{
  "metadata": {
    "timestamp": 1736567085675,
    "page": 675,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "skip2/go-qrcode",
      "stars": 2711,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": "*.sw*\n*.png\n*.directory\nqrcode/qrcode\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0537109375,
          "content": "language: go\n\ngo:\n - 1.7\n\nscript:\n - go test -v ./...\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0302734375,
          "content": "Copyright (c) 2014 Tom Harwood\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.21484375,
          "content": "# go-qrcode #\n\n<img src='https://skip.org/img/nyancat-youtube-qr.png' align='right'>\n\nPackage qrcode implements a QR Code encoder. [![Build Status](https://travis-ci.org/skip2/go-qrcode.svg?branch=master)](https://travis-ci.org/skip2/go-qrcode)\n\nA QR Code is a matrix (two-dimensional) barcode. Arbitrary content may be encoded, with URLs being a popular choice :)\n\nEach QR Code contains error recovery information to aid reading damaged or obscured codes. There are four levels of error recovery: Low, medium, high and highest. QR Codes with a higher recovery level are more robust to damage, at the cost of being physically larger.\n\n## Install\n\n    go get -u github.com/skip2/go-qrcode/...\n\nA command-line tool `qrcode` will be built into `$GOPATH/bin/`.\n\n## Usage\n\n    import qrcode \"github.com/skip2/go-qrcode\"\n\n- **Create a 256x256 PNG image:**\n\n        var png []byte\n        png, err := qrcode.Encode(\"https://example.org\", qrcode.Medium, 256)\n\n- **Create a 256x256 PNG image and write to a file:**\n\n        err := qrcode.WriteFile(\"https://example.org\", qrcode.Medium, 256, \"qr.png\")\n\n- **Create a 256x256 PNG image with custom colors and write to file:**\n\n        err := qrcode.WriteColorFile(\"https://example.org\", qrcode.Medium, 256, color.Black, color.White, \"qr.png\")\n\nAll examples use the qrcode.Medium error Recovery Level and create a fixed 256x256px size QR Code. The last function creates a white on black instead of black on white QR Code.\n\n## Documentation\n\n[![godoc](https://godoc.org/github.com/skip2/go-qrcode?status.png)](https://godoc.org/github.com/skip2/go-qrcode)\n\n## Demoapp\n\n[http://go-qrcode.appspot.com](http://go-qrcode.appspot.com)\n\n## CLI\n\nA command-line tool `qrcode` will be built into `$GOPATH/bin/`.\n\n```\nqrcode -- QR Code encoder in Go\nhttps://github.com/skip2/go-qrcode\n\nFlags:\n  -d\tdisable QR Code border\n  -i\tinvert black and white\n  -o string\n    \tout PNG file prefix, empty for stdout\n  -s int\n    \timage size (pixel) (default 256)\n  -t\tprint as text-art on stdout\n\nUsage:\n  1. Arguments except for flags are joined by \" \" and used to generate QR code.\n     Default output is STDOUT, pipe to imagemagick command \"display\" to display\n     on any X server.\n\n       qrcode hello word | display\n\n  2. Save to file if \"display\" not available:\n\n       qrcode \"homepage: https://github.com/skip2/go-qrcode\" > out.png\n\n```\n## Maximum capacity\nThe maximum capacity of a QR Code varies according to the content encoded and the error recovery level. The maximum capacity is 2,953 bytes, 4,296 alphanumeric characters, 7,089 numeric digits, or a combination of these.\n\n## Borderless QR Codes\n\nTo aid QR Code reading software, QR codes have a built in whitespace border.\n\nIf you know what you're doing, and don't want a border, see https://gist.github.com/skip2/7e3d8a82f5317df9be437f8ec8ec0b7d for how to do it. It's still recommended you include a border manually.\n\n## Links\n\n- [http://en.wikipedia.org/wiki/QR_code](http://en.wikipedia.org/wiki/QR_code)\n- [ISO/IEC 18004:2006](http://www.iso.org/iso/catalogue_detail.htm?csnumber=43655) - Main QR Code specification (approx CHF 198,00)<br>\n- [https://github.com/qpliu/qrencode-go/](https://github.com/qpliu/qrencode-go/) - alternative Go QR encoding library based on [ZXing](https://github.com/zxing/zxing)\n"
        },
        {
          "name": "bitset",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoder.go",
          "type": "blob",
          "size": 11.9619140625,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"errors\"\n\t\"log\"\n\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n)\n\n// Data encoding.\n//\n// The main data portion of a QR Code consists of one or more segments of data.\n// A segment consists of:\n//\n// - The segment Data Mode: numeric, alphanumeric, or byte.\n// - The length of segment in bits.\n// - Encoded data.\n//\n// For example, the string \"123ZZ#!#!\" may be represented as:\n//\n// [numeric, 3, \"123\"] [alphanumeric, 2, \"ZZ\"] [byte, 4, \"#!#!\"]\n//\n// Multiple data modes exist to minimise the size of encoded data. For example,\n// 8-bit bytes require 8 bits to encode each, but base 10 numeric data can be\n// encoded at a higher density of 3 numbers (e.g. 123) per 10 bits.\n//\n// Some data can be represented in multiple modes. Numeric data can be\n// represented in all three modes, whereas alphanumeric data (e.g. 'A') can be\n// represented in alphanumeric and byte mode.\n//\n// Starting a new segment (to use a different Data Mode) has a cost, the bits to\n// state the new segment Data Mode and length. To minimise each QR Code's symbol\n// size, an optimisation routine coalesces segment types where possible, to\n// reduce the encoded data length.\n//\n// There are several other data modes available (e.g. Kanji mode) which are not\n// implemented here.\n\n// A segment encoding mode.\ntype dataMode uint8\n\nconst (\n\t// Each dataMode is a subset of the subsequent dataMode:\n\t// dataModeNone < dataModeNumeric < dataModeAlphanumeric < dataModeByte\n\t//\n\t// This ordering is important for determining which data modes a character can\n\t// be encoded with. E.g. 'E' can be encoded in both dataModeAlphanumeric and\n\t// dataModeByte.\n\tdataModeNone dataMode = 1 << iota\n\tdataModeNumeric\n\tdataModeAlphanumeric\n\tdataModeByte\n)\n\n// dataModeString returns d as a short printable string.\nfunc dataModeString(d dataMode) string {\n\tswitch d {\n\tcase dataModeNone:\n\t\treturn \"none\"\n\tcase dataModeNumeric:\n\t\treturn \"numeric\"\n\tcase dataModeAlphanumeric:\n\t\treturn \"alphanumeric\"\n\tcase dataModeByte:\n\t\treturn \"byte\"\n\t}\n\n\treturn \"unknown\"\n}\n\ntype dataEncoderType uint8\n\nconst (\n\tdataEncoderType1To9 dataEncoderType = iota\n\tdataEncoderType10To26\n\tdataEncoderType27To40\n)\n\n// segment is a single segment of data.\ntype segment struct {\n\t// Data Mode (e.g. numeric).\n\tdataMode dataMode\n\n\t// segment data (e.g. \"abc\").\n\tdata []byte\n}\n\n// A dataEncoder encodes data for a particular QR Code version.\ntype dataEncoder struct {\n\t// Minimum & maximum versions supported.\n\tminVersion int\n\tmaxVersion int\n\n\t// Mode indicator bit sequences.\n\tnumericModeIndicator      *bitset.Bitset\n\talphanumericModeIndicator *bitset.Bitset\n\tbyteModeIndicator         *bitset.Bitset\n\n\t// Character count lengths.\n\tnumNumericCharCountBits      int\n\tnumAlphanumericCharCountBits int\n\tnumByteCharCountBits         int\n\n\t// The raw input data.\n\tdata []byte\n\n\t// The data classified into unoptimised segments.\n\tactual []segment\n\n\t// The data classified into optimised segments.\n\toptimised []segment\n}\n\n// newDataEncoder constructs a dataEncoder.\nfunc newDataEncoder(t dataEncoderType) *dataEncoder {\n\td := &dataEncoder{}\n\n\tswitch t {\n\tcase dataEncoderType1To9:\n\t\td = &dataEncoder{\n\t\t\tminVersion:                   1,\n\t\t\tmaxVersion:                   9,\n\t\t\tnumericModeIndicator:         bitset.New(b0, b0, b0, b1),\n\t\t\talphanumericModeIndicator:    bitset.New(b0, b0, b1, b0),\n\t\t\tbyteModeIndicator:            bitset.New(b0, b1, b0, b0),\n\t\t\tnumNumericCharCountBits:      10,\n\t\t\tnumAlphanumericCharCountBits: 9,\n\t\t\tnumByteCharCountBits:         8,\n\t\t}\n\tcase dataEncoderType10To26:\n\t\td = &dataEncoder{\n\t\t\tminVersion:                   10,\n\t\t\tmaxVersion:                   26,\n\t\t\tnumericModeIndicator:         bitset.New(b0, b0, b0, b1),\n\t\t\talphanumericModeIndicator:    bitset.New(b0, b0, b1, b0),\n\t\t\tbyteModeIndicator:            bitset.New(b0, b1, b0, b0),\n\t\t\tnumNumericCharCountBits:      12,\n\t\t\tnumAlphanumericCharCountBits: 11,\n\t\t\tnumByteCharCountBits:         16,\n\t\t}\n\tcase dataEncoderType27To40:\n\t\td = &dataEncoder{\n\t\t\tminVersion:                   27,\n\t\t\tmaxVersion:                   40,\n\t\t\tnumericModeIndicator:         bitset.New(b0, b0, b0, b1),\n\t\t\talphanumericModeIndicator:    bitset.New(b0, b0, b1, b0),\n\t\t\tbyteModeIndicator:            bitset.New(b0, b1, b0, b0),\n\t\t\tnumNumericCharCountBits:      14,\n\t\t\tnumAlphanumericCharCountBits: 13,\n\t\t\tnumByteCharCountBits:         16,\n\t\t}\n\tdefault:\n\t\tlog.Panic(\"Unknown dataEncoderType\")\n\t}\n\n\treturn d\n}\n\n// encode data as one or more segments and return the encoded data.\n//\n// The returned data does not include the terminator bit sequence.\nfunc (d *dataEncoder) encode(data []byte) (*bitset.Bitset, error) {\n\td.data = data\n\td.actual = nil\n\td.optimised = nil\n\n\tif len(data) == 0 {\n\t\treturn nil, errors.New(\"no data to encode\")\n\t}\n\n\t// Classify data into unoptimised segments.\n\thighestRequiredMode := d.classifyDataModes()\n\n\t// Optimise segments.\n\terr := d.optimiseDataModes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if a single byte encoded segment would be more efficient.\n\toptimizedLength := 0\n\tfor _, s := range d.optimised {\n\t\tlength, err := d.encodedLength(s.dataMode, len(s.data))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\toptimizedLength += length\n\t}\n\n\tsingleByteSegmentLength, err := d.encodedLength(highestRequiredMode, len(d.data))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif singleByteSegmentLength <= optimizedLength {\n\t\td.optimised = []segment{segment{dataMode: highestRequiredMode, data: d.data}}\n\t}\n\n\t// Encode data.\n\tencoded := bitset.New()\n\tfor _, s := range d.optimised {\n\t\td.encodeDataRaw(s.data, s.dataMode, encoded)\n\t}\n\n\treturn encoded, nil\n}\n\n// classifyDataModes classifies the raw data into unoptimised segments.\n// e.g. \"123ZZ#!#!\" =>\n// [numeric, 3, \"123\"] [alphanumeric, 2, \"ZZ\"] [byte, 4, \"#!#!\"].\n//\n// Returns the highest data mode needed to encode the data. e.g. for a mixed\n// numeric/alphanumeric input, the highest is alphanumeric.\n//\n// dataModeNone < dataModeNumeric < dataModeAlphanumeric < dataModeByte\nfunc (d *dataEncoder) classifyDataModes() dataMode {\n\tvar start int\n\tmode := dataModeNone\n\thighestRequiredMode := mode\n\n\tfor i, v := range d.data {\n\t\tnewMode := dataModeNone\n\t\tswitch {\n\t\tcase v >= 0x30 && v <= 0x39:\n\t\t\tnewMode = dataModeNumeric\n\t\tcase v == 0x20 || v == 0x24 || v == 0x25 || v == 0x2a || v == 0x2b || v ==\n\t\t\t0x2d || v == 0x2e || v == 0x2f || v == 0x3a || (v >= 0x41 && v <= 0x5a):\n\t\t\tnewMode = dataModeAlphanumeric\n\t\tdefault:\n\t\t\tnewMode = dataModeByte\n\t\t}\n\n\t\tif newMode != mode {\n\t\t\tif i > 0 {\n\t\t\t\td.actual = append(d.actual, segment{dataMode: mode, data: d.data[start:i]})\n\n\t\t\t\tstart = i\n\t\t\t}\n\n\t\t\tmode = newMode\n\t\t}\n\n\t\tif newMode > highestRequiredMode {\n\t\t\thighestRequiredMode = newMode\n\t\t}\n\t}\n\n\td.actual = append(d.actual, segment{dataMode: mode, data: d.data[start:len(d.data)]})\n\n\treturn highestRequiredMode\n}\n\n// optimiseDataModes optimises the list of segments to reduce the overall output\n// encoded data length.\n//\n// The algorithm coalesces adjacent segments. segments are only coalesced when\n// the Data Modes are compatible, and when the coalesced segment has a shorter\n// encoded length than separate segments.\n//\n// Multiple segments may be coalesced. For example a string of alternating\n// alphanumeric/numeric segments ANANANANA can be optimised to just A.\nfunc (d *dataEncoder) optimiseDataModes() error {\n\tfor i := 0; i < len(d.actual); {\n\t\tmode := d.actual[i].dataMode\n\t\tnumChars := len(d.actual[i].data)\n\n\t\tj := i + 1\n\t\tfor j < len(d.actual) {\n\t\t\tnextNumChars := len(d.actual[j].data)\n\t\t\tnextMode := d.actual[j].dataMode\n\n\t\t\tif nextMode > mode {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tcoalescedLength, err := d.encodedLength(mode, numChars+nextNumChars)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tseperateLength1, err := d.encodedLength(mode, numChars)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tseperateLength2, err := d.encodedLength(nextMode, nextNumChars)\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif coalescedLength < seperateLength1+seperateLength2 {\n\t\t\t\tj++\n\t\t\t\tnumChars += nextNumChars\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\toptimised := segment{dataMode: mode,\n\t\t\tdata: make([]byte, 0, numChars)}\n\n\t\tfor k := i; k < j; k++ {\n\t\t\toptimised.data = append(optimised.data, d.actual[k].data...)\n\t\t}\n\n\t\td.optimised = append(d.optimised, optimised)\n\n\t\ti = j\n\t}\n\n\treturn nil\n}\n\n// encodeDataRaw encodes data in dataMode. The encoded data is appended to\n// encoded.\nfunc (d *dataEncoder) encodeDataRaw(data []byte, dataMode dataMode, encoded *bitset.Bitset) {\n\tmodeIndicator := d.modeIndicator(dataMode)\n\tcharCountBits := d.charCountBits(dataMode)\n\n\t// Append mode indicator.\n\tencoded.Append(modeIndicator)\n\n\t// Append character count.\n\tencoded.AppendUint32(uint32(len(data)), charCountBits)\n\n\t// Append data.\n\tswitch dataMode {\n\tcase dataModeNumeric:\n\t\tfor i := 0; i < len(data); i += 3 {\n\t\t\tcharsRemaining := len(data) - i\n\n\t\t\tvar value uint32\n\t\t\tbitsUsed := 1\n\n\t\t\tfor j := 0; j < charsRemaining && j < 3; j++ {\n\t\t\t\tvalue *= 10\n\t\t\t\tvalue += uint32(data[i+j] - 0x30)\n\t\t\t\tbitsUsed += 3\n\t\t\t}\n\t\t\tencoded.AppendUint32(value, bitsUsed)\n\t\t}\n\tcase dataModeAlphanumeric:\n\t\tfor i := 0; i < len(data); i += 2 {\n\t\t\tcharsRemaining := len(data) - i\n\n\t\t\tvar value uint32\n\t\t\tfor j := 0; j < charsRemaining && j < 2; j++ {\n\t\t\t\tvalue *= 45\n\t\t\t\tvalue += encodeAlphanumericCharacter(data[i+j])\n\t\t\t}\n\n\t\t\tbitsUsed := 6\n\t\t\tif charsRemaining > 1 {\n\t\t\t\tbitsUsed = 11\n\t\t\t}\n\n\t\t\tencoded.AppendUint32(value, bitsUsed)\n\t\t}\n\tcase dataModeByte:\n\t\tfor _, b := range data {\n\t\t\tencoded.AppendByte(b, 8)\n\t\t}\n\t}\n}\n\n// modeIndicator returns the segment header bits for a segment of type dataMode.\nfunc (d *dataEncoder) modeIndicator(dataMode dataMode) *bitset.Bitset {\n\tswitch dataMode {\n\tcase dataModeNumeric:\n\t\treturn d.numericModeIndicator\n\tcase dataModeAlphanumeric:\n\t\treturn d.alphanumericModeIndicator\n\tcase dataModeByte:\n\t\treturn d.byteModeIndicator\n\tdefault:\n\t\tlog.Panic(\"Unknown data mode\")\n\t}\n\n\treturn nil\n}\n\n// charCountBits returns the number of bits used to encode the length of a data\n// segment of type dataMode.\nfunc (d *dataEncoder) charCountBits(dataMode dataMode) int {\n\tswitch dataMode {\n\tcase dataModeNumeric:\n\t\treturn d.numNumericCharCountBits\n\tcase dataModeAlphanumeric:\n\t\treturn d.numAlphanumericCharCountBits\n\tcase dataModeByte:\n\t\treturn d.numByteCharCountBits\n\tdefault:\n\t\tlog.Panic(\"Unknown data mode\")\n\t}\n\n\treturn 0\n}\n\n// encodedLength returns the number of bits required to encode n symbols in\n// dataMode.\n//\n// The number of bits required is affected by:\n//\t- QR code type - Mode Indicator length.\n//\t- Data mode - number of bits used to represent data length.\n//\t- Data mode - how the data is encoded.\n//\t- Number of symbols encoded.\n//\n// An error is returned if the mode is not supported, or the length requested is\n// too long to be represented.\nfunc (d *dataEncoder) encodedLength(dataMode dataMode, n int) (int, error) {\n\tmodeIndicator := d.modeIndicator(dataMode)\n\tcharCountBits := d.charCountBits(dataMode)\n\n\tif modeIndicator == nil {\n\t\treturn 0, errors.New(\"mode not supported\")\n\t}\n\n\tmaxLength := (1 << uint8(charCountBits)) - 1\n\n\tif n > maxLength {\n\t\treturn 0, errors.New(\"length too long to be represented\")\n\t}\n\n\tlength := modeIndicator.Len() + charCountBits\n\n\tswitch dataMode {\n\tcase dataModeNumeric:\n\t\tlength += 10 * (n / 3)\n\n\t\tif n%3 != 0 {\n\t\t\tlength += 1 + 3*(n%3)\n\t\t}\n\tcase dataModeAlphanumeric:\n\t\tlength += 11 * (n / 2)\n\t\tlength += 6 * (n % 2)\n\tcase dataModeByte:\n\t\tlength += 8 * n\n\t}\n\n\treturn length, nil\n}\n\n// encodeAlphanumericChar returns the QR Code encoded value of v.\n//\n// v must be a QR Code defined alphanumeric character: 0-9, A-Z, SP, $%*+-./ or\n// :. The characters are mapped to values in the range 0-44 respectively.\nfunc encodeAlphanumericCharacter(v byte) uint32 {\n\tc := uint32(v)\n\n\tswitch {\n\tcase c >= '0' && c <= '9':\n\t\t// 0-9 encoded as 0-9.\n\t\treturn c - '0'\n\tcase c >= 'A' && c <= 'Z':\n\t\t// A-Z encoded as 10-35.\n\t\treturn c - 'A' + 10\n\tcase c == ' ':\n\t\treturn 36\n\tcase c == '$':\n\t\treturn 37\n\tcase c == '%':\n\t\treturn 38\n\tcase c == '*':\n\t\treturn 39\n\tcase c == '+':\n\t\treturn 40\n\tcase c == '-':\n\t\treturn 41\n\tcase c == '.':\n\t\treturn 42\n\tcase c == '/':\n\t\treturn 43\n\tcase c == ':':\n\t\treturn 44\n\tdefault:\n\t\tlog.Panicf(\"encodeAlphanumericCharacter() with non alphanumeric char %v.\", v)\n\t}\n\n\treturn 0\n}\n"
        },
        {
          "name": "encoder_test.go",
          "type": "blob",
          "size": 8.498046875,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n)\n\nfunc TestClassifyDataMode(t *testing.T) {\n\ttype Test struct {\n\t}\n\n\ttests := []struct {\n\t\tdata   []byte\n\t\tactual []segment\n\t}{\n\t\t{\n\t\t\t[]byte{0x30},\n\t\t\t[]segment{\n\t\t\t\t{\n\t\t\t\t\tdataModeNumeric,\n\t\t\t\t\t[]byte{0x30},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t[]byte{0x30, 0x41, 0x42, 0x43, 0x20, 0x00, 0xf0, 0xf1, 0xf2, 0x31},\n\t\t\t[]segment{\n\t\t\t\t{\n\t\t\t\t\tdataModeNumeric,\n\t\t\t\t\t[]byte{0x30},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdataModeAlphanumeric,\n\t\t\t\t\t[]byte{0x41, 0x42, 0x43, 0x20},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdataModeByte,\n\t\t\t\t\t[]byte{0x00, 0xf0, 0xf1, 0xf2},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdataModeNumeric,\n\t\t\t\t\t[]byte{0x31},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tencoder := newDataEncoder(dataEncoderType1To9)\n\t\tencoder.encode(test.data)\n\n\t\tif !reflect.DeepEqual(test.actual, encoder.actual) {\n\t\t\tt.Errorf(\"Got %v, expected %v\", encoder.actual, test.actual)\n\t\t}\n\t}\n}\n\nfunc TestByteModeLengthCalculations(t *testing.T) {\n\ttests := []struct {\n\t\tdataEncoderType dataEncoderType\n\t\tdataMode        dataMode\n\t\tnumSymbols      int\n\t\texpectedLength  int\n\t}{}\n\n\tfor i, test := range tests {\n\t\tencoder := newDataEncoder(test.dataEncoderType)\n\t\tvar resultLength int\n\n\t\tresultLength, err := encoder.encodedLength(test.dataMode, test.numSymbols)\n\n\t\tif test.expectedLength == -1 {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Test %d: got length %d, expected error\", i, resultLength)\n\t\t\t}\n\t\t} else if resultLength != test.expectedLength {\n\t\t\tt.Errorf(\"Test %d: got length %d, expected length %d\", i, resultLength,\n\t\t\t\ttest.expectedLength)\n\t\t}\n\t}\n}\n\nfunc TestSingleModeEncodings(t *testing.T) {\n\ttests := []struct {\n\t\tdataEncoderType dataEncoderType\n\t\tdataMode        dataMode\n\t\tdata            string\n\t\texpected        *bitset.Bitset\n\t}{\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\tdataModeNumeric,\n\t\t\t\"01234567\",\n\t\t\tbitset.NewFromBase2String(\"0001 0000001000 0000001100 0101011001 1000011\"),\n\t\t},\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\tdataModeAlphanumeric,\n\t\t\t\"AC-42\",\n\t\t\tbitset.NewFromBase2String(\"0010 000000101 00111001110 11100111001 000010\"),\n\t\t},\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\tdataModeByte,\n\t\t\t\"123\",\n\t\t\tbitset.NewFromBase2String(\"0100 00000011 00110001 00110010 00110011\"),\n\t\t},\n\t\t{\n\t\t\tdataEncoderType10To26,\n\t\t\tdataModeByte,\n\t\t\t\"123\",\n\t\t\tbitset.NewFromBase2String(\"0100 00000000 00000011 00110001 00110010 00110011\"),\n\t\t},\n\t\t{\n\t\t\tdataEncoderType27To40,\n\t\t\tdataModeByte,\n\t\t\t\"123\",\n\t\t\tbitset.NewFromBase2String(\"0100 00000000 00000011 00110001 00110010 00110011\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tencoder := newDataEncoder(test.dataEncoderType)\n\t\tencoded := bitset.New()\n\n\t\tencoder.encodeDataRaw([]byte(test.data), test.dataMode, encoded)\n\n\t\tif !test.expected.Equals(encoded) {\n\t\t\tt.Errorf(\"For %s got %s, expected %s\", test.data, encoded.String(),\n\t\t\t\ttest.expected.String())\n\t\t}\n\t}\n}\n\ntype testModeSegment struct {\n\tdataMode dataMode\n\tnumChars int\n}\n\nfunc TestOptimiseEncoding(t *testing.T) {\n\ttests := []struct {\n\t\tdataEncoderType dataEncoderType\n\t\tactual          []testModeSegment\n\t\toptimised       []testModeSegment\n\t}{\n\t\t// Coalescing multiple segments.\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 1}, // length = 4 + 9 + 6 = 19 bits\n\t\t\t\t{dataModeNumeric, 1},      // length = 4 + 10 + 4 = 18 bits\n\t\t\t\t{dataModeAlphanumeric, 1}, // 19 bits.\n\t\t\t\t{dataModeNumeric, 1},      // 18 bits.\n\t\t\t\t{dataModeAlphanumeric, 1}, // 19 bits.\n\t\t\t\t// total = 93 bits.\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 5}, // length = 4 + 9 + 22 + 6 = 41.\n\t\t\t},\n\t\t},\n\t\t// Coalesing not necessary.\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeNumeric, 20},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeNumeric, 20},\n\t\t\t},\n\t\t},\n\t\t// Switch to more general dataMode.\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 100},\n\t\t\t\t{dataModeByte, 1},\n\t\t\t\t{dataModeNumeric, 1},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 100},\n\t\t\t\t{dataModeByte, 2},\n\t\t\t},\n\t\t},\n\t\t// Sometimes encoding everything as bytes is more efficient.\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeByte, 1},\n\t\t\t\t{dataModeNumeric, 1},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 3},\n\t\t\t},\n\t\t},\n\t\t// https://www.google.com/123456789012345678901234567890\n\t\t// BBBBBAAABBBABBBBBBABBBANNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 5},\n\t\t\t\t{dataModeAlphanumeric, 3},\n\t\t\t\t{dataModeByte, 3},\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeByte, 6},\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeAlphanumeric, 4},\n\t\t\t\t{dataModeNumeric, 30},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 23},\n\t\t\t\t{dataModeNumeric, 30},\n\t\t\t},\n\t\t},\n\t\t// https://www.google.com/123\n\t\t// BBBBBAAABBBABBBBBBABBBANNN\n\t\t// Small segments are inefficient because of additional metadata.\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 5},\n\t\t\t\t{dataModeAlphanumeric, 3},\n\t\t\t\t{dataModeByte, 3},\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeByte, 6},\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeAlphanumeric, 4},\n\t\t\t\t{dataModeNumeric, 3},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 26},\n\t\t\t},\n\t\t},\n\t\t// HTTPS://WWW.GOOGLE.COM/123\n\t\t// AAAAAAAAAAAAAAAAAAAAAAANNN\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 23},\n\t\t\t\t{dataModeNumeric, 3},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 26},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdataEncoderType27To40,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 1},\n\t\t\t\t{dataModeNumeric, 1},\n\t\t\t\t{dataModeByte, 1},\n\t\t\t\t{dataModeNumeric, 1},\n\t\t\t\t{dataModeByte, 1},\n\t\t\t\t{dataModeNumeric, 1},\n\t\t\t\t{dataModeByte, 1},\n\t\t\t\t{dataModeNumeric, 1},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeByte, 8},\n\t\t\t},\n\t\t},\n\t\t// HTTPS://ABC.DE/Q/393AABB6998877XYZ0518AUQCRVJN25\n\t\t// AAAAAAAAAAAAAAAAANNNAAAANNNNNNNAAANNNNAAAAAAAANN\n\t\t// different to below---------^--------------------\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 17},\n\t\t\t\t{dataModeNumeric, 3},\n\t\t\t\t{dataModeAlphanumeric, 4},\n\t\t\t\t{dataModeNumeric, 7},\n\t\t\t\t{dataModeAlphanumeric, 3},\n\t\t\t\t{dataModeNumeric, 4},\n\t\t\t\t{dataModeAlphanumeric, 8},\n\t\t\t\t{dataModeNumeric, 2},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 48},\n\t\t\t},\n\t\t},\n\t\t// HTTPS://ABC.DE/Q/393AABB699E877XYZ0518AUQCRVJN25\n\t\t// AAAAAAAAAAAAAAAAANNNAAAANNNANNNAAANNNNAAAAAAAANN\n\t\t// different to above---------^--------------------\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 17},\n\t\t\t\t{dataModeNumeric, 3},\n\t\t\t\t{dataModeAlphanumeric, 4},\n\t\t\t\t{dataModeNumeric, 3},\n\t\t\t\t{dataModeAlphanumeric, 1},\n\t\t\t\t{dataModeNumeric, 3},\n\t\t\t\t{dataModeAlphanumeric, 3},\n\t\t\t\t{dataModeNumeric, 4},\n\t\t\t\t{dataModeAlphanumeric, 8},\n\t\t\t\t{dataModeNumeric, 2},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeAlphanumeric, 48},\n\t\t\t},\n\t\t},\n\t\t// 0123456789\n\t\t// NNNNNNNNNN\n\t\t{\n\t\t\tdataEncoderType1To9,\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeNumeric, 10},\n\t\t\t},\n\t\t\t[]testModeSegment{\n\t\t\t\t{dataModeNumeric, 10},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tnumTotalChars := 0\n\t\tfor _, v := range test.actual {\n\t\t\tnumTotalChars += v.numChars\n\t\t}\n\n\t\tdata := make([]byte, numTotalChars)\n\n\t\ti := 0\n\t\tfor _, v := range test.actual {\n\t\t\tfor j := 0; j < v.numChars; j++ {\n\t\t\t\tswitch v.dataMode {\n\t\t\t\tcase dataModeNumeric:\n\t\t\t\t\tdata[i] = '1'\n\t\t\t\tcase dataModeAlphanumeric:\n\t\t\t\t\tdata[i] = 'A'\n\t\t\t\tcase dataModeByte:\n\t\t\t\t\tdata[i] = '#'\n\t\t\t\tdefault:\n\t\t\t\t\tt.Fatal(\"Unrecognised data mode\")\n\t\t\t\t}\n\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tencoder := newDataEncoder(test.dataEncoderType)\n\n\t\t_, err := encoder.encode(data)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Got %s, expected valid encoding\", err.Error())\n\t\t} else {\n\t\t\tok := true\n\n\t\t\tif len(encoder.optimised) != len(test.optimised) {\n\t\t\t\tok = false\n\t\t\t} else {\n\t\t\t\tfor i, s := range test.optimised {\n\t\t\t\t\tif encoder.optimised[i].dataMode != s.dataMode ||\n\t\t\t\t\t\tlen(encoder.optimised[i].data) != s.numChars {\n\t\t\t\t\t\tok = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"got %s, expected %s\", segmentsString(encoder.optimised),\n\t\t\t\t\ttestModeSegmentsString(test.optimised))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc testModeSegmentsString(segments []testModeSegment) string {\n\tresult := \"[\"\n\n\tfor i, segment := range segments {\n\t\tif i > 0 {\n\t\t\tresult += \", \"\n\t\t}\n\n\t\tresult += fmt.Sprintf(\"%d*%s\", segment.numChars,\n\t\t\tdataModeString(segment.dataMode))\n\t}\n\n\tresult += \"]\"\n\n\treturn result\n}\n\nfunc segmentsString(segments []segment) string {\n\tresult := \"[\"\n\n\tfor i, segment := range segments {\n\t\tif i > 0 {\n\t\t\tresult += \", \"\n\t\t}\n\n\t\tresult += fmt.Sprintf(\"%d*%s\", len(segment.data),\n\t\t\tdataModeString(segment.dataMode))\n\t}\n\n\tresult += \"]\"\n\n\treturn result\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.1416015625,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n/*\n\tAmendments Thu, 2017-December-14:\n\t- test integration (go test -v)\n\t- idiomatic go code\n*/\npackage qrcode\n\nimport (\n\t\"fmt\"\n\t\"image/color\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestExampleEncode(t *testing.T) {\n\tif png, err := Encode(\"https://example.org\", Medium, 256); err != nil {\n\t\tt.Errorf(\"Error: %s\", err.Error())\n\t} else {\n\t\tfmt.Printf(\"PNG is %d bytes long\", len(png))\n\t}\n}\n\nfunc TestExampleWriteFile(t *testing.T) {\n\tfilename := \"example.png\"\n\tif err := WriteFile(\"https://example.org\", Medium, 256, filename); err != nil {\n\t\tif err = os.Remove(filename); err != nil {\n\t\t\tt.Errorf(\"Error: %s\", err.Error())\n\t\t}\n\t}\n}\n\nfunc TestExampleEncodeWithColourAndWithoutBorder(t *testing.T) {\n\tq, err := New(\"https://example.org\", Medium)\n\tif err != nil {\n\t\tt.Errorf(\"Error: %s\", err)\n\t\treturn\n\t}\n\n\t// Optionally, disable the QR Code border.\n\tq.DisableBorder = true\n\n\t// Optionally, set the colours.\n\tq.ForegroundColor = color.RGBA{R: 0x33, G: 0x33, B: 0x66, A: 0xff}\n\tq.BackgroundColor = color.RGBA{R: 0xef, G: 0xef, B: 0xef, A: 0xff}\n\n\terr = q.WriteFile(256, \"example2.png\")\n\tif err != nil {\n\t\tt.Errorf(\"Error: %s\", err)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/skip2/go-qrcode\n\ngo 1.13\n"
        },
        {
          "name": "qrcode.go",
          "type": "blob",
          "size": 15.3125,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\n/*\nPackage qrcode implements a QR Code encoder.\n\nA QR Code is a matrix (two-dimensional) barcode. Arbitrary content may be\nencoded.\n\nA QR Code contains error recovery information to aid reading damaged or\nobscured codes. There are four levels of error recovery: qrcode.{Low, Medium,\nHigh, Highest}. QR Codes with a higher recovery level are more robust to damage,\nat the cost of being physically larger.\n\nThree functions cover most use cases:\n\n- Create a PNG image:\n\n\tvar png []byte\n\tpng, err := qrcode.Encode(\"https://example.org\", qrcode.Medium, 256)\n\n- Create a PNG image and write to a file:\n\n\terr := qrcode.WriteFile(\"https://example.org\", qrcode.Medium, 256, \"qr.png\")\n\n- Create a PNG image with custom colors and write to file:\n\n\terr := qrcode.WriteColorFile(\"https://example.org\", qrcode.Medium, 256, color.Black, color.White, \"qr.png\")\n\nAll examples use the qrcode.Medium error Recovery Level and create a fixed\n256x256px size QR Code. The last function creates a white on black instead of black\non white QR Code.\n\nTo generate a variable sized image instead, specify a negative size (in place of\nthe 256 above), such as -4 or -5. Larger negative numbers create larger images:\nA size of -5 sets each module (QR Code \"pixel\") to be 5px wide/high.\n\n- Create a PNG image (variable size, with minimum white padding) and write to a file:\n\n\terr := qrcode.WriteFile(\"https://example.org\", qrcode.Medium, -5, \"qr.png\")\n\nThe maximum capacity of a QR Code varies according to the content encoded and\nthe error recovery level. The maximum capacity is 2,953 bytes, 4,296\nalphanumeric characters, 7,089 numeric digits, or a combination of these.\n\nThis package implements a subset of QR Code 2005, as defined in ISO/IEC\n18004:2006.\n*/\npackage qrcode\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/png\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n\treedsolomon \"github.com/skip2/go-qrcode/reedsolomon\"\n)\n\n// Encode a QR Code and return a raw PNG image.\n//\n// size is both the image width and height in pixels. If size is too small then\n// a larger image is silently returned. Negative values for size cause a\n// variable sized image to be returned: See the documentation for Image().\n//\n// To serve over HTTP, remember to send a Content-Type: image/png header.\nfunc Encode(content string, level RecoveryLevel, size int) ([]byte, error) {\n\tvar q *QRCode\n\n\tq, err := New(content, level)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn q.PNG(size)\n}\n\n// WriteFile encodes, then writes a QR Code to the given filename in PNG format.\n//\n// size is both the image width and height in pixels. If size is too small then\n// a larger image is silently written. Negative values for size cause a variable\n// sized image to be written: See the documentation for Image().\nfunc WriteFile(content string, level RecoveryLevel, size int, filename string) error {\n\tvar q *QRCode\n\n\tq, err := New(content, level)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn q.WriteFile(size, filename)\n}\n\n// WriteColorFile encodes, then writes a QR Code to the given filename in PNG format.\n// With WriteColorFile you can also specify the colors you want to use.\n//\n// size is both the image width and height in pixels. If size is too small then\n// a larger image is silently written. Negative values for size cause a variable\n// sized image to be written: See the documentation for Image().\nfunc WriteColorFile(content string, level RecoveryLevel, size int, background,\n\tforeground color.Color, filename string) error {\n\n\tvar q *QRCode\n\n\tq, err := New(content, level)\n\n\tq.BackgroundColor = background\n\tq.ForegroundColor = foreground\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn q.WriteFile(size, filename)\n}\n\n// A QRCode represents a valid encoded QRCode.\ntype QRCode struct {\n\t// Original content encoded.\n\tContent string\n\n\t// QR Code type.\n\tLevel         RecoveryLevel\n\tVersionNumber int\n\n\t// User settable drawing options.\n\tForegroundColor color.Color\n\tBackgroundColor color.Color\n\n\t// Disable the QR Code border.\n\tDisableBorder bool\n\n\tencoder *dataEncoder\n\tversion qrCodeVersion\n\n\tdata   *bitset.Bitset\n\tsymbol *symbol\n\tmask   int\n}\n\n// New constructs a QRCode.\n//\n//\tvar q *qrcode.QRCode\n//\tq, err := qrcode.New(\"my content\", qrcode.Medium)\n//\n// An error occurs if the content is too long.\nfunc New(content string, level RecoveryLevel) (*QRCode, error) {\n\tencoders := []dataEncoderType{dataEncoderType1To9, dataEncoderType10To26,\n\t\tdataEncoderType27To40}\n\n\tvar encoder *dataEncoder\n\tvar encoded *bitset.Bitset\n\tvar chosenVersion *qrCodeVersion\n\tvar err error\n\n\tfor _, t := range encoders {\n\t\tencoder = newDataEncoder(t)\n\t\tencoded, err = encoder.encode([]byte(content))\n\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tchosenVersion = chooseQRCodeVersion(level, encoder, encoded.Len())\n\n\t\tif chosenVersion != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t} else if chosenVersion == nil {\n\t\treturn nil, errors.New(\"content too long to encode\")\n\t}\n\n\tq := &QRCode{\n\t\tContent: content,\n\n\t\tLevel:         level,\n\t\tVersionNumber: chosenVersion.version,\n\n\t\tForegroundColor: color.Black,\n\t\tBackgroundColor: color.White,\n\n\t\tencoder: encoder,\n\t\tdata:    encoded,\n\t\tversion: *chosenVersion,\n\t}\n\n\treturn q, nil\n}\n\n// NewWithForcedVersion constructs a QRCode of a specific version.\n//\n//\tvar q *qrcode.QRCode\n//\tq, err := qrcode.NewWithForcedVersion(\"my content\", 25, qrcode.Medium)\n//\n// An error occurs in case of invalid version.\nfunc NewWithForcedVersion(content string, version int, level RecoveryLevel) (*QRCode, error) {\n\tvar encoder *dataEncoder\n\n\tswitch {\n\tcase version >= 1 && version <= 9:\n\t\tencoder = newDataEncoder(dataEncoderType1To9)\n\tcase version >= 10 && version <= 26:\n\t\tencoder = newDataEncoder(dataEncoderType10To26)\n\tcase version >= 27 && version <= 40:\n\t\tencoder = newDataEncoder(dataEncoderType27To40)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Invalid version %d (expected 1-40 inclusive)\", version)\n\t}\n\n\tvar encoded *bitset.Bitset\n\tencoded, err := encoder.encode([]byte(content))\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchosenVersion := getQRCodeVersion(level, version)\n\n\tif chosenVersion == nil {\n\t\treturn nil, errors.New(\"cannot find QR Code version\")\n\t}\n\n\tif encoded.Len() > chosenVersion.numDataBits() {\n\t\treturn nil, fmt.Errorf(\"Cannot encode QR code: content too large for fixed size QR Code version %d (encoded length is %d bits, maximum length is %d bits)\",\n\t\t\tversion,\n\t\t\tencoded.Len(),\n\t\t\tchosenVersion.numDataBits())\n\t}\n\n\tq := &QRCode{\n\t\tContent: content,\n\n\t\tLevel:         level,\n\t\tVersionNumber: chosenVersion.version,\n\n\t\tForegroundColor: color.Black,\n\t\tBackgroundColor: color.White,\n\n\t\tencoder: encoder,\n\t\tdata:    encoded,\n\t\tversion: *chosenVersion,\n\t}\n\n\treturn q, nil\n}\n\n// Bitmap returns the QR Code as a 2D array of 1-bit pixels.\n//\n// bitmap[y][x] is true if the pixel at (x, y) is set.\n//\n// The bitmap includes the required \"quiet zone\" around the QR Code to aid\n// decoding.\nfunc (q *QRCode) Bitmap() [][]bool {\n\t// Build QR code.\n\tq.encode()\n\n\treturn q.symbol.bitmap()\n}\n\n// Image returns the QR Code as an image.Image.\n//\n// A positive size sets a fixed image width and height (e.g. 256 yields an\n// 256x256px image).\n//\n// Depending on the amount of data encoded, fixed size images can have different\n// amounts of padding (white space around the QR Code). As an alternative, a\n// variable sized image can be generated instead:\n//\n// A negative size causes a variable sized image to be returned. The image\n// returned is the minimum size required for the QR Code. Choose a larger\n// negative number to increase the scale of the image. e.g. a size of -5 causes\n// each module (QR Code \"pixel\") to be 5px in size.\nfunc (q *QRCode) Image(size int) image.Image {\n\t// Build QR code.\n\tq.encode()\n\n\t// Minimum pixels (both width and height) required.\n\trealSize := q.symbol.size\n\n\t// Variable size support.\n\tif size < 0 {\n\t\tsize = size * -1 * realSize\n\t}\n\n\t// Actual pixels available to draw the symbol. Automatically increase the\n\t// image size if it's not large enough.\n\tif size < realSize {\n\t\tsize = realSize\n\t}\n\n\t// Output image.\n\trect := image.Rectangle{Min: image.Point{0, 0}, Max: image.Point{size, size}}\n\n\t// Saves a few bytes to have them in this order\n\tp := color.Palette([]color.Color{q.BackgroundColor, q.ForegroundColor})\n\timg := image.NewPaletted(rect, p)\n\tfgClr := uint8(img.Palette.Index(q.ForegroundColor))\n\n\t// QR code bitmap.\n\tbitmap := q.symbol.bitmap()\n\n\t// Map each image pixel to the nearest QR code module.\n\tmodulesPerPixel := float64(realSize) / float64(size)\n\tfor y := 0; y < size; y++ {\n\t\ty2 := int(float64(y) * modulesPerPixel)\n\t\tfor x := 0; x < size; x++ {\n\t\t\tx2 := int(float64(x) * modulesPerPixel)\n\n\t\t\tv := bitmap[y2][x2]\n\n\t\t\tif v {\n\t\t\t\tpos := img.PixOffset(x, y)\n\t\t\t\timg.Pix[pos] = fgClr\n\t\t\t}\n\t\t}\n\t}\n\n\treturn img\n}\n\n// PNG returns the QR Code as a PNG image.\n//\n// size is both the image width and height in pixels. If size is too small then\n// a larger image is silently returned. Negative values for size cause a\n// variable sized image to be returned: See the documentation for Image().\nfunc (q *QRCode) PNG(size int) ([]byte, error) {\n\timg := q.Image(size)\n\n\tencoder := png.Encoder{CompressionLevel: png.BestCompression}\n\n\tvar b bytes.Buffer\n\terr := encoder.Encode(&b, img)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b.Bytes(), nil\n}\n\n// Write writes the QR Code as a PNG image to io.Writer.\n//\n// size is both the image width and height in pixels. If size is too small then\n// a larger image is silently written. Negative values for size cause a\n// variable sized image to be written: See the documentation for Image().\nfunc (q *QRCode) Write(size int, out io.Writer) error {\n\tvar png []byte\n\n\tpng, err := q.PNG(size)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = out.Write(png)\n\treturn err\n}\n\n// WriteFile writes the QR Code as a PNG image to the specified file.\n//\n// size is both the image width and height in pixels. If size is too small then\n// a larger image is silently written. Negative values for size cause a\n// variable sized image to be written: See the documentation for Image().\nfunc (q *QRCode) WriteFile(size int, filename string) error {\n\tvar png []byte\n\n\tpng, err := q.PNG(size)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn ioutil.WriteFile(filename, png, os.FileMode(0644))\n}\n\n// encode completes the steps required to encode the QR Code. These include\n// adding the terminator bits and padding, splitting the data into blocks and\n// applying the error correction, and selecting the best data mask.\nfunc (q *QRCode) encode() {\n\tnumTerminatorBits := q.version.numTerminatorBitsRequired(q.data.Len())\n\n\tq.addTerminatorBits(numTerminatorBits)\n\tq.addPadding()\n\n\tencoded := q.encodeBlocks()\n\n\tconst numMasks int = 8\n\tpenalty := 0\n\n\tfor mask := 0; mask < numMasks; mask++ {\n\t\tvar s *symbol\n\t\tvar err error\n\n\t\ts, err = buildRegularSymbol(q.version, mask, encoded, !q.DisableBorder)\n\n\t\tif err != nil {\n\t\t\tlog.Panic(err.Error())\n\t\t}\n\n\t\tnumEmptyModules := s.numEmptyModules()\n\t\tif numEmptyModules != 0 {\n\t\t\tlog.Panicf(\"bug: numEmptyModules is %d (expected 0) (version=%d)\",\n\t\t\t\tnumEmptyModules, q.VersionNumber)\n\t\t}\n\n\t\tp := s.penaltyScore()\n\n\t\t//log.Printf(\"mask=%d p=%3d p1=%3d p2=%3d p3=%3d p4=%d\\n\", mask, p, s.penalty1(), s.penalty2(), s.penalty3(), s.penalty4())\n\n\t\tif q.symbol == nil || p < penalty {\n\t\t\tq.symbol = s\n\t\t\tq.mask = mask\n\t\t\tpenalty = p\n\t\t}\n\t}\n}\n\n// addTerminatorBits adds final terminator bits to the encoded data.\n//\n// The number of terminator bits required is determined when the QR Code version\n// is chosen (which itself depends on the length of the data encoded). The\n// terminator bits are thus added after the QR Code version\n// is chosen, rather than at the data encoding stage.\nfunc (q *QRCode) addTerminatorBits(numTerminatorBits int) {\n\tq.data.AppendNumBools(numTerminatorBits, false)\n}\n\n// encodeBlocks takes the completed (terminated & padded) encoded data, splits\n// the data into blocks (as specified by the QR Code version), applies error\n// correction to each block, then interleaves the blocks together.\n//\n// The QR Code's final data sequence is returned.\nfunc (q *QRCode) encodeBlocks() *bitset.Bitset {\n\t// Split into blocks.\n\ttype dataBlock struct {\n\t\tdata          *bitset.Bitset\n\t\tecStartOffset int\n\t}\n\n\tblock := make([]dataBlock, q.version.numBlocks())\n\n\tstart := 0\n\tend := 0\n\tblockID := 0\n\n\tfor _, b := range q.version.block {\n\t\tfor j := 0; j < b.numBlocks; j++ {\n\t\t\tstart = end\n\t\t\tend = start + b.numDataCodewords*8\n\n\t\t\t// Apply error correction to each block.\n\t\t\tnumErrorCodewords := b.numCodewords - b.numDataCodewords\n\t\t\tblock[blockID].data = reedsolomon.Encode(q.data.Substr(start, end), numErrorCodewords)\n\t\t\tblock[blockID].ecStartOffset = end - start\n\n\t\t\tblockID++\n\t\t}\n\t}\n\n\t// Interleave the blocks.\n\n\tresult := bitset.New()\n\n\t// Combine data blocks.\n\tworking := true\n\tfor i := 0; working; i += 8 {\n\t\tworking = false\n\n\t\tfor j, b := range block {\n\t\t\tif i >= block[j].ecStartOffset {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresult.Append(b.data.Substr(i, i+8))\n\n\t\t\tworking = true\n\t\t}\n\t}\n\n\t// Combine error correction blocks.\n\tworking = true\n\tfor i := 0; working; i += 8 {\n\t\tworking = false\n\n\t\tfor j, b := range block {\n\t\t\toffset := i + block[j].ecStartOffset\n\t\t\tif offset >= block[j].data.Len() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresult.Append(b.data.Substr(offset, offset+8))\n\n\t\t\tworking = true\n\t\t}\n\t}\n\n\t// Append remainder bits.\n\tresult.AppendNumBools(q.version.numRemainderBits, false)\n\n\treturn result\n}\n\n// max returns the maximum of a and b.\nfunc max(a int, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\n\treturn b\n}\n\n// addPadding pads the encoded data upto the full length required.\nfunc (q *QRCode) addPadding() {\n\tnumDataBits := q.version.numDataBits()\n\n\tif q.data.Len() == numDataBits {\n\t\treturn\n\t}\n\n\t// Pad to the nearest codeword boundary.\n\tq.data.AppendNumBools(q.version.numBitsToPadToCodeword(q.data.Len()), false)\n\n\t// Pad codewords 0b11101100 and 0b00010001.\n\tpadding := [2]*bitset.Bitset{\n\t\tbitset.New(true, true, true, false, true, true, false, false),\n\t\tbitset.New(false, false, false, true, false, false, false, true),\n\t}\n\n\t// Insert pad codewords alternately.\n\ti := 0\n\tfor numDataBits-q.data.Len() >= 8 {\n\t\tq.data.Append(padding[i])\n\n\t\ti = 1 - i // Alternate between 0 and 1.\n\t}\n\n\tif q.data.Len() != numDataBits {\n\t\tlog.Panicf(\"BUG: got len %d, expected %d\", q.data.Len(), numDataBits)\n\t}\n}\n\n// ToString produces a multi-line string that forms a QR-code image.\nfunc (q *QRCode) ToString(inverseColor bool) string {\n\tbits := q.Bitmap()\n\tvar buf bytes.Buffer\n\tfor y := range bits {\n\t\tfor x := range bits[y] {\n\t\t\tif bits[y][x] != inverseColor {\n\t\t\t\tbuf.WriteString(\"  \")\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(\"██\")\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\treturn buf.String()\n}\n\n// ToSmallString produces a multi-line string that forms a QR-code image, a\n// factor two smaller in x and y then ToString.\nfunc (q *QRCode) ToSmallString(inverseColor bool) string {\n\tbits := q.Bitmap()\n\tvar buf bytes.Buffer\n\t// if there is an odd number of rows, the last one needs special treatment\n\tfor y := 0; y < len(bits)-1; y += 2 {\n\t\tfor x := range bits[y] {\n\t\t\tif bits[y][x] == bits[y+1][x] {\n\t\t\t\tif bits[y][x] != inverseColor {\n\t\t\t\t\tbuf.WriteString(\" \")\n\t\t\t\t} else {\n\t\t\t\t\tbuf.WriteString(\"█\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif bits[y][x] != inverseColor {\n\t\t\t\t\tbuf.WriteString(\"▄\")\n\t\t\t\t} else {\n\t\t\t\t\tbuf.WriteString(\"▀\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\t// special treatment for the last row if odd\n\tif len(bits)%2 == 1 {\n\t\ty := len(bits) - 1\n\t\tfor x := range bits[y] {\n\t\t\tif bits[y][x] != inverseColor {\n\t\t\t\tbuf.WriteString(\" \")\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(\"▀\")\n\t\t\t}\n\t\t}\n\t\tbuf.WriteString(\"\\n\")\n\t}\n\treturn buf.String()\n}\n"
        },
        {
          "name": "qrcode",
          "type": "tree",
          "content": null
        },
        {
          "name": "qrcode_decode_test.go",
          "type": "blob",
          "size": 3.9794921875,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// These tests use zbarimg to decode generated QR Codes to ensure they are\n// readable. sudo apt-get install zbar-tools, or download from\n// http://zbar.sourceforge.net.\n//\n// By default these tests are disabled to avoid a dependency on zbarimg if\n// you're not running the tests. Use the -test-decode flag (go test\n// -test-decode) to enable.\n\nvar testDecode *bool = flag.Bool(\"test-decode\",\n\tfalse,\n\t\"Enable decode tests. Requires zbarimg installed.\")\n\nvar testDecodeFuzz *bool = flag.Bool(\"test-decode-fuzz\",\n\tfalse,\n\t\"Enable decode fuzz tests. Requires zbarimg installed.\")\n\nfunc TestDecodeBasic(t *testing.T) {\n\tif !*testDecode {\n\t\tt.Skip(\"Decode tests not enabled\")\n\t}\n\n\ttests := []struct {\n\t\tcontent        string\n\t\tnumRepetitions int\n\t\tlevel          RecoveryLevel\n\t}{\n\t\t{\n\t\t\t\"A\",\n\t\t\t1,\n\t\t\tLow,\n\t\t},\n\t\t{\n\t\t\t\"A\",\n\t\t\t1,\n\t\t\tMedium,\n\t\t},\n\t\t{\n\t\t\t\"A\",\n\t\t\t1,\n\t\t\tHigh,\n\t\t},\n\t\t{\n\t\t\t\"A\",\n\t\t\t1,\n\t\t\tHighest,\n\t\t},\n\t\t{\n\t\t\t\"01234567\",\n\t\t\t1,\n\t\t\tMedium,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tcontent := strings.Repeat(test.content, test.numRepetitions)\n\n\t\tq, err := New(content, test.level)\n\t\tif err != nil {\n\t\t\tt.Error(err.Error())\n\t\t}\n\n\t\terr = zbarimgCheck(q)\n\n\t\tif err != nil {\n\t\t\tt.Error(err.Error())\n\t\t}\n\t}\n}\n\nfunc TestDecodeAllVersionLevels(t *testing.T) {\n\tif !*testDecode {\n\t\tt.Skip(\"Decode tests not enabled\")\n\t}\n\n\tfor version := 1; version <= 40; version++ {\n\t\tfor _, level := range []RecoveryLevel{Low, Medium, High, Highest} {\n\t\t\tt.Logf(\"Version=%d Level=%d\",\n\t\t\t\tversion,\n\t\t\t\tlevel)\n\n\t\t\tq, err := NewWithForcedVersion(\n\t\t\t\tfmt.Sprintf(\"v-%d l-%d\", version, level), version, level)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terr = zbarimgCheck(q)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Version=%d Level=%d, err=%s, expected success\",\n\t\t\t\t\tversion,\n\t\t\t\t\tlevel,\n\t\t\t\t\terr.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDecodeAllCharacters(t *testing.T) {\n\tif !*testDecode {\n\t\tt.Skip(\"Decode tests not enabled\")\n\t}\n\n\tvar content string\n\n\t// zbarimg has trouble with null bytes, hence start from ASCII 1.\n\tfor i := 1; i < 256; i++ {\n\t\tcontent += string(i)\n\t}\n\n\tq, err := New(content, Low)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\terr = zbarimgCheck(q)\n\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n}\n\nfunc TestDecodeFuzz(t *testing.T) {\n\tif !*testDecodeFuzz {\n\t\tt.Skip(\"Decode fuzz tests not enabled\")\n\t}\n\n\tr := rand.New(rand.NewSource(0))\n\n\tconst iterations int = 32\n\tconst maxLength int = 128\n\n\tfor i := 0; i < iterations; i++ {\n\t\tlen := r.Intn(maxLength-1) + 1\n\n\t\tvar content string\n\t\tfor j := 0; j < len; j++ {\n\t\t\t// zbarimg seems to have trouble with special characters, test printable\n\t\t\t// characters only for now.\n\t\t\tcontent += string(32 + r.Intn(94))\n\t\t}\n\n\t\tfor _, level := range []RecoveryLevel{Low, Medium, High, Highest} {\n\t\t\tq, err := New(content, level)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err.Error())\n\t\t\t}\n\n\t\t\terr = zbarimgCheck(q)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err.Error())\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc zbarimgCheck(q *QRCode) error {\n\ts, err := zbarimgDecode(q)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif s != q.Content {\n\t\tq.WriteFile(256, fmt.Sprintf(\"%x.png\", q.Content))\n\t\treturn fmt.Errorf(\"got '%s' (%x) expected '%s' (%x)\", s, s, q.Content, q.Content)\n\t}\n\n\treturn nil\n}\n\nfunc zbarimgDecode(q *QRCode) (string, error) {\n\tvar png []byte\n\n\t// 512x512px\n\tpng, err := q.PNG(512)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcmd := exec.Command(\"zbarimg\", \"--quiet\", \"-Sdisable\",\n\t\t\"-Sqrcode.enable\", \"-\")\n\n\tvar out bytes.Buffer\n\n\tcmd.Stdin = bytes.NewBuffer(png)\n\tcmd.Stdout = &out\n\n\terr = cmd.Run()\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn strings.TrimSuffix(strings.TrimPrefix(out.String(), \"QR-Code:\"), \"\\n\"), nil\n}\n\nfunc BenchmarkDecodeTest(b *testing.B) {\n\tif !*testDecode {\n\t\tb.Skip(\"Decode benchmarks not enabled\")\n\t}\n\n\tfor n := 0; n < b.N; n++ {\n\t\tq, err := New(\"content\", Medium)\n\t\tif err != nil {\n\t\t\tb.Error(err.Error())\n\t\t}\n\n\t\terr = zbarimgCheck(q)\n\n\t\tif err != nil {\n\t\t\tb.Error(err.Error())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "qrcode_test.go",
          "type": "blob",
          "size": 2.9033203125,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestQRCodeMaxCapacity(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"Skipping TestQRCodeCapacity\")\n\t}\n\n\ttests := []struct {\n\t\tstring         string\n\t\tnumRepetitions int\n\t}{\n\t\t{\n\t\t\t\"0\",\n\t\t\t7089,\n\t\t},\n\t\t{\n\t\t\t\"A\",\n\t\t\t4296,\n\t\t},\n\t\t{\n\t\t\t\"#\",\n\t\t\t2953,\n\t\t},\n\t\t// Alternate byte/numeric data types. Optimises to 2,952 bytes.\n\t\t{\n\t\t\t\"#1\",\n\t\t\t1476,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := New(strings.Repeat(test.string, test.numRepetitions), Low)\n\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%d x '%s' got %s expected success\", test.numRepetitions,\n\t\t\t\ttest.string, err.Error())\n\t\t}\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := New(strings.Repeat(test.string, test.numRepetitions+1), Low)\n\n\t\tif err == nil {\n\t\t\tt.Errorf(\"%d x '%s' chars encodable, expected not encodable\",\n\t\t\t\ttest.numRepetitions+1, test.string)\n\t\t}\n\t}\n}\n\nfunc TestQRCodeVersionCapacity(t *testing.T) {\n\ttests := []struct {\n\t\tversion         int\n\t\tlevel           RecoveryLevel\n\t\tmaxNumeric      int\n\t\tmaxAlphanumeric int\n\t\tmaxByte         int\n\t}{\n\t\t{\n\t\t\t1,\n\t\t\tLow,\n\t\t\t41,\n\t\t\t25,\n\t\t\t17,\n\t\t},\n\t\t{\n\t\t\t2,\n\t\t\tLow,\n\t\t\t77,\n\t\t\t47,\n\t\t\t32,\n\t\t},\n\t\t{\n\t\t\t2,\n\t\t\tHighest,\n\t\t\t34,\n\t\t\t20,\n\t\t\t14,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\tLow,\n\t\t\t7089,\n\t\t\t4296,\n\t\t\t2953,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\tHighest,\n\t\t\t3057,\n\t\t\t1852,\n\t\t\t1273,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tnumericData := strings.Repeat(\"1\", test.maxNumeric)\n\t\talphanumericData := strings.Repeat(\"A\", test.maxAlphanumeric)\n\t\tbyteData := strings.Repeat(\"#\", test.maxByte)\n\n\t\tvar n *QRCode\n\t\tvar a *QRCode\n\t\tvar b *QRCode\n\t\tvar err error\n\n\t\tn, err = New(numericData, test.level)\n\t\tif err != nil {\n\t\t\tt.Fatal(err.Error())\n\t\t}\n\n\t\ta, err = New(alphanumericData, test.level)\n\t\tif err != nil {\n\t\t\tt.Fatal(err.Error())\n\t\t}\n\n\t\tb, err = New(byteData, test.level)\n\t\tif err != nil {\n\t\t\tt.Fatal(err.Error())\n\t\t}\n\n\t\tif n.VersionNumber != test.version {\n\t\t\tt.Fatalf(\"Test #%d numeric has version #%d, expected #%d\", i,\n\t\t\t\tn.VersionNumber, test.version)\n\t\t}\n\n\t\tif a.VersionNumber != test.version {\n\t\t\tt.Fatalf(\"Test #%d alphanumeric has version #%d, expected #%d\", i,\n\t\t\t\ta.VersionNumber, test.version)\n\t\t}\n\n\t\tif b.VersionNumber != test.version {\n\t\t\tt.Fatalf(\"Test #%d byte has version #%d, expected #%d\", i,\n\t\t\t\tb.VersionNumber, test.version)\n\t\t}\n\t}\n}\n\nfunc TestQRCodeISOAnnexIExample(t *testing.T) {\n\tvar q *QRCode\n\tq, err := New(\"01234567\", Medium)\n\n\tif err != nil {\n\t\tt.Fatalf(\"Error producing ISO Annex I Example: %s, expected success\",\n\t\t\terr.Error())\n\t}\n\n\tq.encode()\n\n\tconst expectedMask int = 2\n\n\tif q.mask != 2 {\n\t\tt.Errorf(\"ISO Annex I example mask got %d, expected %d\\n\", q.mask,\n\t\t\texpectedMask)\n\t}\n}\n\nfunc BenchmarkQRCodeURLSize(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tNew(\"http://www.example.org\", Medium)\n\t}\n}\n\nfunc BenchmarkQRCodeMaximumSize(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\t// 7089 is the maximum encodable number of numeric digits.\n\t\tNew(strings.Repeat(\"0\", 7089), Low)\n\t}\n}\n"
        },
        {
          "name": "reedsolomon",
          "type": "tree",
          "content": null
        },
        {
          "name": "regular_symbol.go",
          "type": "blob",
          "size": 6.1748046875,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n)\n\ntype regularSymbol struct {\n\tversion qrCodeVersion\n\tmask    int\n\n\tdata *bitset.Bitset\n\n\tsymbol *symbol\n\tsize   int\n}\n\n// Abbreviated true/false.\nconst (\n\tb0 = false\n\tb1 = true\n)\n\nvar (\n\talignmentPatternCenter = [][]int{\n\t\t{}, // Version 0 doesn't exist.\n\t\t{}, // Version 1 doesn't use alignment patterns.\n\t\t{6, 18},\n\t\t{6, 22},\n\t\t{6, 26},\n\t\t{6, 30},\n\t\t{6, 34},\n\t\t{6, 22, 38},\n\t\t{6, 24, 42},\n\t\t{6, 26, 46},\n\t\t{6, 28, 50},\n\t\t{6, 30, 54},\n\t\t{6, 32, 58},\n\t\t{6, 34, 62},\n\t\t{6, 26, 46, 66},\n\t\t{6, 26, 48, 70},\n\t\t{6, 26, 50, 74},\n\t\t{6, 30, 54, 78},\n\t\t{6, 30, 56, 82},\n\t\t{6, 30, 58, 86},\n\t\t{6, 34, 62, 90},\n\t\t{6, 28, 50, 72, 94},\n\t\t{6, 26, 50, 74, 98},\n\t\t{6, 30, 54, 78, 102},\n\t\t{6, 28, 54, 80, 106},\n\t\t{6, 32, 58, 84, 110},\n\t\t{6, 30, 58, 86, 114},\n\t\t{6, 34, 62, 90, 118},\n\t\t{6, 26, 50, 74, 98, 122},\n\t\t{6, 30, 54, 78, 102, 126},\n\t\t{6, 26, 52, 78, 104, 130},\n\t\t{6, 30, 56, 82, 108, 134},\n\t\t{6, 34, 60, 86, 112, 138},\n\t\t{6, 30, 58, 86, 114, 142},\n\t\t{6, 34, 62, 90, 118, 146},\n\t\t{6, 30, 54, 78, 102, 126, 150},\n\t\t{6, 24, 50, 76, 102, 128, 154},\n\t\t{6, 28, 54, 80, 106, 132, 158},\n\t\t{6, 32, 58, 84, 110, 136, 162},\n\t\t{6, 26, 54, 82, 110, 138, 166},\n\t\t{6, 30, 58, 86, 114, 142, 170},\n\t}\n\n\tfinderPattern = [][]bool{\n\t\t{b1, b1, b1, b1, b1, b1, b1},\n\t\t{b1, b0, b0, b0, b0, b0, b1},\n\t\t{b1, b0, b1, b1, b1, b0, b1},\n\t\t{b1, b0, b1, b1, b1, b0, b1},\n\t\t{b1, b0, b1, b1, b1, b0, b1},\n\t\t{b1, b0, b0, b0, b0, b0, b1},\n\t\t{b1, b1, b1, b1, b1, b1, b1},\n\t}\n\n\tfinderPatternSize = 7\n\n\tfinderPatternHorizontalBorder = [][]bool{\n\t\t{b0, b0, b0, b0, b0, b0, b0, b0},\n\t}\n\n\tfinderPatternVerticalBorder = [][]bool{\n\t\t{b0},\n\t\t{b0},\n\t\t{b0},\n\t\t{b0},\n\t\t{b0},\n\t\t{b0},\n\t\t{b0},\n\t\t{b0},\n\t}\n\n\talignmentPattern = [][]bool{\n\t\t{b1, b1, b1, b1, b1},\n\t\t{b1, b0, b0, b0, b1},\n\t\t{b1, b0, b1, b0, b1},\n\t\t{b1, b0, b0, b0, b1},\n\t\t{b1, b1, b1, b1, b1},\n\t}\n)\n\nfunc buildRegularSymbol(version qrCodeVersion, mask int,\n\tdata *bitset.Bitset, includeQuietZone bool) (*symbol, error) {\n\n\tquietZoneSize := 0\n\tif includeQuietZone {\n\t\tquietZoneSize = version.quietZoneSize()\n\t}\n\n\tm := &regularSymbol{\n\t\tversion: version,\n\t\tmask:    mask,\n\t\tdata:    data,\n\n\t\tsymbol: newSymbol(version.symbolSize(), quietZoneSize),\n\t\tsize:   version.symbolSize(),\n\t}\n\n\tm.addFinderPatterns()\n\tm.addAlignmentPatterns()\n\tm.addTimingPatterns()\n\tm.addFormatInfo()\n\tm.addVersionInfo()\n\n\tok, err := m.addData()\n\tif !ok {\n\t\treturn nil, err\n\t}\n\n\treturn m.symbol, nil\n}\n\nfunc (m *regularSymbol) addFinderPatterns() {\n\tfpSize := finderPatternSize\n\tfp := finderPattern\n\tfpHBorder := finderPatternHorizontalBorder\n\tfpVBorder := finderPatternVerticalBorder\n\n\t// Top left Finder Pattern.\n\tm.symbol.set2dPattern(0, 0, fp)\n\tm.symbol.set2dPattern(0, fpSize, fpHBorder)\n\tm.symbol.set2dPattern(fpSize, 0, fpVBorder)\n\n\t// Top right Finder Pattern.\n\tm.symbol.set2dPattern(m.size-fpSize, 0, fp)\n\tm.symbol.set2dPattern(m.size-fpSize-1, fpSize, fpHBorder)\n\tm.symbol.set2dPattern(m.size-fpSize-1, 0, fpVBorder)\n\n\t// Bottom left Finder Pattern.\n\tm.symbol.set2dPattern(0, m.size-fpSize, fp)\n\tm.symbol.set2dPattern(0, m.size-fpSize-1, fpHBorder)\n\tm.symbol.set2dPattern(fpSize, m.size-fpSize-1, fpVBorder)\n}\n\nfunc (m *regularSymbol) addAlignmentPatterns() {\n\tfor _, x := range alignmentPatternCenter[m.version.version] {\n\t\tfor _, y := range alignmentPatternCenter[m.version.version] {\n\t\t\tif !m.symbol.empty(x, y) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tm.symbol.set2dPattern(x-2, y-2, alignmentPattern)\n\t\t}\n\t}\n}\n\nfunc (m *regularSymbol) addTimingPatterns() {\n\tvalue := true\n\n\tfor i := finderPatternSize + 1; i < m.size-finderPatternSize; i++ {\n\t\tm.symbol.set(i, finderPatternSize-1, value)\n\t\tm.symbol.set(finderPatternSize-1, i, value)\n\n\t\tvalue = !value\n\t}\n}\n\nfunc (m *regularSymbol) addFormatInfo() {\n\tfpSize := finderPatternSize\n\tl := formatInfoLengthBits - 1\n\n\tf := m.version.formatInfo(m.mask)\n\n\t// Bits 0-7, under the top right finder pattern.\n\tfor i := 0; i <= 7; i++ {\n\t\tm.symbol.set(m.size-i-1, fpSize+1, f.At(l-i))\n\t}\n\n\t// Bits 0-5, right of the top left finder pattern.\n\tfor i := 0; i <= 5; i++ {\n\t\tm.symbol.set(fpSize+1, i, f.At(l-i))\n\t}\n\n\t// Bits 6-8 on the corner of the top left finder pattern.\n\tm.symbol.set(fpSize+1, fpSize, f.At(l-6))\n\tm.symbol.set(fpSize+1, fpSize+1, f.At(l-7))\n\tm.symbol.set(fpSize, fpSize+1, f.At(l-8))\n\n\t// Bits 9-14 on the underside of the top left finder pattern.\n\tfor i := 9; i <= 14; i++ {\n\t\tm.symbol.set(14-i, fpSize+1, f.At(l-i))\n\t}\n\n\t// Bits 8-14 on the right side of the bottom left finder pattern.\n\tfor i := 8; i <= 14; i++ {\n\t\tm.symbol.set(fpSize+1, m.size-fpSize+i-8, f.At(l-i))\n\t}\n\n\t// Always dark symbol.\n\tm.symbol.set(fpSize+1, m.size-fpSize-1, true)\n}\n\nfunc (m *regularSymbol) addVersionInfo() {\n\tfpSize := finderPatternSize\n\n\tv := m.version.versionInfo()\n\tl := versionInfoLengthBits - 1\n\n\tif v == nil {\n\t\treturn\n\t}\n\n\tfor i := 0; i < v.Len(); i++ {\n\t\t// Above the bottom left finder pattern.\n\t\tm.symbol.set(i/3, m.size-fpSize-4+i%3, v.At(l-i))\n\n\t\t// Left of the top right finder pattern.\n\t\tm.symbol.set(m.size-fpSize-4+i%3, i/3, v.At(l-i))\n\t}\n}\n\ntype direction uint8\n\nconst (\n\tup direction = iota\n\tdown\n)\n\nfunc (m *regularSymbol) addData() (bool, error) {\n\txOffset := 1\n\tdir := up\n\n\tx := m.size - 2\n\ty := m.size - 1\n\n\tfor i := 0; i < m.data.Len(); i++ {\n\t\tvar mask bool\n\t\tswitch m.mask {\n\t\tcase 0:\n\t\t\tmask = (y+x+xOffset)%2 == 0\n\t\tcase 1:\n\t\t\tmask = y%2 == 0\n\t\tcase 2:\n\t\t\tmask = (x+xOffset)%3 == 0\n\t\tcase 3:\n\t\t\tmask = (y+x+xOffset)%3 == 0\n\t\tcase 4:\n\t\t\tmask = (y/2+(x+xOffset)/3)%2 == 0\n\t\tcase 5:\n\t\t\tmask = (y*(x+xOffset))%2+(y*(x+xOffset))%3 == 0\n\t\tcase 6:\n\t\t\tmask = ((y*(x+xOffset))%2+((y*(x+xOffset))%3))%2 == 0\n\t\tcase 7:\n\t\t\tmask = ((y+x+xOffset)%2+((y*(x+xOffset))%3))%2 == 0\n\t\t}\n\n\t\t// != is equivalent to XOR.\n\t\tm.symbol.set(x+xOffset, y, mask != m.data.At(i))\n\n\t\tif i == m.data.Len()-1 {\n\t\t\tbreak\n\t\t}\n\n\t\t// Find next free bit in the symbol.\n\t\tfor {\n\t\t\tif xOffset == 1 {\n\t\t\t\txOffset = 0\n\t\t\t} else {\n\t\t\t\txOffset = 1\n\n\t\t\t\tif dir == up {\n\t\t\t\t\tif y > 0 {\n\t\t\t\t\t\ty--\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdir = down\n\t\t\t\t\t\tx -= 2\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif y < m.size-1 {\n\t\t\t\t\t\ty++\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdir = up\n\t\t\t\t\t\tx -= 2\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip over the vertical timing pattern entirely.\n\t\t\tif x == 5 {\n\t\t\t\tx--\n\t\t\t}\n\n\t\t\tif m.symbol.empty(x+xOffset, y) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true, nil\n}\n"
        },
        {
          "name": "regular_symbol_test.go",
          "type": "blob",
          "size": 0.470703125,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n)\n\nfunc TestBuildRegularSymbol(t *testing.T) {\n\tfor k := 0; k <= 7; k++ {\n\t\tv := getQRCodeVersion(Low, 1)\n\n\t\tdata := bitset.New()\n\t\tfor i := 0; i < 26; i++ {\n\t\t\tdata.AppendNumBools(8, false)\n\t\t}\n\n\t\ts, err := buildRegularSymbol(*v, k, data, false)\n\n\t\tif err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t} else {\n\t\t\t_ = s\n\t\t\t//fmt.Print(m.string())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "symbol.go",
          "type": "blob",
          "size": 6.810546875,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\n// symbol is a 2D array of bits representing a QR Code symbol.\n//\n// A symbol consists of size*size modules, with each module normally drawn as a\n// black or white square. The symbol also has a border of quietZoneSize modules.\n//\n// A (fictional) size=2, quietZoneSize=1 QR Code looks like:\n//\n// +----+\n// |    |\n// | ab |\n// | cd |\n// |    |\n// +----+\n//\n// For ease of implementation, the functions to set/get bits ignore the border,\n// so (0,0)=a, (0,1)=b, (1,0)=c, and (1,1)=d. The entire symbol (including the\n// border) is returned by bitmap().\n//\ntype symbol struct {\n\t// Value of module at [y][x]. True is set.\n\tmodule [][]bool\n\n\t// True if the module at [y][x] is used (to either true or false).\n\t// Used to identify unused modules.\n\tisUsed [][]bool\n\n\t// Combined width/height of the symbol and quiet zones.\n\t//\n\t// size = symbolSize + 2*quietZoneSize.\n\tsize int\n\n\t// Width/height of the symbol only.\n\tsymbolSize int\n\n\t// Width/height of a single quiet zone.\n\tquietZoneSize int\n}\n\n// newSymbol constructs a symbol of size size*size, with a border of\n// quietZoneSize.\nfunc newSymbol(size int, quietZoneSize int) *symbol {\n\tvar m symbol\n\n\tm.module = make([][]bool, size+2*quietZoneSize)\n\tm.isUsed = make([][]bool, size+2*quietZoneSize)\n\n\tfor i := range m.module {\n\t\tm.module[i] = make([]bool, size+2*quietZoneSize)\n\t\tm.isUsed[i] = make([]bool, size+2*quietZoneSize)\n\t}\n\n\tm.size = size + 2*quietZoneSize\n\tm.symbolSize = size\n\tm.quietZoneSize = quietZoneSize\n\n\treturn &m\n}\n\n// get returns the module value at (x, y).\nfunc (m *symbol) get(x int, y int) (v bool) {\n\tv = m.module[y+m.quietZoneSize][x+m.quietZoneSize]\n\treturn\n}\n\n// empty returns true if the module at (x, y) has not been set (to either true\n// or false).\nfunc (m *symbol) empty(x int, y int) bool {\n\treturn !m.isUsed[y+m.quietZoneSize][x+m.quietZoneSize]\n}\n\n// numEmptyModules returns the number of empty modules.\n//\n// Initially numEmptyModules is symbolSize * symbolSize. After every module has\n// been set (to either true or false), the number of empty modules is zero.\nfunc (m *symbol) numEmptyModules() int {\n\tvar count int\n\tfor y := 0; y < m.symbolSize; y++ {\n\t\tfor x := 0; x < m.symbolSize; x++ {\n\t\t\tif !m.isUsed[y+m.quietZoneSize][x+m.quietZoneSize] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count\n}\n\n// set sets the module at (x, y) to v.\nfunc (m *symbol) set(x int, y int, v bool) {\n\tm.module[y+m.quietZoneSize][x+m.quietZoneSize] = v\n\tm.isUsed[y+m.quietZoneSize][x+m.quietZoneSize] = true\n}\n\n// set2dPattern sets a 2D array of modules, starting at (x, y).\nfunc (m *symbol) set2dPattern(x int, y int, v [][]bool) {\n\tfor j, row := range v {\n\t\tfor i, value := range row {\n\t\t\tm.set(x+i, y+j, value)\n\t\t}\n\t}\n}\n\n// bitmap returns the entire symbol, including the quiet zone.\nfunc (m *symbol) bitmap() [][]bool {\n\tmodule := make([][]bool, len(m.module))\n\n\tfor i := range m.module {\n\t\tmodule[i] = m.module[i][:]\n\t}\n\n\treturn module\n}\n\n// string returns a pictorial representation of the symbol, suitable for\n// printing in a TTY.\nfunc (m *symbol) string() string {\n\tvar result string\n\n\tfor _, row := range m.module {\n\t\tfor _, value := range row {\n\t\t\tswitch value {\n\t\t\tcase true:\n\t\t\t\tresult += \"  \"\n\t\t\tcase false:\n\t\t\t\t// Unicode 'FULL BLOCK' (U+2588).\n\t\t\t\tresult += \"██\"\n\t\t\t}\n\t\t}\n\t\tresult += \"\\n\"\n\t}\n\n\treturn result\n}\n\n// Constants used to weight penalty calculations. Specified by ISO/IEC\n// 18004:2006.\nconst (\n\tpenaltyWeight1 = 3\n\tpenaltyWeight2 = 3\n\tpenaltyWeight3 = 40\n\tpenaltyWeight4 = 10\n)\n\n// penaltyScore returns the penalty score of the symbol. The penalty score\n// consists of the sum of the four individual penalty types.\nfunc (m *symbol) penaltyScore() int {\n\treturn m.penalty1() + m.penalty2() + m.penalty3() + m.penalty4()\n}\n\n// penalty1 returns the penalty score for \"adjacent modules in row/column with\n// same colour\".\n//\n// The numbers of adjacent matching modules and scores are:\n// 0-5: score = 0\n// 6+ : score = penaltyWeight1 + (numAdjacentModules - 5)\nfunc (m *symbol) penalty1() int {\n\tpenalty := 0\n\n\tfor x := 0; x < m.symbolSize; x++ {\n\t\tlastValue := m.get(x, 0)\n\t\tcount := 1\n\n\t\tfor y := 1; y < m.symbolSize; y++ {\n\t\t\tv := m.get(x, y)\n\n\t\t\tif v != lastValue {\n\t\t\t\tcount = 1\n\t\t\t\tlastValue = v\n\t\t\t} else {\n\t\t\t\tcount++\n\t\t\t\tif count == 6 {\n\t\t\t\t\tpenalty += penaltyWeight1 + 1\n\t\t\t\t} else if count > 6 {\n\t\t\t\t\tpenalty++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor y := 0; y < m.symbolSize; y++ {\n\t\tlastValue := m.get(0, y)\n\t\tcount := 1\n\n\t\tfor x := 1; x < m.symbolSize; x++ {\n\t\t\tv := m.get(x, y)\n\n\t\t\tif v != lastValue {\n\t\t\t\tcount = 1\n\t\t\t\tlastValue = v\n\t\t\t} else {\n\t\t\t\tcount++\n\t\t\t\tif count == 6 {\n\t\t\t\t\tpenalty += penaltyWeight1 + 1\n\t\t\t\t} else if count > 6 {\n\t\t\t\t\tpenalty++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn penalty\n}\n\n// penalty2 returns the penalty score for \"block of modules in the same colour\".\n//\n// m*n: score = penaltyWeight2 * (m-1) * (n-1).\nfunc (m *symbol) penalty2() int {\n\tpenalty := 0\n\n\tfor y := 1; y < m.symbolSize; y++ {\n\t\tfor x := 1; x < m.symbolSize; x++ {\n\t\t\ttopLeft := m.get(x-1, y-1)\n\t\t\tabove := m.get(x, y-1)\n\t\t\tleft := m.get(x-1, y)\n\t\t\tcurrent := m.get(x, y)\n\n\t\t\tif current == left && current == above && current == topLeft {\n\t\t\t\tpenalty++\n\t\t\t}\n\t\t}\n\t}\n\n\treturn penalty * penaltyWeight2\n}\n\n// penalty3 returns the penalty score for \"1:1:3:1:1 ratio\n// (dark:light:dark:light:dark) pattern in row/column, preceded or followed by\n// light area 4 modules wide\".\n//\n// Existence of the pattern scores penaltyWeight3.\nfunc (m *symbol) penalty3() int {\n\tpenalty := 0\n\n\tfor y := 0; y < m.symbolSize; y++ {\n\t\tvar bitBuffer int16 = 0x00\n\n\t\tfor x := 0; x < m.symbolSize; x++ {\n\t\t\tbitBuffer <<= 1\n\t\t\tif v := m.get(x, y); v {\n\t\t\t\tbitBuffer |= 1\n\t\t\t}\n\n\t\t\tswitch bitBuffer & 0x7ff {\n\t\t\t// 0b000 0101 1101 or 0b10111010000\n\t\t\t// 0x05d           or 0x5d0\n\t\t\tcase 0x05d, 0x5d0:\n\t\t\t\tpenalty += penaltyWeight3\n\t\t\t\tbitBuffer = 0xFF\n\t\t\tdefault:\n\t\t\t\tif x == m.symbolSize-1 && (bitBuffer&0x7f) == 0x5d {\n\t\t\t\t\tpenalty += penaltyWeight3\n\t\t\t\t\tbitBuffer = 0xFF\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor x := 0; x < m.symbolSize; x++ {\n\t\tvar bitBuffer int16 = 0x00\n\n\t\tfor y := 0; y < m.symbolSize; y++ {\n\t\t\tbitBuffer <<= 1\n\t\t\tif v := m.get(x, y); v {\n\t\t\t\tbitBuffer |= 1\n\t\t\t}\n\n\t\t\tswitch bitBuffer & 0x7ff {\n\t\t\t// 0b000 0101 1101 or 0b10111010000\n\t\t\t// 0x05d           or 0x5d0\n\t\t\tcase 0x05d, 0x5d0:\n\t\t\t\tpenalty += penaltyWeight3\n\t\t\t\tbitBuffer = 0xFF\n\t\t\tdefault:\n\t\t\t\tif y == m.symbolSize-1 && (bitBuffer&0x7f) == 0x5d {\n\t\t\t\t\tpenalty += penaltyWeight3\n\t\t\t\t\tbitBuffer = 0xFF\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn penalty\n}\n\n// penalty4 returns the penalty score...\nfunc (m *symbol) penalty4() int {\n\tnumModules := m.symbolSize * m.symbolSize\n\tnumDarkModules := 0\n\n\tfor x := 0; x < m.symbolSize; x++ {\n\t\tfor y := 0; y < m.symbolSize; y++ {\n\t\t\tif v := m.get(x, y); v {\n\t\t\t\tnumDarkModules++\n\t\t\t}\n\t\t}\n\t}\n\n\tnumDarkModuleDeviation := numModules/2 - numDarkModules\n\tif numDarkModuleDeviation < 0 {\n\t\tnumDarkModuleDeviation *= -1\n\t}\n\n\treturn penaltyWeight4 * (numDarkModuleDeviation / (numModules / 20))\n}\n"
        },
        {
          "name": "symbol_test.go",
          "type": "blob",
          "size": 8.70703125,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport \"testing\"\n\nfunc TestSymbolBasic(t *testing.T) {\n\tsize := 10\n\tquietZoneSize := 4\n\n\tm := newSymbol(size, quietZoneSize)\n\n\tif m.size != size+quietZoneSize*2 {\n\t\tt.Errorf(\"Symbol size is %d, expected %d\", m.size, size+quietZoneSize*2)\n\t}\n\n\tfor i := 0; i < size; i++ {\n\t\tfor j := 0; j < size; j++ {\n\n\t\t\tv := m.get(i, j)\n\n\t\t\tif v != false {\n\t\t\t\tt.Errorf(\"New symbol not empty\")\n\t\t\t}\n\n\t\t\tif !m.empty(i, j) {\n\t\t\t\tt.Errorf(\"New symbol is not empty\")\n\t\t\t}\n\n\t\t\tvalue := i*j%2 == 0\n\t\t\tm.set(i, j, value)\n\n\t\t\tv = m.get(i, j)\n\n\t\t\tif v != value {\n\t\t\t\tt.Errorf(\"Symbol ignores set bits\")\n\t\t\t}\n\n\t\t\tif m.empty(i, j) {\n\t\t\t\tt.Errorf(\"Symbol ignores set bits\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSymbolPenalties(t *testing.T) {\n\ttests := []struct {\n\t\tpattern          [][]bool\n\t\texpectedPenalty1 int\n\t\texpectedPenalty2 int\n\t\texpectedPenalty3 int\n\t\texpectedPenalty4 int\n\t}{\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t},\n\t\t\t0, // No adjacent modules of same color.\n\t\t\t0, // No 2x2+ sized blocks.\n\t\t\t0, // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t},\n\t\t\t0, // 5 adjacent modules of same colour, score = 0.\n\t\t\t0, // No 2x2+ sized blocks.\n\t\t\t0, // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t},\n\t\t\t4, // 6 adjacent modules of same colour, score = 3 + (6-5)\n\t\t\t0, // No 2x2+ sized blocks.\n\t\t\t0, // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b0, b0, b0, b0, b0},\n\t\t\t},\n\t\t\t28, // 3+(7-5) + 3+(6-5) + 3+(6-5) + 3+(6-5) + 3+(7-5) + 3+(7-5) = 28\n\t\t\t0,  // No 2x2+ sized blocks.\n\t\t\t0,  // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b1, b0, b1},\n\t\t\t\t{b0, b0, b1, b0, b1, b0},\n\t\t\t\t{b0, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b1, b1, b0},\n\t\t\t\t{b0, b1, b1, b1, b0, b1},\n\t\t\t\t{b1, b0, b1, b0, b1, b0},\n\t\t\t},\n\t\t\t-1,\n\t\t\t6, // 3*(2-1)*(2-1) + 3(2-1)*(2-1)\n\t\t\t0, // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t60, // 3 * (5-1) * (6-1)\n\t\t\t0,  // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b1, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b1, b0, b1, b0, b1},\n\t\t\t\t{b1, b1, b0, b1, b0, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t21, // 3*(5-1)*(2-1) + 3*(2-1)*(4-1) = 3*4 + 3*3\n\t\t\t0,  // No 1:1:3:1:1 pattern.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t\t{b0, b0, b0, b0, b1, b0, b1, b1, b1, b0, b1, b0},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t480, // 12* 1:1:3:1:1 patterns, 12 * 40.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b1, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t80, // 2* 1:1:3:1:1 patterns, 2 * 40.\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t100, // 10 * (10 steps of 5% deviation from 50% black/white).\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t100, // 10 * (10 steps of 5% deviation from 50% black/white).\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t0, // Exactly 50%/50% black/white.\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t20, // 10 * (2 steps of 5% deviation towards white).\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t30, // 10 * (3 steps of 5% deviation towards white).\n\t\t},\n\t\t{\n\t\t\t[][]bool{\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b0},\n\t\t\t\t{b0, b0, b0, b0, b0, b0, b0, b0, b0, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t\t{b1, b1, b1, b1, b1, b1, b1, b1, b1, b1},\n\t\t\t},\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t30, // 10 * (3 steps of 5% deviation towards white).\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\ts := newSymbol(len(test.pattern[0]), 4)\n\t\ts.set2dPattern(0, 0, test.pattern)\n\n\t\tpenalty1 := s.penalty1()\n\t\tpenalty2 := s.penalty2()\n\t\tpenalty3 := s.penalty3()\n\t\tpenalty4 := s.penalty4()\n\n\t\tok := true\n\n\t\tif test.expectedPenalty1 != -1 && test.expectedPenalty1 != penalty1 {\n\t\t\tok = false\n\t\t}\n\t\tif test.expectedPenalty2 != -1 && test.expectedPenalty2 != penalty2 {\n\t\t\tok = false\n\t\t}\n\t\tif test.expectedPenalty3 != -1 && test.expectedPenalty3 != penalty3 {\n\t\t\tok = false\n\t\t}\n\t\tif test.expectedPenalty4 != -1 && test.expectedPenalty4 != penalty4 {\n\t\t\tok = false\n\t\t}\n\n\t\tif !ok {\n\t\t\tt.Fatalf(\"Penalty test #%d p1=%d, p2=%d, p3=%d, p4=%d (expected p1=%d, p2=%d, p3=%d, p4=%d)\", i, penalty1, penalty2, penalty3, penalty4,\n\t\t\t\ttest.expectedPenalty1, test.expectedPenalty2, test.expectedPenalty3,\n\t\t\t\ttest.expectedPenalty4)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 30.2421875,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"log\"\n\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n)\n\n// Error detection/recovery capacity.\n//\n// There are several levels of error detection/recovery capacity. Higher levels\n// of error recovery are able to correct more errors, with the trade-off of\n// increased symbol size.\ntype RecoveryLevel int\n\nconst (\n\t// Level L: 7% error recovery.\n\tLow RecoveryLevel = iota\n\n\t// Level M: 15% error recovery. Good default choice.\n\tMedium\n\n\t// Level Q: 25% error recovery.\n\tHigh\n\n\t// Level H: 30% error recovery.\n\tHighest\n)\n\n// qrCodeVersion describes the data length and encoding order of a single QR\n// Code version. There are 40 versions numbers x 4 recovery levels == 160\n// possible qrCodeVersion structures.\ntype qrCodeVersion struct {\n\t// Version number (1-40 inclusive).\n\tversion int\n\n\t// Error recovery level.\n\tlevel RecoveryLevel\n\n\tdataEncoderType dataEncoderType\n\n\t// Encoded data can be split into multiple blocks. Each block contains data\n\t// and error recovery bytes.\n\t//\n\t// Larger QR Codes contain more blocks.\n\tblock []block\n\n\t// Number of bits required to pad the combined data & error correction bit\n\t// stream up to the symbol's full capacity.\n\tnumRemainderBits int\n}\n\ntype block struct {\n\tnumBlocks int\n\n\t// Total codewords (numCodewords == numErrorCodewords+numDataCodewords).\n\tnumCodewords int\n\n\t// Number of data codewords.\n\tnumDataCodewords int\n}\n\nvar (\n\tversions = []qrCodeVersion{\n\t\t{\n\t\t\t1,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t26,\n\t\t\t\t\t19,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t1,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t26,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t1,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t26,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t1,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t26,\n\t\t\t\t\t9,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t2,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t44,\n\t\t\t\t\t34,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t2,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t44,\n\t\t\t\t\t28,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t2,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t44,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t2,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t44,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t3,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t70,\n\t\t\t\t\t55,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t3,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t70,\n\t\t\t\t\t44,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t3,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t35,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t3,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t35,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t4,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t100,\n\t\t\t\t\t80,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t4,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t50,\n\t\t\t\t\t32,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t4,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t50,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t4,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t25,\n\t\t\t\t\t9,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t5,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t134,\n\t\t\t\t\t108,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t5,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t67,\n\t\t\t\t\t43,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t5,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t33,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t34,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t5,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t33,\n\t\t\t\t\t11,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t34,\n\t\t\t\t\t12,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t6,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t86,\n\t\t\t\t\t68,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t6,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t43,\n\t\t\t\t\t27,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t6,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t43,\n\t\t\t\t\t19,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t6,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t43,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t},\n\t\t\t7,\n\t\t},\n\t\t{\n\t\t\t7,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t98,\n\t\t\t\t\t78,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t7,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t49,\n\t\t\t\t\t31,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t7,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t32,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t33,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t7,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t39,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t40,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t8,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t121,\n\t\t\t\t\t97,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t8,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t60,\n\t\t\t\t\t38,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t61,\n\t\t\t\t\t39,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t8,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t40,\n\t\t\t\t\t18,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t41,\n\t\t\t\t\t19,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t8,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t40,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t41,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t9,\n\t\t\tLow,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t9,\n\t\t\tMedium,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t58,\n\t\t\t\t\t36,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t59,\n\t\t\t\t\t37,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t9,\n\t\t\tHigh,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t36,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t37,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t9,\n\t\t\tHighest,\n\t\t\tdataEncoderType1To9,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t36,\n\t\t\t\t\t12,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t37,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t10,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t86,\n\t\t\t\t\t68,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t87,\n\t\t\t\t\t69,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t10,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t69,\n\t\t\t\t\t43,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t70,\n\t\t\t\t\t44,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t10,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t43,\n\t\t\t\t\t19,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t44,\n\t\t\t\t\t20,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t10,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t43,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t44,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t11,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t101,\n\t\t\t\t\t81,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t11,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t80,\n\t\t\t\t\t50,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t81,\n\t\t\t\t\t51,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t11,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t50,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t51,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t11,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t36,\n\t\t\t\t\t12,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t37,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t12,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t116,\n\t\t\t\t\t92,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t117,\n\t\t\t\t\t93,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t12,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t58,\n\t\t\t\t\t36,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t59,\n\t\t\t\t\t37,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t12,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t46,\n\t\t\t\t\t20,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t47,\n\t\t\t\t\t21,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t12,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t42,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t43,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t13,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t133,\n\t\t\t\t\t107,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t13,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t59,\n\t\t\t\t\t37,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t60,\n\t\t\t\t\t38,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t13,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t44,\n\t\t\t\t\t20,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t45,\n\t\t\t\t\t21,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t13,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t12,\n\t\t\t\t\t33,\n\t\t\t\t\t11,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t34,\n\t\t\t\t\t12,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t14,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t145,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t14,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t64,\n\t\t\t\t\t40,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t65,\n\t\t\t\t\t41,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t14,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t36,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t37,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t14,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t36,\n\t\t\t\t\t12,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t37,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t15,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t109,\n\t\t\t\t\t87,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t110,\n\t\t\t\t\t88,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t15,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t65,\n\t\t\t\t\t41,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t66,\n\t\t\t\t\t42,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t15,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t15,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t36,\n\t\t\t\t\t12,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t37,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t16,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t122,\n\t\t\t\t\t98,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t123,\n\t\t\t\t\t99,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t16,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t73,\n\t\t\t\t\t45,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t16,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t15,\n\t\t\t\t\t43,\n\t\t\t\t\t19,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t44,\n\t\t\t\t\t20,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t16,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t17,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t135,\n\t\t\t\t\t107,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t136,\n\t\t\t\t\t108,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t17,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t17,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t50,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t15,\n\t\t\t\t\t51,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t17,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t42,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t43,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t18,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t150,\n\t\t\t\t\t120,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t151,\n\t\t\t\t\t121,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t18,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t9,\n\t\t\t\t\t69,\n\t\t\t\t\t43,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t70,\n\t\t\t\t\t44,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t18,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t50,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t51,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t18,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t42,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t43,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t19,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t141,\n\t\t\t\t\t113,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t142,\n\t\t\t\t\t114,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t19,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t70,\n\t\t\t\t\t44,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t71,\n\t\t\t\t\t45,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t19,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t47,\n\t\t\t\t\t21,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t48,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t19,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t9,\n\t\t\t\t\t39,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t16,\n\t\t\t\t\t40,\n\t\t\t\t\t14,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t20,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t135,\n\t\t\t\t\t107,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t136,\n\t\t\t\t\t108,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t20,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t67,\n\t\t\t\t\t41,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t68,\n\t\t\t\t\t42,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t20,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t15,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t20,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t15,\n\t\t\t\t\t43,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t44,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t21,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t144,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t145,\n\t\t\t\t\t117,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t21,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t68,\n\t\t\t\t\t42,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t21,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t50,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t51,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t21,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t47,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t22,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t139,\n\t\t\t\t\t111,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t140,\n\t\t\t\t\t112,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t22,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t22,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t16,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t22,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t34,\n\t\t\t\t\t37,\n\t\t\t\t\t13,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t23,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t151,\n\t\t\t\t\t121,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t152,\n\t\t\t\t\t122,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t23,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t23,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t23,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t16,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t24,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t147,\n\t\t\t\t\t117,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t148,\n\t\t\t\t\t118,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t24,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t73,\n\t\t\t\t\t45,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t24,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t16,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t24,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t30,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t47,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t25,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t132,\n\t\t\t\t\t106,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t133,\n\t\t\t\t\t107,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t25,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t25,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t22,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t25,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t22,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t26,\n\t\t\tLow,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t142,\n\t\t\t\t\t114,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t143,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t26,\n\t\t\tMedium,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t26,\n\t\t\tHigh,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t28,\n\t\t\t\t\t50,\n\t\t\t\t\t22,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t51,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t26,\n\t\t\tHighest,\n\t\t\tdataEncoderType10To26,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t33,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t47,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t27,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t152,\n\t\t\t\t\t122,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t153,\n\t\t\t\t\t123,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t27,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t22,\n\t\t\t\t\t73,\n\t\t\t\t\t45,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t27,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t8,\n\t\t\t\t\t53,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t26,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t27,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t12,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t28,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t4,\n\t\t},\n\t\t{\n\t\t\t28,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t147,\n\t\t\t\t\t117,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t148,\n\t\t\t\t\t118,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t28,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t73,\n\t\t\t\t\t45,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t23,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t28,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t31,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t28,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t31,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t29,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t147,\n\t\t\t\t\t117,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t29,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t21,\n\t\t\t\t\t73,\n\t\t\t\t\t45,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t29,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t53,\n\t\t\t\t\t23,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t37,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t29,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t26,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t30,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t5,\n\t\t\t\t\t145,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t30,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t30,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t15,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t25,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t30,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t23,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t25,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t31,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t145,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t3,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t31,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t29,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t31,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t42,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t31,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t23,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t28,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t32,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t145,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t32,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t23,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t32,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t35,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t32,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t35,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t33,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t145,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t33,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t21,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t33,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t29,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t33,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t11,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t46,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t34,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t145,\n\t\t\t\t\t115,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t146,\n\t\t\t\t\t116,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t34,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t23,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t34,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t44,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t34,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t59,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t1,\n\t\t\t\t\t47,\n\t\t\t\t\t17,\n\t\t\t\t},\n\t\t\t},\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t35,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t12,\n\t\t\t\t\t151,\n\t\t\t\t\t121,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t152,\n\t\t\t\t\t122,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t35,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t12,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t26,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t35,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t39,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t35,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t22,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t41,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t36,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t151,\n\t\t\t\t\t121,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t152,\n\t\t\t\t\t122,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t36,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t34,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t36,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t46,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t36,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t2,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t64,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t37,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t17,\n\t\t\t\t\t152,\n\t\t\t\t\t122,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t153,\n\t\t\t\t\t123,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t37,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t29,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t37,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t49,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t37,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t24,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t46,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t38,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t152,\n\t\t\t\t\t122,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t18,\n\t\t\t\t\t153,\n\t\t\t\t\t123,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t38,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t13,\n\t\t\t\t\t74,\n\t\t\t\t\t46,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t32,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t38,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t48,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t14,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t38,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t42,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t32,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t39,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t20,\n\t\t\t\t\t147,\n\t\t\t\t\t117,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t4,\n\t\t\t\t\t148,\n\t\t\t\t\t118,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t39,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t40,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t7,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t39,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t43,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t22,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t39,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t10,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t67,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\tLow,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t19,\n\t\t\t\t\t148,\n\t\t\t\t\t118,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t6,\n\t\t\t\t\t149,\n\t\t\t\t\t119,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\tMedium,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t18,\n\t\t\t\t\t75,\n\t\t\t\t\t47,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t31,\n\t\t\t\t\t76,\n\t\t\t\t\t48,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\tHigh,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t34,\n\t\t\t\t\t54,\n\t\t\t\t\t24,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t34,\n\t\t\t\t\t55,\n\t\t\t\t\t25,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\tHighest,\n\t\t\tdataEncoderType27To40,\n\t\t\t[]block{\n\t\t\t\t{\n\t\t\t\t\t20,\n\t\t\t\t\t45,\n\t\t\t\t\t15,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t61,\n\t\t\t\t\t46,\n\t\t\t\t\t16,\n\t\t\t\t},\n\t\t\t},\n\t\t\t0,\n\t\t},\n\t}\n)\n\nvar (\n\t// Each QR Code contains a 15-bit Format Information value.  The 15 bits\n\t// consist of 5 data bits concatenated with 10 error correction bits.\n\t//\n\t// The 5 data bits consist of:\n\t// - 2 bits for the error correction level (L=01, M=00, G=11, H=10).\n\t// - 3 bits for the data mask pattern identifier.\n\t//\n\t// formatBitSequence is a mapping from the 5 data bits to the completed 15-bit\n\t// Format Information value.\n\t//\n\t// For example, a QR Code using error correction level L, and data mask\n\t// pattern identifier 001:\n\t//\n\t// 01 | 001 = 01001 = 0x9\n\t// formatBitSequence[0x9].qrCode = 0x72f3 = 111001011110011\n\tformatBitSequence = []struct {\n\t\tregular uint32\n\t\tmicro   uint32\n\t}{\n\t\t{0x5412, 0x4445},\n\t\t{0x5125, 0x4172},\n\t\t{0x5e7c, 0x4e2b},\n\t\t{0x5b4b, 0x4b1c},\n\t\t{0x45f9, 0x55ae},\n\t\t{0x40ce, 0x5099},\n\t\t{0x4f97, 0x5fc0},\n\t\t{0x4aa0, 0x5af7},\n\t\t{0x77c4, 0x6793},\n\t\t{0x72f3, 0x62a4},\n\t\t{0x7daa, 0x6dfd},\n\t\t{0x789d, 0x68ca},\n\t\t{0x662f, 0x7678},\n\t\t{0x6318, 0x734f},\n\t\t{0x6c41, 0x7c16},\n\t\t{0x6976, 0x7921},\n\t\t{0x1689, 0x06de},\n\t\t{0x13be, 0x03e9},\n\t\t{0x1ce7, 0x0cb0},\n\t\t{0x19d0, 0x0987},\n\t\t{0x0762, 0x1735},\n\t\t{0x0255, 0x1202},\n\t\t{0x0d0c, 0x1d5b},\n\t\t{0x083b, 0x186c},\n\t\t{0x355f, 0x2508},\n\t\t{0x3068, 0x203f},\n\t\t{0x3f31, 0x2f66},\n\t\t{0x3a06, 0x2a51},\n\t\t{0x24b4, 0x34e3},\n\t\t{0x2183, 0x31d4},\n\t\t{0x2eda, 0x3e8d},\n\t\t{0x2bed, 0x3bba},\n\t}\n\n\t// QR Codes version 7 and higher contain an 18-bit Version Information value,\n\t// consisting of a 6 data bits and 12 error correction bits.\n\t//\n\t// versionBitSequence is a mapping from QR Code version to the completed\n\t// 18-bit Version Information value.\n\t//\n\t// For example, a QR code of version 7:\n\t// versionBitSequence[0x7] = 0x07c94 = 000111110010010100\n\tversionBitSequence = []uint32{\n\t\t0x00000,\n\t\t0x00000,\n\t\t0x00000,\n\t\t0x00000,\n\t\t0x00000,\n\t\t0x00000,\n\t\t0x00000,\n\t\t0x07c94,\n\t\t0x085bc,\n\t\t0x09a99,\n\t\t0x0a4d3,\n\t\t0x0bbf6,\n\t\t0x0c762,\n\t\t0x0d847,\n\t\t0x0e60d,\n\t\t0x0f928,\n\t\t0x10b78,\n\t\t0x1145d,\n\t\t0x12a17,\n\t\t0x13532,\n\t\t0x149a6,\n\t\t0x15683,\n\t\t0x168c9,\n\t\t0x177ec,\n\t\t0x18ec4,\n\t\t0x191e1,\n\t\t0x1afab,\n\t\t0x1b08e,\n\t\t0x1cc1a,\n\t\t0x1d33f,\n\t\t0x1ed75,\n\t\t0x1f250,\n\t\t0x209d5,\n\t\t0x216f0,\n\t\t0x228ba,\n\t\t0x2379f,\n\t\t0x24b0b,\n\t\t0x2542e,\n\t\t0x26a64,\n\t\t0x27541,\n\t\t0x28c69,\n\t}\n)\n\nconst (\n\tformatInfoLengthBits  = 15\n\tversionInfoLengthBits = 18\n)\n\n// formatInfo returns the 15-bit Format Information value for a QR\n// code.\nfunc (v qrCodeVersion) formatInfo(maskPattern int) *bitset.Bitset {\n\tformatID := 0\n\n\tswitch v.level {\n\tcase Low:\n\t\tformatID = 0x08 // 0b01000\n\tcase Medium:\n\t\tformatID = 0x00 // 0b00000\n\tcase High:\n\t\tformatID = 0x18 // 0b11000\n\tcase Highest:\n\t\tformatID = 0x10 // 0b10000\n\tdefault:\n\t\tlog.Panicf(\"Invalid level %d\", v.level)\n\t}\n\n\tif maskPattern < 0 || maskPattern > 7 {\n\t\tlog.Panicf(\"Invalid maskPattern %d\", maskPattern)\n\t}\n\n\tformatID |= maskPattern & 0x7\n\n\tresult := bitset.New()\n\n\tresult.AppendUint32(formatBitSequence[formatID].regular, formatInfoLengthBits)\n\n\treturn result\n}\n\n// versionInfo returns the 18-bit Version Information value for a QR Code.\n//\n// Version Information is applicable only to QR Codes versions 7-40 inclusive.\n// nil is returned if Version Information is not required.\nfunc (v qrCodeVersion) versionInfo() *bitset.Bitset {\n\tif v.version < 7 {\n\t\treturn nil\n\t}\n\n\tresult := bitset.New()\n\tresult.AppendUint32(versionBitSequence[v.version], 18)\n\n\treturn result\n}\n\n// numDataBits returns the data capacity in bits.\nfunc (v qrCodeVersion) numDataBits() int {\n\tnumDataBits := 0\n\tfor _, b := range v.block {\n\t\tnumDataBits += 8 * b.numBlocks * b.numDataCodewords // 8 bits in a byte\n\t}\n\n\treturn numDataBits\n}\n\n// chooseQRCodeVersion chooses the most suitable QR Code version for a stated\n// data length in bits, the error recovery level required, and the data encoder\n// used.\n//\n// The chosen QR Code version is the smallest version able to fit numDataBits\n// and the optional terminator bits required by the specified encoder.\n//\n// On success the chosen QR Code version is returned.\nfunc chooseQRCodeVersion(level RecoveryLevel, encoder *dataEncoder, numDataBits int) *qrCodeVersion {\n\tvar chosenVersion *qrCodeVersion\n\n\tfor _, v := range versions {\n\t\tif v.level != level {\n\t\t\tcontinue\n\t\t} else if v.version < encoder.minVersion {\n\t\t\tcontinue\n\t\t} else if v.version > encoder.maxVersion {\n\t\t\tbreak\n\t\t}\n\n\t\tnumFreeBits := v.numDataBits() - numDataBits\n\n\t\tif numFreeBits >= 0 {\n\t\t\tchosenVersion = &v\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn chosenVersion\n}\n\nfunc (v qrCodeVersion) numTerminatorBitsRequired(numDataBits int) int {\n\tnumFreeBits := v.numDataBits() - numDataBits\n\n\tvar numTerminatorBits int\n\n\tswitch {\n\tcase numFreeBits >= 4:\n\t\tnumTerminatorBits = 4\n\tdefault:\n\t\tnumTerminatorBits = numFreeBits\n\t}\n\n\treturn numTerminatorBits\n}\n\n// numBlocks returns the number of blocks.\nfunc (v qrCodeVersion) numBlocks() int {\n\tnumBlocks := 0\n\n\tfor _, b := range v.block {\n\t\tnumBlocks += b.numBlocks\n\t}\n\n\treturn numBlocks\n}\n\n// numBitsToPadToCodeword returns the number of bits required to pad data of\n// length numDataBits upto the nearest codeword size.\nfunc (v qrCodeVersion) numBitsToPadToCodeword(numDataBits int) int {\n\tif numDataBits == v.numDataBits() {\n\t\treturn 0\n\t}\n\n\treturn (8 - numDataBits%8) % 8\n}\n\n// symbolSize returns the size of the QR Code symbol in number of modules (which\n// is both the width and height, since QR codes are square). The QR Code has\n// size symbolSize() x symbolSize() pixels. This does not include the quiet\n// zone.\nfunc (v qrCodeVersion) symbolSize() int {\n\treturn 21 + (v.version-1)*4\n}\n\n// quietZoneSize returns the number of pixels of border space on each side of\n// the QR Code. The quiet space assists with decoding.\nfunc (v qrCodeVersion) quietZoneSize() int {\n\treturn 4\n}\n\n// getQRCodeVersion returns the QR Code version by version number and recovery\n// level. Returns nil if the requested combination is not defined.\nfunc getQRCodeVersion(level RecoveryLevel, version int) *qrCodeVersion {\n\tfor _, v := range versions {\n\t\tif v.level == level && v.version == version {\n\t\t\treturn &v\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "version_test.go",
          "type": "blob",
          "size": 2.068359375,
          "content": "// go-qrcode\n// Copyright 2014 Tom Harwood\n\npackage qrcode\n\nimport (\n\t\"testing\"\n\n\tbitset \"github.com/skip2/go-qrcode/bitset\"\n)\n\nfunc TestFormatInfo(t *testing.T) {\n\ttests := []struct {\n\t\tlevel       RecoveryLevel\n\t\tmaskPattern int\n\n\t\texpected uint32\n\t}{\n\t\t{ // L=01 M=00 Q=11 H=10\n\t\t\tLow,\n\t\t\t1,\n\t\t\t0x72f3,\n\t\t},\n\t\t{\n\t\t\tMedium,\n\t\t\t2,\n\t\t\t0x5e7c,\n\t\t},\n\t\t{\n\t\t\tHigh,\n\t\t\t3,\n\t\t\t0x3a06,\n\t\t},\n\t\t{\n\t\t\tHighest,\n\t\t\t4,\n\t\t\t0x0762,\n\t\t},\n\t\t{\n\t\t\tLow,\n\t\t\t5,\n\t\t\t0x6318,\n\t\t},\n\t\t{\n\t\t\tMedium,\n\t\t\t6,\n\t\t\t0x4f97,\n\t\t},\n\t\t{\n\t\t\tHigh,\n\t\t\t7,\n\t\t\t0x2bed,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tv := getQRCodeVersion(test.level, 1)\n\n\t\tresult := v.formatInfo(test.maskPattern)\n\n\t\texpected := bitset.New()\n\t\texpected.AppendUint32(test.expected, formatInfoLengthBits)\n\n\t\tif !expected.Equals(result) {\n\t\t\tt.Errorf(\"formatInfo test #%d got %s, expected %s\", i, result.String(),\n\t\t\t\texpected.String())\n\t\t}\n\t}\n}\n\nfunc TestVersionInfo(t *testing.T) {\n\ttests := []struct {\n\t\tversion  int\n\t\texpected uint32\n\t}{\n\t\t{\n\t\t\t7,\n\t\t\t0x007c94,\n\t\t},\n\t\t{\n\t\t\t10,\n\t\t\t0x00a4d3,\n\t\t},\n\t\t{\n\t\t\t20,\n\t\t\t0x0149a6,\n\t\t},\n\t\t{\n\t\t\t30,\n\t\t\t0x01ed75,\n\t\t},\n\t\t{\n\t\t\t40,\n\t\t\t0x028c69,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar v *qrCodeVersion\n\n\t\tv = getQRCodeVersion(Low, test.version)\n\n\t\tresult := v.versionInfo()\n\n\t\texpected := bitset.New()\n\t\texpected.AppendUint32(test.expected, versionInfoLengthBits)\n\n\t\tif !expected.Equals(result) {\n\t\t\tt.Errorf(\"versionInfo test #%d got %s, expected %s\", i, result.String(),\n\t\t\t\texpected.String())\n\t\t}\n\t}\n}\n\nfunc TestNumBitsToPadToCodeoword(t *testing.T) {\n\ttests := []struct {\n\t\tlevel   RecoveryLevel\n\t\tversion int\n\n\t\tnumDataBits int\n\t\texpected    int\n\t}{\n\t\t{\n\t\t\tLow,\n\t\t\t1,\n\t\t\t0,\n\t\t\t0,\n\t\t}, {\n\t\t\tLow,\n\t\t\t1,\n\t\t\t1,\n\t\t\t7,\n\t\t}, {\n\t\t\tLow,\n\t\t\t1,\n\t\t\t7,\n\t\t\t1,\n\t\t}, {\n\t\t\tLow,\n\t\t\t1,\n\t\t\t8,\n\t\t\t0,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tvar v *qrCodeVersion\n\n\t\tv = getQRCodeVersion(test.level, test.version)\n\n\t\tresult := v.numBitsToPadToCodeword(test.numDataBits)\n\n\t\tif result != test.expected {\n\t\t\tt.Errorf(\"numBitsToPadToCodeword test %d (version=%d numDataBits=%d), got %d, expected %d\",\n\t\t\t\ti, test.version, test.numDataBits, result, test.expected)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}