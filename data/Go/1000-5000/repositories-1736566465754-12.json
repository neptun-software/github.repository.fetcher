{
  "metadata": {
    "timestamp": 1736566465754,
    "page": 12,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fiorix/freegeoip",
      "stars": 4942,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.048828125,
          "content": "db.gz\n*.rdb\n*.swp\n*.csv\n*.zip\n*.sqlite\n/vendor/*/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.146484375,
          "content": "sudo: false\n\nlanguage: go\n\ngo:\n  - 1.7\n  - 1.8\n\ninstall:\n  - go get -t -d -v ./...\n\nservices:\n  - redis-server\n\nscript:\n  - go test -v ./ ./apiserver\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.32421875,
          "content": "# This is the official list of freegeoip authors for copyright purposes.\n# This file is distinct from the CONTRIBUTORS file.\n#\n# Names should be added to this file as\n#\tName or Organization <email address>\n#\n# The email address is not required for organizations.\n#\n# Please keep the list sorted.\n\nAlexandre Fiori <fiorix@gmail.com>\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.6748046875,
          "content": "# This is the official list of freegeoip contributors for copyright purposes.\n# This file is distinct from the AUTHORS file.\n#\n# Names should be added to this file as\n#\tName or Organization <email address>\n#\n# Please keep the list sorted.\n#\n# Use the following command to generate the list:\n#\n#\tgit shortlog -se | awk '{print $2 \" \" $3 \" \" $4}'\n#\n# The email address is not required for organizations.\n\nAlex Goretoy <alex@goretoy.com>\nGleicon Moraes <gleicon@gmail.com>\nLeandro Pereira <leandro@hardinfo.org>\nLucas Fontes <lxfontes@gmail.com>\nMatthias Nehlsen <matthias.nehlsen@gmail.com>\nMelchi <melchi.si@gmail.com>\nNick Muerdter <stuff@nickm.org>\nVladimir Agafonkin <agafonkin@gmail.com>\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.75390625,
          "content": "FROM golang:1.9\n\nCOPY cmd/freegeoip/public /var/www\n\nADD . /go/src/github.com/fiorix/freegeoip\nRUN \\\n\tcd /go/src/github.com/fiorix/freegeoip/cmd/freegeoip && \\\n\tgo get -d && go install && \\\n\tapt-get update && apt-get install -y libcap2-bin && \\\n\tsetcap cap_net_bind_service=+ep /go/bin/freegeoip && \\\n\tapt-get clean && rm -rf /var/lib/apt/lists/* && \\\n\tuseradd -ms /bin/bash freegeoip\n\nUSER freegeoip\nENTRYPOINT [\"/go/bin/freegeoip\"]\n\nEXPOSE 8080\n\n# CMD instructions:\n# Add  \"-use-x-forwarded-for\"      if your server is behind a reverse proxy\n# Add  \"-public\", \"/var/www\"       to enable the web front-end\n# Add  \"-internal-server\", \"8888\"  to enable the pprof+metrics server\n#\n# Example:\n# CMD [\"-use-x-forwarded-for\", \"-public\", \"/var/www\", \"-internal-server\", \"8888\"]\n"
        },
        {
          "name": "HISTORY.md",
          "type": "blob",
          "size": 2.8720703125,
          "content": "# History of freegeoip.net\n\nThe freegeoip software is the result of a web server research project that\nstarted in 2009, written in Python and hosted on\n[Google App Engine](http://appengine.google.com). It was rapidly adopted by\nmany developers around the world due to its simplistic and straightforward\nHTTP API, causing the free account on GAE to exceed its quota every day\nafter few hours of operation.\n\nA year later freegeoip 1.0 was released, and the freegeoip.net domain\nmoved over to its own server infrastructure. The software was rewritten\nusing the [Cyclone](http://cyclone.io) web framework, backed by\n[Twisted](http://twistedmatrix.com) and [PyPy](http://pypy.org) in\nproduction. That's when the first database management tool was created,\na script that would download many pieces of information from the Internet\nto create the IP database, an sqlite flat file used by the server.\n\nThis version of the Python server shipped with a much better front-end as\nwell, but still as a server-side rendered template inherited from the GAE\nversion. It was only circa 2011 that freegeoip got its first standalone\nfront-end based on jQuery, and is when Twitter bootstrap was first used.\n\nPython played an important role in the early life of freegeoip and\nallowed the service to grow and evolve fast. It provided a lot of\nflexibility in building and maintaining the IP database using multiple\nsources of data. This version of the server lasted until 2013, when\nit was once again rewritten from scratch, this time in Go. The database\ntool, however, remained intact.\n\nIn 2013 the Go version was released as freegeoip 2.0 and this version\nhad many iterations. The first versions of the server written in Go were\nvery rustic, practically a verbatim transcription of the Python server.\nTook a while until it started looking more like common Go code, and to\nhave tests.\n\nAnother important change that shipped with v2 was a front-end based on\nAngularJS, but still mixed with some jQuery. The Google map in the front\npage was made optional to put more focus on the HTTP API. The popularity\nof freegeoip has increased considerably over the years of 2013 and 2014,\ncalling for more.\n\nEnter freegeoip 3.0, an evolution of the Go server. The foundation of\nfreegeoip, which is the IP database and HTTP API, now lives in a Go\npackage that other developers can leverage. The freegeoip web server is\nbuilt on this package making its code cleaner, the server faster,\nand requires zero maintenance for the IP database. The server downloads\nthe file from MaxMind and keep it up to date in background.\n\nThis and other changes make it very Docker friendly.\n\nThe front-end has been trimmed down to a single index.html file that loads\nCSS and JS from CDNs on the internet. The JS part is based on AngularJS\nand handles the search request and response of the public site. The\noptional map has become a link to Google Maps following the lat/long\nof the query results.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4267578125,
          "content": "Copyright (c) 2009 The freegeoip authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * The names of authors or contributors may NOT be used to endorse or\npromote products derived from this software without specific prior\nwritten permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Procfile",
          "type": "blob",
          "size": 0.1181640625,
          "content": "web: freegeoip -http :${PORT} -use-x-forwarded-for -public /app/cmd/freegeoip/public -quota-backend map -quota-max 10000\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.802734375,
          "content": "# freegeoip\n\n**NOTE:** as of April 2018 this repository is no longer active. Please visit https://github.com/apilayer/freegeoip/ for the current version.\n\n---\n\n[![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy)\n\nThis is the source code of the freegeoip software. It contains both the web server that empowers freegeoip.net, and a package for the [Go](http://golang.org) programming language that enables any web server to support IP geolocation with a simple and clean API.\n\nSee http://en.wikipedia.org/wiki/Geolocation for details about geolocation.\n\nDevelopers looking for the Go API can skip to the [Package freegeoip](#packagefreegeoip) section below.\n\n## Running\n\nThis section is for people who desire to run the freegeoip web server on their own infrastructure. The easiest and most generic way of doing this is by using Docker. All examples below use Docker.\n\n### Docker\n\n#### Install Docker\n\nDocker has [install instructions for many platforms](https://docs.docker.com/engine/installation/),\nincluding\n- [Ubuntu](https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/)\n- [CentOS](https://docs.docker.com/engine/installation/linux/docker-ce/centos/)\n- [Mac](https://docs.docker.com/docker-for-mac/install/)\n\n#### Run the API in a container\n\n```bash\ndocker run --restart=always -p 8080:8080 -d fiorix/freegeoip\n```\n\n#### Test\n\n```bash\ncurl localhost:8080/json/1.2.3.4\n# => {\"ip\":\"1.2.3.4\",\"country_code\":\"US\",\"country_name\":\"United States\", # ...\n```\n\n### Other Linux, OS X, FreeBSD, and Windows\n\nThere are [pre-compiled binaries](https://github.com/fiorix/freegeoip/releases) available.\n\n### Production configuration\n\nFor production workloads you may want to use different configuration for the freegeoip web server, for example:\n\n* Enabling the \"internal server\" for collecting metrics and profiling/tracing the freegeoip web server on demand\n* Monitoring the internal server using [Prometheus](https://prometheus.io), or exporting your metrics to [New Relic](https://newrelic.com)\n* Serving the freegeoip API over HTTPS (TLS) using your own certificates, or provisioned automatically using [LetsEncrypt.org](https://letsencrypt.org)\n* Configuring [HSTS](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) to restrict your browser clients to always use HTTPS\n* Configuring the read and write timeouts to avoid stale clients consuming server resources\n* Configuring the freegeoip web server to read the client IP (for logs, etc) from the X-Forwarded-For header when running behind a reverse proxy\n* Configuring [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) to restrict access to your API to specific domains\n* Configuring a specific endpoint path prefix other than the default \"/\" (thus /json, /xml, /csv) to serve the API alongside other APIs on the same host\n* Optimizing your round trips by enabling [TCP Fast Open](https://en.wikipedia.org/wiki/TCP_Fast_Open) on your OS and the freegeoip web server\n* Setting up usage limits (quotas) for your clients (per client IP) based on requests per time interval; we support various backends such as in-memory map (for single instance), or redis or memcache for distributed deployments\n* Serve the default [GeoLite2 City](http://dev.maxmind.com/geoip/geoip2/geolite2/) free database that is downloaded and updated automatically in background on a configurable schedule, or\n* Serve the commercial [GeoIP2 City](https://www.maxmind.com/en/geoip2-city) database from MaxMind, either as a local file that you provide and update periodically (so the server can reload it), or configured to be downloaded periodically using your API key\n\nSee the [Server Options](#serveroptions) section below for more information on configuring the server.\n\nFor automation, check out the [freegeoip chef cookbook](https://supermarket.chef.io/cookbooks/freegeoip) or the (legacy) [Ansible Playbook](./cmd/freegeoip/ansible-playbook) for Ubuntu 14.04 LTS.\n\n<a name=\"serveroptions\">\n\n### Server Options\n\nTo see all the available options, use the `-help` option:\n\n```bash\ndocker run --rm -it fiorix/freegeoip -help\n```\n\nIf you're using LetsEncrypt.org to provision your TLS certificates, you have to listen for HTTPS on port 443. Following is an example of the server listening on 3 different ports: metrics + pprof (8888), http (80), and https (443):\n\n```bash\ndocker run -p 8888:8888 -p 80:8080 -p 443:8443 -d fiorix/freegeoip \\\n\t-internal-server=:8888 \\\n\t-http=:8080 \\\n\t-https=:8443 \\\n\t-hsts=max-age=31536000 \\\n\t-letsencrypt \\\n\t-letsencrypt-hosts=myfancydomain.io\n```\n\n You can configure the freegeiop web server via command line flags or environment variables. The names of environment variables are the same for command line flags, but prefixed with FREEGEOIP, all upperscase, separated by underscores. If you want to use environment variables instead:\n\n```bash\n$ cat prod.env\nFREEGEOIP_INTERNAL_SERVER=:8888\nFREEGEOIP_HTTP=:8080\nFREEGEOIP_HTTPS=:8443\nFREEGEOIP_HSTS=max-age=31536000\nFREEGEOIP_LETSENCRYPT=true\nFREEGEOIP_LETSENCRYPT_HOSTS=myfancydomain.io\n\n$ docker run --env-file=prod.env -p 8888:8888 -p 80:8080 -p 443:8443 -d fiorix/freegeoip\n```\n\nBy default, HTTP/2 is enabled over HTTPS. You can disable by passing the `-http2=false` flag.\n\nAlso, the Docker image of freegeoip does not provide the web page from freegeiop.net, it only provides the API. If you want to serve that page, you can pass the `-public=/var/www` parameter in the command line. You can also tell Docker to mount that directory as a volume on the host machine and have it serve your own page, using Docker's `-v` parameter.\n\nIf the freegeoip web server is running behind a reverse proxy or load balancer, you have to run it passing the `-use-x-forwarded-for` parameter and provide the `X-Forwarded-For` HTTP header in all requests. This is for the freegeoip web server be able to log the client IP, and to perform geolocation lookups when an IP is not provided to the API, e.g. `/json/` (uses client IP) vs `/json/1.2.3.4`.\n\n## Database\n\nThe current implementation uses the free [GeoLite2 City](http://dev.maxmind.com/geoip/geoip2/geolite2/) database from MaxMind.\n\nIn the past we had databases from other providers, and at some point even our own database comprised of data from different sources. This means it might change in the future.\n\nIf you have purchased the commercial database from MaxMind, you can point the freegeoip web server or (Go API, for dev) to the URL containing the file, or local file, and the server will use it.\n\nIn case of files on disk, you can replace the file with a newer version and the freegeoip web server will reload it automatically in background. If instead of a file you use a URL (the default), we periodically check the URL in background to see if there's a new database version available, then download the reload it automatically.\n\nAll responses from the freegeiop API contain the date that the database was downloaded in the X-Database-Date HTTP header.\n\n## API\n\nThe freegeoip API is served by endpoints that encode the response in different formats.\n\nExample:\n\n```bash\ncurl freegeoip.net/json/\n```\n\nReturns the geolocation information of your own IP address, the source IP address of the connection.\n\nYou can pass a different IP or hostname. For example, to lookup the geolocation of `github.com` the server resolves the name first, then uses the first IP address available, which might be IPv4 or IPv6:\n\n```bash\ncurl freegeoip.net/json/github.com\n```\n\nSame semantics are available for the `/xml/{ip}` and `/csv/{ip}` endpoints.\n\nJSON responses can be encoded as JSONP, by adding the `callback` parameter:\n\n```bash\ncurl freegeoip.net/json/?callback=foobar\n```\n\nThe callback parameter is ignored on all other endpoints.\n\n## Metrics and profiling\n\nThe freegeoip web server can provide metrics about its usage, and also supports runtime profiling and tracing.\n\nBoth are disabled by default, but can be enabled by passing the `-internal-server` parameter in the command line. Metrics are generated for [Prometheus](http://prometheus.io) and can be queried at `/metrics` even with curl.\n\nHTTP pprof is available at `/debug/pprof` and the examples from the [pprof](https://golang.org/pkg/net/http/pprof/) package documentation should work on the freegeiop web server.\n\n<a name=\"packagefreegeoip\">\n\n## Package freegeoip\n\nThe freegeoip package for the Go programming language provides two APIs:\n\n- A database API that requires zero maintenance of the IP database;\n- A geolocation `http.Handler` that can be used/served by any http server.\n\ntl;dr if all you want is code then see the `example_test.go` file.\n\nOtherwise check out the godoc reference.\n\n[![GoDoc](https://godoc.org/github.com/fiorix/freegeoip?status.svg)](https://godoc.org/github.com/fiorix/freegeoip)\n[![Build Status](https://secure.travis-ci.org/fiorix/freegeoip.png)](http://travis-ci.org/fiorix/freegeoip)\n[![GoReportCard](https://goreportcard.com/badge/github.com/fiorix/freegeoip)](https://goreportcard.com/report/github.com/fiorix/freegeoip)\n\n### Features\n\n- Zero maintenance\n\nThe DB object alone can download an IP database file from the internet and service lookups to your program right away. It will auto-update the file in background and always magically work.\n\n- DevOps friendly\n\nIf you do care about the database and have the commercial version of the MaxMind database, you can update the database file with your program running and the DB object will load it in background. You can focus on your stuff.\n\n- Extensible\n\nBesides the database part, the package provides an `http.Handler` object that you can add to your HTTP server to service IP geolocation lookups with the same simplistic API of freegeoip.net. There's also an interface for crafting your own HTTP responses encoded in any format.\n\n### Install\n\nDownload the package:\n\n\tgo get -d github.com/fiorix/freegeoip/...\n\nInstall the web server:\n\n\tgo install github.com/fiorix/freegeoip/cmd/freegeoip\n\nTest coverage is quite good, and test code may help you find the stuff you need.\n"
        },
        {
          "name": "apiserver",
          "type": "tree",
          "content": null
        },
        {
          "name": "app.json",
          "type": "blob",
          "size": 0.1826171875,
          "content": "{\n  \"name\": \"freegeoip\",\n  \"description\": \"IP geolocation web server\",\n  \"website\": \"https://github.com/fiorix/freegeoip\",\n  \"success_url\": \"/\",\n  \"keywords\": [\"golang\", \"geoip\", \"api\"]\n}"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 10.947265625,
          "content": "// Copyright 2009 The freegeoip authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage freegeoip\n\nimport (\n\t\"compress/gzip\"\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/howeyc/fsnotify\"\n\t\"github.com/oschwald/maxminddb-golang\"\n)\n\nvar (\n\t// ErrUnavailable may be returned by DB.Lookup when the database\n\t// points to a URL and is not yet available because it's being\n\t// downloaded in background.\n\tErrUnavailable = errors.New(\"no database available\")\n\n\t// Local cached copy of a database downloaded from a URL.\n\tdefaultDB = filepath.Join(os.TempDir(), \"freegeoip\", \"db.gz\")\n\n\t// MaxMindDB is the URL of the free MaxMind GeoLite2 database.\n\tMaxMindDB = \"http://geolite.maxmind.com/download/geoip/database/GeoLite2-City.mmdb.gz\"\n)\n\n// DB is the IP geolocation database.\ntype DB struct {\n\tfile        string            // Database file name.\n\tchecksum    string            // MD5 of the unzipped database file\n\treader      *maxminddb.Reader // Actual db object.\n\tnotifyQuit  chan struct{}     // Stop auto-update and watch goroutines.\n\tnotifyOpen  chan string       // Notify when a db file is open.\n\tnotifyError chan error        // Notify when an error occurs.\n\tnotifyInfo  chan string       // Notify random actions for logging\n\tclosed      bool              // Mark this db as closed.\n\tlastUpdated time.Time         // Last time the db was updated.\n\tmu          sync.RWMutex      // Protects all the above.\n\n\tupdateInterval   time.Duration // Update interval.\n\tmaxRetryInterval time.Duration // Max retry interval in case of failure.\n}\n\n// Open creates and initializes a DB from a local file.\n//\n// The database file is monitored by fsnotify and automatically\n// reloads when the file is updated or overwritten.\nfunc Open(dsn string) (*DB, error) {\n\tdb := &DB{\n\t\tfile:        dsn,\n\t\tnotifyQuit:  make(chan struct{}),\n\t\tnotifyOpen:  make(chan string, 1),\n\t\tnotifyError: make(chan error, 1),\n\t\tnotifyInfo:  make(chan string, 1),\n\t}\n\terr := db.openFile()\n\tif err != nil {\n\t\tdb.Close()\n\t\treturn nil, err\n\t}\n\terr = db.watchFile()\n\tif err != nil {\n\t\tdb.Close()\n\t\treturn nil, fmt.Errorf(\"fsnotify failed for %s: %s\", dsn, err)\n\t}\n\treturn db, nil\n}\n\n// MaxMindUpdateURL generates the URL for MaxMind paid databases.\nfunc MaxMindUpdateURL(hostname, productID, userID, licenseKey string) (string, error) {\n\tlimiter := func(r io.Reader) *io.LimitedReader {\n\t\treturn &io.LimitedReader{R: r, N: 1 << 30}\n\t}\n\tbaseurl := \"https://\" + hostname + \"/app/\"\n\t// Get the file name for the product ID.\n\tu := baseurl + \"update_getfilename?product_id=\" + productID\n\tresp, err := http.Get(u)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tmd5hash := md5.New()\n\t_, err = io.Copy(md5hash, limiter(resp.Body))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tsum := md5hash.Sum(nil)\n\thexdigest1 := hex.EncodeToString(sum[:])\n\t// Get our client IP address.\n\tresp, err = http.Get(baseurl + \"update_getipaddr\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\tmd5hash = md5.New()\n\tio.WriteString(md5hash, licenseKey)\n\t_, err = io.Copy(md5hash, limiter(resp.Body))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tsum = md5hash.Sum(nil)\n\thexdigest2 := hex.EncodeToString(sum[:])\n\t// Generate the URL.\n\tparams := url.Values{\n\t\t\"db_md5\":        {hexdigest1},\n\t\t\"challenge_md5\": {hexdigest2},\n\t\t\"user_id\":       {userID},\n\t\t\"edition_id\":    {productID},\n\t}\n\tu = baseurl + \"update_secure?\" + params.Encode()\n\treturn u, nil\n}\n\n// OpenURL creates and initializes a DB from a URL.\n// It automatically downloads and updates the file in background, and\n// keeps a local copy on $TMPDIR.\nfunc OpenURL(url string, updateInterval, maxRetryInterval time.Duration) (*DB, error) {\n\tdb := &DB{\n\t\tfile:             defaultDB,\n\t\tnotifyQuit:       make(chan struct{}),\n\t\tnotifyOpen:       make(chan string, 1),\n\t\tnotifyError:      make(chan error, 1),\n\t\tnotifyInfo:       make(chan string, 1),\n\t\tupdateInterval:   updateInterval,\n\t\tmaxRetryInterval: maxRetryInterval,\n\t}\n\tdb.openFile() // Optional, might fail.\n\tgo db.autoUpdate(url)\n\terr := db.watchFile()\n\tif err != nil {\n\t\tdb.Close()\n\t\treturn nil, fmt.Errorf(\"fsnotify failed for %s: %s\", db.file, err)\n\t}\n\treturn db, nil\n}\n\nfunc (db *DB) watchFile() error {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdbdir, err := db.makeDir()\n\tif err != nil {\n\t\treturn err\n\t}\n\tgo db.watchEvents(watcher)\n\treturn watcher.Watch(dbdir)\n}\n\nfunc (db *DB) watchEvents(watcher *fsnotify.Watcher) {\n\tfor {\n\t\tselect {\n\t\tcase ev := <-watcher.Event:\n\t\t\tif ev.Name == db.file && (ev.IsCreate() || ev.IsModify()) {\n\t\t\t\tdb.openFile()\n\t\t\t}\n\t\tcase <-watcher.Error:\n\t\tcase <-db.notifyQuit:\n\t\t\twatcher.Close()\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(time.Second) // Suppress high-rate events.\n\t}\n}\n\nfunc (db *DB) openFile() error {\n\treader, checksum, err := db.newReader(db.file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tstat, err := os.Stat(db.file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdb.setReader(reader, stat.ModTime(), checksum)\n\treturn nil\n}\n\nfunc (db *DB) newReader(dbfile string) (*maxminddb.Reader, string, error) {\n\tf, err := os.Open(dbfile)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer f.Close()\n\tgzf, err := gzip.NewReader(f)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tdefer gzf.Close()\n\tb, err := ioutil.ReadAll(gzf)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\tchecksum := fmt.Sprintf(\"%x\", md5.Sum(b))\n\tmmdb, err := maxminddb.FromBytes(b)\n\treturn mmdb, checksum, err\n}\n\nfunc (db *DB) setReader(reader *maxminddb.Reader, modtime time.Time, checksum string) {\n\tdb.mu.Lock()\n\tdefer db.mu.Unlock()\n\tif db.closed {\n\t\treader.Close()\n\t\treturn\n\t}\n\tif db.reader != nil {\n\t\tdb.reader.Close()\n\t}\n\tdb.reader = reader\n\tdb.lastUpdated = modtime.UTC()\n\tdb.checksum = checksum\n\tselect {\n\tcase db.notifyOpen <- db.file:\n\tdefault:\n\t}\n}\n\nfunc (db *DB) autoUpdate(url string) {\n\tbackoff := time.Second\n\tfor {\n\t\tdb.sendInfo(\"starting update\")\n\t\terr := db.runUpdate(url)\n\t\tif err != nil {\n\t\t\tbs := backoff.Seconds()\n\t\t\tms := db.maxRetryInterval.Seconds()\n\t\t\tbackoff = time.Duration(math.Min(bs*math.E, ms)) * time.Second\n\t\t\tdb.sendError(fmt.Errorf(\"download failed (will retry in %s): %s\", backoff, err))\n\t\t} else {\n\t\t\tbackoff = db.updateInterval\n\t\t}\n\t\tdb.sendInfo(\"finished update\")\n\t\tselect {\n\t\tcase <-db.notifyQuit:\n\t\t\treturn\n\t\tcase <-time.After(backoff):\n\t\t\t// Sleep till time for the next update attempt.\n\t\t}\n\t}\n}\n\nfunc (db *DB) runUpdate(url string) error {\n\tyes, err := db.needUpdate(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !yes {\n\t\treturn nil\n\t}\n\ttmpfile, err := db.download(url)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = db.renameFile(tmpfile)\n\tif err != nil {\n\t\t// Cleanup the tempfile if renaming failed.\n\t\tos.RemoveAll(tmpfile)\n\t}\n\treturn err\n}\n\nfunc (db *DB) needUpdate(url string) (bool, error) {\n\tstat, err := os.Stat(db.file)\n\tif err != nil {\n\t\treturn true, nil // Local db is missing, must be downloaded.\n\t}\n\n\tresp, err := http.Head(url)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check X-Database-MD5 if it exists\n\theaderMd5 := resp.Header.Get(\"X-Database-MD5\")\n\tif len(headerMd5) > 0 && db.checksum != headerMd5 {\n\t\treturn true, nil\n\t}\n\n\tif stat.Size() != resp.ContentLength {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\nfunc (db *DB) download(url string) (tmpfile string, err error) {\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\ttmpfile = filepath.Join(os.TempDir(),\n\t\tfmt.Sprintf(\"_freegeoip.%d.db.gz\", time.Now().UnixNano()))\n\tf, err := os.Create(tmpfile)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer f.Close()\n\t_, err = io.Copy(f, resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpfile, nil\n}\n\nfunc (db *DB) makeDir() (dbdir string, err error) {\n\tdbdir = filepath.Dir(db.file)\n\t_, err = os.Stat(dbdir)\n\tif err != nil {\n\t\terr = os.MkdirAll(dbdir, 0755)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn dbdir, nil\n}\n\nfunc (db *DB) renameFile(name string) error {\n\tos.Rename(db.file, db.file+\".bak\") // Optional, might fail.\n\t_, err := db.makeDir()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Rename(name, db.file)\n}\n\n// Date returns the UTC date the database file was last modified.\n// If no database file has been opened the behaviour of Date is undefined.\nfunc (db *DB) Date() time.Time {\n\tdb.mu.RLock()\n\tdefer db.mu.RUnlock()\n\treturn db.lastUpdated\n}\n\n// NotifyClose returns a channel that is closed when the database is closed.\nfunc (db *DB) NotifyClose() <-chan struct{} {\n\treturn db.notifyQuit\n}\n\n// NotifyOpen returns a channel that notifies when a new database is\n// loaded or reloaded. This can be used to monitor background updates\n// when the DB points to a URL.\nfunc (db *DB) NotifyOpen() (filename <-chan string) {\n\treturn db.notifyOpen\n}\n\n// NotifyError returns a channel that notifies when an error occurs\n// while downloading or reloading a DB that points to a URL.\nfunc (db *DB) NotifyError() (errChan <-chan error) {\n\treturn db.notifyError\n}\n\n// NotifyInfo returns a channel that notifies informational messages\n// while downloading or reloading.\nfunc (db *DB) NotifyInfo() <-chan string {\n\treturn db.notifyInfo\n}\n\nfunc (db *DB) sendError(err error) {\n\tdb.mu.RLock()\n\tdefer db.mu.RUnlock()\n\tif db.closed {\n\t\treturn\n\t}\n\tselect {\n\tcase db.notifyError <- err:\n\tdefault:\n\t}\n}\n\nfunc (db *DB) sendInfo(message string) {\n\tdb.mu.RLock()\n\tdefer db.mu.RUnlock()\n\tif db.closed {\n\t\treturn\n\t}\n\tselect {\n\tcase db.notifyInfo <- message:\n\tdefault:\n\t}\n}\n\n// Lookup performs a database lookup of the given IP address, and stores\n// the response into the result value. The result value must be a struct\n// with specific fields and tags as described here:\n// https://godoc.org/github.com/oschwald/maxminddb-golang#Reader.Lookup\n//\n// See the DefaultQuery for an example of the result struct.\nfunc (db *DB) Lookup(addr net.IP, result interface{}) error {\n\tdb.mu.RLock()\n\tdefer db.mu.RUnlock()\n\tif db.reader != nil {\n\t\treturn db.reader.Lookup(addr, result)\n\t}\n\treturn ErrUnavailable\n}\n\n// DefaultQuery is the default query used for database lookups.\ntype DefaultQuery struct {\n\tContinent struct {\n\t\tNames map[string]string `maxminddb:\"names\"`\n\t} `maxminddb:\"continent\"`\n\tCountry struct {\n\t\tISOCode string            `maxminddb:\"iso_code\"`\n\t\tNames   map[string]string `maxminddb:\"names\"`\n\t} `maxminddb:\"country\"`\n\tRegion []struct {\n\t\tISOCode string            `maxminddb:\"iso_code\"`\n\t\tNames   map[string]string `maxminddb:\"names\"`\n\t} `maxminddb:\"subdivisions\"`\n\tCity struct {\n\t\tNames map[string]string `maxminddb:\"names\"`\n\t} `maxminddb:\"city\"`\n\tLocation struct {\n\t\tLatitude  float64 `maxminddb:\"latitude\"`\n\t\tLongitude float64 `maxminddb:\"longitude\"`\n\t\tMetroCode uint    `maxminddb:\"metro_code\"`\n\t\tTimeZone  string  `maxminddb:\"time_zone\"`\n\t} `maxminddb:\"location\"`\n\tPostal struct {\n\t\tCode string `maxminddb:\"code\"`\n\t} `maxminddb:\"postal\"`\n}\n\n// Close closes the database.\nfunc (db *DB) Close() {\n\tdb.mu.Lock()\n\tdefer db.mu.Unlock()\n\tif !db.closed {\n\t\tdb.closed = true\n\t\tclose(db.notifyQuit)\n\t\tclose(db.notifyOpen)\n\t\tclose(db.notifyError)\n\t\tclose(db.notifyInfo)\n\t}\n\tif db.reader != nil {\n\t\tdb.reader.Close()\n\t\tdb.reader = nil\n\t}\n}\n"
        },
        {
          "name": "db_test.go",
          "type": "blob",
          "size": 7.5537109375,
          "content": "// Copyright 2009 The freegeoip authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage freegeoip\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar testFile = \"testdata/db.gz\"\n\nfunc TestMaxMindUpdateURL(t *testing.T) {\n\tUserID := \"hello\"\n\tLicenseKey := \"world\"\n\tu, err := MaxMindUpdateURL(\n\t\t\"updates.maxmind.com\",\n\t\t\"GeoIP2-City\",\n\t\tUserID,\n\t\tLicenseKey,\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tuu, err := url.Parse(u)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tq := uu.Query()\n\tswitch {\n\tcase uu.Scheme != \"https\":\n\t\tt.Fatalf(\"unexpected url scheme: want https, have %q\", uu.Scheme)\n\tcase uu.Host != \"updates.maxmind.com\":\n\t\tt.Fatalf(\"unexpected url host: want updates.maxmind.com, have %q\", uu.Host)\n\tcase len(q[\"db_md5\"]) == 0:\n\t\tt.Fatal(\"missing db_md5 param\")\n\tcase len(q[\"challenge_md5\"]) == 0:\n\t\tt.Fatal(\"missing challenge_md5 param\")\n\tcase len(q[\"user_id\"]) == 0 || q[\"user_id\"][0] != UserID:\n\t\tt.Fatalf(\"unexpected user id: want %q, have %q\", UserID, q[\"user_id\"])\n\tcase len(q[\"edition_id\"]) == 0 || q[\"edition_id\"][0] != \"GeoIP2-City\":\n\t\tt.Fatalf(\"unexpected edition_id: %q\", q[\"edition_id\"])\n\t}\n}\n\nfunc TestDownload(t *testing.T) {\n\tif _, err := os.Stat(testFile); err == nil {\n\t\tt.Skip(\"Test database already exists:\", testFile)\n\t}\n\tdb := &DB{}\n\tdbfile, err := db.download(MaxMindDB)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = os.Rename(dbfile, testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNeedUpdateFileMissing(t *testing.T) {\n\tdb := &DB{file: \"does-not-exist\"}\n\tyes, err := db.needUpdate(\"whatever\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !yes {\n\t\tt.Fatal(\"Unexpected: db is supposed to need an update\")\n\t}\n}\n\nfunc TestNeedUpdateSameFile(t *testing.T) {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/testdata/\", http.FileServer(http.Dir(\".\")))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tdb := &DB{file: testFile}\n\tyes, err := db.needUpdate(srv.URL + \"/\" + testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif yes {\n\t\tt.Fatal(\"Unexpected: db is not supposed to need an update\")\n\t}\n}\n\nfunc TestNeedUpdateSameMD5(t *testing.T) {\n  db := &DB{file: testFile}\n  _, checksum, err := db.newReader(db.file)\n  if err != nil {\n    t.Fatal(err)\n  }\n  db.checksum = checksum\n\tmux := http.NewServeMux()\n  changeHeaderThenServe := func(h http.Handler) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n      w.Header().Add(\"X-Database-MD5\", checksum)\n      h.ServeHTTP(w, r)\n    }\n  }\n  mux.Handle(\"/testdata/\", changeHeaderThenServe(http.FileServer(http.Dir(\".\"))))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tyes, err := db.needUpdate(srv.URL + \"/\" + testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif yes {\n\t\tt.Fatal(\"Unexpected: db is not supposed to need an update\")\n\t}\n}\n\nfunc TestNeedUpdateMD5(t *testing.T) {\n\tmux := http.NewServeMux()\n  changeHeaderThenServe := func(h http.Handler) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n      w.Header().Add(\"X-Database-MD5\", \"9823y5981y2398y1234\")\n      h.ServeHTTP(w, r)\n    }\n  }\n  mux.Handle(\"/testdata/\", changeHeaderThenServe(http.FileServer(http.Dir(\".\"))))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tdb := &DB{file: testFile}\n\tyes, err := db.needUpdate(srv.URL + \"/\" + testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !yes {\n\t\tt.Fatal(\"Unexpected: db is supposed to need an update\")\n\t}\n}\n\nfunc TestNeedUpdate(t *testing.T) {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/testdata/\", http.FileServer(http.Dir(\".\")))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tfile := testFile + \".tmp\"\n\tf, err := os.Create(file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tdefer os.Remove(file)\n\tdb := &DB{file: file}\n\tyes, err := db.needUpdate(srv.URL + \"/\" + testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !yes {\n\t\tt.Fatal(\"Unexpected: db is supposed to need an update\")\n\t}\n}\n\nfunc TestOpenFile(t *testing.T) {\n\tdb, err := Open(testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tselect {\n\tcase <-db.NotifyOpen():\n\tcase <-db.NotifyClose():\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"Timed out\")\n\t}\n\tdb.Date() // Test this?\n}\n\nfunc TestOpenBadFile(t *testing.T) {\n\tdb, err := Open(\"db_test.go\")\n\tif err == nil {\n\t\tdb.Close()\n\t\tt.Fatal(\"Unexpected bogus db is open\")\n\t}\n}\n\nfunc TestSendError(t *testing.T) {\n\tdb := &DB{notifyError: make(chan error, 1)}\n\terr1 := errors.New(\"test\")\n\tdb.sendError(err1)\n\tselect {\n\tcase err2 := <-db.NotifyError():\n\t\tif err2 != err2 {\n\t\t\tt.Fatalf(\"Unexpected error: %#v\", err2)\n\t\t}\n\tdefault:\n\t\tt.Fatal(\"An error is expected but it's not available\")\n\t}\n}\n\nfunc TestSkipSendError(t *testing.T) {\n\tdb := &DB{notifyError: make(chan error, 1)}\n\tdb.sendError(nil)\n\tdb.sendError(nil)\n\tclose(db.notifyError)\n}\n\nfunc TestWatchFile(t *testing.T) {\n\tdb, err := Open(testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\terr = os.Rename(testFile, testFile+\".bkp\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = os.Rename(testFile+\".bkp\", testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tselect {\n\tcase file := <-db.NotifyOpen():\n\t\tif file != testFile {\n\t\t\tt.Fatal(\"Unexpected file:\", file)\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"Timed out\")\n\t}\n}\n\nfunc TestWatchMkdir(t *testing.T) {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/testdata/\", http.FileServer(http.Dir(\".\")))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\ttmp := defaultDB\n\tdefaultDB = filepath.Join(os.TempDir(), \"foobar\", \"db.gz\")\n\tdefer func() {\n\t\tdefaultDB = tmp\n\t\ttime.Sleep(time.Second)\n\t\tos.RemoveAll(filepath.Dir(defaultDB))\n\t}()\n\tdb, err := OpenURL(srv.URL+\"/\"+testFile, time.Hour, time.Minute)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create %s: %s\", filepath.Dir(defaultDB), err)\n\t}\n\tdb.Close()\n}\n\nfunc TestWatchMkdirFail(t *testing.T) {\n\tbasedir := filepath.Join(os.TempDir(), \"freegeoip-test\")\n\terr := os.MkdirAll(basedir, 0444)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmp := defaultDB\n\tdefaultDB = filepath.Join(basedir, \"a\", \"db.gz\")\n\tdefer func() {\n\t\tdefaultDB = tmp\n\t\ttime.Sleep(time.Second)\n\t\tos.Chmod(basedir, 0755)\n\t\tos.RemoveAll(basedir)\n\t}()\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/testdata/\", http.FileServer(http.Dir(\".\")))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tdb, err := OpenURL(srv.URL+\"/\"+testFile, time.Hour, time.Minute)\n\tif err == nil {\n\t\tdb.Close()\n\t\tt.Fatalf(\"Unexpected creation of dir %s worked\", basedir)\n\t}\n}\n\nfunc TestLookupOnFile(t *testing.T) {\n\tdb, err := Open(testFile)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tvar record DefaultQuery\n\terr = db.Lookup(net.ParseIP(\"8.8.8.8\"), &record)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif record.Country.ISOCode != \"US\" {\n\t\tt.Fatal(\"Unexpected ISO code:\", record.Country.ISOCode)\n\t}\n}\n\nfunc TestLookupOnURL(t *testing.T) {\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/testdata/\", http.FileServer(http.Dir(\".\")))\n\tsrv := httptest.NewServer(mux)\n\tdefer srv.Close()\n\tos.Remove(defaultDB) // In case it exists.\n\tdb, err := OpenURL(srv.URL+\"/\"+testFile, time.Hour, time.Minute)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer db.Close()\n\tselect {\n\tcase file := <-db.NotifyOpen():\n\t\tif file != defaultDB {\n\t\t\tt.Fatal(\"Unexpected db file:\", file)\n\t\t}\n\tcase err := <-db.NotifyError():\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"Timed out\")\n\t}\n\tvar record DefaultQuery\n\terr = db.Lookup(net.ParseIP(\"8.8.8.8\"), &record)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif record.Country.ISOCode != \"US\" {\n\t\tt.Fatal(\"Unexpected ISO code:\", record.Country.ISOCode)\n\t}\n}\n\nfunc TestLookuUnavailable(t *testing.T) {\n\tdb := &DB{}\n\terr := db.Lookup(net.ParseIP(\"8.8.8.8\"), nil)\n\tif err == nil {\n\t\tt.Fatal(\"Unexpected lookup worked\")\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.6025390625,
          "content": "// Copyright 2009 The freegeoip authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Package freegeoip provides an API for searching the geolocation of IP\n// addresses. It uses a database that can be either a local file or a\n// remote resource from a URL.\n//\n// Local databases are monitored by fsnotify and reloaded when the file is\n// either updated or overwritten.\n//\n// Remote databases are automatically downloaded and updated in background\n// so you can focus on using the API and not managing the database.\npackage freegeoip\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.3564453125,
          "content": "// Copyright 2009 The freegeoip authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage freegeoip\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"time\"\n)\n\nfunc ExampleOpen() {\n\tdb, err := Open(\"./testdata.gz\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar result customQuery\n\terr = db.Lookup(net.ParseIP(\"8.8.8.8\"), &result)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\tlog.Printf(\"%#v\", result)\n}\n\nfunc ExampleOpenURL() {\n\tupdateInterval := 24 * time.Hour\n\tmaxRetryInterval := time.Hour\n\tdb, err := OpenURL(MaxMindDB, updateInterval, maxRetryInterval)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\tselect {\n\tcase <-db.NotifyOpen():\n\t\t// Wait for the db to be downloaded.\n\tcase err := <-db.NotifyError():\n\t\tlog.Fatal(err)\n\t}\n\tvar result customQuery\n\terr = db.Lookup(net.ParseIP(\"8.8.8.8\"), &result)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"%#v\", result)\n}\n\n// A customQuery is the query executed in the maxmind database for\n// every IP lookup request.\ntype customQuery struct {\n\tCountry struct {\n\t\tISOCode string            `maxminddb:\"iso_code\"`\n\t\tNames   map[string]string `maxminddb:\"names\"`\n\t} `maxminddb:\"country\"`\n\tLocation struct {\n\t\tLatitude  float64 `maxminddb:\"latitude\"`\n\t\tLongitude float64 `maxminddb:\"longitude\"`\n\t\tTimeZone  string  `maxminddb:\"time_zone\"`\n\t} `maxminddb:\"location\"`\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}