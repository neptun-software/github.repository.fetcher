{
  "metadata": {
    "timestamp": 1736566733506,
    "page": 288,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bitly/go-simplejson",
      "stars": 3754,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.9990234375,
          "content": "Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.6279296875,
          "content": "### go-simplejson\n\na Go package to interact with arbitrary JSON\n\n[![Build Status](https://github.com/bitly/go-simplejson/actions/workflows/ci.yaml/badge.svg)](https://github.com/bitly/go-simplejson/actions)\n[![GoDoc](https://pkg.go.dev/badge/github.com/bitly/go-simplejson)](https://pkg.go.dev/github.com/bitly/go-simplejson)\n[![GitHub release](https://img.shields.io/github/release/bitly/go-simplejson.svg)](https://github.com/bitly/go-simplejson/releases/latest)\n\n\n### Importing\n\n    import github.com/bitly/go-simplejson\n\n### Documentation\n\nVisit the docs on [Go package discovery & docs](https://pkg.go.dev/github.com/bitly/go-simplejson)\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0458984375,
          "content": "module github.com/bitly/go-simplejson\n\ngo 1.17\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "simplejson.go",
          "type": "blob",
          "size": 9.90625,
          "content": "package simplejson\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"log\"\n)\n\n// returns the current implementation version\nfunc Version() string {\n\treturn \"0.5.1\"\n}\n\ntype Json struct {\n\tdata interface{}\n}\n\n// NewJson returns a pointer to a new `Json` object\n// after unmarshaling `body` bytes\nfunc NewJson(body []byte) (*Json, error) {\n\tj := new(Json)\n\terr := j.UnmarshalJSON(body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn j, nil\n}\n\n// New returns a pointer to a new, empty `Json` object\nfunc New() *Json {\n\treturn &Json{\n\t\tdata: make(map[string]interface{}),\n\t}\n}\n\n// Interface returns the underlying data\nfunc (j *Json) Interface() interface{} {\n\treturn j.data\n}\n\n// Encode returns its marshaled data as `[]byte`\nfunc (j *Json) Encode() ([]byte, error) {\n\treturn j.MarshalJSON()\n}\n\n// EncodePretty returns its marshaled data as `[]byte` with indentation\nfunc (j *Json) EncodePretty() ([]byte, error) {\n\treturn json.MarshalIndent(&j.data, \"\", \"  \")\n}\n\n// Implements the json.Marshaler interface.\nfunc (j *Json) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(&j.data)\n}\n\n// Set modifies `Json` map by `key` and `value`\n// Useful for changing single key/value in a `Json` object easily.\nfunc (j *Json) Set(key string, val interface{}) {\n\tm, err := j.Map()\n\tif err != nil {\n\t\treturn\n\t}\n\tm[key] = val\n}\n\n// SetPath modifies `Json`, recursively checking/creating map keys for the supplied path,\n// and then finally writing in the value\nfunc (j *Json) SetPath(branch []string, val interface{}) {\n\tif len(branch) == 0 {\n\t\tj.data = val\n\t\treturn\n\t}\n\n\t// in order to insert our branch, we need map[string]interface{}\n\tif _, ok := (j.data).(map[string]interface{}); !ok {\n\t\t// have to replace with something suitable\n\t\tj.data = make(map[string]interface{})\n\t}\n\tcurr := j.data.(map[string]interface{})\n\n\tfor i := 0; i < len(branch)-1; i++ {\n\t\tb := branch[i]\n\t\t// key exists?\n\t\tif _, ok := curr[b]; !ok {\n\t\t\tn := make(map[string]interface{})\n\t\t\tcurr[b] = n\n\t\t\tcurr = n\n\t\t\tcontinue\n\t\t}\n\n\t\t// make sure the value is the right sort of thing\n\t\tif _, ok := curr[b].(map[string]interface{}); !ok {\n\t\t\t// have to replace with something suitable\n\t\t\tn := make(map[string]interface{})\n\t\t\tcurr[b] = n\n\t\t}\n\n\t\tcurr = curr[b].(map[string]interface{})\n\t}\n\n\t// add remaining k/v\n\tcurr[branch[len(branch)-1]] = val\n}\n\n// Del modifies `Json` map by deleting `key` if it is present.\nfunc (j *Json) Del(key string) {\n\tm, err := j.Map()\n\tif err != nil {\n\t\treturn\n\t}\n\tdelete(m, key)\n}\n\n// Get returns a pointer to a new `Json` object\n// for `key` in its `map` representation\n//\n// useful for chaining operations (to traverse a nested JSON):\n//\n//\tjs.Get(\"top_level\").Get(\"dict\").Get(\"value\").Int()\nfunc (j *Json) Get(key string) *Json {\n\tm, err := j.Map()\n\tif err == nil {\n\t\tif val, ok := m[key]; ok {\n\t\t\treturn &Json{val}\n\t\t}\n\t}\n\treturn &Json{nil}\n}\n\n// GetPath searches for the item as specified by the branch\n// without the need to deep dive using Get()'s.\n//\n//\tjs.GetPath(\"top_level\", \"dict\")\nfunc (j *Json) GetPath(branch ...string) *Json {\n\tjin := j\n\tfor _, p := range branch {\n\t\tjin = jin.Get(p)\n\t}\n\treturn jin\n}\n\n// GetIndex returns a pointer to a new `Json` object\n// for `index` in its `array` representation\n//\n// this is the analog to Get when accessing elements of\n// a json array instead of a json object:\n//\n//\tjs.Get(\"top_level\").Get(\"array\").GetIndex(1).Get(\"key\").Int()\nfunc (j *Json) GetIndex(index int) *Json {\n\ta, err := j.Array()\n\tif err == nil {\n\t\tif len(a) > index {\n\t\t\treturn &Json{a[index]}\n\t\t}\n\t}\n\treturn &Json{nil}\n}\n\n// CheckGet returns a pointer to a new `Json` object and\n// a `bool` identifying success or failure\n//\n// useful for chained operations when success is important:\n//\n//\tif data, ok := js.Get(\"top_level\").CheckGet(\"inner\"); ok {\n//\t    log.Println(data)\n//\t}\nfunc (j *Json) CheckGet(key string) (*Json, bool) {\n\tm, err := j.Map()\n\tif err == nil {\n\t\tif val, ok := m[key]; ok {\n\t\t\treturn &Json{val}, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Map type asserts to `map`\nfunc (j *Json) Map() (map[string]interface{}, error) {\n\tif m, ok := (j.data).(map[string]interface{}); ok {\n\t\treturn m, nil\n\t}\n\treturn nil, errors.New(\"type assertion to map[string]interface{} failed\")\n}\n\n// Array type asserts to an `array`\nfunc (j *Json) Array() ([]interface{}, error) {\n\tif a, ok := (j.data).([]interface{}); ok {\n\t\treturn a, nil\n\t}\n\treturn nil, errors.New(\"type assertion to []interface{} failed\")\n}\n\n// Bool type asserts to `bool`\nfunc (j *Json) Bool() (bool, error) {\n\tif s, ok := (j.data).(bool); ok {\n\t\treturn s, nil\n\t}\n\treturn false, errors.New(\"type assertion to bool failed\")\n}\n\n// String type asserts to `string`\nfunc (j *Json) String() (string, error) {\n\tif s, ok := (j.data).(string); ok {\n\t\treturn s, nil\n\t}\n\treturn \"\", errors.New(\"type assertion to string failed\")\n}\n\n// Bytes type asserts to `[]byte`\nfunc (j *Json) Bytes() ([]byte, error) {\n\tif s, ok := (j.data).(string); ok {\n\t\treturn []byte(s), nil\n\t}\n\treturn nil, errors.New(\"type assertion to []byte failed\")\n}\n\n// StringArray type asserts to an `array` of `string`\nfunc (j *Json) StringArray() ([]string, error) {\n\tarr, err := j.Array()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tretArr := make([]string, 0, len(arr))\n\tfor _, a := range arr {\n\t\tif a == nil {\n\t\t\tretArr = append(retArr, \"\")\n\t\t\tcontinue\n\t\t}\n\t\ts, ok := a.(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"type assertion to []string failed\")\n\t\t}\n\t\tretArr = append(retArr, s)\n\t}\n\treturn retArr, nil\n}\n\n// MustArray guarantees the return of a `[]interface{}` (with optional default)\n//\n// useful when you want to interate over array values in a succinct manner:\n//\n//\tfor i, v := range js.Get(\"results\").MustArray() {\n//\t\tfmt.Println(i, v)\n//\t}\nfunc (j *Json) MustArray(args ...[]interface{}) []interface{} {\n\tvar def []interface{}\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustArray() received too many arguments %d\", len(args))\n\t}\n\n\ta, err := j.Array()\n\tif err == nil {\n\t\treturn a\n\t}\n\n\treturn def\n}\n\n// MustMap guarantees the return of a `map[string]interface{}` (with optional default)\n//\n// useful when you want to interate over map values in a succinct manner:\n//\n//\tfor k, v := range js.Get(\"dictionary\").MustMap() {\n//\t\tfmt.Println(k, v)\n//\t}\nfunc (j *Json) MustMap(args ...map[string]interface{}) map[string]interface{} {\n\tvar def map[string]interface{}\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustMap() received too many arguments %d\", len(args))\n\t}\n\n\ta, err := j.Map()\n\tif err == nil {\n\t\treturn a\n\t}\n\n\treturn def\n}\n\n// MustString guarantees the return of a `string` (with optional default)\n//\n// useful when you explicitly want a `string` in a single value return context:\n//\n//\tmyFunc(js.Get(\"param1\").MustString(), js.Get(\"optional_param\").MustString(\"my_default\"))\nfunc (j *Json) MustString(args ...string) string {\n\tvar def string\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustString() received too many arguments %d\", len(args))\n\t}\n\n\ts, err := j.String()\n\tif err == nil {\n\t\treturn s\n\t}\n\n\treturn def\n}\n\n// MustStringArray guarantees the return of a `[]string` (with optional default)\n//\n// useful when you want to interate over array values in a succinct manner:\n//\n//\tfor i, s := range js.Get(\"results\").MustStringArray() {\n//\t\tfmt.Println(i, s)\n//\t}\nfunc (j *Json) MustStringArray(args ...[]string) []string {\n\tvar def []string\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustStringArray() received too many arguments %d\", len(args))\n\t}\n\n\ta, err := j.StringArray()\n\tif err == nil {\n\t\treturn a\n\t}\n\n\treturn def\n}\n\n// MustInt guarantees the return of an `int` (with optional default)\n//\n// useful when you explicitly want an `int` in a single value return context:\n//\n//\tmyFunc(js.Get(\"param1\").MustInt(), js.Get(\"optional_param\").MustInt(5150))\nfunc (j *Json) MustInt(args ...int) int {\n\tvar def int\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustInt() received too many arguments %d\", len(args))\n\t}\n\n\ti, err := j.Int()\n\tif err == nil {\n\t\treturn i\n\t}\n\n\treturn def\n}\n\n// MustFloat64 guarantees the return of a `float64` (with optional default)\n//\n// useful when you explicitly want a `float64` in a single value return context:\n//\n//\tmyFunc(js.Get(\"param1\").MustFloat64(), js.Get(\"optional_param\").MustFloat64(5.150))\nfunc (j *Json) MustFloat64(args ...float64) float64 {\n\tvar def float64\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustFloat64() received too many arguments %d\", len(args))\n\t}\n\n\tf, err := j.Float64()\n\tif err == nil {\n\t\treturn f\n\t}\n\n\treturn def\n}\n\n// MustBool guarantees the return of a `bool` (with optional default)\n//\n// useful when you explicitly want a `bool` in a single value return context:\n//\n//\tmyFunc(js.Get(\"param1\").MustBool(), js.Get(\"optional_param\").MustBool(true))\nfunc (j *Json) MustBool(args ...bool) bool {\n\tvar def bool\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustBool() received too many arguments %d\", len(args))\n\t}\n\n\tb, err := j.Bool()\n\tif err == nil {\n\t\treturn b\n\t}\n\n\treturn def\n}\n\n// MustInt64 guarantees the return of an `int64` (with optional default)\n//\n// useful when you explicitly want an `int64` in a single value return context:\n//\n//\tmyFunc(js.Get(\"param1\").MustInt64(), js.Get(\"optional_param\").MustInt64(5150))\nfunc (j *Json) MustInt64(args ...int64) int64 {\n\tvar def int64\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustInt64() received too many arguments %d\", len(args))\n\t}\n\n\ti, err := j.Int64()\n\tif err == nil {\n\t\treturn i\n\t}\n\n\treturn def\n}\n\n// MustUInt64 guarantees the return of an `uint64` (with optional default)\n//\n// useful when you explicitly want an `uint64` in a single value return context:\n//\n//\tmyFunc(js.Get(\"param1\").MustUint64(), js.Get(\"optional_param\").MustUint64(5150))\nfunc (j *Json) MustUint64(args ...uint64) uint64 {\n\tvar def uint64\n\n\tswitch len(args) {\n\tcase 0:\n\tcase 1:\n\t\tdef = args[0]\n\tdefault:\n\t\tlog.Panicf(\"MustUint64() received too many arguments %d\", len(args))\n\t}\n\n\ti, err := j.Uint64()\n\tif err == nil {\n\t\treturn i\n\t}\n\n\treturn def\n}\n"
        },
        {
          "name": "simplejson_reader.go",
          "type": "blob",
          "size": 2.330078125,
          "content": "package simplejson\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\n// Implements the json.Unmarshaler interface.\nfunc (j *Json) UnmarshalJSON(p []byte) error {\n\tdec := json.NewDecoder(bytes.NewBuffer(p))\n\tdec.UseNumber()\n\treturn dec.Decode(&j.data)\n}\n\n// NewFromReader returns a *Json by decoding from an io.Reader\nfunc NewFromReader(r io.Reader) (*Json, error) {\n\tj := new(Json)\n\tdec := json.NewDecoder(r)\n\tdec.UseNumber()\n\terr := dec.Decode(&j.data)\n\treturn j, err\n}\n\n// Float64 coerces into a float64\nfunc (j *Json) Float64() (float64, error) {\n\tswitch j.data.(type) {\n\tcase json.Number:\n\t\treturn j.data.(json.Number).Float64()\n\tcase float32, float64:\n\t\treturn reflect.ValueOf(j.data).Float(), nil\n\tcase int, int8, int16, int32, int64:\n\t\treturn float64(reflect.ValueOf(j.data).Int()), nil\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\treturn float64(reflect.ValueOf(j.data).Uint()), nil\n\t}\n\treturn 0, errors.New(\"invalid value type\")\n}\n\n// Int coerces into an int\nfunc (j *Json) Int() (int, error) {\n\tswitch j.data.(type) {\n\tcase json.Number:\n\t\ti, err := j.data.(json.Number).Int64()\n\t\treturn int(i), err\n\tcase float32, float64:\n\t\treturn int(reflect.ValueOf(j.data).Float()), nil\n\tcase int, int8, int16, int32, int64:\n\t\treturn int(reflect.ValueOf(j.data).Int()), nil\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\treturn int(reflect.ValueOf(j.data).Uint()), nil\n\t}\n\treturn 0, errors.New(\"invalid value type\")\n}\n\n// Int64 coerces into an int64\nfunc (j *Json) Int64() (int64, error) {\n\tswitch j.data.(type) {\n\tcase json.Number:\n\t\treturn j.data.(json.Number).Int64()\n\tcase float32, float64:\n\t\treturn int64(reflect.ValueOf(j.data).Float()), nil\n\tcase int, int8, int16, int32, int64:\n\t\treturn reflect.ValueOf(j.data).Int(), nil\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\treturn int64(reflect.ValueOf(j.data).Uint()), nil\n\t}\n\treturn 0, errors.New(\"invalid value type\")\n}\n\n// Uint64 coerces into an uint64\nfunc (j *Json) Uint64() (uint64, error) {\n\tswitch j.data.(type) {\n\tcase json.Number:\n\t\treturn strconv.ParseUint(j.data.(json.Number).String(), 10, 64)\n\tcase float32, float64:\n\t\treturn uint64(reflect.ValueOf(j.data).Float()), nil\n\tcase int, int8, int16, int32, int64:\n\t\treturn uint64(reflect.ValueOf(j.data).Int()), nil\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\treturn reflect.ValueOf(j.data).Uint(), nil\n\t}\n\treturn 0, errors.New(\"invalid value type\")\n}\n"
        },
        {
          "name": "simplejson_reader_test.go",
          "type": "blob",
          "size": 2.7890625,
          "content": "package simplejson\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestNewFromReader(t *testing.T) {\n\t//Use New Constructor\n\tbuf := bytes.NewBuffer([]byte(`{\n\t\t\"test\": {\n\t\t\t\"array\": [1, \"2\", 3],\n\t\t\t\"arraywithsubs\": [\n\t\t\t\t{\"subkeyone\": 1},\n\t\t\t\t{\"subkeytwo\": 2, \"subkeythree\": 3}\n\t\t\t],\n\t\t\t\"bignum\": 9223372036854775807,\n\t\t\t\"uint64\": 18446744073709551615\n\t\t}\n\t}`))\n\tjs, err := NewFromReader(buf)\n\n\t//Standard Test Case\n\tif js == nil {\n\t\tt.Fatal(\"got nil\")\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"got err %#v\", err)\n\t}\n\n\tarr, _ := js.Get(\"test\").Get(\"array\").Array()\n\tif arr == nil {\n\t\tt.Fatal(\"got nil\")\n\t}\n\tfor i, v := range arr {\n\t\tvar iv int\n\t\tswitch v.(type) {\n\t\tcase json.Number:\n\t\t\ti64, err := v.(json.Number).Int64()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"got err %#v\", err)\n\t\t\t}\n\t\t\tiv = int(i64)\n\t\tcase string:\n\t\t\tiv, _ = strconv.Atoi(v.(string))\n\t\t}\n\t\tif iv != i+1 {\n\t\t\tt.Errorf(\"got %#v expected %#v\", iv, i+1)\n\t\t}\n\t}\n\n\tif ma := js.Get(\"test\").Get(\"array\").MustArray(); !reflect.DeepEqual(ma, []interface{}{json.Number(\"1\"), \"2\", json.Number(\"3\")}) {\n\t\tt.Errorf(\"got %#v\", ma)\n\t}\n\n\tmm := js.Get(\"test\").Get(\"arraywithsubs\").GetIndex(0).MustMap()\n\tif !reflect.DeepEqual(mm, map[string]interface{}{\"subkeyone\": json.Number(\"1\")}) {\n\t\tt.Errorf(\"got %#v\", mm)\n\t}\n\n\tif n := js.Get(\"test\").Get(\"bignum\").MustInt64(); n != int64(9223372036854775807) {\n\t\tt.Errorf(\"got %#v\", n)\n\t}\n\tif n := js.Get(\"test\").Get(\"uint64\").MustUint64(); n != uint64(18446744073709551615) {\n\t\tt.Errorf(\"got %#v\", n)\n\t}\n}\n\nfunc TestSimplejsonGo11(t *testing.T) {\n\tjs, err := NewJson([]byte(`{\n\t\t\"test\": {\n\t\t\t\"array\": [1, \"2\", 3],\n\t\t\t\"arraywithsubs\": [\n\t\t\t\t{\"subkeyone\": 1},\n\t\t\t\t{\"subkeytwo\": 2, \"subkeythree\": 3}\n\t\t\t],\n\t\t\t\"bignum\": 9223372036854775807,\n\t\t\t\"uint64\": 18446744073709551615\n\t\t}\n\t}`))\n\n\tif js == nil {\n\t\tt.Fatal(\"got nil\")\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"got err %#v\", err)\n\t}\n\n\tarr, _ := js.Get(\"test\").Get(\"array\").Array()\n\tif arr == nil {\n\t\tt.Fatal(\"got nil\")\n\t}\n\tfor i, v := range arr {\n\t\tvar iv int\n\t\tswitch v.(type) {\n\t\tcase json.Number:\n\t\t\ti64, err := v.(json.Number).Int64()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"got err %#v\", err)\n\t\t\t}\n\t\t\tiv = int(i64)\n\t\tcase string:\n\t\t\tiv, _ = strconv.Atoi(v.(string))\n\t\t}\n\t\tif iv != i+1 {\n\t\t\tt.Errorf(\"got %#v expected %#v\", iv, i+1)\n\t\t}\n\t}\n\n\tif ma := js.Get(\"test\").Get(\"array\").MustArray(); !reflect.DeepEqual(ma, []interface{}{json.Number(\"1\"), \"2\", json.Number(\"3\")}) {\n\t\tt.Errorf(\"got %#v\", ma)\n\t}\n\n\tmm := js.Get(\"test\").Get(\"arraywithsubs\").GetIndex(0).MustMap()\n\tif !reflect.DeepEqual(mm, map[string]interface{}{\"subkeyone\": json.Number(\"1\")}) {\n\t\tt.Errorf(\"got %#v\", mm)\n\t}\n\tif n := js.Get(\"test\").Get(\"bignum\").MustInt64(); n != int64(9223372036854775807) {\n\t\tt.Errorf(\"got %#v\", n)\n\t}\n\tif n := js.Get(\"test\").Get(\"uint64\").MustUint64(); n != uint64(18446744073709551615) {\n\t\tt.Errorf(\"got %#v\", n)\n\t}\n}\n"
        },
        {
          "name": "simplejson_test.go",
          "type": "blob",
          "size": 7.353515625,
          "content": "package simplejson\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestSimplejson(t *testing.T) {\n\tvar ok bool\n\tvar err error\n\n\tjs, err := NewJson([]byte(`{\n\t\t\"test\": {\n\t\t\t\"string_array\": [\"asdf\", \"ghjk\", \"zxcv\"],\n\t\t\t\"string_array_null\": [\"abc\", null, \"efg\"],\n\t\t\t\"array\": [1, \"2\", 3],\n\t\t\t\"arraywithsubs\": [{\"subkeyone\": 1},\n\t\t\t{\"subkeytwo\": 2, \"subkeythree\": 3}],\n\t\t\t\"int\": 10,\n\t\t\t\"float\": 5.150,\n\t\t\t\"string\": \"simplejson\",\n\t\t\t\"bool\": true,\n\t\t\t\"sub_obj\": {\"a\": 1}\n\t\t}\n\t}`))\n\tif js == nil {\n\t\tt.Fatal(\"got nil\")\n\t}\n\tif err != nil {\n\t\tt.Fatalf(\"got err %#v\", err)\n\t}\n\n\t_, ok = js.CheckGet(\"test\")\n\tif !ok {\n\t\tt.Errorf(\"test: got %#v expected true\", ok)\n\t}\n\n\t_, ok = js.CheckGet(\"missing_key\")\n\tif ok {\n\t\tt.Errorf(\"missing_key: got %#v expected false\", ok)\n\t}\n\n\taws := js.Get(\"test\").Get(\"arraywithsubs\")\n\tif aws == nil {\n\t\tt.Fatal(\"got nil\")\n\t}\n\n\tif got, _ := aws.GetIndex(0).Get(\"subkeyone\").Int(); got != 1 {\n\t\tt.Errorf(\"got %#v\", got)\n\t}\n\tif got, _ := aws.GetIndex(1).Get(\"subkeytwo\").Int(); got != 2 {\n\t\tt.Errorf(\"got %#v\", got)\n\t}\n\tif got, _ := aws.GetIndex(1).Get(\"subkeythree\").Int(); got != 3 {\n\t\tt.Errorf(\"got %#v\", got)\n\t}\n\n\tif i, _ := js.Get(\"test\").Get(\"int\").Int(); i != 10 {\n\t\tt.Errorf(\"got %#v\", i)\n\t}\n\n\tif f, _ := js.Get(\"test\").Get(\"float\").Float64(); f != 5.150 {\n\t\tt.Errorf(\"got %#v\", f)\n\t}\n\n\tif s, _ := js.Get(\"test\").Get(\"string\").String(); s != \"simplejson\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tif b, _ := js.Get(\"test\").Get(\"bool\").Bool(); b != true {\n\t\tt.Errorf(\"got %#v\", b)\n\t}\n\n\tif mi := js.Get(\"test\").Get(\"int\").MustInt(); mi != 10 {\n\t\tt.Errorf(\"got %#v\", mi)\n\t}\n\n\tif mi := js.Get(\"test\").Get(\"missing_int\").MustInt(5150); mi != 5150 {\n\t\tt.Errorf(\"got %#v\", mi)\n\t}\n\n\tif s := js.Get(\"test\").Get(\"string\").MustString(); s != \"simplejson\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tif s := js.Get(\"test\").Get(\"missing_string\").MustString(\"fyea\"); s != \"fyea\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\ta := js.Get(\"test\").Get(\"missing_array\").MustArray([]interface{}{\"1\", 2, \"3\"})\n\tif !reflect.DeepEqual(a, []interface{}{\"1\", 2, \"3\"}) {\n\t\tt.Errorf(\"got %#v\", a)\n\t}\n\n\tmsa := js.Get(\"test\").Get(\"string_array\").MustStringArray()\n\tif !reflect.DeepEqual(msa, []string{\"asdf\", \"ghjk\", \"zxcv\"}) {\n\t\tt.Errorf(\"got %#v\", msa)\n\t}\n\n\tmsa = js.Get(\"test\").Get(\"string_array\").MustStringArray([]string{\"1\", \"2\", \"3\"})\n\tif !reflect.DeepEqual(msa, []string{\"asdf\", \"ghjk\", \"zxcv\"}) {\n\t\tt.Errorf(\"got %#v\", msa)\n\t}\n\n\tmsa = js.Get(\"test\").Get(\"missing_array\").MustStringArray([]string{\"1\", \"2\", \"3\"})\n\tif !reflect.DeepEqual(msa, []string{\"1\", \"2\", \"3\"}) {\n\t\tt.Errorf(\"got %#v\", msa)\n\t}\n\n\tmm := js.Get(\"test\").Get(\"missing_map\").MustMap(map[string]interface{}{\"found\": false})\n\tif !reflect.DeepEqual(mm, map[string]interface{}{\"found\": false}) {\n\t\tt.Errorf(\"got %#v\", mm)\n\t}\n\n\tsa, err := js.Get(\"test\").Get(\"string_array\").StringArray()\n\tif err != nil {\n\t\tt.Fatalf(\"got err %#v\", err)\n\t}\n\tif !reflect.DeepEqual(sa, []string{\"asdf\", \"ghjk\", \"zxcv\"}) {\n\t\tt.Errorf(\"got %#v\", sa)\n\t}\n\n\tsa, err = js.Get(\"test\").Get(\"string_array_null\").StringArray()\n\tif err != nil {\n\t\tt.Fatalf(\"got err %#v\", err)\n\t}\n\tif !reflect.DeepEqual(sa, []string{\"abc\", \"\", \"efg\"}) {\n\t\tt.Errorf(\"got %#v\", sa)\n\t}\n\n\tif s, _ := js.GetPath(\"test\", \"string\").String(); s != \"simplejson\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tif i, _ := js.GetPath(\"test\", \"int\").Int(); i != 10 {\n\t\tt.Errorf(\"got %#v\", i)\n\t}\n\n\tif b := js.Get(\"test\").Get(\"bool\").MustBool(); b != true {\n\t\tt.Errorf(\"got %#v\", b)\n\t}\n\n\tjs.Set(\"float2\", 300.0)\n\tif f := js.Get(\"float2\").MustFloat64(); f != 300.0 {\n\t\tt.Errorf(\"got %#v\", f)\n\t}\n\n\tjs.Set(\"test2\", \"setTest\")\n\tif s := js.Get(\"test2\").MustString(); s != \"setTest\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tjs.Del(\"test2\")\n\tif s := js.Get(\"test2\").MustString(); s == \"setTest\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tjs.Get(\"test\").Get(\"sub_obj\").Set(\"a\", 2)\n\tif i := js.Get(\"test\").Get(\"sub_obj\").Get(\"a\").MustInt(); i != 2 {\n\t\tt.Errorf(\"got %#v\", i)\n\t}\n\n\tjs.GetPath(\"test\", \"sub_obj\").Set(\"a\", 3)\n\tif i := js.Get(\"test\").Get(\"sub_obj\").Get(\"a\").MustInt(); i != 3 {\n\t\tt.Errorf(\"got %#v\", i)\n\t}\n}\n\nfunc TestStdlibInterfaces(t *testing.T) {\n\tval := new(struct {\n\t\tName   string `json:\"name\"`\n\t\tParams *Json  `json:\"params\"`\n\t})\n\tval2 := new(struct {\n\t\tName   string `json:\"name\"`\n\t\tParams *Json  `json:\"params\"`\n\t})\n\n\traw := `{\"name\":\"myobject\",\"params\":{\"string\":\"simplejson\"}}`\n\n\tif err := json.Unmarshal([]byte(raw), val); err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif val.Name != \"myobject\" {\n\t\tt.Errorf(\"got %#v\", val.Name)\n\t}\n\tif val.Params.data == nil {\n\t\tt.Errorf(\"got %#v\", val.Params.data)\n\t}\n\tif s, _ := val.Params.Get(\"string\").String(); s != \"simplejson\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tp, err := json.Marshal(val)\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif err = json.Unmarshal(p, val2); err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif !reflect.DeepEqual(val, val2) { // stable\n\t\tt.Errorf(\"got %#v expected %#v\", val2, val)\n\t}\n}\n\nfunc TestSet(t *testing.T) {\n\tjs, err := NewJson([]byte(`{}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\tjs.Set(\"baz\", \"bing\")\n\n\ts, err := js.GetPath(\"baz\").String()\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif s != \"bing\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n}\n\nfunc TestReplace(t *testing.T) {\n\tjs, err := NewJson([]byte(`{}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\terr = js.UnmarshalJSON([]byte(`{\"baz\":\"bing\"}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\ts, err := js.GetPath(\"baz\").String()\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif s != \"bing\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n}\n\nfunc TestSetPath(t *testing.T) {\n\tjs, err := NewJson([]byte(`{}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\tjs.SetPath([]string{\"foo\", \"bar\"}, \"baz\")\n\n\ts, err := js.GetPath(\"foo\", \"bar\").String()\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif s != \"baz\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n}\n\nfunc TestSetPathNoPath(t *testing.T) {\n\tjs, err := NewJson([]byte(`{\"some\":\"data\",\"some_number\":1.0,\"some_bool\":false}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\tif f := js.GetPath(\"some_number\").MustFloat64(99.0); f != 1.0 {\n\t\tt.Errorf(\"got %#v\", f)\n\t}\n\n\tjs.SetPath([]string{}, map[string]interface{}{\"foo\": \"bar\"})\n\n\ts, err := js.GetPath(\"foo\").String()\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif s != \"bar\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n\n\tif f := js.GetPath(\"some_number\").MustFloat64(99.0); f != 99.0 {\n\t\tt.Errorf(\"got %#v\", f)\n\t}\n}\n\nfunc TestPathWillAugmentExisting(t *testing.T) {\n\tjs, err := NewJson([]byte(`{\"this\":{\"a\":\"aa\",\"b\":\"bb\",\"c\":\"cc\"}}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\tjs.SetPath([]string{\"this\", \"d\"}, \"dd\")\n\n\tcases := []struct {\n\t\tpath    []string\n\t\toutcome string\n\t}{\n\t\t{\n\t\t\tpath:    []string{\"this\", \"a\"},\n\t\t\toutcome: \"aa\",\n\t\t},\n\t\t{\n\t\t\tpath:    []string{\"this\", \"b\"},\n\t\t\toutcome: \"bb\",\n\t\t},\n\t\t{\n\t\t\tpath:    []string{\"this\", \"c\"},\n\t\t\toutcome: \"cc\",\n\t\t},\n\t\t{\n\t\t\tpath:    []string{\"this\", \"d\"},\n\t\t\toutcome: \"dd\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\ts, err := js.GetPath(tc.path...).String()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err %#v\", err)\n\t\t}\n\t\tif s != tc.outcome {\n\t\t\tt.Errorf(\"got %#v expected %#v\", s, tc.outcome)\n\t\t}\n\t}\n}\n\nfunc TestPathWillOverwriteExisting(t *testing.T) {\n\t// notice how \"a\" is 0.1 - but then we'll try to set at path a, foo\n\tjs, err := NewJson([]byte(`{\"this\":{\"a\":0.1,\"b\":\"bb\",\"c\":\"cc\"}}`))\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\n\tjs.SetPath([]string{\"this\", \"a\", \"foo\"}, \"bar\")\n\n\ts, err := js.GetPath(\"this\", \"a\", \"foo\").String()\n\tif err != nil {\n\t\tt.Fatalf(\"err %#v\", err)\n\t}\n\tif s != \"bar\" {\n\t\tt.Errorf(\"got %#v\", s)\n\t}\n}\n"
        }
      ]
    }
  ]
}