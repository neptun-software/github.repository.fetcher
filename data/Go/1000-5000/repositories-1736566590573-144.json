{
  "metadata": {
    "timestamp": 1736566590573,
    "page": 144,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "imroc/req",
      "stars": 4353,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2822265625,
          "content": "# IDE ignore\n.idea/\n*.ipr\n*.iml\n*.iws\n.vscode/\n\n# Emacs save files\n*~\n\\#*\\#\n.\\#*\n\n# Vim-related files\n[._]*.s[a-w][a-z]\n[._]s[a-w][a-z]\n*.un~\nSession.vim\n.netrwhist\n\n# make-related metadata\n/.make/\n\n# temp ignore\n*.log\n*.cache\n*.diff\n*.exe\n*.exe~\n*.patch\n*.tmp\n*.swp\n\n# OSX trash\n.DS_Store"
        },
        {
          "name": ".testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0390625,
          "content": "MIT License\n\nCopyright (c) 2017-2022 roc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.1640625,
          "content": "# req\n\n<p align=\"center\">\n    <p align=\"center\"><img src=\"https://req.cool/images/req.png\"></p>\n    <p align=\"center\"><strong>Simple Go HTTP client with Black Magic</strong></p>\n    <p align=\"center\">\n        <a href=\"https://github.com/imroc/req/actions/workflows/ci.yml?query=branch%3Amaster\"><img src=\"https://github.com/imroc/req/actions/workflows/ci.yml/badge.svg\" alt=\"Build Status\"></a>\n        <a href=\"https://goreportcard.com/report/github.com/imroc/req/v3\"><img src=\"https://goreportcard.com/badge/github.com/imroc/req/v3\" alt=\"Go Report Card\"></a>\n        <a href=\"https://pkg.go.dev/github.com/imroc/req/v3\"><img src=\"https://pkg.go.dev/badge/github.com/imroc/req/v3.svg\"></a>\n        <a href=\"LICENSE\"><img src=\"https://img.shields.io/github/license/imroc/req.svg\" alt=\"License\"></a>\n        <a href=\"https://github.com/imroc/req/releases\"><img src=\"https://img.shields.io/github/v/release/imroc/req?display_name=tag&sort=semver\" alt=\"GitHub Releases\"></a>\n        <a href=\"https://github.com/avelino/awesome-go\"><img src=\"https://awesome.re/mentioned-badge.svg\" alt=\"Mentioned in Awesome Go\"></a>\n    </p> \n</p>\n\n## Documentation\n\nFull documentation is available on the official website: https://req.cool.\n\n## <a name=\"Features\">Features</a>\n\n* **Simple and Powerful**: Simple and easy to use, providing rich client-level and request-level settings, all of which are intuitive and chainable methods.\n* **Easy Debugging**: Powerful and convenient debug utilities, including debug logs, performance traces, and even dump the complete request and response content (see [Debugging](https://req.cool/docs/tutorial/debugging/)).\n* **Easy API Testing**: API testing can be done with minimal code, no need to explicitly create any Request or Client, or even to handle errors (See [Quick HTTP Test](https://req.cool/docs/tutorial/quick-test/))\n* **Smart by Default**: Detect and decode to utf-8 automatically if possible to avoid garbled characters (See [Auto Decode](https://req.cool/docs/tutorial/auto-decode/)), marshal request body and unmarshal response body automatically according to the Content-Type.\n* **Support Multiple HTTP Versions**: Support `HTTP/1.1`, `HTTP/2`, and `HTTP/3`, and can automatically detect the server side and select the optimal HTTP version for requests, you can also force the protocol if you want (See [Force HTTP version](https://req.cool/docs/tutorial/force-http-version/)).\n* **Support Retry**: Support automatic request retry and is fully customizable (See [Retry](https://req.cool/docs/tutorial/retry/)).\n* **HTTP Fingerprinting**: Support http fingerprint impersonation, so that we can access websites that prohibit crawler programs by identifying http fingerprints (See [HTTP Fingerprint](https://req.cool/docs/tutorial/http-fingerprint/)).\n* **Multiple Authentication Methods**: You can use HTTP Basic Auth, Bearer Auth Token and Digest Auth out of box (see [Authentication](https://req.cool/docs/tutorial/authentication/)).\n* **Easy Download and Upload**: You can download and upload files with simple request settings, and even set a callback to show real-time progress (See [Download](https://req.cool/docs/tutorial/download/) and [Upload](https://req.cool/docs/tutorial/upload/)).\n* **Exportable**: `req.Transport` is exportable. Compared with `http.Transport`, it also supports HTTP3, dump content, middleware, etc. It can directly replace the Transport of `http.Client` in existing projects, and obtain more powerful functions with minimal code change.\n* **Extensible**: Support Middleware for Request, Response, Client and Transport (See [Request and Response Middleware](https://req.cool/docs/tutorial/middleware-for-request-and-response/)) and [Client and Transport Middleware](https://req.cool/docs/tutorial/middleware-for-client-and-transport/)).\n\n## <a name=\"Get-Started\">Get Started</a>\n\n**Install**\n\nYou first need [Go](https://go.dev/) installed (version 1.22+ is required), then you can use the below Go command to install req:\n\n``` sh\ngo get github.com/imroc/req/v3\n```\n\n**Import**\n\nImport req to your code:\n\n```go\nimport \"github.com/imroc/req/v3\"\n```\n\n**Basic Usage**\n\n```bash\n# assume the following codes in main.go file\n$ cat main.go\n```\n\n```go\npackage main\n\nimport (\n    \"github.com/imroc/req/v3\"\n)\n\nfunc main() {\n    req.DevMode() // Treat the package name as a Client, enable development mode\n    req.MustGet(\"https://httpbin.org/uuid\") // Treat the package name as a Request, send GET request.\n\n    req.EnableForceHTTP1() // Force using HTTP/1.1\n    req.MustGet(\"https://httpbin.org/uuid\")\n}\n```\n\n```bash\n$ go run main.go\n2022/05/19 10:05:07.920113 DEBUG [req] HTTP/2 GET https://httpbin.org/uuid\n:authority: httpbin.org\n:method: GET\n:path: /uuid\n:scheme: https\nuser-agent: req/v3 (https://github.com/imroc/req/v3)\naccept-encoding: gzip\n\n:status: 200\ndate: Thu, 19 May 2022 02:05:08 GMT\ncontent-type: application/json\ncontent-length: 53\nserver: gunicorn/19.9.0\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\n\n{\n  \"uuid\": \"bd519208-35d1-4483-ad9f-e1555ae108ba\"\n}\n\n2022/05/19 10:05:09.340974 DEBUG [req] HTTP/1.1 GET https://httpbin.org/uuid\nGET /uuid HTTP/1.1\nHost: httpbin.org\nUser-Agent: req/v3 (https://github.com/imroc/req/v3)\nAccept-Encoding: gzip\n\nHTTP/1.1 200 OK\nDate: Thu, 19 May 2022 02:05:09 GMT\nContent-Type: application/json\nContent-Length: 53\nConnection: keep-alive\nServer: gunicorn/19.9.0\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\n\n{\n  \"uuid\": \"49b7f916-c6f3-49d4-a6d4-22ae93b71969\"\n}\n```\n\nThe sample code above is good for quick testing purposes, which use `DevMode()` to see request details, and send requests using global wrapper methods that use the default client behind the scenes to initiate the request.\n\nIn production, it is recommended to explicitly create a client, and then use the same client to send all requests, please see other examples below.\n\n**Videos**\n\nThe following is a series of video tutorials for req:\n\n* [Youtube Play List](https://www.youtube.com/watch?v=Dy8iph8JWw0&list=PLnW6i9cc0XqlhUgOJJp5Yf1FHXlANYMhF&index=2)\n* [BiliBili 播放列表](https://www.bilibili.com/video/BV14t4y1J7cm) (Chinese)\n\n**More**\n\nCheck more introduction, tutorials, examples, best practices and API references on the [official website](https://req.cool/).\n\n## <a name=\"Simple-Get\">Simple GET</a>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/imroc/req/v3\"\n\t\"log\"\n)\n\nfunc main() {\n\tclient := req.C() // Use C() to create a client.\n\tresp, err := client.R(). // Use R() to create a request.\n\t\tGet(\"https://httpbin.org/uuid\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(resp)\n}\n```\n\n```txt\n{\n  \"uuid\": \"a4d4430d-0e5f-412f-88f5-722d84bc2a62\"\n}\n```\n\n## <a name=\"Advanced-Get\">Advanced GET</a>\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/imroc/req/v3\"\n  \"log\"\n  \"time\"\n)\n\ntype ErrorMessage struct {\n  Message string `json:\"message\"`\n}\n\ntype UserInfo struct {\n  Name string `json:\"name\"`\n  Blog string `json:\"blog\"`\n}\n\nfunc main() {\n  client := req.C().\n    SetUserAgent(\"my-custom-client\"). // Chainable client settings.\n    SetTimeout(5 * time.Second)\n\n  var userInfo UserInfo\n  var errMsg ErrorMessage\n  resp, err := client.R().\n    SetHeader(\"Accept\", \"application/vnd.github.v3+json\"). // Chainable request settings.\n    SetPathParam(\"username\", \"imroc\"). // Replace path variable in url.\n    SetSuccessResult(&userInfo). // Unmarshal response body into userInfo automatically if status code is between 200 and 299.\n    SetErrorResult(&errMsg). // Unmarshal response body into errMsg automatically if status code >= 400.\n    EnableDump(). // Enable dump at request level, only print dump content if there is an error or some unknown situation occurs to help troubleshoot.\n    Get(\"https://api.github.com/users/{username}\")\n\n  if err != nil { // Error handling.\n    log.Println(\"error:\", err)\n    log.Println(\"raw content:\")\n    log.Println(resp.Dump()) // Record raw content when error occurs.\n    return\n  }\n\n  if resp.IsErrorState() { // Status code >= 400.\n    fmt.Println(errMsg.Message) // Record error message returned.\n    return\n  }\n\n  if resp.IsSuccessState() { // Status code is between 200 and 299.\n    fmt.Printf(\"%s (%s)\\n\", userInfo.Name, userInfo.Blog)\n    return\n  }\n\n  // Unknown status code.\n  log.Println(\"unknown status\", resp.Status)\n  log.Println(\"raw content:\")\n  log.Println(resp.Dump()) // Record raw content when server returned unknown status code.\n}\n```\n\nNormally it will output (SuccessState):\n\n```txt\nroc (https://imroc.cc)\n```\n\n## <a name=\"More-Advanced-Get\">More Advanced GET</a>\n\nYou can set up a unified logic for error handling on the client, so that each time you send a request you only need to focus on the success situation, reducing duplicate code.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/imroc/req/v3\"\n\t\"log\"\n\t\"time\"\n)\n\ntype ErrorMessage struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc (msg *ErrorMessage) Error() string {\n\treturn fmt.Sprintf(\"API Error: %s\", msg.Message)\n}\n\ntype UserInfo struct {\n\tName string `json:\"name\"`\n\tBlog string `json:\"blog\"`\n}\n\nvar client = req.C().\n\tSetUserAgent(\"my-custom-client\"). // Chainable client settings.\n\tSetTimeout(5 * time.Second).\n\tEnableDumpEachRequest().\n\tSetCommonErrorResult(&ErrorMessage{}).\n\tOnAfterResponse(func(client *req.Client, resp *req.Response) error {\n\t\tif resp.Err != nil { // There is an underlying error, e.g. network error or unmarshal error.\n\t\t\treturn nil\n\t\t}\n\t\tif errMsg, ok := resp.ErrorResult().(*ErrorMessage); ok {\n\t\t\tresp.Err = errMsg // Convert api error into go error\n\t\t\treturn nil\n\t\t}\n\t\tif !resp.IsSuccessState() {\n\t\t\t// Neither a success response nor a error response, record details to help troubleshooting\n\t\t\tresp.Err = fmt.Errorf(\"bad status: %s\\nraw content:\\n%s\", resp.Status, resp.Dump())\n\t\t}\n\t\treturn nil\n\t})\n\nfunc main() {\n\tvar userInfo UserInfo\n\tresp, err := client.R().\n\t\tSetHeader(\"Accept\", \"application/vnd.github.v3+json\"). // Chainable request settings\n\t\tSetPathParam(\"username\", \"imroc\").\n\t\tSetSuccessResult(&userInfo). // Unmarshal response body into userInfo automatically if status code is between 200 and 299.\n\t\tGet(\"https://api.github.com/users/{username}\")\n\n\tif err != nil { // Error handling.\n\t\tlog.Println(\"error:\", err)\n\t\treturn\n\t}\n\n\tif resp.IsSuccessState() { // Status code is between 200 and 299.\n\t\tfmt.Printf(\"%s (%s)\\n\", userInfo.Name, userInfo.Blog)\n\t}\n}\n```\n\n## <a name=\"Simple-Post\">Simple POST</a>\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/imroc/req/v3\"\n  \"log\"\n)\n\ntype Repo struct {\n  Name string `json:\"name\"`\n  Url  string `json:\"url\"`\n}\n\ntype Result struct {\n  Data string `json:\"data\"`\n}\n\nfunc main() {\n  client := req.C().DevMode()\n  var result Result\n\n  resp, err := client.R().\n    SetBody(&Repo{Name: \"req\", Url: \"https://github.com/imroc/req\"}).\n    SetSuccessResult(&result).\n    Post(\"https://httpbin.org/post\")\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  if !resp.IsSuccessState() {\n    fmt.Println(\"bad response status:\", resp.Status)\n    return\n  }\n  fmt.Println(\"++++++++++++++++++++++++++++++++++++++++++++++++\")\n  fmt.Println(\"data:\", result.Data)\n  fmt.Println(\"++++++++++++++++++++++++++++++++++++++++++++++++\")\n}\n```\n\n```txt\n2022/05/19 20:11:00.151171 DEBUG [req] HTTP/2 POST https://httpbin.org/post\n:authority: httpbin.org\n:method: POST\n:path: /post\n:scheme: https\nuser-agent: req/v3 (https://github.com/imroc/req/v3)\ncontent-type: application/json; charset=utf-8\ncontent-length: 55\naccept-encoding: gzip\n\n{\"name\":\"req\",\"website\":\"https://github.com/imroc/req\"}\n\n:status: 200\ndate: Thu, 19 May 2022 12:11:00 GMT\ncontent-type: application/json\ncontent-length: 651\nserver: gunicorn/19.9.0\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\n\n{\n  \"args\": {},\n  \"data\": \"{\\\"name\\\":\\\"req\\\",\\\"website\\\":\\\"https://github.com/imroc/req\\\"}\",\n  \"files\": {},\n  \"form\": {},\n  \"headers\": {\n    \"Accept-Encoding\": \"gzip\",\n    \"Content-Length\": \"55\",\n    \"Content-Type\": \"application/json; charset=utf-8\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"req/v3 (https://github.com/imroc/req/v3)\",\n    \"X-Amzn-Trace-Id\": \"Root=1-628633d4-7559d633152b4307288ead2e\"\n  },\n  \"json\": {\n    \"name\": \"req\",\n    \"website\": \"https://github.com/imroc/req\"\n  },\n  \"origin\": \"103.7.29.30\",\n  \"url\": \"https://httpbin.org/post\"\n}\n\n++++++++++++++++++++++++++++++++++++++++++++++++\ndata: {\"name\":\"req\",\"url\":\"https://github.com/imroc/req\"}\n++++++++++++++++++++++++++++++++++++++++++++++++\n```\n\n## <a name=\"Do-API-Style\">Do API Style</a>\n\nIf you like, you can also use a Do API style like the following to make requests:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/imroc/req/v3\"\n)\n\ntype APIResponse struct {\n\tOrigin string `json:\"origin\"`\n\tUrl    string `json:\"url\"`\n}\n\nfunc main() {\n\tvar resp APIResponse\n\tc := req.C().SetBaseURL(\"https://httpbin.org/post\")\n\terr := c.Post().\n\t\tSetBody(\"hello\").\n\t\tDo().\n\t\tInto(&resp)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"My IP is\", resp.Origin)\n}\n```\n\n```txt\nMy IP is 182.138.155.113\n```\n\n* The order of chain calls is more intuitive: first call Client to create a request with a specified Method, then use chain calls to set the request, then use `Do()` to fire the request, return Response, and finally call `Response.Into` to unmarshal response body into specified object.\n* `Response.Into` will return an error if an error occurs during sending the request or during unmarshalling.\n* The url of some APIs is fixed, and different types of requests are implemented by passing different bodies. In this scenario, `Client.SetBaseURL` can be used to set a unified url, and there is no need to set the url for each request when initiating a request. Of course, you can also call `Request.SetURL` to set it if you need it.\n\n## <a name=\"Build-SDK-With-Req\">Build SDK With Req</a>\n\nHere is an example of building GitHub's SDK with req, using two styles (`GetUserProfile_Style1`, `GetUserProfile_Style2`).\n\n```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/imroc/req/v3\"\n)\n\ntype ErrorMessage struct {\n\tMessage string `json:\"message\"`\n}\n\n// Error implements go error interface.\nfunc (msg *ErrorMessage) Error() string {\n\treturn fmt.Sprintf(\"API Error: %s\", msg.Message)\n}\n\ntype GithubClient struct {\n\t*req.Client\n}\n\nfunc NewGithubClient() *GithubClient {\n\treturn &GithubClient{\n\t\tClient: req.C().\n\t\t\tSetBaseURL(\"https://api.github.com\").\n\t\t\tSetCommonErrorResult(&ErrorMessage{}).\n\t\t\tEnableDumpEachRequest().\n\t\t\tOnAfterResponse(func(client *req.Client, resp *req.Response) error {\n\t\t\t\tif resp.Err != nil { // There is an underlying error, e.g. network error or unmarshal error.\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif errMsg, ok := resp.ErrorResult().(*ErrorMessage); ok {\n\t\t\t\t\tresp.Err = errMsg // Convert api error into go error\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif !resp.IsSuccessState() {\n\t\t\t\t\t// Neither a success response nor a error response, record details to help troubleshooting\n\t\t\t\t\tresp.Err = fmt.Errorf(\"bad status: %s\\nraw content:\\n%s\", resp.Status, resp.Dump())\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}),\n\t}\n}\n\ntype UserProfile struct {\n\tName string `json:\"name\"`\n\tBlog string `json:\"blog\"`\n}\n\n// GetUserProfile_Style1 returns the user profile for the specified user.\n// Github API doc: https://docs.github.com/en/rest/users/users#get-a-user\nfunc (c *GithubClient) GetUserProfile_Style1(ctx context.Context, username string) (user *UserProfile, err error) {\n\t_, err = c.R().\n\t\tSetContext(ctx).\n\t\tSetPathParam(\"username\", username).\n\t\tSetSuccessResult(&user).\n\t\tGet(\"/users/{username}\")\n\treturn\n}\n\n// GetUserProfile_Style2 returns the user profile for the specified user.\n// Github API doc: https://docs.github.com/en/rest/users/users#get-a-user\nfunc (c *GithubClient) GetUserProfile_Style2(ctx context.Context, username string) (user *UserProfile, err error) {\n\terr = c.Get(\"/users/{username}\").\n\t\tSetPathParam(\"username\", username).\n\t\tDo(ctx).\n\t\tInto(&user)\n\treturn\n}\n```\n\n## Contributing\n\nIf you have a bug report or feature request, you can [open an issue](https://github.com/imroc/req/issues/new), and [pull requests](https://github.com/imroc/req/pulls) are also welcome.\n\n## Contact\n\nIf you have questions, feel free to reach out to us in the following ways:\n\n* [Github Discussion](https://github.com/imroc/req/discussions)\n* [Slack](https://imroc-req.slack.com/archives/C03UFPGSNC8) | [Join](https://slack.req.cool/)\n\n## Sponsors\n\nIf you like req and it really helps you, feel free to reward me with a cup of coffee, and don't forget to mention your github id.\n\n<table>\n    <tr>\n        <td align=\"center\">\n            <img src=\"https://req.cool/images/wechat.jpg\" width=\"200px\"   alt=\"\"/>\n            <br />\n            <sub><b>Wechat</b></sub>\n        </td>\n        <td align=\"center\">\n            <img src=\"https://req.cool/images/alipay.jpg\" width=\"200px\"   alt=\"\"/>\n            <br />\n            <sub><b>Alipay</b></sub>\n        </td>\n    </tr>\n</table>\n\nMany thanks to the following sponsors:\n\n<table>\n    <tr>\n        <td align=\"center\">\n            <a href=\"https://github.com/M-Cosmosss\">\n                <img src=\"https://avatars.githubusercontent.com/u/46757262?v=4?s=100\" width=\"160px\"   alt=\"\"/>\n                <br />\n                <sub><b>M-Cosmosss 🥇</b></sub>\n            </a>\n        </td>\n        <td align=\"center\">\n            <a href=\"https://github.com/aadog\">\n                <img src=\"https://avatars.githubusercontent.com/u/18098725?v=4?s=100\" width=\"160px\"   alt=\"\"/>\n                <br />\n                <sub><b>aadog 🥈</b></sub>\n            </a>\n        </td>\n    </tr>\n</table>\n\n## <a name=\"License\">License</a>\n\n`Req` released under MIT license, refer [LICENSE](LICENSE) file.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.115234375,
          "content": "# Security Policy\n\n## Supported Versions\n\nreq version >= `v3.43.x`\n\n## Reporting a Vulnerability\n\nEmail: roc@imroc.cc\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 53,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\turlpkg \"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\tutls \"github.com/refraction-networking/utls\"\n\t\"golang.org/x/net/publicsuffix\"\n\n\t\"github.com/imroc/req/v3/http2\"\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/util\"\n)\n\n// DefaultClient returns the global default Client.\nfunc DefaultClient() *Client {\n\treturn defaultClient\n}\n\n// SetDefaultClient override the global default Client.\nfunc SetDefaultClient(c *Client) {\n\tif c != nil {\n\t\tdefaultClient = c\n\t}\n}\n\nvar defaultClient = C()\n\n// Client is the req's http client.\ntype Client struct {\n\tBaseURL               string\n\tPathParams            map[string]string\n\tQueryParams           urlpkg.Values\n\tFormData              urlpkg.Values\n\tDebugLog              bool\n\tAllowGetMethodPayload bool\n\t*Transport\n\n\tcookiejarFactory        func() *cookiejar.Jar\n\ttrace                   bool\n\tdisableAutoReadResponse bool\n\tcommonErrorType         reflect.Type\n\tretryOption             *retryOption\n\tjsonMarshal             func(v interface{}) ([]byte, error)\n\tjsonUnmarshal           func(data []byte, v interface{}) error\n\txmlMarshal              func(v interface{}) ([]byte, error)\n\txmlUnmarshal            func(data []byte, v interface{}) error\n\tmultipartBoundaryFunc   func() string\n\toutputDirectory         string\n\tscheme                  string\n\tlog                     Logger\n\tdumpOptions             *DumpOptions\n\thttpClient              *http.Client\n\tbeforeRequest           []RequestMiddleware\n\tudBeforeRequest         []RequestMiddleware\n\tafterResponse           []ResponseMiddleware\n\twrappedRoundTrip        RoundTripper\n\troundTripWrappers       []RoundTripWrapper\n\tresponseBodyTransformer func(rawBody []byte, req *Request, resp *Response) (transformedBody []byte, err error)\n\tresultStateCheckFunc    func(resp *Response) ResultState\n\tonError                 ErrorHook\n}\n\ntype ErrorHook func(client *Client, req *Request, resp *Response, err error)\n\n// R create a new request.\nfunc (c *Client) R() *Request {\n\treturn &Request{\n\t\tclient:      c,\n\t\tretryOption: c.retryOption.Clone(),\n\t}\n}\n\n// Get create a new GET request, accepts 0 or 1 url.\nfunc (c *Client) Get(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodGet\n\treturn r\n}\n\n// Post create a new POST request.\nfunc (c *Client) Post(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodPost\n\treturn r\n}\n\n// Patch create a new PATCH request.\nfunc (c *Client) Patch(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodPatch\n\treturn r\n}\n\n// Delete create a new DELETE request.\nfunc (c *Client) Delete(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodDelete\n\treturn r\n}\n\n// Put create a new PUT request.\nfunc (c *Client) Put(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodPut\n\treturn r\n}\n\n// Head create a new HEAD request.\nfunc (c *Client) Head(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodHead\n\treturn r\n}\n\n// Options create a new OPTIONS request.\nfunc (c *Client) Options(url ...string) *Request {\n\tr := c.R()\n\tif len(url) > 0 {\n\t\tr.RawURL = url[0]\n\t}\n\tr.Method = http.MethodOptions\n\treturn r\n}\n\n// GetTransport return the underlying transport.\nfunc (c *Client) GetTransport() *Transport {\n\treturn c.Transport\n}\n\n// SetResponseBodyTransformer set the response body transformer, which can modify the\n// response body before unmarshalled if auto-read response body is not disabled.\nfunc (c *Client) SetResponseBodyTransformer(fn func(rawBody []byte, req *Request, resp *Response) (transformedBody []byte, err error)) *Client {\n\tc.responseBodyTransformer = fn\n\treturn c\n}\n\n// SetCommonError set the common result that response body will be unmarshalled to\n// if no error occurs but Response.ResultState returns ErrorState, by default it\n// is HTTP status `code >= 400`, you can also use SetCommonResultStateChecker\n// to customize the result state check logic.\n//\n// Deprecated: Use SetCommonErrorResult instead.\nfunc (c *Client) SetCommonError(err interface{}) *Client {\n\treturn c.SetCommonErrorResult(err)\n}\n\n// SetCommonErrorResult set the common result that response body will be unmarshalled to\n// if no error occurs but Response.ResultState returns ErrorState, by default it\n// is HTTP status `code >= 400`, you can also use SetCommonResultStateChecker\n// to customize the result state check logic.\nfunc (c *Client) SetCommonErrorResult(err interface{}) *Client {\n\tif err != nil {\n\t\tc.commonErrorType = util.GetType(err)\n\t}\n\treturn c\n}\n\n// ResultState represents the state of the result.\ntype ResultState int\n\nconst (\n\t// SuccessState indicates the response is in success state,\n\t// and result will be unmarshalled if Request.SetSuccessResult\n\t// is called.\n\tSuccessState ResultState = iota\n\t// ErrorState indicates the response is in error state,\n\t// and result will be unmarshalled if Request.SetErrorResult\n\t// or Client.SetCommonErrorResult is called.\n\tErrorState\n\t// UnknownState indicates the response is in unknown state,\n\t// and handler will be invoked if Request.SetUnknownResultHandlerFunc\n\t// or Client.SetCommonUnknownResultHandlerFunc is called.\n\tUnknownState\n)\n\n// SetResultStateCheckFunc overrides the default result state checker with customized one,\n// which returns SuccessState when HTTP status `code >= 200 and <= 299`, and returns\n// ErrorState when HTTP status `code >= 400`, otherwise returns UnknownState.\nfunc (c *Client) SetResultStateCheckFunc(fn func(resp *Response) ResultState) *Client {\n\tc.resultStateCheckFunc = fn\n\treturn c\n}\n\n// SetCommonFormDataFromValues set the form data from url.Values for requests\n// fired from the client which request method allows payload.\nfunc (c *Client) SetCommonFormDataFromValues(data urlpkg.Values) *Client {\n\tif c.FormData == nil {\n\t\tc.FormData = urlpkg.Values{}\n\t}\n\tfor k, v := range data {\n\t\tfor _, kv := range v {\n\t\t\tc.FormData.Add(k, kv)\n\t\t}\n\t}\n\treturn c\n}\n\n// SetCommonFormData set the form data from map for requests fired from the client\n// which request method allows payload.\nfunc (c *Client) SetCommonFormData(data map[string]string) *Client {\n\tif c.FormData == nil {\n\t\tc.FormData = urlpkg.Values{}\n\t}\n\tfor k, v := range data {\n\t\tc.FormData.Set(k, v)\n\t}\n\treturn c\n}\n\n// SetMultipartBoundaryFunc overrides the default function used to generate\n// boundary delimiters for \"multipart/form-data\" requests with a customized one,\n// which returns a boundary delimiter (without the two leading hyphens).\n//\n// Boundary delimiter may only contain certain ASCII characters, and must be\n// non-empty and at most 70 bytes long (see RFC 2046, Section 5.1.1).\nfunc (c *Client) SetMultipartBoundaryFunc(fn func() string) *Client {\n\tc.multipartBoundaryFunc = fn\n\treturn c\n}\n\n// SetBaseURL set the default base URL, will be used if request URL is\n// a relative URL.\nfunc (c *Client) SetBaseURL(u string) *Client {\n\tc.BaseURL = strings.TrimRight(u, \"/\")\n\treturn c\n}\n\n// SetOutputDirectory set output directory that response will\n// be downloaded to.\nfunc (c *Client) SetOutputDirectory(dir string) *Client {\n\tc.outputDirectory = dir\n\treturn c\n}\n\n// SetCertFromFile helps to set client certificates from cert and key file.\nfunc (c *Client) SetCertFromFile(certFile, keyFile string) *Client {\n\tcert, err := tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\tc.log.Errorf(\"failed to load client cert: %v\", err)\n\t\treturn c\n\t}\n\tconfig := c.GetTLSClientConfig()\n\tconfig.Certificates = append(config.Certificates, cert)\n\treturn c\n}\n\n// SetCerts set client certificates.\nfunc (c *Client) SetCerts(certs ...tls.Certificate) *Client {\n\tconfig := c.GetTLSClientConfig()\n\tconfig.Certificates = append(config.Certificates, certs...)\n\treturn c\n}\n\nfunc (c *Client) appendRootCertData(data []byte) {\n\tconfig := c.GetTLSClientConfig()\n\tif config.RootCAs == nil {\n\t\tconfig.RootCAs = x509.NewCertPool()\n\t}\n\tconfig.RootCAs.AppendCertsFromPEM(data)\n}\n\n// SetRootCertFromString set root certificates from string.\nfunc (c *Client) SetRootCertFromString(pemContent string) *Client {\n\tc.appendRootCertData([]byte(pemContent))\n\treturn c\n}\n\n// SetRootCertsFromFile set root certificates from files.\nfunc (c *Client) SetRootCertsFromFile(pemFiles ...string) *Client {\n\tfor _, pemFile := range pemFiles {\n\t\trootPemData, err := os.ReadFile(pemFile)\n\t\tif err != nil {\n\t\t\tc.log.Errorf(\"failed to read root cert file: %v\", err)\n\t\t\treturn c\n\t\t}\n\t\tc.appendRootCertData(rootPemData)\n\t}\n\treturn c\n}\n\n// GetTLSClientConfig return the underlying tls.Config.\nfunc (c *Client) GetTLSClientConfig() *tls.Config {\n\tif c.TLSClientConfig == nil {\n\t\tc.TLSClientConfig = &tls.Config{\n\t\t\tNextProtos: []string{\"h2\", \"http/1.1\"},\n\t\t}\n\t}\n\treturn c.TLSClientConfig\n}\n\n// SetRedirectPolicy set the RedirectPolicy which controls the behavior of receiving redirect\n// responses (usually responses with 301 and 302 status code), see the predefined\n// AllowedDomainRedirectPolicy, AllowedHostRedirectPolicy, DefaultRedirectPolicy, MaxRedirectPolicy,\n// NoRedirectPolicy, SameDomainRedirectPolicy and SameHostRedirectPolicy.\nfunc (c *Client) SetRedirectPolicy(policies ...RedirectPolicy) *Client {\n\tif len(policies) == 0 {\n\t\treturn c\n\t}\n\tc.httpClient.CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\t\tfor _, f := range policies {\n\t\t\tif f == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\terr := f(req, via)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif c.DebugLog {\n\t\t\tc.log.Debugf(\"<redirect> %s %s\", req.Method, req.URL.String())\n\t\t}\n\t\treturn nil\n\t}\n\treturn c\n}\n\n// DisableKeepAlives disable the HTTP keep-alives (enabled by default)\n// and will only use the connection to the server for a single\n// HTTP request.\n//\n// This is unrelated to the similarly named TCP keep-alives.\nfunc (c *Client) DisableKeepAlives() *Client {\n\tc.Transport.DisableKeepAlives = true\n\treturn c\n}\n\n// EnableKeepAlives enables HTTP keep-alives (enabled by default).\nfunc (c *Client) EnableKeepAlives() *Client {\n\tc.Transport.DisableKeepAlives = false\n\treturn c\n}\n\n// DisableCompression disables the compression (enabled by default),\n// which prevents the Transport from requesting compression\n// with an \"Accept-Encoding: gzip\" request header when the\n// Request contains no existing Accept-Encoding value. If\n// the Transport requests gzip on its own and gets a gzipped\n// response, it's transparently decoded in the Response.Body.\n// However, if the user explicitly requested gzip it is not\n// automatically uncompressed.\nfunc (c *Client) DisableCompression() *Client {\n\tc.Transport.DisableCompression = true\n\treturn c\n}\n\n// EnableCompression enables the compression (enabled by default).\nfunc (c *Client) EnableCompression() *Client {\n\tc.Transport.DisableCompression = false\n\treturn c\n}\n\n// EnableAutoDecompress enables the automatic decompression (disabled by default).\nfunc (c *Client) EnableAutoDecompress() *Client {\n\tc.Transport.AutoDecompression = true\n\treturn c\n}\n\n// DisableAutoDecompress disables the automatic decompression (disabled by default).\nfunc (c *Client) DisableAutoDecompress() *Client {\n\tc.Transport.AutoDecompression = false\n\treturn c\n}\n\n// SetTLSClientConfig set the TLS client config. Be careful! Usually\n// you don't need this, you can directly set the tls configuration with\n// methods like EnableInsecureSkipVerify, SetCerts etc. Or you can call\n// GetTLSClientConfig to get the current tls configuration to avoid\n// overwriting some important configurations, such as not setting NextProtos\n// will not use http2 by default.\nfunc (c *Client) SetTLSClientConfig(conf *tls.Config) *Client {\n\tc.TLSClientConfig = conf\n\treturn c\n}\n\n// EnableInsecureSkipVerify enable send https without verifing\n// the server's certificates (disabled by default).\nfunc (c *Client) EnableInsecureSkipVerify() *Client {\n\tc.GetTLSClientConfig().InsecureSkipVerify = true\n\treturn c\n}\n\n// DisableInsecureSkipVerify disable send https without verifing\n// the server's certificates (disabled by default).\nfunc (c *Client) DisableInsecureSkipVerify() *Client {\n\tc.GetTLSClientConfig().InsecureSkipVerify = false\n\treturn c\n}\n\n// SetCommonQueryParams set URL query parameters with a map\n// for requests fired from the client.\nfunc (c *Client) SetCommonQueryParams(params map[string]string) *Client {\n\tfor k, v := range params {\n\t\tc.SetCommonQueryParam(k, v)\n\t}\n\treturn c\n}\n\n// AddCommonQueryParam add a URL query parameter with a key-value\n// pair for requests fired from the client.\nfunc (c *Client) AddCommonQueryParam(key, value string) *Client {\n\tif c.QueryParams == nil {\n\t\tc.QueryParams = make(urlpkg.Values)\n\t}\n\tc.QueryParams.Add(key, value)\n\treturn c\n}\n\n// AddCommonQueryParams add one or more values of specified URL query parameter\n// for requests fired from the client.\nfunc (c *Client) AddCommonQueryParams(key string, values ...string) *Client {\n\tif c.QueryParams == nil {\n\t\tc.QueryParams = make(urlpkg.Values)\n\t}\n\tvs := c.QueryParams[key]\n\tvs = append(vs, values...)\n\tc.QueryParams[key] = vs\n\treturn c\n}\n\nfunc (c *Client) pathParams() map[string]string {\n\tif c.PathParams == nil {\n\t\tc.PathParams = make(map[string]string)\n\t}\n\treturn c.PathParams\n}\n\n// SetCommonPathParam set a path parameter for requests fired from the client.\nfunc (c *Client) SetCommonPathParam(key, value string) *Client {\n\tc.pathParams()[key] = value\n\treturn c\n}\n\n// SetCommonPathParams set path parameters for requests fired from the client.\nfunc (c *Client) SetCommonPathParams(pathParams map[string]string) *Client {\n\tm := c.pathParams()\n\tfor k, v := range pathParams {\n\t\tm[k] = v\n\t}\n\treturn c\n}\n\n// SetCommonQueryParam set a URL query parameter with a key-value\n// pair for requests fired from the client.\nfunc (c *Client) SetCommonQueryParam(key, value string) *Client {\n\tif c.QueryParams == nil {\n\t\tc.QueryParams = make(urlpkg.Values)\n\t}\n\tc.QueryParams.Set(key, value)\n\treturn c\n}\n\n// SetCommonQueryString set URL query parameters with a raw query string\n// for requests fired from the client.\nfunc (c *Client) SetCommonQueryString(query string) *Client {\n\tparams, err := urlpkg.ParseQuery(strings.TrimSpace(query))\n\tif err != nil {\n\t\tc.log.Warnf(\"failed to parse query string (%s): %v\", query, err)\n\t\treturn c\n\t}\n\tif c.QueryParams == nil {\n\t\tc.QueryParams = make(urlpkg.Values)\n\t}\n\tfor p, v := range params {\n\t\tfor _, pv := range v {\n\t\t\tc.QueryParams.Add(p, pv)\n\t\t}\n\t}\n\treturn c\n}\n\n// SetCommonCookies set HTTP cookies for requests fired from the client.\nfunc (c *Client) SetCommonCookies(cookies ...*http.Cookie) *Client {\n\tc.Cookies = append(c.Cookies, cookies...)\n\treturn c\n}\n\n// DisableDebugLog disable debug level log (disabled by default).\nfunc (c *Client) DisableDebugLog() *Client {\n\tc.DebugLog = false\n\treturn c\n}\n\n// EnableDebugLog enable debug level log (disabled by default).\nfunc (c *Client) EnableDebugLog() *Client {\n\tc.DebugLog = true\n\treturn c\n}\n\n// DevMode enables:\n// 1. Dump content of all requests and responses to see details.\n// 2. Output debug level log for deeper insights.\n// 3. Trace all requests, so you can get trace info to analyze performance.\nfunc (c *Client) DevMode() *Client {\n\treturn c.EnableDumpAll().\n\t\tEnableDebugLog().\n\t\tEnableTraceAll()\n}\n\n// SetScheme set the default scheme for client, will be used when\n// there is no scheme in the request URL (e.g. \"github.com/imroc/req\").\nfunc (c *Client) SetScheme(scheme string) *Client {\n\tif !util.IsStringEmpty(scheme) {\n\t\tc.scheme = strings.TrimSpace(scheme)\n\t}\n\treturn c\n}\n\n// GetLogger return the internal logger, usually used in middleware.\nfunc (c *Client) GetLogger() Logger {\n\tif c.log != nil {\n\t\treturn c.log\n\t}\n\tc.log = createDefaultLogger()\n\treturn c.log\n}\n\n// SetLogger set the customized logger for client, will disable log if set to nil.\nfunc (c *Client) SetLogger(log Logger) *Client {\n\tif log == nil {\n\t\tc.log = &disableLogger{}\n\t\treturn c\n\t}\n\tc.log = log\n\treturn c\n}\n\n// SetTimeout set timeout for requests fired from the client.\nfunc (c *Client) SetTimeout(d time.Duration) *Client {\n\tc.httpClient.Timeout = d\n\treturn c\n}\n\nfunc (c *Client) getDumpOptions() *DumpOptions {\n\tif c.dumpOptions == nil {\n\t\tc.dumpOptions = newDefaultDumpOptions()\n\t}\n\treturn c.dumpOptions\n}\n\n// EnableDumpAll enable dump for requests fired from the client, including\n// all content for the request and response by default.\nfunc (c *Client) EnableDumpAll() *Client {\n\tif c.Dump != nil { // dump already started\n\t\treturn c\n\t}\n\tc.EnableDump(c.getDumpOptions())\n\treturn c\n}\n\n// EnableDumpAllToFile enable dump for requests fired from the\n// client and output to the specified file.\nfunc (c *Client) EnableDumpAllToFile(filename string) *Client {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\tc.log.Errorf(\"create dump file error: %v\", err)\n\t\treturn c\n\t}\n\tc.getDumpOptions().Output = file\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllTo enable dump for requests fired from the\n// client and output to the specified io.Writer.\nfunc (c *Client) EnableDumpAllTo(output io.Writer) *Client {\n\tc.getDumpOptions().Output = output\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllAsync enable dump for requests fired from the\n// client and output asynchronously, can be used for debugging\n// in production environment without affecting performance.\nfunc (c *Client) EnableDumpAllAsync() *Client {\n\to := c.getDumpOptions()\n\to.Async = true\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllWithoutRequestBody enable dump for requests fired\n// from the client without request body, can be used in the upload\n// request to avoid dumping the unreadable binary content.\nfunc (c *Client) EnableDumpAllWithoutRequestBody() *Client {\n\to := c.getDumpOptions()\n\to.RequestBody = false\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllWithoutResponseBody enable dump for requests fired\n// from the client without response body, can be used in the download\n// request to avoid dumping the unreadable binary content.\nfunc (c *Client) EnableDumpAllWithoutResponseBody() *Client {\n\to := c.getDumpOptions()\n\to.ResponseBody = false\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllWithoutResponse enable dump for requests fired from\n// the client without response, can be used if you only care about\n// the request.\nfunc (c *Client) EnableDumpAllWithoutResponse() *Client {\n\to := c.getDumpOptions()\n\to.ResponseBody = false\n\to.ResponseHeader = false\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllWithoutRequest enables dump for requests fired from\n// the client without request, can be used if you only care about\n// the response.\nfunc (c *Client) EnableDumpAllWithoutRequest() *Client {\n\to := c.getDumpOptions()\n\to.RequestHeader = false\n\to.RequestBody = false\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllWithoutHeader enable dump for requests fired from\n// the client without header, can be used if you only care about\n// the body.\nfunc (c *Client) EnableDumpAllWithoutHeader() *Client {\n\to := c.getDumpOptions()\n\to.RequestHeader = false\n\to.ResponseHeader = false\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpAllWithoutBody enable dump for requests fired from\n// the client without body, can be used if you only care about\n// the header.\nfunc (c *Client) EnableDumpAllWithoutBody() *Client {\n\to := c.getDumpOptions()\n\to.RequestBody = false\n\to.ResponseBody = false\n\tc.EnableDumpAll()\n\treturn c\n}\n\n// EnableDumpEachRequest enable dump at the request-level for each request, and only\n// temporarily stores the dump content in memory, call Response.Dump() to get the\n// dump content when needed.\nfunc (c *Client) EnableDumpEachRequest() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDump()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EnableDumpEachRequestWithoutBody enable dump without body at the request-level for\n// each request, and only temporarily stores the dump content in memory, call\n// Response.Dump() to get the dump content when needed.\nfunc (c *Client) EnableDumpEachRequestWithoutBody() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDumpWithoutBody()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EnableDumpEachRequestWithoutHeader enable dump without header at the request-level for\n// each request, and only temporarily stores the dump content in memory, call\n// Response.Dump() to get the dump content when needed.\nfunc (c *Client) EnableDumpEachRequestWithoutHeader() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDumpWithoutHeader()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EnableDumpEachRequestWithoutRequest enable dump without request at the request-level for\n// each request, and only temporarily stores the dump content in memory, call\n// Response.Dump() to get the dump content when needed.\nfunc (c *Client) EnableDumpEachRequestWithoutRequest() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDumpWithoutRequest()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EnableDumpEachRequestWithoutResponse enable dump without response at the request-level for\n// each request, and only temporarily stores the dump content in memory, call\n// Response.Dump() to get the dump content when needed.\nfunc (c *Client) EnableDumpEachRequestWithoutResponse() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDumpWithoutResponse()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EnableDumpEachRequestWithoutResponseBody enable dump without response body at the\n// request-level for each request, and only temporarily stores the dump content in memory,\n// call Response.Dump() to get the dump content when needed.\nfunc (c *Client) EnableDumpEachRequestWithoutResponseBody() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDumpWithoutResponseBody()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// EnableDumpEachRequestWithoutRequestBody enable dump without request body at the\n// request-level for each request, and only temporarily stores the dump content in memory,\n// call Response.Dump() to get the dump content when needed.\nfunc (c *Client) EnableDumpEachRequestWithoutRequestBody() *Client {\n\treturn c.OnBeforeRequest(func(client *Client, req *Request) error {\n\t\tif req.RetryAttempt == 0 { // Ignore on retry, no need to repeat enable dump.\n\t\t\treq.EnableDumpWithoutRequestBody()\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewRequest is the alias of R()\nfunc (c *Client) NewRequest() *Request {\n\treturn c.R()\n}\n\nfunc (c *Client) NewParallelDownload(url string) *ParallelDownload {\n\treturn &ParallelDownload{\n\t\turl:    url,\n\t\tclient: c,\n\t}\n}\n\n// DisableAutoReadResponse disable read response body automatically (enabled by default).\nfunc (c *Client) DisableAutoReadResponse() *Client {\n\tc.disableAutoReadResponse = true\n\treturn c\n}\n\n// EnableAutoReadResponse enable read response body automatically (enabled by default).\nfunc (c *Client) EnableAutoReadResponse() *Client {\n\tc.disableAutoReadResponse = false\n\treturn c\n}\n\n// SetAutoDecodeContentType set the content types that will be auto-detected and decode to utf-8\n// (e.g. \"json\", \"xml\", \"html\", \"text\").\nfunc (c *Client) SetAutoDecodeContentType(contentTypes ...string) *Client {\n\tc.Transport.SetAutoDecodeContentType(contentTypes...)\n\treturn c\n}\n\n// SetAutoDecodeContentTypeFunc set the function that determines whether the specified `Content-Type` should be auto-detected and decode to utf-8.\nfunc (c *Client) SetAutoDecodeContentTypeFunc(fn func(contentType string) bool) *Client {\n\tc.Transport.SetAutoDecodeContentTypeFunc(fn)\n\treturn c\n}\n\n// SetAutoDecodeAllContentType enable try auto-detect charset and decode all content type to utf-8.\nfunc (c *Client) SetAutoDecodeAllContentType() *Client {\n\tc.Transport.SetAutoDecodeAllContentType()\n\treturn c\n}\n\n// DisableAutoDecode disable auto-detect charset and decode to utf-8 (enabled by default).\nfunc (c *Client) DisableAutoDecode() *Client {\n\tc.Transport.DisableAutoDecode()\n\treturn c\n}\n\n// EnableAutoDecode enable auto-detect charset and decode to utf-8 (enabled by default).\nfunc (c *Client) EnableAutoDecode() *Client {\n\tc.Transport.EnableAutoDecode()\n\treturn c\n}\n\n// SetUserAgent set the \"User-Agent\" header for requests fired from the client.\nfunc (c *Client) SetUserAgent(userAgent string) *Client {\n\treturn c.SetCommonHeader(header.UserAgent, userAgent)\n}\n\n// SetCommonBearerAuthToken set the bearer auth token for requests fired from the client.\nfunc (c *Client) SetCommonBearerAuthToken(token string) *Client {\n\treturn c.SetCommonHeader(header.Authorization, \"Bearer \"+token)\n}\n\n// SetCommonBasicAuth set the basic auth for requests fired from\n// the client.\nfunc (c *Client) SetCommonBasicAuth(username, password string) *Client {\n\tc.SetCommonHeader(header.Authorization, util.BasicAuthHeaderValue(username, password))\n\treturn c\n}\n\n// SetCommonDigestAuth sets the Digest Access auth scheme for requests fired from the client. If a server responds with\n// 401 and sends a Digest challenge in the WWW-Authenticate Header, requests will be resent with the appropriate\n// Authorization Header.\n//\n// For Example: To set the Digest scheme with user \"roc\" and password \"123456\"\n//\n//\tclient.SetCommonDigestAuth(\"roc\", \"123456\")\n//\n// Information about Digest Access Authentication can be found in RFC7616:\n//\n//\thttps://datatracker.ietf.org/doc/html/rfc7616\n//\n// See `Request.SetDigestAuth`\nfunc (c *Client) SetCommonDigestAuth(username, password string) *Client {\n\tc.OnAfterResponse(handleDigestAuthFunc(username, password))\n\treturn c\n}\n\n// SetCommonHeaders set headers for requests fired from the client.\nfunc (c *Client) SetCommonHeaders(hdrs map[string]string) *Client {\n\tfor k, v := range hdrs {\n\t\tc.SetCommonHeader(k, v)\n\t}\n\treturn c\n}\n\n// SetCommonHeader set a header for requests fired from the client.\nfunc (c *Client) SetCommonHeader(key, value string) *Client {\n\tif c.Headers == nil {\n\t\tc.Headers = make(http.Header)\n\t}\n\tc.Headers.Set(key, value)\n\treturn c\n}\n\n// SetCommonHeaderNonCanonical set a header for requests fired from\n// the client which key is a non-canonical key (keep case unchanged),\n// only valid for HTTP/1.1.\nfunc (c *Client) SetCommonHeaderNonCanonical(key, value string) *Client {\n\tif c.Headers == nil {\n\t\tc.Headers = make(http.Header)\n\t}\n\tc.Headers[key] = append(c.Headers[key], value)\n\treturn c\n}\n\n// SetCommonHeadersNonCanonical set headers for requests fired from the\n// client which key is a non-canonical key (keep case unchanged), only\n// valid for HTTP/1.1.\nfunc (c *Client) SetCommonHeadersNonCanonical(hdrs map[string]string) *Client {\n\tfor k, v := range hdrs {\n\t\tc.SetCommonHeaderNonCanonical(k, v)\n\t}\n\treturn c\n}\n\n// SetCommonHeaderOrder set the order of the http header requests fired from the\n// client (case-insensitive).\n// For example:\n//\n//\tclient.R().SetCommonHeaderOrder(\n//\t    \"custom-header\",\n//\t    \"cookie\",\n//\t    \"user-agent\",\n//\t    \"accept-encoding\",\n//\t).Get(url\nfunc (c *Client) SetCommonHeaderOrder(keys ...string) *Client {\n\tc.Transport.WrapRoundTripFunc(func(rt http.RoundTripper) HttpRoundTripFunc {\n\t\treturn func(req *http.Request) (resp *http.Response, err error) {\n\t\t\tif req.Header == nil {\n\t\t\t\treq.Header = make(http.Header)\n\t\t\t}\n\t\t\treq.Header[HeaderOderKey] = keys\n\t\t\treturn rt.RoundTrip(req)\n\t\t}\n\t})\n\treturn c\n}\n\n// SetCommonPseudoHeaderOder set the order of the pseudo http header requests fired\n// from the client (case-insensitive).\n// Note this is only valid for http2 and http3.\n// For example:\n//\n//\tclient.SetCommonPseudoHeaderOder(\n//\t    \":scheme\",\n//\t    \":authority\",\n//\t    \":path\",\n//\t    \":method\",\n//\t)\nfunc (c *Client) SetCommonPseudoHeaderOder(keys ...string) *Client {\n\tc.Transport.WrapRoundTripFunc(func(rt http.RoundTripper) HttpRoundTripFunc {\n\t\treturn func(req *http.Request) (resp *http.Response, err error) {\n\t\t\tif req.Header == nil {\n\t\t\t\treq.Header = make(http.Header)\n\t\t\t}\n\t\t\treq.Header[PseudoHeaderOderKey] = keys\n\t\t\treturn rt.RoundTrip(req)\n\t\t}\n\t})\n\treturn c\n}\n\n// SetHTTP2SettingsFrame set the ordered http2 settings frame.\nfunc (c *Client) SetHTTP2SettingsFrame(settings ...http2.Setting) *Client {\n\tc.Transport.SetHTTP2SettingsFrame(settings...)\n\treturn c\n}\n\n// SetHTTP2ConnectionFlow set the default http2 connection flow, which is the increment\n// value of initial WINDOW_UPDATE frame.\nfunc (c *Client) SetHTTP2ConnectionFlow(flow uint32) *Client {\n\tc.Transport.SetHTTP2ConnectionFlow(flow)\n\treturn c\n}\n\n// SetHTTP2HeaderPriority set the header priority param.\nfunc (c *Client) SetHTTP2HeaderPriority(priority http2.PriorityParam) *Client {\n\tc.Transport.SetHTTP2HeaderPriority(priority)\n\treturn c\n}\n\n// SetHTTP2PriorityFrames set the ordered http2 priority frames.\nfunc (c *Client) SetHTTP2PriorityFrames(frames ...http2.PriorityFrame) *Client {\n\tc.Transport.SetHTTP2PriorityFrames(frames...)\n\treturn c\n}\n\n// SetCommonContentType set the `Content-Type` header for requests fired\n// from the client.\nfunc (c *Client) SetCommonContentType(ct string) *Client {\n\tc.SetCommonHeader(header.ContentType, ct)\n\treturn c\n}\n\n// DisableDumpAll disable dump for requests fired from the client.\nfunc (c *Client) DisableDumpAll() *Client {\n\tc.DisableDump()\n\treturn c\n}\n\n// SetCommonDumpOptions configures the underlying Transport's DumpOptions\n// for requests fired from the client.\nfunc (c *Client) SetCommonDumpOptions(opt *DumpOptions) *Client {\n\tif opt == nil {\n\t\treturn c\n\t}\n\tif opt.Output == nil {\n\t\tif c.dumpOptions != nil {\n\t\t\topt.Output = c.dumpOptions.Output\n\t\t} else {\n\t\t\topt.Output = os.Stdout\n\t\t}\n\t}\n\tc.dumpOptions = opt\n\tif c.Dump != nil {\n\t\tc.Dump.SetOptions(dumpOptions{opt})\n\t}\n\treturn c\n}\n\n// SetProxy set the proxy function.\nfunc (c *Client) SetProxy(proxy func(*http.Request) (*urlpkg.URL, error)) *Client {\n\tc.Transport.SetProxy(proxy)\n\treturn c\n}\n\n// OnError set the error hook which will be executed if any error returned,\n// even if the occurs before request is sent (e.g. invalid URL).\nfunc (c *Client) OnError(hook ErrorHook) *Client {\n\tc.onError = hook\n\treturn c\n}\n\n// OnBeforeRequest add a request middleware which hooks before request sent.\nfunc (c *Client) OnBeforeRequest(m RequestMiddleware) *Client {\n\tc.udBeforeRequest = append(c.udBeforeRequest, m)\n\treturn c\n}\n\n// OnAfterResponse add a response middleware which hooks after response received.\nfunc (c *Client) OnAfterResponse(m ResponseMiddleware) *Client {\n\tc.afterResponse = append(c.afterResponse, m)\n\treturn c\n}\n\n// SetProxyURL set proxy from the proxy URL.\nfunc (c *Client) SetProxyURL(proxyUrl string) *Client {\n\tif proxyUrl == \"\" {\n\t\tc.log.Warnf(\"ignore empty proxy url in SetProxyURL\")\n\t\treturn c\n\t}\n\tu, err := urlpkg.Parse(proxyUrl)\n\tif err != nil {\n\t\tc.log.Errorf(\"failed to parse proxy url %s: %v\", proxyUrl, err)\n\t\treturn c\n\t}\n\tproxy := http.ProxyURL(u)\n\tc.SetProxy(proxy)\n\treturn c\n}\n\n// DisableTraceAll disable trace for requests fired from the client.\nfunc (c *Client) DisableTraceAll() *Client {\n\tc.trace = false\n\treturn c\n}\n\n// EnableTraceAll enable trace for requests fired from the client (http3\n// currently does not support trace).\nfunc (c *Client) EnableTraceAll() *Client {\n\tc.trace = true\n\treturn c\n}\n\n// SetCookieJar set the cookie jar to the underlying `http.Client`, set to nil if you\n// want to disable cookies.\n// Note: If you use Client.Clone to clone a new Client, the new client will share the same\n// cookie jar as the old Client after cloning. Use SetCookieJarFactory instead if you want\n// to create a new CookieJar automatically when cloning a client.\nfunc (c *Client) SetCookieJar(jar http.CookieJar) *Client {\n\tc.cookiejarFactory = nil\n\tc.httpClient.Jar = jar\n\treturn c\n}\n\n// GetCookies get cookies from the underlying `http.Client`'s `CookieJar`.\nfunc (c *Client) GetCookies(url string) ([]*http.Cookie, error) {\n\tif c.httpClient.Jar == nil {\n\t\treturn nil, errors.New(\"cookie jar is not enabled\")\n\t}\n\tu, err := urlpkg.Parse(url)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.httpClient.Jar.Cookies(u), nil\n}\n\n// ClearCookies clears all cookies if cookie is enabled, including\n// cookies from cookie jar and cookies set by SetCommonCookies.\n// Note: The cookie jar will not be cleared if you called SetCookieJar\n// instead of SetCookieJarFactory.\nfunc (c *Client) ClearCookies() *Client {\n\tc.initCookieJar()\n\tc.Cookies = nil\n\treturn c\n}\n\n// SetJsonMarshal set the JSON marshal function which will be used\n// to marshal request body.\nfunc (c *Client) SetJsonMarshal(fn func(v interface{}) ([]byte, error)) *Client {\n\tc.jsonMarshal = fn\n\treturn c\n}\n\n// SetJsonUnmarshal set the JSON unmarshal function which will be used\n// to unmarshal response body.\nfunc (c *Client) SetJsonUnmarshal(fn func(data []byte, v interface{}) error) *Client {\n\tc.jsonUnmarshal = fn\n\treturn c\n}\n\n// SetXmlMarshal set the XML marshal function which will be used\n// to marshal request body.\nfunc (c *Client) SetXmlMarshal(fn func(v interface{}) ([]byte, error)) *Client {\n\tc.xmlMarshal = fn\n\treturn c\n}\n\n// SetXmlUnmarshal set the XML unmarshal function which will be used\n// to unmarshal response body.\nfunc (c *Client) SetXmlUnmarshal(fn func(data []byte, v interface{}) error) *Client {\n\tc.xmlUnmarshal = fn\n\treturn c\n}\n\n// SetDialTLS set the customized `DialTLSContext` function to Transport.\n// Make sure the returned `conn` implements pkg/tls.Conn if you want your\n// customized `conn` supports HTTP2.\nfunc (c *Client) SetDialTLS(fn func(ctx context.Context, network, addr string) (net.Conn, error)) *Client {\n\tc.Transport.SetDialTLS(fn)\n\treturn c\n}\n\n// SetDial set the customized `DialContext` function to Transport.\nfunc (c *Client) SetDial(fn func(ctx context.Context, network, addr string) (net.Conn, error)) *Client {\n\tc.Transport.SetDial(fn)\n\treturn c\n}\n\n// SetTLSFingerprintChrome uses tls fingerprint of Chrome browser.\nfunc (c *Client) SetTLSFingerprintChrome() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloChrome_Auto)\n}\n\n// SetTLSFingerprintFirefox uses tls fingerprint of Firefox browser.\nfunc (c *Client) SetTLSFingerprintFirefox() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloFirefox_Auto)\n}\n\n// SetTLSFingerprintEdge uses tls fingerprint of Edge browser.\nfunc (c *Client) SetTLSFingerprintEdge() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloEdge_Auto)\n}\n\n// SetTLSFingerprintQQ uses tls fingerprint of QQ browser.\nfunc (c *Client) SetTLSFingerprintQQ() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloQQ_Auto)\n}\n\n// SetTLSFingerprintSafari uses tls fingerprint of Safari browser.\nfunc (c *Client) SetTLSFingerprintSafari() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloSafari_Auto)\n}\n\n// SetTLSFingerprint360 uses tls fingerprint of 360 browser.\nfunc (c *Client) SetTLSFingerprint360() *Client {\n\treturn c.SetTLSFingerprint(utls.Hello360_Auto)\n}\n\n// SetTLSFingerprintIOS uses tls fingerprint of IOS.\nfunc (c *Client) SetTLSFingerprintIOS() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloIOS_Auto)\n}\n\n// SetTLSFingerprintAndroid uses tls fingerprint of Android.\nfunc (c *Client) SetTLSFingerprintAndroid() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloAndroid_11_OkHttp)\n}\n\n// SetTLSFingerprintRandomized uses randomized tls fingerprint.\nfunc (c *Client) SetTLSFingerprintRandomized() *Client {\n\treturn c.SetTLSFingerprint(utls.HelloRandomized)\n}\n\n// uTLSConn is wrapper of UConn which implements the net.Conn interface.\ntype uTLSConn struct {\n\t*utls.UConn\n}\n\nfunc (conn *uTLSConn) ConnectionState() tls.ConnectionState {\n\tcs := conn.Conn.ConnectionState()\n\treturn tls.ConnectionState{\n\t\tVersion:                     cs.Version,\n\t\tHandshakeComplete:           cs.HandshakeComplete,\n\t\tDidResume:                   cs.DidResume,\n\t\tCipherSuite:                 cs.CipherSuite,\n\t\tNegotiatedProtocol:          cs.NegotiatedProtocol,\n\t\tNegotiatedProtocolIsMutual:  cs.NegotiatedProtocolIsMutual,\n\t\tServerName:                  cs.ServerName,\n\t\tPeerCertificates:            cs.PeerCertificates,\n\t\tVerifiedChains:              cs.VerifiedChains,\n\t\tSignedCertificateTimestamps: cs.SignedCertificateTimestamps,\n\t\tOCSPResponse:                cs.OCSPResponse,\n\t\tTLSUnique:                   cs.TLSUnique,\n\t}\n}\n\n// SetTLSFingerprint set the tls fingerprint for tls handshake, will use utls\n// (https://github.com/refraction-networking/utls) to perform the tls handshake,\n// which uses the specified clientHelloID to simulate the tls fingerprint.\n// Note this is valid for HTTP1 and HTTP2, not HTTP3.\nfunc (c *Client) SetTLSFingerprint(clientHelloID utls.ClientHelloID) *Client {\n\tfn := func(ctx context.Context, addr string, plainConn net.Conn) (conn net.Conn, tlsState *tls.ConnectionState, err error) {\n\t\tcolonPos := strings.LastIndex(addr, \":\")\n\t\tif colonPos == -1 {\n\t\t\tcolonPos = len(addr)\n\t\t}\n\t\thostname := addr[:colonPos]\n\t\ttlsConfig := c.GetTLSClientConfig()\n\t\tutlsConfig := &utls.Config{\n\t\t\tServerName:                  hostname,\n\t\t\tRand:                        tlsConfig.Rand,\n\t\t\tTime:                        tlsConfig.Time,\n\t\t\tRootCAs:                     tlsConfig.RootCAs,\n\t\t\tNextProtos:                  tlsConfig.NextProtos,\n\t\t\tClientCAs:                   tlsConfig.ClientCAs,\n\t\t\tInsecureSkipVerify:          tlsConfig.InsecureSkipVerify,\n\t\t\tCipherSuites:                tlsConfig.CipherSuites,\n\t\t\tSessionTicketsDisabled:      tlsConfig.SessionTicketsDisabled,\n\t\t\tMinVersion:                  tlsConfig.MinVersion,\n\t\t\tMaxVersion:                  tlsConfig.MaxVersion,\n\t\t\tDynamicRecordSizingDisabled: tlsConfig.DynamicRecordSizingDisabled,\n\t\t\tKeyLogWriter:                tlsConfig.KeyLogWriter,\n\t\t}\n\t\tuconn := &uTLSConn{utls.UClient(plainConn, utlsConfig, clientHelloID)}\n\t\terr = uconn.HandshakeContext(ctx)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tcs := uconn.Conn.ConnectionState()\n\t\tconn = uconn\n\t\ttlsState = &tls.ConnectionState{\n\t\t\tVersion:                     cs.Version,\n\t\t\tHandshakeComplete:           cs.HandshakeComplete,\n\t\t\tDidResume:                   cs.DidResume,\n\t\t\tCipherSuite:                 cs.CipherSuite,\n\t\t\tNegotiatedProtocol:          cs.NegotiatedProtocol,\n\t\t\tNegotiatedProtocolIsMutual:  cs.NegotiatedProtocolIsMutual,\n\t\t\tServerName:                  cs.ServerName,\n\t\t\tPeerCertificates:            cs.PeerCertificates,\n\t\t\tVerifiedChains:              cs.VerifiedChains,\n\t\t\tSignedCertificateTimestamps: cs.SignedCertificateTimestamps,\n\t\t\tOCSPResponse:                cs.OCSPResponse,\n\t\t\tTLSUnique:                   cs.TLSUnique,\n\t\t}\n\t\treturn\n\t}\n\tc.Transport.SetTLSHandshake(fn)\n\treturn c\n}\n\n// SetTLSHandshake set the custom tls handshake function, only valid for HTTP1 and HTTP2, not HTTP3,\n// it specifies an optional dial function for tls handshake, it works even if a proxy is set, can be\n// used to customize the tls fingerprint.\nfunc (c *Client) SetTLSHandshake(fn func(ctx context.Context, addr string, plainConn net.Conn) (conn net.Conn, tlsState *tls.ConnectionState, err error)) *Client {\n\tc.Transport.SetTLSHandshake(fn)\n\treturn c\n}\n\n// SetTLSHandshakeTimeout set the TLS handshake timeout.\nfunc (c *Client) SetTLSHandshakeTimeout(timeout time.Duration) *Client {\n\tc.Transport.SetTLSHandshakeTimeout(timeout)\n\treturn c\n}\n\n// EnableForceHTTP1 enable force using HTTP1 (disabled by default).\n//\n// Attention: This method should not be called when ImpersonateXXX, SetTLSFingerPrint or\n// SetTLSHandshake and other methods that will customize the tls handshake are called.\nfunc (c *Client) EnableForceHTTP1() *Client {\n\tc.Transport.EnableForceHTTP1()\n\treturn c\n}\n\n// EnableForceHTTP2 enable force using HTTP2 for https requests (disabled by default).\n//\n// Attention: This method should not be called when ImpersonateXXX, SetTLSFingerPrint or\n// SetTLSHandshake and other methods that will customize the tls handshake are called.\nfunc (c *Client) EnableForceHTTP2() *Client {\n\tc.Transport.EnableForceHTTP2()\n\treturn c\n}\n\n// EnableForceHTTP3 enable force using HTTP3 for https requests (disabled by default).\n//\n// Attention: This method should not be called when ImpersonateXXX, SetTLSFingerPrint or\n// SetTLSHandshake and other methods that will customize the tls handshake are called.\nfunc (c *Client) EnableForceHTTP3() *Client {\n\tc.Transport.EnableForceHTTP3()\n\treturn c\n}\n\n// DisableForceHttpVersion disable force using specified http\n// version (disabled by default).\nfunc (c *Client) DisableForceHttpVersion() *Client {\n\tc.Transport.DisableForceHttpVersion()\n\treturn c\n}\n\n// EnableH2C enables HTTP/2 over TCP without TLS.\nfunc (c *Client) EnableH2C() *Client {\n\tc.Transport.EnableH2C()\n\treturn c\n}\n\n// DisableH2C disables HTTP/2 over TCP without TLS.\nfunc (c *Client) DisableH2C() *Client {\n\tc.Transport.DisableH2C()\n\treturn c\n}\n\n// DisableAllowGetMethodPayload disable sending GET method requests with body.\nfunc (c *Client) DisableAllowGetMethodPayload() *Client {\n\tc.AllowGetMethodPayload = false\n\treturn c\n}\n\n// EnableAllowGetMethodPayload allows sending GET method requests with body.\nfunc (c *Client) EnableAllowGetMethodPayload() *Client {\n\tc.AllowGetMethodPayload = true\n\treturn c\n}\n\nfunc (c *Client) isPayloadForbid(m string) bool {\n\treturn (m == http.MethodGet && !c.AllowGetMethodPayload) || m == http.MethodHead || m == http.MethodOptions\n}\n\n// GetClient returns the underlying `http.Client`.\nfunc (c *Client) GetClient() *http.Client {\n\treturn c.httpClient\n}\n\nfunc (c *Client) getRetryOption() *retryOption {\n\tif c.retryOption == nil {\n\t\tc.retryOption = newDefaultRetryOption()\n\t}\n\treturn c.retryOption\n}\n\n// SetCommonRetryCount enables retry and set the maximum retry count for requests\n// fired from the client.\n// It will retry infinitely if count is negative.\nfunc (c *Client) SetCommonRetryCount(count int) *Client {\n\tc.getRetryOption().MaxRetries = count\n\treturn c\n}\n\n// SetCommonRetryInterval sets the custom GetRetryIntervalFunc for requests fired\n// from the client, you can use this to implement your own backoff retry algorithm.\n// For example:\n//\n//\t\t req.SetCommonRetryInterval(func(resp *req.Response, attempt int) time.Duration {\n//\t     sleep := 0.01 * math.Exp2(float64(attempt))\n//\t     return time.Duration(math.Min(2, sleep)) * time.Second\n//\t\t })\nfunc (c *Client) SetCommonRetryInterval(getRetryIntervalFunc GetRetryIntervalFunc) *Client {\n\tc.getRetryOption().GetRetryInterval = getRetryIntervalFunc\n\treturn c\n}\n\n// SetCommonRetryFixedInterval set retry to use a fixed interval for requests\n// fired from the client.\nfunc (c *Client) SetCommonRetryFixedInterval(interval time.Duration) *Client {\n\tc.getRetryOption().GetRetryInterval = func(resp *Response, attempt int) time.Duration {\n\t\treturn interval\n\t}\n\treturn c\n}\n\n// SetCommonRetryBackoffInterval set retry to use a capped exponential backoff\n// with jitter for requests fired from the client.\n// https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\nfunc (c *Client) SetCommonRetryBackoffInterval(min, max time.Duration) *Client {\n\tc.getRetryOption().GetRetryInterval = backoffInterval(min, max)\n\treturn c\n}\n\n// SetCommonRetryHook set the retry hook which will be executed before a retry.\n// It will override other retry hooks if any been added before.\nfunc (c *Client) SetCommonRetryHook(hook RetryHookFunc) *Client {\n\tc.getRetryOption().RetryHooks = []RetryHookFunc{hook}\n\treturn c\n}\n\n// AddCommonRetryHook adds a retry hook for requests fired from the client,\n// which will be executed before a retry.\nfunc (c *Client) AddCommonRetryHook(hook RetryHookFunc) *Client {\n\tro := c.getRetryOption()\n\tro.RetryHooks = append(ro.RetryHooks, hook)\n\treturn c\n}\n\n// SetCommonRetryCondition sets the retry condition, which determines whether the\n// request should retry.\n// It will override other retry conditions if any been added before.\nfunc (c *Client) SetCommonRetryCondition(condition RetryConditionFunc) *Client {\n\tc.getRetryOption().RetryConditions = []RetryConditionFunc{condition}\n\treturn c\n}\n\n// AddCommonRetryCondition adds a retry condition, which determines whether the\n// request should retry.\nfunc (c *Client) AddCommonRetryCondition(condition RetryConditionFunc) *Client {\n\tro := c.getRetryOption()\n\tro.RetryConditions = append(ro.RetryConditions, condition)\n\treturn c\n}\n\n// SetUnixSocket set client to dial connection use unix socket.\n// For example:\n//\n// client.SetUnixSocket(\"/var/run/custom.sock\")\nfunc (c *Client) SetUnixSocket(file string) *Client {\n\treturn c.SetDial(func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\tvar d net.Dialer\n\t\treturn d.DialContext(ctx, \"unix\", file)\n\t})\n}\n\n// DisableHTTP3 disables the http3 protocol.\nfunc (c *Client) DisableHTTP3() *Client {\n\tc.Transport.DisableHTTP3()\n\treturn c\n}\n\n// EnableHTTP3 enables the http3 protocol.\nfunc (c *Client) EnableHTTP3() *Client {\n\tc.Transport.EnableHTTP3()\n\treturn c\n}\n\n// SetHTTP2MaxHeaderListSize set the http2 MaxHeaderListSize,\n// which is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to\n// send in the initial settings frame. It is how many bytes\n// of response headers are allowed. Unlike the http2 spec, zero here\n// means to use a default limit (currently 10MB). If you actually\n// want to advertise an unlimited value to the peer, Transport\n// interprets the highest possible value here (0xffffffff or 1<<32-1)\n// to mean no limit.\nfunc (c *Client) SetHTTP2MaxHeaderListSize(max uint32) *Client {\n\tc.Transport.SetHTTP2MaxHeaderListSize(max)\n\treturn c\n}\n\n// SetHTTP2StrictMaxConcurrentStreams set the http2\n// StrictMaxConcurrentStreams, which controls whether the\n// server's SETTINGS_MAX_CONCURRENT_STREAMS should be respected\n// globally. If false, new TCP connections are created to the\n// server as needed to keep each under the per-connection\n// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the\n// server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as\n// a global limit and callers of RoundTrip block when needed,\n// waiting for their turn.\nfunc (c *Client) SetHTTP2StrictMaxConcurrentStreams(strict bool) *Client {\n\tc.Transport.SetHTTP2StrictMaxConcurrentStreams(strict)\n\treturn c\n}\n\n// SetHTTP2ReadIdleTimeout set the http2 ReadIdleTimeout,\n// which is the timeout after which a health check using ping\n// frame will be carried out if no frame is received on the connection.\n// Note that a ping response will is considered a received frame, so if\n// there is no other traffic on the connection, the health check will\n// be performed every ReadIdleTimeout interval.\n// If zero, no health check is performed.\nfunc (c *Client) SetHTTP2ReadIdleTimeout(timeout time.Duration) *Client {\n\tc.Transport.SetHTTP2ReadIdleTimeout(timeout)\n\treturn c\n}\n\n// SetHTTP2PingTimeout set the http2 PingTimeout, which is the timeout\n// after which the connection will be closed if a response to Ping is\n// not received.\n// Defaults to 15s\nfunc (c *Client) SetHTTP2PingTimeout(timeout time.Duration) *Client {\n\tc.Transport.SetHTTP2PingTimeout(timeout)\n\treturn c\n}\n\n// SetHTTP2WriteByteTimeout set the http2 WriteByteTimeout, which is the\n// timeout after which the connection will be closed no data can be written\n// to it. The timeout begins when data is available to write, and is\n// extended whenever any bytes are written.\nfunc (c *Client) SetHTTP2WriteByteTimeout(timeout time.Duration) *Client {\n\tc.Transport.SetHTTP2WriteByteTimeout(timeout)\n\treturn c\n}\n\n// NewClient is the alias of C\nfunc NewClient() *Client {\n\treturn C()\n}\n\n// Clone copy and returns the Client\nfunc (c *Client) Clone() *Client {\n\tcc := *c\n\n\t// clone Transport\n\tcc.Transport = c.Transport.Clone()\n\tcc.initTransport()\n\n\t// clone http.Client\n\tclient := *c.httpClient\n\tclient.Transport = cc.Transport\n\tcc.httpClient = &client\n\tcc.initCookieJar()\n\n\t// clone client middleware\n\tif len(cc.roundTripWrappers) > 0 {\n\t\tcc.wrappedRoundTrip = roundTripImpl{&cc}\n\t\tfor _, w := range cc.roundTripWrappers {\n\t\t\tcc.wrappedRoundTrip = w(cc.wrappedRoundTrip)\n\t\t}\n\t}\n\n\t// clone other fields that may need to be cloned\n\tcc.PathParams = cloneMap(c.PathParams)\n\tcc.QueryParams = cloneUrlValues(c.QueryParams)\n\tcc.FormData = cloneUrlValues(c.FormData)\n\tcc.beforeRequest = cloneSlice(c.beforeRequest)\n\tcc.udBeforeRequest = cloneSlice(c.udBeforeRequest)\n\tcc.afterResponse = cloneSlice(c.afterResponse)\n\tcc.dumpOptions = c.dumpOptions.Clone()\n\tcc.retryOption = c.retryOption.Clone()\n\treturn &cc\n}\n\nfunc memoryCookieJarFactory() *cookiejar.Jar {\n\tjar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})\n\treturn jar\n}\n\n// C create a new client.\nfunc C() *Client {\n\tt := T()\n\n\thttpClient := &http.Client{\n\t\tTransport: t,\n\t\tTimeout:   2 * time.Minute,\n\t}\n\tbeforeRequest := []RequestMiddleware{\n\t\tparseRequestHeader,\n\t\tparseRequestCookie,\n\t\tparseRequestURL,\n\t\tparseRequestBody,\n\t}\n\tafterResponse := []ResponseMiddleware{\n\t\tparseResponseBody,\n\t\thandleDownload,\n\t}\n\tc := &Client{\n\t\tAllowGetMethodPayload: true,\n\t\tbeforeRequest:         beforeRequest,\n\t\tafterResponse:         afterResponse,\n\t\tlog:                   createDefaultLogger(),\n\t\thttpClient:            httpClient,\n\t\tTransport:             t,\n\t\tjsonMarshal:           json.Marshal,\n\t\tjsonUnmarshal:         json.Unmarshal,\n\t\txmlMarshal:            xml.Marshal,\n\t\txmlUnmarshal:          xml.Unmarshal,\n\t\tcookiejarFactory:      memoryCookieJarFactory,\n\t}\n\tc.SetRedirectPolicy(DefaultRedirectPolicy())\n\tc.initCookieJar()\n\n\tc.initTransport()\n\treturn c\n}\n\n// SetCookieJarFactory set the functional factory of cookie jar, which creates\n// cookie jar that store cookies for underlying `http.Client`. After client clone,\n// the cookie jar of the new client will also be regenerated using this factory\n// function.\nfunc (c *Client) SetCookieJarFactory(factory func() *cookiejar.Jar) *Client {\n\tc.cookiejarFactory = factory\n\tc.initCookieJar()\n\treturn c\n}\n\nfunc (c *Client) initCookieJar() {\n\tif c.cookiejarFactory == nil {\n\t\treturn\n\t}\n\tjar := c.cookiejarFactory()\n\tif jar != nil {\n\t\tc.httpClient.Jar = jar\n\t}\n}\n\nfunc (c *Client) initTransport() {\n\tc.Debugf = func(format string, v ...interface{}) {\n\t\tif c.DebugLog {\n\t\t\tc.log.Debugf(format, v...)\n\t\t}\n\t}\n}\n\n// RoundTripper is the interface of req's Client.\ntype RoundTripper interface {\n\tRoundTrip(*Request) (*Response, error)\n}\n\n// RoundTripFunc is a RoundTripper implementation, which is a simple function.\ntype RoundTripFunc func(req *Request) (resp *Response, err error)\n\n// RoundTrip implements RoundTripper.\nfunc (fn RoundTripFunc) RoundTrip(req *Request) (*Response, error) {\n\treturn fn(req)\n}\n\n// RoundTripWrapper is client middleware function.\ntype RoundTripWrapper func(rt RoundTripper) RoundTripper\n\n// RoundTripWrapperFunc is client middleware function, more convenient than RoundTripWrapper.\ntype RoundTripWrapperFunc func(rt RoundTripper) RoundTripFunc\n\nfunc (f RoundTripWrapperFunc) wrapper() RoundTripWrapper {\n\treturn func(rt RoundTripper) RoundTripper {\n\t\treturn f(rt)\n\t}\n}\n\n// WrapRoundTripFunc adds a client middleware function that will give the caller\n// an opportunity to wrap the underlying http.RoundTripper.\nfunc (c *Client) WrapRoundTripFunc(funcs ...RoundTripWrapperFunc) *Client {\n\tvar wrappers []RoundTripWrapper\n\tfor _, fn := range funcs {\n\t\twrappers = append(wrappers, fn.wrapper())\n\t}\n\treturn c.WrapRoundTrip(wrappers...)\n}\n\ntype roundTripImpl struct {\n\t*Client\n}\n\nfunc (r roundTripImpl) RoundTrip(req *Request) (resp *Response, err error) {\n\treturn r.roundTrip(req)\n}\n\n// WrapRoundTrip adds a client middleware function that will give the caller\n// an opportunity to wrap the underlying http.RoundTripper.\nfunc (c *Client) WrapRoundTrip(wrappers ...RoundTripWrapper) *Client {\n\tif len(wrappers) == 0 {\n\t\treturn c\n\t}\n\tif c.wrappedRoundTrip == nil {\n\t\tc.roundTripWrappers = wrappers\n\t\tc.wrappedRoundTrip = roundTripImpl{c}\n\t} else {\n\t\tc.roundTripWrappers = append(c.roundTripWrappers, wrappers...)\n\t}\n\tfor _, w := range wrappers {\n\t\tc.wrappedRoundTrip = w(c.wrappedRoundTrip)\n\t}\n\treturn c\n}\n\n// RoundTrip implements RoundTripper\nfunc (c *Client) roundTrip(r *Request) (resp *Response, err error) {\n\tresp = &Response{Request: r}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tresp.Err = err\n\t\t} else {\n\t\t\terr = resp.Err\n\t\t}\n\t}()\n\n\t// setup trace\n\tif r.trace == nil && r.client.trace {\n\t\tr.trace = &clientTrace{}\n\t}\n\n\tctx := r.ctx\n\n\tif r.trace != nil {\n\t\tctx = r.trace.createContext(r.Context())\n\t}\n\n\t// setup url and host\n\tvar host string\n\tif h := r.getHeader(\"Host\"); h != \"\" {\n\t\thost = h // Host header override\n\t} else {\n\t\thost = r.URL.Host\n\t}\n\n\t// setup header\n\tcontentLength := int64(len(r.Body))\n\n\tvar reqBody io.ReadCloser\n\tif r.GetBody != nil {\n\t\treqBody, resp.Err = r.GetBody()\n\t\tif resp.Err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treq := &http.Request{\n\t\tMethod:        r.Method,\n\t\tHeader:        r.Headers.Clone(),\n\t\tURL:           r.URL,\n\t\tHost:          host,\n\t\tProto:         \"HTTP/1.1\",\n\t\tProtoMajor:    1,\n\t\tProtoMinor:    1,\n\t\tContentLength: contentLength,\n\t\tBody:          reqBody,\n\t\tGetBody:       r.GetBody,\n\t\tClose:         r.close,\n\t}\n\tfor _, cookie := range r.Cookies {\n\t\treq.AddCookie(cookie)\n\t}\n\tif r.isSaveResponse && r.downloadCallback != nil {\n\t\tvar wrap wrapResponseBodyFunc = func(rc io.ReadCloser) io.ReadCloser {\n\t\t\treturn &callbackReader{\n\t\t\t\tReadCloser: rc,\n\t\t\t\tcallback: func(read int64) {\n\t\t\t\t\tr.downloadCallback(DownloadInfo{\n\t\t\t\t\t\tResponse:       resp,\n\t\t\t\t\t\tDownloadedSize: read,\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tlastTime: time.Now(),\n\t\t\t\tinterval: r.downloadCallbackInterval,\n\t\t\t}\n\t\t}\n\t\tif ctx == nil {\n\t\t\tctx = context.Background()\n\t\t}\n\t\tctx = context.WithValue(ctx, wrapResponseBodyKey, wrap)\n\t}\n\tif ctx != nil {\n\t\treq = req.WithContext(ctx)\n\t}\n\tr.RawRequest = req\n\tr.StartTime = time.Now()\n\n\tvar httpResponse *http.Response\n\thttpResponse, resp.Err = c.httpClient.Do(r.RawRequest)\n\tresp.Response = httpResponse\n\n\t// auto-read response body if possible\n\tif resp.Err == nil && !c.disableAutoReadResponse && !r.isSaveResponse && !r.disableAutoReadResponse && resp.StatusCode > 199 {\n\t\tresp.ToBytes()\n\t\t// restore body for re-reads\n\t\tresp.Body = io.NopCloser(bytes.NewReader(resp.body))\n\t}\n\n\tfor _, f := range c.afterResponse {\n\t\tif e := f(c, resp); e != nil {\n\t\t\tresp.Err = e\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "client_impersonate.go",
          "type": "blob",
          "size": 7.7763671875,
          "content": "package req\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"math/big\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/imroc/req/v3/http2\"\n\tutls \"github.com/refraction-networking/utls\"\n)\n\n// Identical for both Blink-based browsers (Chrome, Chromium, etc.) and WebKit-based browsers (Safari, etc.)\n// Blink implementation: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/network/form_data_encoder.cc;drc=1d694679493c7b2f7b9df00e967b4f8699321093;l=130\n// WebKit implementation: https://github.com/WebKit/WebKit/blob/47eea119fe9462721e5cc75527a4280c6d5f5214/Source/WebCore/platform/network/FormDataBuilder.cpp#L120\nfunc webkitMultipartBoundaryFunc() string {\n\tconst letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB\"\n\n\tsb := strings.Builder{}\n\tsb.WriteString(\"----WebKitFormBoundary\")\n\n\tfor i := 0; i < 16; i++ {\n\t\tindex, err := rand.Int(rand.Reader, big.NewInt(int64(len(letters)-1)))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tsb.WriteByte(letters[index.Int64()])\n\t}\n\n\treturn sb.String()\n}\n\n// Firefox implementation: https://searchfox.org/mozilla-central/source/dom/html/HTMLFormSubmission.cpp#355\nfunc firefoxMultipartBoundaryFunc() string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"-------------------------\")\n\n\tfor i := 0; i < 3; i++ {\n\t\tvar b [8]byte\n\t\tif _, err := rand.Read(b[:]); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tu32 := binary.LittleEndian.Uint32(b[:])\n\t\ts := strconv.FormatUint(uint64(u32), 10)\n\n\t\tsb.WriteString(s)\n\t}\n\n\treturn sb.String()\n}\n\nvar (\n\tchromeHttp2Settings = []http2.Setting{\n\t\t{\n\t\t\tID:  http2.SettingHeaderTableSize,\n\t\t\tVal: 65536,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingEnablePush,\n\t\t\tVal: 0,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingMaxConcurrentStreams,\n\t\t\tVal: 1000,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingInitialWindowSize,\n\t\t\tVal: 6291456,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingMaxHeaderListSize,\n\t\t\tVal: 262144,\n\t\t},\n\t}\n\n\tchromePseudoHeaderOrder = []string{\n\t\t\":method\",\n\t\t\":authority\",\n\t\t\":scheme\",\n\t\t\":path\",\n\t}\n\n\tchromeHeaderOrder = []string{\n\t\t\"host\",\n\t\t\"pragma\",\n\t\t\"cache-control\",\n\t\t\"sec-ch-ua\",\n\t\t\"sec-ch-ua-mobile\",\n\t\t\"sec-ch-ua-platform\",\n\t\t\"upgrade-insecure-requests\",\n\t\t\"user-agent\",\n\t\t\"accept\",\n\t\t\"sec-fetch-site\",\n\t\t\"sec-fetch-mode\",\n\t\t\"sec-fetch-user\",\n\t\t\"sec-fetch-dest\",\n\t\t\"referer\",\n\t\t\"accept-encoding\",\n\t\t\"accept-language\",\n\t\t\"cookie\",\n\t}\n\n\tchromeHeaders = map[string]string{\n\t\t\"pragma\":                    \"no-cache\",\n\t\t\"cache-control\":             \"no-cache\",\n\t\t\"sec-ch-ua\":                 `\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"`,\n\t\t\"sec-ch-ua-mobile\":          \"?0\",\n\t\t\"sec-ch-ua-platform\":        `\"macOS\"`,\n\t\t\"upgrade-insecure-requests\": \"1\",\n\t\t\"user-agent\":                \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n\t\t\"accept\":                    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\",\n\t\t\"sec-fetch-site\":            \"none\",\n\t\t\"sec-fetch-mode\":            \"navigate\",\n\t\t\"sec-fetch-user\":            \"?1\",\n\t\t\"sec-fetch-dest\":            \"document\",\n\t\t\"accept-language\":           \"zh-CN,zh;q=0.9\",\n\t}\n\n\tchromeHeaderPriority = http2.PriorityParam{\n\t\tStreamDep: 0,\n\t\tExclusive: true,\n\t\tWeight:    255,\n\t}\n)\n\n// ImpersonateChrome impersonates Chrome browser (version 120).\nfunc (c *Client) ImpersonateChrome() *Client {\n\tc.\n\t\tSetTLSFingerprint(utls.HelloChrome_120).\n\t\tSetHTTP2SettingsFrame(chromeHttp2Settings...).\n\t\tSetHTTP2ConnectionFlow(15663105).\n\t\tSetCommonPseudoHeaderOder(chromePseudoHeaderOrder...).\n\t\tSetCommonHeaderOrder(chromeHeaderOrder...).\n\t\tSetCommonHeaders(chromeHeaders).\n\t\tSetHTTP2HeaderPriority(chromeHeaderPriority).\n\t\tSetMultipartBoundaryFunc(webkitMultipartBoundaryFunc)\n\treturn c\n}\n\nvar (\n\tfirefoxHttp2Settings = []http2.Setting{\n\t\t{\n\t\t\tID:  http2.SettingHeaderTableSize,\n\t\t\tVal: 65536,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingInitialWindowSize,\n\t\t\tVal: 131072,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingMaxFrameSize,\n\t\t\tVal: 16384,\n\t\t},\n\t}\n\n\tfirefoxPriorityFrames = []http2.PriorityFrame{\n\t\t{\n\t\t\tStreamID: 3,\n\t\t\tPriorityParam: http2.PriorityParam{\n\t\t\t\tStreamDep: 0,\n\t\t\t\tExclusive: false,\n\t\t\t\tWeight:    200,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tStreamID: 5,\n\t\t\tPriorityParam: http2.PriorityParam{\n\t\t\t\tStreamDep: 0,\n\t\t\t\tExclusive: false,\n\t\t\t\tWeight:    100,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tStreamID: 7,\n\t\t\tPriorityParam: http2.PriorityParam{\n\t\t\t\tStreamDep: 0,\n\t\t\t\tExclusive: false,\n\t\t\t\tWeight:    0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tStreamID: 9,\n\t\t\tPriorityParam: http2.PriorityParam{\n\t\t\t\tStreamDep: 7,\n\t\t\t\tExclusive: false,\n\t\t\t\tWeight:    0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tStreamID: 11,\n\t\t\tPriorityParam: http2.PriorityParam{\n\t\t\t\tStreamDep: 3,\n\t\t\t\tExclusive: false,\n\t\t\t\tWeight:    0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tStreamID: 13,\n\t\t\tPriorityParam: http2.PriorityParam{\n\t\t\t\tStreamDep: 0,\n\t\t\t\tExclusive: false,\n\t\t\t\tWeight:    240,\n\t\t\t},\n\t\t},\n\t}\n\n\tfirefoxPseudoHeaderOrder = []string{\n\t\t\":method\",\n\t\t\":path\",\n\t\t\":authority\",\n\t\t\":scheme\",\n\t}\n\n\tfirefoxHeaderOrder = []string{\n\t\t\"user-agent\",\n\t\t\"accept\",\n\t\t\"accept-language\",\n\t\t\"accept-encoding\",\n\t\t\"referer\",\n\t\t\"cookie\",\n\t\t\"upgrade-insecure-requests\",\n\t\t\"sec-fetch-dest\",\n\t\t\"sec-fetch-mode\",\n\t\t\"sec-fetch-site\",\n\t\t\"sec-fetch-user\",\n\t\t\"te\",\n\t}\n\n\tfirefoxHeaders = map[string]string{\n\t\t\"user-agent\":                \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:120.0) Gecko/20100101 Firefox/120.0\",\n\t\t\"accept\":                    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n\t\t\"accept-language\":           \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\",\n\t\t\"upgrade-insecure-requests\": \"1\",\n\t\t\"sec-fetch-dest\":            \"document\",\n\t\t\"sec-fetch-mode\":            \"navigate\",\n\t\t\"sec-fetch-site\":            \"same-origin\",\n\t\t\"sec-fetch-user\":            \"?1\",\n\t\t//\"te\":                        \"trailers\",\n\t}\n\n\tfirefoxHeaderPriority = http2.PriorityParam{\n\t\tStreamDep: 13,\n\t\tExclusive: false,\n\t\tWeight:    41,\n\t}\n)\n\n// ImpersonateFirefox impersonates Firefox browser (version 120).\nfunc (c *Client) ImpersonateFirefox() *Client {\n\tc.\n\t\tSetTLSFingerprint(utls.HelloFirefox_120).\n\t\tSetHTTP2SettingsFrame(firefoxHttp2Settings...).\n\t\tSetHTTP2ConnectionFlow(12517377).\n\t\tSetHTTP2PriorityFrames(firefoxPriorityFrames...).\n\t\tSetCommonPseudoHeaderOder(firefoxPseudoHeaderOrder...).\n\t\tSetCommonHeaderOrder(firefoxHeaderOrder...).\n\t\tSetCommonHeaders(firefoxHeaders).\n\t\tSetHTTP2HeaderPriority(firefoxHeaderPriority).\n\t\tSetMultipartBoundaryFunc(firefoxMultipartBoundaryFunc)\n\treturn c\n}\n\nvar (\n\tsafariHttp2Settings = []http2.Setting{\n\t\t{\n\t\t\tID:  http2.SettingInitialWindowSize,\n\t\t\tVal: 4194304,\n\t\t},\n\t\t{\n\t\t\tID:  http2.SettingMaxConcurrentStreams,\n\t\t\tVal: 100,\n\t\t},\n\t}\n\n\tsafariPseudoHeaderOrder = []string{\n\t\t\":method\",\n\t\t\":scheme\",\n\t\t\":path\",\n\t\t\":authority\",\n\t}\n\n\tsafariHeaderOrder = []string{\n\t\t\"accept\",\n\t\t\"sec-fetch-site\",\n\t\t\"cookie\",\n\t\t\"sec-fetch-dest\",\n\t\t\"accept-language\",\n\t\t\"sec-fetch-mode\",\n\t\t\"user-agent\",\n\t\t\"referer\",\n\t\t\"accept-encoding\",\n\t}\n\n\tsafariHeaders = map[string]string{\n\t\t\"accept\":          \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n\t\t\"sec-fetch-site\":  \"same-origin\",\n\t\t\"sec-fetch-dest\":  \"document\",\n\t\t\"accept-language\": \"zh-CN,zh-Hans;q=0.9\",\n\t\t\"sec-fetch-mode\":  \"navigate\",\n\t\t\"user-agent\":      \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Safari/605.1.15\",\n\t}\n\n\tsafariHeaderPriority = http2.PriorityParam{\n\t\tStreamDep: 0,\n\t\tExclusive: false,\n\t\tWeight:    254,\n\t}\n)\n\n// ImpersonateSafari impersonates Safari browser (version 16.6).\nfunc (c *Client) ImpersonateSafari() *Client {\n\tc.\n\t\tSetTLSFingerprint(utls.HelloSafari_16_0).\n\t\tSetHTTP2SettingsFrame(safariHttp2Settings...).\n\t\tSetHTTP2ConnectionFlow(10485760).\n\t\tSetCommonPseudoHeaderOder(safariPseudoHeaderOrder...).\n\t\tSetCommonHeaderOrder(safariHeaderOrder...).\n\t\tSetCommonHeaders(safariHeaders).\n\t\tSetHTTP2HeaderPriority(safariHeaderPriority).\n\t\tSetMultipartBoundaryFunc(webkitMultipartBoundaryFunc)\n\treturn c\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 19.9794921875,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/url\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/tests\"\n\t\"golang.org/x/net/publicsuffix\"\n)\n\nfunc TestRetryCancelledContext(t *testing.T) {\n\tcancelledCtx, done := context.WithCancel(context.Background())\n\tdone()\n\n\tclient := tc().\n\t\tSetCommonRetryCount(2).\n\t\tSetCommonRetryBackoffInterval(1*time.Second, 5*time.Second)\n\n\tres, err := client.R().SetContext(cancelledCtx).Get(\"/\")\n\n\ttests.AssertEqual(t, 0, res.Request.RetryAttempt)\n\ttests.AssertNotNil(t, err)\n\ttests.AssertErrorContains(t, err, \"context canceled\")\n}\n\nfunc TestWrapRoundTrip(t *testing.T) {\n\ti, j, a, b := 0, 0, 0, 0\n\tc := tc().WrapRoundTripFunc(func(rt RoundTripper) RoundTripFunc {\n\t\treturn func(req *Request) (resp *Response, err error) {\n\t\t\ta = 1\n\t\t\tresp, err = rt.RoundTrip(req)\n\t\t\tb = 1\n\t\t\treturn\n\t\t}\n\t})\n\tc.GetTransport().WrapRoundTripFunc(func(rt http.RoundTripper) HttpRoundTripFunc {\n\t\treturn func(req *http.Request) (resp *http.Response, err error) {\n\t\t\ti = 1\n\t\t\tresp, err = rt.RoundTrip(req)\n\t\t\tj = 1\n\t\t\treturn\n\t\t}\n\t})\n\tresp, err := c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, 1, i)\n\ttests.AssertEqual(t, 1, j)\n\ttests.AssertEqual(t, 1, a)\n\ttests.AssertEqual(t, 1, b)\n}\n\nfunc TestAllowGetMethodPayload(t *testing.T) {\n\tc := tc()\n\tresp, err := c.R().SetBody(\"test\").Get(\"/payload\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test\", resp.String())\n\n\tc.DisableAllowGetMethodPayload()\n\tresp, err = c.R().SetBody(\"test\").Get(\"/payload\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"\", resp.String())\n\n\tc.EnableAllowGetMethodPayload()\n\tresp, err = c.R().SetBody(\"test\").Get(\"/payload\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test\", resp.String())\n}\n\nfunc TestSetTLSHandshakeTimeout(t *testing.T) {\n\ttimeout := 2 * time.Second\n\tc := tc().SetTLSHandshakeTimeout(timeout)\n\ttests.AssertEqual(t, timeout, c.TLSHandshakeTimeout)\n}\n\nfunc TestSetDial(t *testing.T) {\n\ttestErr := errors.New(\"test\")\n\ttestDial := func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\treturn nil, testErr\n\t}\n\tc := tc().SetDial(testDial)\n\t_, err := c.DialContext(nil, \"\", \"\")\n\ttests.AssertEqual(t, testErr, err)\n}\n\nfunc TestSetDialTLS(t *testing.T) {\n\ttestErr := errors.New(\"test\")\n\ttestDialTLS := func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\treturn nil, testErr\n\t}\n\tc := tc().SetDialTLS(testDialTLS)\n\t_, err := c.DialTLSContext(nil, \"\", \"\")\n\ttests.AssertEqual(t, testErr, err)\n}\n\nfunc TestSetFuncs(t *testing.T) {\n\ttestErr := errors.New(\"test\")\n\tmarshalFunc := func(v interface{}) ([]byte, error) {\n\t\treturn nil, testErr\n\t}\n\tunmarshalFunc := func(data []byte, v interface{}) error {\n\t\treturn testErr\n\t}\n\tc := tc().\n\t\tSetJsonMarshal(marshalFunc).\n\t\tSetJsonUnmarshal(unmarshalFunc).\n\t\tSetXmlMarshal(marshalFunc).\n\t\tSetXmlUnmarshal(unmarshalFunc)\n\n\t_, err := c.jsonMarshal(nil)\n\ttests.AssertEqual(t, testErr, err)\n\terr = c.jsonUnmarshal(nil, nil)\n\ttests.AssertEqual(t, testErr, err)\n\n\t_, err = c.xmlMarshal(nil)\n\ttests.AssertEqual(t, testErr, err)\n\terr = c.xmlUnmarshal(nil, nil)\n\ttests.AssertEqual(t, testErr, err)\n}\n\nfunc TestSetCookieJar(t *testing.T) {\n\tc := tc().SetCookieJar(nil)\n\ttests.AssertEqual(t, nil, c.httpClient.Jar)\n}\n\nfunc TestTraceAll(t *testing.T) {\n\tc := tc().EnableTraceAll()\n\tresp, err := c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, resp.TraceInfo().TotalTime > 0)\n\n\tc.DisableTraceAll()\n\tresp, err = c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, resp.TraceInfo().TotalTime == 0)\n}\n\nfunc TestOnAfterResponse(t *testing.T) {\n\tc := tc()\n\tlen1 := len(c.afterResponse)\n\tc.OnAfterResponse(func(client *Client, response *Response) error {\n\t\treturn nil\n\t})\n\tlen2 := len(c.afterResponse)\n\ttests.AssertEqual(t, true, len1+1 == len2)\n}\n\nfunc TestOnBeforeRequest(t *testing.T) {\n\tc := tc().OnBeforeRequest(func(client *Client, request *Request) error {\n\t\treturn nil\n\t})\n\ttests.AssertEqual(t, true, len(c.udBeforeRequest) == 1)\n}\n\nfunc TestSetProxyURL(t *testing.T) {\n\tc := tc().SetProxyURL(\"http://dummy.proxy.local\")\n\tu, err := c.Proxy(nil)\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, \"http://dummy.proxy.local\", u.String())\n}\n\nfunc TestSetProxy(t *testing.T) {\n\tu, _ := url.Parse(\"http://dummy.proxy.local\")\n\tproxy := http.ProxyURL(u)\n\tc := tc().SetProxy(proxy)\n\tuu, err := c.Proxy(nil)\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, u.String(), uu.String())\n}\n\nfunc TestSetCommonContentType(t *testing.T) {\n\tc := tc().SetCommonContentType(header.JsonContentType)\n\ttests.AssertEqual(t, header.JsonContentType, c.Headers.Get(header.ContentType))\n}\n\nfunc TestSetCommonHeader(t *testing.T) {\n\tc := tc().SetCommonHeader(\"my-header\", \"my-value\")\n\ttests.AssertEqual(t, \"my-value\", c.Headers.Get(\"my-header\"))\n}\n\nfunc TestSetCommonHeaderNonCanonical(t *testing.T) {\n\tc := tc().SetCommonHeaderNonCanonical(\"my-Header\", \"my-value\")\n\ttests.AssertEqual(t, \"my-value\", c.Headers[\"my-Header\"][0])\n}\n\nfunc TestSetCommonHeaders(t *testing.T) {\n\tc := tc().SetCommonHeaders(map[string]string{\n\t\t\"header1\": \"value1\",\n\t\t\"header2\": \"value2\",\n\t})\n\ttests.AssertEqual(t, \"value1\", c.Headers.Get(\"header1\"))\n\ttests.AssertEqual(t, \"value2\", c.Headers.Get(\"header2\"))\n}\n\nfunc TestSetCommonHeadersNonCanonical(t *testing.T) {\n\tc := tc().SetCommonHeadersNonCanonical(map[string]string{\n\t\t\"my-Header\": \"my-value\",\n\t})\n\ttests.AssertEqual(t, \"my-value\", c.Headers[\"my-Header\"][0])\n}\n\nfunc TestSetCommonBasicAuth(t *testing.T) {\n\tc := tc().SetCommonBasicAuth(\"imroc\", \"123456\")\n\ttests.AssertEqual(t, \"Basic aW1yb2M6MTIzNDU2\", c.Headers.Get(\"Authorization\"))\n}\n\nfunc TestSetCommonBearerAuthToken(t *testing.T) {\n\tc := tc().SetCommonBearerAuthToken(\"123456\")\n\ttests.AssertEqual(t, \"Bearer 123456\", c.Headers.Get(\"Authorization\"))\n}\n\nfunc TestSetUserAgent(t *testing.T) {\n\tc := tc().SetUserAgent(\"test\")\n\ttests.AssertEqual(t, \"test\", c.Headers.Get(header.UserAgent))\n}\n\nfunc TestAutoDecode(t *testing.T) {\n\tc := tc().DisableAutoDecode()\n\tresp, err := c.R().Get(\"/gbk\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, toGbk(\"我是roc\"), resp.Bytes())\n\n\tresp, err = c.EnableAutoDecode().R().Get(\"/gbk\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"我是roc\", resp.String())\n\n\tresp, err = c.SetAutoDecodeContentType(\"html\").R().Get(\"/gbk\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, toGbk(\"我是roc\"), resp.Bytes())\n\tresp, err = c.SetAutoDecodeContentType(\"text\").R().Get(\"/gbk\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"我是roc\", resp.String())\n\tresp, err = c.SetAutoDecodeContentTypeFunc(func(contentType string) bool {\n\t\treturn strings.Contains(contentType, \"text\")\n\t}).R().Get(\"/gbk\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"我是roc\", resp.String())\n\n\tresp, err = c.SetAutoDecodeAllContentType().R().Get(\"/gbk-no-charset\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertContains(t, resp.String(), \"我是roc\", true)\n}\n\nfunc TestSetTimeout(t *testing.T) {\n\ttimeout := 100 * time.Second\n\tc := tc().SetTimeout(timeout)\n\ttests.AssertEqual(t, timeout, c.httpClient.Timeout)\n}\n\nfunc TestSetLogger(t *testing.T) {\n\tl := createDefaultLogger()\n\tc := tc().SetLogger(l)\n\ttests.AssertEqual(t, l, c.log)\n\n\tc.SetLogger(nil)\n\ttests.AssertEqual(t, &disableLogger{}, c.log)\n}\n\nfunc TestSetScheme(t *testing.T) {\n\tc := tc().SetScheme(\"https\")\n\ttests.AssertEqual(t, \"https\", c.scheme)\n}\n\nfunc TestDebugLog(t *testing.T) {\n\tc := tc().EnableDebugLog()\n\ttests.AssertEqual(t, true, c.DebugLog)\n\n\tc.DisableDebugLog()\n\ttests.AssertEqual(t, false, c.DebugLog)\n}\n\nfunc TestSetCommonCookies(t *testing.T) {\n\theaders := make(http.Header)\n\tresp, err := tc().SetCommonCookies(&http.Cookie{\n\t\tName:  \"test\",\n\t\tValue: \"test\",\n\t}).R().SetSuccessResult(&headers).Get(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test=test\", headers.Get(\"Cookie\"))\n}\n\nfunc TestSetCommonQueryString(t *testing.T) {\n\tresp, err := tc().SetCommonQueryString(\"test=test\").R().Get(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test=test\", resp.String())\n}\n\nfunc TestSetCommonPathParams(t *testing.T) {\n\tc := tc().SetCommonPathParams(map[string]string{\"test\": \"test\"})\n\ttests.AssertNotNil(t, c.PathParams)\n\ttests.AssertEqual(t, \"test\", c.PathParams[\"test\"])\n}\n\nfunc TestSetCommonPathParam(t *testing.T) {\n\tc := tc().SetCommonPathParam(\"test\", \"test\")\n\ttests.AssertNotNil(t, c.PathParams)\n\ttests.AssertEqual(t, \"test\", c.PathParams[\"test\"])\n}\n\nfunc TestAddCommonQueryParam(t *testing.T) {\n\tresp, err := tc().\n\t\tAddCommonQueryParam(\"test\", \"1\").\n\t\tAddCommonQueryParam(\"test\", \"2\").\n\t\tR().Get(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test=1&test=2\", resp.String())\n}\n\nfunc TestSetCommonQueryParam(t *testing.T) {\n\tresp, err := tc().SetCommonQueryParam(\"test\", \"test\").R().Get(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test=test\", resp.String())\n}\n\nfunc TestSetCommonQueryParams(t *testing.T) {\n\tresp, err := tc().SetCommonQueryParams(map[string]string{\"test\": \"test\"}).R().Get(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test=test\", resp.String())\n}\n\nfunc TestInsecureSkipVerify(t *testing.T) {\n\tc := tc().EnableInsecureSkipVerify()\n\ttests.AssertEqual(t, true, c.TLSClientConfig.InsecureSkipVerify)\n\n\tc.DisableInsecureSkipVerify()\n\ttests.AssertEqual(t, false, c.TLSClientConfig.InsecureSkipVerify)\n}\n\nfunc TestSetTLSClientConfig(t *testing.T) {\n\tconfig := &tls.Config{InsecureSkipVerify: true}\n\tc := tc().SetTLSClientConfig(config)\n\ttests.AssertEqual(t, config, c.TLSClientConfig)\n}\n\nfunc TestCompression(t *testing.T) {\n\tc := tc().DisableCompression()\n\ttests.AssertEqual(t, true, c.Transport.DisableCompression)\n\n\tc.EnableCompression()\n\ttests.AssertEqual(t, false, c.Transport.DisableCompression)\n}\n\nfunc TestKeepAlives(t *testing.T) {\n\tc := tc().DisableKeepAlives()\n\ttests.AssertEqual(t, true, c.Transport.DisableKeepAlives)\n\n\tc.EnableKeepAlives()\n\ttests.AssertEqual(t, false, c.Transport.DisableKeepAlives)\n}\n\nfunc TestRedirect(t *testing.T) {\n\t_, err := tc().SetRedirectPolicy(NoRedirectPolicy()).R().Get(\"/unlimited-redirect\")\n\ttests.AssertIsNil(t, err)\n\n\t_, err = tc().SetRedirectPolicy(MaxRedirectPolicy(3)).R().Get(\"/unlimited-redirect\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertContains(t, err.Error(), \"stopped after 3 redirects\", true)\n\n\t_, err = tc().SetRedirectPolicy(MaxRedirectPolicy(20)).SetRedirectPolicy(DefaultRedirectPolicy()).R().Get(\"/unlimited-redirect\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertContains(t, err.Error(), \"stopped after 10 redirects\", true)\n\n\t_, err = tc().SetRedirectPolicy(SameDomainRedirectPolicy()).R().Get(\"/redirect-to-other\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertContains(t, err.Error(), \"different domain name is not allowed\", true)\n\n\t_, err = tc().SetRedirectPolicy(SameHostRedirectPolicy()).R().Get(\"/redirect-to-other\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertContains(t, err.Error(), \"different host name is not allowed\", true)\n\n\t_, err = tc().SetRedirectPolicy(AllowedHostRedirectPolicy(\"localhost\", \"127.0.0.1\")).R().Get(\"/redirect-to-other\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertContains(t, err.Error(), \"redirect host [dummy.local] is not allowed\", true)\n\n\t_, err = tc().SetRedirectPolicy(AllowedDomainRedirectPolicy(\"localhost\", \"127.0.0.1\")).R().Get(\"/redirect-to-other\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertContains(t, err.Error(), \"redirect domain [dummy.local] is not allowed\", true)\n\n\tc := tc().SetRedirectPolicy(AlwaysCopyHeaderRedirectPolicy(\"Authorization\"))\n\tnewHeader := make(http.Header)\n\toldHeader := make(http.Header)\n\toldHeader.Set(\"Authorization\", \"test\")\n\tc.GetClient().CheckRedirect(&http.Request{\n\t\tHeader: newHeader,\n\t}, []*http.Request{&http.Request{\n\t\tHeader: oldHeader,\n\t}})\n\ttests.AssertEqual(t, \"test\", newHeader.Get(\"Authorization\"))\n}\n\nfunc TestGetTLSClientConfig(t *testing.T) {\n\tc := tc()\n\tconfig := c.GetTLSClientConfig()\n\ttests.AssertEqual(t, true, c.TLSClientConfig != nil)\n\ttests.AssertEqual(t, config, c.TLSClientConfig)\n}\n\nfunc TestSetRootCertFromFile(t *testing.T) {\n\tc := tc().SetRootCertsFromFile(tests.GetTestFilePath(\"sample-root.pem\"))\n\ttests.AssertEqual(t, true, c.TLSClientConfig.RootCAs != nil)\n}\n\nfunc TestSetRootCertFromString(t *testing.T) {\n\tc := tc().SetRootCertFromString(string(getTestFileContent(t, \"sample-root.pem\")))\n\ttests.AssertEqual(t, true, c.TLSClientConfig.RootCAs != nil)\n}\n\nfunc TestSetCerts(t *testing.T) {\n\tc := tc().SetCerts(tls.Certificate{}, tls.Certificate{})\n\ttests.AssertEqual(t, true, len(c.TLSClientConfig.Certificates) == 2)\n}\n\nfunc TestSetCertFromFile(t *testing.T) {\n\tc := tc().SetCertFromFile(\n\t\ttests.GetTestFilePath(\"sample-client.pem\"),\n\t\ttests.GetTestFilePath(\"sample-client-key.pem\"),\n\t)\n\ttests.AssertEqual(t, true, len(c.TLSClientConfig.Certificates) == 1)\n}\n\nfunc TestSetOutputDirectory(t *testing.T) {\n\toutFile := \"test_output_dir\"\n\tresp, err := tc().\n\t\tSetOutputDirectory(testDataPath).\n\t\tR().SetOutputFile(outFile).\n\t\tGet(\"/\")\n\tassertSuccess(t, resp, err)\n\tcontent := string(getTestFileContent(t, outFile))\n\tos.Remove(tests.GetTestFilePath(outFile))\n\ttests.AssertEqual(t, \"TestGet: text response\", content)\n}\n\nfunc TestSetBaseURL(t *testing.T) {\n\tbaseURL := \"http://dummy-req.local/test\"\n\tresp, _ := tc().SetTimeout(time.Nanosecond).SetBaseURL(baseURL).R().Get(\"/req\")\n\ttests.AssertEqual(t, baseURL+\"/req\", resp.Request.RawRequest.URL.String())\n}\n\nfunc TestSetCommonFormDataFromValues(t *testing.T) {\n\texpectedForm := make(url.Values)\n\tgotForm := make(url.Values)\n\texpectedForm.Set(\"test\", \"test\")\n\tresp, err := tc().\n\t\tSetCommonFormDataFromValues(expectedForm).\n\t\tR().SetSuccessResult(&gotForm).\n\t\tPost(\"/form\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test\", gotForm.Get(\"test\"))\n}\n\nfunc TestSetCommonFormData(t *testing.T) {\n\tform := make(url.Values)\n\tresp, err := tc().\n\t\tSetCommonFormData(\n\t\t\tmap[string]string{\n\t\t\t\t\"test\": \"test\",\n\t\t\t}).R().\n\t\tSetSuccessResult(&form).\n\t\tPost(\"/form\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test\", form.Get(\"test\"))\n}\n\nfunc TestSetMultipartBoundaryFunc(t *testing.T) {\n\tdelimiter := \"test-delimiter\"\n\texpectedContentType := fmt.Sprintf(\"multipart/form-data; boundary=%s\", delimiter)\n\tresp, err := tc().\n\t\tSetMultipartBoundaryFunc(func() string {\n\t\t\treturn delimiter\n\t\t}).R().\n\t\tEnableForceMultipart().\n\t\tSetFormData(\n\t\t\tmap[string]string{\n\t\t\t\t\"test\": \"test\",\n\t\t\t}).\n\t\tPost(\"/content-type\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, expectedContentType, resp.String())\n}\n\nfunc TestFirefoxMultipartBoundaryFunc(t *testing.T) {\n\tr := regexp.MustCompile(`^-------------------------\\d{1,10}\\d{1,10}\\d{1,10}$`)\n\tb := firefoxMultipartBoundaryFunc()\n\ttests.AssertEqual(t, true, r.MatchString(b))\n}\n\nfunc TestWebkitMultipartBoundaryFunc(t *testing.T) {\n\tr := regexp.MustCompile(`^----WebKitFormBoundary[0-9a-zA-Z]{16}$`)\n\tb := webkitMultipartBoundaryFunc()\n\ttests.AssertEqual(t, true, r.MatchString(b))\n}\n\nfunc TestClientClone(t *testing.T) {\n\tc1 := tc().DevMode().\n\t\tSetCommonHeader(\"test\", \"test\").\n\t\tSetCommonCookies(&http.Cookie{\n\t\t\tName:  \"test\",\n\t\t\tValue: \"test\",\n\t\t}).SetCommonQueryParam(\"test\", \"test\").\n\t\tSetCommonPathParam(\"test\", \"test\").\n\t\tSetCommonRetryCount(2).\n\t\tSetCommonFormData(map[string]string{\"test\": \"test\"}).\n\t\tOnBeforeRequest(func(c *Client, r *Request) error { return nil })\n\n\tc2 := c1.Clone()\n\tassertClone(t, c1, c2)\n}\n\nfunc TestDisableAutoReadResponse(t *testing.T) {\n\ttestWithAllTransport(t, testDisableAutoReadResponse)\n}\n\nfunc testDisableAutoReadResponse(t *testing.T, c *Client) {\n\tc.DisableAutoReadResponse()\n\tresp, err := c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"\", resp.String())\n\tresult, err := resp.ToString()\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, \"TestGet: text response\", result)\n\n\tresp, err = c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\t_, err = io.ReadAll(resp.Body)\n\ttests.AssertNoError(t, err)\n}\n\nfunc testEnableDumpAll(t *testing.T, fn func(c *Client) (de dumpExpected)) {\n\ttestDump := func(c *Client) {\n\t\tbuff := new(bytes.Buffer)\n\t\tc.EnableDumpAllTo(buff)\n\t\tr := c.R()\n\t\tde := fn(c)\n\t\tresp, err := r.SetBody(`test body`).Post(\"/\")\n\t\tassertSuccess(t, resp, err)\n\t\tdump := buff.String()\n\t\ttests.AssertContains(t, dump, \"user-agent\", de.ReqHeader)\n\t\ttests.AssertContains(t, dump, \"test body\", de.ReqBody)\n\t\ttests.AssertContains(t, dump, \"date\", de.RespHeader)\n\t\ttests.AssertContains(t, dump, \"testpost: text response\", de.RespBody)\n\t}\n\tc := tc()\n\ttestDump(c)\n\ttestDump(c.EnableForceHTTP1())\n}\n\nfunc TestEnableDumpAll(t *testing.T) {\n\ttestCases := []func(c *Client) (d dumpExpected){\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAll()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\tde.RespHeader = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAllWithoutHeader()\n\t\t\tde.ReqBody = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAllWithoutBody()\n\t\t\tde.ReqHeader = true\n\t\t\tde.RespHeader = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAllWithoutRequest()\n\t\t\tde.RespHeader = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAllWithoutRequestBody()\n\t\t\tde.ReqHeader = true\n\t\t\tde.RespHeader = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAllWithoutResponse()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.EnableDumpAllWithoutResponseBody()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\tde.RespHeader = true\n\t\t\treturn\n\t\t},\n\t\tfunc(c *Client) (de dumpExpected) {\n\t\t\tc.SetCommonDumpOptions(&DumpOptions{\n\t\t\t\tRequestHeader: true,\n\t\t\t\tRequestBody:   true,\n\t\t\t\tResponseBody:  true,\n\t\t\t}).EnableDumpAll()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t}\n\tfor _, fn := range testCases {\n\t\ttestEnableDumpAll(t, fn)\n\t}\n}\n\nfunc TestEnableDumpAllToFile(t *testing.T) {\n\tc := tc()\n\tdumpFile := \"tmp_test_dump_file\"\n\tc.EnableDumpAllToFile(tests.GetTestFilePath(dumpFile))\n\tresp, err := c.R().SetBody(\"test body\").Post(\"/\")\n\tassertSuccess(t, resp, err)\n\tdump := string(getTestFileContent(t, dumpFile))\n\tos.Remove(tests.GetTestFilePath(dumpFile))\n\ttests.AssertContains(t, dump, \"user-agent\", true)\n\ttests.AssertContains(t, dump, \"test body\", true)\n\ttests.AssertContains(t, dump, \"date\", true)\n\ttests.AssertContains(t, dump, \"testpost: text response\", true)\n}\n\nfunc TestEnableDumpAllAsync(t *testing.T) {\n\tc := tc()\n\tbuf := new(bytes.Buffer)\n\tc.EnableDumpAllTo(buf).EnableDumpAllAsync()\n\ttests.AssertEqual(t, true, c.getDumpOptions().Async)\n}\n\nfunc TestSetResponseBodyTransformer(t *testing.T) {\n\tc := tc().SetResponseBodyTransformer(func(rawBody []byte, req *Request, resp *Response) (transformedBody []byte, err error) {\n\t\tif resp.IsSuccessState() {\n\t\t\tresult, err := url.QueryUnescape(string(rawBody))\n\t\t\treturn []byte(result), err\n\t\t}\n\t\treturn rawBody, nil\n\t})\n\tuser := &UserInfo{}\n\tresp, err := c.R().SetSuccessResult(user).Get(\"/urlencode\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, user.Username, \"我是roc\")\n\ttests.AssertEqual(t, user.Email, \"roc@imroc.cc\")\n}\n\nfunc TestSetResultStateCheckFunc(t *testing.T) {\n\tc := tc().SetResultStateCheckFunc(func(resp *Response) ResultState {\n\t\tif resp.StatusCode == http.StatusOK {\n\t\t\treturn SuccessState\n\t\t} else {\n\t\t\treturn ErrorState\n\t\t}\n\t})\n\tresp, err := c.R().Get(\"/status?code=200\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, SuccessState, resp.ResultState())\n\n\tresp, err = c.R().Get(\"/status?code=201\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, ErrorState, resp.ResultState())\n\n\tresp, err = c.R().Get(\"/status?code=399\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, ErrorState, resp.ResultState())\n\n\tresp, err = c.R().Get(\"/status?code=404\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, ErrorState, resp.ResultState())\n}\nfunc TestCloneCookieJar(t *testing.T) {\n\tc1 := C()\n\tc2 := c1.Clone()\n\ttests.AssertEqual(t, true, c1.httpClient.Jar != c2.httpClient.Jar)\n\n\tjar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})\n\tc1.SetCookieJar(jar)\n\tc2 = c1.Clone()\n\ttests.AssertEqual(t, true, c1.httpClient.Jar == c2.httpClient.Jar)\n\n\tc2.SetCookieJar(nil)\n\ttests.AssertEqual(t, true, c2.cookiejarFactory == nil)\n\ttests.AssertEqual(t, true, c2.httpClient.Jar == nil)\n}\n"
        },
        {
          "name": "client_wrapper.go",
          "type": "blob",
          "size": 29.1025390625,
          "content": "package req\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/http2\"\n\tutls \"github.com/refraction-networking/utls\"\n)\n\n// WrapRoundTrip is a global wrapper methods which delegated\n// to the default client's Client.WrapRoundTrip.\nfunc WrapRoundTrip(wrappers ...RoundTripWrapper) *Client {\n\treturn defaultClient.WrapRoundTrip(wrappers...)\n}\n\n// WrapRoundTripFunc is a global wrapper methods which delegated\n// to the default client's Client.WrapRoundTripFunc.\nfunc WrapRoundTripFunc(funcs ...RoundTripWrapperFunc) *Client {\n\treturn defaultClient.WrapRoundTripFunc(funcs...)\n}\n\n// SetCommonError is a global wrapper methods which delegated\n// to the default client's Client.SetCommonErrorResult.\n//\n// Deprecated: Use SetCommonErrorResult instead.\nfunc SetCommonError(err interface{}) *Client {\n\treturn defaultClient.SetCommonErrorResult(err)\n}\n\n// SetCommonErrorResult is a global wrapper methods which delegated\n// to the default client's Client.SetCommonError.\nfunc SetCommonErrorResult(err interface{}) *Client {\n\treturn defaultClient.SetCommonErrorResult(err)\n}\n\n// SetResultStateCheckFunc is a global wrapper methods which delegated\n// to the default client's Client.SetCommonResultStateCheckFunc.\nfunc SetResultStateCheckFunc(fn func(resp *Response) ResultState) *Client {\n\treturn defaultClient.SetResultStateCheckFunc(fn)\n}\n\n// SetCommonFormDataFromValues is a global wrapper methods which delegated\n// to the default client's Client.SetCommonFormDataFromValues.\nfunc SetCommonFormDataFromValues(data url.Values) *Client {\n\treturn defaultClient.SetCommonFormDataFromValues(data)\n}\n\n// SetCommonFormData is a global wrapper methods which delegated\n// to the default client's Client.SetCommonFormData.\nfunc SetCommonFormData(data map[string]string) *Client {\n\treturn defaultClient.SetCommonFormData(data)\n}\n\n// SetMultipartBoundaryFunc is a global wrapper methods which delegated\n// to the default client's Client.SetMultipartBoundaryFunc.\nfunc SetMultipartBoundaryFunc(fn func() string) *Client {\n\treturn defaultClient.SetMultipartBoundaryFunc(fn)\n}\n\n// SetBaseURL is a global wrapper methods which delegated\n// to the default client's Client.SetBaseURL.\nfunc SetBaseURL(u string) *Client {\n\treturn defaultClient.SetBaseURL(u)\n}\n\n// SetOutputDirectory is a global wrapper methods which delegated\n// to the default client's Client.SetOutputDirectory.\nfunc SetOutputDirectory(dir string) *Client {\n\treturn defaultClient.SetOutputDirectory(dir)\n}\n\n// SetCertFromFile is a global wrapper methods which delegated\n// to the default client's Client.SetCertFromFile.\nfunc SetCertFromFile(certFile, keyFile string) *Client {\n\treturn defaultClient.SetCertFromFile(certFile, keyFile)\n}\n\n// SetCerts is a global wrapper methods which delegated\n// to the default client's Client.SetCerts.\nfunc SetCerts(certs ...tls.Certificate) *Client {\n\treturn defaultClient.SetCerts(certs...)\n}\n\n// SetRootCertFromString is a global wrapper methods which delegated\n// to the default client's Client.SetRootCertFromString.\nfunc SetRootCertFromString(pemContent string) *Client {\n\treturn defaultClient.SetRootCertFromString(pemContent)\n}\n\n// SetRootCertsFromFile is a global wrapper methods which delegated\n// to the default client's Client.SetRootCertsFromFile.\nfunc SetRootCertsFromFile(pemFiles ...string) *Client {\n\treturn defaultClient.SetRootCertsFromFile(pemFiles...)\n}\n\n// GetTLSClientConfig is a global wrapper methods which delegated\n// to the default client's Client.GetTLSClientConfig.\nfunc GetTLSClientConfig() *tls.Config {\n\treturn defaultClient.GetTLSClientConfig()\n}\n\n// SetRedirectPolicy is a global wrapper methods which delegated\n// to the default client's Client.SetRedirectPolicy.\nfunc SetRedirectPolicy(policies ...RedirectPolicy) *Client {\n\treturn defaultClient.SetRedirectPolicy(policies...)\n}\n\n// DisableKeepAlives is a global wrapper methods which delegated\n// to the default client's Client.DisableKeepAlives.\nfunc DisableKeepAlives() *Client {\n\treturn defaultClient.DisableKeepAlives()\n}\n\n// EnableKeepAlives is a global wrapper methods which delegated\n// to the default client's Client.EnableKeepAlives.\nfunc EnableKeepAlives() *Client {\n\treturn defaultClient.EnableKeepAlives()\n}\n\n// DisableCompression is a global wrapper methods which delegated\n// to the default client's Client.DisableCompression.\nfunc DisableCompression() *Client {\n\treturn defaultClient.DisableCompression()\n}\n\n// EnableCompression is a global wrapper methods which delegated\n// to the default client's Client.EnableCompression.\nfunc EnableCompression() *Client {\n\treturn defaultClient.EnableCompression()\n}\n\n// SetTLSClientConfig is a global wrapper methods which delegated\n// to the default client's Client.SetTLSClientConfig.\nfunc SetTLSClientConfig(conf *tls.Config) *Client {\n\treturn defaultClient.SetTLSClientConfig(conf)\n}\n\n// EnableInsecureSkipVerify is a global wrapper methods which delegated\n// to the default client's Client.EnableInsecureSkipVerify.\nfunc EnableInsecureSkipVerify() *Client {\n\treturn defaultClient.EnableInsecureSkipVerify()\n}\n\n// DisableInsecureSkipVerify is a global wrapper methods which delegated\n// to the default client's Client.DisableInsecureSkipVerify.\nfunc DisableInsecureSkipVerify() *Client {\n\treturn defaultClient.DisableInsecureSkipVerify()\n}\n\n// SetCommonQueryParams is a global wrapper methods which delegated\n// to the default client's Client.SetCommonQueryParams.\nfunc SetCommonQueryParams(params map[string]string) *Client {\n\treturn defaultClient.SetCommonQueryParams(params)\n}\n\n// AddCommonQueryParam is a global wrapper methods which delegated\n// to the default client's Client.AddCommonQueryParam.\nfunc AddCommonQueryParam(key, value string) *Client {\n\treturn defaultClient.AddCommonQueryParam(key, value)\n}\n\n// AddCommonQueryParams is a global wrapper methods which delegated\n// to the default client's Client.AddCommonQueryParams.\nfunc AddCommonQueryParams(key string, values ...string) *Client {\n\treturn defaultClient.AddCommonQueryParams(key, values...)\n}\n\n// SetCommonPathParam is a global wrapper methods which delegated\n// to the default client's Client.SetCommonPathParam.\nfunc SetCommonPathParam(key, value string) *Client {\n\treturn defaultClient.SetCommonPathParam(key, value)\n}\n\n// SetCommonPathParams is a global wrapper methods which delegated\n// to the default client's Client.SetCommonPathParams.\nfunc SetCommonPathParams(pathParams map[string]string) *Client {\n\treturn defaultClient.SetCommonPathParams(pathParams)\n}\n\n// SetCommonQueryParam is a global wrapper methods which delegated\n// to the default client's Client.SetCommonQueryParam.\nfunc SetCommonQueryParam(key, value string) *Client {\n\treturn defaultClient.SetCommonQueryParam(key, value)\n}\n\n// SetCommonQueryString is a global wrapper methods which delegated\n// to the default client's Client.SetCommonQueryString.\nfunc SetCommonQueryString(query string) *Client {\n\treturn defaultClient.SetCommonQueryString(query)\n}\n\n// SetCommonCookies is a global wrapper methods which delegated\n// to the default client's Client.SetCommonCookies.\nfunc SetCommonCookies(cookies ...*http.Cookie) *Client {\n\treturn defaultClient.SetCommonCookies(cookies...)\n}\n\n// DisableDebugLog is a global wrapper methods which delegated\n// to the default client's Client.DisableDebugLog.\nfunc DisableDebugLog() *Client {\n\treturn defaultClient.DisableDebugLog()\n}\n\n// EnableDebugLog is a global wrapper methods which delegated\n// to the default client's Client.EnableDebugLog.\nfunc EnableDebugLog() *Client {\n\treturn defaultClient.EnableDebugLog()\n}\n\n// DevMode is a global wrapper methods which delegated\n// to the default client's Client.DevMode.\nfunc DevMode() *Client {\n\treturn defaultClient.DevMode()\n}\n\n// SetScheme is a global wrapper methods which delegated\n// to the default client's Client.SetScheme.\nfunc SetScheme(scheme string) *Client {\n\treturn defaultClient.SetScheme(scheme)\n}\n\n// SetLogger is a global wrapper methods which delegated\n// to the default client's Client.SetLogger.\nfunc SetLogger(log Logger) *Client {\n\treturn defaultClient.SetLogger(log)\n}\n\n// SetTimeout is a global wrapper methods which delegated\n// to the default client's Client.SetTimeout.\nfunc SetTimeout(d time.Duration) *Client {\n\treturn defaultClient.SetTimeout(d)\n}\n\n// EnableDumpAll is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAll.\nfunc EnableDumpAll() *Client {\n\treturn defaultClient.EnableDumpAll()\n}\n\n// EnableDumpAllToFile is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllToFile.\nfunc EnableDumpAllToFile(filename string) *Client {\n\treturn defaultClient.EnableDumpAllToFile(filename)\n}\n\n// EnableDumpAllTo is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllTo.\nfunc EnableDumpAllTo(output io.Writer) *Client {\n\treturn defaultClient.EnableDumpAllTo(output)\n}\n\n// EnableDumpAllAsync is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllAsync.\nfunc EnableDumpAllAsync() *Client {\n\treturn defaultClient.EnableDumpAllAsync()\n}\n\n// EnableDumpAllWithoutRequestBody is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllWithoutRequestBody.\nfunc EnableDumpAllWithoutRequestBody() *Client {\n\treturn defaultClient.EnableDumpAllWithoutRequestBody()\n}\n\n// EnableDumpAllWithoutResponseBody is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllWithoutResponseBody.\nfunc EnableDumpAllWithoutResponseBody() *Client {\n\treturn defaultClient.EnableDumpAllWithoutResponseBody()\n}\n\n// EnableDumpAllWithoutResponse is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllWithoutResponse.\nfunc EnableDumpAllWithoutResponse() *Client {\n\treturn defaultClient.EnableDumpAllWithoutResponse()\n}\n\n// EnableDumpAllWithoutRequest is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllWithoutRequest.\nfunc EnableDumpAllWithoutRequest() *Client {\n\treturn defaultClient.EnableDumpAllWithoutRequest()\n}\n\n// EnableDumpAllWithoutHeader is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllWithoutHeader.\nfunc EnableDumpAllWithoutHeader() *Client {\n\treturn defaultClient.EnableDumpAllWithoutHeader()\n}\n\n// EnableDumpAllWithoutBody is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpAllWithoutBody.\nfunc EnableDumpAllWithoutBody() *Client {\n\treturn defaultClient.EnableDumpAllWithoutBody()\n}\n\n// EnableDumpEachRequest is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequest.\nfunc EnableDumpEachRequest() *Client {\n\treturn defaultClient.EnableDumpEachRequest()\n}\n\n// EnableDumpEachRequestWithoutBody is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequestWithoutBody.\nfunc EnableDumpEachRequestWithoutBody() *Client {\n\treturn defaultClient.EnableDumpEachRequestWithoutBody()\n}\n\n// EnableDumpEachRequestWithoutHeader is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequestWithoutHeader.\nfunc EnableDumpEachRequestWithoutHeader() *Client {\n\treturn defaultClient.EnableDumpEachRequestWithoutHeader()\n}\n\n// EnableDumpEachRequestWithoutResponse is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequestWithoutResponse.\nfunc EnableDumpEachRequestWithoutResponse() *Client {\n\treturn defaultClient.EnableDumpEachRequestWithoutResponse()\n}\n\n// EnableDumpEachRequestWithoutRequest is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequestWithoutRequest.\nfunc EnableDumpEachRequestWithoutRequest() *Client {\n\treturn defaultClient.EnableDumpEachRequestWithoutRequest()\n}\n\n// EnableDumpEachRequestWithoutResponseBody is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequestWithoutResponseBody.\nfunc EnableDumpEachRequestWithoutResponseBody() *Client {\n\treturn defaultClient.EnableDumpEachRequestWithoutResponseBody()\n}\n\n// EnableDumpEachRequestWithoutRequestBody is a global wrapper methods which delegated\n// to the default client's Client.EnableDumpEachRequestWithoutRequestBody.\nfunc EnableDumpEachRequestWithoutRequestBody() *Client {\n\treturn defaultClient.EnableDumpEachRequestWithoutRequestBody()\n}\n\n// DisableAutoReadResponse is a global wrapper methods which delegated\n// to the default client's Client.DisableAutoReadResponse.\nfunc DisableAutoReadResponse() *Client {\n\treturn defaultClient.DisableAutoReadResponse()\n}\n\n// EnableAutoReadResponse is a global wrapper methods which delegated\n// to the default client's Client.EnableAutoReadResponse.\nfunc EnableAutoReadResponse() *Client {\n\treturn defaultClient.EnableAutoReadResponse()\n}\n\n// SetAutoDecodeContentType is a global wrapper methods which delegated\n// to the default client's Client.SetAutoDecodeContentType.\nfunc SetAutoDecodeContentType(contentTypes ...string) *Client {\n\treturn defaultClient.SetAutoDecodeContentType(contentTypes...)\n}\n\n// SetAutoDecodeContentTypeFunc is a global wrapper methods which delegated\n// to the default client's Client.SetAutoDecodeAllTypeFunc.\nfunc SetAutoDecodeContentTypeFunc(fn func(contentType string) bool) *Client {\n\treturn defaultClient.SetAutoDecodeContentTypeFunc(fn)\n}\n\n// SetAutoDecodeAllContentType is a global wrapper methods which delegated\n// to the default client's Client.SetAutoDecodeAllContentType.\nfunc SetAutoDecodeAllContentType() *Client {\n\treturn defaultClient.SetAutoDecodeAllContentType()\n}\n\n// DisableAutoDecode is a global wrapper methods which delegated\n// to the default client's Client.DisableAutoDecode.\nfunc DisableAutoDecode() *Client {\n\treturn defaultClient.DisableAutoDecode()\n}\n\n// EnableAutoDecode is a global wrapper methods which delegated\n// to the default client's Client.EnableAutoDecode.\nfunc EnableAutoDecode() *Client {\n\treturn defaultClient.EnableAutoDecode()\n}\n\n// SetUserAgent is a global wrapper methods which delegated\n// to the default client's Client.SetUserAgent.\nfunc SetUserAgent(userAgent string) *Client {\n\treturn defaultClient.SetUserAgent(userAgent)\n}\n\n// SetCommonBearerAuthToken is a global wrapper methods which delegated\n// to the default client's Client.SetCommonBearerAuthToken.\nfunc SetCommonBearerAuthToken(token string) *Client {\n\treturn defaultClient.SetCommonBearerAuthToken(token)\n}\n\n// SetCommonBasicAuth is a global wrapper methods which delegated\n// to the default client's Client.SetCommonBasicAuth.\nfunc SetCommonBasicAuth(username, password string) *Client {\n\treturn defaultClient.SetCommonBasicAuth(username, password)\n}\n\n// SetCommonDigestAuth is a global wrapper methods which delegated\n// to the default client's Client.SetCommonDigestAuth.\nfunc SetCommonDigestAuth(username, password string) *Client {\n\treturn defaultClient.SetCommonDigestAuth(username, password)\n}\n\n// SetCommonHeaders is a global wrapper methods which delegated\n// to the default client's Client.SetCommonHeaders.\nfunc SetCommonHeaders(hdrs map[string]string) *Client {\n\treturn defaultClient.SetCommonHeaders(hdrs)\n}\n\n// SetCommonHeader is a global wrapper methods which delegated\n// to the default client's Client.SetCommonHeader.\nfunc SetCommonHeader(key, value string) *Client {\n\treturn defaultClient.SetCommonHeader(key, value)\n}\n\n// SetCommonHeaderOrder is a global wrapper methods which delegated\n// to the default client's Client.SetCommonHeaderOrder.\nfunc SetCommonHeaderOrder(keys ...string) *Client {\n\treturn defaultClient.SetCommonHeaderOrder(keys...)\n}\n\n// SetCommonPseudoHeaderOder is a global wrapper methods which delegated\n// to the default client's Client.SetCommonPseudoHeaderOder.\nfunc SetCommonPseudoHeaderOder(keys ...string) *Client {\n\treturn defaultClient.SetCommonPseudoHeaderOder(keys...)\n}\n\n// SetHTTP2SettingsFrame is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2SettingsFrame.\nfunc SetHTTP2SettingsFrame(settings ...http2.Setting) *Client {\n\treturn defaultClient.SetHTTP2SettingsFrame(settings...)\n}\n\n// SetHTTP2ConnectionFlow is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2ConnectionFlow.\nfunc SetHTTP2ConnectionFlow(flow uint32) *Client {\n\treturn defaultClient.SetHTTP2ConnectionFlow(flow)\n}\n\n// SetHTTP2HeaderPriority is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2HeaderPriority.\nfunc SetHTTP2HeaderPriority(priority http2.PriorityParam) *Client {\n\treturn defaultClient.SetHTTP2HeaderPriority(priority)\n}\n\n// SetHTTP2PriorityFrames is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2PriorityFrames.\nfunc SetHTTP2PriorityFrames(frames ...http2.PriorityFrame) *Client {\n\treturn defaultClient.SetHTTP2PriorityFrames(frames...)\n}\n\n// SetHTTP2MaxHeaderListSize is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2MaxHeaderListSize.\nfunc SetHTTP2MaxHeaderListSize(max uint32) *Client {\n\treturn defaultClient.SetHTTP2MaxHeaderListSize(max)\n}\n\n// SetHTTP2StrictMaxConcurrentStreams is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2StrictMaxConcurrentStreams.\nfunc SetHTTP2StrictMaxConcurrentStreams(strict bool) *Client {\n\treturn defaultClient.SetHTTP2StrictMaxConcurrentStreams(strict)\n}\n\n// SetHTTP2ReadIdleTimeout is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2ReadIdleTimeout.\nfunc SetHTTP2ReadIdleTimeout(timeout time.Duration) *Client {\n\treturn defaultClient.SetHTTP2ReadIdleTimeout(timeout)\n}\n\n// SetHTTP2PingTimeout is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2PingTimeout.\nfunc SetHTTP2PingTimeout(timeout time.Duration) *Client {\n\treturn defaultClient.SetHTTP2PingTimeout(timeout)\n}\n\n// SetHTTP2WriteByteTimeout is a global wrapper methods which delegated\n// to the default client's Client.SetHTTP2WriteByteTimeout.\nfunc SetHTTP2WriteByteTimeout(timeout time.Duration) *Client {\n\treturn defaultClient.SetHTTP2WriteByteTimeout(timeout)\n}\n\n// ImpersonateChrome is a global wrapper methods which delegated\n// to the default client's Client.ImpersonateChrome.\nfunc ImpersonateChrome() *Client {\n\treturn defaultClient.ImpersonateChrome()\n}\n\n// ImpersonateChrome is a global wrapper methods which delegated\n// to the default client's Client.ImpersonateChrome.\nfunc ImpersonateFirefox() *Client {\n\treturn defaultClient.ImpersonateFirefox()\n}\n\n// ImpersonateChrome is a global wrapper methods which delegated\n// to the default client's Client.ImpersonateChrome.\nfunc ImpersonateSafari() *Client {\n\treturn defaultClient.ImpersonateFirefox()\n}\n\n// SetCommonContentType is a global wrapper methods which delegated\n// to the default client's Client.SetCommonContentType.\nfunc SetCommonContentType(ct string) *Client {\n\treturn defaultClient.SetCommonContentType(ct)\n}\n\n// DisableDumpAll is a global wrapper methods which delegated\n// to the default client's Client.DisableDumpAll.\nfunc DisableDumpAll() *Client {\n\treturn defaultClient.DisableDumpAll()\n}\n\n// SetCommonDumpOptions is a global wrapper methods which delegated\n// to the default client's Client.SetCommonDumpOptions.\nfunc SetCommonDumpOptions(opt *DumpOptions) *Client {\n\treturn defaultClient.SetCommonDumpOptions(opt)\n}\n\n// SetProxy is a global wrapper methods which delegated\n// to the default client's Client.SetProxy.\nfunc SetProxy(proxy func(*http.Request) (*url.URL, error)) *Client {\n\treturn defaultClient.SetProxy(proxy)\n}\n\n// OnBeforeRequest is a global wrapper methods which delegated\n// to the default client's Client.OnBeforeRequest.\nfunc OnBeforeRequest(m RequestMiddleware) *Client {\n\treturn defaultClient.OnBeforeRequest(m)\n}\n\n// OnAfterResponse is a global wrapper methods which delegated\n// to the default client's Client.OnAfterResponse.\nfunc OnAfterResponse(m ResponseMiddleware) *Client {\n\treturn defaultClient.OnAfterResponse(m)\n}\n\n// SetProxyURL is a global wrapper methods which delegated\n// to the default client's Client.SetProxyURL.\nfunc SetProxyURL(proxyUrl string) *Client {\n\treturn defaultClient.SetProxyURL(proxyUrl)\n}\n\n// DisableTraceAll is a global wrapper methods which delegated\n// to the default client's Client.DisableTraceAll.\nfunc DisableTraceAll() *Client {\n\treturn defaultClient.DisableTraceAll()\n}\n\n// EnableTraceAll is a global wrapper methods which delegated\n// to the default client's Client.EnableTraceAll.\nfunc EnableTraceAll() *Client {\n\treturn defaultClient.EnableTraceAll()\n}\n\n// SetCookieJar is a global wrapper methods which delegated\n// to the default client's Client.SetCookieJar.\nfunc SetCookieJar(jar http.CookieJar) *Client {\n\treturn defaultClient.SetCookieJar(jar)\n}\n\n// GetCookies is a global wrapper methods which delegated\n// to the default client's Client.GetCookies.\nfunc GetCookies(url string) ([]*http.Cookie, error) {\n\treturn defaultClient.GetCookies(url)\n}\n\n// ClearCookies is a global wrapper methods which delegated\n// to the default client's Client.ClearCookies.\nfunc ClearCookies() *Client {\n\treturn defaultClient.ClearCookies()\n}\n\n// SetJsonMarshal is a global wrapper methods which delegated\n// to the default client's Client.SetJsonMarshal.\nfunc SetJsonMarshal(fn func(v interface{}) ([]byte, error)) *Client {\n\treturn defaultClient.SetJsonMarshal(fn)\n}\n\n// SetJsonUnmarshal is a global wrapper methods which delegated\n// to the default client's Client.SetJsonUnmarshal.\nfunc SetJsonUnmarshal(fn func(data []byte, v interface{}) error) *Client {\n\treturn defaultClient.SetJsonUnmarshal(fn)\n}\n\n// SetXmlMarshal is a global wrapper methods which delegated\n// to the default client's Client.SetXmlMarshal.\nfunc SetXmlMarshal(fn func(v interface{}) ([]byte, error)) *Client {\n\treturn defaultClient.SetXmlMarshal(fn)\n}\n\n// SetXmlUnmarshal is a global wrapper methods which delegated\n// to the default client's Client.SetXmlUnmarshal.\nfunc SetXmlUnmarshal(fn func(data []byte, v interface{}) error) *Client {\n\treturn defaultClient.SetXmlUnmarshal(fn)\n}\n\n// SetDialTLS is a global wrapper methods which delegated\n// to the default client's Client.SetDialTLS.\nfunc SetDialTLS(fn func(ctx context.Context, network, addr string) (net.Conn, error)) *Client {\n\treturn defaultClient.SetDialTLS(fn)\n}\n\n// SetDial is a global wrapper methods which delegated\n// to the default client's Client.SetDial.\nfunc SetDial(fn func(ctx context.Context, network, addr string) (net.Conn, error)) *Client {\n\treturn defaultClient.SetDial(fn)\n}\n\n// SetTLSHandshakeTimeout is a global wrapper methods which delegated\n// to the default client's Client.SetTLSHandshakeTimeout.\nfunc SetTLSHandshakeTimeout(timeout time.Duration) *Client {\n\treturn defaultClient.SetTLSHandshakeTimeout(timeout)\n}\n\n// EnableForceHTTP1 is a global wrapper methods which delegated\n// to the default client's Client.EnableForceHTTP1.\nfunc EnableForceHTTP1() *Client {\n\treturn defaultClient.EnableForceHTTP1()\n}\n\n// EnableForceHTTP2 is a global wrapper methods which delegated\n// to the default client's Client.EnableForceHTTP2.\nfunc EnableForceHTTP2() *Client {\n\treturn defaultClient.EnableForceHTTP2()\n}\n\n// EnableForceHTTP3 is a global wrapper methods which delegated\n// to the default client's Client.EnableForceHTTP3.\nfunc EnableForceHTTP3() *Client {\n\treturn defaultClient.EnableForceHTTP3()\n}\n\n// EnableHTTP3 is a global wrapper methods which delegated\n// to the default client's Client.EnableHTTP3.\nfunc EnableHTTP3() *Client {\n\treturn defaultClient.EnableHTTP3()\n}\n\n// DisableForceHttpVersion is a global wrapper methods which delegated\n// to the default client's Client.DisableForceHttpVersion.\nfunc DisableForceHttpVersion() *Client {\n\treturn defaultClient.DisableForceHttpVersion()\n}\n\n// EnableH2C is a global wrapper methods which delegated\n// to the default client's Client.EnableH2C.\nfunc EnableH2C() *Client {\n\treturn defaultClient.EnableH2C()\n}\n\n// DisableH2C is a global wrapper methods which delegated\n// to the default client's Client.DisableH2C.\nfunc DisableH2C() *Client {\n\treturn defaultClient.DisableH2C()\n}\n\n// DisableAllowGetMethodPayload is a global wrapper methods which delegated\n// to the default client's Client.DisableAllowGetMethodPayload.\nfunc DisableAllowGetMethodPayload() *Client {\n\treturn defaultClient.DisableAllowGetMethodPayload()\n}\n\n// EnableAllowGetMethodPayload is a global wrapper methods which delegated\n// to the default client's Client.EnableAllowGetMethodPayload.\nfunc EnableAllowGetMethodPayload() *Client {\n\treturn defaultClient.EnableAllowGetMethodPayload()\n}\n\n// SetCommonRetryCount is a global wrapper methods which delegated\n// to the default client's Client.SetCommonRetryCount.\nfunc SetCommonRetryCount(count int) *Client {\n\treturn defaultClient.SetCommonRetryCount(count)\n}\n\n// SetCommonRetryInterval is a global wrapper methods which delegated\n// to the default client's Client.SetCommonRetryInterval.\nfunc SetCommonRetryInterval(getRetryIntervalFunc GetRetryIntervalFunc) *Client {\n\treturn defaultClient.SetCommonRetryInterval(getRetryIntervalFunc)\n}\n\n// SetCommonRetryFixedInterval is a global wrapper methods which delegated\n// to the default client's Client.SetCommonRetryFixedInterval.\nfunc SetCommonRetryFixedInterval(interval time.Duration) *Client {\n\treturn defaultClient.SetCommonRetryFixedInterval(interval)\n}\n\n// SetCommonRetryBackoffInterval is a global wrapper methods which delegated\n// to the default client's Client.SetCommonRetryBackoffInterval.\nfunc SetCommonRetryBackoffInterval(min, max time.Duration) *Client {\n\treturn defaultClient.SetCommonRetryBackoffInterval(min, max)\n}\n\n// SetCommonRetryHook is a global wrapper methods which delegated\n// to the default client's Client.SetCommonRetryHook.\nfunc SetCommonRetryHook(hook RetryHookFunc) *Client {\n\treturn defaultClient.SetCommonRetryHook(hook)\n}\n\n// AddCommonRetryHook is a global wrapper methods which delegated\n// to the default client's Client.AddCommonRetryHook.\nfunc AddCommonRetryHook(hook RetryHookFunc) *Client {\n\treturn defaultClient.AddCommonRetryHook(hook)\n}\n\n// SetCommonRetryCondition is a global wrapper methods which delegated\n// to the default client's Client.SetCommonRetryCondition.\nfunc SetCommonRetryCondition(condition RetryConditionFunc) *Client {\n\treturn defaultClient.SetCommonRetryCondition(condition)\n}\n\n// AddCommonRetryCondition is a global wrapper methods which delegated\n// to the default client's Client.AddCommonRetryCondition.\nfunc AddCommonRetryCondition(condition RetryConditionFunc) *Client {\n\treturn defaultClient.AddCommonRetryCondition(condition)\n}\n\n// SetResponseBodyTransformer is a global wrapper methods which delegated\n// to the default client's Client.SetResponseBodyTransformer.\nfunc SetResponseBodyTransformer(fn func(rawBody []byte, req *Request, resp *Response) (transformedBody []byte, err error)) *Client {\n\treturn defaultClient.SetResponseBodyTransformer(fn)\n}\n\n// SetUnixSocket is a global wrapper methods which delegated\n// to the default client's Client.SetUnixSocket.\nfunc SetUnixSocket(file string) *Client {\n\treturn defaultClient.SetUnixSocket(file)\n}\n\n// SetTLSFingerprint is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprint.\nfunc SetTLSFingerprint(clientHelloID utls.ClientHelloID) *Client {\n\treturn defaultClient.SetTLSFingerprint(clientHelloID)\n}\n\n// SetTLSFingerprintRandomized is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintRandomized.\nfunc SetTLSFingerprintRandomized() *Client {\n\treturn defaultClient.SetTLSFingerprintRandomized()\n}\n\n// SetTLSFingerprintChrome is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintChrome.\nfunc SetTLSFingerprintChrome() *Client {\n\treturn defaultClient.SetTLSFingerprintChrome()\n}\n\n// SetTLSFingerprintAndroid is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintAndroid.\nfunc SetTLSFingerprintAndroid() *Client {\n\treturn defaultClient.SetTLSFingerprintAndroid()\n}\n\n// SetTLSFingerprint360 is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprint360.\nfunc SetTLSFingerprint360() *Client {\n\treturn defaultClient.SetTLSFingerprint360()\n}\n\n// SetTLSFingerprintEdge is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintEdge.\nfunc SetTLSFingerprintEdge() *Client {\n\treturn defaultClient.SetTLSFingerprintEdge()\n}\n\n// SetTLSFingerprintFirefox is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintFirefox.\nfunc SetTLSFingerprintFirefox() *Client {\n\treturn defaultClient.SetTLSFingerprintFirefox()\n}\n\n// SetTLSFingerprintQQ is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintQQ.\nfunc SetTLSFingerprintQQ() *Client {\n\treturn defaultClient.SetTLSFingerprintQQ()\n}\n\n// SetTLSFingerprintIOS is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintIOS.\nfunc SetTLSFingerprintIOS() *Client {\n\treturn defaultClient.SetTLSFingerprintIOS()\n}\n\n// SetTLSFingerprintSafari is a global wrapper methods which delegated\n// to the default client's Client.SetTLSFingerprintSafari.\nfunc SetTLSFingerprintSafari() *Client {\n\treturn defaultClient.SetTLSFingerprintSafari()\n}\n\n// GetClient is a global wrapper methods which delegated\n// to the default client's Client.GetClient.\nfunc GetClient() *http.Client {\n\treturn defaultClient.GetClient()\n}\n\n// NewRequest is a global wrapper methods which delegated\n// to the default client's Client.NewRequest.\nfunc NewRequest() *Request {\n\treturn defaultClient.R()\n}\n\n// R is a global wrapper methods which delegated\n// to the default client's Client.R().\nfunc R() *Request {\n\treturn defaultClient.R()\n}\n"
        },
        {
          "name": "decode.go",
          "type": "blob",
          "size": 2.3515625,
          "content": "package req\n\nimport (\n\t\"github.com/imroc/req/v3/internal/charsets\"\n\t\"io\"\n\t\"strings\"\n)\n\nvar textContentTypes = []string{\"text\", \"json\", \"xml\", \"html\", \"java\"}\n\nvar autoDecodeText = autoDecodeContentTypeFunc(textContentTypes...)\n\nfunc autoDecodeContentTypeFunc(contentTypes ...string) func(contentType string) bool {\n\treturn func(contentType string) bool {\n\t\tfor _, ct := range contentTypes {\n\t\t\tif strings.Contains(contentType, ct) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\ntype decodeReaderCloser struct {\n\tio.ReadCloser\n\tdecodeReader io.Reader\n}\n\nfunc (d *decodeReaderCloser) Read(p []byte) (n int, err error) {\n\treturn d.decodeReader.Read(p)\n}\n\nfunc newAutoDecodeReadCloser(input io.ReadCloser, t *Transport) *autoDecodeReadCloser {\n\treturn &autoDecodeReadCloser{ReadCloser: input, t: t}\n}\n\ntype autoDecodeReadCloser struct {\n\tio.ReadCloser\n\tt            *Transport\n\tdecodeReader io.Reader\n\tdetected     bool\n\tpeek         []byte\n}\n\nfunc (a *autoDecodeReadCloser) peekRead(p []byte) (n int, err error) {\n\tn, err = a.ReadCloser.Read(p)\n\tif n == 0 || (err != nil && err != io.EOF) {\n\t\treturn\n\t}\n\ta.detected = true\n\tenc, name := charsets.FindEncoding(p)\n\tif enc == nil {\n\t\treturn\n\t}\n\tif a.t.Debugf != nil {\n\t\ta.t.Debugf(\"charset %s found in body's meta, auto-decode to utf-8\", name)\n\t}\n\tdc := enc.NewDecoder()\n\ta.decodeReader = dc.Reader(a.ReadCloser)\n\tvar pp []byte\n\tpp, err = dc.Bytes(p[:n])\n\tif err != nil {\n\t\treturn\n\t}\n\tif len(pp) > len(p) {\n\t\ta.peek = make([]byte, len(pp)-len(p))\n\t\tcopy(a.peek, pp[len(p):])\n\t\tcopy(p, pp[:len(p)])\n\t\tn = len(p)\n\t\treturn\n\t}\n\tcopy(p, pp)\n\tn = len(p)\n\treturn\n}\n\nfunc (a *autoDecodeReadCloser) peekDrain(p []byte) (n int, err error) {\n\tif len(a.peek) > len(p) {\n\t\tcopy(p, a.peek[:len(p)])\n\t\tpeek := make([]byte, len(a.peek)-len(p))\n\t\tcopy(peek, a.peek[len(p):])\n\t\ta.peek = peek\n\t\tn = len(p)\n\t\treturn\n\t}\n\tif len(a.peek) == len(p) {\n\t\tcopy(p, a.peek)\n\t\tn = len(p)\n\t\ta.peek = nil\n\t\treturn\n\t}\n\tpp := make([]byte, len(p)-len(a.peek))\n\tnn, err := a.decodeReader.Read(pp)\n\tn = len(a.peek) + nn\n\tcopy(p[:len(a.peek)], a.peek)\n\tcopy(p[len(a.peek):], pp[:nn])\n\ta.peek = nil\n\treturn\n}\n\nfunc (a *autoDecodeReadCloser) Read(p []byte) (n int, err error) {\n\tif !a.detected {\n\t\treturn a.peekRead(p)\n\t}\n\tif a.peek != nil {\n\t\treturn a.peekDrain(p)\n\t}\n\tif a.decodeReader != nil {\n\t\treturn a.decodeReader.Read(p)\n\t}\n\treturn a.ReadCloser.Read(p) // can not determine charset, not decode\n}\n"
        },
        {
          "name": "decode_test.go",
          "type": "blob",
          "size": 0.3662109375,
          "content": "package req\n\nimport (\n\t\"github.com/imroc/req/v3/internal/tests\"\n\t\"testing\"\n)\n\nfunc TestPeekDrain(t *testing.T) {\n\ta := autoDecodeReadCloser{peek: []byte(\"test\")}\n\tp := make([]byte, 2)\n\tn, _ := a.peekDrain(p)\n\ttests.AssertEqual(t, 2, n)\n\ttests.AssertEqual(t, true, a.peek != nil)\n\tn, _ = a.peekDrain(p)\n\ttests.AssertEqual(t, 2, n)\n\ttests.AssertEqual(t, true, a.peek == nil)\n}\n"
        },
        {
          "name": "digest.go",
          "type": "blob",
          "size": 6.5146484375,
          "content": "package req\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/imroc/req/v3/internal/header\"\n)\n\nvar (\n\terrDigestBadChallenge    = errors.New(\"digest: challenge is bad\")\n\terrDigestCharset         = errors.New(\"digest: unsupported charset\")\n\terrDigestAlgNotSupported = errors.New(\"digest: algorithm is not supported\")\n\terrDigestQopNotSupported = errors.New(\"digest: no supported qop in list\")\n)\n\nvar hashFuncs = map[string]func() hash.Hash{\n\t\"\":                 md5.New,\n\t\"MD5\":              md5.New,\n\t\"MD5-sess\":         md5.New,\n\t\"SHA-256\":          sha256.New,\n\t\"SHA-256-sess\":     sha256.New,\n\t\"SHA-512-256\":      sha512.New,\n\t\"SHA-512-256-sess\": sha512.New,\n}\n\n// create response middleware for http digest authentication.\nfunc handleDigestAuthFunc(username, password string) ResponseMiddleware {\n\treturn func(client *Client, resp *Response) error {\n\t\tif resp.Err != nil || resp.StatusCode != http.StatusUnauthorized {\n\t\t\treturn nil\n\t\t}\n\t\tauth, err := createDigestAuth(resp.Response, username, password)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tr := resp.Request\n\t\treq := *r.RawRequest\n\t\tif req.Body != nil {\n\t\t\terr = parseRequestBody(client, r) // re-setup body\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif r.GetBody != nil {\n\t\t\t\tbody, err := r.GetBody()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treq.Body = body\n\t\t\t\treq.GetBody = r.GetBody\n\t\t\t}\n\t\t}\n\t\tif req.Header == nil {\n\t\t\treq.Header = make(http.Header)\n\t\t}\n\t\treq.Header.Set(header.Authorization, auth)\n\t\tresp.Response, err = client.GetTransport().RoundTrip(&req)\n\t\treturn err\n\t}\n}\n\nfunc createDigestAuth(resp *http.Response, username, password string) (auth string, err error) {\n\tchal := resp.Header.Get(header.WwwAuthenticate)\n\tif chal == \"\" {\n\t\treturn \"\", errDigestBadChallenge\n\t}\n\n\tc, err := parseChallenge(chal)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Form credentials based on the challenge\n\tcr := newCredentials(resp.Request.URL.RequestURI(), resp.Request.Method, username, password, c)\n\tauth, err = cr.authorize()\n\treturn\n}\n\nfunc newCredentials(digestURI, method, username, password string, c *challenge) *credentials {\n\treturn &credentials{\n\t\tusername:   username,\n\t\tuserhash:   c.userhash,\n\t\trealm:      c.realm,\n\t\tnonce:      c.nonce,\n\t\tdigestURI:  digestURI,\n\t\talgorithm:  c.algorithm,\n\t\tsessionAlg: strings.HasSuffix(c.algorithm, \"-sess\"),\n\t\topaque:     c.opaque,\n\t\tmessageQop: c.qop,\n\t\tnc:         0,\n\t\tmethod:     method,\n\t\tpassword:   password,\n\t}\n}\n\ntype challenge struct {\n\trealm     string\n\tdomain    string\n\tnonce     string\n\topaque    string\n\tstale     string\n\talgorithm string\n\tqop       string\n\tuserhash  string\n}\n\nfunc parseChallenge(input string) (*challenge, error) {\n\tconst ws = \" \\n\\r\\t\"\n\tconst qs = `\"`\n\ts := strings.Trim(input, ws)\n\tif !strings.HasPrefix(s, \"Digest \") {\n\t\treturn nil, errDigestBadChallenge\n\t}\n\ts = strings.Trim(s[7:], ws)\n\tsl := strings.Split(s, \",\")\n\tc := &challenge{}\n\tvar r []string\n\tfor i := range sl {\n\t\tr = strings.SplitN(strings.TrimSpace(sl[i]), \"=\", 2)\n\t\tif len(r) != 2 {\n\t\t\treturn nil, errDigestBadChallenge\n\t\t}\n\t\tswitch r[0] {\n\t\tcase \"realm\":\n\t\t\tc.realm = strings.Trim(r[1], qs)\n\t\tcase \"domain\":\n\t\t\tc.domain = strings.Trim(r[1], qs)\n\t\tcase \"nonce\":\n\t\t\tc.nonce = strings.Trim(r[1], qs)\n\t\tcase \"opaque\":\n\t\t\tc.opaque = strings.Trim(r[1], qs)\n\t\tcase \"stale\":\n\t\t\tc.stale = strings.Trim(r[1], qs)\n\t\tcase \"algorithm\":\n\t\t\tc.algorithm = strings.Trim(r[1], qs)\n\t\tcase \"qop\":\n\t\t\tc.qop = strings.Trim(r[1], qs)\n\t\tcase \"charset\":\n\t\t\tif strings.ToUpper(strings.Trim(r[1], qs)) != \"UTF-8\" {\n\t\t\t\treturn nil, errDigestCharset\n\t\t\t}\n\t\tcase \"userhash\":\n\t\t\tc.userhash = strings.Trim(r[1], qs)\n\t\tdefault:\n\t\t\treturn nil, errDigestBadChallenge\n\t\t}\n\t}\n\treturn c, nil\n}\n\ntype credentials struct {\n\tusername   string\n\tuserhash   string\n\trealm      string\n\tnonce      string\n\tdigestURI  string\n\talgorithm  string\n\tsessionAlg bool\n\tcNonce     string\n\topaque     string\n\tmessageQop string\n\tnc         int\n\tmethod     string\n\tpassword   string\n}\n\nfunc (c *credentials) authorize() (string, error) {\n\tif _, ok := hashFuncs[c.algorithm]; !ok {\n\t\treturn \"\", errDigestAlgNotSupported\n\t}\n\n\tif err := c.validateQop(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tresp, err := c.resp()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tsl := make([]string, 0, 10)\n\tif c.userhash == \"true\" {\n\t\t// RFC 7616 3.4.4\n\t\tc.username = c.h(fmt.Sprintf(\"%s:%s\", c.username, c.realm))\n\t\tsl = append(sl, fmt.Sprintf(`userhash=%s`, c.userhash))\n\t}\n\tsl = append(sl, fmt.Sprintf(`username=\"%s\"`, c.username))\n\tsl = append(sl, fmt.Sprintf(`realm=\"%s\"`, c.realm))\n\tsl = append(sl, fmt.Sprintf(`nonce=\"%s\"`, c.nonce))\n\tsl = append(sl, fmt.Sprintf(`uri=\"%s\"`, c.digestURI))\n\tsl = append(sl, fmt.Sprintf(`response=\"%s\"`, resp))\n\tsl = append(sl, fmt.Sprintf(`algorithm=%s`, c.algorithm))\n\tif c.opaque != \"\" {\n\t\tsl = append(sl, fmt.Sprintf(`opaque=\"%s\"`, c.opaque))\n\t}\n\tif c.messageQop != \"\" {\n\t\tsl = append(sl, fmt.Sprintf(\"qop=%s\", c.messageQop))\n\t\tsl = append(sl, fmt.Sprintf(\"nc=%08x\", c.nc))\n\t\tsl = append(sl, fmt.Sprintf(`cnonce=\"%s\"`, c.cNonce))\n\t}\n\n\treturn fmt.Sprintf(\"Digest %s\", strings.Join(sl, \", \")), nil\n}\n\nfunc (c *credentials) validateQop() error {\n\t// Currently only supporting auth quality of protection. TODO: add auth-int support\n\tif c.messageQop == \"\" {\n\t\treturn nil\n\t}\n\tpossibleQops := strings.Split(c.messageQop, \", \")\n\tvar authSupport bool\n\tfor _, qop := range possibleQops {\n\t\tif qop == \"auth\" {\n\t\t\tauthSupport = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !authSupport {\n\t\treturn errDigestQopNotSupported\n\t}\n\n\treturn nil\n}\n\nfunc (c *credentials) h(data string) string {\n\thfCtor := hashFuncs[c.algorithm]\n\thf := hfCtor()\n\t_, _ = hf.Write([]byte(data)) // Hash.Write never returns an error\n\treturn fmt.Sprintf(\"%x\", hf.Sum(nil))\n}\n\nfunc (c *credentials) resp() (string, error) {\n\tc.nc++\n\n\tb := make([]byte, 16)\n\t_, err := io.ReadFull(rand.Reader, b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tc.cNonce = fmt.Sprintf(\"%x\", b)[:32]\n\n\tha1 := c.ha1()\n\tha2 := c.ha2()\n\n\tif len(c.messageQop) == 0 {\n\t\treturn c.h(fmt.Sprintf(\"%s:%s:%s\", ha1, c.nonce, ha2)), nil\n\t}\n\treturn c.kd(ha1, fmt.Sprintf(\"%s:%08x:%s:%s:%s\",\n\t\tc.nonce, c.nc, c.cNonce, c.messageQop, ha2)), nil\n}\n\nfunc (c *credentials) kd(secret, data string) string {\n\treturn c.h(fmt.Sprintf(\"%s:%s\", secret, data))\n}\n\n// RFC 7616 3.4.2\nfunc (c *credentials) ha1() string {\n\tret := c.h(fmt.Sprintf(\"%s:%s:%s\", c.username, c.realm, c.password))\n\tif c.sessionAlg {\n\t\treturn c.h(fmt.Sprintf(\"%s:%s:%s\", ret, c.nonce, c.cNonce))\n\t}\n\n\treturn ret\n}\n\n// RFC 7616 3.4.3\nfunc (c *credentials) ha2() string {\n\t// currently no auth-int support\n\treturn c.h(fmt.Sprintf(\"%s:%s\", c.method, c.digestURI))\n}\n"
        },
        {
          "name": "dump.go",
          "type": "blob",
          "size": 2.6376953125,
          "content": "package req\n\nimport (\n\t\"github.com/imroc/req/v3/internal/dump\"\n\t\"io\"\n\t\"os\"\n)\n\n// DumpOptions controls the dump behavior.\ntype DumpOptions struct {\n\tOutput               io.Writer\n\tRequestOutput        io.Writer\n\tResponseOutput       io.Writer\n\tRequestHeaderOutput  io.Writer\n\tRequestBodyOutput    io.Writer\n\tResponseHeaderOutput io.Writer\n\tResponseBodyOutput   io.Writer\n\tRequestHeader        bool\n\tRequestBody          bool\n\tResponseHeader       bool\n\tResponseBody         bool\n\tAsync                bool\n}\n\n// Clone return a copy of DumpOptions\nfunc (do *DumpOptions) Clone() *DumpOptions {\n\tif do == nil {\n\t\treturn nil\n\t}\n\td := *do\n\treturn &d\n}\n\ntype dumpOptions struct {\n\t*DumpOptions\n}\n\nfunc (o dumpOptions) Output() io.Writer {\n\tif o.DumpOptions.Output == nil {\n\t\treturn os.Stdout\n\t}\n\treturn o.DumpOptions.Output\n}\n\nfunc (o dumpOptions) RequestHeaderOutput() io.Writer {\n\tif o.DumpOptions.RequestHeaderOutput != nil {\n\t\treturn o.DumpOptions.RequestHeaderOutput\n\t}\n\tif o.DumpOptions.RequestOutput != nil {\n\t\treturn o.DumpOptions.RequestOutput\n\t}\n\treturn o.Output()\n}\n\nfunc (o dumpOptions) RequestBodyOutput() io.Writer {\n\tif o.DumpOptions.RequestBodyOutput != nil {\n\t\treturn o.DumpOptions.RequestBodyOutput\n\t}\n\tif o.DumpOptions.RequestOutput != nil {\n\t\treturn o.DumpOptions.RequestOutput\n\t}\n\treturn o.Output()\n}\n\nfunc (o dumpOptions) ResponseHeaderOutput() io.Writer {\n\tif o.DumpOptions.ResponseHeaderOutput != nil {\n\t\treturn o.DumpOptions.ResponseHeaderOutput\n\t}\n\tif o.DumpOptions.ResponseOutput != nil {\n\t\treturn o.DumpOptions.ResponseOutput\n\t}\n\treturn o.Output()\n}\n\nfunc (o dumpOptions) ResponseBodyOutput() io.Writer {\n\tif o.DumpOptions.ResponseBodyOutput != nil {\n\t\treturn o.DumpOptions.ResponseBodyOutput\n\t}\n\tif o.DumpOptions.ResponseOutput != nil {\n\t\treturn o.DumpOptions.ResponseOutput\n\t}\n\treturn o.Output()\n}\n\nfunc (o dumpOptions) RequestHeader() bool {\n\treturn o.DumpOptions.RequestHeader\n}\n\nfunc (o dumpOptions) RequestBody() bool {\n\treturn o.DumpOptions.RequestBody\n}\n\nfunc (o dumpOptions) ResponseHeader() bool {\n\treturn o.DumpOptions.ResponseHeader\n}\n\nfunc (o dumpOptions) ResponseBody() bool {\n\treturn o.DumpOptions.ResponseBody\n}\n\nfunc (o dumpOptions) Async() bool {\n\treturn o.DumpOptions.Async\n}\n\nfunc (o dumpOptions) Clone() dump.Options {\n\treturn dumpOptions{o.DumpOptions.Clone()}\n}\n\nfunc newDefaultDumpOptions() *DumpOptions {\n\treturn &DumpOptions{\n\t\tOutput:         os.Stdout,\n\t\tRequestBody:    true,\n\t\tResponseBody:   true,\n\t\tResponseHeader: true,\n\t\tRequestHeader:  true,\n\t}\n}\n\nfunc newDumper(opt *DumpOptions) *dump.Dumper {\n\tif opt == nil {\n\t\topt = newDefaultDumpOptions()\n\t}\n\tif opt.Output == nil {\n\t\topt.Output = os.Stderr\n\t}\n\treturn dump.NewDumper(dumpOptions{opt})\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.90234375,
          "content": "module github.com/imroc/req/v3\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/andybalholm/brotli v1.1.1\n\tgithub.com/hashicorp/go-multierror v1.1.1\n\tgithub.com/klauspost/compress v1.17.11\n\tgithub.com/quic-go/qpack v0.5.1\n\tgithub.com/quic-go/quic-go v0.48.2\n\tgithub.com/refraction-networking/utls v1.6.7\n\tgolang.org/x/net v0.33.0\n\tgolang.org/x/text v0.21.0\n)\n\nrequire (\n\tgithub.com/cloudflare/circl v1.5.0 // indirect\n\tgithub.com/go-task/slim-sprig/v3 v3.0.0 // indirect\n\tgithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad // indirect\n\tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n\tgithub.com/onsi/ginkgo/v2 v2.22.0 // indirect\n\tgo.uber.org/mock v0.5.0 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/exp v0.0.0-20241215155358-4a5509556b9e // indirect\n\tgolang.org/x/mod v0.22.0 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/tools v0.28.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.1064453125,
          "content": "github.com/andybalholm/brotli v1.1.0 h1:eLKJA0d02Lf0mVpIDgYnqXcUn0GqVmEFny3VuID1U3M=\ngithub.com/andybalholm/brotli v1.1.0/go.mod h1:sms7XGricyQI9K10gOSf56VKKWS4oLer58Q+mhRPtnY=\ngithub.com/andybalholm/brotli v1.1.1 h1:PR2pgnyFznKEugtsUo0xLdDop5SKXd5Qf5ysW+7XdTA=\ngithub.com/andybalholm/brotli v1.1.1/go.mod h1:05ib4cKhjx3OQYUY22hTVd34Bc8upXjOLL2rKwwZBoA=\ngithub.com/cloudflare/circl v1.4.0 h1:BV7h5MgrktNzytKmWjpOtdYrf0lkkbF8YMlBGPhJQrY=\ngithub.com/cloudflare/circl v1.4.0/go.mod h1:PDRU+oXvdD7KCtgKxW95M5Z8BpSCJXQORiZFnBQS5QU=\ngithub.com/cloudflare/circl v1.5.0 h1:hxIWksrX6XN5a1L2TI/h53AGPhNHoUBo+TD1ms9+pys=\ngithub.com/cloudflare/circl v1.5.0/go.mod h1:uddAzsPgqdMAYatqJ0lsjX1oECcQLIlRpzZh3pJrofs=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 h1:tfuBGBXKqDEevZMzYi5KSi8KkcZtzBcTgAUUtapy0OI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20241203143554-1e3fdc7de467 h1:keEZFtbLJugfE0qHn+Ge1JCE71spzkchQobDf3mzS/4=\ngithub.com/google/pprof v0.0.0-20241203143554-1e3fdc7de467/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad h1:a6HEuzUHeKH6hwfN/ZoQgRgVIWFJljSWa/zetS2WTvg=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=\ngithub.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=\ngithub.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=\ngithub.com/klauspost/compress v1.17.9 h1:6KIumPrER1LHsvBVuDa0r5xaG0Es51mhhB9BQB2qeMA=\ngithub.com/klauspost/compress v1.17.9/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=\ngithub.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=\ngithub.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/onsi/ginkgo/v2 v2.22.0 h1:Yed107/8DjTr0lKCNt7Dn8yQ6ybuDRQoMGrNFKzMfHg=\ngithub.com/onsi/ginkgo/v2 v2.22.0/go.mod h1:7Du3c42kxCUegi0IImZ1wUQzMBVecgIHjR1C+NkhLQo=\ngithub.com/onsi/gomega v1.34.2 h1:pNCwDkzrsv7MS9kpaQvVb1aVLahQXyJ/Tv5oAZMI3i8=\ngithub.com/onsi/gomega v1.34.2/go.mod h1:v1xfxRgk0KIsG+QOdm7p8UosrOzPYRo60fd3B/1Dukc=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=\ngithub.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=\ngithub.com/quic-go/quic-go v0.48.2 h1:wsKXZPeGWpMpCGSWqOcqpW2wZYic/8T3aqiOID0/KWE=\ngithub.com/quic-go/quic-go v0.48.2/go.mod h1:yBgs3rWBOADpga7F+jJsb6Ybg1LSYiQvwWlLX+/6HMs=\ngithub.com/refraction-networking/utls v1.6.7 h1:zVJ7sP1dJx/WtVuITug3qYUq034cDq9B2MR1K67ULZM=\ngithub.com/refraction-networking/utls v1.6.7/go.mod h1:BC3O4vQzye5hqpmDTWUqi4P5DDhzJfkV1tdqtawQIH0=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/xyproto/randomstring v1.0.5/go.mod h1:rgmS5DeNXLivK7YprL0pY+lTuhNQW3iGxZ18UQApw/E=\ngo.uber.org/mock v0.5.0 h1:KAMbZvZPyBPWgD14IrIQ38QCyjwpvVVV6K/bHl1IwQU=\ngo.uber.org/mock v0.5.0/go.mod h1:ge71pBPLYDk7QIi1LupWxdAykm7KIEFchiOqd6z7qMM=\ngolang.org/x/crypto v0.29.0 h1:L5SG1JTTXupVV3n6sUqMTeWbjAyfPwoda2DLX8J8FrQ=\ngolang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f h1:XdNn9LlyWAhLVp6P/i8QYBW+hlyhrhei9uErw2B5GJo=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f/go.mod h1:D5SMRVC3C2/4+F/DB1wZsLRnSNimn2Sp/NPsCrsv8ak=\ngolang.org/x/exp v0.0.0-20241215155358-4a5509556b9e h1:4qufH0hlUYs6AO6XmZC3GqfDPGSXHVXUFR6OND+iJX4=\ngolang.org/x/exp v0.0.0-20241215155358-4a5509556b9e/go.mod h1:qj5a5QZpwLU2NLQudwIN5koi3beDhSAlJwa67PuM98c=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/net v0.32.0 h1:ZqPmj8Kzc+Y6e0+skZsuACbx+wzMgo5MQsJh9Qd6aYI=\ngolang.org/x/net v0.32.0/go.mod h1:CwU0IoeOlnQQWJ6ioyFrfRuomB8GKF6KbYXZVyeXNfs=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\ngolang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.27.0 h1:qEKojBykQkQ4EynWy4S8Weg69NumxKdn40Fce3uc/8o=\ngolang.org/x/tools v0.27.0/go.mod h1:sUi0ZgbwW9ZPAq26Ekut+weQPR5eIM6GQLQ1Yjm1H0Q=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\ngoogle.golang.org/protobuf v1.34.1 h1:9ddQBjfCyZPOHPUiPxpYESBLc+T8P3E+Vo4IbKZgFWg=\ngoogle.golang.org/protobuf v1.34.1/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "header.go",
          "type": "blob",
          "size": 3.0400390625,
          "content": "package req\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"golang.org/x/net/http/httpguts\"\n\n\t\"github.com/imroc/req/v3/internal/header\"\n)\n\nvar headerNewlineToSpace = strings.NewReplacer(\"\\n\", \" \", \"\\r\", \" \")\n\n// stringWriter implements WriteString on a Writer.\ntype stringWriter struct {\n\tw io.Writer\n}\n\nfunc (w stringWriter) WriteString(s string) (n int, err error) {\n\treturn w.w.Write([]byte(s))\n}\n\n// A headerSorter implements sort.Interface by sorting a []keyValues\n// by key. It's used as a pointer, so it can fit in a sort.Interface\n// interface value without allocation.\ntype headerSorter struct {\n\tkvs []header.KeyValues\n}\n\nfunc (s *headerSorter) Len() int           { return len(s.kvs) }\nfunc (s *headerSorter) Swap(i, j int)      { s.kvs[i], s.kvs[j] = s.kvs[j], s.kvs[i] }\nfunc (s *headerSorter) Less(i, j int) bool { return s.kvs[i].Key < s.kvs[j].Key }\n\nvar headerSorterPool = sync.Pool{\n\tNew: func() interface{} { return new(headerSorter) },\n}\n\n// get is like Get, but key must already be in CanonicalHeaderKey form.\nfunc headerGet(h http.Header, key string) string {\n\tif v := h[key]; len(v) > 0 {\n\t\treturn v[0]\n\t}\n\treturn \"\"\n}\n\n// has reports whether h has the provided key defined, even if it's\n// set to 0-length slice.\nfunc headerHas(h http.Header, key string) bool {\n\t_, ok := h[key]\n\treturn ok\n}\n\n// sortedKeyValues returns h's keys sorted in the returned kvs\n// slice. The headerSorter used to sort is also returned, for possible\n// return to headerSorterCache.\nfunc headerSortedKeyValues(h http.Header, exclude map[string]bool) (kvs []header.KeyValues, hs *headerSorter) {\n\ths = headerSorterPool.Get().(*headerSorter)\n\tif cap(hs.kvs) < len(h) {\n\t\ths.kvs = make([]header.KeyValues, 0, len(h))\n\t}\n\tkvs = hs.kvs[:0]\n\tfor k, vv := range h {\n\t\tif !exclude[k] {\n\t\t\tkvs = append(kvs, header.KeyValues{k, vv})\n\t\t}\n\t}\n\ths.kvs = kvs\n\tsort.Sort(hs)\n\treturn kvs, hs\n}\n\nfunc headerWrite(h http.Header, writeHeader func(key string, values ...string) error, sort bool) error {\n\treturn headerWriteSubset(h, nil, writeHeader, sort)\n}\n\nfunc headerWriteSubset(h http.Header, exclude map[string]bool, writeHeader func(key string, values ...string) error, sort bool) error {\n\tvar kvs []header.KeyValues\n\tvar hs *headerSorter\n\tif sort {\n\t\tkvs = make([]header.KeyValues, 0, len(h))\n\t\tfor k, v := range h {\n\t\t\tif !exclude[k] {\n\t\t\t\tkvs = append(kvs, header.KeyValues{k, v})\n\t\t\t}\n\t\t}\n\t} else {\n\t\tkvs, hs = headerSortedKeyValues(h, exclude)\n\t}\n\tfor _, kv := range kvs {\n\t\tif !httpguts.ValidHeaderFieldName(kv.Key) {\n\t\t\t// This could be an error. In the common case of\n\t\t\t// writing response headers, however, we have no good\n\t\t\t// way to provide the error back to the server\n\t\t\t// handler, so just drop invalid headers instead.\n\t\t\tcontinue\n\t\t}\n\t\tfor i, v := range kv.Values {\n\t\t\tvv := headerNewlineToSpace.Replace(v)\n\t\t\tvv = textproto.TrimString(vv)\n\t\t\tif vv != v {\n\t\t\t\tkv.Values[i] = vv\n\t\t\t}\n\t\t}\n\t\terr := writeHeader(kv.Key, kv.Values...)\n\t\tif err != nil {\n\t\t\tif hs != nil {\n\t\t\t\theaderSorterPool.Put(hs)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\tif hs != nil {\n\t\theaderSorterPool.Put(hs)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 6.2353515625,
          "content": "package req\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"strings\"\n\n\t\"github.com/imroc/req/v3/internal/ascii\"\n\t\"golang.org/x/net/http/httpguts\"\n\t\"golang.org/x/net/idna\"\n)\n\n// maxInt64 is the effective \"infinite\" value for the Server and\n// Transport's byte-limiting readers.\nconst maxInt64 = 1<<63 - 1\n\n// incomparable is a zero-width, non-comparable type. Adding it to a struct\n// makes that struct also non-comparable, and generally doesn't add\n// any size (as long as it's first).\ntype incomparable [0]func()\n\n// bodyIsWritable reports whether the Body supports writing. The\n// Transport returns Writable bodies for 101 Switching Protocols\n// responses.\n// The Transport uses this method to determine whether a persistent\n// connection is done being managed from its perspective. Once we\n// return a writable response body to a user, the net/http package is\n// done managing that connection.\nfunc bodyIsWritable(r *http.Response) bool {\n\t_, ok := r.Body.(io.Writer)\n\treturn ok\n}\n\n// isProtocolSwitch reports whether the response code and header\n// indicate a successful protocol upgrade response.\nfunc isProtocolSwitch(r *http.Response) bool {\n\treturn isProtocolSwitchResponse(r.StatusCode, r.Header)\n}\n\n// isProtocolSwitchResponse reports whether the response code and\n// response header indicate a successful protocol upgrade response.\nfunc isProtocolSwitchResponse(code int, h http.Header) bool {\n\treturn code == http.StatusSwitchingProtocols && isProtocolSwitchHeader(h)\n}\n\n// isProtocolSwitchHeader reports whether the request or response header\n// is for a protocol switch.\nfunc isProtocolSwitchHeader(h http.Header) bool {\n\treturn h.Get(\"Upgrade\") != \"\" &&\n\t\thttpguts.HeaderValuesContainsToken(h[\"Connection\"], \"Upgrade\")\n}\n\n// NoBody is an io.ReadCloser with no bytes. Read always returns EOF\n// and Close always returns nil. It can be used in an outgoing client\n// request to explicitly signal that a request has zero bytes.\n// An alternative, however, is to simply set Request.Body to nil.\nvar NoBody = noBody{}\n\ntype noBody struct{}\n\nfunc (noBody) Read([]byte) (int, error)         { return 0, io.EOF }\nfunc (noBody) Close() error                     { return nil }\nfunc (noBody) WriteTo(io.Writer) (int64, error) { return 0, nil }\n\nvar (\n\t// verify that an io.Copy from NoBody won't require a buffer:\n\t_ io.WriterTo   = NoBody\n\t_ io.ReadCloser = NoBody\n)\n\ntype readResult struct {\n\t_   incomparable\n\tn   int\n\terr error\n\tb   byte // byte read, if n == 1\n}\n\n// hasToken reports whether token appears with v, ASCII\n// case-insensitive, with space or comma boundaries.\n// token must be all lowercase.\n// v may contain mixed cased.\nfunc hasToken(v, token string) bool {\n\tif len(token) > len(v) || token == \"\" {\n\t\treturn false\n\t}\n\tif v == token {\n\t\treturn true\n\t}\n\tfor sp := 0; sp <= len(v)-len(token); sp++ {\n\t\t// Check that first character is good.\n\t\t// The token is ASCII, so checking only a single byte\n\t\t// is sufficient. We skip this potential starting\n\t\t// position if both the first byte and its potential\n\t\t// ASCII uppercase equivalent (b|0x20) don't match.\n\t\t// False positives ('^' => '~') are caught by EqualFold.\n\t\tif b := v[sp]; b != token[0] && b|0x20 != token[0] {\n\t\t\tcontinue\n\t\t}\n\t\t// Check that start pos is on a valid token boundary.\n\t\tif sp > 0 && !isTokenBoundary(v[sp-1]) {\n\t\t\tcontinue\n\t\t}\n\t\t// Check that end pos is on a valid token boundary.\n\t\tif endPos := sp + len(token); endPos != len(v) && !isTokenBoundary(v[endPos]) {\n\t\t\tcontinue\n\t\t}\n\t\tif ascii.EqualFold(v[sp:sp+len(token)], token) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isTokenBoundary(b byte) bool {\n\treturn b == ' ' || b == ',' || b == '\\t'\n}\n\nfunc badStringError(what, val string) error { return fmt.Errorf(\"%s %q\", what, val) }\n\n// foreachHeaderElement splits v according to the \"#rule\" construction\n// in RFC 7230 section 7 and calls fn for each non-empty element.\nfunc foreachHeaderElement(v string, fn func(string)) {\n\tv = textproto.TrimString(v)\n\tif v == \"\" {\n\t\treturn\n\t}\n\tif !strings.Contains(v, \",\") {\n\t\tfn(v)\n\t\treturn\n\t}\n\tfor _, f := range strings.Split(v, \",\") {\n\t\tif f = textproto.TrimString(f); f != \"\" {\n\t\t\tfn(f)\n\t\t}\n\t}\n}\n\n// maxPostHandlerReadBytes is the max number of Request.Body bytes not\n// consumed by a handler that the server will read from the client\n// in order to keep a connection alive. If there are more bytes than\n// this then the server to be paranoid instead sends a \"Connection:\n// close\" response.\n//\n// This number is approximately what a typical machine's TCP buffer\n// size is anyway.  (if we have the bytes on the machine, we might as\n// well read them)\nconst maxPostHandlerReadBytes = 256 << 10\n\nfunc idnaASCII(v string) (string, error) {\n\t// TODO: Consider removing this check after verifying performance is okay.\n\t// Right now punycode verification, length checks, context checks, and the\n\t// permissible character tests are all omitted. It also prevents the ToASCII\n\t// call from salvaging an invalid IDN, when possible. As a result it may be\n\t// possible to have two IDNs that appear identical to the user where the\n\t// ASCII-only version causes an error downstream whereas the non-ASCII\n\t// version does not.\n\t// Note that for correct ASCII IDNs ToASCII will only do considerably more\n\t// work, but it will not cause an allocation.\n\tif ascii.Is(v) {\n\t\treturn v, nil\n\t}\n\treturn idna.Lookup.ToASCII(v)\n}\n\n// removeZone removes IPv6 zone identifier from host.\n// E.g., \"[fe80::1%en0]:8080\" to \"[fe80::1]:8080\"\nfunc removeZone(host string) string {\n\tif !strings.HasPrefix(host, \"[\") {\n\t\treturn host\n\t}\n\ti := strings.LastIndex(host, \"]\")\n\tif i < 0 {\n\t\treturn host\n\t}\n\tj := strings.LastIndex(host[:i], \"%\")\n\tif j < 0 {\n\t\treturn host\n\t}\n\treturn host[:j] + host[i:]\n}\n\n// stringContainsCTLByte reports whether s contains any ASCII control character.\nfunc stringContainsCTLByte(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tb := s[i]\n\t\tif b < ' ' || b == 0x7f {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// See 2 (end of page 4) https://www.ietf.org/rfc/rfc2617.txt\n// \"To receive authorization, the client sends the userid and password,\n// separated by a single colon (\":\") character, within a base64\n// encoded string in the credentials.\"\n// It is not meant to be urlencoded.\nfunc basicAuth(username, password string) string {\n\tauth := username + \":\" + password\n\treturn base64.StdEncoding.EncodeToString([]byte(auth))\n}\n"
        },
        {
          "name": "http2",
          "type": "tree",
          "content": null
        },
        {
          "name": "http_request.go",
          "type": "blob",
          "size": 4.3984375,
          "content": "package req\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"golang.org/x/net/http/httpguts\"\n\n\t\"github.com/imroc/req/v3/internal/ascii\"\n\t\"github.com/imroc/req/v3/internal/header\"\n)\n\n// Given a string of the form \"host\", \"host:port\", or \"[ipv6::address]:port\",\n// return true if the string includes a port.\nfunc hasPort(s string) bool { return strings.LastIndex(s, \":\") > strings.LastIndex(s, \"]\") }\n\n// removeEmptyPort strips the empty port in \":port\" to \"\"\n// as mandated by RFC 3986 Section 6.2.3.\nfunc removeEmptyPort(host string) string {\n\tif hasPort(host) {\n\t\treturn strings.TrimSuffix(host, \":\")\n\t}\n\treturn host\n}\n\nfunc isNotToken(r rune) bool {\n\treturn !httpguts.IsTokenRune(r)\n}\n\nfunc validMethod(method string) bool {\n\t/*\n\t     Method         = \"OPTIONS\"                ; Section 9.2\n\t                    | \"GET\"                    ; Section 9.3\n\t                    | \"HEAD\"                   ; Section 9.4\n\t                    | \"POST\"                   ; Section 9.5\n\t                    | \"PUT\"                    ; Section 9.6\n\t                    | \"DELETE\"                 ; Section 9.7\n\t                    | \"TRACE\"                  ; Section 9.8\n\t                    | \"CONNECT\"                ; Section 9.9\n\t                    | extension-method\n\t   extension-method = token\n\t     token          = 1*<any CHAR except CTLs or separators>\n\t*/\n\treturn len(method) > 0 && strings.IndexFunc(method, isNotToken) == -1\n}\n\nfunc closeBody(r *http.Request) error {\n\tif r.Body == nil {\n\t\treturn nil\n\t}\n\treturn r.Body.Close()\n}\n\n// requestBodyReadError wraps an error from (*Request).write to indicate\n// that the error came from a Read call on the Request.Body.\n// This error type should not escape the net/http package to users.\ntype requestBodyReadError struct{ error }\n\n// Return value if nonempty, def otherwise.\nfunc valueOrDefault(value, def string) string {\n\tif value != \"\" {\n\t\treturn value\n\t}\n\treturn def\n}\n\n// outgoingLength reports the Content-Length of this outgoing (Client) request.\n// It maps 0 into -1 (unknown) when the Body is non-nil.\nfunc outgoingLength(r *http.Request) int64 {\n\tif r.Body == nil || r.Body == NoBody {\n\t\treturn 0\n\t}\n\tif r.ContentLength != 0 {\n\t\treturn r.ContentLength\n\t}\n\treturn -1\n}\n\n// errMissingHost is returned by Write when there is no Host or URL present in\n// the Request.\nvar errMissingHost = errors.New(\"http: Request.Write on Request with no Host or URL set\")\n\nfunc closeRequestBody(r *http.Request) error {\n\tif r.Body == nil {\n\t\treturn nil\n\t}\n\treturn r.Body.Close()\n}\n\n// Headers that Request.Write handles itself and should be skipped.\nvar reqWriteExcludeHeader = map[string]bool{\n\t\"Host\":                     true, // not in Header map anyway\n\t\"User-Agent\":               true,\n\t\"Content-Length\":           true,\n\t\"Transfer-Encoding\":        true,\n\t\"Trailer\":                  true,\n\theader.HeaderOderKey:       true,\n\theader.PseudoHeaderOderKey: true,\n}\n\n// requestMethodUsuallyLacksBody reports whether the given request\n// method is one that typically does not involve a request body.\n// This is used by the Transport (via\n// transferWriter.shouldSendChunkedRequestBody) to determine whether\n// we try to test-read a byte from a non-nil Request.Body when\n// Request.outgoingLength() returns -1. See the comments in\n// shouldSendChunkedRequestBody.\nfunc requestMethodUsuallyLacksBody(method string) bool {\n\tswitch method {\n\tcase \"GET\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"PROPFIND\", \"SEARCH\":\n\t\treturn true\n\t}\n\treturn false\n}\n\n// requiresHTTP1 reports whether this request requires being sent on\n// an HTTP/1 connection.\nfunc requestRequiresHTTP1(r *http.Request) bool {\n\treturn hasToken(r.Header.Get(\"Connection\"), \"upgrade\") &&\n\t\tascii.EqualFold(r.Header.Get(\"Upgrade\"), \"websocket\")\n}\n\nfunc isReplayable(r *http.Request) bool {\n\tif r.Body == nil || r.Body == NoBody || r.GetBody != nil {\n\t\tswitch valueOrDefault(r.Method, \"GET\") {\n\t\tcase \"GET\", \"HEAD\", \"OPTIONS\", \"TRACE\":\n\t\t\treturn true\n\t\t}\n\t\t// The Idempotency-Key, while non-standard, is widely used to\n\t\t// mean a POST or other request is idempotent. See\n\t\t// https://golang.org/issue/19943#issuecomment-421092421\n\t\tif headerHas(r.Header, \"Idempotency-Key\") || headerHas(r.Header, \"X-Idempotency-Key\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc reqExpectsContinue(r *http.Request) bool {\n\treturn hasToken(headerGet(r.Header, \"Expect\"), \"100-continue\")\n}\n\nfunc reqWantsClose(r *http.Request) bool {\n\tif r.Close {\n\t\treturn true\n\t}\n\treturn hasToken(headerGet(r.Header, \"Connection\"), \"close\")\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 1.380859375,
          "content": "package req\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\n// Logger is the abstract logging interface, gives control to\n// the Req users, choice of the logger.\ntype Logger interface {\n\tErrorf(format string, v ...interface{})\n\tWarnf(format string, v ...interface{})\n\tDebugf(format string, v ...interface{})\n}\n\n// NewLogger create a Logger wraps the *log.Logger\nfunc NewLogger(output io.Writer, prefix string, flag int) Logger {\n\treturn &logger{l: log.New(output, prefix, flag)}\n}\n\nfunc NewLoggerFromStandardLogger(l *log.Logger) Logger {\n\treturn &logger{l: l}\n}\n\nfunc createDefaultLogger() Logger {\n\treturn NewLogger(os.Stdout, \"\", log.Ldate|log.Lmicroseconds)\n}\n\nvar _ Logger = (*logger)(nil)\n\ntype disableLogger struct{}\n\nfunc (l *disableLogger) Errorf(format string, v ...interface{}) {}\nfunc (l *disableLogger) Warnf(format string, v ...interface{})  {}\nfunc (l *disableLogger) Debugf(format string, v ...interface{}) {}\n\ntype logger struct {\n\tl *log.Logger\n}\n\nfunc (l *logger) Errorf(format string, v ...interface{}) {\n\tl.output(\"ERROR\", format, v...)\n}\n\nfunc (l *logger) Warnf(format string, v ...interface{}) {\n\tl.output(\"WARN\", format, v...)\n}\n\nfunc (l *logger) Debugf(format string, v ...interface{}) {\n\tl.output(\"DEBUG\", format, v...)\n}\n\nfunc (l *logger) output(level, format string, v ...interface{}) {\n\tformat = level + \" [req] \" + format\n\tif len(v) == 0 {\n\t\tl.l.Print(format)\n\t\treturn\n\t}\n\tl.l.Printf(format, v...)\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 0.7509765625,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/imroc/req/v3/internal/tests\"\n)\n\nfunc TestLogger(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tl := NewLogger(buf, \"\", log.Ldate|log.Lmicroseconds)\n\tc := tc().SetLogger(l)\n\tc.SetProxyURL(\":=\\\\<>ksfj&*&sf\")\n\ttests.AssertContains(t, buf.String(), \"error\", true)\n\tbuf.Reset()\n\tc.R().SetOutput(nil)\n\ttests.AssertContains(t, buf.String(), \"warn\", true)\n}\n\nfunc TestLoggerFromStandardLogger(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tl := NewLoggerFromStandardLogger(log.New(buf, \"\", log.Ldate|log.Lmicroseconds))\n\tc := tc().SetLogger(l)\n\tc.SetProxyURL(\":=\\\\<>ksfj&*&sf\")\n\ttests.AssertContains(t, buf.String(), \"error\", true)\n\tbuf.Reset()\n\tc.R().SetOutput(nil)\n\ttests.AssertContains(t, buf.String(), \"warn\", true)\n}\n"
        },
        {
          "name": "middleware.go",
          "type": "blob",
          "size": 11.6767578125,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/util\"\n)\n\ntype (\n\t// RequestMiddleware type is for request middleware, called before a request is sent\n\tRequestMiddleware func(client *Client, req *Request) error\n\n\t// ResponseMiddleware type is for response middleware, called after a response has been received\n\tResponseMiddleware func(client *Client, resp *Response) error\n)\n\nfunc createMultipartHeader(file *FileUpload, contentType string) textproto.MIMEHeader {\n\thdr := make(textproto.MIMEHeader)\n\n\tcontentDispositionValue := \"form-data\"\n\tcd := new(ContentDisposition)\n\tif file.ParamName != \"\" {\n\t\tcd.Add(\"name\", file.ParamName)\n\t}\n\tif file.FileName != \"\" {\n\t\tcd.Add(\"filename\", file.FileName)\n\t}\n\tif file.ExtraContentDisposition != nil {\n\t\tfor _, kv := range file.ExtraContentDisposition.kv {\n\t\t\tcd.Add(kv.Key, kv.Value)\n\t\t}\n\t}\n\tif c := cd.string(); c != \"\" {\n\t\tcontentDispositionValue += c\n\t}\n\thdr.Set(\"Content-Disposition\", contentDispositionValue)\n\n\tif !util.IsStringEmpty(contentType) {\n\t\thdr.Set(header.ContentType, contentType)\n\t}\n\treturn hdr\n}\n\nfunc closeq(v interface{}) {\n\tif c, ok := v.(io.Closer); ok {\n\t\tc.Close()\n\t}\n}\n\nfunc writeMultipartFormFile(w *multipart.Writer, file *FileUpload, r *Request) error {\n\tcontent, err := file.GetFileContent()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer content.Close()\n\tif r.RetryAttempt > 0 { // reset file reader when retry a multipart file upload\n\t\tif rs, ok := content.(io.ReadSeeker); ok {\n\t\t\t_, err = rs.Seek(0, io.SeekStart)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\t// Auto detect actual multipart content type\n\tcbuf := make([]byte, 512)\n\tseeEOF := false\n\tlastTime := time.Now()\n\tsize, err := content.Read(cbuf)\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\tseeEOF = true\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tct := file.ContentType\n\tif ct == \"\" {\n\t\tct = http.DetectContentType(cbuf)\n\t}\n\tpw, err := w.CreatePart(createMultipartHeader(file, ct))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif r.forceChunkedEncoding && r.uploadCallback != nil {\n\t\tpw = &callbackWriter{\n\t\t\tWriter:    pw,\n\t\t\tlastTime:  lastTime,\n\t\t\tinterval:  r.uploadCallbackInterval,\n\t\t\ttotalSize: file.FileSize,\n\t\t\tcallback: func(written int64) {\n\t\t\t\tr.uploadCallback(UploadInfo{\n\t\t\t\t\tParamName:    file.ParamName,\n\t\t\t\t\tFileName:     file.FileName,\n\t\t\t\t\tFileSize:     file.FileSize,\n\t\t\t\t\tUploadedSize: written,\n\t\t\t\t})\n\t\t\t},\n\t\t}\n\t}\n\n\tif _, err = pw.Write(cbuf[:size]); err != nil {\n\t\treturn err\n\t}\n\tif seeEOF {\n\t\treturn nil\n\t}\n\n\t_, err = io.Copy(pw, content)\n\treturn err\n}\n\nfunc writeMultiPart(r *Request, w *multipart.Writer) {\n\tdefer w.Close() // close multipart to write tailer boundary\n\tif len(r.FormData) > 0 {\n\t\tfor k, vs := range r.FormData {\n\t\t\tfor _, v := range vs {\n\t\t\t\tw.WriteField(k, v)\n\t\t\t}\n\t\t}\n\t} else if len(r.OrderedFormData) > 0 {\n\t\tif len(r.OrderedFormData)%2 != 0 {\n\t\t\tr.error = errBadOrderedFormData\n\t\t\treturn\n\t\t}\n\t\tmaxIndex := len(r.OrderedFormData) - 2\n\t\tfor i := 0; i <= maxIndex; i += 2 {\n\t\t\tkey := r.OrderedFormData[i]\n\t\t\tvalue := r.OrderedFormData[i+1]\n\t\t\tw.WriteField(key, value)\n\t\t}\n\t}\n\tfor _, file := range r.uploadFiles {\n\t\twriteMultipartFormFile(w, file, r)\n\t}\n}\n\nfunc handleMultiPart(c *Client, r *Request) (err error) {\n\tvar b string\n\tif c.multipartBoundaryFunc != nil {\n\t\tb = c.multipartBoundaryFunc()\n\t}\n\n\tif r.forceChunkedEncoding {\n\t\tpr, pw := io.Pipe()\n\t\tr.GetBody = func() (io.ReadCloser, error) {\n\t\t\treturn pr, nil\n\t\t}\n\t\tw := multipart.NewWriter(pw)\n\t\tif len(b) > 0 {\n\t\t\tw.SetBoundary(b)\n\t\t}\n\t\tr.SetContentType(w.FormDataContentType())\n\t\tgo func() {\n\t\t\twriteMultiPart(r, w)\n\t\t\tpw.Close() // close pipe writer so that pipe reader could get EOF, and stop upload\n\t\t}()\n\t} else {\n\t\tbuf := new(bytes.Buffer)\n\t\tw := multipart.NewWriter(buf)\n\t\tif len(b) > 0 {\n\t\t\tw.SetBoundary(b)\n\t\t}\n\t\twriteMultiPart(r, w)\n\t\tr.GetBody = func() (io.ReadCloser, error) {\n\t\t\treturn io.NopCloser(bytes.NewReader(buf.Bytes())), nil\n\t\t}\n\t\tr.Body = buf.Bytes()\n\t\tr.SetContentType(w.FormDataContentType())\n\t}\n\treturn\n}\n\nfunc handleFormData(r *Request) {\n\tr.SetContentType(header.FormContentType)\n\tr.SetBodyBytes([]byte(r.FormData.Encode()))\n}\n\nvar errBadOrderedFormData = errors.New(\"bad ordered form data, the number of key-value pairs should be an even number\")\n\nfunc handleOrderedFormData(r *Request) {\n\tr.SetContentType(header.FormContentType)\n\tif len(r.OrderedFormData)%2 != 0 {\n\t\tr.error = errBadOrderedFormData\n\t\treturn\n\t}\n\tmaxIndex := len(r.OrderedFormData) - 2\n\tvar buf strings.Builder\n\tfor i := 0; i <= maxIndex; i += 2 {\n\t\tkey := r.OrderedFormData[i]\n\t\tvalue := r.OrderedFormData[i+1]\n\t\tif buf.Len() > 0 {\n\t\t\tbuf.WriteByte('&')\n\t\t}\n\t\tbuf.WriteString(url.QueryEscape(key))\n\t\tbuf.WriteByte('=')\n\t\tbuf.WriteString(url.QueryEscape(value))\n\t}\n\tr.SetBodyString(buf.String())\n}\n\nfunc handleMarshalBody(c *Client, r *Request) error {\n\tct := \"\"\n\tif r.Headers != nil {\n\t\tct = r.Headers.Get(header.ContentType)\n\t}\n\tif ct == \"\" {\n\t\tct = c.Headers.Get(header.ContentType)\n\t}\n\tif ct != \"\" {\n\t\tif util.IsXMLType(ct) {\n\t\t\tbody, err := c.xmlMarshal(r.marshalBody)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tr.SetBodyBytes(body)\n\t\t} else {\n\t\t\tbody, err := c.jsonMarshal(r.marshalBody)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tr.SetBodyBytes(body)\n\t\t}\n\t\treturn nil\n\t}\n\tbody, err := c.jsonMarshal(r.marshalBody)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr.SetBodyJsonBytes(body)\n\treturn nil\n}\n\nfunc parseRequestBody(c *Client, r *Request) (err error) {\n\tif c.isPayloadForbid(r.Method) {\n\t\tr.marshalBody = nil\n\t\tr.Body = nil\n\t\tr.GetBody = nil\n\t\treturn\n\t}\n\t// handle multipart\n\tif r.isMultiPart {\n\t\treturn handleMultiPart(c, r)\n\t}\n\n\t// handle form data\n\tif len(c.FormData) > 0 {\n\t\tr.SetFormDataFromValues(c.FormData)\n\t}\n\n\tif len(r.FormData) > 0 {\n\t\thandleFormData(r)\n\t\treturn\n\t} else if len(r.OrderedFormData) > 0 {\n\t\thandleOrderedFormData(r)\n\t\treturn\n\t}\n\n\t// handle marshal body\n\tif r.marshalBody != nil {\n\t\terr = handleMarshalBody(c, r)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif r.Body == nil {\n\t\treturn\n\t}\n\t// body is in-memory []byte, so we can guess content type\n\n\tif c.Headers != nil && c.Headers.Get(header.ContentType) != \"\" { // ignore if content type set at client-level\n\t\treturn\n\t}\n\tif r.getHeader(header.ContentType) != \"\" { // ignore if content-type set at request-level\n\t\treturn\n\t}\n\tr.SetContentType(http.DetectContentType(r.Body))\n\treturn\n}\n\nfunc unmarshalBody(c *Client, r *Response, v interface{}) (err error) {\n\tbody, err := r.ToBytes() // in case req.SetResult or req.SetError with cient.DisalbeAutoReadResponse(true)\n\tif err != nil {\n\t\treturn\n\t}\n\tct := r.GetContentType()\n\tif util.IsJSONType(ct) {\n\t\treturn c.jsonUnmarshal(body, v)\n\t} else if util.IsXMLType(ct) {\n\t\treturn c.xmlUnmarshal(body, v)\n\t} else {\n\t\tif c.DebugLog {\n\t\t\tc.log.Debugf(\"cannot determine the unmarshal function with %q Content-Type, default to json\", ct)\n\t\t}\n\t\treturn c.jsonUnmarshal(body, v)\n\t}\n}\n\nfunc defaultResultStateChecker(resp *Response) ResultState {\n\tif code := resp.StatusCode; code > 199 && code < 300 {\n\t\treturn SuccessState\n\t} else if code > 399 {\n\t\treturn ErrorState\n\t} else {\n\t\treturn UnknownState\n\t}\n}\n\nfunc parseResponseBody(c *Client, r *Response) (err error) {\n\tif r.Response == nil {\n\t\treturn\n\t}\n\treq := r.Request\n\tswitch r.ResultState() {\n\tcase SuccessState:\n\t\tif req.Result != nil && r.StatusCode != http.StatusNoContent {\n\t\t\terr = unmarshalBody(c, r, r.Request.Result)\n\t\t\tif err == nil {\n\t\t\t\tr.result = r.Request.Result\n\t\t\t}\n\t\t}\n\tcase ErrorState:\n\t\tif r.StatusCode == http.StatusNoContent {\n\t\t\treturn\n\t\t}\n\t\tif req.Error != nil {\n\t\t\terr = unmarshalBody(c, r, req.Error)\n\t\t\tif err == nil {\n\t\t\t\tr.error = req.Error\n\t\t\t}\n\t\t} else if c.commonErrorType != nil {\n\t\t\te := reflect.New(c.commonErrorType).Interface()\n\t\t\terr = unmarshalBody(c, r, e)\n\t\t\tif err == nil {\n\t\t\t\tr.error = e\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\ntype callbackWriter struct {\n\tio.Writer\n\twritten   int64\n\ttotalSize int64\n\tlastTime  time.Time\n\tinterval  time.Duration\n\tcallback  func(written int64)\n}\n\nfunc (w *callbackWriter) Write(p []byte) (n int, err error) {\n\tn, err = w.Writer.Write(p)\n\tif n <= 0 {\n\t\treturn\n\t}\n\tw.written += int64(n)\n\tif w.written == w.totalSize {\n\t\tw.callback(w.written)\n\t} else if now := time.Now(); now.Sub(w.lastTime) >= w.interval {\n\t\tw.lastTime = now\n\t\tw.callback(w.written)\n\t}\n\treturn\n}\n\ntype callbackReader struct {\n\tio.ReadCloser\n\tread     int64\n\tlastRead int64\n\tcallback func(read int64)\n\tlastTime time.Time\n\tinterval time.Duration\n}\n\nfunc (r *callbackReader) Read(p []byte) (n int, err error) {\n\tn, err = r.ReadCloser.Read(p)\n\tif n <= 0 {\n\t\tif err == io.EOF && r.read > r.lastRead {\n\t\t\tr.callback(r.read)\n\t\t\tr.lastRead = r.read\n\t\t}\n\t\treturn\n\t}\n\tr.read += int64(n)\n\tif err == io.EOF {\n\t\tr.callback(r.read)\n\t\tr.lastRead = r.read\n\t} else if now := time.Now(); now.Sub(r.lastTime) >= r.interval {\n\t\tr.lastTime = now\n\t\tr.callback(r.read)\n\t\tr.lastRead = r.read\n\t}\n\treturn\n}\n\nfunc handleDownload(c *Client, r *Response) (err error) {\n\tif r.Response == nil || !r.Request.isSaveResponse {\n\t\treturn nil\n\t}\n\tvar body io.ReadCloser\n\n\tif r.body != nil { // already read\n\t\tbody = io.NopCloser(bytes.NewReader(r.body))\n\t} else {\n\t\tbody = r.Body\n\t}\n\n\tvar output io.Writer\n\tif r.Request.outputFile != \"\" {\n\t\tfile := r.Request.outputFile\n\t\tif c.outputDirectory != \"\" && !filepath.IsAbs(file) {\n\t\t\tfile = c.outputDirectory + string(filepath.Separator) + file\n\t\t}\n\n\t\tfile = filepath.Clean(file)\n\n\t\tif err = util.CreateDirectory(filepath.Dir(file)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\toutput, err = os.Create(file)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t} else {\n\t\toutput = r.Request.output // must not nil\n\t}\n\n\tdefer func() {\n\t\tbody.Close()\n\t\tcloseq(output)\n\t}()\n\n\t_, err = io.Copy(output, body)\n\tr.setReceivedAt()\n\treturn\n}\n\n// generate URL\nfunc parseRequestURL(c *Client, r *Request) error {\n\ttempURL := r.RawURL\n\tif len(r.PathParams) > 0 {\n\t\tfor p, v := range r.PathParams {\n\t\t\ttempURL = strings.Replace(tempURL, \"{\"+p+\"}\", url.PathEscape(v), -1)\n\t\t}\n\t}\n\tif len(c.PathParams) > 0 {\n\t\tfor p, v := range c.PathParams {\n\t\t\ttempURL = strings.Replace(tempURL, \"{\"+p+\"}\", url.PathEscape(v), -1)\n\t\t}\n\t}\n\n\t// Parsing request URL\n\treqURL, err := url.Parse(tempURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif reqURL.Scheme == \"\" && len(c.scheme) > 0 { // set scheme if missing\n\t\treqURL, err = url.Parse(c.scheme + \"://\" + tempURL)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// If RawURL is relative path then added c.BaseURL into\n\t// the request URL otherwise Request.URL will be used as-is\n\tif !reqURL.IsAbs() {\n\t\ttempURL = reqURL.String()\n\t\tif len(tempURL) > 0 && tempURL[0] != '/' {\n\t\t\ttempURL = \"/\" + tempURL\n\t\t}\n\n\t\treqURL, err = url.Parse(c.BaseURL + tempURL)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Adding Query Param\n\tquery := make(url.Values)\n\tfor k, v := range c.QueryParams {\n\t\tfor _, iv := range v {\n\t\t\tquery.Add(k, iv)\n\t\t}\n\t}\n\n\tfor k, v := range r.QueryParams {\n\t\t// remove query param from client level by key\n\t\t// since overrides happens for that key in the request\n\t\tquery.Del(k)\n\n\t\tfor _, iv := range v {\n\t\t\tquery.Add(k, iv)\n\t\t}\n\t}\n\n\t// Preserve query string order partially.\n\t// Since not feasible in `SetQuery*` resty methods, because\n\t// standard package `url.Encode(...)` sorts the query params\n\t// alphabetically\n\tif len(query) > 0 {\n\t\tif util.IsStringEmpty(reqURL.RawQuery) {\n\t\t\treqURL.RawQuery = query.Encode()\n\t\t} else {\n\t\t\treqURL.RawQuery = reqURL.RawQuery + \"&\" + query.Encode()\n\t\t}\n\t}\n\n\treqURL.Host = removeEmptyPort(reqURL.Host)\n\tr.URL = reqURL\n\treturn nil\n}\n\nfunc parseRequestHeader(c *Client, r *Request) error {\n\tif c.Headers == nil {\n\t\treturn nil\n\t}\n\tif r.Headers == nil {\n\t\tr.Headers = make(http.Header)\n\t}\n\tfor k, vs := range c.Headers {\n\t\tif len(r.Headers[k]) == 0 {\n\t\t\tr.Headers[k] = vs\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseRequestCookie(c *Client, r *Request) error {\n\tif len(c.Cookies) > 0 || r.RetryAttempt <= 0 {\n\t\tr.Cookies = append(r.Cookies, c.Cookies...)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "parallel_download.go",
          "type": "blob",
          "size": 6.34765625,
          "content": "package req\n\nimport (\n\t\"context\"\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\turlpkg \"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n)\n\ntype ParallelDownload struct {\n\turl          string\n\tclient       *Client\n\tconcurrency  int\n\toutput       io.Writer\n\tfilename     string\n\tsegmentSize  int64\n\tperm         os.FileMode\n\ttempRootDir  string\n\ttempDir      string\n\ttaskCh       chan *downloadTask\n\tdoneCh       chan struct{}\n\twgDoneCh     chan struct{}\n\terrCh        chan error\n\twg           sync.WaitGroup\n\ttaskMap      map[int]*downloadTask\n\ttaskNotifyCh chan *downloadTask\n\tmu           sync.Mutex\n\tlastIndex    int\n}\n\nfunc (pd *ParallelDownload) completeTask(task *downloadTask) {\n\tpd.mu.Lock()\n\tpd.taskMap[task.index] = task\n\tpd.mu.Unlock()\n\tgo func() {\n\t\tselect {\n\t\tcase pd.taskNotifyCh <- task:\n\t\tcase <-pd.doneCh:\n\t\t}\n\t}()\n}\n\nfunc (pd *ParallelDownload) popTask(index int) *downloadTask {\n\tpd.mu.Lock()\n\tif task, ok := pd.taskMap[index]; ok {\n\t\tdelete(pd.taskMap, index)\n\t\tpd.mu.Unlock()\n\t\treturn task\n\t}\n\tpd.mu.Unlock()\n\tfor {\n\t\ttask := <-pd.taskNotifyCh\n\t\tif task.index == index {\n\t\t\tpd.mu.Lock()\n\t\t\tdelete(pd.taskMap, index)\n\t\t\tpd.mu.Unlock()\n\t\t\treturn task\n\t\t}\n\t}\n}\n\nfunc md5Sum(s string) string {\n\tsum := md5.Sum([]byte(s))\n\treturn hex.EncodeToString(sum[:])\n}\n\nfunc (pd *ParallelDownload) ensure() error {\n\tif pd.concurrency <= 0 {\n\t\tpd.concurrency = 5\n\t}\n\tif pd.segmentSize <= 0 {\n\t\tpd.segmentSize = 1073741824 // 10MB\n\t}\n\tif pd.perm == 0 {\n\t\tpd.perm = 0777\n\t}\n\tif pd.tempRootDir == \"\" {\n\t\tpd.tempRootDir = os.TempDir()\n\t}\n\tpd.tempDir = filepath.Join(pd.tempRootDir, md5Sum(pd.url))\n\tif pd.client.DebugLog {\n\t\tpd.client.log.Debugf(\"use temporary directory %s\", pd.tempDir)\n\t\tpd.client.log.Debugf(\"download with %d concurrency and %d bytes segment size\", pd.concurrency, pd.segmentSize)\n\t}\n\terr := os.MkdirAll(pd.tempDir, os.ModePerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpd.taskCh = make(chan *downloadTask)\n\tpd.doneCh = make(chan struct{})\n\tpd.wgDoneCh = make(chan struct{})\n\tpd.errCh = make(chan error)\n\tpd.taskMap = make(map[int]*downloadTask)\n\tpd.taskNotifyCh = make(chan *downloadTask)\n\treturn nil\n}\n\nfunc (pd *ParallelDownload) SetSegmentSize(segmentSize int64) *ParallelDownload {\n\tpd.segmentSize = segmentSize\n\treturn pd\n}\n\nfunc (pd *ParallelDownload) SetTempRootDir(tempRootDir string) *ParallelDownload {\n\tpd.tempRootDir = tempRootDir\n\treturn pd\n}\n\nfunc (pd *ParallelDownload) SetFileMode(perm os.FileMode) *ParallelDownload {\n\tpd.perm = perm\n\treturn pd\n}\n\nfunc (pd *ParallelDownload) SetConcurrency(concurrency int) *ParallelDownload {\n\tpd.concurrency = concurrency\n\treturn pd\n}\n\nfunc (pd *ParallelDownload) SetOutput(output io.Writer) *ParallelDownload {\n\tif output != nil {\n\t\tpd.output = output\n\t}\n\treturn pd\n}\n\nfunc (pd *ParallelDownload) SetOutputFile(filename string) *ParallelDownload {\n\tpd.filename = filename\n\treturn pd\n}\n\nfunc getRangeTempFile(rangeStart, rangeEnd int64, workerDir string) string {\n\treturn filepath.Join(workerDir, fmt.Sprintf(\"temp-%d-%d\", rangeStart, rangeEnd))\n}\n\ntype downloadTask struct {\n\tindex                int\n\trangeStart, rangeEnd int64\n\ttempFilename         string\n\ttempFile             *os.File\n}\n\nfunc (pd *ParallelDownload) handleTask(t *downloadTask, ctx ...context.Context) {\n\tpd.wg.Add(1)\n\tdefer pd.wg.Done()\n\tt.tempFilename = getRangeTempFile(t.rangeStart, t.rangeEnd, pd.tempDir)\n\tif pd.client.DebugLog {\n\t\tpd.client.log.Debugf(\"downloading segment %d-%d\", t.rangeStart, t.rangeEnd)\n\t}\n\tfile, err := os.OpenFile(t.tempFilename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\tpd.errCh <- err\n\t\treturn\n\t}\n\terr = pd.client.Get(pd.url).\n\t\tSetHeader(\"Range\", fmt.Sprintf(\"bytes=%d-%d\", t.rangeStart, t.rangeEnd)).\n\t\tSetOutput(file).\n\t\tDo(ctx...).Err\n\n\tif err != nil {\n\t\tpd.errCh <- err\n\t\treturn\n\t}\n\tt.tempFile = file\n\tpd.completeTask(t)\n}\n\nfunc (pd *ParallelDownload) startWorker(ctx ...context.Context) {\n\tfor {\n\t\tselect {\n\t\tcase t := <-pd.taskCh:\n\t\t\tpd.handleTask(t, ctx...)\n\t\tcase <-pd.doneCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (pd *ParallelDownload) mergeFile() {\n\tdefer pd.wg.Done()\n\tfile, err := pd.getOutputFile()\n\tif err != nil {\n\t\tpd.errCh <- err\n\t\treturn\n\t}\n\tfor i := 0; ; i++ {\n\t\ttask := pd.popTask(i)\n\t\ttempFile, err := os.Open(task.tempFilename)\n\t\tif err != nil {\n\t\t\tpd.errCh <- err\n\t\t\treturn\n\t\t}\n\t\t_, err = io.Copy(file, tempFile)\n\t\ttempFile.Close()\n\t\tif err != nil {\n\t\t\tpd.errCh <- err\n\t\t\treturn\n\t\t}\n\t\tif i < pd.lastIndex {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\tif pd.client.DebugLog {\n\t\tpd.client.log.Debugf(\"removing temporary directory %s\", pd.tempDir)\n\t}\n\terr = os.RemoveAll(pd.tempDir)\n\tif err != nil {\n\t\tpd.errCh <- err\n\t}\n}\n\nfunc (pd *ParallelDownload) Do(ctx ...context.Context) error {\n\terr := pd.ensure()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < pd.concurrency; i++ {\n\t\tgo pd.startWorker(ctx...)\n\t}\n\tresp := pd.client.Head(pd.url).Do(ctx...)\n\tif resp.Err != nil {\n\t\treturn resp.Err\n\t}\n\tif resp.ContentLength <= 0 {\n\t\treturn fmt.Errorf(\"bad content length: %d\", resp.ContentLength)\n\t}\n\tpd.lastIndex = int(math.Ceil(float64(resp.ContentLength)/float64(pd.segmentSize))) - 1\n\tpd.wg.Add(1)\n\tgo pd.mergeFile()\n\tgo func() {\n\t\tpd.wg.Wait()\n\t\tclose(pd.wgDoneCh)\n\t}()\n\ttotalBytes := resp.ContentLength\n\tstart := int64(0)\n\tfor i := 0; ; i++ {\n\t\tend := start + (pd.segmentSize - 1)\n\t\tif end > (totalBytes - 1) {\n\t\t\tend = totalBytes - 1\n\t\t}\n\t\ttask := &downloadTask{\n\t\t\tindex:      i,\n\t\t\trangeStart: start,\n\t\t\trangeEnd:   end,\n\t\t}\n\t\tpd.taskCh <- task\n\t\tif end < (totalBytes - 1) {\n\t\t\tstart = end + 1\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\tselect {\n\tcase <-pd.wgDoneCh:\n\t\tif pd.client.DebugLog {\n\t\t\tif pd.filename != \"\" {\n\t\t\t\tpd.client.log.Debugf(\"download completed from %s to %s\", pd.url, pd.filename)\n\t\t\t} else {\n\t\t\t\tpd.client.log.Debugf(\"download completed for %s\", pd.url)\n\t\t\t}\n\t\t}\n\t\tclose(pd.doneCh)\n\tcase err := <-pd.errCh:\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (pd *ParallelDownload) getOutputFile() (io.Writer, error) {\n\toutputFile := pd.output\n\tif outputFile != nil {\n\t\treturn outputFile, nil\n\t}\n\tif pd.filename == \"\" {\n\t\tu, err := urlpkg.Parse(pd.url)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tpaths := strings.Split(u.Path, \"/\")\n\t\tfor i := len(paths) - 1; i > 0; i-- {\n\t\t\tif paths[i] != \"\" {\n\t\t\t\tpd.filename = paths[i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif pd.filename == \"\" {\n\t\t\tpd.filename = \"download\"\n\t\t}\n\t}\n\tif pd.client.outputDirectory != \"\" && !filepath.IsAbs(pd.filename) {\n\t\tpd.filename = filepath.Join(pd.client.outputDirectory, pd.filename)\n\t}\n\treturn os.OpenFile(pd.filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, pd.perm)\n}\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "redirect.go",
          "type": "blob",
          "size": 3.916015625,
          "content": "package req\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n// RedirectPolicy represents the redirect policy for Client.\ntype RedirectPolicy func(req *http.Request, via []*http.Request) error\n\n// MaxRedirectPolicy specifies the max number of redirect\nfunc MaxRedirectPolicy(noOfRedirect int) RedirectPolicy {\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\tif len(via) >= noOfRedirect {\n\t\t\treturn fmt.Errorf(\"stopped after %d redirects\", noOfRedirect)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// DefaultRedirectPolicy allows up to 10 redirects\nfunc DefaultRedirectPolicy() RedirectPolicy {\n\treturn MaxRedirectPolicy(10)\n}\n\n// NoRedirectPolicy disable redirect behaviour\nfunc NoRedirectPolicy() RedirectPolicy {\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\treturn http.ErrUseLastResponse\n\t}\n}\n\n// SameDomainRedirectPolicy allows redirect only if the redirected domain\n// is the same as original domain, e.g. redirect to \"www.imroc.cc\" from\n// \"imroc.cc\" is allowed, but redirect to \"google.com\" is not allowed.\nfunc SameDomainRedirectPolicy() RedirectPolicy {\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\tif getDomain(req.URL.Host) != getDomain(via[0].URL.Host) {\n\t\t\treturn errors.New(\"different domain name is not allowed\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// SameHostRedirectPolicy allows redirect only if the redirected host\n// is the same as original host, e.g. redirect to \"www.imroc.cc\" from\n// \"imroc.cc\" is not the allowed.\nfunc SameHostRedirectPolicy() RedirectPolicy {\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\tif getHostname(req.URL.Host) != getHostname(via[0].URL.Host) {\n\t\t\treturn errors.New(\"different host name is not allowed\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// AllowedHostRedirectPolicy allows redirect only if the redirected host\n// match one of the host that specified.\nfunc AllowedHostRedirectPolicy(hosts ...string) RedirectPolicy {\n\tm := make(map[string]struct{})\n\tfor _, h := range hosts {\n\t\tm[strings.ToLower(getHostname(h))] = struct{}{}\n\t}\n\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\th := getHostname(req.URL.Host)\n\t\tif _, ok := m[h]; !ok {\n\t\t\treturn fmt.Errorf(\"redirect host [%s] is not allowed\", h)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// AllowedDomainRedirectPolicy allows redirect only if the redirected domain\n// match one of the domain that specified.\nfunc AllowedDomainRedirectPolicy(hosts ...string) RedirectPolicy {\n\tdomains := make(map[string]struct{})\n\tfor _, h := range hosts {\n\t\tdomains[strings.ToLower(getDomain(h))] = struct{}{}\n\t}\n\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\tdomain := getDomain(req.URL.Host)\n\t\tif _, ok := domains[domain]; !ok {\n\t\t\treturn fmt.Errorf(\"redirect domain [%s] is not allowed\", domain)\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc getHostname(host string) (hostname string) {\n\tif strings.Index(host, \":\") > 0 {\n\t\thost, _, _ = net.SplitHostPort(host)\n\t}\n\thostname = strings.ToLower(host)\n\treturn\n}\n\nfunc getDomain(host string) string {\n\thost = getHostname(host)\n\tss := strings.Split(host, \".\")\n\tif len(ss) < 3 {\n\t\treturn host\n\t}\n\tss = ss[1:]\n\treturn strings.Join(ss, \".\")\n}\n\n// AlwaysCopyHeaderRedirectPolicy ensures that the given sensitive headers will\n// always be copied on redirect.\n// By default, golang will copy all of the original request's headers on redirect,\n// unless they're sensitive, like \"Authorization\" or \"Www-Authenticate\". Only send\n// sensitive ones to the same origin, or subdomains thereof (https://go-review.googlesource.com/c/go/+/28930/)\n// Check discussion: https://github.com/golang/go/issues/4800\n// For example:\n//\n//\tclient.SetRedirectPolicy(req.AlwaysCopyHeaderRedirectPolicy(\"Authorization\"))\nfunc AlwaysCopyHeaderRedirectPolicy(headers ...string) RedirectPolicy {\n\treturn func(req *http.Request, via []*http.Request) error {\n\t\tfor _, header := range headers {\n\t\t\tif len(req.Header.Values(header)) > 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvals := via[0].Header.Values(header)\n\t\t\tfor _, val := range vals {\n\t\t\t\treq.Header.Add(header, val)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "req.go",
          "type": "blob",
          "size": 2.736328125,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\ntype kv struct {\n\tKey   string\n\tValue string\n}\n\n// ContentDisposition represents parameters in `Content-Disposition`\n// MIME header of multipart request.\ntype ContentDisposition struct {\n\tkv []kv\n}\n\n// Add adds a new key-value pair of Content-Disposition\nfunc (c *ContentDisposition) Add(key, value string) *ContentDisposition {\n\tc.kv = append(c.kv, kv{Key: key, Value: value})\n\treturn c\n}\n\nfunc (c *ContentDisposition) string() string {\n\tif c == nil {\n\t\treturn \"\"\n\t}\n\ts := \"\"\n\tfor _, kv := range c.kv {\n\t\ts += fmt.Sprintf(\"; %s=%q\", kv.Key, kv.Value)\n\t}\n\treturn s\n}\n\n// FileUpload represents a \"form-data\" multipart\ntype FileUpload struct {\n\t// \"name\" parameter in `Content-Disposition`\n\tParamName string\n\t// \"filename\" parameter in `Content-Disposition`\n\tFileName string\n\t// The file to be uploaded.\n\tGetFileContent GetContentFunc\n\t// Optional file length in bytes.\n\tFileSize int64\n\t// Optional Content-Type\n\tContentType string\n\n\t// Optional extra ContentDisposition parameters.\n\t// According to the HTTP specification, this should be nil,\n\t// but some servers may not follow the specification and\n\t// requires `Content-Disposition` parameters more than just\n\t// \"name\" and \"filename\".\n\tExtraContentDisposition *ContentDisposition\n}\n\n// UploadInfo is the information for each UploadCallback call.\ntype UploadInfo struct {\n\t// parameter name in multipart upload\n\tParamName string\n\t// filename in multipart upload\n\tFileName string\n\t// total file length in bytes.\n\tFileSize int64\n\t// uploaded file length in bytes.\n\tUploadedSize int64\n}\n\n// UploadCallback is the callback which will be invoked during\n// multipart upload.\ntype UploadCallback func(info UploadInfo)\n\n// DownloadInfo is the information for each DownloadCallback call.\ntype DownloadInfo struct {\n\t// Response is the corresponding Response during download.\n\tResponse *Response\n\t// downloaded body length in bytes.\n\tDownloadedSize int64\n}\n\n// DownloadCallback is the callback which will be invoked during\n// response body download.\ntype DownloadCallback func(info DownloadInfo)\n\nfunc cloneSlice[T any](s []T) []T {\n\tif len(s) == 0 {\n\t\treturn nil\n\t}\n\tss := make([]T, len(s))\n\tcopy(ss, s)\n\treturn ss\n}\n\nfunc cloneUrlValues(v url.Values) url.Values {\n\tif v == nil {\n\t\treturn nil\n\t}\n\tvv := make(url.Values)\n\tfor key, values := range v {\n\t\tfor _, value := range values {\n\t\t\tvv.Add(key, value)\n\t\t}\n\t}\n\treturn vv\n}\n\nfunc cloneMap(h map[string]string) map[string]string {\n\tif h == nil {\n\t\treturn nil\n\t}\n\tm := make(map[string]string)\n\tfor k, v := range h {\n\t\tm[k] = v\n\t}\n\treturn m\n}\n\n// convertHeaderToString converts http header to a string.\nfunc convertHeaderToString(h http.Header) string {\n\tif h == nil {\n\t\treturn \"\"\n\t}\n\tbuf := new(bytes.Buffer)\n\th.Write(buf)\n\treturn buf.String()\n}\n"
        },
        {
          "name": "req_test.go",
          "type": "blob",
          "size": 9.6044921875,
          "content": "package req\n\nimport (\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/tests\"\n\t\"go/token\"\n\t\"golang.org/x/text/encoding/simplifiedchinese\"\n\t\"golang.org/x/text/transform\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"unsafe\"\n)\n\nfunc tc() *Client {\n\treturn C().\n\t\tSetBaseURL(getTestServerURL()).\n\t\tEnableInsecureSkipVerify()\n}\n\nvar testDataPath string\n\nfunc init() {\n\tpwd, _ := os.Getwd()\n\ttestDataPath = filepath.Join(pwd, \".testdata\")\n}\n\nfunc createTestServer() *httptest.Server {\n\tserver := httptest.NewUnstartedServer(http.HandlerFunc(handleHTTP))\n\tserver.EnableHTTP2 = true\n\tserver.StartTLS()\n\treturn server\n}\n\nfunc handleHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Add(\"Method\", r.Method)\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\thandleGet(w, r)\n\tcase http.MethodPost:\n\t\thandlePost(w, r)\n\t}\n}\n\nvar testServerMu sync.Mutex\nvar testServer *httptest.Server\n\nfunc getTestServerURL() string {\n\tif testServer != nil {\n\t\treturn testServer.URL\n\t}\n\ttestServerMu.Lock()\n\tdefer testServerMu.Unlock()\n\ttestServer = createTestServer()\n\treturn testServer.URL\n}\n\nfunc getTestFileContent(t *testing.T, filename string) []byte {\n\tb, err := os.ReadFile(tests.GetTestFilePath(filename))\n\ttests.AssertNoError(t, err)\n\treturn b\n}\n\nfunc assertClone(t *testing.T, e, g interface{}) {\n\tev := reflect.ValueOf(e).Elem()\n\tgv := reflect.ValueOf(g).Elem()\n\tet := ev.Type()\n\n\tfor i := 0; i < ev.NumField(); i++ {\n\t\tsf := ev.Field(i)\n\t\tst := et.Field(i)\n\n\t\tvar ee, gg interface{}\n\t\tif !token.IsExported(st.Name) {\n\t\t\tee = reflect.NewAt(sf.Type(), unsafe.Pointer(sf.UnsafeAddr())).Elem().Interface()\n\t\t\tgg = reflect.NewAt(sf.Type(), unsafe.Pointer(gv.Field(i).UnsafeAddr())).Elem().Interface()\n\t\t} else {\n\t\t\tee = sf.Interface()\n\t\t\tgg = gv.Field(i).Interface()\n\t\t}\n\t\tif sf.Kind() == reflect.Func || sf.Kind() == reflect.Slice || sf.Kind() == reflect.Ptr {\n\t\t\tif ee != nil {\n\t\t\t\tif gg == nil {\n\t\t\t\t\tt.Errorf(\"Field %s.%s is nil\", et.Name(), et.Field(i).Name)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(ee, gg) {\n\t\t\tt.Errorf(\"Field %s.%s is not equal, expected [%v], got [%v]\", et.Name(), et.Field(i).Name, ee, gg)\n\t\t}\n\t}\n}\n\n// Echo is used in \"/echo\" API.\ntype Echo struct {\n\tHeader http.Header `json:\"header\" xml:\"header\"`\n\tBody   string      `json:\"body\" xml:\"body\"`\n}\n\nfunc handlePost(w http.ResponseWriter, r *http.Request) {\n\tswitch r.URL.Path {\n\tcase \"/\":\n\t\tio.Copy(io.Discard, r.Body)\n\t\tw.Write([]byte(\"TestPost: text response\"))\n\tcase \"/raw-upload\":\n\t\tio.Copy(io.Discard, r.Body)\n\tcase \"/file-text\":\n\t\tr.ParseMultipartForm(10e6)\n\t\tfiles := r.MultipartForm.File[\"file\"]\n\t\tfile, _ := files[0].Open()\n\t\tb, _ := io.ReadAll(file)\n\t\tr.ParseForm()\n\t\tif a := r.FormValue(\"attempt\"); a != \"\" && a != \"2\" {\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t}\n\t\tw.Write(b)\n\tcase \"/form\":\n\t\tr.ParseForm()\n\t\tret, _ := json.Marshal(&r.Form)\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tw.Write(ret)\n\tcase \"/multipart\":\n\t\tr.ParseMultipartForm(10e6)\n\t\tm := make(map[string]interface{})\n\t\tm[\"values\"] = r.MultipartForm.Value\n\t\tm[\"files\"] = r.MultipartForm.File\n\t\tret, _ := json.Marshal(&m)\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tw.Write(ret)\n\tcase \"/search\":\n\t\thandleSearch(w, r)\n\tcase \"/redirect\":\n\t\tio.Copy(io.Discard, r.Body)\n\t\tw.Header().Set(header.Location, \"/\")\n\t\tw.WriteHeader(http.StatusMovedPermanently)\n\tcase \"/content-type\":\n\t\tio.Copy(io.Discard, r.Body)\n\t\tw.Write([]byte(r.Header.Get(header.ContentType)))\n\tcase \"/echo\":\n\t\tb, _ := io.ReadAll(r.Body)\n\t\te := Echo{\n\t\t\tHeader: r.Header,\n\t\t\tBody:   string(b),\n\t\t}\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tresult, _ := json.Marshal(&e)\n\t\tw.Write(result)\n\t}\n}\n\nfunc handleGetUserProfile(w http.ResponseWriter, r *http.Request) {\n\tuser := strings.TrimLeft(r.URL.Path, \"/user\")\n\tuser = strings.TrimSuffix(user, \"/profile\")\n\tw.Write([]byte(fmt.Sprintf(\"%s's profile\", user)))\n}\n\ntype UserInfo struct {\n\tUsername string `json:\"username\" xml:\"username\"`\n\tEmail    string `json:\"email\" xml:\"email\"`\n}\n\ntype ErrorMessage struct {\n\tErrorCode    int    `json:\"error_code\" xml:\"ErrorCode\"`\n\tErrorMessage string `json:\"error_message\" xml:\"ErrorMessage\"`\n}\n\nfunc handleSearch(w http.ResponseWriter, r *http.Request) {\n\tr.ParseForm()\n\tusername := r.FormValue(\"username\")\n\ttp := r.FormValue(\"type\")\n\tvar marshalFunc func(v interface{}) ([]byte, error)\n\tif tp == \"xml\" {\n\t\tw.Header().Set(header.ContentType, header.XmlContentType)\n\t\tmarshalFunc = xml.Marshal\n\t} else {\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tmarshalFunc = json.Marshal\n\t}\n\tvar result interface{}\n\tswitch username {\n\tcase \"\":\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tresult = &ErrorMessage{\n\t\t\tErrorCode:    10000,\n\t\t\tErrorMessage: \"need username\",\n\t\t}\n\tcase \"imroc\":\n\t\tw.WriteHeader(http.StatusOK)\n\t\tresult = &UserInfo{\n\t\t\tUsername: \"imroc\",\n\t\t\tEmail:    \"roc@imroc.cc\",\n\t\t}\n\tdefault:\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tresult = &ErrorMessage{\n\t\t\tErrorCode:    10001,\n\t\t\tErrorMessage: \"username not exists\",\n\t\t}\n\t}\n\tdata, _ := marshalFunc(result)\n\tw.Write(data)\n}\n\nfunc toGbk(s string) []byte {\n\treader := transform.NewReader(strings.NewReader(s), simplifiedchinese.GBK.NewEncoder())\n\td, e := io.ReadAll(reader)\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn d\n}\n\nfunc handleGet(w http.ResponseWriter, r *http.Request) {\n\tswitch r.URL.Path {\n\tcase \"/\":\n\t\tw.Write([]byte(\"TestGet: text response\"))\n\tcase \"/status\":\n\t\tr.ParseForm()\n\t\tcode := r.FormValue(\"code\")\n\t\tcodeInt, err := strconv.Atoi(code)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tw.Write([]byte(err.Error()))\n\t\t\treturn\n\t\t}\n\t\tw.WriteHeader(codeInt)\n\tcase \"/urlencode\":\n\t\tinfo := &UserInfo{\n\t\t\tUsername: \"我是roc\",\n\t\t\tEmail:    \"roc@imroc.cc\",\n\t\t}\n\t\tbs, err := json.Marshal(info)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tresult := url.QueryEscape(string(bs))\n\t\tw.Write([]byte(result))\n\tcase \"/bad-request\":\n\t\tw.WriteHeader(http.StatusBadRequest)\n\tcase \"/too-many\":\n\t\tw.WriteHeader(http.StatusTooManyRequests)\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tw.Write([]byte(`{\"errMsg\":\"too many requests\"}`))\n\tcase \"/chunked\":\n\t\tw.Header().Add(\"Trailer\", \"Expires\")\n\t\tw.Write([]byte(`This is a chunked body`))\n\tcase \"/host-header\":\n\t\tw.Write([]byte(r.Host))\n\tcase \"/json\":\n\t\tr.ParseForm()\n\t\tif r.FormValue(\"type\") != \"no\" {\n\t\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\t}\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tif r.FormValue(\"error\") == \"yes\" {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tw.Write([]byte(`{\"message\": \"not allowed\"}`))\n\t\t} else {\n\t\t\tw.Write([]byte(`{\"name\": \"roc\"}`))\n\t\t}\n\tcase \"/xml\":\n\t\tr.ParseForm()\n\t\tif r.FormValue(\"type\") != \"no\" {\n\t\t\tw.Header().Set(header.ContentType, header.XmlContentType)\n\t\t}\n\t\tw.Write([]byte(`<user><name>roc</name></user>`))\n\tcase \"/unlimited-redirect\":\n\t\tw.Header().Set(\"Location\", \"/unlimited-redirect\")\n\t\tw.WriteHeader(http.StatusMovedPermanently)\n\tcase \"/redirect-to-other\":\n\t\tw.Header().Set(\"Location\", \"http://dummy.local/test\")\n\t\tw.WriteHeader(http.StatusMovedPermanently)\n\tcase \"/pragma\":\n\t\tw.Header().Add(\"Pragma\", \"no-cache\")\n\tcase \"/payload\":\n\t\tb, _ := io.ReadAll(r.Body)\n\t\tw.Write(b)\n\tcase \"/gbk\":\n\t\tw.Header().Set(header.ContentType, \"text/plain; charset=gbk\")\n\t\tw.Write(toGbk(\"我是roc\"))\n\tcase \"/gbk-no-charset\":\n\t\tb, err := os.ReadFile(tests.GetTestFilePath(\"sample-gbk.html\"))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tw.Header().Set(header.ContentType, \"text/html\")\n\t\tw.Write(b)\n\tcase \"/header\":\n\t\tb, _ := json.Marshal(r.Header)\n\t\tw.Header().Set(header.ContentType, header.JsonContentType)\n\t\tw.Write(b)\n\tcase \"/user-agent\":\n\t\tw.Write([]byte(r.Header.Get(header.UserAgent)))\n\tcase \"/content-type\":\n\t\tw.Write([]byte(r.Header.Get(header.ContentType)))\n\tcase \"/query-parameter\":\n\t\tw.Write([]byte(r.URL.RawQuery))\n\tcase \"/search\":\n\t\thandleSearch(w, r)\n\tcase \"/download\":\n\t\tsize := 100 * 1024 * 1024\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(size))\n\t\tbuf := make([]byte, 1024)\n\t\tfor i := 0; i < 1024; i++ {\n\t\t\tbuf[i] = 'h'\n\t\t}\n\t\tfor i := 0; i < size; {\n\t\t\twbuf := buf\n\t\t\tif size-i < 1024 {\n\t\t\t\twbuf = buf[:size-i]\n\t\t\t}\n\t\t\tn, err := w.Write(wbuf)\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti += n\n\t\t}\n\tcase \"/protected\":\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"Bearer goodtoken\" {\n\t\t\tw.Write([]byte(\"good\"))\n\t\t} else {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(`bad`))\n\t\t}\n\tdefault:\n\t\tif strings.HasPrefix(r.URL.Path, \"/user\") {\n\t\t\thandleGetUserProfile(w, r)\n\t\t}\n\t}\n}\n\nfunc assertStatus(t *testing.T, resp *Response, err error, statusCode int, status string) {\n\ttests.AssertNoError(t, err)\n\ttests.AssertNotNil(t, resp)\n\ttests.AssertNotNil(t, resp.Body)\n\ttests.AssertEqual(t, statusCode, resp.StatusCode)\n\ttests.AssertEqual(t, status, resp.Status)\n}\n\nfunc assertSuccess(t *testing.T, resp *Response, err error) {\n\ttests.AssertNoError(t, err)\n\ttests.AssertNotNil(t, resp.Response)\n\ttests.AssertNotNil(t, resp.Response.Body)\n\ttests.AssertEqual(t, http.StatusOK, resp.StatusCode)\n\ttests.AssertEqual(t, \"200 OK\", resp.Status)\n\tif !resp.IsSuccessState() {\n\t\tt.Error(\"Response.IsSuccessState should return true\")\n\t}\n}\n\nfunc assertIsError(t *testing.T, resp *Response, err error) {\n\ttests.AssertNoError(t, err)\n\ttests.AssertNotNil(t, resp)\n\ttests.AssertNotNil(t, resp.Body)\n\tif !resp.IsErrorState() {\n\t\tt.Error(\"Response.IsErrorState should return true\")\n\t}\n}\n\nfunc TestTrailer(t *testing.T) {\n\tresp, err := tc().EnableForceHTTP1().R().Get(\"/chunked\")\n\tassertSuccess(t, resp, err)\n\t_, ok := resp.Trailer[\"Expires\"]\n\tif !ok {\n\t\tt.Error(\"trailer not exists\")\n\t}\n}\n\nfunc testWithAllTransport(t *testing.T, testFunc func(t *testing.T, c *Client)) {\n\ttestFunc(t, tc())\n\ttestFunc(t, tc().EnableForceHTTP1())\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 34.919921875,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\turlpkg \"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-multierror\"\n\n\t\"github.com/imroc/req/v3/internal/dump\"\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/util\"\n)\n\n// Request struct is used to compose and fire individual request from\n// req client. Request provides lots of chainable settings which can\n// override client level settings.\ntype Request struct {\n\tPathParams      map[string]string\n\tQueryParams     urlpkg.Values\n\tFormData        urlpkg.Values\n\tOrderedFormData []string\n\tHeaders         http.Header\n\tCookies         []*http.Cookie\n\tResult          interface{}\n\tError           interface{}\n\tRawRequest      *http.Request\n\tStartTime       time.Time\n\tRetryAttempt    int\n\tRawURL          string // read only\n\tMethod          string\n\tBody            []byte\n\tGetBody         GetContentFunc\n\t// URL is an auto-generated field, and is nil in request middleware (OnBeforeRequest),\n\t// consider using RawURL if you want, it's not nil in client middleware (WrapRoundTripFunc)\n\tURL *urlpkg.URL\n\n\tisMultiPart              bool\n\tdisableAutoReadResponse  bool\n\tforceChunkedEncoding     bool\n\tisSaveResponse           bool\n\tclose                    bool\n\terror                    error\n\tclient                   *Client\n\tuploadCallback           UploadCallback\n\tuploadCallbackInterval   time.Duration\n\tdownloadCallback         DownloadCallback\n\tdownloadCallbackInterval time.Duration\n\tunReplayableBody         io.ReadCloser\n\tretryOption              *retryOption\n\tbodyReadCloser           io.ReadCloser\n\tdumpOptions              *DumpOptions\n\tmarshalBody              interface{}\n\tctx                      context.Context\n\tuploadFiles              []*FileUpload\n\tuploadReader             []io.ReadCloser\n\toutputFile               string\n\toutput                   io.Writer\n\ttrace                    *clientTrace\n\tdumpBuffer               *bytes.Buffer\n\tresponseReturnTime       time.Time\n\tafterResponse            []ResponseMiddleware\n}\n\ntype GetContentFunc func() (io.ReadCloser, error)\n\nfunc (r *Request) getHeader(key string) string {\n\tif r.Headers == nil {\n\t\treturn \"\"\n\t}\n\treturn r.Headers.Get(key)\n}\n\n// TraceInfo returns the trace information, only available if trace is enabled\n// (see Request.EnableTrace and Client.EnableTraceAll).\nfunc (r *Request) TraceInfo() TraceInfo {\n\tct := r.trace\n\n\tif ct == nil {\n\t\treturn TraceInfo{}\n\t}\n\n\tti := TraceInfo{\n\t\tIsConnReused:  ct.gotConnInfo.Reused,\n\t\tIsConnWasIdle: ct.gotConnInfo.WasIdle,\n\t\tConnIdleTime:  ct.gotConnInfo.IdleTime,\n\t}\n\n\tendTime := ct.endTime\n\tif endTime.IsZero() { // in case timeout\n\t\tendTime = r.responseReturnTime\n\t}\n\n\tif !ct.tlsHandshakeStart.IsZero() {\n\t\tif !ct.tlsHandshakeDone.IsZero() {\n\t\t\tti.TLSHandshakeTime = ct.tlsHandshakeDone.Sub(ct.tlsHandshakeStart)\n\t\t} else {\n\t\t\tti.TLSHandshakeTime = endTime.Sub(ct.tlsHandshakeStart)\n\t\t}\n\t}\n\n\tif ct.gotConnInfo.Reused {\n\t\tti.TotalTime = endTime.Sub(ct.getConn)\n\t} else {\n\t\tif ct.dnsStart.IsZero() {\n\t\t\tti.TotalTime = endTime.Sub(r.StartTime)\n\t\t} else {\n\t\t\tti.TotalTime = endTime.Sub(ct.dnsStart)\n\t\t}\n\t}\n\n\tdnsDone := ct.dnsDone\n\tif dnsDone.IsZero() {\n\t\tdnsDone = endTime\n\t}\n\n\tif !ct.dnsStart.IsZero() {\n\t\tti.DNSLookupTime = dnsDone.Sub(ct.dnsStart)\n\t}\n\n\t// Only calculate on successful connections\n\tif !ct.connectDone.IsZero() {\n\t\tti.TCPConnectTime = ct.connectDone.Sub(dnsDone)\n\t}\n\n\t// Only calculate on successful connections\n\tif !ct.gotConn.IsZero() {\n\t\tti.ConnectTime = ct.gotConn.Sub(ct.getConn)\n\t}\n\n\t// Only calculate on successful connections\n\tif !ct.gotFirstResponseByte.IsZero() {\n\t\tti.FirstResponseTime = ct.gotFirstResponseByte.Sub(ct.gotConn)\n\t\tti.ResponseTime = endTime.Sub(ct.gotFirstResponseByte)\n\t}\n\n\t// Capture remote address info when connection is non-nil\n\tif ct.gotConnInfo.Conn != nil {\n\t\tti.RemoteAddr = ct.gotConnInfo.Conn.RemoteAddr()\n\t}\n\n\treturn ti\n}\n\n// HeaderToString get all header as string.\nfunc (r *Request) HeaderToString() string {\n\treturn convertHeaderToString(r.Headers)\n}\n\n// SetURL set the url for request.\nfunc (r *Request) SetURL(url string) *Request {\n\tr.RawURL = url\n\treturn r\n}\n\n// SetFormDataFromValues set the form data from url.Values, will not\n// been used if request method does not allow payload.\nfunc (r *Request) SetFormDataFromValues(data urlpkg.Values) *Request {\n\tif r.FormData == nil {\n\t\tr.FormData = urlpkg.Values{}\n\t}\n\tfor k, v := range data {\n\t\tfor _, kv := range v {\n\t\t\tr.FormData.Add(k, kv)\n\t\t}\n\t}\n\treturn r\n}\n\n// SetFormData set the form data from a map, will not been used\n// if request method does not allow payload.\nfunc (r *Request) SetFormData(data map[string]string) *Request {\n\tif r.FormData == nil {\n\t\tr.FormData = urlpkg.Values{}\n\t}\n\tfor k, v := range data {\n\t\tr.FormData.Set(k, v)\n\t}\n\treturn r\n}\n\n// SetOrderedFormData set the ordered form data from key-values pairs.\nfunc (r *Request) SetOrderedFormData(kvs ...string) *Request {\n\tr.OrderedFormData = append(r.OrderedFormData, kvs...)\n\treturn r\n}\n\n// SetFormDataAnyType set the form data from a map, which value could be any type,\n// will convert to string automatically.\n// It will not been used if request method does not allow payload.\nfunc (r *Request) SetFormDataAnyType(data map[string]interface{}) *Request {\n\tif r.FormData == nil {\n\t\tr.FormData = urlpkg.Values{}\n\t}\n\tfor k, v := range data {\n\t\tr.FormData.Set(k, fmt.Sprint(v))\n\t}\n\treturn r\n}\n\n// SetCookies set http cookies for the request.\nfunc (r *Request) SetCookies(cookies ...*http.Cookie) *Request {\n\tr.Cookies = append(r.Cookies, cookies...)\n\treturn r\n}\n\n// SetQueryString set URL query parameters for the request using\n// raw query string.\nfunc (r *Request) SetQueryString(query string) *Request {\n\tparams, err := urlpkg.ParseQuery(strings.TrimSpace(query))\n\tif err != nil {\n\t\tr.client.log.Warnf(\"failed to parse query string (%s): %v\", query, err)\n\t\treturn r\n\t}\n\tif r.QueryParams == nil {\n\t\tr.QueryParams = make(urlpkg.Values)\n\t}\n\tfor p, v := range params {\n\t\tfor _, pv := range v {\n\t\t\tr.QueryParams.Add(p, pv)\n\t\t}\n\t}\n\treturn r\n}\n\n// SetFileReader set up a multipart form with a reader to upload file.\nfunc (r *Request) SetFileReader(paramName, filename string, reader io.Reader) *Request {\n\tr.SetFileUpload(FileUpload{\n\t\tParamName: paramName,\n\t\tFileName:  filename,\n\t\tGetFileContent: func() (io.ReadCloser, error) {\n\t\t\tif rc, ok := reader.(io.ReadCloser); ok {\n\t\t\t\treturn rc, nil\n\t\t\t}\n\t\t\treturn io.NopCloser(reader), nil\n\t\t},\n\t})\n\treturn r\n}\n\n// SetFileBytes set up a multipart form with given []byte to upload.\nfunc (r *Request) SetFileBytes(paramName, filename string, content []byte) *Request {\n\tr.SetFileUpload(FileUpload{\n\t\tParamName: paramName,\n\t\tFileName:  filename,\n\t\tGetFileContent: func() (io.ReadCloser, error) {\n\t\t\treturn io.NopCloser(bytes.NewReader(content)), nil\n\t\t},\n\t})\n\treturn r\n}\n\n// SetFiles set up a multipart form from a map to upload, which\n// key is the parameter name, and value is the file path.\nfunc (r *Request) SetFiles(files map[string]string) *Request {\n\tfor k, v := range files {\n\t\tr.SetFile(k, v)\n\t}\n\treturn r\n}\n\n// SetFile set up a multipart form from file path to upload,\n// which read file from filePath automatically to upload.\nfunc (r *Request) SetFile(paramName, filePath string) *Request {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tr.client.log.Errorf(\"failed to open %s: %v\", filePath, err)\n\t\tr.appendError(err)\n\t\treturn r\n\t}\n\tfileInfo, err := os.Stat(filePath)\n\tif err != nil {\n\t\tr.client.log.Errorf(\"failed to stat file %s: %v\", filePath, err)\n\t\tr.appendError(err)\n\t\treturn r\n\t}\n\tr.isMultiPart = true\n\treturn r.SetFileUpload(FileUpload{\n\t\tParamName: paramName,\n\t\tFileName:  filepath.Base(filePath),\n\t\tGetFileContent: func() (io.ReadCloser, error) {\n\t\t\tif r.RetryAttempt > 0 {\n\t\t\t\tfile, err = os.Open(filePath)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn file, nil\n\t\t},\n\t\tFileSize: fileInfo.Size(),\n\t})\n}\n\nvar (\n\terrMissingParamName   = errors.New(\"missing param name in multipart file upload\")\n\terrMissingFileName    = errors.New(\"missing filename in multipart file upload\")\n\terrMissingFileContent = errors.New(\"missing file content in multipart file upload\")\n)\n\n// SetFileUpload set the fully custimized multipart file upload options.\nfunc (r *Request) SetFileUpload(uploads ...FileUpload) *Request {\n\tr.isMultiPart = true\n\tfor _, upload := range uploads {\n\t\tshouldAppend := true\n\t\tif upload.ParamName == \"\" {\n\t\t\tr.appendError(errMissingParamName)\n\t\t\tshouldAppend = false\n\t\t}\n\t\tif upload.FileName == \"\" {\n\t\t\tr.appendError(errMissingFileName)\n\t\t\tshouldAppend = false\n\t\t}\n\t\tif upload.GetFileContent == nil {\n\t\t\tr.appendError(errMissingFileContent)\n\t\t\tshouldAppend = false\n\t\t}\n\t\tif shouldAppend {\n\t\t\tr.uploadFiles = append(r.uploadFiles, &upload)\n\t\t}\n\t}\n\treturn r\n}\n\n// SetUploadCallback set the UploadCallback which will be invoked at least\n// every 200ms during file upload, usually used to show upload progress.\nfunc (r *Request) SetUploadCallback(callback UploadCallback) *Request {\n\treturn r.SetUploadCallbackWithInterval(callback, 200*time.Millisecond)\n}\n\n// SetUploadCallbackWithInterval set the UploadCallback which will be invoked at least\n// every `minInterval` during file upload, usually used to show upload progress.\nfunc (r *Request) SetUploadCallbackWithInterval(callback UploadCallback, minInterval time.Duration) *Request {\n\tif callback == nil {\n\t\treturn r\n\t}\n\tr.forceChunkedEncoding = true\n\tr.uploadCallback = callback\n\tr.uploadCallbackInterval = minInterval\n\treturn r\n}\n\n// SetDownloadCallback set the DownloadCallback which will be invoked at least\n// every 200ms during file upload, usually used to show download progress.\nfunc (r *Request) SetDownloadCallback(callback DownloadCallback) *Request {\n\treturn r.SetDownloadCallbackWithInterval(callback, 200*time.Millisecond)\n}\n\n// SetDownloadCallbackWithInterval set the DownloadCallback which will be invoked at least\n// every `minInterval` during file upload, usually used to show download progress.\nfunc (r *Request) SetDownloadCallbackWithInterval(callback DownloadCallback, minInterval time.Duration) *Request {\n\tif callback == nil {\n\t\treturn r\n\t}\n\tr.downloadCallback = callback\n\tr.downloadCallbackInterval = minInterval\n\treturn r\n}\n\n// SetResult set the result that response Body will be unmarshalled to if\n// no error occurs and Response.ResultState() returns SuccessState, by default\n// it requires HTTP status `code >= 200 && code <= 299`, you can also use\n// Request.SetResultStateCheckFunc or Client.SetResultStateCheckFunc to customize\n// the result state check logic.\n//\n// Deprecated: Use SetSuccessResult instead.\nfunc (r *Request) SetResult(result interface{}) *Request {\n\treturn r.SetSuccessResult(result)\n}\n\n// SetSuccessResult set the result that response Body will be unmarshalled to if\n// no error occurs and Response.ResultState() returns SuccessState, by default\n// it requires HTTP status `code >= 200 && code <= 299`, you can also use\n// Request.SetResultStateCheckFunc or Client.SetResultStateCheckFunc to customize\n// the result state check logic.\nfunc (r *Request) SetSuccessResult(result interface{}) *Request {\n\tif result == nil {\n\t\treturn r\n\t}\n\tr.Result = util.GetPointer(result)\n\treturn r\n}\n\n// SetError set the result that response body will be unmarshalled to if\n// no error occurs and Response.ResultState() returns ErrorState, by default\n// it requires HTTP status `code >= 400`, you can also use Request.SetResultStateCheckFunc\n// or Client.SetResultStateCheckFunc to customize the result state check logic.\n//\n// Deprecated: Use SetErrorResult result.\nfunc (r *Request) SetError(err interface{}) *Request {\n\treturn r.SetErrorResult(err)\n}\n\n// SetErrorResult set the result that response body will be unmarshalled to if\n// no error occurs and Response.ResultState() returns ErrorState, by default\n// it requires HTTP status `code >= 400`, you can also use Request.SetResultStateCheckFunc\n// or Client.SetResultStateCheckFunc to customize the result state check logic.\nfunc (r *Request) SetErrorResult(err interface{}) *Request {\n\tif err == nil {\n\t\treturn r\n\t}\n\tr.Error = util.GetPointer(err)\n\treturn r\n}\n\n// SetBearerAuthToken set bearer auth token for the request.\nfunc (r *Request) SetBearerAuthToken(token string) *Request {\n\treturn r.SetHeader(header.Authorization, \"Bearer \"+token)\n}\n\n// SetBasicAuth set basic auth for the request.\nfunc (r *Request) SetBasicAuth(username, password string) *Request {\n\treturn r.SetHeader(header.Authorization, util.BasicAuthHeaderValue(username, password))\n}\n\n// SetDigestAuth sets the Digest Access auth scheme for the HTTP request. If a server responds with 401 and sends a\n// Digest challenge in the WWW-Authenticate Header, the request will be resent with the appropriate Authorization Header.\n//\n// For Example: To set the Digest scheme with username \"roc\" and password \"123456\"\n//\n//\tclient.R().SetDigestAuth(\"roc\", \"123456\")\n//\n// Information about Digest Access Authentication can be found in RFC7616:\n//\n//\thttps://datatracker.ietf.org/doc/html/rfc7616\n//\n// This method overrides the username and password set by method `Client.SetCommonDigestAuth`.\nfunc (r *Request) SetDigestAuth(username, password string) *Request {\n\tr.OnAfterResponse(handleDigestAuthFunc(username, password))\n\treturn r\n}\n\n// OnAfterResponse add a response middleware which hooks after response received.\nfunc (r *Request) OnAfterResponse(m ResponseMiddleware) *Request {\n\tr.afterResponse = append(r.afterResponse, m)\n\treturn r\n}\n\n// SetHeaders set headers from a map for the request.\nfunc (r *Request) SetHeaders(hdrs map[string]string) *Request {\n\tfor k, v := range hdrs {\n\t\tr.SetHeader(k, v)\n\t}\n\treturn r\n}\n\n// SetHeader set a header for the request.\nfunc (r *Request) SetHeader(key, value string) *Request {\n\tif r.Headers == nil {\n\t\tr.Headers = make(http.Header)\n\t}\n\tr.Headers.Set(key, value)\n\treturn r\n}\n\n// SetHeadersNonCanonical set headers from a map for the request which key is a\n// non-canonical key (keep case unchanged), only valid for HTTP/1.1.\nfunc (r *Request) SetHeadersNonCanonical(hdrs map[string]string) *Request {\n\tfor k, v := range hdrs {\n\t\tr.SetHeaderNonCanonical(k, v)\n\t}\n\treturn r\n}\n\n// SetHeaderNonCanonical set a header for the request which key is a\n// non-canonical key (keep case unchanged), only valid for HTTP/1.1.\nfunc (r *Request) SetHeaderNonCanonical(key, value string) *Request {\n\tif r.Headers == nil {\n\t\tr.Headers = make(http.Header)\n\t}\n\tr.Headers[key] = append(r.Headers[key], value)\n\treturn r\n}\n\nconst (\n\t// HeaderOderKey is the key of header order, which specifies the order\n\t// of the http header.\n\tHeaderOderKey = \"__header_order__\"\n\t// PseudoHeaderOderKey is the key of pseudo header order, which specifies\n\t// the order of the http2 and http3 pseudo header.\n\tPseudoHeaderOderKey = \"__pseudo_header_order__\"\n)\n\n// SetHeaderOrder set the order of the http header (case-insensitive).\n// For example:\n//\n//\tclient.R().SetHeaderOrder(\n//\t    \"custom-header\",\n//\t    \"cookie\",\n//\t    \"user-agent\",\n//\t    \"accept-encoding\",\n//\t)\nfunc (r *Request) SetHeaderOrder(keys ...string) *Request {\n\tif r.Headers == nil {\n\t\tr.Headers = make(http.Header)\n\t}\n\tr.Headers[HeaderOderKey] = append(r.Headers[HeaderOderKey], keys...)\n\treturn r\n}\n\n// SetPseudoHeaderOrder set the order of the pseudo http header (case-insensitive).\n// Note this is only valid for http2 and http3.\n// For example:\n//\n//\tclient.R().SetPseudoHeaderOrder(\n//\t    \":scheme\",\n//\t    \":authority\",\n//\t    \":path\",\n//\t    \":method\",\n//\t)\nfunc (r *Request) SetPseudoHeaderOrder(keys ...string) *Request {\n\tif r.Headers == nil {\n\t\tr.Headers = make(http.Header)\n\t}\n\tr.Headers[PseudoHeaderOderKey] = append(r.Headers[PseudoHeaderOderKey], keys...)\n\treturn r\n}\n\n// SetOutputFile set the file that response Body will be downloaded to.\nfunc (r *Request) SetOutputFile(file string) *Request {\n\tr.isSaveResponse = true\n\tr.outputFile = file\n\treturn r\n}\n\n// SetOutput set the io.Writer that response Body will be downloaded to.\nfunc (r *Request) SetOutput(output io.Writer) *Request {\n\tif output == nil {\n\t\tr.client.log.Warnf(\"nil io.Writer is not allowed in SetOutput\")\n\t\treturn r\n\t}\n\tr.output = output\n\tr.isSaveResponse = true\n\treturn r\n}\n\n// SetQueryParams set URL query parameters from a map for the request.\nfunc (r *Request) SetQueryParams(params map[string]string) *Request {\n\tfor k, v := range params {\n\t\tr.SetQueryParam(k, v)\n\t}\n\treturn r\n}\n\n// SetQueryParamsAnyType set URL query parameters from a map for the request.\n// The value of map is any type, will be convert to string automatically.\nfunc (r *Request) SetQueryParamsAnyType(params map[string]interface{}) *Request {\n\tfor k, v := range params {\n\t\tr.SetQueryParam(k, fmt.Sprint(v))\n\t}\n\treturn r\n}\n\n// SetQueryParam set an URL query parameter for the request.\nfunc (r *Request) SetQueryParam(key, value string) *Request {\n\tif r.QueryParams == nil {\n\t\tr.QueryParams = make(urlpkg.Values)\n\t}\n\tr.QueryParams.Set(key, value)\n\treturn r\n}\n\n// AddQueryParam add a URL query parameter for the request.\nfunc (r *Request) AddQueryParam(key, value string) *Request {\n\tif r.QueryParams == nil {\n\t\tr.QueryParams = make(urlpkg.Values)\n\t}\n\tr.QueryParams.Add(key, value)\n\treturn r\n}\n\n// AddQueryParams add one or more values of specified URL query parameter for the request.\nfunc (r *Request) AddQueryParams(key string, values ...string) *Request {\n\tif r.QueryParams == nil {\n\t\tr.QueryParams = make(urlpkg.Values)\n\t}\n\tvs := r.QueryParams[key]\n\tvs = append(vs, values...)\n\tr.QueryParams[key] = vs\n\treturn r\n}\n\n// SetPathParams set URL path parameters from a map for the request.\nfunc (r *Request) SetPathParams(params map[string]string) *Request {\n\tfor key, value := range params {\n\t\tr.SetPathParam(key, value)\n\t}\n\treturn r\n}\n\n// SetPathParam set a URL path parameter for the request.\nfunc (r *Request) SetPathParam(key, value string) *Request {\n\tif r.PathParams == nil {\n\t\tr.PathParams = make(map[string]string)\n\t}\n\tr.PathParams[key] = value\n\treturn r\n}\n\nfunc (r *Request) appendError(err error) {\n\tr.error = multierror.Append(r.error, err)\n}\n\nvar errRetryableWithUnReplayableBody = errors.New(\"retryable request should not have unreplayable Body (io.Reader)\")\n\nfunc (r *Request) newErrorResponse(err error) *Response {\n\tresp := &Response{Request: r}\n\tresp.Err = err\n\treturn resp\n}\n\n// Do fires http request, 0 or 1 context is allowed, and returns the *Response which\n// is always not nil, and Response.Err is not nil if error occurs.\nfunc (r *Request) Do(ctx ...context.Context) *Response {\n\tif len(ctx) > 0 && ctx[0] != nil {\n\t\tr.ctx = ctx[0]\n\t}\n\n\tdefer func() {\n\t\tr.responseReturnTime = time.Now()\n\t}()\n\tif r.error != nil {\n\t\treturn r.newErrorResponse(r.error)\n\t}\n\tif r.retryOption != nil && r.retryOption.MaxRetries != 0 && r.unReplayableBody != nil { // retryable request should not have unreplayable Body\n\t\treturn r.newErrorResponse(errRetryableWithUnReplayableBody)\n\t}\n\tresp, _ := r.do()\n\treturn resp\n}\n\nfunc (r *Request) do() (resp *Response, err error) {\n\tdefer func() {\n\t\tif resp == nil {\n\t\t\tresp = &Response{Request: r}\n\t\t}\n\t\tif err != nil && resp.Err == nil {\n\t\t\tresp.Err = err\n\t\t}\n\t}()\n\n\tfor {\n\t\tif r.Headers == nil {\n\t\t\tr.Headers = make(http.Header)\n\t\t}\n\t\tfor _, f := range r.client.udBeforeRequest {\n\t\t\tif err = f(r.client, r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tfor _, f := range r.client.beforeRequest {\n\t\t\tif err = f(r.client, r); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif r.client.wrappedRoundTrip != nil {\n\t\t\tresp, err = r.client.wrappedRoundTrip.RoundTrip(r)\n\t\t} else {\n\t\t\tresp, err = r.client.roundTrip(r)\n\t\t}\n\n\t\t// Determine if the error is from a canceled context.\n\t\t// Store it here so it doesn't get lost when processing the AfterResponse middleware.\n\t\tcontextCanceled := errors.Is(err, context.Canceled)\n\n\t\tfor _, f := range r.afterResponse {\n\t\t\tif err = f(r.client, resp); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif contextCanceled || r.retryOption == nil || (r.RetryAttempt >= r.retryOption.MaxRetries && r.retryOption.MaxRetries >= 0) { // absolutely cannot retry.\n\t\t\treturn\n\t\t}\n\n\t\t// check retry whether is needed.\n\t\tneedRetry := err != nil                             // default behaviour: retry if error occurs\n\t\tif l := len(r.retryOption.RetryConditions); l > 0 { // override default behaviour if custom RetryConditions has been set.\n\t\t\tfor i := l - 1; i >= 0; i-- {\n\t\t\t\tneedRetry = r.retryOption.RetryConditions[i](resp, err)\n\t\t\t\tif needRetry {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !needRetry { // no retry is needed.\n\t\t\treturn\n\t\t}\n\n\t\t// need retry, attempt to retry\n\t\tr.RetryAttempt++\n\t\tif l := len(r.retryOption.RetryHooks); l > 0 {\n\t\t\tfor i := l - 1; i >= 0; i-- { // run retry hooks in reverse order\n\t\t\t\tr.retryOption.RetryHooks[i](resp, err)\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(r.retryOption.GetRetryInterval(resp, r.RetryAttempt))\n\n\t\t// clean up before retry\n\t\tif r.dumpBuffer != nil {\n\t\t\tr.dumpBuffer.Reset()\n\t\t}\n\t\tif r.trace != nil {\n\t\t\tr.trace = &clientTrace{}\n\t\t}\n\t\tresp.body = nil\n\t\tresp.result = nil\n\t\tresp.error = nil\n\t}\n}\n\n// Send fires http request with specified method and url, returns the\n// *Response which is always not nil, and the error is not nil if error occurs.\nfunc (r *Request) Send(method, url string) (*Response, error) {\n\tr.Method = method\n\tr.RawURL = url\n\tresp := r.Do()\n\tif resp.Err != nil && r.client.onError != nil {\n\t\tr.client.onError(r.client, r, resp, resp.Err)\n\t}\n\treturn resp, resp.Err\n}\n\n// MustGet like Get, panic if error happens, should only be used to\n// test without error handling.\nfunc (r *Request) MustGet(url string) *Response {\n\tresp, err := r.Get(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Get fires http request with GET method and the specified URL.\nfunc (r *Request) Get(url string) (*Response, error) {\n\treturn r.Send(http.MethodGet, url)\n}\n\n// MustPost like Post, panic if error happens. should only be used to\n// test without error handling.\nfunc (r *Request) MustPost(url string) *Response {\n\tresp, err := r.Post(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Post fires http request with POST method and the specified URL.\nfunc (r *Request) Post(url string) (*Response, error) {\n\treturn r.Send(http.MethodPost, url)\n}\n\n// MustPut like Put, panic if error happens, should only be used to\n// test without error handling.\nfunc (r *Request) MustPut(url string) *Response {\n\tresp, err := r.Put(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Put fires http request with PUT method and the specified URL.\nfunc (r *Request) Put(url string) (*Response, error) {\n\treturn r.Send(http.MethodPut, url)\n}\n\n// MustPatch like Patch, panic if error happens, should only be used\n// to test without error handling.\nfunc (r *Request) MustPatch(url string) *Response {\n\tresp, err := r.Patch(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Patch fires http request with PATCH method and the specified URL.\nfunc (r *Request) Patch(url string) (*Response, error) {\n\treturn r.Send(http.MethodPatch, url)\n}\n\n// MustDelete like Delete, panic if error happens, should only be used\n// to test without error handling.\nfunc (r *Request) MustDelete(url string) *Response {\n\tresp, err := r.Delete(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Delete fires http request with DELETE method and the specified URL.\nfunc (r *Request) Delete(url string) (*Response, error) {\n\treturn r.Send(http.MethodDelete, url)\n}\n\n// MustOptions like Options, panic if error happens, should only be\n// used to test without error handling.\nfunc (r *Request) MustOptions(url string) *Response {\n\tresp, err := r.Options(url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Options fires http request with OPTIONS method and the specified URL.\nfunc (r *Request) Options(url string) (*Response, error) {\n\treturn r.Send(http.MethodOptions, url)\n}\n\n// MustHead like Head, panic if error happens, should only be used\n// to test without error handling.\nfunc (r *Request) MustHead(url string) *Response {\n\tresp, err := r.Send(http.MethodHead, url)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn resp\n}\n\n// Head fires http request with HEAD method and the specified URL.\nfunc (r *Request) Head(url string) (*Response, error) {\n\treturn r.Send(http.MethodHead, url)\n}\n\n// SetBody set the request Body, accepts string, []byte, io.Reader, map and struct.\nfunc (r *Request) SetBody(body interface{}) *Request {\n\tif body == nil {\n\t\treturn r\n\t}\n\tswitch b := body.(type) {\n\tcase io.ReadCloser:\n\t\tr.unReplayableBody = b\n\t\tr.GetBody = func() (io.ReadCloser, error) {\n\t\t\treturn r.unReplayableBody, nil\n\t\t}\n\tcase io.Reader:\n\t\tr.unReplayableBody = io.NopCloser(b)\n\t\tr.GetBody = func() (io.ReadCloser, error) {\n\t\t\treturn r.unReplayableBody, nil\n\t\t}\n\tcase []byte:\n\t\tr.SetBodyBytes(b)\n\tcase string:\n\t\tr.SetBodyString(b)\n\tcase func() (io.ReadCloser, error):\n\t\tr.GetBody = b\n\tcase GetContentFunc:\n\t\tr.GetBody = b\n\tdefault:\n\t\tt := reflect.TypeOf(body)\n\t\tswitch t.Kind() {\n\t\tcase reflect.Ptr, reflect.Struct, reflect.Map, reflect.Slice, reflect.Array:\n\t\t\tr.marshalBody = body\n\t\tdefault:\n\t\t\tr.SetBodyString(fmt.Sprint(body))\n\t\t}\n\t}\n\treturn r\n}\n\n// SetBodyBytes set the request Body as []byte.\nfunc (r *Request) SetBodyBytes(body []byte) *Request {\n\tr.Body = body\n\tr.GetBody = func() (io.ReadCloser, error) {\n\t\treturn io.NopCloser(bytes.NewReader(body)), nil\n\t}\n\treturn r\n}\n\n// SetBodyString set the request Body as string.\nfunc (r *Request) SetBodyString(body string) *Request {\n\treturn r.SetBodyBytes([]byte(body))\n}\n\n// SetBodyJsonString set the request Body as string and set Content-Type header\n// as \"application/json; charset=utf-8\"\nfunc (r *Request) SetBodyJsonString(body string) *Request {\n\treturn r.SetBodyJsonBytes([]byte(body))\n}\n\n// SetBodyJsonBytes set the request Body as []byte and set Content-Type header\n// as \"application/json; charset=utf-8\"\nfunc (r *Request) SetBodyJsonBytes(body []byte) *Request {\n\tr.SetContentType(header.JsonContentType)\n\treturn r.SetBodyBytes(body)\n}\n\n// SetBodyJsonMarshal set the request Body that marshaled from object, and\n// set Content-Type header as \"application/json; charset=utf-8\"\nfunc (r *Request) SetBodyJsonMarshal(v interface{}) *Request {\n\tb, err := r.client.jsonMarshal(v)\n\tif err != nil {\n\t\tr.appendError(err)\n\t\treturn r\n\t}\n\treturn r.SetBodyJsonBytes(b)\n}\n\n// SetBodyXmlString set the request Body as string and set Content-Type header\n// as \"text/xml; charset=utf-8\"\nfunc (r *Request) SetBodyXmlString(body string) *Request {\n\treturn r.SetBodyXmlBytes([]byte(body))\n}\n\n// SetBodyXmlBytes set the request Body as []byte and set Content-Type header\n// as \"text/xml; charset=utf-8\"\nfunc (r *Request) SetBodyXmlBytes(body []byte) *Request {\n\tr.SetContentType(header.XmlContentType)\n\treturn r.SetBodyBytes(body)\n}\n\n// SetBodyXmlMarshal set the request Body that marshaled from object, and\n// set Content-Type header as \"text/xml; charset=utf-8\"\nfunc (r *Request) SetBodyXmlMarshal(v interface{}) *Request {\n\tb, err := r.client.xmlMarshal(v)\n\tif err != nil {\n\t\tr.appendError(err)\n\t\treturn r\n\t}\n\treturn r.SetBodyXmlBytes(b)\n}\n\n// SetContentType set the `Content-Type` for the request.\nfunc (r *Request) SetContentType(contentType string) *Request {\n\treturn r.SetHeader(header.ContentType, contentType)\n}\n\n// Context method returns the Context if its already set in request\n// otherwise it creates new one using `context.Background()`.\nfunc (r *Request) Context() context.Context {\n\tif r.ctx == nil {\n\t\tr.ctx = context.Background()\n\t}\n\treturn r.ctx\n}\n\n// SetContext method sets the context.Context for current Request. It allows\n// to interrupt the request execution if ctx.Done() channel is closed.\n// See https://blog.golang.org/context article and the \"context\" package\n// documentation.\n//\n// Attention: make sure call SetContext before EnableDumpXXX if you want to\n// dump at the request level.\nfunc (r *Request) SetContext(ctx context.Context) *Request {\n\tif ctx != nil {\n\t\tr.ctx = ctx\n\t}\n\treturn r\n}\n\n// SetContextData sets the key-value pair data for current Request, so you\n// can access some extra context info for current Request in hook or middleware.\nfunc (r *Request) SetContextData(key, val any) *Request {\n\tr.ctx = context.WithValue(r.Context(), key, val)\n\treturn r\n}\n\n// GetContextData returns the context data of specified key, which set by SetContextData.\nfunc (r *Request) GetContextData(key any) any {\n\treturn r.Context().Value(key)\n}\n\n// DisableAutoReadResponse disable read response body automatically (enabled by default).\nfunc (r *Request) DisableAutoReadResponse() *Request {\n\tr.disableAutoReadResponse = true\n\treturn r\n}\n\n// EnableAutoReadResponse enable read response body automatically (enabled by default).\nfunc (r *Request) EnableAutoReadResponse() *Request {\n\tr.disableAutoReadResponse = false\n\treturn r\n}\n\n// DisableTrace disables trace.\nfunc (r *Request) DisableTrace() *Request {\n\tr.trace = nil\n\treturn r\n}\n\n// EnableTrace enables trace (http3 currently does not support trace).\nfunc (r *Request) EnableTrace() *Request {\n\tif r.trace == nil {\n\t\tr.trace = &clientTrace{}\n\t}\n\treturn r\n}\n\nfunc (r *Request) getDumpBuffer() *bytes.Buffer {\n\tif r.dumpBuffer == nil {\n\t\tr.dumpBuffer = new(bytes.Buffer)\n\t}\n\treturn r.dumpBuffer\n}\n\nfunc (r *Request) getDumpOptions() *DumpOptions {\n\tif r.dumpOptions == nil {\n\t\tr.dumpOptions = &DumpOptions{\n\t\t\tRequestHeader:  true,\n\t\t\tRequestBody:    true,\n\t\t\tResponseHeader: true,\n\t\t\tResponseBody:   true,\n\t\t\tOutput:         r.getDumpBuffer(),\n\t\t}\n\t}\n\treturn r.dumpOptions\n}\n\n// EnableDumpTo enables dump and save to the specified io.Writer.\nfunc (r *Request) EnableDumpTo(output io.Writer) *Request {\n\tr.getDumpOptions().Output = output\n\treturn r.EnableDump()\n}\n\n// EnableDumpToFile enables dump and save to the specified filename.\nfunc (r *Request) EnableDumpToFile(filename string) *Request {\n\tfile, err := os.Create(filename)\n\tif err != nil {\n\t\tr.appendError(err)\n\t\treturn r\n\t}\n\tr.getDumpOptions().Output = file\n\treturn r.EnableDump()\n}\n\n// SetDumpOptions sets DumpOptions at request level.\nfunc (r *Request) SetDumpOptions(opt *DumpOptions) *Request {\n\tif opt == nil {\n\t\treturn r\n\t}\n\tif opt.Output == nil {\n\t\topt.Output = r.getDumpBuffer()\n\t}\n\tif r.dumpOptions != nil {\n\t\t*r.dumpOptions = *opt\n\t} else {\n\t\tr.dumpOptions = opt\n\t}\n\treturn r\n}\n\n// EnableDump enables dump, including all content for the request and response by default.\nfunc (r *Request) EnableDump() *Request {\n\treturn r.SetContext(context.WithValue(r.Context(), dump.DumperKey, newDumper(r.getDumpOptions())))\n}\n\n// EnableDumpWithoutBody enables dump only header for the request and response.\nfunc (r *Request) EnableDumpWithoutBody() *Request {\n\to := r.getDumpOptions()\n\to.RequestBody = false\n\to.ResponseBody = false\n\treturn r.EnableDump()\n}\n\n// EnableDumpWithoutHeader enables dump only Body for the request and response.\nfunc (r *Request) EnableDumpWithoutHeader() *Request {\n\to := r.getDumpOptions()\n\to.RequestHeader = false\n\to.ResponseHeader = false\n\treturn r.EnableDump()\n}\n\n// EnableDumpWithoutResponse enables dump only request.\nfunc (r *Request) EnableDumpWithoutResponse() *Request {\n\to := r.getDumpOptions()\n\to.ResponseHeader = false\n\to.ResponseBody = false\n\treturn r.EnableDump()\n}\n\n// EnableDumpWithoutRequest enables dump only response.\nfunc (r *Request) EnableDumpWithoutRequest() *Request {\n\to := r.getDumpOptions()\n\to.RequestHeader = false\n\to.RequestBody = false\n\treturn r.EnableDump()\n}\n\n// EnableDumpWithoutRequestBody enables dump with request Body excluded,\n// can be used in upload request to avoid dump the unreadable binary content.\nfunc (r *Request) EnableDumpWithoutRequestBody() *Request {\n\to := r.getDumpOptions()\n\to.RequestBody = false\n\treturn r.EnableDump()\n}\n\n// EnableDumpWithoutResponseBody enables dump with response Body excluded,\n// can be used in download request to avoid dump the unreadable binary content.\nfunc (r *Request) EnableDumpWithoutResponseBody() *Request {\n\to := r.getDumpOptions()\n\to.ResponseBody = false\n\treturn r.EnableDump()\n}\n\n// EnableForceChunkedEncoding enables force using chunked encoding when uploading.\nfunc (r *Request) EnableForceChunkedEncoding() *Request {\n\tr.forceChunkedEncoding = true\n\treturn r\n}\n\n// DisableForceChunkedEncoding disables force using chunked encoding when uploading.\nfunc (r *Request) DisableForceChunkedEncoding() *Request {\n\tr.forceChunkedEncoding = false\n\treturn r\n}\n\n// EnableForceMultipart enables force using multipart to upload form data.\nfunc (r *Request) EnableForceMultipart() *Request {\n\tr.isMultiPart = true\n\treturn r\n}\n\n// DisableForceMultipart disables force using multipart to upload form data.\nfunc (r *Request) DisableForceMultipart() *Request {\n\tr.isMultiPart = false\n\treturn r\n}\n\nfunc (r *Request) getRetryOption() *retryOption {\n\tif r.retryOption == nil {\n\t\tr.retryOption = newDefaultRetryOption()\n\t}\n\treturn r.retryOption\n}\n\n// SetRetryCount enables retry and set the maximum retry count.\n// It will retry infinitely if count is negative.\nfunc (r *Request) SetRetryCount(count int) *Request {\n\tr.getRetryOption().MaxRetries = count\n\treturn r\n}\n\n// SetRetryInterval sets the custom GetRetryIntervalFunc, you can use this to\n// implement your own backoff retry algorithm.\n// For example:\n//\n//\treq.SetRetryInterval(func(resp *req.Response, attempt int) time.Duration {\n//\t    sleep := 0.01 * math.Exp2(float64(attempt))\n//\t    return time.Duration(math.Min(2, sleep)) * time.Second\n//\t})\nfunc (r *Request) SetRetryInterval(getRetryIntervalFunc GetRetryIntervalFunc) *Request {\n\tr.getRetryOption().GetRetryInterval = getRetryIntervalFunc\n\treturn r\n}\n\n// SetRetryFixedInterval set retry to use a fixed interval.\nfunc (r *Request) SetRetryFixedInterval(interval time.Duration) *Request {\n\tr.getRetryOption().GetRetryInterval = func(resp *Response, attempt int) time.Duration {\n\t\treturn interval\n\t}\n\treturn r\n}\n\n// SetRetryBackoffInterval set retry to use a capped exponential backoff with jitter.\n// https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\nfunc (r *Request) SetRetryBackoffInterval(min, max time.Duration) *Request {\n\tr.getRetryOption().GetRetryInterval = backoffInterval(min, max)\n\treturn r\n}\n\n// SetRetryHook set the retry hook which will be executed before a retry.\n// It will override other retry hooks if any been added before (including\n// client-level retry hooks).\nfunc (r *Request) SetRetryHook(hook RetryHookFunc) *Request {\n\tr.getRetryOption().RetryHooks = []RetryHookFunc{hook}\n\treturn r\n}\n\n// AddRetryHook adds a retry hook which will be executed before a retry.\nfunc (r *Request) AddRetryHook(hook RetryHookFunc) *Request {\n\tro := r.getRetryOption()\n\tro.RetryHooks = append(ro.RetryHooks, hook)\n\treturn r\n}\n\n// SetRetryCondition sets the retry condition, which determines whether the\n// request should retry.\n// It will override other retry conditions if any been added before (including\n// client-level retry conditions).\nfunc (r *Request) SetRetryCondition(condition RetryConditionFunc) *Request {\n\tr.getRetryOption().RetryConditions = []RetryConditionFunc{condition}\n\treturn r\n}\n\n// AddRetryCondition adds a retry condition, which determines whether the\n// request should retry.\nfunc (r *Request) AddRetryCondition(condition RetryConditionFunc) *Request {\n\tro := r.getRetryOption()\n\tro.RetryConditions = append(ro.RetryConditions, condition)\n\treturn r\n}\n\n// SetClient change the client of request dynamically.\nfunc (r *Request) SetClient(client *Client) *Request {\n\tif client != nil {\n\t\tr.client = client\n\t}\n\treturn r\n}\n\n// GetClient returns the current client used by request.\nfunc (r *Request) GetClient() *Client {\n\treturn r.client\n}\n\n// EnableCloseConnection closes the connection after sending this\n// request and reading its response if set to true in HTTP/1.1 and\n// HTTP/2.\n//\n// Setting this field prevents re-use of TCP connections between\n// requests to the same hosts event if EnableKeepAlives() were called.\nfunc (r *Request) EnableCloseConnection() *Request {\n\tr.close = true\n\treturn r\n}\n"
        },
        {
          "name": "request_test.go",
          "type": "blob",
          "size": 26.435546875,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/tests\"\n)\n\nfunc TestMustSendMethods(t *testing.T) {\n\tc := tc()\n\ttestCases := []struct {\n\t\tSendReq      func(req *Request, url string) *Response\n\t\tExpectMethod string\n\t}{\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustGet(url)\n\t\t\t},\n\t\t\tExpectMethod: \"GET\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustPost(url)\n\t\t\t},\n\t\t\tExpectMethod: \"POST\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustPatch(url)\n\t\t\t},\n\t\t\tExpectMethod: \"PATCH\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustDelete(url)\n\t\t\t},\n\t\t\tExpectMethod: \"DELETE\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustOptions(url)\n\t\t\t},\n\t\t\tExpectMethod: \"OPTIONS\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustPut(url)\n\t\t\t},\n\t\t\tExpectMethod: \"PUT\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request, url string) *Response {\n\t\t\t\treturn req.MustHead(url)\n\t\t\t},\n\t\t\tExpectMethod: \"HEAD\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttestMethod(t, c, func(req *Request) *Response {\n\t\t\treturn tc.SendReq(req, \"/\")\n\t\t}, tc.ExpectMethod, false)\n\t}\n\n\t// test panic\n\tfor _, tc := range testCases {\n\t\ttestMethod(t, c, func(req *Request) *Response {\n\t\t\treturn tc.SendReq(req, \"/\\r\\n\")\n\t\t}, tc.ExpectMethod, true)\n\t}\n}\n\nfunc TestSendMethods(t *testing.T) {\n\tc := tc()\n\ttestCases := []struct {\n\t\tSendReq      func(req *Request) (resp *Response, err error)\n\t\tExpectMethod string\n\t}{\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Get(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"GET\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Post(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"POST\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Put(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"PUT\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Patch(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"PATCH\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Delete(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"DELETE\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Options(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"OPTIONS\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Head(\"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"HEAD\",\n\t\t},\n\t\t{\n\t\t\tSendReq: func(req *Request) (resp *Response, err error) {\n\t\t\t\treturn req.Send(\"GET\", \"/\")\n\t\t\t},\n\t\t\tExpectMethod: \"GET\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\ttestMethod(t, c, func(req *Request) *Response {\n\t\t\tresp, err := tc.SendReq(req)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"%s %s: %s\", req.Method, req.RawURL, err.Error())\n\t\t\t}\n\t\t\treturn resp\n\t\t}, tc.ExpectMethod, false)\n\t}\n}\n\nfunc testMethod(t *testing.T, c *Client, sendReq func(*Request) *Response, expectMethod string, expectPanic bool) {\n\tr := c.R()\n\tif expectPanic {\n\t\tdefer func() {\n\t\t\tif err := recover(); err == nil {\n\t\t\t\tt.Errorf(\"Must mehod %s should panic\", expectMethod)\n\t\t\t}\n\t\t}()\n\t}\n\tresp := sendReq(r)\n\tmethod := resp.Header.Get(\"Method\")\n\tif expectMethod != method {\n\t\tt.Errorf(\"Expect method %s, got method %s\", expectMethod, method)\n\t}\n}\n\ntype dumpExpected struct {\n\tReqHeader  bool\n\tReqBody    bool\n\tRespHeader bool\n\tRespBody   bool\n}\n\nfunc testEnableDump(t *testing.T, fn func(r *Request) (de dumpExpected)) {\n\ttestDump := func(c *Client) {\n\t\tr := c.R()\n\t\tde := fn(r)\n\t\tresp, err := r.SetBody(`test body`).Post(\"/\")\n\t\tassertSuccess(t, resp, err)\n\t\tdump := resp.Dump()\n\t\ttests.AssertContains(t, dump, \"user-agent\", de.ReqHeader)\n\t\ttests.AssertContains(t, dump, \"test body\", de.ReqBody)\n\t\ttests.AssertContains(t, dump, \"date\", de.RespHeader)\n\t\ttests.AssertContains(t, dump, \"testpost: text response\", de.RespBody)\n\t}\n\tc := tc()\n\ttestDump(c)\n\ttestDump(c.EnableForceHTTP1())\n}\n\nfunc TestEnableDump(t *testing.T) {\n\ttestCases := []func(r *Request) (d dumpExpected){\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDump()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\tde.RespHeader = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDumpWithoutHeader()\n\t\t\tde.ReqBody = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDumpWithoutBody()\n\t\t\tde.ReqHeader = true\n\t\t\tde.RespHeader = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDumpWithoutRequest()\n\t\t\tde.RespHeader = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDumpWithoutRequestBody()\n\t\t\tde.ReqHeader = true\n\t\t\tde.RespHeader = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDumpWithoutResponse()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.EnableDumpWithoutResponseBody()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\tde.RespHeader = true\n\t\t\treturn\n\t\t},\n\t\tfunc(r *Request) (de dumpExpected) {\n\t\t\tr.SetDumpOptions(&DumpOptions{\n\t\t\t\tRequestHeader: true,\n\t\t\t\tRequestBody:   true,\n\t\t\t\tResponseBody:  true,\n\t\t\t}).EnableDump()\n\t\t\tde.ReqHeader = true\n\t\t\tde.ReqBody = true\n\t\t\tde.RespBody = true\n\t\t\treturn\n\t\t},\n\t}\n\tfor _, fn := range testCases {\n\t\ttestEnableDump(t, fn)\n\t}\n}\n\nfunc TestEnableDumpTo(t *testing.T) {\n\tbuff := new(bytes.Buffer)\n\tresp, err := tc().R().EnableDumpTo(buff).Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, buff.Len() > 0)\n}\n\nfunc TestEnableDumpToFIle(t *testing.T) {\n\ttmpFile := \"tmp_dumpfile_req\"\n\tresp, err := tc().R().EnableDumpToFile(tests.GetTestFilePath(tmpFile)).Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, len(getTestFileContent(t, tmpFile)) > 0)\n\tos.Remove(tests.GetTestFilePath(tmpFile))\n}\n\nfunc TestBadRequest(t *testing.T) {\n\tresp, err := tc().R().Get(\"/bad-request\")\n\tassertStatus(t, resp, err, http.StatusBadRequest, \"400 Bad Request\")\n}\n\nfunc TestSetBodyMarshal(t *testing.T) {\n\tusername := \"imroc\"\n\ttype User struct {\n\t\tUsername string `json:\"username\" xml:\"username\"`\n\t}\n\n\tassertUsernameJson := func(body []byte) {\n\t\tvar user User\n\t\terr := json.Unmarshal(body, &user)\n\t\ttests.AssertNoError(t, err)\n\t\ttests.AssertEqual(t, username, user.Username)\n\t}\n\tassertUsernameXml := func(body []byte) {\n\t\tvar user User\n\t\terr := xml.Unmarshal(body, &user)\n\t\ttests.AssertNoError(t, err)\n\t\ttests.AssertEqual(t, username, user.Username)\n\t}\n\n\ttestCases := []struct {\n\t\tSet    func(r *Request)\n\t\tAssert func(body []byte)\n\t}{\n\t\t{ // SetBody with map\n\t\t\tSet: func(r *Request) {\n\t\t\t\tm := map[string]interface{}{\n\t\t\t\t\t\"username\": username,\n\t\t\t\t}\n\t\t\t\tr.SetBody(&m)\n\t\t\t},\n\t\t\tAssert: assertUsernameJson,\n\t\t},\n\t\t{ // SetBody with struct\n\t\t\tSet: func(r *Request) {\n\t\t\t\tvar user User\n\t\t\t\tuser.Username = username\n\t\t\t\tr.SetBody(&user)\n\t\t\t},\n\t\t\tAssert: assertUsernameJson,\n\t\t},\n\t\t{ // SetBody with struct use xml\n\t\t\tSet: func(r *Request) {\n\t\t\t\tvar user User\n\t\t\t\tuser.Username = username\n\t\t\t\tr.SetBody(&user).SetContentType(header.XmlContentType)\n\t\t\t},\n\t\t\tAssert: assertUsernameXml,\n\t\t},\n\t\t{ // SetBodyJsonMarshal with map\n\t\t\tSet: func(r *Request) {\n\t\t\t\tm := map[string]interface{}{\n\t\t\t\t\t\"username\": username,\n\t\t\t\t}\n\t\t\t\tr.SetBodyJsonMarshal(&m)\n\t\t\t},\n\t\t\tAssert: assertUsernameJson,\n\t\t},\n\t\t{ // SetBodyJsonMarshal with struct\n\t\t\tSet: func(r *Request) {\n\t\t\t\tvar user User\n\t\t\t\tuser.Username = username\n\t\t\t\tr.SetBodyJsonMarshal(&user)\n\t\t\t},\n\t\t\tAssert: assertUsernameJson,\n\t\t},\n\t\t{ // SetBodyXmlMarshal with struct\n\t\t\tSet: func(r *Request) {\n\t\t\t\tvar user User\n\t\t\t\tuser.Username = username\n\t\t\t\tr.SetBodyXmlMarshal(&user)\n\t\t\t},\n\t\t\tAssert: assertUsernameXml,\n\t\t},\n\t}\n\n\tc := tc()\n\tfor _, tc := range testCases {\n\t\tr := c.R()\n\t\ttc.Set(r)\n\t\tvar e Echo\n\t\tresp, err := r.SetSuccessResult(&e).Post(\"/echo\")\n\t\tassertSuccess(t, resp, err)\n\t\ttc.Assert([]byte(e.Body))\n\t}\n}\n\nfunc TestDoAPIStyle(t *testing.T) {\n\tc := tc()\n\tuser := &UserInfo{}\n\turl := \"/search?username=imroc&type=json\"\n\n\terr := c.Get().SetURL(url).Do().Into(user)\n\ttests.AssertEqual(t, true, err == nil)\n\ttests.AssertEqual(t, \"imroc\", user.Username)\n}\n\nfunc TestSetSuccessResult(t *testing.T) {\n\tc := tc()\n\tvar user *UserInfo\n\turl := \"/search?username=imroc&type=json\"\n\n\tresp, err := c.R().SetSuccessResult(&user).Get(url)\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"imroc\", user.Username)\n\n\tuser = &UserInfo{}\n\tresp, err = c.R().SetSuccessResult(user).Get(url)\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"imroc\", user.Username)\n\n\tuser = nil\n\tresp, err = c.R().SetSuccessResult(user).Get(url)\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"imroc\", resp.Result().(*UserInfo).Username)\n}\n\nfunc TestSetBody(t *testing.T) {\n\tbody := \"hello\"\n\tfn := func() (io.ReadCloser, error) {\n\t\treturn io.NopCloser(bytes.NewBufferString(body)), nil\n\t}\n\tc := tc()\n\ttestCases := []struct {\n\t\tSetBody     func(r *Request)\n\t\tContentType string\n\t}{\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBody with `func() (io.ReadCloser, error)`\n\t\t\t\tr.SetBody(fn)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { //  SetBody with GetContentFunc\n\t\t\t\tr.SetBody(GetContentFunc(fn))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { //  SetBody with io.ReadCloser\n\t\t\t\tr.SetBody(io.NopCloser(bytes.NewBufferString(body)))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { //  SetBody with io.Reader\n\t\t\t\tr.SetBody(bytes.NewBufferString(body))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { //  SetBody with string\n\t\t\t\tr.SetBody(body)\n\t\t\t},\n\t\t\tContentType: header.PlainTextContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBody with []byte\n\t\t\t\tr.SetBody([]byte(body))\n\t\t\t},\n\t\t\tContentType: header.PlainTextContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBodyString\n\t\t\t\tr.SetBodyString(body)\n\t\t\t},\n\t\t\tContentType: header.PlainTextContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBodyBytes\n\t\t\t\tr.SetBodyBytes([]byte(body))\n\t\t\t},\n\t\t\tContentType: header.PlainTextContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBodyJsonString\n\t\t\t\tr.SetBodyJsonString(body)\n\t\t\t},\n\t\t\tContentType: header.JsonContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBodyJsonBytes\n\t\t\t\tr.SetBodyJsonBytes([]byte(body))\n\t\t\t},\n\t\t\tContentType: header.JsonContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBodyXmlString\n\t\t\t\tr.SetBodyXmlString(body)\n\t\t\t},\n\t\t\tContentType: header.XmlContentType,\n\t\t},\n\t\t{\n\t\t\tSetBody: func(r *Request) { // SetBodyXmlBytes\n\t\t\t\tr.SetBodyXmlBytes([]byte(body))\n\t\t\t},\n\t\t\tContentType: header.XmlContentType,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tr := c.R()\n\t\ttc.SetBody(r)\n\t\tvar e Echo\n\t\tresp, err := r.SetSuccessResult(&e).Post(\"/echo\")\n\t\tassertSuccess(t, resp, err)\n\t\ttests.AssertEqual(t, tc.ContentType, e.Header.Get(header.ContentType))\n\t\ttests.AssertEqual(t, body, e.Body)\n\t}\n}\n\nfunc TestCookie(t *testing.T) {\n\theaders := make(http.Header)\n\tresp, err := tc().R().SetCookies(\n\t\t&http.Cookie{\n\t\t\tName:  \"cookie1\",\n\t\t\tValue: \"value1\",\n\t\t},\n\t\t&http.Cookie{\n\t\t\tName:  \"cookie2\",\n\t\t\tValue: \"value2\",\n\t\t},\n\t).SetSuccessResult(&headers).Get(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"cookie1=value1; cookie2=value2\", headers.Get(\"Cookie\"))\n}\n\nfunc TestSetBasicAuth(t *testing.T) {\n\theaders := make(http.Header)\n\tresp, err := tc().R().\n\t\tSetBasicAuth(\"imroc\", \"123456\").\n\t\tSetSuccessResult(&headers).\n\t\tGet(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"Basic aW1yb2M6MTIzNDU2\", headers.Get(\"Authorization\"))\n}\n\nfunc TestSetBearerAuthToken(t *testing.T) {\n\ttoken := \"NGU1ZWYwZDJhNmZhZmJhODhmMjQ3ZDc4\"\n\theaders := make(http.Header)\n\tresp, err := tc().R().\n\t\tSetBearerAuthToken(token).\n\t\tSetSuccessResult(&headers).\n\t\tGet(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"Bearer \"+token, headers.Get(\"Authorization\"))\n}\n\nfunc TestHeader(t *testing.T) {\n\ttestWithAllTransport(t, testHeader)\n}\n\nfunc testHeader(t *testing.T, c *Client) {\n\t// Set User-Agent\n\tcustomUserAgent := \"My Custom User Agent\"\n\tresp, err := c.R().SetHeader(header.UserAgent, customUserAgent).Get(\"/user-agent\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, customUserAgent, resp.String())\n\n\t// Set custom header\n\theaders := make(http.Header)\n\tresp, err = c.R().\n\t\tSetHeader(\"header1\", \"value1\").\n\t\tSetHeaders(map[string]string{\n\t\t\t\"header2\": \"value2\",\n\t\t\t\"header3\": \"value3\",\n\t\t}).SetSuccessResult(&headers).\n\t\tGet(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"value1\", headers.Get(\"header1\"))\n\ttests.AssertEqual(t, \"value2\", headers.Get(\"header2\"))\n\ttests.AssertEqual(t, \"value3\", headers.Get(\"header3\"))\n}\n\nfunc TestSetHeaderNonCanonical(t *testing.T) {\n\t// set headers\n\tkey := \"spring.cloud.function.Routing-expression\"\n\tc := tc().EnableForceHTTP1()\n\tresp, err := c.R().EnableDumpWithoutResponse().\n\t\tSetHeadersNonCanonical(map[string]string{\n\t\t\tkey: \"test\",\n\t\t}).Get(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, strings.Contains(resp.Dump(), key))\n\n\tresp, err = c.R().\n\t\tEnableDumpWithoutResponse().\n\t\tSetHeaderNonCanonical(key, \"test\").\n\t\tGet(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, strings.Contains(resp.Dump(), key))\n\n\tc.SetCommonHeaderNonCanonical(key, \"test\")\n\tresp, err = c.R().\n\t\tEnableDumpWithoutResponse().\n\t\tGet(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, strings.Contains(resp.Dump(), key))\n}\n\nfunc TestQueryParam(t *testing.T) {\n\ttestWithAllTransport(t, testQueryParam)\n}\n\nfunc testQueryParam(t *testing.T, c *Client) {\n\t// Set query param at client level, should be overwritten at request level\n\tc.SetCommonQueryParam(\"key1\", \"client\").\n\t\tSetCommonQueryParams(map[string]string{\n\t\t\t\"key2\": \"client\",\n\t\t\t\"key3\": \"client\",\n\t\t}).\n\t\tSetCommonQueryString(\"key4=client&key5=client\").\n\t\tAddCommonQueryParam(\"key5\", \"extra\")\n\n\t// SetQueryParam\n\tresp, err := c.R().\n\t\tSetQueryParam(\"key1\", \"value1\").\n\t\tSetQueryParam(\"key2\", \"value2\").\n\t\tSetQueryParam(\"key3\", \"value3\").\n\t\tGet(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"key1=value1&key2=value2&key3=value3&key4=client&key5=client&key5=extra\", resp.String())\n\n\t// SetQueryString\n\tresp, err = c.R().\n\t\tSetQueryString(\"key1=value1&key2=value2&key3=value3\").\n\t\tGet(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"key1=value1&key2=value2&key3=value3&key4=client&key5=client&key5=extra\", resp.String())\n\n\t// SetQueryParams\n\tresp, err = c.R().\n\t\tSetQueryParams(map[string]string{\n\t\t\t\"key1\": \"value1\",\n\t\t\t\"key2\": \"value2\",\n\t\t\t\"key3\": \"value3\",\n\t\t}).\n\t\tGet(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"key1=value1&key2=value2&key3=value3&key4=client&key5=client&key5=extra\", resp.String())\n\n\t// SetQueryParam & SetQueryParams & SetQueryString\n\tresp, err = c.R().\n\t\tSetQueryParam(\"key1\", \"value1\").\n\t\tSetQueryParams(map[string]string{\n\t\t\t\"key2\": \"value2\",\n\t\t\t\"key3\": \"value3\",\n\t\t}).\n\t\tSetQueryString(\"key4=value4&key5=value5\").\n\t\tGet(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"key1=value1&key2=value2&key3=value3&key4=value4&key5=value5\", resp.String())\n\n\t// Add same param without override\n\tresp, err = c.R().\n\t\tSetQueryParam(\"key1\", \"value1\").\n\t\tSetQueryParams(map[string]string{\n\t\t\t\"key2\": \"value2\",\n\t\t\t\"key3\": \"value3\",\n\t\t}).\n\t\tSetQueryString(\"key4=value4&key5=value5\").\n\t\tAddQueryParam(\"key1\", \"value11\").\n\t\tAddQueryParam(\"key2\", \"value22\").\n\t\tAddQueryParam(\"key4\", \"value44\").\n\t\tAddQueryParams(\"key6\", \"value6\", \"value66\").\n\t\tGet(\"/query-parameter\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"key1=value1&key1=value11&key2=value2&key2=value22&key3=value3&key4=value4&key4=value44&key5=value5&key6=value6&key6=value66\", resp.String())\n}\n\nfunc TestPathParam(t *testing.T) {\n\ttestPathParam(t, tc())\n\ttestPathParam(t, tc().EnableForceHTTP1())\n}\n\nfunc testPathParam(t *testing.T, c *Client) {\n\tusername := \"imroc\"\n\tresp, err := c.R().\n\t\tSetPathParam(\"username\", username).\n\t\tGet(\"/user/{username}/profile\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, fmt.Sprintf(\"%s's profile\", username), resp.String())\n}\n\nfunc TestSuccess(t *testing.T) {\n\ttestWithAllTransport(t, testSuccess)\n}\n\nfunc testSuccess(t *testing.T, c *Client) {\n\tvar userInfo UserInfo\n\tresp, err := c.R().\n\t\tSetQueryParam(\"username\", \"imroc\").\n\t\tSetSuccessResult(&userInfo).\n\t\tGet(\"/search\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"roc@imroc.cc\", userInfo.Email)\n\n\tuserInfo = UserInfo{}\n\tresp, err = c.R().\n\t\tSetQueryParam(\"username\", \"imroc\").\n\t\tSetQueryParam(\"type\", \"xml\"). // auto unmarshal to xml\n\t\tSetSuccessResult(&userInfo).EnableDump().\n\t\tGet(\"/search\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"roc@imroc.cc\", userInfo.Email)\n}\n\nfunc TestError(t *testing.T) {\n\ttestWithAllTransport(t, testError)\n}\n\nfunc testError(t *testing.T, c *Client) {\n\tvar errMsg ErrorMessage\n\tresp, err := c.R().\n\t\tSetQueryParam(\"username\", \"\").\n\t\tSetErrorResult(&errMsg).\n\t\tGet(\"/search\")\n\tassertIsError(t, resp, err)\n\ttests.AssertEqual(t, 10000, errMsg.ErrorCode)\n\n\terrMsg = ErrorMessage{}\n\tresp, err = c.R().\n\t\tSetQueryParam(\"username\", \"test\").\n\t\tSetErrorResult(&errMsg).\n\t\tGet(\"/search\")\n\tassertIsError(t, resp, err)\n\ttests.AssertEqual(t, 10001, errMsg.ErrorCode)\n\n\terrMsg = ErrorMessage{}\n\tresp, err = c.R().\n\t\tSetQueryParam(\"username\", \"test\").\n\t\tSetQueryParam(\"type\", \"xml\"). // auto unmarshal to xml\n\t\tSetErrorResult(&errMsg).\n\t\tGet(\"/search\")\n\tassertIsError(t, resp, err)\n\ttests.AssertEqual(t, 10001, errMsg.ErrorCode)\n\n\tc.SetCommonErrorResult(&errMsg)\n\tresp, err = c.R().\n\t\tSetQueryParam(\"username\", \"\").\n\t\tGet(\"/search\")\n\tassertIsError(t, resp, err)\n\tem, ok := resp.Error().(*ErrorMessage)\n\ttests.AssertEqual(t, true, ok)\n\ttests.AssertEqual(t, 10000, em.ErrorCode)\n}\n\nfunc TestForm(t *testing.T) {\n\ttestWithAllTransport(t, testForm)\n}\n\nfunc testForm(t *testing.T, c *Client) {\n\tvar userInfo UserInfo\n\tresp, err := c.R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"username\": \"imroc\",\n\t\t\t\"type\":     \"xml\",\n\t\t}).\n\t\tSetSuccessResult(&userInfo).\n\t\tPost(\"/search\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"roc@imroc.cc\", userInfo.Email)\n\n\tv := make(url.Values)\n\tv.Add(\"username\", \"imroc\")\n\tv.Add(\"type\", \"xml\")\n\tresp, err = c.R().\n\t\tSetFormDataFromValues(v).\n\t\tSetSuccessResult(&userInfo).\n\t\tPost(\"/search\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"roc@imroc.cc\", userInfo.Email)\n}\n\nfunc TestHostHeaderOverride(t *testing.T) {\n\ttestWithAllTransport(t, testHostHeaderOverride)\n}\n\nfunc testHostHeaderOverride(t *testing.T, c *Client) {\n\tresp, err := c.R().SetHeader(\"Host\", \"testhostname\").Get(\"/host-header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"testhostname\", resp.String())\n}\n\nfunc assertTraceInfo(t *testing.T, resp *Response, enable bool) {\n\tti := resp.TraceInfo()\n\ttests.AssertEqual(t, true, resp.TotalTime() > 0)\n\tif !enable {\n\t\ttests.AssertEqual(t, false, ti.TotalTime > 0)\n\t\ttests.AssertIsNil(t, ti.RemoteAddr)\n\t\ttests.AssertContains(t, ti.String(), \"not enabled\", true)\n\t\ttests.AssertContains(t, ti.Blame(), \"not enabled\", true)\n\t\treturn\n\t}\n\n\ttests.AssertContains(t, ti.String(), \"not enabled\", false)\n\ttests.AssertContains(t, ti.Blame(), \"not enabled\", false)\n\ttests.AssertEqual(t, true, ti.TotalTime > 0)\n\ttests.AssertEqual(t, true, ti.ConnectTime > 0)\n\ttests.AssertEqual(t, true, ti.FirstResponseTime > 0)\n\ttests.AssertEqual(t, true, ti.ResponseTime > 0)\n\ttests.AssertNotNil(t, ti.RemoteAddr)\n\tif ti.IsConnReused {\n\t\ttests.AssertEqual(t, true, ti.TCPConnectTime == 0)\n\t\ttests.AssertEqual(t, true, ti.TLSHandshakeTime == 0)\n\t} else {\n\t\ttests.AssertEqual(t, true, ti.TCPConnectTime > 0)\n\t\ttests.AssertEqual(t, true, ti.TLSHandshakeTime > 0)\n\t}\n}\n\nfunc assertEnableTraceInfo(t *testing.T, resp *Response) {\n\tassertTraceInfo(t, resp, true)\n}\n\nfunc assertDisableTraceInfo(t *testing.T, resp *Response) {\n\tassertTraceInfo(t, resp, false)\n}\n\nfunc TestTraceInfo(t *testing.T) {\n\ttestWithAllTransport(t, testTraceInfo)\n}\n\nfunc testTraceInfo(t *testing.T, c *Client) {\n\t// enable trace at client level\n\tc.EnableTraceAll()\n\tresp, err := c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\tassertEnableTraceInfo(t, resp)\n\n\t// disable trace at client level\n\tc.DisableTraceAll()\n\tresp, err = c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\tassertDisableTraceInfo(t, resp)\n\n\t// enable trace at request level\n\tresp, err = c.R().EnableTrace().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\tassertEnableTraceInfo(t, resp)\n}\n\nfunc TestTraceOnTimeout(t *testing.T) {\n\ttestWithAllTransport(t, func(t *testing.T, c *Client) {\n\t\tc.EnableTraceAll().SetTimeout(100 * time.Millisecond)\n\n\t\tresp, err := c.R().Get(\"http://req-nowhere.local\")\n\t\ttests.AssertNotNil(t, err)\n\t\ttests.AssertNotNil(t, resp)\n\n\t\tti := resp.TraceInfo()\n\t\ttests.AssertEqual(t, true, ti.DNSLookupTime >= 0)\n\t\ttests.AssertEqual(t, true, ti.ConnectTime == 0)\n\t\ttests.AssertEqual(t, true, ti.TLSHandshakeTime == 0)\n\t\ttests.AssertEqual(t, true, ti.TCPConnectTime == 0)\n\t\ttests.AssertEqual(t, true, ti.FirstResponseTime == 0)\n\t\ttests.AssertEqual(t, true, ti.ResponseTime == 0)\n\t\ttests.AssertEqual(t, true, ti.TotalTime > 0)\n\t\ttests.AssertEqual(t, true, ti.TotalTime == resp.TotalTime())\n\t})\n}\n\nfunc TestAutoDetectRequestContentType(t *testing.T) {\n\tc := tc()\n\tresp, err := c.R().SetBody(getTestFileContent(t, \"sample-image.png\")).Post(\"/content-type\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"image/png\", resp.String())\n\n\tresp, err = c.R().SetBodyJsonString(`{\"msg\": \"test\"}`).Post(\"/content-type\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, header.JsonContentType, resp.String())\n\n\tresp, err = c.R().SetContentType(header.XmlContentType).SetBody(`{\"msg\": \"test\"}`).Post(\"/content-type\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, header.XmlContentType, resp.String())\n\n\tresp, err = c.R().SetBody(`<html><body><h1>hello</h1></body></html>`).Post(\"/content-type\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"text/html; charset=utf-8\", resp.String())\n\n\tresp, err = c.R().SetBody(`hello world`).Post(\"/content-type\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, header.PlainTextContentType, resp.String())\n}\n\nfunc TestSetFileUploadCheck(t *testing.T) {\n\tc := tc()\n\tresp, err := c.R().SetFileUpload(FileUpload{}).Post(\"/multipart\")\n\ttests.AssertErrorContains(t, err, \"missing param name\")\n\ttests.AssertErrorContains(t, err, \"missing filename\")\n\ttests.AssertErrorContains(t, err, \"missing file content\")\n\ttests.AssertEqual(t, 0, len(resp.Request.uploadFiles))\n}\n\nfunc TestUploadMultipart(t *testing.T) {\n\tm := make(map[string]interface{})\n\tresp, err := tc().R().\n\t\tSetFile(\"file\", tests.GetTestFilePath(\"sample-image.png\")).\n\t\tSetFiles(map[string]string{\"file\": tests.GetTestFilePath(\"sample-file.txt\")}).\n\t\tSetFormData(map[string]string{\n\t\t\t\"param1\": \"value1\",\n\t\t\t\"param2\": \"value2\",\n\t\t}).\n\t\tSetSuccessResult(&m).\n\t\tPost(\"/multipart\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertContains(t, resp.String(), \"sample-image.png\", true)\n\ttests.AssertContains(t, resp.String(), \"sample-file.txt\", true)\n\ttests.AssertContains(t, resp.String(), \"value1\", true)\n\ttests.AssertContains(t, resp.String(), \"value2\", true)\n}\n\nfunc TestFixPragmaCache(t *testing.T) {\n\tresp, err := tc().EnableForceHTTP1().R().Get(\"/pragma\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"no-cache\", resp.Header.Get(\"Cache-Control\"))\n}\n\nfunc TestSetFileBytes(t *testing.T) {\n\tresp := uploadTextFile(t, func(r *Request) {\n\t\tr.SetFileBytes(\"file\", \"file.txt\", []byte(\"test\"))\n\t})\n\ttests.AssertEqual(t, \"test\", resp.String())\n}\n\nfunc TestSetFileReader(t *testing.T) {\n\tbuff := bytes.NewBufferString(\"test\")\n\tresp := uploadTextFile(t, func(r *Request) {\n\t\tr.SetFileReader(\"file\", \"file.txt\", buff)\n\t})\n\ttests.AssertEqual(t, \"test\", resp.String())\n\n\tbuff = bytes.NewBufferString(\"test\")\n\tresp = uploadTextFile(t, func(r *Request) {\n\t\tr.SetFileReader(\"file\", \"file.txt\", io.NopCloser(buff))\n\t})\n\ttests.AssertEqual(t, \"test\", resp.String())\n}\n\nfunc TestSetFileWithRetry(t *testing.T) {\n\tresp, err := tc().R().\n\t\tSetRetryCount(3).\n\t\tSetRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn err != nil || resp.StatusCode > 499\n\t\t}).\n\t\tSetRetryHook(func(resp *Response, err error) {\n\t\t\tresp.Request.SetQueryParam(\"attempt\", strconv.Itoa(resp.Request.RetryAttempt))\n\t\t}).\n\t\tSetFile(\"file\", tests.GetTestFilePath(\"sample-file.txt\")).\n\t\tSetQueryParam(\"attempt\", \"0\").\n\t\tPost(\"/file-text\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, 2, resp.Request.RetryAttempt)\n}\n\nfunc TestSetFile(t *testing.T) {\n\tfilename := \"sample-file.txt\"\n\tresp := uploadTextFile(t, func(r *Request) {\n\t\tr.SetFile(\"file\", tests.GetTestFilePath(filename))\n\t})\n\ttests.AssertEqual(t, getTestFileContent(t, filename), resp.Bytes())\n\n\tresp, err := tc().SetLogger(nil).R().SetFile(\"file\", \"file-not-exists.txt\").Post(\"/file-text\")\n\ttests.AssertErrorContains(t, err, \"no such file\")\n}\n\nfunc TestSetFiles(t *testing.T) {\n\tfilename := \"sample-file.txt\"\n\tresp := uploadTextFile(t, func(r *Request) {\n\t\tr.SetFiles(map[string]string{\n\t\t\t\"file\": tests.GetTestFilePath(filename),\n\t\t})\n\t})\n\ttests.AssertEqual(t, getTestFileContent(t, filename), resp.Bytes())\n}\n\nfunc uploadTextFile(t *testing.T, setReq func(r *Request)) *Response {\n\tr := tc().R()\n\tsetReq(r)\n\tresp, err := r.Post(\"/file-text\")\n\tassertSuccess(t, resp, err)\n\treturn resp\n}\n\ntype SlowReader struct {\n\tio.ReadCloser\n}\n\nfunc (r *SlowReader) Read(p []byte) (int, error) {\n\ttime.Sleep(100 * time.Millisecond)\n\treturn r.ReadCloser.Read(p)\n}\n\nfunc TestUploadCallback(t *testing.T) {\n\tr := tc().R()\n\tfile := \"transport.go\"\n\tfileInfo, err := os.Stat(file)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr.SetFile(\"file\", file)\n\tr.uploadFiles[0].FileSize = fileInfo.Size()\n\tcontent, err := r.uploadFiles[0].GetFileContent()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr.uploadFiles[0].GetFileContent = func() (io.ReadCloser, error) {\n\t\treturn &SlowReader{content}, nil\n\t}\n\tn := 0\n\tr.SetUploadCallback(func(info UploadInfo) {\n\t\tn++\n\t})\n\tresp, err := r.Post(\"/raw-upload\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, n > 1)\n}\n\nfunc TestDownloadCallback(t *testing.T) {\n\tn := 0\n\tresp, err := tc().R().\n\t\tSetOutput(io.Discard).\n\t\tSetDownloadCallback(func(info DownloadInfo) {\n\t\t\tn++\n\t\t}).Get(\"/download\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, true, n > 0)\n}\n\nfunc TestRequestDisableAutoReadResponse(t *testing.T) {\n\ttestWithAllTransport(t, func(t *testing.T, c *Client) {\n\t\tresp, err := c.R().DisableAutoReadResponse().Get(\"/\")\n\t\tassertSuccess(t, resp, err)\n\t\ttests.AssertEqual(t, \"\", resp.String())\n\t\tresult, err := resp.ToString()\n\t\ttests.AssertNoError(t, err)\n\t\ttests.AssertEqual(t, \"TestGet: text response\", result)\n\n\t\tresp, err = c.R().DisableAutoReadResponse().Get(\"/\")\n\t\tassertSuccess(t, resp, err)\n\t\t_, err = io.ReadAll(resp.Body)\n\t\ttests.AssertNoError(t, err)\n\t})\n}\n\nfunc TestRestoreResponseBody(t *testing.T) {\n\tc := tc()\n\tresp, err := c.R().Get(\"/\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, true, len(resp.Bytes()) > 0)\n\tbody, err := io.ReadAll(resp.Body)\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, true, len(body) > 0)\n}\n"
        },
        {
          "name": "request_wrapper.go",
          "type": "blob",
          "size": 20.2890625,
          "content": "package req\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n)\n\n// SetURL is a global wrapper methods which delegated\n// to the default client, create a request and SetURL for request.\nfunc SetURL(url string) *Request {\n\treturn defaultClient.R().SetURL(url)\n}\n\n// SetFormDataFromValues is a global wrapper methods which delegated\n// to the default client, create a request and SetFormDataFromValues for request.\nfunc SetFormDataFromValues(data url.Values) *Request {\n\treturn defaultClient.R().SetFormDataFromValues(data)\n}\n\n// SetFormData is a global wrapper methods which delegated\n// to the default client, create a request and SetFormData for request.\nfunc SetFormData(data map[string]string) *Request {\n\treturn defaultClient.R().SetFormData(data)\n}\n\n// SetOrderedFormData is a global wrapper methods which delegated\n// to the default client, create a request and SetOrderedFormData for request.\nfunc SetOrderedFormData(kvs ...string) *Request {\n\treturn defaultClient.R().SetOrderedFormData(kvs...)\n}\n\n// SetFormDataAnyType is a global wrapper methods which delegated\n// to the default client, create a request and SetFormDataAnyType for request.\nfunc SetFormDataAnyType(data map[string]interface{}) *Request {\n\treturn defaultClient.R().SetFormDataAnyType(data)\n}\n\n// SetCookies is a global wrapper methods which delegated\n// to the default client, create a request and SetCookies for request.\nfunc SetCookies(cookies ...*http.Cookie) *Request {\n\treturn defaultClient.R().SetCookies(cookies...)\n}\n\n// SetQueryString is a global wrapper methods which delegated\n// to the default client, create a request and SetQueryString for request.\nfunc SetQueryString(query string) *Request {\n\treturn defaultClient.R().SetQueryString(query)\n}\n\n// SetFileReader is a global wrapper methods which delegated\n// to the default client, create a request and SetFileReader for request.\nfunc SetFileReader(paramName, filePath string, reader io.Reader) *Request {\n\treturn defaultClient.R().SetFileReader(paramName, filePath, reader)\n}\n\n// SetFileBytes is a global wrapper methods which delegated\n// to the default client, create a request and SetFileBytes for request.\nfunc SetFileBytes(paramName, filename string, content []byte) *Request {\n\treturn defaultClient.R().SetFileBytes(paramName, filename, content)\n}\n\n// SetFiles is a global wrapper methods which delegated\n// to the default client, create a request and SetFiles for request.\nfunc SetFiles(files map[string]string) *Request {\n\treturn defaultClient.R().SetFiles(files)\n}\n\n// SetFile is a global wrapper methods which delegated\n// to the default client, create a request and SetFile for request.\nfunc SetFile(paramName, filePath string) *Request {\n\treturn defaultClient.R().SetFile(paramName, filePath)\n}\n\n// SetFileUpload is a global wrapper methods which delegated\n// to the default client, create a request and SetFileUpload for request.\nfunc SetFileUpload(f ...FileUpload) *Request {\n\treturn defaultClient.R().SetFileUpload(f...)\n}\n\n// SetResult is a global wrapper methods which delegated\n// to the default client, create a request and SetSuccessResult for request.\n//\n// Deprecated: Use SetSuccessResult instead.\nfunc SetResult(result interface{}) *Request {\n\treturn defaultClient.R().SetSuccessResult(result)\n}\n\n// SetSuccessResult is a global wrapper methods which delegated\n// to the default client, create a request and SetSuccessResult for request.\nfunc SetSuccessResult(result interface{}) *Request {\n\treturn defaultClient.R().SetSuccessResult(result)\n}\n\n// SetError is a global wrapper methods which delegated\n// to the default client, create a request and SetErrorResult for request.\n//\n// Deprecated: Use SetErrorResult instead.\nfunc SetError(error interface{}) *Request {\n\treturn defaultClient.R().SetErrorResult(error)\n}\n\n// SetErrorResult is a global wrapper methods which delegated\n// to the default client, create a request and SetErrorResult for request.\nfunc SetErrorResult(error interface{}) *Request {\n\treturn defaultClient.R().SetErrorResult(error)\n}\n\n// SetBearerAuthToken is a global wrapper methods which delegated\n// to the default client, create a request and SetBearerAuthToken for request.\nfunc SetBearerAuthToken(token string) *Request {\n\treturn defaultClient.R().SetBearerAuthToken(token)\n}\n\n// SetBasicAuth is a global wrapper methods which delegated\n// to the default client, create a request and SetBasicAuth for request.\nfunc SetBasicAuth(username, password string) *Request {\n\treturn defaultClient.R().SetBasicAuth(username, password)\n}\n\n// SetDigestAuth is a global wrapper methods which delegated\n// to the default client, create a request and SetDigestAuth for request.\nfunc SetDigestAuth(username, password string) *Request {\n\treturn defaultClient.R().SetDigestAuth(username, password)\n}\n\n// SetHeaders is a global wrapper methods which delegated\n// to the default client, create a request and SetHeaders for request.\nfunc SetHeaders(hdrs map[string]string) *Request {\n\treturn defaultClient.R().SetHeaders(hdrs)\n}\n\n// SetHeader is a global wrapper methods which delegated\n// to the default client, create a request and SetHeader for request.\nfunc SetHeader(key, value string) *Request {\n\treturn defaultClient.R().SetHeader(key, value)\n}\n\n// SetHeaderOrder is a global wrapper methods which delegated\n// to the default client, create a request and SetHeaderOrder for request.\nfunc SetHeaderOrder(keys ...string) *Request {\n\treturn defaultClient.R().SetHeaderOrder(keys...)\n}\n\n// SetPseudoHeaderOrder is a global wrapper methods which delegated\n// to the default client, create a request and SetPseudoHeaderOrder for request.\nfunc SetPseudoHeaderOrder(keys ...string) *Request {\n\treturn defaultClient.R().SetPseudoHeaderOrder(keys...)\n}\n\n// SetOutputFile is a global wrapper methods which delegated\n// to the default client, create a request and SetOutputFile for request.\nfunc SetOutputFile(file string) *Request {\n\treturn defaultClient.R().SetOutputFile(file)\n}\n\n// SetOutput is a global wrapper methods which delegated\n// to the default client, create a request and SetOutput for request.\nfunc SetOutput(output io.Writer) *Request {\n\treturn defaultClient.R().SetOutput(output)\n}\n\n// SetQueryParams is a global wrapper methods which delegated\n// to the default client, create a request and SetQueryParams for request.\nfunc SetQueryParams(params map[string]string) *Request {\n\treturn defaultClient.R().SetQueryParams(params)\n}\n\n// SetQueryParamsAnyType is a global wrapper methods which delegated\n// to the default client, create a request and SetQueryParamsAnyType for request.\nfunc SetQueryParamsAnyType(params map[string]interface{}) *Request {\n\treturn defaultClient.R().SetQueryParamsAnyType(params)\n}\n\n// SetQueryParam is a global wrapper methods which delegated\n// to the default client, create a request and SetQueryParam for request.\nfunc SetQueryParam(key, value string) *Request {\n\treturn defaultClient.R().SetQueryParam(key, value)\n}\n\n// AddQueryParam is a global wrapper methods which delegated\n// to the default client, create a request and AddQueryParam for request.\nfunc AddQueryParam(key, value string) *Request {\n\treturn defaultClient.R().AddQueryParam(key, value)\n}\n\n// AddQueryParams is a global wrapper methods which delegated\n// to the default client, create a request and AddQueryParams for request.\nfunc AddQueryParams(key string, values ...string) *Request {\n\treturn defaultClient.R().AddQueryParams(key, values...)\n}\n\n// SetPathParams is a global wrapper methods which delegated\n// to the default client, create a request and SetPathParams for request.\nfunc SetPathParams(params map[string]string) *Request {\n\treturn defaultClient.R().SetPathParams(params)\n}\n\n// SetPathParam is a global wrapper methods which delegated\n// to the default client, create a request and SetPathParam for request.\nfunc SetPathParam(key, value string) *Request {\n\treturn defaultClient.R().SetPathParam(key, value)\n}\n\n// MustGet is a global wrapper methods which delegated\n// to the default client, create a request and MustGet for request.\nfunc MustGet(url string) *Response {\n\treturn defaultClient.R().MustGet(url)\n}\n\n// Get is a global wrapper methods which delegated\n// to the default client, create a request and Get for request.\nfunc Get(url string) (*Response, error) {\n\treturn defaultClient.R().Get(url)\n}\n\n// MustPost is a global wrapper methods which delegated\n// to the default client, create a request and Get for request.\nfunc MustPost(url string) *Response {\n\treturn defaultClient.R().MustPost(url)\n}\n\n// Post is a global wrapper methods which delegated\n// to the default client, create a request and Post for request.\nfunc Post(url string) (*Response, error) {\n\treturn defaultClient.R().Post(url)\n}\n\n// MustPut is a global wrapper methods which delegated\n// to the default client, create a request and MustPut for request.\nfunc MustPut(url string) *Response {\n\treturn defaultClient.R().MustPut(url)\n}\n\n// Put is a global wrapper methods which delegated\n// to the default client, create a request and Put for request.\nfunc Put(url string) (*Response, error) {\n\treturn defaultClient.R().Put(url)\n}\n\n// MustPatch is a global wrapper methods which delegated\n// to the default client, create a request and MustPatch for request.\nfunc MustPatch(url string) *Response {\n\treturn defaultClient.R().MustPatch(url)\n}\n\n// Patch is a global wrapper methods which delegated\n// to the default client, create a request and Patch for request.\nfunc Patch(url string) (*Response, error) {\n\treturn defaultClient.R().Patch(url)\n}\n\n// MustDelete is a global wrapper methods which delegated\n// to the default client, create a request and MustDelete for request.\nfunc MustDelete(url string) *Response {\n\treturn defaultClient.R().MustDelete(url)\n}\n\n// Delete is a global wrapper methods which delegated\n// to the default client, create a request and Delete for request.\nfunc Delete(url string) (*Response, error) {\n\treturn defaultClient.R().Delete(url)\n}\n\n// MustOptions is a global wrapper methods which delegated\n// to the default client, create a request and MustOptions for request.\nfunc MustOptions(url string) *Response {\n\treturn defaultClient.R().MustOptions(url)\n}\n\n// Options is a global wrapper methods which delegated\n// to the default client, create a request and Options for request.\nfunc Options(url string) (*Response, error) {\n\treturn defaultClient.R().Options(url)\n}\n\n// MustHead is a global wrapper methods which delegated\n// to the default client, create a request and MustHead for request.\nfunc MustHead(url string) *Response {\n\treturn defaultClient.R().MustHead(url)\n}\n\n// Head is a global wrapper methods which delegated\n// to the default client, create a request and Head for request.\nfunc Head(url string) (*Response, error) {\n\treturn defaultClient.R().Head(url)\n}\n\n// SetBody is a global wrapper methods which delegated\n// to the default client, create a request and SetBody for request.\nfunc SetBody(body interface{}) *Request {\n\treturn defaultClient.R().SetBody(body)\n}\n\n// SetBodyBytes is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyBytes for request.\nfunc SetBodyBytes(body []byte) *Request {\n\treturn defaultClient.R().SetBodyBytes(body)\n}\n\n// SetBodyString is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyString for request.\nfunc SetBodyString(body string) *Request {\n\treturn defaultClient.R().SetBodyString(body)\n}\n\n// SetBodyJsonString is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyJsonString for request.\nfunc SetBodyJsonString(body string) *Request {\n\treturn defaultClient.R().SetBodyJsonString(body)\n}\n\n// SetBodyJsonBytes is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyJsonBytes for request.\nfunc SetBodyJsonBytes(body []byte) *Request {\n\treturn defaultClient.R().SetBodyJsonBytes(body)\n}\n\n// SetBodyJsonMarshal is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyJsonMarshal for request.\nfunc SetBodyJsonMarshal(v interface{}) *Request {\n\treturn defaultClient.R().SetBodyJsonMarshal(v)\n}\n\n// SetBodyXmlString is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyXmlString for request.\nfunc SetBodyXmlString(body string) *Request {\n\treturn defaultClient.R().SetBodyXmlString(body)\n}\n\n// SetBodyXmlBytes is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyXmlBytes for request.\nfunc SetBodyXmlBytes(body []byte) *Request {\n\treturn defaultClient.R().SetBodyXmlBytes(body)\n}\n\n// SetBodyXmlMarshal is a global wrapper methods which delegated\n// to the default client, create a request and SetBodyXmlMarshal for request.\nfunc SetBodyXmlMarshal(v interface{}) *Request {\n\treturn defaultClient.R().SetBodyXmlMarshal(v)\n}\n\n// SetContentType is a global wrapper methods which delegated\n// to the default client, create a request and SetContentType for request.\nfunc SetContentType(contentType string) *Request {\n\treturn defaultClient.R().SetContentType(contentType)\n}\n\n// SetContext is a global wrapper methods which delegated\n// to the default client, create a request and SetContext for request.\nfunc SetContext(ctx context.Context) *Request {\n\treturn defaultClient.R().SetContext(ctx)\n}\n\n// DisableTrace is a global wrapper methods which delegated\n// to the default client, create a request and DisableTrace for request.\nfunc DisableTrace() *Request {\n\treturn defaultClient.R().DisableTrace()\n}\n\n// EnableTrace is a global wrapper methods which delegated\n// to the default client, create a request and EnableTrace for request.\nfunc EnableTrace() *Request {\n\treturn defaultClient.R().EnableTrace()\n}\n\n// EnableForceChunkedEncoding is a global wrapper methods which delegated\n// to the default client, create a request and EnableForceChunkedEncoding for request.\nfunc EnableForceChunkedEncoding() *Request {\n\treturn defaultClient.R().EnableForceChunkedEncoding()\n}\n\n// DisableForceChunkedEncoding is a global wrapper methods which delegated\n// to the default client, create a request and DisableForceChunkedEncoding for request.\nfunc DisableForceChunkedEncoding() *Request {\n\treturn defaultClient.R().DisableForceChunkedEncoding()\n}\n\n// EnableForceMultipart is a global wrapper methods which delegated\n// to the default client, create a request and EnableForceMultipart for request.\nfunc EnableForceMultipart() *Request {\n\treturn defaultClient.R().EnableForceMultipart()\n}\n\n// DisableForceMultipart is a global wrapper methods which delegated\n// to the default client, create a request and DisableForceMultipart for request.\nfunc DisableForceMultipart() *Request {\n\treturn defaultClient.R().DisableForceMultipart()\n}\n\n// EnableDumpTo is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpTo for request.\nfunc EnableDumpTo(output io.Writer) *Request {\n\treturn defaultClient.R().EnableDumpTo(output)\n}\n\n// EnableDumpToFile is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpToFile for request.\nfunc EnableDumpToFile(filename string) *Request {\n\treturn defaultClient.R().EnableDumpToFile(filename)\n}\n\n// SetDumpOptions is a global wrapper methods which delegated\n// to the default client, create a request and SetDumpOptions for request.\nfunc SetDumpOptions(opt *DumpOptions) *Request {\n\treturn defaultClient.R().SetDumpOptions(opt)\n}\n\n// EnableDump is a global wrapper methods which delegated\n// to the default client, create a request and EnableDump for request.\nfunc EnableDump() *Request {\n\treturn defaultClient.R().EnableDump()\n}\n\n// EnableDumpWithoutBody is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpWithoutBody for request.\nfunc EnableDumpWithoutBody() *Request {\n\treturn defaultClient.R().EnableDumpWithoutBody()\n}\n\n// EnableDumpWithoutHeader is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpWithoutHeader for request.\nfunc EnableDumpWithoutHeader() *Request {\n\treturn defaultClient.R().EnableDumpWithoutHeader()\n}\n\n// EnableDumpWithoutResponse is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpWithoutResponse for request.\nfunc EnableDumpWithoutResponse() *Request {\n\treturn defaultClient.R().EnableDumpWithoutResponse()\n}\n\n// EnableDumpWithoutRequest is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpWithoutRequest for request.\nfunc EnableDumpWithoutRequest() *Request {\n\treturn defaultClient.R().EnableDumpWithoutRequest()\n}\n\n// EnableDumpWithoutRequestBody is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpWithoutRequestBody for request.\nfunc EnableDumpWithoutRequestBody() *Request {\n\treturn defaultClient.R().EnableDumpWithoutRequestBody()\n}\n\n// EnableDumpWithoutResponseBody is a global wrapper methods which delegated\n// to the default client, create a request and EnableDumpWithoutResponseBody for request.\nfunc EnableDumpWithoutResponseBody() *Request {\n\treturn defaultClient.R().EnableDumpWithoutResponseBody()\n}\n\n// SetRetryCount is a global wrapper methods which delegated\n// to the default client, create a request and SetRetryCount for request.\nfunc SetRetryCount(count int) *Request {\n\treturn defaultClient.R().SetRetryCount(count)\n}\n\n// SetRetryInterval is a global wrapper methods which delegated\n// to the default client, create a request and SetRetryInterval for request.\nfunc SetRetryInterval(getRetryIntervalFunc GetRetryIntervalFunc) *Request {\n\treturn defaultClient.R().SetRetryInterval(getRetryIntervalFunc)\n}\n\n// SetRetryFixedInterval is a global wrapper methods which delegated\n// to the default client, create a request and SetRetryFixedInterval for request.\nfunc SetRetryFixedInterval(interval time.Duration) *Request {\n\treturn defaultClient.R().SetRetryFixedInterval(interval)\n}\n\n// SetRetryBackoffInterval is a global wrapper methods which delegated\n// to the default client, create a request and SetRetryBackoffInterval for request.\nfunc SetRetryBackoffInterval(min, max time.Duration) *Request {\n\treturn defaultClient.R().SetRetryBackoffInterval(min, max)\n}\n\n// SetRetryHook is a global wrapper methods which delegated\n// to the default client, create a request and SetRetryHook for request.\nfunc SetRetryHook(hook RetryHookFunc) *Request {\n\treturn defaultClient.R().SetRetryHook(hook)\n}\n\n// AddRetryHook is a global wrapper methods which delegated\n// to the default client, create a request and AddRetryHook for request.\nfunc AddRetryHook(hook RetryHookFunc) *Request {\n\treturn defaultClient.R().AddRetryHook(hook)\n}\n\n// SetRetryCondition is a global wrapper methods which delegated\n// to the default client, create a request and SetRetryCondition for request.\nfunc SetRetryCondition(condition RetryConditionFunc) *Request {\n\treturn defaultClient.R().SetRetryCondition(condition)\n}\n\n// AddRetryCondition is a global wrapper methods which delegated\n// to the default client, create a request and AddRetryCondition for request.\nfunc AddRetryCondition(condition RetryConditionFunc) *Request {\n\treturn defaultClient.R().AddRetryCondition(condition)\n}\n\n// SetUploadCallback is a global wrapper methods which delegated\n// to the default client, create a request and SetUploadCallback for request.\nfunc SetUploadCallback(callback UploadCallback) *Request {\n\treturn defaultClient.R().SetUploadCallback(callback)\n}\n\n// SetUploadCallbackWithInterval is a global wrapper methods which delegated\n// to the default client, create a request and SetUploadCallbackWithInterval for request.\nfunc SetUploadCallbackWithInterval(callback UploadCallback, minInterval time.Duration) *Request {\n\treturn defaultClient.R().SetUploadCallbackWithInterval(callback, minInterval)\n}\n\n// SetDownloadCallback is a global wrapper methods which delegated\n// to the default client, create a request and SetDownloadCallback for request.\nfunc SetDownloadCallback(callback DownloadCallback) *Request {\n\treturn defaultClient.R().SetDownloadCallback(callback)\n}\n\n// SetDownloadCallbackWithInterval is a global wrapper methods which delegated\n// to the default client, create a request and SetDownloadCallbackWithInterval for request.\nfunc SetDownloadCallbackWithInterval(callback DownloadCallback, minInterval time.Duration) *Request {\n\treturn defaultClient.R().SetDownloadCallbackWithInterval(callback, minInterval)\n}\n\n// EnableCloseConnection is a global wrapper methods which delegated\n// to the default client, create a request and EnableCloseConnection for request.\nfunc EnableCloseConnection() *Request {\n\treturn defaultClient.R().EnableCloseConnection()\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 8.494140625,
          "content": "package req\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/internal/header\"\n\t\"github.com/imroc/req/v3/internal/util\"\n)\n\n// Response is the http response.\ntype Response struct {\n\t// The underlying http.Response is embed into Response.\n\t*http.Response\n\t// Err is the underlying error, not nil if some error occurs.\n\t// Usually used in the ResponseMiddleware, you can skip logic in\n\t// ResponseMiddleware that doesn't need to be executed when err occurs.\n\tErr error\n\t// Request is the Response's related Request.\n\tRequest    *Request\n\tbody       []byte\n\treceivedAt time.Time\n\terror      interface{}\n\tresult     interface{}\n}\n\n// IsSuccess method returns true if no error occurs and HTTP status `code >= 200 and <= 299`\n// by default, you can also use Request.SetResultStateCheckFunc to customize the result\n// state check logic.\n//\n// Deprecated: Use IsSuccessState instead.\nfunc (r *Response) IsSuccess() bool {\n\treturn r.IsSuccessState()\n}\n\n// IsSuccessState method returns true if no error occurs and HTTP status `code >= 200 and <= 299`\n// by default, you can also use Request.SetResultStateCheckFunc to customize the result state\n// check logic.\nfunc (r *Response) IsSuccessState() bool {\n\tif r.Response == nil {\n\t\treturn false\n\t}\n\treturn r.ResultState() == SuccessState\n}\n\n// IsError method returns true if no error occurs and HTTP status `code >= 400`\n// by default, you can also use Request.SetResultStateCheckFunc to customize the result\n// state check logic.\n//\n// Deprecated: Use IsErrorState instead.\nfunc (r *Response) IsError() bool {\n\treturn r.IsErrorState()\n}\n\n// IsErrorState method returns true if no error occurs and HTTP status `code >= 400`\n// by default, you can also use Request.SetResultStateCheckFunc to customize the result\n// state check logic.\nfunc (r *Response) IsErrorState() bool {\n\tif r.Response == nil {\n\t\treturn false\n\t}\n\treturn r.ResultState() == ErrorState\n}\n\n// GetContentType return the `Content-Type` header value.\nfunc (r *Response) GetContentType() string {\n\tif r.Response == nil {\n\t\treturn \"\"\n\t}\n\treturn r.Header.Get(header.ContentType)\n}\n\n// ResultState returns the result state.\n// By default, it returns SuccessState if HTTP status `code >= 400`, and returns\n// ErrorState if HTTP status `code >= 400`, otherwise returns UnknownState.\n// You can also use Request.SetResultStateCheckFunc or Client.SetResultStateCheckFunc\n// to customize the result state check logic.\nfunc (r *Response) ResultState() ResultState {\n\tif r.Response == nil {\n\t\treturn UnknownState\n\t}\n\tvar resultStateCheckFunc func(resp *Response) ResultState\n\tif r.Request.client.resultStateCheckFunc != nil {\n\t\tresultStateCheckFunc = r.Request.client.resultStateCheckFunc\n\t} else {\n\t\tresultStateCheckFunc = defaultResultStateChecker\n\t}\n\treturn resultStateCheckFunc(r)\n}\n\n// Result returns the automatically unmarshalled object if Request.SetSuccessResult\n// is called and ResultState returns SuccessState.\n// Otherwise, return nil.\n//\n// Deprecated: Use SuccessResult instead.\nfunc (r *Response) Result() interface{} {\n\treturn r.SuccessResult()\n}\n\n// SuccessResult returns the automatically unmarshalled object if Request.SetSuccessResult\n// is called and ResultState returns SuccessState.\n// Otherwise, return nil.\nfunc (r *Response) SuccessResult() interface{} {\n\treturn r.result\n}\n\n// Error returns the automatically unmarshalled object when Request.SetErrorResult\n// or Client.SetCommonErrorResult is called, and ResultState returns ErrorState.\n// Otherwise, return nil.\n//\n// Deprecated: Use ErrorResult instead.\nfunc (r *Response) Error() interface{} {\n\treturn r.error\n}\n\n// ErrorResult returns the automatically unmarshalled object when Request.SetErrorResult\n// or Client.SetCommonErrorResult is called, and ResultState returns ErrorState.\n// Otherwise, return nil.\nfunc (r *Response) ErrorResult() interface{} {\n\treturn r.error\n}\n\n// TraceInfo returns the TraceInfo from Request.\nfunc (r *Response) TraceInfo() TraceInfo {\n\treturn r.Request.TraceInfo()\n}\n\n// TotalTime returns the total time of the request, from request we sent to response we received.\nfunc (r *Response) TotalTime() time.Duration {\n\tif r.Request.trace != nil {\n\t\treturn r.Request.TraceInfo().TotalTime\n\t}\n\tif !r.receivedAt.IsZero() {\n\t\treturn r.receivedAt.Sub(r.Request.StartTime)\n\t}\n\treturn r.Request.responseReturnTime.Sub(r.Request.StartTime)\n}\n\n// ReceivedAt returns the timestamp that response we received.\nfunc (r *Response) ReceivedAt() time.Time {\n\treturn r.receivedAt\n}\n\nfunc (r *Response) setReceivedAt() {\n\tr.receivedAt = time.Now()\n\tif r.Request.trace != nil {\n\t\tr.Request.trace.endTime = r.receivedAt\n\t}\n}\n\n// UnmarshalJson unmarshalls JSON response body into the specified object.\nfunc (r *Response) UnmarshalJson(v interface{}) error {\n\tif r.Err != nil {\n\t\treturn r.Err\n\t}\n\tb, err := r.ToBytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn r.Request.client.jsonUnmarshal(b, v)\n}\n\n// UnmarshalXml unmarshalls XML response body into the specified object.\nfunc (r *Response) UnmarshalXml(v interface{}) error {\n\tif r.Err != nil {\n\t\treturn r.Err\n\t}\n\tb, err := r.ToBytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn r.Request.client.xmlUnmarshal(b, v)\n}\n\n// Unmarshal unmarshalls response body into the specified object according\n// to response `Content-Type`.\nfunc (r *Response) Unmarshal(v interface{}) error {\n\tif r.Err != nil {\n\t\treturn r.Err\n\t}\n\tv = util.GetPointer(v)\n\tcontentType := r.Header.Get(\"Content-Type\")\n\tif strings.Contains(contentType, \"json\") {\n\t\treturn r.UnmarshalJson(v)\n\t} else if strings.Contains(contentType, \"xml\") {\n\t\treturn r.UnmarshalXml(v)\n\t}\n\treturn r.UnmarshalJson(v)\n}\n\n// Into unmarshalls response body into the specified object according\n// to response `Content-Type`.\nfunc (r *Response) Into(v interface{}) error {\n\treturn r.Unmarshal(v)\n}\n\n// Set response body with byte array content\nfunc (r *Response) SetBody(body []byte) {\n\tr.body = body\n}\n\n// Set response body with string content\nfunc (r *Response) SetBodyString(body string) {\n\tr.body = []byte(body)\n}\n\n// Bytes return the response body as []bytes that have already been read, could be\n// nil if not read, the following cases are already read:\n//  1. `Request.SetResult` or `Request.SetError` is called.\n//  2. `Client.DisableAutoReadResponse` and `Request.DisableAutoReadResponse` is not\n//     called, and also `Request.SetOutput` and `Request.SetOutputFile` is not called.\nfunc (r *Response) Bytes() []byte {\n\treturn r.body\n}\n\n// String returns the response body as string that have already been read, could be\n// nil if not read, the following cases are already read:\n//  1. `Request.SetResult` or `Request.SetError` is called.\n//  2. `Client.DisableAutoReadResponse` and `Request.DisableAutoReadResponse` is not\n//     called, and also `Request.SetOutput` and `Request.SetOutputFile` is not called.\nfunc (r *Response) String() string {\n\treturn string(r.body)\n}\n\n// ToString returns the response body as string, read body if not have been read.\nfunc (r *Response) ToString() (string, error) {\n\tb, err := r.ToBytes()\n\treturn string(b), err\n}\n\n// ToBytes returns the response body as []byte, read body if not have been read.\nfunc (r *Response) ToBytes() (body []byte, err error) {\n\tif r.Err != nil {\n\t\treturn nil, r.Err\n\t}\n\tif r.body != nil {\n\t\treturn r.body, nil\n\t}\n\tif r.Response == nil || r.Response.Body == nil {\n\t\treturn []byte{}, nil\n\t}\n\tdefer func() {\n\t\tr.Body.Close()\n\t\tif err != nil {\n\t\t\tr.Err = err\n\t\t}\n\t\tr.body = body\n\t}()\n\tbody, err = io.ReadAll(r.Body)\n\tr.setReceivedAt()\n\tif err == nil && r.Request.client.responseBodyTransformer != nil {\n\t\tbody, err = r.Request.client.responseBodyTransformer(body, r.Request, r)\n\t}\n\treturn\n}\n\n// Dump return the string content that have been dumped for the request.\n// `Request.Dump` or `Request.DumpXXX` MUST have been called.\nfunc (r *Response) Dump() string {\n\treturn r.Request.getDumpBuffer().String()\n}\n\n// GetStatus returns the response status.\nfunc (r *Response) GetStatus() string {\n\tif r.Response == nil {\n\t\treturn \"\"\n\t}\n\treturn r.Status\n}\n\n// GetStatusCode returns the response status code.\nfunc (r *Response) GetStatusCode() int {\n\tif r.Response == nil {\n\t\treturn 0\n\t}\n\treturn r.StatusCode\n}\n\n// GetHeader returns the response header value by key.\nfunc (r *Response) GetHeader(key string) string {\n\tif r.Response == nil {\n\t\treturn \"\"\n\t}\n\treturn r.Header.Get(key)\n}\n\n// GetHeaderValues returns the response header values by key.\nfunc (r *Response) GetHeaderValues(key string) []string {\n\tif r.Response == nil {\n\t\treturn nil\n\t}\n\treturn r.Header.Values(key)\n}\n\n// HeaderToString get all header as string.\nfunc (r *Response) HeaderToString() string {\n\tif r.Response == nil {\n\t\treturn \"\"\n\t}\n\treturn convertHeaderToString(r.Header)\n}\n"
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 1.5283203125,
          "content": "package req\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc defaultGetRetryInterval(resp *Response, attempt int) time.Duration {\n\treturn 100 * time.Millisecond\n}\n\n// RetryConditionFunc is a retry condition, which determines\n// whether the request should retry.\ntype RetryConditionFunc func(resp *Response, err error) bool\n\n// RetryHookFunc is a retry hook which will be executed before a retry.\ntype RetryHookFunc func(resp *Response, err error)\n\n// GetRetryIntervalFunc is a function that determines how long should\n// sleep between retry attempts.\ntype GetRetryIntervalFunc func(resp *Response, attempt int) time.Duration\n\nfunc backoffInterval(min, max time.Duration) GetRetryIntervalFunc {\n\tbase := float64(min)\n\tcapLevel := float64(max)\n\treturn func(resp *Response, attempt int) time.Duration {\n\t\ttemp := math.Min(capLevel, base*math.Exp2(float64(attempt)))\n\t\thalfTemp := int64(temp / 2)\n\t\tsleep := halfTemp + rand.Int63n(halfTemp)\n\t\treturn time.Duration(sleep)\n\t}\n}\n\nfunc newDefaultRetryOption() *retryOption {\n\treturn &retryOption{\n\t\tGetRetryInterval: defaultGetRetryInterval,\n\t}\n}\n\ntype retryOption struct {\n\tMaxRetries       int\n\tGetRetryInterval GetRetryIntervalFunc\n\tRetryConditions  []RetryConditionFunc\n\tRetryHooks       []RetryHookFunc\n}\n\nfunc (ro *retryOption) Clone() *retryOption {\n\tif ro == nil {\n\t\treturn nil\n\t}\n\to := &retryOption{\n\t\tMaxRetries:       ro.MaxRetries,\n\t\tGetRetryInterval: ro.GetRetryInterval,\n\t}\n\to.RetryConditions = append(o.RetryConditions, ro.RetryConditions...)\n\to.RetryHooks = append(o.RetryHooks, ro.RetryHooks...)\n\treturn o\n}\n"
        },
        {
          "name": "retry_test.go",
          "type": "blob",
          "size": 5.43359375,
          "content": "package req\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/internal/tests\"\n)\n\nfunc TestRetryBackOff(t *testing.T) {\n\ttestRetry(t, func(r *Request) {\n\t\tr.SetRetryBackoffInterval(10*time.Millisecond, 1*time.Second)\n\t})\n}\n\nfunc testRetry(t *testing.T, setFunc func(r *Request)) {\n\tattempt := 0\n\tr := tc().R().\n\t\tSetRetryCount(3).\n\t\tSetRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn (err != nil) || (resp.StatusCode == http.StatusTooManyRequests)\n\t\t}).\n\t\tSetRetryHook(func(resp *Response, err error) {\n\t\t\tattempt++\n\t\t})\n\tsetFunc(r)\n\tresp, err := r.Get(\"/too-many\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, 3, resp.Request.RetryAttempt)\n\ttests.AssertEqual(t, 3, attempt)\n}\n\nfunc TestRetryInterval(t *testing.T) {\n\ttestRetry(t, func(r *Request) {\n\t\tr.SetRetryInterval(func(resp *Response, attempt int) time.Duration {\n\t\t\tsleep := 0.01 * math.Exp2(float64(attempt))\n\t\t\treturn time.Duration(math.Min(2, sleep)) * time.Second\n\t\t})\n\t})\n}\n\nfunc TestRetryFixedInterval(t *testing.T) {\n\ttestRetry(t, func(r *Request) {\n\t\tr.SetRetryFixedInterval(1 * time.Millisecond)\n\t})\n}\n\nfunc TestAddRetryHook(t *testing.T) {\n\ttest := \"test1\"\n\ttestRetry(t, func(r *Request) {\n\t\tr.AddRetryHook(func(resp *Response, err error) {\n\t\t\ttest = \"test2\"\n\t\t})\n\t})\n\ttests.AssertEqual(t, \"test2\", test)\n}\n\nfunc TestRetryOverride(t *testing.T) {\n\tc := tc().\n\t\tSetCommonRetryCount(3).\n\t\tSetCommonRetryHook(func(resp *Response, err error) {}).\n\t\tAddCommonRetryHook(func(resp *Response, err error) {}).\n\t\tSetCommonRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn false\n\t\t}).SetCommonRetryBackoffInterval(1*time.Millisecond, 10*time.Millisecond)\n\ttest := \"test\"\n\tresp, err := c.R().SetRetryFixedInterval(2 * time.Millisecond).\n\t\tSetRetryCount(2).\n\t\tSetRetryHook(func(resp *Response, err error) {\n\t\t\ttest = \"test1\"\n\t\t}).SetRetryCondition(func(resp *Response, err error) bool {\n\t\treturn err != nil || resp.StatusCode == http.StatusTooManyRequests\n\t}).Get(\"/too-many\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, \"test1\", test)\n\ttests.AssertEqual(t, 2, resp.Request.RetryAttempt)\n}\n\nfunc TestAddRetryCondition(t *testing.T) {\n\tattempt := 0\n\tresp, err := tc().R().\n\t\tSetRetryCount(3).\n\t\tAddRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn err != nil\n\t\t}).\n\t\tAddRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn resp.StatusCode == http.StatusServiceUnavailable\n\t\t}).\n\t\tSetRetryHook(func(resp *Response, err error) {\n\t\t\tattempt++\n\t\t}).Get(\"/too-many\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, 0, attempt)\n\ttests.AssertEqual(t, 0, resp.Request.RetryAttempt)\n\n\tattempt = 0\n\tresp, err = tc().\n\t\tSetCommonRetryCount(3).\n\t\tAddCommonRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn err != nil\n\t\t}).\n\t\tAddCommonRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn resp.StatusCode == http.StatusServiceUnavailable\n\t\t}).\n\t\tSetCommonRetryHook(func(resp *Response, err error) {\n\t\t\tattempt++\n\t\t}).R().Get(\"/too-many\")\n\ttests.AssertNoError(t, err)\n\ttests.AssertEqual(t, 0, attempt)\n\ttests.AssertEqual(t, 0, resp.Request.RetryAttempt)\n\n}\n\nfunc TestRetryWithUnreplayableBody(t *testing.T) {\n\t_, err := tc().R().\n\t\tSetRetryCount(1).\n\t\tSetBody(bytes.NewBufferString(\"test\")).\n\t\tPost(\"/\")\n\ttests.AssertEqual(t, errRetryableWithUnReplayableBody, err)\n\n\t_, err = tc().R().\n\t\tSetRetryCount(1).\n\t\tSetBody(io.NopCloser(bytes.NewBufferString(\"test\"))).\n\t\tPost(\"/\")\n\ttests.AssertEqual(t, errRetryableWithUnReplayableBody, err)\n}\n\nfunc TestRetryWithSetResult(t *testing.T) {\n\theaders := make(http.Header)\n\tresp, err := tc().SetCommonCookies(&http.Cookie{\n\t\tName:  \"test\",\n\t\tValue: \"test\",\n\t}).R().\n\t\tSetRetryCount(1).\n\t\tSetResult(&headers).\n\t\tGet(\"/header\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, \"test=test\", headers.Get(\"Cookie\"))\n}\n\nfunc TestRetryWithModify(t *testing.T) {\n\ttokens := []string{\"badtoken1\", \"badtoken2\", \"goodtoken\"}\n\ttokenIndex := 0\n\tc := tc().\n\t\tSetCommonRetryCount(2).\n\t\tSetCommonRetryHook(func(resp *Response, err error) {\n\t\t\ttokenIndex++\n\t\t\tresp.Request.SetBearerAuthToken(tokens[tokenIndex])\n\t\t}).SetCommonRetryCondition(func(resp *Response, err error) bool {\n\t\treturn err != nil || resp.StatusCode == http.StatusUnauthorized\n\t})\n\n\tresp, err := c.R().\n\t\tSetBearerAuthToken(tokens[tokenIndex]).\n\t\tGet(\"/protected\")\n\tassertSuccess(t, resp, err)\n\ttests.AssertEqual(t, 2, resp.Request.RetryAttempt)\n}\n\nfunc TestRetryFalse(t *testing.T) {\n\tresp, err := tc().SetTimeout(2 * time.Second).R().\n\t\tSetRetryCount(1).\n\t\tSetRetryCondition(func(resp *Response, err error) bool {\n\t\t\treturn false\n\t\t}).Get(\"https://non-exists-host.com.cn\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertIsNil(t, resp.Response)\n\ttests.AssertEqual(t, 0, resp.Request.RetryAttempt)\n}\n\nfunc TestRetryTurnedOffWhenRetryCountEqZero(t *testing.T) {\n\tresp, err := tc().SetTimeout(2 * time.Second).R().\n\t\tSetRetryCount(0).\n\t\tSetRetryCondition(func(resp *Response, err error) bool {\n\t\t\tt.Fatal(\"retry condition should not be executed\")\n\t\t\treturn true\n\t\t}).\n\t\tGet(\"https://non-exists-host.com.cn\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertIsNil(t, resp.Response)\n\ttests.AssertEqual(t, 0, resp.Request.RetryAttempt)\n\n\tresp, err = tc().SetTimeout(2 * time.Second).\n\t\tSetCommonRetryCount(0).\n\t\tSetCommonRetryCondition(func(resp *Response, err error) bool {\n\t\t\tt.Fatal(\"retry condition should not be executed\")\n\t\t\treturn true\n\t\t}).\n\t\tR().\n\t\tGet(\"https://non-exists-host.com.cn\")\n\ttests.AssertNotNil(t, err)\n\ttests.AssertIsNil(t, resp.Response)\n\ttests.AssertEqual(t, 0, resp.Request.RetryAttempt)\n}\n"
        },
        {
          "name": "roundtrip.go",
          "type": "blob",
          "size": 0.8779296875,
          "content": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !js\n\npackage req\n\nimport (\n\t\"net/http\"\n)\n\n// RoundTrip implements the RoundTripper interface.\n//\n// For higher-level HTTP client support (such as handling of cookies\n// and redirects), see Get, Post, and the Client type.\n//\n// Like the RoundTripper interface, the error types returned\n// by RoundTrip are unspecified.\nfunc (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) {\n\tif t.wrappedRoundTrip != nil {\n\t\tresp, err = t.wrappedRoundTrip.RoundTrip(req)\n\t} else {\n\t\tresp, err = t.roundTrip(req)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\tif resp.ProtoMajor != 3 && t.altSvcJar != nil {\n\t\tif v := resp.Header.Get(\"alt-svc\"); v != \"\" {\n\t\t\tt.handleAltSvc(req, v)\n\t\t}\n\t}\n\tt.handleResponseBody(resp, req)\n\treturn\n}\n"
        },
        {
          "name": "roundtrip_js.go",
          "type": "blob",
          "size": 11.85546875,
          "content": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build js && wasm\n\npackage req\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall/js\"\n\n\t\"github.com/imroc/req/v3/internal/ascii\"\n)\n\nvar uint8Array = js.Global().Get(\"Uint8Array\")\n\n// jsFetchMode is a Request.Header map key that, if present,\n// signals that the map entry is actually an option to the Fetch API mode setting.\n// Valid values are: \"cors\", \"no-cors\", \"same-origin\", \"navigate\"\n// The default is \"same-origin\".\n//\n// Reference: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters\nconst jsFetchMode = \"js.fetch:mode\"\n\n// jsFetchCreds is a Request.Header map key that, if present,\n// signals that the map entry is actually an option to the Fetch API credentials setting.\n// Valid values are: \"omit\", \"same-origin\", \"include\"\n// The default is \"same-origin\".\n//\n// Reference: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters\nconst jsFetchCreds = \"js.fetch:credentials\"\n\n// jsFetchRedirect is a Request.Header map key that, if present,\n// signals that the map entry is actually an option to the Fetch API redirect setting.\n// Valid values are: \"follow\", \"error\", \"manual\"\n// The default is \"follow\".\n//\n// Reference: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters\nconst jsFetchRedirect = \"js.fetch:redirect\"\n\n// jsFetchMissing will be true if the Fetch API is not present in\n// the browser globals.\nvar jsFetchMissing = js.Global().Get(\"fetch\").IsUndefined()\n\n// jsFetchDisabled controls whether the use of Fetch API is disabled.\n// It's set to true when we detect we're running in Node.js, so that\n// RoundTrip ends up talking over the same fake network the HTTP servers\n// currently use in various tests and examples. See go.dev/issue/57613.\n//\n// TODO(go.dev/issue/60810): See if it's viable to test the Fetch API\n// code path.\nvar jsFetchDisabled = js.Global().Get(\"process\").Type() == js.TypeObject &&\n\tstrings.HasPrefix(js.Global().Get(\"process\").Get(\"argv0\").String(), \"node\")\n\n// RoundTrip implements the [RoundTripper] interface using the WHATWG Fetch API.\nfunc (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {\n\t// The Transport has a documented contract that states that if the DialContext or\n\t// DialTLSContext functions are set, they will be used to set up the connections.\n\t// If they aren't set then the documented contract is to use Dial or DialTLS, even\n\t// though they are deprecated. Therefore, if any of these are set, we should obey\n\t// the contract and dial using the regular round-trip instead. Otherwise, we'll try\n\t// to fall back on the Fetch API, unless it's not available.\n\tif t.DialContext != nil || t.DialTLSContext != nil || jsFetchMissing || jsFetchDisabled {\n\t\treturn t.roundTrip(req)\n\t}\n\n\tac := js.Global().Get(\"AbortController\")\n\tif !ac.IsUndefined() {\n\t\t// Some browsers that support WASM don't necessarily support\n\t\t// the AbortController. See\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/AbortController#Browser_compatibility.\n\t\tac = ac.New()\n\t}\n\n\topt := js.Global().Get(\"Object\").New()\n\t// See https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n\t// for options available.\n\topt.Set(\"method\", req.Method)\n\topt.Set(\"credentials\", \"same-origin\")\n\tif h := req.Header.Get(jsFetchCreds); h != \"\" {\n\t\topt.Set(\"credentials\", h)\n\t\treq.Header.Del(jsFetchCreds)\n\t}\n\tif h := req.Header.Get(jsFetchMode); h != \"\" {\n\t\topt.Set(\"mode\", h)\n\t\treq.Header.Del(jsFetchMode)\n\t}\n\tif h := req.Header.Get(jsFetchRedirect); h != \"\" {\n\t\topt.Set(\"redirect\", h)\n\t\treq.Header.Del(jsFetchRedirect)\n\t}\n\tif !ac.IsUndefined() {\n\t\topt.Set(\"signal\", ac.Get(\"signal\"))\n\t}\n\theaders := js.Global().Get(\"Headers\").New()\n\tfor key, values := range req.Header {\n\t\tfor _, value := range values {\n\t\t\theaders.Call(\"append\", key, value)\n\t\t}\n\t}\n\topt.Set(\"headers\", headers)\n\n\tif req.Body != nil {\n\t\t// TODO(johanbrandhorst): Stream request body when possible.\n\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=688906 for Blink issue.\n\t\t// See https://bugzilla.mozilla.org/show_bug.cgi?id=1387483 for Firefox issue.\n\t\t// See https://github.com/web-platform-tests/wpt/issues/7693 for WHATWG tests issue.\n\t\t// See https://developer.mozilla.org/en-US/docs/Web/API/Streams_API for more details on the Streams API\n\t\t// and browser support.\n\t\t// NOTE(haruyama480): Ensure HTTP/1 fallback exists.\n\t\t// See https://go.dev/issue/61889 for discussion.\n\t\tbody, err := io.ReadAll(req.Body)\n\t\tif err != nil {\n\t\t\treq.Body.Close() // RoundTrip must always close the body, including on errors.\n\t\t\treturn nil, err\n\t\t}\n\t\treq.Body.Close()\n\t\tif len(body) != 0 {\n\t\t\tbuf := uint8Array.New(len(body))\n\t\t\tjs.CopyBytesToJS(buf, body)\n\t\t\topt.Set(\"body\", buf)\n\t\t}\n\t}\n\n\tfetchPromise := js.Global().Call(\"fetch\", req.URL.String(), opt)\n\tvar (\n\t\trespCh           = make(chan *http.Response, 1)\n\t\terrCh            = make(chan error, 1)\n\t\tsuccess, failure js.Func\n\t)\n\tsuccess = js.FuncOf(func(this js.Value, args []js.Value) any {\n\t\tsuccess.Release()\n\t\tfailure.Release()\n\n\t\tresult := args[0]\n\t\theader := http.Header{}\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Headers/entries\n\t\theadersIt := result.Get(\"headers\").Call(\"entries\")\n\t\tfor {\n\t\t\tn := headersIt.Call(\"next\")\n\t\t\tif n.Get(\"done\").Bool() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tpair := n.Get(\"value\")\n\t\t\tkey, value := pair.Index(0).String(), pair.Index(1).String()\n\t\t\tck := http.CanonicalHeaderKey(key)\n\t\t\theader[ck] = append(header[ck], value)\n\t\t}\n\n\t\tcontentLength := int64(0)\n\t\tclHeader := header.Get(\"Content-Length\")\n\t\tswitch {\n\t\tcase clHeader != \"\":\n\t\t\tcl, err := strconv.ParseInt(clHeader, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- fmt.Errorf(\"net/http: ill-formed Content-Length header: %v\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif cl < 0 {\n\t\t\t\t// Content-Length values less than 0 are invalid.\n\t\t\t\t// See: https://datatracker.ietf.org/doc/html/rfc2616/#section-14.13\n\t\t\t\terrCh <- fmt.Errorf(\"net/http: invalid Content-Length header: %q\", clHeader)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tcontentLength = cl\n\t\tdefault:\n\t\t\t// If the response length is not declared, set it to -1.\n\t\t\tcontentLength = -1\n\t\t}\n\n\t\tb := result.Get(\"body\")\n\t\tvar body io.ReadCloser\n\t\t// The body is undefined when the browser does not support streaming response bodies (Firefox),\n\t\t// and null in certain error cases, i.e. when the request is blocked because of CORS settings.\n\t\tif !b.IsUndefined() && !b.IsNull() {\n\t\t\tbody = &streamReader{stream: b.Call(\"getReader\")}\n\t\t} else {\n\t\t\t// Fall back to using ArrayBuffer\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/Body/arrayBuffer\n\t\t\tbody = &arrayReader{arrayPromise: result.Call(\"arrayBuffer\")}\n\t\t}\n\n\t\tcode := result.Get(\"status\").Int()\n\n\t\tuncompressed := false\n\t\tif ascii.EqualFold(header.Get(\"Content-Encoding\"), \"gzip\") {\n\t\t\t// The fetch api will decode the gzip, but Content-Encoding not be deleted.\n\t\t\theader.Del(\"Content-Encoding\")\n\t\t\theader.Del(\"Content-Length\")\n\t\t\tcontentLength = -1\n\t\t\tuncompressed = true\n\t\t}\n\t\trespCh <- &http.Response{\n\t\t\tStatus:        fmt.Sprintf(\"%d %s\", code, http.StatusText(code)),\n\t\t\tStatusCode:    code,\n\t\t\tHeader:        header,\n\t\t\tContentLength: contentLength,\n\t\t\tUncompressed:  uncompressed,\n\t\t\tBody:          body,\n\t\t\tRequest:       req,\n\t\t}\n\n\t\treturn nil\n\t})\n\tfailure = js.FuncOf(func(this js.Value, args []js.Value) any {\n\t\tsuccess.Release()\n\t\tfailure.Release()\n\n\t\terr := args[0]\n\t\t// The error is a JS Error type\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\n\t\t// We can use the toString() method to get a string representation of the error.\n\t\terrMsg := err.Call(\"toString\").String()\n\t\t// Errors can optionally contain a cause.\n\t\tif cause := err.Get(\"cause\"); !cause.IsUndefined() {\n\t\t\t// The exact type of the cause is not defined,\n\t\t\t// but if it's another error, we can call toString() on it too.\n\t\t\tif !cause.Get(\"toString\").IsUndefined() {\n\t\t\t\terrMsg += \": \" + cause.Call(\"toString\").String()\n\t\t\t} else if cause.Type() == js.TypeString {\n\t\t\t\terrMsg += \": \" + cause.String()\n\t\t\t}\n\t\t}\n\t\terrCh <- fmt.Errorf(\"net/http: fetch() failed: %s\", errMsg)\n\t\treturn nil\n\t})\n\n\tfetchPromise.Call(\"then\", success, failure)\n\tselect {\n\tcase <-req.Context().Done():\n\t\tif !ac.IsUndefined() {\n\t\t\t// Abort the Fetch request.\n\t\t\tac.Call(\"abort\")\n\t\t}\n\t\treturn nil, req.Context().Err()\n\tcase resp := <-respCh:\n\t\treturn resp, nil\n\tcase err := <-errCh:\n\t\treturn nil, err\n\t}\n}\n\nvar errClosed = errors.New(\"net/http: reader is closed\")\n\n// streamReader implements an io.ReadCloser wrapper for ReadableStream.\n// See https://fetch.spec.whatwg.org/#readablestream for more information.\ntype streamReader struct {\n\tpending []byte\n\tstream  js.Value\n\terr     error // sticky read error\n}\n\nfunc (r *streamReader) Read(p []byte) (n int, err error) {\n\tif r.err != nil {\n\t\treturn 0, r.err\n\t}\n\tif len(r.pending) == 0 {\n\t\tvar (\n\t\t\tbCh   = make(chan []byte, 1)\n\t\t\terrCh = make(chan error, 1)\n\t\t)\n\t\tsuccess := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t\tresult := args[0]\n\t\t\tif result.Get(\"done\").Bool() {\n\t\t\t\terrCh <- io.EOF\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tvalue := make([]byte, result.Get(\"value\").Get(\"byteLength\").Int())\n\t\t\tjs.CopyBytesToGo(value, result.Get(\"value\"))\n\t\t\tbCh <- value\n\t\t\treturn nil\n\t\t})\n\t\tdefer success.Release()\n\t\tfailure := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t\t// Assumes it's a TypeError. See\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n\t\t\t// for more information on this type. See\n\t\t\t// https://streams.spec.whatwg.org/#byob-reader-read for the spec on\n\t\t\t// the read method.\n\t\t\terrCh <- errors.New(args[0].Get(\"message\").String())\n\t\t\treturn nil\n\t\t})\n\t\tdefer failure.Release()\n\t\tr.stream.Call(\"read\").Call(\"then\", success, failure)\n\t\tselect {\n\t\tcase b := <-bCh:\n\t\t\tr.pending = b\n\t\tcase err := <-errCh:\n\t\t\tr.err = err\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tn = copy(p, r.pending)\n\tr.pending = r.pending[n:]\n\treturn n, nil\n}\n\nfunc (r *streamReader) Close() error {\n\t// This ignores any error returned from cancel method. So far, I did not encounter any concrete\n\t// situation where reporting the error is meaningful. Most users ignore error from resp.Body.Close().\n\t// If there's a need to report error here, it can be implemented and tested when that need comes up.\n\tr.stream.Call(\"cancel\")\n\tif r.err == nil {\n\t\tr.err = errClosed\n\t}\n\treturn nil\n}\n\n// arrayReader implements an io.ReadCloser wrapper for ArrayBuffer.\n// https://developer.mozilla.org/en-US/docs/Web/API/Body/arrayBuffer.\ntype arrayReader struct {\n\tarrayPromise js.Value\n\tpending      []byte\n\tread         bool\n\terr          error // sticky read error\n}\n\nfunc (r *arrayReader) Read(p []byte) (n int, err error) {\n\tif r.err != nil {\n\t\treturn 0, r.err\n\t}\n\tif !r.read {\n\t\tr.read = true\n\t\tvar (\n\t\t\tbCh   = make(chan []byte, 1)\n\t\t\terrCh = make(chan error, 1)\n\t\t)\n\t\tsuccess := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t\t// Wrap the input ArrayBuffer with a Uint8Array\n\t\t\tuint8arrayWrapper := uint8Array.New(args[0])\n\t\t\tvalue := make([]byte, uint8arrayWrapper.Get(\"byteLength\").Int())\n\t\t\tjs.CopyBytesToGo(value, uint8arrayWrapper)\n\t\t\tbCh <- value\n\t\t\treturn nil\n\t\t})\n\t\tdefer success.Release()\n\t\tfailure := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t\t// Assumes it's a TypeError. See\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n\t\t\t// for more information on this type.\n\t\t\t// See https://fetch.spec.whatwg.org/#concept-body-consume-body for reasons this might error.\n\t\t\terrCh <- errors.New(args[0].Get(\"message\").String())\n\t\t\treturn nil\n\t\t})\n\t\tdefer failure.Release()\n\t\tr.arrayPromise.Call(\"then\", success, failure)\n\t\tselect {\n\t\tcase b := <-bCh:\n\t\t\tr.pending = b\n\t\tcase err := <-errCh:\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tif len(r.pending) == 0 {\n\t\treturn 0, io.EOF\n\t}\n\tn = copy(p, r.pending)\n\tr.pending = r.pending[n:]\n\treturn n, nil\n}\n\nfunc (r *arrayReader) Close() error {\n\tif r.err == nil {\n\t\tr.err = errClosed\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 0.40625,
          "content": "package req\n\nimport \"sync\"\n\nconst copyBufPoolSize = 32 * 1024\n\nvar copyBufPool = sync.Pool{New: func() any { return new([copyBufPoolSize]byte) }}\n\nfunc getCopyBuf() []byte {\n\treturn copyBufPool.Get().(*[copyBufPoolSize]byte)[:]\n}\n\nfunc putCopyBuf(b []byte) {\n\tif len(b) != copyBufPoolSize {\n\t\tpanic(\"trying to put back buffer of the wrong size in the copyBufPool\")\n\t}\n\tcopyBufPool.Put((*[copyBufPoolSize]byte)(b))\n}\n"
        },
        {
          "name": "textproto_reader.go",
          "type": "blob",
          "size": 14.1416015625,
          "content": "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage req\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/textproto\"\n\t\"sync\"\n\n\t\"github.com/imroc/req/v3/internal/dump\"\n)\n\nfunc isASCIILetter(b byte) bool {\n\tb |= 0x20 // make lower case\n\treturn 'a' <= b && b <= 'z'\n}\n\n// TODO: This should be a distinguishable error (ErrMessageTooLarge)\n// to allow mime/multipart to detect it.\nvar errMessageTooLarge = errors.New(\"message too large\")\n\n// A textprotoReader implements convenience methods for reading requests\n// or responses from a text protocol network connection.\ntype textprotoReader struct {\n\tR        *bufio.Reader\n\tbuf      []byte // a re-usable buffer for readContinuedLineSlice\n\treadLine func() (line []byte, isPrefix bool, err error)\n}\n\n// NewReader returns a new textprotoReader reading from r.\n//\n// To avoid denial of service attacks, the provided bufio.Reader\n// should be reading from an io.LimitReader or similar textprotoReader to bound\n// the size of responses.\nfunc newTextprotoReader(r *bufio.Reader, ds dump.Dumpers) *textprotoReader {\n\tcommonHeaderOnce.Do(initCommonHeader)\n\tt := &textprotoReader{R: r}\n\n\tif ds.ShouldDump() {\n\t\tt.readLine = func() (line []byte, isPrefix bool, err error) {\n\t\t\tline, err = t.R.ReadSlice('\\n')\n\t\t\tif len(line) == 0 {\n\t\t\t\tif err != nil {\n\t\t\t\t\tline = nil\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = nil\n\t\t\tds.DumpResponseHeader(line)\n\t\t\tif line[len(line)-1] == '\\n' {\n\t\t\t\tdrop := 1\n\t\t\t\tif len(line) > 1 && line[len(line)-2] == '\\r' {\n\t\t\t\t\tdrop = 2\n\t\t\t\t}\n\t\t\t\tline = line[:len(line)-drop]\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tt.readLine = t.R.ReadLine\n\t}\n\n\treturn t\n}\n\n// ReadLine reads a single line from r,\n// eliding the final \\n or \\r\\n from the returned string.\nfunc (r *textprotoReader) ReadLine() (string, error) {\n\tline, err := r.readLineSlice(-1)\n\treturn string(line), err\n}\n\n// readLineSlice reads a single line from r,\n// up to lim bytes long (or unlimited if lim is less than 0),\n// eliding the final \\r or \\r\\n from the returned string.\nfunc (r *textprotoReader) readLineSlice(lim int64) ([]byte, error) {\n\tvar line []byte\n\n\tfor {\n\t\tl, more, err := r.readLine()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif lim >= 0 && int64(len(line))+int64(len(l)) > lim {\n\t\t\treturn nil, errMessageTooLarge\n\t\t}\n\t\t// Avoid the copy if the first call produced a full line.\n\t\tif line == nil && !more {\n\t\t\treturn l, nil\n\t\t}\n\t\tline = append(line, l...)\n\t\tif !more {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn line, nil\n}\n\n// trim returns s with leading and trailing spaces and tabs removed.\n// It does not assume Unicode or UTF-8.\nfunc trim(s []byte) []byte {\n\ti := 0\n\tfor i < len(s) && (s[i] == ' ' || s[i] == '\\t') {\n\t\ti++\n\t}\n\tn := len(s)\n\tfor n > i && (s[n-1] == ' ' || s[n-1] == '\\t') {\n\t\tn--\n\t}\n\treturn s[i:n]\n}\n\n// readContinuedLineSlice reads continued lines from the reader buffer,\n// returning a byte slice with all lines. The validateFirstLine function\n// is run on the first read line, and if it returns an error then this\n// error is returned from readContinuedLineSlice.\n// It reads up to lim bytes of data (or unlimited if lim is less than 0).\nfunc (r *textprotoReader) readContinuedLineSlice(lim int64, validateFirstLine func([]byte) error) ([]byte, error) {\n\tif validateFirstLine == nil {\n\t\treturn nil, fmt.Errorf(\"missing validateFirstLine func\")\n\t}\n\n\t// Read the first line.\n\tline, err := r.readLineSlice(lim)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(line) == 0 { // blank line - no continuation\n\t\treturn line, nil\n\t}\n\n\tif err := validateFirstLine(line); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Optimistically assume that we have started to buffer the next line\n\t// and it starts with an ASCII letter (the next header key), or a blank\n\t// line, so we can avoid copying that buffered data around in memory\n\t// and skipping over non-existent whitespace.\n\tif r.R.Buffered() > 1 {\n\t\tpeek, _ := r.R.Peek(2)\n\t\tif len(peek) > 0 && (isASCIILetter(peek[0]) || peek[0] == '\\n') ||\n\t\t\tlen(peek) == 2 && peek[0] == '\\r' && peek[1] == '\\n' {\n\t\t\treturn trim(line), nil\n\t\t}\n\t}\n\n\t// ReadByte or the next readLineSlice will flush the read buffer;\n\t// copy the slice into buf.\n\tr.buf = append(r.buf[:0], trim(line)...)\n\n\tif lim < 0 {\n\t\tlim = math.MaxInt64\n\t}\n\tlim -= int64(len(r.buf))\n\n\t// Read continuation lines.\n\tfor r.skipSpace() > 0 {\n\t\tr.buf = append(r.buf, ' ')\n\t\tif int64(len(r.buf)) >= lim {\n\t\t\treturn nil, errMessageTooLarge\n\t\t}\n\t\tline, err := r.readLineSlice(lim - int64(len(r.buf)))\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tr.buf = append(r.buf, trim(line)...)\n\t}\n\treturn r.buf, nil\n}\n\n// skipSpace skips R over all spaces and returns the number of bytes skipped.\nfunc (r *textprotoReader) skipSpace() int {\n\tn := 0\n\tfor {\n\t\tc, err := r.R.ReadByte()\n\t\tif err != nil {\n\t\t\t// Bufio will keep err until next read.\n\t\t\tbreak\n\t\t}\n\t\tif c != ' ' && c != '\\t' {\n\t\t\tr.R.UnreadByte()\n\t\t\tbreak\n\t\t}\n\t\tn++\n\t}\n\treturn n\n}\n\n// A protocolError describes a protocol violation such\n// as an invalid response or a hung-up connection.\ntype protocolError string\n\nfunc (p protocolError) Error() string {\n\treturn string(p)\n}\n\nvar colon = []byte(\":\")\n\n// ReadMIMEHeader reads a MIME-style header from r.\n// The header is a sequence of possibly continued Key: Value lines\n// ending in a blank line.\n// The returned map m maps [CanonicalMIMEHeaderKey](key) to a\n// sequence of values in the same order encountered in the input.\n//\n// For example, consider this input:\n//\n//\tMy-Key: Value 1\n//\tLong-Key: Even\n//\t       Longer Value\n//\tMy-Key: Value 2\n//\n// Given that input, ReadMIMEHeader returns the map:\n//\n//\tmap[string][]string{\n//\t\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n//\t\t\"Long-Key\": {\"Even Longer Value\"},\n//\t}\nfunc (r *textprotoReader) ReadMIMEHeader() (textproto.MIMEHeader, error) {\n\treturn r.readMIMEHeader(math.MaxInt64, math.MaxInt64)\n}\n\n// readMIMEHeader is a version of ReadMIMEHeader which takes a limit on the header size.\n// It is called by the mime/multipart package.\nfunc (r *textprotoReader) readMIMEHeader(maxMemory, maxHeaders int64) (textproto.MIMEHeader, error) {\n\t// Avoid lots of small slice allocations later by allocating one\n\t// large one ahead of time which we'll cut up into smaller\n\t// slices. If this isn't big enough later, we allocate small ones.\n\tvar strs []string\n\thint := r.upcomingHeaderKeys()\n\tif hint > 0 {\n\t\tif hint > 1000 {\n\t\t\thint = 1000 // set a cap to avoid overallocation\n\t\t}\n\t\tstrs = make([]string, hint)\n\t}\n\n\tm := make(textproto.MIMEHeader, hint)\n\n\t// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.\n\t// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large\n\t// MIMEHeaders average about 200 bytes per entry.\n\tmaxMemory -= 400\n\tconst mapEntryOverhead = 200\n\n\t// The first line cannot start with a leading space.\n\tif buf, err := r.R.Peek(1); err == nil && (buf[0] == ' ' || buf[0] == '\\t') {\n\t\tconst errorLimit = 80 // arbitrary limit on how much of the line we'll quote\n\t\tline, err := r.readLineSlice(errorLimit)\n\t\tif err != nil {\n\t\t\treturn m, err\n\t\t}\n\t\treturn m, protocolError(\"malformed MIME header initial line: \" + string(line))\n\t}\n\n\tfor {\n\t\tkv, err := r.readContinuedLineSlice(maxMemory, mustHaveFieldNameColon)\n\t\tif len(kv) == 0 {\n\t\t\treturn m, err\n\t\t}\n\n\t\t// Key ends at first colon.\n\t\tk, v, ok := bytes.Cut(kv, colon)\n\t\tif !ok {\n\t\t\treturn m, protocolError(\"malformed MIME header line: \" + string(kv))\n\t\t}\n\t\tkey, ok := canonicalMIMEHeaderKey(k)\n\t\tif !ok {\n\t\t\treturn m, protocolError(\"malformed MIME header line: \" + string(kv))\n\t\t}\n\t\tfor _, c := range v {\n\t\t\tif !validHeaderValueByte(c) {\n\t\t\t\treturn m, protocolError(\"malformed MIME header line: \" + string(kv))\n\t\t\t}\n\t\t}\n\n\t\tmaxHeaders--\n\t\tif maxHeaders < 0 {\n\t\t\treturn nil, errMessageTooLarge\n\t\t}\n\n\t\t// Skip initial spaces in value.\n\t\tvalue := string(bytes.TrimLeft(v, \" \\t\"))\n\n\t\tvv := m[key]\n\t\tif vv == nil {\n\t\t\tmaxMemory -= int64(len(key))\n\t\t\tmaxMemory -= mapEntryOverhead\n\t\t}\n\t\tmaxMemory -= int64(len(value))\n\t\tif maxMemory < 0 {\n\t\t\treturn m, errMessageTooLarge\n\t\t}\n\t\tif vv == nil && len(strs) > 0 {\n\t\t\t// More than likely this will be a single-element key.\n\t\t\t// Most headers aren't multi-valued.\n\t\t\t// Set the capacity on strs[0] to 1, so any future append\n\t\t\t// won't extend the slice into the other strings.\n\t\t\tvv, strs = strs[:1:1], strs[1:]\n\t\t\tvv[0] = value\n\t\t\tm[key] = vv\n\t\t} else {\n\t\t\tm[key] = append(vv, value)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn m, err\n\t\t}\n\t}\n}\n\n// mustHaveFieldNameColon ensures that, per RFC 7230, the\n// field-name is on a single line, so the first line must\n// contain a colon.\nfunc mustHaveFieldNameColon(line []byte) error {\n\tif bytes.IndexByte(line, ':') < 0 {\n\t\treturn protocolError(fmt.Sprintf(\"malformed MIME header: missing colon: %q\", line))\n\t}\n\treturn nil\n}\n\nvar nl = []byte(\"\\n\")\n\n// upcomingHeaderKeys returns an approximation of the number of keys\n// that will be in this header. If it gets confused, it returns 0.\nfunc (r *textprotoReader) upcomingHeaderKeys() (n int) {\n\t// Try to determine the 'hint' size.\n\tr.R.Peek(1) // force a buffer load if empty\n\ts := r.R.Buffered()\n\tif s == 0 {\n\t\treturn\n\t}\n\tpeek, _ := r.R.Peek(s)\n\tfor len(peek) > 0 && n < 1000 {\n\t\tvar line []byte\n\t\tline, peek, _ = bytes.Cut(peek, nl)\n\t\tif len(line) == 0 || (len(line) == 1 && line[0] == '\\r') {\n\t\t\t// Blank line separating headers from the body.\n\t\t\tbreak\n\t\t}\n\t\tif line[0] == ' ' || line[0] == '\\t' {\n\t\t\t// Folded continuation of the previous line.\n\t\t\tcontinue\n\t\t}\n\t\tn++\n\t}\n\treturn n\n}\n\nconst toLower = 'a' - 'A'\n\n// validHeaderFieldByte reports whether b is a valid byte in a header\n// field name. RFC 7230 says:\n//\n//\theader-field   = field-name \":\" OWS field-value OWS\n//\tfield-name     = token\n//\ttchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n//\t        \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n//\ttoken = 1*tchar\nfunc validHeaderFieldByte(b byte) bool {\n\treturn int(b) < len(isTokenTable) && isTokenTable[b]\n}\n\n// canonicalMIMEHeaderKey is like CanonicalMIMEHeaderKey but is\n// allowed to mutate the provided byte slice before returning the\n// string.\n//\n// For invalid inputs (if a contains spaces or non-token bytes), a\n// is unchanged and a string copy is returned.\n//\n// ok is true if the header key contains only valid characters and spaces.\n// ReadMIMEHeader accepts header keys containing spaces, but does not\n// canonicalize them.\nfunc canonicalMIMEHeaderKey(a []byte) (_ string, ok bool) {\n\tif len(a) == 0 {\n\t\treturn \"\", false\n\t}\n\n\t// See if a looks like a header key. If not, return it unchanged.\n\tnoCanon := false\n\tfor _, c := range a {\n\t\tif validHeaderFieldByte(c) {\n\t\t\tcontinue\n\t\t}\n\t\t// Don't canonicalize.\n\t\tif c == ' ' {\n\t\t\t// We accept invalid headers with a space before the\n\t\t\t// colon, but must not canonicalize them.\n\t\t\t// See https://go.dev/issue/34540.\n\t\t\tnoCanon = true\n\t\t\tcontinue\n\t\t}\n\t\treturn string(a), false\n\t}\n\tif noCanon {\n\t\treturn string(a), true\n\t}\n\n\tupper := true\n\tfor i, c := range a {\n\t\t// Canonicalize: first letter upper case\n\t\t// and upper case after each dash.\n\t\t// (Host, User-Agent, If-Modified-Since).\n\t\t// MIME headers are ASCII only, so no Unicode issues.\n\t\tif upper && 'a' <= c && c <= 'z' {\n\t\t\tc -= toLower\n\t\t} else if !upper && 'A' <= c && c <= 'Z' {\n\t\t\tc += toLower\n\t\t}\n\t\ta[i] = c\n\t\tupper = c == '-' // for next time\n\t}\n\tcommonHeaderOnce.Do(initCommonHeader)\n\t// The compiler recognizes m[string(byteSlice)] as a special\n\t// case, so a copy of a's bytes into a new string does not\n\t// happen in this map lookup:\n\tif v := commonHeader[string(a)]; v != \"\" {\n\t\treturn v, true\n\t}\n\treturn string(a), true\n}\n\n// validHeaderValueByte reports whether c is a valid byte in a header\n// field value. RFC 7230 says:\n//\n//\tfield-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n//\tfield-vchar    = VCHAR / obs-text\n//\tobs-text       = %x80-FF\n//\n// RFC 5234 says:\n//\n//\tHTAB           =  %x09\n//\tSP             =  %x20\n//\tVCHAR          =  %x21-7E\nfunc validHeaderValueByte(c byte) bool {\n\t// mask is a 128-bit bitmap with 1s for allowed bytes,\n\t// so that the byte c can be tested with a shift and an and.\n\t// If c >= 128, then 1<<c and 1<<(c-64) will both be zero.\n\t// Since this is the obs-text range, we invert the mask to\n\t// create a bitmap with 1s for disallowed bytes.\n\tconst mask = 0 |\n\t\t(1<<(0x7f-0x21)-1)<<0x21 | // VCHAR: %x21-7E\n\t\t1<<0x20 | // SP: %x20\n\t\t1<<0x09 // HTAB: %x09\n\treturn ((uint64(1)<<c)&^(mask&(1<<64-1)) |\n\t\t(uint64(1)<<(c-64))&^(mask>>64)) == 0\n}\n\n// commonHeader interns common header strings.\nvar commonHeader map[string]string\n\nvar commonHeaderOnce sync.Once\n\nfunc initCommonHeader() {\n\tcommonHeader = make(map[string]string)\n\tfor _, v := range []string{\n\t\t\"Accept\",\n\t\t\"Accept-Charset\",\n\t\t\"Accept-Encoding\",\n\t\t\"Accept-Language\",\n\t\t\"Accept-Ranges\",\n\t\t\"Cache-Control\",\n\t\t\"Cc\",\n\t\t\"Connection\",\n\t\t\"Content-Id\",\n\t\t\"Content-Language\",\n\t\t\"Content-Length\",\n\t\t\"Content-Transfer-Encoding\",\n\t\t\"Content-Type\",\n\t\t\"Cookie\",\n\t\t\"Date\",\n\t\t\"Dkim-Signature\",\n\t\t\"Etag\",\n\t\t\"Expires\",\n\t\t\"From\",\n\t\t\"Host\",\n\t\t\"If-Modified-Since\",\n\t\t\"If-None-Match\",\n\t\t\"In-Reply-To\",\n\t\t\"Last-Modified\",\n\t\t\"Location\",\n\t\t\"Message-Id\",\n\t\t\"Mime-Version\",\n\t\t\"Pragma\",\n\t\t\"Received\",\n\t\t\"Return-Path\",\n\t\t\"Server\",\n\t\t\"Set-Cookie\",\n\t\t\"Subject\",\n\t\t\"To\",\n\t\t\"User-Agent\",\n\t\t\"Via\",\n\t\t\"X-Forwarded-For\",\n\t\t\"X-Imforwards\",\n\t\t\"X-Powered-By\",\n\t} {\n\t\tcommonHeader[v] = v\n\t}\n}\n\n// isTokenTable is a copy of net/http/lex.go's isTokenTable.\n// See https://httpwg.github.io/specs/rfc7230.html#rule.token.separators\nvar isTokenTable = [127]bool{\n\t'!':  true,\n\t'#':  true,\n\t'$':  true,\n\t'%':  true,\n\t'&':  true,\n\t'\\'': true,\n\t'*':  true,\n\t'+':  true,\n\t'-':  true,\n\t'.':  true,\n\t'0':  true,\n\t'1':  true,\n\t'2':  true,\n\t'3':  true,\n\t'4':  true,\n\t'5':  true,\n\t'6':  true,\n\t'7':  true,\n\t'8':  true,\n\t'9':  true,\n\t'A':  true,\n\t'B':  true,\n\t'C':  true,\n\t'D':  true,\n\t'E':  true,\n\t'F':  true,\n\t'G':  true,\n\t'H':  true,\n\t'I':  true,\n\t'J':  true,\n\t'K':  true,\n\t'L':  true,\n\t'M':  true,\n\t'N':  true,\n\t'O':  true,\n\t'P':  true,\n\t'Q':  true,\n\t'R':  true,\n\t'S':  true,\n\t'T':  true,\n\t'U':  true,\n\t'W':  true,\n\t'V':  true,\n\t'X':  true,\n\t'Y':  true,\n\t'Z':  true,\n\t'^':  true,\n\t'_':  true,\n\t'`':  true,\n\t'a':  true,\n\t'b':  true,\n\t'c':  true,\n\t'd':  true,\n\t'e':  true,\n\t'f':  true,\n\t'g':  true,\n\t'h':  true,\n\t'i':  true,\n\t'j':  true,\n\t'k':  true,\n\t'l':  true,\n\t'm':  true,\n\t'n':  true,\n\t'o':  true,\n\t'p':  true,\n\t'q':  true,\n\t'r':  true,\n\t's':  true,\n\t't':  true,\n\t'u':  true,\n\t'v':  true,\n\t'w':  true,\n\t'x':  true,\n\t'y':  true,\n\t'z':  true,\n\t'|':  true,\n\t'~':  true,\n}\n"
        },
        {
          "name": "trace.go",
          "type": "blob",
          "size": 4.162109375,
          "content": "package req\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http/httptrace\"\n\t\"time\"\n)\n\nconst (\n\ttraceFmt = `TotalTime         : %v\nDNSLookupTime     : %v\nTCPConnectTime    : %v\nTLSHandshakeTime  : %v\nFirstResponseTime : %v\nResponseTime      : %v\nIsConnReused:     : false\nRemoteAddr        : %v`\n\ttraceReusedFmt = `TotalTime         : %v\nFirstResponseTime : %v\nResponseTime      : %v\nIsConnReused:     : true\nRemoteAddr        : %v`\n)\n\n// Blame return the human-readable reason of why request is slowing.\nfunc (t TraceInfo) Blame() string {\n\tif t.RemoteAddr == nil {\n\t\treturn \"trace is not enabled\"\n\t}\n\tvar mk string\n\tvar mv time.Duration\n\tm := map[string]time.Duration{\n\t\t\"on dns lookup\":    t.DNSLookupTime,\n\t\t\"on tcp connect\":   t.TCPConnectTime,\n\t\t\"on tls handshake\": t.TLSHandshakeTime,\n\t\t\"from connection ready to server respond first byte\":   t.FirstResponseTime,\n\t\t\"from server respond first byte to request completion\": t.ResponseTime,\n\t}\n\tfor k, v := range m {\n\t\tif v > mv {\n\t\t\tmk = k\n\t\t\tmv = v\n\t\t}\n\t}\n\tif mk == \"\" {\n\t\treturn \"nothing to blame\"\n\t}\n\treturn fmt.Sprintf(\"the request total time is %v, and costs %v %s\", t.TotalTime, mv, mk)\n}\n\n// String return the details of trace information.\nfunc (t TraceInfo) String() string {\n\tif t.RemoteAddr == nil {\n\t\treturn \"trace is not enabled\"\n\t}\n\tif t.IsConnReused {\n\t\treturn fmt.Sprintf(traceReusedFmt, t.TotalTime, t.FirstResponseTime, t.ResponseTime, t.RemoteAddr)\n\t}\n\treturn fmt.Sprintf(traceFmt, t.TotalTime, t.DNSLookupTime, t.TCPConnectTime, t.TLSHandshakeTime, t.FirstResponseTime, t.ResponseTime, t.RemoteAddr)\n}\n\n// TraceInfo represents the trace information.\ntype TraceInfo struct {\n\t// DNSLookupTime is a duration that transport took to perform\n\t// DNS lookup.\n\tDNSLookupTime time.Duration\n\n\t// ConnectTime is a duration that took to obtain a successful connection.\n\tConnectTime time.Duration\n\n\t// TCPConnectTime is a duration that took to obtain the TCP connection.\n\tTCPConnectTime time.Duration\n\n\t// TLSHandshakeTime is a duration that TLS handshake took place.\n\tTLSHandshakeTime time.Duration\n\n\t// FirstResponseTime is a duration that server took to respond first byte since\n\t// connection ready (after tls handshake if it's tls and not a reused connection).\n\tFirstResponseTime time.Duration\n\n\t// ResponseTime is a duration since first response byte from server to\n\t// request completion.\n\tResponseTime time.Duration\n\n\t// TotalTime is a duration that total request took end-to-end.\n\tTotalTime time.Duration\n\n\t// IsConnReused is whether this connection has been previously\n\t// used for another HTTP request.\n\tIsConnReused bool\n\n\t// IsConnWasIdle is whether this connection was obtained from an\n\t// idle pool.\n\tIsConnWasIdle bool\n\n\t// ConnIdleTime is a duration how long the connection was previously\n\t// idle, if IsConnWasIdle is true.\n\tConnIdleTime time.Duration\n\n\t// RemoteAddr returns the remote network address.\n\tRemoteAddr net.Addr\n}\n\ntype clientTrace struct {\n\tgetConn              time.Time\n\tdnsStart             time.Time\n\tdnsDone              time.Time\n\tconnectDone          time.Time\n\ttlsHandshakeStart    time.Time\n\ttlsHandshakeDone     time.Time\n\tgotConn              time.Time\n\tgotFirstResponseByte time.Time\n\tendTime              time.Time\n\tgotConnInfo          httptrace.GotConnInfo\n}\n\nfunc (t *clientTrace) createContext(ctx context.Context) context.Context {\n\treturn httptrace.WithClientTrace(\n\t\tctx,\n\t\t&httptrace.ClientTrace{\n\t\t\tDNSStart: func(_ httptrace.DNSStartInfo) {\n\t\t\t\tt.dnsStart = time.Now()\n\t\t\t},\n\t\t\tDNSDone: func(_ httptrace.DNSDoneInfo) {\n\t\t\t\tt.dnsDone = time.Now()\n\t\t\t},\n\t\t\tConnectStart: func(_, _ string) {\n\t\t\t\tif t.dnsDone.IsZero() {\n\t\t\t\t\tt.dnsDone = time.Now()\n\t\t\t\t}\n\t\t\t\tif t.dnsStart.IsZero() {\n\t\t\t\t\tt.dnsStart = t.dnsDone\n\t\t\t\t}\n\t\t\t},\n\t\t\tConnectDone: func(net, addr string, err error) {\n\t\t\t\tt.connectDone = time.Now()\n\t\t\t},\n\t\t\tGetConn: func(_ string) {\n\t\t\t\tt.getConn = time.Now()\n\t\t\t},\n\t\t\tGotConn: func(ci httptrace.GotConnInfo) {\n\t\t\t\tt.gotConn = time.Now()\n\t\t\t\tt.gotConnInfo = ci\n\t\t\t},\n\t\t\tGotFirstResponseByte: func() {\n\t\t\t\tt.gotFirstResponseByte = time.Now()\n\t\t\t},\n\t\t\tTLSHandshakeStart: func() {\n\t\t\t\tt.tlsHandshakeStart = time.Now()\n\t\t\t},\n\t\t\tTLSHandshakeDone: func(_ tls.ConnectionState, _ error) {\n\t\t\t\tt.tlsHandshakeDone = time.Now()\n\t\t\t},\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "transfer.go",
          "type": "blob",
          "size": 28.86328125,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage req\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"reflect\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/imroc/req/v3/internal\"\n\t\"github.com/imroc/req/v3/internal/ascii\"\n\t\"github.com/imroc/req/v3/internal/dump\"\n\t\"github.com/imroc/req/v3/internal/godebug\"\n\n\t\"golang.org/x/net/http/httpguts\"\n)\n\ntype errorReader struct {\n\terr error\n}\n\nfunc (r errorReader) Read(p []byte) (n int, err error) {\n\treturn 0, r.err\n}\n\ntype byteReader struct {\n\tb    byte\n\tdone bool\n}\n\nfunc (br *byteReader) Read(p []byte) (n int, err error) {\n\tif br.done {\n\t\treturn 0, io.EOF\n\t}\n\tif len(p) == 0 {\n\t\treturn 0, nil\n\t}\n\tbr.done = true\n\tp[0] = br.b\n\treturn 1, io.EOF\n}\n\n// transferWriter inspects the fields of a user-supplied Request or Response,\n// sanitizes them without changing the user object and provides methods for\n// writing the respective header, body and trailer in wire format.\ntype transferWriter struct {\n\tMethod           string\n\tBody             io.Reader\n\tBodyCloser       io.Closer\n\tContentLength    int64 // -1 means unknown, 0 means exactly none\n\tClose            bool\n\tTransferEncoding []string\n\tHeader           http.Header\n\tTrailer          http.Header\n\tbodyReadError    error // any non-EOF error from reading Body\n\n\tFlushHeaders bool            // flush headers to network before body\n\tByteReadCh   chan readResult // non-nil if probeRequestBody called\n}\n\nfunc newTransferWriter(r *http.Request) (t *transferWriter, err error) {\n\tt = &transferWriter{}\n\n\t// Extract relevant fields\n\tatLeastHTTP11 := false\n\tif r.ContentLength != 0 && r.Body == nil {\n\t\treturn nil, fmt.Errorf(\"http: Request.ContentLength=%d with nil Body\", r.ContentLength)\n\t}\n\tt.Method = valueOrDefault(r.Method, \"GET\")\n\tt.Close = r.Close\n\tt.TransferEncoding = r.TransferEncoding\n\tt.Header = r.Header\n\tt.Trailer = r.Trailer\n\tt.Body = r.Body\n\tt.BodyCloser = r.Body\n\tt.ContentLength = outgoingLength(r)\n\tif t.ContentLength < 0 && len(t.TransferEncoding) == 0 && t.shouldSendChunkedRequestBody() {\n\t\tt.TransferEncoding = []string{\"chunked\"}\n\t}\n\t// If there's a body, conservatively flush the headers\n\t// to any bufio.Writer we're writing to, just in case\n\t// the server needs the headers early, before we copy\n\t// the body and possibly block. We make an exception\n\t// for the common standard library in-memory types,\n\t// though, to avoid unnecessary TCP packets on the\n\t// wire. (Issue 22088.)\n\tif t.ContentLength != 0 && !isKnownInMemoryReader(t.Body) {\n\t\tt.FlushHeaders = true\n\t}\n\n\tatLeastHTTP11 = true // Transport requests are always 1.1 or 2.0\n\n\t// Sanitize Body,ContentLength,TransferEncoding\n\tif !atLeastHTTP11 || t.Body == nil {\n\t\tt.TransferEncoding = nil\n\t}\n\tif chunked(t.TransferEncoding) {\n\t\tt.ContentLength = -1\n\t} else if t.Body == nil { // no chunking, no body\n\t\tt.ContentLength = 0\n\t}\n\n\t// Sanitize Trailer\n\tif !chunked(t.TransferEncoding) {\n\t\tt.Trailer = nil\n\t}\n\n\treturn t, nil\n}\n\n// shouldSendChunkedRequestBody reports whether we should try to send a\n// chunked request body to the server. In particular, the case we really\n// want to prevent is sending a GET or other typically-bodyless request to a\n// server with a chunked body when the body has zero bytes, since GETs with\n// bodies (while acceptable according to specs), even zero-byte chunked\n// bodies, are approximately never seen in the wild and confuse most\n// servers. See Issue 18257, as one example.\n//\n// The only reason we'd send such a request is if the user set the Body to a\n// non-nil value (say, io.NopCloser(bytes.NewReader(nil))) and didn't\n// set ContentLength, or NewRequest set it to -1 (unknown), so then we assume\n// there's bytes to send.\n//\n// This code tries to read a byte from the Request.Body in such cases to see\n// whether the body actually has content (super rare) or is actually just\n// a non-nil content-less ReadCloser (the more common case). In that more\n// common case, we act as if their Body were nil instead, and don't send\n// a body.\nfunc (t *transferWriter) shouldSendChunkedRequestBody() bool {\n\t// Note that t.ContentLength is the corrected content length\n\t// from rr.outgoingLength, so 0 actually means zero, not unknown.\n\tif t.ContentLength >= 0 || t.Body == nil { // redundant checks; caller did them\n\t\treturn false\n\t}\n\tif t.Method == \"CONNECT\" {\n\t\treturn false\n\t}\n\tif requestMethodUsuallyLacksBody(t.Method) {\n\t\t// Only probe the Request.Body for GET/HEAD/DELETE/etc\n\t\t// requests, because it's only those types of requests\n\t\t// that confuse servers.\n\t\tt.probeRequestBody() // adjusts t.Body, t.ContentLength\n\t\treturn t.Body != nil\n\t}\n\t// For all other request types (PUT, POST, PATCH, or anything\n\t// made-up we've never heard of), assume it's normal and the server\n\t// can deal with a chunked request body. Maybe we'll adjust this\n\t// later.\n\treturn true\n}\n\n// probeRequestBody reads a byte from t.Body to see whether it's empty\n// (returns io.EOF right away).\n//\n// But because we've had problems with this blocking users in the past\n// (issue 17480) when the body is a pipe (perhaps waiting on the response\n// headers before the pipe is fed data), we need to be careful and bound how\n// long we wait for it. This delay will only affect users if all the following\n// are true:\n//   - the request body blocks\n//   - the content length is not set (or set to -1)\n//   - the method doesn't usually have a body (GET, HEAD, DELETE, ...)\n//   - there is no transfer-encoding=chunked already set.\n//\n// In other words, this delay will not normally affect anybody, and there\n// are workarounds if it does.\nfunc (t *transferWriter) probeRequestBody() {\n\tt.ByteReadCh = make(chan readResult, 1)\n\tgo func(body io.Reader) {\n\t\tvar buf [1]byte\n\t\tvar rres readResult\n\t\trres.n, rres.err = body.Read(buf[:])\n\t\tif rres.n == 1 {\n\t\t\trres.b = buf[0]\n\t\t}\n\t\tt.ByteReadCh <- rres\n\t\tclose(t.ByteReadCh)\n\t}(t.Body)\n\ttimer := time.NewTimer(200 * time.Millisecond)\n\tselect {\n\tcase rres := <-t.ByteReadCh:\n\t\ttimer.Stop()\n\t\tif rres.n == 0 && rres.err == io.EOF {\n\t\t\t// It was empty.\n\t\t\tt.Body = nil\n\t\t\tt.ContentLength = 0\n\t\t} else if rres.n == 1 {\n\t\t\tif rres.err != nil {\n\t\t\t\tt.Body = io.MultiReader(&byteReader{b: rres.b}, errorReader{rres.err})\n\t\t\t} else {\n\t\t\t\tt.Body = io.MultiReader(&byteReader{b: rres.b}, t.Body)\n\t\t\t}\n\t\t} else if rres.err != nil {\n\t\t\tt.Body = errorReader{rres.err}\n\t\t}\n\tcase <-timer.C:\n\t\t// Too slow. Don't wait. Read it later, and keep\n\t\t// assuming that this is ContentLength == -1\n\t\t// (unknown), which means we'll send a\n\t\t// \"Transfer-Encoding: chunked\" header.\n\t\tt.Body = io.MultiReader(finishAsyncByteRead{t}, t.Body)\n\t\t// Request that Request.Write flush the headers to the\n\t\t// network before writing the body, since our body may not\n\t\t// become readable until it's seen the response headers.\n\t\tt.FlushHeaders = true\n\t}\n}\n\nfunc noResponseBodyExpected(requestMethod string) bool {\n\treturn requestMethod == \"HEAD\"\n}\n\nfunc (t *transferWriter) shouldSendContentLength() bool {\n\tif chunked(t.TransferEncoding) {\n\t\treturn false\n\t}\n\tif t.ContentLength > 0 {\n\t\treturn true\n\t}\n\tif t.ContentLength < 0 {\n\t\treturn false\n\t}\n\t// Many servers expect a Content-Length for these methods\n\tif t.Method == \"POST\" || t.Method == \"PUT\" || t.Method == \"PATCH\" {\n\t\treturn true\n\t}\n\tif t.ContentLength == 0 && isIdentity(t.TransferEncoding) {\n\t\tif t.Method == \"GET\" || t.Method == \"HEAD\" {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (t *transferWriter) writeHeader(writeHeader func(key string, values ...string) error) error {\n\tif t.Close && !hasToken(headerGet(t.Header, \"Connection\"), \"close\") {\n\t\terr := writeHeader(\"Connection\", \"close\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write Content-Length and/or Transfer-Encoding whose values are a\n\t// function of the sanitized field triple (Body, ContentLength,\n\t// TransferEncoding)\n\tif t.shouldSendContentLength() {\n\t\terr := writeHeader(\"Content-Length\", strconv.FormatInt(t.ContentLength, 10))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if chunked(t.TransferEncoding) {\n\t\terr := writeHeader(\"Transfer-Encoding\", \"chunked\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write Trailer header\n\tif t.Trailer != nil {\n\t\tkeys := make([]string, 0, len(t.Trailer))\n\t\tfor k := range t.Trailer {\n\t\t\tk = http.CanonicalHeaderKey(k)\n\t\t\tswitch k {\n\t\t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n\t\t\t\treturn badStringError(\"invalid Trailer key\", k)\n\t\t\t}\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tif len(keys) > 0 {\n\t\t\tslices.Sort(keys)\n\t\t\t// TODO: could do better allocation-wise here, but trailers are rare,\n\t\t\t// so being lazy for now.\n\t\t\terr := writeHeader(\"Trailer\", strings.Join(keys, \",\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// always closes t.BodyCloser\nfunc (t *transferWriter) writeBody(w io.Writer, dumps []*dump.Dumper) (err error) {\n\tvar ncopy int64\n\tclosed := false\n\tdefer func() {\n\t\tif closed || t.BodyCloser == nil {\n\t\t\treturn\n\t\t}\n\t\tif closeErr := t.BodyCloser.Close(); closeErr != nil && err == nil {\n\t\t\terr = closeErr\n\t\t}\n\t}()\n\n\trw := w // raw writer\n\tfor _, dump := range dumps {\n\t\tif dump.RequestBody() {\n\t\t\tw = dump.WrapRequestBodyWriter(w)\n\t\t}\n\t}\n\n\t// Write body. We \"unwrap\" the body first if it was wrapped in a\n\t// nopCloser or readTrackingBody. This is to ensure that we can take advantage of\n\t// OS-level optimizations in the event that the body is an\n\t// *os.File.\n\tif t.Body != nil {\n\t\tbody := t.unwrapBody()\n\t\tif chunked(t.TransferEncoding) {\n\t\t\tif bw, ok := rw.(*bufio.Writer); ok {\n\t\t\t\trw = &internal.FlushAfterChunkWriter{Writer: bw}\n\t\t\t}\n\t\t\tcw := internal.NewChunkedWriter(rw)\n\t\t\tfor _, dump := range dumps {\n\t\t\t\tif dump.RequestBody() {\n\t\t\t\t\tcw = dump.WrapRequestBodyWriteCloser(cw)\n\t\t\t\t}\n\t\t\t}\n\t\t\t_, err = t.doBodyCopy(cw, body)\n\t\t\tif err == nil {\n\t\t\t\terr = cw.Close()\n\t\t\t}\n\t\t} else if t.ContentLength == -1 {\n\t\t\tdst := w\n\t\t\tif t.Method == \"CONNECT\" {\n\t\t\t\tdst = bufioFlushWriter{dst}\n\t\t\t}\n\t\t\tncopy, err = t.doBodyCopy(dst, body)\n\t\t} else {\n\t\t\tncopy, err = t.doBodyCopy(w, io.LimitReader(body, t.ContentLength))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvar nextra int64\n\t\t\tnextra, err = t.doBodyCopy(io.Discard, body)\n\t\t\tncopy += nextra\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, dump := range dumps {\n\t\t\tif dump.RequestBody() {\n\t\t\t\tdump.DumpDefault([]byte(\"\\r\\n\"))\n\t\t\t}\n\t\t}\n\t}\n\tif t.BodyCloser != nil {\n\t\tclosed = true\n\t\tif err := t.BodyCloser.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif t.ContentLength != -1 && t.ContentLength != ncopy {\n\t\treturn fmt.Errorf(\"http: ContentLength=%d with Body length %d\",\n\t\t\tt.ContentLength, ncopy)\n\t}\n\n\tif chunked(t.TransferEncoding) {\n\t\t// Write Trailer header\n\t\tif t.Trailer != nil {\n\t\t\tif err := t.Trailer.Write(w); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Last chunk, empty trailer\n\t\t_, err = io.WriteString(w, \"\\r\\n\")\n\t}\n\treturn err\n}\n\n// doBodyCopy wraps a copy operation, with any resulting error also\n// being saved in bodyReadError.\n//\n// This function is only intended for use in writeBody.\nfunc (t *transferWriter) doBodyCopy(dst io.Writer, src io.Reader) (n int64, err error) {\n\tbuf := getCopyBuf()\n\tdefer putCopyBuf(buf)\n\tn, err = io.CopyBuffer(dst, src, buf)\n\tif err != nil && err != io.EOF {\n\t\tt.bodyReadError = err\n\t}\n\treturn\n}\n\n// unwrapBody unwraps the body's inner reader if it's a\n// nopCloser. This is to ensure that body writes sourced from local\n// files (*os.File types) are properly optimized.\n//\n// This function is only intended for use in writeBody.\nfunc (t *transferWriter) unwrapBody() io.Reader {\n\tif r, ok := unwrapNopCloser(t.Body); ok {\n\t\treturn r\n\t}\n\tif r, ok := t.Body.(*readTrackingBody); ok {\n\t\tr.didRead = true\n\t\treturn r.ReadCloser\n\t}\n\treturn t.Body\n}\n\ntype transferReader struct {\n\t// Input\n\tHeader        http.Header\n\tStatusCode    int\n\tRequestMethod string\n\tProtoMajor    int\n\tProtoMinor    int\n\t// Output\n\tBody          io.ReadCloser\n\tContentLength int64\n\tChunked       bool\n\tClose         bool\n\tTrailer       http.Header\n}\n\nfunc (t *transferReader) protoAtLeast(m, n int) bool {\n\treturn t.ProtoMajor > m || (t.ProtoMajor == m && t.ProtoMinor >= n)\n}\n\n// bodyAllowedForStatus reports whether a given response status code\n// permits a body. See RFC 7230, section 3.3.\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == 204:\n\t\treturn false\n\tcase status == 304:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// msg is *http.Request or *http.Response.\nfunc readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n\tt := &transferReader{RequestMethod: \"GET\"}\n\n\t// Unify input\n\tisResponse := false\n\tswitch rr := msg.(type) {\n\tcase *http.Response:\n\t\tt.Header = rr.Header\n\t\tt.StatusCode = rr.StatusCode\n\t\tt.ProtoMajor = rr.ProtoMajor\n\t\tt.ProtoMinor = rr.ProtoMinor\n\t\tt.Close = shouldClose(t.ProtoMajor, t.ProtoMinor, t.Header, true)\n\t\tisResponse = true\n\t\tif rr.Request != nil {\n\t\t\tt.RequestMethod = rr.Request.Method\n\t\t}\n\tdefault:\n\t\tpanic(\"unexpected type\")\n\t}\n\n\t// Default to HTTP/1.1\n\tif t.ProtoMajor == 0 && t.ProtoMinor == 0 {\n\t\tt.ProtoMajor, t.ProtoMinor = 1, 1\n\t}\n\n\t// Transfer-Encoding: chunked, and overriding Content-Length.\n\tif err := t.parseTransferEncoding(); err != nil {\n\t\treturn err\n\t}\n\n\trealLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.Chunked)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif isResponse && t.RequestMethod == \"HEAD\" {\n\t\tif n, err := parseContentLength(t.Header[\"Content-Length\"]); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tt.ContentLength = n\n\t\t}\n\t} else {\n\t\tt.ContentLength = realLength\n\t}\n\n\t// Trailer\n\tt.Trailer, err = fixTrailer(t.Header, t.Chunked)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If there is no Content-Length or chunked Transfer-Encoding on a *Response\n\t// and the status is not 1xx, 204 or 304, then the body is unbounded.\n\t// See RFC 7230, section 3.3.\n\tswitch msg.(type) {\n\tcase *http.Response:\n\t\tif realLength == -1 && !t.Chunked && bodyAllowedForStatus(t.StatusCode) {\n\t\t\t// Unbounded body.\n\t\t\tt.Close = true\n\t\t}\n\t}\n\n\t// Prepare body reader. ContentLength < 0 means chunked encoding\n\t// or close connection when finished, since multipart is not supported yet\n\tswitch {\n\tcase t.Chunked:\n\t\tif isResponse && (noResponseBodyExpected(t.RequestMethod) || !bodyAllowedForStatus(t.StatusCode)) {\n\t\t\tt.Body = NoBody\n\t\t} else {\n\t\t\tt.Body = &body{src: internal.NewChunkedReader(r), hdr: msg, r: r, closing: t.Close}\n\t\t}\n\tcase realLength == 0:\n\t\tt.Body = NoBody\n\tcase realLength > 0:\n\t\tt.Body = &body{src: io.LimitReader(r, realLength), closing: t.Close}\n\tdefault:\n\t\t// realLength < 0, i.e. \"Content-Length\" not mentioned in header\n\t\tif t.Close {\n\t\t\t// Close semantics (i.e. HTTP/1.0)\n\t\t\tt.Body = &body{src: r, closing: t.Close}\n\t\t} else {\n\t\t\t// Persistent connection (i.e. HTTP/1.1)\n\t\t\tt.Body = NoBody\n\t\t}\n\t}\n\n\t// Unify output\n\tswitch rr := msg.(type) {\n\tcase *http.Response:\n\t\trr.Body = t.Body\n\t\trr.ContentLength = t.ContentLength\n\t\tif t.Chunked {\n\t\t\trr.TransferEncoding = []string{\"chunked\"}\n\t\t}\n\t\trr.Close = t.Close\n\t\trr.Trailer = t.Trailer\n\t}\n\n\treturn nil\n}\n\n// Checks whether chunked is part of the encodings stack.\nfunc chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n\n// Checks whether the encoding is explicitly \"identity\".\nfunc isIdentity(te []string) bool { return len(te) == 1 && te[0] == \"identity\" }\n\n// unsupportedTEError reports unsupported transfer-encodings.\ntype unsupportedTEError struct {\n\terr string\n}\n\nfunc (uste *unsupportedTEError) Error() string {\n\treturn uste.err\n}\n\n// parseTransferEncoding sets t.Chunked based on the Transfer-Encoding header.\nfunc (t *transferReader) parseTransferEncoding() error {\n\traw, present := t.Header[\"Transfer-Encoding\"]\n\tif !present {\n\t\treturn nil\n\t}\n\tdelete(t.Header, \"Transfer-Encoding\")\n\n\t// Issue 12785; ignore Transfer-Encoding on HTTP/1.0 requests.\n\tif !t.protoAtLeast(1, 1) {\n\t\treturn nil\n\t}\n\n\t// Like nginx, we only support a single Transfer-Encoding header field, and\n\t// only if set to \"chunked\". This is one of the most security sensitive\n\t// surfaces in HTTP/1.1 due to the risk of request smuggling, so we keep it\n\t// strict and simple.\n\tif len(raw) != 1 {\n\t\treturn &unsupportedTEError{fmt.Sprintf(\"too many transfer encodings: %q\", raw)}\n\t}\n\tif !ascii.EqualFold(raw[0], \"chunked\") {\n\t\treturn &unsupportedTEError{fmt.Sprintf(\"unsupported transfer encoding: %q\", raw[0])}\n\t}\n\n\tt.Chunked = true\n\treturn nil\n}\n\n// Determine the expected body length, using RFC 7230 Section 3.3. This\n// function is not a method, because ultimately it should be shared by\n// ReadResponse and ReadRequest.\nfunc fixLength(isResponse bool, status int, requestMethod string, header http.Header, chunked bool) (n int64, err error) {\n\tisRequest := !isResponse\n\tcontentLens := header[\"Content-Length\"]\n\n\t// Hardening against HTTP request smuggling\n\tif len(contentLens) > 1 {\n\t\t// Per RFC 7230 Section 3.3.2, prevent multiple\n\t\t// Content-Length headers if they differ in value.\n\t\t// If there are dups of the value, remove the dups.\n\t\t// See Issue 16490.\n\t\tfirst := textproto.TrimString(contentLens[0])\n\t\tfor _, ct := range contentLens[1:] {\n\t\t\tif first != textproto.TrimString(ct) {\n\t\t\t\treturn 0, fmt.Errorf(\"http: message cannot contain multiple Content-Length headers; got %q\", contentLens)\n\t\t\t}\n\t\t}\n\n\t\t// deduplicate Content-Length\n\t\theader.Del(\"Content-Length\")\n\t\theader.Add(\"Content-Length\", first)\n\n\t\tcontentLens = header[\"Content-Length\"]\n\t}\n\n\t// Reject requests with invalid Content-Length headers.\n\tif len(contentLens) > 0 {\n\t\tn, err = parseContentLength(contentLens)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t}\n\n\t// Logic based on response type or status\n\tif isResponse && noResponseBodyExpected(requestMethod) {\n\t\treturn 0, nil\n\t}\n\tif status/100 == 1 {\n\t\treturn 0, nil\n\t}\n\tswitch status {\n\tcase 204, 304:\n\t\treturn 0, nil\n\t}\n\n\t// According to RFC 9112, \"If a message is received with both a\n\t// Transfer-Encoding and a Content-Length header field, the Transfer-Encoding\n\t// overrides the Content-Length. Such a message might indicate an attempt to\n\t// perform request smuggling (Section 11.2) or response splitting (Section 11.1)\n\t// and ought to be handled as an error. An intermediary that chooses to forward\n\t// the message MUST first remove the received Content-Length field and process\n\t// the Transfer-Encoding (as described below) prior to forwarding the message downstream.\"\n\t//\n\t// Chunked-encoding requests with either valid Content-Length\n\t// headers or no Content-Length headers are accepted after removing\n\t// the Content-Length field from header.\n\t//\n\t// Logic based on Transfer-Encoding\n\tif chunked {\n\t\theader.Del(\"Content-Length\")\n\t\treturn -1, nil\n\t}\n\n\t// Logic based on Content-Length\n\tif len(contentLens) > 0 {\n\t\treturn n, nil\n\t}\n\n\theader.Del(\"Content-Length\")\n\n\tif isRequest {\n\t\t// RFC 7230 neither explicitly permits nor forbids an\n\t\t// entity-body on a GET request so we permit one if\n\t\t// declared, but we default to 0 here (not -1 below)\n\t\t// if there's no mention of a body.\n\t\t// Likewise, all other request methods are assumed to have\n\t\t// no body if neither Transfer-Encoding chunked nor a\n\t\t// Content-Length are set.\n\t\treturn 0, nil\n\t}\n\n\t// Body-EOF logic based on other methods (like closing, or chunked coding)\n\treturn -1, nil\n}\n\n// Determine whether to hang up after sending a request and body, or\n// receiving a response and body\n// 'header' is the request headers.\nfunc shouldClose(major, minor int, header http.Header, removeCloseHeader bool) bool {\n\tif major < 1 {\n\t\treturn true\n\t}\n\n\tconv := header[\"Connection\"]\n\thasClose := httpguts.HeaderValuesContainsToken(conv, \"close\")\n\tif major == 1 && minor == 0 {\n\t\treturn hasClose || !httpguts.HeaderValuesContainsToken(conv, \"keep-alive\")\n\t}\n\n\tif hasClose && removeCloseHeader {\n\t\theader.Del(\"Connection\")\n\t}\n\n\treturn hasClose\n}\n\n// Parse the trailer header.\nfunc fixTrailer(header http.Header, chunked bool) (http.Header, error) {\n\tvv, ok := header[\"Trailer\"]\n\tif !ok {\n\t\treturn nil, nil\n\t}\n\tif !chunked {\n\t\t// Trailer and no chunking:\n\t\t// this is an invalid use case for trailer header.\n\t\t// Nevertheless, no error will be returned and we\n\t\t// let users decide if this is a valid HTTP message.\n\t\t// The Trailer header will be kept in Response.Header\n\t\t// but not populate Response.Trailer.\n\t\t// See issue #27197.\n\t\treturn nil, nil\n\t}\n\theader.Del(\"Trailer\")\n\n\ttrailer := make(http.Header)\n\tvar err error\n\tfor _, v := range vv {\n\t\tforeachHeaderElement(v, func(key string) {\n\t\t\tkey = http.CanonicalHeaderKey(key)\n\t\t\tswitch key {\n\t\t\tcase \"Transfer-Encoding\", \"Trailer\", \"Content-Length\":\n\t\t\t\tif err == nil {\n\t\t\t\t\terr = badStringError(\"bad trailer key\", key)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\ttrailer[key] = nil\n\t\t})\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(trailer) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn trailer, nil\n}\n\n// body turns a textprotoReader into a ReadCloser.\n// Close ensures that the body has been fully read\n// and then reads the trailer if necessary.\ntype body struct {\n\tsrc          io.Reader\n\thdr          interface{}   // non-nil (Response or Request) value means read trailer\n\tr            *bufio.Reader // underlying wire-format reader for the trailer\n\tclosing      bool          // is the connection to be closed after reading body?\n\tdoEarlyClose bool          // whether Close should stop early\n\n\tmu         sync.Mutex // guards following, and calls to Read and Close\n\tsawEOF     bool\n\tclosed     bool\n\tearlyClose bool   // Close called and we didn't read to the end of src\n\tonHitEOF   func() // if non-nil, func to call when EOF is Read\n}\n\nfunc (b *body) Read(p []byte) (n int, err error) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif b.closed {\n\t\treturn 0, http.ErrBodyReadAfterClose\n\t}\n\treturn b.readLocked(p)\n}\n\n// Must hold b.mu.\nfunc (b *body) readLocked(p []byte) (n int, err error) {\n\tif b.sawEOF {\n\t\treturn 0, io.EOF\n\t}\n\tn, err = b.src.Read(p)\n\n\tif err == io.EOF {\n\t\tb.sawEOF = true\n\t\t// Chunked case. Read the trailer.\n\t\tif b.hdr != nil {\n\t\t\tif e := b.readTrailer(); e != nil {\n\t\t\t\terr = e\n\t\t\t\t// Something went wrong in the trailer, we must not allow any\n\t\t\t\t// further reads of any kind to succeed from body, nor any\n\t\t\t\t// subsequent requests on the server connection. See\n\t\t\t\t// golang.org/issue/12027\n\t\t\t\tb.sawEOF = false\n\t\t\t\tb.closed = true\n\t\t\t}\n\t\t\tb.hdr = nil\n\t\t} else {\n\t\t\t// If the server declared the Content-Length, our body is a LimitedReader\n\t\t\t// and we need to check whether this EOF arrived early.\n\t\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N > 0 {\n\t\t\t\terr = io.ErrUnexpectedEOF\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we can return an EOF here along with the read data, do\n\t// so. This is optional per the io.textprotoReader contract, but doing\n\t// so helps the HTTP transport code recycle its connection\n\t// earlier (since it will see this EOF itself), even if the\n\t// client doesn't do future reads or Close.\n\tif err == nil && n > 0 {\n\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N == 0 {\n\t\t\terr = io.EOF\n\t\t\tb.sawEOF = true\n\t\t}\n\t}\n\n\tif b.sawEOF && b.onHitEOF != nil {\n\t\tb.onHitEOF()\n\t}\n\n\treturn n, err\n}\n\nvar (\n\tsingleCRLF = []byte(\"\\r\\n\")\n\tdoubleCRLF = []byte(\"\\r\\n\\r\\n\")\n)\n\nfunc seeUpcomingDoubleCRLF(r *bufio.Reader) bool {\n\tfor peekSize := 4; ; peekSize++ {\n\t\t// This loop stops when Peek returns an error,\n\t\t// which it does when r's buffer has been filled.\n\t\tbuf, err := r.Peek(peekSize)\n\t\tif bytes.HasSuffix(buf, doubleCRLF) {\n\t\t\treturn true\n\t\t}\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn false\n}\n\nvar errTrailerEOF = errors.New(\"http: unexpected EOF reading trailer\")\n\nfunc (b *body) readTrailer() error {\n\t// The common case, since nobody uses trailers.\n\tbuf, err := b.r.Peek(2)\n\tif bytes.Equal(buf, singleCRLF) {\n\t\tb.r.Discard(2)\n\t\treturn nil\n\t}\n\tif len(buf) < 2 {\n\t\treturn errTrailerEOF\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Make sure there's a header terminator coming up, to prevent\n\t// a DoS with an unbounded size Trailer. It's not easy to\n\t// slip in a LimitReader here, as textproto.NewReader requires\n\t// a concrete *bufio.textprotoReader. Also, we can't get all the way\n\t// back up to our conn's LimitedReader that *might* be backing\n\t// this bufio.textprotoReader. Instead, a hack: we iteratively Peek up\n\t// to the bufio.textprotoReader's max size, looking for a double CRLF.\n\t// This limits the trailer to the underlying buffer size, typically 4kB.\n\tif !seeUpcomingDoubleCRLF(b.r) {\n\t\treturn errors.New(\"http: suspiciously long trailer after chunked body\")\n\t}\n\n\thdr, err := textproto.NewReader(b.r).ReadMIMEHeader()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\treturn errTrailerEOF\n\t\t}\n\t\treturn err\n\t}\n\tswitch rr := b.hdr.(type) {\n\tcase *http.Request:\n\t\tmergeSetHeader(&rr.Trailer, http.Header(hdr))\n\tcase *http.Response:\n\t\tmergeSetHeader(&rr.Trailer, http.Header(hdr))\n\t}\n\treturn nil\n}\n\nfunc mergeSetHeader(dst *http.Header, src http.Header) {\n\tif *dst == nil {\n\t\t*dst = src\n\t\treturn\n\t}\n\tfor k, vv := range src {\n\t\t(*dst)[k] = vv\n\t}\n}\n\n// unreadDataSizeLocked returns the number of bytes of unread input.\n// It returns -1 if unknown.\n// b.mu must be held.\nfunc (b *body) unreadDataSizeLocked() int64 {\n\tif lr, ok := b.src.(*io.LimitedReader); ok {\n\t\treturn lr.N\n\t}\n\treturn -1\n}\n\nfunc (b *body) Close() error {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tif b.closed {\n\t\treturn nil\n\t}\n\tvar err error\n\tswitch {\n\tcase b.sawEOF:\n\t\t// Already saw EOF, so no need going to look for it.\n\tcase b.hdr == nil && b.closing:\n\t\t// no trailer and closing the connection next.\n\t\t// no point in reading to EOF.\n\tcase b.doEarlyClose:\n\t\t// Read up to maxPostHandlerReadBytes bytes of the body, looking\n\t\t// for EOF (and trailers), so we can re-use this connection.\n\t\tif lr, ok := b.src.(*io.LimitedReader); ok && lr.N > maxPostHandlerReadBytes {\n\t\t\t// There was a declared Content-Length, and we have more bytes remaining\n\t\t\t// than our maxPostHandlerReadBytes tolerance. So, give up.\n\t\t\tb.earlyClose = true\n\t\t} else {\n\t\t\tvar n int64\n\t\t\t// Consume the body, or, which will also lead to us reading\n\t\t\t// the trailer headers after the body, if present.\n\t\t\tn, err = io.CopyN(io.Discard, bodyLocked{b}, maxPostHandlerReadBytes)\n\t\t\tif err == io.EOF {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\tif n == maxPostHandlerReadBytes {\n\t\t\t\tb.earlyClose = true\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// Fully consume the body, which will also lead to us reading\n\t\t// the trailer headers after the body, if present.\n\t\t_, err = io.Copy(io.Discard, bodyLocked{b})\n\t}\n\tb.closed = true\n\treturn err\n}\n\nfunc (b *body) didEarlyClose() bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\treturn b.earlyClose\n}\n\n// bodyRemains reports whether future Read calls might\n// yield data.\nfunc (b *body) bodyRemains() bool {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\treturn !b.sawEOF\n}\n\nfunc (b *body) registerOnHitEOF(fn func()) {\n\tb.mu.Lock()\n\tdefer b.mu.Unlock()\n\tb.onHitEOF = fn\n}\n\n// bodyLocked is an io.Reader reading from a *body when its mutex is\n// already held.\ntype bodyLocked struct {\n\tb *body\n}\n\nfunc (bl bodyLocked) Read(p []byte) (n int, err error) {\n\tif bl.b.closed {\n\t\treturn 0, http.ErrBodyReadAfterClose\n\t}\n\treturn bl.b.readLocked(p)\n}\n\nvar httplaxContentLength = godebug.New(\"httplaxcontentlength\")\n\n// parseContentLength checks that the header is valid and then trims\n// whitespace. It returns -1 if no value is set otherwise the value\n// if it's >= 0.\nfunc parseContentLength(clHeaders []string) (int64, error) {\n\tif len(clHeaders) == 0 {\n\t\treturn -1, nil\n\t}\n\tcl := textproto.TrimString(clHeaders[0])\n\n\t// The Content-Length must be a valid numeric value.\n\t// See: https://datatracker.ietf.org/doc/html/rfc2616/#section-14.13\n\tif cl == \"\" {\n\t\tif httplaxContentLength.Value() == \"1\" {\n\t\t\thttplaxContentLength.IncNonDefault()\n\t\t\treturn -1, nil\n\t\t}\n\t\treturn 0, badStringError(\"invalid empty Content-Length\", cl)\n\t}\n\tn, err := strconv.ParseUint(cl, 10, 63)\n\tif err != nil {\n\t\treturn 0, badStringError(\"bad Content-Length\", cl)\n\t}\n\treturn int64(n), nil\n}\n\n// finishAsyncByteRead finishes reading the 1-byte sniff\n// from the ContentLength==0, Body!=nil case.\ntype finishAsyncByteRead struct {\n\ttw *transferWriter\n}\n\nfunc (fr finishAsyncByteRead) Read(p []byte) (n int, err error) {\n\tif len(p) == 0 {\n\t\treturn\n\t}\n\trres := <-fr.tw.ByteReadCh\n\tn, err = rres.n, rres.err\n\tif n == 1 {\n\t\tp[0] = rres.b\n\t}\n\tif err == nil {\n\t\terr = io.EOF\n\t}\n\treturn\n}\n\nvar (\n\tnopCloserType         = reflect.TypeOf(io.NopCloser(nil))\n\tnopCloserWriterToType = reflect.TypeOf(io.NopCloser(struct {\n\t\tio.Reader\n\t\tio.WriterTo\n\t}{}))\n)\n\n// unwrapNopCloser return the underlying reader and true if r is a NopCloser\n// else it return false.\nfunc unwrapNopCloser(r io.Reader) (underlyingReader io.Reader, isNopCloser bool) {\n\tswitch reflect.TypeOf(r) {\n\tcase nopCloserType, nopCloserWriterToType:\n\t\treturn reflect.ValueOf(r).Field(0).Interface().(io.Reader), true\n\tdefault:\n\t\treturn nil, false\n\t}\n}\n\n// isKnownInMemoryReader reports whether r is a type known to not\n// block on Read. Its caller uses this as an optional optimization to\n// send fewer TCP packets.\nfunc isKnownInMemoryReader(r io.Reader) bool {\n\tswitch r.(type) {\n\tcase *bytes.Reader, *bytes.Buffer, *strings.Reader:\n\t\treturn true\n\t}\n\tif r, ok := unwrapNopCloser(r); ok {\n\t\treturn isKnownInMemoryReader(r)\n\t}\n\tif r, ok := r.(*readTrackingBody); ok {\n\t\treturn isKnownInMemoryReader(r.ReadCloser)\n\t}\n\treturn false\n}\n\n// bufioFlushWriter is an io.Writer wrapper that flushes all writes\n// on its wrapped writer if it's a *bufio.Writer.\ntype bufioFlushWriter struct{ w io.Writer }\n\nfunc (fw bufioFlushWriter) Write(p []byte) (n int, err error) {\n\tn, err = fw.w.Write(p)\n\tif bw, ok := fw.w.(*bufio.Writer); n > 0 && ok {\n\t\tferr := bw.Flush()\n\t\tif ferr != nil && err == nil {\n\t\t\terr = ferr\n\t\t}\n\t}\n\treturn\n}\n"
        },
        {
          "name": "transport.go",
          "type": "blob",
          "size": 108.5107421875,
          "content": "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// HTTP client implementation. See RFC 7230 through 7235.\n//\n// This is the low-level Transport implementation of http.RoundTripper.\n// The high-level interface is in client.go.\n\npackage req\n\nimport (\n\t\"bufio\"\n\t\"compress/gzip\"\n\t\"container/list\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"mime\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptrace\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t_ \"unsafe\"\n\n\t\"github.com/imroc/req/v3/http2\"\n\t\"github.com/imroc/req/v3/internal/altsvcutil\"\n\t\"github.com/imroc/req/v3/internal/ascii\"\n\t\"github.com/imroc/req/v3/internal/common\"\n\t\"github.com/imroc/req/v3/internal/compress\"\n\t\"github.com/imroc/req/v3/internal/dump\"\n\t\"github.com/imroc/req/v3/internal/header\"\n\th2internal \"github.com/imroc/req/v3/internal/http2\"\n\t\"github.com/imroc/req/v3/internal/http3\"\n\t\"github.com/imroc/req/v3/internal/netutil\"\n\t\"github.com/imroc/req/v3/internal/socks\"\n\t\"github.com/imroc/req/v3/internal/transport\"\n\t\"github.com/imroc/req/v3/internal/util\"\n\t\"github.com/imroc/req/v3/pkg/altsvc\"\n\treqtls \"github.com/imroc/req/v3/pkg/tls\"\n\thtmlcharset \"golang.org/x/net/html/charset\"\n\t\"golang.org/x/text/encoding/ianaindex\"\n\n\t\"golang.org/x/net/http/httpguts\"\n)\n\n// httpVersion represents http version.\ntype httpVersion string\n\nconst (\n\t// h1 represents \"HTTP/1.1\"\n\th1 httpVersion = \"1.1\"\n\t// h2 represents \"HTTP/2.0\"\n\th2 httpVersion = \"2\"\n\t// h3 represents \"HTTP/3.0\"\n\th3 httpVersion = \"3\"\n)\n\n// defaultMaxIdleConnsPerHost is the default value of Transport's\n// MaxIdleConnsPerHost.\nconst defaultMaxIdleConnsPerHost = 2\n\n// Transport is an implementation of http.RoundTripper that supports HTTP,\n// HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n//\n// By default, Transport caches connections for future re-use.\n// This may leave many open connections when accessing many hosts.\n// This behavior can be managed using Transport's CloseIdleConnections method\n// and the MaxIdleConnsPerHost and DisableKeepAlives fields.\n//\n// Transports should be reused instead of created as needed.\n// Transports are safe for concurrent use by multiple goroutines.\n//\n// A Transport is a low-level primitive for making HTTP and HTTPS requests.\n// For high-level functionality, such as cookies and redirects, see Client.\n//\n// Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2\n// for HTTPS URLs, depending on whether the server supports HTTP/2,\n// and how the Transport is configured. The DefaultTransport supports HTTP/2.\n// To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\n// and call ConfigureTransport. See the package docs for more about HTTP/2.\n//\n// Responses with status codes in the 1xx range are either handled\n// automatically (100 expect-continue) or ignored. The one\n// exception is HTTP status code 101 (Switching Protocols), which is\n// considered a terminal status and returned by RoundTrip. To see the\n// ignored 1xx responses, use the httptrace trace package's\n// ClientTrace.Got1xxResponse.\n//\n// Transport only retries a request upon encountering a network error\n// if the request is idempotent and either has no body or has its\n// Request.GetBody defined. HTTP requests are considered idempotent if\n// they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their\n// Header map contains an \"Idempotency-Key\" or \"X-Idempotency-Key\"\n// entry. If the idempotency key value is a zero-length slice, the\n// request is treated as idempotent but the header is not sent on the\n// wire.\ntype Transport struct {\n\tHeaders http.Header\n\tCookies []*http.Cookie\n\n\tidleMu       sync.Mutex\n\tcloseIdle    bool                                // user has requested to close all idle conns\n\tidleConn     map[connectMethodKey][]*persistConn // most recently used at end\n\tidleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns\n\tidleLRU      connLRU\n\n\treqMu       sync.Mutex\n\treqCanceler map[*http.Request]context.CancelCauseFunc\n\n\tconnsPerHostMu   sync.Mutex\n\tconnsPerHost     map[connectMethodKey]int\n\tconnsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns\n\tdialsInProgress  wantConnQueue\n\n\taltSvcJar        altsvc.Jar\n\tpendingAltSvcs   map[string]*pendingAltSvc\n\tpendingAltSvcsMu sync.Mutex\n\n\t// Force using specific http version\n\tforceHttpVersion httpVersion\n\n\ttransport.Options\n\n\tt2 *h2internal.Transport // non-nil if http2 wired up\n\tt3 *http3.RoundTripper\n\n\t// disableAutoDecode, if true, prevents auto detect response\n\t// body's charset and decode it to utf-8\n\tdisableAutoDecode bool\n\n\t// autoDecodeContentType specifies an optional function for determine\n\t// whether the response body should been auto decode to utf-8.\n\t// Only valid when DisableAutoDecode is true.\n\tautoDecodeContentType func(contentType string) bool\n\twrappedRoundTrip      http.RoundTripper\n\thttpRoundTripWrappers []HttpRoundTripWrapper\n}\n\n// NewTransport is an alias of T\nfunc NewTransport() *Transport {\n\treturn T()\n}\n\n// T create a Transport.\nfunc T() *Transport {\n\tt := &Transport{\n\t\tOptions: transport.Options{\n\t\t\tProxy:                 http.ProxyFromEnvironment,\n\t\t\tMaxIdleConns:          100,\n\t\t\tIdleConnTimeout:       90 * time.Second,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t\tTLSClientConfig:       &tls.Config{NextProtos: []string{\"http/1.1\", \"h2\"}},\n\t\t},\n\t}\n\tt.t2 = &h2internal.Transport{Options: &t.Options}\n\treturn t\n}\n\n// HttpRoundTripFunc is a http.RoundTripper implementation, which is a simple function.\ntype HttpRoundTripFunc func(req *http.Request) (resp *http.Response, err error)\n\n// RoundTrip implements http.RoundTripper.\nfunc (fn HttpRoundTripFunc) RoundTrip(req *http.Request) (*http.Response, error) {\n\treturn fn(req)\n}\n\n// HttpRoundTripWrapper is transport middleware function.\ntype HttpRoundTripWrapper func(rt http.RoundTripper) http.RoundTripper\n\n// HttpRoundTripWrapperFunc is transport middleware function, more convenient than HttpRoundTripWrapper.\ntype HttpRoundTripWrapperFunc func(rt http.RoundTripper) HttpRoundTripFunc\n\nfunc (f HttpRoundTripWrapperFunc) wrapper() HttpRoundTripWrapper {\n\treturn func(rt http.RoundTripper) http.RoundTripper {\n\t\treturn f(rt)\n\t}\n}\n\n// WrapRoundTripFunc adds a transport middleware function that will give the caller\n// an opportunity to wrap the underlying http.RoundTripper.\nfunc (t *Transport) WrapRoundTripFunc(funcs ...HttpRoundTripWrapperFunc) *Transport {\n\tvar wrappers []HttpRoundTripWrapper\n\tfor _, fn := range funcs {\n\t\twrappers = append(wrappers, fn.wrapper())\n\t}\n\treturn t.WrapRoundTrip(wrappers...)\n}\n\n// WrapRoundTrip adds a transport middleware function that will give the caller\n// an opportunity to wrap the underlying http.RoundTripper.\nfunc (t *Transport) WrapRoundTrip(wrappers ...HttpRoundTripWrapper) *Transport {\n\tif len(wrappers) == 0 {\n\t\treturn t\n\t}\n\tif t.wrappedRoundTrip == nil {\n\t\tt.httpRoundTripWrappers = wrappers\n\t\tfn := func(req *http.Request) (*http.Response, error) {\n\t\t\treturn t.roundTrip(req)\n\t\t}\n\t\tt.wrappedRoundTrip = HttpRoundTripFunc(fn)\n\t} else {\n\t\tt.httpRoundTripWrappers = append(t.httpRoundTripWrappers, wrappers...)\n\t}\n\n\tfor _, w := range wrappers {\n\t\tt.wrappedRoundTrip = w(t.wrappedRoundTrip)\n\t}\n\treturn t\n}\n\n// DisableAutoDecode disable auto-detect charset and decode to utf-8\n// (enabled by default).\nfunc (t *Transport) DisableAutoDecode() *Transport {\n\tt.disableAutoDecode = true\n\treturn t\n}\n\n// EnableAutoDecode enable auto-detect charset and decode to utf-8\n// (enabled by default).\nfunc (t *Transport) EnableAutoDecode() *Transport {\n\tt.disableAutoDecode = false\n\treturn t\n}\n\n// SetAutoDecodeContentTypeFunc set the function that determines whether the\n// specified `Content-Type` should be auto-detected and decode to utf-8.\nfunc (t *Transport) SetAutoDecodeContentTypeFunc(fn func(contentType string) bool) *Transport {\n\tt.autoDecodeContentType = fn\n\treturn t\n}\n\n// SetAutoDecodeAllContentType enable try auto-detect charset and decode all\n// content type to utf-8.\nfunc (t *Transport) SetAutoDecodeAllContentType() *Transport {\n\tt.autoDecodeContentType = func(contentType string) bool {\n\t\treturn true\n\t}\n\treturn t\n}\n\n// SetAutoDecodeContentType set the content types that will be auto-detected and decode\n// to utf-8 (e.g. \"json\", \"xml\", \"html\", \"text\").\nfunc (t *Transport) SetAutoDecodeContentType(contentTypes ...string) {\n\tt.autoDecodeContentType = autoDecodeContentTypeFunc(contentTypes...)\n}\n\n// GetMaxIdleConns returns MaxIdleConns.\nfunc (t *Transport) GetMaxIdleConns() int {\n\treturn t.MaxIdleConns\n}\n\n// SetMaxIdleConns set the MaxIdleConns, which controls the maximum number of idle (keep-alive)\n// connections across all hosts. Zero means no limit.\nfunc (t *Transport) SetMaxIdleConns(max int) *Transport {\n\tt.MaxIdleConns = max\n\treturn t\n}\n\n// SetMaxConnsPerHost set the MaxConnsPerHost, optionally limits the\n// total number of connections per host, including connections in the\n// dialing, active, and idle states. On limit violation, dials will block.\n//\n// Zero means no limit.\nfunc (t *Transport) SetMaxConnsPerHost(max int) *Transport {\n\tt.MaxConnsPerHost = max\n\treturn t\n}\n\n// SetIdleConnTimeout set the IdleConnTimeout, which  is the maximum\n// amount of time an idle (keep-alive) connection will remain idle before\n// closing itself.\n//\n// Zero means no limit.\nfunc (t *Transport) SetIdleConnTimeout(timeout time.Duration) *Transport {\n\tt.IdleConnTimeout = timeout\n\treturn t\n}\n\n// SetTLSHandshakeTimeout set the TLSHandshakeTimeout, which specifies the\n// maximum amount of time waiting to wait for a TLS handshake.\n//\n// Zero means no timeout.\nfunc (t *Transport) SetTLSHandshakeTimeout(timeout time.Duration) *Transport {\n\tt.TLSHandshakeTimeout = timeout\n\treturn t\n}\n\n// SetResponseHeaderTimeout set the ResponseHeaderTimeout, if non-zero, specifies\n// the amount of time to wait for a server's response headers after fully writing\n// the request (including its body, if any). This time does not include the time\n// to read the response body.\nfunc (t *Transport) SetResponseHeaderTimeout(timeout time.Duration) *Transport {\n\tt.ResponseHeaderTimeout = timeout\n\treturn t\n}\n\n// SetExpectContinueTimeout set the ExpectContinueTimeout, if non-zero, specifies\n// the amount of time to wait for a server's first response headers after fully\n// writing the request headers if the request has an \"Expect: 100-continue\" header.\n// Zero means no timeout and causes the body to be sent immediately, without waiting\n// for the server to approve.\n// This time does not include the time to send the request header.\nfunc (t *Transport) SetExpectContinueTimeout(timeout time.Duration) *Transport {\n\tt.ExpectContinueTimeout = timeout\n\treturn t\n}\n\n// SetGetProxyConnectHeader set the GetProxyConnectHeader, which optionally specifies a func\n// to return headers to send to proxyURL during a CONNECT request to the ip:port target.\n// If it returns an error, the Transport's RoundTrip fails with that error. It can\n// return (nil, nil) to not add headers.\n// If GetProxyConnectHeader is non-nil, ProxyConnectHeader is ignored.\nfunc (t *Transport) SetGetProxyConnectHeader(fn func(ctx context.Context, proxyURL *url.URL, target string) (http.Header, error)) *Transport {\n\tt.GetProxyConnectHeader = fn\n\treturn t\n}\n\n// SetProxyConnectHeader set the ProxyConnectHeader, which optionally specifies headers to\n// send to proxies during CONNECT requests.\n// To set the header dynamically, see SetGetProxyConnectHeader.\nfunc (t *Transport) SetProxyConnectHeader(header http.Header) *Transport {\n\tt.ProxyConnectHeader = header\n\treturn t\n}\n\n// SetReadBufferSize set the ReadBufferSize, which specifies the size of the read buffer used\n// when reading from the transport.\n// If zero, a default (currently 4KB) is used.\nfunc (t *Transport) SetReadBufferSize(size int) *Transport {\n\tt.ReadBufferSize = size\n\treturn t\n}\n\n// SetWriteBufferSize set the WriteBufferSize, which specifies the size of the write buffer used\n// when writing to the transport.\n// If zero, a default (currently 4KB) is used.\nfunc (t *Transport) SetWriteBufferSize(size int) *Transport {\n\tt.WriteBufferSize = size\n\treturn t\n}\n\n// SetMaxResponseHeaderBytes set the MaxResponseHeaderBytes, which specifies a limit on how many\n// response bytes are allowed in the server's response header.\n//\n// Zero means to use a default limit.\nfunc (t *Transport) SetMaxResponseHeaderBytes(max int64) *Transport {\n\tt.MaxResponseHeaderBytes = max\n\treturn t\n}\n\n// SetHTTP2MaxHeaderListSize set the http2 MaxHeaderListSize,\n// which is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to\n// send in the initial settings frame. It is how many bytes\n// of response headers are allowed. Unlike the http2 spec, zero here\n// means to use a default limit (currently 10MB). If you actually\n// want to advertise an unlimited value to the peer, Transport\n// interprets the highest possible value here (0xffffffff or 1<<32-1)\n// to mean no limit.\nfunc (t *Transport) SetHTTP2MaxHeaderListSize(max uint32) *Transport {\n\tt.t2.MaxHeaderListSize = max\n\treturn t\n}\n\n// SetHTTP2StrictMaxConcurrentStreams set the http2\n// StrictMaxConcurrentStreams, which controls whether the\n// server's SETTINGS_MAX_CONCURRENT_STREAMS should be respected\n// globally. If false, new TCP connections are created to the\n// server as needed to keep each under the per-connection\n// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the\n// server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as\n// a global limit and callers of RoundTrip block when needed,\n// waiting for their turn.\nfunc (t *Transport) SetHTTP2StrictMaxConcurrentStreams(strict bool) *Transport {\n\tt.t2.StrictMaxConcurrentStreams = strict\n\treturn t\n}\n\n// SetHTTP2ReadIdleTimeout set the http2 ReadIdleTimeout,\n// which is the timeout after which a health check using ping\n// frame will be carried out if no frame is received on the connection.\n// Note that a ping response will is considered a received frame, so if\n// there is no other traffic on the connection, the health check will\n// be performed every ReadIdleTimeout interval.\n// If zero, no health check is performed.\nfunc (t *Transport) SetHTTP2ReadIdleTimeout(timeout time.Duration) *Transport {\n\tt.t2.ReadIdleTimeout = timeout\n\treturn t\n}\n\n// SetHTTP2PingTimeout set the http2 PingTimeout, which is the timeout\n// after which the connection will be closed if a response to Ping is\n// not received.\n// Defaults to 15s\nfunc (t *Transport) SetHTTP2PingTimeout(timeout time.Duration) *Transport {\n\tt.t2.PingTimeout = timeout\n\treturn t\n}\n\n// SetHTTP2WriteByteTimeout set the http2 WriteByteTimeout, which is the\n// timeout after which the connection will be closed no data can be written\n// to it. The timeout begins when data is available to write, and is\n// extended whenever any bytes are written.\nfunc (t *Transport) SetHTTP2WriteByteTimeout(timeout time.Duration) *Transport {\n\tt.t2.WriteByteTimeout = timeout\n\treturn t\n}\n\n// SetHTTP2SettingsFrame set the ordered http2 settings frame.\nfunc (t *Transport) SetHTTP2SettingsFrame(settings ...http2.Setting) *Transport {\n\tt.t2.Settings = settings\n\treturn t\n}\n\n// SetHTTP2ConnectionFlow set the default http2 connection flow, which is the increment\n// value of initial WINDOW_UPDATE frame.\nfunc (t *Transport) SetHTTP2ConnectionFlow(flow uint32) *Transport {\n\tt.t2.ConnectionFlow = flow\n\treturn t\n}\n\n// SetHTTP2HeaderPriority set the header priority param.\nfunc (t *Transport) SetHTTP2HeaderPriority(priority http2.PriorityParam) *Transport {\n\tt.t2.HeaderPriority = priority\n\treturn t\n}\n\n// SetHTTP2PriorityFrames set the ordered http2 priority frames.\nfunc (t *Transport) SetHTTP2PriorityFrames(frames ...http2.PriorityFrame) *Transport {\n\tt.t2.PriorityFrames = frames\n\treturn t\n}\n\n// SetTLSClientConfig set the custom TLSClientConfig, which specifies the TLS configuration to\n// use with tls.Client.\n// If nil, the default configuration is used.\n// If non-nil, HTTP/2 support may not be enabled by default.\nfunc (t *Transport) SetTLSClientConfig(cfg *tls.Config) *Transport {\n\tt.TLSClientConfig = cfg\n\treturn t\n}\n\n// SetDebug set the optional debug function.\nfunc (t *Transport) SetDebug(debugf func(format string, v ...interface{})) *Transport {\n\tt.Debugf = debugf\n\treturn t\n}\n\n// SetProxy set the http proxy, only valid for HTTP1 and HTTP2, which specifies a function\n// to return a proxy for a given Request. If the function returns a non-nil error, the request\n// is aborted with the provided error.\n//\n// The proxy type is determined by the URL scheme. \"http\",\n// \"https\", and \"socks5\" are supported. If the scheme is empty,\n// \"http\" is assumed.\n//\n// If Proxy is nil or returns a nil *URL, no proxy is used.\nfunc (t *Transport) SetProxy(proxy func(*http.Request) (*url.URL, error)) *Transport {\n\tt.Proxy = proxy\n\treturn t\n}\n\n// SetDial set the custom DialContext function, only valid for HTTP1 and HTTP2, which specifies the\n// dial function for creating unencrypted TCP connections.\n// If it is nil, then the transport dials using package net.\n//\n// The dial function runs concurrently with calls to RoundTrip.\n// A RoundTrip call that initiates a dial may end up using a connection dialed previously when the\n// earlier connection becomes idle before the later dial function completes.\nfunc (t *Transport) SetDial(fn func(ctx context.Context, network, addr string) (net.Conn, error)) *Transport {\n\tt.DialContext = fn\n\treturn t\n}\n\n// SetDialTLS set the custom DialTLSContext function, only valid for HTTP1 and HTTP2, which specifies\n// an optional dial function for creating TLS connections for non-proxied HTTPS requests (proxy will\n// not work if set).\n//\n// If it is nil, DialContext and TLSClientConfig are used.\n//\n// If it is set, the function that set in SetDial is not used for HTTPS requests and the TLSClientConfig\n// and TLSHandshakeTimeout are ignored. The returned net.Conn is assumed to already be past the TLS handshake.\nfunc (t *Transport) SetDialTLS(fn func(ctx context.Context, network, addr string) (net.Conn, error)) *Transport {\n\tt.DialTLSContext = fn\n\treturn t\n}\n\n// SetTLSHandshake set the custom tls handshake function, only valid for HTTP1 and HTTP2, not HTTP3,\n// it specifies an optional dial function for tls handshake, it works even if a proxy is set, can be\n// used to customize the tls fingerprint.\nfunc (t *Transport) SetTLSHandshake(fn func(ctx context.Context, addr string, plainConn net.Conn) (conn net.Conn, tlsState *tls.ConnectionState, err error)) *Transport {\n\tt.TLSHandshakeContext = fn\n\treturn t\n}\n\ntype pendingAltSvc struct {\n\tCurrentIndex int\n\tEntries      []*altsvc.AltSvc\n\tMu           sync.Mutex\n\tLastTime     time.Time\n\tTransport    http.RoundTripper\n}\n\n// EnableForceHTTP1 enable force using HTTP1 (disabled by default).\nfunc (t *Transport) EnableForceHTTP1() *Transport {\n\tt.forceHttpVersion = h1\n\treturn t\n}\n\n// EnableForceHTTP2 enable force using HTTP2 for https requests\n// (disabled by default).\nfunc (t *Transport) EnableForceHTTP2() *Transport {\n\tt.forceHttpVersion = h2\n\treturn t\n}\n\n// EnableH2C enables HTTP2 over TCP without TLS.\nfunc (t *Transport) EnableH2C() *Transport {\n\tt.Options.EnableH2C = true\n\tt.t2.AllowHTTP = true\n\tt.DialTLSContext = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\treturn net.Dial(network, addr)\n\t}\n\treturn t\n}\n\n// DisableH2C disables HTTP2 over TCP without TLS.\nfunc (t *Transport) DisableH2C() *Transport {\n\tt.Options.EnableH2C = false\n\tt.t2.AllowHTTP = false\n\tt.t2.DialTLSContext = nil\n\treturn t\n}\n\n// EnableForceHTTP3 enable force using HTTP3 for https requests\n// (disabled by default).\nfunc (t *Transport) EnableForceHTTP3() *Transport {\n\tt.EnableHTTP3()\n\tif t.t3 != nil {\n\t\tt.forceHttpVersion = h3\n\t}\n\treturn t\n}\n\n// DisableForceHttpVersion disable force using specified http\n// version (disabled by default).\nfunc (t *Transport) DisableForceHttpVersion() *Transport {\n\tt.forceHttpVersion = \"\"\n\treturn t\n}\n\nfunc (t *Transport) DisableHTTP3() {\n\tt.altSvcJar = nil\n\tt.pendingAltSvcs = nil\n\tt.t3 = nil\n}\n\nfunc (t *Transport) EnableHTTP3() {\n\tif t.t3 != nil {\n\t\treturn\n\t}\n\n\tv := runtime.Version()\n\tss := strings.Split(v, \".\")\n\n\tif len(ss) < 2 || ss[0] != \"go1\" {\n\t\tif t.Debugf != nil {\n\t\t\tt.Debugf(\"bad go version format: %s\", v)\n\t\t}\n\t\treturn\n\t}\n\tminorVersion, err := strconv.Atoi(ss[1])\n\tif err != nil {\n\t\tif t.Debugf != nil {\n\t\t\tt.Debugf(\"bad go minor version: %s\", v)\n\t\t}\n\t\treturn\n\t}\n\tif minorVersion < 22 || minorVersion > 23 {\n\t\tif t.Debugf != nil {\n\t\t\tt.Debugf(\"%s is not support http3\", v)\n\t\t}\n\t\treturn\n\t}\n\n\tif t.altSvcJar == nil {\n\t\tt.altSvcJar = altsvc.NewAltSvcJar()\n\t}\n\tif t.pendingAltSvcs == nil {\n\t\tt.pendingAltSvcs = make(map[string]*pendingAltSvc)\n\t}\n\tt3 := &http3.RoundTripper{\n\t\tOptions: &t.Options,\n\t}\n\tt.t3 = t3\n}\n\ntype wrapResponseBodyKeyType int\n\nconst wrapResponseBodyKey wrapResponseBodyKeyType = iota\n\ntype wrapResponseBodyFunc func(rc io.ReadCloser) io.ReadCloser\n\nfunc (t *Transport) handleResponseBody(res *http.Response, req *http.Request) {\n\tif wrap, ok := req.Context().Value(wrapResponseBodyKey).(wrapResponseBodyFunc); ok {\n\t\tt.wrapResponseBody(res, wrap)\n\t}\n\tt.autoDecodeResponseBody(res)\n\tdump.WrapResponseBodyIfNeeded(res, req, t.Dump)\n}\n\nvar allowedProtocols = map[string]bool{\n\t\"h3\": true,\n}\n\nfunc (t *Transport) handleAltSvc(req *http.Request, value string) {\n\taddr := netutil.AuthorityKey(req.URL)\n\tas := t.altSvcJar.GetAltSvc(addr)\n\tif as != nil {\n\t\treturn\n\t}\n\n\tt.pendingAltSvcsMu.Lock()\n\tdefer t.pendingAltSvcsMu.Unlock()\n\t_, ok := t.pendingAltSvcs[addr]\n\tif ok {\n\t\treturn\n\t}\n\tass, err := altsvcutil.ParseHeader(value)\n\tif err != nil {\n\t\tif t.Debugf != nil {\n\t\t\tt.Debugf(\"failed to parse alt-svc header: %s\", err.Error())\n\t\t}\n\t\treturn\n\t}\n\tvar entries []*altsvc.AltSvc\n\tfor _, a := range ass {\n\t\tif allowedProtocols[a.Protocol] {\n\t\t\tentries = append(entries, a)\n\t\t}\n\t}\n\tif len(entries) > 0 {\n\t\tpas := &pendingAltSvc{\n\t\t\tEntries: entries,\n\t\t}\n\t\tt.pendingAltSvcs[addr] = pas\n\t\tgo t.handlePendingAltSvc(req.URL, pas)\n\t}\n}\n\nfunc (t *Transport) handlePendingAltSvc(u *url.URL, pas *pendingAltSvc) {\n\tfor i := pas.CurrentIndex; i < len(pas.Entries); i++ {\n\t\tswitch pas.Entries[i].Protocol {\n\t\tcase \"h3\": // only support h3 in alt-svc for now\n\t\t\tu2 := altsvcutil.ConvertURL(pas.Entries[i], u)\n\t\t\thostname := u2.Host\n\t\t\terr := t.t3.AddConn(context.Background(), hostname)\n\t\t\tif err != nil {\n\t\t\t\tif t.Debugf != nil {\n\t\t\t\t\tt.Debugf(\"failed to get http3 connection: %s\", err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpas.CurrentIndex = i\n\t\t\t\tpas.Transport = t.t3\n\t\t\t\tif t.Debugf != nil {\n\t\t\t\t\tt.Debugf(\"detected that the server %s supports http3, will try to use http3 protocol in subsequent requests\", hostname)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *Transport) wrapResponseBody(res *http.Response, wrap wrapResponseBodyFunc) {\n\tswitch b := res.Body.(type) {\n\tcase *gzipReader:\n\t\tb.body.body = wrap(b.body.body)\n\tcase compress.CompressReader:\n\t\tb.SetUnderlyingBody(wrap(b.GetUnderlyingBody()))\n\tdefault:\n\t\tres.Body = wrap(res.Body)\n\t}\n}\n\nfunc (t *Transport) autoDecodeResponseBody(res *http.Response) {\n\tif t.disableAutoDecode || res.Header.Get(\"Accept-Encoding\") != \"\" {\n\t\treturn\n\t}\n\tcontentType := res.Header.Get(\"Content-Type\")\n\tvar shouldDecode func(contentType string) bool\n\tif t.autoDecodeContentType != nil {\n\t\tshouldDecode = t.autoDecodeContentType\n\t} else {\n\t\tshouldDecode = autoDecodeText\n\t}\n\tif !shouldDecode(contentType) {\n\t\treturn\n\t}\n\t_, params, err := mime.ParseMediaType(contentType)\n\tif err != nil {\n\t\tif t.Debugf != nil {\n\t\t\tt.Debugf(\"failed to parse content type %q: %v\", contentType, err)\n\t\t}\n\t} else if charset, ok := params[\"charset\"]; ok {\n\t\tcharset = strings.ToLower(charset)\n\t\tif strings.Contains(charset, \"utf-8\") || strings.Contains(charset, \"utf8\") { // do not decode utf-8\n\t\t\treturn\n\t\t}\n\t\tenc, _ := htmlcharset.Lookup(charset)\n\t\tif enc == nil {\n\t\t\tenc, err = ianaindex.MIME.Encoding(charset)\n\t\t\tif err != nil || enc == nil {\n\t\t\t\tif t.Debugf != nil {\n\t\t\t\t\tt.Debugf(\"ignore charset %s which is detected in Content-Type but not supported\", charset)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif t.Debugf != nil {\n\t\t\tt.Debugf(\"charset %s detected in Content-Type, auto-decode to utf-8\", charset)\n\t\t}\n\t\tdecodeReader := enc.NewDecoder().Reader(res.Body)\n\t\tres.Body = &decodeReaderCloser{res.Body, decodeReader}\n\t\treturn\n\t}\n\tres.Body = newAutoDecodeReadCloser(res.Body, t)\n}\n\nfunc (t *Transport) writeBufferSize() int {\n\tif t.WriteBufferSize > 0 {\n\t\treturn t.WriteBufferSize\n\t}\n\treturn 4 << 10\n}\n\nfunc (t *Transport) readBufferSize() int {\n\tif t.ReadBufferSize > 0 {\n\t\treturn t.ReadBufferSize\n\t}\n\treturn 4 << 10\n}\n\n// Clone returns a deep copy of t's exported fields.\nfunc (t *Transport) Clone() *Transport {\n\ttt := &Transport{\n\t\tHeaders:               t.Headers.Clone(),\n\t\tCookies:               cloneSlice(t.Cookies),\n\t\tOptions:               t.Options.Clone(),\n\t\tdisableAutoDecode:     t.disableAutoDecode,\n\t\tautoDecodeContentType: t.autoDecodeContentType,\n\t\tforceHttpVersion:      t.forceHttpVersion,\n\t\thttpRoundTripWrappers: t.httpRoundTripWrappers,\n\t}\n\tif len(tt.httpRoundTripWrappers) > 0 { // clone transport middleware\n\t\tfn := func(req *http.Request) (*http.Response, error) {\n\t\t\treturn tt.roundTrip(req)\n\t\t}\n\t\ttt.wrappedRoundTrip = HttpRoundTripFunc(fn)\n\t\tfor _, w := range tt.httpRoundTripWrappers {\n\t\t\ttt.wrappedRoundTrip = w(tt.wrappedRoundTrip)\n\t\t}\n\t}\n\tif t.t2 != nil {\n\t\ttt.t2 = &h2internal.Transport{\n\t\t\tOptions:                    &tt.Options,\n\t\t\tMaxHeaderListSize:          t.t2.MaxHeaderListSize,\n\t\t\tStrictMaxConcurrentStreams: t.t2.StrictMaxConcurrentStreams,\n\t\t\tReadIdleTimeout:            t.t2.ReadIdleTimeout,\n\t\t\tPingTimeout:                t.t2.PingTimeout,\n\t\t\tWriteByteTimeout:           t.t2.WriteByteTimeout,\n\t\t\tConnectionFlow:             t.t2.ConnectionFlow,\n\t\t\tSettings:                   cloneSlice(t.t2.Settings),\n\t\t\tHeaderPriority:             t.t2.HeaderPriority,\n\t\t\tPriorityFrames:             cloneSlice(t.t2.PriorityFrames),\n\t\t}\n\t}\n\tif t.t3 != nil {\n\t\ttt.EnableHTTP3()\n\t}\n\treturn tt\n}\n\n// EnableDump enables the dump for all requests with specified dump options.\nfunc (t *Transport) EnableDump(opt *DumpOptions) {\n\tdump := newDumper(opt)\n\tt.Dump = dump\n\tgo dump.Start()\n}\n\n// DisableDump disables the dump.\nfunc (t *Transport) DisableDump() {\n\tif t.Dump != nil {\n\t\tt.Dump.Stop()\n\t\tt.Dump = nil\n\t}\n}\n\nfunc (t *Transport) hasCustomTLSDialer() bool {\n\treturn t.DialTLSContext != nil\n}\n\n// transportRequest is a wrapper around a *Request that adds\n// optional extra headers to write and stores any error to return\n// from roundTrip.\ntype transportRequest struct {\n\t*http.Request                        // original request, not to be mutated\n\textra         http.Header            // extra headers to write, or nil\n\ttrace         *httptrace.ClientTrace // optional\n\n\tctx    context.Context // canceled when we are done with the request\n\tcancel context.CancelCauseFunc\n\n\tmu  sync.Mutex // guards err\n\terr error      // first setError value for mapRoundTripError to consider\n}\n\nfunc (tr *transportRequest) extraHeaders() http.Header {\n\tif tr.extra == nil {\n\t\ttr.extra = make(http.Header)\n\t}\n\treturn tr.extra\n}\n\nfunc (tr *transportRequest) setError(err error) {\n\ttr.mu.Lock()\n\tif tr.err == nil {\n\t\ttr.err = err\n\t}\n\ttr.mu.Unlock()\n}\n\nfunc (t *Transport) roundTripAltSvc(req *http.Request, as *altsvc.AltSvc) (resp *http.Response, err error) {\n\tr := req.Clone(req.Context())\n\tr.URL = altsvcutil.ConvertURL(as, req.URL)\n\tswitch as.Protocol {\n\tcase \"h3\":\n\t\tresp, err = t.t3.RoundTrip(r)\n\tcase \"h2\":\n\t\tresp, err = t.t2.RoundTrip(r)\n\tdefault:\n\t\t// impossible!\n\t\tpanic(fmt.Sprintf(\"unknown protocol %q\", as.Protocol))\n\t}\n\treturn\n}\n\nfunc (t *Transport) checkAltSvc(req *http.Request) (resp *http.Response, err error) {\n\tif t.altSvcJar == nil {\n\t\treturn\n\t}\n\taddr := netutil.AuthorityKey(req.URL)\n\tpas, ok := t.pendingAltSvcs[addr]\n\tif ok && pas.Transport != nil {\n\t\tpas.Mu.Lock()\n\t\tif pas.Transport != nil {\n\t\t\tpas.LastTime = time.Now()\n\t\t\tr := req.Clone(req.Context())\n\t\t\tr.URL = altsvcutil.ConvertURL(pas.Entries[pas.CurrentIndex], req.URL)\n\t\t\tresp, err = pas.Transport.RoundTrip(r)\n\t\t\tif err != nil {\n\t\t\t\tpas.Transport = nil\n\t\t\t\tif pas.CurrentIndex+1 < len(pas.Entries) {\n\t\t\t\t\tpas.CurrentIndex++\n\t\t\t\t\tgo t.handlePendingAltSvc(req.URL, pas)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.altSvcJar.SetAltSvc(addr, pas.Entries[pas.CurrentIndex])\n\t\t\t\tdelete(t.pendingAltSvcs, addr)\n\t\t\t}\n\t\t}\n\t\tpas.Mu.Unlock()\n\t\treturn\n\t}\n\tif as := t.altSvcJar.GetAltSvc(addr); as != nil {\n\t\treturn t.roundTripAltSvc(req, as)\n\t}\n\treturn\n}\n\nfunc validateHeaders(hdrs http.Header) string {\n\tfor k, vv := range hdrs {\n\t\tif !httpguts.ValidHeaderFieldName(k) {\n\t\t\treturn fmt.Sprintf(\"field name %q\", k)\n\t\t}\n\t\tfor _, v := range vv {\n\t\t\tif !httpguts.ValidHeaderFieldValue(v) {\n\t\t\t\t// Don't include the value in the error,\n\t\t\t\t// because it may be sensitive.\n\t\t\t\treturn fmt.Sprintf(\"field value for %q\", k)\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// roundTrip implements a http.RoundTripper over HTTP.\nfunc (t *Transport) roundTrip(req *http.Request) (resp *http.Response, err error) {\n\tctx := req.Context()\n\ttrace := httptrace.ContextClientTrace(ctx)\n\n\tif req.URL == nil {\n\t\tcloseBody(req)\n\t\treturn nil, errors.New(\"http: nil Request.URL\")\n\t}\n\n\tresp, err = t.checkAltSvc(req)\n\tif err != nil || resp != nil {\n\t\treturn\n\t}\n\n\tscheme := req.URL.Scheme\n\tisHTTP := scheme == \"http\" || scheme == \"https\"\n\n\tif isHTTP {\n\t\t// Validate the outgoing headers.\n\t\tif err := validateHeaders(req.Header); err != \"\" {\n\t\t\tcloseBody(req)\n\t\t\treturn nil, fmt.Errorf(\"net/http: invalid header %s\", err)\n\t\t}\n\n\t\t// Validate the outgoing trailers too.\n\t\tif err := validateHeaders(req.Trailer); err != \"\" {\n\t\t\tcloseBody(req)\n\t\t\treturn nil, fmt.Errorf(\"net/http: invalid trailer %s\", err)\n\t\t}\n\t}\n\n\tif req.Header == nil {\n\t\treq.Header = make(http.Header)\n\t}\n\n\tif t.forceHttpVersion != \"\" {\n\t\tswitch t.forceHttpVersion {\n\t\tcase h3:\n\t\t\treturn t.t3.RoundTrip(req)\n\t\tcase h2:\n\t\t\treturn t.t2.RoundTrip(req)\n\t\t}\n\t}\n\n\torigReq := req\n\treq = setupRewindBody(req)\n\n\tif scheme == \"https\" && t.forceHttpVersion != h1 {\n\t\tresp, err := t.t2.RoundTripOnlyCachedConn(req)\n\t\tif err != h2internal.ErrNoCachedConn {\n\t\t\treturn resp, err\n\t\t}\n\t\treq, err = rewindBody(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif t.t3 != nil {\n\t\t\tresp, err = t.t3.RoundTripOnlyCachedConn(req)\n\t\t\tif err != http3.ErrNoCachedConn {\n\t\t\t\treturn resp, err\n\t\t\t}\n\t\t\treq, err = rewindBody(req)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif !isHTTP {\n\t\tcloseBody(req)\n\t\treturn nil, badStringError(\"unsupported protocol scheme\", scheme)\n\t}\n\tif req.Method != \"\" && !validMethod(req.Method) {\n\t\tcloseBody(req)\n\t\treturn nil, fmt.Errorf(\"net/http: invalid method %q\", req.Method)\n\t}\n\tif req.URL.Host == \"\" {\n\t\tcloseBody(req)\n\t\treturn nil, errors.New(\"http: no Host in request URL\")\n\t}\n\n\t// Transport request context.\n\t//\n\t// If RoundTrip returns an error, it cancels this context before returning.\n\t//\n\t// If RoundTrip returns no error:\n\t//   - For an HTTP/1 request, persistConn.readLoop cancels this context\n\t//     after reading the request body.\n\t//   - For an HTTP/2 request, RoundTrip cancels this context after the HTTP/2\n\t//     RoundTripper returns.\n\tctx, cancel := context.WithCancelCause(req.Context())\n\n\t// Convert Request.Cancel into context cancelation.\n\tif origReq.Cancel != nil {\n\t\tgo awaitLegacyCancel(ctx, cancel, origReq)\n\t}\n\n\t// Convert Transport.CancelRequest into context cancelation.\n\t//\n\t// This is lamentably expensive. CancelRequest has been deprecated for a long time\n\t// and doesn't work on HTTP/2 requests. Perhaps we should drop support for it entirely.\n\tcancel = t.prepareTransportCancel(origReq, cancel)\n\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tcancel(err)\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tcloseBody(req)\n\t\t\treturn nil, context.Cause(ctx)\n\t\tdefault:\n\t\t}\n\n\t\t// treq gets modified by roundTrip, so we need to recreate for each retry.\n\t\ttreq := &transportRequest{Request: req, trace: trace, ctx: ctx, cancel: cancel}\n\t\tcm, err := t.connectMethodForRequest(treq)\n\t\tif err != nil {\n\t\t\tcloseBody(req)\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Get the cached or newly-created connection to either the\n\t\t// host (for http or https), the http proxy, or the http proxy\n\t\t// pre-CONNECTed to https server. In any case, we'll be ready\n\t\t// to send it requests.\n\t\tpconn, err := t.getConn(treq, cm)\n\t\tif err != nil {\n\t\t\tcloseBody(req)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar resp *http.Response\n\t\tif t.forceHttpVersion != h1 && pconn.alt != nil {\n\t\t\t// HTTP/2 path.\n\t\t\tresp, err = pconn.alt.RoundTrip(req)\n\t\t} else {\n\t\t\tresp, err = pconn.roundTrip(treq)\n\t\t}\n\t\tif err == nil {\n\t\t\tif pconn.alt != nil {\n\t\t\t\t// HTTP/2 requests are not cancelable with CancelRequest,\n\t\t\t\t// so we have no further need for the request context.\n\t\t\t\t//\n\t\t\t\t// On the HTTP/1 path, roundTrip takes responsibility for\n\t\t\t\t// canceling the context after the response body is read.\n\t\t\t\tcancel(errRequestDone)\n\t\t\t}\n\n\t\t\tresp.Request = origReq\n\t\t\treturn resp, nil\n\t\t}\n\n\t\t// Failed. Clean up and determine whether to retry.\n\t\tif h2internal.IsNoCachedConnError(err) {\n\t\t\tif t.removeIdleConn(pconn) {\n\t\t\t\tt.decConnsPerHost(pconn.cacheKey)\n\t\t\t}\n\t\t} else if !pconn.shouldRetryRequest(req, err) {\n\t\t\t// Issue 16465: return underlying net.Conn.Read error from peek,\n\t\t\t// as we've historically done.\n\t\t\tif e, ok := err.(nothingWrittenError); ok {\n\t\t\t\terr = e.error\n\t\t\t}\n\t\t\tif e, ok := err.(transportReadFromServerError); ok {\n\t\t\t\terr = e.err\n\t\t\t}\n\t\t\tif b, ok := req.Body.(*readTrackingBody); ok && !b.didClose {\n\t\t\t\t// Issue 49621: Close the request body if pconn.roundTrip\n\t\t\t\t// didn't do so already. This can happen if the pconn\n\t\t\t\t// write loop exits without reading the write request.\n\t\t\t\tcloseBody(req)\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\ttestHookRoundTripRetried()\n\n\t\t// Rewind the body if we're able to.\n\t\treq, err = rewindBody(req)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n}\n\nfunc awaitLegacyCancel(ctx context.Context, cancel context.CancelCauseFunc, req *http.Request) {\n\tselect {\n\tcase <-req.Cancel:\n\t\tcancel(common.ErrRequestCanceled)\n\tcase <-ctx.Done():\n\t}\n}\n\nvar errCannotRewind = errors.New(\"net/http: cannot rewind body after connection loss\")\n\ntype readTrackingBody struct {\n\tio.ReadCloser\n\tdidRead  bool\n\tdidClose bool\n}\n\nfunc (r *readTrackingBody) Read(data []byte) (int, error) {\n\tr.didRead = true\n\treturn r.ReadCloser.Read(data)\n}\n\nfunc (r *readTrackingBody) Close() error {\n\tr.didClose = true\n\treturn r.ReadCloser.Close()\n}\n\n// setupRewindBody returns a new request with a custom body wrapper\n// that can report whether the body needs rewinding.\n// This lets rewindBody avoid an error result when the request\n// does not have GetBody but the body hasn't been read at all yet.\nfunc setupRewindBody(req *http.Request) *http.Request {\n\tif req.Body == nil || req.Body == NoBody {\n\t\treturn req\n\t}\n\tnewReq := *req\n\tnewReq.Body = &readTrackingBody{ReadCloser: req.Body}\n\treturn &newReq\n}\n\n// rewindBody returns a new request with the body rewound.\n// It returns req unmodified if the body does not need rewinding.\n// rewindBody takes care of closing req.Body when appropriate\n// (in all cases except when rewindBody returns req unmodified).\nfunc rewindBody(req *http.Request) (rewound *http.Request, err error) {\n\tif req.Body == nil || req.Body == NoBody || (!req.Body.(*readTrackingBody).didRead && !req.Body.(*readTrackingBody).didClose) {\n\t\treturn req, nil // nothing to rewind\n\t}\n\tif !req.Body.(*readTrackingBody).didClose {\n\t\tcloseBody(req)\n\t}\n\tif req.GetBody == nil {\n\t\treturn nil, errCannotRewind\n\t}\n\tbody, err := req.GetBody()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnewReq := *req\n\tnewReq.Body = &readTrackingBody{ReadCloser: body}\n\treturn &newReq, nil\n}\n\n// shouldRetryRequest reports whether we should retry sending a failed\n// HTTP request on a new connection. The non-nil input error is the\n// error from roundTrip.\nfunc (pc *persistConn) shouldRetryRequest(req *http.Request, err error) bool {\n\tif h2internal.IsNoCachedConnError(err) {\n\t\t// Issue 16582: if the user started a bunch of\n\t\t// requests at once, they can all pick the same conn\n\t\t// and violate the server's max concurrent streams.\n\t\t// Instead, match the HTTP/1 behavior for now and dial\n\t\t// again to get a new TCP connection, rather than failing\n\t\t// this request.\n\t\treturn true\n\t}\n\tif err == errMissingHost {\n\t\t// User error.\n\t\treturn false\n\t}\n\tif !pc.isReused() {\n\t\t// This was a fresh connection. There's no reason the server\n\t\t// should've hung up on us.\n\t\t//\n\t\t// Also, if we retried now, we could loop forever\n\t\t// creating new connections and retrying if the server\n\t\t// is just hanging up on us because it doesn't like\n\t\t// our request (as opposed to sending an error).\n\t\treturn false\n\t}\n\tif _, ok := err.(nothingWrittenError); ok {\n\t\t// We never wrote anything, so it's safe to retry, if there's no body or we\n\t\t// can \"rewind\" the body with GetBody.\n\t\treturn outgoingLength(req) == 0 || req.GetBody != nil\n\t}\n\tif !isReplayable(req) {\n\t\t// Don't retry non-idempotent requests.\n\t\treturn false\n\t}\n\tif _, ok := err.(transportReadFromServerError); ok {\n\t\t// We got some non-EOF net.Conn.Read failure reading\n\t\t// the 1st response byte from the server.\n\t\treturn true\n\t}\n\tif err == errServerClosedIdle {\n\t\t// The server replied with io.EOF while we were trying to\n\t\t// read the response. Probably an unfortunately keep-alive\n\t\t// timeout, just as the client was writing a request.\n\t\treturn true\n\t}\n\treturn false // conservatively\n}\n\n// CloseIdleConnections closes any connections which were previously\n// connected from previous requests but are now sitting idle in\n// a \"keep-alive\" state. It does not interrupt any connections currently\n// in use.\nfunc (t *Transport) CloseIdleConnections() {\n\tt.idleMu.Lock()\n\tm := t.idleConn\n\tt.idleConn = nil\n\tt.closeIdle = true // close newly idle connections\n\tt.idleLRU = connLRU{}\n\tt.idleMu.Unlock()\n\tfor _, conns := range m {\n\t\tfor _, pconn := range conns {\n\t\t\tpconn.close(errCloseIdleConns)\n\t\t}\n\t}\n\tt.connsPerHostMu.Lock()\n\tt.dialsInProgress.all(func(w *wantConn) {\n\t\tif w.cancelCtx != nil && !w.waiting() {\n\t\t\tw.cancelCtx()\n\t\t}\n\t})\n\tt.connsPerHostMu.Unlock()\n\n\tif t2 := t.t2; t2 != nil {\n\t\tt2.CloseIdleConnections()\n\t}\n}\n\n// prepareTransportCancel sets up state to convert Transport.CancelRequest into context cancelation.\nfunc (t *Transport) prepareTransportCancel(req *http.Request, origCancel context.CancelCauseFunc) context.CancelCauseFunc {\n\t// Historically, RoundTrip has not modified the Request in any way.\n\t// We could avoid the need to keep a map of all in-flight requests by adding\n\t// a field to the Request containing its cancel func, and setting that field\n\t// while the request is in-flight. Callers aren't supposed to reuse a Request\n\t// until after the response body is closed, so this wouldn't violate any\n\t// concurrency guarantees.\n\tcancel := func(err error) {\n\t\torigCancel(err)\n\t\tt.reqMu.Lock()\n\t\tdelete(t.reqCanceler, req)\n\t\tt.reqMu.Unlock()\n\t}\n\tt.reqMu.Lock()\n\tif t.reqCanceler == nil {\n\t\tt.reqCanceler = make(map[*http.Request]context.CancelCauseFunc)\n\t}\n\tt.reqCanceler[req] = cancel\n\tt.reqMu.Unlock()\n\treturn cancel\n}\n\n// CancelRequest cancels an in-flight request by closing its connection.\n// CancelRequest should only be called after [Transport.RoundTrip] has returned.\n//\n// Deprecated: Use [Request.WithContext] to create a request with a\n// cancelable context instead. CancelRequest cannot cancel HTTP/2\n// requests. This may become a no-op in a future release of Go.\nfunc (t *Transport) CancelRequest(req *http.Request) {\n\tt.reqMu.Lock()\n\tcancel := t.reqCanceler[req]\n\tt.reqMu.Unlock()\n\tif cancel != nil {\n\t\tcancel(common.ErrRequestCanceled)\n\t}\n}\n\n// resetProxyConfig is used by tests.\nfunc resetProxyConfig() {\n}\n\nfunc (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error) {\n\tcm.targetScheme = treq.URL.Scheme\n\tcm.targetAddr = canonicalAddr(treq.URL)\n\tif t.Proxy != nil {\n\t\tcm.proxyURL, err = t.Proxy(treq.Request)\n\t}\n\tcm.onlyH1 = t.forceHttpVersion == h1 || requestRequiresHTTP1(treq.Request)\n\treturn cm, err\n}\n\n// proxyAuth returns the Proxy-Authorization header to set\n// on requests, if applicable.\nfunc (cm *connectMethod) proxyAuth() string {\n\tif cm.proxyURL == nil {\n\t\treturn \"\"\n\t}\n\tif u := cm.proxyURL.User; u != nil {\n\t\tusername := u.Username()\n\t\tpassword, _ := u.Password()\n\t\treturn \"Basic \" + basicAuth(username, password)\n\t}\n\treturn \"\"\n}\n\n// error values for debugging and testing, not seen by users.\nvar (\n\terrKeepAlivesDisabled = errors.New(\"http: putIdleConn: keep alives disabled\")\n\terrConnBroken         = errors.New(\"http: putIdleConn: connection is in bad state\")\n\terrCloseIdle          = errors.New(\"http: putIdleConn: CloseIdleConnections was called\")\n\terrTooManyIdle        = errors.New(\"http: putIdleConn: too many idle connections\")\n\terrTooManyIdleHost    = errors.New(\"http: putIdleConn: too many idle connections for host\")\n\terrCloseIdleConns     = errors.New(\"http: CloseIdleConnections called\")\n\terrReadLoopExiting    = errors.New(\"http: persistConn.readLoop exiting\")\n\terrIdleConnTimeout    = errors.New(\"http: idle connection timeout\")\n\n\t// errServerClosedIdle is not seen by users for idempotent requests, but may be\n\t// seen by a user if the server shuts down an idle connection and sends its FIN\n\t// in flight with already-written POST body bytes from the client.\n\t// See https://github.com/golang/go/issues/19943#issuecomment-355607646\n\terrServerClosedIdle = errors.New(\"http: server closed idle connection\")\n)\n\n// transportReadFromServerError is used by Transport.readLoop when the\n// 1 byte peek read fails and we're actually anticipating a response.\n// Usually this is just due to the inherent keep-alive shut down race,\n// where the server closed the connection at the same time the client\n// wrote. The underlying err field is usually io.EOF or some\n// ECONNRESET sort of thing which varies by platform. But it might be\n// the user's custom net.Conn.Read error too, so we carry it along for\n// them to return from Transport.RoundTrip.\ntype transportReadFromServerError struct {\n\terr error\n}\n\nfunc (e transportReadFromServerError) Unwrap() error { return e.err }\n\nfunc (e transportReadFromServerError) Error() string {\n\treturn fmt.Sprintf(\"net/http: Transport failed to read from server: %v\", e.err)\n}\n\nfunc (t *Transport) putOrCloseIdleConn(pconn *persistConn) {\n\tif err := t.tryPutIdleConn(pconn); err != nil {\n\t\tpconn.close(err)\n\t}\n}\n\nfunc (t *Transport) maxIdleConnsPerHost() int {\n\tif v := t.MaxIdleConnsPerHost; v != 0 {\n\t\treturn v\n\t}\n\treturn defaultMaxIdleConnsPerHost\n}\n\n// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting\n// a new request.\n// If pconn is no longer needed or not in a good state, tryPutIdleConn returns\n// an error explaining why it wasn't registered.\n// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.\nfunc (t *Transport) tryPutIdleConn(pconn *persistConn) error {\n\tif t.DisableKeepAlives || t.MaxIdleConnsPerHost < 0 {\n\t\treturn errKeepAlivesDisabled\n\t}\n\tif pconn.isBroken() {\n\t\treturn errConnBroken\n\t}\n\tpconn.markReused()\n\n\tt.idleMu.Lock()\n\tdefer t.idleMu.Unlock()\n\n\t// HTTP/2 (pconn.alt != nil) connections do not come out of the idle list,\n\t// because multiple goroutines can use them simultaneously.\n\t// If this is an HTTP/2 connection being “returned,” we're done.\n\tif pconn.alt != nil && t.idleLRU.m[pconn] != nil {\n\t\treturn nil\n\t}\n\n\t// Deliver pconn to goroutine waiting for idle connection, if any.\n\t// (They may be actively dialing, but this conn is ready first.\n\t// Chrome calls this socket late binding.\n\t// See https://www.chromium.org/developers/design-documents/network-stack#TOC-Connection-Management.)\n\tkey := pconn.cacheKey\n\tif q, ok := t.idleConnWait[key]; ok {\n\t\tdone := false\n\t\tif pconn.alt == nil {\n\t\t\t// HTTP/1.\n\t\t\t// Loop over the waiting list until we find a w that isn't done already, and hand it pconn.\n\t\t\tfor q.len() > 0 {\n\t\t\t\tw := q.popFront()\n\t\t\t\tif w.tryDeliver(pconn, nil, time.Time{}) {\n\t\t\t\t\tdone = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// HTTP/2.\n\t\t\t// Can hand the same pconn to everyone in the waiting list,\n\t\t\t// and we still won't be done: we want to put it in the idle\n\t\t\t// list unconditionally, for any future clients too.\n\t\t\tfor q.len() > 0 {\n\t\t\t\tw := q.popFront()\n\t\t\t\tw.tryDeliver(pconn, nil, time.Time{})\n\t\t\t}\n\t\t}\n\t\tif q.len() == 0 {\n\t\t\tdelete(t.idleConnWait, key)\n\t\t} else {\n\t\t\tt.idleConnWait[key] = q\n\t\t}\n\t\tif done {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif t.closeIdle {\n\t\treturn errCloseIdle\n\t}\n\tif t.idleConn == nil {\n\t\tt.idleConn = make(map[connectMethodKey][]*persistConn)\n\t}\n\tidles := t.idleConn[key]\n\tif len(idles) >= t.maxIdleConnsPerHost() {\n\t\treturn errTooManyIdleHost\n\t}\n\tfor _, exist := range idles {\n\t\tif exist == pconn {\n\t\t\tlog.Fatalf(\"dup idle pconn %p in freelist\", pconn)\n\t\t}\n\t}\n\tt.idleConn[key] = append(idles, pconn)\n\tt.idleLRU.add(pconn)\n\tif t.MaxIdleConns != 0 && t.idleLRU.len() > t.MaxIdleConns {\n\t\toldest := t.idleLRU.removeOldest()\n\t\toldest.close(errTooManyIdle)\n\t\tt.removeIdleConnLocked(oldest)\n\t}\n\n\t// Set idle timer, but only for HTTP/1 (pconn.alt == nil).\n\t// The HTTP/2 implementation manages the idle timer itself\n\t// (see idleConnTimeout in h2_bundle.go).\n\tif t.IdleConnTimeout > 0 && pconn.alt == nil {\n\t\tif pconn.idleTimer != nil {\n\t\t\tpconn.idleTimer.Reset(t.IdleConnTimeout)\n\t\t} else {\n\t\t\tpconn.idleTimer = time.AfterFunc(t.IdleConnTimeout, pconn.closeConnIfStillIdle)\n\t\t}\n\t}\n\tpconn.idleAt = time.Now()\n\treturn nil\n}\n\n// queueForIdleConn queues w to receive the next idle connection for w.cm.\n// As an optimization hint to the caller, queueForIdleConn reports whether\n// it successfully delivered an already-idle connection.\nfunc (t *Transport) queueForIdleConn(w *wantConn) (delivered bool) {\n\tif t.DisableKeepAlives {\n\t\treturn false\n\t}\n\n\tt.idleMu.Lock()\n\tdefer t.idleMu.Unlock()\n\n\t// Stop closing connections that become idle - we might want one.\n\t// (That is, undo the effect of t.CloseIdleConnections.)\n\tt.closeIdle = false\n\n\tif w == nil {\n\t\t// Happens in test hook.\n\t\treturn false\n\t}\n\n\t// If IdleConnTimeout is set, calculate the oldest\n\t// persistConn.idleAt time we're willing to use a cached idle\n\t// conn.\n\tvar oldTime time.Time\n\tif t.IdleConnTimeout > 0 {\n\t\toldTime = time.Now().Add(-t.IdleConnTimeout)\n\t}\n\n\t// Look for most recently-used idle connection.\n\tif list, ok := t.idleConn[w.key]; ok {\n\t\tstop := false\n\t\tdelivered := false\n\t\tfor len(list) > 0 && !stop {\n\t\t\tpconn := list[len(list)-1]\n\n\t\t\t// See whether this connection has been idle too long, considering\n\t\t\t// only the wall time (the Round(0)), in case this is a laptop or VM\n\t\t\t// coming out of suspend with previously cached idle connections.\n\t\t\ttooOld := !oldTime.IsZero() && pconn.idleAt.Round(0).Before(oldTime)\n\t\t\tif tooOld {\n\t\t\t\t// Async cleanup. Launch in its own goroutine (as if a\n\t\t\t\t// time.AfterFunc called it); it acquires idleMu, which we're\n\t\t\t\t// holding, and does a synchronous net.Conn.Close.\n\t\t\t\tgo pconn.closeConnIfStillIdle()\n\t\t\t}\n\t\t\tif pconn.isBroken() || tooOld {\n\t\t\t\t// If either persistConn.readLoop has marked the connection\n\t\t\t\t// broken, but Transport.removeIdleConn has not yet removed it\n\t\t\t\t// from the idle list, or if this persistConn is too old (it was\n\t\t\t\t// idle too long), then ignore it and look for another. In both\n\t\t\t\t// cases it's already in the process of being closed.\n\t\t\t\tlist = list[:len(list)-1]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdelivered = w.tryDeliver(pconn, nil, pconn.idleAt)\n\t\t\tif delivered {\n\t\t\t\tif pconn.alt != nil {\n\t\t\t\t\t// HTTP/2: multiple clients can share pconn.\n\t\t\t\t\t// Leave it in the list.\n\t\t\t\t} else {\n\t\t\t\t\t// HTTP/1: only one client can use pconn.\n\t\t\t\t\t// Remove it from the list.\n\t\t\t\t\tt.idleLRU.remove(pconn)\n\t\t\t\t\tlist = list[:len(list)-1]\n\t\t\t\t}\n\t\t\t}\n\t\t\tstop = true\n\t\t}\n\t\tif len(list) > 0 {\n\t\t\tt.idleConn[w.key] = list\n\t\t} else {\n\t\t\tdelete(t.idleConn, w.key)\n\t\t}\n\t\tif stop {\n\t\t\treturn delivered\n\t\t}\n\t}\n\n\t// Register to receive next connection that becomes idle.\n\tif t.idleConnWait == nil {\n\t\tt.idleConnWait = make(map[connectMethodKey]wantConnQueue)\n\t}\n\tq := t.idleConnWait[w.key]\n\tq.cleanFrontNotWaiting()\n\tq.pushBack(w)\n\tt.idleConnWait[w.key] = q\n\treturn false\n}\n\n// removeIdleConn marks pconn as dead.\nfunc (t *Transport) removeIdleConn(pconn *persistConn) bool {\n\tt.idleMu.Lock()\n\tdefer t.idleMu.Unlock()\n\treturn t.removeIdleConnLocked(pconn)\n}\n\n// t.idleMu must be held.\nfunc (t *Transport) removeIdleConnLocked(pconn *persistConn) bool {\n\tif pconn.idleTimer != nil {\n\t\tpconn.idleTimer.Stop()\n\t}\n\tt.idleLRU.remove(pconn)\n\tkey := pconn.cacheKey\n\tpconns := t.idleConn[key]\n\tvar removed bool\n\tswitch len(pconns) {\n\tcase 0:\n\t\t// Nothing\n\tcase 1:\n\t\tif pconns[0] == pconn {\n\t\t\tdelete(t.idleConn, key)\n\t\t\tremoved = true\n\t\t}\n\tdefault:\n\t\tfor i, v := range pconns {\n\t\t\tif v != pconn {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Slide down, keeping most recently-used\n\t\t\t// conns at the end.\n\t\t\tcopy(pconns[i:], pconns[i+1:])\n\t\t\tt.idleConn[key] = pconns[:len(pconns)-1]\n\t\t\tremoved = true\n\t\t\tbreak\n\t\t}\n\t}\n\treturn removed\n}\n\nvar zeroDialer net.Dialer\n\nfunc (t *Transport) dial(ctx context.Context, network, addr string) (net.Conn, error) {\n\tif t.DialContext != nil {\n\t\tc, err := t.DialContext(ctx, network, addr)\n\t\tif c == nil && err == nil {\n\t\t\terr = errors.New(\"net/http: Transport.DialContext hook returned (nil, nil)\")\n\t\t}\n\t\treturn c, err\n\t}\n\treturn zeroDialer.DialContext(ctx, network, addr)\n}\n\n// A wantConn records state about a wanted connection\n// (that is, an active call to getConn).\n// The conn may be gotten by dialing or by finding an idle connection,\n// or a cancellation may make the conn no longer wanted.\n// These three options are racing against each other and use\n// wantConn to coordinate and agree about the winning outcome.\ntype wantConn struct {\n\tcm  connectMethod\n\tkey connectMethodKey // cm.key()\n\n\t// hooks for testing to know when dials are done\n\t// beforeDial is called in the getConn goroutine when the dial is queued.\n\t// afterDial is called when the dial is completed or canceled.\n\tbeforeDial func()\n\tafterDial  func()\n\n\tmu        sync.Mutex      // protects ctx, done and sending of the result\n\tctx       context.Context // context for dial, cleared after delivered or canceled\n\tcancelCtx context.CancelFunc\n\tdone      bool             // true after delivered or canceled\n\tresult    chan connOrError // channel to deliver connection or error\n}\n\ntype connOrError struct {\n\tpc     *persistConn\n\terr    error\n\tidleAt time.Time\n}\n\n// waiting reports whether w is still waiting for an answer (connection or error).\nfunc (w *wantConn) waiting() bool {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\treturn !w.done\n}\n\n// getCtxForDial returns context for dial or nil if connection was delivered or canceled.\nfunc (w *wantConn) getCtxForDial() context.Context {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\treturn w.ctx\n}\n\n// tryDeliver attempts to deliver pc, err to w and reports whether it succeeded.\nfunc (w *wantConn) tryDeliver(pc *persistConn, err error, idleAt time.Time) bool {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tif w.done {\n\t\treturn false\n\t}\n\tif (pc == nil) == (err == nil) {\n\t\tpanic(\"net/http: internal error: misuse of tryDeliver\")\n\t}\n\tw.ctx = nil\n\tw.done = true\n\n\tw.result <- connOrError{pc: pc, err: err, idleAt: idleAt}\n\tclose(w.result)\n\n\treturn true\n}\n\n// cancel marks w as no longer wanting a result (for example, due to cancellation).\n// If a connection has been delivered already, cancel returns it with t.putOrCloseIdleConn.\nfunc (w *wantConn) cancel(t *Transport, err error) {\n\tw.mu.Lock()\n\tvar pc *persistConn\n\tif w.done {\n\t\tif r, ok := <-w.result; ok {\n\t\t\tpc = r.pc\n\t\t}\n\t} else {\n\t\tclose(w.result)\n\t}\n\tw.ctx = nil\n\tw.done = true\n\tw.mu.Unlock()\n\n\tif pc != nil {\n\t\tt.putOrCloseIdleConn(pc)\n\t}\n}\n\n// A wantConnQueue is a queue of wantConns.\ntype wantConnQueue struct {\n\t// This is a queue, not a deque.\n\t// It is split into two stages - head[headPos:] and tail.\n\t// popFront is trivial (headPos++) on the first stage, and\n\t// pushBack is trivial (append) on the second stage.\n\t// If the first stage is empty, popFront can swap the\n\t// first and second stages to remedy the situation.\n\t//\n\t// This two-stage split is analogous to the use of two lists\n\t// in Okasaki's purely functional queue but without the\n\t// overhead of reversing the list when swapping stages.\n\thead    []*wantConn\n\theadPos int\n\ttail    []*wantConn\n}\n\n// len returns the number of items in the queue.\nfunc (q *wantConnQueue) len() int {\n\treturn len(q.head) - q.headPos + len(q.tail)\n}\n\n// pushBack adds w to the back of the queue.\nfunc (q *wantConnQueue) pushBack(w *wantConn) {\n\tq.tail = append(q.tail, w)\n}\n\n// popFront removes and returns the wantConn at the front of the queue.\nfunc (q *wantConnQueue) popFront() *wantConn {\n\tif q.headPos >= len(q.head) {\n\t\tif len(q.tail) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\t// Pick up tail as new head, clear tail.\n\t\tq.head, q.headPos, q.tail = q.tail, 0, q.head[:0]\n\t}\n\tw := q.head[q.headPos]\n\tq.head[q.headPos] = nil\n\tq.headPos++\n\treturn w\n}\n\n// peekFront returns the wantConn at the front of the queue without removing it.\nfunc (q *wantConnQueue) peekFront() *wantConn {\n\tif q.headPos < len(q.head) {\n\t\treturn q.head[q.headPos]\n\t}\n\tif len(q.tail) > 0 {\n\t\treturn q.tail[0]\n\t}\n\treturn nil\n}\n\n// cleanFrontNotWaiting pops any wantConns that are no longer waiting from the head of the\n// queue, reporting whether any were popped.\nfunc (q *wantConnQueue) cleanFrontNotWaiting() (cleaned bool) {\n\tfor {\n\t\tw := q.peekFront()\n\t\tif w == nil || w.waiting() {\n\t\t\treturn cleaned\n\t\t}\n\t\tq.popFront()\n\t\tcleaned = true\n\t}\n}\n\n// cleanFrontCanceled pops any wantConns with canceled dials from the head of the queue.\nfunc (q *wantConnQueue) cleanFrontCanceled() {\n\tfor {\n\t\tw := q.peekFront()\n\t\tif w == nil || w.cancelCtx != nil {\n\t\t\treturn\n\t\t}\n\t\tq.popFront()\n\t}\n}\n\n// all iterates over all wantConns in the queue.\n// The caller must not modify the queue while iterating.\nfunc (q *wantConnQueue) all(f func(*wantConn)) {\n\tfor _, w := range q.head[q.headPos:] {\n\t\tf(w)\n\t}\n\tfor _, w := range q.tail {\n\t\tf(w)\n\t}\n}\n\nfunc (t *Transport) customDialTLS(ctx context.Context, network, addr string) (conn net.Conn, err error) {\n\tconn, err = t.DialTLSContext(ctx, network, addr)\n\n\tif conn == nil && err == nil {\n\t\terr = errors.New(\"net/http: Transport.DialTLS or DialTLSContext returned (nil, nil)\")\n\t}\n\treturn\n}\n\n// getConn dials and creates a new persistConn to the target as\n// specified in the connectMethod. This includes doing a proxy CONNECT\n// and/or setting up TLS.  If this doesn't return an error, the persistConn\n// is ready to write requests to.\nfunc (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error) {\n\treq := treq.Request\n\ttrace := treq.trace\n\tctx := req.Context()\n\tif trace != nil && trace.GetConn != nil {\n\t\ttrace.GetConn(cm.addr())\n\t}\n\n\t// Detach from the request context's cancellation signal.\n\t// The dial should proceed even if the request is canceled,\n\t// because a future request may be able to make use of the connection.\n\t//\n\t// We retain the request context's values.\n\tdialCtx, dialCancel := context.WithCancel(context.WithoutCancel(ctx))\n\n\tw := &wantConn{\n\t\tcm:         cm,\n\t\tkey:        cm.key(),\n\t\tctx:        dialCtx,\n\t\tcancelCtx:  dialCancel,\n\t\tresult:     make(chan connOrError, 1),\n\t\tbeforeDial: testHookPrePendingDial,\n\t\tafterDial:  testHookPostPendingDial,\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tw.cancel(t, err)\n\t\t}\n\t}()\n\n\t// Queue for idle connection.\n\tif delivered := t.queueForIdleConn(w); !delivered {\n\t\tt.queueForDial(w)\n\t}\n\n\t// Wait for completion or cancellation.\n\tselect {\n\tcase r := <-w.result:\n\t\t// Trace success but only for HTTP/1.\n\t\t// HTTP/2 calls trace.GotConn itself.\n\t\tif r.pc != nil && r.pc.alt == nil && trace != nil && trace.GotConn != nil {\n\t\t\tinfo := httptrace.GotConnInfo{\n\t\t\t\tConn:   r.pc.conn,\n\t\t\t\tReused: r.pc.isReused(),\n\t\t\t}\n\t\t\tif !r.idleAt.IsZero() {\n\t\t\t\tinfo.WasIdle = true\n\t\t\t\tinfo.IdleTime = time.Since(r.idleAt)\n\t\t\t}\n\t\t\ttrace.GotConn(info)\n\t\t}\n\t\tif r.err != nil {\n\t\t\t// If the request has been canceled, that's probably\n\t\t\t// what caused r.err; if so, prefer to return the\n\t\t\t// cancellation error (see golang.org/issue/16049).\n\t\t\tselect {\n\t\t\tcase <-treq.ctx.Done():\n\t\t\t\terr := context.Cause(treq.ctx)\n\t\t\t\tif err == common.ErrRequestCanceled {\n\t\t\t\t\terr = errRequestCanceledConn\n\t\t\t\t}\n\t\t\t\treturn nil, err\n\t\t\tdefault:\n\t\t\t\t// return below\n\t\t\t}\n\t\t}\n\t\treturn r.pc, r.err\n\tcase <-treq.ctx.Done():\n\t\terr := context.Cause(treq.ctx)\n\t\tif err == common.ErrRequestCanceled {\n\t\t\terr = errRequestCanceledConn\n\t\t}\n\t\treturn nil, err\n\t}\n}\n\n// queueForDial queues w to wait for permission to begin dialing.\n// Once w receives permission to dial, it will do so in a separate goroutine.\nfunc (t *Transport) queueForDial(w *wantConn) {\n\tw.beforeDial()\n\n\tt.connsPerHostMu.Lock()\n\tdefer t.connsPerHostMu.Unlock()\n\n\tif t.MaxConnsPerHost <= 0 {\n\t\tt.startDialConnForLocked(w)\n\t\treturn\n\t}\n\n\tif n := t.connsPerHost[w.key]; n < t.MaxConnsPerHost {\n\t\tif t.connsPerHost == nil {\n\t\t\tt.connsPerHost = make(map[connectMethodKey]int)\n\t\t}\n\t\tt.connsPerHost[w.key] = n + 1\n\t\tt.startDialConnForLocked(w)\n\t\treturn\n\t}\n\n\tif t.connsPerHostWait == nil {\n\t\tt.connsPerHostWait = make(map[connectMethodKey]wantConnQueue)\n\t}\n\tq := t.connsPerHostWait[w.key]\n\tq.cleanFrontNotWaiting()\n\tq.pushBack(w)\n\tt.connsPerHostWait[w.key] = q\n}\n\n// startDialConnFor calls dialConn in a new goroutine.\n// t.connsPerHostMu must be held.\nfunc (t *Transport) startDialConnForLocked(w *wantConn) {\n\tt.dialsInProgress.cleanFrontCanceled()\n\tt.dialsInProgress.pushBack(w)\n\tgo func() {\n\t\tt.dialConnFor(w)\n\t\tt.connsPerHostMu.Lock()\n\t\tdefer t.connsPerHostMu.Unlock()\n\t\tw.cancelCtx = nil\n\t}()\n}\n\n// dialConnFor dials on behalf of w and delivers the result to w.\n// dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()].\n// If the dial is canceled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()].\nfunc (t *Transport) dialConnFor(w *wantConn) {\n\tdefer w.afterDial()\n\tctx := w.getCtxForDial()\n\tif ctx == nil {\n\t\tt.decConnsPerHost(w.key)\n\t\treturn\n\t}\n\n\tpc, err := t.dialConn(ctx, w.cm)\n\tdelivered := w.tryDeliver(pc, err, time.Time{})\n\tif err == nil && (!delivered || pc.alt != nil) {\n\t\t// pconn was not passed to w,\n\t\t// or it is HTTP/2 and can be shared.\n\t\t// Add to the idle connection pool.\n\t\tt.putOrCloseIdleConn(pc)\n\t}\n\tif err != nil {\n\t\tt.decConnsPerHost(w.key)\n\t}\n}\n\n// decConnsPerHost decrements the per-host connection count for key,\n// which may in turn give a different waiting goroutine permission to dial.\nfunc (t *Transport) decConnsPerHost(key connectMethodKey) {\n\tif t.MaxConnsPerHost <= 0 {\n\t\treturn\n\t}\n\n\tt.connsPerHostMu.Lock()\n\tdefer t.connsPerHostMu.Unlock()\n\tn := t.connsPerHost[key]\n\tif n == 0 {\n\t\t// Shouldn't happen, but if it does, the counting is buggy and could\n\t\t// easily lead to a silent deadlock, so report the problem loudly.\n\t\tpanic(\"net/http: internal error: connCount underflow\")\n\t}\n\n\t// Can we hand this count to a goroutine still waiting to dial?\n\t// (Some goroutines on the wait list may have timed out or\n\t// gotten a connection another way. If they're all gone,\n\t// we don't want to kick off any spurious dial operations.)\n\tif q := t.connsPerHostWait[key]; q.len() > 0 {\n\t\tdone := false\n\t\tfor q.len() > 0 {\n\t\t\tw := q.popFront()\n\t\t\tif w.waiting() {\n\t\t\t\tt.startDialConnForLocked(w)\n\t\t\t\tdone = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif q.len() == 0 {\n\t\t\tdelete(t.connsPerHostWait, key)\n\t\t} else {\n\t\t\t// q is a value (like a slice), so we have to store\n\t\t\t// the updated q back into the map.\n\t\t\tt.connsPerHostWait[key] = q\n\t\t}\n\t\tif done {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Otherwise, decrement the recorded count.\n\tif n--; n == 0 {\n\t\tdelete(t.connsPerHost, key)\n\t} else {\n\t\tt.connsPerHost[key] = n\n\t}\n}\n\n// Add TLS to a persistent connection, i.e. negotiate a TLS session. If pconn is already a TLS\n// tunnel, this function establishes a nested TLS session inside the encrypted channel.\n// The remote endpoint's name may be overridden by TLSClientConfig.ServerName.\nfunc (pc *persistConn) addTLS(ctx context.Context, name string, trace *httptrace.ClientTrace, forProxy bool) error {\n\t// Initiate TLS and check remote host name against certificate.\n\tcfg := cloneTLSConfig(pc.t.TLSClientConfig)\n\tif cfg.ServerName == \"\" {\n\t\tcfg.ServerName = name\n\t}\n\tif pc.cacheKey.onlyH1 {\n\t\tcfg.NextProtos = nil\n\t}\n\tplainConn := pc.conn\n\ttlsConn := tls.Client(plainConn, cfg)\n\terrc := make(chan error, 2)\n\tvar timer *time.Timer // for canceling TLS handshake\n\tif d := pc.t.TLSHandshakeTimeout; d != 0 {\n\t\ttimer = time.AfterFunc(d, func() {\n\t\t\terrc <- tlsHandshakeTimeoutError{}\n\t\t})\n\t}\n\tgo func() {\n\t\tif trace != nil && trace.TLSHandshakeStart != nil {\n\t\t\ttrace.TLSHandshakeStart()\n\t\t}\n\t\terr := tlsConn.HandshakeContext(ctx)\n\t\tif timer != nil {\n\t\t\ttimer.Stop()\n\t\t}\n\t\terrc <- err\n\t}()\n\tif err := <-errc; err != nil {\n\t\tplainConn.Close()\n\t\tif err == (tlsHandshakeTimeoutError{}) {\n\t\t\t// Now that we have closed the connection,\n\t\t\t// wait for the call to HandshakeContext to return.\n\t\t\t<-errc\n\t\t}\n\t\tif trace != nil && trace.TLSHandshakeDone != nil {\n\t\t\ttrace.TLSHandshakeDone(tls.ConnectionState{}, err)\n\t\t}\n\t\treturn err\n\t}\n\tcs := tlsConn.ConnectionState()\n\tif trace != nil && trace.TLSHandshakeDone != nil {\n\t\ttrace.TLSHandshakeDone(cs, nil)\n\t}\n\tpc.tlsState = &cs\n\tpc.conn = tlsConn\n\tif !forProxy && pc.t.forceHttpVersion == h2 && cs.NegotiatedProtocol != h2internal.NextProtoTLS {\n\t\treturn newHttp2NotSupportedError(cs.NegotiatedProtocol)\n\t}\n\treturn nil\n}\n\nfunc newHttp2NotSupportedError(negotiatedProtocol string) error {\n\terrMsg := \"server does not support http2\"\n\tif negotiatedProtocol != \"\" {\n\t\terrMsg += fmt.Sprintf(\", you can use %s which is supported\", negotiatedProtocol)\n\t}\n\treturn errors.New(errMsg)\n}\n\nfunc (t *Transport) customTlsHandshake(ctx context.Context, trace *httptrace.ClientTrace, addr string, pconn *persistConn) error {\n\terrc := make(chan error, 2)\n\tvar timer *time.Timer // for canceling TLS handshake\n\tif d := t.TLSHandshakeTimeout; d != 0 {\n\t\ttimer = time.AfterFunc(d, func() {\n\t\t\terrc <- tlsHandshakeTimeoutError{}\n\t\t})\n\t}\n\tgo func() {\n\t\tif trace != nil && trace.TLSHandshakeStart != nil {\n\t\t\ttrace.TLSHandshakeStart()\n\t\t}\n\t\tconn, tlsState, err := t.TLSHandshakeContext(ctx, addr, pconn.conn)\n\t\tif err != nil {\n\t\t\tif timer != nil {\n\t\t\t\ttimer.Stop()\n\t\t\t}\n\t\t\tif trace != nil && trace.TLSHandshakeDone != nil {\n\t\t\t\ttrace.TLSHandshakeDone(tls.ConnectionState{}, err)\n\t\t\t}\n\t\t} else {\n\t\t\tpconn.conn = conn\n\t\t\tpconn.tlsState = tlsState\n\t\t\tif trace != nil && trace.TLSHandshakeDone != nil {\n\t\t\t\ttrace.TLSHandshakeDone(*tlsState, nil)\n\t\t\t}\n\t\t}\n\t\terrc <- err\n\t}()\n\tif err := <-errc; err != nil {\n\t\tpconn.conn.Close()\n\t\treturn err\n\t}\n\treturn nil\n}\n\nvar testHookProxyConnectTimeout = context.WithTimeout\n\nfunc (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error) {\n\tpconn = &persistConn{\n\t\tt:             t,\n\t\tcacheKey:      cm.key(),\n\t\treqch:         make(chan requestAndChan, 1),\n\t\twritech:       make(chan writeRequest, 1),\n\t\tclosech:       make(chan struct{}),\n\t\twriteErrCh:    make(chan error, 1),\n\t\twriteLoopDone: make(chan struct{}),\n\t}\n\ttrace := httptrace.ContextClientTrace(ctx)\n\twrapErr := func(err error) error {\n\t\tif cm.proxyURL != nil {\n\t\t\t// Return a typed error, per Issue 16997\n\t\t\treturn &net.OpError{Op: \"proxyconnect\", Net: \"tcp\", Err: err}\n\t\t}\n\t\treturn err\n\t}\n\tif cm.scheme() == \"https\" && t.hasCustomTLSDialer() {\n\t\tvar err error\n\t\tpconn.conn, err = t.customDialTLS(ctx, \"tcp\", cm.addr())\n\t\tif err != nil {\n\t\t\treturn nil, wrapErr(err)\n\t\t}\n\t\tif tc, ok := pconn.conn.(reqtls.Conn); ok {\n\t\t\t// Handshake here, in case DialTLS didn't. TLSNextProto below\n\t\t\t// depends on it for knowing the connection state.\n\t\t\tif trace != nil && trace.TLSHandshakeStart != nil {\n\t\t\t\ttrace.TLSHandshakeStart()\n\t\t\t}\n\t\t\tif err := tc.HandshakeContext(ctx); err != nil {\n\t\t\t\tgo pconn.conn.Close()\n\t\t\t\tif trace != nil && trace.TLSHandshakeDone != nil {\n\t\t\t\t\ttrace.TLSHandshakeDone(tls.ConnectionState{}, err)\n\t\t\t\t}\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcs := tc.ConnectionState()\n\t\t\tif trace != nil && trace.TLSHandshakeDone != nil {\n\t\t\t\ttrace.TLSHandshakeDone(cs, nil)\n\t\t\t}\n\t\t\tpconn.tlsState = &cs\n\t\t\tif cm.proxyURL == nil && pconn.t.forceHttpVersion == h2 && cs.NegotiatedProtocol != h2internal.NextProtoTLS {\n\t\t\t\treturn nil, newHttp2NotSupportedError(cs.NegotiatedProtocol)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconn, err := t.dial(ctx, \"tcp\", cm.addr())\n\t\tif err != nil {\n\t\t\treturn nil, wrapErr(err)\n\t\t}\n\t\tpconn.conn = conn\n\t\tif cm.scheme() == \"https\" {\n\t\t\tvar firstTLSHost string\n\t\t\tif firstTLSHost, _, err = net.SplitHostPort(cm.addr()); err != nil {\n\t\t\t\treturn nil, wrapErr(err)\n\t\t\t}\n\t\t\tif t.TLSHandshakeContext != nil && cm.proxyURL == nil {\n\t\t\t\terr = t.customTlsHandshake(ctx, trace, firstTLSHost, pconn)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err = pconn.addTLS(ctx, firstTLSHost, trace, cm.proxyURL != nil); err != nil {\n\t\t\t\t\treturn nil, wrapErr(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif t.Debugf != nil && cm.proxyURL != nil {\n\t\tt.Debugf(\"connect %s via proxy %s\", cm.targetAddr, cm.proxyURL.String())\n\t}\n\n\t// Proxy setup.\n\tswitch {\n\tcase cm.proxyURL == nil:\n\t\t// Do nothing. Not using a proxy.\n\tcase cm.proxyURL.Scheme == \"socks5\" || cm.proxyURL.Scheme == \"socks5h\":\n\t\tconn := pconn.conn\n\t\td := socks.NewDialer(\"tcp\", conn.RemoteAddr().String())\n\t\tif u := cm.proxyURL.User; u != nil {\n\t\t\tauth := &socks.UsernamePassword{\n\t\t\t\tUsername: u.Username(),\n\t\t\t}\n\t\t\tauth.Password, _ = u.Password()\n\t\t\td.AuthMethods = []socks.AuthMethod{\n\t\t\t\tsocks.AuthMethodNotRequired,\n\t\t\t\tsocks.AuthMethodUsernamePassword,\n\t\t\t}\n\t\t\td.Authenticate = auth.Authenticate\n\t\t}\n\t\tif _, err := d.DialWithConn(ctx, conn, \"tcp\", cm.targetAddr); err != nil {\n\t\t\tconn.Close()\n\t\t\treturn nil, err\n\t\t}\n\tcase cm.targetScheme == \"http\":\n\t\tpconn.isProxy = true\n\t\tif pa := cm.proxyAuth(); pa != \"\" {\n\t\t\tpconn.mutateHeaderFunc = func(h http.Header) {\n\t\t\t\th.Set(\"Proxy-Authorization\", pa)\n\t\t\t}\n\t\t}\n\tcase cm.targetScheme == \"https\":\n\t\tconn := pconn.conn\n\t\tvar hdr http.Header\n\t\tif t.GetProxyConnectHeader != nil {\n\t\t\tvar err error\n\t\t\thdr, err = t.GetProxyConnectHeader(ctx, cm.proxyURL, cm.targetAddr)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\thdr = t.ProxyConnectHeader\n\t\t}\n\t\tif hdr == nil {\n\t\t\thdr = make(http.Header)\n\t\t}\n\t\tif pa := cm.proxyAuth(); pa != \"\" {\n\t\t\thdr = hdr.Clone()\n\t\t\thdr.Set(\"Proxy-Authorization\", pa)\n\t\t}\n\t\tconnectReq := &http.Request{\n\t\t\tMethod: \"CONNECT\",\n\t\t\tURL:    &url.URL{Opaque: cm.targetAddr},\n\t\t\tHost:   cm.targetAddr,\n\t\t\tHeader: hdr,\n\t\t}\n\n\t\t// Set a (long) timeout here to make sure we don't block forever\n\t\t// and leak a goroutine if the connection stops replying after\n\t\t// the TCP connect.\n\t\tconnectCtx, cancel := testHookProxyConnectTimeout(ctx, 1*time.Minute)\n\t\tdefer cancel()\n\n\t\tdidReadResponse := make(chan struct{}) // closed after CONNECT write+read is done or fails\n\t\tvar (\n\t\t\tresp *http.Response\n\t\t\terr  error // write or read error\n\t\t)\n\t\t// Write the CONNECT request & read the response.\n\t\tgo func() {\n\t\t\tdefer close(didReadResponse)\n\t\t\terr = connectReq.Write(conn)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Okay to use and discard buffered reader here, because\n\t\t\t// TLS server will not speak until spoken to.\n\t\t\tbr := bufio.NewReader(conn)\n\t\t\tresp, err = http.ReadResponse(br, connectReq)\n\t\t}()\n\t\tselect {\n\t\tcase <-connectCtx.Done():\n\t\t\tconn.Close()\n\t\t\t<-didReadResponse\n\t\t\treturn nil, connectCtx.Err()\n\t\tcase <-didReadResponse:\n\t\t\t// resp or err now set\n\t\t}\n\t\tif err != nil {\n\t\t\tconn.Close()\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif t.OnProxyConnectResponse != nil {\n\t\t\terr = t.OnProxyConnectResponse(ctx, cm.proxyURL, connectReq, resp)\n\t\t\tif err != nil {\n\t\t\t\tconn.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif resp.StatusCode != 200 {\n\t\t\t_, text, ok := util.CutString(resp.Status, \" \")\n\t\t\tconn.Close()\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.New(\"unknown status code\")\n\t\t\t}\n\t\t\treturn nil, errors.New(text)\n\t\t}\n\t}\n\n\tif cm.proxyURL != nil && cm.targetScheme == \"https\" {\n\t\tif t.TLSHandshakeContext != nil {\n\t\t\terr := t.customTlsHandshake(ctx, trace, cm.tlsHost(), pconn)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := pconn.addTLS(ctx, cm.tlsHost(), trace, false); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif s := pconn.tlsState; t.forceHttpVersion != h1 && s != nil && s.NegotiatedProtocolIsMutual && s.NegotiatedProtocol != \"\" {\n\t\tif s.NegotiatedProtocol == h2internal.NextProtoTLS {\n\t\t\tif used, err := t.t2.AddConn(pconn.conn, cm.targetAddr); err != nil {\n\t\t\t\tgo pconn.conn.Close()\n\t\t\t\treturn nil, err\n\t\t\t} else if !used {\n\t\t\t\tgo pconn.conn.Close()\n\t\t\t}\n\t\t\treturn &persistConn{t: t, cacheKey: pconn.cacheKey, alt: t.t2}, nil\n\t\t}\n\t}\n\n\tpconn.br = bufio.NewReaderSize(pconn, t.readBufferSize())\n\tpconn.bw = bufio.NewWriterSize(persistConnWriter{pconn}, t.writeBufferSize())\n\n\tgo pconn.readLoop()\n\tgo pconn.writeLoop()\n\treturn pconn, nil\n}\n\n// persistConnWriter is the io.Writer written to by pc.bw.\n// It accumulates the number of bytes written to the underlying conn,\n// so the retry logic can determine whether any bytes made it across\n// the wire.\n// This is exactly 1 pointer field wide so it can go into an interface\n// without allocation.\ntype persistConnWriter struct {\n\tpc *persistConn\n}\n\nfunc (w persistConnWriter) Write(p []byte) (n int, err error) {\n\tn, err = w.pc.conn.Write(p)\n\tw.pc.nwrite += int64(n)\n\treturn\n}\n\n// ReadFrom exposes persistConnWriter's underlying Conn to io.Copy and if\n// the Conn implements io.ReaderFrom, it can take advantage of optimizations\n// such as sendfile.\nfunc (w persistConnWriter) ReadFrom(r io.Reader) (n int64, err error) {\n\tn, err = io.Copy(w.pc.conn, r)\n\tw.pc.nwrite += n\n\treturn\n}\n\nvar _ io.ReaderFrom = (*persistConnWriter)(nil)\n\n// connectMethod is the map key (in its String form) for keeping persistent\n// TCP connections alive for subsequent HTTP requests.\n//\n// A connect method may be of the following types:\n//\n//\tconnectMethod.key().String()      Description\n//\t------------------------------    -------------------------\n//\t|http|foo.com                     http directly to server, no proxy\n//\t|https|foo.com                    https directly to server, no proxy\n//\t|https,h1|foo.com                 https directly to server w/o HTTP/2, no proxy\n//\thttp://proxy.com|https|foo.com    http to proxy, then CONNECT to foo.com\n//\thttp://proxy.com|http             http to proxy, http to anywhere after that\n//\tsocks5://proxy.com|http|foo.com   socks5 to proxy, then http to foo.com\n//\tsocks5://proxy.com|https|foo.com  socks5 to proxy, then https to foo.com\n//\thttps://proxy.com|https|foo.com   https to proxy, then CONNECT to foo.com\n//\thttps://proxy.com|http            https to proxy, http to anywhere after that\ntype connectMethod struct {\n\t_            incomparable\n\tproxyURL     *url.URL // nil for no proxy, else full proxy URL\n\ttargetScheme string   // \"http\" or \"https\"\n\t// If proxyURL specifies an http or https proxy, and targetScheme is http (not https),\n\t// then targetAddr is not included in the connect method key, because the socket can\n\t// be reused for different targetAddr values.\n\ttargetAddr string\n\tonlyH1     bool // whether to disable HTTP/2 and force HTTP/1\n}\n\nfunc (cm *connectMethod) key() connectMethodKey {\n\tproxyStr := \"\"\n\ttargetAddr := cm.targetAddr\n\tif cm.proxyURL != nil {\n\t\tproxyStr = cm.proxyURL.String()\n\t\tif (cm.proxyURL.Scheme == \"http\" || cm.proxyURL.Scheme == \"https\") && cm.targetScheme == \"http\" {\n\t\t\ttargetAddr = \"\"\n\t\t}\n\t}\n\treturn connectMethodKey{\n\t\tproxy:  proxyStr,\n\t\tscheme: cm.targetScheme,\n\t\taddr:   targetAddr,\n\t\tonlyH1: cm.onlyH1,\n\t}\n}\n\n// scheme returns the first hop scheme: http, https, or socks5\nfunc (cm *connectMethod) scheme() string {\n\tif cm.proxyURL != nil {\n\t\treturn cm.proxyURL.Scheme\n\t}\n\treturn cm.targetScheme\n}\n\n// addr returns the first hop \"host:port\" to which we need to TCP connect.\nfunc (cm *connectMethod) addr() string {\n\tif cm.proxyURL != nil {\n\t\treturn canonicalAddr(cm.proxyURL)\n\t}\n\treturn cm.targetAddr\n}\n\n// tlsHost returns the host name to match against the peer's\n// TLS certificate.\nfunc (cm *connectMethod) tlsHost() string {\n\th := cm.targetAddr\n\tif hasPort(h) {\n\t\th = h[:strings.LastIndex(h, \":\")]\n\t}\n\treturn h\n}\n\n// connectMethodKey is the map key version of connectMethod, with a\n// stringified proxy URL (or the empty string) instead of a pointer to\n// a URL.\ntype connectMethodKey struct {\n\tproxy, scheme, addr string\n\tonlyH1              bool\n}\n\nfunc (k connectMethodKey) String() string {\n\t// Only used by tests.\n\tvar h1 string\n\tif k.onlyH1 {\n\t\th1 = \",h1\"\n\t}\n\treturn fmt.Sprintf(\"%s|%s%s|%s\", k.proxy, k.scheme, h1, k.addr)\n}\n\n// persistConn wraps a connection, usually a persistent one\n// (but may be used for non-keep-alive requests as well)\ntype persistConn struct {\n\t// alt optionally specifies the TLS NextProto http.RoundTripper.\n\t// This is used for HTTP/2 today and future protocols later.\n\t// If it's non-nil, the rest of the fields are unused.\n\talt http.RoundTripper\n\n\tt         *Transport\n\tcacheKey  connectMethodKey\n\tconn      net.Conn\n\ttlsState  *tls.ConnectionState\n\tbr        *bufio.Reader       // from conn\n\tbw        *bufio.Writer       // to conn\n\tnwrite    int64               // bytes written\n\treqch     chan requestAndChan // written by roundTrip; read by readLoop\n\twritech   chan writeRequest   // written by roundTrip; read by writeLoop\n\tclosech   chan struct{}       // closed when conn closed\n\tisProxy   bool\n\tsawEOF    bool  // whether we've seen EOF from conn; owned by readLoop\n\treadLimit int64 // bytes allowed to be read; owned by readLoop\n\t// writeErrCh passes the request write error (usually nil)\n\t// from the writeLoop goroutine to the readLoop which passes\n\t// it off to the res.Body reader, which then uses it to decide\n\t// whether or not a connection can be reused. Issue 7569.\n\twriteErrCh chan error\n\n\twriteLoopDone chan struct{} // closed when write loop ends\n\n\t// Both guarded by Transport.idleMu:\n\tidleAt    time.Time   // time it last become idle\n\tidleTimer *time.Timer // holding an AfterFunc to close it\n\n\tmu                   sync.Mutex // guards following fields\n\tnumExpectedResponses int\n\tclosed               error // set non-nil when conn is closed, before closech is closed\n\tcanceledErr          error // set non-nil if conn is canceled\n\tbroken               bool  // an error has happened on this connection; marked broken so it's not reused.\n\treused               bool  // whether conn has had successful request/response and is being reused.\n\t// mutateHeaderFunc is an optional func to modify extra\n\t// headers on each outbound request before it's written. (the\n\t// original Request given to RoundTrip is not modified)\n\tmutateHeaderFunc func(http.Header)\n}\n\n// RFC 7234, section 5.4: Should treat\n//\n//\tPragma: no-cache\n//\n// like\n//\n//\tCache-Control: no-cache\nfunc fixPragmaCacheControl(header http.Header) {\n\tif hp, ok := header[\"Pragma\"]; ok && len(hp) > 0 && hp[0] == \"no-cache\" {\n\t\tif _, presentcc := header[\"Cache-Control\"]; !presentcc {\n\t\t\theader[\"Cache-Control\"] = []string{\"no-cache\"}\n\t\t}\n\t}\n}\n\n// readResponse reads an HTTP response (or two, in the case of \"Expect:\n// 100-continue\") from the server. It returns the final non-100 one.\n// trace is optional.\nfunc (pc *persistConn) _readResponse(req *http.Request) (*http.Response, error) {\n\tds := dump.GetResponseHeaderDumpers(req.Context(), pc.t.Dump)\n\ttp := newTextprotoReader(pc.br, ds)\n\tresp := &http.Response{\n\t\tRequest: req,\n\t}\n\n\t// Parse the first line of the response.\n\tline, err := tp.ReadLine()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t}\n\t\treturn nil, err\n\t}\n\tproto, status, ok := util.CutString(line, \" \")\n\tif !ok {\n\t\treturn nil, badStringError(\"malformed HTTP response\", line)\n\t}\n\tresp.Proto = proto\n\tresp.Status = strings.TrimLeft(status, \" \")\n\n\tstatusCode, _, _ := util.CutString(resp.Status, \" \")\n\tif len(statusCode) != 3 {\n\t\treturn nil, badStringError(\"malformed HTTP status code\", statusCode)\n\t}\n\tresp.StatusCode, err = strconv.Atoi(statusCode)\n\tif err != nil || resp.StatusCode < 0 {\n\t\treturn nil, badStringError(\"malformed HTTP status code\", statusCode)\n\t}\n\tif resp.ProtoMajor, resp.ProtoMinor, ok = http.ParseHTTPVersion(resp.Proto); !ok {\n\t\treturn nil, badStringError(\"malformed HTTP version\", resp.Proto)\n\t}\n\n\t// Parse the response headers.\n\tmimeHeader, err := tp.ReadMIMEHeader()\n\tif err != nil {\n\t\tif err == io.EOF {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t}\n\t\treturn nil, err\n\t}\n\tresp.Header = http.Header(mimeHeader)\n\n\tfixPragmaCacheControl(resp.Header)\n\n\terr = readTransfer(resp, pc.br)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn resp, nil\n}\n\nfunc (pc *persistConn) maxHeaderResponseSize() int64 {\n\tif v := pc.t.MaxResponseHeaderBytes; v != 0 {\n\t\treturn v\n\t}\n\treturn 10 << 20 // conservative default; same as http2\n}\n\nfunc (pc *persistConn) Read(p []byte) (n int, err error) {\n\tif pc.readLimit <= 0 {\n\t\treturn 0, fmt.Errorf(\"read limit of %d bytes exhausted\", pc.maxHeaderResponseSize())\n\t}\n\tif int64(len(p)) > pc.readLimit {\n\t\tp = p[:pc.readLimit]\n\t}\n\tn, err = pc.conn.Read(p)\n\tif err == io.EOF {\n\t\tpc.sawEOF = true\n\t}\n\tpc.readLimit -= int64(n)\n\treturn\n}\n\n// isBroken reports whether this connection is in a known broken state.\nfunc (pc *persistConn) isBroken() bool {\n\tpc.mu.Lock()\n\tb := pc.closed != nil\n\tpc.mu.Unlock()\n\treturn b\n}\n\n// canceled returns non-nil if the connection was closed due to\n// CancelRequest or due to context cancellation.\nfunc (pc *persistConn) canceled() error {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\treturn pc.canceledErr\n}\n\n// isReused reports whether this connection has been used before.\nfunc (pc *persistConn) isReused() bool {\n\tpc.mu.Lock()\n\tr := pc.reused\n\tpc.mu.Unlock()\n\treturn r\n}\n\nfunc (pc *persistConn) cancelRequest(err error) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tpc.canceledErr = err\n\tpc.closeLocked(common.ErrRequestCanceled)\n}\n\n// closeConnIfStillIdle closes the connection if it's still sitting idle.\n// This is what's called by the persistConn's idleTimer, and is run in its\n// own goroutine.\nfunc (pc *persistConn) closeConnIfStillIdle() {\n\tt := pc.t\n\tt.idleMu.Lock()\n\tdefer t.idleMu.Unlock()\n\tif _, ok := t.idleLRU.m[pc]; !ok {\n\t\t// Not idle.\n\t\treturn\n\t}\n\tt.removeIdleConnLocked(pc)\n\tpc.close(errIdleConnTimeout)\n}\n\n// mapRoundTripError returns the appropriate error value for\n// persistConn.roundTrip.\n//\n// The provided err is the first error that (*persistConn).roundTrip\n// happened to receive from its select statement.\n//\n// The startBytesWritten value should be the value of pc.nwrite before the roundTrip\n// started writing the request.\nfunc (pc *persistConn) mapRoundTripError(req *transportRequest, startBytesWritten int64, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// Wait for the writeLoop goroutine to terminate to avoid data\n\t// races on callers who mutate the request on failure.\n\t//\n\t// When resc in pc.roundTrip and hence rc.ch receives a responseAndError\n\t// with a non-nil error it implies that the persistConn is either closed\n\t// or closing. Waiting on pc.writeLoopDone is hence safe as all callers\n\t// close closech which in turn ensures writeLoop returns.\n\t<-pc.writeLoopDone\n\n\t// If the request was canceled, that's better than network\n\t// failures that were likely the result of tearing down the\n\t// connection.\n\tif cerr := pc.canceled(); cerr != nil {\n\t\treturn cerr\n\t}\n\n\t// See if an error was set explicitly.\n\treq.mu.Lock()\n\treqErr := req.err\n\treq.mu.Unlock()\n\tif reqErr != nil {\n\t\treturn reqErr\n\t}\n\n\tif err == errServerClosedIdle {\n\t\t// Don't decorate\n\t\treturn err\n\t}\n\n\tif _, ok := err.(transportReadFromServerError); ok {\n\t\tif pc.nwrite == startBytesWritten {\n\t\t\treturn nothingWrittenError{err}\n\t\t}\n\t\t// Don't decorate\n\t\treturn err\n\t}\n\tif pc.isBroken() {\n\t\tif pc.nwrite == startBytesWritten {\n\t\t\treturn nothingWrittenError{err}\n\t\t}\n\t\treturn fmt.Errorf(\"net/http: HTTP/1.x transport connection broken: %w\", err)\n\t}\n\treturn err\n}\n\n// errCallerOwnsConn is an internal sentinel error used when we hand\n// off a writable response.Body to the caller. We use this to prevent\n// closing a net.Conn that is now owned by the caller.\nvar errCallerOwnsConn = errors.New(\"read loop ending; caller owns writable underlying conn\")\n\nfunc (pc *persistConn) readLoop() {\n\tcloseErr := errReadLoopExiting // default value, if not changed below\n\tdefer func() {\n\t\tpc.close(closeErr)\n\t\tpc.t.removeIdleConn(pc)\n\t}()\n\n\ttryPutIdleConn := func(treq *transportRequest) bool {\n\t\ttrace := treq.trace\n\t\tif err := pc.t.tryPutIdleConn(pc); err != nil {\n\t\t\tcloseErr = err\n\t\t\tif trace != nil && trace.PutIdleConn != nil && err != errKeepAlivesDisabled {\n\t\t\t\ttrace.PutIdleConn(err)\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\tif trace != nil && trace.PutIdleConn != nil {\n\t\t\ttrace.PutIdleConn(nil)\n\t\t}\n\t\treturn true\n\t}\n\n\t// eofc is used to block caller goroutines reading from Response.Body\n\t// at EOF until this goroutines has (potentially) added the connection\n\t// back to the idle pool.\n\teofc := make(chan struct{})\n\tdefer close(eofc) // unblock reader on errors\n\n\t// Read this once, before loop starts. (to avoid races in tests)\n\ttestHookMu.Lock()\n\ttestHookReadLoopBeforeNextRead := testHookReadLoopBeforeNextRead\n\ttestHookMu.Unlock()\n\n\talive := true\n\tfor alive {\n\t\tpc.readLimit = pc.maxHeaderResponseSize()\n\t\t_, err := pc.br.Peek(1)\n\n\t\tpc.mu.Lock()\n\t\tif pc.numExpectedResponses == 0 {\n\t\t\tpc.readLoopPeekFailLocked(err)\n\t\t\tpc.mu.Unlock()\n\t\t\treturn\n\t\t}\n\t\tpc.mu.Unlock()\n\n\t\trc := <-pc.reqch\n\t\ttrace := rc.treq.trace\n\n\t\tvar resp *http.Response\n\t\tif err == nil {\n\t\t\tresp, err = pc.readResponse(rc, trace)\n\t\t} else {\n\t\t\terr = transportReadFromServerError{err}\n\t\t\tcloseErr = err\n\t\t}\n\n\t\tif err != nil {\n\t\t\tif pc.readLimit <= 0 {\n\t\t\t\terr = fmt.Errorf(\"net/http: server response headers exceeded %d bytes; aborted\", pc.maxHeaderResponseSize())\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase rc.ch <- responseAndError{err: err}:\n\t\t\tcase <-rc.callerGone:\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tpc.readLimit = maxInt64 // effectively no limit for response bodies\n\n\t\tpc.mu.Lock()\n\t\tpc.numExpectedResponses--\n\t\tpc.mu.Unlock()\n\n\t\tbodyWritable := bodyIsWritable(resp)\n\t\thasBody := rc.treq.Request.Method != \"HEAD\" && resp.ContentLength != 0\n\n\t\tif resp.Close || rc.treq.Request.Close || resp.StatusCode <= 199 || bodyWritable {\n\t\t\t// Don't do keep-alive on error if either party requested a close\n\t\t\t// or we get an unexpected informational (1xx) response.\n\t\t\t// StatusCode 100 is already handled above.\n\t\t\talive = false\n\t\t}\n\n\t\tif !hasBody || bodyWritable {\n\t\t\t// Put the idle conn back into the pool before we send the response\n\t\t\t// so if they process it quickly and make another request, they'll\n\t\t\t// get this same conn. But we use the unbuffered channel 'rc'\n\t\t\t// to guarantee that persistConn.roundTrip got out of its select\n\t\t\t// potentially waiting for this persistConn to close.\n\t\t\talive = alive &&\n\t\t\t\t!pc.sawEOF &&\n\t\t\t\tpc.wroteRequest() &&\n\t\t\t\ttryPutIdleConn(rc.treq)\n\n\t\t\tif bodyWritable {\n\t\t\t\tcloseErr = errCallerOwnsConn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase rc.ch <- responseAndError{res: resp}:\n\t\t\tcase <-rc.callerGone:\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trc.treq.cancel(errRequestDone)\n\n\t\t\t// Now that they've read from the unbuffered channel, they're safely\n\t\t\t// out of the select that also waits on this goroutine to die, so\n\t\t\t// we're allowed to exit now if needed (if alive is false)\n\t\t\ttestHookReadLoopBeforeNextRead()\n\t\t\tcontinue\n\t\t}\n\n\t\twaitForBodyRead := make(chan bool, 2)\n\t\tbody := &bodyEOFSignal{\n\t\t\tbody: resp.Body,\n\t\t\tearlyCloseFn: func() error {\n\t\t\t\twaitForBodyRead <- false\n\t\t\t\t<-eofc // will be closed by deferred call at the end of the function\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tfn: func(err error) error {\n\t\t\t\tisEOF := err == io.EOF\n\t\t\t\twaitForBodyRead <- isEOF\n\t\t\t\tif isEOF {\n\t\t\t\t\t<-eofc // see comment above eofc declaration\n\t\t\t\t} else if err != nil {\n\t\t\t\t\tif cerr := pc.canceled(); cerr != nil {\n\t\t\t\t\t\treturn cerr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t},\n\t\t}\n\n\t\tresp.Body = body\n\t\tif rc.addedGzip && ascii.EqualFold(resp.Header.Get(\"Content-Encoding\"), \"gzip\") {\n\t\t\tresp.Body = &gzipReader{body: body}\n\t\t\tresp.Header.Del(\"Content-Encoding\")\n\t\t\tresp.Header.Del(\"Content-Length\")\n\t\t\tresp.ContentLength = -1\n\t\t\tresp.Uncompressed = true\n\t\t} else if pc.t.AutoDecompression {\n\t\t\tcontentEncoding := resp.Header.Get(\"Content-Encoding\")\n\t\t\tif contentEncoding != \"\" {\n\t\t\t\tresp.Header.Del(\"Content-Encoding\")\n\t\t\t\tresp.Header.Del(\"Content-Length\")\n\t\t\t\tresp.ContentLength = -1\n\t\t\t\tresp.Uncompressed = true\n\t\t\t\tresp.Body = compress.NewCompressReader(resp.Body, contentEncoding)\n\t\t\t}\n\t\t}\n\n\t\tselect {\n\t\tcase rc.ch <- responseAndError{res: resp}:\n\t\tcase <-rc.callerGone:\n\t\t\treturn\n\t\t}\n\n\t\t// Before looping back to the top of this function and peeking on\n\t\t// the bufio.Reader, wait for the caller goroutine to finish\n\t\t// reading the response body. (or for cancellation or death)\n\t\tselect {\n\t\tcase bodyEOF := <-waitForBodyRead:\n\t\t\talive = alive &&\n\t\t\t\tbodyEOF &&\n\t\t\t\t!pc.sawEOF &&\n\t\t\t\tpc.wroteRequest() &&\n\t\t\t\ttryPutIdleConn(rc.treq)\n\t\t\tif bodyEOF {\n\t\t\t\teofc <- struct{}{}\n\t\t\t}\n\t\tcase <-rc.treq.ctx.Done():\n\t\t\talive = false\n\t\t\tpc.cancelRequest(context.Cause(rc.treq.ctx))\n\t\tcase <-pc.closech:\n\t\t\talive = false\n\t\t}\n\n\t\trc.treq.cancel(errRequestDone)\n\t\ttestHookReadLoopBeforeNextRead()\n\t}\n}\n\nfunc (pc *persistConn) readLoopPeekFailLocked(peekErr error) {\n\tif pc.closed != nil {\n\t\treturn\n\t}\n\tif n := pc.br.Buffered(); n > 0 {\n\t\tbuf, _ := pc.br.Peek(n)\n\t\tif is408Message(buf) {\n\t\t\tpc.closeLocked(errServerClosedIdle)\n\t\t\treturn\n\t\t}\n\t\tlog.Printf(\"Unsolicited response received on idle HTTP channel starting with %q; err=%v\", buf, peekErr)\n\t}\n\tif peekErr == io.EOF {\n\t\t// common case.\n\t\tpc.closeLocked(errServerClosedIdle)\n\t} else {\n\t\tpc.closeLocked(fmt.Errorf(\"readLoopPeekFailLocked: %w\", peekErr))\n\t}\n}\n\n// is408Message reports whether buf has the prefix of an\n// HTTP 408 Request Timeout response.\n// See golang.org/issue/32310.\nfunc is408Message(buf []byte) bool {\n\tif len(buf) < len(\"HTTP/1.x 408\") {\n\t\treturn false\n\t}\n\tif string(buf[:7]) != \"HTTP/1.\" {\n\t\treturn false\n\t}\n\treturn string(buf[8:12]) == \" 408\"\n}\n\n// readResponse reads an HTTP response (or two, in the case of \"Expect:\n// 100-continue\") from the server. It returns the final non-100 one.\n// trace is optional.\nfunc (pc *persistConn) readResponse(rc requestAndChan, trace *httptrace.ClientTrace) (resp *http.Response, err error) {\n\tif trace != nil && trace.GotFirstResponseByte != nil {\n\t\tif peek, err := pc.br.Peek(1); err == nil && len(peek) == 1 {\n\t\t\ttrace.GotFirstResponseByte()\n\t\t}\n\t}\n\tnum1xx := 0               // number of informational 1xx headers received\n\tconst max1xxResponses = 5 // arbitrary bound on number of informational responses\n\n\tcontinueCh := rc.continueCh\n\tfor {\n\t\tresp, err = pc._readResponse(rc.treq.Request)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tresCode := resp.StatusCode\n\t\tif continueCh != nil && resCode == http.StatusContinue {\n\t\t\tif trace != nil && trace.Got100Continue != nil {\n\t\t\t\ttrace.Got100Continue()\n\t\t\t}\n\t\t\tcontinueCh <- struct{}{}\n\t\t\tcontinueCh = nil\n\t\t}\n\t\tis1xx := 100 <= resCode && resCode <= 199\n\t\t// treat 101 as a terminal status, see issue 26161\n\t\tis1xxNonTerminal := is1xx && resCode != http.StatusSwitchingProtocols\n\n\t\tif is1xxNonTerminal {\n\t\t\tnum1xx++\n\t\t\tif num1xx > max1xxResponses {\n\t\t\t\treturn nil, errors.New(\"net/http: too many 1xx informational responses\")\n\t\t\t}\n\t\t\tpc.readLimit = pc.maxHeaderResponseSize() // reset the limit\n\t\t\tif trace != nil && trace.Got1xxResponse != nil {\n\t\t\t\tif err := trace.Got1xxResponse(resCode, textproto.MIMEHeader(resp.Header)); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\tif isProtocolSwitch(resp) {\n\t\tresp.Body = newReadWriteCloserBody(pc.br, pc.conn)\n\t}\n\tif continueCh != nil {\n\t\t// We send an \"Expect: 100-continue\" header, but the server\n\t\t// responded with a terminal status and no 100 Continue.\n\t\t//\n\t\t// If we're going to keep using the connection, we need to send the request body.\n\t\t// Tell writeLoop to skip sending the body if we're going to close the connection,\n\t\t// or to send it otherwise.\n\t\t//\n\t\t// The case where we receive a 101 Switching Protocols response is a bit\n\t\t// ambiguous, since we don't know what protocol we're switching to.\n\t\t// Conceivably, it's one that doesn't need us to send the body.\n\t\t// Given that we'll send the body if ExpectContinueTimeout expires,\n\t\t// be consistent and always send it if we aren't closing the connection.\n\t\tif resp.Close || rc.treq.Request.Close {\n\t\t\tclose(continueCh) // don't send the body; the connection will close\n\t\t} else {\n\t\t\tcontinueCh <- struct{}{} // send the body\n\t\t}\n\t}\n\n\tresp.TLS = pc.tlsState\n\treturn\n}\n\n// waitForContinue returns the function to block until\n// any response, timeout or connection close. After any of them,\n// the function returns a bool which indicates if the body should be sent.\nfunc (pc *persistConn) waitForContinue(continueCh <-chan struct{}) func() bool {\n\tif continueCh == nil {\n\t\treturn nil\n\t}\n\treturn func() bool {\n\t\ttimer := time.NewTimer(pc.t.ExpectContinueTimeout)\n\t\tdefer timer.Stop()\n\n\t\tselect {\n\t\tcase _, ok := <-continueCh:\n\t\t\treturn ok\n\t\tcase <-timer.C:\n\t\t\treturn true\n\t\tcase <-pc.closech:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\nfunc newReadWriteCloserBody(br *bufio.Reader, rwc io.ReadWriteCloser) io.ReadWriteCloser {\n\tbody := &readWriteCloserBody{ReadWriteCloser: rwc}\n\tif br.Buffered() != 0 {\n\t\tbody.br = br\n\t}\n\treturn body\n}\n\n// readWriteCloserBody is the Response.Body type used when we want to\n// give users write access to the Body through the underlying\n// connection (TCP, unless using custom dialers). This is then\n// the concrete type for a Response.Body on the 101 Switching\n// Protocols response, as used by WebSockets, h2c, etc.\ntype readWriteCloserBody struct {\n\t_  incomparable\n\tbr *bufio.Reader // used until empty\n\tio.ReadWriteCloser\n}\n\nfunc (b *readWriteCloserBody) Read(p []byte) (n int, err error) {\n\tif b.br != nil {\n\t\tif n := b.br.Buffered(); len(p) > n {\n\t\t\tp = p[:n]\n\t\t}\n\t\tn, err = b.br.Read(p)\n\t\tif b.br.Buffered() == 0 {\n\t\t\tb.br = nil\n\t\t}\n\t\treturn n, err\n\t}\n\treturn b.ReadWriteCloser.Read(p)\n}\n\n// nothingWrittenError wraps a write errors which ended up writing zero bytes.\ntype nothingWrittenError struct {\n\terror\n}\n\nfunc (nwe nothingWrittenError) Unwrap() error {\n\treturn nwe.error\n}\n\nfunc (pc *persistConn) writeLoop() {\n\tdefer close(pc.writeLoopDone)\n\tfor {\n\t\tselect {\n\t\tcase wr := <-pc.writech:\n\t\t\tstartBytesWritten := pc.nwrite\n\t\t\terr := pc.writeRequest(wr.req.Request, pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))\n\t\t\tif bre, ok := err.(requestBodyReadError); ok {\n\t\t\t\terr = bre.error\n\t\t\t\t// Errors reading from the user's\n\t\t\t\t// Request.Body are high priority.\n\t\t\t\t// Set it here before sending on the\n\t\t\t\t// channels below or calling\n\t\t\t\t// pc.close() which tears down\n\t\t\t\t// connections and causes other\n\t\t\t\t// errors.\n\t\t\t\twr.req.setError(err)\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\terr = pc.bw.Flush()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tif pc.nwrite == startBytesWritten {\n\t\t\t\t\terr = nothingWrittenError{err}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpc.writeErrCh <- err // to the body reader, which might recycle us\n\t\t\twr.ch <- err         // to the roundTrip function\n\t\t\tif err != nil {\n\t\t\t\tpc.close(err)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-pc.closech:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// extraHeaders may be nil\n// waitForContinue may be nil\n// always closes body\nfunc (pc *persistConn) writeRequest(r *http.Request, w io.Writer, usingProxy bool, extraHeaders http.Header, waitForContinue func() bool) (err error) {\n\ttrace := httptrace.ContextClientTrace(r.Context())\n\tif trace != nil && trace.WroteRequest != nil {\n\t\tdefer func() {\n\t\t\ttrace.WroteRequest(httptrace.WroteRequestInfo{\n\t\t\t\tErr: err,\n\t\t\t})\n\t\t}()\n\t}\n\tclosed := false\n\tdefer func() {\n\t\tif closed {\n\t\t\treturn\n\t\t}\n\t\tif closeErr := closeRequestBody(r); closeErr != nil && err == nil {\n\t\t\terr = closeErr\n\t\t}\n\t}()\n\n\t// Find the target host. Prefer the Host: header, but if that\n\t// is not given, use the host from the request URL.\n\t//\n\t// Clean the host, in case it arrives with unexpected stuff in it.\n\thost := r.Host\n\tif host == \"\" {\n\t\tif r.URL == nil {\n\t\t\treturn errMissingHost\n\t\t}\n\t\thost = r.URL.Host\n\t}\n\thost, err = httpguts.PunycodeHostPort(host)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Validate that the Host header is a valid header in general,\n\t// but don't validate the host itself. This is sufficient to avoid\n\t// header or request smuggling via the Host field.\n\t// The server can (and will, if it's a net/http server) reject\n\t// the request if it doesn't consider the host valid.\n\tif !httpguts.ValidHostHeader(host) {\n\t\t// Historically, we would truncate the Host header after '/' or ' '.\n\t\t// Some users have relied on this truncation to convert a network\n\t\t// address such as Unix domain socket path into a valid, ignored\n\t\t// Host header (see https://go.dev/issue/61431).\n\t\t//\n\t\t// We don't preserve the truncation, because sending an altered\n\t\t// header field opens a smuggling vector. Instead, zero out the\n\t\t// Host header entirely if it isn't valid. (An empty Host is valid;\n\t\t// see RFC 9112 Section 3.2.)\n\t\t//\n\t\t// Return an error if we're sending to a proxy, since the proxy\n\t\t// probably can't do anything useful with an empty Host header.\n\t\tif !usingProxy {\n\t\t\thost = \"\"\n\t\t} else {\n\t\t\treturn errors.New(\"http: invalid Host header\")\n\t\t}\n\t}\n\n\t// According to RFC 6874, an HTTP client, proxy, or other\n\t// intermediary must remove any IPv6 zone identifier attached\n\t// to an outgoing URI.\n\thost = removeZone(host)\n\n\truri := r.URL.RequestURI()\n\tif usingProxy && r.URL.Scheme != \"\" && r.URL.Opaque == \"\" {\n\t\truri = r.URL.Scheme + \"://\" + host + ruri\n\t} else if r.Method == \"CONNECT\" && r.URL.Path == \"\" {\n\t\t// CONNECT requests normally give just the host and port, not a full URL.\n\t\truri = host\n\t\tif r.URL.Opaque != \"\" {\n\t\t\truri = r.URL.Opaque\n\t\t}\n\t}\n\tif stringContainsCTLByte(ruri) {\n\t\treturn errors.New(\"net/http: can't write control character in Request.URL\")\n\t}\n\t// TODO: validate r.Method too? At least it's less likely to\n\t// come from an attacker (more likely to be a constant in\n\t// code).\n\n\t// Wrap the writer in a bufio Writer if it's not already buffered.\n\t// Don't always call NewWriter, as that forces a bytes.Buffer\n\t// and other small bufio Writers to have a minimum 4k buffer\n\t// size.\n\tvar bw *bufio.Writer\n\tif _, ok := w.(io.ByteWriter); !ok {\n\t\tbw = bufio.NewWriter(w)\n\t\tw = bw\n\t}\n\n\trw := w // raw writer\n\tdumps := dump.GetDumpers(r.Context(), pc.t.Dump)\n\tfor _, dump := range dumps {\n\t\tif dump.RequestHeader() {\n\t\t\tw = dump.WrapRequestHeaderWriter(w)\n\t\t}\n\t}\n\n\t_, err = fmt.Fprintf(w, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(r.Method, \"GET\"), ruri)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_writeHeader := func(key string, values ...string) error {\n\t\tfor _, value := range values {\n\t\t\t_, err := fmt.Fprintf(w, \"%s: %s\\r\\n\", key, value)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif trace != nil && trace.WroteHeaderField != nil {\n\t\t\ttrace.WroteHeaderField(key, values)\n\t\t}\n\t\treturn nil\n\t}\n\n\tvar writeHeader func(key string, values ...string) error\n\tvar kvs []header.KeyValues\n\tsort := false\n\n\tif r.Header != nil && len(r.Header[header.HeaderOderKey]) > 0 {\n\t\twriteHeader = func(key string, values ...string) error {\n\t\t\tkvs = append(kvs, header.KeyValues{\n\t\t\t\tKey:    key,\n\t\t\t\tValues: values,\n\t\t\t})\n\t\t\treturn nil\n\t\t}\n\t\tsort = true\n\t} else {\n\t\twriteHeader = _writeHeader\n\t}\n\t// Header lines\n\terr = writeHeader(\"Host\", host)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Use the defaultUserAgent unless the Header contains one, which\n\t// may be blank to not send the header.\n\tuserAgent := header.DefaultUserAgent\n\tif headerHas(r.Header, \"User-Agent\") {\n\t\tuserAgent = r.Header.Get(\"User-Agent\")\n\t}\n\tif userAgent != \"\" {\n\t\terr = writeHeader(\"User-Agent\", userAgent)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Process Body,ContentLength,Close,Trailer\n\ttw, err := newTransferWriter(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tw.writeHeader(writeHeader)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = headerWriteSubset(r.Header, reqWriteExcludeHeader, writeHeader, sort)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif extraHeaders != nil {\n\t\terr = headerWrite(extraHeaders, writeHeader, sort)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif sort { // sort and write headers\n\t\theader.SortKeyValues(kvs, r.Header[header.HeaderOderKey])\n\t\tfor _, kv := range kvs {\n\t\t\t_writeHeader(kv.Key, kv.Values...)\n\t\t}\n\t}\n\n\t_, err = io.WriteString(w, \"\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif trace != nil && trace.WroteHeaders != nil {\n\t\ttrace.WroteHeaders()\n\t}\n\n\t// Flush and wait for 100-continue if expected.\n\tif waitForContinue != nil {\n\t\tif bw, ok := w.(*bufio.Writer); ok {\n\t\t\terr = bw.Flush()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif trace != nil && trace.Wait100Continue != nil {\n\t\t\ttrace.Wait100Continue()\n\t\t}\n\t\tif !waitForContinue() {\n\t\t\tclosed = true\n\t\t\tcloseRequestBody(r)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif bw, ok := w.(*bufio.Writer); ok && tw.FlushHeaders {\n\t\tif err := bw.Flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Write body and trailer\n\tclosed = true\n\terr = tw.writeBody(rw, dumps)\n\tif err != nil {\n\t\tif tw.bodyReadError == err {\n\t\t\terr = requestBodyReadError{err}\n\t\t}\n\t\treturn err\n\t}\n\n\tif bw != nil {\n\t\treturn bw.Flush()\n\t}\n\treturn nil\n}\n\n// maxWriteWaitBeforeConnReuse is how long the a Transport RoundTrip\n// will wait to see the Request's Body.Write result after getting a\n// response from the server. See comments in (*persistConn).wroteRequest.\n//\n// In tests, we set this to a large value to avoid flakiness from inconsistent\n// recycling of connections.\nvar maxWriteWaitBeforeConnReuse = 50 * time.Millisecond\n\n// wroteRequest is a check before recycling a connection that the previous write\n// (from writeLoop above) happened and was successful.\nfunc (pc *persistConn) wroteRequest() bool {\n\tselect {\n\tcase err := <-pc.writeErrCh:\n\t\t// Common case: the write happened well before the response, so\n\t\t// avoid creating a timer.\n\t\treturn err == nil\n\tdefault:\n\t\t// Rare case: the request was written in writeLoop above but\n\t\t// before it could send to pc.writeErrCh, the reader read it\n\t\t// all, processed it, and called us here. In this case, give the\n\t\t// write goroutine a bit of time to finish its send.\n\t\t//\n\t\t// Less rare case: We also get here in the legitimate case of\n\t\t// Issue 7569, where the writer is still writing (or stalled),\n\t\t// but the server has already replied. In this case, we don't\n\t\t// want to wait too long, and we want to return false so this\n\t\t// connection isn't re-used.\n\t\tt := time.NewTimer(maxWriteWaitBeforeConnReuse)\n\t\tdefer t.Stop()\n\t\tselect {\n\t\tcase err := <-pc.writeErrCh:\n\t\t\treturn err == nil\n\t\tcase <-t.C:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\n// responseAndError is how the goroutine reading from an HTTP/1 server\n// communicates with the goroutine doing the RoundTrip.\ntype responseAndError struct {\n\t_   incomparable\n\tres *http.Response // else use this response (see res method)\n\terr error\n}\n\ntype requestAndChan struct {\n\t_    incomparable\n\ttreq *transportRequest\n\tch   chan responseAndError // unbuffered; always send in select on callerGone\n\n\t// whether the Transport (as opposed to the user client code)\n\t// added the Accept-Encoding gzip header. If the Transport\n\t// set it, only then do we transparently decode the gzip.\n\taddedGzip bool\n\n\t// Optional blocking chan for Expect: 100-continue (for send).\n\t// If the request has an \"Expect: 100-continue\" header and\n\t// the server responds 100 Continue, readLoop send a value\n\t// to writeLoop via this chan.\n\tcontinueCh chan<- struct{}\n\n\tcallerGone <-chan struct{} // closed when roundTrip caller has returned\n}\n\n// A writeRequest is sent by the caller's goroutine to the\n// writeLoop's goroutine to write a request while the read loop\n// concurrently waits on both the write response and the server's\n// reply.\ntype writeRequest struct {\n\treq *transportRequest\n\tch  chan<- error\n\n\t// Optional blocking chan for Expect: 100-continue (for receive).\n\t// If not nil, writeLoop blocks sending request body until\n\t// it receives from this chan.\n\tcontinueCh <-chan struct{}\n}\n\n// httpTimeoutError represents a timeout.\n// It implements net.Error and wraps context.DeadlineExceeded.\ntype timeoutError struct {\n\terr string\n}\n\nfunc (e *timeoutError) Error() string     { return e.err }\nfunc (e *timeoutError) Timeout() bool     { return true }\nfunc (e *timeoutError) Temporary() bool   { return true }\nfunc (e *timeoutError) Is(err error) bool { return err == context.DeadlineExceeded }\n\nvar errTimeout error = &timeoutError{\"net/http: timeout awaiting response headers\"}\n\nvar errRequestCanceledConn = errors.New(\"net/http: request canceled while waiting for connection\") // TODO: unify?\n\n// errRequestDone is used to cancel the round trip Context after a request is successfully done.\n// It should not be seen by the user.\nvar errRequestDone = errors.New(\"net/http: request completed\")\n\nfunc nop() {}\n\n// testHooks. Always non-nil.\nvar (\n\ttestHookEnterRoundTrip   = nop\n\ttestHookWaitResLoop      = nop\n\ttestHookRoundTripRetried = nop\n\ttestHookPrePendingDial   = nop\n\ttestHookPostPendingDial  = nop\n\n\ttestHookMu                     sync.Locker = fakeLocker{} // guards following\n\ttestHookReadLoopBeforeNextRead             = nop\n)\n\nfunc (pc *persistConn) roundTrip(req *transportRequest) (resp *http.Response, err error) {\n\tif pc.t.Debugf != nil {\n\t\tpc.t.Debugf(\"HTTP/1.1 %s %s\", req.Method, req.URL.String())\n\t}\n\ttestHookEnterRoundTrip()\n\tpc.mu.Lock()\n\tpc.numExpectedResponses++\n\theaderFn := pc.mutateHeaderFunc\n\tpc.mu.Unlock()\n\n\tif headerFn != nil {\n\t\theaderFn(req.extraHeaders())\n\t}\n\n\t// Ask for a compressed version if the caller didn't set their\n\t// own value for Accept-Encoding. We only attempt to\n\t// uncompress the gzip stream if we were the layer that\n\t// requested it.\n\trequestedGzip := false\n\tif !pc.t.DisableCompression &&\n\t\treq.Header.Get(\"Accept-Encoding\") == \"\" &&\n\t\treq.Header.Get(\"Range\") == \"\" &&\n\t\treq.Method != \"HEAD\" {\n\t\t// Request gzip only, not deflate. Deflate is ambiguous and\n\t\t// not as universally supported anyway.\n\t\t// See: https://zlib.net/zlib_faq.html#faq39\n\t\t//\n\t\t// Note that we don't request this for HEAD requests,\n\t\t// due to a bug in nginx:\n\t\t//   https://trac.nginx.org/nginx/ticket/358\n\t\t//   https://golang.org/issue/5522\n\t\t//\n\t\t// We don't request gzip if the request is for a range, since\n\t\t// auto-decoding a portion of a gzipped document will just fail\n\t\t// anyway. See https://golang.org/issue/8923\n\t\trequestedGzip = true\n\t\treq.extraHeaders().Set(\"Accept-Encoding\", \"gzip\")\n\t}\n\n\tvar continueCh chan struct{}\n\tif req.ProtoAtLeast(1, 1) && req.Body != nil && reqExpectsContinue(req.Request) {\n\t\tcontinueCh = make(chan struct{}, 1)\n\t}\n\n\tif pc.t.DisableKeepAlives &&\n\t\t!reqWantsClose(req.Request) &&\n\t\t!isProtocolSwitchHeader(req.Header) {\n\t\treq.extraHeaders().Set(\"Connection\", \"close\")\n\t}\n\n\tgone := make(chan struct{})\n\tdefer close(gone)\n\n\tconst debugRoundTrip = false\n\n\t// Write the request concurrently with waiting for a response,\n\t// in case the server decides to reply before reading our full\n\t// request body.\n\tstartBytesWritten := pc.nwrite\n\twriteErrCh := make(chan error, 1)\n\tpc.writech <- writeRequest{req, writeErrCh, continueCh}\n\n\tresc := make(chan responseAndError)\n\tpc.reqch <- requestAndChan{\n\t\ttreq:       req,\n\t\tch:         resc,\n\t\taddedGzip:  requestedGzip,\n\t\tcontinueCh: continueCh,\n\t\tcallerGone: gone,\n\t}\n\thandleResponse := func(re responseAndError) (*http.Response, error) {\n\t\tif (re.res == nil) == (re.err == nil) {\n\t\t\tpanic(fmt.Sprintf(\"internal error: exactly one of res or err should be set; nil=%v\", re.res == nil))\n\t\t}\n\t\tif debugRoundTrip {\n\t\t\treq.logf(\"resc recv: %p, %T/%#v\", re.res, re.err, re.err)\n\t\t}\n\t\tif re.err != nil {\n\t\t\treturn nil, pc.mapRoundTripError(req, startBytesWritten, re.err)\n\t\t}\n\t\treturn re.res, nil\n\t}\n\n\tvar respHeaderTimer <-chan time.Time\n\tctxDoneChan := req.ctx.Done()\n\tpcClosed := pc.closech\n\tfor {\n\t\ttestHookWaitResLoop()\n\t\tselect {\n\t\tcase err := <-writeErrCh:\n\t\t\tif debugRoundTrip {\n\t\t\t\treq.logf(\"writeErrCh recv: %T/%#v\", err, err)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tpc.close(fmt.Errorf(\"write error: %w\", err))\n\t\t\t\treturn nil, pc.mapRoundTripError(req, startBytesWritten, err)\n\t\t\t}\n\t\t\tif d := pc.t.ResponseHeaderTimeout; d > 0 {\n\t\t\t\tif debugRoundTrip {\n\t\t\t\t\treq.logf(\"starting timer for %v\", d)\n\t\t\t\t}\n\t\t\t\ttimer := time.NewTimer(d)\n\t\t\t\tdefer timer.Stop() // prevent leaks\n\t\t\t\trespHeaderTimer = timer.C\n\t\t\t}\n\t\tcase <-pcClosed:\n\t\t\tselect {\n\t\t\tcase re := <-resc:\n\t\t\t\t// The pconn closing raced with the response to the request,\n\t\t\t\t// probably after the server wrote a response and immediately\n\t\t\t\t// closed the connection. Use the response.\n\t\t\t\treturn handleResponse(re)\n\t\t\tdefault:\n\t\t\t}\n\t\t\tif debugRoundTrip {\n\t\t\t\treq.logf(\"closech recv: %T %#v\", pc.closed, pc.closed)\n\t\t\t}\n\t\t\treturn nil, pc.mapRoundTripError(req, startBytesWritten, pc.closed)\n\t\tcase <-respHeaderTimer:\n\t\t\tif debugRoundTrip {\n\t\t\t\treq.logf(\"timeout waiting for response headers.\")\n\t\t\t}\n\t\t\tpc.close(errTimeout)\n\t\t\treturn nil, errTimeout\n\t\tcase re := <-resc:\n\t\t\treturn handleResponse(re)\n\t\tcase <-ctxDoneChan:\n\t\t\tselect {\n\t\t\tcase re := <-resc:\n\t\t\t\t// readLoop is responsible for canceling req.ctx after\n\t\t\t\t// it reads the response body. Check for a response racing\n\t\t\t\t// the context close, and use the response if available.\n\t\t\t\treturn handleResponse(re)\n\t\t\tdefault:\n\t\t\t}\n\t\t\tpc.cancelRequest(context.Cause(req.ctx))\n\t\t}\n\t}\n}\n\n// tLogKey is a context WithValue key for test debugging contexts containing\n// a t.Logf func. See export_test.go's Request.WithT method.\ntype tLogKey struct{}\n\nfunc (tr *transportRequest) logf(format string, args ...interface{}) {\n\tif logf, ok := tr.Request.Context().Value(tLogKey{}).(func(string, ...interface{})); ok {\n\t\tlogf(time.Now().Format(time.RFC3339Nano)+\": \"+format, args...)\n\t}\n}\n\n// markReused marks this connection as having been successfully used for a\n// request and response.\nfunc (pc *persistConn) markReused() {\n\tpc.mu.Lock()\n\tpc.reused = true\n\tpc.mu.Unlock()\n}\n\n// close closes the underlying TCP connection and closes\n// the pc.closech channel.\n//\n// The provided err is only for testing and debugging; in normal\n// circumstances it should never be seen by users.\nfunc (pc *persistConn) close(err error) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tpc.closeLocked(err)\n}\n\nfunc (pc *persistConn) closeLocked(err error) {\n\tif err == nil {\n\t\tpanic(\"nil error\")\n\t}\n\tpc.broken = true\n\tif pc.closed == nil {\n\t\tpc.closed = err\n\t\tpc.t.decConnsPerHost(pc.cacheKey)\n\t\t// Close HTTP/1 (pc.alt == nil) connection.\n\t\t// HTTP/2 closes its connection itself.\n\t\tif pc.alt == nil {\n\t\t\tif err != errCallerOwnsConn {\n\t\t\t\tpc.conn.Close()\n\t\t\t}\n\t\t\tclose(pc.closech)\n\t\t}\n\t}\n\tpc.mutateHeaderFunc = nil\n}\n\nvar portMap = map[string]string{\n\t\"http\":    \"80\",\n\t\"https\":   \"443\",\n\t\"socks5\":  \"1080\",\n\t\"socks5h\": \"1080\",\n}\n\nfunc idnaASCIIFromURL(url *url.URL) string {\n\taddr := url.Hostname()\n\tif v, err := idnaASCII(addr); err == nil {\n\t\taddr = v\n\t}\n\treturn addr\n}\n\n// canonicalAddr returns url.Host but always with a \":port\" suffix.\nfunc canonicalAddr(url *url.URL) string {\n\tport := url.Port()\n\tif port == \"\" {\n\t\tport = portMap[url.Scheme]\n\t}\n\treturn net.JoinHostPort(idnaASCIIFromURL(url), port)\n}\n\n// bodyEOFSignal is used by the HTTP/1 transport when reading response\n// bodies to make sure we see the end of a response body before\n// proceeding and reading on the connection again.\n//\n// It wraps a ReadCloser but runs fn (if non-nil) at most\n// once, right before its final (error-producing) Read or Close call\n// returns. fn should return the new error to return from Read or Close.\n//\n// If earlyCloseFn is non-nil and Close is called before io.EOF is\n// seen, earlyCloseFn is called instead of fn, and its return value is\n// the return value from Close.\ntype bodyEOFSignal struct {\n\tbody         io.ReadCloser\n\tmu           sync.Mutex        // guards following 4 fields\n\tclosed       bool              // whether Close has been called\n\trerr         error             // sticky Read error\n\tfn           func(error) error // err will be nil on Read io.EOF\n\tearlyCloseFn func() error      // optional alt Close func used if io.EOF not seen\n}\n\nvar errReadOnClosedResBody = errors.New(\"http: read on closed response body\")\n\nfunc (es *bodyEOFSignal) Read(p []byte) (n int, err error) {\n\tes.mu.Lock()\n\tclosed, rerr := es.closed, es.rerr\n\tes.mu.Unlock()\n\tif closed {\n\t\treturn 0, errReadOnClosedResBody\n\t}\n\tif rerr != nil {\n\t\treturn 0, rerr\n\t}\n\n\tn, err = es.body.Read(p)\n\tif err != nil {\n\t\tes.mu.Lock()\n\t\tdefer es.mu.Unlock()\n\t\tif es.rerr == nil {\n\t\t\tes.rerr = err\n\t\t}\n\t\terr = es.condfn(err)\n\t}\n\treturn\n}\n\nfunc (es *bodyEOFSignal) Close() error {\n\tes.mu.Lock()\n\tdefer es.mu.Unlock()\n\tif es.closed {\n\t\treturn nil\n\t}\n\tes.closed = true\n\tif es.earlyCloseFn != nil && es.rerr != io.EOF {\n\t\treturn es.earlyCloseFn()\n\t}\n\terr := es.body.Close()\n\treturn es.condfn(err)\n}\n\n// caller must hold es.mu.\nfunc (es *bodyEOFSignal) condfn(err error) error {\n\tif es.fn == nil {\n\t\treturn err\n\t}\n\terr = es.fn(err)\n\tes.fn = nil\n\treturn err\n}\n\n// gzipReader wraps a response body so it can lazily\n// call gzip.NewReader on the first call to Read\ntype gzipReader struct {\n\t_    incomparable\n\tbody *bodyEOFSignal // underlying HTTP/1 response body framing\n\tzr   *gzip.Reader   // lazily-initialized gzip reader\n\tzerr error          // any error from gzip.NewReader; sticky\n}\n\nfunc (gz *gzipReader) Read(p []byte) (n int, err error) {\n\tif gz.zr == nil {\n\t\tif gz.zerr == nil {\n\t\t\tgz.zr, gz.zerr = gzip.NewReader(gz.body)\n\t\t}\n\t\tif gz.zerr != nil {\n\t\t\treturn 0, gz.zerr\n\t\t}\n\t}\n\n\tgz.body.mu.Lock()\n\tif gz.body.closed {\n\t\terr = errReadOnClosedResBody\n\t}\n\tgz.body.mu.Unlock()\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn gz.zr.Read(p)\n}\n\nfunc (gz *gzipReader) Close() error {\n\treturn gz.body.Close()\n}\n\ntype tlsHandshakeTimeoutError struct{}\n\nfunc (tlsHandshakeTimeoutError) Timeout() bool   { return true }\nfunc (tlsHandshakeTimeoutError) Temporary() bool { return true }\nfunc (tlsHandshakeTimeoutError) Error() string   { return \"net/http: TLS handshake timeout\" }\n\n// fakeLocker is a sync.Locker which does nothing. It's used to guard\n// test-only fields when not under test, to avoid runtime atomic\n// overhead.\ntype fakeLocker struct{}\n\nfunc (fakeLocker) Lock()   {}\nfunc (fakeLocker) Unlock() {}\n\n// cloneTLSConfig returns a shallow clone of cfg, or a new zero tls.Config if\n// cfg is nil. This is safe to call even if cfg is in active use by a TLS\n// client or server.\n//\n// cloneTLSConfig should be an internal detail,\n// but widely used packages access it using linkname.\n// Notable members of the hall of shame include:\n//   - github.com/searKing/golang\n//\n// Do not remove or change the type signature.\n// See go.dev/issue/67401.\n//\n//go:linkname cloneTLSConfig\nfunc cloneTLSConfig(cfg *tls.Config) *tls.Config {\n\tif cfg == nil {\n\t\treturn &tls.Config{}\n\t}\n\treturn cfg.Clone()\n}\n\ntype connLRU struct {\n\tll *list.List // list.Element.Value type is of *persistConn\n\tm  map[*persistConn]*list.Element\n}\n\n// add adds pc to the head of the linked list.\nfunc (cl *connLRU) add(pc *persistConn) {\n\tif cl.ll == nil {\n\t\tcl.ll = list.New()\n\t\tcl.m = make(map[*persistConn]*list.Element)\n\t}\n\tele := cl.ll.PushFront(pc)\n\tif _, ok := cl.m[pc]; ok {\n\t\tpanic(\"persistConn was already in LRU\")\n\t}\n\tcl.m[pc] = ele\n}\n\nfunc (cl *connLRU) removeOldest() *persistConn {\n\tele := cl.ll.Back()\n\tpc := ele.Value.(*persistConn)\n\tcl.ll.Remove(ele)\n\tdelete(cl.m, pc)\n\treturn pc\n}\n\n// remove removes pc from cl.\nfunc (cl *connLRU) remove(pc *persistConn) {\n\tif ele, ok := cl.m[pc]; ok {\n\t\tcl.ll.Remove(ele)\n\t\tdelete(cl.m, pc)\n\t}\n}\n\n// len returns the number of items in the cache.\nfunc (cl *connLRU) len() int {\n\treturn len(cl.m)\n}\n"
        },
        {
          "name": "transport_default_other.go",
          "type": "blob",
          "size": 0.359375,
          "content": "// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !js || !wasm\n\npackage req\n\nimport (\n\t\"context\"\n\t\"net\"\n)\n\nfunc defaultTransportDialContext(dialer *net.Dialer) func(context.Context, string, string) (net.Conn, error) {\n\treturn dialer.DialContext\n}\n"
        },
        {
          "name": "transport_default_wasm.go",
          "type": "blob",
          "size": 0.3544921875,
          "content": "// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build (js && wasm) || wasip1\n\npackage req\n\nimport (\n\t\"context\"\n\t\"net\"\n)\n\nfunc defaultTransportDialContext(dialer *net.Dialer) func(context.Context, string, string) (net.Conn, error) {\n\treturn nil\n}\n"
        }
      ]
    }
  ]
}