{
  "metadata": {
    "timestamp": 1736567047075,
    "page": 630,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "appleboy/gin-jwt",
      "stars": 2799,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2958984375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n.DS_Store\n.vscode\ncoverage.out\n.idea\n"
        },
        {
          "name": ".goreleaser.yaml",
          "type": "blob",
          "size": 0.6689453125,
          "content": "builds:\n  - # If true, skip the build.\n    # Useful for library projects.\n    # Default is false\n    skip: true\n\nchangelog:\n  use: github\n  groups:\n    - title: Features\n      regexp: \"^.*feat[(\\\\w)]*:+.*$\"\n      order: 0\n    - title: \"Bug fixes\"\n      regexp: \"^.*fix[(\\\\w)]*:+.*$\"\n      order: 1\n    - title: \"Enhancements\"\n      regexp: \"^.*chore[(\\\\w)]*:+.*$\"\n      order: 2\n    - title: \"Refactor\"\n      regexp: \"^.*refactor[(\\\\w)]*:+.*$\"\n      order: 3\n    - title: \"Build process updates\"\n      regexp: ^.*?(build|ci)(\\(.+\\))??!?:.+$\n      order: 4\n    - title: \"Documentation updates\"\n      regexp: ^.*?docs?(\\(.+\\))??!?:.+$\n      order: 4\n    - title: Others\n      order: 999\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Bo-Yi Wu\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.9677734375,
          "content": "# JWT Middleware for Gin Framework\n\n[![Run Tests](https://github.com/appleboy/gin-jwt/actions/workflows/go.yml/badge.svg)](https://github.com/appleboy/gin-jwt/actions/workflows/go.yml)\n[![GitHub tag](https://img.shields.io/github/tag/appleboy/gin-jwt.svg)](https://github.com/appleboy/gin-jwt/releases)\n[![GoDoc](https://godoc.org/github.com/appleboy/gin-jwt?status.svg)](https://godoc.org/github.com/appleboy/gin-jwt)\n[![Go Report Card](https://goreportcard.com/badge/github.com/appleboy/gin-jwt)](https://goreportcard.com/report/github.com/appleboy/gin-jwt)\n[![codecov](https://codecov.io/gh/appleboy/gin-jwt/branch/master/graph/badge.svg)](https://codecov.io/gh/appleboy/gin-jwt)\n[![codebeat badge](https://codebeat.co/badges/c4015f07-df23-4c7c-95ba-9193a12e14b1)](https://codebeat.co/projects/github-com-appleboy-gin-jwt)\n[![Sourcegraph](https://sourcegraph.com/github.com/appleboy/gin-jwt/-/badge.svg)](https://sourcegraph.com/github.com/appleboy/gin-jwt?badge)\n\nThis is a middleware for [Gin](https://github.com/gin-gonic/gin) framework.\n\nIt uses [jwt-go](https://github.com/golang-jwt/jwt) to provide a jwt authentication middleware. It provides additional handler functions to provide the `login` api that will generate the token and an additional `refresh` handler that can be used to refresh tokens.\n\n## Security Issue\n\nSimple HS256 JWT token brute force cracker. Effective only to crack JWT tokens with weak secrets. **Recommendation**: Use strong long secrets or `RS256` tokens. See the [jwt-cracker repository](https://github.com/lmammino/jwt-cracker).\n\n## Usage\n\nDownload and install using [go module](https://blog.golang.org/using-go-modules):\n\n```sh\nexport GO111MODULE=on\ngo get github.com/appleboy/gin-jwt/v2\n```\n\nImport it in your code:\n\n```go\nimport \"github.com/appleboy/gin-jwt/v2\"\n```\n\nDownload and install without using [go module](https://blog.golang.org/using-go-modules):\n\n```sh\ngo get github.com/appleboy/gin-jwt\n```\n\nImport it in your code:\n\n```go\nimport \"github.com/appleboy/gin-jwt\"\n```\n\n## Example\n\nPlease see [the example file](_example/basic/server.go) and you can use `ExtractClaims` to fetch user data.\n\n```go\npackage main\n\nimport (\n  \"log\"\n  \"net/http\"\n  \"os\"\n  \"time\"\n\n  jwt \"github.com/appleboy/gin-jwt/v2\"\n  \"github.com/gin-gonic/gin\"\n)\n\ntype login struct {\n  Username string `form:\"username\" json:\"username\" binding:\"required\"`\n  Password string `form:\"password\" json:\"password\" binding:\"required\"`\n}\n\nvar (\n  identityKey = \"id\"\n  port        string\n)\n\n// User demo\ntype User struct {\n  UserName  string\n  FirstName string\n  LastName  string\n}\n\nfunc init() {\n  port = os.Getenv(\"PORT\")\n  if port == \"\" {\n    port = \"8000\"\n  }\n}\n\nfunc main() {\n  engine := gin.Default()\n  // the jwt middleware\n  authMiddleware, err := jwt.New(initParams())\n  if err != nil {\n    log.Fatal(\"JWT Error:\" + err.Error())\n  }\n\n  // register middleware\n  engine.Use(handlerMiddleware(authMiddleware))\n\n  // register route\n  registerRoute(engine, authMiddleware)\n\n  // start http server\n  if err = http.ListenAndServe(\":\"+port, engine); err != nil {\n    log.Fatal(err)\n  }\n}\n\nfunc registerRoute(r *gin.Engine, handle *jwt.GinJWTMiddleware) {\n  r.POST(\"/login\", handle.LoginHandler)\n  r.NoRoute(handle.MiddlewareFunc(), handleNoRoute())\n\n  auth := r.Group(\"/auth\", handle.MiddlewareFunc())\n  auth.GET(\"/refresh_token\", handle.RefreshHandler)\n  auth.GET(\"/hello\", helloHandler)\n}\n\nfunc handlerMiddleware(authMiddleware *jwt.GinJWTMiddleware) gin.HandlerFunc {\n  return func(context *gin.Context) {\n    errInit := authMiddleware.MiddlewareInit()\n    if errInit != nil {\n      log.Fatal(\"authMiddleware.MiddlewareInit() Error:\" + errInit.Error())\n    }\n  }\n}\n\nfunc initParams() *jwt.GinJWTMiddleware {\n\n  return &jwt.GinJWTMiddleware{\n    Realm:       \"test zone\",\n    Key:         []byte(\"secret key\"),\n    Timeout:     time.Hour,\n    MaxRefresh:  time.Hour,\n    IdentityKey: identityKey,\n    PayloadFunc: payloadFunc(),\n\n    IdentityHandler: identityHandler(),\n    Authenticator:   authenticator(),\n    Authorizator:    authorizator(),\n    Unauthorized:    unauthorized(),\n    TokenLookup:     \"header: Authorization, query: token, cookie: jwt\",\n    // TokenLookup: \"query:token\",\n    // TokenLookup: \"cookie:token\",\n    TokenHeadName: \"Bearer\",\n    TimeFunc:      time.Now,\n  }\n}\n\nfunc payloadFunc() func(data interface{}) jwt.MapClaims {\n  return func(data interface{}) jwt.MapClaims {\n    if v, ok := data.(*User); ok {\n      return jwt.MapClaims{\n        identityKey: v.UserName,\n      }\n    }\n    return jwt.MapClaims{}\n  }\n}\n\nfunc identityHandler() func(c *gin.Context) interface{} {\n  return func(c *gin.Context) interface{} {\n    claims := jwt.ExtractClaims(c)\n    return &User{\n      UserName: claims[identityKey].(string),\n    }\n  }\n}\n\nfunc authenticator() func(c *gin.Context) (interface{}, error) {\n  return func(c *gin.Context) (interface{}, error) {\n    var loginVals login\n    if err := c.ShouldBind(&loginVals); err != nil {\n      return \"\", jwt.ErrMissingLoginValues\n    }\n    userID := loginVals.Username\n    password := loginVals.Password\n\n    if (userID == \"admin\" && password == \"admin\") || (userID == \"test\" && password == \"test\") {\n      return &User{\n        UserName:  userID,\n        LastName:  \"Bo-Yi\",\n        FirstName: \"Wu\",\n      }, nil\n    }\n    return nil, jwt.ErrFailedAuthentication\n  }\n}\n\nfunc authorizator() func(data interface{}, c *gin.Context) bool {\n  return func(data interface{}, c *gin.Context) bool {\n    if v, ok := data.(*User); ok && v.UserName == \"admin\" {\n      return true\n    }\n    return false\n  }\n}\n\nfunc unauthorized() func(c *gin.Context, code int, message string) {\n  return func(c *gin.Context, code int, message string) {\n    c.JSON(code, gin.H{\n      \"code\":    code,\n      \"message\": message,\n    })\n  }\n}\n\nfunc handleNoRoute() func(c *gin.Context) {\n  return func(c *gin.Context) {\n    claims := jwt.ExtractClaims(c)\n    log.Printf(\"NoRoute claims: %#v\\n\", claims)\n    c.JSON(404, gin.H{\"code\": \"PAGE_NOT_FOUND\", \"message\": \"Page not found\"})\n  }\n}\n\nfunc helloHandler(c *gin.Context) {\n  claims := jwt.ExtractClaims(c)\n  user, _ := c.Get(identityKey)\n  c.JSON(200, gin.H{\n    \"userID\":   claims[identityKey],\n    \"userName\": user.(*User).UserName,\n    \"text\":     \"Hello World.\",\n  })\n}\n\n```\n\n## Demo\n\nPlease run _example/basic/server.go file and listen `8000` port.\n\n```sh\ngo run _example/basic/server.go\n```\n\nDownload and install [httpie](https://github.com/jkbrzt/httpie) CLI HTTP client.\n\n### Login API\n\n```sh\nhttp -v --json POST localhost:8000/login username=admin password=admin\n```\n\nOutput screenshot\n\n![api screenshot](screenshot/login.png)\n\n### Refresh token API\n\n```bash\nhttp -v -f GET localhost:8000/auth/refresh_token \"Authorization:Bearer xxxxxxxxx\"  \"Content-Type: application/json\"\n```\n\nOutput screenshot\n\n![api screenshot](screenshot/refresh_token.png)\n\n### Hello world\n\nPlease login as `admin` and password as `admin`\n\n```bash\nhttp -f GET localhost:8000/auth/hello \"Authorization:Bearer xxxxxxxxx\"  \"Content-Type: application/json\"\n```\n\nResponse message `200 OK`:\n\n```sh\nHTTP/1.1 200 OK\nContent-Length: 24\nContent-Type: application/json; charset=utf-8\nDate: Sat, 19 Mar 2016 03:02:57 GMT\n\n{\n  \"text\": \"Hello World.\",\n  \"userID\": \"admin\"\n}\n```\n\n### Authorization\n\nPlease login as `test` and password as `test`\n\n```bash\nhttp -f GET localhost:8000/auth/hello \"Authorization:Bearer xxxxxxxxx\"  \"Content-Type: application/json\"\n```\n\nResponse message `403 Forbidden`:\n\n```sh\nHTTP/1.1 403 Forbidden\nContent-Length: 62\nContent-Type: application/json; charset=utf-8\nDate: Sat, 19 Mar 2016 03:05:40 GMT\nWww-Authenticate: JWT realm=test zone\n\n{\n  \"code\": 403,\n  \"message\": \"You don't have permission to access.\"\n}\n```\n\n### Cookie Token\n\nUse these options for setting the JWT in a cookie. See the Mozilla [documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Secure_and_HttpOnly_cookies) for more information on these options.\n\n```go\n  SendCookie:       true,\n  SecureCookie:     false, //non HTTPS dev environments\n  CookieHTTPOnly:   true,  // JS can't modify\n  CookieDomain:     \"localhost:8080\",\n  CookieName:       \"token\", // default jwt\n  TokenLookup:      \"cookie:token\",\n  CookieSameSite:   http.SameSiteDefaultMode, //SameSiteDefaultMode, SameSiteLaxMode, SameSiteStrictMode, SameSiteNoneMode\n```\n\n### Login request flow (using the LoginHandler)\n\nPROVIDED: `LoginHandler`\n\nThis is a provided function to be called on any login endpoint, which will trigger the flow described below.\n\nREQUIRED: `Authenticator`\n\nThis function should verify the user credentials given the gin context (i.e. password matches hashed password for a given user email, and any other authentication logic). Then the authenticator should return a struct or map that contains the user data that will be embedded in the jwt token. This might be something like an account id, role, is_verified, etc. After having successfully authenticated, the data returned from the authenticator is passed in as a parameter into the `PayloadFunc`, which is used to embed the user identifiers mentioned above into the jwt token. If an error is returned, the `Unauthorized` function is used (explained below).\n\nOPTIONAL: `PayloadFunc`\n\nThis function is called after having successfully authenticated (logged in). It should take whatever was returned from `Authenticator` and convert it into `MapClaims` (i.e. map[string]interface{}). A typical use case of this function is for when `Authenticator` returns a struct which holds the user identifiers, and that struct needs to be converted into a map. `MapClaims` should include one element that is [`IdentityKey` (default is \"identity\"): some_user_identity]. The elements of `MapClaims` returned in `PayloadFunc` will be embedded within the jwt token (as token claims). When users pass in their token on subsequent requests, you can get these claims back by using `ExtractClaims`.\n\nOPTIONAL: `LoginResponse`\n\nAfter having successfully authenticated with `Authenticator`, created the jwt token using the identifiers from map returned from `PayloadFunc`, and set it as a cookie if `SendCookie` is enabled, this function is called. It is used to handle any post-login logic. This might look something like using the gin context to return a JSON of the token back to the user.\n\n### Subsequent requests on endpoints requiring jwt token (using MiddlewareFunc)\n\nPROVIDED: `MiddlewareFunc`\n\nThis is gin middleware that should be used within any endpoints that require the jwt token to be present. This middleware will parse the request headers for the token if it exists, and check that the jwt token is valid (not expired, correct signature). Then it will call `IdentityHandler` followed by `Authorizator`. If `Authorizator` passes and all of the previous token validity checks passed, the middleware will continue the request. If any of these checks fail, the `Unauthorized` function is used (explained below).\n\nOPTIONAL: `IdentityHandler`\n\nThe default of this function is likely sufficient for your needs. The purpose of this function is to fetch the user identity from claims embedded within the jwt token, and pass this identity value to `Authorizator`. This function assumes [`IdentityKey`: some_user_identity] is one of the attributes embedded within the claims of the jwt token (determined by `PayloadFunc`).\n\nOPTIONAL: `Authorizator`\n\nGiven the user identity value (`data` parameter) and the gin context, this function should check if the user is authorized to be reaching this endpoint (on the endpoints where the `MiddlewareFunc` applies). This function should likely use `ExtractClaims` to check if the user has the sufficient permissions to reach this endpoint, as opposed to hitting the database on every request. This function should return true if the user is authorized to continue through with the request, or false if they are not authorized (where `Unauthorized` will be called).\n\n### Logout Request flow (using LogoutHandler)\n\nPROVIDED: `LogoutHandler`\n\nThis is a provided function to be called on any logout endpoint, which will clear any cookies if `SendCookie` is set, and then call `LogoutResponse`.\n\nOPTIONAL: `LogoutResponse`\n\nThis should likely just return back to the user the http status code, if logout was successful or not.\n\n### Refresh Request flow (using RefreshHandler)\n\nPROVIDED: `RefreshHandler`:\n\nThis is a provided function to be called on any refresh token endpoint. If the token passed in is was issued within the `MaxRefreshTime` time frame, then this handler will create/set a new token similar to the `LoginHandler`, and pass this token into `RefreshResponse`\n\nOPTIONAL: `RefreshResponse`:\n\nThis should likely return a JSON of the token back to the user, similar to `LoginResponse`\n\n### Failures with logging in, bad tokens, or lacking privileges\n\nOPTIONAL `Unauthorized`:\n\nOn any error logging in, authorizing the user, or when there was no token or a invalid token passed in with the request, the following will happen. The gin context will be aborted depending on `DisabledAbort`, then `HTTPStatusMessageFunc` is called which by default converts the error into a string. Finally the `Unauthorized` function will be called. This function should likely return a JSON containing the http error code and error message to the user.\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "auth_jwt.go",
          "type": "blob",
          "size": 22.5361328125,
          "content": "package jwt\n\nimport (\n\t\"crypto/rsa\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/youmark/pkcs8\"\n)\n\n// MapClaims type that uses the map[string]interface{} for JSON decoding\n// This is the default claims type if you don't supply one\ntype MapClaims map[string]interface{}\n\n// GinJWTMiddleware provides a Json-Web-Token authentication implementation. On failure, a 401 HTTP response\n// is returned. On success, the wrapped middleware is called, and the userID is made available as\n// c.Get(\"userID\").(string).\n// Users can get a token by posting a json request to LoginHandler. The token then needs to be passed in\n// the Authentication header. Example: Authorization:Bearer XXX_TOKEN_XXX\ntype GinJWTMiddleware struct {\n\t// Realm name to display to the user. Required.\n\tRealm string\n\n\t// signing algorithm - possible values are HS256, HS384, HS512, RS256, RS384 or RS512\n\t// Optional, default is HS256.\n\tSigningAlgorithm string\n\n\t// Secret key used for signing. Required.\n\tKey []byte\n\n\t// Callback to retrieve key used for signing. Setting KeyFunc will bypass\n\t// all other key settings\n\tKeyFunc func(token *jwt.Token) (interface{}, error)\n\n\t// Duration that a jwt token is valid. Optional, defaults to one hour.\n\tTimeout time.Duration\n\t// Callback function that will override the default timeout duration.\n\tTimeoutFunc func(data interface{}) time.Duration\n\n\t// This field allows clients to refresh their token until MaxRefresh has passed.\n\t// Note that clients can refresh their token in the last moment of MaxRefresh.\n\t// This means that the maximum validity timespan for a token is TokenTime + MaxRefresh.\n\t// Optional, defaults to 0 meaning not refreshable.\n\tMaxRefresh time.Duration\n\n\t// Callback function that should perform the authentication of the user based on login info.\n\t// Must return user data as user identifier, it will be stored in Claim Array. Required.\n\t// Check error (e) to determine the appropriate error message.\n\tAuthenticator func(c *gin.Context) (interface{}, error)\n\n\t// Callback function that should perform the authorization of the authenticated user. Called\n\t// only after an authentication success. Must return true on success, false on failure.\n\t// Optional, default to success.\n\tAuthorizator func(data interface{}, c *gin.Context) bool\n\n\t// Callback function that will be called during login.\n\t// Using this function it is possible to add additional payload data to the webtoken.\n\t// The data is then made available during requests via c.Get(\"JWT_PAYLOAD\").\n\t// Note that the payload is not encrypted.\n\t// The attributes mentioned on jwt.io can't be used as keys for the map.\n\t// Optional, by default no additional data will be set.\n\tPayloadFunc func(data interface{}) MapClaims\n\n\t// User can define own Unauthorized func.\n\tUnauthorized func(c *gin.Context, code int, message string)\n\n\t// User can define own LoginResponse func.\n\tLoginResponse func(c *gin.Context, code int, message string, time time.Time)\n\n\t// User can define own LogoutResponse func.\n\tLogoutResponse func(c *gin.Context, code int)\n\n\t// User can define own RefreshResponse func.\n\tRefreshResponse func(c *gin.Context, code int, message string, time time.Time)\n\n\t// Set the identity handler function\n\tIdentityHandler func(*gin.Context) interface{}\n\n\t// Set the identity key\n\tIdentityKey string\n\n\t// TokenLookup is a string in the form of \"<source>:<name>\" that is used\n\t// to extract token from the request.\n\t// Optional. Default value \"header:Authorization\".\n\t// Possible values:\n\t// - \"header:<name>\"\n\t// - \"query:<name>\"\n\t// - \"cookie:<name>\"\n\tTokenLookup string\n\n\t// TokenHeadName is a string in the header. Default value is \"Bearer\"\n\tTokenHeadName string\n\n\t// TimeFunc provides the current time. You can override it to use another time value. This is useful for testing or if your server uses a different time zone than your tokens.\n\tTimeFunc func() time.Time\n\n\t// HTTP Status messages for when something in the JWT middleware fails.\n\t// Check error (e) to determine the appropriate error message.\n\tHTTPStatusMessageFunc func(e error, c *gin.Context) string\n\n\t// Private key file for asymmetric algorithms\n\tPrivKeyFile string\n\n\t// Private Key bytes for asymmetric algorithms\n\t//\n\t// Note: PrivKeyFile takes precedence over PrivKeyBytes if both are set\n\tPrivKeyBytes []byte\n\n\t// Public key file for asymmetric algorithms\n\tPubKeyFile string\n\n\t// Private key passphrase\n\tPrivateKeyPassphrase string\n\n\t// Public key bytes for asymmetric algorithms.\n\t//\n\t// Note: PubKeyFile takes precedence over PubKeyBytes if both are set\n\tPubKeyBytes []byte\n\n\t// Private key\n\tprivKey *rsa.PrivateKey\n\n\t// Public key\n\tpubKey *rsa.PublicKey\n\n\t// Optionally return the token as a cookie\n\tSendCookie bool\n\n\t// Duration that a cookie is valid. Optional, by default equals to Timeout value.\n\tCookieMaxAge time.Duration\n\n\t// Allow insecure cookies for development over http\n\tSecureCookie bool\n\n\t// Allow cookies to be accessed client side for development\n\tCookieHTTPOnly bool\n\n\t// Allow cookie domain change for development\n\tCookieDomain string\n\n\t// SendAuthorization allow return authorization header for every request\n\tSendAuthorization bool\n\n\t// Disable abort() of context.\n\tDisabledAbort bool\n\n\t// CookieName allow cookie name change for development\n\tCookieName string\n\n\t// CookieSameSite allow use http.SameSite cookie param\n\tCookieSameSite http.SameSite\n\n\t// ParseOptions allow to modify jwt's parser methods\n\tParseOptions []jwt.ParserOption\n\n\t// Default vaule is \"exp\"\n\tExpField string\n}\n\nvar (\n\t// ErrMissingSecretKey indicates Secret key is required\n\tErrMissingSecretKey = errors.New(\"secret key is required\")\n\n\t// ErrForbidden when HTTP status 403 is given\n\tErrForbidden = errors.New(\"you don't have permission to access this resource\")\n\n\t// ErrMissingAuthenticatorFunc indicates Authenticator is required\n\tErrMissingAuthenticatorFunc = errors.New(\"ginJWTMiddleware.Authenticator func is undefined\")\n\n\t// ErrMissingLoginValues indicates a user tried to authenticate without username or password\n\tErrMissingLoginValues = errors.New(\"missing Username or Password\")\n\n\t// ErrFailedAuthentication indicates authentication failed, could be faulty username or password\n\tErrFailedAuthentication = errors.New(\"incorrect Username or Password\")\n\n\t// ErrFailedTokenCreation indicates JWT Token failed to create, reason unknown\n\tErrFailedTokenCreation = errors.New(\"failed to create JWT Token\")\n\n\t// ErrExpiredToken indicates JWT token has expired. Can't refresh.\n\tErrExpiredToken = errors.New(\"token is expired\") // in practice, this is generated from the jwt library not by us\n\n\t// ErrEmptyAuthHeader can be thrown if authing with a HTTP header, the Auth header needs to be set\n\tErrEmptyAuthHeader = errors.New(\"auth header is empty\")\n\n\t// ErrMissingExpField missing exp field in token\n\tErrMissingExpField = errors.New(\"missing exp field\")\n\n\t// ErrWrongFormatOfExp field must be float64 format\n\tErrWrongFormatOfExp = errors.New(\"exp must be float64 format\")\n\n\t// ErrInvalidAuthHeader indicates auth header is invalid, could for example have the wrong Realm name\n\tErrInvalidAuthHeader = errors.New(\"auth header is invalid\")\n\n\t// ErrEmptyQueryToken can be thrown if authing with URL Query, the query token variable is empty\n\tErrEmptyQueryToken = errors.New(\"query token is empty\")\n\n\t// ErrEmptyCookieToken can be thrown if authing with a cookie, the token cookie is empty\n\tErrEmptyCookieToken = errors.New(\"cookie token is empty\")\n\n\t// ErrEmptyParamToken can be thrown if authing with parameter in path, the parameter in path is empty\n\tErrEmptyParamToken = errors.New(\"parameter token is empty\")\n\n\t// ErrInvalidSigningAlgorithm indicates signing algorithm is invalid, needs to be HS256, HS384, HS512, RS256, RS384 or RS512\n\tErrInvalidSigningAlgorithm = errors.New(\"invalid signing algorithm\")\n\n\t// ErrNoPrivKeyFile indicates that the given private key is unreadable\n\tErrNoPrivKeyFile = errors.New(\"private key file unreadable\")\n\n\t// ErrNoPubKeyFile indicates that the given public key is unreadable\n\tErrNoPubKeyFile = errors.New(\"public key file unreadable\")\n\n\t// ErrInvalidPrivKey indicates that the given private key is invalid\n\tErrInvalidPrivKey = errors.New(\"private key invalid\")\n\n\t// ErrInvalidPubKey indicates the the given public key is invalid\n\tErrInvalidPubKey = errors.New(\"public key invalid\")\n\n\t// IdentityKey default identity key\n\tIdentityKey = \"identity\"\n)\n\n// New for check error with GinJWTMiddleware\nfunc New(m *GinJWTMiddleware) (*GinJWTMiddleware, error) {\n\tif err := m.MiddlewareInit(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn m, nil\n}\n\nfunc (mw *GinJWTMiddleware) readKeys() error {\n\terr := mw.privateKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = mw.publicKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (mw *GinJWTMiddleware) privateKey() error {\n\tvar keyData []byte\n\tvar err error\n\tif mw.PrivKeyFile == \"\" {\n\t\tkeyData = mw.PrivKeyBytes\n\t} else {\n\t\tvar filecontent []byte\n\t\tfilecontent, err = os.ReadFile(mw.PrivKeyFile)\n\t\tif err != nil {\n\t\t\treturn ErrNoPrivKeyFile\n\t\t}\n\t\tkeyData = filecontent\n\t}\n\n\tif mw.PrivateKeyPassphrase != \"\" {\n\t\tvar key interface{}\n\t\tkey, err = pkcs8.ParsePKCS8PrivateKey(keyData, []byte(mw.PrivateKeyPassphrase))\n\t\tif err != nil {\n\t\t\treturn ErrInvalidPrivKey\n\t\t}\n\t\trsaKey, ok := key.(*rsa.PrivateKey)\n\t\tif !ok {\n\t\t\treturn ErrInvalidPrivKey\n\t\t}\n\t\tmw.privKey = rsaKey\n\t\treturn nil\n\t}\n\n\tvar key *rsa.PrivateKey\n\tkey, err = jwt.ParseRSAPrivateKeyFromPEM(keyData)\n\tif err != nil {\n\t\treturn ErrInvalidPrivKey\n\t}\n\tmw.privKey = key\n\treturn nil\n}\n\nfunc (mw *GinJWTMiddleware) publicKey() error {\n\tvar keyData []byte\n\tif mw.PubKeyFile == \"\" {\n\t\tkeyData = mw.PubKeyBytes\n\t} else {\n\t\tfilecontent, err := os.ReadFile(mw.PubKeyFile)\n\t\tif err != nil {\n\t\t\treturn ErrNoPubKeyFile\n\t\t}\n\t\tkeyData = filecontent\n\t}\n\n\tkey, err := jwt.ParseRSAPublicKeyFromPEM(keyData)\n\tif err != nil {\n\t\treturn ErrInvalidPubKey\n\t}\n\tmw.pubKey = key\n\treturn nil\n}\n\nfunc (mw *GinJWTMiddleware) usingPublicKeyAlgo() bool {\n\tswitch mw.SigningAlgorithm {\n\tcase \"RS256\", \"RS512\", \"RS384\":\n\t\treturn true\n\t}\n\treturn false\n}\n\n// MiddlewareInit initialize jwt configs.\nfunc (mw *GinJWTMiddleware) MiddlewareInit() error {\n\tif mw.TokenLookup == \"\" {\n\t\tmw.TokenLookup = \"header:Authorization\"\n\t}\n\n\tif mw.SigningAlgorithm == \"\" {\n\t\tmw.SigningAlgorithm = \"HS256\"\n\t}\n\n\tif mw.Timeout == 0 {\n\t\tmw.Timeout = time.Hour\n\t}\n\n\tif mw.TimeoutFunc == nil {\n\t\tmw.TimeoutFunc = func(data interface{}) time.Duration {\n\t\t\treturn mw.Timeout\n\t\t}\n\t}\n\n\tif mw.TimeFunc == nil {\n\t\tmw.TimeFunc = time.Now\n\t}\n\n\tmw.TokenHeadName = strings.TrimSpace(mw.TokenHeadName)\n\tif len(mw.TokenHeadName) == 0 {\n\t\tmw.TokenHeadName = \"Bearer\"\n\t}\n\n\tif mw.Authorizator == nil {\n\t\tmw.Authorizator = func(data interface{}, c *gin.Context) bool {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif mw.Unauthorized == nil {\n\t\tmw.Unauthorized = func(c *gin.Context, code int, message string) {\n\t\t\tc.JSON(code, gin.H{\n\t\t\t\t\"code\":    code,\n\t\t\t\t\"message\": message,\n\t\t\t})\n\t\t}\n\t}\n\n\tif mw.LoginResponse == nil {\n\t\tmw.LoginResponse = func(c *gin.Context, code int, token string, expire time.Time) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":   http.StatusOK,\n\t\t\t\t\"token\":  token,\n\t\t\t\t\"expire\": expire.Format(time.RFC3339),\n\t\t\t})\n\t\t}\n\t}\n\n\tif mw.LogoutResponse == nil {\n\t\tmw.LogoutResponse = func(c *gin.Context, code int) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\": http.StatusOK,\n\t\t\t})\n\t\t}\n\t}\n\n\tif mw.RefreshResponse == nil {\n\t\tmw.RefreshResponse = func(c *gin.Context, code int, token string, expire time.Time) {\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":   http.StatusOK,\n\t\t\t\t\"token\":  token,\n\t\t\t\t\"expire\": expire.Format(time.RFC3339),\n\t\t\t})\n\t\t}\n\t}\n\n\tif mw.IdentityKey == \"\" {\n\t\tmw.IdentityKey = IdentityKey\n\t}\n\n\tif mw.IdentityHandler == nil {\n\t\tmw.IdentityHandler = func(c *gin.Context) interface{} {\n\t\t\tclaims := ExtractClaims(c)\n\t\t\treturn claims[mw.IdentityKey]\n\t\t}\n\t}\n\n\tif mw.HTTPStatusMessageFunc == nil {\n\t\tmw.HTTPStatusMessageFunc = func(e error, c *gin.Context) string {\n\t\t\treturn e.Error()\n\t\t}\n\t}\n\n\tif mw.Realm == \"\" {\n\t\tmw.Realm = \"gin jwt\"\n\t}\n\n\tif mw.CookieMaxAge == 0 {\n\t\tmw.CookieMaxAge = mw.Timeout\n\t}\n\n\tif mw.CookieName == \"\" {\n\t\tmw.CookieName = \"jwt\"\n\t}\n\n\tif mw.ExpField == \"\" {\n\t\tmw.ExpField = \"exp\"\n\t}\n\n\t// bypass other key settings if KeyFunc is set\n\tif mw.KeyFunc != nil {\n\t\treturn nil\n\t}\n\n\tif mw.usingPublicKeyAlgo() {\n\t\treturn mw.readKeys()\n\t}\n\n\tif mw.Key == nil {\n\t\treturn ErrMissingSecretKey\n\t}\n\n\treturn nil\n}\n\n// MiddlewareFunc makes GinJWTMiddleware implement the Middleware interface.\nfunc (mw *GinJWTMiddleware) MiddlewareFunc() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\tmw.middlewareImpl(c)\n\t}\n}\n\nfunc (mw *GinJWTMiddleware) middlewareImpl(c *gin.Context) {\n\tclaims, err := mw.GetClaimsFromJWT(c)\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(err, c))\n\t\treturn\n\t}\n\n\tswitch v := claims[mw.ExpField].(type) {\n\tcase nil:\n\t\tmw.unauthorized(c, http.StatusBadRequest, mw.HTTPStatusMessageFunc(ErrMissingExpField, c))\n\t\treturn\n\tcase float64:\n\t\tif int64(v) < mw.TimeFunc().Unix() {\n\t\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(ErrExpiredToken, c))\n\t\t\treturn\n\t\t}\n\tcase json.Number:\n\t\tn, err := v.Int64()\n\t\tif err != nil {\n\t\t\tmw.unauthorized(c, http.StatusBadRequest, mw.HTTPStatusMessageFunc(ErrWrongFormatOfExp, c))\n\t\t\treturn\n\t\t}\n\t\tif n < mw.TimeFunc().Unix() {\n\t\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(ErrExpiredToken, c))\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\tmw.unauthorized(c, http.StatusBadRequest, mw.HTTPStatusMessageFunc(ErrWrongFormatOfExp, c))\n\t\treturn\n\t}\n\n\tc.Set(\"JWT_PAYLOAD\", claims)\n\tidentity := mw.IdentityHandler(c)\n\n\tif identity != nil {\n\t\tc.Set(mw.IdentityKey, identity)\n\t}\n\n\tif !mw.Authorizator(identity, c) {\n\t\tmw.unauthorized(c, http.StatusForbidden, mw.HTTPStatusMessageFunc(ErrForbidden, c))\n\t\treturn\n\t}\n\n\tc.Next()\n}\n\n// GetClaimsFromJWT get claims from JWT token\nfunc (mw *GinJWTMiddleware) GetClaimsFromJWT(c *gin.Context) (MapClaims, error) {\n\ttoken, err := mw.ParseToken(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif mw.SendAuthorization {\n\t\tif v, ok := c.Get(\"JWT_TOKEN\"); ok {\n\t\t\tc.Header(\"Authorization\", mw.TokenHeadName+\" \"+v.(string))\n\t\t}\n\t}\n\n\tclaims := MapClaims{}\n\tfor key, value := range token.Claims.(jwt.MapClaims) {\n\t\tclaims[key] = value\n\t}\n\n\treturn claims, nil\n}\n\n// LoginHandler can be used by clients to get a jwt token.\n// Payload needs to be json in the form of {\"username\": \"USERNAME\", \"password\": \"PASSWORD\"}.\n// Reply will be of the form {\"token\": \"TOKEN\"}.\nfunc (mw *GinJWTMiddleware) LoginHandler(c *gin.Context) {\n\tif mw.Authenticator == nil {\n\t\tmw.unauthorized(c, http.StatusInternalServerError, mw.HTTPStatusMessageFunc(ErrMissingAuthenticatorFunc, c))\n\t\treturn\n\t}\n\n\tdata, err := mw.Authenticator(c)\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(err, c))\n\t\treturn\n\t}\n\n\t// Create the token\n\ttoken := jwt.New(jwt.GetSigningMethod(mw.SigningAlgorithm))\n\tclaims := token.Claims.(jwt.MapClaims)\n\n\tif mw.PayloadFunc != nil {\n\t\tfor key, value := range mw.PayloadFunc(data) {\n\t\t\tclaims[key] = value\n\t\t}\n\t}\n\n\texpire := mw.TimeFunc().Add(mw.TimeoutFunc(claims))\n\tclaims[mw.ExpField] = expire.Unix()\n\tclaims[\"orig_iat\"] = mw.TimeFunc().Unix()\n\ttokenString, err := mw.signedString(token)\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(ErrFailedTokenCreation, c))\n\t\treturn\n\t}\n\n\tmw.SetCookie(c, tokenString)\n\n\tmw.LoginResponse(c, http.StatusOK, tokenString, expire)\n}\n\n// LogoutHandler can be used by clients to remove the jwt cookie (if set)\nfunc (mw *GinJWTMiddleware) LogoutHandler(c *gin.Context) {\n\t// delete auth cookie\n\tif mw.SendCookie {\n\t\tif mw.CookieSameSite != 0 {\n\t\t\tc.SetSameSite(mw.CookieSameSite)\n\t\t}\n\n\t\tc.SetCookie(\n\t\t\tmw.CookieName,\n\t\t\t\"\",\n\t\t\t-1,\n\t\t\t\"/\",\n\t\t\tmw.CookieDomain,\n\t\t\tmw.SecureCookie,\n\t\t\tmw.CookieHTTPOnly,\n\t\t)\n\t}\n\n\tmw.LogoutResponse(c, http.StatusOK)\n}\n\nfunc (mw *GinJWTMiddleware) signedString(token *jwt.Token) (string, error) {\n\tvar tokenString string\n\tvar err error\n\tif mw.usingPublicKeyAlgo() {\n\t\ttokenString, err = token.SignedString(mw.privKey)\n\t} else {\n\t\ttokenString, err = token.SignedString(mw.Key)\n\t}\n\treturn tokenString, err\n}\n\n// RefreshHandler can be used to refresh a token. The token still needs to be valid on refresh.\n// Shall be put under an endpoint that is using the GinJWTMiddleware.\n// Reply will be of the form {\"token\": \"TOKEN\"}.\nfunc (mw *GinJWTMiddleware) RefreshHandler(c *gin.Context) {\n\ttokenString, expire, err := mw.RefreshToken(c)\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(err, c))\n\t\treturn\n\t}\n\n\tmw.RefreshResponse(c, http.StatusOK, tokenString, expire)\n}\n\n// RefreshToken refresh token and check if token is expired\nfunc (mw *GinJWTMiddleware) RefreshToken(c *gin.Context) (string, time.Time, error) {\n\tclaims, err := mw.CheckIfTokenExpire(c)\n\tif err != nil {\n\t\treturn \"\", time.Now(), err\n\t}\n\n\t// Create the token\n\tnewToken := jwt.New(jwt.GetSigningMethod(mw.SigningAlgorithm))\n\tnewClaims := newToken.Claims.(jwt.MapClaims)\n\n\tfor key := range claims {\n\t\tnewClaims[key] = claims[key]\n\t}\n\n\texpire := mw.TimeFunc().Add(mw.TimeoutFunc(claims))\n\tnewClaims[mw.ExpField] = expire.Unix()\n\tnewClaims[\"orig_iat\"] = mw.TimeFunc().Unix()\n\ttokenString, err := mw.signedString(newToken)\n\tif err != nil {\n\t\treturn \"\", time.Now(), err\n\t}\n\n\tmw.SetCookie(c, tokenString)\n\n\treturn tokenString, expire, nil\n}\n\n// CheckIfTokenExpire check if token expire\nfunc (mw *GinJWTMiddleware) CheckIfTokenExpire(c *gin.Context) (jwt.MapClaims, error) {\n\ttoken, err := mw.ParseToken(c)\n\tif err != nil {\n\t\t// If we receive an error, and the error is anything other than a single\n\t\t// ValidationErrorExpired, we want to return the error.\n\t\t// If the error is just ValidationErrorExpired, we want to continue, as we can still\n\t\t// refresh the token if it's within the MaxRefresh time.\n\t\t// (see https://github.com/appleboy/gin-jwt/issues/176)\n\t\tvalidationErr, ok := err.(*jwt.ValidationError)\n\t\tif !ok || validationErr.Errors != jwt.ValidationErrorExpired {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tclaims := token.Claims.(jwt.MapClaims)\n\n\torigIat := int64(claims[\"orig_iat\"].(float64))\n\n\tif origIat < mw.TimeFunc().Add(-mw.MaxRefresh).Unix() {\n\t\treturn nil, ErrExpiredToken\n\t}\n\n\treturn claims, nil\n}\n\n// TokenGenerator method that clients can use to get a jwt token.\nfunc (mw *GinJWTMiddleware) TokenGenerator(data interface{}) (string, time.Time, error) {\n\ttoken := jwt.New(jwt.GetSigningMethod(mw.SigningAlgorithm))\n\tclaims := token.Claims.(jwt.MapClaims)\n\n\tif mw.PayloadFunc != nil {\n\t\tfor key, value := range mw.PayloadFunc(data) {\n\t\t\tclaims[key] = value\n\t\t}\n\t}\n\n\texpire := mw.TimeFunc().Add(mw.TimeoutFunc(claims))\n\tclaims[mw.ExpField] = expire.Unix()\n\tclaims[\"orig_iat\"] = mw.TimeFunc().Unix()\n\ttokenString, err := mw.signedString(token)\n\tif err != nil {\n\t\treturn \"\", time.Time{}, err\n\t}\n\n\treturn tokenString, expire, nil\n}\n\nfunc (mw *GinJWTMiddleware) jwtFromHeader(c *gin.Context, key string) (string, error) {\n\tauthHeader := c.Request.Header.Get(key)\n\n\tif authHeader == \"\" {\n\t\treturn \"\", ErrEmptyAuthHeader\n\t}\n\n\tparts := strings.SplitN(authHeader, \" \", 2)\n\tif !(len(parts) == 2 && parts[0] == mw.TokenHeadName) {\n\t\treturn \"\", ErrInvalidAuthHeader\n\t}\n\n\treturn parts[1], nil\n}\n\nfunc (mw *GinJWTMiddleware) jwtFromQuery(c *gin.Context, key string) (string, error) {\n\ttoken := c.Query(key)\n\n\tif token == \"\" {\n\t\treturn \"\", ErrEmptyQueryToken\n\t}\n\n\treturn token, nil\n}\n\nfunc (mw *GinJWTMiddleware) jwtFromCookie(c *gin.Context, key string) (string, error) {\n\tcookie, _ := c.Cookie(key)\n\n\tif cookie == \"\" {\n\t\treturn \"\", ErrEmptyCookieToken\n\t}\n\n\treturn cookie, nil\n}\n\nfunc (mw *GinJWTMiddleware) jwtFromParam(c *gin.Context, key string) (string, error) {\n\ttoken := c.Param(key)\n\n\tif token == \"\" {\n\t\treturn \"\", ErrEmptyParamToken\n\t}\n\n\treturn token, nil\n}\n\nfunc (mw *GinJWTMiddleware) jwtFromForm(c *gin.Context, key string) (string, error) {\n\ttoken := c.PostForm(key)\n\n\tif token == \"\" {\n\t\treturn \"\", ErrEmptyParamToken\n\t}\n\n\treturn token, nil\n}\n\n// ParseToken parse jwt token from gin context\nfunc (mw *GinJWTMiddleware) ParseToken(c *gin.Context) (*jwt.Token, error) {\n\tvar token string\n\tvar err error\n\n\tmethods := strings.Split(mw.TokenLookup, \",\")\n\tfor _, method := range methods {\n\t\tif len(token) > 0 {\n\t\t\tbreak\n\t\t}\n\t\tparts := strings.Split(strings.TrimSpace(method), \":\")\n\t\tk := strings.TrimSpace(parts[0])\n\t\tv := strings.TrimSpace(parts[1])\n\t\tswitch k {\n\t\tcase \"header\":\n\t\t\ttoken, err = mw.jwtFromHeader(c, v)\n\t\tcase \"query\":\n\t\t\ttoken, err = mw.jwtFromQuery(c, v)\n\t\tcase \"cookie\":\n\t\t\ttoken, err = mw.jwtFromCookie(c, v)\n\t\tcase \"param\":\n\t\t\ttoken, err = mw.jwtFromParam(c, v)\n\t\tcase \"form\":\n\t\t\ttoken, err = mw.jwtFromForm(c, v)\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif mw.KeyFunc != nil {\n\t\treturn jwt.Parse(token, mw.KeyFunc, mw.ParseOptions...)\n\t}\n\n\treturn jwt.Parse(token, func(t *jwt.Token) (interface{}, error) {\n\t\tif jwt.GetSigningMethod(mw.SigningAlgorithm) != t.Method {\n\t\t\treturn nil, ErrInvalidSigningAlgorithm\n\t\t}\n\t\tif mw.usingPublicKeyAlgo() {\n\t\t\treturn mw.pubKey, nil\n\t\t}\n\n\t\t// save token string if valid\n\t\tc.Set(\"JWT_TOKEN\", token)\n\n\t\treturn mw.Key, nil\n\t}, mw.ParseOptions...)\n}\n\n// ParseTokenString parse jwt token string\nfunc (mw *GinJWTMiddleware) ParseTokenString(token string) (*jwt.Token, error) {\n\tif mw.KeyFunc != nil {\n\t\treturn jwt.Parse(token, mw.KeyFunc, mw.ParseOptions...)\n\t}\n\n\treturn jwt.Parse(token, func(t *jwt.Token) (interface{}, error) {\n\t\tif jwt.GetSigningMethod(mw.SigningAlgorithm) != t.Method {\n\t\t\treturn nil, ErrInvalidSigningAlgorithm\n\t\t}\n\t\tif mw.usingPublicKeyAlgo() {\n\t\t\treturn mw.pubKey, nil\n\t\t}\n\n\t\treturn mw.Key, nil\n\t}, mw.ParseOptions...)\n}\n\nfunc (mw *GinJWTMiddleware) unauthorized(c *gin.Context, code int, message string) {\n\tc.Header(\"WWW-Authenticate\", \"JWT realm=\"+mw.Realm)\n\tif !mw.DisabledAbort {\n\t\tc.Abort()\n\t}\n\n\tmw.Unauthorized(c, code, message)\n}\n\n// ExtractClaims help to extract the JWT claims\nfunc ExtractClaims(c *gin.Context) MapClaims {\n\tclaims, exists := c.Get(\"JWT_PAYLOAD\")\n\tif !exists {\n\t\treturn make(MapClaims)\n\t}\n\n\treturn claims.(MapClaims)\n}\n\n// ExtractClaimsFromToken help to extract the JWT claims from token\nfunc ExtractClaimsFromToken(token *jwt.Token) MapClaims {\n\tif token == nil {\n\t\treturn make(MapClaims)\n\t}\n\n\tclaims := MapClaims{}\n\tfor key, value := range token.Claims.(jwt.MapClaims) {\n\t\tclaims[key] = value\n\t}\n\n\treturn claims\n}\n\n// GetToken help to get the JWT token string\nfunc GetToken(c *gin.Context) string {\n\ttoken, exists := c.Get(\"JWT_TOKEN\")\n\tif !exists {\n\t\treturn \"\"\n\t}\n\n\treturn token.(string)\n}\n\n// SetCookie help to set the token in the cookie\nfunc (mw *GinJWTMiddleware) SetCookie(c *gin.Context, token string) {\n\t// set cookie\n\tif mw.SendCookie {\n\t\texpireCookie := mw.TimeFunc().Add(mw.CookieMaxAge)\n\t\tmaxage := int(expireCookie.Unix() - mw.TimeFunc().Unix())\n\n\t\tif mw.CookieSameSite != 0 {\n\t\t\tc.SetSameSite(mw.CookieSameSite)\n\t\t}\n\n\t\tc.SetCookie(\n\t\t\tmw.CookieName,\n\t\t\ttoken,\n\t\t\tmaxage,\n\t\t\t\"/\",\n\t\t\tmw.CookieDomain,\n\t\t\tmw.SecureCookie,\n\t\t\tmw.CookieHTTPOnly,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "auth_jwt_test.go",
          "type": "blob",
          "size": 34.806640625,
          "content": "package jwt\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/appleboy/gofight/v2\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/tidwall/gjson\"\n)\n\n// Login form structure.\ntype Login struct {\n\tUsername string `form:\"username\" json:\"username\" binding:\"required\"`\n\tPassword string `form:\"password\" json:\"password\" binding:\"required\"`\n}\n\nvar (\n\tkey                  = []byte(\"secret key\")\n\tdefaultAuthenticator = func(c *gin.Context) (interface{}, error) {\n\t\tvar loginVals Login\n\t\tuserID := loginVals.Username\n\t\tpassword := loginVals.Password\n\n\t\tif userID == \"admin\" && password == \"admin\" {\n\t\t\treturn userID, nil\n\t\t}\n\n\t\treturn userID, ErrFailedAuthentication\n\t}\n)\n\nfunc makeTokenString(SigningAlgorithm string, username string) string {\n\tif SigningAlgorithm == \"\" {\n\t\tSigningAlgorithm = \"HS256\"\n\t}\n\n\ttoken := jwt.New(jwt.GetSigningMethod(SigningAlgorithm))\n\tclaims := token.Claims.(jwt.MapClaims)\n\tclaims[\"identity\"] = username\n\tclaims[\"exp\"] = time.Now().Add(time.Hour).Unix()\n\tclaims[\"orig_iat\"] = time.Now().Unix()\n\tvar tokenString string\n\tif SigningAlgorithm == \"RS256\" {\n\t\tkeyData, _ := os.ReadFile(\"testdata/jwtRS256.key\")\n\t\tsignKey, _ := jwt.ParseRSAPrivateKeyFromPEM(keyData)\n\t\ttokenString, _ = token.SignedString(signKey)\n\t} else {\n\t\ttokenString, _ = token.SignedString(key)\n\t}\n\n\treturn tokenString\n}\n\nfunc keyFunc(token *jwt.Token) (interface{}, error) {\n\tcert, err := os.ReadFile(\"testdata/jwtRS256.key.pub\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn jwt.ParseRSAPublicKeyFromPEM(cert)\n}\n\nfunc TestMissingKey(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrMissingSecretKey, err)\n}\n\nfunc TestMissingPrivKey(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:            \"zone\",\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"nonexisting\",\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrNoPrivKeyFile, err)\n}\n\nfunc TestMissingPubKey(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:            \"zone\",\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"testdata/jwtRS256.key\",\n\t\tPubKeyFile:       \"nonexisting\",\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrNoPubKeyFile, err)\n}\n\nfunc TestInvalidPrivKey(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:            \"zone\",\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"testdata/invalidprivkey.key\",\n\t\tPubKeyFile:       \"testdata/jwtRS256.key.pub\",\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrInvalidPrivKey, err)\n}\n\nfunc TestInvalidPrivKeyBytes(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:            \"zone\",\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyBytes:     []byte(\"Invalid_Private_Key\"),\n\t\tPubKeyFile:       \"testdata/jwtRS256.key.pub\",\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrInvalidPrivKey, err)\n}\n\nfunc TestInvalidPubKey(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:            \"zone\",\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"testdata/jwtRS256.key\",\n\t\tPubKeyFile:       \"testdata/invalidpubkey.key\",\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrInvalidPubKey, err)\n}\n\nfunc TestInvalidPubKeyBytes(t *testing.T) {\n\t_, err := New(&GinJWTMiddleware{\n\t\tRealm:            \"zone\",\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"testdata/jwtRS256.key\",\n\t\tPubKeyBytes:      []byte(\"Invalid_Private_Key\"),\n\t})\n\n\tassert.Error(t, err)\n\tassert.Equal(t, ErrInvalidPubKey, err)\n}\n\nfunc TestMissingTimeOut(t *testing.T) {\n\tauthMiddleware, err := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, time.Hour, authMiddleware.Timeout)\n}\n\nfunc TestMissingTokenLookup(t *testing.T) {\n\tauthMiddleware, err := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"header:Authorization\", authMiddleware.TokenLookup)\n}\n\nfunc helloHandler(c *gin.Context) {\n\tc.JSON(200, gin.H{\n\t\t\"text\":  \"Hello World.\",\n\t\t\"token\": GetToken(c),\n\t})\n}\n\nfunc ginHandler(auth *GinJWTMiddleware) *gin.Engine {\n\tgin.SetMode(gin.TestMode)\n\tr := gin.New()\n\n\tr.POST(\"/login\", auth.LoginHandler)\n\tr.POST(\"/logout\", auth.LogoutHandler)\n\t// test token in path\n\tr.GET(\"/g/:token/refresh_token\", auth.RefreshHandler)\n\n\tgroup := r.Group(\"/auth\")\n\t// Refresh time can be longer than token timeout\n\tgroup.GET(\"/refresh_token\", auth.RefreshHandler)\n\tgroup.Use(auth.MiddlewareFunc())\n\t{\n\t\tgroup.GET(\"/hello\", helloHandler)\n\t}\n\n\treturn r\n}\n\nfunc TestMissingAuthenticatorForLoginHandler(t *testing.T) {\n\tauthMiddleware, err := New(&GinJWTMiddleware{\n\t\tRealm:      \"test zone\",\n\t\tKey:        key,\n\t\tTimeout:    time.Hour,\n\t\tMaxRefresh: time.Hour * 24,\n\t})\n\n\tassert.NoError(t, err)\n\n\thandler := ginHandler(authMiddleware)\n\tr := gofight.New()\n\n\tr.POST(\"/login\").\n\t\tSetJSON(gofight.D{\n\t\t\t\"username\": \"admin\",\n\t\t\t\"password\": \"admin\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\n\t\t\tassert.Equal(t, ErrMissingAuthenticatorFunc.Error(), message.String())\n\t\t\tassert.Equal(t, http.StatusInternalServerError, r.Code)\n\t\t})\n}\n\nfunc TestLoginHandler(t *testing.T) {\n\t// the middleware to test\n\tcookieName := \"jwt\"\n\tcookieDomain := \"example.com\"\n\tauthMiddleware, err := New(&GinJWTMiddleware{\n\t\tRealm: \"test zone\",\n\t\tKey:   key,\n\t\tPayloadFunc: func(data interface{}) MapClaims {\n\t\t\t// Set custom claim, to be checked in Authorizator method\n\t\t\treturn MapClaims{\"testkey\": \"testval\", \"exp\": 0}\n\t\t},\n\t\tAuthenticator: func(c *gin.Context) (interface{}, error) {\n\t\t\tvar loginVals Login\n\t\t\tif binderr := c.ShouldBind(&loginVals); binderr != nil {\n\t\t\t\treturn \"\", ErrMissingLoginValues\n\t\t\t}\n\t\t\tuserID := loginVals.Username\n\t\t\tpassword := loginVals.Password\n\t\t\tif userID == \"admin\" && password == \"admin\" {\n\t\t\t\treturn userID, nil\n\t\t\t}\n\t\t\treturn \"\", ErrFailedAuthentication\n\t\t},\n\t\tAuthorizator: func(user interface{}, c *gin.Context) bool {\n\t\t\treturn true\n\t\t},\n\t\tLoginResponse: func(c *gin.Context, code int, token string, t time.Time) {\n\t\t\tcookie, err := c.Cookie(\"jwt\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":    http.StatusOK,\n\t\t\t\t\"token\":   token,\n\t\t\t\t\"expire\":  t.Format(time.RFC3339),\n\t\t\t\t\"message\": \"login successfully\",\n\t\t\t\t\"cookie\":  cookie,\n\t\t\t})\n\t\t},\n\t\tSendCookie:   true,\n\t\tCookieName:   cookieName,\n\t\tCookieDomain: cookieDomain,\n\t\tTimeFunc:     func() time.Time { return time.Now().Add(time.Duration(5) * time.Minute) },\n\t})\n\n\tassert.NoError(t, err)\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.POST(\"/login\").\n\t\tSetJSON(gofight.D{\n\t\t\t\"username\": \"admin\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\n\t\t\tassert.Equal(t, ErrMissingLoginValues.Error(), message.String())\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t\t//nolint:staticcheck\n\t\t\tassert.Equal(t, \"application/json; charset=utf-8\", r.HeaderMap.Get(\"Content-Type\"))\n\t\t})\n\n\tr.POST(\"/login\").\n\t\tSetJSON(gofight.D{\n\t\t\t\"username\": \"admin\",\n\t\t\t\"password\": \"test\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\t\t\tassert.Equal(t, ErrFailedAuthentication.Error(), message.String())\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.POST(\"/login\").\n\t\tSetJSON(gofight.D{\n\t\t\t\"username\": \"admin\",\n\t\t\t\"password\": \"admin\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\t\t\tassert.Equal(t, \"login successfully\", message.String())\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t\t//nolint:staticcheck\n\t\t\tassert.True(t, strings.HasPrefix(r.HeaderMap.Get(\"Set-Cookie\"), \"jwt=\"))\n\t\t\t//nolint:staticcheck\n\t\t\tassert.True(t, strings.HasSuffix(r.HeaderMap.Get(\"Set-Cookie\"), \"; Path=/; Domain=example.com; Max-Age=3600\"))\n\t\t})\n}\n\nfunc TestParseToken(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Test 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS384\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestParseTokenRS256(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:            \"test zone\",\n\t\tKey:              key,\n\t\tTimeout:          time.Hour,\n\t\tMaxRefresh:       time.Hour * 24,\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"testdata/jwtRS256.key\",\n\t\tPubKeyFile:       \"testdata/jwtRS256.key.pub\",\n\t\tAuthenticator:    defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Test 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS384\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"RS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestParseTokenKeyFunc(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKeyFunc:       keyFunc,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t\t// make sure it skips these settings\n\t\tKey:              []byte(\"\"),\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"\",\n\t\tPubKeyFile:       \"\",\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Test 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS384\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"RS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestRefreshHandlerRS256(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:            \"test zone\",\n\t\tKey:              key,\n\t\tTimeout:          time.Hour,\n\t\tMaxRefresh:       time.Hour * 24,\n\t\tSigningAlgorithm: \"RS256\",\n\t\tPrivKeyFile:      \"testdata/jwtRS256.key\",\n\t\tPubKeyFile:       \"testdata/jwtRS256.key.pub\",\n\t\tSendCookie:       true,\n\t\tCookieName:       \"jwt\",\n\t\tAuthenticator:    defaultAuthenticator,\n\t\tRefreshResponse: func(c *gin.Context, code int, token string, t time.Time) {\n\t\t\tcookie, err := c.Cookie(\"jwt\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t}\n\n\t\t\tc.JSON(http.StatusOK, gin.H{\n\t\t\t\t\"code\":    http.StatusOK,\n\t\t\t\t\"token\":   token,\n\t\t\t\t\"expire\":  t.Format(time.RFC3339),\n\t\t\t\t\"message\": \"refresh successfully\",\n\t\t\t\t\"cookie\":  cookie,\n\t\t\t})\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Test 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"RS256\", \"admin\"),\n\t\t}).\n\t\tSetCookie(gofight.H{\n\t\t\t\"jwt\": makeTokenString(\"RS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\t\t\tcookie := gjson.Get(r.Body.String(), \"cookie\")\n\t\t\tassert.Equal(t, \"refresh successfully\", message.String())\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t\tassert.Equal(t, makeTokenString(\"RS256\", \"admin\"), cookie.String())\n\t\t})\n}\n\nfunc TestRefreshHandler(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Test 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestExpiredTokenWithinMaxRefreshOnRefreshHandler(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    2 * time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\ttoken := jwt.New(jwt.GetSigningMethod(\"HS256\"))\n\tclaims := token.Claims.(jwt.MapClaims)\n\tclaims[\"identity\"] = \"admin\"\n\tclaims[\"exp\"] = time.Now().Add(-time.Minute).Unix()\n\tclaims[\"orig_iat\"] = time.Now().Add(-time.Hour).Unix()\n\ttokenString, _ := token.SignedString(key)\n\n\t// We should be able to refresh a token that has expired but is within the MaxRefresh time\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + tokenString,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestExpiredTokenOnRefreshHandler(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\ttoken := jwt.New(jwt.GetSigningMethod(\"HS256\"))\n\tclaims := token.Claims.(jwt.MapClaims)\n\tclaims[\"identity\"] = \"admin\"\n\tclaims[\"exp\"] = time.Now().Add(time.Hour).Unix()\n\tclaims[\"orig_iat\"] = 0\n\ttokenString, _ := token.SignedString(key)\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + tokenString,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n}\n\nfunc TestAuthorizator(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tAuthorizator: func(data interface{}, c *gin.Context) bool {\n\t\t\treturn data.(string) == \"admin\"\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"test\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusForbidden, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestParseTokenWithJsonNumber(t *testing.T) {\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t\tParseOptions: []jwt.ParserOption{jwt.WithJSONNumber()},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestClaimsDuringAuthorization(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:      \"test zone\",\n\t\tKey:        key,\n\t\tTimeout:    time.Hour,\n\t\tMaxRefresh: time.Hour * 24,\n\t\tPayloadFunc: func(data interface{}) MapClaims {\n\t\t\tif v, ok := data.(MapClaims); ok {\n\t\t\t\treturn v\n\t\t\t}\n\n\t\t\tif reflect.TypeOf(data).String() != \"string\" {\n\t\t\t\treturn MapClaims{}\n\t\t\t}\n\n\t\t\tvar testkey string\n\t\t\tswitch data.(string) {\n\t\t\tcase \"admin\":\n\t\t\t\ttestkey = \"1234\"\n\t\t\tcase \"test\":\n\t\t\t\ttestkey = \"5678\"\n\t\t\tcase \"Guest\":\n\t\t\t\ttestkey = \"\"\n\t\t\t}\n\t\t\t// Set custom claim, to be checked in Authorizator method\n\t\t\treturn MapClaims{\"identity\": data.(string), \"testkey\": testkey, \"exp\": 0}\n\t\t},\n\t\tAuthenticator: func(c *gin.Context) (interface{}, error) {\n\t\t\tvar loginVals Login\n\n\t\t\tif err := c.BindJSON(&loginVals); err != nil {\n\t\t\t\treturn \"\", ErrMissingLoginValues\n\t\t\t}\n\n\t\t\tuserID := loginVals.Username\n\t\t\tpassword := loginVals.Password\n\n\t\t\tif userID == \"admin\" && password == \"admin\" {\n\t\t\t\treturn userID, nil\n\t\t\t}\n\n\t\t\tif userID == \"test\" && password == \"test\" {\n\t\t\t\treturn userID, nil\n\t\t\t}\n\n\t\t\treturn \"Guest\", ErrFailedAuthentication\n\t\t},\n\t\tAuthorizator: func(user interface{}, c *gin.Context) bool {\n\t\t\tjwtClaims := ExtractClaims(c)\n\n\t\t\tif jwtClaims[\"identity\"] == \"administrator\" {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tif jwtClaims[\"testkey\"] == \"1234\" && jwtClaims[\"identity\"] == \"admin\" {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tif jwtClaims[\"testkey\"] == \"5678\" && jwtClaims[\"identity\"] == \"test\" {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\treturn false\n\t\t},\n\t})\n\n\tr := gofight.New()\n\thandler := ginHandler(authMiddleware)\n\n\tuserToken, _, _ := authMiddleware.TokenGenerator(MapClaims{\n\t\t\"identity\": \"administrator\",\n\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n\n\tr.POST(\"/login\").\n\t\tSetJSON(gofight.D{\n\t\t\t\"username\": \"admin\",\n\t\t\t\"password\": \"admin\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\ttoken := gjson.Get(r.Body.String(), \"token\")\n\t\t\tuserToken = token.String()\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n\n\tr.POST(\"/login\").\n\t\tSetJSON(gofight.D{\n\t\t\t\"username\": \"test\",\n\t\t\t\"password\": \"test\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\ttoken := gjson.Get(r.Body.String(), \"token\")\n\t\t\tuserToken = token.String()\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc ConvertClaims(claims MapClaims) map[string]interface{} {\n\treturn map[string]interface{}{}\n}\n\nfunc TestEmptyClaims(t *testing.T) {\n\tvar jwtClaims MapClaims\n\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:      \"test zone\",\n\t\tKey:        key,\n\t\tTimeout:    time.Hour,\n\t\tMaxRefresh: time.Hour * 24,\n\t\tAuthenticator: func(c *gin.Context) (interface{}, error) {\n\t\t\tvar loginVals Login\n\t\t\tuserID := loginVals.Username\n\t\t\tpassword := loginVals.Password\n\n\t\t\tif userID == \"admin\" && password == \"admin\" {\n\t\t\t\treturn \"\", nil\n\t\t\t}\n\n\t\t\tif userID == \"test\" && password == \"test\" {\n\t\t\t\treturn \"Administrator\", nil\n\t\t\t}\n\n\t\t\treturn userID, ErrFailedAuthentication\n\t\t},\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tassert.Empty(t, ExtractClaims(c))\n\t\t\tassert.Empty(t, ConvertClaims(ExtractClaims(c)))\n\t\t\tc.String(code, message)\n\t\t},\n\t})\n\n\tr := gofight.New()\n\thandler := ginHandler(authMiddleware)\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tassert.Empty(t, jwtClaims)\n}\n\nfunc TestUnauthorized(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer 1234\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n}\n\nfunc TestTokenExpire(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    -time.Second,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tuserToken, _, _ := authMiddleware.TokenGenerator(MapClaims{\n\t\t\"identity\": \"admin\",\n\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n}\n\nfunc TestTokenFromQueryString(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t\tTokenLookup: \"query:token\",\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tuserToken, _, _ := authMiddleware.TokenGenerator(MapClaims{\n\t\t\"identity\": \"admin\",\n\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/refresh_token?token=\"+userToken).\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestTokenFromParamPath(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t\tTokenLookup: \"param:token\",\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tuserToken, _, _ := authMiddleware.TokenGenerator(MapClaims{\n\t\t\"identity\": \"admin\",\n\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/g/\"+userToken+\"/refresh_token\").\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestTokenFromCookieString(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t\tTokenLookup: \"cookie:token\",\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tuserToken, _, _ := authMiddleware.TokenGenerator(MapClaims{\n\t\t\"identity\": \"admin\",\n\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\ttoken := gjson.Get(r.Body.String(), \"token\")\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t\tassert.Equal(t, \"\", token.String())\n\t\t})\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetCookie(gofight.H{\n\t\t\t\"token\": userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetCookie(gofight.H{\n\t\t\t\"token\": userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\ttoken := gjson.Get(r.Body.String(), \"token\")\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t\tassert.Equal(t, userToken, token.String())\n\t\t})\n}\n\nfunc TestDefineTokenHeadName(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tTokenHeadName: \"JWTTOKEN       \",\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"JWTTOKEN \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestHTTPStatusMessageFunc(t *testing.T) {\n\tsuccessError := errors.New(\"Successful test error\")\n\tfailedError := errors.New(\"Failed test error\")\n\tsuccessMessage := \"Overwrite error message.\"\n\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tMaxRefresh:    time.Hour * 24,\n\t\tAuthenticator: defaultAuthenticator,\n\n\t\tHTTPStatusMessageFunc: func(e error, c *gin.Context) string {\n\t\t\tif e == successError {\n\t\t\t\treturn successMessage\n\t\t\t}\n\n\t\t\treturn e.Error()\n\t\t},\n\t})\n\n\tsuccessString := authMiddleware.HTTPStatusMessageFunc(successError, nil)\n\tfailedString := authMiddleware.HTTPStatusMessageFunc(failedError, nil)\n\n\tassert.Equal(t, successMessage, successString)\n\tassert.NotEqual(t, successMessage, failedString)\n}\n\nfunc TestSendAuthorizationBool(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:             \"test zone\",\n\t\tKey:               key,\n\t\tTimeout:           time.Hour,\n\t\tMaxRefresh:        time.Hour * 24,\n\t\tAuthenticator:     defaultAuthenticator,\n\t\tSendAuthorization: true,\n\t\tAuthorizator: func(data interface{}, c *gin.Context) bool {\n\t\t\treturn data.(string) == \"admin\"\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"test\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusForbidden, r.Code)\n\t\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\t//nolint:staticcheck\n\t\t\ttoken := r.HeaderMap.Get(\"Authorization\")\n\t\t\tassert.Equal(t, \"Bearer \"+makeTokenString(\"HS256\", \"admin\"), token)\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n}\n\nfunc TestExpiredTokenOnAuth(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:             \"test zone\",\n\t\tKey:               key,\n\t\tTimeout:           time.Hour,\n\t\tMaxRefresh:        time.Hour * 24,\n\t\tAuthenticator:     defaultAuthenticator,\n\t\tSendAuthorization: true,\n\t\tAuthorizator: func(data interface{}, c *gin.Context) bool {\n\t\t\treturn data.(string) == \"admin\"\n\t\t},\n\t\tTimeFunc: func() time.Time {\n\t\t\treturn time.Now().AddDate(0, 0, 1)\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + makeTokenString(\"HS256\", \"admin\"),\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n}\n\nfunc TestBadTokenOnRefreshHandler(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.GET(\"/auth/refresh_token\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + \"BadToken\",\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n}\n\nfunc TestExpiredField(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\ttoken := jwt.New(jwt.GetSigningMethod(\"HS256\"))\n\tclaims := token.Claims.(jwt.MapClaims)\n\tclaims[\"identity\"] = \"admin\"\n\tclaims[\"orig_iat\"] = 0\n\ttokenString, _ := token.SignedString(key)\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + tokenString,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\n\t\t\tassert.Equal(t, ErrMissingExpField.Error(), message.String())\n\t\t\tassert.Equal(t, http.StatusBadRequest, r.Code)\n\t\t})\n\n\t// wrong format\n\tclaims[\"exp\"] = \"wrongFormatForExpiryIgnoredByJwtLibrary\"\n\ttokenString, _ = token.SignedString(key)\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + tokenString,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tmessage := gjson.Get(r.Body.String(), \"message\")\n\n\t\t\tassert.Equal(t, ErrExpiredToken.Error(), strings.ToLower(message.String()))\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n}\n\nfunc TestCheckTokenString(t *testing.T) {\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       1 * time.Second,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tc.String(code, message)\n\t\t},\n\t\tPayloadFunc: func(data interface{}) MapClaims {\n\t\t\tif v, ok := data.(MapClaims); ok {\n\t\t\t\treturn v\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tuserToken, _, _ := authMiddleware.TokenGenerator(MapClaims{\n\t\t\"identity\": \"admin\",\n\t})\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t})\n\n\ttoken, err := authMiddleware.ParseTokenString(userToken)\n\tassert.NoError(t, err)\n\tclaims := ExtractClaimsFromToken(token)\n\tassert.Equal(t, \"admin\", claims[\"identity\"])\n\n\ttime.Sleep(2 * time.Second)\n\n\tr.GET(\"/auth/hello\").\n\t\tSetHeader(gofight.H{\n\t\t\t\"Authorization\": \"Bearer \" + userToken,\n\t\t}).\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusUnauthorized, r.Code)\n\t\t})\n\n\t_, err = authMiddleware.ParseTokenString(userToken)\n\tassert.Error(t, err)\n\tassert.Equal(t, MapClaims{}, ExtractClaimsFromToken(nil))\n}\n\nfunc TestLogout(t *testing.T) {\n\tcookieName := \"jwt\"\n\tcookieDomain := \"example.com\"\n\t// the middleware to test\n\tauthMiddleware, _ := New(&GinJWTMiddleware{\n\t\tRealm:         \"test zone\",\n\t\tKey:           key,\n\t\tTimeout:       time.Hour,\n\t\tAuthenticator: defaultAuthenticator,\n\t\tSendCookie:    true,\n\t\tCookieName:    cookieName,\n\t\tCookieDomain:  cookieDomain,\n\t})\n\n\thandler := ginHandler(authMiddleware)\n\n\tr := gofight.New()\n\n\tr.POST(\"/logout\").\n\t\tRun(handler, func(r gofight.HTTPResponse, rq gofight.HTTPRequest) {\n\t\t\tassert.Equal(t, http.StatusOK, r.Code)\n\t\t\t//nolint:staticcheck\n\t\t\tassert.Equal(t, fmt.Sprintf(\"%s=; Path=/; Domain=%s; Max-Age=0\", cookieName, cookieDomain), r.HeaderMap.Get(\"Set-Cookie\"))\n\t\t})\n}\n\nfunc TestSetCookie(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := gin.CreateTestContext(w)\n\n\tmw, _ := New(&GinJWTMiddleware{\n\t\tRealm:          \"test zone\",\n\t\tKey:            key,\n\t\tTimeout:        time.Hour,\n\t\tAuthenticator:  defaultAuthenticator,\n\t\tSendCookie:     true,\n\t\tCookieName:     \"jwt\",\n\t\tCookieMaxAge:   time.Hour,\n\t\tCookieDomain:   \"example.com\",\n\t\tSecureCookie:   false,\n\t\tCookieHTTPOnly: true,\n\t\tTimeFunc: func() time.Time {\n\t\t\treturn time.Now()\n\t\t},\n\t})\n\n\ttoken := makeTokenString(\"HS384\", \"admin\")\n\n\tmw.SetCookie(c, token)\n\n\tcookies := w.Result().Cookies()\n\n\tassert.Len(t, cookies, 1)\n\n\tcookie := cookies[0]\n\tassert.Equal(t, \"jwt\", cookie.Name)\n\tassert.Equal(t, token, cookie.Value)\n\tassert.Equal(t, \"/\", cookie.Path)\n\tassert.Equal(t, \"example.com\", cookie.Domain)\n\tassert.Equal(t, true, cookie.HttpOnly)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.90625,
          "content": "module github.com/appleboy/gin-jwt/v2\n\ngo 1.21.0\n\nrequire (\n\tgithub.com/appleboy/gofight/v2 v2.1.2\n\tgithub.com/gin-gonic/gin v1.10.0\n\tgithub.com/golang-jwt/jwt/v4 v4.5.1\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/tidwall/gjson v1.17.1\n\tgithub.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78\n)\n\nrequire (\n\tgithub.com/bytedance/sonic v1.12.6 // indirect\n\tgithub.com/bytedance/sonic/loader v0.2.1 // indirect\n\tgithub.com/cloudwego/base64x v0.1.4 // indirect\n\tgithub.com/cloudwego/iasm v0.2.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/gabriel-vasile/mimetype v1.4.7 // indirect\n\tgithub.com/gin-contrib/sse v0.1.0 // indirect\n\tgithub.com/go-playground/locales v0.14.1 // indirect\n\tgithub.com/go-playground/universal-translator v0.18.1 // indirect\n\tgithub.com/go-playground/validator/v10 v10.23.0 // indirect\n\tgithub.com/goccy/go-json v0.10.4 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.9 // indirect\n\tgithub.com/kr/pretty v0.3.0 // indirect\n\tgithub.com/leodido/go-urn v1.4.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.2.3 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rogpeppe/go-internal v1.8.0 // indirect\n\tgithub.com/tidwall/match v1.1.1 // indirect\n\tgithub.com/tidwall/pretty v1.2.0 // indirect\n\tgithub.com/twitchyliquid64/golang-asm v0.15.1 // indirect\n\tgithub.com/ugorji/go/codec v1.2.12 // indirect\n\tgolang.org/x/arch v0.12.0 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgoogle.golang.org/protobuf v1.36.1 // indirect\n\tgopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 9.8603515625,
          "content": "github.com/appleboy/gofight/v2 v2.1.2 h1:VOy3jow4vIK8BRQJoC/I9muxyYlJ2yb9ht2hZoS3rf4=\ngithub.com/appleboy/gofight/v2 v2.1.2/go.mod h1:frW+U1QZEdDgixycTj4CygQ48yLTUhplt43+Wczp3rw=\ngithub.com/bytedance/sonic v1.12.6 h1:/isNmCUF2x3Sh8RAp/4mh4ZGkcFAX/hLrzrK3AvpRzk=\ngithub.com/bytedance/sonic v1.12.6/go.mod h1:B8Gt/XvtZ3Fqj+iSKMypzymZxw/FVwgIGKzMzT9r/rk=\ngithub.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/bytedance/sonic/loader v0.2.1 h1:1GgorWTqf12TA8mma4DDSbaQigE2wOgQo7iCjjJv3+E=\ngithub.com/bytedance/sonic/loader v0.2.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=\ngithub.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=\ngithub.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=\ngithub.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gabriel-vasile/mimetype v1.4.7 h1:SKFKl7kD0RiPdbht0s7hFtjl489WcQ1VyPW8ZzUMYCA=\ngithub.com/gabriel-vasile/mimetype v1.4.7/go.mod h1:GDlAgAyIRT27BhFl53XNAFtfjzOkLaF35JdEG0P7LtU=\ngithub.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=\ngithub.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.23.0 h1:/PwmTwZhS0dPkav3cdK9kV1FsAmrL8sThn8IHr/sO+o=\ngithub.com/go-playground/validator/v10 v10.23.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=\ngithub.com/goccy/go-json v0.10.4 h1:JSwxQzIqKfmFX1swYPpUThQZp/Ka4wzJdK0LWVytLPM=\ngithub.com/goccy/go-json v0.10.4/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=\ngithub.com/golang-jwt/jwt/v4 v4.5.1 h1:JdqV9zKUdtaa9gdPlywC3aeoEsR681PlKC+4F5gQgeo=\ngithub.com/golang-jwt/jwt/v4 v4.5.1/go.mod h1:m21LjoU+eqJr34lmDMbreY2eSTRJ1cv77w39/MY0Ch0=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/klauspost/cpuid/v2 v2.2.9 h1:66ze0taIn2H33fBvCkXuv9BmCwDfafmiIVpKV9kKGuY=\ngithub.com/klauspost/cpuid/v2 v2.2.9/go.mod h1:rqkxqrZ1EhYM9G+hXH7YdowN5R5RGN6NK4QwQ3WMXF8=\ngithub.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=\ngithub.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngithub.com/rogpeppe/go-internal v1.8.0 h1:FCbCCtXNOY3UtUuHUYaghJg4y7Fd14rXifAYUAtL9R8=\ngithub.com/rogpeppe/go-internal v1.8.0/go.mod h1:WmiCO8CzOY8rg0OYDC4/i/2WRWAB6poM+XZ2dLUbcbE=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/tidwall/gjson v1.17.1 h1:wlYEnwqAHgzmhNUFfw7Xalt2JzQvsMx2Se4PcoFCT/U=\ngithub.com/tidwall/gjson v1.17.1/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=\ngithub.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=\ngithub.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=\ngithub.com/tidwall/pretty v1.2.0 h1:RWIZEg2iJ8/g6fDDYzMpobmaoGh5OLl4AXtGUGPcqCs=\ngithub.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=\ngithub.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=\ngithub.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=\ngithub.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=\ngithub.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=\ngithub.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78 h1:ilQV1hzziu+LLM3zUTJ0trRztfwgjqKnBWNtSRkbmwM=\ngithub.com/youmark/pkcs8 v0.0.0-20240726163527-a2c0da244d78/go.mod h1:aL8wCCfTfSfmXjznFBSZNN13rSJjlIOI1fUNAtF7rmI=\ngolang.org/x/arch v0.12.0 h1:UsYJhbzPYGsT0HbEdmYcqtCv8UNGvnaL561NnIUvaKg=\ngolang.org/x/arch v0.12.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=\ngoogle.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nnullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=\n"
        },
        {
          "name": "screenshot",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}