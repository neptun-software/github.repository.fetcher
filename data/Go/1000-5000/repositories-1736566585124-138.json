{
  "metadata": {
    "timestamp": 1736566585124,
    "page": 138,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uber-go/ratelimit",
      "stars": 4386,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0849609375,
          "content": "/bin\n/vendor\ncover.html\ncover.out\nprofile.out\nstat.csv\nstat.txt\nstat.html\n\n*.swp\n.idea\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.1484375,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](http://keepachangelog.com/en/1.0.0/)\nand this project adheres to [Semantic Versioning](http://semver.org/spec/v2.0.0.html).\n\n## Unreleased\n-  No changes yet.\n\n## v0.3.1 - 2024-03-04\n### Fixed\n- Fixed a bug related to maxSlack boundary detection. #124\n  Thanks to @smallnest for reporting and @storozhukBM for fixing.\n\n## v0.3.0 - 2023-07-08\n### Changed\n- Switched to a more efficient internal implementation. No API or behavior changes.\n  [#100](https://github.com/uber-go/ratelimit/pull/100)\n\n## v0.2.0 - 2021-03-02\n### Added\n- Allow configuring the limiter with custom slack.\n  [#64](https://github.com/uber-go/ratelimit/pull/64)\n- Allow configuring the limiter per arbitrary time duration.\n  [#54](https://github.com/uber-go/ratelimit/pull/54)\n### Changed\n- Switched from Glide to Go Modules.\n### Fixed\n- Fix not working slack.\n  [#60](https://github.com/uber-go/ratelimit/pull/60)\n\n## v0.1.0\n### Fixed\n- Changed the import path for `go.uber.org/atomic` to its newer, canonical\n  import path.\n  [#18](https://github.com/uber-go/ratelimit/issues/18)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0634765625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.4033203125,
          "content": "# Directory to put `go install`ed binaries in.\nexport GOBIN ?= $(shell pwd)/bin\n\nGO_FILES := $(shell \\\n\tfind . '(' -path '*/.*' -o -path './vendor' ')' -prune \\\n\t-o -name '*.go' -print | cut -b3-)\n\n.PHONY: bench\nbench: bin/benchstat bin/benchart\n\tgo test -timeout 3h -count=5 -run=xxx -bench=BenchmarkRateLimiter ./... | tee stat.txt\n\t@$(GOBIN)/benchstat stat.txt\n\t@$(GOBIN)/benchstat -csv stat.txt > stat.csv\n\t@$(GOBIN)/benchart 'RateLimiter;xAxisType=log' stat.csv stat.html\n\t@open stat.html\n\nbin/benchstat: tools/go.mod\n\t@cd tools && go install golang.org/x/perf/cmd/benchstat\n\nbin/benchart: tools/go.mod\n\t@cd tools && go install github.com/storozhukBM/benchart\n\nbin/golint: tools/go.mod\n\t@cd tools && go install golang.org/x/lint/golint\n\nbin/staticcheck: tools/go.mod\n\t@cd tools && go install honnef.co/go/tools/cmd/staticcheck\n\n.PHONY: build\nbuild:\n\tgo build ./...\n\n.PHONY: cover\ncover:\n\tgo test -coverprofile=cover.out -coverpkg=./... -v ./...\n\tgo tool cover -html=cover.out -o cover.html\n\n.PHONY: gofmt\ngofmt:\n\t$(eval FMT_LOG := $(shell mktemp -t gofmt.XXXXX))\n\t@gofmt -e -s -l $(GO_FILES) > $(FMT_LOG) || true\n\t@[ ! -s \"$(FMT_LOG)\" ] || (echo \"gofmt failed:\" | cat - $(FMT_LOG) && false)\n\n.PHONY: golint\ngolint: bin/golint\n\t@$(GOBIN)/golint -set_exit_status ./...\n\n.PHONY: lint\nlint: gofmt golint staticcheck\n\n.PHONY: staticcheck\nstaticcheck: bin/staticcheck\n\t@$(GOBIN)/staticcheck ./...\n\n.PHONY: test\ntest:\n\tgo test -race ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.955078125,
          "content": "# Go rate limiter [![GoDoc][doc-img]][doc] [![Coverage Status][cov-img]][cov] ![test][test-img]\n\nThis package provides a Golang implementation of the leaky-bucket rate limit algorithm.\nThis implementation refills the bucket based on the time elapsed between\nrequests instead of requiring an interval clock to fill the bucket discretely.\n\nCreate a rate limiter with a maximum number of operations to perform per second.\nCall Take() before each operation. Take will sleep until you can continue.\n\n```go\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.uber.org/ratelimit\"\n)\n\nfunc main() {\n    rl := ratelimit.New(100) // per second\n\n    prev := time.Now()\n    for i := 0; i < 10; i++ {\n        now := rl.Take()\n        fmt.Println(i, now.Sub(prev))\n        prev = now\n    }\n\n    // Output:\n    // 0 0\n    // 1 10ms\n    // 2 10ms\n    // 3 10ms\n    // 4 10ms\n    // 5 10ms\n    // 6 10ms\n    // 7 10ms\n    // 8 10ms\n    // 9 10ms\n}\n```\n\n## FAQ:\n- What's the major diff v.s. https://pkg.go.dev/golang.org/x/time/rate? (based on #77)\n\n  This ratelimiter was meant to have a (1) simple API and (2) minimal overhead. For more complex use-cases [x/time/rate] is a great choice.  See [here][redit] for historical context, and [here][bench] for benchmarks (from 2016).\n\n- Why does example_test.go fail when I run it locally on Windows? (based on #80)\n\n  Windows has some known issues with timers precision. See golang/go#44343. We don't expect to work around it.\n\n[cov-img]: https://codecov.io/gh/uber-go/ratelimit/branch/master/graph/badge.svg?token=zhLeUjjrm2\n[cov]: https://codecov.io/gh/uber-go/ratelimit\n[doc-img]: https://pkg.go.dev/badge/go.uber.org/ratelimit\n[doc]: https://pkg.go.dev/go.uber.org/ratelimit\n[test-img]: https://github.com/uber-go/ratelimit/workflows/test/badge.svg\n[redit]: https://www.reddit.com/r/golang/comments/59k2bi/ubergoratelimit_a_golang_blocking_leakybucket/d99ob9q\n[x/time/rate]: https://pkg.go.dev/golang.org/x/time/rate\n[bench]: https://gist.github.com/prashantv/26016a7dbc6fc1ec52d8c2b6591f3582\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.818359375,
          "content": "package ratelimit_test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.uber.org/ratelimit\"\n)\n\nfunc Example_default() {\n\trl := ratelimit.New(100) // per second, some slack.\n\n\trl.Take()                         // Initialize.\n\ttime.Sleep(time.Millisecond * 45) // Let some time pass.\n\n\tprev := time.Now()\n\tfor i := 0; i < 10; i++ {\n\t\tnow := rl.Take()\n\t\tif i > 0 {\n\t\t\tfmt.Println(i, now.Sub(prev).Round(time.Millisecond*2))\n\t\t}\n\t\tprev = now\n\t}\n\n\t// Output:\n\t// 1 0s\n\t// 2 0s\n\t// 3 0s\n\t// 4 4ms\n\t// 5 10ms\n\t// 6 10ms\n\t// 7 10ms\n\t// 8 10ms\n\t// 9 10ms\n}\n\nfunc Example_withoutSlack() {\n\trl := ratelimit.New(100, ratelimit.WithoutSlack) // per second, no slack.\n\n\tprev := time.Now()\n\tfor i := 0; i < 6; i++ {\n\t\tnow := rl.Take()\n\t\tif i > 0 {\n\t\t\tfmt.Println(i, now.Sub(prev))\n\t\t}\n\t\tprev = now\n\t}\n\n\t// Output:\n\t// 1 10ms\n\t// 2 10ms\n\t// 3 10ms\n\t// 4 10ms\n\t// 5 10ms\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.318359375,
          "content": "module go.uber.org/ratelimit\n\ngo 1.20\n\nrequire (\n\tgithub.com/benbjohnson/clock v1.3.0\n\tgithub.com/stretchr/testify v1.6.1\n\tgo.uber.org/atomic v1.7.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.4970703125,
          "content": "github.com/benbjohnson/clock v1.3.0 h1:ip6w0uFQkncKQ979AypyG0ER7mqUSBdKLOgAle/AT8A=\ngithub.com/benbjohnson/clock v1.3.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngo.uber.org/atomic v1.7.0 h1:ADUqmZGgLDDfbSL9ZmPxKTybcoEYHgpYfELNoN+7hsw=\ngo.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "limiter_atomic.go",
          "type": "blob",
          "size": 3.6552734375,
          "content": "// Copyright (c) 2016,2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ratelimit // import \"go.uber.org/ratelimit\"\n\nimport (\n\t\"time\"\n\n\t\"sync/atomic\"\n\t\"unsafe\"\n)\n\ntype state struct {\n\tlast     time.Time\n\tsleepFor time.Duration\n}\n\ntype atomicLimiter struct {\n\tstate unsafe.Pointer\n\t//lint:ignore U1000 Padding is unused but it is crucial to maintain performance\n\t// of this rate limiter in case of collocation with other frequently accessed memory.\n\tpadding [56]byte // cache line size - state pointer size = 64 - 8; created to avoid false sharing.\n\n\tperRequest time.Duration\n\tmaxSlack   time.Duration\n\tclock      Clock\n}\n\n// newAtomicBased returns a new atomic based limiter.\nfunc newAtomicBased(rate int, opts ...Option) *atomicLimiter {\n\t// TODO consider moving config building to the implementation\n\t// independent code.\n\tconfig := buildConfig(opts)\n\tperRequest := config.per / time.Duration(rate)\n\tl := &atomicLimiter{\n\t\tperRequest: perRequest,\n\t\tmaxSlack:   -1 * time.Duration(config.slack) * perRequest,\n\t\tclock:      config.clock,\n\t}\n\n\tinitialState := state{\n\t\tlast:     time.Time{},\n\t\tsleepFor: 0,\n\t}\n\tatomic.StorePointer(&l.state, unsafe.Pointer(&initialState))\n\treturn l\n}\n\n// Take blocks to ensure that the time spent between multiple\n// Take calls is on average per/rate.\nfunc (t *atomicLimiter) Take() time.Time {\n\tvar (\n\t\tnewState state\n\t\ttaken    bool\n\t\tinterval time.Duration\n\t)\n\tfor !taken {\n\t\tnow := t.clock.Now()\n\n\t\tpreviousStatePointer := atomic.LoadPointer(&t.state)\n\t\toldState := (*state)(previousStatePointer)\n\n\t\tnewState = state{\n\t\t\tlast:     now,\n\t\t\tsleepFor: oldState.sleepFor,\n\t\t}\n\n\t\t// If this is our first request, then we allow it.\n\t\tif oldState.last.IsZero() {\n\t\t\ttaken = atomic.CompareAndSwapPointer(&t.state, previousStatePointer, unsafe.Pointer(&newState))\n\t\t\tcontinue\n\t\t}\n\n\t\t// sleepFor calculates how much time we should sleep based on\n\t\t// the perRequest budget and how long the last request took.\n\t\t// Since the request may take longer than the budget, this number\n\t\t// can get negative, and is summed across requests.\n\t\tnewState.sleepFor += t.perRequest - now.Sub(oldState.last)\n\t\t// We shouldn't allow sleepFor to get too negative, since it would mean that\n\t\t// a service that slowed down a lot for a short period of time would get\n\t\t// a much higher RPS following that.\n\t\tif newState.sleepFor < t.maxSlack {\n\t\t\tnewState.sleepFor = t.maxSlack\n\t\t}\n\t\tif newState.sleepFor > 0 {\n\t\t\tnewState.last = newState.last.Add(newState.sleepFor)\n\t\t\tinterval, newState.sleepFor = newState.sleepFor, 0\n\t\t}\n\t\ttaken = atomic.CompareAndSwapPointer(&t.state, previousStatePointer, unsafe.Pointer(&newState))\n\t}\n\tt.clock.Sleep(interval)\n\treturn newState.last\n}\n"
        },
        {
          "name": "limiter_atomic_int64.go",
          "type": "blob",
          "size": 3.55078125,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ratelimit // import \"go.uber.org/ratelimit\"\n\nimport (\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype atomicInt64Limiter struct {\n\t//lint:ignore U1000 Padding is unused but it is crucial to maintain performance\n\t// of this rate limiter in case of collocation with other frequently accessed memory.\n\tprepadding [64]byte // cache line size = 64; created to avoid false sharing.\n\tstate      int64    // unix nanoseconds of the next permissions issue.\n\t//lint:ignore U1000 like prepadding.\n\tpostpadding [56]byte // cache line size - state size = 64 - 8; created to avoid false sharing.\n\n\tperRequest time.Duration\n\tmaxSlack   time.Duration\n\tclock      Clock\n}\n\n// newAtomicBased returns a new atomic based limiter.\nfunc newAtomicInt64Based(rate int, opts ...Option) *atomicInt64Limiter {\n\t// TODO consider moving config building to the implementation\n\t// independent code.\n\tconfig := buildConfig(opts)\n\tperRequest := config.per / time.Duration(rate)\n\tl := &atomicInt64Limiter{\n\t\tperRequest: perRequest,\n\t\tmaxSlack:   time.Duration(config.slack) * perRequest,\n\t\tclock:      config.clock,\n\t}\n\tatomic.StoreInt64(&l.state, 0)\n\treturn l\n}\n\n// Take blocks to ensure that the time spent between multiple\n// Take calls is on average time.Second/rate.\nfunc (t *atomicInt64Limiter) Take() time.Time {\n\tvar (\n\t\tnewTimeOfNextPermissionIssue int64\n\t\tnow                          int64\n\t)\n\tfor {\n\t\tnow = t.clock.Now().UnixNano()\n\t\ttimeOfNextPermissionIssue := atomic.LoadInt64(&t.state)\n\n\t\tswitch {\n\t\tcase timeOfNextPermissionIssue == 0 || (t.maxSlack == 0 && now-timeOfNextPermissionIssue > int64(t.perRequest)):\n\t\t\t// if this is our first call or t.maxSlack == 0 we need to shrink issue time to now\n\t\t\tnewTimeOfNextPermissionIssue = now\n\t\tcase t.maxSlack > 0 && now-timeOfNextPermissionIssue > int64(t.maxSlack)+int64(t.perRequest):\n\t\t\t// a lot of nanoseconds passed since the last Take call\n\t\t\t// we will limit max accumulated time to maxSlack\n\t\t\tnewTimeOfNextPermissionIssue = now - int64(t.maxSlack)\n\t\tdefault:\n\t\t\t// calculate the time at which our permission was issued\n\t\t\tnewTimeOfNextPermissionIssue = timeOfNextPermissionIssue + int64(t.perRequest)\n\t\t}\n\n\t\tif atomic.CompareAndSwapInt64(&t.state, timeOfNextPermissionIssue, newTimeOfNextPermissionIssue) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tsleepDuration := time.Duration(newTimeOfNextPermissionIssue - now)\n\tif sleepDuration > 0 {\n\t\tt.clock.Sleep(sleepDuration)\n\t\treturn time.Unix(0, newTimeOfNextPermissionIssue)\n\t}\n\t// return now if we don't sleep as atomicLimiter does\n\treturn time.Unix(0, now)\n}\n"
        },
        {
          "name": "limiter_mutexbased.go",
          "type": "blob",
          "size": 2.771484375,
          "content": "// Copyright (c) 2016,2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ratelimit // import \"go.uber.org/ratelimit\"\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype mutexLimiter struct {\n\tsync.Mutex\n\tlast       time.Time\n\tsleepFor   time.Duration\n\tperRequest time.Duration\n\tmaxSlack   time.Duration\n\tclock      Clock\n}\n\n// newMutexBased returns a new mutex based limiter.\nfunc newMutexBased(rate int, opts ...Option) *mutexLimiter {\n\t// TODO consider moving config building to the implementation\n\t// independent code.\n\tconfig := buildConfig(opts)\n\tperRequest := config.per / time.Duration(rate)\n\tl := &mutexLimiter{\n\t\tperRequest: perRequest,\n\t\tmaxSlack:   -1 * time.Duration(config.slack) * perRequest,\n\t\tclock:      config.clock,\n\t}\n\treturn l\n}\n\n// Take blocks to ensure that the time spent between multiple\n// Take calls is on average per/rate.\nfunc (t *mutexLimiter) Take() time.Time {\n\tt.Lock()\n\tdefer t.Unlock()\n\n\tnow := t.clock.Now()\n\n\t// If this is our first request, then we allow it.\n\tif t.last.IsZero() {\n\t\tt.last = now\n\t\treturn t.last\n\t}\n\n\t// sleepFor calculates how much time we should sleep based on\n\t// the perRequest budget and how long the last request took.\n\t// Since the request may take longer than the budget, this number\n\t// can get negative, and is summed across requests.\n\tt.sleepFor += t.perRequest - now.Sub(t.last)\n\n\t// We shouldn't allow sleepFor to get too negative, since it would mean that\n\t// a service that slowed down a lot for a short period of time would get\n\t// a much higher RPS following that.\n\tif t.sleepFor < t.maxSlack {\n\t\tt.sleepFor = t.maxSlack\n\t}\n\n\t// If sleepFor is positive, then we should sleep now.\n\tif t.sleepFor > 0 {\n\t\tt.clock.Sleep(t.sleepFor)\n\t\tt.last = now.Add(t.sleepFor)\n\t\tt.sleepFor = 0\n\t} else {\n\t\tt.last = now\n\t}\n\n\treturn t.last\n}\n"
        },
        {
          "name": "ratelimit.go",
          "type": "blob",
          "size": 3.6953125,
          "content": "// Copyright (c) 2016,2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ratelimit // import \"go.uber.org/ratelimit\"\n\nimport (\n\t\"time\"\n\n\t\"github.com/benbjohnson/clock\"\n)\n\n// Note: This file is inspired by:\n// https://github.com/prashantv/go-bench/blob/master/ratelimit\n\n// Limiter is used to rate-limit some process, possibly across goroutines.\n// The process is expected to call Take() before every iteration, which\n// may block to throttle the goroutine.\ntype Limiter interface {\n\t// Take should block to make sure that the RPS is met.\n\tTake() time.Time\n}\n\n// Clock is the minimum necessary interface to instantiate a rate limiter with\n// a clock or mock clock, compatible with clocks created using\n// github.com/andres-erbsen/clock.\ntype Clock interface {\n\tNow() time.Time\n\tSleep(time.Duration)\n}\n\n// config configures a limiter.\ntype config struct {\n\tclock Clock\n\tslack int\n\tper   time.Duration\n}\n\n// New returns a Limiter that will limit to the given RPS.\nfunc New(rate int, opts ...Option) Limiter {\n\treturn newAtomicInt64Based(rate, opts...)\n}\n\n// buildConfig combines defaults with options.\nfunc buildConfig(opts []Option) config {\n\tc := config{\n\t\tclock: clock.New(),\n\t\tslack: 10,\n\t\tper:   time.Second,\n\t}\n\n\tfor _, opt := range opts {\n\t\topt.apply(&c)\n\t}\n\treturn c\n}\n\n// Option configures a Limiter.\ntype Option interface {\n\tapply(*config)\n}\n\ntype clockOption struct {\n\tclock Clock\n}\n\nfunc (o clockOption) apply(c *config) {\n\tc.clock = o.clock\n}\n\n// WithClock returns an option for ratelimit.New that provides an alternate\n// Clock implementation, typically a mock Clock for testing.\nfunc WithClock(clock Clock) Option {\n\treturn clockOption{clock: clock}\n}\n\ntype slackOption int\n\nfunc (o slackOption) apply(c *config) {\n\tc.slack = int(o)\n}\n\n// WithoutSlack configures the limiter to be strict and not to accumulate\n// previously \"unspent\" requests for future bursts of traffic.\nvar WithoutSlack Option = slackOption(0)\n\n// WithSlack configures custom slack.\n// Slack allows the limiter to accumulate \"unspent\" requests\n// for future bursts of traffic.\nfunc WithSlack(slack int) Option {\n\treturn slackOption(slack)\n}\n\ntype perOption time.Duration\n\nfunc (p perOption) apply(c *config) {\n\tc.per = time.Duration(p)\n}\n\n// Per allows configuring limits for different time windows.\n//\n// The default window is one second, so New(100) produces a one hundred per\n// second (100 Hz) rate limiter.\n//\n// New(2, Per(60*time.Second)) creates a 2 per minute rate limiter.\nfunc Per(per time.Duration) Option {\n\treturn perOption(per)\n}\n\ntype unlimited struct{}\n\n// NewUnlimited returns a RateLimiter that is not limited.\nfunc NewUnlimited() Limiter {\n\treturn unlimited{}\n}\n\nfunc (unlimited) Take() time.Time {\n\treturn time.Now()\n}\n"
        },
        {
          "name": "ratelimit_bench_test.go",
          "type": "blob",
          "size": 2.0244140625,
          "content": "package ratelimit\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"go.uber.org/atomic\"\n)\n\nfunc BenchmarkRateLimiter(b *testing.B) {\n\tcount := atomic.NewInt64(0)\n\tfor _, procs := range []int{1, 4, 8, 16} {\n\t\truntime.GOMAXPROCS(procs)\n\t\tfor name, limiter := range map[string]Limiter{\n\t\t\t\"atomic\":       newAtomicBased(b.N * 1000000000000),\n\t\t\t\"atomic_int64\": newAtomicInt64Based(b.N * 1000000000000),\n\t\t\t\"mutex\":        newMutexBased(b.N * 1000000000000),\n\t\t} {\n\t\t\tfor ng := 1; ng < 16; ng++ {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 16; ng < 128; ng += 8 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 128; ng < 512; ng += 16 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 512; ng < 1024; ng += 32 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 1024; ng < 2048; ng += 64 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 2048; ng < 4096; ng += 128 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 4096; ng < 16384; ng += 512 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t\tfor ng := 16384; ng < 65536; ng += 2048 {\n\t\t\t\trunner(b, name, procs, ng, limiter, count)\n\t\t\t}\n\t\t}\n\t}\n\tfmt.Printf(\"\\nmark%d\\n\", count.Load())\n}\n\nfunc runner(b *testing.B, name string, procs int, ng int, limiter Limiter, count *atomic.Int64) bool {\n\treturn b.Run(fmt.Sprintf(\"type:%s;max_procs:%d;goroutines:%d\", name, procs, ng), func(b *testing.B) {\n\t\tb.ReportAllocs()\n\n\t\tvar wg sync.WaitGroup\n\t\ttrigger := atomic.NewBool(true)\n\t\tn := b.N\n\t\tbatchSize := n / ng\n\t\tif batchSize == 0 {\n\t\t\tbatchSize = n\n\t\t}\n\t\tfor n > 0 {\n\t\t\twg.Add(1)\n\t\t\tbatch := min(n, batchSize)\n\t\t\tn -= batch\n\t\t\tgo func(quota int) {\n\t\t\t\tfor trigger.Load() {\n\t\t\t\t\truntime.Gosched()\n\t\t\t\t}\n\t\t\t\tlocalCnt := 0\n\t\t\t\tfor i := 0; i < quota; i++ {\n\t\t\t\t\tres := limiter.Take()\n\t\t\t\t\tlocalCnt += res.Nanosecond()\n\t\t\t\t}\n\t\t\t\tcount.Add(int64(localCnt))\n\t\t\t\twg.Done()\n\t\t\t}(batch)\n\t\t}\n\n\t\tb.StartTimer()\n\t\ttrigger.Store(false)\n\t\twg.Wait()\n\t\tb.StopTimer()\n\t})\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "ratelimit_test.go",
          "type": "blob",
          "size": 8.9130859375,
          "content": "package ratelimit\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/atomic\"\n\n\t\"github.com/benbjohnson/clock\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype testRunner interface {\n\t// createLimiter builds a limiter with given options.\n\tcreateLimiter(int, ...Option) Limiter\n\t// takeOnceAfter attempts to Take at a specific time.\n\ttakeOnceAfter(time.Duration, Limiter)\n\t// startTaking tries to Take() on passed in limiters in a loop/goroutine.\n\tstartTaking(rls ...Limiter)\n\t// assertCountAt asserts the limiters have Taken() a number of times at the given time.\n\t// It's a thin wrapper around afterFunc to reduce boilerplate code.\n\tassertCountAt(d time.Duration, count int)\n\t// afterFunc executes a func at a given time.\n\t// not using clock.AfterFunc because andres-erbsen/clock misses a nap there.\n\tafterFunc(d time.Duration, fn func())\n\t// some tests want raw access to the clock.\n\tgetClock() *clock.Mock\n}\n\ntype runnerImpl struct {\n\tt *testing.T\n\n\tclock       *clock.Mock\n\tconstructor func(int, ...Option) Limiter\n\tcount       atomic.Int32\n\t// maxDuration is the time we need to move into the future for a test.\n\t// It's populated automatically based on assertCountAt/afterFunc.\n\tmaxDuration time.Duration\n\tdoneCh      chan struct{}\n\twg          sync.WaitGroup\n}\n\nfunc runTest(t *testing.T, fn func(testRunner)) {\n\timpls := []struct {\n\t\tname        string\n\t\tconstructor func(int, ...Option) Limiter\n\t}{\n\t\t{\n\t\t\tname: \"mutex\",\n\t\t\tconstructor: func(rate int, opts ...Option) Limiter {\n\t\t\t\treturn newMutexBased(rate, opts...)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"atomic\",\n\t\t\tconstructor: func(rate int, opts ...Option) Limiter {\n\t\t\t\treturn newAtomicBased(rate, opts...)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"atomic_int64\",\n\t\t\tconstructor: func(rate int, opts ...Option) Limiter {\n\t\t\t\treturn newAtomicInt64Based(rate, opts...)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range impls {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Set a non-default time.Time since some limiters (int64 in particular) use\n\t\t\t// the default value as \"non-initialized\" state.\n\t\t\tclockMock := clock.NewMock()\n\t\t\tclockMock.Set(time.Now())\n\t\t\tr := runnerImpl{\n\t\t\t\tt:           t,\n\t\t\t\tclock:       clockMock,\n\t\t\t\tconstructor: tt.constructor,\n\t\t\t\tdoneCh:      make(chan struct{}),\n\t\t\t}\n\t\t\tdefer close(r.doneCh)\n\t\t\tdefer r.wg.Wait()\n\n\t\t\tfn(&r)\n\t\t\tr.clock.Add(r.maxDuration)\n\t\t})\n\t}\n}\n\n// createLimiter builds a limiter with given options.\nfunc (r *runnerImpl) createLimiter(rate int, opts ...Option) Limiter {\n\topts = append(opts, WithClock(r.clock))\n\treturn r.constructor(rate, opts...)\n}\n\nfunc (r *runnerImpl) getClock() *clock.Mock {\n\treturn r.clock\n}\n\n// startTaking tries to Take() on passed in limiters in a loop/goroutine.\nfunc (r *runnerImpl) startTaking(rls ...Limiter) {\n\tr.goWait(func() {\n\t\tfor {\n\t\t\tfor _, rl := range rls {\n\t\t\t\trl.Take()\n\t\t\t}\n\t\t\tr.count.Inc()\n\t\t\tselect {\n\t\t\tcase <-r.doneCh:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t})\n}\n\n// takeOnceAfter attempts to Take at a specific time.\nfunc (r *runnerImpl) takeOnceAfter(d time.Duration, rl Limiter) {\n\tr.wg.Add(1)\n\tr.afterFunc(d, func() {\n\t\trl.Take()\n\t\tr.count.Inc()\n\t\tr.wg.Done()\n\t})\n}\n\n// assertCountAt asserts the limiters have Taken() a number of times at a given time.\nfunc (r *runnerImpl) assertCountAt(d time.Duration, count int) {\n\tr.wg.Add(1)\n\tr.afterFunc(d, func() {\n\t\tassert.Equal(r.t, int32(count), r.count.Load(), \"count not as expected\")\n\t\tr.wg.Done()\n\t})\n}\n\n// afterFunc executes a func at a given time.\nfunc (r *runnerImpl) afterFunc(d time.Duration, fn func()) {\n\tif d > r.maxDuration {\n\t\tr.maxDuration = d\n\t}\n\n\tr.goWait(func() {\n\t\tselect {\n\t\tcase <-r.doneCh:\n\t\t\treturn\n\t\tcase <-r.clock.After(d):\n\t\t}\n\t\tfn()\n\t})\n}\n\n// goWait runs a function in a goroutine and makes sure the goroutine was scheduled.\nfunc (r *runnerImpl) goWait(fn func()) {\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\tgo func() {\n\t\twg.Done()\n\t\tfn()\n\t}()\n\twg.Wait()\n}\n\nfunc TestUnlimited(t *testing.T) {\n\tt.Parallel()\n\tnow := time.Now()\n\trl := NewUnlimited()\n\tfor i := 0; i < 1000; i++ {\n\t\trl.Take()\n\t}\n\tassert.Condition(t, func() bool { return time.Since(now) < 1*time.Millisecond }, \"no artificial delay\")\n}\n\nfunc TestRateLimiter(t *testing.T) {\n\tt.Parallel()\n\trunTest(t, func(r testRunner) {\n\t\trl := r.createLimiter(100, WithoutSlack)\n\n\t\t// Create copious counts concurrently.\n\t\tr.startTaking(rl)\n\t\tr.startTaking(rl)\n\t\tr.startTaking(rl)\n\t\tr.startTaking(rl)\n\n\t\tr.assertCountAt(1*time.Second, 100)\n\t\tr.assertCountAt(2*time.Second, 200)\n\t\tr.assertCountAt(3*time.Second, 300)\n\t})\n}\n\nfunc TestDelayedRateLimiter(t *testing.T) {\n\tt.Parallel()\n\trunTest(t, func(r testRunner) {\n\t\tslow := r.createLimiter(10, WithoutSlack)\n\t\tfast := r.createLimiter(100, WithoutSlack)\n\n\t\tr.startTaking(slow, fast)\n\n\t\tr.afterFunc(20*time.Second, func() {\n\t\t\tr.startTaking(fast)\n\t\t\tr.startTaking(fast)\n\t\t\tr.startTaking(fast)\n\t\t\tr.startTaking(fast)\n\t\t})\n\n\t\tr.assertCountAt(30*time.Second, 1200)\n\t})\n}\n\nfunc TestPer(t *testing.T) {\n\tt.Parallel()\n\trunTest(t, func(r testRunner) {\n\t\trl := r.createLimiter(7, WithoutSlack, Per(time.Minute))\n\n\t\tr.startTaking(rl)\n\t\tr.startTaking(rl)\n\n\t\tr.assertCountAt(1*time.Second, 1)\n\t\tr.assertCountAt(1*time.Minute, 8)\n\t\tr.assertCountAt(2*time.Minute, 15)\n\t})\n}\n\n// TestInitial verifies that the initial sequence is scheduled as expected.\nfunc TestInitial(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tmsg  string\n\t\topts []Option\n\t}{\n\t\t{\n\t\t\tmsg: \"With Slack\",\n\t\t},\n\t\t{\n\t\t\tmsg:  \"Without Slack\",\n\t\t\topts: []Option{WithoutSlack},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\trunTest(t, func(r testRunner) {\n\t\t\t\trl := r.createLimiter(10, tt.opts...)\n\n\t\t\t\tvar (\n\t\t\t\t\tclk  = r.getClock()\n\t\t\t\t\tprev = clk.Now()\n\n\t\t\t\t\tresults = make(chan time.Time)\n\t\t\t\t\thave    []time.Duration\n\t\t\t\t\tstartWg sync.WaitGroup\n\t\t\t\t)\n\t\t\t\tstartWg.Add(3)\n\n\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tstartWg.Done()\n\t\t\t\t\t\tresults <- rl.Take()\n\t\t\t\t\t}()\n\t\t\t\t}\n\n\t\t\t\tstartWg.Wait()\n\t\t\t\tclk.Add(time.Second)\n\n\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\tts := <-results\n\t\t\t\t\thave = append(have, ts.Sub(prev))\n\t\t\t\t\tprev = ts\n\t\t\t\t}\n\n\t\t\t\tassert.Equal(t,\n\t\t\t\t\t[]time.Duration{\n\t\t\t\t\t\t0,\n\t\t\t\t\t\ttime.Millisecond * 100,\n\t\t\t\t\t\ttime.Millisecond * 100,\n\t\t\t\t\t},\n\t\t\t\t\thave,\n\t\t\t\t\t\"bad timestamps for inital takes\",\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestMaxSlack(t *testing.T) {\n\tt.Parallel()\n\trunTest(t, func(r testRunner) {\n\t\trl := r.createLimiter(1, WithSlack(1))\n\n\t\tr.takeOnceAfter(time.Nanosecond, rl)\n\t\tr.takeOnceAfter(2*time.Second+1*time.Nanosecond, rl)\n\t\tr.takeOnceAfter(2*time.Second+2*time.Nanosecond, rl)\n\t\tr.takeOnceAfter(2*time.Second+3*time.Nanosecond, rl)\n\t\tr.takeOnceAfter(2*time.Second+4*time.Nanosecond, rl)\n\n\t\tr.assertCountAt(3*time.Second, 3)\n\t\tr.assertCountAt(10*time.Second, 5)\n\t})\n}\n\nfunc TestSlack(t *testing.T) {\n\tt.Parallel()\n\t// To simulate slack, we combine two limiters.\n\t// - First, we start a single goroutine with both of them,\n\t//   during this time the slow limiter will dominate,\n\t//   and allow the fast limiter to accumulate slack.\n\t// - After 2 seconds, we start another goroutine with\n\t//   only the faster limiter. This will allow it to max out,\n\t//   and consume all the slack.\n\t// - After 3 seconds, we look at the final result, and we expect,\n\t//   a sum of:\n\t//   - slower limiter running for 3 seconds\n\t//   - faster limiter running for 1 second\n\t//   - slack accumulated by the faster limiter during the two seconds.\n\t//     it was blocked by slower limiter.\n\ttests := []struct {\n\t\tmsg  string\n\t\topt  []Option\n\t\twant int\n\t}{\n\t\t{\n\t\t\tmsg: \"no option, defaults to 10\",\n\t\t\t// 2*10 + 1*100 + 1*10 (slack)\n\t\t\twant: 130,\n\t\t},\n\t\t{\n\t\t\tmsg: \"slack of 10, like default\",\n\t\t\topt: []Option{WithSlack(10)},\n\t\t\t// 2*10 + 1*100 + 1*10 (slack)\n\t\t\twant: 130,\n\t\t},\n\t\t{\n\t\t\tmsg: \"slack of 20\",\n\t\t\topt: []Option{WithSlack(20)},\n\t\t\t// 2*10 + 1*100 + 1*20 (slack)\n\t\t\twant: 140,\n\t\t},\n\t\t{\n\t\t\t// Note this is bigger then the rate of the limiter.\n\t\t\tmsg: \"slack of 150\",\n\t\t\topt: []Option{WithSlack(150)},\n\t\t\t// 2*10 + 1*100 + 1*150 (slack)\n\t\t\twant: 270,\n\t\t},\n\t\t{\n\t\t\tmsg: \"no option, defaults to 10, with per\",\n\t\t\t// 2*(10*2) + 1*(100*2) + 1*10 (slack)\n\t\t\topt:  []Option{Per(500 * time.Millisecond)},\n\t\t\twant: 230,\n\t\t},\n\t\t{\n\t\t\tmsg: \"slack of 10, like default, with per\",\n\t\t\topt: []Option{WithSlack(10), Per(500 * time.Millisecond)},\n\t\t\t// 2*(10*2) + 1*(100*2) + 1*10 (slack)\n\t\t\twant: 230,\n\t\t},\n\t\t{\n\t\t\tmsg: \"slack of 20, with per\",\n\t\t\topt: []Option{WithSlack(20), Per(500 * time.Millisecond)},\n\t\t\t// 2*(10*2) + 1*(100*2) + 1*20 (slack)\n\t\t\twant: 240,\n\t\t},\n\t\t{\n\t\t\t// Note this is bigger then the rate of the limiter.\n\t\t\tmsg: \"slack of 150, with per\",\n\t\t\topt: []Option{WithSlack(150), Per(500 * time.Millisecond)},\n\t\t\t// 2*(10*2) + 1*(100*2) + 1*150 (slack)\n\t\t\twant: 370,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\trunTest(t, func(r testRunner) {\n\t\t\t\tslow := r.createLimiter(10, WithoutSlack)\n\t\t\t\tfast := r.createLimiter(100, tt.opt...)\n\n\t\t\t\tr.startTaking(slow, fast)\n\n\t\t\t\tr.afterFunc(2*time.Second, func() {\n\t\t\t\t\tr.startTaking(fast)\n\t\t\t\t\tr.startTaking(fast)\n\t\t\t\t})\n\n\t\t\t\t// limiter with 10hz dominates here - we're always at 10.\n\t\t\t\tr.assertCountAt(1*time.Second, 10)\n\t\t\t\tr.assertCountAt(3*time.Second, tt.want)\n\t\t\t})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}