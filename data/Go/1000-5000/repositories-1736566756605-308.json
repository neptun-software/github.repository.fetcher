{
  "metadata": {
    "timestamp": 1736566756605,
    "page": 308,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "github/git-sizer",
      "stars": 3677,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "/bin\n/releases\n/vendor\n"
        },
        {
          "name": ".golangci.toml",
          "type": "blob",
          "size": 24.4921875,
          "content": "[linters]\n    # This file is intended to be used by your IDE to show you what linting\n    # issues exist in the code as you work on it. The github actions will run\n    # only the Tier 1 linters against the whole codebase (see\n    # .golangci-repo.toml, but it should be the same as the tier 1 list here).\n    # The tier 2 and 3 linters will run only against the files you change in a\n    # PR, so that you can clean up as you go.\n    #\n    # To see what issues will be present on just the PR files, you can run\n    # golangci-lint run --new-from-rev=origin/main\n\n    # format of this list:\n    # \"lintername\",         # description\n                                # reason it's enabled\n    enable = [\n        #\n        #   Full Repo Scan - Linters that find bugs.\n        #\n\n        \"bodyclose\",        # checks whether HTTP response body is closed successfully\n                                # Forgetting to close an HTTP body can be a memory leak\n        \"durationcheck\",    # check for two durations multiplied together\n                                # this is probably a rare bug, but should have basically zero false positives.\n        \"errcheck\",         # finds unchecked error returns\n                                # Checking all errors is just good dev practice.\n        \"errorlint\",        # finds code that will cause problems with the error wrapping scheme introduced in Go 1.13\n                                # This ensures you use errors.Is instead of == to compare errors, to avoid bugs with wrapping.\n        \"exportloopref\",    # catch bugs resulting from referencing variables on range scope\n                                # variables initialized in for loops change with each loop, which can cause bugs.\n        \"forcetypeassert\",  # finds type asserts where you don't use the v, ok format\n                                # if you do v := foo.(bar) and foo is not a bar, this will panic, and that's bad.\n        \"gocritic\",         # Provides many diagnostics that check for bugs, performance and style issues.\n                                # This is highly configurable, see the gocritic config section below.\n        \"goerr113\",         # checks that you use errors.Is and don't define your own errors except as package variables.\n                                # If you don't use errors.Is, then your code can break if someone wraps an error before they\n                                # return it. Creating errors with errors.New(\"some message\") makes a magic error that no one\n                                # can handle, so either create it as a sentinel, or give it a type that people can check against.\n        \"goimports\",        # check that all code is formatted with goimports\n                                # Formating is good. goimports is better (and formats imports slightly differently than gofmt).\n        \"gosec\",            # Inspects source code for security problems\n                                # high quality linter that finds real bugs\n        \"govet\",            # reports suspicious constructs like printf calls that don't have the right # of arguments\n                                # high quality, low false positives\n        \"ineffassign\",      # Detects when assignments to existing variables are not used\n                                # this finds bugs all the time, where you assign to a value but then never use\n                                # the assigned value due to shadowing etc.\n        \"nolintlint\",       # Reports ill-formed or insufficient nolint directives\n                                # ensures that you don't typo nolint comments. and that you justify them with why you are ignoring a linter here.\n        \"rowserrcheck\",     # checks whether Err of rows is checked successfully\n                                # finds bugs in SQL code\n        \"sqlclosecheck\",    # Checks that sql.Rows and sql.Stmt are closed.\n                                # easy and finds bugs\n        \"typecheck\",        # parses and type-checks Go code\n                                # probably unnecessary, but shouldn't hurt anything\n        \"wastedassign\",     # finds wasted assignment statements.\n                                # can find bugs where you assign something but never use it\n\n        #\n        # PR Scan - less critical, but should be fixed as we go along\n        #\n\n        \"deadcode\",         # Finds unused code\n                                # dead code can be a bug or just confusing for the next dev\n        \"depguard\",         # checks if package imports are in a list of acceptable packages\n                                # this is useful for ensuring people use the company-standard packages for logging etc.\n        \"errname\",          # Checks that sentinel errors are prefixed with the Err and error types are suffixed with the Error.\n                                # This is standard practice and makes it easy to find error types and sentinels in the code.\n        \"gochecknoinits\",   # Checks that no init functions are present in Go code\n                                # init is bad, and is almost never necessary, nor is it a good idea.\n        \"godot\",            # Check if comments end in a period\n                                # this is a recommended Go style, and not only makes your doc comments look more\n                                # professional, it ensures that you don't stop a comment in the middle and forget\n                                # to write the end of it.\n        #\"godox\",            # detects use of FIXME, TODO and other comment keywords\n                                # These should be issues in an issue tracker, not comments in the code.\n        \"gosimple\",         # tells you where you can simplify your code\n                                # simple is good\n        \"makezero\",         # checks that you don't accidentally make a slice w/ nonzero length and then append to it\n                                # this can cause bugs where you make a slice of length 5 and then append 5 items to it,\n                                # giving you a length of 10 where the first 5 are all zero values.\n        \"misspell\",         # Finds commonly misspelled English words in comments\n                                # we all suck at spelling and tpying\n        \"nakedret\",         # Finds naked returns in functions greater than a specified function length\n                                # naked returns are evil\n        #\"nestif\",           # Reports deeply nested if statements\n                                # deeply nested ifs are hard to read\n        \"nilerr\",           # Finds the code that returns nil even if it checks that the error is not nil.\n                                # finds fairly common bug\n        \"noctx\",            # noctx finds sending http request without context.Context\n                                # you should always use context so we can cancel external requests\n        \"prealloc\",         # Finds slice declarations that could potentially be preallocated\n                                # this can save some memory and copying, otherwise append guesses how big to make slices and may need to\n                                # copy all items in a slice to a bigger one.\n        \"predeclared\",      # find code that shadows one of Go's predeclared identifiers\n                                # you can make a variable called \"true\", but it's a bad idea.\n        #\"revive\",           # finds common style mistakes\n                              # style and other mistakes that you really should listen to.\n        \"staticcheck\",      # go vet on steroids, applying a ton of static analysis checks\n                                # encompasses many linters in one, good stuff\n        \"structcheck\",      # Finds unused struct fields\n                                # can find bugs or trim unused fields to save memory\n        #\"tparallel\",        # tparallel detects inappropriate usage of t.Parallel()\n                                # likely a rare problem, but should have low false positives\n        \"unconvert\",        # Remove unnecessary type conversions\n                                # can save a little memory, unlikely to have false positives\n        \"unused\",           # Checks for unused constants, variables, functions and types\n                                # may have false positives, should watch this one\n        \"varcheck\",         # Finds unused global variables and constants\n                                # may have false positives, should watch this one\n    ]\n\n    # we don't bother putting anything in disable, since we manually enable each linter.\n    # See the bottom of the file for disabled linters.\n    disable = []\n\n\n[run]\n    # options for analysis running\n    # Increase timeout from default 1m, first pre-cache run can take a bit in CI/CD\n    timeout = \"5m\"\n\n    # default concurrency is the available CPU number\n    # concurrency = 4\n\n    # exit code when at least one issue was found, default is 1\n    issues-exit-code = 1\n\n    # include test files or not, default is true\n    tests = true\n\n    # list of build tags, all linters use it. Default is empty list.\n    build-tags = []\n\n    # which dirs to skip: issues from them won't be reported;\n    # can use regexp here: generated.*, regexp is applied on full path;\n    # default value is empty list, but default dirs are skipped independently\n    # from this option's value (see skip-dirs-use-default).\n    # \"/\" will be replaced by current OS file path separator to properly work\n    # on Windows.\n    skip-dirs = []\n\n    # default is true. Enables skipping of directories:\n    #   vendor$, third_party$, testdata$, examples$, Godeps$, builtin$\n    skip-dirs-use-default = true\n\n    # which files to skip: they will be analyzed, but issues from them\n    # won't be reported. Default value is empty list, but there is\n    # no need to include all autogenerated files, we confidently recognize\n    # autogenerated files. If it's not please let us know.\n    # \"/\" will be replaced by current OS file path separator to properly work\n    # on Windows.\n    skip-files = []\n\n    # by default isn't set. If set we pass it to \"go list -mod={option}\". From \"go help modules\":\n    # If invoked with -mod=readonly, the go command is disallowed from the implicit\n    # automatic updating of go.mod described above. Instead, it fails when any changes\n    # to go.mod are needed. This setting is most useful to check that go.mod does\n    # not need updates, such as in a continuous integration and testing system.\n    # If invoked with -mod=vendor, the go command assumes that the vendor\n    # directory holds the correct copies of dependencies and ignores\n    # the dependency descriptions in go.mod.\n    modules-download-mode = \"\"\n\n    # Allow multiple parallel golangci-lint instances running.\n    # If false (default) - golangci-lint acquires file lock on start.\n    allow-parallel-runners = false\n\n\n[output]\n    # colored-line-number|line-number|json|tab|checkstyle|code-climate|junit-xml|github-actions\n    # default is \"colored-line-number\"\n    format = \"colored-line-number\"\n\n    # print lines of code with issue, default is true\n    print-issued-lines = true\n\n    # print linter name in the end of issue text, default is true\n    print-linter-name = true\n\n    # make issues output unique by line, default is true\n    uniq-by-line = true\n\n    # add a prefix to the output file references; default is no prefix\n    path-prefix = \"\"\n\n    # sorts results by: filepath, line and column\n    sort-results = true\n\n\n\n# options to enable differentiating between error and warning severities\n[severity]\n    # GitHub Actions annotations support error and warning only:\n    # https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-error-message\n    default-severity = \"error\"\n\n    # If set to true severity-rules regular expressions become case sensitive.\n    # The default value is false.\n    case-sensitive = false\n\n    # Default value is empty list.\n    # When a list of severity rules are provided, severity information will be added to lint\n    # issues. Severity rules have the same filtering capability as exclude rules except you\n    # are allowed to specify one matcher per severity rule.\n    # Only affects out formats that support setting severity information.\n    # [[severity.rules]]\n    #      linters = [\n    #         \"revive\",\n    #      ]\n    #      severity = \"warning\"\n\n[issues]\n    # List of regexps of issue texts to exclude, empty list by default.\n    # Please document every exception here so we know what we're suppressing and why.\n    exclude = [\n        # err113 doesn't like it when people use errors.New(\"abc\").\n        # That's kinda valid but also kind of a PITA if you don't actually want\n        # to define static errors everywhere, and no one actually depends on them.\n        \".*do not define dynamic errors, use wrapped static errors instead.*\"\n    ]\n\n    # Maximum issues count per one linter. Set to 0 to disable. Default is 50.\n    max-issues-per-linter = 0\n\n    # Maximum count of issues with the same text. Set to 0 to disable. Default is 3.\n    max-same-issues = 0\n\n    # The default value is false. If set to true exclude and exclude-rules\n    # regular expressions become case sensitive.\n    # exclude-case-sensitive = false\n\n    # This flag suppresses lint issues from several linters, overriding any other configuration you have set.\n    # It defaults to true.\n    # NEVER remove this configuration. If you want to suppress something, do so explicitly elsewhere.\n    exclude-use-default = false\n\n    # The list of ids of default excludes to include or disable. By default it's empty.\n    # We shouldn't ever need this, since we turn off default excludes.\n    include = []\n\n    # Show only new issues: if there are unstaged changes or untracked files,\n    # only those changes are analyzed, else only changes in HEAD~ are analyzed.\n    # It's a super-useful option for integration of golangci-lint into existing\n    # large codebase. It's not practical to fix all existing issues at the moment\n    # of integration: much better don't allow issues in new code.\n    # Default is false.\n    new = false\n\n    # Show only new issues created in git patch with set file path.\n    # new-from-patch = \"path/to/patch/file\"\n\n    # Show only new issues created after git revision `REV`\n    # new-from-rev = \"REV\"\n\n    # Fix found issues (if it's supported by the linter). Default is false.\n    fix = false\n\n    # reduce noise in some linters that don't necessarily need to be run in tests\n    [[issues.exclude-rules]]\n        path = \"_test\\\\.go\"\n        linters = [\"errcheck\", \"gosec\", \"gocyclo\", \"noctx\", \"govet\"]\n\n#\n# Specific Linter Settings\n#\n\n[linters-settings.depguard]\n    # ban some modules with replacements\n    list-type = \"blacklist\"\n    include-go-root = true\n    packages = [\n        # we shouldn't use pkg/error anymore\n        \"github.com/pkg/error\",\n    ]\n\n    [[linters-settings.depguard.packages-with-error-message]]\n        \"github.com/pkg/error\" = \"Please use stdlib errors module\"\n\n[linters-settings.errcheck]\n    # report about not checking of errors in type assertions: `a := b.(MyStruct)`;\n    # default is false: such cases aren't reported by default.\n    check-type-assertions = true\n\n    # report about assignment of errors to blank identifier: `num, _ := strconv.Atoi(numStr)`;\n    # default is false: such cases aren't reported by default.\n    check-blank = false\n\n    # path to a file containing a list of functions to exclude from checking\n    # see https://github.com/kisielk/errcheck#excluding-functions for details\n    exclude = \"\"\n\n    # list of functions to exclude from checking, where each entry is a single function to exclude.\n    # see https://github.com/kisielk/errcheck#excluding-functions for details\n    exclude-functions = []\n\n[linters-settings.errorlint]\n    # Check whether fmt.Errorf uses the %w verb for formatting errors. See the readme for caveats\n    errorf = true\n    # Check for plain type assertions and type switches\n    asserts = false\n    # Check for plain error comparisons\n    comparison = false\n\n[linters-settings.gocritic]\n    # Enable multiple checks by tags, run `GL_DEBUG=gocritic golangci-lint run` to see all tags and checks.\n    # Empty list by default. See https://github.com/go-critic/go-critic#usage -> section \"Tags\".\n    enabled-tags = [\n        \"diagnostic\",\n        \"performance\",\n        \"style\",\n    ]\n    disabled-checks = [\n        # import shadow warns if a variable shadow the name of an imported package.\n        # kind of noisy, doesn't actually hurt anything, just may be momentarily confusing.\n        \"importShadow\",\n        \"preferStringWriter\",\n        \"paramTypeCombine\",\n        \"unnamedResult\",\n        \"emptyStringTest\",\n        \"elseif\",\n        \"whyNoLint\",\n    ]\n\n    # HugeParam: warn if passing huge parameters by value; consider passing pointers instead.\n    [linters-settings.gocritic.settings.hugeParam]\n        # increase threshold from default (80 bytes) to 256 bytes.\n        sizeThreshold = 256\n\n\n\n\n[linters-settings.goimports]\n    # Goimports checks whether code was formatted with goimports.\n    # uncomment if we want to enforce having GitHub-owned packages sorted into a separate section\n    #local-prefixes = \"github.com/github/\"\n\n[linters-settings.govet]\n    enable = [ \"httpresponse\" ]\n\n[linters-settings.gosec]\n    excludes = [\n        \"G301\", # Expect directory permissions to be 0750 or less. See umask.\n        \"G307\", # deferring methods with errors. This duplicates errcheck, and I don't want to have to use two nolints.\n    ]\n\n\n[linters-settings.nolintlint]\n    # adds some protections around nolint directives\n\n    # Enable to ensure that nolint directives are all used. Default is true.\n    allow-unused = false\n    # Disable to ensure that nolint directives don't have a leading space. Default is true.\n    allow-leading-space = false\n    # Exclude following linters from requiring an explanation.  Default is [].\n    allow-no-explanation = []\n    # Enable to require an explanation of nonzero length after each nolint directive. Default is false.\n    require-explanation = false\n    # Enable to require nolint directives to mention the specific linter being suppressed. Default is false.\n    require-specific = true\n\n\n\n\n# List of linters supported by golangci-lint that we intentionally do not use.\n# Intentionally formatted the same as the \"enabled\" list, so you can just move one\n# up to that list to enable it.\n# list is in the form\n    # \"name\",   # description\n                    # reason to disable\n\n\n    # \"asciicheck\",         # checks that your code does not contain non-ASCII identifiers\n                                # Honestly not sure why anyone cares?\n    # \"cyclop\",             # checks function and package cyclomatic complexity\n                                # Too hard to know when you trip over this, and I feel like it needs a human\n                                # to understand if a function is too complex.\n    # \"dogsled\",            # Checks assignments with too many blank identifiers (e.g. x, _, _, _, := f())\n                                # This doesn't seem to be a common problem, nor a source of bugs. It would be\n                                # better to have a linter that just tells you not to return 4 things in the\n                                # first place.\n    # \"dupl\",               # Tool for code clone detection\n                                # This feels too likely to have high false positives on trivial code, and miss\n                                # more complicated duplicates.\n    # \"exhaustive\",         # checks exhaustiveness of enum switch statements\n                                # This tends to hit a lot of false positives, and can lead to a lot of nolint statements.\n                                # Definitely could be useful for specific repos of focused libraries where you know you\n                                # update enums a lot, and want to make sure your switch statements stay up to date.\n    # \"exhaustivestruct\",    # Checks if all struct's fields are initialized\n                                # This is generally a feature, not a bug. Requiring a //nolint whenever you partially\n                                # initialize a struct would be pretty annoying.\n    # \"forbidigo\",          # Can be configured to forbids specific identifiers, like fmt.Printf, for example.\n                                # This can actually be really useful, but needs a deep understanding of patterns\n                                # we want devs to avoid in our specific repos. Definitely look into it if you have\n                                # a list of \"don't use XYZ\" items.\n    # \"funlen\",             # Tool for detection of long functions\n                                # We could maybe put this in with a pretty big size limit, but it feels like it would be\n                                # of limited benefit and cause grumbling.\n    # \"gci\",                # control golang package import order and make it always deterministic\n                                # I haven't really had a problem with this, when using goimports, so I'm not sure it's useful.\n    # \"gochecknoglobals\",   # check that no global variables exist\n                                # this is actually good to have on, but I'm afraid it would cause more heartburn than good.\n    # \"gocognit\",           # Computes and checks the cognitive complexity of functions\n                                # Too hard to know when you trip over this, and I feel like it needs a human\n                                # to understand if a function is too complex.\n    # \"goconst\",            # Finds repeated strings that could be replaced by a constant\n                                # magic strings are bad, but I feel like this could reduce adoption of the linter.\n    # \"gofmt\",              # checks whether code was gofmt-ed.\n                                # use goimports instead, they have slightly different formatting.\n    # \"gofumpt\",            # checks whether code is gofumpt-ed\n                                # use goimports instead, they have slightly different formatting.\n    # \"goheader\",           # checks if file header matches a pattern\n                                # useful for companies that mandate a copyright header on every file. That's not github.\n    # \"golint\",             # unmaintained\n    # \"gomnd\",              # an analyzer to detect magic numbers\n                                # just too noisy\n    # \"ifshort\",            # makes sure you use if err := foo(); err != nil\n                                # this is really more personal preference, and sometimes can hinder readability.\n    # \"importas\",           # enforces consistent import aliases\n                                # this is kind of a special case for avoiding import collisions, and not really needed for us.\n    # \"interfacer\",         # unmaintined\n    # \"lll\"                 # reports long lines\n                                # duplicated by other checks\n    # \"nlreturn\",           # nlreturn checks for a new line before return and branch statements to increase code clarity\n                                # I'm not a monster, newline if you like, or not.\n    # \"paralleltest\",       # paralleltest detects missing usage of t.Parallel() method in your Go test\n                                # parallel tests are good, but packages are already run in parallel, so it's not a huge gain.\n    # \"promlinter\",         # Check Prometheus metrics naming via promlint\n                                # enable if you use prometheus\n    # \"scopelint\",          # unmaintained\n    # \"tagliatelle\",        # Checks that struct tags match a certain format (camelcase, snakecase etc)\n                                # likely to cause a lot of false positives if you're making tags for other people's APIs\n    # \"testpackage\",        # makes you use a separate _test package\n                                # I actually think this is a bad idea in general, and I would want a linter that does the opposite.\n    # \"thelper\",            # detects golang test helpers without t.Helper()\n                                # t.Helper is sometimes useful and sometimes not.\n    # \"unparam\",            # Reports unused function parameters\n                                # seems likely to have false positives\n    # \"whitespace\",         # finds extra newlines at the beginning of functions and if statements\n                                # I like this, but I feel like it would be too nitpicky for most people\n    # \"wrapcheck\",          # Checks that errors returned from external packages are wrapped\n                                # I mean, yeah, but you don't *always* need to wrap, that gets excesssive.\n    # \"wsl\",                # Whitespace Linter - Forces you to use empty lines!\n                                # meh, I'm not that much of a control freak\n"
        },
        {
          "name": "Brewfile",
          "type": "blob",
          "size": 0.009765625,
          "content": "brew \"go\"\n"
        },
        {
          "name": "CODEOWNERS",
          "type": "blob",
          "size": 0.03125,
          "content": "* @github/git-storage-reviewers\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.294921875,
          "content": "# Contributor Covenant Code of Conduct\n\nPlease note that this project is released with a Contributor Code of Conduct. By\nparticipating in this project you agree to abide by its terms.\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance, race,\nreligion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at opensource@github.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.5673828125,
          "content": "## Contributing\n\n[fork]: https://github.com/github/git-sizer/fork\n[pr]: https://github.com/github/git-sizer/compare\n[code-of-conduct]: CODE_OF_CONDUCT.md\n\nHi there! We're thrilled that you'd like to contribute to this project. Your help is essential for keeping it great.\n\nPlease note that this project is released with a [Contributor Code of Conduct][code-of-conduct]. By participating in this project you agree to abide by its terms.\n\n## Submitting a pull request\n\n1. [Fork][fork] and clone the repository\n2. Configure and install the dependencies: `script/bootstrap`\n3. Make sure the tests pass on your machine: `make test`\n4. Create a new branch: `git checkout -b my-branch-name`\n5. Make your change, add tests, and make sure the tests still pass\n6. Push to your fork and [submit a pull request][pr]\n7. Pat your self on the back and wait for your pull request to be reviewed and merged.\n\nHere are a few things you can do that will increase the likelihood of your pull request being accepted:\n\n- Make sure that your code is formatted correctly according to `go fmt`: `go fmt .`.\n- Write tests.\n- Keep your change as focused as possible. If there are multiple changes you would like to make that are not dependent upon each other, consider submitting them as separate pull requests.\n- Write a [good commit message](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html).\n\n## Resources\n\n- [How to Contribute to Open Source](https://opensource.guide/how-to-contribute/)\n- [Using Pull Requests](https://help.github.com/articles/about-pull-requests/)\n- [GitHub Help](https://help.github.com)\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0380859375,
          "content": "MIT License\n\nCopyright (c) 2018 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.4697265625,
          "content": "PACKAGE := github.com/github/git-sizer\nGO111MODULES := 1\nexport GO111MODULES\n\nGO := $(CURDIR)/script/go\n\nGO_LDFLAGS := -X main.BuildVersion=$(shell git describe --tags --always --dirty || echo unknown)\nGOFLAGS := -mod=readonly -ldflags \"$(GO_LDFLAGS)\"\n\nifdef USE_ISATTY\nGOFLAGS := $(GOFLAGS) --tags isatty\nendif\n\n.PHONY: all\nall: bin/git-sizer\n\n.PHONY: bin/git-sizer\nbin/git-sizer:\n\tmkdir -p bin\n\t$(GO) build $(GOFLAGS) -o $@ .\n\n# Cross-compile for a bunch of common platforms. Note that this\n# doesn't work with USE_ISATTY:\n.PHONY: common-platforms\ncommon-platforms:\n\n# Create releases for a bunch of common platforms. Note that this\n# doesn't work with USE_ISATTY, and VERSION must be set on the command\n# line; e.g.,\n#\n#     make releases VERSION=1.2.3\n.PHONY: releases\nreleases:\n\n# Define rules for a bunch of common platforms that are supported by go; see\n#     https://golang.org/doc/install/source#environment\n# You can compile for any other platform in that list by running\n#     make GOOS=foo GOARCH=bar\n\ndefine PLATFORM_template =\n.PHONY: bin/git-sizer-$(1)-$(2)$(3)\nbin/git-sizer-$(1)-$(2)$(3):\n\tmkdir -p bin\n\tGOOS=$(1) GOARCH=$(2) $$(GO) build $$(GOFLAGS) -ldflags \"-X main.ReleaseVersion=$$(VERSION)\" -o $$@ .\ncommon-platforms: bin/git-sizer-$(1)-$(2)$(3)\n\n# Note that releases don't include code from vendor (they're only used\n# for testing), so no license info is needed from those projects.\n.PHONY: releases/git-sizer-$$(VERSION)-$(1)-$(2).zip\nreleases/git-sizer-$$(VERSION)-$(1)-$(2).zip: bin/git-sizer-$(1)-$(2)$(3)\n\tif test -z \"$$(VERSION)\"; then echo \"Please set VERSION to make releases\"; exit 1; fi\n\tmkdir -p releases/tmp-$$(VERSION)-$(1)-$(2)\n\tcp README.md LICENSE.md releases/tmp-$$(VERSION)-$(1)-$(2)\n\tcp bin/git-sizer-$(1)-$(2)$(3) releases/tmp-$$(VERSION)-$(1)-$(2)/git-sizer$(3)\n\tcp $$$$($$(GO) list -f '{{.Dir}}' github.com/spf13/pflag)/LICENSE \\\n\t\treleases/tmp-$$(VERSION)-$(1)-$(2)/LICENSE-spf13-pflag\n\trm -f $$@\n\tzip -j $$@ releases/tmp-$$(VERSION)-$(1)-$(2)/*\n\trm -rf releases/tmp-$$(VERSION)-$(1)-$(2)\nreleases: releases/git-sizer-$$(VERSION)-$(1)-$(2).zip\nendef\n\n$(eval $(call PLATFORM_template,linux,amd64))\n$(eval $(call PLATFORM_template,linux,386))\n\n$(eval $(call PLATFORM_template,darwin,amd64))\n$(eval $(call PLATFORM_template,darwin,arm64))\n\n$(eval $(call PLATFORM_template,windows,amd64,.exe))\n$(eval $(call PLATFORM_template,windows,386,.exe))\n\n.PHONY: test\ntest: bin/git-sizer gotest\n\n.PHONY: gotest\ngotest:\n\t$(GO) test -timeout 60s $(GOFLAGS) ./...\n\n.PHONY: clean\nclean:\n\trm -rf bin\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.12109375,
          "content": "_Happy Git repositories are all alike; every unhappy Git repository is unhappy in its own way._ —Linus Tolstoy\n\n# git-sizer\n\nIs your Git repository bursting at the seams?\n\n`git-sizer` computes various size metrics for a local Git repository, flagging those that might cause you problems or inconvenience. For example:\n\n* Is the repository too big overall? Ideally, Git repositories should be under 1 GiB, and (without special handling) they start to get unwieldy over 5 GiB. Big repositories take a long time to clone and repack, and take a lot of disk space. Suggestions:\n\n    * Avoid storing generated files (e.g., compiler output, JAR files) in Git. It would be better to regenerate them when necessary, or store them in a package registry or even a fileserver.\n\n    * Avoid storing large media assets in Git. You might want to look into [Git-LFS](https://git-lfs.github.com/) or [git-annex](http://git-annex.branchable.com/), which allow you to version your media assets in Git while actually storing them outside of your repository.\n\n    * Avoid storing file archives (e.g., ZIP files, tarballs) in Git, especially if compressed. Different versions of such files don't delta well against each other, so Git can't store them efficiently. It would be better to store the individual files in your repository, or store the archive elsewhere.\n\n* Does the repository have too many references (branches and/or tags)? They all have to be transferred to the client for every fetch, even if your clone is up-to-date. Try to limit them to a few tens of thousands at most. Suggestions:\n\n    * Delete unneeded tags and branches.\n\n    * Avoid pushing your \"remote-tracking\" branches to a shared repository.\n\n    * Consider using [\"git notes\"](https://git-scm.com/docs/git-notes) rather than tags to attach auxiliary information to commits (for example, CI build results).\n\n    * Perhaps store some of your rarely-needed tags and branches in a separate fork of your repository that is not fetched from by normal developers.\n\n* Does the repository include too many objects? The more objects, the longer it takes for Git to traverse the repository's history, for example when garbage-collecting. Suggestions:\n\n    * Think about whether you are storing very many tiny files that could easily be collected into a few bigger files.\n\n    * Consider breaking your project up into multiple subprojects.\n\n* Does the repository include gigantic blobs (files)? Git works best with small- to medium-sized files. It's OK to have a few files in the megabyte range, but they should generally be the exception. Suggestions:\n\n    * Consider using [Git-LFS](https://git-lfs.github.com/) for storing your large files, especially those (e.g., media assets) that don't diff and merge usefully.\n\n    * See also the section \"Is the repository too big overall?\"\n\n* Does the repository include many, many versions of large text files, each one slightly changed from the one before? Such files delta very well, so they might not cause your repository to grow alarmingly. But it is expensive for Git to reconstruct the full files and to diff them, which it needs to do internally for many operations. Suggestions:\n\n    * Avoid storing log files and database dumps in Git.\n\n    * Avoid storing giant data files (e.g., enormous XML files) in Git, especially if they are modified frequently. Consider using a database instead.\n\n* Does the repository include gigantic trees (directories)? Every time a file is modified, Git has to create a new copy of every tree (i.e., every directory in the path) leading to the file. Huge trees make this expensive. Moreover, it is very expensive to traverse through history that contains huge trees, for example for `git blame`. Suggestions:\n\n    * Avoid creating directories with more than a couple of thousand entries each.\n\n    * If you must store very many files, it is better to shard them into a hierarchy of multiple, smaller directories.\n\n* Does the repository have the same (or very similar) files repeated over and over again at different paths in a single commit? If so, the repository might have a reasonable overall size, but when you check it out it balloons into an enormous working copy. (Taken to an extreme, this is called a \"git bomb\"; see below.) Suggestions:\n\n    * Perhaps you can achieve your goals more effectively by using tags and branches or a build-time configuration system.\n\n* Does the repository include absurdly long path names? That's probably not going to work well with other tools. One or two hundred characters should be enough, even if you're writing Java.\n\n* Are there other bizarre and questionable things in the repository?\n\n    * Annotated tags pointing at one another in long chains?\n\n    * Octopus merges with dozens of parents?\n\n    * Commits with gigantic log messages?\n\n`git-sizer` computes many size-related statistics about your repository that can help reveal all of the problems described above. These practices are not wrong per se, but the more that you stretch Git beyond its sweet spot, the less you will be able to enjoy Git's legendary speed and performance. Especially if your Git repository statistics seem out of proportion to your project size, you might be able to make your life easier by adjusting how you use Git.\n\n\n## Getting started\n\n1.  Make sure that you have the [Git command-line client](https://git-scm.com/) installed, **version >= 2.6**. NOTE: `git-sizer` invokes `git` commands to examine the contents of your repository, so **it is required that the `git` command be in your `PATH`** when you run `git-sizer`.\n\n2.  Install `git-sizer`. Either:\n\n    a. Install a released version of `git-sizer`(recommended):\n       1. Go to [the releases page](https://github.com/github/git-sizer/releases) and download the ZIP file corresponding to your platform.\n       2. Unzip the file.\n       3. Move the executable file (`git-sizer` or `git-sizer.exe`) into your `PATH`.\n\n    b. Build and install from source. See the instructions in [`docs/BUILDING.md`](docs/BUILDING.md).\n\n3.  Change to the directory containing a full, non-shallow clone of the Git repository that you'd like to analyze. Then run\n\n        git-sizer [<option>...]\n\n    No options are required. You can learn about available options by typing `git-sizer -h` or by reading on.\n\n**Pro tip**: If you add `git-sizer` to your `PATH`, then you can run it by typing either `git-sizer` or `git sizer`. In the latter case, it is found and run for you by Git, and you can add extra Git options between the two words, like `git -C /path/to/my/repo sizer`. If you don't add `git-sizer` to your `PATH`, then of course you need to type its full path and filename to run it; e.g., `/path/to/bin/git-sizer`. In either case, the `git` executable *must* be in your `PATH`.\n\n\n## Usage\n\nBy default, `git-sizer` outputs its results in tabular format. For example, let's use it to analyze [the Linux repository](https://github.com/torvalds/linux), using the `--verbose` option so that all statistics are output:\n\n```\n$ git-sizer --verbose\nProcessing blobs: 1652370\nProcessing trees: 3396199\nProcessing commits: 722647\nMatching commits to trees: 722647\nProcessing annotated tags: 534\nProcessing references: 539\n| Name                         | Value     | Level of concern               |\n| ---------------------------- | --------- | ------------------------------ |\n| Overall repository size      |           |                                |\n| * Commits                    |           |                                |\n|   * Count                    |   723 k   | *                              |\n|   * Total size               |   525 MiB | **                             |\n| * Trees                      |           |                                |\n|   * Count                    |  3.40 M   | **                             |\n|   * Total size               |  9.00 GiB | ****                           |\n|   * Total tree entries       |   264 M   | *****                          |\n| * Blobs                      |           |                                |\n|   * Count                    |  1.65 M   | *                              |\n|   * Total size               |  55.8 GiB | *****                          |\n| * Annotated tags             |           |                                |\n|   * Count                    |   534     |                                |\n| * References                 |           |                                |\n|   * Count                    |   539     |                                |\n|                              |           |                                |\n| Biggest objects              |           |                                |\n| * Commits                    |           |                                |\n|   * Maximum size         [1] |  72.7 KiB | *                              |\n|   * Maximum parents      [2] |    66     | ******                         |\n| * Trees                      |           |                                |\n|   * Maximum entries      [3] |  1.68 k   | *                              |\n| * Blobs                      |           |                                |\n|   * Maximum size         [4] |  13.5 MiB | *                              |\n|                              |           |                                |\n| History structure            |           |                                |\n| * Maximum history depth      |   136 k   |                                |\n| * Maximum tag depth      [5] |     1     |                                |\n|                              |           |                                |\n| Biggest checkouts            |           |                                |\n| * Number of directories  [6] |  4.38 k   | **                             |\n| * Maximum path depth     [7] |    13     | *                              |\n| * Maximum path length    [8] |   134 B   | *                              |\n| * Number of files        [9] |  62.3 k   | *                              |\n| * Total size of files    [9] |   747 MiB |                                |\n| * Number of symlinks    [10] |    40     |                                |\n| * Number of submodules       |     0     |                                |\n\n[1]  91cc53b0c78596a73fa708cceb7313e7168bb146\n[2]  2cde51fbd0f310c8a2c5f977e665c0ac3945b46d\n[3]  4f86eed5893207aca2c2da86b35b38f2e1ec1fc8 (refs/heads/master:arch/arm/boot/dts)\n[4]  a02b6794337286bc12c907c33d5d75537c240bd0 (refs/heads/master:drivers/gpu/drm/amd/include/asic_reg/vega10/NBIO/nbio_6_1_sh_mask.h)\n[5]  5dc01c595e6c6ec9ccda4f6f69c131c0dd945f8c (refs/tags/v2.6.11)\n[6]  1459754b9d9acc2ffac8525bed6691e15913c6e2 (589b754df3f37ca0a1f96fccde7f91c59266f38a^{tree})\n[7]  78a269635e76ed927e17d7883f2d90313570fdbc (dae09011115133666e47c35673c0564b0a702db7^{tree})\n[8]  ce5f2e31d3bdc1186041fdfd27a5ac96e728f2c5 (refs/heads/master^{tree})\n[9]  532bdadc08402b7a72a4b45a2e02e5c710b7d626 (e9ef1fe312b533592e39cddc1327463c30b0ed8d^{tree})\n[10] f29a5ea76884ac37e1197bef1941f62fda3f7b99 (f5308d1b83eba20e69df5e0926ba7257c8dd9074^{tree})\n```\n\nThe output is a table showing the thing that was measured, its numerical value, and a rough indication of which values might be a cause for concern. In all cases, only objects that are reachable from references are included (i.e., not unreachable objects, nor objects that are reachable only from the reflogs).\n\nThe \"Overall repository size\" section includes repository-wide statistics about distinct objects, not including repetition. \"Total size\" is the sum of the sizes of the corresponding objects in their uncompressed form, measured in bytes. The overall uncompressed size of all objects is a good indication of how expensive commands like `git gc --aggressive` (and `git repack [-f|-F]` and `git pack-objects --no-reuse-delta`), `git fsck`, and `git log [-G|-S]` will be.  The uncompressed size of trees and commits is a good indication of how expensive reachability traversals will be, including clones and fetches and `git gc`.\n\nThe \"Biggest objects\" section provides information about the biggest single objects of each type, anywhere in the history.\n\nIn the \"History structure\" section, \"maximum history depth\" is the longest chain of commits in the history, and \"maximum tag depth\" reports the longest chain of annotated tags that point at other annotated tags.\n\nThe \"Biggest checkouts\" section is about the sizes of commits as checked out into a working copy. \"Maximum path depth\" is the largest number of path components for files in the working copy, and \"maximum path length\" is the longest path in terms of bytes. \"Total size of files\" is the sum of all file sizes in the single biggest commit, including multiplicities if the same file appears multiple times.\n\nThe \"Value\" column displays counts, using units \"k\" (thousand), \"M\" (million), \"G\" (billion) etc., and sizes, using units \"B\" (bytes), \"KiB\" (1024 bytes), \"MiB\" (1024 KiB), etc. Note that if a value overflows its counter (which should only happen for malicious repositories), the corresponding value is displayed as `∞` in tabular form, or truncated to 2³²-1 or 2⁶⁴-1 (depending on the size of the counter) in JSON mode.\n\nThe \"Level of concern\" column uses asterisks to indicate values that seem high compared with \"typical\" Git repositories. The more asterisks, the more inconvenience this aspect of your repository might be expected to cause. Exclamation points indicate values that are extremely high (i.e., equivalent to more than 30 asterisks).\n\nThe footnotes list the SHA-1s of the \"biggest\" objects referenced in the table, along with a more human-readable `<commit>:<path>` description of where that object is located in the repository's history. Given the name of a large object, you could, for example, type\n\n    git cat-file -p <commit>:<path>\n\nat the command line to view the contents of the object. (Use `--names=none` if you'd rather omit these footnotes.)\n\nBy default, only statistics above a minimal level of concern are reported. Use `--verbose` (as above) to request that all statistics be output. Use `--threshold=<value>` to suppress the reporting of statistics below a specified level of concern. (`<value>` is interpreted as a numerical value corresponding to the number of asterisks.) Use `--critical` to report only statistics with a critical level of concern (equivalent to `--threshold=30`).\n\nIf you'd like the output in machine-readable format, including exact numbers, use the `--json` option. You can use `--json-version=1` or `--json-version=2` to choose between old and new style JSON output.\n\nTo get a list of other options, run\n\n    git-sizer -h\n\nThe Linux repository is large by most standards. As you can see, it is pushing some of Git's limits. And indeed, some Git operations on the Linux repository (e.g., `git fsck`, `git gc`) do take a while. But due to its sane structure, none of its dimensions are wildly out of proportion to the size of the code base, so the kernel project is managed successfully using Git.\n\nHere is the non-verbose  output for one of the famous [\"git bomb\"](https://kate.io/blog/git-bomb/) repositories:\n\n```\n$ git-sizer\n[...]\n| Name                         | Value     | Level of concern               |\n| ---------------------------- | --------- | ------------------------------ |\n| Biggest checkouts            |           |                                |\n| * Number of directories  [1] |  1.11 G   | !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! |\n| * Maximum path depth     [1] |    11     | *                              |\n| * Number of files        [1] |     ∞     | !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! |\n| * Total size of files    [2] |  83.8 GiB | !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! |\n\n[1]  c1971b07ce6888558e2178a121804774c4201b17 (refs/heads/master^{tree})\n[2]  d9513477b01825130c48c4bebed114c4b2d50401 (18ed56cbc5012117e24a603e7c072cf65d36d469^{tree})\n```\n\nThis repository is mischievously constructed to have a pathological tree structure, with the same directories repeated over and over again. As a result, even though the entire repository is less than 20 kb in size, when checked out it would explode into over a billion directories containing over ten billion files. (`git-sizer` prints `∞` for the blob count because the true number has overflowed the 32-bit counter used for that field.)\n\n\n## Contributing\n\n`git-sizer` is in regular use and is still under active development. If you would like to help out, please see [`CONTRIBUTING.md`](CONTRIBUTING.md).\n"
        },
        {
          "name": "counts",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "git-sizer.go",
          "type": "blob",
          "size": 11.1845703125,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime/pprof\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/spf13/pflag\"\n\n\t\"github.com/github/git-sizer/git\"\n\t\"github.com/github/git-sizer/internal/refopts\"\n\t\"github.com/github/git-sizer/isatty\"\n\t\"github.com/github/git-sizer/meter\"\n\t\"github.com/github/git-sizer/sizes\"\n)\n\nconst usage = `usage: git-sizer [OPTS] [ROOT...]\n\n Scan objects in your Git repository and emit statistics about them.\n\n      --threshold THRESHOLD    minimum level of concern (i.e., number of stars)\n                               that should be reported. Default:\n                               '--threshold=1'. Can be set via gitconfig:\n                               'sizer.threshold'.\n  -v, --verbose                report all statistics, whether concerning or\n                               not; equivalent to '--threshold=0\n      --no-verbose             equivalent to '--threshold=1'\n      --critical               only report critical statistics; equivalent\n                               to '--threshold=30'\n      --names=[none|hash|full] display names of large objects in the specified\n                               style. Values:\n                               * 'none' - omit footnotes entirely\n                               * 'hash' - show only the SHA-1s of objects\n                               * 'full' - show full names\n                               Default is '--names=full'. Can be set via\n                               gitconfig: 'sizer.names'.\n  -j, --json                   output results in JSON format\n      --json-version=[1|2]     choose which JSON format version to output.\n                               Default: --json-version=1. Can be set via\n                               gitconfig: 'sizer.jsonVersion'.\n      --[no-]progress          report (don't report) progress to stderr. Can\n                               be set via gitconfig: 'sizer.progress'.\n      --version                only report the git-sizer version number\n\n Object selection:\n\n git-sizer traverses through your Git history to find objects to\n process. By default, it processes all objects that are reachable from\n any reference. You can tell it to process only some of your\n references; see \"Reference selection\" below.\n\n If explicit ROOTs are specified on the command line, each one should\n be a string that 'git rev-parse' can convert into a single Git object\n ID, like 'main', 'main~:src', or an abbreviated SHA-1. See\n git-rev-parse(1) for details. In that case, git-sizer also treats\n those objects as starting points for its traversal, and also includes\n the Git objects that are reachable from those roots in the analysis.\n\n As a special case, if one or more ROOTs are specified on the command\n line but _no_ reference selection options, then _only_ the specified\n ROOTs are traversed, and no references.\n\n Reference selection:\n\n The following options can be used to limit which references to\n process. The last rule matching a reference determines whether that\n reference is processed.\n\n      --[no-]branches          process [don't process] branches\n      --[no-]tags              process [don't process] tags\n      --[no-]remotes           process [don't process] remote-tracking\n                               references\n      --[no-]notes             process [don't process] git-notes references\n      --[no-]stash             process [don't process] refs/stash\n      --include PREFIX, --exclude PREFIX\n                               process [don't process] references with the\n                               specified PREFIX (e.g.,\n                               '--include=refs/remotes/origin')\n      --include /REGEXP/, --exclude /REGEXP/\n                               process [don't process] references matching the\n                               specified regular expression (e.g.,\n                               '--include=refs/tags/release-.*')\n      --include @REFGROUP, --exclude @REFGROUP\n                               process [don't process] references in the\n                               specified reference group (see below)\n      --show-refs              show which refs are being included/excluded\n\n PREFIX must match at a boundary; for example 'refs/foo' matches\n 'refs/foo' and 'refs/foo/bar' but not 'refs/foobar'.\n\n REGEXP patterns must match the full reference name.\n\n REFGROUP can be the name of a predefined reference group ('branches',\n 'tags', 'remotes', 'pulls', 'changes', 'notes', or 'stash'), or one\n defined via gitconfig settings like the following (the\n include/exclude settings can be repeated):\n\n   * 'refgroup.REFGROUP.name=NAME'\n   * 'refgroup.REFGROUP.include=PREFIX'\n   * 'refgroup.REFGROUP.includeRegexp=REGEXP'\n   * 'refgroup.REFGROUP.exclude=PREFIX'\n   * 'refgroup.REFGROUP.excludeRegexp=REGEXP'\n\n`\n\nvar ReleaseVersion string\nvar BuildVersion string\n\nfunc main() {\n\tctx := context.Background()\n\n\terr := mainImplementation(ctx, os.Stdout, os.Stderr, os.Args[1:])\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"error: %s\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc mainImplementation(ctx context.Context, stdout, stderr io.Writer, args []string) error {\n\tvar nameStyle sizes.NameStyle = sizes.NameStyleFull\n\tvar cpuprofile string\n\tvar jsonOutput bool\n\tvar jsonVersion int\n\tvar threshold sizes.Threshold = 1\n\tvar progress bool\n\tvar version bool\n\tvar showRefs bool\n\n\t// Try to open the repository, but it's not an error yet if this\n\t// fails, because the user might only be asking for `--help`.\n\trepo, repoErr := git.NewRepositoryFromPath(\".\")\n\n\tflags := pflag.NewFlagSet(\"git-sizer\", pflag.ContinueOnError)\n\tflags.Usage = func() {\n\t\tfmt.Fprint(stdout, usage)\n\t}\n\n\tflags.VarP(\n\t\tsizes.NewThresholdFlagValue(&threshold, 0),\n\t\t\"verbose\", \"v\", \"report all statistics, whether concerning or not\",\n\t)\n\tflags.Lookup(\"verbose\").NoOptDefVal = \"true\"\n\n\tflags.Var(\n\t\tsizes.NewThresholdFlagValue(&threshold, 1),\n\t\t\"no-verbose\", \"report statistics that are at all concerning\",\n\t)\n\tflags.Lookup(\"no-verbose\").NoOptDefVal = \"true\"\n\n\tflags.Var(\n\t\t&threshold, \"threshold\",\n\t\t\"minimum level of concern (i.e., number of stars) that should be\\n\"+\n\t\t\t\"                              reported\",\n\t)\n\n\tflags.Var(\n\t\tsizes.NewThresholdFlagValue(&threshold, 30),\n\t\t\"critical\", \"only report critical statistics\",\n\t)\n\tflags.Lookup(\"critical\").NoOptDefVal = \"true\"\n\n\tflags.Var(\n\t\t&nameStyle, \"names\",\n\t\t\"display names of large objects in the specified `style`:\\n\"+\n\t\t\t\"        --names=none            omit footnotes entirely\\n\"+\n\t\t\t\"        --names=hash            show only the SHA-1s of objects\\n\"+\n\t\t\t\"        --names=full            show full names\",\n\t)\n\n\tflags.BoolVarP(&jsonOutput, \"json\", \"j\", false, \"output results in JSON format\")\n\tflags.IntVar(&jsonVersion, \"json-version\", 1, \"JSON format version to output (1 or 2)\")\n\n\tdefaultProgress := false\n\tif f, ok := stderr.(*os.File); ok {\n\t\tatty, err := isatty.Isatty(f.Fd())\n\t\tif err == nil && atty {\n\t\t\tdefaultProgress = true\n\t\t}\n\t}\n\n\tflags.BoolVar(&progress, \"progress\", defaultProgress, \"report progress to stderr\")\n\tflags.BoolVar(&version, \"version\", false, \"report the git-sizer version number\")\n\tflags.Var(&NegatedBoolValue{&progress}, \"no-progress\", \"suppress progress output\")\n\tflags.Lookup(\"no-progress\").NoOptDefVal = \"true\"\n\n\tflags.StringVar(&cpuprofile, \"cpuprofile\", \"\", \"write cpu profile to file\")\n\tif err := flags.MarkHidden(\"cpuprofile\"); err != nil {\n\t\treturn fmt.Errorf(\"marking option hidden: %w\", err)\n\t}\n\n\tvar configger refopts.Configger\n\tif repo != nil {\n\t\tconfigger = repo\n\t}\n\n\trgb, err := refopts.NewRefGroupBuilder(configger)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trgb.AddRefopts(flags)\n\n\tflags.BoolVar(&showRefs, \"show-refs\", false, \"list the references being processed\")\n\n\tflags.SortFlags = false\n\n\terr = flags.Parse(args)\n\tif err != nil {\n\t\tif errors.Is(err, pflag.ErrHelp) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tif cpuprofile != \"\" {\n\t\tf, err := os.Create(cpuprofile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't set up cpuprofile file: %w\", err)\n\t\t}\n\t\tif err := pprof.StartCPUProfile(f); err != nil {\n\t\t\treturn fmt.Errorf(\"starting CPU profiling: %w\", err)\n\t\t}\n\t\tdefer pprof.StopCPUProfile()\n\t}\n\n\tif version {\n\t\tif ReleaseVersion != \"\" {\n\t\t\tfmt.Fprintf(stdout, \"git-sizer release %s\\n\", ReleaseVersion)\n\t\t} else {\n\t\t\tfmt.Fprintf(stdout, \"git-sizer build %s\\n\", BuildVersion)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif repoErr != nil {\n\t\treturn fmt.Errorf(\"couldn't open Git repository: %w\", repoErr)\n\t}\n\n\tif jsonOutput {\n\t\tif !flags.Changed(\"json-version\") {\n\t\t\tv, err := repo.ConfigIntDefault(\"sizer.jsonVersion\", jsonVersion)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tjsonVersion = v\n\t\t\tif !(jsonVersion == 1 || jsonVersion == 2) {\n\t\t\t\treturn fmt.Errorf(\"JSON version (read from gitconfig) must be 1 or 2\")\n\t\t\t}\n\t\t} else if !(jsonVersion == 1 || jsonVersion == 2) {\n\t\t\treturn fmt.Errorf(\"JSON version must be 1 or 2\")\n\t\t}\n\t}\n\n\tif !flags.Changed(\"threshold\") &&\n\t\t!flags.Changed(\"verbose\") &&\n\t\t!flags.Changed(\"no-verbose\") &&\n\t\t!flags.Changed(\"critical\") {\n\t\ts, err := repo.ConfigStringDefault(\"sizer.threshold\", fmt.Sprintf(\"%g\", threshold))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv, err := strconv.ParseFloat(s, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing gitconfig value for 'sizer.threshold': %w\", err)\n\t\t}\n\t\tthreshold = sizes.Threshold(v)\n\t}\n\n\tif !flags.Changed(\"names\") {\n\t\ts, err := repo.ConfigStringDefault(\"sizer.names\", \"full\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = nameStyle.Set(s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing gitconfig value for 'sizer.names': %w\", err)\n\t\t}\n\t}\n\n\tif !flags.Changed(\"progress\") && !flags.Changed(\"no-progress\") {\n\t\tv, err := repo.ConfigBoolDefault(\"sizer.progress\", progress)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"parsing gitconfig value for 'sizer.progress': %w\", err)\n\t\t}\n\t\tprogress = v\n\t}\n\n\trg, err := rgb.Finish(len(flags.Args()) == 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif showRefs {\n\t\tfmt.Fprintf(stderr, \"References (included references marked with '+'):\\n\")\n\t\trg = refopts.NewShowRefGrouper(rg, stderr)\n\t}\n\n\tvar progressMeter meter.Progress = meter.NoProgressMeter\n\tif progress {\n\t\tprogressMeter = meter.NewProgressMeter(stderr, 100*time.Millisecond)\n\t}\n\n\trefRoots, err := sizes.CollectReferences(ctx, repo, rg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"determining which reference to scan: %w\", err)\n\t}\n\n\troots := make([]sizes.Root, 0, len(refRoots)+len(flags.Args()))\n\tfor _, refRoot := range refRoots {\n\t\troots = append(roots, refRoot)\n\t}\n\n\tfor _, arg := range flags.Args() {\n\t\toid, err := repo.ResolveObject(arg)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"resolving command-line argument %q: %w\", arg, err)\n\t\t}\n\t\troots = append(roots, sizes.NewExplicitRoot(arg, oid))\n\t}\n\n\thistorySize, err := sizes.ScanRepositoryUsingGraph(\n\t\tctx, repo, roots, nameStyle, progressMeter,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error scanning repository: %w\", err)\n\t}\n\n\tif jsonOutput {\n\t\tvar j []byte\n\t\tvar err error\n\t\tswitch jsonVersion {\n\t\tcase 1:\n\t\t\tj, err = json.MarshalIndent(historySize, \"\", \"    \")\n\t\tcase 2:\n\t\t\tj, err = historySize.JSON(rg.Groups(), threshold, nameStyle)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"JSON version must be 1 or 2\")\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not convert %v to json: %w\", historySize, err)\n\t\t}\n\t\tfmt.Fprintf(stdout, \"%s\\n\", j)\n\t} else {\n\t\tif _, err := io.WriteString(\n\t\t\tstdout, historySize.TableString(rg.Groups(), threshold, nameStyle),\n\t\t); err != nil {\n\t\t\treturn fmt.Errorf(\"writing output: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "git",
          "type": "tree",
          "content": null
        },
        {
          "name": "git_sizer_test.go",
          "type": "blob",
          "size": 26.8564453125,
          "content": "package main_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/github/git-sizer/counts\"\n\t\"github.com/github/git-sizer/git\"\n\t\"github.com/github/git-sizer/internal/testutils\"\n\t\"github.com/github/git-sizer/meter\"\n\t\"github.com/github/git-sizer/sizes\"\n)\n\nfunc sizerExe(t *testing.T) string {\n\tt.Helper()\n\n\tvar v string\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tv = `bin\\git-sizer.exe`\n\tdefault:\n\t\tv = \"bin/git-sizer\"\n\t}\n\n\tv, err := exec.LookPath(v)\n\trequire.NoError(t, err)\n\n\tv, err = filepath.Abs(v)\n\trequire.NoError(t, err)\n\n\treturn v\n}\n\n// Smoke test that the program runs.\nfunc TestExec(t *testing.T) {\n\tcmd := exec.Command(sizerExe(t))\n\toutput, err := cmd.CombinedOutput()\n\tassert.NoErrorf(t, err, \"command failed; output: %#v\", string(output))\n}\n\nfunc newGitBomb(t *testing.T, repo *testutils.TestRepo, depth, breadth int, body string) {\n\tt.Helper()\n\n\toid := repo.CreateObject(t, \"blob\", func(w io.Writer) error {\n\t\t_, err := io.WriteString(w, body)\n\t\treturn err\n\t})\n\n\tdigits := len(fmt.Sprintf(\"%d\", breadth-1))\n\n\tmode := \"100644\"\n\tprefix := \"f\"\n\n\tfor ; depth > 0; depth-- {\n\t\toid = repo.CreateObject(t, \"tree\", func(w io.Writer) error {\n\t\t\tfor i := 0; i < breadth; i++ {\n\t\t\t\t_, err := fmt.Fprintf(\n\t\t\t\t\tw, \"%s %s%0*d\\x00%s\",\n\t\t\t\t\tmode, prefix, digits, i, oid.Bytes(),\n\t\t\t\t)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tmode = \"40000\"\n\t\tprefix = \"d\"\n\t}\n\n\toid = repo.CreateObject(t, \"commit\", func(w io.Writer) error {\n\t\t_, err := fmt.Fprintf(\n\t\t\tw,\n\t\t\t\"tree %s\\n\"+\n\t\t\t\t\"author Example <example@example.com> 1112911993 -0700\\n\"+\n\t\t\t\t\"committer Example <example@example.com> 1112911993 -0700\\n\"+\n\t\t\t\t\"\\n\"+\n\t\t\t\t\"Test git bomb\\n\",\n\t\t\toid,\n\t\t)\n\t\treturn err\n\t})\n\n\trepo.UpdateRef(t, \"refs/heads/master\", oid)\n}\n\n// TestRefSelections tests various combinations of reference selection\n// options.\nfunc TestRefSelections(t *testing.T) {\n\tt.Parallel()\n\n\treferences := []struct {\n\t\t// The plusses and spaces in the `results` string correspond\n\t\t// to the expected results for one of the tests: `results[i]`\n\t\t// tells whether we expect `refname` to be included ('+') or\n\t\t// excluded (' ') in test case number `i`.\n\t\tresults string\n\n\t\trefname string\n\t}{\n\t\t//nolint:gocritic // Want columns in comment to match initializers.\n\t\t//          111111111\n\t\t//0123456789012345678\n\t\t{\"+ + + + + + +   + +\", \"refs/barfoo\"},\n\t\t{\"+ + + + + + +++    \", \"refs/foo\"},\n\t\t{\"+ + + + + + +   + +\", \"refs/foobar\"},\n\t\t{\"++  + + + +++   +++\", \"refs/heads/foo\"},\n\t\t{\"++  + + + ++    +++\", \"refs/heads/master\"},\n\t\t{\"+ + + ++  +        \", \"refs/notes/discussion\"},\n\t\t{\"+ + ++  + +        \", \"refs/remotes/origin/master\"},\n\t\t{\"+ + ++  + + +   + +\", \"refs/remotes/upstream/foo\"},\n\t\t{\"+ + ++  + +        \", \"refs/remotes/upstream/master\"},\n\t\t{\"+ + + + ++         \", \"refs/stash\"},\n\t\t{\"+ ++  + + +++   + +\", \"refs/tags/foolish\"},\n\t\t{\"+ ++  + + ++    + +\", \"refs/tags/other\"},\n\t\t{\"+ ++  + + ++   +   \", \"refs/tags/release-1\"},\n\t\t{\"+ ++  + + ++   +   \", \"refs/tags/release-2\"},\n\t}\n\n\t// computeExpectations assembles and returns the results expected\n\t// for test `i` from the `references` slice.\n\tcomputeExpectations := func(i int) (string, int) {\n\t\tvar sb strings.Builder\n\t\tfmt.Fprintln(&sb, \"References (included references marked with '+'):\")\n\t\tcount := 0\n\t\tfor _, p := range references {\n\t\t\tpresent := p.results[i]\n\t\t\tfmt.Fprintf(&sb, \"%c %s\\n\", present, p.refname)\n\t\t\tif present == '+' {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\treturn sb.String(), count\n\t}\n\n\t// Create a test repo with one orphan commit per refname:\n\trepo := testutils.NewTestRepo(t, true, \"ref-selection\")\n\tt.Cleanup(func() { repo.Remove(t) })\n\n\tfor _, p := range references {\n\t\trepo.CreateReferencedOrphan(t, p.refname)\n\t}\n\n\texecutable := sizerExe(t)\n\n\tfor i, p := range []struct {\n\t\tname   string\n\t\targs   []string\n\t\tconfig []git.ConfigEntry\n\t}{\n\t\t{ // 0\n\t\t\tname: \"no arguments\",\n\t\t},\n\t\t{ // 1\n\t\t\tname: \"branches\",\n\t\t\targs: []string{\"--branches\"},\n\t\t},\n\t\t{ // 2\n\t\t\tname: \"no branches\",\n\t\t\targs: []string{\"--no-branches\"},\n\t\t},\n\t\t{ // 3\n\t\t\tname: \"tags\",\n\t\t\targs: []string{\"--tags\"},\n\t\t},\n\t\t{ // 4\n\t\t\tname: \"no tags\",\n\t\t\targs: []string{\"--no-tags\"},\n\t\t},\n\t\t{ // 5\n\t\t\tname: \"remotes\",\n\t\t\targs: []string{\"--remotes\"},\n\t\t},\n\t\t{ // 6\n\t\t\tname: \"no remotes\",\n\t\t\targs: []string{\"--no-remotes\"},\n\t\t},\n\t\t{ // 7\n\t\t\tname: \"notes\",\n\t\t\targs: []string{\"--notes\"},\n\t\t},\n\t\t{ // 8\n\t\t\tname: \"no notes\",\n\t\t\targs: []string{\"--no-notes\"},\n\t\t},\n\t\t{ // 9\n\t\t\tname: \"stash\",\n\t\t\targs: []string{\"--stash\"},\n\t\t},\n\t\t{ // 10\n\t\t\tname: \"no stash\",\n\t\t\targs: []string{\"--no-stash\"},\n\t\t},\n\t\t{ // 11\n\t\t\tname: \"branches and tags\",\n\t\t\targs: []string{\"--branches\", \"--tags\"},\n\t\t},\n\t\t{ // 12\n\t\t\tname: \"foo\",\n\t\t\targs: []string{\"--include\", \"/.*foo.*/\"},\n\t\t},\n\t\t{ // 13\n\t\t\tname: \"refs/foo as prefix\",\n\t\t\targs: []string{\"--include\", \"refs/foo\"},\n\t\t},\n\t\t{ // 14\n\t\t\tname: \"refs/foo as regexp\",\n\t\t\targs: []string{\"--include\", \"/refs/foo/\"},\n\t\t},\n\t\t{ // 15\n\t\t\tname: \"release tags\",\n\t\t\targs: []string{\"--include\", \"/refs/tags/release-.*/\"},\n\t\t},\n\t\t{ // 16\n\t\t\tname: \"combination\",\n\t\t\targs: []string{\n\t\t\t\t\"--include=refs/heads\",\n\t\t\t\t\"--tags\",\n\t\t\t\t\"--exclude\", \"refs/heads/foo\",\n\t\t\t\t\"--include\", \"/.*foo.*/\",\n\t\t\t\t\"--exclude\", \"refs/foo\",\n\t\t\t\t\"--exclude\", \"/refs/tags/release-.*/\",\n\t\t\t},\n\t\t},\n\t\t{ // 17\n\t\t\tname: \"branches-refgroup\",\n\t\t\targs: []string{\"--include=@mygroup\"},\n\t\t\tconfig: []git.ConfigEntry{\n\t\t\t\t{Key: \"refgroup.mygroup.include\", Value: \"refs/heads\"},\n\t\t\t},\n\t\t},\n\t\t{ // 18\n\t\t\tname: \"combination-refgroup\",\n\t\t\targs: []string{\"--include=@mygroup\"},\n\t\t\tconfig: []git.ConfigEntry{\n\t\t\t\t{Key: \"refgroup.mygroup.include\", Value: \"refs/heads\"},\n\t\t\t\t{Key: \"refgroup.mygroup.include\", Value: \"refs/tags\"},\n\t\t\t\t{Key: \"refgroup.mygroup.exclude\", Value: \"refs/heads/foo\"},\n\t\t\t\t{Key: \"refgroup.mygroup.includeRegexp\", Value: \".*foo.*\"},\n\t\t\t\t{Key: \"refgroup.mygroup.exclude\", Value: \"refs/foo\"},\n\t\t\t\t{Key: \"refgroup.mygroup.excludeRegexp\", Value: \"refs/tags/release-.*\"},\n\t\t\t},\n\t\t},\n\t} {\n\t\ti, p := i, p\n\t\tt.Run(\n\t\t\tp.name,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\trepo := repo.Clone(t, \"ref-selection\")\n\t\t\t\tdefer repo.Remove(t)\n\n\t\t\t\tfor _, e := range p.config {\n\t\t\t\t\trepo.ConfigAdd(t, e.Key, e.Value)\n\t\t\t\t}\n\n\t\t\t\targs := []string{\"--show-refs\", \"--no-progress\", \"--json\", \"--json-version=2\"}\n\t\t\t\targs = append(args, p.args...)\n\t\t\t\tcmd := exec.Command(executable, args...)\n\t\t\t\tcmd.Env = append(\n\t\t\t\t\tos.Environ(),\n\t\t\t\t\t\"GIT_DIR=\"+repo.Path,\n\t\t\t\t)\n\t\t\t\tvar stdout bytes.Buffer\n\t\t\t\tcmd.Stdout = &stdout\n\t\t\t\tvar stderr bytes.Buffer\n\t\t\t\tcmd.Stderr = &stderr\n\t\t\t\terr := cmd.Run()\n\t\t\t\tassert.NoError(t, err)\n\n\t\t\t\texpectedStderr, expectedUniqueCommitCount := computeExpectations(i)\n\n\t\t\t\t// Make sure that the right number of commits was scanned:\n\t\t\t\tvar v struct {\n\t\t\t\t\tUniqueCommitCount struct {\n\t\t\t\t\t\tValue int\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terr = json.Unmarshal(stdout.Bytes(), &v)\n\t\t\t\tif assert.NoError(t, err) {\n\t\t\t\t\tassert.EqualValues(t, expectedUniqueCommitCount, v.UniqueCommitCount.Value)\n\t\t\t\t}\n\n\t\t\t\t// Make sure that the right references were reported scanned:\n\t\t\t\tassert.Equal(t, expectedStderr, stderr.String())\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestRefgroups(t *testing.T) {\n\tt.Parallel()\n\n\treferences := []string{\n\t\t\"refs/changes/20/884120/1\",\n\t\t\"refs/changes/45/12345/42\",\n\t\t\"refs/fo\",\n\t\t\"refs/foo\",\n\t\t\"refs/heads/foo\",\n\t\t\"refs/heads/main\",\n\t\t\"refs/notes/discussion\",\n\t\t\"refs/notes/tests/build\",\n\t\t\"refs/notes/tests/default\",\n\t\t\"refs/pull/1/head\",\n\t\t\"refs/pull/1/merge\",\n\t\t\"refs/pull/123/head\",\n\t\t\"refs/pull/1234/head\",\n\t\t\"refs/remotes/origin/master\",\n\t\t\"refs/remotes/upstream/foo\",\n\t\t\"refs/remotes/upstream/master\",\n\t\t\"refs/stash\",\n\t\t\"refs/tags/foolish\",\n\t\t\"refs/tags/other\",\n\t\t\"refs/tags/release-1\",\n\t\t\"refs/tags/release-2\",\n\t}\n\n\t// Create a test repo with one orphan commit per refname:\n\trepo := testutils.NewTestRepo(t, true, \"refgroups\")\n\tt.Cleanup(func() { repo.Remove(t) })\n\n\tfor _, refname := range references {\n\t\trepo.CreateReferencedOrphan(t, refname)\n\t}\n\n\texecutable := sizerExe(t)\n\n\tfor _, p := range []struct {\n\t\tname   string\n\t\targs   []string\n\t\tconfig []git.ConfigEntry\n\t\tstdout string\n\t\tstderr string\n\t}{\n\t\t{\n\t\t\tname: \"no arguments\",\n\t\t\tstdout: `\n| * References                 |           |                                |\n|   * Count                    |    21     |                                |\n|     * Branches               |     2     |                                |\n|     * Tags                   |     4     |                                |\n|     * Remote-tracking refs   |     3     |                                |\n|     * Pull request refs      |     4     |                                |\n|     * Changeset refs         |     2     |                                |\n|     * Git notes              |     3     |                                |\n|     * Git stash              |     1     |                                |\n|     * Other                  |     2     |                                |\n|                              |           |                                |\n`[1:],\n\t\t\tstderr: `\nReferences (included references marked with '+'):\n+ refs/changes/20/884120/1\n+ refs/changes/45/12345/42\n+ refs/fo\n+ refs/foo\n+ refs/heads/foo\n+ refs/heads/main\n+ refs/notes/discussion\n+ refs/notes/tests/build\n+ refs/notes/tests/default\n+ refs/pull/1/head\n+ refs/pull/1/merge\n+ refs/pull/123/head\n+ refs/pull/1234/head\n+ refs/remotes/origin/master\n+ refs/remotes/upstream/foo\n+ refs/remotes/upstream/master\n+ refs/stash\n+ refs/tags/foolish\n+ refs/tags/other\n+ refs/tags/release-1\n+ refs/tags/release-2\n`[1:],\n\t\t},\n\t\t{\n\t\t\tname: \"nested-groups\",\n\t\t\tconfig: []git.ConfigEntry{\n\t\t\t\t// Note that refgroup \"misc\" is defined implicitly.\n\n\t\t\t\t{Key: \"refgroup.misc.foo.includeRegexp\", Value: \".*foo.*\"},\n\n\t\t\t\t{Key: \"refgroup.misc.foo.oatend.includeRegexp\", Value: \".*o\"},\n\n\t\t\t\t{Key: \"refgroup.misc.foo.bogus.include\", Value: \"bogus\"},\n\n\t\t\t\t{Key: \"refgroup.tags.releases.name\", Value: \"Releases\"},\n\t\t\t\t{Key: \"refgroup.tags.releases.includeRegexp\", Value: \"refs/tags/release-.*\"},\n\t\t\t},\n\t\t\tstdout: `\n| * References                 |           |                                |\n|   * Count                    |    21     |                                |\n|     * Branches               |     2     |                                |\n|     * Tags                   |     4     |                                |\n|       * Releases             |     2     |                                |\n|       * Other                |     2     |                                |\n|     * Remote-tracking refs   |     3     |                                |\n|     * Pull request refs      |     4     |                                |\n|     * Changeset refs         |     2     |                                |\n|     * Git notes              |     3     |                                |\n|     * Git stash              |     1     |                                |\n|     * misc                   |     4     |                                |\n|       * foo                  |     4     |                                |\n|         * oatend             |     3     |                                |\n|         * Other              |     1     |                                |\n|     * Other                  |     1     |                                |\n|                              |           |                                |\n`[1:],\n\t\t},\n\t\t{\n\t\t\tname: \"include-refgroups\",\n\t\t\targs: []string{\"--include=@branches\", \"--include=@tags.releases\", \"--include=@oatend\"},\n\t\t\tconfig: []git.ConfigEntry{\n\t\t\t\t{Key: \"refgroup.oatend.includeRegexp\", Value: \".*o\"},\n\n\t\t\t\t{Key: \"refgroup.tags.releases.name\", Value: \"Releases\"},\n\t\t\t\t{Key: \"refgroup.tags.releases.includeRegexp\", Value: \"refs/tags/release-.*\"},\n\t\t\t},\n\t\t\tstdout: `\n| * References                 |           |                                |\n|   * Count                    |    21     |                                |\n|     * Branches               |     2     |                                |\n|     * Tags                   |     2     |                                |\n|       * Releases             |     2     |                                |\n|     * Remote-tracking refs   |     1     |                                |\n|     * oatend                 |     4     |                                |\n|     * Ignored                |    14     |                                |\n|                              |           |                                |\n`[1:],\n\t\t\tstderr: `\nReferences (included references marked with '+'):\n  refs/changes/20/884120/1\n  refs/changes/45/12345/42\n+ refs/fo\n+ refs/foo\n+ refs/heads/foo\n+ refs/heads/main\n  refs/notes/discussion\n  refs/notes/tests/build\n  refs/notes/tests/default\n  refs/pull/1/head\n  refs/pull/1/merge\n  refs/pull/123/head\n  refs/pull/1234/head\n  refs/remotes/origin/master\n+ refs/remotes/upstream/foo\n  refs/remotes/upstream/master\n  refs/stash\n  refs/tags/foolish\n  refs/tags/other\n+ refs/tags/release-1\n+ refs/tags/release-2\n`[1:],\n\t\t},\n\t\t{\n\t\t\tname: \"exclude-refgroup\",\n\t\t\targs: []string{\"--exclude=@stash\", \"--exclude=@notes\"},\n\t\t\tstdout: `\n| * References                 |           |                                |\n|   * Count                    |    21     |                                |\n|     * Branches               |     2     |                                |\n|     * Tags                   |     4     |                                |\n|     * Remote-tracking refs   |     3     |                                |\n|     * Pull request refs      |     4     |                                |\n|     * Changeset refs         |     2     |                                |\n|     * Other                  |     2     |                                |\n|     * Ignored                |     4     |                                |\n|                              |           |                                |\n`[1:],\n\t\t\tstderr: `\nReferences (included references marked with '+'):\n+ refs/changes/20/884120/1\n+ refs/changes/45/12345/42\n+ refs/fo\n+ refs/foo\n+ refs/heads/foo\n+ refs/heads/main\n  refs/notes/discussion\n  refs/notes/tests/build\n  refs/notes/tests/default\n+ refs/pull/1/head\n+ refs/pull/1/merge\n+ refs/pull/123/head\n+ refs/pull/1234/head\n+ refs/remotes/origin/master\n+ refs/remotes/upstream/foo\n+ refs/remotes/upstream/master\n  refs/stash\n+ refs/tags/foolish\n+ refs/tags/other\n+ refs/tags/release-1\n+ refs/tags/release-2\n`[1:],\n\t\t},\n\t} {\n\t\tp := p\n\t\tt.Run(\n\t\t\tp.name,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\trepo := repo.Clone(t, \"refgroups\")\n\t\t\t\tdefer repo.Remove(t)\n\n\t\t\t\tfor _, e := range p.config {\n\t\t\t\t\trepo.ConfigAdd(t, e.Key, e.Value)\n\t\t\t\t}\n\n\t\t\t\targs := append([]string{\"--show-refs\", \"-v\", \"--no-progress\"}, p.args...)\n\t\t\t\tcmd := exec.Command(executable, args...)\n\t\t\t\tcmd.Env = append(\n\t\t\t\t\tos.Environ(),\n\t\t\t\t\t\"GIT_DIR=\"+repo.Path,\n\t\t\t\t)\n\t\t\t\tvar stdout bytes.Buffer\n\t\t\t\tcmd.Stdout = &stdout\n\t\t\t\tvar stderr bytes.Buffer\n\t\t\t\tcmd.Stderr = &stderr\n\t\t\t\terr := cmd.Run()\n\t\t\t\tassert.NoError(t, err)\n\n\t\t\t\tassert.Contains(t, stdout.String(), p.stdout)\n\t\t\t\tif p.stderr != \"\" {\n\t\t\t\t\tassert.Equal(t, stderr.String(), p.stderr)\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc pow(x uint64, n int) uint64 {\n\tp := uint64(1)\n\tfor ; n > 0; n-- {\n\t\tp *= x\n\t}\n\treturn p\n}\n\ntype refGrouper struct{}\n\nfunc (rg refGrouper) Categorize(refname string) (bool, []sizes.RefGroupSymbol) {\n\treturn true, nil\n}\n\nfunc (rg refGrouper) Groups() []sizes.RefGroup {\n\treturn nil\n}\n\nfunc TestBomb(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\n\ttestRepo := testutils.NewTestRepo(t, true, \"bomb\")\n\tt.Cleanup(func() { testRepo.Remove(t) })\n\n\tnewGitBomb(t, testRepo, 10, 10, \"boom!\\n\")\n\n\trepo := testRepo.Repository(t)\n\n\tt.Run(\"full\", func(t *testing.T) {\n\t\trefRoots, err := sizes.CollectReferences(ctx, repo, refGrouper{})\n\t\trequire.NoError(t, err)\n\n\t\troots := make([]sizes.Root, 0, len(refRoots))\n\t\tfor _, refRoot := range refRoots {\n\t\t\troots = append(roots, refRoot)\n\t\t}\n\n\t\th, err := sizes.ScanRepositoryUsingGraph(\n\t\t\tctx, repo, roots, sizes.NameStyleFull, meter.NoProgressMeter,\n\t\t)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, counts.Count32(1), h.UniqueCommitCount, \"unique commit count\")\n\t\tassert.Equal(t, counts.Count64(172), h.UniqueCommitSize, \"unique commit size\")\n\t\tassert.Equal(t, counts.Count32(172), h.MaxCommitSize, \"max commit size\")\n\t\tassert.Equal(t, \"refs/heads/master\", h.MaxCommitSizeCommit.BestPath(), \"max commit size commit\")\n\t\tassert.Equal(t, counts.Count32(1), h.MaxHistoryDepth, \"max history depth\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxParentCount, \"max parent count\")\n\t\tassert.Equal(t, \"refs/heads/master\", h.MaxParentCountCommit.BestPath(), \"max parent count commit\")\n\n\t\tassert.Equal(t, counts.Count32(10), h.UniqueTreeCount, \"unique tree count\")\n\t\tassert.Equal(t, counts.Count64(2910), h.UniqueTreeSize, \"unique tree size\")\n\t\tassert.Equal(t, counts.Count64(100), h.UniqueTreeEntries, \"unique tree entries\")\n\t\tassert.Equal(t, counts.Count32(10), h.MaxTreeEntries, \"max tree entries\")\n\t\tassert.Equal(t, \"refs/heads/master:d0/d0/d0/d0/d0/d0/d0/d0/d0\", h.MaxTreeEntriesTree.BestPath(), \"max tree entries tree\")\n\n\t\tassert.Equal(t, counts.Count32(1), h.UniqueBlobCount, \"unique blob count\")\n\t\tassert.Equal(t, counts.Count64(6), h.UniqueBlobSize, \"unique blob size\")\n\t\tassert.Equal(t, counts.Count32(6), h.MaxBlobSize, \"max blob size\")\n\t\tassert.Equal(t, \"refs/heads/master:d0/d0/d0/d0/d0/d0/d0/d0/d0/f0\", h.MaxBlobSizeBlob.BestPath(), \"max blob size blob\")\n\n\t\tassert.Equal(t, counts.Count32(0), h.UniqueTagCount, \"unique tag count\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxTagDepth, \"max tag depth\")\n\n\t\tassert.Equal(t, counts.Count32(1), h.ReferenceCount, \"reference count\")\n\n\t\tassert.Equal(t, counts.Count32(10), h.MaxPathDepth, \"max path depth\")\n\t\tassert.Equal(t, \"refs/heads/master^{tree}\", h.MaxPathDepthTree.BestPath(), \"max path depth tree\")\n\t\tassert.Equal(t, counts.Count32(29), h.MaxPathLength, \"max path length\")\n\t\tassert.Equal(t, \"refs/heads/master^{tree}\", h.MaxPathLengthTree.BestPath(), \"max path length tree\")\n\n\t\tassert.Equal(t, counts.Count32((pow(10, 10)-1)/(10-1)), h.MaxExpandedTreeCount, \"max expanded tree count\")\n\t\tassert.Equal(t, \"refs/heads/master^{tree}\", h.MaxExpandedTreeCountTree.BestPath(), \"max expanded tree count tree\")\n\t\tassert.Equal(t, counts.Count32(0xffffffff), h.MaxExpandedBlobCount, \"max expanded blob count\")\n\t\tassert.Equal(t, \"refs/heads/master^{tree}\", h.MaxExpandedBlobCountTree.BestPath(), \"max expanded blob count tree\")\n\t\tassert.Equal(t, counts.Count64(6*pow(10, 10)), h.MaxExpandedBlobSize, \"max expanded blob size\")\n\t\tassert.Equal(t, \"refs/heads/master^{tree}\", h.MaxExpandedBlobSizeTree.BestPath(), \"max expanded blob size tree\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxExpandedLinkCount, \"max expanded link count\")\n\t\tassert.Nil(t, h.MaxExpandedLinkCountTree, \"max expanded link count tree\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxExpandedSubmoduleCount, \"max expanded submodule count\")\n\t\tassert.Nil(t, h.MaxExpandedSubmoduleCountTree, \"max expanded submodule count tree\")\n\t})\n\n\tt.Run(\"partial\", func(t *testing.T) {\n\t\tname := \"master:d0/d0\"\n\t\toid, err := repo.ResolveObject(name)\n\t\trequire.NoError(t, err)\n\t\troots := []sizes.Root{sizes.NewExplicitRoot(name, oid)}\n\n\t\th, err := sizes.ScanRepositoryUsingGraph(\n\t\t\tctx, repo, roots, sizes.NameStyleFull, meter.NoProgressMeter,\n\t\t)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, counts.Count32(0), h.UniqueCommitCount, \"unique commit count\")\n\t\tassert.Equal(t, counts.Count64(0), h.UniqueCommitSize, \"unique commit size\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxCommitSize, \"max commit size\")\n\t\tassert.Nil(t, h.MaxCommitSizeCommit)\n\t\tassert.Equal(t, counts.Count32(0), h.MaxHistoryDepth, \"max history depth\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxParentCount, \"max parent count\")\n\t\tassert.Nil(t, h.MaxParentCountCommit, \"max parent count commit\")\n\n\t\tassert.Equal(t, counts.Count32(8), h.UniqueTreeCount, \"unique tree count\")\n\t\tassert.Equal(t, counts.Count64(2330), h.UniqueTreeSize, \"unique tree size\")\n\t\tassert.Equal(t, counts.Count64(80), h.UniqueTreeEntries, \"unique tree entries\")\n\t\tassert.Equal(t, counts.Count32(10), h.MaxTreeEntries, \"max tree entries\")\n\t\tassert.Equal(t, \"master:d0/d0/d0/d0/d0/d0/d0/d0/d0\", h.MaxTreeEntriesTree.BestPath(), \"max tree entries tree\")\n\n\t\tassert.Equal(t, counts.Count32(1), h.UniqueBlobCount, \"unique blob count\")\n\t\tassert.Equal(t, counts.Count64(6), h.UniqueBlobSize, \"unique blob size\")\n\t\tassert.Equal(t, counts.Count32(6), h.MaxBlobSize, \"max blob size\")\n\t\tassert.Equal(t, \"master:d0/d0/d0/d0/d0/d0/d0/d0/d0/f0\", h.MaxBlobSizeBlob.BestPath(), \"max blob size blob\")\n\n\t\tassert.Equal(t, counts.Count32(0), h.UniqueTagCount, \"unique tag count\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxTagDepth, \"max tag depth\")\n\n\t\tassert.Equal(t, counts.Count32(0), h.ReferenceCount, \"reference count\")\n\n\t\tassert.Equal(t, counts.Count32(8), h.MaxPathDepth, \"max path depth\")\n\t\tassert.Equal(t, \"master:d0/d0\", h.MaxPathDepthTree.BestPath(), \"max path depth tree\")\n\t\tassert.Equal(t, counts.Count32(23), h.MaxPathLength, \"max path length\")\n\t\tassert.Equal(t, \"master:d0/d0\", h.MaxPathLengthTree.BestPath(), \"max path length tree\")\n\n\t\tassert.Equal(t, counts.Count32((pow(10, 8)-1)/(10-1)), h.MaxExpandedTreeCount, \"max expanded tree count\")\n\t\tassert.Equal(t, \"master:d0/d0\", h.MaxExpandedTreeCountTree.BestPath(), \"max expanded tree count tree\")\n\t\tassert.Equal(t, counts.Count32(pow(10, 8)), h.MaxExpandedBlobCount, \"max expanded blob count\")\n\t\tassert.Equal(t, \"master:d0/d0\", h.MaxExpandedBlobCountTree.BestPath(), \"max expanded blob count tree\")\n\t\tassert.Equal(t, counts.Count64(6*pow(10, 8)), h.MaxExpandedBlobSize, \"max expanded blob size\")\n\t\tassert.Equal(t, \"master:d0/d0\", h.MaxExpandedBlobSizeTree.BestPath(), \"max expanded blob size tree\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxExpandedLinkCount, \"max expanded link count\")\n\t\tassert.Nil(t, h.MaxExpandedLinkCountTree, \"max expanded link count tree\")\n\t\tassert.Equal(t, counts.Count32(0), h.MaxExpandedSubmoduleCount, \"max expanded submodule count\")\n\t\tassert.Nil(t, h.MaxExpandedSubmoduleCountTree, \"max expanded submodule count tree\")\n\t})\n}\n\nfunc TestTaggedTags(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\n\ttestRepo := testutils.NewTestRepo(t, false, \"tagged-tags\")\n\tdefer testRepo.Remove(t)\n\n\ttimestamp := time.Unix(1112911993, 0)\n\n\tcmd := testRepo.GitCommand(t, \"commit\", \"-m\", \"initial\", \"--allow-empty\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating commit\")\n\n\t// The lexicographical order of these tags is important, hence\n\t// their strange names.\n\tcmd = testRepo.GitCommand(t, \"tag\", \"-m\", \"tag 1\", \"tag\", \"master\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating tag 1\")\n\n\tcmd = testRepo.GitCommand(t, \"tag\", \"-m\", \"tag 2\", \"bag\", \"tag\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating tag 2\")\n\n\tcmd = testRepo.GitCommand(t, \"tag\", \"-m\", \"tag 3\", \"wag\", \"bag\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating tag 3\")\n\n\trepo := testRepo.Repository(t)\n\n\trefRoots, err := sizes.CollectReferences(ctx, repo, refGrouper{})\n\trequire.NoError(t, err)\n\n\troots := make([]sizes.Root, 0, len(refRoots))\n\tfor _, refRoot := range refRoots {\n\t\troots = append(roots, refRoot)\n\t}\n\n\th, err := sizes.ScanRepositoryUsingGraph(\n\t\tcontext.Background(), repo,\n\t\troots, sizes.NameStyleNone, meter.NoProgressMeter,\n\t)\n\trequire.NoError(t, err, \"scanning repository\")\n\tassert.Equal(t, counts.Count32(3), h.MaxTagDepth, \"tag depth\")\n}\n\nfunc TestFromSubdir(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\n\ttestRepo := testutils.NewTestRepo(t, false, \"subdir\")\n\tdefer testRepo.Remove(t)\n\n\ttimestamp := time.Unix(1112911993, 0)\n\n\ttestRepo.AddFile(t, \"subdir/file.txt\", \"Hello, world!\\n\")\n\n\tcmd := testRepo.GitCommand(t, \"commit\", \"-m\", \"initial\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating commit\")\n\n\trepo := testRepo.Repository(t)\n\n\trefRoots, err := sizes.CollectReferences(ctx, repo, refGrouper{})\n\trequire.NoError(t, err)\n\n\troots := make([]sizes.Root, 0, len(refRoots))\n\tfor _, refRoot := range refRoots {\n\t\troots = append(roots, refRoot)\n\t}\n\n\th, err := sizes.ScanRepositoryUsingGraph(\n\t\tcontext.Background(), testRepo.Repository(t),\n\t\troots, sizes.NameStyleNone, meter.NoProgressMeter,\n\t)\n\trequire.NoError(t, err, \"scanning repository\")\n\tassert.Equal(t, counts.Count32(2), h.MaxPathDepth, \"max path depth\")\n}\n\nfunc TestSubmodule(t *testing.T) {\n\tt.Parallel()\n\n\tctx := context.Background()\n\n\ttmp, err := os.MkdirTemp(\"\", \"submodule\")\n\trequire.NoError(t, err, \"creating temporary directory\")\n\n\tdefer func() {\n\t\tos.RemoveAll(tmp)\n\t}()\n\n\ttimestamp := time.Unix(1112911993, 0)\n\n\tsubmTestRepo := testutils.TestRepo{\n\t\tPath: filepath.Join(tmp, \"subm\"),\n\t}\n\tsubmTestRepo.Init(t, false)\n\tsubmTestRepo.AddFile(t, \"submfile1.txt\", \"Hello, submodule!\\n\")\n\tsubmTestRepo.AddFile(t, \"submfile2.txt\", \"Hello again, submodule!\\n\")\n\tsubmTestRepo.AddFile(t, \"submfile3.txt\", \"Hello again, submodule!\\n\")\n\n\tcmd := submTestRepo.GitCommand(t, \"commit\", \"-m\", \"subm initial\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating subm commit\")\n\n\tmainTestRepo := testutils.TestRepo{\n\t\tPath: filepath.Join(tmp, \"main\"),\n\t}\n\tmainTestRepo.Init(t, false)\n\n\tmainTestRepo.AddFile(t, \"mainfile.txt\", \"Hello, main!\\n\")\n\n\tcmd = mainTestRepo.GitCommand(t, \"commit\", \"-m\", \"main initial\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"creating main commit\")\n\n\t// Make subm a submodule of main:\n\tcmd = mainTestRepo.GitCommand(t, \"-c\", \"protocol.file.allow=always\", \"submodule\", \"add\", submTestRepo.Path, \"sub\")\n\tcmd.Dir = mainTestRepo.Path\n\trequire.NoError(t, cmd.Run(), \"adding submodule\")\n\n\tcmd = mainTestRepo.GitCommand(t, \"commit\", \"-m\", \"add submodule\")\n\ttestutils.AddAuthorInfo(cmd, &timestamp)\n\trequire.NoError(t, cmd.Run(), \"committing submodule to main\")\n\n\tmainRepo := mainTestRepo.Repository(t)\n\n\tmainRefRoots, err := sizes.CollectReferences(ctx, mainRepo, refGrouper{})\n\trequire.NoError(t, err)\n\n\tmainRoots := make([]sizes.Root, 0, len(mainRefRoots))\n\tfor _, refRoot := range mainRefRoots {\n\t\tmainRoots = append(mainRoots, refRoot)\n\t}\n\n\t// Analyze the main repo:\n\th, err := sizes.ScanRepositoryUsingGraph(\n\t\tcontext.Background(), mainTestRepo.Repository(t),\n\t\tmainRoots, sizes.NameStyleNone, meter.NoProgressMeter,\n\t)\n\trequire.NoError(t, err, \"scanning repository\")\n\tassert.Equal(t, counts.Count32(2), h.UniqueBlobCount, \"unique blob count\")\n\tassert.Equal(t, counts.Count32(2), h.MaxExpandedBlobCount, \"max expanded blob count\")\n\tassert.Equal(t, counts.Count32(1), h.MaxExpandedSubmoduleCount, \"max expanded submodule count\")\n\n\t// Analyze the submodule:\n\tsubmTestRepo2 := testutils.TestRepo{\n\t\tPath: filepath.Join(mainTestRepo.Path, \"sub\"),\n\t}\n\n\tsubmRepo2 := submTestRepo2.Repository(t)\n\n\tsubmRefRoots2, err := sizes.CollectReferences(ctx, submRepo2, refGrouper{})\n\trequire.NoError(t, err)\n\n\tsubmRoots2 := make([]sizes.Root, 0, len(submRefRoots2))\n\tfor _, refRoot := range submRefRoots2 {\n\t\tsubmRoots2 = append(submRoots2, refRoot)\n\t}\n\n\th, err = sizes.ScanRepositoryUsingGraph(\n\t\tcontext.Background(), submRepo2,\n\t\tsubmRoots2, sizes.NameStyleNone, meter.NoProgressMeter,\n\t)\n\trequire.NoError(t, err, \"scanning repository\")\n\tassert.Equal(t, counts.Count32(2), h.UniqueBlobCount, \"unique blob count\")\n\tassert.Equal(t, counts.Count32(3), h.MaxExpandedBlobCount, \"max expanded blob count\")\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.478515625,
          "content": "module github.com/github/git-sizer\n\ngo 1.17\n\nrequire (\n\tgithub.com/cli/safeexec v1.0.0\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.8.1\n\tgolang.org/x/sync v0.1.0 // indirect\n)\n\nrequire github.com/github/go-pipe v1.0.2\n\nrequire (\n\tgithub.com/kr/pretty v0.1.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.5390625,
          "content": "github.com/cli/safeexec v1.0.0 h1:0VngyaIyqACHdcMNWfo6+KdUYnqEr2Sg+bSP1pdF+dI=\ngithub.com/cli/safeexec v1.0.0/go.mod h1:Z/D4tTN8Vs5gXYHDCbaM1S/anmEDnJb1iW0+EJ5zx3Q=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/github/go-pipe v1.0.2 h1:befTXflsc6ir/h9f6Q7QCDmfojoBswD1MfQrPhmmSoA=\ngithub.com/github/go-pipe v1.0.2/go.mod h1:/GvNLA516QlfGGMtfv4PC/5/CdzL9X4af/AJYhmLD54=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngo.uber.org/goleak v1.2.0 h1:xqgm/S+aQvhWFTtR0XK3Jvg7z8kGV8P4X14IzwN3Eqk=\ngo.uber.org/goleak v1.2.0/go.mod h1:XJYK+MuIchqpmGmUSAzotztawfKvYLUIgg7guXrwVUo=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0 h1:wsuoTGHzEhffawBOhz5CYhcrV4IdKZbEyZjBMuTp12o=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "isatty",
          "type": "tree",
          "content": null
        },
        {
          "name": "meter",
          "type": "tree",
          "content": null
        },
        {
          "name": "negated_bool_value.go",
          "type": "blob",
          "size": 0.62890625,
          "content": "package main\n\nimport (\n\t\"strconv\"\n)\n\n// NegatedBoolValue is a `pflag.Value` that set a boolean variable to\n// the inverse of what the argument would normally indicate (e.g., to\n// implement `--no-foo`-style arguments).\ntype NegatedBoolValue struct {\n\tvalue *bool\n}\n\nfunc (v *NegatedBoolValue) Set(s string) error {\n\tb, err := strconv.ParseBool(s)\n\t*v.value = !b\n\treturn err\n}\n\nfunc (v *NegatedBoolValue) Get() interface{} {\n\treturn !*v.value\n}\n\nfunc (v *NegatedBoolValue) String() string {\n\tif v == nil || v.value == nil {\n\t\treturn \"true\"\n\t}\n\n\treturn strconv.FormatBool(!*v.value)\n}\n\nfunc (v *NegatedBoolValue) Type() string {\n\treturn \"bool\"\n}\n"
        },
        {
          "name": "script",
          "type": "tree",
          "content": null
        },
        {
          "name": "sizes",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}