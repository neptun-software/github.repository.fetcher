{
  "metadata": {
    "timestamp": 1736566670033,
    "page": 223,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sony/sonyflake",
      "stars": 3990,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0244140625,
          "content": "example/sonyflake_server\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright 2015 Sony Corporation\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.4912109375,
          "content": "Sonyflake\n=========\n\n[![GoDoc](https://godoc.org/github.com/sony/sonyflake?status.svg)](http://godoc.org/github.com/sony/sonyflake)\n[![Go Report Card](https://goreportcard.com/badge/github.com/sony/sonyflake)](https://goreportcard.com/report/github.com/sony/sonyflake)\n\nSonyflake is a distributed unique ID generator inspired by [Twitter's Snowflake](https://blog.twitter.com/2010/announcing-snowflake).  \n\nSonyflake focuses on lifetime and performance on many host/core environment.\nSo it has a different bit assignment from Snowflake.\nA Sonyflake ID is composed of\n\n    39 bits for time in units of 10 msec\n     8 bits for a sequence number\n    16 bits for a machine id\n\nAs a result, Sonyflake has the following advantages and disadvantages:\n\n- The lifetime (174 years) is longer than that of Snowflake (69 years)\n- It can work in more distributed machines (2^16) than Snowflake (2^10)\n- It can generate 2^8 IDs per 10 msec at most in a single machine/thread (slower than Snowflake)\n\nHowever, if you want more generation rate in a single host,\nyou can easily run multiple Sonyflake ID generators concurrently using goroutines.\n\nInstallation\n------------\n\n```\ngo get github.com/sony/sonyflake\n```\n\nUsage\n-----\n\nThe function New creates a new Sonyflake instance.\n\n```go\nfunc New(st Settings) (*Sonyflake, error)\n```\n\nYou can configure Sonyflake by the struct Settings:\n\n```go\ntype Settings struct {\n\tStartTime      time.Time\n\tMachineID      func() (uint16, error)\n\tCheckMachineID func(uint16) bool\n}\n```\n\n- StartTime is the time since which the Sonyflake time is defined as the elapsed time.\n  If StartTime is 0, the start time of the Sonyflake is set to \"2014-09-01 00:00:00 +0000 UTC\".\n  If StartTime is ahead of the current time, Sonyflake is not created.\n\n- MachineID returns the unique ID of the Sonyflake instance.\n  If MachineID returns an error, Sonyflake is not created.\n  If MachineID is nil, default MachineID is used.\n  Default MachineID returns the lower 16 bits of the private IP address.\n\n- CheckMachineID validates the uniqueness of the machine ID.\n  If CheckMachineID returns false, Sonyflake is not created.\n  If CheckMachineID is nil, no validation is done.\n\nIn order to get a new unique ID, you just have to call the method NextID.\n\n```go\nfunc (sf *Sonyflake) NextID() (uint64, error)\n```\n\nNextID can continue to generate IDs for about 174 years from StartTime.\nBut after the Sonyflake time is over the limit, NextID returns an error.\n\n> **Note:**\n> Sonyflake currently does not use the most significant bit of IDs,\n> so you can convert Sonyflake IDs from `uint64` to `int64` safely.\n\nAWS VPC and Docker\n------------------\n\nThe [awsutil](https://github.com/sony/sonyflake/blob/master/awsutil) package provides\nthe function AmazonEC2MachineID that returns the lower 16-bit private IP address of the Amazon EC2 instance.\nIt also works correctly on Docker\nby retrieving [instance metadata](http://docs.aws.amazon.com/en_us/AWSEC2/latest/UserGuide/ec2-instance-metadata.html).\n\n[AWS VPC](http://docs.aws.amazon.com/en_us/AmazonVPC/latest/UserGuide/VPC_Subnets.html)\nis assigned a single CIDR with a netmask between /28 and /16.\nSo if each EC2 instance has a unique private IP address in AWS VPC,\nthe lower 16 bits of the address is also unique.\nIn this common case, you can use AmazonEC2MachineID as Settings.MachineID.\n\nSee [example](https://github.com/sony/sonyflake/blob/master/example) that runs Sonyflake on AWS Elastic Beanstalk.\n\nLicense\n-------\n\nThe MIT License (MIT)\n\nSee [LICENSE](https://github.com/sony/sonyflake/blob/master/LICENSE) for details.\n"
        },
        {
          "name": "awsutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.041015625,
          "content": "module github.com/sony/sonyflake\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "mock",
          "type": "tree",
          "content": null
        },
        {
          "name": "sonyflake.go",
          "type": "blob",
          "size": 6.2529296875,
          "content": "// Package sonyflake implements Sonyflake, a distributed unique ID generator inspired by Twitter's Snowflake.\n//\n// A Sonyflake ID is composed of\n//\n//\t39 bits for time in units of 10 msec\n//\t 8 bits for a sequence number\n//\t16 bits for a machine id\npackage sonyflake\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/sony/sonyflake/types\"\n)\n\n// These constants are the bit lengths of Sonyflake ID parts.\nconst (\n\tBitLenTime      = 39                               // bit length of time\n\tBitLenSequence  = 8                                // bit length of sequence number\n\tBitLenMachineID = 63 - BitLenTime - BitLenSequence // bit length of machine id\n)\n\n// Settings configures Sonyflake:\n//\n// StartTime is the time since which the Sonyflake time is defined as the elapsed time.\n// If StartTime is 0, the start time of the Sonyflake is set to \"2014-09-01 00:00:00 +0000 UTC\".\n// If StartTime is ahead of the current time, Sonyflake is not created.\n//\n// MachineID returns the unique ID of the Sonyflake instance.\n// If MachineID returns an error, Sonyflake is not created.\n// If MachineID is nil, default MachineID is used.\n// Default MachineID returns the lower 16 bits of the private IP address.\n//\n// CheckMachineID validates the uniqueness of the machine ID.\n// If CheckMachineID returns false, Sonyflake is not created.\n// If CheckMachineID is nil, no validation is done.\ntype Settings struct {\n\tStartTime      time.Time\n\tMachineID      func() (uint16, error)\n\tCheckMachineID func(uint16) bool\n}\n\n// Sonyflake is a distributed unique ID generator.\ntype Sonyflake struct {\n\tmutex       *sync.Mutex\n\tstartTime   int64\n\telapsedTime int64\n\tsequence    uint16\n\tmachineID   uint16\n}\n\nvar (\n\tErrStartTimeAhead   = errors.New(\"start time is ahead of now\")\n\tErrNoPrivateAddress = errors.New(\"no private ip address\")\n\tErrOverTimeLimit    = errors.New(\"over the time limit\")\n\tErrInvalidMachineID = errors.New(\"invalid machine id\")\n)\n\nvar defaultInterfaceAddrs = net.InterfaceAddrs\n\n// New returns a new Sonyflake configured with the given Settings.\n// New returns an error in the following cases:\n// - Settings.StartTime is ahead of the current time.\n// - Settings.MachineID returns an error.\n// - Settings.CheckMachineID returns false.\nfunc New(st Settings) (*Sonyflake, error) {\n\tif st.StartTime.After(time.Now()) {\n\t\treturn nil, ErrStartTimeAhead\n\t}\n\n\tsf := new(Sonyflake)\n\tsf.mutex = new(sync.Mutex)\n\tsf.sequence = uint16(1<<BitLenSequence - 1)\n\n\tif st.StartTime.IsZero() {\n\t\tsf.startTime = toSonyflakeTime(time.Date(2014, 9, 1, 0, 0, 0, 0, time.UTC))\n\t} else {\n\t\tsf.startTime = toSonyflakeTime(st.StartTime)\n\t}\n\n\tvar err error\n\tif st.MachineID == nil {\n\t\tsf.machineID, err = lower16BitPrivateIP(defaultInterfaceAddrs)\n\t} else {\n\t\tsf.machineID, err = st.MachineID()\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif st.CheckMachineID != nil && !st.CheckMachineID(sf.machineID) {\n\t\treturn nil, ErrInvalidMachineID\n\t}\n\n\treturn sf, nil\n}\n\n// NewSonyflake returns a new Sonyflake configured with the given Settings.\n// NewSonyflake returns nil in the following cases:\n// - Settings.StartTime is ahead of the current time.\n// - Settings.MachineID returns an error.\n// - Settings.CheckMachineID returns false.\nfunc NewSonyflake(st Settings) *Sonyflake {\n\tsf, _ := New(st)\n\treturn sf\n}\n\n// NextID generates a next unique ID.\n// After the Sonyflake time overflows, NextID returns an error.\nfunc (sf *Sonyflake) NextID() (uint64, error) {\n\tconst maskSequence = uint16(1<<BitLenSequence - 1)\n\n\tsf.mutex.Lock()\n\tdefer sf.mutex.Unlock()\n\n\tcurrent := currentElapsedTime(sf.startTime)\n\tif sf.elapsedTime < current {\n\t\tsf.elapsedTime = current\n\t\tsf.sequence = 0\n\t} else { // sf.elapsedTime >= current\n\t\tsf.sequence = (sf.sequence + 1) & maskSequence\n\t\tif sf.sequence == 0 {\n\t\t\tsf.elapsedTime++\n\t\t\tovertime := sf.elapsedTime - current\n\t\t\ttime.Sleep(sleepTime((overtime)))\n\t\t}\n\t}\n\n\treturn sf.toID()\n}\n\nconst sonyflakeTimeUnit = 1e7 // nsec, i.e. 10 msec\n\nfunc toSonyflakeTime(t time.Time) int64 {\n\treturn t.UTC().UnixNano() / sonyflakeTimeUnit\n}\n\nfunc currentElapsedTime(startTime int64) int64 {\n\treturn toSonyflakeTime(time.Now()) - startTime\n}\n\nfunc sleepTime(overtime int64) time.Duration {\n\treturn time.Duration(overtime*sonyflakeTimeUnit) -\n\t\ttime.Duration(time.Now().UTC().UnixNano()%sonyflakeTimeUnit)\n}\n\nfunc (sf *Sonyflake) toID() (uint64, error) {\n\tif sf.elapsedTime >= 1<<BitLenTime {\n\t\treturn 0, ErrOverTimeLimit\n\t}\n\n\treturn uint64(sf.elapsedTime)<<(BitLenSequence+BitLenMachineID) |\n\t\tuint64(sf.sequence)<<BitLenMachineID |\n\t\tuint64(sf.machineID), nil\n}\n\nfunc privateIPv4(interfaceAddrs types.InterfaceAddrs) (net.IP, error) {\n\tas, err := interfaceAddrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, a := range as {\n\t\tipnet, ok := a.(*net.IPNet)\n\t\tif !ok || ipnet.IP.IsLoopback() {\n\t\t\tcontinue\n\t\t}\n\n\t\tip := ipnet.IP.To4()\n\t\tif isPrivateIPv4(ip) {\n\t\t\treturn ip, nil\n\t\t}\n\t}\n\treturn nil, ErrNoPrivateAddress\n}\n\nfunc isPrivateIPv4(ip net.IP) bool {\n\t// Allow private IP addresses (RFC1918) and link-local addresses (RFC3927)\n\treturn ip != nil &&\n\t\t(ip[0] == 10 || ip[0] == 172 && (ip[1] >= 16 && ip[1] < 32) || ip[0] == 192 && ip[1] == 168 || ip[0] == 169 && ip[1] == 254)\n}\n\nfunc lower16BitPrivateIP(interfaceAddrs types.InterfaceAddrs) (uint16, error) {\n\tip, err := privateIPv4(interfaceAddrs)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn uint16(ip[2])<<8 + uint16(ip[3]), nil\n}\n\n// ElapsedTime returns the elapsed time when the given Sonyflake ID was generated.\nfunc ElapsedTime(id uint64) time.Duration {\n\treturn time.Duration(elapsedTime(id) * sonyflakeTimeUnit)\n}\n\nfunc elapsedTime(id uint64) uint64 {\n\treturn id >> (BitLenSequence + BitLenMachineID)\n}\n\n// SequenceNumber returns the sequence number of a Sonyflake ID.\nfunc SequenceNumber(id uint64) uint64 {\n\tconst maskSequence = uint64((1<<BitLenSequence - 1) << BitLenMachineID)\n\treturn id & maskSequence >> BitLenMachineID\n}\n\n// MachineID returns the machine ID of a Sonyflake ID.\nfunc MachineID(id uint64) uint64 {\n\tconst maskMachineID = uint64(1<<BitLenMachineID - 1)\n\treturn id & maskMachineID\n}\n\n// Decompose returns a set of Sonyflake ID parts.\nfunc Decompose(id uint64) map[string]uint64 {\n\tmsb := id >> 63\n\ttime := elapsedTime(id)\n\tsequence := SequenceNumber(id)\n\tmachineID := MachineID(id)\n\treturn map[string]uint64{\n\t\t\"id\":         id,\n\t\t\"msb\":        msb,\n\t\t\"time\":       time,\n\t\t\"sequence\":   sequence,\n\t\t\"machine-id\": machineID,\n\t}\n}\n"
        },
        {
          "name": "sonyflake_test.go",
          "type": "blob",
          "size": 6.4970703125,
          "content": "package sonyflake\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/sony/sonyflake/mock\"\n\t\"github.com/sony/sonyflake/types\"\n)\n\nvar sf *Sonyflake\n\nvar startTime int64\nvar machineID uint64\n\nfunc init() {\n\tvar st Settings\n\tst.StartTime = time.Now()\n\n\tsf = NewSonyflake(st)\n\tif sf == nil {\n\t\tpanic(\"sonyflake not created\")\n\t}\n\n\tstartTime = toSonyflakeTime(st.StartTime)\n\n\tip, _ := lower16BitPrivateIP(defaultInterfaceAddrs)\n\tmachineID = uint64(ip)\n}\n\nfunc nextID(t *testing.T) uint64 {\n\tid, err := sf.NextID()\n\tif err != nil {\n\t\tt.Fatal(\"id not generated\")\n\t}\n\treturn id\n}\n\nfunc TestNew(t *testing.T) {\n\tgenError := fmt.Errorf(\"an error occurred while generating ID\")\n\n\ttests := []struct {\n\t\tname     string\n\t\tsettings Settings\n\t\terr      error\n\t}{\n\t\t{\n\t\t\tname: \"failure: time ahead\",\n\t\t\tsettings: Settings{\n\t\t\t\tStartTime: time.Now().Add(time.Minute),\n\t\t\t},\n\t\t\terr: ErrStartTimeAhead,\n\t\t},\n\t\t{\n\t\t\tname: \"failure: machine ID\",\n\t\t\tsettings: Settings{\n\t\t\t\tMachineID: func() (uint16, error) {\n\t\t\t\t\treturn 0, genError\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: genError,\n\t\t},\n\t\t{\n\t\t\tname: \"failure: invalid machine ID\",\n\t\t\tsettings: Settings{\n\t\t\t\tCheckMachineID: func(uint16) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t},\n\t\t\terr: ErrInvalidMachineID,\n\t\t},\n\t\t{\n\t\t\tname:     \"success\",\n\t\t\tsettings: Settings{},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tsonyflake, err := New(test.settings)\n\n\t\t\tif !errors.Is(err, test.err) {\n\t\t\t\tt.Fatalf(\"unexpected value, want %#v, got %#v\", test.err, err)\n\t\t\t}\n\n\t\t\tif sonyflake == nil && err == nil {\n\t\t\t\tt.Fatal(\"unexpected value, sonyflake should not be nil\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSonyflakeOnce(t *testing.T) {\n\tsleepTime := time.Duration(50 * sonyflakeTimeUnit)\n\ttime.Sleep(sleepTime)\n\n\tid := nextID(t)\n\n\tactualTime := ElapsedTime(id)\n\tif actualTime < sleepTime || actualTime > sleepTime+sonyflakeTimeUnit {\n\t\tt.Errorf(\"unexpected time: %d\", actualTime)\n\t}\n\n\tactualSequence := SequenceNumber(id)\n\tif actualSequence != 0 {\n\t\tt.Errorf(\"unexpected sequence: %d\", actualSequence)\n\t}\n\n\tactualMachineID := MachineID(id)\n\tif actualMachineID != machineID {\n\t\tt.Errorf(\"unexpected machine id: %d\", actualMachineID)\n\t}\n\n\tfmt.Println(\"sonyflake id:\", id)\n\tfmt.Println(\"decompose:\", Decompose(id))\n}\n\nfunc currentTime() int64 {\n\treturn toSonyflakeTime(time.Now())\n}\n\nfunc TestSonyflakeFor10Sec(t *testing.T) {\n\tvar numID uint32\n\tvar lastID uint64\n\tvar maxSequence uint64\n\n\tinitial := currentTime()\n\tcurrent := initial\n\tfor current-initial < 1000 {\n\t\tid := nextID(t)\n\t\tparts := Decompose(id)\n\t\tnumID++\n\n\t\tif id == lastID {\n\t\t\tt.Fatal(\"duplicated id\")\n\t\t}\n\t\tif id < lastID {\n\t\t\tt.Fatal(\"must increase with time\")\n\t\t}\n\t\tlastID = id\n\n\t\tcurrent = currentTime()\n\n\t\tactualMSB := parts[\"msb\"]\n\t\tif actualMSB != 0 {\n\t\t\tt.Errorf(\"unexpected msb: %d\", actualMSB)\n\t\t}\n\n\t\tactualTime := int64(parts[\"time\"])\n\t\tovertime := startTime + actualTime - current\n\t\tif overtime > 0 {\n\t\t\tt.Errorf(\"unexpected overtime: %d\", overtime)\n\t\t}\n\n\t\tactualSequence := parts[\"sequence\"]\n\t\tif maxSequence < actualSequence {\n\t\t\tmaxSequence = actualSequence\n\t\t}\n\n\t\tactualMachineID := parts[\"machine-id\"]\n\t\tif actualMachineID != machineID {\n\t\t\tt.Errorf(\"unexpected machine id: %d\", actualMachineID)\n\t\t}\n\t}\n\n\tif maxSequence != 1<<BitLenSequence-1 {\n\t\tt.Errorf(\"unexpected max sequence: %d\", maxSequence)\n\t}\n\tfmt.Println(\"max sequence:\", maxSequence)\n\tfmt.Println(\"number of id:\", numID)\n}\n\nfunc TestSonyflakeInParallel(t *testing.T) {\n\tnumCPU := runtime.NumCPU()\n\truntime.GOMAXPROCS(numCPU)\n\tfmt.Println(\"number of cpu:\", numCPU)\n\n\tconsumer := make(chan uint64)\n\n\tconst numID = 10000\n\tgenerate := func() {\n\t\tfor i := 0; i < numID; i++ {\n\t\t\tconsumer <- nextID(t)\n\t\t}\n\t}\n\n\tconst numGenerator = 10\n\tfor i := 0; i < numGenerator; i++ {\n\t\tgo generate()\n\t}\n\n\tset := make(map[uint64]struct{})\n\tfor i := 0; i < numID*numGenerator; i++ {\n\t\tid := <-consumer\n\t\tif _, ok := set[id]; ok {\n\t\t\tt.Fatal(\"duplicated id\")\n\t\t}\n\t\tset[id] = struct{}{}\n\t}\n\tfmt.Println(\"number of id:\", len(set))\n}\n\nfunc pseudoSleep(period time.Duration) {\n\tsf.startTime -= int64(period) / sonyflakeTimeUnit\n}\n\nfunc TestNextIDError(t *testing.T) {\n\tyear := time.Duration(365*24) * time.Hour\n\tpseudoSleep(time.Duration(174) * year)\n\tnextID(t)\n\n\tpseudoSleep(time.Duration(1) * year)\n\t_, err := sf.NextID()\n\tif err == nil {\n\t\tt.Errorf(\"time is not over\")\n\t}\n}\n\nfunc TestPrivateIPv4(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription    string\n\t\texpected       net.IP\n\t\tinterfaceAddrs types.InterfaceAddrs\n\t\terror          string\n\t}{\n\t\t{\n\t\t\tdescription:    \"InterfaceAddrs returns an error\",\n\t\t\texpected:       nil,\n\t\t\tinterfaceAddrs: mock.NewFailingInterfaceAddrs(),\n\t\t\terror:          \"test error\",\n\t\t},\n\t\t{\n\t\t\tdescription:    \"InterfaceAddrs returns an empty or nil list\",\n\t\t\texpected:       nil,\n\t\t\tinterfaceAddrs: mock.NewNilInterfaceAddrs(),\n\t\t\terror:          \"no private ip address\",\n\t\t},\n\t\t{\n\t\t\tdescription:    \"InterfaceAddrs returns one or more IPs\",\n\t\t\texpected:       net.IP{192, 168, 0, 1},\n\t\t\tinterfaceAddrs: mock.NewSuccessfulInterfaceAddrs(),\n\t\t\terror:          \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tactual, err := privateIPv4(tc.interfaceAddrs)\n\n\t\t\tif (err != nil) && (tc.error == \"\") {\n\t\t\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t\t\t\treturn\n\t\t\t} else if (err != nil) && (tc.error != \"\") {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif net.IP.Equal(actual, tc.expected) {\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"error: expected: %s, but got: %s\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLower16BitPrivateIP(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription    string\n\t\texpected       uint16\n\t\tinterfaceAddrs types.InterfaceAddrs\n\t\terror          string\n\t}{\n\t\t{\n\t\t\tdescription:    \"InterfaceAddrs returns an empty or nil list\",\n\t\t\texpected:       0,\n\t\t\tinterfaceAddrs: mock.NewNilInterfaceAddrs(),\n\t\t\terror:          \"no private ip address\",\n\t\t},\n\t\t{\n\t\t\tdescription:    \"InterfaceAddrs returns one or more IPs\",\n\t\t\texpected:       1,\n\t\t\tinterfaceAddrs: mock.NewSuccessfulInterfaceAddrs(),\n\t\t\terror:          \"\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tactual, err := lower16BitPrivateIP(tc.interfaceAddrs)\n\n\t\t\tif (err != nil) && (tc.error == \"\") {\n\t\t\t\tt.Errorf(\"expected no error, but got: %s\", err)\n\t\t\t\treturn\n\t\t\t} else if (err != nil) && (tc.error != \"\") {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif actual == tc.expected {\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"error: expected: %v, but got: %v\", tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSonyflakeTimeUnit(t *testing.T) {\n\tif time.Duration(sonyflakeTimeUnit) != 10*time.Millisecond {\n\t\tt.Errorf(\"unexpected time unit\")\n\t}\n}\n"
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}