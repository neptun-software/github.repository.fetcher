{
  "metadata": {
    "timestamp": 1736566795955,
    "page": 359,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alecthomas/kingpin",
      "stars": 3518,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0302734375,
          "content": "Copyright (C) 2014 Alec Thomas\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.9013671875,
          "content": "# CONTRIBUTIONS ONLY\n\n**What does this mean?** I do not have time to fix issues myself. The only way fixes or new features will be added is by people submitting PRs. If you are interested in taking over maintenance and have a history of contributions to Kingpin, please let me know.\n\n**Current status.** Kingpin is largely feature stable. There hasn't been a need to add new features in a while, but there are some bugs that should be fixed.\n\n**Why?** I no longer use Kingpin personally (I now use [kong](https://github.com/alecthomas/kong)). Rather than leave the project in a limbo of people filing issues and wondering why they're not being worked on, I believe this notice will more clearly set expectations.\n\n# Kingpin - A Go (golang) command line and flag parser\n[![](https://godoc.org/github.com/alecthomas/kingpin?status.svg)](http://godoc.org/github.com/alecthomas/kingpin) [![CI](https://github.com/alecthomas/kingpin/actions/workflows/ci.yml/badge.svg)](https://github.com/alecthomas/kingpin/actions/workflows/ci.yml)\n\n\n\n\n\n<!-- MarkdownTOC -->\n\n- [Overview](#overview)\n- [Features](#features)\n- [User-visible changes between v1 and v2](#user-visible-changes-between-v1-and-v2)\n  - [Flags can be used at any point after their definition.](#flags-can-be-used-at-any-point-after-their-definition)\n  - [Short flags can be combined with their parameters](#short-flags-can-be-combined-with-their-parameters)\n- [API changes between v1 and v2](#api-changes-between-v1-and-v2)\n- [Versions](#versions)\n  - [V2 is the current stable version](#v2-is-the-current-stable-version)\n  - [V1 is the OLD stable version](#v1-is-the-old-stable-version)\n- [Change History](#change-history)\n- [Examples](#examples)\n  - [Simple Example](#simple-example)\n  - [Complex Example](#complex-example)\n- [Reference Documentation](#reference-documentation)\n  - [Displaying errors and usage information](#displaying-errors-and-usage-information)\n  - [Sub-commands](#sub-commands)\n  - [Custom Parsers](#custom-parsers)\n  - [Repeatable flags](#repeatable-flags)\n  - [Boolean Values](#boolean-values)\n  - [Default Values](#default-values)\n  - [Place-holders in Help](#place-holders-in-help)\n  - [Consuming all remaining arguments](#consuming-all-remaining-arguments)\n  - [Bash/ZSH Shell Completion](#bashzsh-shell-completion)\n  - [Supporting -h for help](#supporting--h-for-help)\n  - [Custom help](#custom-help)\n\n<!-- /MarkdownTOC -->\n\n## Overview\n\nKingpin is a [fluent-style](http://en.wikipedia.org/wiki/Fluent_interface),\ntype-safe command-line parser. It supports flags, nested commands, and\npositional arguments.\n\nInstall it with:\n\n    $ go get github.com/alecthomas/kingpin/v2\n\nIt looks like this:\n\n```go\nvar (\n  verbose = kingpin.Flag(\"verbose\", \"Verbose mode.\").Short('v').Bool()\n  name    = kingpin.Arg(\"name\", \"Name of user.\").Required().String()\n)\n\nfunc main() {\n  kingpin.Parse()\n  fmt.Printf(\"%v, %s\\n\", *verbose, *name)\n}\n```\n\nMore [examples](https://github.com/alecthomas/kingpin/tree/master/_examples) are available.\n\nSecond to parsing, providing the user with useful help is probably the most\nimportant thing a command-line parser does. Kingpin tries to provide detailed\ncontextual help if `--help` is encountered at any point in the command line\n(excluding after `--`).\n\n## Features\n\n- Help output that isn't as ugly as sin.\n- Fully [customisable help](#custom-help), via Go templates.\n- Parsed, type-safe flags (`kingpin.Flag(\"f\", \"help\").Int()`)\n- Parsed, type-safe positional arguments (`kingpin.Arg(\"a\", \"help\").Int()`).\n- Parsed, type-safe, arbitrarily deep commands (`kingpin.Command(\"c\", \"help\")`).\n- Support for required flags and required positional arguments (`kingpin.Flag(\"f\", \"\").Required().Int()`).\n- Support for arbitrarily nested default commands (`command.Default()`).\n- Callbacks per command, flag and argument (`kingpin.Command(\"c\", \"\").Action(myAction)`).\n- POSIX-style short flag combining (`-a -b` -> `-ab`).\n- Short-flag+parameter combining (`-a parm` -> `-aparm`).\n- Read command-line from files (`@<file>`).\n- Automatically generate man pages (`--help-man`).\n\n## User-visible changes between v1 and v2\n\n### Flags can be used at any point after their definition.\n\nFlags can be specified at any point after their definition, not just\n*immediately after their associated command*. From the chat example below, the\nfollowing used to be required:\n\n```\n$ chat --server=chat.server.com:8080 post --image=~/Downloads/owls.jpg pics\n```\n\nBut the following will now work:\n\n```\n$ chat post --server=chat.server.com:8080 --image=~/Downloads/owls.jpg pics\n```\n\n### Short flags can be combined with their parameters\n\nPreviously, if a short flag was used, any argument to that flag would have to\nbe separated by a space. That is no longer the case.\n\n## API changes between v1 and v2\n\n- `ParseWithFileExpansion()` is gone. The new parser directly supports expanding `@<file>`.\n- Added `FatalUsage()` and `FatalUsageContext()` for displaying an error + usage and terminating.\n- `Dispatch()` renamed to `Action()`.\n- Added `ParseContext()` for parsing a command line into its intermediate context form without executing.\n- Added `Terminate()` function to override the termination function.\n- Added `UsageForContextWithTemplate()` for printing usage via a custom template.\n- Added `UsageTemplate()` for overriding the default template to use. Two templates are included:\n    1. `DefaultUsageTemplate` - default template.\n    2. `CompactUsageTemplate` - compact command template for larger applications.\n\n## Versions\n\nThe current stable version is [github.com/alecthomas/kingpin/v2](https://github.com/alecthomas/kingpin/v2). The previous version, [gopkg.in/alecthomas/kingpin.v1](https://gopkg.in/alecthomas/kingpin.v1), is deprecated and in maintenance mode.\n\n### [V2](https://github.com/alecthomas/kingpin/v2) is the current stable version\n\nInstallation:\n\n```sh\n$ go get github.com/alecthomas/kingpin/v2\n```\n\n### [V1](https://gopkg.in/alecthomas/kingpin.v1) is the OLD stable version\n\nInstallation:\n\n```sh\n$ go get gopkg.in/alecthomas/kingpin.v1\n```\n\n## Change History\n\n- *2015-09-19* -- Stable v2.1.0 release.\n    - Added `command.Default()` to specify a default command to use if no other\n      command matches. This allows for convenient user shortcuts.\n    - Exposed `HelpFlag` and `VersionFlag` for further customisation.\n    - `Action()` and `PreAction()` added and both now support an arbitrary\n      number of callbacks.\n    - `kingpin.SeparateOptionalFlagsUsageTemplate`.\n    - `--help-long` and `--help-man` (hidden by default) flags.\n    - Flags are \"interspersed\" by default, but can be disabled with `app.Interspersed(false)`.\n    - Added flags for all simple builtin types (int8, uint16, etc.) and slice variants.\n    - Use `app.Writer(os.Writer)` to specify the default writer for all output functions.\n    - Dropped `os.Writer` prefix from all printf-like functions.\n\n- *2015-05-22* -- Stable v2.0.0 release.\n    - Initial stable release of v2.0.0.\n    - Fully supports interspersed flags, commands and arguments.\n    - Flags can be present at any point after their logical definition.\n    - Application.Parse() terminates if commands are present and a command is not parsed.\n    - Dispatch() -> Action().\n    - Actions are dispatched after all values are populated.\n    - Override termination function (defaults to os.Exit).\n    - Override output stream (defaults to os.Stderr).\n    - Templatised usage help, with default and compact templates.\n    - Make error/usage functions more consistent.\n    - Support argument expansion from files by default (with @<file>).\n    - Fully public data model is available via .Model().\n    - Parser has been completely refactored.\n    - Parsing and execution has been split into distinct stages.\n    - Use `go generate` to generate repeated flags.\n    - Support combined short-flag+argument: -fARG.\n\n- *2015-01-23* -- Stable v1.3.4 release.\n    - Support \"--\" for separating flags from positional arguments.\n    - Support loading flags from files (ParseWithFileExpansion()). Use @FILE as an argument.\n    - Add post-app and post-cmd validation hooks. This allows arbitrary validation to be added.\n    - A bunch of improvements to help usage and formatting.\n    - Support arbitrarily nested sub-commands.\n\n- *2014-07-08* -- Stable v1.2.0 release.\n    - Pass any value through to `Strings()` when final argument.\n      Allows for values that look like flags to be processed.\n    - Allow `--help` to be used with commands.\n    - Support `Hidden()` flags.\n    - Parser for [units.Base2Bytes](https://github.com/alecthomas/units)\n      type. Allows for flags like `--ram=512MB` or `--ram=1GB`.\n    - Add an `Enum()` value, allowing only one of a set of values\n      to be selected. eg. `Flag(...).Enum(\"debug\", \"info\", \"warning\")`.\n\n- *2014-06-27* -- Stable v1.1.0 release.\n    - Bug fixes.\n    - Always return an error (rather than panicing) when misconfigured.\n    - `OpenFile(flag, perm)` value type added, for finer control over opening files.\n    - Significantly improved usage formatting.\n\n- *2014-06-19* -- Stable v1.0.0 release.\n    - Support [cumulative positional](#consuming-all-remaining-arguments) arguments.\n    - Return error rather than panic when there are fatal errors not caught by\n      the type system. eg. when a default value is invalid.\n    - Use gokpg.in.\n\n- *2014-06-10* -- Place-holder streamlining.\n    - Renamed `MetaVar` to `PlaceHolder`.\n    - Removed `MetaVarFromDefault`. Kingpin now uses [heuristics](#place-holders-in-help)\n      to determine what to display.\n\n## Examples\n\n### Simple Example\n\nKingpin can be used for simple flag+arg applications like so:\n\n```\n$ ping --help\nusage: ping [<flags>] <ip> [<count>]\n\nFlags:\n  --debug            Enable debug mode.\n  --help             Show help.\n  -t, --timeout=5s   Timeout waiting for ping.\n\nArgs:\n  <ip>        IP address to ping.\n  [<count>]   Number of packets to send\n$ ping 1.2.3.4 5\nWould ping: 1.2.3.4 with timeout 5s and count 5\n```\n\nFrom the following source:\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/alecthomas/kingpin/v2\"\n)\n\nvar (\n  debug   = kingpin.Flag(\"debug\", \"Enable debug mode.\").Bool()\n  timeout = kingpin.Flag(\"timeout\", \"Timeout waiting for ping.\").Default(\"5s\").Envar(\"PING_TIMEOUT\").Short('t').Duration()\n  ip      = kingpin.Arg(\"ip\", \"IP address to ping.\").Required().IP()\n  count   = kingpin.Arg(\"count\", \"Number of packets to send\").Int()\n)\n\nfunc main() {\n  kingpin.Version(\"0.0.1\")\n  kingpin.Parse()\n  fmt.Printf(\"Would ping: %s with timeout %s and count %d\\n\", *ip, *timeout, *count)\n}\n```\n\n#### Reading arguments from a file\nKingpin supports reading arguments from a file.\nCreate a file with the corresponding arguments:\n```\necho -t=5\\n > args\n```\nAnd now supply it:\n```\n$ ping @args\n```\n\n### Complex Example\n\nKingpin can also produce complex command-line applications with global flags,\nsubcommands, and per-subcommand flags, like this:\n\n```\n$ chat --help\nusage: chat [<flags>] <command> [<flags>] [<args> ...]\n\nA command-line chat application.\n\nFlags:\n  --help              Show help.\n  --debug             Enable debug mode.\n  --server=127.0.0.1  Server address.\n\nCommands:\n  help [<command>]\n    Show help for a command.\n\n  register <nick> <name>\n    Register a new user.\n\n  post [<flags>] <channel> [<text>]\n    Post a message to a channel.\n\n$ chat help post\nusage: chat [<flags>] post [<flags>] <channel> [<text>]\n\nPost a message to a channel.\n\nFlags:\n  --image=IMAGE  Image to post.\n\nArgs:\n  <channel>  Channel to post to.\n  [<text>]   Text to post.\n\n$ chat post --image=~/Downloads/owls.jpg pics\n...\n```\n\nFrom this code:\n\n```go\npackage main\n\nimport (\n  \"os\"\n  \"strings\"\n  \"github.com/alecthomas/kingpin/v2\"\n)\n\nvar (\n  app      = kingpin.New(\"chat\", \"A command-line chat application.\")\n  debug    = app.Flag(\"debug\", \"Enable debug mode.\").Bool()\n  serverIP = app.Flag(\"server\", \"Server address.\").Default(\"127.0.0.1\").IP()\n\n  register     = app.Command(\"register\", \"Register a new user.\")\n  registerNick = register.Arg(\"nick\", \"Nickname for user.\").Required().String()\n  registerName = register.Arg(\"name\", \"Name of user.\").Required().String()\n\n  post        = app.Command(\"post\", \"Post a message to a channel.\")\n  postImage   = post.Flag(\"image\", \"Image to post.\").File()\n  postChannel = post.Arg(\"channel\", \"Channel to post to.\").Required().String()\n  postText    = post.Arg(\"text\", \"Text to post.\").Strings()\n)\n\nfunc main() {\n  switch kingpin.MustParse(app.Parse(os.Args[1:])) {\n  // Register user\n  case register.FullCommand():\n    println(*registerNick)\n\n  // Post message\n  case post.FullCommand():\n    if *postImage != nil {\n    }\n    text := strings.Join(*postText, \" \")\n    println(\"Post:\", text)\n  }\n}\n```\n\n## Reference Documentation\n\n### Displaying errors and usage information\n\nKingpin exports a set of functions to provide consistent errors and usage\ninformation to the user.\n\nError messages look something like this:\n\n    <app>: error: <message>\n\nThe functions on `Application` are:\n\nFunction | Purpose\n---------|--------------\n`Errorf(format, args)` | Display a printf formatted error to the user.\n`Fatalf(format, args)` | As with Errorf, but also call the termination handler.\n`FatalUsage(format, args)` | As with Fatalf, but also print contextual usage information.\n`FatalUsageContext(context, format, args)` | As with Fatalf, but also print contextual usage information from a `ParseContext`.\n`FatalIfError(err, format, args)` | Conditionally print an error prefixed with format+args, then call the termination handler\n\nThere are equivalent global functions in the kingpin namespace for the default\n`kingpin.CommandLine` instance.\n\n### Sub-commands\n\nKingpin supports nested sub-commands, with separate flag and positional\narguments per sub-command. Note that positional arguments may only occur after\nsub-commands.\n\nFor example:\n\n```go\nvar (\n  deleteCommand     = kingpin.Command(\"delete\", \"Delete an object.\")\n  deleteUserCommand = deleteCommand.Command(\"user\", \"Delete a user.\")\n  deleteUserUIDFlag = deleteUserCommand.Flag(\"uid\", \"Delete user by UID rather than username.\")\n  deleteUserUsername = deleteUserCommand.Arg(\"username\", \"Username to delete.\")\n  deletePostCommand = deleteCommand.Command(\"post\", \"Delete a post.\")\n)\n\nfunc main() {\n  switch kingpin.Parse() {\n  case deleteUserCommand.FullCommand():\n  case deletePostCommand.FullCommand():\n  }\n}\n```\n\n### Custom Parsers\n\nKingpin supports both flag and positional argument parsers for converting to\nGo types. For example, some included parsers are `Int()`, `Float()`,\n`Duration()` and `ExistingFile()` (see [parsers.go](./parsers.go) for a complete list of included parsers).\n\nParsers conform to Go's [`flag.Value`](http://godoc.org/flag#Value)\ninterface, so any existing implementations will work.\n\nFor example, a parser for accumulating HTTP header values might look like this:\n\n```go\ntype HTTPHeaderValue http.Header\n\nfunc (h *HTTPHeaderValue) Set(value string) error {\n  parts := strings.SplitN(value, \":\", 2)\n  if len(parts) != 2 {\n    return fmt.Errorf(\"expected HEADER:VALUE got '%s'\", value)\n  }\n  (*http.Header)(h).Add(parts[0], parts[1])\n  return nil\n}\n\nfunc (h *HTTPHeaderValue) String() string {\n  return \"\"\n}\n```\n\nAs a convenience, I would recommend something like this:\n\n```go\nfunc HTTPHeader(s Settings) (target *http.Header) {\n  target = &http.Header{}\n  s.SetValue((*HTTPHeaderValue)(target))\n  return\n}\n```\n\nYou would use it like so:\n\n```go\nheaders = HTTPHeader(kingpin.Flag(\"header\", \"Add a HTTP header to the request.\").Short('H'))\n```\n\n### Repeatable flags\n\nDepending on the `Value` they hold, some flags may be repeated. The\n`IsCumulative() bool` function on `Value` tells if it's safe to call `Set()`\nmultiple times or if an error should be raised if several values are passed.\n\nThe built-in `Value`s returning slices and maps, as well as `Counter` are\nexamples of `Value`s that make a flag repeatable.\n\n### Boolean values\n\nBoolean values are uniquely managed by Kingpin. Each boolean flag will have a negative complement:\n`--<name>` and `--no-<name>`.\n\n### Default Values\n\nThe default value is the zero value for a type. This can be overridden with\nthe `Default(value...)` function on flags and arguments. This function accepts\none or several strings, which are parsed by the value itself, so they *must*\nbe compliant with the format expected.\n\n### Place-holders in Help\n\nThe place-holder value for a flag is the value used in the help to describe\nthe value of a non-boolean flag.\n\nThe value provided to PlaceHolder() is used if provided, then the value\nprovided by Default() if provided, then finally the capitalised flag name is\nused.\n\nHere are some examples of flags with various permutations:\n\n    --name=NAME           // Flag(...).String()\n    --name=\"Harry\"        // Flag(...).Default(\"Harry\").String()\n    --name=FULL-NAME      // Flag(...).PlaceHolder(\"FULL-NAME\").Default(\"Harry\").String()\n\n### Consuming all remaining arguments\n\nA common command-line idiom is to use all remaining arguments for some\npurpose. eg. The following command accepts an arbitrary number of\nIP addresses as positional arguments:\n\n    ./cmd ping 10.1.1.1 192.168.1.1\n\nSuch arguments are similar to [repeatable flags](#repeatable-flags), but for\narguments. Therefore they use the same `IsCumulative() bool` function on the\nunderlying `Value`, so the built-in `Value`s for which the `Set()` function\ncan be called several times will consume multiple arguments.\n\nTo implement the above example with a custom `Value`, we might do something\nlike this:\n\n```go\ntype ipList []net.IP\n\nfunc (i *ipList) Set(value string) error {\n  if ip := net.ParseIP(value); ip == nil {\n    return fmt.Errorf(\"'%s' is not an IP address\", value)\n  } else {\n    *i = append(*i, ip)\n    return nil\n  }\n}\n\nfunc (i *ipList) String() string {\n  return \"\"\n}\n\nfunc (i *ipList) IsCumulative() bool {\n  return true\n}\n\nfunc IPList(s Settings) (target *[]net.IP) {\n  target = new([]net.IP)\n  s.SetValue((*ipList)(target))\n  return\n}\n```\n\nAnd use it like so:\n\n```go\nips := IPList(kingpin.Arg(\"ips\", \"IP addresses to ping.\"))\n```\n\n### Bash/ZSH Shell Completion\n\nBy default, all flags and commands/subcommands generate completions\ninternally.\n\nOut of the box, CLI tools using kingpin should be able to take advantage\nof completion hinting for flags and commands. By specifying\n`--completion-bash` as the first argument, your CLI tool will show\npossible subcommands. By ending your argv with `--`, hints for flags\nwill be shown.\n\nTo allow your end users to take advantage you must package a\n`/etc/bash_completion.d` script with your distribution (or the equivalent\nfor your target platform/shell). An alternative is to instruct your end\nuser to source a script from their `bash_profile` (or equivalent).\n\nFortunately Kingpin makes it easy to generate or source a script for use\nwith end users shells. `./yourtool --completion-script-bash` and\n`./yourtool --completion-script-zsh` will generate these scripts for you.\n\n**Installation by Package**\n\nFor the best user experience, you should bundle your pre-created\ncompletion script with your CLI tool and install it inside\n`/etc/bash_completion.d` (or equivalent). A good suggestion is to add\nthis as an automated step to your build pipeline, in the implementation\nis improved for bug fixed.\n\n**Installation by `bash_profile`**\n\nAlternatively, instruct your users to add an additional statement to\ntheir `bash_profile` (or equivalent):\n\n```\neval \"$(your-cli-tool --completion-script-bash)\"\n```\n\nOr for ZSH\n\n```\neval \"$(your-cli-tool --completion-script-zsh)\"\n```\n\n#### Additional API\nTo provide more flexibility, a completion option API has been\nexposed for flags to allow user defined completion options, to extend\ncompletions further than just EnumVar/Enum.\n\n\n**Provide Static Options**\n\nWhen using an `Enum` or `EnumVar`, users are limited to only the options\ngiven. Maybe we wish to hint possible options to the user, but also\nallow them to provide their own custom option. `HintOptions` gives\nthis functionality to flags.\n\n```\napp := kingpin.New(\"completion\", \"My application with bash completion.\")\napp.Flag(\"port\", \"Provide a port to connect to\").\n    Required().\n    HintOptions(\"80\", \"443\", \"8080\").\n    IntVar(&c.port)\n```\n\n**Provide Dynamic Options**\nConsider the case that you needed to read a local database or a file to\nprovide suggestions. You can dynamically generate the options\n\n```\nfunc listHosts() []string {\n  // Provide a dynamic list of hosts from a hosts file or otherwise\n  // for bash completion. In this example we simply return static slice.\n\n  // You could use this functionality to reach into a hosts file to provide\n  // completion for a list of known hosts.\n  return []string{\"sshhost.example\", \"webhost.example\", \"ftphost.example\"}\n}\n\napp := kingpin.New(\"completion\", \"My application with bash completion.\")\napp.Flag(\"flag-1\", \"\").HintAction(listHosts).String()\n```\n\n**EnumVar/Enum**\nWhen using `Enum` or `EnumVar`, any provided options will be automatically\nused for bash autocompletion. However, if you wish to provide a subset or\ndifferent options, you can use `HintOptions` or `HintAction` which will override\nthe default completion options for `Enum`/`EnumVar`.\n\n\n**Examples**\nYou can see an in depth example of the completion API within\n`examples/completion/main.go`\n\n\n### Supporting -h for help\n\n`kingpin.CommandLine.HelpFlag.Short('h')`\n\nShort help is also available when creating a more complicated app:\n\n```go\nvar (\n\tapp = kingpin.New(\"chat\", \"A command-line chat application.\")\n  // ...\n)\n\nfunc main() {\n\tapp.HelpFlag.Short('h')\n\tswitch kingpin.MustParse(app.Parse(os.Args[1:])) {\n  // ...\n  }\n}\n```\n\n### Custom help\n\nKingpin v2 supports templatised help using the text/template library (actually, [a fork](https://github.com/alecthomas/template)).\n\nYou can specify the template to use with the [Application.UsageTemplate()](http://godoc.org/github.com/alecthomas/kingpin/v2#Application.UsageTemplate) function.\n\nThere are four included templates: `kingpin.DefaultUsageTemplate` is the default,\n`kingpin.CompactUsageTemplate` provides a more compact representation for more complex command-line structures,\n`kingpin.SeparateOptionalFlagsUsageTemplate` looks like the default template, but splits required\nand optional command flags into separate lists, and `kingpin.ManPageTemplate` is used to generate man pages.\n\nSee the above templates for examples of usage, and the the function [UsageForContextWithTemplate()](https://github.com/alecthomas/kingpin/blob/master/usage.go#L198) method for details on the context.\n\n#### Default help template\n\n```\n$ go run ./examples/curl/curl.go --help\nusage: curl [<flags>] <command> [<args> ...]\n\nAn example implementation of curl.\n\nFlags:\n  --help            Show help.\n  -t, --timeout=5s  Set connection timeout.\n  -H, --headers=HEADER=VALUE\n                    Add HTTP headers to the request.\n\nCommands:\n  help [<command>...]\n    Show help.\n\n  get url <url>\n    Retrieve a URL.\n\n  get file <file>\n    Retrieve a file.\n\n  post [<flags>] <url>\n    POST a resource.\n```\n\n#### Compact help template\n\n```\n$ go run ./examples/curl/curl.go --help\nusage: curl [<flags>] <command> [<args> ...]\n\nAn example implementation of curl.\n\nFlags:\n  --help            Show help.\n  -t, --timeout=5s  Set connection timeout.\n  -H, --headers=HEADER=VALUE\n                    Add HTTP headers to the request.\n\nCommands:\n  help [<command>...]\n  get [<flags>]\n    url <url>\n    file <file>\n  post [<flags>] <url>\n```\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "actions.go",
          "type": "blob",
          "size": 0.9365234375,
          "content": "package kingpin\n\n// Action callback executed at various stages after all values are populated.\n// The application, commands, arguments and flags all have corresponding\n// actions.\ntype Action func(*ParseContext) error\n\ntype actionMixin struct {\n\tactions    []Action\n\tpreActions []Action\n}\n\ntype actionApplier interface {\n\tapplyActions(*ParseContext) error\n\tapplyPreActions(*ParseContext) error\n}\n\nfunc (a *actionMixin) addAction(action Action) {\n\ta.actions = append(a.actions, action)\n}\n\nfunc (a *actionMixin) addPreAction(action Action) {\n\ta.preActions = append(a.preActions, action)\n}\n\nfunc (a *actionMixin) applyActions(context *ParseContext) error {\n\tfor _, action := range a.actions {\n\t\tif err := action(context); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (a *actionMixin) applyPreActions(context *ParseContext) error {\n\tfor _, preAction := range a.preActions {\n\t\tif err := preAction(context); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "app.go",
          "type": "blob",
          "size": 18.6396484375,
          "content": "package kingpin\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nvar (\n\tErrCommandNotSpecified = fmt.Errorf(\"command not specified\")\n)\n\nvar (\n\tenvarTransformRegexp = regexp.MustCompile(`[^a-zA-Z0-9_]+`)\n)\n\ntype ApplicationValidator func(*Application) error\n\n// An Application contains the definitions of flags, arguments and commands\n// for an application.\ntype Application struct {\n\tcmdMixin\n\tinitialized bool\n\n\tName string\n\tHelp string\n\n\tauthor         string\n\tversion        string\n\terrorWriter    io.Writer // Destination for errors.\n\tusageWriter    io.Writer // Destination for usage\n\tusageTemplate  string\n\tusageFuncs     template.FuncMap\n\tvalidator      ApplicationValidator\n\tterminate      func(status int) // See Terminate()\n\tnoInterspersed bool             // can flags be interspersed with args (or must they come first)\n\tdefaultEnvars  bool\n\tcompletion     bool\n\n\t// Help flag. Exposed for user customisation.\n\tHelpFlag *FlagClause\n\t// Help command. Exposed for user customisation. May be nil.\n\tHelpCommand *CmdClause\n\t// Version flag. Exposed for user customisation. May be nil.\n\tVersionFlag *FlagClause\n}\n\n// New creates a new Kingpin application instance.\nfunc New(name, help string) *Application {\n\ta := &Application{\n\t\tName:          name,\n\t\tHelp:          help,\n\t\terrorWriter:   os.Stderr, // Left for backwards compatibility purposes.\n\t\tusageWriter:   os.Stderr,\n\t\tusageTemplate: DefaultUsageTemplate,\n\t\tterminate:     os.Exit,\n\t}\n\ta.flagGroup = newFlagGroup()\n\ta.argGroup = newArgGroup()\n\ta.cmdGroup = newCmdGroup(a)\n\ta.HelpFlag = a.Flag(\"help\", \"Show context-sensitive help (also try --help-long and --help-man).\")\n\ta.HelpFlag.Bool()\n\ta.Flag(\"help-long\", \"Generate long help.\").Hidden().PreAction(a.generateLongHelp).Bool()\n\ta.Flag(\"help-man\", \"Generate a man page.\").Hidden().PreAction(a.generateManPage).Bool()\n\ta.Flag(\"completion-bash\", \"Output possible completions for the given args.\").Hidden().BoolVar(&a.completion)\n\ta.Flag(\"completion-script-bash\", \"Generate completion script for bash.\").Hidden().PreAction(a.generateBashCompletionScript).Bool()\n\ta.Flag(\"completion-script-zsh\", \"Generate completion script for ZSH.\").Hidden().PreAction(a.generateZSHCompletionScript).Bool()\n\n\treturn a\n}\n\nfunc (a *Application) generateLongHelp(c *ParseContext) error {\n\ta.Writer(os.Stdout)\n\tif err := a.UsageForContextWithTemplate(c, 2, LongHelpTemplate); err != nil {\n\t\treturn err\n\t}\n\ta.terminate(0)\n\treturn nil\n}\n\nfunc (a *Application) generateManPage(c *ParseContext) error {\n\ta.Writer(os.Stdout)\n\tif err := a.UsageForContextWithTemplate(c, 2, ManPageTemplate); err != nil {\n\t\treturn err\n\t}\n\ta.terminate(0)\n\treturn nil\n}\n\nfunc (a *Application) generateBashCompletionScript(c *ParseContext) error {\n\ta.Writer(os.Stdout)\n\tif err := a.UsageForContextWithTemplate(c, 2, BashCompletionTemplate); err != nil {\n\t\treturn err\n\t}\n\ta.terminate(0)\n\treturn nil\n}\n\nfunc (a *Application) generateZSHCompletionScript(c *ParseContext) error {\n\ta.Writer(os.Stdout)\n\tif err := a.UsageForContextWithTemplate(c, 2, ZshCompletionTemplate); err != nil {\n\t\treturn err\n\t}\n\ta.terminate(0)\n\treturn nil\n}\n\n// DefaultEnvars configures all flags (that do not already have an associated\n// envar) to use a default environment variable in the form \"<app>_<flag>\".\n//\n// For example, if the application is named \"foo\" and a flag is named \"bar-\n// waz\" the environment variable: \"FOO_BAR_WAZ\".\nfunc (a *Application) DefaultEnvars() *Application {\n\ta.defaultEnvars = true\n\treturn a\n}\n\n// Terminate specifies the termination handler. Defaults to os.Exit(status).\n// If nil is passed, a no-op function will be used.\nfunc (a *Application) Terminate(terminate func(int)) *Application {\n\tif terminate == nil {\n\t\tterminate = func(int) {}\n\t}\n\ta.terminate = terminate\n\treturn a\n}\n\n// Writer specifies the writer to use for usage and errors. Defaults to os.Stderr.\n// DEPRECATED: See ErrorWriter and UsageWriter.\nfunc (a *Application) Writer(w io.Writer) *Application {\n\ta.errorWriter = w\n\ta.usageWriter = w\n\treturn a\n}\n\n// ErrorWriter sets the io.Writer to use for errors.\nfunc (a *Application) ErrorWriter(w io.Writer) *Application {\n\ta.errorWriter = w\n\treturn a\n}\n\n// UsageWriter sets the io.Writer to use for errors.\nfunc (a *Application) UsageWriter(w io.Writer) *Application {\n\ta.usageWriter = w\n\treturn a\n}\n\n// UsageTemplate specifies the text template to use when displaying usage\n// information. The default is UsageTemplate.\nfunc (a *Application) UsageTemplate(template string) *Application {\n\ta.usageTemplate = template\n\treturn a\n}\n\n// UsageFuncs adds extra functions that can be used in the usage template.\nfunc (a *Application) UsageFuncs(funcs template.FuncMap) *Application {\n\ta.usageFuncs = funcs\n\treturn a\n}\n\n// Validate sets a validation function to run when parsing.\nfunc (a *Application) Validate(validator ApplicationValidator) *Application {\n\ta.validator = validator\n\treturn a\n}\n\n// ParseContext parses the given command line and returns the fully populated\n// ParseContext.\nfunc (a *Application) ParseContext(args []string) (*ParseContext, error) {\n\treturn a.parseContext(false, args)\n}\n\nfunc (a *Application) parseContext(ignoreDefault bool, args []string) (*ParseContext, error) {\n\tif err := a.init(); err != nil {\n\t\treturn nil, err\n\t}\n\tcontext := tokenize(args, ignoreDefault)\n\terr := parse(context, a)\n\treturn context, err\n}\n\n// Parse parses command-line arguments. It returns the selected command and an\n// error. The selected command will be a space separated subcommand, if\n// subcommands have been configured.\n//\n// This will populate all flag and argument values, call all callbacks, and so\n// on.\nfunc (a *Application) Parse(args []string) (command string, err error) {\n\n\tcontext, parseErr := a.ParseContext(args)\n\tselected := []string{}\n\tvar setValuesErr error\n\n\tif context == nil {\n\t\t// Since we do not throw error immediately, there could be a case\n\t\t// where a context returns nil. Protect against that.\n\t\treturn \"\", parseErr\n\t}\n\n\tif err = a.setDefaults(context); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tselected, setValuesErr = a.setValues(context)\n\n\tif err = a.applyPreActions(context, !a.completion); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif a.completion {\n\t\ta.generateBashCompletion(context)\n\t\ta.terminate(0)\n\t} else {\n\t\tif parseErr != nil {\n\t\t\treturn \"\", parseErr\n\t\t}\n\n\t\ta.maybeHelp(context)\n\t\tif !context.EOL() {\n\t\t\treturn \"\", fmt.Errorf(\"unexpected argument '%s'\", context.Peek())\n\t\t}\n\n\t\tif setValuesErr != nil {\n\t\t\treturn \"\", setValuesErr\n\t\t}\n\n\t\tcommand, err = a.execute(context, selected)\n\t\tif err == ErrCommandNotSpecified {\n\t\t\ta.writeUsage(context, nil)\n\t\t}\n\t}\n\treturn command, err\n}\n\nfunc (a *Application) writeUsage(context *ParseContext, err error) {\n\tif err != nil {\n\t\ta.Errorf(\"%s\", err)\n\t}\n\tif err := a.UsageForContext(context); err != nil {\n\t\tpanic(err)\n\t}\n\tif err != nil {\n\t\ta.terminate(1)\n\t} else {\n\t\ta.terminate(0)\n\t}\n}\n\nfunc (a *Application) maybeHelp(context *ParseContext) {\n\tfor _, element := range context.Elements {\n\t\tif flag, ok := element.Clause.(*FlagClause); ok && flag == a.HelpFlag {\n\t\t\t// Re-parse the command-line ignoring defaults, so that help works correctly.\n\t\t\tcontext, _ = a.parseContext(true, context.rawArgs)\n\t\t\ta.writeUsage(context, nil)\n\t\t}\n\t}\n}\n\n// Version adds a --version flag for displaying the application version.\nfunc (a *Application) Version(version string) *Application {\n\ta.version = version\n\ta.VersionFlag = a.Flag(\"version\", \"Show application version.\").PreAction(func(*ParseContext) error {\n\t\tfmt.Fprintln(a.usageWriter, version)\n\t\ta.terminate(0)\n\t\treturn nil\n\t})\n\ta.VersionFlag.Bool()\n\treturn a\n}\n\n// Author sets the author output by some help templates.\nfunc (a *Application) Author(author string) *Application {\n\ta.author = author\n\treturn a\n}\n\n// Action callback to call when all values are populated and parsing is\n// complete, but before any command, flag or argument actions.\n//\n// All Action() callbacks are called in the order they are encountered on the\n// command line.\nfunc (a *Application) Action(action Action) *Application {\n\ta.addAction(action)\n\treturn a\n}\n\n// Action called after parsing completes but before validation and execution.\nfunc (a *Application) PreAction(action Action) *Application {\n\ta.addPreAction(action)\n\treturn a\n}\n\n// Command adds a new top-level command.\nfunc (a *Application) Command(name, help string) *CmdClause {\n\treturn a.addCommand(name, help)\n}\n\n// Interspersed control if flags can be interspersed with positional arguments\n//\n// true (the default) means that they can, false means that all the flags must appear before the first positional arguments.\nfunc (a *Application) Interspersed(interspersed bool) *Application {\n\ta.noInterspersed = !interspersed\n\treturn a\n}\n\nfunc (a *Application) defaultEnvarPrefix() string {\n\tif a.defaultEnvars {\n\t\treturn a.Name\n\t}\n\treturn \"\"\n}\n\nfunc (a *Application) init() error {\n\tif a.initialized {\n\t\treturn nil\n\t}\n\tif a.cmdGroup.have() && a.argGroup.have() {\n\t\treturn fmt.Errorf(\"can't mix top-level Arg()s with Command()s\")\n\t}\n\n\t// If we have subcommands, add a help command at the top-level.\n\tif a.cmdGroup.have() {\n\t\tvar command []string\n\t\ta.HelpCommand = a.Command(\"help\", \"Show help.\").PreAction(func(context *ParseContext) error {\n\t\t\ta.Usage(command)\n\t\t\ta.terminate(0)\n\t\t\treturn nil\n\t\t})\n\t\ta.HelpCommand.Arg(\"command\", \"Show help on command.\").StringsVar(&command)\n\t\t// Make help first command.\n\t\tl := len(a.commandOrder)\n\t\ta.commandOrder = append(a.commandOrder[l-1:l], a.commandOrder[:l-1]...)\n\t}\n\n\tif err := a.flagGroup.init(a.defaultEnvarPrefix()); err != nil {\n\t\treturn err\n\t}\n\tif err := a.cmdGroup.init(); err != nil {\n\t\treturn err\n\t}\n\tif err := a.argGroup.init(); err != nil {\n\t\treturn err\n\t}\n\tfor _, cmd := range a.commands {\n\t\tif err := cmd.init(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tflagGroups := []*flagGroup{a.flagGroup}\n\tfor _, cmd := range a.commandOrder {\n\t\tif err := checkDuplicateFlags(cmd, flagGroups); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\ta.initialized = true\n\treturn nil\n}\n\n// Recursively check commands for duplicate flags.\nfunc checkDuplicateFlags(current *CmdClause, flagGroups []*flagGroup) error {\n\t// Check for duplicates.\n\tfor _, flags := range flagGroups {\n\t\tfor _, flag := range current.flagOrder {\n\t\t\tif flag.shorthand != 0 {\n\t\t\t\tif _, ok := flags.short[string(flag.shorthand)]; ok {\n\t\t\t\t\treturn fmt.Errorf(\"duplicate short flag -%c\", flag.shorthand)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, ok := flags.long[flag.name]; ok {\n\t\t\t\treturn fmt.Errorf(\"duplicate long flag --%s\", flag.name)\n\t\t\t}\n\t\t}\n\t}\n\tflagGroups = append(flagGroups, current.flagGroup)\n\t// Check subcommands.\n\tfor _, subcmd := range current.commandOrder {\n\t\tif err := checkDuplicateFlags(subcmd, flagGroups); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (a *Application) execute(context *ParseContext, selected []string) (string, error) {\n\tvar err error\n\n\tif err = a.validateRequired(context); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err = a.applyValidators(context); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif err = a.applyActions(context); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcommand := strings.Join(selected, \" \")\n\tif command == \"\" && a.cmdGroup.have() {\n\t\treturn \"\", ErrCommandNotSpecified\n\t}\n\treturn command, err\n}\n\nfunc (a *Application) setDefaults(context *ParseContext) error {\n\tflagElements := map[string]*ParseElement{}\n\tfor _, element := range context.Elements {\n\t\tif flag, ok := element.Clause.(*FlagClause); ok {\n\t\t\tif flag.name == \"help\" {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif flag.name == \"version\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tflagElements[flag.name] = element\n\t\t}\n\t}\n\n\targElements := map[string]*ParseElement{}\n\tfor _, element := range context.Elements {\n\t\tif arg, ok := element.Clause.(*ArgClause); ok {\n\t\t\targElements[arg.name] = element\n\t\t}\n\t}\n\n\t// Check required flags and set defaults.\n\tfor _, flag := range context.flags.long {\n\t\tif flagElements[flag.name] == nil {\n\t\t\tif err := flag.setDefault(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, arg := range context.arguments.args {\n\t\tif argElements[arg.name] == nil {\n\t\t\tif err := arg.setDefault(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a *Application) validateRequired(context *ParseContext) error {\n\tflagElements := map[string]*ParseElement{}\n\tfor _, element := range context.Elements {\n\t\tif flag, ok := element.Clause.(*FlagClause); ok {\n\t\t\tflagElements[flag.name] = element\n\t\t}\n\t}\n\n\targElements := map[string]*ParseElement{}\n\tfor _, element := range context.Elements {\n\t\tif arg, ok := element.Clause.(*ArgClause); ok {\n\t\t\targElements[arg.name] = element\n\t\t}\n\t}\n\n\t// Check required flags and set defaults.\n\tvar missingFlags []string\n\tfor _, flag := range context.flags.long {\n\t\tif flagElements[flag.name] == nil {\n\t\t\t// Check required flags were provided.\n\t\t\tif flag.needsValue() {\n\t\t\t\tmissingFlags = append(missingFlags, fmt.Sprintf(\"'--%s'\", flag.name))\n\t\t\t}\n\t\t}\n\t}\n\tif len(missingFlags) != 0 {\n\t\treturn fmt.Errorf(\"required flag(s) %s not provided\", strings.Join(missingFlags, \", \"))\n\t}\n\n\tfor _, arg := range context.arguments.args {\n\t\tif argElements[arg.name] == nil {\n\t\t\tif arg.needsValue() {\n\t\t\t\treturn fmt.Errorf(\"required argument '%s' not provided\", arg.name)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (a *Application) setValues(context *ParseContext) (selected []string, err error) {\n\t// Set all arg and flag values.\n\tvar (\n\t\tlastCmd *CmdClause\n\t\tflagSet = map[string]struct{}{}\n\t)\n\tfor _, element := range context.Elements {\n\t\tswitch clause := element.Clause.(type) {\n\t\tcase *FlagClause:\n\t\t\tif _, ok := flagSet[clause.name]; ok {\n\t\t\t\tif v, ok := clause.value.(repeatableFlag); !ok || !v.IsCumulative() {\n\t\t\t\t\treturn nil, fmt.Errorf(\"flag '%s' cannot be repeated\", clause.name)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err = clause.value.Set(*element.Value); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tflagSet[clause.name] = struct{}{}\n\n\t\tcase *ArgClause:\n\t\t\tif err = clause.value.Set(*element.Value); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\tcase *CmdClause:\n\t\t\tselected = append(selected, clause.name)\n\t\t\tlastCmd = clause\n\t\t}\n\t}\n\n\tif lastCmd != nil && len(lastCmd.commands) > 0 {\n\t\treturn nil, fmt.Errorf(\"must select a subcommand of '%s'\", lastCmd.FullCommand())\n\t}\n\n\treturn\n}\n\nfunc (a *Application) applyValidators(context *ParseContext) (err error) {\n\t// Call command validation functions.\n\tfor _, element := range context.Elements {\n\t\tif cmd, ok := element.Clause.(*CmdClause); ok && cmd.validator != nil {\n\t\t\tif err = cmd.validator(cmd); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif a.validator != nil {\n\t\terr = a.validator(a)\n\t}\n\treturn err\n}\n\nfunc (a *Application) applyPreActions(context *ParseContext, dispatch bool) error {\n\tif err := a.actionMixin.applyPreActions(context); err != nil {\n\t\treturn err\n\t}\n\t// Dispatch to actions.\n\tif dispatch {\n\t\tfor _, element := range context.Elements {\n\t\t\tif applier, ok := element.Clause.(actionApplier); ok {\n\t\t\t\tif err := applier.applyPreActions(context); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a *Application) applyActions(context *ParseContext) error {\n\tif err := a.actionMixin.applyActions(context); err != nil {\n\t\treturn err\n\t}\n\t// Dispatch to actions.\n\tfor _, element := range context.Elements {\n\t\tif applier, ok := element.Clause.(actionApplier); ok {\n\t\t\tif err := applier.applyActions(context); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Errorf prints an error message to w in the format \"<appname>: error: <message>\".\nfunc (a *Application) Errorf(format string, args ...interface{}) {\n\tfmt.Fprintf(a.errorWriter, a.Name+\": error: \"+format+\"\\n\", args...)\n}\n\n// Fatalf writes a formatted error to w then terminates with exit status 1.\nfunc (a *Application) Fatalf(format string, args ...interface{}) {\n\ta.Errorf(format, args...)\n\ta.terminate(1)\n}\n\n// FatalUsage prints an error message followed by usage information, then\n// exits with a non-zero status.\nfunc (a *Application) FatalUsage(format string, args ...interface{}) {\n\ta.Errorf(format, args...)\n\t// Force usage to go to error output.\n\ta.usageWriter = a.errorWriter\n\ta.Usage([]string{})\n\ta.terminate(1)\n}\n\n// FatalUsageContext writes a printf formatted error message to w, then usage\n// information for the given ParseContext, before exiting.\nfunc (a *Application) FatalUsageContext(context *ParseContext, format string, args ...interface{}) {\n\ta.Errorf(format, args...)\n\tif err := a.UsageForContext(context); err != nil {\n\t\tpanic(err)\n\t}\n\ta.terminate(1)\n}\n\n// FatalIfError prints an error and exits if err is not nil. The error is printed\n// with the given formatted string, if any.\nfunc (a *Application) FatalIfError(err error, format string, args ...interface{}) {\n\tif err != nil {\n\t\tprefix := \"\"\n\t\tif format != \"\" {\n\t\t\tprefix = fmt.Sprintf(format, args...) + \": \"\n\t\t}\n\t\ta.Errorf(prefix+\"%s\", err)\n\t\ta.terminate(1)\n\t}\n}\n\nfunc (a *Application) completionOptions(context *ParseContext) []string {\n\targs := context.rawArgs\n\n\tvar (\n\t\tcurrArg string\n\t\tprevArg string\n\t\ttarget  cmdMixin\n\t)\n\n\tnumArgs := len(args)\n\tif numArgs > 1 {\n\t\targs = args[1:]\n\t\tcurrArg = args[len(args)-1]\n\t}\n\tif numArgs > 2 {\n\t\tprevArg = args[len(args)-2]\n\t}\n\n\ttarget = a.cmdMixin\n\tif context.SelectedCommand != nil {\n\t\t// A subcommand was in use. We will use it as the target\n\t\ttarget = context.SelectedCommand.cmdMixin\n\t}\n\n\tif (currArg != \"\" && strings.HasPrefix(currArg, \"--\")) || strings.HasPrefix(prevArg, \"--\") {\n\t\tif context.argsOnly {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Perform completion for A flag. The last/current argument started with \"-\"\n\t\tvar (\n\t\t\tflagName  string // The name of a flag if given (could be half complete)\n\t\t\tflagValue string // The value assigned to a flag (if given) (could be half complete)\n\t\t)\n\n\t\tif strings.HasPrefix(prevArg, \"--\") && !strings.HasPrefix(currArg, \"--\") {\n\t\t\t// Matches: \t./myApp --flag value\n\t\t\t// Wont Match: \t./myApp --flag --\n\t\t\tflagName = prevArg[2:] // Strip the \"--\"\n\t\t\tflagValue = currArg\n\t\t} else if strings.HasPrefix(currArg, \"--\") {\n\t\t\t// Matches: \t./myApp --flag --\n\t\t\t// Matches:\t\t./myApp --flag somevalue --\n\t\t\t// Matches: \t./myApp --\n\t\t\tflagName = currArg[2:] // Strip the \"--\"\n\t\t}\n\n\t\toptions, flagMatched, valueMatched := target.FlagCompletion(flagName, flagValue)\n\t\tif valueMatched {\n\t\t\t// Value Matched. Show cmdCompletions\n\t\t\treturn target.CmdCompletion(context)\n\t\t}\n\n\t\t// Add top level flags if we're not at the top level and no match was found.\n\t\tif context.SelectedCommand != nil && !flagMatched {\n\t\t\ttopOptions, topFlagMatched, topValueMatched := a.FlagCompletion(flagName, flagValue)\n\t\t\tif topValueMatched {\n\t\t\t\t// Value Matched. Back to cmdCompletions\n\t\t\t\treturn target.CmdCompletion(context)\n\t\t\t}\n\n\t\t\tif topFlagMatched {\n\t\t\t\t// Top level had a flag which matched the input. Return it's options.\n\t\t\t\toptions = topOptions\n\t\t\t} else {\n\t\t\t\t// Add top level flags\n\t\t\t\toptions = append(options, topOptions...)\n\t\t\t}\n\t\t}\n\t\treturn options\n\t}\n\n\t// Perform completion for sub commands and arguments.\n\treturn target.CmdCompletion(context)\n}\n\nfunc (a *Application) generateBashCompletion(context *ParseContext) {\n\toptions := a.completionOptions(context)\n\tfmt.Printf(\"%s\", strings.Join(options, \"\\n\"))\n}\n\nfunc envarTransform(name string) string {\n\treturn strings.ToUpper(envarTransformRegexp.ReplaceAllString(name, \"_\"))\n}\n"
        },
        {
          "name": "app_test.go",
          "type": "blob",
          "size": 11.9814453125,
          "content": "package kingpin\n\nimport (\n\t\"errors\"\n\t\"io/ioutil\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc newTestApp() *Application {\n\treturn New(\"test\", \"\").Terminate(nil)\n}\n\nfunc TestCommander(t *testing.T) {\n\tc := newTestApp()\n\tping := c.Command(\"ping\", \"Ping an IP address.\")\n\tpingTTL := ping.Flag(\"ttl\", \"TTL for ICMP packets\").Short('t').Default(\"5s\").Duration()\n\n\tselected, err := c.Parse([]string{\"ping\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"ping\", selected)\n\tassert.Equal(t, 5*time.Second, *pingTTL)\n\n\tselected, err = c.Parse([]string{\"ping\", \"--ttl=10s\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"ping\", selected)\n\tassert.Equal(t, 10*time.Second, *pingTTL)\n}\n\nfunc TestRequiredFlags(t *testing.T) {\n\tc := newTestApp()\n\tc.Flag(\"a\", \"a\").String()\n\tc.Flag(\"b\", \"b\").Required().String()\n\n\t_, err := c.Parse([]string{\"--a=foo\"})\n\tassert.Error(t, err)\n\t_, err = c.Parse([]string{\"--b=foo\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestRepeatableFlags(t *testing.T) {\n\tc := newTestApp()\n\tc.Flag(\"a\", \"a\").String()\n\tc.Flag(\"b\", \"b\").Strings()\n\t_, err := c.Parse([]string{\"--a=foo\", \"--a=bar\"})\n\tassert.Error(t, err)\n\t_, err = c.Parse([]string{\"--b=foo\", \"--b=bar\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestInvalidDefaultFlagValueErrors(t *testing.T) {\n\tc := newTestApp()\n\tc.Flag(\"foo\", \"foo\").Default(\"a\").Int()\n\t_, err := c.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestInvalidDefaultArgValueErrors(t *testing.T) {\n\tc := newTestApp()\n\tcmd := c.Command(\"cmd\", \"cmd\")\n\tcmd.Arg(\"arg\", \"arg\").Default(\"one\").Int()\n\t_, err := c.Parse([]string{\"cmd\"})\n\tassert.Error(t, err)\n}\n\nfunc TestArgsRequiredAfterNonRequiredErrors(t *testing.T) {\n\tc := newTestApp()\n\tcmd := c.Command(\"cmd\", \"\")\n\tcmd.Arg(\"a\", \"a\").String()\n\tcmd.Arg(\"b\", \"b\").Required().String()\n\t_, err := c.Parse([]string{\"cmd\"})\n\tassert.Error(t, err)\n}\n\nfunc TestArgsMultipleRequiredThenNonRequired(t *testing.T) {\n\tc := newTestApp().Writer(ioutil.Discard)\n\tcmd := c.Command(\"cmd\", \"\")\n\tcmd.Arg(\"a\", \"a\").Required().String()\n\tcmd.Arg(\"b\", \"b\").Required().String()\n\tcmd.Arg(\"c\", \"c\").String()\n\tcmd.Arg(\"d\", \"d\").String()\n\t_, err := c.Parse([]string{\"cmd\", \"a\", \"b\"})\n\tassert.NoError(t, err)\n\t_, err = c.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestDispatchCallbackIsCalled(t *testing.T) {\n\tdispatched := false\n\tc := newTestApp()\n\tc.Command(\"cmd\", \"\").Action(func(*ParseContext) error {\n\t\tdispatched = true\n\t\treturn nil\n\t})\n\n\t_, err := c.Parse([]string{\"cmd\"})\n\tassert.NoError(t, err)\n\tassert.True(t, dispatched)\n}\n\nfunc TestTopLevelArgWorks(t *testing.T) {\n\tc := newTestApp()\n\ts := c.Arg(\"arg\", \"help\").String()\n\t_, err := c.Parse([]string{\"foo\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", *s)\n}\n\nfunc TestTopLevelArgCantBeUsedWithCommands(t *testing.T) {\n\tc := newTestApp()\n\tc.Arg(\"arg\", \"help\").String()\n\tc.Command(\"cmd\", \"help\")\n\t_, err := c.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestTooManyArgs(t *testing.T) {\n\ta := newTestApp()\n\ta.Arg(\"a\", \"\").String()\n\t_, err := a.Parse([]string{\"a\", \"b\"})\n\tassert.Error(t, err)\n}\n\nfunc TestTooManyArgsAfterCommand(t *testing.T) {\n\ta := newTestApp()\n\ta.Command(\"a\", \"\")\n\tassert.NoError(t, a.init())\n\t_, err := a.Parse([]string{\"a\", \"b\"})\n\tassert.Error(t, err)\n}\n\nfunc TestArgsLooksLikeFlagsWithConsumeRemainder(t *testing.T) {\n\ta := newTestApp()\n\ta.Arg(\"opts\", \"\").Required().Strings()\n\t_, err := a.Parse([]string{\"hello\", \"-world\"})\n\tassert.Error(t, err)\n}\n\nfunc TestCommandParseDoesNotResetFlagsToDefault(t *testing.T) {\n\tapp := newTestApp()\n\tflag := app.Flag(\"flag\", \"\").Default(\"default\").String()\n\tapp.Command(\"cmd\", \"\")\n\n\t_, err := app.Parse([]string{\"--flag=123\", \"cmd\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"123\", *flag)\n}\n\nfunc TestCommandParseDoesNotFailRequired(t *testing.T) {\n\tapp := newTestApp()\n\tflag := app.Flag(\"flag\", \"\").Required().String()\n\tapp.Command(\"cmd\", \"\")\n\n\t_, err := app.Parse([]string{\"cmd\", \"--flag=123\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"123\", *flag)\n}\n\nfunc TestSelectedCommand(t *testing.T) {\n\tapp := newTestApp()\n\tc0 := app.Command(\"c0\", \"\")\n\tc0.Command(\"c1\", \"\")\n\ts, err := app.Parse([]string{\"c0\", \"c1\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"c0 c1\", s)\n}\n\nfunc TestSubCommandRequired(t *testing.T) {\n\tapp := newTestApp()\n\tc0 := app.Command(\"c0\", \"\")\n\tc0.Command(\"c1\", \"\")\n\t_, err := app.Parse([]string{\"c0\"})\n\tassert.Error(t, err)\n}\n\nfunc TestInterspersedFalse(t *testing.T) {\n\tapp := newTestApp().Interspersed(false)\n\ta1 := app.Arg(\"a1\", \"\").String()\n\ta2 := app.Arg(\"a2\", \"\").String()\n\tf1 := app.Flag(\"flag\", \"\").String()\n\n\t_, err := app.Parse([]string{\"a1\", \"--flag=flag\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"a1\", *a1)\n\tassert.Equal(t, \"--flag=flag\", *a2)\n\tassert.Equal(t, \"\", *f1)\n}\n\nfunc TestInterspersedTrue(t *testing.T) {\n\t// test once with the default value and once with explicit true\n\tfor i := 0; i < 2; i++ {\n\t\tapp := newTestApp()\n\t\tif i != 0 {\n\t\t\tt.Log(\"Setting explicit\")\n\t\t\tapp.Interspersed(true)\n\t\t} else {\n\t\t\tt.Log(\"Using default\")\n\t\t}\n\t\ta1 := app.Arg(\"a1\", \"\").String()\n\t\ta2 := app.Arg(\"a2\", \"\").String()\n\t\tf1 := app.Flag(\"flag\", \"\").String()\n\n\t\t_, err := app.Parse([]string{\"a1\", \"--flag=flag\"})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"a1\", *a1)\n\t\tassert.Equal(t, \"\", *a2)\n\t\tassert.Equal(t, \"flag\", *f1)\n\t}\n}\n\nfunc TestDefaultEnvars(t *testing.T) {\n\ta := New(\"some-app\", \"\").Terminate(nil).DefaultEnvars()\n\tf0 := a.Flag(\"some-flag\", \"\")\n\tf0.Bool()\n\tf1 := a.Flag(\"some-other-flag\", \"\").NoEnvar()\n\tf1.Bool()\n\tf2 := a.Flag(\"a-1-flag\", \"\")\n\tf2.Bool()\n\t_, err := a.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"SOME_APP_SOME_FLAG\", f0.envar)\n\tassert.Equal(t, \"\", f1.envar)\n\tassert.Equal(t, \"SOME_APP_A_1_FLAG\", f2.envar)\n}\n\nfunc TestBashCompletionOptionsWithEmptyApp(t *testing.T) {\n\ta := newTestApp()\n\tcontext, err := a.ParseContext([]string{\"--completion-bash\"})\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error whilst parsing context: [%v]\", err)\n\t}\n\targs := a.completionOptions(context)\n\tassert.Equal(t, []string(nil), args)\n}\n\nfunc TestBashCompletionOptions(t *testing.T) {\n\ta := newTestApp()\n\ta.Command(\"one\", \"\")\n\ta.Flag(\"flag-0\", \"\").String()\n\ta.Flag(\"flag-1\", \"\").HintOptions(\"opt1\", \"opt2\", \"opt3\").String()\n\n\ttwo := a.Command(\"two\", \"\")\n\ttwo.Flag(\"flag-2\", \"\").String()\n\ttwo.Flag(\"flag-3\", \"\").HintOptions(\"opt4\", \"opt5\", \"opt6\").String()\n\n\tthree := a.Command(\"three\", \"\")\n\tthree.Flag(\"flag-4\", \"\").String()\n\tthree.Arg(\"arg-1\", \"\").String()\n\tthree.Arg(\"arg-2\", \"\").HintOptions(\"arg-2-opt-1\", \"arg-2-opt-2\").String()\n\tthree.Arg(\"arg-3\", \"\").String()\n\tthree.Arg(\"arg-4\", \"\").HintAction(func() []string {\n\t\treturn []string{\"arg-4-opt-1\", \"arg-4-opt-2\"}\n\t}).String()\n\n\tcases := []struct {\n\t\tArgs            string\n\t\tExpectedOptions []string\n\t}{\n\t\t{\n\t\t\tArgs:            \"--completion-bash\",\n\t\t\tExpectedOptions: []string{\"help\", \"one\", \"three\", \"two\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --\",\n\t\t\tExpectedOptions: []string{\"--flag-0\", \"--flag-1\", \"--help\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --fla\",\n\t\t\tExpectedOptions: []string{\"--flag-0\", \"--flag-1\", \"--help\"},\n\t\t},\n\t\t{\n\t\t\t// No options available for flag-0, return to cmd completion\n\t\t\tArgs:            \"--completion-bash --flag-0\",\n\t\t\tExpectedOptions: []string{\"help\", \"one\", \"three\", \"two\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --flag-0 --\",\n\t\t\tExpectedOptions: []string{\"--flag-0\", \"--flag-1\", \"--help\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --flag-1\",\n\t\t\tExpectedOptions: []string{\"opt1\", \"opt2\", \"opt3\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --flag-1 opt\",\n\t\t\tExpectedOptions: []string{\"opt1\", \"opt2\", \"opt3\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --flag-1 opt1\",\n\t\t\tExpectedOptions: []string{\"help\", \"one\", \"three\", \"two\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash --flag-1 opt1 --\",\n\t\t\tExpectedOptions: []string{\"--flag-0\", \"--flag-1\", \"--help\"},\n\t\t},\n\n\t\t// Try Subcommand\n\t\t{\n\t\t\tArgs:            \"--completion-bash two\",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --\",\n\t\t\tExpectedOptions: []string{\"--help\", \"--flag-2\", \"--flag-3\", \"--flag-0\", \"--flag-1\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --flag\",\n\t\t\tExpectedOptions: []string{\"--help\", \"--flag-2\", \"--flag-3\", \"--flag-0\", \"--flag-1\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --flag-2\",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\t// Top level flags carry downwards\n\t\t\tArgs:            \"--completion-bash two --flag-1\",\n\t\t\tExpectedOptions: []string{\"opt1\", \"opt2\", \"opt3\"},\n\t\t},\n\t\t{\n\t\t\t// Top level flags carry downwards\n\t\t\tArgs:            \"--completion-bash two --flag-1 opt\",\n\t\t\tExpectedOptions: []string{\"opt1\", \"opt2\", \"opt3\"},\n\t\t},\n\t\t{\n\t\t\t// Top level flags carry downwards\n\t\t\tArgs:            \"--completion-bash two --flag-1 opt1\",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --flag-3\",\n\t\t\tExpectedOptions: []string{\"opt4\", \"opt5\", \"opt6\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --flag-3 opt\",\n\t\t\tExpectedOptions: []string{\"opt4\", \"opt5\", \"opt6\"},\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --flag-3 opt4\",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\tArgs:            \"--completion-bash two --flag-3 opt4 --\",\n\t\t\tExpectedOptions: []string{\"--help\", \"--flag-2\", \"--flag-3\", \"--flag-0\", \"--flag-1\"},\n\t\t},\n\n\t\t// Args complete\n\t\t{\n\t\t\t// After a command with an arg with no options, nothing should be\n\t\t\t// shown\n\t\t\tArgs:            \"--completion-bash three \",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\t// After a command with an arg, explicitly starting a flag should\n\t\t\t// complete flags\n\t\t\tArgs:            \"--completion-bash three --\",\n\t\t\tExpectedOptions: []string{\"--flag-0\", \"--flag-1\", \"--flag-4\", \"--help\"},\n\t\t},\n\t\t{\n\t\t\t// After a command with an arg that does have completions, they\n\t\t\t// should be shown\n\t\t\tArgs:            \"--completion-bash three arg1 \",\n\t\t\tExpectedOptions: []string{\"arg-2-opt-1\", \"arg-2-opt-2\"},\n\t\t},\n\t\t{\n\t\t\t// After a command with an arg that does have completions, but a\n\t\t\t// flag is started, flag options should be completed\n\t\t\tArgs:            \"--completion-bash three arg1 --\",\n\t\t\tExpectedOptions: []string{\"--flag-0\", \"--flag-1\", \"--flag-4\", \"--help\"},\n\t\t},\n\t\t{\n\t\t\t// After a command with an arg that has no completions, and isn't first,\n\t\t\t// nothing should be shown\n\t\t\tArgs:            \"--completion-bash three arg1 arg2 \",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\t// After a command with a different arg that also has completions,\n\t\t\t// those different options should be shown\n\t\t\tArgs:            \"--completion-bash three arg1 arg2 arg3 \",\n\t\t\tExpectedOptions: []string{\"arg-4-opt-1\", \"arg-4-opt-2\"},\n\t\t},\n\t\t{\n\t\t\t// After a command with all args listed, nothing should complete\n\t\t\tArgs:            \"--completion-bash three arg1 arg2 arg3 arg4\",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\t// After a -- argument, no more flags should be suggested\n\t\t\tArgs:            \"--completion-bash three --flag-0 -- --\",\n\t\t\tExpectedOptions: []string(nil),\n\t\t},\n\t\t{\n\t\t\t// After a -- argument, argument options should still be suggested\n\t\t\tArgs:            \"--completion-bash three -- arg1 \",\n\t\t\tExpectedOptions: []string{\"arg-2-opt-1\", \"arg-2-opt-2\"},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tcontext, _ := a.ParseContext(strings.Split(c.Args, \" \"))\n\t\targs := a.completionOptions(context)\n\n\t\tsort.Strings(args)\n\t\tsort.Strings(c.ExpectedOptions)\n\n\t\tassert.Equal(t, c.ExpectedOptions, args, \"Expected != Actual: [%v] != [%v]. \\nInput was: [%v]\", c.ExpectedOptions, args, c.Args)\n\t}\n\n}\n\nfunc TestCmdValidation(t *testing.T) {\n\tc := newTestApp()\n\tcmd := c.Command(\"cmd\", \"\")\n\n\tvar a, b string\n\tcmd.Flag(\"a\", \"a\").StringVar(&a)\n\tcmd.Flag(\"b\", \"b\").StringVar(&b)\n\tcmd.Validate(func(*CmdClause) error {\n\t\tif a == \"\" && b == \"\" {\n\t\t\treturn errors.New(\"must specify either a or b\")\n\t\t}\n\t\treturn nil\n\t})\n\n\t_, err := c.Parse([]string{\"cmd\"})\n\tassert.Error(t, err)\n\n\t_, err = c.Parse([]string{\"cmd\", \"--a\", \"A\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestVersion(t *testing.T) {\n\tc := newTestApp()\n\tc.Flag(\"config\", \"path to config file\").Default(\"config.yaml\").ExistingFile()\n\tc.Version(\"1.0.0\")\n\n\t// the pre-action for version should be executed without running validation\n\t// for ExistingFile\n\t_, err := c.Parse([]string{\"--version\"})\n\tassert.NoError(t, err)\n}\n"
        },
        {
          "name": "args.go",
          "type": "blob",
          "size": 4.51953125,
          "content": "package kingpin\n\nimport (\n\t\"fmt\"\n)\n\ntype argGroup struct {\n\targs []*ArgClause\n}\n\nfunc newArgGroup() *argGroup {\n\treturn &argGroup{}\n}\n\nfunc (a *argGroup) have() bool {\n\treturn len(a.args) > 0\n}\n\n// GetArg gets an argument definition.\n//\n// This allows existing arguments to be modified after definition but before parsing. Useful for\n// modular applications.\nfunc (a *argGroup) GetArg(name string) *ArgClause {\n\tfor _, arg := range a.args {\n\t\tif arg.name == name {\n\t\t\treturn arg\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (a *argGroup) Arg(name, help string) *ArgClause {\n\targ := newArg(name, help)\n\ta.args = append(a.args, arg)\n\treturn arg\n}\n\nfunc (a *argGroup) init() error {\n\trequired := 0\n\tseen := map[string]struct{}{}\n\tpreviousArgMustBeLast := false\n\tfor i, arg := range a.args {\n\t\tif previousArgMustBeLast {\n\t\t\treturn fmt.Errorf(\"Args() can't be followed by another argument '%s'\", arg.name)\n\t\t}\n\t\tif arg.consumesRemainder() {\n\t\t\tpreviousArgMustBeLast = true\n\t\t}\n\t\tif _, ok := seen[arg.name]; ok {\n\t\t\treturn fmt.Errorf(\"duplicate argument '%s'\", arg.name)\n\t\t}\n\t\tseen[arg.name] = struct{}{}\n\t\tif arg.required && required != i {\n\t\t\treturn fmt.Errorf(\"required arguments found after non-required\")\n\t\t}\n\t\tif arg.required {\n\t\t\trequired++\n\t\t}\n\t\tif err := arg.init(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype ArgClause struct {\n\tactionMixin\n\tparserMixin\n\tcompletionsMixin\n\tenvarMixin\n\tname          string\n\thelp          string\n\tdefaultValues []string\n\tplaceholder   string\n\thidden        bool\n\trequired      bool\n}\n\nfunc newArg(name, help string) *ArgClause {\n\ta := &ArgClause{\n\t\tname: name,\n\t\thelp: help,\n\t}\n\treturn a\n}\n\nfunc (a *ArgClause) setDefault() error {\n\tif a.HasEnvarValue() {\n\t\tif v, ok := a.value.(remainderArg); !ok || !v.IsCumulative() {\n\t\t\t// Use the value as-is\n\t\t\treturn a.value.Set(a.GetEnvarValue())\n\t\t}\n\t\tfor _, value := range a.GetSplitEnvarValue() {\n\t\t\tif err := a.value.Set(value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tif len(a.defaultValues) > 0 {\n\t\tfor _, defaultValue := range a.defaultValues {\n\t\t\tif err := a.value.Set(defaultValue); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc (a *ArgClause) needsValue() bool {\n\thaveDefault := len(a.defaultValues) > 0\n\treturn a.required && !(haveDefault || a.HasEnvarValue())\n}\n\nfunc (a *ArgClause) consumesRemainder() bool {\n\tif r, ok := a.value.(remainderArg); ok {\n\t\treturn r.IsCumulative()\n\t}\n\treturn false\n}\n\n// Hidden hides the argument from usage but still allows it to be used.\nfunc (a *ArgClause) Hidden() *ArgClause {\n\ta.hidden = true\n\treturn a\n}\n\n// PlaceHolder sets the place-holder string used for arg values in the help. The\n// default behaviour is to use the arg name between < > brackets.\nfunc (a *ArgClause) PlaceHolder(value string) *ArgClause {\n\ta.placeholder = value\n\treturn a\n}\n\n// Required arguments must be input by the user. They can not have a Default() value provided.\nfunc (a *ArgClause) Required() *ArgClause {\n\ta.required = true\n\treturn a\n}\n\n// Default values for this argument. They *must* be parseable by the value of the argument.\nfunc (a *ArgClause) Default(values ...string) *ArgClause {\n\ta.defaultValues = values\n\treturn a\n}\n\n// Envar overrides the default value(s) for a flag from an environment variable,\n// if it is set. Several default values can be provided by using new lines to\n// separate them.\nfunc (a *ArgClause) Envar(name string) *ArgClause {\n\ta.envar = name\n\ta.noEnvar = false\n\treturn a\n}\n\n// NoEnvar forces environment variable defaults to be disabled for this flag.\n// Most useful in conjunction with app.DefaultEnvars().\nfunc (a *ArgClause) NoEnvar() *ArgClause {\n\ta.envar = \"\"\n\ta.noEnvar = true\n\treturn a\n}\n\nfunc (a *ArgClause) Action(action Action) *ArgClause {\n\ta.addAction(action)\n\treturn a\n}\n\nfunc (a *ArgClause) PreAction(action Action) *ArgClause {\n\ta.addPreAction(action)\n\treturn a\n}\n\n// HintAction registers a HintAction (function) for the arg to provide completions\nfunc (a *ArgClause) HintAction(action HintAction) *ArgClause {\n\ta.addHintAction(action)\n\treturn a\n}\n\n// HintOptions registers any number of options for the flag to provide completions\nfunc (a *ArgClause) HintOptions(options ...string) *ArgClause {\n\ta.addHintAction(func() []string {\n\t\treturn options\n\t})\n\treturn a\n}\n\n// Help sets the help message.\nfunc (a *ArgClause) Help(help string) *ArgClause {\n\ta.help = help\n\treturn a\n}\n\nfunc (a *ArgClause) init() error {\n\tif a.required && len(a.defaultValues) > 0 {\n\t\treturn fmt.Errorf(\"required argument '%s' with unusable default value\", a.name)\n\t}\n\tif a.value == nil {\n\t\treturn fmt.Errorf(\"no parser defined for arg '%s'\", a.name)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "args_test.go",
          "type": "blob",
          "size": 2.1396484375,
          "content": "package kingpin\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestArgRemainder(t *testing.T) {\n\tapp := New(\"test\", \"\")\n\tv := app.Arg(\"test\", \"\").Strings()\n\targs := []string{\"hello\", \"world\"}\n\t_, err := app.Parse(args)\n\tassert.NoError(t, err)\n\tassert.Equal(t, args, *v)\n}\n\nfunc TestArgRemainderErrorsWhenNotLast(t *testing.T) {\n\ta := newArgGroup()\n\ta.Arg(\"test\", \"\").Strings()\n\ta.Arg(\"test2\", \"\").String()\n\tassert.Error(t, a.init())\n}\n\nfunc TestArgMultipleRequired(t *testing.T) {\n\tterminated := false\n\tapp := New(\"test\", \"\")\n\tapp.Version(\"0.0.0\").Writer(ioutil.Discard)\n\tapp.Arg(\"a\", \"\").Required().String()\n\tapp.Arg(\"b\", \"\").Required().String()\n\tapp.Terminate(func(int) { terminated = true })\n\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n\t_, err = app.Parse([]string{\"A\"})\n\tassert.Error(t, err)\n\t_, err = app.Parse([]string{\"A\", \"B\"})\n\tassert.NoError(t, err)\n\t_, _ = app.Parse([]string{\"--version\"})\n\tassert.True(t, terminated)\n}\n\nfunc TestInvalidArgsDefaultCanBeOverridden(t *testing.T) {\n\tapp := New(\"test\", \"\")\n\tapp.Arg(\"a\", \"\").Default(\"invalid\").Bool()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestArgMultipleValuesDefault(t *testing.T) {\n\tapp := New(\"test\", \"\")\n\ta := app.Arg(\"a\", \"\").Default(\"default1\", \"default2\").Strings()\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"default1\", \"default2\"}, *a)\n}\n\nfunc TestRequiredArgWithEnvarMissingErrors(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Arg(\"t\", \"\").Envar(\"TEST_ARG_ENVAR\").Required().Int()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestArgRequiredWithEnvar(t *testing.T) {\n\tos.Setenv(\"TEST_ARG_ENVAR\", \"123\")\n\tapp := newTestApp()\n\tflag := app.Arg(\"t\", \"\").Envar(\"TEST_ARG_ENVAR\").Required().Int()\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 123, *flag)\n}\n\nfunc TestSubcommandArgRequiredWithEnvar(t *testing.T) {\n\tos.Setenv(\"TEST_ARG_ENVAR\", \"123\")\n\tapp := newTestApp()\n\tcmd := app.Command(\"command\", \"\")\n\tflag := cmd.Arg(\"t\", \"\").Envar(\"TEST_ARG_ENVAR\").Required().Int()\n\t_, err := app.Parse([]string{\"command\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 123, *flag)\n}\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd.go",
          "type": "blob",
          "size": 7.91015625,
          "content": "package kingpin\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype cmdMixin struct {\n\t*flagGroup\n\t*argGroup\n\t*cmdGroup\n\tactionMixin\n}\n\n// CmdCompletion returns completion options for arguments, if that's where\n// parsing left off, or commands if there aren't any unsatisfied args.\nfunc (c *cmdMixin) CmdCompletion(context *ParseContext) []string {\n\tvar options []string\n\n\t// Count args already satisfied - we won't complete those, and add any\n\t// default commands' alternatives, since they weren't listed explicitly\n\t// and the user may want to explicitly list something else.\n\targsSatisfied := 0\n\tallSatisfied := false\nElementLoop:\n\tfor _, el := range context.Elements {\n\t\tswitch clause := el.Clause.(type) {\n\t\tcase *ArgClause:\n\t\t\t// Each new element should reset the previous state\n\t\t\tallSatisfied = false\n\t\t\toptions = nil\n\n\t\t\tif el.Value != nil && *el.Value != \"\" {\n\t\t\t\t// Get the list of valid options for the last argument\n\t\t\t\tvalidOptions := c.argGroup.args[argsSatisfied].resolveCompletions()\n\t\t\t\tif len(validOptions) == 0 {\n\t\t\t\t\t// If there are no options for this argument,\n\t\t\t\t\t// mark is as allSatisfied as we can't suggest anything\n\t\t\t\t\tif !clause.consumesRemainder() {\n\t\t\t\t\t\targsSatisfied++\n\t\t\t\t\t\tallSatisfied = true\n\t\t\t\t\t}\n\t\t\t\t\tcontinue ElementLoop\n\t\t\t\t}\n\n\t\t\t\tfor _, opt := range validOptions {\n\t\t\t\t\tif opt == *el.Value {\n\t\t\t\t\t\t// We have an exact match\n\t\t\t\t\t\t// We don't need to suggest any option\n\t\t\t\t\t\tif !clause.consumesRemainder() {\n\t\t\t\t\t\t\targsSatisfied++\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue ElementLoop\n\t\t\t\t\t}\n\t\t\t\t\tif strings.HasPrefix(opt, *el.Value) {\n\t\t\t\t\t\t// If the option match the partially entered argument, add it to the list\n\t\t\t\t\t\toptions = append(options, opt)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Avoid further completion as we have done everything we could\n\t\t\t\tif !clause.consumesRemainder() {\n\t\t\t\t\targsSatisfied++\n\t\t\t\t\tallSatisfied = true\n\t\t\t\t}\n\t\t\t}\n\t\tcase *CmdClause:\n\t\t\toptions = append(options, clause.completionAlts...)\n\t\tdefault:\n\t\t}\n\t}\n\n\tif argsSatisfied < len(c.argGroup.args) && !allSatisfied {\n\t\t// Since not all args have been satisfied, show options for the current one\n\t\toptions = append(options, c.argGroup.args[argsSatisfied].resolveCompletions()...)\n\t} else {\n\t\t// If all args are satisfied, then go back to completing commands\n\t\tfor _, cmd := range c.cmdGroup.commandOrder {\n\t\t\tif !cmd.hidden {\n\t\t\t\toptions = append(options, cmd.name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn options\n}\n\nfunc (c *cmdMixin) FlagCompletion(flagName string, flagValue string) (choices []string, flagMatch bool, optionMatch bool) {\n\t// Check if flagName matches a known flag.\n\t// If it does, show the options for the flag\n\t// Otherwise, show all flags\n\n\toptions := []string{}\n\n\tfor _, flag := range c.flagGroup.flagOrder {\n\t\t// Loop through each flag and determine if a match exists\n\t\tif flag.name == flagName {\n\t\t\t// User typed entire flag. Need to look for flag options.\n\t\t\toptions = flag.resolveCompletions()\n\t\t\tif len(options) == 0 {\n\t\t\t\t// No Options to Choose From, Assume Match.\n\t\t\t\treturn options, true, true\n\t\t\t}\n\n\t\t\t// Loop options to find if the user specified value matches\n\t\t\tisPrefix := false\n\t\t\tmatched := false\n\n\t\t\tfor _, opt := range options {\n\t\t\t\tif flagValue == opt {\n\t\t\t\t\tmatched = true\n\t\t\t\t} else if strings.HasPrefix(opt, flagValue) {\n\t\t\t\t\tisPrefix = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Matched Flag Directly\n\t\t\t// Flag Value Not Prefixed, and Matched Directly\n\t\t\treturn options, true, !isPrefix && matched\n\t\t}\n\n\t\tif !flag.hidden {\n\t\t\toptions = append(options, \"--\"+flag.name)\n\t\t}\n\t}\n\t// No Flag directly matched.\n\treturn options, false, false\n\n}\n\ntype cmdGroup struct {\n\tapp          *Application\n\tparent       *CmdClause\n\tcommands     map[string]*CmdClause\n\tcommandOrder []*CmdClause\n}\n\nfunc (c *cmdGroup) defaultSubcommand() *CmdClause {\n\tfor _, cmd := range c.commandOrder {\n\t\tif cmd.isDefault {\n\t\t\treturn cmd\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *cmdGroup) cmdNames() []string {\n\tnames := make([]string, 0, len(c.commandOrder))\n\tfor _, cmd := range c.commandOrder {\n\t\tnames = append(names, cmd.name)\n\t}\n\treturn names\n}\n\n// GetArg gets a command definition.\n//\n// This allows existing commands to be modified after definition but before parsing. Useful for\n// modular applications.\nfunc (c *cmdGroup) GetCommand(name string) *CmdClause {\n\treturn c.commands[name]\n}\n\nfunc newCmdGroup(app *Application) *cmdGroup {\n\treturn &cmdGroup{\n\t\tapp:      app,\n\t\tcommands: make(map[string]*CmdClause),\n\t}\n}\n\nfunc (c *cmdGroup) flattenedCommands() (out []*CmdClause) {\n\tfor _, cmd := range c.commandOrder {\n\t\tif len(cmd.commands) == 0 {\n\t\t\tout = append(out, cmd)\n\t\t}\n\t\tout = append(out, cmd.flattenedCommands()...)\n\t}\n\treturn\n}\n\nfunc (c *cmdGroup) addCommand(name, help string) *CmdClause {\n\tcmd := newCommand(c.app, name, help)\n\tc.commands[name] = cmd\n\tc.commandOrder = append(c.commandOrder, cmd)\n\treturn cmd\n}\n\nfunc (c *cmdGroup) init() error {\n\tseen := map[string]bool{}\n\tif c.defaultSubcommand() != nil && !c.have() {\n\t\treturn fmt.Errorf(\"default subcommand %q provided but no subcommands defined\", c.defaultSubcommand().name)\n\t}\n\tdefaults := []string{}\n\tfor _, cmd := range c.commandOrder {\n\t\tif cmd.isDefault {\n\t\t\tdefaults = append(defaults, cmd.name)\n\t\t}\n\t\tif seen[cmd.name] {\n\t\t\treturn fmt.Errorf(\"duplicate command %q\", cmd.name)\n\t\t}\n\t\tseen[cmd.name] = true\n\t\tfor _, alias := range cmd.aliases {\n\t\t\tif seen[alias] {\n\t\t\t\treturn fmt.Errorf(\"alias duplicates existing command %q\", alias)\n\t\t\t}\n\t\t\tc.commands[alias] = cmd\n\t\t}\n\t\tif err := cmd.init(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif len(defaults) > 1 {\n\t\treturn fmt.Errorf(\"more than one default subcommand exists: %s\", strings.Join(defaults, \", \"))\n\t}\n\treturn nil\n}\n\nfunc (c *cmdGroup) have() bool {\n\treturn len(c.commands) > 0\n}\n\ntype CmdClauseValidator func(*CmdClause) error\n\n// A CmdClause is a single top-level command. It encapsulates a set of flags\n// and either subcommands or positional arguments.\ntype CmdClause struct {\n\tcmdMixin\n\tapp            *Application\n\tname           string\n\taliases        []string\n\thelp           string\n\thelpLong       string\n\tisDefault      bool\n\tvalidator      CmdClauseValidator\n\thidden         bool\n\tcompletionAlts []string\n}\n\nfunc newCommand(app *Application, name, help string) *CmdClause {\n\tc := &CmdClause{\n\t\tapp:  app,\n\t\tname: name,\n\t\thelp: help,\n\t}\n\tc.flagGroup = newFlagGroup()\n\tc.argGroup = newArgGroup()\n\tc.cmdGroup = newCmdGroup(app)\n\treturn c\n}\n\n// Add an Alias for this command.\nfunc (c *CmdClause) Alias(name string) *CmdClause {\n\tc.aliases = append(c.aliases, name)\n\treturn c\n}\n\n// Validate sets a validation function to run when parsing.\nfunc (c *CmdClause) Validate(validator CmdClauseValidator) *CmdClause {\n\tc.validator = validator\n\treturn c\n}\n\nfunc (c *CmdClause) FullCommand() string {\n\tout := []string{c.name}\n\tfor p := c.parent; p != nil; p = p.parent {\n\t\tout = append([]string{p.name}, out...)\n\t}\n\treturn strings.Join(out, \" \")\n}\n\n// Command adds a new sub-command.\nfunc (c *CmdClause) Command(name, help string) *CmdClause {\n\tcmd := c.addCommand(name, help)\n\tcmd.parent = c\n\treturn cmd\n}\n\n// Default makes this command the default if commands don't match.\nfunc (c *CmdClause) Default() *CmdClause {\n\tc.isDefault = true\n\treturn c\n}\n\nfunc (c *CmdClause) Action(action Action) *CmdClause {\n\tc.addAction(action)\n\treturn c\n}\n\nfunc (c *CmdClause) PreAction(action Action) *CmdClause {\n\tc.addPreAction(action)\n\treturn c\n}\n\n// Help sets the help message.\nfunc (c *CmdClause) Help(help string) *CmdClause {\n\tc.help = help\n\treturn c\n}\n\nfunc (c *CmdClause) init() error {\n\tif err := c.flagGroup.init(c.app.defaultEnvarPrefix()); err != nil {\n\t\treturn err\n\t}\n\tif c.argGroup.have() && c.cmdGroup.have() {\n\t\treturn fmt.Errorf(\"can't mix Arg()s with Command()s\")\n\t}\n\tif err := c.argGroup.init(); err != nil {\n\t\treturn err\n\t}\n\tif err := c.cmdGroup.init(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *CmdClause) Hidden() *CmdClause {\n\tc.hidden = true\n\treturn c\n}\n\n// HelpLong adds a long help text, which can be used in usage templates.\n// For example, to use a longer help text in the command-specific help\n// than in the apps root help.\nfunc (c *CmdClause) HelpLong(help string) *CmdClause {\n\tc.helpLong = help\n\treturn c\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd_test.go",
          "type": "blob",
          "size": 12.7685546875,
          "content": "package kingpin\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"testing\"\n)\n\nfunc parseAndExecute(app *Application, context *ParseContext) (string, error) {\n\tif err := parse(context, app); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tselected, err := app.setValues(context)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn app.execute(context, selected)\n}\n\nfunc complete(t *testing.T, app *Application, args ...string) []string {\n\tcontext, err := app.ParseContext(args)\n\tassert.NoError(t, err)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tcompletions := app.completionOptions(context)\n\tsort.Strings(completions)\n\n\treturn completions\n}\n\nfunc TestNestedCommands(t *testing.T) {\n\tapp := New(\"app\", \"\")\n\tsub1 := app.Command(\"sub1\", \"\")\n\tsub1.Flag(\"sub1\", \"\")\n\tsubsub1 := sub1.Command(\"sub1sub1\", \"\")\n\tsubsub1.Command(\"sub1sub1end\", \"\")\n\n\tsub2 := app.Command(\"sub2\", \"\")\n\tsub2.Flag(\"sub2\", \"\")\n\tsub2.Command(\"sub2sub1\", \"\")\n\n\tcontext := tokenize([]string{\"sub1\", \"sub1sub1\", \"sub1sub1end\"}, false)\n\tselected, err := parseAndExecute(app, context)\n\tassert.NoError(t, err)\n\tassert.True(t, context.EOL())\n\tassert.Equal(t, \"sub1 sub1sub1 sub1sub1end\", selected)\n}\n\nfunc TestNestedCommandsWithArgs(t *testing.T) {\n\tapp := New(\"app\", \"\")\n\tcmd := app.Command(\"a\", \"\").Command(\"b\", \"\")\n\ta := cmd.Arg(\"a\", \"\").String()\n\tb := cmd.Arg(\"b\", \"\").String()\n\tcontext := tokenize([]string{\"a\", \"b\", \"c\", \"d\"}, false)\n\tselected, err := parseAndExecute(app, context)\n\tassert.NoError(t, err)\n\tassert.True(t, context.EOL())\n\tassert.Equal(t, \"a b\", selected)\n\tassert.Equal(t, \"c\", *a)\n\tassert.Equal(t, \"d\", *b)\n}\n\nfunc TestNestedCommandsWithFlags(t *testing.T) {\n\tapp := New(\"app\", \"\")\n\tcmd := app.Command(\"a\", \"\").Command(\"b\", \"\")\n\ta := cmd.Flag(\"aaa\", \"\").Short('a').String()\n\tb := cmd.Flag(\"bbb\", \"\").Short('b').String()\n\terr := app.init()\n\tassert.NoError(t, err)\n\tcontext := tokenize(strings.Split(\"a b --aaa x -b x\", \" \"), false)\n\tselected, err := parseAndExecute(app, context)\n\tassert.NoError(t, err)\n\tassert.True(t, context.EOL())\n\tassert.Equal(t, \"a b\", selected)\n\tassert.Equal(t, \"x\", *a)\n\tassert.Equal(t, \"x\", *b)\n}\n\nfunc TestNestedCommandWithMergedFlags(t *testing.T) {\n\tapp := New(\"app\", \"\")\n\tcmd0 := app.Command(\"a\", \"\")\n\tcmd0f0 := cmd0.Flag(\"aflag\", \"\").Bool()\n\t// cmd1 := app.Command(\"b\", \"\")\n\t// cmd1f0 := cmd0.Flag(\"bflag\", \"\").Bool()\n\tcmd00 := cmd0.Command(\"aa\", \"\")\n\tcmd00f0 := cmd00.Flag(\"aaflag\", \"\").Bool()\n\terr := app.init()\n\tassert.NoError(t, err)\n\tcontext := tokenize(strings.Split(\"a aa --aflag --aaflag\", \" \"), false)\n\tselected, err := parseAndExecute(app, context)\n\tassert.NoError(t, err)\n\tassert.True(t, *cmd0f0)\n\tassert.True(t, *cmd00f0)\n\tassert.Equal(t, \"a aa\", selected)\n}\n\nfunc TestNestedCommandWithDuplicateFlagErrors(t *testing.T) {\n\tapp := New(\"app\", \"\")\n\tapp.Flag(\"test\", \"\").Bool()\n\tapp.Command(\"cmd0\", \"\").Flag(\"test\", \"\").Bool()\n\terr := app.init()\n\tassert.Error(t, err)\n}\n\nfunc TestNestedCommandWithArgAndMergedFlags(t *testing.T) {\n\tapp := New(\"app\", \"\")\n\tcmd0 := app.Command(\"a\", \"\")\n\tcmd0f0 := cmd0.Flag(\"aflag\", \"\").Bool()\n\t// cmd1 := app.Command(\"b\", \"\")\n\t// cmd1f0 := cmd0.Flag(\"bflag\", \"\").Bool()\n\tcmd00 := cmd0.Command(\"aa\", \"\")\n\tcmd00a0 := cmd00.Arg(\"arg\", \"\").String()\n\tcmd00f0 := cmd00.Flag(\"aaflag\", \"\").Bool()\n\terr := app.init()\n\tassert.NoError(t, err)\n\tcontext := tokenize(strings.Split(\"a aa hello --aflag --aaflag\", \" \"), false)\n\tselected, err := parseAndExecute(app, context)\n\tassert.NoError(t, err)\n\tassert.True(t, *cmd0f0)\n\tassert.True(t, *cmd00f0)\n\tassert.Equal(t, \"a aa\", selected)\n\tassert.Equal(t, \"hello\", *cmd00a0)\n}\n\nfunc TestDefaultSubcommandEOL(t *testing.T) {\n\tapp := newTestApp()\n\tc0 := app.Command(\"c0\", \"\").Default()\n\tc0.Command(\"c01\", \"\").Default()\n\tc0.Command(\"c02\", \"\")\n\n\tcmd, err := app.Parse([]string{\"c0\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"c0 c01\", cmd)\n}\n\nfunc TestDefaultSubcommandWithArg(t *testing.T) {\n\tapp := newTestApp()\n\tc0 := app.Command(\"c0\", \"\").Default()\n\tc01 := c0.Command(\"c01\", \"\").Default()\n\tc012 := c01.Command(\"c012\", \"\").Default()\n\ta0 := c012.Arg(\"a0\", \"\").String()\n\tc0.Command(\"c02\", \"\")\n\n\tcmd, err := app.Parse([]string{\"c0\", \"hello\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"c0 c01 c012\", cmd)\n\tassert.Equal(t, \"hello\", *a0)\n}\n\nfunc TestDefaultSubcommandWithFlags(t *testing.T) {\n\tapp := newTestApp()\n\tc0 := app.Command(\"c0\", \"\").Default()\n\t_ = c0.Flag(\"f0\", \"\").Int()\n\tc0c1 := c0.Command(\"c1\", \"\").Default()\n\tc0c1f1 := c0c1.Flag(\"f1\", \"\").Int()\n\tselected, err := app.Parse([]string{\"--f1=2\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"c0 c1\", selected)\n\tassert.Equal(t, 2, *c0c1f1)\n\t_, err = app.Parse([]string{\"--f2\"})\n\tassert.Error(t, err)\n}\n\nfunc TestMultipleDefaultCommands(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Command(\"c0\", \"\").Default()\n\tapp.Command(\"c1\", \"\").Default()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestAliasedCommand(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Command(\"one\", \"\").Alias(\"two\")\n\tselected, _ := app.Parse([]string{\"one\"})\n\tassert.Equal(t, \"one\", selected)\n\tselected, _ = app.Parse([]string{\"two\"})\n\tassert.Equal(t, \"one\", selected)\n\t// 2 due to \"help\" and \"one\"\n\tassert.Equal(t, 2, len(app.Model().FlattenedCommands()))\n}\n\nfunc TestDuplicateAlias(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Command(\"one\", \"\")\n\tapp.Command(\"two\", \"\").Alias(\"one\")\n\t_, err := app.Parse([]string{\"one\"})\n\tassert.Error(t, err)\n}\n\nfunc TestFlagCompletion(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Command(\"one\", \"\")\n\ttwo := app.Command(\"two\", \"\")\n\ttwo.Flag(\"flag-1\", \"\")\n\ttwo.Flag(\"flag-2\", \"\").HintOptions(\"opt1\", \"opt2\", \"opt3\")\n\ttwo.Flag(\"flag-3\", \"\")\n\n\tcases := []struct {\n\t\ttarget              cmdMixin\n\t\tflagName            string\n\t\tflagValue           string\n\t\texpectedFlagMatch   bool\n\t\texpectedOptionMatch bool\n\t\texpectedFlags       []string\n\t}{\n\t\t{\n\t\t\t// Test top level flags\n\t\t\ttarget:              app.cmdMixin,\n\t\t\tflagName:            \"\",\n\t\t\tflagValue:           \"\",\n\t\t\texpectedFlagMatch:   false,\n\t\t\texpectedOptionMatch: false,\n\t\t\texpectedFlags:       []string{\"--help\"},\n\t\t},\n\t\t{\n\t\t\t// Test no flag passed\n\t\t\ttarget:              two.cmdMixin,\n\t\t\tflagName:            \"\",\n\t\t\tflagValue:           \"\",\n\t\t\texpectedFlagMatch:   false,\n\t\t\texpectedOptionMatch: false,\n\t\t\texpectedFlags:       []string{\"--flag-1\", \"--flag-2\", \"--flag-3\"},\n\t\t},\n\t\t{\n\t\t\t// Test an incomplete flag. Should still give all options as if the flag wasn't given at all.\n\t\t\ttarget:              two.cmdMixin,\n\t\t\tflagName:            \"flag-\",\n\t\t\tflagValue:           \"\",\n\t\t\texpectedFlagMatch:   false,\n\t\t\texpectedOptionMatch: false,\n\t\t\texpectedFlags:       []string{\"--flag-1\", \"--flag-2\", \"--flag-3\"},\n\t\t},\n\t\t{\n\t\t\t// Test with a complete flag. Should show available choices for the flag\n\t\t\t// This flag has no options. No options should be produced.\n\t\t\t// Should also report an option was matched\n\t\t\ttarget:              two.cmdMixin,\n\t\t\tflagName:            \"flag-1\",\n\t\t\tflagValue:           \"\",\n\t\t\texpectedFlagMatch:   true,\n\t\t\texpectedOptionMatch: true,\n\t\t\texpectedFlags:       []string(nil),\n\t\t},\n\t\t{\n\t\t\t// Test with a complete flag. Should show available choices for the flag\n\t\t\ttarget:              two.cmdMixin,\n\t\t\tflagName:            \"flag-2\",\n\t\t\tflagValue:           \"\",\n\t\t\texpectedFlagMatch:   true,\n\t\t\texpectedOptionMatch: false,\n\t\t\texpectedFlags:       []string{\"opt1\", \"opt2\", \"opt3\"},\n\t\t},\n\t\t{\n\t\t\t// Test with a complete flag and complete option for that flag.\n\t\t\ttarget:              two.cmdMixin,\n\t\t\tflagName:            \"flag-2\",\n\t\t\tflagValue:           \"opt1\",\n\t\t\texpectedFlagMatch:   true,\n\t\t\texpectedOptionMatch: true,\n\t\t\texpectedFlags:       []string{\"opt1\", \"opt2\", \"opt3\"},\n\t\t},\n\t}\n\n\tfor i, c := range cases {\n\t\tchoices, flagMatch, optionMatch := c.target.FlagCompletion(c.flagName, c.flagValue)\n\t\tassert.Equal(t, c.expectedFlags, choices, \"Test case %d: expectedFlags != actual flags\", i+1)\n\t\tassert.Equal(t, c.expectedFlagMatch, flagMatch, \"Test case %d: expectedFlagMatch != flagMatch\", i+1)\n\t\tassert.Equal(t, c.expectedOptionMatch, optionMatch, \"Test case %d: expectedOptionMatch != optionMatch\", i+1)\n\t}\n\n}\n\nfunc TestCmdCompletion(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Command(\"one\", \"\")\n\ttwo := app.Command(\"two\", \"\")\n\ttwo.Command(\"sub1\", \"\")\n\ttwo.Command(\"sub2\", \"\")\n\n\tassert.Equal(t, []string{\"help\", \"one\", \"two\"}, complete(t, app))\n\tassert.Equal(t, []string{\"sub1\", \"sub2\"}, complete(t, app, \"two\"))\n}\n\nfunc TestHiddenCmdCompletion(t *testing.T) {\n\tapp := newTestApp()\n\n\t// top level visible & hidden cmds, with no sub-cmds\n\tapp.Command(\"visible1\", \"\")\n\tapp.Command(\"hidden1\", \"\").Hidden()\n\n\t// visible cmd with visible & hidden sub-cmds\n\tvisible2 := app.Command(\"visible2\", \"\")\n\tvisible2.Command(\"visible2-visible\", \"\")\n\tvisible2.Command(\"visible2-hidden\", \"\").Hidden()\n\n\t// hidden cmd with visible & hidden sub-cmds\n\thidden2 := app.Command(\"hidden2\", \"\").Hidden()\n\thidden2.Command(\"hidden2-visible\", \"\")\n\thidden2.Command(\"hidden2-hidden\", \"\").Hidden()\n\n\t// Only top level visible cmds should show\n\tassert.Equal(t, []string{\"help\", \"visible1\", \"visible2\"}, complete(t, app))\n\n\t// Only visible sub-cmds should show\n\tassert.Equal(t, []string{\"visible2-visible\"}, complete(t, app, \"visible2\"))\n\n\t// Hidden commands should still complete visible sub-cmds\n\tassert.Equal(t, []string{\"hidden2-visible\"}, complete(t, app, \"hidden2\"))\n}\n\nfunc TestDefaultCmdCompletion(t *testing.T) {\n\tapp := newTestApp()\n\n\tcmd1 := app.Command(\"cmd1\", \"\")\n\n\tcmd1Sub1 := cmd1.Command(\"cmd1-sub1\", \"\")\n\tcmd1Sub1.Arg(\"cmd1-sub1-arg1\", \"\").HintOptions(\"cmd1-arg1\").String()\n\n\tcmd2 := app.Command(\"cmd2\", \"\").Default()\n\n\tcmd2.Command(\"cmd2-sub1\", \"\")\n\n\tcmd2Sub2 := cmd2.Command(\"cmd2-sub2\", \"\").Default()\n\n\tcmd2Sub2Sub1 := cmd2Sub2.Command(\"cmd2-sub2-sub1\", \"\").Default()\n\tcmd2Sub2Sub1.Arg(\"cmd2-sub2-sub1-arg1\", \"\").HintOptions(\"cmd2-sub2-sub1-arg1\").String()\n\tcmd2Sub2Sub1.Arg(\"cmd2-sub2-sub1-arg2\", \"\").HintOptions(\"cmd2-sub2-sub1-arg2\").String()\n\n\t// Without args, should get:\n\t//   - root cmds (including implicit \"help\")\n\t//   - thread of default cmds\n\t//   - first arg hints for the final default cmd\n\tassert.Equal(t, []string{\"cmd1\", \"cmd2\", \"cmd2-sub1\", \"cmd2-sub2\", \"cmd2-sub2-sub1\", \"cmd2-sub2-sub1-arg1\", \"help\"}, complete(t, app))\n\n\t// With a non-default cmd already listed, should get:\n\t//   - sub cmds of that arg\n\tassert.Equal(t, []string{\"cmd1-sub1\"}, complete(t, app, \"cmd1\"))\n\n\t// With an explicit default cmd listed, should get:\n\t//   - default child-cmds\n\t//   - first arg hints for the final default cmd\n\tassert.Equal(t, []string{\"cmd2-sub1\", \"cmd2-sub2\", \"cmd2-sub2-sub1\", \"cmd2-sub2-sub1-arg1\"}, complete(t, app, \"cmd2\"))\n\tassert.Equal(t, []string{\"cmd2-sub2-sub1-arg1\"}, complete(t, app, \"cmd2\", \"cmd2\"))\n\n\t// Args should be completed when all preceding cmds are explicit, and when\n\t// any of them are implicit (not listed). Check this by trying all possible\n\t// combinations of choosing/excluding the three levels of cmds. This tests\n\t// root-level default, middle default, and end default.\n\tfor i := 0; i < 8; i++ {\n\t\tvar cmdline []string\n\n\t\tif i&1 != 0 {\n\t\t\tcmdline = append(cmdline, \"cmd2\")\n\t\t}\n\t\tif i&2 != 0 {\n\t\t\tcmdline = append(cmdline, \"cmd2-sub2\")\n\t\t}\n\t\tif i&4 != 0 {\n\t\t\tcmdline = append(cmdline, \"cmd2-sub2-sub1\")\n\t\t}\n\n\t\tassert.Contains(t, complete(t, app, cmdline...), \"cmd2-sub2-sub1-arg1\", \"with cmdline: %v\", cmdline)\n\t}\n\n\t// With both args of a default sub cmd, should get no completions\n\tassert.Empty(t, complete(t, app, \"arg1\", \"arg2\"))\n}\n\nfunc TestPartialCmdCompletion(t *testing.T) {\n\tapp := newTestApp()\n\n\tcmd1 := app.Command(\"cmd1\", \"\")\n\tcmd1.Arg(\"cmd1-arg1\", \"\").HintOptions(\"cmd1-arg1-opt1\", \"cmd1-arg1-opt2\", \"cmd1-arg1-opt3\").String()\n\tcmd2 := app.Command(\"cmd2\", \"\")\n\tcmd2.Arg(\"cmd2-arg1\", \"\").HintOptions(\"cmd2-123456\", \"cmd2-123789\", \"cmd2-456789\").String()\n\tcmd3 := app.Command(\"cmd3\", \"\")\n\tcmd3.Arg(\"cmd3-arg1\", \"\").String()\n\tcmd4 := app.Command(\"cmd4\", \"\")\n\tcmd4.Arg(\"cmd4-arg1\", \"\").HintOptions(\"cmd4-arg1\").String()\n\tcmd4.Arg(\"cmd4-arg2\", \"\").HintOptions(\"cmd4-arg2\").String()\n\tcmd4.Arg(\"cmd4-arg3\", \"\").HintOptions(\"cmd4-arg3\").String()\n\n\n\t// partial matches\n\tassert.Equal(t, []string{\"cmd1-arg1-opt1\", \"cmd1-arg1-opt2\", \"cmd1-arg1-opt3\"}, complete(t, app, \"cmd1\", \"cmd1-arg1-opt\"))\n\tassert.Equal(t, []string{\"cmd2-123456\", \"cmd2-123789\", \"cmd2-456789\"}, complete(t, app, \"cmd2\", \"cmd2-\"))\n\tassert.Equal(t, []string{\"cmd2-123456\", \"cmd2-123789\"}, complete(t, app, \"cmd2\", \"cmd2-123\"))\n\tassert.Equal(t, []string{\"cmd2-456789\"}, complete(t, app, \"cmd2\", \"cmd2-4\"))\n\tassert.Equal(t, []string{\"cmd4-arg1\"}, complete(t, app, \"cmd4\"))\n\tassert.Equal(t, []string{\"cmd4-arg1\"}, complete(t, app, \"cmd4\", \"cmd4-\"))\n\tassert.Equal(t, []string{\"cmd4-arg2\"}, complete(t, app, \"cmd4\", \"cmd4-arg1\"))\n\tassert.Equal(t, []string{\"cmd4-arg2\"}, complete(t, app, \"cmd4\", \"cmd4-arg1\", \"cmd4-arg\"))\n\tassert.Equal(t, []string{\"cmd4-arg3\"}, complete(t, app, \"cmd4\", \"cmd4-arg1\", \"cmd4-arg2\"))\n\tassert.Equal(t, []string{\"cmd4-arg3\"}, complete(t, app, \"cmd4\", \"cmd4-arg1\", \"cmd4-arg2\", \"cmd\"))\n\n\t// exact match\n\tassert.Empty(t, complete(t, app, \"cmd2\", \"cmd2-123456\"))\n\n\t// no option\n\tassert.Empty(t, complete(t, app, \"cmd3\", \"cmd3-\"))\n}\n"
        },
        {
          "name": "completions.go",
          "type": "blob",
          "size": 0.8818359375,
          "content": "package kingpin\n\n// HintAction is a function type who is expected to return a slice of possible\n// command line arguments.\ntype HintAction func() []string\ntype completionsMixin struct {\n\thintActions        []HintAction\n\tbuiltinHintActions []HintAction\n}\n\nfunc (a *completionsMixin) addHintAction(action HintAction) {\n\ta.hintActions = append(a.hintActions, action)\n}\n\n// Allow adding of HintActions which are added internally, ie, EnumVar\nfunc (a *completionsMixin) addHintActionBuiltin(action HintAction) {\n\ta.builtinHintActions = append(a.builtinHintActions, action)\n}\n\nfunc (a *completionsMixin) resolveCompletions() []string {\n\tvar hints []string\n\n\toptions := a.builtinHintActions\n\tif len(a.hintActions) > 0 {\n\t\t// User specified their own hintActions. Use those instead.\n\t\toptions = a.hintActions\n\t}\n\n\tfor _, hintAction := range options {\n\t\thints = append(hints, hintAction()...)\n\t}\n\treturn hints\n}\n"
        },
        {
          "name": "completions_test.go",
          "type": "blob",
          "size": 1.7275390625,
          "content": "package kingpin\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestResolveWithBuiltin(t *testing.T) {\n\ta := completionsMixin{}\n\n\thintAction1 := func() []string {\n\t\treturn []string{\"opt1\", \"opt2\"}\n\t}\n\thintAction2 := func() []string {\n\t\treturn []string{\"opt3\", \"opt4\"}\n\t}\n\n\ta.builtinHintActions = []HintAction{hintAction1, hintAction2}\n\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\", \"opt3\", \"opt4\"}, args)\n}\n\nfunc TestResolveWithUser(t *testing.T) {\n\ta := completionsMixin{}\n\thintAction1 := func() []string {\n\t\treturn []string{\"opt1\", \"opt2\"}\n\t}\n\thintAction2 := func() []string {\n\t\treturn []string{\"opt3\", \"opt4\"}\n\t}\n\n\ta.hintActions = []HintAction{hintAction1, hintAction2}\n\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\", \"opt3\", \"opt4\"}, args)\n}\n\nfunc TestResolveWithCombination(t *testing.T) {\n\ta := completionsMixin{}\n\tbuiltin := func() []string {\n\t\treturn []string{\"opt1\", \"opt2\"}\n\t}\n\tuser := func() []string {\n\t\treturn []string{\"opt3\", \"opt4\"}\n\t}\n\n\ta.builtinHintActions = []HintAction{builtin}\n\ta.hintActions = []HintAction{user}\n\n\targs := a.resolveCompletions()\n\t// User provided args take preference over builtin (enum-defined) args.\n\tassert.Equal(t, []string{\"opt3\", \"opt4\"}, args)\n}\n\nfunc TestAddHintAction(t *testing.T) {\n\ta := completionsMixin{}\n\thintFunc := func() []string {\n\t\treturn []string{\"opt1\", \"opt2\"}\n\t}\n\ta.addHintAction(hintFunc)\n\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\n\nfunc TestAddHintActionBuiltin(t *testing.T) {\n\ta := completionsMixin{}\n\thintFunc := func() []string {\n\t\treturn []string{\"opt1\", \"opt2\"}\n\t}\n\n\ta.addHintActionBuiltin(hintFunc)\n\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.97265625,
          "content": "// Package kingpin provides command line interfaces like this:\n//\n//     $ chat\n//     usage: chat [<flags>] <command> [<flags>] [<args> ...]\n//\n//     Flags:\n//       --debug              enable debug mode\n//       --help               Show help.\n//       --server=127.0.0.1   server address\n//\n//     Commands:\n//       help <command>\n//         Show help for a command.\n//\n//       post [<flags>] <channel>\n//         Post a message to a channel.\n//\n//       register <nick> <name>\n//         Register a new user.\n//\n//     $ chat help post\n//     usage: chat [<flags>] post [<flags>] <channel> [<text>]\n//\n//     Post a message to a channel.\n//\n//     Flags:\n//       --image=IMAGE   image to post\n//\n//     Args:\n//       <channel>   channel to post to\n//       [<text>]    text to post\n//     $ chat post --image=~/Downloads/owls.jpg pics\n//\n// From code like this:\n//\n//     package main\n//\n//     import \"github.com/alecthomas/kingpin/v2\"\n//\n//     var (\n//       debug    = kingpin.Flag(\"debug\", \"enable debug mode\").Default(\"false\").Bool()\n//       serverIP = kingpin.Flag(\"server\", \"server address\").Default(\"127.0.0.1\").IP()\n//\n//       register     = kingpin.Command(\"register\", \"Register a new user.\")\n//       registerNick = register.Arg(\"nick\", \"nickname for user\").Required().String()\n//       registerName = register.Arg(\"name\", \"name of user\").Required().String()\n//\n//       post        = kingpin.Command(\"post\", \"Post a message to a channel.\")\n//       postImage   = post.Flag(\"image\", \"image to post\").ExistingFile()\n//       postChannel = post.Arg(\"channel\", \"channel to post to\").Required().String()\n//       postText    = post.Arg(\"text\", \"text to post\").String()\n//     )\n//\n//     func main() {\n//       switch kingpin.Parse() {\n//       // Register user\n//       case \"register\":\n//         println(*registerNick)\n//\n//       // Post message\n//       case \"post\":\n//         if *postImage != nil {\n//         }\n//         if *postText != \"\" {\n//         }\n//       }\n//     }\npackage kingpin\n"
        },
        {
          "name": "envar.go",
          "type": "blob",
          "size": 0.7763671875,
          "content": "package kingpin\n\nimport (\n\t\"os\"\n\t\"regexp\"\n)\n\nvar (\n\tenvVarValuesSeparator = \"\\r?\\n\"\n\tenvVarValuesTrimmer   = regexp.MustCompile(envVarValuesSeparator + \"$\")\n\tenvVarValuesSplitter  = regexp.MustCompile(envVarValuesSeparator)\n)\n\ntype envarMixin struct {\n\tenvar   string\n\tnoEnvar bool\n}\n\nfunc (e *envarMixin) HasEnvarValue() bool {\n\treturn e.GetEnvarValue() != \"\"\n}\n\nfunc (e *envarMixin) GetEnvarValue() string {\n\tif e.noEnvar || e.envar == \"\" {\n\t\treturn \"\"\n\t}\n\treturn os.Getenv(e.envar)\n}\n\nfunc (e *envarMixin) GetSplitEnvarValue() []string {\n\tenvarValue := e.GetEnvarValue()\n\tif envarValue == \"\" {\n\t\treturn []string{}\n\t}\n\n\t// Split by new line to extract multiple values, if any.\n\ttrimmed := envVarValuesTrimmer.ReplaceAllString(envarValue, \"\")\n\n\treturn envVarValuesSplitter.Split(trimmed, -1)\n}\n"
        },
        {
          "name": "examples_test.go",
          "type": "blob",
          "size": 1.0556640625,
          "content": "package kingpin\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n)\n\ntype HTTPHeaderValue http.Header\n\nfunc (h *HTTPHeaderValue) Set(value string) error {\n\tparts := strings.SplitN(value, \":\", 2)\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"expected HEADER:VALUE got '%s'\", value)\n\t}\n\t(*http.Header)(h).Add(parts[0], parts[1])\n\treturn nil\n}\n\nfunc (h *HTTPHeaderValue) Get() interface{} {\n\treturn (http.Header)(*h)\n}\n\nfunc (h *HTTPHeaderValue) String() string {\n\treturn \"\"\n}\n\nfunc HTTPHeader(s Settings) (target *http.Header) {\n\ttarget = new(http.Header)\n\ts.SetValue((*HTTPHeaderValue)(target))\n\treturn\n}\n\n// This example ilustrates how to define custom parsers. HTTPHeader\n// cumulatively parses each encountered --header flag into a http.Header struct.\nfunc ExampleValue() {\n\tvar (\n\t\tcurl    = New(\"curl\", \"transfer a URL\")\n\t\theaders = HTTPHeader(curl.Flag(\"headers\", \"Add HTTP headers to the request.\").Short('H').PlaceHolder(\"HEADER:VALUE\"))\n\t)\n\n\tcurl.Parse([]string{\"-H Content-Type:application/octet-stream\"})\n\tfor key, value := range *headers {\n\t\tfmt.Printf(\"%s = %s\\n\", key, value)\n\t}\n}\n"
        },
        {
          "name": "flags.go",
          "type": "blob",
          "size": 7.6123046875,
          "content": "package kingpin\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype flagGroup struct {\n\tshort     map[string]*FlagClause\n\tlong      map[string]*FlagClause\n\tflagOrder []*FlagClause\n}\n\nfunc newFlagGroup() *flagGroup {\n\treturn &flagGroup{\n\t\tshort: map[string]*FlagClause{},\n\t\tlong:  map[string]*FlagClause{},\n\t}\n}\n\n// GetFlag gets a flag definition.\n//\n// This allows existing flags to be modified after definition but before parsing. Useful for\n// modular applications.\nfunc (f *flagGroup) GetFlag(name string) *FlagClause {\n\treturn f.long[name]\n}\n\n// Flag defines a new flag with the given long name and help.\nfunc (f *flagGroup) Flag(name, help string) *FlagClause {\n\tflag := newFlag(name, help)\n\tf.long[name] = flag\n\tf.flagOrder = append(f.flagOrder, flag)\n\treturn flag\n}\n\nfunc (f *flagGroup) init(defaultEnvarPrefix string) error {\n\tif err := f.checkDuplicates(); err != nil {\n\t\treturn err\n\t}\n\tfor _, flag := range f.long {\n\t\tif defaultEnvarPrefix != \"\" && !flag.noEnvar && flag.envar == \"\" {\n\t\t\tflag.envar = envarTransform(defaultEnvarPrefix + \"_\" + flag.name)\n\t\t}\n\t\tif err := flag.init(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif flag.shorthand != 0 {\n\t\t\tf.short[string(flag.shorthand)] = flag\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (f *flagGroup) checkDuplicates() error {\n\tseenShort := map[rune]bool{}\n\tseenLong := map[string]bool{}\n\tfor _, flag := range f.flagOrder {\n\t\tif flag.shorthand != 0 {\n\t\t\tif _, ok := seenShort[flag.shorthand]; ok {\n\t\t\t\treturn fmt.Errorf(\"duplicate short flag -%c\", flag.shorthand)\n\t\t\t}\n\t\t\tseenShort[flag.shorthand] = true\n\t\t}\n\t\tif _, ok := seenLong[flag.name]; ok {\n\t\t\treturn fmt.Errorf(\"duplicate long flag --%s\", flag.name)\n\t\t}\n\t\tseenLong[flag.name] = true\n\t}\n\treturn nil\n}\n\nfunc (f *flagGroup) parse(context *ParseContext) (*FlagClause, error) {\n\tvar token *Token\n\nloop:\n\tfor {\n\t\ttoken = context.Peek()\n\t\tswitch token.Type {\n\t\tcase TokenEOL:\n\t\t\tbreak loop\n\n\t\tcase TokenLong, TokenShort:\n\t\t\tflagToken := token\n\t\t\tdefaultValue := \"\"\n\t\t\tvar flag *FlagClause\n\t\t\tvar ok bool\n\t\t\tinvert := false\n\n\t\t\tname := token.Value\n\t\t\tif token.Type == TokenLong {\n\t\t\t\tflag, ok = f.long[name]\n\t\t\t\tif !ok {\n\t\t\t\t\tif strings.HasPrefix(name, \"no-\") {\n\t\t\t\t\t\tname = name[3:]\n\t\t\t\t\t\tinvert = true\n\t\t\t\t\t}\n\t\t\t\t\tflag, ok = f.long[name]\n\t\t\t\t}\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown long flag '%s'\", flagToken)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tflag, ok = f.short[name]\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown short flag '%s'\", flagToken)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.Next()\n\n\t\t\tflag.isSetByUser()\n\n\t\t\tfb, ok := flag.value.(boolFlag)\n\t\t\tif ok && fb.IsBoolFlag() {\n\t\t\t\tif invert {\n\t\t\t\t\tdefaultValue = \"false\"\n\t\t\t\t} else {\n\t\t\t\t\tdefaultValue = \"true\"\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif invert {\n\t\t\t\t\tcontext.Push(token)\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown long flag '%s'\", flagToken)\n\t\t\t\t}\n\t\t\t\ttoken = context.Peek()\n\t\t\t\tif token.Type != TokenArg {\n\t\t\t\t\tcontext.Push(token)\n\t\t\t\t\treturn nil, fmt.Errorf(\"expected argument for flag '%s'\", flagToken)\n\t\t\t\t}\n\t\t\t\tcontext.Next()\n\t\t\t\tdefaultValue = token.Value\n\t\t\t}\n\n\t\t\tcontext.matchedFlag(flag, defaultValue)\n\t\t\treturn flag, nil\n\n\t\tdefault:\n\t\t\tbreak loop\n\t\t}\n\t}\n\treturn nil, nil\n}\n\n// FlagClause is a fluid interface used to build flags.\ntype FlagClause struct {\n\tparserMixin\n\tactionMixin\n\tcompletionsMixin\n\tenvarMixin\n\tname          string\n\tshorthand     rune\n\thelp          string\n\tdefaultValues []string\n\tplaceholder   string\n\thidden        bool\n\tsetByUser     *bool\n}\n\nfunc newFlag(name, help string) *FlagClause {\n\tf := &FlagClause{\n\t\tname: name,\n\t\thelp: help,\n\t}\n\treturn f\n}\n\nfunc (f *FlagClause) setDefault() error {\n\tif f.HasEnvarValue() {\n\t\tif v, ok := f.value.(repeatableFlag); !ok || !v.IsCumulative() {\n\t\t\t// Use the value as-is\n\t\t\treturn f.value.Set(f.GetEnvarValue())\n\t\t} else {\n\t\t\tfor _, value := range f.GetSplitEnvarValue() {\n\t\t\t\tif err := f.value.Set(value); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tif len(f.defaultValues) > 0 {\n\t\tfor _, defaultValue := range f.defaultValues {\n\t\t\tif err := f.value.Set(defaultValue); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc (f *FlagClause) isSetByUser() {\n\tif f.setByUser != nil {\n\t\t*f.setByUser = true\n\t}\n}\n\nfunc (f *FlagClause) needsValue() bool {\n\thaveDefault := len(f.defaultValues) > 0\n\treturn f.required && !(haveDefault || f.HasEnvarValue())\n}\n\nfunc (f *FlagClause) init() error {\n\tif f.required && len(f.defaultValues) > 0 {\n\t\treturn fmt.Errorf(\"required flag '--%s' with default value that will never be used\", f.name)\n\t}\n\tif f.value == nil {\n\t\treturn fmt.Errorf(\"no type defined for --%s (eg. .String())\", f.name)\n\t}\n\tif v, ok := f.value.(repeatableFlag); (!ok || !v.IsCumulative()) && len(f.defaultValues) > 1 {\n\t\treturn fmt.Errorf(\"invalid default for '--%s', expecting single value\", f.name)\n\t}\n\treturn nil\n}\n\n// Dispatch to the given function after the flag is parsed and validated.\nfunc (f *FlagClause) Action(action Action) *FlagClause {\n\tf.addAction(action)\n\treturn f\n}\n\nfunc (f *FlagClause) PreAction(action Action) *FlagClause {\n\tf.addPreAction(action)\n\treturn f\n}\n\n// HintAction registers a HintAction (function) for the flag to provide completions\nfunc (a *FlagClause) HintAction(action HintAction) *FlagClause {\n\ta.addHintAction(action)\n\treturn a\n}\n\n// HintOptions registers any number of options for the flag to provide completions\nfunc (a *FlagClause) HintOptions(options ...string) *FlagClause {\n\ta.addHintAction(func() []string {\n\t\treturn options\n\t})\n\treturn a\n}\n\nfunc (a *FlagClause) EnumVar(target *string, options ...string) {\n\ta.parserMixin.EnumVar(target, options...)\n\ta.addHintActionBuiltin(func() []string {\n\t\treturn options\n\t})\n}\n\nfunc (a *FlagClause) Enum(options ...string) (target *string) {\n\ta.addHintActionBuiltin(func() []string {\n\t\treturn options\n\t})\n\treturn a.parserMixin.Enum(options...)\n}\n\n// IsSetByUser let to know if the flag was set by the user\nfunc (f *FlagClause) IsSetByUser(setByUser *bool) *FlagClause {\n\tif setByUser != nil {\n\t\t*setByUser = false\n\t}\n\tf.setByUser = setByUser\n\treturn f\n}\n\n// Default values for this flag. They *must* be parseable by the value of the flag.\nfunc (f *FlagClause) Default(values ...string) *FlagClause {\n\tf.defaultValues = values\n\treturn f\n}\n\n// DEPRECATED: Use Envar(name) instead.\nfunc (f *FlagClause) OverrideDefaultFromEnvar(envar string) *FlagClause {\n\treturn f.Envar(envar)\n}\n\n// Envar overrides the default value(s) for a flag from an environment variable,\n// if it is set. Several default values can be provided by using new lines to\n// separate them.\nfunc (f *FlagClause) Envar(name string) *FlagClause {\n\tf.envar = name\n\tf.noEnvar = false\n\treturn f\n}\n\n// NoEnvar forces environment variable defaults to be disabled for this flag.\n// Most useful in conjunction with app.DefaultEnvars().\nfunc (f *FlagClause) NoEnvar() *FlagClause {\n\tf.envar = \"\"\n\tf.noEnvar = true\n\treturn f\n}\n\n// PlaceHolder sets the place-holder string used for flag values in the help. The\n// default behaviour is to use the value provided by Default() if provided,\n// then fall back on the capitalized flag name.\nfunc (f *FlagClause) PlaceHolder(placeholder string) *FlagClause {\n\tf.placeholder = placeholder\n\treturn f\n}\n\n// Hidden hides a flag from usage but still allows it to be used.\nfunc (f *FlagClause) Hidden() *FlagClause {\n\tf.hidden = true\n\treturn f\n}\n\n// Required makes the flag required. You can not provide a Default() value to a Required() flag.\nfunc (f *FlagClause) Required() *FlagClause {\n\tf.required = true\n\treturn f\n}\n\n// Short sets the short flag name.\nfunc (f *FlagClause) Short(name rune) *FlagClause {\n\tf.shorthand = name\n\treturn f\n}\n\n// Help sets the help message.\nfunc (f *FlagClause) Help(help string) *FlagClause {\n\tf.help = help\n\treturn f\n}\n\n// Bool makes this flag a boolean flag.\nfunc (f *FlagClause) Bool() (target *bool) {\n\ttarget = new(bool)\n\tf.SetValue(newBoolValue(target))\n\treturn\n}\n"
        },
        {
          "name": "flags_test.go",
          "type": "blob",
          "size": 9.7998046875,
          "content": "package kingpin\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"testing\"\n)\n\nfunc TestBool(t *testing.T) {\n\tapp := newTestApp()\n\tb := app.Flag(\"b\", \"\").Bool()\n\t_, err := app.Parse([]string{\"--b\"})\n\tassert.NoError(t, err)\n\tassert.True(t, *b)\n}\n\nfunc TestNoBool(t *testing.T) {\n\tfg := newFlagGroup()\n\tf := fg.Flag(\"b\", \"\").Default(\"true\")\n\tb := f.Bool()\n\tfg.init(\"\")\n\ttokens := tokenize([]string{\"--no-b\"}, false)\n\t_, err := fg.parse(tokens)\n\tassert.NoError(t, err)\n\tassert.False(t, *b)\n}\n\nfunc TestNegateNonBool(t *testing.T) {\n\tfg := newFlagGroup()\n\tf := fg.Flag(\"b\", \"\")\n\tf.Int()\n\tfg.init(\"\")\n\ttokens := tokenize([]string{\"--no-b\"}, false)\n\t_, err := fg.parse(tokens)\n\tassert.Error(t, err)\n}\n\nfunc TestNegativePrefixLongFlag(t *testing.T) {\n\tfg := newFlagGroup()\n\tf := fg.Flag(\"no-comment\", \"\")\n\tb := f.Bool()\n\tfg.init(\"\")\n\ttokens := tokenize([]string{\"--no-comment\"}, false)\n\t_, err := fg.parse(tokens)\n\tassert.NoError(t, err)\n\tassert.False(t, *b)\n}\n\nfunc TestInvalidFlagDefaultCanBeOverridden(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Flag(\"a\", \"\").Default(\"invalid\").Bool()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestRequiredFlag(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Version(\"0.0.0\").Writer(ioutil.Discard)\n\texits := 0\n\tapp.Terminate(func(int) { exits++ })\n\tapp.Flag(\"a\", \"\").Required().Bool()\n\t_, err := app.Parse([]string{\"--a\"})\n\tassert.NoError(t, err)\n\t_, err = app.Parse([]string{})\n\tassert.Error(t, err)\n\t_, _ = app.Parse([]string{\"--version\"})\n\tassert.Equal(t, 1, exits)\n}\n\nfunc TestShortFlag(t *testing.T) {\n\tapp := newTestApp()\n\tf := app.Flag(\"long\", \"\").Short('s').Bool()\n\t_, err := app.Parse([]string{\"-s\"})\n\tassert.NoError(t, err)\n\tassert.True(t, *f)\n}\n\nfunc TestUnicodeShortFlag(t *testing.T) {\n\tapp := newTestApp()\n\tf := app.Flag(\"aaa\", \"\").Short('ä').Bool()\n\t_, err := app.Parse([]string{\"-ä\"})\n\tassert.NoError(t, err)\n\tassert.True(t, *f)\n}\n\nfunc TestCombinedShortFlags(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"short0\", \"\").Short('0').Bool()\n\tb := app.Flag(\"short1\", \"\").Short('1').Bool()\n\tc := app.Flag(\"short2\", \"\").Short('2').Bool()\n\t_, err := app.Parse([]string{\"-01\"})\n\tassert.NoError(t, err)\n\tassert.True(t, *a)\n\tassert.True(t, *b)\n\tassert.False(t, *c)\n}\n\nfunc TestCombinedUnicodeShortFlags(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"short0\", \"\").Short('0').Bool()\n\tb := app.Flag(\"short1\", \"\").Short('1').Bool()\n\tc := app.Flag(\"short2\", \"\").Short('ä').Bool()\n\td := app.Flag(\"short3\", \"\").Short('2').Bool()\n\t_, err := app.Parse([]string{\"-0ä1\"})\n\tassert.NoError(t, err)\n\tassert.True(t, *a)\n\tassert.True(t, *b)\n\tassert.True(t, *c)\n\tassert.False(t, *d)\n}\n\nfunc TestCombinedShortFlagArg(t *testing.T) {\n\ta := newTestApp()\n\tn := a.Flag(\"short\", \"\").Short('s').Int()\n\t_, err := a.Parse([]string{\"-s10\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 10, *n)\n}\n\nfunc TestCombinedUnicodeShortFlagArg(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"short\", \"\").Short('ä').Int()\n\t_, err := app.Parse([]string{\"-ä10\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 10, *a)\n}\n\nfunc TestCombinedUnicodeShortFlagUnicodeArg(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"short\", \"\").Short('ä').String()\n\t_, err := app.Parse([]string{\"-äöö\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"öö\", *a)\n}\n\nfunc TestEmptyShortFlagIsAnError(t *testing.T) {\n\t_, err := newTestApp().Parse([]string{\"-\"})\n\tassert.Error(t, err)\n}\n\nfunc TestRequiredWithEnvarMissingErrors(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Flag(\"t\", \"\").Envar(\"TEST_ENVAR\").Required().Int()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestRequiredWithEnvar(t *testing.T) {\n\tos.Setenv(\"TEST_ENVAR\", \"123\")\n\tapp := newTestApp()\n\tflag := app.Flag(\"t\", \"\").Envar(\"TEST_ENVAR\").Required().Int()\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 123, *flag)\n}\n\nfunc TestSubcommandFlagRequiredWithEnvar(t *testing.T) {\n\tos.Setenv(\"TEST_ENVAR\", \"123\")\n\tapp := newTestApp()\n\tcmd := app.Command(\"command\", \"\")\n\tflag := cmd.Flag(\"t\", \"\").Envar(\"TEST_ENVAR\").Required().Int()\n\t_, err := app.Parse([]string{\"command\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 123, *flag)\n}\n\nfunc TestRegexp(t *testing.T) {\n\tapp := newTestApp()\n\tflag := app.Flag(\"reg\", \"\").Regexp()\n\t_, err := app.Parse([]string{\"--reg\", \"^abc$\"})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, *flag)\n\tassert.Equal(t, \"^abc$\", (*flag).String())\n\tassert.Regexp(t, *flag, \"abc\")\n\tassert.NotRegexp(t, *flag, \"abcd\")\n}\n\nfunc TestDuplicateShortFlag(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Flag(\"a\", \"\").Short('a').String()\n\tapp.Flag(\"b\", \"\").Short('a').String()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestDuplicateLongFlag(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Flag(\"a\", \"\").String()\n\tapp.Flag(\"a\", \"\").String()\n\t_, err := app.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestGetFlagAndOverrideDefault(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"a\", \"\").Default(\"default\").String()\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"default\", *a)\n\tapp.GetFlag(\"a\").Default(\"new\")\n\t_, err = app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"new\", *a)\n}\n\nfunc TestEnvarOverrideDefault(t *testing.T) {\n\tos.Setenv(\"TEST_ENVAR\", \"123\")\n\tapp := newTestApp()\n\tflag := app.Flag(\"t\", \"\").Default(\"default\").Envar(\"TEST_ENVAR\").String()\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"123\", *flag)\n}\n\nfunc TestFlagMultipleValuesDefault(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"a\", \"\").Default(\"default1\", \"default2\").Strings()\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"default1\", \"default2\"}, *a)\n}\n\nfunc TestFlagMultipleValuesDefaultNonRepeatable(t *testing.T) {\n\tc := newTestApp()\n\tc.Flag(\"foo\", \"foo\").Default(\"a\", \"b\").String()\n\t_, err := c.Parse([]string{})\n\tassert.Error(t, err)\n}\n\nfunc TestFlagMultipleValuesDefaultEnvarUnix(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"a\", \"\").Envar(\"TEST_MULTIPLE_VALUES\").Strings()\n\tos.Setenv(\"TEST_MULTIPLE_VALUES\", \"123\\n456\\n\")\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"123\", \"456\"}, *a)\n}\n\nfunc TestFlagMultipleValuesDefaultEnvarWindows(t *testing.T) {\n\tapp := newTestApp()\n\ta := app.Flag(\"a\", \"\").Envar(\"TEST_MULTIPLE_VALUES\").Strings()\n\tos.Setenv(\"TEST_MULTIPLE_VALUES\", \"123\\r\\n456\\r\\n\")\n\t_, err := app.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"123\", \"456\"}, *a)\n}\n\nfunc TestFlagMultipleValuesDefaultEnvarNonRepeatable(t *testing.T) {\n\tc := newTestApp()\n\ta := c.Flag(\"foo\", \"foo\").Envar(\"TEST_MULTIPLE_VALUES_NON_REPEATABLE\").String()\n\tos.Setenv(\"TEST_MULTIPLE_VALUES_NON_REPEATABLE\", \"123\\n456\")\n\t_, err := c.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"123\\n456\", *a)\n}\n\nfunc TestFlagHintAction(t *testing.T) {\n\tc := newTestApp()\n\n\taction := func() []string {\n\t\treturn []string{\"opt1\", \"opt2\"}\n\t}\n\n\ta := c.Flag(\"foo\", \"foo\").HintAction(action)\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\n\nfunc TestFlagHintOptions(t *testing.T) {\n\tc := newTestApp()\n\n\ta := c.Flag(\"foo\", \"foo\").HintOptions(\"opt1\", \"opt2\")\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\n\nfunc TestFlagEnumVar(t *testing.T) {\n\tc := newTestApp()\n\tvar bar string\n\n\ta := c.Flag(\"foo\", \"foo\")\n\ta.Enum(\"opt1\", \"opt2\")\n\tb := c.Flag(\"bar\", \"bar\")\n\tb.EnumVar(&bar, \"opt3\", \"opt4\")\n\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n\n\targs = b.resolveCompletions()\n\tassert.Equal(t, []string{\"opt3\", \"opt4\"}, args)\n}\n\nfunc TestMultiHintOptions(t *testing.T) {\n\tc := newTestApp()\n\n\ta := c.Flag(\"foo\", \"foo\").HintOptions(\"opt1\").HintOptions(\"opt2\")\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\nfunc TestMultiHintActions(t *testing.T) {\n\tc := newTestApp()\n\n\ta := c.Flag(\"foo\", \"foo\").\n\t\tHintAction(func() []string {\n\t\t\treturn []string{\"opt1\"}\n\t\t}).\n\t\tHintAction(func() []string {\n\t\t\treturn []string{\"opt2\"}\n\t\t})\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\n\nfunc TestCombinationHintActionsOptions(t *testing.T) {\n\tc := newTestApp()\n\n\ta := c.Flag(\"foo\", \"foo\").HintAction(func() []string {\n\t\treturn []string{\"opt1\"}\n\t}).HintOptions(\"opt2\")\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n}\n\nfunc TestCombinationEnumActions(t *testing.T) {\n\tc := newTestApp()\n\tvar foo string\n\n\ta := c.Flag(\"foo\", \"foo\").\n\t\tHintAction(func() []string {\n\t\t\treturn []string{\"opt1\", \"opt2\"}\n\t\t})\n\ta.Enum(\"opt3\", \"opt4\")\n\n\tb := c.Flag(\"bar\", \"bar\").\n\t\tHintAction(func() []string {\n\t\t\treturn []string{\"opt5\", \"opt6\"}\n\t\t})\n\tb.EnumVar(&foo, \"opt3\", \"opt4\")\n\n\t// Provided HintActions should override automatically generated Enum options.\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n\n\targs = b.resolveCompletions()\n\tassert.Equal(t, []string{\"opt5\", \"opt6\"}, args)\n}\n\nfunc TestCombinationEnumOptions(t *testing.T) {\n\tc := newTestApp()\n\tvar foo string\n\n\ta := c.Flag(\"foo\", \"foo\").HintOptions(\"opt1\", \"opt2\")\n\ta.Enum(\"opt3\", \"opt4\")\n\n\tb := c.Flag(\"bar\", \"bar\").HintOptions(\"opt5\", \"opt6\")\n\tb.EnumVar(&foo, \"opt3\", \"opt4\")\n\n\t// Provided HintOptions should override automatically generated Enum options.\n\targs := a.resolveCompletions()\n\tassert.Equal(t, []string{\"opt1\", \"opt2\"}, args)\n\n\targs = b.resolveCompletions()\n\tassert.Equal(t, []string{\"opt5\", \"opt6\"}, args)\n\n}\n\nfunc TestIsSetByUser(t *testing.T) {\n\tapp := newTestApp()\n\tvar isSet bool\n\tb := app.Flag(\"b\", \"\").IsSetByUser(&isSet).Bool()\n\t_, err := app.Parse([]string{\"--b\"})\n\tassert.NoError(t, err)\n\tassert.True(t, *b)\n\tassert.True(t, isSet)\n\n\tisSet = false\n\t_, err = app.Parse([]string{\"--no-b\"})\n\tassert.NoError(t, err)\n\tassert.False(t, *b)\n\tassert.True(t, isSet)\n\n\tisSet2 := true\n\tisSet = false\n\t_ = app.Flag(\"b2\", \"\").IsSetByUser(&isSet2).Bool()\n\t_, err = app.Parse([]string{\"--b\", \"--unknown\"})\n\tassert.Error(t, err)\n\tassert.True(t, isSet)\n\tassert.False(t, isSet2)\n}\n"
        },
        {
          "name": "global.go",
          "type": "blob",
          "size": 2.80078125,
          "content": "package kingpin\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\nvar (\n\t// CommandLine is the default Kingpin parser.\n\tCommandLine = New(filepath.Base(os.Args[0]), \"\")\n\t// Global help flag. Exposed for user customisation.\n\tHelpFlag = CommandLine.HelpFlag\n\t// Top-level help command. Exposed for user customisation. May be nil.\n\tHelpCommand = CommandLine.HelpCommand\n\t// Global version flag. Exposed for user customisation. May be nil.\n\tVersionFlag = CommandLine.VersionFlag\n\t// Whether to file expansion with '@' is enabled.\n\tEnableFileExpansion = true\n)\n\n// Command adds a new command to the default parser.\nfunc Command(name, help string) *CmdClause {\n\treturn CommandLine.Command(name, help)\n}\n\n// Flag adds a new flag to the default parser.\nfunc Flag(name, help string) *FlagClause {\n\treturn CommandLine.Flag(name, help)\n}\n\n// Arg adds a new argument to the top-level of the default parser.\nfunc Arg(name, help string) *ArgClause {\n\treturn CommandLine.Arg(name, help)\n}\n\n// Parse and return the selected command. Will call the termination handler if\n// an error is encountered.\nfunc Parse() string {\n\tselected := MustParse(CommandLine.Parse(os.Args[1:]))\n\tif selected == \"\" && CommandLine.cmdGroup.have() {\n\t\tUsage()\n\t\tCommandLine.terminate(0)\n\t}\n\treturn selected\n}\n\n// Errorf prints an error message to stderr.\nfunc Errorf(format string, args ...interface{}) {\n\tCommandLine.Errorf(format, args...)\n}\n\n// Fatalf prints an error message to stderr and exits.\nfunc Fatalf(format string, args ...interface{}) {\n\tCommandLine.Fatalf(format, args...)\n}\n\n// FatalIfError prints an error and exits if err is not nil. The error is printed\n// with the given prefix.\nfunc FatalIfError(err error, format string, args ...interface{}) {\n\tCommandLine.FatalIfError(err, format, args...)\n}\n\n// FatalUsage prints an error message followed by usage information, then\n// exits with a non-zero status.\nfunc FatalUsage(format string, args ...interface{}) {\n\tCommandLine.FatalUsage(format, args...)\n}\n\n// FatalUsageContext writes a printf formatted error message to stderr, then\n// usage information for the given ParseContext, before exiting.\nfunc FatalUsageContext(context *ParseContext, format string, args ...interface{}) {\n\tCommandLine.FatalUsageContext(context, format, args...)\n}\n\n// Usage prints usage to stderr.\nfunc Usage() {\n\tCommandLine.Usage(os.Args[1:])\n}\n\n// Set global usage template to use (defaults to DefaultUsageTemplate).\nfunc UsageTemplate(template string) *Application {\n\treturn CommandLine.UsageTemplate(template)\n}\n\n// MustParse can be used with app.Parse(args) to exit with an error if parsing fails.\nfunc MustParse(command string, err error) string {\n\tif err != nil {\n\t\tFatalf(\"%s, try --help\", err)\n\t}\n\treturn command\n}\n\n// Version adds a flag for displaying the application version number.\nfunc Version(version string) *Application {\n\treturn CommandLine.Version(version)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.34375,
          "content": "module github.com/alecthomas/kingpin/v2\n\ngo 1.17\n\nrequire (\n\tgithub.com/alecthomas/units v0.0.0-20240927000941-0f3dac36c52b\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/xhit/go-str2duration/v2 v2.1.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.0615234375,
          "content": "github.com/alecthomas/units v0.0.0-20240927000941-0f3dac36c52b h1:mimo19zliBX/vSQ6PWWSL9lK8qwHozUj03+zLoEB8O0=\ngithub.com/alecthomas/units v0.0.0-20240927000941-0f3dac36c52b/go.mod h1:fvzegU4vN3H1qMT+8wDmzjAcDONcgo2/SZ/TyfdUOFs=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/xhit/go-str2duration/v2 v2.1.0 h1:lxklc02Drh6ynqX+DdPyp5pCKLUQpRT8bp8Ydu2Bstc=\ngithub.com/xhit/go-str2duration/v2 v2.1.0/go.mod h1:ohY8p+0f07DiV6Em5LKB0s2YpLtXVyJfNt1+BlmyAsU=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "guesswidth.go",
          "type": "blob",
          "size": 0.1474609375,
          "content": "// +build appengine !linux,!freebsd,!darwin,!dragonfly,!netbsd,!openbsd\n\npackage kingpin\n\nimport \"io\"\n\nfunc guessWidth(w io.Writer) int {\n\treturn 80\n}\n"
        },
        {
          "name": "guesswidth_unix.go",
          "type": "blob",
          "size": 0.7109375,
          "content": "// +build !appengine,linux freebsd darwin dragonfly netbsd openbsd\n\npackage kingpin\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc guessWidth(w io.Writer) int {\n\t// check if COLUMNS env is set to comply with\n\t// http://pubs.opengroup.org/onlinepubs/009604499/basedefs/xbd_chap08.html\n\tcolsStr := os.Getenv(\"COLUMNS\")\n\tif colsStr != \"\" {\n\t\tif cols, err := strconv.Atoi(colsStr); err == nil {\n\t\t\treturn cols\n\t\t}\n\t}\n\n\tif t, ok := w.(*os.File); ok {\n\t\tfd := t.Fd()\n\t\tvar dimensions [4]uint16\n\n\t\tif _, _, err := syscall.Syscall6(\n\t\t\tsyscall.SYS_IOCTL,\n\t\t\tuintptr(fd),\n\t\t\tuintptr(syscall.TIOCGWINSZ),\n\t\t\tuintptr(unsafe.Pointer(&dimensions)),\n\t\t\t0, 0, 0,\n\t\t); err == 0 {\n\t\t\treturn int(dimensions[1])\n\t\t}\n\t}\n\treturn 80\n}\n"
        },
        {
          "name": "model.go",
          "type": "blob",
          "size": 5.0947265625,
          "content": "package kingpin\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Data model for Kingpin command-line structure.\n\nvar (\n\tignoreInCount = map[string]bool{\n\t\t\"help\":                   true,\n\t\t\"help-long\":              true,\n\t\t\"help-man\":               true,\n\t\t\"completion-bash\":        true,\n\t\t\"completion-script-bash\": true,\n\t\t\"completion-script-zsh\":  true,\n\t}\n)\n\ntype FlagGroupModel struct {\n\tFlags []*FlagModel\n}\n\nfunc (f *FlagGroupModel) FlagSummary() string {\n\tout := []string{}\n\tcount := 0\n\n\tfor _, flag := range f.Flags {\n\n\t\tif !ignoreInCount[flag.Name] {\n\t\t\tcount++\n\t\t}\n\n\t\tif flag.Required {\n\t\t\tif flag.IsBoolFlag() {\n\t\t\t\tout = append(out, fmt.Sprintf(\"--[no-]%s\", flag.Name))\n\t\t\t} else {\n\t\t\t\tout = append(out, fmt.Sprintf(\"--%s=%s\", flag.Name, flag.FormatPlaceHolder()))\n\t\t\t}\n\t\t}\n\t}\n\tif count != len(out) {\n\t\tout = append(out, \"[<flags>]\")\n\t}\n\treturn strings.Join(out, \" \")\n}\n\ntype FlagModel struct {\n\tName        string\n\tHelp        string\n\tShort       rune\n\tDefault     []string\n\tEnvar       string\n\tPlaceHolder string\n\tRequired    bool\n\tHidden      bool\n\tValue       Value\n}\n\nfunc (f *FlagModel) String() string {\n\tif f.Value == nil {\n\t\treturn \"\"\n\t}\n\treturn f.Value.String()\n}\n\nfunc (f *FlagModel) IsBoolFlag() bool {\n\tif fl, ok := f.Value.(boolFlag); ok {\n\t\treturn fl.IsBoolFlag()\n\t}\n\treturn false\n}\n\nfunc (f *FlagModel) FormatPlaceHolder() string {\n\tif f.PlaceHolder != \"\" {\n\t\treturn f.PlaceHolder\n\t}\n\tif len(f.Default) > 0 {\n\t\tellipsis := \"\"\n\t\tif len(f.Default) > 1 {\n\t\t\tellipsis = \"...\"\n\t\t}\n\t\tif _, ok := f.Value.(*stringValue); ok {\n\t\t\treturn strconv.Quote(f.Default[0]) + ellipsis\n\t\t}\n\t\treturn f.Default[0] + ellipsis\n\t}\n\treturn strings.ToUpper(f.Name)\n}\n\nfunc (f *FlagModel) HelpWithEnvar() string {\n\tif f.Envar == \"\" {\n\t\treturn f.Help\n\t}\n\treturn fmt.Sprintf(\"%s ($%s)\", f.Help, f.Envar)\n}\n\ntype ArgGroupModel struct {\n\tArgs []*ArgModel\n}\n\nfunc (a *ArgGroupModel) ArgSummary() string {\n\tdepth := 0\n\tout := []string{}\n\tfor _, arg := range a.Args {\n\t\tvar h string\n\t\tif arg.PlaceHolder != \"\" {\n\t\t\th = arg.PlaceHolder\n\t\t} else {\n\t\t\th = \"<\" + arg.Name + \">\"\n\t\t}\n\t\tif !arg.Required {\n\t\t\th = \"[\" + h\n\t\t\tdepth++\n\t\t}\n\t\tout = append(out, h)\n\t}\n\tout[len(out)-1] = out[len(out)-1] + strings.Repeat(\"]\", depth)\n\treturn strings.Join(out, \" \")\n}\n\nfunc (a *ArgModel) HelpWithEnvar() string {\n\tif a.Envar == \"\" {\n\t\treturn a.Help\n\t}\n\treturn fmt.Sprintf(\"%s ($%s)\", a.Help, a.Envar)\n}\n\ntype ArgModel struct {\n\tName        string\n\tHelp        string\n\tDefault     []string\n\tEnvar       string\n\tPlaceHolder string\n\tRequired    bool\n\tHidden      bool\n\tValue       Value\n}\n\nfunc (a *ArgModel) String() string {\n\tif a.Value == nil {\n\t\treturn \"\"\n\t}\n\n\treturn a.Value.String()\n}\n\ntype CmdGroupModel struct {\n\tCommands []*CmdModel\n}\n\nfunc (c *CmdGroupModel) FlattenedCommands() (out []*CmdModel) {\n\tfor _, cmd := range c.Commands {\n\t\tif len(cmd.Commands) == 0 {\n\t\t\tout = append(out, cmd)\n\t\t}\n\t\tout = append(out, cmd.FlattenedCommands()...)\n\t}\n\treturn\n}\n\ntype CmdModel struct {\n\tName        string\n\tAliases     []string\n\tHelp        string\n\tHelpLong    string\n\tFullCommand string\n\tDepth       int\n\tHidden      bool\n\tDefault     bool\n\t*FlagGroupModel\n\t*ArgGroupModel\n\t*CmdGroupModel\n}\n\nfunc (c *CmdModel) String() string {\n\treturn c.FullCommand\n}\n\ntype ApplicationModel struct {\n\tName    string\n\tHelp    string\n\tVersion string\n\tAuthor  string\n\t*ArgGroupModel\n\t*CmdGroupModel\n\t*FlagGroupModel\n}\n\nfunc (a *Application) Model() *ApplicationModel {\n\treturn &ApplicationModel{\n\t\tName:           a.Name,\n\t\tHelp:           a.Help,\n\t\tVersion:        a.version,\n\t\tAuthor:         a.author,\n\t\tFlagGroupModel: a.flagGroup.Model(),\n\t\tArgGroupModel:  a.argGroup.Model(),\n\t\tCmdGroupModel:  a.cmdGroup.Model(),\n\t}\n}\n\nfunc (a *argGroup) Model() *ArgGroupModel {\n\tm := &ArgGroupModel{}\n\tfor _, arg := range a.args {\n\t\tm.Args = append(m.Args, arg.Model())\n\t}\n\treturn m\n}\n\nfunc (a *ArgClause) Model() *ArgModel {\n\treturn &ArgModel{\n\t\tName:        a.name,\n\t\tHelp:        a.help,\n\t\tDefault:     a.defaultValues,\n\t\tEnvar:       a.envar,\n\t\tPlaceHolder: a.placeholder,\n\t\tRequired:    a.required,\n\t\tHidden:      a.hidden,\n\t\tValue:       a.value,\n\t}\n}\n\nfunc (f *flagGroup) Model() *FlagGroupModel {\n\tm := &FlagGroupModel{}\n\tfor _, fl := range f.flagOrder {\n\t\tm.Flags = append(m.Flags, fl.Model())\n\t}\n\treturn m\n}\n\nfunc (f *FlagClause) Model() *FlagModel {\n\treturn &FlagModel{\n\t\tName:        f.name,\n\t\tHelp:        f.help,\n\t\tShort:       rune(f.shorthand),\n\t\tDefault:     f.defaultValues,\n\t\tEnvar:       f.envar,\n\t\tPlaceHolder: f.placeholder,\n\t\tRequired:    f.required,\n\t\tHidden:      f.hidden,\n\t\tValue:       f.value,\n\t}\n}\n\nfunc (c *cmdGroup) Model() *CmdGroupModel {\n\tm := &CmdGroupModel{}\n\tfor _, cm := range c.commandOrder {\n\t\tm.Commands = append(m.Commands, cm.Model())\n\t}\n\treturn m\n}\n\nfunc (c *CmdClause) Model() *CmdModel {\n\tdepth := 0\n\tfor i := c; i != nil; i = i.parent {\n\t\tdepth++\n\t}\n\treturn &CmdModel{\n\t\tName:           c.name,\n\t\tAliases:        c.aliases,\n\t\tHelp:           c.help,\n\t\tHelpLong:       c.helpLong,\n\t\tDepth:          depth,\n\t\tHidden:         c.hidden,\n\t\tDefault:        c.isDefault,\n\t\tFullCommand:    c.FullCommand(),\n\t\tFlagGroupModel: c.flagGroup.Model(),\n\t\tArgGroupModel:  c.argGroup.Model(),\n\t\tCmdGroupModel:  c.cmdGroup.Model(),\n\t}\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 8.818359375,
          "content": "package kingpin\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\ntype TokenType int\n\n// Token types.\nconst (\n\tTokenShort TokenType = iota\n\tTokenLong\n\tTokenArg\n\tTokenError\n\tTokenEOL\n)\n\nfunc (t TokenType) String() string {\n\tswitch t {\n\tcase TokenShort:\n\t\treturn \"short flag\"\n\tcase TokenLong:\n\t\treturn \"long flag\"\n\tcase TokenArg:\n\t\treturn \"argument\"\n\tcase TokenError:\n\t\treturn \"error\"\n\tcase TokenEOL:\n\t\treturn \"<EOL>\"\n\t}\n\treturn \"?\"\n}\n\nvar (\n\tTokenEOLMarker = Token{-1, TokenEOL, \"\"}\n)\n\ntype Token struct {\n\tIndex int\n\tType  TokenType\n\tValue string\n}\n\nfunc (t *Token) Equal(o *Token) bool {\n\treturn t.Index == o.Index\n}\n\nfunc (t *Token) IsFlag() bool {\n\treturn t.Type == TokenShort || t.Type == TokenLong\n}\n\nfunc (t *Token) IsEOF() bool {\n\treturn t.Type == TokenEOL\n}\n\nfunc (t *Token) String() string {\n\tswitch t.Type {\n\tcase TokenShort:\n\t\treturn \"-\" + t.Value\n\tcase TokenLong:\n\t\treturn \"--\" + t.Value\n\tcase TokenArg:\n\t\treturn t.Value\n\tcase TokenError:\n\t\treturn \"error: \" + t.Value\n\tcase TokenEOL:\n\t\treturn \"<EOL>\"\n\tdefault:\n\t\tpanic(\"unhandled type\")\n\t}\n}\n\n// A union of possible elements in a parse stack.\ntype ParseElement struct {\n\t// Clause is either *CmdClause, *ArgClause or *FlagClause.\n\tClause interface{}\n\t// Value is corresponding value for an ArgClause or FlagClause (if any).\n\tValue *string\n}\n\n// ParseContext holds the current context of the parser. When passed to\n// Action() callbacks Elements will be fully populated with *FlagClause,\n// *ArgClause and *CmdClause values and their corresponding arguments (if\n// any).\ntype ParseContext struct {\n\tSelectedCommand *CmdClause\n\tignoreDefault   bool\n\targsOnly        bool\n\tpeek            []*Token\n\targi            int // Index of current command-line arg we're processing.\n\targs            []string\n\trawArgs         []string\n\tflags           *flagGroup\n\targuments       *argGroup\n\targumenti       int // Cursor into arguments\n\t// Flags, arguments and commands encountered and collected during parse.\n\tElements []*ParseElement\n}\n\nfunc (p *ParseContext) nextArg() *ArgClause {\n\tif p.argumenti >= len(p.arguments.args) {\n\t\treturn nil\n\t}\n\targ := p.arguments.args[p.argumenti]\n\tif !arg.consumesRemainder() {\n\t\tp.argumenti++\n\t}\n\treturn arg\n}\n\nfunc (p *ParseContext) next() {\n\tp.argi++\n\tp.args = p.args[1:]\n}\n\n// HasTrailingArgs returns true if there are unparsed command-line arguments.\n// This can occur if the parser can not match remaining arguments.\nfunc (p *ParseContext) HasTrailingArgs() bool {\n\treturn len(p.args) > 0\n}\n\nfunc tokenize(args []string, ignoreDefault bool) *ParseContext {\n\treturn &ParseContext{\n\t\tignoreDefault: ignoreDefault,\n\t\targs:          args,\n\t\trawArgs:       args,\n\t\tflags:         newFlagGroup(),\n\t\targuments:     newArgGroup(),\n\t}\n}\n\nfunc (p *ParseContext) mergeFlags(flags *flagGroup) {\n\tfor _, flag := range flags.flagOrder {\n\t\tif flag.shorthand != 0 {\n\t\t\tp.flags.short[string(flag.shorthand)] = flag\n\t\t}\n\t\tp.flags.long[flag.name] = flag\n\t\tp.flags.flagOrder = append(p.flags.flagOrder, flag)\n\t}\n}\n\nfunc (p *ParseContext) mergeArgs(args *argGroup) {\n\tp.arguments.args = append(p.arguments.args, args.args...)\n}\n\nfunc (p *ParseContext) EOL() bool {\n\treturn p.Peek().Type == TokenEOL\n}\n\nfunc (p *ParseContext) Error() bool {\n\treturn p.Peek().Type == TokenError\n}\n\n// Next token in the parse context.\nfunc (p *ParseContext) Next() *Token {\n\tif len(p.peek) > 0 {\n\t\treturn p.pop()\n\t}\n\n\t// End of tokens.\n\tif len(p.args) == 0 {\n\t\treturn &Token{Index: p.argi, Type: TokenEOL}\n\t}\n\n\tif p.argi > 0 && p.argi <= len(p.rawArgs) && p.rawArgs[p.argi-1] == \"--\" {\n\t\t// If the previous argument was a --, from now on only arguments are parsed.\n\t\tp.argsOnly = true\n\t}\n\targ := p.args[0]\n\tp.next()\n\n\tif p.argsOnly {\n\t\treturn &Token{p.argi, TokenArg, arg}\n\t}\n\n\tif arg == \"--\" {\n\t\treturn p.Next()\n\t}\n\n\tif strings.HasPrefix(arg, \"--\") {\n\t\tparts := strings.SplitN(arg[2:], \"=\", 2)\n\t\ttoken := &Token{p.argi, TokenLong, parts[0]}\n\t\tif len(parts) == 2 {\n\t\t\tp.Push(&Token{p.argi, TokenArg, parts[1]})\n\t\t}\n\t\treturn token\n\t}\n\n\tif strings.HasPrefix(arg, \"-\") {\n\t\tif len(arg) == 1 {\n\t\t\treturn &Token{Index: p.argi, Type: TokenArg}\n\t\t}\n\t\tshortRune, size := utf8.DecodeRuneInString(arg[1:])\n\t\tshort := string(shortRune)\n\t\tflag, ok := p.flags.short[short]\n\t\t// Not a known short flag, we'll just return it anyway.\n\t\tif !ok {\n\t\t} else if fb, ok := flag.value.(boolFlag); ok && fb.IsBoolFlag() {\n\t\t\t// Bool short flag.\n\t\t} else {\n\t\t\t// Short flag with combined argument: -fARG\n\t\t\ttoken := &Token{p.argi, TokenShort, short}\n\t\t\tif len(arg) > size+1 {\n\t\t\t\tp.Push(&Token{p.argi, TokenArg, arg[size+1:]})\n\t\t\t}\n\t\t\treturn token\n\t\t}\n\n\t\tif len(arg) > size+1 {\n\t\t\tp.args = append([]string{\"-\" + arg[size+1:]}, p.args...)\n\t\t}\n\t\treturn &Token{p.argi, TokenShort, short}\n\t} else if EnableFileExpansion && strings.HasPrefix(arg, \"@\") {\n\t\texpanded, err := ExpandArgsFromFile(arg[1:])\n\t\tif err != nil {\n\t\t\treturn &Token{p.argi, TokenError, err.Error()}\n\t\t}\n\t\tif len(p.args) == 0 {\n\t\t\tp.args = expanded\n\t\t} else {\n\t\t\tp.args = append(expanded, p.args...)\n\t\t}\n\t\treturn p.Next()\n\t}\n\n\treturn &Token{p.argi, TokenArg, arg}\n}\n\nfunc (p *ParseContext) Peek() *Token {\n\tif len(p.peek) == 0 {\n\t\treturn p.Push(p.Next())\n\t}\n\treturn p.peek[len(p.peek)-1]\n}\n\nfunc (p *ParseContext) Push(token *Token) *Token {\n\tp.peek = append(p.peek, token)\n\treturn token\n}\n\nfunc (p *ParseContext) pop() *Token {\n\tend := len(p.peek) - 1\n\ttoken := p.peek[end]\n\tp.peek = p.peek[0:end]\n\treturn token\n}\n\nfunc (p *ParseContext) String() string {\n\treturn p.SelectedCommand.FullCommand()\n}\n\nfunc (p *ParseContext) matchedFlag(flag *FlagClause, value string) {\n\tp.Elements = append(p.Elements, &ParseElement{Clause: flag, Value: &value})\n}\n\nfunc (p *ParseContext) matchedArg(arg *ArgClause, value string) {\n\tp.Elements = append(p.Elements, &ParseElement{Clause: arg, Value: &value})\n}\n\nfunc (p *ParseContext) matchedCmd(cmd *CmdClause) {\n\tp.Elements = append(p.Elements, &ParseElement{Clause: cmd})\n\tp.mergeFlags(cmd.flagGroup)\n\tp.mergeArgs(cmd.argGroup)\n\tp.SelectedCommand = cmd\n}\n\n// Expand arguments from a file. Lines starting with # will be treated as comments.\nfunc ExpandArgsFromFile(filename string) (out []string, err error) {\n\tif filename == \"\" {\n\t\treturn nil, fmt.Errorf(\"expected @ file to expand arguments from\")\n\t}\n\tr, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open arguments file %q: %s\", filename, err)\n\t}\n\tdefer r.Close()\n\tscanner := bufio.NewScanner(r)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"#\") || strings.TrimSpace(line) == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tout = append(out, line)\n\t}\n\terr = scanner.Err()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read arguments from %q: %s\", filename, err)\n\t}\n\treturn\n}\n\nfunc parse(context *ParseContext, app *Application) (err error) {\n\tcontext.mergeFlags(app.flagGroup)\n\tcontext.mergeArgs(app.argGroup)\n\n\tcmds := app.cmdGroup\n\tignoreDefault := context.ignoreDefault\n\nloop:\n\tfor !context.EOL() && !context.Error() {\n\t\ttoken := context.Peek()\n\n\t\tswitch token.Type {\n\t\tcase TokenLong, TokenShort:\n\t\t\tif flag, err := context.flags.parse(context); err != nil {\n\t\t\t\tif !ignoreDefault {\n\t\t\t\t\tif cmd := cmds.defaultSubcommand(); cmd != nil {\n\t\t\t\t\t\tcmd.completionAlts = cmds.cmdNames()\n\t\t\t\t\t\tcontext.matchedCmd(cmd)\n\t\t\t\t\t\tcmds = cmd.cmdGroup\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t} else if flag == HelpFlag {\n\t\t\t\tignoreDefault = true\n\t\t\t}\n\n\t\tcase TokenArg:\n\t\t\tif cmds.have() {\n\t\t\t\tselectedDefault := false\n\t\t\t\tcmd, ok := cmds.commands[token.String()]\n\t\t\t\tif !ok {\n\t\t\t\t\tif !ignoreDefault {\n\t\t\t\t\t\tif cmd = cmds.defaultSubcommand(); cmd != nil {\n\t\t\t\t\t\t\tcmd.completionAlts = cmds.cmdNames()\n\t\t\t\t\t\t\tselectedDefault = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif cmd == nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"expected command but got %q\", token)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif cmd == HelpCommand {\n\t\t\t\t\tignoreDefault = true\n\t\t\t\t}\n\t\t\t\tcmd.completionAlts = nil\n\t\t\t\tcontext.matchedCmd(cmd)\n\t\t\t\tcmds = cmd.cmdGroup\n\t\t\t\tif !selectedDefault {\n\t\t\t\t\tcontext.Next()\n\t\t\t\t}\n\t\t\t} else if context.arguments.have() {\n\t\t\t\tif app.noInterspersed {\n\t\t\t\t\t// no more flags\n\t\t\t\t\tcontext.argsOnly = true\n\t\t\t\t}\n\t\t\t\targ := context.nextArg()\n\t\t\t\tif arg == nil {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tcontext.matchedArg(arg, token.String())\n\t\t\t\tcontext.Next()\n\t\t\t} else {\n\t\t\t\tbreak loop\n\t\t\t}\n\n\t\tcase TokenEOL:\n\t\t\tbreak loop\n\t\t}\n\t}\n\n\t// Move to innermost default command.\n\tfor !ignoreDefault {\n\t\tif cmd := cmds.defaultSubcommand(); cmd != nil {\n\t\t\tcmd.completionAlts = cmds.cmdNames()\n\t\t\tcontext.matchedCmd(cmd)\n\t\t\tcmds = cmd.cmdGroup\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif context.Error() {\n\t\treturn fmt.Errorf(\"%s\", context.Peek().Value)\n\t}\n\n\tif !context.EOL() {\n\t\treturn fmt.Errorf(\"unexpected %s\", context.Peek())\n\t}\n\n\t// Set defaults for all remaining args.\n\tfor arg := context.nextArg(); arg != nil && !arg.consumesRemainder(); arg = context.nextArg() {\n\t\tfor _, defaultValue := range arg.defaultValues {\n\t\t\tif err := arg.value.Set(defaultValue); err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid default value '%s' for argument '%s'\", defaultValue, arg.name)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "parser_test.go",
          "type": "blob",
          "size": 3.0517578125,
          "content": "package kingpin\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParserExpandFromFile(t *testing.T) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tf.WriteString(\"hello\\nworld\\n\")\n\tf.Close()\n\n\tapp := New(\"test\", \"\")\n\targ0 := app.Arg(\"arg0\", \"\").String()\n\targ1 := app.Arg(\"arg1\", \"\").String()\n\n\t_, err = app.Parse([]string{\"@\" + f.Name()})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hello\", *arg0)\n\tassert.Equal(t, \"world\", *arg1)\n}\n\nfunc TestParserExpandFromFileLeadingArg(t *testing.T) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tf.WriteString(\"hello\\nworld\\n\")\n\tf.Close()\n\n\tapp := New(\"test\", \"\")\n\targ0 := app.Arg(\"arg0\", \"\").String()\n\targ1 := app.Arg(\"arg1\", \"\").String()\n\targ2 := app.Arg(\"arg2\", \"\").String()\n\n\t_, err = app.Parse([]string{\"prefix\", \"@\" + f.Name()})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"prefix\", *arg0)\n\tassert.Equal(t, \"hello\", *arg1)\n\tassert.Equal(t, \"world\", *arg2)\n}\n\nfunc TestParserExpandFromFileTrailingArg(t *testing.T) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tf.WriteString(\"hello\\nworld\\n\")\n\tf.Close()\n\n\tapp := New(\"test\", \"\")\n\targ0 := app.Arg(\"arg0\", \"\").String()\n\targ1 := app.Arg(\"arg1\", \"\").String()\n\targ2 := app.Arg(\"arg2\", \"\").String()\n\n\t_, err = app.Parse([]string{\"@\" + f.Name(), \"suffix\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"hello\", *arg0)\n\tassert.Equal(t, \"world\", *arg1)\n\tassert.Equal(t, \"suffix\", *arg2)\n}\n\nfunc TestParserExpandFromFileMultipleSurroundingArgs(t *testing.T) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tf.WriteString(\"hello\\nworld\\n\")\n\tf.Close()\n\n\tapp := New(\"test\", \"\")\n\targ0 := app.Arg(\"arg0\", \"\").String()\n\targ1 := app.Arg(\"arg1\", \"\").String()\n\targ2 := app.Arg(\"arg2\", \"\").String()\n\targ3 := app.Arg(\"arg3\", \"\").String()\n\n\t_, err = app.Parse([]string{\"prefix\", \"@\" + f.Name(), \"suffix\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"prefix\", *arg0)\n\tassert.Equal(t, \"hello\", *arg1)\n\tassert.Equal(t, \"world\", *arg2)\n\tassert.Equal(t, \"suffix\", *arg3)\n}\n\nfunc TestParserExpandFromFileMultipleFlags(t *testing.T) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tassert.NoError(t, err)\n\tdefer os.Remove(f.Name())\n\tf.WriteString(\"--flag1=f1\\n--flag2=f2\\n\")\n\tf.Close()\n\n\tapp := New(\"test\", \"\")\n\tflag0 := app.Flag(\"flag0\", \"\").String()\n\tflag1 := app.Flag(\"flag1\", \"\").String()\n\tflag2 := app.Flag(\"flag2\", \"\").String()\n\tflag3 := app.Flag(\"flag3\", \"\").String()\n\n\t_, err = app.Parse([]string{\"--flag0=f0\", \"@\" + f.Name(), \"--flag3=f3\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"f0\", *flag0)\n\tassert.Equal(t, \"f1\", *flag1)\n\tassert.Equal(t, \"f2\", *flag2)\n\tassert.Equal(t, \"f3\", *flag3)\n}\n\nfunc TestParseContextPush(t *testing.T) {\n\tapp := New(\"test\", \"\")\n\tapp.Command(\"foo\", \"\").Command(\"bar\", \"\")\n\tc := tokenize([]string{\"foo\", \"bar\"}, false)\n\ta := c.Next()\n\tassert.Equal(t, TokenArg, a.Type)\n\tb := c.Next()\n\tassert.Equal(t, TokenArg, b.Type)\n\tc.Push(b)\n\tc.Push(a)\n\ta = c.Next()\n\tassert.Equal(t, \"foo\", a.Value)\n\tb = c.Next()\n\tassert.Equal(t, \"bar\", b.Value)\n}\n"
        },
        {
          "name": "parsers.go",
          "type": "blob",
          "size": 5.376953125,
          "content": "package kingpin\n\nimport (\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/alecthomas/units\"\n)\n\ntype Settings interface {\n\tSetValue(value Value)\n}\n\ntype parserMixin struct {\n\tvalue    Value\n\trequired bool\n}\n\nfunc (p *parserMixin) SetText(text Text) {\n\tp.value = &wrapText{text}\n}\n\nfunc (p *parserMixin) SetValue(value Value) {\n\tp.value = value\n}\n\n// StringMap provides key=value parsing into a map.\nfunc (p *parserMixin) StringMap() (target *map[string]string) {\n\ttarget = &(map[string]string{})\n\tp.StringMapVar(target)\n\treturn\n}\n\n// Duration sets the parser to a time.Duration parser.\nfunc (p *parserMixin) Duration() (target *time.Duration) {\n\ttarget = new(time.Duration)\n\tp.DurationVar(target)\n\treturn\n}\n\n// Bytes parses numeric byte units. eg. 1.5KB\nfunc (p *parserMixin) Bytes() (target *units.Base2Bytes) {\n\ttarget = new(units.Base2Bytes)\n\tp.BytesVar(target)\n\treturn\n}\n\n// IP sets the parser to a net.IP parser.\nfunc (p *parserMixin) IP() (target *net.IP) {\n\ttarget = new(net.IP)\n\tp.IPVar(target)\n\treturn\n}\n\n// TCP (host:port) address.\nfunc (p *parserMixin) TCP() (target **net.TCPAddr) {\n\ttarget = new(*net.TCPAddr)\n\tp.TCPVar(target)\n\treturn\n}\n\n// TCPVar (host:port) address.\nfunc (p *parserMixin) TCPVar(target **net.TCPAddr) {\n\tp.SetValue(newTCPAddrValue(target))\n}\n\n// ExistingFile sets the parser to one that requires and returns an existing file.\nfunc (p *parserMixin) ExistingFile() (target *string) {\n\ttarget = new(string)\n\tp.ExistingFileVar(target)\n\treturn\n}\n\n// ExistingDir sets the parser to one that requires and returns an existing directory.\nfunc (p *parserMixin) ExistingDir() (target *string) {\n\ttarget = new(string)\n\tp.ExistingDirVar(target)\n\treturn\n}\n\n// ExistingFileOrDir sets the parser to one that requires and returns an existing file OR directory.\nfunc (p *parserMixin) ExistingFileOrDir() (target *string) {\n\ttarget = new(string)\n\tp.ExistingFileOrDirVar(target)\n\treturn\n}\n\n// File returns an os.File against an existing file.\nfunc (p *parserMixin) File() (target **os.File) {\n\ttarget = new(*os.File)\n\tp.FileVar(target)\n\treturn\n}\n\n// File attempts to open a File with os.OpenFile(flag, perm).\nfunc (p *parserMixin) OpenFile(flag int, perm os.FileMode) (target **os.File) {\n\ttarget = new(*os.File)\n\tp.OpenFileVar(target, flag, perm)\n\treturn\n}\n\n// URL provides a valid, parsed url.URL.\nfunc (p *parserMixin) URL() (target **url.URL) {\n\ttarget = new(*url.URL)\n\tp.URLVar(target)\n\treturn\n}\n\n// StringMap provides key=value parsing into a map.\nfunc (p *parserMixin) StringMapVar(target *map[string]string) {\n\tp.SetValue(newStringMapValue(target))\n}\n\n// Float sets the parser to a float64 parser.\nfunc (p *parserMixin) Float() (target *float64) {\n\treturn p.Float64()\n}\n\n// Float sets the parser to a float64 parser.\nfunc (p *parserMixin) FloatVar(target *float64) {\n\tp.Float64Var(target)\n}\n\n// Duration sets the parser to a time.Duration parser.\nfunc (p *parserMixin) DurationVar(target *time.Duration) {\n\tp.SetValue(newDurationValue(target))\n}\n\n// BytesVar parses numeric byte units. eg. 1.5KB\nfunc (p *parserMixin) BytesVar(target *units.Base2Bytes) {\n\tp.SetValue(newBytesValue(target))\n}\n\n// IP sets the parser to a net.IP parser.\nfunc (p *parserMixin) IPVar(target *net.IP) {\n\tp.SetValue(newIPValue(target))\n}\n\n// ExistingFile sets the parser to one that requires and returns an existing file.\nfunc (p *parserMixin) ExistingFileVar(target *string) {\n\tp.SetValue(newExistingFileValue(target))\n}\n\n// ExistingDir sets the parser to one that requires and returns an existing directory.\nfunc (p *parserMixin) ExistingDirVar(target *string) {\n\tp.SetValue(newExistingDirValue(target))\n}\n\n// ExistingDir sets the parser to one that requires and returns an existing directory.\nfunc (p *parserMixin) ExistingFileOrDirVar(target *string) {\n\tp.SetValue(newExistingFileOrDirValue(target))\n}\n\n// FileVar opens an existing file.\nfunc (p *parserMixin) FileVar(target **os.File) {\n\tp.SetValue(newFileValue(target, os.O_RDONLY, 0))\n}\n\n// OpenFileVar calls os.OpenFile(flag, perm)\nfunc (p *parserMixin) OpenFileVar(target **os.File, flag int, perm os.FileMode) {\n\tp.SetValue(newFileValue(target, flag, perm))\n}\n\n// URL provides a valid, parsed url.URL.\nfunc (p *parserMixin) URLVar(target **url.URL) {\n\tp.SetValue(newURLValue(target))\n}\n\n// URLList provides a parsed list of url.URL values.\nfunc (p *parserMixin) URLList() (target *[]*url.URL) {\n\ttarget = new([]*url.URL)\n\tp.URLListVar(target)\n\treturn\n}\n\n// URLListVar provides a parsed list of url.URL values.\nfunc (p *parserMixin) URLListVar(target *[]*url.URL) {\n\tp.SetValue(newURLListValue(target))\n}\n\n// Enum allows a value from a set of options.\nfunc (p *parserMixin) Enum(options ...string) (target *string) {\n\ttarget = new(string)\n\tp.EnumVar(target, options...)\n\treturn\n}\n\n// EnumVar allows a value from a set of options.\nfunc (p *parserMixin) EnumVar(target *string, options ...string) {\n\tp.SetValue(newEnumFlag(target, options...))\n}\n\n// Enums allows a set of values from a set of options.\nfunc (p *parserMixin) Enums(options ...string) (target *[]string) {\n\ttarget = new([]string)\n\tp.EnumsVar(target, options...)\n\treturn\n}\n\n// EnumVar allows a value from a set of options.\nfunc (p *parserMixin) EnumsVar(target *[]string, options ...string) {\n\tp.SetValue(newEnumsFlag(target, options...))\n}\n\n// A Counter increments a number each time it is encountered.\nfunc (p *parserMixin) Counter() (target *int) {\n\ttarget = new(int)\n\tp.CounterVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) CounterVar(target *int) {\n\tp.SetValue(newCounterValue(target))\n}\n"
        },
        {
          "name": "parsers_test.go",
          "type": "blob",
          "size": 2.0400390625,
          "content": "package kingpin\n\nimport (\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"testing\"\n)\n\nfunc TestParseStrings(t *testing.T) {\n\tp := parserMixin{}\n\tv := p.Strings()\n\tp.value.Set(\"a\")\n\tp.value.Set(\"b\")\n\tassert.Equal(t, []string{\"a\", \"b\"}, *v)\n}\n\nfunc TestStringsStringer(t *testing.T) {\n\ttarget := []string{}\n\tv := newAccumulator(&target, func(v interface{}) Value { return newStringValue(v.(*string)) })\n\tv.Set(\"hello\")\n\tv.Set(\"world\")\n\tassert.Equal(t, \"hello,world\", v.String())\n}\n\nfunc TestParseStringMap(t *testing.T) {\n\tp := parserMixin{}\n\tv := p.StringMap()\n\tp.value.Set(\"a:b\")\n\tp.value.Set(\"b:c\")\n\tassert.Equal(t, map[string]string{\"a\": \"b\", \"b\": \"c\"}, *v)\n}\n\nfunc TestParseIP(t *testing.T) {\n\tp := parserMixin{}\n\tv := p.IP()\n\tp.value.Set(\"10.1.1.2\")\n\tip := net.ParseIP(\"10.1.1.2\")\n\tassert.Equal(t, ip, *v)\n}\n\nfunc TestParseURL(t *testing.T) {\n\tp := parserMixin{}\n\tv := p.URL()\n\tp.value.Set(\"http://w3.org\")\n\tu, err := url.Parse(\"http://w3.org\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, *u, **v)\n}\n\nfunc TestParseExistingFile(t *testing.T) {\n\tf, err := ioutil.TempFile(\"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tdefer os.Remove(f.Name())\n\n\tp := parserMixin{}\n\tv := p.ExistingFile()\n\terr = p.value.Set(f.Name())\n\tassert.NoError(t, err)\n\tassert.Equal(t, f.Name(), *v)\n\terr = p.value.Set(\"/etc/hostsDEFINITELYMISSING\")\n\tassert.Error(t, err)\n}\n\nfunc TestParseTCPAddr(t *testing.T) {\n\tp := parserMixin{}\n\tv := p.TCP()\n\terr := p.value.Set(\"127.0.0.1:1234\")\n\tassert.NoError(t, err)\n\texpected, err := net.ResolveTCPAddr(\"tcp\", \"127.0.0.1:1234\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, *expected, **v)\n}\n\nfunc TestParseTCPAddrList(t *testing.T) {\n\tp := parserMixin{}\n\t_ = p.TCPList()\n\terr := p.value.Set(\"127.0.0.1:1234\")\n\tassert.NoError(t, err)\n\terr = p.value.Set(\"127.0.0.1:1235\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"127.0.0.1:1234,127.0.0.1:1235\", p.value.String())\n}\n\nfunc TestFloat32(t *testing.T) {\n\tp := parserMixin{}\n\tv := p.Float32()\n\terr := p.value.Set(\"123.45\")\n\tassert.NoError(t, err)\n\tassert.InEpsilon(t, 123.45, *v, 0.001)\n}\n"
        },
        {
          "name": "renovate.json5",
          "type": "blob",
          "size": 0.345703125,
          "content": "{\n  $schema: \"https://docs.renovatebot.com/renovate-schema.json\",\n  extends: [\n    \"config:recommended\",\n    \":semanticCommits\",\n    \":semanticCommitTypeAll(chore)\",\n    \":semanticCommitScope(deps)\",\n    \"group:allNonMajor\",\n    \"schedule:earlyMondays\", // Run once a week.\n  ],\n  postUpdateOptions: [\n    \"gomodTidy\",\n    \"gomodUpdateImportPaths\"\n  ]\n}\n"
        },
        {
          "name": "templates.go",
          "type": "blob",
          "size": 7.2099609375,
          "content": "package kingpin\n\n// Default usage template.\nvar DefaultUsageTemplate = `{{define \"FormatCommand\" -}}\n{{if .FlagSummary}} {{.FlagSummary}}{{end -}}\n{{range .Args}}{{if not .Hidden}} {{if not .Required}}[{{end}}{{if .PlaceHolder}}{{.PlaceHolder}}{{else}}<{{.Name}}>{{end}}{{if .Value|IsCumulative}}...{{end}}{{if not .Required}}]{{end}}{{end}}{{end -}}\n{{end -}}\n\n{{define \"FormatCommands\" -}}\n{{range .FlattenedCommands -}}\n{{if not .Hidden -}}\n  {{.FullCommand}}{{if .Default}}*{{end}}{{template \"FormatCommand\" .}}\n{{.Help|Wrap 4}}\n{{end -}}\n{{end -}}\n{{end -}}\n\n{{define \"FormatUsage\" -}}\n{{template \"FormatCommand\" .}}{{if .Commands}} <command> [<args> ...]{{end}}\n{{if .Help}}\n{{.Help|Wrap 0 -}}\n{{end -}}\n\n{{end -}}\n\n{{if .Context.SelectedCommand -}}\nusage: {{.App.Name}} {{.Context.SelectedCommand}}{{template \"FormatUsage\" .Context.SelectedCommand}}\n{{ else -}}\nusage: {{.App.Name}}{{template \"FormatUsage\" .App}}\n{{end}}\n{{if .Context.Flags -}}\nFlags:\n{{.Context.Flags|FlagsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.Args -}}\nArgs:\n{{.Context.Args|ArgsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.SelectedCommand -}}\n{{if len .Context.SelectedCommand.Commands -}}\nSubcommands:\n{{template \"FormatCommands\" .Context.SelectedCommand}}\n{{end -}}\n{{else if .App.Commands -}}\nCommands:\n{{template \"FormatCommands\" .App}}\n{{end -}}\n`\n\n// Usage template where command's optional flags are listed separately\nvar SeparateOptionalFlagsUsageTemplate = `{{define \"FormatCommand\" -}}\n{{if .FlagSummary}} {{.FlagSummary}}{{end -}}\n{{range .Args}}{{if not .Hidden}} {{if not .Required}}[{{end}}{{if .PlaceHolder}}{{.PlaceHolder}}{{else}}<{{.Name}}>{{end}}{{if .Value|IsCumulative}}...{{end}}{{if not .Required}}]{{end}}{{end}}{{end -}}\n{{end -}}\n\n{{define \"FormatCommands\" -}}\n{{range .FlattenedCommands -}}\n{{if not .Hidden -}}\n  {{.FullCommand}}{{if .Default}}*{{end}}{{template \"FormatCommand\" .}}\n{{.Help|Wrap 4}}\n{{end -}}\n{{end -}}\n{{end -}}\n\n{{define \"FormatUsage\" -}}\n{{template \"FormatCommand\" .}}{{if .Commands}} <command> [<args> ...]{{end}}\n{{if .Help}}\n{{.Help|Wrap 0 -}}\n{{end -}}\n\n{{end -}}\n{{if .Context.SelectedCommand -}}\nusage: {{.App.Name}} {{.Context.SelectedCommand}}{{template \"FormatUsage\" .Context.SelectedCommand}}\n{{else -}}\nusage: {{.App.Name}}{{template \"FormatUsage\" .App}}\n{{end -}}\n\n{{if .Context.Flags|RequiredFlags -}}\nRequired flags:\n{{.Context.Flags|RequiredFlags|FlagsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if  .Context.Flags|OptionalFlags -}}\nOptional flags:\n{{.Context.Flags|OptionalFlags|FlagsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.Args -}}\nArgs:\n{{.Context.Args|ArgsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.SelectedCommand -}}\nSubcommands:\n{{if .Context.SelectedCommand.Commands -}}\n{{template \"FormatCommands\" .Context.SelectedCommand}}\n{{end -}}\n{{else if .App.Commands -}}\nCommands:\n{{template \"FormatCommands\" .App}}\n{{end -}}\n`\n\n// Usage template with compactly formatted commands.\nvar CompactUsageTemplate = `{{define \"FormatCommand\" -}}\n{{if .FlagSummary}} {{.FlagSummary}}{{end -}}\n{{range .Args}}{{if not .Hidden}} {{if not .Required}}[{{end}}{{if .PlaceHolder}}{{.PlaceHolder}}{{else}}<{{.Name}}>{{end}}{{if .Value|IsCumulative}}...{{end}}{{if not .Required}}]{{end}}{{end}}{{end -}}\n{{end -}}\n\n{{define \"FormatCommandList\" -}}\n{{range . -}}\n{{if not .Hidden -}}\n{{.Depth|Indent}}{{.Name}}{{if .Default}}*{{end}}{{template \"FormatCommand\" .}}\n{{end -}}\n{{template \"FormatCommandList\" .Commands -}}\n{{end -}}\n{{end -}}\n\n{{define \"FormatUsage\" -}}\n{{template \"FormatCommand\" .}}{{if .Commands}} <command> [<args> ...]{{end}}\n{{if .Help}}\n{{.Help|Wrap 0 -}}\n{{end -}}\n\n{{end -}}\n\n{{if .Context.SelectedCommand -}}\nusage: {{.App.Name}} {{.Context.SelectedCommand}}{{template \"FormatUsage\" .Context.SelectedCommand}}\n{{else -}}\nusage: {{.App.Name}}{{template \"FormatUsage\" .App}}\n{{end -}}\n{{if .Context.Flags -}}\nFlags:\n{{.Context.Flags|FlagsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.Args -}}\nArgs:\n{{.Context.Args|ArgsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.SelectedCommand -}}\n{{if .Context.SelectedCommand.Commands -}}\nCommands:\n  {{.Context.SelectedCommand}}\n{{template \"FormatCommandList\" .Context.SelectedCommand.Commands}}\n{{end -}}\n{{else if .App.Commands -}}\nCommands:\n{{template \"FormatCommandList\" .App.Commands}}\n{{end -}}\n`\n\nvar ManPageTemplate = `{{define \"FormatFlags\" -}}\n{{range .Flags -}}\n{{if not .Hidden -}}\n.TP\n\\fB{{if .Short}}-{{.Short|Char}}, {{end}}--{{.Name}}{{if not .IsBoolFlag}}={{.FormatPlaceHolder}}{{end -}}\\fR\n{{.Help}}\n{{end -}}\n{{end -}}\n{{end -}}\n\n{{define \"FormatCommand\" -}}\n{{if .FlagSummary}} {{.FlagSummary}}{{end -}}\n{{range .Args}}{{if not .Hidden}} {{if not .Required}}[{{end}}{{if .PlaceHolder}}{{.PlaceHolder}}{{else}}<{{.Name}}>{{end}}{{if .Value|IsCumulative}}...{{end}}{{if not .Required}}]{{end}}{{end}}{{end -}}\n{{end -}}\n\n{{define \"FormatCommands\" -}}\n{{range .FlattenedCommands -}}\n{{if not .Hidden -}}\n.SS\n\\fB{{.FullCommand}}{{template \"FormatCommand\" . -}}\\fR\n.PP\n{{.Help}}\n{{template \"FormatFlags\" . -}}\n{{end -}}\n{{end -}}\n{{end -}}\n\n{{define \"FormatUsage\" -}}\n{{template \"FormatCommand\" .}}{{if .Commands}} <command> [<args> ...]{{end -}}\\fR\n{{end -}}\n\n.TH {{.App.Name}} 1 {{.App.Version}} \"{{.App.Author}}\"\n.SH \"NAME\"\n{{.App.Name}}\n.SH \"SYNOPSIS\"\n.TP\n\\fB{{.App.Name}}{{template \"FormatUsage\" .App}}\n.SH \"DESCRIPTION\"\n{{.App.Help}}\n.SH \"OPTIONS\"\n{{template \"FormatFlags\" .App -}}\n{{if .App.Commands -}}\n.SH \"COMMANDS\"\n{{template \"FormatCommands\" .App -}}\n{{end -}}\n`\n\n// Default usage template.\nvar LongHelpTemplate = `{{define \"FormatCommand\" -}}\n{{if .FlagSummary}} {{.FlagSummary}}{{end -}}\n{{range .Args}}{{if not .Hidden}} {{if not .Required}}[{{end}}{{if .PlaceHolder}}{{.PlaceHolder}}{{else}}<{{.Name}}>{{end}}{{if .Value|IsCumulative}}...{{end}}{{if not .Required}}]{{end}}{{end}}{{end -}}\n{{end -}}\n\n{{define \"FormatCommands\" -}}\n{{range .FlattenedCommands -}}\n{{if not .Hidden -}}\n  {{.FullCommand}}{{template \"FormatCommand\" .}}\n{{.Help|Wrap 4}}\n{{with .Flags|FlagsToTwoColumns}}{{FormatTwoColumnsWithIndent . 4 2}}{{end}}\n{{end -}}\n{{end -}}\n{{end -}}\n\n{{define \"FormatUsage\" -}}\n{{template \"FormatCommand\" .}}{{if .Commands}} <command> [<args> ...]{{end}}\n{{if .Help}}\n{{.Help|Wrap 0 -}}\n{{end -}}\n\n{{end -}}\n\nusage: {{.App.Name}}{{template \"FormatUsage\" .App}}\n{{if .Context.Flags -}}\nFlags:\n{{.Context.Flags|FlagsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .Context.Args -}}\nArgs:\n{{.Context.Args|ArgsToTwoColumns|FormatTwoColumns}}\n{{end -}}\n{{if .App.Commands -}}\nCommands:\n{{template \"FormatCommands\" .App}}\n{{end -}}\n`\n\nvar BashCompletionTemplate = `\n_{{.App.Name}}_bash_autocomplete() {\n    local cur prev opts base\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    opts=$( ${COMP_WORDS[0]} --completion-bash \"${COMP_WORDS[@]:1:$COMP_CWORD}\" )\n    COMPREPLY=( $(compgen -W \"${opts}\" -- ${cur}) )\n    return 0\n}\ncomplete -F _{{.App.Name}}_bash_autocomplete -o default {{.App.Name}}\n\n`\n\nvar ZshCompletionTemplate = `#compdef {{.App.Name}}\n\n_{{.App.Name}}() {\n    local matches=($(${words[1]} --completion-bash \"${(@)words[2,$CURRENT]}\"))\n    compadd -a matches\n\n    if [[ $compstate[nmatches] -eq 0 && $words[$CURRENT] != -* ]]; then\n        _files\n    fi\n}\n\nif [[ \"$(basename -- ${(%):-%x})\" != \"_{{.App.Name}}\" ]]; then\n    compdef _{{.App.Name}} {{.App.Name}}\nfi\n`\n"
        },
        {
          "name": "usage.go",
          "type": "blob",
          "size": 5.654296875,
          "content": "package kingpin\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/doc\"\n\t\"io\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nvar (\n\tpreIndent = \"  \"\n)\n\nfunc formatTwoColumns(w io.Writer, indent, padding, width int, rows [][2]string) {\n\t// Find size of first column.\n\ts := 0\n\tfor _, row := range rows {\n\t\tif c := len(row[0]); c > s && c < 30 {\n\t\t\ts = c\n\t\t}\n\t}\n\n\tindentStr := strings.Repeat(\" \", indent)\n\toffsetStr := strings.Repeat(\" \", s+padding)\n\n\tfor _, row := range rows {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tdoc.ToText(buf, row[1], \"\", preIndent, width-s-padding-indent)\n\t\tlines := strings.Split(strings.TrimRight(buf.String(), \"\\n\"), \"\\n\")\n\t\tfmt.Fprintf(w, \"%s%-*s%*s\", indentStr, s, row[0], padding, \"\")\n\t\tif len(row[0]) >= 30 {\n\t\t\tfmt.Fprintf(w, \"\\n%s%s\", indentStr, offsetStr)\n\t\t}\n\t\tfmt.Fprintf(w, \"%s\\n\", lines[0])\n\t\tfor _, line := range lines[1:] {\n\t\t\tfmt.Fprintf(w, \"%s%s%s\\n\", indentStr, offsetStr, line)\n\t\t}\n\t}\n}\n\n// Usage writes application usage to w. It parses args to determine\n// appropriate help context, such as which command to show help for.\nfunc (a *Application) Usage(args []string) {\n\tcontext, err := a.parseContext(true, args)\n\ta.FatalIfError(err, \"\")\n\tif err := a.UsageForContextWithTemplate(context, 2, a.usageTemplate); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc formatAppUsage(app *ApplicationModel) string {\n\ts := []string{app.Name}\n\tif len(app.Flags) > 0 {\n\t\ts = append(s, app.FlagSummary())\n\t}\n\tif len(app.Args) > 0 {\n\t\ts = append(s, app.ArgSummary())\n\t}\n\treturn strings.Join(s, \" \")\n}\n\nfunc formatCmdUsage(app *ApplicationModel, cmd *CmdModel) string {\n\ts := []string{app.Name, cmd.String()}\n\tif len(cmd.Flags) > 0 {\n\t\ts = append(s, cmd.FlagSummary())\n\t}\n\tif len(cmd.Args) > 0 {\n\t\ts = append(s, cmd.ArgSummary())\n\t}\n\treturn strings.Join(s, \" \")\n}\n\nfunc formatFlag(haveShort bool, flag *FlagModel) string {\n\tflagString := \"\"\n\tflagName := flag.Name\n\tif flag.IsBoolFlag() {\n\t\tflagName = \"[no-]\" + flagName\n\t}\n\tif flag.Short != 0 {\n\t\tflagString += fmt.Sprintf(\"-%c, --%s\", flag.Short, flagName)\n\t} else {\n\t\tif haveShort {\n\t\t\tflagString += fmt.Sprintf(\"    --%s\", flagName)\n\t\t} else {\n\t\t\tflagString += fmt.Sprintf(\"--%s\", flagName)\n\t\t}\n\t}\n\tif !flag.IsBoolFlag() {\n\t\tflagString += fmt.Sprintf(\"=%s\", flag.FormatPlaceHolder())\n\t}\n\tif v, ok := flag.Value.(repeatableFlag); ok && v.IsCumulative() {\n\t\tflagString += \" ...\"\n\t}\n\treturn flagString\n}\n\ntype templateParseContext struct {\n\tSelectedCommand *CmdModel\n\t*FlagGroupModel\n\t*ArgGroupModel\n}\n\ntype templateContext struct {\n\tApp     *ApplicationModel\n\tWidth   int\n\tContext *templateParseContext\n}\n\n// UsageForContext displays usage information from a ParseContext (obtained from\n// Application.ParseContext() or Action(f) callbacks).\nfunc (a *Application) UsageForContext(context *ParseContext) error {\n\treturn a.UsageForContextWithTemplate(context, 2, a.usageTemplate)\n}\n\n// UsageForContextWithTemplate is the base usage function. You generally don't need to use this.\nfunc (a *Application) UsageForContextWithTemplate(context *ParseContext, indent int, tmpl string) error {\n\twidth := guessWidth(a.usageWriter)\n\tfuncs := template.FuncMap{\n\t\t\"Indent\": func(level int) string {\n\t\t\treturn strings.Repeat(\" \", level*indent)\n\t\t},\n\t\t\"Wrap\": func(indent int, s string) string {\n\t\t\tbuf := bytes.NewBuffer(nil)\n\t\t\tindentText := strings.Repeat(\" \", indent)\n\t\t\tdoc.ToText(buf, s, indentText, \"  \"+indentText, width-indent)\n\t\t\treturn buf.String()\n\t\t},\n\t\t\"FormatFlag\": formatFlag,\n\t\t\"FlagsToTwoColumns\": func(f []*FlagModel) [][2]string {\n\t\t\trows := [][2]string{}\n\t\t\thaveShort := false\n\t\t\tfor _, flag := range f {\n\t\t\t\tif flag.Short != 0 {\n\t\t\t\t\thaveShort = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, flag := range f {\n\t\t\t\tif !flag.Hidden {\n\t\t\t\t\trows = append(rows, [2]string{formatFlag(haveShort, flag), flag.HelpWithEnvar()})\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rows\n\t\t},\n\t\t\"RequiredFlags\": func(f []*FlagModel) []*FlagModel {\n\t\t\trequiredFlags := []*FlagModel{}\n\t\t\tfor _, flag := range f {\n\t\t\t\tif flag.Required {\n\t\t\t\t\trequiredFlags = append(requiredFlags, flag)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn requiredFlags\n\t\t},\n\t\t\"OptionalFlags\": func(f []*FlagModel) []*FlagModel {\n\t\t\toptionalFlags := []*FlagModel{}\n\t\t\tfor _, flag := range f {\n\t\t\t\tif !flag.Required {\n\t\t\t\t\toptionalFlags = append(optionalFlags, flag)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn optionalFlags\n\t\t},\n\t\t\"ArgsToTwoColumns\": func(a []*ArgModel) [][2]string {\n\t\t\trows := [][2]string{}\n\t\t\tfor _, arg := range a {\n\t\t\t\tif !arg.Hidden {\n\t\t\t\t\tvar s string\n\t\t\t\t\tif arg.PlaceHolder != \"\" {\n\t\t\t\t\t\ts = arg.PlaceHolder\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts = \"<\" + arg.Name + \">\"\n\t\t\t\t\t}\n\t\t\t\t\tif !arg.Required {\n\t\t\t\t\t\ts = \"[\" + s + \"]\"\n\t\t\t\t\t}\n\t\t\t\t\trows = append(rows, [2]string{s, arg.HelpWithEnvar()})\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rows\n\t\t},\n\t\t\"FormatTwoColumns\": func(rows [][2]string) string {\n\t\t\tbuf := bytes.NewBuffer(nil)\n\t\t\tformatTwoColumns(buf, indent, indent, width, rows)\n\t\t\treturn buf.String()\n\t\t},\n\t\t\"FormatTwoColumnsWithIndent\": func(rows [][2]string, indent, padding int) string {\n\t\t\tbuf := bytes.NewBuffer(nil)\n\t\t\tformatTwoColumns(buf, indent, padding, width, rows)\n\t\t\treturn buf.String()\n\t\t},\n\t\t\"FormatAppUsage\":     formatAppUsage,\n\t\t\"FormatCommandUsage\": formatCmdUsage,\n\t\t\"IsCumulative\": func(value Value) bool {\n\t\t\tr, ok := value.(remainderArg)\n\t\t\treturn ok && r.IsCumulative()\n\t\t},\n\t\t\"Char\": func(c rune) string {\n\t\t\treturn string(c)\n\t\t},\n\t}\n\tfor k, v := range a.usageFuncs {\n\t\tfuncs[k] = v\n\t}\n\n\tt, err := template.New(\"usage\").Funcs(funcs).Parse(tmpl)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar selectedCommand *CmdModel\n\tif context.SelectedCommand != nil {\n\t\tselectedCommand = context.SelectedCommand.Model()\n\t}\n\tctx := templateContext{\n\t\tApp:   a.Model(),\n\t\tWidth: width,\n\t\tContext: &templateParseContext{\n\t\t\tSelectedCommand: selectedCommand,\n\t\t\tFlagGroupModel:  context.flags.Model(),\n\t\t\tArgGroupModel:   context.arguments.Model(),\n\t\t},\n\t}\n\treturn t.Execute(a.usageWriter, ctx)\n}\n"
        },
        {
          "name": "usage_test.go",
          "type": "blob",
          "size": 2.5869140625,
          "content": "package kingpin\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFormatTwoColumns(t *testing.T) {\n\tbuf := bytes.NewBuffer(nil)\n\tformatTwoColumns(buf, 2, 2, 20, [][2]string{\n\t\t{\"--hello\", \"Hello world help with something that is cool.\"},\n\t})\n\texpected := `  --hello  Hello\n           world\n           help with\n           something\n           that is\n           cool.\n`\n\tassert.Equal(t, expected, buf.String())\n}\n\nfunc TestFormatTwoColumnsWide(t *testing.T) {\n\tsamples := [][2]string{\n\t\t{strings.Repeat(\"x\", 29), \"29 chars\"},\n\t\t{strings.Repeat(\"x\", 30), \"30 chars\"}}\n\tbuf := bytes.NewBuffer(nil)\n\tformatTwoColumns(buf, 0, 0, 200, samples)\n\texpected := `xxxxxxxxxxxxxxxxxxxxxxxxxxxxx29 chars\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n                             30 chars\n`\n\tassert.Equal(t, expected, buf.String())\n}\n\nfunc TestHiddenCommand(t *testing.T) {\n\ttemplates := []struct{ name, template string }{\n\t\t{\"default\", DefaultUsageTemplate},\n\t\t{\"Compact\", CompactUsageTemplate},\n\t\t{\"Long\", LongHelpTemplate},\n\t\t{\"Man\", ManPageTemplate},\n\t}\n\n\tvar buf bytes.Buffer\n\tt.Log(\"1\")\n\n\ta := New(\"test\", \"Test\").Writer(&buf).Terminate(nil)\n\ta.Command(\"visible\", \"visible\")\n\ta.Command(\"hidden\", \"hidden\").Hidden()\n\n\tfor _, tp := range templates {\n\t\tbuf.Reset()\n\t\ta.UsageTemplate(tp.template)\n\t\ta.Parse(nil)\n\t\t// a.Parse([]string{\"--help\"})\n\t\tusage := buf.String()\n\t\tt.Logf(\"Usage for %s is:\\n%s\\n\", tp.name, usage)\n\n\t\tassert.NotContains(t, usage, \"hidden\")\n\t\tassert.Contains(t, usage, \"visible\")\n\t}\n}\n\nfunc TestUsageFuncs(t *testing.T) {\n\tvar buf bytes.Buffer\n\ta := New(\"test\", \"Test\").Writer(&buf).Terminate(nil)\n\ttpl := `{{ add 2 1 }}`\n\ta.UsageTemplate(tpl)\n\ta.UsageFuncs(template.FuncMap{\n\t\t\"add\": func(x, y int) int { return x + y },\n\t})\n\ta.Parse([]string{\"--help\"})\n\tusage := buf.String()\n\tassert.Equal(t, \"3\", usage)\n}\n\nfunc TestCmdClause_HelpLong(t *testing.T) {\n\tvar buf bytes.Buffer\n\ttpl := `{{define \"FormatUsage\"}}{{.HelpLong}}{{end -}}\n{{template \"FormatUsage\" .Context.SelectedCommand}}`\n\n\ta := New(\"test\", \"Test\").Writer(&buf).Terminate(nil)\n\ta.UsageTemplate(tpl)\n\ta.Command(\"command\", \"short help text\").HelpLong(\"long help text\")\n\n\ta.Parse([]string{\"command\", \"--help\"})\n\tusage := buf.String()\n\tassert.Equal(t, \"long help text\", usage)\n}\n\nfunc TestArgEnvVar(t *testing.T) {\n\tvar buf bytes.Buffer\n\n\ta := New(\"test\", \"Test\").Writer(&buf).Terminate(nil)\n\ta.Arg(\"arg\", \"Enable arg\").Envar(\"ARG\").String()\n\ta.Flag(\"flag\", \"Enable flag\").Envar(\"FLAG\").String()\n\n\ta.Parse([]string{\"command\", \"--help\"})\n\tusage := buf.String()\n\tassert.Contains(t, usage, \"($ARG)\")\n\tassert.Contains(t, usage, \"($FLAG)\")\n}\n"
        },
        {
          "name": "values.go",
          "type": "blob",
          "size": 10.294921875,
          "content": "package kingpin\n\n//go:generate go run ./cmd/genvalues/main.go\n\nimport (\n\t\"encoding\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/alecthomas/units\"\n\t\"github.com/xhit/go-str2duration/v2\"\n)\n\n// NOTE: Most of the base type values were lifted from:\n// http://golang.org/src/pkg/flag/flag.go?s=20146:20222\n\n// Value is the interface to the dynamic value stored in a flag.\n// (The default value is represented as a string.)\n//\n// If a Value has an IsBoolFlag() bool method returning true, the command-line\n// parser makes --name equivalent to -name=true rather than using the next\n// command-line argument, and adds a --no-name counterpart for negating the\n// flag.\ntype Value interface {\n\tString() string\n\tSet(string) error\n}\n\n// Getter is an interface that allows the contents of a Value to be retrieved.\n// It wraps the Value interface, rather than being part of it, because it\n// appeared after Go 1 and its compatibility rules. All Value types provided\n// by this package satisfy the Getter interface.\ntype Getter interface {\n\tValue\n\tGet() interface{}\n}\n\n// Optional interface to indicate boolean flags that don't accept a value, and\n// implicitly have a --no-<x> negation counterpart.\ntype boolFlag interface {\n\tIsBoolFlag() bool\n}\n\n// Optional interface for arguments that cumulatively consume all remaining\n// input.\ntype remainderArg interface {\n\tIsCumulative() bool\n}\n\n// Optional interface for flags that can be repeated.\ntype repeatableFlag interface {\n\tIsCumulative() bool\n}\n\n// Text is the interface to the dynamic value stored in a flag.\n// (The default value is represented as a string.)\ntype Text interface {\n\tencoding.TextMarshaler\n\tencoding.TextUnmarshaler\n}\n\ntype wrapText struct {\n\ttext Text\n}\n\nfunc (w wrapText) String() string {\n\tbuf, _ := w.text.MarshalText()\n\treturn string(buf)\n}\n\nfunc (w *wrapText) Set(s string) error {\n\treturn w.text.UnmarshalText([]byte(s))\n}\n\ntype accumulator struct {\n\telement func(value interface{}) Value\n\ttyp     reflect.Type\n\tslice   reflect.Value\n}\n\n// Use reflection to accumulate values into a slice.\n//\n// target := []string{}\n// newAccumulator(&target, func (value interface{}) Value {\n//   return newStringValue(value.(*string))\n// })\nfunc newAccumulator(slice interface{}, element func(value interface{}) Value) *accumulator {\n\ttyp := reflect.TypeOf(slice)\n\tif typ.Kind() != reflect.Ptr || typ.Elem().Kind() != reflect.Slice {\n\t\tpanic(\"expected a pointer to a slice\")\n\t}\n\treturn &accumulator{\n\t\telement: element,\n\t\ttyp:     typ.Elem().Elem(),\n\t\tslice:   reflect.ValueOf(slice),\n\t}\n}\n\nfunc (a *accumulator) String() string {\n\tout := []string{}\n\ts := a.slice.Elem()\n\tfor i := 0; i < s.Len(); i++ {\n\t\tout = append(out, a.element(s.Index(i).Addr().Interface()).String())\n\t}\n\treturn strings.Join(out, \",\")\n}\n\nfunc (a *accumulator) Set(value string) error {\n\te := reflect.New(a.typ)\n\tif err := a.element(e.Interface()).Set(value); err != nil {\n\t\treturn err\n\t}\n\tslice := reflect.Append(a.slice.Elem(), e.Elem())\n\ta.slice.Elem().Set(slice)\n\treturn nil\n}\n\nfunc (a *accumulator) Get() interface{} {\n\treturn a.slice.Interface()\n}\n\nfunc (a *accumulator) IsCumulative() bool {\n\treturn true\n}\n\nfunc (b *boolValue) IsBoolFlag() bool { return true }\n\n// -- time.Duration Value\ntype durationValue time.Duration\n\nfunc newDurationValue(p *time.Duration) *durationValue {\n\treturn (*durationValue)(p)\n}\n\nfunc (d *durationValue) Set(s string) error {\n\tv, err := str2duration.ParseDuration(s)\n\t*d = durationValue(v)\n\treturn err\n}\n\nfunc (d *durationValue) Get() interface{} { return time.Duration(*d) }\n\nfunc (d *durationValue) String() string { return (*time.Duration)(d).String() }\n\n// -- map[string]string Value\ntype stringMapValue map[string]string\n\nfunc newStringMapValue(p *map[string]string) *stringMapValue {\n\treturn (*stringMapValue)(p)\n}\n\nvar stringMapRegex = regexp.MustCompile(\"[:=]\")\n\nfunc (s *stringMapValue) Set(value string) error {\n\tparts := stringMapRegex.Split(value, 2)\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"expected KEY=VALUE got '%s'\", value)\n\t}\n\t(*s)[parts[0]] = parts[1]\n\treturn nil\n}\n\nfunc (s *stringMapValue) Get() interface{} {\n\treturn (map[string]string)(*s)\n}\n\nfunc (s *stringMapValue) String() string {\n\treturn fmt.Sprintf(\"%s\", map[string]string(*s))\n}\n\nfunc (s *stringMapValue) IsCumulative() bool {\n\treturn true\n}\n\n// -- net.IP Value\ntype ipValue net.IP\n\nfunc newIPValue(p *net.IP) *ipValue {\n\treturn (*ipValue)(p)\n}\n\nfunc (i *ipValue) Set(value string) error {\n\tif ip := net.ParseIP(value); ip == nil {\n\t\treturn fmt.Errorf(\"'%s' is not an IP address\", value)\n\t} else {\n\t\t*i = *(*ipValue)(&ip)\n\t\treturn nil\n\t}\n}\n\nfunc (i *ipValue) Get() interface{} {\n\treturn (net.IP)(*i)\n}\n\nfunc (i *ipValue) String() string {\n\treturn (*net.IP)(i).String()\n}\n\n// -- *net.TCPAddr Value\ntype tcpAddrValue struct {\n\taddr **net.TCPAddr\n}\n\nfunc newTCPAddrValue(p **net.TCPAddr) *tcpAddrValue {\n\treturn &tcpAddrValue{p}\n}\n\nfunc (i *tcpAddrValue) Set(value string) error {\n\tif addr, err := net.ResolveTCPAddr(\"tcp\", value); err != nil {\n\t\treturn fmt.Errorf(\"'%s' is not a valid TCP address: %s\", value, err)\n\t} else {\n\t\t*i.addr = addr\n\t\treturn nil\n\t}\n}\n\nfunc (t *tcpAddrValue) Get() interface{} {\n\treturn (*net.TCPAddr)(*t.addr)\n}\n\nfunc (i *tcpAddrValue) String() string {\n\treturn (*i.addr).String()\n}\n\n// -- existingFile Value\n\ntype fileStatValue struct {\n\tpath      *string\n\tpredicate func(os.FileInfo) error\n}\n\nfunc newFileStatValue(p *string, predicate func(os.FileInfo) error) *fileStatValue {\n\treturn &fileStatValue{\n\t\tpath:      p,\n\t\tpredicate: predicate,\n\t}\n}\n\nfunc (e *fileStatValue) Set(value string) error {\n\tif s, err := os.Stat(value); os.IsNotExist(err) {\n\t\treturn fmt.Errorf(\"path '%s' does not exist\", value)\n\t} else if err != nil {\n\t\treturn err\n\t} else if err := e.predicate(s); err != nil {\n\t\treturn err\n\t}\n\t*e.path = value\n\treturn nil\n}\n\nfunc (f *fileStatValue) Get() interface{} {\n\treturn (string)(*f.path)\n}\n\nfunc (e *fileStatValue) String() string {\n\treturn *e.path\n}\n\n// -- os.File value\n\ntype fileValue struct {\n\tf    **os.File\n\tflag int\n\tperm os.FileMode\n}\n\nfunc newFileValue(p **os.File, flag int, perm os.FileMode) *fileValue {\n\treturn &fileValue{p, flag, perm}\n}\n\nfunc (f *fileValue) Set(value string) error {\n\tif fd, err := os.OpenFile(value, f.flag, f.perm); err != nil {\n\t\treturn err\n\t} else {\n\t\t*f.f = fd\n\t\treturn nil\n\t}\n}\n\nfunc (f *fileValue) Get() interface{} {\n\treturn (*os.File)(*f.f)\n}\n\nfunc (f *fileValue) String() string {\n\tif *f.f == nil {\n\t\treturn \"<nil>\"\n\t}\n\treturn (*f.f).Name()\n}\n\n// -- url.URL Value\ntype urlValue struct {\n\tu **url.URL\n}\n\nfunc newURLValue(p **url.URL) *urlValue {\n\treturn &urlValue{p}\n}\n\nfunc (u *urlValue) Set(value string) error {\n\tif url, err := url.Parse(value); err != nil {\n\t\treturn fmt.Errorf(\"invalid URL: %s\", err)\n\t} else {\n\t\t*u.u = url\n\t\treturn nil\n\t}\n}\n\nfunc (u *urlValue) Get() interface{} {\n\treturn (*url.URL)(*u.u)\n}\n\nfunc (u *urlValue) String() string {\n\tif *u.u == nil {\n\t\treturn \"<nil>\"\n\t}\n\treturn (*u.u).String()\n}\n\n// -- []*url.URL Value\ntype urlListValue []*url.URL\n\nfunc newURLListValue(p *[]*url.URL) *urlListValue {\n\treturn (*urlListValue)(p)\n}\n\nfunc (u *urlListValue) Set(value string) error {\n\tif url, err := url.Parse(value); err != nil {\n\t\treturn fmt.Errorf(\"invalid URL: %s\", err)\n\t} else {\n\t\t*u = append(*u, url)\n\t\treturn nil\n\t}\n}\n\nfunc (u *urlListValue) Get() interface{} {\n\treturn ([]*url.URL)(*u)\n}\n\nfunc (u *urlListValue) String() string {\n\tout := []string{}\n\tfor _, url := range *u {\n\t\tout = append(out, url.String())\n\t}\n\treturn strings.Join(out, \",\")\n}\n\nfunc (u *urlListValue) IsCumulative() bool {\n\treturn true\n}\n\n// A flag whose value must be in a set of options.\ntype enumValue struct {\n\tvalue   *string\n\toptions []string\n}\n\nfunc newEnumFlag(target *string, options ...string) *enumValue {\n\treturn &enumValue{\n\t\tvalue:   target,\n\t\toptions: options,\n\t}\n}\n\nfunc (a *enumValue) String() string {\n\treturn *a.value\n}\n\nfunc (a *enumValue) Set(value string) error {\n\tfor _, v := range a.options {\n\t\tif v == value {\n\t\t\t*a.value = value\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"enum value must be one of %s, got '%s'\", strings.Join(a.options, \",\"), value)\n}\n\nfunc (e *enumValue) Get() interface{} {\n\treturn (string)(*e.value)\n}\n\n// -- []string Enum Value\ntype enumsValue struct {\n\tvalue   *[]string\n\toptions []string\n}\n\nfunc newEnumsFlag(target *[]string, options ...string) *enumsValue {\n\treturn &enumsValue{\n\t\tvalue:   target,\n\t\toptions: options,\n\t}\n}\n\nfunc (s *enumsValue) Set(value string) error {\n\tfor _, v := range s.options {\n\t\tif v == value {\n\t\t\t*s.value = append(*s.value, value)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn fmt.Errorf(\"enum value must be one of %s, got '%s'\", strings.Join(s.options, \",\"), value)\n}\n\nfunc (e *enumsValue) Get() interface{} {\n\treturn ([]string)(*e.value)\n}\n\nfunc (s *enumsValue) String() string {\n\treturn strings.Join(*s.value, \",\")\n}\n\nfunc (s *enumsValue) IsCumulative() bool {\n\treturn true\n}\n\n// -- units.Base2Bytes Value\ntype bytesValue units.Base2Bytes\n\nfunc newBytesValue(p *units.Base2Bytes) *bytesValue {\n\treturn (*bytesValue)(p)\n}\n\nfunc (d *bytesValue) Set(s string) error {\n\tv, err := units.ParseBase2Bytes(s)\n\t*d = bytesValue(v)\n\treturn err\n}\n\nfunc (d *bytesValue) Get() interface{} { return units.Base2Bytes(*d) }\n\nfunc (d *bytesValue) String() string { return (*units.Base2Bytes)(d).String() }\n\nfunc newExistingFileValue(target *string) *fileStatValue {\n\treturn newFileStatValue(target, func(s os.FileInfo) error {\n\t\tif s.IsDir() {\n\t\t\treturn fmt.Errorf(\"'%s' is a directory\", s.Name())\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc newExistingDirValue(target *string) *fileStatValue {\n\treturn newFileStatValue(target, func(s os.FileInfo) error {\n\t\tif !s.IsDir() {\n\t\t\treturn fmt.Errorf(\"'%s' is a file\", s.Name())\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc newExistingFileOrDirValue(target *string) *fileStatValue {\n\treturn newFileStatValue(target, func(s os.FileInfo) error { return nil })\n}\n\ntype counterValue int\n\nfunc newCounterValue(n *int) *counterValue {\n\treturn (*counterValue)(n)\n}\n\nfunc (c *counterValue) Set(s string) error {\n\t*c++\n\treturn nil\n}\n\nfunc (c *counterValue) Get() interface{}   { return (int)(*c) }\nfunc (c *counterValue) IsBoolFlag() bool   { return true }\nfunc (c *counterValue) String() string     { return fmt.Sprintf(\"%d\", *c) }\nfunc (c *counterValue) IsCumulative() bool { return true }\n\nfunc resolveHost(value string) (net.IP, error) {\n\tif ip := net.ParseIP(value); ip != nil {\n\t\treturn ip, nil\n\t} else {\n\t\tif addr, err := net.ResolveIPAddr(\"ip\", value); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\treturn addr.IP, nil\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "values.json",
          "type": "blob",
          "size": 1.720703125,
          "content": "[\n  {\"type\": \"bool\", \"parser\": \"strconv.ParseBool(s)\"},\n  {\"type\": \"string\", \"parser\": \"s, error(nil)\", \"format\": \"string(*f.v)\", \"plural\": \"Strings\"},\n  {\"type\": \"uint\", \"parser\": \"strconv.ParseUint(s, 0, 64)\", \"plural\": \"Uints\"},\n  {\"type\": \"uint8\", \"parser\": \"strconv.ParseUint(s, 0, 8)\"},\n  {\"type\": \"uint16\", \"parser\": \"strconv.ParseUint(s, 0, 16)\"},\n  {\"type\": \"uint32\", \"parser\": \"strconv.ParseUint(s, 0, 32)\"},\n  {\"type\": \"uint64\", \"parser\": \"strconv.ParseUint(s, 0, 64)\"},\n  {\"type\": \"int\", \"parser\": \"strconv.ParseFloat(s, 64)\", \"plural\": \"Ints\"},\n  {\"type\": \"int8\", \"parser\": \"strconv.ParseInt(s, 0, 8)\"},\n  {\"type\": \"int16\", \"parser\": \"strconv.ParseInt(s, 0, 16)\"},\n  {\"type\": \"int32\", \"parser\": \"strconv.ParseInt(s, 0, 32)\"},\n  {\"type\": \"int64\", \"parser\": \"strconv.ParseInt(s, 0, 64)\"},\n  {\"type\": \"float64\", \"parser\": \"strconv.ParseFloat(s, 64)\"},\n  {\"type\": \"float32\", \"parser\": \"strconv.ParseFloat(s, 32)\"},\n  {\"name\": \"Duration\", \"type\": \"time.Duration\", \"no_value_parser\": true},\n  {\"name\": \"IP\", \"type\": \"net.IP\", \"no_value_parser\": true},\n  {\"name\": \"TCPAddr\", \"Type\": \"*net.TCPAddr\", \"plural\": \"TCPList\", \"no_value_parser\": true},\n  {\"name\": \"ExistingFile\", \"Type\": \"string\", \"plural\": \"ExistingFiles\", \"no_value_parser\": true},\n  {\"name\": \"ExistingDir\", \"Type\": \"string\", \"plural\": \"ExistingDirs\", \"no_value_parser\": true},\n  {\"name\": \"ExistingFileOrDir\", \"Type\": \"string\", \"plural\": \"ExistingFilesOrDirs\", \"no_value_parser\": true},\n  {\"name\": \"Regexp\", \"Type\": \"*regexp.Regexp\", \"parser\": \"regexp.Compile(s)\"},\n  {\"name\": \"ResolvedIP\", \"Type\": \"net.IP\", \"parser\": \"resolveHost(s)\", \"help\": \"Resolve a hostname or IP to an IP.\"},\n  {\"name\": \"HexBytes\", \"Type\": \"[]byte\", \"parser\": \"hex.DecodeString(s)\", \"help\": \"Bytes as a hex string.\"}\n]\n"
        },
        {
          "name": "values_generated.go",
          "type": "blob",
          "size": 18.42578125,
          "content": "package kingpin\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"net\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// This file is autogenerated by \"go generate .\". Do not modify.\n\n// -- bool Value\ntype boolValue struct{ v *bool }\n\nfunc newBoolValue(p *bool) *boolValue {\n\treturn &boolValue{p}\n}\n\nfunc (f *boolValue) Set(s string) error {\n\tv, err := strconv.ParseBool(s)\n\tif err == nil {\n\t\t*f.v = (bool)(v)\n\t}\n\treturn err\n}\n\nfunc (f *boolValue) Get() interface{} { return (bool)(*f.v) }\n\nfunc (f *boolValue) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Bool parses the next command-line value as bool.\nfunc (p *parserMixin) Bool() (target *bool) {\n\ttarget = new(bool)\n\tp.BoolVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) BoolVar(target *bool) {\n\tp.SetValue(newBoolValue(target))\n}\n\n// BoolList accumulates bool values into a slice.\nfunc (p *parserMixin) BoolList() (target *[]bool) {\n\ttarget = new([]bool)\n\tp.BoolListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) BoolListVar(target *[]bool) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newBoolValue(v.(*bool))\n\t}))\n}\n\n// -- string Value\ntype stringValue struct{ v *string }\n\nfunc newStringValue(p *string) *stringValue {\n\treturn &stringValue{p}\n}\n\nfunc (f *stringValue) Set(s string) error {\n\tv, err := s, error(nil)\n\tif err == nil {\n\t\t*f.v = (string)(v)\n\t}\n\treturn err\n}\n\nfunc (f *stringValue) Get() interface{} { return (string)(*f.v) }\n\nfunc (f *stringValue) String() string { return string(*f.v) }\n\n// String parses the next command-line value as string.\nfunc (p *parserMixin) String() (target *string) {\n\ttarget = new(string)\n\tp.StringVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) StringVar(target *string) {\n\tp.SetValue(newStringValue(target))\n}\n\n// Strings accumulates string values into a slice.\nfunc (p *parserMixin) Strings() (target *[]string) {\n\ttarget = new([]string)\n\tp.StringsVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) StringsVar(target *[]string) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newStringValue(v.(*string))\n\t}))\n}\n\n// -- uint Value\ntype uintValue struct{ v *uint }\n\nfunc newUintValue(p *uint) *uintValue {\n\treturn &uintValue{p}\n}\n\nfunc (f *uintValue) Set(s string) error {\n\tv, err := strconv.ParseUint(s, 0, 64)\n\tif err == nil {\n\t\t*f.v = (uint)(v)\n\t}\n\treturn err\n}\n\nfunc (f *uintValue) Get() interface{} { return (uint)(*f.v) }\n\nfunc (f *uintValue) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Uint parses the next command-line value as uint.\nfunc (p *parserMixin) Uint() (target *uint) {\n\ttarget = new(uint)\n\tp.UintVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) UintVar(target *uint) {\n\tp.SetValue(newUintValue(target))\n}\n\n// Uints accumulates uint values into a slice.\nfunc (p *parserMixin) Uints() (target *[]uint) {\n\ttarget = new([]uint)\n\tp.UintsVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) UintsVar(target *[]uint) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newUintValue(v.(*uint))\n\t}))\n}\n\n// -- uint8 Value\ntype uint8Value struct{ v *uint8 }\n\nfunc newUint8Value(p *uint8) *uint8Value {\n\treturn &uint8Value{p}\n}\n\nfunc (f *uint8Value) Set(s string) error {\n\tv, err := strconv.ParseUint(s, 0, 8)\n\tif err == nil {\n\t\t*f.v = (uint8)(v)\n\t}\n\treturn err\n}\n\nfunc (f *uint8Value) Get() interface{} { return (uint8)(*f.v) }\n\nfunc (f *uint8Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Uint8 parses the next command-line value as uint8.\nfunc (p *parserMixin) Uint8() (target *uint8) {\n\ttarget = new(uint8)\n\tp.Uint8Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint8Var(target *uint8) {\n\tp.SetValue(newUint8Value(target))\n}\n\n// Uint8List accumulates uint8 values into a slice.\nfunc (p *parserMixin) Uint8List() (target *[]uint8) {\n\ttarget = new([]uint8)\n\tp.Uint8ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint8ListVar(target *[]uint8) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newUint8Value(v.(*uint8))\n\t}))\n}\n\n// -- uint16 Value\ntype uint16Value struct{ v *uint16 }\n\nfunc newUint16Value(p *uint16) *uint16Value {\n\treturn &uint16Value{p}\n}\n\nfunc (f *uint16Value) Set(s string) error {\n\tv, err := strconv.ParseUint(s, 0, 16)\n\tif err == nil {\n\t\t*f.v = (uint16)(v)\n\t}\n\treturn err\n}\n\nfunc (f *uint16Value) Get() interface{} { return (uint16)(*f.v) }\n\nfunc (f *uint16Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Uint16 parses the next command-line value as uint16.\nfunc (p *parserMixin) Uint16() (target *uint16) {\n\ttarget = new(uint16)\n\tp.Uint16Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint16Var(target *uint16) {\n\tp.SetValue(newUint16Value(target))\n}\n\n// Uint16List accumulates uint16 values into a slice.\nfunc (p *parserMixin) Uint16List() (target *[]uint16) {\n\ttarget = new([]uint16)\n\tp.Uint16ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint16ListVar(target *[]uint16) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newUint16Value(v.(*uint16))\n\t}))\n}\n\n// -- uint32 Value\ntype uint32Value struct{ v *uint32 }\n\nfunc newUint32Value(p *uint32) *uint32Value {\n\treturn &uint32Value{p}\n}\n\nfunc (f *uint32Value) Set(s string) error {\n\tv, err := strconv.ParseUint(s, 0, 32)\n\tif err == nil {\n\t\t*f.v = (uint32)(v)\n\t}\n\treturn err\n}\n\nfunc (f *uint32Value) Get() interface{} { return (uint32)(*f.v) }\n\nfunc (f *uint32Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Uint32 parses the next command-line value as uint32.\nfunc (p *parserMixin) Uint32() (target *uint32) {\n\ttarget = new(uint32)\n\tp.Uint32Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint32Var(target *uint32) {\n\tp.SetValue(newUint32Value(target))\n}\n\n// Uint32List accumulates uint32 values into a slice.\nfunc (p *parserMixin) Uint32List() (target *[]uint32) {\n\ttarget = new([]uint32)\n\tp.Uint32ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint32ListVar(target *[]uint32) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newUint32Value(v.(*uint32))\n\t}))\n}\n\n// -- uint64 Value\ntype uint64Value struct{ v *uint64 }\n\nfunc newUint64Value(p *uint64) *uint64Value {\n\treturn &uint64Value{p}\n}\n\nfunc (f *uint64Value) Set(s string) error {\n\tv, err := strconv.ParseUint(s, 0, 64)\n\tif err == nil {\n\t\t*f.v = (uint64)(v)\n\t}\n\treturn err\n}\n\nfunc (f *uint64Value) Get() interface{} { return (uint64)(*f.v) }\n\nfunc (f *uint64Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Uint64 parses the next command-line value as uint64.\nfunc (p *parserMixin) Uint64() (target *uint64) {\n\ttarget = new(uint64)\n\tp.Uint64Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint64Var(target *uint64) {\n\tp.SetValue(newUint64Value(target))\n}\n\n// Uint64List accumulates uint64 values into a slice.\nfunc (p *parserMixin) Uint64List() (target *[]uint64) {\n\ttarget = new([]uint64)\n\tp.Uint64ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Uint64ListVar(target *[]uint64) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newUint64Value(v.(*uint64))\n\t}))\n}\n\n// -- int Value\ntype intValue struct{ v *int }\n\nfunc newIntValue(p *int) *intValue {\n\treturn &intValue{p}\n}\n\nfunc (f *intValue) Set(s string) error {\n\tv, err := strconv.ParseFloat(s, 64)\n\tif err == nil {\n\t\t*f.v = (int)(v)\n\t}\n\treturn err\n}\n\nfunc (f *intValue) Get() interface{} { return (int)(*f.v) }\n\nfunc (f *intValue) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Int parses the next command-line value as int.\nfunc (p *parserMixin) Int() (target *int) {\n\ttarget = new(int)\n\tp.IntVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) IntVar(target *int) {\n\tp.SetValue(newIntValue(target))\n}\n\n// Ints accumulates int values into a slice.\nfunc (p *parserMixin) Ints() (target *[]int) {\n\ttarget = new([]int)\n\tp.IntsVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) IntsVar(target *[]int) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newIntValue(v.(*int))\n\t}))\n}\n\n// -- int8 Value\ntype int8Value struct{ v *int8 }\n\nfunc newInt8Value(p *int8) *int8Value {\n\treturn &int8Value{p}\n}\n\nfunc (f *int8Value) Set(s string) error {\n\tv, err := strconv.ParseInt(s, 0, 8)\n\tif err == nil {\n\t\t*f.v = (int8)(v)\n\t}\n\treturn err\n}\n\nfunc (f *int8Value) Get() interface{} { return (int8)(*f.v) }\n\nfunc (f *int8Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Int8 parses the next command-line value as int8.\nfunc (p *parserMixin) Int8() (target *int8) {\n\ttarget = new(int8)\n\tp.Int8Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int8Var(target *int8) {\n\tp.SetValue(newInt8Value(target))\n}\n\n// Int8List accumulates int8 values into a slice.\nfunc (p *parserMixin) Int8List() (target *[]int8) {\n\ttarget = new([]int8)\n\tp.Int8ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int8ListVar(target *[]int8) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newInt8Value(v.(*int8))\n\t}))\n}\n\n// -- int16 Value\ntype int16Value struct{ v *int16 }\n\nfunc newInt16Value(p *int16) *int16Value {\n\treturn &int16Value{p}\n}\n\nfunc (f *int16Value) Set(s string) error {\n\tv, err := strconv.ParseInt(s, 0, 16)\n\tif err == nil {\n\t\t*f.v = (int16)(v)\n\t}\n\treturn err\n}\n\nfunc (f *int16Value) Get() interface{} { return (int16)(*f.v) }\n\nfunc (f *int16Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Int16 parses the next command-line value as int16.\nfunc (p *parserMixin) Int16() (target *int16) {\n\ttarget = new(int16)\n\tp.Int16Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int16Var(target *int16) {\n\tp.SetValue(newInt16Value(target))\n}\n\n// Int16List accumulates int16 values into a slice.\nfunc (p *parserMixin) Int16List() (target *[]int16) {\n\ttarget = new([]int16)\n\tp.Int16ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int16ListVar(target *[]int16) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newInt16Value(v.(*int16))\n\t}))\n}\n\n// -- int32 Value\ntype int32Value struct{ v *int32 }\n\nfunc newInt32Value(p *int32) *int32Value {\n\treturn &int32Value{p}\n}\n\nfunc (f *int32Value) Set(s string) error {\n\tv, err := strconv.ParseInt(s, 0, 32)\n\tif err == nil {\n\t\t*f.v = (int32)(v)\n\t}\n\treturn err\n}\n\nfunc (f *int32Value) Get() interface{} { return (int32)(*f.v) }\n\nfunc (f *int32Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Int32 parses the next command-line value as int32.\nfunc (p *parserMixin) Int32() (target *int32) {\n\ttarget = new(int32)\n\tp.Int32Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int32Var(target *int32) {\n\tp.SetValue(newInt32Value(target))\n}\n\n// Int32List accumulates int32 values into a slice.\nfunc (p *parserMixin) Int32List() (target *[]int32) {\n\ttarget = new([]int32)\n\tp.Int32ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int32ListVar(target *[]int32) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newInt32Value(v.(*int32))\n\t}))\n}\n\n// -- int64 Value\ntype int64Value struct{ v *int64 }\n\nfunc newInt64Value(p *int64) *int64Value {\n\treturn &int64Value{p}\n}\n\nfunc (f *int64Value) Set(s string) error {\n\tv, err := strconv.ParseInt(s, 0, 64)\n\tif err == nil {\n\t\t*f.v = (int64)(v)\n\t}\n\treturn err\n}\n\nfunc (f *int64Value) Get() interface{} { return (int64)(*f.v) }\n\nfunc (f *int64Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Int64 parses the next command-line value as int64.\nfunc (p *parserMixin) Int64() (target *int64) {\n\ttarget = new(int64)\n\tp.Int64Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int64Var(target *int64) {\n\tp.SetValue(newInt64Value(target))\n}\n\n// Int64List accumulates int64 values into a slice.\nfunc (p *parserMixin) Int64List() (target *[]int64) {\n\ttarget = new([]int64)\n\tp.Int64ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Int64ListVar(target *[]int64) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newInt64Value(v.(*int64))\n\t}))\n}\n\n// -- float64 Value\ntype float64Value struct{ v *float64 }\n\nfunc newFloat64Value(p *float64) *float64Value {\n\treturn &float64Value{p}\n}\n\nfunc (f *float64Value) Set(s string) error {\n\tv, err := strconv.ParseFloat(s, 64)\n\tif err == nil {\n\t\t*f.v = (float64)(v)\n\t}\n\treturn err\n}\n\nfunc (f *float64Value) Get() interface{} { return (float64)(*f.v) }\n\nfunc (f *float64Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Float64 parses the next command-line value as float64.\nfunc (p *parserMixin) Float64() (target *float64) {\n\ttarget = new(float64)\n\tp.Float64Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Float64Var(target *float64) {\n\tp.SetValue(newFloat64Value(target))\n}\n\n// Float64List accumulates float64 values into a slice.\nfunc (p *parserMixin) Float64List() (target *[]float64) {\n\ttarget = new([]float64)\n\tp.Float64ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Float64ListVar(target *[]float64) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newFloat64Value(v.(*float64))\n\t}))\n}\n\n// -- float32 Value\ntype float32Value struct{ v *float32 }\n\nfunc newFloat32Value(p *float32) *float32Value {\n\treturn &float32Value{p}\n}\n\nfunc (f *float32Value) Set(s string) error {\n\tv, err := strconv.ParseFloat(s, 32)\n\tif err == nil {\n\t\t*f.v = (float32)(v)\n\t}\n\treturn err\n}\n\nfunc (f *float32Value) Get() interface{} { return (float32)(*f.v) }\n\nfunc (f *float32Value) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Float32 parses the next command-line value as float32.\nfunc (p *parserMixin) Float32() (target *float32) {\n\ttarget = new(float32)\n\tp.Float32Var(target)\n\treturn\n}\n\nfunc (p *parserMixin) Float32Var(target *float32) {\n\tp.SetValue(newFloat32Value(target))\n}\n\n// Float32List accumulates float32 values into a slice.\nfunc (p *parserMixin) Float32List() (target *[]float32) {\n\ttarget = new([]float32)\n\tp.Float32ListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) Float32ListVar(target *[]float32) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newFloat32Value(v.(*float32))\n\t}))\n}\n\n// DurationList accumulates time.Duration values into a slice.\nfunc (p *parserMixin) DurationList() (target *[]time.Duration) {\n\ttarget = new([]time.Duration)\n\tp.DurationListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) DurationListVar(target *[]time.Duration) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newDurationValue(v.(*time.Duration))\n\t}))\n}\n\n// IPList accumulates net.IP values into a slice.\nfunc (p *parserMixin) IPList() (target *[]net.IP) {\n\ttarget = new([]net.IP)\n\tp.IPListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) IPListVar(target *[]net.IP) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newIPValue(v.(*net.IP))\n\t}))\n}\n\n// TCPList accumulates *net.TCPAddr values into a slice.\nfunc (p *parserMixin) TCPList() (target *[]*net.TCPAddr) {\n\ttarget = new([]*net.TCPAddr)\n\tp.TCPListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) TCPListVar(target *[]*net.TCPAddr) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newTCPAddrValue(v.(**net.TCPAddr))\n\t}))\n}\n\n// ExistingFiles accumulates string values into a slice.\nfunc (p *parserMixin) ExistingFiles() (target *[]string) {\n\ttarget = new([]string)\n\tp.ExistingFilesVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) ExistingFilesVar(target *[]string) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newExistingFileValue(v.(*string))\n\t}))\n}\n\n// ExistingDirs accumulates string values into a slice.\nfunc (p *parserMixin) ExistingDirs() (target *[]string) {\n\ttarget = new([]string)\n\tp.ExistingDirsVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) ExistingDirsVar(target *[]string) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newExistingDirValue(v.(*string))\n\t}))\n}\n\n// ExistingFilesOrDirs accumulates string values into a slice.\nfunc (p *parserMixin) ExistingFilesOrDirs() (target *[]string) {\n\ttarget = new([]string)\n\tp.ExistingFilesOrDirsVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) ExistingFilesOrDirsVar(target *[]string) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newExistingFileOrDirValue(v.(*string))\n\t}))\n}\n\n// -- *regexp.Regexp Value\ntype regexpValue struct{ v **regexp.Regexp }\n\nfunc newRegexpValue(p **regexp.Regexp) *regexpValue {\n\treturn &regexpValue{p}\n}\n\nfunc (f *regexpValue) Set(s string) error {\n\tv, err := regexp.Compile(s)\n\tif err == nil {\n\t\t*f.v = (*regexp.Regexp)(v)\n\t}\n\treturn err\n}\n\nfunc (f *regexpValue) Get() interface{} { return (*regexp.Regexp)(*f.v) }\n\nfunc (f *regexpValue) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Regexp parses the next command-line value as *regexp.Regexp.\nfunc (p *parserMixin) Regexp() (target **regexp.Regexp) {\n\ttarget = new(*regexp.Regexp)\n\tp.RegexpVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) RegexpVar(target **regexp.Regexp) {\n\tp.SetValue(newRegexpValue(target))\n}\n\n// RegexpList accumulates *regexp.Regexp values into a slice.\nfunc (p *parserMixin) RegexpList() (target *[]*regexp.Regexp) {\n\ttarget = new([]*regexp.Regexp)\n\tp.RegexpListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) RegexpListVar(target *[]*regexp.Regexp) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newRegexpValue(v.(**regexp.Regexp))\n\t}))\n}\n\n// -- net.IP Value\ntype resolvedIPValue struct{ v *net.IP }\n\nfunc newResolvedIPValue(p *net.IP) *resolvedIPValue {\n\treturn &resolvedIPValue{p}\n}\n\nfunc (f *resolvedIPValue) Set(s string) error {\n\tv, err := resolveHost(s)\n\tif err == nil {\n\t\t*f.v = (net.IP)(v)\n\t}\n\treturn err\n}\n\nfunc (f *resolvedIPValue) Get() interface{} { return (net.IP)(*f.v) }\n\nfunc (f *resolvedIPValue) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Resolve a hostname or IP to an IP.\nfunc (p *parserMixin) ResolvedIP() (target *net.IP) {\n\ttarget = new(net.IP)\n\tp.ResolvedIPVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) ResolvedIPVar(target *net.IP) {\n\tp.SetValue(newResolvedIPValue(target))\n}\n\n// ResolvedIPList accumulates net.IP values into a slice.\nfunc (p *parserMixin) ResolvedIPList() (target *[]net.IP) {\n\ttarget = new([]net.IP)\n\tp.ResolvedIPListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) ResolvedIPListVar(target *[]net.IP) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newResolvedIPValue(v.(*net.IP))\n\t}))\n}\n\n// -- []byte Value\ntype hexBytesValue struct{ v *[]byte }\n\nfunc newHexBytesValue(p *[]byte) *hexBytesValue {\n\treturn &hexBytesValue{p}\n}\n\nfunc (f *hexBytesValue) Set(s string) error {\n\tv, err := hex.DecodeString(s)\n\tif err == nil {\n\t\t*f.v = ([]byte)(v)\n\t}\n\treturn err\n}\n\nfunc (f *hexBytesValue) Get() interface{} { return ([]byte)(*f.v) }\n\nfunc (f *hexBytesValue) String() string { return fmt.Sprintf(\"%v\", *f.v) }\n\n// Bytes as a hex string.\nfunc (p *parserMixin) HexBytes() (target *[]byte) {\n\ttarget = new([]byte)\n\tp.HexBytesVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) HexBytesVar(target *[]byte) {\n\tp.SetValue(newHexBytesValue(target))\n}\n\n// HexBytesList accumulates []byte values into a slice.\nfunc (p *parserMixin) HexBytesList() (target *[][]byte) {\n\ttarget = new([][]byte)\n\tp.HexBytesListVar(target)\n\treturn\n}\n\nfunc (p *parserMixin) HexBytesListVar(target *[][]byte) {\n\tp.SetValue(newAccumulator(target, func(v interface{}) Value {\n\t\treturn newHexBytesValue(v.(*[]byte))\n\t}))\n}\n"
        },
        {
          "name": "values_test.go",
          "type": "blob",
          "size": 2.4326171875,
          "content": "package kingpin\n\nimport (\n\t\"net\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"testing\"\n)\n\nfunc TestAccumulatorStrings(t *testing.T) {\n\ttarget := []string{}\n\tacc := newAccumulator(&target, func(v interface{}) Value { return newStringValue(v.(*string)) })\n\tacc.Set(\"a\")\n\tassert.Equal(t, []string{\"a\"}, target)\n\tacc.Set(\"b\")\n\tassert.Equal(t, []string{\"a\", \"b\"}, target)\n}\n\nfunc TestStrings(t *testing.T) {\n\tapp := New(\"\", \"\")\n\tapp.Arg(\"a\", \"\").Required().String()\n\tapp.Arg(\"b\", \"\").Required().String()\n\tc := app.Arg(\"c\", \"\").Required().Strings()\n\tapp.Parse([]string{\"a\", \"b\", \"a\", \"b\"})\n\tassert.Equal(t, []string{\"a\", \"b\"}, *c)\n}\n\nfunc TestEnum(t *testing.T) {\n\tapp := New(\"\", \"\")\n\ta := app.Arg(\"a\", \"\").Enum(\"one\", \"two\", \"three\")\n\t_, err := app.Parse([]string{\"moo\"})\n\tassert.Error(t, err)\n\t_, err = app.Parse([]string{\"one\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"one\", *a)\n}\n\nfunc TestEnumVar(t *testing.T) {\n\tapp := New(\"\", \"\")\n\tvar a string\n\tapp.Arg(\"a\", \"\").EnumVar(&a, \"one\", \"two\", \"three\")\n\t_, err := app.Parse([]string{\"moo\"})\n\tassert.Error(t, err)\n\t_, err = app.Parse([]string{\"one\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"one\", a)\n}\n\nfunc TestCounter(t *testing.T) {\n\tapp := New(\"\", \"\")\n\tc := app.Flag(\"f\", \"\").Counter()\n\t_, err := app.Parse([]string{\"--f\", \"--f\", \"--f\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, 3, *c)\n}\n\nfunc TestIPv4Addr(t *testing.T) {\n\tapp := newTestApp()\n\tflag := app.Flag(\"addr\", \"\").ResolvedIP()\n\t_, err := app.Parse([]string{\"--addr\", net.IPv4(1, 2, 3, 4).String()})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, *flag)\n\tassert.Equal(t, net.IPv4(1, 2, 3, 4), *flag)\n}\n\nfunc TestInvalidIPv4Addr(t *testing.T) {\n\tapp := newTestApp()\n\tapp.Flag(\"addr\", \"\").ResolvedIP()\n\t_, err := app.Parse([]string{\"--addr\", \"1.2.3.256\"})\n\tassert.Error(t, err)\n}\n\nfunc TestIPv6Addr(t *testing.T) {\n\tapp := newTestApp()\n\tflag := app.Flag(\"addr\", \"\").ResolvedIP()\n\t_, err := app.Parse([]string{\"--addr\", net.IPv6interfacelocalallnodes.String()})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, *flag)\n\tassert.Equal(t, net.IPv6interfacelocalallnodes, *flag)\n}\n\nfunc TestHexBytes(t *testing.T) {\n\tapp := newTestApp()\n\tactual := app.Arg(\"bytes\", \"\").HexBytes()\n\t_, err := app.Parse([]string{\"01020aff\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, []byte{0x01, 0x02, 0x0a, 0xff}, *actual)\n}\n\nfunc TestSetValueDoesNotReset(t *testing.T) {\n\tapp := newTestApp()\n\tmapping := map[string]string{\n\t\t\"key\": \"value\",\n\t}\n\tapp.Flag(\"set\", \"\").StringMapVar(&mapping)\n\tassert.NotEmpty(t, mapping)\n}\n"
        }
      ]
    }
  ]
}