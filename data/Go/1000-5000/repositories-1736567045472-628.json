{
  "metadata": {
    "timestamp": 1736567045472,
    "page": 628,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "flashmob/go-guerrilla",
      "stars": 2806,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0791015625,
          "content": ".idea\ngoguerrilla.conf\ngoguerrilla.conf.json\n/guerrillad\nvendor\ngo-guerrilla.wiki"
        },
        {
          "name": ".travis.gofmt.sh",
          "type": "blob",
          "size": 0.2001953125,
          "content": "#!/bin/bash\n\nif [[ -n $(find . -path '*/vendor/*' -prune -o -path '*.glide/*' -prune -o -name '*.go' -type f -exec gofmt -l {} \\;) ]]; then\n    echo \"Go code is not formatted:\"\n    gofmt -d .\n    exit 1\nfi"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.279296875,
          "content": "language: go\nsudo: false\ngo:\n  - 1.11.x\n  - 1.12.x\n  - 1.13.x\n  - master\n\ncache:\n  directories:\n    - $HOME/.cache/go-build\n    - $HOME/gopath/pkg/mod\n\ninstall:\n  - go get -u github.com/golang/dep/cmd/dep\n  - dep ensure\n\nscript:\n  - ./.travis.gofmt.sh\n  - make guerrillad\n  - make test\n"
        },
        {
          "name": "GoGuerrilla.png",
          "type": "blob",
          "size": 172.2275390625,
          "content": null
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 4.0771484375,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  digest = \"1:0a2a75a7b0d611bf7ecb4e5a0054242815dc27e857b4b9f8ec62225993fd11b7\"\n  name = \"github.com/asaskevich/EventBus\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"68a521d7cbbb7a859c2608b06342f384b3bd5f5a\"\n\n[[projects]]\n  digest = \"1:ec6f9bf5e274c833c911923c9193867f3f18788c461f76f05f62bb1510e0ae65\"\n  name = \"github.com/go-sql-driver/mysql\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"72cd26f257d44c1114970e19afddcd812016007e\"\n  version = \"v1.4.1\"\n\n[[projects]]\n  digest = \"1:38ec74012390146c45af1f92d46e5382b50531247929ff3a685d2b2be65155ac\"\n  name = \"github.com/gomodule/redigo\"\n  packages = [\n    \"internal\",\n    \"redis\"\n  ]\n  pruneopts = \"UT\"\n  revision = \"9c11da706d9b7902c6da69c592f75637793fe121\"\n  version = \"v2.0.0\"\n\n[[projects]]\n  digest = \"1:870d441fe217b8e689d7949fef6e43efbc787e50f200cb1e70dbca9204a1d6be\"\n  name = \"github.com/inconshreveable/mousetrap\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"76626ae9c91c4f2a10f34cad8ce83ea42c93bb75\"\n  version = \"v1.0\"\n\n[[projects]]\n  digest = \"1:31e761d97c76151dde79e9d28964a812c46efc5baee4085b86f68f0c654450de\"\n  name = \"github.com/konsorten/go-windows-terminal-sequences\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"f55edac94c9bbba5d6182a4be46d86a2c9b5b50e\"\n  version = \"v1.0.2\"\n\n[[projects]]\n  digest = \"1:04457f9f6f3ffc5fea48e71d62f2ca256637dee0a04d710288e27e05c8b41976\"\n  name = \"github.com/sirupsen/logrus\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"839c75faf7f98a33d445d181f3018b5c3409a45e\"\n  version = \"v1.4.2\"\n\n[[projects]]\n  digest = \"1:645cabccbb4fa8aab25a956cbcbdf6a6845ca736b2c64e197ca7cbb9d210b939\"\n  name = \"github.com/spf13/cobra\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"ef82de70bb3f60c65fb8eebacbb2d122ef517385\"\n  version = \"v0.0.3\"\n\n[[projects]]\n  digest = \"1:c1b1102241e7f645bc8e0c22ae352e8f0dc6484b6cb4d132fa9f24174e0119e2\"\n  name = \"github.com/spf13/pflag\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"298182f68c66c05229eb03ac171abe6e309ee79a\"\n  version = \"v1.0.3\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:a167b5c532f3245f5a147ade26185f16d6ee8f8d3f6c9846f447e9d8b9705505\"\n  name = \"golang.org/x/net\"\n  packages = [\n    \"html\",\n    \"html/atom\",\n    \"html/charset\"\n  ]\n  pruneopts = \"UT\"\n  revision = \"f4e77d36d62c17c2336347bb2670ddbd02d092b7\"\n\n[[projects]]\n  digest = \"1:3fe612db5a4468ac2846ae481c22bb3250fa67cf03bccb00c06fa8723a3077a8\"\n  name = \"golang.org/x/sys\"\n  packages = [\"unix\"]\n  pruneopts = \"UT\"\n  revision = \"7dca6fe1f43775aa6d1334576870ff63f978f539\"\n\n[[projects]]\n  digest = \"1:8a0baffd5559acaa560f854d7d525c02f4fec2d4f8a214398556fb661a10f6e0\"\n  name = \"golang.org/x/text\"\n  packages = [\n    \"encoding\",\n    \"encoding/charmap\",\n    \"encoding/htmlindex\",\n    \"encoding/internal\",\n    \"encoding/internal/identifier\",\n    \"encoding/japanese\",\n    \"encoding/korean\",\n    \"encoding/simplifiedchinese\",\n    \"encoding/traditionalchinese\",\n    \"encoding/unicode\",\n    \"internal/gen\",\n    \"internal/language\",\n    \"internal/language/compact\",\n    \"internal/tag\",\n    \"internal/utf8internal\",\n    \"language\",\n    \"runes\",\n    \"transform\",\n    \"unicode/cldr\"\n  ]\n  pruneopts = \"UT\"\n  revision = \"342b2e1fbaa52c93f31447ad2c6abc048c63e475\"\n  version = \"v0.3.2\"\n\n[[projects]]\n  digest = \"1:c25289f43ac4a68d88b02245742347c94f1e108c534dda442188015ff80669b3\"\n  name = \"google.golang.org/appengine\"\n  packages = [\"cloudsql\"]\n  pruneopts = \"UT\"\n  revision = \"54a98f90d1c46b7731eb8fb305d2a321c30ef610\"\n  version = \"v1.5.0\"\n\n[[projects]]\n  digest = \"1:6a8414c6457caa5db639b9f5c084a95b698f2b3cc011151a4b43224a1d8fe0f5\"\n  name = \"gopkg.in/iconv.v1\"\n  packages = [\".\"]\n  pruneopts = \"UT\"\n  revision = \"16a760eb7e186ae0e3aedda00d4a1daa4d0701d8\"\n  version = \"v1.1.1\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  input-imports = [\n    \"github.com/asaskevich/EventBus\",\n    \"github.com/go-sql-driver/mysql\",\n    \"github.com/gomodule/redigo/redis\",\n    \"github.com/sirupsen/logrus\",\n    \"github.com/spf13/cobra\",\n    \"golang.org/x/net/html/charset\",\n    \"gopkg.in/iconv.v1\"\n  ]\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.6708984375,
          "content": "[[constraint]]\n  name = \"github.com/go-sql-driver/mysql\"\n  version = \"1.3.0\"\n\n[[constraint]]\n  name = \"github.com/gomodule/redigo\"\n  version = \"~2.0.0\"\n\n[[constraint]]\n  name = \"github.com/sirupsen/logrus\"\n  version = \"~1.4.2\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"golang.org/x/net\"\n\n[[constraint]]\n  name = \"gopkg.in/iconv.v1\"\n  version = \"~1.1.1\"\n\n[[constraint]]\n  name = \"github.com/asaskevich/EventBus\"\n  revision = \"68a521d7cbbb7a859c2608b06342f384b3bd5f5a\"\n\n# The following locks logrus to a particular version of x/sys\n[[override]]\n    name = \"golang.org/x/sys\"\n    revision = \"7dca6fe1f43775aa6d1334576870ff63f978f539\"\n\n[prune]\n  go-tests = true\n  unused-packages = true\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05859375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 GuerrillaMail.com.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.3125,
          "content": "GIT ?= git\nGO_VARS ?=\nGO ?= go\nCOMMIT := $(shell $(GIT) rev-parse HEAD)\nVERSION ?= $(shell $(GIT) describe --tags ${COMMIT} 2> /dev/null || echo \"$(COMMIT)\")\nBUILD_TIME := $(shell LANG=en_US date +\"%F_%T_%z\")\nROOT := github.com/flashmob/go-guerrilla\nLD_FLAGS := -X $(ROOT).Version=$(VERSION) -X $(ROOT).Commit=$(COMMIT) -X $(ROOT).BuildTime=$(BUILD_TIME)\n\n.PHONY: help clean dependencies test\nhelp:\n\t@echo \"Please use \\`make <ROOT>' where <ROOT> is one of\"\n\t@echo \"  guerrillad   to build the main binary for current platform\"\n\t@echo \"  test         to run unittests\"\n\nclean:\n\trm -f guerrillad\n\nvendor:\n\tdep ensure\n\nguerrillad:\n\t$(GO_VARS) $(GO) build -o=\"guerrillad\" -ldflags=\"$(LD_FLAGS)\" $(ROOT)/cmd/guerrillad\n\nguerrilladrace:\n\t$(GO_VARS) $(GO) build -o=\"guerrillad\" -race -ldflags=\"$(LD_FLAGS)\" $(ROOT)/cmd/guerrillad\n\ntest:\n\t$(GO_VARS) $(GO) test -v .\n\t$(GO_VARS) $(GO) test -v ./tests\n\t$(GO_VARS) $(GO) test -v ./cmd/guerrillad\n\t$(GO_VARS) $(GO) test -v ./response\n\t$(GO_VARS) $(GO) test -v ./backends\n\t$(GO_VARS) $(GO) test -v ./mail\n\t$(GO_VARS) $(GO) test -v ./mail/encoding\n\t$(GO_VARS) $(GO) test -v ./mail/rfc5321\n\ntestrace:\n\t$(GO_VARS) $(GO) test -v . -race\n\t$(GO_VARS) $(GO) test -v ./tests -race\n\t$(GO_VARS) $(GO) test -v ./cmd/guerrillad -race\n\t$(GO_VARS) $(GO) test -v ./response -race\n\t$(GO_VARS) $(GO) test -v ./backends -race"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.8232421875,
          "content": "\n> [!IMPORTANT]\n> Hi, my name is Philipp and I am one of the contributors to this project.\n> Sadly it seems as if the original owner has abandonded go-guerilla.\n> As I think there are still some nice things to do with it, and there might\n> be some issues here and there, I have decided to revive this project.\n>\n> I've already mirrored the repository to https://github.com/phires/go-guerrilla\n> as I have not complete full access to this repo and don't know if it will\n> disappear at some point.\n> I will also try to migrate all further relevant informations (e.g. Wiki\n> and Issues) over to the new repo.\n>\n> If the original owner decides to come back I'll glady hand over full control\n> of the projekt back to him. This should by no means be misinterpreted as a\n> \"hostile takeover\" or anything. I just want to get this mighty fine piece\n> of software back to speed and give it some further development.\n>\n>     -- 2023-08-31 Philipp\n\n\nLatest: v1.6.1, tagged on Dec 28, 2019 (Pull requests from #129 to #203)\n\nGo-Guerrilla SMTP Daemon\n====================\n\nA lightweight SMTP server written in Go, made for receiving large volumes of mail.\nTo be used as a package in your Go project, or as a stand-alone daemon by running the \"guerrillad\" binary.\n\nSupports MySQL and Redis out-of-the-box, with many other vendor provided _processors_,\nsuch as [MailDir](https://github.com/flashmob/maildir-processor) and even [FastCGI](https://github.com/flashmob/fastcgi-processor)! \nSee below for a list of available processors.\n\n![Go Guerrilla](/GoGuerrilla.png)\n\n### What is Go-Guerrilla?\n\nIt's an SMTP server written in Go, for the purpose of receiving large volumes of email.\nIt started as a project for GuerrillaMail.com which processes millions of emails every day,\nand needed a daemon with less bloat & written in a more memory-safe language that can \ntake advantage of modern multi-core architectures.\n\nThe purpose of this daemon is to grab the email, save it,\nand disconnect as quickly as possible, essentially performing the services of a\nMail Transfer Agent (MTA) without the sending functionality.\n\nThe software also includes a modular backend implementation, which can extend the email\nprocessing functionality to whatever needs you may require. We refer to these modules as \n\"_Processors_\". Processors can be chained via the config to perform different tasks on \nreceived email, or to validate recipients.\n\nSee the list of available _Processors_ below.\n\nFor more details about the backend system, see the:\n[Backends, configuring and extending](https://github.com/flashmob/go-guerrilla/wiki/Backends,-configuring-and-extending) page.\n\n### License\n\nThe software is using MIT License (MIT) - contributors welcome.\n\n### Features\n\n#### Main Features\n\n- Multi-server. Can spawn multiple servers, all sharing the same backend\nfor saving email.\n- Config hot-reloading. Add/Remove/Enable/Disable servers without restarting. \nReload TLS configuration, change most other settings on the fly.\n- Graceful shutdown: Minimise loss of email if you need to shutdown/restart.\n- Be a gentleman to the garbage collector: resources are pooled & recycled where possible.\n- Modular [Backend system](https://github.com/flashmob/go-guerrilla/wiki/Backends,-configuring-and-extending) \n- Modern TLS support (STARTTLS or SMTPS).\n- Can be [used as a package](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package) in your Go project. \nGet started in just a few lines of code!\n- [Fuzz tested](https://github.com/flashmob/go-guerrilla/wiki/Fuzz-testing). \n[Auto-tested](https://travis-ci.org/flashmob/go-guerrilla). Battle Tested.\n\n#### Backend Features\n\n- Arranged as workers running in parallel, using a producer/consumer type structure, \n taking advantage of Go's channels and go-routines. \n- Modular [backend system](https://github.com/flashmob/go-guerrilla/wiki/Backends,-configuring-and-extending)\n structured using a [decorator-like pattern](https://en.wikipedia.org/wiki/Decorator_pattern) which allows the chaining of components (a.k.a. _Processors_) via the config.  \n- Different ways for processing / delivering email: Supports MySQL and Redis out-of-the box, many other \nvendor provided processors available.\n\n### Roadmap / Contributing & Bounties\n\nPull requests / issue reporting & discussion / code reviews always \nwelcome. To encourage more pull requests, we are now offering bounties. \n\nTake a look at our [Bounties and Roadmap](https://github.com/flashmob/go-guerrilla/wiki/Roadmap-and-Bounties) page!\n\n\nGetting started\n===========================\n\n(Assuming that you have GNU make and latest Go on your system)\n\n#### Dependencies\n\nGo-Guerrilla uses [Dep](https://golang.github.io/dep/) to manage \ndependencies. If you have dep installed, just run `dep ensure` as usual.\n \nYou can also run `$ go get ./..` if you don't want to use dep, and then run `$ make test`\nto ensure all is good.\n\nTo build the binary run:\n\n```\n$ make guerrillad\n```\n\nThis will create a executable file named `guerrillad` that's ready to run.\nSee the [build notes](https://github.com/flashmob/go-guerrilla/wiki/Build-Notes) for more details.\n\nNext, copy the `goguerrilla.conf.sample` file to `goguerrilla.conf.json`. \nYou may need to customize the `pid_file` setting to somewhere local, \nand also set `tls_always_on` to false if you don't have a valid certificate setup yet. \n\nNext, run your server like this:\n\n`$ ./guerrillad serve`\n\nThe configuration options are detailed on the [configuration page](https://github.com/flashmob/go-guerrilla/wiki/Configuration). \nThe main takeaway here is:\n\nThe default configuration uses 3 _processors_, they are set using the `save_process` \nconfig option. Notice that it contains the following value: \n`\"HeadersParser|Header|Debugger\"` - this means, once an email is received, it will\nfirst go through the `HeadersParser` processor where headers will be parsed.\nNext, it will go through the `Header` processor, where delivery headers will be added.\nFinally, it will finish at the `Debugger` which will log some debug messages.\n\nWhere to go next?\n\n- Try setting up an [example configuration](https://github.com/flashmob/go-guerrilla/wiki/Configuration-example:-save-to-Redis-&-MySQL) \nwhich saves email bodies to Redis and metadata to MySQL.\n- Try importing some of the 'vendored' processors into your project. See [MailDiranasaurus](https://github.com/flashmob/maildiranasaurus)\nas an example project which imports the [MailDir](https://github.com/flashmob/maildir-processor) and [FastCGI](https://github.com/flashmob/fastcgi-processor) processors.\n- Try hacking the source and [create your own processor](https://github.com/flashmob/go-guerrilla/wiki/Backends,-configuring-and-extending).\n- Once your daemon is running, you might want to stup [log rotation](https://github.com/flashmob/go-guerrilla/wiki/Automatic-log-file-management-with-logrotate).\n\n\n\nUse as a package\n============================\nGo-Guerrilla can be imported and used as a package in your Go project.\n\n### Quickstart\n\n\n#### 1. Import the guerrilla package\n```go\nimport (\n    \"github.com/flashmob/go-guerrilla\"\n)\n\n\n```\n\nYou should use the `dep ensure` command to get all dependencies, as Go-Guerrilla uses \n[dep](https://golang.github.io/dep/) for dependency management. \n\nOtherise, ``$ go get ./...`` should work if you're in a hurry.\n\n#### 2. Start a server\n\nThis will start a server with the default settings, listening on `127.0.0.1:2525`\n\n\n```go\n\nd := guerrilla.Daemon{}\nerr := d.Start()\n\nif err == nil {\n    fmt.Println(\"Server Started!\")\n}\n```\n\n`d.Start()` *does not block* after the server has been started, so make sure that you keep your program busy.\n\nThe defaults are: \n* Server listening to 127.0.0.1:2525\n* use your hostname to determine your which hosts to accept email for\n* 100 maximum clients\n* 10MB max message size \n* log to Stderror, \n* log level set to \"`debug`\"\n* timeout to 30 sec \n* Backend configured with the following processors: `HeadersParser|Header|Debugger` where it will log the received emails.\n\nNext, you may want to [change the interface](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#starting-a-server---custom-listening-interface) (`127.0.0.1:2525`) to the one of your own choice.\n\n#### API Documentation topics\n\nPlease continue to the [API documentation](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package) for the following topics:\n\n\n- [Suppressing log output](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#starting-a-server---suppressing-log-output)\n- [Custom listening interface](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#starting-a-server---custom-listening-interface)\n- [What else can be configured](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#what-else-can-be-configured)\n- [Backends](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#backends)\n    - [About the backend system](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#about-the-backend-system)\n    - [Backend Configuration](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#backend-configuration)\n    - [Registering a Processor](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#registering-a-processor)\n- [Loading config from JSON](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#loading-config-from-json)\n- [Config hot-reloading](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#config-hot-reloading)\n- [Logging](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#logging-stuff)\n- [Log re-opening](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#log-re-opening)\n- [Graceful shutdown](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#graceful-shutdown)\n- [Pub/Sub](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#pubsub)\n- [More Examples](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#more-examples)\n\nUse as a Daemon\n==========================================================\n\n### Manual for using from the command line\n\n- [guerrillad command](https://github.com/flashmob/go-guerrilla/wiki/Running-from-command-line#guerrillad-command)\n    - [Starting](https://github.com/flashmob/go-guerrilla/wiki/Running-from-command-line#starting)\n    - [Re-loading configuration](https://github.com/flashmob/go-guerrilla/wiki/Running-from-command-line#re-loading-the-config)\n    - [Re-open logs](https://github.com/flashmob/go-guerrilla/wiki/Running-from-command-line#re-open-log-file)\n    - [Examples](https://github.com/flashmob/go-guerrilla/wiki/Running-from-command-line#examples)\n\n### Other topics\n\n- [Using Nginx as a proxy](https://github.com/flashmob/go-guerrilla/wiki/Using-Nginx-as-a-proxy)\n- [Testing STARTTLS](https://github.com/flashmob/go-guerrilla/wiki/Running-from-command-line#testing-starttls)\n- [Benchmarking](https://github.com/flashmob/go-guerrilla/wiki/Profiling#benchmarking)\n\n\nEmail Processing Backend\n=====================\n\nThe main job of a Go-Guerrilla backend is to validate recipients and deliver emails. The term\n\"delivery\" is often synonymous with saving email to secondary storage.\n\nThe default backend implementation manages multiple workers. These workers are composed of \nsmaller components called \"Processors\" which are chained using the config to perform a series of steps.\nEach processor specifies a distinct feature of behaviour. For example, a processor may save\nthe emails to a particular storage system such as MySQL, or it may add additional headers before \npassing the email to the next _processor_.\n\nTo extend or add a new feature, one would write a new Processor, then add it to the config.\nThere are a few default _processors_ to get you started.\n\n\n### Included Processors\n\n| Processor | Description |\n|-----------|-------------|\n|Compressor|Sets a zlib compressor that other processors can use later|\n|Debugger|Logs the email envelope to help with testing|\n|Hasher|Processes each envelope to produce unique hashes to be used for ids later|\n|Header|Add a delivery header to the envelope|\n|HeadersParser|Parses MIME headers and also populates the Subject field of the envelope|\n|MySQL|Saves the emails to MySQL.|\n|Redis|Saves the email data to Redis.|\n|GuerrillaDbRedis|A 'monolithic' processor used at Guerrilla Mail; included for example\n\n### Available Processors\n\nThe following processors can be imported to your project, then use the\n[Daemon.AddProcessor](https://github.com/flashmob/go-guerrilla/wiki/Using-as-a-package#registering-a-processor) function to register, then add to your config.\n\n| Processor | Description |\n|-----------|-------------|\n|[MailDir](https://github.com/flashmob/maildir-processor)|Save emails to a maildir. [MailDiranasaurus](https://github.com/flashmob/maildiranasaurus) is an example project|\n|[FastCGI](https://github.com/flashmob/fastcgi-processor)|Deliver email directly to PHP-FPM or a similar FastCGI backend.|\n|[WildcardProcessor](https://github.com/DevelHell/wildcard-processor)|Use wildcards for recipients host validation.|\n\nHave a processor that you would like to share? Submit a PR to add it to the list!\n\nReleases\n========\n\nCurrent release: 1.5.1 - 4th Nov 2016\n\nNext Planned release: 2.0.0 - TBA\n\nSee our [change log](https://github.com/flashmob/go-guerrilla/wiki/Change-Log) for change and release history\n\n\nUsing Nginx as a proxy\n======================\n\nFor such purposes as load balancing, terminating TLS early,\n or supporting SSL versions not supported by Go (highly not recommended if you\n want to use older TLS/SSL versions), \n it is possible to [use NGINX as a proxy](https://github.com/flashmob/go-guerrilla/wiki/Using-Nginx-as-a-proxy).\n\n\n\nCredits\n=======\n\nProject Lead: \n-------------\nFlashmob, GuerrillaMail.com, Contact: flashmob@gmail.com\n\nMajor Contributors: \n-------------------\n\n* Reza Mohammadi https://github.com/remohammadi\n* Jordan Schalm https://github.com/jordanschalm \n* Philipp Resch https://github.com/dapaxx\n\nThanks to:\n----------\n* https://github.com/dvcrn\n* https://github.com/athoune\n* https://github.com/Xeoncross\n\n... and anyone else who opened an issue / sent a PR / gave suggestions!\n"
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 5.884765625,
          "content": "package guerrilla\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"io/ioutil\"\n\t\"time\"\n)\n\n// Daemon provides a convenient API when using go-guerrilla as a package in your Go project.\n// Is's facade for Guerrilla, AppConfig, backends.Backend and log.Logger\ntype Daemon struct {\n\tConfig  *AppConfig\n\tLogger  log.Logger\n\tBackend backends.Backend\n\n\t// Guerrilla will be managed through the API\n\tg Guerrilla\n\n\tconfigLoadTime time.Time\n\tsubs           []deferredSub\n}\n\ntype deferredSub struct {\n\ttopic Event\n\tfn    interface{}\n}\n\n// AddProcessor adds a processor constructor to the backend.\n// name is the identifier to be used in the config. See backends docs for more info.\nfunc (d *Daemon) AddProcessor(name string, pc backends.ProcessorConstructor) {\n\tbackends.Svc.AddProcessor(name, pc)\n}\n\n// Starts the daemon, initializing d.Config, d.Logger and d.Backend with defaults\n// can only be called once through the lifetime of the program\nfunc (d *Daemon) Start() (err error) {\n\tif d.g == nil {\n\t\tif d.Config == nil {\n\t\t\td.Config = &AppConfig{}\n\t\t}\n\t\tif err = d.configureDefaults(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif d.Logger == nil {\n\t\t\td.Logger, err = log.GetLogger(d.Config.LogFile, d.Config.LogLevel)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif d.Backend == nil {\n\t\t\td.Backend, err = backends.New(d.Config.BackendConfig, d.Logger)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\td.g, err = New(d.Config, d.Backend, d.Logger)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := range d.subs {\n\t\t\t_ = d.Subscribe(d.subs[i].topic, d.subs[i].fn)\n\n\t\t}\n\t\td.subs = make([]deferredSub, 0)\n\t}\n\terr = d.g.Start()\n\tif err == nil {\n\t\tif err := d.resetLogger(); err == nil {\n\t\t\td.Log().Infof(\"main log configured to %s\", d.Config.LogFile)\n\t\t}\n\n\t}\n\treturn err\n}\n\n// Shuts down the daemon, including servers and backend.\n// Do not call Start on it again, use a new server.\nfunc (d *Daemon) Shutdown() {\n\tif d.g != nil {\n\t\td.g.Shutdown()\n\t}\n}\n\n// LoadConfig reads in the config from a JSON file.\n// Note: if d.Config is nil, the sets d.Config with the unmarshalled AppConfig which will be returned\nfunc (d *Daemon) LoadConfig(path string) (AppConfig, error) {\n\tvar ac AppConfig\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn ac, fmt.Errorf(\"could not read config file: %s\", err.Error())\n\t}\n\terr = ac.Load(data)\n\tif err != nil {\n\t\treturn ac, err\n\t}\n\tif d.Config == nil {\n\t\td.Config = &ac\n\t}\n\treturn ac, nil\n}\n\n// SetConfig is same as LoadConfig, except you can pass AppConfig directly\n// does not emit any change events, instead use ReloadConfig after daemon has started\nfunc (d *Daemon) SetConfig(c AppConfig) error {\n\t// need to call c.Load, thus need to convert the config\n\t// d.load takes json bytes, marshal it\n\tdata, err := json.Marshal(&c)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = c.Load(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.Config = &c\n\treturn nil\n}\n\n// Reload a config using the passed in AppConfig and emit config change events\nfunc (d *Daemon) ReloadConfig(c AppConfig) error {\n\toldConfig := *d.Config\n\terr := d.SetConfig(c)\n\tif err != nil {\n\t\td.Log().WithError(err).Error(\"Error while reloading config\")\n\t\treturn err\n\t}\n\td.Log().Infof(\"Configuration was reloaded at %s\", d.configLoadTime)\n\td.Config.EmitChangeEvents(&oldConfig, d.g)\n\n\treturn nil\n}\n\n// Reload a config from a file and emit config change events\nfunc (d *Daemon) ReloadConfigFile(path string) error {\n\tac, err := d.LoadConfig(path)\n\tif err != nil {\n\t\td.Log().WithError(err).Error(\"Error while reloading config from file\")\n\t\treturn err\n\t} else if d.Config != nil {\n\t\toldConfig := *d.Config\n\t\td.Config = &ac\n\t\td.Log().Infof(\"Configuration was reloaded at %s\", d.configLoadTime)\n\t\td.Config.EmitChangeEvents(&oldConfig, d.g)\n\t}\n\treturn nil\n}\n\n// ReopenLogs send events to re-opens all log files.\n// Typically, one would call this after rotating logs\nfunc (d *Daemon) ReopenLogs() error {\n\tif d.Config == nil {\n\t\treturn errors.New(\"d.Config nil\")\n\t}\n\td.Config.EmitLogReopenEvents(d.g)\n\treturn nil\n}\n\n// Subscribe for subscribing to config change events\nfunc (d *Daemon) Subscribe(topic Event, fn interface{}) error {\n\tif d.g == nil {\n\t\t// defer the subscription until the daemon is started\n\t\td.subs = append(d.subs, deferredSub{topic, fn})\n\t\treturn nil\n\t}\n\treturn d.g.Subscribe(topic, fn)\n}\n\n// for publishing config change events\nfunc (d *Daemon) Publish(topic Event, args ...interface{}) {\n\tif d.g == nil {\n\t\treturn\n\t}\n\td.g.Publish(topic, args...)\n}\n\n// for unsubscribing from config change events\nfunc (d *Daemon) Unsubscribe(topic Event, handler interface{}) error {\n\tif d.g == nil {\n\t\tfor i := range d.subs {\n\t\t\tif d.subs[i].topic == topic && d.subs[i].fn == handler {\n\t\t\t\td.subs = append(d.subs[:i], d.subs[i+1:]...)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn d.g.Unsubscribe(topic, handler)\n}\n\n// log returns a logger that implements our log.Logger interface.\n// level is set to \"info\" by default\nfunc (d *Daemon) Log() log.Logger {\n\tif d.Logger != nil {\n\t\treturn d.Logger\n\t}\n\tout := log.OutputStderr.String()\n\tlevel := log.InfoLevel.String()\n\tif d.Config != nil {\n\t\tif len(d.Config.LogFile) > 0 {\n\t\t\tout = d.Config.LogFile\n\t\t}\n\t\tif len(d.Config.LogLevel) > 0 {\n\t\t\tlevel = d.Config.LogLevel\n\t\t}\n\t}\n\tl, _ := log.GetLogger(out, level)\n\treturn l\n\n}\n\n// set the default values for the servers and backend config options\nfunc (d *Daemon) configureDefaults() error {\n\terr := d.Config.setDefaults()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.Backend == nil {\n\t\terr = d.Config.setBackendDefaults()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn err\n}\n\n// resetLogger sets the logger to the one specified in the config.\n// This is because at the start, the daemon may be logging to stderr,\n// then attaches to the logs once the config is loaded.\n// This will propagate down to the servers / backend too.\nfunc (d *Daemon) resetLogger() error {\n\tl, err := log.GetLogger(d.Config.LogFile, d.Config.LogLevel)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.Logger = l\n\td.g.SetLogger(d.Logger)\n\treturn nil\n}\n"
        },
        {
          "name": "api_test.go",
          "type": "blob",
          "size": 17.9453125,
          "content": "package guerrilla\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"github.com/flashmob/go-guerrilla/mail\"\n\t\"github.com/flashmob/go-guerrilla/response\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\n// Test Starting smtp without setting up logger / backend\nfunc TestSMTP(t *testing.T) {\n\tdone := make(chan bool)\n\tgo func() {\n\t\tselect {\n\t\tcase <-time.After(time.Second * 40):\n\t\t\tt.Error(\"timeout\")\n\t\t\treturn\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}()\n\n\td := Daemon{}\n\terr := d.Start()\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\t// it should set to stderr automatically\n\tif d.Config.LogFile != log.OutputStderr.String() {\n\t\tt.Error(\"smtp.config.LogFile is not\", log.OutputStderr.String())\n\t}\n\n\tif len(d.Config.AllowedHosts) == 0 {\n\t\tt.Error(\"smtp.config.AllowedHosts len should be 1, not 0\", d.Config.AllowedHosts)\n\t}\n\n\tif d.Config.LogLevel != \"debug\" {\n\t\tt.Error(\"smtp.config.LogLevel expected'debug', it is\", d.Config.LogLevel)\n\t}\n\tif len(d.Config.Servers) != 1 {\n\t\tt.Error(\"len(smtp.config.Servers) should be 1, got\", len(d.Config.Servers))\n\t}\n\ttime.Sleep(time.Second * 2)\n\td.Shutdown()\n\tdone <- true\n\n}\n\n// Suppressing log output\nfunc TestSMTPNoLog(t *testing.T) {\n\n\t// configure a default server with no log output\n\tcfg := &AppConfig{LogFile: log.OutputOff.String()}\n\td := Daemon{Config: cfg}\n\n\terr := d.Start()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\ttime.Sleep(time.Second * 2)\n\td.Shutdown()\n}\n\n// our custom server\nfunc TestSMTPCustomServer(t *testing.T) {\n\tcfg := &AppConfig{LogFile: log.OutputOff.String()}\n\tsc := ServerConfig{\n\t\tListenInterface: \"127.0.0.1:2526\",\n\t\tIsEnabled:       true,\n\t}\n\tcfg.Servers = append(cfg.Servers, sc)\n\td := Daemon{Config: cfg}\n\n\terr := d.Start()\n\tif err != nil {\n\t\tt.Error(\"start error\", err)\n\t} else {\n\t\ttime.Sleep(time.Second * 2)\n\t\td.Shutdown()\n\t}\n\n}\n\n// with a backend config\nfunc TestSMTPCustomBackend(t *testing.T) {\n\tcfg := &AppConfig{LogFile: log.OutputOff.String()}\n\tsc := ServerConfig{\n\t\tListenInterface: \"127.0.0.1:2526\",\n\t\tIsEnabled:       true,\n\t}\n\tcfg.Servers = append(cfg.Servers, sc)\n\tbcfg := backends.BackendConfig{\n\t\t\"save_workers_size\":  3,\n\t\t\"save_process\":       \"HeadersParser|Header|Hasher|Debugger\",\n\t\t\"log_received_mails\": true,\n\t\t\"primary_mail_host\":  \"example.com\",\n\t}\n\tcfg.BackendConfig = bcfg\n\td := Daemon{Config: cfg}\n\n\terr := d.Start()\n\tif err != nil {\n\t\tt.Error(\"start error\", err)\n\t} else {\n\t\ttime.Sleep(time.Second * 2)\n\t\td.Shutdown()\n\t}\n}\n\n// with a config from a json file\nfunc TestSMTPLoadFile(t *testing.T) {\n\tjson := `{\n    \"log_file\" : \"./tests/testlog\",\n    \"log_level\" : \"debug\",\n    \"pid_file\" : \"tests/go-guerrilla.pid\",\n    \"allowed_hosts\": [\"spam4.me\",\"grr.la\"],\n    \"backend_config\" :\n        {\n            \"log_received_mails\" : true,\n            \"save_process\": \"HeadersParser|Header|Hasher|Debugger\",\n            \"save_workers_size\":  3\n        },\n    \"servers\" : [\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.guerrillamail.com\",\n            \"max_size\": 100017,\n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:2526\",\n            \"max_clients\": 2,\n\t\t\t\"tls\" : {\n\t\t\t\t\"private_key_file\":\"config_test.go\",\n            \t\"public_key_file\":\"config_test.go\",\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":false\n\t\t\t}\n        }\n    ]\n}\n\n\t`\n\tjson2 := `{\n    \"log_file\" : \"./tests/testlog2\",\n    \"log_level\" : \"debug\",\n    \"pid_file\" : \"tests/go-guerrilla2.pid\",\n    \"allowed_hosts\": [\"spam4.me\",\"grr.la\"],\n    \"backend_config\" :\n        {\n            \"log_received_mails\" : true,\n            \"save_process\": \"HeadersParser|Header|Hasher|Debugger\",\n            \"save_workers_size\":  3\n        },\n    \"servers\" : [\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.guerrillamail.com\",\n            \"max_size\": 100017,\n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:2526\",\n            \"max_clients\": 2,\n\t\t\t\"tls\" : {\n \t\t\t\t\"private_key_file\":\"config_test.go\",\n\t\t\t\t\"public_key_file\":\"config_test.go\",\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":false\n\t\t\t}\n        }\n    ]\n}\n\n\t`\n\terr := ioutil.WriteFile(\"goguerrilla.conf.api\", []byte(json), 0644)\n\tif err != nil {\n\t\tt.Error(\"could not write guerrilla.conf.api\", err)\n\t\treturn\n\t}\n\n\td := Daemon{}\n\t_, err = d.LoadConfig(\"goguerrilla.conf.api\")\n\tif err != nil {\n\t\tt.Error(\"ReadConfig error\", err)\n\t\treturn\n\t}\n\n\terr = d.Start()\n\tif err != nil {\n\t\tt.Error(\"start error\", err)\n\t\treturn\n\t} else {\n\t\ttime.Sleep(time.Second * 2)\n\t\tif d.Config.LogFile != \"./tests/testlog\" {\n\t\t\tt.Error(\"d.Config.LogFile != \\\"./tests/testlog\\\"\")\n\t\t}\n\n\t\tif d.Config.PidFile != \"tests/go-guerrilla.pid\" {\n\t\t\tt.Error(\"d.Config.LogFile != tests/go-guerrilla.pid\")\n\t\t}\n\n\t\terr := ioutil.WriteFile(\"goguerrilla.conf.api\", []byte(json2), 0644)\n\t\tif err != nil {\n\t\t\tt.Error(\"could not write guerrilla.conf.api\", err)\n\t\t\treturn\n\t\t}\n\n\t\tif err = d.ReloadConfigFile(\"goguerrilla.conf.api\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tif d.Config.LogFile != \"./tests/testlog2\" {\n\t\t\tt.Error(\"d.Config.LogFile != \\\"./tests/testlog\\\"\")\n\t\t}\n\n\t\tif d.Config.PidFile != \"tests/go-guerrilla2.pid\" {\n\t\t\tt.Error(\"d.Config.LogFile != \\\"go-guerrilla.pid\\\"\")\n\t\t}\n\n\t\td.Shutdown()\n\t}\n}\n\n// test re-opening the main log\nfunc TestReopenLog(t *testing.T) {\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tcfg := &AppConfig{LogFile: \"tests/testlog\"}\n\tsc := ServerConfig{\n\t\tListenInterface: \"127.0.0.1:2526\",\n\t\tIsEnabled:       true,\n\t}\n\tcfg.Servers = append(cfg.Servers, sc)\n\td := Daemon{Config: cfg}\n\n\terr := d.Start()\n\tif err != nil {\n\t\tt.Error(\"start error\", err)\n\t} else {\n\t\tif err = d.ReopenLogs(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\ttime.Sleep(time.Second * 2)\n\n\t\td.Shutdown()\n\t}\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\tif !strings.Contains(string(b), \"re-opened log file\") {\n\t\tt.Error(\"Server log did not re-opened, expecting \\\"re-opened log file\\\"\")\n\t}\n\tif !strings.Contains(string(b), \"re-opened main log file\") {\n\t\tt.Error(\"Main log did not re-opened, expecting \\\"re-opened main log file\\\"\")\n\t}\n}\n\nconst testServerLog = \"tests/testlog-server.log\"\n\n// test re-opening the individual server log\nfunc TestReopenServerLog(t *testing.T) {\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdefer func() {\n\t\tif _, err := os.Stat(testServerLog); err == nil {\n\t\t\tif err = os.Remove(testServerLog); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tcfg := &AppConfig{LogFile: \"tests/testlog\", LogLevel: log.DebugLevel.String(), AllowedHosts: []string{\"grr.la\"}}\n\tsc := ServerConfig{\n\t\tListenInterface: \"127.0.0.1:2526\",\n\t\tIsEnabled:       true,\n\t\tLogFile:         testServerLog,\n\t}\n\tcfg.Servers = append(cfg.Servers, sc)\n\td := Daemon{Config: cfg}\n\n\terr := d.Start()\n\tif err != nil {\n\t\tt.Error(\"start error\", err)\n\t} else {\n\t\tif err := talkToServer(\"127.0.0.1:2526\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif err = d.ReopenLogs(); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\ttime.Sleep(time.Second * 2)\n\t\tif err := talkToServer(\"127.0.0.1:2526\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\td.Shutdown()\n\t}\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\tif !strings.Contains(string(b), \"re-opened log file\") {\n\t\tt.Error(\"Server log did not re-opened, expecting \\\"re-opened log file\\\"\")\n\t}\n\tif !strings.Contains(string(b), \"re-opened main log file\") {\n\t\tt.Error(\"Main log did not re-opened, expecting \\\"re-opened main log file\\\"\")\n\t}\n\n\tb, err = ioutil.ReadFile(testServerLog)\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\n\tif !strings.Contains(string(b), \"Handle client\") {\n\t\tt.Error(\"server log does not contain \\\"handle client\\\"\")\n\t}\n\n}\n\nfunc TestSetConfig(t *testing.T) {\n\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tcfg := AppConfig{LogFile: \"tests/testlog\"}\n\tsc := ServerConfig{\n\t\tListenInterface: \"127.0.0.1:2526\",\n\t\tIsEnabled:       true,\n\t}\n\tcfg.Servers = append(cfg.Servers, sc)\n\td := Daemon{Config: &cfg}\n\n\t// lets add a new server\n\tsc.ListenInterface = \"127.0.0.1:2527\"\n\tcfg.Servers = append(cfg.Servers, sc)\n\n\terr := d.SetConfig(cfg)\n\tif err != nil {\n\t\tt.Error(\"SetConfig returned an error:\", err)\n\t\treturn\n\t}\n\n\terr = d.Start()\n\tif err != nil {\n\t\tt.Error(\"start error\", err)\n\t} else {\n\n\t\ttime.Sleep(time.Second * 2)\n\n\t\td.Shutdown()\n\t}\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\t//fmt.Println(string(b))\n\t// has 127.0.0.1:2527 started?\n\tif !strings.Contains(string(b), \"127.0.0.1:2527\") {\n\t\tt.Error(\"expecting 127.0.0.1:2527 to start\")\n\t}\n\n}\n\nfunc TestSetConfigError(t *testing.T) {\n\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tcfg := AppConfig{LogFile: \"tests/testlog\"}\n\tsc := ServerConfig{\n\t\tListenInterface: \"127.0.0.1:2526\",\n\t\tIsEnabled:       true,\n\t}\n\tcfg.Servers = append(cfg.Servers, sc)\n\td := Daemon{Config: &cfg}\n\n\t// lets add a new server with bad TLS\n\tsc.ListenInterface = \"127.0.0.1:2527\"\n\tsc.TLS.StartTLSOn = true\n\tsc.TLS.PublicKeyFile = \"tests/testlog\"  // totally wrong :->\n\tsc.TLS.PrivateKeyFile = \"tests/testlog\" // totally wrong :->\n\n\tcfg.Servers = append(cfg.Servers, sc)\n\n\terr := d.SetConfig(cfg)\n\tif err == nil {\n\t\tt.Error(\"SetConfig should have returned an error compalning about bad tls settings\")\n\t\treturn\n\t}\n}\n\nvar funkyLogger = func() backends.Decorator {\n\n\tbackends.Svc.AddInitializer(\n\t\tbackends.InitializeWith(\n\t\t\tfunc(backendConfig backends.BackendConfig) error {\n\t\t\t\tbackends.Log().Info(\"Funky logger is up & down to funk!\")\n\t\t\t\treturn nil\n\t\t\t}),\n\t)\n\n\tbackends.Svc.AddShutdowner(\n\t\tbackends.ShutdownWith(\n\t\t\tfunc() error {\n\t\t\t\tbackends.Log().Info(\"The funk has been stopped!\")\n\t\t\t\treturn nil\n\t\t\t}),\n\t)\n\n\treturn func(p backends.Processor) backends.Processor {\n\t\treturn backends.ProcessWith(\n\t\t\tfunc(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {\n\t\t\t\tif task == backends.TaskValidateRcpt {\n\t\t\t\t\t// log the last recipient appended to e.Rcpt\n\t\t\t\t\tbackends.Log().Infof(\n\t\t\t\t\t\t\"another funky recipient [%s]\",\n\t\t\t\t\t\te.RcptTo[len(e.RcptTo)-1])\n\t\t\t\t\t// if valid then forward call to the next processor in the chain\n\t\t\t\t\treturn p.Process(e, task)\n\t\t\t\t\t// if invalid, return a backend result\n\t\t\t\t\t//return backends.NewResult(response.Canned.FailRcptCmd), nil\n\t\t\t\t} else if task == backends.TaskSaveMail {\n\t\t\t\t\tbackends.Log().Info(\"Another funky email!\")\n\t\t\t\t}\n\t\t\t\treturn p.Process(e, task)\n\t\t\t})\n\t}\n}\n\n// How about a custom processor?\nfunc TestSetAddProcessor(t *testing.T) {\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tcfg := &AppConfig{\n\t\tLogFile:      \"tests/testlog\",\n\t\tAllowedHosts: []string{\"grr.la\"},\n\t\tBackendConfig: backends.BackendConfig{\n\t\t\t\"save_process\":     \"HeadersParser|Debugger|FunkyLogger\",\n\t\t\t\"validate_process\": \"FunkyLogger\",\n\t\t},\n\t}\n\td := Daemon{Config: cfg}\n\td.AddProcessor(\"FunkyLogger\", funkyLogger)\n\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\t// lets have a talk with the server\n\tif err := talkToServer(\"127.0.0.1:2525\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\td.Shutdown()\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\t// lets check for fingerprints\n\tif !strings.Contains(string(b), \"another funky recipient\") {\n\t\tt.Error(\"did not log: another funky recipient\")\n\t}\n\n\tif !strings.Contains(string(b), \"Another funky email!\") {\n\t\tt.Error(\"Did not log: Another funky email!\")\n\t}\n\n\tif !strings.Contains(string(b), \"Funky logger is up & down to funk\") {\n\t\tt.Error(\"Did not log: Funky logger is up & down to funk\")\n\t}\n\tif !strings.Contains(string(b), \"The funk has been stopped!\") {\n\t\tt.Error(\"Did not log:The funk has been stopped!\")\n\t}\n\n}\n\nfunc talkToServer(address string) (err error) {\n\n\tconn, err := net.Dial(\"tcp\", address)\n\tif err != nil {\n\t\treturn\n\t}\n\tin := bufio.NewReader(conn)\n\tstr, err := in.ReadString('\\n')\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"HELO maildiranasaurustester\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstr, err = in.ReadString('\\n')\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"MAIL FROM:<test@example.com>r\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstr, err = in.ReadString('\\n')\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"RCPT TO:<test@grr.la>\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstr, err = in.ReadString('\\n')\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"DATA\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstr, err = in.ReadString('\\n')\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"Subject: Test subject\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \"A an email body\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprint(conn, \".\\r\\n\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstr, err = in.ReadString('\\n')\n\tif err != nil {\n\t\treturn err\n\t}\n\t_ = str\n\treturn nil\n}\n\n// Test hot config reload\n// Here we forgot to add FunkyLogger so backend will fail to init\n// it will log to stderr at the beginning, but then change to tests/testlog\n\nfunc TestReloadConfig(t *testing.T) {\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\td := Daemon{}\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer d.Shutdown()\n\tcfg := AppConfig{\n\t\tLogFile:      \"tests/testlog\",\n\t\tAllowedHosts: []string{\"grr.la\"},\n\t\tBackendConfig: backends.BackendConfig{\n\t\t\t\"save_process\":     \"HeadersParser|Debugger|FunkyLogger\",\n\t\t\t\"validate_process\": \"FunkyLogger\",\n\t\t},\n\t}\n\t// Look mom, reloading the config without shutting down!\n\tif err := d.ReloadConfig(cfg); err != nil {\n\t\tt.Error(err)\n\t}\n\n}\n\nfunc TestPubSubAPI(t *testing.T) {\n\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\n\td := Daemon{Config: &AppConfig{LogFile: \"tests/testlog\"}}\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer d.Shutdown()\n\t// new config\n\tcfg := AppConfig{\n\t\tPidFile:      \"tests/pidfilex.pid\",\n\t\tLogFile:      \"tests/testlog\",\n\t\tAllowedHosts: []string{\"grr.la\"},\n\t\tBackendConfig: backends.BackendConfig{\n\t\t\t\"save_process\":     \"HeadersParser|Debugger|FunkyLogger\",\n\t\t\t\"validate_process\": \"FunkyLogger\",\n\t\t},\n\t}\n\n\tvar i = 0\n\tpidEvHandler := func(c *AppConfig) {\n\t\ti++\n\t\tif i > 1 {\n\t\t\tt.Error(\"number > 1, it means d.Unsubscribe didn't work\")\n\t\t}\n\t\td.Logger.Info(\"number\", i)\n\t}\n\tif err := d.Subscribe(EventConfigPidFile, pidEvHandler); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif err := d.ReloadConfig(cfg); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif err := d.Unsubscribe(EventConfigPidFile, pidEvHandler); err != nil {\n\t\tt.Error(err)\n\t}\n\tcfg.PidFile = \"tests/pidfile2.pid\"\n\td.Publish(EventConfigPidFile, &cfg)\n\tif err := d.ReloadConfig(cfg); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\t// lets interrogate the log\n\tif !strings.Contains(string(b), \"number1\") {\n\t\tt.Error(\"it lools like d.ReloadConfig(cfg) did not fire EventConfigPidFile, pidEvHandler not called\")\n\t}\n\n}\n\nfunc TestAPILog(t *testing.T) {\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\td := Daemon{}\n\tl := d.Log()\n\tl.Info(\"logtest1\") // to stderr\n\tif l.GetLevel() != log.InfoLevel.String() {\n\t\tt.Error(\"Log level does not eq info, it is \", l.GetLevel())\n\t}\n\td.Logger = nil\n\td.Config = &AppConfig{LogFile: \"tests/testlog\"}\n\tl = d.Log()\n\tl.Info(\"logtest1\") // to tests/testlog\n\n\t//\n\tl = d.Log()\n\tif l.GetLogDest() != \"tests/testlog\" {\n\t\tt.Error(\"log dest is not tests/testlog, it was \", l.GetLogDest())\n\t}\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\t// lets interrogate the log\n\tif !strings.Contains(string(b), \"logtest1\") {\n\t\tt.Error(\"hai was not found in the log, it should have been in tests/testlog\")\n\t}\n}\n\n// Test the allowed_hosts config option with a single entry of \".\", which will allow all hosts.\nfunc TestSkipAllowsHost(t *testing.T) {\n\n\td := Daemon{}\n\tdefer d.Shutdown()\n\t// setting the allowed hosts to a single entry with a dot will let any host through\n\td.Config = &AppConfig{AllowedHosts: []string{\".\"}, LogFile: \"off\"}\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tconn, err := net.Dial(\"tcp\", d.Config.Servers[0].ListenInterface)\n\tif err != nil {\n\t\tt.Error(t)\n\t\treturn\n\t}\n\tin := bufio.NewReader(conn)\n\tif _, err := fmt.Fprint(conn, \"HELO test\\r\\n\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err := fmt.Fprint(conn, \"RCPT TO:<test@funkyhost.com>\\r\\n\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err := in.ReadString('\\n'); err != nil {\n\t\tt.Error(err)\n\t}\n\tif _, err := in.ReadString('\\n'); err != nil {\n\t\tt.Error(err)\n\t}\n\tstr, _ := in.ReadString('\\n')\n\tif strings.Index(str, \"250\") != 0 {\n\t\tt.Error(\"expected 250 reply, got:\", str)\n\t}\n\n}\n\nvar customBackend2 = func() backends.Decorator {\n\n\treturn func(p backends.Processor) backends.Processor {\n\t\treturn backends.ProcessWith(\n\t\t\tfunc(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {\n\t\t\t\tif task == backends.TaskValidateRcpt {\n\t\t\t\t\treturn p.Process(e, task)\n\t\t\t\t} else if task == backends.TaskSaveMail {\n\t\t\t\t\tbackends.Log().Info(\"Another funky email!\")\n\t\t\t\t\terr := errors.New(\"system shock\")\n\t\t\t\t\treturn backends.NewResult(response.Canned.FailReadErrorDataCmd, response.SP, err), err\n\t\t\t\t}\n\t\t\t\treturn p.Process(e, task)\n\t\t\t})\n\t}\n}\n\n// Test a custom backend response\nfunc TestCustomBackendResult(t *testing.T) {\n\tif err := os.Truncate(\"tests/testlog\", 0); err != nil {\n\t\tt.Error(err)\n\t}\n\tcfg := &AppConfig{\n\t\tLogFile:      \"tests/testlog\",\n\t\tAllowedHosts: []string{\"grr.la\"},\n\t\tBackendConfig: backends.BackendConfig{\n\t\t\t\"save_process\":     \"HeadersParser|Debugger|Custom\",\n\t\t\t\"validate_process\": \"Custom\",\n\t\t},\n\t}\n\td := Daemon{Config: cfg}\n\td.AddProcessor(\"Custom\", customBackend2)\n\n\tif err := d.Start(); err != nil {\n\t\tt.Error(err)\n\t}\n\t// lets have a talk with the server\n\tif err := talkToServer(\"127.0.0.1:2525\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\td.Shutdown()\n\n\tb, err := ioutil.ReadFile(\"tests/testlog\")\n\tif err != nil {\n\t\tt.Error(\"could not read logfile\")\n\t\treturn\n\t}\n\t// lets check for fingerprints\n\tif !strings.Contains(string(b), \"451 4.3.0 Error\") {\n\t\tt.Error(\"did not log: 451 4.3.0 Error\")\n\t}\n\n\tif !strings.Contains(string(b), \"system shock\") {\n\t\tt.Error(\"did not log: system shock\")\n\t}\n\n}\n"
        },
        {
          "name": "backends",
          "type": "tree",
          "content": null
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 6.333984375,
          "content": "package guerrilla\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/textproto\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"github.com/flashmob/go-guerrilla/mail\"\n\t\"github.com/flashmob/go-guerrilla/mail/rfc5321\"\n\t\"github.com/flashmob/go-guerrilla/response\"\n)\n\n// ClientState indicates which part of the SMTP transaction a given client is in.\ntype ClientState int\n\nconst (\n\t// The client has connected, and is awaiting our first response\n\tClientGreeting = iota\n\t// We have responded to the client's connection and are awaiting a command\n\tClientCmd\n\t// We have received the sender and recipient information\n\tClientData\n\t// We have agreed with the client to secure the connection over TLS\n\tClientStartTLS\n\t// Server will shutdown, client to shutdown on next command turn\n\tClientShutdown\n)\n\ntype client struct {\n\t*mail.Envelope\n\tID          uint64\n\tConnectedAt time.Time\n\tKilledAt    time.Time\n\t// Number of errors encountered during session with this client\n\terrors       int\n\tstate        ClientState\n\tmessagesSent int\n\t// Response to be written to the client (for debugging)\n\tresponse   bytes.Buffer\n\tbufErr     error\n\tconn       net.Conn\n\tbufin      *smtpBufferedReader\n\tbufout     *bufio.Writer\n\tsmtpReader *textproto.Reader\n\tar         *adjustableLimitedReader\n\t// guards access to conn\n\tconnGuard sync.Mutex\n\tlog       log.Logger\n\tparser    rfc5321.Parser\n}\n\n// NewClient allocates a new client.\nfunc NewClient(conn net.Conn, clientID uint64, logger log.Logger, envelope *mail.Pool) *client {\n\tc := &client{\n\t\tconn: conn,\n\t\t// Envelope will be borrowed from the envelope pool\n\t\t// the envelope could be 'detached' from the client later when processing\n\t\tEnvelope:    envelope.Borrow(getRemoteAddr(conn), clientID),\n\t\tConnectedAt: time.Now(),\n\t\tbufin:       newSMTPBufferedReader(conn),\n\t\tbufout:      bufio.NewWriter(conn),\n\t\tID:          clientID,\n\t\tlog:         logger,\n\t}\n\n\t// used for reading the DATA state\n\tc.smtpReader = textproto.NewReader(c.bufin.Reader)\n\treturn c\n}\n\n// sendResponse adds a response to be written on the next turn\n// the response gets buffered\nfunc (c *client) sendResponse(r ...interface{}) {\n\tc.bufout.Reset(c.conn)\n\tif c.log.IsDebug() {\n\t\t// an additional buffer so that we can log the response in debug mode only\n\t\tc.response.Reset()\n\t}\n\tvar out string\n\tif c.bufErr != nil {\n\t\tc.bufErr = nil\n\t}\n\tfor _, item := range r {\n\t\tswitch v := item.(type) {\n\t\tcase error:\n\t\t\tout = v.Error()\n\t\tcase fmt.Stringer:\n\t\t\tout = v.String()\n\t\tcase string:\n\t\t\tout = v\n\t\t}\n\t\tif _, c.bufErr = c.bufout.WriteString(out); c.bufErr != nil {\n\t\t\tc.log.WithError(c.bufErr).Error(\"could not write to c.bufout\")\n\t\t}\n\t\tif c.log.IsDebug() {\n\t\t\tc.response.WriteString(out)\n\t\t}\n\t\tif c.bufErr != nil {\n\t\t\treturn\n\t\t}\n\t}\n\t_, c.bufErr = c.bufout.WriteString(\"\\r\\n\")\n\tif c.log.IsDebug() {\n\t\tc.response.WriteString(\"\\r\\n\")\n\t}\n}\n\n// resetTransaction resets the SMTP transaction, ready for the next email (doesn't disconnect)\n// Transaction ends on:\n// -HELO/EHLO/REST command\n// -End of DATA command\n// TLS handshake\nfunc (c *client) resetTransaction() {\n\tc.Envelope.ResetTransaction()\n}\n\n// isInTransaction returns true if the connection is inside a transaction.\n// A transaction starts after a MAIL command gets issued by the client.\n// Call resetTransaction to end the transaction\nfunc (c *client) isInTransaction() bool {\n\tif len(c.MailFrom.User) == 0 && !c.MailFrom.NullPath {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// kill flags the connection to close on the next turn\nfunc (c *client) kill() {\n\tc.KilledAt = time.Now()\n}\n\n// isAlive returns true if the client is to close on the next turn\nfunc (c *client) isAlive() bool {\n\treturn c.KilledAt.IsZero()\n}\n\n// setTimeout adjust the timeout on the connection, goroutine safe\nfunc (c *client) setTimeout(t time.Duration) (err error) {\n\tdefer c.connGuard.Unlock()\n\tc.connGuard.Lock()\n\tif c.conn != nil {\n\t\terr = c.conn.SetDeadline(time.Now().Add(t * time.Second))\n\t}\n\treturn\n}\n\n// closeConn closes a client connection, , goroutine safe\nfunc (c *client) closeConn() {\n\tdefer c.connGuard.Unlock()\n\tc.connGuard.Lock()\n\t_ = c.conn.Close()\n\tc.conn = nil\n}\n\n// init is called after the client is borrowed from the pool, to get it ready for the connection\nfunc (c *client) init(conn net.Conn, clientID uint64, ep *mail.Pool) {\n\tc.conn = conn\n\t// reset our reader & writer\n\tc.bufout.Reset(conn)\n\tc.bufin.Reset(conn)\n\t// reset session data\n\tc.state = 0\n\tc.KilledAt = time.Time{}\n\tc.ConnectedAt = time.Now()\n\tc.ID = clientID\n\tc.errors = 0\n\t// borrow an envelope from the envelope pool\n\tc.Envelope = ep.Borrow(getRemoteAddr(conn), clientID)\n}\n\n// getID returns the client's unique ID\nfunc (c *client) getID() uint64 {\n\treturn c.ID\n}\n\n// UpgradeToTLS upgrades a client connection to TLS\nfunc (c *client) upgradeToTLS(tlsConfig *tls.Config) error {\n\t// wrap c.conn in a new TLS server side connection\n\ttlsConn := tls.Server(c.conn, tlsConfig)\n\t// Call handshake here to get any handshake error before reading starts\n\terr := tlsConn.Handshake()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// convert tlsConn to net.Conn\n\tc.conn = net.Conn(tlsConn)\n\tc.bufout.Reset(c.conn)\n\tc.bufin.Reset(c.conn)\n\tc.TLS = true\n\treturn err\n}\n\nfunc getRemoteAddr(conn net.Conn) string {\n\tif addr, ok := conn.RemoteAddr().(*net.TCPAddr); ok {\n\t\t// we just want the IP (not the port)\n\t\treturn addr.IP.String()\n\t} else {\n\t\treturn conn.RemoteAddr().Network()\n\t}\n}\n\ntype pathParser func([]byte) error\n\nfunc (c *client) parsePath(in []byte, p pathParser) (mail.Address, error) {\n\taddress := mail.Address{}\n\tvar err error\n\tif len(in) > rfc5321.LimitPath {\n\t\treturn address, errors.New(response.Canned.FailPathTooLong.String())\n\t}\n\tif err = p(in); err != nil {\n\t\treturn address, errors.New(response.Canned.FailInvalidAddress.String())\n\t} else if c.parser.NullPath {\n\t\t// bounce has empty from address\n\t\taddress = mail.Address{}\n\t} else if len(c.parser.LocalPart) > rfc5321.LimitLocalPart {\n\t\terr = errors.New(response.Canned.FailLocalPartTooLong.String())\n\t} else if len(c.parser.Domain) > rfc5321.LimitDomain {\n\t\terr = errors.New(response.Canned.FailDomainTooLong.String())\n\t} else {\n\t\taddress = mail.Address{\n\t\t\tUser:       c.parser.LocalPart,\n\t\t\tHost:       c.parser.Domain,\n\t\t\tADL:        c.parser.ADL,\n\t\t\tPathParams: c.parser.PathParams,\n\t\t\tNullPath:   c.parser.NullPath,\n\t\t\tQuoted:     c.parser.LocalPartQuotes,\n\t\t\tIP:         c.parser.IP,\n\t\t}\n\t}\n\treturn address, err\n}\n\nfunc (s *server) rcptTo() (address mail.Address, err error) {\n\treturn address, err\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 17.140625,
          "content": "package guerrilla\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n)\n\n// AppConfig is the holder of the configuration of the app\ntype AppConfig struct {\n\t// Servers can have one or more items.\n\t/// Defaults to 1 server listening on 127.0.0.1:2525\n\tServers []ServerConfig `json:\"servers\"`\n\t// AllowedHosts lists which hosts to accept email for. Defaults to os.Hostname\n\tAllowedHosts []string `json:\"allowed_hosts\"`\n\t// PidFile is the path for writing out the process id. No output if empty\n\tPidFile string `json:\"pid_file\"`\n\t// LogFile is where the logs go. Use path to file, or \"stderr\", \"stdout\"\n\t// or \"off\". Default \"stderr\"\n\tLogFile string `json:\"log_file,omitempty\"`\n\t// LogLevel controls the lowest level we log.\n\t// \"info\", \"debug\", \"error\", \"panic\". Default \"info\"\n\tLogLevel string `json:\"log_level,omitempty\"`\n\t// BackendConfig configures the email envelope processing backend\n\tBackendConfig backends.BackendConfig `json:\"backend_config\"`\n}\n\n// ServerConfig specifies config options for a single server\ntype ServerConfig struct {\n\t// TLS Configuration\n\tTLS ServerTLSConfig `json:\"tls,omitempty\"`\n\t// LogFile is where the logs go. Use path to file, or \"stderr\", \"stdout\" or \"off\".\n\t// defaults to AppConfig.Log file setting\n\tLogFile string `json:\"log_file,omitempty\"`\n\t// Hostname will be used in the server's reply to HELO/EHLO. If TLS enabled\n\t// make sure that the Hostname matches the cert. Defaults to os.Hostname()\n\t// Hostname will also be used to fill the 'Host' property when the \"RCPT TO\" address is\n\t// addressed to just <postmaster>\n\tHostname string `json:\"host_name\"`\n\t// Listen interface specified in <ip>:<port> - defaults to 127.0.0.1:2525\n\tListenInterface string `json:\"listen_interface\"`\n\t// MaxSize is the maximum size of an email that will be accepted for delivery.\n\t// Defaults to 10 Mebibytes\n\tMaxSize int64 `json:\"max_size\"`\n\t// Timeout specifies the connection timeout in seconds. Defaults to 30\n\tTimeout int `json:\"timeout\"`\n\t// MaxClients controls how many maximum clients we can handle at once.\n\t// Defaults to defaultMaxClients\n\tMaxClients int `json:\"max_clients\"`\n\t// IsEnabled set to true to start the server, false will ignore it\n\tIsEnabled bool `json:\"is_enabled\"`\n\t// XClientOn when using a proxy such as Nginx, XCLIENT command is used to pass the\n\t// original client's IP address & client's HELO\n\tXClientOn bool `json:\"xclient_on,omitempty\"`\n}\n\ntype ServerTLSConfig struct {\n\t// TLS Protocols to use. [0] = min, [1]max\n\t// Use Go's default if empty\n\tProtocols []string `json:\"protocols,omitempty\"`\n\t// TLS Ciphers to use.\n\t// Use Go's default if empty\n\tCiphers []string `json:\"ciphers,omitempty\"`\n\t// TLS Curves to use.\n\t// Use Go's default if empty\n\tCurves []string `json:\"curves,omitempty\"`\n\t// PrivateKeyFile path to cert private key in PEM format.\n\tPrivateKeyFile string `json:\"private_key_file\"`\n\t// PublicKeyFile path to cert (public key) chain in PEM format.\n\tPublicKeyFile string `json:\"public_key_file\"`\n\t// TLS Root cert authorities to use. \"A PEM encoded CA's certificate file.\n\t// Defaults to system's root CA file if empty\n\tRootCAs string `json:\"root_cas_file,omitempty\"`\n\t// declares the policy the server will follow for TLS Client Authentication.\n\t// Use Go's default if empty\n\tClientAuthType string `json:\"client_auth_type,omitempty\"`\n\t// The following used to watch certificate changes so that the TLS can be reloaded\n\t_privateKeyFileMtime int64\n\t_publicKeyFileMtime  int64\n\t// controls whether the server selects the\n\t// client's most preferred cipher suite\n\tPreferServerCipherSuites bool `json:\"prefer_server_cipher_suites,omitempty\"`\n\t// StartTLSOn should we offer STARTTLS command. Cert must be valid.\n\t// False by default\n\tStartTLSOn bool `json:\"start_tls_on,omitempty\"`\n\t// AlwaysOn run this server as a pure TLS server, i.e. SMTPS\n\tAlwaysOn bool `json:\"tls_always_on,omitempty\"`\n}\n\n// https://golang.org/pkg/crypto/tls/#pkg-constants\n// Ciphers introduced before Go 1.7 are listed here,\n// ciphers since Go 1.8, see tls_go1.8.go\n// ....... since Go 1.13, see tls_go1.13.go\nvar TLSCiphers = map[string]uint16{\n\n\t// Note: Generally avoid using CBC unless for compatibility\n\t// The following ciphersuites are not configurable for TLS 1.3\n\t// see tls_go1.13.go for a list of ciphersuites always used in TLS 1.3\n\n\t\"TLS_RSA_WITH_3DES_EDE_CBC_SHA\":        tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,\n\t\"TLS_RSA_WITH_AES_128_CBC_SHA\":         tls.TLS_RSA_WITH_AES_128_CBC_SHA,\n\t\"TLS_RSA_WITH_AES_256_CBC_SHA\":         tls.TLS_RSA_WITH_AES_256_CBC_SHA,\n\t\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\": tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,\n\t\"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\": tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,\n\t\"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\":  tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,\n\t\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\":   tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,\n\t\"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\":   tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,\n\n\t\"TLS_RSA_WITH_RC4_128_SHA\":        tls.TLS_RSA_WITH_RC4_128_SHA,\n\t\"TLS_RSA_WITH_AES_128_GCM_SHA256\": tls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n\t\"TLS_RSA_WITH_AES_256_GCM_SHA384\": tls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\n\t\"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\":        tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,\n\t\"TLS_ECDHE_RSA_WITH_RC4_128_SHA\":          tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,\n\t\"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\": tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\":   tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\": tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\n\t// see tls_go1.13 for new TLS 1.3 ciphersuites\n\t// Note that TLS 1.3 ciphersuites are not configurable\n}\n\n// https://golang.org/pkg/crypto/tls/#pkg-constants\nvar TLSProtocols = map[string]uint16{\n\t\"tls1.0\": tls.VersionTLS10,\n\t\"tls1.1\": tls.VersionTLS11,\n\t\"tls1.2\": tls.VersionTLS12,\n}\n\n// https://golang.org/pkg/crypto/tls/#CurveID\nvar TLSCurves = map[string]tls.CurveID{\n\t\"P256\": tls.CurveP256,\n\t\"P384\": tls.CurveP384,\n\t\"P521\": tls.CurveP521,\n}\n\n// https://golang.org/pkg/crypto/tls/#ClientAuthType\nvar TLSClientAuthTypes = map[string]tls.ClientAuthType{\n\t\"NoClientCert\":               tls.NoClientCert,\n\t\"RequestClientCert\":          tls.RequestClientCert,\n\t\"RequireAnyClientCert\":       tls.RequireAnyClientCert,\n\t\"VerifyClientCertIfGiven\":    tls.VerifyClientCertIfGiven,\n\t\"RequireAndVerifyClientCert\": tls.RequireAndVerifyClientCert,\n}\n\nconst defaultMaxClients = 100\nconst defaultTimeout = 30\nconst defaultInterface = \"127.0.0.1:2525\"\nconst defaultMaxSize = int64(10 << 20) // 10 Mebibytes\n\n// Unmarshalls json data into AppConfig struct and any other initialization of the struct\n// also does validation, returns error if validation failed or something went wrong\nfunc (c *AppConfig) Load(jsonBytes []byte) error {\n\terr := json.Unmarshal(jsonBytes, c)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not parse config file: %s\", err)\n\t}\n\tif err = c.setDefaults(); err != nil {\n\t\treturn err\n\t}\n\tif err = c.setBackendDefaults(); err != nil {\n\t\treturn err\n\t}\n\n\t// all servers must be valid in order to continue\n\tfor _, server := range c.Servers {\n\t\tif errs := server.Validate(); errs != nil {\n\t\t\treturn errs\n\t\t}\n\t}\n\n\t// read the timestamps for the TLS keys, to determine if they need to be reloaded\n\tfor i := 0; i < len(c.Servers); i++ {\n\t\tif err := c.Servers[i].loadTlsKeyTimestamps(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Emits any configuration change events onto the event bus.\nfunc (c *AppConfig) EmitChangeEvents(oldConfig *AppConfig, app Guerrilla) {\n\t// has backend changed?\n\tif !reflect.DeepEqual((*c).BackendConfig, (*oldConfig).BackendConfig) {\n\t\tapp.Publish(EventConfigBackendConfig, c)\n\t}\n\t// has config changed, general check\n\tif !reflect.DeepEqual(oldConfig, c) {\n\t\tapp.Publish(EventConfigNewConfig, c)\n\t}\n\t// has 'allowed hosts' changed?\n\tif !reflect.DeepEqual(oldConfig.AllowedHosts, c.AllowedHosts) {\n\t\tapp.Publish(EventConfigAllowedHosts, c)\n\t}\n\t// has pid file changed?\n\tif strings.Compare(oldConfig.PidFile, c.PidFile) != 0 {\n\t\tapp.Publish(EventConfigPidFile, c)\n\t}\n\t// has mainlog log changed?\n\tif strings.Compare(oldConfig.LogFile, c.LogFile) != 0 {\n\t\tapp.Publish(EventConfigLogFile, c)\n\t}\n\t// has log level changed?\n\tif strings.Compare(oldConfig.LogLevel, c.LogLevel) != 0 {\n\t\tapp.Publish(EventConfigLogLevel, c)\n\t}\n\t// server config changes\n\toldServers := oldConfig.getServers()\n\tfor iface, newServer := range c.getServers() {\n\t\t// is server is in both configs?\n\t\tif oldServer, ok := oldServers[iface]; ok {\n\t\t\t// since old server exists in the new config, we do not track it anymore\n\t\t\tdelete(oldServers, iface)\n\t\t\t// so we know the server exists in both old & new configs\n\t\t\tnewServer.emitChangeEvents(oldServer, app)\n\t\t} else {\n\t\t\t// start new server\n\t\t\tapp.Publish(EventConfigServerNew, newServer)\n\t\t}\n\n\t}\n\t// remove any servers that don't exist anymore\n\tfor _, oldServer := range oldServers {\n\t\tapp.Publish(EventConfigServerRemove, oldServer)\n\t}\n}\n\n// EmitLogReopen emits log reopen events using existing config\nfunc (c *AppConfig) EmitLogReopenEvents(app Guerrilla) {\n\tapp.Publish(EventConfigLogReopen, c)\n\tfor _, sc := range c.getServers() {\n\t\tapp.Publish(EventConfigServerLogReopen, sc)\n\t}\n}\n\n// gets the servers in a map (key by interface) for easy lookup\nfunc (c *AppConfig) getServers() map[string]*ServerConfig {\n\tservers := make(map[string]*ServerConfig, len(c.Servers))\n\tfor i := 0; i < len(c.Servers); i++ {\n\t\tservers[c.Servers[i].ListenInterface] = &c.Servers[i]\n\t}\n\treturn servers\n}\n\n// setDefaults fills in default server settings for values that were not configured\n// The defaults are:\n// * Server listening to 127.0.0.1:2525\n// * use your hostname to determine your which hosts to accept email for\n// * 100 maximum clients\n// * 10MB max message size\n// * log to Stderr,\n// * log level set to \"`debug`\"\n// * timeout to 30 sec\n// * Backend configured with the following processors: `HeadersParser|Header|Debugger`\n// where it will log the received emails.\nfunc (c *AppConfig) setDefaults() error {\n\tif c.LogFile == \"\" {\n\t\tc.LogFile = log.OutputStderr.String()\n\t}\n\tif c.LogLevel == \"\" {\n\t\tc.LogLevel = \"debug\"\n\t}\n\tif len(c.AllowedHosts) == 0 {\n\t\tif h, err := os.Hostname(); err != nil {\n\t\t\treturn err\n\t\t} else {\n\t\t\tc.AllowedHosts = append(c.AllowedHosts, h)\n\t\t}\n\t}\n\th, err := os.Hostname()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(c.Servers) == 0 {\n\t\tsc := ServerConfig{}\n\t\tsc.LogFile = c.LogFile\n\t\tsc.ListenInterface = defaultInterface\n\t\tsc.IsEnabled = true\n\t\tsc.Hostname = h\n\t\tsc.MaxClients = defaultMaxClients\n\t\tsc.Timeout = defaultTimeout\n\t\tsc.MaxSize = defaultMaxSize\n\t\tc.Servers = append(c.Servers, sc)\n\t} else {\n\t\t// make sure each server has defaults correctly configured\n\t\tfor i := range c.Servers {\n\t\t\tif c.Servers[i].Hostname == \"\" {\n\t\t\t\tc.Servers[i].Hostname = h\n\t\t\t}\n\t\t\tif c.Servers[i].MaxClients == 0 {\n\t\t\t\tc.Servers[i].MaxClients = defaultMaxClients\n\t\t\t}\n\t\t\tif c.Servers[i].Timeout == 0 {\n\t\t\t\tc.Servers[i].Timeout = defaultTimeout\n\t\t\t}\n\t\t\tif c.Servers[i].MaxSize == 0 {\n\t\t\t\tc.Servers[i].MaxSize = defaultMaxSize // 10 Mebibytes\n\t\t\t}\n\t\t\tif c.Servers[i].ListenInterface == \"\" {\n\t\t\t\treturn fmt.Errorf(\"listen interface not specified for server at index %d\", i)\n\t\t\t}\n\t\t\tif c.Servers[i].LogFile == \"\" {\n\t\t\t\tc.Servers[i].LogFile = c.LogFile\n\t\t\t}\n\t\t\t// validate the server config\n\t\t\terr = c.Servers[i].Validate()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// setBackendDefaults sets default values for the backend config,\n// if no backend config was added before starting, then use a default config\n// otherwise, see what required values were missed in the config and add any missing with defaults\nfunc (c *AppConfig) setBackendDefaults() error {\n\n\tif len(c.BackendConfig) == 0 {\n\t\th, err := os.Hostname()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.BackendConfig = backends.BackendConfig{\n\t\t\t\"log_received_mails\": true,\n\t\t\t\"save_workers_size\":  1,\n\t\t\t\"save_process\":       \"HeadersParser|Header|Debugger\",\n\t\t\t\"primary_mail_host\":  h,\n\t\t}\n\t} else {\n\t\tif _, ok := c.BackendConfig[\"save_process\"]; !ok {\n\t\t\tc.BackendConfig[\"save_process\"] = \"HeadersParser|Header|Debugger\"\n\t\t}\n\t\tif _, ok := c.BackendConfig[\"primary_mail_host\"]; !ok {\n\t\t\th, err := os.Hostname()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.BackendConfig[\"primary_mail_host\"] = h\n\t\t}\n\t\tif _, ok := c.BackendConfig[\"save_workers_size\"]; !ok {\n\t\t\tc.BackendConfig[\"save_workers_size\"] = 1\n\t\t}\n\n\t\tif _, ok := c.BackendConfig[\"log_received_mails\"]; !ok {\n\t\t\tc.BackendConfig[\"log_received_mails\"] = false\n\t\t}\n\t}\n\treturn nil\n}\n\n// Emits any configuration change events on the server.\n// All events are fired and run synchronously\nfunc (sc *ServerConfig) emitChangeEvents(oldServer *ServerConfig, app Guerrilla) {\n\t// get a list of changes\n\tchanges := getChanges(\n\t\t*oldServer,\n\t\t*sc,\n\t)\n\ttlsChanges := getChanges(\n\t\t(*oldServer).TLS,\n\t\t(*sc).TLS,\n\t)\n\n\tif len(changes) > 0 || len(tlsChanges) > 0 {\n\t\t// something changed in the server config\n\t\tapp.Publish(EventConfigServerConfig, sc)\n\t}\n\n\t// enable or disable?\n\tif _, ok := changes[\"IsEnabled\"]; ok {\n\t\tif sc.IsEnabled {\n\t\t\tapp.Publish(EventConfigServerStart, sc)\n\t\t} else {\n\t\t\tapp.Publish(EventConfigServerStop, sc)\n\t\t}\n\t\t// do not emit any more events when IsEnabled changed\n\t\treturn\n\t}\n\t// log file change?\n\tif _, ok := changes[\"LogFile\"]; ok {\n\t\tapp.Publish(EventConfigServerLogFile, sc)\n\t} else {\n\t\t// since config file has not changed, we reload it\n\t\tapp.Publish(EventConfigServerLogReopen, sc)\n\t}\n\t// timeout changed\n\tif _, ok := changes[\"Timeout\"]; ok {\n\t\tapp.Publish(EventConfigServerTimeout, sc)\n\t}\n\t// max_clients changed\n\tif _, ok := changes[\"MaxClients\"]; ok {\n\t\tapp.Publish(EventConfigServerMaxClients, sc)\n\t}\n\n\tif len(tlsChanges) > 0 {\n\t\tapp.Publish(EventConfigServerTLSConfig, sc)\n\t}\n}\n\n// Loads in timestamps for the TLS keys\nfunc (sc *ServerConfig) loadTlsKeyTimestamps() error {\n\tvar statErr = func(iface string, err error) error {\n\t\treturn fmt.Errorf(\n\t\t\t\"could not stat key for server [%s], %s\",\n\t\t\tiface,\n\t\t\terr.Error())\n\t}\n\tif sc.TLS.PrivateKeyFile == \"\" {\n\t\tsc.TLS._privateKeyFileMtime = time.Now().Unix()\n\t\treturn nil\n\t}\n\tif sc.TLS.PublicKeyFile == \"\" {\n\t\tsc.TLS._publicKeyFileMtime = time.Now().Unix()\n\t\treturn nil\n\t}\n\tif info, err := os.Stat(sc.TLS.PrivateKeyFile); err == nil {\n\t\tsc.TLS._privateKeyFileMtime = info.ModTime().Unix()\n\t} else {\n\t\treturn statErr(sc.ListenInterface, err)\n\t}\n\tif info, err := os.Stat(sc.TLS.PublicKeyFile); err == nil {\n\t\tsc.TLS._publicKeyFileMtime = info.ModTime().Unix()\n\t} else {\n\t\treturn statErr(sc.ListenInterface, err)\n\t}\n\treturn nil\n}\n\n// Validate validates the server's configuration.\nfunc (sc *ServerConfig) Validate() error {\n\tvar errs Errors\n\n\tif sc.TLS.StartTLSOn || sc.TLS.AlwaysOn {\n\t\tif sc.TLS.PublicKeyFile == \"\" {\n\t\t\terrs = append(errs, errors.New(\"PublicKeyFile is empty\"))\n\t\t}\n\t\tif sc.TLS.PrivateKeyFile == \"\" {\n\t\t\terrs = append(errs, errors.New(\"PrivateKeyFile is empty\"))\n\t\t}\n\t\tif _, err := tls.LoadX509KeyPair(sc.TLS.PublicKeyFile, sc.TLS.PrivateKeyFile); err != nil {\n\t\t\terrs = append(errs, fmt.Errorf(\"cannot use TLS config for [%s], %v\", sc.ListenInterface, err))\n\t\t}\n\t}\n\tif len(errs) > 0 {\n\t\treturn errs\n\t}\n\n\treturn nil\n}\n\n// Gets the timestamp of the TLS certificates. Returns a unix time of when they were last modified\n// when the config was read. We use this info to determine if TLS needs to be re-loaded.\nfunc (stc *ServerTLSConfig) getTlsKeyTimestamps() (int64, int64) {\n\treturn stc._privateKeyFileMtime, stc._publicKeyFileMtime\n}\n\n// Returns value changes between struct a & struct b.\n// Results are returned in a map, where each key is the name of the field that was different.\n// a and b are struct values, must not be pointer\n// and of the same struct type\nfunc getChanges(a interface{}, b interface{}) map[string]interface{} {\n\tret := make(map[string]interface{}, 5)\n\tcompareWith := structtomap(b)\n\tfor key, val := range structtomap(a) {\n\t\tif sliceOfStr, ok := val.([]string); ok {\n\t\t\tval, _ = json.Marshal(sliceOfStr)\n\t\t\tval = string(val.([]uint8))\n\t\t}\n\t\tif sliceOfStr, ok := compareWith[key].([]string); ok {\n\t\t\tcompareWith[key], _ = json.Marshal(sliceOfStr)\n\t\t\tcompareWith[key] = string(compareWith[key].([]uint8))\n\t\t}\n\t\tif val != compareWith[key] {\n\t\t\tret[key] = compareWith[key]\n\t\t}\n\t}\n\t// detect changes to TLS keys (have the key files been modified?)\n\tif oldTLS, ok := a.(ServerTLSConfig); ok {\n\t\tt1, t2 := oldTLS.getTlsKeyTimestamps()\n\t\tif newTLS, ok := b.(ServerTLSConfig); ok {\n\t\t\tt3, t4 := newTLS.getTlsKeyTimestamps()\n\t\t\tif t1 != t3 {\n\t\t\t\tret[\"PrivateKeyFile\"] = newTLS.PrivateKeyFile\n\t\t\t}\n\t\t\tif t2 != t4 {\n\t\t\t\tret[\"PublicKeyFile\"] = newTLS.PublicKeyFile\n\t\t\t}\n\t\t}\n\t}\n\treturn ret\n}\n\n// Convert fields of a struct to a map\n// only able to convert int, bool, slice-of-strings and string; not recursive\n// slices are marshal'd to json for convenient comparison later\nfunc structtomap(obj interface{}) map[string]interface{} {\n\tret := make(map[string]interface{})\n\tv := reflect.ValueOf(obj)\n\tt := v.Type()\n\tfor index := 0; index < v.NumField(); index++ {\n\t\tvField := v.Field(index)\n\t\tfName := t.Field(index).Name\n\t\tk := vField.Kind()\n\t\tswitch k {\n\t\tcase reflect.Int:\n\t\t\tfallthrough\n\t\tcase reflect.Int64:\n\t\t\tvalue := vField.Int()\n\t\t\tret[fName] = value\n\t\tcase reflect.String:\n\t\t\tvalue := vField.String()\n\t\t\tret[fName] = value\n\t\tcase reflect.Bool:\n\t\t\tvalue := vField.Bool()\n\t\t\tret[fName] = value\n\t\tcase reflect.Slice:\n\t\t\tret[fName] = vField.Interface().([]string)\n\t\t}\n\t}\n\treturn ret\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 9.017578125,
          "content": "package guerrilla\n\nimport (\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"github.com/flashmob/go-guerrilla/tests/testcert\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\n// a configuration file with a dummy backend\n\n//\nvar configJsonA = `\n{\n    \"log_file\" : \"./tests/testlog\",\n    \"log_level\" : \"debug\",\n    \"pid_file\" : \"tests/go-guerrilla.pid\",\n    \"allowed_hosts\": [\"spam4.me\",\"grr.la\"],\n    \"backend_config\" :\n        {\n            \"log_received_mails\" : true\n        },\n    \"servers\" : [\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.guerrillamail.com\",\n            \"max_size\": 100017,\n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:2526\",\n            \"max_clients\": 2,\n\t\t\t\"tls\" : {\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":false,\n\t\t\t\t\"private_key_file\":\"config_test.go\",\n            \t\"public_key_file\":\"config_test.go\"\n\t\t\t}\n        },\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail2.guerrillamail.com\",\n            \"max_size\":1000001,\n            \"timeout\":180,\n            \"listen_interface\":\"127.0.0.1:2527\",\n\t\t\t\"max_clients\":1,\n\t\t\t\"tls\" : {\n \t\t\t\t\"private_key_file\":\"./tests/mail2.guerrillamail.com.key.pem\",\n            \t\"public_key_file\":\"./tests/mail2.guerrillamail.com.cert.pem\",\n\t\t\t\t\"tls_always_on\":false,\n            \t\"start_tls_on\":true\n\t\t\t}\n        },\n\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.stopme.com\",\n            \"max_size\": 100017, \n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:9999\", \n            \"max_clients\": 2,\n\t\t\t\"tls\" : {\n\t\t\t\t\"private_key_file\":\"config_test.go\",\n            \t\"public_key_file\":\"config_test.go\",\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":false\n\t\t\t}\n        },\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.disableme.com\",\n            \"max_size\": 100017,\n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:3333\",\n            \"max_clients\": 2,\n\t\t\t\"tls\" : { \n\t\t\t\t\"private_key_file\":\"config_test.go\",\n            \t\"public_key_file\":\"config_test.go\",\n\t\t\t\t\"start_tls_on\":false,\n\t\t\t\t\"tls_always_on\":false\n\t\t\t}\n        }\n    ]\n}\n`\n\n// B is A's configuration with different values from B\n// 127.0.0.1:4654 will be added\n// A's 127.0.0.1:3333 is disabled\n// B's 127.0.0.1:9999 is removed\n\nvar configJsonB = `\n{\n    \"log_file\" : \"./tests/testlog\",\n    \"log_level\" : \"debug\",\n    \"pid_file\" : \"tests/different-go-guerrilla.pid\",\n    \"allowed_hosts\": [\"spam4.me\",\"grr.la\",\"newhost.com\"],\n    \"backend_config\" :\n        {\n            \"log_received_mails\" : true\n        },\n    \"servers\" : [\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.guerrillamail.com\",\n            \"max_size\": 100017,\n            \"timeout\":161,\n            \"listen_interface\":\"127.0.0.1:2526\",\n            \"max_clients\": 3,\n\t\t\t\"tls\" : {\n \t\t\t\t\"private_key_file\":\"./tests/mail2.guerrillamail.com.key.pem\",\n            \t\"public_key_file\": \"./tests/mail2.guerrillamail.com.cert.pem\",\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":true\n\t\t\t}\n        },\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail2.guerrillamail.com\",\n            \"max_size\": 100017,\n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:2527\",\n            \"log_file\" : \"./tests/testlog\",\n            \"max_clients\": 2,\n\t\t\t\"tls\" : {\n\t\t\t\t\"private_key_file\":\"./tests/mail2.guerrillamail.com.key.pem\",\n            \t\"public_key_file\": \"./tests/mail2.guerrillamail.com.cert.pem\",\n\t\t\t\t\"start_tls_on\":true,\n            \t\"tls_always_on\":false\n\t\t\t}\n        },\n\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.guerrillamail.com\",\n            \"max_size\":1000001,\n            \"timeout\":180,\n            \"listen_interface\":\"127.0.0.1:4654\",\n            \"max_clients\":1,\n\t\t\t\"tls\" : {\n\t\t\t\t\"private_key_file\":\"config_test.go\",\n\t\t\t\t\"public_key_file\":\"config_test.go\",\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":false\n\t\t\t}\n        },\n\n        {\n            \"is_enabled\" : false,\n            \"host_name\":\"mail.disbaleme.com\",\n            \"max_size\": 100017,\n            \"timeout\":160,\n            \"listen_interface\":\"127.0.0.1:3333\",\n            \"max_clients\": 2,\n\t\t\t\"tls\" : {\n\t\t\t\t\"private_key_file\":\"config_test.go\",\n            \t\"public_key_file\":\"config_test.go\",\n\t\t\t\t\"start_tls_on\":false,\n            \t\"tls_always_on\":false\n\t\t\t}\n        }\n    ]\n}\n`\n\nfunc TestConfigLoad(t *testing.T) {\n\tif err := testcert.GenerateCert(\"mail2.guerrillamail.com\", \"\", 365*24*time.Hour, false, 2048, \"P256\", \"./tests/\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer func() {\n\t\tif err := deleteIfExists(\"../tests/mail2.guerrillamail.com.cert.pem\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif err := deleteIfExists(\"../tests/mail2.guerrillamail.com.key.pem\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\tac := &AppConfig{}\n\tif err := ac.Load([]byte(configJsonA)); err != nil {\n\t\tt.Error(\"Cannot load config |\", err)\n\t\tt.SkipNow()\n\t}\n\texpectedLen := 4\n\tif len(ac.Servers) != expectedLen {\n\t\tt.Error(\"len(ac.Servers), expected\", expectedLen, \"got\", len(ac.Servers))\n\t\tt.SkipNow()\n\t}\n\t// did we got the timestamps?\n\tif ac.Servers[0].TLS._privateKeyFileMtime <= 0 {\n\t\tt.Error(\"failed to read timestamp for _privateKeyFileMtime, got\", ac.Servers[0].TLS._privateKeyFileMtime)\n\t}\n}\n\n// Test the sample config to make sure a valid one is given!\nfunc TestSampleConfig(t *testing.T) {\n\tfileName := \"goguerrilla.conf.sample\"\n\tif jsonBytes, err := ioutil.ReadFile(fileName); err == nil {\n\t\tac := &AppConfig{}\n\t\tif err := ac.Load(jsonBytes); err != nil {\n\t\t\t// sample config can have broken tls certs\n\t\t\tif strings.Index(err.Error(), \"cannot use TLS config for [127.0.0.1:25\") != 0 {\n\t\t\t\tt.Error(\"Cannot load config\", fileName, \"|\", err)\n\t\t\t\tt.FailNow()\n\t\t\t}\n\t\t}\n\t} else {\n\t\tt.Error(\"Error reading\", fileName, \"|\", err)\n\t}\n}\n\n// make sure that we get all the config change events\nfunc TestConfigChangeEvents(t *testing.T) {\n\tif err := testcert.GenerateCert(\"mail2.guerrillamail.com\", \"\", 365*24*time.Hour, false, 2048, \"P256\", \"./tests/\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer func() {\n\t\tif err := deleteIfExists(\"../tests/mail2.guerrillamail.com.cert.pem\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif err := deleteIfExists(\"../tests/mail2.guerrillamail.com.key.pem\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\toldconf := &AppConfig{}\n\tif err := oldconf.Load([]byte(configJsonA)); err != nil {\n\t\tt.Error(err)\n\t}\n\tlogger, _ := log.GetLogger(oldconf.LogFile, oldconf.LogLevel)\n\tbcfg := backends.BackendConfig{\"log_received_mails\": true}\n\tbackend, err := backends.New(bcfg, logger)\n\tif err != nil {\n\t\tt.Error(\"cannot create backend\", err)\n\t}\n\tapp, err := New(oldconf, backend, logger)\n\tif err != nil {\n\t\tt.Error(\"cannot create daemon\", err)\n\t}\n\t// simulate timestamp change\n\n\ttime.Sleep(time.Second + time.Millisecond*500)\n\tif err := os.Chtimes(oldconf.Servers[1].TLS.PrivateKeyFile, time.Now(), time.Now()); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := os.Chtimes(oldconf.Servers[1].TLS.PublicKeyFile, time.Now(), time.Now()); err != nil {\n\t\tt.Error(err)\n\t}\n\tnewconf := &AppConfig{}\n\tif err := newconf.Load([]byte(configJsonB)); err != nil {\n\t\tt.Error(err)\n\t}\n\tnewconf.Servers[0].LogFile = log.OutputOff.String() // test for log file change\n\tnewconf.LogLevel = log.InfoLevel.String()\n\tnewconf.LogFile = \"off\"\n\texpectedEvents := map[Event]bool{\n\t\tEventConfigPidFile:         false,\n\t\tEventConfigLogFile:         false,\n\t\tEventConfigLogLevel:        false,\n\t\tEventConfigAllowedHosts:    false,\n\t\tEventConfigServerNew:       false, // 127.0.0.1:4654 will be added\n\t\tEventConfigServerRemove:    false, // 127.0.0.1:9999 server removed\n\t\tEventConfigServerStop:      false, // 127.0.0.1:3333: server (disabled)\n\t\tEventConfigServerLogFile:   false, // 127.0.0.1:2526\n\t\tEventConfigServerLogReopen: false, // 127.0.0.1:2527\n\t\tEventConfigServerTimeout:   false, // 127.0.0.1:2526 timeout\n\t\t//\"server_change:tls_config\":    false, // 127.0.0.1:2526\n\t\tEventConfigServerMaxClients: false, // 127.0.0.1:2526\n\t\tEventConfigServerTLSConfig:  false, // 127.0.0.1:2527 timestamp changed on certificates\n\t}\n\ttoUnsubscribe := map[Event]func(c *AppConfig){}\n\ttoUnsubscribeSrv := map[Event]func(c *ServerConfig){}\n\n\tfor event := range expectedEvents {\n\t\t// Put in anon func since range is overwriting event\n\t\tfunc(e Event) {\n\t\t\tif strings.Contains(e.String(), \"config_change\") {\n\t\t\t\tf := func(c *AppConfig) {\n\t\t\t\t\texpectedEvents[e] = true\n\t\t\t\t}\n\t\t\t\t_ = app.Subscribe(event, f)\n\t\t\t\ttoUnsubscribe[event] = f\n\t\t\t} else {\n\t\t\t\t// must be a server config change then\n\t\t\t\tf := func(c *ServerConfig) {\n\t\t\t\t\texpectedEvents[e] = true\n\t\t\t\t}\n\t\t\t\t_ = app.Subscribe(event, f)\n\t\t\t\ttoUnsubscribeSrv[event] = f\n\t\t\t}\n\n\t\t}(event)\n\t}\n\n\t// emit events\n\tnewconf.EmitChangeEvents(oldconf, app)\n\t// unsubscribe\n\tfor unevent, unfun := range toUnsubscribe {\n\t\t_ = app.Unsubscribe(unevent, unfun)\n\t}\n\tfor unevent, unfun := range toUnsubscribeSrv {\n\t\t_ = app.Unsubscribe(unevent, unfun)\n\t}\n\tfor event, val := range expectedEvents {\n\t\tif val == false {\n\t\t\tt.Error(\"Did not fire config change event:\", event)\n\t\t\tt.FailNow()\n\t\t}\n\t}\n\n\t// don't forget to reset\n\tif err := os.Truncate(oldconf.LogFile, 0); err != nil {\n\t\tt.Error(err)\n\t}\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 2.1337890625,
          "content": "package guerrilla\n\nimport (\n\tevbus \"github.com/asaskevich/EventBus\"\n)\n\ntype Event int\n\nconst (\n\t// when a new config was loaded\n\tEventConfigNewConfig Event = iota\n\t// when allowed_hosts changed\n\tEventConfigAllowedHosts\n\t// when pid_file changed\n\tEventConfigPidFile\n\t// when log_file changed\n\tEventConfigLogFile\n\t// when it's time to reload the main log file\n\tEventConfigLogReopen\n\t// when log level changed\n\tEventConfigLogLevel\n\t// when the backend's config changed\n\tEventConfigBackendConfig\n\t// when a new server was added\n\tEventConfigServerNew\n\t// when an existing server was removed\n\tEventConfigServerRemove\n\t// when a new server config was detected (general event)\n\tEventConfigServerConfig\n\t// when a server was enabled\n\tEventConfigServerStart\n\t// when a server was disabled\n\tEventConfigServerStop\n\t// when a server's log file changed\n\tEventConfigServerLogFile\n\t// when it's time to reload the server's log\n\tEventConfigServerLogReopen\n\t// when a server's timeout changed\n\tEventConfigServerTimeout\n\t// when a server's max clients changed\n\tEventConfigServerMaxClients\n\t// when a server's TLS config changed\n\tEventConfigServerTLSConfig\n)\n\nvar eventList = [...]string{\n\t\"config_change:new_config\",\n\t\"config_change:allowed_hosts\",\n\t\"config_change:pid_file\",\n\t\"config_change:log_file\",\n\t\"config_change:reopen_log_file\",\n\t\"config_change:log_level\",\n\t\"config_change:backend_config\",\n\t\"server_change:new_server\",\n\t\"server_change:remove_server\",\n\t\"server_change:update_config\",\n\t\"server_change:start_server\",\n\t\"server_change:stop_server\",\n\t\"server_change:new_log_file\",\n\t\"server_change:reopen_log_file\",\n\t\"server_change:timeout\",\n\t\"server_change:max_clients\",\n\t\"server_change:tls_config\",\n}\n\nfunc (e Event) String() string {\n\treturn eventList[e]\n}\n\ntype EventHandler struct {\n\tevbus.Bus\n}\n\nfunc (h *EventHandler) Subscribe(topic Event, fn interface{}) error {\n\tif h.Bus == nil {\n\t\th.Bus = evbus.New()\n\t}\n\treturn h.Bus.Subscribe(topic.String(), fn)\n}\n\nfunc (h *EventHandler) Publish(topic Event, args ...interface{}) {\n\th.Bus.Publish(topic.String(), args...)\n}\n\nfunc (h *EventHandler) Unsubscribe(topic Event, handler interface{}) error {\n\treturn h.Bus.Unsubscribe(topic.String(), handler)\n}\n"
        },
        {
          "name": "goguerrilla.conf.sample",
          "type": "blob",
          "size": 2.7783203125,
          "content": "{\n    \"log_file\" : \"stderr\",\n    \"log_level\" : \"info\",\n    \"allowed_hosts\": [\n      \"guerrillamail.com\",\n      \"guerrillamailblock.com\",\n      \"sharklasers.com\",\n      \"guerrillamail.net\",\n      \"guerrillamail.org\"\n    ],\n    \"pid_file\" : \"/var/run/go-guerrilla.pid\",\n    \"backend_config\": {\n        \"log_received_mails\": true,\n        \"save_workers_size\": 1,\n        \"save_process\" : \"HeadersParser|Header|Debugger\",\n        \"primary_mail_host\" : \"mail.example.com\",\n        \"gw_save_timeout\" : \"30s\",\n        \"gw_val_rcpt_timeout\" : \"3s\"\n    },\n    \"servers\" : [\n        {\n            \"is_enabled\" : true,\n            \"host_name\":\"mail.test.com\",\n            \"max_size\": 1000000,\n            \"timeout\":180,\n            \"listen_interface\":\"127.0.0.1:25\",\n            \"max_clients\": 1000,\n            \"log_file\" : \"stderr\",\n            \"tls\" : {\n                \"start_tls_on\":true,\n                \"tls_always_on\":false,\n                \"private_key_file\":\"/path/to/pem/file/test.com.key\",\n                \"public_key_file\":\"/path/to/pem/file/test.com.crt\",\n                \"protocols\" : [\"tls1.0\", \"tls1.2\"],\n                \"ciphers\" : [\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_RSA_WITH_RC4_128_SHA\", \"TLS_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\", \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\"],\n                \"curves\" : [\"P256\", \"P384\", \"P521\", \"X25519\"],\n                \"client_auth_type\" : \"NoClientCert\"\n            }\n        },\n        {\n            \"is_enabled\" : false,\n            \"host_name\":\"mail.test.com\",\n            \"max_size\":1000000,\n            \"timeout\":180,\n            \"listen_interface\":\"127.0.0.1:465\",\n            \"max_clients\":500,\n            \"log_file\" : \"stderr\",\n            \"tls\" : {\n                \"private_key_file\":\"/path/to/pem/file/test.com.key\",\n                \"public_key_file\":\"/path/to/pem/file/test.com.crt\",\n                 \"start_tls_on\":false,\n                 \"tls_always_on\":true,\n                 \"protocols\" : [\"tls1.0\", \"tls1.2\"],\n                 \"ciphers\" : [\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\", \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\", \"TLS_RSA_WITH_RC4_128_SHA\", \"TLS_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\", \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\", \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\"],\n                 \"curves\" : [\"P256\", \"P384\", \"P521\", \"X25519\"],\n                 \"client_auth_type\" : \"NoClientCert\"\n            }\n        }\n    ]\n}\n"
        },
        {
          "name": "guerrilla.go",
          "type": "blob",
          "size": 15.8662109375,
          "content": "package guerrilla\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n)\n\nconst (\n\t// all configured servers were just been created\n\tdaemonStateNew = iota\n\t// ... been started and running\n\tdaemonStateStarted\n\t// ... been stopped\n\tdaemonStateStopped\n)\n\ntype Errors []error\n\n// implement the Error interface\nfunc (e Errors) Error() string {\n\tif len(e) == 1 {\n\t\treturn e[0].Error()\n\t}\n\t// multiple errors\n\tmsg := \"\"\n\tfor _, err := range e {\n\t\tmsg += \"\\n\" + err.Error()\n\t}\n\treturn msg\n}\n\ntype Guerrilla interface {\n\tStart() error\n\tShutdown()\n\tSubscribe(topic Event, fn interface{}) error\n\tPublish(topic Event, args ...interface{})\n\tUnsubscribe(topic Event, handler interface{}) error\n\tSetLogger(log.Logger)\n}\n\ntype guerrilla struct {\n\tConfig  AppConfig\n\tservers map[string]*server\n\t// guard controls access to g.servers\n\tguard sync.Mutex\n\tstate int8\n\tEventHandler\n\tlogStore\n\tbackendStore\n}\n\ntype logStore struct {\n\tatomic.Value\n}\n\ntype backendStore struct {\n\tatomic.Value\n}\n\ntype daemonEvent func(c *AppConfig)\ntype serverEvent func(sc *ServerConfig)\n\n// Get loads the log.logger in an atomic operation. Returns a stderr logger if not able to load\nfunc (ls *logStore) mainlog() log.Logger {\n\tif v, ok := ls.Load().(log.Logger); ok {\n\t\treturn v\n\t}\n\tl, _ := log.GetLogger(log.OutputStderr.String(), log.InfoLevel.String())\n\treturn l\n}\n\n// setMainlog stores the log value in an atomic operation\nfunc (ls *logStore) setMainlog(log log.Logger) {\n\tls.Store(log)\n}\n\n// Returns a new instance of Guerrilla with the given config, not yet running. Backend started.\nfunc New(ac *AppConfig, b backends.Backend, l log.Logger) (Guerrilla, error) {\n\tg := &guerrilla{\n\t\tConfig:  *ac, // take a local copy\n\t\tservers: make(map[string]*server, len(ac.Servers)),\n\t}\n\tg.backendStore.Store(b)\n\tg.setMainlog(l)\n\n\tif ac.LogLevel != \"\" {\n\t\tif h, ok := l.(*log.HookedLogger); ok {\n\t\t\tif h, err := log.GetLogger(h.GetLogDest(), ac.LogLevel); err == nil {\n\t\t\t\tg.setMainlog(h)\n\t\t\t}\n\t\t}\n\t}\n\t// Write the process id (pid) to a file\n\t// we should still be able to continue even if we can't write the pid, error will be logged by writePid()\n\t_ = g.writePid()\n\n\tg.state = daemonStateNew\n\terr := g.makeServers()\n\tif err != nil {\n\t\treturn g, err\n\t}\n\n\t// start backend for processing email\n\terr = g.backend().Start()\n\tif err != nil {\n\t\treturn g, err\n\t}\n\n\t// subscribe for any events that may come in while running\n\tg.subscribeEvents()\n\n\treturn g, err\n}\n\n// Instantiate servers\nfunc (g *guerrilla) makeServers() error {\n\tg.mainlog().Debug(\"making servers\")\n\tvar errs Errors\n\tfor _, sc := range g.Config.Servers {\n\t\tif _, ok := g.servers[sc.ListenInterface]; ok {\n\t\t\t// server already instantiated\n\t\t\tcontinue\n\t\t}\n\t\tif err := sc.Validate(); err != nil {\n\t\t\tg.mainlog().WithError(errs).Errorf(\"Failed to create server [%s]\", sc.ListenInterface)\n\t\t\terrs = append(errs, err)\n\t\t\tcontinue\n\t\t} else {\n\t\t\tsc := sc // pin!\n\t\t\tserver, err := newServer(&sc, g.backend(), g.mainlog())\n\t\t\tif err != nil {\n\t\t\t\tg.mainlog().WithError(err).Errorf(\"Failed to create server [%s]\", sc.ListenInterface)\n\t\t\t\terrs = append(errs, err)\n\t\t\t}\n\t\t\tif server != nil {\n\t\t\t\tg.servers[sc.ListenInterface] = server\n\t\t\t\tserver.setAllowedHosts(g.Config.AllowedHosts)\n\t\t\t}\n\t\t}\n\t}\n\tif len(g.servers) == 0 {\n\t\terrs = append(errs, errors.New(\"there are no servers that can start, please check your config\"))\n\t}\n\tif len(errs) == 0 {\n\t\treturn nil\n\t}\n\treturn errs\n}\n\n// findServer finds a server by iface (interface), retuning the server or err\nfunc (g *guerrilla) findServer(iface string) (*server, error) {\n\tg.guard.Lock()\n\tdefer g.guard.Unlock()\n\tif server, ok := g.servers[iface]; ok {\n\t\treturn server, nil\n\t}\n\treturn nil, errors.New(\"server not found in g.servers\")\n}\n\n// removeServer removes a server from the list of servers\nfunc (g *guerrilla) removeServer(iface string) {\n\tg.guard.Lock()\n\tdefer g.guard.Unlock()\n\tdelete(g.servers, iface)\n}\n\n// setConfig sets the app config\nfunc (g *guerrilla) setConfig(c *AppConfig) {\n\tg.guard.Lock()\n\tdefer g.guard.Unlock()\n\tg.Config = *c\n}\n\n// setServerConfig config updates the server's config, which will update for the next connected client\nfunc (g *guerrilla) setServerConfig(sc *ServerConfig) {\n\tg.guard.Lock()\n\tdefer g.guard.Unlock()\n\tif _, ok := g.servers[sc.ListenInterface]; ok {\n\t\tg.servers[sc.ListenInterface].setConfig(sc)\n\t}\n}\n\n// mapServers calls a callback on each server in g.servers map\n// It locks the g.servers map before mapping\nfunc (g *guerrilla) mapServers(callback func(*server)) map[string]*server {\n\tdefer g.guard.Unlock()\n\tg.guard.Lock()\n\tfor _, server := range g.servers {\n\t\tcallback(server)\n\t}\n\treturn g.servers\n}\n\n// subscribeEvents subscribes event handlers for configuration change events\nfunc (g *guerrilla) subscribeEvents() {\n\n\tevents := map[Event]interface{}{}\n\t// main config changed\n\tevents[EventConfigNewConfig] = daemonEvent(func(c *AppConfig) {\n\t\tg.setConfig(c)\n\t})\n\t// allowed_hosts changed, set for all servers\n\tevents[EventConfigAllowedHosts] = daemonEvent(func(c *AppConfig) {\n\t\tg.mapServers(func(server *server) {\n\t\t\tserver.setAllowedHosts(c.AllowedHosts)\n\t\t})\n\t\tg.mainlog().Infof(\"allowed_hosts config changed, a new list was set\")\n\t})\n\n\t// the main log file changed\n\tevents[EventConfigLogFile] = daemonEvent(func(c *AppConfig) {\n\t\tvar err error\n\t\tvar l log.Logger\n\t\tif l, err = log.GetLogger(c.LogFile, c.LogLevel); err == nil {\n\t\t\tg.setMainlog(l)\n\t\t\tg.mapServers(func(server *server) {\n\t\t\t\t// it will change server's logger when the next client gets accepted\n\t\t\t\tserver.mainlogStore.Store(l)\n\t\t\t})\n\t\t\tg.mainlog().Infof(\"main log for new clients changed to [%s]\", c.LogFile)\n\t\t} else {\n\t\t\tg.mainlog().WithError(err).Errorf(\"main logging change failed [%s]\", c.LogFile)\n\t\t}\n\n\t})\n\n\t// re-open the main log file (file not changed)\n\tevents[EventConfigLogReopen] = daemonEvent(func(c *AppConfig) {\n\t\terr := g.mainlog().Reopen()\n\t\tif err != nil {\n\t\t\tg.mainlog().WithError(err).Errorf(\"main log file [%s] failed to re-open\", c.LogFile)\n\t\t\treturn\n\t\t}\n\t\tg.mainlog().Infof(\"re-opened main log file [%s]\", c.LogFile)\n\t})\n\n\t// when log level changes, apply to mainlog and server logs\n\tevents[EventConfigLogLevel] = daemonEvent(func(c *AppConfig) {\n\t\tl, err := log.GetLogger(g.mainlog().GetLogDest(), c.LogLevel)\n\t\tif err == nil {\n\t\t\tg.logStore.Store(l)\n\t\t\tg.mapServers(func(server *server) {\n\t\t\t\tserver.logStore.Store(l)\n\t\t\t})\n\t\t\tg.mainlog().Infof(\"log level changed to [%s]\", c.LogLevel)\n\t\t}\n\t})\n\n\t// write out our pid whenever the file name changes in the config\n\tevents[EventConfigPidFile] = daemonEvent(func(ac *AppConfig) {\n\t\t_ = g.writePid()\n\t})\n\n\t// server config was updated\n\tevents[EventConfigServerConfig] = serverEvent(func(sc *ServerConfig) {\n\t\tg.setServerConfig(sc)\n\t\tg.mainlog().Infof(\"server %s config change event, a new config has been saved\", sc.ListenInterface)\n\t})\n\n\t// add a new server to the config & start\n\tevents[EventConfigServerNew] = serverEvent(func(sc *ServerConfig) {\n\t\tg.mainlog().Debugf(\"event fired [%s] %s\", EventConfigServerNew, sc.ListenInterface)\n\t\tif _, err := g.findServer(sc.ListenInterface); err != nil {\n\t\t\t// not found, lets add it\n\t\t\t//\n\t\t\tif err := g.makeServers(); err != nil {\n\t\t\t\tg.mainlog().WithError(err).Errorf(\"cannot add server [%s]\", sc.ListenInterface)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tg.mainlog().Infof(\"New server added [%s]\", sc.ListenInterface)\n\t\t\tif g.state == daemonStateStarted {\n\t\t\t\terr := g.Start()\n\t\t\t\tif err != nil {\n\t\t\t\t\tg.mainlog().WithError(err).Info(\"Event server_change:new_server returned errors when starting\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tg.mainlog().Debugf(\"new event, but server already fund\")\n\t\t}\n\t})\n\n\t// start a server that already exists in the config and has been enabled\n\tevents[EventConfigServerStart] = serverEvent(func(sc *ServerConfig) {\n\t\tif server, err := g.findServer(sc.ListenInterface); err == nil {\n\t\t\tif server.state == ServerStateStopped || server.state == ServerStateNew {\n\t\t\t\tg.mainlog().Infof(\"Starting server [%s]\", server.listenInterface)\n\t\t\t\terr := g.Start()\n\t\t\t\tif err != nil {\n\t\t\t\t\tg.mainlog().WithError(err).Info(\"Event server_change:start_server returned errors when starting\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// stop running a server\n\tevents[EventConfigServerStop] = serverEvent(func(sc *ServerConfig) {\n\t\tif server, err := g.findServer(sc.ListenInterface); err == nil {\n\t\t\tif server.state == ServerStateRunning {\n\t\t\t\tserver.Shutdown()\n\t\t\t\tg.mainlog().Infof(\"Server [%s] stopped.\", sc.ListenInterface)\n\t\t\t}\n\t\t}\n\t})\n\n\t// server was removed from config\n\tevents[EventConfigServerRemove] = serverEvent(func(sc *ServerConfig) {\n\t\tif server, err := g.findServer(sc.ListenInterface); err == nil {\n\t\t\tserver.Shutdown()\n\t\t\tg.removeServer(sc.ListenInterface)\n\t\t\tg.mainlog().Infof(\"Server [%s] removed from config, stopped it.\", sc.ListenInterface)\n\t\t}\n\t})\n\n\t// TLS changes\n\tevents[EventConfigServerTLSConfig] = serverEvent(func(sc *ServerConfig) {\n\t\tif server, err := g.findServer(sc.ListenInterface); err == nil {\n\t\t\tif err := server.configureTLS(); err == nil {\n\t\t\t\tg.mainlog().Infof(\"Server [%s] new TLS configuration loaded\", sc.ListenInterface)\n\t\t\t} else {\n\t\t\t\tg.mainlog().WithError(err).Errorf(\"Server [%s] failed to load the new TLS configuration\", sc.ListenInterface)\n\t\t\t}\n\t\t}\n\t})\n\t// when server's timeout change.\n\tevents[EventConfigServerTimeout] = serverEvent(func(sc *ServerConfig) {\n\t\tg.mapServers(func(server *server) {\n\t\t\tserver.setTimeout(sc.Timeout)\n\t\t})\n\t})\n\t// when server's max clients change.\n\tevents[EventConfigServerMaxClients] = serverEvent(func(sc *ServerConfig) {\n\t\tg.mapServers(func(server *server) {\n\t\t\t// TODO resize the pool somehow\n\t\t})\n\t})\n\t// when a server's log file changes\n\tevents[EventConfigServerLogFile] = serverEvent(func(sc *ServerConfig) {\n\t\tif server, err := g.findServer(sc.ListenInterface); err == nil {\n\t\t\tvar err error\n\t\t\tvar l log.Logger\n\t\t\tlevel := g.mainlog().GetLevel()\n\t\t\tif l, err = log.GetLogger(sc.LogFile, level); err == nil {\n\t\t\t\tg.setMainlog(l)\n\t\t\t\tbackends.Svc.SetMainlog(l)\n\t\t\t\t// it will change to the new logger on the next accepted client\n\t\t\t\tserver.logStore.Store(l)\n\t\t\t\tg.mainlog().Infof(\"Server [%s] changed, new clients will log to: [%s]\",\n\t\t\t\t\tsc.ListenInterface,\n\t\t\t\t\tsc.LogFile,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tg.mainlog().WithError(err).Errorf(\n\t\t\t\t\t\"Server [%s] log change failed to: [%s]\",\n\t\t\t\t\tsc.ListenInterface,\n\t\t\t\t\tsc.LogFile,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t})\n\t// when the daemon caught a sighup, event for individual server\n\tevents[EventConfigServerLogReopen] = serverEvent(func(sc *ServerConfig) {\n\t\tif server, err := g.findServer(sc.ListenInterface); err == nil {\n\t\t\tif err = server.log().Reopen(); err != nil {\n\t\t\t\tg.mainlog().WithError(err).Errorf(\"server [%s] log file [%s] failed to re-open\", sc.ListenInterface, sc.LogFile)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tg.mainlog().Infof(\"Server [%s] re-opened log file [%s]\", sc.ListenInterface, sc.LogFile)\n\t\t}\n\t})\n\t// when the backend changes\n\tevents[EventConfigBackendConfig] = daemonEvent(func(appConfig *AppConfig) {\n\t\tlogger, _ := log.GetLogger(appConfig.LogFile, appConfig.LogLevel)\n\t\t// shutdown the backend first.\n\t\tvar err error\n\t\tif err = g.backend().Shutdown(); err != nil {\n\t\t\tlogger.WithError(err).Warn(\"Backend failed to shutdown\")\n\t\t\treturn\n\t\t}\n\t\t// init a new backend, Revert to old backend config if it fails\n\t\tif newBackend, newErr := backends.New(appConfig.BackendConfig, logger); newErr != nil {\n\t\t\tlogger.WithError(newErr).Error(\"Error while loading the backend\")\n\t\t\terr = g.backend().Reinitialize()\n\t\t\tif err != nil {\n\t\t\t\tlogger.WithError(err).Fatal(\"failed to revert to old backend config\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = g.backend().Start()\n\t\t\tif err != nil {\n\t\t\t\tlogger.WithError(err).Fatal(\"failed to start backend with old config\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlogger.Info(\"reverted to old backend config\")\n\t\t} else {\n\t\t\t// swap to the bew backend (assuming old backend was shutdown so it can be safely swapped)\n\t\t\tif err := newBackend.Start(); err != nil {\n\t\t\t\tlogger.WithError(err).Error(\"backend could not start\")\n\t\t\t}\n\t\t\tlogger.Info(\"new backend started\")\n\t\t\tg.storeBackend(newBackend)\n\t\t}\n\t})\n\tvar err error\n\tfor topic, fn := range events {\n\t\tswitch f := fn.(type) {\n\t\tcase daemonEvent:\n\t\t\terr = g.Subscribe(topic, f)\n\t\tcase serverEvent:\n\t\t\terr = g.Subscribe(topic, f)\n\t\t}\n\t\tif err != nil {\n\t\t\tg.mainlog().WithError(err).Errorf(\"failed to subscribe on topic [%s]\", topic)\n\t\t\tbreak\n\t\t}\n\t}\n\n}\n\nfunc (g *guerrilla) storeBackend(b backends.Backend) {\n\tg.backendStore.Store(b)\n\tg.mapServers(func(server *server) {\n\t\tserver.setBackend(b)\n\t})\n}\n\nfunc (g *guerrilla) backend() backends.Backend {\n\tif b, ok := g.backendStore.Load().(backends.Backend); ok {\n\t\treturn b\n\t}\n\treturn nil\n}\n\n// Entry point for the application. Starts all servers.\nfunc (g *guerrilla) Start() error {\n\tvar startErrors Errors\n\tg.guard.Lock()\n\tdefer func() {\n\t\tg.state = daemonStateStarted\n\t\tg.guard.Unlock()\n\t}()\n\tif len(g.servers) == 0 {\n\t\treturn append(startErrors, errors.New(\"no servers to start, please check the config\"))\n\t}\n\tif g.state == daemonStateStopped {\n\t\t// when a backend is shutdown, we need to re-initialize before it can be started again\n\t\tif err := g.backend().Reinitialize(); err != nil {\n\t\t\tstartErrors = append(startErrors, err)\n\t\t}\n\t\tif err := g.backend().Start(); err != nil {\n\t\t\tstartErrors = append(startErrors, err)\n\t\t}\n\t}\n\t// channel for reading errors\n\terrs := make(chan error, len(g.servers))\n\tvar startWG sync.WaitGroup\n\n\t// start servers, send any errors back to errs channel\n\tfor ListenInterface := range g.servers {\n\t\tif !g.servers[ListenInterface].isEnabled() {\n\t\t\t// not enabled\n\t\t\tcontinue\n\t\t}\n\t\tif g.servers[ListenInterface].state != ServerStateNew &&\n\t\t\tg.servers[ListenInterface].state != ServerStateStopped {\n\t\t\tcontinue\n\t\t}\n\t\tstartWG.Add(1)\n\t\tgo func(s *server) {\n\t\t\tg.mainlog().Infof(\"Starting: %s\", s.listenInterface)\n\t\t\tif err := s.Start(&startWG); err != nil {\n\t\t\t\terrs <- err\n\t\t\t}\n\t\t}(g.servers[ListenInterface])\n\t}\n\t// wait for all servers to start (or fail)\n\tstartWG.Wait()\n\n\t// close, then read any errors\n\tclose(errs)\n\tfor err := range errs {\n\t\tif err != nil {\n\t\t\tstartErrors = append(startErrors, err)\n\t\t}\n\t}\n\tif len(startErrors) > 0 {\n\t\treturn startErrors\n\t}\n\treturn nil\n}\n\nfunc (g *guerrilla) Shutdown() {\n\n\t// shut down the servers first\n\tg.mapServers(func(s *server) {\n\t\tif s.state == ServerStateRunning {\n\t\t\ts.Shutdown()\n\t\t\tg.mainlog().Infof(\"shutdown completed for [%s]\", s.listenInterface)\n\t\t}\n\t})\n\n\tg.guard.Lock()\n\tdefer func() {\n\t\tg.state = daemonStateStopped\n\t\tdefer g.guard.Unlock()\n\t}()\n\tif err := g.backend().Shutdown(); err != nil {\n\t\tg.mainlog().WithError(err).Warn(\"Backend failed to shutdown\")\n\t} else {\n\t\tg.mainlog().Infof(\"Backend shutdown completed\")\n\t}\n}\n\n// SetLogger sets the logger for the app and propagates it to sub-packages (eg.\nfunc (g *guerrilla) SetLogger(l log.Logger) {\n\tg.setMainlog(l)\n\tbackends.Svc.SetMainlog(l)\n}\n\n// writePid writes the pid (process id) to the file specified in the config.\n// Won't write anything if no file specified\nfunc (g *guerrilla) writePid() (err error) {\n\tvar f *os.File\n\tdefer func() {\n\t\tif f != nil {\n\t\t\tif closeErr := f.Close(); closeErr != nil {\n\t\t\t\terr = closeErr\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\tg.mainlog().WithError(err).Errorf(\"error while writing pidFile (%s)\", g.Config.PidFile)\n\t\t}\n\t}()\n\tif len(g.Config.PidFile) > 0 {\n\t\tif f, err = os.Create(g.Config.PidFile); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpid := os.Getpid()\n\t\tif _, err := f.WriteString(fmt.Sprintf(\"%d\", pid)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = f.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tg.mainlog().Infof(\"pid_file (%s) written with pid:%v\", g.Config.PidFile, pid)\n\t}\n\treturn nil\n}\n\n// CheckFileLimit checks the number of files we can open (works on OS'es that support the ulimit command)\nfunc CheckFileLimit(c *AppConfig) (bool, int, uint64) {\n\tfileLimit, err := getFileLimit()\n\tmaxClients := 0\n\tif err != nil {\n\t\t// since we can't get the limit, return true to indicate the check passed\n\t\treturn true, maxClients, fileLimit\n\t}\n\tif c.Servers == nil {\n\t\t// no servers have been configured, assuming default\n\t\tmaxClients = defaultMaxClients\n\t} else {\n\t\tfor _, s := range c.Servers {\n\t\t\tmaxClients += s.MaxClients\n\t\t}\n\t}\n\tif uint64(maxClients) > fileLimit {\n\t\treturn false, maxClients, fileLimit\n\t}\n\treturn true, maxClients, fileLimit\n}\n"
        },
        {
          "name": "guerrilla_notunix.go",
          "type": "blob",
          "size": 0.396484375,
          "content": "// +build !darwin\n// +build !dragonfly\n// +build !freebsd\n// +build !linux\n// +build !netbsd\n// +build !openbsd\n\npackage guerrilla\n\nimport \"errors\"\n\n// getFileLimit checks how many files we can open\n// Don't know how to get that info (yet?), so returns false information & error\nfunc getFileLimit() (uint64, error) {\n\treturn 1000000, errors.New(\"syscall.RLIMIT_NOFILE not supported on your OS/platform\")\n}\n"
        },
        {
          "name": "guerrilla_unix.go",
          "type": "blob",
          "size": 0.3916015625,
          "content": "// +build darwin dragonfly freebsd linux netbsd openbsd\n\npackage guerrilla\n\nimport \"syscall\"\n\n// getFileLimit checks how many files we can open\nfunc getFileLimit() (uint64, error) {\n\tvar rLimit syscall.Rlimit\n\terr := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rLimit)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\t//unnecessary type conversions to uint64 is needed for FreeBSD\n\treturn uint64(rLimit.Max), nil\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "mail",
          "type": "tree",
          "content": null
        },
        {
          "name": "mocks",
          "type": "tree",
          "content": null
        },
        {
          "name": "models.go",
          "type": "blob",
          "size": 1.7109375,
          "content": "package guerrilla\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"io\"\n)\n\nvar (\n\tLineLimitExceeded   = errors.New(\"maximum line length exceeded\")\n\tMessageSizeExceeded = errors.New(\"maximum message size exceeded\")\n)\n\n// we need to adjust the limit, so we embed io.LimitedReader\ntype adjustableLimitedReader struct {\n\tR *io.LimitedReader\n}\n\n// bolt this on so we can adjust the limit\nfunc (alr *adjustableLimitedReader) setLimit(n int64) {\n\talr.R.N = n\n}\n\n// Returns a specific error when a limit is reached, that can be differentiated\n// from an EOF error from the standard io.Reader.\nfunc (alr *adjustableLimitedReader) Read(p []byte) (n int, err error) {\n\tn, err = alr.R.Read(p)\n\tif err == io.EOF && alr.R.N <= 0 {\n\t\t// return our custom error since io.Reader returns EOF\n\t\terr = LineLimitExceeded\n\t}\n\treturn\n}\n\n// allocate a new adjustableLimitedReader\nfunc newAdjustableLimitedReader(r io.Reader, n int64) *adjustableLimitedReader {\n\tlr := &io.LimitedReader{R: r, N: n}\n\treturn &adjustableLimitedReader{lr}\n}\n\n// This is a bufio.Reader what will use our adjustable limit reader\n// We 'extend' buffio to have the limited reader feature\ntype smtpBufferedReader struct {\n\t*bufio.Reader\n\talr *adjustableLimitedReader\n}\n\n// Delegate to the adjustable limited reader\nfunc (sbr *smtpBufferedReader) setLimit(n int64) {\n\tsbr.alr.setLimit(n)\n}\n\n// Set a new reader & use it to reset the underlying reader\nfunc (sbr *smtpBufferedReader) Reset(r io.Reader) {\n\tsbr.alr = newAdjustableLimitedReader(r, CommandLineMaxLength)\n\tsbr.Reader.Reset(sbr.alr)\n}\n\n// Allocate a new SMTPBufferedReader\nfunc newSMTPBufferedReader(rd io.Reader) *smtpBufferedReader {\n\talr := newAdjustableLimitedReader(rd, CommandLineMaxLength)\n\ts := &smtpBufferedReader{bufio.NewReader(alr), alr}\n\treturn s\n}\n"
        },
        {
          "name": "pool.go",
          "type": "blob",
          "size": 4.4443359375,
          "content": "package guerrilla\n\nimport (\n\t\"errors\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"github.com/flashmob/go-guerrilla/mail\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nvar (\n\tErrPoolShuttingDown = errors.New(\"server pool: shutting down\")\n)\n\n// a struct can be pooled if it has the following interface\ntype Poolable interface {\n\t// ability to set read/write timeout\n\tsetTimeout(t time.Duration) error\n\t// set a new connection and client id\n\tinit(c net.Conn, clientID uint64, ep *mail.Pool)\n\t// get a unique id\n\tgetID() uint64\n\tkill()\n}\n\n// Pool holds Clients.\ntype Pool struct {\n\t// clients that are ready to be borrowed\n\tpool chan Poolable\n\t// semaphore to control number of maximum borrowed clients\n\tsem chan bool\n\t// book-keeping of clients that have been lent\n\tactiveClients     lentClients\n\tisShuttingDownFlg atomic.Value\n\tpoolGuard         sync.Mutex\n\tShutdownChan      chan int\n}\n\ntype lentClients struct {\n\tm  map[uint64]Poolable\n\tmu sync.Mutex // guards access to this struct\n\twg sync.WaitGroup\n}\n\n// maps the callback on all lentClients\nfunc (c *lentClients) mapAll(callback func(p Poolable)) {\n\tdefer c.mu.Unlock()\n\tc.mu.Lock()\n\tfor _, item := range c.m {\n\t\tcallback(item)\n\t}\n}\n\n// operation performs an operation on a Poolable item using the callback\nfunc (c *lentClients) operation(callback func(p Poolable), item Poolable) {\n\tdefer c.mu.Unlock()\n\tc.mu.Lock()\n\tcallback(item)\n}\n\n// NewPool creates a new pool of Clients.\nfunc NewPool(poolSize int) *Pool {\n\treturn &Pool{\n\t\tpool:          make(chan Poolable, poolSize),\n\t\tsem:           make(chan bool, poolSize),\n\t\tactiveClients: lentClients{m: make(map[uint64]Poolable, poolSize)},\n\t\tShutdownChan:  make(chan int, 1),\n\t}\n}\nfunc (p *Pool) Start() {\n\tp.isShuttingDownFlg.Store(true)\n}\n\n// Lock the pool from borrowing then remove all active clients\n// each active client's timeout is lowered to 1 sec and notified\n// to stop accepting commands\nfunc (p *Pool) ShutdownState() {\n\tconst aVeryLowTimeout = 1\n\tp.poolGuard.Lock() // ensure no other thread is in the borrowing now\n\tdefer p.poolGuard.Unlock()\n\tp.isShuttingDownFlg.Store(true) // no more borrowing\n\tp.ShutdownChan <- 1             // release any waiting p.sem\n\n\t// set a low timeout (let the clients finish whatever the're doing)\n\tp.activeClients.mapAll(func(p Poolable) {\n\t\tif err := p.setTimeout(time.Duration(int64(aVeryLowTimeout))); err != nil {\n\t\t\tp.kill()\n\t\t}\n\t})\n\n}\n\nfunc (p *Pool) ShutdownWait() {\n\tp.poolGuard.Lock() // ensure no other thread is in the borrowing now\n\tdefer p.poolGuard.Unlock()\n\tp.activeClients.wg.Wait() // wait for clients to finish\n\tif len(p.ShutdownChan) > 0 {\n\t\t// drain\n\t\t<-p.ShutdownChan\n\t}\n\tp.isShuttingDownFlg.Store(false)\n}\n\n// returns true if the pool is shutting down\nfunc (p *Pool) IsShuttingDown() bool {\n\tif value, ok := p.isShuttingDownFlg.Load().(bool); ok {\n\t\treturn value\n\t}\n\treturn false\n}\n\n// set a timeout for all lent clients\nfunc (p *Pool) SetTimeout(duration time.Duration) {\n\tp.activeClients.mapAll(func(p Poolable) {\n\t\tif err := p.setTimeout(duration); err != nil {\n\t\t\tp.kill()\n\t\t}\n\t})\n}\n\n// Gets the number of active clients that are currently\n// out of the pool and busy serving\nfunc (p *Pool) GetActiveClientsCount() int {\n\treturn len(p.sem)\n}\n\n// Borrow a Client from the pool. Will block if len(activeClients) > maxClients\nfunc (p *Pool) Borrow(conn net.Conn, clientID uint64, logger log.Logger, ep *mail.Pool) (Poolable, error) {\n\tp.poolGuard.Lock()\n\tdefer p.poolGuard.Unlock()\n\n\tvar c Poolable\n\tif yes, really := p.isShuttingDownFlg.Load().(bool); yes && really {\n\t\t// pool is shutting down.\n\t\treturn c, ErrPoolShuttingDown\n\t}\n\tselect {\n\tcase p.sem <- true: // block the client from serving until there is room\n\t\tselect {\n\t\tcase c = <-p.pool:\n\t\t\tc.init(conn, clientID, ep)\n\t\tdefault:\n\t\t\tc = NewClient(conn, clientID, logger, ep)\n\t\t}\n\t\tp.activeClientsAdd(c)\n\n\tcase <-p.ShutdownChan: // unblock p.sem when shutting down\n\t\t// pool is shutting down.\n\t\treturn c, ErrPoolShuttingDown\n\t}\n\treturn c, nil\n}\n\n// Return returns a Client back to the pool.\nfunc (p *Pool) Return(c Poolable) {\n\tp.activeClientsRemove(c)\n\tselect {\n\tcase p.pool <- c:\n\tdefault:\n\t\t// hasta la vista, baby...\n\t}\n\n\t<-p.sem // make room for the next serving client\n}\n\nfunc (p *Pool) activeClientsAdd(c Poolable) {\n\tp.activeClients.operation(func(item Poolable) {\n\t\tp.activeClients.wg.Add(1)\n\t\tp.activeClients.m[c.getID()] = item\n\t}, c)\n}\n\nfunc (p *Pool) activeClientsRemove(c Poolable) {\n\tp.activeClients.operation(func(item Poolable) {\n\t\tdelete(p.activeClients.m, item.getID())\n\t\tp.activeClients.wg.Done()\n\t}, c)\n}\n"
        },
        {
          "name": "response",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 19.73046875,
          "content": "package guerrilla\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"github.com/sirupsen/logrus\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"github.com/flashmob/go-guerrilla/mail\"\n\t\"github.com/flashmob/go-guerrilla/mail/rfc5321\"\n\t\"github.com/flashmob/go-guerrilla/response\"\n)\n\nconst (\n\tCommandVerbMaxLength = 16\n\tCommandLineMaxLength = 1024\n\t// Number of allowed unrecognized commands before we terminate the connection\n\tMaxUnrecognizedCommands = 5\n)\n\nconst (\n\t// server has just been created\n\tServerStateNew = iota\n\t// Server has just been stopped\n\tServerStateStopped\n\t// Server has been started and is running\n\tServerStateRunning\n\t// Server could not start due to an error\n\tServerStateStartError\n)\n\n// Server listens for SMTP clients on the port specified in its config\ntype server struct {\n\tconfigStore     atomic.Value // stores guerrilla.ServerConfig\n\ttlsConfigStore  atomic.Value\n\ttimeout         atomic.Value // stores time.Duration\n\tlistenInterface string\n\tclientPool      *Pool\n\twg              sync.WaitGroup // for waiting to shutdown\n\tlistener        net.Listener\n\tclosedListener  chan bool\n\thosts           allowedHosts // stores map[string]bool for faster lookup\n\tstate           int\n\t// If log changed after a config reload, newLogStore stores the value here until it's safe to change it\n\tlogStore     atomic.Value\n\tmainlogStore atomic.Value\n\tbackendStore atomic.Value\n\tenvelopePool *mail.Pool\n}\n\ntype allowedHosts struct {\n\ttable      map[string]bool // host lookup table\n\twildcards  []string        // host wildcard list (* is used as a wildcard)\n\tsync.Mutex                 // guard access to the map\n}\n\ntype command []byte\n\nvar (\n\tcmdHELO     command = []byte(\"HELO\")\n\tcmdEHLO     command = []byte(\"EHLO\")\n\tcmdHELP     command = []byte(\"HELP\")\n\tcmdXCLIENT  command = []byte(\"XCLIENT\")\n\tcmdMAIL     command = []byte(\"MAIL FROM:\")\n\tcmdRCPT     command = []byte(\"RCPT TO:\")\n\tcmdRSET     command = []byte(\"RSET\")\n\tcmdVRFY     command = []byte(\"VRFY\")\n\tcmdNOOP     command = []byte(\"NOOP\")\n\tcmdQUIT     command = []byte(\"QUIT\")\n\tcmdDATA     command = []byte(\"DATA\")\n\tcmdSTARTTLS command = []byte(\"STARTTLS\")\n)\n\nfunc (c command) match(in []byte) bool {\n\treturn bytes.Index(in, []byte(c)) == 0\n}\n\n// Creates and returns a new ready-to-run Server from a ServerConfig configuration\nfunc newServer(sc *ServerConfig, b backends.Backend, mainlog log.Logger) (*server, error) {\n\tserver := &server{\n\t\tclientPool:      NewPool(sc.MaxClients),\n\t\tclosedListener:  make(chan bool, 1),\n\t\tlistenInterface: sc.ListenInterface,\n\t\tstate:           ServerStateNew,\n\t\tenvelopePool:    mail.NewPool(sc.MaxClients),\n\t}\n\tserver.mainlogStore.Store(mainlog)\n\tserver.backendStore.Store(b)\n\tif sc.LogFile == \"\" {\n\t\t// none set, use the mainlog for the server log\n\t\tserver.logStore.Store(mainlog)\n\t\tserver.log().Info(\"server [\" + sc.ListenInterface + \"] did not configure a separate log file, so using the main log\")\n\t} else {\n\t\t// set level to same level as mainlog level\n\t\tif l, logOpenError := log.GetLogger(sc.LogFile, server.mainlog().GetLevel()); logOpenError != nil {\n\t\t\tserver.log().WithError(logOpenError).Errorf(\"Failed creating a logger for server [%s]\", sc.ListenInterface)\n\t\t\treturn server, logOpenError\n\t\t} else {\n\t\t\tserver.logStore.Store(l)\n\t\t}\n\t}\n\tserver.setConfig(sc)\n\tserver.setTimeout(sc.Timeout)\n\tif err := server.configureTLS(); err != nil {\n\t\treturn server, err\n\t}\n\treturn server, nil\n}\n\nfunc (s *server) configureTLS() error {\n\tsConfig := s.configStore.Load().(ServerConfig)\n\tif sConfig.TLS.AlwaysOn || sConfig.TLS.StartTLSOn {\n\t\tcert, err := tls.LoadX509KeyPair(sConfig.TLS.PublicKeyFile, sConfig.TLS.PrivateKeyFile)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error while loading the certificate: %s\", err)\n\t\t}\n\t\ttlsConfig := &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t\tClientAuth:   tls.VerifyClientCertIfGiven,\n\t\t\tServerName:   sConfig.Hostname,\n\t\t}\n\t\tif len(sConfig.TLS.Protocols) > 0 {\n\t\t\tif min, ok := TLSProtocols[sConfig.TLS.Protocols[0]]; ok {\n\t\t\t\ttlsConfig.MinVersion = min\n\t\t\t}\n\t\t}\n\t\tif len(sConfig.TLS.Protocols) > 1 {\n\t\t\tif max, ok := TLSProtocols[sConfig.TLS.Protocols[1]]; ok {\n\t\t\t\ttlsConfig.MaxVersion = max\n\t\t\t}\n\t\t}\n\t\tif len(sConfig.TLS.Ciphers) > 0 {\n\t\t\tfor _, val := range sConfig.TLS.Ciphers {\n\t\t\t\tif c, ok := TLSCiphers[val]; ok {\n\t\t\t\t\ttlsConfig.CipherSuites = append(tlsConfig.CipherSuites, c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif len(sConfig.TLS.Curves) > 0 {\n\t\t\tfor _, val := range sConfig.TLS.Curves {\n\t\t\t\tif c, ok := TLSCurves[val]; ok {\n\t\t\t\t\ttlsConfig.CurvePreferences = append(tlsConfig.CurvePreferences, c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif len(sConfig.TLS.RootCAs) > 0 {\n\t\t\tcaCert, err := ioutil.ReadFile(sConfig.TLS.RootCAs)\n\t\t\tif err != nil {\n\t\t\t\ts.log().WithError(err).Errorf(\"failed opening TLSRootCAs file [%s]\", sConfig.TLS.RootCAs)\n\t\t\t} else {\n\t\t\t\tcaCertPool := x509.NewCertPool()\n\t\t\t\tcaCertPool.AppendCertsFromPEM(caCert)\n\t\t\t\ttlsConfig.RootCAs = caCertPool\n\t\t\t}\n\n\t\t}\n\t\tif len(sConfig.TLS.ClientAuthType) > 0 {\n\t\t\tif ca, ok := TLSClientAuthTypes[sConfig.TLS.ClientAuthType]; ok {\n\t\t\t\ttlsConfig.ClientAuth = ca\n\t\t\t}\n\t\t}\n\t\ttlsConfig.PreferServerCipherSuites = sConfig.TLS.PreferServerCipherSuites\n\t\ttlsConfig.Rand = rand.Reader\n\t\ts.tlsConfigStore.Store(tlsConfig)\n\t}\n\treturn nil\n}\n\n// setBackend sets the backend to use for processing email envelopes\nfunc (s *server) setBackend(b backends.Backend) {\n\ts.backendStore.Store(b)\n}\n\n// backend gets the backend used to process email envelopes\nfunc (s *server) backend() backends.Backend {\n\tif b, ok := s.backendStore.Load().(backends.Backend); ok {\n\t\treturn b\n\t}\n\treturn nil\n}\n\n// Set the timeout for the server and all clients\nfunc (s *server) setTimeout(seconds int) {\n\tduration := time.Duration(int64(seconds))\n\ts.clientPool.SetTimeout(duration)\n\ts.timeout.Store(duration)\n}\n\n// goroutine safe config store\nfunc (s *server) setConfig(sc *ServerConfig) {\n\ts.configStore.Store(*sc)\n}\n\n// goroutine safe\nfunc (s *server) isEnabled() bool {\n\tsc := s.configStore.Load().(ServerConfig)\n\treturn sc.IsEnabled\n}\n\n// Set the allowed hosts for the server\nfunc (s *server) setAllowedHosts(allowedHosts []string) {\n\ts.hosts.Lock()\n\tdefer s.hosts.Unlock()\n\ts.hosts.table = make(map[string]bool, len(allowedHosts))\n\ts.hosts.wildcards = nil\n\tfor _, h := range allowedHosts {\n\t\tif strings.Contains(h, \"*\") {\n\t\t\ts.hosts.wildcards = append(s.hosts.wildcards, strings.ToLower(h))\n\t\t} else if len(h) > 5 && h[0] == '[' && h[len(h)-1] == ']' {\n\t\t\tif ip := net.ParseIP(h[1 : len(h)-1]); ip != nil {\n\t\t\t\t// this will save the normalized ip, as ip.String always returns ipv6 in short form\n\t\t\t\ts.hosts.table[\"[\"+ip.String()+\"]\"] = true\n\t\t\t}\n\t\t} else {\n\t\t\ts.hosts.table[strings.ToLower(h)] = true\n\t\t}\n\t}\n}\n\n// Begin accepting SMTP clients. Will block unless there is an error or server.Shutdown() is called\nfunc (s *server) Start(startWG *sync.WaitGroup) error {\n\tvar clientID uint64\n\tclientID = 0\n\n\tlistener, err := net.Listen(\"tcp\", s.listenInterface)\n\ts.listener = listener\n\tif err != nil {\n\t\tstartWG.Done() // don't wait for me\n\t\ts.state = ServerStateStartError\n\t\treturn fmt.Errorf(\"[%s] Cannot listen on port: %s \", s.listenInterface, err.Error())\n\t}\n\n\ts.log().Infof(\"Listening on TCP %s\", s.listenInterface)\n\ts.state = ServerStateRunning\n\tstartWG.Done() // start successful, don't wait for me\n\n\tfor {\n\t\ts.log().Debugf(\"[%s] Waiting for a new client. Next Client ID: %d\", s.listenInterface, clientID+1)\n\t\tconn, err := listener.Accept()\n\t\tclientID++\n\t\tif err != nil {\n\t\t\tif e, ok := err.(net.Error); ok && !e.Temporary() {\n\t\t\t\ts.log().Infof(\"Server [%s] has stopped accepting new clients\", s.listenInterface)\n\t\t\t\t// the listener has been closed, wait for clients to exit\n\t\t\t\ts.log().Infof(\"shutting down pool [%s]\", s.listenInterface)\n\t\t\t\ts.clientPool.ShutdownState()\n\t\t\t\ts.clientPool.ShutdownWait()\n\t\t\t\ts.state = ServerStateStopped\n\t\t\t\ts.closedListener <- true\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ts.mainlog().WithError(err).Info(\"Temporary error accepting client\")\n\t\t\tcontinue\n\t\t}\n\t\tgo func(p Poolable, borrowErr error) {\n\t\t\tc := p.(*client)\n\t\t\tif borrowErr == nil {\n\t\t\t\ts.handleClient(c)\n\t\t\t\ts.envelopePool.Return(c.Envelope)\n\t\t\t\ts.clientPool.Return(c)\n\t\t\t} else {\n\t\t\t\ts.log().WithError(borrowErr).Info(\"couldn't borrow a new client\")\n\t\t\t\t// we could not get a client, so close the connection.\n\t\t\t\t_ = conn.Close()\n\n\t\t\t}\n\t\t\t// intentionally placed Borrow in args so that it's called in the\n\t\t\t// same main goroutine.\n\t\t}(s.clientPool.Borrow(conn, clientID, s.log(), s.envelopePool))\n\n\t}\n}\n\nfunc (s *server) Shutdown() {\n\tif s.listener != nil {\n\t\t// This will cause Start function to return, by causing an error on listener.Accept\n\t\t_ = s.listener.Close()\n\t\t// wait for the listener to listener.Accept\n\t\t<-s.closedListener\n\t\t// At this point Start will exit and close down the pool\n\t} else {\n\t\ts.clientPool.ShutdownState()\n\t\t// listener already closed, wait for clients to exit\n\t\ts.clientPool.ShutdownWait()\n\t\ts.state = ServerStateStopped\n\t}\n}\n\nfunc (s *server) GetActiveClientsCount() int {\n\treturn s.clientPool.GetActiveClientsCount()\n}\n\n// Verifies that the host is a valid recipient.\n// host checking turned off if there is a single entry and it's a dot.\nfunc (s *server) allowsHost(host string) bool {\n\ts.hosts.Lock()\n\tdefer s.hosts.Unlock()\n\t// if hosts contains a single dot, further processing is skipped\n\tif len(s.hosts.table) == 1 {\n\t\tif _, ok := s.hosts.table[\".\"]; ok {\n\t\t\treturn true\n\t\t}\n\t}\n\tif _, ok := s.hosts.table[strings.ToLower(host)]; ok {\n\t\treturn true\n\t}\n\t// check the wildcards\n\tfor _, w := range s.hosts.wildcards {\n\t\tif matched, err := filepath.Match(w, strings.ToLower(host)); matched && err == nil {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *server) allowsIp(ip net.IP) bool {\n\tipStr := ip.String()\n\treturn s.allowsHost(\"[\" + ipStr + \"]\")\n}\n\nconst commandSuffix = \"\\r\\n\"\n\n// Reads from the client until a \\n terminator is encountered,\n// or until a timeout occurs.\nfunc (s *server) readCommand(client *client) ([]byte, error) {\n\t//var input string\n\tvar err error\n\tvar bs []byte\n\t// In command state, stop reading at line breaks\n\tbs, err = client.bufin.ReadSlice('\\n')\n\tif err != nil {\n\t\treturn bs, err\n\t} else if bytes.HasSuffix(bs, []byte(commandSuffix)) {\n\t\treturn bs[:len(bs)-2], err\n\t}\n\treturn bs[:len(bs)-1], err\n}\n\n// flushResponse a response to the client. Flushes the client.bufout buffer to the connection\nfunc (s *server) flushResponse(client *client) error {\n\tif err := client.setTimeout(s.timeout.Load().(time.Duration)); err != nil {\n\t\treturn err\n\t}\n\treturn client.bufout.Flush()\n}\n\nfunc (s *server) isShuttingDown() bool {\n\treturn s.clientPool.IsShuttingDown()\n}\n\n// Handles an entire client SMTP exchange\nfunc (s *server) handleClient(client *client) {\n\tdefer client.closeConn()\n\tsc := s.configStore.Load().(ServerConfig)\n\ts.log().Infof(\"Handle client [%s], id: %d\", client.RemoteIP, client.ID)\n\n\t// Initial greeting\n\tgreeting := fmt.Sprintf(\"220 %s SMTP Guerrilla(%s) #%d (%d) %s\",\n\t\tsc.Hostname, Version, client.ID,\n\t\ts.clientPool.GetActiveClientsCount(), time.Now().Format(time.RFC3339))\n\n\thelo := fmt.Sprintf(\"250 %s Hello\", sc.Hostname)\n\t// ehlo is a multi-line reply and need additional \\r\\n at the end\n\tehlo := fmt.Sprintf(\"250-%s Hello\\r\\n\", sc.Hostname)\n\n\t// Extended feature advertisements\n\tmessageSize := fmt.Sprintf(\"250-SIZE %d\\r\\n\", sc.MaxSize)\n\tpipelining := \"250-PIPELINING\\r\\n\"\n\tadvertiseTLS := \"250-STARTTLS\\r\\n\"\n\tadvertiseEnhancedStatusCodes := \"250-ENHANCEDSTATUSCODES\\r\\n\"\n\t// The last line doesn't need \\r\\n since string will be printed as a new line.\n\t// Also, Last line has no dash -\n\thelp := \"250 HELP\"\n\n\tif sc.TLS.AlwaysOn {\n\t\ttlsConfig, ok := s.tlsConfigStore.Load().(*tls.Config)\n\t\tif !ok {\n\t\t\ts.mainlog().Error(\"Failed to load *tls.Config\")\n\t\t} else if err := client.upgradeToTLS(tlsConfig); err == nil {\n\t\t\tadvertiseTLS = \"\"\n\t\t} else {\n\t\t\ts.log().WithError(err).Warnf(\"[%s] Failed TLS handshake\", client.RemoteIP)\n\t\t\t// server requires TLS, but can't handshake\n\t\t\tclient.kill()\n\t\t}\n\t}\n\tif !sc.TLS.StartTLSOn {\n\t\t// STARTTLS turned off, don't advertise it\n\t\tadvertiseTLS = \"\"\n\t}\n\tr := response.Canned\n\tfor client.isAlive() {\n\t\tswitch client.state {\n\t\tcase ClientGreeting:\n\t\t\tclient.sendResponse(greeting)\n\t\t\tclient.state = ClientCmd\n\t\tcase ClientCmd:\n\t\t\tclient.bufin.setLimit(CommandLineMaxLength)\n\t\t\tinput, err := s.readCommand(client)\n\t\t\ts.log().Debugf(\"Client sent: %s\", input)\n\t\t\tif err == io.EOF {\n\t\t\t\ts.log().WithError(err).Warnf(\"Client closed the connection: %s\", client.RemoteIP)\n\t\t\t\treturn\n\t\t\t} else if netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\t\ts.log().WithError(err).Warnf(\"Timeout: %s\", client.RemoteIP)\n\t\t\t\treturn\n\t\t\t} else if err == LineLimitExceeded {\n\t\t\t\tclient.sendResponse(r.FailLineTooLong)\n\t\t\t\tclient.kill()\n\t\t\t\tbreak\n\t\t\t} else if err != nil {\n\t\t\t\ts.log().WithError(err).Warnf(\"Read error: %s\", client.RemoteIP)\n\t\t\t\tclient.kill()\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif s.isShuttingDown() {\n\t\t\t\tclient.state = ClientShutdown\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcmdLen := len(input)\n\t\t\tif cmdLen > CommandVerbMaxLength {\n\t\t\t\tcmdLen = CommandVerbMaxLength\n\t\t\t}\n\t\t\tcmd := bytes.ToUpper(input[:cmdLen])\n\t\t\tswitch {\n\t\t\tcase cmdHELO.match(cmd):\n\t\t\t\tif h, err := client.parser.Helo(input[4:]); err == nil {\n\t\t\t\t\tclient.Helo = h\n\t\t\t\t} else {\n\t\t\t\t\ts.log().WithFields(logrus.Fields{\"helo\": h, \"client\": client.ID}).Warn(\"invalid helo\")\n\t\t\t\t\tclient.sendResponse(r.FailSyntaxError)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tclient.resetTransaction()\n\t\t\t\tclient.sendResponse(helo)\n\n\t\t\tcase cmdEHLO.match(cmd):\n\t\t\t\tif h, _, err := client.parser.Ehlo(input[4:]); err == nil {\n\t\t\t\t\tclient.Helo = h\n\t\t\t\t} else {\n\t\t\t\t\tclient.sendResponse(r.FailSyntaxError)\n\t\t\t\t\ts.log().WithFields(logrus.Fields{\"ehlo\": h, \"client\": client.ID}).Warn(\"invalid ehlo\")\n\t\t\t\t\tclient.sendResponse(r.FailSyntaxError)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tclient.ESMTP = true\n\t\t\t\tclient.resetTransaction()\n\t\t\t\tclient.sendResponse(ehlo,\n\t\t\t\t\tmessageSize,\n\t\t\t\t\tpipelining,\n\t\t\t\t\tadvertiseTLS,\n\t\t\t\t\tadvertiseEnhancedStatusCodes,\n\t\t\t\t\thelp)\n\n\t\t\tcase cmdHELP.match(cmd):\n\t\t\t\tquote := response.GetQuote()\n\t\t\t\tclient.sendResponse(\"214-OK\\r\\n\", quote)\n\n\t\t\tcase sc.XClientOn && cmdXCLIENT.match(cmd):\n\t\t\t\tif toks := bytes.Split(input[8:], []byte{' '}); len(toks) > 0 {\n\t\t\t\t\tfor i := range toks {\n\t\t\t\t\t\tif vals := bytes.Split(toks[i], []byte{'='}); len(vals) == 2 {\n\t\t\t\t\t\t\tif bytes.Equal(vals[1], []byte(\"[UNAVAILABLE]\")) {\n\t\t\t\t\t\t\t\t// skip\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif bytes.Equal(vals[0], []byte(\"ADDR\")) {\n\t\t\t\t\t\t\t\tclient.RemoteIP = string(vals[1])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif bytes.Equal(vals[0], []byte(\"HELO\")) {\n\t\t\t\t\t\t\t\tclient.Helo = string(vals[1])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclient.sendResponse(r.SuccessMailCmd)\n\t\t\tcase cmdMAIL.match(cmd):\n\t\t\t\tif client.isInTransaction() {\n\t\t\t\t\tclient.sendResponse(r.FailNestedMailCmd)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tclient.MailFrom, err = client.parsePath(input[10:], client.parser.MailFrom)\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.log().WithError(err).Error(\"MAIL parse error\", \"[\"+string(input[10:])+\"]\")\n\t\t\t\t\tclient.sendResponse(err)\n\t\t\t\t\tbreak\n\t\t\t\t} else if client.parser.NullPath {\n\t\t\t\t\t// bounce has empty from address\n\t\t\t\t\tclient.MailFrom = mail.Address{}\n\t\t\t\t}\n\t\t\t\tclient.sendResponse(r.SuccessMailCmd)\n\n\t\t\tcase cmdRCPT.match(cmd):\n\t\t\t\tif len(client.RcptTo) > rfc5321.LimitRecipients {\n\t\t\t\t\tclient.sendResponse(r.ErrorTooManyRecipients)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tto, err := client.parsePath(input[8:], client.parser.RcptTo)\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.log().WithError(err).Error(\"RCPT parse error\", \"[\"+string(input[8:])+\"]\")\n\t\t\t\t\tclient.sendResponse(err.Error())\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ts.defaultHost(&to)\n\t\t\t\tif (to.IP != nil && !s.allowsIp(to.IP)) || (to.IP == nil && !s.allowsHost(to.Host)) {\n\t\t\t\t\tclient.sendResponse(r.ErrorRelayDenied, \" \", to.Host)\n\t\t\t\t} else {\n\t\t\t\t\tclient.PushRcpt(to)\n\t\t\t\t\trcptError := s.backend().ValidateRcpt(client.Envelope)\n\t\t\t\t\tif rcptError != nil {\n\t\t\t\t\t\tclient.PopRcpt()\n\t\t\t\t\t\tclient.sendResponse(r.FailRcptCmd, \" \", rcptError.Error())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclient.sendResponse(r.SuccessRcptCmd)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tcase cmdRSET.match(cmd):\n\t\t\t\tclient.resetTransaction()\n\t\t\t\tclient.sendResponse(r.SuccessResetCmd)\n\n\t\t\tcase cmdVRFY.match(cmd):\n\t\t\t\tclient.sendResponse(r.SuccessVerifyCmd)\n\n\t\t\tcase cmdNOOP.match(cmd):\n\t\t\t\tclient.sendResponse(r.SuccessNoopCmd)\n\n\t\t\tcase cmdQUIT.match(cmd):\n\t\t\t\tclient.sendResponse(r.SuccessQuitCmd)\n\t\t\t\tclient.kill()\n\n\t\t\tcase cmdDATA.match(cmd):\n\t\t\t\tif len(client.RcptTo) == 0 {\n\t\t\t\t\tclient.sendResponse(r.FailNoRecipientsDataCmd)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tclient.sendResponse(r.SuccessDataCmd)\n\t\t\t\tclient.state = ClientData\n\n\t\t\tcase sc.TLS.StartTLSOn && cmdSTARTTLS.match(cmd):\n\n\t\t\t\tclient.sendResponse(r.SuccessStartTLSCmd)\n\t\t\t\tclient.state = ClientStartTLS\n\t\t\tdefault:\n\t\t\t\tclient.errors++\n\t\t\t\tif client.errors >= MaxUnrecognizedCommands {\n\t\t\t\t\tclient.sendResponse(r.FailMaxUnrecognizedCmd)\n\t\t\t\t\tclient.kill()\n\t\t\t\t} else {\n\t\t\t\t\tclient.sendResponse(r.FailUnrecognizedCmd)\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase ClientData:\n\n\t\t\t// intentionally placed the limit 1MB above so that reading does not return with an error\n\t\t\t// if the client goes a little over. Anything above will err\n\t\t\tclient.bufin.setLimit(sc.MaxSize + 1024000) // This a hard limit.\n\n\t\t\tn, err := client.Data.ReadFrom(client.smtpReader.DotReader())\n\t\t\tif n > sc.MaxSize {\n\t\t\t\terr = fmt.Errorf(\"maximum DATA size exceeded (%d)\", sc.MaxSize)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tif err == LineLimitExceeded {\n\t\t\t\t\tclient.sendResponse(r.FailReadLimitExceededDataCmd, \" \", LineLimitExceeded.Error())\n\t\t\t\t\tclient.kill()\n\t\t\t\t} else if err == MessageSizeExceeded {\n\t\t\t\t\tclient.sendResponse(r.FailMessageSizeExceeded, \" \", MessageSizeExceeded.Error())\n\t\t\t\t\tclient.kill()\n\t\t\t\t} else {\n\t\t\t\t\tclient.sendResponse(r.FailReadErrorDataCmd, \" \", err.Error())\n\t\t\t\t\tclient.kill()\n\t\t\t\t}\n\t\t\t\ts.log().WithError(err).Warn(\"Error reading data\")\n\t\t\t\tclient.resetTransaction()\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tres := s.backend().Process(client.Envelope)\n\t\t\tif res.Code() < 300 {\n\t\t\t\tclient.messagesSent++\n\t\t\t}\n\t\t\tclient.sendResponse(res)\n\t\t\tclient.state = ClientCmd\n\t\t\tif s.isShuttingDown() {\n\t\t\t\tclient.state = ClientShutdown\n\t\t\t}\n\t\t\tclient.resetTransaction()\n\n\t\tcase ClientStartTLS:\n\t\t\tif !client.TLS && sc.TLS.StartTLSOn {\n\t\t\t\ttlsConfig, ok := s.tlsConfigStore.Load().(*tls.Config)\n\t\t\t\tif !ok {\n\t\t\t\t\ts.mainlog().Error(\"Failed to load *tls.Config\")\n\t\t\t\t} else if err := client.upgradeToTLS(tlsConfig); err == nil {\n\t\t\t\t\tadvertiseTLS = \"\"\n\t\t\t\t\tclient.resetTransaction()\n\t\t\t\t} else {\n\t\t\t\t\ts.log().WithError(err).Warnf(\"[%s] Failed TLS handshake\", client.RemoteIP)\n\t\t\t\t\t// Don't disconnect, let the client decide if it wants to continue\n\t\t\t\t}\n\t\t\t}\n\t\t\t// change to command state\n\t\t\tclient.state = ClientCmd\n\t\tcase ClientShutdown:\n\t\t\t// shutdown state\n\t\t\tclient.sendResponse(r.ErrorShutdown)\n\t\t\tclient.kill()\n\t\t}\n\n\t\tif client.bufErr != nil {\n\t\t\ts.log().WithError(client.bufErr).Debug(\"client could not buffer a response\")\n\t\t\treturn\n\t\t}\n\t\t// flush the response buffer\n\t\tif client.bufout.Buffered() > 0 {\n\t\t\tif s.log().IsDebug() {\n\t\t\t\ts.log().Debugf(\"Writing response to client: \\n%s\", client.response.String())\n\t\t\t}\n\t\t\terr := s.flushResponse(client)\n\t\t\tif err != nil {\n\t\t\t\ts.log().WithError(err).Debug(\"error writing response\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfunc (s *server) log() log.Logger {\n\treturn s.loadLog(&s.logStore)\n}\n\nfunc (s *server) mainlog() log.Logger {\n\treturn s.loadLog(&s.mainlogStore)\n}\n\nfunc (s *server) loadLog(value *atomic.Value) log.Logger {\n\tif l, ok := value.Load().(log.Logger); ok {\n\t\treturn l\n\t}\n\tout := log.OutputStderr.String()\n\tlevel := log.InfoLevel.String()\n\tif value == &s.logStore {\n\t\tif sc, ok := s.configStore.Load().(ServerConfig); ok && sc.LogFile != \"\" {\n\t\t\tout = sc.LogFile\n\t\t}\n\t\tlevel = s.mainlog().GetLevel()\n\t}\n\n\tl, err := log.GetLogger(out, level)\n\tif err == nil {\n\t\tvalue.Store(l)\n\t}\n\treturn l\n}\n\n// defaultHost ensures that the host attribute is set, if addressed to Postmaster\nfunc (s *server) defaultHost(a *mail.Address) {\n\tif a.Host == \"\" && a.IsPostmaster() {\n\t\tsc := s.configStore.Load().(ServerConfig)\n\t\ta.Host = sc.Hostname\n\t\tif !s.allowsHost(a.Host) {\n\t\t\ts.log().WithFields(\n\t\t\t\tlogrus.Fields{\"hostname\": sc.Hostname}).\n\t\t\t\tWarn(\"the hostname is not present in AllowedHosts config setting\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 33.43359375,
          "content": "package guerrilla\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"bufio\"\n\t\"net/textproto\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\n\t\"github.com/flashmob/go-guerrilla/backends\"\n\t\"github.com/flashmob/go-guerrilla/log\"\n\t\"github.com/flashmob/go-guerrilla/mail\"\n\t\"github.com/flashmob/go-guerrilla/mocks\"\n)\n\n// getMockServerConfig gets a mock ServerConfig struct used for creating a new server\nfunc getMockServerConfig() *ServerConfig {\n\tsc := &ServerConfig{\n\t\tIsEnabled: true, // not tested here\n\t\tHostname:  \"saggydimes.test.com\",\n\t\tMaxSize:   1024, // smtp message max size\n\t\tTLS: ServerTLSConfig{\n\t\t\tPrivateKeyFile: \"./tests/mail.guerrillamail.com.key.pem\",\n\t\t\tPublicKeyFile:  \"./tests/mail.guerrillamail.com.cert.pem\",\n\t\t\tStartTLSOn:     true,\n\t\t\tAlwaysOn:       false,\n\t\t},\n\t\tTimeout:         5,\n\t\tListenInterface: \"127.0.0.1:2529\",\n\t\tMaxClients:      30, // not tested here\n\t\tLogFile:         \"./tests/testlog\",\n\t}\n\treturn sc\n}\n\n// getMockServerConn gets a new server using sc. Server will be using a mocked TCP connection\n// using the dummy backend\n// RCP TO command only allows test.com host\nfunc getMockServerConn(sc *ServerConfig, t *testing.T) (*mocks.Conn, *server) {\n\tvar logOpenError error\n\tvar mainlog log.Logger\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tbackend, err := backends.New(\n\t\tbackends.BackendConfig{\"log_received_mails\": true, \"save_workers_size\": 1},\n\t\tmainlog)\n\tif err != nil {\n\t\tt.Error(\"new dummy backend failed because:\", err)\n\t}\n\tserver, err := newServer(sc, backend, mainlog)\n\tif err != nil {\n\t\t//t.Error(\"new server failed because:\", err)\n\t} else {\n\t\tserver.setAllowedHosts([]string{\"test.com\"})\n\t}\n\tconn := mocks.NewConn()\n\treturn conn, server\n}\n\n// test the RootCAs tls config setting\nvar rootCAPK = `-----BEGIN CERTIFICATE-----\nMIIDqjCCApKgAwIBAgIJALh2TrsBR5MiMA0GCSqGSIb3DQEBCwUAMGkxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJDQTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEhMB8G\nA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDDAlsb2NhbGhv\nc3QwIBcNMTgwNTE4MDYzOTU2WhgPMjExODA0MjQwNjM5NTZaMGkxCzAJBgNVBAYT\nAlVTMQswCQYDVQQIDAJDQTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEhMB8GA1UE\nCgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDDAlsb2NhbGhvc3Qw\nggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCcb0ulYT1o5ysor5UtWYW\nq/ZY3PyK3/4YBZq5JoX4xk7GNQQ+3p/Km7QPoBXfgjFLZXEV2R0bE5hHMXfLa5Xb\n64acb9VqCqDvPFXcaNP4rEdBKDVN2p0PEi917tcKBSrZn5Yl+iOhtcBpQDvhHgn/\n9MdmIAKB3+yK+4l9YhT40XfDXCQqzfg4XcNaEgTzZHcDJz+KjWJuJChprcx27MTI\nNdxs9nmFA2rK16rjgjtwjZ4t9dXsljdOcx59s6dIQ0GnEM8qdKxi/vEx4+M/hbGf\nv7H75LsuKRrVJINAmfy9fmc6VAXjFU0ZVxGK5eVnzsh/hY08TSSrlCCKAJpksjJz\nAgMBAAGjUzBRMB0GA1UdDgQWBBSZsYWs+8FYe4z4c6LLmFB4TeeV/jAfBgNVHSME\nGDAWgBSZsYWs+8FYe4z4c6LLmFB4TeeV/jAPBgNVHRMBAf8EBTADAQH/MA0GCSqG\nSIb3DQEBCwUAA4IBAQAcXt/FaILkOCMj8bTUx42vi2N9ZTiEuRbYi24IyGOokbDR\npSsIxiz+HDPUuX6/X/mHidl24aS9wdv5JTXMr44/BeGK1WC7gMueZBxAqONpaG1Q\nVU0e3q1YwXKcupKQ7kVWl0fuY3licv0+s4zBcTLKkmWAYqsb/n0KtCMyqewi+Rqa\nZj5Z3OcWOq9Ad9fZWKcG8k/sgeTk9z0X1mZcEyWWxqsUmxvN+SdWLoug1xJVVbMN\nCipZ0vBIi9KOhQgzuIFhoTcd6myUtov52/EFqlX6UuFpY2gEWw/f/yu+SI08v4w9\nKwxgAKBkhx2JYZKtu1EsPIMDyS0aahcDnHqnrGAi\n-----END CERTIFICATE-----`\n\nvar clientPrvKey = `-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEA5ZLmMBdKkVyVmN0VhDSFGvgKp24ejHPCv+wfuf3vlU9cwKfH\nR3vejleZAVRcidscfA0Jsub/Glsr0XwecagtpvTI+Fp1ik6sICOz+VW3958qaAi8\nTjbUMjcDHJeSLcjr725CH5uIvhRzR+daYaJQhAcL2MEt8M9WIF6AjtDZEH9R6oM8\nt5FkO0amImlnipYXNBFghmzkZzfGXXRQLw2A+u6keLcjCrn9h2BaofGIjQfYcu/3\nfH4cIFR4z/soGKameqnCUz7dWmbf4tAI+8QR0VXXBKhiHDm98tPSeH994hC52Uul\nrjEVcM5Uox5hazS2PK06oSc1YuFZONqeeGqj6wIDAQABAoIBADERzRHKaK3ZVEBw\nQQEZGLpC+kP/TZhHxgCvv7hJhsQrSnADbJzi5RcXsiSOm5j7tILvZntO1IgVpLAK\nD5fLkrZ069/pteXyGuhjuTw6DjBnXPEPrPAq2ABDse6SlzQiFgv/TTLkU74NMPbV\nhIQJ5ZvSxb12zRMDviz9Bg2ApmTX6k2iPjQBnEHgKzb64IdMcEb5HE1qNt0v0lRA\nsGBMZZKQWbt2m0pSbAbnB3S9GcpJkRgFFMdTaUScIWO6ICT2hBP2pw2/4M2Zrmlt\nbsyWu9uswBzhvu+/pg2E66V6mji0EzDMlXqjlO5jro6t7P33t1zkd/i/ykKmtDLp\nIpR94UECgYEA9Y4EIjOyaBWJ6TRQ6a/tehGPbwIOgvEiTYXRJqdU49qn/i4YZjSm\nF4iibJz+JeOIQXSwa9F7gRlaspIuHgIJoer7BrITMuhr+afqMLkxK0pijul/qAbm\nHdpFn8IxjpNu4/GoAENbEVy50SMST9yWh5ulEkHHftd4/NJKoJQ2PZ8CgYEA71bb\nlFVh1MFclxRKECmpyoqUAzwGlMoHJy/jaBYuWG4X7rzxqDRrgPH3as6gXpRiSZ+K\n5fC+wcU7dKnHtJOkBDk6J5ev2+hbwg+yq3w4+l3bPDvf2TJyXjXjRDZo12pxFD58\nybCOF6ItbIDXqT5pvo3PMjgMwu1Ycie+h6hA3jUCgYEAsq93XpQT/R2/T44cWxEE\nVFG2+GacvLhP5+26ttAJPA1/Nb3BT458Vp+84iCT6GpcWpVZU/wKTXVvxIYPPRLq\ng4MEzGiFBASRngiMqIv6ta/ZbHmJxXHPvmV5SLn9aezrQsA1KovZFxdMuF03FBpH\nB8NBKbnoO+r8Ra2ZVKTFm60CgYAZw8Dpi/N3IsWj4eRDLyj/C8H5Qyn2NHVmq4oQ\nd2rPzDI5Wg+tqs7z15hp4Ap1hAW8pTcfn7X5SBEpculzr/0VE1AGWRbuVmoiTuxN\n95ZupVHnfw6O5BZZu/VWL4FDx0qbAksOrznso2G+b3RH3NcnUz69yjjddw1xZIPn\nOJ6bDQKBgDUcWYu/2amU18D5vJpppUgRq2084WPUeXsaniTbmWfOC8NAn8CKLY0N\nV4yGSu98apDuqEVqL0VFQEgqK+5KTvRdXXYi36XYRbbVUgV13xveq2YTvjNbPM60\nQWG9YmgH7hVYGusuh5nQeS0qiIpwyws2H5mBVrGXrQ1Xb0MLWj8/\n-----END RSA PRIVATE KEY-----`\n\n// signed using the Root (rootCAPK)\nvar clientPubKey = `-----BEGIN CERTIFICATE-----\nMIIDWDCCAkACCQCHoh4OvUySOzANBgkqhkiG9w0BAQsFADBpMQswCQYDVQQGEwJV\nUzELMAkGA1UECAwCQ0ExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxITAfBgNVBAoM\nGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAwwJbG9jYWxob3N0MCAX\nDTE4MDUxODA2NDQ0NVoYDzMwMTcwOTE4MDY0NDQ1WjBxMQswCQYDVQQGEwJVUzET\nMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEhMB8G\nA1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMRIwEAYDVQQDDAlsb2NhbGhv\nc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDlkuYwF0qRXJWY3RWE\nNIUa+Aqnbh6Mc8K/7B+5/e+VT1zAp8dHe96OV5kBVFyJ2xx8DQmy5v8aWyvRfB5x\nqC2m9Mj4WnWKTqwgI7P5Vbf3nypoCLxONtQyNwMcl5ItyOvvbkIfm4i+FHNH51ph\nolCEBwvYwS3wz1YgXoCO0NkQf1Hqgzy3kWQ7RqYiaWeKlhc0EWCGbORnN8ZddFAv\nDYD67qR4tyMKuf2HYFqh8YiNB9hy7/d8fhwgVHjP+ygYpqZ6qcJTPt1aZt/i0Aj7\nxBHRVdcEqGIcOb3y09J4f33iELnZS6WuMRVwzlSjHmFrNLY8rTqhJzVi4Vk42p54\naqPrAgMBAAEwDQYJKoZIhvcNAQELBQADggEBAIQmlo8iCpyYggkbpfDmThBPHfy1\ncZcCi/tRFoFe1ccwn2ezLMIKmW38ZebiroawwqrZgU6AP+dMxVKLMjpyLPSrpFKa\n3o/LbVF7qMfH8/y2q8t7javd6rxoENH9uxLyHhauzI1iWy0whoDWBNiZrPBTBCjq\njDGZARZqGyrPeXi+RNe1cMvZCxAFy7gqEtWFLWWrp0gYNPvxkHhhQBrUcF+8T/Nf\n9G4hKZSN/KAgC0CNBVuNrdyNc3l8H66BfwwL5X0+pesBYZM+MEfmBZOo+p7OWx2r\nug8tR8eSL1vGleONtFRBUVG7NbtjhBf9FhvPZcSRR10od/vWHku9E01i4xg=\n-----END CERTIFICATE-----`\n\nfunc truncateIfExists(filename string) error {\n\tif _, err := os.Stat(filename); !os.IsNotExist(err) {\n\t\treturn os.Truncate(filename, 0)\n\t}\n\treturn nil\n}\nfunc deleteIfExists(filename string) error {\n\tif _, err := os.Stat(filename); !os.IsNotExist(err) {\n\t\treturn os.Remove(filename)\n\t}\n\treturn nil\n}\n\nfunc cleanTestArtifacts(t *testing.T) {\n\tif err := deleteIfExists(\"rootca.test.pem\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"client.test.key\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"client.test.pem\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/mail.guerrillamail.com.key.pem\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/mail.guerrillamail.com.cert.pem\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/different-go-guerrilla.pid\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/go-guerrilla.pid\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/go-guerrilla2.pid\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/pidfile.pid\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := deleteIfExists(\"./tests/pidfile2.pid\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif err := truncateIfExists(\"./tests/testlog\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tif err := truncateIfExists(\"./tests/testlog2\"); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTLSConfig(t *testing.T) {\n\n\tdefer cleanTestArtifacts(t)\n\tif err := ioutil.WriteFile(\"rootca.test.pem\", []byte(rootCAPK), 0644); err != nil {\n\t\tt.Fatal(\"couldn't create rootca.test.pem file.\", err)\n\t\treturn\n\t}\n\tif err := ioutil.WriteFile(\"client.test.key\", []byte(clientPrvKey), 0644); err != nil {\n\t\tt.Fatal(\"couldn't create client.test.key file.\", err)\n\t\treturn\n\t}\n\tif err := ioutil.WriteFile(\"client.test.pem\", []byte(clientPubKey), 0644); err != nil {\n\t\tt.Fatal(\"couldn't create client.test.pem file.\", err)\n\t\treturn\n\t}\n\n\ts := server{}\n\ts.setConfig(&ServerConfig{\n\t\tTLS: ServerTLSConfig{\n\t\t\tStartTLSOn:     true,\n\t\t\tPrivateKeyFile: \"client.test.key\",\n\t\t\tPublicKeyFile:  \"client.test.pem\",\n\t\t\tRootCAs:        \"rootca.test.pem\",\n\t\t\tClientAuthType: \"NoClientCert\",\n\t\t\tCurves:         []string{\"P521\", \"P384\"},\n\t\t\tCiphers:        []string{\"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\"},\n\t\t\tProtocols:      []string{\"tls1.0\", \"tls1.2\"},\n\t\t},\n\t})\n\tif err := s.configureTLS(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tc := s.tlsConfigStore.Load().(*tls.Config)\n\n\tif len(c.CurvePreferences) != 2 {\n\t\tt.Error(\"c.CurvePreferences should have two elements\")\n\t} else if c.CurvePreferences[0] != tls.CurveP521 && c.CurvePreferences[1] != tls.CurveP384 {\n\t\tt.Error(\"c.CurvePreferences curves not setup\")\n\t}\n\tif !strings.Contains(string(c.RootCAs.Subjects()[0]), \"Mountain View\") {\n\t\tt.Error(\"c.RootCAs not correctly set\")\n\t}\n\tif c.ClientAuth != tls.NoClientCert {\n\t\tt.Error(\"c.ClientAuth should be tls.NoClientCert\")\n\t}\n\n\tif len(c.CipherSuites) != 2 {\n\t\tt.Error(\"c.CipherSuites length should be 2\")\n\t}\n\n\tif c.CipherSuites[0] != tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 && c.CipherSuites[1] != tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA {\n\t\tt.Error(\"c.CipherSuites not correctly set \")\n\t}\n\n\tif c.MinVersion != tls.VersionTLS10 {\n\t\tt.Error(\"c.MinVersion should be tls.VersionTLS10\")\n\t}\n\n\tif c.MaxVersion != tls.VersionTLS12 {\n\t\tt.Error(\"c.MinVersion should be tls.VersionTLS10\")\n\t}\n\n\tif c.PreferServerCipherSuites != false {\n\t\tt.Error(\"PreferServerCipherSuites should be false\")\n\t}\n\n}\n\nfunc TestHandleClient(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\t// call the serve.handleClient() func in a goroutine.\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\t//\tfmt.Println(line)\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\tif err := w.PrintfLine(\"HELO test.test.com\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t//fmt.Println(line)\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t//fmt.Println(\"line is:\", line)\n\texpected := \"221 2.0.0 Bye\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\twg.Wait() // wait for handleClient to exit\n}\n\nfunc TestGithubIssue197(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\tserver.backend().Start()\n\t// we assume that 1.1.1.1 is a domain (ip-literal syntax is incorrect)\n\t// [2001:DB8::FF00:42:8329] is an address literal\n\tserver.setAllowedHosts([]string{\"1.1.1.1\", \"[2001:DB8::FF00:42:8329]\"})\n\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\t//\tfmt.Println(line)\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\tif err := w.PrintfLine(\"HELO test.test.com\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// Case 1\n\tif err := w.PrintfLine(\"rcpt to: <hi@[1.1.1.1]>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif client.parser.IP == nil {\n\t\tt.Error(\"[1.1.1.1] not parsed as address-liteal\")\n\t}\n\n\t// case 2, should be parsed as domain\n\tif err := w.PrintfLine(\"rcpt to: <hi@1.1.1.1>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif client.parser.IP != nil {\n\t\tt.Error(\"1.1.1.1 should not be parsed as an IP (syntax requires IP addresses to be in braces, eg <hi@[1.1.1.1]>\")\n\t}\n\n\t// case 3\n\t// prefix ipv6 is case insensitive\n\tif err := w.PrintfLine(\"rcpt to: <hi@[ipv6:2001:DB8::FF00:42:8329]>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif client.parser.IP == nil {\n\t\tt.Error(\"[ipv6:2001:DB8::FF00:42:8329] should be parsed as an address-literal, it wasnt\")\n\t}\n\n\t// case 4\n\tif err := w.PrintfLine(\"rcpt to: <hi@[IPv6:2001:0db8:0000:0000:0000:ff00:0042:8329]>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif client.parser.Domain != \"2001:DB8::FF00:42:8329\" && client.parser.IP == nil {\n\t\tt.Error(\"[IPv6:2001:0db8:0000:0000:0000:ff00:0042:8329] is same as 2001:DB8::FF00:42:8329, lol\")\n\t}\n\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t//fmt.Println(\"line is:\", line)\n\texpected := \"221 2.0.0 Bye\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\twg.Wait() // wait for handleClient to exit\n}\n\nvar githubIssue198data string\n\nvar customBackend = func() backends.Decorator {\n\treturn func(p backends.Processor) backends.Processor {\n\t\treturn backends.ProcessWith(\n\t\t\tfunc(e *mail.Envelope, task backends.SelectTask) (backends.Result, error) {\n\t\t\t\tif task == backends.TaskSaveMail {\n\t\t\t\t\tgithubIssue198data = e.DeliveryHeader + e.Data.String()\n\t\t\t\t}\n\t\t\t\treturn p.Process(e, task)\n\t\t\t})\n\t}\n}\n\n// TestGithubIssue198 is an interesting test because it shows how to do an integration test for\n// a backend using a custom backend.\nfunc TestGithubIssue198(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\n\tbackends.Svc.AddProcessor(\"custom\", customBackend)\n\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\tbe, err := backends.New(map[string]interface{}{\n\t\t\"save_process\": \"HeadersParser|Header|custom\", \"primary_mail_host\": \"example.com\"},\n\t\tmainlog)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tserver.setBackend(be)\n\tif err := server.backend().Start(); err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\tserver.setAllowedHosts([]string{\"1.1.1.1\", \"[2001:DB8::FF00:42:8329]\"})\n\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tclient.RemoteIP = \"127.0.0.1\"\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\t// Test with HELO greeting\n\tline = sendMessage(\"HELO\", true, w, t, line, r, err, client)\n\tif !strings.Contains(githubIssue198data, \" SMTPS \") {\n\t\tt.Error(\"'with SMTPS' not present\")\n\t}\n\n\tif !strings.Contains(githubIssue198data, \"from 127.0.0.1\") {\n\t\tt.Error(\"'from 127.0.0.1' not present\")\n\t}\n\n\t/////////////////////\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\t// Test with EHLO\n\tline, _ = r.ReadLine()\n\tline = sendMessage(\"EHLO\", true, w, t, line, r, err, client)\n\tif !strings.Contains(githubIssue198data, \" ESMTPS \") {\n\t\tt.Error(\"'with ESMTPS' not present\")\n\t}\n\t/////////////////////\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// Test with EHLO & no TLS\n\n\tline = sendMessage(\"EHLO\", false, w, t, line, r, err, client)\n\n\t/////////////////////\n\n\tif !strings.Contains(githubIssue198data, \" ESMTP \") {\n\t\tt.Error(\"'with ESTMP' not present\")\n\t}\n\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\texpected := \"221 2.0.0 Bye\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\twg.Wait() // wait for handleClient to exit\n}\n\nfunc sendMessage(greet string, TLS bool, w *textproto.Writer, t *testing.T, line string, r *textproto.Reader, err error, client *client) string {\n\tif err := w.PrintfLine(greet + \" test.test.com\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tfor {\n\t\tline, _ = r.ReadLine()\n\t\tif strings.Index(line, \"250 \") == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif strings.Index(line, \"250\") != 0 {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\n\tif err := w.PrintfLine(\"MAIL FROM: test@example.com>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif err := w.PrintfLine(\"RCPT TO: <hi@[ipv6:2001:DB8::FF00:42:8329]>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tclient.Hashes = append(client.Hashes, \"abcdef1526777763\")\n\tclient.TLS = TLS\n\tif err := w.PrintfLine(\"DATA\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif err := w.PrintfLine(\"Subject: Test subject\\r\\n\\r\\nHello Sir,\\nThis is a test.\\r\\n.\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\treturn line\n}\n\nfunc TestGithubIssue199(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\tserver.backend().Start()\n\n\tserver.setAllowedHosts([]string{\"grr.la\", \"fake.com\", \"[1.1.1.1]\", \"[2001:db8::8a2e:370:7334]\", \"saggydimes.test.com\"})\n\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\t//\tfmt.Println(line)\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\tif err := w.PrintfLine(\"HELO test\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// case 1\n\tif err := w.PrintfLine(\n\t\t\"MAIL FROM: <\\\"  yo-- man wazz'''up? surprise surprise, this is POSSIBLE@fake.com \\\"@example.com>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t// [SPACE][SPACE]yo--[SPACE]man[SPACE]wazz'''up?[SPACE]surprise[SPACE]surprise,[SPACE]this[SPACE]is[SPACE]POSSIBLE@fake.com[SPACE]\n\tif client.parser.LocalPart != \"  yo-- man wazz'''up? surprise surprise, this is POSSIBLE@fake.com \" {\n\t\tt.Error(\"expecting local part: [  yo-- man wazz'''up? surprise surprise, this is POSSIBLE@fake.com ], got client.parser.LocalPart\")\n\t}\n\tif !client.parser.LocalPartQuotes {\n\t\tt.Error(\"was expecting client.parser.LocalPartQuotes true, got false\")\n\t}\n\t// from should just as above but without angle brackets <>\n\tif from := client.MailFrom.String(); from != \"\\\"  yo-- man wazz'''up? surprise surprise, this is POSSIBLE@fake.com \\\"@example.com\" {\n\t\tt.Error(\"mail from was:\", from)\n\t}\n\tif line != \"250 2.1.0 OK\" {\n\t\tt.Error(\"line did not have: 250 2.1.0 OK, got\", line)\n\t}\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// case 2, address literal mailboxes\n\tif err := w.PrintfLine(\"MAIL FROM: <hi@[1.1.1.1]>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// stringer should be aware its an ip and return the host part in angle brackets\n\tif from := client.MailFrom.String(); from != \"hi@[1.1.1.1]\" {\n\t\tt.Error(\"mail from was:\", from)\n\t}\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// case 3\n\n\tif err := w.PrintfLine(\"MAIL FROM: <hi@[IPv6:2001:0db8:0000:0000:0000:8a2e:0370:7334]>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// stringer should be aware its an ip and return the host part in angle brackets, and ipv6 should be normalized\n\tif from := client.MailFrom.String(); from != \"hi@[2001:db8::8a2e:370:7334]\" {\n\t\tt.Error(\"mail from was:\", from)\n\t}\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// case 4\n\t// rcpt to: <hi@[IPv6:2001:0db8:0000:0000:0000:ff00:0042:8329]>\n\n\tif err := w.PrintfLine(\"MAIL FROM: <>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif err := w.PrintfLine(\"RCPT TO: <Postmaster>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// stringer should return an empty string\n\tif from := client.MailFrom.String(); from != \"\" {\n\t\tt.Error(\"mail from was:\", from)\n\t}\n\n\t// note here the saggydimes.test.com was added because no host was specified in the RCPT TO command\n\tif rcpt := client.RcptTo[0].String(); rcpt != \"postmaster@saggydimes.test.com\" {\n\t\tt.Error(\"mail from was:\", rcpt)\n\t}\n\n\t// additional cases\n\n\t/*\n\t\tuser part:\n\t\t\" al\\ph\\a \"@grr.la should be \" alpha \"@grr.la.\n\t\t\"alpha\"@grr.la should be alpha@grr.la.\n\t\t\"alp\\h\\a\"@grr.la should be alpha@grr.la.\n\t*/\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif err := w.PrintfLine(\"RCPT TO: <\\\" al\\\\ph\\\\a \\\"@grr.la>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif client.RcptTo[0].User != \" alpha \" {\n\t\tt.Error(client.RcptTo[0].User)\n\t}\n\n\t// the unnecessary \\\\ should be removed\n\tif rcpt := client.RcptTo[0].String(); rcpt != \"\\\" alpha \\\"@grr.la\" {\n\t\tt.Error(rcpt)\n\t}\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif err := w.PrintfLine(\"RCPT TO: <\\\"alpha\\\"@grr.la>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// we don't need to quote, so stringer should return without the quotes\n\tif rcpt := client.RcptTo[0].String(); rcpt != \"alpha@grr.la\" {\n\t\tt.Error(rcpt)\n\t}\n\n\tif err := w.PrintfLine(\"RSET\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif err := w.PrintfLine(\"RCPT TO: <\\\"a\\\\l\\\\pha\\\"@grr.la>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tline, _ = r.ReadLine()\n\n\t// we don't need to quote, so stringer should return without the quotes\n\tif rcpt := client.RcptTo[0].String(); rcpt != \"alpha@grr.la\" {\n\t\tt.Error(rcpt)\n\t}\n\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\twg.Wait() // wait for handleClient to exit\n}\n\nfunc TestGithubIssue200(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\tserver.backend().Start()\n\tserver.setAllowedHosts([]string{\"1.1.1.1\", \"[2001:DB8::FF00:42:8329]\"})\n\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\t//\tfmt.Println(line)\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\tif err := w.PrintfLine(\"HELO test\\\"><script>alert('hi')</script>test.com\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif line != \"550 5.5.2 Syntax error\" {\n\t\tt.Error(\"line expected to be: 550 5.5.2 Syntax error, got\", line)\n\t}\n\n\tif err := w.PrintfLine(\"HELO test.com\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif !strings.Contains(line, \"250\") {\n\t\tt.Error(\"line did not have 250 code, got\", line)\n\t}\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t//fmt.Println(\"line is:\", line)\n\texpected := \"221 2.0.0 Bye\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\twg.Wait() // wait for handleClient to exit\n}\n\nfunc TestGithubIssue201(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\tserver.backend().Start()\n\t// note that saggydimes.test.com is the hostname of the server, it comes form the config\n\t// it will be used for rcpt to:<postmaster> which does not specify a host\n\tserver.setAllowedHosts([]string{\"a.com\", \"saggydimes.test.com\"})\n\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\t//\tfmt.Println(line)\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\tif err := w.PrintfLine(\"HELO test\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\t// case 1\n\tif err := w.PrintfLine(\"RCPT TO: <postMaStER@a.com>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif line != \"250 2.1.5 OK\" {\n\t\tt.Error(\"line did not have: 250 2.1.5 OK, got\", line)\n\t}\n\t// case 2\n\tif err := w.PrintfLine(\"RCPT TO: <Postmaster@not-a.com>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif line != \"454 4.1.1 Error: Relay access denied: not-a.com\" {\n\t\tt.Error(\"line is not:454 4.1.1 Error: Relay access denied: not-a.com, got\", line)\n\t}\n\t// case 3 (no host specified)\n\n\tif err := w.PrintfLine(\"RCPT TO: <poSTmAsteR>\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif line != \"250 2.1.5 OK\" {\n\t\tt.Error(\"line is not:[250 2.1.5 OK], got\", line)\n\t}\n\n\t// case 4\n\tif err := w.PrintfLine(\"RCPT TO: <\\\"po\\\\ST\\\\mAs\\\\t\\\\eR\\\">\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\tif line != \"250 2.1.5 OK\" {\n\t\tt.Error(\"line is not:[250 2.1.5 OK], got\", line)\n\t}\n\t// the local part should be just \"postmaster\" (normalized)\n\tif client.parser.LocalPart != \"postmaster\" {\n\t\tt.Error(\"client.parser.LocalPart was not postmaster, got:\", client.parser.LocalPart)\n\t}\n\n\tif client.parser.LocalPartQuotes {\n\t\tt.Error(\"client.parser.LocalPartQuotes was true, expecting false\")\n\t}\n\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t//fmt.Println(\"line is:\", line)\n\texpected := \"221 2.0.0 Bye\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\twg.Wait() // wait for handleClient to exit\n}\n\nfunc TestXClient(t *testing.T) {\n\tvar mainlog log.Logger\n\tvar logOpenError error\n\tdefer cleanTestArtifacts(t)\n\tsc := getMockServerConfig()\n\tsc.XClientOn = true\n\tmainlog, logOpenError = log.GetLogger(sc.LogFile, \"debug\")\n\tif logOpenError != nil {\n\t\tmainlog.WithError(logOpenError).Errorf(\"Failed creating a logger for mock conn [%s]\", sc.ListenInterface)\n\t}\n\tconn, server := getMockServerConn(sc, t)\n\t// call the serve.handleClient() func in a goroutine.\n\tclient := NewClient(conn.Server, 1, mainlog, mail.NewPool(5))\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tserver.handleClient(client)\n\t\twg.Done()\n\t}()\n\t// Wait for the greeting from the server\n\tr := textproto.NewReader(bufio.NewReader(conn.Client))\n\tline, _ := r.ReadLine()\n\t//\tfmt.Println(line)\n\tw := textproto.NewWriter(bufio.NewWriter(conn.Client))\n\tif err := w.PrintfLine(\"HELO test.test.com\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\t//fmt.Println(line)\n\tif err := w.PrintfLine(\"XCLIENT ADDR=212.96.64.216 NAME=[UNAVAILABLE]\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\tif client.RemoteIP != \"212.96.64.216\" {\n\t\tt.Error(\"client.RemoteIP should be 212.96.64.216, but got:\", client.RemoteIP)\n\t}\n\texpected := \"250 2.1.0 OK\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\n\t// try malformed input\n\tif err := w.PrintfLine(\"XCLIENT c\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\n\texpected = \"250 2.1.0 OK\"\n\tif strings.Index(line, expected) != 0 {\n\t\tt.Error(\"expected\", expected, \"but got:\", line)\n\t}\n\n\tif err := w.PrintfLine(\"QUIT\"); err != nil {\n\t\tt.Error(err)\n\t}\n\tline, _ = r.ReadLine()\n\twg.Wait() // wait for handleClient to exit\n}\n\n// The backend gateway should time out after 1 second because it sleeps for 2 sec.\n// The transaction should wait until finished, and then test to see if we can do\n// a second transaction\nfunc TestGatewayTimeout(t *testing.T) {\n\tdefer cleanTestArtifacts(t)\n\tbcfg := backends.BackendConfig{\n\t\t\"save_workers_size\":   1,\n\t\t\"save_process\":        \"HeadersParser|Debugger\",\n\t\t\"log_received_mails\":  true,\n\t\t\"primary_mail_host\":   \"example.com\",\n\t\t\"gw_save_timeout\":     \"1s\",\n\t\t\"gw_val_rcpt_timeout\": \"1s\",\n\t\t\"sleep_seconds\":       2,\n\t}\n\n\tcfg := &AppConfig{\n\t\tLogFile:      log.OutputOff.String(),\n\t\tAllowedHosts: []string{\"grr.la\"},\n\t}\n\tcfg.BackendConfig = bcfg\n\n\td := Daemon{Config: cfg}\n\terr := d.Start()\n\n\tif err != nil {\n\t\tt.Error(\"server didn't start\")\n\t} else {\n\n\t\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:2525\")\n\t\tif err != nil {\n\n\t\t\treturn\n\t\t}\n\t\tin := bufio.NewReader(conn)\n\t\tstr, err := in.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif _, err := fmt.Fprint(conn, \"HELO host\\r\\n\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tstr, err = in.ReadString('\\n')\n\t\t// perform 2 transactions\n\t\t// both should panic.\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tif _, err := fmt.Fprint(conn, \"MAIL FROM:<test@example.com>r\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif str, err = in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"RCPT TO:<test@grr.la>\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif str, err = in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"DATA\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif str, err = in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"Subject: Test subject\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"A an email body\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \".\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tstr, err = in.ReadString('\\n')\n\t\t\texpect := \"transaction timeout\"\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else if !strings.Contains(str, expect) {\n\t\t\t\tt.Error(\"Expected the reply to have'\", expect, \"'but got\", str)\n\t\t\t}\n\t\t}\n\t\t_ = str\n\n\t\td.Shutdown()\n\t}\n}\n\n// The processor will panic and gateway should recover from it\nfunc TestGatewayPanic(t *testing.T) {\n\tdefer cleanTestArtifacts(t)\n\tbcfg := backends.BackendConfig{\n\t\t\"save_workers_size\":   1,\n\t\t\"save_process\":        \"HeadersParser|Debugger\",\n\t\t\"log_received_mails\":  true,\n\t\t\"primary_mail_host\":   \"example.com\",\n\t\t\"gw_save_timeout\":     \"2s\",\n\t\t\"gw_val_rcpt_timeout\": \"2s\",\n\t\t\"sleep_seconds\":       1,\n\t}\n\n\tcfg := &AppConfig{\n\t\tLogFile:      log.OutputOff.String(),\n\t\tAllowedHosts: []string{\"grr.la\"},\n\t}\n\tcfg.BackendConfig = bcfg\n\n\td := Daemon{Config: cfg}\n\terr := d.Start()\n\n\tif err != nil {\n\t\tt.Error(\"server didn't start\")\n\t} else {\n\n\t\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:2525\")\n\t\tif err != nil {\n\n\t\t\treturn\n\t\t}\n\t\tin := bufio.NewReader(conn)\n\t\tif _, err := in.ReadString('\\n'); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif _, err := fmt.Fprint(conn, \"HELO host\\r\\n\"); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tif _, err = in.ReadString('\\n'); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\t// perform 2 transactions\n\t\t// both should timeout. The reason why 2 is because we want to make\n\t\t// sure that the client waits until processing finishes, and the\n\t\t// timeout event is captured.\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tif _, err := fmt.Fprint(conn, \"MAIL FROM:<test@example.com>r\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err = in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"RCPT TO:<test@grr.la>\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err = in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"DATA\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err = in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"Subject: Test subject\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \"A an email body\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif _, err := fmt.Fprint(conn, \".\\r\\n\"); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif str, err := in.ReadString('\\n'); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t} else {\n\t\t\t\texpect := \"storage failed\"\n\t\t\t\tif !strings.Contains(str, expect) {\n\t\t\t\t\tt.Error(\"Expected the reply to have'\", expect, \"'but got\", str)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td.Shutdown()\n\t}\n\n}\n\nfunc TestAllowsHosts(t *testing.T) {\n\tdefer cleanTestArtifacts(t)\n\ts := server{}\n\tallowedHosts := []string{\n\t\t\"spam4.me\",\n\t\t\"grr.la\",\n\t\t\"newhost.com\",\n\t\t\"example.*\",\n\t\t\"*.test\",\n\t\t\"wild*.card\",\n\t\t\"multiple*wild*cards.*\",\n\t\t\"[::FFFF:C0A8:1]\",          // ip4 in ipv6 format. It's actually 192.168.0.1\n\t\t\"[2001:db8::ff00:42:8329]\", // same as 2001:0db8:0000:0000:0000:ff00:0042:8329\n\t\t\"[127.0.0.1]\",\n\t}\n\ts.setAllowedHosts(allowedHosts)\n\n\ttestTable := map[string]bool{\n\t\t\"spam4.me\":                true,\n\t\t\"dont.match\":              false,\n\t\t\"example.com\":             true,\n\t\t\"another.example.com\":     false,\n\t\t\"anything.test\":           true,\n\t\t\"wild.card\":               true,\n\t\t\"wild.card.com\":           false,\n\t\t\"multipleXwildXcards.com\": true,\n\t}\n\n\tfor host, allows := range testTable {\n\t\tif res := s.allowsHost(host); res != allows {\n\t\t\tt.Error(host, \": expected\", allows, \"but got\", res)\n\t\t}\n\t}\n\n\ttestTableIP := map[string]bool{\n\n\t\t\"192.168.0.1\": true,\n\t\t\"2001:0db8:0000:0000:0000:ff00:0042:8329\": true,\n\t\t\"127.0.0.1\": true,\n\t}\n\n\tfor host, allows := range testTableIP {\n\t\tif res := s.allowsIp(net.ParseIP(host)); res != allows {\n\t\t\tt.Error(host, \": expected\", allows, \"but got\", res)\n\t\t}\n\t}\n\n\t// only wildcard - should match anything\n\ts.setAllowedHosts([]string{\"*\"})\n\tif !s.allowsHost(\"match.me\") {\n\t\tt.Error(\"match.me: expected true but got false\")\n\t}\n\n\t// turns off\n\ts.setAllowedHosts([]string{\".\"})\n\tif !s.allowsHost(\"match.me\") {\n\t\tt.Error(\"match.me: expected true but got false\")\n\t}\n\n\t// no wilcards\n\ts.setAllowedHosts([]string{\"grr.la\", \"example.com\"})\n\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tls_go1.13.go",
          "type": "blob",
          "size": 0.4638671875,
          "content": "// +build go1.13\n\npackage guerrilla\n\nimport \"crypto/tls\"\n\n// TLS 1.3 was introduced in go 1.12 as an option and enabled for production in go 1.13\n// release notes: https://golang.org/doc/go1.12#tls_1_3\nfunc init() {\n\tTLSProtocols[\"tls1.3\"] = tls.VersionTLS13\n\n\tTLSCiphers[\"TLS_AES_128_GCM_SHA256\"] = tls.TLS_AES_128_GCM_SHA256\n\tTLSCiphers[\"TLS_AES_256_GCM_SHA384\"] = tls.TLS_AES_256_GCM_SHA384\n\tTLSCiphers[\"TLS_CHACHA20_POLY1305_SHA256\"] = tls.TLS_CHACHA20_POLY1305_SHA256\n}\n"
        },
        {
          "name": "tls_go1.14.go",
          "type": "blob",
          "size": 0.2890625,
          "content": "// +build !go1.14\n\npackage guerrilla\n\nimport \"crypto/tls\"\n\nfunc init() {\n\n\tTLSProtocols[\"ssl3.0\"] = tls.VersionSSL30 // deprecated since GO 1.13, removed 1.14\n\n\t// Include to prevent downgrade attacks (SSLv3 only, deprecated in Go 1.13)\n\tTLSCiphers[\"TLS_FALLBACK_SCSV\"] = tls.TLS_FALLBACK_SCSV\n}\n"
        },
        {
          "name": "tls_go1.8.go",
          "type": "blob",
          "size": 0.7041015625,
          "content": "// +build go1.8\n\npackage guerrilla\n\nimport \"crypto/tls\"\n\n// add ciphers introduced since Go 1.8\nfunc init() {\n\tTLSCiphers[\"TLS_RSA_WITH_AES_128_CBC_SHA256\"] = tls.TLS_RSA_WITH_AES_128_CBC_SHA256\n\tTLSCiphers[\"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\"] = tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\n\tTLSCiphers[\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\"] = tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\n\tTLSCiphers[\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\"] = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n\tTLSCiphers[\"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\"] = tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305\n\tTLSCiphers[\"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\"] = tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305\n\n\tTLSCurves[\"X25519\"] = tls.X25519\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.4072265625,
          "content": "package guerrilla\n\nimport \"time\"\n\nvar (\n\tVersion   string\n\tCommit    string\n\tBuildTime string\n\n\tStartTime      time.Time\n\tConfigLoadTime time.Time\n)\n\nfunc init() {\n\t// If version, commit, or build time are not set, make that clear.\n\tconst unknown = \"unknown\"\n\tif Version == \"\" {\n\t\tVersion = unknown\n\t}\n\tif Commit == \"\" {\n\t\tCommit = unknown\n\t}\n\tif BuildTime == \"\" {\n\t\tBuildTime = unknown\n\t}\n\n\tStartTime = time.Now()\n}\n"
        }
      ]
    }
  ]
}