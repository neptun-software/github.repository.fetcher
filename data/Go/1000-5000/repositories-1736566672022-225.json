{
  "metadata": {
    "timestamp": 1736566672022,
    "page": 225,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kashav/fsql",
      "stars": 3985,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n# Compiled binaries\nfsql\ndebug\nmain\ndist/\n\n# Allow cmd/fsql\n!cmd/fsql\n\n# Editor workspace directories\n.vscode\n\n# Coverage output\ncoverage.txt\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 Kashav Madan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.294921875,
          "content": "PREFIX ?= $(shell pwd)\n\nNAME = fsql\nPKG = github.com/kashav/$(NAME)\nMAIN = $(PKG)/cmd/$(NAME)\n\nDIST_DIR := ${PREFIX}/dist\nDIST_DIRS := find . -type d | sed \"s|^\\./||\" | grep -v \\\\. | tr '\\n' '\\0' | xargs -0 -I '{}'\n\nSRCS := $(shell find . -type f -name '*.go')\nPKGS := $(shell go list ./...)\n\nVERSION := $(shell cat VERSION)\nGITCOMMIT := $(shell git rev-parse --short HEAD)\nifneq ($(shell git status --porcelain --untracked-files=no),)\n\tGITCOMMIT := $(GITCOMMIT)-dirty\nendif\n\nLDFLAGS := ${LDFLAGS} \\\n\t-X $(PKG)/meta.GITCOMMIT=${GITCOMMIT} \\\n\t-X $(PKG)/meta.VERSION=${VERSION}\n\n.PHONY: all\nall: $(NAME)\n\n$(NAME): $(SRCS) VERSION\n\t@echo \"+ $@\"\n\t@go build -ldflags \"${LDFLAGS}\" -o $(NAME) -v $(MAIN)\n\n.PHONY: install\ninstall:\n\t@echo \"+ $@\"\n\t@go install $(PKGS)\n\n.PHONY: get-tools\nget-tools:\n\t@echo \"+ $@\"\n\t@go get -u -v golang.org/x/lint/golint\n\n.PHONY: clean\nclean:\n\t@echo \"+ $@\"\n\t$(RM) $(NAME)\n\t$(RM) -r $(DIST_DIR)\n\n.PHONY: fmt\nfmt:\n\t@echo \"+ $@\"\n\t@test -z \"$$(gofmt -s -l . 2>&1 | tee /dev/stderr)\" || \\\n\t\t(echo >&2 \"+ please format Go code with 'gofmt -s', or use 'make fmt-save'\" && false)\n\n.PHONY: fmt-save\nfmt-save:\n\t@echo \"+ $@\"\n\t@gofmt -s -l . 2>&1 | xargs gofmt -s -l -w\n\n.PHONY: vet\nvet:\n\t@echo \"+ $@\"\n\t@go vet $(PKGS)\n\n.PHONY: lint\nlint:\n\t@echo \"+ $@\"\n\t$(if $(shell which golint || echo ''),, \\\n\t\t$(error Please install golint: `make get-tools`))\n\t@test -z \"$$(golint ./... 2>&1 | grep -v mock/ | tee /dev/stderr)\"\n\n.PHONY: test\ntest:\n\t@echo \"+ $@\"\n\t@go test -race $(PKGS)\n\n.PHONY: coverage\ncoverage:\n\t@echo \"+ $@\"\n\t@for pkg in $(PKGS); do \\\n\t\tgo test -test.short -race -coverprofile=\"../../../$$pkg/coverage.txt\" $${pkg} || exit 1; \\\n\tdone\n\n.PHONY: bootstrap-dist\nbootstrap-dist:\n\t@echo \"+ $@\"\n\t@go get -u -v github.com/franciscocpg/gox\n\n.PHONY: build-all\nbuild-all: $(SRCS) VERSION\n\t@echo \"+ $@\"\n\t@gox -verbose \\\n\t\t-ldflags \"${LDFLAGS}\" \\\n\t\t-os=\"darwin freebsd netbsd openbsd linux solaris windows\" \\\n\t\t-arch=\"386 amd64 arm arm64\" \\\n\t\t-osarch=\"!darwin/386 !darwin/arm\" \\\n\t\t-output=\"$(DIST_DIR)/$(NAME)-{{.OS}}-{{.Arch}}/{{.Dir}}\" $(MAIN)\n\n.PHONY: dist\ndist: clean build-all\n\t@echo \"+ $@\"\n\t@cd $(DIST_DIR) && \\\n\t\t$(DIST_DIRS) cp ../LICENSE {} && \\\n\t\t$(DIST_DIRS) cp ../README.md {} && \\\n\t\t$(DIST_DIRS) tar -zcf fsql-${VERSION}-{}.tar.gz {} && \\\n\t\t$(DIST_DIRS) zip -r -q fsql-${VERSION}-{}.zip {} && \\\n\t\t$(DIST_DIRS) rm -rf {} && \\\n\t\tcd ..\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.44921875,
          "content": "# fsql [![Go](https://github.com/kashav/fsql/actions/workflows/go.yml/badge.svg)](https://github.com/kashav/fsql/actions/workflows/go.yml)\n\n>Search through your filesystem with SQL-esque queries.\n\n## Contents\n\n- [Demo](#demo)\n- [Installation](#installation)\n- [Usage](#usage)\n- [Query Syntax](#query-syntax)\n- [Examples](#usage-examples)\n- [Contribute](#contribute)\n- [License](#license)\n\n## Demo\n\n[![fsql.gif](./media/fsql.gif)](https://asciinema.org/a/120534)\n\n## Installation\n\n#### Binaries\n\n[View latest release](https://github.com/kashav/fsql/releases/latest).\n\n#### Via Go\n\n```sh\n$ go get -u -v github.com/kashav/fsql/...\n$ which fsql\n$GOPATH/bin/fsql\n```\n\n#### Via Homebrew\n\n```sh\n$ brew install fsql\n$ which fsql\n/usr/local/bin/fsql\n```\n\n#### Build manually\n\n```sh\n$ git clone https://github.com/kashav/fsql.git $GOPATH/src/github.com/kashav/fsql\n$ cd $_ # $GOPATH/src/github.com/kashav/fsql\n$ make\n$ ./fsql\n```\n\n## Usage\n\nfsql expects a single query via stdin. You may also choose to use fsql in interactive mode.\n\nView the usage dialogue with the `-help` flag.\n\n```sh\n$ fsql -help\nusage: fsql [options] [query]\n  -v  print version and exit (shorthand)\n  -version\n      print version and exit\n```\n\n## Query syntax\n\nIn general, each query requires a `SELECT` clause (to specify which attributes will be shown), a `FROM` clause (to specify which directories to search), and a `WHERE` clause (to specify conditions to test against).\n\n```console\n>>> SELECT attribute, ... FROM source, ... WHERE condition;\n```\n\nYou may choose to omit the `SELECT` and `WHERE` clause.\n\nIf you're providing your query via stdin, quotes are **not** required, however you'll have to escape _reserved_ characters (e.g. `*`, `<`, `>`, etc).\n\n### Attribute\n\nCurrently supported attributes include `name`, `size`, `time`, `hash`, `mode`.\n\nUse `all` or `*` to choose all; if no attribute is provided, this is chosen by default.\n\n**Examples**:\n\nEach group features a set of equivalent clauses.\n\n```console\n>>> SELECT name, size, time ...\n>>> name, size, time ...\n```\n\n```console\n>>> SELECT all FROM ...\n>>> all FROM ...\n>>> FROM ...\n```\n\n### Source\n\nEach source should be a relative or absolute path to a directory on your machine.\n\nSource paths may include environment variables (e.g. `$GOPATH`) or tildes (`~`). Use a hyphen (`-`) to exclude a directory. Source paths also support usage of [glob patterns](https://en.wikipedia.org/wiki/Glob_(programming)).\n\nIn the case that a directory begins with a hyphen (e.g. `-foo`), use the following to include it as a source:\n\n```console\n>>> ... FROM ./-foo ...\n```\n\n**Examples**:\n\n```console\n>>> ... FROM . ...\n```\n\n```console\n>>> ... FROM ~/Desktop, ./*/**.go ...\n```\n\n```console\n>>> ... FROM $GOPATH, -.git/ ...\n```\n\n### Condition\n\n#### Condition syntax\n\nA single condition is made up of 3 parts: an attribute, an operator, and a value.\n\n- **Attribute**:\n\n  A valid attribute is any of the following: `name`, `size`, `mode`, `time`.\n\n- **Operator**:\n\n  Each attribute has a set of associated operators.\n\n  - `name`:\n\n    | Operator | Description |\n    | :---: | --- |\n    | `=` | String equality |\n    | `<>` / `!=` | Synonymous to using `\"NOT ... = ...\"` |\n    | `IN` | Basic list inclusion |\n    | `LIKE` |  Simple pattern matching. Use `%` to match zero, one, or multiple characters. Check that a string begins with a value: `<value>%`, ends with a value: `%<value>`, or contains a value: `%<value>%`. |\n    | `RLIKE` | Pattern matching with regular expressions. |\n\n  - `size` / `time`:\n\n    - All basic algebraic operators: `>`, `>=`, `<`, `<=`, `=`, and `<>` / `!=`.\n\n  - `hash`:\n\n    - `=` or `<>` / `!=`\n\n  - `mode`:\n\n    - `IS`\n\n\n- **Value**:\n\n  If the value contains spaces, wrap the value in quotes (either single or double) or backticks.\n\n  The default unit for `size` is bytes.\n\n  The default format for `time` is `MMM DD YYYY HH MM` (e.g. `\"Jan 02 2006 15 04\"`).\n\n  Use `mode` to test if a file is regular (`IS REG`) or if it's a directory (`IS DIR`).\n\n  Use `hash` to compute and/or compare the hash value of a file. The default algorithm is `SHA1`\n\n#### Conjunction / Disjunction\n\nUse `AND` / `OR` to join conditions. Note that precedence is assigned based on order of appearance.\n\nThis means `WHERE a AND b OR c` is **not** the same as `WHERE c OR b AND a`. Use parentheses to get around this behaviour, i.e. `WHERE a AND b OR c` **is** the same as `WHERE c OR (b AND a)`.\n\n**Examples**:\n\n```console\n>>> ... WHERE name = main.go OR size = 5 ...\n```\n\n```console\n>>> ... WHERE name = main.go AND size > 20 ...\n```\n\n#### Negation\n\nUse `NOT` to negate a condition. This keyword **must** precede the condition (e.g. `... WHERE NOT a ...`).\n\nNote that negating parenthesized conditions is currently not supported. However, this can easily be resolved by applying [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) to your query. For example, `... WHERE NOT (a AND b) ...` is _logically equivalent_ to `... WHERE NOT a OR NOT b ...` (the latter is actually more optimal, due to [lazy evaluation](https://en.wikipedia.org/wiki/Lazy_evaluation)).\n\n**Examples**:\n\n```console\n>>> ... WHERE NOT name = main.go ...\n```\n\n### Attribute Modifiers\n\nAttribute modifiers are used to specify how input and output values should be processed. These functions are applied directly to attributes in the `SELECT` and `WHERE` clauses.\n\nThe table below lists currently-supported modifiers. Note that the first parameter to `FORMAT` is always the attribute name.\n\n| Attribute | Modifier  | Supported in `SELECT` | Supported in `WHERE` |\n| :---: | --- | :---: | :---: |\n| `hash` | `SHA1(, n)` | ✔️ | ✔️ |\n| `name` | `UPPER` (synonymous to `FORMAT(, UPPER)`) | ✔️ | ✔️ |\n| | `LOWER` (synonymous to `FORMAT(, LOWER)`) | ✔️ | ✔️ |\n| | `FULLPATH` | ✔️ |  |\n| | `SHORTPATH`  | ✔️ |  |\n| `size` | `FORMAT(, unit)` | ✔️ | ✔️ |\n| `time` | `FORMAT(, layout)` | ✔️ | ✔️ |\n\n\n- **`n`**:\n\n  Specify the length of the hash value. Use a negative integer or `ALL` to display all digits.\n\n- **`unit`**:\n\n  Specify the size unit. One of: `B` (byte), `KB` (kilobyte), `MB` (megabyte), or `GB` (gigabyte).\n\n- **`layout`**:\n\n  Specify the time layout. One of: [`ISO`](https://en.wikipedia.org/wiki/ISO_8601), [`UNIX`](https://en.wikipedia.org/wiki/Unix_time), or [custom](https://golang.org/pkg/time/#Time.Format). Custom layouts must be provided in reference to the following date: `Mon Jan 2 15:04:05 -0700 MST 2006`.\n\n**Examples**:\n\n```console\n>>> SELECT SHA1(hash, 20) ...\n```\n\n```console\n>>> ... WHERE UPPER(name) ...\n```\n\n```console\n>>> SELECT FORMAT(size, MB) ...\n```\n\n```console\n>>> ... WHERE FORMAT(time, \"Mon Jan 2 2006 15:04:05\") ...\n```\n\n### Subqueries\n\nSubqueries allow for more complex condition statements. These queries are recursively evaluated while parsing. SELECTing multiple attributes in a subquery is not currently supported; if more than one attribute (or `all`) is provided, only the first attribute is used.\n\nSupport for referencing superqueries is not yet implemented, see [#4](https://github.com/kashav/fsql/issues/4) if you'd like to help with this.\n\n**Examples**:\n\n```console\n>>> ... WHERE name IN (SELECT name FROM ../foo) ...\n```\n\n## Usage Examples\n\nList all attributes of each directory in your home directory (note the escaped `*`):\n\n```console\n$ fsql SELECT \\* FROM ~ WHERE mode IS DIR\n```\n\nList the names of all files in the Desktop and Downloads directory that contain `csc` in the name:\n\n```console\n$ fsql \"SELECT name FROM ~/Desktop, ~/Downloads WHERE name LIKE %csc%\"\n```\n\nList all files in the current directory that are also present in some other directory:\n\n```console\n$ fsql\n>>> SELECT all FROM . WHERE name IN (\n...   SELECT name FROM ~/Desktop/files.bak/\n... );\n```\n\nPassing queries via stdin without quotes is a bit of a pain, hopefully the next examples highlight that, my suggestion is to use interactive mode or wrap the query in quotes if you're doing anything with subqueries or attribute modifiers.\n\nList all files named `main.go` in `$GOPATH` which are larger than 10.5 kilobytes or smaller than 100 bytes:\n\n```console\n$ fsql SELECT all FROM $GOPATH WHERE name = main.go AND \\(FORMAT\\(size, KB\\) \\>= 10.5 OR size \\< 100\\)\n$ fsql \"SELECT all FROM $GOPATH WHERE name = main.go AND (FORMAT(size, KB) >= 10.5 OR size < 100)\"\n$ fsql\n>>> SELECT\n...   all\n... FROM\n...   $GOPATH\n... WHERE\n...   name = main.go\n...   AND (\n...     FORMAT(size, KB) >= 10.5\n...     OR size < 100\n...   )\n... ;\n```\n\nList the name, size, and modification time of JavaScript files in the current directory that were modified after April 1st 2017:\n\n```console\n$ fsql SELECT UPPER\\(name\\), FORMAT\\(size, KB\\), FORMAT\\(time, ISO\\) FROM . WHERE name LIKE %.js AND time \\> \\'Apr 01 2017 00 00\\'\n$ fsql \"SELECT UPPER(name), FORMAT(size, KB), FORMAT(time, ISO) FROM . WHERE name LIKE %.js AND time > 'Apr 01 2017 00 00'\"\n$ fsql\n>>> SELECT\n...   UPPER(name),\n...   FORMAT(size, KB),\n...   FORMAT(time, ISO)\n... FROM\n...   .\n... WHERE\n...   name LIKE %.js\n...   AND time > 'Apr 01 2017 00 00'\n... ;\n```\n\n## Contribute\n\nThis project is completely open source, feel free to [open an issue](https://github.com/kashav/fsql/issues) or [submit a pull request](https://github.com/kashav/fsql/pulls).\n\nBefore submitting code, please ensure that tests are passing and the linter is happy. The following commands may be of use, refer to the [Makefile](./Makefile) to see what they do.\n\n```sh\n$ make install \\\n       get-tools\n$ make fmt \\\n       vet \\\n       lint\n$ make test \\\n       coverage\n$ make bootstrap-dist \\\n       dist\n```\n\n## License\n\nfsql source code is available under the [MIT license](./LICENSE).\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "0.5.2\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "evaluate",
          "type": "tree",
          "content": null
        },
        {
          "name": "fsql.go",
          "type": "blob",
          "size": 1.08984375,
          "content": "package fsql\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/kashav/fsql/parser\"\n)\n\n// Run parses the input and executes the resultant query.\nfunc Run(input string) error {\n\tq, err := parser.Run(input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Find length of the longest name to normalize name output.\n\tvar max = 0\n\tvar results = make([]map[string]interface{}, 0)\n\n\terr = q.Execute(\n\t\tfunc(path string, info os.FileInfo, result map[string]interface{}) {\n\t\t\tresults = append(results, result)\n\t\t\tif !q.HasAttribute(\"name\") {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif s, ok := result[\"name\"].(string); ok && len(s) > max {\n\t\t\t\tmax = len(s)\n\t\t\t}\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, result := range results {\n\t\tvar buf bytes.Buffer\n\t\tfor j, attribute := range q.Attributes {\n\t\t\t// If the current attribute is \"name\", pad the output string by `max`\n\t\t\t// spaces.\n\t\t\tformat := \"%v\"\n\t\t\tif attribute == \"name\" {\n\t\t\t\tformat = fmt.Sprintf(\"%%-%ds\", max)\n\t\t\t}\n\t\t\tbuf.WriteString(fmt.Sprintf(format, result[attribute]))\n\t\t\tif j != len(q.Attributes)-1 {\n\t\t\t\tbuf.WriteString(\"\\t\")\n\t\t\t}\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", buf.String())\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "fsql_test.go",
          "type": "blob",
          "size": 9.9951171875,
          "content": "package fsql\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar files = map[string]*os.FileInfo{}\n\nfunc TestRun_All(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\tcases := []Case{\n\t\t{\n\t\t\tquery: \"SELECT all FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\t-------\\tfoo\\n\",\n\t\t\t\tstrings.Join(GetAttrs(\"foo\", \"mode\", \"size\", \"time\"), \"\\t\")),\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT all FROM ./testdata WHERE name LIKE waldo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\twaldo\\n\",\n\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz/waldo\", \"mode\", \"size\", \"time\", \"hash\"), \"\\t\")),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT all FROM ./testdata WHERE FORMAT(time, 'Jan 02 2006 15:04') > 'Jan 01 2999 00:00'\",\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT all FROM ./testdata WHERE mode IS DIR\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\tstrings.Repeat(\"%s\\n\", 8),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\".\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"testdata\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"bar\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"bar\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"bar/garply\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"garply\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"bar/garply/xyzzy\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"xyzzy\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"bar/garply/xyzzy/thud\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"thud\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"foo\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"quuz\",\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%s\\t-------\\t%-8s\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz/fred\", \"mode\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t\t\"fred\",\n\t\t\t\t),\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n%v\\nGot:\\n%v\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRun_Multiple(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\tcases := []Case{\n\t\t{\n\t\t\tquery:    \"SELECT name, size FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"foo\\t%s\\n\", GetAttrs(\"foo\", \"size\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT size, name FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\tfoo\\n\", GetAttrs(\"foo\", \"size\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT FULLPATH(name), size, time FROM ./testdata/foo\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\tstrings.Repeat(\"%s\\n\", 7),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo/quux\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quux\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo/quuz\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo/quuz/fred\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz/fred\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo/quuz/fred/.gitkeep\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz/fred/.gitkeep\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo/quuz/waldo\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/quuz/waldo\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"%-31s\\t%s\",\n\t\t\t\t\t\"testdata/foo/qux\",\n\t\t\t\t\tstrings.Join(GetAttrs(\"foo/qux\", \"size\", \"time\"), \"\\t\"),\n\t\t\t\t),\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n%v\\nGot:\\n%v\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRun_Name(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\tcases := []Case{\n\t\t{\n\t\t\tquery:    \"SELECT name FROM ./testdata WHERE name REGEXP ^g.*\",\n\t\t\texpected: \"garply\\ngrault\\n\",\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT FULLPATH(name) FROM ./testdata WHERE name REGEXP ^b.*\",\n\t\t\texpected: \"testdata/bar\\ntestdata/baz\\n\",\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT UPPER(FULLPATH(name)) FROM ./testdata WHERE mode IS DIR\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\tstrings.Repeat(\"%-30s\\n\", 8),\n\t\t\t\t\"TESTDATA\",\n\t\t\t\t\"TESTDATA/BAR\",\n\t\t\t\t\"TESTDATA/BAR/GARPLY\",\n\t\t\t\t\"TESTDATA/BAR/GARPLY/XYZZY\",\n\t\t\t\t\"TESTDATA/BAR/GARPLY/XYZZY/THUD\",\n\t\t\t\t\"TESTDATA/FOO\",\n\t\t\t\t\"TESTDATA/FOO/QUUZ\",\n\t\t\t\t\"TESTDATA/FOO/QUUZ/FRED\",\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n%v\\nGot:\\n%v\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRun_Size(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\tcases := []Case{\n\t\t{\n\t\t\tquery:    \"SELECT size FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"foo\", \"size\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT FORMAT(size, KB) FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"foo\", \"size:kb\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT FORMAT(size, MB) FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"foo\", \"size:mb\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT FORMAT(size, GB) FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"foo\", \"size:gb\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT size FROM ./testdata WHERE name LIKE qu\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\tstrings.Repeat(\"%s\\n\", 3),\n\t\t\t\tGetAttrs(\"foo/quux\", \"size\")[0],\n\t\t\t\tGetAttrs(\"foo/quuz\", \"size\")[0],\n\t\t\t\tGetAttrs(\"foo/qux\", \"size\")[0],\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n%v\\nGot:\\n%v\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRun_Time(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\tcases := []Case{\n\t\t{\n\t\t\tquery:    \"SELECT time FROM ./testdata WHERE name = baz\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"baz\", \"time\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT FORMAT(time, ISO) FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"foo\", \"time:iso\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT FORMAT(time, 2006) FROM ./testdata WHERE NOT name LIKE .%\",\n\t\t\texpected: strings.Repeat(fmt.Sprintf(\"%s\\n\", GetAttrs(\".\", \"time:year\")[0]), 14),\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT time FROM ./testdata/foo/quuz\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\tstrings.Repeat(\"%s\\n\", 4),\n\t\t\t\tGetAttrs(\"foo/quuz\", \"time\")[0],\n\t\t\t\tGetAttrs(\"foo/quuz/fred\", \"time\")[0],\n\t\t\t\tGetAttrs(\"foo/quuz/fred/.gitkeep\", \"time\")[0],\n\t\t\t\tGetAttrs(\"foo/quuz/waldo\", \"time\")[0],\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n%v\\nGot:\\n%v\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRun_Mode(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\tcases := []Case{\n\t\t{\n\t\t\tquery:    \"SELECT mode FROM ./testdata WHERE name = foo\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"foo\", \"mode\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery:    \"SELECT mode FROM ./testdata WHERE name = baz\",\n\t\t\texpected: fmt.Sprintf(\"%s\\n\", GetAttrs(\"baz\", \"mode\")[0]),\n\t\t},\n\t\t{\n\t\t\tquery: \"SELECT mode FROM ./testdata WHERE mode IS DIR\",\n\t\t\texpected: fmt.Sprintf(strings.Repeat(\"%s\\n\", 8),\n\t\t\t\tGetAttrs(\"\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"foo\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"foo/quuz\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"foo/quuz/fred\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"bar\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"bar/garply\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"bar/garply/xyzzy\", \"mode\")[0],\n\t\t\t\tGetAttrs(\"bar/garply/xyzzy/thud\", \"mode\")[0],\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n\\\"%v\\\"\\nGot:\\n\\\"%v\\\"\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc TestRun_Hash(t *testing.T) {\n\ttype Case struct {\n\t\tquery    string\n\t\texpected string\n\t}\n\n\t// TODO\n\tcases := []Case{}\n\n\tfor _, c := range cases {\n\t\tactual := DoRun(c.query)\n\t\tif !reflect.DeepEqual(c.expected, actual) {\n\t\t\tt.Fatalf(\"%s\\nExpected:\\n%v\\nGot:\\n%v\", c.query, c.expected, actual)\n\t\t}\n\t}\n}\n\nfunc GetAttrs(path string, attrs ...string) []string {\n\t// If the files map is empty, walk ./testdata and populate it.\n\tif len(files) == 0 {\n\t\tif err := filepath.Walk(\n\t\t\t\"./testdata\",\n\t\t\tfunc(path string, info os.FileInfo, err error) error {\n\t\t\t\tfiles[filepath.Clean(path)] = &info\n\t\t\t\treturn nil\n\t\t\t},\n\t\t); err != nil {\n\t\t\treturn []string{}\n\t\t}\n\t}\n\n\tpath = filepath.Clean(fmt.Sprintf(\"testdata/%s\", path))\n\tfile, ok := files[path]\n\tif !ok {\n\t\treturn []string{}\n\t}\n\n\tresult := make([]string, len(attrs))\n\tfor i, attr := range attrs {\n\t\t// Hard-coding modifiers works for the time being, but we might need a more\n\t\t// elegant solution when we introduce new modifiers in the future.\n\t\tswitch attr {\n\t\tcase \"hash\":\n\t\t\tb, err := os.ReadFile(path)\n\t\t\tif err != nil {\n\t\t\t\treturn []string{}\n\t\t\t}\n\t\t\th := sha1.New()\n\t\t\tif _, err := h.Write(b); err != nil {\n\t\t\t\treturn []string{}\n\t\t\t}\n\t\t\tresult[i] = hex.EncodeToString(h.Sum(nil))[:7]\n\t\tcase \"mode\":\n\t\t\tresult[i] = (*file).Mode().String()\n\t\tcase \"size\":\n\t\t\tresult[i] = fmt.Sprintf(\"%d\", (*file).Size())\n\t\tcase \"size:kb\", \"size:mb\", \"size:gb\":\n\t\t\tsize := (*file).Size()\n\t\t\tswitch attr[len(attr)-2:] {\n\t\t\tcase \"kb\":\n\t\t\t\tresult[i] = fmt.Sprintf(\"%fkb\", float64(size)/(1<<10))\n\t\t\tcase \"mb\":\n\t\t\t\tresult[i] = fmt.Sprintf(\"%fmb\", float64(size)/(1<<20))\n\t\t\tcase \"gb\":\n\t\t\t\tresult[i] = fmt.Sprintf(\"%fgb\", float64(size)/(1<<30))\n\t\t\t}\n\t\tcase \"time\":\n\t\t\tresult[i] = (*file).ModTime().Format(time.Stamp)\n\t\tcase \"time:iso\":\n\t\t\tresult[i] = (*file).ModTime().Format(time.RFC3339)\n\t\tcase \"time:year\":\n\t\t\tresult[i] = (*file).ModTime().Format(\"2006\")\n\t\t}\n\t}\n\treturn result\n}\n\n// DoRun executes fsql.Run and returns the output.\nfunc DoRun(query string) string {\n\tstdout := os.Stdout\n\tch := make(chan string)\n\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tos.Stdout = w\n\n\tif err := Run(query); err != nil {\n\t\treturn \"\"\n\t}\n\n\tgo func() {\n\t\tvar buf bytes.Buffer\n\t\tio.Copy(&buf, r)\n\t\tch <- buf.String()\n\t}()\n\n\tw.Close()\n\tos.Stdout = stdout\n\treturn <-ch\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1982421875,
          "content": "module github.com/kashav/fsql\n\ngo 1.21\n\nrequire (\n\tgithub.com/oleiade/lane v1.0.1\n\tgolang.org/x/crypto v0.17.0\n)\n\nrequire (\n\tgolang.org/x/sys v0.15.0 // indirect\n\tgolang.org/x/term v0.15.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.6171875,
          "content": "github.com/oleiade/lane v1.0.1 h1:hXofkn7GEOubzTwNpeL9MaNy8WxolCYb9cInAIeqShU=\ngithub.com/oleiade/lane v1.0.1/go.mod h1:IyTkraa4maLfjq/GmHR+Dxb4kCMtEGeb+qmhlrQ5Mk4=\ngolang.org/x/crypto v0.17.0 h1:r8bRNjWL3GshPW3gkd+RpvzWrZAwPS49OmTGZ/uhM4k=\ngolang.org/x/crypto v0.17.0/go.mod h1:gCAAfMLgwOJRpTjQ2zCCt2OcSfYMTeZVSRtQlPC7Nq4=\ngolang.org/x/sys v0.15.0 h1:h48lPFYpsTvQJZF4EKyI4aLHaev3CxivZmv7yZig9pc=\ngolang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.15.0 h1:y/Oo/a/q3IXu26lQgl04j/gjuBDOBlx7X6Om1j2CPW4=\ngolang.org/x/term v0.15.0/go.mod h1:BDl952bC7+uMoWR75FIrCDx79TPU9oHkTZ9yRbYOrX0=\n"
        },
        {
          "name": "media",
          "type": "tree",
          "content": null
        },
        {
          "name": "meta",
          "type": "tree",
          "content": null
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "query",
          "type": "tree",
          "content": null
        },
        {
          "name": "terminal",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tokenizer",
          "type": "tree",
          "content": null
        },
        {
          "name": "transform",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}