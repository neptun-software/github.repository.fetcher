{
  "metadata": {
    "timestamp": 1736567334953,
    "page": 946,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "stianeikeland/go-rpio",
      "stars": 2210,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.24609375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Stian Eikeland\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.310546875,
          "content": "go-rpio\n=======\n\nNative GPIO-Gophers for your Pi!\n\n**Documentation:** [![GoDoc](https://pkg.go.dev/badge/github.com/stianeikeland/go-rpio)](https://pkg.go.dev/github.com/stianeikeland/go-rpio/v4)\n\ngo-rpio is a Go library for accessing [GPIO](http://elinux.org/Rpi_Low-level_peripherals)-pins\non the [Raspberry Pi](https://en.wikipedia.org/wiki/Raspberry_Pi).\n\nIt requires no external c libraries such as\n[WiringPI](https://projects.drogon.net/raspberry-pi/wiringpi/) or [bcm2835](http://www.open.com.au/mikem/bcm2835).\n\nThere's a tiny bit of additional information over at my [blog](https://blog.eikeland.se/2013/07/30/go-gpio-library-for-raspberry-pi/).\n\n![raspberrypi-blink](https://blog.eikeland.se/images/2013-07-30-go-gpio-library-for-raspberry-pi/animated.gif)\n\n## Releases ##\n- 1.0.0 - Supports original rpi A/B/B+\n- 2.0.0 - Adds support for rpi 2, by @akramer\n- 3.0.0 - Adds support for /dev/gpiomem, by @dotdoom\n- 4.0.0 - Adds support for PWM and Clock modes, by @drahoslove\n- 4.1.0 - Adds support for edge detection, by @drahoslove\n- 4.2.0 - Faster write and toggle of output pins, by @drahoslove\n- 4.3.0 - Adds support for SPI, by @drahoslove\n- 4.4.0 - Support for disabling interrupts (workaround for #35), by @drahoslove\n- 4.5.0 - Improve rpi 4 support, by @wfd3\n- 4.6.0 - Adds Balanced PWM mode, by @youngkin\n\n## Usage ##\n\n```go\nimport \"github.com/stianeikeland/go-rpio/v4\"\n```\n\nIf you're using an older go.mod incompatible you should instead use:\n```go\nimport \"github.com/stianeikeland/go-rpio\"\n```\n\nOpen memory range for GPIO access in /dev/mem\n\n```go\nerr := rpio.Open()\n```\n\nInitialize a pin, run basic operations.\nPin refers to the bcm2835 pin, not the physical pin on the raspberry pi header. Pin 10 here is exposed on the pin header as physical pin 19.\n\n```go\npin := rpio.Pin(10)\n\npin.Output()       // Output mode\npin.High()         // Set pin High\npin.Low()          // Set pin Low\npin.Toggle()       // Toggle pin (Low -> High -> Low)\n\npin.Input()        // Input mode\nres := pin.Read()  // Read state from pin (High / Low)\n\npin.Mode(rpio.Output)   // Alternative syntax\npin.Write(rpio.High)    // Alternative syntax\n```\n\nPull up/down/off can be set using:\n\n```go\npin.PullUp()\npin.PullDown()\npin.PullOff()\n\npin.Pull(rpio.PullUp)\n```\n\nUnmap memory when done\n\n```go\nrpio.Close()\n```\n\nAlso see example [examples/blinker/blinker.go](examples/blinker/blinker.go)\n\n### SPI\n\n#### setup/teardown\n  - `rpio.SpiBegin(rpio.Spi0)` has to be called first before using any Spi func. It will change pin modes to `Spi` and initialize default setting.\n  - `rpio.SpiEnd(rpio.Spi0)` should be called at the end, it will switch pin modes to `Input`.\n\n#### transferring data\n  - `rpio.SpiTransmit(byte)` or `rpio.SpiTransmit(bytes...)` will transmit byte or bytes to slave.\n  - `rpio.SpiReceive(n)` will return n bytes received from slave.\n  - `rpio.SpiExchange(buffer)` will simultaneously transmit data from the buffer to slave and data from slave to the same buffer in full duplex way.\n\n#### settings\n  - `rpio.SpiSpeed(hz)` will set transmit speed of SPI\n  - `rpio.SpiChipSelect(n)` will select chip/slave (ce0, ce1, or ce2) to which transferring will be done\n  - `rpio.SpiChipSelectPolarity(n, pol)` set chip select polarity (low enabled is used by default which usually works most of the time)\n  - `rpio.SpiMode(cpol, cpha)` set clock/communication mode (=combination of clock polarity and clock phase; cpol=0, cpha=0 is used by default which usually works most of the time)\n\n## Other ##\n\nCurrently, it supports basic functionality such as:\n- Pin Direction (Input / Output)\n- Write (High / Low)\n- Read (High / Low)\n- Pull (Up / Down / Off)\n- PWM (hardware, on supported pins)\n- Clock\n- Edge detection\n\nIt works by memory-mapping the bcm2835 gpio range, and therefore require root/administrative-rights to run.\n\n## Using without root ##\n\nThis library can utilize the new [/dev/gpiomem](https://github.com/raspberrypi/linux/pull/1112/files) \nmemory range if available. \n\nYou will probably need to upgrade to the latest kernel (or wait for the next raspbian release) if you're missing /dev/gpiomem. You will also need to add a `gpio` group, add your user to the group, and then set up udev rules. I would recommend using [create_gpio_user_permissions.py](https://github.com/waveform80/rpi-gpio/blob/master/create_gpio_user_permissions.py) if you're unsure how to do this.\n\nPWM modes will still require root.\n\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.05078125,
          "content": "module github.com/stianeikeland/go-rpio/v4\n\ngo 1.15\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "rpio.go",
          "type": "blob",
          "size": 22.0205078125,
          "content": "/*\nPackage rpio provides GPIO access on the Raspberry PI without any need\nfor external c libraries (eg. WiringPi or BCM2835).\n\nSupports simple operations such as:\n       - Pin mode/direction (input/output/clock/pwm,alt0,alt1,alt2,alt3,alt4,alt5)\n       - Pin write (high/low)\n       - Pin read (high/low)\n       - Pin edge detection (no/rise/fall/any)\n       - Pull up/down/off\nAlso clock/pwm related oparations:\n       - Set Clock frequency\n       - Set Duty cycle\nAnd SPI oparations:\n       - SPI transmit/recieve/exchange bytes\n       - Set speed\n       - Chip select\n\nExample of use:\n\n       rpio.Open()\n       defer rpio.Close()\n\n       pin := rpio.Pin(4)\n       pin.Output()\n\n       for {\n           pin.Toggle()\n           time.Sleep(time.Second)\n       }\n\nThe library use the raw BCM2835 pinouts, not the ports as they are mapped\non the output pins for the raspberry pi, and not the wiringPi convention.\n\n            Rev 2 and 3 Raspberry Pi                        Rev 1 Raspberry Pi (legacy)\n  +-----+---------+----------+---------+-----+      +-----+--------+----------+--------+-----+\n  | BCM |   Name  | Physical | Name    | BCM |      | BCM | Name   | Physical | Name   | BCM |\n  +-----+---------+----++----+---------+-----+      +-----+--------+----++----+--------+-----+\n  |     |    3.3v |  1 || 2  | 5v      |     |      |     | 3.3v   |  1 ||  2 | 5v     |     |\n  |   2 |   SDA 1 |  3 || 4  | 5v      |     |      |   0 | SDA    |  3 ||  4 | 5v     |     |\n  |   3 |   SCL 1 |  5 || 6  | 0v      |     |      |   1 | SCL    |  5 ||  6 | 0v     |     |\n  |   4 | GPIO  7 |  7 || 8  | TxD     | 14  |      |   4 | GPIO 7 |  7 ||  8 | TxD    |  14 |\n  |     |      0v |  9 || 10 | RxD     | 15  |      |     | 0v     |  9 || 10 | RxD    |  15 |\n  |  17 | GPIO  0 | 11 || 12 | GPIO  1 | 18  |      |  17 | GPIO 0 | 11 || 12 | GPIO 1 |  18 |\n  |  27 | GPIO  2 | 13 || 14 | 0v      |     |      |  21 | GPIO 2 | 13 || 14 | 0v     |     |\n  |  22 | GPIO  3 | 15 || 16 | GPIO  4 | 23  |      |  22 | GPIO 3 | 15 || 16 | GPIO 4 |  23 |\n  |     |    3.3v | 17 || 18 | GPIO  5 | 24  |      |     | 3.3v   | 17 || 18 | GPIO 5 |  24 |\n  |  10 |    MOSI | 19 || 20 | 0v      |     |      |  10 | MOSI   | 19 || 20 | 0v     |     |\n  |   9 |    MISO | 21 || 22 | GPIO  6 | 25  |      |   9 | MISO   | 21 || 22 | GPIO 6 |  25 |\n  |  11 |    SCLK | 23 || 24 | CE0     | 8   |      |  11 | SCLK   | 23 || 24 | CE0    |   8 |\n  |     |      0v | 25 || 26 | CE1     | 7   |      |     | 0v     | 25 || 26 | CE1    |   7 |\n  |   0 |   SDA 0 | 27 || 28 | SCL 0   | 1   |      +-----+--------+----++----+--------+-----+\n  |   5 | GPIO 21 | 29 || 30 | 0v      |     |\n  |   6 | GPIO 22 | 31 || 32 | GPIO 26 | 12  |\n  |  13 | GPIO 23 | 33 || 34 | 0v      |     |\n  |  19 | GPIO 24 | 35 || 36 | GPIO 27 | 16  |\n  |  26 | GPIO 25 | 37 || 38 | GPIO 28 | 20  |\n  |     |      0v | 39 || 40 | GPIO 29 | 21  |\n  +-----+---------+----++----+---------+-----+\n\nSee the spec for full details of the BCM2835 controller:\n\nhttps://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf\nand https://elinux.org/BCM2835_datasheet_errata - for errors in that spec\n\nChanges to support the BCM2711, used on the Raspberry Pi 4, were cribbed from https://github.com/RPi-Distro/raspi-gpio/\n\n*/\npackage rpio\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"os\"\n\t\"reflect\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n)\n\ntype Mode uint8\ntype Pin uint8\ntype State uint8\ntype Pull uint8\ntype Edge uint8\n\n// Memory offsets for gpio, see the spec for more details\nconst (\n\tbcm2835Base = 0x20000000\n\tgpioOffset  = 0x200000\n\tclkOffset   = 0x101000\n\tpwmOffset   = 0x20C000\n\tspiOffset   = 0x204000\n\tintrOffset  = 0x00B000\n\n\tmemLength = 4096\n)\n\n// BCM 2711 has a different mechanism for pull-up/pull-down/enable\nconst (\n\tGPPUPPDN0 = 57 // Pin pull-up/down for pins 15:0\n\tGPPUPPDN1 = 58 // Pin pull-up/down for pins 31:16\n\tGPPUPPDN2 = 59 // Pin pull-up/down for pins 47:32\n\tGPPUPPDN3 = 60 // Pin pull-up/down for pins 57:48\n)\n\nvar (\n\tgpioBase int64\n\tclkBase  int64\n\tpwmBase  int64\n\tspiBase  int64\n\tintrBase int64\n\n\tirqsBackup uint64\n)\n\nfunc init() {\n\tbase := getBase()\n\tgpioBase = base + gpioOffset\n\tclkBase = base + clkOffset\n\tpwmBase = base + pwmOffset\n\tspiBase = base + spiOffset\n\tintrBase = base + intrOffset\n}\n\n// Pin mode, a pin can be set in Input or Output, Clock or Pwm mode\nconst (\n\tInput Mode = iota\n\tOutput\n\tClock\n\tPwm\n\tSpi\n\tAlt0\n\tAlt1\n\tAlt2\n\tAlt3\n\tAlt4\n\tAlt5\n)\n\n// State of pin, High / Low\nconst (\n\tLow State = iota\n\tHigh\n)\n\n// Which PWM algorithm to use, Balanced or Mark/Space\nconst (\n\tBalanced  = true\n\tMarkSpace = false\n)\n\n// Pull Up / Down / Off\nconst (\n\tPullOff Pull = iota\n\tPullDown\n\tPullUp\n\tPullNone\n)\n\n// Edge events\nconst (\n\tNoEdge Edge = iota\n\tRiseEdge\n\tFallEdge\n\tAnyEdge = RiseEdge | FallEdge\n)\n\n// Arrays for 8 / 32 bit access to memory and a semaphore for write locking\nvar (\n\tmemlock  sync.Mutex\n\tgpioMem  []uint32\n\tclkMem   []uint32\n\tpwmMem   []uint32\n\tspiMem   []uint32\n\tintrMem  []uint32\n\tgpioMem8 []uint8\n\tclkMem8  []uint8\n\tpwmMem8  []uint8\n\tspiMem8  []uint8\n\tintrMem8 []uint8\n)\n\n// Input: Set pin as Input\nfunc (pin Pin) Input() {\n\tPinMode(pin, Input)\n}\n\n// Output: Set pin as Output\nfunc (pin Pin) Output() {\n\tPinMode(pin, Output)\n}\n\n// Clock: Set pin as Clock\nfunc (pin Pin) Clock() {\n\tPinMode(pin, Clock)\n}\n\n// Pwm: Set pin as Pwm\nfunc (pin Pin) Pwm() {\n\tPinMode(pin, Pwm)\n}\n\n// High: Set pin High\nfunc (pin Pin) High() {\n\tWritePin(pin, High)\n}\n\n// Low: Set pin Low\nfunc (pin Pin) Low() {\n\tWritePin(pin, Low)\n}\n\n// Toggle pin state\nfunc (pin Pin) Toggle() {\n\tTogglePin(pin)\n}\n\n// Freq: Set frequency of Clock or Pwm pin (see doc of SetFreq)\nfunc (pin Pin) Freq(freq int) {\n\tSetFreq(pin, freq)\n}\n\n// DutyCycle: Set duty cycle for Pwm pin (see doc of SetDutyCycle)\nfunc (pin Pin) DutyCycle(dutyLen, cycleLen uint32) {\n\tSetDutyCycle(pin, dutyLen, cycleLen)\n}\n\n// DutyCycleWithPwmMode: Set duty cycle for Pwm pin while also specifying which PWM\n// mode to use, Balanced or MarkSpace (see doc of SetDutyCycleWithPwmMode)\nfunc (pin Pin) DutyCycleWithPwmMode(dutyLen, cycleLen uint32, mode bool) {\n\tSetDutyCycleWithPwmMode(pin, dutyLen, cycleLen, mode)\n}\n\n// Mode: Set pin Mode\nfunc (pin Pin) Mode(mode Mode) {\n\tPinMode(pin, mode)\n}\n\n// Write: Set pin state (high/low)\nfunc (pin Pin) Write(state State) {\n\tWritePin(pin, state)\n}\n\n// Read pin state (high/low)\nfunc (pin Pin) Read() State {\n\treturn ReadPin(pin)\n}\n\n// Pull: Set a given pull up/down mode\nfunc (pin Pin) Pull(pull Pull) {\n\tPullMode(pin, pull)\n}\n\n// PullUp: Pull up pin\nfunc (pin Pin) PullUp() {\n\tPullMode(pin, PullUp)\n}\n\n// PullDown: Pull down pin\nfunc (pin Pin) PullDown() {\n\tPullMode(pin, PullDown)\n}\n\n// PullOff: Disable pullup/down on pin\nfunc (pin Pin) PullOff() {\n\tPullMode(pin, PullOff)\n}\n\nfunc (pin Pin) ReadPull() Pull {\n\tif !isBCM2711() {\n\t\treturn PullNone // Can't read pull-up/pull-down state on other Pi boards\n\t}\n\n\treg := GPPUPPDN0 + (uint8(pin) >> 4)\n\tbits := gpioMem[reg] >> ((uint8(pin) & 0xf) << 1) & 0x3\n\tswitch bits {\n\tcase 0:\n\t\treturn PullOff\n\tcase 1:\n\t\treturn PullUp\n\tcase 2:\n\t\treturn PullDown\n\tdefault:\n\t\treturn PullNone // Invalid\n\t}\n}\n\n// Detect: Enable edge event detection on pin\nfunc (pin Pin) Detect(edge Edge) {\n\tDetectEdge(pin, edge)\n}\n\n// EdgeDetected checks edge event on pin\nfunc (pin Pin) EdgeDetected() bool {\n\treturn EdgeDetected(pin)\n}\n\n// PinMode sets the mode of a given pin (Input, Output, Clock, Pwm or Spi)\n//\n// Clock is possible only for pins 4, 5, 6, 20, 21.\n// Pwm is possible only for pins 12, 13, 18, 19.\n//\n// Spi mode should not be set by this directly, use SpiBegin instead.\nfunc PinMode(pin Pin, mode Mode) {\n\n\t// Pin fsel register, 0 or 1 depending on bank\n\tfselReg := uint8(pin) / 10\n\tshift := (uint8(pin) % 10) * 3\n\tf := uint32(0)\n\n\tconst in = 0   // 000\n\tconst out = 1  // 001\n\tconst alt0 = 4 // 100\n\tconst alt1 = 5 // 101\n\tconst alt2 = 6 // 110\n\tconst alt3 = 7 // 111\n\tconst alt4 = 3 // 011\n\tconst alt5 = 2 // 010\n\n\tswitch mode {\n\tcase Input:\n\t\tf = in\n\tcase Output:\n\t\tf = out\n\tcase Clock:\n\t\tswitch pin {\n\t\tcase 4, 5, 6, 32, 34, 42, 43, 44:\n\t\t\tf = alt0\n\t\tcase 20, 21:\n\t\t\tf = alt5\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\tcase Pwm:\n\t\tswitch pin {\n\t\tcase 12, 13, 40, 41, 45:\n\t\t\tf = alt0\n\t\tcase 18, 19:\n\t\t\tf = alt5\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\tcase Spi:\n\t\tswitch pin {\n\t\tcase 7, 8, 9, 10, 11: // SPI0\n\t\t\tf = alt0\n\t\tcase 35, 36, 37, 38, 39: // SPI0\n\t\t\tf = alt0\n\t\tcase 16, 17, 18, 19, 20, 21: // SPI1\n\t\t\tf = alt4\n\t\tcase 40, 41, 42, 43, 44, 45: // SPI2\n\t\t\tf = alt4\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\tcase Alt0:\n\t\tf = alt0\n\tcase Alt1:\n\t\tf = alt1\n\tcase Alt2:\n\t\tf = alt2\n\tcase Alt3:\n\t\tf = alt3\n\tcase Alt4:\n\t\tf = alt4\n\tcase Alt5:\n\t\tf = alt5\n\t}\n\n\tmemlock.Lock()\n\tdefer memlock.Unlock()\n\n\tconst pinMask = 7 // 111 - pinmode is 3 bits\n\n\tgpioMem[fselReg] = (gpioMem[fselReg] &^ (pinMask << shift)) | (f << shift)\n}\n\n// WritePin sets a given pin High or Low\n// by setting the clear or set registers respectively\nfunc WritePin(pin Pin, state State) {\n\tp := uint8(pin)\n\n\t// Set register, 7 / 8 depending on bank\n\t// Clear register, 10 / 11 depending on bank\n\tsetReg := p/32 + 7\n\tclearReg := p/32 + 10\n\n\tmemlock.Lock()\n\n\tif state == Low {\n\t\tgpioMem[clearReg] = 1 << (p & 31)\n\t} else {\n\t\tgpioMem[setReg] = 1 << (p & 31)\n\t}\n\tmemlock.Unlock() // not deferring saves ~600ns\n}\n\n// ReadPin reads the state of a pin\nfunc ReadPin(pin Pin) State {\n\t// Input level register offset (13 / 14 depending on bank)\n\tlevelReg := uint8(pin)/32 + 13\n\n\tif (gpioMem[levelReg] & (1 << uint8(pin&31))) != 0 {\n\t\treturn High\n\t}\n\n\treturn Low\n}\n\n// TogglePin: Toggle a pin state (high -> low -> high)\nfunc TogglePin(pin Pin) {\n\tp := uint8(pin)\n\n\tsetReg := p/32 + 7\n\tclearReg := p/32 + 10\n\tlevelReg := p/32 + 13\n\n\tbit := uint32(1 << (p & 31))\n\n\tmemlock.Lock()\n\n\tif (gpioMem[levelReg] & bit) != 0 {\n\t\tgpioMem[clearReg] = bit\n\t} else {\n\t\tgpioMem[setReg] = bit\n\t}\n\tmemlock.Unlock()\n}\n\n// DetectEdge: Enable edge event detection on pin.\n//\n// Combine with pin.EdgeDetected() to check whether event occured.\n//\n// Note that using this function might conflict with the same functionality of other gpio library.\n//\n// It also clears previously detected event of this pin if there was any.\n//\n// Note that call with RiseEdge will disable previously set FallEdge detection and vice versa.\n// You have to call with AnyEdge, to enable detection for both edges.\n// To disable previously enabled detection call it with NoEdge.\n//\n// WARNING: this might make your Pi unresponsive, if this happens, you should either run the code as root,\n// or add `dtoverlay=gpio-no-irq` to `/boot/config.txt` and restart your pi,\nfunc DetectEdge(pin Pin, edge Edge) {\n\tif edge != NoEdge {\n\t\t// disable GPIO event interruption to prevent freezing in some cases\n\t\tDisableIRQs(1<<49 | 1<<52) // gpio_int[0] and gpio_int[3]\n\t}\n\n\tp := uint8(pin)\n\n\t// Rising edge detect enable register (19/20 depending on bank)\n\t// Falling edge detect enable register (22/23 depending on bank)\n\t// Event detect status register (16/17)\n\trenReg := p/32 + 19\n\tfenReg := p/32 + 22\n\tedsReg := p/32 + 16\n\n\tbit := uint32(1 << (p & 31))\n\n\tif edge&RiseEdge > 0 { // set bit\n\t\tgpioMem[renReg] |= bit\n\t} else { // clear bit\n\t\tgpioMem[renReg] &^= bit\n\t}\n\tif edge&FallEdge > 0 { // set bit\n\t\tgpioMem[fenReg] |= bit\n\t} else { // clear bit\n\t\tgpioMem[fenReg] &^= bit\n\t}\n\n\tgpioMem[edsReg] = bit // to clear outdated detection\n}\n\n// EdgeDetected checks whether edge event occured since last call\n// or since detection was enabled\n//\n// There is no way (yet) to handle interruption caused by edge event, you have to use polling.\n//\n// Event detection has to be enabled first, by pin.Detect(edge)\nfunc EdgeDetected(pin Pin) bool {\n\tp := uint8(pin)\n\n\t// Event detect status register (16/17)\n\tedsReg := p/32 + 16\n\n\ttest := gpioMem[edsReg] & (1 << (p & 31))\n\tgpioMem[edsReg] = test // set bit to clear it\n\treturn test != 0\n}\n\nfunc PullMode(pin Pin, pull Pull) {\n\n\tmemlock.Lock()\n\tdefer memlock.Unlock()\n\n\tif isBCM2711() {\n\t\tpullreg := GPPUPPDN0 + (pin >> 4)\n\t\tpullshift := (pin & 0xf) << 1\n\n\t\tvar p uint32\n\n\t\tswitch pull {\n\t\tcase PullOff:\n\t\t\tp = 0\n\t\tcase PullUp:\n\t\t\tp = 1\n\t\tcase PullDown:\n\t\t\tp = 2\n\t\t}\n\n\t\t// This is verbatim C code from raspi-gpio.c\n\t\tpullbits := gpioMem[pullreg]\n\t\tpullbits &= ^(3 << pullshift)\n\t\tpullbits |= (p << pullshift)\n\t\tgpioMem[pullreg] = pullbits\n\t} else {\n\t\t// Pull up/down/off register has offset 38 / 39, pull is 37\n\t\tpullClkReg := pin/32 + 38\n\t\tpullReg := 37\n\t\tshift := pin % 32\n\n\t\tswitch pull {\n\t\tcase PullDown, PullUp:\n\t\t\tgpioMem[pullReg] |= uint32(pull)\n\t\tcase PullOff:\n\t\t\tgpioMem[pullReg] &^= 3\n\t\t}\n\n\t\t// Wait for value to clock in, this is ugly, sorry :(\n\t\ttime.Sleep(time.Microsecond)\n\n\t\tgpioMem[pullClkReg] = 1 << shift\n\n\t\t// Wait for value to clock in\n\t\ttime.Sleep(time.Microsecond)\n\n\t\tgpioMem[pullReg] &^= 3\n\t\tgpioMem[pullClkReg] = 0\n\t}\n}\n\n// SetFreq: Set clock speed for given pin in Clock or Pwm mode\n//\n// Param freq should be in range 4688Hz - 19.2MHz to prevent unexpected behavior,\n// however output frequency of Pwm pins can be further adjusted with SetDutyCycle.\n// So for smaller frequencies use Pwm pin with large cycle range. (Or implement custom software clock using output pin and sleep.)\n//\n// Note that some pins share the same clock source, it means that\n// changing frequency for one pin will change it also for all pins within a group.\n// The groups are:\n//   gp_clk0: pins 4, 20, 32, 34\n//   gp_clk1: pins 5, 21, 42, 44\n//   gp_clk2: pins 6 and 43\n//   pwm_clk: pins 12, 13, 18, 19, 40, 41, 45\nfunc SetFreq(pin Pin, freq int) {\n\t// TODO: would be nice to choose best clock source depending on target frequency, oscilator is used for now\n\tsourceFreq := 19200000 // oscilator frequency\n\tif isBCM2711() {\n\t\tsourceFreq = 52000000\n\t}\n\tconst divMask = 4095 // divi and divf have 12 bits each\n\n\tdivi := uint32(sourceFreq / freq)\n\tdivf := uint32(((sourceFreq % freq) << 12) / freq)\n\n\tdivi &= divMask\n\tdivf &= divMask\n\n\tclkCtlReg := 28\n\tclkDivReg := 28\n\tswitch pin {\n\tcase 4, 20, 32, 34: // clk0\n\t\tclkCtlReg += 0\n\t\tclkDivReg += 1\n\tcase 5, 21, 42, 44: // clk1\n\t\tclkCtlReg += 2\n\t\tclkDivReg += 3\n\tcase 6, 43: // clk2\n\t\tclkCtlReg += 4\n\t\tclkDivReg += 5\n\tcase 12, 13, 40, 41, 45, 18, 19: // pwm_clk - shared clk for both pwm channels\n\t\tclkCtlReg += 12\n\t\tclkDivReg += 13\n\t\tStopPwm() // pwm clk busy wont go down without stopping pwm first\n\t\tdefer StartPwm()\n\tdefault:\n\t\treturn\n\t}\n\n\tmash := uint32(1 << 9) // 1-stage MASH\n\tif divi < 2 || divf == 0 {\n\t\tmash = 0\n\t}\n\n\tmemlock.Lock()\n\tdefer memlock.Unlock()\n\n\tconst PASSWORD = 0x5A000000\n\tconst busy = 1 << 7\n\tconst enab = 1 << 4\n\tconst src = 1 << 0 // oscilator\n\n\tclkMem[clkCtlReg] = PASSWORD | (clkMem[clkCtlReg] &^ enab) // stop gpio clock (without changing src or mash)\n\tfor clkMem[clkCtlReg]&busy != 0 {\n\t\ttime.Sleep(time.Microsecond * 10)\n\t} // ... and wait for not busy\n\n\tclkMem[clkCtlReg] = PASSWORD | mash | src          // set mash and source (without enabling clock)\n\tclkMem[clkDivReg] = PASSWORD | (divi << 12) | divf // set dividers\n\n\t// mash and src can not be changed in same step as enab, to prevent lock-up and glitches\n\ttime.Sleep(time.Microsecond * 10) // ... so wait for them to take effect\n\n\tclkMem[clkCtlReg] = PASSWORD | mash | src | enab // finally start clock\n\n\t// NOTE without root permission this changes will simply do nothing successfully\n}\n\n// SetDutyCycle: Set cycle length (range) and duty length (data) for Pwm pin in M/S mode\n//\n//   |<- duty ->|\n//    __________\n//  _/          \\_____________/\n//   |<------- cycle -------->|\n//\n// Output frequency is computed as pwm clock frequency divided by cycle length.\n// So, to set Pwm pin to freqency 38kHz with duty cycle 1/4, use this combination:\n//\n//  pin.Pwm()\n//  pin.DutyCycle(1, 4)\n//  pin.Freq(38000*4)\n//\n// Note that some pins share common pwm channel,\n// so calling this function will set same duty cycle for all pins belonging to channel.\n// The channels are:\n//   channel 1 (pwm0) for pins 12, 18, 40\n//   channel 2 (pwm1) for pins 13, 19, 41, 45.\n//\n// NOTE without root permission this function will simply do nothing successfully\nfunc SetDutyCycle(pin Pin, dutyLen, cycleLen uint32) {\n\tSetDutyCycleWithPwmMode(pin, dutyLen, cycleLen, MarkSpace)\n\n}\n\n// SetDutyCycleWithPwmMode extends SetDutyCycle to allow for the specification of the PWM\n// algorithm to be used, Balanced or Mark/Space. The constants Balanced or MarkSpace\n// as the value. See 'SetDutyCycle(pin, dutyLen, cycleLen)' above for more information\n// regarding how to use 'SetDutyCycleWithPwmMode()'.\n//\n// NOTE without root permission this function will simply do nothing successfully\nfunc SetDutyCycleWithPwmMode(pin Pin, dutyLen, cycleLen uint32, mode bool) {\n\tconst pwmCtlReg = 0\n\tvar (\n\t\tpwmDatReg uint\n\t\tpwmRngReg uint\n\t\tshift     uint // offset inside ctlReg\n\n\t)\n\n\tswitch pin {\n\tcase 12, 18, 40: // channel pwm0\n\t\tpwmRngReg = 4\n\t\tpwmDatReg = 5\n\t\tshift = 0\n\tcase 13, 19, 41, 45: // channel pwm1\n\t\tpwmRngReg = 8\n\t\tpwmDatReg = 9\n\t\tshift = 8\n\tdefault:\n\t\treturn\n\n\t}\n\n\tconst ctlMask = 255 // ctl setting has 8 bits for each channel\n\tconst pwen = 1 << 0 // enable pwm\n\tvar msen uint32 = 0\n\t// The MSEN1 field in the CTL register is at offset 7. This block starts with the assumption\n\t// that 'msen' will be associated with channel 'pwm0'. If this is not the case, 'msen' will\n\t// be further shifted in the next code block below to the MSEN2 field at offset 15.\n\tif mode == MarkSpace {\n\t\tmsen = 1 << 7\n\t}\n\n\t// Shifting 'pwen' and 'msen' puts the associated values at the correct offset within the CTL\n\t// register ('pwmCtlReg'). In addition, 'msen' is associated with a PWM channel depending on the\n\t// value of 'pin' (see above). 'msen' will either stay at offset 7, as set above for channel 'pwm0',\n\t// or be shifted 8 bits if the the associated 'pin' is on channel 'pwm1'.\n\tpwmMem[pwmCtlReg] = pwmMem[pwmCtlReg]&^(ctlMask<<shift) | msen<<shift | pwen<<shift\n\n\t// set duty cycle\n\tpwmMem[pwmDatReg] = dutyLen\n\tpwmMem[pwmRngReg] = cycleLen\n\ttime.Sleep(time.Microsecond * 10)\n}\n\n// StopPwm: Stop pwm for both channels\nfunc StopPwm() {\n\tconst pwmCtlReg = 0\n\tconst pwen = 1\n\tpwmMem[pwmCtlReg] &^= pwen<<8 | pwen\n}\n\n// StartPwm starts pwm for both channels\nfunc StartPwm() {\n\tconst pwmCtlReg = 0\n\tconst pwen = 1\n\tpwmMem[pwmCtlReg] |= pwen<<8 | pwen\n}\n\n// EnableIRQs: Enables given IRQs (by setting bit to 1 at intended position).\n// See 'ARM peripherals interrupts table' in pheripherals datasheet.\n// WARNING: you can corrupt your system, only use this if you know what you are doing.\nfunc EnableIRQs(irqs uint64) {\n\tconst irqEnable1 = 0x210 / 4\n\tconst irqEnable2 = 0x214 / 4\n\tintrMem[irqEnable1] = uint32(irqs)       // IRQ 0..31\n\tintrMem[irqEnable2] = uint32(irqs >> 32) // IRQ 32..63\n}\n\n// DisableIRQs: Disables given IRQs (by setting bit to 1 at intended position).\n// See 'ARM peripherals interrupts table' in pheripherals datasheet.\n// WARNING: you can corrupt your system, only use this if you know what you are doing.\nfunc DisableIRQs(irqs uint64) {\n\tconst irqDisable1 = 0x21C / 4\n\tconst irqDisable2 = 0x220 / 4\n\tintrMem[irqDisable1] = uint32(irqs)       // IRQ 0..31\n\tintrMem[irqDisable2] = uint32(irqs >> 32) // IRQ 32..63\n}\n\nfunc backupIRQs() {\n\tconst irqEnable1 = 0x210 / 4\n\tconst irqEnable2 = 0x214 / 4\n\tirqsBackup = uint64(intrMem[irqEnable2])<<32 | uint64(intrMem[irqEnable1])\n}\n\n// Open and memory map GPIO memory range from /dev/mem .\n// Some reflection magic is used to convert it to a unsafe []uint32 pointer\nfunc Open() (err error) {\n\tvar file *os.File\n\n\t// Open fd for rw mem access; try dev/mem first (need root)\n\tfile, err = os.OpenFile(\"/dev/mem\", os.O_RDWR|os.O_SYNC, os.ModePerm)\n\tif os.IsPermission(err) { // try gpiomem otherwise (some extra functions like clock and pwm setting wont work)\n\t\tfile, err = os.OpenFile(\"/dev/gpiomem\", os.O_RDWR|os.O_SYNC, os.ModePerm)\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\t// FD can be closed after memory mapping\n\tdefer file.Close()\n\n\tmemlock.Lock()\n\tdefer memlock.Unlock()\n\n\t// Memory map GPIO registers to slice\n\tgpioMem, gpioMem8, err = memMap(file.Fd(), gpioBase)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Memory map clock registers to slice\n\tclkMem, clkMem8, err = memMap(file.Fd(), clkBase)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Memory map pwm registers to slice\n\tpwmMem, pwmMem8, err = memMap(file.Fd(), pwmBase)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Memory map spi registers to slice\n\tspiMem, spiMem8, err = memMap(file.Fd(), spiBase)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Memory map interruption registers to slice\n\tintrMem, intrMem8, err = memMap(file.Fd(), intrBase)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tbackupIRQs() // back up enabled IRQs, to restore it later\n\n\treturn nil\n}\n\nfunc memMap(fd uintptr, base int64) (mem []uint32, mem8 []byte, err error) {\n\tmem8, err = syscall.Mmap(\n\t\tint(fd),\n\t\tbase,\n\t\tmemLength,\n\t\tsyscall.PROT_READ|syscall.PROT_WRITE,\n\t\tsyscall.MAP_SHARED,\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\t// Convert mapped byte memory to unsafe []uint32 pointer, adjust length as needed\n\theader := *(*reflect.SliceHeader)(unsafe.Pointer(&mem8))\n\theader.Len /= (32 / 8) // (32 bit = 4 bytes)\n\theader.Cap /= (32 / 8)\n\tmem = *(*[]uint32)(unsafe.Pointer(&header))\n\treturn\n}\n\n// Close unmaps GPIO memory\nfunc Close() error {\n\tEnableIRQs(irqsBackup) // Return IRQs to state where it was before - just to be nice\n\n\tmemlock.Lock()\n\tdefer memlock.Unlock()\n\tfor _, mem8 := range [][]uint8{gpioMem8, clkMem8, pwmMem8, spiMem8, intrMem8} {\n\t\tif err := syscall.Munmap(mem8); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Read /proc/device-tree/soc/ranges and determine the base address.\n// Use the default Raspberry Pi 1 base address if this fails.\nfunc readBase(offset int64) (int64, error) {\n\tranges, err := os.Open(\"/proc/device-tree/soc/ranges\")\n\tdefer ranges.Close()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tb := make([]byte, 4)\n\tn, err := ranges.ReadAt(b, offset)\n\tif n != 4 || err != nil {\n\t\treturn 0, err\n\t}\n\tbuf := bytes.NewReader(b)\n\tvar out uint32\n\terr = binary.Read(buf, binary.BigEndian, &out)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif out == 0 {\n\t\treturn 0, errors.New(\"rpio: GPIO base address not found\")\n\t}\n\treturn int64(out), nil\n}\n\nfunc getBase() int64 {\n\t// Pi 2 & 3 GPIO base address is at offset 4\n\tb, err := readBase(4)\n\tif err == nil {\n\t\treturn b\n\t}\n\n\t// Pi 4 GPIO base address is as offset 8\n\tb, err = readBase(8)\n\tif err == nil {\n\t\treturn b\n\t}\n\n\t// Default to Pi 1\n\treturn int64(bcm2835Base)\n}\n\n// The Pi 4 uses a BCM 2711, which has different register offsets and base addresses than the rest of the Pi family (so far).  This\n// helper function checks if we're on a 2711 and hence a Pi 4\nfunc isBCM2711() bool {\n\treturn gpioMem[GPPUPPDN3] != 0x6770696f\n}\n"
        },
        {
          "name": "rpio_test.go",
          "type": "blob",
          "size": 4.0859375,
          "content": "package rpio\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMain(m *testing.M) {\n\tprintln(\"Note: bcm pins 2 and 3 has to be directly connected\")\n\tif err := Open(); err != nil {\n\t\tpanic(err)\n\t}\n\tdefer Close()\n\tos.Exit(m.Run())\n}\n\nfunc TestInterrupt(t *testing.T) {\n\tlogIrqRegs(t)\n\tEnableIRQs(1 << 49)\n\tEnableIRQs(1 << 50)\n\tEnableIRQs(1 << 51)\n\tEnableIRQs(1 << 52)\n\tlogIrqRegs(t)\n\tDisableIRQs(1 << 49)\n\tDisableIRQs(1 << 50)\n\tDisableIRQs(1 << 51)\n\tDisableIRQs(1 << 52)\n\tlogIrqRegs(t)\n\tEnableIRQs(irqsBackup)\n}\n\nfunc TestEvent(t *testing.T) {\n\tsrc := Pin(3)\n\tsrc.Mode(Output)\n\n\tpin := Pin(2)\n\tpin.Mode(Input)\n\tpin.PullDown()\n\n\tt.Run(\"rising edge\", func(t *testing.T) {\n\t\tpin.Detect(RiseEdge)\n\t\tsrc.Low()\n\n\t\tfor i := 0; ; i++ {\n\t\t\tsrc.High()\n\n\t\t\ttime.Sleep(time.Second / 10)\n\t\t\tif pin.EdgeDetected() {\n\t\t\t\tt.Log(\"edge rised\")\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Rise event should be detected\")\n\t\t\t}\n\t\t\tif i == 5 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tsrc.Low()\n\t\t}\n\n\t\ttime.Sleep(time.Second / 10)\n\t\tif pin.EdgeDetected() {\n\t\t\tt.Error(\"Rise should not be detected, no change since last call\")\n\t\t}\n\t\tpin.Detect(NoEdge)\n\t\tsrc.High()\n\t\tif pin.EdgeDetected() {\n\t\t\tt.Error(\"Rise should not be detected, events disabled\")\n\t\t}\n\n\t})\n\n\tt.Run(\"falling edge\", func(t *testing.T) {\n\t\tpin.Detect(FallEdge)\n\t\tsrc.High()\n\n\t\tfor i := 0; ; i++ {\n\t\t\tsrc.Low()\n\n\t\t\ttime.Sleep(time.Second / 10)\n\t\t\tif pin.EdgeDetected() {\n\t\t\t\tt.Log(\"edge fallen\")\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Fall event should be detected\")\n\t\t\t}\n\n\t\t\tif i == 5 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tsrc.High()\n\t\t}\n\t\ttime.Sleep(time.Second / 10)\n\t\tif pin.EdgeDetected() {\n\t\t\tt.Error(\"Fall should not be detected, no change since last call\")\n\t\t}\n\t\tpin.Detect(NoEdge)\n\t\tsrc.Low()\n\t\tif pin.EdgeDetected() {\n\t\t\tt.Error(\"Fall should not be detected, events disabled\")\n\t\t}\n\t})\n\n\tt.Run(\"both edges\", func(t *testing.T) {\n\t\tpin.Detect(AnyEdge)\n\t\tsrc.Low()\n\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tsrc.High()\n\n\t\t\tif pin.EdgeDetected() {\n\t\t\t\tt.Log(\"edge detected\")\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Rise event shoud be detected\")\n\t\t\t}\n\n\t\t\tsrc.Low()\n\n\t\t\tif pin.EdgeDetected() {\n\t\t\t\tt.Log(\"edge detected\")\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Fall edge should be detected\")\n\t\t\t}\n\t\t}\n\n\t\tpin.Detect(NoEdge)\n\t\tsrc.High()\n\t\tsrc.Low()\n\n\t\tif pin.EdgeDetected() {\n\t\t\tt.Errorf(\"No edge should be detected, events disabled\")\n\t\t}\n\n\t})\n\n\t// If this fr⁽eezes your pi,\n\t// add `dtoverlay=gpio-no-irq` to `/boot/config.txt` and restart your pi,\n\t// or run as root.\n\tt.Run(\"multiple edges\", func(t *testing.T) {\n\t\tEnableIRQs(15 << 49) // all 4 gpio_int[]\n\t\tlogIrqRegs(t)\n\t\tsrc.High()\n\t\tpin.Detect(FallEdge)\n\n\t\tlogIrqRegs(t)\n\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tsrc.High()\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t\tsrc.Low()\n\t\t}\n\t\tlogIrqRegs(t)\n\t\tif !pin.EdgeDetected() {\n\t\t\tt.Errorf(\"Edge not detected\")\n\t\t}\n\t\tlogIrqRegs(t)\n\t\tpin.Detect(NoEdge)\n\t\tlogIrqRegs(t)\n\t\tEnableIRQs(irqsBackup)\n\t})\n\n}\n\nfunc BenchmarkGpio(b *testing.B) {\n\tsrc := Pin(3)\n\tsrc.Mode(Output)\n\tsrc.Low()\n\n\tpin := Pin(2)\n\tpin.Mode(Input)\n\tpin.PullDown()\n\n\toldWrite := func(pin Pin, state State) {\n\t\tp := uint8(pin)\n\n\t\tsetReg := p/32 + 7\n\t\tclearReg := p/32 + 10\n\n\t\tmemlock.Lock()\n\t\tdefer memlock.Unlock()\n\n\t\tif state == Low {\n\t\t\tgpioMem[clearReg] = 1 << (p & 31)\n\t\t} else {\n\t\t\tgpioMem[setReg] = 1 << (p & 31)\n\t\t}\n\t}\n\n\toldToggle := func(pin Pin) {\n\t\tswitch ReadPin(pin) {\n\t\tcase Low:\n\t\t\toldWrite(pin, High)\n\t\tcase High:\n\t\t\toldWrite(pin, Low)\n\t\t}\n\t}\n\n\tb.Run(\"write\", func(b *testing.B) {\n\t\tb.Run(\"old\", func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tif i%2 == 0 {\n\t\t\t\t\toldWrite(src, High)\n\t\t\t\t} else {\n\t\t\t\t\toldWrite(src, Low)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tb.Run(\"new\", func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tif i%2 == 0 {\n\t\t\t\t\tWritePin(src, High)\n\t\t\t\t} else {\n\t\t\t\t\tWritePin(src, Low)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n\n\tb.Run(\"toggle\", func(b *testing.B) {\n\t\tb.Run(\"old\", func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\toldToggle(src)\n\t\t\t}\n\t\t})\n\n\t\tb.Run(\"new\", func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tTogglePin(src)\n\t\t\t}\n\t\t})\n\t})\n\n}\n\nfunc logIrqRegs(t *testing.T) {\n\tfmt.Printf(\"PENDING(% X) FIQ(% X) ENAB(% X) DISAB(% X)\\n\",\n\t\tintrMem8[0x200:0x20C],\n\t\tintrMem8[0x20C:0x210],\n\t\tintrMem8[0x210:0x21C],\n\t\tintrMem8[0x21C:0x228],\n\t)\n}\n"
        },
        {
          "name": "spi.go",
          "type": "blob",
          "size": 4.4560546875,
          "content": "package rpio\n\nimport (\n\t\"errors\"\n)\n\ntype SpiDev int\n\n// SPI devices.\n// Only SPI0 supported for now.\nconst (\n\tSpi0 SpiDev = iota\n\tSpi1        // aux\n\tSpi2        // aux\n)\n\nconst (\n\tcsReg     = 0\n\tfifoReg   = 1 // TX/RX FIFO\n\tclkDivReg = 2\n)\n\nvar (\n\tSpiMapError = errors.New(\"SPI registers not mapped correctly - are you root?\")\n)\n\n// SpiBegin: Sets all pins of given SPI device to SPI mode\n//  dev\\pin | CE0 | CE1 | CE2 | SCLK | MOSI | MISO |\n//  Spi0    |   7 |   8 |   - |    9 |   10 |   11 |\n//  Spi1    |  16 |  17 |  18 |   19 |   20 |   21 |\n//  Spi2    |  40 |  41 |  42 |   43 |   44 |   45 |\n//\n// It also resets SPI control register.\n//\n// Note that you should disable SPI interface in raspi-config first!\nfunc SpiBegin(dev SpiDev) error {\n\tspiMem[csReg] = 0 // reset spi settings to default\n\tif spiMem[csReg] == 0 {\n\t\t// this should not read only zeroes after reset -> mem map failed\n\t\treturn SpiMapError\n\t}\n\n\tfor _, pin := range getSpiPins(dev) {\n\t\tpin.Mode(Spi)\n\t}\n\n\tclearSpiTxRxFifo()\n\tsetSpiDiv(128)\n\treturn nil\n}\n\n// SpiEnd: Sets SPI pins of given device to default (Input) mode. See SpiBegin.\nfunc SpiEnd(dev SpiDev) {\n\tvar pins = getSpiPins(dev)\n\tfor _, pin := range pins {\n\t\tpin.Mode(Input)\n\t}\n}\n\n// SpiSpeed: Set (maximal) speed [Hz] of SPI clock.\n// Param speed may be as big as 125MHz in theory, but\n// only values up to 31.25MHz are considered relayable.\nfunc SpiSpeed(speed int) {\n\tcoreFreq := 250 * 1000000\n\tif isBCM2711() {\n\t\tcoreFreq = 550 * 1000000\n\t}\n\tcdiv := uint32(coreFreq / speed)\n\tsetSpiDiv(cdiv)\n}\n\n// SpiChipSelect: Select chip, one of 0, 1, 2\n// for selecting slave on CE0, CE1, or CE2 pin\nfunc SpiChipSelect(chip uint8) {\n\tconst csMask = 3 // chip select has 2 bits\n\n\tcs := uint32(chip & csMask)\n\n\tspiMem[csReg] = spiMem[csReg]&^csMask | cs\n}\n\n// SpiChipSelectPolarity: Sets polarity (0/1) of active chip select\n// default active=0\nfunc SpiChipSelectPolarity(chip uint8, polarity uint8) {\n\tif chip > 2 {\n\t\treturn\n\t}\n\tcspol := uint32(1 << (21 + chip)) // bit 21, 22 or 23 depending on chip\n\n\tif polarity == 0 { // chip select is active low\n\t\tspiMem[csReg] &^= cspol\n\t} else { // chip select is active hight\n\t\tspiMem[csReg] |= cspol\n\t}\n}\n\n// SpiMode: Set polarity (0/1) and phase (0/1) of spi clock\n// default polarity=0; phase=0\nfunc SpiMode(polarity uint8, phase uint8) {\n\tconst cpol = 1 << 3\n\tconst cpha = 1 << 2\n\n\tif polarity == 0 { // Rest state of clock = low\n\t\tspiMem[csReg] &^= cpol\n\t} else { // Rest state of clock = high\n\t\tspiMem[csReg] |= cpol\n\t}\n\n\tif phase == 0 { // First SCLK transition at middle of data bit\n\t\tspiMem[csReg] &^= cpha\n\t} else { // First SCLK transition at beginning of data bit\n\t\tspiMem[csReg] |= cpha\n\t}\n}\n\n// SpiTransmit takes one or more bytes and send them to slave.\n//\n// Data received from slave are ignored.\n// Use spread operator to send slice of bytes.\nfunc SpiTransmit(data ...byte) {\n\tSpiExchange(append(data[:0:0], data...)) // clone data because it will be rewriten by received bytes\n}\n\n// SpiReceive receives n bytes from slave.\n//\n// Note that n zeroed bytes are send to slave as side effect.\nfunc SpiReceive(n int) []byte {\n\tdata := make([]byte, n, n)\n\tSpiExchange(data)\n\treturn data\n}\n\n// SpiExchange: Transmit all bytes in data to slave\n// and simultaneously receives bytes from slave to data.\n//\n// If you want to only send or only receive, use SpiTransmit/SpiReceive\nfunc SpiExchange(data []byte) {\n\tconst ta = 1 << 7   // transfer active\n\tconst txd = 1 << 18 // tx fifo can accept data\n\tconst rxd = 1 << 17 // rx fifo contains data\n\tconst done = 1 << 16\n\n\tclearSpiTxRxFifo()\n\n\t// set TA = 1\n\tspiMem[csReg] |= ta\n\n\tfor i := range data {\n\t\t// wait for TXD\n\t\tfor spiMem[csReg]&txd == 0 {\n\t\t}\n\t\t// write bytes to SPI_FIFO\n\t\tspiMem[fifoReg] = uint32(data[i])\n\n\t\t// wait for RXD\n\t\tfor spiMem[csReg]&rxd == 0 {\n\t\t}\n\t\t// read bytes from SPI_FIFO\n\t\tdata[i] = byte(spiMem[fifoReg])\n\t}\n\n\t// wait for DONE\n\tfor spiMem[csReg]&done == 0 {\n\t}\n\n\t// Set TA = 0\n\tspiMem[csReg] &^= ta\n}\n\n// set spi clock divider value\nfunc setSpiDiv(div uint32) {\n\tconst divMask = 1<<16 - 1 - 1 // cdiv have 16 bits and must be odd (for some reason)\n\tspiMem[clkDivReg] = div & divMask\n}\n\n// clear both FIFOs\nfunc clearSpiTxRxFifo() {\n\tconst clearTxRx = 1<<5 | 1<<4\n\tspiMem[csReg] |= clearTxRx\n}\n\nfunc getSpiPins(dev SpiDev) []Pin {\n\tswitch dev {\n\tcase Spi0:\n\t\treturn []Pin{7, 8, 9, 10, 11}\n\t\t// ommit 35, 36, 37, 38, 39 - only one set of SPI0 can be set in Spi mode at a time\n\tcase Spi1:\n\t\treturn []Pin{16, 17, 18, 19, 20, 21}\n\tcase Spi2:\n\t\treturn []Pin{40, 41, 42, 43, 44, 45}\n\tdefault:\n\t\treturn []Pin{}\n\t}\n}\n"
        },
        {
          "name": "spi_test.go",
          "type": "blob",
          "size": 0.4111328125,
          "content": "package rpio\n\nimport ()\n\nfunc ExampleSpiTransmit() {\n\tSpiTransmit(0xFF)             // send single byte\n\tSpiTransmit(0xDE, 0xAD, 0xBE) // send several bytes\n\n\tdata := []byte{'H', 'e', 'l', 'l', 'o', 0}\n\tSpiTransmit(data...) // send slice of bytes\n}\n\nfunc ExampleSpiBegin() {\n\terr := SpiBegin(Spi0) // pins 7 to 11\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// any Spi functions must go there...\n\tSpiTransmit(42)\n\n\tSpiEnd(Spi0)\n}\n"
        }
      ]
    }
  ]
}