{
  "metadata": {
    "timestamp": 1736567146716,
    "page": 742,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "awnumar/memguard",
      "stars": 2570,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 1.916015625,
          "content": "linux_task:\n  container:\n    image: golang:latest\n  env:\n    GO111MODULE: on\n    GOPATH: /tmp/go\n    CIRRUS_WORKING_DIR: /tmp/go/src/github.com/${CIRRUS_REPO_FULL_NAME}\n  build_script:\n    - go version\n    - go get ./...\n    - go build -race -v ./...\n  test_script:\n    - go test -race -v ./...\n  bench_script:\n    - go test -run=XXX -bench=. ./...\n\nosx_task:\n  macos_instance:\n    image: ghcr.io/cirruslabs/macos-ventura-base:latest\n  env:\n    GO111MODULE: on\n    GOPATH: /tmp/go\n    PATH: ${GOPATH}/bin:${PATH}\n    CIRRUS_WORKING_DIR: /tmp/go/src/github.com/${CIRRUS_REPO_FULL_NAME}\n  install_script:\n    - brew install go\n  build_script:\n    - go version\n    - go get ./...\n    - go build -race -v ./...\n  test_script:\n    - go test -race -v ./...\n  bench_script:\n    - go test -run=XXX -bench=. ./...\n\nwindows_task:\n  windows_container:\n    image: cirrusci/windowsservercore:2019\n  env:\n    GO111MODULE: on\n    GOPATH: C:\\golang\n    PATH: ${GOPATH}\\bin;C:\\Program Files\\Go\\bin;C:\\Users\\ContainerAdministrator\\go\\bin;${PATH}\n    CIRRUS_WORKING_DIR: C:\\golang\\src\\github.com\\${CIRRUS_REPO_FULL_NAME}\n  install_script:\n    - choco install -y golang\n    - choco install -y mingw  # This installs MinGW which includes gcc\n    - refreshenv\n    - gcc --version\n  build_script:\n    - go version\n    - go get ./...\n    - env CGO_ENABLED=1 go build -race -v ./...\n  test_script:\n    - refreshenv\n    - echo $PATH\n    - env CGO_ENABLED=1 go test -race -v ./...\n  bench_script:\n    - go test -run=XXX -bench=. ./...\n\nfreebsd_task:\n  freebsd_instance:\n    image: freebsd-14-0-release-amd64-ufs\n  env:\n    GO111MODULE: on\n    GOPATH: /tmp/go\n    PATH: ${GOPATH}/bin:${PATH}\n    CIRRUS_WORKING_DIR: /tmp/go/src/github.com/${CIRRUS_REPO_FULL_NAME}\n  install_script:\n    - pkg install -y go git\n  build_script:\n    - go version\n    - go get ./...\n    - go build -race -v ./...\n  test_script:\n    - go test -race -v ./...\n  bench_script:\n    - go test -run=XXX -bench=. ./...\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.419921875,
          "content": "# Entries should be added alphabetically in the form:\n#   Name or Organization <email address>\n\nAndrew LeFevre <jalefevre@liberty.edu>\nAwn Umar <awn@spacetime.dev>\nCarlo Alberto Ferraris <cafxx@strayorange.com>\ndotcppfile <dotcppfile@gmail.com>\nFedor Korotkov <fedor@cirruslabs.org>\nJam Adams <wodadehencou@gmail.com>\nJoseph Richey <joerichey@google.com>\nNeven Sajko <nsajko@gmail.com>\nPaul Zeinlinger <paul.zeinlinger@gmail.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.7177734375,
          "content": "<p align=\"center\">\n  <img src=\"https://cdn.rawgit.com/awnumar/memguard/master/logo.svg\" height=\"140\" />\n  <h3 align=\"center\">MemGuard</h3>\n  <p align=\"center\">Software enclave for storage of sensitive information in memory.</p>\n  <p align=\"center\">\n    <a href=\"https://cirrus-ci.com/github/awnumar/memguard\"><img src=\"https://api.cirrus-ci.com/github/awnumar/memguard.svg\"></a>\n    <a href=\"https://pkg.go.dev/github.com/awnumar/memguard?tab=doc\"><img src=\"https://godoc.org/github.com/awnumar/memguard?status.svg\"></a>\n  </p>\n</p>\n\n---\n\nThis package attempts to reduce the likelihood of sensitive data being exposed when in memory. It aims to support all major operating systems and is written in pure Go.\n\n## Features\n\n* Sensitive data is encrypted and authenticated in memory with XSalsa20Poly1305. The [scheme](https://spacetime.dev/encrypting-secrets-in-memory) used also [defends against cold-boot attacks](https://spacetime.dev/memory-retention-attacks).\n* Memory allocation bypasses the language runtime by [using system calls](https://github.com/awnumar/memcall) to query the kernel for resources directly. This avoids interference from the garbage-collector.\n* Buffers that store plaintext data are fortified with guard pages and canary values to detect spurious accesses and overflows.\n* Effort is taken to prevent sensitive data from touching the disk. This includes locking memory to prevent swapping and handling core dumps.\n* Kernel-level immutability is implemented so that attempted modification of protected regions results in an access violation.\n* Multiple endpoints provide session purging and safe termination capabilities as well as signal handling to prevent remnant data being left behind.\n* Side-channel attacks are mitigated against by making sure that the copying and comparison of data is done in constant-time.\n\nSome features were inspired by [libsodium](https://github.com/jedisct1/libsodium), so credits to them.\n\nFull documentation and a complete overview of the API can be found [here](https://godoc.org/github.com/awnumar/memguard). Interesting and useful code samples can be found within the [examples](examples) subpackage.\n\n## Installation\n\n```\n$ go get github.com/awnumar/memguard\n```\n\nAPI is experimental and may have unstable changes. You should pin a version. [[modules](https://github.com/golang/go/wiki/Modules)]\n\n## Contributing\n\n* Submitting program samples to [`./examples`](examples).\n* Reporting bugs, vulnerabilities, and any difficulties in using the API.\n* Writing useful security and crypto libraries that utilise memguard.\n* Implementing kernel-specific/cpu-specific protections.\n* Submitting performance improvements.\n\nIssues are for reporting bugs and for discussion on proposals. Pull requests should be made against master.\n"
        },
        {
          "name": "buffer.go",
          "type": "blob",
          "size": 17.0791015625,
          "content": "package memguard\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/awnumar/memguard/core\"\n)\n\n/*\nLockedBuffer is a structure that holds raw sensitive data.\n\nThe number of LockedBuffers that you are able to create is limited by how much memory your system's kernel allows each process to mlock/VirtualLock. Therefore you should call Destroy on LockedBuffers that you no longer need or defer a Destroy call after creating a new LockedBuffer.\n*/\ntype LockedBuffer struct {\n\t*core.Buffer\n}\n\n// Constructs a LockedBuffer object from a core.Buffer while also setting up the finalizer for it.\nfunc newBuffer(buf *core.Buffer) *LockedBuffer {\n\treturn &LockedBuffer{buf}\n}\n\n// Constructs a quasi-destroyed LockedBuffer with size zero.\nfunc newNullBuffer() *LockedBuffer {\n\treturn &LockedBuffer{new(core.Buffer)}\n}\n\n/*\nNewBuffer creates a mutable data container of the specified size.\n*/\nfunc NewBuffer(size int) *LockedBuffer {\n\t// Construct a Buffer of the specified size.\n\tbuf, err := core.NewBuffer(size)\n\tif err != nil {\n\t\treturn newNullBuffer()\n\t}\n\n\t// Construct and return the wrapped container object.\n\treturn newBuffer(buf)\n}\n\n/*\nNewBufferFromBytes constructs an immutable buffer from a byte slice. The source buffer is wiped after the value has been copied over to the created container.\n*/\nfunc NewBufferFromBytes(src []byte) *LockedBuffer {\n\t// Construct a buffer of the correct size.\n\tb := NewBuffer(len(src))\n\tif b.Size() == 0 {\n\t\treturn b\n\t}\n\n\t// Move the data over.\n\tb.Move(src)\n\n\t// Make the buffer immutable.\n\tb.Freeze()\n\n\t// Return the created Buffer object.\n\treturn b\n}\n\n/*\nNewBufferFromReader reads some number of bytes from an io.Reader into an immutable LockedBuffer.\n\nAn error is returned precisely when the number of bytes read is less than the requested amount. Any data read is returned in either case.\n*/\nfunc NewBufferFromReader(r io.Reader, size int) (*LockedBuffer, error) {\n\t// Construct a buffer of the provided size.\n\tb := NewBuffer(size)\n\tif b.Size() == 0 {\n\t\treturn b, nil\n\t}\n\n\t// Attempt to fill it with data from the Reader.\n\tif n, err := io.ReadFull(r, b.Bytes()); err != nil {\n\t\tif n == 0 {\n\t\t\t// nothing was read\n\t\t\tb.Destroy()\n\t\t\treturn newNullBuffer(), err\n\t\t}\n\n\t\t// partial read\n\t\td := NewBuffer(n)\n\t\td.Copy(b.Bytes()[:n])\n\t\td.Freeze()\n\t\tb.Destroy()\n\t\treturn d, err\n\t}\n\n\t// success\n\tb.Freeze()\n\treturn b, nil\n}\n\n/*\nNewBufferFromReaderUntil constructs an immutable buffer containing data sourced from an io.Reader object.\n\nIf an error is encountered before the delimiter value, the error will be returned along with the data read up until that point.\n*/\nfunc NewBufferFromReaderUntil(r io.Reader, delim byte) (*LockedBuffer, error) {\n\t// Construct a buffer with a data page that fills an entire memory page.\n\tb := NewBuffer(os.Getpagesize())\n\n\t// Loop over the buffer a byte at a time.\n\tfor i := 0; ; i++ {\n\t\t// If we have filled this buffer...\n\t\tif i == b.Size() {\n\t\t\t// Construct a new buffer that is a page size larger.\n\t\t\tc := NewBuffer(b.Size() + os.Getpagesize())\n\n\t\t\t// Copy the data over.\n\t\t\tc.Copy(b.Bytes())\n\n\t\t\t// Destroy the old one and reassign its variable.\n\t\t\tb.Destroy()\n\t\t\tb = c\n\t\t}\n\n\t\t// Attempt to read a single byte.\n\t\tn, err := r.Read(b.Bytes()[i : i+1])\n\t\tif n != 1 { // if we did not read a byte\n\t\t\tif err == nil { // and there was no error\n\t\t\t\ti-- // try again\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// if instead there was an error, we're done early\n\t\t\tif i == 0 { // no data read\n\t\t\t\tb.Destroy()\n\t\t\t\treturn newNullBuffer(), err\n\t\t\t}\n\t\t\td := NewBuffer(i)\n\t\t\td.Copy(b.Bytes()[:i])\n\t\t\td.Freeze()\n\t\t\tb.Destroy()\n\t\t\treturn d, err\n\t\t}\n\t\t// we managed to read a byte, check if it was the delimiter\n\t\t// note that errors are ignored in this case where we got data\n\t\tif b.Bytes()[i] == delim {\n\t\t\tif i == 0 {\n\t\t\t\t// if first byte was delimiter, there's no data to return\n\t\t\t\tb.Destroy()\n\t\t\t\treturn newNullBuffer(), nil\n\t\t\t}\n\t\t\td := NewBuffer(i)\n\t\t\td.Copy(b.Bytes()[:i])\n\t\t\td.Freeze()\n\t\t\tb.Destroy()\n\t\t\treturn d, nil\n\t\t}\n\t}\n}\n\n/*\nNewBufferFromEntireReader reads from an io.Reader into an immutable buffer. It will continue reading until EOF.\n\nA nil error is returned precisely when we managed to read all the way until EOF. Any data read is returned in either case.\n*/\nfunc NewBufferFromEntireReader(r io.Reader) (*LockedBuffer, error) {\n\t// Create a buffer with a data region of one page size.\n\tb := NewBuffer(os.Getpagesize())\n\n\tfor read := 0; ; {\n\t\t// Attempt to read some data from the reader.\n\t\tn, err := r.Read(b.Bytes()[read:])\n\n\t\t// Nothing read but no error, try again.\n\t\tif n == 0 && err == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// 1) so either have data and no error\n\t\t// 2) or have error and no data\n\t\t// 3) or both have data and have error\n\n\t\t// Increment the read count by the number of bytes that we just read.\n\t\tread += n\n\n\t\tif err != nil {\n\t\t\t// Suppress EOF error\n\t\t\tif err == io.EOF {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\t// We're done, return the data.\n\t\t\tif read == 0 {\n\t\t\t\t// No data read.\n\t\t\t\tb.Destroy()\n\t\t\t\treturn newNullBuffer(), err\n\t\t\t}\n\t\t\td := NewBuffer(read)\n\t\t\td.Copy(b.Bytes()[:read])\n\t\t\td.Freeze()\n\t\t\tb.Destroy()\n\t\t\treturn d, err\n\t\t}\n\n\t\t// If we've filled this buffer, grow it by another page size.\n\t\tif len(b.Bytes()[read:]) == 0 {\n\t\t\td := NewBuffer(b.Size() + os.Getpagesize())\n\t\t\td.Copy(b.Bytes())\n\t\t\tb.Destroy()\n\t\t\tb = d\n\t\t}\n\t}\n}\n\n/*\nNewBufferRandom constructs an immutable buffer filled with cryptographically-secure random bytes.\n*/\nfunc NewBufferRandom(size int) *LockedBuffer {\n\t// Construct a buffer of the specified size.\n\tb := NewBuffer(size)\n\tif b.Size() == 0 {\n\t\treturn b\n\t}\n\n\t// Fill the buffer with random bytes.\n\tb.Scramble()\n\n\t// Make the buffer immutable.\n\tb.Freeze()\n\n\t// Return the created Buffer object.\n\treturn b\n}\n\n// Freeze makes a LockedBuffer's memory immutable. The call can be reversed with Melt.\nfunc (b *LockedBuffer) Freeze() {\n\tb.Buffer.Freeze()\n}\n\n// Melt makes a LockedBuffer's memory mutable. The call can be reversed with Freeze.\nfunc (b *LockedBuffer) Melt() {\n\tb.Buffer.Melt()\n}\n\n/*\nSeal takes a LockedBuffer object and returns its contents encrypted inside a sealed Enclave object. The LockedBuffer is subsequently destroyed and its contents wiped.\n\nIf Seal is called on a destroyed buffer, a nil enclave is returned.\n*/\nfunc (b *LockedBuffer) Seal() *Enclave {\n\te, err := core.Seal(b.Buffer)\n\tif err != nil {\n\t\tif err == core.ErrBufferExpired {\n\t\t\treturn nil\n\t\t}\n\t\tcore.Panic(err)\n\t}\n\treturn &Enclave{e}\n}\n\n/*\nCopy performs a time-constant copy into a LockedBuffer. Move is preferred if the source is not also a LockedBuffer or if the source is no longer needed.\n*/\nfunc (b *LockedBuffer) Copy(src []byte) {\n\tb.CopyAt(0, src)\n}\n\n/*\nCopyAt performs a time-constant copy into a LockedBuffer at an offset. Move is preferred if the source is not also a LockedBuffer or if the source is no longer needed.\n*/\nfunc (b *LockedBuffer) CopyAt(offset int, src []byte) {\n\tif !b.IsAlive() {\n\t\treturn\n\t}\n\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tcore.Copy(b.Bytes()[offset:], src)\n}\n\n/*\nMove performs a time-constant move into a LockedBuffer. The source is wiped after the bytes are copied.\n*/\nfunc (b *LockedBuffer) Move(src []byte) {\n\tb.MoveAt(0, src)\n}\n\n/*\nMoveAt performs a time-constant move into a LockedBuffer at an offset. The source is wiped after the bytes are copied.\n*/\nfunc (b *LockedBuffer) MoveAt(offset int, src []byte) {\n\tif !b.IsAlive() {\n\t\treturn\n\t}\n\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tcore.Move(b.Bytes()[offset:], src)\n}\n\n/*\nScramble attempts to overwrite the data with cryptographically-secure random bytes.\n*/\nfunc (b *LockedBuffer) Scramble() {\n\tif !b.IsAlive() {\n\t\treturn\n\t}\n\n\tb.Buffer.Scramble()\n}\n\n/*\nWipe attempts to overwrite the data with zeros.\n*/\nfunc (b *LockedBuffer) Wipe() {\n\tif !b.IsAlive() {\n\t\treturn\n\t}\n\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tcore.Wipe(b.Bytes())\n}\n\n/*\nSize gives you the length of a given LockedBuffer's data segment. A destroyed LockedBuffer will have a size of zero.\n*/\nfunc (b *LockedBuffer) Size() int {\n\treturn len(b.Bytes())\n}\n\n/*\nDestroy wipes and frees the underlying memory of a LockedBuffer. The LockedBuffer will not be accessible or usable after this calls is made.\n*/\nfunc (b *LockedBuffer) Destroy() {\n\tb.Buffer.Destroy()\n}\n\n/*\nIsAlive returns a boolean value indicating if a LockedBuffer is alive, i.e. that it has not been destroyed.\n*/\nfunc (b *LockedBuffer) IsAlive() bool {\n\treturn b.Buffer.Alive()\n}\n\n/*\nIsMutable returns a boolean value indicating if a LockedBuffer is mutable.\n*/\nfunc (b *LockedBuffer) IsMutable() bool {\n\treturn b.Buffer.Mutable()\n}\n\n/*\nEqualTo performs a time-constant comparison on the contents of a LockedBuffer with a given buffer. A destroyed LockedBuffer will always return false.\n*/\nfunc (b *LockedBuffer) EqualTo(buf []byte) bool {\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\treturn core.Equal(b.Bytes(), buf)\n}\n\n/*\n\tFunctions for representing the memory region as various data types.\n*/\n\n/*\nBytes returns a byte slice referencing the protected region of memory.\n*/\nfunc (b *LockedBuffer) Bytes() []byte {\n\treturn b.Buffer.Data()\n}\n\n/*\nReader returns a Reader object referencing the protected region of memory.\n*/\nfunc (b *LockedBuffer) Reader() *bytes.Reader {\n\treturn bytes.NewReader(b.Bytes())\n}\n\n/*\nString returns a string representation of the protected region of memory.\n*/\nfunc (b *LockedBuffer) String() string {\n\tslice := b.Bytes()\n\treturn *(*string)(unsafe.Pointer(&slice))\n}\n\n/*\nUint16 returns a slice pointing to the protected region of memory with the data represented as a sequence of unsigned 16 bit integers. Its length will be half that of the byte slice, excluding any remaining part that doesn't form a complete uint16 value.\n\nIf called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Uint16() []uint16 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Compute size of new slice representation.\n\tsize := b.Size() / 2\n\tif size < 1 {\n\t\treturn nil\n\t}\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), size, size}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]uint16)(unsafe.Pointer(&sl))\n}\n\n/*\nUint32 returns a slice pointing to the protected region of memory with the data represented as a sequence of unsigned 32 bit integers. Its length will be one quarter that of the byte slice, excluding any remaining part that doesn't form a complete uint32 value.\n\nIf called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Uint32() []uint32 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Compute size of new slice representation.\n\tsize := b.Size() / 4\n\tif size < 1 {\n\t\treturn nil\n\t}\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), size, size}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]uint32)(unsafe.Pointer(&sl))\n}\n\n/*\nUint64 returns a slice pointing to the protected region of memory with the data represented as a sequence of unsigned 64 bit integers. Its length will be one eighth that of the byte slice, excluding any remaining part that doesn't form a complete uint64 value.\n\nIf called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Uint64() []uint64 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Compute size of new slice representation.\n\tsize := b.Size() / 8\n\tif size < 1 {\n\t\treturn nil\n\t}\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), size, size}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]uint64)(unsafe.Pointer(&sl))\n}\n\n/*\nInt8 returns a slice pointing to the protected region of memory with the data represented as a sequence of signed 8 bit integers. If called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Int8() []int8 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), b.Size(), b.Size()}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]int8)(unsafe.Pointer(&sl))\n}\n\n/*\nInt16 returns a slice pointing to the protected region of memory with the data represented as a sequence of signed 16 bit integers. Its length will be half that of the byte slice, excluding any remaining part that doesn't form a complete int16 value.\n\nIf called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Int16() []int16 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Compute size of new slice representation.\n\tsize := b.Size() / 2\n\tif size < 1 {\n\t\treturn nil\n\t}\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), size, size}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]int16)(unsafe.Pointer(&sl))\n}\n\n/*\nInt32 returns a slice pointing to the protected region of memory with the data represented as a sequence of signed 32 bit integers. Its length will be one quarter that of the byte slice, excluding any remaining part that doesn't form a complete int32 value.\n\nIf called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Int32() []int32 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Compute size of new slice representation.\n\tsize := b.Size() / 4\n\tif size < 1 {\n\t\treturn nil\n\t}\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), size, size}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]int32)(unsafe.Pointer(&sl))\n}\n\n/*\nInt64 returns a slice pointing to the protected region of memory with the data represented as a sequence of signed 64 bit integers. Its length will be one eighth that of the byte slice, excluding any remaining part that doesn't form a complete int64 value.\n\nIf called on a destroyed LockedBuffer, a nil slice will be returned.\n*/\nfunc (b *LockedBuffer) Int64() []int64 {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Compute size of new slice representation.\n\tsize := b.Size() / 8\n\tif size < 1 {\n\t\treturn nil\n\t}\n\n\t// Construct the new slice representation.\n\tvar sl = struct {\n\t\taddr uintptr\n\t\tlen  int\n\t\tcap  int\n\t}{uintptr(unsafe.Pointer(&b.Bytes()[0])), size, size}\n\n\t// Cast the representation to the correct type and return it.\n\treturn *(*[]int64)(unsafe.Pointer(&sl))\n}\n\n/*\nByteArray8 returns a pointer to some 8 byte array. Care must be taken not to dereference the pointer and instead pass it around as-is.\n\nThe length of the buffer must be at least 8 bytes in size and the LockedBuffer should not be destroyed. In either of these cases a nil value is returned.\n*/\nfunc (b *LockedBuffer) ByteArray8() *[8]byte {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Check if the length is large enough.\n\tif len(b.Bytes()) < 8 {\n\t\treturn nil\n\t}\n\n\t// Cast the representation to the correct type.\n\treturn (*[8]byte)(unsafe.Pointer(&b.Bytes()[0]))\n}\n\n/*\nByteArray16 returns a pointer to some 16 byte array. Care must be taken not to dereference the pointer and instead pass it around as-is.\n\nThe length of the buffer must be at least 16 bytes in size and the LockedBuffer should not be destroyed. In either of these cases a nil value is returned.\n*/\nfunc (b *LockedBuffer) ByteArray16() *[16]byte {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Check if the length is large enough.\n\tif len(b.Bytes()) < 16 {\n\t\treturn nil\n\t}\n\n\t// Cast the representation to the correct type.\n\treturn (*[16]byte)(unsafe.Pointer(&b.Bytes()[0]))\n}\n\n/*\nByteArray32 returns a pointer to some 32 byte array. Care must be taken not to dereference the pointer and instead pass it around as-is.\n\nThe length of the buffer must be at least 32 bytes in size and the LockedBuffer should not be destroyed. In either of these cases a nil value is returned.\n*/\nfunc (b *LockedBuffer) ByteArray32() *[32]byte {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Check if the length is large enough.\n\tif len(b.Bytes()) < 32 {\n\t\treturn nil\n\t}\n\n\t// Cast the representation to the correct type.\n\treturn (*[32]byte)(unsafe.Pointer(&b.Bytes()[0]))\n}\n\n/*\nByteArray64 returns a pointer to some 64 byte array. Care must be taken not to dereference the pointer and instead pass it around as-is.\n\nThe length of the buffer must be at least 64 bytes in size and the LockedBuffer should not be destroyed. In either of these cases a nil value is returned.\n*/\nfunc (b *LockedBuffer) ByteArray64() *[64]byte {\n\n\t// Check if still alive.\n\tif !b.Buffer.Alive() {\n\t\treturn nil\n\t}\n\n\tb.RLock()\n\tdefer b.RUnlock()\n\n\t// Check if the length is large enough.\n\tif len(b.Bytes()) < 64 {\n\t\treturn nil\n\t}\n\n\t// Cast the representation to the correct type.\n\treturn (*[64]byte)(unsafe.Pointer(&b.Bytes()[0]))\n}\n"
        },
        {
          "name": "buffer_test.go",
          "type": "blob",
          "size": 26.140625,
          "content": "package memguard\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"io\"\n\tmrand \"math/rand\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n\t\"unsafe\"\n)\n\nfunc TestPtrSafetyWithGC(t *testing.T) {\n\tdataToLock := []byte(`abcdefgh`)\n\tb := NewBufferFromBytes(dataToLock)\n\tdataPtr := b.Bytes()\n\n\tfinalizerCalledChan := make(chan bool)\n\truntime.SetFinalizer(b, func(_ *LockedBuffer) {\n\t\tfinalizerCalledChan <- true\n\t})\n\t// b is now unreachable\n\n\truntime.GC()\n\tfinalizerCalled := <-finalizerCalledChan\n\tif finalizerCalled == false {\n\t\tt.Error(\"this should never occur\")\n\t}\n\n\t// Check that data hasn't been garbage collected\n\tif !bytes.Equal(dataPtr, []byte(`abcdefgh`)) {\n\t\tt.Error(\"data does not have the value we set\")\n\t}\n}\n\nfunc TestNewBuffer(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"buffer should not be nil\")\n\t}\n\tif len(b.Bytes()) != 32 || cap(b.Bytes()) != 32 {\n\t\tt.Error(\"buffer sizes incorrect\")\n\t}\n\tif !bytes.Equal(b.Bytes(), make([]byte, 32)) {\n\t\tt.Error(\"buffer is not zeroed\")\n\t}\n\tif !b.IsMutable() {\n\t\tt.Error(\"buffer should be mutable\")\n\t}\n\tif !b.IsAlive() {\n\t\tt.Error(\"buffer should not be destroyed\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(0)\n\tif b.Bytes() != nil {\n\t\tt.Error(\"data slice should be nil\")\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"size should be zero\", b.Size())\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\nfunc TestNewBufferFromBytes(t *testing.T) {\n\tdata := []byte(\"yellow submarine\")\n\tb := NewBufferFromBytes(data)\n\tif b == nil {\n\t\tt.Error(\"buffer should not be nil\")\n\t}\n\tif len(b.Bytes()) != 16 || cap(b.Bytes()) != 16 {\n\t\tt.Error(\"buffer sizes invalid\")\n\t}\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"data does not match\\n\", b.Bytes(), \"\\n\", data)\n\t}\n\tif !bytes.Equal(data, make([]byte, 16)) {\n\t\tt.Error(\"source buffer not wiped\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tif !b.IsAlive() {\n\t\tt.Error(\"buffer should not be destroyed\")\n\t}\n\tb.Destroy()\n\tb = NewBufferFromBytes([]byte{})\n\tif b.Bytes() != nil {\n\t\tt.Error(\"data slice should be nil\")\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"size should be zero\", b.Size())\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\nfunc TestNewBufferFromReader(t *testing.T) {\n\tb, err := NewBufferFromReader(rand.Reader, 4096)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 4096 {\n\t\tt.Error(\"buffer of incorrect size\")\n\t}\n\tif bytes.Equal(b.Bytes(), make([]byte, 4096)) {\n\t\tt.Error(\"didn't read from reader\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected buffer to be immutable\")\n\t}\n\tb.Destroy()\n\n\tr := bytes.NewReader([]byte(\"yellow submarine\"))\n\tb, err = NewBufferFromReader(r, 16)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 16 {\n\t\tt.Error(\"buffer of incorrect size\")\n\t}\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected buffer to be immutable\")\n\t}\n\tb.Destroy()\n\n\tr = bytes.NewReader([]byte(\"yellow submarine\"))\n\tb, err = NewBufferFromReader(r, 17)\n\tif err == nil {\n\t\tt.Error(\"expected error got nil;\", err)\n\t}\n\tif b.Size() != 16 {\n\t\tt.Error(\"incorrect size\")\n\t}\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected buffer to be immutable\")\n\t}\n\tb.Destroy()\n\n\tr = bytes.NewReader([]byte(\"\"))\n\tb, err = NewBufferFromReader(r, 32)\n\tif err == nil {\n\t\tt.Error(\"expected error got nil\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"expected destroyed buffer\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected immutable buffer\")\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"expected nul sized buffer\")\n\t}\n\tr = bytes.NewReader([]byte(\"yellow submarine\"))\n\tb, err = NewBufferFromReader(r, 0)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Bytes() != nil {\n\t\tt.Error(\"data slice should be nil\")\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"size should be zero\", b.Size())\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\ntype s struct {\n\tcount int\n}\n\nfunc (reader *s) Read(p []byte) (n int, err error) {\n\tif mrand.Intn(2) == 0 {\n\t\treturn 0, nil\n\t}\n\treader.count++\n\tif reader.count == 5000 {\n\t\tcopy(p, []byte{1})\n\t\treturn 1, nil\n\t}\n\tcopy(p, []byte{0})\n\treturn 1, nil\n}\n\nfunc TestNewBufferFromReaderUntil(t *testing.T) {\n\tdata := make([]byte, 5000)\n\tdata[4999] = 1\n\tr := bytes.NewReader(data)\n\tb, err := NewBufferFromReaderUntil(r, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 4999 {\n\t\tt.Error(\"buffer has incorrect size\")\n\t}\n\tfor i := range b.Bytes() {\n\t\tif b.Bytes()[i] != 0 {\n\t\t\tt.Error(\"incorrect data\")\n\t\t}\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected buffer to be immutable\")\n\t}\n\tb.Destroy()\n\n\tr = bytes.NewReader(data[:32])\n\tb, err = NewBufferFromReaderUntil(r, 1)\n\tif err == nil {\n\t\tt.Error(\"expected error got nil\")\n\t}\n\tif b.Size() != 32 {\n\t\tt.Error(\"invalid size\")\n\t}\n\tfor i := range b.Bytes() {\n\t\tif b.Bytes()[i] != 0 {\n\t\t\tt.Error(\"incorrect data\")\n\t\t}\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected buffer to be immutable\")\n\t}\n\tb.Destroy()\n\n\tr = bytes.NewReader([]byte{'x'})\n\tb, err = NewBufferFromReaderUntil(r, 'x')\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"expected no data\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"expected dead buffer\")\n\t}\n\n\tr = bytes.NewReader([]byte(\"\"))\n\tb, err = NewBufferFromReaderUntil(r, 1)\n\tif err == nil {\n\t\tt.Error(\"expected error got nil\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"expected destroyed buffer\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected immutable buffer\")\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"expected nul sized buffer\")\n\t}\n\n\trr := new(s)\n\tb, err = NewBufferFromReaderUntil(rr, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 4999 {\n\t\tt.Error(\"invalid size\")\n\t}\n\tfor i := range b.Bytes() {\n\t\tif b.Bytes()[i] != 0 {\n\t\t\tt.Error(\"invalid data\")\n\t\t}\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"expected buffer to be immutable\")\n\t}\n\tb.Destroy()\n}\n\ntype ss struct {\n\tcount int\n}\n\nfunc (reader *ss) Read(p []byte) (n int, err error) {\n\tif mrand.Intn(2) == 0 {\n\t\treturn 0, nil\n\t}\n\treader.count++\n\tif reader.count == 5000 {\n\t\treturn 0, io.EOF\n\t}\n\tcopy(p, []byte{0})\n\treturn 1, nil\n}\n\ntype se struct {\n\tcount int\n}\n\nfunc (reader *se) Read(p []byte) (n int, err error) {\n\tcopy(p, []byte{0})\n\treader.count++\n\tif reader.count == 5000 {\n\t\treturn 1, errors.New(\"shut up bro\")\n\t}\n\treturn 1, nil\n}\n\nfunc TestNewBufferFromEntireReader(t *testing.T) {\n\tr := bytes.NewReader([]byte(\"yellow submarine\"))\n\tb, err := NewBufferFromEntireReader(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 16 {\n\t\tt.Error(\"incorrect size\", b.Size())\n\t}\n\tif !b.EqualTo([]byte(\"yellow submarine\")) {\n\t\tt.Error(\"incorrect data\", b.String())\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb.Destroy()\n\n\tdata := make([]byte, 16000)\n\tScrambleBytes(data)\n\tr = bytes.NewReader(data)\n\tb, err = NewBufferFromEntireReader(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != len(data) {\n\t\tt.Error(\"incorrect size\", b.Size())\n\t}\n\tif !b.EqualTo(data) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb.Destroy()\n\n\tr = bytes.NewReader([]byte{})\n\tb, err = NewBufferFromEntireReader(r)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"buffer should be nil size\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should appear destroyed\")\n\t}\n\n\trr := new(ss)\n\tb, err = NewBufferFromEntireReader(rr)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif b.Size() != 4999 {\n\t\tt.Error(\"incorrect size\", b.Size())\n\t}\n\tif !b.EqualTo(make([]byte, 4999)) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb.Destroy()\n\n\tre := new(se)\n\tb, err = NewBufferFromEntireReader(re)\n\tif err == nil {\n\t\tt.Error(\"expected error got nil\")\n\t}\n\tif b.Size() != 5000 {\n\t\tt.Error(b.Size())\n\t}\n\tif !b.EqualTo(make([]byte, 5000)) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb.Destroy()\n\n\t// real world test\n\tf, err := os.Open(\"LICENSE\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdata, err = io.ReadAll(f)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\t_, err = f.Seek(0, 0)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tb, err = NewBufferFromEntireReader(f)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !b.EqualTo(data) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb.Destroy()\n\tf.Close()\n}\n\nfunc TestNewBufferRandom(t *testing.T) {\n\tb := NewBufferRandom(32)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tif len(b.Bytes()) != 32 || cap(b.Bytes()) != 32 {\n\t\tt.Error(\"buffer sizes incorrect\")\n\t}\n\tif bytes.Equal(b.Bytes(), make([]byte, 32)) {\n\t\tt.Error(\"buffer is zeroed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tif !b.IsAlive() {\n\t\tt.Error(\"buffer should not be destroyed\")\n\t}\n\tb.Destroy()\n\tb = NewBufferRandom(0)\n\tif b.Bytes() != nil {\n\t\tt.Error(\"data slice should be nil\")\n\t}\n\tif b.Size() != 0 {\n\t\tt.Error(\"size should be zero\", b.Size())\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\nfunc TestFreeze(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tif !b.IsMutable() {\n\t\tt.Error(\"buffer isn't mutable\")\n\t}\n\tb.Freeze()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer did not change to immutable\")\n\t}\n\tif !bytes.Equal(b.Bytes(), make([]byte, 8)) {\n\t\tt.Error(\"buffer changed value\") // also tests readability\n\t}\n\tb.Freeze() // Test idempotency\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tif !bytes.Equal(b.Bytes(), make([]byte, 8)) {\n\t\tt.Error(\"buffer changed value\") // also tests readability\n\t}\n\tb.Destroy()\n\tb.Freeze()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer is mutable\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.Freeze()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\nfunc TestMelt(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tb.Freeze()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer is mutable\")\n\t}\n\tb.Melt()\n\tif !b.IsMutable() {\n\t\tt.Error(\"buffer did not become mutable\")\n\t}\n\tif !bytes.Equal(b.Bytes(), make([]byte, 8)) {\n\t\tt.Error(\"buffer changed value\") // also tests readability\n\t}\n\tb.Bytes()[0] = 0x1 // test writability\n\tif b.Bytes()[0] != 0x1 {\n\t\tt.Error(\"buffer value not changed\")\n\t}\n\tb.Melt() // Test idempotency\n\tif !b.IsMutable() {\n\t\tt.Error(\"buffer should be mutable\")\n\t}\n\tb.Bytes()[0] = 0x2\n\tif b.Bytes()[0] != 0x2 {\n\t\tt.Error(\"buffer value not changed\")\n\t}\n\tb.Destroy()\n\tb.Melt()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer shouldn't be mutable\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.Melt()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\nfunc TestSeal(t *testing.T) {\n\tb := NewBufferRandom(32)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tdata := make([]byte, 32)\n\tcopy(data, b.Bytes())\n\te := b.Seal()\n\tif e == nil {\n\t\tt.Error(\"got nil enclave\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb, err := e.Open()\n\tif err != nil {\n\t\tt.Error(\"unexpected error;\", err)\n\t}\n\tif !bytes.Equal(b.Bytes(), data) {\n\t\tt.Error(\"data does not match\")\n\t}\n\tb.Destroy()\n\te = b.Seal() // call on destroyed buffer\n\tif e != nil {\n\t\tt.Error(\"expected nil enclave\")\n\t}\n}\n\nfunc TestCopy(t *testing.T) {\n\tb := NewBuffer(16)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tb.Copy([]byte(\"yellow submarine\"))\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"copy unsuccessful\")\n\t}\n\tb.Destroy()\n\tb.Copy([]byte(\"yellow submarine\"))\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.Copy([]byte(\"yellow submarine\"))\n}\n\nfunc TestCopyAt(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tb.CopyAt(0, []byte(\"1234\"))\n\tif !bytes.Equal(b.Bytes()[:4], []byte(\"1234\")) {\n\t\tt.Error(\"copy unsuccessful\")\n\t}\n\tif !bytes.Equal(b.Bytes()[4:], []byte{0, 0, 0, 0}) {\n\t\tt.Error(\"copy overflow\")\n\t}\n\tb.CopyAt(4, []byte(\"5678\"))\n\tif !bytes.Equal(b.Bytes(), []byte(\"12345678\")) {\n\t\tt.Error(\"copy unsuccessful\")\n\t}\n\tb.Destroy()\n\tb.CopyAt(4, []byte(\"hmmm\"))\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.CopyAt(4, []byte(\"yellow submarine\"))\n}\n\nfunc TestMove(t *testing.T) {\n\tb := NewBuffer(16)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tb.Move([]byte(\"yellow submarine\"))\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"copy unsuccessful\")\n\t}\n\tdata := []byte(\"yellow submarine\")\n\tb.Move(data)\n\tfor b := range data {\n\t\tif data[b] != 0x0 {\n\t\t\tt.Error(\"buffer was not wiped\", b)\n\t\t}\n\t}\n\tb.Destroy()\n\tb.Move(data)\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.Move([]byte(\"yellow submarine\"))\n}\n\nfunc TestMoveAt(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tdata := []byte(\"12345678\")\n\tb.MoveAt(0, data[:4])\n\tif !bytes.Equal(b.Bytes()[:4], []byte(\"1234\")) {\n\t\tt.Error(\"copy unsuccessful\")\n\t}\n\tif !bytes.Equal(b.Bytes()[4:], []byte{0, 0, 0, 0}) {\n\t\tt.Error(\"copy overflow\")\n\t}\n\tb.MoveAt(4, data[4:])\n\tif !bytes.Equal(b.Bytes(), []byte(\"12345678\")) {\n\t\tt.Error(\"copy unsuccessful\")\n\t}\n\tif !bytes.Equal(data, make([]byte, 8)) {\n\t\tt.Error(\"buffer not wiped\")\n\t}\n\tb.Destroy()\n\tb.MoveAt(4, []byte(\"hmmm\"))\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.MoveAt(4, []byte(\"yellow submarine\"))\n}\n\nfunc TestScramble(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"buffer is nil\")\n\t}\n\tb.Scramble()\n\tif bytes.Equal(b.Bytes(), make([]byte, 32)) {\n\t\tt.Error(\"buffer was not randomised\")\n\t}\n\tone := make([]byte, 32)\n\tcopy(one, b.Bytes())\n\tb.Scramble()\n\tif bytes.Equal(b.Bytes(), make([]byte, 32)) {\n\t\tt.Error(\"buffer was not randomised\")\n\t}\n\tif bytes.Equal(b.Bytes(), one) {\n\t\tt.Error(\"buffer did not change\")\n\t}\n\tb.Destroy()\n\tb.Scramble()\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.Scramble()\n}\n\nfunc TestWipe(t *testing.T) {\n\tb := NewBufferRandom(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tb.Melt()\n\tif bytes.Equal(b.Bytes(), make([]byte, 32)) {\n\t\tt.Error(\"buffer was not randomised\")\n\t}\n\tb.Wipe()\n\tfor i := range b.Bytes() {\n\t\tif b.Bytes()[i] != 0 {\n\t\t\tt.Error(\"buffer was not wiped; index\", i)\n\t\t}\n\t}\n\tb.Destroy()\n\tb.Wipe()\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tb = newNullBuffer()\n\tb.Wipe()\n}\n\nfunc TestSize(t *testing.T) {\n\tb := NewBuffer(1234)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif b.Size() != 1234 {\n\t\tt.Error(\"size does not match expected\")\n\t}\n\tb.Destroy()\n\tif b.Size() != 0 {\n\t\tt.Error(\"destroyed buffer size should be zero\")\n\t}\n\tb = newNullBuffer()\n\tif b.Size() != 0 {\n\t\tt.Error(\"size should be zero\")\n\t}\n}\n\nfunc TestDestroy(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif b.Bytes() == nil {\n\t\tt.Error(\"expected buffer to not be nil\")\n\t}\n\tif len(b.Bytes()) != 32 || cap(b.Bytes()) != 32 {\n\t\tt.Error(\"buffer sizes incorrect\")\n\t}\n\tif !b.IsAlive() {\n\t\tt.Error(\"buffer should be alive\")\n\t}\n\tif !b.IsMutable() {\n\t\tt.Error(\"buffer should be mutable\")\n\t}\n\tb.Destroy()\n\tif b.Bytes() != nil {\n\t\tt.Error(\"expected buffer to be nil\")\n\t}\n\tif len(b.Bytes()) != 0 || cap(b.Bytes()) != 0 {\n\t\tt.Error(\"buffer sizes incorrect\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb.Destroy()\n\tif b.Bytes() != nil {\n\t\tt.Error(\"expected buffer to be nil\")\n\t}\n\tif len(b.Bytes()) != 0 || cap(b.Bytes()) != 0 {\n\t\tt.Error(\"buffer sizes incorrect\")\n\t}\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be destroyed\")\n\t}\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n\tb = newNullBuffer()\n\tb.Destroy()\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be dead\")\n\t}\n}\n\nfunc TestIsAlive(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif !b.IsAlive() {\n\t\tt.Error(\"invalid state\")\n\t}\n\tif b.IsAlive() != b.IsAlive() {\n\t\tt.Error(\"states don't match\")\n\t}\n\tb.Destroy()\n\tif b.IsAlive() {\n\t\tt.Error(\"invalid state\")\n\t}\n\tif b.IsAlive() != b.IsAlive() {\n\t\tt.Error(\"states don't match\")\n\t}\n\tb = newNullBuffer()\n\tif b.IsAlive() {\n\t\tt.Error(\"buffer should be dead\")\n\t}\n}\n\nfunc TestIsMutable(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif !b.IsMutable() {\n\t\tt.Error(\"invalid state\")\n\t}\n\tif b.IsMutable() != b.IsMutable() {\n\t\tt.Error(\"states don't match\")\n\t}\n\tb.Freeze()\n\tif b.IsMutable() {\n\t\tt.Error(\"invalid state\")\n\t}\n\tif b.IsMutable() != b.IsMutable() {\n\t\tt.Error(\"states don't match\")\n\t}\n\tb.Destroy()\n\tif b.IsMutable() {\n\t\tt.Error(\"invalid state\")\n\t}\n\tif b.IsMutable() != b.IsMutable() {\n\t\tt.Error(\"states don't match\")\n\t}\n\tb = newNullBuffer()\n\tif b.IsMutable() {\n\t\tt.Error(\"buffer should be immutable\")\n\t}\n}\n\nfunc TestEqualTo(t *testing.T) {\n\tb := NewBufferFromBytes([]byte(\"yellow submarine\"))\n\tif !b.EqualTo([]byte(\"yellow submarine\")) {\n\t\tt.Error(\"comparison incorrect\")\n\t}\n\tif b.EqualTo([]byte(\"yellow\")) {\n\t\tt.Error(\"comparison incorrect\")\n\t}\n\tb.Destroy()\n\tif b.EqualTo([]byte(\"yellow submarine\")) {\n\t\tt.Error(\"comparison with destroyed should be false\")\n\t}\n\tb = newNullBuffer()\n\tif !b.EqualTo([]byte{}) {\n\t\tt.Error(\"buffer should be size zero\")\n\t}\n}\n\nfunc TestBytes(t *testing.T) {\n\tb := NewBufferFromBytes([]byte(\"yellow submarine\"))\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"not equal contents\")\n\t}\n\tb.Melt()\n\tb.Bytes()[8] = ^b.Bytes()[8]\n\tif !bytes.Equal(b.Buffer.Data(), b.Bytes()) {\n\t\tt.Error(\"methods disagree\")\n\t}\n\tb.Destroy()\n\tif b.Bytes() != nil {\n\t\tt.Error(\"expected nil buffer\")\n\t}\n\tb = newNullBuffer()\n\tif b.Bytes() != nil {\n\t\tt.Error(\"buffer should be nil\")\n\t}\n}\n\nfunc TestReader(t *testing.T) {\n\tb := NewBufferRandom(32)\n\tc, err := NewBufferFromReader(b.Reader(), 32)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !bytes.Equal(b.Bytes(), c.Bytes()) {\n\t\tt.Error(\"data not equal\")\n\t}\n\tb.Destroy()\n\tc.Destroy()\n\tif c.Reader().Size() != 0 {\n\t\tt.Error(\"expected nul reader\")\n\t}\n\tb = newNullBuffer()\n\tif c.Reader().Size() != 0 {\n\t\tt.Error(\"expected nul reader\")\n\t}\n}\n\nfunc TestString(t *testing.T) {\n\tb := NewBufferRandom(32)\n\tb.Melt()\n\ts := b.String()\n\tfor i := range b.Bytes() {\n\t\tb.Bytes()[i] = 'x'\n\t\tif string(b.Bytes()) != s {\n\t\t\tt.Error(\"string does not map same memory\")\n\t\t}\n\t}\n\tb.Destroy()\n\ts = b.String()\n\tif s != \"\" {\n\t\tt.Error(\"string should be empty\")\n\t}\n\tb = newNullBuffer()\n\tif s != \"\" {\n\t\tt.Error(\"string should be empty\")\n\t}\n}\n\nfunc TestUint16(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu16 := b.Uint16()\n\tif len(u16) != 16 || cap(u16) != 16 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&u16[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(3)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu16 = b.Uint16()\n\tif len(u16) != 1 || cap(u16) != 1 {\n\t\tt.Error(\"sizes should be 1\")\n\t}\n\tif uintptr(unsafe.Pointer(&u16[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(1)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu16 = b.Uint16()\n\tif u16 != nil {\n\t\tt.Error(\"expected nil slice\")\n\t}\n\tb.Destroy()\n\tif b.Uint16() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Uint16() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestUint32(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu32 := b.Uint32()\n\tif len(u32) != 8 || cap(u32) != 8 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&u32[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(5)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu32 = b.Uint32()\n\tif len(u32) != 1 || cap(u32) != 1 {\n\t\tt.Error(\"sizes should be 1\")\n\t}\n\tif uintptr(unsafe.Pointer(&u32[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(3)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu32 = b.Uint32()\n\tif u32 != nil {\n\t\tt.Error(\"expected nil slice\")\n\t}\n\tb.Destroy()\n\tif b.Uint32() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Uint32() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestUint64(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu64 := b.Uint64()\n\tif len(u64) != 4 || cap(u64) != 4 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&u64[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(9)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu64 = b.Uint64()\n\tif len(u64) != 1 || cap(u64) != 1 {\n\t\tt.Error(\"sizes should be 1\")\n\t}\n\tif uintptr(unsafe.Pointer(&u64[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(7)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tu64 = b.Uint64()\n\tif u64 != nil {\n\t\tt.Error(\"expected nil slice\")\n\t}\n\tb.Destroy()\n\tif b.Uint64() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Uint64() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestInt8(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti8 := b.Int8()\n\tif len(i8) != 32 || cap(i8) != 32 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&i8[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tif b.Int8() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Int8() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestInt16(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti16 := b.Int16()\n\tif len(i16) != 16 || cap(i16) != 16 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&i16[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(3)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti16 = b.Int16()\n\tif len(i16) != 1 || cap(i16) != 1 {\n\t\tt.Error(\"sizes should be 1\")\n\t}\n\tif uintptr(unsafe.Pointer(&i16[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(1)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti16 = b.Int16()\n\tif i16 != nil {\n\t\tt.Error(\"expected nil slice\")\n\t}\n\tb.Destroy()\n\tif b.Int16() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Int16() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestInt32(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti32 := b.Int32()\n\tif len(i32) != 8 || cap(i32) != 8 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&i32[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(5)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti32 = b.Int32()\n\tif len(i32) != 1 || cap(i32) != 1 {\n\t\tt.Error(\"sizes should be 1\")\n\t}\n\tif uintptr(unsafe.Pointer(&i32[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(3)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti32 = b.Int32()\n\tif i32 != nil {\n\t\tt.Error(\"expected nil slice\")\n\t}\n\tb.Destroy()\n\tif b.Int32() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Int32() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestInt64(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti64 := b.Int64()\n\tif len(i64) != 4 || cap(i64) != 4 {\n\t\tt.Error(\"sizes incorrect\")\n\t}\n\tif uintptr(unsafe.Pointer(&i64[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(9)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti64 = b.Int64()\n\tif len(i64) != 1 || cap(i64) != 1 {\n\t\tt.Error(\"sizes should be 1\")\n\t}\n\tif uintptr(unsafe.Pointer(&i64[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(7)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\ti64 = b.Int64()\n\tif i64 != nil {\n\t\tt.Error(\"expected nil slice\")\n\t}\n\tb.Destroy()\n\tif b.Int64() != nil {\n\t\tt.Error(\"expected nil slice as buffer destroyed\")\n\t}\n\tb = newNullBuffer()\n\tif b.Int32() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestByteArray8(t *testing.T) {\n\tb := NewBuffer(8)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif uintptr(unsafe.Pointer(&b.ByteArray8()[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(7)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif b.ByteArray8() != nil {\n\t\tt.Error(\"expected nil byte array\")\n\t}\n\tb.Destroy()\n\tif b.ByteArray8() != nil {\n\t\tt.Error(\"expected nil byte array from destroyed buffer\")\n\t}\n\tb = newNullBuffer()\n\tif b.ByteArray8() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestByteArray16(t *testing.T) {\n\tb := NewBuffer(16)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif uintptr(unsafe.Pointer(&b.ByteArray16()[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(15)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif b.ByteArray16() != nil {\n\t\tt.Error(\"expected nil byte array\")\n\t}\n\tb.Destroy()\n\tif b.ByteArray16() != nil {\n\t\tt.Error(\"expected nil byte array from destroyed buffer\")\n\t}\n\tb = newNullBuffer()\n\tif b.ByteArray16() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestByteArray32(t *testing.T) {\n\tb := NewBuffer(32)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif uintptr(unsafe.Pointer(&b.ByteArray32()[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(31)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif b.ByteArray32() != nil {\n\t\tt.Error(\"expected nil byte array\")\n\t}\n\tb.Destroy()\n\tif b.ByteArray32() != nil {\n\t\tt.Error(\"expected nil byte array from destroyed buffer\")\n\t}\n\tb = newNullBuffer()\n\tif b.ByteArray32() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestByteArray64(t *testing.T) {\n\tb := NewBuffer(64)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif uintptr(unsafe.Pointer(&b.ByteArray64()[0])) != uintptr(unsafe.Pointer(&b.Bytes()[0])) {\n\t\tt.Error(\"pointer locations differ\")\n\t}\n\tb.Destroy()\n\tb = NewBuffer(63)\n\tif b == nil {\n\t\tt.Error(\"got nil buffer\")\n\t}\n\tif b.ByteArray64() != nil {\n\t\tt.Error(\"expected nil byte array\")\n\t}\n\tb.Destroy()\n\tif b.ByteArray64() != nil {\n\t\tt.Error(\"expected nil byte array from destroyed buffer\")\n\t}\n\tb = newNullBuffer()\n\tif b.ByteArray64() != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n"
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs.go",
          "type": "blob",
          "size": 2.9892578125,
          "content": "/*\nPackage memguard implements a secure software enclave for the storage of sensitive information in memory.\n\n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"os\"\n\n\t\t\"github.com/awnumar/memguard\"\n\t)\n\n\tfunc main() {\n\t\t// Safely terminate in case of an interrupt signal\n\t\tmemguard.CatchInterrupt()\n\n\t\t// Purge the session when we return\n\t\tdefer memguard.Purge()\n\n\t\t// Generate a key sealed inside an encrypted container\n\t\tkey := memguard.NewEnclaveRandom(32)\n\n\t\t// Passing the key off to another function\n\t\tkey = invert(key)\n\n\t\t// Decrypt the result returned from invert\n\t\tkeyBuf, err := key.Open()\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t\tdefer keyBuf.Destroy()\n\n\t\t// Um output it\n\t\tfmt.Println(keyBuf.Bytes())\n\t}\n\n\tfunc invert(key *memguard.Enclave) *memguard.Enclave {\n\t\t// Decrypt the key into a local copy\n\t\tb, err := key.Open()\n\t\tif err != nil {\n\t\t\tmemguard.SafePanic(err)\n\t\t}\n\t\tdefer b.Destroy() // Destroy the copy when we return\n\n\t\t// Open returns the data in an immutable buffer, so make it mutable\n\t\tb.Melt()\n\n\t\t// Set every element to its complement\n\t\tfor i := range b.Bytes() {\n\t\t\tb.Bytes()[i] = ^b.Bytes()[i]\n\t\t}\n\n\t\t// Return the new data in encrypted form\n\t\treturn b.Seal() // <- sealing also destroys b\n\t}\n\nThere are two main container objects exposed in this API. Enclave objects encrypt data and store the ciphertext whereas LockedBuffers are more like guarded memory allocations. There is a limit on the maximum number of LockedBuffer objects that can exist at any one time, imposed by the system's mlock limits. There is no limit on Enclaves.\n\nThe general workflow is to store sensitive information in Enclaves when it is not immediately needed and decrypt it when and where it is. After use, the LockedBuffer should be destroyed.\n\nIf you need access to the data inside a LockedBuffer in a type not covered by any methods provided by this API, you can type-cast the allocation's memory to whatever type you want.\n\n\tkey := memguard.NewBuffer(32)\n\tkeyArrayPtr := (*[32]byte)(unsafe.Pointer(&key.Bytes()[0])) // do not dereference\n\nThis is of course an unsafe operation and so care must be taken to ensure that the cast is valid and does not result in memory unsafety. Further examples of code and interesting use-cases can be found in the examples subpackage.\n\nSeveral functions exist to make the mass purging of data very easy. It is recommended to make use of them when appropriate.\n\n\t// Start an interrupt handler that will clean up memory before exiting\n\tmemguard.CatchInterrupt()\n\n\t// Purge the session when returning from the main function of your program\n\tdefer memguard.Purge()\n\n\t// Use the safe variants of exit functions provided in the stdlib\n\tmemguard.SafeExit(1)\n\tmemguard.SafePanic(err)\n\n\t// Destroy LockedBuffers as soon as possible after using them\n\tb, err := enclave.Open()\n\tif err != nil {\n\t\tmemguard.SafePanic(err)\n\t}\n\tdefer b.Destroy()\n\nCore dumps are disabled by default. If you absolutely require them, you can enable them by using unix.Setrlimit to set RLIMIT_CORE to an appropriate value.\n*/\npackage memguard\n"
        },
        {
          "name": "enclave.go",
          "type": "blob",
          "size": 1.4951171875,
          "content": "package memguard\n\nimport (\n\t\"github.com/awnumar/memguard/core\"\n)\n\n/*\nEnclave is a sealed and encrypted container for sensitive data.\n*/\ntype Enclave struct {\n\t*core.Enclave\n}\n\n/*\nNewEnclave seals up some data into an encrypted enclave object. The buffer is wiped after the data is copied. If the length of the buffer is zero, the function will return nil.\n\nA LockedBuffer may alternatively be converted into an Enclave object using its Seal method. This will also have the effect of destroying the LockedBuffer.\n*/\nfunc NewEnclave(src []byte) *Enclave {\n\te, err := core.NewEnclave(src)\n\tif err != nil {\n\t\tif err == core.ErrNullEnclave {\n\t\t\treturn nil\n\t\t}\n\t\tcore.Panic(err)\n\t}\n\treturn &Enclave{e}\n}\n\n/*\nNewEnclaveRandom generates and seals arbitrary amounts of cryptographically-secure random bytes into an encrypted enclave object. If size is not strictly positive the function will return nil.\n*/\nfunc NewEnclaveRandom(size int) *Enclave {\n\t// todo: stream data into enclave\n\tb := NewBufferRandom(size)\n\treturn b.Seal()\n}\n\n/*\nOpen decrypts an Enclave object and places its contents into an immutable LockedBuffer. An error will be returned if decryption failed.\n*/\nfunc (e *Enclave) Open() (*LockedBuffer, error) {\n\tb, err := core.Open(e.Enclave)\n\tif err != nil {\n\t\tif err != core.ErrDecryptionFailed {\n\t\t\tcore.Panic(err)\n\t\t}\n\t\treturn nil, err\n\t}\n\tb.Freeze()\n\treturn newBuffer(b), nil\n}\n\n/*\nSize returns the number of bytes of data stored within an Enclave.\n*/\nfunc (e *Enclave) Size() int {\n\treturn core.EnclaveSize(e.Enclave)\n}\n"
        },
        {
          "name": "enclave_test.go",
          "type": "blob",
          "size": 1.7451171875,
          "content": "package memguard\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/awnumar/memguard/core\"\n)\n\nfunc TestNewEnclave(t *testing.T) {\n\te := NewEnclave([]byte(\"yellow submarine\"))\n\tif e == nil {\n\t\tt.Error(\"got nil enclave\")\n\t}\n\tdata, err := e.Open()\n\tif err != nil {\n\t\tt.Error(\"unexpected error:\", err)\n\t}\n\tif !bytes.Equal(data.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"data doesn't match input\")\n\t}\n\tdata.Destroy()\n\te = NewEnclave([]byte{})\n\tif e != nil {\n\t\tt.Error(\"enclave should be nil\")\n\t}\n}\n\nfunc TestNewEnclaveRandom(t *testing.T) {\n\te := NewEnclaveRandom(32)\n\tif e == nil {\n\t\tt.Error(\"got nil enclave\")\n\t}\n\tdata, err := e.Open()\n\tif err != nil {\n\t\tt.Error(\"unexpected error:\", err)\n\t}\n\tif len(data.Bytes()) != 32 || cap(data.Bytes()) != 32 {\n\t\tt.Error(\"buffer sizes incorrect\")\n\t}\n\tif bytes.Equal(data.Bytes(), make([]byte, 32)) {\n\t\tt.Error(\"buffer not randomised\")\n\t}\n\tdata.Destroy()\n\te = NewEnclaveRandom(0)\n\tif e != nil {\n\t\tt.Error(\"should be nil\")\n\t}\n}\n\nfunc TestOpen(t *testing.T) {\n\te := NewEnclave([]byte(\"yellow submarine\"))\n\tif e == nil {\n\t\tt.Error(\"got nil enclave\")\n\t}\n\tb, err := e.Open()\n\tif err != nil {\n\t\tt.Error(\"unexpected error;\", err)\n\t}\n\tif b == nil {\n\t\tt.Error(\"buffer should not be nil\")\n\t}\n\tif e.Size() != b.Size() {\n\t\tt.Error(\"sizes don't match\")\n\t}\n\tif !bytes.Equal(b.Bytes(), []byte(\"yellow submarine\")) {\n\t\tt.Error(\"data does not match\")\n\t}\n\tPurge() // reset the session\n\tb, err = e.Open()\n\tif err != core.ErrDecryptionFailed {\n\t\tt.Error(\"expected decryption error; got\", err)\n\t}\n\tif b != nil {\n\t\tt.Error(\"buffer should be nil\")\n\t}\n\te = NewEnclaveRandom(0)\n\tif !panics(func() {\n\t\te.Open()\n\t}) {\n\t\tt.Error(\"func should panic on nil enclave\")\n\t}\n}\n\nfunc panics(fn func()) (panicked bool) {\n\tdefer func() {\n\t\tpanicked = (recover() != nil)\n\t}()\n\tfn()\n\treturn\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.26953125,
          "content": "module github.com/awnumar/memguard\n\ngo 1.18\n\nrequire (\n\tgithub.com/awnumar/memcall v0.2.0\n\tgolang.org/x/crypto v0.16.0\n\tlukechampine.com/frand v1.4.2\n)\n\nrequire (\n\tgithub.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da // indirect\n\tgolang.org/x/sys v0.15.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.0576171875,
          "content": "github.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da h1:KjTM2ks9d14ZYCvmHS9iAKVt9AyzRSqNU1qabPih5BY=\ngithub.com/aead/chacha20 v0.0.0-20180709150244-8b13a72661da/go.mod h1:eHEWzANqSiWQsof+nXEI9bUVUyV6F53Fp89EuCh2EAA=\ngithub.com/awnumar/memcall v0.2.0 h1:sRaogqExTOOkkNwO9pzJsL8jrOV29UuUW7teRMfbqtI=\ngithub.com/awnumar/memcall v0.2.0/go.mod h1:S911igBPR9CThzd/hYQQmTc9SWNu3ZHIlCGaWsWsoJo=\ngolang.org/x/crypto v0.16.0 h1:mMMrFzRSCF0GvB7Ne27XVtVAaXLrPmgPC7/v0tkwHaY=\ngolang.org/x/crypto v0.16.0/go.mod h1:gCAAfMLgwOJRpTjQ2zCCt2OcSfYMTeZVSRtQlPC7Nq4=\ngolang.org/x/sys v0.0.0-20190626221950-04f50cda93cb/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.15.0 h1:h48lPFYpsTvQJZF4EKyI4aLHaev3CxivZmv7yZig9pc=\ngolang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\nlukechampine.com/frand v1.4.2 h1:RzFIpOvkMXuPMBb9maa4ND4wjBn71E1Jpf8BzJHMaVw=\nlukechampine.com/frand v1.4.2/go.mod h1:4S/TM2ZgrKejMcKMbeLjISpJMO+/eZ1zu3vYX9dtj3s=\n"
        },
        {
          "name": "logo.svg",
          "type": "blob",
          "size": 0.53515625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"><svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" viewBox=\"0 0 68 100\" enable-background=\"new 0 0 68 100\" xml:space=\"preserve\"><path d=\"M60.5,41.338V26.5C60.5,11.888,48.612,0,34,0S7.5,11.888,7.5,26.5v14.838L0,42v55l34,3l34-3V42L60.5,41.338z M15.5,40.633\r\n\tV26.5C15.5,16.299,23.799,8,34,8s18.5,8.299,18.5,18.5v14.133L34,39L15.5,40.633z\"></path></svg>"
        },
        {
          "name": "memguard.go",
          "type": "blob",
          "size": 0.8408203125,
          "content": "package memguard\n\nimport (\n\t\"github.com/awnumar/memguard/core\"\n)\n\n/* Enhancement: check for low memory locking limit and print warning?*/\n\n/*\nScrambleBytes overwrites an arbitrary buffer with cryptographically-secure random bytes.\n*/\nfunc ScrambleBytes(buf []byte) {\n\tif err := core.Scramble(buf); err != nil {\n\t\tcore.Panic(err)\n\t}\n}\n\n/*\nWipeBytes overwrites an arbitrary buffer with zeroes.\n*/\nfunc WipeBytes(buf []byte) {\n\tcore.Wipe(buf)\n}\n\n/*\nPurge resets the session key to a fresh value and destroys all existing LockedBuffers. Existing Enclave objects will no longer be decryptable.\n*/\nfunc Purge() {\n\tcore.Purge()\n}\n\n/*\nSafePanic wipes all it can before calling panic(v).\n*/\nfunc SafePanic(v interface{}) {\n\tcore.Panic(v)\n}\n\n/*\nSafeExit destroys everything sensitive before exiting with a specified status code.\n*/\nfunc SafeExit(c int) {\n\tcore.Exit(c)\n}\n"
        },
        {
          "name": "memguard_test.go",
          "type": "blob",
          "size": 0.7412109375,
          "content": "package memguard\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/awnumar/memguard/core\"\n)\n\nfunc TestScrambleBytes(t *testing.T) {\n\tbuf := make([]byte, 32)\n\tScrambleBytes(buf)\n\tif bytes.Equal(buf, make([]byte, 32)) {\n\t\tt.Error(\"buffer not scrambled\")\n\t}\n}\n\nfunc TestWipeBytes(t *testing.T) {\n\tbuf := make([]byte, 32)\n\tScrambleBytes(buf)\n\tWipeBytes(buf)\n\tif !bytes.Equal(buf, make([]byte, 32)) {\n\t\tt.Error(\"buffer not wiped\")\n\t}\n}\n\nfunc TestPurge(t *testing.T) {\n\tkey := NewEnclaveRandom(32)\n\tbuf, err := key.Open()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tPurge()\n\tif buf.IsAlive() {\n\t\tt.Error(\"buffer not destroyed\")\n\t}\n\tbuf, err = key.Open()\n\tif err != core.ErrDecryptionFailed {\n\t\tt.Error(buf.Bytes(), err)\n\t}\n\tif buf != nil {\n\t\tt.Error(\"buffer not nil:\", buf)\n\t}\n}\n"
        },
        {
          "name": "signals.go",
          "type": "blob",
          "size": 1.5576171875,
          "content": "package memguard\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\n\t\"github.com/awnumar/memguard/core\"\n)\n\nvar (\n\t// Ensure we only start a single signal handling instance\n\tcreate sync.Once\n\n\t// Channel for updating the signal handler\n\tsigfunc = make(chan func(os.Signal), 1)\n\n\t// Channel that caught signals are sent to by the runtime\n\tlistener = make(chan os.Signal, 4)\n)\n\n/*\nCatchSignal assigns a given function to be run in the event of a signal being received by the process. If no signals are provided all signals will be caught.\n\n 1. Signal is caught by the process\n 2. Interrupt handler is executed\n 3. Secure session state is wiped\n 4. Process terminates with exit code 1\n\nThis function can be called multiple times with the effect that only the last call will have any effect.\n*/\nfunc CatchSignal(f func(os.Signal), signals ...os.Signal) {\n\tcreate.Do(func() {\n\t\t// Start a goroutine to listen on the channels.\n\t\tgo func() {\n\t\t\tvar handler func(os.Signal)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase signal := <-listener:\n\t\t\t\t\thandler(signal)\n\t\t\t\t\tcore.Exit(1)\n\t\t\t\tcase handler = <-sigfunc:\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t})\n\n\t// Update the handler function.\n\tsigfunc <- f\n\n\t// Notify the channel if we receive a signal.\n\tsignal.Reset()\n\tsignal.Notify(listener, signals...)\n}\n\n/*\nCatchInterrupt is a wrapper around CatchSignal that makes it easy to safely handle receiving interrupt signals. If an interrupt is received, the process will wipe sensitive data in memory before terminating.\n\nA subsequent call to CatchSignal will override this call.\n*/\nfunc CatchInterrupt() {\n\tCatchSignal(func(_ os.Signal) {}, os.Interrupt)\n}\n"
        },
        {
          "name": "signals_test.go",
          "type": "blob",
          "size": 2.0576171875,
          "content": "//go:build !windows\n// +build !windows\n\npackage memguard\n\nimport (\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"testing\"\n)\n\nfunc TestCatchSignal(t *testing.T) {\n\t// If we're within the testing subprocess, run test.\n\tif os.Getenv(\"WITHIN_SUBPROCESS\") == \"1\" {\n\t\t// Start a listener object\n\t\tlistener, err := net.Listen(\"tcp\", \"127.0.0.1:\")\n\t\tif err != nil {\n\t\t\tSafePanic(err)\n\t\t}\n\t\tdefer listener.Close()\n\n\t\t// Spawn a handler to catch interrupts\n\t\tCatchSignal(func(s os.Signal) {\n\t\t\tlistener.Close()\n\t\t})\n\n\t\t// Grab a handle on the running process\n\t\tprocess, err := os.FindProcess(os.Getpid())\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\t// Send it an interrupt signal\n\t\tif err := process.Signal(os.Interrupt); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\n\t// Construct the subprocess with its initial state\n\tcmd := exec.Command(os.Args[0], \"-test.run=TestCatchSignal\")\n\tcmd.Env = append(os.Environ(), \"WITHIN_SUBPROCESS=1\")\n\n\t// Execute the subprocess and inspect its exit code\n\terr := cmd.Run().(*exec.ExitError)\n\tif err.ExitCode() != 1 {\n\t\t// if exit code is -1 it was likely killed by the signal\n\t\tt.Error(\"Wanted exit code 1, got\", err.ExitCode(), \"err:\", err)\n\t}\n\n\t// Todo: catch this violation (segfault)\n\t//\n\t// b := NewBuffer(32)\n\t// bA := (*[64]byte)(unsafe.Pointer(&b.Bytes()[0]))\n\t// bA[42] = 0x69 // write to guard page region\n}\n\nfunc TestCatchInterrupt(t *testing.T) {\n\tif os.Getenv(\"WITHIN_SUBPROCESS\") == \"1\" {\n\t\t// Start the interrupt handler\n\t\tCatchInterrupt()\n\n\t\t// Grab a handle on the running process\n\t\tprocess, err := os.FindProcess(os.Getpid())\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\t// Send it an interrupt signal\n\t\tif err := process.Signal(os.Interrupt); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\n\t// Construct the subprocess with its initial state\n\tcmd := exec.Command(os.Args[0], \"-test.run=TestCatchInterrupt\")\n\tcmd.Env = append(os.Environ(), \"WITHIN_SUBPROCESS=1\")\n\n\t// Execute the subprocess and inspect its exit code\n\terr := cmd.Run().(*exec.ExitError)\n\tif err.ExitCode() != 1 {\n\t\t// if exit code is -1 it was likely killed by the signal\n\t\tt.Error(\"Wanted exit code 1, got\", err.ExitCode(), \"err:\", err)\n\t}\n}\n"
        },
        {
          "name": "stream.go",
          "type": "blob",
          "size": 3.7822265625,
          "content": "package memguard\n\nimport (\n\t\"container/list\"\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\n\t\"github.com/awnumar/memguard/core\"\n)\n\nvar (\n\t// StreamChunkSize is the maximum amount of data that is locked into memory at a time.\n\t// If you get error allocating memory, increase your system's mlock limits.\n\t// Use 'ulimit -l' to see mlock limit on unix systems.\n\tStreamChunkSize = c\n\tc               = os.Getpagesize() * 4\n)\n\ntype queue struct {\n\t*list.List\n}\n\n// add data to back of queue\nfunc (q *queue) join(e *Enclave) {\n\tq.PushBack(e)\n}\n\n// add data to front of queue\nfunc (q *queue) push(e *Enclave) {\n\tq.PushFront(e)\n}\n\n// pop data off front of queue\n// returns nil if queue is empty\nfunc (q *queue) pop() *Enclave {\n\te := q.Front() // get element at front of queue\n\tif e == nil {\n\t\treturn nil // no data\n\t}\n\tq.Remove(e)               // success => remove value\n\treturn e.Value.(*Enclave) // unwrap and return (potential panic)\n}\n\n/*\nStream is an in-memory encrypted container implementing the reader and writer interfaces.\n\nIt is most useful when you need to store lots of data in memory and are able to work on it in chunks.\n*/\ntype Stream struct {\n\tsync.Mutex\n\t*queue\n}\n\n// NewStream initialises a new empty Stream object.\nfunc NewStream() *Stream {\n\treturn &Stream{queue: &queue{List: list.New()}}\n}\n\n/*\nWrite encrypts and writes some given data to a Stream object.\n\nThe data is broken down into chunks and added to the stream in order. The last thing to be written to the stream is the last thing that will be read back.\n*/\nfunc (s *Stream) Write(data []byte) (int, error) {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tfor i := 0; i < len(data); i += c {\n\t\tif i+c > len(data) {\n\t\t\ts.join(NewEnclave(data[len(data)-(len(data)%c):]))\n\t\t} else {\n\t\t\ts.join(NewEnclave(data[i : i+c]))\n\t\t}\n\t}\n\treturn len(data), nil\n}\n\n/*\nRead decrypts and places some data from a Stream object into a provided buffer.\n\nIf there is no data, the call will return an io.EOF error. If the caller provides a buffer\nthat is too small to hold the next chunk of data, the remaining bytes are re-encrypted and\nadded to the front of the queue to be returned in the next call.\n\nTo be performant, have\n*/\nfunc (s *Stream) Read(buf []byte) (int, error) {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\t// Grab the next chunk of data from the stream.\n\tb, err := s.next()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer b.Destroy()\n\n\t// Copy the contents into the given buffer.\n\tcore.Copy(buf, b.Bytes())\n\n\t// Check if there is data left over.\n\tif len(buf) < b.Size() {\n\t\t// Re-encrypt it and push onto the front of the list.\n\t\tc := NewBuffer(b.Size() - len(buf))\n\t\tc.Copy(b.Bytes()[len(buf):])\n\t\ts.push(c.Seal())\n\t\treturn len(buf), nil\n\t}\n\n\t// Not enough data or perfect amount of data.\n\t// Either way we copied the entire buffer.\n\treturn b.Size(), nil\n}\n\n// Size returns the number of bytes of data currently stored within a Stream object.\nfunc (s *Stream) Size() int {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\tvar n int\n\tfor e := s.Front(); e != nil; e = e.Next() {\n\t\tn += e.Value.(*Enclave).Size()\n\t}\n\treturn n\n}\n\n// Next grabs the next chunk of data from the Stream and returns it decrypted inside a LockedBuffer. Any error from the stream is forwarded.\nfunc (s *Stream) Next() (*LockedBuffer, error) {\n\ts.Lock()\n\tdefer s.Unlock()\n\n\treturn s.next()\n}\n\n// does not acquire mutex lock\nfunc (s *Stream) next() (*LockedBuffer, error) {\n\t// Pop data from the front of the list.\n\te := s.pop()\n\tif e == nil {\n\t\treturn newNullBuffer(), io.EOF\n\t}\n\n\t// Decrypt the data into a guarded allocation.\n\tb, err := e.Open()\n\tif err != nil {\n\t\treturn newNullBuffer(), err\n\t}\n\treturn b, nil\n}\n\n// Flush reads all of the data from a Stream and returns it inside a LockedBuffer. If an error is encountered before all the data could be read, it is returned along with any data read up until that point.\nfunc (s *Stream) Flush() (*LockedBuffer, error) {\n\treturn NewBufferFromEntireReader(s)\n}\n"
        },
        {
          "name": "stream_test.go",
          "type": "blob",
          "size": 4.6650390625,
          "content": "package memguard\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/awnumar/memguard/core\"\n)\n\nfunc write(t *testing.T, s *Stream, b []byte) {\n\tn, err := s.Write(b)\n\tif err != nil {\n\t\tt.Error(\"write should always succeed\", err)\n\t}\n\tif n != len(b) {\n\t\tt.Error(\"not all data was written\")\n\t}\n\tif !bytes.Equal(b, make([]byte, len(b))) {\n\t\tt.Error(\"buffer not wiped\")\n\t}\n}\n\nfunc read(t *testing.T, s *Stream, ref []byte, expectedErr error) {\n\tb := make([]byte, len(ref))\n\tn, err := s.Read(b)\n\tif err != expectedErr {\n\t\tt.Error(\"Expected\", expectedErr, \"got;\", err)\n\t}\n\tif n != len(b) {\n\t\tt.Error(\"not enough data read\")\n\t}\n\tif !bytes.Equal(ref, b) {\n\t\tt.Error(\"data mismatch\")\n\t}\n}\n\nfunc TestStreamNextFlush(t *testing.T) {\n\ts := NewStream()\n\n\tsize := 2*StreamChunkSize + 1024\n\tb := make([]byte, size)\n\tScrambleBytes(b)\n\tref := make([]byte, len(b))\n\tcopy(ref, b)\n\twrite(t, s, b)\n\n\tc, err := s.Next()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif c.Size() != StreamChunkSize {\n\t\tt.Error(c.Size())\n\t}\n\tif !c.EqualTo(ref[:StreamChunkSize]) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tc.Destroy()\n\n\tc, err = s.Flush()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif c.Size() != size-StreamChunkSize {\n\t\tt.Error(\"unexpected length:\", c.Size())\n\t}\n\tif !c.EqualTo(ref[StreamChunkSize:]) {\n\t\tt.Error(\"incorrect data\")\n\t}\n\tc.Destroy()\n}\n\nfunc TestStreamReadWrite(t *testing.T) {\n\t// Create new stream object.\n\ts := NewStream()\n\n\t// Initialise some data to store.\n\tb := make([]byte, 1024)\n\tScrambleBytes(b)\n\tref := make([]byte, len(b))\n\tcopy(ref, b)\n\n\t// Write the data to the stream.\n\twrite(t, s, b)\n\n\t// Read the data back.\n\tread(t, s, ref, nil)\n\n\t// Check for end of data error\n\tread(t, s, nil, io.EOF)\n\n\t// Write more than the pagesize to the stream\n\tb = make([]byte, os.Getpagesize()*4+16)\n\tScrambleBytes(b)\n\tcopy(b[os.Getpagesize()*4:], []byte(\"yellow submarine\"))\n\tref = make([]byte, len(b))\n\tcopy(ref, b)\n\twrite(t, s, b)\n\n\t// Read back four pages\n\tfor i := 0; i < 4; i++ {\n\t\tread(t, s, ref[i*os.Getpagesize():(i+1)*os.Getpagesize()], nil)\n\t}\n\n\t// Read back the remaining data\n\tread(t, s, []byte(\"yellow submarine\"), nil)\n\n\t// Should be no data left\n\tread(t, s, nil, io.EOF)\n\n\t// Test reading less data than is in the chunk\n\tdata := make([]byte, 16)\n\tScrambleBytes(data)\n\tref = make([]byte, len(data))\n\tcopy(ref, data)\n\twrite(t, s, data)\n\twrite(t, s, data) // have two enclaves in the stream, 32 bytes total\n\tread(t, s, ref[:4], nil)\n\tread(t, s, ref[4:8], nil)\n\tread(t, s, ref[8:], nil)\n\tread(t, s, make([]byte, 16), nil)\n\tread(t, s, nil, io.EOF)\n\n\t// Test reading after purging the session\n\tScrambleBytes(data)\n\twrite(t, s, data)\n\tPurge()\n\tread(t, s, nil, core.ErrDecryptionFailed)\n}\n\nfunc TestStreamingSanity(t *testing.T) {\n\ts := NewStream()\n\n\t// write 2 pages + 1024 bytes to the stream\n\tsize := 2*os.Getpagesize() + 1024\n\tb := make([]byte, size)\n\tScrambleBytes(b)\n\tref := make([]byte, len(b))\n\tcopy(ref, b)\n\twrite(t, s, b)\n\n\t// read it back exactly\n\tc, err := NewBufferFromReader(s, size)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif c.Size() != size {\n\t\tt.Error(\"not enough data read back\")\n\t}\n\tif !c.EqualTo(ref) {\n\t\tt.Error(\"data mismatch\")\n\t}\n\tc.Destroy()\n\n\t// should be no data left\n\tread(t, s, nil, io.EOF)\n\n\t// write the data back to the stream\n\tcopy(b, ref)\n\twrite(t, s, b)\n\n\t// read it all back\n\tc, err = NewBufferFromEntireReader(s)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif c.Size() != size {\n\t\tt.Error(\"not enough data read back\")\n\t}\n\tif !c.EqualTo(ref) {\n\t\tt.Error(\"data mismatch\")\n\t}\n\tc.Destroy()\n\n\t// should be no data left\n\tread(t, s, nil, io.EOF)\n\n\t// write a page + 1024 bytes\n\tsize = os.Getpagesize() + 1024\n\tb = make([]byte, size)\n\tb[size-1] = 'x'\n\twrite(t, s, b)\n\n\t// read it back until the delimiter\n\tc, err = NewBufferFromReaderUntil(s, 'x')\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif c.Size() != size-1 {\n\t\tt.Error(\"not enough data read back:\", c.Size(), \"want\", size-1)\n\t}\n\tif !c.EqualTo(make([]byte, size-1)) {\n\t\tt.Error(\"data mismatch\")\n\t}\n\tc.Destroy()\n\n\t// should be no data left\n\tread(t, s, nil, io.EOF)\n}\n\nfunc TestStreamSize(t *testing.T) {\n\ts := NewStream()\n\n\tif s.Size() != 0 {\n\t\tt.Error(\"size is\", s.Size())\n\t}\n\n\tsize := 1024 * 32\n\tb := make([]byte, size)\n\twrite(t, s, b)\n\n\tif s.Size() != size {\n\t\tt.Error(\"size should be\", size, \"instead is\", s.Size())\n\t}\n}\n\nfunc BenchmarkStreamWrite(b *testing.B) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(StreamChunkSize))\n\n\ts := NewStream()\n\tbuf := make([]byte, StreamChunkSize)\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Write(buf)\n\t}\n\truntime.KeepAlive(s)\n}\n\nfunc BenchmarkStreamRead(b *testing.B) {\n\ts := NewStream()\n\tbuf := make([]byte, StreamChunkSize)\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Write(buf)\n\t}\n\n\tb.ReportAllocs()\n\tb.SetBytes(int64(StreamChunkSize))\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\ts.Read(buf)\n\t}\n\n\truntime.KeepAlive(s)\n}\n"
        }
      ]
    }
  ]
}