{
  "metadata": {
    "timestamp": 1736567366309,
    "page": 973,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vzex/dog-tunnel",
      "stars": 2173,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "dtunnel\ndtunnel_s\n/bin/"
        },
        {
          "name": "BUG",
          "type": "blob",
          "size": 0.5751953125,
          "content": "2014-01-06:某些网络环境（A，B），要求穿透方向必须是A向B发起，否则会穿透失败。所以必须实现重试机制，双方互换顺序进行穿透，由tcp server控制(fixed)\n2014-01-19:对外ip有多个的网络环境，提供手工指明ip列表和stun服务辅助检测ip的机制进行穿透(fixed)\n2014-01-29:对于nat更改监听端口的情况没有处理，导致穿透失败(fixed)\n2014-01-31:网络不好的情况下，重试机制出现问题，导致收发包混乱，并且超时机制也处理错误，断开连接后仍在尝试发送数据(fixed)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014-2015 vzex\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.177734375,
          "content": "all:\n\t@make release\nrelease:\n\tmake mac\n\tmake linux\n\tmake win\n\tmake pi\nmac:\n\tmake client\n\tmake server\nlinux:\n\tmake client_linux\n\tmake server_linux\npi:\n\tmake client_pi\n\tmake server_pi\nwin:\n\tmake client_win\n\tmake server_win\ndebug:\n\tmake client_debug\n\tmake server_debug\n\nclient_debug:\n\t@go build -gcflags \"-N -l\" -o dtunnel_d client.go\nserver_debug:\n\t@go build -gcflags \"-N -l\" -o dtunnel_s_d server.go\n\n\nclient:\n\t@go build -ldflags \"-s -w\" -o bin/dtunnel client.go\nclient_linux:\n\t@GOOS=linux GOARCH=amd64 go build -ldflags \"-s -w\" -o bin/linux/dtunnel client.go\nclient_pi:\n\t@GOOS=linux GOARCH=arm go build -ldflags \"-s -w\" -o bin/pi/dtunnel client.go\nclient_win:\n\t@GOOS=windows GOARCH=amd64 go build -ldflags \"-s -w\" -o bin/windows/dtunnel.exe client.go\n\n\nserver:\n\t@go build -ldflags \"-s -w\" -o bin/dtunnel_s server.go\nserver_linux:\n\t@GOOS=linux GOARCH=amd64 go build -ldflags \"-s -w\" -o bin/linux/dtunnel_s server.go\nserver_pi:\n\t@GOOS=linux GOARCH=arm go build -ldflags \"-s -w\" -o bin/pi/dtunnel_s server.go\nserver_win:\n\t@GOOS=windows GOARCH=amd64 go build -ldflags \"-s -w\" -o bin/windows/dtunnel_s.exe server.go\n\nclean:\n\t@rm -rf bin/*\n.PHONY: all debug release client_debug server_debug client server clean\n"
        },
        {
          "name": "README.en.md",
          "type": "blob",
          "size": 3.6669921875,
          "content": "# Dog Tunnel\r\n## Introduction\r\n\r\nkcp-based p2p port mapping tool that supports SOCKS5 proxy\r\n\r\n## Compiling\r\nInstallation dependencies\r\n\r\ngo get github.com/go-sql-driver/mysql\r\n\r\ngo get github.com/klauspost/reedsolomon\r\n\r\ngo get github.com/cznic/zappy\r\n\r\nCompiler\r\ngo get -u -d github.com/vzex/dog-tunnel && cd $GOPATH/src/github.com/vzex/dog-tunnel/ && git checkout master && make\r\n\r\n(Windows users modify the path by themselves)\r\n\r\n## server setup\r\n\r\nThe compiled program has two dtunnel_s, dtunnel\r\n\r\ndtunnel_s is the server dtunnel is the client\r\n\r\nThe use of dtunnel reference official website http://dog-tunnel.tk (Note: The official website because it hangs on a vps unreliable expires to stop the renewals, so no longer provide the official p2p server, after the binary version will Posted in github\r\n\r\nWhen dtunnel_s starts, it will listen to a TCP port and set it with -addr. If you need -ssl (default is false), then you must specify -cert to load the ssl certificate. Then the client connection must also open the -ssl switch (default is true).\r\n-addrudp is the auxiliary udp port for p2p hole punching. It can increase the success rate of hole punching. The corresponding dtunnel parameter -buster specifies the same ip and port.\r\n\r\ndtunnel_s supports remote interface management. If necessary, specify ip:port with -admin, for example -admin 127.0.0.1:1234\r\n\r\nList of supported commands\r\n```\r\nhttp://127.0.0.1:1234/admin?cmd=servers List all reg users\r\nhttp://127.0.0.1:1234/admin?cmd=sessions&server=a list all links to a session\r\nhttp://127.0.0.1:1234/admin?admin?cmd=kicksession&server=a&session=1 Kick off the client with session number 1 (link end)\r\nhttp://127.0.0.1:1234/admin?cmd=kickserver&server=a Kick off reg a client\r\nhttp://127.0.0.1:1234/admin?cmd=broadcast&type=s&msg=test&quit=true broadcast message, type(s:reg, c:link, a: all clients), msg message content, quit Provincial parameters, non-empty broadcast after the client is kicked out)\r\n\r\nhttp://127.0.0.1:1234/admin?cmd=usersetting (user management related api, need to connect mysql)\r\nConfigure mysql need to use auth/auth.sql table statement, create the database dogtunnel before the construction of the table\r\nConnection mysql need to add -dbhost -dbuser -dbpass parameters in the startup parameters, after adding mysql must pass -key to log in to the server\r\nThe use of mysql please learn on your own\r\nThere are multiple subcommands under usersetting (directly spelled above main api)\r\n&action=list&limita=0&limitb=10, pagination lists user information\r\n&action=limit&user=aaa&size=10000 Limit user aaa's c/s mode traffic to 10k (daily)\r\n&action=add&user=aaa&passwd=1111&type=admin Add user aaa, password 1111, type type (admin administrator (highest privilege), black blacklist, super advanced user, type not pass default normal user), return key user dtunnel - Key parameter\r\n&action=get&user=aaa Returns aaa's user information\r\n&action=del&user=aaa delete aaa\r\n&action=key&user=aaa Returns aaa's new key\r\n&action=set&user=aaa&type=super&serven=10&sessionn=100&pipen=10&sameip=10, which restricts the function of aaa account. The type specified by the type has a default set of configurations, and can also specify servern (the maximum number of registered names), sessionn (The upper limit of the number of sessions that each registered server can connect to), pipen (up to several p2p pipes per session), and single ip (configured to the same number of ip configurable services)\r\n\r\n```\r\n## Thanks\r\n\r\n[netroby] (https://github.com/netroby)\r\n\r\n## License\r\n\r\n[MIT License](LICENSE)\r\n\r\n## Credits\r\n![Welcome donate with Alipay && Welcome to Alipay for this project] (https://raw.githubusercontent.com/vzex/dog-tunnel/udpVersion/dog-tunnel.png)\r\n\r\nAuthor: vzex@163.com"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.2998046875,
          "content": "# Dog Tunnel(狗洞)\n[README in English](https://github.com/f06ybeast/dog-tunnel/blob/master/README.en.md) \n## Introduction\n\n基于kcp的p2p端口映射工具，同时支持socks5代理\n\n## 编译\n安装依赖\n\ngo get github.com/go-sql-driver/mysql\n\ngo get github.com/klauspost/reedsolomon\n\ngo get github.com/cznic/zappy\n\n编译程序\ngo get -u -d github.com/vzex/dog-tunnel && cd $GOPATH/src/github.com/vzex/dog-tunnel/ && git checkout master && make\n\n(windows用户自行修改路径)\n\n## 服务器搭建\n\n编译出来的程序有两个dtunnel_s, dtunnel\n\ndtunnel_s 为服务端 dtunnel 为客户端\n\ndtunnel 的用法参考官网 http://dog-tunnel.tk(注:官网因为挂在一个不靠谱的vps上到期就停止续费了，所以不再提供官方的p2p服务器了，之后的二进制版本会发布在github中)\n\ndtunnel_s 启动时会监听一个tcp端口，通过-addr设置，如果需要-ssl(默认是false)，那么要指定-cert加载ssl证书，之后客户端连接也要打开-ssl开关(默认是true的)\n-addrudp 是p2p打洞的辅助udp端口，能提高打洞成功率,对应dtunnel参数-buster指定同样的ip和端口\n\ndtunnel_s 支持远程接口管理，如果需要，可通过-admin 指定ip:端口，比如-admin 127.0.0.1:1234\n\n支持的命令列表\n```\nhttp://127.0.0.1:1234/admin?cmd=servers 列出所有reg的用户\nhttp://127.0.0.1:1234/admin?cmd=sessions&server=a 列出所有link到a的会话\nhttp://127.0.0.1:1234/admin?admin?cmd=kicksession&server=a&session=1 踢掉会话号为1的客户端(link端)\nhttp://127.0.0.1:1234/admin?cmd=kickserver&server=a 踢掉reg a的客户端\nhttp://127.0.0.1:1234/admin?cmd=broadcast&type=s&msg=test&quit=true 广播消息,type(s:reg端,c:link端,a:所有客户端),msg消息内容,quit(缺省参数，非空则广播后客户端被踢掉)\n\nhttp://127.0.0.1:1234/admin?cmd=usersetting (用户管理相关api，需要连接mysql)\n配置mysql需要用到auth/auth.sql 建表语句，建表前请先创建数据库dogtunnel\n连接mysql需要在启动参数中添加 -dbhost -dbuser -dbpass 参数，加了mysql之后就必须通过-key才能登录服务器\nmysql的使用方法请自行学习\nusersetting下面有多个子命令(直接拼在上面主api后面)\n&action=list&limita=0&limitb=10,分页列出用户信息\n&action=limit&user=aaa&size=10000 限制用户aaa的c/s模式流量上线为10k（每日）\n&action=add&user=aaa&passwd=1111&type=admin 添加用户aaa，密码1111，类型type(admin管理员(最高权限),black黑名单,super高级用户,type不传默认普通用户),返回的key用户dtunnel 的-key参数\n&action=get&user=aaa 返回aaa的用户信息\n&action=del&user=aaa 删除aaa\n&action=key&user=aaa 返回aaa的新key\n&action=set&user=aaa&type=super&serven=10&sessionn=100&pipen=10&sameip=10,对aaa的账号做功能限制，type指定的类型有默认的几套配置，也可以通过指定servern(可以注册的名字数上限),sessionn(每个注册的服务器可以连接的会话数上限),pipen(每个会话最多支持几条p2p管道),sameip(同ip可注册服务数上限)来单独指定配置\n\n```\n## Thanks\n\n[netroby](https://github.com/netroby)\n\n## License\n\n[MIT License](LICENSE)\n\n## Credits\n![Welcome donate with Alipay && 欢迎使用支付宝对该项目进行捐赠](https://raw.githubusercontent.com/vzex/dog-tunnel/udpVersion/dog-tunnel.png)\n\nauthor: vzex@163.com\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.5693359375,
          "content": "(%100)udp发包ack确认，失败自动重发，发包顺序简单校验\n(%100)客户端穿透失败自动换向重连\n(%80)服务端管理端口,广播,踢人,关服,限制人数,限制ip,限制服务名\n(%100)版本校验\n(%100)udp穿透失败后切换成c/s模式\n(%100)客户端会话支持打多个洞，备用洞用于内嵌shell功能\n(%80)账号数据存储，登录认证，登录次数，流量，时长限制(go-sql-driver)\n(%80)配置文件支持(账号密码读取,json file)\n(%100)客户端会话支持sock5 proxy\n(%0)nat类型检测\n(%0)新的分级日志(factorlog)\n\n"
        },
        {
          "name": "admin",
          "type": "tree",
          "content": null
        },
        {
          "name": "auth",
          "type": "tree",
          "content": null
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 32.1923828125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"os/user\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/vzex/dog-tunnel/common\"\n\t\"github.com/vzex/dog-tunnel/nat\"\n)\n\nvar accessKey = flag.String(\"key\", \"\", \"please get an accesskey\")\nvar clientKey = flag.String(\"clientkey\", \"\", \"when other client linkt to the reg client, need clientkey, or empty\")\n\nvar serverAddr = flag.String(\"remote\", \"127.0.0.1:8000\", \"connect remote server\")\nvar serverBustAddr = flag.String(\"buster\", \"127.0.0.1:8018\", \"MakeHole server\")\n\nvar addInitAddr = flag.String(\"addip\", \"127.0.0.1\", \"addip for bust,xx.xx.xx.xx;xx.xx.xx.xx;\")\nvar pipeNum = flag.Int(\"pipen\", 1, \"pipe num for transmission\")\nvar kcpSettings = flag.String(\"kcp\", \"\", \"k1:v1;k2:v2;... k in (nodelay, resend, nc, snd, rcv, mtu),two sides should use the same setting\")\nvar dataShards = flag.Int(\"ds\", 0, \"dataShards for fec, only available in p2p mode, two sides should be same\")\nvar parityShards = flag.Int(\"ps\", 0, \"parityShards for fec, only available in p2p mode, two sides should be same\")\n\nvar serveName = flag.String(\"reg\", \"\", \"reg the name for client link, must assign reg or link\")\n\nvar linkName = flag.String(\"link\", \"\", \"name for link, must assign reg or link\")\nvar localAddr = flag.String(\"local\", \"\", \"addr for listen or connect(value \\\"socks5\\\" means tcp socks5 proxy for reg),depends on link or reg\")\nvar bVerbose = flag.Bool(\"v\", false, \"verbose mode\")\nvar delayTime = flag.Int(\"delay\", 2, \"if bust fail, try to make some delay seconds\")\nvar clientMode = flag.Int(\"mode\", 0, \"connect mode:0 if p2p fail, use c/s mode;1 just p2p mode;2 just c/s mode\")\nvar bUseSSL = flag.Bool(\"ssl\", true, \"use ssl\")\nvar bShowVersion = flag.Bool(\"version\", false, \"show version\")\nvar bLoadSettingFromFile = flag.Bool(\"f\", false, \"load setting from file(~/.dtunnel)\")\nvar bEncrypt = flag.Bool(\"encrypt\", false, \"p2p mode encrypt\")\nvar dnsCacheNum = flag.Int(\"dnscache\", 0, \"if > 0, dns will cache xx minutes\")\n\nvar aesKey *cipher.Block\n\nvar remoteConn net.Conn\nvar clientType = -1\n\ntype dnsInfo struct {\n\tIp                  string\n\tStatus              string\n\tQueue               []*dnsQueryReq\n\toverTime, cacheTime int64\n}\n\nfunc (u *dnsInfo) IsAlive() bool {\n\treturn time.Now().Unix() < u.overTime\n}\n\nfunc (u *dnsInfo) GetCacheTime() int64 {\n\treturn u.overTime\n}\n\nfunc (u *dnsInfo) SetCacheTime(t int64) {\n\tif t >= 0 {\n\t\tu.cacheTime = t\n\t} else {\n\t\tt = u.cacheTime\n\t}\n\tu.overTime = t + time.Now().Unix()\n}\nfunc (u *dnsInfo) DeInit() {}\n\nvar g_ClientMap map[string]*Client\nvar g_ClientMapKey map[string]*cipher.Block\nvar g_Id2UDPSession map[string]*UDPMakeSession\nvar markName = \"\"\nvar bForceQuit = false\n\nfunc isCommonSessionId(id string) bool {\n\treturn id == \"common\"\n}\n\nfunc handleResponse(conn net.Conn, clientId string, action string, content string) {\n\t//log.Println(\"got\", clientId, action)\n\tswitch action {\n\tcase \"aeskey\":\n\t\tfmt.Println(\"init aeskey for client\", clientId, content)\n\t\tblock, _ := aes.NewCipher([]byte(content))\n\t\tg_ClientMapKey[clientId] = &block\n\tcase \"show\":\n\t\tfmt.Println(time.Now().Format(\"2006-01-02 15:04:05\"), content)\n\tcase \"showandretry\":\n\t\tfmt.Println(time.Now().Format(\"2006-01-02 15:04:05\"), content)\n\t\tremoteConn.Close()\n\tcase \"showandquit\":\n\t\tfmt.Println(time.Now().Format(\"2006-01-02 15:04:05\"), content)\n\t\tremoteConn.Close()\n\t\tbForceQuit = true\n\tcase \"clientquit\":\n\t\tclient := g_ClientMap[clientId]\n\t\tlog.Println(\"clientquit!!!\", clientId, client)\n\t\tif client != nil {\n\t\t\tclient.Quit()\n\t\t}\n\tcase \"remove_udpsession\":\n\t\tlog.Println(\"server force remove udpsession\", clientId)\n\t\tdelete(g_Id2UDPSession, clientId)\n\tcase \"query_addrlist_a\":\n\t\toutip := content\n\t\tarr := strings.Split(clientId, \"-\")\n\t\tid := arr[0]\n\t\tsessionId := arr[1]\n\t\tpipeType := arr[2]\n\t\tg_Id2UDPSession[id] = &UDPMakeSession{id: id, sessionId: sessionId, pipeType: pipeType}\n\t\tgo g_Id2UDPSession[id].reportAddrList(true, outip)\n\tcase \"query_addrlist_b\":\n\t\tarr := strings.Split(clientId, \"-\")\n\t\tid := arr[0]\n\t\tsessionId := arr[1]\n\t\tpipeType := arr[2]\n\t\tg_Id2UDPSession[id] = &UDPMakeSession{id: id, sessionId: sessionId, pipeType: pipeType}\n\t\tgo g_Id2UDPSession[id].reportAddrList(false, content)\n\tcase \"tell_bust_a\":\n\t\tsession, bHave := g_Id2UDPSession[clientId]\n\t\tif bHave {\n\t\t\tgo session.beginMakeHole(content)\n\t\t}\n\tcase \"tell_bust_b\":\n\t\tsession, bHave := g_Id2UDPSession[clientId]\n\t\tif bHave {\n\t\t\tgo session.beginMakeHole(\"\")\n\t\t}\n\tcase \"csmode_c_tunnel_close\":\n\t\tlog.Println(\"receive close msg from server\")\n\t\tarr := strings.Split(clientId, \"-\")\n\t\tclientId = arr[0]\n\t\tsessionId := arr[1]\n\t\tclient, bHave := g_ClientMap[clientId]\n\t\tif bHave {\n\t\t\tclient.removeSession(sessionId)\n\t\t}\n\tcase \"csmode_s_tunnel_close\":\n\t\tarr := strings.Split(clientId, \"-\")\n\t\tclientId = arr[0]\n\t\tsessionId := arr[1]\n\t\tclient, bHave := g_ClientMap[clientId]\n\t\tif bHave {\n\t\t\tclient.removeSession(sessionId)\n\t\t}\n\tcase \"csmode_s_tunnel_open\":\n\t\toriId := clientId\n\t\tarr := strings.Split(oriId, \"-\")\n\t\tclientId = arr[0]\n\t\tsessionId := arr[1]\n\t\tclient, bHave := g_ClientMap[clientId]\n\t\tif !bHave {\n\t\t\tclient = &Client{id: clientId, pipes: make(map[int]net.Conn), engine: nil, buster: true, sessions: make(map[string]*clientSession), ready: true, bUdp: false}\n\t\t\tclient.pipes[0] = remoteConn\n\t\t\tg_ClientMap[clientId] = client\n\t\t} else {\n\t\t\tclient.pipes[0] = remoteConn\n\t\t\tclient.ready = true\n\t\t\tclient.bUdp = false\n\t\t}\n\t\t//log.Println(\"client init csmode\", clientId, sessionId)\n\t\tif *localAddr != \"socks5\" {\n\t\t\ts_conn, err := net.DialTimeout(\"tcp\", *localAddr, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"connect to local server fail:\", err.Error())\n\t\t\t\tmsg := \"cannot connect to bind addr\" + *localAddr\n\t\t\t\tcommon.Write(remoteConn, clientId, \"tunnel_error\", msg)\n\t\t\t\t//remoteConn.Close()\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tclient.sessionLock.Lock()\n\t\t\t\tclient.sessions[sessionId] = &clientSession{pipe: remoteConn, localConn: s_conn}\n\t\t\t\tclient.sessionLock.Unlock()\n\t\t\t\tgo handleLocalPortResponse(client, oriId)\n\t\t\t}\n\t\t} else {\n\t\t\tclient.sessionLock.Lock()\n\t\t\tclient.sessions[sessionId] = &clientSession{pipe: remoteConn, localConn: nil, status: \"init\", recvMsg: \"\"}\n\t\t\tclient.sessionLock.Unlock()\n\t\t}\n\tcase \"csmode_c_begin\":\n\t\tclient, bHave := g_ClientMap[clientId]\n\t\tif !bHave {\n\t\t\tclient = &Client{id: clientId, pipes: make(map[int]net.Conn), engine: nil, buster: false, sessions: make(map[string]*clientSession), ready: true, bUdp: false}\n\t\t\tclient.pipes[0] = remoteConn\n\t\t\tg_ClientMap[clientId] = client\n\t\t} else {\n\t\t\tclient.pipes[0] = remoteConn\n\t\t\tclient.ready = true\n\t\t\tclient.bUdp = false\n\t\t}\n\t\tif client.MultiListen() {\n\t\t\tcommon.Write(remoteConn, clientId, \"makeholeok\", \"csmode\")\n\t\t}\n\tcase \"csmode_msg_c\":\n\t\toriId := clientId\n\t\tarr := strings.Split(clientId, \"-\")\n\t\tclientId = arr[0]\n\t\tsessionId := arr[1]\n\t\tclient, bHave := g_ClientMap[clientId]\n\t\tif bHave {\n\t\t\tsession := client.getSession(sessionId)\n\t\t\tif session != nil && session.localConn != nil {\n\t\t\t\tsession.localConn.Write([]byte(content))\n\t\t\t} else if session != nil && *localAddr == \"socks5\" {\n\t\t\t\tsession.processSockProxy(client, oriId, content, func() {\n\t\t\t\t\tif len(session.recvMsg) > 0 && session.localConn != nil {\n\t\t\t\t\t\tsession.localConn.Write([]byte(session.recvMsg))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\tcase \"csmode_msg_s\":\n\t\tarr := strings.Split(clientId, \"-\")\n\t\tclientId = arr[0]\n\t\tsessionId := arr[1]\n\t\tclient, bHave := g_ClientMap[clientId]\n\t\tif bHave {\n\t\t\tsession := client.getSession(sessionId)\n\t\t\tif session != nil && session.localConn != nil {\n\t\t\t\tsession.localConn.Write([]byte(content))\n\t\t\t} else {\n\t\t\t\t//log.Println(\"cs:cannot tunnel msg\", sessionId)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype UDPMakeSession struct {\n\tid        string\n\tsessionId string\n\tbuster    bool\n\tengine    *nat.AttemptEngine\n\tdelay     int\n\tpipeType  string\n}\n\nfunc (session *UDPMakeSession) beginMakeHole(content string) {\n\tengine := session.engine\n\tif engine == nil {\n\t\treturn\n\t}\n\taddrList := content\n\tif session.buster {\n\t\tengine.SetOtherAddrList(addrList)\n\t}\n\tlog.Println(\"begin bust\", session.id, session.sessionId, session.buster)\n\tif clientType == 1 && !session.buster {\n\t\tlog.Println(\"retry bust!\")\n\t}\n\treport := func() {\n\t\tif session.buster {\n\t\t\tif session.delay > 0 {\n\t\t\t\tlog.Println(\"try to delay\", session.delay, \"seconds\")\n\t\t\t\ttime.Sleep(time.Duration(session.delay) * time.Second)\n\t\t\t}\n\t\t\tgo common.Write(remoteConn, session.id, \"success_bust_a\", \"\")\n\t\t}\n\t}\n\toldSession := session\n\tvar aesBlock *cipher.Block\n\tif clientType == 1 {\n\t\taesBlock = aesKey\n\t} else {\n\t\taesBlock, _ = g_ClientMapKey[session.sessionId]\n\t}\n\tvar conn net.Conn\n\tvar err error\n\tif aesBlock == nil {\n\t\tconn, err = engine.GetConn(report, nil, nil)\n\t} else {\n\t\tconn, err = engine.GetConn(report, func(s []byte) []byte {\n\t\t\tif aesBlock == nil {\n\t\t\t\treturn s\n\t\t\t} else {\n\t\t\t\tpadLen := aes.BlockSize - (len(s) % aes.BlockSize)\n\t\t\t\tfor i := 0; i < padLen; i++ {\n\t\t\t\t\ts = append(s, byte(padLen))\n\t\t\t\t}\n\t\t\t\tsrcLen := len(s)\n\t\t\t\tencryptText := make([]byte, srcLen+aes.BlockSize)\n\t\t\t\tiv := encryptText[srcLen:]\n\t\t\t\tfor i := 0; i < len(iv); i++ {\n\t\t\t\t\tiv[i] = byte(i)\n\t\t\t\t}\n\t\t\t\tmode := cipher.NewCBCEncrypter(*aesBlock, iv)\n\t\t\t\tmode.CryptBlocks(encryptText[:srcLen], s)\n\t\t\t\treturn encryptText\n\t\t\t}\n\t\t}, func(s []byte) []byte {\n\t\t\tif aesBlock == nil {\n\t\t\t\treturn s\n\t\t\t} else {\n\t\t\t\tif len(s) < aes.BlockSize*2 || len(s)%aes.BlockSize != 0 {\n\t\t\t\t\treturn []byte{}\n\t\t\t\t}\n\t\t\t\tsrcLen := len(s) - aes.BlockSize\n\t\t\t\tdecryptText := make([]byte, srcLen)\n\t\t\t\tiv := s[srcLen:]\n\t\t\t\tmode := cipher.NewCBCDecrypter(*aesBlock, iv)\n\t\t\t\tmode.CryptBlocks(decryptText, s[:srcLen])\n\t\t\t\tpaddingLen := int(decryptText[srcLen-1])\n\t\t\t\tif paddingLen > 16 {\n\t\t\t\t\treturn []byte{}\n\t\t\t\t}\n\t\t\t\treturn decryptText[:srcLen-paddingLen]\n\t\t\t}\n\t\t})\n\t}\n\tsession, _bHave := g_Id2UDPSession[session.id]\n\tif session != oldSession {\n\t\treturn\n\t}\n\tif !_bHave {\n\t\treturn\n\t}\n\tdelete(g_Id2UDPSession, session.id)\n\tif err == nil {\n\t\tif !session.buster {\n\t\t\tcommon.Write(remoteConn, session.id, \"makeholeok\", \"\")\n\t\t}\n\t\tclient, bHave := g_ClientMap[session.sessionId]\n\t\tif !bHave {\n\t\t\tclient = &Client{id: session.sessionId, engine: session.engine, buster: session.buster, ready: true, bUdp: true, sessions: make(map[string]*clientSession), specPipes: make(map[string]net.Conn), pipes: make(map[int]net.Conn)}\n\t\t\tg_ClientMap[session.sessionId] = client\n\t\t}\n\t\tif isCommonSessionId(session.pipeType) {\n\t\t\tsize := len(client.pipes)\n\t\t\tclient.pipes[size] = conn\n\t\t\tgo client.Run(size, \"\")\n\t\t\tlog.Println(\"add common session\", session.buster, session.sessionId, session.id)\n\t\t\tif clientType == 1 {\n\t\t\t\tif len(client.pipes) == *pipeNum {\n\t\t\t\t\tclient.MultiListen()\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tclient.specPipes[session.pipeType] = conn\n\t\t\tgo client.Run(-1, session.pipeType)\n\t\t\tlog.Println(\"add session for\", session.pipeType)\n\t\t}\n\t} else {\n\t\tdelete(g_ClientMap, session.sessionId)\n\t\tdelete(g_ClientMapKey, session.sessionId)\n\t\tlog.Println(\"cannot connect\", err.Error())\n\t\tif !session.buster && err.Error() != \"quit\" {\n\t\t\tcommon.Write(remoteConn, session.id, \"makeholefail\", \"\")\n\t\t}\n\t}\n}\n\nfunc getKcpSetting() *nat.KcpSetting {\n\tsetting := nat.DefaultKcpSetting()\n\t//bSetResend := false\n\tif *kcpSettings != \"\" {\n\t\tarr := strings.Split(*kcpSettings, \";\")\n\t\tfor _, v := range arr {\n\t\t\t_arr := strings.Split(v, \":\")\n\t\t\tif len(_arr) == 2 {\n\t\t\t\tk := _arr[0]\n\t\t\t\tvar val int32\n\t\t\t\tvar _val int\n\t\t\t\t_val, _ = strconv.Atoi(_arr[1])\n\t\t\t\tval = int32(_val)\n\n\t\t\t\tswitch k {\n\t\t\t\tcase \"nodelay\":\n\t\t\t\t\tsetting.Nodelay = val\n\t\t\t\tcase \"resend\":\n\t\t\t\t\tsetting.Resend = val\n\t\t\t\t\t//bSetResend = true\n\t\t\t\tcase \"nc\":\n\t\t\t\t\tsetting.Nc = val\n\t\t\t\tcase \"snd\":\n\t\t\t\t\tsetting.Sndwnd = val\n\t\t\t\tcase \"rcv\":\n\t\t\t\t\tsetting.Rcvwnd = val\n\t\t\t\tcase \"mtu\":\n\t\t\t\t\tsetting.Mtu = val\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//setting.Xor = *xorData\n\t/*\n\t\tif *dataShards > 0 && *parityShards > 0 {\n\t\t\tif !bSetResend {\n\t\t\t\tsetting.Resend = 0\n\t\t\t\tprintln(\"resend default to 0 in fec mode\")\n\t\t\t}\n\t\t}*/\n\treturn setting\n}\n\nfunc (session *UDPMakeSession) reportAddrList(buster bool, outip string) {\n\tid := session.id\n\tvar otherAddrList string\n\tif !buster {\n\t\tarr := strings.SplitN(outip, \":\", 2)\n\t\toutip, otherAddrList = arr[0], arr[1]\n\t} else {\n\t\tarr := strings.SplitN(outip, \":\", 2)\n\t\tvar delayTime string\n\t\toutip, delayTime = arr[0], arr[1]\n\t\tsession.delay, _ = strconv.Atoi(delayTime)\n\t\tif session.delay < 0 {\n\t\t\tsession.delay = 0\n\t\t}\n\t}\n\toutip += \";\" + *addInitAddr\n\t_id, _ := strconv.Atoi(id)\n\tengine, err := nat.Init(outip, buster, _id, *serverBustAddr)\n\tengine.Kcp = getKcpSetting()\n\tengine.D = *dataShards\n\tengine.P = *parityShards\n\tif err != nil {\n\t\tprintln(\"init error\", err.Error())\n\t\tdisconnect()\n\t\treturn\n\t}\n\tsession.engine = engine\n\tsession.buster = buster\n\tif !buster {\n\t\tengine.SetOtherAddrList(otherAddrList)\n\t}\n\taddrList := engine.GetAddrList()\n\tprintln(\"addrList\", addrList)\n\tcommon.Write(remoteConn, id, \"report_addrlist\", addrList)\n}\n\ntype fileSetting struct {\n\tKey string\n}\n\nfunc saveSettings(info fileSetting) error {\n\tclientInfoStr, err := json.Marshal(info)\n\tif err != nil {\n\t\treturn err\n\t}\n\tuser, err := user.Current()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfilePath := path.Join(user.HomeDir, \".dtunnel\")\n\n\treturn ioutil.WriteFile(filePath, clientInfoStr, 0700)\n}\n\nfunc loadSettings(info *fileSetting) error {\n\tuser, err := user.Current()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfilePath := path.Join(user.HomeDir, \".dtunnel\")\n\tcontent, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal([]byte(content), info)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tflag.Parse()\n\tcheckDns = make(chan *dnsQueryReq)\n\tcheckDnsRes = make(chan *dnsQueryBack)\n\tgo dnsLoop()\n\tif *bShowVersion {\n\t\tfmt.Printf(\"%.2f\\n\", common.Version)\n\t\treturn\n\t}\n\tif !*bVerbose {\n\t\tlog.SetOutput(ioutil.Discard)\n\t}\n\tif *dataShards < 0 || *dataShards >= 128 {\n\t\tprintln(\"-ds should in [0-127]\")\n\t\treturn\n\t}\n\tif *parityShards < 0 || *parityShards >= 128 {\n\t\tprintln(\"-ds should in [0-127]\")\n\t\treturn\n\t}\n\tif *serveName == \"\" && *linkName == \"\" {\n\t\tprintln(\"you must assign reg or link\")\n\t\treturn\n\t}\n\tif *serveName != \"\" && *linkName != \"\" {\n\t\tprintln(\"you must assign reg or link, not both of them\")\n\t\treturn\n\t}\n\tif *localAddr == \"\" {\n\t\tprintln(\"you must assign the local addr\")\n\t\treturn\n\t}\n\tif *serveName != \"\" {\n\t\tclientType = 0\n\t} else {\n\t\tclientType = 1\n\t}\n\tif *bEncrypt {\n\t\tif clientType != 1 {\n\t\t\tprintln(\"only link size need encrypt\")\n\t\t\treturn\n\t\t}\n\t}\n\tgo func() {\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\t\tn := 0\n\t\tfor {\n\t\t\t<-c\n\t\t\tlog.Println(\"received signal,shutdown\")\n\t\t\tbForceQuit = true\n\t\t\tif remoteConn != nil {\n\t\t\t\tremoteConn.Close()\n\t\t\t}\n\t\t\tn++\n\t\t\tif n > 5 {\n\t\t\t\tlog.Println(\"force shutdown\")\n\t\t\t\tos.Exit(-1)\n\t\t\t}\n\t\t}\n\t}()\n\n\tloop := func() bool {\n\t\tif bForceQuit {\n\t\t\treturn true\n\t\t}\n\t\tg_ClientMap = make(map[string]*Client)\n\t\tg_ClientMapKey = make(map[string]*cipher.Block)\n\t\tg_Id2UDPSession = make(map[string]*UDPMakeSession)\n\t\t//var err error\n\t\tif *bUseSSL {\n\t\t\t_remoteConn, err := tls.Dial(\"tcp\", *serverAddr, &tls.Config{InsecureSkipVerify: true})\n\t\t\tif err != nil {\n\t\t\t\tprintln(\"connect remote err:\" + err.Error())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tremoteConn = net.Conn(_remoteConn)\n\t\t} else {\n\t\t\t_remoteConn, err := net.DialTimeout(\"tcp\", *serverAddr, 10*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tprintln(\"connect remote err:\" + err.Error())\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tremoteConn = _remoteConn\n\t\t}\n\t\tprintln(\"connect to server succeed\")\n\t\tgo connect()\n\t\tq := make(chan bool)\n\t\tgo func() {\n\t\t\tc := time.NewTicker(time.Second * 10)\n\t\tout:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-c.C:\n\t\t\t\t\tif remoteConn != nil {\n\t\t\t\t\t\tcommon.Write(remoteConn, \"-1\", \"ping\", \"\")\n\t\t\t\t\t}\n\t\t\t\tcase <-q:\n\t\t\t\t\tbreak out\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Stop()\n\t\t}()\n\n\t\tcommon.Read(remoteConn, handleResponse)\n\t\tq <- true\n\t\tfor clientId, client := range g_ClientMap {\n\t\t\tlog.Println(\"client shutdown\", clientId)\n\t\t\tclient.Quit()\n\t\t}\n\n\t\tfor _, session := range g_Id2UDPSession {\n\t\t\tif session.engine != nil {\n\t\t\t\tsession.engine.Fail()\n\t\t\t}\n\t\t}\n\t\tif remoteConn != nil {\n\t\t\tremoteConn.Close()\n\t\t}\n\t\tif bForceQuit {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tif clientType == 0 {\n\t\tfor {\n\t\t\tif loop() {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ttime.Sleep(10 * time.Second)\n\t\t}\n\t} else {\n\t\tloop()\n\t}\n\tlog.Println(\"service shutdown\")\n}\n\nfunc connect() {\n\tif *pipeNum <= 0 {\n\t\t*pipeNum = 1\n\t}\n\tclientInfo := common.ClientSetting{Version: common.Version, Delay: *delayTime, Mode: *clientMode, PipeNum: *pipeNum, AccessKey: *accessKey, ClientKey: *clientKey, AesKey: \"\"}\n\tif *bEncrypt {\n\t\tclientInfo.AesKey = string([]byte(fmt.Sprintf(\"asd4%d%d\", int32(time.Now().Unix()), (rand.Intn(100000) + 100)))[:16])\n\t\tlog.Println(\"debug aeskey\", clientInfo.AesKey)\n\t\tkey, _ := aes.NewCipher([]byte(clientInfo.AesKey))\n\t\taesKey = &key\n\t}\n\tif *bLoadSettingFromFile {\n\t\tvar setting fileSetting\n\t\terr := loadSettings(&setting)\n\t\tif err == nil {\n\t\t\tclientInfo.AccessKey = setting.Key\n\t\t} else {\n\t\t\tlog.Println(\"load setting fail\", err.Error())\n\t\t}\n\t} else {\n\t\tif clientInfo.AccessKey != \"\" {\n\t\t\tvar setting = fileSetting{Key: clientInfo.AccessKey}\n\t\t\terr := saveSettings(setting)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"save setting error\", err.Error())\n\t\t\t} else {\n\t\t\t\tprintln(\"save setting ok, nexttime please use -f to replace -key\")\n\t\t\t}\n\t\t}\n\t}\n\tif clientType == 0 {\n\t\tmarkName = *serveName\n\t\tclientInfo.ClientType = \"reg\"\n\t} else if clientType == 1 {\n\t\tmarkName = *linkName\n\t\tclientInfo.ClientType = \"link\"\n\t} else {\n\t\tprintln(\"no clienttype!\")\n\t}\n\tclientInfo.Name = markName\n\tclientInfoStr, err := json.Marshal(clientInfo)\n\tif err != nil {\n\t\tprintln(\"encode args error\")\n\t}\n\tlog.Println(\"init client\", string(clientInfoStr))\n\tcommon.Write(remoteConn, \"0\", \"init\", string(clientInfoStr))\n}\n\nfunc disconnect() {\n\tif remoteConn != nil {\n\t\tremoteConn.Close()\n\t\tremoteConn = nil\n\t}\n}\n\ntype clientSession struct {\n\tpipe      net.Conn\n\tlocalConn net.Conn\n\tstatus    string\n\trecvMsg   string\n\textra     uint8\n}\n\nfunc (session *clientSession) processSockProxy(sc *Client, sessionId, content string, callback func()) {\n\tpipe := session.pipe\n\tsession.recvMsg += content\n\tbytes := []byte(session.recvMsg)\n\tsize := len(bytes)\n\t//log.Println(\"recv msg-====\", len(session.recvMsg),  session.recvMsg, session.status, sessionId)\n\tswitch session.status {\n\tcase \"init\":\n\t\tif session.localConn != nil {\n\t\t\tsession.localConn.Close()\n\t\t\tsession.localConn = nil\n\t\t}\n\t\tif size < 2 {\n\t\t\t//println(\"wait init\")\n\t\t\treturn\n\t\t}\n\t\tvar _, nmethod uint8 = bytes[0], bytes[1]\n\t\t//println(\"version\", version, nmethod)\n\t\tsession.status = \"version\"\n\t\tsession.recvMsg = string(bytes[2:])\n\t\tsession.extra = nmethod\n\tcase \"version\":\n\t\tif uint8(size) < session.extra {\n\t\t\t//println(\"wait version\")\n\t\t\treturn\n\t\t}\n\t\tvar send = []uint8{5, 0}\n\t\tgo common.Write(pipe, sessionId, \"tunnel_msg_s\", string(send))\n\t\tsession.status = \"hello\"\n\t\tsession.recvMsg = string(bytes[session.extra:])\n\t\tsession.extra = 0\n\t\t//log.Println(\"now\", len(session.recvMsg))\n\tcase \"hello\":\n\t\tvar hello reqMsg\n\t\tbOk, tail := hello.read(bytes)\n\t\tif bOk {\n\t\t\tgo func() {\n\t\t\t\tvar ansmsg ansMsg\n\t\t\t\turl := hello.url\n\t\t\t\tvar s_conn net.Conn\n\t\t\t\tvar err error\n\t\t\t\tif *dnsCacheNum > 0 && hello.atyp == 3 {\n\t\t\t\t\thost := string(hello.dst_addr[1 : 1+hello.dst_addr[0]])\n\t\t\t\t\tresChan := make(chan *dnsQueryRes)\n\t\t\t\t\tcheckDns <- &dnsQueryReq{c: resChan, host: host, port: int(hello.dst_port2), reqtype: hello.reqtype, url: url}\n\t\t\t\t\tres := <-resChan\n\t\t\t\t\ts_conn = res.conn\n\t\t\t\t\terr = res.err\n\t\t\t\t\tif res.ip != \"\" {\n\t\t\t\t\t\turl = net.JoinHostPort(res.ip, fmt.Sprintf(\"%d\", hello.dst_port2))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif s_conn == nil && err == nil {\n\t\t\t\t\ts_conn, err = net.DialTimeout(hello.reqtype, url, 30*time.Second)\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"connect to local server fail:\", err.Error())\n\t\t\t\t\tansmsg.gen(&hello, 4)\n\t\t\t\t\tgo common.Write(pipe, sessionId, \"tunnel_msg_s\", string(ansmsg.buf[:ansmsg.mlen]))\n\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tsession.localConn = s_conn\n\t\t\t\t\tgo handleLocalPortResponse(sc, sessionId)\n\t\t\t\t\tansmsg.gen(&hello, 0)\n\t\t\t\t\tgo common.Write(pipe, sessionId, \"tunnel_msg_s\", string(ansmsg.buf[:ansmsg.mlen]))\n\t\t\t\t\tsession.status = \"ok\"\n\t\t\t\t\tsession.recvMsg = string(tail)\n\t\t\t\t\tcallback()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}()\n\t\t} else {\n\t\t\t//log.Println(\"wait hello\")\n\t\t}\n\t\treturn\n\tcase \"ok\":\n\t\treturn\n\t}\n\tsession.processSockProxy(sc, sessionId, \"\", callback)\n}\n\nvar checkDns chan *dnsQueryReq\nvar checkDnsRes chan *dnsQueryBack\n\ntype dnsQueryReq struct {\n\tc       chan *dnsQueryRes\n\thost    string\n\tport    int\n\treqtype string\n\turl     string\n}\n\ntype dnsQueryBack struct {\n\thost   string\n\tstatus string\n\tconn   net.Conn\n\terr    error\n}\n\ntype dnsQueryRes struct {\n\tconn net.Conn\n\terr  error\n\tip   string\n}\n\nfunc dnsLoop() {\n\tfor {\n\t\tselect {\n\t\tcase info := <-checkDns:\n\t\t\tcache := common.GetCacheContainer(\"dns\")\n\t\t\tcacheInfo := cache.GetCache(info.host)\n\t\t\tif cacheInfo == nil {\n\t\t\t\tcache.AddCache(info.host, &dnsInfo{Queue: []*dnsQueryReq{info}, Status: \"querying\"}, int64(*dnsCacheNum*60))\n\t\t\t\tgo func() {\n\t\t\t\t\tback := &dnsQueryBack{host: info.host}\n\t\t\t\t\t//log.Println(\"try dial\", info.url)\n\t\t\t\t\ts_conn, err := net.DialTimeout(info.reqtype, info.url, 30*time.Second)\n\t\t\t\t\t//log.Println(\"try dial\", info.url, \"ok\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tback.status = \"queryfail\"\n\t\t\t\t\t\tback.err = err\n\t\t\t\t\t} else {\n\t\t\t\t\t\tback.status = \"queryok\"\n\t\t\t\t\t\tback.conn = s_conn\n\t\t\t\t\t}\n\t\t\t\t\tcheckDnsRes <- back\n\t\t\t\t}()\n\t\t\t} else {\n\t\t\t\t_cacheInfo := cacheInfo.(*dnsInfo)\n\t\t\t\t//log.Println(\"on trigger\", info.host, _cacheInfo.GetCacheTime(), len(_cacheInfo.Queue))\n\t\t\t\tswitch _cacheInfo.Status {\n\t\t\t\tcase \"querying\":\n\t\t\t\t\t_cacheInfo.Queue = append(_cacheInfo.Queue, info)\n\t\t\t\t\t//cache.UpdateCache(info.host, _cacheInfo)\n\t\t\t\t\tcacheInfo.SetCacheTime(-1)\n\t\t\t\tcase \"queryok\":\n\t\t\t\t\tcacheInfo.SetCacheTime(-1)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tinfo.c <- &dnsQueryRes{ip: _cacheInfo.Ip}\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\t\t//url = cacheInfo.(*dnsInfo).Ip + fmt.Sprintf(\":%d\", info.port)\n\t\t\t}\n\t\tcase info := <-checkDnsRes:\n\t\t\tcache := common.GetCacheContainer(\"dns\")\n\t\t\tcacheInfo := cache.GetCache(info.host)\n\t\t\tif cacheInfo != nil {\n\t\t\t\t_cacheInfo := cacheInfo.(*dnsInfo)\n\t\t\t\t_cacheInfo.Status = info.status\n\t\t\t\tswitch info.status {\n\t\t\t\tcase \"queryfail\":\n\t\t\t\t\tfor _, _info := range _cacheInfo.Queue {\n\t\t\t\t\t\tc := _info.c\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tc <- &dnsQueryRes{err: info.err}\n\t\t\t\t\t\t}()\n\t\t\t\t\t}\n\t\t\t\t\tcache.DelCache(info.host)\n\t\t\t\tcase \"queryok\":\n\t\t\t\t\tlog.Println(\"add host\", info.host, \"to dns cache\")\n\t\t\t\t\t_cacheInfo.Ip, _, _ = net.SplitHostPort(info.conn.RemoteAddr().String())\n\t\t\t\t\t_cacheInfo.SetCacheTime(-1)\n\t\t\t\t\t//log.Println(\"process the queue of host\", info.host, len(_cacheInfo.Queue))\n\t\t\t\t\tconn := info.conn\n\t\t\t\t\tfor _, _info := range _cacheInfo.Queue {\n\t\t\t\t\t\tc := _info.c\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tc <- &dnsQueryRes{ip: _cacheInfo.Ip, conn: conn}\n\t\t\t\t\t\t}()\n\t\t\t\t\t\tconn = nil\n\t\t\t\t\t}\n\t\t\t\t\t_cacheInfo.Queue = []*dnsQueryReq{}\n\t\t\t\t}\n\t\t\t\t//cache.UpdateCache(info.host, _cacheInfo)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype ansMsg struct {\n\tver  uint8\n\trep  uint8\n\trsv  uint8\n\tatyp uint8\n\tbuf  [300]uint8\n\tmlen uint16\n}\n\nfunc (msg *ansMsg) gen(req *reqMsg, rep uint8) {\n\tmsg.ver = 5\n\tmsg.rep = rep //rfc1928\n\tmsg.rsv = 0\n\tmsg.atyp = 1\n\n\tmsg.buf[0], msg.buf[1], msg.buf[2], msg.buf[3] = msg.ver, msg.rep, msg.rsv, msg.atyp\n\tfor i := 5; i < 11; i++ {\n\t\tmsg.buf[i] = 0\n\t}\n\tmsg.mlen = 10\n}\n\ntype reqMsg struct {\n\tver       uint8     // socks v5: 0x05\n\tcmd       uint8     // CONNECT: 0x01, BIND:0x02, UDP ASSOCIATE: 0x03\n\trsv       uint8     //RESERVED\n\tatyp      uint8     //IP V4 addr: 0x01, DOMANNAME: 0x03, IP V6 addr: 0x04\n\tdst_addr  [255]byte //\n\tdst_port  [2]uint8  //\n\tdst_port2 uint16    //\n\n\treqtype string\n\turl     string\n}\n\nfunc (msg *reqMsg) read(bytes []byte) (bool, []byte) {\n\tsize := len(bytes)\n\tif size < 4 {\n\t\treturn false, bytes\n\t}\n\tbuf := bytes[0:4]\n\n\tmsg.ver, msg.cmd, msg.rsv, msg.atyp = buf[0], buf[1], buf[2], buf[3]\n\t//println(\"test\", msg.ver, msg.cmd, msg.rsv, msg.atyp)\n\n\tif 5 != msg.ver || 0 != msg.rsv {\n\t\tlog.Println(\"Request Message VER or RSV error!\")\n\t\treturn false, bytes[4:]\n\t}\n\tbuf = bytes[4:]\n\tsize = len(buf)\n\tswitch msg.atyp {\n\tcase 1: //ip v4\n\t\tif size < 4 {\n\t\t\treturn false, buf\n\t\t}\n\t\tcopy(msg.dst_addr[:4], buf[:4])\n\t\tbuf = buf[4:]\n\t\tsize = len(buf)\n\tcase 4:\n\t\tif size < 16 {\n\t\t\treturn false, buf\n\t\t}\n\t\tcopy(msg.dst_addr[:16], buf[:16])\n\t\tbuf = buf[16:]\n\t\tsize = len(buf)\n\tcase 3:\n\t\tif size < 1 {\n\t\t\treturn false, buf\n\t\t}\n\t\tcopy(msg.dst_addr[:1], buf[:1])\n\t\tbuf = buf[1:]\n\t\tsize = len(buf)\n\t\tif size < int(msg.dst_addr[0]) {\n\t\t\treturn false, buf\n\t\t}\n\t\tcopy(msg.dst_addr[1:], buf[:int(msg.dst_addr[0])])\n\t\tbuf = buf[int(msg.dst_addr[0]):]\n\t\tsize = len(buf)\n\t}\n\tif size < 2 {\n\t\treturn false, buf\n\t}\n\tcopy(msg.dst_port[:], buf[:2])\n\tmsg.dst_port2 = (uint16(msg.dst_port[0]) << 8) + uint16(msg.dst_port[1])\n\n\tswitch msg.cmd {\n\tcase 1:\n\t\tmsg.reqtype = \"tcp\"\n\tcase 2:\n\t\tlog.Println(\"BIND\")\n\tcase 3:\n\t\tmsg.reqtype = \"udp\"\n\t}\n\tswitch msg.atyp {\n\tcase 1: // ipv4\n\t\tmsg.url = fmt.Sprintf(\"%d.%d.%d.%d:%d\", msg.dst_addr[0], msg.dst_addr[1], msg.dst_addr[2], msg.dst_addr[3], msg.dst_port2)\n\tcase 3: //DOMANNAME\n\t\tmsg.url = net.JoinHostPort(string(msg.dst_addr[1:1+msg.dst_addr[0]]), fmt.Sprintf(\"%d\", msg.dst_port2))\n\tcase 4: //ipv6\n\t\tmsg.url = fmt.Sprintf(\"[%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x:%x%x]:%d\", msg.dst_addr[0], msg.dst_addr[1], msg.dst_addr[2], msg.dst_addr[3],\n\t\t\tmsg.dst_addr[4], msg.dst_addr[5], msg.dst_addr[6], msg.dst_addr[7],\n\t\t\tmsg.dst_addr[8], msg.dst_addr[9], msg.dst_addr[10], msg.dst_addr[11],\n\t\t\tmsg.dst_addr[12], msg.dst_addr[13], msg.dst_addr[14], msg.dst_addr[15],\n\t\t\tmsg.dst_port2)\n\t}\n\tlog.Println(msg.reqtype, msg.url, msg.atyp, msg.dst_port2)\n\treturn true, buf[2:]\n}\n\ntype Client struct {\n\tid          string\n\tbuster      bool\n\tengine      *nat.AttemptEngine\n\tpipes       map[int]net.Conn          // client for pipes\n\tspecPipes   map[string]net.Conn       // client for pipes\n\tsessions    map[string]*clientSession // session to pipeid\n\tsessionLock sync.RWMutex\n\tready       bool\n\tbUdp        bool\n}\n\n// pipe : client to client\n// local : client to local apps\nfunc (sc *Client) getSession(sessionId string) *clientSession {\n\tsc.sessionLock.RLock()\n\tsession, _ := sc.sessions[sessionId]\n\tsc.sessionLock.RUnlock()\n\treturn session\n}\n\nfunc (sc *Client) removeSession(sessionId string) bool {\n\tif clientType == 1 {\n\t\tcommon.RmId(\"udp\", sessionId)\n\t}\n\tsc.sessionLock.RLock()\n\tsession, bHave := sc.sessions[sessionId]\n\tsc.sessionLock.RUnlock()\n\tif bHave {\n\t\tif session.localConn != nil {\n\t\t\tsession.localConn.Close()\n\t\t}\n\t\tsc.sessionLock.Lock()\n\t\tdelete(sc.sessions, sessionId)\n\t\tsc.sessionLock.Unlock()\n\t\t//log.Println(\"client\", sc.id, \"remove session\", sessionId)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (sc *Client) OnTunnelRecv(pipe net.Conn, sessionId string, action string, content string) {\n\t//println(\"recv p2p tunnel\", sessionId, action, content)\n\tsession := sc.getSession(sessionId)\n\tvar conn net.Conn\n\tif session != nil {\n\t\tconn = session.localConn\n\t}\n\tswitch action {\n\tcase \"tunnel_error\":\n\t\tif conn != nil {\n\t\t\tconn.Write([]byte(content))\n\t\t\tlog.Println(\"tunnel error\", content, sessionId)\n\t\t}\n\t\tsc.removeSession(sessionId)\n\t\t//case \"serve_begin\":\n\tcase \"tunnel_msg_s\":\n\t\tif conn != nil {\n\t\t\t//println(\"tunnel msg\", sessionId, len(content))\n\t\t\tconn.Write([]byte(content))\n\t\t} else {\n\t\t\t//log.Println(\"cannot tunnel msg\", sessionId)\n\t\t}\n\tcase \"tunnel_close_s\":\n\t\tsc.removeSession(sessionId)\n\tcase \"ping\", \"pingback\":\n\t\t//log.Println(\"recv\", action)\n\t\tif action == \"ping\" {\n\t\t\tcommon.Write(pipe, sessionId, \"pingback\", \"\")\n\t\t}\n\tcase \"tunnel_msg_c\":\n\t\tif conn != nil {\n\t\t\t//log.Println(\"tunnel\", len(content), sessionId)\n\t\t\tconn.Write([]byte(content))\n\t\t} else if *localAddr == \"socks5\" {\n\t\t\tif session == nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsession.processSockProxy(sc, sessionId, content, func() {\n\t\t\t\tsc.OnTunnelRecv(pipe, sessionId, action, session.recvMsg)\n\t\t\t})\n\t\t}\n\tcase \"tunnel_close\":\n\t\tsc.removeSession(sessionId)\n\tcase \"tunnel_open\":\n\t\tif clientType == 0 {\n\t\t\tif *localAddr != \"socks5\" {\n\t\t\t\ts_conn, err := net.DialTimeout(\"tcp\", *localAddr, 10*time.Second)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Println(\"connect to local server fail:\", err.Error())\n\t\t\t\t\tmsg := \"cannot connect to bind addr\" + *localAddr\n\t\t\t\t\tcommon.Write(pipe, sessionId, \"tunnel_error\", msg)\n\t\t\t\t\t//remoteConn.Close()\n\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tsc.sessionLock.Lock()\n\t\t\t\t\tsc.sessions[sessionId] = &clientSession{pipe: pipe, localConn: s_conn}\n\t\t\t\t\tsc.sessionLock.Unlock()\n\t\t\t\t\tgo handleLocalPortResponse(sc, sessionId)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsc.sessionLock.Lock()\n\t\t\t\tsc.sessions[sessionId] = &clientSession{pipe: pipe, localConn: nil, status: \"init\", recvMsg: \"\"}\n\t\t\t\tsc.sessionLock.Unlock()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (sc *Client) Quit() {\n\tlog.Println(\"client quit\", sc.id)\n\tdelete(g_ClientMap, sc.id)\n\tdelete(g_ClientMapKey, sc.id)\n\tfor id, _ := range sc.sessions {\n\t\tsc.removeSession(id)\n\t}\n\tfor _, pipe := range sc.pipes {\n\t\tif pipe != remoteConn {\n\t\t\tpipe.Close()\n\t\t}\n\t}\n\tif sc.engine != nil {\n\t\tsc.engine.Fail()\n\t}\n}\n\n///////////////////////multi pipe support\nvar g_LocalConn net.Conn\n\nfunc (sc *Client) MultiListen() bool {\n\tif g_LocalConn == nil {\n\t\tg_LocalConn, err := net.Listen(\"tcp\", *localAddr)\n\t\tif err != nil {\n\t\t\tlog.Println(\"cannot listen addr:\" + err.Error())\n\t\t\tif remoteConn != nil {\n\t\t\t\tremoteConn.Close()\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\tgo func() {\n\t\t\tquit := false\n\t\t\tping := time.NewTicker(time.Second)\n\t\t\tgo func() {\n\t\t\tout:\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ping.C:\n\t\t\t\t\t\tif quit {\n\t\t\t\t\t\t\tbreak out\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor _, pipe := range sc.pipes {\n\t\t\t\t\t\t\tcommon.Write(pipe, \"-1\", \"ping\", \"\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\tfor {\n\t\t\t\tconn, err := g_LocalConn.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsessionId := common.GetId(\"udp\")\n\t\t\t\tpipe := sc.getOnePipe()\n\t\t\t\tif pipe == nil {\n\t\t\t\t\tlog.Println(\"cannot get pipe for client\")\n\t\t\t\t\tif remoteConn != nil {\n\t\t\t\t\t\tremoteConn.Close()\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tsc.sessionLock.Lock()\n\t\t\t\tsc.sessions[sessionId] = &clientSession{pipe: pipe, localConn: conn}\n\t\t\t\tsc.sessionLock.Unlock()\n\t\t\t\tlog.Println(\"client\", sc.id, \"create session\", sessionId)\n\t\t\t\tgo handleLocalServerResponse(sc, sessionId)\n\t\t\t}\n\t\t\tquit = true\n\t\t\tping.Stop()\n\t\t}()\n\t\tmode := \"p2p mode\"\n\t\tif !sc.bUdp {\n\t\t\tmode = \"c/s mode\"\n\t\t\tdelete(g_ClientMapKey, sc.id)\n\t\t}\n\t\tprintln(\"service start success,please connect\", *localAddr, mode)\n\t}\n\treturn true\n}\n\nfunc (sc *Client) getOnePipe() net.Conn {\n\ttmp := []int{}\n\tfor id, _ := range sc.pipes {\n\t\ttmp = append(tmp, id)\n\t}\n\tsize := len(tmp)\n\tif size == 0 {\n\t\treturn nil\n\t}\n\tindex := rand.Intn(size)\n\tlog.Println(\"choose pipe for \", sc.id, \",\", index, \"of\", size)\n\thitId := tmp[index]\n\tpipe, _ := sc.pipes[hitId]\n\treturn pipe\n}\n\n///////////////////////multi pipe support\n\nfunc (sc *Client) Run(index int, specPipe string) {\n\tvar pipe net.Conn\n\tif index >= 0 {\n\t\tpipe = sc.pipes[index]\n\t} else {\n\t\tpipe = sc.specPipes[specPipe]\n\t}\n\tif pipe == nil {\n\t\treturn\n\t}\n\tgo func() {\n\t\tcallback := func(conn net.Conn, sessionId, action, content string) {\n\t\t\tif sc != nil {\n\t\t\t\tsc.OnTunnelRecv(conn, sessionId, action, content)\n\t\t\t}\n\t\t}\n\t\tcommon.Read(pipe, callback)\n\t\tlog.Println(\"client end read\", index)\n\t\tif index >= 0 {\n\t\t\tdelete(sc.pipes, index)\n\t\t\tif clientType == 1 {\n\t\t\t\tif len(sc.pipes) == 0 {\n\t\t\t\t\tif remoteConn != nil {\n\t\t\t\t\t\tremoteConn.Close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdelete(sc.specPipes, specPipe)\n\t\t}\n\t}()\n}\n\nfunc (sc *Client) LocalAddr() net.Addr                { return nil }\nfunc (sc *Client) Close() error                       { return nil }\nfunc (sc *Client) RemoteAddr() net.Addr               { return nil }\nfunc (sc *Client) SetDeadline(t time.Time) error      { return nil }\nfunc (sc *Client) SetReadDeadline(t time.Time) error  { return nil }\nfunc (sc *Client) SetWriteDeadline(t time.Time) error { return nil }\n\nfunc handleLocalPortResponse(client *Client, id string) {\n\tsessionId := id\n\tif !client.bUdp {\n\t\tarr := strings.Split(id, \"-\")\n\t\tsessionId = arr[1]\n\t}\n\tsession := client.getSession(sessionId)\n\tif session == nil {\n\t\treturn\n\t}\n\tconn := session.localConn\n\tif conn == nil {\n\t\treturn\n\t}\n\tarr := make([]byte, nat.SendBuffSize)\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tsize, err := reader.Read(arr)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif common.Write(session.pipe, id, \"tunnel_msg_s\", string(arr[0:size])) != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\t// log.Println(\"handlerlocal down\")\n\tif client.removeSession(sessionId) {\n\t\tcommon.Write(session.pipe, id, \"tunnel_close_s\", \"\")\n\t}\n}\n\nfunc handleLocalServerResponse(client *Client, sessionId string) {\n\tsession := client.getSession(sessionId)\n\tif session == nil {\n\t\treturn\n\t}\n\tpipe := session.pipe\n\tif pipe == nil {\n\t\treturn\n\t}\n\tconn := session.localConn\n\tcommon.Write(pipe, sessionId, \"tunnel_open\", \"\")\n\tarr := make([]byte, nat.SendBuffSize)\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tsize, err := reader.Read(arr)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tif common.Write(pipe, sessionId, \"tunnel_msg_c\", string(arr[0:size])) != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tcommon.Write(pipe, sessionId, \"tunnel_close\", \"\")\n\tclient.removeSession(sessionId)\n}\n"
        },
        {
          "name": "common",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "dogtunnel",
          "type": "blob",
          "size": 0.212890625,
          "content": "#!/bin/bash\n\nBASE_DIR=`dirname $0`\nif [ -L $0 ]\nthen\n\tBASE_DIR=`dirname $(readlink $0)`\nfi\ncd $BASE_DIR\ngo run client.go -remote dog-tunnel.tk:8008 -key test -ssl -local :8888 -delay 2 -stun stun.l.google.com:19302 $@\n"
        },
        {
          "name": "ikcp",
          "type": "tree",
          "content": null
        },
        {
          "name": "keys",
          "type": "tree",
          "content": null
        },
        {
          "name": "nat",
          "type": "tree",
          "content": null
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 1.0458984375,
          "content": "#!/bin/bash\nversion=$1\nif [ $# -eq 0 ] \nthen\n        echo \"Please input version, like \\\"./release.sh 0.60\\\"\"\n        exit\nfi\nrm -f dtunnel_*$1.tgz\necho \"Build ReleaseFile for version $version\"\n\necho \"build linux_amd64\"\nGOOS=linux GOARCH=amd64 make\ntar zcvf dtunnel_linux_x64_$1.tgz dtunnel dtunnel_s\necho \"build linux_386\"\nGOOS=linux GOARCH=386 make\ntar zcvf dtunnel_linux_x86_$1.tgz dtunnel dtunnel_s\necho \"build mac_x64\"\nGOOS=darwin GOARCH=amd64 make\ntar zcvf dtunnel_mac_x64_$1.tgz dtunnel dtunnel_s\necho \"build win32\"\nGOOS=windows GOARCH=386 make && mv dtunnel dtunnel.exe && mv dtunnel_s dtunnel_s.exe\ntar zcvf dtunnel_win32_$1.tgz dtunnel.exe dtunnel_s.exe\necho \"build linux_arm\"\nGOOS=linux GOARCH=arm make\ntar zcvf dtunnel_linux_arm_$1.tgz dtunnel dtunnel_s\necho \"build linux_mips\"\nGOOS=linux GOARCH=mips make\ntar zcvf dtunnel_linux_mips_$1.tgz dtunnel dtunnel_s\necho \"build linux_mipsle\"\nGOOS=linux GOARCH=mipsle make\ntar zcvf dtunnel_linux_mipsle_$1.tgz dtunnel dtunnel_s\nrm -f dtunnel dtunnel.exe dtunnel_s dtunnel_s.exe\necho \"Build Over\"\nls -l dtunnel_*$1.tgz\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 14.787109375,
          "content": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/vzex/dog-tunnel/admin\"\n\t\"github.com/vzex/dog-tunnel/auth\"\n\t\"github.com/vzex/dog-tunnel/common\"\n)\n\nvar listenAddr = flag.String(\"addr\", \"0.0.0.0:8000\", \"server addr\")\nvar listenAddrUDP = flag.String(\"addrudp\", \"0.0.0.0:8018\", \"udp server addr\")\nvar bUseSSL = flag.Bool(\"ssl\", false, \"use ssl\")\nvar bUseHttps = flag.Bool(\"https\", false, \"use https\")\nvar certFile = flag.String(\"cert\", \"\", \"cert file\")\nvar keyFile = flag.String(\"key\", \"\", \"key file\")\n\nvar adminAddr = flag.String(\"admin\", \"\", \"admin addr\")\nvar bShowVersion = flag.Bool(\"version\", false, \"show version\")\nvar bReplaceReg = flag.Bool(\"replace\", false, \"if dup name registered, kick out the previous one, default is false\")\n\nvar db_user = flag.String(\"dbuser\", \"\", \"db user\")\nvar db_pass = flag.String(\"dbpass\", \"\", \"db password\")\nvar db_host = flag.String(\"dbhost\", \"\", \"db host\")\n\nvar bUseDB = false\n\nfunc handleClient(conn net.Conn) {\n\tcommon.Conn2ClientInfo[conn] = &common.ClientInfo{Conn: conn, ClientMap: make(map[net.Conn]*common.Session), Id2Session: make(map[string]*common.Session), IsServer: false, Quit: make(chan bool), ResponseTime: time.Now().Unix()}\n\tlog.Println(\"client linked success\", conn.RemoteAddr().String())\n\tcommon.Conn2ClientInfo[conn].Loop()\n\tcommon.Read(conn, handleResponse)\n\tclient, bHave := common.Conn2ClientInfo[conn]\n\tif bHave {\n\t\tclose(client.Quit)\n\t\tif client.IsServer {\n\t\t\tfor conn, session := range client.ClientMap {\n\t\t\t\tconn.Close()\n\t\t\t\tcommon.RmId(client.ServerName, session.Id)\n\t\t\t}\n\t\t\tdelete(common.ServerName2Conn, client.ServerName)\n\t\t\tlog.Println(\"unregister service Name\", client.ServerName)\n\t\t\tif bUseDB {\n\t\t\t\tuser, _ := auth.GetUser(client.UserName)\n\t\t\t\tif user != nil {\n\t\t\t\t\tuser.OnLogout()\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\t\tid := server.DelClient(conn)\n\t\t\t\tlog.Println(\"send quit\")\n\t\t\t\tcommon.Write(server.Conn, id, \"clientquit\", \"\")\n\t\t\t}, func() {})\n\t\t}\n\t\tdelete(common.Conn2ClientInfo, conn)\n\t}\n\tconn.Close()\n\tlog.Println(\"client disconnected\", conn.RemoteAddr().String())\n}\n\nfunc udphandleClient(conn *net.UDPConn) {\n\n\tfor {\n\n\t\tdata := make([]byte, 1024)\n\n\t\t_, remoteAddr, err := conn.ReadFromUDP(data)\n\t\tif err != nil {\n\t\t\tlog.Println(\"failed to read UDP msg because of \", err.Error())\n\t\t\tbreak\n\t\t}\n\n\t\tconn.WriteToUDP([]byte(remoteAddr.String()), remoteAddr)\n\t}\n}\n\nfunc handleResponse(conn net.Conn, id string, action string, content string) {\n\t//log.Println(\"got\", id, action, content)\n\tcommon.GetClientInfoByConn(conn, func(client *common.ClientInfo) {\n\t\tclient.ResponseTime = time.Now().Unix()\n\t}, func() {\n\t})\n\tswitch action {\n\tcase \"init\":\n\t\tclientInfoStr := content\n\t\tvar clientInfo common.ClientSetting\n\t\terr := json.Unmarshal([]byte(clientInfoStr), &clientInfo)\n\t\tif err != nil {\n\t\t\tlog.Println(\"error decode clientinfo, kick out\", conn.RemoteAddr().String())\n\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"server decode clientInfo error\")\n\t\t\treturn\n\t\t}\n\t\tif common.Version != clientInfo.Version {\n\t\t\ts_version := fmt.Sprintf(\"%.2f\", common.Version)\n\t\t\tc_version := fmt.Sprintf(\"%.2f\", clientInfo.Version)\n\t\t\tlog.Println(\"version not eq\", conn.RemoteAddr().String(), s_version, c_version)\n\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"client version:\"+c_version+\" not eq with server:\"+s_version)\n\t\t\treturn\n\t\t}\n\t\tServerName := clientInfo.Name\n\t\tif clientInfo.ClientType == \"reg\" {\n\t\t\tvar user *auth.User\n\t\t\tif bUseDB {\n\t\t\t\tif clientInfo.AccessKey == \"\" {\n\t\t\t\t\tuser, _ = auth.GetUser(\"test\")\n\t\t\t\t} else {\n\t\t\t\t\tuser, _ = auth.GetUserByKey(clientInfo.AccessKey)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tuser = &auth.User{UserType: auth.UserType_Admin}\n\t\t\t}\n\t\t\t//fmt.Printf(\"%+v\\n\", user)\n\t\t\tif user == nil {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"invalid user accessKey:\"+clientInfo.AccessKey+\"!!!\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !user.CheckOnlineServiceNum() {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"online service num cannot overstep \"+strconv.Itoa(user.MaxOnlineServerNum))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !user.CheckIpLimit(conn.RemoteAddr().(*net.TCPAddr).IP.String()) {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"ip limit service num cannot overstep \"+strconv.Itoa(user.MaxSameIPServers))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tf := func() {\n\t\t\t\tcommon.ServerName2Conn[ServerName] = conn\n\t\t\t\tcommon.GetClientInfoByConn(conn, func(info *common.ClientInfo) {\n\t\t\t\t\tinfo.ServerName = ServerName\n\t\t\t\t\tinfo.IsServer = true\n\t\t\t\t\tinfo.Id2MakeSession = make(map[string]*common.UDPMakeSession)\n\t\t\t\t\tinfo.UserName = user.UserName\n\t\t\t\t\tinfo.ClientKey = clientInfo.ClientKey\n\t\t\t\t}, func() {})\n\t\t\t\tlog.Println(\"client reg service success\", conn.RemoteAddr().String(), user.UserName, ServerName)\n\t\t\t\tcommon.Write(conn, \"0\", \"show\", \"register service ok, user:\"+user.UserName)\n\t\t\t}\n\t\t\tcommon.GetClientInfoByName(ServerName, func(server *common.ClientInfo) {\n\t\t\t\tif *bReplaceReg {\n\t\t\t\t\t_conn := server.Conn\n\t\t\t\t\tclose(server.Quit)\n\t\t\t\t\tfor conn, session := range server.ClientMap {\n\t\t\t\t\t\tconn.Close()\n\t\t\t\t\t\tcommon.RmId(server.ServerName, session.Id)\n\t\t\t\t\t}\n\t\t\t\t\tdelete(common.ServerName2Conn, server.ServerName)\n\t\t\t\t\tlog.Println(\"force unregister service Name\", server.ServerName)\n\t\t\t\t\tif bUseDB {\n\t\t\t\t\t\tuser, _ := auth.GetUser(server.UserName)\n\t\t\t\t\t\tif user != nil {\n\t\t\t\t\t\t\tuser.OnLogout()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete(common.Conn2ClientInfo, _conn)\n\t\t\t\t\tcommon.Write(_conn, \"0\", \"showandquit\", \"some one kick you out\")\n\t\t\t\t\t_conn.Close()\n\t\t\t\t\tf()\n\t\t\t\t} else {\n\t\t\t\t\tcommon.Write(conn, \"0\", \"showandretry\", \"already have the ServerName!\")\n\t\t\t\t}\n\t\t\t}, f)\n\t\t} else if clientInfo.ClientType == \"link\" {\n\t\t\tif clientInfo.Mode < 0 || clientInfo.Mode > 2 {\n\t\t\t\tclientInfo.Mode = 0\n\t\t\t}\n\t\t\tServerName := clientInfo.Name\n\t\t\tbAuth := true\n\t\t\tcommon.GetClientInfoByName(ServerName, func(info *common.ClientInfo) {\n\t\t\t\tvar user *auth.User\n\t\t\t\tif bUseDB {\n\t\t\t\t\tuser, _ = auth.GetUser(info.UserName)\n\t\t\t\t} else {\n\t\t\t\t\tuser = &auth.User{UserType: auth.UserType_Admin}\n\t\t\t\t}\n\t\t\t\t//fmt.Printf(\"%+v\\n\", user)\n\t\t\t\tif user == nil {\n\t\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"invalid user:\"+info.UserName+\"!!!\")\n\t\t\t\t\tbAuth = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif info.ClientKey != clientInfo.ClientKey {\n\t\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"clientkey invalid!!!\")\n\t\t\t\t\tbAuth = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !user.CheckSessionNum(len(info.ClientMap)) {\n\t\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"session numcannot overstep \"+strconv.Itoa(len(info.ClientMap)))\n\t\t\t\t\tbAuth = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !user.CheckPipeNum(clientInfo.PipeNum) {\n\t\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"pipenum cannot overstep \"+strconv.Itoa(user.MaxPipeNum))\n\t\t\t\t\tbAuth = false\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}, func() {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"serverName invalid!!!\")\n\t\t\t\tbAuth = false\n\t\t\t})\n\t\t\tif !bAuth {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcommon.GetClientInfoByConn(conn, func(client *common.ClientInfo) {\n\t\t\t\tclient.ServerName = ServerName\n\t\t\t}, func() {\n\t\t\t})\n\t\t\tcommon.GetClientInfoByName(ServerName, func(server *common.ClientInfo) {\n\t\t\t\tlog.Println(\"client link service success\", conn.RemoteAddr().String(), ServerName)\n\t\t\t\tserver.AddClient(conn, clientInfo)\n\t\t\t}, func() {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"donnt have this service name\")\n\t\t\t})\n\t\t}\n\tcase \"tunnel_error\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tlog.Println(\"<<=====tunnel_error\", server.ServerName, conn.RemoteAddr().String())\n\t\t\tsession, bHave := server.Id2Session[id]\n\t\t\tif bHave {\n\t\t\t\tsession.Status = \"fail\"\n\t\t\t\tcommon.Write(session.ClientA, \"0\", \"showandquit\", content)\n\t\t\t\tserver.DelClient(session.ClientA)\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"makeholefail\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tudpsession, bHave := server.Id2MakeSession[id]\n\t\t\tif bHave {\n\t\t\t\tlog.Println(\"<<=====make hole fail\", conn.RemoteAddr().String(), udpsession.ServerName, udpsession.SessionId, id)\n\t\t\t\tsessionId := udpsession.SessionId\n\t\t\t\tsession, _bHave := server.Id2Session[sessionId]\n\t\t\t\tif _bHave {\n\t\t\t\t\tsession.Status = \"fail\"\n\t\t\t\t\tsession.MakeHoleResponseN++\n\t\t\t\t\tsession.MakeHoleHasFail = true\n\t\t\t\t\tif session.MakeHoleResponseN == session.Setting.PipeNum {\n\t\t\t\t\t\tif session.Method == \"udp\" {\n\t\t\t\t\t\t\tsession.RestartSession(server.ServerName)\n\t\t\t\t\t\t} else if session.Method == \"restart\" {\n\t\t\t\t\t\t\tif session.Setting.Mode == 0 {\n\t\t\t\t\t\t\t\ttmp := session.ClientA\n\t\t\t\t\t\t\t\tsession.ClientA = session.ClientB\n\t\t\t\t\t\t\t\tsession.ClientB = tmp\n\t\t\t\t\t\t\t\tsession.StartCSMode()\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tserver.DelClient(session.ClientB)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tserver.DelClient(session.ClientA)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tudpsession.Remove(false)\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"makeholeok\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tif content == \"csmode\" {\n\t\t\t\tsession, _bHave := server.Id2Session[id]\n\t\t\t\tif _bHave {\n\t\t\t\t\tlog.Println(\"<<=====make hole ok\", conn.RemoteAddr().String(), server.ServerName, session.Id)\n\t\t\t\t\tsession.Status = \"ok\"\n\t\t\t\t\tsession.MakeHoleResponseN++\n\t\t\t\t}\n\t\t\t}\n\t\t\tudpsession, bHave := server.Id2MakeSession[id]\n\t\t\tif bHave {\n\t\t\t\tlog.Println(\"<<=====make hole ok\", conn.RemoteAddr().String(), udpsession.ServerName, udpsession.SessionId, id)\n\t\t\t\tsessionId := udpsession.SessionId\n\t\t\t\tsession, _bHave := server.Id2Session[sessionId]\n\t\t\t\tif _bHave {\n\t\t\t\t\tsession.MakeHoleResponseN++\n\t\t\t\t\tif session.MakeHoleResponseN == session.Setting.PipeNum {\n\t\t\t\t\t\tif !session.MakeHoleHasFail {\n\t\t\t\t\t\t\tsession.Status = \"ok\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tudpsession.Remove(false)\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"report_addrlist\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tudpsession, bHave := server.Id2MakeSession[id]\n\t\t\t//log.Println(\"test\", udpsession, id, server.ServerName)\n\t\t\tif bHave {\n\t\t\t\tlog.Println(\"<<===report addr list ok\", conn.RemoteAddr().String(), udpsession.ServerName, udpsession.Id)\n\t\t\t\tudpsession.BeginMakeHole(1, content)\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"success_bust_a\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tudpsession, bHave := server.Id2MakeSession[id]\n\t\t\tif bHave {\n\t\t\t\tlog.Println(\"<<=====success_bust_a\", conn.RemoteAddr().String(), udpsession.ServerName, udpsession.SessionId, id)\n\t\t\t\tudpsession.BeginMakeHole(2, content)\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\t// for c/s mode\n\tcase \"tunnel_close\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tsession := server.GetSession(conn)\n\t\t\tif session != nil {\n\t\t\t\tcommon.Write(session.ClientB, session.Id+\"-\"+id, \"csmode_s_tunnel_close\", content)\n\t\t\t} else {\n\t\t\t\tprintln(\"no session\")\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"tunnel_open\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tsession := server.GetSession(conn)\n\t\t\tif session != nil {\n\t\t\t\tcommon.Write(session.ClientB, session.Id+\"-\"+id, \"csmode_s_tunnel_open\", content)\n\t\t\t} else {\n\t\t\t\tprintln(\"no session\")\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"tunnel_msg_c\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tvar user *auth.User\n\t\t\tif bUseDB {\n\t\t\t\tuser, _ = auth.GetUser(server.UserName)\n\t\t\t} else {\n\t\t\t\tuser = &auth.User{UserType: auth.UserType_Admin}\n\t\t\t}\n\t\t\tif user == nil {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"cannot get userinfo of this service \"+server.UserName)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !user.UpdateCSMode(len(content)) {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"reach today's csmode data limit\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsession := server.GetSession(conn)\n\t\t\tif session != nil {\n\t\t\t\tcommon.Write(session.ClientB, session.Id+\"-\"+id, \"csmode_msg_c\", content)\n\t\t\t} else {\n\t\t\t\tprintln(\"no session\")\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"tunnel_msg_s\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tvar user *auth.User\n\t\t\tif bUseDB {\n\t\t\t\tuser, _ = auth.GetUser(server.UserName)\n\t\t\t} else {\n\t\t\t\tuser = &auth.User{UserType: auth.UserType_Admin}\n\t\t\t}\n\t\t\tif user == nil {\n\t\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"cannot get userinfo of this service\"+server.UserName)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !user.UpdateCSMode(len(content)) {\n\t\t\t\tcommon.Write(conn, \"0\", \"show\", \"reach today's csmode data limit\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tarr := strings.Split(id, \"-\")\n\t\t\tclientId := arr[0]\n\t\t\tsession, bHave := server.Id2Session[clientId]\n\t\t\tif bHave {\n\t\t\t\tcommon.Write(session.ClientA, id, \"csmode_msg_s\", content)\n\t\t\t} else {\n\t\t\t\tprintln(\"no session\")\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\tcase \"tunnel_close_s\":\n\t\tcommon.GetServerInfoByConn(conn, func(server *common.ClientInfo) {\n\t\t\tarr := strings.Split(id, \"-\")\n\t\t\tclientId := arr[0]\n\t\t\tsession, bHave := server.Id2Session[clientId]\n\t\t\tif bHave {\n\t\t\t\tcommon.Write(session.ClientA, id, \"csmode_c_tunnel_close\", content)\n\t\t\t} else {\n\t\t\t\tprintln(\"no session\")\n\t\t\t}\n\t\t}, func() {\n\t\t})\n\t}\n}\n\nvar err error\nvar g_Master net.Listener\n\nfunc main() {\n\tflag.Parse()\n\tif *bShowVersion {\n\t\tfmt.Printf(\"%.2f\\n\", common.Version)\n\t\treturn\n\t}\n\tcommon.Conn2ClientInfo = make(map[net.Conn]*common.ClientInfo)\n\tcommon.ServerName2Conn = make(map[string]net.Conn)\n\tcommon.Conn2Admin = make(map[net.Conn]*common.AdminInfo)\n\tlistener, err := net.Listen(\"tcp\", *listenAddr)\n\tif err != nil {\n\t\tlog.Println(\"cannot listen addr:\" + err.Error())\n\t\treturn\n\t}\n\tif *bUseSSL {\n\t\tconfig := &tls.Config{}\n\t\tconfig.Certificates = make([]tls.Certificate, 1)\n\t\tconfig.Certificates[0], err = tls.LoadX509KeyPair(*certFile, *keyFile)\n\t\tif err != nil {\n\t\t\tlog.Println(\"load key file error\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tg_Master = tls.NewListener(listener, config)\n\t} else {\n\t\tg_Master = listener\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tconn, err := g_Master.Accept()\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgo handleClient(conn)\n\t\t}\n\t}()\n\n\tudpaddr, err := net.ResolveUDPAddr(\"udp\", *listenAddrUDP)\n\tif err != nil {\n\t\tlog.Println(\"Can't resolve address: \", err)\n\t\treturn\n\t}\n\n\tudpconn, err := net.ListenUDP(\"udp\", udpaddr)\n\tif err != nil {\n\t\tlog.Println(\"Error UDP listening:\", err)\n\t\treturn\n\t}\n\n\tlog.Println(\"listenAdd: \", *listenAddrUDP)\n\n\tdefer udpconn.Close()\n\n\tgo udphandleClient(udpconn)\n\tif *db_host != \"\" {\n\t\terr = auth.Init(*db_user, *db_pass, *db_host)\n\t\tif err != nil {\n\t\t\tlog.Println(\"mysql client fail\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tdefer auth.DeInit()\n\t\tbUseDB = true\n\t}\n\tlog.Println(\"master start success\")\n\tif *adminAddr != \"\" {\n\t\tcert, key := \"\", \"\"\n\t\tif *bUseHttps {\n\t\t\tcert, key = *certFile, *keyFile\n\t\t}\n\t\terr := admin.InitAdminPort(*adminAddr, cert, key)\n\t\tif err != nil {\n\t\t\tlog.Println(\"admin service start fail\", err.Error())\n\t\t\treturn\n\t\t}\n\t\tlog.Println(\"admin service start success\")\n\t}\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\t<-c\n\tlog.Println(\"received signal,shutdown\")\n\tshutdown()\n}\n\nfunc shutdown() {\n\tfor conn, client := range common.Conn2ClientInfo {\n\t\tif !client.IsServer {\n\t\t\tlog.Println(\"shutdown client\", client.ServerName)\n\t\t\tcommon.Write(conn, \"0\", \"showandquit\", \"server shutdown\")\n\t\t} else {\n\t\t\tlog.Println(\"unregister service Name\", client.ServerName)\n\t\t\tif bUseDB {\n\t\t\t\tuser, _ := auth.GetUser(client.UserName)\n\t\t\t\tif user != nil {\n\t\t\t\t\tuser.OnLogout()\n\t\t\t\t}\n\t\t\t}\n\t\t\t//donnot showandquit,because client_server need to reconnect\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "start.sh",
          "type": "blob",
          "size": 0.1484375,
          "content": "#!/bin/bash\nnohup ./dtunnel_s -ssl -admin :8009 -dbuser dog -dbpass dog -cert keys/server.crt -key keys/server.key  -https -addr :8008 > log.txt 2>&1 &\n"
        },
        {
          "name": "test.sh",
          "type": "blob",
          "size": 0.451171875,
          "content": "#!/bin/bash\n# first run server,make client,and reg a,then run this bash to test\ndeclare -i i=0\ndeclare -i maxN=30\n\nwhile [ $i -lt $maxN ]\ndo\n\tdeclare -i j=$i+10000\n\t./dtunnel -link a -local :$j -pipen 4 -v > test_$j.log 2>&1 &\n\ti=$i+1\ndone\n#maybe longer\nsleep 5\ndeclare -i n=`grep \"service start success\" test*.log|wc -l`\nif [ $n -eq $maxN ] \nthen\n\techo \"test ok\"\nelse\n\tcat test*.log\nfi\nps aux|grep \"link a\"|grep -v grep|awk '{print $2}'|xargs kill\nrm test*.log\n"
        }
      ]
    }
  ]
}