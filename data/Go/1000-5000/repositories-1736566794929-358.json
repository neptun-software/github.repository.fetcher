{
  "metadata": {
    "timestamp": 1736566794929,
    "page": 358,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cenkalti/backoff",
      "stars": 3524,
      "defaultBranch": "v5",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2607421875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n# IDEs\n.idea/\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.9541015625,
          "content": "# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [5.0.0] - 2024-12-19\n\n### Added\n\n- RetryAfterError can be returned from an operation to indicate how long to wait before the next retry.\n\n### Changed\n\n- Retry function now accepts additional options for specifying max number of tries and max elapsed time.\n- Retry function now accepts a context.Context.\n- Operation function signature changed to return result (any type) and error.\n\n### Removed\n\n- RetryNotify* and RetryWithData functions. Only single Retry function remains.\n- Optional arguments from ExponentialBackoff constructor.\n- Clock and Timer interfaces.\n\n### Fixed\n\n- The original error is returned from Retry if there's a PermanentError. (#144)\n- The Retry function respects the wrapped PermanentError. (#140)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Cenk AltÄ±\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.5087890625,
          "content": "# Exponential Backoff [![GoDoc][godoc image]][godoc]\n\nThis is a Go port of the exponential backoff algorithm from [Google's HTTP Client Library for Java][google-http-java-client].\n\n[Exponential backoff][exponential backoff wiki]\nis an algorithm that uses feedback to multiplicatively decrease the rate of some process,\nin order to gradually find an acceptable rate.\nThe retries exponentially increase and stop increasing when a certain threshold is met.\n\n## Usage\n\nImport path is `github.com/cenkalti/backoff/v5`. Please note the version part at the end.\n\nFor most cases, use `Retry` function. See [example_test.go][example] for an example.\n\nIf you have specific needs, copy `Retry` function (from [retry.go][retry-src]) into your code and modify it as needed.\n\n## Contributing\n\n* I would like to keep this library as small as possible.\n* Please don't send a PR without opening an issue and discussing it first.\n* If proposed change is not a common use case, I will probably not accept it.\n\n[godoc]: https://pkg.go.dev/github.com/cenkalti/backoff/v5\n[godoc image]: https://godoc.org/github.com/cenkalti/backoff?status.png\n\n[google-http-java-client]: https://github.com/google/google-http-java-client/blob/da1aa993e90285ec18579f1553339b00e19b3ab5/google-http-client/src/main/java/com/google/api/client/util/ExponentialBackOff.java\n[exponential backoff wiki]: http://en.wikipedia.org/wiki/Exponential_backoff\n\n[retry-src]: https://github.com/cenkalti/backoff/blob/v5/retry.go\n[example]: https://github.com/cenkalti/backoff/blob/v5/example_test.go\n"
        },
        {
          "name": "backoff.go",
          "type": "blob",
          "size": 2.1083984375,
          "content": "// Package backoff implements backoff algorithms for retrying operations.\n//\n// Use Retry function for retrying operations that may fail.\n// If Retry does not meet your needs,\n// copy/paste the function into your project and modify as you wish.\n//\n// There is also Ticker type similar to time.Ticker.\n// You can use it if you need to work with channels.\n//\n// See Examples section below for usage examples.\npackage backoff\n\nimport \"time\"\n\n// BackOff is a backoff policy for retrying an operation.\ntype BackOff interface {\n\t// NextBackOff returns the duration to wait before retrying the operation,\n\t// backoff.Stop to indicate that no more retries should be made.\n\t//\n\t// Example usage:\n\t//\n\t//     duration := backoff.NextBackOff()\n\t//     if duration == backoff.Stop {\n\t//         // Do not retry operation.\n\t//     } else {\n\t//         // Sleep for duration and retry operation.\n\t//     }\n\t//\n\tNextBackOff() time.Duration\n\n\t// Reset to initial state.\n\tReset()\n}\n\n// Stop indicates that no more retries should be made for use in NextBackOff().\nconst Stop time.Duration = -1\n\n// ZeroBackOff is a fixed backoff policy whose backoff time is always zero,\n// meaning that the operation is retried immediately without waiting, indefinitely.\ntype ZeroBackOff struct{}\n\nfunc (b *ZeroBackOff) Reset() {}\n\nfunc (b *ZeroBackOff) NextBackOff() time.Duration { return 0 }\n\n// StopBackOff is a fixed backoff policy that always returns backoff.Stop for\n// NextBackOff(), meaning that the operation should never be retried.\ntype StopBackOff struct{}\n\nfunc (b *StopBackOff) Reset() {}\n\nfunc (b *StopBackOff) NextBackOff() time.Duration { return Stop }\n\n// ConstantBackOff is a backoff policy that always returns the same backoff delay.\n// This is in contrast to an exponential backoff policy,\n// which returns a delay that grows longer as you call NextBackOff() over and over again.\ntype ConstantBackOff struct {\n\tInterval time.Duration\n}\n\nfunc (b *ConstantBackOff) Reset()                     {}\nfunc (b *ConstantBackOff) NextBackOff() time.Duration { return b.Interval }\n\nfunc NewConstantBackOff(d time.Duration) *ConstantBackOff {\n\treturn &ConstantBackOff{Interval: d}\n}\n"
        },
        {
          "name": "backoff_test.go",
          "type": "blob",
          "size": 0.5869140625,
          "content": "package backoff\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNextBackOffMillis(t *testing.T) {\n\tsubtestNextBackOff(t, 0, new(ZeroBackOff))\n\tsubtestNextBackOff(t, Stop, new(StopBackOff))\n}\n\nfunc subtestNextBackOff(t *testing.T, expectedValue time.Duration, backOffPolicy BackOff) {\n\tfor i := 0; i < 10; i++ {\n\t\tnext := backOffPolicy.NextBackOff()\n\t\tif next != expectedValue {\n\t\t\tt.Errorf(\"got: %d expected: %d\", next, expectedValue)\n\t\t}\n\t}\n}\n\nfunc TestConstantBackOff(t *testing.T) {\n\tbackoff := NewConstantBackOff(time.Second)\n\tif backoff.NextBackOff() != time.Second {\n\t\tt.Error(\"invalid interval\")\n\t}\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.0341796875,
          "content": "package backoff\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// PermanentError signals that the operation should not be retried.\ntype PermanentError struct {\n\tErr error\n}\n\n// Permanent wraps the given err in a *PermanentError.\nfunc Permanent(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\treturn &PermanentError{\n\t\tErr: err,\n\t}\n}\n\n// Error returns a string representation of the Permanent error.\nfunc (e *PermanentError) Error() string {\n\treturn e.Err.Error()\n}\n\n// Unwrap returns the wrapped error.\nfunc (e *PermanentError) Unwrap() error {\n\treturn e.Err\n}\n\n// RetryAfterError signals that the operation should be retried after the given duration.\ntype RetryAfterError struct {\n\tDuration time.Duration\n}\n\n// RetryAfter returns a RetryAfter error that specifies how long to wait before retrying.\nfunc RetryAfter(seconds int) error {\n\treturn &RetryAfterError{Duration: time.Duration(seconds) * time.Second}\n}\n\n// Error returns a string representation of the RetryAfter error.\nfunc (e *RetryAfterError) Error() string {\n\treturn fmt.Sprintf(\"retry after %s\", e.Duration)\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.9755859375,
          "content": "package backoff_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/cenkalti/backoff/v5\"\n)\n\nfunc ExampleRetry() {\n\t// Define an operation function that returns a value and an error.\n\t// The value can be any type.\n\t// We'll pass this operation to Retry function.\n\toperation := func() (string, error) {\n\t\t// An example request that may fail.\n\t\tresp, err := http.Get(\"http://httpbin.org/get\")\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\t// In case on non-retriable error, return Permanent error to stop retrying.\n\t\t// For this HTTP example, client errors are non-retriable.\n\t\tif resp.StatusCode == 400 {\n\t\t\treturn \"\", backoff.Permanent(errors.New(\"bad request\"))\n\t\t}\n\n\t\t// If we are being rate limited, return a RetryAfter to specify how long to wait.\n\t\t// This will also reset the backoff policy.\n\t\tif resp.StatusCode == 429 {\n\t\t\tseconds, err := strconv.ParseInt(resp.Header.Get(\"Retry-After\"), 10, 64)\n\t\t\tif err == nil {\n\t\t\t\treturn \"\", backoff.RetryAfter(int(seconds))\n\t\t\t}\n\t\t}\n\n\t\t// Return successful response.\n\t\treturn \"hello\", nil\n\t}\n\n\tresult, err := backoff.Retry(context.TODO(), operation, backoff.WithBackOff(backoff.NewExponentialBackOff()))\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\t// Operation is successful.\n\n\tfmt.Println(result)\n\t// Output: hello\n}\n\nfunc ExampleTicker() {\n\t// An operation that may fail.\n\toperation := func() (string, error) {\n\t\treturn \"hello\", nil\n\t}\n\n\tticker := backoff.NewTicker(backoff.NewExponentialBackOff())\n\tdefer ticker.Stop()\n\n\tvar result string\n\tvar err error\n\n\t// Ticks will continue to arrive when the previous operation is still running,\n\t// so operations that take a while to fail could run in quick succession.\n\tfor range ticker.C {\n\t\tif result, err = operation(); err != nil {\n\t\t\tlog.Println(err, \"will retry...\")\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n\n\tif err != nil {\n\t\t// Operation has failed.\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\t// Operation is successful.\n\n\tfmt.Println(result)\n\t// Output: hello\n}\n"
        },
        {
          "name": "exponential.go",
          "type": "blob",
          "size": 4.44921875,
          "content": "package backoff\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\n/*\nExponentialBackOff is a backoff implementation that increases the backoff\nperiod for each retry attempt using a randomization function that grows exponentially.\n\nNextBackOff() is calculated using the following formula:\n\n\trandomized interval =\n\t    RetryInterval * (random value in range [1 - RandomizationFactor, 1 + RandomizationFactor])\n\nIn other words NextBackOff() will range between the randomization factor\npercentage below and above the retry interval.\n\nFor example, given the following parameters:\n\n\tRetryInterval = 2\n\tRandomizationFactor = 0.5\n\tMultiplier = 2\n\nthe actual backoff period used in the next retry attempt will range between 1 and 3 seconds,\nmultiplied by the exponential, that is, between 2 and 6 seconds.\n\nNote: MaxInterval caps the RetryInterval and not the randomized interval.\n\nIf the time elapsed since an ExponentialBackOff instance is created goes past the\nMaxElapsedTime, then the method NextBackOff() starts returning backoff.Stop.\n\nThe elapsed time can be reset by calling Reset().\n\nExample: Given the following default arguments, for 10 tries the sequence will be,\nand assuming we go over the MaxElapsedTime on the 10th try:\n\n\tRequest #  RetryInterval (seconds)  Randomized Interval (seconds)\n\n\t 1          0.5                     [0.25,   0.75]\n\t 2          0.75                    [0.375,  1.125]\n\t 3          1.125                   [0.562,  1.687]\n\t 4          1.687                   [0.8435, 2.53]\n\t 5          2.53                    [1.265,  3.795]\n\t 6          3.795                   [1.897,  5.692]\n\t 7          5.692                   [2.846,  8.538]\n\t 8          8.538                   [4.269, 12.807]\n\t 9         12.807                   [6.403, 19.210]\n\t10         19.210                   backoff.Stop\n\nNote: Implementation is not thread-safe.\n*/\ntype ExponentialBackOff struct {\n\tInitialInterval     time.Duration\n\tRandomizationFactor float64\n\tMultiplier          float64\n\tMaxInterval         time.Duration\n\n\tcurrentInterval time.Duration\n}\n\n// Default values for ExponentialBackOff.\nconst (\n\tDefaultInitialInterval     = 500 * time.Millisecond\n\tDefaultRandomizationFactor = 0.5\n\tDefaultMultiplier          = 1.5\n\tDefaultMaxInterval         = 60 * time.Second\n)\n\n// NewExponentialBackOff creates an instance of ExponentialBackOff using default values.\nfunc NewExponentialBackOff() *ExponentialBackOff {\n\treturn &ExponentialBackOff{\n\t\tInitialInterval:     DefaultInitialInterval,\n\t\tRandomizationFactor: DefaultRandomizationFactor,\n\t\tMultiplier:          DefaultMultiplier,\n\t\tMaxInterval:         DefaultMaxInterval,\n\t}\n}\n\n// Reset the interval back to the initial retry interval and restarts the timer.\n// Reset must be called before using b.\nfunc (b *ExponentialBackOff) Reset() {\n\tb.currentInterval = b.InitialInterval\n}\n\n// NextBackOff calculates the next backoff interval using the formula:\n//\n//\tRandomized interval = RetryInterval * (1 Â± RandomizationFactor)\nfunc (b *ExponentialBackOff) NextBackOff() time.Duration {\n\tif b.currentInterval == 0 {\n\t\tb.currentInterval = b.InitialInterval\n\t}\n\n\tnext := getRandomValueFromInterval(b.RandomizationFactor, rand.Float64(), b.currentInterval)\n\tb.incrementCurrentInterval()\n\treturn next\n}\n\n// Increments the current interval by multiplying it with the multiplier.\nfunc (b *ExponentialBackOff) incrementCurrentInterval() {\n\t// Check for overflow, if overflow is detected set the current interval to the max interval.\n\tif float64(b.currentInterval) >= float64(b.MaxInterval)/b.Multiplier {\n\t\tb.currentInterval = b.MaxInterval\n\t} else {\n\t\tb.currentInterval = time.Duration(float64(b.currentInterval) * b.Multiplier)\n\t}\n}\n\n// Returns a random value from the following interval:\n//\n//\t[currentInterval - randomizationFactor * currentInterval, currentInterval + randomizationFactor * currentInterval].\nfunc getRandomValueFromInterval(randomizationFactor, random float64, currentInterval time.Duration) time.Duration {\n\tif randomizationFactor == 0 {\n\t\treturn currentInterval // make sure no randomness is used when randomizationFactor is 0.\n\t}\n\tvar delta = randomizationFactor * float64(currentInterval)\n\tvar minInterval = float64(currentInterval) - delta\n\tvar maxInterval = float64(currentInterval) + delta\n\n\t// Get a random value from the range [minInterval, maxInterval].\n\t// The formula used below has a +1 because if the minInterval is 1 and the maxInterval is 3 then\n\t// we want a 33% chance for selecting either 1, 2 or 3.\n\treturn time.Duration(minInterval + (random * (maxInterval - minInterval + 1)))\n}\n"
        },
        {
          "name": "exponential_test.go",
          "type": "blob",
          "size": 2.27734375,
          "content": "package backoff\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestBackOff(t *testing.T) {\n\tvar (\n\t\ttestInitialInterval     = 500 * time.Millisecond\n\t\ttestRandomizationFactor = 0.1\n\t\ttestMultiplier          = 2.0\n\t\ttestMaxInterval         = 5 * time.Second\n\t)\n\n\texp := NewExponentialBackOff()\n\texp.InitialInterval = testInitialInterval\n\texp.RandomizationFactor = testRandomizationFactor\n\texp.Multiplier = testMultiplier\n\texp.MaxInterval = testMaxInterval\n\texp.Reset()\n\n\tvar expectedResults = []time.Duration{500, 1000, 2000, 4000, 5000, 5000, 5000, 5000, 5000, 5000}\n\tfor i, d := range expectedResults {\n\t\texpectedResults[i] = d * time.Millisecond\n\t}\n\n\tfor _, expected := range expectedResults {\n\t\tassertEquals(t, expected, exp.currentInterval)\n\t\t// Assert that the next backoff falls in the expected range.\n\t\tvar minInterval = expected - time.Duration(testRandomizationFactor*float64(expected))\n\t\tvar maxInterval = expected + time.Duration(testRandomizationFactor*float64(expected))\n\t\tvar actualInterval = exp.NextBackOff()\n\t\tif !(minInterval <= actualInterval && actualInterval <= maxInterval) {\n\t\t\tt.Error(\"error\")\n\t\t}\n\t}\n}\n\nfunc TestGetRandomizedInterval(t *testing.T) {\n\t// 33% chance of being 1.\n\tassertEquals(t, 1, getRandomValueFromInterval(0.5, 0, 2))\n\tassertEquals(t, 1, getRandomValueFromInterval(0.5, 0.33, 2))\n\t// 33% chance of being 2.\n\tassertEquals(t, 2, getRandomValueFromInterval(0.5, 0.34, 2))\n\tassertEquals(t, 2, getRandomValueFromInterval(0.5, 0.66, 2))\n\t// 33% chance of being 3.\n\tassertEquals(t, 3, getRandomValueFromInterval(0.5, 0.67, 2))\n\tassertEquals(t, 3, getRandomValueFromInterval(0.5, 0.99, 2))\n}\n\nfunc TestBackOffOverflow(t *testing.T) {\n\tvar (\n\t\ttestInitialInterval time.Duration = math.MaxInt64 / 2\n\t\ttestMaxInterval     time.Duration = math.MaxInt64\n\t\ttestMultiplier                    = 2.1\n\t)\n\n\texp := NewExponentialBackOff()\n\texp.InitialInterval = testInitialInterval\n\texp.Multiplier = testMultiplier\n\texp.MaxInterval = testMaxInterval\n\texp.Reset()\n\n\texp.NextBackOff()\n\t// Assert that when an overflow is possible, the current interval time.Duration is set to the max interval time.Duration.\n\tassertEquals(t, testMaxInterval, exp.currentInterval)\n}\n\nfunc assertEquals(t *testing.T, expected, value time.Duration) {\n\tif expected != value {\n\t\tt.Errorf(\"got: %d, expected: %d\", value, expected)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0458984375,
          "content": "module github.com/cenkalti/backoff/v5\n\ngo 1.23\n"
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 3.5888671875,
          "content": "package backoff\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n)\n\n// DefaultMaxElapsedTime sets a default limit for the total retry duration.\nconst DefaultMaxElapsedTime = 15 * time.Minute\n\n// Operation is a function that attempts an operation and may be retried.\ntype Operation[T any] func() (T, error)\n\n// Notify is a function called on operation error with the error and backoff duration.\ntype Notify func(error, time.Duration)\n\n// retryOptions holds configuration settings for the retry mechanism.\ntype retryOptions struct {\n\tBackOff        BackOff       // Strategy for calculating backoff periods.\n\tTimer          timer         // Timer to manage retry delays.\n\tNotify         Notify        // Optional function to notify on each retry error.\n\tMaxTries       uint          // Maximum number of retry attempts.\n\tMaxElapsedTime time.Duration // Maximum total time for all retries.\n}\n\ntype RetryOption func(*retryOptions)\n\n// WithBackOff configures a custom backoff strategy.\nfunc WithBackOff(b BackOff) RetryOption {\n\treturn func(args *retryOptions) {\n\t\targs.BackOff = b\n\t}\n}\n\n// withTimer sets a custom timer for managing delays between retries.\nfunc withTimer(t timer) RetryOption {\n\treturn func(args *retryOptions) {\n\t\targs.Timer = t\n\t}\n}\n\n// WithNotify sets a notification function to handle retry errors.\nfunc WithNotify(n Notify) RetryOption {\n\treturn func(args *retryOptions) {\n\t\targs.Notify = n\n\t}\n}\n\n// WithMaxTries limits the number of retry attempts.\nfunc WithMaxTries(n uint) RetryOption {\n\treturn func(args *retryOptions) {\n\t\targs.MaxTries = n\n\t}\n}\n\n// WithMaxElapsedTime limits the total duration for retry attempts.\nfunc WithMaxElapsedTime(d time.Duration) RetryOption {\n\treturn func(args *retryOptions) {\n\t\targs.MaxElapsedTime = d\n\t}\n}\n\n// Retry attempts the operation until success, a permanent error, or backoff completion.\n// It ensures the operation is executed at least once.\n//\n// Returns the operation result or error if retries are exhausted or context is cancelled.\nfunc Retry[T any](ctx context.Context, operation Operation[T], opts ...RetryOption) (T, error) {\n\t// Initialize default retry options.\n\targs := &retryOptions{\n\t\tBackOff:        NewExponentialBackOff(),\n\t\tTimer:          &defaultTimer{},\n\t\tMaxElapsedTime: DefaultMaxElapsedTime,\n\t}\n\n\t// Apply user-provided options to the default settings.\n\tfor _, opt := range opts {\n\t\topt(args)\n\t}\n\n\tdefer args.Timer.Stop()\n\n\tstartedAt := time.Now()\n\targs.BackOff.Reset()\n\tfor numTries := uint(1); ; numTries++ {\n\t\t// Execute the operation.\n\t\tres, err := operation()\n\t\tif err == nil {\n\t\t\treturn res, nil\n\t\t}\n\n\t\t// Stop retrying if maximum tries exceeded.\n\t\tif args.MaxTries > 0 && numTries >= args.MaxTries {\n\t\t\treturn res, err\n\t\t}\n\n\t\t// Handle permanent errors without retrying.\n\t\tvar permanent *PermanentError\n\t\tif errors.As(err, &permanent) {\n\t\t\treturn res, err\n\t\t}\n\n\t\t// Stop retrying if context is cancelled.\n\t\tif cerr := ctx.Err(); cerr != nil {\n\t\t\treturn res, cerr\n\t\t}\n\n\t\t// Calculate next backoff duration.\n\t\tnext := args.BackOff.NextBackOff()\n\t\tif next == Stop {\n\t\t\treturn res, err\n\t\t}\n\n\t\t// Reset backoff if RetryAfterError is encountered.\n\t\tvar retryAfter *RetryAfterError\n\t\tif errors.As(err, &retryAfter) {\n\t\t\tnext = retryAfter.Duration\n\t\t\targs.BackOff.Reset()\n\t\t}\n\n\t\t// Stop retrying if maximum elapsed time exceeded.\n\t\tif time.Since(startedAt)+next > args.MaxElapsedTime {\n\t\t\treturn res, err\n\t\t}\n\n\t\t// Notify on error if a notifier function is provided.\n\t\tif args.Notify != nil {\n\t\t\targs.Notify(err, next)\n\t\t}\n\n\t\t// Wait for the next backoff period or context cancellation.\n\t\targs.Timer.Start(next)\n\t\tselect {\n\t\tcase <-args.Timer.C():\n\t\tcase <-ctx.Done():\n\t\t\treturn res, ctx.Err()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "retry_test.go",
          "type": "blob",
          "size": 4.4052734375,
          "content": "package backoff\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype testTimer struct {\n\ttimer *time.Timer\n}\n\nfunc (t *testTimer) Start(duration time.Duration) {\n\tt.timer = time.NewTimer(0)\n}\n\nfunc (t *testTimer) Stop() {\n\tif t.timer != nil {\n\t\tt.timer.Stop()\n\t}\n}\n\nfunc (t *testTimer) C() <-chan time.Time {\n\treturn t.timer.C\n}\n\nfunc TestRetry(t *testing.T) {\n\tconst successOn = 3\n\tvar i = 0\n\n\t// This function is successful on \"successOn\" calls.\n\tf := func() (bool, error) {\n\t\ti++\n\t\tlog.Printf(\"function is called %d. time\\n\", i)\n\n\t\tif i == successOn {\n\t\t\tlog.Println(\"OK\")\n\t\t\treturn true, nil\n\t\t}\n\n\t\tlog.Println(\"error\")\n\t\treturn false, errors.New(\"error\")\n\t}\n\n\t_, err := Retry(context.Background(), f, WithBackOff(NewExponentialBackOff()), withTimer(&testTimer{}))\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err.Error())\n\t}\n\tif i != successOn {\n\t\tt.Errorf(\"invalid number of retries: %d\", i)\n\t}\n}\n\nfunc TestRetryWithData(t *testing.T) {\n\tconst successOn = 3\n\tvar i = 0\n\n\t// This function is successful on \"successOn\" calls.\n\tf := func() (int, error) {\n\t\ti++\n\t\tlog.Printf(\"function is called %d. time\\n\", i)\n\n\t\tif i == successOn {\n\t\t\tlog.Println(\"OK\")\n\t\t\treturn 42, nil\n\t\t}\n\n\t\tlog.Println(\"error\")\n\t\treturn 1, errors.New(\"error\")\n\t}\n\n\tres, err := Retry(context.Background(), f, WithBackOff(NewExponentialBackOff()), withTimer(&testTimer{}))\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err.Error())\n\t}\n\tif i != successOn {\n\t\tt.Errorf(\"invalid number of retries: %d\", i)\n\t}\n\tif res != 42 {\n\t\tt.Errorf(\"invalid data in response: %d, expected 42\", res)\n\t}\n}\n\nfunc TestRetryContext(t *testing.T) {\n\tvar cancelOn = 3\n\tvar i = 0\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// This function cancels context on \"cancelOn\" calls.\n\tf := func() (bool, error) {\n\t\ti++\n\t\tlog.Printf(\"function is called %d. time\\n\", i)\n\n\t\t// cancelling the context in the operation function is not a typical\n\t\t// use-case, however it allows to get predictable test results.\n\t\tif i == cancelOn {\n\t\t\tcancel()\n\t\t}\n\n\t\tlog.Println(\"error\")\n\t\treturn false, fmt.Errorf(\"error (%d)\", i)\n\t}\n\n\t_, err := Retry(ctx, f, WithBackOff(NewConstantBackOff(time.Millisecond)), withTimer(&testTimer{}))\n\tif err == nil {\n\t\tt.Errorf(\"error is unexpectedly nil\")\n\t}\n\tif !errors.Is(err, context.Canceled) {\n\t\tt.Errorf(\"unexpected error: %s\", err.Error())\n\t}\n\tif i != cancelOn {\n\t\tt.Errorf(\"invalid number of retries: %d\", i)\n\t}\n}\n\nfunc TestRetryPermanent(t *testing.T) {\n\tensureRetries := func(test string, shouldRetry bool, f func() (int, error), expectRes int) {\n\t\tnumRetries := -1\n\t\tmaxRetries := 1\n\n\t\tres, _ := Retry(\n\t\t\tcontext.Background(),\n\t\t\tfunc() (int, error) {\n\t\t\t\tnumRetries++\n\t\t\t\tif numRetries >= maxRetries {\n\t\t\t\t\treturn -1, Permanent(errors.New(\"forced\"))\n\t\t\t\t}\n\t\t\t\treturn f()\n\t\t\t},\n\t\t\tWithBackOff(NewExponentialBackOff()),\n\t\t\twithTimer(&testTimer{}),\n\t\t)\n\n\t\tif shouldRetry && numRetries == 0 {\n\t\t\tt.Errorf(\"Test: '%s', backoff should have retried\", test)\n\t\t}\n\n\t\tif !shouldRetry && numRetries > 0 {\n\t\t\tt.Errorf(\"Test: '%s', backoff should not have retried\", test)\n\t\t}\n\n\t\tif res != expectRes {\n\t\t\tt.Errorf(\"Test: '%s', got res %d but expected %d\", test, res, expectRes)\n\t\t}\n\t}\n\n\tfor _, testCase := range []struct {\n\t\tname        string\n\t\tf           func() (int, error)\n\t\tshouldRetry bool\n\t\tres         int\n\t}{\n\t\t{\n\t\t\t\"nil test\",\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 1, nil\n\t\t\t},\n\t\t\tfalse,\n\t\t\t1,\n\t\t},\n\t\t{\n\t\t\t\"io.EOF\",\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 2, io.EOF\n\t\t\t},\n\t\t\ttrue,\n\t\t\t-1,\n\t\t},\n\t\t{\n\t\t\t\"Permanent(io.EOF)\",\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 3, Permanent(io.EOF)\n\t\t\t},\n\t\t\tfalse,\n\t\t\t3,\n\t\t},\n\t\t{\n\t\t\t\"Wrapped: Permanent(io.EOF)\",\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 4, fmt.Errorf(\"Wrapped error: %w\", Permanent(io.EOF))\n\t\t\t},\n\t\t\tfalse,\n\t\t\t4,\n\t\t},\n\t} {\n\t\tensureRetries(testCase.name, testCase.shouldRetry, testCase.f, testCase.res)\n\t}\n}\n\nfunc TestPermanent(t *testing.T) {\n\twant := errors.New(\"foo\")\n\tother := errors.New(\"bar\")\n\tvar err error = Permanent(want)\n\n\tgot := errors.Unwrap(err)\n\tif got != want {\n\t\tt.Errorf(\"got %v, want %v\", got, want)\n\t}\n\n\tif is := errors.Is(err, want); !is {\n\t\tt.Errorf(\"err: %v is not %v\", err, want)\n\t}\n\n\tif is := errors.Is(err, other); is {\n\t\tt.Errorf(\"err: %v is %v\", err, other)\n\t}\n\n\twrapped := fmt.Errorf(\"wrapped: %w\", err)\n\tvar permanent *PermanentError\n\tif !errors.As(wrapped, &permanent) {\n\t\tt.Errorf(\"errors.As(%v, %v)\", wrapped, permanent)\n\t}\n\n\terr = Permanent(nil)\n\tif err != nil {\n\t\tt.Errorf(\"got %v, want nil\", err)\n\t}\n}\n"
        },
        {
          "name": "ticker.go",
          "type": "blob",
          "size": 1.7060546875,
          "content": "package backoff\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// Ticker holds a channel that delivers `ticks' of a clock at times reported by a BackOff.\n//\n// Ticks will continue to arrive when the previous operation is still running,\n// so operations that take a while to fail could run in quick succession.\ntype Ticker struct {\n\tC        <-chan time.Time\n\tc        chan time.Time\n\tb        BackOff\n\ttimer    timer\n\tstop     chan struct{}\n\tstopOnce sync.Once\n}\n\n// NewTicker returns a new Ticker containing a channel that will send\n// the time at times specified by the BackOff argument. Ticker is\n// guaranteed to tick at least once.  The channel is closed when Stop\n// method is called or BackOff stops. It is not safe to manipulate the\n// provided backoff policy (notably calling NextBackOff or Reset)\n// while the ticker is running.\nfunc NewTicker(b BackOff) *Ticker {\n\tc := make(chan time.Time)\n\tt := &Ticker{\n\t\tC:     c,\n\t\tc:     c,\n\t\tb:     b,\n\t\ttimer: &defaultTimer{},\n\t\tstop:  make(chan struct{}),\n\t}\n\tt.b.Reset()\n\tgo t.run()\n\treturn t\n}\n\n// Stop turns off a ticker. After Stop, no more ticks will be sent.\nfunc (t *Ticker) Stop() {\n\tt.stopOnce.Do(func() { close(t.stop) })\n}\n\nfunc (t *Ticker) run() {\n\tc := t.c\n\tdefer close(c)\n\n\t// Ticker is guaranteed to tick at least once.\n\tafterC := t.send(time.Now())\n\n\tfor {\n\t\tif afterC == nil {\n\t\t\treturn\n\t\t}\n\n\t\tselect {\n\t\tcase tick := <-afterC:\n\t\t\tafterC = t.send(tick)\n\t\tcase <-t.stop:\n\t\t\tt.c = nil // Prevent future ticks from being sent to the channel.\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (t *Ticker) send(tick time.Time) <-chan time.Time {\n\tselect {\n\tcase t.c <- tick:\n\tcase <-t.stop:\n\t\treturn nil\n\t}\n\n\tnext := t.b.NextBackOff()\n\tif next == Stop {\n\t\tt.Stop()\n\t\treturn nil\n\t}\n\n\tt.timer.Start(next)\n\treturn t.timer.C()\n}\n"
        },
        {
          "name": "ticker_test.go",
          "type": "blob",
          "size": 0.6875,
          "content": "package backoff\n\nimport (\n\t\"errors\"\n\t\"log\"\n\t\"testing\"\n)\n\nfunc TestTicker(t *testing.T) {\n\tconst successOn = 3\n\tvar i = 0\n\n\t// This function is successful on \"successOn\" calls.\n\tf := func() error {\n\t\ti++\n\t\tlog.Printf(\"function is called %d. time\\n\", i)\n\n\t\tif i == successOn {\n\t\t\tlog.Println(\"OK\")\n\t\t\treturn nil\n\t\t}\n\n\t\tlog.Println(\"error\")\n\t\treturn errors.New(\"error\")\n\t}\n\n\tb := NewExponentialBackOff()\n\tticker := NewTicker(b)\n\tticker.timer = &testTimer{}\n\n\tvar err error\n\tfor range ticker.C {\n\t\tif err = f(); err != nil {\n\t\t\tt.Log(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %s\", err.Error())\n\t}\n\tif i != successOn {\n\t\tt.Errorf(\"invalid number of retries: %d\", i)\n\t}\n}\n"
        },
        {
          "name": "timer.go",
          "type": "blob",
          "size": 0.732421875,
          "content": "package backoff\n\nimport \"time\"\n\ntype timer interface {\n\tStart(duration time.Duration)\n\tStop()\n\tC() <-chan time.Time\n}\n\n// defaultTimer implements Timer interface using time.Timer\ntype defaultTimer struct {\n\ttimer *time.Timer\n}\n\n// C returns the timers channel which receives the current time when the timer fires.\nfunc (t *defaultTimer) C() <-chan time.Time {\n\treturn t.timer.C\n}\n\n// Start starts the timer to fire after the given duration\nfunc (t *defaultTimer) Start(duration time.Duration) {\n\tif t.timer == nil {\n\t\tt.timer = time.NewTimer(duration)\n\t} else {\n\t\tt.timer.Reset(duration)\n\t}\n}\n\n// Stop is called when the timer is not used anymore and resources may be freed.\nfunc (t *defaultTimer) Stop() {\n\tif t.timer != nil {\n\t\tt.timer.Stop()\n\t}\n}\n"
        },
        {
          "name": "tries_test.go",
          "type": "blob",
          "size": 1.255859375,
          "content": "//go:build ignore\n\npackage backoff\n\nimport (\n\t\"errors\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMaxTriesHappy(t *testing.T) {\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\tmax := 17 + r.Intn(13)\n\tbo := WithMaxRetries(&ZeroBackOff{}, uint64(max))\n\n\t// Load up the tries count, but reset should clear the record\n\tfor ix := 0; ix < max/2; ix++ {\n\t\tbo.NextBackOff()\n\t}\n\tbo.Reset()\n\n\t// Now fill the tries count all the way up\n\tfor ix := 0; ix < max; ix++ {\n\t\td := bo.NextBackOff()\n\t\tif d == Stop {\n\t\t\tt.Errorf(\"returned Stop on try %d\", ix)\n\t\t}\n\t}\n\n\t// We have now called the BackOff max number of times, we expect\n\t// the next result to be Stop, even if we try it multiple times\n\tfor ix := 0; ix < 7; ix++ {\n\t\td := bo.NextBackOff()\n\t\tif d != Stop {\n\t\t\tt.Error(\"invalid next back off\")\n\t\t}\n\t}\n\n\t// Reset makes it all work again\n\tbo.Reset()\n\td := bo.NextBackOff()\n\tif d == Stop {\n\t\tt.Error(\"returned Stop after reset\")\n\t}\n}\n\n// https://github.com/cenkalti/backoff/issues/80\nfunc TestMaxTriesZero(t *testing.T) {\n\tvar called int\n\n\tb := WithMaxRetries(&ZeroBackOff{}, 0)\n\n\terr := Retry(func() error {\n\t\tcalled++\n\t\treturn errors.New(\"err\")\n\t}, b)\n\n\tif err == nil {\n\t\tt.Errorf(\"error expected, nil found\")\n\t}\n\tif called != 1 {\n\t\tt.Errorf(\"operation is called %d times\", called)\n\t}\n}\n"
        }
      ]
    }
  ]
}