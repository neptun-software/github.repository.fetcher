{
  "metadata": {
    "timestamp": 1736566764053,
    "page": 318,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "zenazn/goji",
      "stars": 3642,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3056640625,
          "content": "language: go\n\ngo:\n    - \"1.5.x\"\n    - \"1.6.x\"\n    - \"1.7.x\"\n    - \"1.8.x\"\n    - \"1.9.x\"\n    - \"1.10.x\"\n    - \"1.11.x\"\n\ninstall:\n    - go list -f '{{range .Imports}}{{.}} {{end}}' ./... | xargs go get -v\n    - go list -f '{{range .TestImports}}{{.}} {{end}}' ./... | xargs go get -v\n\nscript: go test -cover ./...\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.072265625,
          "content": "Copyright (c) 2014, 2015, 2016 Carl Jackson (carl@avtok.com)\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.8154296875,
          "content": "Goji\n====\n\n[![GoDoc](https://godoc.org/github.com/zenazn/goji/web?status.svg)](https://godoc.org/github.com/zenazn/goji/web) [![Build Status](https://travis-ci.org/zenazn/goji.svg?branch=master)](https://travis-ci.org/zenazn/goji)\n\nGoji is a minimalistic web framework that values composability and simplicity.\n\nThis project has been superseded by a [new version of Goji][goji2] by the same\nauthor, which has very similar primitives and semantics, but has been updated to\nreflect several years of experience with this library and the surrounding Go\necosystem. This project is still well-loved and well-maintained, and will be for\nthe foreseeable future, but new projects are encouraged to use `goji.io`\ninstead.\n\n[goji2]: https://goji.io\n\nExample\n-------\n\n```go\npackage main\n\nimport (\n        \"fmt\"\n        \"net/http\"\n\n        \"github.com/zenazn/goji\"\n        \"github.com/zenazn/goji/web\"\n)\n\nfunc hello(c web.C, w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintf(w, \"Hello, %s!\", c.URLParams[\"name\"])\n}\n\nfunc main() {\n        goji.Get(\"/hello/:name\", hello)\n        goji.Serve()\n}\n```\n\nGoji also includes a [sample application][sample] in the `example` folder which\nwas artificially constructed to show off all of Goji's features. Check it out!\n\n[sample]: https://github.com/zenazn/goji/tree/master/example\n\n\nFeatures\n--------\n\n* Compatible with `net/http`\n* URL patterns (both Sinatra style `/foo/:bar` patterns and regular expressions,\n  as well as [custom patterns][pattern])\n* Reconfigurable middleware stack\n* Context/environment object threaded through middleware and handlers\n* Automatic support for [Einhorn][einhorn], systemd, and [more][bind]\n* [Graceful shutdown][graceful], and zero-downtime graceful reload when combined\n  with Einhorn.\n* High in antioxidants\n\n[einhorn]: https://github.com/stripe/einhorn\n[bind]: http://godoc.org/github.com/zenazn/goji/bind\n[graceful]: http://godoc.org/github.com/zenazn/goji/graceful\n[pattern]: https://godoc.org/github.com/zenazn/goji/web#Pattern\n\n\nStability\n---------\n\nGoji's API is essentially frozen, and guarantees to never break compatibility\nwith existing code (under similar rules to the Go project's\n[guidelines][compat]). Goji is suitable for use in production, and has served\nbillions of requests across several companies.\n\n[compat]: https://golang.org/doc/go1compat\n\n\nIs it any good?\n---------------\n\nMaybe!\n\nThere are [plenty][revel] of [other][gorilla] [good][pat] [Go][martini]\n[web][gocraft] [frameworks][tiger] out there. Goji is by no means especially\nnovel, nor is it uniquely good. The primary difference between Goji and other\nframeworks—and the primary reason I think Goji is any good—is its philosophy:\n\nGoji first of all attempts to be simple. It is of the Sinatra and Flask school\nof web framework design, and not the Rails/Django one. If you want me to tell\nyou what directory you should put your models in, or if you want built-in flash\nsessions, you won't have a good time with Goji.\n\nSecondly, Goji attempts to be composable. It is fully composable with net/http,\nand can be used as a `http.Handler`, or can serve arbitrary `http.Handler`s. At\nleast a few HTTP frameworks share this property, and is not particularly novel.\nThe more interesting property in my mind is that Goji is fully composable with\nitself: it defines an interface (`web.Handler`) which is both fully compatible\nwith `http.Handler` and allows Goji to perform a \"protocol upgrade\" of sorts\nwhen it detects that it is talking to itself (or another `web.Handler`\ncompatible component). `web.Handler` is at the core of Goji's interfaces and is\nwhat allows it to share request contexts across unrelated objects.\n\nThird, Goji is not magic. One of my favorite existing frameworks is\n[Martini][martini], but I rejected it in favor of building Goji because I\nthought it was too magical. Goji's web package does not use reflection at all,\nwhich is not in itself a sign of API quality, but to me at least seems to\nsuggest it.\n\nFinally, Goji gives you enough rope to hang yourself with. One of my other\nfavorite libraries, [pat][pat], implements Sinatra-like routing in a\nparticularly elegant way, but because of its reliance on net/http's interfaces,\ndoesn't allow programmers to thread their own state through the request handling\nprocess. Implementing arbitrary context objects was one of the primary\nmotivations behind abandoning pat to write Goji.\n\n[revel]: http://revel.github.io/\n[gorilla]: http://www.gorillatoolkit.org/\n[pat]: https://github.com/bmizerany/pat\n[martini]: http://martini.codegangsta.io/\n[gocraft]: https://github.com/gocraft/web\n[tiger]: https://github.com/rcrowley/go-tigertonic\n\n\nIs it fast?\n-----------\n\n[Yeah][bench1], [it is][bench2]. Goji is among the fastest HTTP routers out\nthere, and is very gentle on the garbage collector.\n\nBut that's sort of missing the point. Almost all Go routers are fast enough for\nalmost all purposes. In my opinion, what matters more is how simple and flexible\nthe routing semantics are.\n\nGoji provides results indistinguishable from naively trying routes one after\nanother. This means that a route added before another route will be attempted\nbefore that route as well. This is perhaps the most simple and most intuitive\ninterface a router can provide, and makes routes very easy to understand and\ndebug.\n\nGoji's router is also very flexible: in addition to the standard Sinatra-style\npatterns and regular expression patterns, you can define [custom\npatterns][pattern] to perform whatever custom matching logic you desire. Custom\npatterns of course are fully compatible with the routing semantics above.\n\nIt's easy (and quite a bit of fun!) to get carried away by microbenchmarks, but\nat the end of the day you're not going to miss those extra hundred nanoseconds\non a request. What matters is that you aren't compromising on the API for a\nhandful of CPU cycles.\n\n[bench1]: https://gist.github.com/zenazn/c5c8528efe1a00634096\n[bench2]: https://github.com/julienschmidt/go-http-routing-benchmark\n\n\nThird-Party Libraries\n---------------------\n\nGoji is already compatible with a great many third-party libraries that are\nthemselves compatible with `net/http`, however some library authors have gone\nout of their way to include Goji compatibility specifically, perhaps by\nintegrating more tightly with Goji's `web.C` or by providing a custom pattern\ntype. An informal list of such libraries is maintained [on the wiki][third];\nfeel free to add to it as you see fit.\n\n[third]: https://github.com/zenazn/goji/wiki/Third-Party-Libraries\n\n\nContributing\n------------\n\nPlease do! I love pull requests, and I love pull requests that include tests\neven more. Goji's core packages have pretty good code coverage (yay code\ncoverage gamification!), and if you have the time to write tests I'd like to\nkeep it that way.\n\nIn addition to contributing code, I'd love to know what you think about Goji.\nPlease open an issue or send me an email with your thoughts; it'd mean a lot to\nme.\n"
        },
        {
          "name": "bind",
          "type": "tree",
          "content": null
        },
        {
          "name": "default.go",
          "type": "blob",
          "size": 3.62890625,
          "content": "package goji\n\nimport (\n\t\"github.com/zenazn/goji/web\"\n\t\"github.com/zenazn/goji/web/middleware\"\n)\n\n// The default web.Mux.\nvar DefaultMux *web.Mux\n\nfunc init() {\n\tDefaultMux = web.New()\n\n\tDefaultMux.Use(middleware.RequestID)\n\tDefaultMux.Use(middleware.Logger)\n\tDefaultMux.Use(middleware.Recoverer)\n\tDefaultMux.Use(middleware.AutomaticOptions)\n}\n\n// Use appends the given middleware to the default Mux's middleware stack. See\n// the documentation for web.Mux.Use for more information.\nfunc Use(middleware web.MiddlewareType) {\n\tDefaultMux.Use(middleware)\n}\n\n// Insert the given middleware into the default Mux's middleware stack. See the\n// documentation for web.Mux.Insert for more information.\nfunc Insert(middleware, before web.MiddlewareType) error {\n\treturn DefaultMux.Insert(middleware, before)\n}\n\n// Abandon removes the given middleware from the default Mux's middleware stack.\n// See the documentation for web.Mux.Abandon for more information.\nfunc Abandon(middleware web.MiddlewareType) error {\n\treturn DefaultMux.Abandon(middleware)\n}\n\n// Handle adds a route to the default Mux. See the documentation for web.Mux for\n// more information about what types this function accepts.\nfunc Handle(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Handle(pattern, handler)\n}\n\n// Connect adds a CONNECT route to the default Mux. See the documentation for\n// web.Mux for more information about what types this function accepts.\nfunc Connect(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Connect(pattern, handler)\n}\n\n// Delete adds a DELETE route to the default Mux. See the documentation for\n// web.Mux for more information about what types this function accepts.\nfunc Delete(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Delete(pattern, handler)\n}\n\n// Get adds a GET route to the default Mux. See the documentation for web.Mux for\n// more information about what types this function accepts.\nfunc Get(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Get(pattern, handler)\n}\n\n// Head adds a HEAD route to the default Mux. See the documentation for web.Mux\n// for more information about what types this function accepts.\nfunc Head(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Head(pattern, handler)\n}\n\n// Options adds a OPTIONS route to the default Mux. See the documentation for\n// web.Mux for more information about what types this function accepts.\nfunc Options(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Options(pattern, handler)\n}\n\n// Patch adds a PATCH route to the default Mux. See the documentation for web.Mux\n// for more information about what types this function accepts.\nfunc Patch(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Patch(pattern, handler)\n}\n\n// Post adds a POST route to the default Mux. See the documentation for web.Mux\n// for more information about what types this function accepts.\nfunc Post(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Post(pattern, handler)\n}\n\n// Put adds a PUT route to the default Mux. See the documentation for web.Mux for\n// more information about what types this function accepts.\nfunc Put(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Put(pattern, handler)\n}\n\n// Trace adds a TRACE route to the default Mux. See the documentation for\n// web.Mux for more information about what types this function accepts.\nfunc Trace(pattern web.PatternType, handler web.HandlerType) {\n\tDefaultMux.Trace(pattern, handler)\n}\n\n// NotFound sets the NotFound handler for the default Mux. See the documentation\n// for web.Mux.NotFound for more information.\nfunc NotFound(handler web.HandlerType) {\n\tDefaultMux.NotFound(handler)\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "goji.go",
          "type": "blob",
          "size": 0.978515625,
          "content": "/*\nPackage goji provides an out-of-box web server with reasonable defaults.\n\nExample:\n\tpackage main\n\n\timport (\n\t\t\"fmt\"\n\t\t\"net/http\"\n\n\t\t\"github.com/zenazn/goji\"\n\t\t\"github.com/zenazn/goji/web\"\n\t)\n\n\tfunc hello(c web.C, w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, %s!\", c.URLParams[\"name\"])\n\t}\n\n\tfunc main() {\n\t\tgoji.Get(\"/hello/:name\", hello)\n\t\tgoji.Serve()\n\t}\n\nThis package exists purely as a convenience to programmers who want to get\nstarted as quickly as possible. It draws almost all of its code from goji's\nsubpackages, the most interesting of which is goji/web, and where most of the\ndocumentation for the web framework lives.\n\nA side effect of this package's ease-of-use is the fact that it is opinionated.\nIf you don't like (or have outgrown) its opinions, it should be straightforward\nto use the APIs of goji's subpackages to reimplement things to your liking. Both\nmethods of using this library are equally well supported.\n\nGoji requires Go 1.2 or newer.\n*/\npackage goji\n"
        },
        {
          "name": "graceful",
          "type": "tree",
          "content": null
        },
        {
          "name": "serve.go",
          "type": "blob",
          "size": 1.2861328125,
          "content": "// +build !appengine\n\npackage goji\n\nimport (\n\t\"crypto/tls\"\n\t\"flag\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/zenazn/goji/bind\"\n\t\"github.com/zenazn/goji/graceful\"\n)\n\nfunc init() {\n\tbind.WithFlag()\n\tif fl := log.Flags(); fl&log.Ltime != 0 {\n\t\tlog.SetFlags(fl | log.Lmicroseconds)\n\t}\n\tgraceful.DoubleKickWindow(2 * time.Second)\n}\n\n// Serve starts Goji using reasonable defaults.\nfunc Serve() {\n\tif !flag.Parsed() {\n\t\tflag.Parse()\n\t}\n\n\tServeListener(bind.Default())\n}\n\n// Like Serve, but enables TLS using the given config.\nfunc ServeTLS(config *tls.Config) {\n\tif !flag.Parsed() {\n\t\tflag.Parse()\n\t}\n\n\tServeListener(tls.NewListener(bind.Default(), config))\n}\n\n// Like Serve, but runs Goji on top of an arbitrary net.Listener.\nfunc ServeListener(listener net.Listener) {\n\tDefaultMux.Compile()\n\t// Install our handler at the root of the standard net/http default mux.\n\t// This allows packages like expvar to continue working as expected.\n\thttp.Handle(\"/\", DefaultMux)\n\n\tlog.Println(\"Starting Goji on\", listener.Addr())\n\n\tgraceful.HandleSignals()\n\tbind.Ready()\n\tgraceful.PreHook(func() { log.Printf(\"Goji received signal, gracefully stopping\") })\n\tgraceful.PostHook(func() { log.Printf(\"Goji stopped\") })\n\n\terr := graceful.Serve(listener, http.DefaultServeMux)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgraceful.Wait()\n}\n"
        },
        {
          "name": "serve_appengine.go",
          "type": "blob",
          "size": 0.458984375,
          "content": "// +build appengine\n\npackage goji\n\nimport (\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc init() {\n\tif fl := log.Flags(); fl&log.Ltime != 0 {\n\t\tlog.SetFlags(fl | log.Lmicroseconds)\n\t}\n}\n\n// Serve starts Goji using reasonable defaults.\nfunc Serve() {\n\tDefaultMux.Compile()\n\t// Install our handler at the root of the standard net/http default mux.\n\t// This is required for App Engine, and also allows packages like expvar\n\t// to continue working as expected.\n\thttp.Handle(\"/\", DefaultMux)\n}\n"
        },
        {
          "name": "web",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}