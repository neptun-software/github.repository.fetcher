{
  "metadata": {
    "timestamp": 1736566456472,
    "page": 2,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "segmentio/ksuid",
      "stars": 4989,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.30078125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n/ksuid\n\n# Emacs\n*~\n\n# govendor\n/vendor/*/\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2017 Segment.io\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.177734375,
          "content": "# ksuid [![Go Report Card](https://goreportcard.com/badge/github.com/segmentio/ksuid)](https://goreportcard.com/report/github.com/segmentio/ksuid) [![GoDoc](https://godoc.org/github.com/segmentio/ksuid?status.svg)](https://godoc.org/github.com/segmentio/ksuid) [![Circle CI](https://circleci.com/gh/segmentio/ksuid.svg?style=shield)](https://circleci.com/gh/segmentio/ksuid.svg?style=shield)\n\nksuid is an efficient, comprehensive, battle-tested Go library for\ngenerating and parsing a specific kind of globally unique identifier\ncalled a *KSUID*. This library serves as its reference implementation.\n\n## Install\n```sh\ngo get -u github.com/segmentio/ksuid\n```\n\n## What is a KSUID?\n\nKSUID is for K-Sortable Unique IDentifier. It is a kind of globally\nunique identifier similar to a [RFC 4122 UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), built from the ground-up to be \"naturally\"\nsorted by generation timestamp without any special type-aware logic.\n\nIn short, running a set of KSUIDs through the UNIX `sort` command will result\nin a list ordered by generation time.\n\n## Why use KSUIDs?\n\nThere are numerous methods for generating unique identifiers, so why KSUID?\n\n1. Naturally ordered by generation time\n2. Collision-free, coordination-free, dependency-free\n3. Highly portable representations\n\nEven if only one of these properties are important to you, KSUID is a great\nchoice! :) Many projects chose to use KSUIDs *just* because the text\nrepresentation is copy-and-paste friendly.\n\nFor a follow up read on the topic: [A brief history of UUID](https://segment.com/blog/a-brief-history-of-the-uuid/)\n\n### 1. Naturally Ordered By Generation Time\n\nUnlike the more ubiquitous UUIDv4, a KSUID contains a timestamp component\nthat allows them to be loosely sorted by generation time. This is not a strong\nguarantee (an invariant) as it depends on wall clocks, but is still incredibly\nuseful in practice. Both the binary and text representations will sort by\ncreation time without any special sorting logic.\n\n### 2. Collision-free, Coordination-free, Dependency-free\n\nWhile RFC 4122 UUIDv1s *do* include a time component, there aren't enough\nbytes of randomness to provide strong protection against collisions\n(duplicates). With such a low amount of entropy, it is feasible for a\nmalicious party to guess generated IDs, creating a problem for systems whose\nsecurity is, implicitly or explicitly, sensitive to an adversary guessing\nidentifiers.\n\nTo fit into a 64-bit number space, [Snowflake IDs](https://blog.twitter.com/2010/announcing-snowflake)\nand its derivatives require coordination to avoid collisions, which\nsignificantly increases the deployment complexity and operational burden.\n\nA KSUID includes 128 bits of pseudorandom data (\"entropy\"). This number space\nis 64 times larger than the 122 bits used by the well-accepted RFC 4122 UUIDv4\nstandard. The additional timestamp component can be considered \"bonus entropy\"\nwhich further decreases the probability of collisions, to the point of physical\ninfeasibility in any practical implementation.\n\n### 3. Highly Portable Representations\n\nThe text *and* binary representations are lexicographically sortable, which\nallows them to be dropped into systems which do not natively support KSUIDs\nand retain their time-ordered property.\n\nThe text representation is an alphanumeric base62 encoding, so it \"fits\"\nanywhere alphanumeric strings are accepted. No delimiters are used, so\nstringified KSUIDs won't be inadvertently truncated or tokenized when\ninterpreted by software that is designed for human-readable text, a common\nproblem for the text representation of RFC 4122 UUIDs.\n\n## How do KSUIDs work?\n\nBinary KSUIDs are 20-bytes: a 32-bit unsigned integer UTC timestamp and\na 128-bit randomly generated payload. The timestamp uses big-endian\nencoding, to support lexicographic sorting. The timestamp epoch is adjusted\nto May 13th, 2014, providing over 100 years of life. The payload is\ngenerated by a cryptographically-strong pseudorandom number generator.\n\nThe text representation is always 27 characters, encoded in alphanumeric\nbase62 that will lexicographically sort by timestamp.\n\n## High Performance\n\nThis library is designed to be used in code paths that are performance\ncritical. Its code has been tuned to eliminate all non-essential\noverhead. The `KSUID` type is derived from a fixed-size array, which\neliminates the additional reference chasing and allocation involved in\na variable-width type.\n\nThe API provides an interface for use in code paths which are sensitive\nto allocation. For example, the `Append` method can be used to parse the\ntext representation and replace the contents of a `KSUID` value\nwithout additional heap allocation.\n\nAll public package level \"pure\" functions are concurrency-safe, protected\nby a global mutex. For hot loops that generate a large amount of KSUIDs\nfrom a single Goroutine, the `Sequence` type is provided to elide the\npotential contention.\n\nBy default, out of an abundance of caution, the cryptographically-secure\nPRNG is used to generate the random bits of a KSUID. This can be relaxed\nin extremely performance-critical code using the included `FastRander`\ntype. `FastRander` uses the standard PRNG with a seed generated by the\ncryptographically-secure PRNG.\n\n*_NOTE:_ While there is no evidence that `FastRander` will increase the\nprobability of a collision, it shouldn't be used in scenarios where\nuniqueness is important to security, as there is an increased chance\nthe generated IDs can be predicted by an adversary.*\n\n## Battle Tested\n\nThis code has been used in production at Segment for several years,\nacross a diverse array of projects. Trillions upon trillions of\nKSUIDs have been generated in some of Segment's most\nperformance-critical, large-scale distributed systems.\n\n## Plays Well With Others\n\nDesigned to be integrated with other libraries, the `KSUID` type\nimplements many standard library interfaces, including:\n\n* `Stringer`\n* `database/sql.Scanner` and `database/sql/driver.Valuer`\n* `encoding.BinaryMarshal` and `encoding.BinaryUnmarshal`\n* `encoding.TextMarshal` and `encoding.TextUnmarshal`\n  (`encoding/json` friendly!)\n\n## Command Line Tool\n\nThis package comes with a command-line tool `ksuid`, useful for\ngenerating KSUIDs as well as inspecting the internal components of\nexisting KSUIDs. Machine-friendly output is provided for scripting\nuse cases.\n\nGiven a Go build environment, it can be installed with the command:\n\n```sh\n$ go install github.com/segmentio/ksuid/cmd/ksuid\n```\n\n## CLI Usage Examples\n\n### Generate a KSUID\n\n```sh\n$ ksuid\n0ujsswThIGTUYm2K8FjOOfXtY1K\n```\n\n### Generate 4 KSUIDs\n\n```sh\n$ ksuid -n 4\n0ujsszwN8NRY24YaXiTIE2VWDTS\n0ujsswThIGTUYm2K8FjOOfXtY1K\n0ujssxh0cECutqzMgbtXSGnjorm\n0ujsszgFvbiEr7CDgE3z8MAUPFt\n```\n\n### Inspect the components of a KSUID\n\n```sh\n$ ksuid -f inspect 0ujtsYcgvSTl8PAuAdqWYSMnLOv\n\nREPRESENTATION:\n\n  String: 0ujtsYcgvSTl8PAuAdqWYSMnLOv\n     Raw: 0669F7EFB5A1CD34B5F99D1154FB6853345C9735\n\nCOMPONENTS:\n\n       Time: 2017-10-09 21:00:47 -0700 PDT\n  Timestamp: 107608047\n    Payload: B5A1CD34B5F99D1154FB6853345C9735\n```\n\n### Generate a KSUID and inspect its components\n\n```sh\n$ ksuid -f inspect\n\nREPRESENTATION:\n\n  String: 0ujzPyRiIAffKhBux4PvQdDqMHY\n     Raw: 066A029C73FC1AA3B2446246D6E89FCD909E8FE8\n\nCOMPONENTS:\n\n       Time: 2017-10-09 21:46:20 -0700 PDT\n  Timestamp: 107610780\n    Payload: 73FC1AA3B2446246D6E89FCD909E8FE8\n\n```\n\n### Inspect a KSUID with template formatted inspection output\n\n```sh\n$ ksuid -f template -t '{{ .Time }}: {{ .Payload }}' 0ujtsYcgvSTl8PAuAdqWYSMnLOv\n2017-10-09 21:00:47 -0700 PDT: B5A1CD34B5F99D1154FB6853345C9735\n```\n\n### Inspect multiple KSUIDs with template formatted output\n\n```sh\n$ ksuid -f template -t '{{ .Time }}: {{ .Payload }}' $(ksuid -n 4)\n2017-10-09 21:05:37 -0700 PDT: 304102BC687E087CC3A811F21D113CCF\n2017-10-09 21:05:37 -0700 PDT: EAF0B240A9BFA55E079D887120D962F0\n2017-10-09 21:05:37 -0700 PDT: DF0761769909ABB0C7BB9D66F79FC041\n2017-10-09 21:05:37 -0700 PDT: 1A8F0E3D0BDEB84A5FAD702876F46543\n```\n\n### Generate KSUIDs and output JSON using template formatting\n\n```sh\n$ ksuid -f template -t '{ \"timestamp\": \"{{ .Timestamp }}\", \"payload\": \"{{ .Payload }}\", \"ksuid\": \"{{.String}}\"}' -n 4\n{ \"timestamp\": \"107611700\", \"payload\": \"9850EEEC191BF4FF26F99315CE43B0C8\", \"ksuid\": \"0uk1Hbc9dQ9pxyTqJ93IUrfhdGq\"}\n{ \"timestamp\": \"107611700\", \"payload\": \"CC55072555316F45B8CA2D2979D3ED0A\", \"ksuid\": \"0uk1HdCJ6hUZKDgcxhpJwUl5ZEI\"}\n{ \"timestamp\": \"107611700\", \"payload\": \"BA1C205D6177F0992D15EE606AE32238\", \"ksuid\": \"0uk1HcdvF0p8C20KtTfdRSB9XIm\"}\n{ \"timestamp\": \"107611700\", \"payload\": \"67517BA309EA62AE7991B27BB6F2FCAC\", \"ksuid\": \"0uk1Ha7hGJ1Q9Xbnkt0yZgNwg3g\"}\n```\n\n## OrNil functions\n\nThere are times when you are sure your ksuid is correct. But you need to get it from bytes or string and pass it\nit's to the structure. For this, there are OrNil functions that return ksuid.Nil on error and can be called \ndirectly in the structure.\n\n**Functions:**\n- `ParseOrNil()`\n- `FromPartsOrNil()`\n- `FromBytesOrNil()`\n\nAn example of using the function without OrNil:\n```go\nfunc getPosts(before, after []byte) {\n\tb, err := ksuid.FromBytes(before)\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\ta, err := ksuid.FromBytes(after)\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\tsortOptions := SortOptions{Before: b, After: a}\n}\n```\n\nIt is much more convenient to do it like this:\n\n```go\nfunc getPosts(before, after []byte) {\n\tsortOptions := SortOptions{\n\t\tBefore: ksuid.FromBytesOrNil(before),\n\t\tAfter:  ksuid.FromBytesOrNil(after),\n\t}\n}\n```\n\nOrNil functions are also used in many other libraries:\n\n- [satori/go.uuid](https://github.com/satori/go.uuid)\n- [oklog/ulid](https://github.com/oklog/ulid) (panic)\n\n## Implementations for other languages\n\n- Python: [svix-ksuid](https://github.com/svixhq/python-ksuid/)\n- Python: [cyksuid](https://github.com/timonwong/cyksuid)\n- Ruby: [ksuid-ruby](https://github.com/michaelherold/ksuid-ruby)\n- Java: [ksuid](https://github.com/ksuid/ksuid)\n- Java: [ksuid-creator](https://github.com/f4b6a3/ksuid-creator)\n- Rust: [svix-ksuid](https://github.com/svix/rust-ksuid)\n- dotNet: [Ksuid.Net](https://github.com/JoyMoe/Ksuid.Net)\n- dotnet: [KsuidDotNet](https://github.com/steve-warren/ksuid)\n- Erlang: [erl-ksuid](https://github.com/exograd/erl-ksuid)\n- Zig: [zig-ksuid](https://github.com/toffaletti/zig-ksuid)\n\n## License\n\nksuid source code is available under an MIT [License](/LICENSE.md).\n"
        },
        {
          "name": "base62.go",
          "type": "blob",
          "size": 4.8642578125,
          "content": "package ksuid\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n)\n\nconst (\n\t// lexographic ordering (based on Unicode table) is 0-9A-Za-z\n\tbase62Characters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\tzeroString       = \"000000000000000000000000000\"\n\toffsetUppercase  = 10\n\toffsetLowercase  = 36\n)\n\nvar (\n\terrShortBuffer = errors.New(\"the output buffer is too small to hold to decoded value\")\n)\n\n// Converts a base 62 byte into the number value that it represents.\nfunc base62Value(digit byte) byte {\n\tswitch {\n\tcase digit >= '0' && digit <= '9':\n\t\treturn digit - '0'\n\tcase digit >= 'A' && digit <= 'Z':\n\t\treturn offsetUppercase + (digit - 'A')\n\tdefault:\n\t\treturn offsetLowercase + (digit - 'a')\n\t}\n}\n\n// This function encodes the base 62 representation of the src KSUID in binary\n// form into dst.\n//\n// In order to support a couple of optimizations the function assumes that src\n// is 20 bytes long and dst is 27 bytes long.\n//\n// Any unused bytes in dst will be set to the padding '0' byte.\nfunc fastEncodeBase62(dst []byte, src []byte) {\n\tconst srcBase = 4294967296\n\tconst dstBase = 62\n\n\t// Split src into 5 4-byte words, this is where most of the efficiency comes\n\t// from because this is a O(N^2) algorithm, and we make N = N / 4 by working\n\t// on 32 bits at a time.\n\tparts := [5]uint32{\n\t\tbinary.BigEndian.Uint32(src[0:4]),\n\t\tbinary.BigEndian.Uint32(src[4:8]),\n\t\tbinary.BigEndian.Uint32(src[8:12]),\n\t\tbinary.BigEndian.Uint32(src[12:16]),\n\t\tbinary.BigEndian.Uint32(src[16:20]),\n\t}\n\n\tn := len(dst)\n\tbp := parts[:]\n\tbq := [5]uint32{}\n\n\tfor len(bp) != 0 {\n\t\tquotient := bq[:0]\n\t\tremainder := uint64(0)\n\n\t\tfor _, c := range bp {\n\t\t\tvalue := uint64(c) + uint64(remainder)*srcBase\n\t\t\tdigit := value / dstBase\n\t\t\tremainder = value % dstBase\n\n\t\t\tif len(quotient) != 0 || digit != 0 {\n\t\t\t\tquotient = append(quotient, uint32(digit))\n\t\t\t}\n\t\t}\n\n\t\t// Writes at the end of the destination buffer because we computed the\n\t\t// lowest bits first.\n\t\tn--\n\t\tdst[n] = base62Characters[remainder]\n\t\tbp = quotient\n\t}\n\n\t// Add padding at the head of the destination buffer for all bytes that were\n\t// not set.\n\tcopy(dst[:n], zeroString)\n}\n\n// This function appends the base 62 representation of the KSUID in src to dst,\n// and returns the extended byte slice.\n// The result is left-padded with '0' bytes to always append 27 bytes to the\n// destination buffer.\nfunc fastAppendEncodeBase62(dst []byte, src []byte) []byte {\n\tdst = reserve(dst, stringEncodedLength)\n\tn := len(dst)\n\tfastEncodeBase62(dst[n:n+stringEncodedLength], src)\n\treturn dst[:n+stringEncodedLength]\n}\n\n// This function decodes the base 62 representation of the src KSUID to the\n// binary form into dst.\n//\n// In order to support a couple of optimizations the function assumes that src\n// is 27 bytes long and dst is 20 bytes long.\n//\n// Any unused bytes in dst will be set to zero.\nfunc fastDecodeBase62(dst []byte, src []byte) error {\n\tconst srcBase = 62\n\tconst dstBase = 4294967296\n\n\t// This line helps BCE (Bounds Check Elimination).\n\t// It may be safely removed.\n\t_ = src[26]\n\n\tparts := [27]byte{\n\t\tbase62Value(src[0]),\n\t\tbase62Value(src[1]),\n\t\tbase62Value(src[2]),\n\t\tbase62Value(src[3]),\n\t\tbase62Value(src[4]),\n\t\tbase62Value(src[5]),\n\t\tbase62Value(src[6]),\n\t\tbase62Value(src[7]),\n\t\tbase62Value(src[8]),\n\t\tbase62Value(src[9]),\n\n\t\tbase62Value(src[10]),\n\t\tbase62Value(src[11]),\n\t\tbase62Value(src[12]),\n\t\tbase62Value(src[13]),\n\t\tbase62Value(src[14]),\n\t\tbase62Value(src[15]),\n\t\tbase62Value(src[16]),\n\t\tbase62Value(src[17]),\n\t\tbase62Value(src[18]),\n\t\tbase62Value(src[19]),\n\n\t\tbase62Value(src[20]),\n\t\tbase62Value(src[21]),\n\t\tbase62Value(src[22]),\n\t\tbase62Value(src[23]),\n\t\tbase62Value(src[24]),\n\t\tbase62Value(src[25]),\n\t\tbase62Value(src[26]),\n\t}\n\n\tn := len(dst)\n\tbp := parts[:]\n\tbq := [stringEncodedLength]byte{}\n\n\tfor len(bp) > 0 {\n\t\tquotient := bq[:0]\n\t\tremainder := uint64(0)\n\n\t\tfor _, c := range bp {\n\t\t\tvalue := uint64(c) + uint64(remainder)*srcBase\n\t\t\tdigit := value / dstBase\n\t\t\tremainder = value % dstBase\n\n\t\t\tif len(quotient) != 0 || digit != 0 {\n\t\t\t\tquotient = append(quotient, byte(digit))\n\t\t\t}\n\t\t}\n\n\t\tif n < 4 {\n\t\t\treturn errShortBuffer\n\t\t}\n\n\t\tdst[n-4] = byte(remainder >> 24)\n\t\tdst[n-3] = byte(remainder >> 16)\n\t\tdst[n-2] = byte(remainder >> 8)\n\t\tdst[n-1] = byte(remainder)\n\t\tn -= 4\n\t\tbp = quotient\n\t}\n\n\tvar zero [20]byte\n\tcopy(dst[:n], zero[:])\n\treturn nil\n}\n\n// This function appends the base 62 decoded version of src into dst.\nfunc fastAppendDecodeBase62(dst []byte, src []byte) []byte {\n\tdst = reserve(dst, byteLength)\n\tn := len(dst)\n\tfastDecodeBase62(dst[n:n+byteLength], src)\n\treturn dst[:n+byteLength]\n}\n\n// Ensures that at least nbytes are available in the remaining capacity of the\n// destination slice, if not, a new copy is made and returned by the function.\nfunc reserve(dst []byte, nbytes int) []byte {\n\tc := cap(dst)\n\tn := len(dst)\n\n\tif avail := c - n; avail < nbytes {\n\t\tc *= 2\n\t\tif (c - n) < nbytes {\n\t\t\tc = n + nbytes\n\t\t}\n\t\tb := make([]byte, n, c)\n\t\tcopy(b, dst)\n\t\tdst = b\n\t}\n\n\treturn dst\n}\n"
        },
        {
          "name": "base62_test.go",
          "type": "blob",
          "size": 5.265625,
          "content": "package ksuid\n\nimport (\n\t\"bytes\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestBase10ToBase62AndBack(t *testing.T) {\n\tnumber := []byte{1, 2, 3, 4}\n\tencoded := base2base(number, 10, 62)\n\tdecoded := base2base(encoded, 62, 10)\n\n\tif bytes.Compare(number, decoded) != 0 {\n\t\tt.Fatal(number, \" != \", decoded)\n\t}\n}\n\nfunc TestBase256ToBase62AndBack(t *testing.T) {\n\tnumber := []byte{255, 254, 253, 251}\n\tencoded := base2base(number, 256, 62)\n\tdecoded := base2base(encoded, 62, 256)\n\n\tif bytes.Compare(number, decoded) != 0 {\n\t\tt.Fatal(number, \" != \", decoded)\n\t}\n}\n\nfunc TestEncodeAndDecodeBase62(t *testing.T) {\n\thelloWorld := []byte(\"hello world\")\n\tencoded := encodeBase62(helloWorld)\n\tdecoded := decodeBase62(encoded)\n\n\tif len(encoded) < len(helloWorld) {\n\t\tt.Fatal(\"length of encoded base62 string\", encoded, \"should be >= than raw bytes!\")\n\n\t}\n\n\tif bytes.Compare(helloWorld, decoded) != 0 {\n\t\tt.Fatal(decoded, \" != \", helloWorld)\n\t}\n}\n\nfunc TestLexographicOrdering(t *testing.T) {\n\tunsortedStrings := make([]string, 256)\n\tfor i := 0; i < 256; i++ {\n\t\ts := string(encodeBase62([]byte{0, byte(i)}))\n\t\tunsortedStrings[i] = strings.Repeat(\"0\", 2-len(s)) + s\n\t}\n\n\tif !sort.StringsAreSorted(unsortedStrings) {\n\t\tsortedStrings := make([]string, len(unsortedStrings))\n\t\tfor i, s := range unsortedStrings {\n\t\t\tsortedStrings[i] = s\n\t\t}\n\t\tsort.Strings(sortedStrings)\n\n\t\tt.Fatal(\"base62 encoder does not produce lexographically sorted output.\",\n\t\t\t\"expected:\", sortedStrings,\n\t\t\t\"actual:\", unsortedStrings)\n\t}\n}\n\nfunc TestBase62Value(t *testing.T) {\n\ts := base62Characters\n\n\tfor i := range s {\n\t\tv := int(base62Value(s[i]))\n\n\t\tif v != i {\n\t\t\tt.Error(\"bad value:\")\n\t\t\tt.Log(\"<<<\", i)\n\t\t\tt.Log(\">>>\", v)\n\t\t}\n\t}\n}\n\nfunc TestFastAppendEncodeBase62(t *testing.T) {\n\tfor i := 0; i != 1000; i++ {\n\t\tid := New()\n\n\t\tb0 := id[:]\n\t\tb1 := appendEncodeBase62(nil, b0)\n\t\tb2 := fastAppendEncodeBase62(nil, b0)\n\n\t\ts1 := string(leftpad(b1, '0', stringEncodedLength))\n\t\ts2 := string(b2)\n\n\t\tif s1 != s2 {\n\t\t\tt.Error(\"bad base62 representation of\", id)\n\t\t\tt.Log(\"<<<\", s1, len(s1))\n\t\t\tt.Log(\">>>\", s2, len(s2))\n\t\t}\n\t}\n}\n\nfunc TestFastAppendDecodeBase62(t *testing.T) {\n\tfor i := 0; i != 1000; i++ {\n\t\tid := New()\n\t\tb0 := leftpad(encodeBase62(id[:]), '0', stringEncodedLength)\n\n\t\tb1 := appendDecodeBase62(nil, []byte(string(b0))) // because it modifies the input buffer\n\t\tb2 := fastAppendDecodeBase62(nil, b0)\n\n\t\tif !bytes.Equal(leftpad(b1, 0, byteLength), b2) {\n\t\t\tt.Error(\"bad binary representation of\", string(b0))\n\t\t\tt.Log(\"<<<\", b1)\n\t\t\tt.Log(\">>>\", b2)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAppendEncodeBase62(b *testing.B) {\n\ta := [stringEncodedLength]byte{}\n\tid := New()\n\n\tfor i := 0; i != b.N; i++ {\n\t\tappendEncodeBase62(a[:0], id[:])\n\t}\n}\n\nfunc BenchmarkAppendFastEncodeBase62(b *testing.B) {\n\ta := [stringEncodedLength]byte{}\n\tid := New()\n\n\tfor i := 0; i != b.N; i++ {\n\t\tfastAppendEncodeBase62(a[:0], id[:])\n\t}\n}\n\nfunc BenchmarkAppendDecodeBase62(b *testing.B) {\n\ta := [byteLength]byte{}\n\tid := []byte(New().String())\n\n\tfor i := 0; i != b.N; i++ {\n\t\tb := [stringEncodedLength]byte{}\n\t\tcopy(b[:], id)\n\t\tappendDecodeBase62(a[:0], b[:])\n\t}\n}\n\nfunc BenchmarkAppendFastDecodeBase62(b *testing.B) {\n\ta := [byteLength]byte{}\n\tid := []byte(New().String())\n\n\tfor i := 0; i != b.N; i++ {\n\t\tfastAppendDecodeBase62(a[:0], id)\n\t}\n}\n\n// The functions bellow were the initial implementation of the base conversion\n// algorithms, they were replaced by optimized versions later on. We keep them\n// in the test files as a reference to ensure compatibility between the generic\n// and optimized implementations.\n\nfunc appendBase2Base(dst []byte, src []byte, inBase int, outBase int) []byte {\n\toff := len(dst)\n\tbs := src[:]\n\tbq := [stringEncodedLength]byte{}\n\n\tfor len(bs) > 0 {\n\t\tlength := len(bs)\n\t\tquotient := bq[:0]\n\t\tremainder := 0\n\n\t\tfor i := 0; i != length; i++ {\n\t\t\tacc := int(bs[i]) + remainder*inBase\n\t\t\td := acc/outBase | 0\n\t\t\tremainder = acc % outBase\n\n\t\t\tif len(quotient) > 0 || d > 0 {\n\t\t\t\tquotient = append(quotient, byte(d))\n\t\t\t}\n\t\t}\n\n\t\t// Appends in reverse order, the byte slice gets reversed before it's\n\t\t// returned by the function.\n\t\tdst = append(dst, byte(remainder))\n\t\tbs = quotient\n\t}\n\n\treverse(dst[off:])\n\treturn dst\n}\n\nfunc base2base(src []byte, inBase int, outBase int) []byte {\n\treturn appendBase2Base(nil, src, inBase, outBase)\n}\n\nfunc appendEncodeBase62(dst []byte, src []byte) []byte {\n\toff := len(dst)\n\tdst = appendBase2Base(dst, src, 256, 62)\n\tfor i, c := range dst[off:] {\n\t\tdst[off+i] = base62Characters[c]\n\t}\n\treturn dst\n}\n\nfunc encodeBase62(in []byte) []byte {\n\treturn appendEncodeBase62(nil, in)\n}\n\nfunc appendDecodeBase62(dst []byte, src []byte) []byte {\n\t// Kind of intrusive, we modify the input buffer... it's OK here, it saves\n\t// a memory allocation in Parse.\n\tfor i, b := range src {\n\t\t// O(1)... technically. Has better real-world perf than a map\n\t\tsrc[i] = byte(strings.IndexByte(base62Characters, b))\n\t}\n\treturn appendBase2Base(dst, src, 62, 256)\n}\n\nfunc decodeBase62(src []byte) []byte {\n\treturn appendDecodeBase62(\n\t\tmake([]byte, 0, len(src)*2),\n\t\tappend(make([]byte, 0, len(src)), src...),\n\t)\n}\n\nfunc reverse(b []byte) {\n\ti := 0\n\tj := len(b) - 1\n\n\tfor i < j {\n\t\tb[i], b[j] = b[j], b[i]\n\t\ti++\n\t\tj--\n\t}\n}\n\nfunc leftpad(b []byte, c byte, n int) []byte {\n\tif n -= len(b); n > 0 {\n\t\tfor i := 0; i != n; i++ {\n\t\t\tb = append(b, c)\n\t\t}\n\n\t\tcopy(b[n:], b)\n\n\t\tfor i := 0; i != n; i++ {\n\t\t\tb[i] = c\n\t\t}\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/segmentio/ksuid\n\ngo 1.12\n"
        },
        {
          "name": "ksuid.go",
          "type": "blob",
          "size": 8.7646484375,
          "content": "package ksuid\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"database/sql/driver\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\t// KSUID's epoch starts more recently so that the 32-bit number space gives a\n\t// significantly higher useful lifetime of around 136 years from March 2017.\n\t// This number (14e8) was picked to be easy to remember.\n\tepochStamp int64 = 1400000000\n\n\t// Timestamp is a uint32\n\ttimestampLengthInBytes = 4\n\n\t// Payload is 16-bytes\n\tpayloadLengthInBytes = 16\n\n\t// KSUIDs are 20 bytes when binary encoded\n\tbyteLength = timestampLengthInBytes + payloadLengthInBytes\n\n\t// The length of a KSUID when string (base62) encoded\n\tstringEncodedLength = 27\n\n\t// A string-encoded minimum value for a KSUID\n\tminStringEncoded = \"000000000000000000000000000\"\n\n\t// A string-encoded maximum value for a KSUID\n\tmaxStringEncoded = \"aWgEPTl1tmebfsQzFP4bxwgy80V\"\n)\n\n// KSUIDs are 20 bytes:\n//  00-03 byte: uint32 BE UTC timestamp with custom epoch\n//  04-19 byte: random \"payload\"\ntype KSUID [byteLength]byte\n\nvar (\n\trander     = rand.Reader\n\trandMutex  = sync.Mutex{}\n\trandBuffer = [payloadLengthInBytes]byte{}\n\n\terrSize        = fmt.Errorf(\"Valid KSUIDs are %v bytes\", byteLength)\n\terrStrSize     = fmt.Errorf(\"Valid encoded KSUIDs are %v characters\", stringEncodedLength)\n\terrStrValue    = fmt.Errorf(\"Valid encoded KSUIDs are bounded by %s and %s\", minStringEncoded, maxStringEncoded)\n\terrPayloadSize = fmt.Errorf(\"Valid KSUID payloads are %v bytes\", payloadLengthInBytes)\n\n\t// Represents a completely empty (invalid) KSUID\n\tNil KSUID\n\t// Represents the highest value a KSUID can have\n\tMax = KSUID{255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}\n)\n\n// Append appends the string representation of i to b, returning a slice to a\n// potentially larger memory area.\nfunc (i KSUID) Append(b []byte) []byte {\n\treturn fastAppendEncodeBase62(b, i[:])\n}\n\n// The timestamp portion of the ID as a Time object\nfunc (i KSUID) Time() time.Time {\n\treturn correctedUTCTimestampToTime(i.Timestamp())\n}\n\n// The timestamp portion of the ID as a bare integer which is uncorrected\n// for KSUID's special epoch.\nfunc (i KSUID) Timestamp() uint32 {\n\treturn binary.BigEndian.Uint32(i[:timestampLengthInBytes])\n}\n\n// The 16-byte random payload without the timestamp\nfunc (i KSUID) Payload() []byte {\n\treturn i[timestampLengthInBytes:]\n}\n\n// String-encoded representation that can be passed through Parse()\nfunc (i KSUID) String() string {\n\treturn string(i.Append(make([]byte, 0, stringEncodedLength)))\n}\n\n// Raw byte representation of KSUID\nfunc (i KSUID) Bytes() []byte {\n\t// Safe because this is by-value\n\treturn i[:]\n}\n\n// IsNil returns true if this is a \"nil\" KSUID\nfunc (i KSUID) IsNil() bool {\n\treturn i == Nil\n}\n\n// Get satisfies the flag.Getter interface, making it possible to use KSUIDs as\n// part of of the command line options of a program.\nfunc (i KSUID) Get() interface{} {\n\treturn i\n}\n\n// Set satisfies the flag.Value interface, making it possible to use KSUIDs as\n// part of of the command line options of a program.\nfunc (i *KSUID) Set(s string) error {\n\treturn i.UnmarshalText([]byte(s))\n}\n\nfunc (i KSUID) MarshalText() ([]byte, error) {\n\treturn []byte(i.String()), nil\n}\n\nfunc (i KSUID) MarshalBinary() ([]byte, error) {\n\treturn i.Bytes(), nil\n}\n\nfunc (i *KSUID) UnmarshalText(b []byte) error {\n\tid, err := Parse(string(b))\n\tif err != nil {\n\t\treturn err\n\t}\n\t*i = id\n\treturn nil\n}\n\nfunc (i *KSUID) UnmarshalBinary(b []byte) error {\n\tid, err := FromBytes(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*i = id\n\treturn nil\n}\n\n// Value converts the KSUID into a SQL driver value which can be used to\n// directly use the KSUID as parameter to a SQL query.\nfunc (i KSUID) Value() (driver.Value, error) {\n\tif i.IsNil() {\n\t\treturn nil, nil\n\t}\n\treturn i.String(), nil\n}\n\n// Scan implements the sql.Scanner interface. It supports converting from\n// string, []byte, or nil into a KSUID value. Attempting to convert from\n// another type will return an error.\nfunc (i *KSUID) Scan(src interface{}) error {\n\tswitch v := src.(type) {\n\tcase nil:\n\t\treturn i.scan(nil)\n\tcase []byte:\n\t\treturn i.scan(v)\n\tcase string:\n\t\treturn i.scan([]byte(v))\n\tdefault:\n\t\treturn fmt.Errorf(\"Scan: unable to scan type %T into KSUID\", v)\n\t}\n}\n\nfunc (i *KSUID) scan(b []byte) error {\n\tswitch len(b) {\n\tcase 0:\n\t\t*i = Nil\n\t\treturn nil\n\tcase byteLength:\n\t\treturn i.UnmarshalBinary(b)\n\tcase stringEncodedLength:\n\t\treturn i.UnmarshalText(b)\n\tdefault:\n\t\treturn errSize\n\t}\n}\n\n// Parse decodes a string-encoded representation of a KSUID object\nfunc Parse(s string) (KSUID, error) {\n\tif len(s) != stringEncodedLength {\n\t\treturn Nil, errStrSize\n\t}\n\n\tsrc := [stringEncodedLength]byte{}\n\tdst := [byteLength]byte{}\n\n\tcopy(src[:], s[:])\n\n\tif err := fastDecodeBase62(dst[:], src[:]); err != nil {\n\t\treturn Nil, errStrValue\n\t}\n\n\treturn FromBytes(dst[:])\n}\n\n// Parse decodes a string-encoded representation of a KSUID object.\n// Same behavior as Parse, but returns a Nil KSUID on error.\nfunc ParseOrNil(s string) KSUID {\n\tksuid, err := Parse(s)\n\tif err != nil {\n\t\treturn Nil\n\t}\n\treturn ksuid\n}\n\nfunc timeToCorrectedUTCTimestamp(t time.Time) uint32 {\n\treturn uint32(t.Unix() - epochStamp)\n}\n\nfunc correctedUTCTimestampToTime(ts uint32) time.Time {\n\treturn time.Unix(int64(ts)+epochStamp, 0)\n}\n\n// Generates a new KSUID. In the strange case that random bytes\n// can't be read, it will panic.\nfunc New() KSUID {\n\tksuid, err := NewRandom()\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"Couldn't generate KSUID, inconceivable! error: %v\", err))\n\t}\n\treturn ksuid\n}\n\n// Generates a new KSUID\nfunc NewRandom() (ksuid KSUID, err error) {\n\treturn NewRandomWithTime(time.Now())\n}\n\nfunc NewRandomWithTime(t time.Time) (ksuid KSUID, err error) {\n\t// Go's default random number generators are not safe for concurrent use by\n\t// multiple goroutines, the use of the rander and randBuffer are explicitly\n\t// synchronized here.\n\trandMutex.Lock()\n\n\t_, err = io.ReadAtLeast(rander, randBuffer[:], len(randBuffer))\n\tcopy(ksuid[timestampLengthInBytes:], randBuffer[:])\n\n\trandMutex.Unlock()\n\n\tif err != nil {\n\t\tksuid = Nil // don't leak random bytes on error\n\t\treturn\n\t}\n\n\tts := timeToCorrectedUTCTimestamp(t)\n\tbinary.BigEndian.PutUint32(ksuid[:timestampLengthInBytes], ts)\n\treturn\n}\n\n// Constructs a KSUID from constituent parts\nfunc FromParts(t time.Time, payload []byte) (KSUID, error) {\n\tif len(payload) != payloadLengthInBytes {\n\t\treturn Nil, errPayloadSize\n\t}\n\n\tvar ksuid KSUID\n\n\tts := timeToCorrectedUTCTimestamp(t)\n\tbinary.BigEndian.PutUint32(ksuid[:timestampLengthInBytes], ts)\n\n\tcopy(ksuid[timestampLengthInBytes:], payload)\n\n\treturn ksuid, nil\n}\n\n// Constructs a KSUID from constituent parts.\n// Same behavior as FromParts, but returns a Nil KSUID on error.\nfunc FromPartsOrNil(t time.Time, payload []byte) KSUID {\n\tksuid, err := FromParts(t, payload)\n\tif err != nil {\n\t\treturn Nil\n\t}\n\treturn ksuid\n}\n\n// Constructs a KSUID from a 20-byte binary representation\nfunc FromBytes(b []byte) (KSUID, error) {\n\tvar ksuid KSUID\n\n\tif len(b) != byteLength {\n\t\treturn Nil, errSize\n\t}\n\n\tcopy(ksuid[:], b)\n\treturn ksuid, nil\n}\n\n// Constructs a KSUID from a 20-byte binary representation.\n// Same behavior as FromBytes, but returns a Nil KSUID on error.\nfunc FromBytesOrNil(b []byte) KSUID {\n\tksuid, err := FromBytes(b)\n\tif err != nil {\n\t\treturn Nil\n\t}\n\treturn ksuid\n}\n\n// Sets the global source of random bytes for KSUID generation. This\n// should probably only be set once globally. While this is technically\n// thread-safe as in it won't cause corruption, there's no guarantee\n// on ordering.\nfunc SetRand(r io.Reader) {\n\tif r == nil {\n\t\trander = rand.Reader\n\t\treturn\n\t}\n\trander = r\n}\n\n// Implements comparison for KSUID type\nfunc Compare(a, b KSUID) int {\n\treturn bytes.Compare(a[:], b[:])\n}\n\n// Sorts the given slice of KSUIDs\nfunc Sort(ids []KSUID) {\n\tquickSort(ids, 0, len(ids)-1)\n}\n\n// IsSorted checks whether a slice of KSUIDs is sorted\nfunc IsSorted(ids []KSUID) bool {\n\tif len(ids) != 0 {\n\t\tmin := ids[0]\n\t\tfor _, id := range ids[1:] {\n\t\t\tif bytes.Compare(min[:], id[:]) > 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tmin = id\n\t\t}\n\t}\n\treturn true\n}\n\nfunc quickSort(a []KSUID, lo int, hi int) {\n\tif lo < hi {\n\t\tpivot := a[hi]\n\t\ti := lo - 1\n\n\t\tfor j, n := lo, hi; j != n; j++ {\n\t\t\tif bytes.Compare(a[j][:], pivot[:]) < 0 {\n\t\t\t\ti++\n\t\t\t\ta[i], a[j] = a[j], a[i]\n\t\t\t}\n\t\t}\n\n\t\ti++\n\t\tif bytes.Compare(a[hi][:], a[i][:]) < 0 {\n\t\t\ta[i], a[hi] = a[hi], a[i]\n\t\t}\n\n\t\tquickSort(a, lo, i-1)\n\t\tquickSort(a, i+1, hi)\n\t}\n}\n\n// Next returns the next KSUID after id.\nfunc (id KSUID) Next() KSUID {\n\tzero := makeUint128(0, 0)\n\n\tt := id.Timestamp()\n\tu := uint128Payload(id)\n\tv := add128(u, makeUint128(0, 1))\n\n\tif v == zero { // overflow\n\t\tt++\n\t}\n\n\treturn v.ksuid(t)\n}\n\n// Prev returns the previoud KSUID before id.\nfunc (id KSUID) Prev() KSUID {\n\tmax := makeUint128(math.MaxUint64, math.MaxUint64)\n\n\tt := id.Timestamp()\n\tu := uint128Payload(id)\n\tv := sub128(u, makeUint128(0, 1))\n\n\tif v == max { // overflow\n\t\tt--\n\t}\n\n\treturn v.ksuid(t)\n}\n"
        },
        {
          "name": "ksuid_test.go",
          "type": "blob",
          "size": 7.0966796875,
          "content": "package ksuid\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestConstructionTimestamp(t *testing.T) {\n\tx := New()\n\tnowTime := time.Now().Round(1 * time.Minute)\n\txTime := x.Time().Round(1 * time.Minute)\n\n\tif xTime != nowTime {\n\t\tt.Fatal(xTime, \"!=\", nowTime)\n\t}\n}\n\nfunc TestNil(t *testing.T) {\n\tif !Nil.IsNil() {\n\t\tt.Fatal(\"Nil should be Nil!\")\n\t}\n\n\tx, _ := FromBytes(make([]byte, byteLength))\n\tif !x.IsNil() {\n\t\tt.Fatal(\"Zero-byte array should be Nil!\")\n\t}\n}\n\nfunc TestEncoding(t *testing.T) {\n\tx, _ := FromBytes(make([]byte, byteLength))\n\tif !x.IsNil() {\n\t\tt.Fatal(\"Zero-byte array should be Nil!\")\n\t}\n\n\tencoded := x.String()\n\texpected := strings.Repeat(\"0\", stringEncodedLength)\n\n\tif encoded != expected {\n\t\tt.Fatal(\"expected\", expected, \"encoded\", encoded)\n\t}\n}\n\nfunc TestPadding(t *testing.T) {\n\tb := make([]byte, byteLength)\n\tfor i := 0; i < byteLength; i++ {\n\t\tb[i] = 255\n\t}\n\n\tx, _ := FromBytes(b)\n\txEncoded := x.String()\n\tnilEncoded := Nil.String()\n\n\tif len(xEncoded) != len(nilEncoded) {\n\t\tt.Fatal(\"Encoding should produce equal-length strings for zero and max case\")\n\t}\n}\n\nfunc TestParse(t *testing.T) {\n\t_, err := Parse(\"123\")\n\tif err != errStrSize {\n\t\tt.Fatal(\"Expected Parsing a 3-char string to return an error\")\n\t}\n\n\tparsed, err := Parse(strings.Repeat(\"0\", stringEncodedLength))\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error\", err)\n\t}\n\n\tif Compare(parsed, Nil) != 0 {\n\t\tt.Fatal(\"Parsing all-zeroes string should equal Nil value\",\n\t\t\t\"expected:\", Nil,\n\t\t\t\"actual:\", parsed)\n\t}\n\n\tmaxBytes := make([]byte, byteLength)\n\tfor i := 0; i < byteLength; i++ {\n\t\tmaxBytes[i] = 255\n\t}\n\tmaxBytesKSUID, err := FromBytes(maxBytes)\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error\", err)\n\t}\n\n\tmaxParseKSUID, err := Parse(maxStringEncoded)\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error\", err)\n\t}\n\n\tif Compare(maxBytesKSUID, maxParseKSUID) != 0 {\n\t\tt.Fatal(\"String decoder broke for max string\")\n\t}\n}\n\nfunc TestIssue25(t *testing.T) {\n\t// https://github.com/segmentio/ksuid/issues/25\n\tfor _, s := range []string{\n\t\t\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t\"aWgEPTl1tmebfsQzFP4bxwgy80!\",\n\t} {\n\t\t_, err := Parse(s)\n\t\tif err != errStrValue {\n\t\t\tt.Error(\"invalid KSUID representations cannot be successfully parsed, got err =\", err)\n\t\t}\n\t}\n}\n\nfunc TestEncodeAndDecode(t *testing.T) {\n\tx := New()\n\tbuiltFromEncodedString, err := Parse(x.String())\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error\", err)\n\t}\n\n\tif Compare(x, builtFromEncodedString) != 0 {\n\t\tt.Fatal(\"Parse(X).String() != X\")\n\t}\n}\n\nfunc TestMarshalText(t *testing.T) {\n\tvar id1 = New()\n\tvar id2 KSUID\n\n\tif err := id2.UnmarshalText([]byte(id1.String())); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif id1 != id2 {\n\t\tt.Fatal(id1, \"!=\", id2)\n\t}\n\n\tif b, err := id2.MarshalText(); err != nil {\n\t\tt.Fatal(err)\n\t} else if s := string(b); s != id1.String() {\n\t\tt.Fatal(s)\n\t}\n}\n\nfunc TestMarshalBinary(t *testing.T) {\n\tvar id1 = New()\n\tvar id2 KSUID\n\n\tif err := id2.UnmarshalBinary(id1.Bytes()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif id1 != id2 {\n\t\tt.Fatal(id1, \"!=\", id2)\n\t}\n\n\tif b, err := id2.MarshalBinary(); err != nil {\n\t\tt.Fatal(err)\n\t} else if bytes.Compare(b, id1.Bytes()) != 0 {\n\t\tt.Fatal(\"bad binary form:\", id2)\n\t}\n}\n\nfunc TestMashalJSON(t *testing.T) {\n\tvar id1 = New()\n\tvar id2 KSUID\n\n\tif b, err := json.Marshal(id1); err != nil {\n\t\tt.Fatal(err)\n\t} else if err := json.Unmarshal(b, &id2); err != nil {\n\t\tt.Fatal(err)\n\t} else if id1 != id2 {\n\t\tt.Error(id1, \"!=\", id2)\n\t}\n}\n\nfunc TestFlag(t *testing.T) {\n\tvar id1 = New()\n\tvar id2 KSUID\n\n\tfset := flag.NewFlagSet(\"test\", flag.ContinueOnError)\n\tfset.Var(&id2, \"id\", \"the KSUID\")\n\n\tif err := fset.Parse([]string{\"-id\", id1.String()}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif id1 != id2 {\n\t\tt.Error(id1, \"!=\", id2)\n\t}\n}\n\nfunc TestSqlValuer(t *testing.T) {\n\tid, _ := Parse(maxStringEncoded)\n\n\tif v, err := id.Value(); err != nil {\n\t\tt.Error(err)\n\t} else if s, ok := v.(string); !ok {\n\t\tt.Error(\"not a string value\")\n\t} else if s != maxStringEncoded {\n\t\tt.Error(\"bad string value::\", s)\n\t}\n}\n\nfunc TestSqlValuerNilValue(t *testing.T) {\n\tif v, err := Nil.Value(); err != nil {\n\t\tt.Error(err)\n\t} else if v != nil {\n\t\tt.Errorf(\"bad nil value: %v\", v)\n\t}\n}\n\nfunc TestSqlScanner(t *testing.T) {\n\tid1 := New()\n\tid2 := New()\n\n\ttests := []struct {\n\t\tksuid KSUID\n\t\tvalue interface{}\n\t}{\n\t\t{Nil, nil},\n\t\t{id1, id1.String()},\n\t\t{id2, id2.Bytes()},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"%T\", test.value), func(t *testing.T) {\n\t\t\tvar id KSUID\n\n\t\t\tif err := id.Scan(test.value); err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\n\t\t\tif id != test.ksuid {\n\t\t\t\tt.Error(\"bad KSUID:\")\n\t\t\t\tt.Logf(\"expected %v\", test.ksuid)\n\t\t\t\tt.Logf(\"found    %v\", id)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAppend(t *testing.T) {\n\tfor _, repr := range []string{\"0pN1Own7255s7jwpwy495bAZeEa\", \"aWgEPTl1tmebfsQzFP4bxwgy80V\"} {\n\t\tk, _ := Parse(repr)\n\t\ta := make([]byte, 0, stringEncodedLength)\n\n\t\ta = append(a, \"?: \"...)\n\t\ta = k.Append(a)\n\n\t\tif s := string(a); s != \"?: \"+repr {\n\t\t\tt.Error(s)\n\t\t}\n\t}\n}\n\nfunc TestSort(t *testing.T) {\n\tids1 := [11]KSUID{}\n\tids2 := [11]KSUID{}\n\n\tfor i := range ids1 {\n\t\tids1[i] = New()\n\t}\n\n\tids2 = ids1\n\tsort.Slice(ids2[:], func(i, j int) bool {\n\t\treturn Compare(ids2[i], ids2[j]) < 0\n\t})\n\n\tSort(ids1[:])\n\n\tif !IsSorted(ids1[:]) {\n\t\tt.Error(\"not sorted\")\n\t}\n\n\tif ids1 != ids2 {\n\t\tt.Error(\"bad order:\")\n\t\tt.Log(ids1)\n\t\tt.Log(ids2)\n\t}\n}\n\nfunc TestPrevNext(t *testing.T) {\n\ttests := []struct {\n\t\tid   KSUID\n\t\tprev KSUID\n\t\tnext KSUID\n\t}{\n\t\t{\n\t\t\tid:   Nil,\n\t\t\tprev: Max,\n\t\t\tnext: KSUID{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n\t\t},\n\t\t{\n\t\t\tid:   Max,\n\t\t\tprev: KSUID{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe},\n\t\t\tnext: Nil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.id.String(), func(t *testing.T) {\n\t\t\ttestPrevNext(t, test.id, test.prev, test.next)\n\t\t})\n\t}\n}\n\nfunc TestGetTimestamp(t *testing.T) {\n\tnowTime := time.Now()\n\tx, _ := NewRandomWithTime(nowTime)\n\txTime := int64(x.Timestamp())\n\tunix := nowTime.Unix()\n\tif xTime != unix - epochStamp {\n\t\tt.Fatal(xTime, \"!=\", unix)\n\t}\n}\n\nfunc testPrevNext(t *testing.T, id, prev, next KSUID) {\n\tid1 := id.Prev()\n\tid2 := id.Next()\n\n\tif id1 != prev {\n\t\tt.Error(\"previous id of the nil KSUID is wrong:\", id1, \"!=\", prev)\n\t}\n\n\tif id2 != next {\n\t\tt.Error(\"next id of the nil KSUID is wrong:\", id2, \"!=\", next)\n\t}\n}\n\nfunc BenchmarkAppend(b *testing.B) {\n\ta := make([]byte, 0, stringEncodedLength)\n\tk := New()\n\n\tfor i := 0; i != b.N; i++ {\n\t\tk.Append(a)\n\t}\n}\n\nfunc BenchmarkString(b *testing.B) {\n\tk := New()\n\n\tfor i := 0; i != b.N; i++ {\n\t\t_ = k.String()\n\t}\n}\n\nfunc BenchmarkParse(b *testing.B) {\n\tfor i := 0; i != b.N; i++ {\n\t\tParse(maxStringEncoded)\n\t}\n}\n\nfunc BenchmarkCompare(b *testing.B) {\n\tk1 := New()\n\tk2 := New()\n\n\tfor i := 0; i != b.N; i++ {\n\t\tCompare(k1, k2)\n\t}\n}\n\nfunc BenchmarkSort(b *testing.B) {\n\tids1 := [101]KSUID{}\n\tids2 := [101]KSUID{}\n\n\tfor i := range ids1 {\n\t\tids1[i] = New()\n\t}\n\n\tfor i := 0; i != b.N; i++ {\n\t\tids2 = ids1\n\t\tSort(ids2[:])\n\t}\n}\n\nfunc BenchmarkNew(b *testing.B) {\n\tb.Run(\"with crypto rand\", func(b *testing.B) {\n\t\tSetRand(nil)\n\t\tfor i := 0; i != b.N; i++ {\n\t\t\tNew()\n\t\t}\n\t})\n\tb.Run(\"with math rand\", func(b *testing.B) {\n\t\tSetRand(FastRander)\n\t\tfor i := 0; i != b.N; i++ {\n\t\t\tNew()\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "rand.go",
          "type": "blob",
          "size": 1.1884765625,
          "content": "package ksuid\n\nimport (\n\tcryptoRand \"crypto/rand\"\n\t\"encoding/binary\"\n\t\"io\"\n\t\"math/rand\"\n)\n\n// FastRander is an io.Reader that uses math/rand and is optimized for\n// generating 16 bytes KSUID payloads. It is intended to be used as a\n// performance improvements for programs that have no need for\n// cryptographically secure KSUIDs and are generating a lot of them.\nvar FastRander = newRBG()\n\nfunc newRBG() io.Reader {\n\tr, err := newRandomBitsGenerator()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r\n}\n\nfunc newRandomBitsGenerator() (r io.Reader, err error) {\n\tvar seed int64\n\n\tif seed, err = readCryptoRandomSeed(); err != nil {\n\t\treturn\n\t}\n\n\tr = &randSourceReader{source: rand.NewSource(seed).(rand.Source64)}\n\treturn\n}\n\nfunc readCryptoRandomSeed() (seed int64, err error) {\n\tvar b [8]byte\n\n\tif _, err = io.ReadFull(cryptoRand.Reader, b[:]); err != nil {\n\t\treturn\n\t}\n\n\tseed = int64(binary.LittleEndian.Uint64(b[:]))\n\treturn\n}\n\ntype randSourceReader struct {\n\tsource rand.Source64\n}\n\nfunc (r *randSourceReader) Read(b []byte) (int, error) {\n\t// optimized for generating 16 bytes payloads\n\tbinary.LittleEndian.PutUint64(b[:8], r.source.Uint64())\n\tbinary.LittleEndian.PutUint64(b[8:], r.source.Uint64())\n\treturn 16, nil\n}\n"
        },
        {
          "name": "sequence.go",
          "type": "blob",
          "size": 1.5185546875,
          "content": "package ksuid\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"math\"\n)\n\n// Sequence is a KSUID generator which produces a sequence of ordered KSUIDs\n// from a seed.\n//\n// Up to 65536 KSUIDs can be generated by for a single seed.\n//\n// A typical usage of a Sequence looks like this:\n//\n//\tseq := ksuid.Sequence{\n//\t\tSeed: ksuid.New(),\n//\t}\n//\tid, err := seq.Next()\n//\n// Sequence values are not safe to use concurrently from multiple goroutines.\ntype Sequence struct {\n\t// The seed is used as base for the KSUID generator, all generated KSUIDs\n\t// share the same leading 18 bytes of the seed.\n\tSeed  KSUID\n\tcount uint32 // uint32 for overflow, only 2 bytes are used\n}\n\n// Next produces the next KSUID in the sequence, or returns an error if the\n// sequence has been exhausted.\nfunc (seq *Sequence) Next() (KSUID, error) {\n\tid := seq.Seed // copy\n\tcount := seq.count\n\tif count > math.MaxUint16 {\n\t\treturn Nil, errors.New(\"too many IDs were generated\")\n\t}\n\tseq.count++\n\treturn withSequenceNumber(id, uint16(count)), nil\n}\n\n// Bounds returns the inclusive min and max bounds of the KSUIDs that may be\n// generated by the sequence. If all ids have been generated already then the\n// returned min value is equal to the max.\nfunc (seq *Sequence) Bounds() (min KSUID, max KSUID) {\n\tcount := seq.count\n\tif count > math.MaxUint16 {\n\t\tcount = math.MaxUint16\n\t}\n\treturn withSequenceNumber(seq.Seed, uint16(count)), withSequenceNumber(seq.Seed, math.MaxUint16)\n}\n\nfunc withSequenceNumber(id KSUID, n uint16) KSUID {\n\tbinary.BigEndian.PutUint16(id[len(id)-2:], n)\n\treturn id\n}\n"
        },
        {
          "name": "sequence_test.go",
          "type": "blob",
          "size": 0.7041015625,
          "content": "package ksuid\n\nimport (\n\t\"encoding/binary\"\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSequence(t *testing.T) {\n\tseq := Sequence{Seed: New()}\n\n\tif min, max := seq.Bounds(); min == max {\n\t\tt.Error(\"min and max of KSUID range must differ when no ids have been generated\")\n\t}\n\n\tfor i := 0; i <= math.MaxUint16; i++ {\n\t\tid, err := seq.Next()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif j := int(binary.BigEndian.Uint16(id[len(id)-2:])); j != i {\n\t\t\tt.Fatalf(\"expected %d but got %d in %s\", i, j, id)\n\t\t}\n\t}\n\n\tif _, err := seq.Next(); err == nil {\n\t\tt.Fatal(\"no error returned after exhausting the id generator\")\n\t}\n\n\tif min, max := seq.Bounds(); min != max {\n\t\tt.Error(\"after all KSUIDs were generated the min and max must be equal\")\n\t}\n}\n"
        },
        {
          "name": "set.go",
          "type": "blob",
          "size": 7.09375,
          "content": "package ksuid\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n)\n\n// CompressedSet is an immutable data type which stores a set of KSUIDs.\ntype CompressedSet []byte\n\n// Iter returns an iterator that produces all KSUIDs in the set.\nfunc (set CompressedSet) Iter() CompressedSetIter {\n\treturn CompressedSetIter{\n\t\tcontent: []byte(set),\n\t}\n}\n\n// String satisfies the fmt.Stringer interface, returns a human-readable string\n// representation of the set.\nfunc (set CompressedSet) String() string {\n\tb := bytes.Buffer{}\n\tb.WriteByte('[')\n\tset.writeTo(&b)\n\tb.WriteByte(']')\n\treturn b.String()\n}\n\n// String satisfies the fmt.GoStringer interface, returns a Go representation of\n// the set.\nfunc (set CompressedSet) GoString() string {\n\tb := bytes.Buffer{}\n\tb.WriteString(\"ksuid.CompressedSet{\")\n\tset.writeTo(&b)\n\tb.WriteByte('}')\n\treturn b.String()\n}\n\nfunc (set CompressedSet) writeTo(b *bytes.Buffer) {\n\ta := [27]byte{}\n\n\tfor i, it := 0, set.Iter(); it.Next(); i++ {\n\t\tif i != 0 {\n\t\t\tb.WriteString(\", \")\n\t\t}\n\t\tb.WriteByte('\"')\n\t\tit.KSUID.Append(a[:0])\n\t\tb.Write(a[:])\n\t\tb.WriteByte('\"')\n\t}\n}\n\n// Compress creates and returns a compressed set of KSUIDs from the list given\n// as arguments.\nfunc Compress(ids ...KSUID) CompressedSet {\n\tc := 1 + byteLength + (len(ids) / 5)\n\tb := make([]byte, 0, c)\n\treturn AppendCompressed(b, ids...)\n}\n\n// AppendCompressed uses the given byte slice as pre-allocated storage space to\n// build a KSUID set.\n//\n// Note that the set uses a compression technique to store the KSUIDs, so the\n// resuling length is not 20 x len(ids). The rule of thumb here is for the given\n// byte slice to reserve the amount of memory that the application would be OK\n// to waste.\nfunc AppendCompressed(set []byte, ids ...KSUID) CompressedSet {\n\tif len(ids) != 0 {\n\t\tif !IsSorted(ids) {\n\t\t\tSort(ids)\n\t\t}\n\t\tone := makeUint128(0, 1)\n\n\t\t// The first KSUID is always written to the set, this is the starting\n\t\t// point for all deltas.\n\t\tset = append(set, byte(rawKSUID))\n\t\tset = append(set, ids[0][:]...)\n\n\t\ttimestamp := ids[0].Timestamp()\n\t\tlastKSUID := ids[0]\n\t\tlastValue := uint128Payload(ids[0])\n\n\t\tfor i := 1; i != len(ids); i++ {\n\t\t\tid := ids[i]\n\n\t\t\tif id == lastKSUID {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tt := id.Timestamp()\n\t\t\tv := uint128Payload(id)\n\n\t\t\tif t != timestamp {\n\t\t\t\td := t - timestamp\n\t\t\t\tn := varintLength32(d)\n\n\t\t\t\tset = append(set, timeDelta|byte(n))\n\t\t\t\tset = appendVarint32(set, d, n)\n\t\t\t\tset = append(set, id[timestampLengthInBytes:]...)\n\n\t\t\t\ttimestamp = t\n\t\t\t} else {\n\t\t\t\td := sub128(v, lastValue)\n\n\t\t\t\tif d != one {\n\t\t\t\t\tn := varintLength128(d)\n\n\t\t\t\t\tset = append(set, payloadDelta|byte(n))\n\t\t\t\t\tset = appendVarint128(set, d, n)\n\t\t\t\t} else {\n\t\t\t\t\tl, c := rangeLength(ids[i+1:], t, id, v)\n\t\t\t\t\tm := uint64(l + 1)\n\t\t\t\t\tn := varintLength64(m)\n\n\t\t\t\t\tset = append(set, payloadRange|byte(n))\n\t\t\t\t\tset = appendVarint64(set, m, n)\n\n\t\t\t\t\ti += c\n\t\t\t\t\tid = ids[i]\n\t\t\t\t\tv = uint128Payload(id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastKSUID = id\n\t\t\tlastValue = v\n\t\t}\n\t}\n\treturn CompressedSet(set)\n}\n\nfunc rangeLength(ids []KSUID, timestamp uint32, lastKSUID KSUID, lastValue uint128) (length int, count int) {\n\tone := makeUint128(0, 1)\n\n\tfor i := range ids {\n\t\tid := ids[i]\n\n\t\tif id == lastKSUID {\n\t\t\tcontinue\n\t\t}\n\n\t\tif id.Timestamp() != timestamp {\n\t\t\tcount = i\n\t\t\treturn\n\t\t}\n\n\t\tv := uint128Payload(id)\n\n\t\tif sub128(v, lastValue) != one {\n\t\t\tcount = i\n\t\t\treturn\n\t\t}\n\n\t\tlastKSUID = id\n\t\tlastValue = v\n\t\tlength++\n\t}\n\n\tcount = len(ids)\n\treturn\n}\n\nfunc appendVarint128(b []byte, v uint128, n int) []byte {\n\tc := v.bytes()\n\treturn append(b, c[len(c)-n:]...)\n}\n\nfunc appendVarint64(b []byte, v uint64, n int) []byte {\n\tc := [8]byte{}\n\tbinary.BigEndian.PutUint64(c[:], v)\n\treturn append(b, c[len(c)-n:]...)\n}\n\nfunc appendVarint32(b []byte, v uint32, n int) []byte {\n\tc := [4]byte{}\n\tbinary.BigEndian.PutUint32(c[:], v)\n\treturn append(b, c[len(c)-n:]...)\n}\n\nfunc varint128(b []byte) uint128 {\n\ta := [16]byte{}\n\tcopy(a[16-len(b):], b)\n\treturn makeUint128FromPayload(a[:])\n}\n\nfunc varint64(b []byte) uint64 {\n\ta := [8]byte{}\n\tcopy(a[8-len(b):], b)\n\treturn binary.BigEndian.Uint64(a[:])\n}\n\nfunc varint32(b []byte) uint32 {\n\ta := [4]byte{}\n\tcopy(a[4-len(b):], b)\n\treturn binary.BigEndian.Uint32(a[:])\n}\n\nfunc varintLength128(v uint128) int {\n\tif v[1] != 0 {\n\t\treturn 8 + varintLength64(v[1])\n\t}\n\treturn varintLength64(v[0])\n}\n\nfunc varintLength64(v uint64) int {\n\tswitch {\n\tcase (v & 0xFFFFFFFFFFFFFF00) == 0:\n\t\treturn 1\n\tcase (v & 0xFFFFFFFFFFFF0000) == 0:\n\t\treturn 2\n\tcase (v & 0xFFFFFFFFFF000000) == 0:\n\t\treturn 3\n\tcase (v & 0xFFFFFFFF00000000) == 0:\n\t\treturn 4\n\tcase (v & 0xFFFFFF0000000000) == 0:\n\t\treturn 5\n\tcase (v & 0xFFFF000000000000) == 0:\n\t\treturn 6\n\tcase (v & 0xFF00000000000000) == 0:\n\t\treturn 7\n\tdefault:\n\t\treturn 8\n\t}\n}\n\nfunc varintLength32(v uint32) int {\n\tswitch {\n\tcase (v & 0xFFFFFF00) == 0:\n\t\treturn 1\n\tcase (v & 0xFFFF0000) == 0:\n\t\treturn 2\n\tcase (v & 0xFF000000) == 0:\n\t\treturn 3\n\tdefault:\n\t\treturn 4\n\t}\n}\n\nconst (\n\trawKSUID     = 0\n\ttimeDelta    = (1 << 6)\n\tpayloadDelta = (1 << 7)\n\tpayloadRange = (1 << 6) | (1 << 7)\n)\n\n// CompressedSetIter is an iterator type returned by Set.Iter to produce the\n// list of KSUIDs stored in a set.\n//\n// Here's is how the iterator type is commonly used:\n//\n//\tfor it := set.Iter(); it.Next(); {\n//\t\tid := it.KSUID\n//\t\t// ...\n//\t}\n//\n// CompressedSetIter values are not safe to use concurrently from multiple\n// goroutines.\ntype CompressedSetIter struct {\n\t// KSUID is modified by calls to the Next method to hold the KSUID loaded\n\t// by the iterator.\n\tKSUID KSUID\n\n\tcontent []byte\n\toffset  int\n\n\tseqlength uint64\n\ttimestamp uint32\n\tlastValue uint128\n}\n\n// Next moves the iterator forward, returning true if there a KSUID was found,\n// or false if the iterator as reached the end of the set it was created from.\nfunc (it *CompressedSetIter) Next() bool {\n\tif it.seqlength != 0 {\n\t\tvalue := incr128(it.lastValue)\n\t\tit.KSUID = value.ksuid(it.timestamp)\n\t\tit.seqlength--\n\t\tit.lastValue = value\n\t\treturn true\n\t}\n\n\tif it.offset == len(it.content) {\n\t\treturn false\n\t}\n\n\tb := it.content[it.offset]\n\tit.offset++\n\n\tconst mask = rawKSUID | timeDelta | payloadDelta | payloadRange\n\ttag := int(b) & mask\n\tcnt := int(b) & ^mask\n\n\tswitch tag {\n\tcase rawKSUID:\n\t\toff0 := it.offset\n\t\toff1 := off0 + byteLength\n\n\t\tcopy(it.KSUID[:], it.content[off0:off1])\n\n\t\tit.offset = off1\n\t\tit.timestamp = it.KSUID.Timestamp()\n\t\tit.lastValue = uint128Payload(it.KSUID)\n\n\tcase timeDelta:\n\t\toff0 := it.offset\n\t\toff1 := off0 + cnt\n\t\toff2 := off1 + payloadLengthInBytes\n\n\t\tit.timestamp += varint32(it.content[off0:off1])\n\n\t\tbinary.BigEndian.PutUint32(it.KSUID[:timestampLengthInBytes], it.timestamp)\n\t\tcopy(it.KSUID[timestampLengthInBytes:], it.content[off1:off2])\n\n\t\tit.offset = off2\n\t\tit.lastValue = uint128Payload(it.KSUID)\n\n\tcase payloadDelta:\n\t\toff0 := it.offset\n\t\toff1 := off0 + cnt\n\n\t\tdelta := varint128(it.content[off0:off1])\n\t\tvalue := add128(it.lastValue, delta)\n\n\t\tit.KSUID = value.ksuid(it.timestamp)\n\t\tit.offset = off1\n\t\tit.lastValue = value\n\n\tcase payloadRange:\n\t\toff0 := it.offset\n\t\toff1 := off0 + cnt\n\n\t\tvalue := incr128(it.lastValue)\n\t\tit.KSUID = value.ksuid(it.timestamp)\n\t\tit.seqlength = varint64(it.content[off0:off1])\n\t\tit.offset = off1\n\t\tit.seqlength--\n\t\tit.lastValue = value\n\n\tdefault:\n\t\tpanic(\"KSUID set iterator is reading malformed data\")\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "set_test.go",
          "type": "blob",
          "size": 7.232421875,
          "content": "package ksuid\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestCompressedSet(t *testing.T) {\n\ttests := []struct {\n\t\tscenario string\n\t\tfunction func(*testing.T)\n\t}{\n\t\t{\n\t\t\tscenario: \"String\",\n\t\t\tfunction: testCompressedSetString,\n\t\t},\n\t\t{\n\t\t\tscenario: \"GoString\",\n\t\t\tfunction: testCompressedSetGoString,\n\t\t},\n\t\t{\n\t\t\tscenario: \"sparse\",\n\t\t\tfunction: testCompressedSetSparse,\n\t\t},\n\t\t{\n\t\t\tscenario: \"packed\",\n\t\t\tfunction: testCompressedSetPacked,\n\t\t},\n\t\t{\n\t\t\tscenario: \"mixed\",\n\t\t\tfunction: testCompressedSetMixed,\n\t\t},\n\t\t{\n\t\t\tscenario: \"iterating over a nil compressed set returns no ids\",\n\t\t\tfunction: testCompressedSetNil,\n\t\t},\n\t\t{\n\t\t\tscenario: \"concatenating multiple compressed sets is supported\",\n\t\t\tfunction: testCompressedSetConcat,\n\t\t},\n\t\t{\n\t\t\tscenario: \"duplicate ids are appear only once in the compressed set\",\n\t\t\tfunction: testCompressedSetDuplicates,\n\t\t},\n\t\t{\n\t\t\tscenario: \"building a compressed set with a single id repeated multiple times produces the id only once\",\n\t\t\tfunction: testCompressedSetSingle,\n\t\t},\n\t\t{\n\t\t\tscenario: \"iterating over a compressed sequence returns the full sequence\",\n\t\t\tfunction: testCompressedSetSequence,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.scenario, test.function)\n\t}\n}\n\nfunc testCompressedSetString(t *testing.T) {\n\tid1, _ := Parse(\"0uHjRkQoL2JKAQIULPdqqb5fOkk\")\n\tid2, _ := Parse(\"0uHjRvkOG5CbtoXW5oCEp3L2xBu\")\n\tid3, _ := Parse(\"0uHjSJ4Pe5606kT2XWixK6dirlo\")\n\n\tset := Compress(id1, id2, id3)\n\n\tif s := set.String(); s != `[\"0uHjRkQoL2JKAQIULPdqqb5fOkk\", \"0uHjRvkOG5CbtoXW5oCEp3L2xBu\", \"0uHjSJ4Pe5606kT2XWixK6dirlo\"]` {\n\t\tt.Error(s)\n\t}\n}\n\nfunc testCompressedSetGoString(t *testing.T) {\n\tid1, _ := Parse(\"0uHjRkQoL2JKAQIULPdqqb5fOkk\")\n\tid2, _ := Parse(\"0uHjRvkOG5CbtoXW5oCEp3L2xBu\")\n\tid3, _ := Parse(\"0uHjSJ4Pe5606kT2XWixK6dirlo\")\n\n\tset := Compress(id1, id2, id3)\n\n\tif s := set.GoString(); s != `ksuid.CompressedSet{\"0uHjRkQoL2JKAQIULPdqqb5fOkk\", \"0uHjRvkOG5CbtoXW5oCEp3L2xBu\", \"0uHjSJ4Pe5606kT2XWixK6dirlo\"}` {\n\t\tt.Error(s)\n\t}\n}\n\nfunc testCompressedSetSparse(t *testing.T) {\n\tnow := time.Now()\n\n\ttimes := [100]time.Time{}\n\tfor i := range times {\n\t\ttimes[i] = now.Add(time.Duration(i) * 2 * time.Second)\n\t}\n\n\tksuids := [1000]KSUID{}\n\tfor i := range ksuids {\n\t\tksuids[i], _ = NewRandomWithTime(times[i%len(times)])\n\t}\n\n\tset := Compress(ksuids[:]...)\n\n\tfor i, it := 0, set.Iter(); it.Next(); {\n\t\tif i >= len(ksuids) {\n\t\t\tt.Error(\"too many KSUIDs were produced by the set iterator\")\n\t\t\tbreak\n\t\t}\n\t\tif ksuids[i] != it.KSUID {\n\t\t\tt.Errorf(\"bad KSUID at index %d: expected %s but found %s\", i, ksuids[i], it.KSUID)\n\t\t}\n\t\ti++\n\t}\n\n\treportCompressionRatio(t, ksuids[:], set)\n}\n\nfunc testCompressedSetPacked(t *testing.T) {\n\tsequences := [10]Sequence{}\n\tfor i := range sequences {\n\t\tsequences[i] = Sequence{Seed: New()}\n\t}\n\n\tksuids := [1000]KSUID{}\n\tfor i := range ksuids {\n\t\tksuids[i], _ = sequences[i%len(sequences)].Next()\n\t}\n\n\tset := Compress(ksuids[:]...)\n\n\tfor i, it := 0, set.Iter(); it.Next(); {\n\t\tif i >= len(ksuids) {\n\t\t\tt.Error(\"too many KSUIDs were produced by the set iterator\")\n\t\t\tbreak\n\t\t}\n\t\tif ksuids[i] != it.KSUID {\n\t\t\tt.Errorf(\"bad KSUID at index %d: expected %s but found %s\", i, ksuids[i], it.KSUID)\n\t\t}\n\t\ti++\n\t}\n\n\treportCompressionRatio(t, ksuids[:], set)\n}\n\nfunc testCompressedSetMixed(t *testing.T) {\n\tnow := time.Now()\n\n\ttimes := [20]time.Time{}\n\tfor i := range times {\n\t\ttimes[i] = now.Add(time.Duration(i) * 2 * time.Second)\n\t}\n\n\tsequences := [200]Sequence{}\n\tfor i := range sequences {\n\t\tseed, _ := NewRandomWithTime(times[i%len(times)])\n\t\tsequences[i] = Sequence{Seed: seed}\n\t}\n\n\tksuids := [1000]KSUID{}\n\tfor i := range ksuids {\n\t\tksuids[i], _ = sequences[i%len(sequences)].Next()\n\t}\n\n\tset := Compress(ksuids[:]...)\n\n\tfor i, it := 0, set.Iter(); it.Next(); {\n\t\tif i >= len(ksuids) {\n\t\t\tt.Error(\"too many KSUIDs were produced by the set iterator\")\n\t\t\tbreak\n\t\t}\n\t\tif ksuids[i] != it.KSUID {\n\t\t\tt.Errorf(\"bad KSUID at index %d: expected %s but found %s\", i, ksuids[i], it.KSUID)\n\t\t}\n\t\ti++\n\t}\n\n\treportCompressionRatio(t, ksuids[:], set)\n}\n\nfunc testCompressedSetDuplicates(t *testing.T) {\n\tsequence := Sequence{Seed: New()}\n\n\tksuids := [1000]KSUID{}\n\tfor i := range ksuids[:10] {\n\t\tksuids[i], _ = sequence.Next() // exercise dedupe on the id range code path\n\t}\n\tfor i := range ksuids[10:] {\n\t\tksuids[i+10] = New()\n\t}\n\tfor i := 1; i < len(ksuids); i += 4 {\n\t\tksuids[i] = ksuids[i-1] // generate many dupes\n\t}\n\n\tmiss := make(map[KSUID]struct{})\n\tuniq := make(map[KSUID]struct{})\n\n\tfor _, id := range ksuids {\n\t\tmiss[id] = struct{}{}\n\t}\n\n\tset := Compress(ksuids[:]...)\n\n\tfor it := set.Iter(); it.Next(); {\n\t\tif _, dupe := uniq[it.KSUID]; dupe {\n\t\t\tt.Errorf(\"duplicate id found in compressed set: %s\", it.KSUID)\n\t\t}\n\t\tuniq[it.KSUID] = struct{}{}\n\t\tdelete(miss, it.KSUID)\n\t}\n\n\tif len(miss) != 0 {\n\t\tt.Error(\"some ids were not found in the compressed set:\")\n\t\tfor id := range miss {\n\t\t\tt.Log(id)\n\t\t}\n\t}\n}\n\nfunc testCompressedSetSingle(t *testing.T) {\n\tid := New()\n\n\tset := Compress(\n\t\tid, id, id, id, id, id, id, id, id, id,\n\t\tid, id, id, id, id, id, id, id, id, id,\n\t\tid, id, id, id, id, id, id, id, id, id,\n\t\tid, id, id, id, id, id, id, id, id, id,\n\t)\n\n\tn := 0\n\n\tfor it := set.Iter(); it.Next(); {\n\t\tif n != 0 {\n\t\t\tt.Errorf(\"too many ids found in the compressed set: %s\", it.KSUID)\n\t\t} else if id != it.KSUID {\n\t\t\tt.Errorf(\"invalid id found in the compressed set: %s != %s\", it.KSUID, id)\n\t\t}\n\t\tn++\n\t}\n\n\tif n == 0 {\n\t\tt.Error(\"no ids were produced by the compressed set\")\n\t}\n}\n\nfunc testCompressedSetSequence(t *testing.T) {\n\tseq := Sequence{Seed: New()}\n\n\tids := make([]KSUID, 5)\n\n\tfor i := 0; i < 5; i++ {\n\t\tids[i], _ = seq.Next()\n\t}\n\n\titer := Compress(ids...).Iter()\n\n\tindex := 0\n\tfor iter.Next() {\n\t\tif iter.KSUID != ids[index] {\n\t\t\tt.Errorf(\"mismatched id at index %d: %s != %s\", index, iter.KSUID, ids[index])\n\t\t}\n\t\tindex++\n\t}\n\n\tif index != 5 {\n\t\tt.Errorf(\"Expected 5 ids, got %d\", index)\n\t}\n}\n\nfunc testCompressedSetNil(t *testing.T) {\n\tset := CompressedSet(nil)\n\n\tfor it := set.Iter(); it.Next(); {\n\t\tt.Errorf(\"too many ids returned by the iterator of a nil compressed set: %s\", it.KSUID)\n\t}\n}\n\nfunc testCompressedSetConcat(t *testing.T) {\n\tksuids := [100]KSUID{}\n\n\tfor i := range ksuids {\n\t\tksuids[i] = New()\n\t}\n\n\tset := CompressedSet(nil)\n\tset = AppendCompressed(set, ksuids[:42]...)\n\tset = AppendCompressed(set, ksuids[42:64]...)\n\tset = AppendCompressed(set, ksuids[64:]...)\n\n\tfor i, it := 0, set.Iter(); it.Next(); i++ {\n\t\tif ksuids[i] != it.KSUID {\n\t\t\tt.Errorf(\"invalid ID at index %d: %s != %s\", i, ksuids[i], it.KSUID)\n\t\t}\n\t}\n}\n\nfunc reportCompressionRatio(t *testing.T, ksuids []KSUID, set CompressedSet) {\n\tlen1 := byteLength * len(ksuids)\n\tlen2 := len(set)\n\tt.Logf(\"original %d B, compressed %d B (%.4g%%)\", len1, len2, 100*(1-(float64(len2)/float64(len1))))\n}\n\nfunc BenchmarkCompressedSet(b *testing.B) {\n\tksuids1 := [1000]KSUID{}\n\tksuids2 := [1000]KSUID{}\n\n\tfor i := range ksuids1 {\n\t\tksuids1[i] = New()\n\t}\n\n\tksuids2 = ksuids1\n\tbuf := make([]byte, 0, 1024)\n\tset := Compress(ksuids2[:]...)\n\n\tb.Run(\"write\", func(b *testing.B) {\n\t\tn := 0\n\t\tfor i := 0; i != b.N; i++ {\n\t\t\tksuids2 = ksuids1\n\t\t\tbuf = AppendCompressed(buf[:0], ksuids2[:]...)\n\t\t\tn = len(buf)\n\t\t}\n\t\tb.SetBytes(int64(n + len(ksuids2)))\n\t})\n\n\tb.Run(\"read\", func(b *testing.B) {\n\t\tn := 0\n\t\tfor i := 0; i != b.N; i++ {\n\t\t\tn = 0\n\t\t\tfor it := set.Iter(); true; {\n\t\t\t\tif !it.Next() {\n\t\t\t\t\tn++\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb.SetBytes(int64((n * byteLength) + len(set)))\n\t})\n}\n"
        },
        {
          "name": "uint128.go",
          "type": "blob",
          "size": 1.5068359375,
          "content": "package ksuid\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"math/bits\"\n)\n\n// uint128 represents an unsigned 128 bits little endian integer.\ntype uint128 [2]uint64\n\nfunc uint128Payload(ksuid KSUID) uint128 {\n\treturn makeUint128FromPayload(ksuid[timestampLengthInBytes:])\n}\n\nfunc makeUint128(high uint64, low uint64) uint128 {\n\treturn uint128{low, high}\n}\n\nfunc makeUint128FromPayload(payload []byte) uint128 {\n\treturn uint128{\n\t\tbinary.BigEndian.Uint64(payload[8:]), // low\n\t\tbinary.BigEndian.Uint64(payload[:8]), // high\n\t}\n}\n\nfunc (v uint128) ksuid(timestamp uint32) (out KSUID) {\n\tbinary.BigEndian.PutUint32(out[:4], timestamp) // time\n\tbinary.BigEndian.PutUint64(out[4:12], v[1])    // high\n\tbinary.BigEndian.PutUint64(out[12:], v[0])     // low\n\treturn\n}\n\nfunc (v uint128) bytes() (out [16]byte) {\n\tbinary.BigEndian.PutUint64(out[:8], v[1])\n\tbinary.BigEndian.PutUint64(out[8:], v[0])\n\treturn\n}\n\nfunc (v uint128) String() string {\n\treturn fmt.Sprintf(\"0x%016X%016X\", v[0], v[1])\n}\n\nfunc cmp128(x, y uint128) int {\n\tif x[1] < y[1] {\n\t\treturn -1\n\t}\n\tif x[1] > y[1] {\n\t\treturn 1\n\t}\n\tif x[0] < y[0] {\n\t\treturn -1\n\t}\n\tif x[0] > y[0] {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc add128(x, y uint128) (z uint128) {\n\tvar c uint64\n\tz[0], c = bits.Add64(x[0], y[0], 0)\n\tz[1], _ = bits.Add64(x[1], y[1], c)\n\treturn\n}\n\nfunc sub128(x, y uint128) (z uint128) {\n\tvar b uint64\n\tz[0], b = bits.Sub64(x[0], y[0], 0)\n\tz[1], _ = bits.Sub64(x[1], y[1], b)\n\treturn\n}\n\nfunc incr128(x uint128) (z uint128) {\n\tvar c uint64\n\tz[0], c = bits.Add64(x[0], 1, 0)\n\tz[1] = x[1] + c\n\treturn\n}\n"
        },
        {
          "name": "uint128_test.go",
          "type": "blob",
          "size": 2.7412109375,
          "content": "package ksuid\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestCmp128(t *testing.T) {\n\ttests := []struct {\n\t\tx uint128\n\t\ty uint128\n\t\tk int\n\t}{\n\t\t{\n\t\t\tx: makeUint128(0, 0),\n\t\t\ty: makeUint128(0, 0),\n\t\t\tk: 0,\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 1),\n\t\t\ty: makeUint128(0, 0),\n\t\t\tk: +1,\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 0),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tk: -1,\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(1, 0),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tk: +1,\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 1),\n\t\t\ty: makeUint128(1, 0),\n\t\t\tk: -1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"cmp128(%s,%s)\", test.x, test.y), func(t *testing.T) {\n\t\t\tif k := cmp128(test.x, test.y); k != test.k {\n\t\t\t\tt.Error(k, \"!=\", test.k)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAdd128(t *testing.T) {\n\ttests := []struct {\n\t\tx uint128\n\t\ty uint128\n\t\tz uint128\n\t}{\n\t\t{\n\t\t\tx: makeUint128(0, 0),\n\t\t\ty: makeUint128(0, 0),\n\t\t\tz: makeUint128(0, 0),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 1),\n\t\t\ty: makeUint128(0, 0),\n\t\t\tz: makeUint128(0, 1),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 0),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tz: makeUint128(0, 1),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(1, 0),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tz: makeUint128(1, 1),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 1),\n\t\t\ty: makeUint128(1, 0),\n\t\t\tz: makeUint128(1, 1),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 0xFFFFFFFFFFFFFFFF),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tz: makeUint128(1, 0),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"add128(%s,%s)\", test.x, test.y), func(t *testing.T) {\n\t\t\tif z := add128(test.x, test.y); z != test.z {\n\t\t\t\tt.Error(z, \"!=\", test.z)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSub128(t *testing.T) {\n\ttests := []struct {\n\t\tx uint128\n\t\ty uint128\n\t\tz uint128\n\t}{\n\t\t{\n\t\t\tx: makeUint128(0, 0),\n\t\t\ty: makeUint128(0, 0),\n\t\t\tz: makeUint128(0, 0),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 1),\n\t\t\ty: makeUint128(0, 0),\n\t\t\tz: makeUint128(0, 1),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 0),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tz: makeUint128(0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(1, 0),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tz: makeUint128(0, 0xFFFFFFFFFFFFFFFF),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 1),\n\t\t\ty: makeUint128(1, 0),\n\t\t\tz: makeUint128(0xFFFFFFFFFFFFFFFF, 1),\n\t\t},\n\t\t{\n\t\t\tx: makeUint128(0, 0xFFFFFFFFFFFFFFFF),\n\t\t\ty: makeUint128(0, 1),\n\t\t\tz: makeUint128(0, 0xFFFFFFFFFFFFFFFE),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"sub128(%s,%s)\", test.x, test.y), func(t *testing.T) {\n\t\t\tif z := sub128(test.x, test.y); z != test.z {\n\t\t\t\tt.Error(z, \"!=\", test.z)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkCmp128(b *testing.B) {\n\tx := makeUint128(0, 0)\n\ty := makeUint128(0, 0)\n\n\tfor i := 0; i != b.N; i++ {\n\t\tcmp128(x, y)\n\t}\n}\n\nfunc BenchmarkAdd128(b *testing.B) {\n\tx := makeUint128(0, 0)\n\ty := makeUint128(0, 0)\n\n\tfor i := 0; i != b.N; i++ {\n\t\tadd128(x, y)\n\t}\n}\n\nfunc BenchmarkSub128(b *testing.B) {\n\tx := makeUint128(0, 0)\n\ty := makeUint128(0, 0)\n\n\tfor i := 0; i != b.N; i++ {\n\t\tsub128(x, y)\n\t}\n}\n"
        }
      ]
    }
  ]
}