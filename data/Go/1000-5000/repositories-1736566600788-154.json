{
  "metadata": {
    "timestamp": 1736566600788,
    "page": 154,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "coyove/goflyway",
      "stars": 4306,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 5.0927734375,
          "content": "top-1m.csv\ndebug\nlaunch.json\n*.exe\n*.dll\n*.a\n*.csv.*\n.vscode\nbuild/\n.DS_Store\nca.pem\nkey.pem\ngfw.conf\n\n## Ignore Visual Studio temporary files, build results, and\n## files generated by popular Visual Studio add-ons.\n##\n## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore\n\n# User-specific files\n*.suo\n*.user\n*.userosscache\n*.sln.docstates\n\n# User-specific files (MonoDevelop/Xamarin Studio)\n*.userprefs\n\n# Build results\n[Dd]ebug/\n[Dd]ebugPublic/\n[Rr]elease/\n[Rr]eleases/\nx64/\nx86/\nbld/\n[Bb]in/\n[Oo]bj/\n[Ll]og/\n\n# Visual Studio 2015 cache/options directory\n.vs/\n# Uncomment if you have tasks that create the project's static files in wwwroot\n#wwwroot/\n\n# MSTest test Results\n[Tt]est[Rr]esult*/\n[Bb]uild[Ll]og.*\n\n# NUNIT\n*.VisualState.xml\nTestResult.xml\n\n# Build Results of an ATL Project\n[Dd]ebugPS/\n[Rr]eleasePS/\ndlldata.c\n\n# Benchmark Results\nBenchmarkDotNet.Artifacts/\n\n# .NET Core\nproject.lock.json\nproject.fragment.lock.json\nartifacts/\n**/Properties/launchSettings.json\n\n*_i.c\n*_p.c\n*_i.h\n*.ilk\n*.meta\n*.obj\n*.pch\n*.pdb\n*.pgc\n*.pgd\n*.rsp\n*.sbr\n*.tlb\n*.tli\n*.tlh\n*.tmp\n*.tmp_proj\n*.log\n*.vspscc\n*.vssscc\n.builds\n*.pidb\n*.svclog\n*.scc\n\n# Chutzpah Test files\n_Chutzpah*\n\n# Visual C++ cache files\nipch/\n*.aps\n*.ncb\n*.opendb\n*.opensdf\n*.sdf\n*.cachefile\n*.VC.db\n*.VC.VC.opendb\n\n# Visual Studio profiler\n*.psess\n*.vsp\n*.vspx\n*.sap\n\n# Visual Studio Trace Files\n*.e2e\n\n# TFS 2012 Local Workspace\n$tf/\n\n# Guidance Automation Toolkit\n*.gpState\n\n# ReSharper is a .NET coding add-in\n_ReSharper*/\n*.[Rr]e[Ss]harper\n*.DotSettings.user\n\n# JustCode is a .NET coding add-in\n.JustCode\n\n# TeamCity is a build add-in\n_TeamCity*\n\n# DotCover is a Code Coverage Tool\n*.dotCover\n\n# AxoCover is a Code Coverage Tool\n.axoCover/*\n!.axoCover/settings.json\n\n# Visual Studio code coverage results\n*.coverage\n*.coveragexml\n\n# NCrunch\n_NCrunch_*\n.*crunch*.local.xml\nnCrunchTemp_*\n\n# MightyMoose\n*.mm.*\nAutoTest.Net/\n\n# Web workbench (sass)\n.sass-cache/\n\n# Installshield output folder\n[Ee]xpress/\n\n# DocProject is a documentation generator add-in\nDocProject/buildhelp/\nDocProject/Help/*.HxT\nDocProject/Help/*.HxC\nDocProject/Help/*.hhc\nDocProject/Help/*.hhk\nDocProject/Help/*.hhp\nDocProject/Help/Html2\nDocProject/Help/html\n\n# Click-Once directory\npublish/\n\n# Publish Web Output\n*.[Pp]ublish.xml\n*.azurePubxml\n# Note: Comment the next line if you want to checkin your web deploy settings,\n# but database connection strings (with potential passwords) will be unencrypted\n*.pubxml\n*.publishproj\n\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\n# checkin your Azure Web App publish settings, but sensitive information contained\n# in these scripts will be unencrypted\nPublishScripts/\n\n# NuGet Packages\n*.nupkg\n# The packages folder can be ignored because of Package Restore\n**/packages/*\n# except build/, which is used as an MSBuild target.\n!**/packages/build/\n# Uncomment if necessary however generally it will be regenerated when needed\n#!**/packages/repositories.config\n# NuGet v3's project.json files produces more ignorable files\n*.nuget.props\n*.nuget.targets\n\n# Microsoft Azure Build Output\ncsx/\n*.build.csdef\n\n# Microsoft Azure Emulator\necf/\nrcf/\n\n# Windows Store app package directories and files\nAppPackages/\nBundleArtifacts/\nPackage.StoreAssociation.xml\n_pkginfo.txt\n*.appx\n\n# Visual Studio cache files\n# files ending in .cache can be ignored\n*.[Cc]ache\n# but keep track of directories ending in .cache\n!*.[Cc]ache/\n\n# Others\nClientBin/\n~$*\n*~\n*.dbmdl\n*.dbproj.schemaview\n*.jfm\n*.pfx\n*.publishsettings\norleans.codegen.cs\n\n# Since there are multiple workflows, uncomment next line to ignore bower_components\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n#bower_components/\n\n# RIA/Silverlight projects\nGenerated_Code/\n\n# Backup & report files from converting an old project file\n# to a newer Visual Studio version. Backup files are not needed,\n# because we have git ;-)\n_UpgradeReport_Files/\nBackup*/\nUpgradeLog*.XML\nUpgradeLog*.htm\n\n# SQL Server files\n*.mdf\n*.ldf\n*.ndf\n\n# Business Intelligence projects\n*.rdl.data\n*.bim.layout\n*.bim_*.settings\n\n# Microsoft Fakes\nFakesAssemblies/\n\n# GhostDoc plugin setting file\n*.GhostDoc.xml\n\n# Node.js Tools for Visual Studio\n.ntvs_analysis.dat\nnode_modules/\n\n# Typescript v1 declaration files\ntypings/\n\n# Visual Studio 6 build log\n*.plg\n\n# Visual Studio 6 workspace options file\n*.opt\n\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\n*.vbw\n\n# Visual Studio LightSwitch build output\n**/*.HTMLClient/GeneratedArtifacts\n**/*.DesktopClient/GeneratedArtifacts\n**/*.DesktopClient/ModelManifest.xml\n**/*.Server/GeneratedArtifacts\n**/*.Server/ModelManifest.xml\n_Pvt_Extensions\n\n# Paket dependency manager\n.paket/paket.exe\npaket-files/\n\n# FAKE - F# Make\n.fake/\n\n# JetBrains Rider\n.idea/\n*.sln.iml\n\n# CodeRush\n.cr/\n\n# Python Tools for Visual Studio (PTVS)\n__pycache__/\n*.pyc\n\n# Cake - Uncomment if you are using it\n# tools/**\n# !tools/packages.config\n\n# Tabs Studio\n*.tss\n\n# Telerik's JustMock configuration file\n*.jmconfig\n\n# BizTalk build output\n*.btp.cs\n*.btm.cs\n*.odx.cs\n*.xsd.cs\n\n# OpenCover UI analysis results\nOpenCover/\nheap.txt\n*.keystore \ncmd/goflyway/lib\nshadowsocks*\n"
        },
        {
          "name": ".misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0693359375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2017 coyove <coyove@hotmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 3.599609375,
          "content": "package goflyway\n\nimport (\n\t\"context\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/coyove/goflyway/toh\"\n\t\"github.com/coyove/goflyway/v\"\n\n\t\"net\"\n)\n\ntype ClientConfig struct {\n\tcommonConfig\n\tUpstream    string\n\tBind        string\n\tURLHeader   string\n\tPathPattern string\n\tWebSocket   bool\n\tVPN         bool\n\tDynamic     bool\n}\n\nfunc NewClient(localaddr string, config *ClientConfig) error {\n\tconfig.check()\n\n\ttr := *http.DefaultTransport.(*http.Transport)\n\tif config.VPN {\n\t\ttr.DialContext = func(ctx context.Context, network string, address string) (net.Conn, error) {\n\t\t\treturn vpnDial(address)\n\t\t}\n\t}\n\n\tdialer := toh.NewDialer(config.Key, config.Upstream,\n\t\ttoh.WithWebSocket(config.WebSocket),\n\t\ttoh.WithInactiveTimeout(config.Timeout),\n\t\ttoh.WithTransport(&tr),\n\t\ttoh.WithMaxWriteBuffer(int(config.WriteBuffer)),\n\t\ttoh.WithHeader(config.URLHeader))\n\n\tmux, err := net.Listen(\"tcp\", localaddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tconn, err := mux.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgo func(conn net.Conn) {\n\t\t\tdownconn := toh.NewBufConn(conn)\n\t\t\tdefer conn.Close()\n\n\t\t\tvar bind = config.Bind\n\n\t\t\tif config.Dynamic {\n\t\t\t\tdst, err := handleSOCKS5(downconn)\n\t\t\t\tif err != nil {\n\t\t\t\t\tv.Eprint(\"SOCKS5 server error: \", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbind = dst\n\t\t\t\tv.Vprint(\"SOCKS5 destination: \", dst)\n\t\t\t}\n\n\t\t\tup, err := dialer.Dial()\n\n\t\t\tif err != nil {\n\t\t\t\tv.Eprint(\"dial server: \", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer up.Close()\n\n\t\t\tupconn := toh.NewBufConn(up)\n\t\t\tif _, err := upconn.Write([]byte(bind + \"\\n\")); err != nil {\n\t\t\t\tv.Eprint(\"failed to req: \", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tresp, err := upconn.ReadBytes('\\n')\n\t\t\tif err != nil || string(resp) != \"OK\\n\" {\n\t\t\t\tv.Eprint(\"server failed to ack: \", err, \", resp: \", string(resp))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif config.Dynamic {\n\t\t\t\t// SOCKS5 OK response\n\t\t\t\tdownconn.Write([]byte{0x05, 0, 0, 1, 0, 0, 0, 0, 0, 0})\n\t\t\t}\n\n\t\t\tBridge(upconn, downconn, nil, config.Stat)\n\t\t}(conn)\n\t}\n}\n\nfunc handleSOCKS5(conn net.Conn) (string, error) {\n\tbuf := make([]byte, 256)\n\tif _, err := io.ReadFull(conn, buf[:2]); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read header: %v\", err)\n\t}\n\n\tif buf[0] != 0x05 {\n\t\treturn \"\", fmt.Errorf(\"unsupported SOCKS version: %v\", buf[0])\n\t}\n\n\tnumMethods := int(buf[1])\n\tif _, err := io.ReadFull(conn, buf[:numMethods]); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read methods: %v\", err)\n\t}\n\n\tif numMethods > 1 {\n\t\tv.VVVprint(\"client supported methods: \", buf[:numMethods])\n\t}\n\n\t// TODO: auth\n\tif _, err := conn.Write([]byte{0x05, 0}); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to handshake: %v\", err)\n\t}\n\n\t// read destination\n\t_, err := io.ReadFull(conn, buf[:3+1])\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read destination: %v\", err)\n\t}\n\n\tvar addrsize int\n\tvar method = buf[3]\n\n\tswitch method {\n\tcase 0x01:\n\t\taddrsize = net.IPv4len + 2\n\tcase 0x04:\n\t\taddrsize = net.IPv6len + 2\n\tcase 0x03:\n\t\t// read one extra byte that indicates the length of the domain\n\t\tif _, err := io.ReadFull(conn, buf[:1]); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"failed to read domain destination: %v\", err)\n\t\t}\n\t\taddrsize = int(buf[0]) + 2\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"invalid address type: %v\", buf[3])\n\t}\n\n\tif _, err = io.ReadFull(conn, buf[:addrsize]); err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to read destination: %v\", err)\n\t}\n\n\tvar host string\n\tvar port = strconv.Itoa(int(binary.BigEndian.Uint16(buf[addrsize-2 : addrsize])))\n\n\tswitch method {\n\tcase 0x01, 0x04:\n\t\thost = net.IP(buf[:addrsize-2]).String()\n\tdefault:\n\t\thost = string(buf[:addrsize-2])\n\t}\n\n\tif strings.Contains(host, \":\") {\n\t\t// IPv6?\n\t\thost = \"[\" + host + \"]\"\n\t}\n\n\treturn host + \":\" + port, nil\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "fd",
          "type": "tree",
          "content": null
        },
        {
          "name": "io.go",
          "type": "blob",
          "size": 1.1240234375,
          "content": "package goflyway\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"sync/atomic\"\n\n\t. \"github.com/coyove/goflyway/v\"\n)\n\nfunc Bridge(target, source net.Conn, timeout *TokenBucket, stat *Traffic) {\n\tgo func() {\n\t\tif err := ioCopy(target, source, timeout, stat.Sent()); err != nil {\n\t\t\tEprint(\"bridge: \", err)\n\t\t}\n\t\ttarget.Close()\n\t\tsource.Close()\n\t}()\n\n\tif err := ioCopy(source, target, timeout, stat.Recv()); err != nil {\n\t\tEprint(\"bridge: \", err)\n\t}\n\n\t// Multiple closes, but for tohConn they are just fine\n\ttarget.Close()\n\tsource.Close()\n}\n\nfunc ioCopy(dst io.WriteCloser, src io.ReadCloser, bk *TokenBucket, bytes *int64) (err error) {\n\tbuf := make([]byte, 32*1024)\n\n\tfor {\n\t\tnr, er := src.Read(buf)\n\n\t\tif nr > 0 {\n\t\t\tif bk != nil {\n\t\t\t\tbk.Consume(int64(nr))\n\t\t\t}\n\n\t\t\tnw, ew := dst.Write(buf[0:nr])\n\n\t\t\tif nw > 0 && bytes != nil {\n\t\t\t\tatomic.AddInt64(bytes, int64(nw))\n\t\t\t}\n\n\t\t\tif ew != nil {\n\t\t\t\tif !isClosedConnErr(ew) && !isTimeoutErr(ew) {\n\t\t\t\t\terr = ew\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif nr != nw {\n\t\t\t\terr = io.ErrShortWrite\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif er != nil {\n\t\t\tif er != io.EOF && !isClosedConnErr(er) && !isTimeoutErr(er) {\n\t\t\t\terr = er\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn err\n}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 1.984375,
          "content": "# goflyway v2 - a local port forwarder built on HTTP\n\n![](https://raw.githubusercontent.com/coyove/goflyway/gdev/.misc/logo.png)\n\n`master` is the active develop branch and containing v2 code, for the stable v1 release (though it was once called v2.0), please refer to [v1.0 branch](https://github.com/coyove/goflyway/tree/v1.0).\n\ngoflyway v2 is a special tool to forward local ports to a remote server securly, just like `ssh -L`.\n\ngoflyway uses pure HTTP POST requests to relay TCP connections. There is no CONNECT involved nor needed because goflyway is designed mainly for those people who are behind a CONNECT-less HTTP proxy or want to accelerate connections through static CDNs.\n\nHowever pure HTTP requesting is definitely a waste of bandwidth if you already have a better network environment, so use `-w` to turn on WebSocket relay, or `-K` to turn on KCP relay if possible.\n\n## Usage\nForward `localhost:1080` to `server:1080` through `server:80`\n\n```\n    Server: ./goflyway :80\n    Client: ./goflyway -L 1080::1080 server:80 -p password\n```\n\nForward `localhost:1080` to `server2:1080` through `server:80` using WebSocket\n\n```\n    Server: ./goflyway :80\n    Client: ./goflyway -w -L 1080:server2:1080 server:80 -p password\n```\n\nDynamically forward `localhost:1080` to `server:80` \n\n```\n    Server: ./goflyway :80\n    Client: ./goflyway -D 1080 server:80 -p password\n```\n\nHTTP reverse proxy or static file server on the same port:\n\n```\n    ./goflyway :80 -P http://127.0.0.1:8080 \n    ./goflyway :80 -P /var/www/html\n```\n\n## Write Buffer\n\nIn HTTP mode when server received some data it can't just send them to the client directly because HTTP is not bi-directional, instead the server must wait until the client requests them, which means these data will be stored in memory for some time.\n\nYou can use `-W bytes` to limit the maximum bytes a server can buffer (for each connection), by default it is 1048576 (1M). If the buffer reaches the limit, the following bytes will be blocked until the buffer has free space for them.\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 1.8447265625,
          "content": "package goflyway\n\nimport (\n\t\"bytes\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/coyove/goflyway/toh\"\n\t. \"github.com/coyove/goflyway/v\"\n)\n\ntype commonConfig struct {\n\tWriteBuffer int64\n\tKey         string\n\tTimeout     time.Duration\n\tStat        *Traffic\n}\n\nfunc (config *commonConfig) check() {\n\tif config.Timeout == 0 {\n\t\tconfig.Timeout = time.Second * 15\n\t}\n\tif config.WriteBuffer == 0 {\n\t\tconfig.WriteBuffer = 1024 * 1024 // 1M\n\t}\n}\n\ntype ServerConfig struct {\n\tcommonConfig\n\tProxyPassAddr string\n\tSpeedThrot    *TokenBucket\n}\n\nfunc NewServer(listen string, config *ServerConfig) error {\n\tconfig.check()\n\n\trp := append([]toh.Option{}, toh.WithMaxWriteBuffer(int(config.WriteBuffer)))\n\n\tif config.ProxyPassAddr != \"\" {\n\t\tif strings.HasPrefix(config.ProxyPassAddr, \"http\") {\n\t\t\tu, err := url.Parse(config.ProxyPassAddr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trp = append(rp, toh.WithBadRequest(httputil.NewSingleHostReverseProxy(u).ServeHTTP))\n\t\t} else {\n\t\t\trp = append(rp, toh.WithBadRequest(http.FileServer(http.Dir(config.ProxyPassAddr)).ServeHTTP))\n\t\t}\n\t}\n\n\tlistener, err := toh.Listen(config.Key, listen, rp...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tgo func(conn net.Conn) {\n\t\t\tdown := toh.NewBufConn(conn)\n\t\t\tdefer down.Close()\n\n\t\t\tbuf, err := down.ReadBytes('\\n')\n\t\t\tif err != nil || len(buf) < 2 {\n\t\t\t\tVprint(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\thost := string(bytes.TrimRight(buf, \"\\n\"))\n\n\t\t\tdialstart := time.Now()\n\t\t\tup, err := net.DialTimeout(\"tcp\", host, config.Timeout)\n\t\t\tif err != nil {\n\t\t\t\tVprint(host, err)\n\t\t\t\tdown.Write([]byte(err.Error() + \"\\n\"))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tVprint(\"dial \", host, \" in \", time.Since(dialstart).Nanoseconds()/1e6, \"ms\")\n\t\t\tdefer up.Close()\n\n\t\t\tdown.Write([]byte(\"OK\\n\"))\n\t\t\tBridge(up, down, config.SpeedThrot, config.Stat)\n\t\t}(conn)\n\t}\n}\n"
        },
        {
          "name": "ssvpn_interop.go",
          "type": "blob",
          "size": 2.669921875,
          "content": "// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n\npackage goflyway\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"net\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"unsafe\"\n\n\t\"github.com/coyove/goflyway/fd\"\n)\n\nfunc vpnDial(address string) (net.Conn, error) {\n\tvar family int\n\tfamily = syscall.AF_INET\n\n\tif address[0] == '[' {\n\t\t// naive match\n\t\tfamily = syscall.AF_INET6\n\t}\n\n\tsock, err := fd.Socket(family)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Send our conn fd to shadowsocks vpn thread for protection\n\tif err := protectFD(sock); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If succeeded, this fd will be closed while we still need it.\n\t// So we dial a new conn, replace its fd with this one\n\treturn fd.DialWithFD(sock, address)\n}\n\nfunc protectFD(fd int) error {\n\tsock, err := syscall.Socket(syscall.AF_UNIX, syscall.SOCK_STREAM, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addr syscall.SockaddrUnix\n\taddr.Name = \"protect_path\"\n\n\tif err := (syscall.Connect(sock, &addr)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := sendFD(sock, fd); err != nil {\n\t\treturn err\n\t}\n\n\tret := []byte{9}\n\tif n, err := syscall.Read(sock, ret); err != nil {\n\t\treturn err\n\t} else if n != 1 {\n\t\treturn errors.New(\"protecting failed\")\n\t}\n\n\tsyscall.Close(sock)\n\n\tif ret[0] != 0 {\n\t\treturn errors.New(\"protecting failed\")\n\t}\n\n\treturn nil\n}\n\nfunc sendTrafficStats(recv, send int64) error {\n\tconst errm = \"sending traffic stats failed\"\n\n\tsock, err := syscall.Socket(syscall.AF_UNIX, syscall.SOCK_STREAM, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addr syscall.SockaddrUnix\n\taddr.Name = \"stat_path\"\n\n\tif err := (syscall.Connect(sock, &addr)); err != nil {\n\t\treturn err\n\t}\n\n\tpayload := make([]byte, 16)\n\tbinary.LittleEndian.PutUint64(payload, uint64(send))\n\tbinary.LittleEndian.PutUint64(payload[8:], uint64(recv))\n\n\tif n, err := syscall.Write(sock, payload); err != nil {\n\t\treturn err\n\t} else if n != 16 {\n\t\treturn errors.New(errm)\n\t}\n\n\tret := []byte{9}\n\tif n, err := syscall.Read(sock, ret); err != nil {\n\t\treturn err\n\t} else if n != 1 {\n\t\treturn errors.New(errm)\n\t}\n\n\tsyscall.Close(sock)\n\n\tif ret[0] != 0 {\n\t\treturn errors.New(errm)\n\t}\n\n\treturn nil\n}\n\nvar _int_value_one int = 1\nvar _little_endian = *(*byte)(unsafe.Pointer(&_int_value_one)) == 1\n\nfunc sendFD(sock int, fd int) error {\n\tcmsg := &syscall.Cmsghdr{\n\t\tLevel: syscall.SOL_SOCKET,\n\t\tType:  syscall.SCM_RIGHTS,\n\t}\n\n\tconst hdrsize = syscall.SizeofCmsghdr\n\tln := byte(hdrsize + strconv.IntSize/8)\n\th := (*[8]byte)(unsafe.Pointer(&cmsg.Len))\n\n\tif _little_endian {\n\t\th[0] = ln\n\t} else {\n\t\th[3+4*(^cmsg.Len<<32>>63)] = ln\n\t}\n\n\tbuffer := make([]byte, cmsg.Len)\n\n\tcopy(buffer, (*[hdrsize]byte)(unsafe.Pointer(cmsg))[:])\n\t*(*int)(unsafe.Pointer(&buffer[hdrsize])) = fd\n\n\treturn syscall.Sendmsg(sock, []byte{'!'}, buffer, nil, 0)\n}\n"
        },
        {
          "name": "ssvpn_windows.go",
          "type": "blob",
          "size": 0.171875,
          "content": "package goflyway\n\nimport (\n\t\"net\"\n)\n\nfunc vpnDial(address string) (net.Conn, error) {\n\tpanic(\"not on Windows\")\n}\n\nfunc sendTrafficStats(recv, send int64) error {\n\treturn nil\n}\n"
        },
        {
          "name": "toh",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 1.384765625,
          "content": "package goflyway\n\nimport (\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc isClosedConnErr(err error) bool {\n\treturn strings.Contains(err.Error(), \"use of closed\")\n}\n\nfunc isTimeoutErr(err error) bool {\n\tif ne, ok := err.(net.Error); ok {\n\t\treturn ne.Timeout()\n\t}\n\n\treturn false\n}\n\ntype TokenBucket struct {\n\tSpeed int64 // bytes per second\n\n\tcapacity    int64 // bytes\n\tmaxCapacity int64\n\tlastConsume time.Time\n\n\tmu sync.Mutex\n}\n\nfunc NewTokenBucket(speed, max int64) *TokenBucket {\n\treturn &TokenBucket{\n\t\tSpeed:       speed,\n\t\tlastConsume: time.Now(),\n\t\tmaxCapacity: max,\n\t}\n}\n\nfunc (tb *TokenBucket) Consume(n int64) {\n\ttb.mu.Lock()\n\tdefer tb.mu.Unlock()\n\n\tnow := time.Now()\n\n\tif tb.Speed == 0 {\n\t\ttb.lastConsume = now\n\t\treturn\n\t}\n\n\tms := now.Sub(tb.lastConsume).Nanoseconds() / 1e6\n\ttb.capacity += ms * tb.Speed / 1000\n\n\tif tb.capacity > tb.maxCapacity {\n\t\ttb.capacity = tb.maxCapacity\n\t}\n\n\tif n <= tb.capacity {\n\t\ttb.lastConsume = now\n\t\ttb.capacity -= n\n\t\treturn\n\t}\n\n\tsec := float64(n-tb.capacity) / float64(tb.Speed)\n\ttime.Sleep(time.Duration(sec*1000) * time.Millisecond)\n\n\ttb.capacity = 0\n\ttb.lastConsume = time.Now()\n}\n\ntype Traffic struct {\n\tsent     int64\n\treceived int64\n}\n\nfunc (t *Traffic) Set(s, r int64) {\n\tt.sent, t.received = s, r\n}\n\nfunc (t *Traffic) Sent() *int64 {\n\tif t == nil {\n\t\treturn nil\n\t}\n\treturn &t.sent\n}\n\nfunc (t *Traffic) Recv() *int64 {\n\tif t == nil {\n\t\treturn nil\n\t}\n\treturn &t.received\n}\n"
        },
        {
          "name": "v",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}