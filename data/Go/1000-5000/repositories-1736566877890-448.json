{
  "metadata": {
    "timestamp": 1736566877890,
    "page": 448,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "arl/statsviz",
      "stars": 3242,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0439453125,
          "content": "internal/static/** linguist-detectable=false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "*.test\nout\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.5078125,
          "content": "Unreleased\n==============\n  * Make all examples use statsviz@latest (#112)\n\nv0.6.0 / 2023-10-08\n==============\n  * New plots showing new go1.20/go1.21 runtime/metrics: (#111)\n    + GC Cycles\n    + GC Scan\n    + Memory classes\n    + CPU classes\n    + Mutex wait\n  * Users can now add their own plots (#111)\n  * Add light/dark mode selector (#108)\n\nv0.5.2 / 2023-03-29\n==============\n  * Ensure all files have a correct Content-Type (#106)\n\nv0.5.1 / 2022-09-30\n==============\n  * Fix UI on Firefox (#83)\n\nv0.5.0 / 2022-09-05\n==============\n  * Switch to runtime/metrics as source, major refactor (#75)\n    + New heatmap UI component\n    + Dynamic plots definition based on server side generated config\n    + Add many new plots (scheduler latency, scheduling events, and more)\n    + Add play/pause switch button\n    + Add show/hide GC events switch button\n    + Add time range selector (1m, 5m, 10m)\n  * Switch javascript code to ES6 (#65)\n  * Build and test all examples (#63)\n\nv0.4.1 / 2021-12-12\n==============\n  * Assets are `go:embed`ed, so the minimum go version is now go1.16 (#55)\n  * Polishing (README, small UI improvements) (#54)\n  * Small ui improvements: link to go.dev rather than golang.org\n\nv0.4.0 / 2021-05-08\n==================\n\n  * Auto-reconnect to new server from GUI after closed websocket connection (#49)\n  * Reorganize examples (#51)\n  * Make `IndexAtRoot` returns an `http.HandlerFunc` instead of `http.Handler` (#52)\n\nv0.3.0 / 2021-02-14\n==================\n\n  * Enable 'save as png' button on plots (#44)\n\nv0.2.2 / 2020-12-13\n==================\n\n  * Use Go Modules for 'github.com/gorilla/websocket' (#39)\n  * Support custom frequency (#37)\n  * Added fixed go-chi example (#38)\n  * `_example`: add echo (#22)\n  * `_example`: add gin example (#34)\n  * ci: track coverage\n  * RegisterDefault returns an error now\n  * Ensure send frequency is a strictly positive integer\n  * Don't log if we can't upgrade to websocket\n  * `_example`_example: add chi router (#38)\n  * `_example`_example: change structure to have one example per directory\n\nv0.2.1 / 2020-10-29\n===================\n\n  * Fix websocket handler now working with https (#25)\n\nv0.2.0 / 2020-10-25\n===================\n\n  * `Register` now accepts options (functional options API) (#20)\n    + `Root` allows to root statsviz at a path different than `/debug/statsviz`\n    + `SendFrequency` allows to set the frequency at which stats are emitted.\n\nv0.1.1 / 2020-10-12\n===================\n\n  * Do not leak timer in sendStats\n\nv0.1.0 / 2020-10-10\n===================\n\n  * First released version\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.099609375,
          "content": "Contributing\n============\n\nFirst of all, thank you for considering to contribute to Statsviz!\n\nPull-requests are welcome!\n\n\n## Go library\n\nThe Statsviz Go public API is relatively light so there's not much to do and at\nthe moment it's unlikely that the API will change. However new options can be\nadded to `statsviz.Register` and `statsviz.NewServer` without breaking\ncompatibility.\n\nThat being said, there may be things to improve in the implementation, any\ncontribution is very welcome!\n\nBig changes should be discussed on the issue tracker prior to start working on\nthe code.\n\nIf you've decided to contribute, thank you so much, please comment on the existing \nissue or create one stating what you want to tackle and why.\n\n\n## User interface (html/css/javascript)\n\nThe user interface aims to be simple, light and minimal.\n\nAssets are located in the `internal/static` directory and are embedded with\n[`go:embed`](https://pkg.go.dev/embed).\n\nDepending on what your modifications are, it's always a good idea to check that\nsome of the examples in [./_example](./_example/) work with your modifications\nto Statsviz. To do so `cd` to the directory of the example and run:\n\n    go mod edit -replace=github.com/arl/statsviz=../../\n\n\n## Documentation\n\nNo contribution is too small, improvements to code comments and/or README\nare welcome!\n\n\n## Examples\n\nThere are many Go libraries to handle HTTP requests, routing, etc..\n\nFeel free to add an example to show how to register Statsviz with your favourite\nlibrary.\n\nTo do so, please add a directory under `./_example`. For instance, if you want to add an\nexample showing how to register Statsviz within library `foobar`:\n\n - create a directory `./_example/foobar/`\n - create a file `./_example/foobar/main.go`\n - call `go example.Work()` as the first line of your example (see other\n   examples). This forces the garbage collector to _do something_ so that\n   Statsviz interface won't remain static when an user runs your example.\n - the code should be `gofmt`ed\n - the example should compile and run\n - when ran, Statsviz interface should be accessible at http://localhost:8080/debug/statsviz\n\n\nThank you!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "MIT License\n\nCopyright (c) 2021 Aur√©lien Rainone\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.990234375,
          "content": "[![go.dev reference](https://img.shields.io/badge/go.dev-reference-007d9c?logo=go&logoColor=white&style=round-square)](https://pkg.go.dev/github.com/arl/statsviz)\n[![Latest tag](https://img.shields.io/github/tag/arl/statsviz.svg)](https://github.com/arl/statsviz/tag/)\n[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge.svg)](https://github.com/avelino/awesome-go)\n\n[![Test Actions Status](https://github.com/arl/statsviz/workflows/Tests-linux/badge.svg)](https://github.com/arl/statsviz/actions)\n[![Test Actions Status](https://github.com/arl/statsviz/workflows/Tests-others/badge.svg)](https://github.com/arl/statsviz/actions)\n[![codecov](https://codecov.io/gh/arl/statsviz/branch/main/graph/badge.svg)](https://codecov.io/gh/arl/statsviz)\n\n# Statsviz\n\n<p align=\"center\">\n  <img alt=\"Statsviz Gopher Logo\" width=\"120\" src=\"https://raw.githubusercontent.com/arl/statsviz/readme-docs/logo.png?sanitize=true\">\n  <img alt=\"statsviz ui\" width=\"450\" align=\"right\" src=\"https://github.com/arl/statsviz/raw/readme-docs/window.png\">\n</p>\n<br/>\n\nVisualize real time plots of your Go program runtime metrics, including heap, objects, goroutines, GC pauses, scheduler and more, in your browser.\n\n<hr>\n\n- [Statsviz](#statsviz)\n  - [Install](#install)\n  - [Usage](#usage)\n  - [Advanced Usage](#advanced-usage)\n  - [How Does That Work?](#how-does-that-work)\n  - [Documentation](#documentation)\n    - [Go API](#go-api)\n    - [User interface](#user-interface)\n    - [Plots](#plots)\n    - [User Plots](#user-plots)\n  - [Examples](#examples)\n  - [Questions / Troubleshooting](#questions--troubleshooting)\n  - [Contributing](#contributing)\n  - [Changelog](#changelog)\n  - [License: MIT](#license-mit)\n\n## Install\n\nDownload the latest version:\n\n```\ngo get github.com/arl/statsviz@latest\n```\n\nPlease note that, as new metrics are added to the `/runtime/metrics` package, new plots are added to Statsviz.\nThis also means that the presence of some plots on the dashboard depends on the Go version you're using.\n\nWhen in doubt, use the latest ;-)\n\n\n## Usage\n\nRegister `Statsviz` HTTP handlers with your application `http.ServeMux`.\n\n```go\nmux := http.NewServeMux()\nstatsviz.Register(mux)\n\ngo func() {\n    log.Println(http.ListenAndServe(\"localhost:8080\", mux))\n}()\n```\n\nOpen your browser at http://localhost:8080/debug/statsviz\n\n\n## Advanced Usage\n\nIf you want more control over Statsviz HTTP handlers, examples are:\n - you're using some HTTP framework\n - you want to place Statsviz handler behind some middleware\n\nthen use `statsviz.NewServer` to obtain a `Server` instance. Both the `Index()` and `Ws()` methods return `http.HandlerFunc`.\n\n```go\nsrv, err := statsviz.NewServer(); // Create server or handle error\nsrv.Index()                       // UI (dashboard) http.HandlerFunc\nsrv.Ws()                          // Websocket http.HandlerFunc\n```\n\nPlease look at examples of usage in the [Examples](_example) directory.\n\n\n## How Does That Work?\n\n`statsviz.Register` registers 2 HTTP handlers within the given `http.ServeMux`:\n\n- the `Index` handler serves Statsviz user interface at `/debug/statsviz` at the address served by your program.\n\n- The `Ws` serves a Websocket endpoint. When the browser connects to that endpoint, [runtime/metrics](https://pkg.go.dev/runtime/metrics) are sent to the browser, once per second.\n\nData points are in a browser-side circular-buffer.\n\n\n## Documentation\n\n### Go API\n\nCheck out the API reference on [pkg.go.dev](https://pkg.go.dev/github.com/arl/statsviz#section-documentation).\n\n### User interface\n\nControls at the top of the page act on all plots:\n\n<img alt=\"menu\" src=\"https://github.com/arl/statsviz/raw/readme-docs/menu-002.png\">\n\n- the groom shows/hides the vertical lines representing garbage collections.\n- the time range selector defines the visualized time span.\n- the play/pause icons stops and resume the refresh of the plots.\n- the light/dark selector switches between light and dark modes.\n\nOn top of each plot there are 2 icons:\n\n<img alt=\"menu\" src=\"https://github.com/arl/statsviz/raw/readme-docs/plot.menu-001.png\">\n\n- the camera downloads a PNG image of the plot.\n- the info icon shows details about the metrics displayed.\n\n### Plots\n\nDepending on your go version, some plots may not be available.\n\n#### Heap (global)\n\n<img width=\"50%\" alt=\"heap-global\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/heap-global.png\">\n\n#### Heap (details)\n\n<img width=\"50%\" alt=\"heap-details\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/heap-details.png\">\n\n#### Live Objects in Heap\n\n<img width=\"50%\" alt=\"live-objects\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/live-objects.png\">\n\n#### Live Bytes in Heap\n\n<img width=\"50%\" alt=\"live-bytes\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/live-bytes.png\">\n\n#### MSpan/MCache\n\n<img width=\"50%\" alt=\"mspan-mcache\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/mspan-mcache.png\">\n\n#### Memory classes\n\n<img width=\"50%\" alt=\"memory-classes\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/memory-classes.png\">\n\n#### Goroutines\n\n<img width=\"50%\" alt=\"goroutines\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/goroutines.png\">\n\n#### Size Classes\n\n<img width=\"50%\" alt=\"size-classes\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/size-classes.png\">\n\n#### GC Scan\n\n<img width=\"50%\" alt=\"gc-scan\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/gc-scan.png\">\n\n#### GC Cycles\n\n<img width=\"50%\" alt=\"gc-cycles\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/gc-cycles.png\">\n\n#### Stop-the-world Pause Latencies\n\n<img width=\"50%\" alt=\"gc-pauses\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/gc-pauses.png\">\n\n#### CPU Classes (GC)\n\n<img width=\"50%\" alt=\"cpu-classes-gc\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/cpu-classes-gc.png\">\n\n#### Time Goroutines Spend in 'Runnable' state\n\n<img width=\"50%\" alt=\"runnable-time\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/runnable-time.png\">\n\n#### Time Goroutines Spend Blocked on Mutexes\n\n<img width=\"50%\" alt=\"mutex-wait\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/mutex-wait.png\">\n\n#### Starting Size of Goroutines Stacks\n\n<img width=\"50%\" alt=\"gc-stack-size\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/gc-stack-size.png\">\n\n#### Goroutine Scheduling Events\n\n<img width=\"50%\" alt=\"sched-events\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/sched-events.png\">\n\n#### CGO Calls\n\n<img width=\"50%\" alt=\"cgo\" src=\"https://github.com/arl/statsviz/raw/readme-docs/runtime-metrics/cgo.png\">\n\n\n### User Plots\n\nSince `v0.6` you can add your own plots to Statsviz dashboard, in order to easily\nvisualize your application metrics next to runtime metrics.\n\nPlease see the [userplots example](_example/userplots/main.go).\n\n## Examples\n\nCheck out the [\\_example](./_example/README.md) directory to see various ways to use Statsviz, such as:\n\n- use of `http.DefaultServeMux` or your own `http.ServeMux`\n- wrap HTTP handler behind a middleware\n- register the web page at `/foo/bar` instead of `/debug/statsviz`\n- use `https://` rather than `http://`\n- register Statsviz handlers with various Go HTTP libraries/frameworks:\n  - [echo](https://github.com/labstack/echo/)\n  - [fasthttp](https://github.com/valyala/fasthttp)\n  - [fiber](https://github.com/gofiber/fiber/)\n  - [gin](https://github.com/gin-gonic/gin)\n  - and many others thanks to many contributors!\n\n## Questions / Troubleshooting\n\nEither use GitHub's [discussions](https://github.com/arl/statsviz/discussions) or come to say hi and ask a live question on [#statsviz channel on Gopher's slack](https://gophers.slack.com/archives/C043DU4NZ9D).\n\n## Contributing\n\nPlease use [issues](https://github.com/arl/statsviz/issues/new/choose) for bugs and feature requests.  \nPull-requests are always welcome!  \nMore details in [CONTRIBUTING.md](CONTRIBUTING.md).\n\n## Changelog\n\nSee [CHANGELOG.md](./CHANGELOG.md).\n\n## License: MIT\n\nSee [LICENSE](LICENSE)\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.19140625,
          "content": "codecov:\n  require_ci_to_pass: yes\n\ncoverage:\n  round: down\n  precision: 2\n\n  status:\n    project:\n      default:\n        informational: true\n    patch:\n      default:\n        informational: true\n"
        },
        {
          "name": "examples_test.go",
          "type": "blob",
          "size": 2.0927734375,
          "content": "//go:build unix\n\npackage statsviz_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/rogpeppe/go-internal/gotooltest\"\n\t\"github.com/rogpeppe/go-internal/testscript\"\n)\n\nfunc TestExamples(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skipf(\"TestExamples skipped in short mode\")\n\t}\n\n\tp := testscript.Params{\n\t\tDir: \"testdata\",\n\t\tSetup: func(env *testscript.Env) error {\n\t\t\t// We want to run scripts with the local version of Statsviz.\n\t\t\t// Provide scripts with statsviz root dir so we can use a\n\t\t\t// 'go mod -edit replace' directive.\n\t\t\twd, err := os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tenv.Setenv(\"STATSVIZ_ROOT\", wd)\n\t\t\treturn nil\n\t\t},\n\t\tCmds: map[string]func(ts *testscript.TestScript, neg bool, args []string){\n\t\t\t\"checkui\": checkui,\n\t\t},\n\t}\n\n\tif err := gotooltest.Setup(&p); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestscript.Run(t, p)\n}\n\n// checkui requests statsviz url from a script.\n// In a script, run it with:\n//\n//\tcheckui url [basic_auth_user basic_auth_pwd]\nfunc checkui(ts *testscript.TestScript, neg bool, args []string) {\n\tif len(args) != 1 && len(args) != 3 {\n\t\tts.Fatalf(`checkui: wrong number of arguments. Call with \"checkui URL [BASIC_USER BASIC_PWD]`)\n\t}\n\tu := args[0]\n\tts.Logf(\"checkui: loading web page %s\", args[0])\n\n\tctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n\tdefer cancel()\n\n\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, u, nil)\n\tif err != nil {\n\t\tts.Fatalf(\"checkui: bad request: %v\", err)\n\t}\n\tif len(args) == 3 {\n\t\tts.Logf(\"checkui: setting basic auth\")\n\t\treq.SetBasicAuth(args[1], args[2])\n\t}\n\n\tclient := http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\tInsecureSkipVerify: true,\n\t\t\t},\n\t\t},\n\t\tTimeout: 5 * time.Second,\n\t}\n\n\t// Let 1 second for the server to start and listen.\n\ttime.Sleep(1 * time.Second)\n\n\tresp, err := client.Do(req)\n\tts.Check(err)\n\n\tbody, err := io.ReadAll(resp.Body)\n\tdefer resp.Body.Close()\n\tts.Check(err)\n\n\twant := []byte(`id=\"plots\"`)\n\tif !bytes.Contains(body, want) {\n\t\tts.Fatalf(\"checkui: response body doesn't contain %s\\n\\nbody;\\n\\n%s\", want, body)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2431640625,
          "content": "module github.com/arl/statsviz\n\ngo 1.20\n\nrequire (\n\tgithub.com/gorilla/websocket v1.5.0\n\tgithub.com/rogpeppe/go-internal v1.11.0\n)\n\nrequire (\n\tgolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f // indirect\n\tgolang.org/x/tools v0.1.12 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.705078125,
          "content": "github.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=\ngithub.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=\ngithub.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f h1:v4INt8xihDGvnrfjMDVXGxw9wrfxYyCjk0KbXjhR55s=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/tools v0.1.12 h1:VveCTK38A2rkS8ZqFY25HIDFscX5X9OoEhJd3quQmXU=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "statsviz.go",
          "type": "blob",
          "size": 8.1416015625,
          "content": "// Package statsviz allows visualizing Go runtime metrics data in real time in\n// your browser.\n//\n// Register a Statsviz HTTP handlers with your server's [http.ServeMux]\n// (preferred method):\n//\n//\tmux := http.NewServeMux()\n//\tstatsviz.Register(mux)\n//\n// Alternatively, you can register with [http.DefaultServeMux]:\n//\n//\tss := statsviz.Server{}\n//\ts.Register(http.DefaultServeMux)\n//\n// By default, Statsviz is served at http://host:port/debug/statsviz/. This, and\n// other settings, can be changed by passing some [Option] to [NewServer].\n//\n// If your application is not already running an HTTP server, you need to start\n// one. Add \"net/http\" and \"log\" to your imports, and use the following code in\n// your main function:\n//\n//\tgo func() {\n//\t    log.Println(http.ListenAndServe(\"localhost:8080\", nil))\n//\t}()\n//\n// Then open your browser and visit http://localhost:8080/debug/statsviz/.\n//\n// # Advanced usage:\n//\n// If you want more control over Statsviz HTTP handlers, examples are:\n//   - you're using some HTTP framework\n//   - you want to place Statsviz handler behind some middleware\n//\n// then use [NewServer] to obtain a [Server] instance. Both the [Server.Index] and\n// [Server.Ws]() methods return [http.HandlerFunc].\n//\n//\tsrv, err := statsviz.NewServer(); // Create server or handle error\n//\tsrv.Index()                       // UI (dashboard) http.HandlerFunc\n//\tsrv.Ws()                          // Websocket http.HandlerFunc\npackage statsviz\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/arl/statsviz/internal/plot\"\n\t\"github.com/arl/statsviz/internal/static\"\n)\n\nconst (\n\tdefaultRoot         = \"/debug/statsviz\"\n\tdefaultSendInterval = time.Second\n)\n\n// RegisterDefault registers the Statsviz HTTP handlers on [http.DefaultServeMux].\n//\n// RegisterDefault should not be used in production.\nfunc RegisterDefault(opts ...Option) error {\n\treturn Register(http.DefaultServeMux, opts...)\n}\n\n// Register registers the Statsviz HTTP handlers on the provided mux.\nfunc Register(mux *http.ServeMux, opts ...Option) error {\n\tsrv, err := NewServer(opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsrv.Register(mux)\n\treturn nil\n}\n\n// Server is the core component of Statsviz. It collects and periodically\n// updates metrics data and provides two essential HTTP handlers:\n//   - the Index handler serves Statsviz user interface, allowing you to\n//     visualize runtime metrics on your browser.\n//   - The Ws handler establishes a WebSocket connection allowing the connected\n//     browser to receive metrics updates from the server.\n//\n// The zero value is not a valid Server, use NewServer to create a valid one.\ntype Server struct {\n\tintv      time.Duration // interval between consecutive metrics emission\n\troot      string        // HTTP path root\n\tplots     *plot.List    // plots shown on the user interface\n\tuserPlots []plot.UserPlot\n}\n\n// NewServer constructs a new Statsviz Server with the provided options, or the\n// default settings.\n//\n// Note that once the server is created, its HTTP handlers needs to be registered\n// with some HTTP server. You can either use the Register method or register yourself\n// the Index and Ws handlers.\nfunc NewServer(opts ...Option) (*Server, error) {\n\ts := &Server{\n\t\tintv: defaultSendInterval,\n\t\troot: defaultRoot,\n\t}\n\n\tfor _, opt := range opts {\n\t\tif err := opt(s); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tpl, err := plot.NewList(s.userPlots)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.plots = pl\n\treturn s, nil\n}\n\n// Option is a configuration option for the Server.\ntype Option func(*Server) error\n\n// SendFrequency changes the interval between successive acquisitions of metrics\n// and their sending to the user interface. The default interval is one second.\nfunc SendFrequency(intv time.Duration) Option {\n\treturn func(s *Server) error {\n\t\tif intv <= 0 {\n\t\t\treturn fmt.Errorf(\"frequency must be a positive integer\")\n\t\t}\n\t\ts.intv = intv\n\t\treturn nil\n\t}\n}\n\n// Root changes the root path of the Statsviz user interface.\n// The default is \"/debug/statsviz\".\nfunc Root(path string) Option {\n\treturn func(s *Server) error {\n\t\ts.root = path\n\t\treturn nil\n\t}\n}\n\n// TimeseriesPlot adds a new time series plot to Statsviz. This options can\n// be added multiple times.\nfunc TimeseriesPlot(tsp TimeSeriesPlot) Option {\n\treturn func(s *Server) error {\n\t\ts.userPlots = append(s.userPlots, plot.UserPlot{Scatter: tsp.timeseries})\n\t\treturn nil\n\t}\n}\n\n// Register registers the Statsviz HTTP handlers on the provided mux.\nfunc (s *Server) Register(mux *http.ServeMux) {\n\tmux.Handle(s.root+\"/\", s.Index())\n\tmux.HandleFunc(s.root+\"/ws\", s.Ws())\n}\n\n// intercept is a middleware that intercepts requests for plotsdef.js, which is\n// generated dynamically based on the plots configuration. Other requests are\n// forwarded as-is.\nfunc intercept(h http.Handler, cfg *plot.Config) http.HandlerFunc {\n\tbuf := bytes.Buffer{}\n\tbuf.WriteString(\"export default \")\n\tenc := json.NewEncoder(&buf)\n\tenc.SetIndent(\"\", \"  \")\n\tif err := enc.Encode(cfg); err != nil {\n\t\tpanic(\"unexpected failure to encode plot definitions: \" + err.Error())\n\t}\n\tbuf.WriteString(\";\")\n\tplotsdefjs := buf.Bytes()\n\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path == \"js/plotsdef.js\" {\n\t\t\tw.Header().Add(\"Content-Length\", strconv.Itoa(buf.Len()))\n\t\t\tw.Header().Add(\"Content-Type\", \"text/javascript; charset=utf-8\")\n\t\t\tw.Write(plotsdefjs)\n\t\t\treturn\n\t\t}\n\n\t\t// Force Content-Type if needed.\n\t\tif ct, ok := contentTypes[r.URL.Path]; ok {\n\t\t\tw.Header().Add(\"Content-Type\", ct)\n\t\t}\n\n\t\th.ServeHTTP(w, r)\n\t}\n}\n\n// contentTypes forces the Content-Type HTTP header for certain files of some\n// JavaScript libraries that have no extensions. Otherwise, the HTTP file server\n// would serve them with \"Content-Type: text/plain\".\nvar contentTypes = map[string]string{\n\t\"libs/js/popperjs-core2\": \"text/javascript\",\n\t\"libs/js/tippy.js@6\":     \"text/javascript\",\n}\n\n// Returns an FS serving the embedded assets, or the assets directory if\n// STATSVIZ_DEBUG contains the 'asssets' key.\nfunc assetsFS() http.FileSystem {\n\tassets := http.FS(static.Assets)\n\n\tvdbg := os.Getenv(\"STATSVIZ_DEBUG\")\n\tif vdbg == \"\" {\n\t\treturn assets\n\t}\n\n\tkvs := strings.Split(vdbg, \";\")\n\tfor _, kv := range kvs {\n\t\tk, v, found := strings.Cut(strings.TrimSpace(kv), \"=\")\n\t\tif !found {\n\t\t\tpanic(\"invalid STATSVIZ_DEBUG value: \" + kv)\n\t\t}\n\t\tif k == \"assets\" {\n\t\t\tdir := filepath.Join(v)\n\t\t\treturn http.Dir(dir)\n\t\t}\n\t}\n\n\treturn assets\n}\n\n// Index returns the index handler, which responds with the Statsviz user\n// interface HTML page. By default, the handler is served at the path specified\n// by the root. Use [WithRoot] to change the path.\nfunc (s *Server) Index() http.HandlerFunc {\n\tprefix := strings.TrimSuffix(s.root, \"/\") + \"/\"\n\tassets := http.FileServer(assetsFS())\n\thandler := intercept(assets, s.plots.Config())\n\n\treturn http.StripPrefix(prefix, handler).ServeHTTP\n}\n\n// Ws returns the WebSocket handler used by Statsviz to send application\n// metrics. The underlying net.Conn is used to upgrade the HTTP server\n// connection to the WebSocket protocol.\nfunc (s *Server) Ws() http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar upgrader = websocket.Upgrader{\n\t\t\tReadBufferSize:  1024,\n\t\t\tWriteBufferSize: 1024,\n\t\t}\n\n\t\tws, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tdefer ws.Close()\n\n\t\t// Ignore this error. This happens when the other end connection closes,\n\t\t// for example. We can't handle it in any meaningful way anyways.\n\t\t_ = s.sendStats(ws, s.intv)\n\t}\n}\n\n// sendStats sends runtime statistics over the WebSocket connection.\nfunc (s *Server) sendStats(conn *websocket.Conn, frequency time.Duration) error {\n\ttick := time.NewTicker(frequency)\n\tdefer tick.Stop()\n\n\t// If the WebSocket connection is initiated by an already open web UI\n\t// (started by a previous process, for example), then plotsdef.js won't be\n\t// requested. Call plots.Config() manually to ensure that s.plots internals\n\t// are correctly initialized.\n\ts.plots.Config()\n\n\tfor range tick.C {\n\t\tw, err := conn.NextWriter(websocket.TextMessage)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := s.plots.WriteValues(w); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := w.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tpanic(\"unreachable\")\n}\n"
        },
        {
          "name": "statsviz_test.go",
          "type": "blob",
          "size": 6.9033203125,
          "content": "package statsviz\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\n\t\"github.com/arl/statsviz/internal/static\"\n)\n\nfunc testIndex(t *testing.T, f http.Handler, url string) {\n\tt.Helper()\n\n\treq := httptest.NewRequest(\"GET\", url, nil)\n\tw := httptest.NewRecorder()\n\tf.ServeHTTP(w, req)\n\n\tresp := w.Result()\n\tbody, _ := io.ReadAll(resp.Body)\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"http status %v, want %v\", resp.StatusCode, http.StatusOK)\n\t}\n\n\tif resp.Header.Get(\"Content-Type\") != \"text/html; charset=utf-8\" {\n\t\tt.Errorf(\"header[Content-Type] %s, want %s\", resp.Header.Get(\"Content-Type\"), \"text/html; charset=utf-8\")\n\t}\n\n\thtml, err := static.Assets.ReadFile(\"index.html\")\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't read index.html from assets Fs: %v\", err)\n\t}\n\n\tif !bytes.Equal(html, body) {\n\t\tt.Errorf(\"read body is not that of index.html from assets\")\n\t}\n}\n\nfunc newServer(tb testing.TB, opts ...Option) *Server {\n\ttb.Helper()\n\n\tsrv, err := NewServer(opts...)\n\tif err != nil {\n\t\ttb.Fatal(err)\n\t}\n\treturn srv\n}\n\nfunc TestIndex(t *testing.T) {\n\tt.Parallel()\n\n\tsrv := newServer(t)\n\ttestIndex(t, srv.Index(), \"http://example.com/debug/statsviz/\")\n}\n\nfunc TestRoot(t *testing.T) {\n\tt.Parallel()\n\n\ttestIndex(t, newServer(t, Root(\"/debug/\")).Index(), \"http://example.com/debug/\")\n\ttestIndex(t, newServer(t, Root(\"/debug\")).Index(), \"http://example.com/debug/\")\n\ttestIndex(t, newServer(t, Root(\"/\")).Index(), \"http://example.com/\")\n\ttestIndex(t, newServer(t, Root(\"/test/\")).Index(), \"http://example.com/test/\")\n}\n\nfunc testWs(t *testing.T, f http.Handler, URL string) {\n\tt.Helper()\n\n\ts := httptest.NewServer(f)\n\tdefer s.Close()\n\n\t// Build a \"ws://\" url using the httptest server URL and the URL argument.\n\tu1, err := url.Parse(s.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tu2, err := url.Parse(URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tu1.Scheme = \"ws\"\n\tu1.Path = u2.Path\n\n\t// Connect to the server\n\tws, _, err := websocket.DefaultDialer.Dial(u1.String(), nil)\n\tif err != nil {\n\t\tt.Fatalf(\"%v\", err)\n\t}\n\tdefer ws.Close()\n\n\t// Check the content of 2 consecutive payloads.\n\tfor i := 0; i < 2; i++ {\n\n\t\t// Verifies that we've received 1 time series (goroutines) and one\n\t\t// heatmap (sizeClasses).\n\t\tvar data struct {\n\t\t\tGoroutines  []uint64 `json:\"goroutines\"`\n\t\t\tSizeClasses []uint64 `json:\"size-classes\"`\n\t\t}\n\t\tif err := ws.ReadJSON(&data); err != nil {\n\t\t\tt.Fatalf(\"failed reading json from websocket: %v\", err)\n\t\t}\n\n\t\t// The time series must have one and only one element\n\t\tif len(data.Goroutines) != 1 {\n\t\t\tt.Errorf(\"len(goroutines) = %d, want 1\", len(data.Goroutines))\n\t\t}\n\t\t// Heatmaps should have many elements, check that there's more than one.\n\t\tif len(data.SizeClasses) <= 1 {\n\t\t\tt.Errorf(\"len(sizeClasses) = %d, want > 1\", len(data.SizeClasses))\n\t\t}\n\t}\n}\n\nfunc TestWs(t *testing.T) {\n\tt.Parallel()\n\n\ttestWs(t, newServer(t).Ws(), \"http://example.com/debug/statsviz/ws\")\n}\n\nfunc TestWsCantUpgrade(t *testing.T) {\n\turl := \"http://example.com/debug/statsviz/ws\"\n\n\treq := httptest.NewRequest(\"GET\", url, nil)\n\tw := httptest.NewRecorder()\n\tnewServer(t).Ws()(w, req)\n\n\tif w.Result().StatusCode != http.StatusBadRequest {\n\t\tt.Errorf(\"responded %v to %q with non-websocket-upgradable conn, want %v\", w.Result().StatusCode, url, http.StatusBadRequest)\n\t}\n}\n\nfunc testRegister(t *testing.T, f http.Handler, baseURL string) {\n\ttestIndex(t, f, baseURL)\n\tws := strings.TrimRight(baseURL, \"/\") + \"/ws\"\n\ttestWs(t, f, ws)\n}\n\nfunc TestRegister(t *testing.T) {\n\tt.Run(\"default\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmux := http.NewServeMux()\n\t\tnewServer(t).Register(mux)\n\t\ttestRegister(t, mux, \"http://example.com/debug/statsviz/\")\n\t})\n\n\tt.Run(\"root\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmux := http.NewServeMux()\n\t\tnewServer(t,\n\t\t\tRoot(\"\"),\n\t\t).Register(mux)\n\n\t\ttestRegister(t, mux, \"http://example.com/\")\n\t})\n\n\tt.Run(\"root2\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmux := http.NewServeMux()\n\t\tnewServer(t,\n\t\t\tRoot(\"/path/to/statsviz\"),\n\t\t).Register(mux)\n\n\t\ttestRegister(t, mux, \"http://example.com/path/to/statsviz/\")\n\t})\n\n\tt.Run(\"root+frequency\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tmux := http.NewServeMux()\n\t\tnewServer(t,\n\t\t\tRoot(\"/path/to/statsviz\"),\n\t\t\tSendFrequency(100*time.Millisecond),\n\t\t).Register(mux)\n\n\t\ttestRegister(t, mux, \"http://example.com/path/to/statsviz/\")\n\t})\n\n\tt.Run(\"non-positive frequency\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tif _, err := NewServer(\n\t\t\tRoot(\"/path/to/statsviz\"),\n\t\t\tSendFrequency(-1),\n\t\t); err == nil {\n\t\t\tt.Errorf(\"NewServer() should have errored\")\n\t\t}\n\t})\n}\n\nfunc TestRegisterDefault(t *testing.T) {\n\tmux := http.DefaultServeMux\n\tRegister(mux)\n\ttestRegister(t, mux, \"http://example.com/debug/statsviz/\")\n}\n\nfunc Test_intercept(t *testing.T) {\n\t// Check that the file server has been 'hijacked'.\n\t// 'plotsdef.js' is generated at runtime, it doesn't actually exist, it is generated on the fly.\n\tw := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"http://example.com/debug/statsviz/js/plotsdef.js\", nil)\n\n\tsrv := newServer(t)\n\tintercept(srv.Index(), srv.plots.Config())(w, req)\n\n\tresp := w.Result()\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Errorf(\"http status %v, want %v\", resp.StatusCode, http.StatusOK)\n\t}\n\n\tcontentType := \"text/javascript; charset=utf-8\"\n\tif resp.Header.Get(\"Content-Type\") != contentType {\n\t\tt.Errorf(\"header[Content-Type] %s, want %s\", resp.Header.Get(\"Content-Type\"), contentType)\n\t}\n}\n\nfunc TestContentTypeIsSet(t *testing.T) {\n\t// Check that \"Content-Type\" headers on the assets we serve are all set to\n\t// something more specific than \"text/plain\" because that'd make the page be\n\t// rejected in certain 'strict' environments.\n\tconst root = \"/some/root/path\"\n\tsrv := newServer(t, Root(root))\n\thttpfs := srv.Index()\n\n\trequested := []string{}\n\n\t// While we walk the embedded assets filesystem, control the header on the\n\t// http filesystem server.\n\t_ = fs.WalkDir(static.Assets, \".\", func(path string, d fs.DirEntry, err error) error {\n\t\tif d.IsDir() || path == \"fs.go\" || path == \"index.html\" {\n\t\t\treturn nil\n\t\t}\n\n\t\tw := httptest.NewRecorder()\n\t\tr := httptest.NewRequest(http.MethodGet, root+\"/\"+path, nil)\n\n\t\thttpfs(w, r)\n\t\tres := w.Result()\n\t\tif res.StatusCode != 200 && path != \"index.html\" {\n\t\t\tt.Errorf(\"GET %q returned HTTP %d, want 200\", path, res.StatusCode)\n\t\t\treturn nil\n\t\t}\n\n\t\tct := res.Header.Get(\"Content-Type\")\n\t\tif ct == \"\" || strings.Contains(ct, \"text/plain\") {\n\t\t\tt.Errorf(`GET %q has incorrect header \"Content-Type = %s\"`, path, ct)\n\t\t\treturn nil\n\t\t}\n\n\t\tif testing.Verbose() {\n\t\t\tt.Logf(\"%q Content-Type %q\", path, ct)\n\t\t}\n\t\trequested = append(requested, path)\n\t\treturn nil\n\t})\n\n\t// Verify that all files in contentTypes map have been requested. This is to\n\t// keep the map aligned with the actual content of the static/ dir.\n\tfor path := range contentTypes {\n\t\tfound := false\n\t\tfor i := range requested {\n\t\t\tif requested[i] == path {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Fatalf(\"contentTypes[%v] matches no files in the static/ dir\", path)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "userplot.go",
          "type": "blob",
          "size": 4.83984375,
          "content": "package statsviz\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/arl/statsviz/internal/plot\"\n)\n\n// TimeSeriesType describes the type of a time series plot.\ntype TimeSeriesType string\n\nconst (\n\t// Scatter is a time series plot made of lines.\n\tScatter TimeSeriesType = \"scatter\"\n\n\t// Bar is a time series plot made of bars.\n\tBar TimeSeriesType = \"bar\"\n)\n\n// BarMode determines how bars at the same location are displayed on a bar plot.\ntype BarMode string\n\nconst (\n\t// Stack indicates that bars are stacked on top of one another.\n\tStack BarMode = \"stack\"\n\n\t// Ggroup indicates that bars are plotted next to one another, centered\n\t// around the shared location.\n\tGroup BarMode = \"group\"\n\n\t// Relative indicates that bars are stacked on top of one another, with\n\t// negative values below the axis and positive values above.\n\tRelative BarMode = \"relative\"\n\n\t// Overlay indicates that bars are plotted over one another.\n\tOverlay BarMode = \"overlay\"\n)\n\nvar (\n\t// ErrNoTimeSeries is returned when a user plot has no time series.\n\tErrNoTimeSeries = errors.New(\"user plot must have at least one time series\")\n\n\t// ErrEmptyPlotName is returned when a user plot has an empty name.\n\tErrEmptyPlotName = errors.New(\"user plot name can't be empty\")\n)\n\n// ErrReservedPlotName is returned when a reserved plot name is used for a user plot.\ntype ErrReservedPlotName string\n\nfunc (e ErrReservedPlotName) Error() string {\n\treturn fmt.Sprintf(\"%q is a reserved plot name\", string(e))\n}\n\n// HoverOnType describes the type of hover effect on a time series plot.\ntype HoverOnType string\n\nconst (\n\t// HoverOnPoints specifies that the hover effects highlights individual\n\t// points.\n\tHoverOnPoints HoverOnType = \"points\"\n\n\t// HoverOnPoints specifies that the hover effects highlights filled regions.\n\tHoverOnFills HoverOnType = \"fills\"\n\n\t// HoverOnPointsAndFills specifies that the hover effects highlights both\n\t// points and filled regions.\n\tHoverOnPointsAndFills HoverOnType = \"points+fills\"\n)\n\n// A TimeSeries describes a single time series of a plot.\ntype TimeSeries struct {\n\t// Name is the name identifying this time series in the user interface.\n\tName string\n\n\t// UnitFmt is the d3-format string used to format the numbers of this time\n\t// series in the user interface. See https://github.com/d3/d3-format.\n\tUnitfmt string\n\n\t// HoverOn configures whether the hover effect highlights individual points\n\t// or do they highlight filled regions, or both. Defaults to HoverOnFills.\n\tHoverOn HoverOnType\n\n\t// Type is the time series type, either [Scatter] or [Bar]. default: [Scatter].\n\tType TimeSeriesType\n\n\t// GetValue specifies the function called to get the value of this time\n\t// series.\n\tGetValue func() float64\n}\n\n// TimeSeriesPlotConfig describes the configuration of a time series plot.\ntype TimeSeriesPlotConfig struct {\n\t// Name is the plot name, it must be unique.\n\tName string\n\n\t// Title is the plot title, shown above the plot.\n\tTitle string\n\n\t// Type is either [Scatter] or [Bar]. default: [Scatter].\n\tType TimeSeriesType\n\n\t// BarMode is either [Stack], [Group], [Relative] or [Overlay].\n\t// default: [Group].\n\tBarMode BarMode\n\n\t// Tooltip is the html-aware text shown when the user clicks on the plot\n\t// Info icon.\n\tInfoText string\n\n\t// YAxisTitle is the title of Y axis.\n\tYAxisTitle string\n\n\t// YAxisTickSuffix is the suffix added to tick values.\n\tYAxisTickSuffix string\n\n\t// Series contains the time series shown on this plot, there must be at\n\t// least one.\n\tSeries []TimeSeries\n}\n\n// Build validates the configuration and builds a time series plot for it\nfunc (p TimeSeriesPlotConfig) Build() (TimeSeriesPlot, error) {\n\tvar zero TimeSeriesPlot\n\tif p.Name == \"\" {\n\t\treturn zero, ErrEmptyPlotName\n\t}\n\tif plot.IsReservedPlotName(p.Name) {\n\t\treturn zero, ErrReservedPlotName(p.Name)\n\t}\n\tif len(p.Series) == 0 {\n\t\treturn zero, ErrNoTimeSeries\n\t}\n\n\tvar (\n\t\tsubplots []plot.Subplot\n\t\tfuncs    []func() float64\n\t)\n\tfor _, ts := range p.Series {\n\t\tswitch ts.HoverOn {\n\t\tcase \"\":\n\t\t\tts.HoverOn = HoverOnFills\n\t\tcase HoverOnPoints, HoverOnFills, HoverOnPointsAndFills:\n\t\t\t// ok\n\t\tdefault:\n\t\t\treturn zero, fmt.Errorf(\"invalid HoverOn value %s\", ts.HoverOn)\n\t\t}\n\n\t\tsubplots = append(subplots, plot.Subplot{\n\t\t\tName:    ts.Name,\n\t\t\tUnitfmt: ts.Unitfmt,\n\t\t\tHoverOn: string(ts.HoverOn),\n\t\t\tType:    string(ts.Type),\n\t\t})\n\t\tfuncs = append(funcs, ts.GetValue)\n\t}\n\n\treturn TimeSeriesPlot{\n\t\ttimeseries: &plot.ScatterUserPlot{\n\t\t\tPlot: plot.Scatter{\n\t\t\t\tName:     p.Name,\n\t\t\t\tTitle:    p.Title,\n\t\t\t\tType:     string(p.Type),\n\t\t\t\tInfoText: p.InfoText,\n\t\t\t\tLayout: plot.ScatterLayout{\n\t\t\t\t\tBarMode: string(p.BarMode),\n\t\t\t\t\tYaxis: plot.ScatterYAxis{\n\t\t\t\t\t\tTitle:      p.YAxisTitle,\n\t\t\t\t\t\tTickSuffix: p.YAxisTickSuffix,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSubplots: subplots,\n\t\t\t},\n\t\t\tFuncs: funcs,\n\t\t},\n\t}, nil\n}\n\n// TimeSeriesPlot is an opaque type representing a timeseries plot.\n// A plot can be created with [TimeSeriesPlotConfig.Build].\ntype TimeSeriesPlot struct {\n\ttimeseries *plot.ScatterUserPlot\n}\n"
        },
        {
          "name": "userplot_test.go",
          "type": "blob",
          "size": 0.796875,
          "content": "package statsviz\n\nimport (\n\t\"errors\"\n\t\"testing\"\n)\n\nfunc TestTimeSeriesPlotConfigErrors(t *testing.T) {\n\tt.Run(\"empty name\", func(t *testing.T) {\n\t\ttsb := TimeSeriesPlotConfig{}\n\t\tif _, err := tsb.Build(); !errors.Is(err, ErrEmptyPlotName) {\n\t\t\tt.Errorf(\"Build() returned err = %v, want %v\", err, ErrEmptyPlotName)\n\t\t}\n\t})\n\tt.Run(\"reserved name\", func(t *testing.T) {\n\t\ttsb := TimeSeriesPlotConfig{Name: \"timestamp\"}\n\t\tvar target ErrReservedPlotName\n\t\tif _, err := tsb.Build(); !errors.As(err, &target) {\n\t\t\tt.Errorf(\"Build() returned err = %v, want %v\", err, target)\n\t\t}\n\t})\n\tt.Run(\"no time series\", func(t *testing.T) {\n\t\ttsb := TimeSeriesPlotConfig{Name: \"some name\"}\n\t\tif _, err := tsb.Build(); !errors.Is(err, ErrNoTimeSeries) {\n\t\t\tt.Errorf(\"Build() returned err = %v, want %v\", err, ErrEmptyPlotName)\n\t\t}\n\t})\n}\n"
        }
      ]
    }
  ]
}