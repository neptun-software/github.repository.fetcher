{
  "metadata": {
    "timestamp": 1736567274044,
    "page": 871,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "playwright-community/playwright-go",
      "stars": 2340,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.072265625,
          "content": "# text files must be lf for golden file tests to work\n* text=auto eol=lf\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5771484375,
          "content": "# Created by https://www.toptal.com/developers/gitignore/api/go\n# Edit at https://www.toptal.com/developers/gitignore?templates=go\n\n### Go ###\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n### Go Patch ###\n/vendor/\n/Godeps/\n\n# End of https://www.toptal.com/developers/gitignore/api/go\ncovprofile\n.idea/\n.DS_Store\n\napi.json\n_site/\n.jekyll-cache/\n\n.vscode/settings.json"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0888671875,
          "content": "[submodule \"playwright\"]\n\tpath = playwright\n\turl = https://github.com/microsoft/playwright\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.0751953125,
          "content": "---\nlinters:\n  enable-all: false\n  disable-all: false\n  enable:\n    - gofumpt"
        },
        {
          "name": ".nojekyll",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "404.html",
          "type": "blob",
          "size": 0.4091796875,
          "content": "---\npermalink: /404.html\nlayout: default\n---\n\n<style type=\"text/css\" media=\"screen\">\n  .container {\n    margin: 10px auto;\n    max-width: 600px;\n    text-align: center;\n  }\n  h1 {\n    margin: 30px 0;\n    font-size: 4em;\n    line-height: 1;\n    letter-spacing: -1px;\n  }\n</style>\n\n<div class=\"container\">\n  <h1>404</h1>\n\n  <p><strong>Page not found :(</strong></p>\n  <p>The requested page could not be found.</p>\n</div>\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.9140625,
          "content": "# Contributing\n\n## Code style\nThe Go code is linted with [golangci-lint](https://golangci-lint.run/) and formatted with [gofumpt](https://github.com/mvdan/gofumpt). Please configure your editor to run the tools while developing and make sure to run the tools before committing any code.\n\n## Tests\n\n### Test coverage\n\nFor every Pull Request on GitHub and on the main branch the coverage data will get sent over to [Coveralls](https://coveralls.io/github/playwright-community/playwright-go), this is helpful for finding functions that aren't covered by tests.\n\n### Running tests\n\nYou can use the `BROWSER` environment variable to use a different browser than Chromium for the tests and use the `HEADLESS` environment variable which is useful for debugging.\n\n```\nBROWSER=chromium HEADLESS=1 go test -v --race ./...\n```\n\n### Roll\n\n1. Find out to which upstream version you want to roll, and change the value of `playwrightCliVersion` in the **run.go** to the new version.\n1. Download current version of Playwright driver `go run scripts/install-browsers/main.go`\n1. Apply patch `bash scripts/apply-patch.sh`\n1. Fix merge conflicts if any, otherwise ignore this step. Once you are happy you can commit the changes `cd playwright; git commit -am \"apply patch\" && cd ..`\n1. Regenerate a new patch `bash scripts/update-patch.sh`\n1. Generate go code `go generate ./...`\n\nTo adapt to the new version of Playwright's protocol and feature updates, you may need to modify the patch. Refer to the following steps:\n\n1. Apply patch `bash scripts/apply-patch.sh`\n1. `cd playwright`\n1. Revert the patch`git reset HEAD~1`\n1. Modify the files under `docs/src/api`, etc. as needed. Available references:\n    - Protocol `packages/protocol/src/protocol.yml`\n    - [Playwright python](https://github.com/microsoft/playwright-python)\n1. Commit the changes `git commit -am \"apply patch\"`\n1. Regenerate a new patch `bash scripts/update-patch.sh`\n1. Generate go code `go generate ./...`.\n"
        },
        {
          "name": "Dockerfile.example",
          "type": "blob",
          "size": 0.830078125,
          "content": "# Stage 1: Modules caching\nFROM golang:1.22 as modules\nCOPY go.mod go.sum /modules/\nWORKDIR /modules\nRUN go mod download\n\n# Stage 2: Build\nFROM golang:1.22 as builder\nCOPY --from=modules /go/pkg /go/pkg\nCOPY . /workdir\nWORKDIR /workdir\n# Install playwright cli with right version for later use\nRUN PWGO_VER=$(grep -oE \"playwright-go v\\S+\" /workdir/go.mod | sed 's/playwright-go //g') \\\n    && go install github.com/playwright-community/playwright-go/cmd/playwright@${PWGO_VER}\n# Build your app\nRUN GOOS=linux GOARCH=amd64 go build -o /bin/myapp\n\n# Stage 3: Final\nFROM ubuntu:noble\nCOPY --from=builder /go/bin/playwright /bin/myapp /\nRUN apt-get update && apt-get install -y ca-certificates tzdata \\\n    # Install dependencies and all browsers (or specify one)\n    && /playwright install --with-deps \\\n    && rm -rf /var/lib/apt/lists/*\nCMD [\"/myapp\"]"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2020 Max Schmitt\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.0478515625,
          "content": "# 🎭 [Playwright](https://github.com/microsoft/playwright#readme) for <img src=\"https://user-images.githubusercontent.com/17984549/91302719-343a1d80-e7a7-11ea-8d6a-9448ef598420.png\" height=\"35\" />\n\n## Looking for maintainers and see [here](https://github.com/playwright-community/playwright-go/issues/122). Thanks!\n\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/playwright-community/playwright-go)](https://pkg.go.dev/github.com/playwright-community/playwright-go)\n[![License](https://img.shields.io/badge/License-MIT-blue.svg)](http://opensource.org/licenses/MIT)\n[![Go Report Card](https://goreportcard.com/badge/github.com/playwright-community/playwright-go)](https://goreportcard.com/report/github.com/playwright-community/playwright-go) ![Build Status](https://github.com/playwright-community/playwright-go/workflows/Go/badge.svg)\n[![Join Slack](https://img.shields.io/badge/join-slack-infomational)](https://aka.ms/playwright-slack) [![Coverage Status](https://coveralls.io/repos/github/playwright-community/playwright-go/badge.svg?branch=main)](https://coveralls.io/github/playwright-community/playwright-go?branch=main) <!-- GEN:chromium-version-badge -->[![Chromium version](https://img.shields.io/badge/chromium-131.0.6778.33-blue.svg?logo=google-chrome)](https://www.chromium.org/Home)<!-- GEN:stop --> <!-- GEN:firefox-version-badge -->[![Firefox version](https://img.shields.io/badge/firefox-132.0-blue.svg?logo=mozilla-firefox)](https://www.mozilla.org/en-US/firefox/new/)<!-- GEN:stop --> <!-- GEN:webkit-version-badge -->[![WebKit version](https://img.shields.io/badge/webkit-18.2-blue.svg?logo=safari)](https://webkit.org/)<!-- GEN:stop -->\n\n[API reference](https://playwright.dev/docs/api/class-playwright) | [Example recipes](https://github.com/playwright-community/playwright-go/tree/main/examples)\n\nPlaywright is a Go library to automate [Chromium](https://www.chromium.org/Home), [Firefox](https://www.mozilla.org/en-US/firefox/new/) and [WebKit](https://webkit.org/) with a single API. Playwright is built to enable cross-browser web automation that is **ever-green**, **capable**, **reliable** and **fast**.\n\n|          | Linux | macOS | Windows |\n|   :---   | :---: | :---: | :---:   |\n| Chromium <!-- GEN:chromium-version -->131.0.6778.33<!-- GEN:stop --> | ✅ | ✅ | ✅ |\n| WebKit <!-- GEN:webkit-version -->18.2<!-- GEN:stop --> | ✅ | ✅ | ✅ |\n| Firefox <!-- GEN:firefox-version -->132.0<!-- GEN:stop --> | ✅ | ✅ | ✅ |\n\nHeadless execution is supported for all the browsers on all platforms.\n\n## Installation\n\n```txt\ngo get -u github.com/playwright-community/playwright-go\n```\n\nInstall the browsers and OS dependencies:\n\n```bash\ngo run github.com/playwright-community/playwright-go/cmd/playwright@latest install --with-deps\n# Or\ngo install github.com/playwright-community/playwright-go/cmd/playwright@latest\nplaywright install --with-deps\n```\n\nAlternatively you can do it inside your program via which downloads the driver and browsers:\n\n```go\nerr := playwright.Install()\n```\n\n## Capabilities\n\nPlaywright is built to automate the broad and growing set of web browser capabilities used by Single Page Apps and Progressive Web Apps.\n\n* Scenarios that span multiple page, domains and iframes\n* Auto-wait for elements to be ready before executing actions (like click, fill)\n* Intercept network activity for stubbing and mocking network requests\n* Emulate mobile devices, geolocation, permissions\n* Support for web components via shadow-piercing selectors\n* Native input events for mouse and keyboard\n* Upload and download files\n\n## Example\n\nThe following example crawls the current top voted items from [Hacker News](https://news.ycombinator.com).\n\n```go\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/playwright-community/playwright-go\"\n)\n\nfunc main() {\n\tpw, err := playwright.Run()\n\tif err != nil {\n\t\tlog.Fatalf(\"could not start playwright: %v\", err)\n\t}\n\tbrowser, err := pw.Chromium.Launch()\n\tif err != nil {\n\t\tlog.Fatalf(\"could not launch browser: %v\", err)\n\t}\n\tpage, err := browser.NewPage()\n\tif err != nil {\n\t\tlog.Fatalf(\"could not create page: %v\", err)\n\t}\n\tif _, err = page.Goto(\"https://news.ycombinator.com\"); err != nil {\n\t\tlog.Fatalf(\"could not goto: %v\", err)\n\t}\n\tentries, err := page.Locator(\".athing\").All()\n\tif err != nil {\n\t\tlog.Fatalf(\"could not get entries: %v\", err)\n\t}\n\tfor i, entry := range entries {\n\t\ttitle, err := entry.Locator(\"td.title > span > a\").TextContent()\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"could not get text content: %v\", err)\n\t\t}\n\t\tfmt.Printf(\"%d: %s\\n\", i+1, title)\n\t}\n\tif err = browser.Close(); err != nil {\n\t\tlog.Fatalf(\"could not close browser: %v\", err)\n\t}\n\tif err = pw.Stop(); err != nil {\n\t\tlog.Fatalf(\"could not stop Playwright: %v\", err)\n\t}\n}\n```\n\n## Docker\nRefer to the [Dockerfile.example](./Dockerfile.example) to build your own docker image.\n\n## More examples\n\n* Refer to [helper_test.go](./tests/helper_test.go) for End-To-End testing \n* [Downloading files](./examples/download/main.go)\n* [End-To-End testing a website](./examples/end-to-end-testing/main.go)\n* [Executing JavaScript in the browser](./examples/javascript/main.go)\n* [Emulate mobile and geolocation](./examples/mobile-and-geolocation/main.go)\n* [Parallel scraping using a WaitGroup](./examples/parallel-scraping/main.go)\n* [Rendering a PDF of a website](./examples/pdf/main.go)\n* [Scraping HackerNews](./examples/scraping/main.go)\n* [Take a screenshot](./examples/screenshot/main.go)\n* [Record a video](./examples/video/main.go)\n* [Monitor network activity](./examples/network-monitoring/main.go)\n\n## How does it work?\n\nPlaywright is a Node.js library which uses:\n\n* Chrome DevTools Protocol to communicate with Chromium\n* Patched Firefox to communicate with Firefox\n* Patched WebKit to communicate with WebKit\n\nThese patches are based on the original sources of the browsers and don't modify the browser behaviour so the browsers are basically the same (see [here](https://github.com/microsoft/playwright/tree/main/browser_patches)) as you see them in the wild. The support for different programming languages is based on exposing a RPC server in the Node.js land which can be used to allow other languages to use Playwright without implementing all the custom logic:\n\n* [Playwright for Python](https://github.com/microsoft/playwright-python)\n* [Playwright for .NET](https://github.com/microsoft/playwright-sharp)\n* [Playwright for Java](https://github.com/microsoft/playwright-java)\n* [Playwright for Go](https://github.com/playwright-community/playwright-go)\n\nThe bridge between Node.js and the other languages is basically a Node.js runtime combined with Playwright which gets shipped for each of these languages (around 50MB) and then communicates over stdio to send the relevant commands. This will also download the pre-compiled browsers.\n\n## Is Playwright for Go ready?\n\nWe are ready for your feedback, but we are still covering Playwright Go with the tests.\n\n## Resources\n\n* [Playwright for Go Documentation](https://pkg.go.dev/github.com/playwright-community/playwright-go)\n* [Playwright Documentation](https://playwright.dev/docs/api/class-playwright)\n* [Example recipes](https://github.com/playwright-community/playwright-go/tree/main/examples)\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.71875,
          "content": "title: Playwright for Go\nemail: max@schmitt.mx\ndescription: >- # this means to ignore newlines until \"baseurl:\"\n  Playwright is a Node.js library to automate Chromium, Firefox and WebKit with a single API.\n  Playwright is built to enable cross-browser web automation that is ever-green, capable, reliable and fast.\nbaseurl: \"/playwright-go\"\nurl: \"https://playwright-community.github.io/\"\ntwitter_username: maxibanki\ngithub_username: playwright-community\nremote_theme: pages-themes/cayman@v0.2.0\nplugins:\n  - jekyll-remote-theme\n  - jekyll-optional-front-matter\n  - jekyll-readme-index\nexclude:\n  - playwright/\ndefaults:\n  - scope:\n      path: \"\" # an empty string here means all files in the project\n    values:\n      layout: \"default\"\n"
        },
        {
          "name": "apiresponse_assertions.go",
          "type": "blob",
          "size": 1.7119140625,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype apiResponseAssertionsImpl struct {\n\tactual APIResponse\n\tisNot  bool\n}\n\nfunc newAPIResponseAssertions(actual APIResponse, isNot bool) *apiResponseAssertionsImpl {\n\treturn &apiResponseAssertionsImpl{\n\t\tactual: actual,\n\t\tisNot:  isNot,\n\t}\n}\n\nfunc (ar *apiResponseAssertionsImpl) Not() APIResponseAssertions {\n\treturn newAPIResponseAssertions(ar.actual, true)\n}\n\nfunc (ar *apiResponseAssertionsImpl) ToBeOK() error {\n\tif ar.isNot != ar.actual.Ok() {\n\t\treturn nil\n\t}\n\tmessage := fmt.Sprintf(`Response status expected to be within [200..299] range, was %v`, ar.actual.Status())\n\tif ar.isNot {\n\t\tmessage = strings.ReplaceAll(message, \"expected to\", \"expected not to\")\n\t}\n\tlogList, err := ar.actual.(*apiResponseImpl).fetchLog()\n\tif err != nil {\n\t\treturn err\n\t}\n\tlog := strings.Join(logList, \"\\n\")\n\tif log != \"\" {\n\t\tmessage += \"\\nCall log:\\n\" + log\n\t}\n\n\tisTextEncoding := false\n\tcontentType, ok := ar.actual.Headers()[\"content-type\"]\n\tif ok {\n\t\tisTextEncoding = isTexualMimeType(contentType)\n\t}\n\tif isTextEncoding {\n\t\ttext, err := ar.actual.Text()\n\t\tif err == nil {\n\t\t\tmessage += fmt.Sprintf(`\\n Response Text:\\n %s`, subString(text, 0, 1000))\n\t\t}\n\t}\n\treturn errors.New(message)\n}\n\nfunc isTexualMimeType(mimeType string) bool {\n\tre := regexp.MustCompile(`^(text\\/.*?|application\\/(json|(x-)?javascript|xml.*?|ecmascript|graphql|x-www-form-urlencoded)|image\\/svg(\\+xml)?|application\\/.*?(\\+json|\\+xml))(;\\s*charset=.*)?$`)\n\treturn re.MatchString(mimeType)\n}\n\nfunc subString(s string, start, length int) string {\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif length < 0 {\n\t\tlength = 0\n\t}\n\trs := []rune(s)\n\tend := start + length\n\tif end > len(rs) {\n\t\tend = len(rs)\n\t}\n\treturn string(rs[start:end])\n}\n"
        },
        {
          "name": "artifact.go",
          "type": "blob",
          "size": 1.6103515625,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype artifactImpl struct {\n\tchannelOwner\n}\n\nfunc (a *artifactImpl) AbsolutePath() string {\n\treturn a.initializer[\"absolutePath\"].(string)\n}\n\nfunc (a *artifactImpl) PathAfterFinished() (string, error) {\n\tif a.connection.isRemote {\n\t\treturn \"\", errors.New(\"Path is not available when connecting remotely. Use SaveAs() to save a local copy\")\n\t}\n\tpath, err := a.channel.Send(\"pathAfterFinished\")\n\treturn path.(string), err\n}\n\nfunc (a *artifactImpl) SaveAs(path string) error {\n\tif !a.connection.isRemote {\n\t\t_, err := a.channel.Send(\"saveAs\", map[string]interface{}{\n\t\t\t\"path\": path,\n\t\t})\n\t\treturn err\n\t}\n\tstreamChannel, err := a.channel.Send(\"saveAsStream\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstream := fromChannel(streamChannel).(*streamImpl)\n\treturn stream.SaveAs(path)\n}\n\nfunc (a *artifactImpl) Failure() error {\n\treason, err := a.channel.Send(\"failure\")\n\tif reason == nil {\n\t\treturn err\n\t}\n\treturn fmt.Errorf(\"%w: %v\", ErrPlaywright, reason)\n}\n\nfunc (a *artifactImpl) Delete() error {\n\t_, err := a.channel.Send(\"delete\")\n\treturn err\n}\n\nfunc (a *artifactImpl) Cancel() error {\n\t_, err := a.channel.Send(\"cancel\")\n\treturn err\n}\n\nfunc (a *artifactImpl) ReadIntoBuffer() ([]byte, error) {\n\tstreamChannel, err := a.channel.Send(\"stream\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstream := fromChannel(streamChannel)\n\treturn stream.(*streamImpl).ReadAll()\n}\n\nfunc newArtifact(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *artifactImpl {\n\tartifact := &artifactImpl{}\n\tartifact.createChannelOwner(artifact, parent, objectType, guid, initializer)\n\treturn artifact\n}\n"
        },
        {
          "name": "assertions.go",
          "type": "blob",
          "size": 3.8505859375,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nconst assertionsDefaultTimeout = 5000 // 5s\n\ntype playwrightAssertionsImpl struct {\n\tdefaultTimeout *float64\n}\n\n// NewPlaywrightAssertions creates a new instance of PlaywrightAssertions\n//   - timeout: default value is 5000 (ms)\nfunc NewPlaywrightAssertions(timeout ...float64) PlaywrightAssertions {\n\tif len(timeout) > 0 {\n\t\treturn &playwrightAssertionsImpl{Float(timeout[0])}\n\t}\n\treturn &playwrightAssertionsImpl{Float(assertionsDefaultTimeout)}\n}\n\nfunc (pa *playwrightAssertionsImpl) APIResponse(response APIResponse) APIResponseAssertions {\n\treturn newAPIResponseAssertions(response, false)\n}\n\nfunc (pa *playwrightAssertionsImpl) Locator(locator Locator) LocatorAssertions {\n\treturn newLocatorAssertions(locator, false, pa.defaultTimeout)\n}\n\nfunc (pa *playwrightAssertionsImpl) Page(page Page) PageAssertions {\n\treturn newPageAssertions(page, false, pa.defaultTimeout)\n}\n\ntype expectedTextValue struct {\n\tStr                 *string `json:\"string\"`\n\tRegexSource         *string `json:\"regexSource\"`\n\tRegexFlags          *string `json:\"regexFlags\"`\n\tMatchSubstring      *bool   `json:\"matchSubstring\"`\n\tIgnoreCase          *bool   `json:\"ignoreCase\"`\n\tNormalizeWhiteSpace *bool   `json:\"normalizeWhiteSpace\"`\n}\n\ntype frameExpectOptions struct {\n\tExpressionArg  interface{}         `json:\"expressionArg\"`\n\tExpectedText   []expectedTextValue `json:\"expectedText\"`\n\tExpectedNumber *float64            `json:\"expectedNumber\"`\n\tExpectedValue  interface{}         `json:\"expectedValue\"`\n\tUseInnerText   *bool               `json:\"useInnerText\"`\n\tIsNot          bool                `json:\"isNot\"`\n\tTimeout        *float64            `json:\"timeout\"`\n}\n\ntype frameExpectResult struct {\n\tMatches  bool        `json:\"matches\"`\n\tReceived interface{} `json:\"received\"`\n\tLog      []string    `json:\"log\"`\n}\n\ntype assertionsBase struct {\n\tactualLocator  Locator\n\tisNot          bool\n\tdefaultTimeout *float64\n}\n\nfunc (b *assertionsBase) expect(\n\texpression string,\n\toptions frameExpectOptions,\n\texpected interface{},\n\tmessage string,\n) error {\n\toptions.IsNot = b.isNot\n\tif options.Timeout == nil {\n\t\toptions.Timeout = b.defaultTimeout\n\t}\n\tif options.IsNot {\n\t\tmessage = strings.ReplaceAll(message, \"expected to\", \"expected not to\")\n\t}\n\tresult, err := b.actualLocator.(*locatorImpl).expect(expression, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif result.Matches == b.isNot {\n\t\tactual := result.Received\n\t\tlog := strings.Join(result.Log, \"\\n\")\n\t\tif log != \"\" {\n\t\t\tlog = \"\\nCall log:\\n\" + log\n\t\t}\n\t\tif expected != nil {\n\t\t\treturn fmt.Errorf(\"%s '%v'\\nActual value: %v %s\", message, expected, actual, log)\n\t\t}\n\t\treturn fmt.Errorf(\"%s\\nActual value: %v %s\", message, actual, log)\n\t}\n\n\treturn nil\n}\n\nfunc toExpectedTextValues(\n\titems []interface{},\n\tmatchSubstring bool,\n\tnormalizeWhiteSpace bool,\n\tignoreCase *bool,\n) ([]expectedTextValue, error) {\n\tvar out []expectedTextValue\n\tfor _, item := range items {\n\t\tswitch item := item.(type) {\n\t\tcase string:\n\t\t\tout = append(out, expectedTextValue{\n\t\t\t\tStr:                 String(item),\n\t\t\t\tMatchSubstring:      Bool(matchSubstring),\n\t\t\t\tNormalizeWhiteSpace: Bool(normalizeWhiteSpace),\n\t\t\t\tIgnoreCase:          ignoreCase,\n\t\t\t})\n\t\tcase *regexp.Regexp:\n\t\t\tpattern, flags := convertRegexp(item)\n\t\t\tout = append(out, expectedTextValue{\n\t\t\t\tRegexSource:         String(pattern),\n\t\t\t\tRegexFlags:          String(flags),\n\t\t\t\tMatchSubstring:      Bool(matchSubstring),\n\t\t\t\tNormalizeWhiteSpace: Bool(normalizeWhiteSpace),\n\t\t\t\tIgnoreCase:          ignoreCase,\n\t\t\t})\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"value must be a string or regexp\")\n\t\t}\n\t}\n\treturn out, nil\n}\n\nfunc convertToInterfaceList(v interface{}) []interface{} {\n\trv := reflect.ValueOf(v)\n\tif rv.Kind() != reflect.Slice {\n\t\treturn []interface{}{v}\n\t}\n\n\tlist := make([]interface{}, rv.Len())\n\tfor i := 0; i < rv.Len(); i++ {\n\t\tlist[i] = rv.Index(i).Interface()\n\t}\n\treturn list\n}\n"
        },
        {
          "name": "binding_call.go",
          "type": "blob",
          "size": 2.296875,
          "content": "package playwright\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/go-stack/stack\"\n)\n\ntype BindingCall interface {\n\tCall(f BindingCallFunction)\n}\n\ntype bindingCallImpl struct {\n\tchannelOwner\n}\n\n// BindingSource is the value passed to a binding call execution\ntype BindingSource struct {\n\tContext BrowserContext\n\tPage    Page\n\tFrame   Frame\n}\n\n// ExposedFunction represents the func signature of an exposed function\ntype ExposedFunction = func(args ...interface{}) interface{}\n\n// BindingCallFunction represents the func signature of an exposed binding call func\ntype BindingCallFunction func(source *BindingSource, args ...interface{}) interface{}\n\nfunc (b *bindingCallImpl) Call(f BindingCallFunction) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif _, err := b.channel.Send(\"reject\", map[string]interface{}{\n\t\t\t\t\"error\": serializeError(r.(error)),\n\t\t\t}); err != nil {\n\t\t\t\tlogger.Error(\"could not reject BindingCall\", \"error\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tframe := fromChannel(b.initializer[\"frame\"]).(*frameImpl)\n\tsource := &BindingSource{\n\t\tContext: frame.Page().Context(),\n\t\tPage:    frame.Page(),\n\t\tFrame:   frame,\n\t}\n\tvar result interface{}\n\tif handle, ok := b.initializer[\"handle\"]; ok {\n\t\tresult = f(source, fromChannel(handle))\n\t} else {\n\t\tinitializerArgs := b.initializer[\"args\"].([]interface{})\n\t\tfuncArgs := []interface{}{}\n\t\tfor i := 0; i < len(initializerArgs); i++ {\n\t\t\tfuncArgs = append(funcArgs, parseResult(initializerArgs[i]))\n\t\t}\n\t\tresult = f(source, funcArgs...)\n\t}\n\t_, err := b.channel.Send(\"resolve\", map[string]interface{}{\n\t\t\"result\": serializeArgument(result),\n\t})\n\tif err != nil {\n\t\tlogger.Error(\"could not resolve BindingCall\", \"error\", err)\n\t}\n}\n\nfunc serializeError(err error) map[string]interface{} {\n\tst := stack.Trace().TrimRuntime()\n\tif len(st) == 0 { // https://github.com/go-stack/stack/issues/27\n\t\tst = stack.Trace()\n\t}\n\treturn map[string]interface{}{\n\t\t\"error\": &Error{\n\t\t\tName:    \"Playwright for Go Error\",\n\t\t\tMessage: err.Error(),\n\t\t\tStack: strings.ReplaceAll(strings.TrimFunc(fmt.Sprintf(\"%+v\", st), func(r rune) bool {\n\t\t\t\treturn r == '[' || r == ']'\n\t\t\t}), \" \", \"\\n\"),\n\t\t},\n\t}\n}\n\nfunc newBindingCall(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *bindingCallImpl {\n\tbt := &bindingCallImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\treturn bt\n}\n"
        },
        {
          "name": "browser.go",
          "type": "blob",
          "size": 7.03125,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype browserImpl struct {\n\tchannelOwner\n\tisConnected                  bool\n\tshouldCloseConnectionOnClose bool\n\tcontexts                     []BrowserContext\n\tbrowserType                  BrowserType\n\tchromiumTracingPath          *string\n\tcloseReason                  *string\n}\n\nfunc (b *browserImpl) BrowserType() BrowserType {\n\treturn b.browserType\n}\n\nfunc (b *browserImpl) IsConnected() bool {\n\tb.RLock()\n\tdefer b.RUnlock()\n\treturn b.isConnected\n}\n\nfunc (b *browserImpl) NewContext(options ...BrowserNewContextOptions) (BrowserContext, error) {\n\toverrides := map[string]interface{}{}\n\toption := BrowserNewContextOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.AcceptDownloads != nil {\n\t\tif *option.AcceptDownloads {\n\t\t\toverrides[\"acceptDownloads\"] = \"accept\"\n\t\t} else {\n\t\t\toverrides[\"acceptDownloads\"] = \"deny\"\n\t\t}\n\t\toptions[0].AcceptDownloads = nil\n\t}\n\tif option.ExtraHttpHeaders != nil {\n\t\toverrides[\"extraHTTPHeaders\"] = serializeMapToNameAndValue(options[0].ExtraHttpHeaders)\n\t\toptions[0].ExtraHttpHeaders = nil\n\t}\n\tif option.ClientCertificates != nil {\n\t\tcerts, err := transformClientCertificate(option.ClientCertificates)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\toverrides[\"clientCertificates\"] = certs\n\t\toptions[0].ClientCertificates = nil\n\t}\n\tif option.StorageStatePath != nil {\n\t\tvar storageState *OptionalStorageState\n\t\tstorageString, err := os.ReadFile(*options[0].StorageStatePath)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not read storage state file: %w\", err)\n\t\t}\n\t\terr = json.Unmarshal(storageString, &storageState)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not parse storage state file: %w\", err)\n\t\t}\n\t\toptions[0].StorageState = storageState\n\t\toptions[0].StorageStatePath = nil\n\t}\n\tif option.NoViewport != nil && *options[0].NoViewport {\n\t\toverrides[\"noDefaultViewport\"] = true\n\t\toptions[0].NoViewport = nil\n\t}\n\tif option.RecordHarPath != nil {\n\t\toverrides[\"recordHar\"] = prepareRecordHarOptions(recordHarInputOptions{\n\t\t\tPath:        *options[0].RecordHarPath,\n\t\t\tURL:         options[0].RecordHarURLFilter,\n\t\t\tMode:        options[0].RecordHarMode,\n\t\t\tContent:     options[0].RecordHarContent,\n\t\t\tOmitContent: options[0].RecordHarOmitContent,\n\t\t})\n\t\toptions[0].RecordHarPath = nil\n\t\toptions[0].RecordHarURLFilter = nil\n\t\toptions[0].RecordHarMode = nil\n\t\toptions[0].RecordHarContent = nil\n\t\toptions[0].RecordHarOmitContent = nil\n\t}\n\tchannel, err := b.channel.Send(\"newContext\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontext := fromChannel(channel).(*browserContextImpl)\n\tcontext.browser = b\n\tb.browserType.(*browserTypeImpl).didCreateContext(context, &option, nil)\n\treturn context, nil\n}\n\nfunc (b *browserImpl) NewPage(options ...BrowserNewPageOptions) (Page, error) {\n\topts := make([]BrowserNewContextOptions, 0)\n\tif len(options) == 1 {\n\t\topts = append(opts, BrowserNewContextOptions(options[0]))\n\t}\n\tcontext, err := b.NewContext(opts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpage, err := context.NewPage()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpage.(*pageImpl).ownedContext = context\n\tcontext.(*browserContextImpl).ownedPage = page\n\treturn page, nil\n}\n\nfunc (b *browserImpl) NewBrowserCDPSession() (CDPSession, error) {\n\tchannel, err := b.channel.Send(\"newBrowserCDPSession\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcdpSession := fromChannel(channel).(*cdpSessionImpl)\n\n\treturn cdpSession, nil\n}\n\nfunc (b *browserImpl) Contexts() []BrowserContext {\n\tb.Lock()\n\tdefer b.Unlock()\n\treturn b.contexts\n}\n\nfunc (b *browserImpl) Close(options ...BrowserCloseOptions) (err error) {\n\tif len(options) == 1 {\n\t\tb.closeReason = options[0].Reason\n\t}\n\n\tif b.shouldCloseConnectionOnClose {\n\t\terr = b.connection.Stop()\n\t} else if b.closeReason != nil {\n\t\t_, err = b.channel.Send(\"close\", map[string]interface{}{\n\t\t\t\"reason\": b.closeReason,\n\t\t})\n\t} else {\n\t\t_, err = b.channel.Send(\"close\")\n\t}\n\tif err != nil && !errors.Is(err, ErrTargetClosed) {\n\t\treturn fmt.Errorf(\"close browser failed: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc (b *browserImpl) Version() string {\n\treturn b.initializer[\"version\"].(string)\n}\n\nfunc (b *browserImpl) StartTracing(options ...BrowserStartTracingOptions) error {\n\toverrides := map[string]interface{}{}\n\toption := BrowserStartTracingOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.Page != nil {\n\t\toverrides[\"page\"] = option.Page.(*pageImpl).channel\n\t\toption.Page = nil\n\t}\n\tif option.Path != nil {\n\t\tb.chromiumTracingPath = option.Path\n\t\toption.Path = nil\n\t}\n\t_, err := b.channel.Send(\"startTracing\", option, overrides)\n\treturn err\n}\n\nfunc (b *browserImpl) StopTracing() ([]byte, error) {\n\tchannel, err := b.channel.Send(\"stopTracing\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tartifact := fromChannel(channel).(*artifactImpl)\n\tbinary, err := artifact.ReadIntoBuffer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = artifact.Delete()\n\tif err != nil {\n\t\treturn binary, err\n\t}\n\tif b.chromiumTracingPath != nil {\n\t\terr := os.MkdirAll(filepath.Dir(*b.chromiumTracingPath), 0o777)\n\t\tif err != nil {\n\t\t\treturn binary, err\n\t\t}\n\t\terr = os.WriteFile(*b.chromiumTracingPath, binary, 0o644)\n\t\tif err != nil {\n\t\t\treturn binary, err\n\t\t}\n\t}\n\treturn binary, nil\n}\n\nfunc (b *browserImpl) onClose() {\n\tb.Lock()\n\tif b.isConnected {\n\t\tb.isConnected = false\n\t\tb.Unlock()\n\t\tb.Emit(\"disconnected\", b)\n\t\treturn\n\t}\n\tb.Unlock()\n}\n\nfunc (b *browserImpl) OnDisconnected(fn func(Browser)) {\n\tb.On(\"disconnected\", fn)\n}\n\nfunc newBrowser(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *browserImpl {\n\tb := &browserImpl{\n\t\tisConnected: true,\n\t\tcontexts:    make([]BrowserContext, 0),\n\t}\n\tb.createChannelOwner(b, parent, objectType, guid, initializer)\n\t// convert parent to *browserTypeImpl\n\tb.browserType = newBrowserType(parent.parent, parent.objectType, parent.guid, parent.initializer)\n\tb.channel.On(\"close\", b.onClose)\n\treturn b\n}\n\nfunc transformClientCertificate(clientCertificates []ClientCertificate) ([]map[string]interface{}, error) {\n\tresults := make([]map[string]interface{}, 0)\n\n\tfor _, cert := range clientCertificates {\n\t\tdata := map[string]interface{}{\n\t\t\t\"origin\":     cert.Origin,\n\t\t\t\"passphrase\": cert.Passphrase,\n\t\t}\n\t\tif len(cert.Cert) > 0 {\n\t\t\tdata[\"cert\"] = base64.StdEncoding.EncodeToString(cert.Cert)\n\t\t} else if cert.CertPath != nil {\n\t\t\tcontent, err := os.ReadFile(*cert.CertPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdata[\"cert\"] = base64.StdEncoding.EncodeToString(content)\n\t\t}\n\n\t\tif len(cert.Key) > 0 {\n\t\t\tdata[\"key\"] = base64.StdEncoding.EncodeToString(cert.Key)\n\t\t} else if cert.KeyPath != nil {\n\t\t\tcontent, err := os.ReadFile(*cert.KeyPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdata[\"key\"] = base64.StdEncoding.EncodeToString(content)\n\t\t}\n\n\t\tif len(cert.Pfx) > 0 {\n\t\t\tdata[\"pfx\"] = base64.StdEncoding.EncodeToString(cert.Pfx)\n\t\t} else if cert.PfxPath != nil {\n\t\t\tcontent, err := os.ReadFile(*cert.PfxPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdata[\"pfx\"] = base64.StdEncoding.EncodeToString(content)\n\t\t}\n\n\t\tresults = append(results, data)\n\t}\n\tif len(results) == 0 {\n\t\treturn nil, nil\n\t}\n\treturn results, nil\n}\n"
        },
        {
          "name": "browser_context.go",
          "type": "blob",
          "size": 24.73828125,
          "content": "package playwright\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n\t\"slices\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/playwright-community/playwright-go/internal/safe\"\n)\n\ntype browserContextImpl struct {\n\tchannelOwner\n\ttimeoutSettings *timeoutSettings\n\tcloseWasCalled  bool\n\toptions         *BrowserNewContextOptions\n\tpages           []Page\n\troutes          []*routeHandlerEntry\n\twebSocketRoutes []*webSocketRouteHandler\n\townedPage       Page\n\tbrowser         *browserImpl\n\tserviceWorkers  []Worker\n\tbackgroundPages []Page\n\tbindings        *safe.SyncMap[string, BindingCallFunction]\n\ttracing         *tracingImpl\n\trequest         *apiRequestContextImpl\n\tharRecorders    map[string]harRecordingMetadata\n\tclosed          chan struct{}\n\tcloseReason     *string\n\tharRouters      []*harRouter\n\tclock           Clock\n}\n\nfunc (b *browserContextImpl) Clock() Clock {\n\treturn b.clock\n}\n\nfunc (b *browserContextImpl) SetDefaultNavigationTimeout(timeout float64) {\n\tb.setDefaultNavigationTimeoutImpl(&timeout)\n}\n\nfunc (b *browserContextImpl) setDefaultNavigationTimeoutImpl(timeout *float64) {\n\tb.timeoutSettings.SetDefaultNavigationTimeout(timeout)\n\tb.channel.SendNoReplyInternal(\"setDefaultNavigationTimeoutNoReply\", map[string]interface{}{\n\t\t\"timeout\": timeout,\n\t})\n}\n\nfunc (b *browserContextImpl) SetDefaultTimeout(timeout float64) {\n\tb.setDefaultTimeoutImpl(&timeout)\n}\n\nfunc (b *browserContextImpl) setDefaultTimeoutImpl(timeout *float64) {\n\tb.timeoutSettings.SetDefaultTimeout(timeout)\n\tb.channel.SendNoReplyInternal(\"setDefaultTimeoutNoReply\", map[string]interface{}{\n\t\t\"timeout\": timeout,\n\t})\n}\n\nfunc (b *browserContextImpl) Pages() []Page {\n\tb.Lock()\n\tdefer b.Unlock()\n\treturn b.pages\n}\n\nfunc (b *browserContextImpl) Browser() Browser {\n\treturn b.browser\n}\n\nfunc (b *browserContextImpl) Tracing() Tracing {\n\treturn b.tracing\n}\n\nfunc (b *browserContextImpl) NewCDPSession(page interface{}) (CDPSession, error) {\n\tparams := map[string]interface{}{}\n\n\tif p, ok := page.(*pageImpl); ok {\n\t\tparams[\"page\"] = p.channel\n\t} else if f, ok := page.(*frameImpl); ok {\n\t\tparams[\"frame\"] = f.channel\n\t} else {\n\t\treturn nil, fmt.Errorf(\"not page or frame: %v\", page)\n\t}\n\n\tchannel, err := b.channel.Send(\"newCDPSession\", params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcdpSession := fromChannel(channel).(*cdpSessionImpl)\n\n\treturn cdpSession, nil\n}\n\nfunc (b *browserContextImpl) NewPage() (Page, error) {\n\tif b.ownedPage != nil {\n\t\treturn nil, errors.New(\"Please use browser.NewContext()\")\n\t}\n\tchannel, err := b.channel.Send(\"newPage\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(channel).(*pageImpl), nil\n}\n\nfunc (b *browserContextImpl) Cookies(urls ...string) ([]Cookie, error) {\n\tresult, err := b.channel.Send(\"cookies\", map[string]interface{}{\n\t\t\"urls\": urls,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcookies := make([]Cookie, len(result.([]interface{})))\n\tfor i, item := range result.([]interface{}) {\n\t\tcookie := &Cookie{}\n\t\tremapMapToStruct(item, cookie)\n\t\tcookies[i] = *cookie\n\t}\n\treturn cookies, nil\n}\n\nfunc (b *browserContextImpl) AddCookies(cookies []OptionalCookie) error {\n\t_, err := b.channel.Send(\"addCookies\", map[string]interface{}{\n\t\t\"cookies\": cookies,\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) ClearCookies(options ...BrowserContextClearCookiesOptions) error {\n\tparams := map[string]interface{}{}\n\tif len(options) == 1 {\n\t\tif options[0].Domain != nil {\n\t\t\tswitch t := options[0].Domain.(type) {\n\t\t\tcase string:\n\t\t\t\tparams[\"domain\"] = t\n\t\t\tcase *string:\n\t\t\t\tparams[\"domain\"] = t\n\t\t\tcase *regexp.Regexp:\n\t\t\t\tpattern, flag := convertRegexp(t)\n\t\t\t\tparams[\"domainRegexSource\"] = pattern\n\t\t\t\tparams[\"domainRegexFlags\"] = flag\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid type for domain, expected string or *regexp.Regexp\")\n\t\t\t}\n\t\t}\n\t\tif options[0].Name != nil {\n\t\t\tswitch t := options[0].Name.(type) {\n\t\t\tcase string:\n\t\t\t\tparams[\"name\"] = t\n\t\t\tcase *string:\n\t\t\t\tparams[\"name\"] = t\n\t\t\tcase *regexp.Regexp:\n\t\t\t\tpattern, flag := convertRegexp(t)\n\t\t\t\tparams[\"nameRegexSource\"] = pattern\n\t\t\t\tparams[\"nameRegexFlags\"] = flag\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid type for name, expected string or *regexp.Regexp\")\n\t\t\t}\n\t\t}\n\t\tif options[0].Path != nil {\n\t\t\tswitch t := options[0].Path.(type) {\n\t\t\tcase string:\n\t\t\t\tparams[\"path\"] = t\n\t\t\tcase *string:\n\t\t\t\tparams[\"path\"] = t\n\t\t\tcase *regexp.Regexp:\n\t\t\t\tpattern, flag := convertRegexp(t)\n\t\t\t\tparams[\"pathRegexSource\"] = pattern\n\t\t\t\tparams[\"pathRegexFlags\"] = flag\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid type for path, expected string or *regexp.Regexp\")\n\t\t\t}\n\t\t}\n\t}\n\t_, err := b.channel.Send(\"clearCookies\", params)\n\treturn err\n}\n\nfunc (b *browserContextImpl) GrantPermissions(permissions []string, options ...BrowserContextGrantPermissionsOptions) error {\n\t_, err := b.channel.Send(\"grantPermissions\", map[string]interface{}{\n\t\t\"permissions\": permissions,\n\t}, options)\n\treturn err\n}\n\nfunc (b *browserContextImpl) ClearPermissions() error {\n\t_, err := b.channel.Send(\"clearPermissions\")\n\treturn err\n}\n\nfunc (b *browserContextImpl) SetGeolocation(geolocation *Geolocation) error {\n\t_, err := b.channel.Send(\"setGeolocation\", map[string]interface{}{\n\t\t\"geolocation\": geolocation,\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) ResetGeolocation() error {\n\t_, err := b.channel.Send(\"setGeolocation\", map[string]interface{}{})\n\treturn err\n}\n\nfunc (b *browserContextImpl) SetExtraHTTPHeaders(headers map[string]string) error {\n\t_, err := b.channel.Send(\"setExtraHTTPHeaders\", map[string]interface{}{\n\t\t\"headers\": serializeMapToNameAndValue(headers),\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) SetOffline(offline bool) error {\n\t_, err := b.channel.Send(\"setOffline\", map[string]interface{}{\n\t\t\"offline\": offline,\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) AddInitScript(script Script) error {\n\tvar source string\n\tif script.Content != nil {\n\t\tsource = *script.Content\n\t}\n\tif script.Path != nil {\n\t\tcontent, err := os.ReadFile(*script.Path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsource = string(content)\n\t}\n\t_, err := b.channel.Send(\"addInitScript\", map[string]interface{}{\n\t\t\"source\": source,\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) ExposeBinding(name string, binding BindingCallFunction, handle ...bool) error {\n\tneedsHandle := false\n\tif len(handle) == 1 {\n\t\tneedsHandle = handle[0]\n\t}\n\tfor _, page := range b.Pages() {\n\t\tif _, ok := page.(*pageImpl).bindings.Load(name); ok {\n\t\t\treturn fmt.Errorf(\"Function '%s' has been already registered in one of the pages\", name)\n\t\t}\n\t}\n\tif _, ok := b.bindings.Load(name); ok {\n\t\treturn fmt.Errorf(\"Function '%s' has been already registered\", name)\n\t}\n\t_, err := b.channel.Send(\"exposeBinding\", map[string]interface{}{\n\t\t\"name\":        name,\n\t\t\"needsHandle\": needsHandle,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.bindings.Store(name, binding)\n\treturn err\n}\n\nfunc (b *browserContextImpl) ExposeFunction(name string, binding ExposedFunction) error {\n\treturn b.ExposeBinding(name, func(source *BindingSource, args ...interface{}) interface{} {\n\t\treturn binding(args...)\n\t})\n}\n\nfunc (b *browserContextImpl) Route(url interface{}, handler routeHandler, times ...int) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\tb.routes = slices.Insert(b.routes, 0, newRouteHandlerEntry(newURLMatcher(url, b.options.BaseURL), handler, times...))\n\treturn b.updateInterceptionPatterns()\n}\n\nfunc (b *browserContextImpl) Unroute(url interface{}, handlers ...routeHandler) error {\n\tremoved, remaining, err := unroute(b.routes, url, handlers...)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn b.unrouteInternal(removed, remaining, UnrouteBehaviorDefault)\n}\n\nfunc (b *browserContextImpl) unrouteInternal(removed []*routeHandlerEntry, remaining []*routeHandlerEntry, behavior *UnrouteBehavior) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\tb.routes = remaining\n\tif err := b.updateInterceptionPatterns(); err != nil {\n\t\treturn err\n\t}\n\tif behavior == nil || behavior == UnrouteBehaviorDefault {\n\t\treturn nil\n\t}\n\twg := &sync.WaitGroup{}\n\tfor _, entry := range removed {\n\t\twg.Add(1)\n\t\tgo func(entry *routeHandlerEntry) {\n\t\t\tdefer wg.Done()\n\t\t\tentry.Stop(string(*behavior))\n\t\t}(entry)\n\t}\n\twg.Wait()\n\treturn nil\n}\n\nfunc (b *browserContextImpl) UnrouteAll(options ...BrowserContextUnrouteAllOptions) error {\n\tvar behavior *UnrouteBehavior\n\tif len(options) == 1 {\n\t\tbehavior = options[0].Behavior\n\t}\n\tdefer b.disposeHarRouters()\n\treturn b.unrouteInternal(b.routes, []*routeHandlerEntry{}, behavior)\n}\n\nfunc (b *browserContextImpl) disposeHarRouters() {\n\tfor _, router := range b.harRouters {\n\t\trouter.dispose()\n\t}\n\tb.harRouters = make([]*harRouter, 0)\n}\n\nfunc (b *browserContextImpl) Request() APIRequestContext {\n\treturn b.request\n}\n\nfunc (b *browserContextImpl) RouteFromHAR(har string, options ...BrowserContextRouteFromHAROptions) error {\n\topt := BrowserContextRouteFromHAROptions{}\n\tif len(options) == 1 {\n\t\topt = options[0]\n\t}\n\tif opt.Update != nil && *opt.Update {\n\t\tvar updateContent *HarContentPolicy\n\t\tswitch opt.UpdateContent {\n\t\tcase RouteFromHarUpdateContentPolicyAttach:\n\t\t\tupdateContent = HarContentPolicyAttach\n\t\tcase RouteFromHarUpdateContentPolicyEmbed:\n\t\t\tupdateContent = HarContentPolicyEmbed\n\t\t}\n\t\treturn b.recordIntoHar(har, browserContextRecordIntoHarOptions{\n\t\t\tURL:           opt.URL,\n\t\t\tUpdateContent: updateContent,\n\t\t\tUpdateMode:    opt.UpdateMode,\n\t\t})\n\t}\n\tnotFound := opt.NotFound\n\tif notFound == nil {\n\t\tnotFound = HarNotFoundAbort\n\t}\n\trouter := newHarRouter(b.connection.localUtils, har, *notFound, opt.URL)\n\tb.harRouters = append(b.harRouters, router)\n\treturn router.addContextRoute(b)\n}\n\nfunc (b *browserContextImpl) WaitForEvent(event string, options ...BrowserContextWaitForEventOptions) (interface{}, error) {\n\treturn b.waiterForEvent(event, options...).Wait()\n}\n\nfunc (b *browserContextImpl) waiterForEvent(event string, options ...BrowserContextWaitForEventOptions) *waiter {\n\ttimeout := b.timeoutSettings.Timeout()\n\tvar predicate interface{} = nil\n\tif len(options) == 1 {\n\t\tif options[0].Timeout != nil {\n\t\t\ttimeout = *options[0].Timeout\n\t\t}\n\t\tpredicate = options[0].Predicate\n\t}\n\twaiter := newWaiter().WithTimeout(timeout)\n\twaiter.RejectOnEvent(b, \"close\", ErrTargetClosed)\n\treturn waiter.WaitForEvent(b, event, predicate)\n}\n\nfunc (b *browserContextImpl) ExpectConsoleMessage(cb func() error, options ...BrowserContextExpectConsoleMessageOptions) (ConsoleMessage, error) {\n\tvar w *waiter\n\tif len(options) == 1 {\n\t\tw = b.waiterForEvent(\"console\", BrowserContextWaitForEventOptions{\n\t\t\tPredicate: options[0].Predicate,\n\t\t\tTimeout:   options[0].Timeout,\n\t\t})\n\t} else {\n\t\tw = b.waiterForEvent(\"console\")\n\t}\n\tret, err := w.RunAndWait(cb)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(ConsoleMessage), nil\n}\n\nfunc (b *browserContextImpl) ExpectEvent(event string, cb func() error, options ...BrowserContextExpectEventOptions) (interface{}, error) {\n\tif len(options) == 1 {\n\t\treturn b.waiterForEvent(event, BrowserContextWaitForEventOptions(options[0])).RunAndWait(cb)\n\t}\n\treturn b.waiterForEvent(event).RunAndWait(cb)\n}\n\nfunc (b *browserContextImpl) ExpectPage(cb func() error, options ...BrowserContextExpectPageOptions) (Page, error) {\n\tvar w *waiter\n\tif len(options) == 1 {\n\t\tw = b.waiterForEvent(\"page\", BrowserContextWaitForEventOptions{\n\t\t\tPredicate: options[0].Predicate,\n\t\t\tTimeout:   options[0].Timeout,\n\t\t})\n\t} else {\n\t\tw = b.waiterForEvent(\"page\")\n\t}\n\tret, err := w.RunAndWait(cb)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(Page), nil\n}\n\nfunc (b *browserContextImpl) Close(options ...BrowserContextCloseOptions) error {\n\tif b.closeWasCalled {\n\t\treturn nil\n\t}\n\tif len(options) == 1 {\n\t\tb.closeReason = options[0].Reason\n\t}\n\tb.closeWasCalled = true\n\n\t_, err := b.channel.connection.WrapAPICall(func() (interface{}, error) {\n\t\treturn nil, b.request.Dispose(APIRequestContextDisposeOptions{\n\t\t\tReason: b.closeReason,\n\t\t})\n\t}, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinnerClose := func() (interface{}, error) {\n\t\tfor harId, harMetaData := range b.harRecorders {\n\t\t\toverrides := map[string]interface{}{}\n\t\t\tif harId != \"\" {\n\t\t\t\toverrides[\"harId\"] = harId\n\t\t\t}\n\t\t\tresponse, err := b.channel.Send(\"harExport\", overrides)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tartifact := fromChannel(response).(*artifactImpl)\n\t\t\t// Server side will compress artifact if content is attach or if file is .zip.\n\t\t\tneedCompressed := strings.HasSuffix(strings.ToLower(harMetaData.Path), \".zip\")\n\t\t\tif !needCompressed && harMetaData.Content == HarContentPolicyAttach {\n\t\t\t\ttmpPath := harMetaData.Path + \".tmp\"\n\t\t\t\tif err := artifact.SaveAs(tmpPath); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\terr = b.connection.localUtils.HarUnzip(tmpPath, harMetaData.Path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := artifact.SaveAs(harMetaData.Path); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := artifact.Delete(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t}\n\n\t_, err = b.channel.connection.WrapAPICall(innerClose, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = b.channel.Send(\"close\", map[string]interface{}{\n\t\t\"reason\": b.closeReason,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\t<-b.closed\n\treturn err\n}\n\ntype browserContextRecordIntoHarOptions struct {\n\tPage          Page\n\tURL           interface{}\n\tUpdateContent *HarContentPolicy\n\tUpdateMode    *HarMode\n}\n\nfunc (b *browserContextImpl) recordIntoHar(har string, options ...browserContextRecordIntoHarOptions) error {\n\toverrides := map[string]interface{}{}\n\tharOptions := recordHarInputOptions{\n\t\tPath:    har,\n\t\tContent: HarContentPolicyAttach,\n\t\tMode:    HarModeMinimal,\n\t}\n\tif len(options) == 1 {\n\t\tif options[0].UpdateContent != nil {\n\t\t\tharOptions.Content = options[0].UpdateContent\n\t\t}\n\t\tif options[0].UpdateMode != nil {\n\t\t\tharOptions.Mode = options[0].UpdateMode\n\t\t}\n\t\tharOptions.URL = options[0].URL\n\t\toverrides[\"options\"] = prepareRecordHarOptions(harOptions)\n\t\tif options[0].Page != nil {\n\t\t\toverrides[\"page\"] = options[0].Page.(*pageImpl).channel\n\t\t}\n\t}\n\tharId, err := b.channel.Send(\"harStart\", overrides)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb.harRecorders[harId.(string)] = harRecordingMetadata{\n\t\tPath:    har,\n\t\tContent: harOptions.Content,\n\t}\n\treturn nil\n}\n\nfunc (b *browserContextImpl) StorageState(paths ...string) (*StorageState, error) {\n\tresult, err := b.channel.SendReturnAsDict(\"storageState\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(paths) == 1 {\n\t\tfile, err := os.Create(paths[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := json.NewEncoder(file).Encode(result); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := file.Close(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tvar storageState StorageState\n\tremapMapToStruct(result, &storageState)\n\treturn &storageState, nil\n}\n\nfunc (b *browserContextImpl) onBinding(binding *bindingCallImpl) {\n\tfunction, ok := b.bindings.Load(binding.initializer[\"name\"].(string))\n\tif !ok || function == nil {\n\t\treturn\n\t}\n\tgo binding.Call(function)\n}\n\nfunc (b *browserContextImpl) onClose() {\n\tif b.browser != nil {\n\t\tcontexts := make([]BrowserContext, 0)\n\t\tb.browser.Lock()\n\t\tfor _, context := range b.browser.contexts {\n\t\t\tif context != b {\n\t\t\t\tcontexts = append(contexts, context)\n\t\t\t}\n\t\t}\n\t\tb.browser.contexts = contexts\n\t\tb.browser.Unlock()\n\t}\n\tb.disposeHarRouters()\n\tb.Emit(\"close\", b)\n}\n\nfunc (b *browserContextImpl) onPage(page Page) {\n\tb.Lock()\n\tb.pages = append(b.pages, page)\n\tb.Unlock()\n\tb.Emit(\"page\", page)\n\topener, _ := page.Opener()\n\tif opener != nil && !opener.IsClosed() {\n\t\topener.Emit(\"popup\", page)\n\t}\n}\n\nfunc (b *browserContextImpl) onRoute(route *routeImpl) {\n\tb.Lock()\n\troute.context = b\n\tpage := route.Request().(*requestImpl).safePage()\n\troutes := make([]*routeHandlerEntry, len(b.routes))\n\tcopy(routes, b.routes)\n\tb.Unlock()\n\n\tcheckInterceptionIfNeeded := func() {\n\t\tb.Lock()\n\t\tdefer b.Unlock()\n\t\tif len(b.routes) == 0 {\n\t\t\t_, err := b.connection.WrapAPICall(func() (interface{}, error) {\n\t\t\t\terr := b.updateInterceptionPatterns()\n\t\t\t\treturn nil, err\n\t\t\t}, true)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"could not update interception patterns\", \"error\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\turl := route.Request().URL()\n\tfor _, handlerEntry := range routes {\n\t\t// If the page or the context was closed we stall all requests right away.\n\t\tif (page != nil && page.closeWasCalled) || b.closeWasCalled {\n\t\t\treturn\n\t\t}\n\t\tif !handlerEntry.Matches(url) {\n\t\t\tcontinue\n\t\t}\n\t\tif !slices.ContainsFunc(b.routes, func(entry *routeHandlerEntry) bool {\n\t\t\treturn entry == handlerEntry\n\t\t}) {\n\t\t\tcontinue\n\t\t}\n\t\tif handlerEntry.WillExceed() {\n\t\t\tb.routes = slices.DeleteFunc(b.routes, func(rhe *routeHandlerEntry) bool {\n\t\t\t\treturn rhe == handlerEntry\n\t\t\t})\n\t\t}\n\t\thandled := handlerEntry.Handle(route)\n\t\tcheckInterceptionIfNeeded()\n\t\tyes := <-handled\n\t\tif yes {\n\t\t\treturn\n\t\t}\n\t}\n\t// If the page is closed or unrouteAll() was called without waiting and interception disabled,\n\t// the method will throw an error - silence it.\n\t_ = route.internalContinue(true)\n}\n\nfunc (b *browserContextImpl) updateInterceptionPatterns() error {\n\tpatterns := prepareInterceptionPatterns(b.routes)\n\t_, err := b.channel.Send(\"setNetworkInterceptionPatterns\", map[string]interface{}{\n\t\t\"patterns\": patterns,\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) pause() <-chan error {\n\tret := make(chan error, 1)\n\tgo func() {\n\t\t_, err := b.channel.Send(\"pause\")\n\t\tret <- err\n\t}()\n\treturn ret\n}\n\nfunc (b *browserContextImpl) onBackgroundPage(ev map[string]interface{}) {\n\tb.Lock()\n\tp := fromChannel(ev[\"page\"]).(*pageImpl)\n\tp.browserContext = b\n\tb.backgroundPages = append(b.backgroundPages, p)\n\tb.Unlock()\n\tb.Emit(\"backgroundpage\", p)\n}\n\nfunc (b *browserContextImpl) onServiceWorker(worker *workerImpl) {\n\tworker.context = b\n\tb.serviceWorkers = append(b.serviceWorkers, worker)\n\tb.Emit(\"serviceworker\", worker)\n}\n\nfunc (b *browserContextImpl) setOptions(options *BrowserNewContextOptions, tracesDir *string) {\n\tif options == nil {\n\t\toptions = &BrowserNewContextOptions{}\n\t}\n\tb.options = options\n\tif b.options != nil && b.options.RecordHarPath != nil {\n\t\tb.harRecorders[\"\"] = harRecordingMetadata{\n\t\t\tPath:    *b.options.RecordHarPath,\n\t\t\tContent: b.options.RecordHarContent,\n\t\t}\n\t}\n\tif tracesDir != nil {\n\t\tb.tracing.tracesDir = *tracesDir\n\t}\n}\n\nfunc (b *browserContextImpl) BackgroundPages() []Page {\n\tb.Lock()\n\tdefer b.Unlock()\n\treturn b.backgroundPages\n}\n\nfunc (b *browserContextImpl) ServiceWorkers() []Worker {\n\tb.Lock()\n\tdefer b.Unlock()\n\treturn b.serviceWorkers\n}\n\nfunc (b *browserContextImpl) OnBackgroundPage(fn func(Page)) {\n\tb.On(\"backgroundpage\", fn)\n}\n\nfunc (b *browserContextImpl) OnClose(fn func(BrowserContext)) {\n\tb.On(\"close\", fn)\n}\n\nfunc (b *browserContextImpl) OnConsole(fn func(ConsoleMessage)) {\n\tb.On(\"console\", fn)\n}\n\nfunc (b *browserContextImpl) OnDialog(fn func(Dialog)) {\n\tb.On(\"dialog\", fn)\n}\n\nfunc (b *browserContextImpl) OnPage(fn func(Page)) {\n\tb.On(\"page\", fn)\n}\n\nfunc (b *browserContextImpl) OnRequest(fn func(Request)) {\n\tb.On(\"request\", fn)\n}\n\nfunc (b *browserContextImpl) OnRequestFailed(fn func(Request)) {\n\tb.On(\"requestfailed\", fn)\n}\n\nfunc (b *browserContextImpl) OnRequestFinished(fn func(Request)) {\n\tb.On(\"requestfinished\", fn)\n}\n\nfunc (b *browserContextImpl) OnResponse(fn func(Response)) {\n\tb.On(\"response\", fn)\n}\n\nfunc (b *browserContextImpl) OnWebError(fn func(WebError)) {\n\tb.On(\"weberror\", fn)\n}\n\nfunc (b *browserContextImpl) RouteWebSocket(url interface{}, handler func(WebSocketRoute)) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\tb.webSocketRoutes = slices.Insert(b.webSocketRoutes, 0, newWebSocketRouteHandler(newURLMatcher(url, b.options.BaseURL), handler))\n\n\treturn b.updateWebSocketInterceptionPatterns()\n}\n\nfunc (b *browserContextImpl) onWebSocketRoute(wr WebSocketRoute) {\n\tb.Lock()\n\tindex := slices.IndexFunc(b.webSocketRoutes, func(r *webSocketRouteHandler) bool {\n\t\treturn r.Matches(wr.URL())\n\t})\n\tif index == -1 {\n\t\tb.Unlock()\n\t\t_, err := wr.ConnectToServer()\n\t\tif err != nil {\n\t\t\tlogger.Error(\"could not connect to WebSocket server\", \"error\", err)\n\t\t}\n\t\treturn\n\t}\n\thandler := b.webSocketRoutes[index]\n\tb.Unlock()\n\thandler.Handle(wr)\n}\n\nfunc (b *browserContextImpl) updateWebSocketInterceptionPatterns() error {\n\tpatterns := prepareWebSocketRouteHandlerInterceptionPatterns(b.webSocketRoutes)\n\t_, err := b.channel.Send(\"setWebSocketInterceptionPatterns\", map[string]interface{}{\n\t\t\"patterns\": patterns,\n\t})\n\treturn err\n}\n\nfunc (b *browserContextImpl) effectiveCloseReason() *string {\n\tb.Lock()\n\tdefer b.Unlock()\n\tif b.closeReason != nil {\n\t\treturn b.closeReason\n\t}\n\tif b.browser != nil {\n\t\treturn b.browser.closeReason\n\t}\n\treturn nil\n}\n\nfunc newBrowserContext(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *browserContextImpl {\n\tbt := &browserContextImpl{\n\t\ttimeoutSettings: newTimeoutSettings(nil),\n\t\tpages:           make([]Page, 0),\n\t\tbackgroundPages: make([]Page, 0),\n\t\troutes:          make([]*routeHandlerEntry, 0),\n\t\tbindings:        safe.NewSyncMap[string, BindingCallFunction](),\n\t\tharRecorders:    make(map[string]harRecordingMetadata),\n\t\tclosed:          make(chan struct{}, 1),\n\t\tharRouters:      make([]*harRouter, 0),\n\t}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tif parent.objectType == \"Browser\" {\n\t\tbt.browser = fromChannel(parent.channel).(*browserImpl)\n\t\tbt.browser.contexts = append(bt.browser.contexts, bt)\n\t}\n\tbt.tracing = fromChannel(initializer[\"tracing\"]).(*tracingImpl)\n\tbt.request = fromChannel(initializer[\"requestContext\"]).(*apiRequestContextImpl)\n\tbt.clock = newClock(bt)\n\tbt.channel.On(\"bindingCall\", func(params map[string]interface{}) {\n\t\tbt.onBinding(fromChannel(params[\"binding\"]).(*bindingCallImpl))\n\t})\n\n\tbt.channel.On(\"close\", bt.onClose)\n\tbt.channel.On(\"page\", func(payload map[string]interface{}) {\n\t\tbt.onPage(fromChannel(payload[\"page\"]).(*pageImpl))\n\t})\n\tbt.channel.On(\"route\", func(params map[string]interface{}) {\n\t\tbt.channel.CreateTask(func() {\n\t\t\tbt.onRoute(fromChannel(params[\"route\"]).(*routeImpl))\n\t\t})\n\t})\n\tbt.channel.On(\"webSocketRoute\", func(params map[string]interface{}) {\n\t\tbt.channel.CreateTask(func() {\n\t\t\tbt.onWebSocketRoute(fromChannel(params[\"webSocketRoute\"]).(*webSocketRouteImpl))\n\t\t})\n\t})\n\tbt.channel.On(\"backgroundPage\", bt.onBackgroundPage)\n\tbt.channel.On(\"serviceWorker\", func(params map[string]interface{}) {\n\t\tbt.onServiceWorker(fromChannel(params[\"worker\"]).(*workerImpl))\n\t})\n\tbt.channel.On(\"console\", func(ev map[string]interface{}) {\n\t\tmessage := newConsoleMessage(ev)\n\t\tbt.Emit(\"console\", message)\n\t\tif message.page != nil {\n\t\t\tmessage.page.Emit(\"console\", message)\n\t\t}\n\t})\n\tbt.channel.On(\"dialog\", func(params map[string]interface{}) {\n\t\tdialog := fromChannel(params[\"dialog\"]).(*dialogImpl)\n\t\tgo func() {\n\t\t\thasListeners := bt.Emit(\"dialog\", dialog)\n\t\t\tpage := dialog.page\n\t\t\tif page != nil {\n\t\t\t\tif page.Emit(\"dialog\", dialog) {\n\t\t\t\t\thasListeners = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !hasListeners {\n\t\t\t\t// Although we do similar handling on the server side, we still need this logic\n\t\t\t\t// on the client side due to a possible race condition between two async calls:\n\t\t\t\t// a) removing \"dialog\" listener subscription (client->server)\n\t\t\t\t// b) actual \"dialog\" event (server->client)\n\t\t\t\tif dialog.Type() == \"beforeunload\" {\n\t\t\t\t\t_ = dialog.Accept()\n\t\t\t\t} else {\n\t\t\t\t\t_ = dialog.Dismiss()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t})\n\tbt.channel.On(\n\t\t\"pageError\", func(ev map[string]interface{}) {\n\t\t\tpwErr := &Error{}\n\t\t\tremapMapToStruct(ev[\"error\"].(map[string]interface{})[\"error\"], pwErr)\n\t\t\terr := parseError(*pwErr)\n\t\t\tpage := fromNullableChannel(ev[\"page\"])\n\t\t\tif page != nil {\n\t\t\t\tbt.Emit(\"weberror\", newWebError(page.(*pageImpl), err))\n\t\t\t\tpage.(*pageImpl).Emit(\"pageerror\", err)\n\t\t\t} else {\n\t\t\t\tbt.Emit(\"weberror\", newWebError(nil, err))\n\t\t\t}\n\t\t},\n\t)\n\tbt.channel.On(\"request\", func(ev map[string]interface{}) {\n\t\trequest := fromChannel(ev[\"request\"]).(*requestImpl)\n\t\tpage := fromNullableChannel(ev[\"page\"])\n\t\tbt.Emit(\"request\", request)\n\t\tif page != nil {\n\t\t\tpage.(*pageImpl).Emit(\"request\", request)\n\t\t}\n\t})\n\tbt.channel.On(\"requestFailed\", func(ev map[string]interface{}) {\n\t\trequest := fromChannel(ev[\"request\"]).(*requestImpl)\n\t\tfailureText := ev[\"failureText\"]\n\t\tif failureText != nil {\n\t\t\trequest.failureText = failureText.(string)\n\t\t}\n\t\tpage := fromNullableChannel(ev[\"page\"])\n\t\trequest.setResponseEndTiming(ev[\"responseEndTiming\"].(float64))\n\t\tbt.Emit(\"requestfailed\", request)\n\t\tif page != nil {\n\t\t\tpage.(*pageImpl).Emit(\"requestfailed\", request)\n\t\t}\n\t})\n\n\tbt.channel.On(\"requestFinished\", func(ev map[string]interface{}) {\n\t\trequest := fromChannel(ev[\"request\"]).(*requestImpl)\n\t\tresponse := fromNullableChannel(ev[\"response\"])\n\t\tpage := fromNullableChannel(ev[\"page\"])\n\t\trequest.setResponseEndTiming(ev[\"responseEndTiming\"].(float64))\n\t\tbt.Emit(\"requestfinished\", request)\n\t\tif page != nil {\n\t\t\tpage.(*pageImpl).Emit(\"requestfinished\", request)\n\t\t}\n\t\tif response != nil {\n\t\t\tclose(response.(*responseImpl).finished)\n\t\t}\n\t})\n\tbt.channel.On(\"response\", func(ev map[string]interface{}) {\n\t\tresponse := fromChannel(ev[\"response\"]).(*responseImpl)\n\t\tpage := fromNullableChannel(ev[\"page\"])\n\t\tbt.Emit(\"response\", response)\n\t\tif page != nil {\n\t\t\tpage.(*pageImpl).Emit(\"response\", response)\n\t\t}\n\t})\n\tbt.Once(\"close\", func() {\n\t\tbt.closed <- struct{}{}\n\t})\n\tbt.setEventSubscriptionMapping(map[string]string{\n\t\t\"console\":         \"console\",\n\t\t\"dialog\":          \"dialog\",\n\t\t\"request\":         \"request\",\n\t\t\"response\":        \"response\",\n\t\t\"requestfinished\": \"requestFinished\",\n\t\t\"responsefailed\":  \"responseFailed\",\n\t})\n\treturn bt\n}\n"
        },
        {
          "name": "browser_type.go",
          "type": "blob",
          "size": 5.1396484375,
          "content": "package playwright\n\nimport (\n\t\"fmt\"\n)\n\ntype browserTypeImpl struct {\n\tchannelOwner\n\tplaywright *Playwright\n}\n\nfunc (b *browserTypeImpl) Name() string {\n\treturn b.initializer[\"name\"].(string)\n}\n\nfunc (b *browserTypeImpl) ExecutablePath() string {\n\treturn b.initializer[\"executablePath\"].(string)\n}\n\nfunc (b *browserTypeImpl) Launch(options ...BrowserTypeLaunchOptions) (Browser, error) {\n\toverrides := map[string]interface{}{}\n\tif len(options) == 1 && options[0].Env != nil {\n\t\toverrides[\"env\"] = serializeMapToNameAndValue(options[0].Env)\n\t\toptions[0].Env = nil\n\t}\n\tchannel, err := b.channel.Send(\"launch\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbrowser := fromChannel(channel).(*browserImpl)\n\tb.didLaunchBrowser(browser)\n\treturn browser, nil\n}\n\nfunc (b *browserTypeImpl) LaunchPersistentContext(userDataDir string, options ...BrowserTypeLaunchPersistentContextOptions) (BrowserContext, error) {\n\toverrides := map[string]interface{}{\n\t\t\"userDataDir\": userDataDir,\n\t}\n\toption := &BrowserNewContextOptions{}\n\tvar tracesDir *string = nil\n\tif len(options) == 1 {\n\t\ttracesDir = options[0].TracesDir\n\t\terr := assignStructFields(option, options[0], true)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"can not convert options: %w\", err)\n\t\t}\n\t\tif options[0].AcceptDownloads != nil {\n\t\t\tif *options[0].AcceptDownloads {\n\t\t\t\toverrides[\"acceptDownloads\"] = \"accept\"\n\t\t\t} else {\n\t\t\t\toverrides[\"acceptDownloads\"] = \"deny\"\n\t\t\t}\n\t\t\toptions[0].AcceptDownloads = nil\n\t\t}\n\t\tif options[0].ClientCertificates != nil {\n\t\t\tcerts, err := transformClientCertificate(options[0].ClientCertificates)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toverrides[\"clientCertificates\"] = certs\n\t\t\toptions[0].ClientCertificates = nil\n\t\t}\n\t\tif options[0].ExtraHttpHeaders != nil {\n\t\t\toverrides[\"extraHTTPHeaders\"] = serializeMapToNameAndValue(options[0].ExtraHttpHeaders)\n\t\t\toptions[0].ExtraHttpHeaders = nil\n\t\t}\n\t\tif options[0].Env != nil {\n\t\t\toverrides[\"env\"] = serializeMapToNameAndValue(options[0].Env)\n\t\t\toptions[0].Env = nil\n\t\t}\n\t\tif options[0].NoViewport != nil && *options[0].NoViewport {\n\t\t\toverrides[\"noDefaultViewport\"] = true\n\t\t\toptions[0].NoViewport = nil\n\t\t}\n\t\tif options[0].RecordHarPath != nil {\n\t\t\toverrides[\"recordHar\"] = prepareRecordHarOptions(recordHarInputOptions{\n\t\t\t\tPath:        *options[0].RecordHarPath,\n\t\t\t\tURL:         options[0].RecordHarURLFilter,\n\t\t\t\tMode:        options[0].RecordHarMode,\n\t\t\t\tContent:     options[0].RecordHarContent,\n\t\t\t\tOmitContent: options[0].RecordHarOmitContent,\n\t\t\t})\n\t\t\toptions[0].RecordHarPath = nil\n\t\t\toptions[0].RecordHarURLFilter = nil\n\t\t\toptions[0].RecordHarMode = nil\n\t\t\toptions[0].RecordHarContent = nil\n\t\t\toptions[0].RecordHarOmitContent = nil\n\t\t}\n\t}\n\tchannel, err := b.channel.Send(\"launchPersistentContext\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcontext := fromChannel(channel).(*browserContextImpl)\n\tb.didCreateContext(context, option, tracesDir)\n\treturn context, nil\n}\n\nfunc (b *browserTypeImpl) Connect(wsEndpoint string, options ...BrowserTypeConnectOptions) (Browser, error) {\n\toverrides := map[string]interface{}{\n\t\t\"wsEndpoint\": wsEndpoint,\n\t}\n\tlocalUtils := b.connection.LocalUtils()\n\tpipe, err := localUtils.channel.SendReturnAsDict(\"connect\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tjsonPipe := fromChannel(pipe[\"pipe\"]).(*jsonPipe)\n\tconnection := newConnection(jsonPipe, localUtils)\n\n\tplaywright, err := connection.Start()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tplaywright.setSelectors(b.playwright.Selectors)\n\tbrowser := fromChannel(playwright.initializer[\"preLaunchedBrowser\"]).(*browserImpl)\n\tbrowser.shouldCloseConnectionOnClose = true\n\tpipeClosed := func() {\n\t\tfor _, context := range browser.Contexts() {\n\t\t\tpages := context.Pages()\n\t\t\tfor _, page := range pages {\n\t\t\t\tpage.(*pageImpl).onClose()\n\t\t\t}\n\t\t\tcontext.(*browserContextImpl).onClose()\n\t\t}\n\t\tbrowser.onClose()\n\t\tconnection.cleanup()\n\t}\n\tjsonPipe.On(\"closed\", pipeClosed)\n\n\tb.didLaunchBrowser(browser)\n\treturn browser, nil\n}\n\nfunc (b *browserTypeImpl) ConnectOverCDP(endpointURL string, options ...BrowserTypeConnectOverCDPOptions) (Browser, error) {\n\toverrides := map[string]interface{}{\n\t\t\"endpointURL\": endpointURL,\n\t}\n\tif len(options) == 1 {\n\t\tif options[0].Headers != nil {\n\t\t\toverrides[\"headers\"] = serializeMapToNameAndValue(options[0].Headers)\n\t\t\toptions[0].Headers = nil\n\t\t}\n\t}\n\tresponse, err := b.channel.SendReturnAsDict(\"connectOverCDP\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbrowser := fromChannel(response[\"browser\"]).(*browserImpl)\n\tb.didLaunchBrowser(browser)\n\tif defaultContext, ok := response[\"defaultContext\"]; ok {\n\t\tcontext := fromChannel(defaultContext).(*browserContextImpl)\n\t\tb.didCreateContext(context, nil, nil)\n\t}\n\treturn browser, nil\n}\n\nfunc (b *browserTypeImpl) didCreateContext(context *browserContextImpl, contextOptions *BrowserNewContextOptions, tracesDir *string) {\n\tcontext.setOptions(contextOptions, tracesDir)\n}\n\nfunc (b *browserTypeImpl) didLaunchBrowser(browser *browserImpl) {\n\tbrowser.browserType = b\n}\n\nfunc newBrowserType(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *browserTypeImpl {\n\tbt := &browserTypeImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\treturn bt\n}\n"
        },
        {
          "name": "cdp_session.go",
          "type": "blob",
          "size": 0.849609375,
          "content": "package playwright\n\ntype cdpSessionImpl struct {\n\tchannelOwner\n}\n\nfunc (c *cdpSessionImpl) Detach() error {\n\t_, err := c.channel.Send(\"detach\")\n\treturn err\n}\n\nfunc (c *cdpSessionImpl) Send(method string, params map[string]interface{}) (interface{}, error) {\n\tresult, err := c.channel.Send(\"send\", map[string]interface{}{\n\t\t\"method\": method,\n\t\t\"params\": params,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result, err\n}\n\nfunc (c *cdpSessionImpl) onEvent(params map[string]interface{}) {\n\tc.Emit(params[\"method\"].(string), params[\"params\"])\n}\n\nfunc newCDPSession(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *cdpSessionImpl {\n\tbt := &cdpSessionImpl{}\n\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\n\tbt.channel.On(\"event\", func(params map[string]interface{}) {\n\t\tbt.onEvent(params)\n\t})\n\n\treturn bt\n}\n"
        },
        {
          "name": "channel.go",
          "type": "blob",
          "size": 2.5302734375,
          "content": "package playwright\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype channel struct {\n\teventEmitter\n\tguid       string\n\tconnection *connection\n\towner      *channelOwner // to avoid type conversion\n\tobject     interface{}   // retain type info (for fromChannel needed)\n}\n\nfunc (c *channel) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(map[string]string{\n\t\t\"guid\": c.guid,\n\t})\n}\n\n// for catch errors of route handlers etc.\nfunc (c *channel) CreateTask(fn func()) {\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif e := recover(); e != nil {\n\t\t\t\terr, ok := e.(error)\n\t\t\t\tif ok {\n\t\t\t\t\tc.connection.err.Set(err)\n\t\t\t\t} else {\n\t\t\t\t\tc.connection.err.Set(fmt.Errorf(\"%v\", e))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tfn()\n\t}()\n}\n\nfunc (c *channel) Send(method string, options ...interface{}) (interface{}, error) {\n\treturn c.connection.WrapAPICall(func() (interface{}, error) {\n\t\treturn c.innerSend(method, options...).GetResultValue()\n\t}, c.owner.isInternalType)\n}\n\nfunc (c *channel) SendReturnAsDict(method string, options ...interface{}) (map[string]interface{}, error) {\n\tret, err := c.connection.WrapAPICall(func() (interface{}, error) {\n\t\treturn c.innerSend(method, options...).GetResult()\n\t}, c.owner.isInternalType)\n\treturn ret.(map[string]interface{}), err\n}\n\nfunc (c *channel) innerSend(method string, options ...interface{}) *protocolCallback {\n\tif err := c.connection.err.Get(); err != nil {\n\t\tc.connection.err.Set(nil)\n\t\tpc := newProtocolCallback(false, c.connection.abort)\n\t\tpc.SetError(err)\n\t\treturn pc\n\t}\n\tparams := transformOptions(options...)\n\treturn c.connection.sendMessageToServer(c.owner, method, params, false)\n}\n\n// SendNoReply ignores return value and errors\n// almost equivalent to `send(...).catch(() => {})`\nfunc (c *channel) SendNoReply(method string, options ...interface{}) {\n\tc.innerSendNoReply(method, c.owner.isInternalType, options...)\n}\n\nfunc (c *channel) SendNoReplyInternal(method string, options ...interface{}) {\n\tc.innerSendNoReply(method, true, options...)\n}\n\nfunc (c *channel) innerSendNoReply(method string, isInternal bool, options ...interface{}) {\n\tparams := transformOptions(options...)\n\t_, err := c.connection.WrapAPICall(func() (interface{}, error) {\n\t\treturn c.connection.sendMessageToServer(c.owner, method, params, true).GetResult()\n\t}, isInternal)\n\tif err != nil {\n\t\t// ignore error actively, log only for debug\n\t\tlogger.Error(\"SendNoReply failed\", \"error\", err)\n\t}\n}\n\nfunc newChannel(owner *channelOwner, object interface{}) *channel {\n\tchannel := &channel{\n\t\tconnection: owner.connection,\n\t\tguid:       owner.guid,\n\t\towner:      owner,\n\t\tobject:     object,\n\t}\n\treturn channel\n}\n"
        },
        {
          "name": "channel_owner.go",
          "type": "blob",
          "size": 3.119140625,
          "content": "package playwright\n\nimport (\n\t\"sync\"\n)\n\ntype channelOwner struct {\n\tsync.RWMutex\n\teventEmitter\n\tobjectType                 string\n\tguid                       string\n\tchannel                    *channel\n\tobjects                    map[string]*channelOwner\n\teventToSubscriptionMapping map[string]string\n\tconnection                 *connection\n\tinitializer                map[string]interface{}\n\tparent                     *channelOwner\n\twasCollected               bool\n\tisInternalType             bool\n}\n\nfunc (c *channelOwner) dispose(reason ...string) {\n\t// Clean up from parent and connection.\n\tif c.parent != nil {\n\t\tdelete(c.parent.objects, c.guid)\n\t}\n\tc.connection.objects.Delete(c.guid)\n\tif len(reason) > 0 {\n\t\tc.wasCollected = reason[0] == \"gc\"\n\t}\n\n\t// Dispose all children.\n\tfor _, object := range c.objects {\n\t\tobject.dispose(reason...)\n\t}\n\tc.objects = make(map[string]*channelOwner)\n}\n\nfunc (c *channelOwner) adopt(child *channelOwner) {\n\tdelete(child.parent.objects, child.guid)\n\tc.objects[child.guid] = child\n\tchild.parent = c\n}\n\nfunc (c *channelOwner) setEventSubscriptionMapping(mapping map[string]string) {\n\tc.eventToSubscriptionMapping = mapping\n}\n\nfunc (c *channelOwner) updateSubscription(event string, enabled bool) {\n\tprotocolEvent, ok := c.eventToSubscriptionMapping[event]\n\tif ok {\n\t\tc.channel.SendNoReplyInternal(\"updateSubscription\", map[string]interface{}{\n\t\t\t\"event\":   protocolEvent,\n\t\t\t\"enabled\": enabled,\n\t\t})\n\t}\n}\n\nfunc (c *channelOwner) Once(name string, handler interface{}) {\n\tc.addEvent(name, handler, true)\n}\n\nfunc (c *channelOwner) On(name string, handler interface{}) {\n\tc.addEvent(name, handler, false)\n}\n\nfunc (c *channelOwner) addEvent(name string, handler interface{}, once bool) {\n\tif c.ListenerCount(name) == 0 {\n\t\tc.updateSubscription(name, true)\n\t}\n\tc.eventEmitter.addEvent(name, handler, once)\n}\n\nfunc (c *channelOwner) RemoveListener(name string, handler interface{}) {\n\tc.eventEmitter.RemoveListener(name, handler)\n\tif c.ListenerCount(name) == 0 {\n\t\tc.updateSubscription(name, false)\n\t}\n}\n\nfunc (c *channelOwner) createChannelOwner(self interface{}, parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) {\n\tc.objectType = objectType\n\tc.guid = guid\n\tc.wasCollected = false\n\tc.parent = parent\n\tc.objects = make(map[string]*channelOwner)\n\tc.initializer = initializer\n\tif c.parent != nil {\n\t\tc.connection = parent.connection\n\t\tc.parent.objects[guid] = c\n\t}\n\tif c.connection != nil {\n\t\tc.connection.objects.Store(guid, c)\n\t}\n\tc.channel = newChannel(c, self)\n\tc.eventToSubscriptionMapping = map[string]string{}\n}\n\nfunc (c *channelOwner) markAsInternalType() {\n\tc.isInternalType = true\n}\n\ntype rootChannelOwner struct {\n\tchannelOwner\n}\n\nfunc (r *rootChannelOwner) initialize() (*Playwright, error) {\n\tret, err := r.channel.SendReturnAsDict(\"initialize\", map[string]interface{}{\n\t\t\"sdkLanguage\": \"javascript\",\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(ret[\"playwright\"]).(*Playwright), nil\n}\n\nfunc newRootChannelOwner(connection *connection) *rootChannelOwner {\n\tc := &rootChannelOwner{}\n\tc.connection = connection\n\tc.createChannelOwner(c, nil, \"Root\", \"\", make(map[string]interface{}))\n\treturn c\n}\n"
        },
        {
          "name": "clock.go",
          "type": "blob",
          "size": 2.26171875,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\ntype clockImpl struct {\n\tbrowserCtx *browserContextImpl\n}\n\nfunc newClock(bCtx *browserContextImpl) Clock {\n\treturn &clockImpl{\n\t\tbrowserCtx: bCtx,\n\t}\n}\n\nfunc (c *clockImpl) FastForward(ticks interface{}) error {\n\tparams, err := parseTicks(ticks)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.browserCtx.channel.Send(\"clockFastForward\", params)\n\treturn err\n}\n\nfunc (c *clockImpl) Install(options ...ClockInstallOptions) (err error) {\n\tparams := map[string]any{}\n\tif len(options) == 1 {\n\t\tif options[0].Time != nil {\n\t\t\tparams, err = parseTime(options[0].Time)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t_, err = c.browserCtx.channel.Send(\"clockInstall\", params)\n\n\treturn err\n}\n\nfunc (c *clockImpl) PauseAt(time interface{}) error {\n\tparams, err := parseTime(time)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.browserCtx.channel.Send(\"clockPauseAt\", params)\n\treturn err\n}\n\nfunc (c *clockImpl) Resume() error {\n\t_, err := c.browserCtx.channel.Send(\"clockResume\")\n\treturn err\n}\n\nfunc (c *clockImpl) RunFor(ticks interface{}) error {\n\tparams, err := parseTicks(ticks)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.browserCtx.channel.Send(\"clockRunFor\", params)\n\treturn err\n}\n\nfunc (c *clockImpl) SetFixedTime(time interface{}) error {\n\tparams, err := parseTime(time)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.browserCtx.channel.Send(\"clockSetFixedTime\", params)\n\treturn err\n}\n\nfunc (c *clockImpl) SetSystemTime(time interface{}) error {\n\tparams, err := parseTime(time)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.browserCtx.channel.Send(\"clockSetSystemTime\", params)\n\treturn err\n}\n\nfunc parseTime(t interface{}) (map[string]any, error) {\n\tswitch v := t.(type) {\n\tcase int, int64:\n\t\treturn map[string]any{\"timeNumber\": v}, nil\n\tcase string:\n\t\treturn map[string]any{\"timeString\": v}, nil\n\tcase time.Time:\n\t\treturn map[string]any{\"timeNumber\": v.UnixMilli()}, nil\n\tdefault:\n\t\treturn nil, errors.New(\"time should be one of: int, int64, string, time.Time\")\n\t}\n}\n\nfunc parseTicks(ticks interface{}) (map[string]any, error) {\n\tswitch v := ticks.(type) {\n\tcase int, int64:\n\t\treturn map[string]any{\"ticksNumber\": v}, nil\n\tcase string:\n\t\treturn map[string]any{\"ticksString\": v}, nil\n\tdefault:\n\t\treturn nil, errors.New(\"ticks should be one of: int, int64, string\")\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "connection.go",
          "type": "blob",
          "size": 8.97265625,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/go-stack/stack\"\n\t\"github.com/playwright-community/playwright-go/internal/safe\"\n)\n\nvar (\n\tpkgSourcePathPattern = regexp.MustCompile(`.+[\\\\/]playwright-go[\\\\/][^\\\\/]+\\.go`)\n\tapiNameTransform     = regexp.MustCompile(`(?U)\\(\\*(.+)(Impl)?\\)`)\n)\n\ntype connection struct {\n\ttransport    transport\n\tapiZone      sync.Map\n\tobjects      *safe.SyncMap[string, *channelOwner]\n\tlastID       atomic.Uint32\n\trootObject   *rootChannelOwner\n\tcallbacks    *safe.SyncMap[uint32, *protocolCallback]\n\tafterClose   func()\n\tonClose      func() error\n\tisRemote     bool\n\tlocalUtils   *localUtilsImpl\n\ttracingCount atomic.Int32\n\tabort        chan struct{}\n\tabortOnce    sync.Once\n\terr          *safeValue[error] // for event listener error\n\tclosedError  *safeValue[error]\n}\n\nfunc (c *connection) Start() (*Playwright, error) {\n\tgo func() {\n\t\tfor {\n\t\t\tmsg, err := c.transport.Poll()\n\t\t\tif err != nil {\n\t\t\t\t_ = c.transport.Close()\n\t\t\t\tc.cleanup(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.Dispatch(msg)\n\t\t}\n\t}()\n\n\tc.onClose = func() error {\n\t\tif err := c.transport.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn c.rootObject.initialize()\n}\n\nfunc (c *connection) Stop() error {\n\tif err := c.onClose(); err != nil {\n\t\treturn err\n\t}\n\tc.cleanup()\n\treturn nil\n}\n\nfunc (c *connection) cleanup(cause ...error) {\n\tif len(cause) > 0 {\n\t\tc.closedError.Set(fmt.Errorf(\"%w: %w\", ErrTargetClosed, cause[0]))\n\t} else {\n\t\tc.closedError.Set(ErrTargetClosed)\n\t}\n\tif c.afterClose != nil {\n\t\tc.afterClose()\n\t}\n\tc.abortOnce.Do(func() {\n\t\tselect {\n\t\tcase <-c.abort:\n\t\tdefault:\n\t\t\tclose(c.abort)\n\t\t}\n\t})\n}\n\nfunc (c *connection) Dispatch(msg *message) {\n\tif c.closedError.Get() != nil {\n\t\treturn\n\t}\n\tmethod := msg.Method\n\tif msg.ID != 0 {\n\t\tcb, _ := c.callbacks.LoadAndDelete(uint32(msg.ID))\n\t\tif cb.noReply {\n\t\t\treturn\n\t\t}\n\t\tif msg.Error != nil {\n\t\t\tcb.SetError(parseError(msg.Error.Error))\n\t\t} else {\n\t\t\tcb.SetResult(c.replaceGuidsWithChannels(msg.Result).(map[string]interface{}))\n\t\t}\n\t\treturn\n\t}\n\tobject, _ := c.objects.Load(msg.GUID)\n\tif method == \"__create__\" {\n\t\tc.createRemoteObject(\n\t\t\tobject, msg.Params[\"type\"].(string), msg.Params[\"guid\"].(string), msg.Params[\"initializer\"],\n\t\t)\n\t\treturn\n\t}\n\tif object == nil {\n\t\treturn\n\t}\n\tif method == \"__adopt__\" {\n\t\tchild, ok := c.objects.Load(msg.Params[\"guid\"].(string))\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tobject.adopt(child)\n\t\treturn\n\t}\n\tif method == \"__dispose__\" {\n\t\treason, ok := msg.Params[\"reason\"]\n\t\tif ok {\n\t\t\tobject.dispose(reason.(string))\n\t\t} else {\n\t\t\tobject.dispose()\n\t\t}\n\t\treturn\n\t}\n\tif object.objectType == \"JsonPipe\" {\n\t\tobject.channel.Emit(method, msg.Params)\n\t} else {\n\t\tobject.channel.Emit(method, c.replaceGuidsWithChannels(msg.Params))\n\t}\n}\n\nfunc (c *connection) LocalUtils() *localUtilsImpl {\n\treturn c.localUtils\n}\n\nfunc (c *connection) createRemoteObject(parent *channelOwner, objectType string, guid string, initializer interface{}) interface{} {\n\tinitializer = c.replaceGuidsWithChannels(initializer)\n\tresult := createObjectFactory(parent, objectType, guid, initializer.(map[string]interface{}))\n\treturn result\n}\n\nfunc (c *connection) WrapAPICall(cb func() (interface{}, error), isInternal bool) (interface{}, error) {\n\tif _, ok := c.apiZone.Load(\"apiZone\"); ok {\n\t\treturn cb()\n\t}\n\tc.apiZone.Store(\"apiZone\", serializeCallStack(isInternal))\n\treturn cb()\n}\n\nfunc (c *connection) replaceGuidsWithChannels(payload interface{}) interface{} {\n\tif payload == nil {\n\t\treturn nil\n\t}\n\tv := reflect.ValueOf(payload)\n\tif v.Kind() == reflect.Slice {\n\t\tlistV := payload.([]interface{})\n\t\tfor i := 0; i < len(listV); i++ {\n\t\t\tlistV[i] = c.replaceGuidsWithChannels(listV[i])\n\t\t}\n\t\treturn listV\n\t}\n\tif v.Kind() == reflect.Map {\n\t\tmapV := payload.(map[string]interface{})\n\t\tif guid, hasGUID := mapV[\"guid\"]; hasGUID {\n\t\t\tif channelOwner, ok := c.objects.Load(guid.(string)); ok {\n\t\t\t\treturn channelOwner.channel\n\t\t\t}\n\t\t}\n\t\tfor key := range mapV {\n\t\t\tmapV[key] = c.replaceGuidsWithChannels(mapV[key])\n\t\t}\n\t\treturn mapV\n\t}\n\treturn payload\n}\n\nfunc (c *connection) sendMessageToServer(object *channelOwner, method string, params interface{}, noReply bool) (cb *protocolCallback) {\n\tcb = newProtocolCallback(noReply, c.abort)\n\n\tif err := c.closedError.Get(); err != nil {\n\t\tcb.SetError(err)\n\t\treturn\n\t}\n\tif object.wasCollected {\n\t\tcb.SetError(errors.New(\"The object has been collected to prevent unbounded heap growth.\"))\n\t\treturn\n\t}\n\n\tid := c.lastID.Add(1)\n\tc.callbacks.Store(id, cb)\n\tvar (\n\t\tmetadata = make(map[string]interface{}, 0)\n\t\tstack    = make([]map[string]interface{}, 0)\n\t)\n\tapiZone, ok := c.apiZone.LoadAndDelete(\"apiZone\")\n\tif ok {\n\t\tfor k, v := range apiZone.(parsedStackTrace).metadata {\n\t\t\tmetadata[k] = v\n\t\t}\n\t\tstack = append(stack, apiZone.(parsedStackTrace).frames...)\n\t}\n\tmetadata[\"wallTime\"] = time.Now().UnixMilli()\n\tmessage := map[string]interface{}{\n\t\t\"id\":       id,\n\t\t\"guid\":     object.guid,\n\t\t\"method\":   method,\n\t\t\"params\":   params, // channel.MarshalJSON will replace channel with guid\n\t\t\"metadata\": metadata,\n\t}\n\tif c.tracingCount.Load() > 0 && len(stack) > 0 && object.guid != \"localUtils\" {\n\t\tc.LocalUtils().AddStackToTracingNoReply(id, stack)\n\t}\n\n\tif err := c.transport.Send(message); err != nil {\n\t\tcb.SetError(fmt.Errorf(\"could not send message: %w\", err))\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (c *connection) setInTracing(isTracing bool) {\n\tif isTracing {\n\t\tc.tracingCount.Add(1)\n\t} else {\n\t\tc.tracingCount.Add(-1)\n\t}\n}\n\ntype parsedStackTrace struct {\n\tframes   []map[string]interface{}\n\tmetadata map[string]interface{}\n}\n\nfunc serializeCallStack(isInternal bool) parsedStackTrace {\n\tst := stack.Trace().TrimRuntime()\n\tif len(st) == 0 { // https://github.com/go-stack/stack/issues/27\n\t\tst = stack.Trace()\n\t}\n\n\tlastInternalIndex := 0\n\tfor i, s := range st {\n\t\tif pkgSourcePathPattern.MatchString(s.Frame().File) {\n\t\t\tlastInternalIndex = i\n\t\t}\n\t}\n\tapiName := \"\"\n\tif !isInternal {\n\t\tapiName = fmt.Sprintf(\"%n\", st[lastInternalIndex])\n\t}\n\tst = st.TrimBelow(st[lastInternalIndex])\n\n\tcallStack := make([]map[string]interface{}, 0)\n\tfor i, s := range st {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tcallStack = append(callStack, map[string]interface{}{\n\t\t\t\"file\":     s.Frame().File,\n\t\t\t\"line\":     s.Frame().Line,\n\t\t\t\"column\":   0,\n\t\t\t\"function\": s.Frame().Function,\n\t\t})\n\t}\n\tmetadata := make(map[string]interface{})\n\tif len(st) > 1 {\n\t\tmetadata[\"location\"] = serializeCallLocation(st[1])\n\t}\n\tapiName = apiNameTransform.ReplaceAllString(apiName, \"$1\")\n\tif len(apiName) > 1 {\n\t\tapiName = strings.ToUpper(apiName[:1]) + apiName[1:]\n\t}\n\tmetadata[\"apiName\"] = apiName\n\tmetadata[\"isInternal\"] = isInternal\n\treturn parsedStackTrace{\n\t\tmetadata: metadata,\n\t\tframes:   callStack,\n\t}\n}\n\nfunc serializeCallLocation(caller stack.Call) map[string]interface{} {\n\tline, _ := strconv.Atoi(fmt.Sprintf(\"%d\", caller))\n\treturn map[string]interface{}{\n\t\t\"file\": fmt.Sprintf(\"%s\", caller),\n\t\t\"line\": line,\n\t}\n}\n\nfunc newConnection(transport transport, localUtils ...*localUtilsImpl) *connection {\n\tconnection := &connection{\n\t\tabort:       make(chan struct{}, 1),\n\t\tcallbacks:   safe.NewSyncMap[uint32, *protocolCallback](),\n\t\tobjects:     safe.NewSyncMap[string, *channelOwner](),\n\t\ttransport:   transport,\n\t\tisRemote:    false,\n\t\terr:         &safeValue[error]{},\n\t\tclosedError: &safeValue[error]{},\n\t}\n\tif len(localUtils) > 0 {\n\t\tconnection.localUtils = localUtils[0]\n\t\tconnection.isRemote = true\n\t}\n\tconnection.rootObject = newRootChannelOwner(connection)\n\treturn connection\n}\n\nfunc fromChannel(v interface{}) interface{} {\n\treturn v.(*channel).object\n}\n\nfunc fromNullableChannel(v interface{}) interface{} {\n\tif v == nil {\n\t\treturn nil\n\t}\n\treturn fromChannel(v)\n}\n\ntype protocolCallback struct {\n\tdone    chan struct{}\n\tnoReply bool\n\tabort   <-chan struct{}\n\tonce    sync.Once\n\tvalue   map[string]interface{}\n\terr     error\n}\n\nfunc (pc *protocolCallback) setResultOnce(result map[string]interface{}, err error) {\n\tpc.once.Do(func() {\n\t\tpc.value = result\n\t\tpc.err = err\n\t\tclose(pc.done)\n\t})\n}\n\nfunc (pc *protocolCallback) waitResult() {\n\tif pc.noReply {\n\t\treturn\n\t}\n\tselect {\n\tcase <-pc.done: // wait for result\n\t\treturn\n\tcase <-pc.abort:\n\t\tselect {\n\t\tcase <-pc.done:\n\t\t\treturn\n\t\tdefault:\n\t\t\tpc.err = errors.New(\"Connection closed\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (pc *protocolCallback) SetError(err error) {\n\tpc.setResultOnce(nil, err)\n}\n\nfunc (pc *protocolCallback) SetResult(result map[string]interface{}) {\n\tpc.setResultOnce(result, nil)\n}\n\nfunc (pc *protocolCallback) GetResult() (map[string]interface{}, error) {\n\tpc.waitResult()\n\treturn pc.value, pc.err\n}\n\n// GetResultValue returns value if the map has only one element\nfunc (pc *protocolCallback) GetResultValue() (interface{}, error) {\n\tpc.waitResult()\n\tif len(pc.value) == 0 { // empty map treated as nil\n\t\treturn nil, pc.err\n\t}\n\tif len(pc.value) == 1 {\n\t\tfor key := range pc.value {\n\t\t\treturn pc.value[key], pc.err\n\t\t}\n\t}\n\n\treturn pc.value, pc.err\n}\n\nfunc newProtocolCallback(noReply bool, abort <-chan struct{}) *protocolCallback {\n\tif noReply {\n\t\treturn &protocolCallback{\n\t\t\tnoReply: true,\n\t\t\tabort:   abort,\n\t\t}\n\t}\n\treturn &protocolCallback{\n\t\tdone:  make(chan struct{}, 1),\n\t\tabort: abort,\n\t}\n}\n"
        },
        {
          "name": "console_message.go",
          "type": "blob",
          "size": 0.9814453125,
          "content": "package playwright\n\ntype consoleMessageImpl struct {\n\tevent map[string]interface{}\n\tpage  Page\n}\n\nfunc (c *consoleMessageImpl) Type() string {\n\treturn c.event[\"type\"].(string)\n}\n\nfunc (c *consoleMessageImpl) Text() string {\n\treturn c.event[\"text\"].(string)\n}\n\nfunc (c *consoleMessageImpl) String() string {\n\treturn c.Text()\n}\n\nfunc (c *consoleMessageImpl) Args() []JSHandle {\n\targs := c.event[\"args\"].([]interface{})\n\tout := []JSHandle{}\n\tfor idx := range args {\n\t\tout = append(out, fromChannel(args[idx]).(*jsHandleImpl))\n\t}\n\treturn out\n}\n\nfunc (c *consoleMessageImpl) Location() *ConsoleMessageLocation {\n\tlocation := &ConsoleMessageLocation{}\n\tremapMapToStruct(c.event[\"location\"], location)\n\treturn location\n}\n\nfunc (c *consoleMessageImpl) Page() Page {\n\treturn c.page\n}\n\nfunc newConsoleMessage(event map[string]interface{}) *consoleMessageImpl {\n\tbt := &consoleMessageImpl{}\n\tbt.event = event\n\tpage := fromNullableChannel(event[\"page\"])\n\tif page != nil {\n\t\tbt.page = page.(*pageImpl)\n\t}\n\treturn bt\n}\n"
        },
        {
          "name": "dialog.go",
          "type": "blob",
          "size": 1.0341796875,
          "content": "package playwright\n\ntype dialogImpl struct {\n\tchannelOwner\n\tpage Page\n}\n\nfunc (d *dialogImpl) Type() string {\n\treturn d.initializer[\"type\"].(string)\n}\n\nfunc (d *dialogImpl) Message() string {\n\treturn d.initializer[\"message\"].(string)\n}\n\nfunc (d *dialogImpl) DefaultValue() string {\n\treturn d.initializer[\"defaultValue\"].(string)\n}\n\nfunc (d *dialogImpl) Accept(promptTextInput ...string) error {\n\tvar promptText *string\n\tif len(promptTextInput) == 1 {\n\t\tpromptText = &promptTextInput[0]\n\t}\n\t_, err := d.channel.Send(\"accept\", map[string]interface{}{\n\t\t\"promptText\": promptText,\n\t})\n\treturn err\n}\n\nfunc (d *dialogImpl) Dismiss() error {\n\t_, err := d.channel.Send(\"dismiss\")\n\treturn err\n}\n\nfunc (d *dialogImpl) Page() Page {\n\treturn d.page\n}\n\nfunc newDialog(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *dialogImpl {\n\tbt := &dialogImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tpage := fromNullableChannel(initializer[\"page\"])\n\tif page != nil {\n\t\tbt.page = page.(*pageImpl)\n\t}\n\treturn bt\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "download.go",
          "type": "blob",
          "size": 1.1064453125,
          "content": "package playwright\n\ntype downloadImpl struct {\n\tpage              *pageImpl\n\turl               string\n\tsuggestedFilename string\n\tartifact          *artifactImpl\n}\n\nfunc (d *downloadImpl) String() string {\n\treturn d.SuggestedFilename()\n}\n\nfunc (d *downloadImpl) Page() Page {\n\treturn d.page\n}\n\nfunc (d *downloadImpl) URL() string {\n\treturn d.url\n}\n\nfunc (d *downloadImpl) SuggestedFilename() string {\n\treturn d.suggestedFilename\n}\n\nfunc (d *downloadImpl) Delete() error {\n\terr := d.artifact.Delete()\n\treturn err\n}\n\nfunc (d *downloadImpl) Failure() error {\n\treturn d.artifact.Failure()\n}\n\nfunc (d *downloadImpl) Path() (string, error) {\n\tpath, err := d.artifact.PathAfterFinished()\n\treturn path, err\n}\n\nfunc (d *downloadImpl) SaveAs(path string) error {\n\terr := d.artifact.SaveAs(path)\n\treturn err\n}\n\nfunc (d *downloadImpl) Cancel() error {\n\treturn d.artifact.Cancel()\n}\n\nfunc newDownload(page *pageImpl, url string, suggestedFilename string, artifact *artifactImpl) *downloadImpl {\n\treturn &downloadImpl{\n\t\tpage:              page,\n\t\turl:               url,\n\t\tsuggestedFilename: suggestedFilename,\n\t\tartifact:          artifact,\n\t}\n}\n"
        },
        {
          "name": "element_handle.go",
          "type": "blob",
          "size": 9.876953125,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype elementHandleImpl struct {\n\tjsHandleImpl\n}\n\nfunc (e *elementHandleImpl) AsElement() ElementHandle {\n\treturn e\n}\n\nfunc (e *elementHandleImpl) OwnerFrame() (Frame, error) {\n\tchannel, err := e.channel.Send(\"ownerFrame\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*frameImpl), nil\n}\n\nfunc (e *elementHandleImpl) ContentFrame() (Frame, error) {\n\tchannel, err := e.channel.Send(\"contentFrame\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*frameImpl), nil\n}\n\nfunc (e *elementHandleImpl) GetAttribute(name string) (string, error) {\n\tattribute, err := e.channel.Send(\"getAttribute\", map[string]interface{}{\n\t\t\"name\": name,\n\t})\n\tif attribute == nil {\n\t\treturn \"\", err\n\t}\n\treturn attribute.(string), err\n}\n\nfunc (e *elementHandleImpl) TextContent() (string, error) {\n\ttextContent, err := e.channel.Send(\"textContent\")\n\tif textContent == nil {\n\t\treturn \"\", err\n\t}\n\treturn textContent.(string), err\n}\n\nfunc (e *elementHandleImpl) InnerText() (string, error) {\n\tinnerText, err := e.channel.Send(\"innerText\")\n\tif innerText == nil {\n\t\treturn \"\", err\n\t}\n\treturn innerText.(string), err\n}\n\nfunc (e *elementHandleImpl) InnerHTML() (string, error) {\n\tinnerHTML, err := e.channel.Send(\"innerHTML\")\n\tif innerHTML == nil {\n\t\treturn \"\", err\n\t}\n\treturn innerHTML.(string), err\n}\n\nfunc (e *elementHandleImpl) DispatchEvent(typ string, initObjects ...interface{}) error {\n\tvar initObject interface{}\n\tif len(initObjects) == 1 {\n\t\tinitObject = initObjects[0]\n\t}\n\t_, err := e.channel.Send(\"dispatchEvent\", map[string]interface{}{\n\t\t\"type\":      typ,\n\t\t\"eventInit\": serializeArgument(initObject),\n\t})\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Hover(options ...ElementHandleHoverOptions) error {\n\t_, err := e.channel.Send(\"hover\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Click(options ...ElementHandleClickOptions) error {\n\t_, err := e.channel.Send(\"click\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Dblclick(options ...ElementHandleDblclickOptions) error {\n\t_, err := e.channel.Send(\"dblclick\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) QuerySelector(selector string) (ElementHandle, error) {\n\tchannel, err := e.channel.Send(\"querySelector\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif channel == nil {\n\t\treturn nil, nil\n\t}\n\treturn fromChannel(channel).(*elementHandleImpl), nil\n}\n\nfunc (e *elementHandleImpl) QuerySelectorAll(selector string) ([]ElementHandle, error) {\n\tchannels, err := e.channel.Send(\"querySelectorAll\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\telements := make([]ElementHandle, 0)\n\tfor _, channel := range channels.([]interface{}) {\n\t\telements = append(elements, fromChannel(channel).(*elementHandleImpl))\n\t}\n\treturn elements, nil\n}\n\nfunc (e *elementHandleImpl) EvalOnSelector(selector string, expression string, options ...interface{}) (interface{}, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := e.channel.Send(\"evalOnSelector\", map[string]interface{}{\n\t\t\"selector\":   selector,\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (e *elementHandleImpl) EvalOnSelectorAll(selector string, expression string, options ...interface{}) (interface{}, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := e.channel.Send(\"evalOnSelectorAll\", map[string]interface{}{\n\t\t\"selector\":   selector,\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (e *elementHandleImpl) ScrollIntoViewIfNeeded(options ...ElementHandleScrollIntoViewIfNeededOptions) error {\n\t_, err := e.channel.Send(\"scrollIntoViewIfNeeded\", options)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn err\n}\n\nfunc (e *elementHandleImpl) SetInputFiles(files interface{}, options ...ElementHandleSetInputFilesOptions) error {\n\tframe, err := e.OwnerFrame()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif frame == nil {\n\t\treturn errors.New(\"Cannot set input files to detached element\")\n\t}\n\n\tparams, err := convertInputFiles(files, frame.(*frameImpl).page.browserContext)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = e.channel.Send(\"setInputFiles\", params, options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) BoundingBox() (*Rect, error) {\n\tboundingBox, err := e.channel.Send(\"boundingBox\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif boundingBox == nil {\n\t\treturn nil, nil\n\t}\n\n\tout := &Rect{}\n\tremapMapToStruct(boundingBox, out)\n\treturn out, nil\n}\n\nfunc (e *elementHandleImpl) Check(options ...ElementHandleCheckOptions) error {\n\t_, err := e.channel.Send(\"check\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Uncheck(options ...ElementHandleUncheckOptions) error {\n\t_, err := e.channel.Send(\"uncheck\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Press(key string, options ...ElementHandlePressOptions) error {\n\t_, err := e.channel.Send(\"press\", map[string]interface{}{\n\t\t\"key\": key,\n\t}, options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Fill(value string, options ...ElementHandleFillOptions) error {\n\t_, err := e.channel.Send(\"fill\", map[string]interface{}{\n\t\t\"value\": value,\n\t}, options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Type(value string, options ...ElementHandleTypeOptions) error {\n\t_, err := e.channel.Send(\"type\", map[string]interface{}{\n\t\t\"text\": value,\n\t}, options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Focus() error {\n\t_, err := e.channel.Send(\"focus\")\n\treturn err\n}\n\nfunc (e *elementHandleImpl) SelectText(options ...ElementHandleSelectTextOptions) error {\n\t_, err := e.channel.Send(\"selectText\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) Screenshot(options ...ElementHandleScreenshotOptions) ([]byte, error) {\n\tvar path *string\n\toverrides := map[string]interface{}{}\n\tif len(options) == 1 {\n\t\tpath = options[0].Path\n\t\toptions[0].Path = nil\n\t\tif options[0].Mask != nil {\n\t\t\tmasks := make([]map[string]interface{}, 0)\n\t\t\tfor _, m := range options[0].Mask {\n\t\t\t\tif m.Err() != nil { // ErrLocatorNotSameFrame\n\t\t\t\t\treturn nil, m.Err()\n\t\t\t\t}\n\t\t\t\tl, ok := m.(*locatorImpl)\n\t\t\t\tif ok {\n\t\t\t\t\tmasks = append(masks, map[string]interface{}{\n\t\t\t\t\t\t\"selector\": l.selector,\n\t\t\t\t\t\t\"frame\":    l.frame.channel,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\toverrides[\"mask\"] = masks\n\t\t\toptions[0].Mask = nil\n\t\t}\n\t}\n\tdata, err := e.channel.Send(\"screenshot\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\timage, err := base64.StdEncoding.DecodeString(data.(string))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not decode base64 :%w\", err)\n\t}\n\tif path != nil {\n\t\tif err := os.WriteFile(*path, image, 0o644); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn image, nil\n}\n\nfunc (e *elementHandleImpl) Tap(options ...ElementHandleTapOptions) error {\n\t_, err := e.channel.Send(\"tap\", options)\n\treturn err\n}\n\nfunc (e *elementHandleImpl) SelectOption(values SelectOptionValues, options ...ElementHandleSelectOptionOptions) ([]string, error) {\n\topts := convertSelectOptionSet(values)\n\tselected, err := e.channel.Send(\"selectOption\", opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn transformToStringList(selected), nil\n}\n\nfunc (e *elementHandleImpl) IsChecked() (bool, error) {\n\tchecked, err := e.channel.Send(\"isChecked\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn checked.(bool), nil\n}\n\nfunc (e *elementHandleImpl) IsDisabled() (bool, error) {\n\tdisabled, err := e.channel.Send(\"isDisabled\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn disabled.(bool), nil\n}\n\nfunc (e *elementHandleImpl) IsEditable() (bool, error) {\n\teditable, err := e.channel.Send(\"isEditable\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn editable.(bool), nil\n}\n\nfunc (e *elementHandleImpl) IsEnabled() (bool, error) {\n\tenabled, err := e.channel.Send(\"isEnabled\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn enabled.(bool), nil\n}\n\nfunc (e *elementHandleImpl) IsHidden() (bool, error) {\n\thidden, err := e.channel.Send(\"isHidden\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn hidden.(bool), nil\n}\n\nfunc (e *elementHandleImpl) IsVisible() (bool, error) {\n\tvisible, err := e.channel.Send(\"isVisible\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn visible.(bool), nil\n}\n\nfunc (e *elementHandleImpl) WaitForElementState(state ElementState, options ...ElementHandleWaitForElementStateOptions) error {\n\t_, err := e.channel.Send(\"waitForElementState\", map[string]interface{}{\n\t\t\"state\": state,\n\t}, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (e *elementHandleImpl) WaitForSelector(selector string, options ...ElementHandleWaitForSelectorOptions) (ElementHandle, error) {\n\tch, err := e.channel.Send(\"waitForSelector\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tchannelOwner := fromNullableChannel(ch)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*elementHandleImpl), nil\n}\n\nfunc (e *elementHandleImpl) InputValue(options ...ElementHandleInputValueOptions) (string, error) {\n\tresult, err := e.channel.Send(\"inputValue\", options)\n\tif result == nil {\n\t\treturn \"\", err\n\t}\n\treturn result.(string), err\n}\n\nfunc (e *elementHandleImpl) SetChecked(checked bool, options ...ElementHandleSetCheckedOptions) error {\n\tif checked {\n\t\t_, err := e.channel.Send(\"check\", options)\n\t\treturn err\n\t} else {\n\t\t_, err := e.channel.Send(\"uncheck\", options)\n\t\treturn err\n\t}\n}\n\nfunc newElementHandle(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *elementHandleImpl {\n\tbt := &elementHandleImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\treturn bt\n}\n\nfunc transformToStringList(in interface{}) []string {\n\ts := in.([]interface{})\n\n\tvar out []string\n\tfor _, v := range s {\n\t\tout = append(out, v.(string))\n\t}\n\treturn out\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 1.4052734375,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nvar (\n\t// ErrPlaywright wraps all Playwright errors.\n\t//   - Use errors.Is to check if the error is a Playwright error.\n\t//   - Use errors.As to cast an error to [Error] if you want to access \"Stack\".\n\tErrPlaywright = errors.New(\"playwright\")\n\t// ErrTargetClosed usually wraps a reason.\n\tErrTargetClosed = errors.New(\"target closed\")\n\t// ErrTimeout wraps timeout errors. It can be either Playwright TimeoutError or client timeout.\n\tErrTimeout = errors.New(\"timeout\")\n)\n\n// Error represents a Playwright error\ntype Error struct {\n\tName    string `json:\"name\"`\n\tMessage string `json:\"message\"`\n\tStack   string `json:\"stack\"`\n}\n\nfunc (e *Error) Error() string {\n\treturn e.Message\n}\n\nfunc (e *Error) Is(target error) bool {\n\terr, ok := target.(*Error)\n\tif !ok {\n\t\treturn false\n\t}\n\tif err.Name != e.Name {\n\t\treturn false\n\t}\n\tif e.Name != \"Error\" {\n\t\treturn true // same name and not normal error\n\t}\n\treturn e.Message == err.Message\n}\n\nfunc parseError(err Error) error {\n\tif err.Name == \"TimeoutError\" {\n\t\treturn fmt.Errorf(\"%w: %w: %w\", ErrPlaywright, ErrTimeout, &err)\n\t} else if err.Name == \"TargetClosedError\" {\n\t\treturn fmt.Errorf(\"%w: %w: %w\", ErrPlaywright, ErrTargetClosed, &err)\n\t}\n\treturn fmt.Errorf(\"%w: %w\", ErrPlaywright, &err)\n}\n\nfunc targetClosedError(reason *string) error {\n\tif reason == nil {\n\t\treturn ErrTargetClosed\n\t}\n\treturn fmt.Errorf(\"%w: %s\", ErrTargetClosed, *reason)\n}\n"
        },
        {
          "name": "event_emitter.go",
          "type": "blob",
          "size": 3.29296875,
          "content": "package playwright\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"slices\"\n\t\"sync\"\n)\n\ntype EventEmitter interface {\n\tEmit(name string, payload ...interface{}) bool\n\tListenerCount(name string) int\n\tOn(name string, handler interface{})\n\tOnce(name string, handler interface{})\n\tRemoveListener(name string, handler interface{})\n\tRemoveListeners(name string)\n}\n\ntype (\n\teventEmitter struct {\n\t\teventsMutex sync.Mutex\n\t\tevents      map[string]*eventRegister\n\t\thasInit     bool\n\t}\n\teventRegister struct {\n\t\tsync.Mutex\n\t\tlisteners []listener\n\t}\n\tlistener struct {\n\t\thandler interface{}\n\t\tonce    bool\n\t}\n)\n\nfunc NewEventEmitter() EventEmitter {\n\treturn &eventEmitter{}\n}\n\nfunc (e *eventEmitter) Emit(name string, payload ...interface{}) (hasListener bool) {\n\te.eventsMutex.Lock()\n\te.init()\n\n\tevt, ok := e.events[name]\n\tif !ok {\n\t\te.eventsMutex.Unlock()\n\t\treturn\n\t}\n\te.eventsMutex.Unlock()\n\treturn evt.callHandlers(payload...) > 0\n}\n\nfunc (e *eventEmitter) Once(name string, handler interface{}) {\n\te.addEvent(name, handler, true)\n}\n\nfunc (e *eventEmitter) On(name string, handler interface{}) {\n\te.addEvent(name, handler, false)\n}\n\nfunc (e *eventEmitter) RemoveListener(name string, handler interface{}) {\n\te.eventsMutex.Lock()\n\tdefer e.eventsMutex.Unlock()\n\te.init()\n\n\tif evt, ok := e.events[name]; ok {\n\t\tevt.Lock()\n\t\tdefer evt.Unlock()\n\t\tevt.removeHandler(handler)\n\t}\n}\n\nfunc (e *eventEmitter) RemoveListeners(name string) {\n\te.eventsMutex.Lock()\n\tdefer e.eventsMutex.Unlock()\n\te.init()\n\tdelete(e.events, name)\n}\n\n// ListenerCount count the listeners by name, count all if name is empty\nfunc (e *eventEmitter) ListenerCount(name string) int {\n\te.eventsMutex.Lock()\n\tdefer e.eventsMutex.Unlock()\n\te.init()\n\n\tif name != \"\" {\n\t\tevt, ok := e.events[name]\n\t\tif !ok {\n\t\t\treturn 0\n\t\t}\n\t\treturn evt.count()\n\t}\n\n\tcount := 0\n\tfor key := range e.events {\n\t\tcount += e.events[key].count()\n\t}\n\n\treturn count\n}\n\nfunc (e *eventEmitter) addEvent(name string, handler interface{}, once bool) {\n\te.eventsMutex.Lock()\n\tdefer e.eventsMutex.Unlock()\n\te.init()\n\n\tif _, ok := e.events[name]; !ok {\n\t\te.events[name] = &eventRegister{\n\t\t\tlisteners: make([]listener, 0),\n\t\t}\n\t}\n\te.events[name].addHandler(handler, once)\n}\n\nfunc (e *eventEmitter) init() {\n\tif !e.hasInit {\n\t\te.events = make(map[string]*eventRegister, 0)\n\t\te.hasInit = true\n\t}\n}\n\nfunc (er *eventRegister) addHandler(handler interface{}, once bool) {\n\ter.Lock()\n\tdefer er.Unlock()\n\ter.listeners = append(er.listeners, listener{handler: handler, once: once})\n}\n\nfunc (er *eventRegister) count() int {\n\ter.Lock()\n\tdefer er.Unlock()\n\treturn len(er.listeners)\n}\n\nfunc (er *eventRegister) removeHandler(handler interface{}) {\n\thandlerPtr := reflect.ValueOf(handler).Pointer()\n\n\ter.listeners = slices.DeleteFunc(er.listeners, func(l listener) bool {\n\t\treturn reflect.ValueOf(l.handler).Pointer() == handlerPtr\n\t})\n}\n\nfunc (er *eventRegister) callHandlers(payloads ...interface{}) int {\n\tpayloadV := make([]reflect.Value, 0)\n\n\tfor _, p := range payloads {\n\t\tpayloadV = append(payloadV, reflect.ValueOf(p))\n\t}\n\n\thandle := func(l listener) {\n\t\thandlerV := reflect.ValueOf(l.handler)\n\t\thandlerV.Call(payloadV[:int(math.Min(float64(handlerV.Type().NumIn()), float64(len(payloadV))))])\n\t}\n\n\ter.Lock()\n\tdefer er.Unlock()\n\tcount := len(er.listeners)\n\tfor _, l := range er.listeners {\n\t\tif l.once {\n\t\t\tdefer er.removeHandler(l.handler)\n\t\t}\n\t\thandle(l)\n\t}\n\treturn count\n}\n"
        },
        {
          "name": "event_emitter_test.go",
          "type": "blob",
          "size": 3.2373046875,
          "content": "package playwright\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\ttestEventName    = \"foobar\"\n\ttestEventNameFoo = \"foo\"\n\ttestEventNameBar = \"bar\"\n)\n\nfunc TestEventEmitterListenerCount(t *testing.T) {\n\thandler := &eventEmitter{}\n\twasCalled := make(chan interface{}, 1)\n\tmyHandler := func(payload ...interface{}) {\n\t\twasCalled <- payload[0]\n\t}\n\trequire.Nil(t, handler.events[testEventNameFoo])\n\thandler.On(testEventNameFoo, myHandler)\n\trequire.Equal(t, 1, handler.ListenerCount(testEventNameFoo))\n\thandler.Once(testEventNameFoo, myHandler)\n\trequire.Equal(t, 2, handler.ListenerCount(testEventNameFoo))\n\trequire.Nil(t, handler.events[testEventNameBar])\n\thandler.Once(testEventNameBar, myHandler)\n\trequire.Equal(t, 1, handler.ListenerCount(testEventNameBar))\n\trequire.Equal(t, 3, handler.ListenerCount(\"\"))\n}\n\nfunc TestEventEmitterOn(t *testing.T) {\n\thandler := &eventEmitter{}\n\twasCalled := make(chan interface{}, 1)\n\trequire.Nil(t, handler.events[testEventName])\n\thandler.On(testEventName, func(payload ...interface{}) {\n\t\twasCalled <- payload[0]\n\t})\n\trequire.Equal(t, 1, handler.ListenerCount(testEventName))\n\tvalue := 123\n\thandler.Emit(testEventName, value)\n\tresult := <-wasCalled\n\trequire.Equal(t, 1, handler.ListenerCount(testEventName))\n\trequire.Equal(t, result.(int), value)\n}\n\nfunc TestEventEmitterOnce(t *testing.T) {\n\thandler := &eventEmitter{}\n\twasCalled := make(chan interface{}, 1)\n\trequire.Nil(t, handler.events[testEventName])\n\thandler.Once(testEventName, func(payload ...interface{}) {\n\t\twasCalled <- payload[0]\n\t})\n\trequire.Equal(t, 1, handler.ListenerCount(testEventName))\n\tvalue := 123\n\thandler.Emit(testEventName, value)\n\tresult := <-wasCalled\n\trequire.Equal(t, result.(int), value)\n\trequire.Equal(t, 0, handler.ListenerCount(testEventName))\n}\n\nfunc TestEventEmitterRemove(t *testing.T) {\n\thandler := &eventEmitter{}\n\twasCalled := make(chan interface{}, 1)\n\trequire.Nil(t, handler.events[testEventName])\n\tmyHandler := func(payload ...interface{}) {\n\t\twasCalled <- payload[0]\n\t}\n\thandler.On(testEventName, myHandler)\n\trequire.Equal(t, 1, handler.ListenerCount(testEventName))\n\tvalue := 123\n\thandler.Emit(testEventName, value)\n\tresult := <-wasCalled\n\trequire.Equal(t, 1, handler.ListenerCount(testEventName))\n\trequire.Equal(t, result.(int), value)\n\thandler.Once(testEventName, myHandler)\n\thandler.RemoveListener(testEventName, myHandler)\n\trequire.Equal(t, 0, handler.ListenerCount(testEventName))\n}\n\nfunc TestEventEmitterRemoveEmpty(t *testing.T) {\n\thandler := &eventEmitter{}\n\thandler.RemoveListener(testEventName, func(...interface{}) {})\n\trequire.Equal(t, 0, handler.ListenerCount(testEventName))\n}\n\nfunc TestEventEmitterRemoveKeepExisting(t *testing.T) {\n\thandler := &eventEmitter{}\n\thandler.On(testEventName, func(...interface{}) {})\n\thandler.Once(testEventName, func(...interface{}) {})\n\thandler.RemoveListener(\"abc123\", func(...interface{}) {})\n\thandler.RemoveListener(testEventName, func(...interface{}) {})\n\trequire.Equal(t, 2, handler.ListenerCount(testEventName))\n}\n\nfunc TestEventEmitterOnLessArgsAcceptingReceiver(t *testing.T) {\n\thandler := &eventEmitter{}\n\twasCalled := make(chan bool, 1)\n\trequire.Nil(t, handler.events[testEventName])\n\thandler.Once(testEventName, func(ev ...interface{}) {\n\t\twasCalled <- true\n\t})\n\thandler.Emit(testEventName)\n\t<-wasCalled\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fetch.go",
          "type": "blob",
          "size": 11.67578125,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype apiRequestImpl struct {\n\t*Playwright\n}\n\nfunc (r *apiRequestImpl) NewContext(options ...APIRequestNewContextOptions) (APIRequestContext, error) {\n\toverrides := map[string]interface{}{}\n\tif len(options) == 1 {\n\t\tif options[0].ClientCertificates != nil {\n\t\t\tcerts, err := transformClientCertificate(options[0].ClientCertificates)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toverrides[\"clientCertificates\"] = certs\n\t\t\toptions[0].ClientCertificates = nil\n\t\t}\n\t\tif options[0].ExtraHttpHeaders != nil {\n\t\t\toverrides[\"extraHTTPHeaders\"] = serializeMapToNameAndValue(options[0].ExtraHttpHeaders)\n\t\t\toptions[0].ExtraHttpHeaders = nil\n\t\t}\n\t\tif options[0].StorageStatePath != nil {\n\t\t\tvar storageState *StorageState\n\t\t\tstorageString, err := os.ReadFile(*options[0].StorageStatePath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not read storage state file: %w\", err)\n\t\t\t}\n\t\t\terr = json.Unmarshal(storageString, &storageState)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"could not parse storage state file: %w\", err)\n\t\t\t}\n\t\t\toptions[0].StorageState = storageState\n\t\t\toptions[0].StorageStatePath = nil\n\t\t}\n\t}\n\n\tchannel, err := r.channel.Send(\"newRequest\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(channel).(*apiRequestContextImpl), nil\n}\n\nfunc newApiRequestImpl(pw *Playwright) *apiRequestImpl {\n\treturn &apiRequestImpl{pw}\n}\n\ntype apiRequestContextImpl struct {\n\tchannelOwner\n\ttracing     *tracingImpl\n\tcloseReason *string\n}\n\nfunc (r *apiRequestContextImpl) Dispose(options ...APIRequestContextDisposeOptions) error {\n\tif len(options) == 1 {\n\t\tr.closeReason = options[0].Reason\n\t}\n\t_, err := r.channel.Send(\"dispose\", map[string]interface{}{\n\t\t\"reason\": r.closeReason,\n\t})\n\tif errors.Is(err, ErrTargetClosed) {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc (r *apiRequestContextImpl) Delete(url string, options ...APIRequestContextDeleteOptions) (APIResponse, error) {\n\topts := APIRequestContextFetchOptions{\n\t\tMethod: String(\"DELETE\"),\n\t}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(&opts, options[0], false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r.Fetch(url, opts)\n}\n\nfunc (r *apiRequestContextImpl) Fetch(urlOrRequest interface{}, options ...APIRequestContextFetchOptions) (APIResponse, error) {\n\tswitch v := urlOrRequest.(type) {\n\tcase string:\n\t\treturn r.innerFetch(v, nil, options...)\n\tcase Request:\n\t\treturn r.innerFetch(\"\", v, options...)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"urlOrRequest has unsupported type: %T\", urlOrRequest)\n\t}\n}\n\nfunc (r *apiRequestContextImpl) innerFetch(url string, request Request, options ...APIRequestContextFetchOptions) (APIResponse, error) {\n\tif r.closeReason != nil {\n\t\treturn nil, fmt.Errorf(\"%w: %s\", ErrTargetClosed, *r.closeReason)\n\t}\n\toverrides := map[string]interface{}{}\n\tif url != \"\" {\n\t\toverrides[\"url\"] = url\n\t} else if request != nil {\n\t\toverrides[\"url\"] = request.URL()\n\t}\n\n\tif len(options) == 1 {\n\t\tif options[0].MaxRedirects != nil && *options[0].MaxRedirects < 0 {\n\t\t\treturn nil, errors.New(\"maxRedirects must be non-negative\")\n\t\t}\n\t\tif options[0].MaxRetries != nil && *options[0].MaxRetries < 0 {\n\t\t\treturn nil, errors.New(\"maxRetries must be non-negative\")\n\t\t}\n\t\t// only one of them can be specified\n\t\tif countNonNil(options[0].Data, options[0].Form, options[0].Multipart) > 1 {\n\t\t\treturn nil, errors.New(\"only one of 'data', 'form' or 'multipart' can be specified\")\n\t\t}\n\t\tif options[0].Method == nil {\n\t\t\tif request != nil {\n\t\t\t\toptions[0].Method = String(request.Method())\n\t\t\t} else {\n\t\t\t\toptions[0].Method = String(\"GET\")\n\t\t\t}\n\t\t}\n\t\tif options[0].Headers == nil {\n\t\t\tif request != nil {\n\t\t\t\toverrides[\"headers\"] = serializeMapToNameAndValue(request.Headers())\n\t\t\t}\n\t\t} else {\n\t\t\toverrides[\"headers\"] = serializeMapToNameAndValue(options[0].Headers)\n\t\t\toptions[0].Headers = nil\n\t\t}\n\t\tif options[0].Data != nil {\n\t\t\tswitch v := options[0].Data.(type) {\n\t\t\tcase string:\n\t\t\t\theadersArray, ok := overrides[\"headers\"].([]map[string]string)\n\t\t\t\tif ok && isJsonContentType(headersArray) {\n\t\t\t\t\tif json.Valid([]byte(v)) {\n\t\t\t\t\t\toverrides[\"jsonData\"] = v\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata, err := json.Marshal(v)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"could not marshal data: %w\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\toverrides[\"jsonData\"] = string(data)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toverrides[\"postData\"] = base64.StdEncoding.EncodeToString([]byte(v))\n\t\t\t\t}\n\t\t\tcase []byte:\n\t\t\t\toverrides[\"postData\"] = base64.StdEncoding.EncodeToString(v)\n\t\t\tcase interface{}:\n\t\t\t\tdata, err := json.Marshal(v)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"could not marshal data: %w\", err)\n\t\t\t\t}\n\t\t\t\toverrides[\"jsonData\"] = string(data)\n\t\t\tdefault:\n\t\t\t\treturn nil, errors.New(\"data must be a string, []byte, or interface{} that can marshal to json\")\n\t\t\t}\n\t\t\toptions[0].Data = nil\n\t\t} else if options[0].Form != nil {\n\t\t\tform, ok := options[0].Form.(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.New(\"form must be a map\")\n\t\t\t}\n\t\t\toverrides[\"formData\"] = serializeMapToNameValue(form)\n\t\t\toptions[0].Form = nil\n\t\t} else if options[0].Multipart != nil {\n\t\t\t_, ok := options[0].Multipart.(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.New(\"multipart must be a map\")\n\t\t\t}\n\t\t\tmultipartData := []map[string]interface{}{}\n\t\t\tfor name, value := range options[0].Multipart.(map[string]interface{}) {\n\t\t\t\tswitch v := value.(type) {\n\t\t\t\tcase InputFile:\n\t\t\t\t\tmultipartData = append(multipartData, map[string]interface{}{\n\t\t\t\t\t\t\"name\": name,\n\t\t\t\t\t\t\"file\": map[string]string{\n\t\t\t\t\t\t\t\"name\":     v.Name,\n\t\t\t\t\t\t\t\"mimeType\": v.MimeType,\n\t\t\t\t\t\t\t\"buffer\":   base64.StdEncoding.EncodeToString(v.Buffer),\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\tdefault:\n\t\t\t\t\tmultipartData = append(multipartData, map[string]interface{}{\n\t\t\t\t\t\t\"name\":  name,\n\t\t\t\t\t\t\"value\": String(fmt.Sprintf(\"%v\", v)),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\toverrides[\"multipartData\"] = multipartData\n\t\t\toptions[0].Multipart = nil\n\t\t} else if request != nil {\n\t\t\tpostDataBuf, err := request.PostDataBuffer()\n\t\t\tif err == nil {\n\t\t\t\toverrides[\"postData\"] = base64.StdEncoding.EncodeToString(postDataBuf)\n\t\t\t}\n\t\t}\n\t\tif options[0].Params != nil {\n\t\t\toverrides[\"params\"] = serializeMapToNameValue(options[0].Params)\n\t\t\toptions[0].Params = nil\n\t\t}\n\t}\n\n\tresponse, err := r.channel.Send(\"fetch\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newAPIResponse(r, response.(map[string]interface{})), nil\n}\n\nfunc (r *apiRequestContextImpl) Get(url string, options ...APIRequestContextGetOptions) (APIResponse, error) {\n\topts := APIRequestContextFetchOptions{\n\t\tMethod: String(\"GET\"),\n\t}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(&opts, options[0], false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r.Fetch(url, opts)\n}\n\nfunc (r *apiRequestContextImpl) Head(url string, options ...APIRequestContextHeadOptions) (APIResponse, error) {\n\topts := APIRequestContextFetchOptions{\n\t\tMethod: String(\"HEAD\"),\n\t}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(&opts, options[0], false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r.Fetch(url, opts)\n}\n\nfunc (r *apiRequestContextImpl) Patch(url string, options ...APIRequestContextPatchOptions) (APIResponse, error) {\n\topts := APIRequestContextFetchOptions{\n\t\tMethod: String(\"PATCH\"),\n\t}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(&opts, options[0], false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r.Fetch(url, opts)\n}\n\nfunc (r *apiRequestContextImpl) Put(url string, options ...APIRequestContextPutOptions) (APIResponse, error) {\n\topts := APIRequestContextFetchOptions{\n\t\tMethod: String(\"PUT\"),\n\t}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(&opts, options[0], false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r.Fetch(url, opts)\n}\n\nfunc (r *apiRequestContextImpl) Post(url string, options ...APIRequestContextPostOptions) (APIResponse, error) {\n\topts := APIRequestContextFetchOptions{\n\t\tMethod: String(\"POST\"),\n\t}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(&opts, options[0], false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn r.Fetch(url, opts)\n}\n\nfunc (r *apiRequestContextImpl) StorageState(path ...string) (*StorageState, error) {\n\tresult, err := r.channel.SendReturnAsDict(\"storageState\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(path) == 1 {\n\t\tfile, err := os.Create(path[0])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := json.NewEncoder(file).Encode(result); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err := file.Close(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tvar storageState StorageState\n\tremapMapToStruct(result, &storageState)\n\treturn &storageState, nil\n}\n\nfunc newAPIRequestContext(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *apiRequestContextImpl {\n\trc := &apiRequestContextImpl{}\n\trc.createChannelOwner(rc, parent, objectType, guid, initializer)\n\trc.tracing = fromChannel(initializer[\"tracing\"]).(*tracingImpl)\n\treturn rc\n}\n\ntype apiResponseImpl struct {\n\trequest     *apiRequestContextImpl\n\tinitializer map[string]interface{}\n\theaders     *rawHeaders\n}\n\nfunc (r *apiResponseImpl) Body() ([]byte, error) {\n\tresult, err := r.request.channel.SendReturnAsDict(\"fetchResponseBody\", []map[string]interface{}{\n\t\t{\n\t\t\t\"fetchUid\": r.fetchUid(),\n\t\t},\n\t})\n\tif err != nil {\n\t\tif errors.Is(err, ErrTargetClosed) {\n\t\t\treturn nil, errors.New(\"response has been disposed\")\n\t\t}\n\t\treturn nil, err\n\t}\n\tbody := result[\"binary\"]\n\tif body == nil {\n\t\treturn nil, errors.New(\"response has been disposed\")\n\t}\n\treturn base64.StdEncoding.DecodeString(body.(string))\n}\n\nfunc (r *apiResponseImpl) Dispose() error {\n\t_, err := r.request.channel.Send(\"disposeAPIResponse\", []map[string]interface{}{\n\t\t{\n\t\t\t\"fetchUid\": r.fetchUid(),\n\t\t},\n\t})\n\treturn err\n}\n\nfunc (r *apiResponseImpl) Headers() map[string]string {\n\treturn r.headers.Headers()\n}\n\nfunc (r *apiResponseImpl) HeadersArray() []NameValue {\n\treturn r.headers.HeadersArray()\n}\n\nfunc (r *apiResponseImpl) JSON(v interface{}) error {\n\tbody, err := r.Body()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(body, &v)\n}\n\nfunc (r *apiResponseImpl) Ok() bool {\n\treturn r.Status() == 0 || (r.Status() >= 200 && r.Status() <= 299)\n}\n\nfunc (r *apiResponseImpl) Status() int {\n\treturn int(r.initializer[\"status\"].(float64))\n}\n\nfunc (r *apiResponseImpl) StatusText() string {\n\treturn r.initializer[\"statusText\"].(string)\n}\n\nfunc (r *apiResponseImpl) Text() (string, error) {\n\tbody, err := r.Body()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}\n\nfunc (r *apiResponseImpl) URL() string {\n\treturn r.initializer[\"url\"].(string)\n}\n\nfunc (r *apiResponseImpl) fetchUid() string {\n\treturn r.initializer[\"fetchUid\"].(string)\n}\n\nfunc (r *apiResponseImpl) fetchLog() ([]string, error) {\n\tret, err := r.request.channel.Send(\"fetchLog\", map[string]interface{}{\n\t\t\"fetchUid\": r.fetchUid(),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := make([]string, len(ret.([]interface{})))\n\tfor i, v := range ret.([]interface{}) {\n\t\tresult[i] = v.(string)\n\t}\n\treturn result, nil\n}\n\nfunc newAPIResponse(context *apiRequestContextImpl, initializer map[string]interface{}) *apiResponseImpl {\n\treturn &apiResponseImpl{\n\t\trequest:     context,\n\t\tinitializer: initializer,\n\t\theaders:     newRawHeaders(initializer[\"headers\"]),\n\t}\n}\n\nfunc countNonNil(args ...interface{}) int {\n\tcount := 0\n\tfor _, v := range args {\n\t\tif v != nil {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc isJsonContentType(headers []map[string]string) bool {\n\tif len(headers) > 0 {\n\t\tfor _, v := range headers {\n\t\t\tif strings.ToLower(v[\"name\"]) == \"content-type\" {\n\t\t\t\tif v[\"value\"] == \"application/json\" {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc serializeMapToNameValue(data map[string]interface{}) []map[string]string {\n\tserialized := make([]map[string]string, 0, len(data))\n\tfor k, v := range data {\n\t\tserialized = append(serialized, map[string]string{\n\t\t\t\"name\":  k,\n\t\t\t\"value\": fmt.Sprintf(\"%v\", v),\n\t\t})\n\t}\n\treturn serialized\n}\n"
        },
        {
          "name": "file_chooser.go",
          "type": "blob",
          "size": 1.052734375,
          "content": "package playwright\n\ntype fileChooserImpl struct {\n\tpage          Page\n\telementHandle ElementHandle\n\tisMultiple    bool\n}\n\nfunc (f *fileChooserImpl) Page() Page {\n\treturn f.page\n}\n\nfunc (f *fileChooserImpl) Element() ElementHandle {\n\treturn f.elementHandle\n}\n\nfunc (f *fileChooserImpl) IsMultiple() bool {\n\treturn f.isMultiple\n}\n\n// InputFile represents the input file for:\n// - FileChooser.SetFiles()\n// - ElementHandle.SetInputFiles()\n// - Page.SetInputFiles()\ntype InputFile struct {\n\tName     string `json:\"name\"`\n\tMimeType string `json:\"mimeType,omitempty\"`\n\tBuffer   []byte `json:\"buffer\"`\n}\n\nfunc (f *fileChooserImpl) SetFiles(files interface{}, options ...FileChooserSetFilesOptions) error {\n\tif len(options) == 1 {\n\t\treturn f.elementHandle.SetInputFiles(files, ElementHandleSetInputFilesOptions(options[0]))\n\t}\n\treturn f.elementHandle.SetInputFiles(files)\n}\n\nfunc newFileChooser(page Page, elementHandle ElementHandle, isMultiple bool) *fileChooserImpl {\n\treturn &fileChooserImpl{\n\t\tpage:          page,\n\t\telementHandle: elementHandle,\n\t\tisMultiple:    isMultiple,\n\t}\n}\n"
        },
        {
          "name": "frame.go",
          "type": "blob",
          "size": 20.7236328125,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"time\"\n\n\tmapset \"github.com/deckarep/golang-set/v2\"\n)\n\ntype frameImpl struct {\n\tchannelOwner\n\tdetached    bool\n\tpage        *pageImpl\n\tname        string\n\turl         string\n\tparentFrame Frame\n\tchildFrames []Frame\n\tloadStates  mapset.Set[string]\n}\n\nfunc newFrame(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *frameImpl {\n\tvar loadStates mapset.Set[string]\n\n\tif ls, ok := initializer[\"loadStates\"].([]string); ok {\n\t\tloadStates = mapset.NewSet[string](ls...)\n\t} else {\n\t\tloadStates = mapset.NewSet[string]()\n\t}\n\tf := &frameImpl{\n\t\tname:        initializer[\"name\"].(string),\n\t\turl:         initializer[\"url\"].(string),\n\t\tloadStates:  loadStates,\n\t\tchildFrames: make([]Frame, 0),\n\t}\n\tf.createChannelOwner(f, parent, objectType, guid, initializer)\n\n\tchannelOwner := fromNullableChannel(initializer[\"parentFrame\"])\n\tif channelOwner != nil {\n\t\tf.parentFrame = channelOwner.(*frameImpl)\n\t\tf.parentFrame.(*frameImpl).childFrames = append(f.parentFrame.(*frameImpl).childFrames, f)\n\t}\n\n\tf.channel.On(\"navigated\", f.onFrameNavigated)\n\tf.channel.On(\"loadstate\", f.onLoadState)\n\treturn f\n}\n\nfunc (f *frameImpl) URL() string {\n\tf.RLock()\n\tdefer f.RUnlock()\n\treturn f.url\n}\n\nfunc (f *frameImpl) Name() string {\n\tf.RLock()\n\tdefer f.RUnlock()\n\treturn f.name\n}\n\nfunc (f *frameImpl) SetContent(content string, options ...FrameSetContentOptions) error {\n\t_, err := f.channel.Send(\"setContent\", map[string]interface{}{\n\t\t\"html\": content,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Content() (string, error) {\n\tcontent, err := f.channel.Send(\"content\")\n\tif content == nil {\n\t\treturn \"\", err\n\t}\n\treturn content.(string), err\n}\n\nfunc (f *frameImpl) Goto(url string, options ...FrameGotoOptions) (Response, error) {\n\tchannel, err := f.channel.Send(\"goto\", map[string]interface{}{\n\t\t\"url\": url,\n\t}, options)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Frame.Goto %s: %w\", url, err)\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\t// navigation to about:blank or navigation to the same URL with a different hash\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*responseImpl), nil\n}\n\nfunc (f *frameImpl) AddScriptTag(options FrameAddScriptTagOptions) (ElementHandle, error) {\n\tif options.Path != nil {\n\t\tfile, err := os.ReadFile(*options.Path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\toptions.Content = String(string(file))\n\t\toptions.Path = nil\n\t}\n\tchannel, err := f.channel.Send(\"addScriptTag\", options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(channel).(*elementHandleImpl), nil\n}\n\nfunc (f *frameImpl) AddStyleTag(options FrameAddStyleTagOptions) (ElementHandle, error) {\n\tif options.Path != nil {\n\t\tfile, err := os.ReadFile(*options.Path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\toptions.Content = String(string(file))\n\t\toptions.Path = nil\n\t}\n\tchannel, err := f.channel.Send(\"addStyleTag\", options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(channel).(*elementHandleImpl), nil\n}\n\nfunc (f *frameImpl) Page() Page {\n\treturn f.page\n}\n\nfunc (f *frameImpl) WaitForLoadState(options ...FrameWaitForLoadStateOptions) error {\n\toption := FrameWaitForLoadStateOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.State == nil {\n\t\toption.State = LoadStateLoad\n\t}\n\treturn f.waitForLoadStateImpl(string(*option.State), option.Timeout, nil)\n}\n\nfunc (f *frameImpl) waitForLoadStateImpl(state string, timeout *float64, cb func() error) error {\n\tif f.loadStates.ContainsOne(state) {\n\t\treturn nil\n\t}\n\twaiter, err := f.setNavigationWaiter(timeout)\n\tif err != nil {\n\t\treturn err\n\t}\n\twaiter.WaitForEvent(f, \"loadstate\", func(payload interface{}) bool {\n\t\tgotState := payload.(string)\n\t\treturn gotState == state\n\t})\n\tif cb == nil {\n\t\t_, err := waiter.Wait()\n\t\treturn err\n\t} else {\n\t\t_, err := waiter.RunAndWait(cb)\n\t\treturn err\n\t}\n}\n\nfunc (f *frameImpl) WaitForURL(url interface{}, options ...FrameWaitForURLOptions) error {\n\tif f.page == nil {\n\t\treturn errors.New(\"frame is detached\")\n\t}\n\tmatcher := newURLMatcher(url, f.page.browserContext.options.BaseURL)\n\tif matcher.Matches(f.URL()) {\n\t\tstate := \"load\"\n\t\ttimeout := Float(f.page.timeoutSettings.NavigationTimeout())\n\t\tif len(options) == 1 {\n\t\t\tif options[0].WaitUntil != nil {\n\t\t\t\tstate = string(*options[0].WaitUntil)\n\t\t\t}\n\t\t\tif options[0].Timeout != nil {\n\t\t\t\ttimeout = options[0].Timeout\n\t\t\t}\n\t\t}\n\t\treturn f.waitForLoadStateImpl(state, timeout, nil)\n\t}\n\tnavigationOptions := FrameExpectNavigationOptions{URL: url}\n\tif len(options) > 0 {\n\t\tnavigationOptions.Timeout = options[0].Timeout\n\t\tnavigationOptions.WaitUntil = options[0].WaitUntil\n\t}\n\tif _, err := f.ExpectNavigation(nil, navigationOptions); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (f *frameImpl) ExpectNavigation(cb func() error, options ...FrameExpectNavigationOptions) (Response, error) {\n\tif f.page == nil {\n\t\treturn nil, errors.New(\"frame is detached\")\n\t}\n\toption := FrameExpectNavigationOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.WaitUntil == nil {\n\t\toption.WaitUntil = WaitUntilStateLoad\n\t}\n\tif option.Timeout == nil {\n\t\toption.Timeout = Float(f.page.timeoutSettings.NavigationTimeout())\n\t}\n\tdeadline := time.Now().Add(time.Duration(*option.Timeout) * time.Millisecond)\n\tvar matcher *urlMatcher\n\tif option.URL != nil {\n\t\tmatcher = newURLMatcher(option.URL, f.page.browserContext.options.BaseURL)\n\t}\n\tpredicate := func(events ...interface{}) bool {\n\t\tev := events[0].(map[string]interface{})\n\t\terr, ok := ev[\"error\"]\n\t\tif ok {\n\t\t\t// Any failed navigation results in a rejection.\n\t\t\tlogger.Error(\"navigation error\", \"url\", ev[\"url\"].(string), \"error\", err)\n\t\t\treturn true\n\t\t}\n\t\treturn matcher == nil || matcher.Matches(ev[\"url\"].(string))\n\t}\n\twaiter, err := f.setNavigationWaiter(option.Timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\teventData, err := waiter.WaitForEvent(f, \"navigated\", predicate).RunAndWait(cb)\n\tif err != nil || eventData == nil {\n\t\treturn nil, err\n\t}\n\n\tt := time.Until(deadline).Milliseconds()\n\tif t > 0 {\n\t\terr = f.waitForLoadStateImpl(string(*option.WaitUntil), Float(float64(t)), nil)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tevent := eventData.(map[string]interface{})\n\tif event[\"newDocument\"] != nil && event[\"newDocument\"].(map[string]interface{})[\"request\"] != nil {\n\t\trequest := fromChannel(event[\"newDocument\"].(map[string]interface{})[\"request\"]).(*requestImpl)\n\t\treturn request.Response()\n\t}\n\treturn nil, nil\n}\n\nfunc (f *frameImpl) setNavigationWaiter(timeout *float64) (*waiter, error) {\n\tif f.page == nil {\n\t\treturn nil, errors.New(\"page does not exist\")\n\t}\n\twaiter := newWaiter()\n\tif timeout != nil {\n\t\twaiter.WithTimeout(*timeout)\n\t} else {\n\t\twaiter.WithTimeout(f.page.timeoutSettings.NavigationTimeout())\n\t}\n\twaiter.RejectOnEvent(f.page, \"close\", f.page.closeErrorWithReason())\n\twaiter.RejectOnEvent(f.page, \"crash\", fmt.Errorf(\"Navigation failed because page crashed!\"))\n\twaiter.RejectOnEvent(f.page, \"framedetached\", fmt.Errorf(\"Navigating frame was detached!\"), func(payload interface{}) bool {\n\t\tframe, ok := payload.(*frameImpl)\n\t\tif ok && frame == f {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\treturn waiter, nil\n}\n\nfunc (f *frameImpl) onFrameNavigated(ev map[string]interface{}) {\n\tf.Lock()\n\tf.url = ev[\"url\"].(string)\n\tf.name = ev[\"name\"].(string)\n\tf.Unlock()\n\tf.Emit(\"navigated\", ev)\n\t_, ok := ev[\"error\"]\n\tif !ok && f.page != nil {\n\t\tf.page.Emit(\"framenavigated\", f)\n\t}\n}\n\nfunc (f *frameImpl) onLoadState(ev map[string]interface{}) {\n\tif ev[\"add\"] != nil {\n\t\tadd := ev[\"add\"].(string)\n\t\tf.loadStates.Add(add)\n\t\tf.Emit(\"loadstate\", add)\n\t\tif f.parentFrame == nil && f.page != nil {\n\t\t\tif add == \"load\" || add == \"domcontentloaded\" {\n\t\t\t\tf.Page().Emit(add, f.page)\n\t\t\t}\n\t\t}\n\t} else if ev[\"remove\"] != nil {\n\t\tremove := ev[\"remove\"].(string)\n\t\tf.loadStates.Remove(remove)\n\t}\n}\n\nfunc (f *frameImpl) QuerySelector(selector string, options ...FrameQuerySelectorOptions) (ElementHandle, error) {\n\tparams := map[string]interface{}{\n\t\t\"selector\": selector,\n\t}\n\tif len(options) == 1 {\n\t\tparams[\"strict\"] = options[0].Strict\n\t}\n\tchannel, err := f.channel.Send(\"querySelector\", params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif channel == nil {\n\t\treturn nil, nil\n\t}\n\treturn fromChannel(channel).(*elementHandleImpl), nil\n}\n\nfunc (f *frameImpl) QuerySelectorAll(selector string) ([]ElementHandle, error) {\n\tchannels, err := f.channel.Send(\"querySelectorAll\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\telements := make([]ElementHandle, 0)\n\tfor _, channel := range channels.([]interface{}) {\n\t\telements = append(elements, fromChannel(channel).(*elementHandleImpl))\n\t}\n\treturn elements, nil\n}\n\nfunc (f *frameImpl) Evaluate(expression string, options ...interface{}) (interface{}, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := f.channel.Send(\"evaluateExpression\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (f *frameImpl) EvalOnSelector(selector string, expression string, arg interface{}, options ...FrameEvalOnSelectorOptions) (interface{}, error) {\n\tparams := map[string]interface{}{\n\t\t\"selector\":   selector,\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t}\n\tif len(options) == 1 && options[0].Strict != nil {\n\t\tparams[\"strict\"] = *options[0].Strict\n\t}\n\n\tresult, err := f.channel.Send(\"evalOnSelector\", params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (f *frameImpl) EvalOnSelectorAll(selector string, expression string, options ...interface{}) (interface{}, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := f.channel.Send(\"evalOnSelectorAll\", map[string]interface{}{\n\t\t\"selector\":   selector,\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (f *frameImpl) EvaluateHandle(expression string, options ...interface{}) (JSHandle, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := f.channel.Send(\"evaluateExpressionHandle\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromChannel(result)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(JSHandle), nil\n}\n\nfunc (f *frameImpl) Click(selector string, options ...FrameClickOptions) error {\n\t_, err := f.channel.Send(\"click\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) WaitForSelector(selector string, options ...FrameWaitForSelectorOptions) (ElementHandle, error) {\n\tchannel, err := f.channel.Send(\"waitForSelector\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*elementHandleImpl), nil\n}\n\nfunc (f *frameImpl) DispatchEvent(selector, typ string, eventInit interface{}, options ...FrameDispatchEventOptions) error {\n\t_, err := f.channel.Send(\"dispatchEvent\", map[string]interface{}{\n\t\t\"selector\":  selector,\n\t\t\"type\":      typ,\n\t\t\"eventInit\": serializeArgument(eventInit),\n\t})\n\treturn err\n}\n\nfunc (f *frameImpl) InnerText(selector string, options ...FrameInnerTextOptions) (string, error) {\n\tinnerText, err := f.channel.Send(\"innerText\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif innerText == nil {\n\t\treturn \"\", err\n\t}\n\treturn innerText.(string), err\n}\n\nfunc (f *frameImpl) InnerHTML(selector string, options ...FrameInnerHTMLOptions) (string, error) {\n\tinnerHTML, err := f.channel.Send(\"innerHTML\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif innerHTML == nil {\n\t\treturn \"\", err\n\t}\n\treturn innerHTML.(string), err\n}\n\nfunc (f *frameImpl) GetAttribute(selector string, name string, options ...FrameGetAttributeOptions) (string, error) {\n\tattribute, err := f.channel.Send(\"getAttribute\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t\t\"name\":     name,\n\t}, options)\n\tif attribute == nil {\n\t\treturn \"\", err\n\t}\n\treturn attribute.(string), err\n}\n\nfunc (f *frameImpl) Hover(selector string, options ...FrameHoverOptions) error {\n\t_, err := f.channel.Send(\"hover\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) SetInputFiles(selector string, files interface{}, options ...FrameSetInputFilesOptions) error {\n\tparams, err := convertInputFiles(files, f.page.browserContext)\n\tif err != nil {\n\t\treturn err\n\t}\n\tparams.Selector = &selector\n\t_, err = f.channel.Send(\"setInputFiles\", params, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Type(selector, text string, options ...FrameTypeOptions) error {\n\t_, err := f.channel.Send(\"type\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t\t\"text\":     text,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Press(selector, key string, options ...FramePressOptions) error {\n\t_, err := f.channel.Send(\"press\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t\t\"key\":      key,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Check(selector string, options ...FrameCheckOptions) error {\n\t_, err := f.channel.Send(\"check\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Uncheck(selector string, options ...FrameUncheckOptions) error {\n\t_, err := f.channel.Send(\"uncheck\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) WaitForTimeout(timeout float64) {\n\ttime.Sleep(time.Duration(timeout) * time.Millisecond)\n}\n\nfunc (f *frameImpl) WaitForFunction(expression string, arg interface{}, options ...FrameWaitForFunctionOptions) (JSHandle, error) {\n\tvar option FrameWaitForFunctionOptions\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tresult, err := f.channel.Send(\"waitForFunction\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t\t\"timeout\":    option.Timeout,\n\t\t\"polling\":    option.Polling,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\thandle := fromChannel(result)\n\tif handle == nil {\n\t\treturn nil, nil\n\t}\n\treturn handle.(*jsHandleImpl), nil\n}\n\nfunc (f *frameImpl) Title() (string, error) {\n\ttitle, err := f.channel.Send(\"title\")\n\tif title == nil {\n\t\treturn \"\", err\n\t}\n\treturn title.(string), err\n}\n\nfunc (f *frameImpl) ChildFrames() []Frame {\n\treturn f.childFrames\n}\n\nfunc (f *frameImpl) Dblclick(selector string, options ...FrameDblclickOptions) error {\n\t_, err := f.channel.Send(\"dblclick\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Fill(selector string, value string, options ...FrameFillOptions) error {\n\t_, err := f.channel.Send(\"fill\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t\t\"value\":    value,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) Focus(selector string, options ...FrameFocusOptions) error {\n\t_, err := f.channel.Send(\"focus\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) FrameElement() (ElementHandle, error) {\n\tchannel, err := f.channel.Send(\"frameElement\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(channel).(*elementHandleImpl), nil\n}\n\nfunc (f *frameImpl) IsDetached() bool {\n\treturn f.detached\n}\n\nfunc (f *frameImpl) ParentFrame() Frame {\n\treturn f.parentFrame\n}\n\nfunc (f *frameImpl) TextContent(selector string, options ...FrameTextContentOptions) (string, error) {\n\ttextContent, err := f.channel.Send(\"textContent\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif textContent == nil {\n\t\treturn \"\", err\n\t}\n\treturn textContent.(string), err\n}\n\nfunc (f *frameImpl) Tap(selector string, options ...FrameTapOptions) error {\n\t_, err := f.channel.Send(\"tap\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) SelectOption(selector string, values SelectOptionValues, options ...FrameSelectOptionOptions) ([]string, error) {\n\topts := convertSelectOptionSet(values)\n\n\tm := make(map[string]interface{})\n\tm[\"selector\"] = selector\n\tfor k, v := range opts {\n\t\tm[k] = v\n\t}\n\tselected, err := f.channel.Send(\"selectOption\", m, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn transformToStringList(selected), nil\n}\n\nfunc (f *frameImpl) IsChecked(selector string, options ...FrameIsCheckedOptions) (bool, error) {\n\tchecked, err := f.channel.Send(\"isChecked\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn checked.(bool), nil\n}\n\nfunc (f *frameImpl) IsDisabled(selector string, options ...FrameIsDisabledOptions) (bool, error) {\n\tdisabled, err := f.channel.Send(\"isDisabled\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn disabled.(bool), nil\n}\n\nfunc (f *frameImpl) IsEditable(selector string, options ...FrameIsEditableOptions) (bool, error) {\n\teditable, err := f.channel.Send(\"isEditable\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn editable.(bool), nil\n}\n\nfunc (f *frameImpl) IsEnabled(selector string, options ...FrameIsEnabledOptions) (bool, error) {\n\tenabled, err := f.channel.Send(\"isEnabled\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn enabled.(bool), nil\n}\n\nfunc (f *frameImpl) IsHidden(selector string, options ...FrameIsHiddenOptions) (bool, error) {\n\thidden, err := f.channel.Send(\"isHidden\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn hidden.(bool), nil\n}\n\nfunc (f *frameImpl) IsVisible(selector string, options ...FrameIsVisibleOptions) (bool, error) {\n\tvisible, err := f.channel.Send(\"isVisible\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn visible.(bool), nil\n}\n\nfunc (f *frameImpl) InputValue(selector string, options ...FrameInputValueOptions) (string, error) {\n\tvalue, err := f.channel.Send(\"inputValue\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t}, options)\n\tif value == nil {\n\t\treturn \"\", err\n\t}\n\treturn value.(string), err\n}\n\nfunc (f *frameImpl) DragAndDrop(source, target string, options ...FrameDragAndDropOptions) error {\n\t_, err := f.channel.Send(\"dragAndDrop\", map[string]interface{}{\n\t\t\"source\": source,\n\t\t\"target\": target,\n\t}, options)\n\treturn err\n}\n\nfunc (f *frameImpl) SetChecked(selector string, checked bool, options ...FrameSetCheckedOptions) error {\n\tif checked {\n\t\t_, err := f.channel.Send(\"check\", map[string]interface{}{\n\t\t\t\"selector\": selector,\n\t\t}, options)\n\t\treturn err\n\t} else {\n\t\t_, err := f.channel.Send(\"uncheck\", map[string]interface{}{\n\t\t\t\"selector\": selector,\n\t\t}, options)\n\t\treturn err\n\t}\n}\n\nfunc (f *frameImpl) Locator(selector string, options ...FrameLocatorOptions) Locator {\n\tvar option LocatorLocatorOptions\n\tif len(options) == 1 {\n\t\toption = LocatorLocatorOptions(options[0])\n\t}\n\treturn newLocator(f, selector, option)\n}\n\nfunc (f *frameImpl) GetByAltText(text interface{}, options ...FrameGetByAltTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn f.Locator(getByAltTextSelector(text, exact))\n}\n\nfunc (f *frameImpl) GetByLabel(text interface{}, options ...FrameGetByLabelOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn f.Locator(getByLabelSelector(text, exact))\n}\n\nfunc (f *frameImpl) GetByPlaceholder(text interface{}, options ...FrameGetByPlaceholderOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn f.Locator(getByPlaceholderSelector(text, exact))\n}\n\nfunc (f *frameImpl) GetByRole(role AriaRole, options ...FrameGetByRoleOptions) Locator {\n\tif len(options) == 1 {\n\t\treturn f.Locator(getByRoleSelector(role, LocatorGetByRoleOptions(options[0])))\n\t}\n\treturn f.Locator(getByRoleSelector(role))\n}\n\nfunc (f *frameImpl) GetByTestId(testId interface{}) Locator {\n\treturn f.Locator(getByTestIdSelector(getTestIdAttributeName(), testId))\n}\n\nfunc (f *frameImpl) GetByText(text interface{}, options ...FrameGetByTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn f.Locator(getByTextSelector(text, exact))\n}\n\nfunc (f *frameImpl) GetByTitle(text interface{}, options ...FrameGetByTitleOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn f.Locator(getByTitleSelector(text, exact))\n}\n\nfunc (f *frameImpl) FrameLocator(selector string) FrameLocator {\n\treturn newFrameLocator(f, selector)\n}\n\nfunc (f *frameImpl) highlight(selector string) error {\n\t_, err := f.channel.Send(\"highlight\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t})\n\treturn err\n}\n\nfunc (f *frameImpl) queryCount(selector string) (int, error) {\n\tresponse, err := f.channel.Send(\"queryCount\", map[string]interface{}{\n\t\t\"selector\": selector,\n\t})\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn int(response.(float64)), nil\n}\n"
        },
        {
          "name": "frame_locator.go",
          "type": "blob",
          "size": 3.419921875,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\ntype frameLocatorImpl struct {\n\tframe         *frameImpl\n\tframeSelector string\n}\n\nfunc newFrameLocator(frame *frameImpl, frameSelector string) *frameLocatorImpl {\n\treturn &frameLocatorImpl{frame: frame, frameSelector: frameSelector}\n}\n\nfunc (fl *frameLocatorImpl) First() FrameLocator {\n\treturn newFrameLocator(fl.frame, fl.frameSelector+\" >> nth=0\")\n}\n\nfunc (fl *frameLocatorImpl) FrameLocator(selector string) FrameLocator {\n\treturn newFrameLocator(fl.frame, fl.frameSelector+\" >> internal:control=enter-frame >> \"+selector)\n}\n\nfunc (fl *frameLocatorImpl) GetByAltText(text interface{}, options ...FrameLocatorGetByAltTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn fl.Locator(getByAltTextSelector(text, exact))\n}\n\nfunc (fl *frameLocatorImpl) GetByLabel(text interface{}, options ...FrameLocatorGetByLabelOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn fl.Locator(getByLabelSelector(text, exact))\n}\n\nfunc (fl *frameLocatorImpl) GetByPlaceholder(text interface{}, options ...FrameLocatorGetByPlaceholderOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn fl.Locator(getByPlaceholderSelector(text, exact))\n}\n\nfunc (fl *frameLocatorImpl) GetByRole(role AriaRole, options ...FrameLocatorGetByRoleOptions) Locator {\n\tif len(options) == 1 {\n\t\treturn fl.Locator(getByRoleSelector(role, LocatorGetByRoleOptions(options[0])))\n\t}\n\treturn fl.Locator(getByRoleSelector(role))\n}\n\nfunc (fl *frameLocatorImpl) GetByTestId(testId interface{}) Locator {\n\treturn fl.Locator(getByTestIdSelector(getTestIdAttributeName(), testId))\n}\n\nfunc (fl *frameLocatorImpl) GetByText(text interface{}, options ...FrameLocatorGetByTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn fl.Locator(getByTextSelector(text, exact))\n}\n\nfunc (fl *frameLocatorImpl) GetByTitle(text interface{}, options ...FrameLocatorGetByTitleOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn fl.Locator(getByTitleSelector(text, exact))\n}\n\nfunc (fl *frameLocatorImpl) Last() FrameLocator {\n\treturn newFrameLocator(fl.frame, fl.frameSelector+\" >> nth=-1\")\n}\n\nfunc (fl *frameLocatorImpl) Locator(selectorOrLocator interface{}, options ...FrameLocatorLocatorOptions) Locator {\n\tvar option LocatorLocatorOptions\n\tif len(options) == 1 {\n\t\toption = LocatorLocatorOptions(options[0])\n\t}\n\n\tselector, ok := selectorOrLocator.(string)\n\tif ok {\n\t\treturn newLocator(fl.frame, fl.frameSelector+\" >> internal:control=enter-frame >> \"+selector, option)\n\t}\n\tlocator, ok := selectorOrLocator.(*locatorImpl)\n\tif ok {\n\t\tif fl.frame != locator.frame {\n\t\t\tlocator.err = errors.Join(locator.err, ErrLocatorNotSameFrame)\n\t\t\treturn locator\n\t\t}\n\t\treturn newLocator(locator.frame,\n\t\t\tfmt.Sprintf(\"%s >> internal:control=enter-frame >> %s\", fl.frameSelector, locator.selector),\n\t\t\toption,\n\t\t)\n\t}\n\treturn &locatorImpl{\n\t\tframe:    fl.frame,\n\t\tselector: fl.frameSelector,\n\t\terr:      fmt.Errorf(\"invalid locator parameter: %v\", selectorOrLocator),\n\t}\n}\n\nfunc (fl *frameLocatorImpl) Nth(index int) FrameLocator {\n\treturn newFrameLocator(fl.frame, fl.frameSelector+\" >> nth=\"+strconv.Itoa(index))\n}\n\nfunc (fl *frameLocatorImpl) Owner() Locator {\n\treturn newLocator(fl.frame, fl.frameSelector)\n}\n"
        },
        {
          "name": "generated-enums.go",
          "type": "blob",
          "size": 12.7275390625,
          "content": "package playwright\n\nfunc getMixedState(in string) *MixedState {\n\tv := MixedState(in)\n\treturn &v\n}\n\ntype MixedState string\n\nvar (\n\tMixedStateOn    *MixedState = getMixedState(\"On\")\n\tMixedStateOff               = getMixedState(\"Off\")\n\tMixedStateMixed             = getMixedState(\"Mixed\")\n)\n\nfunc getElementState(in string) *ElementState {\n\tv := ElementState(in)\n\treturn &v\n}\n\ntype ElementState string\n\nvar (\n\tElementStateVisible  *ElementState = getElementState(\"visible\")\n\tElementStateHidden                 = getElementState(\"hidden\")\n\tElementStateStable                 = getElementState(\"stable\")\n\tElementStateEnabled                = getElementState(\"enabled\")\n\tElementStateDisabled               = getElementState(\"disabled\")\n\tElementStateEditable               = getElementState(\"editable\")\n)\n\nfunc getAriaRole(in string) *AriaRole {\n\tv := AriaRole(in)\n\treturn &v\n}\n\ntype AriaRole string\n\nvar (\n\tAriaRoleAlert            *AriaRole = getAriaRole(\"alert\")\n\tAriaRoleAlertdialog                = getAriaRole(\"alertdialog\")\n\tAriaRoleApplication                = getAriaRole(\"application\")\n\tAriaRoleArticle                    = getAriaRole(\"article\")\n\tAriaRoleBanner                     = getAriaRole(\"banner\")\n\tAriaRoleBlockquote                 = getAriaRole(\"blockquote\")\n\tAriaRoleButton                     = getAriaRole(\"button\")\n\tAriaRoleCaption                    = getAriaRole(\"caption\")\n\tAriaRoleCell                       = getAriaRole(\"cell\")\n\tAriaRoleCheckbox                   = getAriaRole(\"checkbox\")\n\tAriaRoleCode                       = getAriaRole(\"code\")\n\tAriaRoleColumnheader               = getAriaRole(\"columnheader\")\n\tAriaRoleCombobox                   = getAriaRole(\"combobox\")\n\tAriaRoleComplementary              = getAriaRole(\"complementary\")\n\tAriaRoleContentinfo                = getAriaRole(\"contentinfo\")\n\tAriaRoleDefinition                 = getAriaRole(\"definition\")\n\tAriaRoleDeletion                   = getAriaRole(\"deletion\")\n\tAriaRoleDialog                     = getAriaRole(\"dialog\")\n\tAriaRoleDirectory                  = getAriaRole(\"directory\")\n\tAriaRoleDocument                   = getAriaRole(\"document\")\n\tAriaRoleEmphasis                   = getAriaRole(\"emphasis\")\n\tAriaRoleFeed                       = getAriaRole(\"feed\")\n\tAriaRoleFigure                     = getAriaRole(\"figure\")\n\tAriaRoleForm                       = getAriaRole(\"form\")\n\tAriaRoleGeneric                    = getAriaRole(\"generic\")\n\tAriaRoleGrid                       = getAriaRole(\"grid\")\n\tAriaRoleGridcell                   = getAriaRole(\"gridcell\")\n\tAriaRoleGroup                      = getAriaRole(\"group\")\n\tAriaRoleHeading                    = getAriaRole(\"heading\")\n\tAriaRoleImg                        = getAriaRole(\"img\")\n\tAriaRoleInsertion                  = getAriaRole(\"insertion\")\n\tAriaRoleLink                       = getAriaRole(\"link\")\n\tAriaRoleList                       = getAriaRole(\"list\")\n\tAriaRoleListbox                    = getAriaRole(\"listbox\")\n\tAriaRoleListitem                   = getAriaRole(\"listitem\")\n\tAriaRoleLog                        = getAriaRole(\"log\")\n\tAriaRoleMain                       = getAriaRole(\"main\")\n\tAriaRoleMarquee                    = getAriaRole(\"marquee\")\n\tAriaRoleMath                       = getAriaRole(\"math\")\n\tAriaRoleMeter                      = getAriaRole(\"meter\")\n\tAriaRoleMenu                       = getAriaRole(\"menu\")\n\tAriaRoleMenubar                    = getAriaRole(\"menubar\")\n\tAriaRoleMenuitem                   = getAriaRole(\"menuitem\")\n\tAriaRoleMenuitemcheckbox           = getAriaRole(\"menuitemcheckbox\")\n\tAriaRoleMenuitemradio              = getAriaRole(\"menuitemradio\")\n\tAriaRoleNavigation                 = getAriaRole(\"navigation\")\n\tAriaRoleNone                       = getAriaRole(\"none\")\n\tAriaRoleNote                       = getAriaRole(\"note\")\n\tAriaRoleOption                     = getAriaRole(\"option\")\n\tAriaRoleParagraph                  = getAriaRole(\"paragraph\")\n\tAriaRolePresentation               = getAriaRole(\"presentation\")\n\tAriaRoleProgressbar                = getAriaRole(\"progressbar\")\n\tAriaRoleRadio                      = getAriaRole(\"radio\")\n\tAriaRoleRadiogroup                 = getAriaRole(\"radiogroup\")\n\tAriaRoleRegion                     = getAriaRole(\"region\")\n\tAriaRoleRow                        = getAriaRole(\"row\")\n\tAriaRoleRowgroup                   = getAriaRole(\"rowgroup\")\n\tAriaRoleRowheader                  = getAriaRole(\"rowheader\")\n\tAriaRoleScrollbar                  = getAriaRole(\"scrollbar\")\n\tAriaRoleSearch                     = getAriaRole(\"search\")\n\tAriaRoleSearchbox                  = getAriaRole(\"searchbox\")\n\tAriaRoleSeparator                  = getAriaRole(\"separator\")\n\tAriaRoleSlider                     = getAriaRole(\"slider\")\n\tAriaRoleSpinbutton                 = getAriaRole(\"spinbutton\")\n\tAriaRoleStatus                     = getAriaRole(\"status\")\n\tAriaRoleStrong                     = getAriaRole(\"strong\")\n\tAriaRoleSubscript                  = getAriaRole(\"subscript\")\n\tAriaRoleSuperscript                = getAriaRole(\"superscript\")\n\tAriaRoleSwitch                     = getAriaRole(\"switch\")\n\tAriaRoleTab                        = getAriaRole(\"tab\")\n\tAriaRoleTable                      = getAriaRole(\"table\")\n\tAriaRoleTablist                    = getAriaRole(\"tablist\")\n\tAriaRoleTabpanel                   = getAriaRole(\"tabpanel\")\n\tAriaRoleTerm                       = getAriaRole(\"term\")\n\tAriaRoleTextbox                    = getAriaRole(\"textbox\")\n\tAriaRoleTime                       = getAriaRole(\"time\")\n\tAriaRoleTimer                      = getAriaRole(\"timer\")\n\tAriaRoleToolbar                    = getAriaRole(\"toolbar\")\n\tAriaRoleTooltip                    = getAriaRole(\"tooltip\")\n\tAriaRoleTree                       = getAriaRole(\"tree\")\n\tAriaRoleTreegrid                   = getAriaRole(\"treegrid\")\n\tAriaRoleTreeitem                   = getAriaRole(\"treeitem\")\n)\n\nfunc getColorScheme(in string) *ColorScheme {\n\tv := ColorScheme(in)\n\treturn &v\n}\n\ntype ColorScheme string\n\nvar (\n\tColorSchemeLight        *ColorScheme = getColorScheme(\"light\")\n\tColorSchemeDark                      = getColorScheme(\"dark\")\n\tColorSchemeNoPreference              = getColorScheme(\"no-preference\")\n\tColorSchemeNoOverride                = getColorScheme(\"no-override\")\n)\n\nfunc getForcedColors(in string) *ForcedColors {\n\tv := ForcedColors(in)\n\treturn &v\n}\n\ntype ForcedColors string\n\nvar (\n\tForcedColorsActive     *ForcedColors = getForcedColors(\"active\")\n\tForcedColorsNone                     = getForcedColors(\"none\")\n\tForcedColorsNoOverride               = getForcedColors(\"no-override\")\n)\n\nfunc getHarContentPolicy(in string) *HarContentPolicy {\n\tv := HarContentPolicy(in)\n\treturn &v\n}\n\ntype HarContentPolicy string\n\nvar (\n\tHarContentPolicyOmit   *HarContentPolicy = getHarContentPolicy(\"omit\")\n\tHarContentPolicyEmbed                    = getHarContentPolicy(\"embed\")\n\tHarContentPolicyAttach                   = getHarContentPolicy(\"attach\")\n)\n\nfunc getHarMode(in string) *HarMode {\n\tv := HarMode(in)\n\treturn &v\n}\n\ntype HarMode string\n\nvar (\n\tHarModeFull    *HarMode = getHarMode(\"full\")\n\tHarModeMinimal          = getHarMode(\"minimal\")\n)\n\nfunc getReducedMotion(in string) *ReducedMotion {\n\tv := ReducedMotion(in)\n\treturn &v\n}\n\ntype ReducedMotion string\n\nvar (\n\tReducedMotionReduce       *ReducedMotion = getReducedMotion(\"reduce\")\n\tReducedMotionNoPreference                = getReducedMotion(\"no-preference\")\n\tReducedMotionNoOverride                  = getReducedMotion(\"no-override\")\n)\n\nfunc getServiceWorkerPolicy(in string) *ServiceWorkerPolicy {\n\tv := ServiceWorkerPolicy(in)\n\treturn &v\n}\n\ntype ServiceWorkerPolicy string\n\nvar (\n\tServiceWorkerPolicyAllow *ServiceWorkerPolicy = getServiceWorkerPolicy(\"allow\")\n\tServiceWorkerPolicyBlock                      = getServiceWorkerPolicy(\"block\")\n)\n\nfunc getSameSiteAttribute(in string) *SameSiteAttribute {\n\tv := SameSiteAttribute(in)\n\treturn &v\n}\n\ntype SameSiteAttribute string\n\nvar (\n\tSameSiteAttributeStrict *SameSiteAttribute = getSameSiteAttribute(\"Strict\")\n\tSameSiteAttributeLax                       = getSameSiteAttribute(\"Lax\")\n\tSameSiteAttributeNone                      = getSameSiteAttribute(\"None\")\n)\n\nfunc getHarNotFound(in string) *HarNotFound {\n\tv := HarNotFound(in)\n\treturn &v\n}\n\ntype HarNotFound string\n\nvar (\n\tHarNotFoundAbort    *HarNotFound = getHarNotFound(\"abort\")\n\tHarNotFoundFallback              = getHarNotFound(\"fallback\")\n)\n\nfunc getRouteFromHarUpdateContentPolicy(in string) *RouteFromHarUpdateContentPolicy {\n\tv := RouteFromHarUpdateContentPolicy(in)\n\treturn &v\n}\n\ntype RouteFromHarUpdateContentPolicy string\n\nvar (\n\tRouteFromHarUpdateContentPolicyEmbed  *RouteFromHarUpdateContentPolicy = getRouteFromHarUpdateContentPolicy(\"embed\")\n\tRouteFromHarUpdateContentPolicyAttach                                  = getRouteFromHarUpdateContentPolicy(\"attach\")\n)\n\nfunc getUnrouteBehavior(in string) *UnrouteBehavior {\n\tv := UnrouteBehavior(in)\n\treturn &v\n}\n\ntype UnrouteBehavior string\n\nvar (\n\tUnrouteBehaviorWait         *UnrouteBehavior = getUnrouteBehavior(\"wait\")\n\tUnrouteBehaviorIgnoreErrors                  = getUnrouteBehavior(\"ignoreErrors\")\n\tUnrouteBehaviorDefault                       = getUnrouteBehavior(\"default\")\n)\n\nfunc getMouseButton(in string) *MouseButton {\n\tv := MouseButton(in)\n\treturn &v\n}\n\ntype MouseButton string\n\nvar (\n\tMouseButtonLeft   *MouseButton = getMouseButton(\"left\")\n\tMouseButtonRight               = getMouseButton(\"right\")\n\tMouseButtonMiddle              = getMouseButton(\"middle\")\n)\n\nfunc getKeyboardModifier(in string) *KeyboardModifier {\n\tv := KeyboardModifier(in)\n\treturn &v\n}\n\ntype KeyboardModifier string\n\nvar (\n\tKeyboardModifierAlt           *KeyboardModifier = getKeyboardModifier(\"Alt\")\n\tKeyboardModifierControl                         = getKeyboardModifier(\"Control\")\n\tKeyboardModifierControlOrMeta                   = getKeyboardModifier(\"ControlOrMeta\")\n\tKeyboardModifierMeta                            = getKeyboardModifier(\"Meta\")\n\tKeyboardModifierShift                           = getKeyboardModifier(\"Shift\")\n)\n\nfunc getScreenshotAnimations(in string) *ScreenshotAnimations {\n\tv := ScreenshotAnimations(in)\n\treturn &v\n}\n\ntype ScreenshotAnimations string\n\nvar (\n\tScreenshotAnimationsDisabled *ScreenshotAnimations = getScreenshotAnimations(\"disabled\")\n\tScreenshotAnimationsAllow                          = getScreenshotAnimations(\"allow\")\n)\n\nfunc getScreenshotCaret(in string) *ScreenshotCaret {\n\tv := ScreenshotCaret(in)\n\treturn &v\n}\n\ntype ScreenshotCaret string\n\nvar (\n\tScreenshotCaretHide    *ScreenshotCaret = getScreenshotCaret(\"hide\")\n\tScreenshotCaretInitial                  = getScreenshotCaret(\"initial\")\n)\n\nfunc getScreenshotScale(in string) *ScreenshotScale {\n\tv := ScreenshotScale(in)\n\treturn &v\n}\n\ntype ScreenshotScale string\n\nvar (\n\tScreenshotScaleCss    *ScreenshotScale = getScreenshotScale(\"css\")\n\tScreenshotScaleDevice                  = getScreenshotScale(\"device\")\n)\n\nfunc getScreenshotType(in string) *ScreenshotType {\n\tv := ScreenshotType(in)\n\treturn &v\n}\n\ntype ScreenshotType string\n\nvar (\n\tScreenshotTypePng  *ScreenshotType = getScreenshotType(\"png\")\n\tScreenshotTypeJpeg                 = getScreenshotType(\"jpeg\")\n)\n\nfunc getWaitForSelectorState(in string) *WaitForSelectorState {\n\tv := WaitForSelectorState(in)\n\treturn &v\n}\n\ntype WaitForSelectorState string\n\nvar (\n\tWaitForSelectorStateAttached *WaitForSelectorState = getWaitForSelectorState(\"attached\")\n\tWaitForSelectorStateDetached                       = getWaitForSelectorState(\"detached\")\n\tWaitForSelectorStateVisible                        = getWaitForSelectorState(\"visible\")\n\tWaitForSelectorStateHidden                         = getWaitForSelectorState(\"hidden\")\n)\n\nfunc getWaitUntilState(in string) *WaitUntilState {\n\tv := WaitUntilState(in)\n\treturn &v\n}\n\ntype WaitUntilState string\n\nvar (\n\tWaitUntilStateLoad             *WaitUntilState = getWaitUntilState(\"load\")\n\tWaitUntilStateDomcontentloaded                 = getWaitUntilState(\"domcontentloaded\")\n\tWaitUntilStateNetworkidle                      = getWaitUntilState(\"networkidle\")\n\tWaitUntilStateCommit                           = getWaitUntilState(\"commit\")\n)\n\nfunc getLoadState(in string) *LoadState {\n\tv := LoadState(in)\n\treturn &v\n}\n\ntype LoadState string\n\nvar (\n\tLoadStateLoad             *LoadState = getLoadState(\"load\")\n\tLoadStateDomcontentloaded            = getLoadState(\"domcontentloaded\")\n\tLoadStateNetworkidle                 = getLoadState(\"networkidle\")\n)\n\nfunc getMedia(in string) *Media {\n\tv := Media(in)\n\treturn &v\n}\n\ntype Media string\n\nvar (\n\tMediaScreen     *Media = getMedia(\"screen\")\n\tMediaPrint             = getMedia(\"print\")\n\tMediaNoOverride        = getMedia(\"no-override\")\n)\n\nfunc getHttpCredentialsSend(in string) *HttpCredentialsSend {\n\tv := HttpCredentialsSend(in)\n\treturn &v\n}\n\ntype HttpCredentialsSend string\n\nvar (\n\tHttpCredentialsSendUnauthorized *HttpCredentialsSend = getHttpCredentialsSend(\"unauthorized\")\n\tHttpCredentialsSendAlways                            = getHttpCredentialsSend(\"always\")\n)\n"
        },
        {
          "name": "generated-interfaces.go",
          "type": "blob",
          "size": 240.033203125,
          "content": "package playwright\n\n// Exposes API that can be used for the Web API testing. This class is used for creating [APIRequestContext] instance\n// which in turn can be used for sending web requests. An instance of this class can be obtained via\n// [Playwright.Request]. For more information see [APIRequestContext].\ntype APIRequest interface {\n\t// Creates new instances of [APIRequestContext].\n\tNewContext(options ...APIRequestNewContextOptions) (APIRequestContext, error)\n}\n\n// This API is used for the Web API testing. You can use it to trigger API endpoints, configure micro-services,\n// prepare environment or the service to your e2e test.\n// Each Playwright browser context has associated with it [APIRequestContext] instance which shares cookie storage\n// with the browser context and can be accessed via [BrowserContext.Request] or [Page.Request]. It is also possible to\n// create a new APIRequestContext instance manually by calling [APIRequest.NewContext].\n// **Cookie management**\n// [APIRequestContext] returned by [BrowserContext.Request] and [Page.Request] shares cookie storage with the\n// corresponding [BrowserContext]. Each API request will have `Cookie` header populated with the values from the\n// browser context. If the API response contains `Set-Cookie` header it will automatically update [BrowserContext]\n// cookies and requests made from the page will pick them up. This means that if you log in using this API, your e2e\n// test will be logged in and vice versa.\n// If you want API requests to not interfere with the browser cookies you should create a new [APIRequestContext] by\n// calling [APIRequest.NewContext]. Such `APIRequestContext` object will have its own isolated cookie storage.\ntype APIRequestContext interface {\n\t// Sends HTTP(S) [DELETE] request and returns its\n\t// response. The method will populate request cookies from the context and update context cookies from the response.\n\t// The method will automatically follow redirects.\n\t//\n\t//  url: Target URL.\n\t//\n\t// [DELETE]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE\n\tDelete(url string, options ...APIRequestContextDeleteOptions) (APIResponse, error)\n\n\t// All responses returned by [APIRequestContext.Get] and similar methods are stored in the memory, so that you can\n\t// later call [APIResponse.Body].This method discards all its resources, calling any method on disposed\n\t// [APIRequestContext] will throw an exception.\n\tDispose(options ...APIRequestContextDisposeOptions) error\n\n\t// Sends HTTP(S) request and returns its response. The method will populate request cookies from the context and\n\t// update context cookies from the response. The method will automatically follow redirects.\n\t//\n\t//  urlOrRequest: Target URL or Request to get all parameters from.\n\tFetch(urlOrRequest interface{}, options ...APIRequestContextFetchOptions) (APIResponse, error)\n\n\t// Sends HTTP(S) [GET] request and returns its\n\t// response. The method will populate request cookies from the context and update context cookies from the response.\n\t// The method will automatically follow redirects.\n\t//\n\t//  url: Target URL.\n\t//\n\t// [GET]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET\n\tGet(url string, options ...APIRequestContextGetOptions) (APIResponse, error)\n\n\t// Sends HTTP(S) [HEAD] request and returns its\n\t// response. The method will populate request cookies from the context and update context cookies from the response.\n\t// The method will automatically follow redirects.\n\t//\n\t//  url: Target URL.\n\t//\n\t// [HEAD]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD\n\tHead(url string, options ...APIRequestContextHeadOptions) (APIResponse, error)\n\n\t// Sends HTTP(S) [PATCH] request and returns its\n\t// response. The method will populate request cookies from the context and update context cookies from the response.\n\t// The method will automatically follow redirects.\n\t//\n\t//  url: Target URL.\n\t//\n\t// [PATCH]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH\n\tPatch(url string, options ...APIRequestContextPatchOptions) (APIResponse, error)\n\n\t// Sends HTTP(S) [POST] request and returns its\n\t// response. The method will populate request cookies from the context and update context cookies from the response.\n\t// The method will automatically follow redirects.\n\t//\n\t//  url: Target URL.\n\t//\n\t// [POST]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST\n\tPost(url string, options ...APIRequestContextPostOptions) (APIResponse, error)\n\n\t// Sends HTTP(S) [PUT] request and returns its\n\t// response. The method will populate request cookies from the context and update context cookies from the response.\n\t// The method will automatically follow redirects.\n\t//\n\t//  url: Target URL.\n\t//\n\t// [PUT]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT\n\tPut(url string, options ...APIRequestContextPutOptions) (APIResponse, error)\n\n\t// Returns storage state for this request context, contains current cookies and local storage snapshot if it was\n\t// passed to the constructor.\n\tStorageState(path ...string) (*StorageState, error)\n}\n\n// [APIResponse] class represents responses returned by [APIRequestContext.Get] and similar methods.\ntype APIResponse interface {\n\t// Returns the buffer with response body.\n\tBody() ([]byte, error)\n\n\t// Disposes the body of this response. If not called then the body will stay in memory until the context closes.\n\tDispose() error\n\n\t// An object with all the response HTTP headers associated with this response.\n\tHeaders() map[string]string\n\n\t// An array with all the response HTTP headers associated with this response. Header names are not lower-cased.\n\t// Headers with multiple entries, such as `Set-Cookie`, appear in the array multiple times.\n\tHeadersArray() []NameValue\n\n\t// Returns the JSON representation of response body.\n\t// This method will throw if the response body is not parsable via `JSON.parse`.\n\tJSON(v interface{}) error\n\n\t// Contains a boolean stating whether the response was successful (status in the range 200-299) or not.\n\tOk() bool\n\n\t// Contains the status code of the response (e.g., 200 for a success).\n\tStatus() int\n\n\t// Contains the status text of the response (e.g. usually an \"OK\" for a success).\n\tStatusText() string\n\n\t// Returns the text representation of response body.\n\tText() (string, error)\n\n\t// Contains the URL of the response.\n\tURL() string\n}\n\n// The [APIResponseAssertions] class provides assertion methods that can be used to make assertions about the\n// [APIResponse] in the tests.\ntype APIResponseAssertions interface {\n\t// Makes the assertion check for the opposite condition. For example, this code tests that the response status is not\n\t// successful:\n\tNot() APIResponseAssertions\n\n\t// Ensures the response status code is within `200..299` range.\n\tToBeOK() error\n}\n\n// A Browser is created via [BrowserType.Launch]. An example of using a [Browser] to create a [Page]:\ntype Browser interface {\n\tEventEmitter\n\t// Emitted when Browser gets disconnected from the browser application. This might happen because of one of the\n\t// following:\n\t//  - Browser application is closed or crashed.\n\t//  - The [Browser.Close] method was called.\n\tOnDisconnected(fn func(Browser))\n\n\t// Get the browser type (chromium, firefox or webkit) that the browser belongs to.\n\tBrowserType() BrowserType\n\n\t// In case this browser is obtained using [BrowserType.Launch], closes the browser and all of its pages (if any were\n\t// opened).\n\t// In case this browser is connected to, clears all created contexts belonging to this browser and disconnects from\n\t// the browser server.\n\t// **NOTE** This is similar to force quitting the browser. Therefore, you should call [BrowserContext.Close] on any\n\t// [BrowserContext]'s you explicitly created earlier with [Browser.NewContext] **before** calling [Browser.Close].\n\t// The [Browser] object itself is considered to be disposed and cannot be used anymore.\n\tClose(options ...BrowserCloseOptions) error\n\n\t// Returns an array of all open browser contexts. In a newly created browser, this will return zero browser contexts.\n\tContexts() []BrowserContext\n\n\t// Indicates that the browser is connected.\n\tIsConnected() bool\n\n\t// **NOTE** CDP Sessions are only supported on Chromium-based browsers.\n\t// Returns the newly created browser session.\n\tNewBrowserCDPSession() (CDPSession, error)\n\n\t// Creates a new browser context. It won't share cookies/cache with other browser contexts.\n\t// **NOTE** If directly using this method to create [BrowserContext]s, it is best practice to explicitly close the\n\t// returned context via [BrowserContext.Close] when your code is done with the [BrowserContext], and before calling\n\t// [Browser.Close]. This will ensure the `context` is closed gracefully and any artifacts—like HARs and videos—are\n\t// fully flushed and saved.\n\tNewContext(options ...BrowserNewContextOptions) (BrowserContext, error)\n\n\t// Creates a new page in a new browser context. Closing this page will close the context as well.\n\t// This is a convenience API that should only be used for the single-page scenarios and short snippets. Production\n\t// code and testing frameworks should explicitly create [Browser.NewContext] followed by the [BrowserContext.NewPage]\n\t// to control their exact life times.\n\tNewPage(options ...BrowserNewPageOptions) (Page, error)\n\n\t// **NOTE** This API controls\n\t// [Chromium Tracing] which is a low-level\n\t// chromium-specific debugging tool. API to control [Playwright Tracing] could be found\n\t// [here].\n\t// You can use [Browser.StartTracing] and [Browser.StopTracing] to create a trace file that can be opened in Chrome\n\t// DevTools performance panel.\n\t//\n\t// [Chromium Tracing]: https://www.chromium.org/developers/how-tos/trace-event-profiling-tool\n\t// [Playwright Tracing]: ../trace-viewer\n\t// [here]: ./class-tracing\n\tStartTracing(options ...BrowserStartTracingOptions) error\n\n\t// **NOTE** This API controls\n\t// [Chromium Tracing] which is a low-level\n\t// chromium-specific debugging tool. API to control [Playwright Tracing] could be found\n\t// [here].\n\t// Returns the buffer with trace data.\n\t//\n\t// [Chromium Tracing]: https://www.chromium.org/developers/how-tos/trace-event-profiling-tool\n\t// [Playwright Tracing]: ../trace-viewer\n\t// [here]: ./class-tracing\n\tStopTracing() ([]byte, error)\n\n\t// Returns the browser version.\n\tVersion() string\n}\n\n// BrowserContexts provide a way to operate multiple independent browser sessions.\n// If a page opens another page, e.g. with a `window.open` call, the popup will belong to the parent page's browser\n// context.\n// Playwright allows creating isolated non-persistent browser contexts with [Browser.NewContext] method.\n// Non-persistent browser contexts don't write any browsing data to disk.\ntype BrowserContext interface {\n\tEventEmitter\n\t// **NOTE** Only works with Chromium browser's persistent context.\n\t// Emitted when new background page is created in the context.\n\tOnBackgroundPage(fn func(Page))\n\n\t// Playwright has ability to mock clock and passage of time.\n\tClock() Clock\n\n\t// Emitted when Browser context gets closed. This might happen because of one of the following:\n\t//  - Browser context is closed.\n\t//  - Browser application is closed or crashed.\n\t//  - The [Browser.Close] method was called.\n\tOnClose(fn func(BrowserContext))\n\n\t// Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`.\n\t// The arguments passed into `console.log` and the page are available on the [ConsoleMessage] event handler argument.\n\tOnConsole(fn func(ConsoleMessage))\n\n\t// Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Listener **must**\n\t// either [Dialog.Accept] or [Dialog.Dismiss] the dialog - otherwise the page will\n\t// [freeze] waiting for the dialog,\n\t// and actions like click will never finish.\n\t//\n\t// [freeze]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking\n\tOnDialog(fn func(Dialog))\n\n\t// The event is emitted when a new Page is created in the BrowserContext. The page may still be loading. The event\n\t// will also fire for popup pages. See also [Page.OnPopup] to receive events about popups relevant to a specific page.\n\t// The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a\n\t// popup with `window.open('http://example.com')`, this event will fire when the network request to\n\t// \"http://example.com\" is done and its response has started loading in the popup. If you would like to route/listen\n\t// to this network request, use [BrowserContext.Route] and [BrowserContext.OnRequest] respectively instead of similar\n\t// methods on the [Page].\n\t// **NOTE** Use [Page.WaitForLoadState] to wait until the page gets to a particular state (you should not need it in\n\t// most cases).\n\tOnPage(fn func(Page))\n\n\t// Emitted when exception is unhandled in any of the pages in this context. To listen for errors from a particular\n\t// page, use [Page.OnPageError] instead.\n\tOnWebError(fn func(WebError))\n\n\t// Emitted when a request is issued from any pages created through this context. The [request] object is read-only. To\n\t// only listen for requests from a particular page, use [Page.OnRequest].\n\t// In order to intercept and mutate requests, see [BrowserContext.Route] or [Page.Route].\n\tOnRequest(fn func(Request))\n\n\t// Emitted when a request fails, for example by timing out. To only listen for failed requests from a particular page,\n\t// use [Page.OnRequestFailed].\n\t// **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request\n\t// will complete with [BrowserContext.OnRequestFinished] event and not with [BrowserContext.OnRequestFailed].\n\tOnRequestFailed(fn func(Request))\n\n\t// Emitted when a request finishes successfully after downloading the response body. For a successful response, the\n\t// sequence of events is `request`, `response` and `requestfinished`. To listen for successful requests from a\n\t// particular page, use [Page.OnRequestFinished].\n\tOnRequestFinished(fn func(Request))\n\n\t// Emitted when [response] status and headers are received for a request. For a successful response, the sequence of\n\t// events is `request`, `response` and `requestfinished`. To listen for response events from a particular page, use\n\t// [Page.OnResponse].\n\tOnResponse(fn func(Response))\n\n\t// Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies\n\t// can be obtained via [BrowserContext.Cookies].\n\tAddCookies(cookies []OptionalCookie) error\n\n\t// Adds a script which would be evaluated in one of the following scenarios:\n\t//  - Whenever a page is created in the browser context or is navigated.\n\t//  - Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is\n\t//   evaluated in the context of the newly attached frame.\n\t// The script is evaluated after the document was created but before any of its scripts were run. This is useful to\n\t// amend the JavaScript environment, e.g. to seed `Math.random`.\n\t//\n\t//  script: Script to be evaluated in all pages in the browser context.\n\tAddInitScript(script Script) error\n\n\t// **NOTE** Background pages are only supported on Chromium-based browsers.\n\t// All existing background pages in the context.\n\tBackgroundPages() []Page\n\n\t// Returns the browser instance of the context. If it was launched as a persistent context null gets returned.\n\tBrowser() Browser\n\n\t// Removes cookies from context. Accepts optional filter.\n\tClearCookies(options ...BrowserContextClearCookiesOptions) error\n\n\t// Clears all permission overrides for the browser context.\n\tClearPermissions() error\n\n\t// Closes the browser context. All the pages that belong to the browser context will be closed.\n\t// **NOTE** The default browser context cannot be closed.\n\tClose(options ...BrowserContextCloseOptions) error\n\n\t// If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those\n\t// URLs are returned.\n\tCookies(urls ...string) ([]Cookie, error)\n\n\t// The method adds a function called “[object Object]” on the `window` object of every frame in every page in the\n\t// context. When called, the function executes “[object Object]” and returns a [Promise] which resolves to the return\n\t// value of “[object Object]”. If the “[object Object]” returns a [Promise], it will be awaited.\n\t// The first argument of the “[object Object]” function contains information about the caller: `{ browserContext:\n\t// BrowserContext, page: Page, frame: Frame }`.\n\t// See [Page.ExposeBinding] for page-only version.\n\t//\n\t// 1. name: Name of the function on the window object.\n\t// 2. binding: Callback function that will be called in the Playwright's context.\n\tExposeBinding(name string, binding BindingCallFunction, handle ...bool) error\n\n\t// The method adds a function called “[object Object]” on the `window` object of every frame in every page in the\n\t// context. When called, the function executes “[object Object]” and returns a [Promise] which resolves to the return\n\t// value of “[object Object]”.\n\t// If the “[object Object]” returns a [Promise], it will be awaited.\n\t// See [Page.ExposeFunction] for page-only version.\n\t//\n\t// 1. name: Name of the function on the window object.\n\t// 2. binding: Callback function that will be called in the Playwright's context.\n\tExposeFunction(name string, binding ExposedFunction) error\n\n\t// Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if\n\t// specified.\n\t//\n\t//  permissions: A permission or an array of permissions to grant. Permissions can be one of the following values:\n\t//    - `'accelerometer'`\n\t//    - `'accessibility-events'`\n\t//    - `'ambient-light-sensor'`\n\t//    - `'background-sync'`\n\t//    - `'camera'`\n\t//    - `'clipboard-read'`\n\t//    - `'clipboard-write'`\n\t//    - `'geolocation'`\n\t//    - `'gyroscope'`\n\t//    - `'magnetometer'`\n\t//    - `'microphone'`\n\t//    - `'midi-sysex'` (system-exclusive midi)\n\t//    - `'midi'`\n\t//    - `'notifications'`\n\t//    - `'payment-handler'`\n\t//    - `'storage-access'`\n\tGrantPermissions(permissions []string, options ...BrowserContextGrantPermissionsOptions) error\n\n\t// **NOTE** CDP sessions are only supported on Chromium-based browsers.\n\t// Returns the newly created session.\n\t//\n\t//  page: Target to create new session for. For backwards-compatibility, this parameter is named `page`, but it can be a\n\t//    `Page` or `Frame` type.\n\tNewCDPSession(page interface{}) (CDPSession, error)\n\n\t// Creates a new page in the browser context.\n\tNewPage() (Page, error)\n\n\t// Returns all open pages in the context.\n\tPages() []Page\n\n\t// API testing helper associated with this context. Requests made with this API will use context cookies.\n\tRequest() APIRequestContext\n\n\t// Routing provides the capability to modify network requests that are made by any page in the browser context. Once\n\t// route is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.\n\t// **NOTE** [BrowserContext.Route] will not intercept requests intercepted by Service Worker. See\n\t// [this] issue. We recommend disabling Service Workers when\n\t// using request interception by setting “[object Object]” to `block`.\n\t//\n\t// 1. url: A glob pattern, regex pattern or predicate receiving [URL] to match while routing. When a “[object Object]” via the\n\t//    context options was provided and the passed URL is a path, it gets merged via the\n\t//    [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor.\n\t// 2. handler: handler function to route the request.\n\t//\n\t// [this]: https://github.com/microsoft/playwright/issues/1090\n\tRoute(url interface{}, handler routeHandler, times ...int) error\n\n\t// If specified the network requests that are made in the context will be served from the HAR file. Read more about\n\t// [Replaying from HAR].\n\t// Playwright will not serve requests intercepted by Service Worker from the HAR file. See\n\t// [this] issue. We recommend disabling Service Workers when\n\t// using request interception by setting “[object Object]” to `block`.\n\t//\n\t//  har: Path to a [HAR](http://www.softwareishard.com/blog/har-12-spec) file with prerecorded network data. If `path` is a\n\t//    relative path, then it is resolved relative to the current working directory.\n\t//\n\t// [Replaying from HAR]: https://playwright.dev/docs/mock#replaying-from-har\n\t// [this]: https://github.com/microsoft/playwright/issues/1090\n\tRouteFromHAR(har string, options ...BrowserContextRouteFromHAROptions) error\n\n\t// This method allows to modify websocket connections that are made by any page in the browser context.\n\t// Note that only `WebSocket`s created after this method was called will be routed. It is recommended to call this\n\t// method before creating any pages.\n\t//\n\t// 1. url: Only WebSockets with the url matching this pattern will be routed. A string pattern can be relative to the\n\t//    “[object Object]” context option.\n\t// 2. handler: Handler function to route the WebSocket.\n\tRouteWebSocket(url interface{}, handler func(WebSocketRoute)) error\n\n\t// **NOTE** Service workers are only supported on Chromium-based browsers.\n\t// All existing service workers in the context.\n\tServiceWorkers() []Worker\n\n\t// This setting will change the default maximum navigation time for the following methods and related shortcuts:\n\t//  - [Page.GoBack]\n\t//  - [Page.GoForward]\n\t//  - [Page.Goto]\n\t//  - [Page.Reload]\n\t//  - [Page.SetContent]\n\t//  - [Page.ExpectNavigation]\n\t// **NOTE** [Page.SetDefaultNavigationTimeout] and [Page.SetDefaultTimeout] take priority over\n\t// [BrowserContext.SetDefaultNavigationTimeout].\n\t//\n\t//  timeout: Maximum navigation time in milliseconds\n\tSetDefaultNavigationTimeout(timeout float64)\n\n\t// This setting will change the default maximum time for all the methods accepting “[object Object]” option.\n\t// **NOTE** [Page.SetDefaultNavigationTimeout], [Page.SetDefaultTimeout] and\n\t// [BrowserContext.SetDefaultNavigationTimeout] take priority over [BrowserContext.SetDefaultTimeout].\n\t//\n\t//  timeout: Maximum time in milliseconds\n\tSetDefaultTimeout(timeout float64)\n\n\t// The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are\n\t// merged with page-specific extra HTTP headers set with [Page.SetExtraHTTPHeaders]. If page overrides a particular\n\t// header, page-specific header value will be used instead of the browser context header value.\n\t// **NOTE** [BrowserContext.SetExtraHTTPHeaders] does not guarantee the order of headers in the outgoing requests.\n\t//\n\t//  headers: An object containing additional HTTP headers to be sent with every request. All header values must be strings.\n\tSetExtraHTTPHeaders(headers map[string]string) error\n\n\t// Sets the context's geolocation. Passing `null` or `undefined` emulates position unavailable.\n\tSetGeolocation(geolocation *Geolocation) error\n\n\t//\n\t//  offline: Whether to emulate network being offline for the browser context.\n\tSetOffline(offline bool) error\n\n\t// Returns storage state for this browser context, contains current cookies and local storage snapshot.\n\tStorageState(path ...string) (*StorageState, error)\n\n\tTracing() Tracing\n\n\t// Removes all routes created with [BrowserContext.Route] and [BrowserContext.RouteFromHAR].\n\tUnrouteAll(options ...BrowserContextUnrouteAllOptions) error\n\n\t// Removes a route created with [BrowserContext.Route]. When “[object Object]” is not specified, removes all routes\n\t// for the “[object Object]”.\n\t//\n\t// 1. url: A glob pattern, regex pattern or predicate receiving [URL] used to register a routing with [BrowserContext.Route].\n\t// 2. handler: Optional handler function used to register a routing with [BrowserContext.Route].\n\tUnroute(url interface{}, handler ...routeHandler) error\n\n\t// Performs action and waits for a [ConsoleMessage] to be logged by in the pages in the context. If predicate is\n\t// provided, it passes [ConsoleMessage] value into the `predicate` function and waits for `predicate(message)` to\n\t// return a truthy value. Will throw an error if the page is closed before the [BrowserContext.OnConsole] event is\n\t// fired.\n\tExpectConsoleMessage(cb func() error, options ...BrowserContextExpectConsoleMessageOptions) (ConsoleMessage, error)\n\n\t// Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy\n\t// value. Will throw an error if the context closes before the event is fired. Returns the event data value.\n\t//\n\t//  event: Event name, same one would pass into `browserContext.on(event)`.\n\tExpectEvent(event string, cb func() error, options ...BrowserContextExpectEventOptions) (interface{}, error)\n\n\t// Performs action and waits for a new [Page] to be created in the context. If predicate is provided, it passes [Page]\n\t// value into the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error\n\t// if the context closes before new [Page] is created.\n\tExpectPage(cb func() error, options ...BrowserContextExpectPageOptions) (Page, error)\n\n\t// **NOTE** In most cases, you should use [BrowserContext.ExpectEvent].\n\t// Waits for given `event` to fire. If predicate is provided, it passes event's value into the `predicate` function\n\t// and waits for `predicate(event)` to return a truthy value. Will throw an error if the browser context is closed\n\t// before the `event` is fired.\n\t//\n\t//  event: Event name, same one typically passed into `*.on(event)`.\n\tWaitForEvent(event string, options ...BrowserContextWaitForEventOptions) (interface{}, error)\n}\n\n// BrowserType provides methods to launch a specific browser instance or connect to an existing one. The following is\n// a typical example of using Playwright to drive automation:\ntype BrowserType interface {\n\t// This method attaches Playwright to an existing browser instance. When connecting to another browser launched via\n\t// `BrowserType.launchServer` in Node.js, the major and minor version needs to match the client version (1.2.3 → is\n\t// compatible with 1.2.x).\n\t//\n\t//  wsEndpoint: A browser websocket endpoint to connect to.\n\tConnect(wsEndpoint string, options ...BrowserTypeConnectOptions) (Browser, error)\n\n\t// This method attaches Playwright to an existing browser instance using the Chrome DevTools Protocol.\n\t// The default browser context is accessible via [Browser.Contexts].\n\t// **NOTE** Connecting over the Chrome DevTools Protocol is only supported for Chromium-based browsers.\n\t//\n\t//  endpointURL: A CDP websocket endpoint or http url to connect to. For example `http://localhost:9222/` or\n\t//    `ws://127.0.0.1:9222/devtools/browser/387adf4c-243f-4051-a181-46798f4a46f4`.\n\tConnectOverCDP(endpointURL string, options ...BrowserTypeConnectOverCDPOptions) (Browser, error)\n\n\t// A path where Playwright expects to find a bundled browser executable.\n\tExecutablePath() string\n\n\t// Returns the browser instance.\n\t//\n\t// [Chrome Canary]: https://www.google.com/chrome/browser/canary.html\n\t// [Dev Channel]: https://www.chromium.org/getting-involved/dev-channel\n\t// [this article]: https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/\n\t// [This article]: https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md\n\tLaunch(options ...BrowserTypeLaunchOptions) (Browser, error)\n\n\t// Returns the persistent browser context instance.\n\t// Launches browser that uses persistent storage located at “[object Object]” and returns the only context. Closing\n\t// this context will automatically close the browser.\n\t//\n\t//  userDataDir: Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for\n\t//    [Chromium](https://chromium.googlesource.com/chromium/src/+/master/docs/user_data_dir.md#introduction) and\n\t//    [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options#User_Profile). Note that Chromium's\n\t//    user data directory is the **parent** directory of the \"Profile Path\" seen at `chrome://version`. Pass an empty\n\t//    string to use a temporary directory instead.\n\tLaunchPersistentContext(userDataDir string, options ...BrowserTypeLaunchPersistentContextOptions) (BrowserContext, error)\n\n\t// Returns browser name. For example: `chromium`, `webkit` or `firefox`.\n\tName() string\n}\n\n// The `CDPSession` instances are used to talk raw Chrome Devtools Protocol:\n//   - protocol methods can be called with `session.send` method.\n//   - protocol events can be subscribed to with `session.on` method.\n//\n// Useful links:\n//   - Documentation on DevTools Protocol can be found here:\n//     [DevTools Protocol Viewer].\n//   - Getting Started with DevTools Protocol:\n//     https://github.com/aslushnikov/getting-started-with-cdp/blob/master/README.md\n//\n// [DevTools Protocol Viewer]: https://chromedevtools.github.io/devtools-protocol/\ntype CDPSession interface {\n\tEventEmitter\n\t// Detaches the CDPSession from the target. Once detached, the CDPSession object won't emit any events and can't be\n\t// used to send messages.\n\tDetach() error\n\n\t//\n\t// 1. method: Protocol method name.\n\t// 2. params: Optional method parameters.\n\tSend(method string, params map[string]interface{}) (interface{}, error)\n}\n\n// Accurately simulating time-dependent behavior is essential for verifying the correctness of applications. Learn\n// more about [clock emulation].\n// Note that clock is installed for the entire [BrowserContext], so the time in all the pages and iframes is\n// controlled by the same clock.\n//\n// [clock emulation]: https://playwright.dev/docs/clock\ntype Clock interface {\n\t// Advance the clock by jumping forward in time. Only fires due timers at most once. This is equivalent to user\n\t// closing the laptop lid for a while and reopening it later, after given time.\n\t//\n\t//  ticks: Time may be the number of milliseconds to advance the clock by or a human-readable string. Valid string formats are\n\t//    \"08\" for eight seconds, \"01:00\" for one minute and \"02:34:10\" for two hours, 34 minutes and ten seconds.\n\tFastForward(ticks interface{}) error\n\n\t// Install fake implementations for the following time-related functions:\n\t//  - `Date`\n\t//  - `setTimeout`\n\t//  - `clearTimeout`\n\t//  - `setInterval`\n\t//  - `clearInterval`\n\t//  - `requestAnimationFrame`\n\t//  - `cancelAnimationFrame`\n\t//  - `requestIdleCallback`\n\t//  - `cancelIdleCallback`\n\t//  - `performance`\n\t// Fake timers are used to manually control the flow of time in tests. They allow you to advance time, fire timers,\n\t// and control the behavior of time-dependent functions. See [Clock.RunFor] and [Clock.FastForward] for more\n\t// information.\n\tInstall(options ...ClockInstallOptions) error\n\n\t// Advance the clock, firing all the time-related callbacks.\n\t//\n\t//  ticks: Time may be the number of milliseconds to advance the clock by or a human-readable string. Valid string formats are\n\t//    \"08\" for eight seconds, \"01:00\" for one minute and \"02:34:10\" for two hours, 34 minutes and ten seconds.\n\tRunFor(ticks interface{}) error\n\n\t// Advance the clock by jumping forward in time and pause the time. Once this method is called, no timers are fired\n\t// unless [Clock.RunFor], [Clock.FastForward], [Clock.PauseAt] or [Clock.Resume] is called.\n\t// Only fires due timers at most once. This is equivalent to user closing the laptop lid for a while and reopening it\n\t// at the specified time and pausing.\n\t//\n\t//  time: Time to pause at.\n\tPauseAt(time interface{}) error\n\n\t// Resumes timers. Once this method is called, time resumes flowing, timers are fired as usual.\n\tResume() error\n\n\t// Makes `Date.now` and `new Date()` return fixed fake time at all times, keeps all the timers running.\n\t// Use this method for simple scenarios where you only need to test with a predefined time. For more advanced\n\t// scenarios, use [Clock.Install] instead. Read docs on [clock emulation] to learn more.\n\t//\n\t//  time: Time to be set.\n\t//\n\t// [clock emulation]: https://playwright.dev/docs/clock\n\tSetFixedTime(time interface{}) error\n\n\t// Sets system time, but does not trigger any timers. Use this to test how the web page reacts to a time shift, for\n\t// example switching from summer to winter time, or changing time zones.\n\t//\n\t//  time: Time to be set.\n\tSetSystemTime(time interface{}) error\n}\n\n// [ConsoleMessage] objects are dispatched by page via the [Page.OnConsole] event. For each console message logged in\n// the page there will be corresponding event in the Playwright context.\ntype ConsoleMessage interface {\n\t// List of arguments passed to a `console` function call. See also [Page.OnConsole].\n\tArgs() []JSHandle\n\n\tLocation() *ConsoleMessageLocation\n\n\t// The page that produced this console message, if any.\n\tPage() Page\n\n\t// The text of the console message.\n\tText() string\n\n\t// The text of the console message.\n\tString() string\n\n\t// One of the following values: `log`, `debug`, `info`, `error`, `warning`, `dir`, `dirxml`, `table`,\n\t// `trace`, `clear`, `startGroup`, `startGroupCollapsed`, `endGroup`, `assert`, `profile`,\n\t// `profileEnd`, `count`, `timeEnd`.\n\tType() string\n}\n\n// [Dialog] objects are dispatched by page via the [Page.OnDialog] event.\n// An example of using `Dialog` class:\n// **NOTE** Dialogs are dismissed automatically, unless there is a [Page.OnDialog] listener. When listener is present,\n// it **must** either [Dialog.Accept] or [Dialog.Dismiss] the dialog - otherwise the page will\n// [freeze] waiting for the dialog,\n// and actions like click will never finish.\n//\n// [freeze]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking\ntype Dialog interface {\n\t// Returns when the dialog has been accepted.\n\tAccept(promptText ...string) error\n\n\t// If dialog is prompt, returns default prompt value. Otherwise, returns empty string.\n\tDefaultValue() string\n\n\t// Returns when the dialog has been dismissed.\n\tDismiss() error\n\n\t// A message displayed in the dialog.\n\tMessage() string\n\n\t// The page that initiated this dialog, if available.\n\tPage() Page\n\n\t// Returns dialog's type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.\n\tType() string\n}\n\n// [Download] objects are dispatched by page via the [Page.OnDownload] event.\n// All the downloaded files belonging to the browser context are deleted when the browser context is closed.\n// Download event is emitted once the download starts. Download path becomes available once download completes.\ntype Download interface {\n\t// Cancels a download. Will not fail if the download is already finished or canceled. Upon successful cancellations,\n\t// `download.failure()` would resolve to `canceled`.\n\tCancel() error\n\n\t// Deletes the downloaded file. Will wait for the download to finish if necessary.\n\tDelete() error\n\n\t// Returns download error if any. Will wait for the download to finish if necessary.\n\tFailure() error\n\n\t// Get the page that the download belongs to.\n\tPage() Page\n\n\t// Returns path to the downloaded file for a successful download, or throws for a failed/canceled download. The method\n\t// will wait for the download to finish if necessary. The method throws when connected remotely.\n\t// Note that the download's file name is a random GUID, use [Download.SuggestedFilename] to get suggested file name.\n\tPath() (string, error)\n\n\t// Copy the download to a user-specified path. It is safe to call this method while the download is still in progress.\n\t// Will wait for the download to finish if necessary.\n\t//\n\t//  path: Path where the download should be copied.\n\tSaveAs(path string) error\n\n\t// Returns suggested filename for this download. It is typically computed by the browser from the\n\t// [`Content-Disposition`] response\n\t// header or the `download` attribute. See the spec on [whatwg].\n\t// Different browsers can use different logic for computing it.\n\t//\n\t// [`Content-Disposition`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\n\t// [whatwg]: https://html.spec.whatwg.org/#downloading-resources\n\tSuggestedFilename() string\n\n\t// Returns downloaded url.\n\tURL() string\n\n\tString() string\n}\n\n//\tElementHandle represents an in-page DOM element. ElementHandles can be created with the [Page.QuerySelector]\n//\n// method.\n// **NOTE** The use of ElementHandle is discouraged, use [Locator] objects and web-first assertions instead.\n// ElementHandle prevents DOM element from garbage collection unless the handle is disposed with [JSHandle.Dispose].\n// ElementHandles are auto-disposed when their origin frame gets navigated.\n// ElementHandle instances can be used as an argument in [Page.EvalOnSelector] and [Page.Evaluate] methods.\n// The difference between the [Locator] and ElementHandle is that the ElementHandle points to a particular element,\n// while [Locator] captures the logic of how to retrieve an element.\n// In the example below, handle points to a particular DOM element on page. If that element changes text or is used by\n// React to render an entirely different component, handle is still pointing to that very DOM element. This can lead\n// to unexpected behaviors.\n// With the locator, every time the `element` is used, up-to-date DOM element is located in the page using the\n// selector. So in the snippet below, underlying DOM element is going to be located twice.\ntype ElementHandle interface {\n\tJSHandle\n\t// This method returns the bounding box of the element, or `null` if the element is not visible. The bounding box is\n\t// calculated relative to the main frame viewport - which is usually the same as the browser window.\n\t// Scrolling affects the returned bounding box, similarly to\n\t// [Element.GetBoundingClientRect].\n\t// That means `x` and/or `y` may be negative.\n\t// Elements from child frames return the bounding box relative to the main frame, unlike the\n\t// [Element.GetBoundingClientRect].\n\t// Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the\n\t// following snippet should click the center of the element.\n\t//\n\t// [Element.GetBoundingClientRect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n\t// [Element.GetBoundingClientRect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n\tBoundingBox() (*Rect, error)\n\n\t// This method checks the element by performing the following steps:\n\t//  1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already\n\t//    checked, this method returns immediately.\n\t//  2. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to click in the center of the element.\n\t//  5. Ensure that the element is now checked. If not, this method throws.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Check] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tCheck(options ...ElementHandleCheckOptions) error\n\n\t// This method clicks the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Mouse] to click in the center of the element, or the specified “[object Object]”.\n\t//  4. Wait for initiated navigations to either succeed or fail, unless “[object Object]” option is set.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Click] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tClick(options ...ElementHandleClickOptions) error\n\n\t// Returns the content frame for element handles referencing iframe nodes, or `null` otherwise\n\tContentFrame() (Frame, error)\n\n\t// This method double clicks the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Mouse] to double click in the center of the element, or the specified “[object Object]”.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.\n\t//\n\t// Deprecated: Use locator-based [Locator.Dblclick] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tDblclick(options ...ElementHandleDblclickOptions) error\n\n\t// The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the element,\n\t// `click` is dispatched. This is equivalent to calling\n\t// [element.Click()].\n\t//\n\t// Deprecated: Use locator-based [Locator.DispatchEvent] instead. Read more about [locators].\n\t//\n\t// 1. typ: DOM event type: `\"click\"`, `\"dragstart\"`, etc.\n\t// 2. eventInit: Optional event-specific initialization properties.\n\t//\n\t// [element.Click()]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click\n\t// [DeviceMotionEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent\n\t// [DeviceOrientationEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent\n\t// [DragEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent\n\t// [Event]: https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\t// [FocusEvent]: https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent\n\t// [KeyboardEvent]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent\n\t// [MouseEvent]: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n\t// [PointerEvent]: https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent\n\t// [TouchEvent]: https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent\n\t// [WheelEvent]: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent\n\t// [locators]: https://playwright.dev/docs/locators\n\tDispatchEvent(typ string, eventInit ...interface{}) error\n\n\t// Returns the return value of “[object Object]”.\n\t// The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a\n\t// first argument to “[object Object]”. If no elements match the selector, the method throws an error.\n\t// If “[object Object]” returns a [Promise], then [ElementHandle.EvalOnSelector] would wait for the promise to resolve\n\t// and return its value.\n\t//\n\t// Deprecated: This method does not wait for the element to pass actionability checks and therefore can lead to the flaky tests. Use [Locator.Evaluate], other [Locator] helper methods or web-first assertions instead.\n\t//\n\t// 1. selector: A selector to query for.\n\t// 2. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 3. arg: Optional argument to pass to “[object Object]”.\n\tEvalOnSelector(selector string, expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the return value of “[object Object]”.\n\t// The method finds all elements matching the specified selector in the `ElementHandle`'s subtree and passes an array\n\t// of matched elements as a first argument to “[object Object]”.\n\t// If “[object Object]” returns a [Promise], then [ElementHandle.EvalOnSelectorAll] would wait for the promise to\n\t// resolve and return its value.\n\t//\n\t// Deprecated: In most cases, [Locator.EvaluateAll], other [Locator] helper methods and web-first assertions do a better job.\n\t//\n\t// 1. selector: A selector to query for.\n\t// 2. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 3. arg: Optional argument to pass to “[object Object]”.\n\tEvalOnSelectorAll(selector string, expression string, arg ...interface{}) (interface{}, error)\n\n\t// This method waits for [actionability] checks, focuses the element, fills it and triggers an\n\t// `input` event after filling. Note that you can pass an empty string to clear the input field.\n\t// If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an\n\t// error. However, if the element is inside the `<label>` element that has an associated\n\t// [control], the control will be filled\n\t// instead.\n\t// To send fine-grained keyboard events, use [Locator.PressSequentially].\n\t//\n\t// Deprecated: Use locator-based [Locator.Fill] instead. Read more about [locators].\n\t//\n\t//  value: Value to set for the `<input>`, `<textarea>` or `[contenteditable]` element.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tFill(value string, options ...ElementHandleFillOptions) error\n\n\t// Calls [focus] on the element.\n\t//\n\t// Deprecated: Use locator-based [Locator.Focus] instead. Read more about [locators].\n\t//\n\t// [focus]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n\t// [locators]: https://playwright.dev/docs/locators\n\tFocus() error\n\n\t// Returns element attribute value.\n\t//\n\t// Deprecated: Use locator-based [Locator.GetAttribute] instead. Read more about [locators].\n\t//\n\t//  name: Attribute name to get the value for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tGetAttribute(name string) (string, error)\n\n\t// This method hovers over the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Mouse] to hover over the center of the element, or the specified “[object Object]”.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Hover] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tHover(options ...ElementHandleHoverOptions) error\n\n\t// Returns the `element.innerHTML`.\n\t//\n\t// Deprecated: Use locator-based [Locator.InnerHTML] instead. Read more about [locators].\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tInnerHTML() (string, error)\n\n\t// Returns the `element.innerText`.\n\t//\n\t// Deprecated: Use locator-based [Locator.InnerText] instead. Read more about [locators].\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tInnerText() (string, error)\n\n\t// Returns `input.value` for the selected `<input>` or `<textarea>` or `<select>` element.\n\t// Throws for non-input elements. However, if the element is inside the `<label>` element that has an associated\n\t// [control], returns the value of the\n\t// control.\n\t//\n\t// Deprecated: Use locator-based [Locator.InputValue] instead. Read more about [locators].\n\t//\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tInputValue(options ...ElementHandleInputValueOptions) (string, error)\n\n\t// Returns whether the element is checked. Throws if the element is not a checkbox or radio input.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsChecked] instead. Read more about [locators].\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsChecked() (bool, error)\n\n\t// Returns whether the element is disabled, the opposite of [enabled].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsDisabled] instead. Read more about [locators].\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsDisabled() (bool, error)\n\n\t// Returns whether the element is [editable].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsEditable] instead. Read more about [locators].\n\t//\n\t// [editable]: https://playwright.dev/docs/actionability#editable\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsEditable() (bool, error)\n\n\t// Returns whether the element is [enabled].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsEnabled] instead. Read more about [locators].\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsEnabled() (bool, error)\n\n\t// Returns whether the element is hidden, the opposite of [visible].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsHidden] instead. Read more about [locators].\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsHidden() (bool, error)\n\n\t// Returns whether the element is [visible].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsVisible] instead. Read more about [locators].\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsVisible() (bool, error)\n\n\t// Returns the frame containing the given element.\n\tOwnerFrame() (Frame, error)\n\n\t// Focuses the element, and then uses [Keyboard.Down] and [Keyboard.Up].\n\t// “[object Object]” can specify the intended\n\t// [keyboardEvent.Key] value or a single character\n\t// to generate the text for. A superset of the “[object Object]” values can be found\n\t// [here]. Examples of the keys are:\n\t// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t// `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`,\n\t// etc.\n\t// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`,\n\t// `ControlOrMeta`.\n\t// Holding down `Shift` will type the text that corresponds to the “[object Object]” in the upper case.\n\t// If “[object Object]” is a single character, it is case-sensitive, so the values `a` and `A` will generate different\n\t// respective texts.\n\t// Shortcuts such as `key: \"Control+o\"`, `key: \"Control++` or `key: \"Control+Shift+T\"` are supported as well. When\n\t// specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\t//\n\t// Deprecated: Use locator-based [Locator.Press] instead. Read more about [locators].\n\t//\n\t//  key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t//\n\t// [keyboardEvent.Key]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t// [here]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\t// [locators]: https://playwright.dev/docs/locators\n\tPress(key string, options ...ElementHandlePressOptions) error\n\n\t// The method finds an element matching the specified selector in the `ElementHandle`'s subtree. If no elements match\n\t// the selector, returns `null`.\n\t//\n\t// Deprecated: Use locator-based [Page.Locator] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tQuerySelector(selector string) (ElementHandle, error)\n\n\t// The method finds all elements matching the specified selector in the `ElementHandle`s subtree. If no elements match\n\t// the selector, returns empty array.\n\t//\n\t// Deprecated: Use locator-based [Page.Locator] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tQuerySelectorAll(selector string) ([]ElementHandle, error)\n\n\t// This method captures a screenshot of the page, clipped to the size and position of this particular element. If the\n\t// element is covered by other elements, it will not be actually visible on the screenshot. If the element is a\n\t// scrollable container, only the currently scrolled content will be visible on the screenshot.\n\t// This method waits for the [actionability] checks, then scrolls element into view before taking\n\t// a screenshot. If the element is detached from DOM, the method throws an error.\n\t// Returns the buffer with the captured screenshot.\n\t//\n\t// Deprecated: Use locator-based [Locator.Screenshot] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tScreenshot(options ...ElementHandleScreenshotOptions) ([]byte, error)\n\n\t// This method waits for [actionability] checks, then tries to scroll element into view, unless\n\t// it is completely visible as defined by\n\t// [IntersectionObserver]'s `ratio`.\n\t// Throws when `elementHandle` does not point to an element\n\t// [connected] to a Document or a ShadowRoot.\n\t// See [scrolling] for alternative ways to scroll.\n\t//\n\t// Deprecated: Use locator-based [Locator.ScrollIntoViewIfNeeded] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [IntersectionObserver]: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n\t// [connected]: https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n\t// [scrolling]: https://playwright.dev/docs/input#scrolling\n\t// [locators]: https://playwright.dev/docs/locators\n\tScrollIntoViewIfNeeded(options ...ElementHandleScrollIntoViewIfNeededOptions) error\n\n\t// This method waits for [actionability] checks, waits until all specified options are present in\n\t// the `<select>` element and selects these options.\n\t// If the target element is not a `<select>` element, this method throws an error. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], the control will be used\n\t// instead.\n\t// Returns the array of option values that have been successfully selected.\n\t// Triggers a `change` and `input` event once all the provided options have been selected.\n\t//\n\t// Deprecated: Use locator-based [Locator.SelectOption] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSelectOption(values SelectOptionValues, options ...ElementHandleSelectOptionOptions) ([]string, error)\n\n\t// This method waits for [actionability] checks, then focuses the element and selects all its\n\t// text content.\n\t// If the element is inside the `<label>` element that has an associated\n\t// [control], focuses and selects text in\n\t// the control instead.\n\t//\n\t// Deprecated: Use locator-based [Locator.SelectText] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSelectText(options ...ElementHandleSelectTextOptions) error\n\n\t// This method checks or unchecks an element by performing the following steps:\n\t//  1. Ensure that element is a checkbox or a radio input. If not, this method throws.\n\t//  2. If the element already has the right checked state, this method returns immediately.\n\t//  3. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  4. Scroll the element into view if needed.\n\t//  5. Use [Page.Mouse] to click in the center of the element.\n\t//  6. Ensure that the element is now checked or unchecked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.SetChecked] instead. Read more about [locators].\n\t//\n\t//  checked: Whether to check or uncheck the checkbox.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tSetChecked(checked bool, options ...ElementHandleSetCheckedOptions) error\n\n\t// Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then\n\t// they are resolved relative to the current working directory. For empty array, clears the selected files. For inputs\n\t// with a `[webkitdirectory]` attribute, only a single directory path is supported.\n\t// This method expects [ElementHandle] to point to an\n\t// [input element]. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], targets the control instead.\n\t//\n\t// Deprecated: Use locator-based [Locator.SetInputFiles] instead. Read more about [locators].\n\t//\n\t// [input element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSetInputFiles(files interface{}, options ...ElementHandleSetInputFilesOptions) error\n\n\t// This method taps the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Touchscreen] to tap the center of the element, or the specified “[object Object]”.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.\n\t//\n\t// Deprecated: Use locator-based [Locator.Tap] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tTap(options ...ElementHandleTapOptions) error\n\n\t// Returns the `node.textContent`.\n\t//\n\t// Deprecated: Use locator-based [Locator.TextContent] instead. Read more about [locators].\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tTextContent() (string, error)\n\n\t// Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the\n\t// text.\n\t// To press a special key, like `Control` or `ArrowDown`, use [ElementHandle.Press].\n\t//\n\t// Deprecated: In most cases, you should use [Locator.Fill] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [Locator.PressSequentially].\n\t//\n\t//  text: A text to type into a focused element.\n\tType(text string, options ...ElementHandleTypeOptions) error\n\n\t// This method checks the element by performing the following steps:\n\t//  1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already\n\t//    unchecked, this method returns immediately.\n\t//  2. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to click in the center of the element.\n\t//  5. Ensure that the element is now unchecked. If not, this method throws.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Uncheck] instead. Read more about [locators].\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tUncheck(options ...ElementHandleUncheckOptions) error\n\n\t// Returns when the element satisfies the “[object Object]”.\n\t// Depending on the “[object Object]” parameter, this method waits for one of the [actionability]\n\t// checks to pass. This method throws when the element is detached while waiting, unless waiting for the `\"hidden\"`\n\t// state.\n\t//  - `\"visible\"` Wait until the element is [visible].\n\t//  - `\"hidden\"` Wait until the element is [not visible] or not attached. Note that\n\t//   waiting for hidden does not throw when the element detaches.\n\t//  - `\"stable\"` Wait until the element is both [visible] and\n\t//   [stable].\n\t//  - `\"enabled\"` Wait until the element is [enabled].\n\t//  - `\"disabled\"` Wait until the element is [not enabled].\n\t//  - `\"editable\"` Wait until the element is [editable].\n\t// If the element does not satisfy the condition for the “[object Object]” milliseconds, this method will throw.\n\t//\n\t//  state: A state to wait for, see below for more details.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [not visible]: https://playwright.dev/docs/actionability#visible\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [stable]: https://playwright.dev/docs/actionability#stable\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [not enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [editable]: https://playwright.dev/docs/actionability#editable\n\tWaitForElementState(state ElementState, options ...ElementHandleWaitForElementStateOptions) error\n\n\t// Returns element specified by selector when it satisfies “[object Object]” option. Returns `null` if waiting for\n\t// `hidden` or `detached`.\n\t// Wait for the “[object Object]” relative to the element handle to satisfy “[object Object]” option (either\n\t// appear/disappear from dom, or become visible/hidden). If at the moment of calling the method “[object Object]”\n\t// already satisfies the condition, the method will return immediately. If the selector doesn't satisfy the condition\n\t// for the “[object Object]” milliseconds, the function will throw.\n\t//\n\t// Deprecated: Use web assertions that assert visibility or a locator-based [Locator.WaitFor] instead.\n\t//\n\t//  selector: A selector to query for.\n\tWaitForSelector(selector string, options ...ElementHandleWaitForSelectorOptions) (ElementHandle, error)\n}\n\n// [FileChooser] objects are dispatched by the page in the [Page.OnFileChooser] event.\ntype FileChooser interface {\n\t// Returns input element associated with this file chooser.\n\tElement() ElementHandle\n\n\t// Returns whether this file chooser accepts multiple files.\n\tIsMultiple() bool\n\n\t// Returns page this file chooser belongs to.\n\tPage() Page\n\n\t// Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths,\n\t// then they are resolved relative to the current working directory. For empty array, clears the selected files.\n\tSetFiles(files interface{}, options ...FileChooserSetFilesOptions) error\n}\n\n// At every point of time, page exposes its current frame tree via the [Page.MainFrame] and [Frame.ChildFrames]\n// methods.\n// [Frame] object's lifecycle is controlled by three events, dispatched on the page object:\n//   - [Page.OnFrameAttached] - fired when the frame gets attached to the page. A Frame can be attached to the page\n//     only once.\n//   - [Page.OnFrameNavigated] - fired when the frame commits navigation to a different URL.\n//   - [Page.OnFrameDetached] - fired when the frame gets detached from the page.  A Frame can be detached from the\n//     page only once.\n//\n// An example of dumping frame tree:\ntype Frame interface {\n\t// Returns the added tag when the script's onload fires or when the script content was injected into frame.\n\t// Adds a `<script>` tag into the page with the desired url or content.\n\tAddScriptTag(options FrameAddScriptTagOptions) (ElementHandle, error)\n\n\t// Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.\n\t// Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or a `<style type=\"text/css\">` tag with the\n\t// content.\n\tAddStyleTag(options FrameAddStyleTagOptions) (ElementHandle, error)\n\n\t// This method checks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is\n\t//    already checked, this method returns immediately.\n\t//  3. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  4. Scroll the element into view if needed.\n\t//  5. Use [Page.Mouse] to click in the center of the element.\n\t//  6. Ensure that the element is now checked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Check] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tCheck(selector string, options ...FrameCheckOptions) error\n\n\tChildFrames() []Frame\n\n\t// This method clicks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to click in the center of the element, or the specified “[object Object]”.\n\t//  5. Wait for initiated navigations to either succeed or fail, unless “[object Object]” option is set.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Click] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tClick(selector string, options ...FrameClickOptions) error\n\n\t// Gets the full HTML contents of the frame, including the doctype.\n\tContent() (string, error)\n\n\t// This method double clicks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to double click in the center of the element, or the specified “[object Object]”. if the\n\t//    first click of the `dblclick()` triggers a navigation event, this method will throw.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.\n\t//\n\t// Deprecated: Use locator-based [Locator.Dblclick] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tDblclick(selector string, options ...FrameDblclickOptions) error\n\n\t// The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the element,\n\t// `click` is dispatched. This is equivalent to calling\n\t// [element.Click()].\n\t//\n\t// Deprecated: Use locator-based [Locator.DispatchEvent] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. typ: DOM event type: `\"click\"`, `\"dragstart\"`, etc.\n\t// 3. eventInit: Optional event-specific initialization properties.\n\t//\n\t// [element.Click()]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click\n\t// [DeviceMotionEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent\n\t// [DeviceOrientationEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent\n\t// [DragEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent\n\t// [Event]: https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\t// [FocusEvent]: https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent\n\t// [KeyboardEvent]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent\n\t// [MouseEvent]: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n\t// [PointerEvent]: https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent\n\t// [TouchEvent]: https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent\n\t// [WheelEvent]: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent\n\t// [locators]: https://playwright.dev/docs/locators\n\tDispatchEvent(selector string, typ string, eventInit interface{}, options ...FrameDispatchEventOptions) error\n\n\t//\n\t// 1. source: A selector to search for an element to drag. If there are multiple elements satisfying the selector, the first will\n\t//    be used.\n\t// 2. target: A selector to search for an element to drop onto. If there are multiple elements satisfying the selector, the first\n\t//    will be used.\n\tDragAndDrop(source string, target string, options ...FrameDragAndDropOptions) error\n\n\t// Returns the return value of “[object Object]”.\n\t// The method finds an element matching the specified selector within the frame and passes it as a first argument to\n\t// “[object Object]”. If no elements match the selector, the method throws an error.\n\t// If “[object Object]” returns a [Promise], then [Frame.EvalOnSelector] would wait for the promise to resolve and\n\t// return its value.\n\t//\n\t// Deprecated: This method does not wait for the element to pass the actionability checks and therefore can lead to the flaky tests. Use [Locator.Evaluate], other [Locator] helper methods or web-first assertions instead.\n\t//\n\t// 1. selector: A selector to query for.\n\t// 2. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 3. arg: Optional argument to pass to “[object Object]”.\n\tEvalOnSelector(selector string, expression string, arg interface{}, options ...FrameEvalOnSelectorOptions) (interface{}, error)\n\n\t// Returns the return value of “[object Object]”.\n\t// The method finds all elements matching the specified selector within the frame and passes an array of matched\n\t// elements as a first argument to “[object Object]”.\n\t// If “[object Object]” returns a [Promise], then [Frame.EvalOnSelectorAll] would wait for the promise to resolve and\n\t// return its value.\n\t//\n\t// Deprecated: In most cases, [Locator.EvaluateAll], other [Locator] helper methods and web-first assertions do a better job.\n\t//\n\t// 1. selector: A selector to query for.\n\t// 2. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 3. arg: Optional argument to pass to “[object Object]”.\n\tEvalOnSelectorAll(selector string, expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the return value of “[object Object]”.\n\t// If the function passed to the [Frame.Evaluate] returns a [Promise], then [Frame.Evaluate] would wait for the\n\t// promise to resolve and return its value.\n\t// If the function passed to the [Frame.Evaluate] returns a non-[Serializable] value, then [Frame.Evaluate] returns\n\t// `undefined`. Playwright also supports transferring some additional values that are not serializable by `JSON`:\n\t// `-0`, `NaN`, `Infinity`, `-Infinity`.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluate(expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the return value of “[object Object]” as a [JSHandle].\n\t// The only difference between [Frame.Evaluate] and [Frame.EvaluateHandle] is that [Frame.EvaluateHandle] returns\n\t// [JSHandle].\n\t// If the function, passed to the [Frame.EvaluateHandle], returns a [Promise], then [Frame.EvaluateHandle] would wait\n\t// for the promise to resolve and return its value.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluateHandle(expression string, arg ...interface{}) (JSHandle, error)\n\n\t// This method waits for an element matching “[object Object]”, waits for [actionability] checks,\n\t// focuses the element, fills it and triggers an `input` event after filling. Note that you can pass an empty string\n\t// to clear the input field.\n\t// If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an\n\t// error. However, if the element is inside the `<label>` element that has an associated\n\t// [control], the control will be filled\n\t// instead.\n\t// To send fine-grained keyboard events, use [Locator.PressSequentially].\n\t//\n\t// Deprecated: Use locator-based [Locator.Fill] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. value: Value to fill for the `<input>`, `<textarea>` or `[contenteditable]` element.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tFill(selector string, value string, options ...FrameFillOptions) error\n\n\t// This method fetches an element with “[object Object]” and focuses it. If there's no element matching\n\t// “[object Object]”, the method waits until a matching element appears in the DOM.\n\t//\n\t// Deprecated: Use locator-based [Locator.Focus] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tFocus(selector string, options ...FrameFocusOptions) error\n\n\t// Returns the `frame` or `iframe` element handle which corresponds to this frame.\n\t// This is an inverse of [ElementHandle.ContentFrame]. Note that returned handle actually belongs to the parent frame.\n\t// This method throws an error if the frame has been detached before `frameElement()` returns.\n\tFrameElement() (ElementHandle, error)\n\n\t// When working with iframes, you can create a frame locator that will enter the iframe and allow selecting elements\n\t// in that iframe.\n\t//\n\t//  selector: A selector to use when resolving DOM element.\n\tFrameLocator(selector string) FrameLocator\n\n\t// Returns element attribute value.\n\t//\n\t// Deprecated: Use locator-based [Locator.GetAttribute] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. name: Attribute name to get the value for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tGetAttribute(selector string, name string, options ...FrameGetAttributeOptions) (string, error)\n\n\t// Allows locating elements by their alt text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByAltText(text interface{}, options ...FrameGetByAltTextOptions) Locator\n\n\t// Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the\n\t// `aria-label` attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByLabel(text interface{}, options ...FrameGetByLabelOptions) Locator\n\n\t// Allows locating input elements by the placeholder text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByPlaceholder(text interface{}, options ...FrameGetByPlaceholderOptions) Locator\n\n\t// Allows locating elements by their [ARIA role],\n\t// [ARIA attributes] and\n\t// [accessible name].\n\t//\n\t// # Details\n\t//\n\t// Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback\n\t// about the ARIA guidelines.\n\t// Many html elements have an implicitly [defined role]\n\t// that is recognized by the role selector. You can find all the\n\t// [supported roles here]. ARIA guidelines **do not recommend**\n\t// duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.\n\t//\n\t//  role: Required aria role.\n\t//\n\t// [ARIA role]: https://www.w3.org/TR/wai-aria-1.2/#roles\n\t// [ARIA attributes]: https://www.w3.org/TR/wai-aria-1.2/#aria-attributes\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [defined role]: https://w3c.github.io/html-aam/#html-element-role-mappings\n\t// [supported roles here]: https://www.w3.org/TR/wai-aria-1.2/#role_definitions\n\tGetByRole(role AriaRole, options ...FrameGetByRoleOptions) Locator\n\n\t// Locate element by the test id.\n\t//\n\t// # Details\n\t//\n\t// By default, the `data-testid` attribute is used as a test id. Use [Selectors.SetTestIdAttribute] to configure a\n\t// different test id attribute if necessary.\n\t//\n\t//  testId: Id to locate the element by.\n\tGetByTestId(testId interface{}) Locator\n\n\t// Allows locating elements that contain given text.\n\t// See also [Locator.Filter] that allows to match by another criteria, like an accessible role, and then filter by the\n\t// text content.\n\t//\n\t// # Details\n\t//\n\t// Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into\n\t// one, turns line breaks into spaces and ignores leading and trailing whitespace.\n\t// Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For\n\t// example, locating by text `\"Log in\"` matches `<input type=button value=\"Log in\">`.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByText(text interface{}, options ...FrameGetByTextOptions) Locator\n\n\t// Allows locating elements by their title attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByTitle(text interface{}, options ...FrameGetByTitleOptions) Locator\n\n\t// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of\n\t// the last redirect.\n\t// The method will throw an error if:\n\t//  - there's an SSL error (e.g. in case of self-signed certificates).\n\t//  - target URL is invalid.\n\t//  - the “[object Object]” is exceeded during navigation.\n\t//  - the remote server does not respond or is unreachable.\n\t//  - the main resource failed to load.\n\t// The method will not throw an error when any valid HTTP status code is returned by the remote server, including 404\n\t// \"Not Found\" and 500 \"Internal Server Error\".  The status code for such responses can be retrieved by calling\n\t// [Response.Status].\n\t// **NOTE** The method either throws an error or returns a main resource response. The only exceptions are navigation\n\t// to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.\n\t// **NOTE** Headless mode doesn't support navigation to a PDF document. See the\n\t// [upstream issue].\n\t//\n\t//  url: URL to navigate frame to. The url should include scheme, e.g. `https://`.\n\t//\n\t// [upstream issue]: https://bugs.chromium.org/p/chromium/issues/detail?id=761295\n\tGoto(url string, options ...FrameGotoOptions) (Response, error)\n\n\t// This method hovers over an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to hover over the center of the element, or the specified “[object Object]”.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Hover] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tHover(selector string, options ...FrameHoverOptions) error\n\n\t// Returns `element.innerHTML`.\n\t//\n\t// Deprecated: Use locator-based [Locator.InnerHTML] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tInnerHTML(selector string, options ...FrameInnerHTMLOptions) (string, error)\n\n\t// Returns `element.innerText`.\n\t//\n\t// Deprecated: Use locator-based [Locator.InnerText] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tInnerText(selector string, options ...FrameInnerTextOptions) (string, error)\n\n\t// Returns `input.value` for the selected `<input>` or `<textarea>` or `<select>` element.\n\t// Throws for non-input elements. However, if the element is inside the `<label>` element that has an associated\n\t// [control], returns the value of the\n\t// control.\n\t//\n\t// Deprecated: Use locator-based [Locator.InputValue] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tInputValue(selector string, options ...FrameInputValueOptions) (string, error)\n\n\t// Returns whether the element is checked. Throws if the element is not a checkbox or radio input.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsChecked] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsChecked(selector string, options ...FrameIsCheckedOptions) (bool, error)\n\n\t// Returns `true` if the frame has been detached, or `false` otherwise.\n\tIsDetached() bool\n\n\t// Returns whether the element is disabled, the opposite of [enabled].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsDisabled] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsDisabled(selector string, options ...FrameIsDisabledOptions) (bool, error)\n\n\t// Returns whether the element is [editable].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsEditable] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [editable]: https://playwright.dev/docs/actionability#editable\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsEditable(selector string, options ...FrameIsEditableOptions) (bool, error)\n\n\t// Returns whether the element is [enabled].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\tIsEnabled(selector string, options ...FrameIsEnabledOptions) (bool, error)\n\n\t// Returns whether the element is hidden, the opposite of [visible].  “[object Object]”\n\t// that does not match any elements is considered hidden.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsHidden] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsHidden(selector string, options ...FrameIsHiddenOptions) (bool, error)\n\n\t// Returns whether the element is [visible]. “[object Object]” that does not match any\n\t// elements is considered not visible.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsVisible] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsVisible(selector string, options ...FrameIsVisibleOptions) (bool, error)\n\n\t// The method returns an element locator that can be used to perform actions on this page / frame. Locator is resolved\n\t// to the element immediately before performing an action, so a series of actions on the same locator can in fact be\n\t// performed on different DOM elements. That would happen if the DOM structure between those actions has changed.\n\t// [Learn more about locators].\n\t// [Learn more about locators].\n\t//\n\t//  selector: A selector to use when resolving DOM element.\n\t//\n\t// [Learn more about locators]: https://playwright.dev/docs/locators\n\t// [Learn more about locators]: https://playwright.dev/docs/locators\n\tLocator(selector string, options ...FrameLocatorOptions) Locator\n\n\t// Returns frame's name attribute as specified in the tag.\n\t// If the name is empty, returns the id attribute instead.\n\t// **NOTE** This value is calculated once when the frame is created, and will not update if the attribute is changed\n\t// later.\n\tName() string\n\n\t// Returns the page containing this frame.\n\tPage() Page\n\n\t// Parent frame, if any. Detached frames and main frames return `null`.\n\tParentFrame() Frame\n\n\t// “[object Object]” can specify the intended\n\t// [keyboardEvent.Key] value or a single character\n\t// to generate the text for. A superset of the “[object Object]” values can be found\n\t// [here]. Examples of the keys are:\n\t// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t// `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`,\n\t// etc.\n\t// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`,\n\t// `ControlOrMeta`. `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.\n\t// Holding down `Shift` will type the text that corresponds to the “[object Object]” in the upper case.\n\t// If “[object Object]” is a single character, it is case-sensitive, so the values `a` and `A` will generate different\n\t// respective texts.\n\t// Shortcuts such as `key: \"Control+o\"`, `key: \"Control++` or `key: \"Control+Shift+T\"` are supported as well. When\n\t// specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\t//\n\t// Deprecated: Use locator-based [Locator.Press] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t//\n\t// [keyboardEvent.Key]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t// [here]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\t// [locators]: https://playwright.dev/docs/locators\n\tPress(selector string, key string, options ...FramePressOptions) error\n\n\t// Returns the ElementHandle pointing to the frame element.\n\t// **NOTE** The use of [ElementHandle] is discouraged, use [Locator] objects and web-first assertions instead.\n\t// The method finds an element matching the specified selector within the frame. If no elements match the selector,\n\t// returns `null`.\n\t//\n\t// Deprecated: Use locator-based [Frame.Locator] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tQuerySelector(selector string, options ...FrameQuerySelectorOptions) (ElementHandle, error)\n\n\t// Returns the ElementHandles pointing to the frame elements.\n\t// **NOTE** The use of [ElementHandle] is discouraged, use [Locator] objects instead.\n\t// The method finds all elements matching the specified selector within the frame. If no elements match the selector,\n\t// returns empty array.\n\t//\n\t// Deprecated: Use locator-based [Frame.Locator] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tQuerySelectorAll(selector string) ([]ElementHandle, error)\n\n\t// This method waits for an element matching “[object Object]”, waits for [actionability] checks,\n\t// waits until all specified options are present in the `<select>` element and selects these options.\n\t// If the target element is not a `<select>` element, this method throws an error. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], the control will be used\n\t// instead.\n\t// Returns the array of option values that have been successfully selected.\n\t// Triggers a `change` and `input` event once all the provided options have been selected.\n\t//\n\t// Deprecated: Use locator-based [Locator.SelectOption] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSelectOption(selector string, values SelectOptionValues, options ...FrameSelectOptionOptions) ([]string, error)\n\n\t// This method checks or unchecks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Ensure that matched element is a checkbox or a radio input. If not, this method throws.\n\t//  3. If the element already has the right checked state, this method returns immediately.\n\t//  4. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  5. Scroll the element into view if needed.\n\t//  6. Use [Page.Mouse] to click in the center of the element.\n\t//  7. Ensure that the element is now checked or unchecked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.SetChecked] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. checked: Whether to check or uncheck the checkbox.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tSetChecked(selector string, checked bool, options ...FrameSetCheckedOptions) error\n\n\t// This method internally calls [document.Write()],\n\t// inheriting all its specific characteristics and behaviors.\n\t//\n\t//  html: HTML markup to assign to the page.\n\t//\n\t// [document.Write()]: https://developer.mozilla.org/en-US/docs/Web/API/Document/write\n\tSetContent(html string, options ...FrameSetContentOptions) error\n\n\t// Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then\n\t// they are resolved relative to the current working directory. For empty array, clears the selected files.\n\t// This method expects “[object Object]” to point to an\n\t// [input element]. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], targets the control instead.\n\t//\n\t// Deprecated: Use locator-based [Locator.SetInputFiles] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [input element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSetInputFiles(selector string, files interface{}, options ...FrameSetInputFilesOptions) error\n\n\t// This method taps an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Touchscreen] to tap the center of the element, or the specified “[object Object]”.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.\n\t//\n\t// Deprecated: Use locator-based [Locator.Tap] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tTap(selector string, options ...FrameTapOptions) error\n\n\t// Returns `element.textContent`.\n\t//\n\t// Deprecated: Use locator-based [Locator.TextContent] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tTextContent(selector string, options ...FrameTextContentOptions) (string, error)\n\n\t// Returns the page title.\n\tTitle() (string, error)\n\n\t// Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used\n\t// to send fine-grained keyboard events. To fill values in form fields, use [Frame.Fill].\n\t// To press a special key, like `Control` or `ArrowDown`, use [Keyboard.Press].\n\t//\n\t// Deprecated: In most cases, you should use [Locator.Fill] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [Locator.PressSequentially].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. text: A text to type into a focused element.\n\tType(selector string, text string, options ...FrameTypeOptions) error\n\n\t// This method checks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is\n\t//    already unchecked, this method returns immediately.\n\t//  3. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  4. Scroll the element into view if needed.\n\t//  5. Use [Page.Mouse] to click in the center of the element.\n\t//  6. Ensure that the element is now unchecked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Uncheck] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tUncheck(selector string, options ...FrameUncheckOptions) error\n\n\t// Returns frame's url.\n\tURL() string\n\n\t// Returns when the “[object Object]” returns a truthy value, returns that value.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tWaitForFunction(expression string, arg interface{}, options ...FrameWaitForFunctionOptions) (JSHandle, error)\n\n\t// Waits for the required load state to be reached.\n\t// This returns when the frame reaches a required load state, `load` by default. The navigation must have been\n\t// committed when this method is called. If current document has already reached the required state, resolves\n\t// immediately.\n\t// **NOTE** Most of the time, this method is not needed because Playwright\n\t// [auto-waits before every action].\n\t//\n\t// [auto-waits before every action]: https://playwright.dev/docs/actionability\n\tWaitForLoadState(options ...FrameWaitForLoadStateOptions) error\n\n\t// Waits for the frame navigation and returns the main resource response. In case of multiple redirects, the\n\t// navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or\n\t// navigation due to History API usage, the navigation will resolve with `null`.\n\t//\n\t// Deprecated: This method is inherently racy, please use [Frame.WaitForURL] instead.\n\t//\n\t// [History API]: https://developer.mozilla.org/en-US/docs/Web/API/History_API\n\tExpectNavigation(cb func() error, options ...FrameExpectNavigationOptions) (Response, error)\n\n\t// Returns when element specified by selector satisfies “[object Object]” option. Returns `null` if waiting for\n\t// `hidden` or `detached`.\n\t// **NOTE** Playwright automatically waits for element to be ready before performing an action. Using [Locator]\n\t// objects and web-first assertions make the code wait-for-selector-free.\n\t// Wait for the “[object Object]” to satisfy “[object Object]” option (either appear/disappear from dom, or become\n\t// visible/hidden). If at the moment of calling the method “[object Object]” already satisfies the condition, the\n\t// method will return immediately. If the selector doesn't satisfy the condition for the “[object Object]”\n\t// milliseconds, the function will throw.\n\t//\n\t// Deprecated: Use web assertions that assert visibility or a locator-based [Locator.WaitFor] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tWaitForSelector(selector string, options ...FrameWaitForSelectorOptions) (ElementHandle, error)\n\n\t// Waits for the given “[object Object]” in milliseconds.\n\t// Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going\n\t// to be flaky. Use signals such as network events, selectors becoming visible and others instead.\n\t//\n\t// Deprecated: Never wait for timeout in production. Tests that wait for time are inherently flaky. Use [Locator] actions and web assertions that wait automatically.\n\t//\n\t//  timeout: A timeout to wait for\n\tWaitForTimeout(timeout float64)\n\n\t// Waits for the frame to navigate to the given URL.\n\t//\n\t//  url: A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation. Note that if\n\t//    the parameter is a string without wildcard characters, the method will wait for navigation to URL that is exactly\n\t//    equal to the string.\n\tWaitForURL(url interface{}, options ...FrameWaitForURLOptions) error\n}\n\n// FrameLocator represents a view to the `iframe` on the page. It captures the logic sufficient to retrieve the\n// `iframe` and locate elements in that iframe. FrameLocator can be created with either [Locator.ContentFrame],\n// [Page.FrameLocator] or [Locator.FrameLocator] method.\n// **Strictness**\n// Frame locators are strict. This means that all operations on frame locators will throw if more than one element\n// matches a given selector.\n// **Converting Locator to FrameLocator**\n// If you have a [Locator] object pointing to an `iframe` it can be converted to [FrameLocator] using\n// [Locator.ContentFrame].\n// **Converting FrameLocator to Locator**\n// If you have a [FrameLocator] object it can be converted to [Locator] pointing to the same `iframe` using\n// [FrameLocator.Owner].\ntype FrameLocator interface {\n\t// Returns locator to the first matching frame.\n\t//\n\t// Deprecated: Use [Locator.First] followed by [Locator.ContentFrame] instead.\n\tFirst() FrameLocator\n\n\t// When working with iframes, you can create a frame locator that will enter the iframe and allow selecting elements\n\t// in that iframe.\n\t//\n\t//  selector: A selector to use when resolving DOM element.\n\tFrameLocator(selector string) FrameLocator\n\n\t// Allows locating elements by their alt text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByAltText(text interface{}, options ...FrameLocatorGetByAltTextOptions) Locator\n\n\t// Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the\n\t// `aria-label` attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByLabel(text interface{}, options ...FrameLocatorGetByLabelOptions) Locator\n\n\t// Allows locating input elements by the placeholder text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByPlaceholder(text interface{}, options ...FrameLocatorGetByPlaceholderOptions) Locator\n\n\t// Allows locating elements by their [ARIA role],\n\t// [ARIA attributes] and\n\t// [accessible name].\n\t//\n\t// # Details\n\t//\n\t// Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback\n\t// about the ARIA guidelines.\n\t// Many html elements have an implicitly [defined role]\n\t// that is recognized by the role selector. You can find all the\n\t// [supported roles here]. ARIA guidelines **do not recommend**\n\t// duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.\n\t//\n\t//  role: Required aria role.\n\t//\n\t// [ARIA role]: https://www.w3.org/TR/wai-aria-1.2/#roles\n\t// [ARIA attributes]: https://www.w3.org/TR/wai-aria-1.2/#aria-attributes\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [defined role]: https://w3c.github.io/html-aam/#html-element-role-mappings\n\t// [supported roles here]: https://www.w3.org/TR/wai-aria-1.2/#role_definitions\n\tGetByRole(role AriaRole, options ...FrameLocatorGetByRoleOptions) Locator\n\n\t// Locate element by the test id.\n\t//\n\t// # Details\n\t//\n\t// By default, the `data-testid` attribute is used as a test id. Use [Selectors.SetTestIdAttribute] to configure a\n\t// different test id attribute if necessary.\n\t//\n\t//  testId: Id to locate the element by.\n\tGetByTestId(testId interface{}) Locator\n\n\t// Allows locating elements that contain given text.\n\t// See also [Locator.Filter] that allows to match by another criteria, like an accessible role, and then filter by the\n\t// text content.\n\t//\n\t// # Details\n\t//\n\t// Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into\n\t// one, turns line breaks into spaces and ignores leading and trailing whitespace.\n\t// Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For\n\t// example, locating by text `\"Log in\"` matches `<input type=button value=\"Log in\">`.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByText(text interface{}, options ...FrameLocatorGetByTextOptions) Locator\n\n\t// Allows locating elements by their title attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByTitle(text interface{}, options ...FrameLocatorGetByTitleOptions) Locator\n\n\t// Returns locator to the last matching frame.\n\t//\n\t// Deprecated: Use [Locator.Last] followed by [Locator.ContentFrame] instead.\n\tLast() FrameLocator\n\n\t// The method finds an element matching the specified selector in the locator's subtree. It also accepts filter\n\t// options, similar to [Locator.Filter] method.\n\t// [Learn more about locators].\n\t//\n\t//  selectorOrLocator: A selector or locator to use when resolving DOM element.\n\t//\n\t// [Learn more about locators]: https://playwright.dev/docs/locators\n\tLocator(selectorOrLocator interface{}, options ...FrameLocatorLocatorOptions) Locator\n\n\t// Returns locator to the n-th matching frame. It's zero based, `nth(0)` selects the first frame.\n\t//\n\t// Deprecated: Use [Locator.Nth] followed by [Locator.ContentFrame] instead.\n\tNth(index int) FrameLocator\n\n\t// Returns a [Locator] object pointing to the same `iframe` as this frame locator.\n\t// Useful when you have a [FrameLocator] object obtained somewhere, and later on would like to interact with the\n\t// `iframe` element.\n\t// For a reverse operation, use [Locator.ContentFrame].\n\tOwner() Locator\n}\n\n// JSHandle represents an in-page JavaScript object. JSHandles can be created with the [Page.EvaluateHandle] method.\n// JSHandle prevents the referenced JavaScript object being garbage collected unless the handle is exposed with\n// [JSHandle.Dispose]. JSHandles are auto-disposed when their origin frame gets navigated or the parent context gets\n// destroyed.\n// JSHandle instances can be used as an argument in [Page.EvalOnSelector], [Page.Evaluate] and [Page.EvaluateHandle]\n// methods.\ntype JSHandle interface {\n\t// Returns either `null` or the object handle itself, if the object handle is an instance of [ElementHandle].\n\tAsElement() ElementHandle\n\n\t// The `jsHandle.dispose` method stops referencing the element handle.\n\tDispose() error\n\n\t// Returns the return value of “[object Object]”.\n\t// This method passes this handle as the first argument to “[object Object]”.\n\t// If “[object Object]” returns a [Promise], then `handle.evaluate` would wait for the promise to resolve and return\n\t// its value.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluate(expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the return value of “[object Object]” as a [JSHandle].\n\t// This method passes this handle as the first argument to “[object Object]”.\n\t// The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle`\n\t// returns [JSHandle].\n\t// If the function passed to the `jsHandle.evaluateHandle` returns a [Promise], then `jsHandle.evaluateHandle` would\n\t// wait for the promise to resolve and return its value.\n\t// See [Page.EvaluateHandle] for more details.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluateHandle(expression string, arg ...interface{}) (JSHandle, error)\n\n\t// The method returns a map with **own property names** as keys and JSHandle instances for the property values.\n\tGetProperties() (map[string]JSHandle, error)\n\n\t// Fetches a single property from the referenced object.\n\t//\n\t//  propertyName: property to get\n\tGetProperty(propertyName string) (JSHandle, error)\n\n\t// Returns a JSON representation of the object. If the object has a `toJSON` function, it **will not be called**.\n\t// **NOTE** The method will return an empty JSON object if the referenced object is not stringifiable. It will throw\n\t// an error if the object has circular references.\n\tJSONValue() (interface{}, error)\n\n\tString() string\n}\n\n// Keyboard provides an api for managing a virtual keyboard. The high level api is [Keyboard.Type], which takes raw\n// characters and generates proper `keydown`, `keypress`/`input`, and `keyup` events on your page.\n// For finer control, you can use [Keyboard.Down], [Keyboard.Up], and [Keyboard.InsertText] to manually fire events as\n// if they were generated from a real keyboard.\n// An example of holding down `Shift` in order to select and delete some text:\n// An example of pressing uppercase `A`\n// An example to trigger select-all with the keyboard\ntype Keyboard interface {\n\t// Dispatches a `keydown` event.\n\t// “[object Object]” can specify the intended\n\t// [keyboardEvent.Key] value or a single character\n\t// to generate the text for. A superset of the “[object Object]” values can be found\n\t// [here]. Examples of the keys are:\n\t// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t// `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`,\n\t// etc.\n\t// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`,\n\t// `ControlOrMeta`. `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.\n\t// Holding down `Shift` will type the text that corresponds to the “[object Object]” in the upper case.\n\t// If “[object Object]” is a single character, it is case-sensitive, so the values `a` and `A` will generate different\n\t// respective texts.\n\t// If “[object Object]” is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent\n\t// with that modifier active. To release the modifier key, use [Keyboard.Up].\n\t// After the key is pressed once, subsequent calls to [Keyboard.Down] will have\n\t// [repeat] set to true. To release the key,\n\t// use [Keyboard.Up].\n\t// **NOTE** Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.\n\t//\n\t//  key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t//\n\t// [keyboardEvent.Key]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t// [here]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\t// [repeat]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat\n\tDown(key string) error\n\n\t// Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.\n\t//\n\t//  text: Sets input to the specified text value.\n\tInsertText(text string) error\n\n\t// **NOTE** In most cases, you should use [Locator.Press] instead.\n\t// “[object Object]” can specify the intended\n\t// [keyboardEvent.Key] value or a single character\n\t// to generate the text for. A superset of the “[object Object]” values can be found\n\t// [here]. Examples of the keys are:\n\t// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t// `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`,\n\t// etc.\n\t// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`,\n\t// `ControlOrMeta`. `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.\n\t// Holding down `Shift` will type the text that corresponds to the “[object Object]” in the upper case.\n\t// If “[object Object]” is a single character, it is case-sensitive, so the values `a` and `A` will generate different\n\t// respective texts.\n\t// Shortcuts such as `key: \"Control+o\"`, `key: \"Control++` or `key: \"Control+Shift+T\"` are supported as well. When\n\t// specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\t//\n\t//  key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t//\n\t// [keyboardEvent.Key]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t// [here]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\tPress(key string, options ...KeyboardPressOptions) error\n\n\t// **NOTE** In most cases, you should use [Locator.Fill] instead. You only need to press keys one by one if there is\n\t// special keyboard handling on the page - in this case use [Locator.PressSequentially].\n\t// Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.\n\t// To press a special key, like `Control` or `ArrowDown`, use [Keyboard.Press].\n\t//\n\t//  text: A text to type into a focused element.\n\tType(text string, options ...KeyboardTypeOptions) error\n\n\t// Dispatches a `keyup` event.\n\t//\n\t//  key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\tUp(key string) error\n}\n\n// Locators are the central piece of Playwright's auto-waiting and retry-ability. In a nutshell, locators represent a\n// way to find element(s) on the page at any moment. A locator can be created with the [Page.Locator] method.\n// [Learn more about locators].\n//\n// [Learn more about locators]: https://playwright.dev/docs/locators\ntype Locator interface {\n\t// When the locator points to a list of elements, this returns an array of locators, pointing to their respective\n\t// elements.\n\t// **NOTE** [Locator.All] does not wait for elements to match the locator, and instead immediately returns whatever is\n\t// present in the page.\n\t// When the list of elements changes dynamically, [Locator.All] will produce unpredictable and flaky results.\n\t// When the list of elements is stable, but loaded dynamically, wait for the full list to finish loading before\n\t// calling [Locator.All].\n\tAll() ([]Locator, error)\n\n\t// Returns an array of `node.innerText` values for all matching nodes.\n\t// **NOTE** If you need to assert text on the page, prefer [LocatorAssertions.ToHaveText] with “[object Object]”\n\t// option to avoid flakiness. See [assertions guide] for more details.\n\t//\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tAllInnerTexts() ([]string, error)\n\n\t// Returns an array of `node.textContent` values for all matching nodes.\n\t// **NOTE** If you need to assert text on the page, prefer [LocatorAssertions.ToHaveText] to avoid flakiness. See\n\t// [assertions guide] for more details.\n\t//\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tAllTextContents() ([]string, error)\n\n\t// Creates a locator that matches both this locator and the argument locator.\n\t//\n\t//  locator: Additional locator to match.\n\tAnd(locator Locator) Locator\n\n\t// Captures the aria snapshot of the given element. Read more about [aria snapshots] and\n\t// [LocatorAssertions.ToMatchAriaSnapshot] for the corresponding assertion.\n\t//\n\t// # Details\n\t//\n\t// This method captures the aria snapshot of the given element. The snapshot is a string that represents the state of\n\t// the element and its children. The snapshot can be used to assert the state of the element in the test, or to\n\t// compare it to state in the future.\n\t// The ARIA snapshot is represented using [YAML] markup language:\n\t//  - The keys of the objects are the roles and optional accessible names of the elements.\n\t//  - The values are either text content or an array of child elements.\n\t//  - Generic static text can be represented with the `text` key.\n\t// Below is the HTML markup and the respective ARIA snapshot:\n\t// ```html\n\t// <ul aria-label=\"Links\">\n\t//   <li><a href=\"/\">Home</a></li>\n\t//   <li><a href=\"/about\">About</a></li>\n\t// <ul>\n\t// ```\n\t// ```yml\n\t//  - list \"Links\":\n\t//   - listitem:\n\t//     - link \"Home\"\n\t//   - listitem:\n\t//     - link \"About\"\n\t// ```\n\t//\n\t// [aria snapshots]: https://playwright.dev/docs/aria-snapshots\n\t// [YAML]: https://yaml.org/spec/1.2.2/\n\tAriaSnapshot(options ...LocatorAriaSnapshotOptions) (string, error)\n\n\t// Calls [blur] on the element.\n\t//\n\t// [blur]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/blur\n\tBlur(options ...LocatorBlurOptions) error\n\n\t// This method returns the bounding box of the element matching the locator, or `null` if the element is not visible.\n\t// The bounding box is calculated relative to the main frame viewport - which is usually the same as the browser\n\t// window.\n\t//\n\t// # Details\n\t//\n\t// Scrolling affects the returned bounding box, similarly to\n\t// [Element.GetBoundingClientRect].\n\t// That means `x` and/or `y` may be negative.\n\t// Elements from child frames return the bounding box relative to the main frame, unlike the\n\t// [Element.GetBoundingClientRect].\n\t// Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the\n\t// following snippet should click the center of the element.\n\t//\n\t// [Element.GetBoundingClientRect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n\t// [Element.GetBoundingClientRect]: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n\tBoundingBox(options ...LocatorBoundingBoxOptions) (*Rect, error)\n\n\t// Ensure that checkbox or radio element is checked.\n\t//\n\t// # Details\n\t//\n\t// Performs the following steps:\n\t//  1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already\n\t//    checked, this method returns immediately.\n\t//  2. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to click in the center of the element.\n\t//  5. Ensure that the element is now checked. If not, this method throws.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tCheck(options ...LocatorCheckOptions) error\n\n\t// Clear the input field.\n\t//\n\t// # Details\n\t//\n\t// This method waits for [actionability] checks, focuses the element, clears it and triggers an\n\t// `input` event after clearing.\n\t// If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an\n\t// error. However, if the element is inside the `<label>` element that has an associated\n\t// [control], the control will be cleared\n\t// instead.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\tClear(options ...LocatorClearOptions) error\n\n\t// Click an element.\n\t//\n\t// # Details\n\t//\n\t// This method clicks the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Mouse] to click in the center of the element, or the specified “[object Object]”.\n\t//  4. Wait for initiated navigations to either succeed or fail, unless “[object Object]” option is set.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tClick(options ...LocatorClickOptions) error\n\n\t// Returns the number of elements matching the locator.\n\t// **NOTE** If you need to assert the number of elements on the page, prefer [LocatorAssertions.ToHaveCount] to avoid\n\t// flakiness. See [assertions guide] for more details.\n\t//\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tCount() (int, error)\n\n\t// Double-click an element.\n\t//\n\t// # Details\n\t//\n\t// This method double clicks the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Mouse] to double click in the center of the element, or the specified “[object Object]”.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `element.dblclick()` dispatches two `click` events and a single `dblclick` event.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tDblclick(options ...LocatorDblclickOptions) error\n\n\t// Programmatically dispatch an event on the matching element.\n\t//\n\t// # Details\n\t//\n\t// The snippet above dispatches the `click` event on the element. Regardless of the visibility state of the element,\n\t// `click` is dispatched. This is equivalent to calling\n\t// [element.Click()].\n\t// Under the hood, it creates an instance of an event based on the given “[object Object]”, initializes it with\n\t// “[object Object]” properties and dispatches it on the element. Events are `composed`, `cancelable` and bubble by\n\t// default.\n\t// Since “[object Object]” is event-specific, please refer to the events documentation for the lists of initial\n\t// properties:\n\t//  - [DeviceMotionEvent]\n\t//  - [DeviceOrientationEvent]\n\t//  - [DragEvent]\n\t//  - [Event]\n\t//  - [FocusEvent]\n\t//  - [KeyboardEvent]\n\t//  - [MouseEvent]\n\t//  - [PointerEvent]\n\t//  - [TouchEvent]\n\t//  - [WheelEvent]\n\t// You can also specify [JSHandle] as the property value if you want live objects to be passed into the event:\n\t//\n\t// 1. typ: DOM event type: `\"click\"`, `\"dragstart\"`, etc.\n\t// 2. eventInit: Optional event-specific initialization properties.\n\t//\n\t// [element.Click()]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click\n\t// [DeviceMotionEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent\n\t// [DeviceOrientationEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent\n\t// [DragEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent\n\t// [Event]: https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\t// [FocusEvent]: https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent\n\t// [KeyboardEvent]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent\n\t// [MouseEvent]: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n\t// [PointerEvent]: https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent\n\t// [TouchEvent]: https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent\n\t// [WheelEvent]: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent\n\tDispatchEvent(typ string, eventInit interface{}, options ...LocatorDispatchEventOptions) error\n\n\t// Drag the source element towards the target element and drop it.\n\t//\n\t// # Details\n\t//\n\t// This method drags the locator to another target locator or target position. It will first move to the source\n\t// element, perform a `mousedown`, then move to the target element or position and perform a `mouseup`.\n\t//\n\t//  target: Locator of the element to drag to.\n\tDragTo(target Locator, options ...LocatorDragToOptions) error\n\n\t// Resolves given locator to the first matching DOM element. If there are no matching elements, waits for one. If\n\t// multiple elements match the locator, throws.\n\t//\n\t// Deprecated: Always prefer using [Locator]s and web assertions over [ElementHandle]s because latter are inherently racy.\n\tElementHandle(options ...LocatorElementHandleOptions) (ElementHandle, error)\n\n\t// Resolves given locator to all matching DOM elements. If there are no matching elements, returns an empty list.\n\t//\n\t// Deprecated: Always prefer using [Locator]s and web assertions over [ElementHandle]s because latter are inherently racy.\n\tElementHandles() ([]ElementHandle, error)\n\n\t// Returns a [FrameLocator] object pointing to the same `iframe` as this locator.\n\t// Useful when you have a [Locator] object obtained somewhere, and later on would like to interact with the content\n\t// inside the frame.\n\t// For a reverse operation, use [FrameLocator.Owner].\n\tContentFrame() FrameLocator\n\n\t// Execute JavaScript code in the page, taking the matching element as an argument.\n\t//\n\t// # Details\n\t//\n\t// Returns the return value of “[object Object]”, called with the matching element as a first argument, and\n\t// “[object Object]” as a second argument.\n\t// If “[object Object]” returns a [Promise], this method will wait for the promise to resolve and return its value.\n\t// If “[object Object]” throws or rejects, this method throws.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluate(expression string, arg interface{}, options ...LocatorEvaluateOptions) (interface{}, error)\n\n\t// Execute JavaScript code in the page, taking all matching elements as an argument.\n\t//\n\t// # Details\n\t//\n\t// Returns the return value of “[object Object]”, called with an array of all matching elements as a first argument,\n\t// and “[object Object]” as a second argument.\n\t// If “[object Object]” returns a [Promise], this method will wait for the promise to resolve and return its value.\n\t// If “[object Object]” throws or rejects, this method throws.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluateAll(expression string, arg ...interface{}) (interface{}, error)\n\n\t// Execute JavaScript code in the page, taking the matching element as an argument, and return a [JSHandle] with the\n\t// result.\n\t//\n\t// # Details\n\t//\n\t// Returns the return value of “[object Object]” as a[JSHandle], called with the matching element as a first argument,\n\t// and “[object Object]” as a second argument.\n\t// The only difference between [Locator.Evaluate] and [Locator.EvaluateHandle] is that [Locator.EvaluateHandle]\n\t// returns [JSHandle].\n\t// If “[object Object]” returns a [Promise], this method will wait for the promise to resolve and return its value.\n\t// If “[object Object]” throws or rejects, this method throws.\n\t// See [Page.EvaluateHandle] for more details.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluateHandle(expression string, arg interface{}, options ...LocatorEvaluateHandleOptions) (JSHandle, error)\n\n\t// Set a value to the input field.\n\t//\n\t// # Details\n\t//\n\t// This method waits for [actionability] checks, focuses the element, fills it and triggers an\n\t// `input` event after filling. Note that you can pass an empty string to clear the input field.\n\t// If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an\n\t// error. However, if the element is inside the `<label>` element that has an associated\n\t// [control], the control will be filled\n\t// instead.\n\t// To send fine-grained keyboard events, use [Locator.PressSequentially].\n\t//\n\t//  value: Value to set for the `<input>`, `<textarea>` or `[contenteditable]` element.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\tFill(value string, options ...LocatorFillOptions) error\n\n\t// This method narrows existing locator according to the options, for example filters by text. It can be chained to\n\t// filter multiple times.\n\tFilter(options ...LocatorFilterOptions) Locator\n\n\t// Returns locator to the first matching element.\n\tFirst() Locator\n\n\t// Calls [focus] on the matching element.\n\t//\n\t// [focus]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n\tFocus(options ...LocatorFocusOptions) error\n\n\t// When working with iframes, you can create a frame locator that will enter the iframe and allow locating elements in\n\t// that iframe:\n\t//\n\t//  selector: A selector to use when resolving DOM element.\n\tFrameLocator(selector string) FrameLocator\n\n\t// Returns the matching element's attribute value.\n\t// **NOTE** If you need to assert an element's attribute, prefer [LocatorAssertions.ToHaveAttribute] to avoid\n\t// flakiness. See [assertions guide] for more details.\n\t//\n\t//  name: Attribute name to get the value for.\n\t//\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tGetAttribute(name string, options ...LocatorGetAttributeOptions) (string, error)\n\n\t// Allows locating elements by their alt text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByAltText(text interface{}, options ...LocatorGetByAltTextOptions) Locator\n\n\t// Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the\n\t// `aria-label` attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByLabel(text interface{}, options ...LocatorGetByLabelOptions) Locator\n\n\t// Allows locating input elements by the placeholder text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByPlaceholder(text interface{}, options ...LocatorGetByPlaceholderOptions) Locator\n\n\t// Allows locating elements by their [ARIA role],\n\t// [ARIA attributes] and\n\t// [accessible name].\n\t//\n\t// # Details\n\t//\n\t// Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback\n\t// about the ARIA guidelines.\n\t// Many html elements have an implicitly [defined role]\n\t// that is recognized by the role selector. You can find all the\n\t// [supported roles here]. ARIA guidelines **do not recommend**\n\t// duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.\n\t//\n\t//  role: Required aria role.\n\t//\n\t// [ARIA role]: https://www.w3.org/TR/wai-aria-1.2/#roles\n\t// [ARIA attributes]: https://www.w3.org/TR/wai-aria-1.2/#aria-attributes\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [defined role]: https://w3c.github.io/html-aam/#html-element-role-mappings\n\t// [supported roles here]: https://www.w3.org/TR/wai-aria-1.2/#role_definitions\n\tGetByRole(role AriaRole, options ...LocatorGetByRoleOptions) Locator\n\n\t// Locate element by the test id.\n\t//\n\t// # Details\n\t//\n\t// By default, the `data-testid` attribute is used as a test id. Use [Selectors.SetTestIdAttribute] to configure a\n\t// different test id attribute if necessary.\n\t//\n\t//  testId: Id to locate the element by.\n\tGetByTestId(testId interface{}) Locator\n\n\t// Allows locating elements that contain given text.\n\t// See also [Locator.Filter] that allows to match by another criteria, like an accessible role, and then filter by the\n\t// text content.\n\t//\n\t// # Details\n\t//\n\t// Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into\n\t// one, turns line breaks into spaces and ignores leading and trailing whitespace.\n\t// Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For\n\t// example, locating by text `\"Log in\"` matches `<input type=button value=\"Log in\">`.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByText(text interface{}, options ...LocatorGetByTextOptions) Locator\n\n\t// Allows locating elements by their title attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByTitle(text interface{}, options ...LocatorGetByTitleOptions) Locator\n\n\t// Highlight the corresponding element(s) on the screen. Useful for debugging, don't commit the code that uses\n\t// [Locator.Highlight].\n\tHighlight() error\n\n\t// Hover over the matching element.\n\t//\n\t// # Details\n\t//\n\t// This method hovers over the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Mouse] to hover over the center of the element, or the specified “[object Object]”.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tHover(options ...LocatorHoverOptions) error\n\n\t// Returns the [`element.innerHTML`].\n\t//\n\t// [`element.innerHTML`]: https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML\n\tInnerHTML(options ...LocatorInnerHTMLOptions) (string, error)\n\n\t// Returns the [`element.innerText`].\n\t// **NOTE** If you need to assert text on the page, prefer [LocatorAssertions.ToHaveText] with “[object Object]”\n\t// option to avoid flakiness. See [assertions guide] for more details.\n\t//\n\t// [`element.innerText`]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tInnerText(options ...LocatorInnerTextOptions) (string, error)\n\n\t// Returns the value for the matching `<input>` or `<textarea>` or `<select>` element.\n\t// **NOTE** If you need to assert input value, prefer [LocatorAssertions.ToHaveValue] to avoid flakiness. See\n\t// [assertions guide] for more details.\n\t//\n\t// # Details\n\t//\n\t// Throws elements that are not an input, textarea or a select. However, if the element is inside the `<label>`\n\t// element that has an associated\n\t// [control], returns the value of the\n\t// control.\n\t//\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\tInputValue(options ...LocatorInputValueOptions) (string, error)\n\n\t// Returns whether the element is checked. Throws if the element is not a checkbox or radio input.\n\t// **NOTE** If you need to assert that checkbox is checked, prefer [LocatorAssertions.ToBeChecked] to avoid flakiness.\n\t// See [assertions guide] for more details.\n\t//\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tIsChecked(options ...LocatorIsCheckedOptions) (bool, error)\n\n\t// Returns whether the element is disabled, the opposite of [enabled].\n\t// **NOTE** If you need to assert that an element is disabled, prefer [LocatorAssertions.ToBeDisabled] to avoid\n\t// flakiness. See [assertions guide] for more details.\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tIsDisabled(options ...LocatorIsDisabledOptions) (bool, error)\n\n\t// Returns whether the element is [editable].\n\t// **NOTE** If you need to assert that an element is editable, prefer [LocatorAssertions.ToBeEditable] to avoid\n\t// flakiness. See [assertions guide] for more details.\n\t//\n\t// [editable]: https://playwright.dev/docs/actionability#editable\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tIsEditable(options ...LocatorIsEditableOptions) (bool, error)\n\n\t// Returns whether the element is [enabled].\n\t// **NOTE** If you need to assert that an element is enabled, prefer [LocatorAssertions.ToBeEnabled] to avoid\n\t// flakiness. See [assertions guide] for more details.\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tIsEnabled(options ...LocatorIsEnabledOptions) (bool, error)\n\n\t// Returns whether the element is hidden, the opposite of [visible].\n\t// **NOTE** If you need to assert that element is hidden, prefer [LocatorAssertions.ToBeHidden] to avoid flakiness.\n\t// See [assertions guide] for more details.\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tIsHidden(options ...LocatorIsHiddenOptions) (bool, error)\n\n\t// Returns whether the element is [visible].\n\t// **NOTE** If you need to assert that element is visible, prefer [LocatorAssertions.ToBeVisible] to avoid flakiness.\n\t// See [assertions guide] for more details.\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tIsVisible(options ...LocatorIsVisibleOptions) (bool, error)\n\n\t// Returns locator to the last matching element.\n\tLast() Locator\n\n\t// The method finds an element matching the specified selector in the locator's subtree. It also accepts filter\n\t// options, similar to [Locator.Filter] method.\n\t// [Learn more about locators].\n\t//\n\t//  selectorOrLocator: A selector or locator to use when resolving DOM element.\n\t//\n\t// [Learn more about locators]: https://playwright.dev/docs/locators\n\tLocator(selectorOrLocator interface{}, options ...LocatorLocatorOptions) Locator\n\n\t// Returns locator to the n-th matching element. It's zero based, `nth(0)` selects the first element.\n\tNth(index int) Locator\n\n\t// Creates a locator matching all elements that match one or both of the two locators.\n\t// Note that when both locators match something, the resulting locator will have multiple matches and violate\n\t// [locator strictness] guidelines.\n\t//\n\t//  locator: Alternative locator to match.\n\t//\n\t// [locator strictness]: https://playwright.dev/docs/locators#strictness\n\tOr(locator Locator) Locator\n\n\t// A page this locator belongs to.\n\tPage() (Page, error)\n\n\t// Focuses the matching element and presses a combination of the keys.\n\t//\n\t// # Details\n\t//\n\t// Focuses the element, and then uses [Keyboard.Down] and [Keyboard.Up].\n\t// “[object Object]” can specify the intended\n\t// [keyboardEvent.Key] value or a single character\n\t// to generate the text for. A superset of the “[object Object]” values can be found\n\t// [here]. Examples of the keys are:\n\t// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t// `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`,\n\t// etc.\n\t// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`,\n\t// `ControlOrMeta`. `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.\n\t// Holding down `Shift` will type the text that corresponds to the “[object Object]” in the upper case.\n\t// If “[object Object]” is a single character, it is case-sensitive, so the values `a` and `A` will generate different\n\t// respective texts.\n\t// Shortcuts such as `key: \"Control+o\"`, `key: \"Control++` or `key: \"Control+Shift+T\"` are supported as well. When\n\t// specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\t//\n\t//  key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t//\n\t// [keyboardEvent.Key]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t// [here]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\tPress(key string, options ...LocatorPressOptions) error\n\n\t// **NOTE** In most cases, you should use [Locator.Fill] instead. You only need to press keys one by one if there is\n\t// special keyboard handling on the page.\n\t// Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the\n\t// text.\n\t// To press a special key, like `Control` or `ArrowDown`, use [Locator.Press].\n\t//\n\t//  text: String of characters to sequentially press into a focused element.\n\tPressSequentially(text string, options ...LocatorPressSequentiallyOptions) error\n\n\t// Take a screenshot of the element matching the locator.\n\t//\n\t// # Details\n\t//\n\t// This method captures a screenshot of the page, clipped to the size and position of a particular element matching\n\t// the locator. If the element is covered by other elements, it will not be actually visible on the screenshot. If the\n\t// element is a scrollable container, only the currently scrolled content will be visible on the screenshot.\n\t// This method waits for the [actionability] checks, then scrolls element into view before taking\n\t// a screenshot. If the element is detached from DOM, the method throws an error.\n\t// Returns the buffer with the captured screenshot.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tScreenshot(options ...LocatorScreenshotOptions) ([]byte, error)\n\n\t// This method waits for [actionability] checks, then tries to scroll element into view, unless\n\t// it is completely visible as defined by\n\t// [IntersectionObserver]'s `ratio`.\n\t// See [scrolling] for alternative ways to scroll.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [IntersectionObserver]: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n\t// [scrolling]: https://playwright.dev/docs/input#scrolling\n\tScrollIntoViewIfNeeded(options ...LocatorScrollIntoViewIfNeededOptions) error\n\n\t// Selects option or options in `<select>`.\n\t//\n\t// # Details\n\t//\n\t// This method waits for [actionability] checks, waits until all specified options are present in\n\t// the `<select>` element and selects these options.\n\t// If the target element is not a `<select>` element, this method throws an error. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], the control will be used\n\t// instead.\n\t// Returns the array of option values that have been successfully selected.\n\t// Triggers a `change` and `input` event once all the provided options have been selected.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\tSelectOption(values SelectOptionValues, options ...LocatorSelectOptionOptions) ([]string, error)\n\n\t// This method waits for [actionability] checks, then focuses the element and selects all its\n\t// text content.\n\t// If the element is inside the `<label>` element that has an associated\n\t// [control], focuses and selects text in\n\t// the control instead.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\tSelectText(options ...LocatorSelectTextOptions) error\n\n\t// Set the state of a checkbox or a radio element.\n\t//\n\t// # Details\n\t//\n\t// This method checks or unchecks an element by performing the following steps:\n\t//  1. Ensure that matched element is a checkbox or a radio input. If not, this method throws.\n\t//  2. If the element already has the right checked state, this method returns immediately.\n\t//  3. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  4. Scroll the element into view if needed.\n\t//  5. Use [Page.Mouse] to click in the center of the element.\n\t//  6. Ensure that the element is now checked or unchecked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t//  checked: Whether to check or uncheck the checkbox.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tSetChecked(checked bool, options ...LocatorSetCheckedOptions) error\n\n\t// Upload file or multiple files into `<input type=file>`. For inputs with a `[webkitdirectory]` attribute, only a\n\t// single directory path is supported.\n\t//\n\t// # Details\n\t//\n\t// Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then\n\t// they are resolved relative to the current working directory. For empty array, clears the selected files.\n\t// This method expects [Locator] to point to an\n\t// [input element]. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], targets the control instead.\n\t//\n\t// [input element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\tSetInputFiles(files interface{}, options ...LocatorSetInputFilesOptions) error\n\n\t// Perform a tap gesture on the element matching the locator.\n\t//\n\t// # Details\n\t//\n\t// This method taps the element by performing the following steps:\n\t//  1. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  2. Scroll the element into view if needed.\n\t//  3. Use [Page.Touchscreen] to tap the center of the element, or the specified “[object Object]”.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `element.tap()` requires that the `hasTouch` option of the browser context be set to true.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTap(options ...LocatorTapOptions) error\n\n\t// Returns the [`node.textContent`].\n\t// **NOTE** If you need to assert text on the page, prefer [LocatorAssertions.ToHaveText] to avoid flakiness. See\n\t// [assertions guide] for more details.\n\t//\n\t// [`node.textContent`]: https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent\n\t// [assertions guide]: https://playwright.dev/docs/test-assertions\n\tTextContent(options ...LocatorTextContentOptions) (string, error)\n\n\t// Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the\n\t// text.\n\t// To press a special key, like `Control` or `ArrowDown`, use [Locator.Press].\n\t//\n\t// Deprecated: In most cases, you should use [Locator.Fill] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [Locator.PressSequentially].\n\t//\n\t//  text: A text to type into a focused element.\n\tType(text string, options ...LocatorTypeOptions) error\n\n\t// Ensure that checkbox or radio element is unchecked.\n\t//\n\t// # Details\n\t//\n\t// This method unchecks the element by performing the following steps:\n\t//  1. Ensure that element is a checkbox or a radio input. If not, this method throws. If the element is already\n\t//    unchecked, this method returns immediately.\n\t//  2. Wait for [actionability] checks on the element, unless “[object Object]” option is set.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to click in the center of the element.\n\t//  5. Ensure that the element is now unchecked. If not, this method throws.\n\t// If the element is detached from the DOM at any moment during the action, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tUncheck(options ...LocatorUncheckOptions) error\n\n\t// Returns when element specified by locator satisfies the “[object Object]” option.\n\t// If target element already satisfies the condition, the method returns immediately. Otherwise, waits for up to\n\t// “[object Object]” milliseconds until the condition is met.\n\tWaitFor(options ...LocatorWaitForOptions) error\n\n\tErr() error\n}\n\n// The [LocatorAssertions] class provides assertion methods that can be used to make assertions about the [Locator]\n// state in the tests.\ntype LocatorAssertions interface {\n\t// Makes the assertion check for the opposite condition. For example, this code tests that the Locator doesn't contain\n\t// text `\"error\"`:\n\tNot() LocatorAssertions\n\n\t// Ensures that [Locator] points to an element that is\n\t// [connected] to a Document or a ShadowRoot.\n\t//\n\t// [connected]: https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected\n\tToBeAttached(options ...LocatorAssertionsToBeAttachedOptions) error\n\n\t// Ensures the [Locator] points to a checked input.\n\tToBeChecked(options ...LocatorAssertionsToBeCheckedOptions) error\n\n\t// Ensures the [Locator] points to a disabled element. Element is disabled if it has \"disabled\" attribute or is\n\t// disabled via\n\t// ['aria-disabled']. Note\n\t// that only native control elements such as HTML `button`, `input`, `select`, `textarea`, `option`, `optgroup` can be\n\t// disabled by setting \"disabled\" attribute. \"disabled\" attribute on other elements is ignored by the browser.\n\t//\n\t// ['aria-disabled']: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-disabled\n\tToBeDisabled(options ...LocatorAssertionsToBeDisabledOptions) error\n\n\t// Ensures the [Locator] points to an editable element.\n\tToBeEditable(options ...LocatorAssertionsToBeEditableOptions) error\n\n\t// Ensures the [Locator] points to an empty editable element or to a DOM node that has no text.\n\tToBeEmpty(options ...LocatorAssertionsToBeEmptyOptions) error\n\n\t// Ensures the [Locator] points to an enabled element.\n\tToBeEnabled(options ...LocatorAssertionsToBeEnabledOptions) error\n\n\t// Ensures the [Locator] points to a focused DOM node.\n\tToBeFocused(options ...LocatorAssertionsToBeFocusedOptions) error\n\n\t// Ensures that [Locator] either does not resolve to any DOM node, or resolves to a\n\t// [non-visible] one.\n\t//\n\t// [non-visible]: https://playwright.dev/docs/actionability#visible\n\tToBeHidden(options ...LocatorAssertionsToBeHiddenOptions) error\n\n\t// Ensures the [Locator] points to an element that intersects viewport, according to the\n\t// [intersection observer API].\n\t//\n\t// [intersection observer API]: https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n\tToBeInViewport(options ...LocatorAssertionsToBeInViewportOptions) error\n\n\t// Ensures that [Locator] points to an attached and [visible] DOM node.\n\t// To check that at least one element from the list is visible, use [Locator.First].\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\tToBeVisible(options ...LocatorAssertionsToBeVisibleOptions) error\n\n\t// Ensures the [Locator] points to an element that contains the given text. All nested elements will be considered\n\t// when computing the text content of the element. You can use regular expressions for the value as well.\n\t//\n\t// # Details\n\t//\n\t// When `expected` parameter is a string, Playwright will normalize whitespaces and line breaks both in the actual\n\t// text and in the expected string before matching. When regular expression is used, the actual text is matched as is.\n\t//\n\t//  expected: Expected substring or RegExp or a list of those.\n\tToContainText(expected interface{}, options ...LocatorAssertionsToContainTextOptions) error\n\n\t// Ensures the [Locator] points to an element with a given\n\t// [accessible description].\n\t//\n\t//  description: Expected accessible description.\n\t//\n\t// [accessible description]: https://w3c.github.io/accname/#dfn-accessible-description\n\tToHaveAccessibleDescription(description interface{}, options ...LocatorAssertionsToHaveAccessibleDescriptionOptions) error\n\n\t// Ensures the [Locator] points to an element with a given\n\t// [accessible name].\n\t//\n\t//  name: Expected accessible name.\n\t//\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\tToHaveAccessibleName(name interface{}, options ...LocatorAssertionsToHaveAccessibleNameOptions) error\n\n\t// Ensures the [Locator] points to an element with given attribute.\n\t//\n\t// 1. name: Attribute name.\n\t// 2. value: Expected attribute value.\n\tToHaveAttribute(name string, value interface{}, options ...LocatorAssertionsToHaveAttributeOptions) error\n\n\t// Ensures the [Locator] points to an element with given CSS classes. This needs to be a full match or using a relaxed\n\t// regular expression.\n\t//\n\t//  expected: Expected class or RegExp or a list of those.\n\tToHaveClass(expected interface{}, options ...LocatorAssertionsToHaveClassOptions) error\n\n\t// Ensures the [Locator] resolves to an exact number of DOM nodes.\n\t//\n\t//  count: Expected count.\n\tToHaveCount(count int, options ...LocatorAssertionsToHaveCountOptions) error\n\n\t// Ensures the [Locator] resolves to an element with the given computed CSS style.\n\t//\n\t// 1. name: CSS property name.\n\t// 2. value: CSS property value.\n\tToHaveCSS(name string, value interface{}, options ...LocatorAssertionsToHaveCSSOptions) error\n\n\t// Ensures the [Locator] points to an element with the given DOM Node ID.\n\t//\n\t//  id: Element id.\n\tToHaveId(id interface{}, options ...LocatorAssertionsToHaveIdOptions) error\n\n\t// Ensures the [Locator] points to an element with given JavaScript property. Note that this property can be of a\n\t// primitive type as well as a plain serializable JavaScript object.\n\t//\n\t// 1. name: Property name.\n\t// 2. value: Property value.\n\tToHaveJSProperty(name string, value interface{}, options ...LocatorAssertionsToHaveJSPropertyOptions) error\n\n\t// Ensures the [Locator] points to an element with a given [ARIA role].\n\t// Note that role is matched as a string, disregarding the ARIA role hierarchy. For example, asserting  a superclass\n\t// role `\"checkbox\"` on an element with a subclass role `\"switch\"` will fail.\n\t//\n\t//  role: Required aria role.\n\t//\n\t// [ARIA role]: https://www.w3.org/TR/wai-aria-1.2/#roles\n\tToHaveRole(role AriaRole, options ...LocatorAssertionsToHaveRoleOptions) error\n\n\t// Ensures the [Locator] points to an element with the given text. All nested elements will be considered when\n\t// computing the text content of the element. You can use regular expressions for the value as well.\n\t//\n\t// # Details\n\t//\n\t// When `expected` parameter is a string, Playwright will normalize whitespaces and line breaks both in the actual\n\t// text and in the expected string before matching. When regular expression is used, the actual text is matched as is.\n\t//\n\t//  expected: Expected string or RegExp or a list of those.\n\tToHaveText(expected interface{}, options ...LocatorAssertionsToHaveTextOptions) error\n\n\t// Ensures the [Locator] points to an element with the given input value. You can use regular expressions for the\n\t// value as well.\n\t//\n\t//  value: Expected value.\n\tToHaveValue(value interface{}, options ...LocatorAssertionsToHaveValueOptions) error\n\n\t// Ensures the [Locator] points to multi-select/combobox (i.e. a `select` with the `multiple` attribute) and the\n\t// specified values are selected.\n\t//\n\t//  values: Expected options currently selected.\n\tToHaveValues(values []interface{}, options ...LocatorAssertionsToHaveValuesOptions) error\n\n\t// Asserts that the target element matches the given [accessibility snapshot].\n\t//\n\t// [accessibility snapshot]: https://playwright.dev/docs/aria-snapshots\n\tToMatchAriaSnapshot(expected string, options ...LocatorAssertionsToMatchAriaSnapshotOptions) error\n}\n\n// The Mouse class operates in main-frame CSS pixels relative to the top-left corner of the viewport.\n// Every `page` object has its own Mouse, accessible with [Page.Mouse].\ntype Mouse interface {\n\t// Shortcut for [Mouse.Move], [Mouse.Down], [Mouse.Up].\n\t//\n\t// 1. x: X coordinate relative to the main frame's viewport in CSS pixels.\n\t// 2. y: Y coordinate relative to the main frame's viewport in CSS pixels.\n\tClick(x float64, y float64, options ...MouseClickOptions) error\n\n\t// Shortcut for [Mouse.Move], [Mouse.Down], [Mouse.Up], [Mouse.Down] and [Mouse.Up].\n\t//\n\t// 1. x: X coordinate relative to the main frame's viewport in CSS pixels.\n\t// 2. y: Y coordinate relative to the main frame's viewport in CSS pixels.\n\tDblclick(x float64, y float64, options ...MouseDblclickOptions) error\n\n\t// Dispatches a `mousedown` event.\n\tDown(options ...MouseDownOptions) error\n\n\t// Dispatches a `mousemove` event.\n\t//\n\t// 1. x: X coordinate relative to the main frame's viewport in CSS pixels.\n\t// 2. y: Y coordinate relative to the main frame's viewport in CSS pixels.\n\tMove(x float64, y float64, options ...MouseMoveOptions) error\n\n\t// Dispatches a `mouseup` event.\n\tUp(options ...MouseUpOptions) error\n\n\t// Dispatches a `wheel` event. This method is usually used to manually scroll the page. See\n\t// [scrolling] for alternative ways to scroll.\n\t// **NOTE** Wheel events may cause scrolling if they are not handled, and this method does not wait for the scrolling\n\t// to finish before returning.\n\t//\n\t// 1. deltaX: Pixels to scroll horizontally.\n\t// 2. deltaY: Pixels to scroll vertically.\n\t//\n\t// [scrolling]: https://playwright.dev/docs/input#scrolling\n\tWheel(deltaX float64, deltaY float64) error\n}\n\n// Page provides methods to interact with a single tab in a [Browser], or an\n// [extension background page] in Chromium. One [Browser]\n// instance might have multiple [Page] instances.\n// This example creates a page, navigates it to a URL, and then saves a screenshot:\n// The Page class emits various events (described below) which can be handled using any of Node's native\n// [`EventEmitter`] methods, such as `on`, `once` or\n// `removeListener`.\n// This example logs a message for a single page `load` event:\n// To unsubscribe from events use the `removeListener` method:\n//\n// [extension background page]: https://developer.chrome.com/extensions/background_pages\n// [`EventEmitter`]: https://nodejs.org/api/events.html#events_class_eventemitter\ntype Page interface {\n\tEventEmitter\n\t// Playwright has ability to mock clock and passage of time.\n\tClock() Clock\n\n\t// Emitted when the page closes.\n\tOnClose(fn func(Page))\n\n\t// Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`.\n\t// The arguments passed into `console.log` are available on the [ConsoleMessage] event handler argument.\n\tOnConsole(fn func(ConsoleMessage))\n\n\t// Emitted when the page crashes. Browser pages might crash if they try to allocate too much memory. When the page\n\t// crashes, ongoing and subsequent operations will throw.\n\t// The most common way to deal with crashes is to catch an exception:\n\tOnCrash(fn func(Page))\n\n\t// Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Listener **must**\n\t// either [Dialog.Accept] or [Dialog.Dismiss] the dialog - otherwise the page will\n\t// [freeze] waiting for the dialog,\n\t// and actions like click will never finish.\n\t//\n\t// [freeze]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#never_blocking\n\tOnDialog(fn func(Dialog))\n\n\t// Emitted when the JavaScript\n\t// [`DOMContentLoaded`] event is dispatched.\n\t//\n\t// [`DOMContentLoaded`]: https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded\n\tOnDOMContentLoaded(fn func(Page))\n\n\t// Emitted when attachment download started. User can access basic file operations on downloaded content via the\n\t// passed [Download] instance.\n\tOnDownload(fn func(Download))\n\n\t// Emitted when a file chooser is supposed to appear, such as after clicking the  `<input type=file>`. Playwright can\n\t// respond to it via setting the input files using [FileChooser.SetFiles] that can be uploaded after that.\n\tOnFileChooser(fn func(FileChooser))\n\n\t// Emitted when a frame is attached.\n\tOnFrameAttached(fn func(Frame))\n\n\t// Emitted when a frame is detached.\n\tOnFrameDetached(fn func(Frame))\n\n\t// Emitted when a frame is navigated to a new url.\n\tOnFrameNavigated(fn func(Frame))\n\n\t// Emitted when the JavaScript [`load`] event is dispatched.\n\t//\n\t// [`load`]: https://developer.mozilla.org/en-US/docs/Web/Events/load\n\tOnLoad(fn func(Page))\n\n\t// Emitted when an uncaught exception happens within the page.\n\tOnPageError(fn func(error))\n\n\t// Emitted when the page opens a new tab or window. This event is emitted in addition to the [BrowserContext.OnPage],\n\t// but only for popups relevant to this page.\n\t// The earliest moment that page is available is when it has navigated to the initial url. For example, when opening a\n\t// popup with `window.open('http://example.com')`, this event will fire when the network request to\n\t// \"http://example.com\" is done and its response has started loading in the popup. If you would like to route/listen\n\t// to this network request, use [BrowserContext.Route] and [BrowserContext.OnRequest] respectively instead of similar\n\t// methods on the [Page].\n\t// **NOTE** Use [Page.WaitForLoadState] to wait until the page gets to a particular state (you should not need it in\n\t// most cases).\n\tOnPopup(fn func(Page))\n\n\t// Emitted when a page issues a request. The [request] object is read-only. In order to intercept and mutate requests,\n\t// see [Page.Route] or [BrowserContext.Route].\n\tOnRequest(fn func(Request))\n\n\t// Emitted when a request fails, for example by timing out.\n\t// **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request\n\t// will complete with [Page.OnRequestFinished] event and not with [Page.OnRequestFailed]. A request will only be\n\t// considered failed when the client cannot get an HTTP response from the server, e.g. due to network error\n\t// net::ERR_FAILED.\n\tOnRequestFailed(fn func(Request))\n\n\t// Emitted when a request finishes successfully after downloading the response body. For a successful response, the\n\t// sequence of events is `request`, `response` and `requestfinished`.\n\tOnRequestFinished(fn func(Request))\n\n\t// Emitted when [response] status and headers are received for a request. For a successful response, the sequence of\n\t// events is `request`, `response` and `requestfinished`.\n\tOnResponse(fn func(Response))\n\n\t// Emitted when [WebSocket] request is sent.\n\tOnWebSocket(fn func(WebSocket))\n\n\t// Emitted when a dedicated [WebWorker] is spawned\n\t// by the page.\n\t//\n\t// [WebWorker]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n\tOnWorker(fn func(Worker))\n\n\t// Adds a script which would be evaluated in one of the following scenarios:\n\t//  - Whenever the page is navigated.\n\t//  - Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the\n\t//   newly attached frame.\n\t// The script is evaluated after the document was created but before any of its scripts were run. This is useful to\n\t// amend the JavaScript environment, e.g. to seed `Math.random`.\n\t//\n\t//  script: Script to be evaluated in the page.\n\tAddInitScript(script Script) error\n\n\t// Adds a `<script>` tag into the page with the desired url or content. Returns the added tag when the script's onload\n\t// fires or when the script content was injected into frame.\n\tAddScriptTag(options PageAddScriptTagOptions) (ElementHandle, error)\n\n\t// Adds a `<link rel=\"stylesheet\">` tag into the page with the desired url or a `<style type=\"text/css\">` tag with the\n\t// content. Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.\n\tAddStyleTag(options PageAddStyleTagOptions) (ElementHandle, error)\n\n\t// Brings page to front (activates tab).\n\tBringToFront() error\n\n\t// This method checks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is\n\t//    already checked, this method returns immediately.\n\t//  3. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  4. Scroll the element into view if needed.\n\t//  5. Use [Page.Mouse] to click in the center of the element.\n\t//  6. Ensure that the element is now checked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Check] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tCheck(selector string, options ...PageCheckOptions) error\n\n\t// This method clicks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to click in the center of the element, or the specified “[object Object]”.\n\t//  5. Wait for initiated navigations to either succeed or fail, unless “[object Object]” option is set.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Click] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tClick(selector string, options ...PageClickOptions) error\n\n\t// If “[object Object]” is `false`, does not run any unload handlers and waits for the page to be closed. If\n\t// “[object Object]” is `true` the method will run unload handlers, but will **not** wait for the page to close.\n\t// By default, `page.close()` **does not** run `beforeunload` handlers.\n\t// **NOTE** if “[object Object]” is passed as true, a `beforeunload` dialog might be summoned and should be handled\n\t// manually via [Page.OnDialog] event.\n\tClose(options ...PageCloseOptions) error\n\n\t// Gets the full HTML contents of the page, including the doctype.\n\tContent() (string, error)\n\n\t// Get the browser context that the page belongs to.\n\tContext() BrowserContext\n\n\t// This method double clicks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to double click in the center of the element, or the specified “[object Object]”.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** `page.dblclick()` dispatches two `click` events and a single `dblclick` event.\n\t//\n\t// Deprecated: Use locator-based [Locator.Dblclick] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tDblclick(selector string, options ...PageDblclickOptions) error\n\n\t// The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the element,\n\t// `click` is dispatched. This is equivalent to calling\n\t// [element.Click()].\n\t//\n\t// Deprecated: Use locator-based [Locator.DispatchEvent] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. typ: DOM event type: `\"click\"`, `\"dragstart\"`, etc.\n\t// 3. eventInit: Optional event-specific initialization properties.\n\t//\n\t// [element.Click()]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click\n\t// [DeviceMotionEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/DeviceMotionEvent\n\t// [DeviceOrientationEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/DeviceOrientationEvent\n\t// [DragEvent]: https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent\n\t// [Event]: https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\t// [FocusEvent]: https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent\n\t// [KeyboardEvent]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent\n\t// [MouseEvent]: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n\t// [PointerEvent]: https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent\n\t// [TouchEvent]: https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent\n\t// [WheelEvent]: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/WheelEvent\n\t// [locators]: https://playwright.dev/docs/locators\n\tDispatchEvent(selector string, typ string, eventInit interface{}, options ...PageDispatchEventOptions) error\n\n\t// This method drags the source element to the target element. It will first move to the source element, perform a\n\t// `mousedown`, then move to the target element and perform a `mouseup`.\n\t//\n\t// 1. source: A selector to search for an element to drag. If there are multiple elements satisfying the selector, the first will\n\t//    be used.\n\t// 2. target: A selector to search for an element to drop onto. If there are multiple elements satisfying the selector, the first\n\t//    will be used.\n\tDragAndDrop(source string, target string, options ...PageDragAndDropOptions) error\n\n\t// This method changes the `CSS media type` through the `media` argument, and/or the `prefers-colors-scheme` media\n\t// feature, using the `colorScheme` argument.\n\tEmulateMedia(options ...PageEmulateMediaOptions) error\n\n\t// The method finds an element matching the specified selector within the page and passes it as a first argument to\n\t// “[object Object]”. If no elements match the selector, the method throws an error. Returns the value of\n\t// “[object Object]”.\n\t// If “[object Object]” returns a [Promise], then [Page.EvalOnSelector] would wait for the promise to resolve and\n\t// return its value.\n\t//\n\t// Deprecated: This method does not wait for the element to pass actionability checks and therefore can lead to the flaky tests. Use [Locator.Evaluate], other [Locator] helper methods or web-first assertions instead.\n\t//\n\t// 1. selector: A selector to query for.\n\t// 2. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 3. arg: Optional argument to pass to “[object Object]”.\n\tEvalOnSelector(selector string, expression string, arg interface{}, options ...PageEvalOnSelectorOptions) (interface{}, error)\n\n\t// The method finds all elements matching the specified selector within the page and passes an array of matched\n\t// elements as a first argument to “[object Object]”. Returns the result of “[object Object]” invocation.\n\t// If “[object Object]” returns a [Promise], then [Page.EvalOnSelectorAll] would wait for the promise to resolve and\n\t// return its value.\n\t//\n\t// Deprecated: In most cases, [Locator.EvaluateAll], other [Locator] helper methods and web-first assertions do a better job.\n\t//\n\t// 1. selector: A selector to query for.\n\t// 2. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 3. arg: Optional argument to pass to “[object Object]”.\n\tEvalOnSelectorAll(selector string, expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the value of the “[object Object]” invocation.\n\t// If the function passed to the [Page.Evaluate] returns a [Promise], then [Page.Evaluate] would wait for the promise\n\t// to resolve and return its value.\n\t// If the function passed to the [Page.Evaluate] returns a non-[Serializable] value, then [Page.Evaluate] resolves to\n\t// `undefined`. Playwright also supports transferring some additional values that are not serializable by `JSON`:\n\t// `-0`, `NaN`, `Infinity`, `-Infinity`.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluate(expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the value of the “[object Object]” invocation as a [JSHandle].\n\t// The only difference between [Page.Evaluate] and [Page.EvaluateHandle] is that [Page.EvaluateHandle] returns\n\t// [JSHandle].\n\t// If the function passed to the [Page.EvaluateHandle] returns a [Promise], then [Page.EvaluateHandle] would wait for\n\t// the promise to resolve and return its value.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluateHandle(expression string, arg ...interface{}) (JSHandle, error)\n\n\t// The method adds a function called “[object Object]” on the `window` object of every frame in this page. When\n\t// called, the function executes “[object Object]” and returns a [Promise] which resolves to the return value of\n\t// “[object Object]”. If the “[object Object]” returns a [Promise], it will be awaited.\n\t// The first argument of the “[object Object]” function contains information about the caller: `{ browserContext:\n\t// BrowserContext, page: Page, frame: Frame }`.\n\t// See [BrowserContext.ExposeBinding] for the context-wide version.\n\t// **NOTE** Functions installed via [Page.ExposeBinding] survive navigations.\n\t//\n\t// 1. name: Name of the function on the window object.\n\t// 2. binding: Callback function that will be called in the Playwright's context.\n\tExposeBinding(name string, binding BindingCallFunction, handle ...bool) error\n\n\t// The method adds a function called “[object Object]” on the `window` object of every frame in the page. When called,\n\t// the function executes “[object Object]” and returns a [Promise] which resolves to the return value of\n\t// “[object Object]”.\n\t// If the “[object Object]” returns a [Promise], it will be awaited.\n\t// See [BrowserContext.ExposeFunction] for context-wide exposed function.\n\t// **NOTE** Functions installed via [Page.ExposeFunction] survive navigations.\n\t//\n\t// 1. name: Name of the function on the window object\n\t// 2. binding: Callback function which will be called in Playwright's context.\n\tExposeFunction(name string, binding ExposedFunction) error\n\n\t// This method waits for an element matching “[object Object]”, waits for [actionability] checks,\n\t// focuses the element, fills it and triggers an `input` event after filling. Note that you can pass an empty string\n\t// to clear the input field.\n\t// If the target element is not an `<input>`, `<textarea>` or `[contenteditable]` element, this method throws an\n\t// error. However, if the element is inside the `<label>` element that has an associated\n\t// [control], the control will be filled\n\t// instead.\n\t// To send fine-grained keyboard events, use [Locator.PressSequentially].\n\t//\n\t// Deprecated: Use locator-based [Locator.Fill] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. value: Value to fill for the `<input>`, `<textarea>` or `[contenteditable]` element.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tFill(selector string, value string, options ...PageFillOptions) error\n\n\t// This method fetches an element with “[object Object]” and focuses it. If there's no element matching\n\t// “[object Object]”, the method waits until a matching element appears in the DOM.\n\t//\n\t// Deprecated: Use locator-based [Locator.Focus] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tFocus(selector string, options ...PageFocusOptions) error\n\n\t// Returns frame matching the specified criteria. Either `name` or `url` must be specified.\n\tFrame(options ...PageFrameOptions) Frame\n\n\t// When working with iframes, you can create a frame locator that will enter the iframe and allow selecting elements\n\t// in that iframe.\n\t//\n\t//  selector: A selector to use when resolving DOM element.\n\tFrameLocator(selector string) FrameLocator\n\n\t// An array of all frames attached to the page.\n\tFrames() []Frame\n\n\t// Returns element attribute value.\n\t//\n\t// Deprecated: Use locator-based [Locator.GetAttribute] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. name: Attribute name to get the value for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tGetAttribute(selector string, name string, options ...PageGetAttributeOptions) (string, error)\n\n\t// Allows locating elements by their alt text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByAltText(text interface{}, options ...PageGetByAltTextOptions) Locator\n\n\t// Allows locating input elements by the text of the associated `<label>` or `aria-labelledby` element, or by the\n\t// `aria-label` attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByLabel(text interface{}, options ...PageGetByLabelOptions) Locator\n\n\t// Allows locating input elements by the placeholder text.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByPlaceholder(text interface{}, options ...PageGetByPlaceholderOptions) Locator\n\n\t// Allows locating elements by their [ARIA role],\n\t// [ARIA attributes] and\n\t// [accessible name].\n\t//\n\t// # Details\n\t//\n\t// Role selector **does not replace** accessibility audits and conformance tests, but rather gives early feedback\n\t// about the ARIA guidelines.\n\t// Many html elements have an implicitly [defined role]\n\t// that is recognized by the role selector. You can find all the\n\t// [supported roles here]. ARIA guidelines **do not recommend**\n\t// duplicating implicit roles and attributes by setting `role` and/or `aria-*` attributes to default values.\n\t//\n\t//  role: Required aria role.\n\t//\n\t// [ARIA role]: https://www.w3.org/TR/wai-aria-1.2/#roles\n\t// [ARIA attributes]: https://www.w3.org/TR/wai-aria-1.2/#aria-attributes\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [defined role]: https://w3c.github.io/html-aam/#html-element-role-mappings\n\t// [supported roles here]: https://www.w3.org/TR/wai-aria-1.2/#role_definitions\n\tGetByRole(role AriaRole, options ...PageGetByRoleOptions) Locator\n\n\t// Locate element by the test id.\n\t//\n\t// # Details\n\t//\n\t// By default, the `data-testid` attribute is used as a test id. Use [Selectors.SetTestIdAttribute] to configure a\n\t// different test id attribute if necessary.\n\t//\n\t//  testId: Id to locate the element by.\n\tGetByTestId(testId interface{}) Locator\n\n\t// Allows locating elements that contain given text.\n\t// See also [Locator.Filter] that allows to match by another criteria, like an accessible role, and then filter by the\n\t// text content.\n\t//\n\t// # Details\n\t//\n\t// Matching by text always normalizes whitespace, even with exact match. For example, it turns multiple spaces into\n\t// one, turns line breaks into spaces and ignores leading and trailing whitespace.\n\t// Input elements of the type `button` and `submit` are matched by their `value` instead of the text content. For\n\t// example, locating by text `\"Log in\"` matches `<input type=button value=\"Log in\">`.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByText(text interface{}, options ...PageGetByTextOptions) Locator\n\n\t// Allows locating elements by their title attribute.\n\t//\n\t//  text: Text to locate the element for.\n\tGetByTitle(text interface{}, options ...PageGetByTitleOptions) Locator\n\n\t// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of\n\t// the last redirect. If cannot go back, returns `null`.\n\t// Navigate to the previous page in history.\n\tGoBack(options ...PageGoBackOptions) (Response, error)\n\n\t// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of\n\t// the last redirect. If cannot go forward, returns `null`.\n\t// Navigate to the next page in history.\n\tGoForward(options ...PageGoForwardOptions) (Response, error)\n\n\t// Request the page to perform garbage collection. Note that there is no guarantee that all unreachable objects will\n\t// be collected.\n\t// This is useful to help detect memory leaks. For example, if your page has a large object `suspect` that might be\n\t// leaked, you can check that it does not leak by using a\n\t// [`WeakRef`].\n\t//\n\t// [`WeakRef`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef\n\tRequestGC() error\n\n\t// Returns the main resource response. In case of multiple redirects, the navigation will resolve with the first\n\t// non-redirect response.\n\t// The method will throw an error if:\n\t//  - there's an SSL error (e.g. in case of self-signed certificates).\n\t//  - target URL is invalid.\n\t//  - the “[object Object]” is exceeded during navigation.\n\t//  - the remote server does not respond or is unreachable.\n\t//  - the main resource failed to load.\n\t// The method will not throw an error when any valid HTTP status code is returned by the remote server, including 404\n\t// \"Not Found\" and 500 \"Internal Server Error\".  The status code for such responses can be retrieved by calling\n\t// [Response.Status].\n\t// **NOTE** The method either throws an error or returns a main resource response. The only exceptions are navigation\n\t// to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.\n\t// **NOTE** Headless mode doesn't support navigation to a PDF document. See the\n\t// [upstream issue].\n\t//\n\t//  url: URL to navigate page to. The url should include scheme, e.g. `https://`. When a “[object Object]” via the context\n\t//    options was provided and the passed URL is a path, it gets merged via the\n\t//    [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor.\n\t//\n\t// [upstream issue]: https://bugs.chromium.org/p/chromium/issues/detail?id=761295\n\tGoto(url string, options ...PageGotoOptions) (Response, error)\n\n\t// This method hovers over an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Mouse] to hover over the center of the element, or the specified “[object Object]”.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Hover] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tHover(selector string, options ...PageHoverOptions) error\n\n\t// Returns `element.innerHTML`.\n\t//\n\t// Deprecated: Use locator-based [Locator.InnerHTML] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tInnerHTML(selector string, options ...PageInnerHTMLOptions) (string, error)\n\n\t// Returns `element.innerText`.\n\t//\n\t// Deprecated: Use locator-based [Locator.InnerText] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tInnerText(selector string, options ...PageInnerTextOptions) (string, error)\n\n\t// Returns `input.value` for the selected `<input>` or `<textarea>` or `<select>` element.\n\t// Throws for non-input elements. However, if the element is inside the `<label>` element that has an associated\n\t// [control], returns the value of the\n\t// control.\n\t//\n\t// Deprecated: Use locator-based [Locator.InputValue] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tInputValue(selector string, options ...PageInputValueOptions) (string, error)\n\n\t// Returns whether the element is checked. Throws if the element is not a checkbox or radio input.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsChecked] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsChecked(selector string, options ...PageIsCheckedOptions) (bool, error)\n\n\t// Indicates that the page has been closed.\n\tIsClosed() bool\n\n\t// Returns whether the element is disabled, the opposite of [enabled].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsDisabled] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsDisabled(selector string, options ...PageIsDisabledOptions) (bool, error)\n\n\t// Returns whether the element is [editable].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsEditable] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [editable]: https://playwright.dev/docs/actionability#editable\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsEditable(selector string, options ...PageIsEditableOptions) (bool, error)\n\n\t// Returns whether the element is [enabled].\n\t//\n\t// Deprecated: Use locator-based [Locator.IsEnabled] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [enabled]: https://playwright.dev/docs/actionability#enabled\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsEnabled(selector string, options ...PageIsEnabledOptions) (bool, error)\n\n\t// Returns whether the element is hidden, the opposite of [visible].  “[object Object]”\n\t// that does not match any elements is considered hidden.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsHidden] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsHidden(selector string, options ...PageIsHiddenOptions) (bool, error)\n\n\t// Returns whether the element is [visible]. “[object Object]” that does not match any\n\t// elements is considered not visible.\n\t//\n\t// Deprecated: Use locator-based [Locator.IsVisible] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [visible]: https://playwright.dev/docs/actionability#visible\n\t// [locators]: https://playwright.dev/docs/locators\n\tIsVisible(selector string, options ...PageIsVisibleOptions) (bool, error)\n\n\tKeyboard() Keyboard\n\n\t// The method returns an element locator that can be used to perform actions on this page / frame. Locator is resolved\n\t// to the element immediately before performing an action, so a series of actions on the same locator can in fact be\n\t// performed on different DOM elements. That would happen if the DOM structure between those actions has changed.\n\t// [Learn more about locators].\n\t//\n\t//  selector: A selector to use when resolving DOM element.\n\t//\n\t// [Learn more about locators]: https://playwright.dev/docs/locators\n\tLocator(selector string, options ...PageLocatorOptions) Locator\n\n\t// The page's main frame. Page is guaranteed to have a main frame which persists during navigations.\n\tMainFrame() Frame\n\n\tMouse() Mouse\n\n\t// Returns the opener for popup pages and `null` for others. If the opener has been closed already the returns `null`.\n\tOpener() (Page, error)\n\n\t// Pauses script execution. Playwright will stop executing the script and wait for the user to either press 'Resume'\n\t// button in the page overlay or to call `playwright.resume()` in the DevTools console.\n\t// User can inspect selectors or perform manual steps while paused. Resume will continue running the original script\n\t// from the place it was paused.\n\t// **NOTE** This method requires Playwright to be started in a headed mode, with a falsy “[object Object]” option.\n\tPause() error\n\n\t// Returns the PDF buffer.\n\t// **NOTE** Generating a pdf is currently only supported in Chromium headless.\n\t// `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call\n\t// [Page.EmulateMedia] before calling `page.pdf()`:\n\t// **NOTE** By default, `page.pdf()` generates a pdf with modified colors for printing. Use the\n\t// [`-webkit-print-color-adjust`]\n\t// property to force rendering of exact colors.\n\t//\n\t// [`-webkit-print-color-adjust`]: https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust\n\tPDF(options ...PagePdfOptions) ([]byte, error)\n\n\t// Focuses the element, and then uses [Keyboard.Down] and [Keyboard.Up].\n\t// “[object Object]” can specify the intended\n\t// [keyboardEvent.Key] value or a single character\n\t// to generate the text for. A superset of the “[object Object]” values can be found\n\t// [here]. Examples of the keys are:\n\t// `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,\n\t// `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`,\n\t// etc.\n\t// Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`,\n\t// `ControlOrMeta`. `ControlOrMeta` resolves to `Control` on Windows and Linux and to `Meta` on macOS.\n\t// Holding down `Shift` will type the text that corresponds to the “[object Object]” in the upper case.\n\t// If “[object Object]” is a single character, it is case-sensitive, so the values `a` and `A` will generate different\n\t// respective texts.\n\t// Shortcuts such as `key: \"Control+o\"`, `key: \"Control++` or `key: \"Control+Shift+T\"` are supported as well. When\n\t// specified with the modifier, modifier is pressed and being held while the subsequent key is being pressed.\n\t//\n\t// Deprecated: Use locator-based [Locator.Press] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. key: Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.\n\t//\n\t// [keyboardEvent.Key]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t// [here]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n\t// [locators]: https://playwright.dev/docs/locators\n\tPress(selector string, key string, options ...PagePressOptions) error\n\n\t// The method finds an element matching the specified selector within the page. If no elements match the selector, the\n\t// return value resolves to `null`. To wait for an element on the page, use [Locator.WaitFor].\n\t//\n\t// Deprecated: Use locator-based [Page.Locator] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tQuerySelector(selector string, options ...PageQuerySelectorOptions) (ElementHandle, error)\n\n\t// The method finds all elements matching the specified selector within the page. If no elements match the selector,\n\t// the return value resolves to `[]`.\n\t//\n\t// Deprecated: Use locator-based [Page.Locator] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tQuerySelectorAll(selector string) ([]ElementHandle, error)\n\n\t// When testing a web page, sometimes unexpected overlays like a \"Sign up\" dialog appear and block actions you want to\n\t// automate, e.g. clicking a button. These overlays don't always show up in the same way or at the same time, making\n\t// them tricky to handle in automated tests.\n\t// This method lets you set up a special function, called a handler, that activates when it detects that overlay is\n\t// visible. The handler's job is to remove the overlay, allowing your test to continue as if the overlay wasn't there.\n\t// Things to keep in mind:\n\t//  - When an overlay is shown predictably, we recommend explicitly waiting for it in your test and dismissing it as\n\t//   a part of your normal test flow, instead of using [Page.AddLocatorHandler].\n\t//  - Playwright checks for the overlay every time before executing or retrying an action that requires an\n\t//   [actionability check], or before performing an auto-waiting assertion check. When overlay\n\t//   is visible, Playwright calls the handler first, and then proceeds with the action/assertion. Note that the\n\t//   handler is only called when you perform an action/assertion - if the overlay becomes visible but you don't\n\t//   perform any actions, the handler will not be triggered.\n\t//  - After executing the handler, Playwright will ensure that overlay that triggered the handler is not visible\n\t//   anymore. You can opt-out of this behavior with “[object Object]”.\n\t//  - The execution time of the handler counts towards the timeout of the action/assertion that executed the handler.\n\t//   If your handler takes too long, it might cause timeouts.\n\t//  - You can register multiple handlers. However, only a single handler will be running at a time. Make sure the\n\t//   actions within a handler don't depend on another handler.\n\t// **NOTE** Running the handler will alter your page state mid-test. For example it will change the currently focused\n\t// element and move the mouse. Make sure that actions that run after the handler are self-contained and do not rely on\n\t// the focus and mouse state being unchanged.\n\t// For example, consider a test that calls [Locator.Focus] followed by [Keyboard.Press]. If your handler clicks a\n\t// button between these two actions, the focused element most likely will be wrong, and key press will happen on the\n\t// unexpected element. Use [Locator.Press] instead to avoid this problem.\n\t// Another example is a series of mouse actions, where [Mouse.Move] is followed by [Mouse.Down]. Again, when the\n\t// handler runs between these two actions, the mouse position will be wrong during the mouse down. Prefer\n\t// self-contained actions like [Locator.Click] that do not rely on the state being unchanged by a handler.\n\t//\n\t// 1. locator: Locator that triggers the handler.\n\t// 2. handler: Function that should be run once “[object Object]” appears. This function should get rid of the element that blocks\n\t//    actions like click.\n\t//\n\t// [actionability check]: https://playwright.dev/docs/actionability\n\tAddLocatorHandler(locator Locator, handler func(Locator), options ...PageAddLocatorHandlerOptions) error\n\n\t// Removes all locator handlers added by [Page.AddLocatorHandler] for a specific locator.\n\t//\n\t//  locator: Locator passed to [Page.AddLocatorHandler].\n\tRemoveLocatorHandler(locator Locator) error\n\n\t// This method reloads the current page, in the same way as if the user had triggered a browser refresh. Returns the\n\t// main resource response. In case of multiple redirects, the navigation will resolve with the response of the last\n\t// redirect.\n\tReload(options ...PageReloadOptions) (Response, error)\n\n\t// API testing helper associated with this page. This method returns the same instance as [BrowserContext.Request] on\n\t// the page's context. See [BrowserContext.Request] for more details.\n\tRequest() APIRequestContext\n\n\t// Routing provides the capability to modify network requests that are made by a page.\n\t// Once routing is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or\n\t// aborted.\n\t// **NOTE** The handler will only be called for the first url if the response is a redirect.\n\t// **NOTE** [Page.Route] will not intercept requests intercepted by Service Worker. See\n\t// [this] issue. We recommend disabling Service Workers when\n\t// using request interception by setting “[object Object]” to `block`.\n\t// **NOTE** [Page.Route] will not intercept the first request of a popup page. Use [BrowserContext.Route] instead.\n\t//\n\t// 1. url: A glob pattern, regex pattern or predicate receiving [URL] to match while routing. When a “[object Object]” via the\n\t//    context options was provided and the passed URL is a path, it gets merged via the\n\t//    [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor.\n\t// 2. handler: handler function to route the request.\n\t//\n\t// [this]: https://github.com/microsoft/playwright/issues/1090\n\tRoute(url interface{}, handler routeHandler, times ...int) error\n\n\t// If specified the network requests that are made in the page will be served from the HAR file. Read more about\n\t// [Replaying from HAR].\n\t// Playwright will not serve requests intercepted by Service Worker from the HAR file. See\n\t// [this] issue. We recommend disabling Service Workers when\n\t// using request interception by setting “[object Object]” to `block`.\n\t//\n\t//  har: Path to a [HAR](http://www.softwareishard.com/blog/har-12-spec) file with prerecorded network data. If `path` is a\n\t//    relative path, then it is resolved relative to the current working directory.\n\t//\n\t// [Replaying from HAR]: https://playwright.dev/docs/mock#replaying-from-har\n\t// [this]: https://github.com/microsoft/playwright/issues/1090\n\tRouteFromHAR(har string, options ...PageRouteFromHAROptions) error\n\n\t// This method allows to modify websocket connections that are made by the page.\n\t// Note that only `WebSocket`s created after this method was called will be routed. It is recommended to call this\n\t// method before navigating the page.\n\t//\n\t// 1. url: Only WebSockets with the url matching this pattern will be routed. A string pattern can be relative to the\n\t//    “[object Object]” context option.\n\t// 2. handler: Handler function to route the WebSocket.\n\tRouteWebSocket(url interface{}, handler func(WebSocketRoute)) error\n\n\t// Returns the buffer with the captured screenshot.\n\tScreenshot(options ...PageScreenshotOptions) ([]byte, error)\n\n\t// This method waits for an element matching “[object Object]”, waits for [actionability] checks,\n\t// waits until all specified options are present in the `<select>` element and selects these options.\n\t// If the target element is not a `<select>` element, this method throws an error. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], the control will be used\n\t// instead.\n\t// Returns the array of option values that have been successfully selected.\n\t// Triggers a `change` and `input` event once all the provided options have been selected.\n\t//\n\t// Deprecated: Use locator-based [Locator.SelectOption] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSelectOption(selector string, values SelectOptionValues, options ...PageSelectOptionOptions) ([]string, error)\n\n\t// This method checks or unchecks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Ensure that matched element is a checkbox or a radio input. If not, this method throws.\n\t//  3. If the element already has the right checked state, this method returns immediately.\n\t//  4. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  5. Scroll the element into view if needed.\n\t//  6. Use [Page.Mouse] to click in the center of the element.\n\t//  7. Ensure that the element is now checked or unchecked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.SetChecked] instead. Read more about [locators].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. checked: Whether to check or uncheck the checkbox.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tSetChecked(selector string, checked bool, options ...PageSetCheckedOptions) error\n\n\t// This method internally calls [document.Write()],\n\t// inheriting all its specific characteristics and behaviors.\n\t//\n\t//  html: HTML markup to assign to the page.\n\t//\n\t// [document.Write()]: https://developer.mozilla.org/en-US/docs/Web/API/Document/write\n\tSetContent(html string, options ...PageSetContentOptions) error\n\n\t// This setting will change the default maximum navigation time for the following methods and related shortcuts:\n\t//  - [Page.GoBack]\n\t//  - [Page.GoForward]\n\t//  - [Page.Goto]\n\t//  - [Page.Reload]\n\t//  - [Page.SetContent]\n\t//  - [Page.ExpectNavigation]\n\t//  - [Page.WaitForURL]\n\t// **NOTE** [Page.SetDefaultNavigationTimeout] takes priority over [Page.SetDefaultTimeout],\n\t// [BrowserContext.SetDefaultTimeout] and [BrowserContext.SetDefaultNavigationTimeout].\n\t//\n\t//  timeout: Maximum navigation time in milliseconds\n\tSetDefaultNavigationTimeout(timeout float64)\n\n\t// This setting will change the default maximum time for all the methods accepting “[object Object]” option.\n\t// **NOTE** [Page.SetDefaultNavigationTimeout] takes priority over [Page.SetDefaultTimeout].\n\t//\n\t//  timeout: Maximum time in milliseconds\n\tSetDefaultTimeout(timeout float64)\n\n\t// The extra HTTP headers will be sent with every request the page initiates.\n\t// **NOTE** [Page.SetExtraHTTPHeaders] does not guarantee the order of headers in the outgoing requests.\n\t//\n\t//  headers: An object containing additional HTTP headers to be sent with every request. All header values must be strings.\n\tSetExtraHTTPHeaders(headers map[string]string) error\n\n\t// Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then\n\t// they are resolved relative to the current working directory. For empty array, clears the selected files. For inputs\n\t// with a `[webkitdirectory]` attribute, only a single directory path is supported.\n\t// This method expects “[object Object]” to point to an\n\t// [input element]. However, if the element is inside\n\t// the `<label>` element that has an associated\n\t// [control], targets the control instead.\n\t//\n\t// Deprecated: Use locator-based [Locator.SetInputFiles] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [input element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n\t// [control]: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/control\n\t// [locators]: https://playwright.dev/docs/locators\n\tSetInputFiles(selector string, files interface{}, options ...PageSetInputFilesOptions) error\n\n\t// In the case of multiple pages in a single browser, each page can have its own viewport size. However,\n\t// [Browser.NewContext] allows to set viewport size (and more) for all pages in the context at once.\n\t// [Page.SetViewportSize] will resize the page. A lot of websites don't expect phones to change size, so you should\n\t// set the viewport size before navigating to the page. [Page.SetViewportSize] will also reset `screen` size, use\n\t// [Browser.NewContext] with `screen` and `viewport` parameters if you need better control of these properties.\n\t//\n\t// 1. width: Page width in pixels.\n\t// 2. height: Page height in pixels.\n\tSetViewportSize(width int, height int) error\n\n\t// This method taps an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  3. Scroll the element into view if needed.\n\t//  4. Use [Page.Touchscreen] to tap the center of the element, or the specified “[object Object]”.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t// **NOTE** [Page.Tap] the method will throw if “[object Object]” option of the browser context is false.\n\t//\n\t// Deprecated: Use locator-based [Locator.Tap] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tTap(selector string, options ...PageTapOptions) error\n\n\t// Returns `element.textContent`.\n\t//\n\t// Deprecated: Use locator-based [Locator.TextContent] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tTextContent(selector string, options ...PageTextContentOptions) (string, error)\n\n\t// Returns the page's title.\n\tTitle() (string, error)\n\n\tTouchscreen() Touchscreen\n\n\t// Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to\n\t// send fine-grained keyboard events. To fill values in form fields, use [Page.Fill].\n\t// To press a special key, like `Control` or `ArrowDown`, use [Keyboard.Press].\n\t//\n\t// Deprecated: In most cases, you should use [Locator.Fill] instead. You only need to press keys one by one if there is special keyboard handling on the page - in this case use [Locator.PressSequentially].\n\t//\n\t// 1. selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t// 2. text: A text to type into a focused element.\n\tType(selector string, text string, options ...PageTypeOptions) error\n\n\t// This method unchecks an element matching “[object Object]” by performing the following steps:\n\t//  1. Find an element matching “[object Object]”. If there is none, wait until a matching element is attached to\n\t//    the DOM.\n\t//  2. Ensure that matched element is a checkbox or a radio input. If not, this method throws. If the element is\n\t//    already unchecked, this method returns immediately.\n\t//  3. Wait for [actionability] checks on the matched element, unless “[object Object]” option\n\t//    is set. If the element is detached during the checks, the whole action is retried.\n\t//  4. Scroll the element into view if needed.\n\t//  5. Use [Page.Mouse] to click in the center of the element.\n\t//  6. Ensure that the element is now unchecked. If not, this method throws.\n\t// When all steps combined have not finished during the specified “[object Object]”, this method throws a\n\t// [TimeoutError]. Passing zero timeout disables this.\n\t//\n\t// Deprecated: Use locator-based [Locator.Uncheck] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to search for an element. If there are multiple elements satisfying the selector, the first will be\n\t//    used.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\t// [locators]: https://playwright.dev/docs/locators\n\tUncheck(selector string, options ...PageUncheckOptions) error\n\n\t// Removes all routes created with [Page.Route] and [Page.RouteFromHAR].\n\tUnrouteAll(options ...PageUnrouteAllOptions) error\n\n\t// Removes a route created with [Page.Route]. When “[object Object]” is not specified, removes all routes for the\n\t// “[object Object]”.\n\t//\n\t// 1. url: A glob pattern, regex pattern or predicate receiving [URL] to match while routing.\n\t// 2. handler: Optional handler function to route the request.\n\tUnroute(url interface{}, handler ...routeHandler) error\n\n\tURL() string\n\n\t// Video object associated with this page.\n\tVideo() Video\n\n\tViewportSize() *Size\n\n\t// Performs action and waits for a [ConsoleMessage] to be logged by in the page. If predicate is provided, it passes\n\t// [ConsoleMessage] value into the `predicate` function and waits for `predicate(message)` to return a truthy value.\n\t// Will throw an error if the page is closed before the [Page.OnConsole] event is fired.\n\tExpectConsoleMessage(cb func() error, options ...PageExpectConsoleMessageOptions) (ConsoleMessage, error)\n\n\t// Performs action and waits for a new [Download]. If predicate is provided, it passes [Download] value into the\n\t// `predicate` function and waits for `predicate(download)` to return a truthy value. Will throw an error if the page\n\t// is closed before the download event is fired.\n\tExpectDownload(cb func() error, options ...PageExpectDownloadOptions) (Download, error)\n\n\t// Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy\n\t// value. Will throw an error if the page is closed before the event is fired. Returns the event data value.\n\t//\n\t//  event: Event name, same one typically passed into `*.on(event)`.\n\tExpectEvent(event string, cb func() error, options ...PageExpectEventOptions) (interface{}, error)\n\n\t// Performs action and waits for a new [FileChooser] to be created. If predicate is provided, it passes [FileChooser]\n\t// value into the `predicate` function and waits for `predicate(fileChooser)` to return a truthy value. Will throw an\n\t// error if the page is closed before the file chooser is opened.\n\tExpectFileChooser(cb func() error, options ...PageExpectFileChooserOptions) (FileChooser, error)\n\n\t// Returns when the “[object Object]” returns a truthy value. It resolves to a JSHandle of the truthy value.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tWaitForFunction(expression string, arg interface{}, options ...PageWaitForFunctionOptions) (JSHandle, error)\n\n\t// Returns when the required load state has been reached.\n\t// This resolves when the page reaches a required load state, `load` by default. The navigation must have been\n\t// committed when this method is called. If current document has already reached the required state, resolves\n\t// immediately.\n\t// **NOTE** Most of the time, this method is not needed because Playwright\n\t// [auto-waits before every action].\n\t//\n\t// [auto-waits before every action]: https://playwright.dev/docs/actionability\n\tWaitForLoadState(options ...PageWaitForLoadStateOptions) error\n\n\t// Waits for the main frame navigation and returns the main resource response. In case of multiple redirects, the\n\t// navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or\n\t// navigation due to History API usage, the navigation will resolve with `null`.\n\t//\n\t// Deprecated: This method is inherently racy, please use [Page.WaitForURL] instead.\n\t//\n\t// [History API]: https://developer.mozilla.org/en-US/docs/Web/API/History_API\n\tExpectNavigation(cb func() error, options ...PageExpectNavigationOptions) (Response, error)\n\n\t// Performs action and waits for a popup [Page]. If predicate is provided, it passes [Popup] value into the\n\t// `predicate` function and waits for `predicate(page)` to return a truthy value. Will throw an error if the page is\n\t// closed before the popup event is fired.\n\tExpectPopup(cb func() error, options ...PageExpectPopupOptions) (Page, error)\n\n\t// Waits for the matching request and returns it. See [waiting for event] for more\n\t// details about events.\n\t//\n\t//  urlOrPredicate: Request URL string, regex or predicate receiving [Request] object. When a “[object Object]” via the context options\n\t//    was provided and the passed URL is a path, it gets merged via the\n\t//    [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor.\n\t//\n\t// [waiting for event]: https://playwright.dev/docs/events#waiting-for-event\n\tExpectRequest(urlOrPredicate interface{}, cb func() error, options ...PageExpectRequestOptions) (Request, error)\n\n\t// Performs action and waits for a [Request] to finish loading. If predicate is provided, it passes [Request] value\n\t// into the `predicate` function and waits for `predicate(request)` to return a truthy value. Will throw an error if\n\t// the page is closed before the [Page.OnRequestFinished] event is fired.\n\tExpectRequestFinished(cb func() error, options ...PageExpectRequestFinishedOptions) (Request, error)\n\n\t// Returns the matched response. See [waiting for event] for more details about\n\t// events.\n\t//\n\t//  urlOrPredicate: Request URL string, regex or predicate receiving [Response] object. When a “[object Object]” via the context\n\t//    options was provided and the passed URL is a path, it gets merged via the\n\t//    [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) constructor.\n\t//\n\t// [waiting for event]: https://playwright.dev/docs/events#waiting-for-event\n\tExpectResponse(urlOrPredicate interface{}, cb func() error, options ...PageExpectResponseOptions) (Response, error)\n\n\t// Returns when element specified by selector satisfies “[object Object]” option. Returns `null` if waiting for\n\t// `hidden` or `detached`.\n\t// **NOTE** Playwright automatically waits for element to be ready before performing an action. Using [Locator]\n\t// objects and web-first assertions makes the code wait-for-selector-free.\n\t// Wait for the “[object Object]” to satisfy “[object Object]” option (either appear/disappear from dom, or become\n\t// visible/hidden). If at the moment of calling the method “[object Object]” already satisfies the condition, the\n\t// method will return immediately. If the selector doesn't satisfy the condition for the “[object Object]”\n\t// milliseconds, the function will throw.\n\t//\n\t// Deprecated: Use web assertions that assert visibility or a locator-based [Locator.WaitFor] instead. Read more about [locators].\n\t//\n\t//  selector: A selector to query for.\n\t//\n\t// [locators]: https://playwright.dev/docs/locators\n\tWaitForSelector(selector string, options ...PageWaitForSelectorOptions) (ElementHandle, error)\n\n\t// Waits for the given “[object Object]” in milliseconds.\n\t// Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going\n\t// to be flaky. Use signals such as network events, selectors becoming visible and others instead.\n\t//\n\t// Deprecated: Never wait for timeout in production. Tests that wait for time are inherently flaky. Use [Locator] actions and web assertions that wait automatically.\n\t//\n\t//  timeout: A timeout to wait for\n\tWaitForTimeout(timeout float64)\n\n\t// Waits for the main frame to navigate to the given URL.\n\t//\n\t//  url: A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation. Note that if\n\t//    the parameter is a string without wildcard characters, the method will wait for navigation to URL that is exactly\n\t//    equal to the string.\n\tWaitForURL(url interface{}, options ...PageWaitForURLOptions) error\n\n\t// Performs action and waits for a new [WebSocket]. If predicate is provided, it passes [WebSocket] value into the\n\t// `predicate` function and waits for `predicate(webSocket)` to return a truthy value. Will throw an error if the page\n\t// is closed before the WebSocket event is fired.\n\tExpectWebSocket(cb func() error, options ...PageExpectWebSocketOptions) (WebSocket, error)\n\n\t// Performs action and waits for a new [Worker]. If predicate is provided, it passes [Worker] value into the\n\t// `predicate` function and waits for `predicate(worker)` to return a truthy value. Will throw an error if the page is\n\t// closed before the worker event is fired.\n\tExpectWorker(cb func() error, options ...PageExpectWorkerOptions) (Worker, error)\n\n\t// This method returns all of the dedicated\n\t// [WebWorkers] associated with the page.\n\t// **NOTE** This does not contain ServiceWorkers\n\t//\n\t// [WebWorkers]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n\tWorkers() []Worker\n\n\t// **NOTE** In most cases, you should use [Page.ExpectEvent].\n\t// Waits for given `event` to fire. If predicate is provided, it passes event's value into the `predicate` function\n\t// and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is closed before the\n\t// `event` is fired.\n\t//\n\t//  event: Event name, same one typically passed into `*.on(event)`.\n\tWaitForEvent(event string, options ...PageWaitForEventOptions) (interface{}, error)\n}\n\n// The [PageAssertions] class provides assertion methods that can be used to make assertions about the [Page] state in\n// the tests.\ntype PageAssertions interface {\n\t// Makes the assertion check for the opposite condition. For example, this code tests that the page URL doesn't\n\t// contain `\"error\"`:\n\tNot() PageAssertions\n\n\t// Ensures the page has the given title.\n\t//\n\t//  titleOrRegExp: Expected title or RegExp.\n\tToHaveTitle(titleOrRegExp interface{}, options ...PageAssertionsToHaveTitleOptions) error\n\n\t// Ensures the page is navigated to the given URL.\n\t//\n\t//  urlOrRegExp: Expected URL string or RegExp.\n\tToHaveURL(urlOrRegExp interface{}, options ...PageAssertionsToHaveURLOptions) error\n}\n\n// Playwright gives you Web-First Assertions with convenience methods for creating assertions that will wait and retry\n// until the expected condition is met.\n// Consider the following example:\n// Playwright will be re-testing the node with the selector `.status` until fetched Node has the `\"Submitted\"` text.\n// It will be re-fetching the node and checking it over and over, until the condition is met or until the timeout is\n// reached. You can pass this timeout as an option.\n// By default, the timeout for assertions is set to 5 seconds.\ntype PlaywrightAssertions interface {\n\t// Creates a [APIResponseAssertions] object for the given [APIResponse].\n\t//\n\t//  response: [APIResponse] object to use for assertions.\n\tAPIResponse(response APIResponse) APIResponseAssertions\n\n\t// Creates a [LocatorAssertions] object for the given [Locator].\n\t//\n\t//  locator: [Locator] object to use for assertions.\n\tLocator(locator Locator) LocatorAssertions\n\n\t// Creates a [PageAssertions] object for the given [Page].\n\t//\n\t//  page: [Page] object to use for assertions.\n\tPage(page Page) PageAssertions\n}\n\n// Whenever the page sends a request for a network resource the following sequence of events are emitted by [Page]:\n//   - [Page.OnRequest] emitted when the request is issued by the page.\n//   - [Page.OnResponse] emitted when/if the response status and headers are received for the request.\n//   - [Page.OnRequestFinished] emitted when the response body is downloaded and the request is complete.\n//\n// If request fails at some point, then instead of `requestfinished` event (and possibly instead of 'response'\n// event), the  [Page.OnRequestFailed] event is emitted.\n// **NOTE** HTTP Error responses, such as 404 or 503, are still successful responses from HTTP standpoint, so request\n// will complete with `requestfinished` event.\n// If request gets a 'redirect' response, the request is successfully finished with the `requestfinished` event, and a\n// new request is  issued to a redirected url.\ntype Request interface {\n\t// An object with all the request HTTP headers associated with this request. The header names are lower-cased.\n\tAllHeaders() (map[string]string, error)\n\n\t// The method returns `null` unless this request has failed, as reported by `requestfailed` event.\n\tFailure() error\n\n\t// Returns the [Frame] that initiated this request.\n\t//\n\t// # Details\n\t//\n\t// Note that in some cases the frame is not available, and this method will throw.\n\t//  - When request originates in the Service Worker. You can use `request.serviceWorker()` to check that.\n\t//  - When navigation request is issued before the corresponding frame is created. You can use\n\t//   [Request.IsNavigationRequest] to check that.\n\t// Here is an example that handles all the cases:\n\tFrame() Frame\n\n\t// An object with the request HTTP headers. The header names are lower-cased. Note that this method does not return\n\t// security-related headers, including cookie-related ones. You can use [Request.AllHeaders] for complete list of\n\t// headers that include `cookie` information.\n\tHeaders() map[string]string\n\n\t// An array with all the request HTTP headers associated with this request. Unlike [Request.AllHeaders], header names\n\t// are NOT lower-cased. Headers with multiple entries, such as `Set-Cookie`, appear in the array multiple times.\n\tHeadersArray() ([]NameValue, error)\n\n\t// Returns the value of the header matching the name. The name is case-insensitive.\n\t//\n\t//  name: Name of the header.\n\tHeaderValue(name string) (string, error)\n\n\t// Whether this request is driving frame's navigation.\n\t// Some navigation requests are issued before the corresponding frame is created, and therefore do not have\n\t// [Request.Frame] available.\n\tIsNavigationRequest() bool\n\n\t// Request's method (GET, POST, etc.)\n\tMethod() string\n\n\t// Request's post body, if any.\n\tPostData() (string, error)\n\n\t// Request's post body in a binary form, if any.\n\tPostDataBuffer() ([]byte, error)\n\n\t// Returns parsed request's body for `form-urlencoded` and JSON as a fallback if any.\n\t// When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned.\n\t// Otherwise it will be parsed as JSON.\n\tPostDataJSON(v interface{}) error\n\n\t// Request that was redirected by the server to this one, if any.\n\t// When the server responds with a redirect, Playwright creates a new [Request] object. The two requests are connected\n\t// by `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to\n\t// construct the whole redirect chain by repeatedly calling `redirectedFrom()`.\n\tRedirectedFrom() Request\n\n\t// New request issued by the browser if the server responded with redirect.\n\tRedirectedTo() Request\n\n\t// Contains the request's resource type as it was perceived by the rendering engine. ResourceType will be one of the\n\t// following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`,\n\t// `eventsource`, `websocket`, `manifest`, `other`.\n\tResourceType() string\n\n\t// Returns the matching [Response] object, or `null` if the response was not received due to error.\n\tResponse() (Response, error)\n\n\t// Returns resource size information for given request.\n\tSizes() (*RequestSizesResult, error)\n\n\t// Returns resource timing information for given request. Most of the timing values become available upon the\n\t// response, `responseEnd` becomes available when request finishes. Find more information at\n\t// [Resource Timing API].\n\t//\n\t// [Resource Timing API]: https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming\n\tTiming() *RequestTiming\n\n\t// URL of the request.\n\tURL() string\n}\n\n// [Response] class represents responses which are received by page.\ntype Response interface {\n\t// An object with all the response HTTP headers associated with this response.\n\tAllHeaders() (map[string]string, error)\n\n\t// Returns the buffer with response body.\n\tBody() ([]byte, error)\n\n\t// Waits for this response to finish, returns always `null`.\n\tFinished() error\n\n\t// Returns the [Frame] that initiated this response.\n\tFrame() Frame\n\n\t// Indicates whether this Response was fulfilled by a Service Worker's Fetch Handler (i.e. via\n\t// [FetchEvent.RespondWith].\n\t//\n\t// [FetchEvent.RespondWith]: https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith)\n\tFromServiceWorker() bool\n\n\t// An object with the response HTTP headers. The header names are lower-cased. Note that this method does not return\n\t// security-related headers, including cookie-related ones. You can use [Response.AllHeaders] for complete list of\n\t// headers that include `cookie` information.\n\tHeaders() map[string]string\n\n\t// An array with all the request HTTP headers associated with this response. Unlike [Response.AllHeaders], header\n\t// names are NOT lower-cased. Headers with multiple entries, such as `Set-Cookie`, appear in the array multiple times.\n\tHeadersArray() ([]NameValue, error)\n\n\t// Returns the value of the header matching the name. The name is case-insensitive. If multiple headers have the same\n\t// name (except `set-cookie`), they are returned as a list separated by `, `. For `set-cookie`, the `\\n` separator is\n\t// used. If no headers are found, `null` is returned.\n\t//\n\t//  name: Name of the header.\n\tHeaderValue(name string) (string, error)\n\n\t// Returns all values of the headers matching the name, for example `set-cookie`. The name is case-insensitive.\n\t//\n\t//  name: Name of the header.\n\tHeaderValues(name string) ([]string, error)\n\n\t// Returns the JSON representation of response body.\n\t// This method will throw if the response body is not parsable via `JSON.parse`.\n\tJSON(v interface{}) error\n\n\t// Contains a boolean stating whether the response was successful (status in the range 200-299) or not.\n\tOk() bool\n\n\t// Returns the matching [Request] object.\n\tRequest() Request\n\n\t// Returns SSL and other security information.\n\tSecurityDetails() (*ResponseSecurityDetailsResult, error)\n\n\t// Returns the IP address and port of the server.\n\tServerAddr() (*ResponseServerAddrResult, error)\n\n\t// Contains the status code of the response (e.g., 200 for a success).\n\tStatus() int\n\n\t// Contains the status text of the response (e.g. usually an \"OK\" for a success).\n\tStatusText() string\n\n\t// Returns the text representation of response body.\n\tText() (string, error)\n\n\t// Contains the URL of the response.\n\tURL() string\n}\n\n// Whenever a network route is set up with [Page.Route] or [BrowserContext.Route], the `Route` object allows to handle\n// the route.\n// Learn more about [networking].\n//\n// [networking]: https://playwright.dev/docs/network\ntype Route interface {\n\t// Aborts the route's request.\n\tAbort(errorCode ...string) error\n\n\t// Sends route's request to the network with optional overrides.\n\t//\n\t// # Details\n\t//\n\t// The “[object Object]” option applies to both the routed request and any redirects it initiates. However,\n\t// “[object Object]”, “[object Object]”, and “[object Object]” only apply to the original request and are not carried\n\t// over to redirected requests.\n\t// [Route.Continue] will immediately send the request to the network, other matching handlers won't be invoked. Use\n\t// [Route.Fallback] If you want next matching handler in the chain to be invoked.\n\tContinue(options ...RouteContinueOptions) error\n\n\t// Continues route's request with optional overrides. The method is similar to [Route.Continue] with the difference\n\t// that other matching handlers will be invoked before sending the request.\n\tFallback(options ...RouteFallbackOptions) error\n\n\t// Performs the request and fetches result without fulfilling it, so that the response could be modified and then\n\t// fulfilled.\n\t//\n\t// # Details\n\t//\n\t// Note that “[object Object]” option will apply to the fetched request as well as any redirects initiated by it. If\n\t// you want to only apply “[object Object]” to the original request, but not to redirects, look into [Route.Continue]\n\t// instead.\n\tFetch(options ...RouteFetchOptions) (APIResponse, error)\n\n\t// Fulfills route's request with given response.\n\tFulfill(options ...RouteFulfillOptions) error\n\n\t// A request to be routed.\n\tRequest() Request\n}\n\n// Selectors can be used to install custom selector engines. See [extensibility] for more\n// information.\n//\n// [extensibility]: https://playwright.dev/docs/extensibility\ntype Selectors interface {\n\t// Selectors must be registered before creating the page.\n\t//\n\t// 1. name: Name that is used in selectors as a prefix, e.g. `{name: 'foo'}` enables `foo=myselectorbody` selectors. May only\n\t//    contain `[a-zA-Z0-9_]` characters.\n\t// 2. script: Script that evaluates to a selector engine instance. The script is evaluated in the page context.\n\tRegister(name string, script Script, options ...SelectorsRegisterOptions) error\n\n\t// Defines custom attribute name to be used in [Page.GetByTestId]. `data-testid` is used by default.\n\t//\n\t//  attributeName: Test id attribute name.\n\tSetTestIdAttribute(attributeName string)\n}\n\n// The Touchscreen class operates in main-frame CSS pixels relative to the top-left corner of the viewport. Methods on\n// the touchscreen can only be used in browser contexts that have been initialized with `hasTouch` set to true.\ntype Touchscreen interface {\n\t// Dispatches a `touchstart` and `touchend` event with a single touch at the position\n\t// (“[object Object]”,“[object Object]”).\n\t// **NOTE** [Page.Tap] the method will throw if “[object Object]” option of the browser context is false.\n\t//\n\t// 1. x: X coordinate relative to the main frame's viewport in CSS pixels.\n\t// 2. y: Y coordinate relative to the main frame's viewport in CSS pixels.\n\tTap(x int, y int) error\n}\n\n// API for collecting and saving Playwright traces. Playwright traces can be opened in\n// [Trace Viewer] after Playwright script runs.\n// Start recording a trace before performing actions. At the end, stop tracing and save it to a file.\n//\n// [Trace Viewer]: https://playwright.dev/docs/trace-viewer\ntype Tracing interface {\n\t// Start tracing.\n\tStart(options ...TracingStartOptions) error\n\n\t// Start a new trace chunk. If you'd like to record multiple traces on the same [BrowserContext], use [Tracing.Start]\n\t// once, and then create multiple trace chunks with [Tracing.StartChunk] and [Tracing.StopChunk].\n\tStartChunk(options ...TracingStartChunkOptions) error\n\n\t// **NOTE** Use `test.step` instead when available.\n\t// Creates a new group within the trace, assigning any subsequent API calls to this group, until [Tracing.GroupEnd] is\n\t// called. Groups can be nested and will be visible in the trace viewer.\n\t//\n\t//  name: Group name shown in the trace viewer.\n\tGroup(name string, options ...TracingGroupOptions) error\n\n\t// Closes the last group created by [Tracing.Group].\n\tGroupEnd() error\n\n\t// Stop tracing.\n\tStop(path ...string) error\n\n\t// Stop the trace chunk. See [Tracing.StartChunk] for more details about multiple trace chunks.\n\tStopChunk(path ...string) error\n}\n\n// When browser context is created with the `recordVideo` option, each page has a video object associated with it.\ntype Video interface {\n\t// Deletes the video file. Will wait for the video to finish if necessary.\n\tDelete() error\n\n\t// Returns the file system path this video will be recorded to. The video is guaranteed to be written to the\n\t// filesystem upon closing the browser context. This method throws when connected remotely.\n\tPath() (string, error)\n\n\t// Saves the video to a user-specified path. It is safe to call this method while the video is still in progress, or\n\t// after the page has closed. This method waits until the page is closed and the video is fully saved.\n\t//\n\t//  path: Path where the video should be saved.\n\tSaveAs(path string) error\n}\n\n// [WebError] class represents an unhandled exception thrown in the page. It is dispatched via the\n// [BrowserContext.OnWebError] event.\ntype WebError interface {\n\t// The page that produced this unhandled exception, if any.\n\tPage() Page\n\n\t// Unhandled error that was thrown.\n\tError() error\n}\n\n// The [WebSocket] class represents websocket connections in the page.\ntype WebSocket interface {\n\t// Fired when the websocket closes.\n\tOnClose(fn func(WebSocket))\n\n\t// Fired when the websocket receives a frame.\n\tOnFrameReceived(fn func([]byte))\n\n\t// Fired when the websocket sends a frame.\n\tOnFrameSent(fn func([]byte))\n\n\t// Fired when the websocket has an error.\n\tOnSocketError(fn func(string))\n\n\t// Indicates that the web socket has been closed.\n\tIsClosed() bool\n\n\t// Contains the URL of the WebSocket.\n\tURL() string\n\n\t// Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy\n\t// value. Will throw an error if the webSocket is closed before the event is fired. Returns the event data value.\n\t//\n\t//  event: Event name, same one would pass into `webSocket.on(event)`.\n\tExpectEvent(event string, cb func() error, options ...WebSocketExpectEventOptions) (interface{}, error)\n\n\t// **NOTE** In most cases, you should use [WebSocket.ExpectEvent].\n\t// Waits for given `event` to fire. If predicate is provided, it passes event's value into the `predicate` function\n\t// and waits for `predicate(event)` to return a truthy value. Will throw an error if the socket is closed before the\n\t// `event` is fired.\n\t//\n\t//  event: Event name, same one typically passed into `*.on(event)`.\n\tWaitForEvent(event string, options ...WebSocketWaitForEventOptions) (interface{}, error)\n}\n\n// Whenever a [`WebSocket`] route is set up with\n// [Page.RouteWebSocket] or [BrowserContext.RouteWebSocket], the `WebSocketRoute` object allows to handle the\n// WebSocket, like an actual server would do.\n// **Mocking**\n// By default, the routed WebSocket will not connect to the server. This way, you can mock entire communcation over\n// the WebSocket. Here is an example that responds to a `\"request\"` with a `\"response\"`.\n// Since we do not call [WebSocketRoute.ConnectToServer] inside the WebSocket route handler, Playwright assumes that\n// WebSocket will be mocked, and opens the WebSocket inside the page automatically.\n// Here is another example that handles JSON messages:\n// **Intercepting**\n// Alternatively, you may want to connect to the actual server, but intercept messages in-between and modify or block\n// them. Calling [WebSocketRoute.ConnectToServer] returns a server-side `WebSocketRoute` instance that you can send\n// messages to, or handle incoming messages.\n// Below is an example that modifies some messages sent by the page to the server. Messages sent from the server to\n// the page are left intact, relying on the default forwarding.\n// After connecting to the server, all **messages are forwarded** between the page and the server by default.\n// However, if you call [WebSocketRoute.OnMessage] on the original route, messages from the page to the server **will\n// not be forwarded** anymore, but should instead be handled by the “[object Object]”.\n// Similarly, calling [WebSocketRoute.OnMessage] on the server-side WebSocket will **stop forwarding messages** from\n// the server to the page, and “[object Object]” should take care of them.\n// The following example blocks some messages in both directions. Since it calls [WebSocketRoute.OnMessage] in both\n// directions, there is no automatic forwarding at all.\n//\n// [`WebSocket`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\ntype WebSocketRoute interface {\n\t// Closes one side of the WebSocket connection.\n\tClose(options ...WebSocketRouteCloseOptions)\n\n\t// By default, routed WebSocket does not connect to the server, so you can mock entire WebSocket communication. This\n\t// method connects to the actual WebSocket server, and returns the server-side [WebSocketRoute] instance, giving the\n\t// ability to send and receive messages from the server.\n\t// Once connected to the server:\n\t//  - Messages received from the server will be **automatically forwarded** to the WebSocket in the page, unless\n\t//   [WebSocketRoute.OnMessage] is called on the server-side `WebSocketRoute`.\n\t//  - Messages sent by the [`WebSocket.send()`] call\n\t//   in the page will be **automatically forwarded** to the server, unless [WebSocketRoute.OnMessage] is called on\n\t//   the original `WebSocketRoute`.\n\t// See examples at the top for more details.\n\t//\n\t// [`WebSocket.send()`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n\tConnectToServer() (WebSocketRoute, error)\n\n\t// Allows to handle [`WebSocket.close`].\n\t// By default, closing one side of the connection, either in the page or on the server, will close the other side.\n\t// However, when [WebSocketRoute.OnClose] handler is set up, the default forwarding of closure is disabled, and\n\t// handler should take care of it.\n\t//\n\t//  handler: Function that will handle WebSocket closure. Received an optional\n\t//    [close code](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close#code) and an optional\n\t//    [close reason](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close#reason).\n\t//\n\t// [`WebSocket.close`]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n\tOnClose(handler func(*int, *string))\n\n\t// This method allows to handle messages that are sent by the WebSocket, either from the page or from the server.\n\t// When called on the original WebSocket route, this method handles messages sent from the page. You can handle this\n\t// messages by responding to them with [WebSocketRoute.Send], forwarding them to the server-side connection returned\n\t// by [WebSocketRoute.ConnectToServer] or do something else.\n\t// Once this method is called, messages are not automatically forwarded to the server or to the page - you should do\n\t// that manually by calling [WebSocketRoute.Send]. See examples at the top for more details.\n\t// Calling this method again will override the handler with a new one.\n\t//\n\t//  handler: Function that will handle messages.\n\tOnMessage(handler func(interface{}))\n\n\t// Sends a message to the WebSocket. When called on the original WebSocket, sends the message to the page. When called\n\t// on the result of [WebSocketRoute.ConnectToServer], sends the message to the server. See examples at the top for\n\t// more details.\n\t//\n\t//  message: Message to send.\n\tSend(message interface{})\n\n\t// URL of the WebSocket created in the page.\n\tURL() string\n}\n\n// The Worker class represents a [WebWorker].\n// `worker` event is emitted on the page object to signal a worker creation. `close` event is emitted on the worker\n// object when the worker is gone.\n//\n// [WebWorker]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\ntype Worker interface {\n\t// Emitted when this dedicated [WebWorker] is\n\t// terminated.\n\t//\n\t// [WebWorker]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n\tOnClose(fn func(Worker))\n\n\t// Returns the return value of “[object Object]”.\n\t// If the function passed to the [Worker.Evaluate] returns a [Promise], then [Worker.Evaluate] would wait for the\n\t// promise to resolve and return its value.\n\t// If the function passed to the [Worker.Evaluate] returns a non-[Serializable] value, then [Worker.Evaluate] returns\n\t// `undefined`. Playwright also supports transferring some additional values that are not serializable by `JSON`:\n\t// `-0`, `NaN`, `Infinity`, `-Infinity`.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluate(expression string, arg ...interface{}) (interface{}, error)\n\n\t// Returns the return value of “[object Object]” as a [JSHandle].\n\t// The only difference between [Worker.Evaluate] and [Worker.EvaluateHandle] is that [Worker.EvaluateHandle] returns\n\t// [JSHandle].\n\t// If the function passed to the [Worker.EvaluateHandle] returns a [Promise], then [Worker.EvaluateHandle] would wait\n\t// for the promise to resolve and return its value.\n\t//\n\t// 1. expression: JavaScript expression to be evaluated in the browser context. If the expression evaluates to a function, the\n\t//    function is automatically invoked.\n\t// 2. arg: Optional argument to pass to “[object Object]”.\n\tEvaluateHandle(expression string, arg ...interface{}) (JSHandle, error)\n\n\tURL() string\n}\n"
        },
        {
          "name": "generated-structs.go",
          "type": "blob",
          "size": 226.6630859375,
          "content": "package playwright\n\ntype APIRequestNewContextOptions struct {\n\t// Methods like [APIRequestContext.Get] take the base URL into consideration by using the\n\t// [`URL()`] constructor for building the corresponding URL.\n\t// Examples:\n\t//  - baseURL: `http://localhost:3000` and sending request to `/bar.html` results in `http://localhost:3000/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo/` and sending request to `./bar.html` results in\n\t//   `http://localhost:3000/foo/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo` (without trailing slash) and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/bar.html`\n\t//\n\t// [`URL()`]: https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n\tBaseURL *string `json:\"baseURL\"`\n\t// TLS Client Authentication allows the server to request a client certificate and verify it.\n\t//\n\t// # Details\n\t//\n\t// An array of client certificates to be used. Each certificate object must have either both `certPath` and `keyPath`,\n\t// a single `pfxPath`, or their corresponding direct value equivalents (`cert` and `key`, or `pfx`). Optionally,\n\t// `passphrase` property should be provided if the certificate is encrypted. The `origin` property should be provided\n\t// with an exact match to the request origin that the certificate is valid for.\n\t// **NOTE** When using WebKit on macOS, accessing `localhost` will not pick up client certificates. You can make it\n\t// work by replacing `localhost` with `local.playwright`.\n\tClientCertificates []ClientCertificate `json:\"clientCertificates\"`\n\t// An object containing additional HTTP headers to be sent with every request. Defaults to none.\n\tExtraHttpHeaders map[string]string `json:\"extraHTTPHeaders\"`\n\t// Credentials for [HTTP authentication]. If no\n\t// origin is specified, the username and password are sent to any servers upon unauthorized responses.\n\t//\n\t// [HTTP authentication]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n\tHttpCredentials *HttpCredentials `json:\"httpCredentials\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Network proxy settings.\n\tProxy *Proxy `json:\"proxy\"`\n\t// Populates context with given storage state. This option can be used to initialize context with logged-in\n\t// information obtained via [BrowserContext.StorageState] or [APIRequestContext.StorageState]. Either a path to the\n\t// file with saved storage, or the value returned by one of [BrowserContext.StorageState] or\n\t// [APIRequestContext.StorageState] methods.\n\tStorageState *StorageState `json:\"storageState\"`\n\t// Populates context with given storage state. This option can be used to initialize context with logged-in\n\t// information obtained via [BrowserContext.StorageState]. Path to the file with saved storage state.\n\tStorageStatePath *string `json:\"storageStatePath\"`\n\t// Maximum time in milliseconds to wait for the response. Defaults to `30000` (30 seconds). Pass `0` to disable\n\t// timeout.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Specific user agent to use in this context.\n\tUserAgent *string `json:\"userAgent\"`\n}\n\ntype APIRequestContextDeleteOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype APIRequestContextDisposeOptions struct {\n\t// The reason to be reported to the operations interrupted by the context disposal.\n\tReason *string `json:\"reason\"`\n}\n\ntype APIRequestContextFetchOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// If set changes the fetch method (e.g. [PUT] or\n\t// [POST]. If not specified, GET method is used.\n\t//\n\t// [PUT]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT\n\t// [POST]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)\n\tMethod *string `json:\"method\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype APIRequestContextGetOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype APIRequestContextHeadOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype APIRequestContextPatchOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype APIRequestContextPostOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype APIRequestContextPutOptions struct {\n\t// Allows to set post data of the request. If the data parameter is an object, it will be serialized to json string\n\t// and `content-type` header will be set to `application/json` if not explicitly set. Otherwise the `content-type`\n\t// header will be set to `application/octet-stream` if not explicitly set.\n\tData interface{} `json:\"data\"`\n\t// Whether to throw on response codes other than 2xx and 3xx. By default response object is returned for all status\n\t// codes.\n\tFailOnStatusCode *bool `json:\"failOnStatusCode\"`\n\t// Provides an object that will be serialized as html form using `application/x-www-form-urlencoded` encoding and sent\n\t// as this request body. If this parameter is specified `content-type` header will be set to\n\t// `application/x-www-form-urlencoded` unless explicitly provided.\n\tForm interface{} `json:\"form\"`\n\t// Allows to set HTTP headers. These headers will apply to the fetched request as well as any redirects initiated by\n\t// it.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// Provides an object that will be serialized as html form using `multipart/form-data` encoding and sent as this\n\t// request body. If this parameter is specified `content-type` header will be set to `multipart/form-data` unless\n\t// explicitly provided. File values can be passed either as\n\t// [`fs.ReadStream`] or as file-like object containing file\n\t// name, mime-type and its content.\n\t//\n\t// [`fs.ReadStream`]: https://nodejs.org/api/fs.html#fs_class_fs_readstream\n\tMultipart interface{} `json:\"multipart\"`\n\t// Query parameters to be sent with the URL.\n\tParams map[string]interface{} `json:\"params\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype StorageState struct {\n\tCookies []Cookie `json:\"cookies\"`\n\tOrigins []Origin `json:\"origins\"`\n}\n\ntype NameValue struct {\n\t// Name of the header.\n\tName string `json:\"name\"`\n\t// Value of the header.\n\tValue string `json:\"value\"`\n}\n\ntype BrowserCloseOptions struct {\n\t// The reason to be reported to the operations interrupted by the browser closure.\n\tReason *string `json:\"reason\"`\n}\n\ntype BrowserNewContextOptions struct {\n\t// Whether to automatically download all the attachments. Defaults to `true` where all the downloads are accepted.\n\tAcceptDownloads *bool `json:\"acceptDownloads\"`\n\t// When using [Page.Goto], [Page.Route], [Page.WaitForURL], [Page.ExpectRequest], or [Page.ExpectResponse] it takes\n\t// the base URL in consideration by using the [`URL()`]\n\t// constructor for building the corresponding URL. Unset by default. Examples:\n\t//  - baseURL: `http://localhost:3000` and navigating to `/bar.html` results in `http://localhost:3000/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo/` and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/foo/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo` (without trailing slash) and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/bar.html`\n\t//\n\t// [`URL()`]: https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n\tBaseURL *string `json:\"baseURL\"`\n\t// Toggles bypassing page's Content-Security-Policy. Defaults to `false`.\n\tBypassCSP *bool `json:\"bypassCSP\"`\n\t// TLS Client Authentication allows the server to request a client certificate and verify it.\n\t//\n\t// # Details\n\t//\n\t// An array of client certificates to be used. Each certificate object must have either both `certPath` and `keyPath`,\n\t// a single `pfxPath`, or their corresponding direct value equivalents (`cert` and `key`, or `pfx`). Optionally,\n\t// `passphrase` property should be provided if the certificate is encrypted. The `origin` property should be provided\n\t// with an exact match to the request origin that the certificate is valid for.\n\t// **NOTE** When using WebKit on macOS, accessing `localhost` will not pick up client certificates. You can make it\n\t// work by replacing `localhost` with `local.playwright`.\n\tClientCertificates []ClientCertificate `json:\"clientCertificates\"`\n\t// Emulates [prefers-colors-scheme]\n\t// media feature, supported values are `light` and `dark`. See [Page.EmulateMedia] for more details. Passing\n\t// `no-override` resets emulation to system defaults. Defaults to `light`.\n\t//\n\t// [prefers-colors-scheme]: https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\n\tColorScheme *ColorScheme `json:\"colorScheme\"`\n\t// Specify device scale factor (can be thought of as dpr). Defaults to `1`. Learn more about\n\t// [emulating devices with device scale factor].\n\t//\n\t// [emulating devices with device scale factor]: https://playwright.dev/docs/emulation#devices\n\tDeviceScaleFactor *float64 `json:\"deviceScaleFactor\"`\n\t// An object containing additional HTTP headers to be sent with every request. Defaults to none.\n\tExtraHttpHeaders map[string]string `json:\"extraHTTPHeaders\"`\n\t// Emulates `forced-colors` media feature, supported values are `active`, `none`. See [Page.EmulateMedia] for\n\t// more details. Passing `no-override` resets emulation to system defaults. Defaults to `none`.\n\tForcedColors *ForcedColors `json:\"forcedColors\"`\n\tGeolocation  *Geolocation  `json:\"geolocation\"`\n\t// Specifies if viewport supports touch events. Defaults to false. Learn more about\n\t// [mobile emulation].\n\t//\n\t// [mobile emulation]: https://playwright.dev/docs/emulation#devices\n\tHasTouch *bool `json:\"hasTouch\"`\n\t// Credentials for [HTTP authentication]. If no\n\t// origin is specified, the username and password are sent to any servers upon unauthorized responses.\n\t//\n\t// [HTTP authentication]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n\tHttpCredentials *HttpCredentials `json:\"httpCredentials\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Whether the `meta viewport` tag is taken into account and touch events are enabled. isMobile is a part of device,\n\t// so you don't actually need to set it manually. Defaults to `false` and is not supported in Firefox. Learn more\n\t// about [mobile emulation].\n\t//\n\t// [mobile emulation]: https://playwright.dev/docs/emulation#ismobile\n\tIsMobile *bool `json:\"isMobile\"`\n\t// Whether or not to enable JavaScript in the context. Defaults to `true`. Learn more about\n\t// [disabling JavaScript].\n\t//\n\t// [disabling JavaScript]: https://playwright.dev/docs/emulation#javascript-enabled\n\tJavaScriptEnabled *bool `json:\"javaScriptEnabled\"`\n\t// Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value,\n\t// `Accept-Language` request header value as well as number and date formatting rules. Defaults to the system default\n\t// locale. Learn more about emulation in our [emulation guide].\n\t//\n\t// [emulation guide]: https://playwright.dev/docs/emulation#locale--timezone\n\tLocale *string `json:\"locale\"`\n\t// Does not enforce fixed viewport, allows resizing window in the headed mode.\n\tNoViewport *bool `json:\"noViewport\"`\n\t// Whether to emulate network being offline. Defaults to `false`. Learn more about\n\t// [network emulation].\n\t//\n\t// [network emulation]: https://playwright.dev/docs/emulation#offline\n\tOffline *bool `json:\"offline\"`\n\t// A list of permissions to grant to all pages in this context. See [BrowserContext.GrantPermissions] for more\n\t// details. Defaults to none.\n\tPermissions []string `json:\"permissions\"`\n\t// Network proxy settings to use with this context. Defaults to none.\n\tProxy *Proxy `json:\"proxy\"`\n\t// Optional setting to control resource content management. If `omit` is specified, content is not persisted. If\n\t// `attach` is specified, resources are persisted as separate files and all of these files are archived along with the\n\t// HAR file. Defaults to `embed`, which stores content inline the HAR file as per HAR specification.\n\tRecordHarContent *HarContentPolicy `json:\"recordHarContent\"`\n\t// When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page,\n\t// cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to `full`.\n\tRecordHarMode *HarMode `json:\"recordHarMode\"`\n\t// Optional setting to control whether to omit request content from the HAR. Defaults to `false`.\n\tRecordHarOmitContent *bool `json:\"recordHarOmitContent\"`\n\t// Enables [HAR] recording for all pages into the specified HAR file\n\t// on the filesystem. If not specified, the HAR is not recorded. Make sure to call [BrowserContext.Close] for the HAR\n\t// to be saved.\n\t//\n\t// [HAR]: http://www.softwareishard.com/blog/har-12-spec\n\tRecordHarPath      *string     `json:\"recordHarPath\"`\n\tRecordHarURLFilter interface{} `json:\"recordHarUrlFilter\"`\n\t// Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded.\n\t// Make sure to await [BrowserContext.Close] for videos to be saved.\n\tRecordVideo *RecordVideo `json:\"recordVideo\"`\n\t// Emulates `prefers-reduced-motion` media feature, supported values are `reduce`, `no-preference`. See\n\t// [Page.EmulateMedia] for more details. Passing `no-override` resets emulation to system defaults. Defaults to\n\t// `no-preference`.\n\tReducedMotion *ReducedMotion `json:\"reducedMotion\"`\n\t// Emulates consistent window screen size available inside web page via `window.screen`. Is only used when the\n\t// “[object Object]” is set.\n\tScreen *Size `json:\"screen\"`\n\t// Whether to allow sites to register Service workers. Defaults to `allow`.\n\t//  - `allow`: [Service Workers] can be\n\t//   registered.\n\t//  - `block`: Playwright will block all registration of Service Workers.\n\t//\n\t// [Service Workers]: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\n\tServiceWorkers *ServiceWorkerPolicy `json:\"serviceWorkers\"`\n\t// Learn more about [storage state and auth].\n\t// Populates context with given storage state. This option can be used to initialize context with logged-in\n\t// information obtained via [BrowserContext.StorageState].\n\t//\n\t// [storage state and auth]: https://playwright.dev/docs/auth\n\tStorageState *OptionalStorageState `json:\"storageState\"`\n\t// Populates context with given storage state. This option can be used to initialize context with logged-in\n\t// information obtained via [BrowserContext.StorageState]. Path to the file with saved storage state.\n\tStorageStatePath *string `json:\"storageStatePath\"`\n\t// If set to true, enables strict selectors mode for this context. In the strict selectors mode all operations on\n\t// selectors that imply single target DOM element will throw when more than one element matches the selector. This\n\t// option does not affect any Locator APIs (Locators are always strict). Defaults to `false`. See [Locator] to learn\n\t// more about the strict mode.\n\tStrictSelectors *bool `json:\"strictSelectors\"`\n\t// Changes the timezone of the context. See\n\t// [ICU's metaZones.txt]\n\t// for a list of supported timezone IDs. Defaults to the system timezone.\n\t//\n\t// [ICU's metaZones.txt]: https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1\n\tTimezoneId *string `json:\"timezoneId\"`\n\t// Specific user agent to use in this context.\n\tUserAgent *string `json:\"userAgent\"`\n\t// Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed\n\t// viewport. Learn more about [viewport emulation].\n\t//\n\t// [viewport emulation]: https://playwright.dev/docs/emulation#viewport\n\tViewport *Size `json:\"viewport\"`\n}\n\ntype BrowserNewPageOptions struct {\n\t// Whether to automatically download all the attachments. Defaults to `true` where all the downloads are accepted.\n\tAcceptDownloads *bool `json:\"acceptDownloads\"`\n\t// When using [Page.Goto], [Page.Route], [Page.WaitForURL], [Page.ExpectRequest], or [Page.ExpectResponse] it takes\n\t// the base URL in consideration by using the [`URL()`]\n\t// constructor for building the corresponding URL. Unset by default. Examples:\n\t//  - baseURL: `http://localhost:3000` and navigating to `/bar.html` results in `http://localhost:3000/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo/` and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/foo/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo` (without trailing slash) and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/bar.html`\n\t//\n\t// [`URL()`]: https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n\tBaseURL *string `json:\"baseURL\"`\n\t// Toggles bypassing page's Content-Security-Policy. Defaults to `false`.\n\tBypassCSP *bool `json:\"bypassCSP\"`\n\t// TLS Client Authentication allows the server to request a client certificate and verify it.\n\t//\n\t// # Details\n\t//\n\t// An array of client certificates to be used. Each certificate object must have either both `certPath` and `keyPath`,\n\t// a single `pfxPath`, or their corresponding direct value equivalents (`cert` and `key`, or `pfx`). Optionally,\n\t// `passphrase` property should be provided if the certificate is encrypted. The `origin` property should be provided\n\t// with an exact match to the request origin that the certificate is valid for.\n\t// **NOTE** When using WebKit on macOS, accessing `localhost` will not pick up client certificates. You can make it\n\t// work by replacing `localhost` with `local.playwright`.\n\tClientCertificates []ClientCertificate `json:\"clientCertificates\"`\n\t// Emulates [prefers-colors-scheme]\n\t// media feature, supported values are `light` and `dark`. See [Page.EmulateMedia] for more details. Passing\n\t// `no-override` resets emulation to system defaults. Defaults to `light`.\n\t//\n\t// [prefers-colors-scheme]: https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\n\tColorScheme *ColorScheme `json:\"colorScheme\"`\n\t// Specify device scale factor (can be thought of as dpr). Defaults to `1`. Learn more about\n\t// [emulating devices with device scale factor].\n\t//\n\t// [emulating devices with device scale factor]: https://playwright.dev/docs/emulation#devices\n\tDeviceScaleFactor *float64 `json:\"deviceScaleFactor\"`\n\t// An object containing additional HTTP headers to be sent with every request. Defaults to none.\n\tExtraHttpHeaders map[string]string `json:\"extraHTTPHeaders\"`\n\t// Emulates `forced-colors` media feature, supported values are `active`, `none`. See [Page.EmulateMedia] for\n\t// more details. Passing `no-override` resets emulation to system defaults. Defaults to `none`.\n\tForcedColors *ForcedColors `json:\"forcedColors\"`\n\tGeolocation  *Geolocation  `json:\"geolocation\"`\n\t// Specifies if viewport supports touch events. Defaults to false. Learn more about\n\t// [mobile emulation].\n\t//\n\t// [mobile emulation]: https://playwright.dev/docs/emulation#devices\n\tHasTouch *bool `json:\"hasTouch\"`\n\t// Credentials for [HTTP authentication]. If no\n\t// origin is specified, the username and password are sent to any servers upon unauthorized responses.\n\t//\n\t// [HTTP authentication]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n\tHttpCredentials *HttpCredentials `json:\"httpCredentials\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Whether the `meta viewport` tag is taken into account and touch events are enabled. isMobile is a part of device,\n\t// so you don't actually need to set it manually. Defaults to `false` and is not supported in Firefox. Learn more\n\t// about [mobile emulation].\n\t//\n\t// [mobile emulation]: https://playwright.dev/docs/emulation#ismobile\n\tIsMobile *bool `json:\"isMobile\"`\n\t// Whether or not to enable JavaScript in the context. Defaults to `true`. Learn more about\n\t// [disabling JavaScript].\n\t//\n\t// [disabling JavaScript]: https://playwright.dev/docs/emulation#javascript-enabled\n\tJavaScriptEnabled *bool `json:\"javaScriptEnabled\"`\n\t// Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value,\n\t// `Accept-Language` request header value as well as number and date formatting rules. Defaults to the system default\n\t// locale. Learn more about emulation in our [emulation guide].\n\t//\n\t// [emulation guide]: https://playwright.dev/docs/emulation#locale--timezone\n\tLocale *string `json:\"locale\"`\n\t// Does not enforce fixed viewport, allows resizing window in the headed mode.\n\tNoViewport *bool `json:\"noViewport\"`\n\t// Whether to emulate network being offline. Defaults to `false`. Learn more about\n\t// [network emulation].\n\t//\n\t// [network emulation]: https://playwright.dev/docs/emulation#offline\n\tOffline *bool `json:\"offline\"`\n\t// A list of permissions to grant to all pages in this context. See [BrowserContext.GrantPermissions] for more\n\t// details. Defaults to none.\n\tPermissions []string `json:\"permissions\"`\n\t// Network proxy settings to use with this context. Defaults to none.\n\tProxy *Proxy `json:\"proxy\"`\n\t// Optional setting to control resource content management. If `omit` is specified, content is not persisted. If\n\t// `attach` is specified, resources are persisted as separate files and all of these files are archived along with the\n\t// HAR file. Defaults to `embed`, which stores content inline the HAR file as per HAR specification.\n\tRecordHarContent *HarContentPolicy `json:\"recordHarContent\"`\n\t// When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page,\n\t// cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to `full`.\n\tRecordHarMode *HarMode `json:\"recordHarMode\"`\n\t// Optional setting to control whether to omit request content from the HAR. Defaults to `false`.\n\tRecordHarOmitContent *bool `json:\"recordHarOmitContent\"`\n\t// Enables [HAR] recording for all pages into the specified HAR file\n\t// on the filesystem. If not specified, the HAR is not recorded. Make sure to call [BrowserContext.Close] for the HAR\n\t// to be saved.\n\t//\n\t// [HAR]: http://www.softwareishard.com/blog/har-12-spec\n\tRecordHarPath      *string     `json:\"recordHarPath\"`\n\tRecordHarURLFilter interface{} `json:\"recordHarUrlFilter\"`\n\t// Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded.\n\t// Make sure to await [BrowserContext.Close] for videos to be saved.\n\tRecordVideo *RecordVideo `json:\"recordVideo\"`\n\t// Emulates `prefers-reduced-motion` media feature, supported values are `reduce`, `no-preference`. See\n\t// [Page.EmulateMedia] for more details. Passing `no-override` resets emulation to system defaults. Defaults to\n\t// `no-preference`.\n\tReducedMotion *ReducedMotion `json:\"reducedMotion\"`\n\t// Emulates consistent window screen size available inside web page via `window.screen`. Is only used when the\n\t// “[object Object]” is set.\n\tScreen *Size `json:\"screen\"`\n\t// Whether to allow sites to register Service workers. Defaults to `allow`.\n\t//  - `allow`: [Service Workers] can be\n\t//   registered.\n\t//  - `block`: Playwright will block all registration of Service Workers.\n\t//\n\t// [Service Workers]: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\n\tServiceWorkers *ServiceWorkerPolicy `json:\"serviceWorkers\"`\n\t// Learn more about [storage state and auth].\n\t// Populates context with given storage state. This option can be used to initialize context with logged-in\n\t// information obtained via [BrowserContext.StorageState].\n\t//\n\t// [storage state and auth]: https://playwright.dev/docs/auth\n\tStorageState *OptionalStorageState `json:\"storageState\"`\n\t// Populates context with given storage state. This option can be used to initialize context with logged-in\n\t// information obtained via [BrowserContext.StorageState]. Path to the file with saved storage state.\n\tStorageStatePath *string `json:\"storageStatePath\"`\n\t// If set to true, enables strict selectors mode for this context. In the strict selectors mode all operations on\n\t// selectors that imply single target DOM element will throw when more than one element matches the selector. This\n\t// option does not affect any Locator APIs (Locators are always strict). Defaults to `false`. See [Locator] to learn\n\t// more about the strict mode.\n\tStrictSelectors *bool `json:\"strictSelectors\"`\n\t// Changes the timezone of the context. See\n\t// [ICU's metaZones.txt]\n\t// for a list of supported timezone IDs. Defaults to the system timezone.\n\t//\n\t// [ICU's metaZones.txt]: https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1\n\tTimezoneId *string `json:\"timezoneId\"`\n\t// Specific user agent to use in this context.\n\tUserAgent *string `json:\"userAgent\"`\n\t// Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed\n\t// viewport. Learn more about [viewport emulation].\n\t//\n\t// [viewport emulation]: https://playwright.dev/docs/emulation#viewport\n\tViewport *Size `json:\"viewport\"`\n}\n\ntype BrowserStartTracingOptions struct {\n\t// specify custom categories to use instead of default.\n\tCategories []string `json:\"categories\"`\n\t// Optional, if specified, tracing includes screenshots of the given page.\n\tPage Page `json:\"page\"`\n\t// A path to write the trace file to.\n\tPath *string `json:\"path\"`\n\t// captures screenshots in the trace.\n\tScreenshots *bool `json:\"screenshots\"`\n}\n\ntype OptionalCookie struct {\n\tName  string `json:\"name\"`\n\tValue string `json:\"value\"`\n\t// Either url or domain / path are required. Optional.\n\tURL *string `json:\"url\"`\n\t// For the cookie to apply to all subdomains as well, prefix domain with a dot, like this: \".example.com\". Either url\n\t// or domain / path are required. Optional.\n\tDomain *string `json:\"domain\"`\n\t// Either url or domain / path are required Optional.\n\tPath *string `json:\"path\"`\n\t// Unix time in seconds. Optional.\n\tExpires *float64 `json:\"expires\"`\n\t// Optional.\n\tHttpOnly *bool `json:\"httpOnly\"`\n\t// Optional.\n\tSecure *bool `json:\"secure\"`\n\t// Optional.\n\tSameSite *SameSiteAttribute `json:\"sameSite\"`\n}\n\ntype Script struct {\n\t// Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working\n\t// directory. Optional.\n\tPath *string `json:\"path\"`\n\t// Raw script content. Optional.\n\tContent *string `json:\"content\"`\n}\n\ntype BrowserContextClearCookiesOptions struct {\n\t// Only removes cookies with the given domain.\n\tDomain interface{} `json:\"domain\"`\n\t// Only removes cookies with the given name.\n\tName interface{} `json:\"name\"`\n\t// Only removes cookies with the given path.\n\tPath interface{} `json:\"path\"`\n}\n\ntype BrowserContextCloseOptions struct {\n\t// The reason to be reported to the operations interrupted by the context closure.\n\tReason *string `json:\"reason\"`\n}\n\ntype Cookie struct {\n\tName   string `json:\"name\"`\n\tValue  string `json:\"value\"`\n\tDomain string `json:\"domain\"`\n\tPath   string `json:\"path\"`\n\t// Unix time in seconds.\n\tExpires  float64            `json:\"expires\"`\n\tHttpOnly bool               `json:\"httpOnly\"`\n\tSecure   bool               `json:\"secure\"`\n\tSameSite *SameSiteAttribute `json:\"sameSite\"`\n}\n\ntype BrowserContextGrantPermissionsOptions struct {\n\t// The [origin] to grant permissions to, e.g. \"https://example.com\".\n\tOrigin *string `json:\"origin\"`\n}\n\ntype BrowserContextRouteFromHAROptions struct {\n\t//  - If set to 'abort' any request not found in the HAR file will be aborted.\n\t//  - If set to 'fallback' falls through to the next route handler in the handler chain.\n\t// Defaults to abort.\n\tNotFound *HarNotFound `json:\"notFound\"`\n\t// If specified, updates the given HAR with the actual network information instead of serving from file. The file is\n\t// written to disk when [BrowserContext.Close] is called.\n\tUpdate *bool `json:\"update\"`\n\t// Optional setting to control resource content management. If `attach` is specified, resources are persisted as\n\t// separate files or entries in the ZIP archive. If `embed` is specified, content is stored inline the HAR file.\n\tUpdateContent *RouteFromHarUpdateContentPolicy `json:\"updateContent\"`\n\t// When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page,\n\t// cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to\n\t// `minimal`.\n\tUpdateMode *HarMode `json:\"updateMode\"`\n\t// A glob pattern, regular expression or predicate to match the request URL. Only requests with URL matching the\n\t// pattern will be served from the HAR file. If not specified, all requests are served from the HAR file.\n\tURL interface{} `json:\"url\"`\n}\n\ntype Geolocation struct {\n\t// Latitude between -90 and 90.\n\tLatitude float64 `json:\"latitude\"`\n\t// Longitude between -180 and 180.\n\tLongitude float64 `json:\"longitude\"`\n\t// Non-negative accuracy value. Defaults to `0`.\n\tAccuracy *float64 `json:\"accuracy\"`\n}\n\ntype BrowserContextUnrouteAllOptions struct {\n\t// Specifies whether to wait for already running handlers and what to do if they throw errors:\n\t//  - `default` - do not wait for current handler calls (if any) to finish, if unrouted handler throws, it may\n\t//   result in unhandled error\n\t//  - `wait` - wait for current handler calls (if any) to finish\n\t//  - `ignoreErrors` - do not wait for current handler calls (if any) to finish, all errors thrown by the handlers\n\t//   after unrouting are silently caught\n\tBehavior *UnrouteBehavior `json:\"behavior\"`\n}\n\ntype BrowserContextExpectConsoleMessageOptions struct {\n\t// Receives the [ConsoleMessage] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(ConsoleMessage) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype BrowserContextExpectEventOptions struct {\n\t// Receives the event data and resolves to truthy value when the waiting should resolve.\n\tPredicate interface{} `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype BrowserContextExpectPageOptions struct {\n\t// Receives the [Page] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(Page) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype BrowserContextWaitForEventOptions struct {\n\t// Receives the event data and resolves to truthy value when the waiting should resolve.\n\tPredicate interface{} `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype BrowserTypeConnectOptions struct {\n\t// This option exposes network available on the connecting client to the browser being connected to. Consists of a\n\t// list of rules separated by comma.\n\t// Available rules:\n\t//  1. Hostname pattern, for example: `example.com`, `*.org:99`, `x.*.y.com`, `*foo.org`.\n\t//  2. IP literal, for example: `127.0.0.1`, `0.0.0.0:99`, `[::1]`, `[0:0::1]:99`.\n\t//  3. `<loopback>` that matches local loopback interfaces: `localhost`, `*.localhost`, `127.0.0.1`, `[::1]`.\n\t// Some common examples:\n\t//  4. `\"*\"` to expose all network.\n\t//  5. `\"<loopback>\"` to expose localhost network.\n\t//  6. `\"*.test.internal-domain,*.staging.internal-domain,<loopback>\"` to expose test/staging deployments and\n\t//    localhost.\n\tExposeNetwork *string `json:\"exposeNetwork\"`\n\t// Additional HTTP headers to be sent with web socket connect request. Optional.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going\n\t// on. Defaults to 0.\n\tSlowMo *float64 `json:\"slowMo\"`\n\t// Maximum time in milliseconds to wait for the connection to be established. Defaults to `0` (no timeout).\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype BrowserTypeConnectOverCDPOptions struct {\n\t// Additional HTTP headers to be sent with connect request. Optional.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going\n\t// on. Defaults to 0.\n\tSlowMo *float64 `json:\"slowMo\"`\n\t// Maximum time in milliseconds to wait for the connection to be established. Defaults to `30000` (30 seconds). Pass\n\t// `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype BrowserTypeLaunchOptions struct {\n\t// **NOTE** Use custom browser args at your own risk, as some of them may break Playwright functionality.\n\t// Additional arguments to pass to the browser instance. The list of Chromium flags can be found\n\t// [here].\n\t//\n\t// [here]: https://peter.sh/experiments/chromium-command-line-switches/\n\tArgs []string `json:\"args\"`\n\t// Browser distribution channel.\n\t// Use \"chromium\" to [opt in to new headless mode].\n\t// Use \"chrome\", \"chrome-beta\", \"chrome-dev\", \"chrome-canary\", \"msedge\", \"msedge-beta\", \"msedge-dev\", or\n\t// \"msedge-canary\" to use branded [Google Chrome and Microsoft Edge].\n\t//\n\t// [opt in to new headless mode]: https://playwright.dev/docs/browsers#opt-in-to-new-headless-mode\n\t// [Google Chrome and Microsoft Edge]: https://playwright.dev/docs/browsers#google-chrome--microsoft-edge\n\tChannel *string `json:\"channel\"`\n\t// Enable Chromium sandboxing. Defaults to `false`.\n\tChromiumSandbox *bool `json:\"chromiumSandbox\"`\n\t// **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the\n\t// “[object Object]” option will be set `false`.\n\t//\n\t// Deprecated: Use [debugging tools] instead.\n\t//\n\t// [debugging tools]: https://playwright.dev/docs/debug\n\tDevtools *bool `json:\"devtools\"`\n\t// If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and\n\t// is deleted when browser is closed. In either case, the downloads are deleted when the browser context they were\n\t// created in is closed.\n\tDownloadsPath *string `json:\"downloadsPath\"`\n\t// Specify environment variables that will be visible to the browser. Defaults to `process.env`.\n\tEnv map[string]string `json:\"env\"`\n\t// Path to a browser executable to run instead of the bundled one. If “[object Object]” is a relative path, then it is\n\t// resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium,\n\t// Firefox or WebKit, use at your own risk.\n\tExecutablePath *string `json:\"executablePath\"`\n\t// Firefox user preferences. Learn more about the Firefox user preferences at\n\t// [`about:config`].\n\t//\n\t// [`about:config`]: https://support.mozilla.org/en-US/kb/about-config-editor-firefox\n\tFirefoxUserPrefs map[string]interface{} `json:\"firefoxUserPrefs\"`\n\t// Close the browser process on SIGHUP. Defaults to `true`.\n\tHandleSIGHUP *bool `json:\"handleSIGHUP\"`\n\t// Close the browser process on Ctrl-C. Defaults to `true`.\n\tHandleSIGINT *bool `json:\"handleSIGINT\"`\n\t// Close the browser process on SIGTERM. Defaults to `true`.\n\tHandleSIGTERM *bool `json:\"handleSIGTERM\"`\n\t// Whether to run browser in headless mode. More details for\n\t// [Chromium] and\n\t// [Firefox]. Defaults to `true` unless the\n\t// “[object Object]” option is `true`.\n\t//\n\t// [Chromium]: https://developers.google.com/web/updates/2017/04/headless-chrome\n\t// [Firefox]: https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode\n\tHeadless *bool `json:\"headless\"`\n\t// If `true`, Playwright does not pass its own configurations args and only uses the ones from “[object Object]”.\n\t// Dangerous option; use with care. Defaults to `false`.\n\tIgnoreAllDefaultArgs *bool `json:\"ignoreAllDefaultArgs\"`\n\t// If `true`, Playwright does not pass its own configurations args and only uses the ones from “[object Object]”.\n\t// Dangerous option; use with care.\n\tIgnoreDefaultArgs []string `json:\"ignoreDefaultArgs\"`\n\t// Network proxy settings.\n\tProxy *Proxy `json:\"proxy\"`\n\t// Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going\n\t// on.\n\tSlowMo *float64 `json:\"slowMo\"`\n\t// Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0`\n\t// to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n\t// If specified, traces are saved into this directory.\n\tTracesDir *string `json:\"tracesDir\"`\n}\n\ntype BrowserTypeLaunchPersistentContextOptions struct {\n\t// Whether to automatically download all the attachments. Defaults to `true` where all the downloads are accepted.\n\tAcceptDownloads *bool `json:\"acceptDownloads\"`\n\t// **NOTE** Use custom browser args at your own risk, as some of them may break Playwright functionality.\n\t// Additional arguments to pass to the browser instance. The list of Chromium flags can be found\n\t// [here].\n\t//\n\t// [here]: https://peter.sh/experiments/chromium-command-line-switches/\n\tArgs []string `json:\"args\"`\n\t// When using [Page.Goto], [Page.Route], [Page.WaitForURL], [Page.ExpectRequest], or [Page.ExpectResponse] it takes\n\t// the base URL in consideration by using the [`URL()`]\n\t// constructor for building the corresponding URL. Unset by default. Examples:\n\t//  - baseURL: `http://localhost:3000` and navigating to `/bar.html` results in `http://localhost:3000/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo/` and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/foo/bar.html`\n\t//  - baseURL: `http://localhost:3000/foo` (without trailing slash) and navigating to `./bar.html` results in\n\t//   `http://localhost:3000/bar.html`\n\t//\n\t// [`URL()`]: https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n\tBaseURL *string `json:\"baseURL\"`\n\t// Toggles bypassing page's Content-Security-Policy. Defaults to `false`.\n\tBypassCSP *bool `json:\"bypassCSP\"`\n\t// Browser distribution channel.\n\t// Use \"chromium\" to [opt in to new headless mode].\n\t// Use \"chrome\", \"chrome-beta\", \"chrome-dev\", \"chrome-canary\", \"msedge\", \"msedge-beta\", \"msedge-dev\", or\n\t// \"msedge-canary\" to use branded [Google Chrome and Microsoft Edge].\n\t//\n\t// [opt in to new headless mode]: https://playwright.dev/docs/browsers#opt-in-to-new-headless-mode\n\t// [Google Chrome and Microsoft Edge]: https://playwright.dev/docs/browsers#google-chrome--microsoft-edge\n\tChannel *string `json:\"channel\"`\n\t// Enable Chromium sandboxing. Defaults to `false`.\n\tChromiumSandbox *bool `json:\"chromiumSandbox\"`\n\t// TLS Client Authentication allows the server to request a client certificate and verify it.\n\t//\n\t// # Details\n\t//\n\t// An array of client certificates to be used. Each certificate object must have either both `certPath` and `keyPath`,\n\t// a single `pfxPath`, or their corresponding direct value equivalents (`cert` and `key`, or `pfx`). Optionally,\n\t// `passphrase` property should be provided if the certificate is encrypted. The `origin` property should be provided\n\t// with an exact match to the request origin that the certificate is valid for.\n\t// **NOTE** When using WebKit on macOS, accessing `localhost` will not pick up client certificates. You can make it\n\t// work by replacing `localhost` with `local.playwright`.\n\tClientCertificates []ClientCertificate `json:\"clientCertificates\"`\n\t// Emulates [prefers-colors-scheme]\n\t// media feature, supported values are `light` and `dark`. See [Page.EmulateMedia] for more details. Passing\n\t// `no-override` resets emulation to system defaults. Defaults to `light`.\n\t//\n\t// [prefers-colors-scheme]: https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\n\tColorScheme *ColorScheme `json:\"colorScheme\"`\n\t// Specify device scale factor (can be thought of as dpr). Defaults to `1`. Learn more about\n\t// [emulating devices with device scale factor].\n\t//\n\t// [emulating devices with device scale factor]: https://playwright.dev/docs/emulation#devices\n\tDeviceScaleFactor *float64 `json:\"deviceScaleFactor\"`\n\t// **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the\n\t// “[object Object]” option will be set `false`.\n\t//\n\t// Deprecated: Use [debugging tools] instead.\n\t//\n\t// [debugging tools]: https://playwright.dev/docs/debug\n\tDevtools *bool `json:\"devtools\"`\n\t// If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and\n\t// is deleted when browser is closed. In either case, the downloads are deleted when the browser context they were\n\t// created in is closed.\n\tDownloadsPath *string `json:\"downloadsPath\"`\n\t// Specify environment variables that will be visible to the browser. Defaults to `process.env`.\n\tEnv map[string]string `json:\"env\"`\n\t// Path to a browser executable to run instead of the bundled one. If “[object Object]” is a relative path, then it is\n\t// resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium,\n\t// Firefox or WebKit, use at your own risk.\n\tExecutablePath *string `json:\"executablePath\"`\n\t// An object containing additional HTTP headers to be sent with every request. Defaults to none.\n\tExtraHttpHeaders map[string]string `json:\"extraHTTPHeaders\"`\n\t// Firefox user preferences. Learn more about the Firefox user preferences at\n\t// [`about:config`].\n\t//\n\t// [`about:config`]: https://support.mozilla.org/en-US/kb/about-config-editor-firefox\n\tFirefoxUserPrefs map[string]interface{} `json:\"firefoxUserPrefs\"`\n\t// Emulates `forced-colors` media feature, supported values are `active`, `none`. See [Page.EmulateMedia] for\n\t// more details. Passing `no-override` resets emulation to system defaults. Defaults to `none`.\n\tForcedColors *ForcedColors `json:\"forcedColors\"`\n\tGeolocation  *Geolocation  `json:\"geolocation\"`\n\t// Close the browser process on SIGHUP. Defaults to `true`.\n\tHandleSIGHUP *bool `json:\"handleSIGHUP\"`\n\t// Close the browser process on Ctrl-C. Defaults to `true`.\n\tHandleSIGINT *bool `json:\"handleSIGINT\"`\n\t// Close the browser process on SIGTERM. Defaults to `true`.\n\tHandleSIGTERM *bool `json:\"handleSIGTERM\"`\n\t// Specifies if viewport supports touch events. Defaults to false. Learn more about\n\t// [mobile emulation].\n\t//\n\t// [mobile emulation]: https://playwright.dev/docs/emulation#devices\n\tHasTouch *bool `json:\"hasTouch\"`\n\t// Whether to run browser in headless mode. More details for\n\t// [Chromium] and\n\t// [Firefox]. Defaults to `true` unless the\n\t// “[object Object]” option is `true`.\n\t//\n\t// [Chromium]: https://developers.google.com/web/updates/2017/04/headless-chrome\n\t// [Firefox]: https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode\n\tHeadless *bool `json:\"headless\"`\n\t// Credentials for [HTTP authentication]. If no\n\t// origin is specified, the username and password are sent to any servers upon unauthorized responses.\n\t//\n\t// [HTTP authentication]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n\tHttpCredentials *HttpCredentials `json:\"httpCredentials\"`\n\t// If `true`, Playwright does not pass its own configurations args and only uses the ones from “[object Object]”.\n\t// Dangerous option; use with care. Defaults to `false`.\n\tIgnoreAllDefaultArgs *bool `json:\"ignoreAllDefaultArgs\"`\n\t// If `true`, Playwright does not pass its own configurations args and only uses the ones from “[object Object]”.\n\t// Dangerous option; use with care.\n\tIgnoreDefaultArgs []string `json:\"ignoreDefaultArgs\"`\n\t// Whether to ignore HTTPS errors when sending network requests. Defaults to `false`.\n\tIgnoreHttpsErrors *bool `json:\"ignoreHTTPSErrors\"`\n\t// Whether the `meta viewport` tag is taken into account and touch events are enabled. isMobile is a part of device,\n\t// so you don't actually need to set it manually. Defaults to `false` and is not supported in Firefox. Learn more\n\t// about [mobile emulation].\n\t//\n\t// [mobile emulation]: https://playwright.dev/docs/emulation#ismobile\n\tIsMobile *bool `json:\"isMobile\"`\n\t// Whether or not to enable JavaScript in the context. Defaults to `true`. Learn more about\n\t// [disabling JavaScript].\n\t//\n\t// [disabling JavaScript]: https://playwright.dev/docs/emulation#javascript-enabled\n\tJavaScriptEnabled *bool `json:\"javaScriptEnabled\"`\n\t// Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value,\n\t// `Accept-Language` request header value as well as number and date formatting rules. Defaults to the system default\n\t// locale. Learn more about emulation in our [emulation guide].\n\t//\n\t// [emulation guide]: https://playwright.dev/docs/emulation#locale--timezone\n\tLocale *string `json:\"locale\"`\n\t// Does not enforce fixed viewport, allows resizing window in the headed mode.\n\tNoViewport *bool `json:\"noViewport\"`\n\t// Whether to emulate network being offline. Defaults to `false`. Learn more about\n\t// [network emulation].\n\t//\n\t// [network emulation]: https://playwright.dev/docs/emulation#offline\n\tOffline *bool `json:\"offline\"`\n\t// A list of permissions to grant to all pages in this context. See [BrowserContext.GrantPermissions] for more\n\t// details. Defaults to none.\n\tPermissions []string `json:\"permissions\"`\n\t// Network proxy settings.\n\tProxy *Proxy `json:\"proxy\"`\n\t// Optional setting to control resource content management. If `omit` is specified, content is not persisted. If\n\t// `attach` is specified, resources are persisted as separate files and all of these files are archived along with the\n\t// HAR file. Defaults to `embed`, which stores content inline the HAR file as per HAR specification.\n\tRecordHarContent *HarContentPolicy `json:\"recordHarContent\"`\n\t// When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page,\n\t// cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to `full`.\n\tRecordHarMode *HarMode `json:\"recordHarMode\"`\n\t// Optional setting to control whether to omit request content from the HAR. Defaults to `false`.\n\tRecordHarOmitContent *bool `json:\"recordHarOmitContent\"`\n\t// Enables [HAR] recording for all pages into the specified HAR file\n\t// on the filesystem. If not specified, the HAR is not recorded. Make sure to call [BrowserContext.Close] for the HAR\n\t// to be saved.\n\t//\n\t// [HAR]: http://www.softwareishard.com/blog/har-12-spec\n\tRecordHarPath      *string     `json:\"recordHarPath\"`\n\tRecordHarURLFilter interface{} `json:\"recordHarUrlFilter\"`\n\t// Enables video recording for all pages into `recordVideo.dir` directory. If not specified videos are not recorded.\n\t// Make sure to await [BrowserContext.Close] for videos to be saved.\n\tRecordVideo *RecordVideo `json:\"recordVideo\"`\n\t// Emulates `prefers-reduced-motion` media feature, supported values are `reduce`, `no-preference`. See\n\t// [Page.EmulateMedia] for more details. Passing `no-override` resets emulation to system defaults. Defaults to\n\t// `no-preference`.\n\tReducedMotion *ReducedMotion `json:\"reducedMotion\"`\n\t// Emulates consistent window screen size available inside web page via `window.screen`. Is only used when the\n\t// “[object Object]” is set.\n\tScreen *Size `json:\"screen\"`\n\t// Whether to allow sites to register Service workers. Defaults to `allow`.\n\t//  - `allow`: [Service Workers] can be\n\t//   registered.\n\t//  - `block`: Playwright will block all registration of Service Workers.\n\t//\n\t// [Service Workers]: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API\n\tServiceWorkers *ServiceWorkerPolicy `json:\"serviceWorkers\"`\n\t// Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going\n\t// on.\n\tSlowMo *float64 `json:\"slowMo\"`\n\t// If set to true, enables strict selectors mode for this context. In the strict selectors mode all operations on\n\t// selectors that imply single target DOM element will throw when more than one element matches the selector. This\n\t// option does not affect any Locator APIs (Locators are always strict). Defaults to `false`. See [Locator] to learn\n\t// more about the strict mode.\n\tStrictSelectors *bool `json:\"strictSelectors\"`\n\t// Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0`\n\t// to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Changes the timezone of the context. See\n\t// [ICU's metaZones.txt]\n\t// for a list of supported timezone IDs. Defaults to the system timezone.\n\t//\n\t// [ICU's metaZones.txt]: https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1\n\tTimezoneId *string `json:\"timezoneId\"`\n\t// If specified, traces are saved into this directory.\n\tTracesDir *string `json:\"tracesDir\"`\n\t// Specific user agent to use in this context.\n\tUserAgent *string `json:\"userAgent\"`\n\t// Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed\n\t// viewport. Learn more about [viewport emulation].\n\t//\n\t// [viewport emulation]: https://playwright.dev/docs/emulation#viewport\n\tViewport *Size `json:\"viewport\"`\n}\n\ntype ClockInstallOptions struct {\n\t// Time to initialize with, current system time by default.\n\tTime interface{} `json:\"time\"`\n}\n\ntype ConsoleMessageLocation struct {\n\t// URL of the resource.\n\tURL string `json:\"url\"`\n\t// 0-based line number in the resource.\n\tLineNumber int `json:\"lineNumber\"`\n\t// 0-based column number in the resource.\n\tColumnNumber int `json:\"columnNumber\"`\n}\n\ntype Rect struct {\n\t// the x coordinate of the element in pixels.\n\tX float64 `json:\"x\"`\n\t// the y coordinate of the element in pixels.\n\tY float64 `json:\"y\"`\n\t// the width of the element in pixels.\n\tWidth float64 `json:\"width\"`\n\t// the height of the element in pixels.\n\tHeight float64 `json:\"height\"`\n}\n\ntype ElementHandleCheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleClickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleDblclickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleFillOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleHoverOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleInputValueOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandlePressOptions struct {\n\t// Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleScreenshotOptions struct {\n\t// When set to `\"disabled\"`, stops CSS animations, CSS transitions and Web Animations. Animations get different\n\t// treatment depending on their duration:\n\t//  - finite animations are fast-forwarded to completion, so they'll fire `transitionend` event.\n\t//  - infinite animations are canceled to initial state, and then played over after the screenshot.\n\t// Defaults to `\"allow\"` that leaves animations untouched.\n\tAnimations *ScreenshotAnimations `json:\"animations\"`\n\t// When set to `\"hide\"`, screenshot will hide text caret. When set to `\"initial\"`, text caret behavior will not be\n\t// changed.  Defaults to `\"hide\"`.\n\tCaret *ScreenshotCaret `json:\"caret\"`\n\t// Specify locators that should be masked when the screenshot is taken. Masked elements will be overlaid with a pink\n\t// box `#FF00FF` (customized by “[object Object]”) that completely covers its bounding box.\n\tMask []Locator `json:\"mask\"`\n\t// Specify the color of the overlay box for masked elements, in\n\t// [CSS color format]. Default color is pink `#FF00FF`.\n\t//\n\t// [CSS color format]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\n\tMaskColor *string `json:\"maskColor\"`\n\t// Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.\n\t// Defaults to `false`.\n\tOmitBackground *bool `json:\"omitBackground\"`\n\t// The file path to save the image to. The screenshot type will be inferred from file extension. If “[object Object]”\n\t// is a relative path, then it is resolved relative to the current working directory. If no path is provided, the\n\t// image won't be saved to the disk.\n\tPath *string `json:\"path\"`\n\t// The quality of the image, between 0-100. Not applicable to `png` images.\n\tQuality *int `json:\"quality\"`\n\t// When set to `\"css\"`, screenshot will have a single pixel per each css pixel on the page. For high-dpi devices, this\n\t// will keep screenshots small. Using `\"device\"` option will produce a single pixel per each device pixel, so\n\t// screenshots of high-dpi devices will be twice as large or even larger.\n\t// Defaults to `\"device\"`.\n\tScale *ScreenshotScale `json:\"scale\"`\n\t// Text of the stylesheet to apply while making the screenshot. This is where you can hide dynamic elements, make\n\t// elements invisible or change their properties to help you creating repeatable screenshots. This stylesheet pierces\n\t// the Shadow DOM and applies to the inner frames.\n\tStyle *string `json:\"style\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Specify screenshot type, defaults to `png`.\n\tType *ScreenshotType `json:\"type\"`\n}\n\ntype ElementHandleScrollIntoViewIfNeededOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleSelectOptionOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleSelectTextOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleSetCheckedOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleSetInputFilesOptions struct {\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleTapOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleTypeOptions struct {\n\t// Time to wait between key presses in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleUncheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype ElementHandleWaitForElementStateOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype ElementHandleWaitForSelectorOptions struct {\n\t// Defaults to `visible`. Can be either:\n\t//  - `attached` - wait for element to be present in DOM.\n\t//  - `detached` - wait for element to not be present in DOM.\n\t//  - `visible` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element\n\t//   without any content or with `display:none` has an empty bounding box and is not considered visible.\n\t//  - `hidden` - wait for element to be either detached from DOM, or have an empty bounding box or\n\t//   `visibility:hidden`. This is opposite to the `visible` option.\n\tState *WaitForSelectorState `json:\"state\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FileChooserSetFilesOptions struct {\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameAddScriptTagOptions struct {\n\t// Raw JavaScript content to be injected into frame.\n\tContent *string `json:\"content\"`\n\t// Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative\n\t// to the current working directory.\n\tPath *string `json:\"path\"`\n\t// Script type. Use 'module' in order to load a JavaScript ES6 module. See\n\t// [script] for more details.\n\t//\n\t// [script]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n\tType *string `json:\"type\"`\n\t// URL of a script to be added.\n\tURL *string `json:\"url\"`\n}\n\ntype FrameAddStyleTagOptions struct {\n\t// Raw CSS content to be injected into frame.\n\tContent *string `json:\"content\"`\n\t// Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to the\n\t// current working directory.\n\tPath *string `json:\"path\"`\n\t// URL of the `<link>` tag.\n\tURL *string `json:\"url\"`\n}\n\ntype FrameCheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameClickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameDblclickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameDispatchEventOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameDragAndDropOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not\n\t// specified, some visible point of the element is used.\n\tSourcePosition *Position `json:\"sourcePosition\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Drops on the target element at this point relative to the top-left corner of the element's padding box. If not\n\t// specified, some visible point of the element is used.\n\tTargetPosition *Position `json:\"targetPosition\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameEvalOnSelectorOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n}\n\ntype FrameFillOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameFocusOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameGetAttributeOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameGetByAltTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameGetByLabelOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameGetByPlaceholderOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameGetByRoleOptions struct {\n\t// An attribute that is usually set by `aria-checked` or native `<input type=checkbox>` controls.\n\t// Learn more about [`aria-checked`].\n\t//\n\t// [`aria-checked`]: https://www.w3.org/TR/wai-aria-1.2/#aria-checked\n\tChecked *bool `json:\"checked\"`\n\t// An attribute that is usually set by `aria-disabled` or `disabled`.\n\t// **NOTE** Unlike most other attributes, `disabled` is inherited through the DOM hierarchy. Learn more about\n\t// [`aria-disabled`].\n\t//\n\t// [`aria-disabled`]: https://www.w3.org/TR/wai-aria-1.2/#aria-disabled\n\tDisabled *bool `json:\"disabled\"`\n\t// Whether “[object Object]” is matched exactly: case-sensitive and whole-string. Defaults to false. Ignored when\n\t// “[object Object]” is a regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n\t// An attribute that is usually set by `aria-expanded`.\n\t// Learn more about [`aria-expanded`].\n\t//\n\t// [`aria-expanded`]: https://www.w3.org/TR/wai-aria-1.2/#aria-expanded\n\tExpanded *bool `json:\"expanded\"`\n\t// Option that controls whether hidden elements are matched. By default, only non-hidden elements, as\n\t// [defined by ARIA], are matched by role selector.\n\t// Learn more about [`aria-hidden`].\n\t//\n\t// [defined by ARIA]: https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion\n\t// [`aria-hidden`]: https://www.w3.org/TR/wai-aria-1.2/#aria-hidden\n\tIncludeHidden *bool `json:\"includeHidden\"`\n\t// A number attribute that is usually present for roles `heading`, `listitem`, `row`, `treeitem`, with default values\n\t// for `<h1>-<h6>` elements.\n\t// Learn more about [`aria-level`].\n\t//\n\t// [`aria-level`]: https://www.w3.org/TR/wai-aria-1.2/#aria-level\n\tLevel *int `json:\"level\"`\n\t// Option to match the [accessible name]. By default, matching is\n\t// case-insensitive and searches for a substring, use “[object Object]” to control this behavior.\n\t// Learn more about [accessible name].\n\t//\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\tName interface{} `json:\"name\"`\n\t// An attribute that is usually set by `aria-pressed`.\n\t// Learn more about [`aria-pressed`].\n\t//\n\t// [`aria-pressed`]: https://www.w3.org/TR/wai-aria-1.2/#aria-pressed\n\tPressed *bool `json:\"pressed\"`\n\t// An attribute that is usually set by `aria-selected`.\n\t// Learn more about [`aria-selected`].\n\t//\n\t// [`aria-selected`]: https://www.w3.org/TR/wai-aria-1.2/#aria-selected\n\tSelected *bool `json:\"selected\"`\n}\n\ntype FrameGetByTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameGetByTitleOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameGotoOptions struct {\n\t// Referer header value. If provided it will take preference over the referer header value set by\n\t// [Page.SetExtraHTTPHeaders].\n\tReferer *string `json:\"referer\"`\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype FrameHoverOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameInnerHTMLOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameInnerTextOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameInputValueOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameIsCheckedOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameIsDisabledOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameIsEditableOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameIsEnabledOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameIsHiddenOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t//\n\t// Deprecated: This option is ignored. [Frame.IsHidden] does not wait for the element to become hidden and returns immediately.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameIsVisibleOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t//\n\t// Deprecated: This option is ignored. [Frame.IsVisible] does not wait for the element to become visible and returns immediately.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameLocatorOptions struct {\n\t// Narrows down the results of the method to those which contain elements matching this relative locator. For example,\n\t// `article` that has `text=Playwright` matches `<article><div>Playwright</div></article>`.\n\t// Inner locator **must be relative** to the outer locator and is queried starting with the outer locator match, not\n\t// the document root. For example, you can find `content` that has `div` in\n\t// `<article><content><div>Playwright</div></content></article>`. However, looking for `content` that has `article\n\t// div` will fail, because the inner locator must be relative and should not use any elements outside the `content`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHas Locator `json:\"has\"`\n\t// Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the\n\t// outer one. For example, `article` that does not have `div` matches `<article><span>Playwright</span></article>`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHasNot Locator `json:\"hasNot\"`\n\t// Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element.\n\t// When passed a [string], matching is case-insensitive and searches for a substring.\n\tHasNotText interface{} `json:\"hasNotText\"`\n\t// Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When\n\t// passed a [string], matching is case-insensitive and searches for a substring. For example, `\"Playwright\"` matches\n\t// `<article><div>Playwright</div></article>`.\n\tHasText interface{} `json:\"hasText\"`\n}\n\ntype FramePressOptions struct {\n\t// Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameQuerySelectorOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n}\n\ntype FrameSelectOptionOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameSetCheckedOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameSetContentOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype FrameSetInputFilesOptions struct {\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameTapOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameTextContentOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameTypeOptions struct {\n\t// Time to wait between key presses in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameUncheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype FrameWaitForFunctionOptions struct {\n\t// If “[object Object]” is `raf`, then “[object Object]” is constantly executed in `requestAnimationFrame` callback.\n\t// If “[object Object]” is a number, then it is treated as an interval in milliseconds at which the function would be\n\t// executed. Defaults to `raf`.\n\tPolling interface{} `json:\"polling\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameWaitForLoadStateOptions struct {\n\t// Optional load state to wait for, defaults to `load`. If the state has been already reached while loading current\n\t// document, the method resolves immediately. Can be one of:\n\t//  - `load` - wait for the `load` event to be fired.\n\t//  - `domcontentloaded` - wait for the `DOMContentLoaded` event to be fired.\n\t//  - `networkidle` - **DISCOURAGED** wait until there are no network connections for at least `500` ms. Don't use\n\t//   this method for testing, rely on web assertions to assess readiness instead.\n\tState *LoadState `json:\"state\"`\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameExpectNavigationOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation. Note that if\n\t// the parameter is a string without wildcard characters, the method will wait for navigation to URL that is exactly\n\t// equal to the string.\n\tURL interface{} `json:\"url\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype FrameWaitForSelectorOptions struct {\n\t// Defaults to `visible`. Can be either:\n\t//  - `attached` - wait for element to be present in DOM.\n\t//  - `detached` - wait for element to not be present in DOM.\n\t//  - `visible` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element\n\t//   without any content or with `display:none` has an empty bounding box and is not considered visible.\n\t//  - `hidden` - wait for element to be either detached from DOM, or have an empty bounding box or\n\t//   `visibility:hidden`. This is opposite to the `visible` option.\n\tState *WaitForSelectorState `json:\"state\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype FrameWaitForURLOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype FrameLocatorGetByAltTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameLocatorGetByLabelOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameLocatorGetByPlaceholderOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameLocatorGetByRoleOptions struct {\n\t// An attribute that is usually set by `aria-checked` or native `<input type=checkbox>` controls.\n\t// Learn more about [`aria-checked`].\n\t//\n\t// [`aria-checked`]: https://www.w3.org/TR/wai-aria-1.2/#aria-checked\n\tChecked *bool `json:\"checked\"`\n\t// An attribute that is usually set by `aria-disabled` or `disabled`.\n\t// **NOTE** Unlike most other attributes, `disabled` is inherited through the DOM hierarchy. Learn more about\n\t// [`aria-disabled`].\n\t//\n\t// [`aria-disabled`]: https://www.w3.org/TR/wai-aria-1.2/#aria-disabled\n\tDisabled *bool `json:\"disabled\"`\n\t// Whether “[object Object]” is matched exactly: case-sensitive and whole-string. Defaults to false. Ignored when\n\t// “[object Object]” is a regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n\t// An attribute that is usually set by `aria-expanded`.\n\t// Learn more about [`aria-expanded`].\n\t//\n\t// [`aria-expanded`]: https://www.w3.org/TR/wai-aria-1.2/#aria-expanded\n\tExpanded *bool `json:\"expanded\"`\n\t// Option that controls whether hidden elements are matched. By default, only non-hidden elements, as\n\t// [defined by ARIA], are matched by role selector.\n\t// Learn more about [`aria-hidden`].\n\t//\n\t// [defined by ARIA]: https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion\n\t// [`aria-hidden`]: https://www.w3.org/TR/wai-aria-1.2/#aria-hidden\n\tIncludeHidden *bool `json:\"includeHidden\"`\n\t// A number attribute that is usually present for roles `heading`, `listitem`, `row`, `treeitem`, with default values\n\t// for `<h1>-<h6>` elements.\n\t// Learn more about [`aria-level`].\n\t//\n\t// [`aria-level`]: https://www.w3.org/TR/wai-aria-1.2/#aria-level\n\tLevel *int `json:\"level\"`\n\t// Option to match the [accessible name]. By default, matching is\n\t// case-insensitive and searches for a substring, use “[object Object]” to control this behavior.\n\t// Learn more about [accessible name].\n\t//\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\tName interface{} `json:\"name\"`\n\t// An attribute that is usually set by `aria-pressed`.\n\t// Learn more about [`aria-pressed`].\n\t//\n\t// [`aria-pressed`]: https://www.w3.org/TR/wai-aria-1.2/#aria-pressed\n\tPressed *bool `json:\"pressed\"`\n\t// An attribute that is usually set by `aria-selected`.\n\t// Learn more about [`aria-selected`].\n\t//\n\t// [`aria-selected`]: https://www.w3.org/TR/wai-aria-1.2/#aria-selected\n\tSelected *bool `json:\"selected\"`\n}\n\ntype FrameLocatorGetByTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameLocatorGetByTitleOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype FrameLocatorLocatorOptions struct {\n\t// Narrows down the results of the method to those which contain elements matching this relative locator. For example,\n\t// `article` that has `text=Playwright` matches `<article><div>Playwright</div></article>`.\n\t// Inner locator **must be relative** to the outer locator and is queried starting with the outer locator match, not\n\t// the document root. For example, you can find `content` that has `div` in\n\t// `<article><content><div>Playwright</div></content></article>`. However, looking for `content` that has `article\n\t// div` will fail, because the inner locator must be relative and should not use any elements outside the `content`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHas Locator `json:\"has\"`\n\t// Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the\n\t// outer one. For example, `article` that does not have `div` matches `<article><span>Playwright</span></article>`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHasNot Locator `json:\"hasNot\"`\n\t// Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element.\n\t// When passed a [string], matching is case-insensitive and searches for a substring.\n\tHasNotText interface{} `json:\"hasNotText\"`\n\t// Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When\n\t// passed a [string], matching is case-insensitive and searches for a substring. For example, `\"Playwright\"` matches\n\t// `<article><div>Playwright</div></article>`.\n\tHasText interface{} `json:\"hasText\"`\n}\n\ntype KeyboardPressOptions struct {\n\t// Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n}\n\ntype KeyboardTypeOptions struct {\n\t// Time to wait between key presses in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n}\n\ntype LocatorAriaSnapshotOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorBlurOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorBoundingBoxOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorCheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorClearOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorClickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorDblclickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorDispatchEventOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorDragToOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not\n\t// specified, some visible point of the element is used.\n\tSourcePosition *Position `json:\"sourcePosition\"`\n\t// Drops on the target element at this point relative to the top-left corner of the element's padding box. If not\n\t// specified, some visible point of the element is used.\n\tTargetPosition *Position `json:\"targetPosition\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorElementHandleOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorEvaluateOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorEvaluateHandleOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorFillOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorFilterOptions struct {\n\t// Narrows down the results of the method to those which contain elements matching this relative locator. For example,\n\t// `article` that has `text=Playwright` matches `<article><div>Playwright</div></article>`.\n\t// Inner locator **must be relative** to the outer locator and is queried starting with the outer locator match, not\n\t// the document root. For example, you can find `content` that has `div` in\n\t// `<article><content><div>Playwright</div></content></article>`. However, looking for `content` that has `article\n\t// div` will fail, because the inner locator must be relative and should not use any elements outside the `content`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHas Locator `json:\"has\"`\n\t// Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the\n\t// outer one. For example, `article` that does not have `div` matches `<article><span>Playwright</span></article>`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHasNot Locator `json:\"hasNot\"`\n\t// Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element.\n\t// When passed a [string], matching is case-insensitive and searches for a substring.\n\tHasNotText interface{} `json:\"hasNotText\"`\n\t// Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When\n\t// passed a [string], matching is case-insensitive and searches for a substring. For example, `\"Playwright\"` matches\n\t// `<article><div>Playwright</div></article>`.\n\tHasText interface{} `json:\"hasText\"`\n}\n\ntype LocatorFocusOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorGetAttributeOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorGetByAltTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype LocatorGetByLabelOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype LocatorGetByPlaceholderOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype LocatorGetByRoleOptions struct {\n\t// An attribute that is usually set by `aria-checked` or native `<input type=checkbox>` controls.\n\t// Learn more about [`aria-checked`].\n\t//\n\t// [`aria-checked`]: https://www.w3.org/TR/wai-aria-1.2/#aria-checked\n\tChecked *bool `json:\"checked\"`\n\t// An attribute that is usually set by `aria-disabled` or `disabled`.\n\t// **NOTE** Unlike most other attributes, `disabled` is inherited through the DOM hierarchy. Learn more about\n\t// [`aria-disabled`].\n\t//\n\t// [`aria-disabled`]: https://www.w3.org/TR/wai-aria-1.2/#aria-disabled\n\tDisabled *bool `json:\"disabled\"`\n\t// Whether “[object Object]” is matched exactly: case-sensitive and whole-string. Defaults to false. Ignored when\n\t// “[object Object]” is a regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n\t// An attribute that is usually set by `aria-expanded`.\n\t// Learn more about [`aria-expanded`].\n\t//\n\t// [`aria-expanded`]: https://www.w3.org/TR/wai-aria-1.2/#aria-expanded\n\tExpanded *bool `json:\"expanded\"`\n\t// Option that controls whether hidden elements are matched. By default, only non-hidden elements, as\n\t// [defined by ARIA], are matched by role selector.\n\t// Learn more about [`aria-hidden`].\n\t//\n\t// [defined by ARIA]: https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion\n\t// [`aria-hidden`]: https://www.w3.org/TR/wai-aria-1.2/#aria-hidden\n\tIncludeHidden *bool `json:\"includeHidden\"`\n\t// A number attribute that is usually present for roles `heading`, `listitem`, `row`, `treeitem`, with default values\n\t// for `<h1>-<h6>` elements.\n\t// Learn more about [`aria-level`].\n\t//\n\t// [`aria-level`]: https://www.w3.org/TR/wai-aria-1.2/#aria-level\n\tLevel *int `json:\"level\"`\n\t// Option to match the [accessible name]. By default, matching is\n\t// case-insensitive and searches for a substring, use “[object Object]” to control this behavior.\n\t// Learn more about [accessible name].\n\t//\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\tName interface{} `json:\"name\"`\n\t// An attribute that is usually set by `aria-pressed`.\n\t// Learn more about [`aria-pressed`].\n\t//\n\t// [`aria-pressed`]: https://www.w3.org/TR/wai-aria-1.2/#aria-pressed\n\tPressed *bool `json:\"pressed\"`\n\t// An attribute that is usually set by `aria-selected`.\n\t// Learn more about [`aria-selected`].\n\t//\n\t// [`aria-selected`]: https://www.w3.org/TR/wai-aria-1.2/#aria-selected\n\tSelected *bool `json:\"selected\"`\n}\n\ntype LocatorGetByTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype LocatorGetByTitleOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype LocatorHoverOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorInnerHTMLOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorInnerTextOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorInputValueOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorIsCheckedOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorIsDisabledOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorIsEditableOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorIsEnabledOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorIsHiddenOptions struct {\n\t//\n\t// Deprecated: This option is ignored. [Locator.IsHidden] does not wait for the element to become hidden and returns immediately.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorIsVisibleOptions struct {\n\t//\n\t// Deprecated: This option is ignored. [Locator.IsVisible] does not wait for the element to become visible and returns immediately.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorLocatorOptions struct {\n\t// Narrows down the results of the method to those which contain elements matching this relative locator. For example,\n\t// `article` that has `text=Playwright` matches `<article><div>Playwright</div></article>`.\n\t// Inner locator **must be relative** to the outer locator and is queried starting with the outer locator match, not\n\t// the document root. For example, you can find `content` that has `div` in\n\t// `<article><content><div>Playwright</div></content></article>`. However, looking for `content` that has `article\n\t// div` will fail, because the inner locator must be relative and should not use any elements outside the `content`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHas Locator `json:\"has\"`\n\t// Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the\n\t// outer one. For example, `article` that does not have `div` matches `<article><span>Playwright</span></article>`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHasNot Locator `json:\"hasNot\"`\n\t// Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element.\n\t// When passed a [string], matching is case-insensitive and searches for a substring.\n\tHasNotText interface{} `json:\"hasNotText\"`\n\t// Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When\n\t// passed a [string], matching is case-insensitive and searches for a substring. For example, `\"Playwright\"` matches\n\t// `<article><div>Playwright</div></article>`.\n\tHasText interface{} `json:\"hasText\"`\n}\n\ntype LocatorPressOptions struct {\n\t// Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorPressSequentiallyOptions struct {\n\t// Time to wait between key presses in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorScreenshotOptions struct {\n\t// When set to `\"disabled\"`, stops CSS animations, CSS transitions and Web Animations. Animations get different\n\t// treatment depending on their duration:\n\t//  - finite animations are fast-forwarded to completion, so they'll fire `transitionend` event.\n\t//  - infinite animations are canceled to initial state, and then played over after the screenshot.\n\t// Defaults to `\"allow\"` that leaves animations untouched.\n\tAnimations *ScreenshotAnimations `json:\"animations\"`\n\t// When set to `\"hide\"`, screenshot will hide text caret. When set to `\"initial\"`, text caret behavior will not be\n\t// changed.  Defaults to `\"hide\"`.\n\tCaret *ScreenshotCaret `json:\"caret\"`\n\t// Specify locators that should be masked when the screenshot is taken. Masked elements will be overlaid with a pink\n\t// box `#FF00FF` (customized by “[object Object]”) that completely covers its bounding box.\n\tMask []Locator `json:\"mask\"`\n\t// Specify the color of the overlay box for masked elements, in\n\t// [CSS color format]. Default color is pink `#FF00FF`.\n\t//\n\t// [CSS color format]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\n\tMaskColor *string `json:\"maskColor\"`\n\t// Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.\n\t// Defaults to `false`.\n\tOmitBackground *bool `json:\"omitBackground\"`\n\t// The file path to save the image to. The screenshot type will be inferred from file extension. If “[object Object]”\n\t// is a relative path, then it is resolved relative to the current working directory. If no path is provided, the\n\t// image won't be saved to the disk.\n\tPath *string `json:\"path\"`\n\t// The quality of the image, between 0-100. Not applicable to `png` images.\n\tQuality *int `json:\"quality\"`\n\t// When set to `\"css\"`, screenshot will have a single pixel per each css pixel on the page. For high-dpi devices, this\n\t// will keep screenshots small. Using `\"device\"` option will produce a single pixel per each device pixel, so\n\t// screenshots of high-dpi devices will be twice as large or even larger.\n\t// Defaults to `\"device\"`.\n\tScale *ScreenshotScale `json:\"scale\"`\n\t// Text of the stylesheet to apply while making the screenshot. This is where you can hide dynamic elements, make\n\t// elements invisible or change their properties to help you creating repeatable screenshots. This stylesheet pierces\n\t// the Shadow DOM and applies to the inner frames.\n\tStyle *string `json:\"style\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Specify screenshot type, defaults to `png`.\n\tType *ScreenshotType `json:\"type\"`\n}\n\ntype LocatorScrollIntoViewIfNeededOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorSelectOptionOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorSelectTextOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorSetCheckedOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorSetInputFilesOptions struct {\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorTapOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorTextContentOptions struct {\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorTypeOptions struct {\n\t// Time to wait between key presses in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorUncheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype LocatorWaitForOptions struct {\n\t// Defaults to `visible`. Can be either:\n\t//  - `attached` - wait for element to be present in DOM.\n\t//  - `detached` - wait for element to not be present in DOM.\n\t//  - `visible` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element\n\t//   without any content or with `display:none` has an empty bounding box and is not considered visible.\n\t//  - `hidden` - wait for element to be either detached from DOM, or have an empty bounding box or\n\t//   `visibility:hidden`. This is opposite to the `visible` option.\n\tState *WaitForSelectorState `json:\"state\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeAttachedOptions struct {\n\tAttached *bool `json:\"attached\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeCheckedOptions struct {\n\tChecked *bool `json:\"checked\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeDisabledOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeEditableOptions struct {\n\tEditable *bool `json:\"editable\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeEmptyOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeEnabledOptions struct {\n\tEnabled *bool `json:\"enabled\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeFocusedOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeHiddenOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeInViewportOptions struct {\n\t// The minimal ratio of the element to intersect viewport. If equals to `0`, then element should intersect viewport at\n\t// any positive ratio. Defaults to `0`.\n\tRatio *float64 `json:\"ratio\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToBeVisibleOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n\tVisible *bool    `json:\"visible\"`\n}\n\ntype LocatorAssertionsToContainTextOptions struct {\n\t// Whether to perform case-insensitive match. “[object Object]” option takes precedence over the corresponding regular\n\t// expression flag if specified.\n\tIgnoreCase *bool `json:\"ignoreCase\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Whether to use `element.innerText` instead of `element.textContent` when retrieving DOM node text.\n\tUseInnerText *bool `json:\"useInnerText\"`\n}\n\ntype LocatorAssertionsToHaveAccessibleDescriptionOptions struct {\n\t// Whether to perform case-insensitive match. “[object Object]” option takes precedence over the corresponding regular\n\t// expression flag if specified.\n\tIgnoreCase *bool `json:\"ignoreCase\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveAccessibleNameOptions struct {\n\t// Whether to perform case-insensitive match. “[object Object]” option takes precedence over the corresponding regular\n\t// expression flag if specified.\n\tIgnoreCase *bool `json:\"ignoreCase\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveAttributeOptions struct {\n\t// Whether to perform case-insensitive match. “[object Object]” option takes precedence over the corresponding regular\n\t// expression flag if specified.\n\tIgnoreCase *bool `json:\"ignoreCase\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveClassOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveCountOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveCSSOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveIdOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveJSPropertyOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveRoleOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveTextOptions struct {\n\t// Whether to perform case-insensitive match. “[object Object]” option takes precedence over the corresponding regular\n\t// expression flag if specified.\n\tIgnoreCase *bool `json:\"ignoreCase\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Whether to use `element.innerText` instead of `element.textContent` when retrieving DOM node text.\n\tUseInnerText *bool `json:\"useInnerText\"`\n}\n\ntype LocatorAssertionsToHaveValueOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToHaveValuesOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype LocatorAssertionsToMatchAriaSnapshotOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype MouseClickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n}\n\ntype MouseDblclickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n}\n\ntype MouseDownOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n}\n\ntype MouseMoveOptions struct {\n\t// Defaults to 1. Sends intermediate `mousemove` events.\n\tSteps *int `json:\"steps\"`\n}\n\ntype MouseUpOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n}\n\ntype PageAddScriptTagOptions struct {\n\t// Raw JavaScript content to be injected into frame.\n\tContent *string `json:\"content\"`\n\t// Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative\n\t// to the current working directory.\n\tPath *string `json:\"path\"`\n\t// Script type. Use 'module' in order to load a JavaScript ES6 module. See\n\t// [script] for more details.\n\t//\n\t// [script]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n\tType *string `json:\"type\"`\n\t// URL of a script to be added.\n\tURL *string `json:\"url\"`\n}\n\ntype PageAddStyleTagOptions struct {\n\t// Raw CSS content to be injected into frame.\n\tContent *string `json:\"content\"`\n\t// Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to the\n\t// current working directory.\n\tPath *string `json:\"path\"`\n\t// URL of the `<link>` tag.\n\tURL *string `json:\"url\"`\n}\n\ntype PageCheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageClickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// defaults to 1. See [UIEvent.Detail].\n\tClickCount *int `json:\"clickCount\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageCloseOptions struct {\n\t// The reason to be reported to the operations interrupted by the page closure.\n\tReason *string `json:\"reason\"`\n\t// Defaults to `false`. Whether to run the\n\t// [before unload] page handlers.\n\t//\n\t// [before unload]: https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload\n\tRunBeforeUnload *bool `json:\"runBeforeUnload\"`\n}\n\ntype PageDblclickOptions struct {\n\t// Defaults to `left`.\n\tButton *MouseButton `json:\"button\"`\n\t// Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageDispatchEventOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageDragAndDropOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Clicks on the source element at this point relative to the top-left corner of the element's padding box. If not\n\t// specified, some visible point of the element is used.\n\tSourcePosition *Position `json:\"sourcePosition\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Drops on the target element at this point relative to the top-left corner of the element's padding box. If not\n\t// specified, some visible point of the element is used.\n\tTargetPosition *Position `json:\"targetPosition\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageEmulateMediaOptions struct {\n\t// Emulates [prefers-colors-scheme]\n\t// media feature, supported values are `light` and `dark`. Passing `no-override` disables color scheme\n\t// emulation. `no-preference` is deprecated.\n\t//\n\t// [prefers-colors-scheme]: https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme\n\tColorScheme  *ColorScheme  `json:\"colorScheme\"`\n\tForcedColors *ForcedColors `json:\"forcedColors\"`\n\t// Changes the CSS media type of the page. The only allowed values are `screen`, `print` and `no-override`.\n\t// Passing `no-override` disables CSS media emulation.\n\tMedia *Media `json:\"media\"`\n\t// Emulates `prefers-reduced-motion` media feature, supported values are `reduce`, `no-preference`. Passing\n\t// `no-override` disables reduced motion emulation.\n\tReducedMotion *ReducedMotion `json:\"reducedMotion\"`\n}\n\ntype PageEvalOnSelectorOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n}\n\ntype PageFillOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageFocusOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageFrameOptions struct {\n\t// Frame name specified in the `iframe`'s `name` attribute. Optional.\n\tName *string `json:\"name\"`\n\t// A glob pattern, regex pattern or predicate receiving frame's `url` as a [URL] object. Optional.\n\tURL interface{} `json:\"url\"`\n}\n\ntype PageGetAttributeOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageGetByAltTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype PageGetByLabelOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype PageGetByPlaceholderOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype PageGetByRoleOptions struct {\n\t// An attribute that is usually set by `aria-checked` or native `<input type=checkbox>` controls.\n\t// Learn more about [`aria-checked`].\n\t//\n\t// [`aria-checked`]: https://www.w3.org/TR/wai-aria-1.2/#aria-checked\n\tChecked *bool `json:\"checked\"`\n\t// An attribute that is usually set by `aria-disabled` or `disabled`.\n\t// **NOTE** Unlike most other attributes, `disabled` is inherited through the DOM hierarchy. Learn more about\n\t// [`aria-disabled`].\n\t//\n\t// [`aria-disabled`]: https://www.w3.org/TR/wai-aria-1.2/#aria-disabled\n\tDisabled *bool `json:\"disabled\"`\n\t// Whether “[object Object]” is matched exactly: case-sensitive and whole-string. Defaults to false. Ignored when\n\t// “[object Object]” is a regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n\t// An attribute that is usually set by `aria-expanded`.\n\t// Learn more about [`aria-expanded`].\n\t//\n\t// [`aria-expanded`]: https://www.w3.org/TR/wai-aria-1.2/#aria-expanded\n\tExpanded *bool `json:\"expanded\"`\n\t// Option that controls whether hidden elements are matched. By default, only non-hidden elements, as\n\t// [defined by ARIA], are matched by role selector.\n\t// Learn more about [`aria-hidden`].\n\t//\n\t// [defined by ARIA]: https://www.w3.org/TR/wai-aria-1.2/#tree_exclusion\n\t// [`aria-hidden`]: https://www.w3.org/TR/wai-aria-1.2/#aria-hidden\n\tIncludeHidden *bool `json:\"includeHidden\"`\n\t// A number attribute that is usually present for roles `heading`, `listitem`, `row`, `treeitem`, with default values\n\t// for `<h1>-<h6>` elements.\n\t// Learn more about [`aria-level`].\n\t//\n\t// [`aria-level`]: https://www.w3.org/TR/wai-aria-1.2/#aria-level\n\tLevel *int `json:\"level\"`\n\t// Option to match the [accessible name]. By default, matching is\n\t// case-insensitive and searches for a substring, use “[object Object]” to control this behavior.\n\t// Learn more about [accessible name].\n\t//\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\t// [accessible name]: https://w3c.github.io/accname/#dfn-accessible-name\n\tName interface{} `json:\"name\"`\n\t// An attribute that is usually set by `aria-pressed`.\n\t// Learn more about [`aria-pressed`].\n\t//\n\t// [`aria-pressed`]: https://www.w3.org/TR/wai-aria-1.2/#aria-pressed\n\tPressed *bool `json:\"pressed\"`\n\t// An attribute that is usually set by `aria-selected`.\n\t// Learn more about [`aria-selected`].\n\t//\n\t// [`aria-selected`]: https://www.w3.org/TR/wai-aria-1.2/#aria-selected\n\tSelected *bool `json:\"selected\"`\n}\n\ntype PageGetByTextOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype PageGetByTitleOptions struct {\n\t// Whether to find an exact match: case-sensitive and whole-string. Default to false. Ignored when locating by a\n\t// regular expression. Note that exact match still trims whitespace.\n\tExact *bool `json:\"exact\"`\n}\n\ntype PageGoBackOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageGoForwardOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageGotoOptions struct {\n\t// Referer header value. If provided it will take preference over the referer header value set by\n\t// [Page.SetExtraHTTPHeaders].\n\tReferer *string `json:\"referer\"`\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageHoverOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageInnerHTMLOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageInnerTextOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageInputValueOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageIsCheckedOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageIsDisabledOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageIsEditableOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageIsEnabledOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageIsHiddenOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t//\n\t// Deprecated: This option is ignored. [Page.IsHidden] does not wait for the element to become hidden and returns immediately.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageIsVisibleOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t//\n\t// Deprecated: This option is ignored. [Page.IsVisible] does not wait for the element to become visible and returns immediately.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageLocatorOptions struct {\n\t// Narrows down the results of the method to those which contain elements matching this relative locator. For example,\n\t// `article` that has `text=Playwright` matches `<article><div>Playwright</div></article>`.\n\t// Inner locator **must be relative** to the outer locator and is queried starting with the outer locator match, not\n\t// the document root. For example, you can find `content` that has `div` in\n\t// `<article><content><div>Playwright</div></content></article>`. However, looking for `content` that has `article\n\t// div` will fail, because the inner locator must be relative and should not use any elements outside the `content`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHas Locator `json:\"has\"`\n\t// Matches elements that do not contain an element that matches an inner locator. Inner locator is queried against the\n\t// outer one. For example, `article` that does not have `div` matches `<article><span>Playwright</span></article>`.\n\t// Note that outer and inner locators must belong to the same frame. Inner locator must not contain [FrameLocator]s.\n\tHasNot Locator `json:\"hasNot\"`\n\t// Matches elements that do not contain specified text somewhere inside, possibly in a child or a descendant element.\n\t// When passed a [string], matching is case-insensitive and searches for a substring.\n\tHasNotText interface{} `json:\"hasNotText\"`\n\t// Matches elements containing specified text somewhere inside, possibly in a child or a descendant element. When\n\t// passed a [string], matching is case-insensitive and searches for a substring. For example, `\"Playwright\"` matches\n\t// `<article><div>Playwright</div></article>`.\n\tHasText interface{} `json:\"hasText\"`\n}\n\ntype PagePdfOptions struct {\n\t// Display header and footer. Defaults to `false`.\n\tDisplayHeaderFooter *bool `json:\"displayHeaderFooter\"`\n\t// HTML template for the print footer. Should use the same format as the “[object Object]”.\n\tFooterTemplate *string `json:\"footerTemplate\"`\n\t// Paper format. If set, takes priority over “[object Object]” or “[object Object]” options. Defaults to 'Letter'.\n\tFormat *string `json:\"format\"`\n\t// HTML template for the print header. Should be valid HTML markup with following classes used to inject printing\n\t// values into them:\n\t//  - `date` formatted print date\n\t//  - `title` document title\n\t//  - `url` document location\n\t//  - `pageNumber` current page number\n\t//  - `totalPages` total pages in the document\n\tHeaderTemplate *string `json:\"headerTemplate\"`\n\t// Paper height, accepts values labeled with units.\n\tHeight *string `json:\"height\"`\n\t// Paper orientation. Defaults to `false`.\n\tLandscape *bool `json:\"landscape\"`\n\t// Paper margins, defaults to none.\n\tMargin *Margin `json:\"margin\"`\n\t// Whether or not to embed the document outline into the PDF. Defaults to `false`.\n\tOutline *bool `json:\"outline\"`\n\t// Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages.\n\tPageRanges *string `json:\"pageRanges\"`\n\t// The file path to save the PDF to. If “[object Object]” is a relative path, then it is resolved relative to the\n\t// current working directory. If no path is provided, the PDF won't be saved to the disk.\n\tPath *string `json:\"path\"`\n\t// Give any CSS `@page` size declared in the page priority over what is declared in “[object Object]” and\n\t// “[object Object]” or “[object Object]” options. Defaults to `false`, which will scale the content to fit the paper\n\t// size.\n\tPreferCSSPageSize *bool `json:\"preferCSSPageSize\"`\n\t// Print background graphics. Defaults to `false`.\n\tPrintBackground *bool `json:\"printBackground\"`\n\t// Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.\n\tScale *float64 `json:\"scale\"`\n\t// Whether or not to generate tagged (accessible) PDF. Defaults to `false`.\n\tTagged *bool `json:\"tagged\"`\n\t// Paper width, accepts values labeled with units.\n\tWidth *string `json:\"width\"`\n}\n\ntype PagePressOptions struct {\n\t// Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You\n\t// can opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as\n\t// navigating to inaccessible pages. Defaults to `false`.\n\t//\n\t// Deprecated: This option will default to `true` in the future.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageQuerySelectorOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n}\n\ntype PageAddLocatorHandlerOptions struct {\n\t// By default, after calling the handler Playwright will wait until the overlay becomes hidden, and only then\n\t// Playwright will continue with the action/assertion that triggered the handler. This option allows to opt-out of\n\t// this behavior, so that overlay can stay visible after the handler has run.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// Specifies the maximum number of times this handler should be called. Unlimited by default.\n\tTimes *int `json:\"times\"`\n}\n\ntype PageReloadOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageRouteFromHAROptions struct {\n\t//  - If set to 'abort' any request not found in the HAR file will be aborted.\n\t//  - If set to 'fallback' missing requests will be sent to the network.\n\t// Defaults to abort.\n\tNotFound *HarNotFound `json:\"notFound\"`\n\t// If specified, updates the given HAR with the actual network information instead of serving from file. The file is\n\t// written to disk when [BrowserContext.Close] is called.\n\tUpdate *bool `json:\"update\"`\n\t// Optional setting to control resource content management. If `attach` is specified, resources are persisted as\n\t// separate files or entries in the ZIP archive. If `embed` is specified, content is stored inline the HAR file.\n\tUpdateContent *RouteFromHarUpdateContentPolicy `json:\"updateContent\"`\n\t// When set to `minimal`, only record information necessary for routing from HAR. This omits sizes, timing, page,\n\t// cookies, security and other types of HAR information that are not used when replaying from HAR. Defaults to\n\t// `minimal`.\n\tUpdateMode *HarMode `json:\"updateMode\"`\n\t// A glob pattern, regular expression or predicate to match the request URL. Only requests with URL matching the\n\t// pattern will be served from the HAR file. If not specified, all requests are served from the HAR file.\n\tURL interface{} `json:\"url\"`\n}\n\ntype PageScreenshotOptions struct {\n\t// When set to `\"disabled\"`, stops CSS animations, CSS transitions and Web Animations. Animations get different\n\t// treatment depending on their duration:\n\t//  - finite animations are fast-forwarded to completion, so they'll fire `transitionend` event.\n\t//  - infinite animations are canceled to initial state, and then played over after the screenshot.\n\t// Defaults to `\"allow\"` that leaves animations untouched.\n\tAnimations *ScreenshotAnimations `json:\"animations\"`\n\t// When set to `\"hide\"`, screenshot will hide text caret. When set to `\"initial\"`, text caret behavior will not be\n\t// changed.  Defaults to `\"hide\"`.\n\tCaret *ScreenshotCaret `json:\"caret\"`\n\t// An object which specifies clipping of the resulting image.\n\tClip *Rect `json:\"clip\"`\n\t// When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to\n\t// `false`.\n\tFullPage *bool `json:\"fullPage\"`\n\t// Specify locators that should be masked when the screenshot is taken. Masked elements will be overlaid with a pink\n\t// box `#FF00FF` (customized by “[object Object]”) that completely covers its bounding box.\n\tMask []Locator `json:\"mask\"`\n\t// Specify the color of the overlay box for masked elements, in\n\t// [CSS color format]. Default color is pink `#FF00FF`.\n\t//\n\t// [CSS color format]: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\n\tMaskColor *string `json:\"maskColor\"`\n\t// Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.\n\t// Defaults to `false`.\n\tOmitBackground *bool `json:\"omitBackground\"`\n\t// The file path to save the image to. The screenshot type will be inferred from file extension. If “[object Object]”\n\t// is a relative path, then it is resolved relative to the current working directory. If no path is provided, the\n\t// image won't be saved to the disk.\n\tPath *string `json:\"path\"`\n\t// The quality of the image, between 0-100. Not applicable to `png` images.\n\tQuality *int `json:\"quality\"`\n\t// When set to `\"css\"`, screenshot will have a single pixel per each css pixel on the page. For high-dpi devices, this\n\t// will keep screenshots small. Using `\"device\"` option will produce a single pixel per each device pixel, so\n\t// screenshots of high-dpi devices will be twice as large or even larger.\n\t// Defaults to `\"device\"`.\n\tScale *ScreenshotScale `json:\"scale\"`\n\t// Text of the stylesheet to apply while making the screenshot. This is where you can hide dynamic elements, make\n\t// elements invisible or change their properties to help you creating repeatable screenshots. This stylesheet pierces\n\t// the Shadow DOM and applies to the inner frames.\n\tStyle *string `json:\"style\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// Specify screenshot type, defaults to `png`.\n\tType *ScreenshotType `json:\"type\"`\n}\n\ntype PageSelectOptionOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageSetCheckedOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageSetContentOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageSetInputFilesOptions struct {\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageTapOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores\n\t// current modifiers back. If not specified, currently pressed modifiers are used. \"ControlOrMeta\" resolves to\n\t// \"Control\" on Windows and Linux and to \"Meta\" on macOS.\n\tModifiers []KeyboardModifier `json:\"modifiers\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it. Note that keyboard\n\t// `modifiers` will be pressed regardless of `trial` to allow testing elements which are only visible when those keys\n\t// are pressed.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageTextContentOptions struct {\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageTypeOptions struct {\n\t// Time to wait between key presses in milliseconds. Defaults to 0.\n\tDelay *float64 `json:\"delay\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageUncheckOptions struct {\n\t// Whether to bypass the [actionability] checks. Defaults to `false`.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tForce *bool `json:\"force\"`\n\t// This option has no effect.\n\t//\n\t// Deprecated: This option has no effect.\n\tNoWaitAfter *bool `json:\"noWaitAfter\"`\n\t// A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of\n\t// the element.\n\tPosition *Position `json:\"position\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When set, this method only performs the [actionability] checks and skips the action. Defaults\n\t// to `false`. Useful to wait until the element is ready for the action without performing it.\n\t//\n\t// [actionability]: https://playwright.dev/docs/actionability\n\tTrial *bool `json:\"trial\"`\n}\n\ntype PageUnrouteAllOptions struct {\n\t// Specifies whether to wait for already running handlers and what to do if they throw errors:\n\t//  - `default` - do not wait for current handler calls (if any) to finish, if unrouted handler throws, it may\n\t//   result in unhandled error\n\t//  - `wait` - wait for current handler calls (if any) to finish\n\t//  - `ignoreErrors` - do not wait for current handler calls (if any) to finish, all errors thrown by the handlers\n\t//   after unrouting are silently caught\n\tBehavior *UnrouteBehavior `json:\"behavior\"`\n}\n\ntype Size struct {\n\t// page width in pixels.\n\tWidth int `json:\"width\"`\n\t// page height in pixels.\n\tHeight int `json:\"height\"`\n}\n\ntype PageExpectConsoleMessageOptions struct {\n\t// Receives the [ConsoleMessage] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(ConsoleMessage) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectDownloadOptions struct {\n\t// Receives the [Download] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(Download) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectEventOptions struct {\n\t// Receives the event data and resolves to truthy value when the waiting should resolve.\n\tPredicate interface{} `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectFileChooserOptions struct {\n\t// Receives the [FileChooser] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(FileChooser) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageWaitForFunctionOptions struct {\n\t// If “[object Object]” is `raf`, then “[object Object]” is constantly executed in `requestAnimationFrame` callback.\n\t// If “[object Object]” is a number, then it is treated as an interval in milliseconds at which the function would be\n\t// executed. Defaults to `raf`.\n\tPolling interface{} `json:\"polling\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageWaitForLoadStateOptions struct {\n\t// Optional load state to wait for, defaults to `load`. If the state has been already reached while loading current\n\t// document, the method resolves immediately. Can be one of:\n\t//  - `load` - wait for the `load` event to be fired.\n\t//  - `domcontentloaded` - wait for the `DOMContentLoaded` event to be fired.\n\t//  - `networkidle` - **DISCOURAGED** wait until there are no network connections for at least `500` ms. Don't use\n\t//   this method for testing, rely on web assertions to assess readiness instead.\n\tState *LoadState `json:\"state\"`\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectNavigationOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation. Note that if\n\t// the parameter is a string without wildcard characters, the method will wait for navigation to URL that is exactly\n\t// equal to the string.\n\tURL interface{} `json:\"url\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageExpectPopupOptions struct {\n\t// Receives the [Page] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(Page) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectRequestOptions struct {\n\t// Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can\n\t// be changed by using the [Page.SetDefaultTimeout] method.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectRequestFinishedOptions struct {\n\t// Receives the [Request] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(Request) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectResponseOptions struct {\n\t// Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageWaitForSelectorOptions struct {\n\t// Defaults to `visible`. Can be either:\n\t//  - `attached` - wait for element to be present in DOM.\n\t//  - `detached` - wait for element to not be present in DOM.\n\t//  - `visible` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element\n\t//   without any content or with `display:none` has an empty bounding box and is not considered visible.\n\t//  - `hidden` - wait for element to be either detached from DOM, or have an empty bounding box or\n\t//   `visibility:hidden`. This is opposite to the `visible` option.\n\tState *WaitForSelectorState `json:\"state\"`\n\t// When true, the call requires selector to resolve to a single element. If given selector resolves to more than one\n\t// element, the call throws an exception.\n\tStrict *bool `json:\"strict\"`\n\t// Maximum time in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageWaitForURLOptions struct {\n\t// Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can\n\t// be changed by using the [BrowserContext.SetDefaultNavigationTimeout], [BrowserContext.SetDefaultTimeout],\n\t// [Page.SetDefaultNavigationTimeout] or [Page.SetDefaultTimeout] methods.\n\tTimeout *float64 `json:\"timeout\"`\n\t// When to consider operation succeeded, defaults to `load`. Events can be either:\n\t//  - `domcontentloaded` - consider operation to be finished when the `DOMContentLoaded` event is fired.\n\t//  - `load` - consider operation to be finished when the `load` event is fired.\n\t//  - `networkidle` - **DISCOURAGED** consider operation to be finished when there are no network connections for\n\t//   at least `500` ms. Don't use this method for testing, rely on web assertions to assess readiness instead.\n\t//  - `commit` - consider operation to be finished when network response is received and the document started\n\t//   loading.\n\tWaitUntil *WaitUntilState `json:\"waitUntil\"`\n}\n\ntype PageExpectWebSocketOptions struct {\n\t// Receives the [WebSocket] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(WebSocket) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageExpectWorkerOptions struct {\n\t// Receives the [Worker] object and resolves to truthy value when the waiting should resolve.\n\tPredicate func(Worker) bool `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageWaitForEventOptions struct {\n\t// Receives the event data and resolves to truthy value when the waiting should resolve.\n\tPredicate interface{} `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageAssertionsToHaveTitleOptions struct {\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype PageAssertionsToHaveURLOptions struct {\n\t// Whether to perform case-insensitive match. “[object Object]” option takes precedence over the corresponding regular\n\t// expression flag if specified.\n\tIgnoreCase *bool `json:\"ignoreCase\"`\n\t// Time to retry the assertion for in milliseconds. Defaults to `5000`.\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype RequestSizesResult struct {\n\t// Size of the request body (POST data payload) in bytes. Set to 0 if there was no body.\n\tRequestBodySize int `json:\"requestBodySize\"`\n\t// Total number of bytes from the start of the HTTP request message until (and including) the double CRLF before the\n\t// body.\n\tRequestHeadersSize int `json:\"requestHeadersSize\"`\n\t// Size of the received response body (encoded) in bytes.\n\tResponseBodySize int `json:\"responseBodySize\"`\n\t// Total number of bytes from the start of the HTTP response message until (and including) the double CRLF before the\n\t// body.\n\tResponseHeadersSize int `json:\"responseHeadersSize\"`\n}\n\ntype RequestTiming struct {\n\t// Request start time in milliseconds elapsed since January 1, 1970 00:00:00 UTC\n\tStartTime float64 `json:\"startTime\"`\n\t// Time immediately before the browser starts the domain name lookup for the resource. The value is given in\n\t// milliseconds relative to `startTime`, -1 if not available.\n\tDomainLookupStart float64 `json:\"domainLookupStart\"`\n\t// Time immediately after the browser starts the domain name lookup for the resource. The value is given in\n\t// milliseconds relative to `startTime`, -1 if not available.\n\tDomainLookupEnd float64 `json:\"domainLookupEnd\"`\n\t// Time immediately before the user agent starts establishing the connection to the server to retrieve the resource.\n\t// The value is given in milliseconds relative to `startTime`, -1 if not available.\n\tConnectStart float64 `json:\"connectStart\"`\n\t// Time immediately before the browser starts the handshake process to secure the current connection. The value is\n\t// given in milliseconds relative to `startTime`, -1 if not available.\n\tSecureConnectionStart float64 `json:\"secureConnectionStart\"`\n\t// Time immediately before the user agent starts establishing the connection to the server to retrieve the resource.\n\t// The value is given in milliseconds relative to `startTime`, -1 if not available.\n\tConnectEnd float64 `json:\"connectEnd\"`\n\t// Time immediately before the browser starts requesting the resource from the server, cache, or local resource. The\n\t// value is given in milliseconds relative to `startTime`, -1 if not available.\n\tRequestStart float64 `json:\"requestStart\"`\n\t// Time immediately after the browser receives the first byte of the response from the server, cache, or local\n\t// resource. The value is given in milliseconds relative to `startTime`, -1 if not available.\n\tResponseStart float64 `json:\"responseStart\"`\n\t// Time immediately after the browser receives the last byte of the resource or immediately before the transport\n\t// connection is closed, whichever comes first. The value is given in milliseconds relative to `startTime`, -1 if not\n\t// available.\n\tResponseEnd float64 `json:\"responseEnd\"`\n}\n\ntype ResponseSecurityDetailsResult struct {\n\t// Common Name component of the Issuer field. from the certificate. This should only be used for informational\n\t// purposes. Optional.\n\tIssuer *string `json:\"issuer\"`\n\t// The specific TLS protocol used. (e.g. `TLS 1.3`). Optional.\n\tProtocol *string `json:\"protocol\"`\n\t// Common Name component of the Subject field from the certificate. This should only be used for informational\n\t// purposes. Optional.\n\tSubjectName *string `json:\"subjectName\"`\n\t// Unix timestamp (in seconds) specifying when this cert becomes valid. Optional.\n\tValidFrom *float64 `json:\"validFrom\"`\n\t// Unix timestamp (in seconds) specifying when this cert becomes invalid. Optional.\n\tValidTo *float64 `json:\"validTo\"`\n}\n\ntype ResponseServerAddrResult struct {\n\t// IPv4 or IPV6 address of the server.\n\tIpAddress string `json:\"ipAddress\"`\n\tPort      int    `json:\"port\"`\n}\n\ntype RouteContinueOptions struct {\n\t// If set changes the request HTTP headers. Header values will be converted to a string.\n\tHeaders map[string]string `json:\"headers\"`\n\t// If set changes the request method (e.g. GET or POST).\n\tMethod *string `json:\"method\"`\n\t// If set changes the post data of request.\n\tPostData interface{} `json:\"postData\"`\n\t// If set changes the request URL. New URL must have same protocol as original one.\n\tURL *string `json:\"url\"`\n}\n\ntype RouteFallbackOptions struct {\n\t// If set changes the request HTTP headers. Header values will be converted to a string.\n\tHeaders map[string]string `json:\"headers\"`\n\t// If set changes the request method (e.g. GET or POST).\n\tMethod *string `json:\"method\"`\n\t// If set changes the post data of request.\n\tPostData interface{} `json:\"postData\"`\n\t// If set changes the request URL. New URL must have same protocol as original one. Changing the URL won't affect the\n\t// route matching, all the routes are matched using the original request URL.\n\tURL *string `json:\"url\"`\n}\n\ntype RouteFetchOptions struct {\n\t// If set changes the request HTTP headers. Header values will be converted to a string.\n\tHeaders map[string]string `json:\"headers\"`\n\t// Maximum number of request redirects that will be followed automatically. An error will be thrown if the number is\n\t// exceeded. Defaults to `20`. Pass `0` to not follow redirects.\n\tMaxRedirects *int `json:\"maxRedirects\"`\n\t// Maximum number of times network errors should be retried. Currently only `ECONNRESET` error is retried. Does not\n\t// retry based on HTTP response codes. An error will be thrown if the limit is exceeded. Defaults to `0` - no retries.\n\tMaxRetries *int `json:\"maxRetries\"`\n\t// If set changes the request method (e.g. GET or POST).\n\tMethod *string `json:\"method\"`\n\t// If set changes the post data of request.\n\tPostData interface{} `json:\"postData\"`\n\t// Request timeout in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.\n\tTimeout *float64 `json:\"timeout\"`\n\t// If set changes the request URL. New URL must have same protocol as original one.\n\tURL *string `json:\"url\"`\n}\n\ntype RouteFulfillOptions struct {\n\t// Response body.\n\tBody interface{} `json:\"body\"`\n\t// If set, equals to setting `Content-Type` response header.\n\tContentType *string `json:\"contentType\"`\n\t// Response headers. Header values will be converted to a string.\n\tHeaders map[string]string `json:\"headers\"`\n\t// File path to respond with. The content type will be inferred from file extension. If `path` is a relative path,\n\t// then it is resolved relative to the current working directory.\n\tPath *string `json:\"path\"`\n\t// [APIResponse] to fulfill route's request with. Individual fields of the response (such as headers) can be\n\t// overridden using fulfill options.\n\tResponse APIResponse `json:\"response\"`\n\t// Response status code, defaults to `200`.\n\tStatus *int `json:\"status\"`\n}\n\ntype SelectorsRegisterOptions struct {\n\t// Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same\n\t// DOM, but not any JavaScript objects from the frame's scripts. Defaults to `false`. Note that running as a content\n\t// script is not guaranteed when this engine is used together with other registered engines.\n\tContentScript *bool `json:\"contentScript\"`\n}\n\ntype TracingStartOptions struct {\n\t// If specified, intermediate trace files are going to be saved into the files with the given name prefix inside the\n\t// “[object Object]” directory specified in [BrowserType.Launch]. To specify the final trace zip file name, you need\n\t// to pass `path` option to [Tracing.Stop] instead.\n\tName *string `json:\"name\"`\n\t// Whether to capture screenshots during tracing. Screenshots are used to build a timeline preview.\n\tScreenshots *bool `json:\"screenshots\"`\n\t// If this option is true tracing will\n\t//  - capture DOM snapshot on every action\n\t//  - record network activity\n\tSnapshots *bool `json:\"snapshots\"`\n\t// Whether to include source files for trace actions.\n\tSources *bool `json:\"sources\"`\n\t// Trace name to be shown in the Trace Viewer.\n\tTitle *string `json:\"title\"`\n}\n\ntype TracingStartChunkOptions struct {\n\t// If specified, intermediate trace files are going to be saved into the files with the given name prefix inside the\n\t// “[object Object]” directory specified in [BrowserType.Launch]. To specify the final trace zip file name, you need\n\t// to pass `path` option to [Tracing.StopChunk] instead.\n\tName *string `json:\"name\"`\n\t// Trace name to be shown in the Trace Viewer.\n\tTitle *string `json:\"title\"`\n}\n\ntype TracingGroupOptions struct {\n\t// Specifies a custom location for the group to be shown in the trace viewer. Defaults to the location of the\n\t// [Tracing.Group] call.\n\tLocation *TracingGroupOptionsLocation `json:\"location\"`\n}\n\ntype WebSocketExpectEventOptions struct {\n\t// Receives the event data and resolves to truthy value when the waiting should resolve.\n\tPredicate interface{} `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype WebSocketWaitForEventOptions struct {\n\t// Receives the event data and resolves to truthy value when the waiting should resolve.\n\tPredicate interface{} `json:\"predicate\"`\n\t// Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n\t// default value can be changed by using the [BrowserContext.SetDefaultTimeout].\n\tTimeout *float64 `json:\"timeout\"`\n}\n\ntype WebSocketRouteCloseOptions struct {\n\t// Optional [close code].\n\t//\n\t// [close code]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close#code\n\tCode *int `json:\"code\"`\n\t// Optional [close reason].\n\t//\n\t// [close reason]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close#reason\n\tReason *string `json:\"reason\"`\n}\n\ntype ClientCertificate struct {\n\t// Exact origin that the certificate is valid for. Origin includes `https` protocol, a hostname and optionally a port.\n\tOrigin string `json:\"origin\"`\n\t// Path to the file with the certificate in PEM format.\n\tCertPath *string `json:\"certPath\"`\n\t// Direct value of the certificate in PEM format.\n\tCert []byte `json:\"cert\"`\n\t// Path to the file with the private key in PEM format.\n\tKeyPath *string `json:\"keyPath\"`\n\t// Direct value of the private key in PEM format.\n\tKey []byte `json:\"key\"`\n\t// Path to the PFX or PKCS12 encoded private key and certificate chain.\n\tPfxPath *string `json:\"pfxPath\"`\n\t// Direct value of the PFX or PKCS12 encoded private key and certificate chain.\n\tPfx []byte `json:\"pfx\"`\n\t// Passphrase for the private key (PEM or PFX).\n\tPassphrase *string `json:\"passphrase\"`\n}\n\ntype HttpCredentials struct {\n\tUsername string `json:\"username\"`\n\tPassword string `json:\"password\"`\n\t// Restrain sending http credentials on specific origin (scheme://host:port).\n\tOrigin *string `json:\"origin\"`\n\t// This option only applies to the requests sent from corresponding [APIRequestContext] and does not affect requests\n\t// sent from the browser. `always` - `Authorization` header with basic authentication credentials will be sent with\n\t// the each API request. `'unauthorized` - the credentials are only sent when 401 (Unauthorized) response with\n\t// `WWW-Authenticate` header is received. Defaults to `unauthorized`.\n\tSend *HttpCredentialsSend `json:\"send\"`\n}\n\ntype Proxy struct {\n\t// Proxy to be used for all requests. HTTP and SOCKS proxies are supported, for example `http://myproxy.com:3128` or\n\t// `socks5://myproxy.com:3128`. Short form `myproxy.com:3128` is considered an HTTP proxy.\n\tServer string `json:\"server\"`\n\t// Optional comma-separated domains to bypass proxy, for example `\".com, chromium.org, .domain.com\"`.\n\tBypass *string `json:\"bypass\"`\n\t// Optional username to use if HTTP proxy requires authentication.\n\tUsername *string `json:\"username\"`\n\t// Optional password to use if HTTP proxy requires authentication.\n\tPassword *string `json:\"password\"`\n}\n\ntype Origin struct {\n\tOrigin       string      `json:\"origin\"`\n\tLocalStorage []NameValue `json:\"localStorage\"`\n}\n\ntype RecordVideo struct {\n\t// Path to the directory to put videos into.\n\tDir string `json:\"dir\"`\n\t// Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport` scaled down to\n\t// fit into 800x800. If `viewport` is not configured explicitly the video size defaults to 800x450. Actual picture of\n\t// each page will be scaled down if necessary to fit the specified size.\n\tSize *Size `json:\"size\"`\n}\n\ntype OptionalStorageState struct {\n\t// Cookies to set for context\n\tCookies []OptionalCookie `json:\"cookies\"`\n\t// localStorage to set for context\n\tOrigins []Origin `json:\"origins\"`\n}\n\ntype Position struct {\n\tX float64 `json:\"x\"`\n\tY float64 `json:\"y\"`\n}\n\ntype Margin struct {\n\t// Top margin, accepts values labeled with units. Defaults to `0`.\n\tTop *string `json:\"top\"`\n\t// Right margin, accepts values labeled with units. Defaults to `0`.\n\tRight *string `json:\"right\"`\n\t// Bottom margin, accepts values labeled with units. Defaults to `0`.\n\tBottom *string `json:\"bottom\"`\n\t// Left margin, accepts values labeled with units. Defaults to `0`.\n\tLeft *string `json:\"left\"`\n}\n\ntype TracingGroupOptionsLocation struct {\n\tFile   string `json:\"file\"`\n\tLine   *int   `json:\"line\"`\n\tColumn *int   `json:\"column\"`\n}\n"
        },
        {
          "name": "glob.go",
          "type": "blob",
          "size": 1.7802734375,
          "content": "package playwright\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar escapedChars = map[rune]bool{\n\t'$':  true,\n\t'^':  true,\n\t'+':  true,\n\t'.':  true,\n\t'*':  true,\n\t'(':  true,\n\t')':  true,\n\t'|':  true,\n\t'\\\\': true,\n\t'?':  true,\n\t'{':  true,\n\t'}':  true,\n\t'[':  true,\n\t']':  true,\n}\n\nfunc globMustToRegex(glob string) *regexp.Regexp {\n\ttokens := []string{\"^\"}\n\tinGroup := false\n\n\tfor i := 0; i < len(glob); i++ {\n\t\tc := rune(glob[i])\n\t\tif c == '\\\\' && i+1 < len(glob) {\n\t\t\tchar := rune(glob[i+1])\n\t\t\tif _, ok := escapedChars[char]; ok {\n\t\t\t\ttokens = append(tokens, \"\\\\\"+string(char))\n\t\t\t} else {\n\t\t\t\ttokens = append(tokens, string(char))\n\t\t\t}\n\t\t\ti++\n\t\t} else if c == '*' {\n\t\t\tbeforeDeep := rune(0)\n\t\t\tif i > 0 {\n\t\t\t\tbeforeDeep = rune(glob[i-1])\n\t\t\t}\n\t\t\tstarCount := 1\n\t\t\tfor i+1 < len(glob) && glob[i+1] == '*' {\n\t\t\t\tstarCount++\n\t\t\t\ti++\n\t\t\t}\n\t\t\tafterDeep := rune(0)\n\t\t\tif i+1 < len(glob) {\n\t\t\t\tafterDeep = rune(glob[i+1])\n\t\t\t}\n\t\t\tisDeep := starCount > 1 && (beforeDeep == '/' || beforeDeep == 0) && (afterDeep == '/' || afterDeep == 0)\n\t\t\tif isDeep {\n\t\t\t\ttokens = append(tokens, \"((?:[^/]*(?:/|$))*)\")\n\t\t\t\ti++\n\t\t\t} else {\n\t\t\t\ttokens = append(tokens, \"([^/]*)\")\n\t\t\t}\n\t\t} else {\n\t\t\tswitch c {\n\t\t\tcase '?':\n\t\t\t\ttokens = append(tokens, \".\")\n\t\t\tcase '[':\n\t\t\t\ttokens = append(tokens, \"[\")\n\t\t\tcase ']':\n\t\t\t\ttokens = append(tokens, \"]\")\n\t\t\tcase '{':\n\t\t\t\tinGroup = true\n\t\t\t\ttokens = append(tokens, \"(\")\n\t\t\tcase '}':\n\t\t\t\tinGroup = false\n\t\t\t\ttokens = append(tokens, \")\")\n\t\t\tcase ',':\n\t\t\t\tif inGroup {\n\t\t\t\t\ttokens = append(tokens, \"|\")\n\t\t\t\t} else {\n\t\t\t\t\ttokens = append(tokens, string(c))\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif _, ok := escapedChars[c]; ok {\n\t\t\t\t\ttokens = append(tokens, \"\\\\\"+string(c))\n\t\t\t\t} else {\n\t\t\t\t\ttokens = append(tokens, string(c))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttokens = append(tokens, \"$\")\n\treturn regexp.MustCompile(strings.Join(tokens, \"\"))\n}\n"
        },
        {
          "name": "glob_test.go",
          "type": "blob",
          "size": 3.134765625,
          "content": "package playwright\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc Test_globMustToRegex(t *testing.T) {\n\ttype args struct {\n\t\tglob   string\n\t\ttarget string\n\t}\n\ttests := []struct {\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/*.js\",\n\t\t\t\ttarget: \"https://localhost:8080/foo.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/*.css\",\n\t\t\t\ttarget: \"https://localhost:8080/foo.js\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"*.js\",\n\t\t\t\ttarget: \"https://localhost:8080/foo.js\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"https://**/*.js\",\n\t\t\t\ttarget: \"https://localhost:8080/foo.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"http://localhost:8080/simple/path.js\",\n\t\t\t\ttarget: \"http://localhost:8080/simple/path.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"http://localhost:8080/?imple/path.js\",\n\t\t\t\ttarget: \"http://localhost:8080/simple/path.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/{a,b}.js\",\n\t\t\t\ttarget: \"https://localhost:8080/a.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/{a,b}.js\",\n\t\t\t\ttarget: \"https://localhost:8080/b.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/{a,b}.js\",\n\t\t\t\ttarget: \"https://localhost:8080/c.js\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/*.{png,jpg,jpeg}\",\n\t\t\t\ttarget: \"https://localhost:8080/c.jpg\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/*.{png,jpg,jpeg}\",\n\t\t\t\ttarget: \"https://localhost:8080/c.jpeg\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/*.{png,jpg,jpeg}\",\n\t\t\t\ttarget: \"https://localhost:8080/c.png\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/*.{png,jpg,jpeg}\",\n\t\t\t\ttarget: \"https://localhost:8080/c.css\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"foo*\",\n\t\t\t\ttarget: \"foo.js\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"foo*\",\n\t\t\t\ttarget: \"foo/bar.js\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"http://localhost:3000/signin-oidc*\",\n\t\t\t\ttarget: \"http://localhost:3000/signin-oidc/foo\",\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"http://localhost:3000/signin-oidc*\",\n\t\t\t\ttarget: \"http://localhost:3000/signin-oidcnice\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\targs: args{\n\t\t\t\tglob:   \"**/three-columns/settings.html?**id=[a-z]**\",\n\t\t\t\ttarget: \"http://mydomain:8080/blah/blah/three-columns/settings.html?id=settings-e3c58efe-02e9-44b0-97ac-dd138100cf7c&blah\",\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t}\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"glob test %d\", i), func(t *testing.T) {\n\t\t\tif got := globMustToRegex(tt.args.glob).MatchString(tt.args.target); got != tt.want {\n\t\t\t\tt.Errorf(\"globMustToRegex() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\trequire.Equal(t, globMustToRegex(\"\\\\?\").String(), `^\\?$`)\n\trequire.Equal(t, globMustToRegex(\"\\\\\").String(), `^\\\\$`)\n\trequire.Equal(t, globMustToRegex(\"\\\\\\\\\").String(), `^\\\\$`)\n\trequire.Equal(t, globMustToRegex(\"\\\\[\").String(), `^\\[$`)\n\trequire.Equal(t, globMustToRegex(\"[a-z]\").String(), `^[a-z]$`)\n\trequire.Equal(t, globMustToRegex(\"$^+.\\\\*()|\\\\?\\\\{\\\\}\\\\[\\\\]\").String(), `^\\$\\^\\+\\.\\*\\(\\)\\|\\?\\{\\}\\[\\]$`)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.80859375,
          "content": "module github.com/playwright-community/playwright-go\n\ngo 1.22\n\nrequire (\n\tgithub.com/coder/websocket v1.8.12\n\tgithub.com/deckarep/golang-set/v2 v2.6.0\n\tgithub.com/go-jose/go-jose/v3 v3.0.3\n\tgithub.com/go-stack/stack v1.8.1\n\tgithub.com/h2non/filetype v1.1.3\n\tgithub.com/mitchellh/go-ps v1.0.0\n\tgithub.com/orisano/pixelmatch v0.0.0-20230914042517-fa304d1dc785\n\tgithub.com/stretchr/testify v1.8.4\n\tgithub.com/tidwall/gjson v1.17.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rogpeppe/go-internal v1.11.0 // indirect\n\tgithub.com/tidwall/match v1.1.1 // indirect\n\tgithub.com/tidwall/pretty v1.2.1 // indirect\n\tgopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.724609375,
          "content": "github.com/coder/websocket v1.8.12 h1:5bUXkEPPIbewrnkU8LTCLVaxi4N4J8ahufH2vlo4NAo=\ngithub.com/coder/websocket v1.8.12/go.mod h1:LNVeNrXQZfe5qhS9ALED3uA+l5pPqvwXg3CKoDBB2gs=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/deckarep/golang-set/v2 v2.6.0 h1:XfcQbWM1LlMB8BsJ8N9vW5ehnnPVIw0je80NsVHagjM=\ngithub.com/deckarep/golang-set/v2 v2.6.0/go.mod h1:VAky9rY/yGXJOLEDv3OMci+7wtDpOF4IN+y82NBOac4=\ngithub.com/go-jose/go-jose/v3 v3.0.3 h1:fFKWeig/irsp7XD2zBxvnmA/XaRWp5V3CBsZXJF7G7k=\ngithub.com/go-jose/go-jose/v3 v3.0.3/go.mod h1:5b+7YgP7ZICgJDBdfjZaIt+H/9L9T/YQrVfLAMboGkQ=\ngithub.com/go-stack/stack v1.8.1 h1:ntEHSVwIt7PNXNpgPmVfMrNhLtgjlmnZha2kOpuRiDw=\ngithub.com/go-stack/stack v1.8.1/go.mod h1:dcoOX6HbPZSZptuspn9bctJ+N/CnF5gGygcUP3XYfe4=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/h2non/filetype v1.1.3 h1:FKkx9QbD7HR/zjK1Ia5XiBsq9zdLi5Kf3zGyFTAFkGg=\ngithub.com/h2non/filetype v1.1.3/go.mod h1:319b3zT68BvV+WRj7cwy856M2ehB3HqNOt6sy1HndBY=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mitchellh/go-ps v1.0.0 h1:i6ampVEEF4wQFF+bkYfwYgY+F/uYJDktmvLPf7qIgjc=\ngithub.com/mitchellh/go-ps v1.0.0/go.mod h1:J4lOc8z8yJs6vUwklHw2XEIiT4z4C40KtWVN3nvg8Pg=\ngithub.com/orisano/pixelmatch v0.0.0-20230914042517-fa304d1dc785 h1:J1//5K/6QF10cZ59zLcVNFGmBfiSrH8Cho/lNrViK9s=\ngithub.com/orisano/pixelmatch v0.0.0-20230914042517-fa304d1dc785/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=\ngithub.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/tidwall/gjson v1.17.0 h1:/Jocvlh98kcTfpN2+JzGQWQcqrPQwDrVEMApx/M5ZwM=\ngithub.com/tidwall/gjson v1.17.0/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=\ngithub.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=\ngithub.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=\ngithub.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=\ngithub.com/tidwall/pretty v1.2.1 h1:qjsOFOWWQl+N3RsoF5/ssm1pHmJJwhjlSbZ51I6wMl4=\ngithub.com/tidwall/pretty v1.2.1/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "har_router.go",
          "type": "blob",
          "size": 2.4609375,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n)\n\ntype harRouter struct {\n\tlocalUtils     *localUtilsImpl\n\tharId          string\n\tnotFoundAction HarNotFound\n\turlOrPredicate interface{}\n\terr            error\n}\n\nfunc (r *harRouter) addContextRoute(context BrowserContext) error {\n\tif r.err != nil {\n\t\treturn r.err\n\t}\n\terr := context.Route(r.urlOrPredicate, func(route Route) {\n\t\terr := r.handle(route)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error handling context route\", \"error\", err)\n\t\t}\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn r.err\n}\n\nfunc (r *harRouter) addPageRoute(page Page) error {\n\tif r.err != nil {\n\t\treturn r.err\n\t}\n\terr := page.Route(r.urlOrPredicate, func(route Route) {\n\t\terr := r.handle(route)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"Error handling page route\", \"error\", err)\n\t\t}\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn r.err\n}\n\nfunc (r *harRouter) dispose() {\n\tgo r.localUtils.HarClose(r.harId)\n}\n\nfunc (r *harRouter) handle(route Route) error {\n\tif r.err != nil {\n\t\treturn r.err\n\t}\n\trequest := route.Request()\n\tpostData, err := request.PostDataBuffer()\n\tif err != nil {\n\t\treturn err\n\t}\n\tresponse, err := r.localUtils.HarLookup(harLookupOptions{\n\t\tHarId:               r.harId,\n\t\tURL:                 request.URL(),\n\t\tMethod:              request.Method(),\n\t\tHeaders:             request.Headers(),\n\t\tIsNavigationRequest: request.IsNavigationRequest(),\n\t\tPostData:            postData,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch response.Action {\n\tcase \"redirect\":\n\t\tif response.RedirectURL == nil {\n\t\t\treturn errors.New(\"redirect url is null\")\n\t\t}\n\t\treturn route.(*routeImpl).redirectedNavigationRequest(*response.RedirectURL)\n\tcase \"fulfill\":\n\t\tif response.Body == nil {\n\t\t\treturn errors.New(\"fulfill body is null\")\n\t\t}\n\t\treturn route.Fulfill(RouteFulfillOptions{\n\t\t\tBody:    *response.Body,\n\t\t\tStatus:  response.Status,\n\t\t\tHeaders: deserializeNameAndValueToMap(response.Headers),\n\t\t})\n\tcase \"error\":\n\t\tlogger.Error(\"har action error\", \"error\", *response.Message)\n\t\tfallthrough\n\tcase \"noentry\":\n\t}\n\tif r.notFoundAction == *HarNotFoundAbort {\n\t\treturn route.Abort()\n\t}\n\treturn route.Fallback()\n}\n\nfunc newHarRouter(localUtils *localUtilsImpl, file string, notFoundAction HarNotFound, urlOrPredicate interface{}) *harRouter {\n\tharId, err := localUtils.HarOpen(file)\n\tvar url interface{} = \"**/*\"\n\tif urlOrPredicate != nil {\n\t\turl = urlOrPredicate\n\t}\n\treturn &harRouter{\n\t\tlocalUtils:     localUtils,\n\t\tharId:          harId,\n\t\tnotFoundAction: notFoundAction,\n\t\turlOrPredicate: url,\n\t\terr:            err,\n\t}\n}\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 15.87109375,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"path\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\tmapset \"github.com/deckarep/golang-set/v2\"\n)\n\ntype (\n\trouteHandler = func(Route)\n)\n\nfunc skipFieldSerialization(val reflect.Value) bool {\n\ttyp := val.Type()\n\treturn (typ.Kind() == reflect.Ptr ||\n\t\ttyp.Kind() == reflect.Interface ||\n\t\ttyp.Kind() == reflect.Map ||\n\t\ttyp.Kind() == reflect.Slice) && val.IsNil() || (val.Kind() == reflect.Interface && val.Elem().Kind() == reflect.Ptr && val.Elem().IsNil())\n}\n\nfunc transformStructValues(in interface{}) interface{} {\n\tv := reflect.ValueOf(in)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif _, ok := in.(*channel); ok {\n\t\treturn in\n\t}\n\tif v.Kind() == reflect.Map || v.Kind() == reflect.Struct {\n\t\treturn transformStructIntoMapIfNeeded(in)\n\t}\n\tif v.Kind() == reflect.Slice {\n\t\toutSlice := []interface{}{}\n\t\tfor i := 0; i < v.Len(); i++ {\n\t\t\tif !skipFieldSerialization(v.Index(i)) {\n\t\t\t\toutSlice = append(outSlice, transformStructValues(v.Index(i).Interface()))\n\t\t\t}\n\t\t}\n\t\treturn outSlice\n\t}\n\tif v.Interface() == Null() || (v.Kind() == reflect.String && v.String() == Null().(string)) {\n\t\treturn \"null\"\n\t}\n\treturn in\n}\n\nfunc transformStructIntoMapIfNeeded(inStruct interface{}) map[string]interface{} {\n\tout := make(map[string]interface{})\n\tv := reflect.ValueOf(inStruct)\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\ttyp := v.Type()\n\tif v.Kind() == reflect.Struct {\n\t\t// Merge into the base map by the JSON struct tag\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tfi := typ.Field(i)\n\t\t\t// Skip the values when the field is a pointer (like *string) and nil.\n\t\t\tif fi.IsExported() && !skipFieldSerialization(v.Field(i)) {\n\t\t\t\t// We use the JSON struct fields for getting the original names\n\t\t\t\t// out of the field.\n\t\t\t\ttagv := fi.Tag.Get(\"json\")\n\t\t\t\tkey := strings.Split(tagv, \",\")[0]\n\t\t\t\tif key == \"\" {\n\t\t\t\t\tkey = fi.Name\n\t\t\t\t}\n\t\t\t\tout[key] = transformStructValues(v.Field(i).Interface())\n\t\t\t}\n\t\t}\n\t} else if v.Kind() == reflect.Map {\n\t\t// Merge into the base map\n\t\tfor _, key := range v.MapKeys() {\n\t\t\tif !skipFieldSerialization(v.MapIndex(key)) {\n\t\t\t\tout[key.String()] = transformStructValues(v.MapIndex(key).Interface())\n\t\t\t}\n\t\t}\n\t}\n\treturn out\n}\n\n// transformOptions handles the parameter data transformation\nfunc transformOptions(options ...interface{}) map[string]interface{} {\n\tvar base map[string]interface{}\n\tvar option interface{}\n\t// Case 1: No options are given\n\tif len(options) == 0 {\n\t\treturn make(map[string]interface{})\n\t}\n\tif len(options) == 1 {\n\t\t// Case 2: a single value (either struct or map) is given.\n\t\tbase = make(map[string]interface{})\n\t\toption = options[0]\n\t} else if len(options) == 2 {\n\t\t// Case 3: two values are given. The first one needs to be transformed\n\t\t// to a map, the sencond one will be then get merged into the first\n\t\t// base map.\n\t\tif reflect.ValueOf(options[0]).Kind() != reflect.Map {\n\t\t\tbase = transformOptions(options[0])\n\t\t} else {\n\t\t\tbase = transformStructIntoMapIfNeeded(options[0])\n\t\t}\n\t\toption = options[1]\n\t}\n\tv := reflect.ValueOf(option)\n\tif v.Kind() == reflect.Slice {\n\t\tif v.Len() == 0 {\n\t\t\treturn base\n\t\t}\n\t\toption = v.Index(0).Interface()\n\t}\n\n\tif option == nil {\n\t\treturn base\n\t}\n\tv = reflect.ValueOf(option)\n\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\n\toptionMap := transformStructIntoMapIfNeeded(v.Interface())\n\tfor key, value := range optionMap {\n\t\tbase[key] = value\n\t}\n\treturn base\n}\n\nfunc remapValue(inMapValue reflect.Value, outStructValue reflect.Value) {\n\tswitch outStructValue.Type().Kind() {\n\tcase reflect.Bool:\n\t\toutStructValue.SetBool(inMapValue.Bool())\n\tcase reflect.String:\n\t\toutStructValue.SetString(inMapValue.String())\n\tcase reflect.Float64:\n\t\toutStructValue.SetFloat(inMapValue.Float())\n\tcase reflect.Int:\n\t\toutStructValue.SetInt(int64(inMapValue.Float()))\n\tcase reflect.Slice:\n\t\toutStructValue.Set(reflect.MakeSlice(outStructValue.Type(), inMapValue.Len(), inMapValue.Cap()))\n\t\tfor i := 0; i < inMapValue.Len(); i++ {\n\t\t\tremapValue(inMapValue.Index(i).Elem(), outStructValue.Index(i))\n\t\t}\n\tcase reflect.Struct:\n\t\tstructTyp := outStructValue.Type()\n\t\tfor i := 0; i < outStructValue.NumField(); i++ {\n\t\t\tfi := structTyp.Field(i)\n\t\t\tkey := strings.Split(fi.Tag.Get(\"json\"), \",\")[0]\n\t\t\tstructField := outStructValue.Field(i)\n\t\t\tstructFieldDeref := outStructValue.Field(i)\n\t\t\tif structField.Type().Kind() == reflect.Ptr {\n\t\t\t\tstructField.Set(reflect.New(structField.Type().Elem()))\n\t\t\t\tstructFieldDeref = structField.Elem()\n\t\t\t}\n\t\t\tfor _, e := range inMapValue.MapKeys() {\n\t\t\t\tif key == e.String() {\n\t\t\t\t\tvalue := inMapValue.MapIndex(e)\n\t\t\t\t\tremapValue(value.Elem(), structFieldDeref)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tpanic(inMapValue.Interface())\n\t}\n}\n\nfunc remapMapToStruct(inputMap interface{}, outStruct interface{}) {\n\tremapValue(reflect.ValueOf(inputMap), reflect.ValueOf(outStruct).Elem())\n}\n\ntype urlMatcher struct {\n\traw     interface{}\n\tpattern *regexp.Regexp\n\tmatchFn func(url string) bool\n}\n\nfunc newURLMatcher(urlOrPredicate, baseURL interface{}) *urlMatcher {\n\tswitch v := urlOrPredicate.(type) {\n\tcase *regexp.Regexp:\n\t\treturn &urlMatcher{pattern: v, raw: urlOrPredicate}\n\tcase string:\n\t\turl := v\n\t\tif baseURL != nil && !strings.HasPrefix(url, \"*\") {\n\t\t\tbase, ok := baseURL.(*string)\n\t\t\tif ok && base != nil {\n\t\t\t\turl = path.Join(*base, url)\n\t\t\t}\n\t\t}\n\t\treturn &urlMatcher{pattern: globMustToRegex(url), raw: urlOrPredicate}\n\t}\n\tfn, ok := urlOrPredicate.(func(string) bool)\n\tif ok {\n\t\treturn &urlMatcher{\n\t\t\tmatchFn: fn,\n\t\t\traw:     urlOrPredicate,\n\t\t}\n\t}\n\tpanic(fmt.Errorf(\"invalid urlOrPredicate: %v\", urlOrPredicate))\n}\n\nfunc (u *urlMatcher) Matches(url string) bool {\n\tif u.matchFn != nil {\n\t\treturn u.matchFn(url)\n\t}\n\tif u.pattern != nil {\n\t\treturn u.pattern.MatchString(url)\n\t}\n\treturn false\n}\n\n// SameWith compares String() if urlOrPredicate is *regexp.Regexp\nfunc (u *urlMatcher) SameWith(urlOrPredicate interface{}) bool {\n\tswitch v := urlOrPredicate.(type) {\n\tcase *regexp.Regexp:\n\t\treturn u.pattern.String() == v.String()\n\tdefault:\n\t\treturn u.raw == urlOrPredicate\n\t}\n}\n\ntype routeHandlerInvocation struct {\n\troute    Route\n\tcomplete chan bool\n}\n\ntype routeHandlerEntry struct {\n\tmatcher           *urlMatcher\n\thandler           routeHandler\n\ttimes             int\n\tcount             int32\n\tignoreErrors      *atomic.Bool\n\tactiveInvocations mapset.Set[*routeHandlerInvocation]\n}\n\nfunc (r *routeHandlerEntry) Matches(url string) bool {\n\treturn r.matcher.Matches(url)\n}\n\nfunc (r *routeHandlerEntry) Handle(route Route) chan bool {\n\thandlerInvocation := &routeHandlerInvocation{\n\t\troute:    route,\n\t\tcomplete: make(chan bool, 1),\n\t}\n\tr.activeInvocations.Add(handlerInvocation)\n\n\tdefer func() {\n\t\thandlerInvocation.complete <- true\n\t\tr.activeInvocations.Remove(handlerInvocation)\n\t}()\n\tdefer func() {\n\t\t// If the handler was stopped (without waiting for completion), we ignore all exceptions.\n\t\tif r.ignoreErrors.Load() {\n\t\t\t_ = recover()\n\t\t\troute.(*routeImpl).reportHandled(false)\n\t\t} else {\n\t\t\te := recover()\n\t\t\tif e != nil {\n\t\t\t\terr, ok := e.(error)\n\t\t\t\tif ok && errors.Is(err, ErrTargetClosed) {\n\t\t\t\t\tpanic(fmt.Errorf(\"\\\"%w\\\" while running route callback.\\nConsider awaiting `page.UnrouteAll(playwright.PageUnrouteAllOptions{Behavior: playwright.UnrouteBehaviorIgnoreErrors})`\\nbefore the end of the test to ignore remaining routes in flight.\", err))\n\t\t\t\t}\n\t\t\t\tpanic(e)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn r.handleInternal(route)\n}\n\nfunc (r *routeHandlerEntry) Stop(behavior string) {\n\t// When a handler is manually unrouted or its page/context is closed we either\n\t// - wait for the current handler invocations to finish\n\t// - or do not wait, if the user opted out of it, but swallow all exceptions\n\t//   that happen after the unroute/close.\n\tif behavior == string(*UnrouteBehaviorIgnoreErrors) {\n\t\tr.ignoreErrors.Store(true)\n\t} else {\n\t\twg := &sync.WaitGroup{}\n\t\tr.activeInvocations.Each(func(activation *routeHandlerInvocation) bool {\n\t\t\tif !activation.route.(*routeImpl).didThrow {\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func(complete chan bool) {\n\t\t\t\t\t<-complete\n\t\t\t\t\twg.Done()\n\t\t\t\t}(activation.complete)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\t\twg.Wait()\n\t}\n}\n\nfunc (r *routeHandlerEntry) handleInternal(route Route) chan bool {\n\thandled := route.(*routeImpl).startHandling()\n\tatomic.AddInt32(&r.count, 1)\n\tr.handler(route)\n\treturn handled\n}\n\nfunc (r *routeHandlerEntry) WillExceed() bool {\n\tif r.times == 0 {\n\t\treturn false\n\t}\n\treturn int(atomic.LoadInt32(&r.count)+1) >= r.times\n}\n\nfunc newRouteHandlerEntry(matcher *urlMatcher, handler routeHandler, times ...int) *routeHandlerEntry {\n\tn := 0\n\tif len(times) > 0 {\n\t\tn = times[0]\n\t}\n\treturn &routeHandlerEntry{\n\t\tmatcher:           matcher,\n\t\thandler:           handler,\n\t\ttimes:             n,\n\t\tcount:             0,\n\t\tignoreErrors:      &atomic.Bool{},\n\t\tactiveInvocations: mapset.NewSet[*routeHandlerInvocation](),\n\t}\n}\n\nfunc prepareInterceptionPatterns(handlers []*routeHandlerEntry) []map[string]interface{} {\n\tpatterns := []map[string]interface{}{}\n\tall := false\n\tfor _, h := range handlers {\n\t\tswitch h.matcher.raw.(type) {\n\t\tcase *regexp.Regexp:\n\t\t\tpattern, flags := convertRegexp(h.matcher.raw.(*regexp.Regexp))\n\t\t\tpatterns = append(patterns, map[string]interface{}{\n\t\t\t\t\"regexSource\": pattern,\n\t\t\t\t\"regexFlags\":  flags,\n\t\t\t})\n\t\tcase string:\n\t\t\tpatterns = append(patterns, map[string]interface{}{\n\t\t\t\t\"glob\": h.matcher.raw.(string),\n\t\t\t})\n\t\tdefault:\n\t\t\tall = true\n\t\t}\n\t}\n\tif all {\n\t\treturn []map[string]interface{}{\n\t\t\t{\n\t\t\t\t\"glob\": \"**/*\",\n\t\t\t},\n\t\t}\n\t}\n\treturn patterns\n}\n\nconst defaultTimeout = 30 * 1000\n\ntype timeoutSettings struct {\n\tsync.RWMutex\n\tparent                   *timeoutSettings\n\tdefaultTimeout           *float64\n\tdefaultNavigationTimeout *float64\n}\n\nfunc (t *timeoutSettings) SetDefaultTimeout(timeout *float64) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.defaultTimeout = timeout\n}\n\nfunc (t *timeoutSettings) DefaultTimeout() *float64 {\n\tt.RLock()\n\tdefer t.RUnlock()\n\treturn t.defaultTimeout\n}\n\nfunc (t *timeoutSettings) Timeout(timeout ...float64) float64 {\n\tt.RLock()\n\tdefer t.RUnlock()\n\tif len(timeout) == 1 {\n\t\treturn timeout[0]\n\t}\n\tif t.defaultTimeout != nil {\n\t\treturn *t.defaultTimeout\n\t}\n\tif t.parent != nil {\n\t\treturn t.parent.Timeout()\n\t}\n\treturn defaultTimeout\n}\n\nfunc (t *timeoutSettings) DefaultNavigationTimeout() *float64 {\n\tt.RLock()\n\tdefer t.RUnlock()\n\treturn t.defaultNavigationTimeout\n}\n\nfunc (t *timeoutSettings) SetDefaultNavigationTimeout(navigationTimeout *float64) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.defaultNavigationTimeout = navigationTimeout\n}\n\nfunc (t *timeoutSettings) NavigationTimeout() float64 {\n\tt.RLock()\n\tdefer t.RUnlock()\n\tif t.defaultNavigationTimeout != nil {\n\t\treturn *t.defaultNavigationTimeout\n\t}\n\tif t.parent != nil {\n\t\treturn t.parent.NavigationTimeout()\n\t}\n\treturn defaultTimeout\n}\n\nfunc newTimeoutSettings(parent *timeoutSettings) *timeoutSettings {\n\treturn &timeoutSettings{\n\t\tparent:                   parent,\n\t\tdefaultTimeout:           nil,\n\t\tdefaultNavigationTimeout: nil,\n\t}\n}\n\n// SelectOptionValues is the option struct for ElementHandle.Select() etc.\ntype SelectOptionValues struct {\n\tValuesOrLabels *[]string\n\tValues         *[]string\n\tIndexes        *[]int\n\tLabels         *[]string\n\tElements       *[]ElementHandle\n}\n\nfunc convertSelectOptionSet(values SelectOptionValues) map[string]interface{} {\n\tout := make(map[string]interface{})\n\tif values == (SelectOptionValues{}) {\n\t\treturn out\n\t}\n\n\tvar o []map[string]interface{}\n\tif values.ValuesOrLabels != nil {\n\t\tfor _, v := range *values.ValuesOrLabels {\n\t\t\tm := map[string]interface{}{\"valueOrLabel\": v}\n\t\t\to = append(o, m)\n\t\t}\n\t}\n\tif values.Values != nil {\n\t\tfor _, v := range *values.Values {\n\t\t\tm := map[string]interface{}{\"value\": v}\n\t\t\to = append(o, m)\n\t\t}\n\t}\n\tif values.Indexes != nil {\n\t\tfor _, i := range *values.Indexes {\n\t\t\tm := map[string]interface{}{\"index\": i}\n\t\t\to = append(o, m)\n\t\t}\n\t}\n\tif values.Labels != nil {\n\t\tfor _, l := range *values.Labels {\n\t\t\tm := map[string]interface{}{\"label\": l}\n\t\t\to = append(o, m)\n\t\t}\n\t}\n\tif o != nil {\n\t\tout[\"options\"] = o\n\t}\n\n\tvar e []*channel\n\tif values.Elements != nil {\n\t\tfor _, eh := range *values.Elements {\n\t\t\te = append(e, eh.(*elementHandleImpl).channel)\n\t\t}\n\t}\n\tif e != nil {\n\t\tout[\"elements\"] = e\n\t}\n\n\treturn out\n}\n\nfunc unroute(inRoutes []*routeHandlerEntry, url interface{}, handlers ...routeHandler) ([]*routeHandlerEntry, []*routeHandlerEntry, error) {\n\tvar handler routeHandler\n\tif len(handlers) == 1 {\n\t\thandler = handlers[0]\n\t}\n\thandlerPtr := reflect.ValueOf(handler).Pointer()\n\n\tremoved := make([]*routeHandlerEntry, 0)\n\tremaining := make([]*routeHandlerEntry, 0)\n\n\tfor _, route := range inRoutes {\n\t\trouteHandlerPtr := reflect.ValueOf(route.handler).Pointer()\n\t\t// note: compare regex expression if url is a regexp, not pointer\n\t\tif !route.matcher.SameWith(url) ||\n\t\t\t(handler != nil && routeHandlerPtr != handlerPtr) {\n\t\t\tremaining = append(remaining, route)\n\t\t} else {\n\t\t\tremoved = append(removed, route)\n\t\t}\n\t}\n\n\treturn removed, remaining, nil\n}\n\nfunc serializeMapToNameAndValue(headers map[string]string) []map[string]string {\n\tserialized := make([]map[string]string, 0)\n\tfor name, value := range headers {\n\t\tserialized = append(serialized, map[string]string{\n\t\t\t\"name\":  name,\n\t\t\t\"value\": value,\n\t\t})\n\t}\n\treturn serialized\n}\n\n// assignStructFields assigns fields from src to dest,\n//\n//\tomitExtra determines whether to omit src's extra fields\nfunc assignStructFields(dest, src interface{}, omitExtra bool) error {\n\tdestValue := reflect.ValueOf(dest)\n\tif destValue.Kind() != reflect.Ptr || destValue.IsNil() {\n\t\treturn fmt.Errorf(\"dest must be a non-nil pointer\")\n\t}\n\tdestValue = destValue.Elem()\n\tif destValue.Kind() != reflect.Struct {\n\t\treturn fmt.Errorf(\"dest must be a struct\")\n\t}\n\n\tsrcValue := reflect.ValueOf(src)\n\tif srcValue.Kind() == reflect.Ptr {\n\t\tsrcValue = srcValue.Elem()\n\t}\n\tif srcValue.Kind() != reflect.Struct {\n\t\treturn fmt.Errorf(\"src must be a struct\")\n\t}\n\n\tfor i := 0; i < destValue.NumField(); i++ {\n\t\tdestField := destValue.Field(i)\n\t\tdestFieldType := destField.Type()\n\t\tdestFieldName := destValue.Type().Field(i).Name\n\n\t\tif srcField := srcValue.FieldByName(destFieldName); srcField.IsValid() && srcField.Type() != destFieldType {\n\t\t\treturn fmt.Errorf(\"mismatched field type for field %s\", destFieldName)\n\t\t} else if srcField.IsValid() {\n\t\t\tdestField.Set(srcField)\n\t\t}\n\t}\n\n\tif !omitExtra {\n\t\tfor i := 0; i < srcValue.NumField(); i++ {\n\t\t\tsrcFieldName := srcValue.Type().Field(i).Name\n\n\t\t\tif destField := destValue.FieldByName(srcFieldName); !destField.IsValid() {\n\t\t\t\treturn fmt.Errorf(\"extra field %s in src\", srcFieldName)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc deserializeNameAndValueToMap(headersArray []map[string]string) map[string]string {\n\tunserialized := make(map[string]string)\n\tfor _, item := range headersArray {\n\t\tunserialized[item[\"name\"]] = item[\"value\"]\n\t}\n\treturn unserialized\n}\n\ntype recordHarOptions struct {\n\tPath           string            `json:\"path\"`\n\tContent        *HarContentPolicy `json:\"content,omitempty\"`\n\tMode           *HarMode          `json:\"mode,omitempty\"`\n\tUrlGlob        *string           `json:\"urlGlob,omitempty\"`\n\tUrlRegexSource *string           `json:\"urlRegexSource,omitempty\"`\n\tUrlRegexFlags  *string           `json:\"urlRegexFlags,omitempty\"`\n}\n\ntype recordHarInputOptions struct {\n\tPath        string\n\tURL         interface{}\n\tMode        *HarMode\n\tContent     *HarContentPolicy\n\tOmitContent *bool\n}\n\ntype harRecordingMetadata struct {\n\tPath    string\n\tContent *HarContentPolicy\n}\n\nfunc prepareRecordHarOptions(option recordHarInputOptions) recordHarOptions {\n\tout := recordHarOptions{\n\t\tPath: option.Path,\n\t}\n\tif option.URL != nil {\n\t\tswitch option.URL.(type) {\n\t\tcase *regexp.Regexp:\n\t\t\tpattern, flags := convertRegexp(option.URL.(*regexp.Regexp))\n\t\t\tout.UrlRegexSource = String(pattern)\n\t\t\tout.UrlRegexFlags = String(flags)\n\t\tcase string:\n\t\t\tout.UrlGlob = String(option.URL.(string))\n\t\t}\n\t}\n\tif option.Mode != nil {\n\t\tout.Mode = option.Mode\n\t}\n\tif option.Content != nil {\n\t\tout.Content = option.Content\n\t} else if option.OmitContent != nil && *option.OmitContent {\n\t\tout.Content = HarContentPolicyOmit\n\t}\n\treturn out\n}\n\ntype safeValue[T any] struct {\n\tsync.Mutex\n\tv T\n}\n\nfunc (s *safeValue[T]) Set(v T) {\n\ts.Lock()\n\tdefer s.Unlock()\n\ts.v = v\n}\n\nfunc (s *safeValue[T]) Get() T {\n\ts.Lock()\n\tdefer s.Unlock()\n\treturn s.v\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 5.41796875,
          "content": "package playwright\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype testOptionsJSONSerialization struct {\n\tStringPointer  *string `json:\"stringPointer\"`\n\tNormalString   string  `json:\"normalString\"`\n\tWithoutJSONTag string\n\tWithJSONTag    string   `json:\"withJSONTag\"`\n\tOverrideMe     []string `json:\"overrideMe\"`\n\tSkipNilPtrs    *string  `json:\"skipNilPtrs\"`\n\tSkipMe         *int     `json:\"skipMe\"`\n}\n\nfunc TestTransformOptions(t *testing.T) {\n\t// test data\n\tstructVar := &testOptionsJSONSerialization{\n\t\tStringPointer:  String(\"1\"),\n\t\tNormalString:   \"2\",\n\t\tWithoutJSONTag: \"3\",\n\t\tWithJSONTag:    \"4\",\n\t\tOverrideMe:     []string{\"5\"},\n\t}\n\tvar nilStrPtr *string\n\ttestCases := []struct {\n\t\tname         string\n\t\tfirstOption  interface{}\n\t\tsecondOption interface{}\n\t\texpected     interface{}\n\t}{\n\t\t{\n\t\t\tname: \"No options supplied\",\n\t\t\tfirstOption: map[string]interface{}{\n\t\t\t\t\"1234\": nilStrPtr,\n\t\t\t\t\"foo\":  \"bar\",\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Options are nil\",\n\t\t\tfirstOption: map[string]interface{}{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t\tsecondOption: nil,\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"foo\": \"bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"JSON serialization works\",\n\t\t\tfirstOption: map[string]interface{}{\n\t\t\t\t\"foo\":           \"bar\",\n\t\t\t\t\"stringPointer\": 1,\n\t\t\t},\n\t\t\tsecondOption: structVar,\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"foo\":            \"bar\",\n\t\t\t\t\"stringPointer\":  String(\"1\"),\n\t\t\t\t\"normalString\":   \"2\",\n\t\t\t\t\"WithoutJSONTag\": \"3\",\n\t\t\t\t\"withJSONTag\":    \"4\",\n\t\t\t\t\"overrideMe\":     []interface{}{\"5\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Second overwrites the first one\",\n\t\t\tfirstOption: map[string]interface{}{\n\t\t\t\t\"foo\": \"1\",\n\t\t\t},\n\t\t\tsecondOption: map[string]interface{}{\n\t\t\t\t\"foo\": \"2\",\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"foo\": \"2\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"Second overwrites the first one's value in different type\",\n\t\t\tfirstOption: structVar,\n\t\t\tsecondOption: map[string]interface{}{\n\t\t\t\t\"overrideMe\": \"5\",\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"stringPointer\":  String(\"1\"),\n\t\t\t\t\"normalString\":   \"2\",\n\t\t\t\t\"WithoutJSONTag\": \"3\",\n\t\t\t\t\"withJSONTag\":    \"4\",\n\t\t\t\t\"overrideMe\":     \"5\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trequire.Equal(t, tc.expected, transformOptions(tc.firstOption, tc.secondOption))\n\t\t})\n\t}\n}\n\nfunc TestRemapMapToStruct(t *testing.T) {\n\tourStruct := struct {\n\t\tV1 string `json:\"v1\"`\n\t}{}\n\tinMap := map[string]interface{}{\n\t\t\"v1\": \"foobar\",\n\t}\n\tremapMapToStruct(inMap, &ourStruct)\n\trequire.Equal(t, ourStruct.V1, \"foobar\")\n}\n\nfunc TestConvertSelectOptionSet(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\toptionValues SelectOptionValues\n\t\texpected     interface{}\n\t}{\n\t\t{\n\t\t\tname:         \"SelectOptionValues is nil\",\n\t\t\toptionValues: SelectOptionValues{},\n\t\t\texpected:     make(map[string]interface{}),\n\t\t},\n\t\t{\n\t\t\tname: \"SelectOptionValues is supplied\",\n\t\t\toptionValues: SelectOptionValues{\n\t\t\t\tValuesOrLabels: StringSlice(\"c\", \"d\"),\n\t\t\t\tValues:         StringSlice(\"a\", \"b\"),\n\t\t\t\tIndexes:        IntSlice(1),\n\t\t\t\tLabels:         StringSlice(\"x\"),\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"options\": []map[string]interface{}{\n\t\t\t\t\t{\"valueOrLabel\": \"c\"}, {\"valueOrLabel\": \"d\"}, {\"value\": \"a\"}, {\"value\": \"b\"}, {\"index\": 1}, {\"label\": \"x\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Only value is supplied\",\n\t\t\toptionValues: SelectOptionValues{\n\t\t\t\tValues: StringSlice(\"a\", \"b\"),\n\t\t\t},\n\t\t\texpected: map[string]interface{}{\n\t\t\t\t\"options\": []map[string]interface{}{\n\t\t\t\t\t{\"value\": \"a\"}, {\"value\": \"b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trequire.Equal(t, tc.expected, convertSelectOptionSet(tc.optionValues))\n\t\t})\n\t}\n}\n\nfunc TestAssignFields(t *testing.T) {\n\ttype (\n\t\tA struct {\n\t\t\tField1 string\n\t\t\tField2 int\n\t\t}\n\t\tB struct {\n\t\t\tField1 string\n\t\t\tField2 int\n\t\t\tField3 float64\n\t\t}\n\t\targs struct {\n\t\t\tdest      interface{}\n\t\t\tsrc       interface{}\n\t\t\tomitExtra bool\n\t\t}\n\t)\n\ttestV := \"foo\"\n\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"src is nil\",\n\t\t\targs: args{\n\t\t\t\tdest:      &B{},\n\t\t\t\tsrc:       nil,\n\t\t\t\tomitExtra: true,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"src is not struct\",\n\t\t\targs: args{\n\t\t\t\tdest:      &B{},\n\t\t\t\tsrc:       \"foo\",\n\t\t\t\tomitExtra: true,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"dest is nil\",\n\t\t\targs: args{\n\t\t\t\tdest:      nil,\n\t\t\t\tsrc:       &A{},\n\t\t\t\tomitExtra: true,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"dest is not struct\",\n\t\t\targs: args{\n\t\t\t\tdest:      &testV,\n\t\t\t\tsrc:       &A{},\n\t\t\t\tomitExtra: true,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"dest includes all src fields\",\n\t\t\targs: args{\n\t\t\t\tdest: &B{},\n\t\t\t\tsrc: &A{\n\t\t\t\t\tField1: \"hello\",\n\t\t\t\t\tField2: 42,\n\t\t\t\t},\n\t\t\t\tomitExtra: true,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"dest does not include all src fields, omit extra fields\",\n\t\t\targs: args{\n\t\t\t\tdest: &A{},\n\t\t\t\tsrc: &B{\n\t\t\t\t\tField1: \"hello\",\n\t\t\t\t\tField2: 42,\n\t\t\t\t\tField3: 3.14,\n\t\t\t\t},\n\t\t\t\tomitExtra: true,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"dest does not include all src fields\",\n\t\t\targs: args{\n\t\t\t\tdest: &A{},\n\t\t\t\tsrc: &B{\n\t\t\t\t\tField1: \"hello\",\n\t\t\t\t\tField2: 42,\n\t\t\t\t\tField3: 3.14,\n\t\t\t\t},\n\t\t\t\tomitExtra: false,\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := assignStructFields(tt.args.dest, tt.args.src, tt.args.omitExtra); (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"assignFields() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 2.4970703125,
          "content": "package playwright\n\ntype mouseImpl struct {\n\tchannel *channel\n}\n\nfunc newMouse(channel *channel) *mouseImpl {\n\treturn &mouseImpl{\n\t\tchannel: channel,\n\t}\n}\n\nfunc (m *mouseImpl) Move(x float64, y float64, options ...MouseMoveOptions) error {\n\t_, err := m.channel.Send(\"mouseMove\", map[string]interface{}{\n\t\t\"x\": x,\n\t\t\"y\": y,\n\t}, options)\n\treturn err\n}\n\nfunc (m *mouseImpl) Down(options ...MouseDownOptions) error {\n\t_, err := m.channel.Send(\"mouseDown\", options)\n\treturn err\n}\n\nfunc (m *mouseImpl) Up(options ...MouseUpOptions) error {\n\t_, err := m.channel.Send(\"mouseUp\", options)\n\treturn err\n}\n\nfunc (m *mouseImpl) Click(x, y float64, options ...MouseClickOptions) error {\n\t_, err := m.channel.Send(\"mouseClick\", map[string]interface{}{\n\t\t\"x\": x,\n\t\t\"y\": y,\n\t}, options)\n\treturn err\n}\n\nfunc (m *mouseImpl) Dblclick(x, y float64, options ...MouseDblclickOptions) error {\n\tvar option MouseDblclickOptions\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\treturn m.Click(x, y, MouseClickOptions{\n\t\tClickCount: Int(2),\n\t\tButton:     option.Button,\n\t\tDelay:      option.Delay,\n\t})\n}\n\nfunc (m *mouseImpl) Wheel(deltaX, deltaY float64) error {\n\t_, err := m.channel.Send(\"mouseWheel\", map[string]interface{}{\n\t\t\"deltaX\": deltaX,\n\t\t\"deltaY\": deltaY,\n\t})\n\treturn err\n}\n\ntype keyboardImpl struct {\n\tchannel *channel\n}\n\nfunc newKeyboard(channel *channel) *keyboardImpl {\n\treturn &keyboardImpl{\n\t\tchannel: channel,\n\t}\n}\n\nfunc (m *keyboardImpl) Down(key string) error {\n\t_, err := m.channel.Send(\"keyboardDown\", map[string]interface{}{\n\t\t\"key\": key,\n\t})\n\treturn err\n}\n\nfunc (m *keyboardImpl) Up(key string) error {\n\t_, err := m.channel.Send(\"keyboardUp\", map[string]interface{}{\n\t\t\"key\": key,\n\t})\n\treturn err\n}\n\nfunc (m *keyboardImpl) InsertText(text string) error {\n\t_, err := m.channel.Send(\"keyboardInsertText\", map[string]interface{}{\n\t\t\"text\": text,\n\t})\n\treturn err\n}\n\nfunc (m *keyboardImpl) Type(text string, options ...KeyboardTypeOptions) error {\n\t_, err := m.channel.Send(\"keyboardInsertText\", map[string]interface{}{\n\t\t\"text\": text,\n\t}, options)\n\treturn err\n}\n\nfunc (m *keyboardImpl) Press(key string, options ...KeyboardPressOptions) error {\n\t_, err := m.channel.Send(\"keyboardPress\", map[string]interface{}{\n\t\t\"key\": key,\n\t}, options)\n\treturn err\n}\n\ntype touchscreenImpl struct {\n\tchannel *channel\n}\n\nfunc newTouchscreen(channel *channel) *touchscreenImpl {\n\treturn &touchscreenImpl{\n\t\tchannel: channel,\n\t}\n}\n\nfunc (t *touchscreenImpl) Tap(x int, y int) error {\n\t_, err := t.channel.Send(\"touchscreenTap\", map[string]interface{}{\"x\": x, \"y\": y})\n\treturn err\n}\n"
        },
        {
          "name": "input_files_helper.go",
          "type": "blob",
          "size": 5.091796875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nconst fileSizeLimitInBytes = 50 * 1024 * 1024\n\nvar ErrInputFilesSizeExceeded = errors.New(\"Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.\")\n\ntype inputFiles struct {\n\tSelector        *string             `json:\"selector,omitempty\"`\n\tStreams         []*channel          `json:\"streams,omitempty\"` // writableStream\n\tLocalPaths      []string            `json:\"localPaths,omitempty\"`\n\tPayloads        []map[string]string `json:\"payloads,omitempty\"`\n\tLocalDirectory  *string             `json:\"localDirectory,omitempty\"`\n\tDirectoryStream *channel            `json:\"directoryStream,omitempty\"`\n}\n\ntype fileItem struct {\n\tLastModifiedMs *int64 `json:\"lastModifiedMs,omitempty\"`\n\tName           string `json:\"name\"`\n}\n\n// convertInputFiles converts files to proper format for Playwright\n//\n//   - files should be one of: string, []string, InputFile, []InputFile,\n//     string: local file path\nfunc convertInputFiles(files interface{}, context *browserContextImpl) (*inputFiles, error) {\n\tvar (\n\t\tconverted = &inputFiles{}\n\t\tpaths     []string\n\t)\n\tswitch items := files.(type) {\n\tcase InputFile:\n\t\tif sizeOfInputFiles([]InputFile{items}) > fileSizeLimitInBytes {\n\t\t\treturn nil, ErrInputFilesSizeExceeded\n\t\t}\n\t\tconverted.Payloads = normalizeFilePayloads([]InputFile{items})\n\tcase []InputFile:\n\t\tif sizeOfInputFiles(items) > fileSizeLimitInBytes {\n\t\t\treturn nil, ErrInputFilesSizeExceeded\n\t\t}\n\t\tconverted.Payloads = normalizeFilePayloads(items)\n\tcase string: // local file path\n\t\tpaths = []string{items}\n\tcase []string:\n\t\tpaths = items\n\tdefault:\n\t\treturn nil, errors.New(\"files should be one of: string, []string, InputFile, []InputFile\")\n\t}\n\n\tlocalPaths, localDir, err := resolvePathsAndDirectoryForInputFiles(paths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !context.connection.isRemote {\n\t\tconverted.LocalPaths = localPaths\n\t\tconverted.LocalDirectory = localDir\n\t\treturn converted, nil\n\t}\n\n\t// remote\n\tparams := map[string]interface{}{\n\t\t\"items\": []fileItem{},\n\t}\n\tallFiles := localPaths\n\tif localDir != nil {\n\t\tparams[\"rootDirName\"] = filepath.Base(*localDir)\n\t\tallFiles, err = listFiles(*localDir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfor _, file := range allFiles {\n\t\tlastModifiedMs, err := getFileLastModifiedMs(file)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to get last modified time of %s: %w\", file, err)\n\t\t}\n\t\tfilename := filepath.Base(file)\n\t\tif localDir != nil {\n\t\t\tvar err error\n\t\t\tfilename, err = filepath.Rel(*localDir, file)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tparams[\"items\"] = append(params[\"items\"].([]fileItem), fileItem{\n\t\t\tLastModifiedMs: &lastModifiedMs,\n\t\t\tName:           filename,\n\t\t})\n\t}\n\n\tret, err := context.connection.WrapAPICall(func() (interface{}, error) {\n\t\treturn context.channel.SendReturnAsDict(\"createTempFiles\", params)\n\t}, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := ret.(map[string]interface{})\n\n\tstreams := make([]*channel, 0)\n\titems := result[\"writableStreams\"].([]interface{})\n\tfor i := 0; i < len(allFiles); i++ {\n\t\tstream := fromChannel(items[i]).(*writableStream)\n\t\tif err := stream.Copy(allFiles[i]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tstreams = append(streams, stream.channel)\n\t}\n\n\tif result[\"rootDir\"] != nil {\n\t\tconverted.DirectoryStream = result[\"rootDir\"].(*channel)\n\t} else {\n\t\tconverted.Streams = streams\n\t}\n\n\treturn converted, nil\n}\n\nfunc getFileLastModifiedMs(path string) (int64, error) {\n\tinfo, err := os.Stat(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif info.IsDir() {\n\t\treturn 0, fmt.Errorf(\"%s is a directory\", path)\n\t}\n\treturn info.ModTime().UnixMilli(), nil\n}\n\nfunc sizeOfInputFiles(files []InputFile) int {\n\tsize := 0\n\tfor _, file := range files {\n\t\tsize += len(file.Buffer)\n\t}\n\treturn size\n}\n\nfunc normalizeFilePayloads(files []InputFile) []map[string]string {\n\tout := make([]map[string]string, 0)\n\tfor _, file := range files {\n\t\tout = append(out, map[string]string{\n\t\t\t\"name\":     file.Name,\n\t\t\t\"mimeType\": file.MimeType,\n\t\t\t\"buffer\":   base64.StdEncoding.EncodeToString(file.Buffer),\n\t\t})\n\t}\n\treturn out\n}\n\nfunc resolvePathsAndDirectoryForInputFiles(items []string) (localPaths []string, localDirectory *string, e error) {\n\tfor _, item := range items {\n\t\tabspath, err := filepath.Abs(item)\n\t\tif err != nil {\n\t\t\te = err\n\t\t\treturn\n\t\t}\n\t\t// if the path is a directory\n\t\tif info, err := os.Stat(abspath); err == nil {\n\t\t\tif info.IsDir() {\n\t\t\t\tif localDirectory != nil {\n\t\t\t\t\te = errors.New(\"Multiple directories are not supported\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlocalDirectory = &abspath\n\t\t\t} else {\n\t\t\t\tif localPaths == nil {\n\t\t\t\t\tlocalPaths = []string{abspath}\n\t\t\t\t} else {\n\t\t\t\t\tlocalPaths = append(localPaths, abspath)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\te = err\n\t\t\treturn\n\t\t}\n\t}\n\tif localPaths != nil && localDirectory != nil {\n\t\te = errors.New(\"File paths must be all files or a single directory\")\n\t}\n\treturn\n}\n\nfunc listFiles(dir string) ([]string, error) {\n\tvar files []string\n\terr := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !info.IsDir() {\n\t\t\tfiles = append(files, path)\n\t\t}\n\t\treturn nil\n\t})\n\treturn files, err\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "js_handle.go",
          "type": "blob",
          "size": 7.1982421875,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"time\"\n)\n\ntype jsHandleImpl struct {\n\tchannelOwner\n\tpreview string\n}\n\nfunc (j *jsHandleImpl) Evaluate(expression string, options ...interface{}) (interface{}, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := j.channel.Send(\"evaluateExpression\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (j *jsHandleImpl) EvaluateHandle(expression string, options ...interface{}) (JSHandle, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := j.channel.Send(\"evaluateExpressionHandle\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromChannel(result)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*jsHandleImpl), nil\n}\n\nfunc (j *jsHandleImpl) GetProperty(name string) (JSHandle, error) {\n\tchannel, err := j.channel.Send(\"getProperty\", map[string]interface{}{\n\t\t\"name\": name,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(channel).(*jsHandleImpl), nil\n}\n\nfunc (j *jsHandleImpl) GetProperties() (map[string]JSHandle, error) {\n\tproperties, err := j.channel.Send(\"getPropertyList\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpropertiesMap := make(map[string]JSHandle)\n\tfor _, property := range properties.([]interface{}) {\n\t\titem := property.(map[string]interface{})\n\t\tpropertiesMap[item[\"name\"].(string)] = fromChannel(item[\"value\"]).(*jsHandleImpl)\n\t}\n\treturn propertiesMap, nil\n}\n\nfunc (j *jsHandleImpl) AsElement() ElementHandle {\n\treturn nil\n}\n\nfunc (j *jsHandleImpl) Dispose() error {\n\t_, err := j.channel.Send(\"dispose\")\n\tif errors.Is(err, ErrTargetClosed) {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc (j *jsHandleImpl) String() string {\n\treturn j.preview\n}\n\nfunc (j *jsHandleImpl) JSONValue() (interface{}, error) {\n\tv, err := j.channel.Send(\"jsonValue\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(v), nil\n}\n\nfunc parseValue(result interface{}, refs map[float64]interface{}) interface{} {\n\tvMap, ok := result.(map[string]interface{})\n\tif !ok {\n\t\treturn result\n\t}\n\tif v, ok := vMap[\"n\"]; ok {\n\t\tif math.Ceil(v.(float64))-v.(float64) == 0 {\n\t\t\treturn int(v.(float64))\n\t\t}\n\t\treturn v.(float64)\n\t}\n\n\tif v, ok := vMap[\"u\"]; ok {\n\t\tu, _ := url.Parse(v.(string))\n\t\treturn u\n\t}\n\n\tif v, ok := vMap[\"bi\"]; ok {\n\t\tn := new(big.Int)\n\t\tn.SetString(v.(string), 0)\n\t\treturn n\n\t}\n\n\tif v, ok := vMap[\"ref\"]; ok {\n\t\tif vV, ok := refs[v.(float64)]; ok {\n\t\t\treturn vV\n\t\t}\n\t\treturn nil\n\t}\n\n\tif v, ok := vMap[\"s\"]; ok {\n\t\treturn v.(string)\n\t}\n\tif v, ok := vMap[\"b\"]; ok {\n\t\treturn v.(bool)\n\t}\n\tif v, ok := vMap[\"v\"]; ok {\n\t\tif v == \"undefined\" || v == \"null\" {\n\t\t\treturn nil\n\t\t}\n\t\tif v == \"NaN\" {\n\t\t\treturn math.NaN()\n\t\t}\n\t\tif v == \"Infinity\" {\n\t\t\treturn math.Inf(1)\n\t\t}\n\t\tif v == \"-Infinity\" {\n\t\t\treturn math.Inf(-1)\n\t\t}\n\t\tif v == \"-0\" {\n\t\t\treturn math.Copysign(0, -1)\n\t\t}\n\t\treturn v\n\t}\n\tif v, ok := vMap[\"d\"]; ok {\n\t\tt, _ := time.Parse(time.RFC3339Nano, v.(string))\n\t\treturn t\n\t}\n\tif v, ok := vMap[\"a\"]; ok {\n\t\taV := v.([]interface{})\n\t\trefs[vMap[\"id\"].(float64)] = aV\n\t\tfor i := range aV {\n\t\t\taV[i] = parseValue(aV[i], refs)\n\t\t}\n\t\treturn aV\n\t}\n\tif v, ok := vMap[\"o\"]; ok {\n\t\taV := v.([]interface{})\n\t\tout := map[string]interface{}{}\n\t\trefs[vMap[\"id\"].(float64)] = out\n\t\tfor key := range aV {\n\t\t\tentry := aV[key].(map[string]interface{})\n\t\t\tout[entry[\"k\"].(string)] = parseValue(entry[\"v\"], refs)\n\t\t}\n\t\treturn out\n\t}\n\n\tif v, ok := vMap[\"e\"]; ok {\n\t\treturn parseError(Error{\n\t\t\tName:    v.(map[string]interface{})[\"n\"].(string),\n\t\t\tMessage: v.(map[string]interface{})[\"m\"].(string),\n\t\t\tStack:   v.(map[string]interface{})[\"s\"].(string),\n\t\t})\n\t}\n\tpanic(fmt.Errorf(\"Unexpected value: %v\", vMap))\n}\n\nfunc serializeValue(value interface{}, handles *[]*channel, depth int) interface{} {\n\tif handle, ok := value.(*elementHandleImpl); ok {\n\t\th := len(*handles)\n\t\t*handles = append(*handles, handle.channel)\n\t\treturn map[string]interface{}{\n\t\t\t\"h\": h,\n\t\t}\n\t}\n\tif handle, ok := value.(*jsHandleImpl); ok {\n\t\th := len(*handles)\n\t\t*handles = append(*handles, handle.channel)\n\t\treturn map[string]interface{}{\n\t\t\t\"h\": h,\n\t\t}\n\t}\n\tif u, ok := value.(*url.URL); ok {\n\t\treturn map[string]interface{}{\n\t\t\t\"u\": u.String(),\n\t\t}\n\t}\n\n\tif err, ok := value.(error); ok {\n\t\tvar e *Error\n\t\tif errors.As(err, &e) {\n\t\t\treturn map[string]interface{}{\n\t\t\t\t\"e\": map[string]interface{}{\n\t\t\t\t\t\"n\": e.Name,\n\t\t\t\t\t\"m\": e.Message,\n\t\t\t\t\t\"s\": e.Stack,\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\treturn map[string]interface{}{\n\t\t\t\"e\": map[string]interface{}{\n\t\t\t\t\"n\": \"\",\n\t\t\t\t\"m\": err.Error(),\n\t\t\t\t\"s\": \"\",\n\t\t\t},\n\t\t}\n\t}\n\n\tif depth > 100 {\n\t\tpanic(errors.New(\"Maximum argument depth exceeded\"))\n\t}\n\tif value == nil {\n\t\treturn map[string]interface{}{\n\t\t\t\"v\": \"undefined\",\n\t\t}\n\t}\n\tif n, ok := value.(*big.Int); ok {\n\t\treturn map[string]interface{}{\n\t\t\t\"bi\": n.String(),\n\t\t}\n\t}\n\n\tswitch v := value.(type) {\n\tcase time.Time:\n\t\treturn map[string]interface{}{\n\t\t\t\"d\": v.Format(time.RFC3339Nano),\n\t\t}\n\tcase int:\n\t\treturn map[string]interface{}{\n\t\t\t\"n\": v,\n\t\t}\n\tcase string:\n\t\treturn map[string]interface{}{\n\t\t\t\"s\": v,\n\t\t}\n\tcase bool:\n\t\treturn map[string]interface{}{\n\t\t\t\"b\": v,\n\t\t}\n\t}\n\n\trefV := reflect.ValueOf(value)\n\n\tswitch refV.Kind() {\n\tcase reflect.Float32, reflect.Float64:\n\t\tfloatV := refV.Float()\n\t\tif math.IsInf(floatV, 1) {\n\t\t\treturn map[string]interface{}{\n\t\t\t\t\"v\": \"Infinity\",\n\t\t\t}\n\t\t}\n\t\tif math.IsInf(floatV, -1) {\n\t\t\treturn map[string]interface{}{\n\t\t\t\t\"v\": \"-Infinity\",\n\t\t\t}\n\t\t}\n\t\t// https://github.com/golang/go/issues/2196\n\t\tif floatV == math.Copysign(0, -1) {\n\t\t\treturn map[string]interface{}{\n\t\t\t\t\"v\": \"-0\",\n\t\t\t}\n\t\t}\n\t\tif math.IsNaN(floatV) {\n\t\t\treturn map[string]interface{}{\n\t\t\t\t\"v\": \"NaN\",\n\t\t\t}\n\t\t}\n\t\treturn map[string]interface{}{\n\t\t\t\"n\": floatV,\n\t\t}\n\tcase reflect.Slice:\n\t\taV := make([]interface{}, refV.Len())\n\t\tfor i := 0; i < refV.Len(); i++ {\n\t\t\taV[i] = serializeValue(refV.Index(i).Interface(), handles, depth+1)\n\t\t}\n\t\treturn map[string]interface{}{\n\t\t\t\"a\": aV,\n\t\t}\n\tcase reflect.Map:\n\t\tout := []interface{}{}\n\t\tvM := value.(map[string]interface{})\n\t\tfor key := range vM {\n\t\t\tv := serializeValue(vM[key], handles, depth+1)\n\t\t\t// had key, so convert \"undefined\" to \"null\"\n\t\t\tif reflect.DeepEqual(v, map[string]interface{}{\n\t\t\t\t\"v\": \"undefined\",\n\t\t\t}) {\n\t\t\t\tv = map[string]interface{}{\n\t\t\t\t\t\"v\": \"null\",\n\t\t\t\t}\n\t\t\t}\n\t\t\tout = append(out, map[string]interface{}{\n\t\t\t\t\"k\": key,\n\t\t\t\t\"v\": v,\n\t\t\t})\n\t\t}\n\t\treturn map[string]interface{}{\n\t\t\t\"o\": out,\n\t\t}\n\t}\n\treturn map[string]interface{}{\n\t\t\"v\": \"undefined\",\n\t}\n}\n\nfunc parseResult(result interface{}) interface{} {\n\treturn parseValue(result, map[float64]interface{}{})\n}\n\nfunc serializeArgument(arg interface{}) interface{} {\n\thandles := []*channel{}\n\tvalue := serializeValue(arg, &handles, 0)\n\treturn map[string]interface{}{\n\t\t\"value\":   value,\n\t\t\"handles\": handles,\n\t}\n}\n\nfunc newJSHandle(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *jsHandleImpl {\n\tbt := &jsHandleImpl{\n\t\tpreview: initializer[\"preview\"].(string),\n\t}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tbt.channel.On(\"previewUpdated\", func(ev map[string]interface{}) {\n\t\tbt.preview = ev[\"preview\"].(string)\n\t})\n\treturn bt\n}\n"
        },
        {
          "name": "jsonPipe.go",
          "type": "blob",
          "size": 1.267578125,
          "content": "package playwright\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype jsonPipe struct {\n\tchannelOwner\n\tmsgChan chan *message\n}\n\nfunc (j *jsonPipe) Send(message map[string]interface{}) error {\n\t_, err := j.channel.Send(\"send\", map[string]interface{}{\n\t\t\"message\": message,\n\t})\n\treturn err\n}\n\nfunc (j *jsonPipe) Close() error {\n\t_, err := j.channel.Send(\"close\")\n\treturn err\n}\n\nfunc (j *jsonPipe) Poll() (*message, error) {\n\tmsg := <-j.msgChan\n\tif msg == nil {\n\t\treturn nil, errors.New(\"jsonPipe closed\")\n\t}\n\treturn msg, nil\n}\n\nfunc newJsonPipe(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *jsonPipe {\n\tj := &jsonPipe{\n\t\tmsgChan: make(chan *message, 2),\n\t}\n\tj.createChannelOwner(j, parent, objectType, guid, initializer)\n\tj.channel.On(\"message\", func(ev map[string]interface{}) {\n\t\tvar msg message\n\t\tm, err := json.Marshal(ev[\"message\"])\n\t\tif err == nil {\n\t\t\terr = json.Unmarshal(m, &msg)\n\t\t}\n\t\tif err != nil {\n\t\t\tmsg = message{\n\t\t\t\tError: &struct {\n\t\t\t\t\tError Error \"json:\\\"error\\\"\"\n\t\t\t\t}{\n\t\t\t\t\tError: Error{\n\t\t\t\t\t\tName:    \"Error\",\n\t\t\t\t\t\tMessage: fmt.Sprintf(\"jsonPipe: could not decode message: %s\", err.Error()),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tj.msgChan <- &msg\n\t})\n\tj.channel.Once(\"closed\", func() {\n\t\tj.Emit(\"closed\")\n\t\tclose(j.msgChan)\n\t})\n\treturn j\n}\n"
        },
        {
          "name": "local_utils.go",
          "type": "blob",
          "size": 4.482421875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype localUtilsImpl struct {\n\tchannelOwner\n\tDevices map[string]*DeviceDescriptor\n}\n\ntype (\n\tlocalUtilsZipOptions struct {\n\t\tZipFile        string        `json:\"zipFile\"`\n\t\tEntries        []interface{} `json:\"entries\"`\n\t\tStacksId       string        `json:\"stacksId\"`\n\t\tMode           string        `json:\"mode\"`\n\t\tIncludeSources bool          `json:\"includeSources\"`\n\t}\n\n\tharLookupOptions struct {\n\t\tHarId               string            `json:\"harId\"`\n\t\tURL                 string            `json:\"url\"`\n\t\tMethod              string            `json:\"method\"`\n\t\tHeaders             map[string]string `json:\"headers\"`\n\t\tIsNavigationRequest bool              `json:\"isNavigationRequest\"`\n\t\tPostData            interface{}       `json:\"postData,omitempty\"`\n\t}\n\n\tharLookupResult struct {\n\t\tAction      string              `json:\"action\"`\n\t\tMessage     *string             `json:\"message,omitempty\"`\n\t\tRedirectURL *string             `json:\"redirectUrl,omitempty\"`\n\t\tStatus      *int                `json:\"status,omitempty\"`\n\t\tHeaders     []map[string]string `json:\"headers,omitempty\"`\n\t\tBody        *string             `json:\"body,omitempty\"`\n\t}\n)\n\nfunc (l *localUtilsImpl) Zip(options localUtilsZipOptions) (interface{}, error) {\n\treturn l.channel.Send(\"zip\", options)\n}\n\nfunc (l *localUtilsImpl) HarOpen(file string) (string, error) {\n\tresult, err := l.channel.SendReturnAsDict(\"harOpen\", []map[string]interface{}{\n\t\t{\n\t\t\t\"file\": file,\n\t\t},\n\t})\n\tif err == nil {\n\t\tif harId, ok := result[\"harId\"]; ok {\n\t\t\treturn harId.(string), nil\n\t\t}\n\t\tif err, ok := result[\"error\"]; ok {\n\t\t\treturn \"\", fmt.Errorf(\"%w:%v\", ErrPlaywright, err)\n\t\t}\n\t}\n\treturn \"\", err\n}\n\nfunc (l *localUtilsImpl) HarLookup(option harLookupOptions) (*harLookupResult, error) {\n\toverrides := make(map[string]interface{})\n\toverrides[\"harId\"] = option.HarId\n\toverrides[\"url\"] = option.URL\n\toverrides[\"method\"] = option.Method\n\tif option.Headers != nil {\n\t\toverrides[\"headers\"] = serializeMapToNameAndValue(option.Headers)\n\t}\n\toverrides[\"isNavigationRequest\"] = option.IsNavigationRequest\n\tif option.PostData != nil {\n\t\tswitch v := option.PostData.(type) {\n\t\tcase string:\n\t\t\toverrides[\"postData\"] = base64.StdEncoding.EncodeToString([]byte(v))\n\t\tcase []byte:\n\t\t\toverrides[\"postData\"] = base64.StdEncoding.EncodeToString(v)\n\t\t}\n\t}\n\tret, err := l.channel.SendReturnAsDict(\"harLookup\", overrides)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\tvar result harLookupResult\n\tmJson, err := json.Marshal(ret)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = json.Unmarshal(mJson, &result)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif result.Body != nil {\n\t\tbody, err := base64.StdEncoding.DecodeString(*result.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult.Body = String(string(body))\n\t}\n\treturn &result, err\n}\n\nfunc (l *localUtilsImpl) HarClose(harId string) error {\n\t_, err := l.channel.Send(\"harClose\", []map[string]interface{}{\n\t\t{\n\t\t\t\"harId\": harId,\n\t\t},\n\t})\n\treturn err\n}\n\nfunc (l *localUtilsImpl) HarUnzip(zipFile, harFile string) error {\n\t_, err := l.channel.Send(\"harUnzip\", []map[string]interface{}{\n\t\t{\n\t\t\t\"zipFile\": zipFile,\n\t\t\t\"harFile\": harFile,\n\t\t},\n\t})\n\treturn err\n}\n\nfunc (l *localUtilsImpl) TracingStarted(traceName string, tracesDir ...string) (string, error) {\n\toverrides := make(map[string]interface{})\n\toverrides[\"traceName\"] = traceName\n\tif len(tracesDir) > 0 {\n\t\toverrides[\"tracesDir\"] = tracesDir[0]\n\t}\n\tstacksId, err := l.channel.Send(\"tracingStarted\", overrides)\n\tif stacksId == nil {\n\t\treturn \"\", err\n\t}\n\treturn stacksId.(string), err\n}\n\nfunc (l *localUtilsImpl) TraceDiscarded(stacksId string) error {\n\t_, err := l.channel.Send(\"traceDiscarded\", map[string]interface{}{\n\t\t\"stacksId\": stacksId,\n\t})\n\treturn err\n}\n\nfunc (l *localUtilsImpl) AddStackToTracingNoReply(id uint32, stack []map[string]interface{}) {\n\tl.channel.SendNoReply(\"addStackToTracingNoReply\", map[string]interface{}{\n\t\t\"callData\": map[string]interface{}{\n\t\t\t\"id\":    id,\n\t\t\t\"stack\": stack,\n\t\t},\n\t})\n}\n\nfunc newLocalUtils(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *localUtilsImpl {\n\tl := &localUtilsImpl{\n\t\tDevices: make(map[string]*DeviceDescriptor),\n\t}\n\tl.createChannelOwner(l, parent, objectType, guid, initializer)\n\tfor _, dd := range initializer[\"deviceDescriptors\"].([]interface{}) {\n\t\tentry := dd.(map[string]interface{})\n\t\tl.Devices[entry[\"name\"].(string)] = &DeviceDescriptor{\n\t\t\tViewport: &Size{},\n\t\t}\n\t\tremapMapToStruct(entry[\"descriptor\"], l.Devices[entry[\"name\"].(string)])\n\t}\n\tl.markAsInternalType()\n\treturn l\n}\n"
        },
        {
          "name": "locator.go",
          "type": "blob",
          "size": 21.3583984375,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\nvar (\n\ttestIdAttributeName    = \"data-testid\"\n\tErrLocatorNotSameFrame = errors.New(\"inner 'has' or 'hasNot' locator must belong to the same frame\")\n)\n\ntype locatorImpl struct {\n\tframe    *frameImpl\n\tselector string\n\toptions  *LocatorLocatorOptions\n\terr      error\n}\n\nfunc newLocator(frame *frameImpl, selector string, options ...LocatorLocatorOptions) *locatorImpl {\n\toption := &LocatorLocatorOptions{}\n\tif len(options) == 1 {\n\t\toption = &options[0]\n\t}\n\tlocator := &locatorImpl{frame: frame, selector: selector, options: option, err: nil}\n\tif option.HasText != nil {\n\t\tselector += fmt.Sprintf(` >> internal:has-text=%s`, escapeForTextSelector(option.HasText, false))\n\t}\n\tif option.HasNotText != nil {\n\t\tselector += fmt.Sprintf(` >> internal:has-not-text=%s`, escapeForTextSelector(option.HasNotText, false))\n\t}\n\tif option.Has != nil {\n\t\thas := option.Has.(*locatorImpl)\n\t\tif frame != has.frame {\n\t\t\tlocator.err = errors.Join(locator.err, ErrLocatorNotSameFrame)\n\t\t} else {\n\t\t\tselector += fmt.Sprintf(` >> internal:has=%s`, escapeText(has.selector))\n\t\t}\n\t}\n\tif option.HasNot != nil {\n\t\thasNot := option.HasNot.(*locatorImpl)\n\t\tif frame != hasNot.frame {\n\t\t\tlocator.err = errors.Join(locator.err, ErrLocatorNotSameFrame)\n\t\t} else {\n\t\t\tselector += fmt.Sprintf(` >> internal:has-not=%s`, escapeText(hasNot.selector))\n\t\t}\n\t}\n\tlocator.selector = selector\n\n\treturn locator\n}\n\nfunc (l *locatorImpl) equals(locator Locator) bool {\n\treturn l.frame == locator.(*locatorImpl).frame && l.err == locator.(*locatorImpl).err && l.selector == locator.(*locatorImpl).selector\n}\n\nfunc (l *locatorImpl) Err() error {\n\treturn l.err\n}\n\nfunc (l *locatorImpl) All() ([]Locator, error) {\n\tresult := make([]Locator, 0)\n\tcount, err := l.Count()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor i := 0; i < count; i++ {\n\t\tresult = append(result, l.Nth(i))\n\t}\n\treturn result, nil\n}\n\nfunc (l *locatorImpl) AllInnerTexts() ([]string, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\tinnerTexts, err := l.frame.EvalOnSelectorAll(l.selector, \"ee => ee.map(e => e.innerText)\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttexts := innerTexts.([]interface{})\n\tresult := make([]string, len(texts))\n\tfor i := range texts {\n\t\tresult[i] = texts[i].(string)\n\t}\n\treturn result, nil\n}\n\nfunc (l *locatorImpl) AllTextContents() ([]string, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\ttextContents, err := l.frame.EvalOnSelectorAll(l.selector, \"ee => ee.map(e => e.textContent || '')\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttexts := textContents.([]interface{})\n\tresult := make([]string, len(texts))\n\tfor i := range texts {\n\t\tresult[i] = texts[i].(string)\n\t}\n\treturn result, nil\n}\n\nfunc (l *locatorImpl) And(locator Locator) Locator {\n\treturn newLocator(l.frame, l.selector+` >> internal:and=`+escapeText(locator.(*locatorImpl).selector))\n}\n\nfunc (l *locatorImpl) Or(locator Locator) Locator {\n\treturn newLocator(l.frame, l.selector+` >> internal:or=`+escapeText(locator.(*locatorImpl).selector))\n}\n\nfunc (l *locatorImpl) Blur(options ...LocatorBlurOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\tparams := map[string]interface{}{\n\t\t\"selector\": l.selector,\n\t\t\"strict\":   true,\n\t}\n\tif len(options) == 1 {\n\t\tif options[0].Timeout != nil {\n\t\t\tparams[\"timeout\"] = options[0].Timeout\n\t\t}\n\t}\n\t_, err := l.frame.channel.Send(\"blur\", params)\n\treturn err\n}\n\nfunc (l *locatorImpl) AriaSnapshot(options ...LocatorAriaSnapshotOptions) (string, error) {\n\tvar option LocatorAriaSnapshotOptions\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tret, err := l.frame.channel.Send(\"ariaSnapshot\", option,\n\t\tmap[string]interface{}{\"selector\": l.selector})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn ret.(string), nil\n}\n\nfunc (l *locatorImpl) BoundingBox(options ...LocatorBoundingBoxOptions) (*Rect, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\tvar option FrameWaitForSelectorOptions\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t}\n\n\tresult, err := l.withElement(func(handle ElementHandle) (interface{}, error) {\n\t\treturn handle.BoundingBox()\n\t}, option)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result.(*Rect), nil\n}\n\nfunc (l *locatorImpl) Check(options ...LocatorCheckOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameCheckOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Check(l.selector, opt)\n}\n\nfunc (l *locatorImpl) Clear(options ...LocatorClearOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\tif len(options) == 1 {\n\t\treturn l.Fill(\"\", LocatorFillOptions{\n\t\t\tForce:   options[0].Force,\n\t\t\tTimeout: options[0].Timeout,\n\t\t})\n\t} else {\n\t\treturn l.Fill(\"\")\n\t}\n}\n\nfunc (l *locatorImpl) Click(options ...LocatorClickOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameClickOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Click(l.selector, opt)\n}\n\nfunc (l *locatorImpl) ContentFrame() FrameLocator {\n\treturn newFrameLocator(l.frame, l.selector)\n}\n\nfunc (l *locatorImpl) Count() (int, error) {\n\tif l.err != nil {\n\t\treturn 0, l.err\n\t}\n\treturn l.frame.queryCount(l.selector)\n}\n\nfunc (l *locatorImpl) Dblclick(options ...LocatorDblclickOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameDblclickOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Dblclick(l.selector, opt)\n}\n\nfunc (l *locatorImpl) DispatchEvent(typ string, eventInit interface{}, options ...LocatorDispatchEventOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameDispatchEventOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.DispatchEvent(l.selector, typ, eventInit, opt)\n}\n\nfunc (l *locatorImpl) DragTo(target Locator, options ...LocatorDragToOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameDragAndDropOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.DragAndDrop(l.selector, target.(*locatorImpl).selector, opt)\n}\n\nfunc (l *locatorImpl) ElementHandle(options ...LocatorElementHandleOptions) (ElementHandle, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\toption := FrameWaitForSelectorOptions{\n\t\tState:  WaitForSelectorStateAttached,\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&option, options[0], false); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn l.frame.WaitForSelector(l.selector, option)\n}\n\nfunc (l *locatorImpl) ElementHandles() ([]ElementHandle, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\treturn l.frame.QuerySelectorAll(l.selector)\n}\n\nfunc (l *locatorImpl) Evaluate(expression string, arg interface{}, options ...LocatorEvaluateOptions) (interface{}, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\tvar option FrameWaitForSelectorOptions\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t}\n\n\treturn l.withElement(func(handle ElementHandle) (interface{}, error) {\n\t\treturn handle.Evaluate(expression, arg)\n\t}, option)\n}\n\nfunc (l *locatorImpl) EvaluateAll(expression string, options ...interface{}) (interface{}, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\treturn l.frame.EvalOnSelectorAll(l.selector, expression, options...)\n}\n\nfunc (l *locatorImpl) EvaluateHandle(expression string, arg interface{}, options ...LocatorEvaluateHandleOptions) (JSHandle, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\tvar option FrameWaitForSelectorOptions\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t}\n\n\th, err := l.withElement(func(handle ElementHandle) (interface{}, error) {\n\t\treturn handle.EvaluateHandle(expression, arg)\n\t}, option)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn h.(JSHandle), nil\n}\n\nfunc (l *locatorImpl) Fill(value string, options ...LocatorFillOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameFillOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Fill(l.selector, value, opt)\n}\n\nfunc (l *locatorImpl) Filter(options ...LocatorFilterOptions) Locator {\n\tif len(options) == 1 {\n\t\treturn newLocator(l.frame, l.selector, LocatorLocatorOptions(options[0]))\n\t}\n\treturn newLocator(l.frame, l.selector)\n}\n\nfunc (l *locatorImpl) First() Locator {\n\treturn newLocator(l.frame, l.selector+\" >> nth=0\")\n}\n\nfunc (l *locatorImpl) Focus(options ...LocatorFocusOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameFocusOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Focus(l.selector, opt)\n}\n\nfunc (l *locatorImpl) FrameLocator(selector string) FrameLocator {\n\treturn newFrameLocator(l.frame, l.selector+\" >> \"+selector)\n}\n\nfunc (l *locatorImpl) GetAttribute(name string, options ...LocatorGetAttributeOptions) (string, error) {\n\tif l.err != nil {\n\t\treturn \"\", l.err\n\t}\n\topt := FrameGetAttributeOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn l.frame.GetAttribute(l.selector, name, opt)\n}\n\nfunc (l *locatorImpl) GetByAltText(text interface{}, options ...LocatorGetByAltTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn l.Locator(getByAltTextSelector(text, exact))\n}\n\nfunc (l *locatorImpl) GetByLabel(text interface{}, options ...LocatorGetByLabelOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn l.Locator(getByLabelSelector(text, exact))\n}\n\nfunc (l *locatorImpl) GetByPlaceholder(text interface{}, options ...LocatorGetByPlaceholderOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn l.Locator(getByPlaceholderSelector(text, exact))\n}\n\nfunc (l *locatorImpl) GetByRole(role AriaRole, options ...LocatorGetByRoleOptions) Locator {\n\treturn l.Locator(getByRoleSelector(role, options...))\n}\n\nfunc (l *locatorImpl) GetByTestId(testId interface{}) Locator {\n\treturn l.Locator(getByTestIdSelector(getTestIdAttributeName(), testId))\n}\n\nfunc (l *locatorImpl) GetByText(text interface{}, options ...LocatorGetByTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn l.Locator(getByTextSelector(text, exact))\n}\n\nfunc (l *locatorImpl) GetByTitle(text interface{}, options ...LocatorGetByTitleOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn l.Locator(getByTitleSelector(text, exact))\n}\n\nfunc (l *locatorImpl) Highlight() error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\treturn l.frame.highlight(l.selector)\n}\n\nfunc (l *locatorImpl) Hover(options ...LocatorHoverOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameHoverOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Hover(l.selector, opt)\n}\n\nfunc (l *locatorImpl) InnerHTML(options ...LocatorInnerHTMLOptions) (string, error) {\n\tif l.err != nil {\n\t\treturn \"\", l.err\n\t}\n\topt := FrameInnerHTMLOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn l.frame.InnerHTML(l.selector, opt)\n}\n\nfunc (l *locatorImpl) InnerText(options ...LocatorInnerTextOptions) (string, error) {\n\tif l.err != nil {\n\t\treturn \"\", l.err\n\t}\n\topt := FrameInnerTextOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn l.frame.InnerText(l.selector, opt)\n}\n\nfunc (l *locatorImpl) InputValue(options ...LocatorInputValueOptions) (string, error) {\n\tif l.err != nil {\n\t\treturn \"\", l.err\n\t}\n\topt := FrameInputValueOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn l.frame.InputValue(l.selector, opt)\n}\n\nfunc (l *locatorImpl) IsChecked(options ...LocatorIsCheckedOptions) (bool, error) {\n\tif l.err != nil {\n\t\treturn false, l.err\n\t}\n\topt := FrameIsCheckedOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn l.frame.IsChecked(l.selector, opt)\n}\n\nfunc (l *locatorImpl) IsDisabled(options ...LocatorIsDisabledOptions) (bool, error) {\n\tif l.err != nil {\n\t\treturn false, l.err\n\t}\n\topt := FrameIsDisabledOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn l.frame.IsDisabled(l.selector, opt)\n}\n\nfunc (l *locatorImpl) IsEditable(options ...LocatorIsEditableOptions) (bool, error) {\n\tif l.err != nil {\n\t\treturn false, l.err\n\t}\n\topt := FrameIsEditableOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn l.frame.IsEditable(l.selector, opt)\n}\n\nfunc (l *locatorImpl) IsEnabled(options ...LocatorIsEnabledOptions) (bool, error) {\n\tif l.err != nil {\n\t\treturn false, l.err\n\t}\n\topt := FrameIsEnabledOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn l.frame.IsEnabled(l.selector, opt)\n}\n\nfunc (l *locatorImpl) IsHidden(options ...LocatorIsHiddenOptions) (bool, error) {\n\tif l.err != nil {\n\t\treturn false, l.err\n\t}\n\topt := FrameIsHiddenOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn l.frame.IsHidden(l.selector, opt)\n}\n\nfunc (l *locatorImpl) IsVisible(options ...LocatorIsVisibleOptions) (bool, error) {\n\tif l.err != nil {\n\t\treturn false, l.err\n\t}\n\topt := FrameIsVisibleOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn l.frame.IsVisible(l.selector, opt)\n}\n\nfunc (l *locatorImpl) Last() Locator {\n\treturn newLocator(l.frame, l.selector+\" >> nth=-1\")\n}\n\nfunc (l *locatorImpl) Locator(selectorOrLocator interface{}, options ...LocatorLocatorOptions) Locator {\n\tselector, ok := selectorOrLocator.(string)\n\tif ok {\n\t\treturn newLocator(l.frame, l.selector+\" >> \"+selector, options...)\n\t}\n\tlocator, ok := selectorOrLocator.(*locatorImpl)\n\tif ok {\n\t\tif l.frame != locator.frame {\n\t\t\tl.err = errors.Join(l.err, ErrLocatorNotSameFrame)\n\t\t\treturn l\n\t\t}\n\t\treturn newLocator(l.frame,\n\t\t\tl.selector+\" >> internal:chain=\"+escapeText(locator.selector),\n\t\t\toptions...,\n\t\t)\n\t}\n\tl.err = errors.Join(l.err, fmt.Errorf(\"invalid locator parameter: %v\", selectorOrLocator))\n\treturn l\n}\n\nfunc (l *locatorImpl) Nth(index int) Locator {\n\treturn newLocator(l.frame, l.selector+\" >> nth=\"+strconv.Itoa(index))\n}\n\nfunc (l *locatorImpl) Page() (Page, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\treturn l.frame.Page(), nil\n}\n\nfunc (l *locatorImpl) Press(key string, options ...LocatorPressOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FramePressOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Press(l.selector, key, opt)\n}\n\nfunc (l *locatorImpl) PressSequentially(text string, options ...LocatorPressSequentiallyOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\tvar option LocatorTypeOptions\n\tif len(options) == 1 {\n\t\toption = LocatorTypeOptions(options[0])\n\t}\n\treturn l.Type(text, option)\n}\n\nfunc (l *locatorImpl) Screenshot(options ...LocatorScreenshotOptions) ([]byte, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\tvar option FrameWaitForSelectorOptions\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t}\n\n\tresult, err := l.withElement(func(handle ElementHandle) (interface{}, error) {\n\t\tvar screenshotOption ElementHandleScreenshotOptions\n\t\tif len(options) == 1 {\n\t\t\tscreenshotOption = ElementHandleScreenshotOptions(options[0])\n\t\t}\n\t\treturn handle.Screenshot(screenshotOption)\n\t}, option)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn result.([]byte), nil\n}\n\nfunc (l *locatorImpl) ScrollIntoViewIfNeeded(options ...LocatorScrollIntoViewIfNeededOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\tvar option FrameWaitForSelectorOptions\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t}\n\n\t_, err := l.withElement(func(handle ElementHandle) (interface{}, error) {\n\t\tvar opt ElementHandleScrollIntoViewIfNeededOptions\n\t\tif len(options) == 1 {\n\t\t\topt.Timeout = options[0].Timeout\n\t\t}\n\t\treturn nil, handle.ScrollIntoViewIfNeeded(opt)\n\t}, option)\n\n\treturn err\n}\n\nfunc (l *locatorImpl) SelectOption(values SelectOptionValues, options ...LocatorSelectOptionOptions) ([]string, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\topt := FrameSelectOptionOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn l.frame.SelectOption(l.selector, values, opt)\n}\n\nfunc (l *locatorImpl) SelectText(options ...LocatorSelectTextOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\tvar option FrameWaitForSelectorOptions\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t}\n\n\t_, err := l.withElement(func(handle ElementHandle) (interface{}, error) {\n\t\tvar opt ElementHandleSelectTextOptions\n\t\tif len(options) == 1 {\n\t\t\topt = ElementHandleSelectTextOptions(options[0])\n\t\t}\n\t\treturn nil, handle.SelectText(opt)\n\t}, option)\n\n\treturn err\n}\n\nfunc (l *locatorImpl) SetChecked(checked bool, options ...LocatorSetCheckedOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameSetCheckedOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.SetChecked(l.selector, checked, opt)\n}\n\nfunc (l *locatorImpl) SetInputFiles(files interface{}, options ...LocatorSetInputFilesOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameSetInputFilesOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.SetInputFiles(l.selector, files, opt)\n}\n\nfunc (l *locatorImpl) Tap(options ...LocatorTapOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameTapOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Tap(l.selector, opt)\n}\n\nfunc (l *locatorImpl) TextContent(options ...LocatorTextContentOptions) (string, error) {\n\tif l.err != nil {\n\t\treturn \"\", l.err\n\t}\n\topt := FrameTextContentOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn l.frame.TextContent(l.selector, opt)\n}\n\nfunc (l *locatorImpl) Type(text string, options ...LocatorTypeOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameTypeOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Type(l.selector, text, opt)\n}\n\nfunc (l *locatorImpl) Uncheck(options ...LocatorUncheckOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameUncheckOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn l.frame.Uncheck(l.selector, opt)\n}\n\nfunc (l *locatorImpl) WaitFor(options ...LocatorWaitForOptions) error {\n\tif l.err != nil {\n\t\treturn l.err\n\t}\n\topt := FrameWaitForSelectorOptions{\n\t\tStrict: Bool(true),\n\t}\n\tif len(options) == 1 {\n\t\tif err := assignStructFields(&opt, options[0], false); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err := l.frame.WaitForSelector(l.selector, opt)\n\treturn err\n}\n\nfunc (l *locatorImpl) withElement(\n\tcallback func(handle ElementHandle) (interface{}, error),\n\toptions ...FrameWaitForSelectorOptions,\n) (interface{}, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\thandle, err := l.frame.WaitForSelector(l.selector, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresult, err := callback(handle)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\nfunc (l *locatorImpl) expect(expression string, options frameExpectOptions) (*frameExpectResult, error) {\n\tif l.err != nil {\n\t\treturn nil, l.err\n\t}\n\toverrides := map[string]interface{}{\n\t\t\"selector\":   l.selector,\n\t\t\"expression\": expression,\n\t}\n\tif options.ExpectedValue != nil {\n\t\toverrides[\"expectedValue\"] = serializeArgument(options.ExpectedValue)\n\t\toptions.ExpectedValue = nil\n\t}\n\tresult, err := l.frame.channel.SendReturnAsDict(\"expect\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar (\n\t\treceived interface{}\n\t\tmatches  bool\n\t\tlog      []string\n\t)\n\n\tif v, ok := result[\"received\"]; ok {\n\t\treceived = parseResult(v)\n\t}\n\tif v, ok := result[\"matches\"]; ok {\n\t\tmatches = v.(bool)\n\t}\n\tif v, ok := result[\"log\"]; ok {\n\t\tfor _, l := range v.([]interface{}) {\n\t\t\tlog = append(log, l.(string))\n\t\t}\n\t}\n\treturn &frameExpectResult{Received: received, Matches: matches, Log: log}, nil\n}\n"
        },
        {
          "name": "locator_assertions.go",
          "type": "blob",
          "size": 12.16015625,
          "content": "package playwright\n\nimport (\n\t\"regexp\"\n)\n\ntype locatorAssertionsImpl struct {\n\tassertionsBase\n}\n\nfunc newLocatorAssertions(locator Locator, isNot bool, defaultTimeout *float64) *locatorAssertionsImpl {\n\treturn &locatorAssertionsImpl{\n\t\tassertionsBase: assertionsBase{\n\t\t\tactualLocator:  locator,\n\t\t\tisNot:          isNot,\n\t\t\tdefaultTimeout: defaultTimeout,\n\t\t},\n\t}\n}\n\nfunc (la *locatorAssertionsImpl) ToBeAttached(options ...LocatorAssertionsToBeAttachedOptions) error {\n\texpression := \"to.be.attached\"\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\tif options[0].Attached != nil && !*options[0].Attached {\n\t\t\texpression = \"to.be.detached\"\n\t\t}\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\texpression,\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be attached\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeChecked(options ...LocatorAssertionsToBeCheckedOptions) error {\n\texpression := \"to.be.checked\"\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\tif options[0].Checked != nil && !*options[0].Checked {\n\t\t\texpression = \"to.be.unchecked\"\n\t\t}\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\texpression,\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be checked\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeDisabled(options ...LocatorAssertionsToBeDisabledOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.disabled\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be disabled\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeEditable(options ...LocatorAssertionsToBeEditableOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.editable\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be editable\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeEmpty(options ...LocatorAssertionsToBeEmptyOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.empty\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be empty\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeEnabled(options ...LocatorAssertionsToBeEnabledOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.enabled\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be enabled\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeFocused(options ...LocatorAssertionsToBeFocusedOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.focused\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be focused\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeHidden(options ...LocatorAssertionsToBeHiddenOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.hidden\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be hidden\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeInViewport(options ...LocatorAssertionsToBeInViewportOptions) error {\n\tvar (\n\t\tratio   *float64\n\t\ttimeout *float64\n\t)\n\tif len(options) == 1 {\n\t\tratio = options[0].Ratio\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.in.viewport\",\n\t\tframeExpectOptions{\n\t\t\tExpectedNumber: ratio,\n\t\t\tTimeout:        timeout,\n\t\t},\n\t\tnil,\n\t\t\"Locator expected to be in viewport\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToBeVisible(options ...LocatorAssertionsToBeVisibleOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.be.visible\",\n\t\tframeExpectOptions{Timeout: timeout},\n\t\tnil,\n\t\t\"Locator expected to be visible\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToContainText(expected interface{}, options ...LocatorAssertionsToContainTextOptions) error {\n\tvar (\n\t\ttimeout      *float64\n\t\tuseInnerText *bool\n\t\tignoreCase   *bool\n\t)\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t\tuseInnerText = options[0].UseInnerText\n\t\tignoreCase = options[0].IgnoreCase\n\t}\n\n\tswitch expected.(type) {\n\tcase []string, []*regexp.Regexp:\n\t\texpectedText, err := toExpectedTextValues(convertToInterfaceList(expected), true, true, ignoreCase)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn la.expect(\n\t\t\t\"to.contain.text.array\",\n\t\t\tframeExpectOptions{\n\t\t\t\tExpectedText: expectedText,\n\t\t\t\tUseInnerText: useInnerText,\n\t\t\t\tTimeout:      timeout,\n\t\t\t},\n\t\t\texpected,\n\t\t\t\"Locator expected to contain text\",\n\t\t)\n\tdefault:\n\t\texpectedText, err := toExpectedTextValues([]interface{}{expected}, true, true, ignoreCase)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn la.expect(\n\t\t\t\"to.have.text\",\n\t\t\tframeExpectOptions{\n\t\t\t\tExpectedText: expectedText,\n\t\t\t\tUseInnerText: useInnerText,\n\t\t\t\tTimeout:      timeout,\n\t\t\t},\n\t\t\texpected,\n\t\t\t\"Locator expected to contain text\",\n\t\t)\n\t}\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveAccessibleDescription(description interface{}, options ...LocatorAssertionsToHaveAccessibleDescriptionOptions) error {\n\tvar timeout *float64\n\tvar ignoreCase *bool\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t\tignoreCase = options[0].IgnoreCase\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{description}, false, false, ignoreCase)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.accessible.description\",\n\t\tframeExpectOptions{ExpectedText: expectedText, Timeout: timeout},\n\t\tdescription,\n\t\t\"Locator expected to have AccessibleDescription\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveAccessibleName(name interface{}, options ...LocatorAssertionsToHaveAccessibleNameOptions) error {\n\tvar timeout *float64\n\tvar ignoreCase *bool\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t\tignoreCase = options[0].IgnoreCase\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{name}, false, false, ignoreCase)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.accessible.name\",\n\t\tframeExpectOptions{ExpectedText: expectedText, Timeout: timeout},\n\t\tname,\n\t\t\"Locator expected to have AccessibleName\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveAttribute(name string, value interface{}, options ...LocatorAssertionsToHaveAttributeOptions) error {\n\tvar timeout *float64\n\tvar ignoreCase *bool\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t\tignoreCase = options[0].IgnoreCase\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{value}, false, false, ignoreCase)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.attribute.value\",\n\t\tframeExpectOptions{\n\t\t\tExpressionArg: name,\n\t\t\tExpectedText:  expectedText,\n\t\t\tTimeout:       timeout,\n\t\t},\n\t\tvalue,\n\t\t\"Locator expected to have attribute\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveClass(expected interface{}, options ...LocatorAssertionsToHaveClassOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\tswitch expected.(type) {\n\tcase []string, []*regexp.Regexp:\n\t\texpectedText, err := toExpectedTextValues(convertToInterfaceList(expected), false, false, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn la.expect(\n\t\t\t\"to.have.class.array\",\n\t\t\tframeExpectOptions{\n\t\t\t\tExpectedText: expectedText,\n\t\t\t\tTimeout:      timeout,\n\t\t\t},\n\t\t\texpected,\n\t\t\t\"Locator expected to have class\",\n\t\t)\n\tdefault:\n\t\texpectedText, err := toExpectedTextValues([]interface{}{expected}, false, false, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn la.expect(\n\t\t\t\"to.have.class\",\n\t\t\tframeExpectOptions{\n\t\t\t\tExpectedText: expectedText,\n\t\t\t\tTimeout:      timeout,\n\t\t\t},\n\t\t\texpected,\n\t\t\t\"Locator expected to have class\",\n\t\t)\n\t}\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveCount(count int, options ...LocatorAssertionsToHaveCountOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.have.count\",\n\t\tframeExpectOptions{ExpectedNumber: Float(float64(count)), Timeout: timeout},\n\t\tcount,\n\t\t\"Locator expected to have count\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveCSS(name string, value interface{}, options ...LocatorAssertionsToHaveCSSOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{value}, false, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.css\",\n\t\tframeExpectOptions{\n\t\t\tExpressionArg: name,\n\t\t\tExpectedText:  expectedText,\n\t\t\tTimeout:       timeout,\n\t\t},\n\t\tvalue,\n\t\t\"Locator expected to have CSS\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveId(id interface{}, options ...LocatorAssertionsToHaveIdOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{id}, false, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.id\",\n\t\tframeExpectOptions{ExpectedText: expectedText, Timeout: timeout},\n\t\tid,\n\t\t\"Locator expected to have ID\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveJSProperty(name string, value interface{}, options ...LocatorAssertionsToHaveJSPropertyOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.have.property\",\n\t\tframeExpectOptions{\n\t\t\tExpressionArg: name,\n\t\t\tExpectedValue: value,\n\t\t\tTimeout:       timeout,\n\t\t},\n\t\tvalue,\n\t\t\"Locator expected to have JS Property\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveRole(role AriaRole, options ...LocatorAssertionsToHaveRoleOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{string(role)}, false, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.role\",\n\t\tframeExpectOptions{ExpectedText: expectedText, Timeout: timeout},\n\t\trole,\n\t\t\"Locator expected to have Role\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveText(expected interface{}, options ...LocatorAssertionsToHaveTextOptions) error {\n\tvar (\n\t\ttimeout      *float64\n\t\tuseInnerText *bool\n\t\tignoreCase   *bool\n\t)\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t\tuseInnerText = options[0].UseInnerText\n\t\tignoreCase = options[0].IgnoreCase\n\t}\n\n\tswitch expected.(type) {\n\tcase []string, []*regexp.Regexp:\n\t\texpectedText, err := toExpectedTextValues(convertToInterfaceList(expected), false, true, ignoreCase)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn la.expect(\n\t\t\t\"to.have.text.array\",\n\t\t\tframeExpectOptions{\n\t\t\t\tExpectedText: expectedText,\n\t\t\t\tUseInnerText: useInnerText,\n\t\t\t\tTimeout:      timeout,\n\t\t\t},\n\t\t\texpected,\n\t\t\t\"Locator expected to have text\",\n\t\t)\n\tdefault:\n\t\texpectedText, err := toExpectedTextValues([]interface{}{expected}, false, true, ignoreCase)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn la.expect(\n\t\t\t\"to.have.text\",\n\t\t\tframeExpectOptions{\n\t\t\t\tExpectedText: expectedText,\n\t\t\t\tUseInnerText: useInnerText,\n\t\t\t\tTimeout:      timeout,\n\t\t\t},\n\t\t\texpected,\n\t\t\t\"Locator expected to have text\",\n\t\t)\n\t}\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveValue(value interface{}, options ...LocatorAssertionsToHaveValueOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\texpectedText, err := toExpectedTextValues([]interface{}{value}, false, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.value\",\n\t\tframeExpectOptions{ExpectedText: expectedText, Timeout: timeout},\n\t\tvalue,\n\t\t\"Locator expected to have Value\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToHaveValues(values []interface{}, options ...LocatorAssertionsToHaveValuesOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\texpectedText, err := toExpectedTextValues(values, false, false, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn la.expect(\n\t\t\"to.have.values\",\n\t\tframeExpectOptions{ExpectedText: expectedText, Timeout: timeout},\n\t\tvalues,\n\t\t\"Locator expected to have Values\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) ToMatchAriaSnapshot(expected string, options ...LocatorAssertionsToMatchAriaSnapshotOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\treturn la.expect(\n\t\t\"to.match.aria\",\n\t\tframeExpectOptions{\n\t\t\tExpectedValue: expected,\n\t\t\tTimeout:       timeout,\n\t\t},\n\t\texpected,\n\t\t\"Locator expected to match Aria snapshot\",\n\t)\n}\n\nfunc (la *locatorAssertionsImpl) Not() LocatorAssertions {\n\treturn newLocatorAssertions(la.actualLocator, true, la.defaultTimeout)\n}\n"
        },
        {
          "name": "locator_helpers.go",
          "type": "blob",
          "size": 3.65625,
          "content": "package playwright\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nfunc convertRegexp(reg *regexp.Regexp) (pattern, flags string) {\n\tmatches := regexp.MustCompile(`\\(\\?([imsU]+)\\)(.+)`).FindStringSubmatch(reg.String())\n\n\tif len(matches) == 3 {\n\t\tpattern = matches[2]\n\t\tflags = matches[1]\n\t} else {\n\t\tpattern = reg.String()\n\t}\n\treturn\n}\n\nfunc escapeForAttributeSelector(text interface{}, exact bool) string {\n\tswitch text := text.(type) {\n\tcase *regexp.Regexp:\n\t\treturn escapeRegexForSelector(text)\n\tdefault:\n\t\tsuffix := \"i\"\n\t\tif exact {\n\t\t\tsuffix = \"s\"\n\t\t}\n\t\treturn fmt.Sprintf(`\"%s\"%s`, strings.Replace(strings.Replace(text.(string), `\\`, `\\\\`, -1), `\"`, `\\\"`, -1), suffix)\n\t}\n}\n\nfunc escapeForTextSelector(text interface{}, exact bool) string {\n\tswitch text := text.(type) {\n\tcase *regexp.Regexp:\n\t\treturn escapeRegexForSelector(text)\n\tdefault:\n\t\tif exact {\n\t\t\treturn fmt.Sprintf(`%ss`, escapeText(text.(string)))\n\t\t}\n\t\treturn fmt.Sprintf(`%si`, escapeText(text.(string)))\n\t}\n}\n\nfunc escapeRegexForSelector(re *regexp.Regexp) string {\n\tpattern, flag := convertRegexp(re)\n\treturn fmt.Sprintf(`/%s/%s`, strings.ReplaceAll(pattern, `>>`, `\\>\\>`), flag)\n}\n\nfunc escapeText(s string) string {\n\tbuilder := &strings.Builder{}\n\tencoder := json.NewEncoder(builder)\n\tencoder.SetEscapeHTML(false)\n\t_ = encoder.Encode(s)\n\treturn strings.TrimSpace(builder.String())\n}\n\nfunc getByAltTextSelector(text interface{}, exact bool) string {\n\treturn getByAttributeTextSelector(\"alt\", text, exact)\n}\n\nfunc getByAttributeTextSelector(attrName string, text interface{}, exact bool) string {\n\treturn fmt.Sprintf(`internal:attr=[%s=%s]`, attrName, escapeForAttributeSelector(text, exact))\n}\n\nfunc getByLabelSelector(text interface{}, exact bool) string {\n\treturn fmt.Sprintf(`internal:label=%s`, escapeForTextSelector(text, exact))\n}\n\nfunc getByPlaceholderSelector(text interface{}, exact bool) string {\n\treturn getByAttributeTextSelector(\"placeholder\", text, exact)\n}\n\nfunc getByRoleSelector(role AriaRole, options ...LocatorGetByRoleOptions) string {\n\tprops := make(map[string]string)\n\tif len(options) == 1 {\n\t\tif options[0].Checked != nil {\n\t\t\tprops[\"checked\"] = fmt.Sprintf(\"%t\", *options[0].Checked)\n\t\t}\n\t\tif options[0].Disabled != nil {\n\t\t\tprops[\"disabled\"] = fmt.Sprintf(\"%t\", *options[0].Disabled)\n\t\t}\n\t\tif options[0].Selected != nil {\n\t\t\tprops[\"selected\"] = fmt.Sprintf(\"%t\", *options[0].Selected)\n\t\t}\n\t\tif options[0].Expanded != nil {\n\t\t\tprops[\"expanded\"] = fmt.Sprintf(\"%t\", *options[0].Expanded)\n\t\t}\n\t\tif options[0].IncludeHidden != nil {\n\t\t\tprops[\"include-hidden\"] = fmt.Sprintf(\"%t\", *options[0].IncludeHidden)\n\t\t}\n\t\tif options[0].Level != nil {\n\t\t\tprops[\"level\"] = fmt.Sprintf(\"%d\", *options[0].Level)\n\t\t}\n\t\tif options[0].Name != nil {\n\t\t\texact := false\n\t\t\tif options[0].Exact != nil {\n\t\t\t\texact = *options[0].Exact\n\t\t\t}\n\t\t\tprops[\"name\"] = escapeForAttributeSelector(options[0].Name, exact)\n\t\t}\n\t\tif options[0].Pressed != nil {\n\t\t\tprops[\"pressed\"] = fmt.Sprintf(\"%t\", *options[0].Pressed)\n\t\t}\n\t}\n\tpropsStr := \"\"\n\tfor k, v := range props {\n\t\tpropsStr += \"[\" + k + \"=\" + v + \"]\"\n\t}\n\treturn fmt.Sprintf(\"internal:role=%s%s\", role, propsStr)\n}\n\nfunc getByTextSelector(text interface{}, exact bool) string {\n\treturn fmt.Sprintf(`internal:text=%s`, escapeForTextSelector(text, exact))\n}\n\nfunc getByTestIdSelector(testIdAttributeName string, testId interface{}) string {\n\treturn fmt.Sprintf(`internal:testid=[%s=%s]`, testIdAttributeName, escapeForAttributeSelector(testId, true))\n}\n\nfunc getByTitleSelector(text interface{}, exact bool) string {\n\treturn getByAttributeTextSelector(\"title\", text, exact)\n}\n\nfunc getTestIdAttributeName() string {\n\treturn testIdAttributeName\n}\n\nfunc setTestIdAttributeName(name string) {\n\ttestIdAttributeName = name\n}\n"
        },
        {
          "name": "network.go",
          "type": "blob",
          "size": 1.3603515625,
          "content": "package playwright\n\nimport (\n\t\"strings\"\n)\n\ntype rawHeaders struct {\n\theadersArray []NameValue\n\theadersMap   map[string][]string\n}\n\nfunc (r *rawHeaders) Get(name string) string {\n\tvalues := r.GetAll(name)\n\tif len(values) == 0 {\n\t\treturn \"\"\n\t}\n\tsep := \", \"\n\tif strings.ToLower(name) == \"set-cookie\" {\n\t\tsep = \"\\n\"\n\t}\n\treturn strings.Join(values, sep)\n}\n\nfunc (r *rawHeaders) GetAll(name string) []string {\n\tname = strings.ToLower(name)\n\tif _, ok := r.headersMap[name]; !ok {\n\t\treturn []string{}\n\t}\n\treturn r.headersMap[name]\n}\n\nfunc (r *rawHeaders) Headers() map[string]string {\n\tout := make(map[string]string)\n\tfor key := range r.headersMap {\n\t\tout[key] = r.Get(key)\n\t}\n\treturn out\n}\n\nfunc (r *rawHeaders) HeadersArray() []NameValue {\n\treturn r.headersArray\n}\n\nfunc newRawHeaders(headers interface{}) *rawHeaders {\n\tr := &rawHeaders{}\n\tr.headersArray = make([]NameValue, 0)\n\tr.headersMap = make(map[string][]string)\n\tfor _, header := range headers.([]interface{}) {\n\t\tentry := header.(map[string]interface{})\n\t\tname := entry[\"name\"].(string)\n\t\tvalue := entry[\"value\"].(string)\n\t\tr.headersArray = append(r.headersArray, NameValue{\n\t\t\tName:  name,\n\t\t\tValue: value,\n\t\t})\n\t\tif _, ok := r.headersMap[strings.ToLower(name)]; !ok {\n\t\t\tr.headersMap[strings.ToLower(name)] = make([]string, 0)\n\t\t}\n\t\tr.headersMap[strings.ToLower(name)] = append(r.headersMap[strings.ToLower(name)], value)\n\t}\n\treturn r\n}\n"
        },
        {
          "name": "objectFactory.go",
          "type": "blob",
          "size": 2.4912109375,
          "content": "package playwright\n\nfunc createObjectFactory(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) interface{} {\n\tswitch objectType {\n\tcase \"Android\":\n\t\treturn nil\n\tcase \"AndroidSocket\":\n\t\treturn nil\n\tcase \"AndroidDevice\":\n\t\treturn nil\n\tcase \"APIRequestContext\":\n\t\treturn newAPIRequestContext(parent, objectType, guid, initializer)\n\tcase \"Artifact\":\n\t\treturn newArtifact(parent, objectType, guid, initializer)\n\tcase \"BindingCall\":\n\t\treturn newBindingCall(parent, objectType, guid, initializer)\n\tcase \"Browser\":\n\t\treturn newBrowser(parent, objectType, guid, initializer)\n\tcase \"BrowserType\":\n\t\treturn newBrowserType(parent, objectType, guid, initializer)\n\tcase \"BrowserContext\":\n\t\treturn newBrowserContext(parent, objectType, guid, initializer)\n\tcase \"CDPSession\":\n\t\treturn newCDPSession(parent, objectType, guid, initializer)\n\tcase \"Dialog\":\n\t\treturn newDialog(parent, objectType, guid, initializer)\n\tcase \"Electron\":\n\t\treturn nil\n\tcase \"ElectronApplication\":\n\t\treturn nil\n\tcase \"ElementHandle\":\n\t\treturn newElementHandle(parent, objectType, guid, initializer)\n\tcase \"Frame\":\n\t\treturn newFrame(parent, objectType, guid, initializer)\n\tcase \"JSHandle\":\n\t\treturn newJSHandle(parent, objectType, guid, initializer)\n\tcase \"JsonPipe\":\n\t\treturn newJsonPipe(parent, objectType, guid, initializer)\n\tcase \"LocalUtils\":\n\t\tlocalUtils := newLocalUtils(parent, objectType, guid, initializer)\n\t\tif localUtils.connection.localUtils == nil {\n\t\t\tlocalUtils.connection.localUtils = localUtils\n\t\t}\n\t\treturn localUtils\n\tcase \"Page\":\n\t\treturn newPage(parent, objectType, guid, initializer)\n\tcase \"Playwright\":\n\t\treturn newPlaywright(parent, objectType, guid, initializer)\n\tcase \"Request\":\n\t\treturn newRequest(parent, objectType, guid, initializer)\n\tcase \"Response\":\n\t\treturn newResponse(parent, objectType, guid, initializer)\n\tcase \"Route\":\n\t\treturn newRoute(parent, objectType, guid, initializer)\n\tcase \"Selectors\":\n\t\treturn newSelectorsOwner(parent, objectType, guid, initializer)\n\tcase \"SocksSupport\":\n\t\treturn nil\n\tcase \"Stream\":\n\t\treturn newStream(parent, objectType, guid, initializer)\n\tcase \"Tracing\":\n\t\treturn newTracing(parent, objectType, guid, initializer)\n\tcase \"WebSocket\":\n\t\treturn newWebsocket(parent, objectType, guid, initializer)\n\tcase \"WebSocketRoute\":\n\t\treturn newWebSocketRoute(parent, objectType, guid, initializer)\n\tcase \"Worker\":\n\t\treturn newWorker(parent, objectType, guid, initializer)\n\tcase \"WritableStream\":\n\t\treturn newWritableStream(parent, objectType, guid, initializer)\n\tdefault:\n\t\tpanic(objectType)\n\t}\n}\n"
        },
        {
          "name": "page.go",
          "type": "blob",
          "size": 38.1826171875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"slices\"\n\t\"sync\"\n\n\t\"github.com/playwright-community/playwright-go/internal/safe\"\n)\n\ntype pageImpl struct {\n\tchannelOwner\n\tisClosed        bool\n\tclosedOrCrashed chan error\n\tvideo           *videoImpl\n\tmouse           *mouseImpl\n\tkeyboard        *keyboardImpl\n\ttouchscreen     *touchscreenImpl\n\ttimeoutSettings *timeoutSettings\n\tbrowserContext  *browserContextImpl\n\tframes          []Frame\n\tworkers         []Worker\n\tmainFrame       Frame\n\troutes          []*routeHandlerEntry\n\twebSocketRoutes []*webSocketRouteHandler\n\tviewportSize    *Size\n\townedContext    BrowserContext\n\tbindings        *safe.SyncMap[string, BindingCallFunction]\n\tcloseReason     *string\n\tcloseWasCalled  bool\n\tharRouters      []*harRouter\n\tlocatorHandlers map[float64]*locatorHandlerEntry\n}\n\ntype locatorHandlerEntry struct {\n\tlocator *locatorImpl\n\thandler func(Locator)\n\ttimes   *int\n}\n\nfunc (p *pageImpl) AddLocatorHandler(locator Locator, handler func(Locator), options ...PageAddLocatorHandlerOptions) error {\n\tif locator == nil || handler == nil {\n\t\treturn errors.New(\"locator or handler must not be nil\")\n\t}\n\tif locator.Err() != nil {\n\t\treturn locator.Err()\n\t}\n\n\tvar option PageAddLocatorHandlerOptions\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t\tif option.Times != nil && *option.Times == 0 {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tloc := locator.(*locatorImpl)\n\tif loc.frame != p.mainFrame {\n\t\treturn errors.New(\"locator must belong to the main frame of this page\")\n\t}\n\tuid, err := p.channel.Send(\"registerLocatorHandler\", map[string]any{\n\t\t\"selector\":    loc.selector,\n\t\t\"noWaitAfter\": option.NoWaitAfter,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.locatorHandlers[uid.(float64)] = &locatorHandlerEntry{locator: loc, handler: handler, times: option.Times}\n\treturn nil\n}\n\nfunc (p *pageImpl) onLocatorHandlerTriggered(uid float64) {\n\tvar remove *bool\n\thandler, ok := p.locatorHandlers[uid]\n\tif !ok {\n\t\treturn\n\t}\n\tif handler.times != nil {\n\t\t*handler.times--\n\t\tif *handler.times == 0 {\n\t\t\tremove = Bool(true)\n\t\t}\n\t}\n\tdefer func() {\n\t\tif remove != nil && *remove {\n\t\t\tdelete(p.locatorHandlers, uid)\n\t\t}\n\t\t_, _ = p.connection.WrapAPICall(func() (interface{}, error) {\n\t\t\t_, err := p.channel.Send(\"resolveLocatorHandlerNoReply\", map[string]any{\n\t\t\t\t\"uid\":    uid,\n\t\t\t\t\"remove\": remove,\n\t\t\t})\n\t\t\treturn nil, err\n\t\t}, true)\n\t}()\n\n\thandler.handler(handler.locator)\n}\n\nfunc (p *pageImpl) RemoveLocatorHandler(locator Locator) error {\n\tfor uid := range p.locatorHandlers {\n\t\tif p.locatorHandlers[uid].locator.equals(locator) {\n\t\t\tdelete(p.locatorHandlers, uid)\n\t\t\tp.channel.SendNoReply(\"unregisterLocatorHandler\", map[string]any{\n\t\t\t\t\"uid\": uid,\n\t\t\t})\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *pageImpl) Context() BrowserContext {\n\treturn p.browserContext\n}\n\nfunc (b *pageImpl) Clock() Clock {\n\treturn b.browserContext.clock\n}\n\nfunc (p *pageImpl) Close(options ...PageCloseOptions) error {\n\tif len(options) == 1 {\n\t\tp.closeReason = options[0].Reason\n\t}\n\tp.closeWasCalled = true\n\t_, err := p.channel.Send(\"close\", options)\n\tif err == nil && p.ownedContext != nil {\n\t\terr = p.ownedContext.Close()\n\t}\n\tif errors.Is(err, ErrTargetClosed) || (len(options) == 1 && options[0].RunBeforeUnload != nil && *(options[0].RunBeforeUnload)) {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc (p *pageImpl) InnerText(selector string, options ...PageInnerTextOptions) (string, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.InnerText(selector, FrameInnerTextOptions(options[0]))\n\t}\n\treturn p.mainFrame.InnerText(selector)\n}\n\nfunc (p *pageImpl) InnerHTML(selector string, options ...PageInnerHTMLOptions) (string, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.InnerHTML(selector, FrameInnerHTMLOptions(options[0]))\n\t}\n\treturn p.mainFrame.InnerHTML(selector)\n}\n\nfunc (p *pageImpl) Opener() (Page, error) {\n\tchannel := p.initializer[\"opener\"]\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\t// not popup page or opener has been closed\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*pageImpl), nil\n}\n\nfunc (p *pageImpl) MainFrame() Frame {\n\treturn p.mainFrame\n}\n\nfunc (p *pageImpl) Frame(options ...PageFrameOptions) Frame {\n\toption := PageFrameOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tvar matcher *urlMatcher\n\tif option.URL != nil {\n\t\tmatcher = newURLMatcher(option.URL, p.browserContext.options.BaseURL)\n\t}\n\n\tfor _, f := range p.frames {\n\t\tif option.Name != nil && f.Name() == *option.Name {\n\t\t\treturn f\n\t\t}\n\n\t\tif option.URL != nil && matcher != nil && matcher.Matches(f.URL()) {\n\t\t\treturn f\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *pageImpl) Frames() []Frame {\n\treturn p.frames\n}\n\nfunc (p *pageImpl) SetDefaultNavigationTimeout(timeout float64) {\n\tp.timeoutSettings.SetDefaultNavigationTimeout(&timeout)\n\tp.channel.SendNoReplyInternal(\"setDefaultNavigationTimeoutNoReply\", map[string]interface{}{\n\t\t\"timeout\": timeout,\n\t})\n}\n\nfunc (p *pageImpl) SetDefaultTimeout(timeout float64) {\n\tp.timeoutSettings.SetDefaultTimeout(&timeout)\n\tp.channel.SendNoReplyInternal(\"setDefaultTimeoutNoReply\", map[string]interface{}{\n\t\t\"timeout\": timeout,\n\t})\n}\n\nfunc (p *pageImpl) QuerySelector(selector string, options ...PageQuerySelectorOptions) (ElementHandle, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.QuerySelector(selector, FrameQuerySelectorOptions(options[0]))\n\t}\n\treturn p.mainFrame.QuerySelector(selector)\n}\n\nfunc (p *pageImpl) QuerySelectorAll(selector string) ([]ElementHandle, error) {\n\treturn p.mainFrame.QuerySelectorAll(selector)\n}\n\nfunc (p *pageImpl) WaitForSelector(selector string, options ...PageWaitForSelectorOptions) (ElementHandle, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.WaitForSelector(selector, FrameWaitForSelectorOptions(options[0]))\n\t}\n\treturn p.mainFrame.WaitForSelector(selector)\n}\n\nfunc (p *pageImpl) DispatchEvent(selector string, typ string, eventInit interface{}, options ...PageDispatchEventOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.DispatchEvent(selector, typ, eventInit, FrameDispatchEventOptions(options[0]))\n\t}\n\treturn p.mainFrame.DispatchEvent(selector, typ, eventInit)\n}\n\nfunc (p *pageImpl) Evaluate(expression string, arg ...interface{}) (interface{}, error) {\n\treturn p.mainFrame.Evaluate(expression, arg...)\n}\n\nfunc (p *pageImpl) EvaluateHandle(expression string, arg ...interface{}) (JSHandle, error) {\n\treturn p.mainFrame.EvaluateHandle(expression, arg...)\n}\n\nfunc (p *pageImpl) EvalOnSelector(selector string, expression string, arg interface{}, options ...PageEvalOnSelectorOptions) (interface{}, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.EvalOnSelector(selector, expression, arg, FrameEvalOnSelectorOptions(options[0]))\n\t}\n\treturn p.mainFrame.EvalOnSelector(selector, expression, arg)\n}\n\nfunc (p *pageImpl) EvalOnSelectorAll(selector string, expression string, arg ...interface{}) (interface{}, error) {\n\treturn p.mainFrame.EvalOnSelectorAll(selector, expression, arg...)\n}\n\nfunc (p *pageImpl) AddScriptTag(options PageAddScriptTagOptions) (ElementHandle, error) {\n\treturn p.mainFrame.AddScriptTag(FrameAddScriptTagOptions(options))\n}\n\nfunc (p *pageImpl) AddStyleTag(options PageAddStyleTagOptions) (ElementHandle, error) {\n\treturn p.mainFrame.AddStyleTag(FrameAddStyleTagOptions(options))\n}\n\nfunc (p *pageImpl) SetExtraHTTPHeaders(headers map[string]string) error {\n\t_, err := p.channel.Send(\"setExtraHTTPHeaders\", map[string]interface{}{\n\t\t\"headers\": serializeMapToNameAndValue(headers),\n\t})\n\treturn err\n}\n\nfunc (p *pageImpl) URL() string {\n\treturn p.mainFrame.URL()\n}\n\nfunc (p *pageImpl) Unroute(url interface{}, handlers ...routeHandler) error {\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tremoved, remaining, err := unroute(p.routes, url, handlers...)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn p.unrouteInternal(removed, remaining, UnrouteBehaviorDefault)\n}\n\nfunc (p *pageImpl) unrouteInternal(removed []*routeHandlerEntry, remaining []*routeHandlerEntry, behavior *UnrouteBehavior) error {\n\tp.routes = remaining\n\terr := p.updateInterceptionPatterns()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif behavior == nil || behavior == UnrouteBehaviorDefault {\n\t\treturn nil\n\t}\n\twg := &sync.WaitGroup{}\n\tfor _, entry := range removed {\n\t\twg.Add(1)\n\t\tgo func(entry *routeHandlerEntry) {\n\t\t\tdefer wg.Done()\n\t\t\tentry.Stop(string(*behavior))\n\t\t}(entry)\n\t}\n\twg.Wait()\n\treturn nil\n}\n\nfunc (p *pageImpl) disposeHarRouters() {\n\tfor _, router := range p.harRouters {\n\t\trouter.dispose()\n\t}\n\tp.harRouters = make([]*harRouter, 0)\n}\n\nfunc (p *pageImpl) UnrouteAll(options ...PageUnrouteAllOptions) error {\n\tvar behavior *UnrouteBehavior\n\tif len(options) == 1 {\n\t\tbehavior = options[0].Behavior\n\t}\n\tp.Lock()\n\tdefer p.Unlock()\n\tdefer p.disposeHarRouters()\n\treturn p.unrouteInternal(p.routes, []*routeHandlerEntry{}, behavior)\n}\n\nfunc (p *pageImpl) Content() (string, error) {\n\treturn p.mainFrame.Content()\n}\n\nfunc (p *pageImpl) SetContent(html string, options ...PageSetContentOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.SetContent(html, FrameSetContentOptions(options[0]))\n\t}\n\treturn p.mainFrame.SetContent(html)\n}\n\nfunc (p *pageImpl) Goto(url string, options ...PageGotoOptions) (Response, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Goto(url, FrameGotoOptions(options[0]))\n\t}\n\treturn p.mainFrame.Goto(url)\n}\n\nfunc (p *pageImpl) Reload(options ...PageReloadOptions) (Response, error) {\n\tchannel, err := p.channel.Send(\"reload\", options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*responseImpl), nil\n}\n\nfunc (p *pageImpl) WaitForLoadState(options ...PageWaitForLoadStateOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.WaitForLoadState(FrameWaitForLoadStateOptions(options[0]))\n\t}\n\treturn p.mainFrame.WaitForLoadState()\n}\n\nfunc (p *pageImpl) GoBack(options ...PageGoBackOptions) (Response, error) {\n\tchannel, err := p.channel.Send(\"goBack\", options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\t// can not go back\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*responseImpl), nil\n}\n\nfunc (p *pageImpl) GoForward(options ...PageGoForwardOptions) (Response, error) {\n\tchannel, err := p.channel.Send(\"goForward\", options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\t// can not go forward\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*responseImpl), nil\n}\n\nfunc (p *pageImpl) EmulateMedia(options ...PageEmulateMediaOptions) error {\n\t_, err := p.channel.Send(\"emulateMedia\", options)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn err\n}\n\nfunc (p *pageImpl) SetViewportSize(width, height int) error {\n\t_, err := p.channel.Send(\"setViewportSize\", map[string]interface{}{\n\t\t\"viewportSize\": map[string]interface{}{\n\t\t\t\"width\":  width,\n\t\t\t\"height\": height,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.viewportSize.Width = width\n\tp.viewportSize.Height = height\n\treturn nil\n}\n\nfunc (p *pageImpl) ViewportSize() *Size {\n\treturn p.viewportSize\n}\n\nfunc (p *pageImpl) BringToFront() error {\n\t_, err := p.channel.Send(\"bringToFront\")\n\treturn err\n}\n\nfunc (p *pageImpl) Type(selector, text string, options ...PageTypeOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Type(selector, text, FrameTypeOptions(options[0]))\n\t}\n\treturn p.mainFrame.Type(selector, text)\n}\n\nfunc (p *pageImpl) Fill(selector, text string, options ...PageFillOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Fill(selector, text, FrameFillOptions(options[0]))\n\t}\n\treturn p.mainFrame.Fill(selector, text)\n}\n\nfunc (p *pageImpl) Press(selector, key string, options ...PagePressOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Press(selector, key, FramePressOptions(options[0]))\n\t}\n\treturn p.mainFrame.Press(selector, key)\n}\n\nfunc (p *pageImpl) Title() (string, error) {\n\treturn p.mainFrame.Title()\n}\n\nfunc (p *pageImpl) Workers() []Worker {\n\treturn p.workers\n}\n\nfunc (p *pageImpl) Request() APIRequestContext {\n\treturn p.Context().Request()\n}\n\nfunc (p *pageImpl) Screenshot(options ...PageScreenshotOptions) ([]byte, error) {\n\tvar path *string\n\toverrides := map[string]interface{}{}\n\tif len(options) == 1 {\n\t\tpath = options[0].Path\n\t\toptions[0].Path = nil\n\t\tif options[0].Mask != nil {\n\t\t\tmasks := make([]map[string]interface{}, 0)\n\t\t\tfor _, m := range options[0].Mask {\n\t\t\t\tif m.Err() != nil { // ErrLocatorNotSameFrame\n\t\t\t\t\treturn nil, m.Err()\n\t\t\t\t}\n\t\t\t\tl, ok := m.(*locatorImpl)\n\t\t\t\tif ok {\n\t\t\t\t\tmasks = append(masks, map[string]interface{}{\n\t\t\t\t\t\t\"selector\": l.selector,\n\t\t\t\t\t\t\"frame\":    l.frame.channel,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\toverrides[\"mask\"] = masks\n\t\t}\n\t}\n\tdata, err := p.channel.Send(\"screenshot\", options, overrides)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\timage, err := base64.StdEncoding.DecodeString(data.(string))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not decode base64 :%w\", err)\n\t}\n\tif path != nil {\n\t\tif err := os.WriteFile(*path, image, 0o644); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn image, nil\n}\n\nfunc (p *pageImpl) PDF(options ...PagePdfOptions) ([]byte, error) {\n\tvar path *string\n\tif len(options) == 1 {\n\t\tpath = options[0].Path\n\t}\n\tdata, err := p.channel.Send(\"pdf\", options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpdf, err := base64.StdEncoding.DecodeString(data.(string))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not decode base64 :%w\", err)\n\t}\n\tif path != nil {\n\t\tif err := os.WriteFile(*path, pdf, 0o644); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn pdf, nil\n}\n\nfunc (p *pageImpl) Click(selector string, options ...PageClickOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Click(selector, FrameClickOptions(options[0]))\n\t}\n\treturn p.mainFrame.Click(selector)\n}\n\nfunc (p *pageImpl) WaitForEvent(event string, options ...PageWaitForEventOptions) (interface{}, error) {\n\treturn p.waiterForEvent(event, options...).Wait()\n}\n\nfunc (p *pageImpl) waiterForEvent(event string, options ...PageWaitForEventOptions) *waiter {\n\ttimeout := p.timeoutSettings.Timeout()\n\tvar predicate interface{} = nil\n\tif len(options) == 1 {\n\t\tif options[0].Timeout != nil {\n\t\t\ttimeout = *options[0].Timeout\n\t\t}\n\t\tpredicate = options[0].Predicate\n\t}\n\twaiter := newWaiter().WithTimeout(timeout)\n\twaiter.RejectOnEvent(p, \"close\", p.closeErrorWithReason())\n\twaiter.RejectOnEvent(p, \"crash\", errors.New(\"page crashed\"))\n\treturn waiter.WaitForEvent(p, event, predicate)\n}\n\nfunc (p *pageImpl) waiterForRequest(url interface{}, options ...PageExpectRequestOptions) *waiter {\n\toption := PageExpectRequestOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.Timeout == nil {\n\t\toption.Timeout = Float(p.timeoutSettings.Timeout())\n\t}\n\tvar matcher *urlMatcher\n\tif url != nil {\n\t\tmatcher = newURLMatcher(url, p.browserContext.options.BaseURL)\n\t}\n\tpredicate := func(req *requestImpl) bool {\n\t\tif matcher != nil {\n\t\t\treturn matcher.Matches(req.URL())\n\t\t}\n\t\treturn true\n\t}\n\n\twaiter := newWaiter().WithTimeout(*option.Timeout)\n\treturn waiter.WaitForEvent(p, \"request\", predicate)\n}\n\nfunc (p *pageImpl) waiterForResponse(url interface{}, options ...PageExpectResponseOptions) *waiter {\n\toption := PageExpectResponseOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.Timeout == nil {\n\t\toption.Timeout = Float(p.timeoutSettings.Timeout())\n\t}\n\tvar matcher *urlMatcher\n\tif url != nil {\n\t\tmatcher = newURLMatcher(url, p.browserContext.options.BaseURL)\n\t}\n\tpredicate := func(req *responseImpl) bool {\n\t\tif matcher != nil {\n\t\t\treturn matcher.Matches(req.URL())\n\t\t}\n\t\treturn true\n\t}\n\n\twaiter := newWaiter().WithTimeout(*option.Timeout)\n\treturn waiter.WaitForEvent(p, \"response\", predicate)\n}\n\nfunc (p *pageImpl) ExpectEvent(event string, cb func() error, options ...PageExpectEventOptions) (interface{}, error) {\n\tif len(options) == 1 {\n\t\treturn p.waiterForEvent(event, PageWaitForEventOptions(options[0])).RunAndWait(cb)\n\t}\n\treturn p.waiterForEvent(event).RunAndWait(cb)\n}\n\nfunc (p *pageImpl) ExpectNavigation(cb func() error, options ...PageExpectNavigationOptions) (Response, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.ExpectNavigation(cb, FrameExpectNavigationOptions(options[0]))\n\t}\n\treturn p.mainFrame.ExpectNavigation(cb)\n}\n\nfunc (p *pageImpl) ExpectConsoleMessage(cb func() error, options ...PageExpectConsoleMessageOptions) (ConsoleMessage, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"console\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*consoleMessageImpl), err\n}\n\nfunc (p *pageImpl) ExpectDownload(cb func() error, options ...PageExpectDownloadOptions) (Download, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"download\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*downloadImpl), err\n}\n\nfunc (p *pageImpl) ExpectFileChooser(cb func() error, options ...PageExpectFileChooserOptions) (FileChooser, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"filechooser\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*fileChooserImpl), err\n}\n\nfunc (p *pageImpl) ExpectPopup(cb func() error, options ...PageExpectPopupOptions) (Page, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"popup\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*pageImpl), err\n}\n\nfunc (p *pageImpl) ExpectResponse(url interface{}, cb func() error, options ...PageExpectResponseOptions) (Response, error) {\n\tret, err := p.waiterForResponse(url, options...).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*responseImpl), err\n}\n\nfunc (p *pageImpl) ExpectRequest(url interface{}, cb func() error, options ...PageExpectRequestOptions) (Request, error) {\n\tret, err := p.waiterForRequest(url, options...).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*requestImpl), err\n}\n\nfunc (p *pageImpl) ExpectRequestFinished(cb func() error, options ...PageExpectRequestFinishedOptions) (Request, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"requestfinished\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*requestImpl), err\n}\n\nfunc (p *pageImpl) ExpectWebSocket(cb func() error, options ...PageExpectWebSocketOptions) (WebSocket, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"websocket\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*webSocketImpl), err\n}\n\nfunc (p *pageImpl) ExpectWorker(cb func() error, options ...PageExpectWorkerOptions) (Worker, error) {\n\toption := PageWaitForEventOptions{}\n\tif len(options) == 1 {\n\t\toption.Timeout = options[0].Timeout\n\t\toption.Predicate = options[0].Predicate\n\t}\n\tret, err := p.waiterForEvent(\"worker\", option).RunAndWait(cb)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(*workerImpl), err\n}\n\nfunc (p *pageImpl) Route(url interface{}, handler routeHandler, times ...int) error {\n\tp.Lock()\n\tdefer p.Unlock()\n\tp.routes = slices.Insert(p.routes, 0, newRouteHandlerEntry(newURLMatcher(url, p.browserContext.options.BaseURL), handler, times...))\n\treturn p.updateInterceptionPatterns()\n}\n\nfunc (p *pageImpl) GetAttribute(selector string, name string, options ...PageGetAttributeOptions) (string, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.GetAttribute(selector, name, FrameGetAttributeOptions(options[0]))\n\t}\n\treturn p.mainFrame.GetAttribute(selector, name)\n}\n\nfunc (p *pageImpl) Hover(selector string, options ...PageHoverOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Hover(selector, FrameHoverOptions(options[0]))\n\t}\n\treturn p.mainFrame.Hover(selector)\n}\n\nfunc (p *pageImpl) IsClosed() bool {\n\treturn p.isClosed\n}\n\nfunc (p *pageImpl) AddInitScript(script Script) error {\n\tvar source string\n\tif script.Content != nil {\n\t\tsource = *script.Content\n\t}\n\tif script.Path != nil {\n\t\tcontent, err := os.ReadFile(*script.Path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsource = string(content)\n\t}\n\t_, err := p.channel.Send(\"addInitScript\", map[string]interface{}{\n\t\t\"source\": source,\n\t})\n\treturn err\n}\n\nfunc (p *pageImpl) Keyboard() Keyboard {\n\treturn p.keyboard\n}\n\nfunc (p *pageImpl) Mouse() Mouse {\n\treturn p.mouse\n}\n\nfunc (p *pageImpl) RouteFromHAR(har string, options ...PageRouteFromHAROptions) error {\n\topt := PageRouteFromHAROptions{}\n\tif len(options) == 1 {\n\t\topt = options[0]\n\t}\n\tif opt.Update != nil && *opt.Update {\n\t\treturn p.browserContext.recordIntoHar(har, browserContextRecordIntoHarOptions{\n\t\t\tPage: p,\n\t\t\tURL:  opt.URL,\n\t\t})\n\t}\n\tnotFound := opt.NotFound\n\tif notFound == nil {\n\t\tnotFound = HarNotFoundAbort\n\t}\n\trouter := newHarRouter(p.connection.localUtils, har, *notFound, opt.URL)\n\tp.harRouters = append(p.harRouters, router)\n\treturn router.addPageRoute(p)\n}\n\nfunc (p *pageImpl) Touchscreen() Touchscreen {\n\treturn p.touchscreen\n}\n\nfunc newPage(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *pageImpl {\n\tviewportSize := &Size{}\n\tif _, ok := initializer[\"viewportSize\"].(map[string]interface{}); ok {\n\t\tviewportSize.Height = int(initializer[\"viewportSize\"].(map[string]interface{})[\"height\"].(float64))\n\t\tviewportSize.Width = int(initializer[\"viewportSize\"].(map[string]interface{})[\"width\"].(float64))\n\t}\n\tbt := &pageImpl{\n\t\tworkers:         make([]Worker, 0),\n\t\troutes:          make([]*routeHandlerEntry, 0),\n\t\tbindings:        safe.NewSyncMap[string, BindingCallFunction](),\n\t\tviewportSize:    viewportSize,\n\t\tharRouters:      make([]*harRouter, 0),\n\t\tlocatorHandlers: make(map[float64]*locatorHandlerEntry, 0),\n\t}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tbt.browserContext = fromChannel(parent.channel).(*browserContextImpl)\n\tbt.timeoutSettings = newTimeoutSettings(bt.browserContext.timeoutSettings)\n\tmainframe := fromChannel(initializer[\"mainFrame\"]).(*frameImpl)\n\tmainframe.page = bt\n\tbt.mainFrame = mainframe\n\tbt.frames = []Frame{mainframe}\n\tbt.mouse = newMouse(bt.channel)\n\tbt.keyboard = newKeyboard(bt.channel)\n\tbt.touchscreen = newTouchscreen(bt.channel)\n\tbt.channel.On(\"bindingCall\", func(params map[string]interface{}) {\n\t\tbt.onBinding(fromChannel(params[\"binding\"]).(*bindingCallImpl))\n\t})\n\tbt.channel.On(\"close\", bt.onClose)\n\tbt.channel.On(\"crash\", func() {\n\t\tbt.Emit(\"crash\", bt)\n\t})\n\tbt.channel.On(\"domcontentloaded\", func() {\n\t\tbt.Emit(\"domcontentloaded\", bt)\n\t})\n\tbt.channel.On(\"fileChooser\", func(ev map[string]interface{}) {\n\t\tbt.Emit(\"filechooser\", newFileChooser(bt, fromChannel(ev[\"element\"]).(*elementHandleImpl), ev[\"isMultiple\"].(bool)))\n\t})\n\tbt.channel.On(\"frameAttached\", func(ev map[string]interface{}) {\n\t\tbt.onFrameAttached(fromChannel(ev[\"frame\"]).(*frameImpl))\n\t})\n\tbt.channel.On(\"frameDetached\", func(ev map[string]interface{}) {\n\t\tbt.onFrameDetached(fromChannel(ev[\"frame\"]).(*frameImpl))\n\t})\n\tbt.channel.On(\"locatorHandlerTriggered\", func(ev map[string]interface{}) {\n\t\tbt.channel.CreateTask(func() {\n\t\t\tbt.onLocatorHandlerTriggered(ev[\"uid\"].(float64))\n\t\t})\n\t})\n\tbt.channel.On(\n\t\t\"load\", func(ev map[string]interface{}) {\n\t\t\tbt.Emit(\"load\", bt)\n\t\t},\n\t)\n\tbt.channel.On(\"popup\", func(ev map[string]interface{}) {\n\t\tbt.Emit(\"popup\", fromChannel(ev[\"page\"]).(*pageImpl))\n\t})\n\tbt.channel.On(\"route\", func(ev map[string]interface{}) {\n\t\tbt.channel.CreateTask(func() {\n\t\t\tbt.onRoute(fromChannel(ev[\"route\"]).(*routeImpl))\n\t\t})\n\t})\n\tbt.channel.On(\"download\", func(ev map[string]interface{}) {\n\t\turl := ev[\"url\"].(string)\n\t\tsuggestedFilename := ev[\"suggestedFilename\"].(string)\n\t\tartifact := fromChannel(ev[\"artifact\"]).(*artifactImpl)\n\t\tbt.Emit(\"download\", newDownload(bt, url, suggestedFilename, artifact))\n\t})\n\tbt.channel.On(\"video\", func(params map[string]interface{}) {\n\t\tartifact := fromChannel(params[\"artifact\"]).(*artifactImpl)\n\t\tbt.Video().(*videoImpl).artifactReady(artifact)\n\t})\n\tbt.channel.On(\"webSocket\", func(ev map[string]interface{}) {\n\t\tbt.Emit(\"websocket\", fromChannel(ev[\"webSocket\"]).(*webSocketImpl))\n\t})\n\tbt.channel.On(\"webSocketRoute\", func(ev map[string]interface{}) {\n\t\tbt.channel.CreateTask(func() {\n\t\t\tbt.onWebSocketRoute(fromChannel(ev[\"webSocketRoute\"]).(*webSocketRouteImpl))\n\t\t})\n\t})\n\n\tbt.channel.On(\"worker\", func(ev map[string]interface{}) {\n\t\tbt.onWorker(fromChannel(ev[\"worker\"]).(*workerImpl))\n\t})\n\tbt.closedOrCrashed = make(chan error, 1)\n\tbt.OnClose(func(Page) {\n\t\tselect {\n\t\tcase bt.closedOrCrashed <- bt.closeErrorWithReason():\n\t\tdefault:\n\t\t}\n\t})\n\tbt.OnCrash(func(Page) {\n\t\tselect {\n\t\tcase bt.closedOrCrashed <- ErrTargetClosed:\n\t\tdefault:\n\t\t}\n\t})\n\tbt.setEventSubscriptionMapping(map[string]string{\n\t\t\"console\":         \"console\",\n\t\t\"dialog\":          \"dialog\",\n\t\t\"request\":         \"request\",\n\t\t\"response\":        \"response\",\n\t\t\"requestfinished\": \"requestFinished\",\n\t\t\"responsefailed\":  \"responseFailed\",\n\t\t\"filechooser\":     \"fileChooser\",\n\t})\n\n\treturn bt\n}\n\nfunc (p *pageImpl) closeErrorWithReason() error {\n\tif p.closeReason != nil {\n\t\treturn targetClosedError(p.closeReason)\n\t}\n\treturn targetClosedError(p.browserContext.effectiveCloseReason())\n}\n\nfunc (p *pageImpl) onBinding(binding *bindingCallImpl) {\n\tfunction, ok := p.bindings.Load(binding.initializer[\"name\"].(string))\n\tif !ok || function == nil {\n\t\treturn\n\t}\n\tgo binding.Call(function)\n}\n\nfunc (p *pageImpl) onFrameAttached(frame *frameImpl) {\n\tframe.page = p\n\tp.frames = append(p.frames, frame)\n\tp.Emit(\"frameattached\", frame)\n}\n\nfunc (p *pageImpl) onFrameDetached(frame *frameImpl) {\n\tframe.detached = true\n\tframes := make([]Frame, 0)\n\tfor i := 0; i < len(p.frames); i++ {\n\t\tif p.frames[i] != frame {\n\t\t\tframes = append(frames, frame)\n\t\t}\n\t}\n\tif len(frames) != len(p.frames) {\n\t\tp.frames = frames\n\t}\n\tp.Emit(\"framedetached\", frame)\n}\n\nfunc (p *pageImpl) onRoute(route *routeImpl) {\n\tp.Lock()\n\troute.context = p.browserContext\n\troutes := make([]*routeHandlerEntry, len(p.routes))\n\tcopy(routes, p.routes)\n\tp.Unlock()\n\n\tcheckInterceptionIfNeeded := func() {\n\t\tp.Lock()\n\t\tdefer p.Unlock()\n\t\tif len(p.routes) == 0 {\n\t\t\t_, err := p.connection.WrapAPICall(func() (interface{}, error) {\n\t\t\t\terr := p.updateInterceptionPatterns()\n\t\t\t\treturn nil, err\n\t\t\t}, true)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"could not update interception patterns\", \"error\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\turl := route.Request().URL()\n\tfor _, handlerEntry := range routes {\n\t\t// If the page was closed we stall all requests right away.\n\t\tif p.closeWasCalled || p.browserContext.closeWasCalled {\n\t\t\treturn\n\t\t}\n\t\tif !handlerEntry.Matches(url) {\n\t\t\tcontinue\n\t\t}\n\t\tif !slices.ContainsFunc(p.routes, func(entry *routeHandlerEntry) bool {\n\t\t\treturn entry == handlerEntry\n\t\t}) {\n\t\t\tcontinue\n\t\t}\n\t\tif handlerEntry.WillExceed() {\n\t\t\tp.routes = slices.DeleteFunc(p.routes, func(rhe *routeHandlerEntry) bool {\n\t\t\t\treturn rhe == handlerEntry\n\t\t\t})\n\t\t}\n\t\thandled := handlerEntry.Handle(route)\n\t\tcheckInterceptionIfNeeded()\n\n\t\tif <-handled {\n\t\t\treturn\n\t\t}\n\t}\n\tp.browserContext.onRoute(route)\n}\n\nfunc (p *pageImpl) updateInterceptionPatterns() error {\n\tpatterns := prepareInterceptionPatterns(p.routes)\n\t_, err := p.channel.Send(\"setNetworkInterceptionPatterns\", map[string]interface{}{\n\t\t\"patterns\": patterns,\n\t})\n\treturn err\n}\n\nfunc (p *pageImpl) onWorker(worker *workerImpl) {\n\tp.workers = append(p.workers, worker)\n\tworker.page = p\n\tp.Emit(\"worker\", worker)\n}\n\nfunc (p *pageImpl) onClose() {\n\tp.isClosed = true\n\tnewPages := []Page{}\n\tnewBackgoundPages := []Page{}\n\tif p.browserContext != nil {\n\t\tp.browserContext.Lock()\n\t\tfor _, page := range p.browserContext.pages {\n\t\t\tif page != p {\n\t\t\t\tnewPages = append(newPages, page)\n\t\t\t}\n\t\t}\n\t\tfor _, page := range p.browserContext.backgroundPages {\n\t\t\tif page != p {\n\t\t\t\tnewBackgoundPages = append(newBackgoundPages, page)\n\t\t\t}\n\t\t}\n\t\tp.browserContext.pages = newPages\n\t\tp.browserContext.backgroundPages = newBackgoundPages\n\t\tp.browserContext.Unlock()\n\t}\n\tp.disposeHarRouters()\n\tp.Emit(\"close\", p)\n}\n\nfunc (p *pageImpl) SetInputFiles(selector string, files interface{}, options ...PageSetInputFilesOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.SetInputFiles(selector, files, FrameSetInputFilesOptions(options[0]))\n\t}\n\treturn p.mainFrame.SetInputFiles(selector, files)\n}\n\nfunc (p *pageImpl) Check(selector string, options ...PageCheckOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Check(selector, FrameCheckOptions(options[0]))\n\t}\n\treturn p.mainFrame.Check(selector)\n}\n\nfunc (p *pageImpl) Uncheck(selector string, options ...PageUncheckOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Uncheck(selector, FrameUncheckOptions(options[0]))\n\t}\n\treturn p.mainFrame.Uncheck(selector)\n}\n\nfunc (p *pageImpl) WaitForTimeout(timeout float64) {\n\tp.mainFrame.WaitForTimeout(timeout)\n}\n\nfunc (p *pageImpl) WaitForFunction(expression string, arg interface{}, options ...PageWaitForFunctionOptions) (JSHandle, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.WaitForFunction(expression, arg, FrameWaitForFunctionOptions(options[0]))\n\t}\n\treturn p.mainFrame.WaitForFunction(expression, arg)\n}\n\nfunc (p *pageImpl) Dblclick(expression string, options ...PageDblclickOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Dblclick(expression, FrameDblclickOptions(options[0]))\n\t}\n\treturn p.mainFrame.Dblclick(expression)\n}\n\nfunc (p *pageImpl) Focus(expression string, options ...PageFocusOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Focus(expression, FrameFocusOptions(options[0]))\n\t}\n\treturn p.mainFrame.Focus(expression)\n}\n\nfunc (p *pageImpl) TextContent(selector string, options ...PageTextContentOptions) (string, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.TextContent(selector, FrameTextContentOptions(options[0]))\n\t}\n\treturn p.mainFrame.TextContent(selector)\n}\n\nfunc (p *pageImpl) Video() Video {\n\tp.Lock()\n\tdefer p.Unlock()\n\n\tif p.video == nil {\n\t\tp.video = newVideo(p)\n\t}\n\treturn p.video\n}\n\nfunc (p *pageImpl) Tap(selector string, options ...PageTapOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.Tap(selector, FrameTapOptions(options[0]))\n\t}\n\treturn p.mainFrame.Tap(selector)\n}\n\nfunc (p *pageImpl) ExposeFunction(name string, binding ExposedFunction) error {\n\treturn p.ExposeBinding(name, func(source *BindingSource, args ...interface{}) interface{} {\n\t\treturn binding(args...)\n\t})\n}\n\nfunc (p *pageImpl) ExposeBinding(name string, binding BindingCallFunction, handle ...bool) error {\n\tneedsHandle := false\n\tif len(handle) == 1 {\n\t\tneedsHandle = handle[0]\n\t}\n\tif _, ok := p.bindings.Load(name); ok {\n\t\treturn fmt.Errorf(\"Function '%s' has been already registered\", name)\n\t}\n\tif _, ok := p.browserContext.bindings.Load(name); ok {\n\t\treturn fmt.Errorf(\"Function '%s' has been already registered in the browser context\", name)\n\t}\n\t_, err := p.channel.Send(\"exposeBinding\", map[string]interface{}{\n\t\t\"name\":        name,\n\t\t\"needsHandle\": needsHandle,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.bindings.Store(name, binding)\n\treturn nil\n}\n\nfunc (p *pageImpl) SelectOption(selector string, values SelectOptionValues, options ...PageSelectOptionOptions) ([]string, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.SelectOption(selector, values, FrameSelectOptionOptions(options[0]))\n\t}\n\treturn p.mainFrame.SelectOption(selector, values)\n}\n\nfunc (p *pageImpl) IsChecked(selector string, options ...PageIsCheckedOptions) (bool, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.IsChecked(selector, FrameIsCheckedOptions(options[0]))\n\t}\n\treturn p.mainFrame.IsChecked(selector)\n}\n\nfunc (p *pageImpl) IsDisabled(selector string, options ...PageIsDisabledOptions) (bool, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.IsDisabled(selector, FrameIsDisabledOptions(options[0]))\n\t}\n\treturn p.mainFrame.IsDisabled(selector)\n}\n\nfunc (p *pageImpl) IsEditable(selector string, options ...PageIsEditableOptions) (bool, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.IsEditable(selector, FrameIsEditableOptions(options[0]))\n\t}\n\treturn p.mainFrame.IsEditable(selector)\n}\n\nfunc (p *pageImpl) IsEnabled(selector string, options ...PageIsEnabledOptions) (bool, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.IsEnabled(selector, FrameIsEnabledOptions(options[0]))\n\t}\n\treturn p.mainFrame.IsEnabled(selector)\n}\n\nfunc (p *pageImpl) IsHidden(selector string, options ...PageIsHiddenOptions) (bool, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.IsHidden(selector, FrameIsHiddenOptions(options[0]))\n\t}\n\treturn p.mainFrame.IsHidden(selector)\n}\n\nfunc (p *pageImpl) IsVisible(selector string, options ...PageIsVisibleOptions) (bool, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.IsVisible(selector, FrameIsVisibleOptions(options[0]))\n\t}\n\treturn p.mainFrame.IsVisible(selector)\n}\n\nfunc (p *pageImpl) DragAndDrop(source, target string, options ...PageDragAndDropOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.DragAndDrop(source, target, FrameDragAndDropOptions(options[0]))\n\t}\n\treturn p.mainFrame.DragAndDrop(source, target)\n}\n\nfunc (p *pageImpl) Pause() (err error) {\n\tdefaultNavigationTimout := p.browserContext.timeoutSettings.DefaultNavigationTimeout()\n\tdefaultTimeout := p.browserContext.timeoutSettings.DefaultTimeout()\n\tp.browserContext.SetDefaultNavigationTimeout(0)\n\tp.browserContext.SetDefaultTimeout(0)\n\tselect {\n\tcase err = <-p.closedOrCrashed:\n\tcase err = <-p.browserContext.pause():\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.browserContext.setDefaultNavigationTimeoutImpl(defaultNavigationTimout)\n\tp.browserContext.setDefaultTimeoutImpl(defaultTimeout)\n\treturn\n}\n\nfunc (p *pageImpl) InputValue(selector string, options ...PageInputValueOptions) (string, error) {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.InputValue(selector, FrameInputValueOptions(options[0]))\n\t}\n\treturn p.mainFrame.InputValue(selector)\n}\n\nfunc (p *pageImpl) WaitForURL(url interface{}, options ...PageWaitForURLOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.WaitForURL(url, FrameWaitForURLOptions(options[0]))\n\t}\n\treturn p.mainFrame.WaitForURL(url)\n}\n\nfunc (p *pageImpl) SetChecked(selector string, checked bool, options ...PageSetCheckedOptions) error {\n\tif len(options) == 1 {\n\t\treturn p.mainFrame.SetChecked(selector, checked, FrameSetCheckedOptions(options[0]))\n\t}\n\treturn p.mainFrame.SetChecked(selector, checked)\n}\n\nfunc (p *pageImpl) Locator(selector string, options ...PageLocatorOptions) Locator {\n\tvar option FrameLocatorOptions\n\tif len(options) == 1 {\n\t\toption = FrameLocatorOptions(options[0])\n\t}\n\treturn p.mainFrame.Locator(selector, option)\n}\n\nfunc (p *pageImpl) GetByAltText(text interface{}, options ...PageGetByAltTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn p.Locator(getByAltTextSelector(text, exact))\n}\n\nfunc (p *pageImpl) GetByLabel(text interface{}, options ...PageGetByLabelOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn p.Locator(getByLabelSelector(text, exact))\n}\n\nfunc (p *pageImpl) GetByPlaceholder(text interface{}, options ...PageGetByPlaceholderOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn p.Locator(getByPlaceholderSelector(text, exact))\n}\n\nfunc (p *pageImpl) GetByRole(role AriaRole, options ...PageGetByRoleOptions) Locator {\n\tif len(options) == 1 {\n\t\treturn p.Locator(getByRoleSelector(role, LocatorGetByRoleOptions(options[0])))\n\t}\n\treturn p.Locator(getByRoleSelector(role))\n}\n\nfunc (p *pageImpl) GetByTestId(testId interface{}) Locator {\n\treturn p.Locator(getByTestIdSelector(getTestIdAttributeName(), testId))\n}\n\nfunc (p *pageImpl) GetByText(text interface{}, options ...PageGetByTextOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn p.Locator(getByTextSelector(text, exact))\n}\n\nfunc (p *pageImpl) GetByTitle(text interface{}, options ...PageGetByTitleOptions) Locator {\n\texact := false\n\tif len(options) == 1 {\n\t\tif *options[0].Exact {\n\t\t\texact = true\n\t\t}\n\t}\n\treturn p.Locator(getByTitleSelector(text, exact))\n}\n\nfunc (p *pageImpl) FrameLocator(selector string) FrameLocator {\n\treturn p.mainFrame.FrameLocator(selector)\n}\n\nfunc (p *pageImpl) OnClose(fn func(Page)) {\n\tp.On(\"close\", fn)\n}\n\nfunc (p *pageImpl) OnConsole(fn func(ConsoleMessage)) {\n\tp.On(\"console\", fn)\n}\n\nfunc (p *pageImpl) OnCrash(fn func(Page)) {\n\tp.On(\"crash\", fn)\n}\n\nfunc (p *pageImpl) OnDialog(fn func(Dialog)) {\n\tp.On(\"dialog\", fn)\n}\n\nfunc (p *pageImpl) OnDOMContentLoaded(fn func(Page)) {\n\tp.On(\"domcontentloaded\", fn)\n}\n\nfunc (p *pageImpl) OnDownload(fn func(Download)) {\n\tp.On(\"download\", fn)\n}\n\nfunc (p *pageImpl) OnFileChooser(fn func(FileChooser)) {\n\tp.On(\"filechooser\", fn)\n}\n\nfunc (p *pageImpl) OnFrameAttached(fn func(Frame)) {\n\tp.On(\"frameattached\", fn)\n}\n\nfunc (p *pageImpl) OnFrameDetached(fn func(Frame)) {\n\tp.On(\"framedetached\", fn)\n}\n\nfunc (p *pageImpl) OnFrameNavigated(fn func(Frame)) {\n\tp.On(\"framenavigated\", fn)\n}\n\nfunc (p *pageImpl) OnLoad(fn func(Page)) {\n\tp.On(\"load\", fn)\n}\n\nfunc (p *pageImpl) OnPageError(fn func(error)) {\n\tp.On(\"pageerror\", fn)\n}\n\nfunc (p *pageImpl) OnPopup(fn func(Page)) {\n\tp.On(\"popup\", fn)\n}\n\nfunc (p *pageImpl) OnRequest(fn func(Request)) {\n\tp.On(\"request\", fn)\n}\n\nfunc (p *pageImpl) OnRequestFailed(fn func(Request)) {\n\tp.On(\"requestfailed\", fn)\n}\n\nfunc (p *pageImpl) OnRequestFinished(fn func(Request)) {\n\tp.On(\"requestfinished\", fn)\n}\n\nfunc (p *pageImpl) OnResponse(fn func(Response)) {\n\tp.On(\"response\", fn)\n}\n\nfunc (p *pageImpl) OnWebSocket(fn func(WebSocket)) {\n\tp.On(\"websocket\", fn)\n}\n\nfunc (p *pageImpl) OnWorker(fn func(Worker)) {\n\tp.On(\"worker\", fn)\n}\n\nfunc (p *pageImpl) RequestGC() error {\n\t_, err := p.channel.Send(\"requestGC\")\n\treturn err\n}\n\nfunc (p *pageImpl) RouteWebSocket(url interface{}, handler func(WebSocketRoute)) error {\n\tp.Lock()\n\tdefer p.Unlock()\n\tp.webSocketRoutes = slices.Insert(p.webSocketRoutes, 0, newWebSocketRouteHandler(newURLMatcher(url, p.browserContext.options.BaseURL), handler))\n\n\treturn p.updateWebSocketInterceptionPatterns()\n}\n\nfunc (p *pageImpl) onWebSocketRoute(wr WebSocketRoute) {\n\tp.Lock()\n\tindex := slices.IndexFunc(p.webSocketRoutes, func(r *webSocketRouteHandler) bool {\n\t\treturn r.Matches(wr.URL())\n\t})\n\tif index == -1 {\n\t\tp.Unlock()\n\t\tp.browserContext.onWebSocketRoute(wr)\n\t\treturn\n\t}\n\thandler := p.webSocketRoutes[index]\n\tp.Unlock()\n\thandler.Handle(wr)\n}\n\nfunc (p *pageImpl) updateWebSocketInterceptionPatterns() error {\n\tpatterns := prepareWebSocketRouteHandlerInterceptionPatterns(p.webSocketRoutes)\n\t_, err := p.channel.Send(\"setWebSocketInterceptionPatterns\", map[string]interface{}{\n\t\t\"patterns\": patterns,\n\t})\n\treturn err\n}\n"
        },
        {
          "name": "page_assertions.go",
          "type": "blob",
          "size": 1.759765625,
          "content": "package playwright\n\nimport (\n\t\"net/url\"\n\t\"path\"\n)\n\ntype pageAssertionsImpl struct {\n\tassertionsBase\n\tactualPage Page\n}\n\nfunc newPageAssertions(page Page, isNot bool, defaultTimeout *float64) *pageAssertionsImpl {\n\treturn &pageAssertionsImpl{\n\t\tassertionsBase: assertionsBase{\n\t\t\tactualLocator:  page.Locator(\":root\"),\n\t\t\tisNot:          isNot,\n\t\t\tdefaultTimeout: defaultTimeout,\n\t\t},\n\t\tactualPage: page,\n\t}\n}\n\nfunc (pa *pageAssertionsImpl) ToHaveTitle(titleOrRegExp interface{}, options ...PageAssertionsToHaveTitleOptions) error {\n\tvar timeout *float64\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t}\n\texpectedValues, err := toExpectedTextValues([]interface{}{titleOrRegExp}, false, true, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pa.expect(\n\t\t\"to.have.title\",\n\t\tframeExpectOptions{ExpectedText: expectedValues, Timeout: timeout},\n\t\ttitleOrRegExp,\n\t\t\"Page title expected to be\",\n\t)\n}\n\nfunc (pa *pageAssertionsImpl) ToHaveURL(urlOrRegExp interface{}, options ...PageAssertionsToHaveURLOptions) error {\n\tvar timeout *float64\n\tvar ignoreCase *bool\n\tif len(options) == 1 {\n\t\ttimeout = options[0].Timeout\n\t\tignoreCase = options[0].IgnoreCase\n\t}\n\n\tbaseURL := pa.actualPage.Context().(*browserContextImpl).options.BaseURL\n\tif urlPath, ok := urlOrRegExp.(string); ok && baseURL != nil {\n\t\tu, _ := url.Parse(*baseURL)\n\t\tu.Path = path.Join(u.Path, urlPath)\n\t\turlOrRegExp = u.String()\n\t}\n\n\texpectedValues, err := toExpectedTextValues([]interface{}{urlOrRegExp}, false, false, ignoreCase)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn pa.expect(\n\t\t\"to.have.url\",\n\t\tframeExpectOptions{ExpectedText: expectedValues, Timeout: timeout},\n\t\turlOrRegExp,\n\t\t\"Page URL expected to be\",\n\t)\n}\n\nfunc (pa *pageAssertionsImpl) Not() PageAssertions {\n\treturn newPageAssertions(pa.actualPage, true, pa.defaultTimeout)\n}\n"
        },
        {
          "name": "patches",
          "type": "tree",
          "content": null
        },
        {
          "name": "playwright",
          "type": "commit",
          "content": null
        },
        {
          "name": "playwright.go",
          "type": "blob",
          "size": 2.2861328125,
          "content": "// Package playwright is a library to automate Chromium, Firefox and WebKit with\n// a single API. Playwright is built to enable cross-browser web automation that\n// is ever-green, capable, reliable and fast.\npackage playwright\n\n// DeviceDescriptor represents a single device\ntype DeviceDescriptor struct {\n\tUserAgent          string  `json:\"userAgent\"`\n\tViewport           *Size   `json:\"viewport\"`\n\tScreen             *Size   `json:\"screen\"`\n\tDeviceScaleFactor  float64 `json:\"deviceScaleFactor\"`\n\tIsMobile           bool    `json:\"isMobile\"`\n\tHasTouch           bool    `json:\"hasTouch\"`\n\tDefaultBrowserType string  `json:\"defaultBrowserType\"`\n}\n\n// Playwright represents a Playwright instance\ntype Playwright struct {\n\tchannelOwner\n\tSelectors Selectors\n\tChromium  BrowserType\n\tFirefox   BrowserType\n\tWebKit    BrowserType\n\tRequest   APIRequest\n\tDevices   map[string]*DeviceDescriptor\n}\n\n// Stop stops the Playwright instance\nfunc (p *Playwright) Stop() error {\n\treturn p.connection.Stop()\n}\n\nfunc (p *Playwright) setSelectors(selectors Selectors) {\n\tselectorsOwner := fromChannel(p.initializer[\"selectors\"]).(*selectorsOwnerImpl)\n\tp.Selectors.(*selectorsImpl).removeChannel(selectorsOwner)\n\tp.Selectors = selectors\n\tp.Selectors.(*selectorsImpl).addChannel(selectorsOwner)\n}\n\nfunc newPlaywright(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *Playwright {\n\tpw := &Playwright{\n\t\tSelectors: newSelectorsImpl(),\n\t\tChromium:  fromChannel(initializer[\"chromium\"]).(*browserTypeImpl),\n\t\tFirefox:   fromChannel(initializer[\"firefox\"]).(*browserTypeImpl),\n\t\tWebKit:    fromChannel(initializer[\"webkit\"]).(*browserTypeImpl),\n\t\tDevices:   make(map[string]*DeviceDescriptor),\n\t}\n\tpw.createChannelOwner(pw, parent, objectType, guid, initializer)\n\tpw.Request = newApiRequestImpl(pw)\n\tpw.Chromium.(*browserTypeImpl).playwright = pw\n\tpw.Firefox.(*browserTypeImpl).playwright = pw\n\tpw.WebKit.(*browserTypeImpl).playwright = pw\n\tselectorsOwner := fromChannel(initializer[\"selectors\"]).(*selectorsOwnerImpl)\n\tpw.Selectors.(*selectorsImpl).addChannel(selectorsOwner)\n\tpw.connection.afterClose = func() {\n\t\tpw.Selectors.(*selectorsImpl).removeChannel(selectorsOwner)\n\t}\n\tif pw.connection.localUtils != nil {\n\t\tpw.Devices = pw.connection.localUtils.Devices\n\t}\n\treturn pw\n}\n\n//go:generate bash scripts/generate-api.sh\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 6.419921875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype serializedFallbackOverrides struct {\n\tURL            *string\n\tMethod         *string\n\tHeaders        map[string]string\n\tPostDataBuffer []byte\n}\n\ntype requestImpl struct {\n\tchannelOwner\n\ttiming             *RequestTiming\n\tprovisionalHeaders *rawHeaders\n\tallHeaders         *rawHeaders\n\tredirectedFrom     Request\n\tredirectedTo       Request\n\tfailureText        string\n\tfallbackOverrides  *serializedFallbackOverrides\n}\n\nfunc (r *requestImpl) URL() string {\n\tif r.fallbackOverrides.URL != nil {\n\t\treturn *r.fallbackOverrides.URL\n\t}\n\treturn r.initializer[\"url\"].(string)\n}\n\nfunc (r *requestImpl) ResourceType() string {\n\treturn r.initializer[\"resourceType\"].(string)\n}\n\nfunc (r *requestImpl) Method() string {\n\tif r.fallbackOverrides.Method != nil {\n\t\treturn *r.fallbackOverrides.Method\n\t}\n\treturn r.initializer[\"method\"].(string)\n}\n\nfunc (r *requestImpl) PostData() (string, error) {\n\tbody, err := r.PostDataBuffer()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), err\n}\n\nfunc (r *requestImpl) PostDataJSON(v interface{}) error {\n\tbody, err := r.PostDataBuffer()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(body, v)\n}\n\nfunc (r *requestImpl) PostDataBuffer() ([]byte, error) {\n\tif r.fallbackOverrides.PostDataBuffer != nil {\n\t\treturn r.fallbackOverrides.PostDataBuffer, nil\n\t}\n\tif _, ok := r.initializer[\"postData\"]; !ok {\n\t\treturn nil, nil\n\t}\n\treturn base64.StdEncoding.DecodeString(r.initializer[\"postData\"].(string))\n}\n\nfunc (r *requestImpl) Headers() map[string]string {\n\tif r.fallbackOverrides.Headers != nil {\n\t\treturn newRawHeaders(serializeMapToNameAndValue(r.fallbackOverrides.Headers)).Headers()\n\t}\n\treturn r.provisionalHeaders.Headers()\n}\n\nfunc (r *requestImpl) Response() (Response, error) {\n\tchannel, err := r.channel.Send(\"response\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchannelOwner := fromNullableChannel(channel)\n\tif channelOwner == nil {\n\t\t// no response\n\t\treturn nil, nil\n\t}\n\treturn channelOwner.(*responseImpl), nil\n}\n\nfunc (r *requestImpl) Frame() Frame {\n\tchannel, ok := r.initializer[\"frame\"]\n\tif !ok {\n\t\t// Service Worker requests do not have an associated frame.\n\t\treturn nil\n\t}\n\tframe := fromChannel(channel).(*frameImpl)\n\tif frame.page == nil {\n\t\t// Frame for this navigation request is not available, because the request\n\t\t// was issued before the frame is created. You can check whether the request\n\t\t// is a navigation request by calling IsNavigationRequest() method.\n\t\treturn nil\n\t}\n\treturn frame\n}\n\nfunc (r *requestImpl) IsNavigationRequest() bool {\n\treturn r.initializer[\"isNavigationRequest\"].(bool)\n}\n\nfunc (r *requestImpl) RedirectedFrom() Request {\n\treturn r.redirectedFrom\n}\n\nfunc (r *requestImpl) RedirectedTo() Request {\n\treturn r.redirectedTo\n}\n\nfunc (r *requestImpl) Failure() error {\n\tif r.failureText == \"\" {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"%v\", r.failureText)\n}\n\nfunc (r *requestImpl) Timing() *RequestTiming {\n\treturn r.timing\n}\n\nfunc (r *requestImpl) AllHeaders() (map[string]string, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn headers.Headers(), nil\n}\n\nfunc (r *requestImpl) HeadersArray() ([]NameValue, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn headers.HeadersArray(), nil\n}\n\nfunc (r *requestImpl) HeaderValue(name string) (string, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn headers.Get(name), err\n}\n\nfunc (r *requestImpl) HeaderValues(name string) ([]string, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\treturn headers.GetAll(name), err\n}\n\nfunc (r *requestImpl) ActualHeaders() (*rawHeaders, error) {\n\tif r.fallbackOverrides.Headers != nil {\n\t\treturn newRawHeaders(serializeMapToNameAndValue(r.fallbackOverrides.Headers)), nil\n\t}\n\tif r.allHeaders == nil {\n\t\tresponse, err := r.Response()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif response == nil {\n\t\t\treturn r.provisionalHeaders, nil\n\t\t}\n\t\theaders, err := r.channel.Send(\"rawRequestHeaders\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.allHeaders = newRawHeaders(headers)\n\t}\n\treturn r.allHeaders, nil\n}\n\nfunc (r *requestImpl) ServiceWorker() Worker {\n\tchannel, ok := r.initializer[\"serviceWorker\"]\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn fromChannel(channel).(*workerImpl)\n}\n\nfunc (r *requestImpl) Sizes() (*RequestSizesResult, error) {\n\tresponse, err := r.Response()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsizes, err := response.(*responseImpl).channel.Send(\"sizes\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := &RequestSizesResult{}\n\tremapMapToStruct(sizes, result)\n\treturn result, nil\n}\n\nfunc (r *requestImpl) applyFallbackOverrides(options RouteFallbackOptions) {\n\tif options.URL != nil {\n\t\tr.fallbackOverrides.URL = options.URL\n\t}\n\tif options.Method != nil {\n\t\tr.fallbackOverrides.Method = options.Method\n\t}\n\tr.fallbackOverrides.Headers = options.Headers\n\tif options.PostData != nil {\n\t\tswitch v := options.PostData.(type) {\n\t\tcase string:\n\t\t\tr.fallbackOverrides.PostDataBuffer = []byte(v)\n\t\tcase []byte:\n\t\t\tr.fallbackOverrides.PostDataBuffer = v\n\t\t}\n\t}\n}\n\nfunc (r *requestImpl) targetClosed() <-chan error {\n\tpage := r.safePage()\n\tif page == nil {\n\t\treturn make(<-chan error, 1)\n\t}\n\treturn page.closedOrCrashed\n}\n\nfunc (r *requestImpl) setResponseEndTiming(t float64) {\n\tr.timing.ResponseEnd = t\n\tif r.timing.ResponseStart == -1 {\n\t\tr.timing.ResponseStart = t\n\t}\n}\n\nfunc (r *requestImpl) safePage() *pageImpl {\n\tchannel := fromNullableChannel(r.initializer[\"frame\"])\n\tif channel == nil {\n\t\treturn nil\n\t}\n\tframe, ok := channel.(*frameImpl)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn frame.page\n}\n\nfunc newRequest(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *requestImpl {\n\treq := &requestImpl{}\n\treq.createChannelOwner(req, parent, objectType, guid, initializer)\n\tredirectedFrom := fromNullableChannel(initializer[\"redirectedFrom\"])\n\tif redirectedFrom != nil {\n\t\treq.redirectedFrom = redirectedFrom.(*requestImpl)\n\t}\n\tif req.redirectedFrom != nil {\n\t\treq.redirectedFrom.(*requestImpl).redirectedTo = req\n\t}\n\treq.timing = &RequestTiming{\n\t\tStartTime:             0,\n\t\tDomainLookupStart:     -1,\n\t\tDomainLookupEnd:       -1,\n\t\tConnectStart:          -1,\n\t\tSecureConnectionStart: -1,\n\t\tConnectEnd:            -1,\n\t\tRequestStart:          -1,\n\t\tResponseStart:         -1,\n\t\tResponseEnd:           -1,\n\t}\n\treq.provisionalHeaders = newRawHeaders(req.initializer[\"headers\"])\n\treq.fallbackOverrides = &serializedFallbackOverrides{}\n\treturn req\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 3.966796875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n)\n\ntype responseImpl struct {\n\tchannelOwner\n\trequest            *requestImpl\n\tprovisionalHeaders *rawHeaders\n\trawHeaders         *rawHeaders\n\tfinished           chan error\n}\n\nfunc (r *responseImpl) FromServiceWorker() bool {\n\treturn r.initializer[\"fromServiceWorker\"].(bool)\n}\n\nfunc (r *responseImpl) URL() string {\n\treturn r.initializer[\"url\"].(string)\n}\n\nfunc (r *responseImpl) Ok() bool {\n\treturn r.Status() == 0 || (r.Status() >= 200 && r.Status() <= 299)\n}\n\nfunc (r *responseImpl) Status() int {\n\treturn int(r.initializer[\"status\"].(float64))\n}\n\nfunc (r *responseImpl) StatusText() string {\n\treturn r.initializer[\"statusText\"].(string)\n}\n\nfunc (r *responseImpl) Headers() map[string]string {\n\treturn r.provisionalHeaders.Headers()\n}\n\nfunc (r *responseImpl) Finished() error {\n\tselect {\n\tcase err := <-r.request.targetClosed():\n\t\treturn err\n\tcase err := <-r.finished:\n\t\treturn err\n\t}\n}\n\nfunc (r *responseImpl) Body() ([]byte, error) {\n\tb64Body, err := r.channel.Send(\"body\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn base64.StdEncoding.DecodeString(b64Body.(string))\n}\n\nfunc (r *responseImpl) Text() (string, error) {\n\tbody, err := r.Body()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(body), nil\n}\n\nfunc (r *responseImpl) JSON(v interface{}) error {\n\tbody, err := r.Body()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn json.Unmarshal(body, v)\n}\n\nfunc (r *responseImpl) Request() Request {\n\treturn r.request\n}\n\nfunc (r *responseImpl) Frame() Frame {\n\treturn r.request.Frame()\n}\n\nfunc (r *responseImpl) AllHeaders() (map[string]string, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn headers.Headers(), nil\n}\n\nfunc (r *responseImpl) HeadersArray() ([]NameValue, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn headers.HeadersArray(), nil\n}\n\nfunc (r *responseImpl) HeaderValue(name string) (string, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn headers.Get(name), err\n}\n\nfunc (r *responseImpl) HeaderValues(name string) ([]string, error) {\n\theaders, err := r.ActualHeaders()\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\treturn headers.GetAll(name), err\n}\n\nfunc (r *responseImpl) ActualHeaders() (*rawHeaders, error) {\n\tif r.rawHeaders == nil {\n\t\theaders, err := r.channel.Send(\"rawResponseHeaders\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.rawHeaders = newRawHeaders(headers)\n\t}\n\treturn r.rawHeaders, nil\n}\n\nfunc (r *responseImpl) SecurityDetails() (*ResponseSecurityDetailsResult, error) {\n\tdetails, err := r.channel.Send(\"securityDetails\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := &ResponseSecurityDetailsResult{}\n\tremapMapToStruct(details.(map[string]interface{}), result)\n\treturn result, nil\n}\n\nfunc (r *responseImpl) ServerAddr() (*ResponseServerAddrResult, error) {\n\taddr, err := r.channel.Send(\"serverAddr\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := &ResponseServerAddrResult{}\n\tremapMapToStruct(addr, result)\n\treturn result, nil\n}\n\nfunc newResponse(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *responseImpl {\n\tresp := &responseImpl{}\n\tresp.createChannelOwner(resp, parent, objectType, guid, initializer)\n\ttiming := resp.initializer[\"timing\"].(map[string]interface{})\n\tresp.request = fromChannel(resp.initializer[\"request\"]).(*requestImpl)\n\tresp.request.timing = &RequestTiming{\n\t\tStartTime:             timing[\"startTime\"].(float64),\n\t\tDomainLookupStart:     timing[\"domainLookupStart\"].(float64),\n\t\tDomainLookupEnd:       timing[\"domainLookupEnd\"].(float64),\n\t\tConnectStart:          timing[\"connectStart\"].(float64),\n\t\tSecureConnectionStart: timing[\"secureConnectionStart\"].(float64),\n\t\tConnectEnd:            timing[\"connectEnd\"].(float64),\n\t\tRequestStart:          timing[\"requestStart\"].(float64),\n\t\tResponseStart:         timing[\"responseStart\"].(float64),\n\t}\n\tresp.provisionalHeaders = newRawHeaders(resp.initializer[\"headers\"])\n\tresp.finished = make(chan error, 1)\n\treturn resp\n}\n"
        },
        {
          "name": "route.go",
          "type": "blob",
          "size": 6.384765625,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype routeImpl struct {\n\tchannelOwner\n\thandling *chan bool\n\tcontext  *browserContextImpl\n\tdidThrow bool\n}\n\nfunc (r *routeImpl) startHandling() chan bool {\n\tr.Lock()\n\tdefer r.Unlock()\n\thandling := make(chan bool, 1)\n\tr.handling = &handling\n\treturn handling\n}\n\nfunc (r *routeImpl) reportHandled(done bool) {\n\tr.Lock()\n\tdefer r.Unlock()\n\tif r.handling != nil {\n\t\thandling := *r.handling\n\t\tr.handling = nil\n\t\thandling <- done\n\t}\n}\n\nfunc (r *routeImpl) checkNotHandled() error {\n\tr.RLock()\n\tdefer r.RUnlock()\n\tif r.handling == nil {\n\t\treturn errors.New(\"Route is already handled!\")\n\t}\n\treturn nil\n}\n\nfunc (r *routeImpl) Request() Request {\n\treturn fromChannel(r.initializer[\"request\"]).(*requestImpl)\n}\n\nfunc unpackOptionalArgument(input interface{}) interface{} {\n\tinputValue := reflect.ValueOf(input)\n\tif inputValue.Kind() != reflect.Slice {\n\t\tpanic(\"Needs to be a slice\")\n\t}\n\tif inputValue.Len() == 0 {\n\t\treturn nil\n\t}\n\treturn inputValue.Index(0).Interface()\n}\n\nfunc (r *routeImpl) Abort(errorCode ...string) error {\n\treturn r.handleRoute(func() error {\n\t\treturn r.raceWithPageClose(func() error {\n\t\t\t_, err := r.channel.Send(\"abort\", map[string]interface{}{\n\t\t\t\t\"errorCode\": unpackOptionalArgument(errorCode),\n\t\t\t})\n\t\t\treturn err\n\t\t})\n\t})\n}\n\nfunc (r *routeImpl) raceWithPageClose(f func() error) error {\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\terrChan <- f()\n\t}()\n\n\tselect {\n\tcase <-r.Request().(*requestImpl).targetClosed():\n\t\t// upstream does not throw the err\n\t\treturn nil\n\tcase err := <-errChan:\n\t\treturn err\n\t}\n}\n\nfunc (r *routeImpl) Fulfill(options ...RouteFulfillOptions) error {\n\treturn r.handleRoute(func() error {\n\t\treturn r.innerFulfill(options...)\n\t})\n}\n\nfunc (r *routeImpl) handleRoute(cb func() error) error {\n\terr := r.checkNotHandled()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := cb(); err != nil {\n\t\tr.didThrow = true\n\t\treturn err\n\t}\n\tr.reportHandled(true)\n\treturn nil\n}\n\nfunc (r *routeImpl) innerFulfill(options ...RouteFulfillOptions) error {\n\terr := r.checkNotHandled()\n\tif err != nil {\n\t\treturn err\n\t}\n\toption := RouteFulfillOptions{}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\toverrides := map[string]interface{}{\n\t\t\"status\": 200,\n\t}\n\theaders := make(map[string]string)\n\n\tif option.Response != nil {\n\t\toverrides[\"status\"] = option.Response.Status()\n\t\theaders = option.Response.Headers()\n\t\tresponse, ok := option.Response.(*apiResponseImpl)\n\t\tif option.Body == nil && option.Path == nil && ok && response.request.connection == r.connection {\n\t\t\toverrides[\"fetchResponseUid\"] = response.fetchUid()\n\t\t} else {\n\t\t\toption.Body, _ = option.Response.Body()\n\t\t}\n\t\toption.Response = nil\n\t}\n\tif option.Status != nil {\n\t\toverrides[\"status\"] = *option.Status\n\t\toption.Status = nil\n\t}\n\n\tlength := 0\n\tisBase64 := false\n\tvar fileContentType string\n\tif _, ok := option.Body.(string); ok {\n\t\tisBase64 = false\n\t} else if body, ok := option.Body.([]byte); ok {\n\t\toption.Body = base64.StdEncoding.EncodeToString(body)\n\t\tlength = len(body)\n\t\tisBase64 = true\n\t} else if option.Path != nil {\n\t\tcontent, err := os.ReadFile(*option.Path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfileContentType = http.DetectContentType(content)\n\t\toption.Body = base64.StdEncoding.EncodeToString(content)\n\t\tisBase64 = true\n\t\tlength = len(content)\n\t}\n\n\tif option.Headers != nil {\n\t\theaders = make(map[string]string)\n\t\tfor key, val := range option.Headers {\n\t\t\theaders[strings.ToLower(key)] = val\n\t\t}\n\t\toption.Headers = nil\n\t}\n\tif option.ContentType != nil {\n\t\theaders[\"content-type\"] = *option.ContentType\n\t\toption.ContentType = nil\n\t} else if option.Path != nil {\n\t\theaders[\"content-type\"] = fileContentType\n\t}\n\tif _, ok := headers[\"content-length\"]; !ok && length > 0 {\n\t\theaders[\"content-length\"] = strconv.Itoa(length)\n\t}\n\toverrides[\"headers\"] = serializeMapToNameAndValue(headers)\n\toverrides[\"isBase64\"] = isBase64\n\n\toption.Path = nil\n\terr = r.raceWithPageClose(func() error {\n\t\t_, err := r.channel.Send(\"fulfill\", option, overrides)\n\t\treturn err\n\t})\n\treturn err\n}\n\nfunc (r *routeImpl) Fallback(options ...RouteFallbackOptions) error {\n\terr := r.checkNotHandled()\n\tif err != nil {\n\t\treturn err\n\t}\n\topt := RouteFallbackOptions{}\n\tif len(options) == 1 {\n\t\topt = options[0]\n\t}\n\tr.Request().(*requestImpl).applyFallbackOverrides(opt)\n\tr.reportHandled(false)\n\treturn nil\n}\n\nfunc (r *routeImpl) Fetch(options ...RouteFetchOptions) (APIResponse, error) {\n\topt := &APIRequestContextFetchOptions{}\n\turl := \"\"\n\tif len(options) == 1 {\n\t\terr := assignStructFields(opt, options[0], true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\topt.Data = options[0].PostData\n\t\tif options[0].URL != nil {\n\t\t\turl = *options[0].URL\n\t\t}\n\t}\n\tret, err := r.connection.WrapAPICall(func() (interface{}, error) {\n\t\treturn r.context.request.innerFetch(url, r.Request(), *opt)\n\t}, false)\n\tif ret == nil {\n\t\treturn nil, err\n\t}\n\treturn ret.(APIResponse), err\n}\n\nfunc (r *routeImpl) Continue(options ...RouteContinueOptions) error {\n\toption := &RouteFallbackOptions{}\n\tif len(options) == 1 {\n\t\terr := assignStructFields(option, options[0], true)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn r.handleRoute(func() error {\n\t\tr.Request().(*requestImpl).applyFallbackOverrides(*option)\n\t\treturn r.internalContinue(false)\n\t})\n}\n\nfunc (r *routeImpl) internalContinue(isFallback bool) error {\n\toverrides := make(map[string]interface{})\n\toverrides[\"url\"] = r.Request().(*requestImpl).fallbackOverrides.URL\n\toverrides[\"method\"] = r.Request().(*requestImpl).fallbackOverrides.Method\n\theaders := r.Request().(*requestImpl).fallbackOverrides.Headers\n\tif headers != nil {\n\t\toverrides[\"headers\"] = serializeMapToNameAndValue(headers)\n\t}\n\tpostDataBuf := r.Request().(*requestImpl).fallbackOverrides.PostDataBuffer\n\tif postDataBuf != nil {\n\t\toverrides[\"postData\"] = base64.StdEncoding.EncodeToString(postDataBuf)\n\t}\n\toverrides[\"isFallback\"] = isFallback\n\treturn r.raceWithPageClose(func() error {\n\t\t_, err := r.channel.Send(\"continue\", overrides)\n\t\treturn err\n\t})\n}\n\nfunc (r *routeImpl) redirectedNavigationRequest(url string) error {\n\treturn r.handleRoute(func() error {\n\t\treturn r.raceWithPageClose(func() error {\n\t\t\t_, err := r.channel.Send(\"redirectNavigationRequest\", map[string]interface{}{\n\t\t\t\t\"url\": url,\n\t\t\t})\n\t\t\treturn err\n\t\t})\n\t})\n}\n\nfunc newRoute(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *routeImpl {\n\tbt := &routeImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tbt.markAsInternalType()\n\treturn bt\n}\n"
        },
        {
          "name": "run.go",
          "type": "blob",
          "size": 10.8359375,
          "content": "package playwright\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"log/slog\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n)\n\nconst playwrightCliVersion = \"1.49.1\"\n\nvar (\n\tlogger               = slog.Default()\n\tplaywrightCDNMirrors = []string{\n\t\t\"https://playwright.azureedge.net\",\n\t\t\"https://playwright-akamai.azureedge.net\",\n\t\t\"https://playwright-verizon.azureedge.net\",\n\t}\n)\n\n// PlaywrightDriver wraps the Playwright CLI of upstream Playwright.\n//\n// It's required for playwright-go to work.\ntype PlaywrightDriver struct {\n\tVersion string\n\toptions *RunOptions\n}\n\nfunc NewDriver(options ...*RunOptions) (*PlaywrightDriver, error) {\n\ttransformed, err := transformRunOptions(options...) // get default values\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &PlaywrightDriver{\n\t\toptions: transformed,\n\t\tVersion: playwrightCliVersion,\n\t}, nil\n}\n\nfunc getDefaultCacheDirectory() (string, error) {\n\tuserHomeDir, err := os.UserHomeDir()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"could not get user home directory: %w\", err)\n\t}\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\treturn filepath.Join(userHomeDir, \"AppData\", \"Local\"), nil\n\tcase \"darwin\":\n\t\treturn filepath.Join(userHomeDir, \"Library\", \"Caches\"), nil\n\tcase \"linux\":\n\t\treturn filepath.Join(userHomeDir, \".cache\"), nil\n\t}\n\treturn \"\", errors.New(\"could not determine cache directory\")\n}\n\nfunc (d *PlaywrightDriver) isUpToDateDriver() (bool, error) {\n\tif _, err := os.Stat(d.options.DriverDirectory); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(d.options.DriverDirectory, 0o777); err != nil {\n\t\t\treturn false, fmt.Errorf(\"could not create driver directory: %w\", err)\n\t\t}\n\t}\n\tif _, err := os.Stat(getDriverCliJs(d.options.DriverDirectory)); os.IsNotExist(err) {\n\t\treturn false, nil\n\t} else if err != nil {\n\t\treturn false, fmt.Errorf(\"could not check if driver is up2date: %w\", err)\n\t}\n\tcmd := d.Command(\"--version\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"could not run driver: %w\", err)\n\t}\n\tif bytes.Contains(output, []byte(d.Version)) {\n\t\treturn true, nil\n\t}\n\t// avoid triggering downloads and accidentally overwriting files\n\treturn false, fmt.Errorf(\"driver exists but version not %s in : %s\", d.Version, d.options.DriverDirectory)\n}\n\n// Command returns an exec.Cmd for the driver.\nfunc (d *PlaywrightDriver) Command(arg ...string) *exec.Cmd {\n\tcmd := exec.Command(getNodeExecutable(d.options.DriverDirectory), append([]string{getDriverCliJs(d.options.DriverDirectory)}, arg...)...)\n\tcmd.SysProcAttr = defaultSysProcAttr\n\treturn cmd\n}\n\n// Install downloads the driver and the browsers depending on [RunOptions].\nfunc (d *PlaywrightDriver) Install() error {\n\tif err := d.DownloadDriver(); err != nil {\n\t\treturn fmt.Errorf(\"could not install driver: %w\", err)\n\t}\n\tif d.options.SkipInstallBrowsers {\n\t\treturn nil\n\t}\n\n\td.log(\"Downloading browsers...\")\n\tif err := d.installBrowsers(); err != nil {\n\t\treturn fmt.Errorf(\"could not install browsers: %w\", err)\n\t}\n\td.log(\"Downloaded browsers successfully\")\n\n\treturn nil\n}\n\n// Uninstall removes the driver and the browsers.\nfunc (d *PlaywrightDriver) Uninstall() error {\n\td.log(\"Removing browsers...\")\n\tif err := d.uninstallBrowsers(); err != nil {\n\t\treturn fmt.Errorf(\"could not uninstall browsers: %w\", err)\n\t}\n\n\td.log(\"Removing driver...\")\n\tif err := os.RemoveAll(d.options.DriverDirectory); err != nil {\n\t\treturn fmt.Errorf(\"could not remove driver directory: %w\", err)\n\t}\n\n\td.log(\"Uninstall driver successfully\")\n\treturn nil\n}\n\n// DownloadDriver downloads the driver only\nfunc (d *PlaywrightDriver) DownloadDriver() error {\n\tup2Date, err := d.isUpToDateDriver()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif up2Date {\n\t\treturn nil\n\t}\n\n\td.log(\"Downloading driver\", \"path\", d.options.DriverDirectory)\n\n\tbody, err := downloadDriver(d.getDriverURLs())\n\tif err != nil {\n\t\treturn err\n\t}\n\tzipReader, err := zip.NewReader(bytes.NewReader(body), int64(len(body)))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not read zip content: %w\", err)\n\t}\n\n\tfor _, zipFile := range zipReader.File {\n\t\tzipFileDiskPath := filepath.Join(d.options.DriverDirectory, zipFile.Name)\n\t\tif zipFile.FileInfo().IsDir() {\n\t\t\tif err := os.MkdirAll(zipFileDiskPath, os.ModePerm); err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not create directory: %w\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\toutFile, err := os.Create(zipFileDiskPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not create driver: %w\", err)\n\t\t}\n\t\tfile, err := zipFile.Open()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not open zip file: %w\", err)\n\t\t}\n\t\tif _, err = io.Copy(outFile, file); err != nil {\n\t\t\treturn fmt.Errorf(\"could not copy response body to file: %w\", err)\n\t\t}\n\t\tif err := outFile.Close(); err != nil {\n\t\t\treturn fmt.Errorf(\"could not close file (driver): %w\", err)\n\t\t}\n\t\tif err := file.Close(); err != nil {\n\t\t\treturn fmt.Errorf(\"could not close file (zip file): %w\", err)\n\t\t}\n\t\tif zipFile.Mode().Perm()&0o100 != 0 && runtime.GOOS != \"windows\" {\n\t\t\tif err := makeFileExecutable(zipFileDiskPath); err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not make executable: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\td.log(\"Downloaded driver successfully\")\n\n\treturn nil\n}\n\nfunc (d *PlaywrightDriver) log(msg string, args ...any) {\n\tif d.options.Verbose {\n\t\tlogger.Info(msg, args...)\n\t}\n}\n\nfunc (d *PlaywrightDriver) run() (*connection, error) {\n\ttransport, err := newPipeTransport(d, d.options.Stderr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconnection := newConnection(transport)\n\treturn connection, nil\n}\n\nfunc (d *PlaywrightDriver) installBrowsers() error {\n\tadditionalArgs := []string{\"install\"}\n\tif d.options.Browsers != nil {\n\t\tadditionalArgs = append(additionalArgs, d.options.Browsers...)\n\t}\n\tcmd := d.Command(additionalArgs...)\n\tcmd.Stdout = d.options.Stdout\n\tcmd.Stderr = d.options.Stderr\n\treturn cmd.Run()\n}\n\nfunc (d *PlaywrightDriver) uninstallBrowsers() error {\n\tcmd := d.Command(\"uninstall\")\n\tcmd.Stdout = d.options.Stdout\n\tcmd.Stderr = d.options.Stderr\n\treturn cmd.Run()\n}\n\n// RunOptions are custom options to run the driver\ntype RunOptions struct {\n\t// DriverDirectory points to the playwright driver directory.\n\t// It should have two subdirectories: node and package.\n\t// You can also specify it using the environment variable PLAYWRIGHT_DRIVER_PATH.\n\t//\n\t// Default is user cache directory + \"/ms-playwright-go/x.xx.xx\":\n\t//  - Windows: %USERPROFILE%\\AppData\\Local\n\t//  - macOS: ~/Library/Caches\n\t//  - Linux: ~/.cache\n\tDriverDirectory     string\n\tSkipInstallBrowsers bool\n\t// if not set and SkipInstallBrowsers is false, will download all browsers (chromium, firefox, webkit)\n\tBrowsers []string\n\tVerbose  bool // default true\n\tStdout   io.Writer\n\tStderr   io.Writer\n\tLogger   *slog.Logger\n}\n\n// Install does download the driver and the browsers.\n//\n// Use this before playwright.Run() or use playwright cli to install the driver and browsers\nfunc Install(options ...*RunOptions) error {\n\tdriver, err := NewDriver(options...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not get driver instance: %w\", err)\n\t}\n\tif err := driver.Install(); err != nil {\n\t\treturn fmt.Errorf(\"could not install driver: %w\", err)\n\t}\n\treturn nil\n}\n\n// Run starts a Playwright instance.\n//\n// Requires the driver and the browsers to be installed before.\n// Either use Install() or use playwright cli.\nfunc Run(options ...*RunOptions) (*Playwright, error) {\n\tdriver, err := NewDriver(options...)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not get driver instance: %w\", err)\n\t}\n\tup2date, err := driver.isUpToDateDriver()\n\tif err != nil || !up2date {\n\t\treturn nil, fmt.Errorf(\"please install the driver (v%s) first: %w\", playwrightCliVersion, err)\n\t}\n\tconnection, err := driver.run()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tplaywright, err := connection.Start()\n\treturn playwright, err\n}\n\nfunc transformRunOptions(options ...*RunOptions) (*RunOptions, error) {\n\toption := &RunOptions{\n\t\tVerbose: true,\n\t}\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\tif option.DriverDirectory == \"\" { // if user did not set it, try to get it from env\n\t\toption.DriverDirectory = os.Getenv(\"PLAYWRIGHT_DRIVER_PATH\")\n\t}\n\tif option.DriverDirectory == \"\" {\n\t\tcacheDirectory, err := getDefaultCacheDirectory()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not get default cache directory: %w\", err)\n\t\t}\n\t\toption.DriverDirectory = filepath.Join(cacheDirectory, \"ms-playwright-go\", playwrightCliVersion)\n\t}\n\tif option.Stdout == nil {\n\t\toption.Stdout = os.Stdout\n\t}\n\tif option.Stderr == nil {\n\t\toption.Stderr = os.Stderr\n\t} else if option.Logger == nil {\n\t\tlog.SetOutput(option.Stderr)\n\t}\n\tif option.Logger != nil {\n\t\tlogger = option.Logger\n\t}\n\treturn option, nil\n}\n\nfunc getNodeExecutable(driverDirectory string) string {\n\tenvPath := os.Getenv(\"PLAYWRIGHT_NODEJS_PATH\")\n\tif envPath != \"\" {\n\t\treturn envPath\n\t}\n\n\tnode := \"node\"\n\tif runtime.GOOS == \"windows\" {\n\t\tnode = \"node.exe\"\n\t}\n\treturn filepath.Join(driverDirectory, node)\n}\n\nfunc getDriverCliJs(driverDirectory string) string {\n\treturn filepath.Join(driverDirectory, \"package\", \"cli.js\")\n}\n\nfunc (d *PlaywrightDriver) getDriverURLs() []string {\n\tplatform := \"\"\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tplatform = \"win32_x64\"\n\tcase \"darwin\":\n\t\tif runtime.GOARCH == \"arm64\" {\n\t\t\tplatform = \"mac-arm64\"\n\t\t} else {\n\t\t\tplatform = \"mac\"\n\t\t}\n\tcase \"linux\":\n\t\tif runtime.GOARCH == \"arm64\" {\n\t\t\tplatform = \"linux-arm64\"\n\t\t} else {\n\t\t\tplatform = \"linux\"\n\t\t}\n\t}\n\n\tbaseURLs := []string{}\n\tpattern := \"%s/builds/driver/playwright-%s-%s.zip\"\n\tif !d.isReleaseVersion() {\n\t\tpattern = \"%s/builds/driver/next/playwright-%s-%s.zip\"\n\t}\n\n\tif hostEnv := os.Getenv(\"PLAYWRIGHT_DOWNLOAD_HOST\"); hostEnv != \"\" {\n\t\tbaseURLs = append(baseURLs, fmt.Sprintf(pattern, hostEnv, d.Version, platform))\n\t} else {\n\t\tfor _, mirror := range playwrightCDNMirrors {\n\t\t\tbaseURLs = append(baseURLs, fmt.Sprintf(pattern, mirror, d.Version, platform))\n\t\t}\n\t}\n\treturn baseURLs\n}\n\n// isReleaseVersion checks if the version is not a beta or alpha release\n// this helps to determine the url from where to download the driver\nfunc (d *PlaywrightDriver) isReleaseVersion() bool {\n\treturn !strings.Contains(d.Version, \"beta\") && !strings.Contains(d.Version, \"alpha\") && !strings.Contains(d.Version, \"next\")\n}\n\nfunc makeFileExecutable(path string) error {\n\tstats, err := os.Stat(path)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not stat driver: %w\", err)\n\t}\n\tif err := os.Chmod(path, stats.Mode()|0x40); err != nil {\n\t\treturn fmt.Errorf(\"could not set permissions: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc downloadDriver(driverURLs []string) (body []byte, e error) {\n\tfor _, driverURL := range driverURLs {\n\t\tresp, err := http.Get(driverURL)\n\t\tif err != nil {\n\t\t\te = errors.Join(e, fmt.Errorf(\"could not download driver from %s: %w\", driverURL, err))\n\t\t\tcontinue\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\te = errors.Join(e, fmt.Errorf(\"error: got non 200 status code: %d (%s) from %s\", resp.StatusCode, resp.Status, driverURL))\n\t\t\tcontinue\n\t\t}\n\t\tbody, err = io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\te = errors.Join(e, fmt.Errorf(\"could not read response body: %w\", err))\n\t\t\tcontinue\n\t\t}\n\t\treturn body, nil\n\t}\n\treturn nil, e\n}\n"
        },
        {
          "name": "run_test.go",
          "type": "blob",
          "size": 4.2197265625,
          "content": "package playwright\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/mitchellh/go-ps\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRunOptionsRedirectStderr(t *testing.T) {\n\tr, w := io.Pipe()\n\tvar output string\n\twg := &sync.WaitGroup{}\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tbuf := bufio.NewReader(r)\n\t\tfor {\n\t\t\tline, _, err := buf.ReadLine()\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toutput += string(line)\n\t\t}\n\t\t_ = r.Close()\n\t}()\n\n\tdriverPath := t.TempDir()\n\toptions := &RunOptions{\n\t\tStderr:          w,\n\t\tDriverDirectory: driverPath,\n\t\tBrowsers:        []string{},\n\t\tVerbose:         true,\n\t}\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(404)\n\t}))\n\tdefer ts.Close()\n\n\tt.Setenv(\"PLAYWRIGHT_DOWNLOAD_HOST\", ts.URL)\n\tdriver, err := NewDriver(options)\n\trequire.NoError(t, err)\n\terr = driver.Install()\n\trequire.Error(t, err)\n\trequire.NoError(t, w.Close())\n\twg.Wait()\n\n\tassert.Contains(t, output, \"Downloading driver\")\n\trequire.Contains(t, output, fmt.Sprintf(\"path=%s\", driverPath))\n}\n\nfunc TestDriverInstall(t *testing.T) {\n\tdriverPath := t.TempDir()\n\tdriver, err := NewDriver(&RunOptions{\n\t\tDriverDirectory: driverPath,\n\t\tBrowsers:        []string{getBrowserName()},\n\t\tVerbose:         true,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"could not start driver: %v\", err)\n\t}\n\tbrowserPath := t.TempDir()\n\terr = os.Setenv(\"PLAYWRIGHT_BROWSERS_PATH\", browserPath)\n\tif err != nil {\n\t\tt.Fatalf(\"could not set PLAYWRIGHT_BROWSERS_PATH: %v\", err)\n\t}\n\tdefer os.Unsetenv(\"PLAYWRIGHT_BROWSERS_PATH\")\n\terr = driver.Install()\n\tif err != nil {\n\t\tt.Fatalf(\"could not install driver: %v\", err)\n\t}\n\terr = driver.Uninstall()\n\tif err != nil {\n\t\tt.Fatalf(\"could not uninstall driver: %v\", err)\n\t}\n}\n\nfunc TestDriverDownloadHostEnv(t *testing.T) {\n\tdriverPath := t.TempDir()\n\tdriver, err := NewDriver(&RunOptions{\n\t\tDriverDirectory:     driverPath,\n\t\tSkipInstallBrowsers: true,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"could not start driver: %v\", err)\n\t}\n\turi := \"\"\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\turi = r.URL.String()\n\t\tw.WriteHeader(404)\n\t}))\n\tdefer ts.Close()\n\n\terr = os.Setenv(\"PLAYWRIGHT_DOWNLOAD_HOST\", ts.URL)\n\tif err != nil {\n\t\tt.Fatalf(\"could not set PLAYWRIGHT_DOWNLOAD_HOST: %v\", err)\n\t}\n\tdefer os.Unsetenv(\"PLAYWRIGHT_DOWNLOAD_HOST\")\n\terr = driver.Install()\n\tif err == nil || !strings.Contains(err.Error(), \"404 Not Found\") || !strings.Contains(uri, \"/builds/driver\") {\n\t\tt.Fatalf(\"PLAYWRIGHT_DOWNLOAD_HOST do not work: %v\", err)\n\t}\n}\n\nfunc TestShouldNotHangWhenPlaywrightUnexpectedExit(t *testing.T) {\n\tif getBrowserName() != \"chromium\" {\n\t\tt.Skip(\"chromium only\")\n\t\treturn\n\t}\n\n\tpw, err := Run()\n\trequire.NoError(t, err)\n\tdefer func() {\n\t\t_ = pw.Stop()\n\t}()\n\tbrowser, err := pw.Chromium.Launch()\n\trequire.NoError(t, err)\n\tcontext, err := browser.NewContext()\n\trequire.NoError(t, err)\n\n\terr = killPlaywrightProcess()\n\trequire.NoError(t, err)\n\n\t_, err = context.NewPage()\n\trequire.Error(t, err)\n}\n\nfunc TestGetNodeExecutable(t *testing.T) {\n\t// When PLAYWRIGHT_NODEJS_PATH is set, use that path.\n\terr := os.Setenv(\"PLAYWRIGHT_NODEJS_PATH\", \"envDir/node.exe\")\n\trequire.NoError(t, err)\n\n\texecutable := getNodeExecutable(\"testDirectory\")\n\tassert.Equal(t, \"envDir/node.exe\", executable)\n\n\terr = os.Unsetenv(\"PLAYWRIGHT_NODEJS_PATH\")\n\trequire.NoError(t, err)\n\n\texecutable = getNodeExecutable(\"testDirectory\")\n\tassert.Contains(t, executable, \"testDirectory\")\n}\n\n// find and kill playwright process\nfunc killPlaywrightProcess() error {\n\tall, err := ps.Processes()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, process := range all {\n\t\tif process.Executable() == \"node\" || process.Executable() == \"node.exe\" {\n\t\t\tif process.PPid() == os.Getpid() {\n\t\t\t\tif err := killProcessByPid(process.Pid()); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn fmt.Errorf(\"playwright process not found\")\n}\n\nfunc killProcessByPid(pid int) error {\n\tprocess, err := os.FindProcess(pid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := process.Kill(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc getBrowserName() string {\n\tbrowserName, hasEnv := os.LookupEnv(\"BROWSER\")\n\tif hasEnv {\n\t\treturn browserName\n\t}\n\treturn \"chromium\"\n}\n"
        },
        {
          "name": "run_unix.go",
          "type": "blob",
          "size": 0.169921875,
          "content": "//go:build !windows\n\npackage playwright\n\nimport \"syscall\"\n\nvar defaultSysProcAttr = &syscall.SysProcAttr{}\n\n// for WritableStream.Copy\nconst defaultCopyBufSize = 1024 * 1024\n"
        },
        {
          "name": "run_win.go",
          "type": "blob",
          "size": 0.1826171875,
          "content": "//go:build windows\n\npackage playwright\n\nimport \"syscall\"\n\nvar defaultSysProcAttr = &syscall.SysProcAttr{HideWindow: true}\n\n// for WritableStream.Copy\nconst defaultCopyBufSize = 64 * 1024\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "selectors.go",
          "type": "blob",
          "size": 2.1669921875,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"sync\"\n)\n\ntype selectorsOwnerImpl struct {\n\tchannelOwner\n}\n\nfunc (s *selectorsOwnerImpl) setTestIdAttributeName(name string) {\n\ts.channel.SendNoReply(\"setTestIdAttributeName\", map[string]interface{}{\n\t\t\"testIdAttributeName\": name,\n\t})\n}\n\nfunc newSelectorsOwner(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *selectorsOwnerImpl {\n\tobj := &selectorsOwnerImpl{}\n\tobj.createChannelOwner(obj, parent, objectType, guid, initializer)\n\treturn obj\n}\n\ntype selectorsImpl struct {\n\tchannels      sync.Map\n\tregistrations []map[string]interface{}\n}\n\nfunc (s *selectorsImpl) Register(name string, script Script, options ...SelectorsRegisterOptions) error {\n\tif script.Path == nil && script.Content == nil {\n\t\treturn errors.New(\"Either source or path should be specified\")\n\t}\n\tsource := \"\"\n\tif script.Path != nil {\n\t\tcontent, err := os.ReadFile(*script.Path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsource = string(content)\n\t} else {\n\t\tsource = *script.Content\n\t}\n\tparams := map[string]interface{}{\n\t\t\"name\":   name,\n\t\t\"source\": source,\n\t}\n\tif len(options) == 1 && options[0].ContentScript != nil {\n\t\tparams[\"contentScript\"] = *options[0].ContentScript\n\t}\n\tvar err error\n\ts.channels.Range(func(key, value any) bool {\n\t\t_, err = value.(*selectorsOwnerImpl).channel.Send(\"register\", params)\n\t\treturn err == nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.registrations = append(s.registrations, params)\n\treturn nil\n}\n\nfunc (s *selectorsImpl) SetTestIdAttribute(name string) {\n\tsetTestIdAttributeName(name)\n\ts.channels.Range(func(key, value any) bool {\n\t\tvalue.(*selectorsOwnerImpl).setTestIdAttributeName(name)\n\t\treturn true\n\t})\n}\n\nfunc (s *selectorsImpl) addChannel(channel *selectorsOwnerImpl) {\n\ts.channels.Store(channel.guid, channel)\n\tfor _, params := range s.registrations {\n\t\tchannel.channel.SendNoReply(\"register\", params)\n\t\tchannel.setTestIdAttributeName(getTestIdAttributeName())\n\t}\n}\n\nfunc (s *selectorsImpl) removeChannel(channel *selectorsOwnerImpl) {\n\ts.channels.Delete(channel.guid)\n}\n\nfunc newSelectorsImpl() *selectorsImpl {\n\treturn &selectorsImpl{\n\t\tchannels:      sync.Map{},\n\t\tregistrations: make([]map[string]interface{}, 0),\n\t}\n}\n"
        },
        {
          "name": "stream.go",
          "type": "blob",
          "size": 1.3310546875,
          "content": "package playwright\n\nimport (\n\t\"bufio\"\n\t\"encoding/base64\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype streamImpl struct {\n\tchannelOwner\n}\n\nfunc (s *streamImpl) SaveAs(path string) error {\n\terr := os.MkdirAll(filepath.Dir(path), 0o777)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\twriter := bufio.NewWriter(file)\n\tfor {\n\t\tbinary, err := s.channel.Send(\"read\", map[string]interface{}{\"size\": 1024 * 1024})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tbytes, err := base64.StdEncoding.DecodeString(binary.(string))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(bytes) == 0 {\n\t\t\tbreak\n\t\t}\n\t\t_, err = writer.Write(bytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn writer.Flush()\n}\n\nfunc (s *streamImpl) ReadAll() ([]byte, error) {\n\tvar data []byte\n\tfor {\n\t\tbinary, err := s.channel.Send(\"read\", map[string]interface{}{\"size\": 1024 * 1024})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbytes, err := base64.StdEncoding.DecodeString(binary.(string))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(bytes) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tdata = append(data, bytes...)\n\t}\n\treturn data, nil\n}\n\nfunc newStream(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *streamImpl {\n\tstream := &streamImpl{}\n\tstream.createChannelOwner(stream, parent, objectType, guid, initializer)\n\treturn stream\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tracing.go",
          "type": "blob",
          "size": 4.0400390625,
          "content": "package playwright\n\nimport \"fmt\"\n\ntype tracingImpl struct {\n\tchannelOwner\n\tincludeSources bool\n\tisTracing      bool\n\tstacksId       string\n\ttracesDir      string\n}\n\nfunc (t *tracingImpl) Start(options ...TracingStartOptions) error {\n\tchunkOption := TracingStartChunkOptions{}\n\tif len(options) == 1 {\n\t\tif options[0].Sources != nil {\n\t\t\tt.includeSources = *options[0].Sources\n\t\t}\n\t\tchunkOption.Name = options[0].Name\n\t\tchunkOption.Title = options[0].Title\n\t}\n\tinnerStart := func() (interface{}, error) {\n\t\tif _, err := t.channel.Send(\"tracingStart\", options); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn t.channel.Send(\"tracingStartChunk\", chunkOption)\n\t}\n\tname, err := innerStart()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.startCollectingStacks(name.(string))\n}\n\nfunc (t *tracingImpl) StartChunk(options ...TracingStartChunkOptions) error {\n\tname, err := t.channel.Send(\"tracingStartChunk\", options)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.startCollectingStacks(name.(string))\n}\n\nfunc (t *tracingImpl) StopChunk(path ...string) error {\n\tfilePath := \"\"\n\tif len(path) == 1 {\n\t\tfilePath = path[0]\n\t}\n\treturn t.doStopChunk(filePath)\n}\n\nfunc (t *tracingImpl) Stop(path ...string) error {\n\tfilePath := \"\"\n\tif len(path) == 1 {\n\t\tfilePath = path[0]\n\t}\n\tif err := t.doStopChunk(filePath); err != nil {\n\t\treturn err\n\t}\n\t_, err := t.channel.Send(\"tracingStop\")\n\treturn err\n}\n\nfunc (t *tracingImpl) doStopChunk(filePath string) (err error) {\n\tif t.isTracing {\n\t\tt.isTracing = false\n\t\tt.connection.setInTracing(false)\n\t}\n\tif filePath == \"\" {\n\t\t// Not interested in artifacts.\n\t\t_, err = t.channel.Send(\"tracingStopChunk\", map[string]interface{}{\n\t\t\t\"mode\": \"discard\",\n\t\t})\n\t\tif t.stacksId != \"\" {\n\t\t\treturn t.connection.LocalUtils().TraceDiscarded(t.stacksId)\n\t\t}\n\t\treturn err\n\t}\n\n\tisLocal := !t.connection.isRemote\n\tif isLocal {\n\t\tresult, err := t.channel.SendReturnAsDict(\"tracingStopChunk\", map[string]interface{}{\n\t\t\t\"mode\": \"entries\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tentries, ok := result[\"entries\"]\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"could not convert result to map: %v\", result)\n\t\t}\n\t\t_, err = t.connection.LocalUtils().Zip(localUtilsZipOptions{\n\t\t\tZipFile:        filePath,\n\t\t\tEntries:        entries.([]interface{}),\n\t\t\tStacksId:       t.stacksId,\n\t\t\tMode:           \"write\",\n\t\t\tIncludeSources: t.includeSources,\n\t\t})\n\t\treturn err\n\t}\n\n\tresult, err := t.channel.SendReturnAsDict(\"tracingStopChunk\", map[string]interface{}{\n\t\t\"mode\": \"archive\",\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tartifactChannel, ok := result[\"artifact\"]\n\tif !ok {\n\t\treturn fmt.Errorf(\"could not convert result to map: %v\", result)\n\t}\n\t// Save trace to the final local file.\n\tartifact := fromNullableChannel(artifactChannel).(*artifactImpl)\n\t// The artifact may be missing if the browser closed while stopping tracing.\n\tif artifact == nil {\n\t\tif t.stacksId != \"\" {\n\t\t\treturn t.connection.LocalUtils().TraceDiscarded(t.stacksId)\n\t\t}\n\t\treturn\n\t}\n\tif err := artifact.SaveAs(filePath); err != nil {\n\t\treturn err\n\t}\n\tif err := artifact.Delete(); err != nil {\n\t\treturn err\n\t}\n\t_, err = t.connection.LocalUtils().Zip(localUtilsZipOptions{\n\t\tZipFile:        filePath,\n\t\tEntries:        []interface{}{},\n\t\tStacksId:       t.stacksId,\n\t\tMode:           \"append\",\n\t\tIncludeSources: t.includeSources,\n\t})\n\treturn err\n}\n\nfunc (t *tracingImpl) startCollectingStacks(name string) (err error) {\n\tif !t.isTracing {\n\t\tt.isTracing = true\n\t\tt.connection.setInTracing(true)\n\t}\n\tt.stacksId, err = t.connection.LocalUtils().TracingStarted(name, t.tracesDir)\n\treturn\n}\n\nfunc (t *tracingImpl) Group(name string, options ...TracingGroupOptions) error {\n\tvar option TracingGroupOptions\n\tif len(options) == 1 {\n\t\toption = options[0]\n\t}\n\t_, err := t.channel.Send(\"tracingGroup\", option, map[string]interface{}{\"name\": name})\n\treturn err\n}\n\nfunc (t *tracingImpl) GroupEnd() error {\n\t_, err := t.channel.Send(\"tracingGroupEnd\")\n\treturn err\n}\n\nfunc newTracing(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *tracingImpl {\n\tbt := &tracingImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tbt.markAsInternalType()\n\treturn bt\n}\n"
        },
        {
          "name": "transport.go",
          "type": "blob",
          "size": 3.0390625,
          "content": "package playwright\n\nimport (\n\t\"bufio\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/go-jose/go-jose/v3/json\"\n)\n\ntype transport interface {\n\tSend(msg map[string]interface{}) error\n\tPoll() (*message, error)\n\tClose() error\n}\n\ntype pipeTransport struct {\n\twriter    io.WriteCloser\n\tbufReader *bufio.Reader\n\tclosed    chan struct{}\n\tonClose   func() error\n}\n\nfunc (t *pipeTransport) Poll() (*message, error) {\n\tif t.isClosed() {\n\t\treturn nil, fmt.Errorf(\"transport closed\")\n\t}\n\n\tvar length uint32\n\terr := binary.Read(t.bufReader, binary.LittleEndian, &length)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read protocol padding: %w\", err)\n\t}\n\n\tdata := make([]byte, length)\n\t_, err = io.ReadFull(t.bufReader, data)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read protocol data: %w\", err)\n\t}\n\n\tmsg := &message{}\n\tif err := json.Unmarshal(data, &msg); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not decode json: %w\", err)\n\t}\n\tif os.Getenv(\"DEBUGP\") != \"\" {\n\t\tfmt.Fprintf(os.Stdout, \"\\x1b[33mRECV>\\x1b[0m\\n%s\\n\", data)\n\t}\n\treturn msg, nil\n}\n\ntype message struct {\n\tID     int                    `json:\"id\"`\n\tGUID   string                 `json:\"guid\"`\n\tMethod string                 `json:\"method,omitempty\"`\n\tParams map[string]interface{} `json:\"params,omitempty\"`\n\tResult map[string]interface{} `json:\"result,omitempty\"`\n\tError  *struct {\n\t\tError Error `json:\"error\"`\n\t} `json:\"error,omitempty\"`\n}\n\nfunc (t *pipeTransport) Send(msg map[string]interface{}) error {\n\tif t.isClosed() {\n\t\treturn fmt.Errorf(\"transport closed\")\n\t}\n\tmsgBytes, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"pipeTransport: could not marshal json: %w\", err)\n\t}\n\tif os.Getenv(\"DEBUGP\") != \"\" {\n\t\tfmt.Fprintf(os.Stdout, \"\\x1b[32mSEND>\\x1b[0m\\n%s\\n\", msgBytes)\n\t}\n\n\tlengthPadding := make([]byte, 4)\n\tbinary.LittleEndian.PutUint32(lengthPadding, uint32(len(msgBytes)))\n\tif _, err = t.writer.Write(append(lengthPadding, msgBytes...)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (t *pipeTransport) Close() error {\n\tselect {\n\tcase <-t.closed:\n\t\treturn nil\n\tdefault:\n\t\treturn t.onClose()\n\t}\n}\n\nfunc (t *pipeTransport) isClosed() bool {\n\tselect {\n\tcase <-t.closed:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc newPipeTransport(driver *PlaywrightDriver, stderr io.Writer) (transport, error) {\n\tt := &pipeTransport{\n\t\tclosed: make(chan struct{}, 1),\n\t}\n\n\tcmd := driver.Command(\"run-driver\")\n\tcmd.Stderr = stderr\n\tstdin, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not create stdin pipe: %w\", err)\n\t}\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not create stdout pipe: %w\", err)\n\t}\n\tt.writer = stdin\n\tt.bufReader = bufio.NewReader(stdout)\n\n\tt.onClose = func() error {\n\t\tselect {\n\t\tcase <-t.closed:\n\t\tdefault:\n\t\t\tclose(t.closed)\n\t\t}\n\t\tif err := t.writer.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// playwright-cli will exit when its stdin is closed\n\t\tif err := cmd.Wait(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not start driver: %w\", err)\n\t}\n\n\treturn t, nil\n}\n"
        },
        {
          "name": "type_helpers.go",
          "type": "blob",
          "size": 1.7861328125,
          "content": "package playwright\n\n// String is a helper routine that allocates a new string value\n// to store v and returns a pointer to it.\nfunc String(v string) *string {\n\treturn &v\n}\n\n// Bool is a helper routine that allocates a new bool value\n// to store v and returns a pointer to it.\nfunc Bool(v bool) *bool {\n\treturn &v\n}\n\n// Int is a helper routine that allocates a new int32 value\n// to store v and returns a pointer to it.\nfunc Int(v int) *int {\n\treturn &v\n}\n\n// Float is a helper routine that allocates a new float64 value\n// to store v and returns a pointer to it.\nfunc Float(v float64) *float64 {\n\treturn &v\n}\n\n// Null will be used in certain scenarios where a strict nil pointer\n// check is not possible\nfunc Null() interface{} {\n\treturn \"PW_NULL\"\n}\n\n// StringSlice is a helper routine that allocates a new StringSlice value\n// to store v and returns a pointer to it.\nfunc StringSlice(v ...string) *[]string {\n\tvar o []string\n\to = append(o, v...)\n\treturn &o\n}\n\n// IntSlice is a helper routine that allocates a new IntSlice value\n// to store v and returns a pointer to it.\nfunc IntSlice(v ...int) *[]int {\n\tvar o []int\n\to = append(o, v...)\n\treturn &o\n}\n\n// ToOptionalStorageState converts StorageState to OptionalStorageState for use directly in [Browser.NewContext]\nfunc (s StorageState) ToOptionalStorageState() *OptionalStorageState {\n\tcookies := make([]OptionalCookie, len(s.Cookies))\n\tfor i, c := range s.Cookies {\n\t\tcookies[i] = c.ToOptionalCookie()\n\t}\n\treturn &OptionalStorageState{\n\t\tOrigins: s.Origins,\n\t\tCookies: cookies,\n\t}\n}\n\nfunc (c Cookie) ToOptionalCookie() OptionalCookie {\n\treturn OptionalCookie{\n\t\tName:     c.Name,\n\t\tValue:    c.Value,\n\t\tDomain:   String(c.Domain),\n\t\tPath:     String(c.Path),\n\t\tExpires:  Float(c.Expires),\n\t\tHttpOnly: Bool(c.HttpOnly),\n\t\tSecure:   Bool(c.Secure),\n\t\tSameSite: c.SameSite,\n\t}\n}\n"
        },
        {
          "name": "video.go",
          "type": "blob",
          "size": 2.068359375,
          "content": "package playwright\n\nimport (\n\t\"errors\"\n\t\"sync\"\n)\n\ntype videoImpl struct {\n\tpage         *pageImpl\n\tartifact     *artifactImpl\n\tartifactChan chan *artifactImpl\n\tdone         chan struct{}\n\tcloseOnce    sync.Once\n\tisRemote     bool\n}\n\nfunc (v *videoImpl) Path() (string, error) {\n\tif v.isRemote {\n\t\treturn \"\", errors.New(\"Path is not available when connecting remotely. Use SaveAs() to save a local copy.\")\n\t}\n\tv.getArtifact()\n\tif v.artifact == nil {\n\t\treturn \"\", errors.New(\"Page did not produce any video frames\")\n\t}\n\treturn v.artifact.AbsolutePath(), nil\n}\n\nfunc (v *videoImpl) Delete() error {\n\tv.getArtifact()\n\tif v.artifact == nil {\n\t\treturn nil\n\t}\n\treturn v.artifact.Delete()\n}\n\nfunc (v *videoImpl) SaveAs(path string) error {\n\tif !v.page.IsClosed() {\n\t\treturn errors.New(\"Page is not yet closed. Close the page prior to calling SaveAs\")\n\t}\n\tv.getArtifact()\n\tif v.artifact == nil {\n\t\treturn errors.New(\"Page did not produce any video frames\")\n\t}\n\treturn v.artifact.SaveAs(path)\n}\n\nfunc (v *videoImpl) artifactReady(artifact *artifactImpl) {\n\tv.artifactChan <- artifact\n}\n\nfunc (v *videoImpl) pageClosed(p Page) {\n\tv.closeOnce.Do(func() {\n\t\tclose(v.done)\n\t})\n}\n\nfunc (v *videoImpl) getArtifact() {\n\t// prevent channel block if no video will be produced\n\tif v.page.browserContext.options == nil {\n\t\tv.pageClosed(v.page)\n\t} else {\n\t\toption := v.page.browserContext.options\n\t\tif option == nil || option.RecordVideo == nil { // no recordVideo option\n\t\t\tv.pageClosed(v.page)\n\t\t}\n\t}\n\tselect {\n\tcase artifact := <-v.artifactChan:\n\t\tif artifact != nil {\n\t\t\tv.artifact = artifact\n\t\t}\n\tcase <-v.done: // page closed\n\t\tselect { // make sure get artifact if it's ready before page closed\n\t\tcase artifact := <-v.artifactChan:\n\t\t\tif artifact != nil {\n\t\t\t\tv.artifact = artifact\n\t\t\t}\n\t\tdefault:\n\t\t}\n\t}\n}\n\nfunc newVideo(page *pageImpl) *videoImpl {\n\tvideo := &videoImpl{\n\t\tpage:         page,\n\t\tartifactChan: make(chan *artifactImpl, 1),\n\t\tdone:         make(chan struct{}, 1),\n\t\tisRemote:     page.connection.isRemote,\n\t}\n\n\tif page.isClosed {\n\t\tvideo.pageClosed(page)\n\t} else {\n\t\tpage.OnClose(video.pageClosed)\n\t}\n\treturn video\n}\n"
        },
        {
          "name": "waiter.go",
          "type": "blob",
          "size": 3.9453125,
          "content": "package playwright\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype (\n\twaiter struct {\n\t\tmu        sync.Mutex\n\t\ttimeout   float64\n\t\tfulfilled atomic.Bool\n\t\tlisteners []eventListener\n\t\terrChan   chan error\n\t\twaitFunc  func() (interface{}, error)\n\t}\n\teventListener struct {\n\t\temitter EventEmitter\n\t\tevent   string\n\t\thandler interface{}\n\t}\n)\n\n// RejectOnEvent sets the Waiter to return an error when an event occurs (and the predicate returns true)\nfunc (w *waiter) RejectOnEvent(emitter EventEmitter, event string, err error, predicates ...interface{}) *waiter {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tif w.waitFunc != nil {\n\t\tw.reject(fmt.Errorf(\"waiter: call RejectOnEvent before WaitForEvent\"))\n\t\treturn w\n\t}\n\thandler := func(ev ...interface{}) {\n\t\tif w.fulfilled.Load() {\n\t\t\treturn\n\t\t}\n\t\tif len(predicates) == 0 {\n\t\t\tw.reject(err)\n\t\t} else {\n\t\t\tresult := reflect.ValueOf(predicates[0]).Call([]reflect.Value{reflect.ValueOf(ev[0])})\n\t\t\tif result[0].Bool() {\n\t\t\t\tw.reject(err)\n\t\t\t}\n\t\t}\n\t}\n\temitter.On(event, handler)\n\tw.listeners = append(w.listeners, eventListener{\n\t\temitter: emitter,\n\t\tevent:   event,\n\t\thandler: handler,\n\t})\n\treturn w\n}\n\n// WithTimeout sets timeout, in milliseconds, for the waiter. 0 means no timeout.\nfunc (w *waiter) WithTimeout(timeout float64) *waiter {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tif w.waitFunc != nil {\n\t\tw.reject(fmt.Errorf(\"waiter: please set timeout before WaitForEvent\"))\n\t\treturn w\n\t}\n\tw.timeout = timeout\n\treturn w\n}\n\n// WaitForEvent sets the Waiter to return when an event occurs (and the predicate returns true)\nfunc (w *waiter) WaitForEvent(emitter EventEmitter, event string, predicate interface{}) *waiter {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\tif w.waitFunc != nil {\n\t\tw.reject(fmt.Errorf(\"waiter: WaitForEvent can only be called once\"))\n\t\treturn w\n\t}\n\tevChan := make(chan interface{}, 1)\n\thandler := w.createHandler(evChan, predicate)\n\tctx, cancel := context.WithCancel(context.Background())\n\tif w.timeout != 0 {\n\t\ttimeout := w.timeout\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-time.After(time.Duration(timeout) * time.Millisecond):\n\t\t\t\terr := fmt.Errorf(\"%w:Timeout %.2fms exceeded.\", ErrTimeout, timeout)\n\t\t\t\tw.reject(err)\n\t\t\t\treturn\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t}\n\n\temitter.On(event, handler)\n\tw.listeners = append(w.listeners, eventListener{\n\t\temitter: emitter,\n\t\tevent:   event,\n\t\thandler: handler,\n\t})\n\n\tw.waitFunc = func() (interface{}, error) {\n\t\tvar (\n\t\t\terr error\n\t\t\tval interface{}\n\t\t)\n\t\tselect {\n\t\tcase err = <-w.errChan:\n\t\t\tbreak\n\t\tcase val = <-evChan:\n\t\t\tbreak\n\t\t}\n\t\tcancel()\n\t\tw.mu.Lock()\n\t\tdefer w.mu.Unlock()\n\t\tfor _, l := range w.listeners {\n\t\t\tl.emitter.RemoveListener(l.event, l.handler)\n\t\t}\n\t\tclose(evChan)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn val, nil\n\t}\n\treturn w\n}\n\n// Wait waits for the waiter to return. It needs to call WaitForEvent once first.\nfunc (w *waiter) Wait() (interface{}, error) {\n\tif w.waitFunc == nil {\n\t\treturn nil, fmt.Errorf(\"waiter: call WaitForEvent first\")\n\t}\n\treturn w.waitFunc()\n}\n\n// RunAndWait waits for the waiter to return after calls func.\nfunc (w *waiter) RunAndWait(cb func() error) (interface{}, error) {\n\tif w.waitFunc == nil {\n\t\treturn nil, fmt.Errorf(\"waiter: call WaitForEvent first\")\n\t}\n\tif cb != nil {\n\t\tif err := cb(); err != nil {\n\t\t\tw.errChan <- err\n\t\t}\n\t}\n\treturn w.waitFunc()\n}\n\nfunc (w *waiter) createHandler(evChan chan<- interface{}, predicate interface{}) func(...interface{}) {\n\treturn func(ev ...interface{}) {\n\t\tif w.fulfilled.Load() {\n\t\t\treturn\n\t\t}\n\t\tif predicate == nil || reflect.ValueOf(predicate).IsNil() {\n\t\t\tw.fulfilled.Store(true)\n\t\t\tif len(ev) == 1 {\n\t\t\t\tevChan <- ev[0]\n\t\t\t} else {\n\t\t\t\tevChan <- nil\n\t\t\t}\n\t\t} else {\n\t\t\tresult := reflect.ValueOf(predicate).Call([]reflect.Value{reflect.ValueOf(ev[0])})\n\t\t\tif result[0].Bool() {\n\t\t\t\tw.fulfilled.Store(true)\n\t\t\t\tevChan <- ev[0]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (w *waiter) reject(err error) {\n\tw.fulfilled.Store(true)\n\tw.errChan <- err\n}\n\nfunc newWaiter() *waiter {\n\tw := &waiter{\n\t\terrChan: make(chan error, 1),\n\t}\n\treturn w\n}\n"
        },
        {
          "name": "waiter_test.go",
          "type": "blob",
          "size": 4.2080078125,
          "content": "package playwright\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\ttestEventNameFoobar = \"foobar\"\n\ttestEventNameReject = \"reject\"\n\ttestEventPayload    = \"payload data\"\n)\n\nfunc TestWaiterWaitForEvent(t *testing.T) {\n\ttimeout := 500.0\n\temitter := &eventEmitter{}\n\twaiter := newWaiter().WithTimeout(timeout)\n\t_, err := waiter.Wait()\n\trequire.Error(t, err)\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\tgo func() {\n\t\temitter.Emit(testEventNameFoobar, testEventPayload)\n\t\temitter.Emit(testEventNameFoobar, \"2\")\n\t\temitter.Emit(testEventNameFoobar, \"3\")\n\t}()\n\tresult, err := waiter.Wait()\n\trequire.NoError(t, err)\n\trequire.Equal(t, result, testEventPayload)\n}\n\nfunc TestWaiterWaitForEventWithPredicate(t *testing.T) {\n\ttimeout := 500.0\n\temitter := &eventEmitter{}\n\twaiter := newWaiter().WithTimeout(timeout)\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, func(payload interface{}) bool {\n\t\tcontent, ok := payload.(string)\n\t\tif ok && content == testEventPayload {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tgo func() {\n\t\temitter.Emit(testEventNameFoobar, \"1\")\n\t\temitter.Emit(testEventNameFoobar, testEventPayload)\n\t\temitter.Emit(testEventNameFoobar, \"3\")\n\t}()\n\tresult, err := waiter.Wait()\n\trequire.NoError(t, err)\n\trequire.Equal(t, result, testEventPayload)\n}\n\nfunc TestWaiterRejectOnTimeout(t *testing.T) {\n\ttimeout := 300.0\n\temitter := &eventEmitter{}\n\twaiter := newWaiter().WithTimeout(timeout)\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\tgo func() {\n\t\ttime.Sleep(time.Duration(timeout*2) * time.Millisecond)\n\t\temitter.Emit(testEventNameFoobar, testEventPayload)\n\t}()\n\tresult, err := waiter.Wait()\n\trequire.ErrorContains(t, err, fmt.Sprintf(\"Timeout %.2fms exceeded.\", timeout))\n\trequire.Nil(t, result)\n}\n\nfunc TestWaiterRejectOnEvent(t *testing.T) {\n\terrCause := fmt.Errorf(\"reject on event\")\n\terrPredicate := fmt.Errorf(\"payload on event\")\n\temitter := &eventEmitter{}\n\twaiter := newWaiter().RejectOnEvent(emitter, testEventNameReject, errCause)\n\twaiter.RejectOnEvent(emitter, testEventNameFoobar, errPredicate, func(payload interface{}) bool {\n\t\tcontent, ok := payload.(string)\n\t\tif ok && content == \"testEventPayload\" {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\trequire.Equal(t, 1, emitter.ListenerCount(testEventNameReject))\n\tgo func() {\n\t\temitter.Emit(testEventNameReject)\n\t\temitter.Emit(testEventNameFoobar, testEventPayload)\n\t\temitter.Emit(testEventNameFoobar, \"3\")\n\t}()\n\tresult, err := waiter.Wait()\n\trequire.EqualError(t, err, errCause.Error())\n\trequire.Equal(t, 0, emitter.ListenerCount(testEventNameReject))\n\trequire.Nil(t, result)\n}\n\nfunc TestWaiterRejectOnEventWithPredicate(t *testing.T) {\n\terrCause := fmt.Errorf(\"reject on event\")\n\terrPredicate := fmt.Errorf(\"payload on event\")\n\temitter := &eventEmitter{}\n\twaiter := newWaiter().RejectOnEvent(emitter, testEventNameReject, errCause)\n\twaiter.RejectOnEvent(emitter, testEventNameFoobar, errPredicate, func(payload interface{}) bool {\n\t\tcontent, ok := payload.(string)\n\t\tif ok && content == testEventPayload {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\trequire.Equal(t, 1, emitter.ListenerCount(testEventNameReject))\n\tgo func() {\n\t\temitter.Emit(testEventNameFoobar, testEventPayload)\n\t\temitter.Emit(testEventNameReject)\n\t\temitter.Emit(testEventNameFoobar, \"3\")\n\t}()\n\tresult, err := waiter.Wait()\n\trequire.EqualError(t, err, errPredicate.Error())\n\trequire.Equal(t, 0, emitter.ListenerCount(testEventNameReject))\n\trequire.Nil(t, result)\n}\n\nfunc TestWaiterReturnErrorWhenMisuse(t *testing.T) {\n\temitter := &eventEmitter{}\n\twaiter := newWaiter()\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\twaiter.WithTimeout(500)\n\t_, err := waiter.Wait()\n\trequire.ErrorContains(t, err, \"please set timeout before WaitForEvent\")\n\n\twaiter = newWaiter()\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\twaiter.WaitForEvent(emitter, testEventNameFoo, nil)\n\t_, err = waiter.Wait()\n\trequire.ErrorContains(t, err, \"WaitForEvent can only be called once\")\n\n\twaiter = newWaiter()\n\twaiter.WaitForEvent(emitter, testEventNameFoobar, nil)\n\twaiter.RejectOnEvent(emitter, testEventNameFoo, nil)\n\t_, err = waiter.Wait()\n\trequire.ErrorContains(t, err, \"call RejectOnEvent before WaitForEvent\")\n}\n"
        },
        {
          "name": "web_error.go",
          "type": "blob",
          "size": 0.2822265625,
          "content": "package playwright\n\ntype webErrorImpl struct {\n\terr  error\n\tpage Page\n}\n\nfunc (e *webErrorImpl) Page() Page {\n\treturn e.page\n}\n\nfunc (e *webErrorImpl) Error() error {\n\treturn e.err\n}\n\nfunc newWebError(page Page, err error) WebError {\n\treturn &webErrorImpl{\n\t\terr:  err,\n\t\tpage: page,\n\t}\n}\n"
        },
        {
          "name": "websocket.go",
          "type": "blob",
          "size": 3.421875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n)\n\ntype webSocketImpl struct {\n\tchannelOwner\n\tisClosed bool\n\tpage     *pageImpl\n}\n\nfunc (ws *webSocketImpl) URL() string {\n\treturn ws.initializer[\"url\"].(string)\n}\n\nfunc newWebsocket(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *webSocketImpl {\n\tws := &webSocketImpl{}\n\tws.createChannelOwner(ws, parent, objectType, guid, initializer)\n\tws.page = fromChannel(parent.channel).(*pageImpl)\n\tws.channel.On(\"close\", func() {\n\t\tws.Lock()\n\t\tws.isClosed = true\n\t\tws.Unlock()\n\t\tws.Emit(\"close\", ws)\n\t})\n\tws.channel.On(\n\t\t\"frameSent\",\n\t\tfunc(params map[string]interface{}) {\n\t\t\tws.onFrameSent(params[\"opcode\"].(float64), params[\"data\"].(string))\n\t\t},\n\t)\n\tws.channel.On(\n\t\t\"frameReceived\",\n\t\tfunc(params map[string]interface{}) {\n\t\t\tws.onFrameReceived(params[\"opcode\"].(float64), params[\"data\"].(string))\n\t\t},\n\t)\n\tws.channel.On(\n\t\t\"socketError\",\n\t\tfunc(params map[string]interface{}) {\n\t\t\tws.Emit(\"socketerror\", params[\"error\"])\n\t\t},\n\t)\n\treturn ws\n}\n\nfunc (ws *webSocketImpl) onFrameSent(opcode float64, data string) {\n\tif opcode == 2 {\n\t\tpayload, err := base64.StdEncoding.DecodeString(data)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"could not decode WebSocket.onFrameSent payload\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t\tws.Emit(\"framesent\", payload)\n\t} else {\n\t\tws.Emit(\"framesent\", []byte(data))\n\t}\n}\n\nfunc (ws *webSocketImpl) onFrameReceived(opcode float64, data string) {\n\tif opcode == 2 {\n\t\tpayload, err := base64.StdEncoding.DecodeString(data)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"could not decode WebSocket.onFrameReceived payload\", \"error\", err)\n\t\t\treturn\n\t\t}\n\t\tws.Emit(\"framereceived\", payload)\n\t} else {\n\t\tws.Emit(\"framereceived\", []byte(data))\n\t}\n}\n\nfunc (ws *webSocketImpl) ExpectEvent(event string, cb func() error, options ...WebSocketExpectEventOptions) (interface{}, error) {\n\treturn ws.expectEvent(event, cb, options...)\n}\n\nfunc (ws *webSocketImpl) WaitForEvent(event string, options ...WebSocketWaitForEventOptions) (interface{}, error) {\n\tif len(options) == 1 {\n\t\toption := WebSocketExpectEventOptions(options[0])\n\t\treturn ws.expectEvent(event, nil, option)\n\t} else {\n\t\treturn ws.expectEvent(event, nil)\n\t}\n}\n\nfunc (ws *webSocketImpl) expectEvent(event string, cb func() error, options ...WebSocketExpectEventOptions) (interface{}, error) {\n\tvar predicate interface{} = nil\n\ttimeout := ws.page.timeoutSettings.Timeout()\n\tif len(options) == 1 {\n\t\tif options[0].Timeout != nil {\n\t\t\ttimeout = *options[0].Timeout\n\t\t}\n\t\tif options[0].Predicate != nil {\n\t\t\tpredicate = options[0].Predicate\n\t\t}\n\t}\n\twaiter := newWaiter().WithTimeout(timeout)\n\tif event != \"close\" {\n\t\twaiter.RejectOnEvent(ws, \"close\", errors.New(\"websocket closed\"))\n\t}\n\tif event != \"socketerror\" {\n\t\twaiter.RejectOnEvent(ws, \"socketerror\", errors.New(\"websocket error\"))\n\t}\n\twaiter.RejectOnEvent(ws.page, \"close\", errors.New(\"page closed\"))\n\tif cb == nil {\n\t\treturn waiter.WaitForEvent(ws, event, predicate).Wait()\n\t} else {\n\t\treturn waiter.WaitForEvent(ws, event, predicate).RunAndWait(cb)\n\t}\n}\n\nfunc (ws *webSocketImpl) IsClosed() bool {\n\tws.RLock()\n\tdefer ws.RUnlock()\n\treturn ws.isClosed\n}\n\nfunc (ws *webSocketImpl) OnClose(fn func(WebSocket)) {\n\tws.On(\"close\", fn)\n}\n\nfunc (ws *webSocketImpl) OnFrameReceived(fn func(payload []byte)) {\n\tws.On(\"framereceived\", fn)\n}\n\nfunc (ws *webSocketImpl) OnFrameSent(fn func(payload []byte)) {\n\tws.On(\"framesent\", fn)\n}\n\nfunc (ws *webSocketImpl) OnSocketError(fn func(string)) {\n\tws.On(\"socketerror\", fn)\n}\n"
        },
        {
          "name": "websocket_route.go",
          "type": "blob",
          "size": 6.0810546875,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"sync/atomic\"\n)\n\ntype webSocketRouteImpl struct {\n\tchannelOwner\n\tconnected       *atomic.Bool\n\tserver          WebSocketRoute\n\tonPageMessage   func(interface{})\n\tonPageClose     func(code *int, reason *string)\n\tonServerMessage func(interface{})\n\tonServerClose   func(code *int, reason *string)\n}\n\nfunc newWebSocketRoute(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *webSocketRouteImpl {\n\troute := &webSocketRouteImpl{\n\t\tconnected: &atomic.Bool{},\n\t}\n\troute.createChannelOwner(route, parent, objectType, guid, initializer)\n\troute.markAsInternalType()\n\n\troute.server = newServerWebSocketRoute(route)\n\n\troute.channel.On(\"messageFromPage\", func(event map[string]interface{}) {\n\t\tmsg, err := untransformWebSocketMessage(event)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf(\"Could not decode WebSocket message: %w\", err))\n\t\t}\n\t\tif route.onPageMessage != nil {\n\t\t\troute.onPageMessage(msg)\n\t\t} else if route.connected.Load() {\n\t\t\tgo route.channel.SendNoReply(\"sendToServer\", event)\n\t\t}\n\t})\n\n\troute.channel.On(\"messageFromServer\", func(event map[string]interface{}) {\n\t\tmsg, err := untransformWebSocketMessage(event)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf(\"Could not decode WebSocket message: %w\", err))\n\t\t}\n\t\tif route.onServerMessage != nil {\n\t\t\troute.onServerMessage(msg)\n\t\t} else {\n\t\t\tgo route.channel.SendNoReply(\"sendToPage\", event)\n\t\t}\n\t})\n\n\troute.channel.On(\"closePage\", func(event map[string]interface{}) {\n\t\tif route.onPageClose != nil {\n\t\t\troute.onPageClose(event[\"code\"].(*int), event[\"reason\"].(*string))\n\t\t} else {\n\t\t\tgo route.channel.SendNoReply(\"closeServer\", event)\n\t\t}\n\t})\n\n\troute.channel.On(\"closeServer\", func(event map[string]interface{}) {\n\t\tif route.onServerClose != nil {\n\t\t\troute.onServerClose(event[\"code\"].(*int), event[\"reason\"].(*string))\n\t\t} else {\n\t\t\tgo route.channel.SendNoReply(\"closePage\", event)\n\t\t}\n\t})\n\n\treturn route\n}\n\nfunc (r *webSocketRouteImpl) Close(options ...WebSocketRouteCloseOptions) {\n\tr.channel.SendNoReply(\"closePage\", options, map[string]interface{}{\"wasClean\": true})\n}\n\nfunc (r *webSocketRouteImpl) ConnectToServer() (WebSocketRoute, error) {\n\tif r.connected.Load() {\n\t\treturn nil, fmt.Errorf(\"Already connected to the server\")\n\t}\n\tr.channel.SendNoReply(\"connect\")\n\tr.connected.Store(true)\n\treturn r.server, nil\n}\n\nfunc (r *webSocketRouteImpl) OnClose(handler func(code *int, reason *string)) {\n\tr.onPageClose = handler\n}\n\nfunc (r *webSocketRouteImpl) OnMessage(handler func(interface{})) {\n\tr.onPageMessage = handler\n}\n\nfunc (r *webSocketRouteImpl) Send(message interface{}) {\n\tdata, err := transformWebSocketMessage(message)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"Could not encode WebSocket message: %w\", err))\n\t}\n\tgo r.channel.SendNoReply(\"sendToPage\", data)\n}\n\nfunc (r *webSocketRouteImpl) URL() string {\n\treturn r.initializer[\"url\"].(string)\n}\n\nfunc (r *webSocketRouteImpl) afterHandle() error {\n\tif r.connected.Load() {\n\t\treturn nil\n\t}\n\t// Ensure that websocket is \"open\" and can send messages without an actual server connection.\n\t_, err := r.channel.Send(\"ensureOpened\")\n\treturn err\n}\n\ntype serverWebSocketRouteImpl struct {\n\twebSocketRoute *webSocketRouteImpl\n}\n\nfunc newServerWebSocketRoute(route *webSocketRouteImpl) *serverWebSocketRouteImpl {\n\treturn &serverWebSocketRouteImpl{webSocketRoute: route}\n}\n\nfunc (s *serverWebSocketRouteImpl) OnMessage(handler func(interface{})) {\n\ts.webSocketRoute.onServerMessage = handler\n}\n\nfunc (s *serverWebSocketRouteImpl) OnClose(handler func(code *int, reason *string)) {\n\ts.webSocketRoute.onServerClose = handler\n}\n\nfunc (s *serverWebSocketRouteImpl) ConnectToServer() (WebSocketRoute, error) {\n\treturn nil, fmt.Errorf(\"ConnectToServer must be called on the page-side WebSocketRoute\")\n}\n\nfunc (s *serverWebSocketRouteImpl) URL() string {\n\treturn s.webSocketRoute.URL()\n}\n\nfunc (s *serverWebSocketRouteImpl) Close(options ...WebSocketRouteCloseOptions) {\n\tgo s.webSocketRoute.channel.SendNoReply(\"close\", options, map[string]interface{}{\"wasClean\": true})\n}\n\nfunc (s *serverWebSocketRouteImpl) Send(message interface{}) {\n\tdata, err := transformWebSocketMessage(message)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"Could not encode WebSocket message: %w\", err))\n\t}\n\tgo s.webSocketRoute.channel.SendNoReply(\"sendToServer\", data)\n}\n\nfunc transformWebSocketMessage(message interface{}) (map[string]interface{}, error) {\n\tdata := map[string]interface{}{}\n\tswitch v := message.(type) {\n\tcase []byte:\n\t\tdata[\"isBase64\"] = true\n\t\tdata[\"message\"] = base64.StdEncoding.EncodeToString(v)\n\tcase string:\n\t\tdata[\"isBase64\"] = false\n\t\tdata[\"message\"] = v\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"Unsupported message type: %T\", v)\n\t}\n\treturn data, nil\n}\n\nfunc untransformWebSocketMessage(data map[string]interface{}) (interface{}, error) {\n\tif data[\"isBase64\"].(bool) {\n\t\treturn base64.StdEncoding.DecodeString(data[\"message\"].(string))\n\t}\n\treturn data[\"message\"], nil\n}\n\ntype webSocketRouteHandler struct {\n\tmatcher *urlMatcher\n\thandler func(WebSocketRoute)\n}\n\nfunc newWebSocketRouteHandler(matcher *urlMatcher, handler func(WebSocketRoute)) *webSocketRouteHandler {\n\treturn &webSocketRouteHandler{matcher: matcher, handler: handler}\n}\n\nfunc (h *webSocketRouteHandler) Handle(route WebSocketRoute) {\n\th.handler(route)\n\terr := route.(*webSocketRouteImpl).afterHandle()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"Could not handle WebSocketRoute: %w\", err))\n\t}\n}\n\nfunc (h *webSocketRouteHandler) Matches(wsURL string) bool {\n\treturn h.matcher.Matches(wsURL)\n}\n\nfunc prepareWebSocketRouteHandlerInterceptionPatterns(handlers []*webSocketRouteHandler) []map[string]interface{} {\n\tpatterns := []map[string]interface{}{}\n\tall := false\n\tfor _, handler := range handlers {\n\t\tswitch handler.matcher.raw.(type) {\n\t\tcase *regexp.Regexp:\n\t\t\tpattern, flags := convertRegexp(handler.matcher.raw.(*regexp.Regexp))\n\t\t\tpatterns = append(patterns, map[string]interface{}{\n\t\t\t\t\"regexSource\": pattern,\n\t\t\t\t\"regexFlags\":  flags,\n\t\t\t})\n\t\tcase string:\n\t\t\tpatterns = append(patterns, map[string]interface{}{\n\t\t\t\t\"glob\": handler.matcher.raw.(string),\n\t\t\t})\n\t\tdefault:\n\t\t\tall = true\n\t\t}\n\t}\n\tif all {\n\t\treturn []map[string]interface{}{\n\t\t\t{\n\t\t\t\t\"glob\": \"**/*\",\n\t\t\t},\n\t\t}\n\t}\n\treturn patterns\n}\n"
        },
        {
          "name": "worker.go",
          "type": "blob",
          "size": 1.8671875,
          "content": "package playwright\n\ntype workerImpl struct {\n\tchannelOwner\n\tpage    *pageImpl\n\tcontext *browserContextImpl\n}\n\nfunc (w *workerImpl) URL() string {\n\treturn w.initializer[\"url\"].(string)\n}\n\nfunc (w *workerImpl) Evaluate(expression string, options ...interface{}) (interface{}, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := w.channel.Send(\"evaluateExpression\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parseResult(result), nil\n}\n\nfunc (w *workerImpl) EvaluateHandle(expression string, options ...interface{}) (JSHandle, error) {\n\tvar arg interface{}\n\tif len(options) == 1 {\n\t\targ = options[0]\n\t}\n\tresult, err := w.channel.Send(\"evaluateExpressionHandle\", map[string]interface{}{\n\t\t\"expression\": expression,\n\t\t\"arg\":        serializeArgument(arg),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn fromChannel(result).(*jsHandleImpl), nil\n}\n\nfunc (w *workerImpl) onClose() {\n\tif w.page != nil {\n\t\tw.page.Lock()\n\t\tworkers := make([]Worker, 0)\n\t\tfor i := 0; i < len(w.page.workers); i++ {\n\t\t\tif w.page.workers[i] != w {\n\t\t\t\tworkers = append(workers, w.page.workers[i])\n\t\t\t}\n\t\t}\n\t\tw.page.workers = workers\n\t\tw.page.Unlock()\n\t}\n\tif w.context != nil {\n\t\tw.context.Lock()\n\t\tworkers := make([]Worker, 0)\n\t\tfor i := 0; i < len(w.context.serviceWorkers); i++ {\n\t\t\tif w.context.serviceWorkers[i] != w {\n\t\t\t\tworkers = append(workers, w.context.serviceWorkers[i])\n\t\t\t}\n\t\t}\n\t\tw.context.serviceWorkers = workers\n\t\tw.context.Unlock()\n\t}\n\tw.Emit(\"close\", w)\n}\n\nfunc (w *workerImpl) OnClose(fn func(Worker)) {\n\tw.On(\"close\", fn)\n}\n\nfunc newWorker(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *workerImpl {\n\tbt := &workerImpl{}\n\tbt.createChannelOwner(bt, parent, objectType, guid, initializer)\n\tbt.channel.On(\"close\", bt.onClose)\n\treturn bt\n}\n"
        },
        {
          "name": "writable_stream.go",
          "type": "blob",
          "size": 0.8486328125,
          "content": "package playwright\n\nimport (\n\t\"encoding/base64\"\n\t\"io\"\n\t\"os\"\n)\n\ntype writableStream struct {\n\tchannelOwner\n}\n\nfunc (s *writableStream) Copy(file string) error {\n\tf, err := os.OpenFile(file, os.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tfor {\n\t\tbuf := make([]byte, defaultCopyBufSize)\n\t\tn, err := f.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\t_, err = s.channel.Send(\"write\", map[string]interface{}{\n\t\t\t\"binary\": base64.StdEncoding.EncodeToString(buf[:n]),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t_, err = s.channel.Send(\"close\")\n\treturn err\n}\n\nfunc newWritableStream(parent *channelOwner, objectType string, guid string, initializer map[string]interface{}) *writableStream {\n\tstream := &writableStream{}\n\tstream.createChannelOwner(stream, parent, objectType, guid, initializer)\n\treturn stream\n}\n"
        }
      ]
    }
  ]
}