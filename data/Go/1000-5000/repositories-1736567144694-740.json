{
  "metadata": {
    "timestamp": 1736567144694,
    "page": 740,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gavv/httpexpect",
      "stars": 2580,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0234375,
          "content": "TODO.org\nvendor/\n.idea/\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.43359375,
          "content": "linters:\n  enable:\n    - govet\n    - revive\n    - staticcheck\n    - exhaustive\n    - exportloopref\n    - lll\n    - misspell\n    - dupword\n  disable:\n    - gosimple\n    - unused\n\nlinters-settings:\n  lll:\n    line-length: 90\n  revive:\n    rules:\n      - name: unused-parameter\n        disabled: true\n\nissues:\n  exclude-rules:\n    - text: error-strings\n      linters:\n        - revive\n    - text: indent-error-flow\n      linters:\n        - revive\n"
        },
        {
          "name": ".ignore",
          "type": "blob",
          "size": 0.05078125,
          "content": "assertiontype_string.go\nassertionseverity_string.go\n"
        },
        {
          "name": ".spelling",
          "type": "blob",
          "size": 0.2001953125,
          "content": "auth\nchainable\ncolor\nconfig\ndatetime\ndialer\ngofmt\ngolang\ngolangci-lint\ngo.mod\ngopkg.in\nHACKING.md\nhttpexpect\njsonpath\nliberapay\nlinters\nmultipart\noauth2\npkg.go.dev\nstandalone\ntyranron\nurlencoded\nwebsocket\n"
        },
        {
          "name": "HACKING.md",
          "type": "blob",
          "size": 7.6611328125,
          "content": "# Hacking guidelines\n\n<!-- toc -->\n\n- [Working on a task](#working-on-a-task)\n  * [Choosing a task](#choosing-a-task)\n  * [Creating pull request](#creating-pull-request)\n- [Developer instructions](#developer-instructions)\n  * [Development dependencies](#development-dependencies)\n  * [Makefile targets](#makefile-targets)\n- [Code style](#code-style)\n  * [Comment formatting](#comment-formatting)\n- [Project internals](#project-internals)\n  * [Object tree](#object-tree)\n  * [Failure reporting](#failure-reporting)\n\n<!-- tocstop -->\n\n## Working on a task\n\n### Choosing a task\n\nChoosing a task is easy:\n\n* Find a free task with **help wanted** or **good first issue** tag. The latter means that the task does not require deep knowldge of the project.\n\n* **Leave a comment** in the task, indicating that you want to work on it. This allows to assign you to the task and to ensure that others wont work on it on the same time.\n\n### Creating pull request\n\nPlease follow a few simple rules to ease the work of the reviewer:\n\n* Add a **link to the task** in pull request description.\n\n* Until pull request is ready to be merged, use GitHub **draft** feature.\n\n* If you want pull request to be reviewed (no matter is it draft or not), use GitHub **request review** feature.\n\n* When you submit changes after review, don't forget to **re-request review**.\n\n* When you adderess issues raised during review, **don't resolve discussions by yourself**. Instead, leave a comment or thumbs up on that discussion.\n\n## Developer instructions\n\n### Development dependencies\n\nFor development, you need two additional dependencies:\n\n* [golangci-lint](https://golangci-lint.run/welcome/install/#local-installation)\n\n* [stringer](https://github.com/golang/tools)\n\n    `go install golang.org/x/tools/cmd/stringer@latest`\n\n### Makefile targets\n\nRe-generate, build, lint, and test everything:\n\n```\nmake\n```\n\nRun tests:\n\n```\nmake test\n```\n\nRun only short tests:\n\n```\nmake short\n```\n\nRun gofmt:\n\n```\nmake fmt\n```\n\nRun go generate:\n\n```\nmake gen\n```\n\nRun go mod tidy:\n\n```\nmake tidy\n```\n\nGenerate TOC in HACKING.md:\n\n```\nmake toc\n```\n\n## Code style\n\n### Comment formatting\n\nExported functions should have documentation comments, formatted as follows:\n\n* short function description, indented with one SPACE\n* empty line\n* optional details, indented with one SPACE\n* empty line\n* `Example:` line, indented with one SPACE\n* empty line\n* example code, indented with one TAB\n* no more empty lines\n\n**GOOD:**\n\n```go\n// Short function description.\n//\n// Optional details, probably multiple\n// lines or paragraphs.\n//\n// Example:\n//\n//\texampleCode()\nfunc MyFunction() { ... }\n```\n\n**BAD:** no space after `//`:\n\n```go\n//Short function description.\n//\n// Example:\n//\n//\texampleCode()\nfunc MyFunction() { ... }\n```\n\n**BAD:** missing empty line before `Example:`\n\n```go\n// Short function description.\n// Example:\n//\n//\texampleCode()\nfunc MyFunction() { ... }\n```\n\n**BAD:** missing empty line after `Example:`\n\n```go\n// Short function description.\n//\n// Example:\n//\texampleCode()\nfunc MyFunction() { ... }\n```\n\n**BAD:** forgetting to indent example code:\n\n```go\n// Short function description.\n//\n// Example:\n//\n// exampleCode()\nfunc MyFunction() { ... }\n```\n\n**BAD:** using spaces instead of TAB to indent example code:\n\n```go\n// Short function description.\n//\n// Example:\n//\n//  exampleCode()\nfunc MyFunction() { ... }\n```\n\n**BAD:** extra empty line between comment and function:\n\n```go\n// Short function description.\n//\n// Example:\n//\n//\texampleCode()\n\nfunc MyFunction() { ... }\n```\n\n## Project internals\n\n### Object tree\n\nThe typical user workflow looks like this:\n\n* create `Expect` instance (root object) using `httpexpect.Default` or `httpexpect.WithConfig`\n* use `Expect` methods to create `Request` instance (HTTP request builder)\n* use `Request` methods to configure HTTP request (e.g. `WithHeader`, `WithText`)\n* use `Request.Expect()` method to send HTTP request and receive HTTP response; the method returns `Response` instance (HTTP response matcher)\n* use `Response` methods to make assertions on HTTP response\n* use `Response` methods to create child matcher objects for HTTP response payload (e.g. `Response.Headers()` or `Response.Body()`)\n* use methods of matcher objects to make assertions on payload, or to create nested child matcher objects\n\nAll objects described above are linked into a tree using `chain` struct:\n\n* every object has `chain` field\n* when a child object is created (e.g. `Expect` creates `Request`, `Request` creates `Response`, and so on), the child object clones `chain` of its parent and stores it inside its `chain` field\n* when an object performs an assertion (e.g. user calls `IsEqual`), it creates a temporary clone of its `chain` and uses it to report failure or success\n\n`chain` maintains context needed to report succeeded or failed assertions:\n\n* `AssertionContext` defines *where* the assertion happens: path to the assertion in object tree, pointer to current request and response, etc.\n* `AssertionHandler` defines *what* to do in response to success or failure\n* `AssertionSeverity` defines *how* to treat failures, either as fatal or non-fatal\n\nThese fields are inherited by child `chain` when it is cloned.\n\nIn addition, `chain` maintains a reference to its parent and flags indicating whether a failure happened on the `chain` or any of its children.\n\nWhen success or failure is reported, the following happens:\n\n* `chain` invokes `AssertionHandler` and passes `AssertionContext` and `AssertionFailure` to it\n* in case of failure, `chain` raises a flag on itself, indicating failure\n* in case of failure, `chain` raises a flag on its parents and garndparents (up to the tree root), indicating that their children have failures (this feature is rarely used)\n\nThese failure flags are then used to ignore all subsequent assertions on a failed branch of the object tree. For example, if you run this code:\n\n```go\ne.GET(\"/test\").Expect().Status(http.StatusOK).Body().IsObject()\n```\n\nand if `Status()` assertion failed, then this branch of the tree will be marked as failed, and calls to `Body()` and `IsObject()` will be just ignored. This is achieved by inheriting failure flag when cloning `chain`, and checking this flag in every assertion.\n\n### Failure reporting\n\n`AssertionHandler` is an interface that is used to handle every succeeded or failed assertion (like `IsEqual`).\n\nIt can be implemented by user if the user needs very precise control on assertion handling. In most cases, however, user does not need it, and just uses `DefaultAssertionHandler` implementation, which does the following:\n\n* pass `AssertionContext` and `AssertionFailure` to `Formatter`, to get formatted message\n* when reporting failed assertion, pass formatted message to `Reporter`\n* when reporting succeeded assertion, pass formatted message to `Logger`\n\n`Formatter`, `Reporter`, and `Logger` are also interfaces that can be implemented by user. Again, in most cases user can use one of the available implementations:\n\n* `DefaultFormatter` for `Formatter`\n* `testing.T`, `FatalReporter`, `AssertReporter`, or `RequireReporter` for `Reporter`\n* `testing.T` for `Logger`\n\nIn most cases, all the user needs to do is to select which reporter to use: `testing.T` or `FatalReporter` for non-fatal and fatal failure reports using standard `testing` package, and `AssertReporter` or `RequireReporter` for non-fatal and fatal failure reports using `testify` package (which adds nice backtrace and indentation).\n\nFor the rest, we will automatically employ default implementations (`DefaultFormatter`, `DefaultAssertionHandler`).\n\nNote that `Formatter`, `Reporter`, and `Logger` are used only by `DefaultAssertionHandler`. If the user provides custom `AssertionHandler`, that implementation is free to ignore these three interfaces and can do whatever it wants.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.072265625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Victor Gaydov and contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.8369140625,
          "content": "all: tidy gen build lint test spell\n\ntidy:\n\tgo mod tidy -v\n\tcd _examples && go get -v -u github.com/gavv/httpexpect/v2\n\tcd _examples && go mod tidy -v -compat=1.17\n\ngen:\n\tgo generate ./...\n\nfmt:\n\tgofmt -s -w . ./e2e ./_examples\nifneq (,$(findstring GNU,$(shell sed --version)))\n\tsed -r -e ':loop' -e 's,^(//\\t+)    ,\\1\\t,g' -e 't loop' -i *.go e2e/*.go _examples/*.go\nendif\n\nbuild:\n\tgo build ./...\n\tcd _examples && go build\n\nlint:\n\tgolangci-lint run ./...\n\tcd _examples && golangci-lint run .\n\ntest:\nifneq ($(shell which gotest),)\n\tgotest ./...\n\tcd _examples && gotest\nelse\n\tgo test ./...\n\tcd _examples && go test\nendif\n\nshort:\nifneq ($(shell which gotest),)\n\tgotest -short ./...\nelse\n\tgo test -short ./...\nendif\n\nspell:\nifneq ($(shell which mdspell),)\n\tmdspell -a README.md\n\tsort .spelling -o .spelling\nendif\n\ntoc:\n\tmarkdown-toc --maxdepth 3 -i HACKING.md\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 21.8623046875,
          "content": "![](_images/logo.png)\n\n# httpexpect [![GoDev](https://img.shields.io/badge/go.dev-reference-007d9c?logo=go&logoColor=white)](https://pkg.go.dev/github.com/gavv/httpexpect/v2) [![Build](https://github.com/gavv/httpexpect/workflows/build/badge.svg)](https://github.com/gavv/httpexpect/actions) [![Coveralls](https://coveralls.io/repos/github/gavv/httpexpect/badge.svg?branch=master)](https://coveralls.io/github/gavv/httpexpect?branch=master) [![GitHub release](https://img.shields.io/github/tag/gavv/httpexpect.svg)](https://github.com/gavv/httpexpect/releases) [![Discord](https://img.shields.io/discord/1047473005900615780?logo=discord&label=discord&color=blueviolet&logoColor=white)](https://discord.gg/5SCPCuCWA9)\n\nConcise, declarative, and easy to use end-to-end HTTP and REST API testing for Go (golang).\n\nBasically, httpexpect is a set of chainable *builders* for HTTP requests and *assertions* for HTTP responses and payload, on top of net/http and several utility packages.\n\nWorkflow:\n\n* Incrementally build HTTP requests.\n* Inspect HTTP responses.\n* Inspect response payload recursively.\n\n## Features\n\n##### Request builder\n\n* URL path construction, with simple string interpolation provided by [`go-interpol`](https://github.com/imkira/go-interpol) package.\n* URL query parameters (encoding using [`go-querystring`](https://github.com/google/go-querystring) package).\n* Headers, cookies, payload: JSON,  urlencoded or multipart forms (encoding using [`form`](https://github.com/ajg/form) package), plain text.\n* Custom reusable [request builders](#reusable-builders) and [request transformers](#request-transformers).\n\n##### Response assertions\n\n* Response status, predefined status ranges.\n* Headers, cookies, payload: JSON, JSONP, forms, text.\n* Round-trip time.\n* Custom reusable [response matchers](#reusable-matchers).\n\n##### Payload assertions\n\n* Type-specific assertions, supported types: object, array, string, number, boolean, null, datetime.\n* Regular expressions.\n* Simple JSON queries (using subset of [JSONPath](http://goessner.net/articles/JsonPath/)), provided by [`jsonpath`](https://github.com/yalp/jsonpath) package.\n* [JSON Schema](http://json-schema.org/) validation, provided by [`gojsonschema`](https://github.com/xeipuuv/gojsonschema) package.\n\n##### WebSocket support (thanks to [@tyranron](https://github.com/tyranron))\n\n* Upgrade an HTTP connection to a WebSocket connection (we use [`gorilla/websocket`](https://github.com/gorilla/websocket) internally).\n* Interact with the WebSocket server.\n* Inspect WebSocket connection parameters and WebSocket messages.\n\n##### Pretty printing\n\n* Verbose error messages.\n* JSON diff is produced on failure using [`gojsondiff`](https://github.com/yudai/gojsondiff/) package.\n* Failures are reported using [`testify`](https://github.com/stretchr/testify/) (`assert` or `require` package) or standard `testing` package.\n* JSON values are pretty-printed using `encoding/json`, Go values are pretty-printed using [`litter`](https://github.com/sanity-io/litter).\n* Dumping requests and responses in various formats, using [`httputil`](https://golang.org/pkg/net/http/httputil/), [`http2curl`](https://github.com/moul/http2curl), or simple compact logger.\n* Color support using [`fatih/color`](https://github.com/fatih/color).\n\n##### Tuning\n\n* Tests can communicate with server via real HTTP client or invoke `net/http` or [`fasthttp`](https://github.com/valyala/fasthttp/) handler directly.\n* User can provide custom HTTP client, WebSocket dialer, HTTP request factory (e.g. from the Google App Engine testing).\n* User can configure formatting options or provide custom templates based on `text/template` engine.\n* Custom handlers may be provided for logging, printing requests and responses, handling succeeded and failed assertions.\n\n## Versions\n\nThe versions are selected according to the [semantic versioning](https://semver.org/) scheme. Every new major version gets its own stable branch with a backwards compatibility promise. Releases are tagged from stable branches.\n\nThe current stable branch is `v2`. Previous branches are still maintained, but no new features are added.\n\nIf you're using go.mod, use a versioned import path:\n\n```go\nimport \"github.com/gavv/httpexpect/v2\"\n```\n\nOtherwise, use gopkg.in import path:\n\n```go\nimport \"gopkg.in/gavv/httpexpect.v2\"\n```\n\n## Documentation\n\nDocumentation is available on [pkg.go.dev](https://pkg.go.dev/github.com/gavv/httpexpect/v2#section-documentation). It contains an overview and reference.\n\n## Community\n\nCommunity forum and Q&A board is right on GitHub in [discussions tab](https://github.com/gavv/httpexpect/discussions).\n\nFor more interactive discussion, you can join [discord chat](https://discord.gg/5SCPCuCWA9).\n\n## Contributing\n\nFeel free to report bugs, suggest improvements, and send pull requests! Please add documentation and tests for new features.\n\nThis project highly depends on contributors. Thank you all for your amazing work!\n\nIf you would like to submit code, see [HACKING.md](HACKING.md).\n\n## Donating\n\nIf you would like to support my open-source work, you can do it here:\n\n* [Liberapay](https://liberapay.com/gavv)\n* [PayPal](https://www.paypal.com/paypalme/victorgaydov)\n\nThanks!\n\n## Examples\n\nSee [`_examples`](_examples) directory for complete standalone examples.\n\n* [`fruits_test.go`](_examples/fruits_test.go)\n\n    Testing a simple CRUD server made with bare `net/http`.\n\n* [`iris_test.go`](_examples/iris_test.go)\n\n    Testing a server made with [`iris`](https://github.com/kataras/iris/) framework. Example includes JSON queries and validation, URL and form parameters, basic auth, sessions, and streaming. Tests invoke the `http.Handler` directly.\n\n* [`echo_test.go`](_examples/echo_test.go)\n\n    Testing a server with JWT authentication made with [`echo`](https://github.com/labstack/echo/) framework. Tests use either HTTP client or invoke the `http.Handler` directly.\n\n* [`gin_test.go`](_examples/gin_test.go)\n\n    Testing a server utilizing the [`gin`](https://github.com/gin-gonic/gin) web framework. Tests invoke the `http.Handler` directly.\n\n* [`fasthttp_test.go`](_examples/fasthttp_test.go)\n\n    Testing a server made with [`fasthttp`](https://github.com/valyala/fasthttp) package. Tests invoke the `fasthttp.RequestHandler` directly.\n\n* [`websocket_test.go`](_examples/websocket_test.go)\n\n    Testing a WebSocket server based on [`gorilla/websocket`](https://github.com/gorilla/websocket). Tests invoke the `http.Handler` or `fasthttp.RequestHandler` directly.\n\n* [`oauth2_test.go`](_examples/oauth2_test.go)\n\n  Testing a OAuth2 server with [`oauth2`](https://github.com/go-oauth2/oauth2/).\n\n* [`gae_test.go`](_examples/gae_test.go)\n\n    Testing a server running under the [Google App Engine](https://en.wikipedia.org/wiki/Google_App_Engine).\n\n* [`formatter_test.go`](_examples/formatter_test.go)\n\n    Testing with custom formatter for assertion messages.\n\n## Quick start\n\n##### Hello, world!\n\n```go\npackage example\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gavv/httpexpect/v2\"\n)\n\nfunc TestFruits(t *testing.T) {\n\t// create http.Handler\n\thandler := FruitsHandler()\n\n\t// run server using httptest\n\tserver := httptest.NewServer(handler)\n\tdefer server.Close()\n\n\t// create httpexpect instance\n\te := httpexpect.Default(t, server.URL)\n\n\t// is it working?\n\te.GET(\"/fruits\").\n\t\tExpect().\n\t\tStatus(http.StatusOK).JSON().Array().IsEmpty()\n}\n```\n\n##### JSON\n\n```go\norange := map[string]interface{}{\n\t\"weight\": 100,\n}\n\ne.PUT(\"/fruits/orange\").WithJSON(orange).\n\tExpect().\n\tStatus(http.StatusNoContent).NoContent()\n\ne.GET(\"/fruits/orange\").\n\tExpect().\n\tStatus(http.StatusOK).\n\tJSON().Object().ContainsKey(\"weight\").HasValue(\"weight\", 100)\n\napple := map[string]interface{}{\n\t\"colors\": []interface{}{\"green\", \"red\"},\n\t\"weight\": 200,\n}\n\ne.PUT(\"/fruits/apple\").WithJSON(apple).\n\tExpect().\n\tStatus(http.StatusNoContent).NoContent()\n\nobj := e.GET(\"/fruits/apple\").\n\tExpect().\n\tStatus(http.StatusOK).JSON().Object()\n\nobj.Keys().ContainsOnly(\"colors\", \"weight\")\n\nobj.Value(\"colors\").Array().ConsistsOf(\"green\", \"red\")\nobj.Value(\"colors\").Array().Value(0).String().IsEqual(\"green\")\nobj.Value(\"colors\").Array().Value(1).String().IsEqual(\"red\")\nobj.Value(\"colors\").Array().First().String().IsEqual(\"green\")\nobj.Value(\"colors\").Array().Last().String().IsEqual(\"red\")\n```\n\n##### JSON Schema and JSON Path\n\n```go\nschema := `{\n\t\"type\": \"array\",\n\t\"items\": {\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t...\n\t\t\t\"private\": {\n\t\t\t\t\"type\": \"boolean\"\n\t\t\t}\n\t\t}\n\t}\n}`\n\nrepos := e.GET(\"/repos/octocat\").\n\tExpect().\n\tStatus(http.StatusOK).JSON()\n\n// validate JSON schema\nrepos.Schema(schema)\n\n// run JSONPath query and iterate results\nfor _, private := range repos.Path(\"$..private\").Array().Iter() {\n\tprivate.Boolean().IsFalse()\n}\n```\n\n##### JSON decoding\n\n```go\ntype User struct {\n\tName   string `json:\"name\"`\n\tAge    int    `json:\"age\"`\n\tGender string `json:\"gender\"`\n}\n\nvar user User\ne.GET(\"/user\").\n\tExpect().\n\tStatus(http.StatusOK).\n\tJSON().\n\tDecode(&user)\n\t\nif user.Name != \"octocat\" {\n\tt.Fail()\n}\n```\n\n##### Forms\n\n```go\n// post form encoded from struct or map\ne.POST(\"/form\").WithForm(structOrMap).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// set individual fields\ne.POST(\"/form\").WithFormField(\"foo\", \"hello\").WithFormField(\"bar\", 123).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// multipart form\ne.POST(\"/form\").WithMultipart().\n\tWithFile(\"avatar\", \"./john.png\").WithFormField(\"username\", \"john\").\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### URL construction\n\n```go\n// construct path using ordered parameters\ne.GET(\"/repos/{user}/{repo}\", \"octocat\", \"hello-world\").\n\tExpect().\n\tStatus(http.StatusOK)\n\n// construct path using named parameters\ne.GET(\"/repos/{user}/{repo}\").\n\tWithPath(\"user\", \"octocat\").WithPath(\"repo\", \"hello-world\").\n\tExpect().\n\tStatus(http.StatusOK)\n\n// set query parameters\ne.GET(\"/repos/{user}\", \"octocat\").WithQuery(\"sort\", \"asc\").\n\tExpect().\n\tStatus(http.StatusOK)    // \"/repos/octocat?sort=asc\"\n```\n\n##### Headers\n\n```go\n// set If-Match\ne.POST(\"/users/john\").WithHeader(\"If-Match\", etag).WithJSON(john).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// check ETag\ne.GET(\"/users/john\").\n\tExpect().\n\tStatus(http.StatusOK).Header(\"ETag\").NotEmpty()\n\n// check Date\nt := time.Now()\n\ne.GET(\"/users/john\").\n\tExpect().\n\tStatus(http.StatusOK).Header(\"Date\").AsDateTime().InRange(t, time.Now())\n```\n\n##### Cookies\n\n```go\n// set cookie\nt := time.Now()\n\ne.POST(\"/users/john\").WithCookie(\"session\", sessionID).WithJSON(john).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// check cookies\nc := e.GET(\"/users/john\").\n\tExpect().\n\tStatus(http.StatusOK).Cookie(\"session\")\n\nc.Value().IsEqual(sessionID)\nc.Domain().IsEqual(\"example.com\")\nc.Path().IsEqual(\"/\")\nc.Expires().InRange(t, t.Add(time.Hour * 24))\n```\n\n##### Regular expressions\n\n```go\n// simple match\ne.GET(\"/users/john\").\n\tExpect().\n\tHeader(\"Location\").\n\tMatch(\"http://(.+)/users/(.+)\").Values(\"example.com\", \"john\")\n\n// check capture groups by index or name\nm := e.GET(\"/users/john\").\n\tExpect().\n\tHeader(\"Location\").Match(\"http://(?P<host>.+)/users/(?P<user>.+)\")\n\nm.Submatch(0).IsEqual(\"http://example.com/users/john\")\nm.Submatch(1).IsEqual(\"example.com\")\nm.Submatch(2).IsEqual(\"john\")\n\nm.NamedSubmatch(\"host\").IsEqual(\"example.com\")\nm.NamedSubmatch(\"user\").IsEqual(\"john\")\n```\n\n##### Redirection support\n\n```go\ne.POST(\"/path\").\n\tWithRedirectPolicy(httpexpect.FollowAllRedirects).\n\tWithMaxRedirects(5).\n\tExpect().\n\tStatus(http.StatusOK)\n\ne.POST(\"/path\").\n\tWithRedirectPolicy(httpexpect.DontFollowRedirects).\n\tExpect().\n\tStatus(http.StatusPermanentRedirect)\n```\n\n##### Retry support\n\n```go\n// default retry policy\ne.POST(\"/path\").\n\tWithMaxRetries(5).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// custom retry policy\ne.POST(\"/path\").\n\tWithMaxRetries(5).\n\tWithRetryPolicy(httpexpect.RetryAllErrors).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// custom retry delays\ne.POST(\"/path\").\n\tWithMaxRetries(5).\n\tWithRetryDelay(time.Second, time.Minute).\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### Subdomains and per-request URL\n\n```go\ne.GET(\"/path\").WithURL(\"http://example.com\").\n\tExpect().\n\tStatus(http.StatusOK)\n\ne.GET(\"/path\").WithURL(\"http://subdomain.example.com\").\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### WebSocket support\n\n```go\nws := e.GET(\"/mysocket\").WithWebsocketUpgrade().\n\tExpect().\n\tStatus(http.StatusSwitchingProtocols).\n\tWebsocket()\ndefer ws.Disconnect()\n\nws.WriteText(\"some request\").\n\tExpect().\n\tTextMessage().Body().IsEqual(\"some response\")\n\nws.CloseWithText(\"bye\").\n\tExpect().\n\tCloseMessage().NoContent()\n```\n\n##### Reusable builders\n\n```go\ne := httpexpect.Default(t, \"http://example.com\")\n\nr := e.POST(\"/login\").WithForm(Login{\"ford\", \"betelgeuse7\"}).\n\tExpect().\n\tStatus(http.StatusOK).JSON().Object()\n\ntoken := r.Value(\"token\").String().Raw()\n\nauth := e.Builder(func (req *httpexpect.Request) {\n\treq.WithHeader(\"Authorization\", \"Bearer \"+token)\n})\n\nauth.GET(\"/restricted\").\n\tExpect().\n\tStatus(http.StatusOK)\n\ne.GET(\"/restricted\").\n\tExpect().\n\tStatus(http.StatusUnauthorized)\n```\n\n##### Reusable matchers\n\n```go\ne := httpexpect.Default(t, \"http://example.com\")\n\n// every response should have this header\nm := e.Matcher(func (resp *httpexpect.Response) {\n\tresp.Header(\"API-Version\").NotEmpty()\n})\n\nm.GET(\"/some-path\").\n\tExpect().\n\tStatus(http.StatusOK)\n\nm.GET(\"/bad-path\").\n\tExpect().\n\tStatus(http.StatusNotFound)\n```\n\n##### Request transformers\n\n```go\ne := httpexpect.Default(t, \"http://example.com\")\n\nmyTranform := func(r* http.Request) {\n\t// modify the underlying http.Request\n}\n\n// apply transformer to a single request\ne.POST(\"/some-path\").\n\tWithTransformer(myTranform).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// create a builder that applies transfromer to every request\nmyBuilder := e.Builder(func (req *httpexpect.Request) {\n\treq.WithTransformer(myTranform)\n})\n\nmyBuilder.POST(\"/some-path\").\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### Shared environment\n\n```go\ne := httpexpect.Default(t, \"http://example.com\")\n\nt.Run(\"/users\", func(t *testing.T) {\n\tobj := e.GET(\"/users\").\n\t\tExpect().\n\t\tStatus(http.StatusOK).JSON().Object()\n\n\t// store user id for next tests\n\tuserID := obj.Path(\"$.users[1].id\").String().Raw()\n\te.Env().Put(\"user1.id\", userID)\n})\n\nt.Run(\"/user/{userId}\", func(t *testing.T) {\n\t// read user id from previous tests\n\tuserID := e.Env().GetString(\"user1.id\")\n\n\te.GET(\"/user/{userId}\").\n\t\tWithPath(\"userId\", userID)\n\t\tExpect().\n\t\tStatus(http.StatusOK)\n})\n```\n\n##### Custom config\n\n```go\ne := httpexpect.WithConfig(httpexpect.Config{\n\t// include test name in failures (optional)\n\tTestName: t.Name(),\n\n\t// prepend this url to all requests\n\tBaseURL: \"http://example.com\",\n\n\t// use http.Client with a cookie jar and timeout\n\tClient: &http.Client{\n\t\tJar:     httpexpect.NewCookieJar(),\n\t\tTimeout: time.Second * 30,\n\t},\n\n\t// use fatal failures\n\tReporter: httpexpect.NewRequireReporter(t),\n\n\t// print all requests and responses\n\tPrinters: []httpexpect.Printer{\n\t\thttpexpect.NewDebugPrinter(t, true),\n\t},\n})\n```\n\n##### Use HTTP handler directly\n\n```go\n// invoke http.Handler directly using httpexpect.Binder\nvar handler http.Handler = myHandler()\n\ne := httpexpect.WithConfig(httpexpect.Config{\n\t// prepend this url to all requests, required for cookies\n\t// to be handled correctly\n\tBaseURL: \"http://example.com\",\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tTransport: httpexpect.NewBinder(handler),\n\t\tJar:       httpexpect.NewCookieJar(),\n\t},\n})\n\n// invoke fasthttp.RequestHandler directly using httpexpect.FastBinder\nvar handler fasthttp.RequestHandler = myHandler()\n\ne := httpexpect.WithConfig(httpexpect.Config{\n\t// prepend this url to all requests, required for cookies\n\t// to be handled correctly\n\tBaseURL: \"http://example.com\",\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tTransport: httpexpect.NewFastBinder(handler),\n\t\tJar:       httpexpect.NewCookieJar(),\n\t},\n})\n```\n\n##### Per-request client or handler\n\n```go\ne := httpexpect.Default(t, server.URL)\n\nclient := &http.Client{\n\tTransport: &http.Transport{\n\t\tDisableCompression: true,\n\t},\n}\n\n// overwrite client\ne.GET(\"/path\").WithClient(client).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// construct client that invokes a handler directly and overwrite client\ne.GET(\"/path\").WithHandler(handler).\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### WebSocket dialer\n\n```go\n// invoke http.Handler directly using websocket.Dialer\nvar handler http.Handler = myHandler()\n\ne := httpexpect.WithConfig(httpexpect.Config{\n\tBaseURL:         \"http://example.com\",\n\tReporter:        httpexpect.NewAssertReporter(t),\n\tWebsocketDialer: httpexpect.NewWebsocketDialer(handler),\n})\n\n// invoke fasthttp.RequestHandler directly using websocket.Dialer\nvar handler fasthttp.RequestHandler = myHandler()\n\ne := httpexpect.WithConfig(httpexpect.Config{\n\tBaseURL:         \"http://example.com\",\n\tReporter:        httpexpect.NewAssertReporter(t),\n\tWebsocketDialer: httpexpect.NewFastWebsocketDialer(handler),\n})\n```\n\n##### Session support\n\n```go\n// cookie jar is used to store cookies from server\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tJar: httpexpect.NewCookieJar(), // used by default if Client is nil\n\t},\n})\n\n// cookies are disabled\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tJar: nil,\n\t},\n})\n```\n\n##### TLS support\n\n```go\n// use TLS with http.Transport\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: &tls.Config{\n\t\t\t\t// accept any certificate; for testing only!\n\t\t\t\tInsecureSkipVerify: true,\n\t\t\t},\n\t\t},\n\t},\n})\n\n// use TLS with http.Handler\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tTransport: &httpexpect.Binder{\n\t\t\tHandler: myHandler,\n\t\t\tTLS:     &tls.ConnectionState{},\n\t\t},\n\t},\n})\n```\n\n##### Proxy support\n\n```go\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tClient: &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tProxy: http.ProxyURL(\"http://proxy.example.com\"),\n\t\t},\n\t},\n})\n```\n\n##### Global time-out/cancellation\n\n```go\nhandler := FruitsHandler()\n\nserver := httptest.NewServer(handler)\ndefer server.Close()\n\nctx, cancel := context.WithCancel(context.Background())\n\ne := WithConfig(Config{\n\tBaseURL:  server.URL,\n\tReporter: httpexpect.NewAssertReporter(t),\n\tContext:  ctx,\n})\n\ngo func() {\n\ttime.Sleep(time.Duration(5)*time.Second)\n\tcancel()\n}()\n\ne.GET(\"/fruits\").\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### Per-request time-out/cancellation\n\n```go\n// per-request context\ne.GET(\"/fruits\").\n\tWithContext(context.TODO()).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// per-request timeout\ne.GET(\"/fruits\").\n\tWithTimeout(time.Duration(5)*time.Second).\n\tExpect().\n\tStatus(http.StatusOK)\n\n// timeout combined with retries (timeout applies to each try)\ne.POST(\"/fruits\").\n\tWithMaxRetries(5).\n\tWithTimeout(time.Duration(10)*time.Second).\n\tExpect().\n\tStatus(http.StatusOK)\n```\n\n##### Support for aliases in failure messages\n\n```go\n// when the tests fails, assertion path in the failure message is:\n//   Request(\"GET\").Expect().JSON().Array().IsEmpty()\ne.GET(\"/fruits\").\n\tExpect().\n\tStatus(http.StatusOK).JSON().Array().IsEmpty()\n\n\n// assign alias \"fruits\" to the Array variable\nfruits := e.GET(\"/fruits\").\n\tExpect().\n\tStatus(http.StatusOK).JSON().Array().Alias(\"fruits\")\n\n// assertion path in the failure message is now:\n//   fruits.IsEmpty()\nfruits.IsEmpty()\n```\n\n##### Printing requests and responses\n\n```go\n// print requests in short form, don't print responses\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tPrinters: []httpexpect.Printer{\n\t\thttpexpect.NewCompactPrinter(t),\n\t},\n})\n\n// print requests as curl commands that can be inserted into terminal\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tPrinters: []httpexpect.Printer{\n\t\thttpexpect.NewCurlPrinter(t),\n\t},\n})\n\n// print requests and responses in verbose form\n// also print all incoming and outgoing websocket messages\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter: httpexpect.NewAssertReporter(t),\n\tPrinters: []httpexpect.Printer{\n\t\thttpexpect.NewDebugPrinter(t, true),\n\t},\n})\n```\n\n##### Customize failure formatting\n\n```go\n// customize formatting options\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter:  httpexpect.NewAssertReporter(t),\n\tFormatter: &httpexpect.DefaultFormatter{\n\t\tDisablePaths: true,\n\t\tDisableDiffs: true,\n\t\tFloatFormat:  httpexpect.FloatFormatScientific,\n\t\tColorMode:    httpexpect.ColorModeNever,\n\t\tLineWidth:    80,\n\t},\n})\n\n// customize formatting template\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter:  httpexpect.NewAssertReporter(t),\n\tFormatter: &httpexpect.DefaultFormatter{\n\t\tSuccessTemplate: \"...\",\n\t\tFailureTemplate: \"...\",\n\t\tTemplateFuncs:   template.FuncMap{ ... },\n\t},\n})\n\n// provide custom formatter\ne := httpexpect.WithConfig(httpexpect.Config{\n\tReporter:  httpexpect.NewAssertReporter(t),\n\tFormatter: &MyFormatter{},\n})\n```\n\n##### Customize assertion handling\n\n```go\n// enable printing of succeeded assertions\ne := httpexpect.WithConfig(httpexpect.Config{\n\tAssertionHandler: &httpexpect.DefaultAssertionHandler{\n\t\tFormatter: &httpexpect.DefaultFormatter{},\n\t\tReporter:  httpexpect.NewAssertReporter(t),\n\t\tLogger:    t, // specify logger to enable printing of succeeded assertions\n\t},\n})\n\n// provide custom assertion handler\n// here you can implement custom handling of succeeded and failed assertions\n// this may be useful for integrating httpexpect with other testing libs\n// if desired, you can completely ignore builtin Formatter, Reporter, and Logger\ne := httpexpect.WithConfig(httpexpect.Config{\n\tAssertionHandler: &MyAssertionHandler{},\n})\n```\n\n## Similar packages\n\n* [`gorequest`](https://github.com/parnurzeal/gorequest)\n* [`baloo`](https://github.com/h2non/baloo)\n* [`apitest`](https://github.com/steinfletcher/apitest)\n* [`gofight`](https://github.com/appleboy/gofight)\n* [`frisby`](https://github.com/verdverm/frisby)\n* [`forest`](https://github.com/emicklei/forest)\n* [`restit`](https://github.com/go-restit/restit)\n* [`httptesting`](https://github.com/dolab/httptesting)\n* [`http-test`](https://github.com/vsco/http-test)\n* [`go-json-rest`](https://github.com/ant0ine/go-json-rest)\n\n## License\n\n[MIT](LICENSE)\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "_images",
          "type": "tree",
          "content": null
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 41.744140625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Array provides methods to inspect attached []interface{} object\n// (Go representation of JSON array).\ntype Array struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  []interface{}\n}\n\n// NewArray returns a new Array instance.\n//\n// If reporter is nil, the function panics.\n// If value is nil, failure is reported.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\nfunc NewArray(reporter Reporter, value []interface{}) *Array {\n\treturn newArray(newChainWithDefaults(\"Array()\", reporter), value)\n}\n\n// NewArrayC returns a new Array instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// If value is nil, failure is reported.\n//\n// Example:\n//\n//\tarray := NewArrayC(config, []interface{}{\"foo\", 123})\nfunc NewArrayC(config Config, value []interface{}) *Array {\n\treturn newArray(newChainWithConfig(\"Array()\", config.withDefaults()), value)\n}\n\nfunc newArray(parent *chain, val []interface{}) *Array {\n\ta := &Array{chain: parent.clone(), value: nil}\n\n\topChain := a.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\tif val == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{val},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-nil array\"),\n\t\t\t},\n\t\t})\n\t} else {\n\t\ta.value, _ = canonArray(opChain, val)\n\t}\n\n\treturn a\n}\n\n// Raw returns underlying value attached to Array.\n// This is the value originally passed to NewArray, converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tassert.Equal(t, []interface{}{\"foo\", 123.0}, array.Raw())\nfunc (a *Array) Raw() []interface{} {\n\treturn a.value\n}\n\n// Decode unmarshals the underlying value attached to the Array to a target variable.\n// target should be one of these:\n//\n//   - pointer to an empty interface\n//   - pointer to a slice of any type\n//\n// Example:\n//\n//\ttype S struct{\n//\t\tFoo int `json:foo`\n//\t}\n//\tvalue := []interface{}{\n//\t\tmap[string]interface{}{\n//\t\t\t\"foo\": 123,\n//\t\t},\n//\t\tmap[string]interface{}{\n//\t\t\t\"foo\": 456,\n//\t\t},\n//\t}\n//\tarray := NewArray(t, value)\n//\n//\tvar target []S\n//\tarr.Decode(&target)\n//\n//\tassert.Equal(t, []S{{123}, {456}}, target)\nfunc (a *Array) Decode(target interface{}) *Array {\n\topChain := a.chain.enter(\"Decode()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tcanonDecode(opChain, a.value, target)\n\treturn a\n}\n\n// Alias is similar to Value.Alias.\nfunc (a *Array) Alias(name string) *Array {\n\topChain := a.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\ta.chain.setAlias(name)\n\treturn a\n}\n\n// Path is similar to Value.Path.\nfunc (a *Array) Path(path string) *Value {\n\topChain := a.chain.enter(\"Path(%q)\", path)\n\tdefer opChain.leave()\n\n\treturn jsonPath(opChain, a.value, path)\n}\n\n// Schema is similar to Value.Schema.\nfunc (a *Array) Schema(schema interface{}) *Array {\n\topChain := a.chain.enter(\"Schema()\")\n\tdefer opChain.leave()\n\n\tjsonSchema(opChain, a.value, schema)\n\treturn a\n}\n\n// Length returns a new Number instance with array length.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{1, 2, 3})\n//\tarray.Length().IsEqual(3)\nfunc (a *Array) Length() *Number {\n\topChain := a.chain.enter(\"Length()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\treturn newNumber(opChain, float64(len(a.value)))\n}\n\n// Value returns a new Value instance with array element for given index.\n//\n// If index is out of array bounds, Value reports failure and returns empty\n// (but non-nil) instance.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.Value(0).String().IsEqual(\"foo\")\n//\tarray.Value(1).Number().IsEqual(123)\nfunc (a *Array) Value(index int) *Value {\n\topChain := a.chain.enter(\"Value(%d)\", index)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif index < 0 || index >= len(a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertInRange,\n\t\t\tActual: &AssertionValue{index},\n\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\tMin: 0,\n\t\t\t\tMax: len(a.value) - 1,\n\t\t\t}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid element index\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\treturn newValue(opChain, a.value[index])\n}\n\n// Deprecated: use Value instead.\nfunc (a *Array) Element(index int) *Value {\n\treturn a.Value(index)\n}\n\n// HasValue succeeds if array's value at the given index is equal to given value.\n//\n// Before comparison, both values are converted to canonical form. value should be\n// map[string]interface{} or struct.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", \"123\"})\n//\tarray.HasValue(1, 123)\nfunc (a *Array) HasValue(index int, value interface{}) *Array {\n\topChain := a.chain.enter(\"HasValue(%d)\", index)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif index < 0 || index >= len(a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertInRange,\n\t\t\tActual: &AssertionValue{index},\n\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\tMin: 0,\n\t\t\t\tMax: len(a.value) - 1,\n\t\t\t}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid element index\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\texpected, ok := canonValue(opChain, value)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tif !reflect.DeepEqual(expected, a.value[index]) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{a.value[index]},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"expected: array value at index %d is equal to given value\",\n\t\t\t\t\tindex),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\treturn a\n}\n\n// NotHasValue succeeds if array's value at the given index is not equal to given value.\n//\n// Before comparison, both values are converted to canonical form. value should be\n// map[string]interface{} or struct.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", \"123\"})\n//\tarray.NotHasValue(1, 234)\nfunc (a *Array) NotHasValue(index int, value interface{}) *Array {\n\topChain := a.chain.enter(\"NotHasValue(%d)\", index)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif index < 0 || index >= len(a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertInRange,\n\t\t\tActual: &AssertionValue{index},\n\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\tMin: 0,\n\t\t\t\tMax: len(a.value) - 1,\n\t\t\t}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid element index\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\texpected, ok := canonValue(opChain, value)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tif reflect.DeepEqual(expected, a.value[index]) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{a.value[index]},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"expected: array value at index %d is not equal to given value\",\n\t\t\t\t\tindex),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\treturn a\n}\n\n// Deprecated: use Value or HasValue instead.\nfunc (a *Array) First() *Value {\n\topChain := a.chain.enter(\"First()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif len(a.value) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotEmpty,\n\t\t\tActual: &AssertionValue{a.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-empty array\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\treturn newValue(opChain, a.value[0])\n}\n\n// Deprecated: use Value or HasValue instead.\nfunc (a *Array) Last() *Value {\n\topChain := a.chain.enter(\"Last()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif len(a.value) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotEmpty,\n\t\t\tActual: &AssertionValue{a.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-empty array\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\treturn newValue(opChain, a.value[len(a.value)-1])\n}\n\n// Iter returns a new slice of Values attached to array elements.\n//\n// Example:\n//\n//\tstrings := []interface{}{\"foo\", \"bar\"}\n//\tarray := NewArray(t, strings)\n//\n//\tfor index, value := range array.Iter() {\n//\t\tvalue.String().IsEqual(strings[index])\n//\t}\nfunc (a *Array) Iter() []Value {\n\topChain := a.chain.enter(\"Iter()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn []Value{}\n\t}\n\n\tret := []Value{}\n\n\tfor index, element := range a.value {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Iter[%d]\", index)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tret = append(ret, *newValue(valueChain, element))\n\t\t}()\n\t}\n\n\treturn ret\n}\n\n// Every runs the passed function on all the elements in the array.\n//\n// If assertion inside function fails, the original Array is marked failed.\n//\n// Every will execute the function for all values in the array irrespective\n// of assertion failures for some values in the array.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", \"bar\"})\n//\n//\tarray.Every(func(index int, value *httpexpect.Value) {\n//\t\tvalue.String().NotEmpty()\n//\t})\nfunc (a *Array) Every(fn func(index int, value *Value)) *Array {\n\topChain := a.chain.enter(\"Every()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\tfor index, element := range a.value {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Every[%d]\", index)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tfn(index, newValue(valueChain, element))\n\t\t}()\n\t}\n\n\treturn a\n}\n\n// Filter accepts a function that returns a boolean. The function is ran\n// over the array elements. If the function returns true, the element passes\n// the filter and is added to the new array of filtered elements. If false,\n// the element is skipped (or in other words filtered out). After iterating\n// through all the elements of the original array, the new filtered array\n// is returned.\n//\n// If there are any failed assertions in the filtering function, the\n// element is omitted without causing test failure.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{1, 2, \"foo\", \"bar\"})\n//\tfilteredArray := array.Filter(func(index int, value *httpexpect.Value) bool {\n//\t\tvalue.String().NotEmpty()\t\t//fails on 1 and 2\n//\t\treturn value.Raw() != \"bar\"\t\t//fails on \"bar\"\n//\t})\n//\tfilteredArray.IsEqual([]interface{}{\"foo\"})\t//succeeds\nfunc (a *Array) Filter(fn func(index int, value *Value) bool) *Array {\n\topChain := a.chain.enter(\"Filter()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tfilteredArray := []interface{}{}\n\n\tfor index, element := range a.value {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Filter[%d]\", index)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(index, newValue(valueChain, element)) && !valueChain.treeFailed() {\n\t\t\t\tfilteredArray = append(filteredArray, element)\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn newArray(opChain, filteredArray)\n}\n\n// Transform runs the passed function on all the elements in the array\n// and returns a new array without effeecting original array.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", \"bar\"})\n//\ttransformedArray := array.Transform(\n//\t\tfunc(index int, value interface{}) interface{} {\n//\t\t\treturn strings.ToUpper(value.(string))\n//\t\t})\n//\ttransformedArray.IsEqual([]interface{}{\"FOO\", \"BAR\"})\nfunc (a *Array) Transform(fn func(index int, value interface{}) interface{}) *Array {\n\topChain := a.chain.enter(\"Transform()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn newArray(opChain, nil)\n\t}\n\n\ttransformedArray := []interface{}{}\n\n\tfor index, element := range a.value {\n\t\ttransformedArray = append(transformedArray, fn(index, element))\n\t}\n\n\treturn newArray(opChain, transformedArray)\n}\n\n// Find accepts a function that returns a boolean, runs it over the array\n// elements, and returns the first element on which it returned true.\n//\n// If there are any failed assertions in the predicate function, the\n// element is skipped without causing test failure.\n//\n// If no elements were found, a failure is reported.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{1, \"foo\", 101, \"bar\", 201})\n//\tfoundValue := array.Find(func(index int, value *httpexpect.Value) bool {\n//\t\tnum := value.Number()    // skip if element is not a number\n//\t\treturn num.Raw() > 100   // check element value\n//\t})\n//\tfoundValue.IsEqual(101) // succeeds\nfunc (a *Array) Find(fn func(index int, value *Value) bool) *Value {\n\topChain := a.chain.enter(\"Find()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tfor index, element := range a.value {\n\t\tfound := false\n\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Find[%d]\", index)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(index, newValue(valueChain, element)) && !valueChain.treeFailed() {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}()\n\n\t\tif found {\n\t\t\treturn newValue(opChain, element)\n\t\t}\n\t}\n\n\topChain.fail(AssertionFailure{\n\t\tType:   AssertValid,\n\t\tActual: &AssertionValue{a.value},\n\t\tErrors: []error{\n\t\t\terrors.New(\"expected: at least one array element matches predicate\"),\n\t\t},\n\t})\n\n\treturn newValue(opChain, nil)\n}\n\n// FindAll accepts a function that returns a boolean, runs it over the array\n// elements, and returns all the elements on which it returned true.\n//\n// If there are any failed assertions in the predicate function, the\n// element is skipped without causing test failure.\n//\n// If no elements were found, empty slice is returned without reporting error.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{1, \"foo\", 101, \"bar\", 201})\n//\tfoundValues := array.FindAll(func(index int, value *httpexpect.Value) bool {\n//\t\tnum := value.Number()   // skip if element is not a number\n//\t\treturn num.Raw() > 100  // check element value\n//\t})\n//\n//\tassert.Equal(t, len(foundValues), 2)\n//\tfoundValues[0].IsEqual(101)\n//\tfoundValues[1].IsEqual(201)\nfunc (a *Array) FindAll(fn func(index int, value *Value) bool) []*Value {\n\topChain := a.chain.enter(\"FindAll()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn []*Value{}\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn []*Value{}\n\t}\n\n\tfoundValues := make([]*Value, 0, len(a.value))\n\n\tfor index, element := range a.value {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"FindAll[%d]\", index)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(index, newValue(valueChain, element)) && !valueChain.treeFailed() {\n\t\t\t\tfoundValues = append(foundValues, newValue(opChain, element))\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn foundValues\n}\n\n// NotFind accepts a function that returns a boolean, runs it over the array\n// elelements, and checks that it does not return true for any of the elements.\n//\n// If there are any failed assertions in the predicate function, the\n// element is skipped without causing test failure.\n//\n// If the predicate function did not fail and returned true for at least\n// one element, a failure is reported.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{1, \"foo\", 2, \"bar\"})\n//\tarray.NotFind(func(index int, value *httpexpect.Value) bool {\n//\t\tnum := value.Number()    // skip if element is not a number\n//\t\treturn num.Raw() > 100   // check element value\n//\t}) // succeeds\nfunc (a *Array) NotFind(fn func(index int, value *Value) bool) *Array {\n\topChain := a.chain.enter(\"NotFind()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\tfor index, element := range a.value {\n\t\tfound := false\n\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"NotFind[%d]\", index)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(index, newValue(valueChain, element)) && !valueChain.treeFailed() {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}()\n\n\t\tif found {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotContainsElement,\n\t\t\t\tExpected: &AssertionValue{element},\n\t\t\t\tActual:   &AssertionValue{a.value},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: none of the array elements match predicate\"),\n\t\t\t\t\tfmt.Errorf(\"element with index %d matches predicate\", index),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t}\n\n\treturn a\n}\n\n// IsEmpty succeeds if array is empty.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{})\n//\tarray.IsEmpty()\nfunc (a *Array) IsEmpty() *Array {\n\topChain := a.chain.enter(\"IsEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif !(len(a.value) == 0) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertEmpty,\n\t\t\tActual: &AssertionValue{a.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: empty array\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// NotEmpty succeeds if array is non-empty.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotEmpty()\nfunc (a *Array) NotEmpty() *Array {\n\topChain := a.chain.enter(\"NotEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif len(a.value) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotEmpty,\n\t\t\tActual: &AssertionValue{a.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-empty array\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// Deprecated: use IsEmpty instead.\nfunc (a *Array) Empty() *Array {\n\treturn a.IsEmpty()\n}\n\n// IsEqual succeeds if array is equal to given value.\n// Before comparison, both array and value are converted to canonical form.\n//\n// value should be a slice of any type.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.IsEqual([]interface{}{\"foo\", 123})\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", \"bar\"})\n//\tarray.IsEqual([]string{}{\"foo\", \"bar\"})\n//\n//\tarray := NewArray(t, []interface{}{123, 456})\n//\tarray.IsEqual([]int{}{123, 456})\nfunc (a *Array) IsEqual(value interface{}) *Array {\n\topChain := a.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\texpected, ok := canonArray(opChain, value)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tif !reflect.DeepEqual(expected, a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{a.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: arrays are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// NotEqual succeeds if array is not equal to given value.\n// Before comparison, both array and value are converted to canonical form.\n//\n// value should be a slice of any type.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotEqual([]interface{}{123, \"foo\"})\nfunc (a *Array) NotEqual(value interface{}) *Array {\n\topChain := a.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\texpected, ok := canonArray(opChain, value)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tif reflect.DeepEqual(expected, a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{a.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: arrays are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// Deprecated: use IsEqual instead.\nfunc (a *Array) Equal(value interface{}) *Array {\n\treturn a.IsEqual(value)\n}\n\n// IsEqualUnordered succeeds if array is equal to another array, ignoring element\n// order. Before comparison, both arrays are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.IsEqualUnordered([]interface{}{123, \"foo\"})\nfunc (a *Array) IsEqualUnordered(value interface{}) *Array {\n\topChain := a.chain.enter(\"IsEqualUnordered()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\texpected, ok := canonArray(opChain, value)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfor _, element := range expected {\n\t\texpectedCount := countElement(expected, element)\n\t\tactualCount := countElement(a.value, element)\n\n\t\tif actualCount != expectedCount {\n\t\t\tif expectedCount == 1 && actualCount == 0 {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType:      AssertContainsElement,\n\t\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\t\tExpected:  &AssertionValue{element},\n\t\t\t\t\tReference: &AssertionValue{value},\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\terrors.New(\"expected: array contains element from reference array\"),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType:      AssertNotContainsElement,\n\t\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\t\tExpected:  &AssertionValue{element},\n\t\t\t\t\tReference: &AssertionValue{value},\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\t\t\"expected: element occurs %d time(s), as in reference array,\"+\n\t\t\t\t\t\t\t\t\" but it occurs %d time(s)\",\n\t\t\t\t\t\t\texpectedCount,\n\t\t\t\t\t\t\tactualCount),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn a\n\t\t}\n\t}\n\n\tfor _, element := range a.value {\n\t\texpectedCount := countElement(expected, element)\n\t\tactualCount := countElement(a.value, element)\n\n\t\tif actualCount != expectedCount {\n\t\t\tif expectedCount == 0 && actualCount == 1 {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType:      AssertNotContainsElement,\n\t\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\t\tExpected:  &AssertionValue{element},\n\t\t\t\t\tReference: &AssertionValue{value},\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\terrors.New(\"expected: array does not contain elements\" +\n\t\t\t\t\t\t\t\" that are not present in reference array\"),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType:      AssertNotContainsElement,\n\t\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\t\tExpected:  &AssertionValue{element},\n\t\t\t\t\tReference: &AssertionValue{value},\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\t\t\"expected: element occurs %d time(s), as in reference array,\"+\n\t\t\t\t\t\t\t\t\" but it occurs %d time(s)\",\n\t\t\t\t\t\t\texpectedCount,\n\t\t\t\t\t\t\tactualCount),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn a\n\t\t}\n\t}\n\n\treturn a\n}\n\n// NotEqualUnordered succeeds if array is not equal to another array, ignoring\n// element order. Before comparison, both arrays are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotEqualUnordered([]interface{}{123, \"foo\", \"bar\"})\nfunc (a *Array) NotEqualUnordered(value interface{}) *Array {\n\topChain := a.chain.enter(\"NotEqualUnordered()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\texpected, ok := canonArray(opChain, value)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tdifferent := false\n\n\tfor _, element := range expected {\n\t\texpectedCount := countElement(expected, element)\n\t\tactualCount := countElement(a.value, element)\n\n\t\tif actualCount != expectedCount {\n\t\t\tdifferent = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor _, element := range a.value {\n\t\texpectedCount := countElement(expected, element)\n\t\tactualCount := countElement(a.value, element)\n\n\t\tif actualCount != expectedCount {\n\t\t\tdifferent = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !different {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:      AssertNotEqual,\n\t\t\tActual:    &AssertionValue{a.value},\n\t\t\tExpected:  &AssertionValue{value},\n\t\t\tReference: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: arrays are non-equal (ignoring order)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// Deprecated: use IsEqualUnordered instead.\nfunc (a *Array) EqualUnordered(value interface{}) *Array {\n\treturn a.IsEqualUnordered(value)\n}\n\n// InList succeeds if the whole array is equal to one of the values from given\n// list of arrays. Before comparison, both array and each value are converted\n// to canonical form.\n//\n// Each value should be a slice of any type. If at least one value has wrong\n// type, failure is reported.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.InList([]interface{}{\"foo\", 123}, []interface{}{\"bar\", \"456\"})\nfunc (a *Array) InList(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\texpected, ok := canonArray(opChain, v)\n\t\tif !ok {\n\t\t\treturn a\n\t\t}\n\n\t\tif reflect.DeepEqual(expected, a.value) {\n\t\t\tisListed = true\n\t\t\t// continue loop to check that all values are correct\n\t\t}\n\t}\n\n\tif !isListed {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{a.value},\n\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: array is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// NotInList succeeds if the whole array is not equal to any of the values from\n// given list of arrays. Before comparison, both array and each value are\n// converted to canonical form.\n//\n// Each value should be a slice of any type. If at least one value has wrong\n// type, failure is reported.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotInList([]interface{}{\"bar\", 456}, []interface{}{\"baz\", \"foo\"})\nfunc (a *Array) NotInList(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\tfor _, v := range values {\n\t\texpected, ok := canonArray(opChain, v)\n\t\tif !ok {\n\t\t\treturn a\n\t\t}\n\n\t\tif reflect.DeepEqual(expected, a.value) {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{a.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: array is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t}\n\n\treturn a\n}\n\n// ConsistsOf succeeds if array contains all given elements, in given order, and only\n// them. Before comparison, array and all elements are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.ConsistsOf(\"foo\", 123)\n//\n// These calls are equivalent:\n//\n//\tarray.ConsistsOf(\"a\", \"b\")\n//\tarray.IsEqual([]interface{}{\"a\", \"b\"})\nfunc (a *Array) ConsistsOf(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"ConsistsOf()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\texpected, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tif !reflect.DeepEqual(expected, a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{a.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: array consists of given elements\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// NotConsistsOf is opposite to ConsistsOf.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotConsistsOf(\"foo\")\n//\tarray.NotConsistsOf(\"foo\", 123, 456)\n//\tarray.NotConsistsOf(123, \"foo\")\n//\n// These calls are equivalent:\n//\n//\tarray.NotConsistsOf(\"a\", \"b\")\n//\tarray.NotEqual([]interface{}{\"a\", \"b\"})\nfunc (a *Array) NotConsistsOf(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"NotConsistsOf()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\texpected, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tif reflect.DeepEqual(expected, a.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{a.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: arrays does not consist of given elements\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// Deprecated: use ConsistsOf instead.\nfunc (a *Array) Elements(values ...interface{}) *Array {\n\treturn a.ConsistsOf(values...)\n}\n\n// Deprecated: use NotConsistsOf instead.\nfunc (a *Array) NotElements(values ...interface{}) *Array {\n\treturn a.NotConsistsOf(values...)\n}\n\n// Deprecated: use ContainsAll or ContainsAny instead.\nfunc (a *Array) Contains(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"Contains()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfor _, expected := range elements {\n\t\tif countElement(a.value, expected) == 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertContainsElement,\n\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\tExpected:  &AssertionValue{expected},\n\t\t\t\tReference: &AssertionValue{values},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: array contains element from reference array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn a\n}\n\n// Deprecated: use NotContainsAll or NotContainsAny instead.\nfunc (a *Array) NotContains(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"NotContains()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfor _, expected := range elements {\n\t\tif !(countElement(a.value, expected) == 0) {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertNotContainsElement,\n\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\tExpected:  &AssertionValue{expected},\n\t\t\t\tReference: &AssertionValue{values},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\t\" array does not contain any elements from reference array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn a\n}\n\n// ContainsAll succeeds if array contains all given elements (in any order).\n// Before comparison, array and all elements are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.ContainsAll(123, \"foo\")\nfunc (a *Array) ContainsAll(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"ContainsAll()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfor _, expected := range elements {\n\t\tif countElement(a.value, expected) == 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertContainsElement,\n\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\tExpected:  &AssertionValue{expected},\n\t\t\t\tReference: &AssertionValue{values},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: array contains element from reference array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn a\n}\n\n// NotContainsAll succeeds if array does not contain at least one of the elements.\n// Before comparison, array and all elements are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotContainsAll(\"bar\")         // success\n//\tarray.NotContainsAll(123, \"foo\")    // failure\nfunc (a *Array) NotContainsAll(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"NotContainsAll()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\thaveMissing := false\n\n\tfor _, expected := range elements {\n\t\tif countElement(a.value, expected) == 0 {\n\t\t\thaveMissing = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !haveMissing {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:      AssertNotContainsElement,\n\t\t\tActual:    &AssertionValue{a.value},\n\t\t\tReference: &AssertionValue{values},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\" array does not contain at least one element from reference array\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// ContainsAny succeeds if array contains at least one element from the given elements.\n// Before comparison, array and all elements are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123, 123})\n//\tarray.ContainsAny(123, \"foo\", \"FOO\") // success\n//\tarray.ContainsAny(\"FOO\") // failure\nfunc (a *Array) ContainsAny(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"ContainsAny()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfoundAny := false\n\n\tfor _, expected := range elements {\n\t\tif countElement(a.value, expected) != 0 {\n\t\t\tfoundAny = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !foundAny {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:      AssertContainsElement,\n\t\t\tActual:    &AssertionValue{a.value},\n\t\t\tReference: &AssertionValue{values},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\" array contains at least one element from reference array\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// NotContainsAny succeeds if none of the given elements are in the array.\n// Before comparison, array and all elements are converted to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotContainsAny(\"bar\", 124) // success\n//\tarray.NotContainsAny(123) // failure\nfunc (a *Array) NotContainsAny(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"NotContainsAny()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfor _, expected := range elements {\n\t\tif countElement(a.value, expected) != 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertNotContainsElement,\n\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\tExpected:  &AssertionValue{expected},\n\t\t\t\tReference: &AssertionValue{values},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\t\" array does not contain any elements from reference array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t}\n\n\treturn a\n}\n\n// ContainsOnly succeeds if array contains all given elements, in any order, and only\n// them, ignoring duplicates. Before comparison, array and all elements are converted\n// to canonical form.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123, 123})\n//\tarray.ContainsOnly(123, \"foo\")\n//\n// These calls are equivalent:\n//\n//\tarray.ContainsOnly(\"a\", \"b\")\n//\tarray.ContainsOnly(\"b\", \"a\")\nfunc (a *Array) ContainsOnly(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"ContainsOnly()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tfor _, element := range elements {\n\t\tif countElement(a.value, element) == 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertContainsElement,\n\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\tExpected:  &AssertionValue{element},\n\t\t\t\tReference: &AssertionValue{values},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: array contains element from reference array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t}\n\n\tfor _, element := range a.value {\n\t\tif countElement(elements, element) == 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertNotContainsElement,\n\t\t\t\tActual:    &AssertionValue{a.value},\n\t\t\t\tExpected:  &AssertionValue{element},\n\t\t\t\tReference: &AssertionValue{values},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: array does not contain elements\" +\n\t\t\t\t\t\t\" that are not present in reference array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t}\n\n\treturn a\n}\n\n// NotContainsOnly is opposite to ContainsOnly.\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{\"foo\", 123})\n//\tarray.NotContainsOnly(123)\n//\tarray.NotContainsOnly(123, \"foo\", \"bar\")\n//\n// These calls are equivalent:\n//\n//\tarray.NotContainsOnly(\"a\", \"b\")\n//\tarray.NotContainsOnly(\"b\", \"a\")\nfunc (a *Array) NotContainsOnly(values ...interface{}) *Array {\n\topChain := a.chain.enter(\"NotContainsOnly()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\telements, ok := canonArray(opChain, values)\n\tif !ok {\n\t\treturn a\n\t}\n\n\tdifferent := false\n\n\tfor _, element := range elements {\n\t\tif countElement(a.value, element) == 0 {\n\t\t\tdifferent = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor _, element := range a.value {\n\t\tif countElement(elements, element) == 0 {\n\t\t\tdifferent = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !different {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:      AssertNotEqual,\n\t\t\tActual:    &AssertionValue{a.value},\n\t\t\tExpected:  &AssertionValue{values},\n\t\t\tReference: &AssertionValue{values},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\" array does not contain only elements from reference array\" +\n\t\t\t\t\t\" (at least one distinguishing element needed)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\n// IsOrdered succeeds if every element is not less than the previous element\n// as defined on the given `less` comparator function.\n// For default, it will use built-in comparator function for each data type.\n// Built-in comparator requires all elements in the array to have same data type.\n// Array with 0 or 1 element will always succeed\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{100, 101, 102})\n//\tarray.IsOrdered() // succeeds\n//\tarray.IsOrdered(func(x, y *httpexpect.Value) bool {\n//\t\treturn x.Number().Raw() < y.Number().Raw()\n//\t}) // succeeds\nfunc (a *Array) IsOrdered(less ...func(x, y *Value) bool) *Array {\n\topChain := a.chain.enter(\"IsOrdered()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif len(less) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple less arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\tvar lessFn func(x, y *Value) bool\n\tif len(less) == 1 {\n\t\tlessFn = less[0]\n\t\tif lessFn == nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertUsage,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"unexpected nil less argument\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t} else {\n\t\tlessFn = builtinComparator(opChain, a.value)\n\t\tif lessFn == nil {\n\t\t\treturn a\n\t\t}\n\t}\n\n\tif len(a.value) <= 1 {\n\t\treturn a\n\t}\n\n\tfor i := 0; i < len(a.value)-1; i++ {\n\t\tvar unordered bool\n\n\t\tfunc() {\n\t\t\txChain := opChain.replace(\"IsOrdered[%d]\", i)\n\t\t\tdefer xChain.leave()\n\n\t\t\tyChain := opChain.replace(\"IsOrdered[%d]\", i+1)\n\t\t\tdefer yChain.leave()\n\n\t\t\tx := newValue(xChain, a.value[i])\n\t\t\ty := newValue(yChain, a.value[i+1])\n\n\t\t\tunordered = lessFn(y, x)\n\t\t}()\n\n\t\tif opChain.failed() {\n\t\t\treturn a\n\t\t}\n\n\t\tif unordered {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:      AssertLt,\n\t\t\t\tActual:    &AssertionValue{a.value[i]},\n\t\t\t\tExpected:  &AssertionValue{a.value[i+1]},\n\t\t\t\tReference: &AssertionValue{a.value},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: reference array is ordered\"),\n\t\t\t\t\tfmt.Errorf(\"element %v must not be less than element %v\",\n\t\t\t\t\t\ti+1, i),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t}\n\n\treturn a\n}\n\n// NotOrdered succeeds if at least one element is less than the previous element\n// as defined on the given `less` comparator function.\n// For default, it will use built-in comparator function for each data type.\n// Built-in comparator requires all elements in the array to have same data type.\n// Array with 0 or 1 element will always succeed\n//\n// Example:\n//\n//\tarray := NewArray(t, []interface{}{102, 101, 100})\n//\tarray.NotOrdered() // succeeds\n//\tarray.NotOrdered(func(x, y *httpexpect.Value) bool {\n//\t\treturn x.Number().Raw() < y.Number().Raw()\n//\t}) // succeeds\nfunc (a *Array) NotOrdered(less ...func(x, y *Value) bool) *Array {\n\topChain := a.chain.enter(\"NotOrdered()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn a\n\t}\n\n\tif len(less) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple less arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn a\n\t}\n\n\tvar lessFn func(x, y *Value) bool\n\tif len(less) == 1 {\n\t\tlessFn = less[0]\n\t\tif lessFn == nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertUsage,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"unexpected nil less argument\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn a\n\t\t}\n\t} else {\n\t\tlessFn = builtinComparator(opChain, a.value)\n\t\tif lessFn == nil {\n\t\t\treturn a\n\t\t}\n\t}\n\n\tif len(a.value) <= 1 {\n\t\treturn a\n\t}\n\n\tordered := true\n\n\tfor i := 0; i < len(a.value)-1; i++ {\n\t\tfunc() {\n\t\t\txChain := opChain.replace(\"IsOrdered[%d]\", i)\n\t\t\tdefer xChain.leave()\n\n\t\t\tyChain := opChain.replace(\"IsOrdered[%d]\", i+1)\n\t\t\tdefer yChain.leave()\n\n\t\t\tx := newValue(xChain, a.value[i])\n\t\t\ty := newValue(yChain, a.value[i+1])\n\n\t\t\tif lessFn(y, x) {\n\t\t\t\tordered = false\n\t\t\t}\n\t\t}()\n\n\t\tif opChain.failed() {\n\t\t\treturn a\n\t\t}\n\n\t\tif !ordered {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif ordered {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{a.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: array is not ordered, but it is\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn a\n}\n\nfunc countElement(array []interface{}, element interface{}) int {\n\tcount := 0\n\tfor _, e := range array {\n\t\tif reflect.DeepEqual(element, e) {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc builtinComparator(opChain *chain, array []interface{}) func(x, y *Value) bool {\n\tvar prev interface{}\n\tfor index, curr := range array {\n\t\tswitch curr.(type) {\n\t\tcase bool, float64, string, nil:\n\t\t\t// ok, do nothing\n\n\t\tdefault:\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertBelongs,\n\t\t\t\tActual: &AssertionValue{\n\t\t\t\t\tunquotedType(fmt.Sprintf(\"%T\", curr)),\n\t\t\t\t},\n\t\t\t\tExpected: &AssertionValue{AssertionList{\n\t\t\t\t\tunquotedType(\"Boolean (bool)\"),\n\t\t\t\t\tunquotedType(\"Number (int*, uint*, float*)\"),\n\t\t\t\t\tunquotedType(\"String (string)\"),\n\t\t\t\t\tunquotedType(\"Null (nil)\"),\n\t\t\t\t}},\n\t\t\t\tReference: &AssertionValue{\n\t\t\t\t\tarray,\n\t\t\t\t},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: type of each element of reference array\" +\n\t\t\t\t\t\t\" belongs to allowed list\"),\n\t\t\t\t\tfmt.Errorf(\"element %v has disallowed type %T\", index, curr),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn nil\n\t\t}\n\n\t\tif index > 0 && fmt.Sprintf(\"%T\", curr) != fmt.Sprintf(\"%T\", prev) {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertEqual,\n\t\t\t\tActual: &AssertionValue{\n\t\t\t\t\tunquotedType(fmt.Sprintf(\"%T (type of element %v)\", curr, index)),\n\t\t\t\t},\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tunquotedType(fmt.Sprintf(\"%T (type of element %v)\", prev, index-1)),\n\t\t\t\t},\n\t\t\t\tReference: &AssertionValue{\n\t\t\t\t\tarray,\n\t\t\t\t},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\t\" types of all elements of reference array are the same\"),\n\t\t\t\t\tfmt.Errorf(\"element %v has type %T, but element %v has type %T\",\n\t\t\t\t\t\tindex-1, prev, index, curr),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn nil\n\t\t}\n\n\t\tprev = curr\n\t}\n\n\tif len(array) > 1 {\n\t\tswitch array[0].(type) {\n\t\tcase bool:\n\t\t\treturn func(x, y *Value) bool {\n\t\t\t\txVal := x.Raw().(bool)\n\t\t\t\tyVal := y.Raw().(bool)\n\t\t\t\treturn (!xVal && yVal)\n\t\t\t}\n\t\tcase float64:\n\t\t\treturn func(x, y *Value) bool {\n\t\t\t\txVal := x.Raw().(float64)\n\t\t\t\tyVal := y.Raw().(float64)\n\t\t\t\treturn xVal < yVal\n\t\t\t}\n\t\tcase string:\n\t\t\treturn func(x, y *Value) bool {\n\t\t\t\txVal := x.Raw().(string)\n\t\t\t\tyVal := y.Raw().(string)\n\t\t\t\treturn xVal < yVal\n\t\t\t}\n\t\tcase nil:\n\t\t\treturn func(x, y *Value) bool {\n\t\t\t\t// `nil` is never less than `nil`\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype unquotedType string\n\nfunc (t unquotedType) String() string {\n\treturn string(t)\n}\n"
        },
        {
          "name": "array_test.go",
          "type": "blob",
          "size": 59.7353515625,
          "content": "package httpexpect\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestArray_FailedChain(t *testing.T) {\n\tcheck := func(value *Array) {\n\t\tvalue.chain.assert(t, failure)\n\n\t\tvalue.Path(\"$\").chain.assert(t, failure)\n\t\tvalue.Schema(\"\")\n\t\tvalue.Alias(\"foo\")\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.Length().chain.assert(t, failure)\n\t\tvalue.Value(0).chain.assert(t, failure)\n\t\tvalue.First().chain.assert(t, failure)\n\t\tvalue.Last().chain.assert(t, failure)\n\n\t\tvalue.IsEmpty()\n\t\tvalue.NotEmpty()\n\t\tvalue.IsEqual([]interface{}{})\n\t\tvalue.NotEqual([]interface{}{})\n\t\tvalue.IsEqualUnordered([]interface{}{})\n\t\tvalue.NotEqualUnordered([]interface{}{})\n\t\tvalue.InList([]interface{}{})\n\t\tvalue.NotInList([]interface{}{})\n\t\tvalue.ConsistsOf(\"foo\")\n\t\tvalue.NotConsistsOf(\"foo\")\n\t\tvalue.Contains(\"foo\")\n\t\tvalue.NotContains(\"foo\")\n\t\tvalue.ContainsAll(\"foo\")\n\t\tvalue.NotContainsAll(\"foo\")\n\t\tvalue.ContainsAny(\"foo\")\n\t\tvalue.NotContainsAny(\"foo\")\n\t\tvalue.ContainsOnly(\"foo\")\n\t\tvalue.NotContainsOnly(\"foo\")\n\t\tvalue.HasValue(0, nil)\n\t\tvalue.NotHasValue(0, nil)\n\n\t\tassert.NotNil(t, value.Iter())\n\t\tassert.Equal(t, 0, len(value.Iter()))\n\n\t\tvalue.Every(func(_ int, val *Value) {\n\t\t\tval.String().NotEmpty()\n\t\t})\n\t\tvalue.Filter(func(_ int, val *Value) bool {\n\t\t\tval.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t\tvalue.Transform(func(index int, value interface{}) interface{} {\n\t\t\treturn nil\n\t\t})\n\t\tvalue.Find(func(index int, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t\tvalue.FindAll(func(index int, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t\tvalue.NotFind(func(index int, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t}\n\n\tt.Run(\"failed chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t, flagFailed)\n\t\tvalue := newArray(chain, []interface{}{})\n\n\t\tcheck(value)\n\t})\n\n\tt.Run(\"nil value\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newArray(chain, nil)\n\n\t\tcheck(value)\n\t})\n\n\tt.Run(\"failed chain, nil value\", func(t *testing.T) {\n\t\tchain := newMockChain(t, flagFailed)\n\t\tvalue := newArray(chain, nil)\n\n\t\tcheck(value)\n\t})\n}\n\nfunc TestArray_Constructors(t *testing.T) {\n\ttestValue := []interface{}{\"Foo\", 123}\n\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewArray(reporter, testValue)\n\n\t\tvalue.IsEqual(testValue)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewArrayC(Config{\n\t\t\tReporter: reporter,\n\t\t}, testValue)\n\n\t\tvalue.IsEqual(testValue)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\n\t\tvalue := newArray(chain, testValue)\n\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n\n\tt.Run(\"invalid value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewArray(reporter, nil)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tdata := []interface{}{\"foo\", 123.0}\n\n\tvalue := NewArray(reporter, data)\n\n\tassert.Equal(t, data, value.Raw())\n\tassert.NotSame(t, &data[0], &value.Raw()[0])\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestArray_Decode(t *testing.T) {\n\tt.Run(\"target is empty interface\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttestValue := []interface{}{\"Foo\", 123.0}\n\t\tarr := NewArray(reporter, testValue)\n\n\t\tvar target interface{}\n\t\tarr.Decode(&target)\n\n\t\tarr.chain.assert(t, success)\n\t\tassert.Equal(t, testValue, target)\n\t})\n\n\tt.Run(\"target is slice of empty interfaces\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttestValue := []interface{}{\"Foo\", 123.0}\n\t\tarr := NewArray(reporter, testValue)\n\n\t\tvar target []interface{}\n\t\tarr.Decode(&target)\n\n\t\tarr.chain.assert(t, success)\n\t\tassert.Equal(t, testValue, target)\n\t})\n\n\tt.Run(\"target is slice of structs\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttype S struct {\n\t\t\tFoo int `json:\"foo\"`\n\t\t}\n\n\t\tactualStruct := []S{{123}, {456}}\n\t\ttestValue := []interface{}{\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"foo\": 123,\n\t\t\t},\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"foo\": 456,\n\t\t\t},\n\t\t}\n\t\tarr := NewArray(reporter, testValue)\n\n\t\tvar target []S\n\t\tarr.Decode(&target)\n\n\t\tarr.chain.assert(t, success)\n\t\tassert.Equal(t, actualStruct, target)\n\t})\n\n\tt.Run(\"target is unmarshable\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttestValue := []interface{}{\"Foo\", 123.0}\n\t\tarr := NewArray(reporter, testValue)\n\n\t\tarr.Decode(123)\n\n\t\tarr.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"target is nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttestValue := []interface{}{\"Foo\", 123.0}\n\t\tarr := NewArray(reporter, testValue)\n\n\t\tarr.Decode(nil)\n\n\t\tarr.chain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewArray(reporter, []interface{}{1, 2})\n\tassert.Equal(t, []string{\"Array()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Array()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Array()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.Filter(func(index int, value *Value) bool {\n\t\treturn value.Number().Raw() > 1\n\t})\n\tassert.Equal(t, []string{\"Array()\", \"Filter()\"}, childValue.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\", \"Filter()\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestArray_Path(t *testing.T) {\n\tcases := []struct {\n\t\tname  string\n\t\tvalue []interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tvalue: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"not empty\",\n\t\t\tvalue: []interface{}{\"foo\", 123.0},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewArray(reporter, tc.value)\n\n\t\t\tassert.Equal(t, tc.value, value.Path(\"$\").Raw())\n\t\t\tvalue.chain.assert(t, success)\n\t\t})\n\t}\n}\n\nfunc TestArray_Schema(t *testing.T) {\n\tcases := []struct {\n\t\tname  string\n\t\tvalue []interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tvalue: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"not empty\",\n\t\t\tvalue: []interface{}{\"foo\", 123.0},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewArray(reporter, tc.value).Schema(`{\"type\": \"array\"}`).\n\t\t\t\tchain.assert(t, success)\n\n\t\t\tNewArray(reporter, tc.value).Schema(`{\"type\": \"object\"}`).\n\t\t\t\tchain.assert(t, failure)\n\t\t})\n\t}\n}\n\nfunc TestArray_Getters(t *testing.T) {\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tdata := []interface{}{}\n\n\t\tvalue := NewArray(reporter, data)\n\n\t\tassert.Equal(t, 0.0, value.Length().Raw())\n\t\tvalue.chain.assert(t, success)\n\t\tvalue.chain.clear()\n\n\t\tassert.NotNil(t, value.Value(0))\n\t\tvalue.chain.assert(t, failure)\n\t\tvalue.chain.clear()\n\t})\n\n\tt.Run(\"not empty\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tdata := []interface{}{\"foo\", 123.0}\n\n\t\tvalue := NewArray(reporter, data)\n\n\t\tassert.Equal(t, 2.0, value.Length().Raw())\n\t\tvalue.chain.assert(t, success)\n\t\tvalue.chain.clear()\n\n\t\tassert.Equal(t, \"foo\", value.Value(0).Raw())\n\t\tassert.Equal(t, 123.0, value.Value(1).Raw())\n\t\tvalue.chain.assert(t, success)\n\t\tvalue.chain.clear()\n\n\t\tassert.Equal(t, nil, value.Value(2).Raw())\n\t\tvalue.chain.assert(t, failure)\n\t\tvalue.chain.clear()\n\t})\n}\n\nfunc TestArray_IsEmpty(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tvalue     []interface{}\n\t\twantEmpty chainResult\n\t}{\n\t\t{\n\t\t\tname:      \"empty slice\",\n\t\t\tvalue:     []interface{}{},\n\t\t\twantEmpty: success,\n\t\t},\n\t\t{\n\t\t\tname:      \"one empty element\",\n\t\t\tvalue:     []interface{}{\"\"},\n\t\t\twantEmpty: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewArray(reporter, tc.value).IsEmpty().\n\t\t\t\tchain.assert(t, tc.wantEmpty)\n\n\t\t\tNewArray(reporter, tc.value).NotEmpty().\n\t\t\t\tchain.assert(t, !tc.wantEmpty)\n\t\t})\n\t}\n}\n\nfunc TestArray_IsEqual(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tvalue     []interface{}\n\t\t\ttestValue interface{}\n\t\t\twantEqual chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:      \"empty array vs empty array\",\n\t\t\t\tvalue:     []interface{}{},\n\t\t\t\ttestValue: []interface{}{},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"one empty element vs one empty elemenent\",\n\t\t\t\tvalue:     []interface{}{\"\"},\n\t\t\t\ttestValue: []interface{}{\"\"},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"array vs empty array\",\n\t\t\t\tvalue:     []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestValue: []interface{}{},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"subset\",\n\t\t\t\tvalue:     []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestValue: []interface{}{\"foo\"},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"reordered\",\n\t\t\t\tvalue:     []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestValue: []interface{}{\"bar\", \"foo\"},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"strings\",\n\t\t\t\tvalue:     []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestValue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"numbers\",\n\t\t\t\tvalue:     []interface{}{123, 456},\n\t\t\t\ttestValue: []interface{}{123, 456},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.value).IsEqual(tc.testValue).\n\t\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\t\tNewArray(reporter, tc.value).NotEqual(tc.testValue).\n\t\t\t\t\tchain.assert(t, !tc.wantEqual)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttype S struct {\n\t\t\tFoo int `json:\"foo\"`\n\t\t}\n\n\t\tvalue := []interface{}{\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"foo\": 123,\n\t\t\t},\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"foo\": 456,\n\t\t\t},\n\t\t}\n\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, value).IsEqual([]S{{123}, {456}}).\n\t\t\tchain.assert(t, success)\n\n\t\tNewArray(reporter, value).NotEqual([]S{{123}, {456}}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, value).IsEqual([]S{{456}, {123}}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, value).NotEqual([]S{{456}, {123}}).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyArray []interface{}\n\t\t\tmyInt   int\n\t\t)\n\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{123, 456}).IsEqual(myArray{myInt(123), 456.0}).\n\t\t\tchain.assert(t, success)\n\n\t\tNewArray(reporter, []interface{}{123, 456}).NotEqual(myArray{myInt(123), 456.0}).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).IsEqual(nil).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotEqual(nil).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).IsEqual(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotEqual(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_IsEqualUnordered(t *testing.T) {\n\tt.Run(\"without duplicates\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tvalue              []interface{}\n\t\t\ttestValue          interface{}\n\t\t\twantEqualUnordered chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"only first element\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"only second element\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\"},\n\t\t\t\ttestValue:          []interface{}{\"foo\"},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"extra element\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"equal ordered\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123, \"foo\"},\n\t\t\t\twantEqualUnordered: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"equal unordered\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\"},\n\t\t\t\ttestValue:          []interface{}{\"foo\", 123},\n\t\t\t\twantEqualUnordered: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"overlap\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\"},\n\t\t\t\ttestValue:          []interface{}{\"foo\", 1234},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.value).IsEqualUnordered(tc.testValue).\n\t\t\t\t\tchain.assert(t, tc.wantEqualUnordered)\n\n\t\t\t\tNewArray(reporter, tc.value).NotEqualUnordered(tc.testValue).\n\t\t\t\t\tchain.assert(t, !tc.wantEqualUnordered)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"with duplicates\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tvalue              []interface{}\n\t\t\ttestValue          interface{}\n\t\t\twantEqualUnordered chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"missing duplicate\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123, \"foo\"},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"count mismatch\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123, 123, \"foo\"},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"equal ordered\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\twantEqualUnordered: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"equal unordered\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\ttestValue:          []interface{}{\"foo\", 123, \"foo\"},\n\t\t\t\twantEqualUnordered: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"only one element\",\n\t\t\t\tvalue:              []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\ttestValue:          []interface{}{123},\n\t\t\t\twantEqualUnordered: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.value).IsEqualUnordered(tc.testValue).\n\t\t\t\t\tchain.assert(t, tc.wantEqualUnordered)\n\n\t\t\t\tNewArray(reporter, tc.value).NotEqualUnordered(tc.testValue).\n\t\t\t\t\tchain.assert(t, !tc.wantEqualUnordered)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyArray []interface{}\n\t\t\tmyInt   int\n\t\t)\n\n\t\treporter := newMockReporter(t)\n\n\t\ttestVal := myArray{myInt(456), 123.0, \"foo\"}\n\n\t\tNewArray(reporter, []interface{}{123, 456, \"foo\"}).IsEqualUnordered(testVal).\n\t\t\tchain.assert(t, success)\n\n\t\tNewArray(reporter, []interface{}{123, 456, \"foo\"}).NotEqualUnordered(testVal).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).IsEqualUnordered(nil).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotEqualUnordered(nil).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).IsEqualUnordered(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotEqualUnordered(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_InList(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname       string\n\t\t\tvalue      []interface{}\n\t\t\ttestList   []interface{}\n\t\t\twantInList chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:  \"one element list with equal array\",\n\t\t\t\tvalue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\t[]interface{}{\"foo\", \"bar\"},\n\t\t\t\t},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"one element list with inequal array\",\n\t\t\t\tvalue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\t[]interface{}{\"bar\", \"foo\"},\n\t\t\t\t},\n\t\t\t\twantInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"list with inequal and equal arrays\",\n\t\t\t\tvalue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\t[]interface{}{\"bar\", \"foo\"},\n\t\t\t\t\t[]interface{}{\"foo\", \"bar\"},\n\t\t\t\t},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"list with inequal arrays\",\n\t\t\t\tvalue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\t[]interface{}{\"bar\", \"foo\"},\n\t\t\t\t\t[]interface{}{\"FOO\", \"BAR\"},\n\t\t\t\t},\n\t\t\t\twantInList: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.value).InList(tc.testList...).\n\t\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\t\tNewArray(reporter, tc.value).NotInList(tc.testList...).\n\t\t\t\t\tchain.assert(t, !tc.wantInList)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyArray []interface{}\n\t\t\tmyMap   map[string]interface{}\n\t\t\tmyInt   int\n\t\t)\n\n\t\tvalue := []interface{}{\n\t\t\t123,\n\t\t\t456,\n\t\t\t[]interface{}{789, 567},\n\t\t\tmap[string]interface{}{\"a\": \"b\"},\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tvalue     []interface{}\n\t\t\ttestValue []interface{}\n\t\t\tresult    chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:  \"test 1\",\n\t\t\t\tvalue: value,\n\t\t\t\ttestValue: myArray{\n\t\t\t\t\tmyInt(123.0),\n\t\t\t\t\tmyInt(456.0),\n\t\t\t\t\tmyArray{\n\t\t\t\t\t\tmyInt(789.0),\n\t\t\t\t\t\tmyInt(567.0),\n\t\t\t\t\t},\n\t\t\t\t\tmyMap{\"a\": \"b\"},\n\t\t\t\t},\n\t\t\t\tresult: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"test 2\",\n\t\t\t\tvalue: value,\n\t\t\t\ttestValue: myArray{\n\t\t\t\t\t123.0,\n\t\t\t\t\t456.0,\n\t\t\t\t\tmyArray{789.0, 567.0},\n\t\t\t\t\tmyMap{\"a\": \"b\"},\n\t\t\t\t},\n\t\t\t\tresult: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"test 3\",\n\t\t\t\tvalue: value,\n\t\t\t\ttestValue: myArray{\n\t\t\t\t\tmyInt(123),\n\t\t\t\t\t456.0,\n\t\t\t\t\tmyArray{myInt(789), 567.0},\n\t\t\t\t\tmyMap{\"a\": \"b\"},\n\t\t\t\t},\n\t\t\t\tresult: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.value).InList(tc.testValue).\n\t\t\t\t\tchain.assert(t, tc.result)\n\n\t\t\t\tNewArray(reporter, tc.value).NotInList(tc.testValue).\n\t\t\t\t\tchain.assert(t, !tc.result)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname     string\n\t\t\tvalue    []interface{}\n\t\t\ttestList []interface{}\n\t\t}{\n\t\t\t{\n\t\t\t\tname:     \"empty list\",\n\t\t\t\tvalue:    []interface{}{},\n\t\t\t\ttestList: []interface{}{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"nil list\",\n\t\t\t\tvalue:    []interface{}{},\n\t\t\t\ttestList: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"invalid type\",\n\t\t\t\tvalue:    []interface{}{},\n\t\t\t\ttestList: []interface{}{func() {}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"one equal array, another not array\",\n\t\t\t\tvalue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\t[]interface{}{\"foo\", \"bar\"},\n\t\t\t\t\t\"NOT ARRAY\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"one inequal array, another not array\",\n\t\t\t\tvalue: []interface{}{\"foo\", \"bar\"},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\t[]interface{}{\"bar\", \"foo\"},\n\t\t\t\t\t\"NOT ARRAY\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.value).InList(tc.testList...).\n\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\tNewArray(reporter, tc.value).NotInList(tc.testList...).\n\t\t\t\t\tchain.assert(t, failure)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestArray_ConsistsOf(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname           string\n\t\t\tarray          []interface{}\n\t\t\tvalue          []interface{}\n\t\t\twantConsistsOf chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:           \"first value (int) in array\",\n\t\t\t\tarray:          []interface{}{123, \"foo\"},\n\t\t\t\tvalue:          []interface{}{123},\n\t\t\t\twantConsistsOf: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"second value (string) in array\",\n\t\t\t\tarray:          []interface{}{123, \"foo\"},\n\t\t\t\tvalue:          []interface{}{\"foo\"},\n\t\t\t\twantConsistsOf: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"reversed order\",\n\t\t\t\tarray:          []interface{}{123, \"foo\"},\n\t\t\t\tvalue:          []interface{}{\"foo\", 123},\n\t\t\t\twantConsistsOf: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"duplicate element\",\n\t\t\t\tarray:          []interface{}{123, \"foo\"},\n\t\t\t\tvalue:          []interface{}{\"foo\", \"foo\", 123},\n\t\t\t\twantConsistsOf: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"copy of array\",\n\t\t\t\tarray:          []interface{}{123, \"foo\"},\n\t\t\t\tvalue:          []interface{}{123, \"foo\"},\n\t\t\t\twantConsistsOf: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).ConsistsOf(tc.value...).\n\t\t\t\t\tchain.assert(t, tc.wantConsistsOf)\n\n\t\t\t\tNewArray(reporter, tc.array).NotConsistsOf(tc.value...).\n\t\t\t\t\tchain.assert(t, !tc.wantConsistsOf)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{123, 456}).ConsistsOf(myInt(123), 456.0).\n\t\t\tchain.assert(t, success)\n\n\t\tNewArray(reporter, []interface{}{123, 456}).NotConsistsOf(myInt(123), 456.0).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).ConsistsOf(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotConsistsOf(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_Contains(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname         string\n\t\t\tarray        []interface{}\n\t\t\tvalue        interface{}\n\t\t\twantContains chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:         \"first value in array\",\n\t\t\t\tarray:        []interface{}{123, \"foo\"},\n\t\t\t\tvalue:        123,\n\t\t\t\twantContains: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:         \"second value in array\",\n\t\t\t\tarray:        []interface{}{123, \"foo\"},\n\t\t\t\tvalue:        \"foo\",\n\t\t\t\twantContains: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:         \"value not in array\",\n\t\t\t\tarray:        []interface{}{123, \"foo\"},\n\t\t\t\tvalue:        \"FOO\",\n\t\t\t\twantContains: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:         \"array\",\n\t\t\t\tarray:        []interface{}{123, \"foo\"},\n\t\t\t\tvalue:        []interface{}{123, \"foo\"},\n\t\t\t\twantContains: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).Contains(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContains)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContains(tc.value).\n\t\t\t\t\tchain.assert(t, !tc.wantContains)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\t\tcases := []struct {\n\t\t\tname         string\n\t\t\tarray        []interface{}\n\t\t\tvalue        interface{}\n\t\t\twantContains chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:         \"myInt check\",\n\t\t\t\tarray:        []interface{}{123, 456},\n\t\t\t\tvalue:        myInt(123),\n\t\t\t\twantContains: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:         \"float to int check\",\n\t\t\t\tarray:        []interface{}{123, 456},\n\t\t\t\tvalue:        456.0,\n\t\t\t\twantContains: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).Contains(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContains)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContains(tc.value).\n\t\t\t\t\tchain.assert(t, !tc.wantContains)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).Contains(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotContains(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_ContainsAll(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname            string\n\t\t\tarray           []interface{}\n\t\t\tvalue           []interface{}\n\t\t\twantContainsAll chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:            \"first element\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{123},\n\t\t\t\twantContainsAll: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"second element\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{\"foo\"},\n\t\t\t\twantContainsAll: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"element not in array\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{\"FOO\"},\n\t\t\t\twantContainsAll: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"array copy\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{123, \"foo\"},\n\t\t\t\twantContainsAll: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"double valid elements\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{\"foo\", \"foo\"},\n\t\t\t\twantContainsAll: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"array with one invalid element\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{123, \"foo\", \"FOO\"},\n\t\t\t\twantContainsAll: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"subset of array\",\n\t\t\t\tarray:           []interface{}{123, \"foo\", \"bar\"},\n\t\t\t\tvalue:           []interface{}{\"bar\", \"foo\"},\n\t\t\t\twantContainsAll: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).ContainsAll(tc.value...).\n\t\t\t\t\tchain.assert(t, tc.wantContainsAll)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContainsAll(tc.value...).\n\t\t\t\t\tchain.assert(t, !tc.wantContainsAll)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{123, 456}).ContainsAll(myInt(123), 456.0).\n\t\t\tchain.assert(t, success)\n\n\t\tNewArray(reporter, []interface{}{123, 456}).NotContainsAll(myInt(123), 456.0).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).ContainsAll(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotContainsAll(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_ContainsAny(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname            string\n\t\t\tarray           []interface{}\n\t\t\tvalue           []interface{}\n\t\t\twantContainsAny chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:            \"first element\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{123},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"copy of array\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{\"foo\", 123},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"double valid elements\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{\"foo\", \"foo\"},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"array with one invalid element\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{123, \"foo\", \"FOO\"},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"invalid element\",\n\t\t\t\tarray:           []interface{}{123, \"foo\"},\n\t\t\t\tvalue:           []interface{}{\"FOO\"},\n\t\t\t\twantContainsAny: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"subset of array\",\n\t\t\t\tarray:           []interface{}{123, \"foo\", \"bar\"},\n\t\t\t\tvalue:           []interface{}{\"bar\", \"foo\"},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t}\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).ContainsAny(tc.value...).\n\t\t\t\t\tchain.assert(t, tc.wantContainsAny)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContainsAny(tc.value...).\n\t\t\t\t\tchain.assert(t, !tc.wantContainsAny)\n\t\t\t})\n\t\t}\n\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt   int\n\t\t\tmyArray []interface{}\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname            string\n\t\t\tarray           []interface{}\n\t\t\tvalue           []interface{}\n\t\t\twantContainsAny chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:            \"int float check\",\n\t\t\t\tarray:           []interface{}{123, 789, \"foo\", []interface{}{567, 456}},\n\t\t\t\tvalue:           []interface{}{myInt(123), 789.0},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:            \"array check\",\n\t\t\t\tarray:           []interface{}{123, 789, \"foo\", []interface{}{567, 456}},\n\t\t\t\tvalue:           []interface{}{myArray{567.0, 456.0}},\n\t\t\t\twantContainsAny: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).\n\t\t\t\t\tContainsAny(tc.value...).chain.assert(t, tc.wantContainsAny)\n\n\t\t\t\tNewArray(reporter, tc.array).\n\t\t\t\t\tNotContainsAny(tc.value...).chain.assert(t, !tc.wantContainsAny)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).ContainsAny(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotContainsAny(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_ContainsOnly(t *testing.T) {\n\tt.Run(\"without duplicates\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname             string\n\t\t\tarray            []interface{}\n\t\t\tvalue            []interface{}\n\t\t\twantContainsOnly chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:             \"first element\",\n\t\t\t\tarray:            []interface{}{123, \"foo\"},\n\t\t\t\tvalue:            []interface{}{123},\n\t\t\t\twantContainsOnly: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"second element\",\n\t\t\t\tarray:            []interface{}{123, \"foo\"},\n\t\t\t\tvalue:            []interface{}{\"foo\"},\n\t\t\t\twantContainsOnly: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"copy of array\",\n\t\t\t\tarray:            []interface{}{123, \"foo\"},\n\t\t\t\tvalue:            []interface{}{123, \"foo\"},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"copy of array with one valid value added\",\n\t\t\t\tarray:            []interface{}{123, \"foo\"},\n\t\t\t\tvalue:            []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"different order of array\",\n\t\t\t\tarray:            []interface{}{123, \"foo\"},\n\t\t\t\tvalue:            []interface{}{\"foo\", 123},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"copy of array with one invalid value added\",\n\t\t\t\tarray:            []interface{}{123, \"foo\"},\n\t\t\t\tvalue:            []interface{}{\"foo\", 123, \"bar\"},\n\t\t\t\twantContainsOnly: failure,\n\t\t\t},\n\t\t}\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).ContainsOnly(tc.value...).\n\t\t\t\t\tchain.assert(t, tc.wantContainsOnly)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContainsOnly(tc.value...).\n\t\t\t\t\tchain.assert(t, !tc.wantContainsOnly)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"with duplicates\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname             string\n\t\t\tarray            []interface{}\n\t\t\tvalue            []interface{}\n\t\t\twantContainsOnly chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:             \"copy of array with no duplicates\",\n\t\t\t\tarray:            []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\tvalue:            []interface{}{123, \"foo\"},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"copy of no duplicates array with other element duplciated\",\n\t\t\t\tarray:            []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\tvalue:            []interface{}{123, 123, \"foo\"},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"copy of array\",\n\t\t\t\tarray:            []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\tvalue:            []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"copy of array reordered\",\n\t\t\t\tarray:            []interface{}{123, \"foo\", \"foo\"},\n\t\t\t\tvalue:            []interface{}{\"foo\", 123, \"foo\"},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).ContainsOnly(tc.value...).\n\t\t\t\t\tchain.assert(t, tc.wantContainsOnly)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContainsOnly(tc.value...).\n\t\t\t\t\tchain.assert(t, !tc.wantContainsOnly)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname             string\n\t\t\tarray            []interface{}\n\t\t\tvalue            []interface{}\n\t\t\twantContainsOnly chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:             \"float variable\",\n\t\t\t\tarray:            []interface{}{123, 456, 456},\n\t\t\t\tvalue:            []interface{}{456.0},\n\t\t\t\twantContainsOnly: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:             \"myInt and float variable\",\n\t\t\t\tarray:            []interface{}{123, 456, 456},\n\t\t\t\tvalue:            []interface{}{myInt(123), 456.0},\n\t\t\t\twantContainsOnly: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).ContainsOnly(tc.value...).\n\t\t\t\t\tchain.assert(t, tc.wantContainsOnly)\n\n\t\t\t\tNewArray(reporter, tc.array).NotContainsOnly(tc.value...).\n\t\t\t\t\tchain.assert(t, !tc.wantContainsOnly)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{}).ContainsOnly(func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{}).NotContainsOnly(func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_HasValue(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname            string\n\t\t\tarray           []interface{}\n\t\t\tindex           int\n\t\t\tvalue           interface{}\n\t\t\twantHasValue    chainResult\n\t\t\twantNotHasValue chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"index zero check\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           0,\n\t\t\t\tvalue:           123,\n\t\t\t\twantHasValue:    success,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"index one check\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           1,\n\t\t\t\tvalue:           []interface{}{\"456\", 789},\n\t\t\t\twantHasValue:    success,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"index two check\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           2,\n\t\t\t\tvalue:           map[string]interface{}{\"a\": \"b\"},\n\t\t\t\twantHasValue:    success,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"out of bounds check\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           3,\n\t\t\t\tvalue:           777,\n\t\t\t\twantHasValue:    failure,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"wrong value check\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           0,\n\t\t\t\tvalue:           777,\n\t\t\t\twantHasValue:    failure,\n\t\t\t\twantNotHasValue: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).HasValue(tc.index, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantHasValue)\n\n\t\t\t\tNewArray(reporter, tc.array).NotHasValue(tc.index, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotHasValue)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttype (\n\t\t\tA struct {\n\t\t\t\tB int `json:\"b\"`\n\t\t\t\tC int `json:\"c\"`\n\t\t\t}\n\n\t\t\tBaz struct {\n\t\t\t\tA A `json:\"a\"`\n\t\t\t}\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname            string\n\t\t\tarray           []interface{}\n\t\t\tindex           int\n\t\t\tvalue           interface{}\n\t\t\twantHasValue    chainResult\n\t\t\twantNotHasValue chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"struct comparison\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\t\t\"c\": 444,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: Baz{\n\t\t\t\t\tA: A{\n\t\t\t\t\t\tB: 333,\n\t\t\t\t\t\tC: 444,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantHasValue:    success,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"empty struct comparison\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\t\t\"c\": 444,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           0,\n\t\t\t\tvalue:           Baz{},\n\t\t\t\twantHasValue:    failure,\n\t\t\t\twantNotHasValue: success,\n\t\t\t},\n\t\t}\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).HasValue(tc.index, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantHasValue)\n\n\t\t\t\tNewArray(reporter, tc.array).NotHasValue(tc.index, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotHasValue)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyArray []interface{}\n\t\t\tmyMap   map[string]interface{}\n\t\t\tmyInt   int\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname            string\n\t\t\tarray           []interface{}\n\t\t\tindex           int\n\t\t\tvalue           interface{}\n\t\t\twantHasValue    chainResult\n\t\t\twantNotHasValue chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"myArray and myInt testing\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           1,\n\t\t\t\tvalue:           myArray{\"456\", myInt(789)},\n\t\t\t\twantHasValue:    success,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"myMap testing\",\n\t\t\t\tarray: []interface{}{\n\t\t\t\t\t123,\n\t\t\t\t\t[]interface{}{\"456\", 789},\n\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\"a\": \"b\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tindex:           2,\n\t\t\t\tvalue:           myMap{\"a\": \"b\"},\n\t\t\t\twantHasValue:    success,\n\t\t\t\twantNotHasValue: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewArray(reporter, tc.array).HasValue(tc.index, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantHasValue)\n\n\t\t\t\tNewArray(reporter, tc.array).NotHasValue(tc.index, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotHasValue)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewArray(reporter, []interface{}{1, 2, 3}).HasValue(1, func() {}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewArray(reporter, []interface{}{1, 2, 3}).NotHasValue(1, func() {}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_Iter(t *testing.T) {\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tdata := []interface{}{}\n\n\t\tvalue := NewArray(reporter, data)\n\n\t\tit := value.Iter()\n\n\t\tassert.NotNil(t, it)\n\t\tassert.Equal(t, 0, len(data), it)\n\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"not empty\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tdata := []interface{}{\"foo\", 123.0}\n\n\t\tvalue := NewArray(reporter, data)\n\n\t\tit := value.Iter()\n\n\t\tassert.NotNil(t, it)\n\t\tassert.Equal(t, 2, len(it))\n\t\tassert.Equal(t, \"foo\", it[0].Raw())\n\t\tassert.Equal(t, 123.0, it[1].Raw())\n\n\t\tvalue.chain.assert(t, success)\n\t})\n}\n\nfunc TestArray_Every(t *testing.T) {\n\tt.Run(\"check value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{2, 4, 6})\n\n\t\tinvoked := 0\n\t\tarray.Every(func(_ int, val *Value) {\n\t\t\tif v, ok := val.Raw().(float64); ok {\n\t\t\t\tinvoked++\n\t\t\t\tassert.Equal(t, 0, int(v)%2)\n\t\t\t}\n\t\t})\n\n\t\tassert.Equal(t, 3, invoked)\n\t\tarray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"check index\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, 3})\n\n\t\tinvoked := 0\n\t\tarray.Every(func(idx int, val *Value) {\n\t\t\tif v, ok := val.Raw().(float64); ok {\n\t\t\t\tinvoked++\n\t\t\t\tassert.Equal(t, idx, int(v)-1)\n\t\t\t}\n\t\t})\n\n\t\tassert.Equal(t, 3, invoked)\n\t\tarray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty array\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{})\n\n\t\tinvoked := 0\n\t\tarray.Every(func(_ int, val *Value) {\n\t\t\tinvoked++\n\t\t})\n\n\t\tassert.Equal(t, 0, invoked)\n\t\tarray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"one assertion fails\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{\"foo\", \"\", \"bar\"})\n\n\t\tinvoked := 0\n\t\tarray.Every(func(_ int, val *Value) {\n\t\t\tinvoked++\n\t\t\tval.String().NotEmpty()\n\t\t})\n\n\t\tassert.Equal(t, 3, invoked)\n\t\tarray.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"all assertions fail\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{\"\", \"\", \"\"})\n\n\t\tinvoked := 0\n\t\tarray.Every(func(_ int, val *Value) {\n\t\t\tinvoked++\n\t\t\tval.String().NotEmpty()\n\t\t})\n\n\t\tassert.Equal(t, 3, invoked)\n\t\tarray.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, 3})\n\t\tarray.Every((func(index int, value *Value))(nil))\n\t\tarray.chain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_Transform(t *testing.T) {\n\tt.Run(\"check index\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, 3})\n\n\t\tnewArray := array.Transform(func(idx int, val interface{}) interface{} {\n\t\t\tif v, ok := val.(float64); ok {\n\t\t\t\tassert.Equal(t, idx, int(v)-1)\n\t\t\t}\n\t\t\treturn val\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{float64(1), float64(2), float64(3)}, newArray.value)\n\t\tnewArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"transform value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{2, 4, 6})\n\n\t\tnewArray := array.Transform(func(_ int, val interface{}) interface{} {\n\t\t\tif v, ok := val.(float64); ok {\n\t\t\t\treturn int(v) * int(v)\n\t\t\t}\n\t\t\tt.Errorf(\"failed transformation\")\n\t\t\treturn nil\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{float64(4), float64(16), float64(36)}, newArray.value)\n\t\tnewArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty array\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{})\n\n\t\tnewArray := array.Transform(func(_ int, _ interface{}) interface{} {\n\t\t\tt.Errorf(\"failed transformation\")\n\t\t\treturn nil\n\t\t})\n\n\t\tnewArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{2, 4, 6})\n\n\t\tnewArray := array.Transform(nil)\n\n\t\tnewArray.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{2, 4, 6})\n\n\t\tnewArray := array.Transform(func(_ int, val interface{}) interface{} {\n\t\t\tif val, ok := val.(float64); ok {\n\t\t\t\treturn myInt(val)\n\t\t\t}\n\t\t\tt.Errorf(\"failed transformation\")\n\t\t\treturn nil\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{2.0, 4.0, 6.0}, newArray.Raw())\n\t\tnewArray.chain.assert(t, success)\n\t})\n}\n\nfunc TestArray_Filter(t *testing.T) {\n\tt.Run(\"elements of same type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, 3, 4, 5, 6})\n\n\t\tfilteredArray := array.Filter(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() != 2.0 && value.Raw() != 5.0\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{1.0, 3.0, 4.0, 6.0}, filteredArray.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0, 3.0, 4.0, 5.0, 6.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfilteredArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"elements of different types\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{\"foo\", \"bar\", true, 1.0})\n\n\t\tfilteredArray := array.Filter(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() != \"bar\"\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{\"foo\", true, 1.0}, filteredArray.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{\"foo\", \"bar\", true, 1.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfilteredArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty array\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{})\n\n\t\tfilteredArray := array.Filter(func(index int, value *Value) bool {\n\t\t\treturn false\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{}, filteredArray.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{})\n\n\t\tarray.chain.assert(t, success)\n\t\tfilteredArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{\"foo\", \"bar\", true, 1.0})\n\n\t\tfilteredArray := array.Filter(func(index int, value *Value) bool {\n\t\t\treturn false\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{}, filteredArray.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{\"foo\", \"bar\", true, 1.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfilteredArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"assertion fails\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1.0, \"foo\", \"bar\", 4.0, \"baz\", 6.0})\n\n\t\tfilteredArray := array.Filter(func(index int, value *Value) bool {\n\t\t\tstringifiedValue := value.String().NotEmpty().Raw()\n\t\t\treturn stringifiedValue != \"bar\"\n\t\t})\n\n\t\tassert.Equal(t, []interface{}{\"foo\", \"baz\"}, filteredArray.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, \"foo\", \"bar\", 4.0, \"baz\", 6.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfilteredArray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{\"foo\", \"bar\", true, 1.0})\n\t\tfilteredArray := array.Filter((func(index int, value *Value) bool)(nil))\n\t\tarray.chain.assert(t, failure)\n\t\tfilteredArray.chain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_Find(t *testing.T) {\n\tt.Run(\"elements of same type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, 3, 4, 5, 6})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0\n\t\t})\n\n\t\tassert.Equal(t, 2.0, foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0, 3.0, 4.0, 5.0, 6.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfoundValue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"elements of different types\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, \"foo\", true, \"bar\"})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\tstringifiedValue := value.String().NotEmpty().Raw()\n\t\t\treturn stringifiedValue == \"bar\"\n\t\t})\n\n\t\tassert.Equal(t, \"bar\", foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tarray.chain.assert(t, success)\n\t\tfoundValue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"first match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, \"foo\", true, \"bar\"})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\tstringifiedValue := value.String().Raw()\n\t\t\treturn stringifiedValue != \"\"\n\t\t})\n\n\t\tassert.Equal(t, \"foo\", foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tarray.chain.assert(t, success)\n\t\tfoundValue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, \"foo\", true, \"bar\"})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0\n\t\t})\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tarray.chain.assert(t, failure)\n\t\tfoundValue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"empty array\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0\n\t\t})\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{})\n\n\t\tarray.chain.assert(t, failure)\n\t\tfoundValue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0})\n\n\t\tarray.chain.assert(t, failure)\n\t\tfoundValue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, have match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, \"str\"})\n\n\t\tfoundValue := array.Find(func(index int, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Equal(t, \"str\", foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0, \"str\"})\n\n\t\tarray.chain.assert(t, success)\n\t\tfoundValue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2})\n\n\t\tfoundValue := array.Find(nil)\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0})\n\n\t\tarray.chain.assert(t, failure)\n\t\tfoundValue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_FindAll(t *testing.T) {\n\tt.Run(\"elements of same type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, 3, 4, 5, 6})\n\n\t\tfoundValues := array.FindAll(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0 || value.Raw() == 5.0\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{2.0, 5.0}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0, 3.0, 4.0, 5.0, 6.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t})\n\n\tt.Run(\"elements of different types\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tfoundValues := array.FindAll(func(index int, value *Value) bool {\n\t\t\tstringifiedValue := value.String().Raw()\n\t\t\treturn stringifiedValue != \"\"\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{\"foo\", \"bar\"}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tarray.chain.assert(t, success)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t})\n\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tfoundValues := array.FindAll(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, \"foo\", true, \"bar\"})\n\n\t\tarray.chain.assert(t, success)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t})\n\n\tt.Run(\"empty array\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{})\n\n\t\tfoundValues := array.FindAll(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{})\n\n\t\tarray.chain.assert(t, success)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2})\n\n\t\tfoundValues := array.FindAll(func(index int, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0})\n\n\t\tarray.chain.assert(t, success)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, have matches\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{\"foo\", 1, 2, \"bar\"})\n\n\t\tfoundValues := array.FindAll(func(index int, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{\"foo\", \"bar\"}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{\"foo\", 1.0, 2.0, \"bar\"})\n\n\t\tarray.chain.assert(t, success)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2})\n\n\t\tfoundValues := array.FindAll(nil)\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, array.Raw(), []interface{}{1.0, 2.0})\n\n\t\tarray.chain.assert(t, failure)\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, failure)\n\t\t}\n\t})\n}\n\nfunc TestArray_NotFind(t *testing.T) {\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, \"foo\", true, \"bar\"})\n\n\t\tafterArray := array.NotFind(func(index int, value *Value) bool {\n\t\t\treturn value.String().Raw() == \"baz\"\n\t\t})\n\n\t\tassert.Same(t, array, afterArray)\n\t\tarray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"have match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, \"foo\", true, \"bar\"})\n\n\t\tafterArray := array.NotFind(func(index int, value *Value) bool {\n\t\t\treturn value.String().NotEmpty().Raw() == \"bar\"\n\t\t})\n\n\t\tassert.Same(t, array, afterArray)\n\t\tarray.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"empty array\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{})\n\n\t\tafterArray := array.NotFind(func(index int, value *Value) bool {\n\t\t\treturn value.Raw() == 2.0\n\t\t})\n\n\t\tassert.Same(t, array, afterArray)\n\t\tarray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2})\n\n\t\tafterArray := array.NotFind(func(index int, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Same(t, array, afterArray)\n\t\tarray.chain.assert(t, success)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, have match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2, \"str\"})\n\n\t\tafterArray := array.NotFind(func(index int, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Same(t, array, afterArray)\n\t\tarray.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tarray := NewArray(reporter, []interface{}{1, 2})\n\n\t\tafterArray := array.NotFind(nil)\n\n\t\tassert.Same(t, array, afterArray)\n\t\tarray.chain.assert(t, failure)\n\t})\n}\n\nfunc TestArray_IsOrdered(t *testing.T) {\n\ttype args struct {\n\t\tvalues      []interface{}\n\t\tless        []func(x, y *Value) bool\n\t\tchainFailed bool\n\t}\n\tcases := []struct {\n\t\tname        string\n\t\targs        args\n\t\tisInvalid   bool\n\t\tisOrdered   bool\n\t\tisUnordered bool\n\t}{\n\t\t{\n\t\t\tname: \"booleans ordered\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{false, false, true, true},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: false,\n\t\t},\n\t\t{\n\t\t\tname: \"booleans unordered\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{true, false, true, false},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   false,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"numbers ordered\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, 1, 2, 3},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: false,\n\t\t},\n\t\t{\n\t\t\tname: \"numbers unordered\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{3, 1, 1, 2},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   false,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"strings ordered\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{\"\", \"a\", \"b\", \"ba\"},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: false,\n\t\t},\n\t\t{\n\t\t\tname: \"strings unordered\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{\"z\", \"y\", \"x\", \"\"},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   false,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"all nils\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{nil, nil, nil},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: false,\n\t\t},\n\t\t{\n\t\t\tname: \"reversed\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{3, 2, 1},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   false,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"user-defined less function\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, 2, 3},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\tvalX := x.Number().Raw()\n\t\t\t\t\t\tvalY := y.Number().Raw()\n\t\t\t\t\t\treturn valX < valY\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: false,\n\t\t},\n\t\t{\n\t\t\tname: \"user-defined less function, negated\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, 2, 3},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\tvalX := x.Number().Raw()\n\t\t\t\t\t\tvalY := y.Number().Raw()\n\t\t\t\t\t\treturn valX >= valY\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   false,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty array\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one element\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"empty array, custom func\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\tpanic(\"test\")\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"one element, custom func\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\tpanic(\"test\")\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid:   false,\n\t\t\tisOrdered:   true,\n\t\t\tisUnordered: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid, assertion failed\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, 2, 3},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\tx.String()\n\t\t\t\t\t\ty.String()\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid, multiple arguments\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, 2, 3},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t\tfunc(x, y *Value) bool {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid, nil argument\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, 2, 3},\n\t\t\t\tless: []func(x, y *Value) bool{\n\t\t\t\t\tnil,\n\t\t\t\t},\n\t\t\t},\n\t\t\tisInvalid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid, unsupported type\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{[]int{1, 2}, []int{3, 4}, []int{5, 6}},\n\t\t\t\tless:   []func(x, y *Value) bool{},\n\t\t\t},\n\t\t\tisInvalid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid, multiple types\",\n\t\t\targs: args{\n\t\t\t\tvalues: []interface{}{1, \"abc\", true},\n\t\t\t\tless:   []func(x, y *Value) bool{},\n\t\t\t},\n\t\t\tisInvalid: true,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid, failed chain\",\n\t\t\targs: args{\n\t\t\t\tchainFailed: true,\n\t\t\t},\n\t\t\tisInvalid: true,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tif tc.isInvalid {\n\t\t\t\tt.Run(\"normal\", func(t *testing.T) {\n\t\t\t\t\tNewArray(reporter, tc.args.values).IsOrdered(tc.args.less...).\n\t\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\t\tNewArray(reporter, tc.args.values).NotOrdered(tc.args.less...).\n\t\t\t\t\t\tchain.assert(t, failure)\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"reversed\", func(t *testing.T) {\n\t\t\t\t\t// reverse slice\n\t\t\t\t\tsort.SliceStable(tc.args.values, func(i, j int) bool {\n\t\t\t\t\t\treturn i > j\n\t\t\t\t\t})\n\n\t\t\t\t\tNewArray(reporter, tc.args.values).IsOrdered(tc.args.less...).\n\t\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\t\tNewArray(reporter, tc.args.values).NotOrdered(tc.args.less...).\n\t\t\t\t\t\tchain.assert(t, failure)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tt.Run(\"is ordered\", func(t *testing.T) {\n\t\t\t\t\tif tc.isOrdered {\n\t\t\t\t\t\tNewArray(reporter, tc.args.values).IsOrdered(tc.args.less...).\n\t\t\t\t\t\t\tchain.assert(t, success)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNewArray(reporter, tc.args.values).IsOrdered(tc.args.less...).\n\t\t\t\t\t\t\tchain.assert(t, failure)\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tt.Run(\"not ordered\", func(t *testing.T) {\n\t\t\t\t\tif tc.isUnordered {\n\t\t\t\t\t\tNewArray(reporter, tc.args.values).NotOrdered(tc.args.less...).\n\t\t\t\t\t\t\tchain.assert(t, success)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNewArray(reporter, tc.args.values).NotOrdered(tc.args.less...).\n\t\t\t\t\t\t\tchain.assert(t, failure)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestArray_ComparatorErrors(t *testing.T) {\n\tt.Run(\"nil slice\", func(t *testing.T) {\n\t\tchain := newMockChain(t).enter(\"test\")\n\n\t\tfn := builtinComparator(chain, nil)\n\n\t\tassert.Nil(t, fn)\n\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"0 elements\", func(t *testing.T) {\n\t\tchain := newMockChain(t).enter(\"test\")\n\n\t\tfn := builtinComparator(chain, []interface{}{})\n\n\t\tassert.Nil(t, fn)\n\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"1 element\", func(t *testing.T) {\n\t\tchain := newMockChain(t).enter(\"test\")\n\n\t\tfn := builtinComparator(chain, []interface{}{\n\t\t\t\"test\",\n\t\t})\n\n\t\tassert.Nil(t, fn)\n\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"2 elements, bad_type\", func(t *testing.T) {\n\t\tchain := newMockChain(t).enter(\"test\")\n\n\t\tfn := builtinComparator(chain, []interface{}{\n\t\t\t\"test\",\n\t\t\tmake(chan int), // bad type\n\t\t})\n\n\t\tassert.Nil(t, fn)\n\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"2 elements, good types\", func(t *testing.T) {\n\t\tchain := newMockChain(t).enter(\"test\")\n\n\t\tfn := builtinComparator(chain, []interface{}{\n\t\t\t\"test\",\n\t\t\t\"test\",\n\t\t})\n\n\t\tassert.NotNil(t, fn)\n\t\tchain.assert(t, success)\n\t})\n}\n"
        },
        {
          "name": "assertion.go",
          "type": "blob",
          "size": 8.1689453125,
          "content": "package httpexpect\n\n// AssertionType defines type of performed assertion.\ntype AssertionType uint\n\n//go:generate stringer -type=AssertionType\nconst (\n\t// Check if the invocation is correct\n\tAssertUsage AssertionType = iota\n\n\t// Check if the operation succeeded\n\tAssertOperation\n\n\t// Check expression: [Actual] has appropriate type\n\tAssertType\n\tAssertNotType\n\n\t// Check expression: [Actual] has valid value\n\tAssertValid\n\tAssertNotValid\n\n\t// Check expression: [Actual] is nil\n\tAssertNil\n\tAssertNotNil\n\n\t// Check expression: [Actual] is empty\n\tAssertEmpty\n\tAssertNotEmpty\n\n\t// Check expression: [Actual] is equal to [Expected]\n\t// If [Delta] is set, it specifies allowed difference between values\n\tAssertEqual\n\tAssertNotEqual\n\n\t// Check expression: [Actual] < [Expected]\n\tAssertLt\n\t// Check expression: [Actual] <= [Expected]\n\tAssertLe\n\t// Check expression: [Actual] > [Expected]\n\tAssertGt\n\t// Check expression: [Actual] >= [Expected]\n\tAssertGe\n\n\t// Check expression: [Actual] belongs to inclusive range [Expected]\n\t// [Expected] stores AssertionRange with Min and Max values\n\tAssertInRange\n\tAssertNotInRange\n\n\t// Check expression: [Actual] matches json schema [Expected]\n\t// [Expected] stores map with parsed schema or string with schema uri\n\tAssertMatchSchema\n\tAssertNotMatchSchema\n\n\t// Check expression: [Actual] matches json path [Expected]\n\t// [Expected] stores a string with json path\n\tAssertMatchPath\n\tAssertNotMatchPath\n\n\t// Check expression: [Actual] matches regex [Expected]\n\t// [Expected] stores a string with regular expression\n\tAssertMatchRegexp\n\tAssertNotMatchRegexp\n\n\t// Check expression: [Actual] matches format [Expected]\n\t// [Expected] stores expected format or format list (AssertionList)\n\tAssertMatchFormat\n\tAssertNotMatchFormat\n\n\t// Check expression: [Actual] contains key [Expected]\n\tAssertContainsKey\n\tAssertNotContainsKey\n\n\t// Check expression: [Actual] contains element [Expected]\n\tAssertContainsElement\n\tAssertNotContainsElement\n\n\t// Check expression: [Actual] contains subset [Expected]\n\tAssertContainsSubset\n\tAssertNotContainsSubset\n\n\t// Check expression: [Actual] belongs to list [Expected]\n\t// [Expected] stores AssertionList with allowed values\n\tAssertBelongs\n\tAssertNotBelongs\n)\n\n// AssertionSeverity defines how assertion failure should be treated.\ntype AssertionSeverity uint\n\n//go:generate stringer -type=AssertionSeverity\nconst (\n\t// This assertion failure should mark current test as failed.\n\t// Typically handler will call t.Errorf().\n\t// This severity is used for most assertions.\n\tSeverityError AssertionSeverity = iota\n\n\t// This assertion failure is informational only, it can be logged,\n\t// but should not cause test failure.\n\t// Typically handler will call t.Logf(), or just ignore assertion.\n\t// This severity is used for assertions issued inside predicate functions,\n\t// e.g. in Array.Filter and Object.Filter.\n\tSeverityLog\n)\n\n// AssertionContext provides context where the assetion happened.\ntype AssertionContext struct {\n\t// Name of the running test\n\t// Usually comes from testing.T\n\tTestName string\n\n\t// Name of request being sent\n\t// Comes from Request.WithName()\n\tRequestName string\n\n\t// Chain of nested assertion names\n\t// Example value:\n\t//   {`Request(\"GET\")`, `Expect()`, `JSON()`, `NotNull()`}\n\tPath []string\n\n\t// Chain of nested assertion names starting from alias\n\t// When alias is not set, AliasedPath has the same value as Path\n\t// Example value:\n\t//   {`foo`, `NotNull()`} // alias named foo\n\tAliasedPath []string\n\n\t// Request being sent\n\t// May be nil if request was not yet sent\n\tRequest *Request\n\n\t// Response being matched\n\t// May be nil if response was not yet received\n\tResponse *Response\n\n\t// Environment shared between tests\n\t// Comes from Expect instance\n\tEnvironment *Environment\n\n\t// Whether reporter is known to output to testing.TB\n\t// For example, true when reporter is testing.T or testify-based reporter.\n\tTestingTB bool\n}\n\n// AssertionFailure provides detailed information about failed assertion.\n//\n// [Type] and [Errors] fields are set for all assertions.\n// [Actual], [Expected], [Reference], and [Delta] fields are set only for\n// certain assertion types.\n//\n// The value itself is stored in [Actual.Value], [Expected.Value], etc.\n// It allows to distinguish whether the value is not present at all,\n// or is present but is nil.\n//\n// [Actual] stores the value being examined.\n//\n// Exact meaning of [Expected] depends on assertion type. It may be the value\n// to which [Actual] was compared, or range to which [Actual] should belong,\n// or pattern with which [Actual] should match, or element which [Actual]\n// should contain, and so on.\n//\n// If [Reference] is set, it stores the value from which the check originated.\n// For example, the user asked to check for unordered equality of arrays\n// A and B. During comparison, a check failed that array A contains element E\n// from array B. In this case [Actual] will be set to A (actually observed array),\n// [Expected] will be set to E (expected but missing element), and [Reference]\n// will be set to B (reference array that originated the check).\n//\n// If [Delta] is set, it stores maximum allowed difference between [Actual]\n// and [Expected] values.\n//\n// For further details, see comments for corresponding AssertionType constant.\ntype AssertionFailure struct {\n\t// Type of failed assertion\n\tType AssertionType\n\n\t// Severity of failure\n\tSeverity AssertionSeverity\n\n\t// Deprecated: use Severity\n\tIsFatal bool\n\n\t// List of error messages\n\tErrors []error\n\n\t// Actually observed value\n\tActual *AssertionValue\n\n\t// Expected value\n\tExpected *AssertionValue\n\n\t// Reference value\n\tReference *AssertionValue\n\n\t// Allowed delta between actual and expected\n\tDelta *AssertionValue\n\n\t// Stacktrace of the failure\n\tStacktrace []StacktraceEntry\n}\n\n// AssertionValue holds expected or actual value\ntype AssertionValue struct {\n\tValue interface{}\n}\n\n// AssertionRange holds inclusive range for allowed values\ntype AssertionRange struct {\n\tMin interface{}\n\tMax interface{}\n}\n\n// AssertionList holds list of allowed values\ntype AssertionList []interface{}\n\n// AssertionHandler takes care of formatting and reporting test Failure or Success.\n//\n// You can log every performed assertion, or report only failures. You can implement\n// custom formatting, for example, provide a JSON output for ulterior processing.\n//\n// Usually you don't need to implement AssertionHandler; instead you can implement\n// Reporter, which is much simpler, and use it with DefaultAssertionHandler.\ntype AssertionHandler interface {\n\t// Invoked every time when an assertion succeeded.\n\t// May ignore failure, or log it, e.g. using t.Logf().\n\tSuccess(*AssertionContext)\n\n\t// Invoked every time when an assertion failed.\n\t// Handling depends on Failure.Severity field:\n\t//  - for SeverityError, reports failure to testing suite, e.g. using t.Errorf()\n\t//  - for SeverityLog, ignores failure, or logs it, e.g. using t.Logf()\n\tFailure(*AssertionContext, *AssertionFailure)\n}\n\n// DefaultAssertionHandler is default implementation for AssertionHandler.\n//\n//   - Formatter is used to format success and failure messages\n//   - Reporter is used to report formatted fatal failure messages\n//   - Logger is used to print formatted success and non-fatal failure messages\n//\n// Formatter and Reporter are required. Logger is optional.\n// By default httpexpect creates DefaultAssertionHandler without Logger.\ntype DefaultAssertionHandler struct {\n\tFormatter Formatter\n\tReporter  Reporter\n\tLogger    Logger\n}\n\n// Success implements AssertionHandler.Success.\nfunc (h *DefaultAssertionHandler) Success(ctx *AssertionContext) {\n\tif h.Formatter == nil {\n\t\tpanic(\"DefaultAssertionHandler.Formatter is nil\")\n\t}\n\n\tif h.Logger == nil {\n\t\treturn\n\t}\n\n\tmsg := h.Formatter.FormatSuccess(ctx)\n\n\th.Logger.Logf(\"%s\", msg)\n}\n\n// Failure implements AssertionHandler.Failure.\nfunc (h *DefaultAssertionHandler) Failure(\n\tctx *AssertionContext, failure *AssertionFailure,\n) {\n\tif h.Formatter == nil {\n\t\tpanic(\"DefaultAssertionHandler.Formatter is nil\")\n\t}\n\n\tswitch failure.Severity {\n\tcase SeverityError:\n\t\tif h.Reporter == nil {\n\t\t\tpanic(\"DefaultAssertionHandler.Reporter is nil\")\n\t\t}\n\n\t\tmsg := h.Formatter.FormatFailure(ctx, failure)\n\n\t\th.Reporter.Errorf(\"%s\", msg)\n\n\tcase SeverityLog:\n\t\tif h.Logger == nil {\n\t\t\treturn\n\t\t}\n\n\t\tmsg := h.Formatter.FormatFailure(ctx, failure)\n\n\t\th.Logger.Logf(\"%s\", msg)\n\t}\n}\n"
        },
        {
          "name": "assertion_test.go",
          "type": "blob",
          "size": 14.060546875,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAssertion_Handler(t *testing.T) {\n\ttype test struct {\n\t\tformatter *mockFormatter\n\t\treporter  *mockReporter\n\t\tlogger    *mockLogger\n\n\t\thandler *DefaultAssertionHandler\n\t}\n\n\tcreateTest := func(t *testing.T, enableLogger bool) test {\n\t\tvar test test\n\n\t\ttest.handler = &DefaultAssertionHandler{}\n\n\t\ttest.formatter = newMockFormatter(t)\n\t\ttest.handler.Formatter = test.formatter\n\n\t\ttest.reporter = newMockReporter(t)\n\t\ttest.handler.Reporter = test.reporter\n\n\t\tif enableLogger {\n\t\t\ttest.logger = newMockLogger(t)\n\t\t\ttest.handler.Logger = test.logger\n\t\t}\n\n\t\treturn test\n\t}\n\n\tt.Run(\"success\", func(t *testing.T) {\n\t\ttest := createTest(t, true)\n\n\t\ttest.handler.Success(&AssertionContext{\n\t\t\tTestName: t.Name(),\n\t\t})\n\n\t\tassert.Equal(t, 1, test.formatter.formattedSuccess)\n\t\tassert.Equal(t, 0, test.formatter.formattedFailure)\n\n\t\tassert.True(t, test.logger.logged)\n\t\tassert.False(t, test.reporter.reported)\n\t})\n\n\tt.Run(\"success, no logger\", func(t *testing.T) {\n\t\ttest := createTest(t, false)\n\n\t\ttest.handler.Success(&AssertionContext{\n\t\t\tTestName: t.Name(),\n\t\t})\n\n\t\tassert.Equal(t, 0, test.formatter.formattedSuccess)\n\t\tassert.Equal(t, 0, test.formatter.formattedFailure)\n\n\t\tassert.Nil(t, test.logger)\n\t\tassert.False(t, test.reporter.reported)\n\t})\n\n\tt.Run(\"failure, severity info\", func(t *testing.T) {\n\t\ttest := createTest(t, true)\n\n\t\ttest.handler.Failure(\n\t\t\t&AssertionContext{\n\t\t\t\tTestName: t.Name(),\n\t\t\t},\n\t\t\t&AssertionFailure{\n\t\t\t\tType:     AssertValid,\n\t\t\t\tSeverity: SeverityLog,\n\t\t\t})\n\n\t\tassert.Equal(t, 0, test.formatter.formattedSuccess)\n\t\tassert.Equal(t, 1, test.formatter.formattedFailure)\n\n\t\tassert.True(t, test.logger.logged)\n\t\tassert.False(t, test.reporter.reported)\n\t})\n\n\tt.Run(\"failure, severity info, no logger\", func(t *testing.T) {\n\t\ttest := createTest(t, false)\n\n\t\ttest.handler.Failure(\n\t\t\t&AssertionContext{\n\t\t\t\tTestName: t.Name(),\n\t\t\t},\n\t\t\t&AssertionFailure{\n\t\t\t\tType:     AssertValid,\n\t\t\t\tSeverity: SeverityLog,\n\t\t\t})\n\n\t\tassert.Equal(t, 0, test.formatter.formattedSuccess)\n\t\tassert.Equal(t, 0, test.formatter.formattedFailure)\n\n\t\tassert.Nil(t, test.logger)\n\t\tassert.False(t, test.reporter.reported)\n\t})\n\n\tt.Run(\"failure, severity error\", func(t *testing.T) {\n\t\ttest := createTest(t, true)\n\n\t\ttest.handler.Failure(\n\t\t\t&AssertionContext{\n\t\t\t\tTestName: t.Name(),\n\t\t\t},\n\t\t\t&AssertionFailure{\n\t\t\t\tType:     AssertValid,\n\t\t\t\tSeverity: SeverityError,\n\t\t\t})\n\n\t\tassert.Equal(t, 0, test.formatter.formattedSuccess)\n\t\tassert.Equal(t, 1, test.formatter.formattedFailure)\n\n\t\tassert.False(t, test.logger.logged)\n\t\tassert.True(t, test.reporter.reported)\n\t})\n\n\tt.Run(\"failure, severity error, no logger\", func(t *testing.T) {\n\t\ttest := createTest(t, false)\n\n\t\ttest.handler.Failure(\n\t\t\t&AssertionContext{\n\t\t\t\tTestName: t.Name(),\n\t\t\t},\n\t\t\t&AssertionFailure{\n\t\t\t\tType:     AssertValid,\n\t\t\t\tSeverity: SeverityError,\n\t\t\t})\n\n\t\tassert.Equal(t, 0, test.formatter.formattedSuccess)\n\t\tassert.Equal(t, 1, test.formatter.formattedFailure)\n\n\t\tassert.Nil(t, test.logger)\n\t\tassert.True(t, test.reporter.reported)\n\t})\n}\n\nfunc TestAssertion_HandlerPanics(t *testing.T) {\n\tt.Run(\"success, nil Formatter\", func(t *testing.T) {\n\t\thandler := &DefaultAssertionHandler{\n\t\t\tFormatter: nil,\n\t\t\tReporter:  newMockReporter(t),\n\t\t\tLogger:    newMockLogger(t),\n\t\t}\n\n\t\tassert.Panics(t, func() {\n\t\t\thandler.Success(&AssertionContext{\n\t\t\t\tTestName: t.Name(),\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"failure, nil Formatter\", func(t *testing.T) {\n\t\thandler := &DefaultAssertionHandler{\n\t\t\tFormatter: nil,\n\t\t\tReporter:  newMockReporter(t),\n\t\t\tLogger:    newMockLogger(t),\n\t\t}\n\n\t\tassert.Panics(t, func() {\n\t\t\thandler.Failure(\n\t\t\t\t&AssertionContext{\n\t\t\t\t\tTestName: t.Name(),\n\t\t\t\t},\n\t\t\t\t&AssertionFailure{\n\t\t\t\t\tType:     AssertValid,\n\t\t\t\t\tSeverity: SeverityError,\n\t\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"failure, nil Reporter\", func(t *testing.T) {\n\t\thandler := &DefaultAssertionHandler{\n\t\t\tFormatter: newMockFormatter(t),\n\t\t\tReporter:  nil,\n\t\t\tLogger:    newMockLogger(t),\n\t\t}\n\n\t\tassert.Panics(t, func() {\n\t\t\thandler.Failure(\n\t\t\t\t&AssertionContext{\n\t\t\t\t\tTestName: t.Name(),\n\t\t\t\t},\n\t\t\t\t&AssertionFailure{\n\t\t\t\t\tType:     AssertValid,\n\t\t\t\t\tSeverity: SeverityError,\n\t\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestAssertion_ValidateTraits(t *testing.T) {\n\tcases := []struct {\n\t\tname              string\n\t\terrorContainsText string\n\t\tfailure           AssertionFailure\n\t\ttraits            fieldTraits\n\t}{\n\t\t{\n\t\t\tname:              \"bad Type\",\n\t\t\terrorContainsText: \"AssertionType\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tType: AssertionType(9999),\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tActual: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"required Actual\",\n\t\t\terrorContainsText: \"Actual\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tActual: nil,\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tActual: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"denied Actual\",\n\t\t\terrorContainsText: \"Actual\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tActual: &AssertionValue{},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tActual: fieldDenied,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"required Expected\",\n\t\t\terrorContainsText: \"Expected\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: nil,\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tExpected: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"denied Expected\",\n\t\t\terrorContainsText: \"Expected\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tExpected: fieldDenied,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"required AssertionRange\",\n\t\t\terrorContainsText: \"Expected\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: nil,\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tRange: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"AssertionRange should not be pointer\",\n\t\t\terrorContainsText: \"AssertionRange\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tValue: &AssertionRange{},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tRange: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"AssertionRange.Min should not be nil\",\n\t\t\terrorContainsText: \"AssertionRange\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tValue: AssertionRange{\n\t\t\t\t\t\tMax: 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tRange: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"AssertionRange.Max should not be nil\",\n\t\t\terrorContainsText: \"AssertionRange\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tValue: AssertionRange{\n\t\t\t\t\t\tMin: 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tRange: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"required AssertionList\",\n\t\t\terrorContainsText: \"Expected\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: nil,\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tList: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"AssertionList should not be pointer\",\n\t\t\terrorContainsText: \"AssertionValue\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tValue: &AssertionList{},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tList: fieldRequired,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"AssertionList should be not nil\",\n\t\t\terrorContainsText: \"AssertionList\",\n\t\t\tfailure: AssertionFailure{\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tValue: AssertionList{},\n\t\t\t\t},\n\t\t\t},\n\t\t\ttraits: fieldTraits{\n\t\t\t\tList: fieldRequired,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := validateTraits(&tc.failure, tc.traits)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), tc.errorContainsText)\n\t\t})\n\t}\n\n\tt.Run(\"no error\", func(t *testing.T) {\n\t\terr := validateTraits(&AssertionFailure{}, fieldTraits{})\n\t\trequire.Nil(t, err)\n\t})\n\n\tt.Run(\"panic unsupported\", func(t *testing.T) {\n\t\tassert.Panics(t, func() {\n\t\t\terr := validateTraits(&AssertionFailure{}, fieldTraits{List: fieldDenied})\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\terr := validateTraits(&AssertionFailure{}, fieldTraits{Range: fieldDenied})\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t})\n\n}\n\nfunc TestAssertion_ValidateAssertion(t *testing.T) {\n\tvar mErr *mockError\n\tvar mErrPtr error = mErr\n\n\tassert.Nil(t, mErrPtr)\n\tassert.NotEqual(t, nil, mErrPtr)\n\n\tcases := []struct {\n\t\tname              string\n\t\terrorContainsText string\n\t\tinput             AssertionFailure\n\t}{\n\t\t{\n\t\t\tname:              \"bad Type\",\n\t\t\terrorContainsText: \"AssertionType\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertionType(9999),\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"nil Errors\",\n\t\t\terrorContainsText: \"Errors\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType:   AssertOperation,\n\t\t\t\tErrors: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"empty Errors\",\n\t\t\terrorContainsText: \"Errors\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType:   AssertOperation,\n\t\t\t\tErrors: []error{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"nil in Errors\",\n\t\t\terrorContainsText: \"Errors\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType:   AssertOperation,\n\t\t\t\tErrors: []error{nil},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"typed nil in Errors\",\n\t\t\terrorContainsText: \"Errors\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType:   AssertOperation,\n\t\t\t\tErrors: []error{mErrPtr},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"denied Actual\",\n\t\t\terrorContainsText: \"Actual\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertOperation,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"denied Expected\",\n\t\t\terrorContainsText: \"Expected\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertOperation,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"required Actual and denied Expected\",\n\t\t\terrorContainsText: \"\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertType,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"missing Actual and denied Expected\",\n\t\t\terrorContainsText: \"\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertType,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   nil,\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"missing Actual\",\n\t\t\terrorContainsText: \"Actual\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertEqual,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   nil,\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"missing Expected\",\n\t\t\terrorContainsText: \"Expected\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertEqual,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"missing Actual and Expected\",\n\t\t\terrorContainsText: \"\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertEqual,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   nil,\n\t\t\t\tExpected: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"Range is nil\",\n\t\t\terrorContainsText: \"AssertionRange\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertInRange,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"Range has wrong type\",\n\t\t\terrorContainsText: \"AssertionRange\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertInRange,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{\"test\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"Range is pointer\",\n\t\t\terrorContainsText: \"AssertionRange\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertInRange,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{&AssertionRange{Min: 0, Max: 0}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"Range Min is nil\",\n\t\t\terrorContainsText: \"Min\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertInRange,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{AssertionRange{nil, 123}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"Range Max is nil\",\n\t\t\terrorContainsText: \"Max\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertInRange,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{AssertionRange{123, nil}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"Range Min and Max are nil\",\n\t\t\terrorContainsText: \"\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertInRange,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{AssertionRange{nil, nil}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"List is nil\",\n\t\t\terrorContainsText: \"AssertionList\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertBelongs,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"List has wrong type\",\n\t\t\terrorContainsText: \"AssertionList\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertBelongs,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{\"test\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"List is pointer\",\n\t\t\terrorContainsText: \"AssertionList\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertBelongs,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{&AssertionList{1}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"List is typed nil\",\n\t\t\terrorContainsText: \"AssertionList\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertBelongs,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{AssertionList(nil)},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:              \"List is empty\",\n\t\t\terrorContainsText: \"AssertionList\",\n\t\t\tinput: AssertionFailure{\n\t\t\t\tType: AssertBelongs,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"test\"),\n\t\t\t\t},\n\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\tExpected: &AssertionValue{AssertionList{}},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := validateAssertion(&tc.input)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.Contains(t, err.Error(), tc.errorContainsText)\n\t\t})\n\t}\n}\n\nfunc TestAssertion_Strings(t *testing.T) {\n\tt.Run(\"AssertionType\", func(t *testing.T) {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tassert.NotEmpty(t, AssertionType(i).String())\n\t\t}\n\t})\n\n\tt.Run(\"AssertionSeverity\", func(t *testing.T) {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tassert.NotEmpty(t, AssertionSeverity(i).String())\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "assertion_validation.go",
          "type": "blob",
          "size": 4.9658203125,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc validateAssertion(failure *AssertionFailure) error {\n\tif len(failure.Errors) == 0 {\n\t\treturn errors.New(\"AssertionFailure should have non-empty Errors list\")\n\t}\n\n\tfor _, err := range failure.Errors {\n\t\tif err == nil {\n\t\t\treturn errors.New(\"AssertionFailure should not have nil in Errors\")\n\t\t} else if refIsNil(err) {\n\t\t\treturn errors.New(\"AssertionFailure should not have typed-nil in Errors\")\n\t\t}\n\t}\n\n\tif err := validateType(failure); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc validateType(failure *AssertionFailure) error {\n\tswitch failure.Type {\n\tcase AssertUsage, AssertOperation:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldDenied,\n\t\t\tExpected: fieldDenied,\n\t\t})\n\n\tcase AssertType, AssertNotType,\n\t\tAssertValid, AssertNotValid,\n\t\tAssertNil, AssertNotNil,\n\t\tAssertEmpty, AssertNotEmpty:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldRequired,\n\t\t\tExpected: fieldDenied,\n\t\t})\n\n\tcase AssertEqual, AssertNotEqual,\n\t\tAssertLt, AssertLe, AssertGt, AssertGe:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldRequired,\n\t\t\tExpected: fieldRequired,\n\t\t})\n\n\tcase AssertInRange, AssertNotInRange:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldRequired,\n\t\t\tExpected: fieldRequired,\n\t\t\tRange:    fieldRequired,\n\t\t})\n\n\tcase AssertMatchSchema, AssertNotMatchSchema,\n\t\tAssertMatchPath, AssertNotMatchPath,\n\t\tAssertMatchRegexp, AssertNotMatchRegexp,\n\t\tAssertMatchFormat, AssertNotMatchFormat:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldRequired,\n\t\t\tExpected: fieldRequired,\n\t\t})\n\n\tcase AssertContainsKey, AssertNotContainsKey,\n\t\tAssertContainsElement, AssertNotContainsElement,\n\t\tAssertContainsSubset, AssertNotContainsSubset:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldRequired,\n\t\t\tExpected: fieldOptional,\n\t\t})\n\n\tcase AssertBelongs, AssertNotBelongs:\n\t\treturn validateTraits(failure, fieldTraits{\n\t\t\tActual:   fieldRequired,\n\t\t\tExpected: fieldRequired,\n\t\t\tList:     fieldRequired,\n\t\t})\n\t}\n\n\treturn fmt.Errorf(\"unknown assertion type %s\", failure.Type)\n}\n\ntype fieldRequirement uint\n\nconst (\n\tfieldOptional fieldRequirement = iota\n\tfieldRequired\n\tfieldDenied\n)\n\ntype fieldTraits struct {\n\tActual   fieldRequirement\n\tExpected fieldRequirement\n\tRange    fieldRequirement\n\tList     fieldRequirement\n}\n\nfunc validateTraits(failure *AssertionFailure, traits fieldTraits) error {\n\tswitch traits.Actual {\n\tcase fieldRequired:\n\t\tif failure.Actual == nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s should have Actual field\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\tcase fieldDenied:\n\t\tif failure.Actual != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s can't have Actual field\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\tcase fieldOptional:\n\t\tbreak\n\t}\n\n\tswitch traits.Expected {\n\tcase fieldRequired:\n\t\tif failure.Expected == nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s should have Expected field\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\tcase fieldDenied:\n\t\tif failure.Expected != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s can't have Expected field\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\tcase fieldOptional:\n\t\tbreak\n\t}\n\n\tif traits.Range == fieldRequired || traits.Range == fieldOptional {\n\t\tif failure.Expected != nil {\n\t\t\tif _, ok := failure.Expected.Value.(*AssertionRange); ok {\n\t\t\t\treturn errors.New(\n\t\t\t\t\t\"AssertionValue should contain AssertionRange, not *AssertionRange\")\n\t\t\t}\n\n\t\t\tif rng, ok := failure.Expected.Value.(AssertionRange); ok {\n\t\t\t\tif rng.Min == nil {\n\t\t\t\t\treturn errors.New(\"AssertionRange value should have non-nil Min field\")\n\t\t\t\t}\n\t\t\t\tif rng.Max == nil {\n\t\t\t\t\treturn errors.New(\"AssertionRange value should have non-nil Max field\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch traits.Range {\n\tcase fieldRequired:\n\t\tif failure.Expected == nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s should have Expected field\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\t\tif _, ok := failure.Expected.Value.(AssertionRange); !ok {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s\"+\n\t\t\t\t\t\" should have Expected field with AssertionRange value\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\tcase fieldDenied:\n\t\tpanic(\"unsupported\")\n\n\tcase fieldOptional:\n\t\tbreak\n\t}\n\n\tif traits.List == fieldRequired || traits.List == fieldOptional {\n\t\tif failure.Expected != nil {\n\t\t\tif _, ok := failure.Expected.Value.(*AssertionList); ok {\n\t\t\t\treturn errors.New(\n\t\t\t\t\t\"AssertionValue should contain AssertionList, not *AssertionList\")\n\t\t\t}\n\n\t\t\tif lst, ok := failure.Expected.Value.(AssertionList); ok {\n\t\t\t\tif len(lst) == 0 {\n\t\t\t\t\treturn errors.New(\"AssertionList should be non-empty\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch traits.List {\n\tcase fieldRequired:\n\t\tif failure.Expected == nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s should have Expected field\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\t\tif _, ok := failure.Expected.Value.(AssertionList); !ok {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"AssertionFailure of type %s\"+\n\t\t\t\t\t\" should have Expected field with AssertionList value\",\n\t\t\t\tfailure.Type)\n\t\t}\n\n\tcase fieldDenied:\n\t\tpanic(\"unsupported\")\n\n\tcase fieldOptional:\n\t\tbreak\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "assertionseverity_string.go",
          "type": "blob",
          "size": 0.70703125,
          "content": "// Code generated by \"stringer -type=AssertionSeverity\"; DO NOT EDIT.\n\npackage httpexpect\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[SeverityError-0]\n\t_ = x[SeverityLog-1]\n}\n\nconst _AssertionSeverity_name = \"SeverityErrorSeverityLog\"\n\nvar _AssertionSeverity_index = [...]uint8{0, 13, 24}\n\nfunc (i AssertionSeverity) String() string {\n\tif i >= AssertionSeverity(len(_AssertionSeverity_index)-1) {\n\t\treturn \"AssertionSeverity(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _AssertionSeverity_name[_AssertionSeverity_index[i]:_AssertionSeverity_index[i+1]]\n}\n"
        },
        {
          "name": "assertiontype_string.go",
          "type": "blob",
          "size": 2.1240234375,
          "content": "// Code generated by \"stringer -type=AssertionType\"; DO NOT EDIT.\n\npackage httpexpect\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[AssertUsage-0]\n\t_ = x[AssertOperation-1]\n\t_ = x[AssertType-2]\n\t_ = x[AssertNotType-3]\n\t_ = x[AssertValid-4]\n\t_ = x[AssertNotValid-5]\n\t_ = x[AssertNil-6]\n\t_ = x[AssertNotNil-7]\n\t_ = x[AssertEmpty-8]\n\t_ = x[AssertNotEmpty-9]\n\t_ = x[AssertEqual-10]\n\t_ = x[AssertNotEqual-11]\n\t_ = x[AssertLt-12]\n\t_ = x[AssertLe-13]\n\t_ = x[AssertGt-14]\n\t_ = x[AssertGe-15]\n\t_ = x[AssertInRange-16]\n\t_ = x[AssertNotInRange-17]\n\t_ = x[AssertMatchSchema-18]\n\t_ = x[AssertNotMatchSchema-19]\n\t_ = x[AssertMatchPath-20]\n\t_ = x[AssertNotMatchPath-21]\n\t_ = x[AssertMatchRegexp-22]\n\t_ = x[AssertNotMatchRegexp-23]\n\t_ = x[AssertMatchFormat-24]\n\t_ = x[AssertNotMatchFormat-25]\n\t_ = x[AssertContainsKey-26]\n\t_ = x[AssertNotContainsKey-27]\n\t_ = x[AssertContainsElement-28]\n\t_ = x[AssertNotContainsElement-29]\n\t_ = x[AssertContainsSubset-30]\n\t_ = x[AssertNotContainsSubset-31]\n\t_ = x[AssertBelongs-32]\n\t_ = x[AssertNotBelongs-33]\n}\n\nconst _AssertionType_name = \"AssertUsageAssertOperationAssertTypeAssertNotTypeAssertValidAssertNotValidAssertNilAssertNotNilAssertEmptyAssertNotEmptyAssertEqualAssertNotEqualAssertLtAssertLeAssertGtAssertGeAssertInRangeAssertNotInRangeAssertMatchSchemaAssertNotMatchSchemaAssertMatchPathAssertNotMatchPathAssertMatchRegexpAssertNotMatchRegexpAssertMatchFormatAssertNotMatchFormatAssertContainsKeyAssertNotContainsKeyAssertContainsElementAssertNotContainsElementAssertContainsSubsetAssertNotContainsSubsetAssertBelongsAssertNotBelongs\"\n\nvar _AssertionType_index = [...]uint16{0, 11, 26, 36, 49, 60, 74, 83, 95, 106, 120, 131, 145, 153, 161, 169, 177, 190, 206, 223, 243, 258, 276, 293, 313, 330, 350, 367, 387, 408, 432, 452, 475, 488, 504}\n\nfunc (i AssertionType) String() string {\n\tif i >= AssertionType(len(_AssertionType_index)-1) {\n\t\treturn \"AssertionType(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _AssertionType_name[_AssertionType_index[i]:_AssertionType_index[i+1]]\n}\n"
        },
        {
          "name": "binder.go",
          "type": "blob",
          "size": 5.7978515625,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/valyala/fasthttp\"\n)\n\n// Binder implements networkless http.RoundTripper attached directly to\n// http.Handler.\n//\n// Binder emulates network communication by invoking given http.Handler\n// directly. It passes httptest.ResponseRecorder as http.ResponseWriter\n// to the handler, and then constructs http.Response from recorded data.\ntype Binder struct {\n\t// HTTP handler invoked for every request.\n\tHandler http.Handler\n\t// TLS connection state used for https:// requests.\n\tTLS *tls.ConnectionState\n}\n\n// NewBinder returns a new Binder given a http.Handler.\n//\n// Example:\n//\n//\tclient := &http.Client{\n//\t\tTransport: NewBinder(handler),\n//\t}\nfunc NewBinder(handler http.Handler) Binder {\n\treturn Binder{Handler: handler}\n}\n\n// RoundTrip implements http.RoundTripper.RoundTrip.\nfunc (binder Binder) RoundTrip(origReq *http.Request) (*http.Response, error) {\n\treq := *origReq\n\n\tif req.Proto == \"\" {\n\t\treq.Proto = fmt.Sprintf(\"HTTP/%d.%d\", req.ProtoMajor, req.ProtoMinor)\n\t}\n\n\tif req.Body != nil && req.Body != http.NoBody {\n\t\tif req.ContentLength == -1 {\n\t\t\treq.TransferEncoding = []string{\"chunked\"}\n\t\t}\n\t} else {\n\t\treq.Body = http.NoBody\n\t}\n\n\tif req.URL != nil && req.URL.Scheme == \"https\" && binder.TLS != nil {\n\t\treq.TLS = binder.TLS\n\t}\n\n\tif req.RequestURI == \"\" {\n\t\treq.RequestURI = req.URL.RequestURI()\n\t}\n\n\trecorder := httptest.NewRecorder()\n\n\tbinder.Handler.ServeHTTP(recorder, &req)\n\n\tresp := http.Response{\n\t\tRequest:    &req,\n\t\tStatusCode: recorder.Code,\n\t\tStatus:     http.StatusText(recorder.Code),\n\t\tHeader:     recorder.Result().Header,\n\t}\n\n\tif recorder.Flushed {\n\t\tresp.TransferEncoding = []string{\"chunked\"}\n\t}\n\n\tif recorder.Body != nil {\n\t\tresp.Body = io.NopCloser(recorder.Body)\n\t}\n\n\treturn &resp, nil\n}\n\n// FastBinder implements networkless http.RoundTripper attached directly\n// to fasthttp.RequestHandler.\n//\n// FastBinder emulates network communication by invoking given fasthttp.RequestHandler\n// directly. It converts http.Request to fasthttp.Request, invokes handler, and then\n// converts fasthttp.Response to http.Response.\ntype FastBinder struct {\n\t// FastHTTP handler invoked for every request.\n\tHandler fasthttp.RequestHandler\n\t// TLS connection state used for https:// requests.\n\tTLS *tls.ConnectionState\n\t// If non-nil, fasthttp.RequestCtx.Logger() will print messages to it.\n\tLogger Logger\n}\n\n// NewFastBinder returns a new FastBinder given a fasthttp.RequestHandler.\n//\n// Example:\n//\n//\tclient := &http.Client{\n//\t\tTransport: NewFastBinder(fasthandler),\n//\t}\nfunc NewFastBinder(handler fasthttp.RequestHandler) FastBinder {\n\treturn FastBinder{Handler: handler}\n}\n\n// RoundTrip implements http.RoundTripper.RoundTrip.\nfunc (binder FastBinder) RoundTrip(stdreq *http.Request) (*http.Response, error) {\n\tfastreq := std2fast(stdreq)\n\n\tvar conn net.Conn\n\tif stdreq.URL != nil && stdreq.URL.Scheme == \"https\" && binder.TLS != nil {\n\t\tconn = connTLS{state: binder.TLS}\n\t} else {\n\t\tconn = connNonTLS{}\n\t}\n\n\tctx := fasthttp.RequestCtx{}\n\tlog := fastLogger{binder.Logger}\n\tctx.Init2(conn, log, true)\n\n\tfastreq.CopyTo(&ctx.Request)\n\n\tif stdreq.RemoteAddr != \"\" {\n\t\tvar parts = strings.SplitN(stdreq.RemoteAddr, \":\", 2)\n\t\thost := parts[0]\n\t\tport := 0\n\t\tif len(parts) > 1 {\n\t\t\tport, _ = strconv.Atoi(parts[1])\n\t\t}\n\t\tctx.SetRemoteAddr(&net.TCPAddr{\n\t\t\tIP:   net.ParseIP(host),\n\t\t\tPort: port,\n\t\t})\n\t}\n\n\tif stdreq.ContentLength >= 0 {\n\t\tctx.Request.Header.SetContentLength(int(stdreq.ContentLength))\n\t} else {\n\t\tctx.Request.Header.SetContentLength(-1)\n\t\tctx.Request.Header.Add(\"Transfer-Encoding\", \"chunked\")\n\t}\n\n\tif stdreq.Body != nil {\n\t\tb, err := io.ReadAll(stdreq.Body)\n\t\tif err == nil {\n\t\t\tctx.Request.SetBody(b)\n\t\t}\n\t}\n\n\tbinder.Handler(&ctx)\n\n\treturn fast2std(stdreq, &ctx.Response), nil\n}\n\nfunc std2fast(stdreq *http.Request) *fasthttp.Request {\n\tfastreq := &fasthttp.Request{}\n\n\tfastreq.SetRequestURI(stdreq.URL.String())\n\n\tif stdreq.Proto != \"\" {\n\t\tfastreq.Header.SetProtocol(stdreq.Proto)\n\t} else if stdreq.ProtoMajor != 0 || stdreq.ProtoMinor != 0 {\n\t\tfastreq.Header.SetProtocol(\n\t\t\tfmt.Sprintf(\"HTTP/%d.%d\", stdreq.ProtoMajor, stdreq.ProtoMinor))\n\t}\n\n\tfastreq.Header.SetMethod(stdreq.Method)\n\n\tif stdreq.Host != \"\" {\n\t\tfastreq.Header.SetHost(stdreq.Host)\n\t}\n\n\tfor k, a := range stdreq.Header {\n\t\tfor n, v := range a {\n\t\t\tif n == 0 {\n\t\t\t\tfastreq.Header.Set(k, v)\n\t\t\t} else {\n\t\t\t\tfastreq.Header.Add(k, v)\n\t\t\t}\n\t\t}\n\t}\n\n\tfastreq.Header.SetContentLength(int(stdreq.ContentLength))\n\n\treturn fastreq\n}\n\nfunc fast2std(stdreq *http.Request, fastresp *fasthttp.Response) *http.Response {\n\tstatus := fastresp.Header.StatusCode()\n\tbody := fastresp.Body()\n\n\tstdresp := &http.Response{\n\t\tStatusCode: status,\n\t\tStatus:     http.StatusText(status),\n\t\tRequest:    stdreq,\n\t}\n\n\tfastresp.Header.VisitAll(func(k, v []byte) {\n\t\tsk := string(k)\n\t\tsv := string(v)\n\t\tif stdresp.Header == nil {\n\t\t\tstdresp.Header = make(http.Header)\n\t\t}\n\t\tstdresp.Header.Add(sk, sv)\n\t})\n\n\tif fastresp.Header.ContentLength() >= 0 {\n\t\tstdresp.ContentLength = int64(fastresp.Header.ContentLength())\n\t} else {\n\t\tstdresp.ContentLength = -1\n\t\tstdresp.TransferEncoding = []string{\"chunked\"}\n\t}\n\n\tif body != nil {\n\t\tstdresp.Body = io.NopCloser(bytes.NewReader(body))\n\t} else {\n\t\tstdresp.Body = io.NopCloser(bytes.NewReader(nil))\n\t}\n\n\treturn stdresp\n}\n\ntype fastLogger struct {\n\tlogger Logger\n}\n\nfunc (f fastLogger) Printf(format string, args ...interface{}) {\n\tif f.logger != nil {\n\t\tf.logger.Logf(format, args...)\n\t}\n}\n\ntype connNonTLS struct {\n\tnet.Conn\n}\n\nfunc (connNonTLS) RemoteAddr() net.Addr {\n\treturn &net.TCPAddr{IP: net.IPv4zero}\n}\n\nfunc (connNonTLS) LocalAddr() net.Addr {\n\treturn &net.TCPAddr{IP: net.IPv4zero}\n}\n\ntype connTLS struct {\n\tconnNonTLS\n\tstate *tls.ConnectionState\n}\n\nfunc (c connTLS) Handshake() error {\n\treturn nil\n}\n\nfunc (c connTLS) ConnectionState() tls.ConnectionState {\n\treturn *c.state\n}\n"
        },
        {
          "name": "binder_test.go",
          "type": "blob",
          "size": 11.4716796875,
          "content": "package httpexpect\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/valyala/fasthttp\"\n)\n\ntype mockHandler struct {\n\tt       *testing.T\n\thttps   bool\n\thttp10  bool\n\tchunked bool\n}\n\nfunc (c *mockHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tbody, err := io.ReadAll(req.Body)\n\tassert.True(c.t, err == nil)\n\n\tif c.http10 {\n\t\tassert.Equal(c.t, \"HTTP/1.0\", req.Proto)\n\t\tassert.Equal(c.t, 1, req.ProtoMajor)\n\t\tassert.Equal(c.t, 0, req.ProtoMinor)\n\t} else {\n\t\tassert.Equal(c.t, \"HTTP/1.1\", req.Proto)\n\t\tassert.Equal(c.t, 1, req.ProtoMajor)\n\t\tassert.Equal(c.t, 1, req.ProtoMinor)\n\t}\n\tif c.https {\n\t\tassert.Equal(c.t, \"https://example.com/path\", req.URL.String())\n\t} else {\n\t\tassert.Equal(c.t, \"http://example.com/path\", req.URL.String())\n\t}\n\tassert.Equal(c.t, \"/path\", req.URL.RequestURI())\n\tassert.Equal(c.t, \"/path\", req.RequestURI)\n\tassert.Equal(c.t, \"GET\", req.Method)\n\tassert.Equal(c.t, \"body\", string(body))\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\t_, err = w.Write([]byte(`{\"hello\":\"world\"}`))\n\tif c.chunked {\n\t\tw.(http.Flusher).Flush()\n\t}\n\n\tassert.True(c.t, err == nil)\n}\n\nfunc TestBinder_Basic(t *testing.T) {\n\thandler := &mockHandler{\n\t\tt:       t,\n\t\thttp10:  true,\n\t\tchunked: false,\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: NewBinder(handler),\n\t}\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com/path\", strings.NewReader(\"body\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.ProtoMajor = 1\n\treq.ProtoMinor = 0\n\treq.Proto = \"\"\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\theader := http.Header{\n\t\t\"Content-Type\": {\"application/json\"},\n\t}\n\n\tb, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, header, resp.Header)\n\tassert.Equal(t, `{\"hello\":\"world\"}`, string(b))\n\n\tassert.Equal(t, []string(nil), resp.TransferEncoding)\n}\n\nfunc TestBinder_TLS(t *testing.T) {\n\thandler := &mockHandler{t: t}\n\n\thttpClient := &http.Client{\n\t\tTransport: &Binder{\n\t\t\tHandler: handler,\n\t\t\tTLS:     nil,\n\t\t},\n\t}\n\n\ttlsState := &tls.ConnectionState{}\n\n\thttpsClient := &http.Client{\n\t\tTransport: &Binder{\n\t\t\tHandler: handler,\n\t\t\tTLS:     tlsState,\n\t\t},\n\t}\n\n\tt.Run(\"handler=no url=no client=no\", func(t *testing.T) {\n\t\thandler.https = false\n\t\treq, _ := http.NewRequest(\"GET\", \"http://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.Nil(t, resp.Request.TLS)\n\t})\n\n\tt.Run(\"handler=yes url=yes client=no\", func(t *testing.T) {\n\t\thandler.https = true\n\t\treq, _ := http.NewRequest(\"GET\", \"https://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.Nil(t, resp.Request.TLS)\n\t})\n\n\tt.Run(\"handler=no url=no client=yes\", func(t *testing.T) {\n\t\thandler.https = false\n\t\treq, _ := http.NewRequest(\"GET\", \"http://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpsClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.Nil(t, resp.Request.TLS)\n\t})\n\n\tt.Run(\"handler=yes url=yes client=yes\", func(t *testing.T) {\n\t\thandler.https = true\n\t\treq, _ := http.NewRequest(\"GET\", \"https://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpsClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.NotNil(t, resp.Request.TLS)\n\t\tassert.Same(t, tlsState, resp.Request.TLS)\n\t})\n}\n\nfunc TestBinder_Chunked(t *testing.T) {\n\thandler := &mockHandler{\n\t\tt:       t,\n\t\tchunked: true,\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: NewBinder(handler),\n\t}\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com/path\", strings.NewReader(\"body\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.ContentLength = -1\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, []string{\"chunked\"}, resp.Request.TransferEncoding)\n\tassert.Equal(t, []string{\"chunked\"}, resp.TransferEncoding)\n}\n\nfunc TestFastBinder_Basic(t *testing.T) {\n\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\tassert.Equal(t, \"POST\", string(ctx.Request.Header.Method()))\n\t\tassert.Equal(t, \"http://example.com/path\", string(ctx.Request.Header.RequestURI()))\n\n\t\tassert.Equal(t, \"application/x-www-form-urlencoded\",\n\t\t\tstring(ctx.Request.Header.ContentType()))\n\n\t\tassert.NotNil(t, ctx.LocalAddr())\n\t\tassert.Equal(t, \"tcp\", ctx.LocalAddr().Network())\n\t\tassert.Equal(t, \"0.0.0.0:0\", ctx.LocalAddr().String())\n\n\t\tassert.NotNil(t, ctx.RemoteAddr())\n\t\tassert.Equal(t, \"tcp\", ctx.RemoteAddr().Network())\n\t\tassert.Equal(t, \"0.0.0.0:0\", ctx.RemoteAddr().String())\n\n\t\tassert.False(t, ctx.IsTLS())\n\t\tassert.Nil(t, ctx.TLSConnectionState())\n\n\t\theaders := map[string][]string{}\n\n\t\tctx.Request.Header.VisitAll(func(k, v []byte) {\n\t\t\theaders[string(k)] = append(headers[string(k)], string(v))\n\t\t})\n\n\t\texpected := map[string][]string{\n\t\t\t\"Host\":           {\"example.com\"},\n\t\t\t\"Content-Type\":   {\"application/x-www-form-urlencoded\"},\n\t\t\t\"Content-Length\": {\"7\"},\n\t\t\t\"Some-Header\":    {\"foo\", \"bar\"},\n\t\t}\n\n\t\tassert.Equal(t, expected, headers)\n\n\t\tassert.Equal(t, \"bar\", string(ctx.FormValue(\"foo\")))\n\t\tassert.Equal(t, \"foo=bar\", string(ctx.Request.Body()))\n\n\t\tctx.Response.Header.Set(\"Content-Type\", \"application/json\")\n\t\tctx.Response.SetBody([]byte(`{\"hello\":\"world\"}`))\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: NewFastBinder(handler),\n\t}\n\n\treq, err := http.NewRequest(\n\t\t\"POST\", \"http://example.com/path\", strings.NewReader(\"foo=bar\"))\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\treq.Header.Add(\"Some-Header\", \"foo\")\n\treq.Header.Add(\"Some-Header\", \"bar\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\theader := http.Header{\n\t\t\"Content-Type\": {\"application/json\"},\n\t}\n\n\tb, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, header, resp.Header)\n\tassert.Equal(t, `{\"hello\":\"world\"}`, string(b))\n\n\tassert.Equal(t, []string(nil), resp.TransferEncoding)\n}\n\nfunc TestFastBinder_RemoteAddr(t *testing.T) {\n\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\tassert.NotNil(t, ctx.RemoteAddr())\n\t\tassert.Equal(t, \"tcp\", ctx.RemoteAddr().Network())\n\t\tassert.Equal(t, \"8.8.8.8:88\", ctx.RemoteAddr().String())\n\n\t\tctx.Response.SetBody([]byte(`ok`))\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: NewFastBinder(handler),\n\t}\n\n\treq, err := http.NewRequest(\n\t\t\"POST\", \"http://example.com/path\", strings.NewReader(\"foo=bar\"))\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.RemoteAddr = \"8.8.8.8:88\"\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tb, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, `ok`, string(b))\n}\n\nfunc TestFastBinder_Protocol(t *testing.T) {\n\ttest := func(setProto func(req *http.Request)) {\n\t\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\t\tassert.Equal(t, \"HTTP/1.0\", string(ctx.Request.Header.Protocol()))\n\n\t\t\tctx.Response.SetBody([]byte(`ok`))\n\t\t}\n\n\t\tclient := &http.Client{\n\t\t\tTransport: NewFastBinder(handler),\n\t\t}\n\n\t\treq, err := http.NewRequest(\n\t\t\t\"POST\", \"http://example.com/path\", strings.NewReader(\"foo=bar\"))\n\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tsetProto(req)\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tassert.Equal(t, `ok`, string(b))\n\t}\n\n\tt.Run(\"from string\", func(t *testing.T) {\n\t\ttest(func(req *http.Request) {\n\t\t\treq.Proto = \"HTTP/1.0\"\n\t\t})\n\t})\n\n\tt.Run(\"from components\", func(t *testing.T) {\n\t\ttest(func(req *http.Request) {\n\t\t\treq.Proto = \"\"\n\t\t\treq.ProtoMajor = 1\n\t\t\treq.ProtoMinor = 0\n\t\t})\n\t})\n}\n\nfunc TestFastBinder_TLS(t *testing.T) {\n\tvar isHTTPS, isTLS bool\n\n\ttlsState := &tls.ConnectionState{\n\t\tVersion: tls.VersionTLS12,\n\t}\n\n\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\tisHTTPS = strings.HasPrefix(string(ctx.Request.Header.RequestURI()), \"https://\")\n\t\tisTLS = ctx.IsTLS()\n\t\tif isTLS {\n\t\t\tassert.Equal(t, *tlsState, *ctx.TLSConnectionState())\n\t\t}\n\t}\n\n\thttpClient := &http.Client{\n\t\tTransport: &FastBinder{\n\t\t\tHandler: handler,\n\t\t\tTLS:     nil,\n\t\t},\n\t}\n\n\thttpsClient := &http.Client{\n\t\tTransport: &FastBinder{\n\t\t\tHandler: handler,\n\t\t\tTLS:     tlsState,\n\t\t},\n\t}\n\n\tt.Run(\"url=no client=no\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(\"GET\", \"http://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.False(t, isHTTPS)\n\t\tassert.False(t, isTLS)\n\t})\n\n\tt.Run(\"url=yes client=no\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(\"GET\", \"https://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.True(t, isHTTPS)\n\t\tassert.False(t, isTLS)\n\t})\n\n\tt.Run(\"url=no client=yes\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(\"GET\", \"http://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpsClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.False(t, isHTTPS)\n\t\tassert.False(t, isTLS)\n\t})\n\n\tt.Run(\"url=yes client=yes\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(\"GET\", \"https://example.com/path\", strings.NewReader(\"body\"))\n\t\tresp, err := httpsClient.Do(req)\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, resp)\n\t\tassert.True(t, isHTTPS)\n\t\tassert.True(t, isTLS)\n\t})\n}\n\nfunc TestFastBinder_Chunked(t *testing.T) {\n\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\tassert.Equal(t, \"POST\", string(ctx.Request.Header.Method()))\n\t\tassert.Equal(t, \"http://example.com/path\", string(ctx.Request.Header.RequestURI()))\n\n\t\tassert.Equal(t, \"application/x-www-form-urlencoded\",\n\t\t\tstring(ctx.Request.Header.ContentType()))\n\n\t\theaders := map[string][]string{}\n\n\t\tctx.Request.Header.VisitAll(func(k, v []byte) {\n\t\t\theaders[string(k)] = append(headers[string(k)], string(v))\n\t\t})\n\n\t\texpected := map[string][]string{\n\t\t\t\"Host\":              {\"example.com\"},\n\t\t\t\"Content-Type\":      {\"application/x-www-form-urlencoded\"},\n\t\t\t\"Transfer-Encoding\": {\"chunked\"},\n\t\t}\n\n\t\tassert.Equal(t, expected, headers)\n\n\t\tassert.Equal(t, \"bar\", string(ctx.FormValue(\"foo\")))\n\t\tassert.Equal(t, \"foo=bar\", string(ctx.Request.Body()))\n\n\t\tctx.Response.Header.Set(\"Content-Type\", \"application/json\")\n\t\tctx.Response.SetBodyStreamWriter(func(w *bufio.Writer) {\n\t\t\t_, _ = w.WriteString(`[1, `)\n\t\t\t_ = w.Flush()\n\t\t\t_, _ = w.WriteString(`2]`)\n\t\t})\n\t}\n\n\tclient := &http.Client{\n\t\tTransport: NewFastBinder(handler),\n\t}\n\n\treq, err := http.NewRequest(\n\t\t\"POST\", \"http://example.com/path\", strings.NewReader(\"foo=bar\"))\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\treq.ContentLength = -1\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, []string{\"chunked\"}, resp.TransferEncoding)\n}\n\nfunc TestFastBinder_EmptyResponse(t *testing.T) {\n\thandler := func(*fasthttp.RequestCtx) {}\n\n\tclient := &http.Client{\n\t\tTransport: NewFastBinder(handler),\n\t}\n\n\treq, err := http.NewRequest(\"POST\", \"http://example.com/path\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.False(t, resp.Body == nil)\n\n\tb, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.Equal(t, \"\", string(b))\n}\n\nfunc TestFastBinder_Logger(t *testing.T) {\n\thandler := func(ctx *fasthttp.RequestCtx) {\n\t\tctx.Logger().Printf(\"test_message\")\n\t}\n\n\tlogger := newMockLogger(t)\n\n\tclient := &http.Client{\n\t\tTransport: &FastBinder{\n\t\t\tHandler: handler,\n\t\t\tLogger:  logger,\n\t\t},\n\t}\n\n\treq, err := http.NewRequest(\n\t\t\"POST\", \"http://example.com/path\", strings.NewReader(\"foo=bar\"))\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = client.Do(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.True(t, logger.logged)\n\tassert.Contains(t, logger.lastMessage, \"test_message\")\n}\n"
        },
        {
          "name": "body_wrapper.go",
          "type": "blob",
          "size": 6.8134765625,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"runtime\"\n\t\"sync\"\n)\n\n// Wrapper for request or response body reader.\n//\n// Allows to read body multiple times using two approaches:\n//   - use Read to read body contents and Rewind to restart reading from beginning\n//   - use GetBody to get new reader for body contents\n//\n// When bodyWrapper is created, it does not read anything. Also, until anything is\n// read, rewind operations are no-op.\n//\n// When the user starts reading body, bodyWrapper automatically copies retrieved\n// content in memory. Then, when the body is fully read and Rewind is requested,\n// it will close original body and switch to reading body from memory.\n//\n// If Rewind, GetBody, or Close is invoked before the body is fully read first time,\n// bodyWrapper automatically performs full read.\n//\n// At any moment, the user can call DisableRewinds. In this case, Rewind and GetBody\n// functionality is disabled, memory cache is cleared, and bodyWrapper switches to\n// reading original body (if it's not fully read yet).\n//\n// bodyWrapper automatically creates finalizer that will close original body if the\n// user never reads it fully or calls Closes.\ntype bodyWrapper struct {\n\t// Protects all operations.\n\tmu sync.Mutex\n\n\t// Original reader of HTTP response body.\n\thttpReader io.ReadCloser\n\n\t// Cancellation function for original HTTP response.\n\t// If set, called after HTTP response is fully read into memory.\n\thttpCancelFunc context.CancelFunc\n\n\t// Reader for HTTP response body stored in memory.\n\t// Rewind() resets this reader to start from the beginning.\n\tmemReader *bytes.Reader\n\n\t// HTTP response body stored in memory.\n\tmemBytes []byte\n\n\t// Cached read and close errors.\n\treadErr  error\n\tcloseErr error\n\n\t// If true, Read will not store bytes in memory, and memBytes and memReader\n\t// won't be used.\n\tisRewindDisabled bool\n\n\t// True means that HTTP response was fully read into memory already.\n\tisFullyRead bool\n\n\t// True means that a read operation of any type was called at least once.\n\tisReadBefore bool\n}\n\nfunc newBodyWrapper(reader io.ReadCloser, cancelFunc context.CancelFunc) *bodyWrapper {\n\tbw := &bodyWrapper{\n\t\thttpReader:     reader,\n\t\thttpCancelFunc: cancelFunc,\n\t}\n\n\t// Finalizer will close body if closeAndCancel was never called.\n\truntime.SetFinalizer(bw, (*bodyWrapper).Close)\n\n\treturn bw\n}\n\n// Read body contents.\nfunc (bw *bodyWrapper) Read(p []byte) (int, error) {\n\tbw.mu.Lock()\n\tdefer bw.mu.Unlock()\n\n\tbw.isReadBefore = true\n\n\tif bw.isRewindDisabled && !bw.isFullyRead {\n\t\t// Regular read from original HTTP response.\n\t\treturn bw.httpReader.Read(p)\n\t} else if !bw.isFullyRead {\n\t\t// Read from original HTTP response + store into memory.\n\t\treturn bw.httpReadNext(p)\n\t} else {\n\t\t// Read from memory.\n\t\treturn bw.memReadNext(p)\n\t}\n}\n\n// Close body.\nfunc (bw *bodyWrapper) Close() error {\n\tbw.mu.Lock()\n\tdefer bw.mu.Unlock()\n\n\t// Preserve original reader error.\n\terr := bw.closeErr\n\n\t// Rewind or GetBody may be called later, so be sure to\n\t// read body into memory before closing.\n\tif !bw.isRewindDisabled && !bw.isFullyRead {\n\t\tbw.isReadBefore = true\n\n\t\tif readErr := bw.httpReadFull(); readErr != nil {\n\t\t\terr = readErr\n\t\t}\n\t}\n\n\t// Close original reader.\n\tcloseErr := bw.closeAndCancel()\n\tif closeErr != nil {\n\t\terr = closeErr\n\t}\n\n\t// Reset memory reader.\n\tbw.memReader = bytes.NewReader(nil)\n\n\t// Free memory when rewind is disabled.\n\tif bw.isRewindDisabled {\n\t\tbw.memBytes = nil\n\t}\n\n\treturn err\n}\n\n// Rewind reading to the beginning.\nfunc (bw *bodyWrapper) Rewind() {\n\tbw.mu.Lock()\n\tdefer bw.mu.Unlock()\n\n\t// Rewind is no-op if disabled.\n\tif bw.isRewindDisabled {\n\t\treturn\n\t}\n\n\t// Rewind is no-op until first read operation.\n\tif !bw.isReadBefore {\n\t\treturn\n\t}\n\n\t// If HTTP response is not fully read yet, do it now.\n\t// If error occurs, it will be reported next read operation.\n\tif !bw.isFullyRead {\n\t\t_ = bw.httpReadFull()\n\t}\n\n\t// Reset memory reader.\n\tbw.memReader = bytes.NewReader(bw.memBytes)\n}\n\n// Create new reader to retrieve body contents.\n// New reader always reads body from the beginning.\n// Does not affected by Rewind().\nfunc (bw *bodyWrapper) GetBody() (io.ReadCloser, error) {\n\tbw.mu.Lock()\n\tdefer bw.mu.Unlock()\n\n\tbw.isReadBefore = true\n\n\t// Preserve original reader error.\n\tif bw.readErr != nil {\n\t\treturn nil, bw.readErr\n\t}\n\n\t// GetBody() requires rewinds to be enabled.\n\tif bw.isRewindDisabled {\n\t\treturn nil, errors.New(\"rewinds are disabled, cannot get body\")\n\t}\n\n\t// If HTTP response is not fully read yet, do it now.\n\tif !bw.isFullyRead {\n\t\tif err := bw.httpReadFull(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Return fresh reader for memory chunk.\n\treturn io.NopCloser(bytes.NewReader(bw.memBytes)), nil\n}\n\n// Disables storing body contents in memory and clears the cache.\nfunc (bw *bodyWrapper) DisableRewinds() {\n\tbw.mu.Lock()\n\tdefer bw.mu.Unlock()\n\n\t// Free memory if reading from original HTTP response, or reading from memory\n\t// and memory reader has nothing left to read.\n\t// Otherwise, i.e. when we're reading from memory, and there is more to read,\n\t// memReadNext() will free memory later when it hits EOF.\n\tif !bw.isFullyRead || bw.memReader.Len() == 0 {\n\t\tbw.memReader = bytes.NewReader(nil)\n\t\tbw.memBytes = nil\n\t}\n\n\tbw.isRewindDisabled = true\n}\n\nfunc (bw *bodyWrapper) memReadNext(p []byte) (int, error) {\n\tn, err := bw.memReader.Read(p)\n\n\tif err == io.EOF {\n\t\t// Free memory after we hit EOF when reading from memory,\n\t\t// if rewinds were disabled while we were reading from it.\n\t\tif bw.isRewindDisabled {\n\t\t\tbw.memReader = bytes.NewReader(nil)\n\t\t\tbw.memBytes = nil\n\t\t}\n\t\tif bw.readErr != nil {\n\t\t\terr = bw.readErr\n\t\t}\n\t}\n\n\treturn n, err\n}\n\nfunc (bw *bodyWrapper) httpReadNext(p []byte) (int, error) {\n\tn, err := bw.httpReader.Read(p)\n\n\tif n > 0 {\n\t\tbw.memBytes = append(bw.memBytes, p[:n]...)\n\t}\n\n\tif err != nil {\n\t\tif err != io.EOF {\n\t\t\tbw.readErr = err\n\t\t}\n\t\tif closeErr := bw.closeAndCancel(); closeErr != nil && err == io.EOF {\n\t\t\terr = closeErr\n\t\t}\n\n\t\t// Switch to reading from memory.\n\t\tbw.isFullyRead = true\n\t\tbw.memReader = bytes.NewReader(nil)\n\t}\n\n\treturn n, err\n}\n\nfunc (bw *bodyWrapper) httpReadFull() error {\n\tb, err := io.ReadAll(bw.httpReader)\n\n\t// Switch to reading from memory.\n\tbw.isFullyRead = true\n\tbw.memBytes = append(bw.memBytes, b...)\n\tbw.memReader = bytes.NewReader(bw.memBytes[len(bw.memBytes)-len(b):])\n\n\tif err != nil {\n\t\tbw.readErr = err\n\t}\n\n\tif closeErr := bw.closeAndCancel(); closeErr != nil && err == nil {\n\t\terr = closeErr\n\t}\n\n\treturn err\n}\n\nfunc (bw *bodyWrapper) closeAndCancel() error {\n\tif bw.httpReader == nil && bw.httpCancelFunc == nil {\n\t\treturn bw.closeErr\n\t}\n\n\tif bw.httpReader != nil {\n\t\terr := bw.httpReader.Close()\n\t\tbw.httpReader = nil\n\n\t\tif bw.readErr == nil {\n\t\t\tbw.readErr = err\n\t\t}\n\n\t\tif bw.closeErr == nil {\n\t\t\tbw.closeErr = err\n\t\t}\n\t}\n\n\tif bw.httpCancelFunc != nil {\n\t\tbw.httpCancelFunc()\n\t\tbw.httpCancelFunc = nil\n\t}\n\n\t// Finalizer is not needed anymore.\n\truntime.SetFinalizer(bw, nil)\n\n\treturn bw.closeErr\n}\n"
        },
        {
          "name": "body_wrapper_test.go",
          "type": "blob",
          "size": 31.9736328125,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBodyWrapper_Close(t *testing.T) {\n\tt.Run(\"close after read\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// fully read and closed\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\t// nothing changed\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"close before read\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\terr := wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\t// fully read and closed\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\n\t\tb := make([]byte, 1)\n\n\t\tn, err := wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\t// nothing changed\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n}\n\nfunc TestBodyWrapper_Rewind(t *testing.T) {\n\tt.Run(\"readall - close - rewind - readall\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\twrp.Rewind()\n\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"rewind - readall - close - rewind - readall\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\twrp.Rewind()\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\twrp.Rewind()\n\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"readall - rewind - readall\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\n\t\twrp.Rewind()\n\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"close - rewind - readall\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\terr := wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\twrp.Rewind()\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"rewind - readall - rewind - readall\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\twrp.Rewind()\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\n\t\twrp.Rewind()\n\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"rewind - close - rewind - readall\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\twrp.Rewind()\n\n\t\terr := wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\twrp.Rewind()\n\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, cancelCount)\n\t})\n\n\tt.Run(\"readall - close - rewind (loop)\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\tcancelCount := 0\n\t\tcancelFn := func() {\n\t\t\tcancelCount++\n\t\t}\n\n\t\twrp := newBodyWrapper(body, cancelFn)\n\n\t\tn := 3\n\t\tfor i := 0; i < n; i++ {\n\t\t\tb, err := io.ReadAll(wrp)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t\tassert.NotEqual(t, 0, body.readCount)\n\t\t\tassert.Equal(t, 1, body.closeCount)\n\t\t\tassert.Equal(t, 1, cancelCount)\n\n\t\t\terr = wrp.Close()\n\t\t\tassert.NoError(t, err)\n\n\t\t\twrp.Rewind()\n\t\t}\n\t})\n}\n\nfunc TestBodyWrapper_GetBody(t *testing.T) {\n\tt.Run(\"parallel readers\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\trd1, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\n\t\trd2, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\n\t\tb, err := io.ReadAll(rd1)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tb, err = io.ReadAll(rd2)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n\n\tt.Run(\"start read - get body - finish read\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\t// Start reading body\n\t\tb := make([]byte, len(\"test\"))\n\t\tn, err := wrp.Read(b)\n\t\tassert.Equal(t, len(b), n)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test\", string(b))\n\n\t\t// Call GetBody and read from it\n\t\trd, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err = io.ReadAll(rd)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Finish reading body\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"_body\", string(b))\n\n\t\t// Check body read count and close count\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n\n\tt.Run(\"start read - rewind - get body - read again\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\t// Start reading body\n\t\tb := make([]byte, len(\"test\"))\n\t\tn, err := wrp.Read(b)\n\t\tassert.Equal(t, len(b), n)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test\", string(b))\n\n\t\t// Rewind\n\t\twrp.Rewind()\n\n\t\t// Call GetBody and read from it\n\t\trd, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err = io.ReadAll(rd)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Re-read body until EOF\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Check body read count and close count\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n\n\tt.Run(\"read all - get body - read again\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\t// Read body until EOF\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Call GetBody and read from it\n\t\trd, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err = io.ReadAll(rd)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Try to read more\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"\", string(b))\n\n\t\t// Check body read count and close count\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n\n\tt.Run(\"read all - rewind - get body - read again\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\t// Read body until EOF\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Rewind\n\t\twrp.Rewind()\n\n\t\t// Call GetBody and read from it\n\t\trd, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err = io.ReadAll(rd)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Re-read body until EOF\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Check body read count and close count\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n\n\tt.Run(\"read all - close - get body - read again\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\t// Read body until EOF\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Close\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\t// Call GetBody and read from it\n\t\trd, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err = io.ReadAll(rd)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Try to read more\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"\", string(b))\n\n\t\t// Check body read count and close count\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n\n\tt.Run(\"read all - close - rewind - get body - read again\", func(t *testing.T) {\n\t\tbody := newMockBody(\"test_body\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\t// Read body until EOF\n\t\tb, err := io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Close\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\t// Rewind\n\t\twrp.Rewind()\n\n\t\t// Call GetBody and read from it\n\t\trd, err := wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err = io.ReadAll(rd)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Try to read more\n\t\tb, err = io.ReadAll(wrp)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test_body\", string(b))\n\n\t\t// Check body read count and close count\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t})\n}\n\nfunc TestBodyWrapper_OneError(t *testing.T) {\n\tbodyErr := errors.New(\"test_error\")\n\tbodyText := \"test_body\"\n\n\tcheckReadErr := func(t *testing.T, wrp *bodyWrapper) {\n\t\tb := make([]byte, len(bodyText)+1)\n\t\tn, err := wrp.Read(b)\n\n\t\tassert.Equal(t, bodyErr, err)\n\t\tassert.Equal(t, 0, n)\n\t}\n\n\tcheckReadNoErr := func(t *testing.T, wrp *bodyWrapper) {\n\t\tb := make([]byte, len(bodyText)+1)\n\t\tn, err := wrp.Read(b)\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, len(bodyText), n)\n\t}\n\n\tcheckCloseErr := func(t *testing.T, wrp *bodyWrapper) {\n\t\terr := wrp.Close()\n\n\t\tassert.Equal(t, bodyErr, err)\n\t}\n\n\tcheckCloseNoErr := func(t *testing.T, wrp *bodyWrapper) {\n\t\terr := wrp.Close()\n\n\t\tassert.NoError(t, err)\n\t}\n\n\tcheckGetBodyErr := func(t *testing.T, wrp *bodyWrapper) {\n\t\trd, err := wrp.GetBody()\n\n\t\tassert.Equal(t, bodyErr, err)\n\t\tassert.Nil(t, rd)\n\t}\n\n\tt.Run(\"read_err, read_close\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\tbody.readErr = bodyErr\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tcheckReadErr(t, wrp)\n\t\tcheckCloseNoErr(t, wrp)\n\n\t\tcheckReadErr(t, wrp)\n\t\tcheckCloseNoErr(t, wrp)\n\t})\n\n\tt.Run(\"read_err, close_read\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\tbody.readErr = bodyErr\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tcheckCloseErr(t, wrp)\n\t\tcheckReadErr(t, wrp)\n\n\t\tcheckCloseNoErr(t, wrp)\n\t\tcheckReadErr(t, wrp)\n\t})\n\n\tt.Run(\"close_err, read_close\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\tbody.closeErr = bodyErr\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tcheckReadNoErr(t, wrp)\n\t\tcheckCloseErr(t, wrp)\n\n\t\tcheckReadErr(t, wrp)\n\t\tcheckCloseErr(t, wrp)\n\t})\n\n\tt.Run(\"close_err, close_read\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\tbody.closeErr = bodyErr\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tcheckCloseErr(t, wrp)\n\t\tcheckReadErr(t, wrp)\n\n\t\tcheckCloseErr(t, wrp)\n\t\tcheckReadErr(t, wrp)\n\t})\n\n\tt.Run(\"read_err, get_body\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\tbody.readErr = bodyErr\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tcheckGetBodyErr(t, wrp)\n\t\tcheckGetBodyErr(t, wrp)\n\t})\n\n\tt.Run(\"close_err, get_body\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\tbody.closeErr = bodyErr\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tcheckGetBodyErr(t, wrp)\n\t\tcheckGetBodyErr(t, wrp)\n\t})\n}\n\nfunc TestBodyWrapper_TwoErrors(t *testing.T) {\n\tt.Run(\"read_close\", func(t *testing.T) {\n\t\tbodyText := \"test_body\"\n\t\tbody := newMockBody(bodyText)\n\n\t\tbody.readErr = errors.New(\"read_error\")\n\t\tbody.closeErr = errors.New(\"close_error\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, len(bodyText)+1)\n\t\tvar err error\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\t_, err = wrp.Read(b)\n\t\t\tassert.Equal(t, body.readErr, err)\n\n\t\t\terr = wrp.Close()\n\t\t\tassert.Equal(t, body.closeErr, err)\n\t\t}\n\t})\n\n\tt.Run(\"close_read\", func(t *testing.T) {\n\t\tbodyText := \"test_body\"\n\t\tbody := newMockBody(bodyText)\n\n\t\tbody.readErr = errors.New(\"read_error\")\n\t\tbody.closeErr = errors.New(\"close_error\")\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, len(bodyText)+1)\n\t\tvar err error\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\terr = wrp.Close()\n\t\t\tassert.Equal(t, body.closeErr, err)\n\n\t\t\t_, err = wrp.Read(b)\n\t\t\tassert.Equal(t, body.readErr, err)\n\t\t}\n\t})\n}\n\nfunc TestBodyWrapper_RewindError(t *testing.T) {\n\tbodyText := \"test_body\"\n\tbody := newMockBody(bodyText)\n\n\tbody.readErr = errors.New(\"read_error\")\n\tbody.closeErr = errors.New(\"close_error\")\n\n\twrp := newBodyWrapper(body, nil)\n\n\tb := make([]byte, len(bodyText)+1)\n\tvar err error\n\n\tfor i := 0; i < 2; i++ {\n\t\t_, err = wrp.Read(b)\n\t\tassert.NotNil(t, err)\n\n\t\terr = wrp.Close()\n\t\tassert.NotNil(t, err)\n\n\t\t_, err = wrp.GetBody()\n\t\tassert.NotNil(t, err)\n\t}\n\n\twrp.Rewind()\n\n\tbody.readErr = nil\n\tbody.closeErr = nil\n\n\tfor i := 0; i < 2; i++ {\n\t\t_, err = wrp.Read(b)\n\t\tassert.NotNil(t, err)\n\n\t\terr = wrp.Close()\n\t\tassert.NotNil(t, err)\n\n\t\t_, err = wrp.GetBody()\n\t\tassert.NotNil(t, err)\n\t}\n}\n\nfunc TestBodyWrapper_Memory(t *testing.T) {\n\tt.Run(\"unaligned read\", func(t *testing.T) {\n\t\tbodyText := \"123456789\"\n\t\tbodyChunks := []string{\"1234\", \"5678\", \"9\"}\n\n\t\tbody := newMockBody(bodyText)\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr error\n\t\t\tn   int\n\t\t)\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tn, err = wrp.Read(b)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, 4, n)\n\t\t\tassert.Equal(t, bodyChunks[i], string(b))\n\n\t\t\tassert.False(t, wrp.isFullyRead)\n\t\t\tassert.Equal(t, bodyText[:(i+1)*4], string(wrp.memBytes))\n\n\t\t\tassert.Equal(t, i+1, body.readCount)\n\t\t\tassert.Equal(t, 0, body.closeCount)\n\t\t\tassert.Equal(t, 0, body.eofCount)\n\t\t}\n\n\t\t// last read is incomplete\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 1, n)\n\t\tassert.Equal(t, bodyChunks[2], string(b[:n]))\n\n\t\tassert.False(t, wrp.isFullyRead) // not fully read until the next read\n\t\tassert.Equal(t, bodyText, string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, bodyText, string(wrp.memBytes))\n\n\t\tassert.Equal(t, 4, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"aligned read\", func(t *testing.T) {\n\t\tbodyText := \"12345678\"\n\t\tbodyChunks := []string{\"1234\", \"5678\"}\n\n\t\tbody := newMockBody(bodyText)\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr error\n\t\t\tn   int\n\t\t)\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tn, err = wrp.Read(b)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, 4, n)\n\t\t\tassert.Equal(t, bodyChunks[i], string(b))\n\n\t\t\tassert.False(t, wrp.isFullyRead)\n\t\t\tassert.Equal(t, bodyText[:(i+1)*4], string(wrp.memBytes))\n\n\t\t\tassert.Equal(t, i+1, body.readCount)\n\t\t\tassert.Equal(t, 0, body.closeCount)\n\t\t\tassert.Equal(t, 0, body.eofCount)\n\t\t}\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, bodyText, string(wrp.memBytes))\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, bodyText, string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"partial read\", func(t *testing.T) {\n\t\tbuffer := bytes.NewBufferString(\"\")\n\t\tbody := &mockBody{\n\t\t\treader: buffer,\n\t\t}\n\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr error\n\t\t\tn   int\n\t\t)\n\n\t\t// add bytes to response\n\t\tbuffer.Write([]byte(\"1234\"))\n\n\t\t// partial read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b[:4]))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"1234\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// add bytes to response\n\t\tbuffer.Write([]byte(\"5678\"))\n\n\t\t// another partial read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"5678\", string(b[:4]))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"rewind\", func(t *testing.T) {\n\t\tbody := newMockBody(\"123456789\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr error\n\t\t\tn   int\n\t\t)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"1234\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// rewind\n\t\twrp.Rewind()\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"123456789\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// new first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b))\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"123456789\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"get body\", func(t *testing.T) {\n\t\tbody := newMockBody(\"123456789\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr    error\n\t\t\tn      int\n\t\t\treader io.ReadCloser\n\t\t)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"1234\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// get body between reads\n\t\treader, err = wrp.GetBody()\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, reader)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"123456789\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// check body\n\t\tc, err := io.ReadAll(reader)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"123456789\", string(c))\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"123456789\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// second read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"5678\", string(b))\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"123456789\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n}\n\nfunc TestBodyWrapper_DisableRewinds(t *testing.T) {\n\tt.Run(\"disable rewinds before first read\", func(t *testing.T) {\n\t\tbody := newMockBody(\"12345678\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr    error\n\t\t\tn      int\n\t\t\treader io.ReadCloser\n\t\t)\n\n\t\t// disable rewinds\n\t\twrp.DisableRewinds()\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// does not work\n\t\treader, err = wrp.GetBody()\n\t\tassert.EqualError(t, err, \"rewinds are disabled, cannot get body\")\n\t\tassert.Nil(t, reader)\n\n\t\t// no-op\n\t\twrp.Rewind()\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// second read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"5678\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// close\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"disable rewinds during read from http\", func(t *testing.T) {\n\t\tbody := newMockBody(\"12345678\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 4)\n\t\tvar (\n\t\t\terr    error\n\t\t\tn      int\n\t\t\treader io.ReadCloser\n\t\t)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"1234\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// disable rewinds\n\t\twrp.DisableRewinds()\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// does not work\n\t\treader, err = wrp.GetBody()\n\t\tassert.EqualError(t, err, \"rewinds are disabled, cannot get body\")\n\t\tassert.Nil(t, reader)\n\n\t\t// no-op\n\t\twrp.Rewind()\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// second read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"5678\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// close\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 3, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"disable rewinds after full read from http\", func(t *testing.T) {\n\t\tbody := newMockBody(\"12345678\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 8)\n\t\tvar (\n\t\t\terr    error\n\t\t\tn      int\n\t\t\treader io.ReadCloser\n\t\t)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 8, n)\n\t\tassert.Equal(t, \"12345678\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// disable rewinds\n\t\twrp.DisableRewinds()\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// does not work\n\t\treader, err = wrp.GetBody()\n\t\tassert.EqualError(t, err, \"rewinds are disabled, cannot get body\")\n\t\tassert.Nil(t, reader)\n\n\t\t// no-op\n\t\twrp.Rewind()\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// close\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"disable rewinds during read from memory\", func(t *testing.T) {\n\t\tbody := newMockBody(\"12345678\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 8)\n\t\tvar (\n\t\t\terr    error\n\t\t\tn      int\n\t\t\treader io.ReadCloser\n\t\t)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 8, n)\n\t\tassert.Equal(t, \"12345678\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// rewind\n\t\twrp.Rewind()\n\n\t\t// new first read\n\t\tn, err = wrp.Read(b[:4])\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b[:4]))\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// disable rewinds\n\t\twrp.DisableRewinds()\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// does not work\n\t\treader, err = wrp.GetBody()\n\t\tassert.EqualError(t, err, \"rewinds are disabled, cannot get body\")\n\t\tassert.Nil(t, reader)\n\n\t\t// no-op\n\t\twrp.Rewind()\n\n\t\t// second read\n\t\tn, err = wrp.Read(b[:4])\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"5678\", string(b[:4]))\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// no-op\n\t\twrp.Rewind()\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n\n\tt.Run(\"disable rewinds during read from memory before closing\", func(t *testing.T) {\n\t\tbody := newMockBody(\"12345678\")\n\t\twrp := newBodyWrapper(body, nil)\n\n\t\tb := make([]byte, 8)\n\t\tvar (\n\t\t\terr error\n\t\t\tn   int\n\t\t)\n\n\t\t// first read\n\t\tn, err = wrp.Read(b)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 8, n)\n\t\tassert.Equal(t, \"12345678\", string(b))\n\n\t\tassert.False(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 1, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Equal(t, 0, body.eofCount)\n\n\t\t// read eof\n\t\tn, err = wrp.Read(b)\n\t\tassert.Error(t, io.EOF, err)\n\t\tassert.Equal(t, 0, n)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// rewind\n\t\twrp.Rewind()\n\n\t\t// new first read\n\t\tn, err = wrp.Read(b[:4])\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, 4, n)\n\t\tassert.Equal(t, \"1234\", string(b[:4]))\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// disable rewinds\n\t\twrp.DisableRewinds()\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Equal(t, \"12345678\", string(wrp.memBytes))\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\n\t\t// close\n\t\terr = wrp.Close()\n\t\tassert.NoError(t, err)\n\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.Nil(t, wrp.memBytes)\n\n\t\tassert.Equal(t, 2, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, 1, body.eofCount)\n\t})\n}\n\nfunc TestBodyWrapper_DisableRewindsErrors(t *testing.T) {\n\tbodyText := \"test_body\"\n\n\tt.Run(\"rewinds are disabled before first read\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\twrp := newBodyWrapper(body, nil)\n\t\tbodyErr := errors.New(\"read_error\")\n\t\tbody.readErr = bodyErr\n\t\tb := make([]byte, len(bodyText)+1)\n\n\t\t// disable rewinds before first read\n\t\twrp.DisableRewinds()\n\n\t\t// Read calls body.Read, which fails\n\t\t_, err := wrp.Read(b)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 1, body.readCount)\n\n\t\t// Read calls body.Read again, which fails again\n\t\t_, err = wrp.Read(b)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 2, body.readCount)\n\t})\n\n\tt.Run(\"rewinds are disabled after read error\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\twrp := newBodyWrapper(body, nil)\n\t\tbodyErr := errors.New(\"read_error\")\n\t\tbody.readErr = bodyErr\n\t\tb := make([]byte, len(bodyText)+1)\n\n\t\t// Read calls body.Read, which fails\n\t\t_, err := wrp.Read(b)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 1, body.readCount)\n\n\t\t// disable rewinds after failed read\n\t\twrp.DisableRewinds()\n\n\t\t// Read returns cached error from previous call\n\t\t_, err = wrp.Read(b)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 1, body.readCount)\n\t})\n\n\tt.Run(\"rewinds are disabled after close error\", func(t *testing.T) {\n\t\tbody := newMockBody(bodyText)\n\t\twrp := newBodyWrapper(body, nil)\n\t\tbodyErr := errors.New(\"close_error\")\n\t\tbody.closeErr = bodyErr\n\t\tb := make([]byte, len(bodyText)+1)\n\n\t\t// Close calls body.Read, then body.Close, which fails\n\t\terr := wrp.Close()\n\t\tassert.True(t, wrp.isFullyRead)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 2, body.readCount)\n\n\t\t// disable rewinds after failed close\n\t\twrp.DisableRewinds()\n\n\t\t// Read returns cached error from Close call\n\t\t_, err = wrp.Read(b)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 2, body.readCount)\n\n\t\t// Read returns cached error from Close call, again\n\t\t_, err = wrp.Read(b)\n\t\tassert.EqualError(t, err, bodyErr.Error())\n\t\tassert.Equal(t, 2, body.readCount)\n\t})\n}\n"
        },
        {
          "name": "boolean.go",
          "type": "blob",
          "size": 6.5859375,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n)\n\n// Boolean provides methods to inspect attached bool value\n// (Go representation of JSON boolean).\ntype Boolean struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  bool\n}\n\n// NewBoolean returns a new Boolean instance.\n//\n// If reporter is nil, the function panics.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tboolean.IsTrue()\nfunc NewBoolean(reporter Reporter, value bool) *Boolean {\n\treturn newBoolean(newChainWithDefaults(\"Boolean()\", reporter), value)\n}\n\n// NewBooleanC returns a new Boolean instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// Example:\n//\n//\tboolean := NewBooleanC(config, true)\n//\tboolean.IsTrue()\nfunc NewBooleanC(config Config, value bool) *Boolean {\n\treturn newBoolean(newChainWithConfig(\"Boolean()\", config.withDefaults()), value)\n}\n\nfunc newBoolean(parent *chain, val bool) *Boolean {\n\treturn &Boolean{chain: parent.clone(), value: val}\n}\n\n// Raw returns underlying value attached to Boolean.\n// This is the value originally passed to NewBoolean.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tassert.Equal(t, true, boolean.Raw())\nfunc (b *Boolean) Raw() bool {\n\treturn b.value\n}\n\n// Decode unmarshals the underlying value attached to the Boolean to a target variable.\n// target should be one of these:\n//\n//   - pointer to an empty interface\n//   - pointer to a boolean\n//\n// Example:\n//\n//\tvalue := NewBoolean(t, true)\n//\n//\tvar target bool\n//\tvalue.Decode(&target)\n//\n//\tassert.Equal(t, true, target)\nfunc (b *Boolean) Decode(target interface{}) *Boolean {\n\topChain := b.chain.enter(\"Decode()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tcanonDecode(opChain, b.value, target)\n\treturn b\n}\n\n// Alias is similar to Value.Alias.\nfunc (b *Boolean) Alias(name string) *Boolean {\n\topChain := b.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tb.chain.setAlias(name)\n\treturn b\n}\n\n// Path is similar to Value.Path.\nfunc (b *Boolean) Path(path string) *Value {\n\topChain := b.chain.enter(\"Path(%q)\", path)\n\tdefer opChain.leave()\n\n\treturn jsonPath(opChain, b.value, path)\n}\n\n// Schema is similar to Value.Schema.\nfunc (b *Boolean) Schema(schema interface{}) *Boolean {\n\topChain := b.chain.enter(\"Schema()\")\n\tdefer opChain.leave()\n\n\tjsonSchema(opChain, b.value, schema)\n\treturn b\n}\n\n// IsTrue succeeds if boolean is true.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tboolean.IsTrue()\nfunc (b *Boolean) IsTrue() *Boolean {\n\topChain := b.chain.enter(\"IsTrue()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tif !(b.value == true) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{b.value},\n\t\t\tExpected: &AssertionValue{true},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: boolean is true\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn b\n}\n\n// IsFalse succeeds if boolean is false.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, false)\n//\tboolean.IsFalse()\nfunc (b *Boolean) IsFalse() *Boolean {\n\topChain := b.chain.enter(\"IsFalse()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tif !(b.value == false) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{b.value},\n\t\t\tExpected: &AssertionValue{false},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: boolean is false\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn b\n}\n\n// Deprecated: use IsTrue instead.\nfunc (b *Boolean) True() *Boolean {\n\treturn b.IsTrue()\n}\n\n// Deprecated: use IsFalse instead.\nfunc (b *Boolean) False() *Boolean {\n\treturn b.IsFalse()\n}\n\n// IsEqual succeeds if boolean is equal to given value.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tboolean.IsEqual(true)\nfunc (b *Boolean) IsEqual(value bool) *Boolean {\n\topChain := b.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tif !(b.value == value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{b.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: booleans are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn b\n}\n\n// NotEqual succeeds if boolean is not equal to given value.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tboolean.NotEqual(false)\nfunc (b *Boolean) NotEqual(value bool) *Boolean {\n\topChain := b.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tif b.value == value {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{b.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: booleans are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn b\n}\n\n// Deprecated: use IsEqual instead.\nfunc (b *Boolean) Equal(value bool) *Boolean {\n\treturn b.IsEqual(value)\n}\n\n// InList succeeds if boolean is equal to one of the values from given\n// list of booleans.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tboolean.InList(true, false)\nfunc (b *Boolean) InList(values ...bool) *Boolean {\n\topChain := b.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn b\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\tif b.value == v {\n\t\t\tisListed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !isListed {\n\t\tvalueList := make([]interface{}, 0, len(values))\n\t\tfor _, v := range values {\n\t\t\tvalueList = append(valueList, v)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{b.value},\n\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: boolean is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn b\n}\n\n// NotInList succeeds if boolean is not equal to any of the values from\n// given list of booleans.\n//\n// Example:\n//\n//\tboolean := NewBoolean(t, true)\n//\tboolean.NotInList(true, false) // failure\nfunc (b *Boolean) NotInList(values ...bool) *Boolean {\n\topChain := b.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn b\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn b\n\t}\n\n\tfor _, v := range values {\n\t\tif b.value == v {\n\t\t\tvalueList := make([]interface{}, 0, len(values))\n\t\t\tfor _, v := range values {\n\t\t\t\tvalueList = append(valueList, v)\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{b.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: boolean is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treturn b\n\t\t}\n\t}\n\n\treturn b\n}\n"
        },
        {
          "name": "boolean_test.go",
          "type": "blob",
          "size": 5.0146484375,
          "content": "package httpexpect\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBoolean_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\tvalue := newBoolean(chain, false)\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Path(\"$\").chain.assert(t, failure)\n\tvalue.Schema(\"\")\n\tvalue.Alias(\"foo\")\n\n\tvar target interface{}\n\tvalue.Decode(&target)\n\n\tvalue.IsTrue()\n\tvalue.IsFalse()\n\tvalue.IsEqual(false)\n\tvalue.NotEqual(false)\n\tvalue.InList(false)\n\tvalue.NotInList(false)\n}\n\nfunc TestBoolean_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewBoolean(reporter, true)\n\t\tvalue.IsEqual(true)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewBooleanC(Config{\n\t\t\tReporter: reporter,\n\t\t}, true)\n\t\tvalue.IsEqual(true)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newBoolean(chain, true)\n\t\tassert.NotSame(t, value.chain, &chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestBoolean_Raw(t *testing.T) {\n\tfor _, data := range []bool{true, false} {\n\t\tt.Run(fmt.Sprintf(\"%v\", data), func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewBoolean(reporter, data)\n\n\t\t\tassert.Equal(t, data, value.Raw())\n\t\t\tvalue.chain.assert(t, success)\n\t\t})\n\t}\n}\n\nfunc TestBoolean_Decode(t *testing.T) {\n\tt.Run(\"target is empty interface\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewBoolean(reporter, true)\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, true, target)\n\t})\n\n\tt.Run(\"target is bool\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewBoolean(reporter, true)\n\n\t\tvar target bool\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, true, target)\n\t})\n\n\tt.Run(\"target is nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewBoolean(reporter, true)\n\n\t\tvalue.Decode(nil)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"target is unmarshable\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewBoolean(reporter, true)\n\n\t\tvalue.Decode(123)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestBoolean_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewBoolean(reporter, true)\n\tassert.Equal(t, []string{\"Boolean()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Boolean()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Boolean()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestBoolean_Path(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewBoolean(reporter, true)\n\n\tassert.Equal(t, true, value.Path(\"$\").Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestBoolean_Schema(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tNewBoolean(reporter, true).Schema(`{\"type\": \"boolean\"}`).\n\t\tchain.assert(t, success)\n\n\tNewBoolean(reporter, true).Schema(`{\"type\": \"object\"}`).\n\t\tchain.assert(t, failure)\n}\n\nfunc TestBoolean_IsEqual(t *testing.T) {\n\tfor _, data := range []bool{true, false} {\n\t\tt.Run(fmt.Sprintf(\"%v\", data), func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewBoolean(reporter, data).IsEqual(data).\n\t\t\t\tchain.assert(t, success)\n\n\t\t\tNewBoolean(reporter, data).IsEqual(!data).\n\t\t\t\tchain.assert(t, failure)\n\n\t\t\tNewBoolean(reporter, data).NotEqual(data).\n\t\t\t\tchain.assert(t, failure)\n\n\t\t\tNewBoolean(reporter, data).NotEqual(!data).\n\t\t\t\tchain.assert(t, success)\n\t\t})\n\t}\n}\n\nfunc TestBoolean_IsValue(t *testing.T) {\n\tfor _, data := range []bool{true, false} {\n\t\tt.Run(fmt.Sprintf(\"%v\", data), func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tif data {\n\t\t\t\tNewBoolean(reporter, data).IsTrue().\n\t\t\t\t\tchain.assert(t, success)\n\n\t\t\t\tNewBoolean(reporter, data).IsFalse().\n\t\t\t\t\tchain.assert(t, failure)\n\t\t\t} else {\n\t\t\t\tNewBoolean(reporter, data).IsTrue().\n\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\tNewBoolean(reporter, data).IsFalse().\n\t\t\t\t\tchain.assert(t, success)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBoolean_InList(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tfor _, data := range []bool{true, false} {\n\t\t\tt.Run(fmt.Sprintf(\"%v\", data), func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewBoolean(reporter, data).InList(data).\n\t\t\t\t\tchain.assert(t, success)\n\n\t\t\t\tNewBoolean(reporter, data).InList(!data, data).\n\t\t\t\t\tchain.assert(t, success)\n\n\t\t\t\tNewBoolean(reporter, data).InList(!data, !data).\n\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\tNewBoolean(reporter, data).NotInList(data).\n\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\tNewBoolean(reporter, data).NotInList(!data, data).\n\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\tNewBoolean(reporter, data).NotInList(!data, !data).\n\t\t\t\t\tchain.assert(t, success)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\tfor _, data := range []bool{true, false} {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewBoolean(reporter, data).InList().\n\t\t\t\tchain.assert(t, failure)\n\n\t\t\tNewBoolean(reporter, data).NotInList().\n\t\t\t\tchain.assert(t, failure)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "canon.go",
          "type": "blob",
          "size": 2.5791015625,
          "content": "package httpexpect\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc canonNumber(opChain *chain, in interface{}) (out float64, ok bool) {\n\tok = true\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{in},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: valid number\"),\n\t\t\t\t\tfmt.Errorf(\"%s\", err),\n\t\t\t\t},\n\t\t\t})\n\t\t\tok = false\n\t\t}\n\t}()\n\tout = reflect.ValueOf(in).Convert(reflect.TypeOf(float64(0))).Float()\n\treturn\n}\n\nfunc canonArray(opChain *chain, in interface{}) ([]interface{}, bool) {\n\tvar out []interface{}\n\tdata, ok := canonValue(opChain, in)\n\tif ok {\n\t\tout, ok = data.([]interface{})\n\t\tif !ok {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{in},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: valid array\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\treturn out, ok\n}\n\nfunc canonMap(opChain *chain, in interface{}) (map[string]interface{}, bool) {\n\tvar out map[string]interface{}\n\tdata, ok := canonValue(opChain, in)\n\tif ok {\n\t\tout, ok = data.(map[string]interface{})\n\t\tif !ok {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{in},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: valid map\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\treturn out, ok\n}\n\nfunc canonValue(opChain *chain, in interface{}) (interface{}, bool) {\n\tb, err := json.Marshal(in)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{in},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: marshalable value\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil, false\n\t}\n\n\tvar out interface{}\n\tif err := json.Unmarshal(b, &out); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{in},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: unmarshalable value\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil, false\n\t}\n\n\treturn out, true\n}\n\nfunc canonDecode(opChain *chain, value interface{}, target interface{}) {\n\tif target == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil target argument\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tb, err := json.Marshal(value)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: marshable value\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif err := json.Unmarshal(b, target); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{target},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value can be unmarshaled into target argument\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "canon_test.go",
          "type": "blob",
          "size": 4.24609375,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCanon_Number(t *testing.T) {\n\ttype myInt int\n\n\tcases := []struct {\n\t\tname   string\n\t\tin     interface{}\n\t\tout    interface{}\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"input is int\",\n\t\t\tin:     123,\n\t\t\tout:    123.0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is float\",\n\t\t\tin:     123.0,\n\t\t\tout:    123.0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is myInt\",\n\t\t\tin:     myInt(123),\n\t\t\tout:    123.0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is string\",\n\t\t\tin:     \"123\",\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is nil\",\n\t\t\tin:     nil,\n\t\t\tresult: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchain := newMockChain(t).enter(\"test\")\n\t\t\tdefer chain.leave()\n\n\t\t\tval, ok := canonNumber(chain, tc.in)\n\t\t\tassert.Equal(t, tc.result, chainResult(ok))\n\n\t\t\tchain.assert(t, tc.result)\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.out, val)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCannon_Array(t *testing.T) {\n\ttype (\n\t\tmyInt   int\n\t\tmyArray []interface{}\n\t)\n\n\tcases := []struct {\n\t\tname   string\n\t\tin     interface{}\n\t\tout    interface{}\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"input is []interface{}\",\n\t\t\tin:     []interface{}{123.0, 456.0},\n\t\t\tout:    []interface{}{123.0, 456.0},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is myArray{}\",\n\t\t\tin:     myArray{myInt(123), 456.0},\n\t\t\tout:    []interface{}{123.0, 456.0},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is string\",\n\t\t\tin:     \"123\",\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is func() {}\",\n\t\t\tin:     func() {},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is nil\",\n\t\t\tin:     nil,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is []interface{}(nil)\",\n\t\t\tin:     []interface{}(nil),\n\t\t\tresult: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchain := newMockChain(t).enter(\"test\")\n\t\t\tdefer chain.leave()\n\n\t\t\tval, ok := canonArray(chain, tc.in)\n\t\t\tassert.Equal(t, tc.result, chainResult(ok))\n\n\t\t\tchain.assert(t, tc.result)\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.out, val)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCanon_Map(t *testing.T) {\n\ttype (\n\t\tmyInt int\n\t\tmyMap map[string]interface{}\n\t)\n\n\tcases := []struct {\n\t\tname   string\n\t\tin     interface{}\n\t\tout    interface{}\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"input is map[string]interface{}{}\",\n\t\t\tin:     map[string]interface{}{\"foo\": 123.0},\n\t\t\tout:    map[string]interface{}{\"foo\": 123.0},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is myMap{}\",\n\t\t\tin:     myMap{\"foo\": myInt(123)},\n\t\t\tout:    map[string]interface{}{\"foo\": 123.0},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is string\",\n\t\t\tin:     \"123\",\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is func() {}\",\n\t\t\tin:     func() {},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is nil\",\n\t\t\tin:     nil,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"input is map[string]interface{}(nil)\",\n\t\t\tin:     map[string]interface{}(nil),\n\t\t\tresult: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchain := newMockChain(t).enter(\"test\")\n\t\t\tdefer chain.leave()\n\n\t\t\tval, ok := canonMap(chain, tc.in)\n\t\t\tassert.Equal(t, tc.result, chainResult(ok))\n\n\t\t\tchain.assert(t, tc.result)\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.out, val)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCannon_Decode(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tvalue  interface{}\n\t\ttarget interface{}\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"string\",\n\t\t\tvalue:  \"foo\",\n\t\t\ttarget: new(string),\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"int\",\n\t\t\tvalue:  123,\n\t\t\ttarget: new(int),\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"any\",\n\t\t\tvalue:  123,\n\t\t\ttarget: new(interface{}),\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"target is nil\",\n\t\t\tvalue:  123,\n\t\t\ttarget: nil,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"unmarshallable value\",\n\t\t\tvalue:  func() {},\n\t\t\ttarget: new(interface{}),\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"incompatible value\",\n\t\t\tvalue:  \"foo\",\n\t\t\ttarget: new(int),\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"target is not a pointer\",\n\t\t\tvalue:  123,\n\t\t\ttarget: 123,\n\t\t\tresult: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchain := newMockChain(t).enter(\"test\")\n\t\t\tdefer chain.leave()\n\n\t\t\tcanonDecode(chain, tc.value, tc.target)\n\t\t\tchain.assert(t, tc.result)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "chain.go",
          "type": "blob",
          "size": 12.46875,
          "content": "package httpexpect\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Every matcher struct, e.g. Value, Object, Array, etc. contains a chain instance.\n//\n// Most important chain fields are:\n//\n//   - AssertionContext: provides test name, current request and response, and path\n//     to current assertion starting from chain root\n//\n//   - AssertionHandler: provides methods to handle successful and failed assertions;\n//     may be defined by user, but usually we just use DefaulAssertionHandler\n//\n//   - AssertionSeverity: severity to be used for failures (fatal or non-fatal)\n//\n//   - Reference to parent: every chain remembers its parent chain; on failure,\n//     chain automatically marks its parents failed\n//\n//   - Failure flags: flags indicating whether a failure occurred on chain, or\n//     on any of its children\n//\n// Chains are linked into a tree. Child chain corresponds to nested matchers\n// and assertions. For example, when the user invokes:\n//\n//\te.GET(\"/test\").Expect().JSON().IsEqual(...)\n//\n// each nested call (GET, Expect, JSON, Equal) will create a child chain.\n//\n// There are two ways to create a child chain:\n//\n//   - use enter() / leave()\n//   - use clone()\n//\n// enter() creates a chain to be used during assertion. After calling enter(), you\n// can use fail() to report any failures, which will pass it to AssertionHandler\n// and mark chain as failed.\n//\n// After assertion is done, you should call leave(). If there were no failures,\n// leave() will notify AssertionHandler about succeeded assertion. Otherwise,\n// leave() will mark its parent as failed and notify grand-, grand-grand-, etc\n// parents that they have failed children.\n//\n// If the assertion wants to create child matcher struct, it should invoke clone()\n// after calling enter() and before calling leave().\n//\n// enter() receives assertion name as an argument. This name is appended to the\n// path in AssertionContext. If you call clone() on this chain, it will inherit\n// this path. This way chain maintains path of the nested assertions.\n//\n// Typical workflow looks like:\n//\n//\t// create temporary chain for assertion\n//\topChain := array.chain.enter(\"AssertionName()\")\n//\n//\t// optional: report assertion failure\n//\topChain.fail(...)\n//\n//\t// optional: create child matcher\n//\tchild := &Value{chain: opChain.clone(), ...}\n//\n//\t// if there was a failure, propagate it back to array.chain and notify\n//\t// parents of array.chain that they have failed children\n//\topChain.leave()\ntype chain struct {\n\tmu sync.Mutex\n\n\tparent *chain\n\tstate  chainState\n\tflags  chainFlags\n\n\tcontext  AssertionContext\n\thandler  AssertionHandler\n\tseverity AssertionSeverity\n\tfailure  *AssertionFailure\n}\n\n// If enabled, chain will panic if used incorrectly or gets illformed AssertionFailure.\n// Used only in our own tests.\nvar chainValidation = false\n\ntype chainState int\n\nconst (\n\tstateCloned  chainState = iota // chain was created using clone()\n\tstateEntered                   // chain was created using enter()\n\tstateLeaved                    // leave() was called\n)\n\ntype chainFlags int\n\nconst (\n\tflagFailed         chainFlags = (1 << iota) // fail() was called on this chain\n\tflagFailedChildren                          // fail() was called on any child\n)\n\ntype chainResult bool\n\nconst (\n\tsuccess chainResult = true\n\tfailure chainResult = false\n)\n\n// Construct chain using config.\nfunc newChainWithConfig(name string, config Config) *chain {\n\tconfig.validate()\n\n\tc := &chain{\n\t\tcontext:  AssertionContext{},\n\t\thandler:  config.AssertionHandler,\n\t\tseverity: SeverityError,\n\t}\n\n\tc.context.TestName = config.TestName\n\n\tif name != \"\" {\n\t\tc.context.Path = []string{name}\n\t\tc.context.AliasedPath = []string{name}\n\t} else {\n\t\tc.context.Path = []string{}\n\t\tc.context.AliasedPath = []string{}\n\t}\n\n\tif config.Environment != nil {\n\t\tc.context.Environment = config.Environment\n\t} else {\n\t\tc.context.Environment = newEnvironment(c)\n\t}\n\n\tc.context.TestingTB = isTestingTB(c.handler)\n\n\treturn c\n}\n\n// Construct chain using DefaultAssertionHandler and provided Reporter.\nfunc newChainWithDefaults(name string, reporter Reporter, flag ...chainFlags) *chain {\n\tif reporter == nil {\n\t\tpanic(\"Reporter is nil\")\n\t}\n\n\tc := &chain{\n\t\tcontext: AssertionContext{},\n\t\thandler: &DefaultAssertionHandler{\n\t\t\tFormatter: &DefaultFormatter{},\n\t\t\tReporter:  reporter,\n\t\t},\n\t\tseverity: SeverityError,\n\t}\n\n\tif name != \"\" {\n\t\tc.context.Path = []string{name}\n\t\tc.context.AliasedPath = []string{name}\n\t} else {\n\t\tc.context.Path = []string{}\n\t\tc.context.AliasedPath = []string{}\n\t}\n\n\tc.context.Environment = newEnvironment(c)\n\n\tc.context.TestingTB = isTestingTB(c.handler)\n\n\tfor _, f := range flag {\n\t\tc.flags |= f\n\t}\n\n\treturn c\n}\n\n// Get environment instance.\n// Root chain constructor either gets environment from config or creates a new one.\n// Child chains inherit environment from parent.\nfunc (c *chain) env() *Environment {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.context.Environment\n}\n\n// Make this chain to be root.\n// Chain's parent field is cleared.\n// Failures wont be propagated to the upper chains anymore.\nfunc (c *chain) setRoot() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tc.parent = nil\n}\n\n// Set severity of reported failures.\n// Chain always overrides failure severity with configured one.\nfunc (c *chain) setSeverity(severity AssertionSeverity) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tc.severity = severity\n}\n\n// Reset aliased path to given string.\nfunc (c *chain) setAlias(name string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tif name != \"\" {\n\t\tc.context.AliasedPath = []string{name}\n\t} else {\n\t\tc.context.AliasedPath = []string{}\n\t}\n}\n\n// Store request name in AssertionContext.\n// Child chains inherit context from parent.\nfunc (c *chain) setRequestName(name string) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tc.context.RequestName = name\n}\n\n// Store request pointer in AssertionContext.\n// Child chains inherit context from parent.\nfunc (c *chain) setRequest(req *Request) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tif chainValidation && c.context.Request != nil {\n\t\tpanic(\"context.Request already set\")\n\t}\n\n\tc.context.Request = req\n}\n\n// Store response pointer in AssertionContext.\n// Child chains inherit context from parent.\nfunc (c *chain) setResponse(resp *Response) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tif chainValidation && c.context.Response != nil {\n\t\tpanic(\"context.Response already set\")\n\t}\n\n\tc.context.Response = resp\n}\n\n// Set assertion handler\n// Chain always overrides assertion handler with given one.\nfunc (c *chain) setHandler(handler AssertionHandler) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tc.handler = handler\n\tc.context.TestingTB = isTestingTB(handler)\n}\n\n// Create chain clone.\n// Typically is called between enter() and leave().\nfunc (c *chain) clone() *chain {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state == stateLeaved {\n\t\tpanic(\"can't use chain after leave\")\n\t}\n\n\tcontextCopy := c.context\n\tcontextCopy.Path = append(([]string)(nil), contextCopy.Path...)\n\tcontextCopy.AliasedPath = append(([]string)(nil), c.context.AliasedPath...)\n\n\treturn &chain{\n\t\tparent: c,\n\t\tstate:  stateCloned,\n\t\t// flagFailedChildren is not inherited because the newly created clone\n\t\t// doesn't have children\n\t\tflags:    (c.flags & ^flagFailedChildren),\n\t\tcontext:  contextCopy,\n\t\thandler:  c.handler,\n\t\tseverity: c.severity,\n\t\t// failure is not inherited because it should be reported only once\n\t\t// by the chain where it happened\n\t\tfailure: nil,\n\t}\n}\n\n// Create temporary chain clone to be used in assertion.\n// If name is not empty, it is appended to the path.\n// You must call leave() at the end of assertion.\nfunc (c *chain) enter(name string, args ...interface{}) *chain {\n\tchainCopy := c.clone()\n\n\tchainCopy.state = stateEntered\n\tif name != \"\" {\n\t\tchainCopy.context.Path = append(chainCopy.context.Path, fmt.Sprintf(name, args...))\n\t\tchainCopy.context.AliasedPath =\n\t\t\tappend(c.context.AliasedPath, fmt.Sprintf(name, args...))\n\t}\n\n\treturn chainCopy\n}\n\n// Like enter(), but it replaces last element of the path instead appending to it.\n// Must be called between enter() and leave().\nfunc (c *chain) replace(name string, args ...interface{}) *chain {\n\tif chainValidation {\n\t\tfunc() {\n\t\t\tc.mu.Lock()\n\t\t\tdefer c.mu.Unlock()\n\n\t\t\tif c.state != stateEntered {\n\t\t\t\tpanic(\"replace allowed only between enter/leave\")\n\t\t\t}\n\t\t\tif len(c.context.Path) == 0 {\n\t\t\t\tpanic(\"replace allowed only if path is non-empty\")\n\t\t\t}\n\t\t\tif len(c.context.AliasedPath) == 0 {\n\t\t\t\tpanic(\"replace allowed only if aliased path is non-empty\")\n\t\t\t}\n\t\t}()\n\t}\n\n\tchainCopy := c.clone()\n\n\tchainCopy.state = stateEntered\n\tif len(chainCopy.context.Path) != 0 {\n\t\tlast := len(chainCopy.context.Path) - 1\n\t\tchainCopy.context.Path[last] = fmt.Sprintf(name, args...)\n\t}\n\tif len(chainCopy.context.AliasedPath) != 0 {\n\t\tlast := len(chainCopy.context.AliasedPath) - 1\n\t\tchainCopy.context.AliasedPath[last] = fmt.Sprintf(name, args...)\n\t}\n\n\treturn chainCopy\n}\n\n// Finalize assertion.\n// Report success of failure to AssertionHandler.\n// In case of failure, also recursively notify parents and grandparents\n// that they have faield children.\n// Must be called after enter().\n// Chain can't be used after this call.\nfunc (c *chain) leave() {\n\tvar (\n\t\tparent  *chain\n\t\tflags   chainFlags\n\t\tcontext AssertionContext\n\t\thandler AssertionHandler\n\t\tfailure *AssertionFailure\n\t)\n\tfunc() {\n\t\tc.mu.Lock()\n\t\tdefer c.mu.Unlock()\n\n\t\tif chainValidation && c.state != stateEntered {\n\t\t\tpanic(\"unpaired enter/leave\")\n\t\t}\n\t\tc.state = stateLeaved\n\n\t\tparent = c.parent\n\t\tflags = c.flags\n\n\t\tcontext = c.context\n\t\thandler = c.handler\n\t\tfailure = c.failure\n\n\t}()\n\n\tif flags&(flagFailed|flagFailedChildren) == 0 {\n\t\thandler.Success(&context)\n\t}\n\n\tif flags&(flagFailed) != 0 && failure != nil {\n\t\thandler.Failure(&context, failure)\n\n\t\tif chainValidation {\n\t\t\tif err := validateAssertion(failure); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif flags&(flagFailed|flagFailedChildren) != 0 && parent != nil {\n\t\tparent.mu.Lock()\n\t\tparent.flags |= flagFailed\n\t\tp := parent.parent\n\t\tparent.mu.Unlock()\n\n\t\tfor p != nil {\n\t\t\tp.mu.Lock()\n\t\t\tp.flags |= flagFailedChildren\n\t\t\tpp := p.parent\n\t\t\tp.mu.Unlock()\n\t\t\tp = pp\n\t\t}\n\t}\n}\n\n// Mark chain as failed.\n// Remember failure inside chain. It will be reported in leave().\n// Subsequent fail() call will be ignored.\n// Must be called between enter() and leave().\nfunc (c *chain) fail(failure AssertionFailure) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif chainValidation && c.state != stateEntered {\n\t\tpanic(\"fail allowed only between enter/leave\")\n\t}\n\n\tif c.flags&flagFailed != 0 {\n\t\treturn\n\t}\n\tc.flags |= flagFailed\n\n\tfailure.Severity = c.severity\n\tif c.severity == SeverityError {\n\t\tfailure.IsFatal = true\n\t}\n\n\tfailure.Stacktrace = stacktrace()\n\n\tc.failure = &failure\n}\n\n// Check if chain failed.\nfunc (c *chain) failed() bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.flags&flagFailed != 0\n}\n\n// Check if chain or any of its children failed.\nfunc (c *chain) treeFailed() bool {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\treturn c.flags&(flagFailed|flagFailedChildren) != 0\n}\n\n// Report failure unless chain has specified state.\n// For tests.\nfunc (c *chain) assert(t testing.TB, result chainResult) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tswitch result {\n\tcase success:\n\t\tassert.Equal(t, chainFlags(0), c.flags&flagFailed,\n\t\t\t\"expected: chain is in success state\")\n\n\tcase failure:\n\t\tassert.NotEqual(t, chainFlags(0), c.flags&flagFailed,\n\t\t\t\"expected: chain is in failure state\")\n\t}\n}\n\n// Report failure unless chain has specified flags.\n// For tests.\nfunc (c *chain) assertFlags(t testing.TB, flags chainFlags) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tassert.Equal(t, flags, c.flags,\n\t\t\"expected: chain has specified flags\")\n}\n\n// Clear failure flags.\n// For tests.\nfunc (c *chain) clear() {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tc.flags &= ^(flagFailed | flagFailedChildren)\n}\n\n// Whether handler outputs to testing.TB\nfunc isTestingTB(in AssertionHandler) bool {\n\th, ok := in.(*DefaultAssertionHandler)\n\tif !ok {\n\t\treturn false\n\t}\n\tswitch h.Reporter.(type) {\n\tcase *AssertReporter, *RequireReporter, *FatalReporter, testing.TB:\n\t\treturn true\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "chain_test.go",
          "type": "blob",
          "size": 20.9091796875,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc testFailure() AssertionFailure {\n\treturn AssertionFailure{\n\t\tType: AssertOperation,\n\t\tErrors: []error{\n\t\t\terrors.New(\"test_error\"),\n\t\t},\n\t}\n}\n\nfunc TestChain_Reentrancy(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tassertionHandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"root\", Config{\n\t\t\tAssertionHandler: assertionHandler,\n\t\t}.withDefaults())\n\n\t\tchain2 := chain.enter(\"test\")\n\t\tassertionHandler.assertionCb = func() {\n\t\t\t// will hang if chain calls assertion handler under a lock\n\t\t\tchain2.env()\n\t\t}\n\n\t\tchain2.leave()\n\n\t\tassert.False(t, chain2.failed())\n\t\tassert.Equal(t, 1, assertionHandler.successCalled)\n\t\tassert.Equal(t, 0, assertionHandler.failureCalled)\n\t})\n\n\tt.Run(\"failure\", func(t *testing.T) {\n\t\tassertionHandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"root\", Config{\n\t\t\tAssertionHandler: assertionHandler,\n\t\t}.withDefaults())\n\n\t\tchain2 := chain.enter(\"test\")\n\t\tassertionHandler.assertionCb = func() {\n\t\t\t// will hang if chain calls assertion handler under a lock\n\t\t\tchain2.env()\n\t\t}\n\n\t\tchain2.fail(testFailure())\n\t\tchain2.leave()\n\n\t\tassert.True(t, chain2.failed())\n\t\tassert.Equal(t, 1, assertionHandler.failureCalled)\n\t\tassert.Equal(t, 0, assertionHandler.successCalled)\n\t})\n}\n\nfunc TestChain_Basic(t *testing.T) {\n\tt.Run(\"clone\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.clone()\n\n\t\tassert.NotSame(t, chain1, chain2)\n\t\tassert.NotSame(t, chain1.context.Path, chain2.context.Path)\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\t})\n\n\tt.Run(\"enter leave\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.enter(\"test\")\n\n\t\tassert.NotSame(t, chain1, chain2)\n\t\tassert.NotSame(t, chain1.context.Path, chain2.context.Path)\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\n\t\tchain2.leave()\n\t})\n\n\tt.Run(\"enter leave fail\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.enter(\"test\")\n\n\t\tchain2.fail(testFailure())\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.True(t, chain2.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.True(t, chain2.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, flagFailed)\n\n\t\tchain2.leave() // propagates failure to parents\n\n\t\tassert.True(t, chain1.failed())\n\t\tassert.True(t, chain2.failed())\n\n\t\tassert.True(t, chain1.treeFailed())\n\t\tassert.True(t, chain2.treeFailed())\n\n\t\tchain1.assertFlags(t, flagFailed)\n\t\tchain2.assertFlags(t, flagFailed)\n\t})\n\n\tt.Run(\"clone enter leave fail\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.clone()\n\t\tchain3 := chain2.clone()\n\t\tchain3e := chain3.enter(\"test\")\n\n\t\tchain3e.fail(testFailure())\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.False(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\t\tassert.False(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, 0)\n\t\tchain3.assertFlags(t, 0)\n\t\tchain3e.assertFlags(t, flagFailed)\n\n\t\tchain3e.leave() // propagates failure to parents\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.True(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.True(t, chain1.treeFailed())\n\t\tassert.True(t, chain2.treeFailed())\n\t\tassert.True(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, flagFailedChildren)\n\t\tchain2.assertFlags(t, flagFailedChildren)\n\t\tchain3.assertFlags(t, flagFailed)\n\t\tchain3e.assertFlags(t, flagFailed)\n\t})\n\n\tt.Run(\"two branches\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.clone()\n\t\tchain2e := chain2.enter(\"test\")\n\t\tchain3 := chain2.clone()\n\t\tchain3e := chain3.enter(\"test\")\n\n\t\tchain2e.fail(testFailure())\n\t\tchain3e.fail(testFailure())\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.True(t, chain2e.failed())\n\t\tassert.False(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\t\tassert.True(t, chain2e.treeFailed())\n\t\tassert.False(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, 0)\n\t\tchain2e.assertFlags(t, flagFailed)\n\t\tchain3.assertFlags(t, 0)\n\t\tchain3e.assertFlags(t, flagFailed)\n\n\t\tchain2e.leave() // propagates failure to parents\n\t\tchain3e.leave() // propagates failure to parents\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.True(t, chain2.failed())\n\t\tassert.True(t, chain2e.failed())\n\t\tassert.True(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.True(t, chain1.treeFailed())\n\t\tassert.True(t, chain2.treeFailed())\n\t\tassert.True(t, chain2e.treeFailed())\n\t\tassert.True(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, flagFailedChildren)\n\t\tchain2.assertFlags(t, flagFailed|flagFailedChildren)\n\t\tchain2e.assertFlags(t, flagFailed)\n\t\tchain3.assertFlags(t, flagFailed)\n\t\tchain3e.assertFlags(t, flagFailed)\n\t})\n\n\tt.Run(\"set root 1\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.clone()\n\t\tchain2.setRoot()\n\t\tchain3 := chain2.clone()\n\t\tchain3e := chain3.enter(\"test\")\n\n\t\tchain3e.fail(testFailure())\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.False(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\t\tassert.False(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, 0)\n\t\tchain3.assertFlags(t, 0)\n\t\tchain3e.assertFlags(t, flagFailed)\n\n\t\tchain3e.leave() // propagates failure to parents\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.True(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.True(t, chain2.treeFailed())\n\t\tassert.True(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, flagFailedChildren)\n\t\tchain3.assertFlags(t, flagFailed)\n\t\tchain3e.assertFlags(t, flagFailed)\n\t})\n\n\tt.Run(\"set root 2\", func(t *testing.T) {\n\t\tchain1 := newMockChain(t)\n\t\tchain2 := chain1.clone()\n\t\tchain3 := chain2.clone()\n\t\tchain3.setRoot()\n\t\tchain3e := chain3.enter(\"test\")\n\n\t\tchain3e.fail(testFailure())\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.False(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\t\tassert.False(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, 0)\n\t\tchain3.assertFlags(t, 0)\n\t\tchain3e.assertFlags(t, flagFailed)\n\n\t\tchain3e.leave() // propagates failure to parents\n\n\t\tassert.False(t, chain1.failed())\n\t\tassert.False(t, chain2.failed())\n\t\tassert.True(t, chain3.failed())\n\t\tassert.True(t, chain3e.failed())\n\n\t\tassert.False(t, chain1.treeFailed())\n\t\tassert.False(t, chain2.treeFailed())\n\t\tassert.True(t, chain3.treeFailed())\n\t\tassert.True(t, chain3e.treeFailed())\n\n\t\tchain1.assertFlags(t, 0)\n\t\tchain2.assertFlags(t, 0)\n\t\tchain3.assertFlags(t, flagFailed)\n\t\tchain3e.assertFlags(t, flagFailed)\n\t})\n}\n\nfunc TestChain_Panics(t *testing.T) {\n\tt.Run(\"nil reporter\", func(t *testing.T) {\n\t\tassert.Panics(t, func() {\n\t\t\t_ = newChainWithDefaults(\"test\", nil)\n\t\t})\n\t})\n\n\tt.Run(\"set request twice\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.setRequest(&Request{})\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.setRequest(&Request{})\n\t\t})\n\t})\n\n\tt.Run(\"set response twice\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.setResponse(&Response{})\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.setResponse(&Response{})\n\t\t})\n\t})\n\n\tt.Run(\"leave without enter\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\tassert.Panics(t, func() {\n\t\t\tchain.leave()\n\t\t})\n\t})\n\n\tt.Run(\"leave on parent\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\t_ = chain.enter(\"foo\")\n\n\t\tassert.Panics(t, func() {\n\t\t\tchain.leave()\n\t\t})\n\t})\n\n\tt.Run(\"double leave\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.leave()\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.leave()\n\t\t})\n\t})\n\n\tt.Run(\"enter after leave\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.leave()\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.enter(\"bar\")\n\t\t})\n\t})\n\n\tt.Run(\"replace without enter\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\tassert.Panics(t, func() {\n\t\t\tchain.replace(\"foo\")\n\t\t})\n\t})\n\n\tt.Run(\"replace after leave\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.leave()\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.replace(\"bar\")\n\t\t})\n\t})\n\n\tt.Run(\"replace empty path\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"\")\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.replace(\"bar\")\n\t\t})\n\t})\n\n\tt.Run(\"replace empty aliased path\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.setAlias(\"\")\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.replace(\"bar\")\n\t\t})\n\t})\n\n\tt.Run(\"fail without enter\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\tassert.Panics(t, func() {\n\t\t\tchain.fail(testFailure())\n\t\t})\n\t})\n\n\tt.Run(\"fail after leave\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.leave()\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.fail(testFailure())\n\t\t})\n\t})\n\n\tt.Run(\"clone after leave\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.leave()\n\n\t\tassert.Panics(t, func() {\n\t\t\t_ = opChain.clone()\n\t\t})\n\t})\n\n\tt.Run(\"alias after leave\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\t\topChain.leave()\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.setAlias(\"bar\")\n\t\t})\n\t})\n\n\tt.Run(\"setters after leave\", func(t *testing.T) {\n\t\tsetterFuncs := []func(chain *chain){\n\t\t\tfunc(chain *chain) {\n\t\t\t\tchain.setRoot()\n\t\t\t},\n\t\t\tfunc(chain *chain) {\n\t\t\t\tchain.setSeverity(SeverityLog)\n\t\t\t},\n\t\t\tfunc(chain *chain) {\n\t\t\t\tchain.setRequestName(\"\")\n\t\t\t},\n\t\t\tfunc(chain *chain) {\n\t\t\t\tchain.setRequest(&Request{})\n\t\t\t},\n\t\t\tfunc(chain *chain) {\n\t\t\t\tchain.setResponse(&Response{})\n\t\t\t},\n\t\t}\n\n\t\tfor _, setter := range setterFuncs {\n\t\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\t\topChain := chain.enter(\"foo\")\n\t\t\topChain.leave()\n\n\t\t\tassert.Panics(t, func() {\n\t\t\t\tsetter(opChain)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid assertion\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"test\", newMockReporter(t))\n\n\t\topChain := chain.enter(\"foo\")\n\n\t\tassert.Panics(t, func() {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertionType(9999),\n\t\t\t})\n\t\t\topChain.leave()\n\t\t})\n\t})\n}\n\nfunc TestChain_Env(t *testing.T) {\n\tt.Run(\"newChainWithConfig, non-nil env\", func(t *testing.T) {\n\t\tenv := NewEnvironment(newMockReporter(t))\n\n\t\tchain := newChainWithConfig(\"root\", Config{\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t\tEnvironment:      env,\n\t\t}.withDefaults())\n\n\t\tassert.Same(t, env, chain.env())\n\t})\n\n\tt.Run(\"newChainWithConfig, nil env\", func(t *testing.T) {\n\t\tchain := newChainWithConfig(\"root\", Config{\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t\tEnvironment:      nil,\n\t\t}.withDefaults())\n\n\t\tassert.NotNil(t, chain.env())\n\t})\n\n\tt.Run(\"newChainWithDefaults\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"root\", newMockReporter(t))\n\n\t\tassert.NotNil(t, chain.env())\n\t})\n}\n\nfunc TestChain_Root(t *testing.T) {\n\tt.Run(\"newChainWithConfig, non-empty path\", func(t *testing.T) {\n\t\tchain := newChainWithConfig(\"root\", Config{\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t}.withDefaults())\n\n\t\tassert.Equal(t, []string{\"root\"}, chain.context.Path)\n\t})\n\n\tt.Run(\"newChainWithConfig, empty path\", func(t *testing.T) {\n\t\tchain := newChainWithConfig(\"\", Config{\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t}.withDefaults())\n\n\t\tassert.Equal(t, []string{}, chain.context.Path)\n\t})\n\n\tt.Run(\"newChainWithDefaults, non-empty path\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"root\", newMockReporter(t))\n\n\t\tassert.Equal(t, []string{\"root\"}, chain.context.Path)\n\t})\n\n\tt.Run(\"newChainWithDefaults, empty path\", func(t *testing.T) {\n\t\tchain := newChainWithDefaults(\"\", newMockReporter(t))\n\n\t\tassert.Equal(t, []string{}, chain.context.Path)\n\t})\n}\n\nfunc TestChain_Path(t *testing.T) {\n\tpath := func(c *chain) string {\n\t\treturn strings.Join(c.context.Path, \".\")\n\t}\n\n\trootChain := newChainWithDefaults(\"root\", newMockReporter(t))\n\n\tassert.Equal(t, \"root\", path(rootChain))\n\n\topChain1 := rootChain.enter(\"foo\")\n\n\tassert.Equal(t, \"root\", path(rootChain))\n\tassert.Equal(t, \"root.foo\", path(opChain1))\n\n\topChain2 := opChain1.enter(\"bar\")\n\n\tassert.Equal(t, \"root\", path(rootChain))\n\tassert.Equal(t, \"root.foo\", path(opChain1))\n\tassert.Equal(t, \"root.foo.bar\", path(opChain2))\n\n\topChain2Clone := opChain2.clone()\n\topChain3 := opChain2Clone.enter(\"baz\")\n\n\tassert.Equal(t, \"root\", path(rootChain))\n\tassert.Equal(t, \"root.foo\", path(opChain1))\n\tassert.Equal(t, \"root.foo.bar\", path(opChain2))\n\tassert.Equal(t, \"root.foo.bar\", path(opChain2Clone))\n\tassert.Equal(t, \"root.foo.bar.baz\", path(opChain3))\n\n\topChain1r := opChain1.replace(\"xxx\")\n\topChain3r := opChain3.replace(\"yyy\")\n\n\tassert.Equal(t, \"root\", path(rootChain))\n\tassert.Equal(t, \"root.foo\", path(opChain1))\n\tassert.Equal(t, \"root.foo.bar\", path(opChain2))\n\tassert.Equal(t, \"root.foo.bar\", path(opChain2Clone))\n\tassert.Equal(t, \"root.foo.bar.baz\", path(opChain3))\n\tassert.Equal(t, \"root.xxx\", path(opChain1r))\n\tassert.Equal(t, \"root.foo.bar.yyy\", path(opChain3r))\n}\n\nfunc TestChain_AliasedPath(t *testing.T) {\n\tpath := func(c *chain) string {\n\t\treturn strings.Join(c.context.Path, \".\")\n\t}\n\taliasedPath := func(c *chain) string {\n\t\treturn strings.Join(c.context.AliasedPath, \".\")\n\t}\n\n\tt.Run(\"enter and leave\", func(t *testing.T) {\n\t\trootChain := newChainWithDefaults(\"root\", newMockReporter(t))\n\n\t\tassert.Equal(t, \"root\", path(rootChain))\n\t\tassert.Equal(t, \"root\", aliasedPath(rootChain))\n\n\t\tc1 := rootChain.enter(\"foo\")\n\t\tassert.Equal(t, \"root.foo\", path(c1))\n\t\tassert.Equal(t, \"root.foo\", aliasedPath(c1))\n\n\t\tc2 := c1.enter(\"bar\")\n\t\tassert.Equal(t, \"root.foo.bar\", path(c2))\n\t\tassert.Equal(t, \"root.foo.bar\", aliasedPath(c2))\n\n\t\tc2.setAlias(\"alias1\")\n\t\tassert.Equal(t, \"root.foo.bar\", path(c2))\n\t\tassert.Equal(t, \"alias1\", aliasedPath(c2))\n\n\t\tc3 := c2.enter(\"baz\")\n\t\tassert.Equal(t, \"root.foo.bar.baz\", path(c3))\n\t\tassert.Equal(t, \"alias1.baz\", aliasedPath(c3))\n\n\t\tc3.leave()\n\t\tassert.Equal(t, \"root.foo.bar.baz\", path(c3))\n\t\tassert.Equal(t, \"alias1.baz\", aliasedPath(c3))\n\t})\n\n\tt.Run(\"set empty\", func(t *testing.T) {\n\t\trootChain := newChainWithDefaults(\"root\", newMockReporter(t))\n\n\t\tassert.Equal(t, \"root\", path(rootChain))\n\t\tassert.Equal(t, \"root\", aliasedPath(rootChain))\n\n\t\trootChain.setAlias(\"\")\n\t\tassert.Equal(t, \"root\", path(rootChain))\n\t\tassert.Equal(t, \"\", aliasedPath(rootChain))\n\t})\n}\n\nfunc TestChain_Handler(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\thandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"test\", Config{\n\t\t\tAssertionHandler: handler,\n\t\t}.withDefaults())\n\n\t\topChain := chain.enter(\"test\")\n\t\topChain.leave()\n\n\t\tassert.NotNil(t, handler.ctx)\n\t\tassert.Nil(t, handler.failure)\n\t})\n\n\tt.Run(\"failure\", func(t *testing.T) {\n\t\thandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"test\", Config{\n\t\t\tAssertionHandler: handler,\n\t\t}.withDefaults())\n\n\t\topChain := chain.enter(\"test\")\n\t\topChain.fail(testFailure())\n\t\topChain.leave()\n\n\t\tassert.NotNil(t, handler.ctx)\n\t\tassert.NotNil(t, handler.failure)\n\t})\n}\n\nfunc TestChain_Severity(t *testing.T) {\n\tt.Run(\"default\", func(t *testing.T) {\n\t\thandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"test\", Config{\n\t\t\tAssertionHandler: handler,\n\t\t}.withDefaults())\n\n\t\topChain := chain.enter(\"test\")\n\t\topChain.fail(testFailure())\n\t\topChain.leave()\n\n\t\tassert.NotNil(t, handler.failure)\n\t\tassert.Equal(t, SeverityError, handler.failure.Severity)\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\thandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"test\", Config{\n\t\t\tAssertionHandler: handler,\n\t\t}.withDefaults())\n\n\t\tchain.setSeverity(SeverityError)\n\n\t\topChain := chain.enter(\"test\")\n\t\topChain.fail(testFailure())\n\t\topChain.leave()\n\n\t\tassert.NotNil(t, handler.failure)\n\t\tassert.Equal(t, SeverityError, handler.failure.Severity)\n\t})\n\n\tt.Run(\"log\", func(t *testing.T) {\n\t\thandler := &mockAssertionHandler{}\n\n\t\tchain := newChainWithConfig(\"test\", Config{\n\t\t\tAssertionHandler: handler,\n\t\t}.withDefaults())\n\n\t\tchain.setSeverity(SeverityLog)\n\n\t\topChain := chain.enter(\"test\")\n\t\topChain.fail(testFailure())\n\t\topChain.leave()\n\n\t\tassert.NotNil(t, handler.failure)\n\t\tassert.Equal(t, SeverityLog, handler.failure.Severity)\n\t})\n}\n\nfunc TestChain_Stacktrace(t *testing.T) {\n\thandler := &mockAssertionHandler{}\n\n\tchain := newChainWithConfig(\"test\", Config{\n\t\tAssertionHandler: handler,\n\t}.withDefaults())\n\n\topChain := chain.enter(\"test\")\n\topChain.fail(testFailure())\n\topChain.leave()\n\n\tassert.True(t, opChain.failed())\n\tassert.NotNil(t, handler.failure)\n\n\tassert.GreaterOrEqual(t, len(handler.failure.Stacktrace), 2)\n\tassert.Contains(t, handler.failure.Stacktrace[0].FuncName, \"(*chain).fail\")\n\tassert.Contains(t, handler.failure.Stacktrace[1].FuncName, \"TestChain_Stacktrace\")\n}\n\nfunc TestChain_Reporting(t *testing.T) {\n\thandler := &mockAssertionHandler{}\n\n\tfailure := AssertionFailure{\n\t\tIsFatal: true,\n\t\tErrors: []error{\n\t\t\terrors.New(\"test_error\"),\n\t\t},\n\t}\n\n\tchain := newChainWithConfig(\"test\", Config{\n\t\tAssertionHandler: handler,\n\t}.withDefaults())\n\n\topChain := chain.enter(\"test\")\n\n\tassert.False(t, opChain.failed()) // no failure flag\n\tassert.False(t, chain.failed())   // not reported to parent\n\tassert.Nil(t, handler.ctx)        // not reported to handler\n\tassert.Nil(t, handler.failure)\n\n\topChain.fail(failure)\n\n\tassert.True(t, opChain.failed()) // has failure flag\n\tassert.False(t, chain.failed())  // not reported to parent\n\tassert.Nil(t, handler.ctx)       // not reported to handler\n\tassert.Nil(t, handler.failure)\n\n\topChain.leave()\n\n\tassert.True(t, opChain.failed()) // has failure flag\n\tassert.True(t, chain.failed())   // reported to parent\n\tassert.NotNil(t, handler.ctx)    // reported to handler\n\tassert.NotNil(t, handler.failure)\n\n\tfailure.Stacktrace = handler.failure.Stacktrace\n\tassert.Equal(t, failure, *handler.failure)\n}\n\nfunc TestChain_TestingTB(t *testing.T) {\n\ttype args struct {\n\t\thandler  AssertionHandler\n\t\treporter Reporter\n\t}\n\tcases := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"testing.T\",\n\t\t\targs: args{\n\t\t\t\thandler: &DefaultAssertionHandler{\n\t\t\t\t\tFormatter: newMockFormatter(t),\n\t\t\t\t\tReporter:  t,\n\t\t\t\t\tLogger:    newMockLogger(t),\n\t\t\t\t},\n\t\t\t\treporter: t,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"testing.B\",\n\t\t\targs: args{\n\t\t\t\thandler: &DefaultAssertionHandler{\n\t\t\t\t\tFormatter: newMockFormatter(t),\n\t\t\t\t\tReporter:  &testing.B{},\n\t\t\t\t\tLogger:    newMockLogger(t),\n\t\t\t\t},\n\t\t\t\treporter: &testing.B{},\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"testing.TB\",\n\t\t\targs: args{\n\t\t\t\thandler: &DefaultAssertionHandler{\n\t\t\t\t\tFormatter: newMockFormatter(t),\n\t\t\t\t\tReporter:  testing.TB(t),\n\t\t\t\t\tLogger:    newMockLogger(t),\n\t\t\t\t},\n\t\t\t\treporter: testing.TB(t),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"AssertReporter\",\n\t\t\targs: args{\n\t\t\t\thandler: &DefaultAssertionHandler{\n\t\t\t\t\tFormatter: newMockFormatter(t),\n\t\t\t\t\tReporter:  NewFatalReporter(t),\n\t\t\t\t\tLogger:    newMockLogger(t),\n\t\t\t\t},\n\t\t\t\treporter: NewFatalReporter(t),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"AssertReporter\",\n\t\t\targs: args{\n\t\t\t\thandler: &DefaultAssertionHandler{\n\t\t\t\t\tFormatter: newMockFormatter(t),\n\t\t\t\t\tReporter:  NewAssertReporter(t),\n\t\t\t\t\tLogger:    newMockLogger(t),\n\t\t\t\t},\n\t\t\t\treporter: NewAssertReporter(t),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"RequireReporter\",\n\t\t\targs: args{\n\t\t\t\thandler: &DefaultAssertionHandler{\n\t\t\t\t\tFormatter: newMockFormatter(t),\n\t\t\t\t\tReporter:  NewRequireReporter(t),\n\t\t\t\t\tLogger:    newMockLogger(t),\n\t\t\t\t},\n\t\t\t\treporter: NewRequireReporter(t),\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"mockHandler, mockReporter\",\n\t\t\targs: args{\n\t\t\t\thandler:  &mockAssertionHandler{},\n\t\t\t\treporter: newMockReporter(t),\n\t\t\t},\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchain := newChainWithConfig(tc.name, Config{\n\t\t\t\tAssertionHandler: tc.args.handler,\n\t\t\t}.withDefaults())\n\t\t\tassert.Equal(t, tc.want, chain.context.TestingTB)\n\n\t\t\tchain = newChainWithDefaults(tc.name, tc.args.reporter)\n\t\t\tassert.Equal(t, tc.want, chain.context.TestingTB)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cookie.go",
          "type": "blob",
          "size": 6.3251953125,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// Cookie provides methods to inspect attached http.Cookie value.\ntype Cookie struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  *http.Cookie\n}\n\n// NewCookie returns a new Cookie instance.\n//\n// If reporter is nil, the function panics.\n// If value is nil, failure is reported.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\n//\tcookie.Domain().IsEqual(\"example.com\")\n//\tcookie.Path().IsEqual(\"/\")\n//\tcookie.Expires().InRange(time.Now(), time.Now().Add(time.Hour * 24))\nfunc NewCookie(reporter Reporter, value *http.Cookie) *Cookie {\n\treturn newCookie(newChainWithDefaults(\"Cookie()\", reporter), value)\n}\n\n// NewCookieC returns a new Cookie instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// If value is nil, failure is reported.\n//\n// See NewCookie for usage example.\nfunc NewCookieC(config Config, value *http.Cookie) *Cookie {\n\treturn newCookie(newChainWithConfig(\"Cookie()\", config.withDefaults()), value)\n}\n\nfunc newCookie(parent *chain, val *http.Cookie) *Cookie {\n\tc := &Cookie{chain: parent.clone(), value: nil}\n\n\topChain := c.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\tif val == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{val},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-nil cookie\"),\n\t\t\t},\n\t\t})\n\t} else {\n\t\tc.value = val\n\t}\n\n\treturn c\n}\n\n// Raw returns underlying http.Cookie value attached to Cookie.\n// This is the value originally passed to NewCookie.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, c)\n//\tassert.Equal(t, c, cookie.Raw())\nfunc (c *Cookie) Raw() *http.Cookie {\n\treturn c.value\n}\n\n// Alias is similar to Value.Alias.\nfunc (c *Cookie) Alias(name string) *Cookie {\n\topChain := c.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tc.chain.setAlias(name)\n\treturn c\n}\n\n// Name returns a new String instance with cookie name.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.Name().IsEqual(\"session\")\nfunc (c *Cookie) Name() *String {\n\topChain := c.chain.enter(\"Name()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, c.value.Name)\n}\n\n// Value returns a new String instance with cookie value.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.Value().IsEqual(\"gH6z7Y\")\nfunc (c *Cookie) Value() *String {\n\topChain := c.chain.enter(\"Value()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, c.value.Value)\n}\n\n// Domain returns a new String instance with cookie domain.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.Domain().IsEqual(\"example.com\")\nfunc (c *Cookie) Domain() *String {\n\topChain := c.chain.enter(\"Domain()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, c.value.Domain)\n}\n\n// Path returns a new String instance with cookie path.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.Path().IsEqual(\"/foo\")\nfunc (c *Cookie) Path() *String {\n\topChain := c.chain.enter(\"Path()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, c.value.Path)\n}\n\n// Expires returns a new DateTime instance with cookie expiration date.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.Expires().InRange(time.Now(), time.Now().Add(time.Hour * 24))\nfunc (c *Cookie) Expires() *DateTime {\n\topChain := c.chain.enter(\"Expires()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newDateTime(opChain, time.Unix(0, 0))\n\t}\n\n\treturn newDateTime(opChain, c.value.Expires)\n}\n\n// ContainsMaxAge succeeds if cookie has Max-Age field.\n//\n// In particular, if Max-Age is present and is zero (which means delete\n// cookie now), method succeeds.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.ContainsMaxAge()\nfunc (c *Cookie) ContainsMaxAge() *Cookie {\n\topChain := c.chain.enter(\"ContainsMaxAge()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn c\n\t}\n\n\tif c.value.MaxAge == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{c.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: cookie has Max-Age field\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn c\n}\n\n// NotContainsMaxAge succeeds if cookie does not have Max-Age field.\n//\n// In particular, if Max-Age is present and is zero (which means delete\n// cookie now), method fails.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.NotContainsMaxAge()\nfunc (c *Cookie) NotContainsMaxAge() *Cookie {\n\topChain := c.chain.enter(\"NotContainsMaxAge()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn c\n\t}\n\n\tif c.value.MaxAge != 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotValid,\n\t\t\tActual: &AssertionValue{c.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: cookie does not have Max-Age field\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn c\n}\n\n// Deprecated: use ContainsMaxAge instead.\nfunc (c *Cookie) HasMaxAge() *Cookie {\n\treturn c.ContainsMaxAge()\n}\n\n// Deprecated: use NotContainsMaxAge instead.\nfunc (c *Cookie) NotHasMaxAge() *Cookie {\n\treturn c.NotContainsMaxAge()\n}\n\n// Deprecated: use ContainsMaxAge instead.\nfunc (c *Cookie) HaveMaxAge() *Cookie {\n\treturn c.ContainsMaxAge()\n}\n\n// Deprecated: use NotContainsMaxAge instead.\nfunc (c *Cookie) NotHaveMaxAge() *Cookie {\n\treturn c.NotContainsMaxAge()\n}\n\n// MaxAge returns a new Duration instance with cookie Max-Age field.\n//\n// If Max-Age is not present, method fails.\n//\n// If Max-Age is present and is zero (which means delete cookie now),\n// methods succeeds and the returned Duration is equal to zero.\n//\n// Example:\n//\n//\tcookie := NewCookie(t, &http.Cookie{...})\n//\tcookie.ContainsMaxAge()\n//\tcookie.MaxAge().InRange(time.Minute, time.Minute*10)\nfunc (c *Cookie) MaxAge() *Duration {\n\topChain := c.chain.enter(\"MaxAge()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newDuration(opChain, nil)\n\t}\n\n\tswitch {\n\tcase c.value.MaxAge == 0: // zero value means not present\n\t\t// TODO: after removing Duration.IsSet, add failure here (breaking change)\n\t\t_ = (*Duration).IsSet\n\t\treturn newDuration(opChain, nil)\n\n\tcase c.value.MaxAge < 0: // negative value means present and zero\n\t\tage := time.Duration(0)\n\t\treturn newDuration(opChain, &age)\n\n\tdefault:\n\t\tage := time.Duration(c.value.MaxAge) * time.Second\n\t\treturn newDuration(opChain, &age)\n\t}\n}\n"
        },
        {
          "name": "cookie_jar.go",
          "type": "blob",
          "size": 0.59765625,
          "content": "package httpexpect\n\nimport (\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\n\t\"golang.org/x/net/publicsuffix\"\n)\n\n// NewCookieJar returns a new http.CookieJar.\n//\n// Returned jar is implemented in net/http/cookiejar. PublicSuffixList is\n// implemented in golang.org/x/net/publicsuffix.\n//\n// Note that this jar ignores cookies when request url is empty.\nfunc NewCookieJar() http.CookieJar {\n\tjar, err := cookiejar.New(&cookiejar.Options{\n\t\tPublicSuffixList: publicsuffix.List,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn jar\n}\n\n// Deprecated: use NewCookieJar instead.\nfunc NewJar() http.CookieJar {\n\treturn NewCookieJar()\n}\n"
        },
        {
          "name": "cookie_test.go",
          "type": "blob",
          "size": 5.0478515625,
          "content": "package httpexpect\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCookie_FailedChain(t *testing.T) {\n\tcheck := func(value *Cookie, isNil bool) {\n\t\tvalue.chain.assert(t, failure)\n\n\t\tif isNil {\n\t\t\tassert.Nil(t, value.Raw())\n\t\t} else {\n\t\t\tassert.NotNil(t, value.Raw())\n\t\t}\n\n\t\tvalue.Alias(\"foo\")\n\n\t\tvalue.Name().chain.assert(t, failure)\n\t\tvalue.Value().chain.assert(t, failure)\n\t\tvalue.Domain().chain.assert(t, failure)\n\t\tvalue.Path().chain.assert(t, failure)\n\t\tvalue.Expires().chain.assert(t, failure)\n\t\tvalue.MaxAge().chain.assert(t, failure)\n\n\t\tvalue.ContainsMaxAge()\n\t\tvalue.NotContainsMaxAge()\n\t}\n\n\tt.Run(\"failed chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t, flagFailed)\n\t\tvalue := newCookie(chain, &http.Cookie{})\n\n\t\tcheck(value, false)\n\t})\n\n\tt.Run(\"nil value\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newCookie(chain, nil)\n\n\t\tcheck(value, true)\n\t})\n\n\tt.Run(\"failed chain, nil value\", func(t *testing.T) {\n\t\tchain := newMockChain(t, flagFailed)\n\t\tvalue := newCookie(chain, nil)\n\n\t\tcheck(value, true)\n\t})\n}\n\nfunc TestCookie_Constructors(t *testing.T) {\n\tcookie := &http.Cookie{\n\t\tName:    \"Test\",\n\t\tValue:   \"Test_val\",\n\t\tDomain:  \"example.com\",\n\t\tPath:    \"/path\",\n\t\tExpires: time.Unix(1234, 0),\n\t\tMaxAge:  123,\n\t}\n\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewCookie(reporter, cookie)\n\t\tvalue.Name().IsEqual(\"Test\")\n\t\tvalue.Value().IsEqual(\"Test_val\")\n\t\tvalue.Domain().IsEqual(\"example.com\")\n\t\tvalue.Expires().IsEqual(time.Unix(1234, 0))\n\t\tvalue.MaxAge().IsEqual(123 * time.Second)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewCookieC(Config{\n\t\t\tReporter: reporter,\n\t\t}, cookie)\n\t\tvalue.Name().IsEqual(\"Test\")\n\t\tvalue.Value().IsEqual(\"Test_val\")\n\t\tvalue.Domain().IsEqual(\"example.com\")\n\t\tvalue.Expires().IsEqual(time.Unix(1234, 0))\n\t\tvalue.MaxAge().IsEqual(123 * time.Second)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newCookie(chain, cookie)\n\t\tassert.NotSame(t, value.chain, &chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestCookie_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tdata := http.Cookie{}\n\n\tvalue := NewCookie(reporter, &data)\n\n\tassert.Same(t, &data, value.Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestCookie_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewCookie(reporter, &http.Cookie{\n\t\tMaxAge: 0,\n\t})\n\tassert.Equal(t, []string{\"Cookie()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Cookie()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Cookie()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.Domain()\n\tassert.Equal(t, []string{\"Cookie()\", \"Domain()\"}, childValue.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\", \"Domain()\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestCookie_Getters(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewCookie(reporter, &http.Cookie{\n\t\tName:    \"name\",\n\t\tValue:   \"value\",\n\t\tDomain:  \"example.com\",\n\t\tPath:    \"/path\",\n\t\tExpires: time.Unix(1234, 0),\n\t\tMaxAge:  123,\n\t})\n\n\tvalue.chain.assert(t, success)\n\n\tvalue.Name().chain.assert(t, success)\n\tvalue.Value().chain.assert(t, success)\n\tvalue.Domain().chain.assert(t, success)\n\tvalue.Path().chain.assert(t, success)\n\tvalue.Expires().chain.assert(t, success)\n\tvalue.MaxAge().chain.assert(t, success)\n\n\tassert.Equal(t, \"name\", value.Name().Raw())\n\tassert.Equal(t, \"value\", value.Value().Raw())\n\tassert.Equal(t, \"example.com\", value.Domain().Raw())\n\tassert.Equal(t, \"/path\", value.Path().Raw())\n\tassert.True(t, time.Unix(1234, 0).Equal(value.Expires().Raw()))\n\tassert.Equal(t, 123*time.Second, value.MaxAge().Raw())\n\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestCookie_MaxAge(t *testing.T) {\n\tcases := []struct {\n\t\tname               string\n\t\tmaxAge             int\n\t\twantContainsMaxAge chainResult\n\t\twantDuration       time.Duration\n\t}{\n\t\t{\n\t\t\tname:               \"unset\",\n\t\t\tmaxAge:             0,\n\t\t\twantContainsMaxAge: failure,\n\t\t},\n\t\t{\n\t\t\tname:               \"zero\",\n\t\t\tmaxAge:             -1,\n\t\t\twantContainsMaxAge: success,\n\t\t\twantDuration:       time.Duration(0),\n\t\t},\n\t\t{\n\t\t\tname:               \"non-zero\",\n\t\t\tmaxAge:             3,\n\t\t\twantContainsMaxAge: success,\n\t\t\twantDuration:       time.Duration(3) * time.Second,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tdata := &http.Cookie{\n\t\t\t\tMaxAge: tc.maxAge,\n\t\t\t}\n\n\t\t\tNewCookie(reporter, data).ContainsMaxAge().\n\t\t\t\tchain.assert(t, tc.wantContainsMaxAge)\n\n\t\t\tNewCookie(reporter, data).NotContainsMaxAge().\n\t\t\t\tchain.assert(t, !tc.wantContainsMaxAge)\n\n\t\t\tif tc.wantContainsMaxAge {\n\t\t\t\trequire.NotNil(t,\n\t\t\t\t\tNewCookie(reporter, data).MaxAge().value)\n\n\t\t\t\trequire.Equal(t, tc.wantDuration,\n\t\t\t\t\t*NewCookie(reporter, data).MaxAge().value)\n\t\t\t} else {\n\t\t\t\trequire.Nil(t,\n\t\t\t\t\tNewCookie(reporter, data).MaxAge().value)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "datetime.go",
          "type": "blob",
          "size": 14.8779296875,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\n// DateTime provides methods to inspect attached time.Time value.\ntype DateTime struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  time.Time\n}\n\n// NewDateTime returns a new DateTime instance.\n//\n// If reporter is nil, the function panics.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Now())\n//\tdt.Le(time.Now())\n//\n//\ttime.Sleep(time.Second)\n//\tdt.Lt(time.Now())\nfunc NewDateTime(reporter Reporter, value time.Time) *DateTime {\n\treturn newDateTime(newChainWithDefaults(\"DateTime()\", reporter), value)\n}\n\n// NewDateTimeC returns a new DateTime instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// See NewDateTime for usage example.\nfunc NewDateTimeC(config Config, value time.Time) *DateTime {\n\treturn newDateTime(newChainWithConfig(\"DateTime()\", config.withDefaults()), value)\n}\n\nfunc newDateTime(parent *chain, val time.Time) *DateTime {\n\treturn &DateTime{chain: parent.clone(), value: val}\n}\n\n// Raw returns underlying time.Time value attached to DateTime.\n// This is the value originally passed to NewDateTime.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, timestamp)\n//\tassert.Equal(t, timestamp, dt.Raw())\nfunc (dt *DateTime) Raw() time.Time {\n\treturn dt.value\n}\n\n// Alias is similar to Value.Alias.\nfunc (dt *DateTime) Alias(name string) *DateTime {\n\topChain := dt.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tdt.chain.setAlias(name)\n\treturn dt\n}\n\n// Zone returns a new String instance with datetime zone.\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Zone().IsEqual(\"IST\")\nfunc (dt *DateTime) Zone() *String {\n\topChain := dt.chain.enter(\"Zone()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tzone, _ := dt.value.Zone()\n\treturn newString(opChain, zone)\n}\n\n// Year returns the year in which datetime occurs,\n// in the range [0, 9999]\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Year().IsEqual(2022)\nfunc (dt *DateTime) Year() *Number {\n\topChain := dt.chain.enter(\"Year()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Year()))\n}\n\n// Month returns the month of the year specified by datetime,\n// in the range [1,12].\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Month().IsEqual(12)\nfunc (dt *DateTime) Month() *Number {\n\topChain := dt.chain.enter(\"Month()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Month()))\n}\n\n// Day returns the day of the month specified datetime,\n// in the range [1,31].\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Day().IsEqual(30)\nfunc (dt *DateTime) Day() *Number {\n\topChain := dt.chain.enter(\"Day()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Day()))\n}\n\n// Weekday returns the day of the week specified by datetime,\n// in the range [0, 6], 0 corresponds to Sunday\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.WeekDay().IsEqual(time.Friday)\nfunc (dt *DateTime) WeekDay() *Number {\n\topChain := dt.chain.enter(\"WeekDay()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Weekday()))\n}\n\n// YearDay returns the day of the year specified by datetime,\n// in the range [1,365] for non-leap years,\n// and [1,366] in leap years.\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.YearDay().IsEqual(364)\nfunc (dt *DateTime) YearDay() *Number {\n\topChain := dt.chain.enter(\"YearDay()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.YearDay()))\n}\n\n// Hour returns the hour within the day specified by datetime,\n// in the range [0, 23].\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Hour().IsEqual(15)\nfunc (dt *DateTime) Hour() *Number {\n\topChain := dt.chain.enter(\"Hour()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Hour()))\n}\n\n// Minute returns the minute offset within the hour specified by datetime,\n// in the range [0, 59].\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Minute().IsEqual(4)\nfunc (dt *DateTime) Minute() *Number {\n\topChain := dt.chain.enter(\"Minute()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Minute()))\n}\n\n// Second returns the second offset within the minute specified by datetime,\n// in the range [0, 59].\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Second().IsEqual(5)\nfunc (dt *DateTime) Second() *Number {\n\topChain := dt.chain.enter(\"Second()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Second()))\n}\n\n// Nanosecond returns the nanosecond offset within the second specified by datetime,\n// in the range [0, 999999999].\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.Nanosecond().IsEqual(0)\nfunc (dt *DateTime) Nanosecond() *Number {\n\topChain := dt.chain.enter(\"Nanosecond()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, float64(0))\n\t}\n\n\treturn newNumber(opChain, float64(dt.value.Nanosecond()))\n}\n\n// Deprecated: use Zone instead.\nfunc (dt *DateTime) GetZone() *String {\n\treturn dt.Zone()\n}\n\n// Deprecated: use Year instead.\nfunc (dt *DateTime) GetYear() *Number {\n\treturn dt.Year()\n}\n\n// Deprecated: use Month instead.\nfunc (dt *DateTime) GetMonth() *Number {\n\treturn dt.Month()\n}\n\n// Deprecated: use Day instead.\nfunc (dt *DateTime) GetDay() *Number {\n\treturn dt.Day()\n}\n\n// Deprecated: use WeekDay instead.\nfunc (dt *DateTime) GetWeekDay() *Number {\n\treturn dt.WeekDay()\n}\n\n// Deprecated: use YearDay instead.\nfunc (dt *DateTime) GetYearDay() *Number {\n\treturn dt.YearDay()\n}\n\n// Deprecated: use Hour instead.\nfunc (dt *DateTime) GetHour() *Number {\n\treturn dt.Hour()\n}\n\n// Deprecated: use Minute instead.\nfunc (dt *DateTime) GetMinute() *Number {\n\treturn dt.Minute()\n}\n\n// Deprecated: use Second instead.\nfunc (dt *DateTime) GetSecond() *Number {\n\treturn dt.Second()\n}\n\n// Deprecated: use Nanosecond instead.\nfunc (dt *DateTime) GetNanosecond() *Number {\n\treturn dt.Nanosecond()\n}\n\n// IsEqual succeeds if DateTime is equal to given value.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 1))\n//\tdt.IsEqual(time.Unix(0, 1))\nfunc (dt *DateTime) IsEqual(value time.Time) *DateTime {\n\topChain := dt.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif !dt.value.Equal(value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time points are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// NotEqual succeeds if DateTime is not equal to given value.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 1))\n//\tdt.NotEqual(time.Unix(0, 2))\nfunc (dt *DateTime) NotEqual(value time.Time) *DateTime {\n\topChain := dt.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif dt.value.Equal(value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time points are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// Deprecated: use IsEqual instead.\nfunc (dt *DateTime) Equal(value time.Time) *DateTime {\n\treturn dt.IsEqual(value)\n}\n\n// InRange succeeds if DateTime is within given range [min; max].\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 2))\n//\tdt.InRange(time.Unix(0, 1), time.Unix(0, 3))\n//\tdt.InRange(time.Unix(0, 2), time.Unix(0, 2))\nfunc (dt *DateTime) InRange(min, max time.Time) *DateTime {\n\topChain := dt.chain.enter(\"InRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif !((dt.value.After(min) || dt.value.Equal(min)) &&\n\t\t(dt.value.Before(max) || dt.value.Equal(max))) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertInRange,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{AssertionRange{min, max}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is within given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// NotInRange succeeds if DateTime is not within given range [min; max].\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 10))\n//\tdt.NotInRange(time.Unix(0, 1), time.Unix(0, 9))\n//\tdt.NotInRange(time.Unix(0, 11), time.Unix(0, 20))\nfunc (dt *DateTime) NotInRange(min, max time.Time) *DateTime {\n\topChain := dt.chain.enter(\"NotInRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif (dt.value.After(min) || dt.value.Equal(min)) &&\n\t\t(dt.value.Before(max) || dt.value.Equal(max)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotInRange,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{AssertionRange{min, max}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is not within given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// InList succeeds if DateTime is equal to one of the values from given\n// list of time.Time.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 2))\n//\tdt.InRange(time.Unix(0, 1), time.Unix(0, 2))\nfunc (dt *DateTime) InList(values ...time.Time) *DateTime {\n\topChain := dt.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn dt\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\tif dt.value.Equal(v) {\n\t\t\tisListed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !isListed {\n\t\tvalueList := make([]interface{}, 0, len(values))\n\t\tfor _, v := range values {\n\t\t\tvalueList = append(valueList, v)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// NotInList succeeds if DateTime is not equal to any of the values from\n// given list of time.Time.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 2))\n//\tdt.InRange(time.Unix(0, 1), time.Unix(0, 3))\nfunc (dt *DateTime) NotInList(values ...time.Time) *DateTime {\n\topChain := dt.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn dt\n\t}\n\n\tfor _, v := range values {\n\t\tif dt.value.Equal(v) {\n\t\t\tvalueList := make([]interface{}, 0, len(values))\n\t\t\tfor _, v := range values {\n\t\t\t\tvalueList = append(valueList, v)\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: time point is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treturn dt\n\t\t}\n\t}\n\n\treturn dt\n}\n\n// Gt succeeds if DateTime is greater than given value.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 2))\n//\tdt.Gt(time.Unix(0, 1))\nfunc (dt *DateTime) Gt(value time.Time) *DateTime {\n\topChain := dt.chain.enter(\"Gt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif !dt.value.After(value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertGt,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is after given time\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// Ge succeeds if DateTime is greater than or equal to given value.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 2))\n//\tdt.Ge(time.Unix(0, 1))\nfunc (dt *DateTime) Ge(value time.Time) *DateTime {\n\topChain := dt.chain.enter(\"Ge()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif !(dt.value.After(value) || dt.value.Equal(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertGe,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is after or equal to given time\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// Lt succeeds if DateTime is lesser than given value.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 1))\n//\tdt.Lt(time.Unix(0, 2))\nfunc (dt *DateTime) Lt(value time.Time) *DateTime {\n\topChain := dt.chain.enter(\"Lt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif !dt.value.Before(value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertLt,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is before given time\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// Le succeeds if DateTime is lesser than or equal to given value.\n//\n// Example:\n//\n//\tdt := NewDateTime(t, time.Unix(0, 1))\n//\tdt.Le(time.Unix(0, 2))\nfunc (dt *DateTime) Le(value time.Time) *DateTime {\n\topChain := dt.chain.enter(\"Le()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn dt\n\t}\n\n\tif !(dt.value.Before(value) || dt.value.Equal(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertLe,\n\t\t\tActual:   &AssertionValue{dt.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time point is before or equal to given time\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn dt\n}\n\n// AsUTC returns a new DateTime instance in UTC timeZone.\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.AsUTC().Zone().IsEqual(\"UTC\")\nfunc (dt *DateTime) AsUTC() *DateTime {\n\topChain := dt.chain.enter(\"AsUTC()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newDateTime(opChain, time.Unix(0, 0))\n\t}\n\n\treturn newDateTime(opChain, dt.value.UTC())\n}\n\n// AsLocal returns a new DateTime instance in Local timeZone.\n//\n// Example:\n//\n//\ttm, _ := time.Parse(time.UnixDate, \"Fri Dec 30 15:04:05 IST 2022\")\n//\tdt := NewDateTime(t, tm)\n//\tdt.AsLocal().Zone().IsEqual(\"IST\")\nfunc (dt *DateTime) AsLocal() *DateTime {\n\topChain := dt.chain.enter(\"AsLocal()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newDateTime(opChain, time.Unix(0, 0))\n\t}\n\n\treturn newDateTime(opChain, dt.value.Local())\n}\n"
        },
        {
          "name": "datetime_test.go",
          "type": "blob",
          "size": 9.041015625,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDateTime_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\ttm := time.Unix(0, 0)\n\tvalue := newDateTime(chain, tm)\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Alias(\"foo\")\n\n\tvalue.IsEqual(tm)\n\tvalue.NotEqual(tm)\n\tvalue.InRange(tm, tm)\n\tvalue.NotInRange(tm, tm)\n\tvalue.InList(tm, tm)\n\tvalue.NotInList(tm, tm)\n\tvalue.Gt(tm)\n\tvalue.Ge(tm)\n\tvalue.Lt(tm)\n\tvalue.Le(tm)\n\n\tvalue.Zone().chain.assert(t, failure)\n\tvalue.Year().chain.assert(t, failure)\n\tvalue.Month().chain.assert(t, failure)\n\tvalue.Day().chain.assert(t, failure)\n\tvalue.WeekDay().chain.assert(t, failure)\n\tvalue.YearDay().chain.assert(t, failure)\n\tvalue.Hour().chain.assert(t, failure)\n\tvalue.Minute().chain.assert(t, failure)\n\tvalue.Second().chain.assert(t, failure)\n\tvalue.Nanosecond().chain.assert(t, failure)\n\n\tvalue.AsUTC().chain.assert(t, failure)\n\tvalue.AsLocal().chain.assert(t, failure)\n}\n\nfunc TestDateTime_Constructors(t *testing.T) {\n\ttime := time.Unix(0, 1234)\n\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewDateTime(reporter, time)\n\t\tvalue.IsEqual(time)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewDateTimeC(Config{\n\t\t\tReporter: reporter,\n\t\t}, time)\n\t\tvalue.IsEqual(time)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newDateTime(chain, time)\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestDateTime_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tdata := time.Unix(0, 1234)\n\n\tvalue := NewDateTime(reporter, data)\n\n\tassert.Equal(t, data, value.Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestDateTime_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewDateTime(reporter, time.Unix(0, 1234))\n\tassert.Equal(t, []string{\"DateTime()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"DateTime()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"DateTime()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestDateTime_Getters(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tparsedTime, _ := time.Parse(time.UnixDate, \"FRI Dec 30 15:04:05 IST 2022\")\n\n\tvalue := NewDateTime(reporter, parsedTime)\n\n\tvalue.chain.assert(t, success)\n\n\tvalue.Zone().chain.assert(t, success)\n\tvalue.Year().chain.assert(t, success)\n\tvalue.Month().chain.assert(t, success)\n\tvalue.Day().chain.assert(t, success)\n\tvalue.WeekDay().chain.assert(t, success)\n\tvalue.YearDay().chain.assert(t, success)\n\tvalue.Hour().chain.assert(t, success)\n\tvalue.Minute().chain.assert(t, success)\n\tvalue.Second().chain.assert(t, success)\n\tvalue.Nanosecond().chain.assert(t, success)\n\tvalue.AsUTC().chain.assert(t, success)\n\tvalue.AsLocal().chain.assert(t, success)\n\n\texpectedTime := parsedTime\n\texpectedZone, _ := expectedTime.Zone()\n\n\tassert.Equal(t, expectedZone, value.Zone().Raw())\n\tassert.Equal(t, float64(expectedTime.Year()), value.Year().Raw())\n\tassert.Equal(t, float64(expectedTime.Month()), value.Month().Raw())\n\tassert.Equal(t, float64(expectedTime.Day()), value.Day().Raw())\n\tassert.Equal(t, float64(expectedTime.Weekday()), value.WeekDay().Raw())\n\tassert.Equal(t, float64(expectedTime.YearDay()), value.YearDay().Raw())\n\tassert.Equal(t, float64(expectedTime.Hour()), value.Hour().Raw())\n\tassert.Equal(t, float64(expectedTime.Minute()), value.Minute().Raw())\n\tassert.Equal(t, float64(expectedTime.Second()), value.Second().Raw())\n\tassert.Equal(t, float64(expectedTime.Nanosecond()), value.Nanosecond().Raw())\n}\n\nfunc TestDateTime_IsEqual(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\ttime        time.Time\n\t\tvalue       time.Time\n\t\twantIsEqual chainResult\n\t}{\n\t\t{\n\t\t\tname:        \"equal to value\",\n\t\t\ttime:        time.Unix(0, 1234),\n\t\t\tvalue:       time.Unix(0, 1234),\n\t\t\twantIsEqual: success,\n\t\t},\n\t\t{\n\t\t\tname:        \"not equal to value\",\n\t\t\ttime:        time.Unix(0, 1234),\n\t\t\tvalue:       time.Unix(0, 4321),\n\t\t\twantIsEqual: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDateTime(reporter, tc.time).IsEqual(tc.value).\n\t\t\t\tchain.assert(t, tc.wantIsEqual)\n\n\t\t\tNewDateTime(reporter, tc.time).NotEqual(tc.value).\n\t\t\t\tchain.assert(t, !tc.wantIsEqual)\n\t\t})\n\t}\n}\n\nfunc TestDateTime_IsGreater(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\ttime   time.Time\n\t\tvalue  time.Time\n\t\twantGt chainResult\n\t\twantGe chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"greater than value\",\n\t\t\ttime:   time.Unix(0, 1234),\n\t\t\tvalue:  time.Unix(0, 1234-1),\n\t\t\twantGt: success,\n\t\t\twantGe: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal to value\",\n\t\t\ttime:   time.Unix(0, 1234),\n\t\t\tvalue:  time.Unix(0, 1234),\n\t\t\twantGt: failure,\n\t\t\twantGe: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"less than value\",\n\t\t\ttime:   time.Unix(0, 1234),\n\t\t\tvalue:  time.Unix(0, 1234+1),\n\t\t\twantGt: failure,\n\t\t\twantGe: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDateTime(reporter, tc.time).Gt(tc.value).\n\t\t\t\tchain.assert(t, tc.wantGt)\n\n\t\t\tNewDateTime(reporter, tc.time).Ge(tc.value).\n\t\t\t\tchain.assert(t, tc.wantGe)\n\t\t})\n\t}\n}\n\nfunc TestDateTime_IsLesser(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\ttime   time.Time\n\t\tvalue  time.Time\n\t\twantLt chainResult\n\t\twantLe chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"less than value\",\n\t\t\ttime:   time.Unix(0, 1234),\n\t\t\tvalue:  time.Unix(0, 1234+1),\n\t\t\twantLt: success,\n\t\t\twantLe: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"equal to value\",\n\t\t\ttime:   time.Unix(0, 1234),\n\t\t\tvalue:  time.Unix(0, 1234),\n\t\t\twantLt: failure,\n\t\t\twantLe: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"greater than value\",\n\t\t\ttime:   time.Unix(0, 1234),\n\t\t\tvalue:  time.Unix(0, 1234-1),\n\t\t\twantLt: failure,\n\t\t\twantLe: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDateTime(reporter, tc.time).Lt(tc.value).\n\t\t\t\tchain.assert(t, tc.wantLt)\n\n\t\t\tNewDateTime(reporter, tc.time).Le(tc.value).\n\t\t\t\tchain.assert(t, tc.wantLe)\n\t\t})\n\t}\n}\n\nfunc TestDateTime_InRange(t *testing.T) {\n\tcases := []struct {\n\t\tname           string\n\t\tvalue          time.Time\n\t\tmin            time.Time\n\t\tmax            time.Time\n\t\twantInRange    chainResult\n\t\twantNotInRange chainResult\n\t}{\n\t\t{\n\t\t\tname:           \"value equal to both min and max\",\n\t\t\tvalue:          time.Unix(0, 1234),\n\t\t\tmin:            time.Unix(0, 1234),\n\t\t\tmax:            time.Unix(0, 1234),\n\t\t\twantInRange:    success,\n\t\t\twantNotInRange: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value after min and equal to max\",\n\t\t\tvalue:          time.Unix(0, 1234),\n\t\t\tmin:            time.Unix(0, 1234-1),\n\t\t\tmax:            time.Unix(0, 1234),\n\t\t\twantInRange:    success,\n\t\t\twantNotInRange: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value equal to min and before max\",\n\t\t\tvalue:          time.Unix(0, 1234),\n\t\t\tmin:            time.Unix(0, 1234),\n\t\t\tmax:            time.Unix(0, 1234+1),\n\t\t\twantInRange:    success,\n\t\t\twantNotInRange: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value before range\",\n\t\t\tvalue:          time.Unix(0, 1234),\n\t\t\tmin:            time.Unix(0, 1234+1),\n\t\t\tmax:            time.Unix(0, 1234+2),\n\t\t\twantInRange:    failure,\n\t\t\twantNotInRange: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"value after range\",\n\t\t\tvalue:          time.Unix(0, 1234),\n\t\t\tmin:            time.Unix(0, 1234-2),\n\t\t\tmax:            time.Unix(0, 1234-1),\n\t\t\twantInRange:    failure,\n\t\t\twantNotInRange: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"invalid range\",\n\t\t\tvalue:          time.Unix(0, 1234),\n\t\t\tmin:            time.Unix(0, 1234+1),\n\t\t\tmax:            time.Unix(0, 1234-1),\n\t\t\twantInRange:    failure,\n\t\t\twantNotInRange: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDateTime(reporter, tc.value).InRange(tc.min, tc.max).\n\t\t\t\tchain.assert(t, tc.wantInRange)\n\n\t\t\tNewDateTime(reporter, tc.value).NotInRange(tc.min, tc.max).\n\t\t\t\tchain.assert(t, tc.wantNotInRange)\n\t\t})\n\t}\n}\n\nfunc TestDateTime_InList(t *testing.T) {\n\tcases := []struct {\n\t\tname          string\n\t\tvalue         time.Time\n\t\tlist          []time.Time\n\t\twantInList    chainResult\n\t\twantNotInList chainResult\n\t}{\n\t\t{\n\t\t\tname:          \"empty list\",\n\t\t\tvalue:         time.Unix(0, 1234),\n\t\t\tlist:          []time.Time{},\n\t\t\twantInList:    failure,\n\t\t\twantNotInList: failure,\n\t\t},\n\t\t{\n\t\t\tname:          \"value present in list\",\n\t\t\tvalue:         time.Unix(0, 1234),\n\t\t\tlist:          []time.Time{time.Unix(0, 1234), time.Unix(0, 1234+1)},\n\t\t\twantInList:    success,\n\t\t\twantNotInList: failure,\n\t\t},\n\t\t{\n\t\t\tname:          \"value not present in list\",\n\t\t\tvalue:         time.Unix(0, 1234),\n\t\t\tlist:          []time.Time{time.Unix(0, 1234-1), time.Unix(0, 1234+1)},\n\t\t\twantInList:    failure,\n\t\t\twantNotInList: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDateTime(reporter, tc.value).InList(tc.list...).\n\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\tNewDateTime(reporter, tc.value).NotInList(tc.list...).\n\t\t\t\tchain.assert(t, tc.wantNotInList)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "duration.go",
          "type": "blob",
          "size": 11.4150390625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"time\"\n)\n\n// Duration provides methods to inspect attached time.Duration value.\ntype Duration struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  *time.Duration\n}\n\n// NewDuration returns a new Duration instance.\n//\n// If reporter is nil, the function panics.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Second)\n//\td.Le(time.Minute)\nfunc NewDuration(reporter Reporter, value time.Duration) *Duration {\n\treturn newDuration(newChainWithDefaults(\"Duration()\", reporter), &value)\n}\n\n// NewDurationC returns a new Duration instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// Example:\n//\n//\td := NewDurationC(config, time.Second)\n//\td.Le(time.Minute)\nfunc NewDurationC(config Config, value time.Duration) *Duration {\n\treturn newDuration(newChainWithConfig(\"Duration()\", config.withDefaults()), &value)\n}\n\nfunc newDuration(parent *chain, val *time.Duration) *Duration {\n\treturn &Duration{chain: parent.clone(), value: val}\n}\n\n// Raw returns underlying time.Duration value attached to Duration.\n// This is the value originally passed to NewDuration.\n//\n// Example:\n//\n//\td := NewDuration(t, duration)\n//\tassert.Equal(t, timestamp, d.Raw())\nfunc (d *Duration) Raw() time.Duration {\n\tif d.value == nil {\n\t\treturn 0\n\t}\n\treturn *d.value\n}\n\n// Alias is similar to Value.Alias.\nfunc (d *Duration) Alias(name string) *Duration {\n\topChain := d.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\td.chain.setAlias(name)\n\treturn d\n}\n\n// Deprecated: support for unset durations will be removed. The only method that\n// can create unset duration is Cookie.MaxAge. Instead of Cookie.MaxAge().IsSet(),\n// please use Cookie.ContainsMaxAge().\nfunc (d *Duration) IsSet() *Duration {\n\topChain := d.chain.enter(\"IsSet()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// Deprecated: support for unset durations will be removed. The only method that\n// can create unset duration is Cookie.MaxAge. Instead of Cookie.MaxAge().NotSet(),\n// please use Cookie.NotContainsMaxAge().\nfunc (d *Duration) NotSet() *Duration {\n\topChain := d.chain.enter(\"NotSet()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif !(d.value == nil) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is not present\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// IsEqual succeeds if Duration is equal to given value.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Second)\n//\td.IsEqual(time.Second)\nfunc (d *Duration) IsEqual(value time.Duration) *Duration {\n\topChain := d.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif !(*d.value == value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: durations are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// NotEqual succeeds if Duration is not equal to given value.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Second)\n//\td.NotEqual(time.Minute)\nfunc (d *Duration) NotEqual(value time.Duration) *Duration {\n\topChain := d.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif *d.value == value {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: durations are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// Deprecated: use IsEqual instead.\nfunc (d *Duration) Equal(value time.Duration) *Duration {\n\treturn d.IsEqual(value)\n}\n\n// Gt succeeds if Duration is greater than given value.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Minute)\n//\td.Gt(time.Second)\nfunc (d *Duration) Gt(value time.Duration) *Duration {\n\topChain := d.chain.enter(\"Gt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif !(*d.value > value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertGt,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is larger than given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// Ge succeeds if Duration is greater than or equal to given value.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Minute)\n//\td.Ge(time.Second)\nfunc (d *Duration) Ge(value time.Duration) *Duration {\n\topChain := d.chain.enter(\"Ge()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif !(*d.value >= value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertGe,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is larger than or equal to given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// Lt succeeds if Duration is lesser than given value.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Second)\n//\td.Lt(time.Minute)\nfunc (d *Duration) Lt(value time.Duration) *Duration {\n\topChain := d.chain.enter(\"Lt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif !(*d.value < value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertLt,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is less than given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// Le succeeds if Duration is lesser than or equal to given value.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Second)\n//\td.Le(time.Minute)\nfunc (d *Duration) Le(value time.Duration) *Duration {\n\topChain := d.chain.enter(\"Le()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif !(*d.value <= value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertLe,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is less than or equal to given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// InRange succeeds if Duration is within given range [min; max].\n//\n// Example:\n//\n//\td := NewDuration(t, time.Minute)\n//\td.InRange(time.Second, time.Hour)\n//\td.InRange(time.Minute, time.Minute)\nfunc (d *Duration) InRange(min, max time.Duration) *Duration {\n\topChain := d.chain.enter(\"InRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif !(*d.value >= min && *d.value <= max) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertInRange,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{AssertionRange{min, max}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is within given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// NotInRange succeeds if Duration is not within given range [min; max].\n//\n// Example:\n//\n//\td := NewDuration(t, time.Minute*10)\n//\td.NotInRange(time.Minute, time.Minute-time.Nanosecond)\n//\td.NotInRange(time.Minute+time.Nanosecond, time.Minute*10)\nfunc (d *Duration) NotInRange(min, max time.Duration) *Duration {\n\topChain := d.chain.enter(\"NotInRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif *d.value >= min && *d.value <= max {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotInRange,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{AssertionRange{min, max}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is not within given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// InList succeeds if Duration is equal to one of the values from given\n// list of time.Duration.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Minute)\n//\td.InList(time.Minute, time.Hour)\nfunc (d *Duration) InList(values ...time.Duration) *Duration {\n\topChain := d.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\tif *d.value == v {\n\t\t\tisListed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !isListed {\n\t\tvalueList := make([]interface{}, 0, len(values))\n\t\tfor _, v := range values {\n\t\t\tvalueList = append(valueList, v)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{d.value},\n\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn d\n}\n\n// NotInList succeeds if Duration is not equal to any of the values from\n// given list of time.Duration.\n//\n// Example:\n//\n//\td := NewDuration(t, time.Minute)\n//\td.NotInList(time.Second, time.Hour)\nfunc (d *Duration) NotInList(values ...time.Duration) *Duration {\n\topChain := d.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn d\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tif d.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{d.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: duration is present\"),\n\t\t\t},\n\t\t})\n\t\treturn d\n\t}\n\n\tfor _, v := range values {\n\t\tif *d.value == v {\n\t\t\tvalueList := make([]interface{}, 0, len(values))\n\t\t\tfor _, v := range values {\n\t\t\t\tvalueList = append(valueList, v)\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{d.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: duration is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treturn d\n\t\t}\n\t}\n\n\treturn d\n}\n"
        },
        {
          "name": "duration_test.go",
          "type": "blob",
          "size": 7.0126953125,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDuration_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\ttm := time.Second\n\tvalue := newDuration(chain, &tm)\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Alias(\"foo\")\n\tvalue.IsEqual(tm)\n\tvalue.NotEqual(tm)\n\tvalue.InRange(tm, tm)\n\tvalue.NotInRange(tm, tm)\n\tvalue.InList(tm)\n\tvalue.NotInList(tm)\n\tvalue.Gt(tm)\n\tvalue.Ge(tm)\n\tvalue.Lt(tm)\n\tvalue.Le(tm)\n}\n\nfunc TestDuration_Constructors(t *testing.T) {\n\ttm := time.Second\n\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewDuration(reporter, tm)\n\t\tvalue.IsEqual(tm)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewDurationC(Config{\n\t\t\tReporter: reporter,\n\t\t}, tm)\n\t\tvalue.IsEqual(tm)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newDuration(chain, &tm)\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestDuration_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewDuration(reporter, time.Second)\n\n\tassert.Equal(t, time.Second, value.Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestDuration_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewDuration(reporter, time.Second)\n\tassert.Equal(t, []string{\"Duration()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Duration()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Duration()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestDuration_IsEqual(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tduration  time.Duration\n\t\tvalue     time.Duration\n\t\twantEqual chainResult\n\t}{\n\t\t{\n\t\t\tname:      \"compare equivalent durations\",\n\t\t\tduration:  time.Second,\n\t\t\tvalue:     time.Second,\n\t\t\twantEqual: success,\n\t\t},\n\t\t{\n\t\t\tname:      \"compare non-equivalent durations\",\n\t\t\tduration:  time.Second,\n\t\t\tvalue:     time.Minute,\n\t\t\twantEqual: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDuration(reporter, tc.duration).IsEqual(tc.value).\n\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\tNewDuration(reporter, tc.duration).NotEqual(tc.value).\n\t\t\t\tchain.assert(t, !tc.wantEqual)\n\t\t})\n\t}\n}\n\nfunc TestDuration_IsGreater(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tduration time.Duration\n\t\tvalue    time.Duration\n\t\twantGt   chainResult\n\t\twantGe   chainResult\n\t}{\n\t\t{\n\t\t\tname:     \"duration is lesser\",\n\t\t\tduration: time.Second,\n\t\t\tvalue:    time.Second + 1,\n\t\t\twantGt:   failure,\n\t\t\twantGe:   failure,\n\t\t},\n\t\t{\n\t\t\tname:     \"duration is equal\",\n\t\t\tduration: time.Second,\n\t\t\tvalue:    time.Second,\n\t\t\twantGt:   failure,\n\t\t\twantGe:   success,\n\t\t},\n\t\t{\n\t\t\tname:     \"duration is greater\",\n\t\t\tduration: time.Second,\n\t\t\tvalue:    time.Second - 1,\n\t\t\twantGt:   success,\n\t\t\twantGe:   success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDuration(reporter, tc.duration).Gt(tc.value).\n\t\t\t\tchain.assert(t, tc.wantGt)\n\n\t\t\tNewDuration(reporter, tc.duration).Ge(tc.value).\n\t\t\t\tchain.assert(t, tc.wantGe)\n\t\t})\n\t}\n}\n\nfunc TestDuration_IsLesser(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tduration time.Duration\n\t\tvalue    time.Duration\n\t\twantLt   chainResult\n\t\twantLe   chainResult\n\t}{\n\t\t{\n\t\t\tname:     \"duration is lesser\",\n\t\t\tduration: time.Second,\n\t\t\tvalue:    time.Second + 1,\n\t\t\twantLt:   success,\n\t\t\twantLe:   success,\n\t\t},\n\t\t{\n\t\t\tname:     \"duration is equal\",\n\t\t\tduration: time.Second,\n\t\t\tvalue:    time.Second,\n\t\t\twantLt:   failure,\n\t\t\twantLe:   success,\n\t\t},\n\t\t{\n\t\t\tname:     \"duration is greater\",\n\t\t\tduration: time.Second,\n\t\t\tvalue:    time.Second - 1,\n\t\t\twantLt:   failure,\n\t\t\twantLe:   failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDuration(reporter, tc.duration).Lt(tc.value).\n\t\t\t\tchain.assert(t, tc.wantLt)\n\n\t\t\tNewDuration(reporter, tc.duration).Le(tc.value).\n\t\t\t\tchain.assert(t, tc.wantLe)\n\t\t})\n\t}\n}\n\nfunc TestDuration_InRange(t *testing.T) {\n\tcases := []struct {\n\t\tname           string\n\t\tvalue          time.Duration\n\t\tmin            time.Duration\n\t\tmax            time.Duration\n\t\twantInRange    chainResult\n\t\twantNotInRange chainResult\n\t}{\n\t\t{\n\t\t\tname:           \"value equal to both min and max\",\n\t\t\tvalue:          time.Second,\n\t\t\tmin:            time.Second,\n\t\t\tmax:            time.Second,\n\t\t\twantInRange:    success,\n\t\t\twantNotInRange: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value greater than min and equal to max\",\n\t\t\tvalue:          time.Second,\n\t\t\tmin:            time.Second - 1,\n\t\t\tmax:            time.Second,\n\t\t\twantInRange:    success,\n\t\t\twantNotInRange: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value equal to min and smaller than max\",\n\t\t\tvalue:          time.Second,\n\t\t\tmin:            time.Second,\n\t\t\tmax:            time.Second + 1,\n\t\t\twantInRange:    success,\n\t\t\twantNotInRange: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value smaller than min\",\n\t\t\tvalue:          time.Second,\n\t\t\tmin:            time.Second + 1,\n\t\t\tmax:            time.Second + 2,\n\t\t\twantInRange:    failure,\n\t\t\twantNotInRange: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"value greater than max\",\n\t\t\tvalue:          time.Second,\n\t\t\tmin:            time.Second - 2,\n\t\t\tmax:            time.Second - 1,\n\t\t\twantInRange:    failure,\n\t\t\twantNotInRange: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"min smaller than max\",\n\t\t\tvalue:          time.Second,\n\t\t\tmin:            time.Second + 1,\n\t\t\tmax:            time.Second - 1,\n\t\t\twantInRange:    failure,\n\t\t\twantNotInRange: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDuration(reporter, tc.value).InRange(tc.min, tc.max).\n\t\t\t\tchain.assert(t, tc.wantInRange)\n\n\t\t\tNewDuration(reporter, tc.value).NotInRange(tc.min, tc.max).\n\t\t\t\tchain.assert(t, tc.wantNotInRange)\n\t\t})\n\t}\n}\n\nfunc TestDuration_InList(t *testing.T) {\n\tcases := []struct {\n\t\tname          string\n\t\tvalue         time.Duration\n\t\tlist          []time.Duration\n\t\twantInList    chainResult\n\t\twantNotInList chainResult\n\t}{\n\t\t{\n\t\t\tname:          \"empty list\",\n\t\t\tvalue:         time.Second,\n\t\t\tlist:          []time.Duration{},\n\t\t\twantInList:    failure,\n\t\t\twantNotInList: failure,\n\t\t},\n\t\t{\n\t\t\tname:          \"value present in list\",\n\t\t\tvalue:         time.Second,\n\t\t\tlist:          []time.Duration{time.Second, time.Minute},\n\t\t\twantInList:    success,\n\t\t\twantNotInList: failure,\n\t\t},\n\t\t{\n\t\t\tname:          \"value not present in list\",\n\t\t\tvalue:         time.Second,\n\t\t\tlist:          []time.Duration{time.Second - 1, time.Second + 1},\n\t\t\twantInList:    failure,\n\t\t\twantNotInList: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewDuration(reporter, tc.value).InList(tc.list...).\n\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\tNewDuration(reporter, tc.value).NotInList(tc.list...).\n\t\t\t\tchain.assert(t, tc.wantNotInList)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "e2e",
          "type": "tree",
          "content": null
        },
        {
          "name": "environment.go",
          "type": "blob",
          "size": 10.4658203125,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gobwas/glob\"\n)\n\n// Environment provides a container for arbitrary data shared between tests.\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\n//\tenv.Put(\"key\", \"value\")\n//\tvalue := env.GetString(\"key\")\ntype Environment struct {\n\tmu    sync.RWMutex\n\tchain *chain\n\tdata  map[string]interface{}\n}\n\n// NewEnvironment returns a new Environment.\n//\n// If reporter is nil, the function panics.\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\nfunc NewEnvironment(reporter Reporter) *Environment {\n\treturn newEnvironment(newChainWithDefaults(\"Environment()\", reporter))\n}\n\n// NewEnvironmentC returns a new Environment with config.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// Example:\n//\n//\tenv := NewEnvironmentC(config)\nfunc NewEnvironmentC(config Config) *Environment {\n\treturn newEnvironment(newChainWithConfig(\"Environment()\", config.withDefaults()))\n}\n\nfunc newEnvironment(parent *chain) *Environment {\n\treturn &Environment{\n\t\tchain: parent.clone(),\n\t\tdata:  make(map[string]interface{}),\n\t}\n}\n\n// Put saves the value with key in the environment.\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\n//\tenv.Put(\"key1\", \"str\")\n//\tenv.Put(\"key2\", 123)\nfunc (e *Environment) Put(key string, value interface{}) {\n\topChain := e.chain.enter(\"Put(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.Lock()\n\tdefer e.mu.Unlock()\n\n\te.data[key] = value\n}\n\n// Delete removes the value with key from the environment.\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\n//\tenv.Put(\"key1\", \"str\")\n//\tenv.Delete(\"key1\")\nfunc (e *Environment) Delete(key string) {\n\topChain := e.chain.enter(\"Delete(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.Lock()\n\tdefer e.mu.Unlock()\n\n\tdelete(e.data, key)\n}\n\n// Clear will delete all key value pairs from the environment\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\n//\tenv.Put(\"key1\", 123)\n//\tenv.Put(\"key2\", 456)\n//\tenv.Clear()\nfunc (e *Environment) Clear() {\n\topChain := e.chain.enter(\"Clear()\")\n\tdefer opChain.leave()\n\n\te.mu.Lock()\n\tdefer e.mu.Unlock()\n\n\te.data = make(map[string]interface{})\n}\n\n// Has returns true if value exists in the environment.\n//\n// Example:\n//\n//\tif env.Has(\"key1\") {\n//\t   ...\n//\t}\nfunc (e *Environment) Has(key string) bool {\n\topChain := e.chain.enter(\"Has(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\t_, ok := e.data[key]\n\treturn ok\n}\n\n// Get returns value stored in the environment.\n//\n// If value does not exist, reports failure and returns nil.\n//\n// Example:\n//\n//\tvalue1 := env.Get(\"key1\").(string)\n//\tvalue2 := env.Get(\"key1\").(int)\nfunc (e *Environment) Get(key string) interface{} {\n\topChain := e.chain.enter(\"Get(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, _ := envValue(opChain, e.data, key)\n\n\treturn value\n}\n\n// GetBool returns value stored in the environment, casted to bool.\n//\n// If value does not exist, or is not bool, reports failure and returns false.\n//\n// Example:\n//\n//\tvalue := env.GetBool(\"key\")\nfunc (e *Environment) GetBool(key string) bool {\n\topChain := e.chain.enter(\"GetBool(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn false\n\t}\n\n\tcasted, ok := value.(bool)\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: bool value\"),\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\treturn casted\n}\n\n// GetInt returns value stored in the environment, casted to int64.\n//\n// If value does not exist, or is not signed or unsigned integer that can be\n// represented as int without overflow, reports failure and returns zero.\n//\n// Example:\n//\n//\tvalue := env.GetInt(\"key\")\nfunc (e *Environment) GetInt(key string) int {\n\topChain := e.chain.enter(\"GetInt(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn 0\n\t}\n\n\tvar casted int\n\n\tconst (\n\t\tintSize = 32 << (^uint(0) >> 63) // 32 or 64\n\t\tmaxInt  = 1<<(intSize-1) - 1\n\t\tminInt  = -1 << (intSize - 1)\n\t)\n\n\tswitch num := value.(type) {\n\tcase int8:\n\t\tcasted = int(num)\n\t\tok = (int64(num) >= minInt) && (int64(num) <= maxInt)\n\tcase int16:\n\t\tcasted = int(num)\n\t\tok = (int64(num) >= minInt) && (int64(num) <= maxInt)\n\tcase int32:\n\t\tcasted = int(num)\n\t\tok = (int64(num) >= minInt) && (int64(num) <= maxInt)\n\tcase int64:\n\t\tcasted = int(num)\n\t\tok = (int64(num) >= minInt) && (int64(num) <= maxInt)\n\tcase int:\n\t\tcasted = num\n\t\tok = (int64(num) >= minInt) && (int64(num) <= maxInt)\n\n\tcase uint8:\n\t\tcasted = int(num)\n\t\tok = (uint64(num) <= maxInt)\n\tcase uint16:\n\t\tcasted = int(num)\n\t\tok = (uint64(num) <= maxInt)\n\tcase uint32:\n\t\tcasted = int(num)\n\t\tok = (uint64(num) <= maxInt)\n\tcase uint64:\n\t\tcasted = int(num)\n\t\tok = (uint64(num) <= maxInt)\n\tcase uint:\n\t\tcasted = int(num)\n\t\tok = (uint64(num) <= maxInt)\n\n\tdefault:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: signed or unsigned integer\"),\n\t\t\t},\n\t\t})\n\t\treturn 0\n\t}\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertInRange,\n\t\t\tActual:   &AssertionValue{value},\n\t\t\tExpected: &AssertionValue{AssertionRange{minInt, maxInt}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\n\t\t\t\t\t\"expected: value can be represented as int without overflow\"),\n\t\t\t},\n\t\t})\n\t\treturn 0\n\t}\n\n\treturn casted\n}\n\n// GetFloat returns value stored in the environment, casted to float64.\n//\n// If value does not exist, or is not floating point value, reports failure\n// and returns zero value.\n//\n// Example:\n//\n//\tvalue := env.GetFloat(\"key\")\nfunc (e *Environment) GetFloat(key string) float64 {\n\topChain := e.chain.enter(\"GetFloat(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn 0\n\t}\n\n\tvar casted float64\n\n\tswitch num := value.(type) {\n\tcase float32:\n\t\tcasted = float64(num)\n\n\tcase float64:\n\t\tcasted = num\n\n\tdefault:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: float32 or float64\"),\n\t\t\t},\n\t\t})\n\t\treturn 0\n\t}\n\n\treturn casted\n}\n\n// GetString returns value stored in the environment, casted to string.\n//\n// If value does not exist, or is not string, reports failure and returns\n// empty string.\n//\n// Example:\n//\n//\tvalue := env.GetString(\"key\")\nfunc (e *Environment) GetString(key string) string {\n\topChain := e.chain.enter(\"GetString(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\tcasted, ok := value.(string)\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string value\"),\n\t\t\t},\n\t\t})\n\t\treturn \"\"\n\t}\n\n\treturn casted\n}\n\n// GetBytes returns value stored in the environment, casted to []byte.\n//\n// If value does not exist, or is not []byte slice, reports failure and returns nil.\n//\n// Example:\n//\n//\tvalue := env.GetBytes(\"key\")\nfunc (e *Environment) GetBytes(key string) []byte {\n\topChain := e.chain.enter(\"GetBytes(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tcasted, ok := value.([]byte)\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: []byte slice\"),\n\t\t\t},\n\t\t})\n\t\treturn nil\n\t}\n\n\treturn casted\n}\n\n// GetDuration returns value stored in the environment, casted to time.Duration.\n//\n// If value does not exist, is not time.Duration, reports failure and returns\n// zero duration.\n//\n// Example:\n//\n//\tvalue := env.GetDuration(\"key\")\nfunc (e *Environment) GetDuration(key string) time.Duration {\n\topChain := e.chain.enter(\"GetDuration(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn time.Duration(0)\n\t}\n\n\tcasted, ok := value.(time.Duration)\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time.Duration value\"),\n\t\t\t},\n\t\t})\n\t\treturn time.Duration(0)\n\t}\n\n\treturn casted\n}\n\n// GetTime returns value stored in the environment, casted to time.Time.\n//\n// If value does not exist, is not time.Time, reports failure and returns\n// zero time.\n//\n// Example:\n//\n//\tvalue := env.GetTime(\"key\")\nfunc (e *Environment) GetTime(key string) time.Time {\n\topChain := e.chain.enter(\"GetTime(%q)\", key)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tvalue, ok := envValue(opChain, e.data, key)\n\tif !ok {\n\t\treturn time.Unix(0, 0)\n\t}\n\n\tcasted, ok := value.(time.Time)\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertType,\n\t\t\tActual: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: time.Time value\"),\n\t\t\t},\n\t\t})\n\t\treturn time.Unix(0, 0)\n\t}\n\n\treturn casted\n}\n\n// List returns a sorted slice of keys.\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\n//\n//\tfor _, key := range env.List() {\n//\t\t...\n//\t}\nfunc (e *Environment) List() []string {\n\topChain := e.chain.enter(\"List()\")\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tkeys := []string{}\n\n\tfor key := range e.data {\n\t\tkeys = append(keys, key)\n\t}\n\n\tsort.Slice(keys, func(i, j int) bool {\n\t\treturn keys[i] < keys[j]\n\t})\n\treturn keys\n}\n\n// Glob accepts a glob pattern and returns a sorted slice of\n// keys that match the pattern.\n//\n// If the pattern is invalid, reports failure and returns an\n// empty slice.\n//\n// Example:\n//\n//\tenv := NewEnvironment(t)\n//\n//\tfor _, key := range env.Glob(\"foo.*\") {\n//\t\t...\n//\t}\nfunc (e *Environment) Glob(pattern string) []string {\n\topChain := e.chain.enter(\"Glob(%q)\", pattern)\n\tdefer opChain.leave()\n\n\te.mu.RLock()\n\tdefer e.mu.RUnlock()\n\n\tglb, err := glob.Compile(pattern)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected invalid glob pattern\"),\n\t\t\t},\n\t\t})\n\t\treturn []string{}\n\t}\n\n\tkeys := []string{}\n\tfor key := range e.data {\n\t\tif glb.Match(key) {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t}\n\n\tsort.Slice(keys, func(i, j int) bool {\n\t\treturn keys[i] < keys[j]\n\t})\n\treturn keys\n}\n\nfunc envValue(chain *chain, env map[string]interface{}, key string) (interface{}, bool) {\n\tv, ok := env[key]\n\n\tif !ok {\n\t\tchain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsKey,\n\t\t\tActual:   &AssertionValue{env},\n\t\t\tExpected: &AssertionValue{key},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: environment contains key\"),\n\t\t\t},\n\t\t})\n\t\treturn nil, false\n\t}\n\n\treturn v, true\n}\n"
        },
        {
          "name": "environment_test.go",
          "type": "blob",
          "size": 10.796875,
          "content": "package httpexpect\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEnvironment_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tenv := NewEnvironment(reporter)\n\t\tenv.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tenv := NewEnvironmentC(Config{\n\t\t\tReporter: reporter,\n\t\t})\n\t\tenv.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newEnvironment(chain)\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestEnvironment_Reentrancy(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tenv := NewEnvironment(reporter)\n\n\treportCalled := false\n\treporter.reportCb = func() {\n\t\tenv.Put(\"good_key\", 123)\n\t\treportCalled = true\n\t}\n\n\tenv.Get(\"bad_key\")\n\tenv.chain.assert(t, failure)\n\n\tassert.True(t, reportCalled)\n}\n\nfunc TestEnvironment_Basic(t *testing.T) {\n\tenv := newEnvironment(newMockChain(t))\n\n\tassert.False(t, env.Has(\"good_key\"))\n\tenv.chain.assert(t, success)\n\n\tenv.Put(\"good_key\", 123)\n\tenv.chain.assert(t, success)\n\n\tassert.True(t, env.Has(\"good_key\"))\n\tassert.NotNil(t, env.Get(\"good_key\"))\n\tassert.Equal(t, 123, env.Get(\"good_key\").(int))\n\tenv.chain.assert(t, success)\n\n\tassert.False(t, env.Has(\"bad_key\"))\n\tenv.chain.assert(t, success)\n\n\tassert.Nil(t, env.Get(\"bad_key\"))\n\tenv.chain.assert(t, failure)\n}\n\nfunc TestEnvironment_Delete(t *testing.T) {\n\tenv := newEnvironment(newMockChain(t))\n\n\tenv.Put(\"good_key\", 123)\n\tenv.chain.assert(t, success)\n\n\tassert.True(t, env.Has(\"good_key\"))\n\tassert.NotNil(t, env.Get(\"good_key\"))\n\tassert.Equal(t, 123, env.Get(\"good_key\").(int))\n\tenv.chain.assert(t, success)\n\n\tenv.Delete(\"good_key\")\n\tenv.chain.assert(t, success)\n\n\tassert.False(t, env.Has(\"good_key\"))\n\tassert.Nil(t, env.Get(\"good_key\"))\n\tenv.chain.assert(t, failure)\n}\n\nfunc TestEnvironment_Clear(t *testing.T) {\n\tenv := newEnvironment(newMockChain(t))\n\n\tfor i := 1; i < 11; i++ {\n\t\tkey := fmt.Sprint(\"key\", i)\n\t\tenv.Put(key, i)\n\t\tenv.chain.assert(t, success)\n\t\tassert.True(t, env.Has(key))\n\t\tassert.NotNil(t, env.Get(key))\n\t\tassert.Equal(t, i, env.Get(key).(int))\n\t\tenv.chain.assert(t, success)\n\t}\n\n\tenv.Clear()\n\tenv.chain.assert(t, success)\n\n\tfor i := 1; i < 11; i++ {\n\t\tkey := fmt.Sprint(\"key\", i)\n\t\tassert.False(t, env.Has(key))\n\t}\n\n\tassert.Zero(t, len(env.data))\n\tenv.chain.assert(t, success)\n}\n\nfunc TestEnvironment_NotFound(t *testing.T) {\n\tt.Run(\"Get\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Nil(t, env.Get(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetBool\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Zero(t, env.GetInt(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetInt\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Zero(t, env.GetInt(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetFloat\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Zero(t, env.GetFloat(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetString\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Zero(t, env.GetString(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetBytes\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Nil(t, env.GetBytes(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetDuration\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Zero(t, env.GetDuration(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"GetTime\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Equal(t, time.Unix(0, 0), env.GetTime(\"bad_key\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n}\n\nfunc TestEnvironment_Bool(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    bool\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    true,\n\t\t\tget:    true,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    1,\n\t\t\tget:    false,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    1.0,\n\t\t\tget:    false,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    \"true\",\n\t\t\tget:    false,\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetBool(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_Int(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    int\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    int(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    int8(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    int16(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    int32(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    int64(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    uint(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    uint8(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    uint16(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    uint32(123),\n\t\t\tget:    123,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    uint64(math.MaxUint64),\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    123.0,\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    false,\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    time.Second,\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    \"123\",\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetInt(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_Float(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    float64\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    float32(123),\n\t\t\tget:    123.0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    float64(123),\n\t\t\tget:    123.0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    int(123),\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    false,\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    \"123.0\",\n\t\t\tget:    0,\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetFloat(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_String(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    string\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    \"test\",\n\t\t\tget:    \"test\",\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    []byte(\"test\"),\n\t\t\tget:    \"\",\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    123,\n\t\t\tget:    \"\",\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetString(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_Bytes(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    []byte\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    []byte(\"test\"),\n\t\t\tget:    []byte(\"test\"),\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    \"test\",\n\t\t\tget:    nil,\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    123,\n\t\t\tget:    nil,\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetBytes(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_Duration(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    time.Duration\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    time.Second,\n\t\t\tget:    time.Second,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    int64(999999999),\n\t\t\tget:    time.Duration(0),\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    \"1s\",\n\t\t\tget:    time.Duration(0),\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetDuration(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_Time(t *testing.T) {\n\tcases := []struct {\n\t\tput    interface{}\n\t\tget    time.Time\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tput:    time.Unix(9999999, 0),\n\t\t\tget:    time.Unix(9999999, 0),\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tput:    9999999,\n\t\t\tget:    time.Unix(0, 0),\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tput:    time.Unix(9999999, 0).String(),\n\t\t\tget:    time.Unix(0, 0),\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(fmt.Sprintf(\"%T-%v\", tc.put, tc.put),\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tenv := newEnvironment(newMockChain(t))\n\n\t\t\t\tenv.Put(\"key\", tc.put)\n\t\t\t\tenv.chain.assert(t, success)\n\n\t\t\t\tval := env.GetTime(\"key\")\n\t\t\t\tassert.Equal(t, tc.get, val)\n\n\t\t\t\tenv.chain.assert(t, tc.result)\n\t\t\t})\n\t}\n}\n\nfunc TestEnvironment_List(t *testing.T) {\n\tenv := newEnvironment(newMockChain(t))\n\n\tassert.Equal(t, []string{}, env.List())\n\n\tenv.Put(\"k1\", 1)\n\tenv.Put(\"k2\", 2)\n\tenv.Put(\"k3\", 3)\n\tassert.Equal(t, []string{\"k1\", \"k2\", \"k3\"}, env.List())\n\n\tenv.Put(\"abc\", 4)\n\tassert.Equal(t, []string{\"abc\", \"k1\", \"k2\", \"k3\"}, env.List())\n\n\tenv.Delete(\"k2\")\n\tenv.Delete(\"k3\")\n\tenv.Put(\"pqr\", 5)\n\tassert.Equal(t, []string{\"abc\", \"k1\", \"pqr\"}, env.List())\n}\n\nfunc TestEnvironment_Glob(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Equal(t, []string{}, env.Glob(\"*\"))\n\n\t\tenv.Put(\"k1\", 1)\n\t\tenv.Put(\"k2\", 2)\n\t\tenv.Put(\"k3\", 3)\n\t\tassert.Equal(t, []string{\"k1\", \"k2\", \"k3\"}, env.Glob(\"*\"))\n\n\t\tenv.Put(\"abc\", 5)\n\t\tassert.Equal(t, []string{\"k1\", \"k2\", \"k3\"}, env.Glob(\"k*\"))\n\n\t\tenv.Put(\"ab\", 6)\n\t\tenv.Put(\"ac\", 7)\n\t\tassert.Equal(t, []string{\"ab\", \"ac\"}, env.Glob(\"a?\"))\n\n\t\tassert.Equal(t, []string{\"ab\", \"abc\"}, env.Glob(\"ab*\"))\n\n\t\tenv.Put(\"k4\", 8)\n\t\tassert.Equal(t, []string{\"k2\", \"k3\", \"k4\"}, env.Glob(\"k[2-4]\"))\n\n\t\tenv.Put(\"a4\", 9)\n\t\tassert.Equal(t, []string{\"a4\", \"ab\", \"ac\", \"k4\"}, env.Glob(\"?[!1-3]\"))\n\t\tassert.Equal(t, []string{\"a4\", \"k1\", \"k4\"}, env.Glob(\"?[1,4]\"))\n\t\tassert.Equal(t, []string{\"ab\", \"ac\", \"k2\", \"k3\"}, env.Glob(\"?[!1,4]\"))\n\t})\n\n\tt.Run(\"invalid pattern, empty env\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tassert.Equal(t, []string{}, env.Glob(\"k[1-2\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid pattern, non-empty env\", func(t *testing.T) {\n\t\tenv := newEnvironment(newMockChain(t))\n\n\t\tenv.Put(\"k1\", 1)\n\t\tenv.Put(\"k2\", 2)\n\n\t\tassert.Equal(t, []string{}, env.Glob(\"k[]\"))\n\t\tenv.chain.assert(t, failure)\n\t})\n}\n"
        },
        {
          "name": "expect.go",
          "type": "blob",
          "size": 20.669921875,
          "content": "// Package httpexpect helps with end-to-end HTTP and REST API testing.\n//\n// # Usage examples\n//\n// See example directory:\n//   - https://pkg.go.dev/github.com/gavv/httpexpect/_examples\n//   - https://github.com/gavv/httpexpect/tree/master/_examples\n//\n// # Communication mode\n//\n// There are two common ways to test API with httpexpect:\n//   - start HTTP server and instruct httpexpect to use HTTP client for communication\n//   - don't start server and instruct httpexpect to invoke http handler directly\n//\n// The second approach works only if the server is a Go module and its handler can\n// be imported in tests.\n//\n// Concrete behaviour is determined by Client implementation passed to Config struct.\n// If you're using http.Client, set its Transport field (http.RoundTriper) to one of\n// the following:\n//  1. default (nil) - use HTTP transport from net/http (you should start server)\n//  2. httpexpect.Binder - invoke given http.Handler directly\n//  3. httpexpect.FastBinder - invoke given fasthttp.RequestHandler directly\n//\n// Note that http handler can be usually obtained from http framework you're using.\n// E.g., echo framework provides either http.Handler or fasthttp.RequestHandler.\n//\n// You can also provide your own implementation of RequestFactory (creates http.Request),\n// or Client (gets http.Request and returns http.Response).\n//\n// If you're starting server from tests, it's very handy to use net/http/httptest.\n//\n// # Value equality\n//\n// Whenever values are checked for equality in httpexpect, they are converted\n// to \"canonical form\":\n//   - structs are converted to map[string]interface{}\n//   - type aliases are removed\n//   - numeric types are converted to float64\n//   - non-nil interfaces pointing to nil slices and maps are replaced with\n//     nil interfaces\n//\n// This is equivalent to subsequently json.Marshal() and json.Unmarshal() the value\n// and currently is implemented so.\n//\n// # Failure handling\n//\n// When some check fails, failure is reported. If non-fatal failures are used\n// (see Reporter interface), execution is continued and instance that was checked\n// is marked as failed.\n//\n// If specific instance is marked as failed, all subsequent checks are ignored\n// for this instance and for any child instances retrieved after failure.\n//\n// Example:\n//\n//\tarray := NewArray(NewAssertReporter(t), []interface{}{\"foo\", 123})\n//\n//\te0 := array.Value(0)  // success\n//\te1 := array.Value(1)  // success\n//\n//\ts0 := e0.String()  // success\n//\ts1 := e1.String()  // failure; e1 and s1 are marked as failed, e0 and s0 are not\n//\n//\ts0.IsEqual(\"foo\")    // success\n//\ts1.IsEqual(\"bar\")    // this check is ignored because s1 is marked as failed\n//\n// # Assertion handling\n//\n// If you want to be informed about every asserion made, successful or failed, you\n// can use AssertionHandler interface.\n//\n// Default implementation of this interface ignores successful assertions and reports\n// failed assertions using Formatter and Reporter objects.\n//\n// Custom AssertionHandler can handle all assertions (e.g. dump them in JSON format)\n// and is free to use or not to use Formatter and Reporter in its sole discretion.\npackage httpexpect\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// Expect is a toplevel object that contains user Config and allows\n// to construct Request objects.\ntype Expect struct {\n\tnoCopy   noCopy\n\tconfig   Config\n\tchain    *chain\n\tbuilders []func(*Request)\n\tmatchers []func(*Response)\n}\n\n// Config contains various settings.\ntype Config struct {\n\t// TestName defines the name of the currently running test.\n\t// May be empty.\n\t//\n\t// If non-empty, it will be included in failure report.\n\t// Normally you set this value to t.Name().\n\tTestName string\n\n\t// BaseURL is a URL to prepended to all requests.\n\t// May be empty.\n\t//\n\t// If non-empty, trailing slash is allowed (but not required) and is appended\n\t// automatically.\n\tBaseURL string\n\n\t// RequestFactory is used to pass in a custom *http.Request generation func.\n\t// May be nil.\n\t//\n\t// If nil, DefaultRequestFactory is used, which just calls http.NewRequest.\n\t//\n\t// You can use DefaultRequestFactory, or provide custom implementation.\n\t// Useful for Google App Engine testing for example.\n\tRequestFactory RequestFactory\n\n\t// Client is used to send http.Request and receive http.Response.\n\t// May be nil.\n\t//\n\t// If nil, set to a default client with a non-nil Jar:\n\t//  &http.Client{\n\t//      Jar: httpexpect.NewCookieJar(),\n\t//  }\n\t//\n\t// You can use http.DefaultClient or your own http.Client, or provide\n\t// custom implementation.\n\tClient Client\n\n\t// WebsocketDialer is used to establish websocket.Conn and receive http.Response\n\t// of handshake result.\n\t// May be nil.\n\t//\n\t// If nil, set to a default dialer:\n\t//  &websocket.Dialer{}\n\t//\n\t// You can use websocket.DefaultDialer or websocket.Dialer, or provide\n\t// custom implementation.\n\tWebsocketDialer WebsocketDialer\n\n\t// Context is passed to all requests. It is typically used for request cancellation,\n\t// either explicit or after a time-out.\n\t// May be nil.\n\t//\n\t// You can use the Request.WithContext for per-request context and Request.WithTimeout\n\t// for per-request timeout.\n\tContext context.Context\n\n\t// Reporter is used to report formatted failure messages.\n\t// Should NOT be nil, unless custom AssertionHandler is used.\n\t//\n\t// Config.Reporter is used by DefaultAssertionHandler, which is automatically\n\t// constructed when AssertionHandler is nil.\n\t//\n\t// You can use:\n\t//  - AssertReporter / RequireReporter\n\t//    (non-fatal / fatal failures using testify package)\n\t//  - testing.T / FatalReporter\n\t//    (non-fatal / fatal failures using standard testing package)\n\t//  - PanicReporter\n\t//    (failures that panic to be used in multithreaded tests)\n\t//  - custom implementation\n\tReporter Reporter\n\n\t// Formatter is used to format success and failure messages.\n\t// May be nil.\n\t//\n\t// If nil, DefaultFormatter is used.\n\t//\n\t// Config.Formatter is used by DefaultAssertionHandler, which is automatically\n\t// constructed when AssertionHandler is nil.\n\t//\n\t// Usually you don't need custom formatter. Implementing one is a\n\t// relatively big task.\n\tFormatter Formatter\n\n\t// AssertionHandler handles successful and failed assertions.\n\t// May be nil.\n\t//\n\t// Every time an assertion is made, AssertionHandler is invoked with detailed\n\t// info about the assertion. On failure, AssertionHandler is responsible to\n\t// format error and report it to the test suite.\n\t//\n\t// If AssertionHandler is nil, DefaultAssertionHandler is constructed, with\n\t// Formatter set to Config.Formatter, Reporter set to Config.Reporter, and\n\t// Logger set to nil. DefaultAssertionHandler will just delegate formatting\n\t// and reporting to Formatter and Reporter.\n\t//\n\t// If you're happy with DefaultAssertionHandler, but want to enable logging\n\t// of successful assertions and non-fatal failures, you can manually construct\n\t// DefaultAssertionHandler and set its Logger field to a non-nil value.\n\t//\n\t// Usually you don't need custom AssertionHandler and it's enough just to\n\t// set Reporter. Use AssertionHandler for more precise control of reports.\n\tAssertionHandler AssertionHandler\n\n\t// Printers are used to print requests and responses.\n\t// May be nil.\n\t//\n\t// If printer implements WebsocketPrinter interface, it will be also used\n\t// to print Websocket messages.\n\t//\n\t// You can use CompactPrinter, DebugPrinter, CurlPrinter, or provide\n\t// custom implementation.\n\t//\n\t// You can also use builtin printers with alternative Logger if you're happy\n\t// with their format, but want to send logs somewhere else than *testing.T.\n\tPrinters []Printer\n\n\t// Environment provides a container for arbitrary data shared between tests.\n\t// May be nil.\n\t//\n\t// Environment is not used by httpexpect itself, but can be used by tests to\n\t// store and load arbitrary values. Tests can access Environment via\n\t// Expect.Env(). It is also accessible in AssertionHandler via AssertionContext.\n\t//\n\t// If Environment is nil, a new empty environment is automatically created\n\t// when Expect instance is constructed.\n\tEnvironment *Environment\n}\n\nfunc (config Config) withDefaults() Config {\n\tif config.RequestFactory == nil {\n\t\tconfig.RequestFactory = DefaultRequestFactory{}\n\t}\n\n\tif config.Client == nil {\n\t\tconfig.Client = &http.Client{\n\t\t\tJar: NewCookieJar(),\n\t\t}\n\t}\n\n\tif config.WebsocketDialer == nil {\n\t\tconfig.WebsocketDialer = &websocket.Dialer{}\n\t}\n\n\tif config.AssertionHandler == nil {\n\t\tif config.Formatter == nil {\n\t\t\tconfig.Formatter = &DefaultFormatter{}\n\t\t}\n\n\t\tif config.Reporter == nil {\n\t\t\tpanic(\"either Config.Reporter or Config.AssertionHandler should be non-nil\")\n\t\t}\n\n\t\tconfig.AssertionHandler = &DefaultAssertionHandler{\n\t\t\tFormatter: config.Formatter,\n\t\t\tReporter:  config.Reporter,\n\t\t}\n\t}\n\n\treturn config\n}\n\nfunc (config *Config) validate() {\n\tif config.RequestFactory == nil {\n\t\tpanic(\"Config.RequestFactory is nil\")\n\t}\n\n\tif config.Client == nil {\n\t\tpanic(\"Config.Client is nil\")\n\t}\n\n\tif config.AssertionHandler == nil {\n\t\tpanic(\"Config.AssertionHandler is nil\")\n\t}\n\n\tif handler, ok := config.AssertionHandler.(*DefaultAssertionHandler); ok {\n\t\tif handler.Formatter == nil {\n\t\t\tpanic(\"DefaultAssertionHandler.Formatter is nil\")\n\t\t}\n\n\t\tif handler.Reporter == nil {\n\t\t\tpanic(\"DefaultAssertionHandler.Reporter is nil\")\n\t\t}\n\t}\n}\n\n// RequestFactory is used to create all http.Request objects.\n// aetest.Instance from the Google App Engine implements this interface.\ntype RequestFactory interface {\n\tNewRequest(method, url string, body io.Reader) (*http.Request, error)\n}\n\n// RequestFactoryFunc is an adapter that allows a function\n// to be used as the RequestFactory\n//\n// Example:\n//\n//\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\tRequestFactory: httpextect.RequestFactoryFunc(\n//\t\t\tfunc(method string, url string, body io.Reader) (*http.Request, error) {\n//\t\t\t\t// factory code here\n//\t\t\t}),\n//\t})\ntype RequestFactoryFunc func(\n\tmethod string, url string, body io.Reader,\n) (*http.Request, error)\n\nfunc (f RequestFactoryFunc) NewRequest(\n\tmethod string, url string, body io.Reader,\n) (*http.Request, error) {\n\treturn f(method, url, body)\n}\n\n// Client is used to send http.Request and receive http.Response.\n// http.Client implements this interface.\n//\n// Binder and FastBinder may be used to obtain this interface implementation.\n//\n// Example:\n//\n//\thttpBinderClient := &http.Client{\n//\t  Transport: httpexpect.NewBinder(HTTPHandler),\n//\t}\n//\tfastBinderClient := &http.Client{\n//\t  Transport: httpexpect.NewFastBinder(FastHTTPHandler),\n//\t}\ntype Client interface {\n\t// Do sends request and returns response.\n\tDo(*http.Request) (*http.Response, error)\n}\n\n// ClientFunc is an adapter that allows a function to be used as the Client\n//\n// Example:\n//\n//\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\tClient: httpextect.ClientFunc(\n//\t\t\tfunc(req *http.Request) (*http.Response, error) {\n//\t\t\t\t// client code here\n//\t\t\t}),\n//\t})\ntype ClientFunc func(req *http.Request) (*http.Response, error)\n\nfunc (f ClientFunc) Do(req *http.Request) (*http.Response, error) {\n\treturn f(req)\n}\n\n// WebsocketDialer is used to establish websocket.Conn and receive http.Response\n// of handshake result.\n// websocket.Dialer implements this interface.\n//\n// NewWebsocketDialer and NewFastWebsocketDialer may be used to obtain this\n// interface implementation.\n//\n// Example:\n//\n//\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\tWebsocketDialer: httpexpect.NewWebsocketDialer(myHandler),\n//\t})\ntype WebsocketDialer interface {\n\t// Dial establishes new Websocket connection and returns response\n\t// of handshake result.\n\tDial(url string, reqH http.Header) (*websocket.Conn, *http.Response, error)\n}\n\n// WebsocketDialerFunc is an adapter that allows a function\n// to be used as the WebsocketDialer\n//\n// Example:\n//\n//\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\tWebsocketDialer: httpextect.WebsocketDialerFunc(\n//\t\t\tfunc(url string, reqH http.Header) (*websocket.Conn, *http.Response, error) {\n//\t\t\t\t// dialer code here\n//\t\t\t}),\n//\t})\ntype WebsocketDialerFunc func(\n\turl string, reqH http.Header,\n) (*websocket.Conn, *http.Response, error)\n\nfunc (f WebsocketDialerFunc) Dial(\n\turl string, reqH http.Header,\n) (*websocket.Conn, *http.Response, error) {\n\treturn f(url, reqH)\n}\n\n// Reporter is used to report failures.\n// *testing.T, FatalReporter, AssertReporter, RequireReporter, PanicReporter implement it.\ntype Reporter interface {\n\t// Errorf reports failure.\n\t// Allowed to return normally or terminate test using t.FailNow().\n\tErrorf(message string, args ...interface{})\n}\n\n// ReporterFunc is an adapter that allows a function to be used as the Reporter\n//\n// Example:\n//\n//\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\tReporter: httpextect.ReporterFunc(\n//\t\t\tfunc(message string, args ...interface{}) {\n//\t\t\t\t// reporter code here\n//\t\t\t}),\n//\t})\ntype ReporterFunc func(message string, args ...interface{})\n\nfunc (f ReporterFunc) Errorf(message string, args ...interface{}) {\n\tf(message, args)\n}\n\n// Logger is used as output backend for Printer.\n// *testing.T implements this interface.\ntype Logger interface {\n\t// Logf writes message to test log.\n\tLogf(fmt string, args ...interface{})\n}\n\n// LoggerFunc is an adapter that allows a function to be used as the Logger\n//\n// Example:\n//\n//\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\tPrinters: []httpexpect.Printer{\n//\t\t\thttpexpect.NewCompactPrinter(\n//\t\t\t\thttpextect.LoggerFunc(\n//\t\t\t\t\tfunc(fmt string, args ...interface{}) {\n//\t\t\t\t\t\t// logger code here\n//\t\t\t\t\t})),\n//\t\t},\n//\t})\ntype LoggerFunc func(fmt string, args ...interface{})\n\nfunc (f LoggerFunc) Logf(fmt string, args ...interface{}) {\n\tf(fmt, args)\n}\n\n// TestingTB is a subset of testing.TB interface used by httpexpect.\n// You can use *testing.T or pass custom implementation.\ntype TestingTB interface {\n\tReporter\n\tLogger\n\tName() string // Returns current test name.\n}\n\n// Deprecated: use TestingTB instead.\ntype LoggerReporter interface {\n\tLogger\n\tReporter\n}\n\n// Deprecated: use Default instead.\nfunc New(t LoggerReporter, baseURL string) *Expect {\n\treturn WithConfig(Config{\n\t\tBaseURL:  baseURL,\n\t\tReporter: NewAssertReporter(t),\n\t\tPrinters: []Printer{\n\t\t\tNewCompactPrinter(t),\n\t\t},\n\t})\n}\n\n// Default returns a new Expect instance with default config.\n//\n// t is usually *testing.T, but can be any matching implementation.\n//\n// baseURL specifies URL to be prepended to all requests. May be empty. If non-empty,\n// trailing slash is allowed (but not required) and is appended automatically.\n//\n// Default is a shorthand for WithConfig. It uses:\n//   - baseURL for Config.BaseURL\n//   - t.Name() for Config.TestName\n//   - NewAssertReporter(t) for Config.Reporter\n//   - NewCompactPrinter(t) for Config.Printers\n//\n// Example:\n//\n//\tfunc TestSomething(t *testing.T) {\n//\t\te := httpexpect.Default(t, \"http://example.com/\")\n//\n//\t\te.GET(\"/path\").\n//\t\t\tExpect().\n//\t\t\tStatus(http.StatusOK)\n//\t}\nfunc Default(t TestingTB, baseURL string) *Expect {\n\treturn WithConfig(Config{\n\t\tTestName: t.Name(),\n\t\tBaseURL:  baseURL,\n\t\tReporter: NewAssertReporter(t),\n\t\tPrinters: []Printer{\n\t\t\tNewCompactPrinter(t),\n\t\t},\n\t})\n}\n\n// WithConfig returns a new Expect instance with custom config.\n//\n// Either Reporter or AssertionHandler should not be nil,\n// otherwise the function panics.\n//\n// Example:\n//\n//\tfunc TestSomething(t *testing.T) {\n//\t\te := httpexpect.WithConfig(httpexpect.Config{\n//\t\t\tTestName: t.Name(),\n//\t\t\tBaseURL:  \"http://example.com/\",\n//\t\t\tClient:   &http.Client{\n//\t\t\t\tTransport: httpexpect.NewBinder(myHandler()),\n//\t\t\t\tJar:       httpexpect.NewCookieJar(),\n//\t\t\t},\n//\t\t\tReporter: httpexpect.NewAssertReporter(t),\n//\t\t\tPrinters: []httpexpect.Printer{\n//\t\t\t\thttpexpect.NewCurlPrinter(t),\n//\t\t\t\thttpexpect.NewDebugPrinter(t, true)\n//\t\t\t},\n//\t\t})\n//\n//\t\te.GET(\"/path\").\n//\t\t\tExpect().\n//\t\t\tStatus(http.StatusOK)\n//\t}\nfunc WithConfig(config Config) *Expect {\n\tconfig = config.withDefaults()\n\n\tconfig.validate()\n\n\treturn &Expect{\n\t\tchain:  newChainWithConfig(\"\", config),\n\t\tconfig: config,\n\t}\n}\n\n// Env returns Environment associated with Expect instance.\n// Tests can use it to store arbitrary data.\n//\n// Example:\n//\n//\te := httpexpect.Default(t, \"http://example.com\")\n//\n//\te.Env().Put(\"key\", \"value\")\n//\tvalue := e.Env().GetString(\"key\")\nfunc (e *Expect) Env() *Environment {\n\treturn e.chain.env()\n}\n\nfunc (e *Expect) clone() *Expect {\n\treturn &Expect{\n\t\tconfig:   e.config,\n\t\tchain:    e.chain.clone(),\n\t\tbuilders: append(([]func(*Request))(nil), e.builders...),\n\t\tmatchers: append(([]func(*Response))(nil), e.matchers...),\n\t}\n}\n\n// Builder returns a copy of Expect instance with given builder attached to it.\n// Returned copy contains all previously attached builders plus a new one.\n// Builders are invoked from Request method, after constructing every new request.\n//\n// Example:\n//\n//\te := httpexpect.Default(t, \"http://example.com\")\n//\n//\ttoken := e.POST(\"/login\").WithForm(Login{\"ford\", \"betelgeuse7\"}).\n//\t\tExpect().\n//\t\tStatus(http.StatusOK).JSON().Object().Value(\"token\").String().Raw()\n//\n//\tauth := e.Builder(func (req *httpexpect.Request) {\n//\t\treq.WithHeader(\"Authorization\", \"Bearer \"+token)\n//\t})\n//\n//\tauth.GET(\"/restricted\").\n//\t   Expect().\n//\t   Status(http.StatusOK)\nfunc (e *Expect) Builder(builder func(*Request)) *Expect {\n\tret := e.clone()\n\n\tret.builders = append(ret.builders, builder)\n\treturn ret\n}\n\n// Matcher returns a copy of Expect instance with given matcher attached to it.\n// Returned copy contains all previously attached matchers plus a new one.\n// Matchers are invoked from Request.Expect method, after retrieving a new response.\n//\n// Example:\n//\n//\t e := httpexpect.Default(t, \"http://example.com\")\n//\n//\t m := e.Matcher(func (resp *httpexpect.Response) {\n//\t\t resp.Header(\"API-Version\").NotEmpty()\n//\t })\n//\n//\t m.GET(\"/some-path\").\n//\t\t\tExpect().\n//\t\t\tStatus(http.StatusOK)\n//\n//\t m.GET(\"/bad-path\").\n//\t\t\tExpect().\n//\t\t\tStatus(http.StatusNotFound)\nfunc (e *Expect) Matcher(matcher func(*Response)) *Expect {\n\tret := e.clone()\n\n\tret.matchers = append(ret.matchers, matcher)\n\treturn ret\n}\n\n// Request returns a new Request instance.\n// Arguments are similar to NewRequest.\n// After creating request, all builders attached to Expect instance are invoked.\n// See Builder.\nfunc (e *Expect) Request(method, path string, pathargs ...interface{}) *Request {\n\topChain := e.chain.enter(\"Request(%q)\", method)\n\tdefer opChain.leave()\n\n\treq := newRequest(opChain, e.config, method, path, pathargs...)\n\n\tfor _, builder := range e.builders {\n\t\tbuilder(req)\n\t}\n\n\tfor _, matcher := range e.matchers {\n\t\treq.WithMatcher(matcher)\n\t}\n\n\treturn req\n}\n\n// OPTIONS is a shorthand for e.Request(\"OPTIONS\", path, pathargs...).\nfunc (e *Expect) OPTIONS(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodOptions, path, pathargs...)\n}\n\n// HEAD is a shorthand for e.Request(\"HEAD\", path, pathargs...).\nfunc (e *Expect) HEAD(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodHead, path, pathargs...)\n}\n\n// GET is a shorthand for e.Request(\"GET\", path, pathargs...).\nfunc (e *Expect) GET(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodGet, path, pathargs...)\n}\n\n// POST is a shorthand for e.Request(\"POST\", path, pathargs...).\nfunc (e *Expect) POST(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodPost, path, pathargs...)\n}\n\n// PUT is a shorthand for e.Request(\"PUT\", path, pathargs...).\nfunc (e *Expect) PUT(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodPut, path, pathargs...)\n}\n\n// PATCH is a shorthand for e.Request(\"PATCH\", path, pathargs...).\nfunc (e *Expect) PATCH(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodPatch, path, pathargs...)\n}\n\n// DELETE is a shorthand for e.Request(\"DELETE\", path, pathargs...).\nfunc (e *Expect) DELETE(path string, pathargs ...interface{}) *Request {\n\treturn e.Request(http.MethodDelete, path, pathargs...)\n}\n\n// Deprecated: use NewValue or NewValueC instead.\nfunc (e *Expect) Value(value interface{}) *Value {\n\topChain := e.chain.enter(\"Value()\")\n\tdefer opChain.leave()\n\n\treturn newValue(opChain, value)\n}\n\n// Deprecated: use NewObject or NewObjectC instead.\nfunc (e *Expect) Object(value map[string]interface{}) *Object {\n\topChain := e.chain.enter(\"Object()\")\n\tdefer opChain.leave()\n\n\treturn newObject(opChain, value)\n}\n\n// Deprecated: use NewArray or NewArrayC instead.\nfunc (e *Expect) Array(value []interface{}) *Array {\n\topChain := e.chain.enter(\"Array()\")\n\tdefer opChain.leave()\n\n\treturn newArray(opChain, value)\n}\n\n// Deprecated: use NewString or NewStringC instead.\nfunc (e *Expect) String(value string) *String {\n\topChain := e.chain.enter(\"String()\")\n\tdefer opChain.leave()\n\n\treturn newString(opChain, value)\n}\n\n// Deprecated: use NewNumber or NewNumberC instead.\nfunc (e *Expect) Number(value float64) *Number {\n\topChain := e.chain.enter(\"Number()\")\n\tdefer opChain.leave()\n\n\treturn newNumber(opChain, value)\n}\n\n// Deprecated: use NewBoolean or NewBooleanC instead.\nfunc (e *Expect) Boolean(value bool) *Boolean {\n\topChain := e.chain.enter(\"Boolean()\")\n\tdefer opChain.leave()\n\n\treturn newBoolean(opChain, value)\n}\n"
        },
        {
          "name": "expect_test.go",
          "type": "blob",
          "size": 18.8525390625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestExpect_Constructors(t *testing.T) {\n\tt.Run(\"testing.T\", func(t *testing.T) {\n\t\t_ = Default(&testing.T{}, \"\")\n\t})\n\n\tt.Run(\"testing.B\", func(t *testing.T) {\n\t\t_ = Default(&testing.B{}, \"\")\n\t})\n\n\tt.Run(\"testing.TB\", func(t *testing.T) {\n\t\t_ = Default(testing.TB(&testing.T{}), \"\")\n\t})\n}\n\nfunc TestExpect_Requests(t *testing.T) {\n\tclient := &mockClient{}\n\n\treporter := NewAssertReporter(t)\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com\",\n\t\tClient:   client,\n\t\tReporter: reporter,\n\t}\n\n\tvar reqs [8]*Request\n\n\te := WithConfig(config)\n\n\treqs[0] = e.Request(\"GET\", \"/url\")\n\treqs[1] = e.OPTIONS(\"/url\")\n\treqs[2] = e.HEAD(\"/url\")\n\treqs[3] = e.GET(\"/url\")\n\treqs[4] = e.POST(\"/url\")\n\treqs[5] = e.PUT(\"/url\")\n\treqs[6] = e.PATCH(\"/url\")\n\treqs[7] = e.DELETE(\"/url\")\n\n\tassert.Equal(t, \"GET\", reqs[0].httpReq.Method)\n\tassert.Equal(t, \"OPTIONS\", reqs[1].httpReq.Method)\n\tassert.Equal(t, \"HEAD\", reqs[2].httpReq.Method)\n\tassert.Equal(t, \"GET\", reqs[3].httpReq.Method)\n\tassert.Equal(t, \"POST\", reqs[4].httpReq.Method)\n\tassert.Equal(t, \"PUT\", reqs[5].httpReq.Method)\n\tassert.Equal(t, \"PATCH\", reqs[6].httpReq.Method)\n\tassert.Equal(t, \"DELETE\", reqs[7].httpReq.Method)\n}\n\nfunc TestExpect_Builders(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\treporter := NewAssertReporter(t)\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\te := WithConfig(config)\n\n\t\tvar reqs1 []*Request\n\n\t\te1 := e.Builder(func(r *Request) {\n\t\t\treqs1 = append(reqs1, r)\n\t\t})\n\n\t\tvar reqs2 []*Request\n\n\t\te2 := e1.Builder(func(r *Request) {\n\t\t\treqs2 = append(reqs2, r)\n\t\t})\n\n\t\te.Request(\"GET\", \"/url\")\n\n\t\tr1 := e1.Request(\"GET\", \"/url\")\n\t\tr2 := e2.Request(\"GET\", \"/url\")\n\n\t\tassert.Equal(t, 2, len(reqs1))\n\t\tassert.Equal(t, 1, len(reqs2))\n\n\t\tassert.Same(t, r1, reqs1[0])\n\t\tassert.Same(t, r2, reqs1[1])\n\t\tassert.Same(t, r2, reqs2[0])\n\t})\n\n\tt.Run(\"copying\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\treporter := NewAssertReporter(t)\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\tcounter1 := 0\n\t\tcounter2a := 0\n\t\tcounter2b := 0\n\n\t\te0 := WithConfig(config)\n\n\t\t// Simulate the case when many builders are added, and the builders slice\n\t\t// have some additioonal capacity. We are going to check that the slice\n\t\t// is cloned properly when a new builder is appended.\n\t\tfor i := 0; i < 10; i++ {\n\t\t\te0 = e0.Builder(func(r *Request) {})\n\t\t}\n\n\t\te1 := e0.Builder(func(r *Request) {\n\t\t\tcounter1++\n\t\t})\n\n\t\te2a := e1.Builder(func(r *Request) {\n\t\t\tcounter2a++\n\t\t})\n\n\t\te2b := e1.Builder(func(r *Request) {\n\t\t\tcounter2b++\n\t\t})\n\n\t\te0.Request(\"GET\", \"/url\")\n\t\tassert.Equal(t, 0, counter1)\n\t\tassert.Equal(t, 0, counter2a)\n\t\tassert.Equal(t, 0, counter2b)\n\n\t\te1.Request(\"GET\", \"/url\")\n\t\tassert.Equal(t, 1, counter1)\n\t\tassert.Equal(t, 0, counter2a)\n\t\tassert.Equal(t, 0, counter2b)\n\n\t\te2a.Request(\"GET\", \"/url\")\n\t\tassert.Equal(t, 2, counter1)\n\t\tassert.Equal(t, 1, counter2a)\n\t\tassert.Equal(t, 0, counter2b)\n\n\t\te2b.Request(\"GET\", \"/url\")\n\t\tassert.Equal(t, 3, counter1)\n\t\tassert.Equal(t, 1, counter2a)\n\t\tassert.Equal(t, 1, counter2b)\n\t})\n}\n\nfunc TestExpect_Matchers(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\treporter := NewAssertReporter(t)\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\te := WithConfig(config)\n\n\t\tvar resps1 []*Response\n\n\t\te1 := e.Matcher(func(r *Response) {\n\t\t\tresps1 = append(resps1, r)\n\t\t})\n\n\t\tvar resps2 []*Response\n\n\t\te2 := e1.Matcher(func(r *Response) {\n\t\t\tresps2 = append(resps2, r)\n\t\t})\n\n\t\te.Request(\"GET\", \"/url\")\n\n\t\treq1 := e1.Request(\"GET\", \"/url\")\n\t\treq2 := e2.Request(\"GET\", \"/url\")\n\n\t\tassert.Equal(t, 0, len(resps1))\n\t\tassert.Equal(t, 0, len(resps2))\n\n\t\tresp1 := req1.Expect()\n\t\tresp2 := req2.Expect()\n\n\t\tassert.Equal(t, 2, len(resps1))\n\t\tassert.Equal(t, 1, len(resps2))\n\n\t\tassert.Same(t, resp1, resps1[0])\n\t\tassert.Same(t, resp2, resps1[1])\n\t\tassert.Same(t, resp2, resps2[0])\n\t})\n\n\tt.Run(\"copying\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\treporter := NewAssertReporter(t)\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\tcounter1 := 0\n\t\tcounter2a := 0\n\t\tcounter2b := 0\n\n\t\te0 := WithConfig(config)\n\n\t\t// Simulate the case when many builders are added, and the builders slice\n\t\t// have some additioonal capacity. We are going to check that the slice\n\t\t// is cloned properly when a new builder is appended.\n\t\tfor i := 0; i < 10; i++ {\n\t\t\te0 = e0.Matcher(func(r *Response) {})\n\t\t}\n\n\t\te1 := e0.Matcher(func(r *Response) {\n\t\t\tcounter1++\n\t\t})\n\n\t\te2a := e1.Matcher(func(r *Response) {\n\t\t\tcounter2a++\n\t\t})\n\n\t\te2b := e1.Matcher(func(r *Response) {\n\t\t\tcounter2b++\n\t\t})\n\n\t\te0.Request(\"GET\", \"/url\").Expect()\n\t\tassert.Equal(t, 0, counter1)\n\t\tassert.Equal(t, 0, counter2a)\n\t\tassert.Equal(t, 0, counter2b)\n\n\t\te1.Request(\"GET\", \"/url\").Expect()\n\t\tassert.Equal(t, 1, counter1)\n\t\tassert.Equal(t, 0, counter2a)\n\t\tassert.Equal(t, 0, counter2b)\n\n\t\te2a.Request(\"GET\", \"/url\").Expect()\n\t\tassert.Equal(t, 2, counter1)\n\t\tassert.Equal(t, 1, counter2a)\n\t\tassert.Equal(t, 0, counter2b)\n\n\t\te2b.Request(\"GET\", \"/url\").Expect()\n\t\tassert.Equal(t, 3, counter1)\n\t\tassert.Equal(t, 1, counter2a)\n\t\tassert.Equal(t, 1, counter2b)\n\t})\n}\n\nfunc TestExpect_Traverse(t *testing.T) {\n\tclient := &mockClient{}\n\n\treporter := NewAssertReporter(t)\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com\",\n\t\tClient:   client,\n\t\tReporter: reporter,\n\t}\n\n\tdata := map[string]interface{}{\n\t\t\"aaa\": []interface{}{\"bbb\", 123, false, nil},\n\t\t\"bbb\": \"hello\",\n\t\t\"ccc\": 456,\n\t}\n\n\tresp := WithConfig(config).GET(\"/url\").WithJSON(data).Expect()\n\n\tm := resp.JSON().Object()\n\n\tm.IsEqual(data)\n\n\tm.ContainsKey(\"aaa\")\n\tm.ContainsKey(\"bbb\")\n\tm.ContainsKey(\"aaa\")\n\n\tm.HasValue(\"aaa\", data[\"aaa\"])\n\tm.HasValue(\"bbb\", data[\"bbb\"])\n\tm.HasValue(\"ccc\", data[\"ccc\"])\n\n\tm.Keys().ConsistsOf(\"aaa\", \"bbb\", \"ccc\")\n\tm.Values().ConsistsOf(data[\"aaa\"], data[\"bbb\"], data[\"ccc\"])\n\n\tm.Value(\"aaa\").Array().ConsistsOf(\"bbb\", 123, false, nil)\n\tm.Value(\"bbb\").String().IsEqual(\"hello\")\n\tm.Value(\"ccc\").Number().IsEqual(456)\n\n\tm.Value(\"aaa\").Array().Value(2).Boolean().IsFalse()\n\tm.Value(\"aaa\").Array().Value(3).IsNull()\n}\n\nfunc TestExpect_Branches(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com\",\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tdata := map[string]interface{}{\n\t\t\"foo\": []interface{}{\"bar\", 123, false, nil},\n\t\t\"bar\": \"hello\",\n\t\t\"baz\": 456,\n\t}\n\n\treq := WithConfig(config).GET(\"/url\").WithJSON(data)\n\tresp := req.Expect()\n\n\tm1 := resp.JSON().Array()  // fail\n\tm2 := resp.JSON().Object() // ok\n\tm3 := resp.JSON().Object() // ok\n\n\te1 := m2.Value(\"foo\").Object()                    // fail\n\te2 := m2.Value(\"foo\").Array().Value(999).String() // fail\n\te3 := m2.Value(\"foo\").Array().Value(0).Number()   // fail\n\te4 := m2.Value(\"foo\").Array().Value(0).String()   // ok\n\te5 := m2.Value(\"foo\").Array().Value(0).String()   // ok\n\n\te4.IsEqual(\"qux\") // fail\n\te5.IsEqual(\"bar\") // ok\n\n\treq.chain.assertFlags(t, flagFailedChildren)\n\tresp.chain.assertFlags(t, flagFailedChildren)\n\n\tm1.chain.assertFlags(t, flagFailed)\n\tm2.chain.assertFlags(t, flagFailedChildren)\n\tm3.chain.assertFlags(t, 0)\n\n\te1.chain.assertFlags(t, flagFailed)\n\te2.chain.assertFlags(t, flagFailed)\n\te3.chain.assertFlags(t, flagFailed)\n\te4.chain.assertFlags(t, flagFailed)\n\te5.chain.assertFlags(t, 0)\n}\n\nfunc TestExpect_Propagation(t *testing.T) {\n\tt.Run(\"subsequent operations\", func(t *testing.T) {\n\t\tctr := 0\n\t\treporter := newMockReporter(t)\n\t\treporter.reportCb = func() {\n\t\t\tctr++\n\t\t}\n\n\t\t// Failed operation\n\t\tvalue := NewArray(reporter, []interface{}{\"foo\"})\n\t\tvalue.IsEmpty()\n\t\tvalue.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 1, ctr)\n\n\t\t// Subsequent failed operation won't report failures\n\t\tvalue.IsEmpty()\n\t\tvalue.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 1, ctr)\n\t})\n\n\tt.Run(\"newly created child\", func(t *testing.T) {\n\t\tctr := 0\n\t\treporter := newMockReporter(t)\n\t\treporter.reportCb = func() {\n\t\t\tctr++\n\t\t}\n\n\t\t// Parent's failed operation reports failure\n\t\tparent := NewArray(reporter, []interface{}{\"foo\"})\n\t\tparent.IsEmpty()\n\t\tparent.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 1, ctr)\n\n\t\t// Child created after parent's failure\n\t\t// Child's failed operation won't report failures\n\t\tchild := parent.Value(0)\n\t\tchild.IsEqual(\"bar\")\n\t\tparent.chain.assertFlags(t, flagFailed|flagFailedChildren)\n\t\tchild.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 1, ctr)\n\t})\n\n\tt.Run(\"previously created child\", func(t *testing.T) {\n\t\tctr := 0\n\t\treporter := newMockReporter(t)\n\t\treporter.reportCb = func() {\n\t\t\tctr++\n\t\t}\n\n\t\t// Parent and child\n\t\tparent := NewArray(reporter, []interface{}{\"foo\"})\n\t\tchild := parent.Value(0)\n\n\t\t// Parent's failed operation reports failure\n\t\tparent.IsEmpty()\n\t\tparent.chain.assertFlags(t, flagFailed)\n\t\tchild.chain.assertFlags(t, 0)\n\t\tassert.Equal(t, 1, ctr)\n\n\t\t// Child was created before parent's failure\n\t\t// Child's failed operation will report failures\n\t\tchild.IsEqual(\"bar\")\n\t\tparent.chain.assertFlags(t, flagFailed|flagFailedChildren)\n\t\tchild.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 2, ctr)\n\t})\n\n\tt.Run(\"newly created child of parent\", func(t *testing.T) {\n\t\tctr := 0\n\t\treporter := newMockReporter(t)\n\t\treporter.reportCb = func() {\n\t\t\tctr++\n\t\t}\n\n\t\t// Parent\n\t\tparent := NewArray(reporter, []interface{}{\"foo\"})\n\n\t\t// Child's failed operation will report failures\n\t\tchild := parent.Value(0)\n\t\tchild.IsEqual(\"bar\")\n\t\tparent.chain.assertFlags(t, flagFailedChildren)\n\t\tchild.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 1, ctr)\n\n\t\t// New child created after failure in another child\n\t\t// New child's failed operation will report failures\n\t\tnewChild := parent.Value(0)\n\t\tnewChild.IsEqual(\"bar\")\n\t\tparent.chain.assertFlags(t, flagFailedChildren)\n\t\tchild.chain.assertFlags(t, flagFailed)\n\t\tnewChild.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 2, ctr)\n\t})\n\n\tt.Run(\"previously created child of parent\", func(t *testing.T) {\n\t\tctr := 0\n\t\treporter := newMockReporter(t)\n\t\treporter.reportCb = func() {\n\t\t\tctr++\n\t\t}\n\n\t\t// Parent\n\t\tparent := NewArray(reporter, []interface{}{\"foo\"})\n\n\t\t// Children\n\t\tchild1 := parent.Value(0)\n\t\tchild2 := parent.Value(0)\n\n\t\t// child1's failed operation will report failures\n\t\tchild1.IsEqual(\"bar\")\n\t\tparent.chain.assertFlags(t, flagFailedChildren)\n\t\tchild1.chain.assertFlags(t, flagFailed)\n\t\tchild2.chain.assertFlags(t, 0)\n\t\tassert.Equal(t, 1, ctr)\n\n\t\t// child2's failed operation will report failures\n\t\tchild2.IsEqual(\"bar\")\n\t\tparent.chain.assertFlags(t, flagFailedChildren)\n\t\tchild1.chain.assertFlags(t, flagFailed)\n\t\tchild2.chain.assertFlags(t, flagFailed)\n\t\tassert.Equal(t, 2, ctr)\n\t})\n}\n\nfunc TestExpect_Inheritance(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\trootReporter := newMockReporter(t)\n\t\treq2Reporter := newMockReporter(t)\n\n\t\te := WithConfig(Config{\n\t\t\tBaseURL:  \"http://example.com\",\n\t\t\tClient:   &mockClient{},\n\t\t\tReporter: rootReporter,\n\t\t})\n\n\t\treq1 := e.GET(\"/\")\n\t\treq2 := e.GET(\"/\")\n\n\t\treq2.WithReporter(req2Reporter)\n\n\t\t// So far OK\n\t\treq1.chain.assert(t, success)\n\t\treq2.chain.assert(t, success)\n\n\t\tresp1 := req1.Expect()\n\t\tresp2 := req2.Expect()\n\n\t\t// So far OK\n\t\tresp1.chain.assert(t, success)\n\t\tresp2.chain.assert(t, success)\n\n\t\t// Failure on resp1 should be reported to rootReporter,\n\t\t// which was inherited from config\n\t\tresp1.JSON().Object().Value(\"foo\").chain.assert(t, failure)\n\t\tassert.Equal(t, 1, rootReporter.reportCalled)\n\t\tassert.Equal(t, 0, req2Reporter.reportCalled)\n\n\t\t// Failure on resp2 should be reported to req2Reporter,\n\t\t// which was inherited from req2\n\t\tresp2.JSON().Object().Value(\"foo\").chain.assert(t, failure)\n\t\tassert.Equal(t, 1, rootReporter.reportCalled)\n\t\tassert.Equal(t, 1, req2Reporter.reportCalled)\n\t})\n\n\tt.Run(\"assertion handler\", func(t *testing.T) {\n\t\trootHandler := &mockAssertionHandler{}\n\t\treq2Handler := &mockAssertionHandler{}\n\n\t\te := WithConfig(Config{\n\t\t\tBaseURL:          \"http://example.com\",\n\t\t\tClient:           &mockClient{},\n\t\t\tAssertionHandler: rootHandler,\n\t\t})\n\n\t\treq1 := e.GET(\"/\")\n\t\treq2 := e.GET(\"/\")\n\n\t\treq2.WithAssertionHandler(req2Handler)\n\n\t\t// So far OK\n\t\treq1.chain.assert(t, success)\n\t\treq2.chain.assert(t, success)\n\n\t\tresp1 := req1.Expect()\n\t\tresp2 := req2.Expect()\n\n\t\t// So far OK\n\t\tresp1.chain.assert(t, success)\n\t\tresp2.chain.assert(t, success)\n\n\t\t// Failure on resp1 should be reported to rootReporter,\n\t\t// which was inherited from config\n\t\tresp1.JSON().Object().Value(\"foo\").chain.assert(t, failure)\n\t\tassert.Equal(t, 1, rootHandler.failureCalled)\n\t\tassert.Equal(t, 0, req2Handler.failureCalled)\n\n\t\t// Failure on resp2 should be reported to req2Reporter,\n\t\t// which was inherited from req2\n\t\tresp2.JSON().Object().Value(\"foo\").chain.assert(t, failure)\n\t\tassert.Equal(t, 1, rootHandler.failureCalled)\n\t\tassert.Equal(t, 1, req2Handler.failureCalled)\n\t})\n}\n\nfunc TestExpect_RequestFactory(t *testing.T) {\n\tt.Run(\"default factory\", func(t *testing.T) {\n\t\te := WithConfig(Config{\n\t\t\tBaseURL:  \"http://example.com\",\n\t\t\tReporter: NewAssertReporter(t),\n\t\t})\n\n\t\treq := e.Request(\"GET\", \"/\")\n\t\treq.chain.assert(t, success)\n\n\t\tassert.NotNil(t, req.httpReq)\n\t})\n\n\tt.Run(\"custom factory\", func(t *testing.T) {\n\t\tfactory := &mockRequestFactory{}\n\n\t\te := WithConfig(Config{\n\t\t\tBaseURL:        \"http://example.com\",\n\t\t\tReporter:       NewAssertReporter(t),\n\t\t\tRequestFactory: factory,\n\t\t})\n\n\t\treq := e.Request(\"GET\", \"/\")\n\t\treq.chain.assert(t, success)\n\n\t\tassert.NotNil(t, factory.lastreq)\n\t\tassert.Same(t, req.httpReq, factory.lastreq)\n\t})\n\n\tt.Run(\"factory failure\", func(t *testing.T) {\n\t\tfactory := &mockRequestFactory{\n\t\t\tfail: true,\n\t\t}\n\n\t\te := WithConfig(Config{\n\t\t\tBaseURL:        \"http://example.com\",\n\t\t\tReporter:       newMockReporter(t),\n\t\t\tRequestFactory: factory,\n\t\t})\n\n\t\treq := e.Request(\"GET\", \"/\")\n\t\treq.chain.assert(t, failure)\n\n\t\tassert.Nil(t, factory.lastreq)\n\t})\n}\n\nfunc TestExpect_Panics(t *testing.T) {\n\tt.Run(\"nil AssertionHandler, non-nil Reporter\", func(t *testing.T) {\n\t\tassert.NotPanics(t, func() {\n\t\t\tWithConfig(Config{\n\t\t\t\tReporter:         newMockReporter(t),\n\t\t\t\tAssertionHandler: nil,\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"non-nil AssertionHandler, nil Reporter\", func(t *testing.T) {\n\t\tassert.NotPanics(t, func() {\n\t\t\tWithConfig(Config{\n\t\t\t\tReporter:         nil,\n\t\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t\t})\n\t\t})\n\t})\n\n\tt.Run(\"nil AssertionHandler, nil Reporter\", func(t *testing.T) {\n\t\tassert.Panics(t, func() {\n\t\t\tWithConfig(Config{\n\t\t\t\tReporter:         nil,\n\t\t\t\tAssertionHandler: nil,\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunc TestExpect_Config(t *testing.T) {\n\tt.Run(\"defaults, non-nil Reporter\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\tconfig = config.withDefaults()\n\n\t\tassert.NotNil(t, config.RequestFactory)\n\t\tassert.NotNil(t, config.Client)\n\t\tassert.NotNil(t, config.WebsocketDialer)\n\t\tassert.NotNil(t, config.AssertionHandler)\n\t\tassert.NotNil(t, config.Formatter)\n\t\tassert.NotNil(t, config.Reporter)\n\n\t\tassert.NotPanics(t, func() {\n\t\t\tconfig.validate()\n\t\t})\n\t})\n\n\tt.Run(\"defaults, non-nil AssertionHandler\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t}\n\n\t\tconfig = config.withDefaults()\n\n\t\tassert.NotNil(t, config.RequestFactory)\n\t\tassert.NotNil(t, config.Client)\n\t\tassert.NotNil(t, config.WebsocketDialer)\n\t\tassert.NotNil(t, config.AssertionHandler)\n\t\tassert.Nil(t, config.Formatter)\n\t\tassert.Nil(t, config.Reporter)\n\n\t\tassert.NotPanics(t, func() {\n\t\t\tconfig.validate()\n\t\t})\n\t})\n\n\tt.Run(\"defaults, nil Reporter and AssertionHandler\", func(t *testing.T) {\n\t\tconfig := Config{}\n\n\t\tassert.Panics(t, func() {\n\t\t\tconfig.withDefaults()\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tconfig.validate()\n\t\t})\n\t})\n\n\tt.Run(\"validate fields\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\tconfig = config.withDefaults()\n\n\t\tassert.NotPanics(t, func() {\n\t\t\tconfig.validate()\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tbadConfig := config\n\t\t\tbadConfig.RequestFactory = nil\n\t\t\tbadConfig.validate()\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tbadConfig := config\n\t\t\tbadConfig.Client = nil\n\t\t\tbadConfig.validate()\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tbadConfig := config\n\t\t\tbadConfig.AssertionHandler = nil\n\t\t\tbadConfig.validate()\n\t\t})\n\t})\n\n\tt.Run(\"validate handler\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\tconfig = config.withDefaults()\n\n\t\tassert.NotPanics(t, func() {\n\t\t\tbadConfig := config\n\t\t\tbadConfig.AssertionHandler = &DefaultAssertionHandler{\n\t\t\t\tFormatter: &DefaultFormatter{},\n\t\t\t\tReporter:  newMockReporter(t),\n\t\t\t}\n\t\t\tbadConfig.validate()\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tbadConfig := config\n\t\t\tbadConfig.AssertionHandler = &DefaultAssertionHandler{\n\t\t\t\tFormatter: &DefaultFormatter{},\n\t\t\t\tReporter:  nil,\n\t\t\t}\n\t\t\tbadConfig.validate()\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tbadConfig := config\n\t\t\tbadConfig.AssertionHandler = &DefaultAssertionHandler{\n\t\t\t\tFormatter: nil,\n\t\t\t\tReporter:  newMockReporter(t),\n\t\t\t}\n\t\t\tbadConfig.validate()\n\t\t})\n\t})\n}\n\nfunc TestExpect_Adapters(t *testing.T) {\n\tt.Run(\"RequestFactoryFunc\", func(t *testing.T) {\n\t\tcalled := false\n\t\tfactory := RequestFactoryFunc(func(\n\t\t\t_ string, _ string, _ io.Reader,\n\t\t) (*http.Request, error) {\n\t\t\tcalled = true\n\t\t\treturn nil, nil\n\t\t})\n\n\t\te := WithConfig(Config{\n\t\t\tRequestFactory: factory,\n\t\t\tReporter:       newMockReporter(t),\n\t\t})\n\n\t\te.Request(\"GET\", \"/\")\n\n\t\tassert.True(t, called)\n\t})\n\n\tt.Run(\"ClientFunc\", func(t *testing.T) {\n\t\tcalled := false\n\t\tclient := ClientFunc(func(_ *http.Request) (*http.Response, error) {\n\t\t\tcalled = true\n\t\t\treturn &http.Response{\n\t\t\t\tStatus:     \"Test Status\",\n\t\t\t\tStatusCode: 504,\n\t\t\t}, nil\n\t\t})\n\n\t\te := WithConfig(Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t})\n\n\t\treq := e.GET(\"/\")\n\t\tresp := req.Expect()\n\n\t\tassert.True(t, called)\n\t\tassert.Equal(t, resp.httpResp.StatusCode, 504)\n\t\tassert.Equal(t, resp.httpResp.Status, \"Test Status\")\n\t})\n\n\tt.Run(\"WebsocketDialerFunc\", func(t *testing.T) {\n\t\tcalled := false\n\t\tdialer := WebsocketDialerFunc(func(\n\t\t\t_ string, _ http.Header,\n\t\t) (*websocket.Conn, *http.Response, error) {\n\t\t\tcalled = true\n\t\t\treturn &websocket.Conn{}, &http.Response{}, nil\n\t\t})\n\n\t\te := WithConfig(Config{\n\t\t\tWebsocketDialer: dialer,\n\t\t\tReporter:        newMockReporter(t),\n\t\t})\n\n\t\te.GET(\"/path\").WithWebsocketUpgrade().Expect().Websocket()\n\n\t\tassert.True(t, called)\n\t})\n\n\tt.Run(\"ReporterFunc\", func(t *testing.T) {\n\t\tcalled := false\n\t\tmessage := \"\"\n\t\tclient := ClientFunc(func(r *http.Request) (*http.Response, error) {\n\t\t\treturn nil, errors.New(\"\")\n\t\t})\n\t\treporter := ReporterFunc(func(_ string, _ ...interface{}) {\n\t\t\tcalled = true\n\t\t\tmessage = \"test reporter called\"\n\t\t})\n\n\t\te := WithConfig(Config{\n\t\t\tReporter: reporter,\n\t\t\tClient:   client,\n\t\t})\n\n\t\te.GET(\"/\").Expect()\n\n\t\tassert.True(t, called)\n\t\tassert.Contains(t, message, \"test reporter called\")\n\t})\n\n\tt.Run(\"LoggerFunc\", func(t *testing.T) {\n\t\tcalled := false\n\t\tmessage := \"\"\n\t\tlogger := LoggerFunc(func(_ string, _ ...interface{}) {\n\t\t\tcalled = true\n\t\t\tmessage = \"test logger called\"\n\t\t})\n\n\t\te := WithConfig(Config{\n\t\t\tReporter: newMockReporter(t),\n\t\t\tPrinters: []Printer{\n\t\t\t\tNewCompactPrinter(logger),\n\t\t\t},\n\t\t})\n\n\t\te.GET(\"\").Expect()\n\n\t\tassert.True(t, called)\n\t\tassert.Contains(t, message, \"test logger called\")\n\t})\n}\n"
        },
        {
          "name": "formatter.go",
          "type": "blob",
          "size": 26.5849609375,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"text/template\"\n\n\t\"github.com/TylerBrock/colorjson\"\n\t\"github.com/fatih/color\"\n\t\"github.com/mattn/go-isatty\"\n\t\"github.com/mitchellh/go-wordwrap\"\n\t\"github.com/sanity-io/litter\"\n\t\"github.com/yudai/gojsondiff\"\n\t\"github.com/yudai/gojsondiff/formatter\"\n)\n\n// Formatter is used to format assertion messages into strings.\ntype Formatter interface {\n\tFormatSuccess(*AssertionContext) string\n\tFormatFailure(*AssertionContext, *AssertionFailure) string\n}\n\n// DefaultFormatter is the default Formatter implementation.\n//\n// DefaultFormatter gathers values from AssertionContext and AssertionFailure,\n// converts them to strings, and creates FormatData struct. Then it passes\n// FormatData to the template engine (text/template) to format message.\n//\n// You can control what is included and what is excluded from messages via\n// several public fields.\n//\n// If desired, you can provide custom templates and function map. This may\n// be easier than creating your own formatter from scratch.\ntype DefaultFormatter struct {\n\t// Exclude test name and request name from failure report.\n\tDisableNames bool\n\n\t// Exclude assertion path from failure report.\n\tDisablePaths bool\n\n\t// Exclude aliased assertion path from failure report.\n\tDisableAliases bool\n\n\t// Exclude diff from failure report.\n\tDisableDiffs bool\n\n\t// Exclude HTTP request from failure report.\n\tDisableRequests bool\n\n\t// Exclude HTTP response from failure report.\n\tDisableResponses bool\n\n\t// Thousand separator.\n\t// Default is DigitSeparatorUnderscore.\n\tDigitSeparator DigitSeparator\n\n\t// Float printing format.\n\t// Default is FloatFormatAuto.\n\tFloatFormat FloatFormat\n\n\t// Defines whether to print stacktrace on failure and in what format.\n\t// Default is StacktraceModeDisabled.\n\tStacktraceMode StacktraceMode\n\n\t// Colorization mode.\n\t// Default is ColorModeAuto.\n\tColorMode ColorMode\n\n\t// Wrap text to keep lines below given width.\n\t// Use zero for default width, and negative value to disable wrapping.\n\tLineWidth int\n\n\t// If not empty, used to format success messages.\n\t// If empty, default template is used.\n\tSuccessTemplate string\n\n\t// If not empty, used to format failure messages.\n\t// If empty, default template is used.\n\tFailureTemplate string\n\n\t// When SuccessTemplate or FailureTemplate is set, this field\n\t// defines the function map passed to template engine.\n\t// May be nil.\n\tTemplateFuncs template.FuncMap\n}\n\n// FormatSuccess implements Formatter.FormatSuccess.\nfunc (f *DefaultFormatter) FormatSuccess(ctx *AssertionContext) string {\n\tif f.SuccessTemplate != \"\" {\n\t\treturn f.applyTemplate(\"SuccessTemplate\",\n\t\t\tf.SuccessTemplate, f.TemplateFuncs, ctx, nil)\n\t} else {\n\t\treturn f.applyTemplate(\"SuccessTemplate\",\n\t\t\tdefaultSuccessTemplate, defaultTemplateFuncs, ctx, nil)\n\t}\n}\n\n// FormatFailure implements Formatter.FormatFailure.\nfunc (f *DefaultFormatter) FormatFailure(\n\tctx *AssertionContext, failure *AssertionFailure,\n) string {\n\tif f.FailureTemplate != \"\" {\n\t\treturn f.applyTemplate(\"FailureTemplate\",\n\t\t\tf.FailureTemplate, f.TemplateFuncs, ctx, failure)\n\t} else {\n\t\treturn f.applyTemplate(\"FailureTemplate\",\n\t\t\tdefaultFailureTemplate, defaultTemplateFuncs, ctx, failure)\n\t}\n}\n\n// DigitSeparator defines the separator used to format integers and floats.\ntype DigitSeparator int\n\nconst (\n\t// Separate using underscore\n\tDigitSeparatorUnderscore DigitSeparator = iota\n\n\t// Separate using comma\n\tDigitSeparatorComma\n\n\t// Separate using apostrophe\n\tDigitSeparatorApostrophe\n\n\t// Do not separate\n\tDigitSeparatorNone\n)\n\n// FloatFormat defines the format in which all floats are printed.\ntype FloatFormat int\n\nconst (\n\t// Print floats in scientific notation for large exponents,\n\t// otherwise print in decimal notation.\n\t// Precision is the smallest needed to identify the value uniquely.\n\t// Similar to %g format.\n\tFloatFormatAuto FloatFormat = iota\n\n\t// Always print floats in decimal notation.\n\t// Precision is the smallest needed to identify the value uniquely.\n\t// Similar to %f format.\n\tFloatFormatDecimal\n\n\t// Always print floats in scientific notation.\n\t// Precision is the smallest needed to identify the value uniquely.\n\t// Similar to %e format.\n\tFloatFormatScientific\n)\n\n// StacktraceMode defines the format of stacktrace.\ntype StacktraceMode int\n\nconst (\n\t// Don't print stacktrace.\n\tStacktraceModeDisabled StacktraceMode = iota\n\n\t// Standard, verbose format.\n\tStacktraceModeStandard\n\n\t// Compact format.\n\tStacktraceModeCompact\n)\n\n// ColorMode defines how the text color is enabled.\ntype ColorMode int\n\nconst (\n\t// Automatically enable colors if ALL of the following is true:\n\t//  - stdout is a tty / console\n\t//  - AssertionHandler is known to output to testing.T\n\t//  - testing.Verbose() is true\n\t//\n\t// Colors are forcibly enabled if FORCE_COLOR environment variable\n\t// is set to a positive integer.\n\t//\n\t// Colors are forcibly disabled if TERM is \"dumb\" or NO_COLOR\n\t// environment variable is set to non-empty string.\n\tColorModeAuto ColorMode = iota\n\n\t// Unconditionally enable colors.\n\tColorModeAlways\n\n\t// Unconditionally disable colors.\n\tColorModeNever\n)\n\n// FormatData defines data passed to template engine when DefaultFormatter\n// formats assertion. You can use these fields in your custom templates.\ntype FormatData struct {\n\tTestName    string\n\tRequestName string\n\n\tAssertPath     []string\n\tAssertType     string\n\tAssertSeverity string\n\n\tErrors []string\n\n\tHaveActual bool\n\tActual     string\n\n\tHaveExpected bool\n\tIsNegation   bool\n\tIsComparison bool\n\tExpectedKind string\n\tExpected     []string\n\n\tHaveReference bool\n\tReference     string\n\n\tHaveDelta bool\n\tDelta     string\n\n\tHaveDiff bool\n\tDiff     string\n\n\tHaveRequest bool\n\tRequest     string\n\n\tHaveResponse bool\n\tResponse     string\n\n\tHaveStacktrace bool\n\tStacktrace     []string\n\n\tEnableColors bool\n\tLineWidth    int\n}\n\nconst (\n\tkindRange      = \"range\"\n\tkindSchema     = \"schema\"\n\tkindPath       = \"path\"\n\tkindRegexp     = \"regexp\"\n\tkindFormat     = \"format\"\n\tkindFormatList = \"formats\"\n\tkindKey        = \"key\"\n\tkindElement    = \"element\"\n\tkindSubset     = \"subset\"\n\tkindValue      = \"value\"\n\tkindValueList  = \"values\"\n)\n\nfunc (f *DefaultFormatter) applyTemplate(\n\ttemplateName string,\n\ttemplateString string,\n\ttemplateFuncs template.FuncMap,\n\tctx *AssertionContext,\n\tfailure *AssertionFailure,\n) string {\n\ttemplateData := f.buildFormatData(ctx, failure)\n\n\tt, err := template.New(templateName).Funcs(templateFuncs).Parse(templateString)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar b bytes.Buffer\n\n\terr = t.Execute(&b, templateData)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn b.String()\n}\n\nfunc (f *DefaultFormatter) buildFormatData(\n\tctx *AssertionContext, failure *AssertionFailure,\n) *FormatData {\n\tdata := FormatData{}\n\n\tf.fillGeneral(&data, ctx)\n\n\tif failure != nil {\n\t\tdata.AssertType = failure.Type.String()\n\t\tdata.AssertSeverity = failure.Severity.String()\n\n\t\tf.fillErrors(&data, ctx, failure)\n\n\t\tif failure.Actual != nil {\n\t\t\tf.fillActual(&data, ctx, failure)\n\t\t}\n\n\t\tif failure.Expected != nil {\n\t\t\tf.fillExpected(&data, ctx, failure)\n\t\t\tf.fillIsNegation(&data, ctx, failure)\n\t\t\tf.fillIsComparison(&data, ctx, failure)\n\t\t}\n\n\t\tif failure.Reference != nil {\n\t\t\tf.fillReference(&data, ctx, failure)\n\t\t}\n\n\t\tif failure.Delta != nil {\n\t\t\tf.fillDelta(&data, ctx, failure)\n\t\t}\n\n\t\tf.fillRequest(&data, ctx, failure)\n\t\tf.fillResponse(&data, ctx, failure)\n\t\tf.fillStacktrace(&data, ctx, failure)\n\t}\n\n\treturn &data\n}\n\nfunc (f *DefaultFormatter) fillGeneral(\n\tdata *FormatData, ctx *AssertionContext,\n) {\n\tif !f.DisableNames {\n\t\tdata.TestName = ctx.TestName\n\t\tdata.RequestName = ctx.RequestName\n\t}\n\n\tif !f.DisablePaths {\n\t\tif !f.DisableAliases {\n\t\t\tdata.AssertPath = ctx.AliasedPath\n\t\t} else {\n\t\t\tdata.AssertPath = ctx.Path\n\t\t}\n\t}\n\n\tswitch f.ColorMode {\n\tcase ColorModeAuto:\n\t\tswitch colorMode() {\n\t\tcase colorsUnsupported:\n\t\t\tdata.EnableColors = false\n\t\tcase colorsForced:\n\t\t\tdata.EnableColors = true\n\t\tcase colorsSupported:\n\t\t\tdata.EnableColors = ctx.TestingTB && flag.Parsed() && testing.Verbose()\n\t\t}\n\tcase ColorModeAlways:\n\t\tdata.EnableColors = true\n\tcase ColorModeNever:\n\t\tdata.EnableColors = false\n\t}\n\n\tif f.LineWidth != 0 {\n\t\tdata.LineWidth = f.LineWidth\n\t} else {\n\t\tdata.LineWidth = defaultLineWidth\n\t}\n}\n\nfunc (f *DefaultFormatter) fillErrors(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tdata.Errors = []string{}\n\n\tfor _, err := range failure.Errors {\n\t\tif refIsNil(err) {\n\t\t\tcontinue\n\t\t}\n\t\tdata.Errors = append(data.Errors, err.Error())\n\t}\n}\n\nfunc (f *DefaultFormatter) fillActual(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tswitch failure.Type { //nolint\n\tcase AssertUsage, AssertOperation:\n\t\tdata.HaveActual = false\n\n\tcase AssertType, AssertNotType:\n\t\tdata.HaveActual = true\n\t\tdata.Actual = f.formatTypedValue(failure.Actual.Value)\n\n\tdefault:\n\t\tdata.HaveActual = true\n\t\tdata.Actual = f.formatValue(failure.Actual.Value)\n\t}\n}\n\nfunc (f *DefaultFormatter) fillExpected(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tswitch failure.Type {\n\tcase AssertUsage, AssertOperation,\n\t\tAssertType, AssertNotType,\n\t\tAssertValid, AssertNotValid,\n\t\tAssertNil, AssertNotNil,\n\t\tAssertEmpty, AssertNotEmpty,\n\t\tAssertNotEqual:\n\t\tdata.HaveExpected = false\n\n\tcase AssertEqual:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindValue\n\t\tdata.Expected = []string{\n\t\t\tf.formatValue(failure.Expected.Value),\n\t\t}\n\n\t\tif !f.DisableDiffs && failure.Actual != nil && failure.Expected != nil {\n\t\t\tdata.Diff, data.HaveDiff = f.formatDiff(\n\t\t\t\tfailure.Expected.Value, failure.Actual.Value)\n\t\t}\n\n\tcase AssertLt, AssertLe, AssertGt, AssertGe:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindValue\n\t\tdata.Expected = []string{\n\t\t\tf.formatValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertInRange, AssertNotInRange:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindRange\n\t\tdata.Expected = f.formatRangeValue(failure.Expected.Value)\n\n\tcase AssertMatchSchema, AssertNotMatchSchema:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindSchema\n\t\tdata.Expected = []string{\n\t\t\tf.formatMatchValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertMatchPath, AssertNotMatchPath:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindPath\n\t\tdata.Expected = []string{\n\t\t\tf.formatMatchValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertMatchRegexp, AssertNotMatchRegexp:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindRegexp\n\t\tdata.Expected = []string{\n\t\t\tf.formatMatchValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertMatchFormat, AssertNotMatchFormat:\n\t\tdata.HaveExpected = true\n\t\tif extractList(failure.Expected.Value) != nil {\n\t\t\tdata.ExpectedKind = kindFormatList\n\t\t} else {\n\t\t\tdata.ExpectedKind = kindFormat\n\t\t}\n\t\tdata.Expected = f.formatListValue(failure.Expected.Value)\n\n\tcase AssertContainsKey, AssertNotContainsKey:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindKey\n\t\tdata.Expected = []string{\n\t\t\tf.formatValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertContainsElement, AssertNotContainsElement:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindElement\n\t\tdata.Expected = []string{\n\t\t\tf.formatValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertContainsSubset, AssertNotContainsSubset:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindSubset\n\t\tdata.Expected = []string{\n\t\t\tf.formatValue(failure.Expected.Value),\n\t\t}\n\n\tcase AssertBelongs, AssertNotBelongs:\n\t\tdata.HaveExpected = true\n\t\tdata.ExpectedKind = kindValueList\n\t\tdata.Expected = f.formatListValue(failure.Expected.Value)\n\t}\n}\n\nfunc (f *DefaultFormatter) fillIsNegation(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tswitch failure.Type {\n\tcase AssertUsage, AssertOperation,\n\t\tAssertType,\n\t\tAssertValid,\n\t\tAssertNil,\n\t\tAssertEmpty,\n\t\tAssertEqual,\n\t\tAssertLt, AssertLe, AssertGt, AssertGe,\n\t\tAssertInRange,\n\t\tAssertMatchSchema,\n\t\tAssertMatchPath,\n\t\tAssertMatchRegexp,\n\t\tAssertMatchFormat,\n\t\tAssertContainsKey,\n\t\tAssertContainsElement,\n\t\tAssertContainsSubset,\n\t\tAssertBelongs:\n\t\tbreak\n\n\tcase AssertNotType,\n\t\tAssertNotValid,\n\t\tAssertNotNil,\n\t\tAssertNotEmpty,\n\t\tAssertNotEqual,\n\t\tAssertNotInRange,\n\t\tAssertNotMatchSchema,\n\t\tAssertNotMatchPath,\n\t\tAssertNotMatchRegexp,\n\t\tAssertNotMatchFormat,\n\t\tAssertNotContainsKey,\n\t\tAssertNotContainsElement,\n\t\tAssertNotContainsSubset,\n\t\tAssertNotBelongs:\n\t\tdata.IsNegation = true\n\t}\n}\n\nfunc (f *DefaultFormatter) fillIsComparison(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tswitch failure.Type { //nolint\n\tcase AssertLt, AssertLe, AssertGt, AssertGe:\n\t\tdata.IsComparison = true\n\t}\n}\n\nfunc (f *DefaultFormatter) fillReference(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tdata.HaveReference = true\n\tdata.Reference = f.formatValue(failure.Reference.Value)\n}\n\nfunc (f *DefaultFormatter) fillDelta(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tdata.HaveDelta = true\n\tdata.Delta = f.formatValue(failure.Delta.Value)\n}\n\nfunc (f *DefaultFormatter) fillRequest(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tif !f.DisableRequests && ctx.Request != nil && ctx.Request.httpReq != nil {\n\t\tdump, err := httputil.DumpRequest(ctx.Request.httpReq, false)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tdata.HaveRequest = true\n\t\tdata.Request = string(dump)\n\t}\n}\n\nfunc (f *DefaultFormatter) fillResponse(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tif !f.DisableResponses && ctx.Response != nil && ctx.Response.httpResp != nil {\n\t\tdump, err := httputil.DumpResponse(ctx.Response.httpResp, false)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\ttext := strings.Replace(string(dump), \"\\r\\n\", \"\\n\", -1)\n\t\tlines := strings.SplitN(text, \"\\n\", 2)\n\n\t\tdata.HaveResponse = true\n\t\tdata.Response = fmt.Sprintf(\"%s %s\\n%s\", lines[0], ctx.Response.rtt, lines[1])\n\t}\n}\n\nfunc (f *DefaultFormatter) fillStacktrace(\n\tdata *FormatData, ctx *AssertionContext, failure *AssertionFailure,\n) {\n\tdata.Stacktrace = []string{}\n\n\tswitch f.StacktraceMode {\n\tcase StacktraceModeDisabled:\n\t\tbreak\n\n\tcase StacktraceModeStandard:\n\t\tfor _, entry := range failure.Stacktrace {\n\t\t\tdata.HaveStacktrace = true\n\t\t\tdata.Stacktrace = append(data.Stacktrace,\n\t\t\t\tfmt.Sprintf(\"%s()\\n\\t%s:%d +0x%x\",\n\t\t\t\t\tentry.Func.Name(), entry.File, entry.Line, entry.FuncOffset))\n\n\t\t}\n\n\tcase StacktraceModeCompact:\n\t\tfor _, entry := range failure.Stacktrace {\n\t\t\tif entry.IsEntrypoint {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdata.HaveStacktrace = true\n\t\t\tdata.Stacktrace = append(data.Stacktrace,\n\t\t\t\tfmt.Sprintf(\"%s() at %s:%d (%s)\",\n\t\t\t\t\tentry.FuncName, filepath.Base(entry.File), entry.Line, entry.FuncPackage))\n\n\t\t}\n\t}\n}\n\nfunc (f *DefaultFormatter) formatValue(value interface{}) string {\n\tif flt := extractFloat32(value); flt != nil {\n\t\treturn f.reformatNumber(f.formatFloatValue(*flt, 32))\n\t}\n\n\tif flt := extractFloat64(value); flt != nil {\n\t\treturn f.reformatNumber(f.formatFloatValue(*flt, 64))\n\t}\n\n\tif refIsNum(value) {\n\t\treturn f.reformatNumber(fmt.Sprintf(\"%v\", value))\n\t}\n\n\tif !refIsNil(value) && !refIsHTTP(value) {\n\t\tif s, _ := value.(fmt.Stringer); s != nil {\n\t\t\tif ss := s.String(); strings.TrimSpace(ss) != \"\" {\n\t\t\t\treturn ss\n\t\t\t}\n\t\t}\n\t\tif b, err := json.MarshalIndent(value, \"\", defaultIndent); err == nil {\n\t\t\treturn string(b)\n\t\t}\n\t}\n\n\tsq := litter.Options{\n\t\tSeparator: defaultIndent,\n\t}\n\treturn sq.Sdump(value)\n}\n\nfunc (f *DefaultFormatter) formatFloatValue(value float64, bits int) string {\n\tswitch f.FloatFormat {\n\tcase FloatFormatAuto:\n\t\tif _, frac := math.Modf(value); frac != 0 {\n\t\t\treturn strconv.FormatFloat(value, 'g', -1, bits)\n\t\t} else {\n\t\t\treturn strconv.FormatFloat(value, 'f', -1, bits)\n\t\t}\n\n\tcase FloatFormatDecimal:\n\t\treturn strconv.FormatFloat(value, 'f', -1, bits)\n\n\tcase FloatFormatScientific:\n\t\treturn strconv.FormatFloat(value, 'e', -1, bits)\n\n\tdefault:\n\t\treturn fmt.Sprintf(\"%v\", value)\n\t}\n}\n\nfunc (f *DefaultFormatter) formatTypedValue(value interface{}) string {\n\tif refIsNum(value) {\n\t\treturn fmt.Sprintf(\"%T(%v)\", value, f.formatValue(value))\n\t}\n\n\treturn fmt.Sprintf(\"%T(%#v)\", value, value)\n}\n\nfunc (f *DefaultFormatter) formatMatchValue(value interface{}) string {\n\tif str := extractString(value); str != nil {\n\t\treturn *str\n\t}\n\n\treturn f.formatValue(value)\n}\n\nfunc (f *DefaultFormatter) formatRangeValue(value interface{}) []string {\n\tif rng := exctractRange(value); rng != nil {\n\t\tif refIsNum(rng.Min) && refIsNum(rng.Max) {\n\t\t\treturn []string{\n\t\t\t\tfmt.Sprintf(\"[%v; %v]\", f.formatValue(rng.Min), f.formatValue(rng.Max)),\n\t\t\t}\n\t\t} else {\n\t\t\treturn []string{\n\t\t\t\tfmt.Sprintf(\"%v\", rng.Min),\n\t\t\t\tfmt.Sprintf(\"%v\", rng.Max),\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn []string{\n\t\t\tf.formatValue(value),\n\t\t}\n\t}\n}\n\nfunc (f *DefaultFormatter) formatListValue(value interface{}) []string {\n\tif lst := extractList(value); lst != nil {\n\t\ts := make([]string, 0, len(*lst))\n\t\tfor _, e := range *lst {\n\t\t\ts = append(s, f.formatValue(e))\n\t\t}\n\t\treturn s\n\t} else {\n\t\treturn []string{\n\t\t\tf.formatValue(value),\n\t\t}\n\t}\n}\n\nfunc (f *DefaultFormatter) formatDiff(expected, actual interface{}) (string, bool) {\n\tdiffer := gojsondiff.New()\n\n\tvar diff gojsondiff.Diff\n\n\tif ve, ok := expected.(map[string]interface{}); ok {\n\t\tif va, ok := actual.(map[string]interface{}); ok {\n\t\t\tdiff = differ.CompareObjects(ve, va)\n\t\t} else {\n\t\t\treturn \"\", false\n\t\t}\n\t} else if ve, ok := expected.([]interface{}); ok {\n\t\tif va, ok := actual.([]interface{}); ok {\n\t\t\tdiff = differ.CompareArrays(ve, va)\n\t\t} else {\n\t\t\treturn \"\", false\n\t\t}\n\t} else {\n\t\treturn \"\", false\n\t}\n\n\tif !diff.Modified() {\n\t\treturn \"\", false\n\t}\n\n\tconfig := formatter.AsciiFormatterConfig{\n\t\tShowArrayIndex: true,\n\t}\n\tfa := formatter.NewAsciiFormatter(expected, config)\n\n\tstr, err := fa.Format(diff)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\tdiffText := \"--- expected\\n+++ actual\\n\" + str\n\n\treturn diffText, true\n}\n\nfunc (f *DefaultFormatter) reformatNumber(numStr string) string {\n\tsignPart, intPart, fracPart, expPart := f.decomposeNumber(numStr)\n\tif intPart == \"\" {\n\t\treturn numStr\n\t}\n\n\tvar sb strings.Builder\n\n\tsb.WriteString(signPart)\n\tsb.WriteString(f.applySeparator(intPart, -1))\n\n\tif fracPart != \"\" {\n\t\tsb.WriteString(\".\")\n\t\tsb.WriteString(f.applySeparator(fracPart, +1))\n\t}\n\n\tif expPart != \"\" {\n\t\tsb.WriteString(\"e\")\n\t\tsb.WriteString(expPart)\n\t}\n\n\treturn sb.String()\n}\n\nvar (\n\tdecomposeRegexp = regexp.MustCompile(`^([+-])?(\\d+)([.](\\d+))?([eE]([+-]?\\d+))?$`)\n)\n\nfunc (f *DefaultFormatter) decomposeNumber(numStr string) (\n\tsignPart, intPart, fracPart, expPart string,\n) {\n\tparts := decomposeRegexp.FindStringSubmatch(numStr)\n\n\tif len(parts) > 1 {\n\t\tsignPart = parts[1]\n\t}\n\tif len(parts) > 2 {\n\t\tintPart = parts[2]\n\t}\n\tif len(parts) > 4 {\n\t\tfracPart = parts[4]\n\t}\n\tif len(parts) > 6 {\n\t\texpPart = parts[6]\n\t}\n\n\treturn\n}\n\nfunc (f *DefaultFormatter) applySeparator(numStr string, dir int) string {\n\tvar separator string\n\tswitch f.DigitSeparator {\n\tcase DigitSeparatorUnderscore:\n\t\tseparator = \"_\"\n\t\tbreak\n\tcase DigitSeparatorApostrophe:\n\t\tseparator = \"'\"\n\t\tbreak\n\tcase DigitSeparatorComma:\n\t\tseparator = \",\"\n\t\tbreak\n\tcase DigitSeparatorNone:\n\tdefault:\n\t\treturn numStr\n\t}\n\n\tvar sb strings.Builder\n\n\tcnt := 0\n\tif dir < 0 {\n\t\tcnt = len(numStr)\n\t}\n\n\tfor i := 0; i != len(numStr); i++ {\n\t\tsb.WriteByte(numStr[i])\n\n\t\tcnt += dir\n\t\tif cnt%3 == 0 && i != len(numStr)-1 {\n\t\t\tsb.WriteString(separator)\n\t\t}\n\t}\n\n\treturn sb.String()\n}\n\nfunc extractString(value interface{}) *string {\n\tswitch s := value.(type) {\n\tcase string:\n\t\treturn &s\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc extractFloat32(value interface{}) *float64 {\n\tswitch f := value.(type) {\n\tcase float32:\n\t\tff := float64(f)\n\t\treturn &ff\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc extractFloat64(value interface{}) *float64 {\n\tswitch f := value.(type) {\n\tcase float64:\n\t\treturn &f\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc exctractRange(value interface{}) *AssertionRange {\n\tswitch rng := value.(type) {\n\tcase AssertionRange:\n\t\treturn &rng\n\tcase *AssertionRange: // invalid, but we handle it\n\t\treturn rng\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc extractList(value interface{}) *AssertionList {\n\tswitch lst := value.(type) {\n\tcase AssertionList:\n\t\treturn &lst\n\tcase *AssertionList: // invalid, but we handle it\n\t\treturn lst\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nvar (\n\tcolorsSupportedOnce sync.Once\n\tcolorsSupportedMode int\n)\n\nconst (\n\tcolorsUnsupported = iota\n\tcolorsSupported\n\tcolorsForced\n)\n\nfunc colorMode() int {\n\tcolorsSupportedOnce.Do(func() {\n\t\tif s := os.Getenv(\"FORCE_COLOR\"); len(s) != 0 {\n\t\t\tif n, err := strconv.Atoi(s); err == nil && n > 0 {\n\t\t\t\tcolorsSupportedMode = colorsForced\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif (isatty.IsTerminal(os.Stdout.Fd()) || isatty.IsCygwinTerminal(os.Stdout.Fd())) &&\n\t\t\tlen(os.Getenv(\"NO_COLOR\")) == 0 &&\n\t\t\t!strings.HasPrefix(os.Getenv(\"TERM\"), \"dumb\") {\n\t\t\tcolorsSupportedMode = colorsSupported\n\t\t\treturn\n\t\t}\n\n\t\tcolorsSupportedMode = colorsUnsupported\n\t\treturn\n\t})\n\n\treturn colorsSupportedMode\n}\n\nconst (\n\tdefaultIndent    = \"  \"\n\tdefaultLineWidth = 60\n)\n\nvar defaultColors = map[string]color.Attribute{\n\t// regular\n\t\"Black\":   color.FgBlack,\n\t\"Red\":     color.FgRed,\n\t\"Green\":   color.FgGreen,\n\t\"Yellow\":  color.FgYellow,\n\t\"Magenta\": color.FgMagenta,\n\t\"Cyan\":    color.FgCyan,\n\t\"White\":   color.FgWhite,\n\t// bright\n\t\"HiBlack\":   color.FgHiBlack,\n\t\"HiRed\":     color.FgHiRed,\n\t\"HiGreen\":   color.FgHiGreen,\n\t\"HiYellow\":  color.FgHiYellow,\n\t\"HiMagenta\": color.FgHiMagenta,\n\t\"HiCyan\":    color.FgHiCyan,\n\t\"HiWhite\":   color.FgHiWhite,\n}\n\nvar defaultTemplateFuncs = template.FuncMap{\n\t\"trim\": func(input string) string {\n\t\treturn strings.TrimSpace(input)\n\t},\n\t\"indent\": func(input string) string {\n\t\tvar sb strings.Builder\n\n\t\tfor _, s := range strings.Split(input, \"\\n\") {\n\t\t\tif sb.Len() != 0 {\n\t\t\t\tsb.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tsb.WriteString(defaultIndent)\n\t\t\tsb.WriteString(s)\n\t\t}\n\n\t\treturn sb.String()\n\t},\n\t\"wrap\": func(width int, input string) string {\n\t\tinput = strings.TrimSpace(input)\n\n\t\twidth -= len(defaultIndent)\n\t\tif width <= 0 {\n\t\t\treturn input\n\t\t}\n\n\t\treturn wordwrap.WrapString(input, uint(width))\n\t},\n\t\"join\": func(width int, tokenList []string) string {\n\t\twidth -= len(defaultIndent)\n\t\tif width <= 0 {\n\t\t\treturn strings.Join(tokenList, \".\")\n\t\t}\n\n\t\tvar sb strings.Builder\n\n\t\tlineLen := 0\n\t\tlineNum := 0\n\n\t\twrite := func(s string) {\n\t\t\tsb.WriteString(s)\n\t\t\tlineLen += len(s)\n\t\t}\n\n\t\tfor n, token := range tokenList {\n\t\t\tif lineLen+len(token)+1 > width {\n\t\t\t\twrite(\"\\n\")\n\t\t\t\tlineLen = 0\n\t\t\t\tif lineNum < 2 {\n\t\t\t\t\tlineNum++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif lineLen == 0 {\n\t\t\t\tfor l := 0; l < lineNum; l++ {\n\t\t\t\t\twrite(defaultIndent)\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(token)\n\t\t\tif n != len(tokenList)-1 {\n\t\t\t\twrite(\".\")\n\t\t\t}\n\t\t}\n\n\t\treturn sb.String()\n\t},\n\t\"color\": func(enable bool, colorName, input string) string {\n\t\tif !enable {\n\t\t\treturn input\n\t\t}\n\t\tcolorAttr := color.Reset\n\t\tif ca, ok := defaultColors[colorName]; ok {\n\t\t\tcolorAttr = ca\n\t\t}\n\t\treturn color.New(colorAttr).Sprint(input)\n\t},\n\t\"colorhttp\": func(enable bool, isResponse bool, input string) string {\n\t\tif !enable {\n\t\t\treturn input\n\t\t}\n\n\t\tmethodColor := color.New(defaultColors[\"HiMagenta\"])\n\t\tstatusColor := color.New(defaultColors[\"HiMagenta\"])\n\t\theaderColor := color.New(defaultColors[\"Cyan\"])\n\n\t\tvar sb strings.Builder\n\n\t\tisFirstLine := true\n\t\tfor _, line := range strings.Split(input, \"\\n\") {\n\t\t\tif sb.Len() != 0 {\n\t\t\t\tsb.WriteString(\"\\n\")\n\t\t\t}\n\n\t\t\tline = strings.TrimSuffix(line, \"\\n\")\n\t\t\tline = strings.TrimSuffix(line, \"\\r\")\n\n\t\t\tvar words []string\n\t\t\tif isFirstLine {\n\t\t\t\twords = strings.SplitN(line, \" \", -1)\n\t\t\t} else {\n\t\t\t\twords = strings.SplitN(line, \" \", 2)\n\t\t\t}\n\n\t\t\twordLen := len(words)\n\t\t\tfor index, word := range words {\n\t\t\t\tvar applyColor *color.Color\n\n\t\t\t\tif isFirstLine {\n\t\t\t\t\tif isResponse {\n\t\t\t\t\t\tif index != 0 && index != wordLen-1 {\n\t\t\t\t\t\t\tapplyColor = statusColor\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif index == 0 {\n\t\t\t\t\t\t\tapplyColor = methodColor\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif index == 0 {\n\t\t\t\t\t\tapplyColor = headerColor\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif word != \"\" && applyColor != nil {\n\t\t\t\t\tsb.WriteString(applyColor.Sprint(word))\n\t\t\t\t} else {\n\t\t\t\t\tsb.WriteString(word)\n\t\t\t\t}\n\n\t\t\t\tsb.WriteString(\" \")\n\t\t\t}\n\n\t\t\tisFirstLine = false\n\t\t}\n\n\t\treturn sb.String()\n\t},\n\t\"colorjson\": func(enable bool, colorName, input string) string {\n\t\tif !enable {\n\t\t\treturn input\n\t\t}\n\n\t\tfallbackColor := color.Reset\n\t\tif attr, ok := defaultColors[colorName]; ok {\n\t\t\tfallbackColor = attr\n\t\t}\n\n\t\tvar parsedInput interface{}\n\t\terr := json.Unmarshal([]byte(input), &parsedInput)\n\t\tif err != nil {\n\t\t\treturn color.New(fallbackColor).Sprint(input)\n\t\t}\n\n\t\tformatter := colorjson.NewFormatter()\n\t\tformatter.KeyColor = color.New(color.Reset)\n\t\tformatter.StringColor = color.New(defaultColors[\"HiMagenta\"])\n\t\tformatter.NumberColor = color.New(defaultColors[\"Cyan\"])\n\t\tformatter.BoolColor = color.New(defaultColors[\"Cyan\"])\n\t\tformatter.NullColor = color.New(defaultColors[\"Cyan\"])\n\t\tformatter.Indent = 2\n\n\t\tb, err := formatter.Marshal(parsedInput)\n\t\tif err != nil {\n\t\t\treturn color.New(fallbackColor).Sprint(input)\n\t\t}\n\n\t\treturn string(b)\n\t},\n\t\"colordiff\": func(enable bool, input string) string {\n\t\tif !enable {\n\t\t\treturn input\n\t\t}\n\n\t\tprefixColor := [...]struct {\n\t\t\tprefix string\n\t\t\tcolor  color.Attribute\n\t\t}{\n\t\t\t{\"---\", color.FgWhite},\n\t\t\t{\"+++\", color.FgWhite},\n\t\t\t{\"-\", color.FgRed},\n\t\t\t{\"+\", color.FgGreen},\n\t\t}\n\n\t\tlineColor := func(s string) color.Attribute {\n\t\t\tfor _, pc := range prefixColor {\n\t\t\t\tif strings.HasPrefix(s, pc.prefix) {\n\t\t\t\t\treturn pc.color\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn color.Reset\n\t\t}\n\n\t\tvar sb strings.Builder\n\t\tfor _, line := range strings.Split(input, \"\\n\") {\n\t\t\tif sb.Len() != 0 {\n\t\t\t\tsb.WriteString(\"\\n\")\n\t\t\t}\n\n\t\t\tsb.WriteString(color.New(lineColor(line)).Sprint(line))\n\t\t}\n\n\t\treturn sb.String()\n\t},\n}\n\nvar defaultSuccessTemplate = `[OK] {{ join .LineWidth .AssertPath }}`\n\nvar defaultFailureTemplate = `\n{{- range $n, $err := .Errors }}\n{{ if eq $n 0 -}}\n{{ $err | wrap $.LineWidth | color $.EnableColors \"Red\" }}\n{{- else -}}\n{{ $err | wrap $.LineWidth | indent | color $.EnableColors \"Red\" }}\n{{- end -}}\n{{- end -}}\n{{- if .TestName }}\n\ntest name: {{ .TestName | color $.EnableColors \"Cyan\" }}\n{{- end -}}\n{{- if .RequestName }}\n\nrequest name: {{ .RequestName | color $.EnableColors \"Cyan\" }}\n{{- end -}}\n{{- if .HaveRequest }}\n\nrequest: {{ .Request | colorhttp $.EnableColors false | indent | trim }}\n{{- end -}}\n{{- if .HaveResponse }}\n\nresponse: {{ .Response | colorhttp $.EnableColors true | indent | trim }}\n{{- end -}}\n{{- if .HaveStacktrace }}\n\ntrace:\n{{- range $n, $call := .Stacktrace }}\n{{ $call | indent }}\n{{- end -}}\n{{- end -}}\n{{- if .AssertPath }}\n\nassertion:\n{{ join .LineWidth .AssertPath | indent | color .EnableColors \"Yellow\" }}\n{{- end -}}\n{{- if .HaveExpected }}\n\n{{ if .IsNegation }}denied\n{{- else if .IsComparison }}compared\n{{- else }}expected\n{{- end }} {{ .ExpectedKind }}:\n{{- range $n, $exp := .Expected }}\n{{ $exp | colorjson $.EnableColors \"HiMagenta\" | indent }}\n{{- end -}}\n{{- end -}}\n{{- if .HaveActual }}\n\nactual value:\n{{ .Actual | colorjson .EnableColors \"HiMagenta\" | indent }}\n{{- end -}}\n{{- if .HaveReference }}\n\nreference value:\n{{ .Reference | colorjson .EnableColors \"HiMagenta\" | indent }}\n{{- end -}}\n{{- if .HaveDelta }}\n\nallowed delta:\n{{ .Delta | indent | color .EnableColors \"Cyan\" }}\n{{- end -}}\n{{- if .HaveDiff }}\n\ndiff:\n{{ .Diff | colordiff .EnableColors | indent }}\n{{- end -}}\n`\n"
        },
        {
          "name": "formatter_test.go",
          "type": "blob",
          "size": 27.759765625,
          "content": "package httpexpect\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype typedStingerNil int\n\nfunc (*typedStingerNil) String() string {\n\treturn \"\"\n}\n\nfunc TestFormatter_FailureActual(t *testing.T) {\n\tcases := []struct {\n\t\tname           string\n\t\tassertionType  AssertionType\n\t\tassertionValue interface{}\n\t\twantHaveActual bool\n\t\twantActual     string\n\t}{\n\t\t// AssertType\n\t\t{\n\t\t\tname:           \"AssertType nil\",\n\t\t\tassertionType:  AssertType,\n\t\t\tassertionValue: nil,\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"<nil>(<nil>)\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertType int\",\n\t\t\tassertionType:  AssertType,\n\t\t\tassertionValue: int(1_000_000),\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"int(1_000_000)\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertType float32\",\n\t\t\tassertionType:  AssertType,\n\t\t\tassertionValue: float32(1_000_000),\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"float32(1_000_000)\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertType float64\",\n\t\t\tassertionType:  AssertType,\n\t\t\tassertionValue: float64(1_000_000),\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"float64(1_000_000)\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertType string\",\n\t\t\tassertionType:  AssertType,\n\t\t\tassertionValue: \"test string\",\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"string(\\\"test string\\\")\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertType object\",\n\t\t\tassertionType:  AssertType,\n\t\t\tassertionValue: struct{ Name string }{\"test name\"},\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"struct { Name string }(struct { Name string }{Name:\\\"test name\\\"})\",\n\t\t},\n\t\t// AssertValid\n\t\t{\n\t\t\tname:           \"AssertValid nil\",\n\t\t\tassertionType:  AssertValid,\n\t\t\tassertionValue: nil,\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"nil\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertValid int\",\n\t\t\tassertionType:  AssertValid,\n\t\t\tassertionValue: int(1_000_000),\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertValid float32\",\n\t\t\tassertionType:  AssertValid,\n\t\t\tassertionValue: float32(1_000_000),\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertValid float64\",\n\t\t\tassertionType:  AssertValid,\n\t\t\tassertionValue: float64(1_000_000),\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertValid string\",\n\t\t\tassertionType:  AssertValid,\n\t\t\tassertionValue: \"test string\",\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"\\\"test string\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:           \"AssertValid object\",\n\t\t\tassertionType:  AssertValid,\n\t\t\tassertionValue: struct{ Name string }{\"test name\"},\n\t\t\twantHaveActual: true,\n\t\t\twantActual:     \"{\\n  \\\"Name\\\": \\\"test name\\\"\\n}\",\n\t\t},\n\t}\n\n\tdf := &DefaultFormatter{}\n\tctx := &AssertionContext{}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfl := &AssertionFailure{\n\t\t\t\tType: tc.assertionType,\n\t\t\t\tActual: &AssertionValue{\n\t\t\t\t\tValue: tc.assertionValue,\n\t\t\t\t},\n\t\t\t}\n\t\t\tfd := df.buildFormatData(ctx, fl)\n\t\t\tassert.Equal(t, tc.wantHaveActual, fd.HaveActual)\n\t\t\tassert.Equal(t, tc.wantActual, fd.Actual)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FailureExpected(t *testing.T) {\n\tcases := []struct {\n\t\tname             string\n\t\tassertionType    AssertionType\n\t\tassertionValue   interface{}\n\t\tformatter        DefaultFormatter\n\t\twantHaveExpected bool\n\t\twantExpectedKind string\n\t\twantExpected     []string\n\t}{\n\t\t// AssertInRange\n\t\t{\n\t\t\tname:          \"AssertInRange nil\",\n\t\t\tassertionType: AssertInRange,\n\t\t\tassertionValue: AssertionRange{\n\t\t\t\tMin: nil,\n\t\t\t\tMax: nil,\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindRange,\n\t\t\twantExpected:     []string{\"<nil>\", \"<nil>\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertInRange int\",\n\t\t\tassertionType: AssertInRange,\n\t\t\tassertionValue: AssertionRange{\n\t\t\t\tMin: int(1_000_000),\n\t\t\t\tMax: int(2_000_000),\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindRange,\n\t\t\twantExpected:     []string{\"[1_000_000; 2_000_000]\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertInRange float32\",\n\t\t\tassertionType: AssertInRange,\n\t\t\tassertionValue: AssertionRange{\n\t\t\t\tMin: float32(1_000_000),\n\t\t\t\tMax: float32(2_000_000),\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindRange,\n\t\t\twantExpected:     []string{\"[1_000_000; 2_000_000]\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertInRange float64\",\n\t\t\tassertionType: AssertInRange,\n\t\t\tassertionValue: AssertionRange{\n\t\t\t\tMin: float64(1_000_000),\n\t\t\t\tMax: float64(2_000_000),\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindRange,\n\t\t\twantExpected:     []string{\"[1_000_000; 2_000_000]\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertInRange string\",\n\t\t\tassertionType: AssertInRange,\n\t\t\tassertionValue: AssertionRange{\n\t\t\t\tMin: \"test string 1\",\n\t\t\t\tMax: \"test string 2\",\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindRange,\n\t\t\twantExpected:     []string{\"test string 1\", \"test string 2\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertInRange object\",\n\t\t\tassertionType: AssertInRange,\n\t\t\tassertionValue: AssertionRange{\n\t\t\t\tMin: struct{ Name string }{\"test name 1\"},\n\t\t\t\tMax: struct{ Name string }{\"test name 2\"},\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindRange,\n\t\t\twantExpected:     []string{\"{test name 1}\", \"{test name 2}\"},\n\t\t},\n\t\t// AssertMatchPath\n\t\t{\n\t\t\tname:             \"AssertMatchPath nil\",\n\t\t\tassertionType:    AssertMatchPath,\n\t\t\tassertionValue:   nil,\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindPath,\n\t\t\twantExpected:     []string{\"nil\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"AssertMatchPath int\",\n\t\t\tassertionType:    AssertMatchPath,\n\t\t\tassertionValue:   int(1_000_000),\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindPath,\n\t\t\twantExpected:     []string{\"1_000_000\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"AssertMatchPath float32\",\n\t\t\tassertionType:    AssertMatchPath,\n\t\t\tassertionValue:   float32(1_000_000),\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindPath,\n\t\t\twantExpected:     []string{\"1_000_000\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"AssertMatchPath float64\",\n\t\t\tassertionType:    AssertMatchPath,\n\t\t\tassertionValue:   float64(1_000_000),\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindPath,\n\t\t\twantExpected:     []string{\"1_000_000\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"AssertMatchPath string\",\n\t\t\tassertionType:    AssertMatchPath,\n\t\t\tassertionValue:   \"test string\",\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindPath,\n\t\t\twantExpected:     []string{\"test string\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"AssertMatchPath object\",\n\t\t\tassertionType:    AssertMatchPath,\n\t\t\tassertionValue:   struct{ Name string }{\"test name\"},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindPath,\n\t\t\twantExpected:     []string{\"{\\n  \\\"Name\\\": \\\"test name\\\"\\n}\"},\n\t\t},\n\t\t// AssertMatchFormat\n\t\t{\n\t\t\tname:          \"AssertMatchFormat nil\",\n\t\t\tassertionType: AssertMatchFormat,\n\t\t\tassertionValue: AssertionList{\n\t\t\t\tnil,\n\t\t\t\tnil,\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindFormatList,\n\t\t\twantExpected:     []string{\"nil\", \"nil\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertMatchFormat int\",\n\t\t\tassertionType: AssertMatchFormat,\n\t\t\tassertionValue: AssertionList{\n\t\t\t\tint(1_000_000),\n\t\t\t\tint(2_000_000),\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindFormatList,\n\t\t\twantExpected:     []string{\"1_000_000\", \"2_000_000\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertMatchFormat float32\",\n\t\t\tassertionType: AssertMatchFormat,\n\t\t\tassertionValue: AssertionList{\n\t\t\t\tfloat32(1_000_000),\n\t\t\t\tfloat32(2_000_000),\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindFormatList,\n\t\t\twantExpected:     []string{\"1_000_000\", \"2_000_000\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertMatchFormat float64\",\n\t\t\tassertionType: AssertMatchFormat,\n\t\t\tassertionValue: AssertionList{\n\t\t\t\tfloat64(1_000_000),\n\t\t\t\tfloat64(2_000_000),\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindFormatList,\n\t\t\twantExpected:     []string{\"1_000_000\", \"2_000_000\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertMatchFormat string\",\n\t\t\tassertionType: AssertMatchFormat,\n\t\t\tassertionValue: AssertionList{\n\t\t\t\t\"test string 1\",\n\t\t\t\t\"test string 2\",\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindFormatList,\n\t\t\twantExpected:     []string{\"\\\"test string 1\\\"\", \"\\\"test string 2\\\"\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"AssertMatchFormat object\",\n\t\t\tassertionType: AssertMatchFormat,\n\t\t\tassertionValue: AssertionList{\n\t\t\t\tstruct{ Name string }{\"test name 1\"},\n\t\t\t\tstruct{ Name string }{\"test name 2\"},\n\t\t\t},\n\t\t\twantHaveExpected: true,\n\t\t\twantExpectedKind: kindFormatList,\n\t\t\twantExpected: []string{\n\t\t\t\t\"{\\n  \\\"Name\\\": \\\"test name 1\\\"\\n}\", \"{\\n  \\\"Name\\\": \\\"test name 2\\\"\\n}\",\n\t\t\t},\n\t\t},\n\t}\n\n\tctx := &AssertionContext{}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfl := &AssertionFailure{\n\t\t\t\tType: tc.assertionType,\n\t\t\t\tExpected: &AssertionValue{\n\t\t\t\t\tValue: tc.assertionValue,\n\t\t\t\t},\n\t\t\t}\n\t\t\tfd := tc.formatter.buildFormatData(ctx, fl)\n\t\t\tassert.Equal(t, tc.wantHaveExpected, fd.HaveExpected)\n\t\t\tassert.Equal(t, tc.wantExpectedKind, fd.ExpectedKind)\n\t\t\tassert.Equal(t, tc.wantExpected, fd.Expected)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FailureReference(t *testing.T) {\n\tcases := []struct {\n\t\tname              string\n\t\tassertionValue    interface{}\n\t\twantHaveReference bool\n\t\twantReference     string\n\t}{\n\t\t{\n\t\t\tname:              \"nil\",\n\t\t\tassertionValue:    nil,\n\t\t\twantHaveReference: true,\n\t\t\twantReference:     \"nil\",\n\t\t},\n\t\t{\n\t\t\tname:              \"int\",\n\t\t\tassertionValue:    int(1_000_000),\n\t\t\twantHaveReference: true,\n\t\t\twantReference:     \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:              \"float32\",\n\t\t\tassertionValue:    float32(1_000_000),\n\t\t\twantHaveReference: true,\n\t\t\twantReference:     \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:              \"float64\",\n\t\t\tassertionValue:    float64(1_000_000),\n\t\t\twantHaveReference: true,\n\t\t\twantReference:     \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:              \"string\",\n\t\t\tassertionValue:    \"test string\",\n\t\t\twantHaveReference: true,\n\t\t\twantReference:     \"\\\"test string\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:              \"object\",\n\t\t\tassertionValue:    struct{ Name string }{\"test name\"},\n\t\t\twantHaveReference: true,\n\t\t\twantReference:     \"{\\n  \\\"Name\\\": \\\"test name\\\"\\n}\",\n\t\t},\n\t}\n\n\tdf := &DefaultFormatter{}\n\tctx := &AssertionContext{}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfl := &AssertionFailure{\n\t\t\t\tReference: &AssertionValue{\n\t\t\t\t\tValue: tc.assertionValue,\n\t\t\t\t},\n\t\t\t}\n\t\t\tfd := df.buildFormatData(ctx, fl)\n\t\t\tassert.Equal(t, tc.wantHaveReference, fd.HaveReference)\n\t\t\tassert.Equal(t, tc.wantReference, fd.Reference)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FailureDelta(t *testing.T) {\n\tcases := []struct {\n\t\tname           string\n\t\tassertionValue interface{}\n\t\twantHaveDelta  bool\n\t\twantDelta      string\n\t}{\n\t\t{\n\t\t\tname:           \"nil\",\n\t\t\tassertionValue: nil,\n\t\t\twantHaveDelta:  true,\n\t\t\twantDelta:      \"nil\",\n\t\t},\n\t\t{\n\t\t\tname:           \"int\",\n\t\t\tassertionValue: int(1_000_000),\n\t\t\twantHaveDelta:  true,\n\t\t\twantDelta:      \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:           \"float32\",\n\t\t\tassertionValue: float32(1_000_000),\n\t\t\twantHaveDelta:  true,\n\t\t\twantDelta:      \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:           \"float64\",\n\t\t\tassertionValue: float64(1_000_000),\n\t\t\twantHaveDelta:  true,\n\t\t\twantDelta:      \"1_000_000\",\n\t\t},\n\t\t{\n\t\t\tname:           \"string\",\n\t\t\tassertionValue: \"test string\",\n\t\t\twantHaveDelta:  true,\n\t\t\twantDelta:      \"\\\"test string\\\"\",\n\t\t},\n\t\t{\n\t\t\tname:           \"object\",\n\t\t\tassertionValue: struct{ Name string }{\"test name\"},\n\t\t\twantHaveDelta:  true,\n\t\t\twantDelta:      \"{\\n  \\\"Name\\\": \\\"test name\\\"\\n}\",\n\t\t},\n\t}\n\n\tdf := &DefaultFormatter{}\n\tctx := &AssertionContext{}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfl := &AssertionFailure{\n\t\t\t\tDelta: &AssertionValue{\n\t\t\t\t\tValue: tc.assertionValue,\n\t\t\t\t},\n\t\t\t}\n\t\t\tfd := df.buildFormatData(ctx, fl)\n\t\t\tassert.Equal(t, tc.wantHaveDelta, fd.HaveDelta)\n\t\t\tassert.Equal(t, tc.wantDelta, fd.Delta)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FailureErrors(t *testing.T) {\n\tvar mErr *mockError\n\tvar mErrPtr error = mErr\n\n\tassert.Nil(t, mErrPtr)\n\tassert.NotEqual(t, nil, mErrPtr)\n\n\tcases := []struct {\n\t\tname     string\n\t\terrors   []error\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tname:     \"nil errors slice\",\n\t\t\terrors:   nil,\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty errors slice\",\n\t\t\terrors:   []error{},\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname:     \"errors slice with nil error\",\n\t\t\terrors:   []error{nil},\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname:     \"errors slice with typed nil error\",\n\t\t\terrors:   []error{mErrPtr},\n\t\t\texpected: []string{},\n\t\t},\n\t\t{\n\t\t\tname:     \"errors slice with one error\",\n\t\t\terrors:   []error{fmt.Errorf(\"error message\")},\n\t\t\texpected: []string{\"error message\"},\n\t\t},\n\t\t{\n\t\t\tname: \"errors slice with multiple errors\",\n\t\t\terrors: []error{\n\t\t\t\tfmt.Errorf(\"error message 1\"),\n\t\t\t\tfmt.Errorf(\"error message 2\"),\n\t\t\t},\n\t\t\texpected: []string{\n\t\t\t\t\"error message 1\",\n\t\t\t\t\"error message 2\",\n\t\t\t},\n\t\t},\n\t}\n\n\tdf := &DefaultFormatter{}\n\tctx := &AssertionContext{}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfl := &AssertionFailure{\n\t\t\t\tErrors: tc.errors,\n\t\t\t}\n\t\t\tfd := df.buildFormatData(ctx, fl)\n\t\t\tassert.Equal(t, tc.expected, fd.Errors)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FailureContext(t *testing.T) {\n\tctx := &AssertionContext{\n\t\tTestName:    \"MyTestName\",\n\t\tRequestName: \"MyRequestName\",\n\t\tPath:        []string{\"MyPath\"},\n\t\tAliasedPath: []string{\"MyAliasedPath\"},\n\t}\n\n\tcases := []struct {\n\t\tname  string\n\t\tfmt   DefaultFormatter\n\t\tcheck func(t *testing.T, data *FormatData)\n\t}{\n\t\t{\n\t\t\tname: \"default options\",\n\t\t\tfmt:  DefaultFormatter{},\n\t\t\tcheck: func(t *testing.T, fd *FormatData) {\n\t\t\t\tassert.Equal(t, \"MyTestName\", fd.TestName)\n\t\t\t\tassert.Equal(t, \"MyRequestName\", fd.RequestName)\n\t\t\t\tassert.Equal(t, []string{\"MyAliasedPath\"}, fd.AssertPath)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"DisableNames\",\n\t\t\tfmt: DefaultFormatter{\n\t\t\t\tDisableNames: true,\n\t\t\t},\n\t\t\tcheck: func(t *testing.T, fd *FormatData) {\n\t\t\t\tassert.Equal(t, \"\", fd.TestName)\n\t\t\t\tassert.Equal(t, \"\", fd.RequestName)\n\t\t\t\tassert.Equal(t, []string{\"MyAliasedPath\"}, fd.AssertPath)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"DisablePaths\",\n\t\t\tfmt: DefaultFormatter{\n\t\t\t\tDisablePaths: true,\n\t\t\t},\n\t\t\tcheck: func(t *testing.T, fd *FormatData) {\n\t\t\t\tassert.Equal(t, \"MyTestName\", fd.TestName)\n\t\t\t\tassert.Equal(t, \"MyRequestName\", fd.RequestName)\n\t\t\t\tassert.Equal(t, []string(nil), fd.AssertPath)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"DisableAliases\",\n\t\t\tfmt: DefaultFormatter{\n\t\t\t\tDisableAliases: true,\n\t\t\t},\n\t\t\tcheck: func(t *testing.T, fd *FormatData) {\n\t\t\t\tassert.Equal(t, \"MyTestName\", fd.TestName)\n\t\t\t\tassert.Equal(t, \"MyRequestName\", fd.RequestName)\n\t\t\t\tassert.Equal(t, []string{\"MyPath\"}, fd.AssertPath)\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfl := &AssertionFailure{\n\t\t\t\tType: AssertEqual,\n\t\t\t}\n\t\t\tfd := tc.fmt.buildFormatData(ctx, fl)\n\t\t\ttc.check(t, fd)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FloatFormat(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tformat   FloatFormat\n\t\tvalue    interface{}\n\t\twantText string\n\t}{\n\t\t// float32\n\t\t{\n\t\t\tname:     \"float32 auto small exponent\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    float32(1.2345678),\n\t\t\twantText: \"1.234_567_8\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 auto large exponent\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    float32(1234567.8),\n\t\t\twantText: \"1.234_567_8e+06\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 decimal\",\n\t\t\tformat:   FloatFormatDecimal,\n\t\t\tvalue:    float32(1234567.8),\n\t\t\twantText: \"1_234_567.8\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float32 scientific\",\n\t\t\tformat:   FloatFormatScientific,\n\t\t\tvalue:    float32(1.2345678),\n\t\t\twantText: \"1.234_567_8e+00\",\n\t\t},\n\t\t// float64\n\t\t{\n\t\t\tname:     \"float64 auto small exponent\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    float64(1.23456789),\n\t\t\twantText: \"1.234_567_89\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64 auto large exponent\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    float64(12345678.9),\n\t\t\twantText: \"1.234_567_89e+07\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64 decimal\",\n\t\t\tformat:   FloatFormatDecimal,\n\t\t\tvalue:    float64(12345678.9),\n\t\t\twantText: \"12_345_678.9\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64 scientific\",\n\t\t\tformat:   FloatFormatScientific,\n\t\t\tvalue:    float64(1.23456789),\n\t\t\twantText: \"1.234_567_89e+00\",\n\t\t},\n\t\t// no fractional part\n\t\t{\n\t\t\tname:     \"nofrac auto\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    float32(12345678),\n\t\t\twantText: \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nofrac decimal\",\n\t\t\tformat:   FloatFormatDecimal,\n\t\t\tvalue:    float32(12345678),\n\t\t\twantText: \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nofrac scientific\",\n\t\t\tformat:   FloatFormatScientific,\n\t\t\tvalue:    float32(12345678),\n\t\t\twantText: \"1.234_567_8e+07\",\n\t\t},\n\t\t// integer\n\t\t{\n\t\t\tname:     \"integer auto\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    int(12345678),\n\t\t\twantText: \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:     \"integer decimal\",\n\t\t\tformat:   FloatFormatDecimal,\n\t\t\tvalue:    int(12345678),\n\t\t\twantText: \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:     \"integer scientific\",\n\t\t\tformat:   FloatFormatScientific,\n\t\t\tvalue:    int(12345678),\n\t\t\twantText: \"12_345_678\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tformatter := DefaultFormatter{\n\t\t\t\tFloatFormat: tc.format,\n\t\t\t}\n\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t&AssertionContext{},\n\t\t\t\t&AssertionFailure{\n\t\t\t\t\tType:   AssertValid,\n\t\t\t\t\tActual: &AssertionValue{tc.value},\n\t\t\t\t})\n\t\t\tassert.Equal(t, tc.wantText, formatData.Actual)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FloatFields(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tformat   FloatFormat\n\t\tvalue    float64\n\t\twantText string\n\t}{\n\t\t{\n\t\t\tname:     \"auto\",\n\t\t\tformat:   FloatFormatAuto,\n\t\t\tvalue:    1.2345678,\n\t\t\twantText: \"1.234_567_8\",\n\t\t},\n\t\t{\n\t\t\tname:     \"decimal\",\n\t\t\tformat:   FloatFormatDecimal,\n\t\t\tvalue:    1.2345678,\n\t\t\twantText: \"1.234_567_8\",\n\t\t},\n\t\t{\n\t\t\tname:     \"scientific\",\n\t\t\tformat:   FloatFormatScientific,\n\t\t\tvalue:    1.2345678,\n\t\t\twantText: \"1.234_567_8e+00\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tformatter := DefaultFormatter{\n\t\t\t\tFloatFormat: tc.format,\n\t\t\t}\n\n\t\t\tt.Run(\"actual\", func(t *testing.T) {\n\t\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t\t&AssertionContext{},\n\t\t\t\t\t&AssertionFailure{\n\t\t\t\t\t\tType:   AssertValid,\n\t\t\t\t\t\tActual: &AssertionValue{tc.value},\n\t\t\t\t\t})\n\t\t\t\tassert.Equal(t, tc.wantText, formatData.Actual)\n\t\t\t})\n\n\t\t\tt.Run(\"expected\", func(t *testing.T) {\n\t\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t\t&AssertionContext{},\n\t\t\t\t\t&AssertionFailure{\n\t\t\t\t\t\tType:     AssertEqual,\n\t\t\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\t\t\tExpected: &AssertionValue{tc.value},\n\t\t\t\t\t})\n\t\t\t\trequire.Equal(t, 1, len(formatData.Expected))\n\t\t\t\tassert.Equal(t, tc.wantText, formatData.Expected[0])\n\t\t\t})\n\n\t\t\tt.Run(\"reference\", func(t *testing.T) {\n\t\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t\t&AssertionContext{},\n\t\t\t\t\t&AssertionFailure{\n\t\t\t\t\t\tType:      AssertEqual,\n\t\t\t\t\t\tActual:    &AssertionValue{},\n\t\t\t\t\t\tExpected:  &AssertionValue{},\n\t\t\t\t\t\tReference: &AssertionValue{tc.value},\n\t\t\t\t\t})\n\t\t\t\tassert.Equal(t, tc.wantText, formatData.Reference)\n\t\t\t})\n\n\t\t\tt.Run(\"delta\", func(t *testing.T) {\n\t\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t\t&AssertionContext{},\n\t\t\t\t\t&AssertionFailure{\n\t\t\t\t\t\tType:     AssertEqual,\n\t\t\t\t\t\tActual:   &AssertionValue{},\n\t\t\t\t\t\tExpected: &AssertionValue{},\n\t\t\t\t\t\tDelta:    &AssertionValue{tc.value},\n\t\t\t\t\t})\n\t\t\t\tassert.Equal(t, tc.wantText, formatData.Delta)\n\t\t\t})\n\n\t\t\tt.Run(\"range\", func(t *testing.T) {\n\t\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t\t&AssertionContext{},\n\t\t\t\t\t&AssertionFailure{\n\t\t\t\t\t\tType:   AssertInRange,\n\t\t\t\t\t\tActual: &AssertionValue{},\n\t\t\t\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\t\t\t\tMin: tc.value,\n\t\t\t\t\t\t\tMax: tc.value,\n\t\t\t\t\t\t}},\n\t\t\t\t\t})\n\t\t\t\trequire.Equal(t, 1, len(formatData.Expected))\n\t\t\t\tassert.Equal(t,\n\t\t\t\t\tfmt.Sprintf(\"[%s; %s]\", tc.wantText, tc.wantText),\n\t\t\t\t\tformatData.Expected[0])\n\t\t\t})\n\n\t\t\tt.Run(\"list\", func(t *testing.T) {\n\t\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t\t&AssertionContext{},\n\t\t\t\t\t&AssertionFailure{\n\t\t\t\t\t\tType:   AssertBelongs,\n\t\t\t\t\t\tActual: &AssertionValue{},\n\t\t\t\t\t\tExpected: &AssertionValue{AssertionList{\n\t\t\t\t\t\t\ttc.value,\n\t\t\t\t\t\t\ttc.value,\n\t\t\t\t\t\t}},\n\t\t\t\t\t})\n\t\t\t\trequire.Equal(t, 2, len(formatData.Expected))\n\t\t\t\tassert.Equal(t, tc.wantText, formatData.Expected[0])\n\t\t\t\tassert.Equal(t, tc.wantText, formatData.Expected[1])\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestFormatter_DigitSeparator(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tseparator DigitSeparator\n\t\tformat    FloatFormat\n\t\tvalue     interface{}\n\t\twantText  string\n\t}{\n\t\t// types\n\t\t{\n\t\t\tname:      \"float32\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatAuto,\n\t\t\tvalue:     float32(1.23456),\n\t\t\twantText:  \"1.234_56\",\n\t\t},\n\t\t{\n\t\t\tname:      \"float64\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatAuto,\n\t\t\tvalue:     float64(1.23456789),\n\t\t\twantText:  \"1.234_567_89\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int32\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatAuto,\n\t\t\tvalue:     int32(12345678),\n\t\t\twantText:  \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int64\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatAuto,\n\t\t\tvalue:     int64(12345678),\n\t\t\twantText:  \"12_345_678\",\n\t\t},\n\t\t// components\n\t\t{\n\t\t\tname:      \"int part, decimal\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(12345678),\n\t\t\twantText:  \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int part, scientific\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatScientific,\n\t\t\tvalue:     float64(12345678),\n\t\t\twantText:  \"1.234_567_8e+07\",\n\t\t},\n\t\t{\n\t\t\tname:      \"sign part, int part, decimal\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(-12345678),\n\t\t\twantText:  \"-12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:      \"sign part, int part, scientific\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatScientific,\n\t\t\tvalue:     float64(-12345678),\n\t\t\twantText:  \"-1.234_567_8e+07\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int part, frac part, decimal\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(12345678.12345678),\n\t\t\twantText:  \"12_345_678.123_456_78\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int part, frac part, scientific\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatScientific,\n\t\t\tvalue:     float64(12345678.12345678),\n\t\t\twantText:  \"1.234_567_812_345_678e+07\",\n\t\t},\n\t\t{\n\t\t\tname:      \"sign part, int part, frac part, decimal\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(-12345678.12345678),\n\t\t\twantText:  \"-12_345_678.123_456_78\",\n\t\t},\n\t\t{\n\t\t\tname:      \"sign part, int part, frac part, scientific\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatScientific,\n\t\t\tvalue:     float64(-12345678.12345678),\n\t\t\twantText:  \"-1.234_567_812_345_678e+07\",\n\t\t},\n\t\t// edge cases\n\t\t{\n\t\t\tname:      \"int part, 3 digits\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(123),\n\t\t\twantText:  \"123\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int part, multiple of 3\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(123456),\n\t\t\twantText:  \"123_456\",\n\t\t},\n\t\t{\n\t\t\tname:      \"frac part, 3 digits\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(0.123),\n\t\t\twantText:  \"0.123\",\n\t\t},\n\t\t{\n\t\t\tname:      \"frac part, multiple of 3\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(0.123456),\n\t\t\twantText:  \"0.123_456\",\n\t\t},\n\t\t{\n\t\t\tname:      \"int and frac part, multiple of 3\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(123456.123456),\n\t\t\twantText:  \"123_456.123_456\",\n\t\t},\n\t\t// separators\n\t\t{\n\t\t\tname:      \"underscore\",\n\t\t\tseparator: DigitSeparatorUnderscore,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(12345678),\n\t\t\twantText:  \"12_345_678\",\n\t\t},\n\t\t{\n\t\t\tname:      \"comma\",\n\t\t\tseparator: DigitSeparatorComma,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(12345678),\n\t\t\twantText:  \"12,345,678\",\n\t\t},\n\t\t{\n\t\t\tname:      \"apostrophe\",\n\t\t\tseparator: DigitSeparatorApostrophe,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(12345678),\n\t\t\twantText:  \"12'345'678\",\n\t\t},\n\t\t{\n\t\t\tname:      \"none\",\n\t\t\tseparator: DigitSeparatorNone,\n\t\t\tformat:    FloatFormatDecimal,\n\t\t\tvalue:     float64(12345678),\n\t\t\twantText:  \"12345678\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tformatter := DefaultFormatter{\n\t\t\t\tDigitSeparator: tc.separator,\n\t\t\t\tFloatFormat:    tc.format,\n\t\t\t}\n\t\t\tformatData := formatter.buildFormatData(\n\t\t\t\t&AssertionContext{},\n\t\t\t\t&AssertionFailure{\n\t\t\t\t\tType:   AssertValid,\n\t\t\t\t\tActual: &AssertionValue{tc.value},\n\t\t\t\t})\n\t\t\tassert.Equal(t, tc.wantText, formatData.Actual)\n\t\t})\n\t}\n}\n\nfunc TestFormatter_FormatValue(t *testing.T) {\n\tvar formatter = &DefaultFormatter{}\n\n\tcheckAll := func(t *testing.T, fn func(interface{}) string) {\n\t\tvar tnil *typedStingerNil\n\t\tvar tnilPtr fmt.Stringer = tnil\n\n\t\tassert.Nil(t, tnilPtr)\n\t\tassert.NotEqual(t, nil, tnilPtr)\n\n\t\tcheck := func(s string) {\n\t\t\tt.Logf(\"\\n%s\", s)\n\t\t\tassert.NotEmpty(t, s)\n\t\t}\n\n\t\tcheck(fn(nil))\n\t\tcheck(fn(tnil))\n\t\tcheck(fn(tnilPtr))\n\t\tcheck(fn(123))\n\t\tcheck(fn(float32(123)))\n\t\tcheck(fn(float64(123)))\n\t\tcheck(fn(\"hello\"))\n\t\tcheck(fn(time.Second))\n\t\tcheck(fn(time.Unix(0, 0)))\n\t\tcheck(fn([]interface{}{1, 2}))\n\t\tcheck(fn(map[string]string{\"a\": \"b\"}))\n\t\tcheck(fn(make(chan int)))\n\t\tcheck(fn(AssertionRange{1, 2}))\n\t\tcheck(fn(&AssertionRange{1, 2}))\n\t\tcheck(fn(AssertionRange{\"a\", \"b\"}))\n\t\tcheck(fn(AssertionList([]interface{}{1, 2})))\n\t}\n\n\tt.Run(\"formatValue\", func(t *testing.T) {\n\t\tcheckAll(t, formatter.formatValue)\n\t})\n\n\tt.Run(\"formatTypedValue\", func(t *testing.T) {\n\t\tcheckAll(t, formatter.formatTypedValue)\n\t})\n\n\tt.Run(\"formatMatchValue\", func(t *testing.T) {\n\t\tcheckAll(t, formatter.formatMatchValue)\n\t})\n\n\tt.Run(\"formatRangeValue\", func(t *testing.T) {\n\t\tcheckAll(t, func(v interface{}) string {\n\t\t\treturn strings.Join(formatter.formatRangeValue(v), \"\")\n\t\t})\n\t})\n\n\tt.Run(\"formatListValue\", func(t *testing.T) {\n\t\tcheckAll(t, func(v interface{}) string {\n\t\t\treturn strings.Join(formatter.formatListValue(v), \"\")\n\t\t})\n\t})\n}\n\nfunc TestFormatter_FormatDiff(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tcheck := func(a, b interface{}) {\n\t\t\tformatter := &DefaultFormatter{}\n\t\t\tdiff, ok := formatter.formatDiff(a, b)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.NotEqual(t, \"\", diff)\n\t\t}\n\n\t\tcheck(map[string]interface{}{\"a\": 1}, map[string]interface{}{})\n\t\tcheck([]interface{}{\"a\"}, []interface{}{})\n\t})\n\n\tt.Run(\"failure\", func(t *testing.T) {\n\t\tcheck := func(a, b interface{}) {\n\t\t\tformatter := &DefaultFormatter{}\n\t\t\tdiff, ok := formatter.formatDiff(a, b)\n\t\t\tassert.False(t, ok)\n\t\t\tassert.Equal(t, \"\", diff)\n\t\t}\n\n\t\tcheck(map[string]interface{}{}, []interface{}{})\n\t\tcheck([]interface{}{}, map[string]interface{}{})\n\t\tcheck(\"foo\", \"bar\")\n\t\tcheck(func() {}, func() {})\n\n\t\tcheck(map[string]interface{}{}, map[string]interface{}{})\n\t\tcheck([]interface{}{}, []interface{}{})\n\t})\n}\n\nfunc TestFormatter_StacktraceMode(t *testing.T) {\n\tcases := []struct {\n\t\tname string\n\t\tmode StacktraceMode\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"disabled\",\n\t\t\tmode: StacktraceModeDisabled,\n\t\t\twant: false,\n\t\t},\n\t\t{\n\t\t\tname: \"standard\",\n\t\t\tmode: StacktraceModeStandard,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"compact\",\n\t\t\tmode: StacktraceModeCompact,\n\t\t\twant: true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tf := &DefaultFormatter{\n\t\t\t\tStacktraceMode: tc.mode,\n\t\t\t}\n\t\t\tfd := f.buildFormatData(&AssertionContext{}, &AssertionFailure{\n\t\t\t\tStacktrace: stacktrace(),\n\t\t\t})\n\n\t\t\tif tc.want {\n\t\t\t\trequire.GreaterOrEqual(t, len(fd.Stacktrace), 1)\n\t\t\t\tassert.Contains(t, fd.Stacktrace[0], \"TestFormatter_StacktraceMode.func\")\n\t\t\t\tassert.Contains(t, fd.Stacktrace[0], \"formatter_test.go\")\n\t\t\t\tassert.Contains(t, fd.Stacktrace[0], \"github.com/gavv/httpexpect\")\n\t\t\t} else {\n\t\t\t\tassert.NotNil(t, fd.Stacktrace)\n\t\t\t\tassert.Equal(t, 0, len(fd.Stacktrace))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFormatter_ColorMode(t *testing.T) {\n\tcases := []struct {\n\t\tname string\n\t\tmode ColorMode\n\t\twant bool\n\t}{\n\t\t{\n\t\t\tname: \"always\",\n\t\t\tmode: ColorModeAlways,\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"never\",\n\t\t\tmode: ColorModeNever,\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tf := DefaultFormatter{\n\t\t\t\tColorMode: tc.mode,\n\t\t\t}\n\t\t\tfd := f.buildFormatData(&AssertionContext{}, &AssertionFailure{})\n\t\t\tassert.Equal(t, tc.want, fd.EnableColors)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.7138671875,
          "content": "module github.com/gavv/httpexpect/v2\n\ngo 1.19\n\nrequire (\n\tgithub.com/TylerBrock/colorjson v0.0.0-20200706003622-8a50f05110d2\n\tgithub.com/ajg/form v1.5.1\n\tgithub.com/fasthttp/websocket v1.4.3-rc.6\n\tgithub.com/fatih/color v1.15.0\n\tgithub.com/fatih/structs v1.1.0\n\tgithub.com/gobwas/glob v0.2.3\n\tgithub.com/google/go-querystring v1.1.0\n\tgithub.com/gorilla/websocket v1.4.2\n\tgithub.com/imkira/go-interpol v1.1.0\n\tgithub.com/mattn/go-isatty v0.0.18\n\tgithub.com/mitchellh/go-wordwrap v1.0.1\n\tgithub.com/sanity-io/litter v1.5.5\n\tgithub.com/stretchr/testify v1.5.0\n\tgithub.com/valyala/fasthttp v1.34.0\n\tgithub.com/xeipuuv/gojsonschema v1.2.0\n\tgithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0\n\tgithub.com/yudai/gojsondiff v1.0.0\n\tgolang.org/x/net v0.23.0\n\tmoul.io/http2curl/v2 v2.3.0\n)\n\nrequire (\n\tgithub.com/andybalholm/brotli v1.0.4 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/hokaccha/go-prettyjson v0.0.0-20211117102719-0474bc63780f // indirect\n\tgithub.com/klauspost/compress v1.15.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/onsi/ginkgo v1.10.1 // indirect\n\tgithub.com/onsi/gomega v1.7.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/savsgio/gotils v0.0.0-20210617111740-97865ed5a873 // indirect\n\tgithub.com/sergi/go-diff v1.0.0 // indirect\n\tgithub.com/valyala/bytebufferpool v1.0.0 // indirect\n\tgithub.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb // indirect\n\tgithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect\n\tgithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 // indirect\n\tgithub.com/yudai/pp v2.0.1+incompatible // indirect\n\tgolang.org/x/sys v0.18.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 13.8955078125,
          "content": "github.com/TylerBrock/colorjson v0.0.0-20200706003622-8a50f05110d2 h1:ZBbLwSJqkHBuFDA6DUhhse0IGJ7T5bemHyNILUjvOq4=\ngithub.com/TylerBrock/colorjson v0.0.0-20200706003622-8a50f05110d2/go.mod h1:VSw57q4QFiWDbRnjdX8Cb3Ow0SFncRw+bA/ofY6Q83w=\ngithub.com/ajg/form v1.5.1 h1:t9c7v8JUKu/XxOGBU0yjNpaMloxGEJhUkqFRq0ibGeU=\ngithub.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=\ngithub.com/andybalholm/brotli v1.0.2/go.mod h1:loMXtMfwqflxFJPmdbJO0a3KNoPuLBgiu3qAvBg8x/Y=\ngithub.com/andybalholm/brotli v1.0.4 h1:V7DdXeJtZscaqfNuAdSRuRFzuiKlHSC/Zh3zl9qY3JY=\ngithub.com/andybalholm/brotli v1.0.4/go.mod h1:fO7iG3H7G2nSZ7m0zPUDn85XEX2GTukHGRSepvi9Eig=\ngithub.com/davecgh/go-spew v0.0.0-20161028175848-04cdfd42973b/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fasthttp/websocket v1.4.3-rc.6 h1:omHqsl8j+KXpmzRjF8bmzOSYJ8GnS0E3efi1wYT+niY=\ngithub.com/fasthttp/websocket v1.4.3-rc.6/go.mod h1:43W9OM2T8FeXpCWMsBd9Cb7nE2CACNqNvCqQCoty/Lc=\ngithub.com/fatih/color v1.15.0 h1:kOqh6YHBtK8aywxGerMG2Eq3H6Qgoqeo13Bk2Mv/nBs=\ngithub.com/fatih/color v1.15.0/go.mod h1:0h5ZqXfHYED7Bhv2ZJamyIOUej9KtShiJESRwBDUSsw=\ngithub.com/fatih/structs v1.1.0 h1:Q7juDM0QtcnhCpeyLGQKyg4TOIghuNXrkL32pHAUMxo=\ngithub.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/gobwas/glob v0.2.3 h1:A4xDbljILXROh+kObIiy5kIaPYD8e96x1tgBhUI5J+Y=\ngithub.com/gobwas/glob v0.2.3/go.mod h1:d3Ez4x06l9bZtSvzIay5+Yzi0fmZzPgnTbPcKjJAkT8=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/google/go-cmp v0.5.2 h1:X2ev0eStA3AbceY54o37/0PQ/UWqKEiiO2dKL5OPaFM=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngithub.com/google/uuid v1.2.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/hokaccha/go-prettyjson v0.0.0-20211117102719-0474bc63780f h1:7LYC+Yfkj3CTRcShK0KOL/w6iTiKyqqBA9a41Wnggw8=\ngithub.com/hokaccha/go-prettyjson v0.0.0-20211117102719-0474bc63780f/go.mod h1:pFlLw2CfqZiIBOx6BuCeRLCrfxBJipTY0nIOF/VbGcI=\ngithub.com/hpcloud/tail v1.0.0 h1:nfCOvKYfkgYP8hkirhJocXT2+zOD8yUNjXaWfTlyFKI=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/imkira/go-interpol v1.1.0 h1:KIiKr0VSG2CUW1hl1jpiyuzuJeKUUpC8iM1AIE7N1Vk=\ngithub.com/imkira/go-interpol v1.1.0/go.mod h1:z0h2/2T3XF8kyEPpRgJ3kmNv+C43p+I/CoI+jC3w2iA=\ngithub.com/klauspost/compress v1.12.2/go.mod h1:8dP1Hq4DHOhN9w426knH3Rhby4rFm6D8eO+e+Dq5Gzg=\ngithub.com/klauspost/compress v1.15.0 h1:xqfchp4whNFxn5A4XFyyYtitiWI8Hy5EW59jEwcyL6U=\ngithub.com/klauspost/compress v1.15.0/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.18 h1:DOKFKCQ7FNG2L1rbrmstDN4QVRdS89Nkh85u68Uwp98=\ngithub.com/mattn/go-isatty v0.0.18/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mitchellh/go-wordwrap v1.0.1 h1:TLuKupo69TCn6TQSyGxwI1EblZZEsQ0vMlAFQflz0v0=\ngithub.com/mitchellh/go-wordwrap v1.0.1/go.mod h1:R62XHJLzvMFRBbcrT7m7WgmE1eOyTSsCt+hzestvNj0=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.10.1 h1:q/mM8GF/n0shIN8SaAZ0V+jnLPzen6WIVZdiwrRlMlo=\ngithub.com/onsi/ginkgo v1.10.1/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/gomega v1.7.0 h1:XPnZz8VVBHjVsy1vzJmRwIcSwiUO+JFfrv/xGiigmME=\ngithub.com/onsi/gomega v1.7.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/pkg/diff v0.0.0-20200914180035-5b29258ca4f7/go.mod h1:zO8QMzTeZd5cpnIkz/Gn6iK0jDfGicM1nynOkkPIl28=\ngithub.com/pmezard/go-difflib v0.0.0-20151028094244-d8ed2627bdf0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sanity-io/litter v1.5.5 h1:iE+sBxPBzoK6uaEP5Lt3fHNgpKcHXc/A2HGETy0uJQo=\ngithub.com/sanity-io/litter v1.5.5/go.mod h1:9gzJgR2i4ZpjZHsKvUXIRQVk7P+yM3e+jAF7bU2UI5U=\ngithub.com/savsgio/gotils v0.0.0-20210617111740-97865ed5a873 h1:N3Af8f13ooDKcIhsmFT7Z05CStZWu4C7Md0uDEy4q6o=\ngithub.com/savsgio/gotils v0.0.0-20210617111740-97865ed5a873/go.mod h1:dmPawKuiAeG/aFYVs2i+Dyosoo7FNcm+Pi8iK6ZUrX8=\ngithub.com/sergi/go-diff v1.0.0 h1:Kpca3qRNrduNnOQeazBd0ysaKrUJiIuISHxogkT9RPQ=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v0.0.0-20161117074351-18a02ba4a312/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.0 h1:DMOzIV76tmoDNE9pX6RSN0aDtCYeCg5VueieJaAo1uw=\ngithub.com/stretchr/testify v1.5.0/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/tailscale/depaware v0.0.0-20210622194025-720c4b409502/go.mod h1:p9lPsd+cx33L3H9nNoecRRxPssFKUwwI50I3pZ0yT+8=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasthttp v1.27.0/go.mod h1:cmWIqlu99AO/RKcp1HWaViTqc57FswJOfYYdPJBl8BA=\ngithub.com/valyala/fasthttp v1.34.0 h1:d3AAQJ2DRcxJYHm7OXNXtXt2as1vMDfxeIcFvhmGGm4=\ngithub.com/valyala/fasthttp v1.34.0/go.mod h1:epZA5N+7pY6ZaEKRmstzOuYJx9HI8DI1oaCGZpdH4h0=\ngithub.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb h1:zGWFAtiMcyryUHoUjUJX0/lt1H2+i2Ka2n+D3DImSNo=\ngithub.com/xeipuuv/gojsonpointer v0.0.0-20190905194746-02993c407bfb/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=\ngithub.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=\ngithub.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=\ngithub.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=\ngithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0 h1:6fRhSjgLCkTD3JnJxvaJ4Sj+TYblw757bqYgZaOq5ZY=\ngithub.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0/go.mod h1:/LWChgwKmvncFJFHJ7Gvn9wZArjbV5/FppcK2fKk/tI=\ngithub.com/yudai/gojsondiff v1.0.0 h1:27cbfqXLVEJ1o8I6v3y9lg8Ydm53EKqHXAOMxEGlCOA=\ngithub.com/yudai/gojsondiff v1.0.0/go.mod h1:AY32+k2cwILAkW1fbgxQ5mUmMiZFgLIV+FBNExI05xg=\ngithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 h1:BHyfKlQyqbsFN5p3IfnEUduWvb9is428/nNb5L3U01M=\ngithub.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=\ngithub.com/yudai/pp v2.0.1+incompatible h1:Q4//iY4pNF6yPLZIigmvcl7k/bPgrcTPIFIcmawg5bI=\ngithub.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210513164829-c07d793c2f9a/go.mod h1:P+XmwS30IXTQdn5tA2iutPOUgjI07+tq3H3K9MVA1s8=\ngolang.org/x/crypto v0.0.0-20220214200702-86341886e292/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210510120150-4163338589ed/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20220225172249-27dd8689420f/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210514084401-e8d321eab015/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220227234510-4e6760a101f9/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.18.0 h1:DBdB3niSjOA/O0blCZBqDefyWNYveAYMNF1Wum0DYQ4=\ngolang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20201211185031-d93e913c1a58/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/fsnotify.v1 v1.4.7 h1:xOHLXZwVvI9hhs+cLKq5+I5onOuwQLhQwiu63xxlHs4=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\nmoul.io/http2curl/v2 v2.3.0 h1:9r3JfDzWPcbIklMOs2TnIFzDYvfAZvjeavG6EzP7jYs=\nmoul.io/http2curl/v2 v2.3.0/go.mod h1:RW4hyBjTWSYDOxapodpNEtX0g5Eb16sxklBqmd2RHcE=\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 2.2978515625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\n\t\"github.com/xeipuuv/gojsonschema\"\n\t\"github.com/yalp/jsonpath\"\n)\n\nfunc jsonPath(opChain *chain, value interface{}, path string) *Value {\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tfilterFn, err := jsonpath.Prepare(path)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{path},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid json path\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tresult, err := filterFn(value)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertMatchPath,\n\t\t\tActual:   &AssertionValue{value},\n\t\t\tExpected: &AssertionValue{path},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value matches given json path\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\treturn newValue(opChain, result)\n}\n\nfunc jsonSchema(opChain *chain, value, schema interface{}) {\n\tif opChain.failed() {\n\t\treturn\n\t}\n\n\tgetString := func(in interface{}) (out string, ok bool) {\n\t\tok = true\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tok = false\n\t\t\t}\n\t\t}()\n\t\tout = reflect.ValueOf(in).Convert(reflect.TypeOf(\"\")).String()\n\t\treturn\n\t}\n\n\tvar schemaLoader gojsonschema.JSONLoader\n\tvar schemaData interface{}\n\n\tif str, ok := getString(schema); ok {\n\t\tif ok, _ := regexp.MatchString(`^\\w+://`, str); ok {\n\t\t\tschemaLoader = gojsonschema.NewReferenceLoader(str)\n\t\t\tschemaData = str\n\t\t} else {\n\t\t\tschemaLoader = gojsonschema.NewStringLoader(str)\n\t\t\tschemaData, _ = schemaLoader.LoadJSON()\n\t\t}\n\t} else {\n\t\tschemaLoader = gojsonschema.NewGoLoader(schema)\n\t\tschemaData = schema\n\t}\n\n\tvalueLoader := gojsonschema.NewGoLoader(value)\n\n\tresult, err := gojsonschema.Validate(schemaLoader, valueLoader)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{schema},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid json schema\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif !result.Valid() {\n\t\terrors := []error{\n\t\t\terrors.New(\"expected: value matches given json schema\"),\n\t\t}\n\t\tfor _, err := range result.Errors() {\n\t\t\terrors = append(errors, fmt.Errorf(\"%s\", err))\n\t\t}\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertMatchSchema,\n\t\t\tActual:   &AssertionValue{value},\n\t\t\tExpected: &AssertionValue{schemaData},\n\t\t\tErrors:   errors,\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 0.158203125,
          "content": "package httpexpect\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestMain(m *testing.M) {\n\t// all chains should panic on misuse\n\tchainValidation = true\n\n\tos.Exit(m.Run())\n}\n"
        },
        {
          "name": "match.go",
          "type": "blob",
          "size": 8.42578125,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n)\n\n// Match provides methods to inspect attached regexp match results.\ntype Match struct {\n\tchain          *chain\n\tsubmatchValues []string\n\tsubmatchNames  map[string]int\n}\n\n// NewMatch returns a new Match instance.\n//\n// If reporter is nil, the function panics.\n// Both submatchValues and submatchNames may be nil.\n//\n// Example:\n//\n//\ts := \"http://example.com/users/john\"\n//\tr := regexp.MustCompile(`http://(?P<host>.+)/users/(?P<user>.+)`)\n//\n//\tm := NewMatch(t, r.FindStringSubmatch(s), r.SubexpNames())\n//\n//\tm.NotEmpty()\n//\tm.Length().IsEqual(3)\n//\n//\tm.Submatch(0).IsEqual(\"http://example.com/users/john\")\n//\tm.Submatch(1).IsEqual(\"example.com\")\n//\tm.Submatch(2).IsEqual(\"john\")\n//\n//\tm.NamedSubmatch(\"host\").IsEqual(\"example.com\")\n//\tm.NamedSubmatch(\"user\").IsEqual(\"john\")\nfunc NewMatch(reporter Reporter, submatchValues []string, submatchNames []string) *Match {\n\treturn newMatch(\n\t\tnewChainWithDefaults(\"Match()\", reporter), submatchValues, submatchNames)\n}\n\n// NewMatchC returns a new Match instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// Both submatches and names may be nil.\n//\n// See NewMatch for usage example.\nfunc NewMatchC(config Config, submatchValues []string, submatchNames []string) *Match {\n\treturn newMatch(\n\t\tnewChainWithConfig(\"Match()\", config.withDefaults()), submatchValues, submatchNames)\n}\n\nfunc newMatch(parent *chain, submatchValues []string, submatchNames []string) *Match {\n\tm := &Match{parent.clone(), nil, nil}\n\n\tif submatchValues != nil {\n\t\tm.submatchValues = make([]string, len(submatchValues))\n\t\tcopy(m.submatchValues, submatchValues)\n\t} else {\n\t\tm.submatchValues = []string{}\n\t}\n\n\tm.submatchNames = map[string]int{}\n\tfor n, name := range submatchNames {\n\t\tif name != \"\" {\n\t\t\tm.submatchNames[name] = n\n\t\t}\n\t}\n\n\treturn m\n}\n\n// Raw returns underlying submatches attached to Match.\n// This is the value originally passed to NewMatch.\n//\n// Example:\n//\n//\tm := NewMatch(t, submatches, names)\n//\tassert.Equal(t, submatches, m.Raw())\nfunc (m *Match) Raw() []string {\n\treturn m.submatchValues\n}\n\n// Alias is similar to Value.Alias.\nfunc (m *Match) Alias(name string) *Match {\n\topChain := m.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tm.chain.setAlias(name)\n\treturn m\n}\n\n// Length returns a new Number instance with number of submatches.\n//\n// Example:\n//\n//\tm := NewMatch(t, submatches, names)\n//\tm.Length().IsEqual(len(submatches))\nfunc (m *Match) Length() *Number {\n\topChain := m.chain.enter(\"Length()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\treturn newNumber(opChain, float64(len(m.submatchValues)))\n}\n\n// Submatch returns a new String instance with submatch for given index.\n//\n// Note that submatch with index 0 contains the whole match. If index is out\n// of bounds, Submatch reports failure and returns empty (but non-nil) instance.\n//\n// Example:\n//\n//\ts := \"http://example.com/users/john\"\n//\n//\tr := regexp.MustCompile(`http://(.+)/users/(.+)`)\n//\tm := NewMatch(t, r.FindStringSubmatch(s), nil)\n//\n//\tm.Submatch(0).IsEqual(\"http://example.com/users/john\")\n//\tm.Submatch(1).IsEqual(\"example.com\")\n//\tm.Submatch(2).IsEqual(\"john\")\nfunc (m *Match) Submatch(index int) *String {\n\topChain := m.chain.enter(\"Submatch(%d)\", index)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tif index < 0 || index >= len(m.submatchValues) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertInRange,\n\t\t\tActual: &AssertionValue{index},\n\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\tMin: 0,\n\t\t\t\tMax: len(m.submatchValues) - 1,\n\t\t\t}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid sub-match index\"),\n\t\t\t},\n\t\t})\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, m.submatchValues[index])\n}\n\n// NamedSubmatch returns a new String instance with submatch for given name.\n//\n// If there is no submatch with given name, NamedSubmatch reports failure and returns\n// empty (but non-nil) instance.\n//\n// Example:\n//\n//\ts := \"http://example.com/users/john\"\n//\n//\tr := regexp.MustCompile(`http://(?P<host>.+)/users/(?P<user>.+)`)\n//\tm := NewMatch(t, r.FindStringSubmatch(s), r.SubexpNames())\n//\n//\tm.NamedSubmatch(\"host\").IsEqual(\"example.com\")\n//\tm.NamedSubmatch(\"user\").IsEqual(\"john\")\nfunc (m *Match) NamedSubmatch(name string) *String {\n\topChain := m.chain.enter(\"NamedSubmatch(%q)\", name)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tindex, ok := m.submatchNames[name]\n\tif !ok {\n\t\tnameList := make([]interface{}, 0, len(m.submatchNames))\n\t\tfor n := range m.submatchNames {\n\t\t\tnameList = append(nameList, n)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{name},\n\t\t\tExpected: &AssertionValue{AssertionList(nameList)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: existing sub-match name\"),\n\t\t\t},\n\t\t})\n\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, m.submatchValues[index])\n}\n\n// Deprecated: use Submatch instead.\nfunc (m *Match) Index(index int) *String {\n\treturn m.Submatch(index)\n}\n\n// Deprecated: use Submatch instead.\nfunc (m *Match) Name(name string) *String {\n\treturn m.NamedSubmatch(name)\n}\n\n// IsEmpty succeeds if submatches array is empty.\n//\n// Example:\n//\n//\tm := NewMatch(t, submatches, names)\n//\tm.IsEmpty()\nfunc (m *Match) IsEmpty() *Match {\n\topChain := m.chain.enter(\"IsEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn m\n\t}\n\n\tif !(len(m.submatchValues) == 0) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertEmpty,\n\t\t\tActual: &AssertionValue{m.submatchValues},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: empty sub-match list\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn m\n}\n\n// NotEmpty succeeds if submatches array is non-empty.\n//\n// Example:\n//\n//\tm := NewMatch(t, submatches, names)\n//\tm.NotEmpty()\nfunc (m *Match) NotEmpty() *Match {\n\topChain := m.chain.enter(\"NotEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn m\n\t}\n\n\tif !(len(m.submatchValues) != 0) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotEmpty,\n\t\t\tActual: &AssertionValue{m.submatchValues},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-empty sub-match list\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn m\n}\n\n// Deprecated: use IsEmpty instead.\nfunc (m *Match) Empty() *Match {\n\treturn m.IsEmpty()\n}\n\n// HasSubmatches succeeds if submatches array, starting from index 1, is equal to\n// given array.\n//\n// Note that submatch with index 0 contains the whole match and is not\n// included into this check.\n//\n// Example:\n//\n//\ts := \"http://example.com/users/john\"\n//\tr := regexp.MustCompile(`http://(.+)/users/(.+)`)\n//\tm := NewMatch(t, r.FindStringSubmatch(s), nil)\n//\tm.HasSubmatches(\"example.com\", \"john\")\nfunc (m *Match) HasSubmatches(submatchValues ...string) *Match {\n\topChain := m.chain.enter(\"HasSubmatches()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn m\n\t}\n\n\tif submatchValues == nil {\n\t\tsubmatchValues = []string{}\n\t}\n\n\tif !reflect.DeepEqual(submatchValues, m.getValues()) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{m.submatchValues},\n\t\t\tExpected: &AssertionValue{submatchValues},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: sub-match lists are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn m\n}\n\n// NotHasSubmatches succeeds if submatches array, starting from index 1, is not\n// equal to given array.\n//\n// Note that submatch with index 0 contains the whole match and is not\n// included into this check.\n//\n// Example:\n//\n//\ts := \"http://example.com/users/john\"\n//\tr := regexp.MustCompile(`http://(.+)/users/(.+)`)\n//\tm := NewMatch(t, r.FindStringSubmatch(s), nil)\n//\tm.NotHasSubmatches(\"example.com\", \"bob\")\nfunc (m *Match) NotHasSubmatches(submatchValues ...string) *Match {\n\topChain := m.chain.enter(\"NotHasSubmatches()\")\n\tdefer opChain.leave()\n\n\tif submatchValues == nil {\n\t\tsubmatchValues = []string{}\n\t}\n\n\tif reflect.DeepEqual(submatchValues, m.getValues()) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{m.submatchValues},\n\t\t\tExpected: &AssertionValue{submatchValues},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: sub-match lists are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn m\n}\n\n// Deprecated: use HasSubmatches instead.\nfunc (m *Match) Values(submatchValues ...string) *Match {\n\treturn m.HasSubmatches(submatchValues...)\n}\n\n// Deprecated: use NotHasSubmatches instead.\nfunc (m *Match) NotValues(submatchValues ...string) *Match {\n\treturn m.NotHasSubmatches(submatchValues...)\n}\n\nfunc (m *Match) getValues() []string {\n\tif len(m.submatchValues) > 1 {\n\t\treturn m.submatchValues[1:]\n\t}\n\treturn []string{}\n}\n"
        },
        {
          "name": "match_test.go",
          "type": "blob",
          "size": 5.576171875,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMatch_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\tvalue := newMatch(chain, nil, nil)\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Alias(\"foo\")\n\n\tvalue.Length().chain.assert(t, failure)\n\tvalue.Submatch(0).chain.assert(t, failure)\n\tvalue.NamedSubmatch(\"\").chain.assert(t, failure)\n\n\tvalue.IsEmpty()\n\tvalue.NotEmpty()\n\tvalue.HasSubmatches(\"\")\n\tvalue.NotHasSubmatches(\"\")\n}\n\nfunc TestMatch_Constructors(t *testing.T) {\n\tmatches := []string{\"m0\", \"m1\", \"m2\"}\n\tnames := []string{\"\", \"n1\", \"n2\"}\n\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewMatch(reporter, matches, names)\n\t\tassert.Equal(t, matches, value.Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewMatchC(Config{\n\t\t\tReporter: reporter,\n\t\t}, matches, names)\n\t\tassert.Equal(t, matches, value.Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newMatch(chain, matches, names)\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestMatch_Raw(t *testing.T) {\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewMatch(reporter, nil, nil)\n\n\t\tassert.NotNil(t, []string{}, value.Raw())\n\t\tassert.Equal(t, []string{}, value.Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"non-nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tdata := []string{\"foo\", \"bar\"}\n\n\t\tvalue := NewMatch(reporter, data, nil)\n\n\t\tassert.Equal(t, data, value.Raw())\n\t\tassert.NotSame(t, &data[0], &value.Raw()[0])\n\t\tvalue.chain.assert(t, success)\n\t})\n}\n\nfunc TestMatch_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tmatches := []string{\"m0\", \"m1\", \"m2\"}\n\tnames := []string{\"\", \"n1\", \"n2\"}\n\n\tvalue := NewMatch(reporter, matches, names)\n\tassert.Equal(t, []string{\"Match()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Match()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Match()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.Submatch(0)\n\tassert.Equal(t, []string{\"Match()\", \"Submatch(0)\"}, childValue.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\", \"Submatch(0)\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestMatch_Getters(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tmatches := []string{\"m0\", \"m1\", \"m2\"}\n\tnames := []string{\"\", \"n1\", \"n2\"}\n\n\tvalue := NewMatch(reporter, matches, names)\n\n\tassert.Equal(t, matches, value.Raw())\n\n\tassert.Equal(t, 3.0, value.Length().Raw())\n\n\tassert.Equal(t, \"m0\", value.Submatch(0).Raw())\n\tassert.Equal(t, \"m1\", value.Submatch(1).Raw())\n\tassert.Equal(t, \"m2\", value.Submatch(2).Raw())\n\tvalue.chain.assert(t, success)\n\n\tassert.Equal(t, \"m1\", value.NamedSubmatch(\"n1\").Raw())\n\tassert.Equal(t, \"m2\", value.NamedSubmatch(\"n2\").Raw())\n\tvalue.chain.assert(t, success)\n\n\tassert.Equal(t, \"\", value.Submatch(-1).Raw())\n\tvalue.chain.assert(t, failure)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, \"\", value.Submatch(3).Raw())\n\tvalue.chain.assert(t, failure)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, \"\", value.NamedSubmatch(\"\").Raw())\n\tvalue.chain.assert(t, failure)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, \"\", value.NamedSubmatch(\"bad\").Raw())\n\tvalue.chain.assert(t, failure)\n\tvalue.chain.clear()\n}\n\nfunc TestMatch_IsEmpty(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tsubmatch  []string\n\t\twantEmpty chainResult\n\t}{\n\t\t{\n\t\t\tname:      \"string\",\n\t\t\tsubmatch:  []string{\"m\"},\n\t\t\twantEmpty: failure,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty string slice\",\n\t\t\tsubmatch:  []string{},\n\t\t\twantEmpty: success,\n\t\t},\n\t\t{\n\t\t\tname:      \"nil\",\n\t\t\tsubmatch:  nil,\n\t\t\twantEmpty: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewMatch(reporter, tc.submatch, nil).IsEmpty().\n\t\t\t\tchain.assert(t, tc.wantEmpty)\n\n\t\t\tNewMatch(reporter, tc.submatch, nil).NotEmpty().\n\t\t\t\tchain.assert(t, !tc.wantEmpty)\n\n\t\t\tif tc.wantEmpty {\n\t\t\t\tassert.Equal(t, []string{},\n\t\t\t\t\tNewMatch(reporter, tc.submatch, nil).Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMatch_Values(t *testing.T) {\n\ttype wantMatch struct {\n\t\ttarget []string\n\t\tresult chainResult\n\t}\n\n\tcases := []struct {\n\t\tname       string\n\t\tsubmatches []string\n\t\twantMatch  []wantMatch\n\t}{\n\t\t{\n\t\t\tname:       \"nil match instance\",\n\t\t\tsubmatches: nil,\n\t\t\twantMatch: []wantMatch{\n\t\t\t\t{target: nil, result: success},\n\t\t\t\t{target: []string{\"\"}, result: failure},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"empty match instance\",\n\t\t\tsubmatches: []string{},\n\t\t\twantMatch: []wantMatch{\n\t\t\t\t{target: nil, result: success},\n\t\t\t\t{target: []string{\"\"}, result: failure},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"not empty index 0 only\",\n\t\t\tsubmatches: []string{\"m0\"},\n\t\t\twantMatch: []wantMatch{\n\t\t\t\t{target: nil, result: success},\n\t\t\t\t{target: []string{\"m0\"}, result: failure},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:       \"not empty\",\n\t\t\tsubmatches: []string{\"m0\", \"m1\", \"m2\"},\n\t\t\twantMatch: []wantMatch{\n\t\t\t\t{target: nil, result: failure},\n\t\t\t\t{target: []string{\"m1\"}, result: failure},\n\t\t\t\t{target: []string{\"m2\", \"m1\"}, result: failure},\n\t\t\t\t{target: []string{\"m1\", \"m2\"}, result: success},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tfor _, match := range tc.wantMatch {\n\t\t\t\tNewMatch(reporter, tc.submatches, nil).HasSubmatches(match.target...).\n\t\t\t\t\tchain.assert(t, match.result)\n\n\t\t\t\tNewMatch(reporter, tc.submatches, nil).NotHasSubmatches(match.target...).\n\t\t\t\t\tchain.assert(t, !match.result)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "mocks_test.go",
          "type": "blob",
          "size": 6.9033203125,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n)\n\n// mock config\nfunc newMockConfig(r Reporter) Config {\n\treturn Config{Reporter: r}.withDefaults()\n}\n\n// mock chain\nfunc newMockChain(t *testing.T, flag ...chainFlags) *chain {\n\treturn newChainWithDefaults(\"test\", newMockReporter(t), flag...)\n}\n\n// mock logger\ntype mockLogger struct {\n\ttesting     *testing.T\n\tlogged      bool\n\tlastMessage string\n}\n\nfunc newMockLogger(t *testing.T) *mockLogger {\n\treturn &mockLogger{testing: t}\n}\n\nfunc (ml *mockLogger) Logf(message string, args ...interface{}) {\n\tml.testing.Logf(message, args...)\n\tml.lastMessage = fmt.Sprintf(message, args...)\n\tml.logged = true\n}\n\n// mock reporter\ntype mockReporter struct {\n\ttesting      *testing.T\n\treported     bool\n\treportCalled int\n\treportCb     func()\n}\n\nfunc newMockReporter(t *testing.T) *mockReporter {\n\treturn &mockReporter{testing: t}\n}\n\nfunc (mr *mockReporter) Errorf(message string, args ...interface{}) {\n\tmr.testing.Logf(\"Fail: \"+message, args...)\n\tmr.reported = true\n\tmr.reportCalled++\n\n\tif mr.reportCb != nil {\n\t\tmr.reportCb()\n\t}\n}\n\n// mock formatter\ntype mockFormatter struct {\n\ttesting          *testing.T\n\tformattedSuccess int\n\tformattedFailure int\n}\n\nfunc newMockFormatter(t *testing.T) *mockFormatter {\n\treturn &mockFormatter{testing: t}\n}\n\nfunc (mf *mockFormatter) FormatSuccess(ctx *AssertionContext) string {\n\tmf.formattedSuccess++\n\treturn ctx.TestName\n}\n\nfunc (mf *mockFormatter) FormatFailure(\n\tctx *AssertionContext, failure *AssertionFailure,\n) string {\n\tmf.formattedFailure++\n\treturn ctx.TestName\n}\n\n// mock assertion handler\ntype mockAssertionHandler struct {\n\tctx           *AssertionContext\n\tfailure       *AssertionFailure\n\tsuccessCalled int\n\tfailureCalled int\n\tassertionCb   func()\n}\n\nfunc (mh *mockAssertionHandler) Success(ctx *AssertionContext) {\n\tmh.ctx = ctx\n\tmh.successCalled++\n\n\tif mh.assertionCb != nil {\n\t\tmh.assertionCb()\n\t}\n}\n\nfunc (mh *mockAssertionHandler) Failure(\n\tctx *AssertionContext, failure *AssertionFailure,\n) {\n\tmh.ctx = ctx\n\tmh.failure = failure\n\tmh.failureCalled++\n\n\tif mh.assertionCb != nil {\n\t\tmh.assertionCb()\n\t}\n}\n\n// mock websocket printer\ntype mockWebsocketPrinter struct {\n\tisWrittenTo bool\n\tisReadFrom  bool\n}\n\nfunc (mp *mockWebsocketPrinter) Request(*http.Request) {\n}\n\nfunc (mp *mockWebsocketPrinter) Response(*http.Response, time.Duration) {\n}\n\nfunc (mp *mockWebsocketPrinter) WebsocketWrite(typ int, content []byte, closeCode int) {\n\tmp.isWrittenTo = true\n}\n\nfunc (mp *mockWebsocketPrinter) WebsocketRead(typ int, content []byte, closeCode int) {\n\tmp.isReadFrom = true\n}\n\n// mock websocket connection\ntype mockWebsocketConn struct {\n\tsubprotocol  string\n\tcloseError   error\n\treadMsgErr   error\n\twriteMsgErr  error\n\treadDlError  error\n\twriteDlError error\n\tmsgType      int\n\tmsg          []byte\n}\n\nfunc (mc *mockWebsocketConn) Subprotocol() string {\n\treturn mc.subprotocol\n}\n\nfunc (mc *mockWebsocketConn) Close() error {\n\treturn mc.closeError\n}\n\nfunc (mc *mockWebsocketConn) SetReadDeadline(t time.Time) error {\n\treturn mc.readDlError\n}\n\nfunc (mc *mockWebsocketConn) SetWriteDeadline(t time.Time) error {\n\treturn mc.writeDlError\n}\n\nfunc (mc *mockWebsocketConn) ReadMessage() (messageType int, p []byte, err error) {\n\treturn mc.msgType, []byte{}, mc.readMsgErr\n}\n\nfunc (mc *mockWebsocketConn) WriteMessage(messageType int, data []byte) error {\n\treturn mc.writeMsgErr\n}\n\n// mock http client\ntype mockClient struct {\n\treq  *http.Request\n\tresp http.Response\n\terr  error\n\tcb   func(req *http.Request)\n}\n\nfunc (c *mockClient) Do(req *http.Request) (*http.Response, error) {\n\tdefer func() {\n\t\tif c.cb != nil {\n\t\t\tc.cb(req)\n\t\t}\n\t}()\n\tc.req = req\n\tif c.err == nil {\n\t\tc.resp.Header = c.req.Header\n\t\tc.resp.Body = c.req.Body\n\t\treturn &c.resp, nil\n\t}\n\treturn nil, c.err\n}\n\n// mock http redirecting transport\ntype mockRedirectTransport struct {\n\t// assertFn asserts the HTTP request\n\tassertFn func(*http.Request)\n\n\t// redirectHTTPStatusCode indicates the HTTP status code of redirection response\n\tredirectHTTPStatusCode int\n\n\t// tripCount tracks the number of trip that has been done\n\t//\n\t// When tripCount < maxRedirect,\n\t// mockTransportRedirect responses with redirectHTTPStatusCode\n\t//\n\t// When tripCount = maxRedirect,\n\t// mockTransportRedirect responses with HTTP 200 OK\n\ttripCount int\n\n\t// maxRedirects indicates the number of trip that can be done for redirection.\n\t// -1 means always redirect.\n\tmaxRedirects int\n}\n\nfunc newMockRedirectTransport() *mockRedirectTransport {\n\treturn &mockRedirectTransport{\n\t\tredirectHTTPStatusCode: http.StatusPermanentRedirect,\n\t\tmaxRedirects:           -1,\n\t}\n}\n\nfunc (mt *mockRedirectTransport) RoundTrip(origReq *http.Request) (\n\t*http.Response, error,\n) {\n\tmt.tripCount++\n\n\tif mt.assertFn != nil {\n\t\tmt.assertFn(origReq)\n\t}\n\n\tres := httptest.NewRecorder()\n\n\tif mt.maxRedirects == -1 || mt.tripCount <= mt.maxRedirects {\n\t\tres.Result().StatusCode = mt.redirectHTTPStatusCode\n\t\tres.Result().Header.Set(\"Location\", \"/redirect\")\n\t} else {\n\t\tres.Result().StatusCode = http.StatusOK\n\t}\n\n\treturn res.Result(), nil\n}\n\n// mock http request factory\ntype mockRequestFactory struct {\n\tlastreq *http.Request\n\tfail    bool\n}\n\nfunc (mf *mockRequestFactory) NewRequest(\n\tmethod, urlStr string, body io.Reader) (*http.Request, error) {\n\tif mf.fail {\n\t\treturn nil, errors.New(\"testRequestFactory\")\n\t}\n\tmf.lastreq = httptest.NewRequest(method, urlStr, body)\n\treturn mf.lastreq, nil\n}\n\n// mock http request or response body\ntype mockBody struct {\n\treader io.Reader\n\n\treadCount int\n\treadErr   error\n\n\tcloseCount int\n\tcloseErr   error\n\n\terrCount int\n\teofCount int\n}\n\nfunc newMockBody(body string) *mockBody {\n\treturn &mockBody{\n\t\treader: bytes.NewBufferString(body),\n\t}\n}\n\nfunc (mb *mockBody) Read(p []byte) (int, error) {\n\tmb.readCount++\n\n\tif mb.readErr != nil {\n\t\treturn 0, mb.readErr\n\t}\n\n\tn, err := mb.reader.Read(p)\n\tif err == io.EOF {\n\t\tmb.eofCount++\n\t} else if err != nil {\n\t\tmb.errCount++\n\t}\n\n\treturn n, err\n}\n\nfunc (mb *mockBody) Close() error {\n\tmb.closeCount++\n\n\tif mb.closeErr != nil {\n\t\treturn mb.closeErr\n\t}\n\n\treturn nil\n}\n\n// mock query string encoder (query.Encoder.EncodeValues)\ntype mockQueryEncoder string\n\nfunc (mq mockQueryEncoder) EncodeValues(key string, v *url.Values) error {\n\tif mq == \"err\" {\n\t\treturn errors.New(\"encoding error\")\n\t}\n\tv.Set(key, string(mq))\n\treturn nil\n}\n\n// mock io.Writer\ntype mockWriter struct {\n\tio.Writer\n\terr error\n}\n\nfunc (mw *mockWriter) Write(p []byte) (n int, err error) {\n\tif mw.err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn mw.Writer.Write(p)\n}\n\n// mock network error\ntype mockNetError struct {\n\tisTimeout   bool\n\tisTemporary bool\n}\n\nfunc (me *mockNetError) Error() string {\n\treturn \"mock net error\"\n}\n\nfunc (me *mockNetError) Timeout() bool {\n\treturn me.isTimeout\n}\n\nfunc (me *mockNetError) Temporary() bool {\n\treturn me.isTemporary\n}\n\n// mock custom error\ntype mockError struct{}\n\nfunc (me *mockError) Error() string {\n\treturn \"mock error\"\n}\n\n// mock sleep function\nfunc mockSleep(time.Duration) <-chan time.Time {\n\treturn time.After(0)\n}\n"
        },
        {
          "name": "nocopy.go",
          "type": "blob",
          "size": 0.501953125,
          "content": "package httpexpect\n\n// noCopy struct is a special type that is used to prevent a value from being copied.\n// `go vet` gives a warning if it finds that a struct with a field of\n// this type is being copied.\n// To enable this behavior, this struct provides two methods `Lock` and `Unlock,\n// that do not do anything.\n// See more details here:\n//   https://github.com/golang/go/issues/8005\n//   https://stackoverflow.com/questions/52494458\n\ntype noCopy struct{}\n\nfunc (*noCopy) Lock()   {}\nfunc (*noCopy) Unlock() {}\n"
        },
        {
          "name": "nocopy_test.go",
          "type": "blob",
          "size": 0.1171875,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNoCopy(t *testing.T) {\n\tvar n noCopy\n\n\tn.Lock()\n\tdefer n.Unlock()\n}\n"
        },
        {
          "name": "number.go",
          "type": "blob",
          "size": 30.28515625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n)\n\n// Number provides methods to inspect attached float64 value\n// (Go representation of JSON number).\ntype Number struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  float64\n}\n\n// NewNumber returns a new Number instance.\n//\n// If reporter is nil, the function panics.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123.4)\nfunc NewNumber(reporter Reporter, value float64) *Number {\n\treturn newNumber(newChainWithDefaults(\"Number()\", reporter), value)\n}\n\n// NewNumberC returns a new Number instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// Example:\n//\n//\tnumber := NewNumberC(config, 123.4)\nfunc NewNumberC(config Config, value float64) *Number {\n\treturn newNumber(newChainWithConfig(\"Number()\", config.withDefaults()), value)\n}\n\nfunc newNumber(parent *chain, val float64) *Number {\n\treturn &Number{chain: parent.clone(), value: val}\n}\n\n// Raw returns underlying value attached to Number.\n// This is the value originally passed to NewNumber.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123.4)\n//\tassert.Equal(t, 123.4, number.Raw())\nfunc (n *Number) Raw() float64 {\n\treturn n.value\n}\n\n// Decode unmarshals the underlying value attached to the Number to a target variable.\n// target should be one of these:\n//\n//   - pointer to an empty interface\n//   - pointer to any integer or floating type\n//\n// Example:\n//\n//\tvalue := NewNumber(t, 123)\n//\n//\tvar target interface{}\n//\tvalude.decode(&target)\n//\n//\tassert.Equal(t, 123, target)\nfunc (n *Number) Decode(target interface{}) *Number {\n\topChain := n.chain.enter(\"Decode()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tcanonDecode(opChain, n.value, target)\n\treturn n\n}\n\n// Alias is similar to Value.Alias.\nfunc (n *Number) Alias(name string) *Number {\n\topChain := n.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tn.chain.setAlias(name)\n\treturn n\n}\n\n// Path is similar to Value.Path.\nfunc (n *Number) Path(path string) *Value {\n\topChain := n.chain.enter(\"Path(%q)\", path)\n\tdefer opChain.leave()\n\n\treturn jsonPath(opChain, n.value, path)\n}\n\n// Schema is similar to Value.Schema.\nfunc (n *Number) Schema(schema interface{}) *Number {\n\topChain := n.chain.enter(\"Schema()\")\n\tdefer opChain.leave()\n\n\tjsonSchema(opChain, n.value, schema)\n\treturn n\n}\n\n// IsEqual succeeds if number is equal to given value.\n//\n// value should have numeric type convertible to float64. Before comparison,\n// it is converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.IsEqual(float64(123))\n//\tnumber.IsEqual(int32(123))\nfunc (n *Number) IsEqual(value interface{}) *Number {\n\topChain := n.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tnum, ok := canonNumber(opChain, value)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif !(n.value == num) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{num},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// NotEqual succeeds if number is not equal to given value.\n//\n// value should have numeric type convertible to float64. Before comparison,\n// it is converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.NotEqual(float64(321))\n//\tnumber.NotEqual(int32(321))\nfunc (n *Number) NotEqual(value interface{}) *Number {\n\topChain := n.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tnum, ok := canonNumber(opChain, value)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif n.value == num {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{num},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// Deprecated: use IsEqual instead.\nfunc (n *Number) Equal(value interface{}) *Number {\n\treturn n.IsEqual(value)\n}\n\n// InDelta succeeds if two numerals are within delta of each other.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123.0)\n//\tnumber.InDelta(123.2, 0.3)\nfunc (n *Number) InDelta(value, delta float64) *Number {\n\topChain := n.chain.enter(\"InDelta()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif math.IsNaN(delta) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected NaN delta argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif math.IsNaN(n.value) || math.IsNaN(value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{delta},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers are comparable\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tdiff := n.value - value\n\n\tif diff < -delta || diff > delta {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{delta},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers lie within delta\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\treturn n\n}\n\n// NotInDelta succeeds if two numerals are not within delta of each other.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123.0)\n//\tnumber.NotInDelta(123.2, 0.1)\nfunc (n *Number) NotInDelta(value, delta float64) *Number {\n\topChain := n.chain.enter(\"NotInDelta()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif math.IsNaN(delta) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected NaN delta argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif math.IsNaN(n.value) || math.IsNaN(value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{delta},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers are comparable\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tdiff := n.value - value\n\n\tif !(diff < -delta || diff > delta) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{delta},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers do not lie within delta\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\treturn n\n}\n\n// Deprecated: use InDelta instead.\nfunc (n *Number) EqualDelta(value, delta float64) *Number {\n\treturn n.InDelta(value, delta)\n}\n\n// Deprecated: use NotInDelta instead.\nfunc (n *Number) NotEqualDelta(value, delta float64) *Number {\n\treturn n.NotInDelta(value, delta)\n}\n\n// InDeltaRelative succeeds if two numbers are within relative delta of each other.\n//\n// The relative delta is expressed as a decimal. For example, to determine if a number\n// and a value are within 1% of each other, use 0.01.\n//\n// A number and a value are within relative delta if\n// Abs(number-value) / Abs(number) < relative delta.\n//\n// Please note that number, value, and delta can't be NaN, number and value can't\n// be opposite Inf and delta cannot be Inf.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123.0)\n//\tnumber.InDeltaRelative(126.5, 0.03)\nfunc (n *Number) InDeltaRelative(value, delta float64) *Number {\n\topChain := n.chain.enter(\"InDeltaRelative()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif math.IsNaN(delta) || math.IsInf(delta, 0) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected non-number delta argument: %v\", delta),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif delta < 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected negative delta argument: %v\", delta),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\t// Fail if any of the numbers is NaN with specific error message\n\tanyNumIsNaN := math.IsNaN(n.value) || math.IsNaN(value)\n\tif anyNumIsNaN {\n\t\tvar assertionErrors []error\n\t\tassertionErrors = append(\n\t\t\tassertionErrors,\n\t\t\terrors.New(\"expected: can compare values with relative delta\"),\n\t\t)\n\t\tif math.IsNaN(n.value) {\n\t\t\tassertionErrors = append(\n\t\t\t\tassertionErrors,\n\t\t\t\terrors.New(\"actual value is NaN\"),\n\t\t\t)\n\t\t}\n\t\tif math.IsNaN(value) {\n\t\t\tassertionErrors = append(\n\t\t\t\tassertionErrors,\n\t\t\t\terrors.New(\"expected value is NaN\"),\n\t\t\t)\n\t\t}\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{relativeDelta(delta)},\n\t\t\tErrors:   assertionErrors,\n\t\t})\n\t\treturn n\n\t}\n\n\t// Pass if number and value are +-Inf and equal,\n\t// regardless if delta is 0 or positive number\n\tsameInfNumCheck := math.IsInf(n.value, 0) && math.IsInf(value, 0) && value == n.value\n\tif sameInfNumCheck {\n\t\treturn n\n\t}\n\n\t// Fail if number and value are +=Inf and unequal with specific error message\n\tdiffInfNumCheck := math.IsInf(n.value, 0) && math.IsInf(value, 0) && value != n.value\n\tif diffInfNumCheck {\n\t\tvar assertionErrors []error\n\t\tassertionErrors = append(\n\t\t\tassertionErrors,\n\t\t\terrors.New(\"expected: can compare values with relative delta\"),\n\t\t\terrors.New(\"actual value and expected value are opposite Infs\"),\n\t\t)\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{relativeDelta(delta)},\n\t\t\tErrors:   assertionErrors,\n\t\t})\n\t\treturn n\n\t}\n\n\t// Normal comparison after filtering out all corner cases\n\tdeltaRelativeError := deltaRelativeErrorCheck(true, n.value, value, delta)\n\tif deltaRelativeError {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{relativeDelta(delta)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers lie within relative delta\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\treturn n\n}\n\n// NotInDeltaRelative succeeds if two numbers aren't within relative delta of each other.\n//\n// The relative delta is expressed as a decimal. For example, to determine if a number\n// and a value are within 1% of each other, use 0.01.\n//\n// A number and a value are within relative delta if\n// Abs(number-value) / Abs(number) < relative delta.\n//\n// Please note that number, value, and delta can't be NaN, number and value can't\n// be opposite Inf and delta cannot be Inf.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123.0)\n//\tnumber.NotInDeltaRelative(126.5, 0.01)\nfunc (n *Number) NotInDeltaRelative(value, delta float64) *Number {\n\topChain := n.chain.enter(\"NotInDeltaRelative()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif math.IsNaN(delta) || math.IsInf(delta, 0) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected non-number delta argument: %v\", delta),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif delta < 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected negative delta argument: %v\", delta),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\t// Fail if any of the numbers is NaN with specific error message\n\tanyNumIsNaN := math.IsNaN(n.value) || math.IsNaN(value)\n\tif anyNumIsNaN {\n\t\tvar assertionErrors []error\n\t\tassertionErrors = append(\n\t\t\tassertionErrors,\n\t\t\terrors.New(\"expected: can compare values with relative delta\"),\n\t\t)\n\t\tif math.IsNaN(n.value) {\n\t\t\tassertionErrors = append(\n\t\t\t\tassertionErrors,\n\t\t\t\terrors.New(\"actual value is NaN\"),\n\t\t\t)\n\t\t}\n\t\tif math.IsNaN(value) {\n\t\t\tassertionErrors = append(\n\t\t\t\tassertionErrors,\n\t\t\t\terrors.New(\"expected value is NaN\"),\n\t\t\t)\n\t\t}\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{relativeDelta(delta)},\n\t\t\tErrors:   assertionErrors,\n\t\t})\n\t\treturn n\n\t}\n\n\t// Fail if number and value are +-Inf and equal,\n\t// regardless if delta is 0 or positive number\n\tsameInfNumCheck := math.IsInf(n.value, 0) && math.IsInf(value, 0) && value == n.value\n\tif sameInfNumCheck {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{relativeDelta(delta)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers lie within relative delta\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\t// Pass if number and value are +=Inf and unequal\n\tdiffInfNumCheck := math.IsInf(n.value, 0) && math.IsInf(value, 0) && value != n.value\n\tif diffInfNumCheck {\n\t\treturn n\n\t}\n\n\t// Normal comparison after filtering out all corner cases\n\tdeltaRelativeError := deltaRelativeErrorCheck(false, n.value, value, delta)\n\tif deltaRelativeError {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tDelta:    &AssertionValue{relativeDelta(delta)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: numbers lie within relative delta\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\treturn n\n}\n\n// InRange succeeds if number is within given range [min; max].\n//\n// min and max should have numeric type convertible to float64. Before comparison,\n// they are converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.InRange(float32(100), int32(200))  // success\n//\tnumber.InRange(100, 200)                  // success\n//\tnumber.InRange(123, 123)                  // success\nfunc (n *Number) InRange(min, max interface{}) *Number {\n\topChain := n.chain.enter(\"InRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\ta, ok := canonNumber(opChain, min)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tb, ok := canonNumber(opChain, max)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif !(n.value >= a && n.value <= b) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertInRange,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{AssertionRange{a, b}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is within given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// NotInRange succeeds if number is not within given range [min; max].\n//\n// min and max should have numeric type convertible to float64. Before comparison,\n// they are converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 100)\n//\tnumber.NotInRange(0, 99)\n//\tnumber.NotInRange(101, 200)\nfunc (n *Number) NotInRange(min, max interface{}) *Number {\n\topChain := n.chain.enter(\"NotInRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\ta, ok := canonNumber(opChain, min)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tb, ok := canonNumber(opChain, max)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif n.value >= a && n.value <= b {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotInRange,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{AssertionRange{a, b}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is not within given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// InList succeeds if the number is equal to one of the values from given list\n// of numbers. Before comparison, each value is converted to canonical form.\n//\n// Each value should be numeric type convertible to float64. If at least one\n// value has wrong type, failure is reported.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.InList(float64(123), int32(123))\nfunc (n *Number) InList(values ...interface{}) *Number {\n\topChain := n.chain.enter(\"IsList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\tnum, ok := canonNumber(opChain, v)\n\t\tif !ok {\n\t\t\treturn n\n\t\t}\n\n\t\tif n.value == num {\n\t\t\tisListed = true\n\t\t\t// continue loop to check that all values are correct\n\t\t}\n\t}\n\n\tif !isListed {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// NotInList succeeds if the number is not equal to any of the values from given\n// list of numbers. Before comparison, each value is converted to canonical form.\n//\n// Each value should be numeric type convertible to float64. If at least one\n// value has wrong type, failure is reported.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.NotInList(float64(456), int32(456))\nfunc (n *Number) NotInList(values ...interface{}) *Number {\n\topChain := n.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tfor _, v := range values {\n\t\tnum, ok := canonNumber(opChain, v)\n\t\tif !ok {\n\t\t\treturn n\n\t\t}\n\n\t\tif n.value == num {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{n.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: number is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn n\n\t\t}\n\t}\n\n\treturn n\n}\n\n// Gt succeeds if number is greater than given value.\n//\n// value should have numeric type convertible to float64. Before comparison,\n// it is converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.Gt(float64(122))\n//\tnumber.Gt(int32(122))\nfunc (n *Number) Gt(value interface{}) *Number {\n\topChain := n.chain.enter(\"Gt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tnum, ok := canonNumber(opChain, value)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif !(n.value > num) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertGt,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{num},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is larger than given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// Ge succeeds if number is greater than or equal to given value.\n//\n// value should have numeric type convertible to float64. Before comparison,\n// it is converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.Ge(float64(122))\n//\tnumber.Ge(int32(122))\nfunc (n *Number) Ge(value interface{}) *Number {\n\topChain := n.chain.enter(\"Ge()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tnum, ok := canonNumber(opChain, value)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif !(n.value >= num) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertGe,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{num},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is larger than or equal to given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// Lt succeeds if number is lesser than given value.\n//\n// value should have numeric type convertible to float64. Before comparison,\n// it is converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.Lt(float64(124))\n//\tnumber.Lt(int32(124))\nfunc (n *Number) Lt(value interface{}) *Number {\n\topChain := n.chain.enter(\"Lt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tnum, ok := canonNumber(opChain, value)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif !(n.value < num) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertLt,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{num},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is less than given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// Le succeeds if number is lesser than or equal to given value.\n//\n// value should have numeric type convertible to float64. Before comparison,\n// it is converted to float64.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 123)\n//\tnumber.Le(float64(124))\n//\tnumber.Le(int32(124))\nfunc (n *Number) Le(value interface{}) *Number {\n\topChain := n.chain.enter(\"Le()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tnum, ok := canonNumber(opChain, value)\n\tif !ok {\n\t\treturn n\n\t}\n\n\tif !(n.value <= num) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertLe,\n\t\t\tActual:   &AssertionValue{n.value},\n\t\t\tExpected: &AssertionValue{num},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is less than or equal to given value\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn n\n}\n\n// IsInt succeeds if number is a signed integer of the specified bit width\n// as an optional argument.\n//\n// Bits argument defines maximum allowed bitness for the given number.\n// If bits is omitted, boundary check is omitted too.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 1000000)\n//\tnumber.IsInt()   // success\n//\tnumber.IsInt(32) // success\n//\tnumber.IsInt(16) // failure\n//\n//\tnumber := NewNumber(t, -1000000)\n//\tnumber.IsInt()   // success\n//\tnumber.IsInt(32) // success\n//\tnumber.IsInt(16) // failure\n//\n//\tnumber := NewNumber(t, 0.5)\n//\tnumber.IsInt()   // failure\nfunc (n *Number) IsInt(bits ...int) *Number {\n\topChain := n.chain.enter(\"IsInt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif len(bits) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple bits arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif len(bits) == 1 && bits[0] <= 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected non-positive bits argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif math.IsNaN(n.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is signed integer\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tinum, acc := big.NewFloat(n.value).Int(nil)\n\tif !(acc == big.Exact) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is signed integer\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif len(bits) > 0 {\n\t\tbitSize := bits[0]\n\n\t\timax := new(big.Int)\n\t\timax.Lsh(big.NewInt(1), uint(bitSize-1))\n\t\timax.Sub(imax, big.NewInt(1))\n\t\timin := new(big.Int)\n\t\timin.Neg(imax)\n\t\timin.Sub(imin, big.NewInt(1))\n\t\tif inum.Cmp(imin) < 0 || inum.Cmp(imax) > 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertInRange,\n\t\t\t\tActual: &AssertionValue{n.value},\n\t\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\t\tMin: intBoundary{imin, -1, bitSize - 1},\n\t\t\t\t\tMax: intBoundary{imax, +1, bitSize - 1},\n\t\t\t\t}},\n\t\t\t\tErrors: []error{\n\t\t\t\t\tfmt.Errorf(\"expected: number is %d-bit signed integer\", bitSize),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn n\n\t\t}\n\t}\n\n\treturn n\n}\n\n// NotInt succeeds if number is not a signed integer of the specified bit\n// width as an optional argument.\n//\n// Bits argument defines maximum allowed bitness for the given number.\n// If bits is omitted, boundary check is omitted too.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 1000000)\n//\tnumber.NotInt()   // failure\n//\tnumber.NotInt(32) // failure\n//\tnumber.NotInt(16) // success\n//\n//\tnumber := NewNumber(t, -1000000)\n//\tnumber.NotInt()   // failure\n//\tnumber.NotInt(32) // failure\n//\tnumber.NotInt(16) // success\n//\n//\tnumber := NewNumber(t, 0.5)\n//\tnumber.NotInt()   // success\nfunc (n *Number) NotInt(bits ...int) *Number {\n\topChain := n.chain.enter(\"NotInt()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif len(bits) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple bits arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif len(bits) == 1 && bits[0] <= 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected non-positive bits argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif !math.IsNaN(n.value) {\n\t\tinum, acc := big.NewFloat(n.value).Int(nil)\n\t\tif acc == big.Exact {\n\t\t\tif len(bits) == 0 {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType:   AssertValid,\n\t\t\t\t\tActual: &AssertionValue{n.value},\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\terrors.New(\"expected: number is not signed integer\"),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn n\n\t\t\t}\n\n\t\t\tbitSize := bits[0]\n\t\t\timax := new(big.Int)\n\t\t\timax.Lsh(big.NewInt(1), uint(bitSize-1))\n\t\t\timax.Sub(imax, big.NewInt(1))\n\t\t\timin := new(big.Int)\n\t\t\timin.Neg(imax)\n\t\t\timin.Sub(imin, big.NewInt(1))\n\t\t\tif !(inum.Cmp(imin) < 0 || inum.Cmp(imax) > 0) {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType:   AssertNotInRange,\n\t\t\t\t\tActual: &AssertionValue{n.value},\n\t\t\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\t\t\tMin: intBoundary{imin, -1, bitSize - 1},\n\t\t\t\t\t\tMax: intBoundary{imax, +1, bitSize - 1},\n\t\t\t\t\t}},\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\t\t\"expected: number doesn't fit %d-bit signed integer\",\n\t\t\t\t\t\t\tbitSize),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n\n}\n\n// IsUint succeeds if number is an unsigned integer of the specified bit\n// width as an optional argument.\n//\n// Bits argument defines maximum allowed bitness for the given number.\n// If bits is omitted, boundary check is omitted too.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 1000000)\n//\tnumber.IsUint()   // success\n//\tnumber.IsUint(32) // success\n//\tnumber.IsUint(16) // failure\n//\n//\tnumber := NewNumber(t, -1000000)\n//\tnumber.IsUint()   // failure\n//\tnumber.IsUint(32) // failure\n//\tnumber.IsUint(16) // failure\n//\n//\tnumber := NewNumber(t, 0.5)\n//\tnumber.IsUint()   // failure\nfunc (n *Number) IsUint(bits ...int) *Number {\n\topChain := n.chain.enter(\"IsUint()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif len(bits) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple bits arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif len(bits) == 1 && bits[0] <= 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected non-positive bits argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif math.IsNaN(n.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is unsigned integer\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tinum, acc := big.NewFloat(n.value).Int(nil)\n\tif !(acc == big.Exact) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is unsigned integer\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\timin := big.NewInt(0)\n\tif inum.Cmp(imin) < 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is unsigned integer\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif len(bits) > 0 {\n\t\tbitSize := bits[0]\n\t\timax := new(big.Int)\n\t\timax.Lsh(big.NewInt(1), uint(bitSize))\n\t\timax.Sub(imax, big.NewInt(1))\n\t\tif inum.Cmp(imax) > 0 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertInRange,\n\t\t\t\tActual: &AssertionValue{n.value},\n\t\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\t\tMin: intBoundary{imin, 0, 0},\n\t\t\t\t\tMax: intBoundary{imax, +1, bitSize},\n\t\t\t\t}},\n\t\t\t\tErrors: []error{\n\t\t\t\t\tfmt.Errorf(\"expected: number fits %d-bit unsigned integer\", bitSize),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn n\n\t\t}\n\t}\n\n\treturn n\n}\n\n// NotUint succeeds if number is not an unsigned integer of the specified bit\n// width as an optional argument.\n//\n// Bits argument defines maximum allowed bitness for the given number.\n// If bits is omitted, boundary check is omitted too.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 1000000)\n//\tnumber.NotUint()   // failure\n//\tnumber.NotUint(32) // failure\n//\tnumber.NotUint(16) // success\n//\n//\tnumber := NewNumber(t, -1000000)\n//\tnumber.NotUint()   // success\n//\tnumber.NotUint(32) // success\n//\tnumber.NotUint(16) // success\n//\n//\tnumber := NewNumber(t, 0.5)\n//\tnumber.NotUint()   // success\nfunc (n *Number) NotUint(bits ...int) *Number {\n\topChain := n.chain.enter(\"NotUint()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif len(bits) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple bits arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif len(bits) == 1 && bits[0] <= 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected non-positive bits argument\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\tif !math.IsNaN(n.value) {\n\t\tinum, acc := big.NewFloat(n.value).Int(nil)\n\t\tif acc == big.Exact {\n\t\t\timin := big.NewInt(0)\n\t\t\tif inum.Cmp(imin) >= 0 {\n\t\t\t\tif len(bits) == 0 {\n\t\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\t\tType:   AssertValid,\n\t\t\t\t\t\tActual: &AssertionValue{n.value},\n\t\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\t\terrors.New(\"expected: number is not unsigned integer\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t\treturn n\n\t\t\t\t}\n\n\t\t\t\tbitSize := bits[0]\n\t\t\t\timax := new(big.Int)\n\t\t\t\timax.Lsh(big.NewInt(1), uint(bitSize))\n\t\t\t\timax.Sub(imax, big.NewInt(1))\n\t\t\t\tif inum.Cmp(imax) <= 0 {\n\t\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\t\tType:   AssertNotInRange,\n\t\t\t\t\t\tActual: &AssertionValue{n.value},\n\t\t\t\t\t\tExpected: &AssertionValue{AssertionRange{\n\t\t\t\t\t\t\tMin: intBoundary{imin, 0, 0},\n\t\t\t\t\t\t\tMax: intBoundary{imax, +1, bitSize},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\t\t\t\"expected: number doesn't fit %d-bit unsigned integer\",\n\t\t\t\t\t\t\t\tbitSize),\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t\treturn n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n\n}\n\n// IsFinite succeeds if number is neither ±Inf nor NaN.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 1234.5)\n//\tnumber.IsFinite() // success\n//\n//\tnumber := NewNumber(t, math.NaN())\n//\tnumber.IsFinite() // failure\n//\n//\tnumber := NewNumber(t, math.Inf(+1))\n//\tnumber.IsFinite() // failure\nfunc (n *Number) IsFinite() *Number {\n\topChain := n.chain.enter(\"IsFinite()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif math.IsInf(n.value, 0) || math.IsNaN(n.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is neither ±Inf nor NaN\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\treturn n\n}\n\n// NotFinite succeeds if number is either ±Inf or NaN.\n//\n// Example:\n//\n//\tnumber := NewNumber(t, 1234.5)\n//\tnumber.NotFinite() // failure\n//\n//\tnumber := NewNumber(t, math.NaN())\n//\tnumber.NotFinite() // success\n//\n//\tnumber := NewNumber(t, math.Inf(+1))\n//\tnumber.NotFinite() // success\nfunc (n *Number) NotFinite() *Number {\n\topChain := n.chain.enter(\"NotFinite()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn n\n\t}\n\n\tif !(math.IsInf(n.value, 0) || math.IsNaN(n.value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{n.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: number is either ±Inf or NaN\"),\n\t\t\t},\n\t\t})\n\t\treturn n\n\t}\n\n\treturn n\n}\n\ntype intBoundary struct {\n\tval  *big.Int\n\tsign int\n\tbits int\n}\n\nfunc (b intBoundary) String() string {\n\tif b.sign > 0 {\n\t\treturn fmt.Sprintf(\"+2^%d-1 (+%s)\", b.bits, b.val)\n\t} else if b.sign < 0 {\n\t\treturn fmt.Sprintf(\"-2^%d   (%s)\", b.bits, b.val)\n\t}\n\treturn fmt.Sprintf(\"%s\", b.val)\n}\n\ntype relativeDelta float64\n\nfunc (rd relativeDelta) String() string {\n\treturn fmt.Sprintf(\"%v (%.f%%)\", float64(rd), rd*100)\n}\n\nfunc deltaRelativeErrorCheck(inDeltaRelative bool, number, value, delta float64) bool {\n\tif (number == 0 || math.IsInf(number, 0)) && value != number {\n\t\treturn true\n\t}\n\tif math.Abs(number-value)/math.Abs(number) > delta {\n\t\tif inDeltaRelative {\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\tif !(inDeltaRelative) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "number_test.go",
          "type": "blob",
          "size": 26.5859375,
          "content": "package httpexpect\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNumber_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\tvalue := newNumber(chain, 0)\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Path(\"$\").chain.assert(t, failure)\n\tvalue.Schema(\"\")\n\tvalue.Alias(\"foo\")\n\n\tvar target interface{}\n\tvalue.Decode(&target)\n\n\tvalue.IsEqual(0)\n\tvalue.NotEqual(0)\n\tvalue.InDelta(0, 0)\n\tvalue.NotInDelta(0, 0)\n\tvalue.InDeltaRelative(0, 0)\n\tvalue.NotInDeltaRelative(0, 0)\n\tvalue.InRange(0, 0)\n\tvalue.NotInRange(0, 0)\n\tvalue.InList(0)\n\tvalue.NotInList(0)\n\tvalue.Gt(0)\n\tvalue.Ge(0)\n\tvalue.Lt(0)\n\tvalue.Le(0)\n\tvalue.IsInt()\n\tvalue.NotInt()\n\tvalue.IsUint()\n\tvalue.NotUint()\n\tvalue.IsFinite()\n\tvalue.NotFinite()\n}\n\nfunc TestNumber_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewNumber(reporter, 10.3)\n\t\tvalue.IsEqual(10.3)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewNumberC(Config{\n\t\t\tReporter: reporter,\n\t\t}, 10.3)\n\t\tvalue.IsEqual(10.3)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newNumber(chain, 10.3)\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestNumber_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewNumber(reporter, 123.0)\n\n\tassert.Equal(t, 123.0, value.Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestNumber_Decode(t *testing.T) {\n\tt.Run(\"target is empty interface\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewNumber(reporter, 10.1)\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, 10.1, target)\n\t})\n\n\tt.Run(\"target is int\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewNumber(reporter, 10)\n\n\t\tvar target int\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, 10, target)\n\t})\n\n\tt.Run(\"target is float64\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewNumber(reporter, 10.1)\n\n\t\tvar target float64\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, 10.1, target)\n\t})\n\n\tt.Run(\"target is nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewNumber(reporter, 10.1)\n\n\t\tvalue.Decode(nil)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"target is unmarshable\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewNumber(reporter, 10.1)\n\n\t\tvalue.Decode(123)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewNumber(reporter, 123)\n\tassert.Equal(t, []string{\"Number()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Number()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Number()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestNumber_Path(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewNumber(reporter, 123.0)\n\n\tassert.Equal(t, 123.0, value.Path(\"$\").Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestNumber_Schema(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tNewNumber(reporter, 123.0).Schema(`{\"type\": \"number\"}`).\n\t\tchain.assert(t, success)\n\n\tNewNumber(reporter, 123.0).Schema(`{\"type\": \"object\"}`).\n\t\tchain.assert(t, failure)\n}\n\nfunc TestNumber_IsEqual(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tnumber    float64\n\t\t\tvalue     interface{}\n\t\t\twantEqual chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:      \"compare equivalent integers\",\n\t\t\t\tnumber:    1234,\n\t\t\t\tvalue:     1234,\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare non-equivalent integers\",\n\t\t\t\tnumber:    1234,\n\t\t\t\tvalue:     4321,\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare NaN to float\",\n\t\t\t\tnumber:    math.NaN(),\n\t\t\t\tvalue:     1234.5,\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare float to NaN\",\n\t\t\t\tnumber:    1234.5,\n\t\t\t\tvalue:     math.NaN(),\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.number).IsEqual(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\t\tNewNumber(reporter, tc.number).NotEqual(tc.value).\n\t\t\t\t\tchain.assert(t, !tc.wantEqual)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).IsEqual(int64(1234)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).IsEqual(float32(1234)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).NotEqual(int64(4321)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).NotEqual(float32(4321)).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).IsEqual(\"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).NotEqual(\"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_InDelta(t *testing.T) {\n\tcases := []struct {\n\t\tname           string\n\t\tnumber         float64\n\t\tvalue          float64\n\t\tdelta          float64\n\t\twantInDelta    chainResult\n\t\twantNotInDelta chainResult\n\t}{\n\t\t{\n\t\t\tname:           \"larger value in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.7,\n\t\t\tdelta:          0.3,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"smaller value in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.3,\n\t\t\tdelta:          0.3,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"larger value not in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.7,\n\t\t\tdelta:          0.1,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"smaller value not in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.3,\n\t\t\tdelta:          0.1,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"number is NaN\",\n\t\t\tnumber:         math.NaN(),\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          0.1,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value is NaN\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          math.NaN(),\n\t\t\tdelta:          0.1,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"delta is NaN\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          math.NaN(),\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewNumber(reporter, tc.number).InDelta(tc.value, tc.delta).\n\t\t\t\tchain.assert(t, tc.wantInDelta)\n\n\t\t\tNewNumber(reporter, tc.number).NotInDelta(tc.value, tc.delta).\n\t\t\t\tchain.assert(t, tc.wantNotInDelta)\n\t\t})\n\t}\n}\n\nfunc TestNumber_InDeltaRelative(t *testing.T) {\n\tcases := []struct {\n\t\tname           string\n\t\tnumber         float64\n\t\tvalue          float64\n\t\tdelta          float64\n\t\twantInDelta    chainResult\n\t\twantNotInDelta chainResult\n\t}{\n\t\t{\n\t\t\tname:           \"larger value in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1271.5,\n\t\t\tdelta:          0.03,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"smaller value in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1221.1,\n\t\t\tdelta:          0.03,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"larger value not in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1259.1,\n\t\t\tdelta:          0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"smaller value not in delta range\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1209.8,\n\t\t\tdelta:          0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"delta is negative\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          -0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"target is NaN\",\n\t\t\tnumber:         math.NaN(),\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value is NaN\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          math.NaN(),\n\t\t\tdelta:          0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"delta is NaN\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          math.NaN(),\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"delta is +Inf\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          math.Inf(1),\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"delta is -Inf\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          math.Inf(-1),\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"+Inf target\",\n\t\t\tnumber:         math.Inf(1),\n\t\t\tvalue:          1234.0,\n\t\t\tdelta:          0,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"-Inf value\",\n\t\t\tnumber:         1234.5,\n\t\t\tvalue:          math.Inf(-1),\n\t\t\tdelta:          0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"+Inf number and target with 0 delta\",\n\t\t\tnumber:         math.Inf(1),\n\t\t\tvalue:          math.Inf(1),\n\t\t\tdelta:          0,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"-Inf number and target with 0 delta\",\n\t\t\tnumber:         math.Inf(-1),\n\t\t\tvalue:          math.Inf(-1),\n\t\t\tdelta:          0,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"+Inf number and target with non-zero delta\",\n\t\t\tnumber:         math.Inf(1),\n\t\t\tvalue:          math.Inf(1),\n\t\t\tdelta:          10000,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"-Inf number and target with non-zero delta\",\n\t\t\tnumber:         math.Inf(-1),\n\t\t\tvalue:          math.Inf(-1),\n\t\t\tdelta:          10000,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"+Inf number and -Inf target\",\n\t\t\tnumber:         math.Inf(1),\n\t\t\tvalue:          math.Inf(-1),\n\t\t\tdelta:          0,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"-Inf number and +Inf target\",\n\t\t\tnumber:         math.Inf(-1),\n\t\t\tvalue:          math.Inf(1),\n\t\t\tdelta:          0,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t\t{\n\t\t\tname:           \"target is 0 in delta range\",\n\t\t\tnumber:         0,\n\t\t\tvalue:          0,\n\t\t\tdelta:          0,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value is 0 in delta range\",\n\t\t\tnumber:         0.05,\n\t\t\tvalue:          0,\n\t\t\tdelta:          1.0,\n\t\t\twantInDelta:    success,\n\t\t\twantNotInDelta: failure,\n\t\t},\n\t\t{\n\t\t\tname:           \"value is 0 not in delta range\",\n\t\t\tnumber:         0.01,\n\t\t\tvalue:          0,\n\t\t\tdelta:          0.01,\n\t\t\twantInDelta:    failure,\n\t\t\twantNotInDelta: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewNumber(reporter, tc.number).InDeltaRelative(tc.value, tc.delta).\n\t\t\t\tchain.assert(t, tc.wantInDelta)\n\n\t\t\tNewNumber(reporter, tc.number).NotInDeltaRelative(tc.value, tc.delta).\n\t\t\t\tchain.assert(t, tc.wantNotInDelta)\n\t\t})\n\t}\n}\n\nfunc TestNumber_InRange(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname           string\n\t\t\tnumber         float64\n\t\t\tmin            interface{}\n\t\t\tmax            interface{}\n\t\t\twantInRange    chainResult\n\t\t\twantNotInRange chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:           \"range includes only number\",\n\t\t\t\tnumber:         1234,\n\t\t\t\tmin:            1234,\n\t\t\t\tmax:            1234,\n\t\t\t\twantInRange:    success,\n\t\t\t\twantNotInRange: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"range includes number and below\",\n\t\t\t\tnumber:         1234,\n\t\t\t\tmin:            1234 - 1,\n\t\t\t\tmax:            1234,\n\t\t\t\twantInRange:    success,\n\t\t\t\twantNotInRange: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"range includes number and above\",\n\t\t\t\tnumber:         1234,\n\t\t\t\tmin:            1234,\n\t\t\t\tmax:            1234 + 1,\n\t\t\t\twantInRange:    success,\n\t\t\t\twantNotInRange: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"range is above number\",\n\t\t\t\tnumber:         1234,\n\t\t\t\tmin:            1234 + 1,\n\t\t\t\tmax:            1234 + 2,\n\t\t\t\twantInRange:    failure,\n\t\t\t\twantNotInRange: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"range is below number\",\n\t\t\t\tnumber:         1234,\n\t\t\t\tmin:            1234 - 2,\n\t\t\t\tmax:            1234 - 1,\n\t\t\t\twantInRange:    failure,\n\t\t\t\twantNotInRange: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"range min is larger than max\",\n\t\t\t\tnumber:         1234,\n\t\t\t\tmin:            1234 + 1,\n\t\t\t\tmax:            1234 - 1,\n\t\t\t\twantInRange:    failure,\n\t\t\t\twantNotInRange: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.number).InRange(tc.min, tc.max).\n\t\t\t\t\tchain.assert(t, tc.wantInRange)\n\n\t\t\t\tNewNumber(reporter, tc.number).NotInRange(tc.min, tc.max).\n\t\t\t\t\tchain.assert(t, tc.wantNotInRange)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tnumber      float64\n\t\t\tmin         interface{}\n\t\t\tmax         interface{}\n\t\t\twantInRange chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tnumber:      1234,\n\t\t\t\tmin:         int64(1233),\n\t\t\t\tmax:         float32(1235),\n\t\t\t\twantInRange: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tnumber:      1234,\n\t\t\t\tmin:         1235,\n\t\t\t\tmax:         1236,\n\t\t\t\twantInRange: failure,\n\t\t\t},\n\t\t}\n\n\t\treporter := newMockReporter(t)\n\n\t\tfor _, tc := range cases {\n\t\t\tNewNumber(reporter, tc.number).InRange(tc.min, tc.max).\n\t\t\t\tchain.assert(t, tc.wantInRange)\n\n\t\t\tNewNumber(reporter, tc.number).NotInRange(tc.min, tc.max).\n\t\t\t\tchain.assert(t, !tc.wantInRange)\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).InRange(int64(1233), \"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).NotInRange(int64(1233), \"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).InRange(\"NOT NUMBER\", float32(1235)).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).NotInRange(\"NOT NUMBER\", float32(1235)).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_InList(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname          string\n\t\t\tnumber        float64\n\t\t\tlist          []interface{}\n\t\t\twantInList    chainResult\n\t\t\twantNotInList chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:          \"no list\",\n\t\t\t\tnumber:        1234,\n\t\t\t\tlist:          nil,\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"empty list\",\n\t\t\t\tnumber:        1234,\n\t\t\t\tlist:          []interface{}{},\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"in integer list\",\n\t\t\t\tnumber:        1234,\n\t\t\t\tlist:          []interface{}{1234, 4567},\n\t\t\t\twantInList:    success,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"in float list\",\n\t\t\t\tnumber:        1234,\n\t\t\t\tlist:          []interface{}{1234.00, 4567.00},\n\t\t\t\twantInList:    success,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"not in float list\",\n\t\t\t\tnumber:        1234,\n\t\t\t\tlist:          []interface{}{4567.00, 1234.01},\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.number).InList(tc.list...).\n\t\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\t\tNewNumber(reporter, tc.number).NotInList(tc.list...).\n\t\t\t\t\tchain.assert(t, tc.wantNotInList)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tnumber     float64\n\t\t\tlist       []interface{}\n\t\t\twantInList chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tnumber:     111,\n\t\t\t\tlist:       []interface{}{int64(111), float32(222)},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tnumber:     111,\n\t\t\t\tlist:       []interface{}{float32(111), int64(222)},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tnumber:     111,\n\t\t\t\tlist:       []interface{}{222, 333},\n\t\t\t\twantInList: failure,\n\t\t\t},\n\t\t}\n\n\t\treporter := newMockReporter(t)\n\n\t\tfor _, tc := range cases {\n\t\t\tNewNumber(reporter, tc.number).InList(tc.list...).\n\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\tNewNumber(reporter, tc.number).NotInList(tc.list...).\n\t\t\t\tchain.assert(t, !tc.wantInList)\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 111).InList(222, \"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 111).NotInList(222, \"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 111).InList(111, \"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 111).NotInList(111, \"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_IsGreater(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname   string\n\t\t\tnumber float64\n\t\t\tvalue  interface{}\n\t\t\twantGt chainResult\n\t\t\twantGe chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"number is lesser\",\n\t\t\t\tnumber: 1234,\n\t\t\t\tvalue:  1234 + 1,\n\t\t\t\twantGt: failure,\n\t\t\t\twantGe: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"number is equal\",\n\t\t\t\tnumber: 1234,\n\t\t\t\tvalue:  1234,\n\t\t\t\twantGt: failure,\n\t\t\t\twantGe: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"number is greater\",\n\t\t\t\tnumber: 1234,\n\t\t\t\tvalue:  1234 - 1,\n\t\t\t\twantGt: success,\n\t\t\t\twantGe: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.number).Gt(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantGt)\n\n\t\t\t\tNewNumber(reporter, tc.number).Ge(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantGe)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).Gt(int64(1233)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).Gt(float32(1233)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).Ge(int64(1233)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).Ge(float32(1233)).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).Gt(\"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).Ge(\"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_IsLesser(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname   string\n\t\t\tnumber float64\n\t\t\tvalue  interface{}\n\t\t\twantLt chainResult\n\t\t\twantLe chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"number is lesser\",\n\t\t\t\tnumber: 1234,\n\t\t\t\tvalue:  1234 + 1,\n\t\t\t\twantLt: success,\n\t\t\t\twantLe: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"number is equal\",\n\t\t\t\tnumber: 1234,\n\t\t\t\tvalue:  1234,\n\t\t\t\twantLt: failure,\n\t\t\t\twantLe: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"number is greater\",\n\t\t\t\tnumber: 1234,\n\t\t\t\tvalue:  1234 - 1,\n\t\t\t\twantLt: failure,\n\t\t\t\twantLe: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.number).Lt(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantLt)\n\n\t\t\t\tNewNumber(reporter, tc.number).Le(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantLe)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).Lt(int64(1235)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).Lt(float32(1235)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).Le(int64(1235)).\n\t\t\tchain.assert(t, success)\n\n\t\tNewNumber(reporter, 1234).Le(float32(1235)).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).Lt(\"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).Le(\"NOT NUMBER\").\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_IsInt(t *testing.T) {\n\tt.Run(\"values\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tvalue     float64\n\t\t\twantInt16 chainResult\n\t\t\twantInt32 chainResult\n\t\t\twantInt   chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:      \"0\",\n\t\t\t\tvalue:     0,\n\t\t\t\twantInt16: success,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"1\",\n\t\t\t\tvalue:     1,\n\t\t\t\twantInt16: success,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"0.5\",\n\t\t\t\tvalue:     0.5,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: failure,\n\t\t\t\twantInt:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"NaN\",\n\t\t\t\tvalue:     math.NaN(),\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: failure,\n\t\t\t\twantInt:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"-Inf\",\n\t\t\t\tvalue:     math.Inf(-1),\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: failure,\n\t\t\t\twantInt:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"+Inf\",\n\t\t\t\tvalue:     math.Inf(+1),\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: failure,\n\t\t\t\twantInt:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MinInt16-1\",\n\t\t\t\tvalue:     math.MinInt16 - 1,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MinInt16\",\n\t\t\t\tvalue:     math.MinInt16,\n\t\t\t\twantInt16: success,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MaxInt16\",\n\t\t\t\tvalue:     math.MaxInt16,\n\t\t\t\twantInt16: success,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MaxInt16+1\",\n\t\t\t\tvalue:     math.MaxInt16 + 1,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MinInt32-1\",\n\t\t\t\tvalue:     math.MinInt32 - 1,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: failure,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MinInt32\",\n\t\t\t\tvalue:     math.MinInt32,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MaxInt32\",\n\t\t\t\tvalue:     math.MaxInt32,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: success,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"MaxInt32+1\",\n\t\t\t\tvalue:     math.MaxInt32 + 1,\n\t\t\t\twantInt16: failure,\n\t\t\t\twantInt32: failure,\n\t\t\t\twantInt:   success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.value).IsInt().\n\t\t\t\t\tchain.assert(t, tc.wantInt)\n\t\t\t\tNewNumber(reporter, tc.value).NotInt().\n\t\t\t\t\tchain.assert(t, !tc.wantInt)\n\n\t\t\t\tNewNumber(reporter, tc.value).IsInt(32).\n\t\t\t\t\tchain.assert(t, tc.wantInt32)\n\t\t\t\tNewNumber(reporter, tc.value).NotInt(32).\n\t\t\t\t\tchain.assert(t, !tc.wantInt32)\n\n\t\t\t\tNewNumber(reporter, tc.value).IsInt(16).\n\t\t\t\t\tchain.assert(t, tc.wantInt16)\n\t\t\t\tNewNumber(reporter, tc.value).NotInt(16).\n\t\t\t\t\tchain.assert(t, !tc.wantInt16)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).IsInt(16, 32).\n\t\t\tchain.assert(t, failure)\n\t\tNewNumber(reporter, 1234).NotInt(16, 32).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).IsInt(0).\n\t\t\tchain.assert(t, failure)\n\t\tNewNumber(reporter, 1234).NotInt(0).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).IsInt(-16).\n\t\t\tchain.assert(t, failure)\n\t\tNewNumber(reporter, 1234).NotInt(-16).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_IsUint(t *testing.T) {\n\tt.Run(\"values\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname       string\n\t\t\tvalue      float64\n\t\t\twantUint16 chainResult\n\t\t\twantUint32 chainResult\n\t\t\twantUint   chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:       \"0\",\n\t\t\t\tvalue:      0,\n\t\t\t\twantUint16: success,\n\t\t\t\twantUint32: success,\n\t\t\t\twantUint:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"1\",\n\t\t\t\tvalue:      1,\n\t\t\t\twantUint16: success,\n\t\t\t\twantUint32: success,\n\t\t\t\twantUint:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"-1\",\n\t\t\t\tvalue:      -1,\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: failure,\n\t\t\t\twantUint:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"0.5\",\n\t\t\t\tvalue:      0.5,\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: failure,\n\t\t\t\twantUint:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"NaN\",\n\t\t\t\tvalue:      math.NaN(),\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: failure,\n\t\t\t\twantUint:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"-Inf\",\n\t\t\t\tvalue:      math.Inf(-1),\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: failure,\n\t\t\t\twantUint:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"+Inf\",\n\t\t\t\tvalue:      math.Inf(+1),\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: failure,\n\t\t\t\twantUint:   failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"MaxUint16\",\n\t\t\t\tvalue:      math.MaxUint16,\n\t\t\t\twantUint16: success,\n\t\t\t\twantUint32: success,\n\t\t\t\twantUint:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"MaxUint16+1\",\n\t\t\t\tvalue:      math.MaxUint16 + 1,\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: success,\n\t\t\t\twantUint:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"MaxUint32\",\n\t\t\t\tvalue:      math.MaxUint32,\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: success,\n\t\t\t\twantUint:   success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"MaxUint32+1\",\n\t\t\t\tvalue:      math.MaxUint32 + 1,\n\t\t\t\twantUint16: failure,\n\t\t\t\twantUint32: failure,\n\t\t\t\twantUint:   success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewNumber(reporter, tc.value).IsUint().\n\t\t\t\t\tchain.assert(t, tc.wantUint)\n\t\t\t\tNewNumber(reporter, tc.value).NotUint().\n\t\t\t\t\tchain.assert(t, !tc.wantUint)\n\n\t\t\t\tNewNumber(reporter, tc.value).IsUint(32).\n\t\t\t\t\tchain.assert(t, tc.wantUint32)\n\t\t\t\tNewNumber(reporter, tc.value).NotUint(32).\n\t\t\t\t\tchain.assert(t, !tc.wantUint32)\n\n\t\t\t\tNewNumber(reporter, tc.value).IsUint(16).\n\t\t\t\t\tchain.assert(t, tc.wantUint16)\n\t\t\t\tNewNumber(reporter, tc.value).NotUint(16).\n\t\t\t\t\tchain.assert(t, !tc.wantUint16)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewNumber(reporter, 1234).IsUint(16, 32).\n\t\t\tchain.assert(t, failure)\n\t\tNewNumber(reporter, 1234).NotUint(16, 32).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).IsUint(0).\n\t\t\tchain.assert(t, failure)\n\t\tNewNumber(reporter, 1234).NotUint(0).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewNumber(reporter, 1234).IsUint(-16).\n\t\t\tchain.assert(t, failure)\n\t\tNewNumber(reporter, 1234).NotUint(-16).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestNumber_IsFinite(t *testing.T) {\n\tcases := []struct {\n\t\tname       string\n\t\tvalue      float64\n\t\twantFinite chainResult\n\t}{\n\t\t{\n\t\t\tname:       \"0\",\n\t\t\tvalue:      0,\n\t\t\twantFinite: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"1\",\n\t\t\tvalue:      1,\n\t\t\twantFinite: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"-1\",\n\t\t\tvalue:      -1,\n\t\t\twantFinite: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"0.5\",\n\t\t\tvalue:      0.5,\n\t\t\twantFinite: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"NaN\",\n\t\t\tvalue:      math.NaN(),\n\t\t\twantFinite: failure,\n\t\t},\n\t\t{\n\t\t\tname:       \"-Inf\",\n\t\t\tvalue:      math.Inf(-1),\n\t\t\twantFinite: failure,\n\t\t},\n\t\t{\n\t\t\tname:       \"+Inf\",\n\t\t\tvalue:      math.Inf(+1),\n\t\t\twantFinite: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewNumber(reporter, tc.value).IsFinite().\n\t\t\t\tchain.assert(t, tc.wantFinite)\n\n\t\t\tNewNumber(reporter, tc.value).NotFinite().\n\t\t\t\tchain.assert(t, !tc.wantFinite)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "object.go",
          "type": "blob",
          "size": 29.1171875,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n)\n\n// Object provides methods to inspect attached map[string]interface{} object\n// (Go representation of JSON object).\ntype Object struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  map[string]interface{}\n}\n\n// NewObject returns a new Object instance.\n//\n// If reporter is nil, the function panics.\n// If value is nil, failure is reported.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\nfunc NewObject(reporter Reporter, value map[string]interface{}) *Object {\n\treturn newObject(newChainWithDefaults(\"Object()\", reporter), value)\n}\n\n// NewObjectC returns a new Object instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// If value is nil, failure is reported.\n//\n// Example:\n//\n//\tobject := NewObjectC(config, map[string]interface{}{\"foo\": 123})\nfunc NewObjectC(config Config, value map[string]interface{}) *Object {\n\treturn newObject(newChainWithConfig(\"Object()\", config.withDefaults()), value)\n}\n\nfunc newObject(parent *chain, val map[string]interface{}) *Object {\n\to := &Object{chain: parent.clone(), value: nil}\n\n\topChain := o.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\tif val == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{val},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-nil map\"),\n\t\t\t},\n\t\t})\n\t} else {\n\t\to.value, _ = canonMap(opChain, val)\n\t}\n\n\treturn o\n}\n\n// Raw returns underlying value attached to Object.\n// This is the value originally passed to NewObject, converted to canonical form.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tassert.Equal(t, map[string]interface{}{\"foo\": 123.0}, object.Raw())\nfunc (o *Object) Raw() map[string]interface{} {\n\treturn o.value\n}\n\n// Decode unmarshals the underlying value attached to the Object to a target variable\n// target should be one of this:\n//\n//   - pointer to an empty interface\n//   - pointer to a map\n//   - pointer to a struct\n//\n// Example:\n//\n//\ttype S struct{\n//\t\tFoo int                    `json:\"foo\"`\n//\t\tBar []interface{}          `json:\"bar\"`\n//\t\tBaz map[string]interface{} `json:\"baz\"`\n//\t\tBat struct{ A int }        `json:\"bat\"`\n//\t}\n//\n//\tm := map[string]interface{}{\n//\t\t\"foo\": 123,\n//\t\t\"bar\": []interface{}{\"123\", 234.0},\n//\t\t\"baz\": map[string]interface{}{\n//\t\t\t\"a\": \"b\",\n//\t\t},\n//\t\t\"bat\": struct{ A int }{123},\n//\t}\n//\n//\tvalue := NewObject(t, value)\n//\n//\tvar target S\n//\tvalue.Decode(&target)\n//\n//\tassert.Equal(t, S{123,[]interface{}{\"123\", 234.0},\n//\t\tmap[string]interface{}{\"a\": \"b\"}, struct{ A int }{123},\n//\t}, target)\nfunc (o *Object) Decode(target interface{}) *Object {\n\topChain := o.chain.enter(\"Decode()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tcanonDecode(opChain, o.value, target)\n\treturn o\n}\n\n// Alias is similar to Value.Alias.\nfunc (o *Object) Alias(name string) *Object {\n\topChain := o.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\to.chain.setAlias(name)\n\treturn o\n}\n\n// Path is similar to Value.Path.\nfunc (o *Object) Path(path string) *Value {\n\topChain := o.chain.enter(\"Path(%q)\", path)\n\tdefer opChain.leave()\n\n\treturn jsonPath(opChain, o.value, path)\n}\n\n// Schema is similar to Value.Schema.\nfunc (o *Object) Schema(schema interface{}) *Object {\n\topChain := o.chain.enter(\"Schema()\")\n\tdefer opChain.leave()\n\n\tjsonSchema(opChain, o.value, schema)\n\treturn o\n}\n\n// Keys returns a new Array instance with object's keys.\n// Keys are sorted in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123, \"bar\": 456})\n//\tobject.Keys().ContainsOnly(\"foo\", \"bar\")\nfunc (o *Object) Keys() *Array {\n\topChain := o.chain.enter(\"Keys()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tkeys := []interface{}{}\n\tfor _, kv := range o.sortedKV() {\n\t\tkeys = append(keys, kv.key)\n\t}\n\n\treturn newArray(opChain, keys)\n}\n\n// Values returns a new Array instance with object's values.\n// Values are sorted by keys ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123, \"bar\": 456})\n//\tobject.Values().ContainsOnly(123, 456)\nfunc (o *Object) Values() *Array {\n\topChain := o.chain.enter(\"Values()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tvalues := []interface{}{}\n\tfor _, kv := range o.sortedKV() {\n\t\tvalues = append(values, kv.val)\n\t}\n\n\treturn newArray(opChain, values)\n}\n\n// Value returns a new Value instance with value for given key.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.Value(\"foo\").Number().IsEqual(123)\nfunc (o *Object) Value(key string) *Value {\n\topChain := o.chain.enter(\"Value(%q)\", key)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tvalue, ok := o.value[key]\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsKey,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{key},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map contains key\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\treturn newValue(opChain, value)\n}\n\n// HasValue succeeds if object's value for given key is equal to given value.\n// Before comparison, both values are converted to canonical form.\n//\n// value should be map[string]interface{} or struct.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.HasValue(\"foo\", 123)\nfunc (o *Object) HasValue(key string, value interface{}) *Object {\n\topChain := o.chain.enter(\"HasValue(%q)\", key)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif !containsKey(opChain, o.value, key) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsKey,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{key},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map contains key\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\texpected, ok := canonValue(opChain, value)\n\tif !ok {\n\t\treturn o\n\t}\n\n\tif !reflect.DeepEqual(expected, o.value[key]) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{o.value[key]},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"expected: map value for key %q is equal to given value\",\n\t\t\t\t\tkey),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\treturn o\n}\n\n// NotHasValue succeeds if object's value for given key is not equal to given\n// value. Before comparison, both values are converted to canonical form.\n//\n// value should be map[string]interface{} or struct.\n//\n// If object doesn't contain any value for given key, failure is reported.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.NotHasValue(\"foo\", \"bad value\")  // success\n//\tobject.NotHasValue(\"bar\", \"bad value\")  // failure! (key is missing)\nfunc (o *Object) NotHasValue(key string, value interface{}) *Object {\n\topChain := o.chain.enter(\"NotHasValue(%q)\", key)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif !containsKey(opChain, o.value, key) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsKey,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{key},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map contains key\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\texpected, ok := canonValue(opChain, value)\n\tif !ok {\n\t\treturn o\n\t}\n\n\tif reflect.DeepEqual(expected, o.value[key]) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{o.value[key]},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"expected: map value for key %q is non-equal to given value\",\n\t\t\t\t\tkey),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\treturn o\n}\n\n// Deprecated: use HasValue instead.\nfunc (o *Object) ValueEqual(key string, value interface{}) *Object {\n\treturn o.HasValue(key, value)\n}\n\n// Deprecated: use NotHasValue instead.\nfunc (o *Object) ValueNotEqual(key string, value interface{}) *Object {\n\treturn o.NotHasValue(key, value)\n}\n\n// Iter returns a new map of Values attached to object elements.\n//\n// Example:\n//\n//\tnumbers := map[string]interface{}{\"foo\": 123, \"bar\": 456}\n//\tobject := NewObject(t, numbers)\n//\n//\tfor key, value := range object.Iter() {\n//\t\tvalue.Number().IsEqual(numbers[key])\n//\t}\nfunc (o *Object) Iter() map[string]Value {\n\topChain := o.chain.enter(\"Iter()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn map[string]Value{}\n\t}\n\n\tret := map[string]Value{}\n\n\tfor k, v := range o.value {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Iter[%q]\", k)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tret[k] = *newValue(valueChain, v)\n\t\t}()\n\t}\n\n\treturn ret\n}\n\n// Every runs the passed function for all the key value pairs in the object.\n//\n// If assertion inside function fails, the original Object is marked failed.\n//\n// Every will execute the function for all values in the object irrespective\n// of assertion failures for some values in the object.\n//\n// The function is invoked for key value pairs sorted by keys in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123, \"bar\": 456})\n//\n//\tobject.Every(func(key string, value *httpexpect.Value) {\n//\t  value.String().NotEmpty()\n//\t})\nfunc (o *Object) Every(fn func(key string, value *Value)) *Object {\n\topChain := o.chain.enter(\"Every()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\tfor _, kv := range o.sortedKV() {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Every[%q]\", kv.key)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tfn(kv.key, newValue(valueChain, kv.val))\n\t\t}()\n\t}\n\n\treturn o\n}\n\n// Filter accepts a function that returns a boolean. The function is ran\n// over the object elements. If the function returns true, the element passes\n// the filter and is added to the new object of filtered elements. If false,\n// the value is skipped (or in other words filtered out). After iterating\n// through all the elements of the original object, the new filtered object\n// is returned.\n//\n// If there are any failed assertions in the filtering function, the\n// element is omitted without causing test failure.\n//\n// The function is invoked for key value pairs sorted by keys in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\n//\t\t\"foo\": \"bar\",\n//\t\t\"baz\": 6,\n//\t\t\"qux\": \"quux\",\n//\t})\n//\tfilteredObject := object.Filter(func(key string, value *httpexpect.Value) bool {\n//\t\tvalue.String().NotEmpty()\t\t//fails on 6\n//\t\treturn value.Raw() != \"bar\"\t\t//fails on \"bar\"\n//\t})\n//\tfilteredObject.IsEqual(map[string]interface{}{\"qux\":\"quux\"})\t//succeeds\nfunc (o *Object) Filter(fn func(key string, value *Value) bool) *Object {\n\topChain := o.chain.enter(\"Filter()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tfilteredObject := map[string]interface{}{}\n\n\tfor _, kv := range o.sortedKV() {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Filter[%q]\", kv.key)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(kv.key, newValue(valueChain, kv.val)) && !valueChain.treeFailed() {\n\t\t\t\tfilteredObject[kv.key] = kv.val\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn newObject(opChain, filteredObject)\n}\n\n// Transform runs the passed function on all the elements in the Object\n// and returns a new object without effecting original object.\n//\n// The function is invoked for key value pairs sorted by keys in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, []interface{}{\"x\": \"foo\", \"y\": \"bar\"})\n//\ttransformedObject := object.Transform(\n//\t\tfunc(key string, value interface{}) interface{} {\n//\t\t\treturn strings.ToUpper(value.(string))\n//\t\t})\n//\ttransformedObject.IsEqual([]interface{}{\"x\": \"FOO\", \"y\": \"BAR\"})\nfunc (o *Object) Transform(fn func(key string, value interface{}) interface{}) *Object {\n\topChain := o.chain.enter(\"Transform()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn newObject(opChain, nil)\n\t}\n\n\ttransformedObject := map[string]interface{}{}\n\n\tfor _, kv := range o.sortedKV() {\n\t\ttransformedObject[kv.key] = fn(kv.key, kv.val)\n\t}\n\n\treturn newObject(opChain, transformedObject)\n}\n\n// Find accepts a function that returns a boolean, runs it over the object\n// elements, and returns the first element on which it returned true.\n//\n// If there are any failed assertions in the predicate function, the\n// element is skipped without causing test failure.\n//\n// If no elements were found, a failure is reported.\n//\n// The function is invoked for key value pairs sorted by keys in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\n//\t\t\"a\": 1,\n//\t\t\"b\": \"foo\",\n//\t\t\"c\": 101,\n//\t\t\"d\": \"bar\",\n//\t\t\"e\": 201,\n//\t})\n//\tfoundValue := object.Find(func(key string, value *httpexpect.Value)  bool {\n//\t\tnum := value.Number()      // skip if element is not a string\n//\t\treturn num.Raw() > 100     // check element value\n//\t})\n//\tfoundValue.IsEqual(101) // succeeds\nfunc (o *Object) Find(fn func(key string, value *Value) bool) *Value {\n\topChain := o.chain.enter(\"Find()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tfor _, kv := range o.sortedKV() {\n\t\tfound := false\n\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"Find[%q]\", kv.key)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(kv.key, newValue(valueChain, kv.val)) && !valueChain.treeFailed() {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}()\n\n\t\tif found {\n\t\t\treturn newValue(opChain, kv.val)\n\t\t}\n\t}\n\n\topChain.fail(AssertionFailure{\n\t\tType:   AssertValid,\n\t\tActual: &AssertionValue{o.value},\n\t\tErrors: []error{\n\t\t\terrors.New(\"expected: at least one object element matches predicate\"),\n\t\t},\n\t})\n\n\treturn newValue(opChain, nil)\n}\n\n// FindAll accepts a function that returns a boolean, runs it over the object\n// elements, and returns all the elements on which it returned true.\n//\n// If there are any failed assertions in the predicate function, the\n// element is skipped without causing test failure.\n//\n// If no elements were found, empty slice is returned without reporting error.\n//\n// The function is invoked for key value pairs sorted by keys in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\n//\t\t\"a\": 1,\n//\t\t\"b\": \"foo\",\n//\t\t\"c\": 101,\n//\t\t\"d\": \"bar\",\n//\t\t\"e\": 201,\n//\t})\n//\tfoundValues := object.FindAll(func(key string, value *httpexpect.Value)  bool {\n//\t\tnum := value.Number()      // skip if element is not a string\n//\t\treturn num.Raw() > 100     // check element value\n//\t})\n//\n//\tassert.Equal(t, len(foundValues), 2)\n//\tfoundValues[0].IsEqual(101)\n//\tfoundValues[1].IsEqual(201)\nfunc (o *Object) FindAll(fn func(key string, value *Value) bool) []*Value {\n\topChain := o.chain.enter(\"FindAll()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn []*Value{}\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn []*Value{}\n\t}\n\n\tfoundValues := make([]*Value, 0, len(o.value))\n\n\tfor _, kv := range o.sortedKV() {\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"FindAll[%q]\", kv.key)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(kv.key, newValue(valueChain, kv.val)) && !valueChain.treeFailed() {\n\t\t\t\tfoundValues = append(foundValues, newValue(opChain, kv.val))\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn foundValues\n}\n\n// NotFind accepts a function that returns a boolean, runs it over the object\n// elelements, and checks that it does not return true for any of the elements.\n//\n// If there are any failed assertions in the predicate function, the\n// element is skipped without causing test failure.\n//\n// If the predicate function did not fail and returned true for at least\n// one element, a failure is reported.\n//\n// The function is invoked for key value pairs sorted by keys in ascending order.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\n//\t\t\"a\": 1,\n//\t\t\"b\": \"foo\",\n//\t\t\"c\": 2,\n//\t\t\"d\": \"bar\",\n//\t})\n//\tobject.NotFind(func(key string, value *httpexpect.Value) bool {\n//\t\tnum := value.Number()    // skip if element is not a number\n//\t\treturn num.Raw() > 100   // check element value\n//\t}) // succeeds\nfunc (o *Object) NotFind(fn func(key string, value *Value) bool) *Object {\n\topChain := o.chain.enter(\"NotFind()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif fn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil function argument\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\tfor _, kv := range o.sortedKV() {\n\t\tfound := false\n\n\t\tfunc() {\n\t\t\tvalueChain := opChain.replace(\"NotFind[%q]\", kv.key)\n\t\t\tdefer valueChain.leave()\n\n\t\t\tvalueChain.setRoot()\n\t\t\tvalueChain.setSeverity(SeverityLog)\n\n\t\t\tif fn(kv.key, newValue(valueChain, kv.val)) && !valueChain.treeFailed() {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}()\n\n\t\tif found {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotContainsElement,\n\t\t\t\tExpected: &AssertionValue{kv.val},\n\t\t\t\tActual:   &AssertionValue{o.value},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: none of the object elements match predicate\"),\n\t\t\t\t\tfmt.Errorf(\"element with key %q matches predicate\", kv.key),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn o\n\t\t}\n\t}\n\n\treturn o\n}\n\n// IsEmpty succeeds if object is empty.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{})\n//\tobject.IsEmpty()\nfunc (o *Object) IsEmpty() *Object {\n\topChain := o.chain.enter(\"IsEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif !(len(o.value) == 0) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertEmpty,\n\t\t\tActual: &AssertionValue{o.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map is empty\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// NotEmpty succeeds if object is non-empty.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.NotEmpty()\nfunc (o *Object) NotEmpty() *Object {\n\topChain := o.chain.enter(\"NotEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif len(o.value) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotEmpty,\n\t\t\tActual: &AssertionValue{o.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map is non-empty\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// Deprecated: use IsEmpty instead.\nfunc (o *Object) Empty() *Object {\n\treturn o.IsEmpty()\n}\n\n// IsEqual succeeds if object is equal to given value.\n// Before comparison, both object and value are converted to canonical form.\n//\n// value should be map[string]interface{} or struct.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.IsEqual(map[string]interface{}{\"foo\": 123})\nfunc (o *Object) IsEqual(value interface{}) *Object {\n\topChain := o.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\texpected, ok := canonMap(opChain, value)\n\tif !ok {\n\t\treturn o\n\t}\n\n\tif !reflect.DeepEqual(expected, o.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: maps are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// NotEqual succeeds if object is not equal to given value.\n// Before comparison, both object and value are converted to canonical form.\n//\n// value should be map[string]interface{} or struct.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.IsEqual(map[string]interface{}{\"bar\": 123})\nfunc (o *Object) NotEqual(value interface{}) *Object {\n\topChain := o.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\texpected, ok := canonMap(opChain, value)\n\tif !ok {\n\t\treturn o\n\t}\n\n\tif reflect.DeepEqual(expected, o.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: maps are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// Deprecated: use IsEqual instead.\nfunc (o *Object) Equal(value interface{}) *Object {\n\treturn o.IsEqual(value)\n}\n\n// InList succeeds if whole object is equal to one of the values from given list\n// of objects. Before comparison, each value is converted to canonical form.\n//\n// Each value should be map[string]interface{} or struct. If at least one value\n// has wrong type, failure is reported.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.InList(\n//\t\tmap[string]interface{}{\"foo\": 123},\n//\t\tmap[string]interface{}{\"bar\": 456},\n//\t)\nfunc (o *Object) InList(values ...interface{}) *Object {\n\topChain := o.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\texpected, ok := canonMap(opChain, v)\n\t\tif !ok {\n\t\t\treturn o\n\t\t}\n\n\t\tif reflect.DeepEqual(expected, o.value) {\n\t\t\tisListed = true\n\t\t\t// continue loop to check that all values are correct\n\t\t}\n\t}\n\n\tif !isListed {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\treturn o\n}\n\n// NotInList succeeds if the whole object is not equal to any of the values\n// from given list of objects. Before comparison, each value is converted to\n// canonical form.\n//\n// Each value should be map[string]interface{} or struct. If at least one value\n// has wrong type, failure is reported.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.NotInList(\n//\t\tmap[string]interface{}{\"bar\": 456},\n//\t\tmap[string]interface{}{\"baz\": 789},\n//\t)\nfunc (o *Object) NotInList(values ...interface{}) *Object {\n\topChain := o.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn o\n\t}\n\n\tfor _, v := range values {\n\t\texpected, ok := canonMap(opChain, v)\n\t\tif !ok {\n\t\t\treturn o\n\t\t}\n\n\t\tif reflect.DeepEqual(expected, o.value) {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{o.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: map is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn o\n\t\t}\n\t}\n\n\treturn o\n}\n\n// ContainsKey succeeds if object contains given key.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.ContainsKey(\"foo\")\nfunc (o *Object) ContainsKey(key string) *Object {\n\topChain := o.chain.enter(\"ContainsKey()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif !containsKey(opChain, o.value, key) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsKey,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{key},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map contains key\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// NotContainsKey succeeds if object doesn't contain given key.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.NotContainsKey(\"bar\")\nfunc (o *Object) NotContainsKey(key string) *Object {\n\topChain := o.chain.enter(\"NotContainsKey()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif containsKey(opChain, o.value, key) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsKey,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{key},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map does not contain key\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// ContainsValue succeeds if object contains given value with any key.\n// Before comparison, both object and value are converted to canonical form.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.ContainsValue(123)\nfunc (o *Object) ContainsValue(value interface{}) *Object {\n\topChain := o.chain.enter(\"ContainsValue()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif _, ok := containsValue(opChain, o.value, value); !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsElement,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map contains element (with any key)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// NotContainsValue succeeds if object does not contain given value with any key.\n// Before comparison, both object and value are converted to canonical form.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123})\n//\tobject.NotContainsValue(456)\nfunc (o *Object) NotContainsValue(value interface{}) *Object {\n\topChain := o.chain.enter(\"NotContainsValue()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif key, ok := containsValue(opChain, o.value, value); ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsElement,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map does not contain element (with any key)\"),\n\t\t\t\tfmt.Errorf(\"found matching element with key %q\", key),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// ContainsSubset succeeds if given value is a subset of object.\n// Before comparison, both object and value are converted to canonical form.\n//\n// value should be map[string]interface{} or struct.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\n//\t\t\"foo\": 123,\n//\t\t\"bar\": []interface{}{\"x\", \"y\"},\n//\t\t\"bar\": map[string]interface{}{\n//\t\t\t\"a\": true,\n//\t\t\t\"b\": false,\n//\t\t},\n//\t})\n//\n//\tobject.ContainsSubset(map[string]interface{}{  // success\n//\t\t\"foo\": 123,\n//\t\t\"bar\": map[string]interface{}{\n//\t\t\t\"a\": true,\n//\t\t},\n//\t})\n//\n//\tobject.ContainsSubset(map[string]interface{}{  // failure\n//\t\t\"foo\": 123,\n//\t\t\"qux\": 456,\n//\t})\n//\n//\tobject.ContainsSubset(map[string]interface{}{  // failure, slices should match exactly\n//\t\t\"bar\": []interface{}{\"x\"},\n//\t})\nfunc (o *Object) ContainsSubset(value interface{}) *Object {\n\topChain := o.chain.enter(\"ContainsSubset()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif !containsSubset(opChain, o.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map contains sub-map\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// NotContainsSubset succeeds if given value is not a subset of object.\n// Before comparison, both object and value are converted to canonical form.\n//\n// value should be map[string]interface{} or struct.\n//\n// Example:\n//\n//\tobject := NewObject(t, map[string]interface{}{\"foo\": 123, \"bar\": 456})\n//\tobject.NotContainsSubset(map[string]interface{}{\"foo\": 123, \"bar\": \"no-no-no\"})\nfunc (o *Object) NotContainsSubset(value interface{}) *Object {\n\topChain := o.chain.enter(\"NotContainsSubset()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn o\n\t}\n\n\tif containsSubset(opChain, o.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{o.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: map does not contain sub-map\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn o\n}\n\n// Deprecated: use ContainsSubset instead.\nfunc (o *Object) ContainsMap(value interface{}) *Object {\n\treturn o.ContainsSubset(value)\n}\n\n// Deprecated: use NotContainsSubset instead.\nfunc (o *Object) NotContainsMap(value interface{}) *Object {\n\treturn o.NotContainsSubset(value)\n}\n\ntype kv struct {\n\tkey string\n\tval interface{}\n}\n\nfunc (o *Object) sortedKV() []kv {\n\tkvs := make([]kv, 0, len(o.value))\n\n\tfor key, val := range o.value {\n\t\tkvs = append(kvs, kv{key: key, val: val})\n\t}\n\n\tsort.Slice(kvs, func(i, j int) bool {\n\t\treturn kvs[i].key < kvs[j].key\n\t})\n\n\treturn kvs\n}\n\nfunc containsKey(\n\topChain *chain, obj map[string]interface{}, key string,\n) bool {\n\tfor k := range obj {\n\t\tif k == key {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc containsValue(\n\topChain *chain, obj map[string]interface{}, val interface{},\n) (string, bool) {\n\tcanonVal, ok := canonValue(opChain, val)\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\n\tfor k, v := range obj {\n\t\tif reflect.DeepEqual(canonVal, v) {\n\t\t\treturn k, true\n\t\t}\n\t}\n\n\treturn \"\", false\n}\n\nfunc containsSubset(\n\topChain *chain, obj map[string]interface{}, val interface{},\n) bool {\n\tcanonVal, ok := canonMap(opChain, val)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn isSubset(obj, canonVal)\n}\n\nfunc isSubset(outer, inner map[string]interface{}) bool {\n\tfor k, iv := range inner {\n\t\tov, ok := outer[k]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\n\t\tif ovm, ok := ov.(map[string]interface{}); ok {\n\t\t\tif ivm, ok := iv.(map[string]interface{}); ok {\n\t\t\t\tif !isSubset(ovm, ivm) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif !reflect.DeepEqual(ov, iv) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "object_test.go",
          "type": "blob",
          "size": 48.8486328125,
          "content": "package httpexpect\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestObject_FailedChain(t *testing.T) {\n\tcheck := func(value *Object) {\n\t\tvalue.chain.assert(t, failure)\n\n\t\tvalue.Path(\"$\").chain.assert(t, failure)\n\t\tvalue.Schema(\"\")\n\t\tvalue.Alias(\"foo\")\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.Keys().chain.assert(t, failure)\n\t\tvalue.Values().chain.assert(t, failure)\n\t\tvalue.Value(\"foo\").chain.assert(t, failure)\n\n\t\tvalue.IsEmpty()\n\t\tvalue.NotEmpty()\n\t\tvalue.IsEqual(nil)\n\t\tvalue.NotEqual(nil)\n\t\tvalue.InList(nil)\n\t\tvalue.NotInList(nil)\n\t\tvalue.ContainsKey(\"foo\")\n\t\tvalue.NotContainsKey(\"foo\")\n\t\tvalue.ContainsValue(\"foo\")\n\t\tvalue.NotContainsValue(\"foo\")\n\t\tvalue.ContainsSubset(nil)\n\t\tvalue.NotContainsSubset(nil)\n\t\tvalue.HasValue(\"foo\", nil)\n\t\tvalue.NotHasValue(\"foo\", nil)\n\n\t\tassert.NotNil(t, value.Iter())\n\t\tassert.Equal(t, 0, len(value.Iter()))\n\n\t\tvalue.Every(func(_ string, value *Value) {\n\t\t\tvalue.String().NotEmpty()\n\t\t})\n\t\tvalue.Transform(func(key string, value interface{}) interface{} {\n\t\t\treturn nil\n\t\t})\n\t\tvalue.Filter(func(_ string, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t\tvalue.Find(func(key string, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t\tvalue.FindAll(func(key string, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t\tvalue.NotFind(func(key string, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn true\n\t\t})\n\t}\n\n\tt.Run(\"failed chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t, flagFailed)\n\t\tvalue := newObject(chain, map[string]interface{}{})\n\n\t\tcheck(value)\n\t})\n\n\tt.Run(\"nil value\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newObject(chain, nil)\n\n\t\tcheck(value)\n\t})\n\n\tt.Run(\"failed chain, nil value\", func(t *testing.T) {\n\t\tchain := newMockChain(t, flagFailed)\n\t\tvalue := newObject(chain, nil)\n\n\t\tcheck(value)\n\t})\n}\n\nfunc TestObject_Constructors(t *testing.T) {\n\ttest := map[string]interface{}{\n\t\t\"foo\": 100.0,\n\t}\n\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewObject(reporter, test)\n\n\t\tvalue.IsEqual(test)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewObjectC(Config{\n\t\t\tReporter: reporter,\n\t\t}, test)\n\n\t\tvalue.IsEqual(test)\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\n\t\tvalue := newObject(chain, test)\n\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n\n\tt.Run(\"invalid value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewObject(reporter, nil)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tdata := map[string]interface{}{\"foo\": \"bar\"}\n\n\tvalue := NewObject(reporter, data)\n\tassert.Equal(t, data, value.Raw())\n\n\tdata[\"foo\"] = \"baz\"\n\tassert.NotEqual(t, data, value.Raw())\n\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestObject_Decode(t *testing.T) {\n\tt.Run(\"target is empty interface\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tm := map[string]interface{}{\n\t\t\t\"foo\": 123.0,\n\t\t\t\"bar\": []interface{}{\"123\", 234.0},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": \"b\",\n\t\t\t},\n\t\t}\n\n\t\tvalue := NewObject(reporter, m)\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, target, m)\n\t})\n\n\tt.Run(\"target is map\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tm := map[string]interface{}{\n\t\t\t\"foo\": 123.0,\n\t\t\t\"bar\": []interface{}{\"123\", 234.0},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": \"b\",\n\t\t\t},\n\t\t}\n\n\t\tvalue := NewObject(reporter, m)\n\n\t\tvar target map[string]interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, target, m)\n\t})\n\n\tt.Run(\"target is struct\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttype S struct {\n\t\t\tFoo int                    `json:\"foo\"`\n\t\t\tBar []interface{}          `json:\"bar\"`\n\t\t\tBaz map[string]interface{} `json:\"baz\"`\n\t\t\tBat struct{ A int }        `json:\"bat\"`\n\t\t}\n\n\t\tm := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"123\", 234.0},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": \"b\",\n\t\t\t},\n\t\t\t\"bat\": struct{ A int }{123},\n\t\t}\n\n\t\tvalue := NewObject(reporter, m)\n\n\t\tactualStruct := S{\n\t\t\tFoo: 123,\n\t\t\tBar: []interface{}{\"123\", 234.0},\n\t\t\tBaz: map[string]interface{}{\"a\": \"b\"},\n\t\t\tBat: struct{ A int }{123},\n\t\t}\n\n\t\tvar target S\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, target, actualStruct)\n\t})\n\n\tt.Run(\"target is nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tm := map[string]interface{}{\n\t\t\t\"foo\": 123.0,\n\t\t\t\"bar\": []interface{}{\"123\", 234.0},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": \"b\",\n\t\t\t},\n\t\t}\n\n\t\tvalue := NewObject(reporter, m)\n\n\t\tvalue.Decode(nil)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"target is unmarshable\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tm := map[string]interface{}{\n\t\t\t\"foo\": 123.0,\n\t\t\t\"bar\": []interface{}{\"123\", 234.0},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": \"b\",\n\t\t\t},\n\t\t}\n\n\t\tvalue := NewObject(reporter, m)\n\n\t\tvalue.Decode(123)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewObject(reporter, map[string]interface{}{\n\t\t\"foo\": 100.0,\n\t})\n\tassert.Equal(t, []string{\"Object()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Object()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"bar\")\n\tassert.Equal(t, []string{\"Object()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"bar\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.Values()\n\tassert.Equal(t, []string{\"Object()\", \"Values()\"}, childValue.chain.context.Path)\n\tassert.Equal(t, []string{\"bar\", \"Values()\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestObject_Path(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tm := map[string]interface{}{\n\t\t\"foo\": 123.0,\n\t\t\"bar\": []interface{}{\"456\", 789.0},\n\t\t\"baz\": map[string]interface{}{\n\t\t\t\"a\": \"b\",\n\t\t},\n\t}\n\n\tvalue := NewObject(reporter, m)\n\n\tassert.Equal(t, m, value.Path(\"$\").Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestObject_Schema(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tdata := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t}\n\n\tNewObject(reporter, data).Schema(`{\"type\": \"object\"}`).\n\t\tchain.assert(t, success)\n\n\tNewObject(reporter, data).Schema(`{\"type\": \"array\"}`).\n\t\tchain.assert(t, failure)\n}\n\nfunc TestObject_Getters(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tm := map[string]interface{}{\n\t\t\"foo\": 123.0,\n\t\t\"bar\": []interface{}{\"456\", 789.0},\n\t\t\"baz\": map[string]interface{}{\n\t\t\t\"a\": \"b\",\n\t\t},\n\t}\n\n\tvalue := NewObject(reporter, m)\n\n\tkeys := []interface{}{\"foo\", \"bar\", \"baz\"}\n\n\tvalues := []interface{}{\n\t\t123.0,\n\t\t[]interface{}{\"456\", 789.0},\n\t\tmap[string]interface{}{\n\t\t\t\"a\": \"b\",\n\t\t},\n\t}\n\n\tassert.Equal(t, m, value.Raw())\n\tvalue.chain.assert(t, success)\n\tvalue.chain.clear()\n\n\tvalue.Keys().ContainsOnly(keys...)\n\tvalue.chain.assert(t, success)\n\tvalue.chain.clear()\n\n\tvalue.Values().ContainsOnly(values...)\n\tvalue.chain.assert(t, success)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, m[\"foo\"], value.Value(\"foo\").Raw())\n\tvalue.chain.assert(t, success)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, m[\"bar\"], value.Value(\"bar\").Raw())\n\tvalue.chain.assert(t, success)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, m[\"baz\"], value.Value(\"baz\").Raw())\n\tvalue.chain.assert(t, success)\n\tvalue.chain.clear()\n\n\tassert.Equal(t, nil, value.Value(\"BAZ\").Raw())\n\tvalue.chain.assert(t, failure)\n\tvalue.chain.clear()\n}\n\nfunc TestObject_IsEmpty(t *testing.T) {\n\tt.Run(\"empty map\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewObject(reporter, map[string]interface{}{}).IsEmpty().\n\t\t\tchain.assert(t, success)\n\n\t\tNewObject(reporter, map[string]interface{}{}).NotEmpty().\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"one empty element\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewObject(reporter, map[string]interface{}{\"\": nil}).IsEmpty().\n\t\t\tchain.assert(t, failure)\n\n\t\tNewObject(reporter, map[string]interface{}{\"\": nil}).NotEmpty().\n\t\t\tchain.assert(t, success)\n\t})\n}\n\nfunc TestObject_IsEqual(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tvalue     map[string]interface{}\n\t\t\ttestValue map[string]interface{}\n\t\t\twantEqual chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:      \"empty vs one empty\",\n\t\t\t\tvalue:     map[string]interface{}{},\n\t\t\t\ttestValue: map[string]interface{}{},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"empty vs one empty element\",\n\t\t\t\tvalue:     map[string]interface{}{},\n\t\t\t\ttestValue: map[string]interface{}{\"\": nil},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"one empty element vs empty\",\n\t\t\t\tvalue:     map[string]interface{}{\"\": nil},\n\t\t\t\ttestValue: map[string]interface{}{},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"non-empty vs empty\",\n\t\t\t\tvalue:     map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestValue: map[string]interface{}{},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"different key\",\n\t\t\t\tvalue:     map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestValue: map[string]interface{}{\"FOO\": 123.0},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"different value\",\n\t\t\t\tvalue:     map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestValue: map[string]interface{}{\"foo\": 456.0},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"equal\",\n\t\t\t\tvalue:     map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestValue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.value).IsEqual(tc.testValue).\n\t\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\t\tNewObject(reporter, tc.value).NotEqual(tc.testValue).\n\t\t\t\t\tchain.assert(t, !tc.wantEqual)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttype (\n\t\t\tBar struct {\n\t\t\t\tBaz []bool `json:\"baz\"`\n\t\t\t}\n\n\t\t\tS struct {\n\t\t\t\tFoo int `json:\"foo\"`\n\t\t\t\tBar Bar `json:\"bar\"`\n\t\t\t}\n\t\t)\n\n\t\tvalue := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": map[string]interface{}{\n\t\t\t\t\"baz\": []interface{}{true, false},\n\t\t\t},\n\t\t}\n\n\t\ts := S{\n\t\t\tFoo: 123,\n\t\t\tBar: Bar{\n\t\t\t\tBaz: []bool{true, false},\n\t\t\t},\n\t\t}\n\n\t\tNewObject(reporter, value).IsEqual(s).\n\t\t\tchain.assert(t, success)\n\n\t\tNewObject(reporter, value).NotEqual(s).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewObject(reporter, value).IsEqual(S{}).\n\t\t\tchain.assert(t, failure)\n\n\t\tNewObject(reporter, value).NotEqual(S{}).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttype (\n\t\t\tmyMap map[string]interface{}\n\t\t\tmyInt int\n\t\t)\n\n\t\tdata := map[string]interface{}{\"foo\": 123}\n\n\t\tNewObject(reporter, data).IsEqual(myMap{\"foo\": myInt(123)}).\n\t\t\tchain.assert(t, success)\n\n\t\tNewObject(reporter, data).NotEqual(myMap{\"foo\": myInt(123)}).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_InList(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tvalue     map[string]interface{}\n\t\t\ttestList  []interface{}\n\t\t\twantEqual chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:  \"empty vs empty\",\n\t\t\t\tvalue: map[string]interface{}{},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tmap[string]interface{}{},\n\t\t\t\t},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"different key\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\"FOO\": 123.0},\n\t\t\t\t\tmap[string]interface{}{\"BAR\": 456.0},\n\t\t\t\t},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"different key or value\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\"foo\": 456.0},\n\t\t\t\t\tmap[string]interface{}{\"bar\": 123.0},\n\t\t\t\t},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"success\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\"foo\": 123.0},\n\t\t\t\t\tmap[string]interface{}{\"bar\": 456.0},\n\t\t\t\t},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"struct\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tstruct {\n\t\t\t\t\t\tFoo float64 `json:\"foo\"`\n\t\t\t\t\t}{\n\t\t\t\t\t\tFoo: 123.00,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.value).InList(tc.testList...).\n\t\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\t\tNewObject(reporter, tc.value).NotInList(tc.testList...).\n\t\t\t\t\tchain.assert(t, !tc.wantEqual)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyMap map[string]interface{}\n\t\t\tmyInt int\n\t\t)\n\t\treporter := newMockReporter(t)\n\n\t\tdata := map[string]interface{}{\"foo\": 123, \"bar\": 456}\n\n\t\tNewObject(reporter, data).InList(myMap{\"foo\": 123.0, \"bar\": 456.0}).\n\t\t\tchain.assert(t, success)\n\n\t\tNewObject(reporter, data).NotInList(myMap{\"foo\": 123.0, \"bar\": 456.0}).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname     string\n\t\t\tvalue    map[string]interface{}\n\t\t\ttestList []interface{}\n\t\t}{\n\t\t\t{\n\t\t\t\tname:     \"empty list\",\n\t\t\t\tvalue:    map[string]interface{}{},\n\t\t\t\ttestList: []interface{}{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"nil list\",\n\t\t\t\tvalue:    map[string]interface{}{},\n\t\t\t\ttestList: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:     \"invalid type\",\n\t\t\t\tvalue:    map[string]interface{}{},\n\t\t\t\ttestList: []interface{}{func() {}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"one inequal object, another not object\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\"bar\": 123.0},\n\t\t\t\t\t\"NOT OBJECT\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"one equal object, another not object\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": 123.0},\n\t\t\t\ttestList: []interface{}{\n\t\t\t\t\tmap[string]interface{}{\"foo\": 123.0},\n\t\t\t\t\t\"NOT OBJECT\",\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.value).InList(tc.testList...).\n\t\t\t\t\tchain.assert(t, failure)\n\n\t\t\t\tNewObject(reporter, tc.value).NotInList(tc.testList...).\n\t\t\t\t\tchain.assert(t, failure)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestObject_ContainsKey(t *testing.T) {\n\ttestObj := map[string]interface{}{\"foo\": 123, \"bar\": \"\"}\n\n\tcases := []struct {\n\t\tname               string\n\t\tobject             map[string]interface{}\n\t\tkey                string\n\t\twantContainsKey    chainResult\n\t\twantNotContainsKey chainResult\n\t}{\n\t\t{\n\t\t\tname:               \"foo value, correct key value\",\n\t\t\tobject:             testObj,\n\t\t\tkey:                \"foo\",\n\t\t\twantContainsKey:    success,\n\t\t\twantNotContainsKey: failure,\n\t\t},\n\t\t{\n\t\t\tname:               \"bar value, correct key value\",\n\t\t\tobject:             testObj,\n\t\t\tkey:                \"bar\",\n\t\t\twantContainsKey:    success,\n\t\t\twantNotContainsKey: failure,\n\t\t},\n\t\t{\n\t\t\tname:               \"BAR value, wrong key value\",\n\t\t\tobject:             testObj,\n\t\t\tkey:                \"BAR\",\n\t\t\twantContainsKey:    failure,\n\t\t\twantNotContainsKey: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewObject(reporter, tc.object).ContainsKey(tc.key).\n\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\tNewObject(reporter, tc.object).NotContainsKey(tc.key).\n\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t})\n\t}\n}\n\nfunc TestObject_ContainsValue(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\"foo\": 123, \"bar\": \"xxx\"}\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"123 value, correct value\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              123,\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"xxx value, correct value\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              \"xxx\",\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"XXX value, wrong value\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              \"XXX\",\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttype (\n\t\t\tA struct {\n\t\t\t\tB int `json:\"b\"`\n\t\t\t\tC int `json:\"c\"`\n\t\t\t}\n\n\t\t\tBaz struct {\n\t\t\t\tA A `json:\"a\"`\n\t\t\t}\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"correct value, contains slice\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              []interface{}{\"456\", 789},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"correct value, contains nested map\",\n\t\t\t\tobject: testObj,\n\t\t\t\tvalue: Baz{\n\t\t\t\t\tA: A{\n\t\t\t\t\t\tB: 333,\n\t\t\t\t\t\tC: 444,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\"foo\": 123, \"bar\": 789}\n\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"correct value, wrapped primitive\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              myInt(789.0),\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\"foo\": 123, \"bar\": \"xxx\"}\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"invalid value, channel\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              make(chan int),\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsValue(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestObject_ContainsSubset(t *testing.T) {\n\tt.Run(\"success\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tsubset             map[string]interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"partial subset with slices\",\n\t\t\t\tobject: testObj,\n\t\t\t\tsubset: map[string]interface{}{\n\t\t\t\t\t\"foo\": 123,\n\t\t\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"partial subset with nested maps\",\n\t\t\t\tobject: testObj,\n\t\t\t\tsubset: map[string]interface{}{\n\t\t\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\t\t\"c\": 444,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsSubset(tc.subset).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsSubset(tc.subset).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"failure\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tsubset             map[string]interface{}\n\t\t\tassertion          uint\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"partial subset with wrong key\",\n\t\t\t\tobject: testObj,\n\t\t\t\tsubset: map[string]interface{}{\n\t\t\t\t\t\"foo\": 123,\n\t\t\t\t\t\"qux\": 456,\n\t\t\t\t},\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:   \"partial subset with nested map\",\n\t\t\t\tobject: testObj,\n\t\t\t\tsubset: map[string]interface{}{\n\t\t\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\t\t\"b\": \"333\",\n\t\t\t\t\t\t\t\"c\": 444,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"nil subset\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tsubset:             nil,\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsSubset(tc.subset).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsSubset(tc.subset).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttype (\n\t\t\tA struct {\n\t\t\t\tB int `json:\"b\"`\n\t\t\t}\n\n\t\t\tBaz struct {\n\t\t\t\tA A `json:\"a\"`\n\t\t\t}\n\n\t\t\tS struct {\n\t\t\t\tFoo int `json:\"foo\"`\n\t\t\t\tBaz Baz `json:\"baz\"`\n\t\t\t}\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"partial subset\",\n\t\t\t\tobject: testObj,\n\t\t\t\tvalue: S{\n\t\t\t\t\tFoo: 123,\n\t\t\t\t\tBaz: Baz{\n\t\t\t\t\t\tA: A{\n\t\t\t\t\t\t\tB: 333,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"empty subset\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tvalue:              S{},\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsSubset(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsSubset(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttype (\n\t\t\tmyArray []interface{}\n\t\t\tmyMap   map[string]interface{}\n\t\t\tmyInt   int\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"correct value, wrapped map\",\n\t\t\t\tobject: testObj,\n\t\t\t\tvalue: myMap{\n\t\t\t\t\t\"foo\": myInt(123),\n\t\t\t\t\t\"bar\": myArray{\"456\", myInt(789)},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).ContainsSubset(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotContainsSubset(tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestObject_HasValue(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tkey                string\n\t\t\tvalue              interface{}\n\t\t\tassertion          uint\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"correct key-value with primitives\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"foo\",\n\t\t\t\tvalue:              123,\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"correct key-value with slices\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"bar\",\n\t\t\t\tvalue:              []interface{}{\"456\", 789},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"wrong key-value with maps\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"baz\",\n\t\t\t\tvalue:              map[string]interface{}{\"a\": \"b\"},\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"wrong value with empty func\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"baz\",\n\t\t\t\tvalue:              func() {},\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"wrong key-value with primitive\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"BAZ\",\n\t\t\t\tvalue:              777,\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).HasValue(tc.key, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotHasValue(tc.key, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": map[string]interface{}{\n\t\t\t\t\t\"b\": 333,\n\t\t\t\t\t\"c\": 444,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttype (\n\t\t\tA struct {\n\t\t\t\tB int `json:\"b\"`\n\t\t\t\tC int `json:\"c\"`\n\t\t\t}\n\n\t\t\tBaz struct {\n\t\t\t\tA A `json:\"a\"`\n\t\t\t}\n\t\t)\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tkey                string\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:   \"partial subset\",\n\t\t\t\tobject: testObj,\n\t\t\t\tkey:    \"baz\",\n\t\t\t\tvalue: Baz{\n\t\t\t\t\tA: A{\n\t\t\t\t\t\tB: 333,\n\t\t\t\t\t\tC: 444,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"empty subset\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"baz\",\n\t\t\t\tvalue:              Baz{},\n\t\t\t\twantContainsKey:    failure,\n\t\t\t\twantNotContainsKey: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).HasValue(tc.key, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotHasValue(tc.key, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyArray []interface{}\n\t\t\tmyMap   map[string]interface{}\n\t\t\tmyInt   int\n\t\t)\n\n\t\ttestObj := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"456\", 789},\n\t\t\t\"baz\": map[string]interface{}{\n\t\t\t\t\"a\": \"b\",\n\t\t\t},\n\t\t}\n\n\t\tcases := []struct {\n\t\t\tname               string\n\t\t\tobject             map[string]interface{}\n\t\t\tkey                string\n\t\t\tvalue              interface{}\n\t\t\twantContainsKey    chainResult\n\t\t\twantNotContainsKey chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:               \"correct value, wrapped array\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"bar\",\n\t\t\t\tvalue:              myArray{\"456\", myInt(789)},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:               \"correct value, wrapped map\",\n\t\t\t\tobject:             testObj,\n\t\t\t\tkey:                \"baz\",\n\t\t\t\tvalue:              myMap{\"a\": \"b\"},\n\t\t\t\twantContainsKey:    success,\n\t\t\t\twantNotContainsKey: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewObject(reporter, tc.object).HasValue(tc.key, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantContainsKey)\n\n\t\t\t\tNewObject(reporter, tc.object).NotHasValue(tc.key, tc.value).\n\t\t\t\t\tchain.assert(t, tc.wantNotContainsKey)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestObject_Iter(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tm := map[string]interface{}{\n\t\t\"foo\": 123.0,\n\t\t\"bar\": []interface{}{\"456\", 789.0},\n\t}\n\n\tvalue := NewObject(reporter, m)\n\n\tit := value.Iter()\n\n\tassert.NotNil(t, it)\n\tassert.Equal(t, 2, len(it))\n\tassert.Equal(t, it[\"foo\"].value, value.Value(\"foo\").Raw())\n\tassert.Equal(t, it[\"bar\"].value, value.Value(\"bar\").Raw())\n\n\tit[\"foo\"].chain.assert(t, success)\n\tit[\"bar\"].chain.assert(t, success)\n\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestObject_Every(t *testing.T) {\n\tt.Run(\"check value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"b\",\n\t\t})\n\n\t\tinvoked := 0\n\t\tobject.Every(func(_ string, value *Value) {\n\t\t\tinvoked++\n\t\t\tvalue.String().NotEmpty()\n\t\t})\n\n\t\tassert.Equal(t, 3, invoked)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"check key\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"b\",\n\t\t})\n\n\t\tinvoked := 0\n\t\tobject.Every(func(key string, value *Value) {\n\t\t\tif v, ok := value.Raw().(string); ok {\n\t\t\t\tinvoked++\n\t\t\t\tswitch v {\n\t\t\t\tcase \"123\":\n\t\t\t\t\tassert.Equal(t, \"foo\", key)\n\t\t\t\tcase \"456\":\n\t\t\t\t\tassert.Equal(t, \"bar\", key)\n\t\t\t\tcase \"baz\":\n\t\t\t\t\tassert.Equal(t, \"baz\", key)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tassert.Equal(t, 3, invoked)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty object\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\n\t\tinvoked := 0\n\t\tobject.Every(func(_ string, value *Value) {\n\t\t\tinvoked++\n\t\t\tvalue.String().NotEmpty()\n\t\t})\n\n\t\tassert.Equal(t, 0, invoked)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"one assertion fails\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\"foo\": \"\", \"bar\": \"bar\"})\n\n\t\tinvoked := 0\n\t\tobject.Every(func(_ string, val *Value) {\n\t\t\tinvoked++\n\t\t\tval.String().NotEmpty()\n\t\t})\n\n\t\tassert.Equal(t, 2, invoked)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"all assertions fail\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\"foo\": \"\", \"bar\": \"\"})\n\n\t\tinvoked := 0\n\t\tobject.Every(func(_ string, val *Value) {\n\t\t\tinvoked++\n\t\t\tval.String().NotEmpty()\n\t\t})\n\n\t\tassert.Equal(t, 2, invoked)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"call order\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"bar\": \"123\",\n\t\t\t\"baz\": \"456\",\n\t\t\t\"foo\": \"foo\",\n\t\t\t\"foz\": \"foo\",\n\t\t\t\"b\":   \"789\",\n\t\t\t\"c\":   \"987\",\n\t\t})\n\n\t\tvar actualOrder []string\n\t\tobject.Every(func(key string, val *Value) {\n\t\t\tactualOrder = append(actualOrder, key)\n\t\t})\n\n\t\texpectedOrder := []string{\"b\", \"bar\", \"baz\", \"c\", \"foo\", \"foz\"}\n\t\tassert.Equal(t, expectedOrder, actualOrder)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\t\tobject.Every((func(key string, value *Value))(nil))\n\t\tobject.chain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_Transform(t *testing.T) {\n\tt.Run(\"check index\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"baz\",\n\t\t})\n\n\t\tnewObject := object.Transform(func(key string, value interface{}) interface{} {\n\t\t\tif v, ok := value.(string); ok {\n\t\t\t\tswitch v {\n\t\t\t\tcase \"123\":\n\t\t\t\t\tassert.Equal(t, \"foo\", key)\n\t\t\t\tcase \"456\":\n\t\t\t\t\tassert.Equal(t, \"bar\", key)\n\t\t\t\tcase \"baz\":\n\t\t\t\t\tassert.Equal(t, \"baz\", key)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value\n\t\t})\n\n\t\tnewObject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"transform value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"b\",\n\t\t})\n\n\t\tnewObject := object.Transform(func(_ string, value interface{}) interface{} {\n\t\t\tif v, ok := value.(string); ok {\n\t\t\t\treturn \"Hello \" + v\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"foo\": \"Hello 123\",\n\t\t\t\t\"bar\": \"Hello 456\",\n\t\t\t\t\"baz\": \"Hello b\",\n\t\t\t},\n\t\t\tnewObject.value,\n\t\t)\n\t})\n\n\tt.Run(\"empty object\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"b\",\n\t\t})\n\n\t\tnewObject := object.Transform(func(_ string, value interface{}) interface{} {\n\t\t\tif v, ok := value.(string); ok {\n\t\t\t\treturn \"Hello \" + v\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\tnewObject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"call order\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"b\":   \"456\",\n\t\t\t\"baz\": \"baz\",\n\t\t})\n\n\t\tactualOrder := []string{}\n\t\tobject.Transform(func(key string, value interface{}) interface{} {\n\t\t\tactualOrder = append(actualOrder, key)\n\t\t\treturn value\n\t\t})\n\n\t\texpectedOrder := []string{\"b\", \"bar\", \"baz\", \"foo\"}\n\t\tassert.Equal(t, expectedOrder, actualOrder)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"b\",\n\t\t})\n\n\t\tnewObject := object.Transform(nil)\n\n\t\tnewObject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"canonization\", func(t *testing.T) {\n\t\ttype (\n\t\t\tmyInt int\n\t\t)\n\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"123\",\n\t\t\t\"bar\": \"456\",\n\t\t\t\"baz\": \"b\",\n\t\t})\n\n\t\tnewObject := object.Transform(func(_ string, val interface{}) interface{} {\n\t\t\tif v, err := strconv.ParseFloat(val.(string), 64); err == nil {\n\t\t\t\treturn myInt(v)\n\t\t\t}\n\t\t\treturn val\n\t\t})\n\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"foo\": 123.0,\n\t\t\t\t\"bar\": 456.0,\n\t\t\t\t\"baz\": \"b\",\n\t\t\t},\n\t\t\tnewObject.Raw())\n\t\tnewObject.chain.assert(t, success)\n\t})\n}\n\nfunc TestObject_Filter(t *testing.T) {\n\tt.Run(\"elements of same type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t\t\"baz\": \"qux\", \"quux\": \"corge\",\n\t\t})\n\n\t\tfilteredObject := object.Filter(func(key string, value *Value) bool {\n\t\t\treturn value.Raw() != \"qux\" && key != \"quux\"\n\t\t})\n\n\t\tassert.Equal(t, map[string]interface{}{\"foo\": \"bar\"}, filteredObject.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t\t\"baz\": \"qux\", \"quux\": \"corge\",\n\t\t})\n\n\t\tfilteredObject.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"elements of different types\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t\t\"baz\": 3.0, \"qux\": false,\n\t\t})\n\n\t\tfilteredObject := object.Filter(func(key string, value *Value) bool {\n\t\t\treturn value.Raw() != \"bar\" && value.Raw() != 3.0\n\t\t})\n\n\t\tassert.Equal(t, map[string]interface{}{\"qux\": false}, filteredObject.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t\t\"baz\": 3.0, \"qux\": false,\n\t\t})\n\n\t\tfilteredObject.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty object\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\n\t\tfilteredObject := object.Filter(func(key string, value *Value) bool {\n\t\t\treturn false\n\t\t})\n\t\tassert.Equal(t, map[string]interface{}{}, filteredObject.Raw())\n\n\t\tfilteredObject.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t\t\"baz\": \"qux\", \"quux\": \"corge\",\n\t\t})\n\n\t\tfilteredObject := object.Filter(func(key string, value *Value) bool {\n\t\t\treturn false\n\t\t})\n\n\t\tassert.Equal(t, map[string]interface{}{}, filteredObject.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t\t\"baz\": \"qux\", \"quux\": \"corge\",\n\t\t})\n\n\t\tfilteredObject.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"assertion fails\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": \"bar\", \"baz\": 6.0,\n\t\t\t\"qux\": \"quux\",\n\t\t})\n\n\t\tfilteredObject := object.Filter(func(key string, value *Value) bool {\n\t\t\tstringifiedValue := value.String().NotEmpty().Raw()\n\t\t\treturn stringifiedValue != \"bar\"\n\t\t})\n\n\t\tassert.Equal(t, map[string]interface{}{\"qux\": \"quux\"}, filteredObject.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": \"bar\", \"baz\": 6.0,\n\t\t\t\"qux\": \"quux\",\n\t\t})\n\n\t\tfilteredObject.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"call order\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  \"qux\",\n\t\t\t\"bar\":  \"qux\",\n\t\t\t\"b\":    \"qux\",\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tvar actualOrder []string\n\t\tobject.Filter(func(key string, value *Value) bool {\n\t\t\tactualOrder = append(actualOrder, key)\n\t\t\treturn false\n\t\t})\n\n\t\texpectedOrder := []string{\"b\", \"bar\", \"baz\", \"foo\", \"quux\"}\n\t\tassert.Equal(t, expectedOrder, actualOrder)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\t\tfilteredObject := object.Filter((func(key string, value *Value) bool)(nil))\n\t\tobject.chain.assert(t, failure)\n\t\tfilteredObject.chain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_Find(t *testing.T) {\n\tt.Run(\"elements of same type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  \"qux\",\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tfoundValue := object.Find(func(key string, value *Value) bool {\n\t\t\treturn key == \"baz\"\n\t\t})\n\n\t\tassert.Equal(t, \"qux\", foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  \"qux\",\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tfoundValue.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"elements of different types\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1,\n\t\t\t\"quux\": 2,\n\t\t})\n\n\t\tfoundValue := object.Find(func(key string, value *Value) bool {\n\t\t\tn := value.Number().Raw()\n\t\t\treturn n > 1\n\t\t})\n\n\t\tassert.Equal(t, 2.0, foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1.0,\n\t\t\t\"quux\": 2.0,\n\t\t})\n\n\t\tfoundValue.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1,\n\t\t\t\"quux\": 2,\n\t\t})\n\n\t\tfoundValue := object.Find(func(key string, value *Value) bool {\n\t\t\tn := value.Number().Raw()\n\t\t\treturn n == 3\n\t\t})\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1.0,\n\t\t\t\"quux\": 2.0,\n\t\t})\n\n\t\tfoundValue.chain.assert(t, failure)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"empty object\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\n\t\tfoundValue := object.Find(func(key string, value *Value) bool {\n\t\t\tn := value.Number().Raw()\n\t\t\treturn n == 3\n\t\t})\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{})\n\n\t\tfoundValue.chain.assert(t, failure)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t})\n\n\t\tfoundValue := object.Find(func(key string, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": 1.0,\n\t\t\t\"bar\": 2.0,\n\t\t})\n\n\t\tfoundValue.chain.assert(t, failure)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, have match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t\t\"baz\": \"str\",\n\t\t})\n\n\t\tfoundValue := object.Find(func(key string, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Equal(t, \"str\", foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": 1.0,\n\t\t\t\"bar\": 2.0,\n\t\t\t\"baz\": \"str\",\n\t\t})\n\n\t\tfoundValue.chain.assert(t, success)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t})\n\n\t\tfoundValue := object.Find(nil)\n\n\t\tassert.Equal(t, nil, foundValue.Raw())\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": 1.0,\n\t\t\t\"bar\": 2.0,\n\t\t})\n\n\t\tfoundValue.chain.assert(t, failure)\n\t\tobject.chain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_FindAll(t *testing.T) {\n\tt.Run(\"elements of same type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  \"qux\",\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tfoundValues := object.FindAll(func(key string, value *Value) bool {\n\t\t\treturn key == \"baz\" || key == \"quux\"\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{\"qux\", \"corge\"}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  \"qux\",\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"elements of different types\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":   \"bar\",\n\t\t\t\"baz\":   6,\n\t\t\t\"qux\":   \"quux\",\n\t\t\t\"corge\": \"grault\",\n\t\t})\n\n\t\tfoundValues := object.FindAll(func(key string, value *Value) bool {\n\t\t\tvalue.String().NotEmpty()\n\t\t\treturn key != \"qux\"\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{\"grault\", \"bar\"}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":   \"bar\",\n\t\t\t\"baz\":   6.0,\n\t\t\t\"qux\":   \"quux\",\n\t\t\t\"corge\": \"grault\",\n\t\t})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1,\n\t\t\t\"quux\": 2,\n\t\t})\n\n\t\tfoundValues := object.FindAll(func(key string, value *Value) bool {\n\t\t\treturn value.Number().Raw() == 3.0\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1.0,\n\t\t\t\"quux\": 2.0,\n\t\t})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty object\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\n\t\tfoundValues := object.FindAll(func(key string, value *Value) bool {\n\t\t\treturn value.Number().Raw() == 3.0\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t})\n\n\t\tfoundValues := object.FindAll(func(key string, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": 1.0,\n\t\t\t\"bar\": 2.0,\n\t\t})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, have matches\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  1,\n\t\t\t\"qux\":  2,\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tfoundValues := object.FindAll(func(key string, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{\"bar\", \"corge\"}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  1.0,\n\t\t\t\"qux\":  2.0,\n\t\t\t\"quux\": \"corge\",\n\t\t})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, success)\n\t\t}\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t})\n\n\t\tfoundValues := object.FindAll(nil)\n\n\t\tactual := []interface{}{}\n\t\tfor _, value := range foundValues {\n\t\t\tactual = append(actual, value.Raw())\n\t\t}\n\n\t\tassert.Equal(t, []interface{}{}, actual)\n\t\tassert.Equal(t, object.Raw(), map[string]interface{}{\n\t\t\t\"foo\": 1.0,\n\t\t\t\"bar\": 2.0,\n\t\t})\n\n\t\tfor _, value := range foundValues {\n\t\t\tvalue.chain.assert(t, failure)\n\t\t}\n\t\tobject.chain.assert(t, failure)\n\t})\n}\n\nfunc TestObject_NotFind(t *testing.T) {\n\tt.Run(\"no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1,\n\t\t\t\"quux\": 2,\n\t\t})\n\n\t\tafterObject := object.NotFind(func(key string, value *Value) bool {\n\t\t\treturn key == \"corge\"\n\t\t})\n\n\t\tassert.Same(t, object, afterObject)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"have match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\":  \"bar\",\n\t\t\t\"baz\":  true,\n\t\t\t\"qux\":  -1,\n\t\t\t\"quux\": 2,\n\t\t})\n\n\t\tafterObject := object.NotFind(func(key string, value *Value) bool {\n\t\t\treturn key == \"qux\"\n\t\t})\n\n\t\tassert.Same(t, object, afterObject)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"empty object\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{})\n\n\t\tafterObject := object.NotFind(func(key string, value *Value) bool {\n\t\t\treturn key == \"corge\"\n\t\t})\n\n\t\tassert.Same(t, object, afterObject)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, no match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t})\n\n\t\tafterObject := object.NotFind(func(key string, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Same(t, object, afterObject)\n\t\tobject.chain.assert(t, success)\n\t})\n\n\tt.Run(\"predicate returns true, assertion fails, have match\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t\t\"baz\": \"str\",\n\t\t})\n\n\t\tafterObject := object.NotFind(func(key string, value *Value) bool {\n\t\t\tvalue.String()\n\t\t\treturn true\n\t\t})\n\n\t\tassert.Same(t, object, afterObject)\n\t\tobject.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tobject := NewObject(reporter, map[string]interface{}{\n\t\t\t\"foo\": 1,\n\t\t\t\"bar\": 2,\n\t\t})\n\n\t\tafterObject := object.NotFind(nil)\n\n\t\tassert.Same(t, object, afterObject)\n\t\tobject.chain.assert(t, failure)\n\t})\n}\n"
        },
        {
          "name": "printer.go",
          "type": "blob",
          "size": 4.4052734375,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"moul.io/http2curl/v2\"\n)\n\n// Printer is used to print requests and responses.\n// CompactPrinter, DebugPrinter, and CurlPrinter implement this interface.\ntype Printer interface {\n\t// Request is called before request is sent.\n\t// It is allowed to read and close request body, or ignore it.\n\tRequest(*http.Request)\n\n\t// Response is called after response is received.\n\t// It is allowed to read and close response body, or ignore it.\n\tResponse(*http.Response, time.Duration)\n}\n\n// WebsocketPrinter is used to print writes and reads of WebSocket connection.\n//\n// If WebSocket connection is used, all Printers that also implement WebsocketPrinter\n// are invoked on every WebSocket message read or written.\n//\n// DebugPrinter implements this interface.\ntype WebsocketPrinter interface {\n\tPrinter\n\n\t// WebsocketWrite is called before writes to WebSocket connection.\n\tWebsocketWrite(typ int, content []byte, closeCode int)\n\n\t// WebsocketRead is called after reads from WebSocket connection.\n\tWebsocketRead(typ int, content []byte, closeCode int)\n}\n\n// CompactPrinter implements Printer.\n// Prints requests in compact form. Does not print responses.\ntype CompactPrinter struct {\n\tlogger Logger\n}\n\n// NewCompactPrinter returns a new CompactPrinter given a logger.\nfunc NewCompactPrinter(logger Logger) CompactPrinter {\n\treturn CompactPrinter{logger}\n}\n\n// Request implements Printer.Request.\nfunc (p CompactPrinter) Request(req *http.Request) {\n\tif req != nil {\n\t\tp.logger.Logf(\"%s %s\", req.Method, req.URL)\n\t}\n}\n\n// Response implements Printer.Response.\nfunc (CompactPrinter) Response(*http.Response, time.Duration) {\n}\n\n// CurlPrinter implements Printer.\n// Uses http2curl to dump requests as curl commands that can be inserted\n// into terminal.\ntype CurlPrinter struct {\n\tlogger Logger\n}\n\n// NewCurlPrinter returns a new CurlPrinter given a logger.\nfunc NewCurlPrinter(logger Logger) CurlPrinter {\n\treturn CurlPrinter{logger}\n}\n\n// Request implements Printer.Request.\nfunc (p CurlPrinter) Request(req *http.Request) {\n\tif req != nil {\n\t\tcmd, err := http2curl.GetCurlCommand(req)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tp.logger.Logf(\"%s\", cmd.String())\n\t}\n}\n\n// Response implements Printer.Response.\nfunc (CurlPrinter) Response(*http.Response, time.Duration) {\n}\n\n// DebugPrinter implements Printer and WebsocketPrinter.\n// Uses net/http/httputil to dump both requests and responses.\n// Also prints all websocket messages.\ntype DebugPrinter struct {\n\tlogger Logger\n\tbody   bool\n}\n\n// NewDebugPrinter returns a new DebugPrinter given a logger and body\n// flag. If body is true, request and response body is also printed.\nfunc NewDebugPrinter(logger Logger, body bool) DebugPrinter {\n\treturn DebugPrinter{logger, body}\n}\n\n// Request implements Printer.Request.\nfunc (p DebugPrinter) Request(req *http.Request) {\n\tif req == nil {\n\t\treturn\n\t}\n\n\tdump, err := httputil.DumpRequest(req, p.body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tp.logger.Logf(\"%s\", dump)\n}\n\n// Response implements Printer.Response.\nfunc (p DebugPrinter) Response(resp *http.Response, duration time.Duration) {\n\tif resp == nil {\n\t\treturn\n\t}\n\n\tdump, err := httputil.DumpResponse(resp, p.body)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttext := strings.Replace(string(dump), \"\\r\\n\", \"\\n\", -1)\n\tlines := strings.SplitN(text, \"\\n\", 2)\n\n\tp.logger.Logf(\"%s %s\\n%s\", lines[0], duration, lines[1])\n}\n\n// WebsocketWrite implements WebsocketPrinter.WebsocketWrite.\nfunc (p DebugPrinter) WebsocketWrite(typ int, content []byte, closeCode int) {\n\tb := &bytes.Buffer{}\n\tfmt.Fprintf(b, \"-> Sent: %s\", wsMessageType(typ))\n\tif typ == websocket.CloseMessage {\n\t\tfmt.Fprintf(b, \" %s\", wsCloseCode(closeCode))\n\t}\n\tfmt.Fprint(b, \"\\n\")\n\tif len(content) > 0 {\n\t\tif typ == websocket.BinaryMessage {\n\t\t\tfmt.Fprintf(b, \"%v\\n\", content)\n\t\t} else {\n\t\t\tfmt.Fprintf(b, \"%s\\n\", content)\n\t\t}\n\t}\n\tfmt.Fprintf(b, \"\\n\")\n\tp.logger.Logf(b.String())\n}\n\n// WebsocketRead implements WebsocketPrinter.WebsocketRead.\nfunc (p DebugPrinter) WebsocketRead(typ int, content []byte, closeCode int) {\n\tb := &bytes.Buffer{}\n\tfmt.Fprintf(b, \"<- Received: %s\", wsMessageType(typ))\n\tif typ == websocket.CloseMessage {\n\t\tfmt.Fprintf(b, \" %s\", wsCloseCode(closeCode))\n\t}\n\tfmt.Fprint(b, \"\\n\")\n\tif len(content) > 0 {\n\t\tif typ == websocket.BinaryMessage {\n\t\t\tfmt.Fprintf(b, \"%v\\n\", content)\n\t\t} else {\n\t\t\tfmt.Fprintf(b, \"%s\\n\", content)\n\t\t}\n\t}\n\tfmt.Fprintf(b, \"\\n\")\n\tp.logger.Logf(b.String())\n}\n"
        },
        {
          "name": "printer_test.go",
          "type": "blob",
          "size": 1.708984375,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype failingReader struct{}\n\nfunc (failingReader) Read(_ []byte) (n int, err error) {\n\treturn 0, errors.New(\"error\")\n}\n\nfunc (failingReader) Close() error {\n\treturn errors.New(\"error\")\n}\n\nfunc TestPrinter_Compact(t *testing.T) {\n\tprinter := NewCompactPrinter(t)\n\n\tbody1 := bytes.NewBufferString(\"body1\")\n\tbody2 := bytes.NewBufferString(\"body2\")\n\n\treq1, _ := http.NewRequest(\"GET\", \"http://example.com\", body1)\n\treq2, _ := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\n\tprinter.Request(req1)\n\tprinter.Request(req2)\n\tprinter.Request(nil)\n\n\tprinter.Response(&http.Response{Body: io.NopCloser(body2)}, 0)\n\tprinter.Response(&http.Response{}, 0)\n\tprinter.Response(nil, 0)\n}\n\nfunc TestPrinter_Debug(t *testing.T) {\n\tprinter := NewDebugPrinter(t, true)\n\n\tbody1 := bytes.NewBufferString(\"body1\")\n\tbody2 := bytes.NewBufferString(\"body2\")\n\n\treq1, _ := http.NewRequest(\"GET\", \"http://example.com\", body1)\n\treq2, _ := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\n\tprinter.Request(req1)\n\tprinter.Request(req2)\n\tprinter.Request(nil)\n\n\tprinter.Response(&http.Response{Body: io.NopCloser(body2)}, 0)\n\tprinter.Response(&http.Response{}, 0)\n\tprinter.Response(nil, 0)\n}\n\nfunc TestPrinter_Panics(t *testing.T) {\n\tt.Run(\"CurlPrinter\", func(t *testing.T) {\n\t\tcurl := NewCurlPrinter(t)\n\n\t\tassert.Panics(t, func() {\n\t\t\tcurl.Request(&http.Request{})\n\t\t})\n\t})\n\n\tt.Run(\"DebugPrinter\", func(t *testing.T) {\n\t\tcurl := NewDebugPrinter(t, true)\n\n\t\tassert.Panics(t, func() {\n\t\t\tcurl.Request(&http.Request{\n\t\t\t\tBody: failingReader{},\n\t\t\t})\n\t\t})\n\n\t\tassert.Panics(t, func() {\n\t\t\tcurl.Response(&http.Response{\n\t\t\t\tBody: failingReader{},\n\t\t\t}, 0)\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "reflect.go",
          "type": "blob",
          "size": 0.6337890625,
          "content": "package httpexpect\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n)\n\nfunc refIsNil(value interface{}) bool {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\treturn value == nil || reflect.ValueOf(value).IsNil()\n}\n\nfunc refIsNum(value interface{}) bool {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\treflect.ValueOf(value).Convert(reflect.TypeOf(float64(0))).Float()\n\treturn true\n}\n\nfunc refIsHTTP(value interface{}) bool {\n\tswitch value.(type) {\n\tcase *http.Client, http.Client,\n\t\t*http.Transport, http.Transport,\n\t\t*http.Request, http.Request,\n\t\t*http.Response, http.Response,\n\t\t*http.Header, http.Header,\n\t\t*http.Cookie, http.Cookie:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n"
        },
        {
          "name": "reporter.go",
          "type": "blob",
          "size": 2.142578125,
          "content": "package httpexpect\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// AssertReporter implements Reporter interface using `testify/assert'\n// package. Failures are non-fatal with this reporter.\ntype AssertReporter struct {\n\tbackend *assert.Assertions\n}\n\n// NewAssertReporter returns a new AssertReporter object.\nfunc NewAssertReporter(t assert.TestingT) *AssertReporter {\n\treturn &AssertReporter{assert.New(t)}\n}\n\n// Errorf implements Reporter.Errorf.\nfunc (r *AssertReporter) Errorf(message string, args ...interface{}) {\n\tr.backend.Fail(fmt.Sprintf(message, args...))\n}\n\n// RequireReporter implements Reporter interface using `testify/require'\n// package. Failures are fatal with this reporter.\ntype RequireReporter struct {\n\tbackend *require.Assertions\n}\n\n// NewRequireReporter returns a new RequireReporter object.\nfunc NewRequireReporter(t require.TestingT) *RequireReporter {\n\treturn &RequireReporter{require.New(t)}\n}\n\n// Errorf implements Reporter.Errorf.\nfunc (r *RequireReporter) Errorf(message string, args ...interface{}) {\n\tr.backend.FailNow(fmt.Sprintf(message, args...))\n}\n\n// FatalReporter is a struct that implements the Reporter interface\n// and calls t.Fatalf() when a test fails.\ntype FatalReporter struct {\n\tbackend testing.TB\n}\n\n// NewFatalReporter returns a new FatalReporter object.\nfunc NewFatalReporter(t testing.TB) *FatalReporter {\n\treturn &FatalReporter{t}\n}\n\n// Errorf implements Reporter.Errorf.\nfunc (r *FatalReporter) Errorf(message string, args ...interface{}) {\n\tr.backend.Fatalf(fmt.Sprintf(message, args...))\n}\n\n// PanicReporter is a struct that implements the Reporter interface\n// and panics when a test fails.\n// Useful for multithreaded tests when you want to report fatal\n// failures from goroutines other than the main goroutine, because\n// the main goroutine is forbidden to call t.Fatal.\ntype PanicReporter struct{}\n\n// NewPanicReporter returns a new PanicReporter object.\nfunc NewPanicReporter() *PanicReporter {\n\treturn &PanicReporter{}\n}\n\n// Errorf implements Reporter.Errorf\nfunc (r *PanicReporter) Errorf(message string, args ...interface{}) {\n\tpanic(fmt.Sprintf(message, args...))\n}\n"
        },
        {
          "name": "reporter_test.go",
          "type": "blob",
          "size": 1.1875,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype mockT struct {\n\ttesting.T\n\tfatalfInvoked bool\n}\n\nfunc (m *mockT) Fatalf(format string, args ...interface{}) {\n\tm.fatalfInvoked = true\n}\n\ntype mockAssertT struct {\n\terrorfInvoked bool\n}\n\nfunc (m *mockAssertT) Errorf(format string, args ...interface{}) {\n\tm.errorfInvoked = true\n}\n\ntype mockRequireT struct {\n\ttesting.T\n\tfailNowInvoked bool\n}\n\nfunc (m *mockRequireT) FailNow() {\n\tm.failNowInvoked = true\n}\n\nfunc TestReporter_AssertReporter(t *testing.T) {\n\tmockBackend := &mockAssertT{}\n\treporter := NewAssertReporter(mockBackend)\n\n\treporter.Errorf(\"test\")\n\tassert.True(t, mockBackend.errorfInvoked)\n}\n\nfunc TestReporter_RequireReporter(t *testing.T) {\n\tmockBackend := &mockRequireT{}\n\treporter := NewRequireReporter(mockBackend)\n\n\treporter.Errorf(\"test\")\n\tassert.True(t, mockBackend.failNowInvoked)\n}\n\nfunc TestReporter_FatalReporter(t *testing.T) {\n\tmockBackend := &mockT{}\n\treporter := NewFatalReporter(mockBackend)\n\n\treporter.Errorf(\"test\")\n\tassert.True(t, mockBackend.fatalfInvoked)\n}\n\nfunc TestReporter_PanicReporter(t *testing.T) {\n\treporter := NewPanicReporter()\n\n\tassert.Panics(t, func() {\n\t\treporter.Errorf(\"test\")\n\t})\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 54.6240234375,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ajg/form\"\n\t\"github.com/fatih/structs\"\n\t\"github.com/google/go-querystring/query\"\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/imkira/go-interpol\"\n)\n\n// Request provides methods to incrementally build http.Request object,\n// send it, and receive response.\ntype Request struct {\n\tmu sync.Mutex\n\n\tconfig Config\n\tchain  *chain\n\n\tredirectPolicy RedirectPolicy\n\tmaxRedirects   int\n\n\tretryPolicy   RetryPolicy\n\tmaxRetries    int\n\tminRetryDelay time.Duration\n\tmaxRetryDelay time.Duration\n\tsleepFn       func(d time.Duration) <-chan time.Time\n\n\ttimeout time.Duration\n\n\thttpReq *http.Request\n\tpath    string\n\tquery   url.Values\n\n\tform        url.Values\n\tformbuf     *bytes.Buffer\n\tmultipart   *multipart.Writer\n\tmultipartFn func(w io.Writer) *multipart.Writer\n\n\tbodySetter   string\n\ttypeSetter   string\n\tforceType    bool\n\texpectCalled bool\n\n\twsUpgrade bool\n\n\ttransformers []func(*http.Request)\n\tmatchers     []func(*Response)\n}\n\n// Deprecated: use NewRequestC instead.\nfunc NewRequest(config Config, method, path string, pathargs ...interface{}) *Request {\n\treturn NewRequestC(config, method, path, pathargs...)\n}\n\n// NewRequestC returns a new Request instance.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// method defines the HTTP method (GET, POST, PUT, etc.). path defines url path.\n//\n// Simple interpolation is allowed for {named} parameters in path:\n//   - if pathargs is given, it's used to substitute first len(pathargs) parameters,\n//     regardless of their names\n//   - if WithPath() or WithPathObject() is called, it's used to substitute given\n//     parameters by name\n//\n// For example:\n//\n//\treq := NewRequestC(config, \"POST\", \"/repos/{user}/{repo}\", \"gavv\", \"httpexpect\")\n//\t// path will be \"/repos/gavv/httpexpect\"\n//\n// Or:\n//\n//\treq := NewRequestC(config, \"POST\", \"/repos/{user}/{repo}\")\n//\treq.WithPath(\"user\", \"gavv\")\n//\treq.WithPath(\"repo\", \"httpexpect\")\n//\t// path will be \"/repos/gavv/httpexpect\"\n//\n// After interpolation, path is urlencoded and appended to Config.BaseURL,\n// separated by slash. If BaseURL ends with a slash and path (after interpolation)\n// starts with a slash, only single slash is inserted.\nfunc NewRequestC(config Config, method, path string, pathargs ...interface{}) *Request {\n\tconfig = config.withDefaults()\n\n\treturn newRequest(\n\t\tnewChainWithConfig(fmt.Sprintf(\"Request(%q)\", method), config),\n\t\tconfig,\n\t\tmethod,\n\t\tpath,\n\t\tpathargs...,\n\t)\n}\n\nfunc newRequest(\n\tparent *chain, config Config, method, path string, pathargs ...interface{},\n) *Request {\n\tconfig.validate()\n\n\tr := &Request{\n\t\tconfig: config,\n\t\tchain:  parent.clone(),\n\n\t\tredirectPolicy: defaultRedirectPolicy,\n\t\tmaxRedirects:   -1,\n\n\t\tretryPolicy:   RetryTimeoutAndServerErrors,\n\t\tmaxRetries:    0,\n\t\tminRetryDelay: time.Millisecond * 50,\n\t\tmaxRetryDelay: time.Second * 5,\n\t\tsleepFn: func(d time.Duration) <-chan time.Time {\n\t\t\treturn time.After(d)\n\t\t},\n\t\tmultipartFn: func(w io.Writer) *multipart.Writer {\n\t\t\treturn multipart.NewWriter(w)\n\t\t},\n\t}\n\n\topChain := r.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\tr.initPath(opChain, path, pathargs...)\n\tr.initReq(opChain, method)\n\n\tr.chain.setRequest(r)\n\n\treturn r\n}\n\nfunc (r *Request) initPath(opChain *chain, path string, pathargs ...interface{}) {\n\tif len(pathargs) != 0 {\n\t\tvar n int\n\n\t\tvar err error\n\t\tpath, err = interpol.WithFunc(path, func(k string, w io.Writer) error {\n\t\t\tif n < len(pathargs) {\n\t\t\t\tif pathargs[n] == nil {\n\t\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\t\tType:   AssertValid,\n\t\t\t\t\t\tActual: &AssertionValue{pathargs},\n\t\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\t\tfmt.Errorf(\"unexpected nil argument at index %d\", n),\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tmustWrite(w, fmt.Sprint(pathargs[n]))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmustWrite(w, \"{\")\n\t\t\t\tmustWrite(w, k)\n\t\t\t\tmustWrite(w, \"}\")\n\t\t\t}\n\t\t\tn++\n\t\t\treturn nil\n\t\t})\n\n\t\tif err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{path},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"invalid interpol string\"),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tr.path = path\n}\n\nfunc (r *Request) initReq(opChain *chain, method string) {\n\thttpReq, err := r.config.RequestFactory.NewRequest(method, r.config.BaseURL, nil)\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to create http request\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t}\n\n\tr.httpReq = httpReq\n}\n\n// Alias is similar to Value.Alias.\nfunc (r *Request) Alias(name string) *Request {\n\topChain := r.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tr.chain.setAlias(name)\n\treturn r\n}\n\n// WithName sets convenient request name.\n// This name will be included in assertion reports for this request.\n// It does not affect assertion chain path, inlike Alias.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"POST\", \"/api/login\")\n//\treq.WithName(\"Login Request\")\nfunc (r *Request) WithName(name string) *Request {\n\topChain := r.chain.enter(\"WithName()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithName()\") {\n\t\treturn r\n\t}\n\n\tr.chain.setRequestName(name)\n\n\treturn r\n}\n\n// WithReporter sets reporter to be used for this request.\n//\n// The new reporter overwrites AssertionHandler.\n// The new AssertionHandler is DefaultAssertionHandler with specified reporter,\n// existing Config.Formatter and nil Logger.\n// It will be used to report formatted fatal failure messages.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"http://example.com/path\")\n//\treq.WithReporter(t)\nfunc (r *Request) WithReporter(reporter Reporter) *Request {\n\topChain := r.chain.enter(\"WithReporter()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithReporter()\") {\n\t\treturn r\n\t}\n\n\tif reporter == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\thandler := &DefaultAssertionHandler{\n\t\tReporter:  reporter,\n\t\tFormatter: r.config.Formatter,\n\t}\n\tr.chain.setHandler(handler)\n\n\treturn r\n}\n\n// WithAssertionHandler sets assertion handler to be used for this request.\n//\n// The new handler overwrites assertion handler that will be used\n// by Request and its children (Response, Body, etc.).\n// It will be used to format and report test Failure or Success.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"http://example.com/path\")\n//\treq.WithAssertionHandler(&DefaultAssertionHandler{\n//\t\tReporter:  reporter,\n//\t\tFormatter: formatter,\n//\t})\nfunc (r *Request) WithAssertionHandler(handler AssertionHandler) *Request {\n\topChain := r.chain.enter(\"WithAssertionHandler()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithAssertionHandler()\") {\n\t\treturn r\n\t}\n\n\tif handler == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.chain.setHandler(handler)\n\n\treturn r\n}\n\n// WithMatcher attaches a matcher to the request.\n// All attached matchers are invoked in the Expect method for a newly\n// created Response.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithMatcher(func (resp *httpexpect.Response) {\n//\t\tresp.Header(\"API-Version\").NotEmpty()\n//\t})\nfunc (r *Request) WithMatcher(matcher func(*Response)) *Request {\n\topChain := r.chain.enter(\"WithMatcher()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithMatcher()\") {\n\t\treturn r\n\t}\n\n\tif matcher == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.matchers = append(r.matchers, matcher)\n\treturn r\n}\n\n// WithTransformer attaches a transform to the Request.\n// All attachhed transforms are invoked in the Expect methods for\n// http.Request struct, after it's encoded and before it's sent.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithTransformer(func(r *http.Request) { r.Header.Add(\"foo\", \"bar\") })\nfunc (r *Request) WithTransformer(transformer func(*http.Request)) *Request {\n\topChain := r.chain.enter(\"WithTransformer()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithTransformer()\") {\n\t\treturn r\n\t}\n\n\tif transformer == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.transformers = append(r.transformers, transformer)\n\n\treturn r\n}\n\n// WithClient sets client.\n//\n// The new client overwrites Config.Client. It will be used once to send the\n// request and receive a response.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithClient(&http.Client{\n//\t  Transport: &http.Transport{\n//\t\tDisableCompression: true,\n//\t  },\n//\t})\nfunc (r *Request) WithClient(client Client) *Request {\n\topChain := r.chain.enter(\"WithClient()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithClient()\") {\n\t\treturn r\n\t}\n\n\tif client == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.config.Client = client\n\n\treturn r\n}\n\n// WithHandler configures client to invoke the given handler directly.\n//\n// If Config.Client is http.Client, then only its Transport field is overwritten\n// because the client may contain some state shared among requests like a cookie\n// jar. Otherwise, the whole client is overwritten with a new client.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithHandler(myServer.someHandler)\nfunc (r *Request) WithHandler(handler http.Handler) *Request {\n\topChain := r.chain.enter(\"WithHandler()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithHandler()\") {\n\t\treturn r\n\t}\n\n\tif handler == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tif client, ok := r.config.Client.(*http.Client); ok {\n\t\tclientCopy := *client\n\t\tclientCopy.Transport = NewBinder(handler)\n\t\tr.config.Client = &clientCopy\n\t} else {\n\t\tr.config.Client = &http.Client{\n\t\t\tTransport: NewBinder(handler),\n\t\t\tJar:       NewCookieJar(),\n\t\t}\n\t}\n\n\treturn r\n}\n\n// WithContext sets the context.\n//\n// Config.Context will be overwritten.\n//\n// Any retries will stop after one is cancelled.\n// If the intended behavior is to continue any further retries, use WithTimeout.\n//\n// Example:\n//\n//\tctx, _ = context.WithTimeout(context.Background(), time.Duration(3)*time.Second)\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithContext(ctx)\n//\treq.Expect().Status(http.StatusOK)\nfunc (r *Request) WithContext(ctx context.Context) *Request {\n\topChain := r.chain.enter(\"WithContext()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithContext()\") {\n\t\treturn r\n\t}\n\n\tif ctx == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.config.Context = ctx\n\n\treturn r\n}\n\n// WithTimeout sets a timeout duration for the request.\n//\n// Will attach to the request a context.WithTimeout around the Config.Context\n// or any context set WithContext. If these are nil, the new context will be\n// created on top of a context.Background().\n//\n// Any retries will continue after one is cancelled.\n// If the intended behavior is to stop any further retries, use WithContext or\n// Config.Context.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithTimeout(time.Duration(3)*time.Second)\n//\treq.Expect().Status(http.StatusOK)\nfunc (r *Request) WithTimeout(timeout time.Duration) *Request {\n\topChain := r.chain.enter(\"WithTimeout()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithTimeout()\") {\n\t\treturn r\n\t}\n\n\tr.timeout = timeout\n\n\treturn r\n}\n\n// RedirectPolicy defines how redirection responses are handled.\n//\n// Status codes 307, 308 require resending body. They are followed only if\n// redirect policy is FollowAllRedirects.\n//\n// Status codes 301, 302, 303 don't require resending body. On such redirect,\n// http.Client automatically switches HTTP method to GET, if it's not GET or\n// HEAD already. These redirects are followed if redirect policy is either\n// FollowAllRedirects or FollowRedirectsWithoutBody.\n//\n// Default redirect policy is FollowRedirectsWithoutBody.\ntype RedirectPolicy int\n\nconst (\n\t// indicates that WithRedirectPolicy was not called\n\tdefaultRedirectPolicy RedirectPolicy = iota\n\n\t// DontFollowRedirects forbids following any redirects.\n\t// Redirection response is returned to the user and can be inspected.\n\tDontFollowRedirects\n\n\t// FollowAllRedirects allows following any redirects, including those\n\t// which require resending body.\n\tFollowAllRedirects\n\n\t// FollowRedirectsWithoutBody allows following only redirects which\n\t// don't require resending body.\n\t// If redirect requires resending body, it's not followed, and redirection\n\t// response is returned instead.\n\tFollowRedirectsWithoutBody\n)\n\n// WithRedirectPolicy sets policy for redirection response handling.\n//\n// How redirect is handled depends on both response status code and\n// redirect policy. See comments for RedirectPolicy for details.\n//\n// Default redirect policy is defined by Client implementation.\n// Default behavior of http.Client corresponds to FollowRedirectsWithoutBody.\n//\n// This method can be used only if Client interface points to\n// *http.Client struct, since we rely on it in redirect handling.\n//\n// Example:\n//\n//\treq1 := NewRequestC(config, \"POST\", \"/path\")\n//\treq1.WithRedirectPolicy(FollowAllRedirects)\n//\treq1.Expect().Status(http.StatusOK)\n//\n//\treq2 := NewRequestC(config, \"POST\", \"/path\")\n//\treq2.WithRedirectPolicy(DontFollowRedirects)\n//\treq2.Expect().Status(http.StatusPermanentRedirect)\nfunc (r *Request) WithRedirectPolicy(policy RedirectPolicy) *Request {\n\topChain := r.chain.enter(\"WithRedirectPolicy()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithRedirectPolicy()\") {\n\t\treturn r\n\t}\n\n\tr.redirectPolicy = policy\n\n\treturn r\n}\n\n// WithMaxRedirects sets maximum number of redirects to follow.\n//\n// If the number of redirects exceedes this limit, request is failed.\n//\n// Default limit is defined by Client implementation.\n// Default behavior of http.Client corresponds to maximum of 10-1 redirects.\n//\n// This method can be used only if Client interface points to\n// *http.Client struct, since we rely on it in redirect handling.\n//\n// Example:\n//\n//\treq1 := NewRequestC(config, \"POST\", \"/path\")\n//\treq1.WithMaxRedirects(1)\n//\treq1.Expect().Status(http.StatusOK)\nfunc (r *Request) WithMaxRedirects(maxRedirects int) *Request {\n\topChain := r.chain.enter(\"WithMaxRedirects()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithMaxRedirects()\") {\n\t\treturn r\n\t}\n\n\tif maxRedirects < 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{maxRedirects},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid negative argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.maxRedirects = maxRedirects\n\n\treturn r\n}\n\n// RetryPolicy defines how failed requests are retried.\n//\n// Whether a request is retried depends on error type (if any), response\n// status code (if any), and retry policy.\ntype RetryPolicy int\n\nconst (\n\t// DontRetry disables retrying at all.\n\tDontRetry RetryPolicy = iota\n\n\t// Deprecated: use RetryTimeoutErrors instead.\n\tRetryTemporaryNetworkErrors\n\n\t// Deprecated: use RetryTimeoutAndServerErrors instead.\n\tRetryTemporaryNetworkAndServerErrors\n\n\t// RetryTimeoutErrors enables retrying of timeout errors.\n\t// Retry happens if Client returns net.Error and its Timeout() method\n\t// returns true.\n\tRetryTimeoutErrors\n\n\t// RetryTimeoutAndServerErrors enables retrying of network timeout errors,\n\t// as well as 5xx status codes.\n\tRetryTimeoutAndServerErrors\n\n\t// RetryAllErrors enables retrying of any error or 4xx/5xx status code.\n\tRetryAllErrors\n)\n\n// WithRetryPolicy sets policy for retries.\n//\n// Whether a request is retried depends on error type (if any), response\n// status code (if any), and retry policy.\n//\n// How much retry attempts happens is defined by WithMaxRetries().\n// How much to wait between attempts is defined by WithRetryDelay().\n//\n// Default retry policy is RetryTimeoutAndServerErrors, but\n// default maximum number of retries is zero, so no retries happen\n// unless WithMaxRetries() is called.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"POST\", \"/path\")\n//\treq.WithRetryPolicy(RetryAllErrors)\n//\treq.Expect().Status(http.StatusOK)\nfunc (r *Request) WithRetryPolicy(policy RetryPolicy) *Request {\n\topChain := r.chain.enter(\"WithRetryPolicy()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithRetryPolicy()\") {\n\t\treturn r\n\t}\n\n\tr.retryPolicy = policy\n\n\treturn r\n}\n\n// WithMaxRetries sets maximum number of retry attempts.\n//\n// After first request failure, additional retry attempts may happen,\n// depending on the retry policy.\n//\n// Setting this to zero disables retries, i.e. only one request is sent.\n// Setting this to N enables retries, and up to N+1 requests may be sent.\n//\n// Default number of retries is zero, i.e. retries are disabled.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"POST\", \"/path\")\n//\treq.WithMaxRetries(1)\n//\treq.Expect().Status(http.StatusOK)\nfunc (r *Request) WithMaxRetries(maxRetries int) *Request {\n\topChain := r.chain.enter(\"WithMaxRetries()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithMaxRetries()\") {\n\t\treturn r\n\t}\n\n\tif maxRetries < 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{maxRetries},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid negative argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.maxRetries = maxRetries\n\n\treturn r\n}\n\n// WithRetryDelay sets minimum and maximum delay between retries.\n//\n// If multiple retry attempts happen, delay between attempts starts from\n// minDelay and then grows exponentionally until it reaches maxDelay.\n//\n// Default delay range is [50ms; 5s].\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"POST\", \"/path\")\n//\treq.WithRetryDelay(time.Second, time.Minute)\n//\treq.Expect().Status(http.StatusOK)\nfunc (r *Request) WithRetryDelay(minDelay, maxDelay time.Duration) *Request {\n\topChain := r.chain.enter(\"WithRetryDelay()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithRetryDelay()\") {\n\t\treturn r\n\t}\n\n\tif !(minDelay <= maxDelay) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertValid,\n\t\t\tActual: &AssertionValue{\n\t\t\t\t[2]time.Duration{minDelay, maxDelay},\n\t\t\t},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid delay range\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.minRetryDelay = minDelay\n\tr.maxRetryDelay = maxDelay\n\n\treturn r\n}\n\n// WithWebsocketUpgrade enables upgrades the connection to websocket.\n//\n// At least the following fields are added to the request header:\n//\n//\tUpgrade: websocket\n//\tConnection: Upgrade\n//\n// The actual set of header fields is define by the protocol implementation\n// in the gorilla/websocket package.\n//\n// The user should then call the Response.Websocket() method which returns\n// the Websocket instance. This instance can be used to send messages to the\n// server, to inspect the received messages, and to close the websocket.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithWebsocketUpgrade()\n//\tws := req.Expect().Status(http.StatusSwitchingProtocols).Websocket()\n//\tdefer ws.Disconnect()\nfunc (r *Request) WithWebsocketUpgrade() *Request {\n\topChain := r.chain.enter(\"WithWebsocketUpgrade()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithWebsocketUpgrade()\") {\n\t\treturn r\n\t}\n\n\tr.wsUpgrade = true\n\n\treturn r\n}\n\n// WithWebsocketDialer sets the custom websocket dialer.\n//\n// The new dialer overwrites Config.WebsocketDialer. It will be used once to establish\n// the WebSocket connection and receive a response of handshake result.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithWebsocketUpgrade()\n//\treq.WithWebsocketDialer(&websocket.Dialer{\n//\t  EnableCompression: false,\n//\t})\n//\tws := req.Expect().Status(http.StatusSwitchingProtocols).Websocket()\n//\tdefer ws.Disconnect()\nfunc (r *Request) WithWebsocketDialer(dialer WebsocketDialer) *Request {\n\topChain := r.chain.enter(\"WithWebsocketDialer()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithWebsocketDialer()\") {\n\t\treturn r\n\t}\n\n\tif dialer == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.config.WebsocketDialer = dialer\n\n\treturn r\n}\n\n// WithPath substitutes named parameters in url path.\n//\n// value is converted to string using fmt.Sprint(). If there is no named\n// parameter '{key}' in url path, failure is reported.\n//\n// Named parameters are case-insensitive.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"POST\", \"/repos/{user}/{repo}\")\n//\treq.WithPath(\"user\", \"gavv\")\n//\treq.WithPath(\"repo\", \"httpexpect\")\n//\t// path will be \"/repos/gavv/httpexpect\"\nfunc (r *Request) WithPath(key string, value interface{}) *Request {\n\topChain := r.chain.enter(\"WithPath()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithPath()\") {\n\t\treturn r\n\t}\n\n\tr.withPath(opChain, key, value)\n\n\treturn r\n}\n\n// WithPathObject substitutes multiple named parameters in url path.\n//\n// object should be map or struct. If object is struct, it's converted\n// to map using https://github.com/fatih/structs. Structs may contain\n// \"path\" struct tag, similar to \"json\" struct tag for json.Marshal().\n//\n// Each map value is converted to string using fmt.Sprint(). If there\n// is no named parameter for some map '{key}' in url path, failure is\n// reported.\n//\n// Named parameters are case-insensitive.\n//\n// Example:\n//\n//\ttype MyPath struct {\n//\t\tLogin string `path:\"user\"`\n//\t\tRepo  string\n//\t}\n//\n//\treq := NewRequestC(config, \"POST\", \"/repos/{user}/{repo}\")\n//\treq.WithPathObject(MyPath{\"gavv\", \"httpexpect\"})\n//\t// path will be \"/repos/gavv/httpexpect\"\n//\n//\treq := NewRequestC(config, \"POST\", \"/repos/{user}/{repo}\")\n//\treq.WithPathObject(map[string]string{\"user\": \"gavv\", \"repo\": \"httpexpect\"})\n//\t// path will be \"/repos/gavv/httpexpect\"\nfunc (r *Request) WithPathObject(object interface{}) *Request {\n\topChain := r.chain.enter(\"WithPathObject()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithPathObject()\") {\n\t\treturn r\n\t}\n\n\tif object == nil {\n\t\treturn r\n\t}\n\n\tvar (\n\t\tm  map[string]interface{}\n\t\tok bool\n\t)\n\tif reflect.Indirect(reflect.ValueOf(object)).Kind() == reflect.Struct {\n\t\ts := structs.New(object)\n\t\ts.TagName = \"path\"\n\t\tm = s.Map()\n\t} else {\n\t\tm, ok = canonMap(opChain, object)\n\t\tif !ok {\n\t\t\treturn r\n\t\t}\n\t}\n\n\tfor key, value := range m {\n\t\tr.withPath(opChain, key, value)\n\t}\n\n\treturn r\n}\n\nfunc (r *Request) withPath(opChain *chain, key string, value interface{}) {\n\tfound := false\n\n\tpath, err := interpol.WithFunc(r.path, func(k string, w io.Writer) error {\n\t\tif strings.EqualFold(k, key) {\n\t\t\tif value == nil {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType: AssertUsage,\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\tfmt.Errorf(\"unexpected nil interpol argument %q\", k),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tmustWrite(w, fmt.Sprint(value))\n\t\t\t\tfound = true\n\t\t\t}\n\t\t} else {\n\t\t\tmustWrite(w, \"{\")\n\t\t\tmustWrite(w, k)\n\t\t\tmustWrite(w, \"}\")\n\t\t}\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{path},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid interpol string\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif !found {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"key %q not found in interpol string\", key),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tr.path = path\n}\n\n// WithQuery adds query parameter to request URL.\n//\n// value is converted to string using fmt.Sprint() and urlencoded.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithQuery(\"a\", 123)\n//\treq.WithQuery(\"b\", \"foo\")\n//\t// URL is now http://example.com/path?a=123&b=foo\nfunc (r *Request) WithQuery(key string, value interface{}) *Request {\n\topChain := r.chain.enter(\"WithQuery()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithQuery()\") {\n\t\treturn r\n\t}\n\n\tif value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected nil argument\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tif r.query == nil {\n\t\tr.query = make(url.Values)\n\t}\n\tr.query.Add(key, fmt.Sprint(value))\n\n\treturn r\n}\n\n// WithQueryObject adds multiple query parameters to request URL.\n//\n// object is converted to query string using github.com/google/go-querystring\n// if it's a struct or pointer to struct, or github.com/ajg/form otherwise.\n//\n// Various object types are supported. Structs may contain \"url\" struct tag,\n// similar to \"json\" struct tag for json.Marshal().\n//\n// Example:\n//\n//\ttype MyURL struct {\n//\t\tA int    `url:\"a\"`\n//\t\tB string `url:\"b\"`\n//\t}\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithQueryObject(MyURL{A: 123, B: \"foo\"})\n//\t// URL is now http://example.com/path?a=123&b=foo\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithQueryObject(map[string]interface{}{\"a\": 123, \"b\": \"foo\"})\n//\t// URL is now http://example.com/path?a=123&b=foo\nfunc (r *Request) WithQueryObject(object interface{}) *Request {\n\topChain := r.chain.enter(\"WithQueryObject()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithQueryObject()\") {\n\t\treturn r\n\t}\n\n\tif object == nil {\n\t\treturn r\n\t}\n\n\tvar (\n\t\tq   url.Values\n\t\terr error\n\t)\n\tif reflect.Indirect(reflect.ValueOf(object)).Kind() == reflect.Struct {\n\t\tq, err = query.Values(object)\n\t\tif err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{object},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"invalid query object\"),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn r\n\t\t}\n\t} else {\n\t\tq, err = form.EncodeToValues(object)\n\t\tif err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{object},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"invalid query object\"),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn r\n\t\t}\n\t}\n\n\tif r.query == nil {\n\t\tr.query = make(url.Values)\n\t}\n\tfor k, v := range q {\n\t\tr.query[k] = append(r.query[k], v...)\n\t}\n\n\treturn r\n}\n\n// WithQueryString parses given query string and adds it to request URL.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithQuery(\"a\", 11)\n//\treq.WithQueryString(\"b=22&c=33\")\n//\t// URL is now http://example.com/path?a=11&bb=22&c=33\nfunc (r *Request) WithQueryString(query string) *Request {\n\topChain := r.chain.enter(\"WithQueryString()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithQueryString()\") {\n\t\treturn r\n\t}\n\n\tv, err := url.ParseQuery(query)\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{query},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid query string\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tif r.query == nil {\n\t\tr.query = make(url.Values)\n\t}\n\tfor k, v := range v {\n\t\tr.query[k] = append(r.query[k], v...)\n\t}\n\n\treturn r\n}\n\n// WithURL sets request URL.\n//\n// This URL overwrites Config.BaseURL. Request path passed to request constructor\n// is appended to this URL, separated by slash if necessary.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"/path\")\n//\treq.WithURL(\"http://example.com\")\n//\t// URL is now http://example.com/path\nfunc (r *Request) WithURL(urlStr string) *Request {\n\topChain := r.chain.enter(\"WithURL()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithURL()\") {\n\t\treturn r\n\t}\n\n\tu, err := url.Parse(urlStr)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{urlStr},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid url string\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.httpReq.URL = u\n\n\treturn r\n}\n\n// WithHeaders adds given headers to request.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithHeaders(map[string]string{\n//\t\t\"Content-Type\": \"application/json\",\n//\t})\nfunc (r *Request) WithHeaders(headers map[string]string) *Request {\n\topChain := r.chain.enter(\"WithHeaders()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithHeaders()\") {\n\t\treturn r\n\t}\n\n\tfor k, v := range headers {\n\t\tr.withHeader(k, v)\n\t}\n\n\treturn r\n}\n\n// WithHeader adds given single header to request.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithHeader(\"Content-Type\", \"application/json\")\nfunc (r *Request) WithHeader(k, v string) *Request {\n\topChain := r.chain.enter(\"WithHeader()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithHeader()\") {\n\t\treturn r\n\t}\n\n\tr.withHeader(k, v)\n\n\treturn r\n}\n\nfunc (r *Request) withHeader(k, v string) {\n\tswitch http.CanonicalHeaderKey(k) {\n\tcase \"Host\":\n\t\tr.httpReq.Host = v\n\n\tcase \"Content-Type\":\n\t\tif !r.forceType {\n\t\t\tdelete(r.httpReq.Header, \"Content-Type\")\n\t\t}\n\t\tr.forceType = true\n\t\tr.typeSetter = \"WithHeader()\"\n\t\tr.httpReq.Header.Add(k, v)\n\n\tdefault:\n\t\tr.httpReq.Header.Add(k, v)\n\t}\n}\n\n// WithCookies adds given cookies to request.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithCookies(map[string]string{\n//\t\t\"foo\": \"aa\",\n//\t\t\"bar\": \"bb\",\n//\t})\nfunc (r *Request) WithCookies(cookies map[string]string) *Request {\n\topChain := r.chain.enter(\"WithCookies()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithCookies()\") {\n\t\treturn r\n\t}\n\n\tfor k, v := range cookies {\n\t\tr.httpReq.AddCookie(&http.Cookie{\n\t\t\tName:  k,\n\t\t\tValue: v,\n\t\t})\n\t}\n\n\treturn r\n}\n\n// WithCookie adds given single cookie to request.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithCookie(\"name\", \"value\")\nfunc (r *Request) WithCookie(k, v string) *Request {\n\topChain := r.chain.enter(\"WithCookie()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithCookie()\") {\n\t\treturn r\n\t}\n\n\tr.httpReq.AddCookie(&http.Cookie{\n\t\tName:  k,\n\t\tValue: v,\n\t})\n\n\treturn r\n}\n\n// WithBasicAuth sets the request's Authorization header to use HTTP\n// Basic Authentication with the provided username and password.\n//\n// With HTTP Basic Authentication the provided username and password\n// are not encrypted.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithBasicAuth(\"john\", \"secret\")\nfunc (r *Request) WithBasicAuth(username, password string) *Request {\n\topChain := r.chain.enter(\"WithBasicAuth()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithBasicAuth()\") {\n\t\treturn r\n\t}\n\n\tr.httpReq.SetBasicAuth(username, password)\n\n\treturn r\n}\n\n// WithHost sets request host to given string.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithHost(\"example.com\")\nfunc (r *Request) WithHost(host string) *Request {\n\topChain := r.chain.enter(\"WithHost()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithHost()\") {\n\t\treturn r\n\t}\n\n\tr.httpReq.Host = host\n\n\treturn r\n}\n\n// WithProto sets HTTP protocol version.\n//\n// proto should have form of \"HTTP/{major}.{minor}\", e.g. \"HTTP/1.1\".\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithProto(\"HTTP/2.0\")\nfunc (r *Request) WithProto(proto string) *Request {\n\topChain := r.chain.enter(\"WithProto()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithProto()\") {\n\t\treturn r\n\t}\n\n\tmajor, minor, ok := http.ParseHTTPVersion(proto)\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t`unexpected protocol version %q, expected \"HTTP/{major}.{minor}\"`,\n\t\t\t\t\tproto),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.httpReq.ProtoMajor = major\n\tr.httpReq.ProtoMinor = minor\n\n\treturn r\n}\n\n// WithChunked enables chunked encoding and sets request body reader.\n//\n// Expect() will read all available data from given reader. Content-Length\n// is not set, and \"chunked\" Transfer-Encoding is used.\n//\n// If protocol version is not at least HTTP/1.1 (required for chunked\n// encoding), failure is reported.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/upload\")\n//\tfh, _ := os.Open(\"data\")\n//\tdefer fh.Close()\n//\treq.WithHeader(\"Content-Type\", \"application/octet-stream\")\n//\treq.WithChunked(fh)\nfunc (r *Request) WithChunked(reader io.Reader) *Request {\n\topChain := r.chain.enter(\"WithChunked()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithChunked()\") {\n\t\treturn r\n\t}\n\tif !r.httpReq.ProtoAtLeast(1, 1) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t`chunked Transfer-Encoding requires at least \"HTTP/1.1\",`+\n\t\t\t\t\t\t` but \"HTTP/%d.%d\" is used`,\n\t\t\t\t\tr.httpReq.ProtoMajor, r.httpReq.ProtoMinor),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.setBody(opChain, \"WithChunked()\", reader, -1, false)\n\n\treturn r\n}\n\n// WithBytes sets request body to given slice of bytes.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithHeader(\"Content-Type\", \"application/json\")\n//\treq.WithBytes([]byte(`{\"foo\": 123}`))\nfunc (r *Request) WithBytes(b []byte) *Request {\n\topChain := r.chain.enter(\"WithBytes()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithBytes()\") {\n\t\treturn r\n\t}\n\n\tif b == nil {\n\t\tr.setBody(opChain, \"WithBytes()\", nil, 0, false)\n\t} else {\n\t\tr.setBody(opChain, \"WithBytes()\", bytes.NewReader(b), len(b), false)\n\t}\n\n\treturn r\n}\n\n// WithText sets Content-Type header to \"text/plain; charset=utf-8\" and\n// sets body to given string.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithText(\"hello, world!\")\nfunc (r *Request) WithText(s string) *Request {\n\topChain := r.chain.enter(\"WithText()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithText()\") {\n\t\treturn r\n\t}\n\n\tr.setType(opChain, \"WithText()\", \"text/plain; charset=utf-8\", false)\n\tr.setBody(opChain, \"WithText()\", strings.NewReader(s), len(s), false)\n\n\treturn r\n}\n\n// WithJSON sets Content-Type header to \"application/json; charset=utf-8\"\n// and sets body to object, marshaled using json.Marshal().\n//\n// Example:\n//\n//\ttype MyJSON struct {\n//\t\tFoo int `json:\"foo\"`\n//\t}\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithJSON(MyJSON{Foo: 123})\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithJSON(map[string]interface{}{\"foo\": 123})\nfunc (r *Request) WithJSON(object interface{}) *Request {\n\topChain := r.chain.enter(\"WithJSON()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithJSON()\") {\n\t\treturn r\n\t}\n\n\tb, err := json.Marshal(object)\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{object},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid json object\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.setType(opChain, \"WithJSON()\", \"application/json; charset=utf-8\", false)\n\tr.setBody(opChain, \"WithJSON()\", bytes.NewReader(b), len(b), false)\n\n\treturn r\n}\n\n// WithForm sets Content-Type header to \"application/x-www-form-urlencoded\"\n// or (if WithMultipart() was called) \"multipart/form-data\", converts given\n// object to url.Values using github.com/ajg/form, and adds it to request body.\n//\n// Various object types are supported, including maps and structs. Structs may\n// contain \"form\" struct tag, similar to \"json\" struct tag for json.Marshal().\n// See https://github.com/ajg/form for details.\n//\n// Multiple WithForm(), WithFormField(), and WithFile() calls may be combined.\n// If WithMultipart() is called, it should be called first.\n//\n// Example:\n//\n//\ttype MyForm struct {\n//\t\tFoo int `form:\"foo\"`\n//\t}\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithForm(MyForm{Foo: 123})\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithForm(map[string]interface{}{\"foo\": 123})\nfunc (r *Request) WithForm(object interface{}) *Request {\n\topChain := r.chain.enter(\"WithForm()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithForm()\") {\n\t\treturn r\n\t}\n\n\tf, err := form.EncodeToValues(object)\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{object},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid form object\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tif r.multipart != nil {\n\t\tr.setType(opChain, \"WithForm()\", \"multipart/form-data\", false)\n\n\t\tvar keys []string\n\t\tfor k := range f {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tsort.Strings(keys)\n\n\t\tfor _, k := range keys {\n\t\t\tif err := r.multipart.WriteField(k, f[k][0]); err != nil {\n\t\t\t\topChain.fail(AssertionFailure{\n\t\t\t\t\tType: AssertOperation,\n\t\t\t\t\tErrors: []error{\n\t\t\t\t\t\tfmt.Errorf(\"failed to write multipart form field %q\", k),\n\t\t\t\t\t\terr,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn r\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr.setType(opChain, \"WithForm()\", \"application/x-www-form-urlencoded\", false)\n\n\t\tif r.form == nil {\n\t\t\tr.form = make(url.Values)\n\t\t}\n\t\tfor k, v := range f {\n\t\t\tr.form[k] = append(r.form[k], v...)\n\t\t}\n\t}\n\n\treturn r\n}\n\n// WithFormField sets Content-Type header to \"application/x-www-form-urlencoded\"\n// or (if WithMultipart() was called) \"multipart/form-data\", converts given\n// value to string using fmt.Sprint(), and adds it to request body.\n//\n// Multiple WithForm(), WithFormField(), and WithFile() calls may be combined.\n// If WithMultipart() is called, it should be called first.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithFormField(\"foo\", 123).\n//\t\tWithFormField(\"bar\", 456)\nfunc (r *Request) WithFormField(key string, value interface{}) *Request {\n\topChain := r.chain.enter(\"WithFormField()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithFormField()\") {\n\t\treturn r\n\t}\n\n\tif r.multipart != nil {\n\t\tr.setType(opChain, \"WithFormField()\", \"multipart/form-data\", false)\n\n\t\terr := r.multipart.WriteField(key, fmt.Sprint(value))\n\t\tif err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertOperation,\n\t\t\t\tErrors: []error{\n\t\t\t\t\tfmt.Errorf(\"failed to write multipart form field %q\", key),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn r\n\t\t}\n\t} else {\n\t\tr.setType(opChain, \"WithFormField()\", \"application/x-www-form-urlencoded\", false)\n\n\t\tif r.form == nil {\n\t\t\tr.form = make(url.Values)\n\t\t}\n\t\tr.form[key] = append(r.form[key], fmt.Sprint(value))\n\t}\n\n\treturn r\n}\n\n// WithFile sets Content-Type header to \"multipart/form-data\", reads given\n// file and adds its contents to request body.\n//\n// If reader is given, it's used to read file contents. Otherwise, os.Open()\n// is used to read a file with given path.\n//\n// Multiple WithForm(), WithFormField(), and WithFile() calls may be combined.\n// WithMultipart() should be called before WithFile(), otherwise WithFile()\n// fails.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithFile(\"avatar\", \"./john.png\")\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\tfh, _ := os.Open(\"./john.png\")\n//\treq.WithMultipart().\n//\t\tWithFile(\"avatar\", \"john.png\", fh)\n//\tfh.Close()\nfunc (r *Request) WithFile(key, path string, reader ...io.Reader) *Request {\n\topChain := r.chain.enter(\"WithFile()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithFile()\") {\n\t\treturn r\n\t}\n\n\tif len(reader) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple reader arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.withFile(opChain, \"WithFile()\", key, path, reader...)\n\n\treturn r\n}\n\n// WithFileBytes is like WithFile, but uses given slice of bytes as the\n// file contents.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\tfh, _ := os.Open(\"./john.png\")\n//\tb, _ := io.ReadAll(fh)\n//\treq.WithMultipart().\n//\t\tWithFileBytes(\"avatar\", \"john.png\", b)\n//\tfh.Close()\nfunc (r *Request) WithFileBytes(key, path string, data []byte) *Request {\n\topChain := r.chain.enter(\"WithFileBytes()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithFileBytes()\") {\n\t\treturn r\n\t}\n\n\tr.withFile(opChain, \"WithFileBytes()\", key, path, bytes.NewReader(data))\n\n\treturn r\n}\n\nfunc (r *Request) withFile(\n\topChain *chain, method, key, path string, reader ...io.Reader,\n) {\n\tr.setType(opChain, method, \"multipart/form-data\", false)\n\n\tif r.multipart == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"%s requires WithMultipart() to be called first\", method),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\twr, err := r.multipart.CreateFormFile(key, path)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"failed to create form file with key %q and path %q\",\n\t\t\t\t\tkey, path),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tvar rd io.Reader\n\tif len(reader) != 0 && reader[0] != nil {\n\t\trd = reader[0]\n\t} else {\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertOperation,\n\t\t\t\tErrors: []error{\n\t\t\t\t\tfmt.Errorf(\"failed to open file %q\", path),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t\trd = f\n\t\tdefer f.Close()\n\t}\n\n\tif _, err := io.Copy(wr, rd); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"failed to read file %q\", path),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n}\n\n// WithMultipart sets Content-Type header to \"multipart/form-data\".\n//\n// After this call, WithForm() and WithFormField() switch to multipart\n// form instead of urlencoded form.\n//\n// If WithMultipart() is called, it should be called before WithForm(),\n// WithFormField(), and WithFile().\n//\n// WithFile() always requires WithMultipart() to be called first.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithMultipart().\n//\t\tWithForm(map[string]interface{}{\"foo\": 123})\nfunc (r *Request) WithMultipart() *Request {\n\topChain := r.chain.enter(\"WithMultipart()\")\n\tdefer opChain.leave()\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif !r.checkOrder(opChain, \"WithMultipart()\") {\n\t\treturn r\n\t}\n\n\tr.setType(opChain, \"WithMultipart()\", \"multipart/form-data\", false)\n\n\tif r.multipart == nil {\n\t\tr.formbuf = &bytes.Buffer{}\n\t\tr.multipart = r.multipartFn(r.formbuf)\n\t\tr.setBody(opChain, \"WithMultipart()\", r.formbuf, 0, false)\n\t}\n\n\treturn r\n}\n\n// Expect constructs http.Request, sends it, receives http.Response, and\n// returns a new Response instance.\n//\n// Request is sent using Client interface, or WebsocketDialer in case of\n// WebSocket request.\n//\n// After calling Expect, there should not be any more calls of Expect or\n// other WithXXX methods on the same Request instance.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"PUT\", \"http://example.com/path\")\n//\treq.WithJSON(map[string]interface{}{\"foo\": 123})\n//\tresp := req.Expect()\n//\tresp.Status(http.StatusOK)\nfunc (r *Request) Expect() *Response {\n\topChain := r.chain.enter(\"Expect()\")\n\tdefer opChain.leave()\n\n\tresp := r.expect(opChain)\n\n\tif resp == nil {\n\t\tresp = newResponse(responseOpts{\n\t\t\tconfig: r.config,\n\t\t\tchain:  opChain,\n\t\t})\n\t}\n\n\treturn resp\n}\n\nfunc (r *Request) expect(opChain *chain) *Response {\n\tif !r.prepare(opChain) {\n\t\treturn nil\n\t}\n\n\t// after return from prepare(), all subsequent calls to WithXXX and Expect will\n\t// abort early due to checkOrder(); so we can safely proceed without a lock\n\n\tresp := r.execute(opChain)\n\n\tif resp == nil {\n\t\treturn nil\n\t}\n\n\tfor _, matcher := range r.matchers {\n\t\tmatcher(resp)\n\t}\n\n\treturn resp\n}\n\nfunc (r *Request) prepare(opChain *chain) bool {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif opChain.failed() {\n\t\treturn false\n\t}\n\n\tif !r.checkOrder(opChain, \"Expect()\") {\n\t\treturn false\n\t}\n\n\tr.expectCalled = true\n\n\treturn true\n}\n\nfunc (r *Request) execute(opChain *chain) *Response {\n\tif !r.encodeRequest(opChain) {\n\t\treturn nil\n\t}\n\n\tif r.wsUpgrade {\n\t\tif !r.encodeWebsocketRequest(opChain) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tfor _, transform := range r.transformers {\n\t\ttransform(r.httpReq)\n\n\t\tif opChain.failed() {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvar (\n\t\thttpResp *http.Response\n\t\twebsock  *websocket.Conn\n\t\telapsed  time.Duration\n\t)\n\tif r.wsUpgrade {\n\t\thttpResp, websock, elapsed = r.sendWebsocketRequest(opChain)\n\t} else {\n\t\thttpResp, elapsed = r.sendRequest(opChain)\n\t}\n\n\tif httpResp == nil {\n\t\treturn nil\n\t}\n\n\treturn newResponse(responseOpts{\n\t\tconfig:    r.config,\n\t\tchain:     opChain,\n\t\thttpResp:  httpResp,\n\t\twebsocket: websock,\n\t\trtt:       []time.Duration{elapsed},\n\t})\n}\n\nfunc (r *Request) encodeRequest(opChain *chain) bool {\n\tr.httpReq.URL.Path = concatPaths(r.httpReq.URL.Path, r.path)\n\n\tif r.query != nil {\n\t\tr.httpReq.URL.RawQuery = r.query.Encode()\n\t}\n\n\tif r.multipart != nil {\n\t\tif err := r.multipart.Close(); err != nil {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertOperation,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"failed to close multipart form\"),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn false\n\t\t}\n\n\t\tr.setType(opChain, \"Expect()\", r.multipart.FormDataContentType(), true)\n\t\tr.setBody(opChain, \"Expect()\", r.formbuf, r.formbuf.Len(), true)\n\t} else if r.form != nil {\n\t\ts := r.form.Encode()\n\t\tr.setBody(opChain,\n\t\t\t\"WithForm() or WithFormField()\", strings.NewReader(s), len(s), false)\n\t}\n\n\tif r.httpReq.Body == nil {\n\t\tr.httpReq.Body = http.NoBody\n\t}\n\n\tif r.config.Context != nil {\n\t\tr.httpReq = r.httpReq.WithContext(r.config.Context)\n\t}\n\n\tr.setupRedirects(opChain)\n\n\treturn true\n}\n\nvar websocketErr = `webocket request can not have body:\n  body was set by %s\n  webocket was enabled by WithWebsocketUpgrade()`\n\nfunc (r *Request) encodeWebsocketRequest(opChain *chain) bool {\n\tif r.bodySetter != \"\" {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(websocketErr, r.bodySetter),\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\tswitch r.httpReq.URL.Scheme {\n\tcase \"https\":\n\t\tr.httpReq.URL.Scheme = \"wss\"\n\tdefault:\n\t\tr.httpReq.URL.Scheme = \"ws\"\n\t}\n\n\treturn true\n}\n\nfunc (r *Request) sendRequest(opChain *chain) (*http.Response, time.Duration) {\n\tresp, elapsed, err := r.retryRequest(func() (*http.Response, error) {\n\t\treturn r.config.Client.Do(r.httpReq)\n\t})\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to send http request\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil, 0\n\t}\n\n\treturn resp, elapsed\n}\n\nfunc (r *Request) sendWebsocketRequest(opChain *chain) (\n\t*http.Response, *websocket.Conn, time.Duration,\n) {\n\tvar conn *websocket.Conn\n\tresp, elapsed, err := r.retryRequest(func() (resp *http.Response, err error) {\n\t\tconn, resp, err = r.config.WebsocketDialer.Dial(\n\t\t\tr.httpReq.URL.String(), r.httpReq.Header)\n\t\treturn resp, err\n\t})\n\n\tif err != nil && err != websocket.ErrBadHandshake {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to send websocket request\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil, nil, 0\n\t}\n\n\tif conn == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to upgrade connection to websocket\"),\n\t\t\t},\n\t\t})\n\t\treturn nil, nil, 0\n\t}\n\n\treturn resp, conn, elapsed\n}\n\nfunc (r *Request) retryRequest(reqFunc func() (*http.Response, error)) (\n\t*http.Response, time.Duration, error,\n) {\n\tif r.httpReq.Body != nil && r.httpReq.Body != http.NoBody {\n\t\tif _, ok := r.httpReq.Body.(*bodyWrapper); !ok {\n\t\t\tr.httpReq.Body = newBodyWrapper(r.httpReq.Body, nil)\n\t\t}\n\t}\n\n\treqBody, _ := r.httpReq.Body.(*bodyWrapper)\n\n\tdelay := r.minRetryDelay\n\ti := 0\n\n\tfor {\n\t\tfor _, printer := range r.config.Printers {\n\t\t\tif reqBody != nil {\n\t\t\t\treqBody.Rewind()\n\t\t\t}\n\t\t\tprinter.Request(r.httpReq)\n\t\t}\n\n\t\tif reqBody != nil {\n\t\t\treqBody.Rewind()\n\t\t}\n\n\t\tvar cancelFn context.CancelFunc\n\n\t\tif r.timeout > 0 {\n\t\t\tvar ctx context.Context\n\t\t\tif r.config.Context != nil {\n\t\t\t\tctx, cancelFn = context.WithTimeout(r.config.Context, r.timeout)\n\t\t\t} else {\n\t\t\t\tctx, cancelFn = context.WithTimeout(context.Background(), r.timeout)\n\t\t\t}\n\n\t\t\tr.httpReq = r.httpReq.WithContext(ctx)\n\t\t}\n\n\t\tstart := time.Now()\n\t\tresp, err := reqFunc()\n\t\telapsed := time.Since(start)\n\n\t\tif resp != nil && resp.Body != nil {\n\t\t\tresp.Body = newBodyWrapper(resp.Body, cancelFn)\n\t\t} else if cancelFn != nil {\n\t\t\tcancelFn()\n\t\t}\n\n\t\tif resp != nil {\n\t\t\tfor _, printer := range r.config.Printers {\n\t\t\t\tif resp.Body != nil {\n\t\t\t\t\tresp.Body.(*bodyWrapper).Rewind()\n\t\t\t\t}\n\t\t\t\tprinter.Response(resp, elapsed)\n\t\t\t}\n\t\t}\n\n\t\ti++\n\t\tif i == r.maxRetries+1 {\n\t\t\treturn resp, elapsed, err\n\t\t}\n\n\t\tif !r.shouldRetry(resp, err) {\n\t\t\treturn resp, elapsed, err\n\t\t}\n\n\t\tif resp != nil && resp.Body != nil {\n\t\t\tresp.Body.Close()\n\t\t}\n\n\t\tif configCtx := r.config.Context; configCtx != nil {\n\t\t\tselect {\n\t\t\tcase <-configCtx.Done():\n\t\t\t\treturn nil, elapsed, configCtx.Err()\n\t\t\tcase <-r.sleepFn(delay):\n\t\t\t}\n\t\t} else {\n\t\t\t<-r.sleepFn(delay)\n\t\t}\n\n\t\tdelay *= 2\n\t\tif delay > r.maxRetryDelay {\n\t\t\tdelay = r.maxRetryDelay\n\t\t}\n\t}\n}\n\nfunc (r *Request) shouldRetry(resp *http.Response, err error) bool {\n\tvar (\n\t\tisTemporaryNetworkError bool // Deprecated\n\t\tisTimeoutError          bool\n\t\tisServerError           bool\n\t\tisHTTPError             bool\n\t)\n\n\tif netErr, ok := err.(net.Error); ok {\n\t\t//nolint\n\t\tisTemporaryNetworkError = netErr.Temporary()\n\t\tisTimeoutError = netErr.Timeout()\n\t}\n\n\tif resp != nil {\n\t\tisServerError = resp.StatusCode >= 500 && resp.StatusCode <= 599\n\t\tisHTTPError = resp.StatusCode >= 400 && resp.StatusCode <= 599\n\t}\n\n\tswitch r.retryPolicy {\n\tcase DontRetry:\n\t\tbreak\n\n\tcase RetryTemporaryNetworkErrors:\n\t\treturn isTemporaryNetworkError\n\n\tcase RetryTemporaryNetworkAndServerErrors:\n\t\treturn isTemporaryNetworkError || isServerError\n\n\tcase RetryTimeoutErrors:\n\t\treturn isTimeoutError\n\n\tcase RetryTimeoutAndServerErrors:\n\t\treturn isTimeoutError || isServerError\n\n\tcase RetryAllErrors:\n\t\treturn err != nil || isHTTPError\n\t}\n\n\treturn false\n}\n\nfunc (r *Request) setupRedirects(opChain *chain) {\n\thttpClient, _ := r.config.Client.(*http.Client)\n\n\tif httpClient == nil {\n\t\tif r.redirectPolicy != defaultRedirectPolicy {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertUsage,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\n\t\t\t\t\t\t\"WithRedirectPolicy() can be used only if Client is *http.Client\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tif r.maxRedirects != -1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertUsage,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\n\t\t\t\t\t\t\"WithMaxRedirects() can be used only if Client is *http.Client\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tif r.redirectPolicy != defaultRedirectPolicy || r.maxRedirects != -1 {\n\t\t\tclientCopy := *httpClient\n\t\t\thttpClient = &clientCopy\n\t\t\tr.config.Client = &clientCopy\n\t\t}\n\t}\n\n\tif r.redirectPolicy == DontFollowRedirects {\n\t\thttpClient.CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\t\t\treturn http.ErrUseLastResponse\n\t\t}\n\t} else if r.maxRedirects >= 0 {\n\t\thttpClient.CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\t\t\tif len(via) > r.maxRedirects {\n\t\t\t\treturn fmt.Errorf(\"stopped after %d redirects\", r.maxRedirects)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t} else if r.redirectPolicy != defaultRedirectPolicy {\n\t\thttpClient.CheckRedirect = nil\n\t}\n\n\tif r.redirectPolicy == FollowAllRedirects {\n\t\tif r.httpReq.Body != nil && r.httpReq.Body != http.NoBody {\n\t\t\tif _, ok := r.httpReq.Body.(*bodyWrapper); !ok {\n\t\t\t\tr.httpReq.Body = newBodyWrapper(r.httpReq.Body, nil)\n\t\t\t}\n\t\t\twrapper := r.httpReq.Body.(*bodyWrapper)\n\t\t\tr.httpReq.GetBody = wrapper.GetBody\n\t\t} else {\n\t\t\tr.httpReq.GetBody = func() (io.ReadCloser, error) {\n\t\t\t\treturn http.NoBody, nil\n\t\t\t}\n\t\t}\n\t} else if r.redirectPolicy != defaultRedirectPolicy {\n\t\tr.httpReq.GetBody = nil\n\t}\n}\n\nvar typeErr = `ambiguous request \"Content-Type\" header values:\n  first set by %s:\n    %q\n  then replaced by %s:\n    %q`\n\nfunc (r *Request) setType(\n\topChain *chain, newSetter, newType string, overwrite bool,\n) {\n\tif r.forceType {\n\t\treturn\n\t}\n\n\tif !overwrite {\n\t\tpreviousType := r.httpReq.Header.Get(\"Content-Type\")\n\n\t\tif previousType != \"\" && previousType != newType {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertUsage,\n\t\t\t\tErrors: []error{\n\t\t\t\t\tfmt.Errorf(typeErr,\n\t\t\t\t\t\tr.typeSetter, previousType, newSetter, newType),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n\n\tr.typeSetter = newSetter\n\tr.httpReq.Header[\"Content-Type\"] = []string{newType}\n}\n\nvar bodyErr = `ambiguous request body contents:\n  first set by %s\n  then replaced by %s`\n\nfunc (r *Request) setBody(\n\topChain *chain, setter string, reader io.Reader, len int, overwrite bool,\n) {\n\tif !overwrite && r.bodySetter != \"\" {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(bodyErr, r.bodySetter, setter),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif len > 0 && reader == nil {\n\t\tpanic(\"invalid length\")\n\t}\n\n\tif reader == nil {\n\t\tr.httpReq.Body = http.NoBody\n\t\tr.httpReq.ContentLength = 0\n\t} else {\n\t\tr.httpReq.Body = io.NopCloser(reader)\n\t\tr.httpReq.ContentLength = int64(len)\n\t}\n\n\tr.bodySetter = setter\n}\n\nfunc (r *Request) checkOrder(opChain *chain, funcCall string) bool {\n\tif r.expectCalled {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected call to %s: Expect() has already been called\", funcCall),\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc concatPaths(a, b string) string {\n\tif a == \"\" {\n\t\treturn b\n\t}\n\tif b == \"\" {\n\t\treturn a\n\t}\n\ta = strings.TrimSuffix(a, \"/\")\n\tb = strings.TrimPrefix(b, \"/\")\n\treturn a + \"/\" + b\n}\n\nfunc mustWrite(w io.Writer, s string) {\n\t_, err := w.Write([]byte(s))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "request_factory.go",
          "type": "blob",
          "size": 0.38671875,
          "content": "package httpexpect\n\nimport (\n\t\"io\"\n\t\"net/http\"\n)\n\n// DefaultRequestFactory is the default RequestFactory implementation which just\n// calls http.NewRequest.\ntype DefaultRequestFactory struct{}\n\n// NewRequest implements RequestFactory.NewRequest.\nfunc (DefaultRequestFactory) NewRequest(\n\tmethod, url string, body io.Reader,\n) (*http.Request, error) {\n\treturn http.NewRequest(method, url, body)\n}\n"
        },
        {
          "name": "request_test.go",
          "type": "blob",
          "size": 91.6455078125,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\tneturl \"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRequest_FailedChain(t *testing.T) {\n\treporter := newMockReporter(t)\n\tassertionHandler := &mockAssertionHandler{}\n\tconfig := newMockConfig(reporter)\n\tchain := newChainWithDefaults(\"test\", reporter, flagFailed)\n\n\treq := newRequest(chain, config, \"GET\", \"\")\n\treq.chain.assert(t, failure)\n\n\treq.Alias(\"foo\")\n\treq.WithName(\"foo\")\n\treq.WithReporter(reporter)\n\treq.WithAssertionHandler(assertionHandler)\n\treq.WithMatcher(func(resp *Response) {\n\t})\n\treq.WithTransformer(func(r *http.Request) {\n\t})\n\treq.WithClient(&http.Client{})\n\treq.WithHandler(http.HandlerFunc(func(http.ResponseWriter, *http.Request) {}))\n\treq.WithContext(context.TODO())\n\treq.WithTimeout(0)\n\treq.WithRedirectPolicy(FollowAllRedirects)\n\treq.WithMaxRedirects(1)\n\treq.WithRetryPolicy(RetryAllErrors)\n\treq.WithMaxRetries(1)\n\treq.WithRetryDelay(time.Millisecond, time.Millisecond)\n\treq.WithWebsocketUpgrade()\n\treq.WithWebsocketDialer(\n\t\tNewWebsocketDialer(\n\t\t\thttp.HandlerFunc(func(http.ResponseWriter, *http.Request) {})))\n\treq.WithPath(\"foo\", \"bar\")\n\treq.WithPathObject(map[string]interface{}{\"foo\": \"bar\"})\n\treq.WithQuery(\"foo\", \"bar\")\n\treq.WithQueryObject(map[string]interface{}{\"foo\": \"bar\"})\n\treq.WithQueryString(\"foo=bar\")\n\treq.WithURL(\"http://example.com\")\n\treq.WithHeaders(map[string]string{\"foo\": \"bar\"})\n\treq.WithHeader(\"foo\", \"bar\")\n\treq.WithCookies(map[string]string{\"foo\": \"bar\"})\n\treq.WithCookie(\"foo\", \"bar\")\n\treq.WithBasicAuth(\"foo\", \"bar\")\n\treq.WithHost(\"127.0.0.1\")\n\treq.WithProto(\"HTTP/1.1\")\n\treq.WithChunked(strings.NewReader(\"foo\"))\n\treq.WithBytes([]byte(\"foo\"))\n\treq.WithText(\"foo\")\n\treq.WithJSON(map[string]string{\"foo\": \"bar\"})\n\treq.WithForm(map[string]string{\"foo\": \"bar\"})\n\treq.WithFormField(\"foo\", \"bar\")\n\treq.WithFile(\"foo\", \"bar\", strings.NewReader(\"baz\"))\n\treq.WithFileBytes(\"foo\", \"bar\", []byte(\"baz\"))\n\treq.WithMultipart()\n\n\tresp := req.Expect()\n\tresp.chain.assert(t, failure)\n}\n\nfunc TestRequest_Constructors(t *testing.T) {\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tconfig := newMockConfig(reporter)\n\t\treq := NewRequestC(config, \"GET\", \"\")\n\t\treq.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\treporter := newMockReporter(t)\n\t\tconfig := newMockConfig(reporter)\n\t\treq := newRequest(chain, config, \"GET\", \"\")\n\t\tassert.NotSame(t, req.chain, chain)\n\t\tassert.Equal(t, req.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestRequest_Reentrancy(t *testing.T) {\n\tt.Run(\"call from reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tconfig := Config{\n\t\t\tClient:   &mockClient{err: errors.New(\"test\")},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\tcallCount := 0\n\t\treporter.reportCb = func() {\n\t\t\tcallCount++\n\t\t\tif callCount == 1 {\n\t\t\t\treq.WithName(\"test\")\n\t\t\t}\n\t\t}\n\n\t\tresp := req.Expect()\n\t\tassert.Equal(t, 2, callCount)\n\n\t\treq.chain.assert(t, failure)\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"call from client\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\tcallCount := 0\n\t\tclient.cb = func(_ *http.Request) {\n\t\t\tcallCount++\n\t\t\treq.WithName(\"test\")\n\t\t}\n\n\t\tresp := req.Expect()\n\t\tassert.Equal(t, 1, callCount)\n\n\t\treq.chain.assert(t, failure)\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"call from transformer\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tClient:   &mockClient{},\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\tcallCount := 0\n\t\treq.WithTransformer(func(_ *http.Request) {\n\t\t\tcallCount++\n\t\t\treq.WithName(\"test\")\n\t\t})\n\n\t\tresp := req.Expect()\n\t\tassert.Equal(t, 1, callCount)\n\n\t\treq.chain.assert(t, failure)\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"call from matcher\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tClient:   &mockClient{},\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\tcallCount := 0\n\t\treq.WithMatcher(func(_ *Response) {\n\t\t\tcallCount++\n\t\t\treq.WithName(\"test\")\n\t\t})\n\n\t\tresp := req.Expect()\n\t\tassert.Equal(t, 1, callCount)\n\n\t\treq.chain.assert(t, failure)\n\t\tresp.chain.assert(t, success)\n\t})\n}\n\nfunc TestRequest_Alias(t *testing.T) {\n\tconfig := Config{\n\t\tClient:   &mockClient{},\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tvalue := NewRequestC(config, \"GET\", \"\")\n\tassert.Equal(t, []string{`Request(\"GET\")`}, value.chain.context.Path)\n\tassert.Equal(t, []string{`Request(\"GET\")`}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{`Request(\"GET\")`}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestRequest_Basic(t *testing.T) {\n\tt.Run(\"get\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/path\")\n\t\tresp := req.Expect()\n\n\t\treq.chain.assert(t, success)\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"empty path\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"\")\n\t\tresp := req.Expect()\n\n\t\treq.chain.assert(t, success)\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"round trip time\", func(t *testing.T) {\n\t\tclient := &mockClient{}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\tfor n := 0; n < 10; n++ {\n\t\t\treq := NewRequestC(config, \"GET\", \"/path\")\n\t\t\tresp := req.Expect()\n\t\t\trequire.NotNil(t, resp.rtt)\n\t\t\tassert.True(t, *resp.rtt >= 0)\n\t\t}\n\t})\n\n\tt.Run(\"client error\", func(t *testing.T) {\n\t\tclient := &mockClient{\n\t\t\terr: errors.New(\"error\"),\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\tassert.Nil(t, resp.Raw())\n\t})\n}\n\nfunc TestRequest_Reporter(t *testing.T) {\n\tt.Run(\"default reporter\", func(t *testing.T) {\n\t\tconfigReporter := newMockReporter(t)\n\t\tconfig := Config{\n\t\t\tClient:   &mockClient{},\n\t\t\tReporter: configReporter,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\treq.WithClient(nil)\n\t\treq.chain.assert(t, failure)\n\n\t\tassert.True(t, configReporter.reported)\n\t})\n\n\tt.Run(\"custom reporter\", func(t *testing.T) {\n\t\tconfigReporter := newMockReporter(t)\n\t\tconfig := Config{\n\t\t\tClient:   &mockClient{},\n\t\t\tReporter: configReporter,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\t// set custom reporter\n\t\treqReporter := newMockReporter(t)\n\t\treq.WithReporter(reqReporter)\n\n\t\treq.WithClient(nil)\n\t\treq.chain.assert(t, failure)\n\n\t\tassert.False(t, configReporter.reported)\n\t\tassert.True(t, reqReporter.reported)\n\t})\n}\n\nfunc TestRequest_AssertionHandler(t *testing.T) {\n\tt.Run(\"default handler\", func(t *testing.T) {\n\t\tconfigHandler := &mockAssertionHandler{}\n\t\tconfig := Config{\n\t\t\tClient:           &mockClient{},\n\t\t\tAssertionHandler: configHandler,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\treq.WithClient(nil)\n\t\treq.chain.assert(t, failure)\n\n\t\tassert.Equal(t, 1, configHandler.failureCalled)\n\t})\n\n\tt.Run(\"custom handler\", func(t *testing.T) {\n\t\tconfigHandler := &mockAssertionHandler{}\n\t\tconfig := Config{\n\t\t\tClient:           &mockClient{},\n\t\t\tAssertionHandler: configHandler,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\t// set custom assertion handler\n\t\treqHandler := &mockAssertionHandler{}\n\t\treq.WithAssertionHandler(reqHandler)\n\n\t\treq.WithClient(nil)\n\t\treq.chain.assert(t, failure)\n\n\t\tassert.Equal(t, 0, configHandler.failureCalled)\n\t\tassert.Equal(t, 1, reqHandler.failureCalled)\n\t})\n}\n\nfunc TestRequest_Matchers(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\treq := NewRequestC(config, \"GET\", \"/\")\n\n\tvar resps []*Response\n\n\treq.WithMatcher(func(r *Response) {\n\t\tresps = append(resps, r)\n\t})\n\n\tassert.Equal(t, 0, len(resps))\n\n\tresp := req.Expect()\n\n\tassert.Equal(t, 1, len(resps))\n\tassert.Same(t, resp, resps[0])\n}\n\nfunc TestRequest_Transformers(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"save ptr\", func(t *testing.T) {\n\t\tvar savedReq *http.Request\n\t\ttransform := func(r *http.Request) {\n\t\t\tsavedReq = r\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\t\treq.WithTransformer(transform)\n\t\treq.Expect().chain.assert(t, success)\n\n\t\tassert.NotNil(t, savedReq)\n\t})\n\n\tt.Run(\"append header\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\treq.WithTransformer(func(r *http.Request) {\n\t\t\tr.Header.Add(\"foo\", \"11\")\n\t\t})\n\n\t\treq.WithTransformer(func(r *http.Request) {\n\t\t\tr.Header.Add(\"bar\", \"22\")\n\t\t})\n\n\t\treq.Expect().chain.assert(t, success)\n\n\t\tassert.Equal(t, []string{\"11\"}, client.req.Header[\"Foo\"])\n\t\tassert.Equal(t, []string{\"22\"}, client.req.Header[\"Bar\"])\n\t})\n\n\tt.Run(\"append url\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}\")\n\n\t\treq.WithPath(\"arg1\", \"11\")\n\t\treq.WithPath(\"arg2\", \"22\")\n\n\t\treq.WithTransformer(func(r *http.Request) {\n\t\t\tr.URL.Path += \"/33\"\n\t\t})\n\n\t\treq.WithTransformer(func(r *http.Request) {\n\t\t\tr.URL.Path += \"/44\"\n\t\t})\n\n\t\treq.Expect().chain.assert(t, success)\n\n\t\tassert.Equal(t, \"/11/22/33/44\", client.req.URL.Path)\n\t})\n\n\tt.Run(\"nil func\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\t\treq.WithTransformer(nil)\n\t\treq.chain.assert(t, failure)\n\t})\n}\n\nfunc TestRequest_Client(t *testing.T) {\n\tclient1 := &mockClient{}\n\tclient2 := &mockClient{}\n\n\tconfig := Config{\n\t\tReporter: newMockReporter(t),\n\t\tClient:   client1,\n\t}\n\n\tvar req *Request\n\n\treq = NewRequestC(config, \"GET\", \"/\")\n\treq.Expect().chain.assert(t, success)\n\tassert.NotNil(t, client1.req)\n\n\treq = NewRequestC(config, \"GET\", \"/\")\n\treq.WithClient(client2)\n\treq.Expect().chain.assert(t, success)\n\tassert.NotNil(t, client2.req)\n\n\treq = NewRequestC(config, \"GET\", \"/\")\n\treq.WithClient(nil)\n\treq.chain.assert(t, failure)\n}\n\nfunc TestRequest_Handler(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvar hr1 *http.Request\n\t\thandler1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\thr1 = r\n\t\t})\n\n\t\tvar hr2 *http.Request\n\t\thandler2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\thr2 = r\n\t\t})\n\n\t\tconfig := Config{\n\t\t\tReporter: reporter,\n\t\t\tClient: &http.Client{\n\t\t\t\tTransport: NewBinder(handler1),\n\t\t\t},\n\t\t}\n\n\t\tvar req *Request\n\n\t\treq = NewRequestC(config, \"GET\", \"/\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.NotNil(t, hr1)\n\n\t\treq = NewRequestC(config, \"GET\", \"/\")\n\t\treq.WithHandler(handler2)\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.NotNil(t, hr2)\n\t})\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tconfig := Config{\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\t\treq.WithHandler(nil)\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"reset client\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvar hr *http.Request\n\t\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\thr = r\n\t\t})\n\n\t\tclient := &mockClient{}\n\n\t\tconfig := Config{\n\t\t\tReporter: reporter,\n\t\t\tClient:   client,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\t\treq.WithHandler(handler)\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.NotNil(t, hr)\n\t\tassert.Nil(t, client.req)\n\t})\n\n\tt.Run(\"reuse client\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\thandler1 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\t\thandler2 := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {})\n\n\t\tclient := &http.Client{\n\t\t\tTransport: NewBinder(handler1),\n\t\t\tJar:       NewCookieJar(),\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tReporter: reporter,\n\t\t\tClient:   client,\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"/\")\n\t\treq.WithHandler(handler2)\n\t\tassert.Same(t, client.Jar, req.config.Client.(*http.Client).Jar)\n\t})\n}\n\nfunc TestRequest_Proto(t *testing.T) {\n\tcases := []struct {\n\t\tname   string\n\t\tproto  string\n\t\tmajor  int\n\t\tminor  int\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname:   \"default\",\n\t\t\tproto:  \"\",\n\t\t\tmajor:  1,\n\t\t\tminor:  1,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"1.0\",\n\t\t\tproto:  \"HTTP/1.0\",\n\t\t\tmajor:  1,\n\t\t\tminor:  0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"1.1\",\n\t\t\tproto:  \"HTTP/1.1\",\n\t\t\tmajor:  1,\n\t\t\tminor:  1,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"2.0\",\n\t\t\tproto:  \"HTTP/2.0\",\n\t\t\tmajor:  2,\n\t\t\tminor:  0,\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname:   \"invalid\",\n\t\t\tproto:  \"<invalid>\",\n\t\t\tresult: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconfig := Config{\n\t\t\t\tClient:   &mockClient{},\n\t\t\t\tReporter: newMockReporter(t),\n\t\t\t}\n\n\t\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\t\tif tc.proto != \"\" {\n\t\t\t\treq.WithProto(tc.proto)\n\t\t\t}\n\n\t\t\treq.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.major, req.httpReq.ProtoMajor)\n\t\t\t\tassert.Equal(t, tc.minor, req.httpReq.ProtoMinor)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRequest_URLConcatenate(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\tbaseURL     string\n\t\tmethod      string\n\t\tpath        string\n\t\tpathArgs    []interface{}\n\t\tsetupFunc   func(req *Request)\n\t\texpectedURL string\n\t}{\n\t\t{\n\t\t\tname:        \"empty url, empty path\",\n\t\t\tbaseURL:     \"\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"\",\n\t\t\texpectedURL: \"\",\n\t\t},\n\t\t{\n\t\t\tname:        \"empty path\",\n\t\t\tbaseURL:     \"http://example.com\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"\",\n\t\t\texpectedURL: \"http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with slash, empty path\",\n\t\t\tbaseURL:     \"http://example.com/\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"\",\n\t\t\texpectedURL: \"http://example.com/\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with path\",\n\t\t\tbaseURL:     \"http://example.com\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"path\",\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with path, path without slash\",\n\t\t\tbaseURL:     \"http://example.com\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"path\",\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with path, path with slash\",\n\t\t\tbaseURL:     \"http://example.com\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"/path\",\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with slash and path, path without slash\",\n\t\t\tbaseURL:     \"http://example.com/\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"path\",\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with slash and path, path with slash\",\n\t\t\tbaseURL:     \"http://example.com/\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"/path\",\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:        \"url with path arg\",\n\t\t\tbaseURL:     \"http://example.com/\",\n\t\t\tmethod:      \"GET\",\n\t\t\tpath:        \"{arg}\",\n\t\t\tpathArgs:    []interface{}{\"/path\"},\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:    \"url with arg setup func\",\n\t\t\tbaseURL: \"http://example.com/\",\n\t\t\tmethod:  \"GET\",\n\t\t\tpath:    \"{arg}\",\n\t\t\tsetupFunc: func(req *Request) {\n\t\t\t\treq.WithPath(\"arg\", \"/path\")\n\t\t\t},\n\t\t\texpectedURL: \"http://example.com/path\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tclient := &mockClient{}\n\t\t\treporter := NewAssertReporter(t)\n\n\t\t\treq := NewRequestC(\n\t\t\t\tConfig{\n\t\t\t\t\tBaseURL:  tc.baseURL,\n\t\t\t\t\tClient:   client,\n\t\t\t\t\tReporter: reporter,\n\t\t\t\t},\n\t\t\t\ttc.method,\n\t\t\t\ttc.path,\n\t\t\t\ttc.pathArgs...)\n\n\t\t\tif tc.setupFunc != nil {\n\t\t\t\ttc.setupFunc(req)\n\t\t\t}\n\n\t\t\treq.Expect().chain.assert(t, success)\n\t\t\treq.chain.assert(t, success)\n\t\t\tassert.Equal(t, tc.expectedURL, req.httpReq.URL.String())\n\n\t\t})\n\t}\n}\n\nfunc TestRequest_URLOverwrite(t *testing.T) {\n\tcases := []struct {\n\t\tname         string\n\t\tbaseURL      string\n\t\tmethod       string\n\t\tpath         string\n\t\toverwriteURL string\n\t\texpectedURL  string\n\t}{\n\t\t{\n\t\t\tname:         \"without slash on url\",\n\t\t\tbaseURL:      \"\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"/path\",\n\t\t\toverwriteURL: \"http://example.com\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"without slash on url and path\",\n\t\t\tbaseURL:      \"\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"path\",\n\t\t\toverwriteURL: \"http://example.com\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"with slash on url and path\",\n\t\t\tbaseURL:      \"\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"/path\",\n\t\t\toverwriteURL: \"http://example.com/\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"without slash on path\",\n\t\t\tbaseURL:      \"\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"path\",\n\t\t\toverwriteURL: \"http://example.com/\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"without slash on url\",\n\t\t\tbaseURL:      \"http://foobar.com\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"/path\",\n\t\t\toverwriteURL: \"http://example.com\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"without slash on url and path\",\n\t\t\tbaseURL:      \"http://foobar.com\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"path\",\n\t\t\toverwriteURL: \"http://example.com\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"with slash on url and path\",\n\t\t\tbaseURL:      \"http://foobar.com\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"/path\",\n\t\t\toverwriteURL: \"http://example.com/\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t\t{\n\t\t\tname:         \"without slash on path\",\n\t\t\tbaseURL:      \"http://foobar.com\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"path\",\n\t\t\toverwriteURL: \"http://example.com/\",\n\t\t\texpectedURL:  \"http://example.com/path\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tclient := &mockClient{}\n\t\t\treporter := NewAssertReporter(t)\n\n\t\t\treq := NewRequestC(\n\t\t\t\tConfig{\n\t\t\t\t\tBaseURL:  tc.baseURL,\n\t\t\t\t\tClient:   client,\n\t\t\t\t\tReporter: reporter,\n\t\t\t\t},\n\t\t\t\ttc.method,\n\t\t\t\ttc.path)\n\n\t\t\treq.WithURL(tc.overwriteURL)\n\n\t\t\treq.Expect().chain.assert(t, success)\n\t\t\treq.chain.assert(t, success)\n\t\t\tassert.Equal(t, tc.expectedURL, client.req.URL.String())\n\t\t})\n\t}\n}\n\nfunc TestRequest_URLQuery(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com\",\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tcheckOK := func(req *Request, url string) {\n\t\tclient.req = nil\n\t\treq.Expect()\n\t\treq.chain.assert(t, success)\n\t\tassert.Equal(t, url, client.req.URL.String())\n\t}\n\n\tcheckFailed := func(req *Request) {\n\t\treq.chain.assert(t, failure)\n\t}\n\n\tt.Run(\"WithQuery\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQuery(\"aa\", \"foo\").WithQuery(\"bb\", 123).WithQuery(\"cc\", \"*&@\")\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?aa=foo&bb=123&cc=%2A%26%40\")\n\t})\n\n\tt.Run(\"WithQueryObject map\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQuery(\"aa\", \"foo\").\n\t\t\tWithQueryObject(map[string]interface{}{\n\t\t\t\t\"bb\": 123,\n\t\t\t\t\"cc\": \"*&@\",\n\t\t\t})\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?aa=foo&bb=123&cc=%2A%26%40\")\n\t})\n\n\ttype S struct {\n\t\tBb int    `url:\"bb\"`\n\t\tCc string `url:\"cc\"`\n\t\tDd string `url:\"-\"`\n\t}\n\n\tt.Run(\"WithQueryObject struct\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQueryObject(S{123, \"*&@\", \"dummy\"}).WithQuery(\"aa\", \"foo\")\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?aa=foo&bb=123&cc=%2A%26%40\")\n\t})\n\n\tt.Run(\"WithQueryObject pointer to struct\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQueryObject(&S{123, \"*&@\", \"dummy\"}).WithQuery(\"aa\", \"foo\")\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?aa=foo&bb=123&cc=%2A%26%40\")\n\t})\n\n\tt.Run(\"WithQuery and WithQueryString\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQuery(\"bb\", 123).\n\t\t\tWithQueryString(\"aa=foo&cc=%2A%26%40\")\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?aa=foo&bb=123&cc=%2A%26%40\")\n\t})\n\n\tt.Run(\"WithQueryString and WithQuery\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQueryString(\"aa=foo&cc=%2A%26%40\").\n\t\t\tWithQuery(\"bb\", 123)\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?aa=foo&bb=123&cc=%2A%26%40\")\n\t})\n\n\tt.Run(\"WithQueryObject nil\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQuery(\"foo\", \"bar\").\n\t\t\tWithQueryObject(nil)\n\t\tcheckOK(req,\n\t\t\t\"http://example.com/path?foo=bar\")\n\t})\n\n\tt.Run(\"WithQueryString invalid\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQueryString(\"%\")\n\t\tcheckFailed(req)\n\t})\n\n\tt.Run(\"WithQueryObject invalid\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQueryObject(func() {})\n\t\tcheckFailed(req)\n\t})\n\n\tt.Run(\"WithQueryObject invalid struct\", func(t *testing.T) {\n\t\ttype invalidSt struct {\n\t\t\tStr mockQueryEncoder\n\t\t}\n\t\tqueryObj := invalidSt{\n\t\t\tStr: mockQueryEncoder(\"err\"),\n\t\t}\n\t\treq := NewRequestC(config, \"GET\", \"/path\").\n\t\t\tWithQueryObject(queryObj)\n\t\tcheckFailed(req)\n\t})\n}\n\nfunc TestRequest_PathConstruct(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\tpath        string\n\t\tpathArgs    []interface{}\n\t\texpectedURL string\n\t\tresult      chainResult\n\t}{\n\t\t{\n\t\t\tname:        \"nil args slice\",\n\t\t\tpath:        \"/foo/{arg}\",\n\t\t\tpathArgs:    nil,\n\t\t\texpectedURL: \"http://example.com/foo/%7Barg%7D\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"empty args slice\",\n\t\t\tpath:        \"/foo/{arg}\",\n\t\t\tpathArgs:    []interface{}{},\n\t\t\texpectedURL: \"http://example.com/foo/%7Barg%7D\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"missing braсe, empty args slice\",\n\t\t\tpath:        \"/foo/{arg\",\n\t\t\tpathArgs:    []interface{}{},\n\t\t\texpectedURL: \"http://example.com/foo/%7Barg\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"unmatched brace, empty args slice\",\n\t\t\tpath:        \"/foo/{arg}}\",\n\t\t\tpathArgs:    []interface{}{},\n\t\t\texpectedURL: \"http://example.com/foo/%7Barg%7D%7D\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"one arg\",\n\t\t\tpath:        \"/foo/{arg}\",\n\t\t\tpathArgs:    []interface{}{\"bar\"},\n\t\t\texpectedURL: \"http://example.com/foo/bar\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"two args\",\n\t\t\tpath:        \"{arg}foo{arg}\",\n\t\t\tpathArgs:    []interface{}{\"/\", \"/bar\"},\n\t\t\texpectedURL: \"http://example.com/foo/bar\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"one arg with slashes\",\n\t\t\tpath:        \"{arg}\",\n\t\t\tpathArgs:    []interface{}{\"/foo/bar\"},\n\t\t\texpectedURL: \"http://example.com/foo/bar\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:        \"incomplete\",\n\t\t\tpath:        \"/{arg1}/{arg2}\",\n\t\t\tpathArgs:    []interface{}{\"foo\"},\n\t\t\texpectedURL: \"http://example.com/foo/%7Barg2%7D\",\n\t\t\tresult:      success,\n\t\t},\n\t\t{\n\t\t\tname:     \"nil arg\",\n\t\t\tpath:     \"/{arg1}\",\n\t\t\tpathArgs: []interface{}{nil},\n\t\t\tresult:   failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tclient := &mockClient{}\n\n\t\t\tconfig := Config{\n\t\t\t\tBaseURL:  \"http://example.com/\",\n\t\t\t\tClient:   client,\n\t\t\t\tReporter: newMockReporter(t),\n\t\t\t}\n\n\t\t\treq := NewRequestC(config, \"GET\", tc.path, tc.pathArgs...)\n\n\t\t\tif tc.result {\n\t\t\t\treq.chain.assert(t, success)\n\t\t\t\treq.Expect().chain.assert(t, success)\n\n\t\t\t\tassert.Equal(t, tc.expectedURL,\n\t\t\t\t\tclient.req.URL.String())\n\t\t\t} else {\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRequest_Path(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com/\",\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"complete\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPath(\"ARG3\", \"baz\")\n\t\treq.WithPath(\"arg2\", \"bar\")\n\t\treq.WithPath(\"arg1\", \"foo\")\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/foo/bar/baz\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"incomplete\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPath(\"ARG3\", \"baz\")\n\t\treq.WithPath(\"arg2\", \"bar\")\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/%7Barg1%7D/bar/baz\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"invalid path\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg\")\n\t\treq.chain.assert(t, success)\n\t\treq.WithPath(\"arg\", \"foo\")\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid key\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPath(\"BAD\", \"value\")\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid value\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPath(\"arg\", nil)\n\t\treq.chain.assert(t, failure)\n\t})\n}\n\nfunc TestRequest_PathObject(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com/\",\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"map string\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(map[string]string{\n\t\t\t\"arg1\": \"foo\",\n\t\t\t\"arg2\": \"bar\",\n\t\t\t\"ARG3\": \"baz\",\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/foo/bar/baz\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"map any\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(map[string]interface{}{\n\t\t\t\"arg1\": \"foo\",\n\t\t\t\"arg2\": 222,\n\t\t\t\"ARG3\": 333,\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/foo/222/333\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"map incomplete\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(map[string]string{\n\t\t\t\"arg2\": \"bar\",\n\t\t\t\"ARG3\": \"baz\",\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/%7Barg1%7D/bar/baz\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(struct {\n\t\t\tArg1 string\n\t\t\tArg2 interface{}\n\t\t\tArg3 int\n\t\t}{\n\t\t\tArg1: \"foo\",\n\t\t\tArg2: \"bar\",\n\t\t\tArg3: 333,\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/foo/bar/333\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"struct incomplete\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(struct {\n\t\t\tArg2 string\n\t\t\tArg3 string\n\t\t}{\n\t\t\tArg2: \"bar\",\n\t\t\tArg3: \"baz\",\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/%7Barg1%7D/bar/baz\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"struct tags\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(struct {\n\t\t\tArg1 string\n\t\t\tA2   string `path:\"arg2\"`\n\t\t\tArg3 string `path:\"-\"`\n\t\t}{\n\t\t\tArg1: \"foo\",\n\t\t\tA2:   \"bar\",\n\t\t\tArg3: \"baz\",\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/foo/bar/%7Barg3%7D\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"struct pointer\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}/{arg3}\")\n\t\treq.WithPathObject(&struct {\n\t\t\tArg1 string\n\t\t\tArg2 string\n\t\t\tArg3 string\n\t\t}{\n\t\t\tArg1: \"foo\",\n\t\t\tArg2: \"bar\",\n\t\t\tArg3: \"baz\",\n\t\t})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/foo/bar/baz\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"nil argument\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPathObject(nil)\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/%7Barg%7D\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"empty argument\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPathObject(map[string]string{})\n\t\treq.Expect().chain.assert(t, success)\n\t\trequire.NotNil(t, client.req)\n\t\tassert.Equal(t, \"http://example.com/%7Barg%7D\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.chain.assert(t, success)\n\t\treq.WithPathObject(func() {})\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"nil value\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPathObject(map[string]interface{}{\n\t\t\t\"arg\": nil,\n\t\t})\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid value\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPathObject(map[string]interface{}{\n\t\t\t\"arg\": func() {},\n\t\t})\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid key\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg}\")\n\t\treq.WithPathObject(map[string]interface{}{\n\t\t\t\"BAD\": nil,\n\t\t})\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid path\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"{arg\")\n\t\treq.chain.assert(t, success)\n\t\treq.WithPathObject(map[string]interface{}{\n\t\t\t\"arg\": \"foo\",\n\t\t})\n\t\treq.chain.assert(t, failure)\n\t})\n}\n\nfunc TestRequest_PathCombined(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tBaseURL:  \"http://example.com/\",\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"constructor and WithPath\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}\", \"foo\")\n\t\treq.WithPath(\"arg2\", \"bar\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, \"http://example.com/foo/bar\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"constructor and WithPathObject\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}\", \"foo\")\n\t\treq.WithPathObject(map[string]string{\"arg2\": \"bar\"})\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, \"http://example.com/foo/bar\",\n\t\t\tclient.req.URL.String())\n\t})\n\n\tt.Run(\"WithPath and WithPathObject\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/{arg1}/{arg2}\")\n\t\treq.WithPathObject(map[string]string{\"arg1\": \"foo\"})\n\t\treq.WithPath(\"arg2\", \"bar\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, \"http://example.com/foo/bar\",\n\t\t\tclient.req.URL.String())\n\t})\n}\n\nfunc TestRequest_Headers(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\treq := NewRequestC(config, \"GET\", \"url\")\n\n\treq.WithHeader(\"first-header\", \"foo\")\n\n\treq.WithHeaders(map[string]string{\n\t\t\"Second-Header\": \"bar\",\n\t\t\"content-Type\":  \"baz\",\n\t\t\"HOST\":          \"example.com\",\n\t})\n\n\texpectedHeaders := map[string][]string{\n\t\t\"First-Header\":  {\"foo\"},\n\t\t\"Second-Header\": {\"bar\"},\n\t\t\"Content-Type\":  {\"baz\"},\n\t}\n\n\tresp := req.Expect()\n\tresp.chain.assert(t, success)\n\n\tassert.Equal(t, \"GET\", client.req.Method)\n\tassert.Equal(t, \"example.com\", client.req.Host)\n\tassert.Equal(t, \"url\", client.req.URL.String())\n\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\n\tassert.Same(t, &client.resp, resp.Raw())\n}\n\nfunc TestRequest_Cookies(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\treq := NewRequestC(config, \"GET\", \"url\")\n\n\treq.WithCookie(\"foo\", \"1\")\n\treq.WithCookie(\"bar\", \"2 \")\n\n\treq.WithCookies(map[string]string{\n\t\t\"baz\": \" 3\",\n\t})\n\n\texpectedHeaders := map[string][]string{\n\t\t\"Cookie\": {`foo=1; bar=\"2 \"; baz=\" 3\"`},\n\t}\n\n\tresp := req.Expect()\n\tresp.chain.assert(t, success)\n\n\tassert.Equal(t, \"GET\", client.req.Method)\n\tassert.Equal(t, \"url\", client.req.URL.String())\n\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\n\tassert.Same(t, &client.resp, resp.Raw())\n}\n\nfunc TestRequest_BasicAuth(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\treq := NewRequestC(config, \"GET\", \"url\")\n\n\treq.WithBasicAuth(\"Aladdin\", \"open sesame\")\n\treq.chain.assert(t, success)\n\n\tassert.Equal(t, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\",\n\t\treq.httpReq.Header.Get(\"Authorization\"))\n}\n\nfunc TestRequest_Host(t *testing.T) {\n\tcases := []struct {\n\t\tname         string\n\t\tmethod       string\n\t\tpath         string\n\t\texpectedHost string\n\t\tsetupFunc    func(req *Request)\n\t}{\n\t\t{\n\t\t\tname:         \"request with host and without host header\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"url\",\n\t\t\texpectedHost: \"example.com\",\n\t\t\tsetupFunc: func(req *Request) {\n\t\t\t\treq.WithHost(\"example.com\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:         \"request with header before with host\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"url\",\n\t\t\texpectedHost: \"example2.com\",\n\t\t\tsetupFunc: func(req *Request) {\n\t\t\t\treq.WithHost(\"example1.com\")\n\t\t\t\treq.withHeader(\"HOST\", \"example2.com\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:         \"request with host before with header\",\n\t\t\tmethod:       \"GET\",\n\t\t\tpath:         \"url\",\n\t\t\texpectedHost: \"example1.com\",\n\t\t\tsetupFunc: func(req *Request) {\n\t\t\t\treq.WithHost(\"example2.com\")\n\t\t\t\treq.withHeader(\"HOST\", \"example1.com\")\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tclient := &mockClient{}\n\t\t\treporter := newMockReporter(t)\n\n\t\t\treq := NewRequestC(\n\t\t\t\tConfig{\n\t\t\t\t\tClient:   client,\n\t\t\t\t\tReporter: reporter,\n\t\t\t\t},\n\t\t\t\ttc.method,\n\t\t\t\ttc.path)\n\n\t\t\tif tc.setupFunc != nil {\n\t\t\t\ttc.setupFunc(req)\n\t\t\t}\n\n\t\t\tresp := req.Expect()\n\t\t\treq.chain.assert(t, success)\n\t\t\tresp.chain.assert(t, success)\n\n\t\t\tassert.Equal(t, tc.method, client.req.Method)\n\t\t\tassert.Equal(t, tc.expectedHost, client.req.Host)\n\t\t\tassert.Equal(t, tc.path, client.req.URL.String())\n\n\t\t\tassert.Same(t, &client.resp, resp.Raw())\n\t\t})\n\t}\n}\n\nfunc TestRequest_BodyChunked(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"body\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithChunked(bytes.NewBufferString(\"body\"))\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.NotNil(t, client.req.Body)\n\t\tassert.Equal(t, int64(-1), client.req.ContentLength)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\t\tassert.Equal(t, make(http.Header), client.req.Header)\n\t\tassert.Equal(t, \"body\", resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithChunked(nil)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, http.NoBody, client.req.Body)\n\t\tassert.Equal(t, int64(0), client.req.ContentLength)\n\t})\n\n\tt.Run(\"proto 1.0\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithProto(\"HTTP/1.0\")\n\t\tassert.Equal(t, 1, req.httpReq.ProtoMajor)\n\t\tassert.Equal(t, 0, req.httpReq.ProtoMinor)\n\n\t\treq.WithChunked(bytes.NewBufferString(\"body\"))\n\t\treq.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"proto 2.0\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithProto(\"HTTP/2.0\")\n\t\tassert.Equal(t, 2, req.httpReq.ProtoMajor)\n\t\tassert.Equal(t, 0, req.httpReq.ProtoMinor)\n\n\t\treq.WithChunked(bytes.NewBufferString(\"body\"))\n\t\tassert.Equal(t, 2, req.httpReq.ProtoMajor)\n\t\tassert.Equal(t, 0, req.httpReq.ProtoMinor)\n\t})\n}\n\nfunc TestRequest_BodyBytes(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"byte slice\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"/path\")\n\n\t\treq.WithBytes([]byte(\"body\"))\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.NotNil(t, client.req.Body)\n\t\tassert.Equal(t, int64(len(\"body\")), client.req.ContentLength)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"/path\", client.req.URL.String())\n\t\tassert.Equal(t, make(http.Header), client.req.Header)\n\t\tassert.Equal(t, \"body\", resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithBytes(nil)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, http.NoBody, client.req.Body)\n\t\tassert.Equal(t, int64(0), client.req.ContentLength)\n\t})\n}\n\nfunc TestRequest_BodyText(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\texpectedHeaders := map[string][]string{\n\t\t\"Content-Type\": {\"text/plain; charset=utf-8\"},\n\t\t\"Some-Header\":  {\"foo\"},\n\t}\n\n\treq := NewRequestC(config, \"GET\", \"url\")\n\n\treq.WithHeaders(map[string]string{\n\t\t\"Some-Header\": \"foo\",\n\t})\n\n\treq.WithText(\"some text\")\n\n\tresp := req.Expect()\n\tresp.chain.assert(t, success)\n\n\tassert.Equal(t, \"GET\", client.req.Method)\n\tassert.Equal(t, \"url\", client.req.URL.String())\n\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\tassert.Equal(t, \"some text\", resp.Body().Raw())\n\n\tassert.Same(t, &client.resp, resp.Raw())\n}\n\nfunc TestRequest_BodyForm(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"form\", func(t *testing.T) {\n\t\texpectedHeaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t\t\"Some-Header\":  {\"foo\"},\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithHeaders(map[string]string{\n\t\t\t\"Some-Header\": \"foo\",\n\t\t})\n\n\t\treq.WithForm(map[string]interface{}{\n\t\t\t\"a\": 1,\n\t\t\t\"b\": \"2\",\n\t\t})\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\t\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\t\tassert.Equal(t, `a=1&b=2`, resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"form field\", func(t *testing.T) {\n\t\texpectedHeaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t\t\"Some-Header\":  {\"foo\"},\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithHeaders(map[string]string{\n\t\t\t\"Some-Header\": \"foo\",\n\t\t})\n\n\t\treq.WithFormField(\"a\", 1)\n\t\treq.WithFormField(\"b\", \"2\")\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\t\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\t\tassert.Equal(t, `a=1&b=2`, resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"form struct\", func(t *testing.T) {\n\t\texpectedHeaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\ttype S struct {\n\t\t\tA string `form:\"a\"`\n\t\t\tB int    `form:\"b\"`\n\t\t\tC int    `form:\"-\"`\n\t\t}\n\n\t\treq.WithForm(S{\"1\", 2, 3})\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\t\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\t\tassert.Equal(t, `a=1&b=2`, resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"form combined\", func(t *testing.T) {\n\t\texpectedHeaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\ttype S struct {\n\t\t\tA int `form:\"a\"`\n\t\t}\n\n\t\treq.WithForm(S{A: 1})\n\t\treq.WithForm(map[string]string{\"b\": \"2\"})\n\t\treq.WithFormField(\"c\", 3)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\t\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\t\tassert.Equal(t, `a=1&b=2&c=3`, resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"marshal error\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithForm(func() {})\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\tassert.Nil(t, resp.Raw())\n\t})\n}\n\nfunc TestRequest_BodyMultipart(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"multipart\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"POST\", \"url\")\n\n\t\treq.WithMultipart()\n\t\treq.WithForm(map[string]string{\"b\": \"1\", \"c\": \"2\"})\n\t\treq.WithFormField(\"a\", 3)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"POST\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\n\t\tmediatype, params, err := mime.ParseMediaType(client.req.Header.Get(\"Content-Type\"))\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"multipart/form-data\", mediatype)\n\t\tassert.True(t, params[\"boundary\"] != \"\")\n\n\t\treader := multipart.NewReader(strings.NewReader(resp.Body().Raw()),\n\t\t\tparams[\"boundary\"])\n\n\t\tpart1, _ := reader.NextPart()\n\t\tassert.Equal(t, \"b\", part1.FormName())\n\t\tassert.Equal(t, \"\", part1.FileName())\n\t\tb1, _ := io.ReadAll(part1)\n\t\tassert.Equal(t, \"1\", string(b1))\n\n\t\tpart2, _ := reader.NextPart()\n\t\tassert.Equal(t, \"c\", part2.FormName())\n\t\tassert.Equal(t, \"\", part2.FileName())\n\t\tb2, _ := io.ReadAll(part2)\n\t\tassert.Equal(t, \"2\", string(b2))\n\n\t\tpart3, _ := reader.NextPart()\n\t\tassert.Equal(t, \"a\", part3.FormName())\n\t\tassert.Equal(t, \"\", part3.FileName())\n\t\tb3, _ := io.ReadAll(part3)\n\t\tassert.Equal(t, \"3\", string(b3))\n\n\t\teof, _ := reader.NextPart()\n\t\tassert.Nil(t, eof)\n\t})\n\n\tt.Run(\"multipart file\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"POST\", \"url\")\n\n\t\tfh, _ := os.CreateTemp(\"\", \"httpexpect\")\n\t\tfilename2 := fh.Name()\n\t\t_, _ = fh.WriteString(\"2\")\n\t\tfh.Close()\n\t\tdefer os.Remove(filename2)\n\n\t\treq.WithMultipart()\n\t\treq.WithForm(map[string]string{\"a\": \"1\"})\n\t\treq.WithFile(\"b\", filename2)\n\t\treq.WithFile(\"c\", \"filename3\", strings.NewReader(\"3\"))\n\t\treq.WithFileBytes(\"d\", \"filename4\", []byte(\"4\"))\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"POST\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\n\t\tmediatype, params, err := mime.ParseMediaType(client.req.Header.Get(\"Content-Type\"))\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"multipart/form-data\", mediatype)\n\t\tassert.True(t, params[\"boundary\"] != \"\")\n\n\t\treader := multipart.NewReader(strings.NewReader(resp.Body().Raw()),\n\t\t\tparams[\"boundary\"])\n\n\t\tpart1, _ := reader.NextPart()\n\t\tassert.Equal(t, \"a\", part1.FormName())\n\t\tassert.Equal(t, \"\", part1.FileName())\n\t\tb1, _ := io.ReadAll(part1)\n\t\tassert.Equal(t, \"1\", string(b1))\n\n\t\tpart2, _ := reader.NextPart()\n\t\tassert.Equal(t, \"b\", part2.FormName())\n\t\tassert.Equal(t, filepath.Base(filename2), filepath.Base(part2.FileName()))\n\t\tb2, _ := io.ReadAll(part2)\n\t\tassert.Equal(t, \"2\", string(b2))\n\n\t\tpart3, _ := reader.NextPart()\n\t\tassert.Equal(t, \"c\", part3.FormName())\n\t\tassert.Equal(t, \"filename3\", filepath.Base(part3.FileName()))\n\t\tb3, _ := io.ReadAll(part3)\n\t\tassert.Equal(t, \"3\", string(b3))\n\n\t\tpart4, _ := reader.NextPart()\n\t\tassert.Equal(t, \"d\", part4.FormName())\n\t\tassert.Equal(t, \"filename4\", filepath.Base(part4.FileName()))\n\t\tb4, _ := io.ReadAll(part4)\n\t\tassert.Equal(t, \"4\", string(b4))\n\n\t\teof, _ := reader.NextPart()\n\t\tassert.Nil(t, eof)\n\t})\n\n\tt.Run(\"multipart writer error\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname   string\n\t\t\treqFn  func(*Request)\n\t\t\tresult chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"with form\",\n\t\t\t\treqFn: func(req *Request) {\n\t\t\t\t\treq.WithForm(map[string]string{\"foo\": \"bar\"})\n\t\t\t\t},\n\t\t\t\tresult: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"with form field\",\n\t\t\t\treqFn: func(req *Request) {\n\t\t\t\t\treq.WithFormField(\"foo\", \"bar\")\n\t\t\t\t},\n\t\t\t\tresult: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"with file\",\n\t\t\t\treqFn: func(req *Request) {\n\t\t\t\t\treq.WithFile(\"foo\", \"bar\", strings.NewReader(\"baz\"))\n\t\t\t\t},\n\t\t\t\tresult: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"POST\", \"url\")\n\t\t\t\treq.multipartFn = func(w io.Writer) *multipart.Writer {\n\t\t\t\t\treturn multipart.NewWriter(&mockWriter{\n\t\t\t\t\t\terr: errors.New(\"mock writer error\"),\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\treq.WithMultipart()\n\t\t\t\ttc.reqFn(req)\n\n\t\t\t\treq.chain.assert(t, tc.result)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"missing WithMultipart\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname  string\n\t\t\treqFn func(*Request)\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"WithFile\",\n\t\t\t\treqFn: func(req *Request) {\n\t\t\t\t\treq.WithFile(\"test_key\", \"test_file\", strings.NewReader(\"test_data\"))\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"WithFileBytes\",\n\t\t\t\treqFn: func(req *Request) {\n\t\t\t\t\treq.WithFileBytes(\"test_key\", \"test_file\", []byte(\"test_data\"))\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"POST\", \"url\")\n\n\t\t\t\ttc.reqFn(req)\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t})\n\t\t}\n\n\t})\n}\n\nfunc TestRequest_BodyJSON(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"json\", func(t *testing.T) {\n\t\texpectedHeaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json; charset=utf-8\"},\n\t\t\t\"Some-Header\":  {\"foo\"},\n\t\t}\n\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithHeaders(map[string]string{\n\t\t\t\"Some-Header\": \"foo\",\n\t\t})\n\n\t\treq.WithJSON(map[string]interface{}{\"key\": \"value\"})\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, \"GET\", client.req.Method)\n\t\tassert.Equal(t, \"url\", client.req.URL.String())\n\t\tassert.Equal(t, http.Header(expectedHeaders), client.req.Header)\n\t\tassert.Equal(t, `{\"key\":\"value\"}`, resp.Body().Raw())\n\n\t\tassert.Same(t, &client.resp, resp.Raw())\n\t})\n\n\tt.Run(\"marshal error\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\treq.WithJSON(func() {})\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\tassert.Nil(t, resp.Raw())\n\t})\n}\n\nfunc TestRequest_ContentLength(t *testing.T) {\n\tclient := &mockClient{}\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"chunked\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithChunked(bytes.NewReader([]byte(\"12345\")))\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, int64(-1), client.req.ContentLength)\n\t})\n\n\tt.Run(\"bytes\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithBytes([]byte(\"12345\"))\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, int64(5), client.req.ContentLength)\n\t})\n\n\tt.Run(\"text\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithText(\"12345\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, int64(5), client.req.ContentLength)\n\t})\n\n\tt.Run(\"json\", func(t *testing.T) {\n\t\tj, _ := json.Marshal(map[string]string{\"a\": \"b\"})\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithJSON(map[string]string{\"a\": \"b\"})\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, int64(len(j)), client.req.ContentLength)\n\t})\n\n\tt.Run(\"form\", func(t *testing.T) {\n\t\tf := `a=b`\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithForm(map[string]string{\"a\": \"b\"})\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, int64(len(f)), client.req.ContentLength)\n\t})\n\n\tt.Run(\"form field\", func(t *testing.T) {\n\t\tf := `a=b`\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithFormField(\"a\", \"b\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, int64(len(f)), client.req.ContentLength)\n\t})\n\n\tt.Run(\"multipart\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithMultipart()\n\t\treq.WithFileBytes(\"a\", \"b\", []byte(\"12345\"))\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.True(t, client.req.ContentLength > 0)\n\t})\n}\n\nfunc TestRequest_ContentType(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"WithText sets Content-Type header\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithText(\"hello\")\n\t\treq.WithHeader(\"Content-Type\", \"foo\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, http.Header{\"Content-Type\": {\"foo\"}}, client.req.Header)\n\t})\n\n\tt.Run(\"WithHeader sets Content-Type header\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithHeader(\"Content-Type\", \"foo\")\n\t\treq.WithText(\"hello\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, http.Header{\"Content-Type\": {\"foo\"}}, client.req.Header)\n\t})\n\n\tt.Run(\"WithJSON overrides Content-Type header\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithJSON(map[string]interface{}{\"a\": \"b\"})\n\t\treq.WithHeader(\"Content-Type\", \"foo\")\n\t\treq.WithHeader(\"Content-Type\", \"bar\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, http.Header{\"Content-Type\": {\"foo\", \"bar\"}}, client.req.Header)\n\t})\n\n\tt.Run(\"WithForm overrides Content-Type header\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithForm(map[string]interface{}{\"a\": \"b\"})\n\t\treq.WithHeader(\"Content-Type\", \"foo\")\n\t\treq.WithHeader(\"Content-Type\", \"bar\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, http.Header{\"Content-Type\": {\"foo\", \"bar\"}}, client.req.Header)\n\t})\n\n\tt.Run(\"WithMultipart overrides Content-Type header\", func(t *testing.T) {\n\t\treq := NewRequestC(config, \"GET\", \"url\")\n\t\treq.WithMultipart()\n\t\treq.WithForm(map[string]interface{}{\"a\": \"b\"})\n\t\treq.WithHeader(\"Content-Type\", \"foo\")\n\t\treq.WithHeader(\"Content-Type\", \"bar\")\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, http.Header{\"Content-Type\": {\"foo\", \"bar\"}}, client.req.Header)\n\t})\n}\n\nfunc TestRequest_Websocket(t *testing.T) {\n\tt.Run(\"ws successful\", func(t *testing.T) {\n\t\tscheme := \"\"\n\t\tdialer := WebsocketDialerFunc(func(\n\t\t\turl string, _ http.Header,\n\t\t) (*websocket.Conn, *http.Response, error) {\n\t\t\tu, _ := neturl.Parse(url)\n\t\t\tscheme = u.Scheme\n\t\t\treturn &websocket.Conn{}, &http.Response{}, nil\n\t\t})\n\t\tconfig := Config{\n\t\t\tReporter:        newMockReporter(t),\n\t\t\tWebsocketDialer: dialer,\n\t\t\tBaseURL:         \"http://example.com\",\n\t\t}\n\t\treq := NewRequestC(config, \"GET\", \"url\").WithWebsocketUpgrade()\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, \"ws\", scheme)\n\t})\n\n\tt.Run(\"wss successful\", func(t *testing.T) {\n\t\tscheme := \"\"\n\t\tdialer := WebsocketDialerFunc(func(\n\t\t\turl string, _ http.Header,\n\t\t) (*websocket.Conn, *http.Response, error) {\n\t\t\tu, _ := neturl.Parse(url)\n\t\t\tscheme = u.Scheme\n\t\t\treturn &websocket.Conn{}, &http.Response{}, nil\n\t\t})\n\t\tconfig := Config{\n\t\t\tReporter:        newMockReporter(t),\n\t\t\tWebsocketDialer: dialer,\n\t\t\tBaseURL:         \"https://example.com\",\n\t\t}\n\t\treq := NewRequestC(config, \"GET\", \"url\").WithWebsocketUpgrade()\n\t\treq.Expect().chain.assert(t, success)\n\t\tassert.Equal(t, \"wss\", scheme)\n\t})\n\n\tt.Run(\"bad handshake\", func(t *testing.T) {\n\t\tdialer := WebsocketDialerFunc(func(\n\t\t\t_ string, _ http.Header,\n\t\t) (*websocket.Conn, *http.Response, error) {\n\t\t\treturn &websocket.Conn{}, &http.Response{}, websocket.ErrBadHandshake\n\t\t})\n\t\tconfig := Config{\n\t\t\tReporter:        newMockReporter(t),\n\t\t\tWebsocketDialer: dialer,\n\t\t}\n\t\treq := NewRequestC(config, \"GET\", \"url\").WithWebsocketUpgrade()\n\t\treq.Expect().chain.assert(t, success)\n\t})\n\n\tt.Run(\"custom error\", func(t *testing.T) {\n\t\tdialer := WebsocketDialerFunc(func(\n\t\t\t_ string, _ http.Header,\n\t\t) (*websocket.Conn, *http.Response, error) {\n\t\t\treturn &websocket.Conn{}, &http.Response{}, errors.New(\"custom error\")\n\t\t})\n\t\tconfig := Config{\n\t\t\tReporter:        newMockReporter(t),\n\t\t\tWebsocketDialer: dialer,\n\t\t}\n\t\treq := NewRequestC(config, \"GET\", \"url\").WithWebsocketUpgrade()\n\t\treq.Expect().chain.assert(t, failure)\n\t})\n\n\tt.Run(\"request body not allowed\", func(t *testing.T) {\n\t\tdialer := WebsocketDialerFunc(func(\n\t\t\t_ string, _ http.Header,\n\t\t) (*websocket.Conn, *http.Response, error) {\n\t\t\treturn &websocket.Conn{}, &http.Response{}, nil\n\t\t})\n\t\tconfig := Config{\n\t\t\tReporter:        newMockReporter(t),\n\t\t\tWebsocketDialer: dialer,\n\t\t}\n\t\treq := NewRequestC(config, \"GET\", \"url\").\n\t\t\tWithJSON(\"\").\n\t\t\tWithWebsocketUpgrade()\n\t\treq.Expect().chain.assert(t, failure)\n\t})\n}\n\nfunc TestRequest_RedirectsDontFollow(t *testing.T) {\n\tt.Run(\"no body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tassert.Equal(t, http.NoBody, r.Body)\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(DontFollowRedirects)\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return redirection response\n\t\tresp := req.Expect().\n\t\t\tStatus(tp.redirectHTTPStatusCode).\n\t\t\tHeader(\"Location\").\n\t\t\tIsEqual(\"/redirect\")\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Equal(t, http.ErrUseLastResponse, httpClient.CheckRedirect(req.httpReq, nil))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 1, tp.tripCount)\n\t})\n\n\tt.Run(\"has body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(DontFollowRedirects).\n\t\t\tWithText(\"test body\")\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return redirection response\n\t\tresp := req.Expect().\n\t\t\tStatus(tp.redirectHTTPStatusCode).\n\t\t\tHeader(\"Location\").\n\t\t\tIsEqual(\"/redirect\")\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Equal(t, http.ErrUseLastResponse, httpClient.CheckRedirect(req.httpReq, nil))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 1, tp.tripCount)\n\t})\n}\n\nfunc TestRequest_RedirectsFollowAll(t *testing.T) {\n\tt.Run(\"no body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.maxRedirects = 1\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tassert.Equal(t, http.NoBody, r.Body)\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowAllRedirects).\n\t\t\tWithMaxRedirects(1)\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return OK response\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusOK)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tgb, err := req.httpReq.GetBody()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, http.NoBody, gb)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n\n\tt.Run(\"no body, too many redirects\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tassert.Equal(t, http.NoBody, r.Body)\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowAllRedirects).\n\t\t\tWithMaxRedirects(1)\n\t\treq.chain.assert(t, success)\n\n\t\t// Should error\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should set GetBody\n\t\tgb, err := req.httpReq.GetBody()\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, http.NoBody, gb)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n\n\tt.Run(\"has body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.maxRedirects = 1\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowAllRedirects).\n\t\t\tWithMaxRedirects(1).\n\t\t\tWithText(\"test body\")\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return OK response\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusOK)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tgb, err := req.httpReq.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err := io.ReadAll(gb)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test body\", string(b))\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n\n\tt.Run(\"has body, too many redirects\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowAllRedirects).\n\t\t\tWithMaxRedirects(1).\n\t\t\tWithText(\"test body\")\n\t\treq.chain.assert(t, success)\n\n\t\t// Should error\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should set GetBody\n\t\tgb, err := req.httpReq.GetBody()\n\t\tassert.NoError(t, err)\n\t\tb, err := io.ReadAll(gb)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test body\", string(b))\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n}\n\nfunc TestRequest_RedirectsFollowWithoutBody(t *testing.T) {\n\tt.Run(\"no body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.maxRedirects = 1\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tassert.Contains(t, []interface{}{nil, http.NoBody}, r.Body)\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowRedirectsWithoutBody).\n\t\t\tWithMaxRedirects(1)\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return OK response\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusOK)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n\n\tt.Run(\"no body, too many redirects\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tassert.Contains(t, []interface{}{nil, http.NoBody}, r.Body)\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowRedirectsWithoutBody).\n\t\t\tWithMaxRedirects(1)\n\t\treq.chain.assert(t, success)\n\n\t\t// Should error\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n\n\tt.Run(\"has body, status permanent redirect\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.maxRedirects = 1\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowRedirectsWithoutBody).\n\t\t\tWithMaxRedirects(1).\n\t\t\tWithText(\"test body\")\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return redirection response\n\t\tresp := req.Expect().\n\t\t\tStatus(tp.redirectHTTPStatusCode)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 1, tp.tripCount)\n\t})\n\n\tt.Run(\"has body, status moved permanently\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.maxRedirects = 1\n\t\ttp.redirectHTTPStatusCode = http.StatusMovedPermanently\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tif r.URL.String() == \"/url\" {\n\t\t\t\tassert.Equal(t, r.Method, http.MethodPut)\n\n\t\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t} else if r.URL.String() == \"/redirect\" {\n\t\t\t\tassert.Equal(t, r.Method, http.MethodGet)\n\t\t\t\tassert.Nil(t, r.Body)\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"invalid request URL\")\n\t\t\t}\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowRedirectsWithoutBody).\n\t\t\tWithMaxRedirects(1).\n\t\t\tWithText(\"test body\")\n\t\treq.chain.assert(t, success)\n\n\t\t// Should return OK response\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusOK)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n\n\tt.Run(\"has body, status moved permanently, too many redirects\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttp := newMockRedirectTransport()\n\t\ttp.redirectHTTPStatusCode = http.StatusMovedPermanently\n\t\ttp.assertFn = func(r *http.Request) {\n\t\t\tif r.URL.String() == \"/url\" {\n\t\t\t\tassert.Equal(t, r.Method, http.MethodPut)\n\n\t\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t} else if r.URL.String() == \"/redirect\" {\n\t\t\t\tassert.Equal(t, r.Method, http.MethodGet)\n\t\t\t\tassert.Nil(t, r.Body)\n\t\t\t} else {\n\t\t\t\tt.Fatalf(\"invalid request URL\")\n\t\t\t}\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   &http.Client{Transport: tp},\n\t\t\tReporter: reporter,\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPut, \"/url\").\n\t\t\tWithRedirectPolicy(FollowRedirectsWithoutBody).\n\t\t\tWithMaxRedirects(1).\n\t\t\tWithText(\"test body\")\n\t\treq.chain.assert(t, success)\n\n\t\t// Should error\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should set GetBody\n\t\tassert.Nil(t, req.httpReq.GetBody)\n\n\t\t// Should set CheckRedirect\n\t\thttpClient, _ := req.config.Client.(*http.Client)\n\t\tassert.NotNil(t, httpClient.CheckRedirect)\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, nil))\n\t\tassert.Nil(t, httpClient.CheckRedirect(req.httpReq, make([]*http.Request, 1)))\n\t\tassert.Equal(t,\n\t\t\terrors.New(\"stopped after 1 redirects\"),\n\t\t\thttpClient.CheckRedirect(req.httpReq, make([]*http.Request, 2)))\n\n\t\t// Should do round trip\n\t\tassert.Equal(t, 2, tp.tripCount)\n\t})\n}\n\nfunc TestRequest_RetriesDisabled(t *testing.T) {\n\tt.Run(\"no error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(DontRetry)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"timeout error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\terr: &mockNetError{\n\t\t\t\tisTimeout: true,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(DontRetry).\n\t\t\tWithMaxRetries(1)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"server error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(DontRetry).\n\t\t\tWithMaxRetries(1)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusInternalServerError)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"http error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(DontRetry).\n\t\t\tWithMaxRetries(1)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusBadRequest)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n}\n\nfunc TestRequest_RetriesTimeout(t *testing.T) {\n\tt.Run(\"no error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutErrors)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"timeout error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\terr: &mockNetError{\n\t\t\t\tisTimeout: true,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutErrors).\n\t\t\tWithMaxRetries(1).\n\t\t\tWithRetryDelay(0, 0)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should retry\n\t\tassert.Equal(t, 2, callCount)\n\t})\n\n\tt.Run(\"server error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutErrors).\n\t\t\tWithMaxRetries(1)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusInternalServerError)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"http error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutErrors).\n\t\t\tWithMaxRetries(1)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusBadRequest)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n}\n\nfunc TestRequest_RetriesTimeoutAndServer(t *testing.T) {\n\tt.Run(\"no error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutAndServerErrors)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"timeout error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\terr: &mockNetError{\n\t\t\t\tisTimeout: true,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutAndServerErrors).\n\t\t\tWithMaxRetries(1).\n\t\t\tWithRetryDelay(0, 0)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should retry\n\t\tassert.Equal(t, 2, callCount)\n\t})\n\n\tt.Run(\"server error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutAndServerErrors).\n\t\t\tWithMaxRetries(1).\n\t\t\tWithRetryDelay(0, 0)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusInternalServerError)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should retry\n\t\tassert.Equal(t, 2, callCount)\n\t})\n\n\tt.Run(\"http error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryTimeoutAndServerErrors).\n\t\t\tWithMaxRetries(1)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusBadRequest)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n}\n\nfunc TestRequest_RetriesAll(t *testing.T) {\n\tt.Run(\"no error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryAllErrors)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should not retry\n\t\tassert.Equal(t, 1, callCount)\n\t})\n\n\tt.Run(\"timeout error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\terr: &mockNetError{\n\t\t\t\tisTimeout: true,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryAllErrors).\n\t\t\tWithMaxRetries(1).\n\t\t\tWithRetryDelay(0, 0)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect()\n\t\tresp.chain.assert(t, failure)\n\n\t\t// Should retry\n\t\tassert.Equal(t, 2, callCount)\n\t})\n\n\tt.Run(\"server error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusInternalServerError,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryAllErrors).\n\t\t\tWithMaxRetries(1).\n\t\t\tWithRetryDelay(0, 0)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusInternalServerError)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should retry\n\t\tassert.Equal(t, 2, callCount)\n\t})\n\n\tt.Run(\"http error\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryAllErrors).\n\t\t\tWithMaxRetries(1).\n\t\t\tWithRetryDelay(0, 0)\n\t\treq.sleepFn = mockSleep\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusBadRequest)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should retry\n\t\tassert.Equal(t, 2, callCount)\n\t})\n}\n\nfunc TestRequest_RetriesLimit(t *testing.T) {\n\tcallCount := 0\n\n\tclient := &mockClient{\n\t\tresp: http.Response{\n\t\t\tStatusCode: http.StatusBadRequest,\n\t\t},\n\t\tcb: func(req *http.Request) {\n\t\t\tcallCount++\n\n\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t},\n\t}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\tWithText(\"test body\").\n\t\tWithRetryPolicy(RetryAllErrors).\n\t\tWithMaxRetries(3).\n\t\tWithRetryDelay(0, 0)\n\treq.sleepFn = mockSleep\n\treq.chain.assert(t, success)\n\n\tresp := req.Expect().\n\t\tStatus(http.StatusBadRequest)\n\tresp.chain.assert(t, success)\n\n\t// Should retry until max retries is reached\n\tassert.Equal(t, 1+3, callCount)\n}\n\nfunc TestRequest_RetriesDelay(t *testing.T) {\n\tt.Run(\"not exceeded\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\tvar totalSleepTime time.Duration\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryAllErrors).\n\t\t\tWithMaxRetries(3).\n\t\t\tWithRetryDelay(100*time.Millisecond, 1000*time.Millisecond)\n\t\treq.sleepFn = func(d time.Duration) <-chan time.Time {\n\t\t\ttotalSleepTime += d\n\t\t\treturn time.After(0)\n\t\t}\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusBadRequest)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should retry with delay\n\t\tassert.Equal(t, int64(100+200+400), totalSleepTime.Milliseconds())\n\t})\n\n\tt.Run(\"exceeded\", func(t *testing.T) {\n\t\tcallCount := 0\n\n\t\tclient := &mockClient{\n\t\t\tresp: http.Response{\n\t\t\t\tStatusCode: http.StatusBadRequest,\n\t\t\t},\n\t\t\tcb: func(req *http.Request) {\n\t\t\t\tcallCount++\n\n\t\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t\t},\n\t\t}\n\n\t\tconfig := Config{\n\t\t\tClient:   client,\n\t\t\tReporter: newMockReporter(t),\n\t\t}\n\n\t\tvar totalSleepTime time.Duration\n\n\t\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\t\tWithText(\"test body\").\n\t\t\tWithRetryPolicy(RetryAllErrors).\n\t\t\tWithMaxRetries(3).\n\t\t\tWithRetryDelay(100*time.Millisecond, 300*time.Millisecond)\n\t\treq.sleepFn = func(d time.Duration) <-chan time.Time {\n\t\t\ttotalSleepTime += d\n\t\t\treturn time.After(0)\n\t\t}\n\n\t\treq.chain.assert(t, success)\n\n\t\tresp := req.Expect().\n\t\t\tStatus(http.StatusBadRequest)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Should retry with delay\n\t\tassert.Equal(t, int64(100+200+300), totalSleepTime.Milliseconds())\n\t})\n}\n\nfunc TestRequest_RetriesCancellation(t *testing.T) {\n\tcallCount := 0\n\n\tclient := &mockClient{\n\t\tresp: http.Response{\n\t\t\tStatusCode: http.StatusBadRequest,\n\t\t},\n\t\tcb: func(req *http.Request) {\n\t\t\tcallCount++\n\n\t\t\tassert.Error(t, req.Context().Err(), context.Canceled.Error())\n\n\t\t\tb, err := io.ReadAll(req.Body)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"test body\", string(b))\n\t\t},\n\t}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel() // Cancel immediately to trigger error\n\n\treq := NewRequestC(config, http.MethodPost, \"/url\").\n\t\tWithText(\"test body\").\n\t\tWithRetryPolicy(RetryAllErrors).\n\t\tWithMaxRetries(1).\n\t\tWithContext(ctx).\n\t\tWithRetryDelay(1*time.Minute, 5*time.Minute)\n\treq.chain.assert(t, success)\n\n\tresp := req.Expect()\n\tresp.chain.assert(t, failure)\n\n\t// Should not retry\n\tassert.Equal(t, 1, callCount)\n}\n\nfunc TestRequest_Conflicts(t *testing.T) {\n\tclient := &mockClient{}\n\n\tconfig := Config{\n\t\tClient:   client,\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"body conflict\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname string\n\t\t\tfn   func(req *Request)\n\t\t}{\n\t\t\t{\"WithChunked\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithChunked(strings.NewReader(\"test\"))\n\t\t\t\t}},\n\t\t\t{\"WithBytes\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithBytes([]byte(\"test\"))\n\t\t\t\t}},\n\t\t\t{\"WithText\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithText(\"test\")\n\t\t\t\t}},\n\t\t\t{\"WithJSON\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithJSON(map[string]interface{}{\"a\": \"b\"})\n\t\t\t\t}},\n\t\t\t{\"WithForm\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithForm(map[string]interface{}{\"a\": \"b\"})\n\t\t\t\t}},\n\t\t\t{\"WithFormField\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithFormField(\"a\", \"b\")\n\t\t\t\t}},\n\t\t\t{\"WithMultipart\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithMultipart()\n\t\t\t\t}},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\t\t\treq.WithChunked(strings.NewReader(\"test\"))\n\t\t\t\treq.chain.assert(t, success)\n\n\t\t\t\ttc.fn(req)\n\t\t\t\tresp := req.Expect()\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t})\n\n\t\t\tt.Run(tc.name+\" - reversed\", func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\t\t\ttc.fn(req)\n\t\t\t\treq.chain.assert(t, success)\n\n\t\t\t\treq.WithChunked(strings.NewReader(\"test\"))\n\t\t\t\tresp := req.Expect()\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"type conflict\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname string\n\t\t\tfn   func(req *Request)\n\t\t}{\n\t\t\t{\"WithJSON\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithJSON(map[string]interface{}{\"a\": \"b\"})\n\t\t\t\t}},\n\t\t\t{\"WithForm\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithForm(map[string]interface{}{\"a\": \"b\"})\n\t\t\t\t}},\n\t\t\t{\"WithFormField\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithFormField(\"a\", \"b\")\n\t\t\t\t}},\n\t\t\t{\"WithMultipart\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithMultipart()\n\t\t\t\t}},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\t\t\treq.WithText(\"test\")\n\t\t\t\treq.chain.assert(t, success)\n\n\t\t\t\ttc.fn(req)\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t})\n\n\t\t\tt.Run(tc.name+\" - reversed\", func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\t\t\ttc.fn(req)\n\t\t\t\treq.chain.assert(t, success)\n\n\t\t\t\treq.WithText(\"test\")\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"multipart conflict\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname string\n\t\t\tfn   func(req *Request)\n\t\t}{\n\t\t\t{\"WithForm\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithForm(map[string]interface{}{\"a\": \"b\"})\n\t\t\t\t}},\n\t\t\t{\"WithFormField\",\n\t\t\t\tfunc(req *Request) {\n\t\t\t\t\treq.WithFormField(\"a\", \"b\")\n\t\t\t\t}},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treq := NewRequestC(config, \"GET\", \"url\")\n\n\t\t\t\ttc.fn(req)\n\t\t\t\treq.chain.assert(t, success)\n\n\t\t\t\treq.WithMultipart()\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestRequest_Usage(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\tclient      Client\n\t\tprepFunc    func(req *Request)\n\t\tprepFails   bool\n\t\texpectFails bool\n\t}{\n\t\t{\n\t\t\tname: \"WithReporter - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithReporter(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithAssertionHandler - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithAssertionHandler(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithMatcher - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithMatcher(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithTransformer - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithTransformer(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithClient - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithClient(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithHandler - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithHandler(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithContext - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithContext(nil) //nolint\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithMaxRedirects - negative argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithMaxRedirects(-1)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithMaxRetries - negative argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithMaxRetries(-1)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithRetryDelay - invalid range\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithRetryDelay(10, 5)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithWebsocketDialer - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithWebsocketDialer(nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithPath - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithPath(\"test-key\", nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithQuery - nil argument\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithQuery(\"test-query\", nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithURL - invalid url\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithURL(\"%-invalid-url\")\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname: \"WithFile - multiple readers\",\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithFile(\"test-key\", \"test-path\", nil, nil)\n\t\t\t},\n\t\t\tprepFails:   true,\n\t\t\texpectFails: true,\n\t\t},\n\t\t// WithRedirectPolicy and WithMaxRedirects require Client\n\t\t// to be http.Client, but we use another one\n\t\t{\n\t\t\tname:   \"WithRedirectPolicy - incompatible client\",\n\t\t\tclient: &mockClient{},\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithRedirectPolicy(FollowAllRedirects)\n\t\t\t},\n\t\t\tprepFails:   false,\n\t\t\texpectFails: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"WithMaxRedirects - incompatible client\",\n\t\t\tclient: &mockClient{},\n\t\t\tprepFunc: func(req *Request) {\n\t\t\t\treq.WithMaxRedirects(1)\n\t\t\t},\n\t\t\tprepFails:   false,\n\t\t\texpectFails: true,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconfig := Config{\n\t\t\t\tClient:   tc.client,\n\t\t\t\tReporter: newMockReporter(t),\n\t\t\t}\n\n\t\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\t\ttc.prepFunc(req)\n\n\t\t\tif tc.prepFails {\n\t\t\t\treq.chain.assert(t, failure)\n\t\t\t} else {\n\t\t\t\treq.chain.assert(t, success)\n\n\t\t\t\tresp := req.Expect()\n\n\t\t\t\tif tc.expectFails {\n\t\t\t\t\treq.chain.assert(t, failure)\n\t\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t\t} else {\n\t\t\t\t\treq.chain.assert(t, success)\n\t\t\t\t\tresp.chain.assert(t, success)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRequest_Order(t *testing.T) {\n\tcases := []struct {\n\t\tname       string\n\t\tbeforeFunc func(req *Request)\n\t\tafterFunc  func(req *Request)\n\t}{\n\t\t{\n\t\t\tname: \"Expect after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.Expect()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithName after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithName(\"Test\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithReporter after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithReporter(newMockReporter(t))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithAssertionHandler after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithAssertionHandler(&mockAssertionHandler{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithMatcher after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithMatcher(func(*Response) {\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithTransformer after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithTransformer(func(*http.Request) {\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithClient after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithClient(&mockClient{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithHandler after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithHandler(http.NotFoundHandler())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithContext after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithContext(context.Background())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithTimeout after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithTimeout(3 * time.Second)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithRedirectPolicy after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithRedirectPolicy(FollowAllRedirects)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithMaxRedirects after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithMaxRedirects(3)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithRetryPolicy after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithRetryPolicy(DontRetry)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithMaxRetries after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithMaxRetries(10)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithRetryDelay after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithRetryDelay(time.Second, 5*time.Second)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithWebsocketUpgrade after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithWebsocketUpgrade()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithWebsocketDialer after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithWebsocketDialer(&websocket.Dialer{})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithPath after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithPath(\"repo\", \"repo1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithPathObject after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithPathObject(map[string]string{\n\t\t\t\t\t\"repo\": \"repo1\",\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithQuery after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithQuery(\"a\", 123)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithQueryObject after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithQueryObject(map[string]string{\n\t\t\t\t\t\"a\": \"val\",\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithQueryString after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithQueryString(\"a=123&b=hello\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithURL after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithURL(\"https://www.github.com\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithHeaders after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithHeaders(map[string]string{\n\t\t\t\t\t\"Content-Type\": \"application/json\",\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithHeader after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithHeader(\"Content-Type\", \"application/json\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithCookies after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithCookies(map[string]string{\n\t\t\t\t\t\"key1\": \"val1\",\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithCookie after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithCookie(\"key1\", \"val1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithBasicAuth after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithBasicAuth(\"user\", \"pass\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithHost after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithHost(\"localhost\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithProto after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithProto(\"HTTP/1.1\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithChunked after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithChunked(bytes.NewReader(nil))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithBytes after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithBytes(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithText after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithText(\"hello\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithJSON after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithJSON(map[string]string{\n\t\t\t\t\t\"key1\": \"val1\",\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithForm after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithForm(map[string]string{\n\t\t\t\t\t\"key1\": \"val1\",\n\t\t\t\t})\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFormField after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithFormField(\"key1\", 123)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFile after Expect\",\n\t\t\tbeforeFunc: func(req *Request) {\n\t\t\t\treq.WithMultipart()\n\t\t\t},\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithFile(\"foo\", \"bar\", strings.NewReader(\"baz\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithFileBytes after Expect\",\n\t\t\tbeforeFunc: func(req *Request) {\n\t\t\t\treq.WithMultipart()\n\t\t\t},\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithFileBytes(\"foo\", \"bar\", []byte(\"baz\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithMultipart after Expect\",\n\t\t\tafterFunc: func(req *Request) {\n\t\t\t\treq.WithMultipart()\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tconfig := Config{\n\t\t\t\tClient:   &mockClient{},\n\t\t\t\tReporter: newMockReporter(t),\n\t\t\t}\n\n\t\t\treq := NewRequestC(config, \"GET\", \"/\")\n\n\t\t\tif tc.beforeFunc != nil {\n\t\t\t\ttc.beforeFunc(req)\n\t\t\t}\n\t\t\treq.chain.assert(t, success)\n\n\t\t\tresp := req.Expect()\n\t\t\treq.chain.assert(t, success)\n\t\t\tresp.chain.assert(t, success)\n\n\t\t\ttc.afterFunc(req)\n\t\t\treq.chain.assert(t, failure)\n\t\t})\n\t}\n}\n\nfunc TestRequest_Panics(t *testing.T) {\n\tt.Run(\"RequestFactory is nil\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tRequestFactory:   nil,\n\t\t\tClient:           &mockClient{},\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t}\n\n\t\tassert.Panics(t, func() { newRequest(newMockChain(t), config, \"GET\", \"\") })\n\t})\n\n\tt.Run(\"Client is nil\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tRequestFactory:   DefaultRequestFactory{},\n\t\t\tClient:           nil,\n\t\t\tAssertionHandler: &mockAssertionHandler{},\n\t\t}\n\n\t\tassert.Panics(t, func() { newRequest(newMockChain(t), config, \"GET\", \"\") })\n\t})\n\n\tt.Run(\"AssertionHandler is nil\", func(t *testing.T) {\n\t\tconfig := Config{\n\t\t\tRequestFactory:   DefaultRequestFactory{},\n\t\t\tClient:           &mockClient{},\n\t\t\tAssertionHandler: nil,\n\t\t}\n\n\t\tassert.Panics(t, func() { newRequest(newMockChain(t), config, \"GET\", \"\") })\n\t})\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 25.3291015625,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/ajg/form\"\n\t\"github.com/gorilla/websocket\"\n)\n\n// Response provides methods to inspect attached http.Response object.\ntype Response struct {\n\tnoCopy noCopy\n\tconfig Config\n\tchain  *chain\n\n\thttpResp  *http.Response\n\twebsocket *websocket.Conn\n\trtt       *time.Duration\n\n\tcontent       []byte\n\tcontentState  contentState\n\tcontentMethod string\n\n\tcookies []*http.Cookie\n}\n\ntype contentState int\n\nconst (\n\t// We didn't try to retrieve response content yet\n\tcontentPending contentState = iota\n\t// We successfully retrieved response content\n\tcontentRetreived\n\t// We tried to retrieve response content and failed\n\tcontentFailed\n\t// We transferred body reader to user and will not use it by ourselves\n\tcontentHijacked\n)\n\n// NewResponse returns a new Response instance.\n//\n// If reporter is nil, the function panics.\n// If response is nil, failure is reported.\n//\n// If rtt is given, it defines response round-trip time to be reported\n// by response.RoundTripTime().\nfunc NewResponse(\n\treporter Reporter, response *http.Response, rtt ...time.Duration,\n) *Response {\n\tconfig := Config{Reporter: reporter}\n\tconfig = config.withDefaults()\n\n\treturn newResponse(responseOpts{\n\t\tconfig:   config,\n\t\tchain:    newChainWithConfig(\"Response()\", config),\n\t\thttpResp: response,\n\t\trtt:      rtt,\n\t})\n}\n\n// NewResponse returns a new Response instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// If response is nil, failure is reported.\n//\n// If rtt is given, it defines response round-trip time to be reported\n// by response.RoundTripTime().\nfunc NewResponseC(\n\tconfig Config, response *http.Response, rtt ...time.Duration,\n) *Response {\n\tconfig = config.withDefaults()\n\n\treturn newResponse(responseOpts{\n\t\tconfig:   config,\n\t\tchain:    newChainWithConfig(\"Response()\", config),\n\t\thttpResp: response,\n\t\trtt:      rtt,\n\t})\n}\n\ntype responseOpts struct {\n\tconfig    Config\n\tchain     *chain\n\thttpResp  *http.Response\n\twebsocket *websocket.Conn\n\trtt       []time.Duration\n}\n\nfunc newResponse(opts responseOpts) *Response {\n\topts.config.validate()\n\n\tr := &Response{\n\t\tconfig:       opts.config,\n\t\tchain:        opts.chain.clone(),\n\t\tcontentState: contentPending,\n\t}\n\n\topChain := r.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\tif len(opts.rtt) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple rtt arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tif len(opts.rtt) > 0 {\n\t\trttCopy := opts.rtt[0]\n\t\tr.rtt = &rttCopy\n\t}\n\n\tif opts.httpResp == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{opts.httpResp},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: non-nil response\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.httpResp = opts.httpResp\n\n\tif r.httpResp.Body != nil && r.httpResp.Body != http.NoBody {\n\t\tif _, ok := r.httpResp.Body.(*bodyWrapper); !ok {\n\t\t\trespCopy := *r.httpResp\n\t\t\tr.httpResp = &respCopy\n\t\t\tr.httpResp.Body = newBodyWrapper(r.httpResp.Body, nil)\n\t\t}\n\t}\n\n\tr.websocket = opts.websocket\n\tr.cookies = r.httpResp.Cookies()\n\n\tr.chain.setResponse(r)\n\n\treturn r\n}\n\nfunc (r *Response) getContent(opChain *chain, method string) ([]byte, bool) {\n\tswitch r.contentState {\n\tcase contentRetreived:\n\t\treturn r.content, true\n\n\tcase contentFailed:\n\t\treturn nil, false\n\n\tcase contentPending:\n\t\tbreak\n\n\tcase contentHijacked:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"cannot call %s because Reader() was already called\", method),\n\t\t\t},\n\t\t})\n\t\treturn nil, false\n\t}\n\n\tresp := r.httpResp\n\n\tif resp.Body == nil || resp.Body == http.NoBody {\n\t\treturn []byte{}, true\n\t}\n\n\tif bw, ok := resp.Body.(*bodyWrapper); ok {\n\t\tbw.Rewind()\n\t}\n\n\tcontent, err := io.ReadAll(resp.Body)\n\n\tcloseErr := resp.Body.Close()\n\tif err == nil {\n\t\terr = closeErr\n\t}\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to read response body\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\n\t\tr.content = nil\n\t\tr.contentState = contentFailed\n\n\t\treturn nil, false\n\t}\n\n\tr.content = content\n\tr.contentState = contentRetreived\n\tr.contentMethod = method\n\n\treturn r.content, true\n}\n\n// Raw returns underlying http.Response object.\n// This is the value originally passed to NewResponse.\nfunc (r *Response) Raw() *http.Response {\n\treturn r.httpResp\n}\n\n// Alias is similar to Value.Alias.\nfunc (r *Response) Alias(name string) *Response {\n\topChain := r.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tr.chain.setAlias(name)\n\treturn r\n}\n\n// RoundTripTime returns a new Duration instance with response round-trip time.\n//\n// The returned duration is the time interval starting just before request is\n// sent and ending right after response is received (handshake finished for\n// WebSocket request), retrieved from a monotonic clock source.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response, time.Duration(10000000))\n//\tresp.RoundTripTime().Lt(10 * time.Millisecond)\nfunc (r *Response) RoundTripTime() *Duration {\n\topChain := r.chain.enter(\"RoundTripTime()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newDuration(opChain, nil)\n\t}\n\n\treturn newDuration(opChain, r.rtt)\n}\n\n// Deprecated: use RoundTripTime instead.\nfunc (r *Response) Duration() *Number {\n\topChain := r.chain.enter(\"Duration()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\tif r.rtt == nil {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\treturn newNumber(opChain, float64(*r.rtt))\n}\n\n// Status succeeds if response contains given status code.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Status(http.StatusOK)\nfunc (r *Response) Status(status int) *Response {\n\topChain := r.chain.enter(\"Status()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tr.checkEqual(opChain, \"http status\",\n\t\tstatusCodeText(status), statusCodeText(r.httpResp.StatusCode))\n\n\treturn r\n}\n\n// StatusRange is enum for response status ranges.\ntype StatusRange int\n\nconst (\n\t// Status1xx defines \"Informational\" status codes.\n\tStatus1xx StatusRange = 100\n\n\t// Status2xx defines \"Success\" status codes.\n\tStatus2xx StatusRange = 200\n\n\t// Status3xx defines \"Redirection\" status codes.\n\tStatus3xx StatusRange = 300\n\n\t// Status4xx defines \"Client Error\" status codes.\n\tStatus4xx StatusRange = 400\n\n\t// Status5xx defines \"Server Error\" status codes.\n\tStatus5xx StatusRange = 500\n)\n\n// StatusRange succeeds if response status belongs to given range.\n//\n// Supported ranges:\n//   - Status1xx - Informational\n//   - Status2xx - Success\n//   - Status3xx - Redirection\n//   - Status4xx - Client Error\n//   - Status5xx - Server Error\n//\n// See https://en.wikipedia.org/wiki/List_of_HTTP_status_codes.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.StatusRange(Status2xx)\nfunc (r *Response) StatusRange(rn StatusRange) *Response {\n\topChain := r.chain.enter(\"StatusRange()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tstatus := statusCodeText(r.httpResp.StatusCode)\n\n\tactual := statusRangeText(r.httpResp.StatusCode)\n\texpected := statusRangeText(int(rn))\n\n\tif actual == \"\" || actual != expected {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertBelongs,\n\t\t\tActual: &AssertionValue{status},\n\t\t\tExpected: &AssertionValue{AssertionList{\n\t\t\t\tstatusRangeText(int(rn)),\n\t\t\t}},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: http status belongs to given range\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn r\n}\n\n// StatusList succeeds if response matches with any given status code list\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.StatusList(http.StatusForbidden, http.StatusUnauthorized)\nfunc (r *Response) StatusList(values ...int) *Response {\n\topChain := r.chain.enter(\"StatusList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty status list\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tvar found bool\n\tfor _, v := range values {\n\t\tif v == r.httpResp.StatusCode {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{statusCodeText(r.httpResp.StatusCode)},\n\t\t\tExpected: &AssertionValue{AssertionList(statusListText(values))},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: http status belongs to given list\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn r\n}\n\nfunc statusCodeText(code int) string {\n\tif s := http.StatusText(code); s != \"\" {\n\t\treturn strconv.Itoa(code) + \" \" + s\n\t}\n\treturn strconv.Itoa(code)\n}\n\nfunc statusRangeText(code int) string {\n\tswitch {\n\tcase code >= 100 && code < 200:\n\t\treturn \"1xx Informational\"\n\tcase code >= 200 && code < 300:\n\t\treturn \"2xx Success\"\n\tcase code >= 300 && code < 400:\n\t\treturn \"3xx Redirection\"\n\tcase code >= 400 && code < 500:\n\t\treturn \"4xx Client Error\"\n\tcase code >= 500 && code < 600:\n\t\treturn \"5xx Server Error\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\nfunc statusListText(values []int) []interface{} {\n\tvar statusText []interface{}\n\tfor _, v := range values {\n\t\tstatusText = append(statusText, statusCodeText(v))\n\t}\n\treturn statusText\n}\n\n// Headers returns a new Object instance with response header map.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Headers().Value(\"Content-Type\").String().IsEqual(\"application-json\")\nfunc (r *Response) Headers() *Object {\n\topChain := r.chain.enter(\"Headers()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tvar value map[string]interface{}\n\tvalue, _ = canonMap(opChain, r.httpResp.Header)\n\n\treturn newObject(opChain, value)\n}\n\n// Header returns a new String instance with given header field.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Header(\"Content-Type\").IsEqual(\"application-json\")\n//\tresp.Header(\"Date\").AsDateTime().Le(time.Now())\nfunc (r *Response) Header(header string) *String {\n\topChain := r.chain.enter(\"Header(%q)\", header)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tvalue := r.httpResp.Header.Get(header)\n\n\treturn newString(opChain, value)\n}\n\n// Cookies returns a new Array instance with all cookie names set by this response.\n// Returned Array contains a String value for every cookie name.\n//\n// Note that this returns only cookies set by Set-Cookie headers of this response.\n// It doesn't return session cookies from previous responses, which may be stored\n// in a cookie jar.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Cookies().Contains(\"session\")\nfunc (r *Response) Cookies() *Array {\n\topChain := r.chain.enter(\"Cookies()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tnames := []interface{}{}\n\tfor _, c := range r.cookies {\n\t\tnames = append(names, c.Name)\n\t}\n\n\treturn newArray(opChain, names)\n}\n\n// Cookie returns a new Cookie instance with specified cookie from response.\n//\n// Note that this returns only cookies set by Set-Cookie headers of this response.\n// It doesn't return session cookies from previous responses, which may be stored\n// in a cookie jar.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Cookie(\"session\").Domain().IsEqual(\"example.com\")\nfunc (r *Response) Cookie(name string) *Cookie {\n\topChain := r.chain.enter(\"Cookie(%q)\", name)\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newCookie(opChain, nil)\n\t}\n\n\tvar cookie *Cookie\n\n\tnames := []string{}\n\tfor _, c := range r.cookies {\n\t\tif c.Name == name {\n\t\t\tcookie = newCookie(opChain, c)\n\t\t\tbreak\n\t\t}\n\t\tnames = append(names, c.Name)\n\t}\n\n\tif cookie == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsElement,\n\t\t\tActual:   &AssertionValue{names},\n\t\t\tExpected: &AssertionValue{name},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: response contains cookie with given name\"),\n\t\t\t},\n\t\t})\n\t\treturn newCookie(opChain, nil)\n\t}\n\n\treturn cookie\n}\n\n// Websocket returns Websocket instance for interaction with WebSocket server.\n//\n// May be called only if the WithWebsocketUpgrade was called on the request.\n// That is responsibility of the caller to explicitly disconnect websocket after use.\n//\n// Example:\n//\n//\treq := NewRequestC(config, \"GET\", \"/path\")\n//\treq.WithWebsocketUpgrade()\n//\tws := req.Expect().Websocket()\n//\tdefer ws.Disconnect()\nfunc (r *Response) Websocket() *Websocket {\n\topChain := r.chain.enter(\"Websocket()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newWebsocket(opChain, r.config, nil)\n\t}\n\n\tif r.websocket == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\n\t\t\t\t\t\"Websocket() requires WithWebsocketUpgrade() to be called on request\"),\n\t\t\t},\n\t\t})\n\t\treturn newWebsocket(opChain, r.config, nil)\n\t}\n\n\treturn newWebsocket(opChain, r.config, r.websocket)\n}\n\n// Reader returns the body reader from the response.\n//\n// This method is mutually exclusive with methods that read entire\n// response body, like Text, Body, JSON, etc. It can be used when\n// you need to parse body manually or retrieve infinite responses.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\treader := resp.Reader()\nfunc (r *Response) Reader() io.ReadCloser {\n\topChain := r.chain.enter(\"Reader()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn errBodyReader{errors.New(\"cannot read from failed Response\")}\n\t}\n\n\tif r.contentState != contentPending {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"cannot call Reader() because %s was already called\",\n\t\t\t\t\tr.contentMethod),\n\t\t\t},\n\t\t})\n\t\treturn errBodyReader{errors.New(\"cannot read from failed Response\")}\n\t}\n\n\tif bw, _ := r.httpResp.Body.(*bodyWrapper); bw != nil {\n\t\tbw.DisableRewinds()\n\t}\n\n\tr.contentState = contentHijacked\n\n\treturn r.httpResp.Body\n}\n\n// Body returns a new String instance with response body.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Body().NotEmpty()\n//\tresp.Body().Length().IsEqual(100)\nfunc (r *Response) Body() *String {\n\topChain := r.chain.enter(\"Body()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tcontent, ok := r.getContent(opChain, \"Body()\")\n\tif !ok {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, string(content))\n}\n\n// NoContent succeeds if response contains empty Content-Type header and\n// empty body.\nfunc (r *Response) NoContent() *Response {\n\topChain := r.chain.enter(\"NoContent()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tcontentType := r.httpResp.Header.Get(\"Content-Type\")\n\tif !r.checkEqual(opChain, `\"Content-Type\" header`, \"\", contentType) {\n\t\treturn r\n\t}\n\n\tcontent, ok := r.getContent(opChain, \"NoContent()\")\n\tif !ok {\n\t\treturn r\n\t}\n\tif !r.checkEqual(opChain, \"body\", \"\", string(content)) {\n\t\treturn r\n\t}\n\n\treturn r\n}\n\n// HasContentType succeeds if response contains Content-Type header with given\n// media type and charset.\n//\n// If charset is omitted, and mediaType is non-empty, Content-Type header\n// should contain empty or utf-8 charset.\n//\n// If charset is omitted, and mediaType is also empty, Content-Type header\n// should contain no charset.\nfunc (r *Response) HasContentType(mediaType string, charset ...string) *Response {\n\topChain := r.chain.enter(\"HasContentType()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tif len(charset) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple charset arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn r\n\t}\n\n\tr.checkContentType(opChain, mediaType, charset...)\n\n\treturn r\n}\n\n// HasContentEncoding succeeds if response has exactly given Content-Encoding list.\n// Common values are empty, \"gzip\", \"compress\", \"deflate\", \"identity\" and \"br\".\nfunc (r *Response) HasContentEncoding(encoding ...string) *Response {\n\topChain := r.chain.enter(\"HasContentEncoding()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tr.checkEqual(opChain, `\"Content-Encoding\" header`,\n\t\tencoding,\n\t\tr.httpResp.Header[\"Content-Encoding\"])\n\n\treturn r\n}\n\n// HasTransferEncoding succeeds if response contains given Transfer-Encoding list.\n// Common values are empty, \"chunked\" and \"identity\".\nfunc (r *Response) HasTransferEncoding(encoding ...string) *Response {\n\topChain := r.chain.enter(\"HasTransferEncoding()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn r\n\t}\n\n\tr.checkEqual(opChain, `\"Transfer-Encoding\" header`,\n\t\tencoding,\n\t\tr.httpResp.TransferEncoding)\n\n\treturn r\n}\n\n// Deprecated: use HasContentType instead.\nfunc (r *Response) ContentType(mediaType string, charset ...string) *Response {\n\treturn r.HasContentType(mediaType, charset...)\n}\n\n// Deprecated: use HasContentEncoding instead.\nfunc (r *Response) ContentEncoding(encoding ...string) *Response {\n\treturn r.HasContentEncoding(encoding...)\n}\n\n// Deprecated: use HasTransferEncoding instead.\nfunc (r *Response) TransferEncoding(encoding ...string) *Response {\n\treturn r.HasTransferEncoding(encoding...)\n}\n\n// ContentOpts define parameters for matching the response content parameters.\ntype ContentOpts struct {\n\t// The media type Content-Type part, e.g. \"application/json\"\n\tMediaType string\n\t// The character set Content-Type part, e.g. \"utf-8\"\n\tCharset string\n}\n\n// Text returns a new String instance with response body.\n//\n// Text succeeds if response contains \"text/plain\" Content-Type header\n// with empty or \"utf-8\" charset.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Text().IsEqual(\"hello, world!\")\n//\tresp.Text(ContentOpts{\n//\t  MediaType: \"text/plain\",\n//\t}).IsEqual(\"hello, world!\")\nfunc (r *Response) Text(options ...ContentOpts) *String {\n\topChain := r.chain.enter(\"Text()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tif len(options) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple options arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tif !r.checkContentOptions(opChain, options, \"text/plain\") {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tcontent, ok := r.getContent(opChain, \"Text()\")\n\tif !ok {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, string(content))\n}\n\n// Form returns a new Object instance with form decoded from response body.\n//\n// Form succeeds if response contains \"application/x-www-form-urlencoded\"\n// Content-Type header and if form may be decoded from response body.\n// Decoding is performed using https://github.com/ajg/form.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.Form().Value(\"foo\").IsEqual(\"bar\")\n//\tresp.Form(ContentOpts{\n//\t  MediaType: \"application/x-www-form-urlencoded\",\n//\t}).Value(\"foo\").IsEqual(\"bar\")\nfunc (r *Response) Form(options ...ContentOpts) *Object {\n\topChain := r.chain.enter(\"Form()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tif len(options) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple options arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tobject := r.getForm(opChain, \"Form()\", options...)\n\n\treturn newObject(opChain, object)\n}\n\nfunc (r *Response) getForm(\n\topChain *chain, method string, options ...ContentOpts,\n) map[string]interface{} {\n\tif !r.checkContentOptions(opChain, options, \"application/x-www-form-urlencoded\", \"\") {\n\t\treturn nil\n\t}\n\n\tcontent, ok := r.getContent(opChain, method)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tdecoder := form.NewDecoder(bytes.NewReader(content))\n\n\tvar object map[string]interface{}\n\n\tif err := decoder.Decode(&object); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertValid,\n\t\t\tActual: &AssertionValue{\n\t\t\t\tstring(content),\n\t\t\t},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to decode form\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil\n\t}\n\n\treturn object\n}\n\n// JSON returns a new Value instance with JSON decoded from response body.\n//\n// JSON succeeds if response contains \"application/json\" Content-Type header\n// with empty or \"utf-8\" charset and if JSON may be decoded from response body.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.JSON().Array().ConsistsOf(\"foo\", \"bar\")\n//\tresp.JSON(ContentOpts{\n//\t  MediaType: \"application/json\",\n//\t}).Array.ConsistsOf(\"foo\", \"bar\")\nfunc (r *Response) JSON(options ...ContentOpts) *Value {\n\topChain := r.chain.enter(\"JSON()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif len(options) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple options arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tvalue := r.getJSON(opChain, \"JSON()\", options...)\n\n\treturn newValue(opChain, value)\n}\n\nfunc (r *Response) getJSON(\n\topChain *chain, method string, options ...ContentOpts,\n) interface{} {\n\tif !r.checkContentOptions(opChain, options, \"application/json\") {\n\t\treturn nil\n\t}\n\n\tcontent, ok := r.getContent(opChain, method)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tvar value interface{}\n\n\tif err := json.Unmarshal(content, &value); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertValid,\n\t\t\tActual: &AssertionValue{\n\t\t\t\tstring(content),\n\t\t\t},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to decode json\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil\n\t}\n\n\treturn value\n}\n\n// JSONP returns a new Value instance with JSONP decoded from response body.\n//\n// JSONP succeeds if response contains \"application/javascript\" Content-Type\n// header with empty or \"utf-8\" charset and response body of the following form:\n//\n//\tcallback(<valid json>);\n//\n// or:\n//\n//\tcallback(<valid json>)\n//\n// Whitespaces are allowed.\n//\n// Example:\n//\n//\tresp := NewResponse(t, response)\n//\tresp.JSONP(\"myCallback\").Array().ConsistsOf(\"foo\", \"bar\")\n//\tresp.JSONP(\"myCallback\", ContentOpts{\n//\t  MediaType: \"application/javascript\",\n//\t}).Array().ConsistsOf(\"foo\", \"bar\")\nfunc (r *Response) JSONP(callback string, options ...ContentOpts) *Value {\n\topChain := r.chain.enter(\"JSONP()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tif len(options) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple options arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tvalue := r.getJSONP(opChain, \"JSONP()\", callback, options...)\n\n\treturn newValue(opChain, value)\n}\n\nvar (\n\tjsonp = regexp.MustCompile(`^\\s*([^\\s(]+)\\s*\\((.*)\\)\\s*;*\\s*$`)\n)\n\nfunc (r *Response) getJSONP(\n\topChain *chain, method string, callback string, options ...ContentOpts,\n) interface{} {\n\tif !r.checkContentOptions(opChain, options, \"application/javascript\") {\n\t\treturn nil\n\t}\n\n\tcontent, ok := r.getContent(opChain, method)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tm := jsonp.FindSubmatch(content)\n\n\tif len(m) != 3 || string(m[1]) != callback {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertValid,\n\t\t\tActual: &AssertionValue{\n\t\t\t\tstring(content),\n\t\t\t},\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(`expected: JSONP body in form of \"%s(<valid json>)\"`,\n\t\t\t\t\tcallback),\n\t\t\t},\n\t\t})\n\t\treturn nil\n\t}\n\n\tvar value interface{}\n\n\tif err := json.Unmarshal(m[2], &value); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertValid,\n\t\t\tActual: &AssertionValue{\n\t\t\t\tstring(content),\n\t\t\t},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to decode json\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn nil\n\t}\n\n\treturn value\n}\n\nfunc (r *Response) checkContentOptions(\n\topChain *chain, options []ContentOpts, expectedType string, expectedCharset ...string,\n) bool {\n\tif len(options) != 0 {\n\t\tif options[0].MediaType != \"\" {\n\t\t\texpectedType = options[0].MediaType\n\t\t}\n\t\tif options[0].Charset != \"\" {\n\t\t\texpectedCharset = []string{options[0].Charset}\n\t\t}\n\t}\n\treturn r.checkContentType(opChain, expectedType, expectedCharset...)\n}\n\nfunc (r *Response) checkContentType(\n\topChain *chain, expectedType string, expectedCharset ...string,\n) bool {\n\tcontentType := r.httpResp.Header.Get(\"Content-Type\")\n\n\tif expectedType == \"\" && len(expectedCharset) == 0 {\n\t\tif contentType == \"\" {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tmediaType, params, err := mime.ParseMediaType(contentType)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{contentType},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(`invalid \"Content-Type\" response header`),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\tif mediaType != expectedType {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{mediaType},\n\t\t\tExpected: &AssertionValue{expectedType},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(`unexpected media type in \"Content-Type\" response header`),\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\tcharset := params[\"charset\"]\n\n\tif len(expectedCharset) == 0 {\n\t\tif charset != \"\" && !strings.EqualFold(charset, \"utf-8\") {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertBelongs,\n\t\t\t\tActual:   &AssertionValue{charset},\n\t\t\t\tExpected: &AssertionValue{AssertionList{\"\", \"utf-8\"}},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(`unexpected charset in \"Content-Type\" response header`),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn false\n\t\t}\n\t} else {\n\t\tif !strings.EqualFold(charset, expectedCharset[0]) {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertEqual,\n\t\t\t\tActual:   &AssertionValue{charset},\n\t\t\t\tExpected: &AssertionValue{expectedCharset[0]},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(`unexpected charset in \"Content-Type\" response header`),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (r *Response) checkEqual(\n\topChain *chain, what string, expected, actual interface{},\n) bool {\n\tif !reflect.DeepEqual(expected, actual) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{actual},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected %s value\", what),\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\treturn true\n}\n\ntype errBodyReader struct {\n\terr error\n}\n\nfunc (r errBodyReader) Read(_ []byte) (int, error) {\n\treturn 0, r.err\n}\n\nfunc (r errBodyReader) Close() error {\n\treturn r.err\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 42.4404296875,
          "content": "package httpexpect\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResponse_FailedChain(t *testing.T) {\n\tcheck := func(resp *Response) {\n\t\tresp.chain.assert(t, failure)\n\n\t\tresp.Alias(\"foo\")\n\n\t\tresp.RoundTripTime().chain.assert(t, failure)\n\t\tresp.Duration().chain.assert(t, failure)\n\t\tresp.Headers().chain.assert(t, failure)\n\t\tresp.Header(\"foo\").chain.assert(t, failure)\n\t\tresp.Cookies().chain.assert(t, failure)\n\t\tresp.Cookie(\"foo\").chain.assert(t, failure)\n\t\tresp.Body().chain.assert(t, failure)\n\t\tresp.Text().chain.assert(t, failure)\n\t\tresp.Form().chain.assert(t, failure)\n\t\tresp.JSON().chain.assert(t, failure)\n\t\tresp.JSONP(\"\").chain.assert(t, failure)\n\t\tresp.Websocket().chain.assert(t, failure)\n\n\t\tresp.Status(123)\n\t\tresp.StatusRange(Status2xx)\n\t\tresp.StatusList(http.StatusOK, http.StatusBadGateway)\n\t\tresp.NoContent()\n\t\tresp.HasContentType(\"\", \"\")\n\t\tresp.HasContentEncoding(\"\")\n\t\tresp.HasTransferEncoding(\"\")\n\t}\n\n\tt.Run(\"failed chain\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tconfig := newMockConfig(reporter)\n\t\tchain := newChainWithDefaults(\"test\", reporter, flagFailed)\n\n\t\tresp := newResponse(responseOpts{\n\t\t\tconfig:   config,\n\t\t\tchain:    chain,\n\t\t\thttpResp: &http.Response{},\n\t\t})\n\n\t\tcheck(resp)\n\t})\n\n\tt.Run(\"nil value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tconfig := newMockConfig(reporter)\n\t\tchain := newChainWithDefaults(\"test\", reporter)\n\n\t\tresp := newResponse(responseOpts{\n\t\t\tconfig:   config,\n\t\t\tchain:    chain,\n\t\t\thttpResp: nil,\n\t\t})\n\n\t\tcheck(resp)\n\t})\n\n\tt.Run(\"failed chain, nil value\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tconfig := newMockConfig(reporter)\n\t\tchain := newChainWithDefaults(\"test\", reporter, flagFailed)\n\n\t\tresp := newResponse(responseOpts{\n\t\t\tconfig:   config,\n\t\t\tchain:    chain,\n\t\t\thttpResp: nil,\n\t\t})\n\n\t\tcheck(resp)\n\t})\n}\n\nfunc TestResponse_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tresp := NewResponse(reporter, &http.Response{})\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tresp := NewResponseC(Config{\n\t\t\tReporter: reporter,\n\t\t}, &http.Response{})\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\treporter := newMockReporter(t)\n\t\tconfig := newMockConfig(reporter)\n\t\tvalue := newResponse(responseOpts{\n\t\t\tconfig:   config,\n\t\t\tchain:    chain,\n\t\t\thttpResp: &http.Response{},\n\t\t})\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestResponse_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\thttpResp := http.Response{}\n\n\tresp := NewResponse(reporter, &httpResp)\n\n\tassert.Same(t, &httpResp, resp.Raw())\n\tresp.chain.assert(t, success)\n}\n\nfunc TestResponse_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewResponse(reporter, &http.Response{}, time.Second)\n\tassert.Equal(t, []string{\"Response()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Response()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Response()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestResponse_RoundTripTime(t *testing.T) {\n\tt.Run(\"provided\", func(t *testing.T) {\n\t\tduration := time.Second\n\n\t\treporter := newMockReporter(t)\n\t\tresp := NewResponse(reporter, &http.Response{}, duration)\n\t\tresp.chain.assert(t, success)\n\n\t\trt := resp.RoundTripTime()\n\t\tresp.chain.assert(t, success)\n\t\trt.chain.assert(t, success)\n\n\t\tassert.Equal(t, time.Second, rt.Raw())\n\t})\n\n\tt.Run(\"omitted\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tresp := NewResponse(reporter, &http.Response{})\n\t\tresp.chain.assert(t, success)\n\n\t\trt := resp.RoundTripTime()\n\t\tresp.chain.assert(t, success)\n\t\trt.chain.assert(t, success)\n\n\t\tassert.Equal(t, time.Duration(0), rt.Raw())\n\t})\n}\n\nfunc TestResponse_Status(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tcases := []struct {\n\t\tstatus     int\n\t\ttestStatus int\n\t}{\n\t\t{http.StatusOK, http.StatusOK},\n\t\t{http.StatusOK, http.StatusNotFound},\n\t\t{http.StatusNotFound, http.StatusNotFound},\n\t\t{http.StatusNotFound, http.StatusOK},\n\t}\n\n\tfor _, tc := range cases {\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: tc.status,\n\t\t})\n\n\t\tresp.Status(tc.testStatus)\n\n\t\tif tc.status == tc.testStatus {\n\t\t\tresp.chain.assert(t, success)\n\t\t} else {\n\t\t\tresp.chain.assert(t, failure)\n\t\t}\n\t}\n}\n\nfunc TestResponse_StatusRange(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tranges := []StatusRange{\n\t\tStatus1xx,\n\t\tStatus2xx,\n\t\tStatus3xx,\n\t\tStatus4xx,\n\t\tStatus5xx,\n\t}\n\n\tcases := []struct {\n\t\tstatus      int\n\t\tstatusRange StatusRange\n\t}{\n\t\t{99, StatusRange(-1)},\n\t\t{100, Status1xx},\n\t\t{199, Status1xx},\n\t\t{200, Status2xx},\n\t\t{299, Status2xx},\n\t\t{300, Status3xx},\n\t\t{399, Status3xx},\n\t\t{400, Status4xx},\n\t\t{499, Status4xx},\n\t\t{500, Status5xx},\n\t\t{599, Status5xx},\n\t\t{600, StatusRange(-1)},\n\t}\n\n\tfor _, tc := range cases {\n\t\tfor _, r := range ranges {\n\t\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\t\tStatusCode: tc.status,\n\t\t\t})\n\n\t\t\tresp.StatusRange(r)\n\n\t\t\tif tc.statusRange == r {\n\t\t\t\tresp.chain.assert(t, success)\n\t\t\t} else {\n\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestResponse_StatusList(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tcases := []struct {\n\t\tstatus     int\n\t\tstatusList []int\n\t\tresult     chainResult\n\t}{\n\t\t{\n\t\t\thttp.StatusOK,\n\t\t\t[]int{http.StatusOK, http.StatusBadRequest, http.StatusInternalServerError},\n\t\t\tsuccess,\n\t\t},\n\t\t{\n\t\t\thttp.StatusBadRequest,\n\t\t\t[]int{http.StatusOK, http.StatusBadRequest, http.StatusInternalServerError},\n\t\t\tsuccess,\n\t\t},\n\t\t{\n\t\t\thttp.StatusOK,\n\t\t\t[]int{http.StatusInternalServerError, http.StatusBadRequest},\n\t\t\tfailure,\n\t\t},\n\t\t{\n\t\t\thttp.StatusBadGateway,\n\t\t\t[]int{},\n\t\t\tfailure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: tc.status,\n\t\t})\n\t\tresp.StatusList(tc.statusList...)\n\t\tresp.chain.assert(t, tc.result)\n\t}\n}\n\nfunc TestResponse_Headers(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\theaders := map[string][]string{\n\t\t\"First-Header\":  {\"foo\"},\n\t\t\"Second-Header\": {\"bar\"},\n\t}\n\n\thttpResp := &http.Response{\n\t\tStatusCode: http.StatusOK,\n\t\tHeader:     http.Header(headers),\n\t\tBody:       nil,\n\t}\n\n\tresp := NewResponse(reporter, httpResp)\n\n\tresp.Headers().IsEqual(headers).\n\t\tchain.assert(t, success)\n\n\tfor k, v := range headers {\n\t\tfor _, h := range []string{k, strings.ToLower(k), strings.ToUpper(k)} {\n\t\t\tresp.Header(h).IsEqual(v[0]).\n\t\t\t\tchain.assert(t, success)\n\t\t}\n\t}\n\n\tresp.Header(\"Bad-Header\").IsEmpty().\n\t\tchain.assert(t, success)\n}\n\nfunc TestResponse_Cookies(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tt.Run(\"cookies\", func(t *testing.T) {\n\t\theaders := map[string][]string{\n\t\t\t\"Set-Cookie\": {\n\t\t\t\t\"foo=aaa\",\n\t\t\t\t\"bar=bbb; expires=Fri, 31 Dec 2010 23:59:59 GMT; \" +\n\t\t\t\t\t\"path=/xxx; domain=example.com\",\n\t\t\t},\n\t\t}\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       nil,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, []interface{}{\"foo\", \"bar\"}, resp.Cookies().Raw())\n\t\tresp.chain.assert(t, success)\n\n\t\tc1 := resp.Cookie(\"foo\")\n\t\tresp.chain.assert(t, success)\n\t\tassert.Equal(t, \"foo\", c1.Raw().Name)\n\t\tassert.Equal(t, \"aaa\", c1.Raw().Value)\n\t\tassert.Equal(t, \"\", c1.Raw().Domain)\n\t\tassert.Equal(t, \"\", c1.Raw().Path)\n\n\t\tc2 := resp.Cookie(\"bar\")\n\t\tresp.chain.assert(t, success)\n\t\tassert.Equal(t, \"bar\", c2.Raw().Name)\n\t\tassert.Equal(t, \"bbb\", c2.Raw().Value)\n\t\tassert.Equal(t, \"example.com\", c2.Raw().Domain)\n\t\tassert.Equal(t, \"/xxx\", c2.Raw().Path)\n\t\tassert.True(t, time.Date(2010, 12, 31, 23, 59, 59, 0, time.UTC).\n\t\t\tEqual(c2.Raw().Expires))\n\n\t\tc3 := resp.Cookie(\"baz\")\n\t\tresp.chain.assert(t, failure)\n\t\tc3.chain.assert(t, failure)\n\t\tassert.Nil(t, c3.Raw())\n\t})\n\n\tt.Run(\"no cookies\", func(t *testing.T) {\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     nil,\n\t\t\tBody:       nil,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, []interface{}{}, resp.Cookies().Raw())\n\t\tresp.chain.assert(t, success)\n\n\t\tc := resp.Cookie(\"foo\")\n\t\tresp.chain.assert(t, failure)\n\t\tc.chain.assert(t, failure)\n\t\tassert.Nil(t, c.Raw())\n\t})\n}\n\nfunc TestResponse_BodyOperations(t *testing.T) {\n\tt.Run(\"content\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(\"body\")),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, \"body\", resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"read and close\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"test_body\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, \"test_body\", resp.Body().Raw())\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\n\t\tresp.chain.assert(t, success)\n\t})\n\n\tt.Run(\"read error\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"test_body\")\n\t\tbody.readErr = errors.New(\"test_error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\t\trespBody := resp.Body()\n\n\t\tassert.Equal(t, \"\", respBody.Raw())\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\n\t\trespBody.chain.assert(t, failure)\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"close error\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"test_body\")\n\t\tbody.closeErr = errors.New(\"test_error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, \"\", resp.Body().Raw())\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\n\t\tresp.chain.assert(t, failure)\n\t})\n}\n\nfunc TestResponse_BodyDeferred(t *testing.T) {\n\tt.Run(\"constructor does not read content\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"body string\")\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t})\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentPending, resp.contentState)\n\t})\n\n\tt.Run(\"content is remembered\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"body string\")\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t})\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentPending, resp.contentState)\n\n\t\t// Read body\n\t\tresp.Body()\n\t\tresp.chain.assert(t, success)\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, []byte(\"body string\"), resp.content)\n\t\tassert.Equal(t, contentRetreived, resp.contentState)\n\n\t\t// Second call should be no-op\n\t\tresp.Body()\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Equal(t, []byte(\"body string\"), resp.content)\n\t\tassert.Equal(t, contentRetreived, resp.contentState)\n\t})\n\n\tt.Run(\"read error is remembered\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"body string\")\n\t\tbody.readErr = errors.New(\"test error\")\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t})\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentPending, resp.contentState)\n\n\t\t// Read body\n\t\tresp.Body()\n\t\tresp.chain.assert(t, failure)\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentFailed, resp.contentState)\n\n\t\t// Second call should be no-op\n\t\tresp.Body()\n\t\tresp.chain.assert(t, failure)\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentFailed, resp.contentState)\n\t})\n\n\tt.Run(\"close error is remembered\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"body string\")\n\t\tbody.closeErr = errors.New(\"test error\")\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t})\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentPending, resp.contentState)\n\n\t\t// Read body\n\t\tresp.Body()\n\t\tresp.chain.assert(t, failure)\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentFailed, resp.contentState)\n\n\t\t// Second call should be no-op\n\t\tresp.Body()\n\t\tresp.chain.assert(t, failure)\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentFailed, resp.contentState)\n\t})\n\n\tt.Run(\"failed state\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"body string\")\n\t\tbody.readErr = errors.New(\"test error\")\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t})\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentPending, resp.contentState)\n\n\t\t// Read body\n\t\tresp.Body()\n\t\tresp.chain.assert(t, failure)\n\n\t\treadCount := body.readCount\n\t\tassert.NotEqual(t, 0, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentFailed, resp.contentState)\n\n\t\t// Invoke getContent()\n\t\tchain := resp.chain.enter(\"Test()\")\n\t\tcontent, ok := resp.getContent(chain, \"Test()\")\n\n\t\tchain.assert(t, failure)\n\t\tassert.Nil(t, content)\n\t\tassert.False(t, ok)\n\n\t\tassert.Equal(t, readCount, body.readCount)\n\t\tassert.Equal(t, 1, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentFailed, resp.contentState)\n\t})\n\n\tt.Run(\"hijacked state\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := newMockBody(\"body string\")\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       body,\n\t\t})\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentPending, resp.contentState)\n\n\t\t// Hijack body\n\t\treader := resp.Reader()\n\t\tassert.NotNil(t, reader)\n\t\tresp.chain.assert(t, success)\n\n\t\t// Invoke getContent()\n\t\tchain := resp.chain.enter(\"Test()\")\n\t\tcontent, ok := resp.getContent(chain, \"Test()\")\n\n\t\tchain.assert(t, failure)\n\t\tassert.Nil(t, content)\n\t\tassert.False(t, ok)\n\n\t\tassert.Equal(t, 0, body.readCount)\n\t\tassert.Equal(t, 0, body.closeCount)\n\t\tassert.Nil(t, resp.content)\n\t\tassert.Equal(t, contentHijacked, resp.contentState)\n\t})\n}\n\nfunc TestResponse_NoContent(t *testing.T) {\n\tt.Run(\"empty Content-Type, empty Body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"\"},\n\t\t}\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(\"\")),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, \"\", resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.NoContent()\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.Text()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.Form()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.JSON()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.JSONP(\"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n\n\tt.Run(\"empty Content-Type, nil Body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"\"},\n\t\t}\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       nil,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, \"\", resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.NoContent()\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.Text()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.Form()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.JSON()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.JSONP(\"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n\n\tt.Run(\"non-empty Content-Type, empty Body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"text/plain; charset=utf-8\"},\n\t\t}\n\n\t\tbody := ``\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, body, resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.NoContent()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n\n\tt.Run(\"empty Content-Type, Body read failure\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"\"},\n\t\t}\n\n\t\tbody := newMockBody(\"\")\n\t\tbody.readErr = errors.New(\"test_error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.NoContent()\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"empty Content-Type, Body close failure\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"\"},\n\t\t}\n\n\t\tbody := newMockBody(\"\")\n\t\tbody.closeErr = errors.New(\"test_error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.NoContent()\n\t\tresp.chain.assert(t, failure)\n\t})\n}\n\nfunc TestResponse_ContentType(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"text/plain; charset=utf-8\"},\n\t\t}\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tHeader: http.Header(headers),\n\t\t})\n\n\t\tresp.HasContentType(\"text/plain\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"utf-8\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"UTF-8\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"bad\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"bad\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n\n\tt.Run(\"empty type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"charset=utf-8\"},\n\t\t}\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tHeader: http.Header(headers),\n\t\t})\n\n\t\tresp.HasContentType(\"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"\", \"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n\n\tt.Run(\"empty charset\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"text/plain\"},\n\t\t}\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tHeader: http.Header(headers),\n\t\t})\n\n\t\tresp.HasContentType(\"text/plain\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"utf-8\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n\n\tt.Run(\"empty type and charset\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\";\"},\n\t\t}\n\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tHeader: http.Header(headers),\n\t\t})\n\n\t\tresp.HasContentType(\"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"\", \"\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n}\n\nfunc TestResponse_ContentEncoding(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\theaders := map[string][]string{\n\t\t\"Content-Encoding\": {\"gzip\", \"deflate\"},\n\t}\n\n\tresp := NewResponse(reporter, &http.Response{\n\t\tHeader: http.Header(headers),\n\t})\n\n\tresp.HasContentEncoding(\"gzip\", \"deflate\")\n\tresp.chain.assert(t, success)\n\tresp.chain.clear()\n\n\tresp.HasContentEncoding(\"deflate\", \"gzip\")\n\tresp.chain.assert(t, failure)\n\tresp.chain.clear()\n\n\tresp.HasContentEncoding(\"gzip\")\n\tresp.chain.assert(t, failure)\n\tresp.chain.clear()\n\n\tresp.HasContentEncoding()\n\tresp.chain.assert(t, failure)\n\tresp.chain.clear()\n}\n\nfunc TestResponse_TransferEncoding(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tresp := NewResponse(reporter, &http.Response{\n\t\tTransferEncoding: []string{\"foo\", \"bar\"},\n\t})\n\n\tresp.HasTransferEncoding(\"foo\", \"bar\")\n\tresp.chain.assert(t, success)\n\tresp.chain.clear()\n\n\tresp.HasTransferEncoding(\"foo\")\n\tresp.chain.assert(t, failure)\n\tresp.chain.clear()\n\n\tresp.HasTransferEncoding()\n\tresp.chain.assert(t, failure)\n\tresp.chain.clear()\n}\n\nfunc TestResponse_Text(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"text/plain; charset=utf-8\"},\n\t\t}\n\n\t\tbody := `hello, world!`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, body, resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\", \"utf-8\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"application/json\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.Text()\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tassert.Equal(t, \"hello, world!\", resp.Text().Raw())\n\t})\n\n\tt.Run(\"read failure\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"text/plain; charset=utf-8\"},\n\t\t}\n\n\t\tbody := newMockBody(`hello, world!`)\n\t\tbody.readErr = errors.New(\"read error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\trespText := resp.Text()\n\n\t\tassert.Equal(t, \"\", respText.Raw())\n\t\trespText.chain.assert(t, failure)\n\t\tresp.chain.assert(t, failure)\n\t})\n}\n\nfunc TestResponse_Form(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t}\n\n\t\tbody := `a=1&b=2`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, body, resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"application/x-www-form-urlencoded\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"application/x-www-form-urlencoded\", \"\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.Form()\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\texpected := map[string]interface{}{\n\t\t\t\"a\": \"1\",\n\t\t\t\"b\": \"2\",\n\t\t}\n\n\t\tassert.Equal(t, expected, resp.Form().Raw())\n\t})\n\n\tt.Run(\"bad body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t}\n\n\t\tbody := \"%\"\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.Form()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tassert.Nil(t, resp.Form().Raw())\n\t})\n\n\tt.Run(\"bad type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"bad\"},\n\t\t}\n\n\t\tbody := \"foo=bar\"\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.Form()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tassert.Nil(t, resp.Form().Raw())\n\t})\n\n\tt.Run(\"read failure\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t}\n\n\t\tbody := newMockBody(\"foo=bar\")\n\t\tbody.readErr = errors.New(\"read error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\trespForm := resp.Form()\n\t\tassert.Nil(t, respForm.Raw())\n\n\t\trespForm.chain.assert(t, failure)\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n}\n\nfunc TestResponse_JSON(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json; charset=utf-8\"},\n\t\t}\n\n\t\tbody := `{\"key\": \"value\"}`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.Equal(t, body, resp.Body().Raw())\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"application/json\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"application/json\", \"utf-8\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tresp.HasContentType(\"text/plain\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tresp.JSON()\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\"key\": \"value\"}, resp.JSON().Object().Raw())\n\t})\n\n\tt.Run(\"bad body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json; charset=utf-8\"},\n\t\t}\n\n\t\tbody := \"{\"\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.JSON()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tassert.Nil(t, resp.JSON().Raw())\n\t})\n\n\tt.Run(\"empty charset\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json\"},\n\t\t}\n\n\t\tbody := `{\"key\": \"value\"}`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.JSON()\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\"key\": \"value\"}, resp.JSON().Object().Raw())\n\t})\n\n\tt.Run(\"bad charset\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json; charset=bad\"},\n\t\t}\n\n\t\tbody := `{\"key\": \"value\"}`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.JSON()\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tassert.Equal(t, nil, resp.JSON().Raw())\n\t})\n\n\tt.Run(\"read failure\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json; charset=utf-8\"},\n\t\t}\n\n\t\tbody := newMockBody(`{\"key\": \"value\"}`)\n\t\tbody.readErr = errors.New(\"read error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\trespJSON := resp.JSON()\n\t\tassert.Nil(t, respJSON.Raw())\n\t\trespJSON.chain.assert(t, failure)\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n}\n\nfunc TestResponse_JSONP(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/javascript; charset=utf-8\"},\n\t\t}\n\n\t\tbody1 := `foo({\"key\": \"value\"})`\n\t\tbody2 := `foo({\"key\": \"value\"});`\n\t\tbody3 := ` foo ( {\"key\": \"value\"} ) ; `\n\n\t\tfor n, body := range []string{body1, body2, body3} {\n\t\t\tt.Run(fmt.Sprintf(\"body%d\", n+1),\n\t\t\t\tfunc(t *testing.T) {\n\t\t\t\t\thttpResp := &http.Response{\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tHeader:     http.Header(headers),\n\t\t\t\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t\t\t\t}\n\n\t\t\t\t\tresp := NewResponse(reporter, httpResp)\n\n\t\t\t\t\tassert.Equal(t, body, resp.Body().Raw())\n\t\t\t\t\tresp.chain.assert(t, success)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tresp.HasContentType(\"application/javascript\")\n\t\t\t\t\tresp.chain.assert(t, success)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tresp.HasContentType(\"application/javascript\", \"utf-8\")\n\t\t\t\t\tresp.chain.assert(t, success)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tresp.HasContentType(\"text/plain\")\n\t\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tresp.JSONP(\"foo\")\n\t\t\t\t\tresp.chain.assert(t, success)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tassert.Equal(t,\n\t\t\t\t\t\tmap[string]interface{}{\"key\": \"value\"},\n\t\t\t\t\t\tresp.JSONP(\"foo\").Object().Raw())\n\n\t\t\t\t\tresp.JSONP(\"fo\")\n\t\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tresp.JSONP(\"\")\n\t\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t\t\tresp.chain.clear()\n\t\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"bad body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/javascript; charset=utf-8\"},\n\t\t}\n\n\t\tbody1 := `foo`\n\t\tbody2 := `foo();`\n\t\tbody3 := `foo(`\n\t\tbody4 := `foo({);`\n\n\t\tfor n, body := range []string{body1, body2, body3, body4} {\n\t\t\tt.Run(fmt.Sprintf(\"body%d\", n+1),\n\t\t\t\tfunc(t *testing.T) {\n\t\t\t\t\thttpResp := &http.Response{\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tHeader:     http.Header(headers),\n\t\t\t\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t\t\t\t}\n\n\t\t\t\t\tresp := NewResponse(reporter, httpResp)\n\n\t\t\t\t\tresp.JSONP(\"foo\")\n\t\t\t\t\tresp.chain.assert(t, failure)\n\t\t\t\t\tresp.chain.clear()\n\n\t\t\t\t\tassert.Nil(t, resp.JSONP(\"foo\").Raw())\n\t\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"empty charset\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/javascript\"},\n\t\t}\n\n\t\tbody := `foo({\"key\": \"value\"})`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.JSONP(\"foo\")\n\t\tresp.chain.assert(t, success)\n\t\tresp.chain.clear()\n\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\"key\": \"value\"}, resp.JSONP(\"foo\").Object().Raw())\n\t})\n\n\tt.Run(\"bad charset\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/javascript; charset=bad\"},\n\t\t}\n\n\t\tbody := `foo({\"key\": \"value\"})`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tresp.JSONP(\"foo\")\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\n\t\tassert.Nil(t, resp.JSONP(\"foo\").Raw())\n\t})\n\n\tt.Run(\"read failure\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/javascript; charset=utf-8\"},\n\t\t}\n\n\t\tbody := newMockBody(`foo({\"key\": \"value\"})`)\n\t\tbody.readErr = errors.New(\"read error\")\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       body,\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\trespJSONP := resp.JSONP(\"foo\")\n\t\tassert.Nil(t, respJSONP.Raw())\n\t\trespJSONP.chain.assert(t, failure)\n\t\tresp.chain.assert(t, failure)\n\t\tresp.chain.clear()\n\t})\n}\n\nfunc TestResponse_ContentOpts(t *testing.T) {\n\ttype testCase struct {\n\t\trespContentType   string\n\t\trespBody          string\n\t\texpectedMediaType string\n\t\texpectedCharset   string\n\t\tmatch             bool\n\t\tchainFunc         func(*Response, ContentOpts) *chain\n\t}\n\n\trunTest := func(t *testing.T, tc testCase) {\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {tc.respContentType},\n\t\t}\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(tc.respBody)),\n\t\t}\n\n\t\treporter := newMockReporter(t)\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tc := tc.chainFunc(resp, ContentOpts{\n\t\t\tMediaType: tc.expectedMediaType,\n\t\t\tCharset:   tc.expectedCharset,\n\t\t})\n\n\t\tif tc.match {\n\t\t\tc.assert(t, success)\n\t\t} else {\n\t\t\tc.assert(t, failure)\n\t\t}\n\t}\n\n\trunAllTests := func(\n\t\tt *testing.T,\n\t\tdefaultType, defaultCharset, respBody string,\n\t\tchainFunc func(*Response, ContentOpts) *chain,\n\t) {\n\t\trunTest(t, testCase{\n\t\t\trespContentType:   \"test-type; charset=test-charset\",\n\t\t\trespBody:          respBody,\n\t\t\texpectedMediaType: \"test-type\",\n\t\t\texpectedCharset:   \"test-charset\",\n\t\t\tmatch:             true,\n\t\t\tchainFunc:         chainFunc,\n\t\t})\n\t\trunTest(t, testCase{\n\t\t\trespContentType:   \"test-type; charset=BAD\",\n\t\t\trespBody:          respBody,\n\t\t\texpectedMediaType: \"test-type\",\n\t\t\texpectedCharset:   \"test-charset\",\n\t\t\tmatch:             false,\n\t\t\tchainFunc:         chainFunc,\n\t\t})\n\t\trunTest(t, testCase{\n\t\t\trespContentType:   \"BAD; charset=test-charset\",\n\t\t\trespBody:          respBody,\n\t\t\texpectedMediaType: \"test-type\",\n\t\t\texpectedCharset:   \"test-charset\",\n\t\t\tmatch:             false,\n\t\t\tchainFunc:         chainFunc,\n\t\t})\n\t\tif defaultCharset != \"\" {\n\t\t\trunTest(t, testCase{\n\t\t\t\trespContentType:   \"test-type; charset=\" + defaultCharset,\n\t\t\t\trespBody:          respBody,\n\t\t\t\texpectedMediaType: \"test-type\",\n\t\t\t\texpectedCharset:   defaultCharset,\n\t\t\t\tmatch:             true,\n\t\t\t\tchainFunc:         chainFunc,\n\t\t\t})\n\t\t\trunTest(t, testCase{\n\t\t\t\trespContentType:   \"test-type; charset=\" + defaultCharset,\n\t\t\t\trespBody:          respBody,\n\t\t\t\texpectedMediaType: \"test-type\",\n\t\t\t\texpectedCharset:   \"\",\n\t\t\t\tmatch:             true,\n\t\t\t\tchainFunc:         chainFunc,\n\t\t\t})\n\t\t}\n\t\trunTest(t, testCase{\n\t\t\trespContentType:   \"test-type\",\n\t\t\trespBody:          respBody,\n\t\t\texpectedMediaType: \"test-type\",\n\t\t\texpectedCharset:   \"\",\n\t\t\tmatch:             true,\n\t\t\tchainFunc:         chainFunc,\n\t\t})\n\t\trunTest(t, testCase{\n\t\t\trespContentType:   defaultType + \"; charset=test-charset\",\n\t\t\trespBody:          respBody,\n\t\t\texpectedMediaType: defaultType,\n\t\t\texpectedCharset:   \"test-charset\",\n\t\t\tmatch:             true,\n\t\t\tchainFunc:         chainFunc,\n\t\t})\n\t\trunTest(t, testCase{\n\t\t\trespContentType:   defaultType + \"; charset=test-charset\",\n\t\t\trespBody:          respBody,\n\t\t\texpectedMediaType: \"\",\n\t\t\texpectedCharset:   \"test-charset\",\n\t\t\tmatch:             true,\n\t\t\tchainFunc:         chainFunc,\n\t\t})\n\t}\n\n\tt.Run(\"text\", func(t *testing.T) {\n\t\trunAllTests(t, \"text/plain\",\n\t\t\t\"utf-8\",\n\t\t\t\"test text\",\n\t\t\tfunc(resp *Response, opts ContentOpts) *chain {\n\t\t\t\treturn resp.Text(opts).chain\n\t\t\t})\n\t})\n\n\tt.Run(\"form\", func(t *testing.T) {\n\t\trunAllTests(t, \"application/x-www-form-urlencoded\",\n\t\t\t\"\",\n\t\t\t\"a=b\",\n\t\t\tfunc(resp *Response, opts ContentOpts) *chain {\n\t\t\t\treturn resp.Form(opts).chain\n\t\t\t})\n\t})\n\n\tt.Run(\"json\", func(t *testing.T) {\n\t\trunAllTests(t, \"application/json\",\n\t\t\t\"utf-8\",\n\t\t\t\"{}\",\n\t\t\tfunc(resp *Response, opts ContentOpts) *chain {\n\t\t\t\treturn resp.JSON(opts).chain\n\t\t\t})\n\t})\n\n\tt.Run(\"jsonp\", func(t *testing.T) {\n\t\trunAllTests(t, \"application/javascript\",\n\t\t\t\"utf-8\",\n\t\t\t\"cb({})\",\n\t\t\tfunc(resp *Response, opts ContentOpts) *chain {\n\t\t\t\treturn resp.JSONP(\"cb\", opts).chain\n\t\t\t})\n\t})\n}\n\nfunc TestResponse_Reader(t *testing.T) {\n\tt.Run(\"read body\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       newMockBody(\"test body\"),\n\t\t}\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\treader := resp.Reader()\n\t\trequire.NotNil(t, reader)\n\t\tresp.chain.assert(t, success)\n\n\t\tb, err := io.ReadAll(reader)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"test body\", string(b))\n\n\t\terr = reader.Close()\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"rewinds disabled\", func(t *testing.T) {\n\t\twrp := newBodyWrapper(newMockBody(\"test\"), nil)\n\n\t\treporter := newMockReporter(t)\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tBody:       wrp,\n\t\t}\n\t\tresp := NewResponse(reporter, httpResp)\n\n\t\tassert.False(t, wrp.isRewindDisabled)\n\n\t\treader := resp.Reader()\n\t\trequire.NotNil(t, reader)\n\t\tresp.chain.assert(t, success)\n\n\t\tassert.True(t, wrp.isRewindDisabled)\n\n\t\terr := reader.Close()\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"conflicts\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\tcontentType string\n\t\t\tbody        string\n\t\t\tmethod      func(resp *Response) *chain\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"Body\",\n\t\t\t\tcontentType: \"text/plain; charset=utf-8\",\n\t\t\t\tbody:        `test`,\n\t\t\t\tmethod: func(resp *Response) *chain {\n\t\t\t\t\treturn resp.Body().chain\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"Text\",\n\t\t\t\tcontentType: \"text/plain; charset=utf-8\",\n\t\t\t\tbody:        `test`,\n\t\t\t\tmethod: func(resp *Response) *chain {\n\t\t\t\t\treturn resp.Text().chain\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"Form\",\n\t\t\t\tcontentType: \"application/x-www-form-urlencoded\",\n\t\t\t\tbody:        `x=1&y=0`,\n\t\t\t\tmethod: func(resp *Response) *chain {\n\t\t\t\t\treturn resp.Form().chain\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"JSON\",\n\t\t\t\tcontentType: \"application/json\",\n\t\t\t\tbody:        `{\"x\":\"y\"}`,\n\t\t\t\tmethod: func(resp *Response) *chain {\n\t\t\t\t\treturn resp.JSON().chain\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"JSONP\",\n\t\t\t\tcontentType: \"application/javascript\",\n\t\t\t\tbody:        `test({\"x\":\"y\"})`,\n\t\t\t\tmethod: func(resp *Response) *chain {\n\t\t\t\t\treturn resp.JSONP(\"test\").chain\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tt.Run(\"before reader\", func(t *testing.T) {\n\t\t\t\t\treporter := newMockReporter(t)\n\t\t\t\t\thttpResp := &http.Response{\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tHeader: http.Header(map[string][]string{\n\t\t\t\t\t\t\t\"Content-Type\": {tc.contentType},\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tBody: newMockBody(tc.body),\n\t\t\t\t\t}\n\t\t\t\t\tresp := NewResponse(reporter, httpResp)\n\n\t\t\t\t\t// other method reads body\n\t\t\t\t\ttc.method(resp).assert(t, success)\n\n\t\t\t\t\t// Reader will fail\n\t\t\t\t\treader := resp.Reader()\n\t\t\t\t\trequire.NotNil(t, reader)\n\t\t\t\t\tresp.chain.assert(t, failure)\n\n\t\t\t\t\tb, err := io.ReadAll(reader)\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t\tassert.Empty(t, b)\n\n\t\t\t\t\terr = reader.Close()\n\t\t\t\t\tassert.Error(t, err)\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tt.Run(\"after reader\", func(t *testing.T) {\n\t\t\t\t\treporter := newMockReporter(t)\n\t\t\t\t\thttpResp := &http.Response{\n\t\t\t\t\t\tStatusCode: http.StatusOK,\n\t\t\t\t\t\tHeader: http.Header(map[string][]string{\n\t\t\t\t\t\t\t\"Content-Type\": {tc.contentType},\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tBody: newMockBody(tc.body),\n\t\t\t\t\t}\n\t\t\t\t\tresp := NewResponse(reporter, httpResp)\n\n\t\t\t\t\t// Reader hijacks body\n\t\t\t\t\treader := resp.Reader()\n\t\t\t\t\trequire.NotNil(t, reader)\n\t\t\t\t\tresp.chain.assert(t, success)\n\n\t\t\t\t\t// other method will fail\n\t\t\t\t\ttc.method(resp).assert(t, failure)\n\t\t\t\t\tresp.chain.assert(t, failure)\n\n\t\t\t\t\tb, err := io.ReadAll(reader)\n\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, tc.body, string(b))\n\n\t\t\t\t\terr = reader.Close()\n\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestResponse_Usage(t *testing.T) {\n\tt.Run(\"NewResponse multiple rtt arguments\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\trtt := []time.Duration{time.Second, time.Second}\n\t\tresp := NewResponse(reporter, &http.Response{}, rtt...)\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"ContentType multiple charset arguments\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"text/plain;charset=utf-8;charset=US-ASCII\"},\n\t\t}\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tHeader: headers,\n\t\t})\n\t\tresp.HasContentType(\"text/plain\", \"utf-8\", \"US-ASCII\")\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"Text multiple arguments\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\theader := map[string][]string{\n\t\t\t\"ContentType\": {\"text/plain\"},\n\t\t}\n\t\tresp := NewResponse(reporter, &http.Response{\n\t\t\tHeader: header,\n\t\t})\n\t\tcontentOpts1 := ContentOpts{\n\t\t\tMediaType: \"text/plain\",\n\t\t}\n\t\tcontentOpts2 := ContentOpts{\n\t\t\tMediaType: \"application/json\",\n\t\t}\n\t\tresp.Text(contentOpts1, contentOpts2)\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"Form multiple arguments\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/x-www-form-urlencoded\"},\n\t\t}\n\n\t\tbody := `a=1&b=2`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\t\tcontentOpts1 := ContentOpts{\n\t\t\tMediaType: \"text/plain\",\n\t\t}\n\t\tcontentOpts2 := ContentOpts{\n\t\t\tMediaType: \"application/json\",\n\t\t}\n\t\tresp.Form(contentOpts1, contentOpts2)\n\t\tresp.chain.assert(t, failure)\n\n\t})\n\n\tt.Run(\"JSON multiple arguments\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/json; charset=utf-8\"},\n\t\t}\n\n\t\tbody := `{\"key\": \"value\"}`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\t\tcontentOpts1 := ContentOpts{\n\t\t\tMediaType: \"text/plain\",\n\t\t}\n\t\tcontentOpts2 := ContentOpts{\n\t\t\tMediaType: \"application/json\",\n\t\t}\n\t\tresp.JSON(contentOpts1, contentOpts2)\n\t\tresp.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"JSONP multiple arguments\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\theaders := map[string][]string{\n\t\t\t\"Content-Type\": {\"application/javascript; charset=utf-8\"},\n\t\t}\n\n\t\tbody1 := `foo({\"key\": \"value\"})`\n\n\t\thttpResp := &http.Response{\n\t\t\tStatusCode: http.StatusOK,\n\t\t\tHeader:     http.Header(headers),\n\t\t\tBody:       io.NopCloser(bytes.NewBufferString(body1)),\n\t\t}\n\n\t\tresp := NewResponse(reporter, httpResp)\n\t\tcontentOpts1 := ContentOpts{\n\t\t\tMediaType: \"text/plain\",\n\t\t}\n\t\tcontentOpts2 := ContentOpts{\n\t\t\tMediaType: \"application/json\",\n\t\t}\n\t\tresp.JSONP(\"foo\", contentOpts1, contentOpts2)\n\t\tresp.chain.assert(t, failure)\n\t})\n}\n"
        },
        {
          "name": "stacktrace.go",
          "type": "blob",
          "size": 1.2197265625,
          "content": "package httpexpect\n\nimport (\n\t\"regexp\"\n\t\"runtime\"\n)\n\n// Stacktrace entry.\ntype StacktraceEntry struct {\n\tPc uintptr // Program counter\n\n\tFile string // File path\n\tLine int    // Line number\n\n\tFunc *runtime.Func // Function information\n\n\tFuncName    string  // Function name (without package and parenthesis)\n\tFuncPackage string  // Function package\n\tFuncOffset  uintptr // Program counter offset relative to function start\n\n\t// True if this is program entry point\n\t// (like main.main or testing.tRunner)\n\tIsEntrypoint bool\n}\n\nvar stacktraceFuncRe = regexp.MustCompile(`^(.+/[^.]+)\\.(.+)$`)\n\nfunc stacktrace() []StacktraceEntry {\n\tcallers := []StacktraceEntry{}\n\tfor i := 1; ; i++ {\n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\n\t\tf := runtime.FuncForPC(pc)\n\t\tif f == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tentry := StacktraceEntry{\n\t\t\tPc:   pc,\n\t\t\tFile: file,\n\t\t\tLine: line,\n\t\t\tFunc: f,\n\t\t}\n\n\t\tif m := stacktraceFuncRe.FindStringSubmatch(f.Name()); m != nil {\n\t\t\tentry.FuncName = m[2]\n\t\t\tentry.FuncPackage = m[1]\n\t\t} else {\n\t\t\tentry.FuncName = f.Name()\n\t\t}\n\n\t\tentry.FuncOffset = pc - f.Entry()\n\n\t\tswitch f.Name() {\n\t\tcase \"main.main\", \"testing.tRunner\":\n\t\t\tentry.IsEntrypoint = true\n\t\t}\n\n\t\tcallers = append(callers, entry)\n\t}\n\n\treturn callers\n}\n"
        },
        {
          "name": "string.go",
          "type": "blob",
          "size": 28.884765625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n)\n\n// String provides methods to inspect attached string value\n// (Go representation of JSON string).\ntype String struct {\n\tnoCopy noCopy\n\tchain  *chain\n\tvalue  string\n}\n\n// NewString returns a new String instance.\n//\n// If reporter is nil, the function panics.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\nfunc NewString(reporter Reporter, value string) *String {\n\treturn newString(newChainWithDefaults(\"String()\", reporter), value)\n}\n\n// NewStringC returns a new String instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n//\n// Example:\n//\n//\tstr := NewStringC(config, \"Hello\")\nfunc NewStringC(config Config, value string) *String {\n\treturn newString(newChainWithConfig(\"String()\", config.withDefaults()), value)\n}\n\nfunc newString(parent *chain, val string) *String {\n\treturn &String{chain: parent.clone(), value: val}\n}\n\n// Raw returns underlying value attached to String.\n// This is the value originally passed to NewString.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tassert.Equal(t, \"Hello\", str.Raw())\nfunc (s *String) Raw() string {\n\treturn s.value\n}\n\n// Decode unmarshals the underlying value attached to the String to a target variable.\n// target should be one of these:\n//\n//   - pointer to an empty interface\n//   - pointer to a string\n//\n// Example:\n//\n//\tvalue := NewString(t, \"foo\")\n//\n//\tvar target string\n//\tvalue.Decode(&target)\n//\n//\tassert.Equal(t, \"foo\", target)\nfunc (s *String) Decode(target interface{}) *String {\n\topChain := s.chain.enter(\"Decode()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tcanonDecode(opChain, s.value, target)\n\treturn s\n}\n\n// Alias is similar to Value.Alias.\nfunc (s *String) Alias(name string) *String {\n\topChain := s.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\ts.chain.setAlias(name)\n\treturn s\n}\n\n// Path is similar to Value.Path.\nfunc (s *String) Path(path string) *Value {\n\topChain := s.chain.enter(\"Path(%q)\", path)\n\tdefer opChain.leave()\n\n\treturn jsonPath(opChain, s.value, path)\n}\n\n// Schema is similar to Value.Schema.\nfunc (s *String) Schema(schema interface{}) *String {\n\topChain := s.chain.enter(\"Schema()\")\n\tdefer opChain.leave()\n\n\tjsonSchema(opChain, s.value, schema)\n\treturn s\n}\n\n// Length returns a new Number instance with string length.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.Length().IsEqual(5)\nfunc (s *String) Length() *Number {\n\topChain := s.chain.enter(\"Length()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\treturn newNumber(opChain, float64(len(s.value)))\n}\n\n// IsEmpty succeeds if string is empty.\n//\n// Example:\n//\n//\tstr := NewString(t, \"\")\n//\tstr.IsEmpty()\nfunc (s *String) IsEmpty() *String {\n\topChain := s.chain.enter(\"IsEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !(s.value == \"\") {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertEmpty,\n\t\t\tActual: &AssertionValue{s.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string is empty\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotEmpty succeeds if string is non-empty.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotEmpty()\nfunc (s *String) NotEmpty() *String {\n\topChain := s.chain.enter(\"NotEmpty()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif s.value == \"\" {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotEmpty,\n\t\t\tActual: &AssertionValue{s.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string is non-empty\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// Deprecated: use IsEmpty instead.\nfunc (s *String) Empty() *String {\n\treturn s.IsEmpty()\n}\n\n// IsEqual succeeds if string is equal to given Go string.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.IsEqual(\"Hello\")\nfunc (s *String) IsEqual(value string) *String {\n\topChain := s.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !(s.value == value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: strings are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotEqual succeeds if string is not equal to given Go string.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotEqual(\"Goodbye\")\nfunc (s *String) NotEqual(value string) *String {\n\topChain := s.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif s.value == value {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: strings are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// Deprecated: use IsEqual instead.\nfunc (s *String) Equal(value string) *String {\n\treturn s.IsEqual(value)\n}\n\n// IsEqualFold succeeds if string is equal to given Go string after applying Unicode\n// case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.IsEqualFold(\"hELLo\")\nfunc (s *String) IsEqualFold(value string) *String {\n\topChain := s.chain.enter(\"IsEqualFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.EqualFold(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: strings are equal (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotEqualFold succeeds if string is not equal to given Go string after applying\n// Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotEqualFold(\"gOODBYe\")\nfunc (s *String) NotEqualFold(value string) *String {\n\topChain := s.chain.enter(\"NotEqualFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.EqualFold(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: strings are non-equal (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// Deprecated: use IsEqualFold instead.\nfunc (s *String) EqualFold(value string) *String {\n\treturn s.IsEqualFold(value)\n}\n\n// InList succeeds if the string is equal to one of the values from given\n// list of strings.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.InList(\"Hello\", \"Goodbye\")\nfunc (s *String) InList(values ...string) *String {\n\topChain := s.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn s\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\tif s.value == v {\n\t\t\tisListed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !isListed {\n\t\tvalueList := make([]interface{}, 0, len(values))\n\t\tfor _, v := range values {\n\t\t\tvalueList = append(valueList, v)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotInList succeeds if the string is not equal to any of the values from\n// given list of strings.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotInList(\"Sayonara\", \"Goodbye\")\nfunc (s *String) NotInList(values ...string) *String {\n\topChain := s.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn s\n\t}\n\n\tfor _, v := range values {\n\t\tif s.value == v {\n\t\t\tvalueList := make([]interface{}, 0, len(values))\n\t\t\tfor _, v := range values {\n\t\t\t\tvalueList = append(valueList, v)\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{s.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: string is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treturn s\n\t\t}\n\t}\n\n\treturn s\n}\n\n// InListFold succeeds if the string is equal to one of the values from given\n// list of strings after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.InListFold(\"hEllo\", \"Goodbye\")\nfunc (s *String) InListFold(values ...string) *String {\n\topChain := s.chain.enter(\"InListFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn s\n\t}\n\n\tvar isListed bool\n\tfor _, v := range values {\n\t\tif strings.EqualFold(s.value, v) {\n\t\t\tisListed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !isListed {\n\t\tvalueList := make([]interface{}, 0, len(values))\n\t\tfor _, v := range values {\n\t\t\tvalueList = append(valueList, v)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string is equal to one of the values (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotInListFold succeeds if the string is not equal to any of the values from given\n// list of strings after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotInListFold(\"Bye\", \"Goodbye\")\nfunc (s *String) NotInListFold(values ...string) *String {\n\topChain := s.chain.enter(\"NotInListFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn s\n\t}\n\n\tfor _, v := range values {\n\t\tif strings.EqualFold(s.value, v) {\n\t\t\tvalueList := make([]interface{}, 0, len(values))\n\t\t\tfor _, v := range values {\n\t\t\t\tvalueList = append(valueList, v)\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{s.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(valueList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: string is not equal to any of the values (if folded)\"),\n\t\t\t\t},\n\t\t\t})\n\n\t\t\treturn s\n\t\t}\n\t}\n\n\treturn s\n}\n\n// Contains succeeds if string contains given Go string as a substring.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.Contains(\"ell\")\nfunc (s *String) Contains(value string) *String {\n\topChain := s.chain.enter(\"Contains()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.Contains(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string contains sub-string\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotContains succeeds if string doesn't contain Go string as a substring.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotContains(\"bye\")\nfunc (s *String) NotContains(value string) *String {\n\topChain := s.chain.enter(\"NotContains()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.Contains(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string does not contain sub-string\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// ContainsFold succeeds if string contains given Go string as a substring after\n// applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.ContainsFold(\"ELL\")\nfunc (s *String) ContainsFold(value string) *String {\n\topChain := s.chain.enter(\"ContainsFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.Contains(strings.ToLower(s.value), strings.ToLower(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string contains sub-string (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotContainsFold succeeds if string doesn't contain given Go string as a substring\n// after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.NotContainsFold(\"BYE\")\nfunc (s *String) NotContainsFold(value string) *String {\n\topChain := s.chain.enter(\"NotContainsFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.Contains(strings.ToLower(s.value), strings.ToLower(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string does not contain sub-string (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// HasPrefix succeeds if string has given Go string as prefix\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.HasPrefix(\"Hello\")\nfunc (s *String) HasPrefix(value string) *String {\n\topChain := s.chain.enter(\"HasPrefix()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.HasPrefix(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string has prefix\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotHasPrefix succeeds if string doesn't have given Go string as prefix\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.NotHasPrefix(\"Bye\")\nfunc (s *String) NotHasPrefix(value string) *String {\n\topChain := s.chain.enter(\"NotHasPrefix()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.HasPrefix(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string doesn't have prefix\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// HasSuffix succeeds if string has given Go string as suffix\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.HasSuffix(\"World\")\nfunc (s *String) HasSuffix(value string) *String {\n\topChain := s.chain.enter(\"HasSuffix()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.HasSuffix(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string has suffix\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotHasSuffix succeeds if string doesn't have given Go string as suffix\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.NotHasSuffix(\"Hello\")\nfunc (s *String) NotHasSuffix(value string) *String {\n\topChain := s.chain.enter(\"NotHasSuffix()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.HasSuffix(s.value, value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string doesn't have suffix\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// HasPrefixFold succeeds if string has given Go string as prefix\n// after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.HasPrefixFold(\"hello\")\nfunc (s *String) HasPrefixFold(value string) *String {\n\topChain := s.chain.enter(\"HasPrefixFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.HasPrefix(strings.ToLower(s.value), strings.ToLower(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string has prefix (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotHasPrefixFold succeeds if string doesn't have given Go string as prefix\n// after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.NotHasPrefixFold(\"Bye\")\nfunc (s *String) NotHasPrefixFold(value string) *String {\n\topChain := s.chain.enter(\"NotHasPrefixFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.HasPrefix(strings.ToLower(s.value), strings.ToLower(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string doesn't have prefix (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// HasSuffixFold succeeds if string has given Go string as suffix\n// after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.HasSuffixFold(\"world\")\nfunc (s *String) HasSuffixFold(value string) *String {\n\topChain := s.chain.enter(\"HasSuffixFold()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif !strings.HasSuffix(strings.ToLower(s.value), strings.ToLower(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string has suffix (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotHasSuffixFold succeeds if string doesn't have given Go string as suffix\n// after applying Unicode case-folding (so it's a case-insensitive match).\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello World\")\n//\tstr.NotHasSuffixFold(\"Bye\")\nfunc (s *String) NotHasSuffixFold(value string) *String {\n\topChain := s.chain.enter(\"NotHasSuffix()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tif strings.HasSuffix(strings.ToLower(s.value), strings.ToLower(value)) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotContainsSubset,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string doesn't have suffix (if folded)\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// Match matches the string with given regexp and returns a new Match instance\n// with found submatches.\n//\n// If regexp is invalid or string doesn't match regexp, Match fails and returns\n// empty (but non-nil) instance. regexp.Compile is used to construct regexp, and\n// Regexp.FindStringSubmatch is used to construct matches.\n//\n// Example:\n//\n//\ts := NewString(t, \"http://example.com/users/john\")\n//\tm := s.Match(`http://(?P<host>.+)/users/(?P<user>.+)`)\n//\n//\tm.NotEmpty()\n//\tm.Length().IsEqual(3)\n//\n//\tm.Submatch(0).IsEqual(\"http://example.com/users/john\")\n//\tm.Submatch(1).IsEqual(\"example.com\")\n//\tm.Submatch(2).IsEqual(\"john\")\n//\n//\tm.NamedSubmatch(\"host\").IsEqual(\"example.com\")\n//\tm.NamedSubmatch(\"user\").IsEqual(\"john\")\nfunc (s *String) Match(re string) *Match {\n\topChain := s.chain.enter(\"Match()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newMatch(opChain, nil, nil)\n\t}\n\n\trx, err := regexp.Compile(re)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{re},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid regexp\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn newMatch(opChain, nil, nil)\n\t}\n\n\tmatch := rx.FindStringSubmatch(s.value)\n\tif match == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertMatchRegexp,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{re},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string matches regexp\"),\n\t\t\t},\n\t\t})\n\t\treturn newMatch(opChain, nil, nil)\n\t}\n\n\treturn newMatch(opChain, match, rx.SubexpNames())\n}\n\n// NotMatch succeeds if the string doesn't match to given regexp.\n//\n// regexp.Compile is used to construct regexp, and Regexp.MatchString\n// is used to perform match.\n//\n// Example:\n//\n//\ts := NewString(t, \"a\")\n//\ts.NotMatch(`[^a]`)\nfunc (s *String) NotMatch(re string) *String {\n\topChain := s.chain.enter(\"NotMatch()\")\n\tdefer opChain.leave()\n\n\trx, err := regexp.Compile(re)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{re},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid regexp\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn s\n\t}\n\n\tif rx.MatchString(s.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotMatchRegexp,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{re},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string does not match regexp\"),\n\t\t\t},\n\t\t})\n\t\treturn s\n\t}\n\n\treturn s\n}\n\n// MatchAll find all matches in string for given regexp and returns a list\n// of found matches.\n//\n// If regexp is invalid or string doesn't match regexp, MatchAll fails and\n// returns empty (but non-nil) slice. regexp.Compile is used to construct\n// regexp, and Regexp.FindAllStringSubmatch is used to find matches.\n//\n// Example:\n//\n//\ts := NewString(t,\n//\t   \"http://example.com/users/john http://example.com/users/bob\")\n//\n//\tm := s.MatchAll(`http://(?P<host>\\S+)/users/(?P<user>\\S+)`)\n//\n//\tm[0].NamedSubmatch(\"user\").IsEqual(\"john\")\n//\tm[1].NamedSubmatch(\"user\").IsEqual(\"bob\")\nfunc (s *String) MatchAll(re string) []Match {\n\topChain := s.chain.enter(\"MatchAll()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn []Match{}\n\t}\n\n\trx, err := regexp.Compile(re)\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{re},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: valid regexp\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn []Match{}\n\t}\n\n\tmatches := rx.FindAllStringSubmatch(s.value, -1)\n\tif matches == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertMatchRegexp,\n\t\t\tActual:   &AssertionValue{s.value},\n\t\t\tExpected: &AssertionValue{re},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: string matches regexp\"),\n\t\t\t},\n\t\t})\n\t\treturn []Match{}\n\t}\n\n\tret := []Match{}\n\tfor _, match := range matches {\n\t\tret = append(ret, *newMatch(\n\t\t\topChain,\n\t\t\tmatch,\n\t\t\trx.SubexpNames()))\n\t}\n\n\treturn ret\n}\n\n// IsASCII succeeds if all string characters belongs to ASCII.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Hello\")\n//\tstr.IsASCII()\nfunc (s *String) IsASCII() *String {\n\topChain := s.chain.enter(\"IsASCII()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tisASCII := true\n\tfor _, c := range s.value {\n\t\tif c > unicode.MaxASCII {\n\t\t\tisASCII = false\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !isASCII {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{s.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: all string characters are ascii\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// NotASCII succeeds if at least one string character does not belong to ASCII.\n//\n// Example:\n//\n//\tstr := NewString(t, \"こんにちは\")\n//\tstr.NotASCII()\nfunc (s *String) NotASCII() *String {\n\topChain := s.chain.enter(\"NotASCII()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn s\n\t}\n\n\tisASCII := true\n\tfor _, c := range s.value {\n\t\tif c > unicode.MaxASCII {\n\t\t\tisASCII = false\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif isASCII {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{s.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: at least one string character is not ascii\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn s\n}\n\n// Deprecated: use NotASCII instead.\nfunc (s *String) NotIsASCII() *String {\n\treturn s.NotASCII()\n}\n\n// AsNumber parses float from string and returns a new Number instance\n// with result.\n//\n// If base is 10 or omitted, uses strconv.ParseFloat.\n// Otherwise, uses strconv.ParseInt or strconv.ParseUint with given base.\n//\n// Example:\n//\n//\tstr := NewString(t, \"100\")\n//\tstr.AsNumber().IsEqual(100)\n//\n// Specifying base:\n//\n//\tstr.AsNumber(10).IsEqual(100)\n//\tstr.AsNumber(16).IsEqual(256)\nfunc (s *String) AsNumber(base ...int) *Number {\n\topChain := s.chain.enter(\"AsNumber()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\tif len(base) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple base arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\tb := 10\n\tif len(base) != 0 {\n\t\tb = base[0]\n\t}\n\n\tvar fnum float64\n\tvar inum int64\n\tvar unum uint64\n\tvar err error\n\n\tinum, err = strconv.ParseInt(s.value, b, 64)\n\tfnum = float64(inum)\n\n\tif err == nil && int64(fnum) != inum {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{s.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\" number can be represented as float64 without precision loss\"),\n\t\t\t},\n\t\t})\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\tif err != nil && errors.Is(err, strconv.ErrRange) {\n\t\tunum, err = strconv.ParseUint(s.value, b, 64)\n\t\tfnum = float64(unum)\n\n\t\tif err == nil && uint64(fnum) != unum {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{s.value},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected:\" +\n\t\t\t\t\t\t\" number can be represented as float64 without precision loss\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn newNumber(opChain, 0)\n\t\t}\n\t}\n\n\tif err != nil && b == 10 {\n\t\tfnum, err = strconv.ParseFloat(s.value, 64)\n\t}\n\n\tif err != nil {\n\t\tif b == 10 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{s.value},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: string can be parsed to integer or float\"),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:   AssertValid,\n\t\t\t\tActual: &AssertionValue{s.value},\n\t\t\t\tErrors: []error{\n\t\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\t\"expected: string can be parsed to integer with base %d\",\n\t\t\t\t\t\tbase[0]),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\treturn newNumber(opChain, fnum)\n}\n\n// AsBoolean parses true/false value string and returns a new Boolean instance\n// with result.\n//\n// Accepts string values \"true\", \"True\", \"false\", \"False\".\n//\n// Example:\n//\n//\tstr := NewString(t, \"true\")\n//\tstr.AsBoolean().IsTrue()\nfunc (s *String) AsBoolean() *Boolean {\n\topChain := s.chain.enter(\"AsBoolean()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newBoolean(opChain, false)\n\t}\n\n\tswitch s.value {\n\tcase \"true\", \"True\":\n\t\treturn newBoolean(opChain, true)\n\n\tcase \"false\", \"False\":\n\t\treturn newBoolean(opChain, false)\n\t}\n\n\topChain.fail(AssertionFailure{\n\t\tType:   AssertValid,\n\t\tActual: &AssertionValue{s.value},\n\t\tErrors: []error{\n\t\t\terrors.New(\"expected: string can be parsed to boolean\"),\n\t\t},\n\t})\n\n\treturn newBoolean(opChain, false)\n}\n\n// AsDateTime parses date/time from string and returns a new DateTime instance\n// with result.\n//\n// If format is given, AsDateTime() uses time.Parse() with every given format.\n// Otherwise, it uses the list of predefined common formats.\n//\n// If the string can't be parsed with any format, AsDateTime reports failure\n// and returns empty (but non-nil) instance.\n//\n// Example:\n//\n//\tstr := NewString(t, \"Tue, 15 Nov 1994 08:12:31 GMT\")\n//\tstr.AsDateTime().Lt(time.Now())\n//\n//\tstr := NewString(t, \"15 Nov 94 08:12 GMT\")\n//\tstr.AsDateTime(time.RFC822).Lt(time.Now())\nfunc (s *String) AsDateTime(format ...string) *DateTime {\n\topChain := s.chain.enter(\"AsDateTime()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newDateTime(opChain, time.Unix(0, 0))\n\t}\n\n\tvar formatList []datetimeFormat\n\n\tif len(format) != 0 {\n\t\tfor _, f := range format {\n\t\t\tformatList = append(formatList, datetimeFormat{layout: f})\n\t\t}\n\t} else {\n\t\tformatList = []datetimeFormat{\n\t\t\t{http.TimeFormat, \"RFC1123+GMT\"},\n\n\t\t\t{time.RFC850, \"RFC850\"},\n\n\t\t\t{time.ANSIC, \"ANSIC\"},\n\t\t\t{time.UnixDate, \"Unix\"},\n\t\t\t{time.RubyDate, \"Ruby\"},\n\n\t\t\t{time.RFC1123, \"RFC1123\"},\n\t\t\t{time.RFC1123Z, \"RFC1123Z\"},\n\t\t\t{time.RFC822, \"RFC822\"},\n\t\t\t{time.RFC822Z, \"RFC822Z\"},\n\t\t\t{time.RFC3339, \"RFC3339\"},\n\t\t\t{time.RFC3339Nano, \"RFC3339+nano\"},\n\t\t}\n\t}\n\n\tvar (\n\t\ttm  time.Time\n\t\terr error\n\t)\n\tfor _, f := range formatList {\n\t\ttm, err = time.Parse(f.layout, s.value)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tif len(formatList) == 1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertMatchFormat,\n\t\t\t\tActual:   &AssertionValue{s.value},\n\t\t\t\tExpected: &AssertionValue{formatList[0]},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: string can be parsed to datetime\" +\n\t\t\t\t\t\t\" with given format\"),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\tvar expectedFormats []interface{}\n\t\t\tfor _, f := range formatList {\n\t\t\t\texpectedFormats = append(expectedFormats, f)\n\t\t\t}\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertMatchFormat,\n\t\t\t\tActual:   &AssertionValue{s.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(expectedFormats)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: string can be parsed to datetime\" +\n\t\t\t\t\t\t\" with one of the formats from list\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t\treturn newDateTime(opChain, time.Unix(0, 0))\n\t}\n\n\treturn newDateTime(opChain, tm)\n}\n\ntype datetimeFormat struct {\n\tlayout string\n\tname   string\n}\n\nfunc (f datetimeFormat) String() string {\n\tif f.name != \"\" {\n\t\treturn fmt.Sprintf(\"%q (%s)\", f.layout, f.name)\n\t} else {\n\t\treturn fmt.Sprintf(\"%q\", f.layout)\n\t}\n}\n\n// Deprecated: use AsNumber instead.\nfunc (s *String) Number() *Number {\n\treturn s.AsNumber()\n}\n\n// Deprecated: use AsDateTime instead.\nfunc (s *String) DateTime(layout ...string) *DateTime {\n\treturn s.AsDateTime(layout...)\n}\n"
        },
        {
          "name": "string_test.go",
          "type": "blob",
          "size": 20.0068359375,
          "content": "package httpexpect\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestString_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\tvalue := newString(chain, \"\")\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Path(\"$\").chain.assert(t, failure)\n\tvalue.Schema(\"\")\n\tvalue.Alias(\"foo\")\n\n\tvar target interface{}\n\tvalue.Decode(target)\n\n\tvalue.Length().chain.assert(t, failure)\n\n\tvalue.IsEmpty()\n\tvalue.NotEmpty()\n\tvalue.IsEqual(\"\")\n\tvalue.NotEqual(\"\")\n\tvalue.IsEqualFold(\"\")\n\tvalue.NotEqualFold(\"\")\n\tvalue.InList(\"\")\n\tvalue.NotInList(\"\")\n\tvalue.InListFold(\"\")\n\tvalue.NotInListFold(\"\")\n\tvalue.Contains(\"\")\n\tvalue.NotContains(\"\")\n\tvalue.ContainsFold(\"\")\n\tvalue.NotContainsFold(\"\")\n\tvalue.HasPrefix(\"\")\n\tvalue.NotHasPrefix(\"\")\n\tvalue.HasSuffix(\"\")\n\tvalue.NotHasSuffix(\"\")\n\tvalue.HasPrefixFold(\"\")\n\tvalue.NotHasPrefixFold(\"\")\n\tvalue.HasSuffixFold(\"\")\n\tvalue.NotHasSuffixFold(\"\")\n\tvalue.IsASCII()\n\tvalue.NotASCII()\n\n\tvalue.Match(\"\").chain.assert(t, failure)\n\tvalue.NotMatch(\"\")\n\tassert.NotNil(t, value.MatchAll(\"\"))\n\tassert.Equal(t, 0, len(value.MatchAll(\"\")))\n\n\tvalue.AsBoolean().chain.assert(t, failure)\n\tvalue.AsNumber().chain.assert(t, failure)\n\tvalue.AsDateTime().chain.assert(t, failure)\n}\n\nfunc TestString_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewString(reporter, \"Hello\")\n\t\tvalue.IsEqual(\"Hello\")\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewStringC(Config{\n\t\t\tReporter: reporter,\n\t\t}, \"Hello\")\n\t\tvalue.IsEqual(\"Hello\")\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newString(chain, \"Hello\")\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestString_Raw(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewString(reporter, \"foo\")\n\n\tassert.Equal(t, \"foo\", value.Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestString_Decode(t *testing.T) {\n\tt.Run(\"target is empty interface\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"foo\")\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, \"foo\", target)\n\t})\n\n\tt.Run(\"target is string\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"foo\")\n\n\t\tvar target string\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, \"foo\", target)\n\t})\n\n\tt.Run(\"target is unmarshable\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"foo\")\n\n\t\tvalue.Decode(123)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n\n\tt.Run(\"target is nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"foo\")\n\n\t\tvalue.Decode(nil)\n\n\t\tvalue.chain.assert(t, failure)\n\t})\n}\n\nfunc TestString_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewString(reporter, \"123\")\n\tassert.Equal(t, []string{\"String()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"String()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"String()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.AsNumber()\n\tassert.Equal(t, []string{\"String()\", \"AsNumber()\"}, childValue.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\", \"AsNumber()\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestString_Path(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewString(reporter, \"foo\")\n\n\tassert.Equal(t, \"foo\", value.Path(\"$\").Raw())\n\tvalue.chain.assert(t, success)\n}\n\nfunc TestString_Schema(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tNewString(reporter, \"foo\").Schema(`{\"type\": \"string\"}`).\n\t\tchain.assert(t, success)\n\n\tNewString(reporter, \"foo\").Schema(`{\"type\": \"object\"}`).\n\t\tchain.assert(t, failure)\n}\n\nfunc TestString_Getters(t *testing.T) {\n\tt.Run(\"length\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"foo\")\n\n\t\tinnerValue := value.Length()\n\t\tassert.Equal(t, 3.0, innerValue.Raw())\n\n\t\tvalue.chain.assert(t, success)\n\t\tinnerValue.chain.assert(t, success)\n\t})\n}\n\nfunc TestString_IsEmpty(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tstr       string\n\t\twantEmpty chainResult\n\t}{\n\t\t{\n\t\t\tname:      \"empty string\",\n\t\t\tstr:       \"\",\n\t\t\twantEmpty: success,\n\t\t},\n\t\t{\n\t\t\tname:      \"non-empty string\",\n\t\t\tstr:       \"foo\",\n\t\t\twantEmpty: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewString(reporter, tc.str).IsEmpty().\n\t\t\t\tchain.assert(t, tc.wantEmpty)\n\n\t\t\tNewString(reporter, tc.str).NotEmpty().\n\t\t\t\tchain.assert(t, !tc.wantEmpty)\n\t\t})\n\t}\n}\n\nfunc TestString_IsEqual(t *testing.T) {\n\tcases := []struct {\n\t\tname          string\n\t\tstr           string\n\t\tvalue         string\n\t\twantEqual     chainResult\n\t\twantEqualFold chainResult\n\t}{\n\t\t{\n\t\t\tname:          \"equivalent string\",\n\t\t\tstr:           \"foo\",\n\t\t\tvalue:         \"foo\",\n\t\t\twantEqual:     success,\n\t\t\twantEqualFold: success,\n\t\t},\n\t\t{\n\t\t\tname:          \"non-equivalent string\",\n\t\t\tstr:           \"foo\",\n\t\t\tvalue:         \"bar\",\n\t\t\twantEqual:     failure,\n\t\t\twantEqualFold: failure,\n\t\t},\n\t\t{\n\t\t\tname:          \"different case\",\n\t\t\tstr:           \"foo\",\n\t\t\tvalue:         \"FOO\",\n\t\t\twantEqual:     failure,\n\t\t\twantEqualFold: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\treporter := newMockReporter(t)\n\n\t\tNewString(reporter, tc.str).IsEqual(tc.value).\n\t\t\tchain.assert(t, tc.wantEqual)\n\t\tNewString(reporter, tc.str).NotEqual(tc.value).\n\t\t\tchain.assert(t, !tc.wantEqual)\n\n\t\tNewString(reporter, tc.str).IsEqualFold(tc.value).\n\t\t\tchain.assert(t, tc.wantEqualFold)\n\t\tNewString(reporter, tc.str).NotEqualFold(tc.value).\n\t\t\tchain.assert(t, !tc.wantEqualFold)\n\t}\n}\n\nfunc TestString_InList(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname           string\n\t\t\tstr            string\n\t\t\tvalue          []string\n\t\t\twantInList     chainResult\n\t\t\twantInListFold chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:           \"in list\",\n\t\t\t\tstr:            \"foo\",\n\t\t\t\tvalue:          []string{\"foo\", \"bar\"},\n\t\t\t\twantInList:     success,\n\t\t\t\twantInListFold: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"not in list\",\n\t\t\t\tstr:            \"baz\",\n\t\t\t\tvalue:          []string{\"foo\", \"bar\"},\n\t\t\t\twantInList:     failure,\n\t\t\t\twantInListFold: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:           \"different case\",\n\t\t\t\tstr:            \"FOO\",\n\t\t\t\tvalue:          []string{\"foo\", \"bar\"},\n\t\t\t\twantInList:     failure,\n\t\t\t\twantInListFold: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewString(reporter, tc.str).InList(tc.value...).\n\t\t\t\tchain.assert(t, tc.wantInList)\n\t\t\tNewString(reporter, tc.str).NotInList(tc.value...).\n\t\t\t\tchain.assert(t, !tc.wantInList)\n\n\t\t\tNewString(reporter, tc.str).InListFold(tc.value...).\n\t\t\t\tchain.assert(t, tc.wantInListFold)\n\t\t\tNewString(reporter, tc.str).NotInListFold(tc.value...).\n\t\t\t\tchain.assert(t, !tc.wantInListFold)\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewString(reporter, \"foo\").InList().\n\t\t\tchain.assert(t, failure)\n\t\tNewString(reporter, \"foo\").NotInList().\n\t\t\tchain.assert(t, failure)\n\n\t\tNewString(reporter, \"foo\").InListFold().\n\t\t\tchain.assert(t, failure)\n\t\tNewString(reporter, \"foo\").NotInListFold().\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestString_Contains(t *testing.T) {\n\tcases := []struct {\n\t\tname             string\n\t\tstr              string\n\t\tvalue            string\n\t\twantContains     chainResult\n\t\twantContainsFold chainResult\n\t}{\n\t\t{\n\t\t\tname:             \"contains\",\n\t\t\tstr:              \"11-foo-22\",\n\t\t\tvalue:            \"foo\",\n\t\t\twantContains:     success,\n\t\t\twantContainsFold: success,\n\t\t},\n\t\t{\n\t\t\tname:             \"not contains\",\n\t\t\tstr:              \"11-foo-22\",\n\t\t\tvalue:            \"bar\",\n\t\t\twantContains:     failure,\n\t\t\twantContainsFold: failure,\n\t\t},\n\t\t{\n\t\t\tname:             \"different case\",\n\t\t\tstr:              \"11-foo-22\",\n\t\t\tvalue:            \"FOO\",\n\t\t\twantContains:     failure,\n\t\t\twantContainsFold: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\treporter := newMockReporter(t)\n\n\t\tNewString(reporter, tc.str).Contains(tc.value).\n\t\t\tchain.assert(t, tc.wantContains)\n\t\tNewString(reporter, tc.str).NotContains(tc.value).\n\t\t\tchain.assert(t, !tc.wantContains)\n\n\t\tNewString(reporter, tc.str).ContainsFold(tc.value).\n\t\t\tchain.assert(t, tc.wantContainsFold)\n\t\tNewString(reporter, tc.str).NotContainsFold(tc.value).\n\t\t\tchain.assert(t, !tc.wantContainsFold)\n\t}\n}\n\nfunc TestString_HasPrefix(t *testing.T) {\n\tcases := []struct {\n\t\tname              string\n\t\tstr               string\n\t\tvalue             string\n\t\twantHasPrefix     chainResult\n\t\twantHasPrefixFold chainResult\n\t}{\n\t\t{\n\t\t\tname:              \"has prefix\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"Hello\",\n\t\t\twantHasPrefix:     success,\n\t\t\twantHasPrefixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"full match\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"Hello World\",\n\t\t\twantHasPrefix:     success,\n\t\t\twantHasPrefixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"empty string\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"\",\n\t\t\twantHasPrefix:     success,\n\t\t\twantHasPrefixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"extra char\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"Hello!\",\n\t\t\twantHasPrefix:     failure,\n\t\t\twantHasPrefixFold: failure,\n\t\t},\n\t\t{\n\t\t\tname:              \"different case\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"hell\",\n\t\t\twantHasPrefix:     failure,\n\t\t\twantHasPrefixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"different case extra char\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"hella\",\n\t\t\twantHasPrefix:     failure,\n\t\t\twantHasPrefixFold: failure,\n\t\t},\n\t\t{\n\t\t\tname:              \"different case full match\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"hELLO wORLD\",\n\t\t\twantHasPrefix:     failure,\n\t\t\twantHasPrefixFold: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\treporter := newMockReporter(t)\n\n\t\tNewString(reporter, tc.str).HasPrefix(tc.value).\n\t\t\tchain.assert(t, tc.wantHasPrefix)\n\t\tNewString(reporter, tc.str).NotHasPrefix(tc.value).\n\t\t\tchain.assert(t, !tc.wantHasPrefix)\n\n\t\tNewString(reporter, tc.str).HasPrefixFold(tc.value).\n\t\t\tchain.assert(t, tc.wantHasPrefixFold)\n\t\tNewString(reporter, tc.str).NotHasPrefixFold(tc.value).\n\t\t\tchain.assert(t, !tc.wantHasPrefixFold)\n\t}\n}\n\nfunc TestString_HasSuffix(t *testing.T) {\n\tcases := []struct {\n\t\tname              string\n\t\tstr               string\n\t\tvalue             string\n\t\twantHasSuffix     chainResult\n\t\twantHasSuffixFold chainResult\n\t}{\n\t\t{\n\t\t\tname:              \"has suffix\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"World\",\n\t\t\twantHasSuffix:     success,\n\t\t\twantHasSuffixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"full match\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"Hello World\",\n\t\t\twantHasSuffix:     success,\n\t\t\twantHasSuffixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"empty string\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"\",\n\t\t\twantHasSuffix:     success,\n\t\t\twantHasSuffixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"extra char\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"!World\",\n\t\t\twantHasSuffix:     failure,\n\t\t\twantHasSuffixFold: failure,\n\t\t},\n\t\t{\n\t\t\tname:              \"different case\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"WORLD\",\n\t\t\twantHasSuffix:     failure,\n\t\t\twantHasSuffixFold: success,\n\t\t},\n\t\t{\n\t\t\tname:              \"different case extra char\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"!WORLD\",\n\t\t\twantHasSuffix:     failure,\n\t\t\twantHasSuffixFold: failure,\n\t\t},\n\t\t{\n\t\t\tname:              \"different case full match\",\n\t\t\tstr:               \"Hello World\",\n\t\t\tvalue:             \"hELLO wORLD\",\n\t\t\twantHasSuffix:     failure,\n\t\t\twantHasSuffixFold: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\treporter := newMockReporter(t)\n\n\t\tNewString(reporter, tc.str).HasSuffix(tc.value).\n\t\t\tchain.assert(t, tc.wantHasSuffix)\n\t\tNewString(reporter, tc.str).NotHasSuffix(tc.value).\n\t\t\tchain.assert(t, !tc.wantHasSuffix)\n\n\t\tNewString(reporter, tc.str).HasSuffixFold(tc.value).\n\t\t\tchain.assert(t, tc.wantHasSuffixFold)\n\t\tNewString(reporter, tc.str).NotHasSuffixFold(tc.value).\n\t\t\tchain.assert(t, !tc.wantHasSuffixFold)\n\t}\n}\n\nfunc TestString_Match(t *testing.T) {\n\tt.Run(\"named\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"http://example.com/users/john\")\n\n\t\tm := value.Match(`http://(?P<host>.+)/users/(?P<user>.+)`)\n\t\tm.chain.assert(t, success)\n\n\t\tassert.Equal(t,\n\t\t\t[]string{\"http://example.com/users/john\", \"example.com\", \"john\"},\n\t\t\tm.submatchValues)\n\t})\n\n\tt.Run(\"unnamed\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter, \"http://example.com/users/john\")\n\n\t\tm := value.Match(`http://(.+)/users/(.+)`)\n\t\tm.chain.assert(t, success)\n\n\t\tassert.Equal(t,\n\t\t\t[]string{\"http://example.com/users/john\", \"example.com\", \"john\"},\n\t\t\tm.submatchValues)\n\t})\n\n\tt.Run(\"all\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewString(reporter,\n\t\t\t\"http://example.com/users/john http://example.com/users/bob\")\n\n\t\tm := value.MatchAll(`http://(\\S+)/users/(\\S+)`)\n\n\t\tassert.Equal(t, 2, len(m))\n\n\t\tm[0].chain.assert(t, success)\n\t\tm[1].chain.assert(t, success)\n\n\t\tassert.Equal(t,\n\t\t\t[]string{\"http://example.com/users/john\", \"example.com\", \"john\"},\n\t\t\tm[0].submatchValues)\n\n\t\tassert.Equal(t,\n\t\t\t[]string{\"http://example.com/users/bob\", \"example.com\", \"bob\"},\n\t\t\tm[1].submatchValues)\n\t})\n\n\tt.Run(\"status\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tstr          string\n\t\t\tre           string\n\t\t\twantMatch    chainResult\n\t\t\twantNotMatch chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tstr:          `a`,\n\t\t\t\tre:           `a`,\n\t\t\t\twantMatch:    success,\n\t\t\t\twantNotMatch: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tstr:          `a`,\n\t\t\t\tre:           `[^a]`,\n\t\t\t\twantMatch:    failure,\n\t\t\t\twantNotMatch: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tstr:          `a`,\n\t\t\t\tre:           `[`,\n\t\t\t\twantMatch:    failure,\n\t\t\t\twantNotMatch: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.str, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tvar value *String\n\n\t\t\t\tvalue = NewString(reporter, tc.str)\n\t\t\t\tvalue.Match(tc.re).chain.assert(t, tc.wantMatch)\n\t\t\t\tvalue.chain.assert(t, tc.wantMatch)\n\n\t\t\t\tvalue = NewString(reporter, tc.str)\n\t\t\t\tvalue.MatchAll(tc.re)\n\t\t\t\tvalue.chain.assert(t, tc.wantMatch)\n\n\t\t\t\tvalue = NewString(reporter, tc.str)\n\t\t\t\tvalue.NotMatch(tc.re)\n\t\t\t\tvalue.chain.assert(t, tc.wantNotMatch)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestString_IsAscii(t *testing.T) {\n\tcases := []struct {\n\t\tstr         string\n\t\twantIsASCII chainResult\n\t}{\n\t\t{\"Ascii\", success},\n\t\t{string(rune(127)), success},\n\t\t{\"Ascii is アスキー\", failure},\n\t\t{\"アスキー\", failure},\n\t\t{string(rune(128)), failure},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.str, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewString(reporter, tc.str).IsASCII().\n\t\t\t\tchain.assert(t, tc.wantIsASCII)\n\n\t\t\tNewString(reporter, tc.str).NotASCII().\n\t\t\t\tchain.assert(t, !tc.wantIsASCII)\n\t\t})\n\t}\n}\n\nfunc TestString_AsNumber(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\tstr         string\n\t\tbase        []int\n\t\tresult      chainResult\n\t\texpectedNum float64\n\t}{\n\t\t{\n\t\t\tname:        \"default base integer\",\n\t\t\tstr:         \"1234567\",\n\t\t\tresult:      success,\n\t\t\texpectedNum: float64(1234567),\n\t\t},\n\t\t{\n\t\t\tname:        \"default base float\",\n\t\t\tstr:         \"11.22\",\n\t\t\tresult:      success,\n\t\t\texpectedNum: float64(11.22),\n\t\t},\n\t\t{\n\t\t\tname:   \"default base bad\",\n\t\t\tstr:    \"a1\",\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"base10 integer\",\n\t\t\tstr:         \"100\",\n\t\t\tbase:        []int{10},\n\t\t\tresult:      success,\n\t\t\texpectedNum: float64(100),\n\t\t},\n\t\t{\n\t\t\tname:        \"base10 float\",\n\t\t\tstr:         \"11.22\",\n\t\t\tbase:        []int{10},\n\t\t\tresult:      success,\n\t\t\texpectedNum: float64(11.22),\n\t\t},\n\t\t{\n\t\t\tname:        \"base16 integer\",\n\t\t\tstr:         \"100\",\n\t\t\tbase:        []int{16},\n\t\t\tresult:      success,\n\t\t\texpectedNum: float64(0x100),\n\t\t},\n\t\t{\n\t\t\tname:   \"base16 float\",\n\t\t\tstr:    \"11.22\",\n\t\t\tbase:   []int{16},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"base16 large integer\",\n\t\t\tstr:         \"4000000000000000\",\n\t\t\tbase:        []int{16},\n\t\t\tresult:      success,\n\t\t\texpectedNum: float64(0x4000000000000000),\n\t\t},\n\t\t{\n\t\t\tname:   \"default float precision max\",\n\t\t\tstr:    \"4611686018427387905\",\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"base10 float precision max\",\n\t\t\tstr:    \"4611686018427387905\",\n\t\t\tbase:   []int{10},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"base16 float precision max\",\n\t\t\tstr:    \"8000000000000001\",\n\t\t\tbase:   []int{16},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"base16 float precision min\",\n\t\t\tstr:    \"-4000000000000001\",\n\t\t\tbase:   []int{16},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname:   \"multiple bases\",\n\t\t\tstr:    \"100\",\n\t\t\tbase:   []int{10, 16},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tstr := NewString(reporter, tc.str)\n\t\t\tnum := str.AsNumber(tc.base...)\n\n\t\t\tstr.chain.assert(t, tc.result)\n\t\t\tnum.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.expectedNum, num.Raw())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, float64(0), num.Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestString_AsBoolean(t *testing.T) {\n\ttrueValues := []string{\"true\", \"True\"}\n\tfalseValues := []string{\"false\", \"False\"}\n\tbadValues := []string{\"TRUE\", \"FALSE\", \"t\", \"f\", \"1\", \"0\", \"bad\"}\n\n\tfor _, str := range trueValues {\n\t\tt.Run(str, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tvalue := NewString(reporter, str)\n\n\t\t\tb := value.AsBoolean()\n\t\t\tb.chain.assert(t, success)\n\n\t\t\tassert.True(t, b.Raw())\n\t\t})\n\t}\n\n\tfor _, str := range falseValues {\n\t\tt.Run(str, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tvalue := NewString(reporter, str)\n\n\t\t\tb := value.AsBoolean()\n\t\t\tb.chain.assert(t, success)\n\n\t\t\tassert.False(t, b.Raw())\n\t\t})\n\t}\n\n\tfor _, str := range badValues {\n\t\tt.Run(str, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tvalue := NewString(reporter, str)\n\n\t\t\tb := value.AsBoolean()\n\t\t\tb.chain.assert(t, failure)\n\t\t})\n\t}\n}\n\nfunc TestString_AsDateTime(t *testing.T) {\n\tt.Run(\"default formats - RFC1123+GMT\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewString(reporter, \"Tue, 15 Nov 1994 08:12:31 GMT\")\n\n\t\tdt := value.AsDateTime()\n\t\tvalue.chain.assert(t, success)\n\t\tdt.chain.assert(t, success)\n\n\t\tassert.True(t, time.Date(1994, 11, 15, 8, 12, 31, 0, time.UTC).Equal(dt.Raw()))\n\t})\n\n\tt.Run(\"RFC822\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewString(reporter, \"15 Nov 94 08:12 GMT\")\n\n\t\tdt := value.AsDateTime(time.RFC822)\n\t\tvalue.chain.assert(t, success)\n\t\tdt.chain.assert(t, success)\n\n\t\tassert.True(t, time.Date(1994, 11, 15, 8, 12, 0, 0, time.UTC).Equal(dt.Raw()))\n\t})\n\n\tt.Run(\"bad input\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewString(reporter, \"bad\")\n\n\t\tdt := value.AsDateTime()\n\t\tvalue.chain.assert(t, failure)\n\t\tdt.chain.assert(t, failure)\n\n\t\tassert.True(t, time.Unix(0, 0).Equal(dt.Raw()))\n\t})\n\n\tformats := []string{\n\t\thttp.TimeFormat,\n\t\ttime.RFC850,\n\t\ttime.ANSIC,\n\t\ttime.UnixDate,\n\t\ttime.RubyDate,\n\t\ttime.RFC1123,\n\t\ttime.RFC1123Z,\n\t\ttime.RFC822,\n\t\ttime.RFC822Z,\n\t\ttime.RFC3339,\n\t\ttime.RFC3339Nano,\n\t}\n\n\tfor n, f := range formats {\n\t\tt.Run(\"default formats - \"+f, func(t *testing.T) {\n\t\t\tstr := time.Now().Format(f)\n\n\t\t\treporter := newMockReporter(t)\n\t\t\tvalue := NewString(reporter, str)\n\n\t\t\tdt := value.AsDateTime()\n\t\t\tdt.chain.assert(t, success)\n\t\t})\n\n\t\tt.Run(\"all formats - \"+f, func(t *testing.T) {\n\t\t\tstr := time.Now().Format(f)\n\n\t\t\treporter := newMockReporter(t)\n\t\t\tvalue := NewString(reporter, str)\n\n\t\t\tdt := value.AsDateTime(formats...)\n\t\t\tdt.chain.assert(t, success)\n\t\t})\n\n\t\tt.Run(\"same format - \"+f, func(t *testing.T) {\n\t\t\tstr := time.Now().Format(f)\n\n\t\t\treporter := newMockReporter(t)\n\t\t\tvalue := NewString(reporter, str)\n\n\t\t\tdt := value.AsDateTime(f)\n\t\t\tdt.chain.assert(t, success)\n\t\t})\n\n\t\tif n != 0 {\n\t\t\tt.Run(\"different format - \"+f, func(t *testing.T) {\n\t\t\t\tstr := time.Now().Format(f)\n\n\t\t\t\treporter := newMockReporter(t)\n\t\t\t\tvalue := NewString(reporter, str)\n\n\t\t\t\tdt := value.AsDateTime(formats[0])\n\t\t\t\tdt.chain.assert(t, failure)\n\t\t\t})\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 19.8544921875,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n)\n\n// Value provides methods to inspect attached interface{} object\n// (Go representation of arbitrary JSON value) and cast it to\n// concrete type.\ntype Value struct {\n\tchain *chain\n\tvalue interface{}\n}\n\n// NewValue returns a new Value instance.\n//\n// If reporter is nil, the function panics.\n// Value may be nil.\n//\n// Example:\n//\n//\tvalue := NewValue(t, map[string]interface{}{\"foo\": 123})\n//\tvalue.IsObject()\n//\n//\tvalue := NewValue(t, []interface{}{\"foo\", 123})\n//\tvalue.IsArray()\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.IsString()\n//\n//\tvalue := NewValue(t, 123)\n//\tvalue.IsNumber()\n//\n//\tvalue := NewValue(t, true)\n//\tvalue.IsBoolean()\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.IsNull()\nfunc NewValue(reporter Reporter, value interface{}) *Value {\n\treturn newValue(newChainWithDefaults(\"Value()\", reporter), value)\n}\n\n// NewValueC returns a new Value instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// Value may be nil.\n//\n// See NewValue for usage example.\nfunc NewValueC(config Config, value interface{}) *Value {\n\treturn newValue(newChainWithConfig(\"Value()\", config.withDefaults()), value)\n}\n\nfunc newValue(parent *chain, val interface{}) *Value {\n\tv := &Value{parent.clone(), nil}\n\n\topChain := v.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\tif val != nil {\n\t\tv.value, _ = canonValue(opChain, val)\n\t}\n\n\treturn v\n}\n\n// Raw returns underlying value attached to Value.\n// This is the value originally passed to NewValue, converted to canonical form.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tassert.Equal(t, \"foo\", number.Raw().(string))\nfunc (v *Value) Raw() interface{} {\n\treturn v.value\n}\n\n// Decode unmarshals the underlying value attached to the Object to a target variable\n// target should be pointer to any type.\n//\n// Example:\n//\n//\ttype S struct {\n//\t\tFoo int             `json:\"foo\"`\n//\t\tBar []interface{}   `json:\"bar\"`\n//\t\tBaz struct{ A int } `json:\"baz\"`\n//\t}\n//\n//\tm := map[string]interface{}{\n//\t\t\"foo\": 123,\n//\t\t\"bar\": []interface{}{\"123\", 456.0},\n//\t\t\"baz\": struct{ A int }{123},\n//\t}\n//\n//\tvalue = NewValue(reporter,m)\n//\n//\tvar target S\n//\tvalue.Decode(&target)\n//\n//\tassert.Equal(t, S{123, []interface{}{\"123\", 456.0}, struct{ A int }{123}, target})\nfunc (v *Value) Decode(target interface{}) *Value {\n\topChain := v.chain.enter(\"Decode()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tcanonDecode(opChain, v.value, target)\n\treturn v\n}\n\n// Alias returns a new Value object with alias.\n// When a test of Value object with alias is failed,\n// an assertion is displayed as a chain starting from the alias.\n//\n// Example:\n//\n//\t// In this example, GET /example responds \"foo\"\n//\tfoo := e.GET(\"/example\").Expect().Status(http.StatusOK).JSON().Object()\n//\n//\t// When a test is failed, an assertion without alias is\n//\t// Request(\"GET\").Expect().JSON().Object().IsEqual()\n//\tfoo.IsEqual(\"bar\")\n//\n//\t// Set Alias\n//\tfooWithAlias := e.GET(\"/example\").\n//\t\tExpect().\n//\t\tStatus(http.StatusOK).JSON().Object().Alias(\"foo\")\n//\n//\t// When a test is failed, an assertion with alias is\n//\t// foo.IsEqual()\n//\tfooWithAlias.IsEqual(\"bar\")\nfunc (v *Value) Alias(name string) *Value {\n\topChain := v.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tv.chain.setAlias(name)\n\treturn v\n}\n\n// Path returns a new Value object for child object(s) matching given\n// JSONPath expression.\n//\n// JSONPath is a simple XPath-like query language.\n// See http://goessner.net/articles/JsonPath/.\n//\n// We currently use https://github.com/yalp/jsonpath, which implements\n// only a subset of JSONPath, yet useful for simple queries. It doesn't\n// support filters and requires double quotes for strings.\n//\n// Example 1:\n//\n//\tjson := `{\"users\": [{\"name\": \"john\"}, {\"name\": \"bob\"}]}`\n//\tvalue := NewValue(t, json)\n//\n//\tvalue.Path(\"$.users[0].name\").String().IsEqual(\"john\")\n//\tvalue.Path(\"$.users[1].name\").String().IsEqual(\"bob\")\n//\n// Example 2:\n//\n//\tjson := `{\"yfGH2a\": {\"user\": \"john\"}, \"f7GsDd\": {\"user\": \"john\"}}`\n//\tvalue := NewValue(t, json)\n//\n//\tfor _, user := range value.Path(\"$..user\").Array().Iter() {\n//\t\tuser.String().IsEqual(\"john\")\n//\t}\nfunc (v *Value) Path(path string) *Value {\n\topChain := v.chain.enter(\"Path(%q)\", path)\n\tdefer opChain.leave()\n\n\treturn jsonPath(opChain, v.value, path)\n}\n\n// Schema succeeds if value matches given JSON Schema.\n//\n// JSON Schema specifies a JSON-based format to define the structure of\n// JSON data. See http://json-schema.org/.\n// We use https://github.com/xeipuuv/gojsonschema implementation.\n//\n// schema should be one of the following:\n//   - go value that can be json.Marshal-ed to a valid schema\n//   - type convertible to string containing valid schema\n//   - type convertible to string containing valid http:// or file:// URI,\n//     pointing to reachable and valid schema\n//\n// Example 1:\n//\n//\t schema := `{\n//\t   \"type\": \"object\",\n//\t   \"properties\": {\n//\t\t  \"foo\": {\n//\t\t\t  \"type\": \"string\"\n//\t\t  },\n//\t\t  \"bar\": {\n//\t\t\t  \"type\": \"integer\"\n//\t\t  }\n//\t  },\n//\t  \"require\": [\"foo\", \"bar\"]\n//\t}`\n//\n//\tvalue := NewValue(t, map[string]interface{}{\n//\t\t\"foo\": \"a\",\n//\t\t\"bar\": 1,\n//\t})\n//\n//\tvalue.Schema(schema)\n//\n// Example 2:\n//\n//\tvalue := NewValue(t, data)\n//\tvalue.Schema(\"http://example.com/schema.json\")\nfunc (v *Value) Schema(schema interface{}) *Value {\n\topChain := v.chain.enter(\"Schema()\")\n\tdefer opChain.leave()\n\n\tjsonSchema(opChain, v.value, schema)\n\treturn v\n}\n\n// Object returns a new Object attached to underlying value.\n//\n// If underlying value is not an object (map[string]interface{}), failure is reported\n// and empty (but non-nil) value is returned.\n//\n// Example:\n//\n//\tvalue := NewValue(t, map[string]interface{}{\"foo\": 123})\n//\tvalue.Object().ContainsKey(\"foo\")\nfunc (v *Value) Object() *Object {\n\topChain := v.chain.enter(\"Object()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newObject(opChain, nil)\n\t}\n\n\tdata, ok := v.value.(map[string]interface{})\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is object\"),\n\t\t\t},\n\t\t})\n\t\treturn newObject(opChain, nil)\n\t}\n\n\treturn newObject(opChain, data)\n}\n\n// Array returns a new Array attached to underlying value.\n//\n// If underlying value is not an array ([]interface{}), failure is reported and empty\n// (but non-nil) value is returned.\n//\n// Example:\n//\n//\tvalue := NewValue(t, []interface{}{\"foo\", 123})\n//\tvalue.Array().ConsistsOf(\"foo\", 123)\nfunc (v *Value) Array() *Array {\n\topChain := v.chain.enter(\"Array()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newArray(opChain, nil)\n\t}\n\n\tdata, ok := v.value.([]interface{})\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is array\"),\n\t\t\t},\n\t\t})\n\t\treturn newArray(opChain, nil)\n\t}\n\n\treturn newArray(opChain, data)\n}\n\n// String returns a new String attached to underlying value.\n//\n// If underlying value is not a string, failure is reported and empty (but non-nil)\n// value is returned.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.String().IsEqualFold(\"FOO\")\nfunc (v *Value) String() *String {\n\topChain := v.chain.enter(\"String()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tdata, ok := v.value.(string)\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is string\"),\n\t\t\t},\n\t\t})\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, data)\n}\n\n// Number returns a new Number attached to underlying value.\n//\n// If underlying value is not a number (numeric type convertible to float64), failure\n// is reported and empty (but non-nil) value is returned.\n//\n// Example:\n//\n//\tvalue := NewValue(t, 123)\n//\tvalue.Number().InRange(100, 200)\nfunc (v *Value) Number() *Number {\n\topChain := v.chain.enter(\"Number()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\tdata, ok := v.value.(float64)\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is number\"),\n\t\t\t},\n\t\t})\n\t\treturn newNumber(opChain, 0)\n\t}\n\n\treturn newNumber(opChain, data)\n}\n\n// Boolean returns a new Boolean attached to underlying value.\n//\n// If underlying value is not a bool, failure is reported and empty (but non-nil)\n// value is returned.\n//\n// Example:\n//\n//\tvalue := NewValue(t, true)\n//\tvalue.Boolean().IsTrue()\nfunc (v *Value) Boolean() *Boolean {\n\topChain := v.chain.enter(\"Boolean()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newBoolean(opChain, false)\n\t}\n\n\tdata, ok := v.value.(bool)\n\n\tif !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is boolean\"),\n\t\t\t},\n\t\t})\n\t\treturn newBoolean(opChain, false)\n\t}\n\n\treturn newBoolean(opChain, data)\n}\n\n// IsNull succeeds if value is nil.\n//\n// Note that non-nil interface{} that points to nil value (e.g. nil slice or map)\n// is also treated as null value. Empty (non-nil) slice or map, empty string, and\n// zero number are not treated as null value.\n//\n// Example:\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.IsNull()\n//\n//\tvalue := NewValue(t, []interface{}(nil))\n//\tvalue.IsNull()\nfunc (v *Value) IsNull() *Value {\n\topChain := v.chain.enter(\"IsNull()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif !(v.value == nil) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNil,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is null\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotNull succeeds if value is not nil.\n//\n// Note that non-nil interface{} that points to nil value (e.g. nil slice or map)\n// is also treated as null value. Empty (non-nil) slice or map, empty string, and\n// zero number are not treated as null value.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"\")\n//\tvalue.NotNull()\n//\n//\tvalue := NewValue(t, make([]interface{}, 0))\n//\tvalue.NotNull()\nfunc (v *Value) NotNull() *Value {\n\topChain := v.chain.enter(\"NotNull()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif v.value == nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertNotNil,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is non-null\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// Deprecated: use IsNull instead.\nfunc (v *Value) Null() *Value {\n\treturn v.IsNull()\n}\n\n// IsObject succeeds if the underlying value is an object.\n//\n// If underlying value is not an object (map[string]interface{}), failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, map[string]interface{}{\"foo\": 123})\n//\tvalue.IsObject()\nfunc (v *Value) IsObject() *Value {\n\topChain := v.chain.enter(\"IsObject()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(map[string]interface{}); !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is object\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotObject succeeds if the underlying value is not an object.\n//\n// If underlying value is an object (map[string]interface{}), failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.NotObject()\nfunc (v *Value) NotObject() *Value {\n\topChain := v.chain.enter(\"NotObject()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(map[string]interface{}); ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is not object\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// IsArray succeeds if the underlying value is an array.\n//\n// If underlying value is not an array ([]interface{}), failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, []interface{}{\"foo\", \"123\"})\n//\tvalue.IsArray()\nfunc (v *Value) IsArray() *Value {\n\topChain := v.chain.enter(\"IsArray()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.([]interface{}); !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is array\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotArray succeeds if the underlying value is not an array.\n//\n// If underlying value is an array ([]interface{}), failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.NotArray()\nfunc (v *Value) NotArray() *Value {\n\topChain := v.chain.enter(\"NotArray()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.([]interface{}); ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is not array\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// IsString succeeds if the underlying value is a string.\n//\n// If underlying value is not a string, failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.IsString()\nfunc (v *Value) IsString() *Value {\n\topChain := v.chain.enter(\"IsString()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(string); !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is string\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotString succeeds if the underlying value is not a string.\n//\n// If underlying value is a string, failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.NotString()\nfunc (v *Value) NotString() *Value {\n\topChain := v.chain.enter(\"NotString()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(string); ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is not string\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// IsNumber succeeds if the underlying value is a number.\n//\n// If underlying value is not a number (numeric type convertible to float64),\n// failure is reported\n//\n// Example:\n//\n//\tvalue := NewValue(t, 123)\n//\tvalue.IsNumber()\nfunc (v *Value) IsNumber() *Value {\n\topChain := v.chain.enter(\"IsNumber()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(float64); !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is number\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotNumber succeeds if the underlying value is a not a number.\n//\n// If underlying value is a number (numeric type convertible to float64),\n// failure is reported\n//\n// Example:\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.NotNumber()\nfunc (v *Value) NotNumber() *Value {\n\topChain := v.chain.enter(\"NotNumber()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(float64); ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is not number\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// IsBoolean succeeds if the underlying value is a boolean.\n//\n// If underlying value is not a boolean, failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, true)\n//\tvalue.IsBoolean()\nfunc (v *Value) IsBoolean() *Value {\n\topChain := v.chain.enter(\"IsBoolean()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(bool); !ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is boolean\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotBoolean succeeds if the underlying value is not a boolean.\n//\n// If underlying value is a boolean, failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, nil)\n//\tvalue.NotBoolean()\nfunc (v *Value) NotBoolean() *Value {\n\topChain := v.chain.enter(\"NotBoolean()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif _, ok := v.value.(bool); ok {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{v.value},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is not boolean\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// IsEqual succeeds if value is equal to another value (e.g. map, slice, string, etc).\n// Before comparison, both values are converted to canonical form.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.IsEqual(\"foo\")\nfunc (v *Value) IsEqual(value interface{}) *Value {\n\topChain := v.chain.enter(\"IsEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\texpected, ok := canonValue(opChain, value)\n\tif !ok {\n\t\treturn v\n\t}\n\n\tif !reflect.DeepEqual(expected, v.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{v.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: values are equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotEqual succeeds if value is not equal to another value (e.g. map, slice,\n// string, etc). Before comparison, both values are converted to canonical form.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.NorEqual(\"bar\")\nfunc (v *Value) NotEqual(value interface{}) *Value {\n\topChain := v.chain.enter(\"NotEqual()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\texpected, ok := canonValue(opChain, value)\n\tif !ok {\n\t\treturn v\n\t}\n\n\tif reflect.DeepEqual(expected, v.value) {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertNotEqual,\n\t\t\tActual:   &AssertionValue{v.value},\n\t\t\tExpected: &AssertionValue{expected},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: values are non-equal\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// Deprecated: use IsEqual instead.\nfunc (v *Value) Equal(value interface{}) *Value {\n\treturn v.IsEqual(value)\n}\n\n// InList succeeds if whole value is equal to one of the values from given\n// list of values (e.g. map, slice, string, etc). Before comparison, all\n// values are converted to canonical form.\n//\n// If at least one value has wrong type, failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.InList(\"foo\", 123)\nfunc (v *Value) InList(values ...interface{}) *Value {\n\topChain := v.chain.enter(\"InList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn v\n\t}\n\n\tvar isListed bool\n\tfor _, val := range values {\n\t\texpected, ok := canonValue(opChain, val)\n\t\tif !ok {\n\t\t\treturn v\n\t\t}\n\n\t\tif reflect.DeepEqual(expected, v.value) {\n\t\t\tisListed = true\n\t\t\t// continue loop to check that all values are correct\n\t\t}\n\t}\n\n\tif !isListed {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertBelongs,\n\t\t\tActual:   &AssertionValue{v.value},\n\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: value is equal to one of the values\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn v\n}\n\n// NotInList succeeds if the whole value is not equal to any of the values from\n// given list of values (e.g. map, slice, string, etc).\n// Before comparison, all values are converted to canonical form.\n//\n// If at least one value has wrong type, failure is reported.\n//\n// Example:\n//\n//\tvalue := NewValue(t, \"foo\")\n//\tvalue.NotInList(\"bar\", 123)\nfunc (v *Value) NotInList(values ...interface{}) *Value {\n\topChain := v.chain.enter(\"NotInList()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn v\n\t}\n\n\tif len(values) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected empty list argument\"),\n\t\t\t},\n\t\t})\n\t\treturn v\n\t}\n\n\tfor _, val := range values {\n\t\texpected, ok := canonValue(opChain, val)\n\t\tif !ok {\n\t\t\treturn v\n\t\t}\n\n\t\tif reflect.DeepEqual(expected, v.value) {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{v.value},\n\t\t\t\tExpected: &AssertionValue{AssertionList(values)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: value is not equal to any of the values\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn v\n\t\t}\n\t}\n\n\treturn v\n}\n"
        },
        {
          "name": "value_test.go",
          "type": "blob",
          "size": 30.009765625,
          "content": "package httpexpect\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestValue_FailedChain(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\tvalue := newValue(chain, nil)\n\tvalue.chain.assert(t, failure)\n\n\tvalue.Path(\"$\").chain.assert(t, failure)\n\tvalue.Schema(\"\")\n\tvalue.Alias(\"foo\")\n\n\tvar target interface{}\n\tvalue.Decode(target)\n\n\tvalue.Object().chain.assert(t, failure)\n\tvalue.Array().chain.assert(t, failure)\n\tvalue.String().chain.assert(t, failure)\n\tvalue.Number().chain.assert(t, failure)\n\tvalue.Boolean().chain.assert(t, failure)\n\n\tvalue.IsNull()\n\tvalue.NotNull()\n\tvalue.IsObject()\n\tvalue.NotObject()\n\tvalue.IsArray()\n\tvalue.NotArray()\n\tvalue.IsString()\n\tvalue.NotString()\n\tvalue.IsNumber()\n\tvalue.NotNumber()\n\tvalue.IsBoolean()\n\tvalue.NotBoolean()\n\tvalue.IsEqual(nil)\n\tvalue.NotEqual(nil)\n\tvalue.InList(nil)\n\tvalue.NotInList(nil)\n}\n\nfunc TestValue_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewValue(reporter, \"Test\")\n\t\tvalue.IsEqual(\"Test\")\n\t\tvalue.chain.assert(t, success)\n\t\tvalue.String().chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tvalue := NewValueC(Config{\n\t\t\tReporter: reporter,\n\t\t}, \"Test\")\n\t\tvalue.IsEqual(\"Test\")\n\t\tvalue.chain.assert(t, success)\n\t\tvalue.String().chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newValue(chain, \"Test\")\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestValue_Decode(t *testing.T) {\n\tt.Run(\"target is empty interface\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, 123.0)\n\n\t\tvar target interface{}\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, 123.0, target)\n\t})\n\n\tt.Run(\"target is struct\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\ttype S struct {\n\t\t\tFoo int             `json:\"foo\"`\n\t\t\tBar []interface{}   `json:\"bar\"`\n\t\t\tBaz struct{ A int } `json:\"baz\"`\n\t\t}\n\n\t\tm := map[string]interface{}{\n\t\t\t\"foo\": 123,\n\t\t\t\"bar\": []interface{}{\"123\", 456.0},\n\t\t\t\"baz\": struct{ A int }{123},\n\t\t}\n\n\t\tvalue := NewValue(reporter, m)\n\n\t\tactualStruct := S{\n\t\t\t123,\n\t\t\t[]interface{}{\"123\", 456.0},\n\t\t\tstruct{ A int }{123},\n\t\t}\n\n\t\tvar target S\n\t\tvalue.Decode(&target)\n\n\t\tvalue.chain.assert(t, success)\n\t\tassert.Equal(t, target, actualStruct)\n\t})\n\n\tt.Run(\"target is nil\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, 123)\n\n\t\tvalue.Decode(nil)\n\n\t\tvalue.chain.failed()\n\t})\n\n\tt.Run(\"target is unmarshable\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, 123)\n\n\t\tvalue.Decode(123)\n\n\t\tvalue.chain.failed()\n\t})\n}\n\nfunc TestValue_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewValue(reporter, 123)\n\tassert.Equal(t, []string{\"Value()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Value()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Value()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.Number()\n\tassert.Equal(t, []string{\"Value()\", \"Number()\"}, childValue.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\", \"Number()\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestValue_Getters(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\tdata        interface{}\n\t\twantObject  chainResult\n\t\twantArray   chainResult\n\t\twantString  chainResult\n\t\twantNumber  chainResult\n\t\twantBoolean chainResult\n\t\twantNull    chainResult\n\t\twantInvalid chainResult\n\t}{\n\t\t{\n\t\t\tname:     \"null\",\n\t\t\tdata:     nil,\n\t\t\twantNull: success,\n\t\t},\n\t\t{\n\t\t\tname:     \"null object\",\n\t\t\tdata:     map[string]interface{}(nil),\n\t\t\twantNull: success,\n\t\t},\n\t\t{\n\t\t\tname:     \"null array\",\n\t\t\tdata:     []interface{}(nil),\n\t\t\twantNull: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"object\",\n\t\t\tdata:       map[string]interface{}{},\n\t\t\twantObject: success,\n\t\t},\n\t\t{\n\t\t\tname:      \"array\",\n\t\t\tdata:      []interface{}{},\n\t\t\twantArray: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"string\",\n\t\t\tdata:       \"\",\n\t\t\twantString: success,\n\t\t},\n\t\t{\n\t\t\tname:       \"number\",\n\t\t\tdata:       0.0,\n\t\t\twantNumber: success,\n\t\t},\n\t\t{\n\t\t\tname:        \"boolean\",\n\t\t\tdata:        false,\n\t\t\twantBoolean: success,\n\t\t},\n\t\t{\n\t\t\tname:        \"invalid\",\n\t\t\tdata:        func() {},\n\t\t\twantInvalid: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tt.Run(\"null\", func(t *testing.T) {\n\t\t\t\tNewValue(reporter, tc.data).IsNull().\n\t\t\t\t\tchain.assert(t, tc.wantNull && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).NotNull().\n\t\t\t\t\tchain.assert(t, !tc.wantNull && !tc.wantInvalid)\n\t\t\t})\n\n\t\t\tt.Run(\"object\", func(t *testing.T) {\n\t\t\t\tNewValue(reporter, tc.data).Object().\n\t\t\t\t\tchain.assert(t, tc.wantObject && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).IsObject().\n\t\t\t\t\tchain.assert(t, tc.wantObject && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).NotObject().\n\t\t\t\t\tchain.assert(t, !tc.wantObject && !tc.wantInvalid)\n\t\t\t})\n\n\t\t\tt.Run(\"array\", func(t *testing.T) {\n\t\t\t\tNewValue(reporter, tc.data).Array().\n\t\t\t\t\tchain.assert(t, tc.wantArray && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).IsArray().\n\t\t\t\t\tchain.assert(t, tc.wantArray && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).NotArray().\n\t\t\t\t\tchain.assert(t, !tc.wantArray && !tc.wantInvalid)\n\t\t\t})\n\n\t\t\tt.Run(\"string\", func(t *testing.T) {\n\t\t\t\tNewValue(reporter, tc.data).String().\n\t\t\t\t\tchain.assert(t, tc.wantString && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).IsString().\n\t\t\t\t\tchain.assert(t, tc.wantString && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).NotString().\n\t\t\t\t\tchain.assert(t, !tc.wantString && !tc.wantInvalid)\n\t\t\t})\n\n\t\t\tt.Run(\"number\", func(t *testing.T) {\n\t\t\t\tNewValue(reporter, tc.data).Number().\n\t\t\t\t\tchain.assert(t, tc.wantNumber && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).IsNumber().\n\t\t\t\t\tchain.assert(t, tc.wantNumber && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).NotNumber().\n\t\t\t\t\tchain.assert(t, !tc.wantNumber && !tc.wantInvalid)\n\t\t\t})\n\n\t\t\tt.Run(\"boolean\", func(t *testing.T) {\n\t\t\t\tNewValue(reporter, tc.data).Boolean().\n\t\t\t\t\tchain.assert(t, tc.wantBoolean && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).IsBoolean().\n\t\t\t\t\tchain.assert(t, tc.wantBoolean && !tc.wantInvalid)\n\n\t\t\t\tNewValue(reporter, tc.data).NotBoolean().\n\t\t\t\t\tchain.assert(t, !tc.wantBoolean && !tc.wantInvalid)\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestValue_GetObject(t *testing.T) {\n\ttype myMap map[string]interface{}\n\n\tcases := []struct {\n\t\tname           string\n\t\tdata           interface{}\n\t\tresult         chainResult\n\t\texpectedObject map[string]interface{}\n\t}{\n\t\t{\n\t\t\tname:           \"map\",\n\t\t\tdata:           map[string]interface{}{\"foo\": 123.0},\n\t\t\tresult:         success,\n\t\t\texpectedObject: map[string]interface{}{\"foo\": 123.0},\n\t\t},\n\t\t{\n\t\t\tname:           \"myMap\",\n\t\t\tdata:           myMap{\"foo\": 123.0},\n\t\t\tresult:         success,\n\t\t\texpectedObject: map[string]interface{}(myMap{\"foo\": 123.0}),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, tc.data)\n\t\t\tinner := value.Object()\n\n\t\t\tinner.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.expectedObject, inner.Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue_GetArray(t *testing.T) {\n\ttype myArray []interface{}\n\n\tcases := []struct {\n\t\tname          string\n\t\tdata          interface{}\n\t\tresult        chainResult\n\t\texpectedArray []interface{}\n\t}{\n\t\t{\n\t\t\tname:          \"array\",\n\t\t\tdata:          []interface{}{\"foo\", 123.0},\n\t\t\tresult:        success,\n\t\t\texpectedArray: []interface{}{\"foo\", 123.0},\n\t\t},\n\t\t{\n\t\t\tname:          \"myArray\",\n\t\t\tdata:          myArray{\"foo\", 123.0},\n\t\t\tresult:        success,\n\t\t\texpectedArray: []interface{}(myArray{\"foo\", 123.0}),\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, tc.data)\n\t\t\tinner := value.Array()\n\n\t\t\tvalue.chain.assert(t, tc.result)\n\t\t\tinner.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.expectedArray, inner.Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue_GetString(t *testing.T) {\n\ttype myString string\n\n\tcases := []struct {\n\t\tname           string\n\t\tdata           interface{}\n\t\tresult         chainResult\n\t\texpectedString string\n\t}{\n\t\t{\n\t\t\tname:           \"string\",\n\t\t\tdata:           \"foo\",\n\t\t\tresult:         success,\n\t\t\texpectedString: \"foo\",\n\t\t},\n\t\t{\n\t\t\tname:           \"myString\",\n\t\t\tdata:           myString(\"foo\"),\n\t\t\tresult:         success,\n\t\t\texpectedString: \"foo\",\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, tc.data)\n\t\t\tinner := value.String()\n\n\t\t\tvalue.chain.assert(t, tc.result)\n\t\t\tinner.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.expectedString, inner.Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue_GetNumber(t *testing.T) {\n\ttype myInt int\n\n\tcases := []struct {\n\t\tname        string\n\t\tdata        interface{}\n\t\tresult      chainResult\n\t\texpectedNum float64\n\t}{\n\t\t{name: \"float\", data: 123.0, result: success, expectedNum: float64(123.0)},\n\t\t{name: \"integer\", data: 123, result: success, expectedNum: float64(123)},\n\t\t{name: \"myInt\", data: myInt(123), result: success, expectedNum: float64(myInt(123))},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, tc.data)\n\t\t\tinner := value.Number()\n\n\t\t\tvalue.chain.assert(t, tc.result)\n\t\t\tinner.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.expectedNum, inner.Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue_GetBoolean(t *testing.T) {\n\ttype myBool bool\n\n\tcases := []struct {\n\t\tname         string\n\t\tdata         interface{}\n\t\tresult       chainResult\n\t\texpectedBool bool\n\t}{\n\t\t{name: \"false\", data: false, result: success, expectedBool: false},\n\t\t{name: \"true\", data: true, result: success, expectedBool: true},\n\t\t{name: \"myTrue\", data: myBool(true), result: success, expectedBool: true},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, tc.data)\n\t\t\tinner := value.Boolean()\n\n\t\t\tvalue.chain.assert(t, tc.result)\n\t\t\tinner.chain.assert(t, tc.result)\n\n\t\t\tif tc.result {\n\t\t\t\tassert.Equal(t, tc.expectedBool, inner.Raw())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValue_IsObject(t *testing.T) {\n\tcases := []struct {\n\t\tname       string\n\t\tdata       interface{}\n\t\twantObject chainResult\n\t}{\n\t\t{name: \"object\", data: map[string]interface{}{\"foo\": 123.0}, wantObject: success},\n\t\t{name: \"string\", data: \"foo\", wantObject: failure},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewValue(reporter, tc.data).IsObject().\n\t\t\t\tchain.assert(t, tc.wantObject)\n\n\t\t\tNewValue(reporter, tc.data).NotObject().\n\t\t\t\tchain.assert(t, !tc.wantObject)\n\t\t})\n\t}\n}\n\nfunc TestValue_IsArray(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tdata      interface{}\n\t\twantArray chainResult\n\t}{\n\t\t{name: \"array\", data: []interface{}{\"foo\", \"123\"}, wantArray: success},\n\t\t{name: \"string\", data: \"foo\", wantArray: failure},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewValue(reporter, tc.data).IsArray().\n\t\t\t\tchain.assert(t, tc.wantArray)\n\n\t\t\tNewValue(reporter, tc.data).NotArray().\n\t\t\t\tchain.assert(t, !tc.wantArray)\n\t\t})\n\t}\n}\n\nfunc TestValue_IsString(t *testing.T) {\n\tcases := []struct {\n\t\tname       string\n\t\tdata       interface{}\n\t\twantString chainResult\n\t}{\n\t\t{name: \"string\", data: \"foo\", wantString: success},\n\t\t{name: \"integer\", data: 123, wantString: failure},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewValue(reporter, tc.data).IsString().\n\t\t\t\tchain.assert(t, tc.wantString)\n\n\t\t\tNewValue(reporter, tc.data).NotString().\n\t\t\t\tchain.assert(t, !tc.wantString)\n\t\t})\n\t}\n}\n\nfunc TestValue_IsNumber(t *testing.T) {\n\tcases := []struct {\n\t\tname       string\n\t\tdata       interface{}\n\t\twantNumber chainResult\n\t}{\n\t\t{name: \"integer\", data: 123, wantNumber: success},\n\t\t{name: \"string\", data: \"foo\", wantNumber: failure},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewValue(reporter, tc.data).IsNumber().\n\t\t\t\tchain.assert(t, tc.wantNumber)\n\n\t\t\tNewValue(reporter, tc.data).NotNumber().\n\t\t\t\tchain.assert(t, !tc.wantNumber)\n\t\t})\n\t}\n}\n\nfunc TestValue_IsBoolean(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tdata     interface{}\n\t\twantBool chainResult\n\t}{\n\t\t{name: \"bool\", data: true, wantBool: success},\n\t\t{name: \"string\", data: \"foo\", wantBool: failure},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewValue(reporter, tc.data).IsBoolean().\n\t\t\t\tchain.assert(t, tc.wantBool)\n\n\t\t\tNewValue(reporter, tc.data).NotBoolean().\n\t\t\t\tchain.assert(t, !tc.wantBool)\n\t\t})\n\t}\n}\n\nfunc TestValue_IsEqual(t *testing.T) {\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname      string\n\t\t\tvalue1    interface{}\n\t\t\tvalue2    interface{}\n\t\t\twantEqual chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:      \"compare equivalent values (strings)\",\n\t\t\t\tvalue1:    \"baz\",\n\t\t\t\tvalue2:    \"baz\",\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare equivalent values (maps)\",\n\t\t\t\tvalue1:    map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tvalue2:    map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare non-equivalent values\",\n\t\t\t\tvalue1:    map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tvalue2:    \"baz\",\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare nil values\",\n\t\t\t\tvalue1:    nil,\n\t\t\t\tvalue2:    nil,\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare nil and nil-value\",\n\t\t\t\tvalue1:    nil,\n\t\t\t\tvalue2:    map[string]interface{}(nil),\n\t\t\t\twantEqual: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:      \"compare nil and value\",\n\t\t\t\tvalue1:    nil,\n\t\t\t\tvalue2:    map[string]interface{}{},\n\t\t\t\twantEqual: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewValue(reporter, tc.value1).IsEqual(tc.value2).\n\t\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\t\tNewValue(reporter, tc.value1).NotEqual(tc.value2).\n\t\t\t\t\tchain.assert(t, !tc.wantEqual)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname         string\n\t\t\tvalue1       interface{}\n\t\t\tvalue2       interface{}\n\t\t\twantEqual    chainResult\n\t\t\twantNotEqual chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:         \"compare value and func\",\n\t\t\t\tvalue1:       map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tvalue2:       func() {},\n\t\t\t\twantEqual:    failure,\n\t\t\t\twantNotEqual: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewValue(reporter, tc.value1).IsEqual(tc.value2).\n\t\t\t\t\tchain.assert(t, tc.wantEqual)\n\n\t\t\t\tNewValue(reporter, tc.value1).NotEqual(tc.value2).\n\t\t\t\t\tchain.assert(t, tc.wantNotEqual)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestValue_InList(t *testing.T) {\n\ttype dataStruct struct {\n\t\tData []int `json:\"data\"`\n\t}\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname       string\n\t\t\tvalue      interface{}\n\t\t\tlist       []interface{}\n\t\t\twantInList chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:  \"in list\",\n\t\t\t\tvalue: map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist: []interface{}{map[string]interface{}{\"foo\": \"bar\"}, dataStruct{\n\t\t\t\t\tData: []int{1, 2, 3, 4},\n\t\t\t\t}},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:  \"not in list\",\n\t\t\t\tvalue: \"baz\",\n\t\t\t\tlist: []interface{}{map[string]interface{}{\"foo\": \"bar\"}, dataStruct{\n\t\t\t\t\tData: []int{1, 2, 3, 4},\n\t\t\t\t}},\n\t\t\t\twantInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"map not in list of string\",\n\t\t\t\tvalue:      map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:       []interface{}{\"baz\"},\n\t\t\t\twantInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"map in list of map\",\n\t\t\t\tvalue:      map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:       []interface{}{map[string]interface{}{\"foo\": \"bar\"}},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"nil in list of nil-map\",\n\t\t\t\tvalue:      nil,\n\t\t\t\tlist:       []interface{}{map[string]interface{}(nil)},\n\t\t\t\twantInList: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:       \"nil not in list of empty map\",\n\t\t\t\tvalue:      nil,\n\t\t\t\tlist:       []interface{}{map[string]interface{}{}},\n\t\t\t\twantInList: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewValue(reporter, tc.value).InList(tc.list...).\n\t\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\t\tNewValue(reporter, tc.value).NotInList(tc.list...).\n\t\t\t\t\tchain.assert(t, !tc.wantInList)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid argument\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname          string\n\t\t\tvalue         interface{}\n\t\t\tlist          []interface{}\n\t\t\twantInList    chainResult\n\t\t\twantNotInList chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:          \"nil list\",\n\t\t\t\tvalue:         map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:          nil,\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"empty list\",\n\t\t\t\tvalue:         map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:          []interface{}{},\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"list of a func\",\n\t\t\t\tvalue:         map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:          []interface{}{func() {}},\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"list of map and func\",\n\t\t\t\tvalue:         map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:          []interface{}{map[string]interface{}{\"foo\": \"bar\"}, func() {}},\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:          \"list of string and func\",\n\t\t\t\tvalue:         map[string]interface{}{\"foo\": \"bar\"},\n\t\t\t\tlist:          []interface{}{\"baz\", func() {}},\n\t\t\t\twantInList:    failure,\n\t\t\t\twantNotInList: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewValue(reporter, tc.value).InList(tc.list...).\n\t\t\t\t\tchain.assert(t, tc.wantInList)\n\n\t\t\t\tNewValue(reporter, tc.value).NotInList(tc.list...).\n\t\t\t\t\tchain.assert(t, tc.wantNotInList)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestValue_PathTypes(t *testing.T) {\n\tt.Run(\"object\", func(t *testing.T) {\n\t\tuser0 := map[string]interface{}{\"name\": \"john\"}\n\t\tuser1 := map[string]interface{}{\"name\": \"bob\"}\n\n\t\tdata := map[string]interface{}{\n\t\t\t\"users\": []interface{}{\n\t\t\t\tuser0,\n\t\t\t\tuser1,\n\t\t\t},\n\t\t}\n\n\t\tt.Run(\"queries\", func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, data)\n\n\t\t\tassert.Equal(t, data, value.Path(\"$\").Raw())\n\t\t\tassert.Equal(t, data[\"users\"], value.Path(\"$.users\").Raw())\n\t\t\tassert.Equal(t, user0, value.Path(\"$.users[0]\").Raw())\n\t\t\tassert.Equal(t, \"john\", value.Path(\"$.users[0].name\").Raw())\n\t\t\tassert.Equal(t, []interface{}{\"john\", \"bob\"}, value.Path(\"$.users[*].name\").Raw())\n\t\t\tassert.Equal(t, []interface{}{\"john\", \"bob\"}, value.Path(\"$..name\").Raw())\n\t\t\tvalue.chain.assert(t, success)\n\n\t\t\tnames := value.Path(\"$..name\").Array().Iter()\n\t\t\tnames[0].String().IsEqual(\"john\").chain.assert(t, success)\n\t\t\tnames[1].String().IsEqual(\"bob\").chain.assert(t, success)\n\t\t\tvalue.chain.assert(t, success)\n\t\t})\n\n\t\tt.Run(\"bad key\", func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, data)\n\n\t\t\tbad := value.Path(\"$.bad\")\n\t\t\tassert.True(t, bad != nil)\n\t\t\tassert.True(t, bad.Raw() == nil)\n\t\t\tvalue.chain.assert(t, failure)\n\t\t})\n\n\t\tt.Run(\"invalid query\", func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tvalue := NewValue(reporter, data)\n\n\t\t\tbad := value.Path(\"!\")\n\t\t\tassert.True(t, bad != nil)\n\t\t\tassert.True(t, bad.Raw() == nil)\n\t\t\tvalue.chain.assert(t, failure)\n\t\t})\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tuser0 := map[string]interface{}{\"name\": \"john\"}\n\t\tuser1 := map[string]interface{}{\"name\": \"bob\"}\n\n\t\tdata := []interface{}{\n\t\t\tuser0,\n\t\t\tuser1,\n\t\t}\n\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\n\t\tassert.Equal(t, data, value.Path(\"$\").Raw())\n\t\tassert.Equal(t, user0, value.Path(\"$[0]\").Raw())\n\t\tassert.Equal(t, \"john\", value.Path(\"$[0].name\").Raw())\n\t\tassert.Equal(t, []interface{}{\"john\", \"bob\"}, value.Path(\"$[*].name\").Raw())\n\t\tassert.Equal(t, []interface{}{\"john\", \"bob\"}, value.Path(\"$..name\").Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tdata := \"foo\"\n\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\n\t\tassert.Equal(t, data, value.Path(\"$\").Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"number\", func(t *testing.T) {\n\t\tdata := 123\n\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\n\t\tassert.Equal(t, float64(data), value.Path(\"$\").Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"boolean\", func(t *testing.T) {\n\t\tdata := true\n\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\n\t\tassert.Equal(t, data, value.Path(\"$\").Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"null\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, nil)\n\n\t\tassert.Equal(t, nil, value.Path(\"$\").Raw())\n\t\tvalue.chain.assert(t, success)\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tdata := \"foo\"\n\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\n\t\tfor _, key := range []string{\"$.bad\", \"!\"} {\n\t\t\tbad := value.Path(key)\n\t\t\tassert.True(t, bad != nil)\n\t\t\tassert.True(t, bad.Raw() == nil)\n\t\t\tvalue.chain.assert(t, failure)\n\t\t}\n\t})\n\n\tt.Run(\"int float\", func(t *testing.T) {\n\t\tdata := map[string]interface{}{\n\t\t\t\"A\": 123,\n\t\t\t\"B\": 123.0,\n\t\t}\n\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\t\tvalue.chain.assert(t, success)\n\n\t\ta := value.Path(`$[\"A\"]`)\n\t\ta.chain.assert(t, success)\n\t\tassert.Equal(t, 123.0, a.Raw())\n\n\t\tb := value.Path(`$[\"B\"]`)\n\t\tb.chain.assert(t, success)\n\t\tassert.Equal(t, 123.0, b.Raw())\n\t})\n}\n\n// based on github.com/yalp/jsonpath\nfunc TestValue_PathExpressions(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"A\": []interface{}{\n\t\t\t\"string\",\n\t\t\t23.3,\n\t\t\t3.0,\n\t\t\ttrue,\n\t\t\tfalse,\n\t\t\tnil,\n\t\t},\n\t\t\"B\": \"value\",\n\t\t\"C\": 3.14,\n\t\t\"D\": map[string]interface{}{\n\t\t\t\"C\": 3.1415,\n\t\t\t\"V\": []interface{}{\n\t\t\t\t\"string2a\",\n\t\t\t\t\"string2b\",\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"C\": 3.141592,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"E\": map[string]interface{}{\n\t\t\t\"A\": []interface{}{\"string3\"},\n\t\t\t\"D\": map[string]interface{}{\n\t\t\t\t\"V\": map[string]interface{}{\n\t\t\t\t\t\"C\": 3.14159265,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"F\": map[string]interface{}{\n\t\t\t\"V\": []interface{}{\n\t\t\t\t\"string4a\",\n\t\t\t\t\"string4b\",\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"CC\": 3.1415926535,\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"CC\": \"hello\",\n\t\t\t\t},\n\t\t\t\t[]interface{}{\n\t\t\t\t\t\"string5a\",\n\t\t\t\t\t\"string5b\",\n\t\t\t\t},\n\t\t\t\t[]interface{}{\n\t\t\t\t\t\"string6a\",\n\t\t\t\t\t\"string6b\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trunTests := func(tests map[string]interface{}) {\n\t\treporter := newMockReporter(t)\n\n\t\tvalue := NewValue(reporter, data)\n\t\tvalue.chain.assert(t, success)\n\n\t\tfor path, expected := range tests {\n\t\t\tactual := value.Path(path)\n\t\t\tactual.chain.assert(t, success)\n\n\t\t\tassert.Equal(t, expected, actual.Raw())\n\t\t}\n\t}\n\n\tt.Run(\"pick\", func(t *testing.T) {\n\t\trunTests(map[string]interface{}{\n\t\t\t\"$\":         data,\n\t\t\t\"$.A[0]\":    \"string\",\n\t\t\t`$[\"A\"][0]`: \"string\",\n\t\t\t\"$.A\":       []interface{}{\"string\", 23.3, 3.0, true, false, nil},\n\t\t\t\"$.A[*]\":    []interface{}{\"string\", 23.3, 3.0, true, false, nil},\n\t\t\t\"$.A.*\":     []interface{}{\"string\", 23.3, 3.0, true, false, nil},\n\t\t\t\"$.A.*.a\":   []interface{}{},\n\t\t})\n\t})\n\n\tt.Run(\"slice\", func(t *testing.T) {\n\t\trunTests(map[string]interface{}{\n\t\t\t\"$.A[1,4,2]\":      []interface{}{23.3, false, 3.0},\n\t\t\t`$[\"B\",\"C\"]`:      []interface{}{\"value\", 3.14},\n\t\t\t`$[\"C\",\"B\"]`:      []interface{}{3.14, \"value\"},\n\t\t\t\"$.A[1:4]\":        []interface{}{23.3, 3.0, true},\n\t\t\t\"$.A[::2]\":        []interface{}{\"string\", 3.0, false},\n\t\t\t\"$.A[-2:]\":        []interface{}{false, nil},\n\t\t\t\"$.A[:-1]\":        []interface{}{\"string\", 23.3, 3.0, true, false},\n\t\t\t\"$.A[::-1]\":       []interface{}{nil, false, true, 3.0, 23.3, \"string\"},\n\t\t\t\"$.F.V[4:5][0,1]\": []interface{}{\"string5a\", \"string5b\"},\n\t\t\t\"$.F.V[4:6][1]\":   []interface{}{\"string5b\", \"string6b\"},\n\t\t\t\"$.F.V[4:6][0,1]\": []interface{}{\"string5a\", \"string5b\", \"string6a\", \"string6b\"},\n\t\t\t\"$.F.V[4,5][0:2]\": []interface{}{\"string5a\", \"string5b\", \"string6a\", \"string6b\"},\n\t\t\t\"$.F.V[4:6]\": []interface{}{\n\t\t\t\t[]interface{}{\n\t\t\t\t\t\"string5a\",\n\t\t\t\t\t\"string5b\",\n\t\t\t\t},\n\t\t\t\t[]interface{}{\n\t\t\t\t\t\"string6a\",\n\t\t\t\t\t\"string6b\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t})\n\n\tt.Run(\"quote\", func(t *testing.T) {\n\t\trunTests(map[string]interface{}{\n\t\t\t`$[A][0]`:    \"string\",\n\t\t\t`$[\"A\"][0]`:  \"string\",\n\t\t\t`$[B,C]`:     []interface{}{\"value\", 3.14},\n\t\t\t`$[\"B\",\"C\"]`: []interface{}{\"value\", 3.14},\n\t\t})\n\t})\n\n\tt.Run(\"search\", func(t *testing.T) {\n\t\trunTests(map[string]interface{}{\n\t\t\t\"$..C\":       []interface{}{3.14, 3.1415, 3.141592, 3.14159265},\n\t\t\t`$..[\"C\"]`:   []interface{}{3.14, 3.1415, 3.141592, 3.14159265},\n\t\t\t\"$.D.V..C\":   []interface{}{3.141592},\n\t\t\t\"$.D.V.*.C\":  []interface{}{3.141592},\n\t\t\t\"$.D.V..*.C\": []interface{}{3.141592},\n\t\t\t\"$.D.*..C\":   []interface{}{3.141592},\n\t\t\t\"$.*.V..C\":   []interface{}{3.141592},\n\t\t\t\"$.*.D.V.C\":  []interface{}{3.14159265},\n\t\t\t\"$.*.D..C\":   []interface{}{3.14159265},\n\t\t\t\"$.*.D.V..*\": []interface{}{3.14159265},\n\t\t\t\"$..D..V..C\": []interface{}{3.141592, 3.14159265},\n\t\t\t\"$.*.*.*.C\":  []interface{}{3.141592, 3.14159265},\n\t\t\t\"$..V..C\":    []interface{}{3.141592, 3.14159265},\n\t\t\t\"$.D.V..*\": []interface{}{\n\t\t\t\t\"string2a\",\n\t\t\t\t\"string2b\",\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"C\": 3.141592,\n\t\t\t\t},\n\t\t\t\t3.141592,\n\t\t\t},\n\t\t\t\"$..A\": []interface{}{\n\t\t\t\t[]interface{}{\"string\", 23.3, 3.0, true, false, nil},\n\t\t\t\t[]interface{}{\"string3\"},\n\t\t\t},\n\t\t\t\"$..A..*\":      []interface{}{\"string\", 23.3, 3.0, true, false, nil, \"string3\"},\n\t\t\t\"$.A..*\":       []interface{}{\"string\", 23.3, 3.0, true, false, nil},\n\t\t\t\"$.A.*\":        []interface{}{\"string\", 23.3, 3.0, true, false, nil},\n\t\t\t\"$..A[0,1]\":    []interface{}{\"string\", 23.3},\n\t\t\t\"$..A[0]\":      []interface{}{\"string\", \"string3\"},\n\t\t\t\"$.*.V[0]\":     []interface{}{\"string2a\", \"string4a\"},\n\t\t\t\"$.*.V[1]\":     []interface{}{\"string2b\", \"string4b\"},\n\t\t\t\"$.*.V[0,1]\":   []interface{}{\"string2a\", \"string2b\", \"string4a\", \"string4b\"},\n\t\t\t\"$.*.V[0:2]\":   []interface{}{\"string2a\", \"string2b\", \"string4a\", \"string4b\"},\n\t\t\t\"$.*.V[2].C\":   []interface{}{3.141592},\n\t\t\t\"$..V[2].C\":    []interface{}{3.141592},\n\t\t\t\"$..V[*].C\":    []interface{}{3.141592},\n\t\t\t\"$.*.V[2].*\":   []interface{}{3.141592, 3.1415926535},\n\t\t\t\"$.*.V[2:3].*\": []interface{}{3.141592, 3.1415926535},\n\t\t\t\"$.*.V[2:4].*\": []interface{}{3.141592, 3.1415926535, \"hello\"},\n\t\t\t\"$..V[2,3].CC\": []interface{}{3.1415926535, \"hello\"},\n\t\t\t\"$..V[2:4].CC\": []interface{}{3.1415926535, \"hello\"},\n\t\t\t\"$..V[*].*\": []interface{}{\n\t\t\t\t3.141592,\n\t\t\t\t3.1415926535,\n\t\t\t\t\"hello\",\n\t\t\t\t\"string5a\",\n\t\t\t\t\"string5b\",\n\t\t\t\t\"string6a\",\n\t\t\t\t\"string6b\",\n\t\t\t},\n\t\t\t\"$..[0]\": []interface{}{\n\t\t\t\t\"string\",\n\t\t\t\t\"string2a\",\n\t\t\t\t\"string3\",\n\t\t\t\t\"string4a\",\n\t\t\t\t\"string5a\",\n\t\t\t\t\"string6a\",\n\t\t\t},\n\t\t\t\"$..ZZ\": []interface{}{},\n\t\t})\n\t})\n}\n\nfunc TestValue_Schema(t *testing.T) {\n\tschema := `{\n\t\t\"type\": \"object\",\n\t\t\"properties\": {\n\t\t\t\"foo\": {\n\t\t\t\t\"type\": \"string\"\n\t\t\t},\n\t\t\t\"bar\": {\n\t\t\t\t\"type\": \"integer\"\n\t\t\t}\n\t\t},\n\t\t\"require\": [\"foo\", \"bar\"]\n\t}`\n\n\tt.Run(\"schema with valid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": 1,\n\t\t}\n\t\tNewValue(reporter, data).Schema(schema).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"byte slice schema with valid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": 1,\n\t\t}\n\t\tNewValue(reporter, data).Schema([]byte(schema)).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"schema with invalid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": \"b\",\n\t\t}\n\t\tNewValue(reporter, data).Schema(schema).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"byte slice schema with invalid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": \"b\",\n\t\t}\n\t\tNewValue(reporter, data).Schema([]byte(schema)).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"schema from unmarshalled JSON with valid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": 1,\n\t\t}\n\t\tvar b interface{}\n\t\terr := json.Unmarshal([]byte(schema), &b)\n\t\trequire.Nil(t, err)\n\t\tNewValue(reporter, data).Schema(b).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"schema from unmarshalled JSON with invalid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": \"b\",\n\t\t}\n\t\tvar b interface{}\n\t\terr := json.Unmarshal([]byte(schema), &b)\n\t\trequire.Nil(t, err)\n\t\tNewValue(reporter, data).Schema(b).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"schema with valid file url with valid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": 1,\n\t\t}\n\t\ttmp, _ := os.CreateTemp(\"\", \"httpexpect\")\n\t\tdefer os.Remove(tmp.Name())\n\n\t\t_, err := tmp.Write([]byte(schema))\n\t\trequire.Nil(t, err)\n\n\t\terr = tmp.Close()\n\t\trequire.Nil(t, err)\n\n\t\turl := \"file://\"\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\turl = url + \"/\"\n\t\t}\n\t\turl = url + tmp.Name()\n\t\tNewValue(reporter, data).Schema(url).\n\t\t\tchain.assert(t, success)\n\t})\n\n\tt.Run(\"schema with valid file url with invalid data\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": \"b\",\n\t\t}\n\n\t\ttmp, _ := os.CreateTemp(\"\", \"httpexpect\")\n\t\tdefer os.Remove(tmp.Name())\n\n\t\t_, err := tmp.Write([]byte(schema))\n\t\trequire.Nil(t, err)\n\n\t\terr = tmp.Close()\n\t\trequire.Nil(t, err)\n\n\t\turl := \"file://\"\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\turl = url + \"/\"\n\t\t}\n\t\turl = url + tmp.Name()\n\t\tNewValue(reporter, data).Schema(url).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid schema file url\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": 1,\n\t\t}\n\t\tNewValue(reporter, data).Schema(\"file:///bad/path\").\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"invalid schema json\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tdata := map[string]interface{}{\n\t\t\t\"foo\": \"a\",\n\t\t\t\"bar\": 1,\n\t\t}\n\t\tNewValue(reporter, data).Schema(\"{ bad json\").\n\t\t\tchain.assert(t, failure)\n\t})\n}\n"
        },
        {
          "name": "websocket.go",
          "type": "blob",
          "size": 15.201171875,
          "content": "package httpexpect\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tnoDuration   = time.Duration(0)\n\tinfiniteTime = time.Time{}\n)\n\n// WebsocketConn is used by Websocket to communicate with actual WebSocket connection.\ntype WebsocketConn interface {\n\tReadMessage() (messageType int, p []byte, err error)\n\tWriteMessage(messageType int, data []byte) error\n\tClose() error\n\tSetReadDeadline(t time.Time) error\n\tSetWriteDeadline(t time.Time) error\n\tSubprotocol() string\n}\n\n// Websocket provides methods to read from, write into and close WebSocket\n// connection.\ntype Websocket struct {\n\tnoCopy noCopy\n\tconfig Config\n\tchain  *chain\n\n\tconn WebsocketConn\n\n\treadTimeout  time.Duration\n\twriteTimeout time.Duration\n\n\tisClosed bool\n}\n\n// Deprecated: use NewWebsocketC instead.\nfunc NewWebsocket(config Config, conn WebsocketConn) *Websocket {\n\treturn NewWebsocketC(config, conn)\n}\n\n// NewWebsocketC returns a new Websocket instance.\n//\n// Requirements for config are same as for WithConfig function.\nfunc NewWebsocketC(config Config, conn WebsocketConn) *Websocket {\n\tconfig = config.withDefaults()\n\n\treturn newWebsocket(\n\t\tnewChainWithConfig(\"Websocket()\", config),\n\t\tconfig,\n\t\tconn,\n\t)\n}\n\nfunc newWebsocket(parent *chain, config Config, conn WebsocketConn) *Websocket {\n\tconfig.validate()\n\n\treturn &Websocket{\n\t\tconfig: config,\n\t\tchain:  parent.clone(),\n\t\tconn:   conn,\n\t}\n}\n\n// Conn returns underlying WebsocketConn object.\n// This is the value originally passed to NewConnection.\nfunc (ws *Websocket) Conn() WebsocketConn {\n\treturn ws.conn\n}\n\n// Deprecated: use Conn instead.\nfunc (ws *Websocket) Raw() *websocket.Conn {\n\tif ws.conn == nil {\n\t\treturn nil\n\t}\n\tconn, ok := ws.conn.(*websocket.Conn)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn conn\n}\n\n// Alias is similar to Value.Alias.\nfunc (ws *Websocket) Alias(name string) *Websocket {\n\topChain := ws.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\tws.chain.setAlias(name)\n\treturn ws\n}\n\n// WithReadTimeout sets timeout duration for WebSocket connection reads.\n//\n// By default no timeout is used.\nfunc (ws *Websocket) WithReadTimeout(timeout time.Duration) *Websocket {\n\topChain := ws.chain.enter(\"WithReadTimeout()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn ws\n\t}\n\n\tws.readTimeout = timeout\n\n\treturn ws\n}\n\n// WithoutReadTimeout removes timeout for WebSocket connection reads.\nfunc (ws *Websocket) WithoutReadTimeout() *Websocket {\n\topChain := ws.chain.enter(\"WithoutReadTimeout()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn ws\n\t}\n\n\tws.readTimeout = noDuration\n\n\treturn ws\n}\n\n// WithWriteTimeout sets timeout duration for WebSocket connection writes.\n//\n// By default no timeout is used.\nfunc (ws *Websocket) WithWriteTimeout(timeout time.Duration) *Websocket {\n\topChain := ws.chain.enter(\"WithWriteTimeout()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn ws\n\t}\n\n\tws.writeTimeout = timeout\n\n\treturn ws\n}\n\n// WithoutWriteTimeout removes timeout for WebSocket connection writes.\n//\n// If not used then DefaultWebsocketTimeout will be used.\nfunc (ws *Websocket) WithoutWriteTimeout() *Websocket {\n\topChain := ws.chain.enter(\"WithoutWriteTimeout()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn ws\n\t}\n\n\tws.writeTimeout = noDuration\n\n\treturn ws\n}\n\n// Subprotocol returns a new String instance with negotiated protocol\n// for the connection.\nfunc (ws *Websocket) Subprotocol() *String {\n\topChain := ws.chain.enter(\"Subprotocol()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\tif ws.conn == nil {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, ws.conn.Subprotocol())\n}\n\n// Expect reads next message from WebSocket connection and\n// returns a new WebsocketMessage instance.\n//\n// Example:\n//\n//\tmsg := conn.Expect()\n//\tmsg.JSON().Object().HasValue(\"message\", \"hi\")\nfunc (ws *Websocket) Expect() *WebsocketMessage {\n\topChain := ws.chain.enter(\"Expect()\")\n\tdefer opChain.leave()\n\n\tif ws.checkUnusable(opChain, \"Expect()\") {\n\t\treturn newEmptyWebsocketMessage(opChain)\n\t}\n\n\tm := ws.readMessage(opChain)\n\tif m == nil {\n\t\treturn newEmptyWebsocketMessage(opChain)\n\t}\n\n\treturn m\n}\n\n// Disconnect closes the underlying WebSocket connection without sending or\n// waiting for a close message.\n//\n// It's okay to call this function multiple times.\n//\n// It's recommended to always call this function after connection usage is over\n// to ensure that no resource leaks will happen.\n//\n// Example:\n//\n//\tconn := resp.Connection()\n//\tdefer conn.Disconnect()\nfunc (ws *Websocket) Disconnect() *Websocket {\n\topChain := ws.chain.enter(\"Disconnect()\")\n\tdefer opChain.leave()\n\n\tif ws.conn == nil || ws.isClosed {\n\t\treturn ws\n\t}\n\n\tws.isClosed = true\n\n\tif err := ws.conn.Close(); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"got close error when disconnecting websocket\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t}\n\n\treturn ws\n}\n\n// Close cleanly closes the underlying WebSocket connection\n// by sending an empty close message and then waiting (with timeout)\n// for the server to close the connection.\n//\n// WebSocket close code may be optionally specified.\n// If not, then \"1000 - Normal Closure\" will be used.\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// It's okay to call this function multiple times.\n//\n// Example:\n//\n//\tconn := resp.Connection()\n//\tconn.Close(websocket.CloseUnsupportedData)\nfunc (ws *Websocket) Close(code ...int) *Websocket {\n\topChain := ws.chain.enter(\"Close()\")\n\tdefer opChain.leave()\n\n\tswitch {\n\tcase ws.checkUnusable(opChain, \"Close()\"):\n\t\treturn ws\n\n\tcase len(code) > 1:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple code arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.CloseMessage, nil, code...)\n\n\treturn ws\n}\n\n// CloseWithBytes cleanly closes the underlying WebSocket connection\n// by sending given slice of bytes as a close message and then waiting\n// (with timeout) for the server to close the connection.\n//\n// WebSocket close code may be optionally specified.\n// If not, then \"1000 - Normal Closure\" will be used.\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// It's okay to call this function multiple times.\n//\n// Example:\n//\n//\tconn := resp.Connection()\n//\tconn.CloseWithBytes([]byte(\"bye!\"), websocket.CloseGoingAway)\nfunc (ws *Websocket) CloseWithBytes(b []byte, code ...int) *Websocket {\n\topChain := ws.chain.enter(\"CloseWithBytes()\")\n\tdefer opChain.leave()\n\n\tswitch {\n\tcase ws.checkUnusable(opChain, \"CloseWithBytes()\"):\n\t\treturn ws\n\n\tcase len(code) > 1:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple code arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.CloseMessage, b, code...)\n\n\treturn ws\n}\n\n// CloseWithJSON cleanly closes the underlying WebSocket connection\n// by sending given object (marshaled using json.Marshal()) as a close message\n// and then waiting (with timeout) for the server to close the connection.\n//\n// WebSocket close code may be optionally specified.\n// If not, then \"1000 - Normal Closure\" will be used.\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// It's okay to call this function multiple times.\n//\n// Example:\n//\n//\ttype MyJSON struct {\n//\t  Foo int `json:\"foo\"`\n//\t}\n//\n//\tconn := resp.Connection()\n//\tconn.CloseWithJSON(MyJSON{Foo: 123}, websocket.CloseUnsupportedData)\nfunc (ws *Websocket) CloseWithJSON(\n\tobject interface{}, code ...int,\n) *Websocket {\n\topChain := ws.chain.enter(\"CloseWithJSON()\")\n\tdefer opChain.leave()\n\n\tswitch {\n\tcase ws.checkUnusable(opChain, \"CloseWithJSON()\"):\n\t\treturn ws\n\n\tcase len(code) > 1:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple code arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn ws\n\t}\n\n\tb, err := json.Marshal(object)\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{object},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid json object\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.CloseMessage, b, code...)\n\n\treturn ws\n}\n\n// CloseWithText cleanly closes the underlying WebSocket connection\n// by sending given text as a close message and then waiting (with timeout)\n// for the server to close the connection.\n//\n// WebSocket close code may be optionally specified.\n// If not, then \"1000 - Normal Closure\" will be used.\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// It's okay to call this function multiple times.\n//\n// Example:\n//\n//\tconn := resp.Connection()\n//\tconn.CloseWithText(\"bye!\")\nfunc (ws *Websocket) CloseWithText(s string, code ...int) *Websocket {\n\topChain := ws.chain.enter(\"CloseWithText()\")\n\tdefer opChain.leave()\n\n\tswitch {\n\tcase ws.checkUnusable(opChain, \"CloseWithText()\"):\n\t\treturn ws\n\n\tcase len(code) > 1:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple code arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.CloseMessage, []byte(s), code...)\n\n\treturn ws\n}\n\n// WriteMessage writes to the underlying WebSocket connection a message\n// of given type with given content.\n// Additionally, WebSocket close code may be specified for close messages.\n//\n// WebSocket message types are defined in RFC 6455, section 11.8.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// Example:\n//\n//\tconn := resp.Connection()\n//\tconn.WriteMessage(websocket.CloseMessage, []byte(\"Namárië...\"))\nfunc (ws *Websocket) WriteMessage(typ int, content []byte, closeCode ...int) *Websocket {\n\topChain := ws.chain.enter(\"WriteMessage()\")\n\tdefer opChain.leave()\n\n\tif ws.checkUnusable(opChain, \"WriteMessage()\") {\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, typ, content, closeCode...)\n\n\treturn ws\n}\n\n// WriteBytesBinary is a shorthand for c.WriteMessage(websocket.BinaryMessage, b).\nfunc (ws *Websocket) WriteBytesBinary(b []byte) *Websocket {\n\topChain := ws.chain.enter(\"WriteBytesBinary()\")\n\tdefer opChain.leave()\n\n\tif ws.checkUnusable(opChain, \"WriteBytesBinary()\") {\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.BinaryMessage, b)\n\n\treturn ws\n}\n\n// WriteBytesText is a shorthand for c.WriteMessage(websocket.TextMessage, b).\nfunc (ws *Websocket) WriteBytesText(b []byte) *Websocket {\n\topChain := ws.chain.enter(\"WriteBytesText()\")\n\tdefer opChain.leave()\n\n\tif ws.checkUnusable(opChain, \"WriteBytesText()\") {\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.TextMessage, b)\n\n\treturn ws\n}\n\n// WriteText is a shorthand for\n// c.WriteMessage(websocket.TextMessage, []byte(s)).\nfunc (ws *Websocket) WriteText(s string) *Websocket {\n\topChain := ws.chain.enter(\"WriteText()\")\n\tdefer opChain.leave()\n\n\tif ws.checkUnusable(opChain, \"WriteText()\") {\n\t\treturn ws\n\t}\n\n\treturn ws.WriteMessage(websocket.TextMessage, []byte(s))\n}\n\n// WriteJSON writes to the underlying WebSocket connection given object,\n// marshaled using json.Marshal().\nfunc (ws *Websocket) WriteJSON(object interface{}) *Websocket {\n\topChain := ws.chain.enter(\"WriteJSON()\")\n\tdefer opChain.leave()\n\n\tif ws.checkUnusable(opChain, \"WriteJSON()\") {\n\t\treturn ws\n\t}\n\n\tb, err := json.Marshal(object)\n\n\tif err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertValid,\n\t\t\tActual: &AssertionValue{object},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"invalid json object\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn ws\n\t}\n\n\tws.writeMessage(opChain, websocket.TextMessage, b)\n\n\treturn ws\n}\n\nfunc (ws *Websocket) checkUnusable(opChain *chain, where string) bool {\n\tswitch {\n\tcase opChain.failed():\n\t\treturn true\n\n\tcase ws.conn == nil:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected %s call for failed websocket connection\", where),\n\t\t\t},\n\t\t})\n\t\treturn true\n\n\tcase ws.isClosed:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected %s call for closed websocket connection\", where),\n\t\t\t},\n\t\t})\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (ws *Websocket) readMessage(opChain *chain) *WebsocketMessage {\n\twm := newEmptyWebsocketMessage(opChain)\n\n\tif !ws.setReadDeadline(opChain) {\n\t\treturn nil\n\t}\n\n\tvar err error\n\twm.typ, wm.content, err = ws.conn.ReadMessage()\n\n\tif err != nil {\n\t\tcloseErr, ok := err.(*websocket.CloseError)\n\t\tif !ok {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertOperation,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"failed to read from websocket\"),\n\t\t\t\t\terr,\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn nil\n\t\t}\n\n\t\twm.typ = websocket.CloseMessage\n\t\twm.closeCode = closeErr.Code\n\t\twm.content = []byte(closeErr.Text)\n\t}\n\n\tws.printRead(wm.typ, wm.content, wm.closeCode)\n\n\treturn wm\n}\n\nfunc (ws *Websocket) writeMessage(\n\topChain *chain, typ int, content []byte, closeCode ...int,\n) {\n\tswitch typ {\n\tcase websocket.TextMessage, websocket.BinaryMessage:\n\t\tws.printWrite(typ, content, 0)\n\n\tcase websocket.CloseMessage:\n\t\tif len(closeCode) > 1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType: AssertUsage,\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"unexpected multiple closeCode arguments\"),\n\t\t\t\t},\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tcode := websocket.CloseNormalClosure\n\t\tif len(closeCode) > 0 {\n\t\t\tcode = closeCode[0]\n\t\t}\n\n\t\tws.printWrite(typ, content, code)\n\n\t\tcontent = websocket.FormatCloseMessage(code, string(content))\n\n\tdefault:\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\tfmt.Errorf(\"unexpected websocket message type %s\",\n\t\t\t\t\twsMessageType(typ)),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif !ws.setWriteDeadline(opChain) {\n\t\treturn\n\t}\n\n\tif err := ws.conn.WriteMessage(typ, content); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to write to websocket\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n}\n\nfunc (ws *Websocket) setReadDeadline(opChain *chain) bool {\n\tdeadline := infiniteTime\n\tif ws.readTimeout != noDuration {\n\t\tdeadline = time.Now().Add(ws.readTimeout)\n\t}\n\n\tif err := ws.conn.SetReadDeadline(deadline); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to set read deadline for websocket\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (ws *Websocket) setWriteDeadline(opChain *chain) bool {\n\tdeadline := infiniteTime\n\tif ws.writeTimeout != noDuration {\n\t\tdeadline = time.Now().Add(ws.writeTimeout)\n\t}\n\n\tif err := ws.conn.SetWriteDeadline(deadline); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertOperation,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to set write deadline for websocket\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (ws *Websocket) printRead(typ int, content []byte, closeCode int) {\n\tfor _, printer := range ws.config.Printers {\n\t\tif p, ok := printer.(WebsocketPrinter); ok {\n\t\t\tp.WebsocketRead(typ, content, closeCode)\n\t\t}\n\t}\n}\n\nfunc (ws *Websocket) printWrite(typ int, content []byte, closeCode int) {\n\tfor _, printer := range ws.config.Printers {\n\t\tif p, ok := printer.(WebsocketPrinter); ok {\n\t\t\tp.WebsocketWrite(typ, content, closeCode)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "websocket_dialer.go",
          "type": "blob",
          "size": 2.4921875,
          "content": "package httpexpect\n\nimport (\n\t\"bufio\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/valyala/fasthttp\"\n)\n\n// NewWebsocketDialer produces new websocket.Dialer which dials to bound\n// http.Handler without creating a real net.Conn.\nfunc NewWebsocketDialer(handler http.Handler) *websocket.Dialer {\n\treturn &websocket.Dialer{\n\t\tNetDial: func(network, addr string) (net.Conn, error) {\n\t\t\thc := newHandlerConn()\n\t\t\thc.runHandler(handler)\n\t\t\treturn hc, nil\n\t\t},\n\t}\n}\n\n// NewFastWebsocketDialer produces new websocket.Dialer which dials to bound\n// fasthttp.RequestHandler without creating a real net.Conn.\nfunc NewFastWebsocketDialer(handler fasthttp.RequestHandler) *websocket.Dialer {\n\treturn &websocket.Dialer{\n\t\tNetDial: func(network, addr string) (net.Conn, error) {\n\t\t\thc := newHandlerConn()\n\t\t\thc.runFastHandler(handler)\n\t\t\treturn hc, nil\n\t\t},\n\t}\n}\n\ntype handlerConn struct {\n\tnet.Conn          // returned from dialer\n\tbackConn net.Conn // passed to the background goroutine\n\n\twg sync.WaitGroup\n}\n\nfunc newHandlerConn() *handlerConn {\n\tdialConn, backConn := net.Pipe()\n\n\treturn &handlerConn{\n\t\tConn:     dialConn,\n\t\tbackConn: backConn,\n\t}\n}\n\nfunc (hc *handlerConn) Close() error {\n\terr := hc.Conn.Close()\n\thc.wg.Wait() // wait the background goroutine\n\treturn err\n}\n\nfunc (hc *handlerConn) runHandler(handler http.Handler) {\n\thc.wg.Add(1)\n\n\tgo func() {\n\t\tdefer hc.wg.Done()\n\n\t\trecorder := &hijackRecorder{conn: hc.backConn}\n\n\t\tfor {\n\t\t\treq, err := http.ReadRequest(bufio.NewReader(hc.backConn))\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\thandler.ServeHTTP(recorder, req)\n\t\t}\n\t}()\n}\n\nfunc (hc *handlerConn) runFastHandler(handler fasthttp.RequestHandler) {\n\thc.wg.Add(1)\n\n\tgo func() {\n\t\tdefer hc.wg.Done()\n\n\t\t_ = fasthttp.ServeConn(hc.backConn, handler)\n\t}()\n}\n\n// hijackRecorder it similar to httptest.ResponseRecorder,\n// but with Hijack capabilities.\n//\n// Original idea is stolen from https://github.com/posener/wstest\ntype hijackRecorder struct {\n\thttptest.ResponseRecorder\n\tconn net.Conn\n}\n\n// Hijack the connection for caller.\n//\n// Implements http.Hijacker interface.\nfunc (r *hijackRecorder) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\trw := bufio.NewReadWriter(bufio.NewReader(r.conn), bufio.NewWriter(r.conn))\n\treturn r.conn, rw, nil\n}\n\n// WriteHeader write HTTP header to the client and closes the connection\n//\n// Implements http.ResponseWriter interface.\nfunc (r *hijackRecorder) WriteHeader(code int) {\n\tresp := http.Response{StatusCode: code, Header: r.Header()}\n\t_ = resp.Write(r.conn)\n}\n"
        },
        {
          "name": "websocket_message.go",
          "type": "blob",
          "size": 13.837890625,
          "content": "package httpexpect\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// WebsocketMessage provides methods to inspect message read from WebSocket connection.\ntype WebsocketMessage struct {\n\tnoCopy noCopy\n\tchain  *chain\n\n\ttyp       int\n\tcontent   []byte\n\tcloseCode int\n}\n\n// NewWebsocketMessage returns a new WebsocketMessage instance.\n//\n// If reporter is nil, the function panics.\n// Content may be nil.\n//\n// Example:\n//\n//\tm := NewWebsocketMessage(t, websocket.TextMessage, []byte(\"content\"), 0)\n//\tm.TextMessage()\nfunc NewWebsocketMessage(\n\treporter Reporter, typ int, content []byte, closeCode ...int,\n) *WebsocketMessage {\n\treturn newWebsocketMessage(\n\t\tnewChainWithDefaults(\"WebsocketMessage()\", reporter),\n\t\ttyp,\n\t\tcontent,\n\t\tcloseCode...,\n\t)\n}\n\n// NewWebsocketMessageC returns a new WebsocketMessage instance with config.\n//\n// Requirements for config are same as for WithConfig function.\n// Content may be nil.\n//\n// Example:\n//\n//\tm := NewWebsocketMessageC(config, websocket.TextMessage, []byte(\"content\"), 0)\n//\tm.TextMessage()\nfunc NewWebsocketMessageC(\n\tconfig Config, typ int, content []byte, closeCode ...int,\n) *WebsocketMessage {\n\treturn newWebsocketMessage(\n\t\tnewChainWithConfig(\"WebsocketMessage()\", config.withDefaults()),\n\t\ttyp,\n\t\tcontent,\n\t\tcloseCode...,\n\t)\n}\n\nfunc newWebsocketMessage(\n\tparent *chain, typ int, content []byte, closeCode ...int,\n) *WebsocketMessage {\n\twm := newEmptyWebsocketMessage(parent)\n\n\topChain := wm.chain.enter(\"\")\n\tdefer opChain.leave()\n\n\twm.typ = typ\n\n\tif content != nil {\n\t\twm.content = make([]byte, len(content))\n\t\tcopy(wm.content, content)\n\t} else {\n\t\twm.content = []byte{}\n\t}\n\n\tif len(closeCode) > 1 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"unexpected multiple closeCode arguments\"),\n\t\t\t},\n\t\t})\n\t\treturn wm\n\t}\n\n\tif len(closeCode) != 0 {\n\t\twm.closeCode = closeCode[0]\n\t}\n\n\treturn wm\n}\n\nfunc newEmptyWebsocketMessage(parent *chain) *WebsocketMessage {\n\treturn &WebsocketMessage{\n\t\tchain: parent.clone(),\n\t}\n}\n\n// Raw returns underlying type, content and close code of WebSocket message.\n// Theses values are originally read from WebSocket connection.\nfunc (wm *WebsocketMessage) Raw() (typ int, content []byte, closeCode int) {\n\treturn wm.typ, wm.content, wm.closeCode\n}\n\n// Alias is similar to Value.Alias.\nfunc (wm *WebsocketMessage) Alias(name string) *WebsocketMessage {\n\topChain := wm.chain.enter(\"Alias(%q)\", name)\n\tdefer opChain.leave()\n\n\twm.chain.setAlias(name)\n\treturn wm\n}\n\n// CloseMessage is a shorthand for m.Type(websocket.CloseMessage).\nfunc (wm *WebsocketMessage) CloseMessage() *WebsocketMessage {\n\topChain := wm.chain.enter(\"CloseMessage()\")\n\tdefer opChain.leave()\n\n\twm.checkType(opChain, websocket.CloseMessage)\n\n\treturn wm\n}\n\n// NotCloseMessage is a shorthand for m.NotType(websocket.CloseMessage).\nfunc (wm *WebsocketMessage) NotCloseMessage() *WebsocketMessage {\n\topChain := wm.chain.enter(\"NotCloseMessage()\")\n\tdefer opChain.leave()\n\n\twm.checkNotType(opChain, websocket.CloseMessage)\n\n\treturn wm\n}\n\n// BinaryMessage is a shorthand for m.Type(websocket.BinaryMessage).\nfunc (wm *WebsocketMessage) BinaryMessage() *WebsocketMessage {\n\topChain := wm.chain.enter(\"BinaryMessage()\")\n\tdefer opChain.leave()\n\n\twm.checkType(opChain, websocket.BinaryMessage)\n\n\treturn wm\n}\n\n// NotBinaryMessage is a shorthand for m.NotType(websocket.BinaryMessage).\nfunc (wm *WebsocketMessage) NotBinaryMessage() *WebsocketMessage {\n\topChain := wm.chain.enter(\"NotBinaryMessage()\")\n\tdefer opChain.leave()\n\n\twm.checkNotType(opChain, websocket.BinaryMessage)\n\n\treturn wm\n}\n\n// TextMessage is a shorthand for m.Type(websocket.TextMessage).\nfunc (wm *WebsocketMessage) TextMessage() *WebsocketMessage {\n\topChain := wm.chain.enter(\"TextMessage()\")\n\tdefer opChain.leave()\n\n\twm.checkType(opChain, websocket.TextMessage)\n\n\treturn wm\n}\n\n// NotTextMessage is a shorthand for m.NotType(websocket.TextMessage).\nfunc (wm *WebsocketMessage) NotTextMessage() *WebsocketMessage {\n\topChain := wm.chain.enter(\"NotTextMessage()\")\n\tdefer opChain.leave()\n\n\twm.checkNotType(opChain, websocket.TextMessage)\n\n\treturn wm\n}\n\n// Type succeeds if WebSocket message type is one of the given.\n//\n// WebSocket message types are defined in RFC 6455, section 11.8.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// Example:\n//\n//\tmsg := conn.Expect()\n//\tmsg.Type(websocket.TextMessage, websocket.BinaryMessage)\nfunc (wm *WebsocketMessage) Type(types ...int) *WebsocketMessage {\n\topChain := wm.chain.enter(\"Type()\")\n\tdefer opChain.leave()\n\n\twm.checkType(opChain, types...)\n\n\treturn wm\n}\n\n// NotType succeeds if WebSocket message type is none of the given.\n//\n// WebSocket message types are defined in RFC 6455, section 11.8.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// Example:\n//\n//\tmsg := conn.Expect()\n//\tmsg.NotType(websocket.CloseMessage, websocket.BinaryMessage)\nfunc (wm *WebsocketMessage) NotType(types ...int) *WebsocketMessage {\n\topChain := wm.chain.enter(\"NotType()\")\n\tdefer opChain.leave()\n\n\twm.checkNotType(opChain, types...)\n\n\treturn wm\n}\n\nfunc (wm *WebsocketMessage) checkType(opChain *chain, types ...int) {\n\tif opChain.failed() {\n\t\treturn\n\t}\n\n\tif len(types) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"missing type argument\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tfound := false\n\tfor _, t := range types {\n\t\tif t == wm.typ {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tif len(types) == 1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertEqual,\n\t\t\t\tActual:   &AssertionValue{wsMessageType(wm.typ)},\n\t\t\t\tExpected: &AssertionValue{wsMessageType(types[0])},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: message types are equal\"),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\ttypeList := make([]interface{}, 0, len(types))\n\t\t\tfor _, t := range types {\n\t\t\t\ttypeList = append(typeList, wsMessageType(t))\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertBelongs,\n\t\t\t\tActual:   &AssertionValue{wsMessageType(wm.typ)},\n\t\t\t\tExpected: &AssertionValue{AssertionList(typeList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: message type belongs to given list\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc (wm *WebsocketMessage) checkNotType(opChain *chain, types ...int) {\n\tif opChain.failed() {\n\t\treturn\n\t}\n\n\tif len(types) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"missing type argument\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tfound := false\n\tfor _, t := range types {\n\t\tif t == wm.typ {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif found {\n\t\tif len(types) == 1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotEqual,\n\t\t\t\tActual:   &AssertionValue{wsMessageType(wm.typ)},\n\t\t\t\tExpected: &AssertionValue{wsMessageType(types[0])},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: message types are non-equal\"),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\ttypeList := make([]interface{}, 0, len(types))\n\t\t\tfor _, t := range types {\n\t\t\t\ttypeList = append(typeList, wsMessageType(t))\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{wsMessageType(wm.typ)},\n\t\t\t\tExpected: &AssertionValue{AssertionList(typeList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: message type does not belong to given list\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n}\n\n// Code succeeds if WebSocket close code is one of the given.\n//\n// Code fails if WebSocket message type is not \"8 - Connection Close Frame\".\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// Example:\n//\n//\tmsg := conn.Expect().Closed()\n//\tmsg.Code(websocket.CloseNormalClosure, websocket.CloseGoingAway)\nfunc (wm *WebsocketMessage) Code(codes ...int) *WebsocketMessage {\n\topChain := wm.chain.enter(\"Code()\")\n\tdefer opChain.leave()\n\n\twm.checkCode(opChain, codes...)\n\n\treturn wm\n}\n\n// NotCode succeeds if WebSocket close code is none of the given.\n//\n// NotCode fails if WebSocket message type is not \"8 - Connection Close Frame\".\n//\n// WebSocket close codes are defined in RFC 6455, section 11.7.\n// See also https://godoc.org/github.com/gorilla/websocket#pkg-constants\n//\n// Example:\n//\n//\tmsg := conn.Expect().Closed()\n//\tmsg.NotCode(websocket.CloseAbnormalClosure, websocket.CloseNoStatusReceived)\nfunc (wm *WebsocketMessage) NotCode(codes ...int) *WebsocketMessage {\n\topChain := wm.chain.enter(\"NotCode()\")\n\tdefer opChain.leave()\n\n\twm.checkNotCode(opChain, codes...)\n\n\treturn wm\n}\n\nfunc (wm *WebsocketMessage) checkCode(opChain *chain, codes ...int) {\n\tif opChain.failed() {\n\t\treturn\n\t}\n\n\tif len(codes) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"missing code argument\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif wm.typ != websocket.CloseMessage {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{wsMessageType(wm.typ)},\n\t\t\tExpected: &AssertionValue{wsMessageType(websocket.CloseMessage)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: close message\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tfound := false\n\tfor _, c := range codes {\n\t\tif c == wm.closeCode {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tif len(codes) == 1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertEqual,\n\t\t\t\tActual:   &AssertionValue{wsCloseCode(wm.closeCode)},\n\t\t\t\tExpected: &AssertionValue{wsCloseCode(codes[0])},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: close codes are equal\"),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\tcodeList := make([]interface{}, 0, len(codes))\n\t\t\tfor _, c := range codes {\n\t\t\t\tcodeList = append(codeList, wsCloseCode(c))\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertBelongs,\n\t\t\t\tActual:   &AssertionValue{wsCloseCode(wm.closeCode)},\n\t\t\t\tExpected: &AssertionValue{AssertionList(codeList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: close code belongs to given list\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc (wm *WebsocketMessage) checkNotCode(opChain *chain, codes ...int) {\n\tif opChain.failed() {\n\t\treturn\n\t}\n\n\tif len(codes) == 0 {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertUsage,\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"missing code argument\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tif wm.typ != websocket.CloseMessage {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:     AssertEqual,\n\t\t\tActual:   &AssertionValue{wsMessageType(wm.typ)},\n\t\t\tExpected: &AssertionValue{wsMessageType(websocket.CloseMessage)},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: close message\"),\n\t\t\t},\n\t\t})\n\t\treturn\n\t}\n\n\tfound := false\n\tfor _, c := range codes {\n\t\tif c == wm.closeCode {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif found {\n\t\tif len(codes) == 1 {\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotEqual,\n\t\t\t\tActual:   &AssertionValue{wsCloseCode(wm.closeCode)},\n\t\t\t\tExpected: &AssertionValue{wsCloseCode(codes[0])},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: close codes are non-equal\"),\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\tcodeList := make([]interface{}, 0, len(codes))\n\t\t\tfor _, c := range codes {\n\t\t\t\tcodeList = append(codeList, wsCloseCode(c))\n\t\t\t}\n\n\t\t\topChain.fail(AssertionFailure{\n\t\t\t\tType:     AssertNotBelongs,\n\t\t\t\tActual:   &AssertionValue{wsCloseCode(wm.closeCode)},\n\t\t\t\tExpected: &AssertionValue{AssertionList(codeList)},\n\t\t\t\tErrors: []error{\n\t\t\t\t\terrors.New(\"expected: close code dose not belong to given list\"),\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n}\n\n// NoContent succeeds if WebSocket message has no content (is empty).\nfunc (wm *WebsocketMessage) NoContent() *WebsocketMessage {\n\topChain := wm.chain.enter(\"NoContent()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn wm\n\t}\n\n\tif len(wm.content) != 0 {\n\t\tvar actual interface{}\n\t\tswitch wm.typ {\n\t\tcase websocket.BinaryMessage:\n\t\t\tactual = wm.content\n\n\t\tdefault:\n\t\t\tactual = string(wm.content)\n\t\t}\n\n\t\topChain.fail(AssertionFailure{\n\t\t\tType:   AssertEmpty,\n\t\t\tActual: &AssertionValue{actual},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"expected: message content is empty\"),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn wm\n}\n\n// Body returns a new String instance with WebSocket message content.\n//\n// Example:\n//\n//\tmsg := conn.Expect()\n//\tmsg.Body().NotEmpty()\n//\tmsg.Body().Length().IsEqual(100)\nfunc (wm *WebsocketMessage) Body() *String {\n\topChain := wm.chain.enter(\"Body()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newString(opChain, \"\")\n\t}\n\n\treturn newString(opChain, string(wm.content))\n}\n\n// JSON returns a new Value instance with JSON contents of WebSocket message.\n//\n// JSON succeeds if JSON may be decoded from message content.\n//\n// Example:\n//\n//\tmsg := conn.Expect()\n//\tmsg.JSON().Array().ConsistsOf(\"foo\", \"bar\")\nfunc (wm *WebsocketMessage) JSON() *Value {\n\topChain := wm.chain.enter(\"JSON()\")\n\tdefer opChain.leave()\n\n\tif opChain.failed() {\n\t\treturn newValue(opChain, nil)\n\t}\n\n\tvar value interface{}\n\n\tif err := json.Unmarshal(wm.content, &value); err != nil {\n\t\topChain.fail(AssertionFailure{\n\t\t\tType: AssertValid,\n\t\t\tActual: &AssertionValue{\n\t\t\t\tstring(wm.content),\n\t\t\t},\n\t\t\tErrors: []error{\n\t\t\t\terrors.New(\"failed to decode json\"),\n\t\t\t\terr,\n\t\t\t},\n\t\t})\n\t\treturn newValue(opChain, nil)\n\t}\n\n\treturn newValue(opChain, value)\n}\n\ntype wsMessageType int\n\nfunc (wmt wsMessageType) String() string {\n\ts := \"unknown\"\n\n\tswitch wmt {\n\tcase websocket.TextMessage:\n\t\ts = \"text\"\n\tcase websocket.BinaryMessage:\n\t\ts = \"binary\"\n\tcase websocket.CloseMessage:\n\t\ts = \"close\"\n\tcase websocket.PingMessage:\n\t\ts = \"ping\"\n\tcase websocket.PongMessage:\n\t\ts = \"pong\"\n\t}\n\n\treturn fmt.Sprintf(\"%s(%d)\", s, wmt)\n}\n\ntype wsCloseCode int\n\n// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\nfunc (wcc wsCloseCode) String() string {\n\ts := \"Unknown\"\n\n\tswitch wcc {\n\tcase 1000:\n\t\ts = \"NormalClosure\"\n\tcase 1001:\n\t\ts = \"GoingAway\"\n\tcase 1002:\n\t\ts = \"ProtocolError\"\n\tcase 1003:\n\t\ts = \"UnsupportedData\"\n\tcase 1004:\n\t\ts = \"Reserved\"\n\tcase 1005:\n\t\ts = \"NoStatusReceived\"\n\tcase 1006:\n\t\ts = \"AbnormalClosure\"\n\tcase 1007:\n\t\ts = \"InvalidFramePayloadData\"\n\tcase 1008:\n\t\ts = \"PolicyViolation\"\n\tcase 1009:\n\t\ts = \"MessageTooBig\"\n\tcase 1010:\n\t\ts = \"MandatoryExtension\"\n\tcase 1011:\n\t\ts = \"InternalServerError\"\n\tcase 1012:\n\t\ts = \"ServiceRestart\"\n\tcase 1013:\n\t\ts = \"TryAgainLater\"\n\tcase 1014:\n\t\ts = \"BadGateway\"\n\tcase 1015:\n\t\ts = \"TLSHandshake\"\n\t}\n\n\treturn fmt.Sprintf(\"%s(%d)\", s, wcc)\n}\n"
        },
        {
          "name": "websocket_message_test.go",
          "type": "blob",
          "size": 18.875,
          "content": "package httpexpect\n\nimport (\n\t\"testing\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestWebsocketMessage_Failed(t *testing.T) {\n\tchain := newMockChain(t, flagFailed)\n\n\tmsg := newEmptyWebsocketMessage(chain)\n\n\tmsg.Raw()\n\tmsg.CloseMessage()\n\tmsg.NotCloseMessage()\n\tmsg.BinaryMessage()\n\tmsg.NotBinaryMessage()\n\tmsg.TextMessage()\n\tmsg.NotTextMessage()\n\tmsg.Type(0)\n\tmsg.NotType(0)\n\tmsg.Code(0)\n\tmsg.NotCode(0)\n\tmsg.NoContent()\n\tmsg.Alias(\"foo\")\n\n\tmsg.Body().chain.assert(t, failure)\n\tmsg.JSON().chain.assert(t, failure)\n}\n\nfunc TestWebsocketMessage_Constructors(t *testing.T) {\n\tt.Run(\"reporter\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tmsg := NewWebsocketMessage(reporter, websocket.CloseMessage, nil)\n\t\tmsg.CloseMessage()\n\t\tmsg.chain.assert(t, success)\n\t})\n\n\tt.Run(\"config\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tmsg := NewWebsocketMessageC(Config{\n\t\t\tReporter: reporter,\n\t\t}, websocket.CloseMessage, nil)\n\t\tmsg.CloseMessage()\n\t\tmsg.chain.assert(t, success)\n\t})\n\n\tt.Run(\"chain\", func(t *testing.T) {\n\t\tchain := newMockChain(t)\n\t\tvalue := newWebsocketMessage(chain, 0, nil)\n\t\tassert.NotSame(t, value.chain, chain)\n\t\tassert.Equal(t, value.chain.context.Path, chain.context.Path)\n\t})\n}\n\nfunc TestWebsocketMessage_Raw(t *testing.T) {\n\tt.Run(\"nil content\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tmsg := NewWebsocketMessage(reporter, websocket.CloseMessage, nil)\n\n\t\ttyp, content, closeCode := msg.Raw()\n\n\t\tassert.Equal(t, websocket.CloseMessage, typ)\n\t\tassert.NotNil(t, content)\n\t\tassert.Equal(t, 0, len(content))\n\t\tassert.Equal(t, 0, closeCode)\n\t})\n\n\tt.Run(\"empty content\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tmsg := NewWebsocketMessage(reporter, websocket.CloseMessage, []byte{})\n\n\t\ttyp, content, closeCode := msg.Raw()\n\n\t\tassert.Equal(t, websocket.CloseMessage, typ)\n\t\tassert.NotNil(t, content)\n\t\tassert.Equal(t, 0, len(content))\n\t\tassert.Equal(t, 0, closeCode)\n\t})\n\n\tt.Run(\"non-empty content\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\torigContent := []byte{1, 2, 3}\n\n\t\tmsg := NewWebsocketMessage(reporter, websocket.CloseMessage, origContent)\n\n\t\ttyp, content, closeCode := msg.Raw()\n\n\t\tassert.Equal(t, websocket.CloseMessage, typ)\n\t\tassert.NotNil(t, content)\n\t\tassert.Equal(t, origContent, content)\n\t\tassert.NotSame(t, &origContent[0], &content[0])\n\t\tassert.Equal(t, 0, closeCode)\n\t})\n\n\tt.Run(\"close code\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tmsg := NewWebsocketMessage(reporter, websocket.CloseMessage, []byte{}, 123)\n\n\t\ttyp, content, closeCode := msg.Raw()\n\n\t\tassert.Equal(t, websocket.CloseMessage, typ)\n\t\tassert.NotNil(t, content)\n\t\tassert.Equal(t, 123, closeCode)\n\t})\n}\n\nfunc TestWebsocketMessage_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewWebsocketMessage(reporter, websocket.CloseMessage, nil)\n\tassert.Equal(t, []string{\"WebsocketMessage()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"WebsocketMessage()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"WebsocketMessage()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n\n\tchildValue := value.Body()\n\tassert.Equal(t, []string{\"WebsocketMessage()\", \"Body()\"},\n\t\tchildValue.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\", \"Body()\"}, childValue.chain.context.AliasedPath)\n}\n\nfunc TestWebsocketMessage_CloseCode(t *testing.T) {\n\tt.Run(\"close code is not passed\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewWebsocketMessage(reporter, websocket.CloseMessage, nil).Code(0).\n\t\t\tchain.assert(t, success)\n\t\tNewWebsocketMessage(reporter, websocket.CloseMessage, nil).NotCode(0).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"single close code is passed\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewWebsocketMessage(reporter, websocket.CloseMessage, nil, 10).Code(10).\n\t\t\tchain.assert(t, success)\n\t\tNewWebsocketMessage(reporter, websocket.CloseMessage, nil, 10).NotCode(10).\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"multiple close code is passed\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewWebsocketMessage(reporter, websocket.CloseMessage, nil, 10, 20).\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestWebsocketMessage_CloseMessage(t *testing.T) {\n\tt.Run(\"CloseMessage type with functions\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname string\n\t\t\ttyp  int\n\t\t\tfn   func(s *WebsocketMessage) *WebsocketMessage\n\t\t\twant chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"CloseMessage type with CloseMessage function\",\n\t\t\t\ttyp:  websocket.CloseMessage,\n\t\t\t\tfn:   (*WebsocketMessage).CloseMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"CloseMessage type with NotCloseMessage function\",\n\t\t\t\ttyp:  websocket.CloseMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotCloseMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"CloseMessage type with BinaryMessage function\",\n\t\t\t\ttyp:  websocket.CloseMessage,\n\t\t\t\tfn:   (*WebsocketMessage).BinaryMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"CloseMessage type with NotBinaryMessage function\",\n\t\t\t\ttyp:  websocket.CloseMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotBinaryMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"CloseMessage type with TextMessage function\",\n\t\t\t\ttyp:  websocket.CloseMessage,\n\t\t\t\tfn:   (*WebsocketMessage).TextMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"CloseMessage type with NotTextMessage function\",\n\t\t\t\ttyp:  websocket.CloseMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotTextMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\ttc.fn(NewWebsocketMessage(reporter, tc.typ, nil, 1000)).\n\t\t\t\t\tchain.assert(t, tc.want)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"CloseMessage type with codes\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\ttyp         int\n\t\t\tcode        int\n\t\t\ttestCode    int\n\t\t\twantCode    chainResult\n\t\t\twantNotCode chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"CloseMessage type with code 1000 and test code 1000\",\n\t\t\t\ttyp:         websocket.CloseMessage,\n\t\t\t\tcode:        1000,\n\t\t\t\ttestCode:    1000,\n\t\t\t\twantCode:    success,\n\t\t\t\twantNotCode: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"CloseMessage type with code 1000 and test code 1001\",\n\t\t\t\ttyp:         websocket.CloseMessage,\n\t\t\t\tcode:        1000,\n\t\t\t\ttestCode:    1001,\n\t\t\t\twantCode:    failure,\n\t\t\t\twantNotCode: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).Code(tc.testCode).\n\t\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).NotCode(tc.testCode).\n\t\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"CloseMessage type with types\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\ttyp         int\n\t\t\tcode        int\n\t\t\ttestCode    int\n\t\t\twantCode    chainResult\n\t\t\twantNotCode chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"CloseMessage type with code 1000 and test code 1000\",\n\t\t\t\ttyp:         websocket.CloseMessage,\n\t\t\t\tcode:        1000,\n\t\t\t\ttestCode:    1000,\n\t\t\t\twantCode:    success,\n\t\t\t\twantNotCode: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"CloseMessage type with code 1000 and test code 1001\",\n\t\t\t\ttyp:         websocket.CloseMessage,\n\t\t\t\tcode:        1000,\n\t\t\t\ttestCode:    1001,\n\t\t\t\twantCode:    failure,\n\t\t\t\twantNotCode: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).Code(tc.testCode).\n\t\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).NotCode(tc.testCode).\n\t\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestWebsocketMessage_TextMessage(t *testing.T) {\n\tt.Run(\"TextMessage type with functions\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname string\n\t\t\ttyp  int\n\t\t\tfn   func(s *WebsocketMessage) *WebsocketMessage\n\t\t\twant chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"TextMessage type with CloseMessage function\",\n\t\t\t\ttyp:  websocket.TextMessage,\n\t\t\t\tfn:   (*WebsocketMessage).CloseMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"TextMessage type with NotCloseMessage function\",\n\t\t\t\ttyp:  websocket.TextMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotCloseMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"TextMessage type with BinaryMessage function\",\n\t\t\t\ttyp:  websocket.TextMessage,\n\t\t\t\tfn:   (*WebsocketMessage).BinaryMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"TextMessage type with NotBinaryMessage function\",\n\t\t\t\ttyp:  websocket.TextMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotBinaryMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"TextMessage type with TextMessage function\",\n\t\t\t\ttyp:  websocket.TextMessage,\n\t\t\t\tfn:   (*WebsocketMessage).TextMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"TextMessage type with NotTextMessage function\",\n\t\t\t\ttyp:  websocket.TextMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotTextMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\ttc.fn(NewWebsocketMessage(reporter, tc.typ, nil, 1000)).\n\t\t\t\t\tchain.assert(t, tc.want)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"TextMessage type with types\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\ttyp         int\n\t\t\ttestTyp     int\n\t\t\twantCode    chainResult\n\t\t\twantNotCode chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"TextMessage type with CloseMessage type\",\n\t\t\t\ttyp:         websocket.TextMessage,\n\t\t\t\ttestTyp:     websocket.CloseMessage,\n\t\t\t\twantCode:    failure,\n\t\t\t\twantNotCode: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"TextMessage type with TextMessage type\",\n\t\t\t\ttyp:         websocket.TextMessage,\n\t\t\t\ttestTyp:     websocket.TextMessage,\n\t\t\t\twantCode:    success,\n\t\t\t\twantNotCode: failure,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, 10).Type(tc.testTyp).\n\t\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, 10).NotType(tc.testTyp).\n\t\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestWebsocketMessage_BinaryMessage(t *testing.T) {\n\tt.Run(\"BinaryMessage type with functions\", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname string\n\t\t\ttyp  int\n\t\t\tfn   func(s *WebsocketMessage) *WebsocketMessage\n\t\t\twant chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"BinaryMessage type with CloseMessage function\",\n\t\t\t\ttyp:  websocket.BinaryMessage,\n\t\t\t\tfn:   (*WebsocketMessage).CloseMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"BinaryMessage type with NotCloseMessage function\",\n\t\t\t\ttyp:  websocket.BinaryMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotCloseMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"BinaryMessage type with BinaryMessage function\",\n\t\t\t\ttyp:  websocket.BinaryMessage,\n\t\t\t\tfn:   (*WebsocketMessage).BinaryMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"BinaryMessage type with NotBinaryMessage function\",\n\t\t\t\ttyp:  websocket.BinaryMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotBinaryMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"BinaryMessage type with TextMessage function\",\n\t\t\t\ttyp:  websocket.BinaryMessage,\n\t\t\t\tfn:   (*WebsocketMessage).TextMessage,\n\t\t\t\twant: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"BinaryMessage type with NotTextMessage function\",\n\t\t\t\ttyp:  websocket.BinaryMessage,\n\t\t\t\tfn:   (*WebsocketMessage).NotTextMessage,\n\t\t\t\twant: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\ttc.fn(NewWebsocketMessage(reporter, tc.typ, nil, 1000)).\n\t\t\t\t\tchain.assert(t, tc.want)\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"BinaryMessage with types \", func(t *testing.T) {\n\t\tcases := []struct {\n\t\t\tname        string\n\t\t\ttyp         int\n\t\t\ttestTyp     int\n\t\t\twantCode    chainResult\n\t\t\twantNotCode chainResult\n\t\t}{\n\t\t\t{\n\t\t\t\tname:        \"BinaryMessage type with BinaryMessage type\",\n\t\t\t\ttyp:         websocket.BinaryMessage,\n\t\t\t\ttestTyp:     websocket.BinaryMessage,\n\t\t\t\twantCode:    success,\n\t\t\t\twantNotCode: failure,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:        \"BinaryMessage type with TextMessage type\",\n\t\t\t\ttyp:         websocket.BinaryMessage,\n\t\t\t\ttestTyp:     websocket.TextMessage,\n\t\t\t\twantCode:    failure,\n\t\t\t\twantNotCode: success,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range cases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\treporter := newMockReporter(t)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, 10).Type(tc.testTyp).\n\t\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, 10).NotType(tc.testTyp).\n\t\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t\t})\n\n\t\t}\n\t})\n}\n\nfunc TestWebsocketMessage_MatchTypes(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\ttyp         int\n\t\ttestTypes   []int\n\t\twantCode    chainResult\n\t\twantNotCode chainResult\n\t}{\n\t\t{\n\t\t\tname:        \"TextMessage type with TextMessage and BinaryMessage types\",\n\t\t\ttyp:         websocket.TextMessage,\n\t\t\ttestTypes:   []int{websocket.TextMessage, websocket.BinaryMessage},\n\t\t\twantCode:    success,\n\t\t\twantNotCode: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"TextMessage type with BinaryMessage andTexMessage types\",\n\t\t\ttyp:         websocket.TextMessage,\n\t\t\ttestTypes:   []int{websocket.BinaryMessage, websocket.TextMessage},\n\t\t\twantCode:    success,\n\t\t\twantNotCode: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"TextMessage type with CloseMessage and BinaryMessage types\",\n\t\t\ttyp:         websocket.TextMessage,\n\t\t\ttestTypes:   []int{websocket.CloseMessage, websocket.BinaryMessage},\n\t\t\twantCode:    failure,\n\t\t\twantNotCode: success,\n\t\t},\n\t\t{\n\t\t\tname:        \"TextMessage type with BinaryMessage and CloseMessage types\",\n\t\t\ttyp:         websocket.TextMessage,\n\t\t\ttestTypes:   []int{websocket.BinaryMessage, websocket.CloseMessage},\n\t\t\twantCode:    failure,\n\t\t\twantNotCode: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, 0).Type(tc.testTypes...).\n\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, 0).NotType(tc.testTypes...).\n\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t})\n\t}\n}\n\nfunc TestWebsocketMessage_MatchCodes(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\ttyp         int\n\t\tcode        int\n\t\ttestCodes   []int\n\t\twantCode    chainResult\n\t\twantNotCode chainResult\n\t}{\n\t\t{\n\t\t\tname:        \"close message with close code 10 and with test codes 10 and 20\",\n\t\t\ttyp:         websocket.CloseMessage,\n\t\t\tcode:        10,\n\t\t\ttestCodes:   []int{10, 20},\n\t\t\twantCode:    success,\n\t\t\twantNotCode: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"close message with close code 10 and with test codes 20 and 10\",\n\t\t\ttyp:         websocket.CloseMessage,\n\t\t\tcode:        10,\n\t\t\ttestCodes:   []int{20, 10},\n\t\t\twantCode:    success,\n\t\t\twantNotCode: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"close message with close code 10 and with test codes 30 and 20\",\n\t\t\ttyp:         websocket.CloseMessage,\n\t\t\tcode:        10,\n\t\t\ttestCodes:   []int{30, 20},\n\t\t\twantCode:    failure,\n\t\t\twantNotCode: success,\n\t\t},\n\t\t{\n\t\t\tname:        \"close message with close code 10 and with test codes 20 and 30\",\n\t\t\ttyp:         websocket.CloseMessage,\n\t\t\tcode:        10,\n\t\t\ttestCodes:   []int{20, 30},\n\t\t\twantCode:    failure,\n\t\t\twantNotCode: success,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).Code(tc.testCodes...).\n\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).NotCode(tc.testCodes...).\n\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t})\n\t}\n}\n\nfunc TestWebsocketMessage_CodeAndType(t *testing.T) {\n\tcases := []struct {\n\t\tname        string\n\t\ttyp         int\n\t\tcode        int\n\t\twantCode    chainResult\n\t\twantNotCode chainResult\n\t}{\n\t\t{\n\t\t\tname:        \"text message with close code 10\",\n\t\t\ttyp:         websocket.TextMessage,\n\t\t\tcode:        10,\n\t\t\twantCode:    failure,\n\t\t\twantNotCode: failure,\n\t\t},\n\t\t{\n\t\t\tname:        \"close message with close code 10\",\n\t\t\ttyp:         websocket.CloseMessage,\n\t\t\tcode:        10,\n\t\t\twantCode:    success,\n\t\t\twantNotCode: failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).Code(tc.code).\n\t\t\t\tchain.assert(t, tc.wantCode)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, nil, tc.code).NotCode(tc.code).\n\t\t\t\tchain.assert(t, tc.wantNotCode)\n\t\t})\n\t}\n}\n\nfunc TestWebsocketMessage_NoContent(t *testing.T) {\n\tcases := []struct {\n\t\tname    string\n\t\ttyp     int\n\t\tcontent []byte\n\t\tresult  chainResult\n\t}{\n\t\t{\n\t\t\tname:    \"nil text message\",\n\t\t\ttyp:     websocket.TextMessage,\n\t\t\tcontent: nil,\n\t\t\tresult:  success,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty text message\",\n\t\t\ttyp:     websocket.TextMessage,\n\t\t\tcontent: []byte(\"\"),\n\t\t\tresult:  success,\n\t\t},\n\t\t{\n\t\t\tname:    \"text message with content\",\n\t\t\ttyp:     websocket.TextMessage,\n\t\t\tcontent: []byte(\"test\"),\n\t\t\tresult:  failure,\n\t\t},\n\t\t{\n\t\t\tname:    \"nil binary message\",\n\t\t\ttyp:     websocket.BinaryMessage,\n\t\t\tcontent: nil,\n\t\t\tresult:  success,\n\t\t},\n\t\t{\n\t\t\tname:    \"empty binary message\",\n\t\t\ttyp:     websocket.BinaryMessage,\n\t\t\tcontent: []byte(\"\"),\n\t\t\tresult:  success,\n\t\t},\n\t\t{\n\t\t\tname:    \"binary message with content\",\n\t\t\ttyp:     websocket.BinaryMessage,\n\t\t\tcontent: []byte(\"test\"),\n\t\t\tresult:  failure,\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\n\t\t\tNewWebsocketMessage(reporter, tc.typ, tc.content).NoContent().\n\t\t\t\tchain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocketMessage_Body(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tbody := []byte(\"test\")\n\n\tmsg := NewWebsocketMessage(reporter, websocket.TextMessage, body)\n\n\ts := msg.Body()\n\ts.chain.assert(t, success)\n\n\trequire.Equal(t, \"test\", s.Raw())\n}\n\nfunc TestWebsocketMessage_JSON(t *testing.T) {\n\tt.Run(\"good\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := []byte(`{\"foo\":\"bar\"}`)\n\n\t\tmsg := NewWebsocketMessage(reporter, websocket.TextMessage, body)\n\n\t\tj := msg.JSON()\n\t\tj.chain.assert(t, success)\n\n\t\trequire.Equal(t, \"bar\", j.Object().Value(\"foo\").Raw())\n\t})\n\n\tt.Run(\"bad\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tbody := []byte(`{`)\n\n\t\tmsg := NewWebsocketMessage(reporter, websocket.TextMessage, body)\n\n\t\tj := msg.JSON()\n\t\tj.chain.assert(t, failure)\n\n\t\tmsg.chain.assert(t, failure)\n\t})\n}\n\nfunc TestWebsocketMessage_Usage(t *testing.T) {\n\tt.Run(\"type\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewWebsocketMessage(reporter, websocket.TextMessage, nil).Type().\n\t\t\tchain.assert(t, failure)\n\n\t\tNewWebsocketMessage(reporter, websocket.TextMessage, nil).NotType().\n\t\t\tchain.assert(t, failure)\n\t})\n\n\tt.Run(\"code\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\n\t\tNewWebsocketMessage(reporter, websocket.TextMessage, nil).Code().\n\t\t\tchain.assert(t, failure)\n\n\t\tNewWebsocketMessage(reporter, websocket.TextMessage, nil).NotCode().\n\t\t\tchain.assert(t, failure)\n\t})\n}\n\nfunc TestWebsocketMessage_Codes(t *testing.T) {\n\tt.Run(\"message type\", func(t *testing.T) {\n\t\tfor n := 0; n < 100; n++ {\n\t\t\tassert.NotEmpty(t, wsMessageType(n).String())\n\t\t}\n\t})\n\n\tt.Run(\"close code\", func(t *testing.T) {\n\t\tfor n := 0; n < 2000; n++ {\n\t\t\tassert.NotEmpty(t, wsCloseCode(n).String())\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "websocket_test.go",
          "type": "blob",
          "size": 22.515625,
          "content": "package httpexpect\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc noWsPreSteps(ws *Websocket) {}\n\nfunc TestWebsocket_FailedChain(t *testing.T) {\n\treporter := newMockReporter(t)\n\tconfig := newMockConfig(reporter)\n\tchain := newChainWithDefaults(\"test\", reporter, flagFailed)\n\n\tws := newWebsocket(chain, config, nil)\n\n\tws.Conn()\n\tws.Raw()\n\tws.Alias(\"foo\")\n\tws.WithReadTimeout(0)\n\tws.WithoutReadTimeout()\n\tws.WithWriteTimeout(0)\n\tws.WithoutWriteTimeout()\n\n\tws.Subprotocol().chain.assert(t, failure)\n\tws.Expect().chain.assert(t, failure)\n\n\tws.WriteMessage(websocket.TextMessage, []byte(\"a\"))\n\tws.WriteBytesBinary([]byte(\"a\"))\n\tws.WriteBytesText([]byte(\"a\"))\n\tws.WriteText(\"a\")\n\tws.WriteJSON(map[string]string{\"a\": \"b\"})\n\n\tws.Close()\n\tws.CloseWithBytes([]byte(\"a\"))\n\tws.CloseWithJSON(map[string]string{\"a\": \"b\"})\n\tws.CloseWithText(\"a\")\n\n\tws.Disconnect()\n\tws.Close()\n}\n\nfunc TestWebsocket_Alias(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tvalue := NewWebsocketC(Config{Reporter: reporter}, &mockWebsocketConn{})\n\tassert.Equal(t, []string{\"Websocket()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"Websocket()\"}, value.chain.context.AliasedPath)\n\n\tvalue.Alias(\"foo\")\n\tassert.Equal(t, []string{\"Websocket()\"}, value.chain.context.Path)\n\tassert.Equal(t, []string{\"foo\"}, value.chain.context.AliasedPath)\n}\n\nfunc TestWebsocket_NilConn(t *testing.T) {\n\tconfig := Config{\n\t\tReporter: newMockReporter(t),\n\t}\n\n\tt.Run(\"getters\", func(t *testing.T) {\n\t\tws := NewWebsocketC(config, nil)\n\n\t\tif ws.Conn() != nil {\n\t\t\tt.Fatal(\"Conn returned not nil\")\n\t\t}\n\n\t\tif ws.Raw() != nil {\n\t\t\tt.Fatal(\"Raw returned not nil\")\n\t\t}\n\n\t\tif ws.Subprotocol() == nil {\n\t\t\tt.Fatal(\"Subprotocol returned nil\")\n\t\t}\n\n\t\tws.chain.assert(t, success)\n\t})\n\n\tt.Run(\"expect\", func(t *testing.T) {\n\t\tws := NewWebsocketC(config, nil)\n\n\t\tmsg := ws.Expect()\n\t\tmsg.chain.assert(t, failure)\n\n\t\tws.chain.assert(t, failure)\n\t})\n}\n\nfunc TestWebsocket_MockConn(t *testing.T) {\n\treporter := newMockReporter(t)\n\n\tconfig := Config{\n\t\tReporter: reporter,\n\t}\n\n\tt.Run(\"getters\", func(t *testing.T) {\n\t\tws := NewWebsocketC(config, &mockWebsocketConn{})\n\n\t\tif ws.Conn() == nil {\n\t\t\tt.Fatal(\"Conn returned nil\")\n\t\t}\n\n\t\tif ws.Raw() != nil {\n\t\t\tt.Fatal(\"Raw returned not nil\")\n\t\t}\n\n\t\tif ws.Subprotocol() == nil {\n\t\t\tt.Fatal(\"Subprotocol returned nil\")\n\t\t}\n\n\t\tws.chain.assert(t, success)\n\t})\n\n\tt.Run(\"expect\", func(t *testing.T) {\n\t\tws := NewWebsocketC(config, &mockWebsocketConn{})\n\n\t\tmsg := ws.Expect()\n\t\tmsg.chain.assert(t, success)\n\n\t\tws.chain.assert(t, success)\n\t})\n}\n\nfunc TestWebsocket_Expect(t *testing.T) {\n\ttype args struct {\n\t\tchainFlags chainFlags\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"fail to read message from conn\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\treadMsgErr: errors.New(\"failed to read message\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"chain already failed\",\n\t\t\targs: args{\n\t\t\t\tchainFlags: flagFailed,\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     nil,\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"connection closed\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"failed to set read deadline\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\treadDlError: errors.New(\"failed to set read deadline\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tconfig := newMockConfig(reporter)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter, tc.args.chainFlags)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.Expect()\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_Close(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcloseCode  []int\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     nil,\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\twsConn:    &mockWebsocketConn{},\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"too many close codes\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure, websocket.CloseAbnormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.Close(tc.args.closeCode...)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_CloseWithBytes(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    []byte\n\t\tcloseCode  []int\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    []byte(\"connection closed...\"),\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     nil,\n\t\t\t\tcontent:    []byte(\"connection closed...\"),\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\twsConn:    &mockWebsocketConn{},\n\t\t\t\tcontent:   []byte(\"connection closed...\"),\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"too many close codes\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    []byte(\"connection closed...\"),\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure, websocket.CloseAbnormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.CloseWithBytes(tc.args.content, tc.args.closeCode...)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_CloseWithText(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    string\n\t\tcloseCode  []int\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    \"connection closed...\",\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     nil,\n\t\t\t\tcontent:    \"connection closed...\",\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\twsConn:    &mockWebsocketConn{},\n\t\t\t\tcontent:   \"connection closed...\",\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"too many close codes\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    \"connection closed...\",\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure, websocket.CloseAbnormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.CloseWithText(tc.args.content, tc.args.closeCode...)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_CloseWithJSON(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    interface{}\n\t\tcloseCode  []int\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"connection closing...\",\n\t\t\t\t},\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     nil,\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"connection closing...\",\n\t\t\t\t},\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"connection closing...\",\n\t\t\t\t},\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"too many close codes\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"connection closing...\",\n\t\t\t\t},\n\t\t\t\tcloseCode: []int{websocket.CloseNormalClosure, websocket.CloseAbnormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"marshall failed\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    make(chan int),\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.CloseWithJSON(tc.args.content, tc.args.closeCode...)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_WriteMessage(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\ttyp        int\n\t\tcontent    []byte\n\t\tcloseCode  []int\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"text message success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\ttyp:        websocket.TextMessage,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t\tcloseCode:  []int{},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"text message fail nil conn\",\n\t\t\targs: args{\n\t\t\t\twsConn:     nil,\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\ttyp:        websocket.TextMessage,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t\tcloseCode:  []int{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"text message fail unusable\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\ttyp:       websocket.TextMessage,\n\t\t\t\tcontent:   []byte(\"random message...\"),\n\t\t\t\tcloseCode: []int{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"text message failed to set write deadline\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\twriteDlError: errors.New(\"failed to set write deadline\"),\n\t\t\t\t},\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\ttyp:        websocket.TextMessage,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t\tcloseCode:  []int{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"text message failed to write to conn\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\twriteMsgErr: errors.New(\"failed to write message to conn\"),\n\t\t\t\t},\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\ttyp:        websocket.TextMessage,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t\tcloseCode:  []int{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"text binary message success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\ttyp:        websocket.BinaryMessage,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t\tcloseCode:  []int{},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"close message success\",\n\t\t\targs: args{\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\ttyp:        websocket.CloseMessage,\n\t\t\t\tcontent:    []byte(\"closing message...\"),\n\t\t\t\tcloseCode:  []int{websocket.CloseNormalClosure},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"close message too many close codes\",\n\t\t\targs: args{\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\ttyp:        websocket.CloseMessage,\n\t\t\t\tcontent:    []byte(\"closing message...\"),\n\t\t\t\tcloseCode: []int{\n\t\t\t\t\twebsocket.CloseNormalClosure,\n\t\t\t\t\twebsocket.CloseAbnormalClosure,\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported message type\",\n\t\t\targs: args{\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\ttyp:        websocket.CloseMandatoryExtension,\n\t\t\t\tcontent:    []byte(\"unsupported message...\"),\n\t\t\t\tcloseCode:  []int{},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.WriteMessage(tc.args.typ, tc.args.content, tc.args.closeCode...)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_WriteBytesBinary(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    []byte\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsConn:     nil,\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\tcontent: []byte(\"random message...\"),\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.WriteBytesBinary(tc.args.content)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_WriteBytesText(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    []byte\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsConn:     nil,\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\tcontent:    []byte(\"random message...\"),\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\tcontent: []byte(\"random message...\"),\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.WriteBytesText(tc.args.content)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_WriteText(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    string\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent:    \"random message...\",\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsConn:     nil,\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\tcontent:    \"random message...\",\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\tcontent: \"random message...\",\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.WriteText(tc.args.content)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_WriteJSON(t *testing.T) {\n\ttype args struct {\n\t\twsConn     WebsocketConn\n\t\twsPreSteps func(*Websocket)\n\t\tcontent    interface{}\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"random message\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsConn:     nil,\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"random message\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"websocket unusable\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t\twsPreSteps: func(ws *Websocket) {\n\t\t\t\t\tws.Disconnect()\n\t\t\t\t},\n\t\t\t\tcontent: map[string]string{\n\t\t\t\t\t\"msg\": \"random message\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t\t{\n\t\t\tname: \"JSON marshal failed\",\n\t\t\targs: args{\n\t\t\t\twsConn:     &mockWebsocketConn{},\n\t\t\t\twsPreSteps: noWsPreSteps,\n\t\t\t\tcontent:    make(chan int),\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\ttc.args.wsPreSteps(ws)\n\n\t\t\tws.WriteJSON(tc.args.content)\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_Subprotocol(t *testing.T) {\n\tsubproto := \"soap\"\n\tws := NewWebsocketC(\n\t\tConfig{\n\t\t\tReporter: NewAssertReporter(t),\n\t\t},\n\t\t&mockWebsocketConn{\n\t\t\tsubprotocol: subproto,\n\t\t})\n\n\tws.Subprotocol()\n\n\tif got := ws.Subprotocol().value; got != subproto {\n\t\tt.Errorf(\"Websocket.Subprotocol() = %v, want %v\", got, subproto)\n\t}\n}\n\nfunc TestWebsocket_SetReadDeadline(t *testing.T) {\n\ttype args struct {\n\t\twsConn WebsocketConn\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn.SetReadDeadline error\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\treadDlError: errors.New(\"Failed to set read deadline\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn).\n\t\t\t\tWithReadTimeout(time.Second)\n\n\t\t\topChain := ws.chain.enter(\"test\")\n\t\t\tws.setReadDeadline(opChain)\n\t\t\topChain.leave()\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_SetWriteDeadline(t *testing.T) {\n\ttype args struct {\n\t\twsConn WebsocketConn\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn.SetReadDeadline error\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\twriteDlError: errors.New(\"Failed to set read deadline\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn).\n\t\t\t\tWithWriteTimeout(time.Second)\n\n\t\t\topChain := ws.chain.enter(\"test\")\n\t\t\tws.setWriteDeadline(opChain)\n\t\t\topChain.leave()\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_Disconnect(t *testing.T) {\n\ttype args struct {\n\t\twsConn WebsocketConn\n\t}\n\tcases := []struct {\n\t\tname   string\n\t\targs   args\n\t\tresult chainResult\n\t}{\n\t\t{\n\t\t\tname: \"success\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{},\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"success even if conn is nil\",\n\t\t\targs: args{\n\t\t\t\twsConn: nil,\n\t\t\t},\n\t\t\tresult: success,\n\t\t},\n\t\t{\n\t\t\tname: \"conn close failed\",\n\t\t\targs: args{\n\t\t\t\twsConn: &mockWebsocketConn{\n\t\t\t\t\tcloseError: errors.New(\"failed to close ws conn\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tresult: failure,\n\t\t},\n\t}\n\tfor _, tc := range cases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treporter := newMockReporter(t)\n\t\t\tchain := newChainWithDefaults(\"test\", reporter)\n\t\t\tconfig := newMockConfig(reporter)\n\n\t\t\tws := newWebsocket(chain, config, tc.args.wsConn)\n\n\t\t\tws.Disconnect()\n\n\t\t\tws.chain.assert(t, tc.result)\n\t\t})\n\t}\n}\n\nfunc TestWebsocket_Printer(t *testing.T) {\n\tt.Run(\"print read\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tprinter := &mockWebsocketPrinter{}\n\t\tconfig := Config{\n\t\t\tReporter: reporter,\n\t\t\tPrinters: []Printer{printer},\n\t\t}.withDefaults()\n\t\tws := newWebsocket(newMockChain(t), config, &mockWebsocketConn{})\n\n\t\tws.printRead(websocket.CloseMessage,\n\t\t\t[]byte(\"random message\"),\n\t\t\twebsocket.CloseNormalClosure)\n\n\t\tif !printer.isReadFrom {\n\t\t\tt.Errorf(\"Websocket.printRead() failed to read from printer\")\n\t\t}\n\t})\n\n\tt.Run(\"print write\", func(t *testing.T) {\n\t\treporter := newMockReporter(t)\n\t\tprinter := &mockWebsocketPrinter{}\n\t\tconfig := Config{\n\t\t\tReporter: reporter,\n\t\t\tPrinters: []Printer{printer},\n\t\t}.withDefaults()\n\t\tws := newWebsocket(newMockChain(t), config, &mockWebsocketConn{})\n\n\t\tws.printWrite(websocket.CloseMessage,\n\t\t\t[]byte(\"random message\"),\n\t\t\twebsocket.CloseNormalClosure)\n\n\t\tif !printer.isWrittenTo {\n\t\t\tt.Errorf(\"Websocket.printWrite() failed to write to printer\")\n\t\t}\n\t})\n}\n"
        }
      ]
    }
  ]
}