{
  "metadata": {
    "timestamp": 1736566465147,
    "page": 11,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "natefinch/lumberjack",
      "stars": 4943,
      "defaultBranch": "v2.0",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2529296875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0947265625,
          "content": "language: go\n\ngo:\n  - tip\n  - 1.15.x\n  - 1.14.x\n  - 1.13.x\n  - 1.12.x\n  \nenv:\n  - GO111MODULE=on\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Nate Finch \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.2490234375,
          "content": "# lumberjack  [![GoDoc](https://godoc.org/gopkg.in/natefinch/lumberjack.v2?status.png)](https://godoc.org/gopkg.in/natefinch/lumberjack.v2) [![Build Status](https://travis-ci.org/natefinch/lumberjack.svg?branch=v2.0)](https://travis-ci.org/natefinch/lumberjack) [![Build status](https://ci.appveyor.com/api/projects/status/00gchpxtg4gkrt5d)](https://ci.appveyor.com/project/natefinch/lumberjack) [![Coverage Status](https://coveralls.io/repos/natefinch/lumberjack/badge.svg?branch=v2.0)](https://coveralls.io/r/natefinch/lumberjack?branch=v2.0)\n\n### Lumberjack is a Go package for writing logs to rolling files.\n\nPackage lumberjack provides a rolling logger.\n\nNote that this is v2.0 of lumberjack, and should be imported using gopkg.in\nthusly:\n\n    import \"gopkg.in/natefinch/lumberjack.v2\"\n\nThe package name remains simply lumberjack, and the code resides at\nhttps://github.com/natefinch/lumberjack under the v2.0 branch.\n\nLumberjack is intended to be one part of a logging infrastructure.\nIt is not an all-in-one solution, but instead is a pluggable\ncomponent at the bottom of the logging stack that simply controls the files\nto which logs are written.\n\nLumberjack plays well with any logging package that can write to an\nio.Writer, including the standard library's log package.\n\nLumberjack assumes that only one process is writing to the output files.\nUsing the same lumberjack configuration from multiple processes on the same\nmachine will result in improper behavior.\n\n\n**Example**\n\nTo use lumberjack with the standard library's log package, just pass it into the SetOutput function when your application starts.\n\nCode:\n\n```go\nlog.SetOutput(&lumberjack.Logger{\n    Filename:   \"/var/log/myapp/foo.log\",\n    MaxSize:    500, // megabytes\n    MaxBackups: 3,\n    MaxAge:     28, //days\n    Compress:   true, // disabled by default\n})\n```\n\n\n\n## type Logger\n``` go\ntype Logger struct {\n    // Filename is the file to write logs to.  Backup log files will be retained\n    // in the same directory.  It uses <processname>-lumberjack.log in\n    // os.TempDir() if empty.\n    Filename string `json:\"filename\" yaml:\"filename\"`\n\n    // MaxSize is the maximum size in megabytes of the log file before it gets\n    // rotated. It defaults to 100 megabytes.\n    MaxSize int `json:\"maxsize\" yaml:\"maxsize\"`\n\n    // MaxAge is the maximum number of days to retain old log files based on the\n    // timestamp encoded in their filename.  Note that a day is defined as 24\n    // hours and may not exactly correspond to calendar days due to daylight\n    // savings, leap seconds, etc. The default is not to remove old log files\n    // based on age.\n    MaxAge int `json:\"maxage\" yaml:\"maxage\"`\n\n    // MaxBackups is the maximum number of old log files to retain.  The default\n    // is to retain all old log files (though MaxAge may still cause them to get\n    // deleted.)\n    MaxBackups int `json:\"maxbackups\" yaml:\"maxbackups\"`\n\n    // LocalTime determines if the time used for formatting the timestamps in\n    // backup files is the computer's local time.  The default is to use UTC\n    // time.\n    LocalTime bool `json:\"localtime\" yaml:\"localtime\"`\n\n    // Compress determines if the rotated log files should be compressed\n    // using gzip. The default is not to perform compression.\n    Compress bool `json:\"compress\" yaml:\"compress\"`\n    // contains filtered or unexported fields\n}\n```\nLogger is an io.WriteCloser that writes to the specified filename.\n\nLogger opens or creates the logfile on first Write.  If the file exists and\nis less than MaxSize megabytes, lumberjack will open and append to that file.\nIf the file exists and its size is >= MaxSize megabytes, the file is renamed\nby putting the current time in a timestamp in the name immediately before the\nfile's extension (or the end of the filename if there's no extension). A new\nlog file is then created using original filename.\n\nWhenever a write would cause the current log file exceed MaxSize megabytes,\nthe current file is closed, renamed, and a new log file created with the\noriginal name. Thus, the filename you give Logger is always the \"current\" log\nfile.\n\nBackups use the log file name given to Logger, in the form `name-timestamp.ext`\nwhere name is the filename without the extension, timestamp is the time at which\nthe log was rotated formatted with the time.Time format of\n`2006-01-02T15-04-05.000` and the extension is the original extension.  For\nexample, if your Logger.Filename is `/var/log/foo/server.log`, a backup created\nat 6:30pm on Nov 11 2016 would use the filename\n`/var/log/foo/server-2016-11-04T18-30-00.000.log`\n\n### Cleaning Up Old Log Files\nWhenever a new logfile gets created, old log files may be deleted.  The most\nrecent files according to the encoded timestamp will be retained, up to a\nnumber equal to MaxBackups (or all of them if MaxBackups is 0).  Any files\nwith an encoded timestamp older than MaxAge days are deleted, regardless of\nMaxBackups.  Note that the time encoded in the timestamp is the rotation\ntime, which may differ from the last time that file was written to.\n\nIf MaxBackups and MaxAge are both 0, no old log files will be deleted.\n\n\n\n\n\n\n\n\n\n\n\n### func (\\*Logger) Close\n``` go\nfunc (l *Logger) Close() error\n```\nClose implements io.Closer, and closes the current logfile.\n\n\n\n### func (\\*Logger) Rotate\n``` go\nfunc (l *Logger) Rotate() error\n```\nRotate causes Logger to close the existing log file and immediately create a\nnew one.  This is a helper function for applications that want to initiate\nrotations outside of the normal rotation rules, such as in response to\nSIGHUP.  After rotating, this initiates a cleanup of old log files according\nto the normal rules.\n\n**Example**\n\nExample of how to rotate in response to SIGHUP.\n\nCode:\n\n```go\nl := &lumberjack.Logger{}\nlog.SetOutput(l)\nc := make(chan os.Signal, 1)\nsignal.Notify(c, syscall.SIGHUP)\n\ngo func() {\n    for {\n        <-c\n        l.Rotate()\n    }\n}()\n```\n\n### func (\\*Logger) Write\n``` go\nfunc (l *Logger) Write(p []byte) (n int, err error)\n```\nWrite implements io.Writer.  If a write would cause the log file to be larger\nthan MaxSize, the file is closed, renamed to include a timestamp of the\ncurrent time, and a new log file is created using the original log file name.\nIf the length of the write is greater than MaxSize, an error is returned.\n\n\n\n\n\n\n\n\n\n- - -\nGenerated by [godoc2md](http://godoc.org/github.com/davecheney/godoc2md)\n"
        },
        {
          "name": "chown.go",
          "type": "blob",
          "size": 0.111328125,
          "content": "// +build !linux\n\npackage lumberjack\n\nimport (\n\t\"os\"\n)\n\nfunc chown(_ string, _ os.FileInfo) error {\n\treturn nil\n}\n"
        },
        {
          "name": "chown_linux.go",
          "type": "blob",
          "size": 0.3837890625,
          "content": "package lumberjack\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\n// osChown is a var so we can mock it out during tests.\nvar osChown = os.Chown\n\nfunc chown(name string, info os.FileInfo) error {\n\tf, err := os.OpenFile(name, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, info.Mode())\n\tif err != nil {\n\t\treturn err\n\t}\n\tf.Close()\n\tstat := info.Sys().(*syscall.Stat_t)\n\treturn osChown(name, int(stat.Uid), int(stat.Gid))\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.373046875,
          "content": "package lumberjack\n\nimport (\n\t\"log\"\n)\n\n// To use lumberjack with the standard library's log package, just pass it into\n// the SetOutput function when your application starts.\nfunc Example() {\n\tlog.SetOutput(&Logger{\n\t\tFilename:   \"/var/log/myapp/foo.log\",\n\t\tMaxSize:    500, // megabytes\n\t\tMaxBackups: 3,\n\t\tMaxAge:     28,   // days\n\t\tCompress:   true, // disabled by default\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0478515625,
          "content": "module gopkg.in/natefinch/lumberjack.v2\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "linux_test.go",
          "type": "blob",
          "size": 3.9130859375,
          "content": "// +build linux\n\npackage lumberjack\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestMaintainMode(t *testing.T) {\n\tcurrentTime = fakeTime\n\tdir := makeTempDir(\"TestMaintainMode\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\n\tmode := os.FileMode(0600)\n\tf, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, mode)\n\tisNil(err, t)\n\tf.Close()\n\n\tl := &Logger{\n\t\tFilename:   filename,\n\t\tMaxBackups: 1,\n\t\tMaxSize:    100, // megabytes\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\tfilename2 := backupFile(dir)\n\tinfo, err := os.Stat(filename)\n\tisNil(err, t)\n\tinfo2, err := os.Stat(filename2)\n\tisNil(err, t)\n\tequals(mode, info.Mode(), t)\n\tequals(mode, info2.Mode(), t)\n}\n\nfunc TestMaintainOwner(t *testing.T) {\n\tfakeFS := newFakeFS()\n\tosChown = fakeFS.Chown\n\tosStat = fakeFS.Stat\n\tdefer func() {\n\t\tosChown = os.Chown\n\t\tosStat = os.Stat\n\t}()\n\tcurrentTime = fakeTime\n\tdir := makeTempDir(\"TestMaintainOwner\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\n\tf, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0644)\n\tisNil(err, t)\n\tf.Close()\n\n\tl := &Logger{\n\t\tFilename:   filename,\n\t\tMaxBackups: 1,\n\t\tMaxSize:    100, // megabytes\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\tequals(555, fakeFS.files[filename].uid, t)\n\tequals(666, fakeFS.files[filename].gid, t)\n}\n\nfunc TestCompressMaintainMode(t *testing.T) {\n\tcurrentTime = fakeTime\n\n\tdir := makeTempDir(\"TestCompressMaintainMode\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\n\tmode := os.FileMode(0600)\n\tf, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, mode)\n\tisNil(err, t)\n\tf.Close()\n\n\tl := &Logger{\n\t\tCompress:   true,\n\t\tFilename:   filename,\n\t\tMaxBackups: 1,\n\t\tMaxSize:    100, // megabytes\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\t// we need to wait a little bit since the files get compressed on a different\n\t// goroutine.\n\t<-time.After(10 * time.Millisecond)\n\n\t// a compressed version of the log file should now exist with the correct\n\t// mode.\n\tfilename2 := backupFile(dir)\n\tinfo, err := os.Stat(filename)\n\tisNil(err, t)\n\tinfo2, err := os.Stat(filename2 + compressSuffix)\n\tisNil(err, t)\n\tequals(mode, info.Mode(), t)\n\tequals(mode, info2.Mode(), t)\n}\n\nfunc TestCompressMaintainOwner(t *testing.T) {\n\tfakeFS := newFakeFS()\n\tosChown = fakeFS.Chown\n\tosStat = fakeFS.Stat\n\tdefer func() {\n\t\tosChown = os.Chown\n\t\tosStat = os.Stat\n\t}()\n\tcurrentTime = fakeTime\n\tdir := makeTempDir(\"TestCompressMaintainOwner\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\n\tf, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0644)\n\tisNil(err, t)\n\tf.Close()\n\n\tl := &Logger{\n\t\tCompress:   true,\n\t\tFilename:   filename,\n\t\tMaxBackups: 1,\n\t\tMaxSize:    100, // megabytes\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\t// we need to wait a little bit since the files get compressed on a different\n\t// goroutine.\n\t<-time.After(10 * time.Millisecond)\n\n\t// a compressed version of the log file should now exist with the correct\n\t// owner.\n\tfilename2 := backupFile(dir)\n\tequals(555, fakeFS.files[filename2+compressSuffix].uid, t)\n\tequals(666, fakeFS.files[filename2+compressSuffix].gid, t)\n}\n\ntype fakeFile struct {\n\tuid int\n\tgid int\n}\n\ntype fakeFS struct {\n\tfiles map[string]fakeFile\n}\n\nfunc newFakeFS() *fakeFS {\n\treturn &fakeFS{files: make(map[string]fakeFile)}\n}\n\nfunc (fs *fakeFS) Chown(name string, uid, gid int) error {\n\tfs.files[name] = fakeFile{uid: uid, gid: gid}\n\treturn nil\n}\n\nfunc (fs *fakeFS) Stat(name string) (os.FileInfo, error) {\n\tinfo, err := os.Stat(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstat := info.Sys().(*syscall.Stat_t)\n\tstat.Uid = 555\n\tstat.Gid = 666\n\treturn info, nil\n}\n"
        },
        {
          "name": "lumberjack.go",
          "type": "blob",
          "size": 15.2294921875,
          "content": "// Package lumberjack provides a rolling logger.\n//\n// Note that this is v2.0 of lumberjack, and should be imported using gopkg.in\n// thusly:\n//\n//   import \"gopkg.in/natefinch/lumberjack.v2\"\n//\n// The package name remains simply lumberjack, and the code resides at\n// https://github.com/natefinch/lumberjack under the v2.0 branch.\n//\n// Lumberjack is intended to be one part of a logging infrastructure.\n// It is not an all-in-one solution, but instead is a pluggable\n// component at the bottom of the logging stack that simply controls the files\n// to which logs are written.\n//\n// Lumberjack plays well with any logging package that can write to an\n// io.Writer, including the standard library's log package.\n//\n// Lumberjack assumes that only one process is writing to the output files.\n// Using the same lumberjack configuration from multiple processes on the same\n// machine will result in improper behavior.\npackage lumberjack\n\nimport (\n\t\"compress/gzip\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tbackupTimeFormat = \"2006-01-02T15-04-05.000\"\n\tcompressSuffix   = \".gz\"\n\tdefaultMaxSize   = 100\n)\n\n// ensure we always implement io.WriteCloser\nvar _ io.WriteCloser = (*Logger)(nil)\n\n// Logger is an io.WriteCloser that writes to the specified filename.\n//\n// Logger opens or creates the logfile on first Write.  If the file exists and\n// is less than MaxSize megabytes, lumberjack will open and append to that file.\n// If the file exists and its size is >= MaxSize megabytes, the file is renamed\n// by putting the current time in a timestamp in the name immediately before the\n// file's extension (or the end of the filename if there's no extension). A new\n// log file is then created using original filename.\n//\n// Whenever a write would cause the current log file exceed MaxSize megabytes,\n// the current file is closed, renamed, and a new log file created with the\n// original name. Thus, the filename you give Logger is always the \"current\" log\n// file.\n//\n// Backups use the log file name given to Logger, in the form\n// `name-timestamp.ext` where name is the filename without the extension,\n// timestamp is the time at which the log was rotated formatted with the\n// time.Time format of `2006-01-02T15-04-05.000` and the extension is the\n// original extension.  For example, if your Logger.Filename is\n// `/var/log/foo/server.log`, a backup created at 6:30pm on Nov 11 2016 would\n// use the filename `/var/log/foo/server-2016-11-04T18-30-00.000.log`\n//\n// Cleaning Up Old Log Files\n//\n// Whenever a new logfile gets created, old log files may be deleted.  The most\n// recent files according to the encoded timestamp will be retained, up to a\n// number equal to MaxBackups (or all of them if MaxBackups is 0).  Any files\n// with an encoded timestamp older than MaxAge days are deleted, regardless of\n// MaxBackups.  Note that the time encoded in the timestamp is the rotation\n// time, which may differ from the last time that file was written to.\n//\n// If MaxBackups and MaxAge are both 0, no old log files will be deleted.\ntype Logger struct {\n\t// Filename is the file to write logs to.  Backup log files will be retained\n\t// in the same directory.  It uses <processname>-lumberjack.log in\n\t// os.TempDir() if empty.\n\tFilename string `json:\"filename\" yaml:\"filename\"`\n\n\t// MaxSize is the maximum size in megabytes of the log file before it gets\n\t// rotated. It defaults to 100 megabytes.\n\tMaxSize int `json:\"maxsize\" yaml:\"maxsize\"`\n\n\t// MaxAge is the maximum number of days to retain old log files based on the\n\t// timestamp encoded in their filename.  Note that a day is defined as 24\n\t// hours and may not exactly correspond to calendar days due to daylight\n\t// savings, leap seconds, etc. The default is not to remove old log files\n\t// based on age.\n\tMaxAge int `json:\"maxage\" yaml:\"maxage\"`\n\n\t// MaxBackups is the maximum number of old log files to retain.  The default\n\t// is to retain all old log files (though MaxAge may still cause them to get\n\t// deleted.)\n\tMaxBackups int `json:\"maxbackups\" yaml:\"maxbackups\"`\n\n\t// LocalTime determines if the time used for formatting the timestamps in\n\t// backup files is the computer's local time.  The default is to use UTC\n\t// time.\n\tLocalTime bool `json:\"localtime\" yaml:\"localtime\"`\n\n\t// Compress determines if the rotated log files should be compressed\n\t// using gzip. The default is not to perform compression.\n\tCompress bool `json:\"compress\" yaml:\"compress\"`\n\n\tsize int64\n\tfile *os.File\n\tmu   sync.Mutex\n\n\tmillCh    chan bool\n\tstartMill sync.Once\n}\n\nvar (\n\t// currentTime exists so it can be mocked out by tests.\n\tcurrentTime = time.Now\n\n\t// os_Stat exists so it can be mocked out by tests.\n\tosStat = os.Stat\n\n\t// megabyte is the conversion factor between MaxSize and bytes.  It is a\n\t// variable so tests can mock it out and not need to write megabytes of data\n\t// to disk.\n\tmegabyte = 1024 * 1024\n)\n\n// Write implements io.Writer.  If a write would cause the log file to be larger\n// than MaxSize, the file is closed, renamed to include a timestamp of the\n// current time, and a new log file is created using the original log file name.\n// If the length of the write is greater than MaxSize, an error is returned.\nfunc (l *Logger) Write(p []byte) (n int, err error) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\n\twriteLen := int64(len(p))\n\tif writeLen > l.max() {\n\t\treturn 0, fmt.Errorf(\n\t\t\t\"write length %d exceeds maximum file size %d\", writeLen, l.max(),\n\t\t)\n\t}\n\n\tif l.file == nil {\n\t\tif err = l.openExistingOrNew(len(p)); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tif l.size+writeLen > l.max() {\n\t\tif err := l.rotate(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tn, err = l.file.Write(p)\n\tl.size += int64(n)\n\n\treturn n, err\n}\n\n// Close implements io.Closer, and closes the current logfile.\nfunc (l *Logger) Close() error {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\treturn l.close()\n}\n\n// close closes the file if it is open.\nfunc (l *Logger) close() error {\n\tif l.file == nil {\n\t\treturn nil\n\t}\n\terr := l.file.Close()\n\tl.file = nil\n\treturn err\n}\n\n// Rotate causes Logger to close the existing log file and immediately create a\n// new one.  This is a helper function for applications that want to initiate\n// rotations outside of the normal rotation rules, such as in response to\n// SIGHUP.  After rotating, this initiates compression and removal of old log\n// files according to the configuration.\nfunc (l *Logger) Rotate() error {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\treturn l.rotate()\n}\n\n// rotate closes the current file, moves it aside with a timestamp in the name,\n// (if it exists), opens a new file with the original filename, and then runs\n// post-rotation processing and removal.\nfunc (l *Logger) rotate() error {\n\tif err := l.close(); err != nil {\n\t\treturn err\n\t}\n\tif err := l.openNew(); err != nil {\n\t\treturn err\n\t}\n\tl.mill()\n\treturn nil\n}\n\n// openNew opens a new log file for writing, moving any old log file out of the\n// way.  This methods assumes the file has already been closed.\nfunc (l *Logger) openNew() error {\n\terr := os.MkdirAll(l.dir(), 0755)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't make directories for new logfile: %s\", err)\n\t}\n\n\tname := l.filename()\n\tmode := os.FileMode(0600)\n\tinfo, err := osStat(name)\n\tif err == nil {\n\t\t// Copy the mode off the old logfile.\n\t\tmode = info.Mode()\n\t\t// move the existing file\n\t\tnewname := backupName(name, l.LocalTime)\n\t\tif err := os.Rename(name, newname); err != nil {\n\t\t\treturn fmt.Errorf(\"can't rename log file: %s\", err)\n\t\t}\n\n\t\t// this is a no-op anywhere but linux\n\t\tif err := chown(name, info); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// we use truncate here because this should only get called when we've moved\n\t// the file ourselves. if someone else creates the file in the meantime,\n\t// just wipe out the contents.\n\tf, err := os.OpenFile(name, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't open new logfile: %s\", err)\n\t}\n\tl.file = f\n\tl.size = 0\n\treturn nil\n}\n\n// backupName creates a new filename from the given name, inserting a timestamp\n// between the filename and the extension, using the local time if requested\n// (otherwise UTC).\nfunc backupName(name string, local bool) string {\n\tdir := filepath.Dir(name)\n\tfilename := filepath.Base(name)\n\text := filepath.Ext(filename)\n\tprefix := filename[:len(filename)-len(ext)]\n\tt := currentTime()\n\tif !local {\n\t\tt = t.UTC()\n\t}\n\n\ttimestamp := t.Format(backupTimeFormat)\n\treturn filepath.Join(dir, fmt.Sprintf(\"%s-%s%s\", prefix, timestamp, ext))\n}\n\n// openExistingOrNew opens the logfile if it exists and if the current write\n// would not put it over MaxSize.  If there is no such file or the write would\n// put it over the MaxSize, a new file is created.\nfunc (l *Logger) openExistingOrNew(writeLen int) error {\n\tl.mill()\n\n\tfilename := l.filename()\n\tinfo, err := osStat(filename)\n\tif os.IsNotExist(err) {\n\t\treturn l.openNew()\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error getting log file info: %s\", err)\n\t}\n\n\tif info.Size()+int64(writeLen) >= l.max() {\n\t\treturn l.rotate()\n\t}\n\n\tfile, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\t// if we fail to open the old log file for some reason, just ignore\n\t\t// it and open a new log file.\n\t\treturn l.openNew()\n\t}\n\tl.file = file\n\tl.size = info.Size()\n\treturn nil\n}\n\n// filename generates the name of the logfile from the current time.\nfunc (l *Logger) filename() string {\n\tif l.Filename != \"\" {\n\t\treturn l.Filename\n\t}\n\tname := filepath.Base(os.Args[0]) + \"-lumberjack.log\"\n\treturn filepath.Join(os.TempDir(), name)\n}\n\n// millRunOnce performs compression and removal of stale log files.\n// Log files are compressed if enabled via configuration and old log\n// files are removed, keeping at most l.MaxBackups files, as long as\n// none of them are older than MaxAge.\nfunc (l *Logger) millRunOnce() error {\n\tif l.MaxBackups == 0 && l.MaxAge == 0 && !l.Compress {\n\t\treturn nil\n\t}\n\n\tfiles, err := l.oldLogFiles()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar compress, remove []logInfo\n\n\tif l.MaxBackups > 0 && l.MaxBackups < len(files) {\n\t\tpreserved := make(map[string]bool)\n\t\tvar remaining []logInfo\n\t\tfor _, f := range files {\n\t\t\t// Only count the uncompressed log file or the\n\t\t\t// compressed log file, not both.\n\t\t\tfn := f.Name()\n\t\t\tif strings.HasSuffix(fn, compressSuffix) {\n\t\t\t\tfn = fn[:len(fn)-len(compressSuffix)]\n\t\t\t}\n\t\t\tpreserved[fn] = true\n\n\t\t\tif len(preserved) > l.MaxBackups {\n\t\t\t\tremove = append(remove, f)\n\t\t\t} else {\n\t\t\t\tremaining = append(remaining, f)\n\t\t\t}\n\t\t}\n\t\tfiles = remaining\n\t}\n\tif l.MaxAge > 0 {\n\t\tdiff := time.Duration(int64(24*time.Hour) * int64(l.MaxAge))\n\t\tcutoff := currentTime().Add(-1 * diff)\n\n\t\tvar remaining []logInfo\n\t\tfor _, f := range files {\n\t\t\tif f.timestamp.Before(cutoff) {\n\t\t\t\tremove = append(remove, f)\n\t\t\t} else {\n\t\t\t\tremaining = append(remaining, f)\n\t\t\t}\n\t\t}\n\t\tfiles = remaining\n\t}\n\n\tif l.Compress {\n\t\tfor _, f := range files {\n\t\t\tif !strings.HasSuffix(f.Name(), compressSuffix) {\n\t\t\t\tcompress = append(compress, f)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, f := range remove {\n\t\terrRemove := os.Remove(filepath.Join(l.dir(), f.Name()))\n\t\tif err == nil && errRemove != nil {\n\t\t\terr = errRemove\n\t\t}\n\t}\n\tfor _, f := range compress {\n\t\tfn := filepath.Join(l.dir(), f.Name())\n\t\terrCompress := compressLogFile(fn, fn+compressSuffix)\n\t\tif err == nil && errCompress != nil {\n\t\t\terr = errCompress\n\t\t}\n\t}\n\n\treturn err\n}\n\n// millRun runs in a goroutine to manage post-rotation compression and removal\n// of old log files.\nfunc (l *Logger) millRun() {\n\tfor range l.millCh {\n\t\t// what am I going to do, log this?\n\t\t_ = l.millRunOnce()\n\t}\n}\n\n// mill performs post-rotation compression and removal of stale log files,\n// starting the mill goroutine if necessary.\nfunc (l *Logger) mill() {\n\tl.startMill.Do(func() {\n\t\tl.millCh = make(chan bool, 1)\n\t\tgo l.millRun()\n\t})\n\tselect {\n\tcase l.millCh <- true:\n\tdefault:\n\t}\n}\n\n// oldLogFiles returns the list of backup log files stored in the same\n// directory as the current log file, sorted by ModTime\nfunc (l *Logger) oldLogFiles() ([]logInfo, error) {\n\tfiles, err := ioutil.ReadDir(l.dir())\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't read log file directory: %s\", err)\n\t}\n\tlogFiles := []logInfo{}\n\n\tprefix, ext := l.prefixAndExt()\n\n\tfor _, f := range files {\n\t\tif f.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tif t, err := l.timeFromName(f.Name(), prefix, ext); err == nil {\n\t\t\tlogFiles = append(logFiles, logInfo{t, f})\n\t\t\tcontinue\n\t\t}\n\t\tif t, err := l.timeFromName(f.Name(), prefix, ext+compressSuffix); err == nil {\n\t\t\tlogFiles = append(logFiles, logInfo{t, f})\n\t\t\tcontinue\n\t\t}\n\t\t// error parsing means that the suffix at the end was not generated\n\t\t// by lumberjack, and therefore it's not a backup file.\n\t}\n\n\tsort.Sort(byFormatTime(logFiles))\n\n\treturn logFiles, nil\n}\n\n// timeFromName extracts the formatted time from the filename by stripping off\n// the filename's prefix and extension. This prevents someone's filename from\n// confusing time.parse.\nfunc (l *Logger) timeFromName(filename, prefix, ext string) (time.Time, error) {\n\tif !strings.HasPrefix(filename, prefix) {\n\t\treturn time.Time{}, errors.New(\"mismatched prefix\")\n\t}\n\tif !strings.HasSuffix(filename, ext) {\n\t\treturn time.Time{}, errors.New(\"mismatched extension\")\n\t}\n\tts := filename[len(prefix) : len(filename)-len(ext)]\n\treturn time.Parse(backupTimeFormat, ts)\n}\n\n// max returns the maximum size in bytes of log files before rolling.\nfunc (l *Logger) max() int64 {\n\tif l.MaxSize == 0 {\n\t\treturn int64(defaultMaxSize * megabyte)\n\t}\n\treturn int64(l.MaxSize) * int64(megabyte)\n}\n\n// dir returns the directory for the current filename.\nfunc (l *Logger) dir() string {\n\treturn filepath.Dir(l.filename())\n}\n\n// prefixAndExt returns the filename part and extension part from the Logger's\n// filename.\nfunc (l *Logger) prefixAndExt() (prefix, ext string) {\n\tfilename := filepath.Base(l.filename())\n\text = filepath.Ext(filename)\n\tprefix = filename[:len(filename)-len(ext)] + \"-\"\n\treturn prefix, ext\n}\n\n// compressLogFile compresses the given log file, removing the\n// uncompressed log file if successful.\nfunc compressLogFile(src, dst string) (err error) {\n\tf, err := os.Open(src)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open log file: %v\", err)\n\t}\n\tdefer f.Close()\n\n\tfi, err := osStat(src)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to stat log file: %v\", err)\n\t}\n\n\tif err := chown(dst, fi); err != nil {\n\t\treturn fmt.Errorf(\"failed to chown compressed log file: %v\", err)\n\t}\n\n\t// If this file already exists, we presume it was created by\n\t// a previous attempt to compress the log file.\n\tgzf, err := os.OpenFile(dst, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, fi.Mode())\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open compressed log file: %v\", err)\n\t}\n\tdefer gzf.Close()\n\n\tgz := gzip.NewWriter(gzf)\n\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tos.Remove(dst)\n\t\t\terr = fmt.Errorf(\"failed to compress log file: %v\", err)\n\t\t}\n\t}()\n\n\tif _, err := io.Copy(gz, f); err != nil {\n\t\treturn err\n\t}\n\tif err := gz.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := gzf.Close(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := f.Close(); err != nil {\n\t\treturn err\n\t}\n\tif err := os.Remove(src); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// logInfo is a convenience struct to return the filename and its embedded\n// timestamp.\ntype logInfo struct {\n\ttimestamp time.Time\n\tos.FileInfo\n}\n\n// byFormatTime sorts by newest time formatted in the name.\ntype byFormatTime []logInfo\n\nfunc (b byFormatTime) Less(i, j int) bool {\n\treturn b[i].timestamp.After(b[j].timestamp)\n}\n\nfunc (b byFormatTime) Swap(i, j int) {\n\tb[i], b[j] = b[j], b[i]\n}\n\nfunc (b byFormatTime) Len() int {\n\treturn len(b)\n}\n"
        },
        {
          "name": "lumberjack_test.go",
          "type": "blob",
          "size": 17.7421875,
          "content": "package lumberjack\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n)\n\n// !!!NOTE!!!\n//\n// Running these tests in parallel will almost certainly cause sporadic (or even\n// regular) failures, because they're all messing with the same global variable\n// that controls the logic's mocked time.Now.  So... don't do that.\n\n// Since all the tests uses the time to determine filenames etc, we need to\n// control the wall clock as much as possible, which means having a wall clock\n// that doesn't change unless we want it to.\nvar fakeCurrentTime = time.Now()\n\nfunc fakeTime() time.Time {\n\treturn fakeCurrentTime\n}\n\nfunc TestNewFile(t *testing.T) {\n\tcurrentTime = fakeTime\n\n\tdir := makeTempDir(\"TestNewFile\", t)\n\tdefer os.RemoveAll(dir)\n\tl := &Logger{\n\t\tFilename: logFile(dir),\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\texistsWithContent(logFile(dir), b, t)\n\tfileCount(dir, 1, t)\n}\n\nfunc TestOpenExisting(t *testing.T) {\n\tcurrentTime = fakeTime\n\tdir := makeTempDir(\"TestOpenExisting\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tdata := []byte(\"foo!\")\n\terr := ioutil.WriteFile(filename, data, 0644)\n\tisNil(err, t)\n\texistsWithContent(filename, data, t)\n\n\tl := &Logger{\n\t\tFilename: filename,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\t// make sure the file got appended\n\texistsWithContent(filename, append(data, b...), t)\n\n\t// make sure no other files were created\n\tfileCount(dir, 1, t)\n}\n\nfunc TestWriteTooLong(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\tdir := makeTempDir(\"TestWriteTooLong\", t)\n\tdefer os.RemoveAll(dir)\n\tl := &Logger{\n\t\tFilename: logFile(dir),\n\t\tMaxSize:  5,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"booooooooooooooo!\")\n\tn, err := l.Write(b)\n\tnotNil(err, t)\n\tequals(0, n, t)\n\tequals(err.Error(),\n\t\tfmt.Sprintf(\"write length %d exceeds maximum file size %d\", len(b), l.MaxSize), t)\n\t_, err = os.Stat(logFile(dir))\n\tassert(os.IsNotExist(err), t, \"File exists, but should not have been created\")\n}\n\nfunc TestMakeLogDir(t *testing.T) {\n\tcurrentTime = fakeTime\n\tdir := time.Now().Format(\"TestMakeLogDir\" + backupTimeFormat)\n\tdir = filepath.Join(os.TempDir(), dir)\n\tdefer os.RemoveAll(dir)\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tFilename: filename,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\texistsWithContent(logFile(dir), b, t)\n\tfileCount(dir, 1, t)\n}\n\nfunc TestDefaultFilename(t *testing.T) {\n\tcurrentTime = fakeTime\n\tdir := os.TempDir()\n\tfilename := filepath.Join(dir, filepath.Base(os.Args[0])+\"-lumberjack.log\")\n\tdefer os.Remove(filename)\n\tl := &Logger{}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\texistsWithContent(filename, b, t)\n}\n\nfunc TestAutoRotate(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestAutoRotate\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tFilename: filename,\n\t\tMaxSize:  10,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\texistsWithContent(filename, b, t)\n\tfileCount(dir, 1, t)\n\n\tnewFakeTime()\n\n\tb2 := []byte(\"foooooo!\")\n\tn, err = l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n, t)\n\n\t// the old logfile should be moved aside and the main logfile should have\n\t// only the last write in it.\n\texistsWithContent(filename, b2, t)\n\n\t// the backup file will use the current fake time and have the old contents.\n\texistsWithContent(backupFile(dir), b, t)\n\n\tfileCount(dir, 2, t)\n}\n\nfunc TestFirstWriteRotate(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\tdir := makeTempDir(\"TestFirstWriteRotate\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tFilename: filename,\n\t\tMaxSize:  10,\n\t}\n\tdefer l.Close()\n\n\tstart := []byte(\"boooooo!\")\n\terr := ioutil.WriteFile(filename, start, 0600)\n\tisNil(err, t)\n\n\tnewFakeTime()\n\n\t// this would make us rotate\n\tb := []byte(\"fooo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\texistsWithContent(filename, b, t)\n\texistsWithContent(backupFile(dir), start, t)\n\n\tfileCount(dir, 2, t)\n}\n\nfunc TestMaxBackups(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\tdir := makeTempDir(\"TestMaxBackups\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tFilename:   filename,\n\t\tMaxSize:    10,\n\t\tMaxBackups: 1,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\texistsWithContent(filename, b, t)\n\tfileCount(dir, 1, t)\n\n\tnewFakeTime()\n\n\t// this will put us over the max\n\tb2 := []byte(\"foooooo!\")\n\tn, err = l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n, t)\n\n\t// this will use the new fake time\n\tsecondFilename := backupFile(dir)\n\texistsWithContent(secondFilename, b, t)\n\n\t// make sure the old file still exists with the same content.\n\texistsWithContent(filename, b2, t)\n\n\tfileCount(dir, 2, t)\n\n\tnewFakeTime()\n\n\t// this will make us rotate again\n\tb3 := []byte(\"baaaaaar!\")\n\tn, err = l.Write(b3)\n\tisNil(err, t)\n\tequals(len(b3), n, t)\n\n\t// this will use the new fake time\n\tthirdFilename := backupFile(dir)\n\texistsWithContent(thirdFilename, b2, t)\n\n\texistsWithContent(filename, b3, t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(time.Millisecond * 10)\n\n\t// should only have two files in the dir still\n\tfileCount(dir, 2, t)\n\n\t// second file name should still exist\n\texistsWithContent(thirdFilename, b2, t)\n\n\t// should have deleted the first backup\n\tnotExist(secondFilename, t)\n\n\t// now test that we don't delete directories or non-logfile files\n\n\tnewFakeTime()\n\n\t// create a file that is close to but different from the logfile name.\n\t// It shouldn't get caught by our deletion filters.\n\tnotlogfile := logFile(dir) + \".foo\"\n\terr = ioutil.WriteFile(notlogfile, []byte(\"data\"), 0644)\n\tisNil(err, t)\n\n\t// Make a directory that exactly matches our log file filters... it still\n\t// shouldn't get caught by the deletion filter since it's a directory.\n\tnotlogfiledir := backupFile(dir)\n\terr = os.Mkdir(notlogfiledir, 0700)\n\tisNil(err, t)\n\n\tnewFakeTime()\n\n\t// this will use the new fake time\n\tfourthFilename := backupFile(dir)\n\n\t// Create a log file that is/was being compressed - this should\n\t// not be counted since both the compressed and the uncompressed\n\t// log files still exist.\n\tcompLogFile := fourthFilename + compressSuffix\n\terr = ioutil.WriteFile(compLogFile, []byte(\"compress\"), 0644)\n\tisNil(err, t)\n\n\t// this will make us rotate again\n\tb4 := []byte(\"baaaaaaz!\")\n\tn, err = l.Write(b4)\n\tisNil(err, t)\n\tequals(len(b4), n, t)\n\n\texistsWithContent(fourthFilename, b3, t)\n\texistsWithContent(fourthFilename+compressSuffix, []byte(\"compress\"), t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(time.Millisecond * 10)\n\n\t// We should have four things in the directory now - the 2 log files, the\n\t// not log file, and the directory\n\tfileCount(dir, 5, t)\n\n\t// third file name should still exist\n\texistsWithContent(filename, b4, t)\n\n\texistsWithContent(fourthFilename, b3, t)\n\n\t// should have deleted the first filename\n\tnotExist(thirdFilename, t)\n\n\t// the not-a-logfile should still exist\n\texists(notlogfile, t)\n\n\t// the directory\n\texists(notlogfiledir, t)\n}\n\nfunc TestCleanupExistingBackups(t *testing.T) {\n\t// test that if we start with more backup files than we're supposed to have\n\t// in total, that extra ones get cleaned up when we rotate.\n\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestCleanupExistingBackups\", t)\n\tdefer os.RemoveAll(dir)\n\n\t// make 3 backup files\n\n\tdata := []byte(\"data\")\n\tbackup := backupFile(dir)\n\terr := ioutil.WriteFile(backup, data, 0644)\n\tisNil(err, t)\n\n\tnewFakeTime()\n\n\tbackup = backupFile(dir)\n\terr = ioutil.WriteFile(backup+compressSuffix, data, 0644)\n\tisNil(err, t)\n\n\tnewFakeTime()\n\n\tbackup = backupFile(dir)\n\terr = ioutil.WriteFile(backup, data, 0644)\n\tisNil(err, t)\n\n\t// now create a primary log file with some data\n\tfilename := logFile(dir)\n\terr = ioutil.WriteFile(filename, data, 0644)\n\tisNil(err, t)\n\n\tl := &Logger{\n\t\tFilename:   filename,\n\t\tMaxSize:    10,\n\t\tMaxBackups: 1,\n\t}\n\tdefer l.Close()\n\n\tnewFakeTime()\n\n\tb2 := []byte(\"foooooo!\")\n\tn, err := l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n, t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(time.Millisecond * 10)\n\n\t// now we should only have 2 files left - the primary and one backup\n\tfileCount(dir, 2, t)\n}\n\nfunc TestMaxAge(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestMaxAge\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tFilename: filename,\n\t\tMaxSize:  10,\n\t\tMaxAge:   1,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\texistsWithContent(filename, b, t)\n\tfileCount(dir, 1, t)\n\n\t// two days later\n\tnewFakeTime()\n\n\tb2 := []byte(\"foooooo!\")\n\tn, err = l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n, t)\n\texistsWithContent(backupFile(dir), b, t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(10 * time.Millisecond)\n\n\t// We should still have 2 log files, since the most recent backup was just\n\t// created.\n\tfileCount(dir, 2, t)\n\n\texistsWithContent(filename, b2, t)\n\n\t// we should have deleted the old file due to being too old\n\texistsWithContent(backupFile(dir), b, t)\n\n\t// two days later\n\tnewFakeTime()\n\n\tb3 := []byte(\"baaaaar!\")\n\tn, err = l.Write(b3)\n\tisNil(err, t)\n\tequals(len(b3), n, t)\n\texistsWithContent(backupFile(dir), b2, t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(10 * time.Millisecond)\n\n\t// We should have 2 log files - the main log file, and the most recent\n\t// backup.  The earlier backup is past the cutoff and should be gone.\n\tfileCount(dir, 2, t)\n\n\texistsWithContent(filename, b3, t)\n\n\t// we should have deleted the old file due to being too old\n\texistsWithContent(backupFile(dir), b2, t)\n}\n\nfunc TestOldLogFiles(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestOldLogFiles\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tdata := []byte(\"data\")\n\terr := ioutil.WriteFile(filename, data, 07)\n\tisNil(err, t)\n\n\t// This gives us a time with the same precision as the time we get from the\n\t// timestamp in the name.\n\tt1, err := time.Parse(backupTimeFormat, fakeTime().UTC().Format(backupTimeFormat))\n\tisNil(err, t)\n\n\tbackup := backupFile(dir)\n\terr = ioutil.WriteFile(backup, data, 07)\n\tisNil(err, t)\n\n\tnewFakeTime()\n\n\tt2, err := time.Parse(backupTimeFormat, fakeTime().UTC().Format(backupTimeFormat))\n\tisNil(err, t)\n\n\tbackup2 := backupFile(dir)\n\terr = ioutil.WriteFile(backup2, data, 07)\n\tisNil(err, t)\n\n\tl := &Logger{Filename: filename}\n\tfiles, err := l.oldLogFiles()\n\tisNil(err, t)\n\tequals(2, len(files), t)\n\n\t// should be sorted by newest file first, which would be t2\n\tequals(t2, files[0].timestamp, t)\n\tequals(t1, files[1].timestamp, t)\n}\n\nfunc TestTimeFromName(t *testing.T) {\n\tl := &Logger{Filename: \"/var/log/myfoo/foo.log\"}\n\tprefix, ext := l.prefixAndExt()\n\n\ttests := []struct {\n\t\tfilename string\n\t\twant     time.Time\n\t\twantErr  bool\n\t}{\n\t\t{\"foo-2014-05-04T14-44-33.555.log\", time.Date(2014, 5, 4, 14, 44, 33, 555000000, time.UTC), false},\n\t\t{\"foo-2014-05-04T14-44-33.555\", time.Time{}, true},\n\t\t{\"2014-05-04T14-44-33.555.log\", time.Time{}, true},\n\t\t{\"foo.log\", time.Time{}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot, err := l.timeFromName(test.filename, prefix, ext)\n\t\tequals(got, test.want, t)\n\t\tequals(err != nil, test.wantErr, t)\n\t}\n}\n\nfunc TestLocalTime(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestLocalTime\", t)\n\tdefer os.RemoveAll(dir)\n\n\tl := &Logger{\n\t\tFilename:  logFile(dir),\n\t\tMaxSize:   10,\n\t\tLocalTime: true,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\tb2 := []byte(\"fooooooo!\")\n\tn2, err := l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n2, t)\n\n\texistsWithContent(logFile(dir), b2, t)\n\texistsWithContent(backupFileLocal(dir), b, t)\n}\n\nfunc TestRotate(t *testing.T) {\n\tcurrentTime = fakeTime\n\tdir := makeTempDir(\"TestRotate\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\n\tl := &Logger{\n\t\tFilename:   filename,\n\t\tMaxBackups: 1,\n\t\tMaxSize:    100, // megabytes\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\texistsWithContent(filename, b, t)\n\tfileCount(dir, 1, t)\n\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(10 * time.Millisecond)\n\n\tfilename2 := backupFile(dir)\n\texistsWithContent(filename2, b, t)\n\texistsWithContent(filename, []byte{}, t)\n\tfileCount(dir, 2, t)\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\t// we need to wait a little bit since the files get deleted on a different\n\t// goroutine.\n\t<-time.After(10 * time.Millisecond)\n\n\tfilename3 := backupFile(dir)\n\texistsWithContent(filename3, []byte{}, t)\n\texistsWithContent(filename, []byte{}, t)\n\tfileCount(dir, 2, t)\n\n\tb2 := []byte(\"foooooo!\")\n\tn, err = l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n, t)\n\n\t// this will use the new fake time\n\texistsWithContent(filename, b2, t)\n}\n\nfunc TestCompressOnRotate(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestCompressOnRotate\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tCompress: true,\n\t\tFilename: filename,\n\t\tMaxSize:  10,\n\t}\n\tdefer l.Close()\n\tb := []byte(\"boo!\")\n\tn, err := l.Write(b)\n\tisNil(err, t)\n\tequals(len(b), n, t)\n\n\texistsWithContent(filename, b, t)\n\tfileCount(dir, 1, t)\n\n\tnewFakeTime()\n\n\terr = l.Rotate()\n\tisNil(err, t)\n\n\t// the old logfile should be moved aside and the main logfile should have\n\t// nothing in it.\n\texistsWithContent(filename, []byte{}, t)\n\n\t// we need to wait a little bit since the files get compressed on a different\n\t// goroutine.\n\t<-time.After(300 * time.Millisecond)\n\n\t// a compressed version of the log file should now exist and the original\n\t// should have been removed.\n\tbc := new(bytes.Buffer)\n\tgz := gzip.NewWriter(bc)\n\t_, err = gz.Write(b)\n\tisNil(err, t)\n\terr = gz.Close()\n\tisNil(err, t)\n\texistsWithContent(backupFile(dir)+compressSuffix, bc.Bytes(), t)\n\tnotExist(backupFile(dir), t)\n\n\tfileCount(dir, 2, t)\n}\n\nfunc TestCompressOnResume(t *testing.T) {\n\tcurrentTime = fakeTime\n\tmegabyte = 1\n\n\tdir := makeTempDir(\"TestCompressOnResume\", t)\n\tdefer os.RemoveAll(dir)\n\n\tfilename := logFile(dir)\n\tl := &Logger{\n\t\tCompress: true,\n\t\tFilename: filename,\n\t\tMaxSize:  10,\n\t}\n\tdefer l.Close()\n\n\t// Create a backup file and empty \"compressed\" file.\n\tfilename2 := backupFile(dir)\n\tb := []byte(\"foo!\")\n\terr := ioutil.WriteFile(filename2, b, 0644)\n\tisNil(err, t)\n\terr = ioutil.WriteFile(filename2+compressSuffix, []byte{}, 0644)\n\tisNil(err, t)\n\n\tnewFakeTime()\n\n\tb2 := []byte(\"boo!\")\n\tn, err := l.Write(b2)\n\tisNil(err, t)\n\tequals(len(b2), n, t)\n\texistsWithContent(filename, b2, t)\n\n\t// we need to wait a little bit since the files get compressed on a different\n\t// goroutine.\n\t<-time.After(300 * time.Millisecond)\n\n\t// The write should have started the compression - a compressed version of\n\t// the log file should now exist and the original should have been removed.\n\tbc := new(bytes.Buffer)\n\tgz := gzip.NewWriter(bc)\n\t_, err = gz.Write(b)\n\tisNil(err, t)\n\terr = gz.Close()\n\tisNil(err, t)\n\texistsWithContent(filename2+compressSuffix, bc.Bytes(), t)\n\tnotExist(filename2, t)\n\n\tfileCount(dir, 2, t)\n}\n\nfunc TestJson(t *testing.T) {\n\tdata := []byte(`\n{\n\t\"filename\": \"foo\",\n\t\"maxsize\": 5,\n\t\"maxage\": 10,\n\t\"maxbackups\": 3,\n\t\"localtime\": true,\n\t\"compress\": true\n}`[1:])\n\n\tl := Logger{}\n\terr := json.Unmarshal(data, &l)\n\tisNil(err, t)\n\tequals(\"foo\", l.Filename, t)\n\tequals(5, l.MaxSize, t)\n\tequals(10, l.MaxAge, t)\n\tequals(3, l.MaxBackups, t)\n\tequals(true, l.LocalTime, t)\n\tequals(true, l.Compress, t)\n}\n\n// makeTempDir creates a file with a semi-unique name in the OS temp directory.\n// It should be based on the name of the test, to keep parallel tests from\n// colliding, and must be cleaned up after the test is finished.\nfunc makeTempDir(name string, t testing.TB) string {\n\tdir := time.Now().Format(name + backupTimeFormat)\n\tdir = filepath.Join(os.TempDir(), dir)\n\tisNilUp(os.Mkdir(dir, 0700), t, 1)\n\treturn dir\n}\n\n// existsWithContent checks that the given file exists and has the correct content.\nfunc existsWithContent(path string, content []byte, t testing.TB) {\n\tinfo, err := os.Stat(path)\n\tisNilUp(err, t, 1)\n\tequalsUp(int64(len(content)), info.Size(), t, 1)\n\n\tb, err := ioutil.ReadFile(path)\n\tisNilUp(err, t, 1)\n\tequalsUp(content, b, t, 1)\n}\n\n// logFile returns the log file name in the given directory for the current fake\n// time.\nfunc logFile(dir string) string {\n\treturn filepath.Join(dir, \"foobar.log\")\n}\n\nfunc backupFile(dir string) string {\n\treturn filepath.Join(dir, \"foobar-\"+fakeTime().UTC().Format(backupTimeFormat)+\".log\")\n}\n\nfunc backupFileLocal(dir string) string {\n\treturn filepath.Join(dir, \"foobar-\"+fakeTime().Format(backupTimeFormat)+\".log\")\n}\n\n// logFileLocal returns the log file name in the given directory for the current\n// fake time using the local timezone.\nfunc logFileLocal(dir string) string {\n\treturn filepath.Join(dir, fakeTime().Format(backupTimeFormat))\n}\n\n// fileCount checks that the number of files in the directory is exp.\nfunc fileCount(dir string, exp int, t testing.TB) {\n\tfiles, err := ioutil.ReadDir(dir)\n\tisNilUp(err, t, 1)\n\t// Make sure no other files were created.\n\tequalsUp(exp, len(files), t, 1)\n}\n\n// newFakeTime sets the fake \"current time\" to two days later.\nfunc newFakeTime() {\n\tfakeCurrentTime = fakeCurrentTime.Add(time.Hour * 24 * 2)\n}\n\nfunc notExist(path string, t testing.TB) {\n\t_, err := os.Stat(path)\n\tassertUp(os.IsNotExist(err), t, 1, \"expected to get os.IsNotExist, but instead got %v\", err)\n}\n\nfunc exists(path string, t testing.TB) {\n\t_, err := os.Stat(path)\n\tassertUp(err == nil, t, 1, \"expected file to exist, but got error from os.Stat: %v\", err)\n}\n"
        },
        {
          "name": "rotate_test.go",
          "type": "blob",
          "size": 0.3115234375,
          "content": "// +build linux\n\npackage lumberjack\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n)\n\n// Example of how to rotate in response to SIGHUP.\nfunc ExampleLogger_Rotate() {\n\tl := &Logger{}\n\tlog.SetOutput(l)\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGHUP)\n\n\tgo func() {\n\t\tfor {\n\t\t\t<-c\n\t\t\tl.Rotate()\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "testing_test.go",
          "type": "blob",
          "size": 2.78125,
          "content": "package lumberjack\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"testing\"\n)\n\n// assert will log the given message if condition is false.\nfunc assert(condition bool, t testing.TB, msg string, v ...interface{}) {\n\tassertUp(condition, t, 1, msg, v...)\n}\n\n// assertUp is like assert, but used inside helper functions, to ensure that\n// the file and line number reported by failures corresponds to one or more\n// levels up the stack.\nfunc assertUp(condition bool, t testing.TB, caller int, msg string, v ...interface{}) {\n\tif !condition {\n\t\t_, file, line, _ := runtime.Caller(caller + 1)\n\t\tv = append([]interface{}{filepath.Base(file), line}, v...)\n\t\tfmt.Printf(\"%s:%d: \"+msg+\"\\n\", v...)\n\t\tt.FailNow()\n\t}\n}\n\n// equals tests that the two values are equal according to reflect.DeepEqual.\nfunc equals(exp, act interface{}, t testing.TB) {\n\tequalsUp(exp, act, t, 1)\n}\n\n// equalsUp is like equals, but used inside helper functions, to ensure that the\n// file and line number reported by failures corresponds to one or more levels\n// up the stack.\nfunc equalsUp(exp, act interface{}, t testing.TB, caller int) {\n\tif !reflect.DeepEqual(exp, act) {\n\t\t_, file, line, _ := runtime.Caller(caller + 1)\n\t\tfmt.Printf(\"%s:%d: exp: %v (%T), got: %v (%T)\\n\",\n\t\t\tfilepath.Base(file), line, exp, exp, act, act)\n\t\tt.FailNow()\n\t}\n}\n\n// isNil reports a failure if the given value is not nil.  Note that values\n// which cannot be nil will always fail this check.\nfunc isNil(obtained interface{}, t testing.TB) {\n\tisNilUp(obtained, t, 1)\n}\n\n// isNilUp is like isNil, but used inside helper functions, to ensure that the\n// file and line number reported by failures corresponds to one or more levels\n// up the stack.\nfunc isNilUp(obtained interface{}, t testing.TB, caller int) {\n\tif !_isNil(obtained) {\n\t\t_, file, line, _ := runtime.Caller(caller + 1)\n\t\tfmt.Printf(\"%s:%d: expected nil, got: %v\\n\", filepath.Base(file), line, obtained)\n\t\tt.FailNow()\n\t}\n}\n\n// notNil reports a failure if the given value is nil.\nfunc notNil(obtained interface{}, t testing.TB) {\n\tnotNilUp(obtained, t, 1)\n}\n\n// notNilUp is like notNil, but used inside helper functions, to ensure that the\n// file and line number reported by failures corresponds to one or more levels\n// up the stack.\nfunc notNilUp(obtained interface{}, t testing.TB, caller int) {\n\tif _isNil(obtained) {\n\t\t_, file, line, _ := runtime.Caller(caller + 1)\n\t\tfmt.Printf(\"%s:%d: expected non-nil, got: %v\\n\", filepath.Base(file), line, obtained)\n\t\tt.FailNow()\n\t}\n}\n\n// _isNil is a helper function for isNil and notNil, and should not be used\n// directly.\nfunc _isNil(obtained interface{}) bool {\n\tif obtained == nil {\n\t\treturn true\n\t}\n\n\tswitch v := reflect.ValueOf(obtained); v.Kind() {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:\n\t\treturn v.IsNil()\n\t}\n\n\treturn false\n}\n"
        }
      ]
    }
  ]
}