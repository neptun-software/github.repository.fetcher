{
  "metadata": {
    "timestamp": 1736567333236,
    "page": 943,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "onsi/gomega",
      "stars": 2211,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": ".DS_Store\n*.test\n.\n.idea\ngomega.iml\nTODO\n.vscode"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 29.5302734375,
          "content": "## 1.36.2\n\n### Maintenance\n- Bump google.golang.org/protobuf from 1.35.1 to 1.36.1 (#810) [9a7609d]\n- Bump golang.org/x/net from 0.30.0 to 0.33.0 (#807) [b6cb028]\n- Bump github.com/onsi/ginkgo/v2 from 2.20.1 to 2.22.1 (#808) [5756529]\n- Bump nokogiri from 1.16.3 to 1.16.5 in /docs (#757) [dabc12e]\n\n## 1.36.1\n\n### Fixes\n- Fix https://github.com/onsi/gomega/issues/803 [1c6c112]\n- resolves onsi/gomega#696: make HaveField great on pointer receivers given only a non-addressable value [4feb9d7]\n\n## 1.36.0\n\n### Features\n- new: make collection-related matchers Go 1.23 iterator aware [4c964c6]\n\n### Maintenance\n- Replace min/max helpers with built-in min/max [ece6872]\n- Fix some typos in docs [8e924d7]\n\n## 1.35.1\n\n### Fixes\n- Export EnforceDefaultTimeoutsWhenUsingContexts and DisableDefaultTimeoutsWhenUsingContext [ca36da1]\n\n## 1.35.0\n\n### Features\n\n- You can now call `EnforceDefaultTimeoutsWhenUsingContexts()` to have `Eventually` honor the default timeout when passed a context.  (prior to this you had to expclility add a timeout) [e4c4265]\n- You can call `StopTrying(message).Successfully()` to abort a `Consistently` early without failure [eeca931]\n\n### Fixes\n\n- Stop memoizing the result of `HaveField` to avoid unexpected errors when used with async assertions. [3bdbc4e]\n\n### Maintenance\n\n- Bump all dependencies [a05a416]\n\n## 1.34.2\n\nRequire Go 1.22+\n\n### Maintenance\n- bump ginkgo as well [c59c6dc]\n- bump to go 1.22 - remove x/exp dependency [8158b99]\n\n## 1.34.1\n\n### Maintenance\n- Use slices from exp/slices to keep golang 1.20 compat [5e71dcd]\n\n## 1.34.0\n\n### Features\n- Add RoundTripper method to ghttp.Server [c549e0d]\n\n### Fixes\n- fix incorrect handling of nil slices in HaveExactElements (fixes #771) [878940c]\n- issue_765 - fixed bug in Hopcroft-Karp algorithm [ebadb67]\n\n### Maintenance\n- bump ginkgo [8af2ece]\n- Fix typo in docs [123a071]\n- Bump github.com/onsi/ginkgo/v2 from 2.17.2 to 2.17.3 (#756) [0e69083]\n- Bump google.golang.org/protobuf from 1.33.0 to 1.34.1 (#755) [2675796]\n- Bump golang.org/x/net from 0.24.0 to 0.25.0 (#754) [4160c0f]\n- Bump github-pages from 230 to 231 in /docs (#748) [892c303]\n\n## 1.33.1\n\n### Fixes\n- fix confusing eventually docs [3a66379]\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.17.1 to 2.17.2 [e9bc35a]\n\n## 1.33.0\n\n### Features\n\n`Receive` not accepts `Receive(<POINTER>, MATCHER>)`, allowing you to pick out a specific value on the channel that satisfies the provided matcher and is stored in the provided pointer.\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.15.0 to 2.17.1 (#745) [9999deb]\n- Bump github-pages from 229 to 230 in /docs (#735) [cb5ff21]\n- Bump golang.org/x/net from 0.20.0 to 0.23.0 (#746) [bac6596]\n\n## 1.32.0\n\n### Maintenance\n- Migrate github.com/golang/protobuf to google.golang.org/protobuf [436a197]\n  \n  This release drops the deprecated github.com/golang/protobuf and adopts google.golang.org/protobuf.  Care was taken to ensure the release is backwards compatible (thanks @jbduncan !).  Please open an issue if you run into one.\n\n- chore: test with Go 1.22 (#733) [32ef35e]\n- Bump golang.org/x/net from 0.19.0 to 0.20.0 (#717) [a0d0387]\n- Bump github-pages and jekyll-feed in /docs (#732) [b71e477]\n- docs: fix typo and broken anchor link to gstruct [f460154]\n- docs: fix HaveEach matcher signature [a2862e4]\n\n## 1.31.1\n\n### Fixes\n- Inverted arguments order of FailureMessage of BeComparableToMatcher [e0dd999]\n- Update test in case keeping msg is desired [ad1a367]\n\n### Maintenance\n- Show how to import the format sub package [24e958d]\n- tidy up go.sum [26661b8]\n- bump dependencies [bde8f7a]\n\n## 1.31.0\n\n### Features\n- Async assertions include context cancellation cause if present [121c37f]\n\n### Maintenance\n- Bump minimum go version [dee1e3c]\n- docs: fix typo in example usage \"occured\" -> \"occurred\" [49005fe]\n- Bump actions/setup-go from 4 to 5 (#714) [f1c8757]\n- Bump github/codeql-action from 2 to 3 (#715) [9836e76]\n- Bump github.com/onsi/ginkgo/v2 from 2.13.0 to 2.13.2 (#713) [54726f0]\n- Bump golang.org/x/net from 0.17.0 to 0.19.0 (#711) [df97ecc]\n- docs: fix `HaveExactElement` typo (#712) [a672c86]\n\n## 1.30.0\n\n### Features\n- BeTrueBecause and BeFalseBecause allow for better failure messages [4da4c7f]\n\n### Maintenance\n- Bump actions/checkout from 3 to 4 (#694) [6ca6e97]\n- doc: fix type on gleak go doc [f1b8343]\n\n## 1.29.0\n\n### Features\n- MatchError can now take an optional func(error) bool + description [2b39142]\n\n## 1.28.1\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.12.0 to 2.13.0 [635d196]\n- Bump github.com/google/go-cmp from 0.5.9 to 0.6.0 [14f8859]\n- Bump golang.org/x/net from 0.14.0 to 0.17.0 [d8a6508]\n- #703 doc(matchers): HaveEach() doc comment updated [2705bdb]\n- Minor typos (#699) [375648c]\n\n## 1.28.0\n\n### Features\n- Add VerifyHost handler to ghttp (#698) [0b03b36]\n\n### Fixes\n- Read Body for Newer Responses in HaveHTTPBodyMatcher (#686) [18d6673]\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.11.0 to 2.12.0 (#693) [55a33f3]\n- Typo in matchers.go (#691) [de68e8f]\n- Bump commonmarker from 0.23.9 to 0.23.10 in /docs (#690) [ab17f5e]\n- chore: update test matrix for Go 1.21 (#689) [5069017]\n- Bump golang.org/x/net from 0.12.0 to 0.14.0 (#688) [babe25f]\n\n## 1.27.10\n\n### Fixes\n- fix: go 1.21 adding goroutine ID to creator+location (#685) [bdc7803]\n\n## 1.27.9\n\n### Fixes\n- Prevent nil-dereference in format.Object for boxed nil error (#681) [3b31fc3]\n\n### Maintenance\n- Bump golang.org/x/net from 0.11.0 to 0.12.0 (#679) [360849b]\n- chore: use String() instead of fmt.Sprintf (#678) [86f3659]\n- Bump golang.org/x/net from 0.10.0 to 0.11.0 (#674) [642ead0]\n- chore: unnecessary use of fmt.Sprintf (#677) [ceb9ca6]\n- Bump github.com/onsi/ginkgo/v2 from 2.10.0 to 2.11.0 (#675) [a2087d8]\n- docs: fix ContainSubstring references (#673) [fc9a89f]\n- Bump github.com/onsi/ginkgo/v2 from 2.9.7 to 2.10.0 (#671) [9076019]\n\n## 1.27.8\n\n### Fixes\n- HaveExactElement should not call FailureMessage if a submatcher returned an error [096f392]\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.9.5 to 2.9.7 (#669) [8884bee]\n\n## 1.27.7\n\n### Fixes\n- fix: gcustom.MakeMatcher accepts nil as actual value (#666) [57054d5]\n\n### Maintenance\n- update gitignore [05c1bc6]\n- Bump github.com/onsi/ginkgo/v2 from 2.9.4 to 2.9.5 (#663) [7cadcf6]\n- Bump golang.org/x/net from 0.9.0 to 0.10.0 (#662) [b524839]\n- Bump github.com/onsi/ginkgo/v2 from 2.9.2 to 2.9.4 (#661) [5f44694]\n- Bump commonmarker from 0.23.8 to 0.23.9 in /docs (#657) [05dc99a]\n- Bump nokogiri from 1.14.1 to 1.14.3 in /docs (#658) [3a033d1]\n- Replace deprecated NewGomegaWithT with NewWithT (#659) [a19238f]\n- Bump golang.org/x/net from 0.8.0 to 0.9.0 (#656) [29ed041]\n- Bump actions/setup-go from 3 to 4 (#651) [11b2080]\n\n## 1.27.6\n\n### Fixes\n- Allow collections matchers to work correctly when expected has nil elements [60e7cf3]\n\n### Maintenance\n- updates MatchError godoc comment to also accept a Gomega matcher (#654) [67b869d]\n\n## 1.27.5\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.9.1 to 2.9.2 (#653) [a215021]\n- Bump github.com/go-task/slim-sprig (#652) [a26fed8]\n\n## 1.27.4\n\n### Fixes\n- improve error formatting and remove duplication of error message in Eventually/Consistently [854f075]\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.9.0 to 2.9.1 (#650) [ccebd9b]\n\n## 1.27.3\n\n### Fixes\n- format.Object now always includes err.Error() when passed an error [86d97ef]\n- Fix HaveExactElements to work inside ContainElement or other collection matchers (#648) [636757e]\n\n### Maintenance\n- Bump github.com/golang/protobuf from 1.5.2 to 1.5.3 (#649) [cc16689]\n- Bump github.com/onsi/ginkgo/v2 from 2.8.4 to 2.9.0 (#646) [e783366]\n\n## 1.27.2\n\n### Fixes\n- improve poll progress message when polling a consistently that has been passing [28a319b]\n\n### Maintenance\n- bump ginkgo\n- remove tools.go hack as Ginkgo 2.8.2 automatically pulls in the cli dependencies [81443b3]\n\n## 1.27.1\n\n### Maintenance\n\n- Bump golang.org/x/net from 0.6.0 to 0.7.0 (#640) [bc686cd]\n\n## 1.27.0\n\n### Features\n- Add HaveExactElements matcher (#634) [9d50783]\n- update Gomega docs to discuss GinkgoHelper() [be32774]\n\n### Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.8.0 to 2.8.1 (#639) [296a68b]\n- Bump golang.org/x/net from 0.5.0 to 0.6.0 (#638) [c2b098b]\n- Bump github-pages from 227 to 228 in /docs (#636) [a9069ab]\n- test: update matrix for Go 1.20 (#635) [6bd25c8]\n- Bump github.com/onsi/ginkgo/v2 from 2.7.0 to 2.8.0 (#631) [5445f8b]\n- Bump webrick from 1.7.0 to 1.8.1 in /docs (#630) [03e93bb]\n- codeql: add ruby language (#626) [63c7d21]\n- dependabot: add bundler package-ecosystem for docs (#625) [d92f963]\n\n## 1.26.0\n\n### Features\n- When a polled function returns an error, keep track of the actual and report on the matcher state of the last non-errored actual [21f3090]\n- improve eventually failure message output [c530fb3]\n\n### Fixes\n- fix several documentation spelling issues [e2eff1f]\n\n\n## 1.25.0\n\n### Features\n- add `MustPassRepeatedly(int)` to asyncAssertion (#619) [4509f72]\n- compare unwrapped errors using DeepEqual (#617) [aaeaa5d]\n\n### Maintenance\n- Bump golang.org/x/net from 0.4.0 to 0.5.0 (#614) [c7cfea4]\n- Bump github.com/onsi/ginkgo/v2 from 2.6.1 to 2.7.0 (#615) [71b8adb]\n- Docs: Fix typo \"MUltiple\" -> \"Multiple\" (#616) [9351dda]\n- clean up go.sum [cd1dc1d]\n\n## 1.24.2\n\n### Fixes\n- Correctly handle assertion failure panics for eventually/consistnetly \"g Gomega\"s in a goroutine [78f1660]\n- docs:Fix typo \"you an\" -> \"you can\" (#607) [3187c1f]\n- fixes issue #600 (#606) [808d192]\n\n### Maintenance\n- Bump golang.org/x/net from 0.2.0 to 0.4.0 (#611) [6ebc0bf]\n- Bump nokogiri from 1.13.9 to 1.13.10 in /docs (#612) [258cfc8]\n- Bump github.com/onsi/ginkgo/v2 from 2.5.0 to 2.5.1 (#609) [e6c3eb9]\n\n## 1.24.1\n\n### Fixes\n- maintain backward compatibility for Eventually and Consisntetly's signatures [4c7df5e]\n- fix small typo (#601) [ea0ebe6]\n\n### Maintenance\n- Bump golang.org/x/net from 0.1.0 to 0.2.0 (#603) [1ba8372]\n- Bump github.com/onsi/ginkgo/v2 from 2.4.0 to 2.5.0 (#602) [f9426cb]\n- fix label-filter in test.yml [d795db6]\n- stop running flakey tests and rely on external network dependencies in CI [7133290]\n\n## 1.24.0\n\n### Features\n\nIntroducing [gcustom](https://onsi.github.io/gomega/#gcustom-a-convenient-mechanism-for-buildling-custom-matchers) - a convenient mechanism for building custom matchers.\n\nThis is an RC release for `gcustom`.  The external API may be tweaked in response to feedback however it is expected to remain mostly stable.\n\n### Maintenance\n\n- Update BeComparableTo documentation [756eaa0]\n\n## 1.23.0\n\n### Features\n- Custom formatting on a per-type basis can be provided using `format.RegisterCustomFormatter()` -- see the docs [here](https://onsi.github.io/gomega/#adjusting-output)\n\n- Substantial improvement have been made to `StopTrying()`:\n  - Users can now use `StopTrying().Wrap(err)` to wrap errors and `StopTrying().Attach(description, object)` to attach arbitrary objects to the `StopTrying()` error\n  - `StopTrying()` is now always interpreted as a failure.  If you are an early adopter of `StopTrying()` you may need to change your code as the prior version would match against the returned value even if `StopTrying()` was returned.  Going forward the `StopTrying()` api should remain stable.\n  - `StopTrying()` and `StopTrying().Now()` can both be used in matchers - not just polled functions.\n\n- `TryAgainAfter(duration)` is used like `StopTrying()` but instructs `Eventually` and `Consistently` that the poll should be tried again after the specified duration.  This allows you to dynamically adjust the polling duration.\n\n- `ctx` can now be passed-in as the first argument to `Eventually` and `Consistently`.\n\n## Maintenance\n\n- Bump github.com/onsi/ginkgo/v2 from 2.3.0 to 2.3.1 (#597) [afed901]\n- Bump nokogiri from 1.13.8 to 1.13.9 in /docs (#599) [7c691b3]\n- Bump github.com/google/go-cmp from 0.5.8 to 0.5.9 (#587) [ff22665]\n\n## 1.22.1\n\n## Fixes\n- When passed a context and no explicit timeout, Eventually will only timeout when the context is cancelled [e5105cf]\n- Allow StopTrying() to be wrapped [bf3cba9]\n\n## Maintenance\n- bump to ginkgo v2.3.0 [c5d5c39]\n\n## 1.22.0\n\n### Features\n\nSeveral improvements have been made to `Eventually` and `Consistently` in this and the most recent releases:\n\n- Eventually and Consistently can take a context.Context [65c01bc]\n  This enables integration with Ginkgo 2.3.0's interruptible nodes and node timeouts.\n- Eventually and Consistently that are passed a SpecContext can provide reports when an interrupt occurs [0d063c9]\n- Eventually/Consistently will forward an attached context to functions that ask for one [e2091c5]\n- Eventually/Consistently supports passing arguments to functions via WithArguments() [a2dc7c3]\n- Eventually and Consistently can now be stopped early with StopTrying(message) and StopTrying(message).Now() [52976bb]\n\nThese improvements are all documented in [Gomega's docs](https://onsi.github.io/gomega/#making-asynchronous-assertions)\n\n## Fixes\n\n## Maintenance\n\n## 1.21.1\n\n### Features\n- Eventually and Consistently that are passed a SpecContext can provide reports when an interrupt occurs [0d063c9]\n\n## 1.21.0\n\n### Features\n- Eventually and Consistently can take a context.Context [65c01bc]\n  This enables integration with Ginkgo 2.3.0's interruptible nodes and node timeouts.\n- Introduces Eventually.Within.ProbeEvery with tests and documentation (#591) [f633800]\n- New BeKeyOf matcher with documentation and unit tests (#590) [fb586b3]\n    \n## Fixes\n- Cover the entire gmeasure suite with leak detection [8c54344]\n- Fix gmeasure leak [119d4ce]\n- Ignore new Ginkgo ProgressSignal goroutine in gleak [ba548e2]\n\n## Maintenance\n\n- Fixes crashes on newer Ruby 3 installations by upgrading github-pages gem dependency (#596) [12469a0]\n\n\n## 1.20.2\n\n## Fixes\n- label specs that rely on remote access; bump timeout on short-circuit test to make it less flaky [35eeadf]\n- gexec: allow more headroom for SIGABRT-related unit tests (#581) [5b78f40]\n- Enable reading from a closed gbytes.Buffer (#575) [061fd26]\n\n## Maintenance\n- Bump github.com/onsi/ginkgo/v2 from 2.1.5 to 2.1.6 (#583) [55d895b]\n- Bump github.com/onsi/ginkgo/v2 from 2.1.4 to 2.1.5 (#582) [346de7c]\n\n## 1.20.1\n\n## Fixes\n- fix false positive gleaks when using ginkgo -p (#577) [cb46517]\n- Fix typos in gomega_dsl.go (#569) [5f71ed2]\n- don't panic on Eventually(nil), fixing #555 (#567) [9d1186f]\n- vet optional description args in assertions, fixing #560 (#566) [8e37808]\n\n## Maintenance\n- test: add new Go 1.19 to test matrix (#571) [40d7efe]\n- Bump tzinfo from 1.2.9 to 1.2.10 in /docs (#564) [5f26371]\n\n## 1.20.0\n\n## Features\n- New [`gleak`](https://onsi.github.io/gomega/#codegleakcode-finding-leaked-goroutines) experimental goroutine leak detection package! (#538) [85ba7bc]\n- New `BeComparableTo` matcher(#546) that uses `gocmp` to make comparisons [e77ea75]\n- New `HaveExistingField` matcher (#553) [fd130e1]\n- Document how to wrap Gomega (#539) [56714a4]\n\n## Fixes\n- Support pointer receivers in HaveField; fixes #543 (#544) [8dab36e]\n\n## Maintenance\n- Bump various dependencies:\n    - Upgrade to yaml.v3 (#556) [f5a83b1]\n    - Bump github/codeql-action from 1 to 2 (#549) [52f5adf]\n    - Bump github.com/google/go-cmp from 0.5.7 to 0.5.8 (#551) [5f3942d]\n    - Bump nokogiri from 1.13.4 to 1.13.6 in /docs (#554) [eb4b4c2]\n    - Use latest ginkgo (#535) [1c29028]\n    - Bump nokogiri from 1.13.3 to 1.13.4 in /docs (#541) [1ce84d5]\n    - Bump actions/setup-go from 2 to 3 (#540) [755485e]\n    - Bump nokogiri from 1.12.5 to 1.13.3 in /docs (#522) [4fbb0dc]\n    - Bump actions/checkout from 2 to 3 (#526) [ac49202]\n\n## 1.19.0\n\n## Features\n- New [`HaveEach`](https://onsi.github.io/gomega/#haveeachelement-interface) matcher to ensure that each and every element in an `array`, `slice`, or `map` satisfies the passed in matcher. (#523) [9fc2ae2] (#524) [c8ba582]\n- Users can now wrap the `Gomega` interface to implement custom behavior on each assertion. (#521) [1f2e714]\n- [`ContainElement`](https://onsi.github.io/gomega/#containelementelement-interface) now accepts an additional pointer argument.  Elements that satisfy the matcher are stored in the pointer enabling developers to easily add subsequent, more detailed, assertions against the matching element. (#527) [1a4e27f]\n\n## Fixes\n- update RELEASING instructions to match ginkgo [0917cde]\n- Bump github.com/onsi/ginkgo/v2 from 2.0.0 to 2.1.3 (#519) [49ab4b0]\n- Fix CVE-2021-38561 (#534) [f1b4456]\n- Fix max number of samples in experiments on non-64-bit systems. (#528) [1c84497]\n- Remove dependency on ginkgo v1.16.4 (#530) [4dea8d5]\n- Fix for Go 1.18 (#532) [56d2a29]\n- Document precedence of timeouts (#533) [b607941]\n\n## 1.18.1\n\n## Fixes\n- Add pointer support to HaveField matcher (#495) [79e41a3]\n\n## 1.18.0\n\n## Features\n- Docs now live on the master branch in the docs folder which will make for easier PRs.  The docs also use Ginkgo 2.0's new docs html/css/js. [2570272]\n- New HaveValue matcher can handle actuals that are either values (in which case they are passed on unscathed) or pointers (in which case they are indirected).  [Docs here.](https://onsi.github.io/gomega/#working-with-values) (#485) [bdc087c]\n- Gmeasure has been declared GA [360db9d]\n\n## Fixes\n- Gomega now uses ioutil for Go 1.15 and lower (#492) - official support is only for the most recent two major versions of Go but this will unblock users who need to stay on older unsupported versions of Go. [c29c1c0]\n\n## Maintenance\n- Remove Travis workflow (#491) [72e6040]\n- Upgrade to Ginkgo 2.0.0 GA [f383637]\n- chore: fix description of HaveField matcher (#487) [2b4b2c0]\n- use tools.go to ensure Ginkgo cli dependencies are included [f58a52b]\n- remove dockerfile and simplify github actions to match ginkgo's actions [3f8160d]\n\n## 1.17.0\n\n### Features\n- Add HaveField matcher [3a26311]\n- add Error() assertions on the final error value of multi-return values (#480) [2f96943]\n- separate out offsets and timeouts (#478) [18a4723]\n- fix transformation error reporting (#479) [e001fab]\n- allow transform functions to report errors (#472) [bf93408]\n\n### Fixes\nStop using deprecated ioutil package (#467) [07f405d]\n\n## 1.16.0\n\n### Features\n- feat: HaveHTTPStatus multiple expected values (#465) [aa69f1b]\n- feat: HaveHTTPHeaderWithValue() matcher (#463) [dd83a96]\n- feat: HaveHTTPBody matcher (#462) [504e1f2]\n- feat: formatter for HTTP responses (#461) [e5b3157]\n\n## 1.15.0\n\n### Fixes\nThe previous version (1.14.0) introduced a change to allow `Eventually` and `Consistently` to support functions that make assertions.  This was accomplished by overriding the global fail handler when running the callbacks passed to `Eventually/Consistently` in order to capture any resulting errors.  Issue #457 uncovered a flaw with this approach: when multiple `Eventually`s are running concurrently they race when overriding the singleton global fail handler.\n\n1.15.0 resolves this by requiring users who want to make assertions in `Eventually/Consistently` call backs to explicitly pass in a function that takes a `Gomega` as an argument.  The passed-in `Gomega` instance can be used to make assertions.  Any failures will cause `Eventually` to retry the callback.  This cleaner interface avoids the issue of swapping out globals but comes at the cost of changing the contract introduced in v1.14.0.  As such 1.15.0 introduces a breaking change with respect to 1.14.0 - however we expect that adoption of this feature in 1.14.0 remains limited.\n\nIn addition, 1.15.0 cleans up some of Gomega's internals.  Most users shouldn't notice any differences stemming from the refactoring that was made.\n\n## 1.14.0\n\n### Features\n- gmeasure.SamplingConfig now suppers a MinSamplingInterval [e94dbca]\n- Eventually and Consistently support functions that make assertions [2f04e6e]\n    - Eventually and Consistently now allow their passed-in functions to make assertions.\n    These assertions must pass or the function is considered to have failed and is retried.\n    - Eventually and Consistently can now take functions with no return values.  These implicitly return nil\n    if they contain no failed assertion.  Otherwise they return an error wrapping the first assertion failure.  This allows\n    these functions to be used with the Succeed() matcher.\n    - Introduce InterceptGomegaFailure - an analogue to InterceptGomegaFailures - that captures the first assertion failure\n    and halts execution in its passed-in callback.\n\n### Fixes\n- Call Verify GHTTPWithGomega receiver funcs (#454) [496e6fd]\n- Build a binary with an expected name (#446) [7356360]\n\n## 1.13.0\n\n### Features\n- gmeasure provides BETA support for benchmarking (#447) [8f2dfbf]\n- Set consistently and eventually defaults on init (#443) [12eb778]\n\n## 1.12.0\n\n### Features\n- Add Satisfy() matcher (#437) [c548f31]\n- tweak truncation message [3360b8c]\n- Add format.GomegaStringer (#427) [cc80b6f]\n- Add Clear() method to gbytes.Buffer [c3c0920]\n\n### Fixes\n- Fix error message in BeNumericallyMatcher (#432) [09c074a]\n- Bump github.com/onsi/ginkgo from 1.12.1 to 1.16.2 (#442) [e5f6ea0]\n- Bump github.com/golang/protobuf from 1.4.3 to 1.5.2 (#431) [adae3bf]\n- Bump golang.org/x/net (#441) [3275b35]\n\n## 1.11.0\n\n### Features\n- feature: add index to gstruct element func (#419) [334e00d]\n- feat(gexec) Add CompileTest functions. Close #410 (#411) [47c613f]\n\n### Fixes\n- Check more carefully for nils in WithTransform (#423) [3c60a15]\n- fix: typo in Makefile [b82522a]\n- Allow WithTransform function to accept a nil value (#422) [b75d2f2]\n- fix: print value type for interface{} containers (#409) [f08e2dc]\n- fix(BeElementOf): consistently flatten expected values [1fa9468]\n\n## 1.10.5\n\n### Fixes\n- fix: collections matchers should display type of expectation (#408) [6b4eb5a]\n- fix(ContainElements): consistently flatten expected values [073b880]\n- fix(ConsistOf): consistently flatten expected values [7266efe]\n\n## 1.10.4\n\n### Fixes\n- update golang net library to more recent version without vulnerability (#406) [817a8b9]\n- Correct spelling: alloted -> allotted (#403) [0bae715]\n- fix a panic in MessageWithDiff with long message (#402) [ea06b9b]\n\n## 1.10.3\n\n### Fixes\n- updates golang/x/net to fix vulnerability detected by snyk (#394) [c479356]\n\n## 1.10.2\n\n### Fixes\n- Add ExpectWithOffset, EventuallyWithOffset and ConsistentlyWithOffset to WithT (#391) [990941a]\n\n## 1.10.1\n\n### Fixes\n- Update dependencies (#389) [9f5eecd]\n\n## 1.10.0\n\n### Features\n- Add HaveHTTPStatusMatcher (#378) [f335c94]\n- Changed matcher for content-type in VerifyJSONRepresenting (#377) [6024f5b]\n- Make ghttp usable with x-unit style tests (#376) [c0be499]\n- Implement PanicWith matcher (#381) [f8032b4]\n\n## 1.9.0\n\n### Features\n- Add ContainElements matcher (#370) [2f57380]\n- Output missing and extra elements in ConsistOf failure message [a31eda7]\n- Document method LargestMatching [7c5a280]\n\n## 1.8.1\n\n### Fixes\n- Fix unexpected MatchError() behaviour (#375) [8ae7b2f]\n\n## 1.8.0\n\n### Features\n- Allow optional description to be lazily evaluated function (#364) [bf64010]\n- Support wrapped errors (#359) [0a981cb]\n\n## 1.7.1\n\n### Fixes\n- Bump go-yaml version to cover fixed ddos heuristic (#362) [95e431e]\n\n## 1.7.0\n\n### Features\n- export format property variables (#347) [642e5ba]\n\n### Fixes\n- minor fix in the documentation of ExpectWithOffset (#358) [beea727]\n\n## 1.6.0\n\n### Features\n\n- Display special chars on error [41e1b26]\n- Add BeElementOf matcher [6a48b48]\n\n### Fixes\n\n- Remove duplication in XML matcher tests [cc1a6cb]\n- Remove unnecessary conversions (#357) [7bf756a]\n- Fixed import order (#353) [2e3b965]\n- Added missing error handling in test (#355) [c98d3eb]\n- Simplify code (#356) [0001ed9]\n- Simplify code (#354) [0d9100e]\n- Fixed typos (#352) [3f647c4]\n- Add failure message tests to BeElementOf matcher [efe19c3]\n- Update go-testcov untested sections [37ee382]\n- Mark all uncovered files so go-testcov ./... works [53b150e]\n- Reenable gotip in travis [5c249dc]\n- Fix the typo of comment (#345) [f0e010e]\n- Optimize contain_element_matcher [abeb93d]\n\n\n## 1.5.0\n\n### Features\n\n- Added MatchKeys matchers [8b909fc]\n\n### Fixes and Minor Improvements\n\n- Add type aliases to remove stuttering [03b0461]\n- Don't run session_test.go on windows (#324) [5533ce8]\n\n## 1.4.3\n\n### Fixes:\n\n- ensure file name and line numbers are correctly reported for XUnit [6fff58f]\n- Fixed matcher for content-type (#305) [69d9b43]\n\n## 1.4.2\n\n### Fixes:\n\n- Add go.mod and go.sum files to define the gomega go module [f3de367, a085d30]\n- Work around go vet issue with Go v1.11 (#300) [40dd6ad]\n- Better output when using with go XUnit-style tests, fixes #255 (#297) [29a4b97]\n- Fix MatchJSON fail to parse json.RawMessage (#298) [ae19f1b]\n- show threshold in failure message of BeNumericallyMatcher (#293) [4bbecc8]\n\n## 1.4.1\n\n### Fixes:\n\n- Update documentation formatting and examples (#289) [9be8410]\n- allow 'Receive' matcher to be used with concrete types (#286) [41673fd]\n- Fix data race in ghttp server (#283) [7ac6b01]\n- Travis badge should only show master [cc102ab]\n\n## 1.4.0\n\n### Features\n- Make string pretty diff user configurable (#273) [eb112ce, 649b44d]\n\n### Fixes\n- Use httputil.DumpRequest to pretty-print unhandled requests (#278) [a4ff0fc, b7d1a52]\n- fix typo floa32 > float32 (#272) [041ae3b, 6e33911]\n- Fix link to documentation on adding your own matchers (#270) [bb2c830, fcebc62]\n- Use setters and getters to avoid race condition (#262) [13057c3, a9c79f1]\n- Avoid sending a signal if the process is not alive (#259) [b8043e5, 4fc1762]\n- Improve message from AssignableToTypeOf when expected value is nil (#281) [9c1fb20]\n\n## 1.3.0\n\nImprovements:\n\n- The `Equal` matcher matches byte slices more performantly.\n- Improved how `MatchError` matches error strings.\n- `MatchXML` ignores the order of xml node attributes.\n- Improve support for XUnit style golang tests. ([#254](https://github.com/onsi/gomega/issues/254))\n\nBug Fixes:\n\n- Diff generation now handles multi-byte sequences correctly.\n- Multiple goroutines can now call `gexec.Build` concurrently.\n\n## 1.2.0\n\nImprovements:\n\n- Added `BeSent` which attempts to send a value down a channel and fails if the attempt blocks.  Can be paired with `Eventually` to safely send a value down a channel with a timeout.\n- `Ω`, `Expect`, `Eventually`, and `Consistently` now immediately `panic` if there is no registered fail handler.  This is always a mistake that can hide failing tests.\n- `Receive()` no longer errors when passed a closed channel, it's perfectly fine to attempt to read from a closed channel so Ω(c).Should(Receive()) always fails and Ω(c).ShouldNot(Receive()) always passes with a closed channel.\n- Added `HavePrefix` and `HaveSuffix` matchers.\n- `ghttp` can now handle concurrent requests.\n- Added `Succeed` which allows one to write `Ω(MyFunction()).Should(Succeed())`.\n- Improved `ghttp`'s behavior around failing assertions and panics:\n    - If a registered handler makes a failing assertion `ghttp` will return `500`.\n    - If a registered handler panics, `ghttp` will return `500` *and* fail the test.  This is new behavior that may cause existing code to break.  This code is almost certainly incorrect and creating a false positive.\n- `ghttp` servers can take an `io.Writer`.  `ghttp` will write a line to the writer when each request arrives.\n- Added `WithTransform` matcher to allow munging input data before feeding into the relevant matcher\n- Added boolean `And`, `Or`, and `Not` matchers to allow creating composite matchers\n- Added `gbytes.TimeoutCloser`, `gbytes.TimeoutReader`, and `gbytes.TimeoutWriter` - these are convenience wrappers that timeout if the underlying Closer/Reader/Writer does not return within the allotted time.\n- Added `gbytes.BufferReader` - this constructs a `gbytes.Buffer` that asynchronously reads the passed-in `io.Reader` into its buffer.\n\nBug Fixes:\n- gexec: `session.Wait` now uses `EventuallyWithOffset` to get the right line number in the failure.\n- `ContainElement` no longer bails if a passed-in matcher errors.\n\n## 1.0 (8/2/2014)\n\nNo changes. Dropping \"beta\" from the version number.\n\n## 1.0.0-beta (7/8/2014)\nBreaking Changes:\n\n- Changed OmegaMatcher interface.  Instead of having `Match` return failure messages, two new methods `FailureMessage` and `NegatedFailureMessage` are called instead.\n- Moved and renamed OmegaFailHandler to types.GomegaFailHandler and OmegaMatcher to types.GomegaMatcher.  Any references to OmegaMatcher in any custom matchers will need to be changed to point to types.GomegaMatcher\n\nNew Test-Support Features:\n\n- `ghttp`: supports testing http clients\n    - Provides a flexible fake http server\n    - Provides a collection of chainable http handlers that perform assertions.\n- `gbytes`: supports making ordered assertions against streams of data\n    - Provides a `gbytes.Buffer`\n    - Provides a `Say` matcher to perform ordered assertions against output data\n- `gexec`: supports testing external processes\n    - Provides support for building Go binaries\n    - Wraps and starts `exec.Cmd` commands\n    - Makes it easy to assert against stdout and stderr\n    - Makes it easy to send signals and wait for processes to exit\n    - Provides an `Exit` matcher to assert against exit code.\n\nDSL Changes:\n\n- `Eventually` and `Consistently` can accept `time.Duration` interval and polling inputs.\n- The default timeouts for `Eventually` and `Consistently` are now configurable.\n\nNew Matchers:\n\n- `ConsistOf`: order-independent assertion against the elements of an array/slice or keys of a map.\n- `BeTemporally`: like `BeNumerically` but for `time.Time`\n- `HaveKeyWithValue`: asserts a map has a given key with the given value.\n\nUpdated Matchers:\n\n- `Receive` matcher can take a matcher as an argument and passes only if the channel under test receives an object that satisfies the passed-in matcher.\n- Matchers that implement `MatchMayChangeInTheFuture(actual interface{}) bool` can inform `Eventually` and/or `Consistently` when a match has no chance of changing status in the future.  For example, `Receive` returns `false` when a channel is closed.\n\nMisc:\n\n- Start using semantic versioning\n- Start maintaining changelog\n\nMajor refactor:\n\n- Pull out Gomega's internal to `internal`\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.9052734375,
          "content": "# Contributing to Gomega\n\nYour contributions to Gomega are essential for its long-term maintenance and improvement.  To make a contribution:\n\n- Please **open an issue first** - describe what problem you are trying to solve and give the community a forum for input and feedback ahead of investing time in writing code!\n- Ensure adequate test coverage:\n    - Make sure to add appropriate unit tests\n    - Please run all tests locally (`ginkgo -r -p`) and make sure they go green before submitting the PR\n    - Please run following linter locally `go vet ./...` and make sure output does not contain any warnings\n- Update the documentation.  In addition to standard `godoc` comments Gomega has extensive documentation on the `gh-pages` branch.  If relevant, please submit a docs PR to that branch alongside your code PR.\n\nIf you're a committer, check out RELEASING.md to learn how to cut a release.\n\nThanks for supporting Gomega!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "Copyright (c) 2013-2014 Onsi Fakhouri\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.9501953125,
          "content": "![Gomega: Ginkgo's Preferred Matcher Library](http://onsi.github.io/gomega/images/gomega.png)\n\n[![test](https://github.com/onsi/gomega/actions/workflows/test.yml/badge.svg)](https://github.com/onsi/gomega/actions/workflows/test.yml)\n\nJump straight to the [docs](http://onsi.github.io/gomega/) to learn about Gomega, including a list of [all available matchers](http://onsi.github.io/gomega/#provided-matchers).\n\nIf you have a question, comment, bug report, feature request, etc. please open a GitHub issue.\n\n## [Ginkgo](http://github.com/onsi/ginkgo): a BDD Testing Framework for Golang\n\nLearn more about Ginkgo [here](http://onsi.github.io/ginkgo/)\n\n## Community Matchers\n\nA collection of community matchers is available on the [wiki](https://github.com/onsi/gomega/wiki).\n\n## License\n\nGomega is MIT-Licensed\n\nThe `ConsistOf` matcher uses [goraph](https://github.com/amitkgupta/goraph) which is embedded in the source to simplify distribution.  goraph has an MIT license.\n"
        },
        {
          "name": "RELEASING.md",
          "type": "blob",
          "size": 0.8359375,
          "content": "A Gomega release is a tagged sha and a GitHub release.  To cut a release:\n\n1. Ensure CHANGELOG.md is up to date.\n  - Use \n    ```bash\n    LAST_VERSION=$(git tag --sort=version:refname | tail -n1)\n    CHANGES=$(git log --pretty=format:'- %s [%h]' HEAD...$LAST_VERSION)\n    echo -e \"## NEXT\\n\\n$CHANGES\\n\\n### Features\\n\\n### Fixes\\n\\n### Maintenance\\n\\n$(cat CHANGELOG.md)\" > CHANGELOG.md\n    ```\n   to update the changelog\n  - Categorize the changes into\n    - Breaking Changes (requires a major version)\n    - New Features (minor version)\n    - Fixes (fix version)\n    - Maintenance (which in general should not be mentioned in `CHANGELOG.md` as they have no user impact)\n1. Update GOMEGA_VERSION in `gomega_dsl.go`\n1. Commit, push, and release:\n  ```\n  git commit -m \"vM.m.p\"\n  git push\n  gh release create \"vM.m.p\"\n  git fetch --tags origin master\n  ```"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "format",
          "type": "tree",
          "content": null
        },
        {
          "name": "gbytes",
          "type": "tree",
          "content": null
        },
        {
          "name": "gcustom",
          "type": "tree",
          "content": null
        },
        {
          "name": "gexec",
          "type": "tree",
          "content": null
        },
        {
          "name": "ghttp",
          "type": "tree",
          "content": null
        },
        {
          "name": "gleak",
          "type": "tree",
          "content": null
        },
        {
          "name": "gmeasure",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5166015625,
          "content": "module github.com/onsi/gomega\n\ngo 1.22.0\n\ntoolchain go1.22.10\n\nrequire (\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/onsi/ginkgo/v2 v2.22.2\n\tgolang.org/x/net v0.33.0\n\tgoogle.golang.org/protobuf v1.36.1\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-task/slim-sprig/v3 v3.0.0 // indirect\n\tgithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.28.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.5185546875,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad h1:a6HEuzUHeKH6hwfN/ZoQgRgVIWFJljSWa/zetS2WTvg=\ngithub.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/onsi/ginkgo/v2 v2.22.2 h1:/3X8Panh8/WwhU/3Ssa6rCKqPLuAkVY2I0RoyDLySlU=\ngithub.com/onsi/ginkgo/v2 v2.22.2/go.mod h1:oeMosUL+8LtarXBHu/c0bx2D/K9zyQ6uX3cTyztHwsk=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\ngoogle.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=\ngoogle.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gomega_dsl.go",
          "type": "blob",
          "size": 26.4765625,
          "content": "/*\nGomega is the Ginkgo BDD-style testing framework's preferred matcher library.\n\nThe godoc documentation describes Gomega's API.  More comprehensive documentation (with examples!) is available at http://onsi.github.io/gomega/\n\nGomega on Github: http://github.com/onsi/gomega\n\nLearn more about Ginkgo online: http://onsi.github.io/ginkgo\n\nGinkgo on Github: http://github.com/onsi/ginkgo\n\nGomega is MIT-Licensed\n*/\npackage gomega\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/onsi/gomega/internal\"\n\t\"github.com/onsi/gomega/types\"\n)\n\nconst GOMEGA_VERSION = \"1.36.2\"\n\nconst nilGomegaPanic = `You are trying to make an assertion, but haven't registered Gomega's fail handler.\nIf you're using Ginkgo then you probably forgot to put your assertion in an It().\nAlternatively, you may have forgotten to register a fail handler with RegisterFailHandler() or RegisterTestingT().\nDepending on your vendoring solution you may be inadvertently importing gomega and subpackages (e.g. ghhtp, gexec,...) from different locations.\n`\n\n// Gomega describes the essential Gomega DSL. This interface allows libraries\n// to abstract between the standard package-level function implementations\n// and alternatives like *WithT.\n//\n// The types in the top-level DSL have gotten a bit messy due to earlier deprecations that avoid stuttering\n// and due to an accidental use of a concrete type (*WithT) in an earlier release.\n//\n// As of 1.15 both the WithT and Ginkgo variants of Gomega are implemented by the same underlying object\n// however one (the Ginkgo variant) is exported as an interface (types.Gomega) whereas the other (the withT variant)\n// is shared as a concrete type (*WithT, which is aliased to *internal.Gomega).  1.15 did not clean this mess up to ensure\n// that declarations of *WithT in existing code are not broken by the upgrade to 1.15.\ntype Gomega = types.Gomega\n\n// DefaultGomega supplies the standard package-level implementation\nvar Default = Gomega(internal.NewGomega(internal.FetchDefaultDurationBundle()))\n\n// NewGomega returns an instance of Gomega wired into the passed-in fail handler.\n// You generally don't need to use this when using Ginkgo - RegisterFailHandler will wire up the global gomega\n// However creating a NewGomega with a custom fail handler can be useful in contexts where you want to use Gomega's\n// rich ecosystem of matchers without causing a test to fail.  For example, to aggregate a series of potential failures\n// or for use in a non-test setting.\nfunc NewGomega(fail types.GomegaFailHandler) Gomega {\n\treturn internal.NewGomega(internalGomega(Default).DurationBundle).ConfigureWithFailHandler(fail)\n}\n\n// WithT wraps a *testing.T and provides `Expect`, `Eventually`, and `Consistently` methods.  This allows you to leverage\n// Gomega's rich ecosystem of matchers in standard `testing` test suites.\n//\n// Use `NewWithT` to instantiate a `WithT`\n//\n// As of 1.15 both the WithT and Ginkgo variants of Gomega are implemented by the same underlying object\n// however one (the Ginkgo variant) is exported as an interface (types.Gomega) whereas the other (the withT variant)\n// is shared as a concrete type (*WithT, which is aliased to *internal.Gomega).  1.15 did not clean this mess up to ensure\n// that declarations of *WithT in existing code are not broken by the upgrade to 1.15.\ntype WithT = internal.Gomega\n\n// GomegaWithT is deprecated in favor of gomega.WithT, which does not stutter.\ntype GomegaWithT = WithT\n\n// inner is an interface that allows users to provide a wrapper around Default.  The wrapper\n// must implement the inner interface and return either the original Default or the result of\n// a call to NewGomega().\ntype inner interface {\n\tInner() Gomega\n}\n\nfunc internalGomega(g Gomega) *internal.Gomega {\n\tif v, ok := g.(inner); ok {\n\t\treturn v.Inner().(*internal.Gomega)\n\t}\n\treturn g.(*internal.Gomega)\n}\n\n// NewWithT takes a *testing.T and returns a `gomega.WithT` allowing you to use `Expect`, `Eventually`, and `Consistently` along with\n// Gomega's rich ecosystem of matchers in standard `testing` test suits.\n//\n//\tfunc TestFarmHasCow(t *testing.T) {\n//\t    g := gomega.NewWithT(t)\n//\n//\t    f := farm.New([]string{\"Cow\", \"Horse\"})\n//\t    g.Expect(f.HasCow()).To(BeTrue(), \"Farm should have cow\")\n//\t }\nfunc NewWithT(t types.GomegaTestingT) *WithT {\n\treturn internal.NewGomega(internalGomega(Default).DurationBundle).ConfigureWithT(t)\n}\n\n// NewGomegaWithT is deprecated in favor of gomega.NewWithT, which does not stutter.\nvar NewGomegaWithT = NewWithT\n\n// RegisterFailHandler connects Ginkgo to Gomega. When a matcher fails\n// the fail handler passed into RegisterFailHandler is called.\nfunc RegisterFailHandler(fail types.GomegaFailHandler) {\n\tinternalGomega(Default).ConfigureWithFailHandler(fail)\n}\n\n// RegisterFailHandlerWithT is deprecated and will be removed in a future release.\n// users should use RegisterFailHandler, or RegisterTestingT\nfunc RegisterFailHandlerWithT(_ types.GomegaTestingT, fail types.GomegaFailHandler) {\n\tfmt.Println(\"RegisterFailHandlerWithT is deprecated.  Please use RegisterFailHandler or RegisterTestingT instead.\")\n\tinternalGomega(Default).ConfigureWithFailHandler(fail)\n}\n\n// RegisterTestingT connects Gomega to Golang's XUnit style\n// Testing.T tests.  It is now deprecated and you should use NewWithT() instead to get a fresh instance of Gomega for each test.\nfunc RegisterTestingT(t types.GomegaTestingT) {\n\tinternalGomega(Default).ConfigureWithT(t)\n}\n\n// InterceptGomegaFailures runs a given callback and returns an array of\n// failure messages generated by any Gomega assertions within the callback.\n// Execution continues after the first failure allowing users to collect all failures\n// in the callback.\n//\n// This is most useful when testing custom matchers, but can also be used to check\n// on a value using a Gomega assertion without causing a test failure.\nfunc InterceptGomegaFailures(f func()) []string {\n\toriginalHandler := internalGomega(Default).Fail\n\tfailures := []string{}\n\tinternalGomega(Default).Fail = func(message string, callerSkip ...int) {\n\t\tfailures = append(failures, message)\n\t}\n\tdefer func() {\n\t\tinternalGomega(Default).Fail = originalHandler\n\t}()\n\tf()\n\treturn failures\n}\n\n// InterceptGomegaFailure runs a given callback and returns the first\n// failure message generated by any Gomega assertions within the callback, wrapped in an error.\n//\n// The callback ceases execution as soon as the first failed assertion occurs, however Gomega\n// does not register a failure with the FailHandler registered via RegisterFailHandler - it is up\n// to the user to decide what to do with the returned error\nfunc InterceptGomegaFailure(f func()) (err error) {\n\toriginalHandler := internalGomega(Default).Fail\n\tinternalGomega(Default).Fail = func(message string, callerSkip ...int) {\n\t\terr = errors.New(message)\n\t\tpanic(\"stop execution\")\n\t}\n\n\tdefer func() {\n\t\tinternalGomega(Default).Fail = originalHandler\n\t\tif e := recover(); e != nil {\n\t\t\tif err == nil {\n\t\t\t\tpanic(e)\n\t\t\t}\n\t\t}\n\t}()\n\n\tf()\n\treturn err\n}\n\nfunc ensureDefaultGomegaIsConfigured() {\n\tif !internalGomega(Default).IsConfigured() {\n\t\tpanic(nilGomegaPanic)\n\t}\n}\n\n// Ω wraps an actual value allowing assertions to be made on it:\n//\n//\tΩ(\"foo\").Should(Equal(\"foo\"))\n//\n// If Ω is passed more than one argument it will pass the *first* argument to the matcher.\n// All subsequent arguments will be required to be nil/zero.\n//\n// This is convenient if you want to make an assertion on a method/function that returns\n// a value and an error - a common patter in Go.\n//\n// For example, given a function with signature:\n//\n//\tfunc MyAmazingThing() (int, error)\n//\n// Then:\n//\n//\tΩ(MyAmazingThing()).Should(Equal(3))\n//\n// Will succeed only if `MyAmazingThing()` returns `(3, nil)`\n//\n// Ω and Expect are identical\nfunc Ω(actual interface{}, extra ...interface{}) Assertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.Ω(actual, extra...)\n}\n\n// Expect wraps an actual value allowing assertions to be made on it:\n//\n//\tExpect(\"foo\").To(Equal(\"foo\"))\n//\n// If Expect is passed more than one argument it will pass the *first* argument to the matcher.\n// All subsequent arguments will be required to be nil/zero.\n//\n// This is convenient if you want to make an assertion on a method/function that returns\n// a value and an error - a common pattern in Go.\n//\n// For example, given a function with signature:\n//\n//\tfunc MyAmazingThing() (int, error)\n//\n// Then:\n//\n//\tExpect(MyAmazingThing()).Should(Equal(3))\n//\n// Will succeed only if `MyAmazingThing()` returns `(3, nil)`\n//\n// Expect and Ω are identical\nfunc Expect(actual interface{}, extra ...interface{}) Assertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.Expect(actual, extra...)\n}\n\n// ExpectWithOffset wraps an actual value allowing assertions to be made on it:\n//\n//\tExpectWithOffset(1, \"foo\").To(Equal(\"foo\"))\n//\n// Unlike `Expect` and `Ω`, `ExpectWithOffset` takes an additional integer argument\n// that is used to modify the call-stack offset when computing line numbers. It is\n// the same as `Expect(...).WithOffset`.\n//\n// This is most useful in helper functions that make assertions.  If you want Gomega's\n// error message to refer to the calling line in the test (as opposed to the line in the helper function)\n// set the first argument of `ExpectWithOffset` appropriately.\nfunc ExpectWithOffset(offset int, actual interface{}, extra ...interface{}) Assertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.ExpectWithOffset(offset, actual, extra...)\n}\n\n/*\nEventually enables making assertions on asynchronous behavior.\n\nEventually checks that an assertion *eventually* passes.  Eventually blocks when called and attempts an assertion periodically until it passes or a timeout occurs.  Both the timeout and polling interval are configurable as optional arguments.\nThe first optional argument is the timeout (which defaults to 1s), the second is the polling interval (which defaults to 10ms).  Both intervals can be specified as time.Duration, parsable duration strings or floats/integers (in which case they are interpreted as seconds).  In addition an optional context.Context can be passed in - Eventually will keep trying until either the timeout expires or the context is cancelled, whichever comes first.\n\nEventually works with any Gomega compatible matcher and supports making assertions against three categories of actual value:\n\n**Category 1: Making Eventually assertions on values**\n\nThere are several examples of values that can change over time.  These can be passed in to Eventually and will be passed to the matcher repeatedly until a match occurs.  For example:\n\n\tc := make(chan bool)\n\tgo DoStuff(c)\n\tEventually(c, \"50ms\").Should(BeClosed())\n\nwill poll the channel repeatedly until it is closed.  In this example `Eventually` will block until either the specified timeout of 50ms has elapsed or the channel is closed, whichever comes first.\n\nSeveral Gomega libraries allow you to use Eventually in this way.  For example, the gomega/gexec package allows you to block until a *gexec.Session exits successfully via:\n\n\tEventually(session).Should(gexec.Exit(0))\n\nAnd the gomega/gbytes package allows you to monitor a streaming *gbytes.Buffer until a given string is seen:\n\n\tEventually(buffer).Should(gbytes.Say(\"hello there\"))\n\nIn these examples, both `session` and `buffer` are designed to be thread-safe when polled by the `Exit` and `Say` matchers.  This is not true in general of most raw values, so while it is tempting to do something like:\n\n\t// THIS IS NOT THREAD-SAFE\n\tvar s *string\n\tgo mutateStringEventually(s)\n\tEventually(s).Should(Equal(\"I've changed\"))\n\nthis will trigger Go's race detector as the goroutine polling via Eventually will race over the value of s with the goroutine mutating the string.  For cases like this you can use channels or introduce your own locking around s by passing Eventually a function.\n\n**Category 2: Make Eventually assertions on functions**\n\nEventually can be passed functions that **return at least one value**.  When configured this way, Eventually will poll the function repeatedly and pass the first returned value to the matcher.\n\nFor example:\n\n\t   Eventually(func() int {\n\t   \treturn client.FetchCount()\n\t   }).Should(BeNumerically(\">=\", 17))\n\n\twill repeatedly poll client.FetchCount until the BeNumerically matcher is satisfied.  (Note that this example could have been written as Eventually(client.FetchCount).Should(BeNumerically(\">=\", 17)))\n\nIf multiple values are returned by the function, Eventually will pass the first value to the matcher and require that all others are zero-valued.  This allows you to pass Eventually a function that returns a value and an error - a common pattern in Go.\n\nFor example, consider a method that returns a value and an error:\n\n\tfunc FetchFromDB() (string, error)\n\nThen\n\n\tEventually(FetchFromDB).Should(Equal(\"got it\"))\n\nwill pass only if and when the returned error is nil *and* the returned string satisfies the matcher.\n\nEventually can also accept functions that take arguments, however you must provide those arguments using .WithArguments().  For example, consider a function that takes a user-id and makes a network request to fetch a full name:\n\n\tfunc FetchFullName(userId int) (string, error)\n\nYou can poll this function like so:\n\n\tEventually(FetchFullName).WithArguments(1138).Should(Equal(\"Wookie\"))\n\nIt is important to note that the function passed into Eventually is invoked *synchronously* when polled.  Eventually does not (in fact, it cannot) kill the function if it takes longer to return than Eventually's configured timeout.  A common practice here is to use a context.  Here's an example that combines Ginkgo's spec timeout support with Eventually:\n\n\tIt(\"fetches the correct count\", func(ctx SpecContext) {\n\t\tEventually(ctx, func() int {\n\t\t\treturn client.FetchCount(ctx, \"/users\")\n\t\t}).Should(BeNumerically(\">=\", 17))\n\t}, SpecTimeout(time.Second))\n\nyou an also use Eventually().WithContext(ctx) to pass in the context.  Passed-in contexts play nicely with passed-in arguments as long as the context appears first.  You can rewrite the above example as:\n\n\tIt(\"fetches the correct count\", func(ctx SpecContext) {\n\t\tEventually(client.FetchCount).WithContext(ctx).WithArguments(\"/users\").Should(BeNumerically(\">=\", 17))\n\t}, SpecTimeout(time.Second))\n\nEither way the context passed to Eventually is also passed to the underlying function.  Now, when Ginkgo cancels the context both the FetchCount client and Gomega will be informed and can exit.\n\nBy default, when a context is passed to Eventually *without* an explicit timeout, Gomega will rely solely on the context's cancellation to determine when to stop polling.  If you want to specify a timeout in addition to the context you can do so using the .WithTimeout() method.  For example:\n\n\tEventually(client.FetchCount).WithContext(ctx).WithTimeout(10*time.Second).Should(BeNumerically(\">=\", 17))\n\nnow either the context cancellation or the timeout will cause Eventually to stop polling.\n\nIf, instead, you would like to opt out of this behavior and have Gomega's default timeouts govern Eventuallys that take a context you can call:\n\n\tEnforceDefaultTimeoutsWhenUsingContexts()\n\nin the DSL (or on a Gomega instance).  Now all calls to Eventually that take a context will fail if either the context is cancelled or the default timeout elapses.\n\n**Category 3: Making assertions _in_ the function passed into Eventually**\n\nWhen testing complex systems it can be valuable to assert that a _set_ of assertions passes Eventually.  Eventually supports this by accepting functions that take a single Gomega argument and return zero or more values.\n\nHere's an example that makes some assertions and returns a value and error:\n\n\tEventually(func(g Gomega) (Widget, error) {\n\t\tids, err := client.FetchIDs()\n\t\tg.Expect(err).NotTo(HaveOccurred())\n\t\tg.Expect(ids).To(ContainElement(1138))\n\t\treturn client.FetchWidget(1138)\n\t}).Should(Equal(expectedWidget))\n\nwill pass only if all the assertions in the polled function pass and the return value satisfied the matcher.\n\nEventually also supports a special case polling function that takes a single Gomega argument and returns no values.  Eventually assumes such a function is making assertions and is designed to work with the Succeed matcher to validate that all assertions have passed.\nFor example:\n\n\tEventually(func(g Gomega) {\n\t\tmodel, err := client.Find(1138)\n\t\tg.Expect(err).NotTo(HaveOccurred())\n\t\tg.Expect(model.Reticulate()).To(Succeed())\n\t\tg.Expect(model.IsReticulated()).To(BeTrue())\n\t\tg.Expect(model.Save()).To(Succeed())\n\t}).Should(Succeed())\n\nwill rerun the function until all assertions pass.\n\nYou can also pass additional arguments to functions that take a Gomega.  The only rule is that the Gomega argument must be first.  If you also want to pass the context attached to Eventually you must ensure that is the second argument.  For example:\n\n\tEventually(func(g Gomega, ctx context.Context, path string, expected ...string){\n\t\ttok, err := client.GetToken(ctx)\n\t\tg.Expect(err).NotTo(HaveOccurred())\n\n\t\telements, err := client.Fetch(ctx, tok, path)\n\t\tg.Expect(err).NotTo(HaveOccurred())\n\t\tg.Expect(elements).To(ConsistOf(expected))\n\t}).WithContext(ctx).WithArguments(\"/names\", \"Joe\", \"Jane\", \"Sam\").Should(Succeed())\n\nYou can ensure that you get a number of consecutive successful tries before succeeding using `MustPassRepeatedly(int)`. For Example:\n\n\tint count := 0\n\tEventually(func() bool {\n\t\tcount++\n\t\treturn count > 2\n\t}).MustPassRepeatedly(2).Should(BeTrue())\n\t// Because we had to wait for 2 calls that returned true\n\tExpect(count).To(Equal(3))\n\nFinally, in addition to passing timeouts and a context to Eventually you can be more explicit with Eventually's chaining configuration methods:\n\n\tEventually(..., \"10s\", \"2s\", ctx).Should(...)\n\nis equivalent to\n\n\tEventually(...).WithTimeout(10*time.Second).WithPolling(2*time.Second).WithContext(ctx).Should(...)\n*/\nfunc Eventually(actualOrCtx interface{}, args ...interface{}) AsyncAssertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.Eventually(actualOrCtx, args...)\n}\n\n// EventuallyWithOffset operates like Eventually but takes an additional\n// initial argument to indicate an offset in the call stack.  This is useful when building helper\n// functions that contain matchers.  To learn more, read about `ExpectWithOffset`.\n//\n// `EventuallyWithOffset` is the same as `Eventually(...).WithOffset`.\n//\n// `EventuallyWithOffset` specifying a timeout interval (and an optional polling interval) are\n// the same as `Eventually(...).WithOffset(...).WithTimeout` or\n// `Eventually(...).WithOffset(...).WithTimeout(...).WithPolling`.\nfunc EventuallyWithOffset(offset int, actualOrCtx interface{}, args ...interface{}) AsyncAssertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.EventuallyWithOffset(offset, actualOrCtx, args...)\n}\n\n/*\nConsistently, like Eventually, enables making assertions on asynchronous behavior.\n\nConsistently blocks when called for a specified duration.  During that duration Consistently repeatedly polls its matcher and ensures that it is satisfied.  If the matcher is consistently satisfied, then Consistently will pass.  Otherwise Consistently will fail.\n\nBoth the total waiting duration and the polling interval are configurable as optional arguments.  The first optional argument is the duration that Consistently will run for (defaults to 100ms), and the second argument is the polling interval (defaults to 10ms).  As with Eventually, these intervals can be passed in as time.Duration, parsable duration strings or an integer or float number of seconds.  You can also pass in an optional context.Context - Consistently will exit early (with a failure) if the context is cancelled before the waiting duration expires.\n\nConsistently accepts the same three categories of actual as Eventually, check the Eventually docs to learn more.\n\nConsistently is useful in cases where you want to assert that something *does not happen* for a period of time.  For example, you may want to assert that a goroutine does *not* send data down a channel.  In this case you could write:\n\n\tConsistently(channel, \"200ms\").ShouldNot(Receive())\n\nThis will block for 200 milliseconds and repeatedly check the channel and ensure nothing has been received.\n*/\nfunc Consistently(actualOrCtx interface{}, args ...interface{}) AsyncAssertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.Consistently(actualOrCtx, args...)\n}\n\n// ConsistentlyWithOffset operates like Consistently but takes an additional\n// initial argument to indicate an offset in the call stack. This is useful when building helper\n// functions that contain matchers. To learn more, read about `ExpectWithOffset`.\n//\n// `ConsistentlyWithOffset` is the same as `Consistently(...).WithOffset` and\n// optional `WithTimeout` and `WithPolling`.\nfunc ConsistentlyWithOffset(offset int, actualOrCtx interface{}, args ...interface{}) AsyncAssertion {\n\tensureDefaultGomegaIsConfigured()\n\treturn Default.ConsistentlyWithOffset(offset, actualOrCtx, args...)\n}\n\n/*\nStopTrying can be used to signal to Eventually and Consistently that they should abort and stop trying.  This always results in a failure of the assertion - and the failure message is the content of the StopTrying signal.\n\nYou can send the StopTrying signal by either returning StopTrying(\"message\") as an error from your passed-in function _or_ by calling StopTrying(\"message\").Now() to trigger a panic and end execution.\n\nYou can also wrap StopTrying around an error with `StopTrying(\"message\").Wrap(err)` and can attach additional objects via `StopTrying(\"message\").Attach(\"description\", object).  When rendered, the signal will include the wrapped error and any attached objects rendered using Gomega's default formatting.\n\nHere are a couple of examples.  This is how you might use StopTrying() as an error to signal that Eventually should stop:\n\n\tplayerIndex, numPlayers := 0, 11\n\tEventually(func() (string, error) {\n\t    if playerIndex == numPlayers {\n\t        return \"\", StopTrying(\"no more players left\")\n\t    }\n\t    name := client.FetchPlayer(playerIndex)\n\t    playerIndex += 1\n\t    return name, nil\n\t}).Should(Equal(\"Patrick Mahomes\"))\n\nAnd here's an example where `StopTrying().Now()` is called to halt execution immediately:\n\n\tEventually(func() []string {\n\t\tnames, err := client.FetchAllPlayers()\n\t\tif err == client.IRRECOVERABLE_ERROR {\n\t\t\tStopTrying(\"Irrecoverable error occurred\").Wrap(err).Now()\n\t\t}\n\t\treturn names\n\t}).Should(ContainElement(\"Patrick Mahomes\"))\n*/\nvar StopTrying = internal.StopTrying\n\n/*\nTryAgainAfter(<duration>) allows you to adjust the polling interval for the _next_ iteration of `Eventually` or `Consistently`.  Like `StopTrying` you can either return `TryAgainAfter` as an error or trigger it immedieately with `.Now()`\n\nWhen `TryAgainAfter(<duration>` is triggered `Eventually` and `Consistently` will wait for that duration.  If a timeout occurs before the next poll is triggered both `Eventually` and `Consistently` will always fail with the content of the TryAgainAfter message.  As with StopTrying you can `.Wrap()` and error and `.Attach()` additional objects to `TryAgainAfter`.\n*/\nvar TryAgainAfter = internal.TryAgainAfter\n\n/*\nPollingSignalError is the error returned by StopTrying() and TryAgainAfter()\n*/\ntype PollingSignalError = internal.PollingSignalError\n\n// SetDefaultEventuallyTimeout sets the default timeout duration for Eventually. Eventually will repeatedly poll your condition until it succeeds, or until this timeout elapses.\nfunc SetDefaultEventuallyTimeout(t time.Duration) {\n\tDefault.SetDefaultEventuallyTimeout(t)\n}\n\n// SetDefaultEventuallyPollingInterval sets the default polling interval for Eventually.\nfunc SetDefaultEventuallyPollingInterval(t time.Duration) {\n\tDefault.SetDefaultEventuallyPollingInterval(t)\n}\n\n// SetDefaultConsistentlyDuration sets  the default duration for Consistently. Consistently will verify that your condition is satisfied for this long.\nfunc SetDefaultConsistentlyDuration(t time.Duration) {\n\tDefault.SetDefaultConsistentlyDuration(t)\n}\n\n// SetDefaultConsistentlyPollingInterval sets the default polling interval for Consistently.\nfunc SetDefaultConsistentlyPollingInterval(t time.Duration) {\n\tDefault.SetDefaultConsistentlyPollingInterval(t)\n}\n\n// EnforceDefaultTimeoutsWhenUsingContexts forces `Eventually` to apply a default timeout even when a context is provided.\nfunc EnforceDefaultTimeoutsWhenUsingContexts() {\n\tDefault.EnforceDefaultTimeoutsWhenUsingContexts()\n}\n\n// DisableDefaultTimeoutsWhenUsingContext disables the default timeout when a context is provided to `Eventually`.\nfunc DisableDefaultTimeoutsWhenUsingContext() {\n\tDefault.DisableDefaultTimeoutsWhenUsingContext()\n}\n\n// AsyncAssertion is returned by Eventually and Consistently and polls the actual value passed into Eventually against\n// the matcher passed to the Should and ShouldNot methods.\n//\n// Both Should and ShouldNot take a variadic optionalDescription argument.\n// This argument allows you to make your failure messages more descriptive.\n// If a single argument of type `func() string` is passed, this function will be lazily evaluated if a failure occurs\n// and the returned string is used to annotate the failure message.\n// Otherwise, this argument is passed on to fmt.Sprintf() and then used to annotate the failure message.\n//\n// Both Should and ShouldNot return a boolean that is true if the assertion passed and false if it failed.\n//\n// Example:\n//\n//\tEventually(myChannel).Should(Receive(), \"Something should have come down the pipe.\")\n//\tConsistently(myChannel).ShouldNot(Receive(), func() string { return \"Nothing should have come down the pipe.\" })\ntype AsyncAssertion = types.AsyncAssertion\n\n// GomegaAsyncAssertion is deprecated in favor of AsyncAssertion, which does not stutter.\ntype GomegaAsyncAssertion = types.AsyncAssertion\n\n// Assertion is returned by Ω and Expect and compares the actual value to the matcher\n// passed to the Should/ShouldNot and To/ToNot/NotTo methods.\n//\n// Typically Should/ShouldNot are used with Ω and To/ToNot/NotTo are used with Expect\n// though this is not enforced.\n//\n// All methods take a variadic optionalDescription argument.\n// This argument allows you to make your failure messages more descriptive.\n// If a single argument of type `func() string` is passed, this function will be lazily evaluated if a failure occurs\n// and the returned string is used to annotate the failure message.\n// Otherwise, this argument is passed on to fmt.Sprintf() and then used to annotate the failure message.\n//\n// All methods return a bool that is true if the assertion passed and false if it failed.\n//\n// Example:\n//\n//\tΩ(farm.HasCow()).Should(BeTrue(), \"Farm %v should have a cow\", farm)\ntype Assertion = types.Assertion\n\n// GomegaAssertion is deprecated in favor of Assertion, which does not stutter.\ntype GomegaAssertion = types.Assertion\n\n// OmegaMatcher is deprecated in favor of the better-named and better-organized types.GomegaMatcher but sticks around to support existing code that uses it\ntype OmegaMatcher = types.GomegaMatcher\n"
        },
        {
          "name": "gstruct",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "matchers.go",
          "type": "blob",
          "size": 28.1904296875,
          "content": "package gomega\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/onsi/gomega/matchers\"\n\t\"github.com/onsi/gomega/types\"\n)\n\n// Equal uses reflect.DeepEqual to compare actual with expected.  Equal is strict about\n// types when performing comparisons.\n// It is an error for both actual and expected to be nil.  Use BeNil() instead.\nfunc Equal(expected interface{}) types.GomegaMatcher {\n\treturn &matchers.EqualMatcher{\n\t\tExpected: expected,\n\t}\n}\n\n// BeEquivalentTo is more lax than Equal, allowing equality between different types.\n// This is done by converting actual to have the type of expected before\n// attempting equality with reflect.DeepEqual.\n// It is an error for actual and expected to be nil.  Use BeNil() instead.\nfunc BeEquivalentTo(expected interface{}) types.GomegaMatcher {\n\treturn &matchers.BeEquivalentToMatcher{\n\t\tExpected: expected,\n\t}\n}\n\n// BeComparableTo uses gocmp.Equal from github.com/google/go-cmp (instead of reflect.DeepEqual) to perform a deep comparison.\n// You can pass cmp.Option as options.\n// It is an error for actual and expected to be nil.  Use BeNil() instead.\nfunc BeComparableTo(expected interface{}, opts ...cmp.Option) types.GomegaMatcher {\n\treturn &matchers.BeComparableToMatcher{\n\t\tExpected: expected,\n\t\tOptions:  opts,\n\t}\n}\n\n// BeIdenticalTo uses the == operator to compare actual with expected.\n// BeIdenticalTo is strict about types when performing comparisons.\n// It is an error for both actual and expected to be nil.  Use BeNil() instead.\nfunc BeIdenticalTo(expected interface{}) types.GomegaMatcher {\n\treturn &matchers.BeIdenticalToMatcher{\n\t\tExpected: expected,\n\t}\n}\n\n// BeNil succeeds if actual is nil\nfunc BeNil() types.GomegaMatcher {\n\treturn &matchers.BeNilMatcher{}\n}\n\n// BeTrue succeeds if actual is true\n//\n// In general, it's better to use `BeTrueBecause(reason)` to provide a more useful error message if a true check fails.\nfunc BeTrue() types.GomegaMatcher {\n\treturn &matchers.BeTrueMatcher{}\n}\n\n// BeFalse succeeds if actual is false\n//\n// In general, it's better to use `BeFalseBecause(reason)` to provide a more useful error message if a false check fails.\nfunc BeFalse() types.GomegaMatcher {\n\treturn &matchers.BeFalseMatcher{}\n}\n\n// BeTrueBecause succeeds if actual is true and displays the provided reason if it is false\n// fmt.Sprintf is used to render the reason\nfunc BeTrueBecause(format string, args ...any) types.GomegaMatcher {\n\treturn &matchers.BeTrueMatcher{Reason: fmt.Sprintf(format, args...)}\n}\n\n// BeFalseBecause succeeds if actual is false and displays the provided reason if it is true.\n// fmt.Sprintf is used to render the reason\nfunc BeFalseBecause(format string, args ...any) types.GomegaMatcher {\n\treturn &matchers.BeFalseMatcher{Reason: fmt.Sprintf(format, args...)}\n}\n\n// HaveOccurred succeeds if actual is a non-nil error\n// The typical Go error checking pattern looks like:\n//\n//\terr := SomethingThatMightFail()\n//\tExpect(err).ShouldNot(HaveOccurred())\nfunc HaveOccurred() types.GomegaMatcher {\n\treturn &matchers.HaveOccurredMatcher{}\n}\n\n// Succeed passes if actual is a nil error\n// Succeed is intended to be used with functions that return a single error value. Instead of\n//\n//\terr := SomethingThatMightFail()\n//\tExpect(err).ShouldNot(HaveOccurred())\n//\n// You can write:\n//\n//\tExpect(SomethingThatMightFail()).Should(Succeed())\n//\n// It is a mistake to use Succeed with a function that has multiple return values.  Gomega's Ω and Expect\n// functions automatically trigger failure if any return values after the first return value are non-zero/non-nil.\n// This means that Ω(MultiReturnFunc()).ShouldNot(Succeed()) can never pass.\nfunc Succeed() types.GomegaMatcher {\n\treturn &matchers.SucceedMatcher{}\n}\n\n// MatchError succeeds if actual is a non-nil error that matches the passed in\n// string, error, function, or matcher.\n//\n// These are valid use-cases:\n//\n// When passed a string:\n//\n//\tExpect(err).To(MatchError(\"an error\"))\n//\n// asserts that err.Error() == \"an error\"\n//\n// When passed an error:\n//\n//\tExpect(err).To(MatchError(SomeError))\n//\n// First checks if errors.Is(err, SomeError).\n// If that fails then it checks if reflect.DeepEqual(err, SomeError) repeatedly for err and any errors wrapped by err\n//\n// When passed a matcher:\n//\n//\tExpect(err).To(MatchError(ContainSubstring(\"sprocket not found\")))\n//\n// the matcher is passed err.Error().  In this case it asserts that err.Error() contains substring \"sprocket not found\"\n//\n// When passed a func(err) bool and a description:\n//\n//\tExpect(err).To(MatchError(os.IsNotExist, \"IsNotExist\"))\n//\n// the function is passed err and matches if the return value is true.  The description is required to allow Gomega\n// to print a useful error message.\n//\n// It is an error for err to be nil or an object that does not implement the\n// Error interface\n//\n// The optional second argument is a description of the error function, if used.  This is required when passing a function but is ignored in all other cases.\nfunc MatchError(expected interface{}, functionErrorDescription ...any) types.GomegaMatcher {\n\treturn &matchers.MatchErrorMatcher{\n\t\tExpected:           expected,\n\t\tFuncErrDescription: functionErrorDescription,\n\t}\n}\n\n// BeClosed succeeds if actual is a closed channel.\n// It is an error to pass a non-channel to BeClosed, it is also an error to pass nil\n//\n// In order to check whether or not the channel is closed, Gomega must try to read from the channel\n// (even in the `ShouldNot(BeClosed())` case).  You should keep this in mind if you wish to make subsequent assertions about\n// values coming down the channel.\n//\n// Also, if you are testing that a *buffered* channel is closed you must first read all values out of the channel before\n// asserting that it is closed (it is not possible to detect that a buffered-channel has been closed until all its buffered values are read).\n//\n// Finally, as a corollary: it is an error to check whether or not a send-only channel is closed.\nfunc BeClosed() types.GomegaMatcher {\n\treturn &matchers.BeClosedMatcher{}\n}\n\n// Receive succeeds if there is a value to be received on actual.\n// Actual must be a channel (and cannot be a send-only channel) -- anything else is an error.\n//\n// Receive returns immediately and never blocks:\n//\n// - If there is nothing on the channel `c` then Expect(c).Should(Receive()) will fail and Ω(c).ShouldNot(Receive()) will pass.\n//\n// - If the channel `c` is closed then Expect(c).Should(Receive()) will fail and Ω(c).ShouldNot(Receive()) will pass.\n//\n// - If there is something on the channel `c` ready to be read, then Expect(c).Should(Receive()) will pass and Ω(c).ShouldNot(Receive()) will fail.\n//\n// If you have a go-routine running in the background that will write to channel `c` you can:\n//\n//\tEventually(c).Should(Receive())\n//\n// This will timeout if nothing gets sent to `c` (you can modify the timeout interval as you normally do with `Eventually`)\n//\n// A similar use-case is to assert that no go-routine writes to a channel (for a period of time).  You can do this with `Consistently`:\n//\n//\tConsistently(c).ShouldNot(Receive())\n//\n// You can pass `Receive` a matcher.  If you do so, it will match the received object against the matcher.  For example:\n//\n//\tExpect(c).Should(Receive(Equal(\"foo\")))\n//\n// When given a matcher, `Receive` will always fail if there is nothing to be received on the channel.\n//\n// Passing Receive a matcher is especially useful when paired with Eventually:\n//\n//\tEventually(c).Should(Receive(ContainSubstring(\"bar\")))\n//\n// will repeatedly attempt to pull values out of `c` until a value matching \"bar\" is received.\n//\n// Furthermore, if you want to have a reference to the value *sent* to the channel you can pass the `Receive` matcher a pointer to a variable of the appropriate type:\n//\n//\tvar myThing thing\n//\tEventually(thingChan).Should(Receive(&myThing))\n//\tExpect(myThing.Sprocket).Should(Equal(\"foo\"))\n//\tExpect(myThing.IsValid()).Should(BeTrue())\n//\n// Finally, if you want to match the received object as well as get the actual received value into a variable, so you can reason further about the value received,\n// you can pass a pointer to a variable of the appropriate type first, and second a matcher:\n//\n//\tvar myThing thing\n//\tEventually(thingChan).Should(Receive(&myThing, ContainSubstring(\"bar\")))\nfunc Receive(args ...interface{}) types.GomegaMatcher {\n\treturn &matchers.ReceiveMatcher{\n\t\tArgs: args,\n\t}\n}\n\n// BeSent succeeds if a value can be sent to actual.\n// Actual must be a channel (and cannot be a receive-only channel) that can sent the type of the value passed into BeSent -- anything else is an error.\n// In addition, actual must not be closed.\n//\n// BeSent never blocks:\n//\n// - If the channel `c` is not ready to receive then Expect(c).Should(BeSent(\"foo\")) will fail immediately\n// - If the channel `c` is eventually ready to receive then Eventually(c).Should(BeSent(\"foo\")) will succeed.. presuming the channel becomes ready to receive  before Eventually's timeout\n// - If the channel `c` is closed then Expect(c).Should(BeSent(\"foo\")) and Ω(c).ShouldNot(BeSent(\"foo\")) will both fail immediately\n//\n// Of course, the value is actually sent to the channel.  The point of `BeSent` is less to make an assertion about the availability of the channel (which is typically an implementation detail that your test should not be concerned with).\n// Rather, the point of `BeSent` is to make it possible to easily and expressively write tests that can timeout on blocked channel sends.\nfunc BeSent(arg interface{}) types.GomegaMatcher {\n\treturn &matchers.BeSentMatcher{\n\t\tArg: arg,\n\t}\n}\n\n// MatchRegexp succeeds if actual is a string or stringer that matches the\n// passed-in regexp.  Optional arguments can be provided to construct a regexp\n// via fmt.Sprintf().\nfunc MatchRegexp(regexp string, args ...interface{}) types.GomegaMatcher {\n\treturn &matchers.MatchRegexpMatcher{\n\t\tRegexp: regexp,\n\t\tArgs:   args,\n\t}\n}\n\n// ContainSubstring succeeds if actual is a string or stringer that contains the\n// passed-in substring.  Optional arguments can be provided to construct the substring\n// via fmt.Sprintf().\nfunc ContainSubstring(substr string, args ...interface{}) types.GomegaMatcher {\n\treturn &matchers.ContainSubstringMatcher{\n\t\tSubstr: substr,\n\t\tArgs:   args,\n\t}\n}\n\n// HavePrefix succeeds if actual is a string or stringer that contains the\n// passed-in string as a prefix.  Optional arguments can be provided to construct\n// via fmt.Sprintf().\nfunc HavePrefix(prefix string, args ...interface{}) types.GomegaMatcher {\n\treturn &matchers.HavePrefixMatcher{\n\t\tPrefix: prefix,\n\t\tArgs:   args,\n\t}\n}\n\n// HaveSuffix succeeds if actual is a string or stringer that contains the\n// passed-in string as a suffix.  Optional arguments can be provided to construct\n// via fmt.Sprintf().\nfunc HaveSuffix(suffix string, args ...interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveSuffixMatcher{\n\t\tSuffix: suffix,\n\t\tArgs:   args,\n\t}\n}\n\n// MatchJSON succeeds if actual is a string or stringer of JSON that matches\n// the expected JSON.  The JSONs are decoded and the resulting objects are compared via\n// reflect.DeepEqual so things like key-ordering and whitespace shouldn't matter.\nfunc MatchJSON(json interface{}) types.GomegaMatcher {\n\treturn &matchers.MatchJSONMatcher{\n\t\tJSONToMatch: json,\n\t}\n}\n\n// MatchXML succeeds if actual is a string or stringer of XML that matches\n// the expected XML.  The XMLs are decoded and the resulting objects are compared via\n// reflect.DeepEqual so things like whitespaces shouldn't matter.\nfunc MatchXML(xml interface{}) types.GomegaMatcher {\n\treturn &matchers.MatchXMLMatcher{\n\t\tXMLToMatch: xml,\n\t}\n}\n\n// MatchYAML succeeds if actual is a string or stringer of YAML that matches\n// the expected YAML.  The YAML's are decoded and the resulting objects are compared via\n// reflect.DeepEqual so things like key-ordering and whitespace shouldn't matter.\nfunc MatchYAML(yaml interface{}) types.GomegaMatcher {\n\treturn &matchers.MatchYAMLMatcher{\n\t\tYAMLToMatch: yaml,\n\t}\n}\n\n// BeEmpty succeeds if actual is empty.  Actual must be of type string, array, map, chan, or slice.\nfunc BeEmpty() types.GomegaMatcher {\n\treturn &matchers.BeEmptyMatcher{}\n}\n\n// HaveLen succeeds if actual has the passed-in length.  Actual must be of type string, array, map, chan, or slice.\nfunc HaveLen(count int) types.GomegaMatcher {\n\treturn &matchers.HaveLenMatcher{\n\t\tCount: count,\n\t}\n}\n\n// HaveCap succeeds if actual has the passed-in capacity.  Actual must be of type array, chan, or slice.\nfunc HaveCap(count int) types.GomegaMatcher {\n\treturn &matchers.HaveCapMatcher{\n\t\tCount: count,\n\t}\n}\n\n// BeZero succeeds if actual is the zero value for its type or if actual is nil.\nfunc BeZero() types.GomegaMatcher {\n\treturn &matchers.BeZeroMatcher{}\n}\n\n// ContainElement succeeds if actual contains the passed in element. By default\n// ContainElement() uses Equal() to perform the match, however a matcher can be\n// passed in instead:\n//\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ContainElement(ContainSubstring(\"Bar\")))\n//\n// Actual must be an array, slice or map. For maps, ContainElement searches\n// through the map's values.\n//\n// If you want to have a copy of the matching element(s) found you can pass a\n// pointer to a variable of the appropriate type. If the variable isn't a slice\n// or map, then exactly one match will be expected and returned. If the variable\n// is a slice or map, then at least one match is expected and all matches will be\n// stored in the variable.\n//\n//\tvar findings []string\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ContainElement(ContainSubString(\"Bar\", &findings)))\nfunc ContainElement(element interface{}, result ...interface{}) types.GomegaMatcher {\n\treturn &matchers.ContainElementMatcher{\n\t\tElement: element,\n\t\tResult:  result,\n\t}\n}\n\n// BeElementOf succeeds if actual is contained in the passed in elements.\n// BeElementOf() always uses Equal() to perform the match.\n// When the passed in elements are comprised of a single element that is either an Array or Slice, BeElementOf() behaves\n// as the reverse of ContainElement() that operates with Equal() to perform the match.\n//\n//\tExpect(2).Should(BeElementOf([]int{1, 2}))\n//\tExpect(2).Should(BeElementOf([2]int{1, 2}))\n//\n// Otherwise, BeElementOf() provides a syntactic sugar for Or(Equal(_), Equal(_), ...):\n//\n//\tExpect(2).Should(BeElementOf(1, 2))\n//\n// Actual must be typed.\nfunc BeElementOf(elements ...interface{}) types.GomegaMatcher {\n\treturn &matchers.BeElementOfMatcher{\n\t\tElements: elements,\n\t}\n}\n\n// BeKeyOf succeeds if actual is contained in the keys of the passed in map.\n// BeKeyOf() always uses Equal() to perform the match between actual and the map keys.\n//\n//\tExpect(\"foo\").Should(BeKeyOf(map[string]bool{\"foo\": true, \"bar\": false}))\nfunc BeKeyOf(element interface{}) types.GomegaMatcher {\n\treturn &matchers.BeKeyOfMatcher{\n\t\tMap: element,\n\t}\n}\n\n// ConsistOf succeeds if actual contains precisely the elements passed into the matcher.  The ordering of the elements does not matter.\n// By default ConsistOf() uses Equal() to match the elements, however custom matchers can be passed in instead.  Here are some examples:\n//\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ConsistOf(\"FooBar\", \"Foo\"))\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ConsistOf(ContainSubstring(\"Bar\"), \"Foo\"))\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ConsistOf(ContainSubstring(\"Foo\"), ContainSubstring(\"Foo\")))\n//\n// Actual must be an array, slice or map.  For maps, ConsistOf matches against the map's values.\n//\n// You typically pass variadic arguments to ConsistOf (as in the examples above).  However, if you need to pass in a slice you can provided that it\n// is the only element passed in to ConsistOf:\n//\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ConsistOf([]string{\"FooBar\", \"Foo\"}))\n//\n// Note that Go's type system does not allow you to write this as ConsistOf([]string{\"FooBar\", \"Foo\"}...) as []string and []interface{} are different types - hence the need for this special rule.\nfunc ConsistOf(elements ...interface{}) types.GomegaMatcher {\n\treturn &matchers.ConsistOfMatcher{\n\t\tElements: elements,\n\t}\n}\n\n// HaveExactElements succeeds if actual contains elements that precisely match the elements passed into the matcher. The ordering of the elements does matter.\n// By default HaveExactElements() uses Equal() to match the elements, however custom matchers can be passed in instead.  Here are some examples:\n//\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(HaveExactElements(\"Foo\", \"FooBar\"))\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(HaveExactElements(\"Foo\", ContainSubstring(\"Bar\")))\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(HaveExactElements(ContainSubstring(\"Foo\"), ContainSubstring(\"Foo\")))\n//\n// Actual must be an array or slice.\nfunc HaveExactElements(elements ...interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveExactElementsMatcher{\n\t\tElements: elements,\n\t}\n}\n\n// ContainElements succeeds if actual contains the passed in elements. The ordering of the elements does not matter.\n// By default ContainElements() uses Equal() to match the elements, however custom matchers can be passed in instead. Here are some examples:\n//\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ContainElements(\"FooBar\"))\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(ContainElements(ContainSubstring(\"Bar\"), \"Foo\"))\n//\n// Actual must be an array, slice or map.\n// For maps, ContainElements searches through the map's values.\nfunc ContainElements(elements ...interface{}) types.GomegaMatcher {\n\treturn &matchers.ContainElementsMatcher{\n\t\tElements: elements,\n\t}\n}\n\n// HaveEach succeeds if actual solely contains elements that match the passed in element.\n// Please note that if actual is empty, HaveEach always will fail.\n// By default HaveEach() uses Equal() to perform the match, however a\n// matcher can be passed in instead:\n//\n//\tExpect([]string{\"Foo\", \"FooBar\"}).Should(HaveEach(ContainSubstring(\"Foo\")))\n//\n// Actual must be an array, slice or map.\n// For maps, HaveEach searches through the map's values.\nfunc HaveEach(element interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveEachMatcher{\n\t\tElement: element,\n\t}\n}\n\n// HaveKey succeeds if actual is a map with the passed in key.\n// By default HaveKey uses Equal() to perform the match, however a\n// matcher can be passed in instead:\n//\n//\tExpect(map[string]string{\"Foo\": \"Bar\", \"BazFoo\": \"Duck\"}).Should(HaveKey(MatchRegexp(`.+Foo$`)))\nfunc HaveKey(key interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveKeyMatcher{\n\t\tKey: key,\n\t}\n}\n\n// HaveKeyWithValue succeeds if actual is a map with the passed in key and value.\n// By default HaveKeyWithValue uses Equal() to perform the match, however a\n// matcher can be passed in instead:\n//\n//\tExpect(map[string]string{\"Foo\": \"Bar\", \"BazFoo\": \"Duck\"}).Should(HaveKeyWithValue(\"Foo\", \"Bar\"))\n//\tExpect(map[string]string{\"Foo\": \"Bar\", \"BazFoo\": \"Duck\"}).Should(HaveKeyWithValue(MatchRegexp(`.+Foo$`), \"Bar\"))\nfunc HaveKeyWithValue(key interface{}, value interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveKeyWithValueMatcher{\n\t\tKey:   key,\n\t\tValue: value,\n\t}\n}\n\n// HaveField succeeds if actual is a struct and the value at the passed in field\n// matches the passed in matcher.  By default HaveField used Equal() to perform the match,\n// however a matcher can be passed in in stead.\n//\n// The field must be a string that resolves to the name of a field in the struct.  Structs can be traversed\n// using the '.' delimiter.  If the field ends with '()' a method named field is assumed to exist on the struct and is invoked.\n// Such methods must take no arguments and return a single value:\n//\n//\ttype Book struct {\n//\t    Title string\n//\t    Author Person\n//\t}\n//\ttype Person struct {\n//\t    FirstName string\n//\t    LastName string\n//\t    DOB time.Time\n//\t}\n//\tExpect(book).To(HaveField(\"Title\", \"Les Miserables\"))\n//\tExpect(book).To(HaveField(\"Title\", ContainSubstring(\"Les\"))\n//\tExpect(book).To(HaveField(\"Author.FirstName\", Equal(\"Victor\"))\n//\tExpect(book).To(HaveField(\"Author.DOB.Year()\", BeNumerically(\"<\", 1900))\nfunc HaveField(field string, expected interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveFieldMatcher{\n\t\tField:    field,\n\t\tExpected: expected,\n\t}\n}\n\n// HaveExistingField succeeds if actual is a struct and the specified field\n// exists.\n//\n// HaveExistingField can be combined with HaveField in order to cover use cases\n// with optional fields. HaveField alone would trigger an error in such situations.\n//\n//\tExpect(MrHarmless).NotTo(And(HaveExistingField(\"Title\"), HaveField(\"Title\", \"Supervillain\")))\nfunc HaveExistingField(field string) types.GomegaMatcher {\n\treturn &matchers.HaveExistingFieldMatcher{\n\t\tField: field,\n\t}\n}\n\n// HaveValue applies the given matcher to the value of actual, optionally and\n// repeatedly dereferencing pointers or taking the concrete value of interfaces.\n// Thus, the matcher will always be applied to non-pointer and non-interface\n// values only. HaveValue will fail with an error if a pointer or interface is\n// nil. It will also fail for more than 31 pointer or interface dereferences to\n// guard against mistakenly applying it to arbitrarily deep linked pointers.\n//\n// HaveValue differs from gstruct.PointTo in that it does not expect actual to\n// be a pointer (as gstruct.PointTo does) but instead also accepts non-pointer\n// and even interface values.\n//\n//\tactual := 42\n//\tExpect(actual).To(HaveValue(42))\n//\tExpect(&actual).To(HaveValue(42))\nfunc HaveValue(matcher types.GomegaMatcher) types.GomegaMatcher {\n\treturn &matchers.HaveValueMatcher{\n\t\tMatcher: matcher,\n\t}\n}\n\n// BeNumerically performs numerical assertions in a type-agnostic way.\n// Actual and expected should be numbers, though the specific type of\n// number is irrelevant (float32, float64, uint8, etc...).\n//\n// There are six, self-explanatory, supported comparators:\n//\n//\tExpect(1.0).Should(BeNumerically(\"==\", 1))\n//\tExpect(1.0).Should(BeNumerically(\"~\", 0.999, 0.01))\n//\tExpect(1.0).Should(BeNumerically(\">\", 0.9))\n//\tExpect(1.0).Should(BeNumerically(\">=\", 1.0))\n//\tExpect(1.0).Should(BeNumerically(\"<\", 3))\n//\tExpect(1.0).Should(BeNumerically(\"<=\", 1.0))\nfunc BeNumerically(comparator string, compareTo ...interface{}) types.GomegaMatcher {\n\treturn &matchers.BeNumericallyMatcher{\n\t\tComparator: comparator,\n\t\tCompareTo:  compareTo,\n\t}\n}\n\n// BeTemporally compares time.Time's like BeNumerically\n// Actual and expected must be time.Time. The comparators are the same as for BeNumerically\n//\n//\tExpect(time.Now()).Should(BeTemporally(\">\", time.Time{}))\n//\tExpect(time.Now()).Should(BeTemporally(\"~\", time.Now(), time.Second))\nfunc BeTemporally(comparator string, compareTo time.Time, threshold ...time.Duration) types.GomegaMatcher {\n\treturn &matchers.BeTemporallyMatcher{\n\t\tComparator: comparator,\n\t\tCompareTo:  compareTo,\n\t\tThreshold:  threshold,\n\t}\n}\n\n// BeAssignableToTypeOf succeeds if actual is assignable to the type of expected.\n// It will return an error when one of the values is nil.\n//\n//\tExpect(0).Should(BeAssignableToTypeOf(0))         // Same values\n//\tExpect(5).Should(BeAssignableToTypeOf(-1))        // different values same type\n//\tExpect(\"foo\").Should(BeAssignableToTypeOf(\"bar\")) // different values same type\n//\tExpect(struct{ Foo string }{}).Should(BeAssignableToTypeOf(struct{ Foo string }{}))\nfunc BeAssignableToTypeOf(expected interface{}) types.GomegaMatcher {\n\treturn &matchers.AssignableToTypeOfMatcher{\n\t\tExpected: expected,\n\t}\n}\n\n// Panic succeeds if actual is a function that, when invoked, panics.\n// Actual must be a function that takes no arguments and returns no results.\nfunc Panic() types.GomegaMatcher {\n\treturn &matchers.PanicMatcher{}\n}\n\n// PanicWith succeeds if actual is a function that, when invoked, panics with a specific value.\n// Actual must be a function that takes no arguments and returns no results.\n//\n// By default PanicWith uses Equal() to perform the match, however a\n// matcher can be passed in instead:\n//\n//\tExpect(fn).Should(PanicWith(MatchRegexp(`.+Foo$`)))\nfunc PanicWith(expected interface{}) types.GomegaMatcher {\n\treturn &matchers.PanicMatcher{Expected: expected}\n}\n\n// BeAnExistingFile succeeds if a file exists.\n// Actual must be a string representing the abs path to the file being checked.\nfunc BeAnExistingFile() types.GomegaMatcher {\n\treturn &matchers.BeAnExistingFileMatcher{}\n}\n\n// BeARegularFile succeeds if a file exists and is a regular file.\n// Actual must be a string representing the abs path to the file being checked.\nfunc BeARegularFile() types.GomegaMatcher {\n\treturn &matchers.BeARegularFileMatcher{}\n}\n\n// BeADirectory succeeds if a file exists and is a directory.\n// Actual must be a string representing the abs path to the file being checked.\nfunc BeADirectory() types.GomegaMatcher {\n\treturn &matchers.BeADirectoryMatcher{}\n}\n\n// HaveHTTPStatus succeeds if the Status or StatusCode field of an HTTP response matches.\n// Actual must be either a *http.Response or *httptest.ResponseRecorder.\n// Expected must be either an int or a string.\n//\n//\tExpect(resp).Should(HaveHTTPStatus(http.StatusOK))   // asserts that resp.StatusCode == 200\n//\tExpect(resp).Should(HaveHTTPStatus(\"404 Not Found\")) // asserts that resp.Status == \"404 Not Found\"\n//\tExpect(resp).Should(HaveHTTPStatus(http.StatusOK, http.StatusNoContent))   // asserts that resp.StatusCode == 200 || resp.StatusCode == 204\nfunc HaveHTTPStatus(expected ...interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveHTTPStatusMatcher{Expected: expected}\n}\n\n// HaveHTTPHeaderWithValue succeeds if the header is found and the value matches.\n// Actual must be either a *http.Response or *httptest.ResponseRecorder.\n// Expected must be a string header name, followed by a header value which\n// can be a string, or another matcher.\nfunc HaveHTTPHeaderWithValue(header string, value interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveHTTPHeaderWithValueMatcher{\n\t\tHeader: header,\n\t\tValue:  value,\n\t}\n}\n\n// HaveHTTPBody matches if the body matches.\n// Actual must be either a *http.Response or *httptest.ResponseRecorder.\n// Expected must be either a string, []byte, or other matcher\nfunc HaveHTTPBody(expected interface{}) types.GomegaMatcher {\n\treturn &matchers.HaveHTTPBodyMatcher{Expected: expected}\n}\n\n// And succeeds only if all of the given matchers succeed.\n// The matchers are tried in order, and will fail-fast if one doesn't succeed.\n//\n//\tExpect(\"hi\").To(And(HaveLen(2), Equal(\"hi\"))\n//\n// And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.\nfunc And(ms ...types.GomegaMatcher) types.GomegaMatcher {\n\treturn &matchers.AndMatcher{Matchers: ms}\n}\n\n// SatisfyAll is an alias for And().\n//\n//\tExpect(\"hi\").Should(SatisfyAll(HaveLen(2), Equal(\"hi\")))\nfunc SatisfyAll(matchers ...types.GomegaMatcher) types.GomegaMatcher {\n\treturn And(matchers...)\n}\n\n// Or succeeds if any of the given matchers succeed.\n// The matchers are tried in order and will return immediately upon the first successful match.\n//\n//\tExpect(\"hi\").To(Or(HaveLen(3), HaveLen(2))\n//\n// And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.\nfunc Or(ms ...types.GomegaMatcher) types.GomegaMatcher {\n\treturn &matchers.OrMatcher{Matchers: ms}\n}\n\n// SatisfyAny is an alias for Or().\n//\n//\tExpect(\"hi\").SatisfyAny(Or(HaveLen(3), HaveLen(2))\nfunc SatisfyAny(matchers ...types.GomegaMatcher) types.GomegaMatcher {\n\treturn Or(matchers...)\n}\n\n// Not negates the given matcher; it succeeds if the given matcher fails.\n//\n//\tExpect(1).To(Not(Equal(2))\n//\n// And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.\nfunc Not(matcher types.GomegaMatcher) types.GomegaMatcher {\n\treturn &matchers.NotMatcher{Matcher: matcher}\n}\n\n// WithTransform applies the `transform` to the actual value and matches it against `matcher`.\n// The given transform must be either a function of one parameter that returns one value or a\n// function of one parameter that returns two values, where the second value must be of the\n// error type.\n//\n//\tvar plus1 = func(i int) int { return i + 1 }\n//\tExpect(1).To(WithTransform(plus1, Equal(2))\n//\n//\t var failingplus1 = func(i int) (int, error) { return 42, \"this does not compute\" }\n//\t Expect(1).To(WithTransform(failingplus1, Equal(2)))\n//\n// And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.\nfunc WithTransform(transform interface{}, matcher types.GomegaMatcher) types.GomegaMatcher {\n\treturn matchers.NewWithTransformMatcher(transform, matcher)\n}\n\n// Satisfy matches the actual value against the `predicate` function.\n// The given predicate must be a function of one parameter that returns bool.\n//\n//\tvar isEven = func(i int) bool { return i%2 == 0 }\n//\tExpect(2).To(Satisfy(isEven))\nfunc Satisfy(predicate interface{}) types.GomegaMatcher {\n\treturn matchers.NewSatisfyMatcher(predicate)\n}\n"
        },
        {
          "name": "matchers",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}