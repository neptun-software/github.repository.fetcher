{
  "metadata": {
    "timestamp": 1736567193753,
    "page": 790,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "charmbracelet/log",
      "stars": 2472,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2744140625,
          "content": "*.txt\n*.gif\n\nexamples/batch2/batch2\nexamples/chocolate-chips/chocolate-chips\nexamples/cookie/cookie\nexamples/error/error\nexamples/format/format\nexamples/log/log\nexamples/new/new\nexamples/options/options\nexamples/oven/oven\nexamples/temperature/temperature\n\n.vscode\n.history\ngo.work\n"
        },
        {
          "name": ".golangci-soft.yml",
          "type": "blob",
          "size": 0.57421875,
          "content": "run:\n  tests: false\n  issues-exit-code: 0\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - exhaustive\n    - goconst\n    - godot\n    - godox\n    - mnd\n    - gomoddirectives\n    - goprintffuncname\n    - misspell\n    - nakedret\n    - nestif\n    - noctx\n    - nolintlint\n    - prealloc\n    - wrapcheck\n\n  # disable default linters, they are already enabled in .golangci.yml\n  disable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3564453125,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - gofumpt\n    - goimports\n    - gosec\n    - nilerr\n    - revive\n    - rowserrcheck\n    - sqlclosecheck\n    - tparallel\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.0771484375,
          "content": "includes:\n  - from_url:\n      url: charmbracelet/meta/main/goreleaser-lib.yaml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "MIT License\n\nCopyright (c) 2022-2023 Charmbracelet, Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.04296875,
          "content": "# Log\n\n<p>\n    <picture>\n      <source media=\"(prefers-color-scheme: light)\" srcset=\"https://user-images.githubusercontent.com/25087/219742757-c8afe0d9-608a-4845-a555-ef59c0af9ebc.png\" width=\"359\">\n      <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://user-images.githubusercontent.com/25087/219743408-3d7bef51-1409-40c0-8159-acc6e52f078e.png\" width=\"359\">\n      <img src=\"https://user-images.githubusercontent.com/25087/219742757-c8afe0d9-608a-4845-a555-ef59c0af9ebc.png\" width=\"359\" />\n    </picture>\n    <br>\n    <a href=\"https://github.com/charmbracelet/log/releases\"><img src=\"https://img.shields.io/github/release/charmbracelet/log.svg\" alt=\"Latest Release\"></a>\n    <a href=\"https://pkg.go.dev/github.com/charmbracelet/log?tab=doc\"><img src=\"https://godoc.org/github.com/golang/gddo?status.svg\" alt=\"Go Docs\"></a>\n    <a href=\"https://github.com/charmbracelet/log/actions\"><img src=\"https://github.com/charmbracelet/log/workflows/build/badge.svg\" alt=\"Build Status\"></a>\n    <a href=\"https://codecov.io/gh/charmbracelet/log\"><img alt=\"Codecov branch\" src=\"https://img.shields.io/codecov/c/github/charmbracelet/log/main.svg\"></a>\n    <a href=\"https://goreportcard.com/report/github.com/charmbracelet/log\"><img alt=\"Go Report Card\" src=\"https://goreportcard.com/badge/github.com/charmbracelet/log\"></a>\n</p>\n\nA minimal and colorful Go logging library. ü™µ\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://vhs.charm.sh/vhs-1wBImk2iSIuiiD7Ib9rufi.gif\">\n    <source media=\"(prefers-color-scheme: light)\" srcset=\"https://vhs.charm.sh/vhs-1wBImk2iSIuiiD7Ib9rufi.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" srcset=\"https://vhs.charm.sh/vhs-2NvOYS29AauVRgRRPmquXx.gif\"> -->\n    <img src=\"https://vhs.charm.sh/vhs-1wBImk2iSIuiiD7Ib9rufi.gif\" alt=\"Made with VHS\" />\n</picture>\n\nIt provides a leveled structured human readable logger with a small API. Unlike\n[standard `log`][stdlog], the Charm logger provides customizable colorful human\nreadable logging with batteries included.\n\n- Uses [Lip Gloss][lipgloss] to style and colorize the output.\n- Colorful, human readable format.\n- Ability to customize the time stamp format.\n- Skips caller frames and marks function as helpers.\n- Leveled logging.\n- Text, JSON, and Logfmt formatters.\n- Store and retrieve logger in and from context.\n- Slog handler.\n- Standard log adapter.\n\n## Usage\n\nUse `go get` to download the dependency.\n\n```bash\ngo get github.com/charmbracelet/log@latest\n```\n\nThen, `import` it in your Go files:\n\n```go\nimport \"github.com/charmbracelet/log\"\n```\n\nThe Charm logger comes with a global package-wise logger with timestamps turned\non, and the logging level set to `info`.\n\n```go\nlog.Debug(\"Cookie üç™\") // won't print anything\nlog.Info(\"Hello World!\")\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"400\" srcset=\"https://vhs.charm.sh/vhs-cKiS8OuRrF1VVVpscM9e3.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"400\" srcset=\"https://vhs.charm.sh/vhs-cKiS8OuRrF1VVVpscM9e3.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"400\" srcset=\"https://vhs.charm.sh/vhs-4AeLaEuO3tDbECR1qe9Jvp.gif\"> -->\n    <img width=\"400\" src=\"https://vhs.charm.sh/vhs-4AeLaEuO3tDbECR1qe9Jvp.gif\" alt=\"Made with VHS\" />\n</picture>\n\nAll logging levels accept optional key/value pairs to be printed along with a\nmessage.\n\n```go\nerr := fmt.Errorf(\"too much sugar\")\nlog.Error(\"failed to bake cookies\", \"err\", err)\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"600\" srcset=\"https://vhs.charm.sh/vhs-65KIpGw4FTESK0IzkDB9VQ.gif\" >\n    <source media=\"(prefers-color-scheme: light)\" width=\"600\" srcset=\"https://vhs.charm.sh/vhs-65KIpGw4FTESK0IzkDB9VQ.gif\" >\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"600\" srcset=\"https://vhs.charm.sh/vhs-7rk8wALXRDoFw8SLFwn9rW.gif\"> -->\n    <img width=\"600\" src=\"https://vhs.charm.sh/vhs-65KIpGw4FTESK0IzkDB9VQ.gif\" alt=\"Made with VHS\">\n</picture>\n\nYou can use `log.Print()` to print messages without a level prefix.\n\n```go\nlog.Print(\"Baking 101\")\n// 2023/01/04 10:04:06 Baking 101\n```\n\n### New loggers\n\nUse `New()` to create new loggers.\n\n```go\nlogger := log.New(os.Stderr)\nif butter {\n    logger.Warn(\"chewy!\", \"butter\", true)\n}\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"300\" srcset=\"https://vhs.charm.sh/vhs-3QQdzOW4Zc0bN2tOhAest9.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"300\" srcset=\"https://vhs.charm.sh/vhs-3QQdzOW4Zc0bN2tOhAest9.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"300\" srcset=\"https://vhs.charm.sh/vhs-1nrhNSuFnQkxWD4RoMlE4O.gif\"> -->\n    <img width=\"300\" src=\"https://vhs.charm.sh/vhs-3QQdzOW4Zc0bN2tOhAest9.gif\">\n</picture>\n\n### Levels\n\nLog offers multiple levels to filter your logs on. Available levels are:\n\n```go\nlog.DebugLevel\nlog.InfoLevel\nlog.WarnLevel\nlog.ErrorLevel\nlog.FatalLevel\n```\n\nUse `log.SetLevel()` to set the log level. You can also create a new logger with\na specific log level using `log.Options{Level: }`.\n\nUse the corresponding function to log a message:\n\n```go\nerr := errors.New(\"Baking error 101\")\nlog.Debug(err)\nlog.Info(err)\nlog.Warn(err)\nlog.Error(err)\nlog.Fatal(err) // this calls os.Exit(1)\nlog.Print(err) // prints regardless of log level\n```\n\nOr use the formatter variant:\n\n```go\nformat := \"%s %d\"\nlog.Debugf(format, \"chocolate\", 10)\nlog.Warnf(format, \"adding more\", 5)\nlog.Errorf(format, \"increasing temp\", 420)\nlog.Fatalf(format, \"too hot!\", 500) // this calls os.Exit(1)\nlog.Printf(format, \"baking cookies\") // prints regardless of log level\n\n// Use these in conjunction with `With(...)` to add more context\nlog.With(\"err\", err).Errorf(\"unable to start %s\", \"oven\")\n```\n\n### Structured\n\nAll the functions above take a message and key-value pairs of anything. The\nmessage can also be of type any.\n\n```go\ningredients := []string{\"flour\", \"butter\", \"sugar\", \"chocolate\"}\nlog.Debug(\"Available ingredients\", \"ingredients\", ingredients)\n// DEBUG Available ingredients ingredients=\"[flour butter sugar chocolate]\"\n```\n\n### Options\n\nYou can customize the logger with options. Use `log.NewWithOptions()` and\n`log.Options{}` to customize your new logger.\n\n```go\nlogger := log.NewWithOptions(os.Stderr, log.Options{\n    ReportCaller: true,\n    ReportTimestamp: true,\n    TimeFormat: time.Kitchen,\n    Prefix: \"Baking üç™ \",\n})\nlogger.Info(\"Starting oven!\", \"degree\", 375)\ntime.Sleep(10 * time.Minute)\nlogger.Info(\"Finished baking\")\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-6oSCJcQ5EmFKKELcskJhLo.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-6oSCJcQ5EmFKKELcskJhLo.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-2X8Esd8ZsHo4DVPVgR36yx.gif\"> -->\n    <img width=\"700\" src=\"https://vhs.charm.sh/vhs-6oSCJcQ5EmFKKELcskJhLo.gif\">\n</picture>\n\nYou can also use logger setters to customize the logger.\n\n```go\nlogger := log.New(os.Stderr)\nlogger.SetReportTimestamp(false)\nlogger.SetReportCaller(false)\nlogger.SetLevel(log.DebugLevel)\n```\n\nUse `log.SetFormatter()` or `log.Options{Formatter: }` to change the output\nformat. Available options are:\n\n- `log.TextFormatter` (_default_)\n- `log.JSONFormatter`\n- `log.LogfmtFormatter`\n\n> **Note** styling only affects the `TextFormatter`. Styling is disabled if the\n> output is not a TTY.\n\nFor a list of available options, refer to [options.go](./options.go).\n\n### Styles\n\nYou can customize the logger styles using [Lipgloss][lipgloss]. The styles are\ndefined at a global level in [styles.go](./styles.go).\n\n```go\n// Override the default error level style.\nstyles := log.DefaultStyles()\nstyles.Levels[log.ErrorLevel] = lipgloss.NewStyle().\n\tSetString(\"ERROR!!\").\n\tPadding(0, 1, 0, 1).\n\tBackground(lipgloss.Color(\"204\")).\n\tForeground(lipgloss.Color(\"0\"))\n// Add a custom style for key `err`\nstyles.Keys[\"err\"] = lipgloss.NewStyle().Foreground(lipgloss.Color(\"204\"))\nstyles.Values[\"err\"] = lipgloss.NewStyle().Bold(true)\nlogger := log.New(os.Stderr)\nlogger.SetStyles(styles)\nlogger.Error(\"Whoops!\", \"err\", \"kitchen on fire\")\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"400\" srcset=\"https://vhs.charm.sh/vhs-4LXsGvzyH4RdjJaTF4a9MG.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"400\" srcset=\"https://vhs.charm.sh/vhs-4LXsGvzyH4RdjJaTF4a9MG.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"400\" srcset=\"https://vhs.charm.sh/vhs-4f6qLnIfudMMLDD9sxXUrv.gif\"> -->\n    <img width=\"400\" src=\"https://vhs.charm.sh/vhs-4LXsGvzyH4RdjJaTF4a9MG.gif\">\n</picture>\n\n### Sub-logger\n\nCreate sub-loggers with their specific fields.\n\n```go\nlogger := log.NewWithOptions(os.Stderr, log.Options{\n    Prefix: \"Baking üç™ \"\n})\nbatch2 := logger.With(\"batch\", 2, \"chocolateChips\", true)\nbatch2.Debug(\"Preparing batch 2...\")\nbatch2.Debug(\"Adding chocolate chips\")\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-1JgP5ZRL0oXVspeg50CczR.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-1JgP5ZRL0oXVspeg50CczR.gif\">\n    <img width=\"700\" src=\"https://vhs.charm.sh/vhs-1JgP5ZRL0oXVspeg50CczR.gif\">\n</picture>\n\n### Format Messages\n\nYou can use `fmt.Sprintf()` to format messages.\n\n```go\nfor item := 1; i <= 100; i++ {\n    log.Info(fmt.Sprintf(\"Baking %d/100...\", item))\n}\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"500\" srcset=\"https://vhs.charm.sh/vhs-4nX5I7qHT09aJ2gU7OaGV5.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"500\" srcset=\"https://vhs.charm.sh/vhs-4nX5I7qHT09aJ2gU7OaGV5.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"500\" srcset=\"https://vhs.charm.sh/vhs-4RHXd4JSucomcPqJGZTpKh.gif\"> -->\n    <img width=\"500\" src=\"https://vhs.charm.sh/vhs-4nX5I7qHT09aJ2gU7OaGV5.gif\">\n</picture>\n\nOr arguments:\n\n```go\nfor temp := 375; temp <= 400; temp++ {\n    log.Info(\"Increasing temperature\", \"degree\", fmt.Sprintf(\"%d¬∞F\", temp))\n}\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-79YvXcDOsqgHte3bv42UTr.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-79YvXcDOsqgHte3bv42UTr.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-4AvAnoA2S53QTOteX8krp4.gif\"> -->\n    <img width=\"700\" src=\"https://vhs.charm.sh/vhs-79YvXcDOsqgHte3bv42UTr.gif\">\n</picture>\n\n### Helper Functions\n\nSkip caller frames in helper functions. Similar to what you can do with\n`testing.TB().Helper()`.\n\n```go\nfunc startOven(degree int) {\n    log.Helper()\n    log.Info(\"Starting oven\", \"degree\", degree)\n}\n\nlog.SetReportCaller(true)\nstartOven(400) // INFO <cookies/oven.go:123> Starting oven degree=400\n```\n\n<picture>\n    <source media=\"(prefers-color-scheme: dark)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-6CeQGIV8Ovgr8GD0N6NgTq.gif\">\n    <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-6CeQGIV8Ovgr8GD0N6NgTq.gif\">\n    <!-- <source media=\"(prefers-color-scheme: light)\" width=\"700\" srcset=\"https://vhs.charm.sh/vhs-6DPg0bVL4K4TkfoHkAn2ap.gif\"> -->\n    <img width=\"700\" src=\"https://vhs.charm.sh/vhs-6CeQGIV8Ovgr8GD0N6NgTq.gif\">\n</picture>\n\nThis will use the _caller_ function (`startOven`) line number instead of the\nlogging function (`log.Info`) to report the source location.\n\n### Slog Handler\n\nYou can use Log as an [`log/slog`](https://pkg.go.dev/log/slog) handler. Just\npass a logger instance to Slog and you're good to go.\n\n```go\nhandler := log.New(os.Stderr)\nlogger := slog.New(handler)\nlogger.Error(\"meow?\")\n```\n\n### Standard Log Adapter\n\nSome Go libraries, especially the ones in the standard library, will only accept\nthe [standard logger][stdlog] interface. For instance, the HTTP Server from\n`net/http` will only take a `*log.Logger` for its `ErrorLog` field.\n\nFor this, you can use the standard log adapter, which simply wraps the logger in\na `*log.Logger` interface.\n\n```go\nlogger := log.NewWithOptions(os.Stderr, log.Options{Prefix: \"http\"})\nstdlog := logger.StandardLog(log.StandardLogOptions{\n    ForceLevel: log.ErrorLevel,\n})\ns := &http.Server{\n    Addr:     \":8080\",\n    Handler:  handler,\n    ErrorLog: stdlog,\n}\nstdlog.Printf(\"Failed to make bake request, %s\", fmt.Errorf(\"temperature is too low\"))\n// ERROR http: Failed to make bake request, temperature is too low\n```\n\n## Gum\n\n<img src=\"https://vhs.charm.sh/vhs-6jupuFM0s2fXiUrBE0I1vU.gif\" width=\"600\" alt=\"Running gum log with debug and error levels\" />\n\nLog integrates with [Gum][gum] to log messages to output. Use `gum log [flags]\n[message]` to handle logging in your shell scripts. See\n[charmbracelet/gum](https://github.com/charmbracelet/gum#log) for more\ninformation.\n\n[gum]: https://github.com/charmbracelet/gum\n[lipgloss]: https://github.com/charmbracelet/lipgloss\n[stdlog]: https://pkg.go.dev/log\n\n## License\n\n[MIT](https://github.com/charmbracelet/log/raw/master/LICENSE)\n\n---\n\nPart of [Charm](https://charm.sh).\n\n<a href=\"https://charm.sh/\"><img alt=\"the Charm logo\" src=\"https://stuff.charm.sh/charm-badge.jpg\" width=\"400\"></a>\n\nCharmÁÉ≠Áà±ÂºÄÊ∫ê ‚Ä¢ Charm loves open source ‚Ä¢ ŸÜÿ≠ŸÜŸè ŸÜÿ≠ÿ® ÿßŸÑŸÖÿµÿßÿØÿ± ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 0.6064453125,
          "content": "package log\n\nimport \"context\"\n\n// WithContext wraps the given logger in context.\nfunc WithContext(ctx context.Context, logger *Logger) context.Context {\n\treturn context.WithValue(ctx, ContextKey, logger)\n}\n\n// FromContext returns the logger from the given context.\n// This will return the default package logger if no logger\n// found in context.\nfunc FromContext(ctx context.Context) *Logger {\n\tif logger, ok := ctx.Value(ContextKey).(*Logger); ok {\n\t\treturn logger\n\t}\n\treturn Default()\n}\n\ntype contextKey struct{ string }\n\n// ContextKey is the key used to store the logger in context.\nvar ContextKey = contextKey{\"log\"}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 0.62890625,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestLogContext_empty(t *testing.T) {\n\trequire.Equal(t, Default(), FromContext(context.TODO()))\n}\n\nfunc TestLogContext_simple(t *testing.T) {\n\tl := New(io.Discard)\n\tctx := WithContext(context.Background(), l)\n\trequire.Equal(t, l, FromContext(ctx))\n}\n\nfunc TestLogContext_fields(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tl.SetLevel(DebugLevel)\n\tctx := WithContext(context.Background(), l.With(\"foo\", \"bar\"))\n\tl = FromContext(ctx)\n\trequire.NotNil(t, l)\n\tl.Debug(\"test\")\n\trequire.Equal(t, \"DEBU test foo=bar\\n\", buf.String())\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "formatter.go",
          "type": "blob",
          "size": 0.7197265625,
          "content": "package log\n\n// Formatter is a formatter for log messages.\ntype Formatter uint8\n\nconst (\n\t// TextFormatter is a formatter that formats log messages as text. Suitable for\n\t// console output and log files.\n\tTextFormatter Formatter = iota\n\t// JSONFormatter is a formatter that formats log messages as JSON.\n\tJSONFormatter\n\t// LogfmtFormatter is a formatter that formats log messages as logfmt.\n\tLogfmtFormatter\n)\n\nvar (\n\t// TimestampKey is the key for the timestamp.\n\tTimestampKey = \"time\"\n\t// MessageKey is the key for the message.\n\tMessageKey = \"msg\"\n\t// LevelKey is the key for the level.\n\tLevelKey = \"level\"\n\t// CallerKey is the key for the caller.\n\tCallerKey = \"caller\"\n\t// PrefixKey is the key for the prefix.\n\tPrefixKey = \"prefix\"\n)\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.7333984375,
          "content": "module github.com/charmbracelet/log\n\ngo 1.19\n\nrequire (\n\tgithub.com/charmbracelet/lipgloss v1.0.0\n\tgithub.com/go-logfmt/logfmt v0.6.0\n\tgithub.com/muesli/termenv v0.15.2\n\tgithub.com/stretchr/testify v1.10.0\n\tgolang.org/x/exp v0.0.0-20231006140011-7918f672742d\n)\n\nrequire (\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/charmbracelet/x/ansi v0.4.2 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgolang.org/x/sys v0.19.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.9375,
          "content": "github.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=\ngithub.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=\ngithub.com/charmbracelet/x/ansi v0.4.2 h1:0JM6Aj/g/KC154/gOP4vfxun0ff6itogDYk41kof+qk=\ngithub.com/charmbracelet/x/ansi v0.4.2/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-logfmt/logfmt v0.6.0 h1:wGYYu3uicYdqXVgoYbvnkrPVXkuLM1p1ifugDMEdRi4=\ngithub.com/go-logfmt/logfmt v0.6.0/go.mod h1:WYhtIu8zTZfxdn5+rREduYbwxfcBr/Vr6KEVveWlfTs=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=\ngithub.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngolang.org/x/exp v0.0.0-20231006140011-7918f672742d h1:jtJma62tbqLibJ5sFQz8bKtEM8rJBtfilJ2qTU199MI=\ngolang.org/x/exp v0.0.0-20231006140011-7918f672742d/go.mod h1:ldy0pHrwJyGW56pPQzzkH36rKxoZW1tw7ZJpeKx+hdo=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.19.0 h1:q5f1RH2jigJ1MoAWp2KTp3gm5zAGFUTarQZ5U386+4o=\ngolang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 2.75,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc (l *Logger) jsonFormatter(keyvals ...interface{}) {\n\tjw := &jsonWriter{w: &l.b}\n\tjw.start()\n\n\ti := 0\n\tfor i < len(keyvals) {\n\t\tswitch kv := keyvals[i].(type) {\n\t\tcase slogAttr:\n\t\t\tl.jsonFormatterRoot(jw, kv.Key, kv.Value)\n\t\t\ti++\n\t\tdefault:\n\t\t\tif i+1 < len(keyvals) {\n\t\t\t\tl.jsonFormatterRoot(jw, keyvals[i], keyvals[i+1])\n\t\t\t}\n\t\t\ti += 2\n\t\t}\n\t}\n\n\tjw.end()\n\tl.b.WriteRune('\\n')\n}\n\nfunc (l *Logger) jsonFormatterRoot(jw *jsonWriter, key, value any) {\n\tswitch key {\n\tcase TimestampKey:\n\t\tif t, ok := value.(time.Time); ok {\n\t\t\tjw.objectItem(TimestampKey, t.Format(l.timeFormat))\n\t\t}\n\tcase LevelKey:\n\t\tif level, ok := value.(Level); ok {\n\t\t\tjw.objectItem(LevelKey, level.String())\n\t\t}\n\tcase CallerKey:\n\t\tif caller, ok := value.(string); ok {\n\t\t\tjw.objectItem(CallerKey, caller)\n\t\t}\n\tcase PrefixKey:\n\t\tif prefix, ok := value.(string); ok {\n\t\t\tjw.objectItem(PrefixKey, prefix)\n\t\t}\n\tcase MessageKey:\n\t\tif msg := value; msg != nil {\n\t\t\tjw.objectItem(MessageKey, fmt.Sprint(msg))\n\t\t}\n\tdefault:\n\t\tl.jsonFormatterItem(jw, key, value)\n\t}\n}\n\nfunc (l *Logger) jsonFormatterItem(jw *jsonWriter, key, value any) {\n\tswitch k := key.(type) {\n\tcase fmt.Stringer:\n\t\tjw.objectKey(k.String())\n\tcase error:\n\t\tjw.objectKey(k.Error())\n\tdefault:\n\t\tjw.objectKey(fmt.Sprint(k))\n\t}\n\tswitch v := value.(type) {\n\tcase error:\n\t\tjw.objectValue(v.Error())\n\tcase slogLogValuer:\n\t\tl.writeSlogValue(jw, v.LogValue())\n\tcase slogValue:\n\t\tl.writeSlogValue(jw, v.Resolve())\n\tcase fmt.Stringer:\n\t\tjw.objectValue(v.String())\n\tdefault:\n\t\tjw.objectValue(v)\n\t}\n}\n\nfunc (l *Logger) writeSlogValue(jw *jsonWriter, v slogValue) {\n\tswitch v.Kind() {\n\tcase slogKindGroup:\n\t\tjw.start()\n\t\tfor _, attr := range v.Group() {\n\t\t\tl.jsonFormatterItem(jw, attr.Key, attr.Value)\n\t\t}\n\t\tjw.end()\n\tdefault:\n\t\tjw.objectValue(v.Any())\n\t}\n}\n\ntype jsonWriter struct {\n\tw *bytes.Buffer\n\td int\n}\n\nfunc (w *jsonWriter) start() {\n\tw.w.WriteRune('{')\n\tw.d = 0\n}\n\nfunc (w *jsonWriter) end() {\n\tw.w.WriteRune('}')\n}\n\nfunc (w *jsonWriter) objectItem(key string, value any) {\n\tw.objectKey(key)\n\tw.objectValue(value)\n}\n\nfunc (w *jsonWriter) objectKey(key string) {\n\tif w.d > 0 {\n\t\tw.w.WriteRune(',')\n\t}\n\tw.d++\n\n\tpos := w.w.Len()\n\terr := w.writeEncoded(key)\n\tif err != nil {\n\t\tw.w.Truncate(pos)\n\t\tw.w.WriteString(`\"invalid key\"`)\n\t}\n\tw.w.WriteRune(':')\n}\n\nfunc (w *jsonWriter) objectValue(value any) {\n\tpos := w.w.Len()\n\terr := w.writeEncoded(value)\n\tif err != nil {\n\t\tw.w.Truncate(pos)\n\t\tw.w.WriteString(`\"invalid value\"`)\n\t}\n}\n\nfunc (w *jsonWriter) writeEncoded(v any) error {\n\te := json.NewEncoder(w.w)\n\te.SetEscapeHTML(false)\n\tif err := e.Encode(v); err != nil {\n\t\treturn err\n\t}\n\n\t// trailing \\n added by json.Encode\n\tb := w.w.Bytes()\n\tif len(b) > 0 && b[len(b)-1] == '\\n' {\n\t\tw.w.Truncate(w.w.Len() - 1)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 7.283203125,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestJson(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tl.SetFormatter(JSONFormatter)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\t\tf        func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"default logger info with timestamp\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\"}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"default logger debug with timestamp\",\n\t\t\texpected: \"\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Debug,\n\t\t},\n\t\t{\n\t\t\tname:     \"default logger error with timestamp\",\n\t\t\texpected: \"{\\\"level\\\":\\\"error\\\",\\\"msg\\\":\\\"info\\\"}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiline message\",\n\t\t\texpected: \"{\\\"level\\\":\\\"error\\\",\\\"msg\\\":\\\"info\\\\ninfo\\\"}\\n\",\n\t\t\tmsg:      \"info\\ninfo\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiline kvs\",\n\t\t\texpected: \"{\\\"level\\\":\\\"error\\\",\\\"msg\\\":\\\"info\\\",\\\"multiline\\\":\\\"info\\\\ninfo\\\"}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"multiline\", \"info\\ninfo\"},\n\t\t\tf:        l.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"odd number of kvs\",\n\t\t\texpected: \"{\\\"level\\\":\\\"error\\\",\\\"msg\\\":\\\"info\\\",\\\"foo\\\":\\\"bar\\\",\\\"baz\\\":\\\"missing value\\\"}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", \"bar\", \"baz\"},\n\t\t\tf:        l.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"error field\",\n\t\t\texpected: \"{\\\"level\\\":\\\"error\\\",\\\"msg\\\":\\\"info\\\",\\\"error\\\":\\\"error message\\\"}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"error\", errors.New(\"error message\")},\n\t\t\tf:        l.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"struct field\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\",\\\"struct\\\":{}}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"struct\", struct{ foo string }{foo: \"bar\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice field\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\",\\\"slice\\\":[1,2,3]}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"slice\", []int{1, 2, 3}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of structs\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\",\\\"slice\\\":[{},{}]}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"slice\", []struct{ foo string }{{foo: \"bar\"}, {foo: \"baz\"}}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of strings\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\",\\\"slice\\\":[\\\"foo\\\",\\\"bar\\\"]}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"slice\", []string{\"foo\", \"bar\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of errors\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\",\\\"slice\\\":[{},{}]}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"slice\", []error{errors.New(\"error message1\"), errors.New(\"error message2\")}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"map of strings\",\n\t\t\texpected: \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\",\\\"map\\\":{\\\"a\\\":\\\"b\\\",\\\"foo\\\":\\\"bar\\\"}}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"map\", map[string]string{\"a\": \"b\", \"foo\": \"bar\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\trequire.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestJsonCaller(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tl.SetFormatter(JSONFormatter)\n\tl.SetReportCaller(true)\n\tl.SetLevel(DebugLevel)\n\t_, file, line, _ := runtime.Caller(0)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\n\t\tf func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"simple caller\",\n\t\t\texpected: fmt.Sprintf(\"{\\\"level\\\":\\\"info\\\",\\\"caller\\\":\\\"log/%s:%d\\\",\\\"msg\\\":\\\"info\\\"}\\n\", filepath.Base(file), line+30),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"nested caller\",\n\t\t\texpected: fmt.Sprintf(\"{\\\"level\\\":\\\"info\\\",\\\"caller\\\":\\\"log/%s:%d\\\",\\\"msg\\\":\\\"info\\\"}\\n\", filepath.Base(file), line+30),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf: func(msg interface{}, kvs ...interface{}) {\n\t\t\t\tl.Helper()\n\t\t\t\tl.Info(msg, kvs...)\n\t\t\t},\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\trequire.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestJsonTime(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetTimeFunction(_zeroTime)\n\tlogger.SetFormatter(JSONFormatter)\n\tlogger.SetReportTimestamp(true)\n\tlogger.Info(\"info\")\n\trequire.Equal(t, \"{\\\"time\\\":\\\"0002/01/01 00:00:00\\\",\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\"}\\n\", buf.String())\n}\n\nfunc TestJsonPrefix(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetFormatter(JSONFormatter)\n\tlogger.SetPrefix(\"my-prefix\")\n\tlogger.Info(\"info\")\n\trequire.Equal(t, \"{\\\"level\\\":\\\"info\\\",\\\"prefix\\\":\\\"my-prefix\\\",\\\"msg\\\":\\\"info\\\"}\\n\", buf.String())\n}\n\nfunc TestJsonCustomKey(t *testing.T) {\n\tvar buf bytes.Buffer\n\toldTsKey := TimestampKey\n\tdefer func() {\n\t\tTimestampKey = oldTsKey\n\t}()\n\tTimestampKey = \"other-time\"\n\tlogger := New(&buf)\n\tlogger.SetTimeFunction(_zeroTime)\n\tlogger.SetFormatter(JSONFormatter)\n\tlogger.SetReportTimestamp(true)\n\tlogger.Info(\"info\")\n\trequire.Equal(t, \"{\\\"other-time\\\":\\\"0002/01/01 00:00:00\\\",\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\"}\\n\", buf.String())\n}\n\nfunc TestJsonWriter(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tfn       func(w *jsonWriter)\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"string\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", \"value\")\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\t\"int\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", 123)\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":123}`,\n\t\t},\n\t\t{\n\t\t\t\"bytes\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"b\", []byte{0x0, 0x1})\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"b\":\"AAE=\"}`,\n\t\t},\n\t\t{\n\t\t\t\"no fields\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{}`,\n\t\t},\n\t\t{\n\t\t\t\"multiple in asc order\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", \"value\")\n\t\t\t\tw.objectItem(\"b\", \"some-other\")\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":\"value\",\"b\":\"some-other\"}`,\n\t\t},\n\t\t{\n\t\t\t\"multiple in desc order\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"b\", \"some-other\")\n\t\t\t\tw.objectItem(\"a\", \"value\")\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"b\":\"some-other\",\"a\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\t\"depth\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", map[string]int{\"b\": 123})\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":{\"b\":123}}`,\n\t\t},\n\t\t{\n\t\t\t\"key contains reserved\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a:\\\"b\", \"value\")\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a:\\\"b\":\"value\"}`,\n\t\t},\n\t\t{\n\t\t\t\"pointer\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", ptr(\"pointer\"))\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":\"pointer\"}`,\n\t\t},\n\t\t{\n\t\t\t\"double-pointer\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", ptr(ptr(\"pointer\")))\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":\"pointer\"}`,\n\t\t},\n\t\t{\n\t\t\t\"invalid\",\n\t\t\tfunc(w *jsonWriter) {\n\t\t\t\tw.start()\n\t\t\t\tw.objectItem(\"a\", invalidJSON{})\n\t\t\t\tw.end()\n\t\t\t},\n\t\t\t`{\"a\":\"invalid value\"}`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\ttc.fn(&jsonWriter{w: &buf})\n\t\t\trequire.Equal(t, tc.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc ptr[T any](v T) *T {\n\treturn &v\n}\n\ntype invalidJSON struct{}\n\nfunc (invalidJSON) MarshalJSON() ([]byte, error) {\n\treturn nil, errors.New(\"invalid json error\")\n}\n"
        },
        {
          "name": "level.go",
          "type": "blob",
          "size": 1.3515625,
          "content": "package log\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\n// Level is a logging level.\ntype Level int\n\nconst (\n\t// DebugLevel is the debug level.\n\tDebugLevel Level = -4\n\t// InfoLevel is the info level.\n\tInfoLevel Level = 0\n\t// WarnLevel is the warn level.\n\tWarnLevel Level = 4\n\t// ErrorLevel is the error level.\n\tErrorLevel Level = 8\n\t// FatalLevel is the fatal level.\n\tFatalLevel Level = 12\n\t// noLevel is used with log.Print.\n\tnoLevel Level = math.MaxInt\n)\n\n// String returns the string representation of the level.\nfunc (l Level) String() string {\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"debug\"\n\tcase InfoLevel:\n\t\treturn \"info\"\n\tcase WarnLevel:\n\t\treturn \"warn\"\n\tcase ErrorLevel:\n\t\treturn \"error\"\n\tcase FatalLevel:\n\t\treturn \"fatal\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// ErrInvalidLevel is an error returned when parsing an invalid level string.\nvar ErrInvalidLevel = errors.New(\"invalid level\")\n\n// ParseLevel converts level in string to Level type. Default level is InfoLevel.\nfunc ParseLevel(level string) (Level, error) {\n\tswitch strings.ToLower(level) {\n\tcase DebugLevel.String():\n\t\treturn DebugLevel, nil\n\tcase InfoLevel.String():\n\t\treturn InfoLevel, nil\n\tcase WarnLevel.String():\n\t\treturn WarnLevel, nil\n\tcase ErrorLevel.String():\n\t\treturn ErrorLevel, nil\n\tcase FatalLevel.String():\n\t\treturn FatalLevel, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"%w: %q\", ErrInvalidLevel, level)\n\t}\n}\n"
        },
        {
          "name": "level_test.go",
          "type": "blob",
          "size": 1.2705078125,
          "content": "package log\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDefaultLevel(t *testing.T) {\n\tvar level Level\n\tassert.Equal(t, InfoLevel, level)\n}\n\nfunc TestParseLevel(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected Level\n\t\terror    error\n\t}{\n\t\t{\n\t\t\tname:     \"Parse debug\",\n\t\t\tinput:    \"debug\",\n\t\t\texpected: DebugLevel,\n\t\t\terror:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Parse info\",\n\t\t\tinput:    \"Info\",\n\t\t\texpected: InfoLevel,\n\t\t\terror:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Parse warn\",\n\t\t\tinput:    \"WARN\",\n\t\t\texpected: WarnLevel,\n\t\t\terror:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Parse error\",\n\t\t\tinput:    \"error\",\n\t\t\texpected: ErrorLevel,\n\t\t\terror:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Parse fatal\",\n\t\t\tinput:    \"FATAL\",\n\t\t\texpected: FatalLevel,\n\t\t\terror:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Default\",\n\t\t\tinput:    \"\",\n\t\t\texpected: InfoLevel,\n\t\t\terror:    fmt.Errorf(\"%w: %q\", ErrInvalidLevel, \"\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"Wrong level, set INFO\",\n\t\t\tinput:    \"WRONG_LEVEL\",\n\t\t\texpected: InfoLevel,\n\t\t\terror:    fmt.Errorf(\"%w: %q\", ErrInvalidLevel, \"WRONG_LEVEL\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tlvl, err := ParseLevel(tc.input)\n\t\t\tassert.Equal(t, tc.expected, lvl)\n\t\t\tassert.Equal(t, tc.error, err)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "logfmt.go",
          "type": "blob",
          "size": 0.7158203125,
          "content": "package log\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/go-logfmt/logfmt\"\n)\n\nfunc (l *Logger) logfmtFormatter(keyvals ...interface{}) {\n\te := logfmt.NewEncoder(&l.b)\n\n\tfor i := 0; i < len(keyvals); i += 2 {\n\t\tswitch keyvals[i] {\n\t\tcase TimestampKey:\n\t\t\tif t, ok := keyvals[i+1].(time.Time); ok {\n\t\t\t\tkeyvals[i+1] = t.Format(l.timeFormat)\n\t\t\t}\n\t\tdefault:\n\t\t\tif key := fmt.Sprint(keyvals[i]); key != \"\" {\n\t\t\t\tkeyvals[i] = key\n\t\t\t}\n\t\t}\n\t\terr := e.EncodeKeyval(keyvals[i], keyvals[i+1])\n\t\tif err != nil && errors.Is(err, logfmt.ErrUnsupportedValueType) {\n\t\t\t// If the value is not supported by logfmt, we try to convert it to a string.\n\t\t\t_ = e.EncodeKeyval(keyvals[i], fmt.Sprintf(\"%+v\", keyvals[i+1]))\n\t\t}\n\t}\n\t_ = e.EndRecord()\n}\n"
        },
        {
          "name": "logfmt_test.go",
          "type": "blob",
          "size": 3.171875,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLogfmt(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tl.SetFormatter(LogfmtFormatter)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\t\tf        func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"simple\",\n\t\t\texpected: \"level=info msg=info\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"ignored message\",\n\t\t\texpected: \"\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Debug,\n\t\t},\n\t\t{\n\t\t\tname:     \"message with keyvals\",\n\t\t\texpected: \"level=info msg=info foo=bar\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", \"bar\"},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"message with multiline keyvals\",\n\t\t\texpected: \"level=info msg=info foo=\\\"bar\\\\nbaz\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", \"bar\\nbaz\"},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiline message\",\n\t\t\texpected: \"level=info msg=\\\"info\\\\nfoo\\\"\\n\",\n\t\t\tmsg:      \"info\\nfoo\",\n\t\t\tkvs:      nil,\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"message with error\",\n\t\t\texpected: \"level=info msg=info err=\\\"foo: bar\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"err\", errors.New(\"foo: bar\")},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"odd number of keyvals\",\n\t\t\texpected: \"level=info msg=info foo=bar baz=\\\"missing value\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", \"bar\", \"baz\"},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"struct field\",\n\t\t\texpected: \"level=info msg=info foo=\\\"{bar:foo bar}\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", struct{ bar string }{\"foo bar\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"multiple struct fields\",\n\t\t\texpected: \"level=info msg=info foo={bar:baz} foo2={bar:baz}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", struct{ bar string }{\"baz\"}, \"foo2\", struct{ bar string }{\"baz\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of structs\",\n\t\t\texpected: \"level=info msg=info foo=\\\"[{bar:baz} {bar:baz}]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", []struct{ bar string }{{\"baz\"}, {\"baz\"}}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of strings\",\n\t\t\texpected: \"level=info msg=info foo=\\\"[bar baz]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", []string{\"bar\", \"baz\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of errors\",\n\t\t\texpected: \"level=info msg=info foo=\\\"[error1 error2]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", []error{errors.New(\"error1\"), errors.New(\"error2\")}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"map of strings\",\n\t\t\texpected: \"level=info msg=info foo=map[bar:baz]\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", map[string]string{\"bar\": \"baz\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"map with interface\",\n\t\t\texpected: \"level=info msg=info foo=map[bar:baz]\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"foo\", map[string]interface{}{\"bar\": \"baz\"}},\n\t\t\tf:        l.Info,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 9.564453125,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/muesli/termenv\"\n)\n\n// ErrMissingValue is returned when a key is missing a value.\nvar ErrMissingValue = fmt.Errorf(\"missing value\")\n\n// LoggerOption is an option for a logger.\ntype LoggerOption = func(*Logger)\n\n// Logger is a Logger that implements Logger.\ntype Logger struct {\n\tw  io.Writer\n\tb  bytes.Buffer\n\tmu *sync.RWMutex\n\tre *lipgloss.Renderer\n\n\tisDiscard uint32\n\n\tlevel           int64\n\tprefix          string\n\ttimeFunc        TimeFunction\n\ttimeFormat      string\n\tcallerOffset    int\n\tcallerFormatter CallerFormatter\n\tformatter       Formatter\n\n\treportCaller    bool\n\treportTimestamp bool\n\n\tfields []interface{}\n\n\thelpers *sync.Map\n\tstyles  *Styles\n}\n\n// Logf logs a message with formatting.\nfunc (l *Logger) Logf(level Level, format string, args ...interface{}) {\n\tl.Log(level, fmt.Sprintf(format, args...))\n}\n\n// Log logs the given message with the given keyvals for the given level.\nfunc (l *Logger) Log(level Level, msg interface{}, keyvals ...interface{}) {\n\tif atomic.LoadUint32(&l.isDiscard) != 0 {\n\t\treturn\n\t}\n\n\t// check if the level is allowed\n\tif atomic.LoadInt64(&l.level) > int64(level) {\n\t\treturn\n\t}\n\n\tvar frame runtime.Frame\n\tif l.reportCaller {\n\t\t// Skip log.log, the caller, and any offset added.\n\t\tframes := l.frames(l.callerOffset + 2)\n\t\tfor {\n\t\t\tf, more := frames.Next()\n\t\t\t_, helper := l.helpers.Load(f.Function)\n\t\t\tif !helper || !more {\n\t\t\t\t// Found a frame that wasn't a helper function.\n\t\t\t\t// Or we ran out of frames to check.\n\t\t\t\tframe = f\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tl.handle(level, l.timeFunc(time.Now()), []runtime.Frame{frame}, msg, keyvals...)\n}\n\nfunc (l *Logger) handle(level Level, ts time.Time, frames []runtime.Frame, msg interface{}, keyvals ...interface{}) {\n\tvar kvs []interface{}\n\tif l.reportTimestamp && !ts.IsZero() {\n\t\tkvs = append(kvs, TimestampKey, ts)\n\t}\n\n\t_, ok := l.styles.Levels[level]\n\tif ok {\n\t\tkvs = append(kvs, LevelKey, level)\n\t}\n\n\tif l.reportCaller && len(frames) > 0 && frames[0].PC != 0 {\n\t\tfile, line, fn := l.location(frames)\n\t\tif file != \"\" {\n\t\t\tcaller := l.callerFormatter(file, line, fn)\n\t\t\tkvs = append(kvs, CallerKey, caller)\n\t\t}\n\t}\n\n\tif l.prefix != \"\" {\n\t\tkvs = append(kvs, PrefixKey, l.prefix)\n\t}\n\n\tif msg != nil {\n\t\tif m := fmt.Sprint(msg); m != \"\" {\n\t\t\tkvs = append(kvs, MessageKey, m)\n\t\t}\n\t}\n\n\t// append logger fields\n\tkvs = append(kvs, l.fields...)\n\tif len(l.fields)%2 != 0 {\n\t\tkvs = append(kvs, ErrMissingValue)\n\t}\n\n\t// append the rest\n\tkvs = append(kvs, keyvals...)\n\tif len(keyvals)%2 != 0 {\n\t\tkvs = append(kvs, ErrMissingValue)\n\t}\n\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tswitch l.formatter {\n\tcase LogfmtFormatter:\n\t\tl.logfmtFormatter(kvs...)\n\tcase JSONFormatter:\n\t\tl.jsonFormatter(kvs...)\n\tdefault:\n\t\tl.textFormatter(kvs...)\n\t}\n\n\t// WriteTo will reset the buffer\n\tl.b.WriteTo(l.w) //nolint: errcheck\n}\n\n// Helper marks the calling function as a helper\n// and skips it for source location information.\n// It's the equivalent of testing.TB.Helper().\nfunc (l *Logger) Helper() {\n\tl.helper(1)\n}\n\nfunc (l *Logger) helper(skip int) {\n\tvar pcs [1]uintptr\n\t// Skip runtime.Callers, and l.helper\n\tn := runtime.Callers(skip+2, pcs[:])\n\tframes := runtime.CallersFrames(pcs[:n])\n\tframe, _ := frames.Next()\n\tl.helpers.LoadOrStore(frame.Function, struct{}{})\n}\n\n// frames returns the runtime.Frames for the caller.\nfunc (l *Logger) frames(skip int) *runtime.Frames {\n\t// Copied from testing.T\n\tconst maxStackLen = 50\n\tvar pc [maxStackLen]uintptr\n\n\t// Skip runtime.Callers, and l.frame\n\tn := runtime.Callers(skip+2, pc[:])\n\tframes := runtime.CallersFrames(pc[:n])\n\treturn frames\n}\n\nfunc (l *Logger) location(frames []runtime.Frame) (file string, line int, fn string) {\n\tif len(frames) == 0 {\n\t\treturn \"\", 0, \"\"\n\t}\n\tf := frames[0]\n\treturn f.File, f.Line, f.Function\n}\n\n// Cleanup a path by returning the last n segments of the path only.\nfunc trimCallerPath(path string, n int) string {\n\t// lovely borrowed from zap\n\t// nb. To make sure we trim the path correctly on Windows too, we\n\t// counter-intuitively need to use '/' and *not* os.PathSeparator here,\n\t// because the path given originates from Go stdlib, specifically\n\t// runtime.Caller() which (as of Mar/17) returns forward slashes even on\n\t// Windows.\n\t//\n\t// See https://github.com/golang/go/issues/3335\n\t// and https://github.com/golang/go/issues/18151\n\t//\n\t// for discussion on the issue on Go side.\n\n\t// Return the full path if n is 0.\n\tif n <= 0 {\n\t\treturn path\n\t}\n\n\t// Find the last separator.\n\tidx := strings.LastIndexByte(path, '/')\n\tif idx == -1 {\n\t\treturn path\n\t}\n\n\tfor i := 0; i < n-1; i++ {\n\t\t// Find the penultimate separator.\n\t\tidx = strings.LastIndexByte(path[:idx], '/')\n\t\tif idx == -1 {\n\t\t\treturn path\n\t\t}\n\t}\n\n\treturn path[idx+1:]\n}\n\n// SetReportTimestamp sets whether the timestamp should be reported.\nfunc (l *Logger) SetReportTimestamp(report bool) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.reportTimestamp = report\n}\n\n// SetReportCaller sets whether the caller location should be reported.\nfunc (l *Logger) SetReportCaller(report bool) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.reportCaller = report\n}\n\n// GetLevel returns the current level.\nfunc (l *Logger) GetLevel() Level {\n\tl.mu.RLock()\n\tdefer l.mu.RUnlock()\n\treturn Level(l.level)\n}\n\n// SetLevel sets the current level.\nfunc (l *Logger) SetLevel(level Level) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tatomic.StoreInt64(&l.level, int64(level))\n}\n\n// GetPrefix returns the current prefix.\nfunc (l *Logger) GetPrefix() string {\n\tl.mu.RLock()\n\tdefer l.mu.RUnlock()\n\treturn l.prefix\n}\n\n// SetPrefix sets the current prefix.\nfunc (l *Logger) SetPrefix(prefix string) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.prefix = prefix\n}\n\n// SetTimeFormat sets the time format.\nfunc (l *Logger) SetTimeFormat(format string) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.timeFormat = format\n}\n\n// SetTimeFunction sets the time function.\nfunc (l *Logger) SetTimeFunction(f TimeFunction) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.timeFunc = f\n}\n\n// SetOutput sets the output destination.\nfunc (l *Logger) SetOutput(w io.Writer) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tif w == nil {\n\t\tw = os.Stderr\n\t}\n\tl.w = w\n\tvar isDiscard uint32\n\tif w == io.Discard {\n\t\tisDiscard = 1\n\t}\n\tatomic.StoreUint32(&l.isDiscard, isDiscard)\n\t// Reuse cached renderers\n\tif v, ok := registry.Load(w); ok {\n\t\tl.re = v.(*lipgloss.Renderer)\n\t} else {\n\t\tl.re = lipgloss.NewRenderer(w, termenv.WithColorCache(true))\n\t\tregistry.Store(w, l.re)\n\t}\n}\n\n// SetFormatter sets the formatter.\nfunc (l *Logger) SetFormatter(f Formatter) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.formatter = f\n}\n\n// SetCallerFormatter sets the caller formatter.\nfunc (l *Logger) SetCallerFormatter(f CallerFormatter) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.callerFormatter = f\n}\n\n// SetCallerOffset sets the caller offset.\nfunc (l *Logger) SetCallerOffset(offset int) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.callerOffset = offset\n}\n\n// SetColorProfile force sets the underlying Lip Gloss renderer color profile\n// for the TextFormatter.\nfunc (l *Logger) SetColorProfile(profile termenv.Profile) {\n\tl.re.SetColorProfile(profile)\n}\n\n// SetStyles sets the logger styles for the TextFormatter.\nfunc (l *Logger) SetStyles(s *Styles) {\n\tif s == nil {\n\t\ts = DefaultStyles()\n\t}\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tl.styles = s\n}\n\n// With returns a new logger with the given keyvals added.\nfunc (l *Logger) With(keyvals ...interface{}) *Logger {\n\tvar st Styles\n\tl.mu.Lock()\n\tsl := *l\n\tst = *l.styles\n\tl.mu.Unlock()\n\tsl.b = bytes.Buffer{}\n\tsl.mu = &sync.RWMutex{}\n\tsl.helpers = &sync.Map{}\n\tsl.fields = append(make([]interface{}, 0, len(l.fields)+len(keyvals)), l.fields...)\n\tsl.fields = append(sl.fields, keyvals...)\n\tsl.styles = &st\n\treturn &sl\n}\n\n// WithPrefix returns a new logger with the given prefix.\nfunc (l *Logger) WithPrefix(prefix string) *Logger {\n\tsl := l.With()\n\tsl.SetPrefix(prefix)\n\treturn sl\n}\n\n// Debug prints a debug message.\nfunc (l *Logger) Debug(msg interface{}, keyvals ...interface{}) {\n\tl.Log(DebugLevel, msg, keyvals...)\n}\n\n// Info prints an info message.\nfunc (l *Logger) Info(msg interface{}, keyvals ...interface{}) {\n\tl.Log(InfoLevel, msg, keyvals...)\n}\n\n// Warn prints a warning message.\nfunc (l *Logger) Warn(msg interface{}, keyvals ...interface{}) {\n\tl.Log(WarnLevel, msg, keyvals...)\n}\n\n// Error prints an error message.\nfunc (l *Logger) Error(msg interface{}, keyvals ...interface{}) {\n\tl.Log(ErrorLevel, msg, keyvals...)\n}\n\n// Fatal prints a fatal message and exits.\nfunc (l *Logger) Fatal(msg interface{}, keyvals ...interface{}) {\n\tl.Log(FatalLevel, msg, keyvals...)\n\tos.Exit(1)\n}\n\n// Print prints a message with no level.\nfunc (l *Logger) Print(msg interface{}, keyvals ...interface{}) {\n\tl.Log(noLevel, msg, keyvals...)\n}\n\n// Debugf prints a debug message with formatting.\nfunc (l *Logger) Debugf(format string, args ...interface{}) {\n\tl.Log(DebugLevel, fmt.Sprintf(format, args...))\n}\n\n// Infof prints an info message with formatting.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.Log(InfoLevel, fmt.Sprintf(format, args...))\n}\n\n// Warnf prints a warning message with formatting.\nfunc (l *Logger) Warnf(format string, args ...interface{}) {\n\tl.Log(WarnLevel, fmt.Sprintf(format, args...))\n}\n\n// Errorf prints an error message with formatting.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.Log(ErrorLevel, fmt.Sprintf(format, args...))\n}\n\n// Fatalf prints a fatal message with formatting and exits.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.Log(FatalLevel, fmt.Sprintf(format, args...))\n\tos.Exit(1)\n}\n\n// Printf prints a message with no level and formatting.\nfunc (l *Logger) Printf(format string, args ...interface{}) {\n\tl.Log(noLevel, fmt.Sprintf(format, args...))\n}\n"
        },
        {
          "name": "logger_121.go",
          "type": "blob",
          "size": 1.73046875,
          "content": "//go:build go1.21\n// +build go1.21\n\npackage log\n\nimport (\n\t\"context\"\n\t\"log/slog\"\n\t\"runtime\"\n\t\"sync/atomic\"\n)\n\n// type aliases for slog.\ntype (\n\tslogAttr      = slog.Attr\n\tslogValue     = slog.Value\n\tslogLogValuer = slog.LogValuer\n)\n\nconst slogKindGroup = slog.KindGroup\n\n// Enabled reports whether the logger is enabled for the given level.\n//\n// Implements slog.Handler.\nfunc (l *Logger) Enabled(_ context.Context, level slog.Level) bool {\n\treturn atomic.LoadInt64(&l.level) <= int64(level)\n}\n\n// Handle handles the Record. It will only be called if Enabled returns true.\n//\n// Implements slog.Handler.\nfunc (l *Logger) Handle(ctx context.Context, record slog.Record) error {\n\tif !l.Enabled(ctx, record.Level) {\n\t\treturn nil\n\t}\n\n\tfields := make([]interface{}, 0, record.NumAttrs()*2)\n\trecord.Attrs(func(a slog.Attr) bool {\n\t\tfields = append(fields, a.Key, a.Value)\n\t\treturn true\n\t})\n\t// Get the caller frame using the record's PC.\n\tframes := runtime.CallersFrames([]uintptr{record.PC})\n\tframe, _ := frames.Next()\n\tl.handle(Level(record.Level), l.timeFunc(record.Time), []runtime.Frame{frame}, record.Message, fields...)\n\treturn nil\n}\n\n// WithAttrs returns a new Handler with the given attributes added.\n//\n// Implements slog.Handler.\nfunc (l *Logger) WithAttrs(attrs []slog.Attr) slog.Handler {\n\tfields := make([]interface{}, 0, len(attrs)*2)\n\tfor _, attr := range attrs {\n\t\tfields = append(fields, attr.Key, attr.Value)\n\t}\n\treturn l.With(fields...)\n}\n\n// WithGroup returns a new Handler with the given group name prepended to the\n// current group name or prefix.\n//\n// Implements slog.Handler.\nfunc (l *Logger) WithGroup(name string) slog.Handler {\n\tif l.prefix != \"\" {\n\t\tname = l.prefix + \".\" + name\n\t}\n\treturn l.WithPrefix(name)\n}\n\nvar _ slog.Handler = (*Logger)(nil)\n"
        },
        {
          "name": "logger_121_test.go",
          "type": "blob",
          "size": 5.8154296875,
          "content": "//go:build go1.21\n// +build go1.21\n\npackage log\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"log/slog\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSlogSimple(t *testing.T) {\n\tvar buf bytes.Buffer\n\th := New(&buf)\n\th.SetLevel(DebugLevel)\n\tl := slog.New(h)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tattrs    []any\n\t\tprint    func(string, ...any)\n\t}{\n\t\t{\n\t\t\tname:     \"slog debug\",\n\t\t\texpected: \"DEBU slog debug\\n\",\n\t\t\tmsg:      \"slog debug\",\n\t\t\tprint:    l.Debug,\n\t\t\tattrs:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"slog info\",\n\t\t\texpected: \"INFO slog info\\n\",\n\t\t\tmsg:      \"slog info\",\n\t\t\tprint:    l.Info,\n\t\t\tattrs:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"slog warn\",\n\t\t\texpected: \"WARN slog warn\\n\",\n\t\t\tmsg:      \"slog warn\",\n\t\t\tprint:    l.Warn,\n\t\t\tattrs:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"slog error\",\n\t\t\texpected: \"ERRO slog error\\n\",\n\t\t\tmsg:      \"slog error\",\n\t\t\tprint:    l.Error,\n\t\t\tattrs:    nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"slog error attrs\",\n\t\t\texpected: \"ERRO slog error foo=bar\\n\",\n\t\t\tmsg:      \"slog error\",\n\t\t\tprint:    l.Error,\n\t\t\tattrs:    []any{\"foo\", \"bar\"},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.print(c.msg, c.attrs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestSlogWith(t *testing.T) {\n\tvar buf bytes.Buffer\n\th := New(&buf)\n\th.SetLevel(DebugLevel)\n\tl := slog.New(h).With(\"a\", \"b\")\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tattrs    []any\n\t\tprint    func(string, ...any)\n\t}{\n\t\t{\n\t\t\tname:     \"slog debug\",\n\t\t\texpected: \"DEBU slog debug a=b foo=bar\\n\",\n\t\t\tmsg:      \"slog debug\",\n\t\t\tprint:    l.Debug,\n\t\t\tattrs:    []any{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"slog info\",\n\t\t\texpected: \"INFO slog info a=b foo=bar\\n\",\n\t\t\tmsg:      \"slog info\",\n\t\t\tprint:    l.Info,\n\t\t\tattrs:    []any{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"slog warn\",\n\t\t\texpected: \"WARN slog warn a=b foo=bar\\n\",\n\t\t\tmsg:      \"slog warn\",\n\t\t\tprint:    l.Warn,\n\t\t\tattrs:    []any{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"slog error\",\n\t\t\texpected: \"ERRO slog error a=b foo=bar\\n\",\n\t\t\tmsg:      \"slog error\",\n\t\t\tprint:    l.Error,\n\t\t\tattrs:    []any{\"foo\", \"bar\"},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.print(c.msg, c.attrs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestSlogWithGroup(t *testing.T) {\n\tvar buf bytes.Buffer\n\th := New(&buf)\n\tl := slog.New(h).WithGroup(\"charm\").WithGroup(\"bracelet\")\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t}{\n\t\t{\n\t\t\tname:     \"simple\",\n\t\t\tmsg:      \"message\",\n\t\t\texpected: \"INFO charm.bracelet: message\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"empty\",\n\t\t\tmsg:      \"\",\n\t\t\texpected: \"INFO charm.bracelet:\\n\",\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl.Info(c.msg)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestSlogCustomLevel(t *testing.T) {\n\tvar buf bytes.Buffer\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tlevel    slog.Level\n\t\tminLevel Level\n\t}{\n\t\t{\n\t\t\tname:     \"custom level not enabled\",\n\t\t\texpected: \"\",\n\t\t\tlevel:    slog.Level(500),\n\t\t\tminLevel: Level(600),\n\t\t},\n\t\t{\n\t\t\tname:     \"custom level enabled\",\n\t\t\texpected: \"foo\\n\",\n\t\t\tlevel:    slog.Level(500),\n\t\t\tminLevel: Level(100),\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl := New(&buf)\n\t\t\tl.SetLevel(c.minLevel)\n\t\t\tl.Handle(context.Background(), slog.NewRecord(time.Now(), c.level, \"foo\", 0))\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\ntype testLogValue struct {\n\tv slog.Value\n}\n\nfunc (v testLogValue) LogValue() slog.Value {\n\treturn v.v\n}\n\nfunc TestSlogAttr(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tkvs      []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"any\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"any\":42}` + \"\\n\",\n\t\t\tkvs:      []any{\"any\", slog.AnyValue(42)},\n\t\t},\n\t\t{\n\t\t\tname:     \"bool\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"bool\":false}` + \"\\n\",\n\t\t\tkvs:      []any{\"bool\", slog.BoolValue(false)},\n\t\t},\n\t\t{\n\t\t\tname:     \"duration\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"duration\":10800000000000}` + \"\\n\",\n\t\t\tkvs:      []any{\"duration\", slog.DurationValue(3 * time.Hour)},\n\t\t},\n\t\t{\n\t\t\tname:     \"float64\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"float64\":123}` + \"\\n\",\n\t\t\tkvs:      []any{\"float64\", slog.Float64Value(123)},\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"string\":\"hello\"}` + \"\\n\",\n\t\t\tkvs:      []any{\"string\", slog.StringValue(\"hello\")},\n\t\t},\n\t\t{\n\t\t\tname:     \"time\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"_time\":\"1970-01-01T00:00:00Z\"}` + \"\\n\",\n\t\t\tkvs:      []any{\"_time\", slog.TimeValue(time.Unix(0, 0).UTC())},\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"uint64\":42}` + \"\\n\",\n\t\t\tkvs:      []any{\"uint64\", slog.Uint64Value(42)},\n\t\t},\n\t\t{\n\t\t\tname:     \"group\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"g\":{\"b\":true}}` + \"\\n\",\n\t\t\tkvs:      []any{slog.Group(\"g\", slog.Bool(\"b\", true))},\n\t\t},\n\t\t{\n\t\t\tname:     \"log valuer\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"lv\":42}` + \"\\n\",\n\t\t\tkvs: []any{\n\t\t\t\t\"lv\", testLogValue{slog.AnyValue(42)},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"log valuer\",\n\t\t\texpected: `{\"level\":\"info\",\"msg\":\"message\",\"lv\":{\"first\":\"hello\",\"last\":\"world\"}}` + \"\\n\",\n\t\t\tkvs: []any{\n\t\t\t\t\"lv\", testLogValue{slog.GroupValue(\n\t\t\t\t\tslog.String(\"first\", \"hello\"),\n\t\t\t\t\tslog.String(\"last\", \"world\"),\n\t\t\t\t)},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tc := c\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// expect same output from slog and log\n\t\t\tvar buf bytes.Buffer\n\t\t\tl := NewWithOptions(&buf, Options{Formatter: JSONFormatter})\n\t\t\tl.Info(\"message\", c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\n\t\t\tbuf.Truncate(0)\n\t\t\tsl := slog.New(l)\n\t\t\tsl.Info(\"message\", c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "logger_no121.go",
          "type": "blob",
          "size": 1.69140625,
          "content": "//go:build !go1.21\n// +build !go1.21\n\npackage log\n\nimport (\n\t\"context\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\n\t\"golang.org/x/exp/slog\"\n)\n\n// type alises for slog.\ntype (\n\tslogAttr      = slog.Attr\n\tslogValue     = slog.Value\n\tslogLogValuer = slog.LogValuer\n)\n\nconst slogKindGroup = slog.KindGroup\n\n// Enabled reports whether the logger is enabled for the given level.\n//\n// Implements slog.Handler.\nfunc (l *Logger) Enabled(_ context.Context, level slog.Level) bool {\n\treturn atomic.LoadInt64(&l.level) <= int64(level)\n}\n\n// Handle handles the Record. It will only be called if Enabled returns true.\n//\n// Implements slog.Handler.\nfunc (l *Logger) Handle(_ context.Context, record slog.Record) error {\n\tfields := make([]interface{}, 0, record.NumAttrs()*2)\n\trecord.Attrs(func(a slog.Attr) bool {\n\t\tfields = append(fields, a.Key, a.Value)\n\t\treturn true\n\t})\n\t// Get the caller frame using the record's PC.\n\tframes := runtime.CallersFrames([]uintptr{record.PC})\n\tframe, _ := frames.Next()\n\tl.handle(Level(record.Level), l.timeFunc(record.Time), []runtime.Frame{frame}, record.Message, fields...)\n\treturn nil\n}\n\n// WithAttrs returns a new Handler with the given attributes added.\n//\n// Implements slog.Handler.\nfunc (l *Logger) WithAttrs(attrs []slog.Attr) slog.Handler {\n\tfields := make([]interface{}, 0, len(attrs)*2)\n\tfor _, attr := range attrs {\n\t\tfields = append(fields, attr.Key, attr.Value)\n\t}\n\treturn l.With(fields...)\n}\n\n// WithGroup returns a new Handler with the given group name prepended to the\n// current group name or prefix.\n//\n// Implements slog.Handler.\nfunc (l *Logger) WithGroup(name string) slog.Handler {\n\tif l.prefix != \"\" {\n\t\tname = l.prefix + \".\" + name\n\t}\n\treturn l.WithPrefix(name)\n}\n\nvar _ slog.Handler = (*Logger)(nil)\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 5.4013671875,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSubLogger(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tfields   []interface{}\n\t\tkvs      []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"sub logger nil fields\",\n\t\t\texpected: \"INFO info\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tfields:   nil,\n\t\t\tkvs:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"sub logger info\",\n\t\t\texpected: \"INFO info foo=bar\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tfields:   []interface{}{\"foo\", \"bar\"},\n\t\t\tkvs:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"sub logger info with kvs\",\n\t\t\texpected: \"INFO info foo=bar foobar=baz\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tfields:   []interface{}{\"foo\", \"bar\"},\n\t\t\tkvs:      []interface{}{\"foobar\", \"baz\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"emoji\",\n\t\t\texpected: \"INFO üëç üê±\\n\",\n\t\t\tmsg:      \"üëç üê±\",\n\t\t\tfields:   nil,\n\t\t\tkvs:      nil,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl.With(c.fields...).Info(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestWrongLevel(t *testing.T) {\n\tvar buf bytes.Buffer\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tlevel    Level\n\t}{\n\t\t{\n\t\t\tname:     \"wrong level\",\n\t\t\texpected: \"\",\n\t\t\tlevel:    Level(999),\n\t\t},\n\t\t{\n\t\t\tname:     \"wrong level negative\",\n\t\t\texpected: \"INFO info\\n\",\n\t\t\tlevel:    Level(-999),\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tbuf.Reset()\n\t\t\tl := New(&buf)\n\t\t\tl.SetLevel(c.level)\n\t\t\tl.Info(\"info\")\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestLogFormatter(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tl.SetLevel(DebugLevel)\n\tcases := []struct {\n\t\tname     string\n\t\tformat   string\n\t\targs     []interface{}\n\t\tfun      func(string, ...interface{})\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"info format\",\n\t\t\tformat:   \"%s %s\",\n\t\t\targs:     []interface{}{\"foo\", \"bar\"},\n\t\t\tfun:      l.Infof,\n\t\t\texpected: \"INFO foo bar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"debug format\",\n\t\t\tformat:   \"%s %s\",\n\t\t\targs:     []interface{}{\"foo\", \"bar\"},\n\t\t\tfun:      l.Debugf,\n\t\t\texpected: \"DEBU foo bar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"warn format\",\n\t\t\tformat:   \"%s %s\",\n\t\t\targs:     []interface{}{\"foo\", \"bar\"},\n\t\t\tfun:      l.Warnf,\n\t\t\texpected: \"WARN foo bar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"error format\",\n\t\t\tformat:   \"%s %s\",\n\t\t\targs:     []interface{}{\"foo\", \"bar\"},\n\t\t\tfun:      l.Errorf,\n\t\t\texpected: \"ERRO foo bar\\n\",\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tbuf.Reset()\n\t\t\tc.fun(c.format, \"foo\", \"bar\")\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestEmptyMessage(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tfields   []interface{}\n\t\tkvs      []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"empty message nil fields\",\n\t\t\texpected: \"INFO\\n\",\n\t\t\tmsg:      \"\",\n\t\t\tfields:   nil,\n\t\t\tkvs:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty message with fields\",\n\t\t\texpected: \"INFO foo=bar\\n\",\n\t\t\tmsg:      \"\",\n\t\t\tfields:   []interface{}{\"foo\", \"bar\"},\n\t\t\tkvs:      nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty message with fields & kvs\",\n\t\t\texpected: \"INFO foo=bar foobar=baz\\n\",\n\t\t\tmsg:      \"\",\n\t\t\tfields:   []interface{}{\"foo\", \"bar\"},\n\t\t\tkvs:      []interface{}{\"foobar\", \"baz\"},\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl.With(c.fields...).Info(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestLogWithPrefix(t *testing.T) {\n\tvar buf bytes.Buffer\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tprefix   string\n\t\tmsg      string\n\t}{\n\t\t{\n\t\t\tname:     \"with prefix\",\n\t\t\texpected: \"INFO prefix: info\\n\",\n\t\t\tprefix:   \"prefix\",\n\t\t\tmsg:      \"info\",\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tbuf.Reset()\n\t\t\tl := New(&buf)\n\t\t\tl.SetPrefix(c.prefix)\n\t\t\tl.Info(c.msg)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestLogWithRaceCondition(t *testing.T) {\n\tw := io.Discard\n\tcases := []struct {\n\t\tname string\n\t}{\n\t\t{\n\t\t\tname: \"must be run with -race\",\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl := New(w)\n\n\t\t\tvar done sync.WaitGroup\n\n\t\t\tlongArgs := make([]interface{}, 0, 1000)\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tlongArgs = append(longArgs, fmt.Sprintf(\"arg%d\", i), fmt.Sprintf(\"val%d\", i))\n\t\t\t}\n\t\t\tl = l.With(longArgs...)\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tdone.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\tll := l.With(\"arg1\", \"val1\", \"arg2\", \"val2\")\n\t\t\t\t\tll.Info(\"kinda long long log message\")\n\t\t\t\t\tdone.Done()\n\t\t\t\t}()\n\n\t\t\t\tdone.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\tl.Info(\"kinda long log message\")\n\t\t\t\t\tdone.Done()\n\t\t\t\t}()\n\t\t\t}\n\t\t\tdone.Wait()\n\t\t})\n\t}\n}\n\nfunc TestRace(t *testing.T) {\n\tt.Parallel()\n\n\tw := io.Discard\n\tl := New(w)\n\tfor i := 0; i < 100; i++ {\n\t\tt.Run(\"race\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ts := l.StandardLog()\n\t\t\tl.Info(\"foo\")\n\t\t\tl.GetLevel()\n\t\t\tl.Print(\"foo\")\n\n\t\t\ts.Print(\"foo\")\n\t\t\ts.Writer().Write([]byte(\"bar\"))\n\t\t\ts.Output(1, \"baz\")\n\n\t\t\tl.SetOutput(w)\n\t\t\tl.Debug(\"foo\")\n\t\t\tl.SetLevel(InfoLevel)\n\t\t\tl.GetPrefix()\n\n\t\t\to := l.With(\"foo\", \"bar\")\n\t\t\to.Printf(\"foo %s\", \"bar\")\n\t\t\to.SetTimeFormat(time.Kitchen)\n\t\t\to.Warn(\"foo\")\n\t\t\to.SetOutput(w)\n\t\t\to.Error(\"foo\")\n\t\t\to.SetFormatter(JSONFormatter)\n\t\t})\n\t}\n}\n\nfunc TestCustomLevel(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlevel500 := Level(500)\n\tl := New(&buf)\n\tl.SetLevel(level500)\n\tl.Logf(level500, \"foo\")\n\tassert.Equal(t, \"foo\\n\", buf.String())\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 2.0439453125,
          "content": "package log\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// DefaultTimeFormat is the default time format.\nconst DefaultTimeFormat = \"2006/01/02 15:04:05\"\n\n// TimeFunction is a function that returns a time.Time.\ntype TimeFunction = func(time.Time) time.Time\n\n// NowUTC is a convenient function that returns the\n// current time in UTC timezone.\n//\n// This is to be used as a time function.\n// For example:\n//\n//\tlog.SetTimeFunction(log.NowUTC)\nfunc NowUTC(t time.Time) time.Time {\n\treturn t.UTC()\n}\n\n// CallerFormatter is the caller formatter.\ntype CallerFormatter func(string, int, string) string\n\n// ShortCallerFormatter is a caller formatter that returns the last 2 levels of the path\n// and line number.\nfunc ShortCallerFormatter(file string, line int, _ string) string {\n\treturn fmt.Sprintf(\"%s:%d\", trimCallerPath(file, 2), line)\n}\n\n// LongCallerFormatter is a caller formatter that returns the full path and line number.\nfunc LongCallerFormatter(file string, line int, _ string) string {\n\treturn fmt.Sprintf(\"%s:%d\", file, line)\n}\n\n// Options is the options for the logger.\ntype Options struct {\n\t// TimeFunction is the time function for the logger. The default is time.Now.\n\tTimeFunction TimeFunction\n\t// TimeFormat is the time format for the logger. The default is \"2006/01/02 15:04:05\".\n\tTimeFormat string\n\t// Level is the level for the logger. The default is InfoLevel.\n\tLevel Level\n\t// Prefix is the prefix for the logger. The default is no prefix.\n\tPrefix string\n\t// ReportTimestamp is whether the logger should report the timestamp. The default is false.\n\tReportTimestamp bool\n\t// ReportCaller is whether the logger should report the caller location. The default is false.\n\tReportCaller bool\n\t// CallerFormatter is the caller format for the logger. The default is ShortCallerFormatter.\n\tCallerFormatter CallerFormatter\n\t// CallerOffset is the caller format for the logger. The default is 0.\n\tCallerOffset int\n\t// Fields is the fields for the logger. The default is no fields.\n\tFields []interface{}\n\t// Formatter is the formatter for the logger. The default is TextFormatter.\n\tFormatter Formatter\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 1.8046875,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestOptions(t *testing.T) {\n\topts := Options{\n\t\tLevel:        ErrorLevel,\n\t\tReportCaller: true,\n\t\tFields:       []interface{}{\"foo\", \"bar\"},\n\t}\n\tlogger := NewWithOptions(io.Discard, opts)\n\trequire.Equal(t, ErrorLevel, logger.GetLevel())\n\trequire.True(t, logger.reportCaller)\n\trequire.False(t, logger.reportTimestamp)\n\trequire.Equal(t, []interface{}{\"foo\", \"bar\"}, logger.fields)\n\trequire.Equal(t, TextFormatter, logger.formatter)\n\trequire.Equal(t, DefaultTimeFormat, logger.timeFormat)\n\trequire.NotNil(t, logger.timeFunc)\n}\n\nfunc TestCallerFormatter(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := NewWithOptions(&buf, Options{ReportCaller: true})\n\tframes := l.frames(0)\n\tframe, _ := frames.Next()\n\tfile, line, fn := frame.File, frame.Line, frame.Function\n\thi := func() { l.Info(\"hi\") }\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tformat   CallerFormatter\n\t}{\n\t\t{\n\t\t\tname:     \"short caller formatter\",\n\t\t\texpected: fmt.Sprintf(\"INFO <log/options_test.go:%d> hi\\n\", line+3),\n\t\t\tformat:   ShortCallerFormatter,\n\t\t},\n\t\t{\n\t\t\tname:     \"long caller formatter\",\n\t\t\texpected: fmt.Sprintf(\"INFO <%s:%d> hi\\n\", file, line+3),\n\t\t\tformat:   LongCallerFormatter,\n\t\t},\n\t\t{\n\t\t\tname:     \"foo caller formatter\",\n\t\t\texpected: \"INFO <foo> hi\\n\",\n\t\t\tformat: func(file string, line int, fn string) string {\n\t\t\t\treturn \"foo\"\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"custom caller formatter\",\n\t\t\texpected: fmt.Sprintf(\"INFO <%s:%d:%s.func1> hi\\n\", file, line+3, fn),\n\t\t\tformat: func(file string, line int, fn string) string {\n\t\t\t\treturn fmt.Sprintf(\"%s:%d:%s\", file, line, fn)\n\t\t\t},\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tbuf.Reset()\n\t\t\tl.callerFormatter = c.format\n\t\t\thi()\n\t\t\trequire.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "pkg.go",
          "type": "blob",
          "size": 6.25390625,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/muesli/termenv\"\n)\n\nvar (\n\t// registry is a map of all registered lipgloss renderers.\n\tregistry = sync.Map{}\n\n\t// defaultLogger is the default global logger instance.\n\tdefaultLogger     atomic.Pointer[Logger]\n\tdefaultLoggerOnce sync.Once\n)\n\n// Default returns the default logger. The default logger comes with timestamp enabled.\nfunc Default() *Logger {\n\tdl := defaultLogger.Load()\n\tif dl == nil {\n\t\tdefaultLoggerOnce.Do(func() {\n\t\t\tdefaultLogger.CompareAndSwap(\n\t\t\t\tnil, NewWithOptions(os.Stderr, Options{ReportTimestamp: true}),\n\t\t\t)\n\t\t})\n\t\tdl = defaultLogger.Load()\n\t}\n\treturn dl\n}\n\n// SetDefault sets the default global logger.\nfunc SetDefault(logger *Logger) {\n\tdefaultLogger.Store(logger)\n}\n\n// New returns a new logger with the default options.\nfunc New(w io.Writer) *Logger {\n\treturn NewWithOptions(w, Options{})\n}\n\n// NewWithOptions returns a new logger using the provided options.\nfunc NewWithOptions(w io.Writer, o Options) *Logger {\n\tl := &Logger{\n\t\tb:               bytes.Buffer{},\n\t\tmu:              &sync.RWMutex{},\n\t\thelpers:         &sync.Map{},\n\t\tlevel:           int64(o.Level),\n\t\treportTimestamp: o.ReportTimestamp,\n\t\treportCaller:    o.ReportCaller,\n\t\tprefix:          o.Prefix,\n\t\ttimeFunc:        o.TimeFunction,\n\t\ttimeFormat:      o.TimeFormat,\n\t\tformatter:       o.Formatter,\n\t\tfields:          o.Fields,\n\t\tcallerFormatter: o.CallerFormatter,\n\t\tcallerOffset:    o.CallerOffset,\n\t}\n\n\tl.SetOutput(w)\n\tl.SetLevel(Level(l.level))\n\tl.SetStyles(DefaultStyles())\n\n\tif l.callerFormatter == nil {\n\t\tl.callerFormatter = ShortCallerFormatter\n\t}\n\n\tif l.timeFunc == nil {\n\t\tl.timeFunc = func(t time.Time) time.Time { return t }\n\t}\n\n\tif l.timeFormat == \"\" {\n\t\tl.timeFormat = DefaultTimeFormat\n\t}\n\n\treturn l\n}\n\n// SetReportTimestamp sets whether to report timestamp for the default logger.\nfunc SetReportTimestamp(report bool) {\n\tDefault().SetReportTimestamp(report)\n}\n\n// SetReportCaller sets whether to report caller location for the default logger.\nfunc SetReportCaller(report bool) {\n\tDefault().SetReportCaller(report)\n}\n\n// SetLevel sets the level for the default logger.\nfunc SetLevel(level Level) {\n\tDefault().SetLevel(level)\n}\n\n// GetLevel returns the level for the default logger.\nfunc GetLevel() Level {\n\treturn Default().GetLevel()\n}\n\n// SetTimeFormat sets the time format for the default logger.\nfunc SetTimeFormat(format string) {\n\tDefault().SetTimeFormat(format)\n}\n\n// SetTimeFunction sets the time function for the default logger.\nfunc SetTimeFunction(f TimeFunction) {\n\tDefault().SetTimeFunction(f)\n}\n\n// SetOutput sets the output for the default logger.\nfunc SetOutput(w io.Writer) {\n\tDefault().SetOutput(w)\n}\n\n// SetFormatter sets the formatter for the default logger.\nfunc SetFormatter(f Formatter) {\n\tDefault().SetFormatter(f)\n}\n\n// SetCallerFormatter sets the caller formatter for the default logger.\nfunc SetCallerFormatter(f CallerFormatter) {\n\tDefault().SetCallerFormatter(f)\n}\n\n// SetCallerOffset sets the caller offset for the default logger.\nfunc SetCallerOffset(offset int) {\n\tDefault().SetCallerOffset(offset)\n}\n\n// SetPrefix sets the prefix for the default logger.\nfunc SetPrefix(prefix string) {\n\tDefault().SetPrefix(prefix)\n}\n\n// SetColorProfile force sets the underlying Lip Gloss renderer color profile\n// for the TextFormatter.\nfunc SetColorProfile(profile termenv.Profile) {\n\tDefault().SetColorProfile(profile)\n}\n\n// SetStyles sets the logger styles for the TextFormatter.\nfunc SetStyles(s *Styles) {\n\tDefault().SetStyles(s)\n}\n\n// GetPrefix returns the prefix for the default logger.\nfunc GetPrefix() string {\n\treturn Default().GetPrefix()\n}\n\n// With returns a new logger with the given keyvals.\nfunc With(keyvals ...interface{}) *Logger {\n\treturn Default().With(keyvals...)\n}\n\n// WithPrefix returns a new logger with the given prefix.\nfunc WithPrefix(prefix string) *Logger {\n\treturn Default().WithPrefix(prefix)\n}\n\n// Helper marks the calling function as a helper\n// and skips it for source location information.\n// It's the equivalent of testing.TB.Helper().\nfunc Helper() {\n\tDefault().helper(1)\n}\n\n// Log logs a message with the given level.\nfunc Log(level Level, msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(level, msg, keyvals...)\n}\n\n// Debug logs a debug message.\nfunc Debug(msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(DebugLevel, msg, keyvals...)\n}\n\n// Info logs an info message.\nfunc Info(msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(InfoLevel, msg, keyvals...)\n}\n\n// Warn logs a warning message.\nfunc Warn(msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(WarnLevel, msg, keyvals...)\n}\n\n// Error logs an error message.\nfunc Error(msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(ErrorLevel, msg, keyvals...)\n}\n\n// Fatal logs a fatal message and exit.\nfunc Fatal(msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(FatalLevel, msg, keyvals...)\n\tos.Exit(1)\n}\n\n// Print logs a message with no level.\nfunc Print(msg interface{}, keyvals ...interface{}) {\n\tDefault().Log(noLevel, msg, keyvals...)\n}\n\n// Logf logs a message with formatting and level.\nfunc Logf(level Level, format string, args ...interface{}) {\n\tDefault().Logf(level, format, args...)\n}\n\n// Debugf logs a debug message with formatting.\nfunc Debugf(format string, args ...interface{}) {\n\tDefault().Log(DebugLevel, fmt.Sprintf(format, args...))\n}\n\n// Infof logs an info message with formatting.\nfunc Infof(format string, args ...interface{}) {\n\tDefault().Log(InfoLevel, fmt.Sprintf(format, args...))\n}\n\n// Warnf logs a warning message with formatting.\nfunc Warnf(format string, args ...interface{}) {\n\tDefault().Log(WarnLevel, fmt.Sprintf(format, args...))\n}\n\n// Errorf logs an error message with formatting.\nfunc Errorf(format string, args ...interface{}) {\n\tDefault().Log(ErrorLevel, fmt.Sprintf(format, args...))\n}\n\n// Fatalf logs a fatal message with formatting and exit.\nfunc Fatalf(format string, args ...interface{}) {\n\tDefault().Log(FatalLevel, fmt.Sprintf(format, args...))\n\tos.Exit(1)\n}\n\n// Printf logs a message with formatting and no level.\nfunc Printf(format string, args ...interface{}) {\n\tDefault().Log(noLevel, fmt.Sprintf(format, args...))\n}\n\n// StandardLog returns a standard logger from the default logger.\nfunc StandardLog(opts ...StandardLogOptions) *log.Logger {\n\treturn Default().StandardLog(opts...)\n}\n"
        },
        {
          "name": "pkg_test.go",
          "type": "blob",
          "size": 5.3330078125,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/muesli/termenv\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDefaultRace(t *testing.T) {\n\tl := Default()\n\tt.Cleanup(func() {\n\t\tSetDefault(l)\n\t})\n\n\tfor i := 0; i < 2; i++ {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tSetDefault(New(io.Discard))\n\t\t\tDefault().Info(\"foo\")\n\t\t})\n\t}\n}\n\nfunc TestGlobal(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetTimeFunction(_zeroTime)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\t\tf        func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"default logger info with timestamp\",\n\t\t\texpected: \"0002/01/01 00:00:00 INFO info\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"default logger debug with timestamp\",\n\t\t\texpected: \"\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        Debug,\n\t\t},\n\t\t{\n\t\t\tname:     \"default logger error with timestamp\",\n\t\t\texpected: \"0002/01/01 00:00:00 ERRO info\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        Error,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestPrint(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(FatalLevel)\n\tSetTimeFunction(_zeroTime)\n\tSetReportTimestamp(true)\n\tSetReportCaller(false)\n\tSetTimeFormat(DefaultTimeFormat)\n\tSetColorProfile(termenv.ANSI)\n\tError(\"error\")\n\tPrint(\"print\")\n\tassert.Equal(t, \"0002/01/01 00:00:00 print\\n\", buf.String())\n}\n\nfunc TestPrintf(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(FatalLevel)\n\tSetTimeFunction(_zeroTime)\n\tSetReportTimestamp(true)\n\tSetReportCaller(false)\n\tSetTimeFormat(DefaultTimeFormat)\n\tErrorf(\"error\")\n\tPrintf(\"print\")\n\tassert.Equal(t, \"0002/01/01 00:00:00 print\\n\", buf.String())\n}\n\nfunc TestFatal(t *testing.T) {\n\tSetReportTimestamp(true)\n\tSetReportCaller(false)\n\tSetTimeFormat(DefaultTimeFormat)\n\tif os.Getenv(\"FATAL\") == \"1\" {\n\t\tFatal(\"i'm dead\")\n\t\treturn\n\t}\n\tcmd := exec.Command(os.Args[0], \"-test.run=TestFatal\")\n\tcmd.Env = append(os.Environ(), \"FATAL=1\")\n\terr := cmd.Run()\n\tif e, ok := err.(*exec.ExitError); ok && !e.Success() {\n\t\treturn\n\t}\n\tt.Fatalf(\"process ran with err %v, want exit status 1\", err)\n}\n\nfunc TestFatalf(t *testing.T) {\n\tSetReportTimestamp(true)\n\tSetReportCaller(false)\n\tSetTimeFormat(DefaultTimeFormat)\n\tif os.Getenv(\"FATAL\") == \"1\" {\n\t\tFatalf(\"i'm %s\", \"dead\")\n\t\treturn\n\t}\n\tcmd := exec.Command(os.Args[0], \"-test.run=TestFatalf\")\n\tcmd.Env = append(os.Environ(), \"FATAL=1\")\n\terr := cmd.Run()\n\tif e, ok := err.(*exec.ExitError); ok && !e.Success() {\n\t\treturn\n\t}\n\tt.Fatalf(\"process ran with err %v, want exit status 1\", err)\n}\n\nfunc TestDebugf(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(DebugLevel)\n\tSetTimeFunction(_zeroTime)\n\tSetReportTimestamp(true)\n\tSetReportCaller(true)\n\tSetTimeFormat(DefaultTimeFormat)\n\t_, file, line, _ := runtime.Caller(0)\n\tDebugf(\"debug %s\", \"foo\")\n\tassert.Equal(t, fmt.Sprintf(\"0002/01/01 00:00:00 DEBU <log/%s:%d> debug foo\\n\", filepath.Base(file), line+1), buf.String())\n}\n\nfunc TestInfof(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(InfoLevel)\n\tSetReportTimestamp(false)\n\tSetReportCaller(false)\n\tSetTimeFormat(DefaultTimeFormat)\n\tInfof(\"info %s\", \"foo\")\n\tassert.Equal(t, \"INFO info foo\\n\", buf.String())\n}\n\nfunc TestWarnf(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(WarnLevel)\n\tSetReportCaller(false)\n\tSetReportTimestamp(true)\n\tSetTimeFunction(_zeroTime)\n\tSetTimeFormat(DefaultTimeFormat)\n\tWarnf(\"warn %s\", \"foo\")\n\tassert.Equal(t, \"0002/01/01 00:00:00 WARN warn foo\\n\", buf.String())\n}\n\nfunc TestErrorf(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(ErrorLevel)\n\tSetReportCaller(false)\n\tSetReportTimestamp(true)\n\tSetTimeFunction(_zeroTime)\n\tSetTimeFormat(time.Kitchen)\n\tErrorf(\"error %s\", \"foo\")\n\tassert.Equal(t, \"12:00AM ERRO error foo\\n\", buf.String())\n}\n\nfunc TestWith(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(InfoLevel)\n\tSetReportCaller(false)\n\tSetReportTimestamp(true)\n\tSetTimeFunction(_zeroTime)\n\tSetTimeFormat(DefaultTimeFormat)\n\tWith(\"foo\", \"bar\").Info(\"info\")\n\tassert.Equal(t, \"0002/01/01 00:00:00 INFO info foo=bar\\n\", buf.String())\n}\n\nfunc TestGetLevel(t *testing.T) {\n\tSetLevel(InfoLevel)\n\tassert.Equal(t, InfoLevel, GetLevel())\n}\n\nfunc TestPrefix(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(WarnLevel)\n\tSetReportCaller(false)\n\tSetReportTimestamp(false)\n\tSetPrefix(\"prefix\")\n\tWarn(\"info\")\n\tassert.Equal(t, \"WARN prefix: info\\n\", buf.String())\n\tassert.Equal(t, \"prefix\", GetPrefix())\n\tSetPrefix(\"\")\n}\n\nfunc TestFormatter(t *testing.T) {\n\tvar buf bytes.Buffer\n\tSetOutput(&buf)\n\tSetLevel(InfoLevel)\n\tSetReportCaller(false)\n\tSetReportTimestamp(false)\n\tSetFormatter(JSONFormatter)\n\tInfo(\"info\")\n\tassert.Equal(t, \"{\\\"level\\\":\\\"info\\\",\\\"msg\\\":\\\"info\\\"}\\n\", buf.String())\n}\n\nfunc TestWithPrefix(t *testing.T) {\n\tl := WithPrefix(\"test\")\n\tassert.Equal(t, \"test\", l.prefix)\n}\n\nfunc TestGlobalCustomLevel(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlvl := Level(-1)\n\tSetOutput(&buf)\n\tSetLevel(lvl)\n\tSetReportCaller(false)\n\tSetReportTimestamp(false)\n\tSetFormatter(JSONFormatter)\n\tLog(lvl, \"info\")\n\tLogf(lvl, \"hey %s\", \"you\")\n\tassert.Equal(t, \"{\\\"msg\\\":\\\"info\\\"}\\n{\\\"msg\\\":\\\"hey you\\\"}\\n\", buf.String())\n}\n"
        },
        {
          "name": "stdlog.go",
          "type": "blob",
          "size": 1.462890625,
          "content": "package log\n\nimport (\n\t\"log\"\n\t\"strings\"\n)\n\ntype stdLogWriter struct {\n\tl   *Logger\n\topt *StandardLogOptions\n}\n\nfunc (l *stdLogWriter) Write(p []byte) (n int, err error) {\n\tstr := strings.TrimSuffix(string(p), \"\\n\")\n\n\tif l.opt != nil {\n\t\tswitch l.opt.ForceLevel {\n\t\tcase DebugLevel:\n\t\t\tl.l.Debug(str)\n\t\tcase InfoLevel:\n\t\t\tl.l.Info(str)\n\t\tcase WarnLevel:\n\t\t\tl.l.Warn(str)\n\t\tcase ErrorLevel:\n\t\t\tl.l.Error(str)\n\t\t}\n\t} else {\n\t\tswitch {\n\t\tcase strings.HasPrefix(str, \"DEBUG\"):\n\t\t\tl.l.Debug(strings.TrimSpace(str[5:]))\n\t\tcase strings.HasPrefix(str, \"INFO\"):\n\t\t\tl.l.Info(strings.TrimSpace(str[4:]))\n\t\tcase strings.HasPrefix(str, \"WARN\"):\n\t\t\tl.l.Warn(strings.TrimSpace(str[4:]))\n\t\tcase strings.HasPrefix(str, \"ERROR\"):\n\t\t\tl.l.Error(strings.TrimSpace(str[5:]))\n\t\tcase strings.HasPrefix(str, \"ERR\"):\n\t\t\tl.l.Error(strings.TrimSpace(str[3:]))\n\t\tdefault:\n\t\t\tl.l.Info(str)\n\t\t}\n\t}\n\n\treturn len(p), nil\n}\n\n// StandardLogOptions can be used to configure the standard log adapter.\ntype StandardLogOptions struct {\n\tForceLevel Level\n}\n\n// StandardLog returns a standard logger from Logger. The returned logger\n// can infer log levels from message prefix. Expected prefixes are DEBUG, INFO,\n// WARN, ERROR, and ERR.\nfunc (l *Logger) StandardLog(opts ...StandardLogOptions) *log.Logger {\n\tnl := l.With()\n\t// The caller stack is\n\t// log.Printf() -> l.Output() -> l.out.Write(stdLogger.Write)\n\tnl.callerOffset += 3\n\tsl := &stdLogWriter{\n\t\tl: nl,\n\t}\n\tif len(opts) > 0 {\n\t\tsl.opt = &opts[0]\n\t}\n\treturn log.New(sl, \"\", 0)\n}\n"
        },
        {
          "name": "stdlog_test.go",
          "type": "blob",
          "size": 2.33984375,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestStdLog(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tcases := []struct {\n\t\tf        func(l *log.Logger)\n\t\tname     string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"simple\",\n\t\t\texpected: \"INFO info\\n\",\n\t\t\tf:        func(l *log.Logger) { l.Print(\"info\") },\n\t\t},\n\t\t{\n\t\t\tname:     \"without level\",\n\t\t\texpected: \"INFO coffee\\n\",\n\t\t\tf:        func(l *log.Logger) { l.Print(\"coffee\") },\n\t\t},\n\t\t{\n\t\t\tname:     \"error level\",\n\t\t\texpected: \"ERRO coffee\\n\",\n\t\t\tf:        func(l *log.Logger) { l.Print(\"ERROR coffee\") },\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl.SetOutput(&buf)\n\t\t\tl.SetTimeFunction(_zeroTime)\n\t\t\tc.f(l.StandardLog())\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestStdLog_forceLevel(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tlevel    Level\n\t}{\n\t\t{\n\t\t\tname:     \"debug\",\n\t\t\texpected: \"\",\n\t\t\tlevel:    DebugLevel,\n\t\t},\n\t\t{\n\t\t\tname:     \"info\",\n\t\t\texpected: \"INFO coffee\\n\",\n\t\t\tlevel:    InfoLevel,\n\t\t},\n\t\t{\n\t\t\tname:     \"error\",\n\t\t\texpected: \"ERRO coffee\\n\",\n\t\t\tlevel:    ErrorLevel,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl := logger.StandardLog(StandardLogOptions{ForceLevel: c.level})\n\t\t\tl.Print(\"coffee\")\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestStdLog_writer(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetReportCaller(true)\n\t_, file, line, ok := runtime.Caller(0)\n\trequire.True(t, ok)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tlevel    Level\n\t}{\n\t\t{\n\t\t\tname:     \"debug\",\n\t\t\texpected: \"\",\n\t\t\tlevel:    DebugLevel,\n\t\t},\n\t\t{\n\t\t\tname:     \"info\",\n\t\t\texpected: fmt.Sprintf(\"INFO <log/%s:%d> coffee\\n\", filepath.Base(file), line+27),\n\t\t\tlevel:    InfoLevel,\n\t\t},\n\t\t{\n\t\t\tname:     \"error\",\n\t\t\texpected: fmt.Sprintf(\"ERRO <log/%s:%d> coffee\\n\", filepath.Base(file), line+27),\n\t\t\tlevel:    ErrorLevel,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tl := log.New(logger.StandardLog(StandardLogOptions{ForceLevel: c.level}).Writer(), \"\", 0)\n\t\t\tl.Print(\"coffee\")\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "styles.go",
          "type": "blob",
          "size": 2.0927734375,
          "content": "package log\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// Styles defines the styles for the text logger.\ntype Styles struct {\n\t// Timestamp is the style for timestamps.\n\tTimestamp lipgloss.Style\n\n\t// Caller is the style for source caller.\n\tCaller lipgloss.Style\n\n\t// Prefix is the style for prefix.\n\tPrefix lipgloss.Style\n\n\t// Message is the style for messages.\n\tMessage lipgloss.Style\n\n\t// Key is the style for keys.\n\tKey lipgloss.Style\n\n\t// Value is the style for values.\n\tValue lipgloss.Style\n\n\t// Separator is the style for separators.\n\tSeparator lipgloss.Style\n\n\t// Levels are the styles for each level.\n\tLevels map[Level]lipgloss.Style\n\n\t// Keys overrides styles for specific keys.\n\tKeys map[string]lipgloss.Style\n\n\t// Values overrides value styles for specific keys.\n\tValues map[string]lipgloss.Style\n}\n\n// DefaultStyles returns the default styles.\nfunc DefaultStyles() *Styles {\n\treturn &Styles{\n\t\tTimestamp: lipgloss.NewStyle(),\n\t\tCaller:    lipgloss.NewStyle().Faint(true),\n\t\tPrefix:    lipgloss.NewStyle().Bold(true).Faint(true),\n\t\tMessage:   lipgloss.NewStyle(),\n\t\tKey:       lipgloss.NewStyle().Faint(true),\n\t\tValue:     lipgloss.NewStyle(),\n\t\tSeparator: lipgloss.NewStyle().Faint(true),\n\t\tLevels: map[Level]lipgloss.Style{\n\t\t\tDebugLevel: lipgloss.NewStyle().\n\t\t\t\tSetString(strings.ToUpper(DebugLevel.String())).\n\t\t\t\tBold(true).\n\t\t\t\tMaxWidth(4).\n\t\t\t\tForeground(lipgloss.Color(\"63\")),\n\t\t\tInfoLevel: lipgloss.NewStyle().\n\t\t\t\tSetString(strings.ToUpper(InfoLevel.String())).\n\t\t\t\tBold(true).\n\t\t\t\tMaxWidth(4).\n\t\t\t\tForeground(lipgloss.Color(\"86\")),\n\t\t\tWarnLevel: lipgloss.NewStyle().\n\t\t\t\tSetString(strings.ToUpper(WarnLevel.String())).\n\t\t\t\tBold(true).\n\t\t\t\tMaxWidth(4).\n\t\t\t\tForeground(lipgloss.Color(\"192\")),\n\t\t\tErrorLevel: lipgloss.NewStyle().\n\t\t\t\tSetString(strings.ToUpper(ErrorLevel.String())).\n\t\t\t\tBold(true).\n\t\t\t\tMaxWidth(4).\n\t\t\t\tForeground(lipgloss.Color(\"204\")),\n\t\t\tFatalLevel: lipgloss.NewStyle().\n\t\t\t\tSetString(strings.ToUpper(FatalLevel.String())).\n\t\t\t\tBold(true).\n\t\t\t\tMaxWidth(4).\n\t\t\t\tForeground(lipgloss.Color(\"134\")),\n\t\t},\n\t\tKeys:   map[string]lipgloss.Style{},\n\t\tValues: map[string]lipgloss.Style{},\n\t}\n}\n"
        },
        {
          "name": "text.go",
          "type": "blob",
          "size": 5.794921875,
          "content": "package log\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nconst (\n\tseparator       = \"=\"\n\tindentSeparator = \"  ‚îÇ \"\n)\n\nfunc (l *Logger) writeIndent(w io.Writer, str string, indent string, newline bool, key string) {\n\tst := l.styles\n\n\t// kindly borrowed from hclog\n\tfor {\n\t\tnl := strings.IndexByte(str, '\\n')\n\t\tif nl == -1 {\n\t\t\tif str != \"\" {\n\t\t\t\t_, _ = w.Write([]byte(indent))\n\t\t\t\tval := escapeStringForOutput(str, false)\n\t\t\t\tif valueStyle, ok := st.Values[key]; ok {\n\t\t\t\t\tval = valueStyle.Renderer(l.re).Render(val)\n\t\t\t\t} else {\n\t\t\t\t\tval = st.Value.Renderer(l.re).Render(val)\n\t\t\t\t}\n\t\t\t\t_, _ = w.Write([]byte(val))\n\t\t\t\tif newline {\n\t\t\t\t\t_, _ = w.Write([]byte{'\\n'})\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t_, _ = w.Write([]byte(indent))\n\t\tval := escapeStringForOutput(str[:nl], false)\n\t\tval = st.Value.Renderer(l.re).Render(val)\n\t\t_, _ = w.Write([]byte(val))\n\t\t_, _ = w.Write([]byte{'\\n'})\n\t\tstr = str[nl+1:]\n\t}\n}\n\nfunc needsEscaping(str string) bool {\n\tfor _, b := range str {\n\t\tif !unicode.IsPrint(b) || b == '\"' {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nconst (\n\tlowerhex = \"0123456789abcdef\"\n)\n\nvar bufPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn new(strings.Builder)\n\t},\n}\n\nfunc escapeStringForOutput(str string, escapeQuotes bool) string {\n\t// kindly borrowed from hclog\n\tif !needsEscaping(str) {\n\t\treturn str\n\t}\n\n\tbb := bufPool.Get().(*strings.Builder)\n\tbb.Reset()\n\n\tdefer bufPool.Put(bb)\n\tfor _, r := range str {\n\t\tif escapeQuotes && r == '\"' {\n\t\t\tbb.WriteString(`\\\"`)\n\t\t} else if unicode.IsPrint(r) {\n\t\t\tbb.WriteRune(r)\n\t\t} else {\n\t\t\tswitch r {\n\t\t\tcase '\\a':\n\t\t\t\tbb.WriteString(`\\a`)\n\t\t\tcase '\\b':\n\t\t\t\tbb.WriteString(`\\b`)\n\t\t\tcase '\\f':\n\t\t\t\tbb.WriteString(`\\f`)\n\t\t\tcase '\\n':\n\t\t\t\tbb.WriteString(`\\n`)\n\t\t\tcase '\\r':\n\t\t\t\tbb.WriteString(`\\r`)\n\t\t\tcase '\\t':\n\t\t\t\tbb.WriteString(`\\t`)\n\t\t\tcase '\\v':\n\t\t\t\tbb.WriteString(`\\v`)\n\t\t\tdefault:\n\t\t\t\tswitch {\n\t\t\t\tcase r < ' ':\n\t\t\t\t\tbb.WriteString(`\\x`)\n\t\t\t\t\tbb.WriteByte(lowerhex[byte(r)>>4])\n\t\t\t\t\tbb.WriteByte(lowerhex[byte(r)&0xF])\n\t\t\t\tcase !utf8.ValidRune(r):\n\t\t\t\t\tr = 0xFFFD\n\t\t\t\t\tfallthrough\n\t\t\t\tcase r < 0x10000:\n\t\t\t\t\tbb.WriteString(`\\u`)\n\t\t\t\t\tfor s := 12; s >= 0; s -= 4 {\n\t\t\t\t\t\tbb.WriteByte(lowerhex[r>>uint(s)&0xF])\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbb.WriteString(`\\U`)\n\t\t\t\t\tfor s := 28; s >= 0; s -= 4 {\n\t\t\t\t\t\tbb.WriteByte(lowerhex[r>>uint(s)&0xF])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bb.String()\n}\n\nfunc needsQuoting(s string) bool {\n\tfor i := 0; i < len(s); {\n\t\tb := s[i]\n\t\tif b < utf8.RuneSelf {\n\t\t\tif needsQuotingSet[b] {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tr, size := utf8.DecodeRuneInString(s[i:])\n\t\tif r == utf8.RuneError || unicode.IsSpace(r) || !unicode.IsPrint(r) {\n\t\t\treturn true\n\t\t}\n\t\ti += size\n\t}\n\treturn false\n}\n\nvar needsQuotingSet = [utf8.RuneSelf]bool{\n\t'\"': true,\n\t'=': true,\n}\n\nfunc init() {\n\tfor i := 0; i < utf8.RuneSelf; i++ {\n\t\tr := rune(i)\n\t\tif unicode.IsSpace(r) || !unicode.IsPrint(r) {\n\t\t\tneedsQuotingSet[i] = true\n\t\t}\n\t}\n}\n\nfunc writeSpace(w io.Writer, first bool) {\n\tif !first {\n\t\tw.Write([]byte{' '}) //nolint: errcheck\n\t}\n}\n\nfunc (l *Logger) textFormatter(keyvals ...interface{}) {\n\tst := l.styles\n\tlenKeyvals := len(keyvals)\n\n\tfor i := 0; i < lenKeyvals; i += 2 {\n\t\tfirstKey := i == 0\n\t\tmoreKeys := i < lenKeyvals-2\n\n\t\tswitch keyvals[i] {\n\t\tcase TimestampKey:\n\t\t\tif t, ok := keyvals[i+1].(time.Time); ok {\n\t\t\t\tts := t.Format(l.timeFormat)\n\t\t\t\tts = st.Timestamp.Renderer(l.re).Render(ts)\n\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\tl.b.WriteString(ts)\n\t\t\t}\n\t\tcase LevelKey:\n\t\t\tif level, ok := keyvals[i+1].(Level); ok {\n\t\t\t\tvar lvl string\n\t\t\t\tlvlStyle, ok := st.Levels[level]\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tlvl = lvlStyle.Renderer(l.re).String()\n\t\t\t\tif lvl != \"\" {\n\t\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\t\tl.b.WriteString(lvl)\n\t\t\t\t}\n\t\t\t}\n\t\tcase CallerKey:\n\t\t\tif caller, ok := keyvals[i+1].(string); ok {\n\t\t\t\tcaller = fmt.Sprintf(\"<%s>\", caller)\n\t\t\t\tcaller = st.Caller.Renderer(l.re).Render(caller)\n\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\tl.b.WriteString(caller)\n\t\t\t}\n\t\tcase PrefixKey:\n\t\t\tif prefix, ok := keyvals[i+1].(string); ok {\n\t\t\t\tprefix = st.Prefix.Renderer(l.re).Render(prefix + \":\")\n\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\tl.b.WriteString(prefix)\n\t\t\t}\n\t\tcase MessageKey:\n\t\t\tif msg := keyvals[i+1]; msg != nil {\n\t\t\t\tm := fmt.Sprint(msg)\n\t\t\t\tm = st.Message.Renderer(l.re).Render(m)\n\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\tl.b.WriteString(m)\n\t\t\t}\n\t\tdefault:\n\t\t\tsep := separator\n\t\t\tindentSep := indentSeparator\n\t\t\tsep = st.Separator.Renderer(l.re).Render(sep)\n\t\t\tindentSep = st.Separator.Renderer(l.re).Render(indentSep)\n\t\t\tkey := fmt.Sprint(keyvals[i])\n\t\t\tval := fmt.Sprintf(\"%+v\", keyvals[i+1])\n\t\t\traw := val == \"\"\n\t\t\tif raw {\n\t\t\t\tval = `\"\"`\n\t\t\t}\n\t\t\tif key == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tactualKey := key\n\t\t\tvalueStyle := st.Value\n\t\t\tif vs, ok := st.Values[actualKey]; ok {\n\t\t\t\tvalueStyle = vs\n\t\t\t}\n\t\t\tif keyStyle, ok := st.Keys[key]; ok {\n\t\t\t\tkey = keyStyle.Renderer(l.re).Render(key)\n\t\t\t} else {\n\t\t\t\tkey = st.Key.Renderer(l.re).Render(key)\n\t\t\t}\n\n\t\t\t// Values may contain multiple lines, and that format\n\t\t\t// is preserved, with each line prefixed with a \"  | \"\n\t\t\t// to show it's part of a collection of lines.\n\t\t\t//\n\t\t\t// Values may also need quoting, if not all the runes\n\t\t\t// in the value string are \"normal\", like if they\n\t\t\t// contain ANSI escape sequences.\n\t\t\tif strings.Contains(val, \"\\n\") {\n\t\t\t\tl.b.WriteString(\"\\n  \")\n\t\t\t\tl.b.WriteString(key)\n\t\t\t\tl.b.WriteString(sep + \"\\n\")\n\t\t\t\tl.writeIndent(&l.b, val, indentSep, moreKeys, actualKey)\n\t\t\t} else if !raw && needsQuoting(val) {\n\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\tl.b.WriteString(key)\n\t\t\t\tl.b.WriteString(sep)\n\t\t\t\tl.b.WriteString(valueStyle.Renderer(l.re).Render(fmt.Sprintf(`\"%s\"`,\n\t\t\t\t\tescapeStringForOutput(val, true))))\n\t\t\t} else {\n\t\t\t\tval = valueStyle.Renderer(l.re).Render(val)\n\t\t\t\twriteSpace(&l.b, firstKey)\n\t\t\t\tl.b.WriteString(key)\n\t\t\t\tl.b.WriteString(sep)\n\t\t\t\tl.b.WriteString(val)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add a newline to the end of the log message.\n\tl.b.WriteByte('\\n')\n}\n"
        },
        {
          "name": "text_test.go",
          "type": "blob",
          "size": 11.3857421875,
          "content": "package log\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/muesli/termenv\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc _zeroTime(time.Time) time.Time {\n\treturn time.Time{}.AddDate(1, 0, 0)\n}\n\nfunc TestNilStyles(t *testing.T) {\n\tst := DefaultStyles()\n\tl := New(io.Discard)\n\tl.SetStyles(nil)\n\tassert.Equal(t, st, l.styles)\n}\n\nfunc TestTextCaller(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetReportCaller(true)\n\t// We calculate the caller offset based on the caller line number.\n\t_, file, line, _ := runtime.Caller(0)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\t\tf        func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"simple caller\",\n\t\t\texpected: fmt.Sprintf(\"INFO <log/%s:%d> info\\n\", filepath.Base(file), line+14),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf: func(msg interface{}, kvs ...interface{}) {\n\t\t\t\tlogger.Info(msg, kvs...)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"helper caller\",\n\t\t\texpected: fmt.Sprintf(\"INFO <log/%s:%d> info\\n\", filepath.Base(file), line+58),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf: func(msg interface{}, kvs ...interface{}) {\n\t\t\t\tlogger.Helper()\n\t\t\t\tlogger.Info(msg, kvs...)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"nested helper caller\",\n\t\t\texpected: fmt.Sprintf(\"INFO <log/%s:%d> info\\n\", filepath.Base(file), line+37),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf: func(msg interface{}, kvs ...interface{}) {\n\t\t\t\tfun := func(msg interface{}, kvs ...interface{}) {\n\t\t\t\t\tlogger.Helper()\n\t\t\t\t\tlogger.Info(msg, kvs...)\n\t\t\t\t}\n\t\t\t\tfun(msg, kvs...)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"double nested helper caller\",\n\t\t\texpected: fmt.Sprintf(\"INFO <log/%s:%d> info\\n\", filepath.Base(file), line+58),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf: func(msg interface{}, kvs ...interface{}) {\n\t\t\t\tlogger.Helper()\n\t\t\t\tfun := func(msg interface{}, kvs ...interface{}) {\n\t\t\t\t\tlogger.Helper()\n\t\t\t\t\tlogger.Info(msg, kvs...)\n\t\t\t\t}\n\t\t\t\tfun(msg, kvs...)\n\t\t\t},\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestTextLogger(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\t\tf        func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"simple message\",\n\t\t\texpected: \"INFO info\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        logger.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"ignored message\",\n\t\t\texpected: \"\",\n\t\t\tmsg:      \"this is a debug message\",\n\t\t\tkvs:      nil,\n\t\t\tf:        logger.Debug,\n\t\t},\n\t\t{\n\t\t\tname:     \"message with keyvals\",\n\t\t\texpected: \"INFO info key1=val1 key2=val2\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", \"val1\", \"key2\", \"val2\"},\n\t\t\tf:        logger.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"error message with keyvals\",\n\t\t\texpected: \"ERRO info key1=val1 key2=val2\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", \"val1\", \"key2\", \"val2\"},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"error message with multiline\",\n\t\t\texpected: \"ERRO info\\n  key1=\\n  ‚îÇ val1\\n  ‚îÇ val2\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", \"val1\\nval2\"},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"odd number of keyvals\",\n\t\t\texpected: \"ERRO info key1=val1 key2=val2 key3=\\\"missing value\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", \"val1\", \"key2\", \"val2\", \"key3\"},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"error field\",\n\t\t\texpected: \"ERRO info key1=\\\"error value\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", errors.New(\"error value\")},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"struct field\",\n\t\t\texpected: \"ERRO info key1={foo:bar}\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", struct{ foo string }{foo: \"bar\"}},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"struct field quoted\",\n\t\t\texpected: \"ERRO info key1=\\\"{foo:bar baz}\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", struct{ foo string }{foo: \"bar baz\"}},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of strings\",\n\t\t\texpected: \"ERRO info key1=\\\"[foo bar]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", []string{\"foo\", \"bar\"}},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of structs\",\n\t\t\texpected: \"ERRO info key1=\\\"[{foo:bar} {foo:baz}]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", []struct{ foo string }{{foo: \"bar\"}, {foo: \"baz\"}}},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice of errors\",\n\t\t\texpected: \"ERRO info key1=\\\"[error value1 error value2]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", []error{errors.New(\"error value1\"), errors.New(\"error value2\")}},\n\t\t\tf:        logger.Error,\n\t\t},\n\t\t{\n\t\t\tname:     \"map of strings\",\n\t\t\texpected: \"ERRO info key1=\\\"map[baz:qux foo:bar]\\\"\\n\",\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      []interface{}{\"key1\", map[string]string{\"foo\": \"bar\", \"baz\": \"qux\"}},\n\t\t\tf:        logger.Error,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestTextHelper(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetReportCaller(true)\n\thelper := func() {\n\t\tlogger.Helper()\n\t\tlogger.Info(\"helper func\")\n\t}\n\n\thelper()\n\t_, file, line, ok := runtime.Caller(0)\n\trequire.True(t, ok)\n\tassert.Equal(t, fmt.Sprintf(\"INFO <log/%s:%d> helper func\\n\", filepath.Base(file), line-1), buf.String())\n}\n\nfunc TestTextFatal(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetReportCaller(true)\n\tif os.Getenv(\"FATAL\") == \"1\" {\n\t\tlogger.Fatal(\"i'm dead\")\n\t\tlogger.Fatalf(\"bye %s\", \"bye\")\n\t\treturn\n\t}\n\tcmd := exec.Command(os.Args[0], \"-test.run=TestTextFatal\")\n\tcmd.Env = append(os.Environ(), \"FATAL=1\")\n\terr := cmd.Run()\n\tif e, ok := err.(*exec.ExitError); ok && !e.Success() {\n\t\treturn\n\t}\n\tt.Fatalf(\"process ran with err %v, want exit status 1\", err)\n}\n\nfunc TestTextValueStyles(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlogger := New(&buf)\n\tlogger.SetColorProfile(termenv.ANSI256)\n\tlipgloss.SetColorProfile(termenv.ANSI256)\n\tst := DefaultStyles()\n\tst.Value = lipgloss.NewStyle().Bold(true)\n\tst.Values[\"key3\"] = st.Value.Copy().Underline(true)\n\tlogger.SetStyles(st)\n\tcases := []struct {\n\t\tname     string\n\t\texpected string\n\t\tmsg      string\n\t\tkvs      []interface{}\n\t\tf        func(msg interface{}, kvs ...interface{})\n\t}{\n\t\t{\n\t\t\tname:     \"simple message\",\n\t\t\texpected: fmt.Sprintf(\"%s info\\n\", st.Levels[InfoLevel]),\n\t\t\tmsg:      \"info\",\n\t\t\tkvs:      nil,\n\t\t\tf:        logger.Info,\n\t\t},\n\t\t{\n\t\t\tname:     \"ignored message\",\n\t\t\texpected: \"\",\n\t\t\tmsg:      \"this is a debug message\",\n\t\t\tkvs:      nil,\n\t\t\tf:        logger.Debug,\n\t\t},\n\t\t{\n\t\t\tname: \"message with keyvals\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s %s%s%s\\n\",\n\t\t\t\tst.Levels[InfoLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(\"val1\"),\n\t\t\t\tst.Key.Render(\"key2\"), st.Separator.Render(separator), st.Value.Render(\"val2\"),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", \"val1\", \"key2\", \"val2\"},\n\t\t\tf:   logger.Info,\n\t\t},\n\t\t{\n\t\t\tname: \"error message with multiline\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info\\n  %s%s\\n%s%s\\n%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator),\n\t\t\t\tst.Separator.Render(indentSeparator), st.Value.Render(\"val1\"),\n\t\t\t\tst.Separator.Render(indentSeparator), st.Value.Render(\"val2\"),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", \"val1\\nval2\"},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"error message with keyvals\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(\"val1\"),\n\t\t\t\tst.Key.Render(\"key2\"), st.Separator.Render(separator), st.Value.Render(\"val2\"),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", \"val1\", \"key2\", \"val2\"},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"odd number of keyvals\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s %s%s%s %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(\"val1\"),\n\t\t\t\tst.Key.Render(\"key2\"), st.Separator.Render(separator), st.Value.Render(\"val2\"),\n\t\t\t\tst.Key.Render(\"key3\"), st.Separator.Render(separator), st.Values[\"key3\"].Render(`\"missing value\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", \"val1\", \"key2\", \"val2\", \"key3\"},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"error field\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(`\"error value\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", errors.New(\"error value\")},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"struct field\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[InfoLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(\"{foo:bar}\"),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", struct{ foo string }{foo: \"bar\"}},\n\t\t\tf:   logger.Info,\n\t\t},\n\t\t{\n\t\t\tname: \"struct field quoted\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[InfoLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(`\"{foo:bar baz}\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", struct{ foo string }{foo: \"bar baz\"}},\n\t\t\tf:   logger.Info,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of strings\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(`\"[foo bar]\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", []string{\"foo\", \"bar\"}},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of structs\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(`\"[{foo:bar} {foo:baz}]\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", []struct{ foo string }{{foo: \"bar\"}, {foo: \"baz\"}}},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"slice of errors\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(`\"[error value1 error value2]\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", []error{errors.New(\"error value1\"), errors.New(\"error value2\")}},\n\t\t\tf:   logger.Error,\n\t\t},\n\t\t{\n\t\t\tname: \"map of strings\",\n\t\t\texpected: fmt.Sprintf(\n\t\t\t\t\"%s info %s%s%s\\n\",\n\t\t\t\tst.Levels[ErrorLevel],\n\t\t\t\tst.Key.Render(\"key1\"), st.Separator.Render(separator), st.Value.Render(`\"map[baz:qux foo:bar]\"`),\n\t\t\t),\n\t\t\tmsg: \"info\",\n\t\t\tkvs: []interface{}{\"key1\", map[string]string{\"foo\": \"bar\", \"baz\": \"qux\"}},\n\t\t\tf:   logger.Error,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tbuf.Reset()\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tc.f(c.msg, c.kvs...)\n\t\t\tassert.Equal(t, c.expected, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestColorProfile(t *testing.T) {\n\tcases := []termenv.Profile{\n\t\ttermenv.Ascii,\n\t\ttermenv.ANSI,\n\t\ttermenv.ANSI256,\n\t\ttermenv.TrueColor,\n\t}\n\tl := New(io.Discard)\n\tfor _, p := range cases {\n\t\tl.SetColorProfile(p)\n\t\tassert.Equal(t, p, l.re.ColorProfile())\n\t}\n}\n\nfunc TestCustomLevelStyle(t *testing.T) {\n\tvar buf bytes.Buffer\n\tl := New(&buf)\n\tst := DefaultStyles()\n\tlvl := Level(1234)\n\tst.Levels[lvl] = lipgloss.NewStyle().Bold(true).SetString(\"FUNKY\")\n\tl.SetStyles(st)\n\tl.SetLevel(lvl)\n\tl.Log(lvl, \"foobar\")\n\tassert.Equal(t, \"FUNKY foobar\\n\", buf.String())\n}\n"
        }
      ]
    }
  ]
}