{
  "metadata": {
    "timestamp": 1736567055809,
    "page": 640,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "otiai10/gosseract",
      "stars": 2769,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.005859375,
          "content": "vendor"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.462890625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n# environment\n*.DS_Store\n\n# editors and IDEs\n\n.idea/*\ngosseract.sublime-project\ngosseract.sublime-workspace\ngosseract.iml\n\n# runtime\n.vagrant\ncoverage.txt\ncoverage\nvendor\ntest/runtimes/TESTRESULT.*.txt\n\n# Editors\n.vscode\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.138671875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at otiai10@gmail.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.6259765625,
          "content": "#####\n# This is a working example of setting up tesseract/gosseract,\n# and also works as an example runtime to use gosseract package.\n# You can just hit `docker run -it --rm otiai10/gosseract`\n# to try and check it out!\n#####\nFROM golang:latest\nLABEL maintainer=\"Hiromu Ochiai <otiai10@gmail.com>\"\n\nRUN apt-get update -qq\n\n# You need librariy files and headers of tesseract and leptonica.\n# When you miss these or LD_LIBRARY_PATH is not set to them,\n# you would face an error: \"tesseract/baseapi.h: No such file or directory\"\nRUN apt-get install -y -qq libtesseract-dev libleptonica-dev\n\n# In case you face TESSDATA_PREFIX error, you minght need to set env vars\n# to specify the directory where \"tessdata\" is located.\nENV TESSDATA_PREFIX=/usr/share/tesseract-ocr/5/tessdata/\n\n# Load languages.\n# These {lang}.traineddata would b located under ${TESSDATA_PREFIX}/tessdata.\nRUN apt-get install -y -qq \\\n  tesseract-ocr-eng \\\n  tesseract-ocr-deu \\\n  tesseract-ocr-jpn\n# See https://github.com/tesseract-ocr/tessdata for the list of available languages.\n# If you want to download these traineddata via `wget`, don't forget to locate\n# downloaded traineddata under ${TESSDATA_PREFIX}/tessdata.\n\n# Setup your cool project with go.mod.\nWORKDIR ${GOPATH}/src/github.com/ghost/cool-project\nRUN go mod init\n\n# Let's have gosseract in your project and test it.\nRUN go get -t github.com/otiai10/gosseract/v2\n\n# Now, you've got complete environment to play with \"gosseract\"!\n# For other OS, check https://github.com/otiai10/gosseract/tree/main/test/runtimes\n\n# Try `docker run -it --rm otiai10/gosseract` to test this environment.\nCMD go test -v github.com/otiai10/gosseract/v2\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.509765625,
          "content": "> This text is generated based on `ISSUE_TEMPLATE.md`. The issue reporter must read and remove this block before submitting.\n\n# Summary\n\n- bla bla bla\n\n# Reproducibility\n\n## Reproducibility Frequency\n\n- XX%\n\n## Reproducible Dockerfile\n\n```dockerfile\nFROM your-os:your-version\n# Describe how to reproduce your problem\n# on your environment\n```\n\nOtherwise, describe how to reproduce\n\n1. `foo bar`\n2. `spam ham`\n3. `hoge fuga`\n\n# Environment\n\n```\nuname -a\n```\n\n```\ngo env\n```\n\n```\ngo version\n```\n\n```\ntesseract --version\n```\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.048828125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 otiai10\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.6962890625,
          "content": "# gosseract OCR\n\n[![Go Test](https://github.com/otiai10/gosseract/actions/workflows/go-ci.yml/badge.svg)](https://github.com/otiai10/gosseract/actions/workflows/go-ci.yml)\n[![Docker Test](https://github.com/otiai10/gosseract/actions/workflows/runtime-docker.yml/badge.svg)](https://github.com/otiai10/gosseract/actions/workflows/runtime-docker.yml)\n[![BSD Test](https://github.com/otiai10/gosseract/actions/workflows/runtime-vmactions.yml/badge.svg)](https://github.com/otiai10/gosseract/actions/workflows/runtime-vmactions.yml)\n[![codecov](https://codecov.io/gh/otiai10/gosseract/branch/main/graph/badge.svg)](https://codecov.io/gh/otiai10/gosseract)\n[![Go Report Card](https://goreportcard.com/badge/github.com/otiai10/gosseract)](https://goreportcard.com/report/github.com/otiai10/gosseract)\n[![Maintainability](https://api.codeclimate.com/v1/badges/351d9027a3c517505094/maintainability)](https://codeclimate.com/github/otiai10/gosseract/maintainability)\n[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](https://github.com/otiai10/gosseract/blob/main/LICENSE)\n[![Go Reference](https://pkg.go.dev/badge/github.com/otiai10/gosseract/v2.svg)](https://pkg.go.dev/github.com/otiai10/gosseract/v2)\n\nGolang OCR package, by using Tesseract C++ library.\n\n# OCR Server\n\nDo you just want OCR server, or see the working example of this package? Yes, there is already-made server application, which is seriously easy to deploy!\n\nðŸ‘‰ https://github.com/otiai10/ocrserver\n\n# Example\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/otiai10/gosseract/v2\"\n)\n\nfunc main() {\n\tclient := gosseract.NewClient()\n\tdefer client.Close()\n\tclient.SetImage(\"path/to/image.png\")\n\ttext, _ := client.Text()\n\tfmt.Println(text)\n\t// Hello, World!\n}\n```\n\n# Installation\n\n1. [tesseract-ocr](https://github.com/tesseract-ocr/tessdoc), including library and headers\n2. `go get -t github.com/otiai10/gosseract/v2`\n\nPlease check this [Dockerfile](https://github.com/otiai10/gosseract/blob/main/Dockerfile) to get started step-by-step.\nOr if you want the env instantly, you can just try by `docker run -it --rm otiai10/gosseract`.\n\n# Test\n\nIn case you have [tesseract-ocr](https://github.com/tesseract-ocr/tessdoc) on your local, you can just hit\n\n```\n% go test .\n```\n\nOtherwise, if you **DON'T** want to install tesseract-ocr on your local, kick `./test/runtime` which is using Docker and Vagrant to test the source code on some runtimes.\n\n```\n% ./test/runtime --driver docker\n% ./test/runtime --driver vagrant\n```\n\nCheck [./test/runtimes](https://github.com/otiai10/gosseract/tree/main/test/runtimes) for more information about runtime tests.\n\n# Issues\n\n- [https://github.com/otiai10/gosseract/issues](https://github.com/otiai10/gosseract/issues?utf8=%E2%9C%93&q=is%3Aissue)\n"
        },
        {
          "name": "all_test.go",
          "type": "blob",
          "size": 7.9345703125,
          "content": "package gosseract\n\nimport (\n\t\"encoding/xml\"\n\t\"image\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/otiai10/mint\"\n)\n\nfunc TestMain(m *testing.M) {\n\tbeforeTest()\n\tcode := m.Run()\n\tos.Exit(code)\n}\n\nfunc beforeTest() {\n\tif strings.HasPrefix(Version(), \"4.0\") {\n\t\tos.Setenv(\"TESS_LSTM_DISABLED\", \"1\")\n\t}\n\tswitch os.Getenv(\"TESTCASE\") {\n\tcase \"archlinux\", \"centos\", \"debian\", \"fedora\", \"mingw\":\n\t\tos.Setenv(\"TESS_BOX_DISABLED\", \"1\")\n\t}\n}\n\nfunc TestVersion(t *testing.T) {\n\tversion := Version()\n\tExpect(t, version).Match(\"[0-9]{1}.[0-9]{1,2}(.[0-9a-z_-]*)?\")\n}\n\nfunc TestClearPersistentCache(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\tclient.init()\n\tClearPersistentCache()\n}\n\nfunc TestNewClient(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tExpect(t, client).TypeOf(\"*gosseract.Client\")\n}\n\nfunc TestDoubleClose(t *testing.T) {\n\tclient := NewClient()\n\tclient.Close()\n\tclient.Close()\n}\n\nfunc TestClient_SetTessdataPrefix(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tcwd, err := os.Getwd()\n\tExpect(t, err).ToBe(nil)\n\ttestModelDir := filepath.Join(cwd, \"test-model\", \"tessdata\")\n\n\terr = os.MkdirAll(testModelDir, 0770)\n\tExpect(t, err).ToBe(nil)\n\tdefer os.RemoveAll(filepath.Dir(testModelDir))\n\n\tsrc, err := os.Open(filepath.Join(getDataPath(), \"eng.traineddata\"))\n\tExpect(t, err).ToBe(nil)\n\tdefer src.Close()\n\n\tdst, err := os.Create(filepath.Join(testModelDir, \"eng.traineddata\"))\n\tExpect(t, err).ToBe(nil)\n\n\t_, err = io.Copy(dst, src)\n\tExpect(t, err).ToBe(nil)\n\tdst.Close()\n\n\tclient.Trim = true\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\tclient.SetLanguage(\"eng\")\n\tclient.SetTessdataPrefix(testModelDir)\n\n\ttext, err := client.Text()\n\tExpect(t, err).ToBe(nil)\n\tExpect(t, text).ToBe(\"Hello, World!\")\n}\n\nfunc TestClient_Version(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\tversion := client.Version()\n\tExpect(t, version).Match(\"[0-9]{1}.[0-9]{1,2}(.[0-9a-z_-]*)?\")\n}\n\nfunc TestClient_SetImage(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tclient.Trim = true\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\n\tclient.SetPageSegMode(PSM_SINGLE_BLOCK)\n\n\ttext, err := client.Text()\n\tif client.pixImage == nil {\n\t\tt.Errorf(\"could not set image\")\n\t}\n\tExpect(t, err).ToBe(nil)\n\tExpect(t, text).ToBe(\"Hello, World!\")\n\n\terr = client.SetImage(\"./test/data/001-helloworld.png\")\n\tExpect(t, err).ToBe(nil)\n\n\terr = client.SetImage(\"\")\n\tExpect(t, err).Not().ToBe(nil)\n\n\terr = client.SetImage(\"somewhere/fake/fakeimage.png\")\n\tExpect(t, err).Not().ToBe(nil)\n\n\t_, err = client.Text()\n\tExpect(t, err).ToBe(nil)\n\n\tBecause(t, \"api must be initialized beforehand\", func(t *testing.T) {\n\t\tclient := &Client{}\n\t\terr := client.SetImage(\"./test/data/001-helloworld.png\")\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n}\n\nfunc TestClient_SetImageFromBytes(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tcontent, err := ioutil.ReadFile(\"./test/data/001-helloworld.png\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not read test file\")\n\t}\n\n\tclient.Trim = true\n\tclient.SetImageFromBytes(content)\n\n\tclient.SetPageSegMode(PSM_SINGLE_BLOCK)\n\n\ttext, err := client.Text()\n\tif client.pixImage == nil {\n\t\tt.Errorf(\"could not set image\")\n\t}\n\tExpect(t, err).ToBe(nil)\n\tExpect(t, text).ToBe(\"Hello, World!\")\n\terr = client.SetImageFromBytes(content)\n\tExpect(t, err).ToBe(nil)\n\n\terr = client.SetImageFromBytes(nil)\n\tExpect(t, err).Not().ToBe(nil)\n\n\tBecause(t, \"api must be initialized beforehand\", func(t *testing.T) {\n\t\tclient := &Client{}\n\t\terr := client.SetImageFromBytes(content)\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n}\n\nfunc TestClient_SetWhitelist(t *testing.T) {\n\n\tif os.Getenv(\"TESS_LSTM_DISABLED\") == \"1\" {\n\t\tt.Skip(\"Whitelist with LSTM is not working for now. Please check https://github.com/tesseract-ocr/tesseract/issues/751\")\n\t}\n\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tclient.Trim = true\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\tclient.Languages = []string{\"eng\"}\n\tclient.SetWhitelist(\"HeloWrd,\")\n\ttext, err := client.Text()\n\tExpect(t, err).ToBe(nil)\n\n\t// Expect(t, text).ToBe(\"Hello, Worldl\")\n\tExpect(t, text).Match(\"Hello, ?Worldl?\")\n}\n\nfunc TestClient_SetBlacklist(t *testing.T) {\n\n\tif os.Getenv(\"TESS_LSTM_DISABLED\") == \"1\" {\n\t\tt.Skip(\"Blacklist with LSTM is not working for now. Please check https://github.com/tesseract-ocr/tesseract/issues/751\")\n\t}\n\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tclient.Trim = true\n\terr := client.SetImage(\"./test/data/001-helloworld.png\")\n\tExpect(t, err).ToBe(nil)\n\tclient.Languages = []string{\"eng\"}\n\terr = client.SetBlacklist(\"l\")\n\tExpect(t, err).ToBe(nil)\n\ttext, err := client.Text()\n\tExpect(t, err).ToBe(nil)\n\tExpect(t, text).Match(\"He(110|tto|o), Wor(I|t)?d!\")\n}\n\nfunc TestClient_SetLanguage(t *testing.T) {\n\tclient := NewClient()\n\tdefer client.Close()\n\terr := client.SetLanguage(\"undefined-language\")\n\tExpect(t, err).ToBe(nil)\n\terr = client.SetLanguage()\n\tExpect(t, err).Not().ToBe(nil)\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\t_, err = client.Text()\n\tExpect(t, err).Not().ToBe(nil)\n\tif os.Getenv(\"GOSSERACT_CPPSTDERR_NOT_CAPTURED\") != \"1\" {\n\t\tExpect(t, err).Match(\"Failed loading language 'undefined-language'\")\n\t}\n}\n\nfunc TestClient_ConfigFilePath(t *testing.T) {\n\n\tif os.Getenv(\"TESS_LSTM_DISABLED\") == \"1\" {\n\t\tt.Skip(\"Whitelist with LSTM is not working for now. Please check https://github.com/tesseract-ocr/tesseract/issues/751\")\n\t}\n\n\tclient := NewClient()\n\tdefer client.Close()\n\n\terr := client.SetConfigFile(\"./test/config/01.config\")\n\tExpect(t, err).ToBe(nil)\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\ttext, err := client.Text()\n\tExpect(t, err).ToBe(nil)\n\n\tExpect(t, text).Match(\"H *W *\")\n\n\tWhen(t, \"the config file is not found\", func(t *testing.T) {\n\t\terr := client.SetConfigFile(\"./test/config/not-existing\")\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n\n\tWhen(t, \"the config file path is a directory\", func(t *testing.T) {\n\t\terr := client.SetConfigFile(\"./test/config/02.config\")\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n\n}\n\nfunc TestClientBoundingBox(t *testing.T) {\n\n\tif os.Getenv(\"TESS_BOX_DISABLED\") == \"1\" {\n\t\tt.Skip()\n\t}\n\n\tclient := NewClient()\n\tdefer client.Close()\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\tclient.SetWhitelist(\"Hello,World!\")\n\tboxes, err := client.GetBoundingBoxes(RIL_WORD)\n\tExpect(t, err).ToBe(nil)\n\n\tBecause(t, \"api must be initialized beforehand\", func(t *testing.T) {\n\t\tclient := &Client{}\n\t\t_, err := client.GetBoundingBoxes(RIL_WORD)\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n\n\twords := []string{\"Hello,World!\"}\n\tcoords := []image.Rectangle{\n\t\timage.Rect(74, 64, 1099, 190),\n\t}\n\n\tif os.Getenv(\"TESS_LSTM_DISABLED\") == \"1\" {\n\t\tt.Skip()\n\t}\n\tfor i, box := range boxes {\n\t\tExpect(t, box.Word).ToBe(words[i])\n\t\tExpect(t, box.Box).ToBe(coords[i])\n\t}\n}\n\nfunc TestClient_HTML(t *testing.T) {\n\n\tif os.Getenv(\"TESS_BOX_DISABLED\") == \"1\" {\n\t\tt.Skip()\n\t}\n\n\tclient := NewClient()\n\tdefer client.Close()\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\tclient.SetWhitelist(\"Hello,World!\")\n\tout, err := client.HOCRText()\n\tExpect(t, err).ToBe(nil)\n\n\tpage := new(Page)\n\terr = xml.Unmarshal([]byte(out), page)\n\tExpect(t, err).ToBe(nil)\n\tExpect(t, len(page.Content.Par.Lines)).ToBe(1)\n\n\tif os.Getenv(\"TESS_LSTM_DISABLED\") != \"1\" {\n\t\tExpect(t, len(page.Content.Par.Lines[0].Words)).ToBe(1)\n\t\tExpect(t, page.Content.Par.Lines[0].Words[0].Characters).ToBe(\"Hello,World!\")\n\t}\n\n\tWhen(t, \"only invalid languages are given\", func(t *testing.T) {\n\t\tclient := NewClient()\n\t\tdefer client.Close()\n\t\tclient.SetLanguage(\"foo\")\n\t\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\t\t_, err := client.HOCRText()\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n\tBecause(t, \"unknown key is validated when `init` is called\", func(t *testing.T) {\n\t\tclient := NewClient()\n\t\tdefer client.Close()\n\t\terr := client.SetVariable(\"foobar\", \"hoge\")\n\t\tExpect(t, err).ToBe(nil)\n\t\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\t\t_, err = client.Text()\n\t\tExpect(t, err).Not().ToBe(nil)\n\t})\n}\n\nfunc TestGetAvailableLangs(t *testing.T) {\n\tt.Skip(\"TODO\")\n\t// langs, err := GetAvailableLanguages()\n\t// Expect(t, err).ToBe(nil)\n\t// Expect(t, len(langs)).ToBe(1) // eng only\n}\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 0.8203125,
          "content": "package gosseract\n\nimport \"testing\"\n\nfunc BenchmarkClient_Text(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tclient := NewClient()\n\t\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\t\tclient.Text()\n\t\tclient.Close()\n\t}\n}\n\nfunc BenchmarkClient_Text2(b *testing.B) {\n\tclient := NewClient()\n\tfor i := 0; i < b.N; i++ {\n\t\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\t\tclient.Text()\n\t}\n\tclient.Close()\n}\n\nfunc BenchmarkClient_GetBoundingBoxes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tclient := NewClient()\n\t\tclient.SetImage(\"./test/data/003-longer-text.png\")\n\t\tclient.GetBoundingBoxes(3)\n\t\tclient.Close()\n\t}\n}\n\nfunc BenchmarkClient_GetBoundingBoxesVerbose(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tclient := NewClient()\n\t\tclient.SetImage(\"./test/data/003-longer-text.png\")\n\t\tclient.GetBoundingBoxesVerbose()\n\t\tclient.Close()\n\t}\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 13.8798828125,
          "content": "package gosseract\n\n// #include <stdlib.h>\n// #include <stdbool.h>\n// #include \"tessbridge.h\"\nimport \"C\"\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\nvar (\n\t// ErrClientNotConstructed is returned when a client is not constructed\n\tErrClientNotConstructed = fmt.Errorf(\"TessBaseAPI is not constructed, please use `gosseract.NewClient`\")\n)\n\n// Version returns the version of Tesseract-OCR\nfunc Version() string {\n\tapi := C.Create()\n\tdefer C.Free(api)\n\tversion := C.Version(api)\n\treturn C.GoString(version)\n}\n\n// ClearPersistentCache clears any library-level memory caches. There are a variety of expensive-to-load constant data structures (mostly language dictionaries) that are cached globally â€“ surviving the Init() and End() of individual TessBaseAPI's. This function allows the clearing of these caches.\nfunc ClearPersistentCache() {\n\tapi := C.Create()\n\tdefer C.Free(api)\n\tC.ClearPersistentCache(api)\n}\n\n// Client is argument builder for tesseract::TessBaseAPI.\ntype Client struct {\n\tapi C.TessBaseAPI\n\n\t// Holds a reference to the pix image to be able to destroy on client close\n\t// or when a new image is set\n\tpixImage C.PixImage\n\n\t// Trim specifies characters to trim, which would be trimed from result string.\n\t// As results of OCR, text often contains unnecessary characters, such as newlines, on the head/foot of string.\n\t// If `Trim` is set, this client will remove specified characters from the result.\n\tTrim bool\n\n\t// TessdataPrefix can indicate directory path to `tessdata`.\n\t// It is set `/usr/local/share/tessdata/` or something like that, as default.\n\t// TODO: Implement and test\n\tTessdataPrefix string\n\n\t// Languages are languages to be detected. If not specified, it's gonna be \"eng\".\n\tLanguages []string\n\n\t// Variables is just a pool to evaluate \"tesseract::TessBaseAPI->SetVariable\" in delay.\n\t// TODO: Think if it should be public, or private property.\n\tVariables map[SettableVariable]string\n\n\t// Config is a file path to the configuration for Tesseract\n\t// See http://www.sk-spell.sk.cx/tesseract-ocr-parameters-in-302-version\n\t// TODO: Fix link to official page\n\tConfigFilePath string\n\n\t// internal flag to check if the instance should be initialized again\n\t// i.e, we should create a new gosseract client when language or config file change\n\tshouldInit bool\n}\n\n// NewClient construct new Client. It's due to caller to Close this client.\nfunc NewClient() *Client {\n\tclient := &Client{\n\t\tapi:        C.Create(),\n\t\tVariables:  map[SettableVariable]string{},\n\t\tTrim:       true,\n\t\tshouldInit: true,\n\t\tLanguages:  []string{\"eng\"},\n\t}\n\t// set a finalizer to close the client when it's unused and not closed by the user\n\truntime.SetFinalizer(client, (*Client).Close)\n\treturn client\n}\n\n// Close frees allocated API. This MUST be called for ANY client constructed by \"NewClient\" function.\nfunc (client *Client) Close() (err error) {\n\t// no need for a finalizer anymore\n\truntime.SetFinalizer(client, nil)\n\tif client.api == nil {\n\t\t// already closed or not constructed\n\t\treturn nil\n\t}\n\t// defer func() {\n\t// \tif e := recover(); e != nil {\n\t// \t\terr = fmt.Errorf(\"%v\", e)\n\t// \t}\n\t// }()\n\n\tC.Clear(client.api)\n\tC.Free(client.api)\n\tclient.api = nil\n\n\tif client.pixImage != nil {\n\t\tC.DestroyPixImage(client.pixImage)\n\t\tclient.pixImage = nil\n\t}\n\treturn err\n}\n\n// Version provides the version of Tesseract used by this client.\nfunc (client *Client) Version() string {\n\tif client.api == nil {\n\t\treturn \"\"\n\t}\n\tversion := C.Version(client.api)\n\treturn C.GoString(version)\n}\n\n// SetImage sets path to image file to be processed OCR.\nfunc (client *Client) SetImage(imagepath string) error {\n\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tif imagepath == \"\" {\n\t\treturn fmt.Errorf(\"image path cannot be empty\")\n\t}\n\tif _, err := os.Stat(imagepath); err != nil {\n\t\treturn fmt.Errorf(\"cannot detect the stat of specified file: %v\", err)\n\t}\n\n\tif client.pixImage != nil {\n\t\tC.DestroyPixImage(client.pixImage)\n\t\tclient.pixImage = nil\n\t}\n\n\tp := C.CString(imagepath)\n\tdefer C.free(unsafe.Pointer(p))\n\n\timg := C.CreatePixImageByFilePath(p)\n\tif img == nil {\n\t\treturn fmt.Errorf(\"failed to create PixImage from file path: %s\", imagepath)\n\t}\n\n\tclient.pixImage = img\n\n\treturn nil\n}\n\n// SetImageFromBytes sets the image data to be processed OCR.\nfunc (client *Client) SetImageFromBytes(data []byte) error {\n\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tif len(data) == 0 {\n\t\treturn fmt.Errorf(\"image data cannot be empty\")\n\t}\n\n\tif client.pixImage != nil {\n\t\tC.DestroyPixImage(client.pixImage)\n\t\tclient.pixImage = nil\n\t}\n\n\timg := C.CreatePixImageFromBytes((*C.uchar)(unsafe.Pointer(&data[0])), C.int(len(data)))\n\tif img == nil {\n\t\treturn fmt.Errorf(\"failed to create PixImage from bytes: %d\", len(data))\n\t}\n\n\tclient.pixImage = img\n\n\treturn nil\n}\n\n// SetLanguage sets languages to use. English as default.\nfunc (client *Client) SetLanguage(langs ...string) error {\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tif len(langs) == 0 {\n\t\treturn fmt.Errorf(\"languages cannot be empty\")\n\t}\n\n\tclient.Languages = langs\n\n\tclient.flagForInit()\n\n\treturn nil\n}\n\n// DisableOutput ...\nfunc (client *Client) DisableOutput() error {\n\treturn client.SetVariable(DEBUG_FILE, os.DevNull)\n}\n\n// SetWhitelist sets whitelist chars.\n// See official documentation for whitelist here https://tesseract-ocr.github.io/tessdoc/ImproveQuality#dictionaries-word-lists-and-patterns\nfunc (client *Client) SetWhitelist(whitelist string) error {\n\treturn client.SetVariable(TESSEDIT_CHAR_WHITELIST, whitelist)\n}\n\n// SetBlacklist sets blacklist chars.\n// See official documentation for blacklist here https://tesseract-ocr.github.io/tessdoc/ImproveQuality#dictionaries-word-lists-and-patterns\nfunc (client *Client) SetBlacklist(blacklist string) error {\n\treturn client.SetVariable(TESSEDIT_CHAR_BLACKLIST, blacklist)\n}\n\n// SetVariable sets parameters, representing tesseract::TessBaseAPI->SetVariable.\n// See official documentation here https://zdenop.github.io/tesseract-doc/classtesseract_1_1_tess_base_a_p_i.html#a2e09259c558c6d8e0f7e523cbaf5adf5\n// Because `api->SetVariable` must be called after `api->Init`, this method cannot detect unexpected key for variables.\n// Check `client.setVariablesToInitializedAPI` for more information.\nfunc (client *Client) SetVariable(key SettableVariable, value string) error {\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tclient.Variables[key] = value\n\n\treturn client.setVariablesToInitializedAPIIfNeeded()\n}\n\n// SetPageSegMode sets \"Page Segmentation Mode\" (PSM) to detect layout of characters.\n// See official documentation for PSM here https://tesseract-ocr.github.io/tessdoc/ImproveQuality#page-segmentation-method\n// See https://github.com/otiai10/gosseract/issues/52 for more information.\nfunc (client *Client) SetPageSegMode(mode PageSegMode) error {\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tC.SetPageSegMode(client.api, C.int(mode))\n\treturn nil\n}\n\n// SetConfigFile sets the file path to config file.\nfunc (client *Client) SetConfigFile(fpath string) error {\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tinfo, err := os.Stat(fpath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif info.IsDir() {\n\t\treturn fmt.Errorf(\"the specified config file path seems to be a directory\")\n\t}\n\tclient.ConfigFilePath = fpath\n\n\tclient.flagForInit()\n\n\treturn nil\n}\n\n// SetTessdataPrefix sets path to the models directory.\n// Environment variable TESSDATA_PREFIX is used as default.\nfunc (client *Client) SetTessdataPrefix(prefix string) error {\n\tif client.api == nil {\n\t\treturn ErrClientNotConstructed\n\t}\n\tif prefix == \"\" {\n\t\treturn fmt.Errorf(\"tessdata prefix could not be empty\")\n\t}\n\tclient.TessdataPrefix = prefix\n\tclient.flagForInit()\n\treturn nil\n}\n\n// Initialize tesseract::TessBaseAPI\nfunc (client *Client) init() error {\n\n\tif !client.shouldInit {\n\t\tC.SetPixImage(client.api, client.pixImage)\n\t\treturn nil\n\t}\n\n\tvar languages *C.char\n\tif len(client.Languages) != 0 {\n\t\tlanguages = C.CString(strings.Join(client.Languages, \"+\"))\n\t}\n\tdefer C.free(unsafe.Pointer(languages))\n\n\tvar configfile *C.char\n\tif _, err := os.Stat(client.ConfigFilePath); err == nil {\n\t\tconfigfile = C.CString(client.ConfigFilePath)\n\t}\n\tdefer C.free(unsafe.Pointer(configfile))\n\n\tvar tessdataPrefix *C.char\n\tif client.TessdataPrefix != \"\" {\n\t\ttessdataPrefix = C.CString(client.TessdataPrefix)\n\t}\n\tdefer C.free(unsafe.Pointer(tessdataPrefix))\n\n\terrbuf := [512]C.char{}\n\tres := C.Init(client.api, tessdataPrefix, languages, configfile, &errbuf[0])\n\tmsg := C.GoString(&errbuf[0])\n\n\tif res != 0 {\n\t\treturn fmt.Errorf(\"failed to initialize TessBaseAPI with code %d: %s\", res, msg)\n\t}\n\n\tif err := client.setVariablesToInitializedAPI(); err != nil {\n\t\treturn err\n\t}\n\n\tif client.pixImage == nil {\n\t\treturn fmt.Errorf(\"PixImage is not set, use SetImage or SetImageFromBytes before Text or HOCRText\")\n\t}\n\n\tC.SetPixImage(client.api, client.pixImage)\n\n\tclient.shouldInit = false\n\n\treturn nil\n}\n\n// This method flag the current instance to be initialized again on the next call to a function that\n// requires a gosseract API initialized: when user change the config file or the languages\n// the instance needs to init a new gosseract api\nfunc (client *Client) flagForInit() {\n\tclient.shouldInit = true\n}\n\n// This method sets all the sspecified variables to TessBaseAPI structure.\n// Because `api->SetVariable` must be called after `api->Init()`,\n// gosseract.Client.SetVariable cannot call `api->SetVariable` directly.\n// See https://zdenop.github.io/tesseract-doc/classtesseract_1_1_tess_base_a_p_i.html#a2e09259c558c6d8e0f7e523cbaf5adf5\nfunc (client *Client) setVariablesToInitializedAPI() error {\n\tfor key, value := range client.Variables {\n\t\tk, v := C.CString(string(key)), C.CString(value)\n\t\tdefer C.free(unsafe.Pointer(k))\n\t\tdefer C.free(unsafe.Pointer(v))\n\t\tres := C.SetVariable(client.api, k, v)\n\t\tif !bool(res) {\n\t\t\treturn fmt.Errorf(\"failed to set variable with key(%v) and value(%v)\", key, value)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Call setVariablesToInitializedAPI only if the API is initialized\n// it is useful to call when changing variables that does not requires\n// to init a new tesseract instance. Otherwise it is better to just flag\n// the instance for re-init (Client.flagForInit())\nfunc (client *Client) setVariablesToInitializedAPIIfNeeded() error {\n\tif !client.shouldInit {\n\t\treturn client.setVariablesToInitializedAPI()\n\t}\n\n\treturn nil\n}\n\n// Text finally initialize tesseract::TessBaseAPI, execute OCR and extract text detected as string.\nfunc (client *Client) Text() (out string, err error) {\n\tif client.api == nil {\n\t\treturn out, ErrClientNotConstructed\n\t}\n\tif err = client.init(); err != nil {\n\t\treturn\n\t}\n\tout = C.GoString(C.UTF8Text(client.api))\n\tif client.Trim {\n\t\tout = strings.Trim(out, \"\\n\")\n\t}\n\treturn out, err\n}\n\n// HOCRText finally initialize tesseract::TessBaseAPI, execute OCR and returns hOCR text.\n// See https://en.wikipedia.org/wiki/HOCR for more information of hOCR.\nfunc (client *Client) HOCRText() (out string, err error) {\n\tif client.api == nil {\n\t\treturn out, ErrClientNotConstructed\n\t}\n\tif err = client.init(); err != nil {\n\t\treturn\n\t}\n\tout = C.GoString(C.HOCRText(client.api))\n\treturn\n}\n\n// BoundingBox contains the position, confidence and UTF8 text of the recognized word\ntype BoundingBox struct {\n\tBox                                image.Rectangle\n\tWord                               string\n\tConfidence                         float64\n\tBlockNum, ParNum, LineNum, WordNum int\n}\n\n// GetBoundingBoxes returns bounding boxes for each matched word\nfunc (client *Client) GetBoundingBoxes(level PageIteratorLevel) (out []BoundingBox, err error) {\n\tif client.api == nil {\n\t\treturn out, ErrClientNotConstructed\n\t}\n\tif err = client.init(); err != nil {\n\t\treturn\n\t}\n\tboxArray := C.GetBoundingBoxes(client.api, C.int(level))\n\tlength := int(boxArray.length)\n\tdefer C.free(unsafe.Pointer(boxArray.boxes))\n\tdefer C.free(unsafe.Pointer(boxArray))\n\tout = make([]BoundingBox, 0, length)\n\tfor i := 0; i < length; i++ {\n\t\t// cast to bounding_box: boxes + i*sizeof(box)\n\t\tbox := (*C.struct_bounding_box)(unsafe.Pointer(uintptr(unsafe.Pointer(boxArray.boxes)) + uintptr(i)*unsafe.Sizeof(C.struct_bounding_box{})))\n\t\tout = append(out, BoundingBox{\n\t\t\tBox:        image.Rect(int(box.x1), int(box.y1), int(box.x2), int(box.y2)),\n\t\t\tWord:       C.GoString(box.word),\n\t\t\tConfidence: float64(box.confidence),\n\t\t})\n\t}\n\n\treturn\n}\n\n// GetAvailableLanguages returns a list of available languages in the default tesspath\nfunc GetAvailableLanguages() ([]string, error) {\n\tlanguages, err := filepath.Glob(filepath.Join(getDataPath(), \"*.traineddata\"))\n\tif err != nil {\n\t\treturn languages, err\n\t}\n\tfor i := 0; i < len(languages); i++ {\n\t\tlanguages[i] = filepath.Base(languages[i])\n\t\tidx := strings.Index(languages[i], \".\")\n\t\tlanguages[i] = languages[i][:idx]\n\t}\n\treturn languages, nil\n}\n\n// GetBoundingBoxesVerbose returns bounding boxes at word level with block_num, par_num, line_num and word_num\n// according to the c++ api that returns a formatted TSV output. Reference: `TessBaseAPI::GetTSVText`.\nfunc (client *Client) GetBoundingBoxesVerbose() (out []BoundingBox, err error) {\n\tif client.api == nil {\n\t\treturn out, ErrClientNotConstructed\n\t}\n\tif err = client.init(); err != nil {\n\t\treturn\n\t}\n\tboxArray := C.GetBoundingBoxesVerbose(client.api)\n\tlength := int(boxArray.length)\n\tdefer C.free(unsafe.Pointer(boxArray.boxes))\n\tdefer C.free(unsafe.Pointer(boxArray))\n\tout = make([]BoundingBox, 0, length)\n\tfor i := 0; i < length; i++ {\n\t\t// cast to bounding_box: boxes + i*sizeof(box)\n\t\tbox := (*C.struct_bounding_box)(unsafe.Pointer(uintptr(unsafe.Pointer(boxArray.boxes)) + uintptr(i)*unsafe.Sizeof(C.struct_bounding_box{})))\n\t\tout = append(out, BoundingBox{\n\t\t\tBox:        image.Rect(int(box.x1), int(box.y1), int(box.x2), int(box.y2)),\n\t\t\tWord:       C.GoString(box.word),\n\t\t\tConfidence: float64(box.confidence),\n\t\t\tBlockNum:   int(box.block_num),\n\t\t\tParNum:     int(box.par_num),\n\t\t\tLineNum:    int(box.line_num),\n\t\t\tWordNum:    int(box.word_num),\n\t\t})\n\t}\n\treturn\n}\n\n// getDataPath is useful hepler to determine where current tesseract\n// installation stores trained models\nfunc getDataPath() string {\n\treturn C.GoString(C.GetDataPath())\n}\n"
        },
        {
          "name": "constant.go",
          "type": "blob",
          "size": 3.216796875,
          "content": "package gosseract\n\n// PageSegMode represents tesseract::PageSegMode.\n// See https://github.com/tesseract-ocr/tesseract/wiki/ImproveQuality#page-segmentation-method and\n// https://github.com/tesseract-ocr/tesseract/blob/a18620cfea33d03032b71fe1b9fc424777e34252/ccstruct/publictypes.h#L158-L183 for more information.\ntype PageSegMode int\n\nconst (\n\t// PSM_OSD_ONLY - Orientation and script detection (OSD) only.\n\tPSM_OSD_ONLY PageSegMode = iota\n\t// PSM_AUTO_OSD - Automatic page segmentation with OSD.\n\tPSM_AUTO_OSD\n\t// PSM_AUTO_ONLY - Automatic page segmentation, but no OSD, or OCR.\n\tPSM_AUTO_ONLY\n\t// PSM_AUTO - (DEFAULT) Fully automatic page segmentation, but no OSD.\n\tPSM_AUTO\n\t// PSM_SINGLE_COLUMN - Assume a single column of text of variable sizes.\n\tPSM_SINGLE_COLUMN\n\t// PSM_SINGLE_BLOCK_VERT_TEXT - Assume a single uniform block of vertically aligned text.\n\tPSM_SINGLE_BLOCK_VERT_TEXT\n\t// PSM_SINGLE_BLOCK - Assume a single uniform block of text.\n\tPSM_SINGLE_BLOCK\n\t// PSM_SINGLE_LINE - Treat the image as a single text line.\n\tPSM_SINGLE_LINE\n\t// PSM_SINGLE_WORD - Treat the image as a single word.\n\tPSM_SINGLE_WORD\n\t// PSM_CIRCLE_WORD - Treat the image as a single word in a circle.\n\tPSM_CIRCLE_WORD\n\t// PSM_SINGLE_CHAR - Treat the image as a single character.\n\tPSM_SINGLE_CHAR\n\t// PSM_SPARSE_TEXT - Find as much text as possible in no particular order.\n\tPSM_SPARSE_TEXT\n\t// PSM_SPARSE_TEXT_OSD - Sparse text with orientation and script det.\n\tPSM_SPARSE_TEXT_OSD\n\t// PSM_RAW_LINE - Treat the image as a single text line, bypassing hacks that are Tesseract-specific.\n\tPSM_RAW_LINE\n\n\t// PSM_COUNT - Just a number of enum entries. This is NOT a member of PSM ;)\n\tPSM_COUNT\n)\n\n// PageIteratorLevel maps directly to tesseracts enum tesseract::PageIteratorLevel\n// represents the hierarchy of the page elements used in ResultIterator.\n// https://github.com/tesseract-ocr/tesseract/blob/a18620cfea33d03032b71fe1b9fc424777e34252/ccstruct/publictypes.h#L219-L225\ntype PageIteratorLevel int\n\nconst (\n\t// RIL_BLOCK - Block of text/image/separator line.\n\tRIL_BLOCK PageIteratorLevel = iota\n\t// RIL_PARA - Paragraph within a block.\n\tRIL_PARA\n\t// RIL_TEXTLINE - Line within a paragraph.\n\tRIL_TEXTLINE\n\t// RIL_WORD - Word within a textline.\n\tRIL_WORD\n\t// RIL_SYMBOL - Symbol/character within a word.\n\tRIL_SYMBOL\n)\n\n// SettableVariable represents available strings for TessBaseAPI::SetVariable.\n// See https://groups.google.com/forum/#!topic/tesseract-ocr/eHTBzrBiwvQ\n// and https://github.com/tesseract-ocr/tesseract/blob/master/src/ccmain/tesseractclass.h\ntype SettableVariable string\n\n// Followings are variables which can be used for TessBaseAPI::SetVariable.\n// If anything missing (I know there are many), please add one below.\nconst (\n\t// DEBUG_FILE - File to send output to.\n\tDEBUG_FILE SettableVariable = \"debug_file\"\n\t// TESSEDIT_CHAR_WHITELIST - Whitelist of chars to recognize\n\t// There is a known issue in 4.00 with LSTM\n\t// https://github.com/tesseract-ocr/tesseract/issues/751\n\tTESSEDIT_CHAR_WHITELIST SettableVariable = \"tessedit_char_whitelist\"\n\t// TESSEDIT_CHAR_BLACKLIST - Blacklist of chars not to recognize\n\t// There is a known issue in 4.00 with LSTM\n\t// https://github.com/tesseract-ocr/tesseract/issues/751\n\tTESSEDIT_CHAR_BLACKLIST SettableVariable = \"tessedit_char_blacklist\"\n)\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.880859375,
          "content": "package gosseract\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc ExampleNewClient() {\n\tclient := NewClient()\n\t// Never forget to defer Close. It is due to caller to Close this client.\n\tdefer client.Close()\n}\n\nfunc ExampleClient_SetImage() {\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\t// See \"ExampleClient_Text\" for more practical usecase ;)\n}\n\nfunc ExampleClient_Text() {\n\n\tclient := NewClient()\n\tdefer client.Close()\n\n\tclient.SetImage(\"./test/data/001-helloworld.png\")\n\n\ttext, err := client.Text()\n\tfmt.Println(text, err)\n}\n\nfunc ExampleClient_SetWhitelist() {\n\n\tif os.Getenv(\"TESS_LSTM_DISABLED\") == \"1\" {\n\t\tos.Exit(0)\n\t}\n\n\tclient := NewClient()\n\tdefer client.Close()\n\tclient.SetImage(\"./test/data/002-confusing.png\")\n\n\tclient.SetWhitelist(\"IO-\")\n\ttext1, _ := client.Text()\n\n\tclient.SetWhitelist(\"10-\")\n\ttext2, _ := client.Text()\n\n\tfmt.Println(text1, text2)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0859375,
          "content": "module github.com/otiai10/gosseract/v2\n\ngo 1.18\n\nrequire github.com/otiai10/mint v1.6.3\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1611328125,
          "content": "github.com/otiai10/mint v1.6.3 h1:87qsV/aw1F5as1eH1zS/yqHY85ANKVMgkDrf9rcxbQs=\ngithub.com/otiai10/mint v1.6.3/go.mod h1:MJm72SBthJjz8qhefc4z1PYEieWmy8Bku7CjcAqyUSM=\n"
        },
        {
          "name": "hocr.go",
          "type": "blob",
          "size": 1.1845703125,
          "content": "package gosseract\n\n/**\n * NOTE:\n * \tThese structs are the very minimum implementation\n *\tonly to satisfy test assertions.\n * TODO: Extend structs to cover main usecases.\n**/\n\n// Page represents `<div class='ocr_page' />`\ntype Page struct {\n\tID      string  `xml:\"id,attr\"`\n\tTitle   string  `xml:\"title,attr\"`\n\tClass   string  `xml:\"class,attr\"`\n\tContent Content `xml:\"div\"`\n}\n\n// Content represents `<div class='ocr_carea' />`\ntype Content struct {\n\tID    string `xml:\"id,attr\"`\n\tTitle string `xml:\"title,attr\"`\n\tClass string `xml:\"class,attr\"`\n\tPar   Par    `xml:\"p\"`\n}\n\n// Par represents `<p class='ocr_par' />`\ntype Par struct {\n\tID       string `xml:\"id,attr\"`\n\tTitle    string `xml:\"title,attr\"`\n\tClass    string `xml:\"class,attr\"`\n\tLanguage string `xml:\"lang,attr\"`\n\tLines    []Line `xml:\"span\"`\n}\n\n// Line represents `<span class='ocr_line' />`\ntype Line struct {\n\tID    string `xml:\"id,attr\"`\n\tTitle string `xml:\"title,attr\"`\n\tClass string `xml:\"class,attr\"`\n\tWords []Word `xml:\"span\"`\n}\n\n// Word represents `<span class='ocr_word' />`\ntype Word struct {\n\tID         string `xml:\"id,attr\"`\n\tTitle      string `xml:\"title,attr\"`\n\tClass      string `xml:\"class,attr\"`\n\tCharacters string `xml:\",chardata\"`\n}\n"
        },
        {
          "name": "preprocessflags_darwin.go",
          "type": "blob",
          "size": 0.2314453125,
          "content": "package gosseract\n\n// #cgo CXXFLAGS: -std=c++0x\n// #cgo CPPFLAGS: -I/opt/homebrew/include -I/usr/local/include\n// #cgo CPPFLAGS: -Wno-unused-result\n// #cgo LDFLAGS: -L/opt/homebrew/lib -L/usr/local/lib -lleptonica -ltesseract\nimport \"C\"\n"
        },
        {
          "name": "preprocessflags_freebsd.go",
          "type": "blob",
          "size": 0.08984375,
          "content": "package gosseract\n\n// #cgo LDFLAGS: -L/usr/local/lib -llept -ltesseract -fopenmp\nimport \"C\"\n"
        },
        {
          "name": "preprocessflags_x.go",
          "type": "blob",
          "size": 0.2080078125,
          "content": "//go:build !darwin\n\npackage gosseract\n\n// #cgo CXXFLAGS: -std=c++0x\n// #cgo CPPFLAGS: -I/usr/local/include\n// #cgo CPPFLAGS: -Wno-unused-result\n// #cgo LDFLAGS: -L/usr/local/lib -lleptonica -ltesseract\nimport \"C\"\n"
        },
        {
          "name": "tessbridge.cpp",
          "type": "blob",
          "size": 7.1591796875,
          "content": "#if __FreeBSD__ >= 10\n#include \"/usr/local/include/leptonica/allheaders.h\"\n#include \"/usr/local/include/tesseract/baseapi.h\"\n#else\n#include <leptonica/allheaders.h>\n#include <tesseract/baseapi.h>\n#endif\n\n#include <stdio.h>\n#include <unistd.h>\n#include \"tessbridge.h\"\n\nTessBaseAPI Create() {\n    tesseract::TessBaseAPI* api = new tesseract::TessBaseAPI();\n    return (void*)api;\n}\n\nvoid Free(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    if (api != nullptr) {\n        api->End();\n        delete api;\n    }\n}\n\nvoid Clear(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    if (api != nullptr) {\n        api->Clear();\n    }\n}\n\nvoid ClearPersistentCache(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    api->ClearPersistentCache();\n}\n\nint Init(TessBaseAPI a, char* tessdataprefix, char* languages) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    return api->Init(tessdataprefix, languages);\n}\n\nint Init(TessBaseAPI a, char* tessdataprefix, char* languages, char* configfilepath, char* errbuf) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n\n    // {{{ Redirect STDERR to given buffer\n    fflush(stderr);\n    int original_stderr;\n    original_stderr = dup(STDERR_FILENO);\n    (void)freopen(\"/dev/null\", \"a\", stderr);\n    setbuf(stderr, errbuf);\n    // }}}\n\n    int ret;\n    if (configfilepath != NULL) {\n        char* configs[] = {configfilepath};\n        int configs_size = 1;\n        ret = api->Init(tessdataprefix, languages, tesseract::OEM_DEFAULT, configs, configs_size, NULL, NULL, false);\n    } else {\n        ret = api->Init(tessdataprefix, languages);\n    }\n\n    // {{{ Restore default stderr\n    (void)freopen(\"/dev/null\", \"a\", stderr);\n    dup2(original_stderr, STDERR_FILENO);\n    close(original_stderr);\n    setbuf(stderr, NULL);\n    // }}}\n\n    return ret;\n}\n\nbool SetVariable(TessBaseAPI a, char* name, char* value) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    return api->SetVariable(name, value);\n}\n\nvoid SetPixImage(TessBaseAPI a, PixImage pix) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    Pix* image = (Pix*)pix;\n    api->SetImage(image);\n    if (api->GetSourceYResolution() < 70) {\n        api->SetSourceResolution(70);\n    }\n}\n\nvoid SetPageSegMode(TessBaseAPI a, int m) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    tesseract::PageSegMode mode = (tesseract::PageSegMode)m;\n    api->SetPageSegMode(mode);\n}\n\nint GetPageSegMode(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    return api->GetPageSegMode();\n}\n\nchar* UTF8Text(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    return api->GetUTF8Text();\n}\n\nchar* HOCRText(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    return api->GetHOCRText(0);\n}\n\nbounding_boxes* GetBoundingBoxesVerbose(TessBaseAPI a) {\n    using namespace tesseract;\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    struct bounding_boxes* box_array;\n    box_array = (bounding_boxes*)malloc(sizeof(bounding_boxes));\n    // linearly resize boxes array\n    int realloc_threshold = 900;\n    int realloc_raise = 1000;\n    int capacity = 1000;\n    box_array->boxes = (bounding_box*)malloc(capacity * sizeof(bounding_box));\n    box_array->length = 0;\n    api->Recognize(NULL);\n    int block_num = 0;\n    int par_num = 0;\n    int line_num = 0;\n    int word_num = 0;\n\n    ResultIterator* res_it = api->GetIterator();\n    while (!res_it->Empty(RIL_BLOCK)) {\n        if (res_it->Empty(RIL_WORD)) {\n            res_it->Next(RIL_WORD);\n            continue;\n        }\n        // Add rows for any new block/paragraph/textline.\n        if (res_it->IsAtBeginningOf(RIL_BLOCK)) {\n            block_num++;\n            par_num = 0;\n            line_num = 0;\n            word_num = 0;\n        }\n        if (res_it->IsAtBeginningOf(RIL_PARA)) {\n            par_num++;\n            line_num = 0;\n            word_num = 0;\n        }\n        if (res_it->IsAtBeginningOf(RIL_TEXTLINE)) {\n            line_num++;\n            word_num = 0;\n        }\n        word_num++;\n\n        if (box_array->length >= realloc_threshold) {\n            capacity += realloc_raise;\n            box_array->boxes = (bounding_box*)realloc(box_array->boxes, capacity * sizeof(bounding_box));\n            realloc_threshold += realloc_raise;\n        }\n\n        box_array->boxes[box_array->length].word = res_it->GetUTF8Text(RIL_WORD);\n        box_array->boxes[box_array->length].confidence = res_it->Confidence(RIL_WORD);\n        res_it->BoundingBox(RIL_WORD, &box_array->boxes[box_array->length].x1, &box_array->boxes[box_array->length].y1,\n                            &box_array->boxes[box_array->length].x2, &box_array->boxes[box_array->length].y2);\n\n        // block, para, line, word numbers\n        box_array->boxes[box_array->length].block_num = block_num;\n        box_array->boxes[box_array->length].par_num = par_num;\n        box_array->boxes[box_array->length].line_num = line_num;\n        box_array->boxes[box_array->length].word_num = word_num;\n\n        box_array->length++;\n        res_it->Next(RIL_WORD);\n    }\n\n    return box_array;\n}\n\nbounding_boxes* GetBoundingBoxes(TessBaseAPI a, int pageIteratorLevel) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    struct bounding_boxes* box_array;\n    box_array = (bounding_boxes*)malloc(sizeof(bounding_boxes));\n    // linearly resize boxes array\n    int realloc_threshold = 900;\n    int realloc_raise = 1000;\n    int capacity = 1000;\n    box_array->boxes = (bounding_box*)malloc(capacity * sizeof(bounding_box));\n    box_array->length = 0;\n    api->Recognize(NULL);\n    tesseract::ResultIterator* ri = api->GetIterator();\n    tesseract::PageIteratorLevel level = (tesseract::PageIteratorLevel)pageIteratorLevel;\n\n    if (ri != 0) {\n        do {\n            if (box_array->length >= realloc_threshold) {\n                capacity += realloc_raise;\n                box_array->boxes = (bounding_box*)realloc(box_array->boxes, capacity * sizeof(bounding_box));\n                realloc_threshold += realloc_raise;\n            }\n            box_array->boxes[box_array->length].word = ri->GetUTF8Text(level);\n            box_array->boxes[box_array->length].confidence = ri->Confidence(level);\n            ri->BoundingBox(level, &box_array->boxes[box_array->length].x1, &box_array->boxes[box_array->length].y1,\n                            &box_array->boxes[box_array->length].x2, &box_array->boxes[box_array->length].y2);\n            box_array->length++;\n        } while (ri->Next(level));\n    }\n\n    return box_array;\n}\n\nconst char* Version(TessBaseAPI a) {\n    tesseract::TessBaseAPI* api = (tesseract::TessBaseAPI*)a;\n    const char* v = api->Version();\n    return v;\n}\n\nPixImage CreatePixImageByFilePath(char* imagepath) {\n    Pix* image = pixRead(imagepath);\n    return (void*)image;\n}\n\nPixImage CreatePixImageFromBytes(unsigned char* data, int size) {\n    Pix* image = pixReadMem(data, (size_t)size);\n    return (void*)image;\n}\n\nvoid DestroyPixImage(PixImage pix) {\n    Pix* img = (Pix*)pix;\n    pixDestroy(&img);\n}\n\nconst char* GetDataPath() {\n    static tesseract::TessBaseAPI api;\n    api.Init(nullptr, nullptr);\n    return api.GetDatapath();\n}\n"
        },
        {
          "name": "tessbridge.h",
          "type": "blob",
          "size": 1.029296875,
          "content": "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void* TessBaseAPI;\ntypedef void* PixImage;\n\nstruct bounding_box {\n    int x1, y1, x2, y2;\n    char* word;\n    float confidence;\n    int block_num, par_num, line_num, word_num;\n};\n\nstruct bounding_boxes {\n    int length;\n    struct bounding_box* boxes;\n};\n\nTessBaseAPI Create(void);\n\nvoid Free(TessBaseAPI);\nvoid Clear(TessBaseAPI);\nvoid ClearPersistentCache(TessBaseAPI);\nint Init(TessBaseAPI, char*, char*, char*, char*);\nstruct bounding_boxes* GetBoundingBoxes(TessBaseAPI, int);\nstruct bounding_boxes* GetBoundingBoxesVerbose(TessBaseAPI);\nbool SetVariable(TessBaseAPI, char*, char*);\nvoid SetPixImage(TessBaseAPI a, PixImage pix);\nvoid SetPageSegMode(TessBaseAPI, int);\nint GetPageSegMode(TessBaseAPI);\nchar* UTF8Text(TessBaseAPI);\nchar* HOCRText(TessBaseAPI);\nconst char* Version(TessBaseAPI);\nconst char* GetDataPath();\n\nPixImage CreatePixImageByFilePath(char*);\nPixImage CreatePixImageFromBytes(unsigned char*, int);\nvoid DestroyPixImage(PixImage pix);\n\n#ifdef __cplusplus\n}\n#endif /* extern \"C\" */\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}