{
  "metadata": {
    "timestamp": 1736566566410,
    "page": 114,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fogleman/gg",
      "stars": 4470,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0068359375,
          "content": "*.png\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (C) 2016 Michael Fogleman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.046875,
          "content": "# Go Graphics\n\n`gg` is a library for rendering 2D graphics in pure Go.\n\n![Stars](http://i.imgur.com/CylQIJt.png)\n\n## Installation\n\n    go get -u github.com/fogleman/gg\n\nAlternatively, you may use gopkg.in to grab a specific major-version:\n\n    go get -u gopkg.in/fogleman/gg.v1\n\n## Documentation\n\n- godoc: https://godoc.org/github.com/fogleman/gg\n- pkg.go.dev: https://pkg.go.dev/github.com/fogleman/gg?tab=doc\n\n## Hello, Circle!\n\nLook how easy!\n\n```go\npackage main\n\nimport \"github.com/fogleman/gg\"\n\nfunc main() {\n    dc := gg.NewContext(1000, 1000)\n    dc.DrawCircle(500, 500, 400)\n    dc.SetRGB(0, 0, 0)\n    dc.Fill()\n    dc.SavePNG(\"out.png\")\n}\n```\n\n## Examples\n\nThere are [lots of examples](https://github.com/fogleman/gg/tree/master/examples) included. They're mostly for testing the code, but they're good for learning, too.\n\n![Examples](http://i.imgur.com/tMFoyzu.png)\n\n## Creating Contexts\n\nThere are a few ways of creating a context.\n\n```go\nNewContext(width, height int) *Context\nNewContextForImage(im image.Image) *Context\nNewContextForRGBA(im *image.RGBA) *Context\n```\n\n## Drawing Functions\n\nEver used a graphics library that didn't have functions for drawing rectangles\nor circles? What a pain!\n\n```go\nDrawPoint(x, y, r float64)\nDrawLine(x1, y1, x2, y2 float64)\nDrawRectangle(x, y, w, h float64)\nDrawRoundedRectangle(x, y, w, h, r float64)\nDrawCircle(x, y, r float64)\nDrawArc(x, y, r, angle1, angle2 float64)\nDrawEllipse(x, y, rx, ry float64)\nDrawEllipticalArc(x, y, rx, ry, angle1, angle2 float64)\nDrawRegularPolygon(n int, x, y, r, rotation float64)\nDrawImage(im image.Image, x, y int)\nDrawImageAnchored(im image.Image, x, y int, ax, ay float64)\nSetPixel(x, y int)\n\nMoveTo(x, y float64)\nLineTo(x, y float64)\nQuadraticTo(x1, y1, x2, y2 float64)\nCubicTo(x1, y1, x2, y2, x3, y3 float64)\nClosePath()\nClearPath()\nNewSubPath()\n\nClear()\nStroke()\nFill()\nStrokePreserve()\nFillPreserve()\n```\n\nIt is often desired to center an image at a point. Use `DrawImageAnchored` with `ax` and `ay` set to 0.5 to do this. Use 0 to left or top align. Use 1 to right or bottom align. `DrawStringAnchored` does the same for text, so you don't need to call `MeasureString` yourself.\n\n## Text Functions\n\nIt will even do word wrap for you!\n\n```go\nDrawString(s string, x, y float64)\nDrawStringAnchored(s string, x, y, ax, ay float64)\nDrawStringWrapped(s string, x, y, ax, ay, width, lineSpacing float64, align Align)\nMeasureString(s string) (w, h float64)\nMeasureMultilineString(s string, lineSpacing float64) (w, h float64)\nWordWrap(s string, w float64) []string\nSetFontFace(fontFace font.Face)\nLoadFontFace(path string, points float64) error\n```\n\n## Color Functions\n\nColors can be set in several different ways for your convenience.\n\n```go\nSetRGB(r, g, b float64)\nSetRGBA(r, g, b, a float64)\nSetRGB255(r, g, b int)\nSetRGBA255(r, g, b, a int)\nSetColor(c color.Color)\nSetHexColor(x string)\n```\n\n## Stroke & Fill Options\n\n```go\nSetLineWidth(lineWidth float64)\nSetLineCap(lineCap LineCap)\nSetLineJoin(lineJoin LineJoin)\nSetDash(dashes ...float64)\nSetDashOffset(offset float64)\nSetFillRule(fillRule FillRule)\n```\n\n## Gradients & Patterns\n\n`gg` supports linear, radial and conic gradients and surface patterns. You can also implement your own patterns.\n\n```go\nSetFillStyle(pattern Pattern)\nSetStrokeStyle(pattern Pattern)\nNewSolidPattern(color color.Color)\nNewLinearGradient(x0, y0, x1, y1 float64)\nNewRadialGradient(x0, y0, r0, x1, y1, r1 float64)\nNewConicGradient(cx, cy, deg float64)\nNewSurfacePattern(im image.Image, op RepeatOp)\n```\n\n## Transformation Functions\n\n```go\nIdentity()\nTranslate(x, y float64)\nScale(x, y float64)\nRotate(angle float64)\nShear(x, y float64)\nScaleAbout(sx, sy, x, y float64)\nRotateAbout(angle, x, y float64)\nShearAbout(sx, sy, x, y float64)\nTransformPoint(x, y float64) (tx, ty float64)\nInvertY()\n```\n\nIt is often desired to rotate or scale about a point that is not the origin. The functions `RotateAbout`, `ScaleAbout`, `ShearAbout` are provided as a convenience.\n\n`InvertY` is provided in case Y should increase from bottom to top vs. the default top to bottom.\n\n## Stack Functions\n\nSave and restore the state of the context. These can be nested.\n\n```go\nPush()\nPop()\n```\n\n## Clipping Functions\n\nUse clipping regions to restrict drawing operations to an area that you\ndefined using paths.\n\n```go\nClip()\nClipPreserve()\nResetClip()\nAsMask() *image.Alpha\nSetMask(mask *image.Alpha)\nInvertMask()\n```\n\n## Helper Functions\n\nSometimes you just don't want to write these yourself.\n\n```go\nRadians(degrees float64) float64\nDegrees(radians float64) float64\nLoadImage(path string) (image.Image, error)\nLoadPNG(path string) (image.Image, error)\nSavePNG(path string, im image.Image) error\n```\n\n![Separator](http://i.imgur.com/fsUvnPB.png)\n\n## Another Example\n\nSee the output of this example below.\n\n```go\npackage main\n\nimport \"github.com/fogleman/gg\"\n\nfunc main() {\n\tconst S = 1024\n\tdc := gg.NewContext(S, S)\n\tdc.SetRGBA(0, 0, 0, 0.1)\n\tfor i := 0; i < 360; i += 15 {\n\t\tdc.Push()\n\t\tdc.RotateAbout(gg.Radians(float64(i)), S/2, S/2)\n\t\tdc.DrawEllipse(S/2, S/2, S*7/16, S/8)\n\t\tdc.Fill()\n\t\tdc.Pop()\n\t}\n\tdc.SavePNG(\"out.png\")\n}\n```\n\n![Ellipses](http://i.imgur.com/J9CBZef.png)\n"
        },
        {
          "name": "bezier.go",
          "type": "blob",
          "size": 1.1572265625,
          "content": "package gg\n\nimport \"math\"\n\nfunc quadratic(x0, y0, x1, y1, x2, y2, t float64) (x, y float64) {\n\tu := 1 - t\n\ta := u * u\n\tb := 2 * u * t\n\tc := t * t\n\tx = a*x0 + b*x1 + c*x2\n\ty = a*y0 + b*y1 + c*y2\n\treturn\n}\n\nfunc QuadraticBezier(x0, y0, x1, y1, x2, y2 float64) []Point {\n\tl := (math.Hypot(x1-x0, y1-y0) +\n\t\tmath.Hypot(x2-x1, y2-y1))\n\tn := int(l + 0.5)\n\tif n < 4 {\n\t\tn = 4\n\t}\n\td := float64(n) - 1\n\tresult := make([]Point, n)\n\tfor i := 0; i < n; i++ {\n\t\tt := float64(i) / d\n\t\tx, y := quadratic(x0, y0, x1, y1, x2, y2, t)\n\t\tresult[i] = Point{x, y}\n\t}\n\treturn result\n}\n\nfunc cubic(x0, y0, x1, y1, x2, y2, x3, y3, t float64) (x, y float64) {\n\tu := 1 - t\n\ta := u * u * u\n\tb := 3 * u * u * t\n\tc := 3 * u * t * t\n\td := t * t * t\n\tx = a*x0 + b*x1 + c*x2 + d*x3\n\ty = a*y0 + b*y1 + c*y2 + d*y3\n\treturn\n}\n\nfunc CubicBezier(x0, y0, x1, y1, x2, y2, x3, y3 float64) []Point {\n\tl := (math.Hypot(x1-x0, y1-y0) +\n\t\tmath.Hypot(x2-x1, y2-y1) +\n\t\tmath.Hypot(x3-x2, y3-y2))\n\tn := int(l + 0.5)\n\tif n < 4 {\n\t\tn = 4\n\t}\n\td := float64(n) - 1\n\tresult := make([]Point, n)\n\tfor i := 0; i < n; i++ {\n\t\tt := float64(i) / d\n\t\tx, y := cubic(x0, y0, x1, y1, x2, y2, x3, y3, t)\n\t\tresult[i] = Point{x, y}\n\t}\n\treturn result\n}\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 24.353515625,
          "content": "// Package gg provides a simple API for rendering 2D graphics in pure Go.\npackage gg\n\nimport (\n\t\"errors\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"io\"\n\t\"math\"\n\t\"strings\"\n\n\t\"github.com/golang/freetype/raster\"\n\t\"golang.org/x/image/draw\"\n\t\"golang.org/x/image/font\"\n\t\"golang.org/x/image/font/basicfont\"\n\t\"golang.org/x/image/math/f64\"\n)\n\ntype LineCap int\n\nconst (\n\tLineCapRound LineCap = iota\n\tLineCapButt\n\tLineCapSquare\n)\n\ntype LineJoin int\n\nconst (\n\tLineJoinRound LineJoin = iota\n\tLineJoinBevel\n)\n\ntype FillRule int\n\nconst (\n\tFillRuleWinding FillRule = iota\n\tFillRuleEvenOdd\n)\n\ntype Align int\n\nconst (\n\tAlignLeft Align = iota\n\tAlignCenter\n\tAlignRight\n)\n\nvar (\n\tdefaultFillStyle   = NewSolidPattern(color.White)\n\tdefaultStrokeStyle = NewSolidPattern(color.Black)\n)\n\ntype Context struct {\n\twidth         int\n\theight        int\n\trasterizer    *raster.Rasterizer\n\tim            *image.RGBA\n\tmask          *image.Alpha\n\tcolor         color.Color\n\tfillPattern   Pattern\n\tstrokePattern Pattern\n\tstrokePath    raster.Path\n\tfillPath      raster.Path\n\tstart         Point\n\tcurrent       Point\n\thasCurrent    bool\n\tdashes        []float64\n\tdashOffset    float64\n\tlineWidth     float64\n\tlineCap       LineCap\n\tlineJoin      LineJoin\n\tfillRule      FillRule\n\tfontFace      font.Face\n\tfontHeight    float64\n\tmatrix        Matrix\n\tstack         []*Context\n}\n\n// NewContext creates a new image.RGBA with the specified width and height\n// and prepares a context for rendering onto that image.\nfunc NewContext(width, height int) *Context {\n\treturn NewContextForRGBA(image.NewRGBA(image.Rect(0, 0, width, height)))\n}\n\n// NewContextForImage copies the specified image into a new image.RGBA\n// and prepares a context for rendering onto that image.\nfunc NewContextForImage(im image.Image) *Context {\n\treturn NewContextForRGBA(imageToRGBA(im))\n}\n\n// NewContextForRGBA prepares a context for rendering onto the specified image.\n// No copy is made.\nfunc NewContextForRGBA(im *image.RGBA) *Context {\n\tw := im.Bounds().Size().X\n\th := im.Bounds().Size().Y\n\treturn &Context{\n\t\twidth:         w,\n\t\theight:        h,\n\t\trasterizer:    raster.NewRasterizer(w, h),\n\t\tim:            im,\n\t\tcolor:         color.Transparent,\n\t\tfillPattern:   defaultFillStyle,\n\t\tstrokePattern: defaultStrokeStyle,\n\t\tlineWidth:     1,\n\t\tfillRule:      FillRuleWinding,\n\t\tfontFace:      basicfont.Face7x13,\n\t\tfontHeight:    13,\n\t\tmatrix:        Identity(),\n\t}\n}\n\n// GetCurrentPoint will return the current point and if there is a current point.\n// The point will have been transformed by the context's transformation matrix.\nfunc (dc *Context) GetCurrentPoint() (Point, bool) {\n\tif dc.hasCurrent {\n\t\treturn dc.current, true\n\t}\n\treturn Point{}, false\n}\n\n// Image returns the image that has been drawn by this context.\nfunc (dc *Context) Image() image.Image {\n\treturn dc.im\n}\n\n// Width returns the width of the image in pixels.\nfunc (dc *Context) Width() int {\n\treturn dc.width\n}\n\n// Height returns the height of the image in pixels.\nfunc (dc *Context) Height() int {\n\treturn dc.height\n}\n\n// SavePNG encodes the image as a PNG and writes it to disk.\nfunc (dc *Context) SavePNG(path string) error {\n\treturn SavePNG(path, dc.im)\n}\n\n// SaveJPG encodes the image as a JPG and writes it to disk.\nfunc (dc *Context) SaveJPG(path string, quality int) error {\n\treturn SaveJPG(path, dc.im, quality)\n}\n\n// EncodePNG encodes the image as a PNG and writes it to the provided io.Writer.\nfunc (dc *Context) EncodePNG(w io.Writer) error {\n\treturn png.Encode(w, dc.im)\n}\n\n// EncodeJPG encodes the image as a JPG and writes it to the provided io.Writer\n// in JPEG 4:2:0 baseline format with the given options.\n// Default parameters are used if a nil *jpeg.Options is passed.\nfunc (dc *Context) EncodeJPG(w io.Writer, o *jpeg.Options) error {\n\treturn jpeg.Encode(w, dc.im, o)\n}\n\n// SetDash sets the current dash pattern to use. Call with zero arguments to\n// disable dashes. The values specify the lengths of each dash, with\n// alternating on and off lengths.\nfunc (dc *Context) SetDash(dashes ...float64) {\n\tdc.dashes = dashes\n}\n\n// SetDashOffset sets the initial offset into the dash pattern to use when\n// stroking dashed paths.\nfunc (dc *Context) SetDashOffset(offset float64) {\n\tdc.dashOffset = offset\n}\n\nfunc (dc *Context) SetLineWidth(lineWidth float64) {\n\tdc.lineWidth = lineWidth\n}\n\nfunc (dc *Context) SetLineCap(lineCap LineCap) {\n\tdc.lineCap = lineCap\n}\n\nfunc (dc *Context) SetLineCapRound() {\n\tdc.lineCap = LineCapRound\n}\n\nfunc (dc *Context) SetLineCapButt() {\n\tdc.lineCap = LineCapButt\n}\n\nfunc (dc *Context) SetLineCapSquare() {\n\tdc.lineCap = LineCapSquare\n}\n\nfunc (dc *Context) SetLineJoin(lineJoin LineJoin) {\n\tdc.lineJoin = lineJoin\n}\n\nfunc (dc *Context) SetLineJoinRound() {\n\tdc.lineJoin = LineJoinRound\n}\n\nfunc (dc *Context) SetLineJoinBevel() {\n\tdc.lineJoin = LineJoinBevel\n}\n\nfunc (dc *Context) SetFillRule(fillRule FillRule) {\n\tdc.fillRule = fillRule\n}\n\nfunc (dc *Context) SetFillRuleWinding() {\n\tdc.fillRule = FillRuleWinding\n}\n\nfunc (dc *Context) SetFillRuleEvenOdd() {\n\tdc.fillRule = FillRuleEvenOdd\n}\n\n// Color Setters\n\nfunc (dc *Context) setFillAndStrokeColor(c color.Color) {\n\tdc.color = c\n\tdc.fillPattern = NewSolidPattern(c)\n\tdc.strokePattern = NewSolidPattern(c)\n}\n\n// SetFillStyle sets current fill style\nfunc (dc *Context) SetFillStyle(pattern Pattern) {\n\t// if pattern is SolidPattern, also change dc.color(for dc.Clear, dc.drawString)\n\tif fillStyle, ok := pattern.(*solidPattern); ok {\n\t\tdc.color = fillStyle.color\n\t}\n\tdc.fillPattern = pattern\n}\n\n// SetStrokeStyle sets current stroke style\nfunc (dc *Context) SetStrokeStyle(pattern Pattern) {\n\tdc.strokePattern = pattern\n}\n\n// SetColor sets the current color(for both fill and stroke).\nfunc (dc *Context) SetColor(c color.Color) {\n\tdc.setFillAndStrokeColor(c)\n}\n\n// SetHexColor sets the current color using a hex string. The leading pound\n// sign (#) is optional. Both 3- and 6-digit variations are supported. 8 digits\n// may be provided to set the alpha value as well.\nfunc (dc *Context) SetHexColor(x string) {\n\tr, g, b, a := parseHexColor(x)\n\tdc.SetRGBA255(r, g, b, a)\n}\n\n// SetRGBA255 sets the current color. r, g, b, a values should be between 0 and\n// 255, inclusive.\nfunc (dc *Context) SetRGBA255(r, g, b, a int) {\n\tdc.color = color.NRGBA{uint8(r), uint8(g), uint8(b), uint8(a)}\n\tdc.setFillAndStrokeColor(dc.color)\n}\n\n// SetRGB255 sets the current color. r, g, b values should be between 0 and 255,\n// inclusive. Alpha will be set to 255 (fully opaque).\nfunc (dc *Context) SetRGB255(r, g, b int) {\n\tdc.SetRGBA255(r, g, b, 255)\n}\n\n// SetRGBA sets the current color. r, g, b, a values should be between 0 and 1,\n// inclusive.\nfunc (dc *Context) SetRGBA(r, g, b, a float64) {\n\tdc.color = color.NRGBA{\n\t\tuint8(r * 255),\n\t\tuint8(g * 255),\n\t\tuint8(b * 255),\n\t\tuint8(a * 255),\n\t}\n\tdc.setFillAndStrokeColor(dc.color)\n}\n\n// SetRGB sets the current color. r, g, b values should be between 0 and 1,\n// inclusive. Alpha will be set to 1 (fully opaque).\nfunc (dc *Context) SetRGB(r, g, b float64) {\n\tdc.SetRGBA(r, g, b, 1)\n}\n\n// Path Manipulation\n\n// MoveTo starts a new subpath within the current path starting at the\n// specified point.\nfunc (dc *Context) MoveTo(x, y float64) {\n\tif dc.hasCurrent {\n\t\tdc.fillPath.Add1(dc.start.Fixed())\n\t}\n\tx, y = dc.TransformPoint(x, y)\n\tp := Point{x, y}\n\tdc.strokePath.Start(p.Fixed())\n\tdc.fillPath.Start(p.Fixed())\n\tdc.start = p\n\tdc.current = p\n\tdc.hasCurrent = true\n}\n\n// LineTo adds a line segment to the current path starting at the current\n// point. If there is no current point, it is equivalent to MoveTo(x, y)\nfunc (dc *Context) LineTo(x, y float64) {\n\tif !dc.hasCurrent {\n\t\tdc.MoveTo(x, y)\n\t} else {\n\t\tx, y = dc.TransformPoint(x, y)\n\t\tp := Point{x, y}\n\t\tdc.strokePath.Add1(p.Fixed())\n\t\tdc.fillPath.Add1(p.Fixed())\n\t\tdc.current = p\n\t}\n}\n\n// QuadraticTo adds a quadratic bezier curve to the current path starting at\n// the current point. If there is no current point, it first performs\n// MoveTo(x1, y1)\nfunc (dc *Context) QuadraticTo(x1, y1, x2, y2 float64) {\n\tif !dc.hasCurrent {\n\t\tdc.MoveTo(x1, y1)\n\t}\n\tx1, y1 = dc.TransformPoint(x1, y1)\n\tx2, y2 = dc.TransformPoint(x2, y2)\n\tp1 := Point{x1, y1}\n\tp2 := Point{x2, y2}\n\tdc.strokePath.Add2(p1.Fixed(), p2.Fixed())\n\tdc.fillPath.Add2(p1.Fixed(), p2.Fixed())\n\tdc.current = p2\n}\n\n// CubicTo adds a cubic bezier curve to the current path starting at the\n// current point. If there is no current point, it first performs\n// MoveTo(x1, y1). Because freetype/raster does not support cubic beziers,\n// this is emulated with many small line segments.\nfunc (dc *Context) CubicTo(x1, y1, x2, y2, x3, y3 float64) {\n\tif !dc.hasCurrent {\n\t\tdc.MoveTo(x1, y1)\n\t}\n\tx0, y0 := dc.current.X, dc.current.Y\n\tx1, y1 = dc.TransformPoint(x1, y1)\n\tx2, y2 = dc.TransformPoint(x2, y2)\n\tx3, y3 = dc.TransformPoint(x3, y3)\n\tpoints := CubicBezier(x0, y0, x1, y1, x2, y2, x3, y3)\n\tprevious := dc.current.Fixed()\n\tfor _, p := range points[1:] {\n\t\tf := p.Fixed()\n\t\tif f == previous {\n\t\t\t// TODO: this fixes some rendering issues but not all\n\t\t\tcontinue\n\t\t}\n\t\tprevious = f\n\t\tdc.strokePath.Add1(f)\n\t\tdc.fillPath.Add1(f)\n\t\tdc.current = p\n\t}\n}\n\n// ClosePath adds a line segment from the current point to the beginning\n// of the current subpath. If there is no current point, this is a no-op.\nfunc (dc *Context) ClosePath() {\n\tif dc.hasCurrent {\n\t\tdc.strokePath.Add1(dc.start.Fixed())\n\t\tdc.fillPath.Add1(dc.start.Fixed())\n\t\tdc.current = dc.start\n\t}\n}\n\n// ClearPath clears the current path. There is no current point after this\n// operation.\nfunc (dc *Context) ClearPath() {\n\tdc.strokePath.Clear()\n\tdc.fillPath.Clear()\n\tdc.hasCurrent = false\n}\n\n// NewSubPath starts a new subpath within the current path. There is no current\n// point after this operation.\nfunc (dc *Context) NewSubPath() {\n\tif dc.hasCurrent {\n\t\tdc.fillPath.Add1(dc.start.Fixed())\n\t}\n\tdc.hasCurrent = false\n}\n\n// Path Drawing\n\nfunc (dc *Context) capper() raster.Capper {\n\tswitch dc.lineCap {\n\tcase LineCapButt:\n\t\treturn raster.ButtCapper\n\tcase LineCapRound:\n\t\treturn raster.RoundCapper\n\tcase LineCapSquare:\n\t\treturn raster.SquareCapper\n\t}\n\treturn nil\n}\n\nfunc (dc *Context) joiner() raster.Joiner {\n\tswitch dc.lineJoin {\n\tcase LineJoinBevel:\n\t\treturn raster.BevelJoiner\n\tcase LineJoinRound:\n\t\treturn raster.RoundJoiner\n\t}\n\treturn nil\n}\n\nfunc (dc *Context) stroke(painter raster.Painter) {\n\tpath := dc.strokePath\n\tif len(dc.dashes) > 0 {\n\t\tpath = dashed(path, dc.dashes, dc.dashOffset)\n\t} else {\n\t\t// TODO: this is a temporary workaround to remove tiny segments\n\t\t// that result in rendering issues\n\t\tpath = rasterPath(flattenPath(path))\n\t}\n\tr := dc.rasterizer\n\tr.UseNonZeroWinding = true\n\tr.Clear()\n\tr.AddStroke(path, fix(dc.lineWidth), dc.capper(), dc.joiner())\n\tr.Rasterize(painter)\n}\n\nfunc (dc *Context) fill(painter raster.Painter) {\n\tpath := dc.fillPath\n\tif dc.hasCurrent {\n\t\tpath = make(raster.Path, len(dc.fillPath))\n\t\tcopy(path, dc.fillPath)\n\t\tpath.Add1(dc.start.Fixed())\n\t}\n\tr := dc.rasterizer\n\tr.UseNonZeroWinding = dc.fillRule == FillRuleWinding\n\tr.Clear()\n\tr.AddPath(path)\n\tr.Rasterize(painter)\n}\n\n// StrokePreserve strokes the current path with the current color, line width,\n// line cap, line join and dash settings. The path is preserved after this\n// operation.\nfunc (dc *Context) StrokePreserve() {\n\tvar painter raster.Painter\n\tif dc.mask == nil {\n\t\tif pattern, ok := dc.strokePattern.(*solidPattern); ok {\n\t\t\t// with a nil mask and a solid color pattern, we can be more efficient\n\t\t\t// TODO: refactor so we don't have to do this type assertion stuff?\n\t\t\tp := raster.NewRGBAPainter(dc.im)\n\t\t\tp.SetColor(pattern.color)\n\t\t\tpainter = p\n\t\t}\n\t}\n\tif painter == nil {\n\t\tpainter = newPatternPainter(dc.im, dc.mask, dc.strokePattern)\n\t}\n\tdc.stroke(painter)\n}\n\n// Stroke strokes the current path with the current color, line width,\n// line cap, line join and dash settings. The path is cleared after this\n// operation.\nfunc (dc *Context) Stroke() {\n\tdc.StrokePreserve()\n\tdc.ClearPath()\n}\n\n// FillPreserve fills the current path with the current color. Open subpaths\n// are implicity closed. The path is preserved after this operation.\nfunc (dc *Context) FillPreserve() {\n\tvar painter raster.Painter\n\tif dc.mask == nil {\n\t\tif pattern, ok := dc.fillPattern.(*solidPattern); ok {\n\t\t\t// with a nil mask and a solid color pattern, we can be more efficient\n\t\t\t// TODO: refactor so we don't have to do this type assertion stuff?\n\t\t\tp := raster.NewRGBAPainter(dc.im)\n\t\t\tp.SetColor(pattern.color)\n\t\t\tpainter = p\n\t\t}\n\t}\n\tif painter == nil {\n\t\tpainter = newPatternPainter(dc.im, dc.mask, dc.fillPattern)\n\t}\n\tdc.fill(painter)\n}\n\n// Fill fills the current path with the current color. Open subpaths\n// are implicity closed. The path is cleared after this operation.\nfunc (dc *Context) Fill() {\n\tdc.FillPreserve()\n\tdc.ClearPath()\n}\n\n// ClipPreserve updates the clipping region by intersecting the current\n// clipping region with the current path as it would be filled by dc.Fill().\n// The path is preserved after this operation.\nfunc (dc *Context) ClipPreserve() {\n\tclip := image.NewAlpha(image.Rect(0, 0, dc.width, dc.height))\n\tpainter := raster.NewAlphaOverPainter(clip)\n\tdc.fill(painter)\n\tif dc.mask == nil {\n\t\tdc.mask = clip\n\t} else {\n\t\tmask := image.NewAlpha(image.Rect(0, 0, dc.width, dc.height))\n\t\tdraw.DrawMask(mask, mask.Bounds(), clip, image.ZP, dc.mask, image.ZP, draw.Over)\n\t\tdc.mask = mask\n\t}\n}\n\n// SetMask allows you to directly set the *image.Alpha to be used as a clipping\n// mask. It must be the same size as the context, else an error is returned\n// and the mask is unchanged.\nfunc (dc *Context) SetMask(mask *image.Alpha) error {\n\tif mask.Bounds().Size() != dc.im.Bounds().Size() {\n\t\treturn errors.New(\"mask size must match context size\")\n\t}\n\tdc.mask = mask\n\treturn nil\n}\n\n// AsMask returns an *image.Alpha representing the alpha channel of this\n// context. This can be useful for advanced clipping operations where you first\n// render the mask geometry and then use it as a mask.\nfunc (dc *Context) AsMask() *image.Alpha {\n\tmask := image.NewAlpha(dc.im.Bounds())\n\tdraw.Draw(mask, dc.im.Bounds(), dc.im, image.ZP, draw.Src)\n\treturn mask\n}\n\n// InvertMask inverts the alpha values in the current clipping mask such that\n// a fully transparent region becomes fully opaque and vice versa.\nfunc (dc *Context) InvertMask() {\n\tif dc.mask == nil {\n\t\tdc.mask = image.NewAlpha(dc.im.Bounds())\n\t} else {\n\t\tfor i, a := range dc.mask.Pix {\n\t\t\tdc.mask.Pix[i] = 255 - a\n\t\t}\n\t}\n}\n\n// Clip updates the clipping region by intersecting the current\n// clipping region with the current path as it would be filled by dc.Fill().\n// The path is cleared after this operation.\nfunc (dc *Context) Clip() {\n\tdc.ClipPreserve()\n\tdc.ClearPath()\n}\n\n// ResetClip clears the clipping region.\nfunc (dc *Context) ResetClip() {\n\tdc.mask = nil\n}\n\n// Convenient Drawing Functions\n\n// Clear fills the entire image with the current color.\nfunc (dc *Context) Clear() {\n\tsrc := image.NewUniform(dc.color)\n\tdraw.Draw(dc.im, dc.im.Bounds(), src, image.ZP, draw.Src)\n}\n\n// SetPixel sets the color of the specified pixel using the current color.\nfunc (dc *Context) SetPixel(x, y int) {\n\tdc.im.Set(x, y, dc.color)\n}\n\n// DrawPoint is like DrawCircle but ensures that a circle of the specified\n// size is drawn regardless of the current transformation matrix. The position\n// is still transformed, but not the shape of the point.\nfunc (dc *Context) DrawPoint(x, y, r float64) {\n\tdc.Push()\n\ttx, ty := dc.TransformPoint(x, y)\n\tdc.Identity()\n\tdc.DrawCircle(tx, ty, r)\n\tdc.Pop()\n}\n\nfunc (dc *Context) DrawLine(x1, y1, x2, y2 float64) {\n\tdc.MoveTo(x1, y1)\n\tdc.LineTo(x2, y2)\n}\n\nfunc (dc *Context) DrawRectangle(x, y, w, h float64) {\n\tdc.NewSubPath()\n\tdc.MoveTo(x, y)\n\tdc.LineTo(x+w, y)\n\tdc.LineTo(x+w, y+h)\n\tdc.LineTo(x, y+h)\n\tdc.ClosePath()\n}\n\nfunc (dc *Context) DrawRoundedRectangle(x, y, w, h, r float64) {\n\tx0, x1, x2, x3 := x, x+r, x+w-r, x+w\n\ty0, y1, y2, y3 := y, y+r, y+h-r, y+h\n\tdc.NewSubPath()\n\tdc.MoveTo(x1, y0)\n\tdc.LineTo(x2, y0)\n\tdc.DrawArc(x2, y1, r, Radians(270), Radians(360))\n\tdc.LineTo(x3, y2)\n\tdc.DrawArc(x2, y2, r, Radians(0), Radians(90))\n\tdc.LineTo(x1, y3)\n\tdc.DrawArc(x1, y2, r, Radians(90), Radians(180))\n\tdc.LineTo(x0, y1)\n\tdc.DrawArc(x1, y1, r, Radians(180), Radians(270))\n\tdc.ClosePath()\n}\n\nfunc (dc *Context) DrawEllipticalArc(x, y, rx, ry, angle1, angle2 float64) {\n\tconst n = 16\n\tfor i := 0; i < n; i++ {\n\t\tp1 := float64(i+0) / n\n\t\tp2 := float64(i+1) / n\n\t\ta1 := angle1 + (angle2-angle1)*p1\n\t\ta2 := angle1 + (angle2-angle1)*p2\n\t\tx0 := x + rx*math.Cos(a1)\n\t\ty0 := y + ry*math.Sin(a1)\n\t\tx1 := x + rx*math.Cos((a1+a2)/2)\n\t\ty1 := y + ry*math.Sin((a1+a2)/2)\n\t\tx2 := x + rx*math.Cos(a2)\n\t\ty2 := y + ry*math.Sin(a2)\n\t\tcx := 2*x1 - x0/2 - x2/2\n\t\tcy := 2*y1 - y0/2 - y2/2\n\t\tif i == 0 {\n\t\t\tif dc.hasCurrent {\n\t\t\t\tdc.LineTo(x0, y0)\n\t\t\t} else {\n\t\t\t\tdc.MoveTo(x0, y0)\n\t\t\t}\n\t\t}\n\t\tdc.QuadraticTo(cx, cy, x2, y2)\n\t}\n}\n\nfunc (dc *Context) DrawEllipse(x, y, rx, ry float64) {\n\tdc.NewSubPath()\n\tdc.DrawEllipticalArc(x, y, rx, ry, 0, 2*math.Pi)\n\tdc.ClosePath()\n}\n\nfunc (dc *Context) DrawArc(x, y, r, angle1, angle2 float64) {\n\tdc.DrawEllipticalArc(x, y, r, r, angle1, angle2)\n}\n\nfunc (dc *Context) DrawCircle(x, y, r float64) {\n\tdc.NewSubPath()\n\tdc.DrawEllipticalArc(x, y, r, r, 0, 2*math.Pi)\n\tdc.ClosePath()\n}\n\nfunc (dc *Context) DrawRegularPolygon(n int, x, y, r, rotation float64) {\n\tangle := 2 * math.Pi / float64(n)\n\trotation -= math.Pi / 2\n\tif n%2 == 0 {\n\t\trotation += angle / 2\n\t}\n\tdc.NewSubPath()\n\tfor i := 0; i < n; i++ {\n\t\ta := rotation + angle*float64(i)\n\t\tdc.LineTo(x+r*math.Cos(a), y+r*math.Sin(a))\n\t}\n\tdc.ClosePath()\n}\n\n// DrawImage draws the specified image at the specified point.\nfunc (dc *Context) DrawImage(im image.Image, x, y int) {\n\tdc.DrawImageAnchored(im, x, y, 0, 0)\n}\n\n// DrawImageAnchored draws the specified image at the specified anchor point.\n// The anchor point is x - w * ax, y - h * ay, where w, h is the size of the\n// image. Use ax=0.5, ay=0.5 to center the image at the specified point.\nfunc (dc *Context) DrawImageAnchored(im image.Image, x, y int, ax, ay float64) {\n\ts := im.Bounds().Size()\n\tx -= int(ax * float64(s.X))\n\ty -= int(ay * float64(s.Y))\n\ttransformer := draw.BiLinear\n\tfx, fy := float64(x), float64(y)\n\tm := dc.matrix.Translate(fx, fy)\n\ts2d := f64.Aff3{m.XX, m.XY, m.X0, m.YX, m.YY, m.Y0}\n\tif dc.mask == nil {\n\t\ttransformer.Transform(dc.im, s2d, im, im.Bounds(), draw.Over, nil)\n\t} else {\n\t\ttransformer.Transform(dc.im, s2d, im, im.Bounds(), draw.Over, &draw.Options{\n\t\t\tDstMask:  dc.mask,\n\t\t\tDstMaskP: image.ZP,\n\t\t})\n\t}\n}\n\n// Text Functions\n\nfunc (dc *Context) SetFontFace(fontFace font.Face) {\n\tdc.fontFace = fontFace\n\tdc.fontHeight = float64(fontFace.Metrics().Height) / 64\n}\n\nfunc (dc *Context) LoadFontFace(path string, points float64) error {\n\tface, err := LoadFontFace(path, points)\n\tif err == nil {\n\t\tdc.fontFace = face\n\t\tdc.fontHeight = points * 72 / 96\n\t}\n\treturn err\n}\n\nfunc (dc *Context) FontHeight() float64 {\n\treturn dc.fontHeight\n}\n\nfunc (dc *Context) drawString(im *image.RGBA, s string, x, y float64) {\n\td := &font.Drawer{\n\t\tDst:  im,\n\t\tSrc:  image.NewUniform(dc.color),\n\t\tFace: dc.fontFace,\n\t\tDot:  fixp(x, y),\n\t}\n\t// based on Drawer.DrawString() in golang.org/x/image/font/font.go\n\tprevC := rune(-1)\n\tfor _, c := range s {\n\t\tif prevC >= 0 {\n\t\t\td.Dot.X += d.Face.Kern(prevC, c)\n\t\t}\n\t\tdr, mask, maskp, advance, ok := d.Face.Glyph(d.Dot, c)\n\t\tif !ok {\n\t\t\t// TODO: is falling back on the U+FFFD glyph the responsibility of\n\t\t\t// the Drawer or the Face?\n\t\t\t// TODO: set prevC = '\\ufffd'?\n\t\t\tcontinue\n\t\t}\n\t\tsr := dr.Sub(dr.Min)\n\t\ttransformer := draw.BiLinear\n\t\tfx, fy := float64(dr.Min.X), float64(dr.Min.Y)\n\t\tm := dc.matrix.Translate(fx, fy)\n\t\ts2d := f64.Aff3{m.XX, m.XY, m.X0, m.YX, m.YY, m.Y0}\n\t\ttransformer.Transform(d.Dst, s2d, d.Src, sr, draw.Over, &draw.Options{\n\t\t\tSrcMask:  mask,\n\t\t\tSrcMaskP: maskp,\n\t\t})\n\t\td.Dot.X += advance\n\t\tprevC = c\n\t}\n}\n\n// DrawString draws the specified text at the specified point.\nfunc (dc *Context) DrawString(s string, x, y float64) {\n\tdc.DrawStringAnchored(s, x, y, 0, 0)\n}\n\n// DrawStringAnchored draws the specified text at the specified anchor point.\n// The anchor point is x - w * ax, y - h * ay, where w, h is the size of the\n// text. Use ax=0.5, ay=0.5 to center the text at the specified point.\nfunc (dc *Context) DrawStringAnchored(s string, x, y, ax, ay float64) {\n\tw, h := dc.MeasureString(s)\n\tx -= ax * w\n\ty += ay * h\n\tif dc.mask == nil {\n\t\tdc.drawString(dc.im, s, x, y)\n\t} else {\n\t\tim := image.NewRGBA(image.Rect(0, 0, dc.width, dc.height))\n\t\tdc.drawString(im, s, x, y)\n\t\tdraw.DrawMask(dc.im, dc.im.Bounds(), im, image.ZP, dc.mask, image.ZP, draw.Over)\n\t}\n}\n\n// DrawStringWrapped word-wraps the specified string to the given max width\n// and then draws it at the specified anchor point using the given line\n// spacing and text alignment.\nfunc (dc *Context) DrawStringWrapped(s string, x, y, ax, ay, width, lineSpacing float64, align Align) {\n\tlines := dc.WordWrap(s, width)\n\n\t// sync h formula with MeasureMultilineString\n\th := float64(len(lines)) * dc.fontHeight * lineSpacing\n\th -= (lineSpacing - 1) * dc.fontHeight\n\n\tx -= ax * width\n\ty -= ay * h\n\tswitch align {\n\tcase AlignLeft:\n\t\tax = 0\n\tcase AlignCenter:\n\t\tax = 0.5\n\t\tx += width / 2\n\tcase AlignRight:\n\t\tax = 1\n\t\tx += width\n\t}\n\tay = 1\n\tfor _, line := range lines {\n\t\tdc.DrawStringAnchored(line, x, y, ax, ay)\n\t\ty += dc.fontHeight * lineSpacing\n\t}\n}\n\nfunc (dc *Context) MeasureMultilineString(s string, lineSpacing float64) (width, height float64) {\n\tlines := strings.Split(s, \"\\n\")\n\n\t// sync h formula with DrawStringWrapped\n\theight = float64(len(lines)) * dc.fontHeight * lineSpacing\n\theight -= (lineSpacing - 1) * dc.fontHeight\n\n\td := &font.Drawer{\n\t\tFace: dc.fontFace,\n\t}\n\n\t// max width from lines\n\tfor _, line := range lines {\n\t\tadv := d.MeasureString(line)\n\t\tcurrentWidth := float64(adv >> 6) // from gg.Context.MeasureString\n\t\tif currentWidth > width {\n\t\t\twidth = currentWidth\n\t\t}\n\t}\n\n\treturn width, height\n}\n\n// MeasureString returns the rendered width and height of the specified text\n// given the current font face.\nfunc (dc *Context) MeasureString(s string) (w, h float64) {\n\td := &font.Drawer{\n\t\tFace: dc.fontFace,\n\t}\n\ta := d.MeasureString(s)\n\treturn float64(a >> 6), dc.fontHeight\n}\n\n// WordWrap wraps the specified string to the given max width and current\n// font face.\nfunc (dc *Context) WordWrap(s string, w float64) []string {\n\treturn wordWrap(dc, s, w)\n}\n\n// Transformation Matrix Operations\n\n// Identity resets the current transformation matrix to the identity matrix.\n// This results in no translating, scaling, rotating, or shearing.\nfunc (dc *Context) Identity() {\n\tdc.matrix = Identity()\n}\n\n// Translate updates the current matrix with a translation.\nfunc (dc *Context) Translate(x, y float64) {\n\tdc.matrix = dc.matrix.Translate(x, y)\n}\n\n// Scale updates the current matrix with a scaling factor.\n// Scaling occurs about the origin.\nfunc (dc *Context) Scale(x, y float64) {\n\tdc.matrix = dc.matrix.Scale(x, y)\n}\n\n// ScaleAbout updates the current matrix with a scaling factor.\n// Scaling occurs about the specified point.\nfunc (dc *Context) ScaleAbout(sx, sy, x, y float64) {\n\tdc.Translate(x, y)\n\tdc.Scale(sx, sy)\n\tdc.Translate(-x, -y)\n}\n\n// Rotate updates the current matrix with a anticlockwise rotation.\n// Rotation occurs about the origin. Angle is specified in radians.\nfunc (dc *Context) Rotate(angle float64) {\n\tdc.matrix = dc.matrix.Rotate(angle)\n}\n\n// RotateAbout updates the current matrix with a anticlockwise rotation.\n// Rotation occurs about the specified point. Angle is specified in radians.\nfunc (dc *Context) RotateAbout(angle, x, y float64) {\n\tdc.Translate(x, y)\n\tdc.Rotate(angle)\n\tdc.Translate(-x, -y)\n}\n\n// Shear updates the current matrix with a shearing angle.\n// Shearing occurs about the origin.\nfunc (dc *Context) Shear(x, y float64) {\n\tdc.matrix = dc.matrix.Shear(x, y)\n}\n\n// ShearAbout updates the current matrix with a shearing angle.\n// Shearing occurs about the specified point.\nfunc (dc *Context) ShearAbout(sx, sy, x, y float64) {\n\tdc.Translate(x, y)\n\tdc.Shear(sx, sy)\n\tdc.Translate(-x, -y)\n}\n\n// TransformPoint multiplies the specified point by the current matrix,\n// returning a transformed position.\nfunc (dc *Context) TransformPoint(x, y float64) (tx, ty float64) {\n\treturn dc.matrix.TransformPoint(x, y)\n}\n\n// InvertY flips the Y axis so that Y grows from bottom to top and Y=0 is at\n// the bottom of the image.\nfunc (dc *Context) InvertY() {\n\tdc.Translate(0, float64(dc.height))\n\tdc.Scale(1, -1)\n}\n\n// Stack\n\n// Push saves the current state of the context for later retrieval. These\n// can be nested.\nfunc (dc *Context) Push() {\n\tx := *dc\n\tdc.stack = append(dc.stack, &x)\n}\n\n// Pop restores the last saved context state from the stack.\nfunc (dc *Context) Pop() {\n\tbefore := *dc\n\ts := dc.stack\n\tx, s := s[len(s)-1], s[:len(s)-1]\n\t*dc = *x\n\tdc.mask = before.mask\n\tdc.strokePath = before.strokePath\n\tdc.fillPath = before.fillPath\n\tdc.start = before.start\n\tdc.current = before.current\n\tdc.hasCurrent = before.hasCurrent\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 7.5634765625,
          "content": "package gg\n\nimport (\n\t\"crypto/md5\"\n\t\"flag\"\n\t\"fmt\"\n\t\"image/color\"\n\t\"math/rand\"\n\t\"testing\"\n)\n\nvar save bool\n\nfunc init() {\n\tflag.BoolVar(&save, \"save\", false, \"save PNG output for each test case\")\n\tflag.Parse()\n}\n\nfunc hash(dc *Context) string {\n\treturn fmt.Sprintf(\"%x\", md5.Sum(dc.im.Pix))\n}\n\nfunc checkHash(t *testing.T, dc *Context, expected string) {\n\tactual := hash(dc)\n\tif actual != expected {\n\t\tt.Fatalf(\"expected hash: %s != actual hash: %s\", expected, actual)\n\t}\n}\n\nfunc saveImage(dc *Context, name string) error {\n\tif save {\n\t\treturn SavePNG(name+\".png\", dc.Image())\n\t}\n\treturn nil\n}\n\nfunc TestBlank(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tsaveImage(dc, \"TestBlank\")\n\tcheckHash(t, dc, \"4e0a293a5b638f0aba2c4fe2c3418d0e\")\n}\n\nfunc TestGrid(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\tfor i := 10; i < 100; i += 10 {\n\t\tx := float64(i) + 0.5\n\t\tdc.DrawLine(x, 0, x, 100)\n\t\tdc.DrawLine(0, x, 100, x)\n\t}\n\tdc.SetRGB(0, 0, 0)\n\tdc.Stroke()\n\tsaveImage(dc, \"TestGrid\")\n\tcheckHash(t, dc, \"78606adda71d8abfbd8bb271087e4d69\")\n}\n\nfunc TestLines(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(0.5, 0.5, 0.5)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 100; i++ {\n\t\tx1 := rnd.Float64() * 100\n\t\ty1 := rnd.Float64() * 100\n\t\tx2 := rnd.Float64() * 100\n\t\ty2 := rnd.Float64() * 100\n\t\tdc.DrawLine(x1, y1, x2, y2)\n\t\tdc.SetLineWidth(rnd.Float64() * 3)\n\t\tdc.SetRGB(rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.Stroke()\n\t}\n\tsaveImage(dc, \"TestLines\")\n\tcheckHash(t, dc, \"036bd220e2529955cc48425dd72bb686\")\n}\n\nfunc TestCircles(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 10; i++ {\n\t\tx := rnd.Float64() * 100\n\t\ty := rnd.Float64() * 100\n\t\tr := rnd.Float64()*10 + 5\n\t\tdc.DrawCircle(x, y, r)\n\t\tdc.SetRGB(rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.FillPreserve()\n\t\tdc.SetRGB(rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.SetLineWidth(rnd.Float64() * 3)\n\t\tdc.Stroke()\n\t}\n\tsaveImage(dc, \"TestCircles\")\n\tcheckHash(t, dc, \"c52698000df96fabafe7863701afe922\")\n}\n\nfunc TestQuadratic(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(0.25, 0.25, 0.25)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 100; i++ {\n\t\tx1 := rnd.Float64() * 100\n\t\ty1 := rnd.Float64() * 100\n\t\tx2 := rnd.Float64() * 100\n\t\ty2 := rnd.Float64() * 100\n\t\tx3 := rnd.Float64() * 100\n\t\ty3 := rnd.Float64() * 100\n\t\tdc.MoveTo(x1, y1)\n\t\tdc.QuadraticTo(x2, y2, x3, y3)\n\t\tdc.SetLineWidth(rnd.Float64() * 3)\n\t\tdc.SetRGB(rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.Stroke()\n\t}\n\tsaveImage(dc, \"TestQuadratic\")\n\tcheckHash(t, dc, \"56b842d814aee94b52495addae764a77\")\n}\n\nfunc TestCubic(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(0.75, 0.75, 0.75)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 100; i++ {\n\t\tx1 := rnd.Float64() * 100\n\t\ty1 := rnd.Float64() * 100\n\t\tx2 := rnd.Float64() * 100\n\t\ty2 := rnd.Float64() * 100\n\t\tx3 := rnd.Float64() * 100\n\t\ty3 := rnd.Float64() * 100\n\t\tx4 := rnd.Float64() * 100\n\t\ty4 := rnd.Float64() * 100\n\t\tdc.MoveTo(x1, y1)\n\t\tdc.CubicTo(x2, y2, x3, y3, x4, y4)\n\t\tdc.SetLineWidth(rnd.Float64() * 3)\n\t\tdc.SetRGB(rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.Stroke()\n\t}\n\tsaveImage(dc, \"TestCubic\")\n\tcheckHash(t, dc, \"4a7960fc4eaaa33ce74131c5ce0afca8\")\n}\n\nfunc TestFill(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 10; i++ {\n\t\tdc.NewSubPath()\n\t\tfor j := 0; j < 10; j++ {\n\t\t\tx := rnd.Float64() * 100\n\t\t\ty := rnd.Float64() * 100\n\t\t\tdc.LineTo(x, y)\n\t\t}\n\t\tdc.ClosePath()\n\t\tdc.SetRGBA(rnd.Float64(), rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.Fill()\n\t}\n\tsaveImage(dc, \"TestFill\")\n\tcheckHash(t, dc, \"7ccb3a2443906a825e57ab94db785467\")\n}\n\nfunc TestClip(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\tdc.DrawCircle(50, 50, 40)\n\tdc.Clip()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 1000; i++ {\n\t\tx := rnd.Float64() * 100\n\t\ty := rnd.Float64() * 100\n\t\tr := rnd.Float64()*10 + 5\n\t\tdc.DrawCircle(x, y, r)\n\t\tdc.SetRGBA(rnd.Float64(), rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.Fill()\n\t}\n\tsaveImage(dc, \"TestClip\")\n\tcheckHash(t, dc, \"762c32374d529fd45ffa038b05be7865\")\n}\n\nfunc TestPushPop(t *testing.T) {\n\tconst S = 100\n\tdc := NewContext(S, S)\n\tdc.SetRGBA(0, 0, 0, 0.1)\n\tfor i := 0; i < 360; i += 15 {\n\t\tdc.Push()\n\t\tdc.RotateAbout(Radians(float64(i)), S/2, S/2)\n\t\tdc.DrawEllipse(S/2, S/2, S*7/16, S/8)\n\t\tdc.Fill()\n\t\tdc.Pop()\n\t}\n\tsaveImage(dc, \"TestPushPop\")\n\tcheckHash(t, dc, \"31e908ee1c2ea180da98fd5681a89d05\")\n}\n\nfunc TestDrawStringWrapped(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\tdc.SetRGB(0, 0, 0)\n\tdc.DrawStringWrapped(\"Hello, world! How are you?\", 50, 50, 0.5, 0.5, 90, 1.5, AlignCenter)\n\tsaveImage(dc, \"TestDrawStringWrapped\")\n\tcheckHash(t, dc, \"8d92f6aae9e8b38563f171abd00893f8\")\n}\n\nfunc TestDrawImage(t *testing.T) {\n\tsrc := NewContext(100, 100)\n\tsrc.SetRGB(1, 1, 1)\n\tsrc.Clear()\n\tfor i := 10; i < 100; i += 10 {\n\t\tx := float64(i) + 0.5\n\t\tsrc.DrawLine(x, 0, x, 100)\n\t\tsrc.DrawLine(0, x, 100, x)\n\t}\n\tsrc.SetRGB(0, 0, 0)\n\tsrc.Stroke()\n\n\tdc := NewContext(200, 200)\n\tdc.SetRGB(0, 0, 0)\n\tdc.Clear()\n\tdc.DrawImage(src.Image(), 50, 50)\n\tsaveImage(dc, \"TestDrawImage\")\n\tcheckHash(t, dc, \"282afbc134676722960b6bec21305b15\")\n}\n\nfunc TestSetPixel(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(0, 0, 0)\n\tdc.Clear()\n\tdc.SetRGB(0, 1, 0)\n\ti := 0\n\tfor y := 0; y < 100; y++ {\n\t\tfor x := 0; x < 100; x++ {\n\t\t\tif i%31 == 0 {\n\t\t\t\tdc.SetPixel(x, y)\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\tsaveImage(dc, \"TestSetPixel\")\n\tcheckHash(t, dc, \"27dda6b4b1d94f061018825b11982793\")\n}\n\nfunc TestDrawPoint(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(0, 0, 0)\n\tdc.Clear()\n\tdc.SetRGB(0, 1, 0)\n\tdc.Scale(10, 10)\n\tfor y := 0; y <= 10; y++ {\n\t\tfor x := 0; x <= 10; x++ {\n\t\t\tdc.DrawPoint(float64(x), float64(y), 3)\n\t\t\tdc.Fill()\n\t\t}\n\t}\n\tsaveImage(dc, \"TestDrawPoint\")\n\tcheckHash(t, dc, \"55af8874531947ea6eeb62222fb33e0e\")\n}\n\nfunc TestLinearGradient(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tg := NewLinearGradient(0, 0, 100, 100)\n\tg.AddColorStop(0, color.RGBA{0, 255, 0, 255})\n\tg.AddColorStop(1, color.RGBA{0, 0, 255, 255})\n\tg.AddColorStop(0.5, color.RGBA{255, 0, 0, 255})\n\tdc.SetFillStyle(g)\n\tdc.DrawRectangle(0, 0, 100, 100)\n\tdc.Fill()\n\tsaveImage(dc, \"TestLinearGradient\")\n\tcheckHash(t, dc, \"75eb9385c1219b1d5bb6f4c961802c7a\")\n}\n\nfunc TestRadialGradient(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tg := NewRadialGradient(30, 50, 0, 70, 50, 50)\n\tg.AddColorStop(0, color.RGBA{0, 255, 0, 255})\n\tg.AddColorStop(1, color.RGBA{0, 0, 255, 255})\n\tg.AddColorStop(0.5, color.RGBA{255, 0, 0, 255})\n\tdc.SetFillStyle(g)\n\tdc.DrawRectangle(0, 0, 100, 100)\n\tdc.Fill()\n\tsaveImage(dc, \"TestRadialGradient\")\n\tcheckHash(t, dc, \"f170f39c3f35c29de11e00428532489d\")\n}\n\nfunc TestDashes(t *testing.T) {\n\tdc := NewContext(100, 100)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < 100; i++ {\n\t\tx1 := rnd.Float64() * 100\n\t\ty1 := rnd.Float64() * 100\n\t\tx2 := rnd.Float64() * 100\n\t\ty2 := rnd.Float64() * 100\n\t\tdc.SetDash(rnd.Float64()*3+1, rnd.Float64()*3+3)\n\t\tdc.DrawLine(x1, y1, x2, y2)\n\t\tdc.SetLineWidth(rnd.Float64() * 3)\n\t\tdc.SetRGB(rnd.Float64(), rnd.Float64(), rnd.Float64())\n\t\tdc.Stroke()\n\t}\n\tsaveImage(dc, \"TestDashes\")\n\tcheckHash(t, dc, \"d188069c69dcc3970edfac80f552b53c\")\n}\n\nfunc BenchmarkCircles(b *testing.B) {\n\tdc := NewContext(1000, 1000)\n\tdc.SetRGB(1, 1, 1)\n\tdc.Clear()\n\trnd := rand.New(rand.NewSource(99))\n\tfor i := 0; i < b.N; i++ {\n\t\tx := rnd.Float64() * 1000\n\t\ty := rnd.Float64() * 1000\n\t\tdc.DrawCircle(x, y, 10)\n\t\tif i%2 == 0 {\n\t\t\tdc.SetRGB(0, 0, 0)\n\t\t} else {\n\t\t\tdc.SetRGB(1, 1, 1)\n\t\t}\n\t\tdc.Fill()\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gradient.go",
          "type": "blob",
          "size": 4.71875,
          "content": "package gg\n\nimport (\n\t\"image/color\"\n\t\"math\"\n\t\"sort\"\n)\n\ntype stop struct {\n\tpos   float64\n\tcolor color.Color\n}\n\ntype stops []stop\n\n// Len satisfies the Sort interface.\nfunc (s stops) Len() int {\n\treturn len(s)\n}\n\n// Less satisfies the Sort interface.\nfunc (s stops) Less(i, j int) bool {\n\treturn s[i].pos < s[j].pos\n}\n\n// Swap satisfies the Sort interface.\nfunc (s stops) Swap(i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\ntype Gradient interface {\n\tPattern\n\tAddColorStop(offset float64, color color.Color)\n}\n\n// Linear Gradient\ntype linearGradient struct {\n\tx0, y0, x1, y1 float64\n\tstops          stops\n}\n\nfunc (g *linearGradient) ColorAt(x, y int) color.Color {\n\tif len(g.stops) == 0 {\n\t\treturn color.Transparent\n\t}\n\n\tfx, fy := float64(x), float64(y)\n\tx0, y0, x1, y1 := g.x0, g.y0, g.x1, g.y1\n\tdx, dy := x1-x0, y1-y0\n\n\t// Horizontal\n\tif dy == 0 && dx != 0 {\n\t\treturn getColor((fx-x0)/dx, g.stops)\n\t}\n\n\t// Vertical\n\tif dx == 0 && dy != 0 {\n\t\treturn getColor((fy-y0)/dy, g.stops)\n\t}\n\n\t// Dot product\n\ts0 := dx*(fx-x0) + dy*(fy-y0)\n\tif s0 < 0 {\n\t\treturn g.stops[0].color\n\t}\n\t// Calculate distance to (x0,y0) alone (x0,y0)->(x1,y1)\n\tmag := math.Hypot(dx, dy)\n\tu := ((fx-x0)*-dy + (fy-y0)*dx) / (mag * mag)\n\tx2, y2 := x0+u*-dy, y0+u*dx\n\td := math.Hypot(fx-x2, fy-y2) / mag\n\treturn getColor(d, g.stops)\n}\n\nfunc (g *linearGradient) AddColorStop(offset float64, color color.Color) {\n\tg.stops = append(g.stops, stop{pos: offset, color: color})\n\tsort.Sort(g.stops)\n}\n\nfunc NewLinearGradient(x0, y0, x1, y1 float64) Gradient {\n\tg := &linearGradient{\n\t\tx0: x0, y0: y0,\n\t\tx1: x1, y1: y1,\n\t}\n\treturn g\n}\n\n// Radial Gradient\ntype circle struct {\n\tx, y, r float64\n}\n\ntype radialGradient struct {\n\tc0, c1, cd circle\n\ta, inva    float64\n\tmindr      float64\n\tstops      stops\n}\n\nfunc dot3(x0, y0, z0, x1, y1, z1 float64) float64 {\n\treturn x0*x1 + y0*y1 + z0*z1\n}\n\nfunc (g *radialGradient) ColorAt(x, y int) color.Color {\n\tif len(g.stops) == 0 {\n\t\treturn color.Transparent\n\t}\n\n\t// copy from pixman's pixman-radial-gradient.c\n\n\tdx, dy := float64(x)+0.5-g.c0.x, float64(y)+0.5-g.c0.y\n\tb := dot3(dx, dy, g.c0.r, g.cd.x, g.cd.y, g.cd.r)\n\tc := dot3(dx, dy, -g.c0.r, dx, dy, g.c0.r)\n\n\tif g.a == 0 {\n\t\tif b == 0 {\n\t\t\treturn color.Transparent\n\t\t}\n\t\tt := 0.5 * c / b\n\t\tif t*g.cd.r >= g.mindr {\n\t\t\treturn getColor(t, g.stops)\n\t\t}\n\t\treturn color.Transparent\n\t}\n\n\tdiscr := dot3(b, g.a, 0, b, -c, 0)\n\tif discr >= 0 {\n\t\tsqrtdiscr := math.Sqrt(discr)\n\t\tt0 := (b + sqrtdiscr) * g.inva\n\t\tt1 := (b - sqrtdiscr) * g.inva\n\n\t\tif t0*g.cd.r >= g.mindr {\n\t\t\treturn getColor(t0, g.stops)\n\t\t} else if t1*g.cd.r >= g.mindr {\n\t\t\treturn getColor(t1, g.stops)\n\t\t}\n\t}\n\n\treturn color.Transparent\n}\n\nfunc (g *radialGradient) AddColorStop(offset float64, color color.Color) {\n\tg.stops = append(g.stops, stop{pos: offset, color: color})\n\tsort.Sort(g.stops)\n}\n\nfunc NewRadialGradient(x0, y0, r0, x1, y1, r1 float64) Gradient {\n\tc0 := circle{x0, y0, r0}\n\tc1 := circle{x1, y1, r1}\n\tcd := circle{x1 - x0, y1 - y0, r1 - r0}\n\ta := dot3(cd.x, cd.y, -cd.r, cd.x, cd.y, cd.r)\n\tvar inva float64\n\tif a != 0 {\n\t\tinva = 1.0 / a\n\t}\n\tmindr := -c0.r\n\tg := &radialGradient{\n\t\tc0:    c0,\n\t\tc1:    c1,\n\t\tcd:    cd,\n\t\ta:     a,\n\t\tinva:  inva,\n\t\tmindr: mindr,\n\t}\n\treturn g\n}\n\n// Conic Gradient\ntype conicGradient struct {\n\tcx, cy   float64\n\trotation float64\n\tstops    stops\n}\n\nfunc (g *conicGradient) ColorAt(x, y int) color.Color {\n\tif len(g.stops) == 0 {\n\t\treturn color.Transparent\n\t}\n\ta := math.Atan2(float64(y)-g.cy, float64(x)-g.cx)\n\tt := norm(a, -math.Pi, math.Pi) - g.rotation\n\tif t < 0 {\n\t\tt += 1\n\t}\n\treturn getColor(t, g.stops)\n}\n\nfunc (g *conicGradient) AddColorStop(offset float64, color color.Color) {\n\tg.stops = append(g.stops, stop{pos: offset, color: color})\n\tsort.Sort(g.stops)\n}\n\nfunc NewConicGradient(cx, cy, deg float64) Gradient {\n\tg := &conicGradient{\n\t\tcx:       cx,\n\t\tcy:       cy,\n\t\trotation: normalizeAngle(deg) / 360,\n\t}\n\treturn g\n}\n\nfunc normalizeAngle(t float64) float64 {\n\tt = math.Mod(t, 360)\n\tif t < 0 {\n\t\tt += 360\n\t}\n\treturn t\n}\n\n// Map value which is in range [a..b] to range [0..1]\nfunc norm(value, a, b float64) float64 {\n\treturn (value - a) * (1.0 / (b - a))\n}\n\nfunc getColor(pos float64, stops stops) color.Color {\n\tif pos <= 0.0 || len(stops) == 1 {\n\t\treturn stops[0].color\n\t}\n\n\tlast := stops[len(stops)-1]\n\n\tif pos >= last.pos {\n\t\treturn last.color\n\t}\n\n\tfor i, stop := range stops[1:] {\n\t\tif pos < stop.pos {\n\t\t\tpos = (pos - stops[i].pos) / (stop.pos - stops[i].pos)\n\t\t\treturn colorLerp(stops[i].color, stop.color, pos)\n\t\t}\n\t}\n\n\treturn last.color\n}\n\nfunc colorLerp(c0, c1 color.Color, t float64) color.Color {\n\tr0, g0, b0, a0 := c0.RGBA()\n\tr1, g1, b1, a1 := c1.RGBA()\n\n\treturn color.RGBA{\n\t\tlerp(r0, r1, t),\n\t\tlerp(g0, g1, t),\n\t\tlerp(b0, b1, t),\n\t\tlerp(a0, a1, t),\n\t}\n}\n\nfunc lerp(a, b uint32, t float64) uint8 {\n\treturn uint8(int32(float64(a)*(1.0-t)+float64(b)*t) >> 8)\n}\n"
        },
        {
          "name": "matrix.go",
          "type": "blob",
          "size": 1.3076171875,
          "content": "package gg\n\nimport \"math\"\n\ntype Matrix struct {\n\tXX, YX, XY, YY, X0, Y0 float64\n}\n\nfunc Identity() Matrix {\n\treturn Matrix{\n\t\t1, 0,\n\t\t0, 1,\n\t\t0, 0,\n\t}\n}\n\nfunc Translate(x, y float64) Matrix {\n\treturn Matrix{\n\t\t1, 0,\n\t\t0, 1,\n\t\tx, y,\n\t}\n}\n\nfunc Scale(x, y float64) Matrix {\n\treturn Matrix{\n\t\tx, 0,\n\t\t0, y,\n\t\t0, 0,\n\t}\n}\n\nfunc Rotate(angle float64) Matrix {\n\tc := math.Cos(angle)\n\ts := math.Sin(angle)\n\treturn Matrix{\n\t\tc, s,\n\t\t-s, c,\n\t\t0, 0,\n\t}\n}\n\nfunc Shear(x, y float64) Matrix {\n\treturn Matrix{\n\t\t1, y,\n\t\tx, 1,\n\t\t0, 0,\n\t}\n}\n\nfunc (a Matrix) Multiply(b Matrix) Matrix {\n\treturn Matrix{\n\t\ta.XX*b.XX + a.YX*b.XY,\n\t\ta.XX*b.YX + a.YX*b.YY,\n\t\ta.XY*b.XX + a.YY*b.XY,\n\t\ta.XY*b.YX + a.YY*b.YY,\n\t\ta.X0*b.XX + a.Y0*b.XY + b.X0,\n\t\ta.X0*b.YX + a.Y0*b.YY + b.Y0,\n\t}\n}\n\nfunc (a Matrix) TransformVector(x, y float64) (tx, ty float64) {\n\ttx = a.XX*x + a.XY*y\n\tty = a.YX*x + a.YY*y\n\treturn\n}\n\nfunc (a Matrix) TransformPoint(x, y float64) (tx, ty float64) {\n\ttx = a.XX*x + a.XY*y + a.X0\n\tty = a.YX*x + a.YY*y + a.Y0\n\treturn\n}\n\nfunc (a Matrix) Translate(x, y float64) Matrix {\n\treturn Translate(x, y).Multiply(a)\n}\n\nfunc (a Matrix) Scale(x, y float64) Matrix {\n\treturn Scale(x, y).Multiply(a)\n}\n\nfunc (a Matrix) Rotate(angle float64) Matrix {\n\treturn Rotate(angle).Multiply(a)\n}\n\nfunc (a Matrix) Shear(x, y float64) Matrix {\n\treturn Shear(x, y).Multiply(a)\n}\n"
        },
        {
          "name": "path.go",
          "type": "blob",
          "size": 3.3193359375,
          "content": "package gg\n\nimport (\n\t\"math\"\n\n\t\"github.com/golang/freetype/raster\"\n\t\"golang.org/x/image/math/fixed\"\n)\n\nfunc flattenPath(p raster.Path) [][]Point {\n\tvar result [][]Point\n\tvar path []Point\n\tvar cx, cy float64\n\tfor i := 0; i < len(p); {\n\t\tswitch p[i] {\n\t\tcase 0:\n\t\t\tif len(path) > 0 {\n\t\t\t\tresult = append(result, path)\n\t\t\t\tpath = nil\n\t\t\t}\n\t\t\tx := unfix(p[i+1])\n\t\t\ty := unfix(p[i+2])\n\t\t\tpath = append(path, Point{x, y})\n\t\t\tcx, cy = x, y\n\t\t\ti += 4\n\t\tcase 1:\n\t\t\tx := unfix(p[i+1])\n\t\t\ty := unfix(p[i+2])\n\t\t\tpath = append(path, Point{x, y})\n\t\t\tcx, cy = x, y\n\t\t\ti += 4\n\t\tcase 2:\n\t\t\tx1 := unfix(p[i+1])\n\t\t\ty1 := unfix(p[i+2])\n\t\t\tx2 := unfix(p[i+3])\n\t\t\ty2 := unfix(p[i+4])\n\t\t\tpoints := QuadraticBezier(cx, cy, x1, y1, x2, y2)\n\t\t\tpath = append(path, points...)\n\t\t\tcx, cy = x2, y2\n\t\t\ti += 6\n\t\tcase 3:\n\t\t\tx1 := unfix(p[i+1])\n\t\t\ty1 := unfix(p[i+2])\n\t\t\tx2 := unfix(p[i+3])\n\t\t\ty2 := unfix(p[i+4])\n\t\t\tx3 := unfix(p[i+5])\n\t\t\ty3 := unfix(p[i+6])\n\t\t\tpoints := CubicBezier(cx, cy, x1, y1, x2, y2, x3, y3)\n\t\t\tpath = append(path, points...)\n\t\t\tcx, cy = x3, y3\n\t\t\ti += 8\n\t\tdefault:\n\t\t\tpanic(\"bad path\")\n\t\t}\n\t}\n\tif len(path) > 0 {\n\t\tresult = append(result, path)\n\t}\n\treturn result\n}\n\nfunc dashPath(paths [][]Point, dashes []float64, offset float64) [][]Point {\n\tvar result [][]Point\n\tif len(dashes) == 0 {\n\t\treturn paths\n\t}\n\tif len(dashes) == 1 {\n\t\tdashes = append(dashes, dashes[0])\n\t}\n\tfor _, path := range paths {\n\t\tif len(path) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tprevious := path[0]\n\t\tpathIndex := 1\n\t\tdashIndex := 0\n\t\tsegmentLength := 0.0\n\n\t\t// offset\n\t\tif offset != 0 {\n\t\t\tvar totalLength float64\n\t\t\tfor _, dashLength := range dashes {\n\t\t\t\ttotalLength += dashLength\n\t\t\t}\n\t\t\toffset = math.Mod(offset, totalLength)\n\t\t\tif offset < 0 {\n\t\t\t\toffset += totalLength\n\t\t\t}\n\t\t\tfor i, dashLength := range dashes {\n\t\t\t\toffset -= dashLength\n\t\t\t\tif offset < 0 {\n\t\t\t\t\tdashIndex = i\n\t\t\t\t\tsegmentLength = dashLength + offset\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar segment []Point\n\t\tsegment = append(segment, previous)\n\t\tfor pathIndex < len(path) {\n\t\t\tdashLength := dashes[dashIndex]\n\t\t\tpoint := path[pathIndex]\n\t\t\td := previous.Distance(point)\n\t\t\tmaxd := dashLength - segmentLength\n\t\t\tif d > maxd {\n\t\t\t\tt := maxd / d\n\t\t\t\tp := previous.Interpolate(point, t)\n\t\t\t\tsegment = append(segment, p)\n\t\t\t\tif dashIndex%2 == 0 && len(segment) > 1 {\n\t\t\t\t\tresult = append(result, segment)\n\t\t\t\t}\n\t\t\t\tsegment = nil\n\t\t\t\tsegment = append(segment, p)\n\t\t\t\tsegmentLength = 0\n\t\t\t\tprevious = p\n\t\t\t\tdashIndex = (dashIndex + 1) % len(dashes)\n\t\t\t} else {\n\t\t\t\tsegment = append(segment, point)\n\t\t\t\tprevious = point\n\t\t\t\tsegmentLength += d\n\t\t\t\tpathIndex++\n\t\t\t}\n\t\t}\n\t\tif dashIndex%2 == 0 && len(segment) > 1 {\n\t\t\tresult = append(result, segment)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc rasterPath(paths [][]Point) raster.Path {\n\tvar result raster.Path\n\tfor _, path := range paths {\n\t\tvar previous fixed.Point26_6\n\t\tfor i, point := range path {\n\t\t\tf := point.Fixed()\n\t\t\tif i == 0 {\n\t\t\t\tresult.Start(f)\n\t\t\t} else {\n\t\t\t\tdx := f.X - previous.X\n\t\t\t\tdy := f.Y - previous.Y\n\t\t\t\tif dx < 0 {\n\t\t\t\t\tdx = -dx\n\t\t\t\t}\n\t\t\t\tif dy < 0 {\n\t\t\t\t\tdy = -dy\n\t\t\t\t}\n\t\t\t\tif dx+dy > 8 {\n\t\t\t\t\t// TODO: this is a hack for cases where two points are\n\t\t\t\t\t// too close - causes rendering issues with joins / caps\n\t\t\t\t\tresult.Add1(f)\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevious = f\n\t\t}\n\t}\n\treturn result\n}\n\nfunc dashed(path raster.Path, dashes []float64, offset float64) raster.Path {\n\treturn rasterPath(dashPath(flattenPath(path), dashes, offset))\n}\n"
        },
        {
          "name": "pattern.go",
          "type": "blob",
          "size": 2.39453125,
          "content": "package gg\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\n\t\"github.com/golang/freetype/raster\"\n)\n\ntype RepeatOp int\n\nconst (\n\tRepeatBoth RepeatOp = iota\n\tRepeatX\n\tRepeatY\n\tRepeatNone\n)\n\ntype Pattern interface {\n\tColorAt(x, y int) color.Color\n}\n\n// Solid Pattern\ntype solidPattern struct {\n\tcolor color.Color\n}\n\nfunc (p *solidPattern) ColorAt(x, y int) color.Color {\n\treturn p.color\n}\n\nfunc NewSolidPattern(color color.Color) Pattern {\n\treturn &solidPattern{color: color}\n}\n\n// Surface Pattern\ntype surfacePattern struct {\n\tim image.Image\n\top RepeatOp\n}\n\nfunc (p *surfacePattern) ColorAt(x, y int) color.Color {\n\tb := p.im.Bounds()\n\tswitch p.op {\n\tcase RepeatX:\n\t\tif y >= b.Dy() {\n\t\t\treturn color.Transparent\n\t\t}\n\tcase RepeatY:\n\t\tif x >= b.Dx() {\n\t\t\treturn color.Transparent\n\t\t}\n\tcase RepeatNone:\n\t\tif x >= b.Dx() || y >= b.Dy() {\n\t\t\treturn color.Transparent\n\t\t}\n\t}\n\tx = x%b.Dx() + b.Min.X\n\ty = y%b.Dy() + b.Min.Y\n\treturn p.im.At(x, y)\n}\n\nfunc NewSurfacePattern(im image.Image, op RepeatOp) Pattern {\n\treturn &surfacePattern{im: im, op: op}\n}\n\ntype patternPainter struct {\n\tim   *image.RGBA\n\tmask *image.Alpha\n\tp    Pattern\n}\n\n// Paint satisfies the Painter interface.\nfunc (r *patternPainter) Paint(ss []raster.Span, done bool) {\n\tb := r.im.Bounds()\n\tfor _, s := range ss {\n\t\tif s.Y < b.Min.Y {\n\t\t\tcontinue\n\t\t}\n\t\tif s.Y >= b.Max.Y {\n\t\t\treturn\n\t\t}\n\t\tif s.X0 < b.Min.X {\n\t\t\ts.X0 = b.Min.X\n\t\t}\n\t\tif s.X1 > b.Max.X {\n\t\t\ts.X1 = b.Max.X\n\t\t}\n\t\tif s.X0 >= s.X1 {\n\t\t\tcontinue\n\t\t}\n\t\tconst m = 1<<16 - 1\n\t\ty := s.Y - r.im.Rect.Min.Y\n\t\tx0 := s.X0 - r.im.Rect.Min.X\n\t\t// RGBAPainter.Paint() in $GOPATH/src/github.com/golang/freetype/raster/paint.go\n\t\ti0 := (s.Y-r.im.Rect.Min.Y)*r.im.Stride + (s.X0-r.im.Rect.Min.X)*4\n\t\ti1 := i0 + (s.X1-s.X0)*4\n\t\tfor i, x := i0, x0; i < i1; i, x = i+4, x+1 {\n\t\t\tma := s.Alpha\n\t\t\tif r.mask != nil {\n\t\t\t\tma = ma * uint32(r.mask.AlphaAt(x, y).A) / 255\n\t\t\t\tif ma == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tc := r.p.ColorAt(x, y)\n\t\t\tcr, cg, cb, ca := c.RGBA()\n\t\t\tdr := uint32(r.im.Pix[i+0])\n\t\t\tdg := uint32(r.im.Pix[i+1])\n\t\t\tdb := uint32(r.im.Pix[i+2])\n\t\t\tda := uint32(r.im.Pix[i+3])\n\t\t\ta := (m - (ca * ma / m)) * 0x101\n\t\t\tr.im.Pix[i+0] = uint8((dr*a + cr*ma) / m >> 8)\n\t\t\tr.im.Pix[i+1] = uint8((dg*a + cg*ma) / m >> 8)\n\t\t\tr.im.Pix[i+2] = uint8((db*a + cb*ma) / m >> 8)\n\t\t\tr.im.Pix[i+3] = uint8((da*a + ca*ma) / m >> 8)\n\t\t}\n\t}\n}\n\nfunc newPatternPainter(im *image.RGBA, mask *image.Alpha, p Pattern) *patternPainter {\n\treturn &patternPainter{im, mask, p}\n}\n"
        },
        {
          "name": "point.go",
          "type": "blob",
          "size": 0.369140625,
          "content": "package gg\n\nimport (\n\t\"math\"\n\n\t\"golang.org/x/image/math/fixed\"\n)\n\ntype Point struct {\n\tX, Y float64\n}\n\nfunc (a Point) Fixed() fixed.Point26_6 {\n\treturn fixp(a.X, a.Y)\n}\n\nfunc (a Point) Distance(b Point) float64 {\n\treturn math.Hypot(a.X-b.X, a.Y-b.Y)\n}\n\nfunc (a Point) Interpolate(b Point, t float64) Point {\n\tx := a.X + (b.X-a.X)*t\n\ty := a.Y + (b.Y-a.Y)*t\n\treturn Point{x, y}\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 2.853515625,
          "content": "package gg\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/draw\"\n\t\"image/jpeg\"\n\t_ \"image/jpeg\"\n\t\"image/png\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/golang/freetype/truetype\"\n\n\t\"golang.org/x/image/font\"\n\t\"golang.org/x/image/math/fixed\"\n)\n\nfunc Radians(degrees float64) float64 {\n\treturn degrees * math.Pi / 180\n}\n\nfunc Degrees(radians float64) float64 {\n\treturn radians * 180 / math.Pi\n}\n\nfunc LoadImage(path string) (image.Image, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\tim, _, err := image.Decode(file)\n\treturn im, err\n}\n\nfunc LoadPNG(path string) (image.Image, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\treturn png.Decode(file)\n}\n\nfunc SavePNG(path string, im image.Image) error {\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\treturn png.Encode(file, im)\n}\n\nfunc LoadJPG(path string) (image.Image, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\treturn jpeg.Decode(file)\n}\n\nfunc SaveJPG(path string, im image.Image, quality int) error {\n\tfile, err := os.Create(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close()\n\n\tvar opt jpeg.Options\n\topt.Quality = quality\n\n\treturn jpeg.Encode(file, im, &opt)\n}\n\nfunc imageToRGBA(src image.Image) *image.RGBA {\n\tbounds := src.Bounds()\n\tdst := image.NewRGBA(bounds)\n\tdraw.Draw(dst, bounds, src, bounds.Min, draw.Src)\n\treturn dst\n}\n\nfunc parseHexColor(x string) (r, g, b, a int) {\n\tx = strings.TrimPrefix(x, \"#\")\n\ta = 255\n\tif len(x) == 3 {\n\t\tformat := \"%1x%1x%1x\"\n\t\tfmt.Sscanf(x, format, &r, &g, &b)\n\t\tr |= r << 4\n\t\tg |= g << 4\n\t\tb |= b << 4\n\t}\n\tif len(x) == 6 {\n\t\tformat := \"%02x%02x%02x\"\n\t\tfmt.Sscanf(x, format, &r, &g, &b)\n\t}\n\tif len(x) == 8 {\n\t\tformat := \"%02x%02x%02x%02x\"\n\t\tfmt.Sscanf(x, format, &r, &g, &b, &a)\n\t}\n\treturn\n}\n\nfunc fixp(x, y float64) fixed.Point26_6 {\n\treturn fixed.Point26_6{fix(x), fix(y)}\n}\n\nfunc fix(x float64) fixed.Int26_6 {\n\treturn fixed.Int26_6(math.Round(x * 64))\n}\n\nfunc unfix(x fixed.Int26_6) float64 {\n\tconst shift, mask = 6, 1<<6 - 1\n\tif x >= 0 {\n\t\treturn float64(x>>shift) + float64(x&mask)/64\n\t}\n\tx = -x\n\tif x >= 0 {\n\t\treturn -(float64(x>>shift) + float64(x&mask)/64)\n\t}\n\treturn 0\n}\n\n// LoadFontFace is a helper function to load the specified font file with\n// the specified point size. Note that the returned `font.Face` objects\n// are not thread safe and cannot be used in parallel across goroutines.\n// You can usually just use the Context.LoadFontFace function instead of\n// this package-level function.\nfunc LoadFontFace(path string, points float64) (font.Face, error) {\n\tfontBytes, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := truetype.Parse(fontBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tface := truetype.NewFace(f, &truetype.Options{\n\t\tSize: points,\n\t\t// Hinting: font.HintingFull,\n\t})\n\treturn face, nil\n}\n"
        },
        {
          "name": "wrap.go",
          "type": "blob",
          "size": 1.0322265625,
          "content": "package gg\n\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\ntype measureStringer interface {\n\tMeasureString(s string) (w, h float64)\n}\n\nfunc splitOnSpace(x string) []string {\n\tvar result []string\n\tpi := 0\n\tps := false\n\tfor i, c := range x {\n\t\ts := unicode.IsSpace(c)\n\t\tif s != ps && i > 0 {\n\t\t\tresult = append(result, x[pi:i])\n\t\t\tpi = i\n\t\t}\n\t\tps = s\n\t}\n\tresult = append(result, x[pi:])\n\treturn result\n}\n\nfunc wordWrap(m measureStringer, s string, width float64) []string {\n\tvar result []string\n\tfor _, line := range strings.Split(s, \"\\n\") {\n\t\tfields := splitOnSpace(line)\n\t\tif len(fields)%2 == 1 {\n\t\t\tfields = append(fields, \"\")\n\t\t}\n\t\tx := \"\"\n\t\tfor i := 0; i < len(fields); i += 2 {\n\t\t\tw, _ := m.MeasureString(x + fields[i])\n\t\t\tif w > width {\n\t\t\t\tif x == \"\" {\n\t\t\t\t\tresult = append(result, fields[i])\n\t\t\t\t\tx = \"\"\n\t\t\t\t\tcontinue\n\t\t\t\t} else {\n\t\t\t\t\tresult = append(result, x)\n\t\t\t\t\tx = \"\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tx += fields[i] + fields[i+1]\n\t\t}\n\t\tif x != \"\" {\n\t\t\tresult = append(result, x)\n\t\t}\n\t}\n\tfor i, line := range result {\n\t\tresult[i] = strings.TrimSpace(line)\n\t}\n\treturn result\n}\n"
        }
      ]
    }
  ]
}