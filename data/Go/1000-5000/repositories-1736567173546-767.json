{
  "metadata": {
    "timestamp": 1736567173546,
    "page": 767,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "danielgtaylor/huma",
      "stars": 2504,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1005859375,
          "content": "coverage.txt\n.vscode\n*.test\ncpu.out\nmem.out\n**/.DS_STORE\ndocs/site\ndocs/__pycache__\ndocs/.cache\n.idea/\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2099609375,
          "content": "linters:\n  disable:\n    - errcheck\n  enable:\n    - dupword\n    - misspell\n    - musttag\n    - nolintlint\n    - perfsprint\n    - prealloc\n    - tenv\n    - testifylint\n    - unparam\n    - unconvert\n    - wastedassign\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.03125,
          "content": "Copyright 2020 Daniel G. Taylor\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.646484375,
          "content": "<a href=\"#\">\n\t<picture>\n\t\t<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://huma.rocks/huma-dark.png\" />\n\t\t<source media=\"(prefers-color-scheme: light)\" srcset=\"https://huma.rocks/huma.png\" />\n\t\t<img alt=\"Huma Logo\" src=\"https://huma.rocks/huma.png\" />\n\t</picture>\n</a>\n\n[![HUMA Powered](https://img.shields.io/badge/Powered%20By-HUMA-f40273)](https://huma.rocks/) [![CI](https://github.com/danielgtaylor/huma/workflows/CI/badge.svg?branch=main)](https://github.com/danielgtaylor/huma/actions?query=workflow%3ACI+branch%3Amain++) [![codecov](https://codecov.io/gh/danielgtaylor/huma/branch/main/graph/badge.svg)](https://codecov.io/gh/danielgtaylor/huma) [![Docs](https://godoc.org/github.com/danielgtaylor/huma/v2?status.svg)](https://pkg.go.dev/github.com/danielgtaylor/huma/v2?tab=doc) [![Go Report Card](https://goreportcard.com/badge/github.com/danielgtaylor/huma/v2)](https://goreportcard.com/report/github.com/danielgtaylor/huma/v2)\n\n[**üåé‰∏≠ÊñáÊñáÊ°£**](./README_CN.md)\n\n- [What is huma?](#intro)\n- [Install](#install)\n- [Example](#example)\n- [Documentation](#documentation)\n\n<a name=\"intro\"></a>\nA modern, simple, fast & flexible micro framework for building HTTP REST/RPC APIs in Go backed by OpenAPI 3 and JSON Schema. Pronounced IPA: [/'hjuÀêm…ë/](https://en.wiktionary.org/wiki/Wiktionary:International_Phonetic_Alphabet). The goals of this project are to provide:\n\n- Incremental adoption for teams with existing services\n  - Bring your own router (including Go 1.22+), middleware, and logging/metrics\n  - Extensible OpenAPI & JSON Schema layer to document existing routes\n- A modern REST or HTTP RPC API backend framework for Go developers\n  - Described by [OpenAPI 3.1](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md) & [JSON Schema](https://json-schema.org/)\n- Guard rails to prevent common mistakes\n- Documentation that can't get out of date\n- High-quality generated developer tooling\n\nFeatures include:\n\n- Declarative interface on top of your router of choice:\n  - Operation & model documentation\n  - Request params (path, query, header, or cookie)\n  - Request body\n  - Responses (including errors)\n  - Response headers\n- JSON Errors using [RFC9457](https://datatracker.ietf.org/doc/html/rfc9457) and `application/problem+json` by default (but can be changed)\n- Per-operation request size limits with sane defaults\n- [Content negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation) between server and client\n  - Support for JSON ([RFC 8259](https://tools.ietf.org/html/rfc8259)) and optionally CBOR ([RFC 7049](https://tools.ietf.org/html/rfc7049)) content types via the `Accept` header with the default config.\n- Conditional requests support, e.g. `If-Match` or `If-Unmodified-Since` header utilities.\n- Optional automatic generation of `PATCH` operations that support:\n  - [RFC 7386](https://www.rfc-editor.org/rfc/rfc7386) JSON Merge Patch\n  - [RFC 6902](https://www.rfc-editor.org/rfc/rfc6902) JSON Patch\n  - [Shorthand](https://github.com/danielgtaylor/shorthand) patches\n- Annotated Go types for input and output models\n  - Generates JSON Schema from Go types\n  - Static typing for path/query/header params, bodies, response headers, etc.\n  - Automatic input model validation & error handling\n- Documentation generation using [Stoplight Elements](https://stoplight.io/open-source/elements)\n- Optional CLI built-in, configured via arguments or environment variables\n  - Set via e.g. `-p 8000`, `--port=8000`, or `SERVICE_PORT=8000`\n  - Startup actions & graceful shutdown built-in\n- Generates OpenAPI for access to a rich ecosystem of tools\n  - Mocks with [API Sprout](https://github.com/danielgtaylor/apisprout) or [Prism](https://stoplight.io/open-source/prism)\n  - SDKs with [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) or [oapi-codegen](https://github.com/deepmap/oapi-codegen)\n  - CLI with [Restish](https://rest.sh/)\n  - And [plenty](https://openapi.tools/) [more](https://apis.guru/awesome-openapi3/category.html)\n- Generates JSON Schema for each resource using optional `describedby` link relation headers as well as optional `$schema` properties in returned objects that integrate into editors for validation & completion.\n\nThis project was inspired by [FastAPI](https://fastapi.tiangolo.com/). Logo & branding designed by Kari Taylor.\n\n## Sponsors\n\nA big thank you to our current & former sponsors!\n\n<div>\n\t\t\t\t\t<img width=\"1000\" height=\"0\" />\n\t\t\t\t\t<a href=\"https://zuplo.link/huma-gh \">\n\t\t\t\t\t<picture>\n\t\t\t\t\t\t\t<!-- <source media=\"(prefers-color-scheme: dark)\" srcset=\"docs/zuplo-dark.png\"> -->\n\t\t\t\t\t\t\t<img src=\"https://github.com/user-attachments/assets/aace5aa7-32bd-45cf-a8f8-2e352feaf017\" alt=\"Zuplo\" width=\"260\" align=\"right\">\n\t\t\t\t\t</picture>\n\t\t\t\t\t</a>\n\t\t\t\t\t<h3>Zuplo: Scale, Protect, and Productize your Huma API</h3>\n\t\t\t\t\t<p>\n\t\t\t\t\t\t\tOur API Gateway allows you to secure your API, scale it globally, generate documentation from your OpenAPI, and monetize your users.\n\t\t\t\t\t</p>\n\t\t\t\t\t<a href=\"https://zuplo.link/huma-gh \">Start for Free</a>\n</div>\n<hr/>\n\n- [@bclements](https://github.com/bclements)\n- [@bekabaz](https://github.com/bekabaz)\n- [@victoraugustolls](https://github.com/victoraugustolls)\n- [@phoenixtechnologies-io](https://github.com/phoenixtechnologies-io)\n- [@chenjr0719](https://github.com/chenjr0719)\n- [@vinogradovkonst](https://github.com/vinogradovkonst)\n- [@miyamo2](https://github.com/miyamo2)\n\n## Testimonials\n\n> This is by far my favorite web framework for Go. It is inspired by FastAPI, which is also amazing, and conforms to many RFCs for common web things ... I really like the feature set, the fact that it [can use] Chi, and the fact that it is still somehow relatively simple to use. I've tried other frameworks and they do not spark joy for me. - [Jeb_Jenky](https://www.reddit.com/r/golang/comments/zhitcg/comment/izmg6vk/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> After working with #Golang for over a year, I stumbled upon Huma, the #FastAPI-inspired web framework. It‚Äôs the Christmas miracle I‚Äôve been hoping for! This framework has everything! - [Hana Mohan](https://twitter.com/unamashana/status/1733088066053583197)\n\n> I love Huma. Thank you, sincerely, for this awesome package. I‚Äôve been using it for some time now and it‚Äôs been great! - [plscott](https://www.reddit.com/r/golang/comments/1aoshey/comment/kq6hcpd/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> Thank you Daniel for Huma. Superbly useful project and saves us a lot of time and hassle thanks to the OpenAPI gen ‚Äî similar to FastAPI in Python. - [WolvesOfAllStreets](https://www.reddit.com/r/golang/comments/1aqj99d/comment/kqfqcml/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> Huma is wonderful, I've started working with it recently, and it's a pleasure, so thank you very much for your efforts üôè - [callmemicah](https://www.reddit.com/r/golang/comments/1b32ts4/comment/ksvr9h7/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> It took us 3 months to build our platform in Python with FastAPI, SQL Alchemy and only 3 weeks to rewrite it in Go with Huma and SQL C. Things just work and I seldomly have to debug where in Python I spent a majority of my time debugging. - [Bitclick\\_](https://www.reddit.com/r/golang/comments/1cj2znb/comment/l2e4u6y/)\n\n> Look at Huma, it's great. A nice slim layer on top of stdlib mux/chi and automatic body and parameter serialization, kinda feels like doing dotnet web APIs, but forces you to actually design request and response structs, which is great imo. - [Kirides](https://www.reddit.com/r/golang/comments/1fnn5c2/comment/lokuvpo/)\n\n# Install\n\nInstall via `go get`. Note that Go 1.21 or newer is required.\n\n```sh\n# After: go mod init ...\ngo get -u github.com/danielgtaylor/huma/v2\n```\n\n# Example\n\nHere is a complete basic hello world example in Huma, that shows how to initialize a Huma app complete with CLI, declare a resource operation, and define its handler function.\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI. Pass `--port` or set the `SERVICE_PORT` env var.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Add the operation handler to the API.\n\t\thuma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n> [!TIP]\n> Replace `chi.NewMux()` ‚Üí `http.NewServeMux()` and `humachi.New` ‚Üí `humago.New` to use the standard library router from Go 1.22+. Just make sure your `go.mod` has `go 1.22` or newer listed in it. Everything else stays the same! Switch whenever you are ready.\n\nYou can test it with `go run greet.go` (optionally pass `--port` to change the default) and make a sample request using [Restish](https://rest.sh/) (or `curl`):\n\n```sh\n# Get the message from the server\n$ restish :8888/greeting/world\nHTTP/1.1 200 OK\n...\n{\n\t$schema: \"http://localhost:8888/schemas/GreetingOutputBody.json\",\n\tmessage: \"Hello, world!\"\n}\n```\n\nEven though the example is tiny you can also see some generated documentation at http://localhost:8888/docs. The generated OpenAPI is available at http://localhost:8888/openapi.json or http://localhost:8888/openapi.yaml.\n\nCheck out the [Huma tutorial](https://huma.rocks/tutorial/installation/) for a step-by-step guide to get started.\n\n# Documentation\n\nSee the [https://huma.rocks/](https://huma.rocks/) website for full documentation in a presentation that's easier to navigate and search then this README. You can find the source for the site in the `docs` directory of this repo.\n\nOfficial Go package documentation can always be found at https://pkg.go.dev/github.com/danielgtaylor/huma/v2.\n\n# Articles & Mentions\n\n- [APIs in Go with Huma 2.0](https://dgt.hashnode.dev/apis-in-go-with-huma-20)\n- [Reducing Go Dependencies: A case study of dependency reduction in Huma](https://dgt.hashnode.dev/reducing-go-dependencies)\n- [Golang News & Libs & Jobs shared on Twitter/X](https://twitter.com/golangch/status/1752175499701264532)\n- Featured in Go Weekly [#495](https://golangweekly.com/issues/495) & [#498](https://golangweekly.com/issues/498)\n- [Bump.sh Deploying Docs from Huma](https://docs.bump.sh/guides/bump-sh-tutorials/huma/)\n- Mentioned in [Composable HTTP Handlers Using Generics](https://www.willem.dev/articles/generic-http-handlers/)\n\nBe sure to star the project if you find it useful!\n\n<a href=\"https://star-history.com/#danielgtaylor/huma&Date\">\n\t<picture>\n\t\t<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://api.star-history.com/svg?repos=danielgtaylor/huma&type=Date&theme=dark\" />\n\t\t<source media=\"(prefers-color-scheme: light)\" srcset=\"https://api.star-history.com/svg?repos=danielgtaylor/huma&type=Date\" />\n\t\t<img alt=\"Star History Chart\" src=\"https://api.star-history.com/svg?repos=danielgtaylor/huma&type=Date\" />\n\t</picture>\n</a>\n"
        },
        {
          "name": "README_CN.md",
          "type": "blob",
          "size": 9.7880859375,
          "content": "<a href=\"#\">\n\t<picture>\n\t\t<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://huma.rocks/huma-dark.png\" />\n\t\t<source media=\"(prefers-color-scheme: light)\" srcset=\"https://huma.rocks/huma.png\" />\n\t\t<img alt=\"Huma Logo\" src=\"https://huma.rocks/huma.png\" />\n\t</picture>\n</a>\n\n[![HUMA Powered](https://img.shields.io/badge/Powered%20By-HUMA-f40273)](https://huma.rocks/) [![CI](https://github.com/danielgtaylor/huma/workflows/CI/badge.svg?branch=main)](https://github.com/danielgtaylor/huma/actions?query=workflow%3ACI+branch%3Amain++) [![codecov](https://codecov.io/gh/danielgtaylor/huma/branch/main/graph/badge.svg)](https://codecov.io/gh/danielgtaylor/huma) [![Docs](https://godoc.org/github.com/danielgtaylor/huma/v2?status.svg)](https://pkg.go.dev/github.com/danielgtaylor/huma/v2?tab=doc) [![Go Report Card](https://goreportcard.com/badge/github.com/danielgtaylor/huma/v2)](https://goreportcard.com/report/github.com/danielgtaylor/huma/v2)\n\n[**üåéEnglish Documentation**](./README.md)\n\n- [‰ªÄ‰πàÊòØ huma?](#intro)\n- [ÂÆâË£Ö](#install)\n- [Ê†∑‰æã](#example)\n- [ÊñáÊ°£](#documentation)\n\n<a name=\"intro\"></a>\n‰∏Ä‰∏™Áé∞‰ª£„ÄÅÁÆÄÂçï„ÄÅÂø´ÈÄü‰∏îÁÅµÊ¥ªÁöÑÂæÆÊ°ÜÊû∂ÔºåÁî®‰∫éÂú® OpenAPI 3 Âíå JSON Schema ÊîØÊåÅÁöÑ Go ‰∏≠ÊûÑÂª∫ HTTP REST/RPC API„ÄÇÂõΩÈôÖÈü≥Ê†áÂèëÈü≥Ôºö[/'hjuÀêm…ë/](https://en.wiktionary.org/wiki/Wiktionary:International_Phonetic_Alphabet)„ÄÇËØ•È°πÁõÆÁöÑÁõÆÊ†áÊòØÊèê‰æõÔºö\n\n- Êã•ÊúâÁé∞ÊúâÊúçÂä°ÁöÑÂõ¢ÈòüÈÄêÊ≠•ÈááÁî®\n  - Â∏¶‰∏äÊÇ®Ëá™Â∑±ÁöÑË∑ØÁî±Âô®ÔºàÂåÖÊã¨ Go 1.22+Ôºâ„ÄÅ‰∏≠Èó¥‰ª∂ÂíåÊó•ÂøóËÆ∞ÂΩï/ÊåáÊ†á\n  - ÂèØÊâ©Â±ïÁöÑ OpenAPI Âíå JSON Schema Â±ÇÊù•ËÆ∞ÂΩïÁé∞ÊúâË∑ØÁî±\n- ÈÄÇÂêà Go ÂºÄÂèë‰∫∫ÂëòÁöÑÁé∞‰ª£ REST Êàñ HTTP RPC API ÂêéÁ´ØÊ°ÜÊû∂\n  - [Áî±OpenAPI 3.1](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md)Âíå[JSON Schema](https://json-schema.org/)ÊèèËø∞\n- Èò≤Ê≠¢Â∏∏ËßÅÈîôËØØÁöÑÊä§Ê†è\n- ‰∏ç‰ºöËøáÊó∂ÁöÑÊñáÊ°£\n- ÁîüÊàêÁöÑÈ´òË¥®ÈáèÂºÄÂèë‰∫∫ÂëòÂ∑•ÂÖ∑\n\nÁâπÁÇπÂåÖÊã¨Ôºö\n\n- ÊÇ®ÈÄâÊã©ÁöÑË∑ØÁî±Âô®‰πã‰∏äÁöÑÂ£∞ÊòéÂºèÊé•Âè£Ôºö\n  - Êìç‰ΩúÂíåÊ®°ÂûãÊñáÊ°£\n  - ËØ∑Ê±ÇÂèÇÊï∞ÔºàË∑ØÂæÑ„ÄÅÊü•ËØ¢„ÄÅÊ†áÂ§¥Êàñ cookieÔºâ\n  - ËØ∑Ê±ÇÊ≠£Êñá\n  - ÂìçÂ∫îÔºàÂåÖÊã¨ÈîôËØØÔºâ\n  - ÂìçÂ∫îÊ†áÂ§¥\n- [‰ΩøÁî®RFC9457](https://datatracker.ietf.org/doc/html/rfc9457)ÂíåÈªòËÆ§ÊÉÖÂÜµ‰∏ãÁöÑJSON ÈîôËØØ`application/problem+json`Ôºà‰ΩÜÂèØ‰ª•Êõ¥ÊîπÔºâ\n- ÊØè‰∏™Êìç‰ΩúÁöÑËØ∑Ê±ÇÂ§ßÂ∞èÈôêÂà∂‰∏éÂêàÁêÜÁöÑÈªòËÆ§ÂÄº\n- ÊúçÂä°Âô®ÂíåÂÆ¢Êà∑Á´Ø‰πãÈó¥ÁöÑ [ÂÜÖÂÆπÂçèÂïÜ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)\n  - ÈÄöËøáÈªòËÆ§ÈÖçÁΩÆÁöÑÊ†áÂ§¥ÊîØÊåÅ JSON ( [RFC 8259](https://tools.ietf.org/html/rfc8259) ) ÂíåÂèØÈÄâÁöÑ CBOR ( [RFC 7049](https://tools.ietf.org/html/rfc7049) ) ÂÜÖÂÆπÁ±ªÂûã„ÄÇ`Accept`\n- Êù°‰ª∂ËØ∑Ê±ÇÊîØÊåÅÔºå‰æãÂ¶Ç`If-Match`Êàñ`If-Unmodified-Since`header ÂÆûÁî®Á®ãÂ∫è„ÄÇ\n- ÂèØÈÄâÁöÑËá™Âä®ÁîüÊàê `PATCH` Êìç‰ΩúÊîØÊåÅÔºö\n  - [RFC 7386](https://www.rfc-editor.org/rfc/rfc7386) JSON ÂêàÂπ∂Ë°•‰∏Å\n  - [RFC 6902](https://www.rfc-editor.org/rfc/rfc6902) JSON Ë°•‰∏Å\n  - [ÈÄüËÆ∞](https://github.com/danielgtaylor/shorthand)Ë°•‰∏Å\n- ËæìÂÖ•ÂíåËæìÂá∫Ê®°ÂûãÁöÑÂ∏¶Ê≥®ÈáäÁöÑ Go Á±ªÂûã\n  - ‰ªé Go Á±ªÂûãÁîüÊàê JSON Ê®°Âºè\n  - Ë∑ØÂæÑ/Êü•ËØ¢/Ê†áÂ§¥ÂèÇÊï∞„ÄÅÊ≠£Êñá„ÄÅÂìçÂ∫îÊ†áÂ§¥Á≠âÁöÑÈùôÊÄÅÁ±ªÂûã„ÄÇ\n  - Ëá™Âä®ËæìÂÖ•Ê®°ÂûãÈ™åËØÅÂíåÈîôËØØÂ§ÑÁêÜ\n- [‰ΩøÁî®Stoplight Elements](https://stoplight.io/open-source/elements)ÁîüÊàêÊñáÊ°£\n- ÂèØÈÄâÁöÑÂÜÖÁΩÆ CLIÔºåÈÄöËøáÂèÇÊï∞ÊàñÁéØÂ¢ÉÂèòÈáèËøõË°åÈÖçÁΩÆ\n  - `-p 8000`ÈÄöËøá‰æãÂ¶Ç„ÄÅ`--port=8000`„ÄÅ ÊàñËÆæÁΩÆ`SERVICE_PORT=8000`\n  - ÂÜÖÁΩÆÂêØÂä®Êìç‰ΩúÂíåÊ≠£Â∏∏ÂÖ≥Èó≠\n- ÁîüÊàê OpenAPI ‰ª•ËÆøÈóÆ‰∏∞ÂØåÁöÑÂ∑•ÂÖ∑ÁîüÊÄÅÁ≥ªÁªü\n  - ‰ΩøÁî®[API Sprout](https://github.com/danielgtaylor/apisprout)Êàñ[PrismËøõË°åÊ®°Êãü](https://stoplight.io/open-source/prism)\n  - [Â∏¶ÊúâOpenAPI Generator](https://github.com/OpenAPITools/openapi-generator)Êàñ[oapi-codegen ÁöÑ](https://github.com/deepmap/oapi-codegen)SDK\n  - CLI ‰∏é[Restish](https://rest.sh/)\n  - ËøòÊúâ[Êõ¥Â§ö](https://openapi.tools/) \n- ‰ΩøÁî®ÂèØÈÄâ`describedby`ÈìæÊé•ÂÖ≥Á≥ªÊ†áÂ§¥‰ª•Âèä`$schema`ËøîÂõûÂØπË±°‰∏≠ÁöÑÂèØÈÄâÂ±ûÊÄß‰∏∫ÊØè‰∏™ËµÑÊ∫êÁîüÊàê JSON Êû∂ÊûÑÔºåËøô‰∫õÂ±ûÊÄßÈõÜÊàêÂà∞ÁºñËæëÂô®‰∏≠‰ª•ËøõË°åÈ™åËØÅÂíåÂÆåÊàê„ÄÇ\n\nËØ•È°πÁõÆÁöÑÁÅµÊÑüÊù•Ëá™[FastAPI](https://fastapi.tiangolo.com/)„ÄÇÊ†áÂøóÂíåÂìÅÁâåÁî±Âç°Èáå¬∑Ê≥∞ÂãíËÆæËÆ°„ÄÇ\n\n## ËµûÂä©ÂïÜ\n\nÈùûÂ∏∏ÊÑüË∞¢Êàë‰ª¨Áé∞‰ªªÂíåÂâç‰ªªÁöÑËµûÂä©ÂïÜÔºö\n\n- [@bclements](https://github.com/bclements)\n- [@bekabaz](https://github.com/bekabaz)\n- [@victoraugustolls](https://github.com/victoraugustolls)\n\n## ÊÑüË®Ä\n\n> ËøôÊòØËøÑ‰ªä‰∏∫Ê≠¢ÊàëÊúÄÂñúÊ¨¢ÁöÑ Go Web Ê°ÜÊû∂„ÄÇÂÆÉÂèóÂà∞ FastAPI ÁöÑÂêØÂèëÔºåËøô‰πüÂæàÊ£íÔºåÂπ∂‰∏îÁ¨¶ÂêàÂ∏∏ËßÅ Web ‰∫ãÁâ©ÁöÑËÆ∏Â§ö RFC...ÊàëÁúüÁöÑÂæàÂñúÊ¨¢Ëøô‰∏™ÂäüËÉΩÈõÜÔºåÂÆÉ[ÂèØ‰ª•‰ΩøÁî®] ChiÔºåËÄå‰∏îÂÆÉÂú®ÊüêÁßçÁ®ãÂ∫¶‰∏ä‰ªçÁÑ∂Áõ∏ÂØπÁÆÄÂçï‰ΩøÁî®„ÄÇÊàëÂ∞ùËØïËøáÂÖ∂‰ªñÊ°ÜÊû∂Ôºå‰ΩÜÂÆÉ‰ª¨Âπ∂Ê≤°ÊúâÁªôÊàëÂ∏¶Êù•Âø´‰πê„ÄÇ - [Jeb_Jenky](https://www.reddit.com/r/golang/comments/zhitcg/comment/izmg6vk/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> ‰ΩøÁî® #Golang ‰∏ÄÂπ¥Â§öÂêéÔºåÊàëÂÅ∂ÁÑ∂ÂèëÁé∞‰∫Ü HumaÔºå‰∏Ä‰∏™Âèó #FastAPI ÂêØÂèëÁöÑ Web Ê°ÜÊû∂„ÄÇËøôÂ∞±ÊòØÊàë‰∏ÄÁõ¥ÊúüÁõºÁöÑÂú£ËØûÂ•áËøπÔºÅËøô‰∏™Ê°ÜÊû∂‰ªÄ‰πàÈÉΩÊúâÔºÅ- [Hana Mohan](https://twitter.com/unamashana/status/1733088066053583197)\n\n> ÊàëÁà±ËÉ°Áéõ„ÄÇÁúüËØöÂú∞ÊÑüË∞¢ÊÇ®Êèê‰æõËøô‰∏™ÂæàÊ£íÁöÑÂåÖË£π„ÄÇÊàëÂ∑≤Áªè‰ΩøÁî®ÂÆÉÊúâ‰∏ÄÊÆµÊó∂Èó¥‰∫ÜÔºåÊïàÊûúÈùûÂ∏∏Â•ΩÔºÅ - [plscott](https://www.reddit.com/r/golang/comments/1aoshey/comment/kq6hcpd/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> Ë∞¢Ë∞¢‰∏πÂ∞ºÂ∞î‰∏∫ËÉ°Áéõ„ÄÇÈùûÂ∏∏ÊúâÁî®ÁöÑÈ°πÁõÆÔºåÂπ∂‰∏îÁî±‰∫é OpenAPI gen ‰∏∫Êàë‰ª¨ËäÇÁúÅ‰∫ÜÂ§ßÈáèÁöÑÊó∂Èó¥ÂíåÈ∫ªÁÉ¶‚Äî‚ÄîÁ±ª‰ºº‰∫é Python ‰∏≠ÁöÑ FastAPI„ÄÇ - [WolvesOfAllStreets](https://www.reddit.com/r/golang/comments/1aqj99d/comment/kqfqcml/?utm_source=reddit&utm_medium=web2x&context=3)\n\n> Huma ÂæàÊ£íÔºåÊàëÊúÄËøëÂºÄÂßã‰ΩøÁî®ÂÆÉÔºåÂæàÈ´òÂÖ¥ÔºåÊâÄ‰ª•ÈùûÂ∏∏ÊÑüË∞¢ÊÇ®ÁöÑÂä™Âäõüôè  - [callmemicah](https://www.reddit.com/r/golang/comments/1b32ts4/comment/ksvr9h7/?utm_source=reddit&utm_medium=web2x&context=3)\n\n# ÂÆâË£Ö\n\nÈÄöËøáÂÆâË£Ö`go get`„ÄÇËØ∑Ê≥®ÊÑèÔºåÈúÄË¶Å Go 1.21 ÊàñÊõ¥È´òÁâàÊú¨„ÄÇ\n\n```sh\n# After: go mod init ...\ngo get -u github.com/danielgtaylor/huma/v2\n```\n\n# ‰æãÂ≠ê\n\nËøôÊòØ Huma ‰∏≠ÁöÑ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÂü∫Êú¨ hello world Á§∫‰æãÔºåÂ±ïÁ§∫‰∫ÜÂ¶Ç‰Ωï‰ΩøÁî® CLI ÂàùÂßãÂåñ Huma Â∫îÁî®Á®ãÂ∫è„ÄÅÂ£∞ÊòéËµÑÊ∫êÊìç‰ΩúÂπ∂ÂÆö‰πâÂÖ∂Â§ÑÁêÜÂáΩÊï∞„ÄÇ\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI. Pass `--port` or set the `SERVICE_PORT` env var.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Add the operation handler to the API.\n\t\thuma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n> [!TIP]\n> ÊõøÊç¢`chi.NewMux()`‚Üí`http.NewServeMux()`Âíå`humachi.New`‚Üí`humago.New`‰ª•‰ΩøÁî® Go 1.22+ ‰∏≠ÁöÑÊ†áÂáÜÂ∫ìË∑ØÁî±Âô®„ÄÇÂè™ÈúÄÁ°Æ‰øùÂÖ∂‰∏≠ÂàóÂá∫‰∫ÜÊÇ®ÁöÑÊàñÊõ¥Êñ∞ÁöÑ`go.mod`ÁâàÊú¨Âç≥ÂèØ„ÄÇ`go 1.22`ÂÖ∂‰ªñ‰∏ÄÂàáÈÉΩ‰øùÊåÅ‰∏çÂèòÔºÅÂΩì‰Ω†ÂáÜÂ§áÂ•ΩÊó∂Â∞±ÂàáÊç¢„ÄÇ\n\n‰Ω†ÂèØ‰ª•Áî® `go run greet.go` ÊµãËØïÂÆÉÔºàÂèØÈÄâÂú∞‰º†ÈÄí '--port' Êù•Êõ¥ÊîπÈªòËÆ§ÂÄºÔºâÔºåÂπ∂‰ΩøÁî® [Restish](https://rest.sh/)ÔºàÊàñ `curl`Ôºâ ÂèëÂá∫Á§∫‰æãËØ∑Ê±ÇÔºö\n\n```sh\n# Get the message from the server\n$ restish :8888/greeting/world\nHTTP/1.1 200 OK\n...\n{\n\t$schema: \"http://localhost:8888/schemas/GreetingOutputBody.json\",\n\tmessage: \"Hello, world!\"\n}\n```\n\nÂ∞ΩÁÆ°Á§∫‰æãÂæàÂ∞èÔºåÊÇ®‰πüÂèØ‰ª•Âú® http://localhost:8888/docs ‰∏äÁúãÂà∞‰∏Ä‰∫õÁîüÊàêÁöÑÊñáÊ°£„ÄÇÁîüÊàêÁöÑ OpenAPI ÂèØÂú® http://localhost:8888/openapi.json Êàñ http://localhost:8888/openapi.yaml Ëé∑Âèñ„ÄÇ\n\nÊü•Áúã[Huma ÊïôÁ®ã](https://huma.rocks/tutorial/installation/)ÔºåËé∑ÂèñÂÖ•Èó®ÂàÜÊ≠•ÊåáÂçó„ÄÇ\n\n# ÊñáÊ°£\n\nËØ∑ÂèÇÈòÖ https://huma.rocks/ ÁΩëÁ´ôÔºåËé∑ÂèñÊºîÁ§∫ÊñáÁ®ø‰∏≠ÁöÑÂÆåÊï¥ÊñáÊ°£ÔºåËØ•ÊºîÁ§∫ÊñáÁ®øÊØîÊú¨Ëá™Ëø∞Êñá‰ª∂Êõ¥Êòì‰∫éÂØºËà™ÂíåÊêúÁ¥¢„ÄÇÊÇ®ÂèØ‰ª•Âú®`docs`Ê≠§Â≠òÂÇ®Â∫ìÁöÑÁõÆÂΩï‰∏≠ÊâæÂà∞ËØ•Á´ôÁÇπÁöÑÊ∫ê‰ª£Á†Å„ÄÇ\n\nÂÆòÊñπ Go ÂåÖÊñáÊ°£ÂßãÁªàÂèØ‰ª•Âú® https://pkg.go.dev/github.com/danielgtaylor/huma/v2 ÊâæÂà∞„ÄÇ\n\n# ÊñáÁ´†ÂíåÊèêÂèä\n\n- [Go ‰∏≠ÁöÑ API ‰∏é Huma 2.0](https://dgt.hashnode.dev/apis-in-go-with-huma-20)\n- [ÂáèÂ∞ë Go ‰æùËµñÔºöHuma ‰∏≠ÂáèÂ∞ë‰æùËµñÁöÑÊ°à‰æãÁ†îÁ©∂](https://dgt.hashnode.dev/reducing-go-dependencies)\n- [Âú® Twitter/X ‰∏äÂàÜ‰∫´ÁöÑ Golang Êñ∞Èóª„ÄÅÂ∫ìÂíåÂ∑•‰Ωú](https://twitter.com/golangch/status/1752175499701264532)\n- [Go Weekly #495](https://golangweekly.com/issues/495) & [#498](https://golangweekly.com/issues/498)Á≤æÈÄâ\n- [Bump.sh ‰ªé Huma ÈÉ®ÁΩ≤ÊñáÊ°£](https://docs.bump.sh/guides/bump-sh-tutorials/huma/)\n- [‰ΩøÁî®Ê≥õÂûãÁöÑÂèØÁªÑÂêà HTTP Â§ÑÁêÜÁ®ãÂ∫è](https://www.willem.dev/articles/generic-http-handlers/)‰∏≠ÊèêÂà∞\n\nÂ¶ÇÊûúÊÇ®ËßâÂæóËØ•È°πÁõÆÊúâÁî®ÔºåËØ∑Âä°ÂøÖ‰∏∫ËØ•È°πÁõÆÂä†Ê≥®ÊòüÊ†áÔºÅ\n\n<a href=\"https://star-history.com/#danielgtaylor/huma&Date\">\n\t<picture>\n\t\t<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://api.star-history.com/svg?repos=danielgtaylor/huma&type=Date&theme=dark\" />\n\t\t<source media=\"(prefers-color-scheme: light)\" srcset=\"https://api.star-history.com/svg?repos=danielgtaylor/huma&type=Date\" />\n\t\t<img alt=\"Star History Chart\" src=\"https://api.star-history.com/svg?repos=danielgtaylor/huma&type=Date\" />\n\t</picture>\n</a>\n"
        },
        {
          "name": "adapters",
          "type": "tree",
          "content": null
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 15.8642578125,
          "content": "package huma\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2/negotiation\"\n)\n\nvar rxSchema = regexp.MustCompile(`#/components/schemas/([^\"]+)`)\n\nvar ErrUnknownContentType = errors.New(\"unknown content type\")\n\n// Resolver runs a `Resolve` function after a request has been parsed, enabling\n// you to run custom validation or other code that can modify the request and /\n// or return errors.\ntype Resolver interface {\n\tResolve(ctx Context) []error\n}\n\n// ResolverWithPath runs a `Resolve` function after a request has been parsed,\n// enabling you to run custom validation or other code that can modify the\n// request and / or return errors. The `prefix` is the path to the current\n// location for errors, e.g. `body.foo[0].bar`.\ntype ResolverWithPath interface {\n\tResolve(ctx Context, prefix *PathBuffer) []error\n}\n\nvar (\n\tresolverType         = reflect.TypeOf((*Resolver)(nil)).Elem()\n\tresolverWithPathType = reflect.TypeOf((*ResolverWithPath)(nil)).Elem()\n)\n\n// Adapter is an interface that allows the API to be used with different HTTP\n// routers and frameworks. It is designed to work with the standard library\n// `http.Request` and `http.ResponseWriter` types as well as types like\n// `gin.Context` or `fiber.Ctx` that provide both request and response\n// functionality in one place, by using the `huma.Context` interface which\n// abstracts away those router-specific differences.\n//\n// The handler function takes uses the context to get request information like\n// path / query / header params, the input body, and provide response data\n// like a status code, response headers, and a response body.\ntype Adapter interface {\n\tHandle(op *Operation, handler func(ctx Context))\n\tServeHTTP(http.ResponseWriter, *http.Request)\n}\n\n// Context is the current request/response context. It provides a generic\n// interface to get request information and write responses.\ntype Context interface {\n\t// Operation returns the OpenAPI operation that matched the request.\n\tOperation() *Operation\n\n\t// Context returns the underlying request context.\n\tContext() context.Context\n\n\t// TLS / SSL connection information.\n\tTLS() *tls.ConnectionState\n\n\t// Version of the HTTP protocol as text and integers.\n\tVersion() ProtoVersion\n\n\t// Method returns the HTTP method for the request.\n\tMethod() string\n\n\t// Host returns the HTTP host for the request.\n\tHost() string\n\n\t// RemoteAddr returns the remote address of the client.\n\tRemoteAddr() string\n\n\t// URL returns the full URL for the request.\n\tURL() url.URL\n\n\t// Param returns the value for the given path parameter.\n\tParam(name string) string\n\n\t// Query returns the value for the given query parameter.\n\tQuery(name string) string\n\n\t// Header returns the value for the given header.\n\tHeader(name string) string\n\n\t// EachHeader iterates over all headers and calls the given callback with\n\t// the header name and value.\n\tEachHeader(cb func(name, value string))\n\n\t// BodyReader returns the request body reader.\n\tBodyReader() io.Reader\n\n\t// GetMultipartForm returns the parsed multipart form, if any.\n\tGetMultipartForm() (*multipart.Form, error)\n\n\t// SetReadDeadline sets the read deadline for the request body.\n\tSetReadDeadline(time.Time) error\n\n\t// SetStatus sets the HTTP status code for the response.\n\tSetStatus(code int)\n\n\t// Status returns the HTTP status code for the response.\n\tStatus() int\n\n\t// SetHeader sets the given header to the given value, overwriting any\n\t// existing value. Use `AppendHeader` to append a value instead.\n\tSetHeader(name, value string)\n\n\t// AppendHeader appends the given value to the given header.\n\tAppendHeader(name, value string)\n\n\t// BodyWriter returns the response body writer.\n\tBodyWriter() io.Writer\n}\n\n// Represent http protocol version\ntype ProtoVersion struct {\n\tProto      string\n\tProtoMajor int\n\tProtoMinor int\n}\n\ntype (\n\thumaContext Context\n\tsubContext  struct {\n\t\thumaContext\n\t\toverride context.Context\n\t}\n)\n\nfunc (c subContext) Context() context.Context {\n\treturn c.override\n}\n\n// WithContext returns a new `huma.Context` with the underlying `context.Context`\n// replaced with the given one. This is useful for middleware that needs to\n// modify the request context.\nfunc WithContext(ctx Context, override context.Context) Context {\n\treturn subContext{humaContext: ctx, override: override}\n}\n\n// WithValue returns a new `huma.Context` with the given key and value set in\n// the underlying `context.Context`. This is useful for middleware that needs to\n// set request-scoped values.\nfunc WithValue(ctx Context, key, value any) Context {\n\treturn WithContext(ctx, context.WithValue(ctx.Context(), key, value))\n}\n\n// Transformer is a function that can modify a response body before it is\n// serialized. The `status` is the HTTP status code for the response and `v` is\n// the value to be serialized. The return value is the new value to be\n// serialized or an error.\ntype Transformer func(ctx Context, status string, v any) (any, error)\n\n// Config represents a configuration for a new API. See `huma.DefaultConfig()`\n// as a starting point.\ntype Config struct {\n\t// OpenAPI spec for the API. You should set at least the `Info.Title` and\n\t// `Info.Version` fields.\n\t*OpenAPI\n\n\t// OpenAPIPath is the path to the OpenAPI spec without extension. If set\n\t// to `/openapi` it will allow clients to get `/openapi.json` or\n\t// `/openapi.yaml`, for example.\n\tOpenAPIPath string\n\n\t// DocsPath is the path to the API documentation. If set to `/docs` it will\n\t// allow clients to get `/docs` to view the documentation in a browser. If\n\t// you wish to provide your own documentation renderer, you can leave this\n\t// blank and attach it directly to the router or adapter.\n\tDocsPath string\n\n\t// SchemasPath is the path to the API schemas. If set to `/schemas` it will\n\t// allow clients to get `/schemas/{schema}` to view the schema in a browser\n\t// or for use in editors like VSCode to provide autocomplete & validation.\n\tSchemasPath string\n\n\t// Formats defines the supported request/response formats by content type or\n\t// extension (e.g. `json` for `application/my-format+json`).\n\tFormats map[string]Format\n\n\t// DefaultFormat specifies the default content type to use when the client\n\t// does not specify one. If unset, the default type will be randomly\n\t// chosen from the keys of `Formats`.\n\tDefaultFormat string\n\n\t// Transformers are a way to modify a response body before it is serialized.\n\tTransformers []Transformer\n\n\t// CreateHooks is a list of functions that will be called before the API is\n\t// created. This allows you to modify the configuration at creation time,\n\t// for example if you need access to the path settings that may be changed\n\t// by the user after the defaults have been set.\n\tCreateHooks []func(Config) Config\n}\n\n// API represents a Huma API wrapping a specific router.\ntype API interface {\n\t// Adapter returns the router adapter for this API, providing a generic\n\t// interface to get request information and write responses.\n\tAdapter() Adapter\n\n\t// OpenAPI returns the OpenAPI spec for this API. You may edit this spec\n\t// until the server starts.\n\tOpenAPI() *OpenAPI\n\n\t// Negotiate returns the selected content type given the client's `accept`\n\t// header and the server's supported content types. If the client does not\n\t// send an `accept` header, then JSON is used.\n\tNegotiate(accept string) (string, error)\n\n\t// Transform runs the API transformers on the given value. The `status` is\n\t// the key in the operation's `Responses` map that corresponds to the\n\t// response being sent (e.g. \"200\" for a 200 OK response).\n\tTransform(ctx Context, status string, v any) (any, error)\n\n\t// Marshal marshals the given value into the given writer. The\n\t// content type is used to determine which format to use. Use `Negotiate` to\n\t// get the content type from an accept header.\n\tMarshal(w io.Writer, contentType string, v any) error\n\n\t// Unmarshal unmarshals the given data into the given value. The content type\n\tUnmarshal(contentType string, data []byte, v any) error\n\n\t// UseMiddleware appends a middleware handler to the API middleware stack.\n\t//\n\t// The middleware stack for any API will execute before searching for a matching\n\t// route to a specific handler, which provides opportunity to respond early,\n\t// change the course of the request execution, or set request-scoped values for\n\t// the next Middleware.\n\tUseMiddleware(middlewares ...func(ctx Context, next func(Context)))\n\n\t// Middlewares returns a slice of middleware handler functions that will be\n\t// run for all operations. Middleware are run in the order they are added.\n\t// See also `huma.Operation{}.Middlewares` for adding operation-specific\n\t// middleware at operation registration time.\n\tMiddlewares() Middlewares\n}\n\n// Format represents a request / response format. It is used to marshal and\n// unmarshal data.\ntype Format struct {\n\t// Marshal a value to a given writer (e.g. response body).\n\tMarshal func(writer io.Writer, v any) error\n\n\t// Unmarshal a value into `v` from the given bytes (e.g. request body).\n\tUnmarshal func(data []byte, v any) error\n}\n\ntype api struct {\n\tconfig       Config\n\tadapter      Adapter\n\tformats      map[string]Format\n\tformatKeys   []string\n\ttransformers []Transformer\n\tmiddlewares  Middlewares\n}\n\nfunc (a *api) Adapter() Adapter {\n\treturn a.adapter\n}\n\nfunc (a *api) OpenAPI() *OpenAPI {\n\treturn a.config.OpenAPI\n}\n\nfunc (a *api) Unmarshal(contentType string, data []byte, v any) error {\n\t// Handle e.g. `application/json; charset=utf-8` or `my/format+json`\n\tstart := strings.IndexRune(contentType, '+') + 1\n\tend := strings.IndexRune(contentType, ';')\n\tif end == -1 {\n\t\tend = len(contentType)\n\t}\n\tct := contentType[start:end]\n\tif ct == \"\" {\n\t\t// Default to assume JSON since this is an API.\n\t\tct = \"application/json\"\n\t}\n\tf, ok := a.formats[ct]\n\tif !ok {\n\t\treturn fmt.Errorf(\"%w: %s\", ErrUnknownContentType, contentType)\n\t}\n\treturn f.Unmarshal(data, v)\n}\n\nfunc (a *api) Negotiate(accept string) (string, error) {\n\tct := negotiation.SelectQValueFast(accept, a.formatKeys)\n\tif ct == \"\" && a.formatKeys != nil {\n\t\tct = a.formatKeys[0]\n\t}\n\tif _, ok := a.formats[ct]; !ok {\n\t\treturn ct, fmt.Errorf(\"unknown content type: %s\", ct)\n\t}\n\treturn ct, nil\n}\n\nfunc (a *api) Transform(ctx Context, status string, v any) (any, error) {\n\tvar err error\n\tfor _, t := range a.transformers {\n\t\tv, err = t(ctx, status, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn v, nil\n}\n\nfunc (a *api) Marshal(w io.Writer, ct string, v any) error {\n\tf, ok := a.formats[ct]\n\tif !ok {\n\t\tstart := strings.IndexRune(ct, '+') + 1\n\t\tf, ok = a.formats[ct[start:]]\n\t}\n\tif !ok {\n\t\treturn fmt.Errorf(\"unknown content type: %s\", ct)\n\t}\n\treturn f.Marshal(w, v)\n}\n\nfunc (a *api) UseMiddleware(middlewares ...func(ctx Context, next func(Context))) {\n\ta.middlewares = append(a.middlewares, middlewares...)\n}\n\nfunc (a *api) Middlewares() Middlewares {\n\treturn a.middlewares\n}\n\n// getAPIPrefix returns the API prefix from the first server URL in the OpenAPI\n// spec. If no server URL is set, then an empty string is returned.\nfunc getAPIPrefix(oapi *OpenAPI) string {\n\tfor _, server := range oapi.Servers {\n\t\tif u, err := url.Parse(server.URL); err == nil && u.Path != \"\" {\n\t\t\treturn u.Path\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// NewAPI creates a new API with the given configuration and router adapter.\n// You usually don't need to use this function directly, and can instead use\n// the `New(...)` function provided by the adapter packages which call this\n// function internally.\n//\n// When the API is created, this function will ensure a schema registry exists\n// (or create a new map registry if not), will set a default format if not\n// set, and will set up the handlers for the OpenAPI spec, documentation, and\n// JSON schema routes if the paths are set in the config.\n//\n//\trouter := chi.NewMux()\n//\tadapter := humachi.NewAdapter(router)\n//\tconfig := huma.DefaultConfig(\"Example API\", \"1.0.0\")\n//\tapi := huma.NewAPI(config, adapter)\nfunc NewAPI(config Config, a Adapter) API {\n\tfor i := 0; i < len(config.CreateHooks); i++ {\n\t\tconfig = config.CreateHooks[i](config)\n\t}\n\n\tnewAPI := &api{\n\t\tconfig:       config,\n\t\tadapter:      a,\n\t\tformats:      map[string]Format{},\n\t\ttransformers: config.Transformers,\n\t}\n\n\tif config.OpenAPI == nil {\n\t\tconfig.OpenAPI = &OpenAPI{}\n\t}\n\n\tif config.OpenAPI.OpenAPI == \"\" {\n\t\tconfig.OpenAPI.OpenAPI = \"3.1.0\"\n\t}\n\n\tif config.OpenAPI.Components == nil {\n\t\tconfig.OpenAPI.Components = &Components{}\n\t}\n\n\tif config.OpenAPI.Components.Schemas == nil {\n\t\tconfig.OpenAPI.Components.Schemas = NewMapRegistry(\"#/components/schemas/\", DefaultSchemaNamer)\n\t}\n\n\tif config.DefaultFormat == \"\" && config.Formats[\"application/json\"].Marshal != nil {\n\t\tconfig.DefaultFormat = \"application/json\"\n\t}\n\tif config.DefaultFormat != \"\" {\n\t\tnewAPI.formatKeys = append(newAPI.formatKeys, config.DefaultFormat)\n\t}\n\tfor k, v := range config.Formats {\n\t\tnewAPI.formats[k] = v\n\t\tnewAPI.formatKeys = append(newAPI.formatKeys, k)\n\t}\n\n\tif config.OpenAPIPath != \"\" {\n\t\tvar specJSON []byte\n\t\ta.Handle(&Operation{\n\t\t\tMethod: http.MethodGet,\n\t\t\tPath:   config.OpenAPIPath + \".json\",\n\t\t}, func(ctx Context) {\n\t\t\tctx.SetHeader(\"Content-Type\", \"application/vnd.oai.openapi+json\")\n\t\t\tif specJSON == nil {\n\t\t\t\tspecJSON, _ = json.Marshal(newAPI.OpenAPI())\n\t\t\t}\n\t\t\tctx.BodyWriter().Write(specJSON)\n\t\t})\n\t\tvar specJSON30 []byte\n\t\ta.Handle(&Operation{\n\t\t\tMethod: http.MethodGet,\n\t\t\tPath:   config.OpenAPIPath + \"-3.0.json\",\n\t\t}, func(ctx Context) {\n\t\t\tctx.SetHeader(\"Content-Type\", \"application/vnd.oai.openapi+json\")\n\t\t\tif specJSON30 == nil {\n\t\t\t\tspecJSON30, _ = newAPI.OpenAPI().Downgrade()\n\t\t\t}\n\t\t\tctx.BodyWriter().Write(specJSON30)\n\t\t})\n\t\tvar specYAML []byte\n\t\ta.Handle(&Operation{\n\t\t\tMethod: http.MethodGet,\n\t\t\tPath:   config.OpenAPIPath + \".yaml\",\n\t\t}, func(ctx Context) {\n\t\t\tctx.SetHeader(\"Content-Type\", \"application/vnd.oai.openapi+yaml\")\n\t\t\tif specYAML == nil {\n\t\t\t\tspecYAML, _ = newAPI.OpenAPI().YAML()\n\t\t\t}\n\t\t\tctx.BodyWriter().Write(specYAML)\n\t\t})\n\t\tvar specYAML30 []byte\n\t\ta.Handle(&Operation{\n\t\t\tMethod: http.MethodGet,\n\t\t\tPath:   config.OpenAPIPath + \"-3.0.yaml\",\n\t\t}, func(ctx Context) {\n\t\t\tctx.SetHeader(\"Content-Type\", \"application/vnd.oai.openapi+yaml\")\n\t\t\tif specYAML30 == nil {\n\t\t\t\tspecYAML30, _ = newAPI.OpenAPI().DowngradeYAML()\n\t\t\t}\n\t\t\tctx.BodyWriter().Write(specYAML30)\n\t\t})\n\t}\n\n\tif config.DocsPath != \"\" {\n\t\ta.Handle(&Operation{\n\t\t\tMethod: http.MethodGet,\n\t\t\tPath:   config.DocsPath,\n\t\t}, func(ctx Context) {\n\t\t\topenAPIPath := config.OpenAPIPath\n\t\t\tif prefix := getAPIPrefix(newAPI.OpenAPI()); prefix != \"\" {\n\t\t\t\topenAPIPath = path.Join(prefix, openAPIPath)\n\t\t\t}\n\t\t\tctx.SetHeader(\"Content-Type\", \"text/html\")\n\t\t\ttitle := \"Elements in HTML\"\n\t\t\tif config.Info != nil && config.Info.Title != \"\" {\n\t\t\t\ttitle = config.Info.Title + \" Reference\"\n\t\t\t}\n\t\t\tctx.BodyWriter().Write([]byte(`<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"referrer\" content=\"same-origin\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" />\n    <title>` + title + `</title>\n    <!-- Embed elements Elements via Web Component -->\n    <link href=\"https://unpkg.com/@stoplight/elements@8.1.0/styles.min.css\" rel=\"stylesheet\" />\n    <script src=\"https://unpkg.com/@stoplight/elements@8.1.0/web-components.min.js\"\n            integrity=\"sha256-985sDMZYbGa0LDS8jYmC4VbkVlh7DZ0TWejFv+raZII=\"\n            crossorigin=\"anonymous\"></script>\n  </head>\n  <body style=\"height: 100vh;\">\n\n    <elements-api\n      apiDescriptionUrl=\"` + openAPIPath + `.yaml\"\n      router=\"hash\"\n      layout=\"sidebar\"\n      tryItCredentialsPolicy=\"same-origin\"\n    />\n\n  </body>\n</html>`))\n\t\t})\n\t}\n\n\tif config.SchemasPath != \"\" {\n\t\ta.Handle(&Operation{\n\t\t\tMethod: http.MethodGet,\n\t\t\tPath:   config.SchemasPath + \"/{schema}\",\n\t\t}, func(ctx Context) {\n\t\t\t// Some routers dislike a path param+suffix, so we strip it here instead.\n\t\t\tschema := strings.TrimSuffix(ctx.Param(\"schema\"), \".json\")\n\t\t\tctx.SetHeader(\"Content-Type\", \"application/json\")\n\t\t\tb, _ := json.Marshal(config.OpenAPI.Components.Schemas.Map()[schema])\n\t\t\tb = rxSchema.ReplaceAll(b, []byte(config.SchemasPath+`/$1.json`))\n\t\t\tctx.BodyWriter().Write(b)\n\t\t})\n\t}\n\n\treturn newAPI\n}\n"
        },
        {
          "name": "api_test.go",
          "type": "blob",
          "size": 2.2451171875,
          "content": "package huma_test\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBlankConfig(t *testing.T) {\n\tadapter := humatest.NewAdapter()\n\n\tassert.NotPanics(t, func() {\n\t\thuma.NewAPI(huma.Config{}, adapter)\n\t})\n}\n\n// ExampleAdapter_handle demonstrates how to use the adapter directly\n// instead of using the `huma.Register` convenience function to add a new\n// operation and handler to the API.\n//\n// Note that you are responsible for defining all of the operation details,\n// including the parameter and response definitions & schemas.\nfunc ExampleAdapter_handle() {\n\t// Create an adapter for your chosen router.\n\tadapter := NewExampleAdapter()\n\n\t// Register an operation with a custom handler.\n\tadapter.Handle(&huma.Operation{\n\t\tOperationID: \"example-operation\",\n\t\tMethod:      \"GET\",\n\t\tPath:        \"/example/{name}\",\n\t\tSummary:     \"Example operation\",\n\t\tParameters: []*huma.Param{\n\t\t\t{\n\t\t\t\tName:        \"name\",\n\t\t\t\tIn:          \"path\",\n\t\t\t\tDescription: \"Name to return\",\n\t\t\t\tRequired:    true,\n\t\t\t\tSchema: &huma.Schema{\n\t\t\t\t\tType: \"string\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tResponses: map[string]*huma.Response{\n\t\t\t\"200\": {\n\t\t\t\tDescription: \"OK\",\n\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\"text/plain\": {\n\t\t\t\t\t\tSchema: &huma.Schema{\n\t\t\t\t\t\t\tType: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, func(ctx huma.Context) {\n\t\t// Get the `name` path parameter.\n\t\tname := ctx.Param(\"name\")\n\n\t\t// Set the response content type, status code, and body.\n\t\tctx.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\tctx.SetStatus(http.StatusOK)\n\t\tctx.BodyWriter().Write([]byte(\"Hello, \" + name))\n\t})\n}\n\nfunc TestContextValue(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t// Make an updated context available to the handler.\n\t\tctx = huma.WithValue(ctx, \"foo\", \"bar\")\n\t\tnext(ctx)\n\t\tassert.Equal(t, http.StatusNoContent, ctx.Status())\n\t})\n\n\t// Register a simple hello world operation in the API.\n\thuma.Get(api, \"/test\", func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\tassert.Equal(t, \"bar\", ctx.Value(\"foo\"))\n\t\treturn nil, nil\n\t})\n\n\tresp := api.Get(\"/test\")\n\tassert.Equal(t, http.StatusNoContent, resp.Code)\n}\n"
        },
        {
          "name": "autoconfig.go",
          "type": "blob",
          "size": 1.126953125,
          "content": "package huma\n\n// AutoConfigVar represents a variable given by the user when prompted during\n// auto-configuration setup of an API.\ntype AutoConfigVar struct {\n\tDescription string        `json:\"description,omitempty\"`\n\tExample     string        `json:\"example,omitempty\"`\n\tDefault     interface{}   `json:\"default,omitempty\"`\n\tEnum        []interface{} `json:\"enum,omitempty\"`\n\n\t// Exclude the value from being sent to the server. This essentially makes\n\t// it a value which is only used in param templates.\n\tExclude bool `json:\"exclude,omitempty\"`\n}\n\n// AutoConfig holds an API's automatic configuration settings for the CLI. These\n// are advertised via OpenAPI extension and picked up by the CLI to make it\n// easier to get started using an API. This struct should be put into the\n// `OpenAPI.Extensions` map under the key `x-cli-config`. See also:\n// https://rest.sh/#/openapi?id=autoconfiguration\ntype AutoConfig struct {\n\tSecurity string                   `json:\"security\"`\n\tHeaders  map[string]string        `json:\"headers,omitempty\"`\n\tPrompt   map[string]AutoConfigVar `json:\"prompt,omitempty\"`\n\tParams   map[string]string        `json:\"params\"`\n}\n"
        },
        {
          "name": "autopatch",
          "type": "tree",
          "content": null
        },
        {
          "name": "autoregister_test.go",
          "type": "blob",
          "size": 1.375,
          "content": "package huma_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n)\n\n// Item represents a single item with a unique ID.\ntype Item struct {\n\tID string `json:\"id\"`\n}\n\n// ItemsResponse is a response containing a list of items.\ntype ItemsResponse struct {\n\tBody []Item `json:\"body\"`\n}\n\n// ItemsHandler handles item-related CRUD operations.\ntype ItemsHandler struct{}\n\n// RegisterListItems registers the `list-items` operation with the given API.\n// Because the method starts with `Register` it will be automatically called\n// by `huma.AutoRegister` down below.\nfunc (s *ItemsHandler) RegisterListItems(api huma.API) {\n\t// Register a list operation to get all the items.\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"list-items\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/items\",\n\t}, func(ctx context.Context, input *struct{}) (*ItemsResponse, error) {\n\t\tresp := &ItemsResponse{}\n\t\tresp.Body = []Item{{ID: \"123\"}}\n\t\treturn resp, nil\n\t})\n}\n\nfunc ExampleAutoRegister() {\n\t// Create the router and API.\n\trouter := http.NewServeMux()\n\tapi := NewExampleAPI(router, huma.DefaultConfig(\"My Service\", \"1.0.0\"))\n\n\t// Create the item handler and register all of its operations.\n\titemsHandler := &ItemsHandler{}\n\thuma.AutoRegister(api, itemsHandler)\n\n\t// Confirm the list operation was registered.\n\tfmt.Println(api.OpenAPI().Paths[\"/items\"].Get.OperationID)\n\t// Output: list-items\n}\n"
        },
        {
          "name": "casing",
          "type": "tree",
          "content": null
        },
        {
          "name": "chain.go",
          "type": "blob",
          "size": 1.041015625,
          "content": "package huma\n\n// Middlewares is a list of middleware functions that can be attached to an\n// API and will be called for all incoming requests.\ntype Middlewares []func(ctx Context, next func(Context))\n\n// Handler builds and returns a handler func from the chain of middlewares,\n// with `endpoint func` as the final handler.\nfunc (m Middlewares) Handler(endpoint func(Context)) func(Context) {\n\treturn m.chain(endpoint)\n}\n\n// wrap user middleware func with the next func to one func\nfunc wrap(fn func(Context, func(Context)), next func(Context)) func(Context) {\n\treturn func(ctx Context) {\n\t\tfn(ctx, next)\n\t}\n}\n\n// chain builds a Middleware composed of an inline middleware stack and endpoint\n// handler in the order they are passed.\nfunc (m Middlewares) chain(endpoint func(Context)) func(Context) {\n\t// Return ahead of time if there aren't any middlewares for the chain\n\tif len(m) == 0 {\n\t\treturn endpoint\n\t}\n\n\t// Wrap the end handler with the middleware chain\n\tw := wrap(m[len(m)-1], endpoint)\n\tfor i := len(m) - 2; i >= 0; i-- {\n\t\tw = wrap(m[i], w)\n\t}\n\treturn w\n}\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.060546875,
          "content": "ignore:\n  - benchmark\n  - examples\n  - adapters\n  - cookie.go\n"
        },
        {
          "name": "conditional",
          "type": "tree",
          "content": null
        },
        {
          "name": "cookie.go",
          "type": "blob",
          "size": 3.671875,
          "content": "package huma\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"strings\"\n)\n\n// ReadCookie reads a single cookie from the request headers by name. If\n// multiple cookies with the same name exist, the first is returned.\nfunc ReadCookie(ctx Context, name string) (*http.Cookie, error) {\n\theaders := []string{}\n\tctx.EachHeader(func(name, value string) {\n\t\tif strings.EqualFold(name, \"cookie\") {\n\t\t\theaders = append(headers, value)\n\t\t}\n\t})\n\tfor _, c := range readCookies(headers, name) {\n\t\treturn c, nil\n\t}\n\treturn nil, fmt.Errorf(\"%w: %s\", http.ErrNoCookie, name)\n}\n\n// ReadCookies reads all cookies from the request headers.\nfunc ReadCookies(ctx Context) []*http.Cookie {\n\theaders := []string{}\n\tctx.EachHeader(func(name, value string) {\n\t\tif strings.EqualFold(name, \"cookie\") {\n\t\t\theaders = append(headers, value)\n\t\t}\n\t})\n\treturn readCookies(headers, \"\")\n}\n\n// Everything below this line is copied from the Go standard library. None of\n// it is exported, so we have to copy it here to use it. üò≠\n\nvar isTokenTable = [127]bool{\n\t'!':  true,\n\t'#':  true,\n\t'$':  true,\n\t'%':  true,\n\t'&':  true,\n\t'\\'': true,\n\t'*':  true,\n\t'+':  true,\n\t'-':  true,\n\t'.':  true,\n\t'0':  true,\n\t'1':  true,\n\t'2':  true,\n\t'3':  true,\n\t'4':  true,\n\t'5':  true,\n\t'6':  true,\n\t'7':  true,\n\t'8':  true,\n\t'9':  true,\n\t'A':  true,\n\t'B':  true,\n\t'C':  true,\n\t'D':  true,\n\t'E':  true,\n\t'F':  true,\n\t'G':  true,\n\t'H':  true,\n\t'I':  true,\n\t'J':  true,\n\t'K':  true,\n\t'L':  true,\n\t'M':  true,\n\t'N':  true,\n\t'O':  true,\n\t'P':  true,\n\t'Q':  true,\n\t'R':  true,\n\t'S':  true,\n\t'T':  true,\n\t'U':  true,\n\t'W':  true,\n\t'V':  true,\n\t'X':  true,\n\t'Y':  true,\n\t'Z':  true,\n\t'^':  true,\n\t'_':  true,\n\t'`':  true,\n\t'a':  true,\n\t'b':  true,\n\t'c':  true,\n\t'd':  true,\n\t'e':  true,\n\t'f':  true,\n\t'g':  true,\n\t'h':  true,\n\t'i':  true,\n\t'j':  true,\n\t'k':  true,\n\t'l':  true,\n\t'm':  true,\n\t'n':  true,\n\t'o':  true,\n\t'p':  true,\n\t'q':  true,\n\t'r':  true,\n\t's':  true,\n\t't':  true,\n\t'u':  true,\n\t'v':  true,\n\t'w':  true,\n\t'x':  true,\n\t'y':  true,\n\t'z':  true,\n\t'|':  true,\n\t'~':  true,\n}\n\nfunc isTokenRune(r rune) bool {\n\ti := int(r)\n\treturn i < len(isTokenTable) && isTokenTable[i]\n}\n\nfunc isNotToken(r rune) bool {\n\treturn !isTokenRune(r)\n}\n\n// readCookies parses all \"Cookie\" values from the header h and\n// returns the successfully parsed Cookies.\n//\n// if filter isn't empty, only cookies of that name are returned.\nfunc readCookies(lines []string, filter string) []*http.Cookie {\n\t// lines := h[\"Cookie\"]\n\tif len(lines) == 0 {\n\t\treturn []*http.Cookie{}\n\t}\n\n\tcookies := make([]*http.Cookie, 0, len(lines)+strings.Count(lines[0], \";\"))\n\tfor _, line := range lines {\n\t\tline = textproto.TrimString(line)\n\n\t\tvar part string\n\t\tfor len(line) > 0 { // continue since we have rest\n\t\t\tpart, line, _ = strings.Cut(line, \";\")\n\t\t\tpart = textproto.TrimString(part)\n\t\t\tif part == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tname, val, _ := strings.Cut(part, \"=\")\n\t\t\tname = textproto.TrimString(name)\n\t\t\tif !isCookieNameValid(name) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif filter != \"\" && filter != name {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval, ok := parseCookieValue(val, true)\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcookies = append(cookies, &http.Cookie{Name: name, Value: val})\n\t\t}\n\t}\n\treturn cookies\n}\n\nfunc validCookieValueByte(b byte) bool {\n\treturn 0x20 <= b && b < 0x7f && b != '\"' && b != ';' && b != '\\\\'\n}\n\nfunc parseCookieValue(raw string, allowDoubleQuote bool) (string, bool) {\n\t// Strip the quotes, if present.\n\tif allowDoubleQuote && len(raw) > 1 && raw[0] == '\"' && raw[len(raw)-1] == '\"' {\n\t\traw = raw[1 : len(raw)-1]\n\t}\n\tfor i := 0; i < len(raw); i++ {\n\t\tif !validCookieValueByte(raw[i]) {\n\t\t\treturn \"\", false\n\t\t}\n\t}\n\treturn raw, true\n}\n\nfunc isCookieNameValid(raw string) bool {\n\tif raw == \"\" {\n\t\treturn false\n\t}\n\treturn strings.IndexFunc(raw, isNotToken) < 0\n}\n"
        },
        {
          "name": "defaults.go",
          "type": "blob",
          "size": 2.9677734375,
          "content": "package huma\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\n// DefaultJSONFormat is the default JSON formatter that can be set in the API's\n// `Config.Formats` map. This is used by the `DefaultConfig` function.\n//\n//\tconfig := huma.Config{}\n//\tconfig.Formats = map[string]huma.Format{\n//\t\t\"application/json\": huma.DefaultJSONFormat,\n//\t\t\"json\":             huma.DefaultJSONFormat,\n//\t}\nvar DefaultJSONFormat = Format{\n\tMarshal: func(w io.Writer, v any) error {\n\t\treturn json.NewEncoder(w).Encode(v)\n\t},\n\tUnmarshal: json.Unmarshal,\n}\n\n// DefaultFormats is a map of default formats that can be set in the API's\n// `Config.Formats` map, used for content negotiation for marshaling and\n// unmarshaling request/response bodies. This is used by the `DefaultConfig`\n// function and can be modified to add or remove additional formats. For\n// example, to add support for CBOR, simply import it:\n//\n//\timport _ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\nvar DefaultFormats = map[string]Format{\n\t\"application/json\": DefaultJSONFormat,\n\t\"json\":             DefaultJSONFormat,\n}\n\n// DefaultConfig returns a default configuration for a new API. It is a good\n// starting point for creating your own configuration. It supports the JSON\n// format out of the box. The registry uses references for structs and a link\n// transformer is included to add `$schema` fields and links into responses. The\n// `/openapi.[json|yaml]`, `/docs`, and `/schemas` paths are set up to serve the\n// OpenAPI spec, docs UI, and schemas respectively.\n//\n//\t// Create and customize the config (if desired).\n//\tconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\n//\n//\t// Create the API using the config.\n//\trouter := chi.NewMux()\n//\tapi := humachi.New(router, config)\n//\n// If desired, CBOR (a binary format similar to JSON) support can be\n// automatically enabled by importing the CBOR package:\n//\n//\timport _ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\nfunc DefaultConfig(title, version string) Config {\n\tschemaPrefix := \"#/components/schemas/\"\n\tschemasPath := \"/schemas\"\n\n\tregistry := NewMapRegistry(schemaPrefix, DefaultSchemaNamer)\n\n\treturn Config{\n\t\tOpenAPI: &OpenAPI{\n\t\t\tOpenAPI: \"3.1.0\",\n\t\t\tInfo: &Info{\n\t\t\t\tTitle:   title,\n\t\t\t\tVersion: version,\n\t\t\t},\n\t\t\tComponents: &Components{\n\t\t\t\tSchemas: registry,\n\t\t\t},\n\t\t},\n\t\tOpenAPIPath:   \"/openapi\",\n\t\tDocsPath:      \"/docs\",\n\t\tSchemasPath:   schemasPath,\n\t\tFormats:       DefaultFormats,\n\t\tDefaultFormat: \"application/json\",\n\t\tCreateHooks: []func(Config) Config{\n\t\t\tfunc(c Config) Config {\n\t\t\t\t// Add a link transformer to the API. This adds `Link` headers and\n\t\t\t\t// puts `$schema` fields in the response body which point to the JSON\n\t\t\t\t// Schema that describes the response structure.\n\t\t\t\t// This is a create hook so we get the latest schema path setting.\n\t\t\t\tlinkTransformer := NewSchemaLinkTransformer(schemaPrefix, c.SchemasPath)\n\t\t\t\tc.OpenAPI.OnAddOperation = append(c.OpenAPI.OnAddOperation, linkTransformer.OnAddOperation)\n\t\t\t\tc.Transformers = append(c.Transformers, linkTransformer.Transform)\n\t\t\t\treturn c\n\t\t\t},\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 12.228515625,
          "content": "package huma\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\n// ErrorDetailer returns error details for responses & debugging. This enables\n// the use of custom error types. See `NewError` for more details.\ntype ErrorDetailer interface {\n\tErrorDetail() *ErrorDetail\n}\n\n// ErrorDetail provides details about a specific error.\ntype ErrorDetail struct {\n\t// Message is a human-readable explanation of the error.\n\tMessage string `json:\"message,omitempty\" doc:\"Error message text\"`\n\n\t// Location is a path-like string indicating where the error occurred.\n\t// It typically begins with `path`, `query`, `header`, or `body`. Example:\n\t// `body.items[3].tags` or `path.thing-id`.\n\tLocation string `json:\"location,omitempty\" doc:\"Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id'\"`\n\n\t// Value is the value at the given location, echoed back to the client\n\t// to help with debugging. This can be useful for e.g. validating that\n\t// the client didn't send extra whitespace or help when the client\n\t// did not log an outgoing request.\n\tValue any `json:\"value,omitempty\" doc:\"The value at the given location\"`\n}\n\n// Error returns the error message / satisfies the `error` interface. If a\n// location and value are set, they will be included in the error message,\n// otherwise just the message is returned.\nfunc (e *ErrorDetail) Error() string {\n\tif e.Location == \"\" && e.Value == nil {\n\t\treturn e.Message\n\t}\n\treturn fmt.Sprintf(\"%s (%s: %v)\", e.Message, e.Location, e.Value)\n}\n\n// ErrorDetail satisfies the `ErrorDetailer` interface.\nfunc (e *ErrorDetail) ErrorDetail() *ErrorDetail {\n\treturn e\n}\n\n// ErrorModel defines a basic error message model based on RFC 9457 Problem\n// Details for HTTP APIs (https://datatracker.ietf.org/doc/html/rfc9457). It\n// is augmented with an `errors` field of `huma.ErrorDetail` objects that\n// can help provide exhaustive & descriptive errors.\n//\n//\terr := &huma.ErrorModel{\n//\t\tTitle: http.StatusText(http.StatusBadRequest),\n//\t\tStatus http.StatusBadRequest,\n//\t\tDetail: \"Validation failed\",\n//\t\tErrors: []*huma.ErrorDetail{\n//\t\t\t&huma.ErrorDetail{\n//\t\t\t\tMessage: \"expected required property id to be present\",\n//\t\t\t\tLocation: \"body.friends[0]\",\n//\t\t\t\tValue: nil,\n//\t\t\t},\n//\t\t\t&huma.ErrorDetail{\n//\t\t\t\tMessage: \"expected boolean\",\n//\t\t\t\tLocation: \"body.friends[1].active\",\n//\t\t\t\tValue: 5,\n//\t\t\t},\n//\t\t},\n//\t}\ntype ErrorModel struct {\n\t// Type is a URI to get more information about the error type.\n\tType string `json:\"type,omitempty\" format:\"uri\" default:\"about:blank\" example:\"https://example.com/errors/example\" doc:\"A URI reference to human-readable documentation for the error.\"`\n\n\t// Title provides a short static summary of the problem. Huma will default this\n\t// to the HTTP response status code text if not present.\n\tTitle string `json:\"title,omitempty\" example:\"Bad Request\" doc:\"A short, human-readable summary of the problem type. This value should not change between occurrences of the error.\"`\n\n\t// Status provides the HTTP status code for client convenience. Huma will\n\t// default this to the response status code if unset. This SHOULD match the\n\t// response status code (though proxies may modify the actual status code).\n\tStatus int `json:\"status,omitempty\" example:\"400\" doc:\"HTTP status code\"`\n\n\t// Detail is an explanation specific to this error occurrence.\n\tDetail string `json:\"detail,omitempty\" example:\"Property foo is required but is missing.\" doc:\"A human-readable explanation specific to this occurrence of the problem.\"`\n\n\t// Instance is a URI to get more info about this error occurrence.\n\tInstance string `json:\"instance,omitempty\" format:\"uri\" example:\"https://example.com/error-log/abc123\" doc:\"A URI reference that identifies the specific occurrence of the problem.\"`\n\n\t// Errors provides an optional mechanism of passing additional error details\n\t// as a list.\n\tErrors []*ErrorDetail `json:\"errors,omitempty\" doc:\"Optional list of individual error details\"`\n}\n\n// Error satisfies the `error` interface. It returns the error's detail field.\nfunc (e *ErrorModel) Error() string {\n\treturn e.Detail\n}\n\n// Add an error to the `Errors` slice. If passed a struct that satisfies the\n// `huma.ErrorDetailer` interface, then it is used, otherwise the error\n// string is used as the error detail message.\n//\n//\terr := &ErrorModel{ /* ... */ }\n//\terr.Add(&huma.ErrorDetail{\n//\t\tMessage: \"expected boolean\",\n//\t\tLocation: \"body.friends[1].active\",\n//\t\tValue: 5\n//\t})\nfunc (e *ErrorModel) Add(err error) {\n\tif converted, ok := err.(ErrorDetailer); ok {\n\t\te.Errors = append(e.Errors, converted.ErrorDetail())\n\t\treturn\n\t}\n\n\te.Errors = append(e.Errors, &ErrorDetail{Message: err.Error()})\n}\n\n// GetStatus returns the HTTP status that should be returned to the client\n// for this error.\nfunc (e *ErrorModel) GetStatus() int {\n\treturn e.Status\n}\n\n// ContentType provides a filter to adjust response content types. This is\n// used to ensure e.g. `application/problem+json` content types defined in\n// RFC 9457 Problem Details for HTTP APIs are used in responses to clients.\nfunc (e *ErrorModel) ContentType(ct string) string {\n\tif ct == \"application/json\" {\n\t\treturn \"application/problem+json\"\n\t}\n\tif ct == \"application/cbor\" {\n\t\treturn \"application/problem+cbor\"\n\t}\n\treturn ct\n}\n\n// ContentTypeFilter allows you to override the content type for responses,\n// allowing you to return a different content type like\n// `application/problem+json` after using the `application/json` marshaller.\n// This should be implemented by the response body struct.\ntype ContentTypeFilter interface {\n\tContentType(string) string\n}\n\n// StatusError is an error that has an HTTP status code. When returned from\n// an operation handler, this sets the response status code before sending it\n// to the client.\ntype StatusError interface {\n\tGetStatus() int\n\tError() string\n}\n\n// HeadersError is an error that has HTTP headers. When returned from an\n// operation handler, these headers are set on the response before sending it\n// to the client. Use `ErrorWithHeaders` to wrap an error like\n// `huma.Error400BadRequest` with additional headers.\ntype HeadersError interface {\n\tGetHeaders() http.Header\n\tError() string\n}\n\ntype errWithHeaders struct {\n\terr     error\n\theaders http.Header\n}\n\nfunc (e *errWithHeaders) Error() string {\n\treturn e.err.Error()\n}\n\nfunc (e *errWithHeaders) Unwrap() error {\n\treturn e.err\n}\n\nfunc (e *errWithHeaders) GetHeaders() http.Header {\n\treturn e.headers\n}\n\n// ErrorWithHeaders wraps an error with additional headers to be sent to the\n// client. This is useful for e.g. caching, rate limiting, or other metadata.\nfunc ErrorWithHeaders(err error, headers http.Header) error {\n\tvar he HeadersError\n\tif errors.As(err, &he) {\n\t\t// There is already a headers error, so we need to merge the headers. This\n\t\t// lets you chain multiple calls together and have all the headers set.\n\t\torig := he.GetHeaders()\n\t\tfor k, values := range headers {\n\t\t\tfor _, v := range values {\n\t\t\t\torig.Add(k, v)\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\treturn &errWithHeaders{err: err, headers: headers}\n}\n\n// NewError creates a new instance of an error model with the given status code,\n// message, and optional error details. If the error details implement the\n// `ErrorDetailer` interface, the error details will be used. Otherwise, the\n// error string will be used as the message. This function is used by all the\n// error response utility functions, like `huma.Error400BadRequest`.\n//\n// Replace this function to use your own error type. Example:\n//\n//\ttype MyDetail struct {\n//\t\tMessage string\t`json:\"message\"`\n//\t\tLocation string\t`json:\"location\"`\n//\t}\n//\n//\ttype MyError struct {\n//\t\tstatus  int\n//\t\tMessage string\t`json:\"message\"`\n//\t\tErrors  []error\t`json:\"errors\"`\n//\t}\n//\n//\tfunc (e *MyError) Error() string {\n//\t\treturn e.Message\n//\t}\n//\n//\tfunc (e *MyError) GetStatus() int {\n//\t\treturn e.status\n//\t}\n//\n//\thuma.NewError = func(status int, msg string, errs ...error) StatusError {\n//\t\treturn &MyError{\n//\t\t\tstatus:  status,\n//\t\t\tMessage: msg,\n//\t\t\tErrors:  errs,\n//\t\t}\n//\t}\nvar NewError = func(status int, msg string, errs ...error) StatusError {\n\tdetails := make([]*ErrorDetail, len(errs))\n\tfor i := 0; i < len(errs); i++ {\n\t\tif converted, ok := errs[i].(ErrorDetailer); ok {\n\t\t\tdetails[i] = converted.ErrorDetail()\n\t\t} else {\n\t\t\tif errs[i] == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdetails[i] = &ErrorDetail{Message: errs[i].Error()}\n\t\t}\n\t}\n\treturn &ErrorModel{\n\t\tStatus: status,\n\t\tTitle:  http.StatusText(status),\n\t\tDetail: msg,\n\t\tErrors: details,\n\t}\n}\n\nvar NewErrorWithContext = func(_ Context, status int, msg string, errs ...error) StatusError {\n\treturn NewError(status, msg, errs...)\n}\n\n// WriteErr writes an error response with the given context, using the\n// configured error type and with the given status code and message. It is\n// marshaled using the API's content negotiation methods.\nfunc WriteErr(api API, ctx Context, status int, msg string, errs ...error) error {\n\tvar err = NewErrorWithContext(ctx, status, msg, errs...)\n\n\t// NewError may have modified the status code, so update it here if needed.\n\t// If it was not modified then this is a no-op.\n\tstatus = err.GetStatus()\n\n\twriteErr := writeResponse(api, ctx, status, \"\", err)\n\tif writeErr != nil {\n\t\t// If we can't write the error, log it so we know what happened.\n\t\tfmt.Fprintf(os.Stderr, \"could not write error: %v\\n\", writeErr)\n\t}\n\treturn writeErr\n}\n\n// Status304NotModified returns a 304. This is not really an error, but\n// provides a way to send non-default responses.\nfunc Status304NotModified() StatusError {\n\treturn NewError(http.StatusNotModified, \"\")\n}\n\n// Error400BadRequest returns a 400.\nfunc Error400BadRequest(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusBadRequest, msg, errs...)\n}\n\n// Error401Unauthorized returns a 401.\nfunc Error401Unauthorized(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusUnauthorized, msg, errs...)\n}\n\n// Error403Forbidden returns a 403.\nfunc Error403Forbidden(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusForbidden, msg, errs...)\n}\n\n// Error404NotFound returns a 404.\nfunc Error404NotFound(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusNotFound, msg, errs...)\n}\n\n// Error405MethodNotAllowed returns a 405.\nfunc Error405MethodNotAllowed(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusMethodNotAllowed, msg, errs...)\n}\n\n// Error406NotAcceptable returns a 406.\nfunc Error406NotAcceptable(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusNotAcceptable, msg, errs...)\n}\n\n// Error409Conflict returns a 409.\nfunc Error409Conflict(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusConflict, msg, errs...)\n}\n\n// Error410Gone returns a 410.\nfunc Error410Gone(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusGone, msg, errs...)\n}\n\n// Error412PreconditionFailed returns a 412.\nfunc Error412PreconditionFailed(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusPreconditionFailed, msg, errs...)\n}\n\n// Error415UnsupportedMediaType returns a 415.\nfunc Error415UnsupportedMediaType(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusUnsupportedMediaType, msg, errs...)\n}\n\n// Error422UnprocessableEntity returns a 422.\nfunc Error422UnprocessableEntity(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusUnprocessableEntity, msg, errs...)\n}\n\n// Error429TooManyRequests returns a 429.\nfunc Error429TooManyRequests(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusTooManyRequests, msg, errs...)\n}\n\n// Error500InternalServerError returns a 500.\nfunc Error500InternalServerError(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusInternalServerError, msg, errs...)\n}\n\n// Error501NotImplemented returns a 501.\nfunc Error501NotImplemented(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusNotImplemented, msg, errs...)\n}\n\n// Error502BadGateway returns a 502.\nfunc Error502BadGateway(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusBadGateway, msg, errs...)\n}\n\n// Error503ServiceUnavailable returns a 503.\nfunc Error503ServiceUnavailable(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusServiceUnavailable, msg, errs...)\n}\n\n// Error504GatewayTimeout returns a 504.\nfunc Error504GatewayTimeout(msg string, errs ...error) StatusError {\n\treturn NewError(http.StatusGatewayTimeout, msg, errs...)\n}\n\n// ErrorFormatter is a function that formats an error message\nvar ErrorFormatter = fmt.Sprintf\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 3.9189453125,
          "content": "package huma_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\n// Ensure the default error models satisfy these interfaces.\nvar _ huma.StatusError = (*huma.ErrorModel)(nil)\nvar _ huma.ContentTypeFilter = (*huma.ErrorModel)(nil)\nvar _ huma.ErrorDetailer = (*huma.ErrorDetail)(nil)\n\nfunc TestError(t *testing.T) {\n\terr := &huma.ErrorModel{\n\t\tStatus: 400,\n\t\tDetail: \"test err\",\n\t}\n\n\t// Add some children.\n\terr.Add(&huma.ErrorDetail{\n\t\tMessage:  \"test detail\",\n\t\tLocation: \"body.foo\",\n\t\tValue:    \"bar\",\n\t})\n\n\terr.Add(errors.New(\"plain error\"))\n\n\t// Confirm errors were added.\n\tassert.Equal(t, \"test err\", err.Error())\n\tassert.Len(t, err.Errors, 2)\n\tassert.Equal(t, \"test detail (body.foo: bar)\", err.Errors[0].Error())\n\tassert.Equal(t, \"plain error\", err.Errors[1].Error())\n\n\t// Ensure problem content types.\n\tassert.Equal(t, \"application/problem+json\", err.ContentType(\"application/json\"))\n\tassert.Equal(t, \"application/problem+cbor\", err.ContentType(\"application/cbor\"))\n\tassert.Equal(t, \"other\", err.ContentType(\"other\"))\n}\n\nfunc TestErrorResponses(t *testing.T) {\n\t// NotModified has a slightly different signature.\n\tassert.Equal(t, 304, huma.Status304NotModified().GetStatus())\n\n\tfor _, item := range []struct {\n\t\tconstructor func(msg string, errs ...error) huma.StatusError\n\t\texpected    int\n\t}{\n\t\t{huma.Error400BadRequest, 400},\n\t\t{huma.Error401Unauthorized, 401},\n\t\t{huma.Error403Forbidden, 403},\n\t\t{huma.Error404NotFound, 404},\n\t\t{huma.Error405MethodNotAllowed, 405},\n\t\t{huma.Error406NotAcceptable, 406},\n\t\t{huma.Error409Conflict, 409},\n\t\t{huma.Error410Gone, 410},\n\t\t{huma.Error412PreconditionFailed, 412},\n\t\t{huma.Error415UnsupportedMediaType, 415},\n\t\t{huma.Error422UnprocessableEntity, 422},\n\t\t{huma.Error429TooManyRequests, 429},\n\t\t{huma.Error500InternalServerError, 500},\n\t\t{huma.Error501NotImplemented, 501},\n\t\t{huma.Error502BadGateway, 502},\n\t\t{huma.Error503ServiceUnavailable, 503},\n\t\t{huma.Error504GatewayTimeout, 504},\n\t} {\n\t\terr := item.constructor(\"test\")\n\t\tassert.Equal(t, item.expected, err.GetStatus())\n\t}\n}\n\nfunc TestNegotiateError(t *testing.T) {\n\t_, api := humatest.New(t, huma.Config{OpenAPI: &huma.OpenAPI{Info: &huma.Info{Title: \"Test API\", Version: \"1.0.0\"}}})\n\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tresp := httptest.NewRecorder()\n\tctx := humatest.NewContext(&huma.Operation{}, req, resp)\n\trequire.Error(t, huma.WriteErr(api, ctx, 400, \"bad request\"))\n}\n\nfunc TestTransformError(t *testing.T) {\n\tconfig := huma.DefaultConfig(\"Test API\", \"1.0.0\")\n\tconfig.Transformers = []huma.Transformer{\n\t\tfunc(ctx huma.Context, status string, v any) (any, error) {\n\t\t\treturn nil, errors.New(\"whoops\")\n\t\t},\n\t}\n\t_, api := humatest.New(t, config)\n\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tresp := httptest.NewRecorder()\n\tctx := humatest.NewContext(&huma.Operation{}, req, resp)\n\n\trequire.Error(t, huma.WriteErr(api, ctx, 400, \"bad request\"))\n}\n\nfunc TestErrorAs(t *testing.T) {\n\terr := fmt.Errorf(\"wrapped: %w\", huma.Error400BadRequest(\"test\"))\n\n\tvar e huma.StatusError\n\trequire.ErrorAs(t, err, &e)\n\tassert.Equal(t, 400, e.GetStatus())\n}\n\nfunc TestErrorWithHeaders(t *testing.T) {\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Get(api, \"/test\", func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\terr := huma.ErrorWithHeaders(\n\t\t\thuma.Error400BadRequest(\"test\"),\n\t\t\thttp.Header{\n\t\t\t\t\"My-Header\": {\"bar\"},\n\t\t\t},\n\t\t)\n\n\t\tassert.Equal(t, \"test\", err.Error())\n\n\t\t// Call again and have all the headers merged\n\t\terr = huma.ErrorWithHeaders(err, http.Header{\n\t\t\t\"Another\": {\"bar\"},\n\t\t})\n\n\t\treturn nil, fmt.Errorf(\"wrapped: %w\", err)\n\t})\n\n\tresp := api.Get(\"/test\")\n\tassert.Equal(t, 400, resp.Code)\n\tassert.Equal(t, \"bar\", resp.Header().Get(\"My-Header\"))\n\tassert.Equal(t, \"bar\", resp.Header().Get(\"Another\"))\n\tassert.Contains(t, resp.Body.String(), \"test\")\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "formats",
          "type": "tree",
          "content": null
        },
        {
          "name": "formdata.go",
          "type": "blob",
          "size": 6.70703125,
          "content": "package huma\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strings\"\n)\n\ntype FormFile struct {\n\tmultipart.File\n\tContentType string // Content-Type as declared in the multipart form field, or detected when parsing request as fallback\n\tIsSet       bool   // Indicates whether content was received when working with optional files\n\tSize        int64  // File size in bytes\n\tFilename    string // Filename as declared in the multipart form field, if any\n}\n\ntype MultipartFormFiles[T any] struct {\n\tForm *multipart.Form\n\tdata *T\n}\n\ntype MimeTypeValidator struct {\n\taccept []string\n}\n\nfunc NewMimeTypeValidator(encoding *Encoding) MimeTypeValidator {\n\tvar mimeTypes = strings.Split(encoding.ContentType, \",\")\n\tfor i := range mimeTypes {\n\t\tmimeTypes[i] = strings.Trim(mimeTypes[i], \" \")\n\t}\n\tif len(mimeTypes) == 0 {\n\t\tmimeTypes = []string{\"application/octet-stream\"}\n\t}\n\treturn MimeTypeValidator{accept: mimeTypes}\n}\n\n// Validate checks the mime type of the provided file against the expected content type.\n// In the absence of a Content-Type file header, the mime type is detected using [http.DetectContentType].\nfunc (v MimeTypeValidator) Validate(fh *multipart.FileHeader, location string) (string, *ErrorDetail) {\n\tfile, err := fh.Open()\n\tif err != nil {\n\t\treturn \"\", &ErrorDetail{Message: \"Failed to open file\", Location: location}\n\t}\n\n\tmimeType := fh.Header.Get(\"Content-Type\")\n\tif mimeType == \"\" {\n\t\tvar buffer = make([]byte, 1000)\n\t\tif _, err := file.Read(buffer); err != nil {\n\t\t\treturn \"\", &ErrorDetail{Message: \"Failed to infer file media type\", Location: location}\n\t\t}\n\t\tfile.Seek(int64(0), io.SeekStart)\n\t\tmimeType = http.DetectContentType(buffer)\n\t}\n\taccept := false\n\tfor _, m := range v.accept {\n\t\tif m == \"text/plain\" || m == \"application/octet-stream\" {\n\t\t\taccept = true\n\t\t\tbreak\n\t\t}\n\t\tif strings.HasSuffix(m, \"/*\") &&\n\t\t\tstrings.HasPrefix(mimeType, strings.TrimRight(m, \"*\")) {\n\t\t\taccept = true\n\t\t\tbreak\n\t\t}\n\t\tif mimeType == m {\n\t\t\taccept = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif accept {\n\t\treturn mimeType, nil\n\t} else {\n\t\treturn mimeType, &ErrorDetail{\n\t\t\tMessage: fmt.Sprintf(\n\t\t\t\t\"Invalid mime type: got %v, expected %v\",\n\t\t\t\tmimeType, strings.Join(v.accept, \",\"),\n\t\t\t),\n\t\t\tLocation: location,\n\t\t\tValue:    mimeType,\n\t\t}\n\t}\n}\n\nfunc (m *MultipartFormFiles[T]) readFile(\n\tfh *multipart.FileHeader,\n\tlocation string,\n\tvalidator MimeTypeValidator,\n) (FormFile, *ErrorDetail) {\n\tf, err := fh.Open()\n\tif err != nil {\n\t\treturn FormFile{}, &ErrorDetail{Message: \"Failed to open file\", Location: location}\n\t}\n\tcontentType, validationErr := validator.Validate(fh, location)\n\tif validationErr != nil {\n\t\treturn FormFile{}, validationErr\n\t}\n\treturn FormFile{\n\t\tFile:        f,\n\t\tContentType: contentType,\n\t\tIsSet:       true,\n\t\tSize:        fh.Size,\n\t\tFilename:    fh.Filename,\n\t}, nil\n}\n\nfunc (m *MultipartFormFiles[T]) readSingleFile(key string, opMediaType *MediaType) (FormFile, *ErrorDetail) {\n\tfileHeaders := m.Form.File[key]\n\tif len(fileHeaders) == 0 {\n\t\tif opMediaType.Schema.requiredMap[key] {\n\t\t\treturn FormFile{}, &ErrorDetail{Message: \"File required\", Location: key}\n\t\t} else {\n\t\t\treturn FormFile{}, nil\n\t\t}\n\t} else if len(fileHeaders) == 1 {\n\t\tvalidator := NewMimeTypeValidator(opMediaType.Encoding[key])\n\t\treturn m.readFile(fileHeaders[0], key, validator)\n\t}\n\treturn FormFile{}, &ErrorDetail{\n\t\tMessage:  \"Multiple files received but only one was expected\",\n\t\tLocation: key,\n\t}\n}\n\nfunc (m *MultipartFormFiles[T]) readMultipleFiles(key string, opMediaType *MediaType) ([]FormFile, []error) {\n\tfileHeaders := m.Form.File[key]\n\tvar (\n\t\tfiles  = make([]FormFile, len(fileHeaders))\n\t\terrors []error\n\t)\n\tif opMediaType.Schema.requiredMap[key] && len(fileHeaders) == 0 {\n\t\treturn nil, []error{&ErrorDetail{Message: \"At least one file is required\", Location: key}}\n\t}\n\tvalidator := NewMimeTypeValidator(opMediaType.Encoding[key])\n\tfor i, fh := range fileHeaders {\n\t\tfile, err := m.readFile(\n\t\t\tfh,\n\t\t\tfmt.Sprintf(\"%s[%d]\", key, i),\n\t\t\tvalidator,\n\t\t)\n\t\tif err != nil {\n\t\t\terrors = append(errors, err)\n\t\t\tcontinue\n\t\t}\n\t\tfiles[i] = file\n\t}\n\treturn files, errors\n}\n\nfunc (m *MultipartFormFiles[T]) Data() *T {\n\treturn m.data\n}\n\n// Decodes multipart.Form data into *T, returning []*ErrorDetail if any\n// Schema is used to check for validation constraints\nfunc (m *MultipartFormFiles[T]) Decode(opMediaType *MediaType) []error {\n\tvar (\n\t\tdataType = reflect.TypeOf(m.data).Elem()\n\t\tvalue    = reflect.New(dataType)\n\t\terrors   []error\n\t)\n\tfor i := 0; i < dataType.NumField(); i++ {\n\t\tfield := value.Elem().Field(i)\n\t\tstructField := dataType.Field(i)\n\t\tkey := structField.Tag.Get(\"form\")\n\t\tif key == \"\" {\n\t\t\tkey = structField.Name\n\t\t}\n\t\tswitch {\n\t\tcase field.Type() == reflect.TypeOf(FormFile{}):\n\t\t\tfile, err := m.readSingleFile(key, opMediaType)\n\t\t\tif err != nil {\n\t\t\t\terrors = append(errors, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfield.Set(reflect.ValueOf(file))\n\t\tcase field.Type() == reflect.TypeOf([]FormFile{}):\n\t\t\tfiles, errs := m.readMultipleFiles(key, opMediaType)\n\t\t\tif errs != nil {\n\t\t\t\terrors = append(errors, errs...)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfield.Set(reflect.ValueOf(files))\n\n\t\tdefault:\n\t\t\tcontinue\n\t\t}\n\t}\n\tm.data = value.Interface().(*T)\n\treturn errors\n}\n\nfunc formDataFieldName(f reflect.StructField) string {\n\tname := f.Name\n\tif formDataKey := f.Tag.Get(\"form\"); formDataKey != \"\" {\n\t\tname = formDataKey\n\t}\n\treturn name\n}\n\nfunc multiPartFormFileSchema(t reflect.Type) *Schema {\n\tnFields := t.NumField()\n\tschema := &Schema{\n\t\tType:        \"object\",\n\t\tProperties:  make(map[string]*Schema, nFields),\n\t\trequiredMap: make(map[string]bool, nFields),\n\t}\n\trequiredFields := make([]string, nFields)\n\tfor i := 0; i < nFields; i++ {\n\t\tf := t.Field(i)\n\t\tname := formDataFieldName(f)\n\n\t\tswitch {\n\t\tcase f.Type == reflect.TypeOf(FormFile{}):\n\t\t\tschema.Properties[name] = multiPartFileSchema(f)\n\t\tcase f.Type == reflect.TypeOf([]FormFile{}):\n\t\t\tschema.Properties[name] = &Schema{\n\t\t\t\tType:  \"array\",\n\t\t\t\tItems: multiPartFileSchema(f),\n\t\t\t}\n\t\tdefault:\n\t\t\t// Should we panic if [T] struct defines fields with unsupported types ?\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, ok := f.Tag.Lookup(\"required\"); ok && boolTag(f, \"required\", false) {\n\t\t\trequiredFields[i] = name\n\t\t\tschema.requiredMap[name] = true\n\t\t}\n\t}\n\tschema.Required = requiredFields\n\treturn schema\n}\n\nfunc multiPartFileSchema(f reflect.StructField) *Schema {\n\treturn &Schema{\n\t\tType:            \"string\",\n\t\tFormat:          \"binary\",\n\t\tDescription:     f.Tag.Get(\"doc\"),\n\t\tContentEncoding: \"binary\",\n\t}\n}\n\nfunc multiPartContentEncoding(t reflect.Type) map[string]*Encoding {\n\tnFields := t.NumField()\n\tencoding := make(map[string]*Encoding, nFields)\n\tfor i := 0; i < nFields; i++ {\n\t\tf := t.Field(i)\n\t\tname := formDataFieldName(f)\n\t\tcontentType := f.Tag.Get(\"contentType\")\n\t\tif contentType == \"\" {\n\t\t\tcontentType = \"application/octet-stream\"\n\t\t}\n\t\tencoding[name] = &Encoding{\n\t\t\tContentType: contentType,\n\t\t}\n\t}\n\treturn encoding\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.712890625,
          "content": "module github.com/danielgtaylor/huma/v2\n\ngo 1.22\n\ntoolchain go1.22.0\n\nrequire (\n\tgithub.com/danielgtaylor/shorthand/v2 v2.2.0\n\tgithub.com/evanphx/json-patch/v5 v5.9.0\n\tgithub.com/fxamacker/cbor/v2 v2.7.0\n\tgithub.com/gin-gonic/gin v1.10.0\n\tgithub.com/go-chi/chi/v5 v5.1.0\n\tgithub.com/gofiber/fiber/v2 v2.52.5\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/gorilla/mux v1.8.1\n\tgithub.com/julienschmidt/httprouter v1.3.0\n\tgithub.com/labstack/echo/v4 v4.12.0\n\tgithub.com/spf13/cobra v1.8.1\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/uptrace/bunrouter v1.0.22\n)\n\nrequire (\n\tgithub.com/andybalholm/brotli v1.1.0 // indirect\n\tgithub.com/bytedance/sonic v1.12.3 // indirect\n\tgithub.com/bytedance/sonic/loader v0.2.0 // indirect\n\tgithub.com/cloudwego/base64x v0.1.4 // indirect\n\tgithub.com/cloudwego/iasm v0.2.0 // indirect\n\tgithub.com/danielgtaylor/mexpr v1.9.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/gabriel-vasile/mimetype v1.4.5 // indirect\n\tgithub.com/gin-contrib/sse v0.1.0 // indirect\n\tgithub.com/go-playground/locales v0.14.1 // indirect\n\tgithub.com/go-playground/universal-translator v0.18.1 // indirect\n\tgithub.com/go-playground/validator/v10 v10.22.1 // indirect\n\tgithub.com/goccy/go-json v0.10.3 // indirect\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/klauspost/compress v1.17.10 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.8 // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/labstack/gommon v0.4.2 // indirect\n\tgithub.com/leodido/go-urn v1.4.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.16 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.2.3 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgithub.com/spf13/pflag v1.0.5 // indirect\n\tgithub.com/twitchyliquid64/golang-asm v0.15.1 // indirect\n\tgithub.com/ugorji/go/codec v1.2.12 // indirect\n\tgithub.com/valyala/bytebufferpool v1.0.0 // indirect\n\tgithub.com/valyala/fasthttp v1.56.0 // indirect\n\tgithub.com/valyala/fasttemplate v1.2.2 // indirect\n\tgithub.com/valyala/tcplisten v1.0.0 // indirect\n\tgithub.com/x448/float16 v0.8.4 // indirect\n\tgolang.org/x/arch v0.11.0 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/net v0.30.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgoogle.golang.org/protobuf v1.35.1 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 12.98046875,
          "content": "github.com/andybalholm/brotli v1.1.0 h1:eLKJA0d02Lf0mVpIDgYnqXcUn0GqVmEFny3VuID1U3M=\ngithub.com/andybalholm/brotli v1.1.0/go.mod h1:sms7XGricyQI9K10gOSf56VKKWS4oLer58Q+mhRPtnY=\ngithub.com/bytedance/sonic v1.12.3 h1:W2MGa7RCU1QTeYRTPE3+88mVC0yXmsRQRChiyVocVjU=\ngithub.com/bytedance/sonic v1.12.3/go.mod h1:B8Gt/XvtZ3Fqj+iSKMypzymZxw/FVwgIGKzMzT9r/rk=\ngithub.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/bytedance/sonic/loader v0.2.0 h1:zNprn+lsIP06C/IqCHs3gPQIvnvpKbbxyXQP1iU4kWM=\ngithub.com/bytedance/sonic/loader v0.2.0/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=\ngithub.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=\ngithub.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=\ngithub.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/danielgtaylor/mexpr v1.9.0 h1:9ZDghCLBJ88ZTUkDn/cxyK4KmAJvStCEe+ECN2EoMa4=\ngithub.com/danielgtaylor/mexpr v1.9.0/go.mod h1:kAivYNRnBeE/IJinqBvVFvLrX54xX//9zFYwADo4Bc8=\ngithub.com/danielgtaylor/shorthand/v2 v2.2.0 h1:hVsemdRq6v3JocP6YRTfu9rOoghZI9PFmkngdKqzAVQ=\ngithub.com/danielgtaylor/shorthand/v2 v2.2.0/go.mod h1:t5QfaNf7DPru9ZLIIhPQSO7Gyvajm3euw7LxB/MTUqE=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/evanphx/json-patch/v5 v5.9.0 h1:kcBlZQbplgElYIlo/n1hJbls2z/1awpXxpRi0/FOJfg=\ngithub.com/evanphx/json-patch/v5 v5.9.0/go.mod h1:VNkHZ/282BpEyt/tObQO8s5CMPmYYq14uClGH4abBuQ=\ngithub.com/fxamacker/cbor/v2 v2.7.0 h1:iM5WgngdRBanHcxugY4JySA0nk1wZorNOpTgCMedv5E=\ngithub.com/fxamacker/cbor/v2 v2.7.0/go.mod h1:pxXPTn3joSm21Gbwsv0w9OSA2y1HFR9qXEeXQVeNoDQ=\ngithub.com/gabriel-vasile/mimetype v1.4.5 h1:J7wGKdGu33ocBOhGy0z653k/lFKLFDPJMG8Gql0kxn4=\ngithub.com/gabriel-vasile/mimetype v1.4.5/go.mod h1:ibHel+/kbxn9x2407k1izTA1S81ku1z/DlgOW2QE0M4=\ngithub.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=\ngithub.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=\ngithub.com/go-chi/chi/v5 v5.1.0 h1:acVI1TYaD+hhedDJ3r54HyA6sExp3HfXq7QWEEY/xMw=\ngithub.com/go-chi/chi/v5 v5.1.0/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.22.1 h1:40JcKH+bBNGFczGuoBYgX4I6m/i27HYW8P9FDk5PbgA=\ngithub.com/go-playground/validator/v10 v10.22.1/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=\ngithub.com/goccy/go-json v0.10.3 h1:KZ5WoDbxAIgm2HNbYckL0se1fHD6rz5j4ywS6ebzDqA=\ngithub.com/goccy/go-json v0.10.3/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=\ngithub.com/gofiber/fiber/v2 v2.52.5 h1:tWoP1MJQjGEe4GB5TUGOi7P2E0ZMMRx5ZTG4rT+yGMo=\ngithub.com/gofiber/fiber/v2 v2.52.5/go.mod h1:KEOE+cXMhXG0zHc9d8+E38hoX+ZN7bhOtgeF2oT6jrQ=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=\ngithub.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=\ngithub.com/klauspost/compress v1.17.10 h1:oXAz+Vh0PMUvJczoi+flxpnBEPxoER1IaAnU/NMPtT0=\ngithub.com/klauspost/compress v1.17.10/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/klauspost/cpuid/v2 v2.2.8 h1:+StwCXwm9PdpiEkPyzBXIy+M9KUb4ODm0Zarf1kS5BM=\ngithub.com/klauspost/cpuid/v2 v2.2.8/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\ngithub.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/labstack/echo/v4 v4.12.0 h1:IKpw49IMryVB2p1a4dzwlhP1O2Tf2E0Ir/450lH+kI0=\ngithub.com/labstack/echo/v4 v4.12.0/go.mod h1:UP9Cr2DJXbOK3Kr9ONYzNowSh7HP0aG0ShAyycHSJvM=\ngithub.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=\ngithub.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=\ngithub.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=\ngithub.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=\ngithub.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=\ngithub.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=\ngithub.com/uptrace/bunrouter v1.0.22 h1:634bRGogHxjMaSqc5a3MjM/sisS/MkfXhWJ/WZXrktc=\ngithub.com/uptrace/bunrouter v1.0.22/go.mod h1:O3jAcl+5qgnF+ejhgkmbceEk0E/mqaK+ADOocdNpY8M=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasthttp v1.56.0 h1:bEZdJev/6LCBlpdORfrLu/WOZXXxvrUQSiyniuaoW8U=\ngithub.com/valyala/fasthttp v1.56.0/go.mod h1:sReBt3XZVnudxuLOx4J/fMrJVorWRiWY2koQKgABiVI=\ngithub.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=\ngithub.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=\ngithub.com/valyala/tcplisten v1.0.0 h1:rBHj/Xf+E1tRGZyWIWwJDiRY0zc1Js+CV5DqwacVSA8=\ngithub.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=\ngithub.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=\ngithub.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=\ngolang.org/x/arch v0.11.0 h1:KXV8WWKCXm6tRpLirl2szsO5j/oOODwZf4hATmGVNs4=\ngolang.org/x/arch v0.11.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.30.0 h1:AcW1SDZMkb8IpzCdQUaIq2sP4sZ4zw+55h6ynffypl4=\ngolang.org/x/net v0.30.0/go.mod h1:2wGyMJ5iFasEhkwi13ChkO/t1ECNC4X4eBKkVFyYFlU=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngoogle.golang.org/protobuf v1.35.1 h1:m3LfL6/Ca+fqnjnlqQXNpFPABW1UD7mjh8KO2mKFytA=\ngoogle.golang.org/protobuf v1.35.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nnullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=\n"
        },
        {
          "name": "huma.go",
          "type": "blob",
          "size": 51.4375,
          "content": "// Package huma provides a framework for building REST APIs in Go. It is\n// designed to be simple, fast, and easy to use. It is also designed to\n// generate OpenAPI 3.1 specifications and JSON Schema documents\n// describing the API and providing a quick & easy way to generate\n// docs, mocks, SDKs, CLI clients, and more.\n//\n// https://huma.rocks/\npackage huma\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2/casing\"\n)\n\nvar errDeadlineUnsupported = fmt.Errorf(\"%w\", http.ErrNotSupported)\n\nvar bodyCallbackType = reflect.TypeOf(func(Context) {})\nvar cookieType = reflect.TypeOf((*http.Cookie)(nil)).Elem()\nvar fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()\nvar stringType = reflect.TypeOf(\"\")\n\n// SetReadDeadline is a utility to set the read deadline on a response writer,\n// if possible. If not, it will not incur any allocations (unlike the stdlib\n// `http.ResponseController`). This is mostly a convenience function for\n// adapters so they can be more efficient.\n//\n//\thuma.SetReadDeadline(w, time.Now().Add(5*time.Second))\nfunc SetReadDeadline(w http.ResponseWriter, deadline time.Time) error {\n\tfor {\n\t\tswitch t := w.(type) {\n\t\tcase interface{ SetReadDeadline(time.Time) error }:\n\t\t\treturn t.SetReadDeadline(deadline)\n\t\tcase interface{ Unwrap() http.ResponseWriter }:\n\t\t\tw = t.Unwrap()\n\t\tdefault:\n\t\t\treturn errDeadlineUnsupported\n\t\t}\n\t}\n}\n\n// StreamResponse is a response that streams data to the client. The body\n// function will be called once the response headers have been written and\n// the body writer is ready to be written to.\n//\n//\tfunc handler(ctx context.Context, input *struct{}) (*huma.StreamResponse, error) {\n//\t\treturn &huma.StreamResponse{\n//\t\t\tBody: func(ctx huma.Context) {\n//\t\t\t\tctx.SetHeader(\"Content-Type\", \"text/my-type\")\n//\n//\t\t\t\t// Write some data to the stream.\n//\t\t\t\twriter := ctx.BodyWriter()\n//\t\t\t\twriter.Write([]byte(\"Hello \"))\n//\n//\t\t\t\t// Flush the stream to the client.\n//\t\t\t\tif f, ok := writer.(http.Flusher); ok {\n//\t\t\t\t\tf.Flush()\n//\t\t\t\t}\n//\n//\t\t\t\t// Write some more...\n//\t\t\t\twriter.Write([]byte(\"world!\"))\n//\t\t\t}\n//\t\t}\n//\t}\ntype StreamResponse struct {\n\tBody func(ctx Context)\n}\n\ntype paramFieldInfo struct {\n\tType       reflect.Type\n\tName       string\n\tLoc        string\n\tRequired   bool\n\tDefault    string\n\tTimeFormat string\n\tExplode    bool\n\tSchema     *Schema\n}\n\nfunc findParams(registry Registry, op *Operation, t reflect.Type) *findResult[*paramFieldInfo] {\n\treturn findInType(t, nil, func(f reflect.StructField, path []int) *paramFieldInfo {\n\t\tif f.Anonymous {\n\t\t\treturn nil\n\t\t}\n\n\t\tpfi := &paramFieldInfo{\n\t\t\tType: f.Type,\n\t\t}\n\n\t\tif def := f.Tag.Get(\"default\"); def != \"\" {\n\t\t\tpfi.Default = def\n\t\t}\n\n\t\tvar name string\n\t\tvar explode *bool\n\t\tif p := f.Tag.Get(\"path\"); p != \"\" {\n\t\t\tpfi.Loc = \"path\"\n\t\t\tname = p\n\t\t\tpfi.Required = true\n\t\t} else if q := f.Tag.Get(\"query\"); q != \"\" {\n\t\t\tpfi.Loc = \"query\"\n\t\t\tsplit := strings.Split(q, \",\")\n\t\t\tname = split[0]\n\t\t\t// If `in` is `query` then `explode` defaults to true. Parsing is *much*\n\t\t\t// easier if we use comma-separated values, so we disable explode by default.\n\t\t\tif slices.Contains(split[1:], \"explode\") {\n\t\t\t\tpfi.Explode = true\n\t\t\t}\n\t\t\texplode = &pfi.Explode\n\t\t} else if h := f.Tag.Get(\"header\"); h != \"\" {\n\t\t\tpfi.Loc = \"header\"\n\t\t\tname = h\n\t\t} else if c := f.Tag.Get(\"cookie\"); c != \"\" {\n\t\t\tpfi.Loc = \"cookie\"\n\t\t\tname = c\n\n\t\t\tif f.Type == cookieType {\n\t\t\t\t// Special case: this will be parsed from a string input to a\n\t\t\t\t// `http.Cookie` struct.\n\t\t\t\tf.Type = stringType\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\n\t\tif f.Type.Kind() == reflect.Pointer {\n\t\t\t// TODO: support pointers? The problem is that when we dynamically\n\t\t\t// create an instance of the input struct the `params.Every(...)`\n\t\t\t// call cannot set them as the value is `reflect.Invalid` unless\n\t\t\t// dynamically allocated, but we don't know when to allocate until\n\t\t\t// after the `Every` callback has run. Doable, but a bigger change.\n\t\t\tpanic(\"pointers are not supported for path/query/header parameters\")\n\t\t}\n\n\t\tpfi.Schema = SchemaFromField(registry, f, \"\")\n\n\t\tvar example any\n\t\tif e := f.Tag.Get(\"example\"); e != \"\" {\n\t\t\texample = jsonTagValue(registry, f.Type.Name(), pfi.Schema, f.Tag.Get(\"example\"))\n\t\t}\n\t\tif example == nil && len(pfi.Schema.Examples) > 0 {\n\t\t\texample = pfi.Schema.Examples[0]\n\t\t}\n\n\t\t// While discouraged, make it possible to make query/header params required.\n\t\tif r := f.Tag.Get(\"required\"); r == \"true\" {\n\t\t\tpfi.Required = true\n\t\t}\n\n\t\tpfi.Name = name\n\n\t\tif f.Type == timeType {\n\t\t\ttimeFormat := time.RFC3339Nano\n\t\t\tif pfi.Loc == \"header\" {\n\t\t\t\ttimeFormat = http.TimeFormat\n\t\t\t}\n\t\t\tif f := f.Tag.Get(\"timeFormat\"); f != \"\" {\n\t\t\t\ttimeFormat = f\n\t\t\t}\n\t\t\tpfi.TimeFormat = timeFormat\n\t\t}\n\n\t\tif !boolTag(f, \"hidden\", false) {\n\t\t\tdesc := \"\"\n\t\t\tif pfi.Schema != nil {\n\t\t\t\t// If the schema has a description, use it. Some tools will not show\n\t\t\t\t// the description if it is only on the schema.\n\t\t\t\tdesc = pfi.Schema.Description\n\t\t\t}\n\n\t\t\t// Document the parameter if not hidden.\n\t\t\top.Parameters = append(op.Parameters, &Param{\n\t\t\t\tName:        name,\n\t\t\t\tDescription: desc,\n\t\t\t\tIn:          pfi.Loc,\n\t\t\t\tExplode:     explode,\n\t\t\t\tRequired:    pfi.Required,\n\t\t\t\tSchema:      pfi.Schema,\n\t\t\t\tExample:     example,\n\t\t\t})\n\t\t}\n\n\t\treturn pfi\n\t}, false, \"Body\")\n}\n\nfunc findResolvers(resolverType, t reflect.Type) *findResult[bool] {\n\treturn findInType(t, func(t reflect.Type, path []int) bool {\n\t\ttp := reflect.PointerTo(t)\n\t\tif tp.Implements(resolverType) || tp.Implements(resolverWithPathType) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}, nil, true)\n}\n\nfunc findDefaults(registry Registry, t reflect.Type) *findResult[any] {\n\treturn findInType(t, nil, func(sf reflect.StructField, i []int) any {\n\t\tif d := sf.Tag.Get(\"default\"); d != \"\" {\n\t\t\tif sf.Type.Kind() == reflect.Pointer && sf.Type.Elem().Kind() == reflect.Struct {\n\t\t\t\tpanic(\"pointers to structs cannot have default values\")\n\t\t\t}\n\t\t\ts := registry.Schema(sf.Type, true, \"\")\n\t\t\treturn convertType(sf.Type.Name(), sf.Type, jsonTagValue(registry, sf.Name, s, d))\n\t\t}\n\t\treturn nil\n\t}, true)\n}\n\ntype headerInfo struct {\n\tField      reflect.StructField\n\tName       string\n\tTimeFormat string\n}\n\nfunc findHeaders(t reflect.Type) *findResult[*headerInfo] {\n\treturn findInType(t, nil, func(sf reflect.StructField, i []int) *headerInfo {\n\t\t// Ignore embedded fields\n\t\tif sf.Anonymous {\n\t\t\treturn nil\n\t\t}\n\n\t\theader := sf.Tag.Get(\"header\")\n\t\tif header == \"\" {\n\t\t\theader = sf.Name\n\t\t}\n\t\ttimeFormat := \"\"\n\t\tif sf.Type == timeType {\n\t\t\ttimeFormat = http.TimeFormat\n\t\t\tif f := sf.Tag.Get(\"timeFormat\"); f != \"\" {\n\t\t\t\ttimeFormat = f\n\t\t\t}\n\t\t}\n\t\treturn &headerInfo{sf, header, timeFormat}\n\t}, false, \"Status\", \"Body\")\n}\n\ntype findResultPath[T comparable] struct {\n\tPath  []int\n\tValue T\n}\n\ntype findResult[T comparable] struct {\n\tPaths []findResultPath[T]\n}\n\nfunc (r *findResult[T]) every(current reflect.Value, path []int, v T, f func(reflect.Value, T)) {\n\tif len(path) == 0 {\n\t\tf(current, v)\n\t\treturn\n\t}\n\n\tcurrent = reflect.Indirect(current)\n\tif current.Kind() == reflect.Invalid {\n\t\t// Indirect may have resulted in no value, for example an optional field\n\t\t// that's a pointer may have been omitted; just ignore it.\n\t\treturn\n\t}\n\n\tswitch current.Kind() {\n\tcase reflect.Struct:\n\t\tr.every(current.Field(path[0]), path[1:], v, f)\n\tcase reflect.Slice:\n\t\tfor j := 0; j < current.Len(); j++ {\n\t\t\tr.every(current.Index(j), path, v, f)\n\t\t}\n\tcase reflect.Map:\n\t\tfor _, k := range current.MapKeys() {\n\t\t\tr.every(current.MapIndex(k), path, v, f)\n\t\t}\n\tdefault:\n\t\tpanic(\"unsupported\")\n\t}\n}\n\nfunc (r *findResult[T]) Every(v reflect.Value, f func(reflect.Value, T)) {\n\tfor i := range r.Paths {\n\t\tr.every(v, r.Paths[i].Path, r.Paths[i].Value, f)\n\t}\n}\n\nfunc jsonName(field reflect.StructField) string {\n\tname := strings.ToLower(field.Name)\n\tif jsonName := field.Tag.Get(\"json\"); jsonName != \"\" {\n\t\tname = strings.Split(jsonName, \",\")[0]\n\t}\n\treturn name\n}\n\nfunc (r *findResult[T]) everyPB(current reflect.Value, path []int, pb *PathBuffer, v T, f func(reflect.Value, T)) {\n\tswitch reflect.Indirect(current).Kind() {\n\tcase reflect.Slice, reflect.Map:\n\t\t// Ignore these. We only care about the leaf nodes.\n\tdefault:\n\t\tif len(path) == 0 {\n\t\t\tf(current, v)\n\t\t\treturn\n\t\t}\n\t}\n\n\tcurrent = reflect.Indirect(current)\n\tif current.Kind() == reflect.Invalid {\n\t\t// Indirect may have resulted in no value, for example an optional field may\n\t\t// have been omitted; just ignore it.\n\t\treturn\n\t}\n\n\tswitch current.Kind() {\n\tcase reflect.Struct:\n\t\tfield := current.Type().Field(path[0])\n\t\tpops := 0\n\t\tif !field.Anonymous {\n\t\t\t// The path name can come from one of four places: path parameter,\n\t\t\t// query parameter, header parameter, or body field.\n\t\t\t// TODO: pre-compute type/field names? Could save a few allocations.\n\t\t\tpops++\n\t\t\tif path := field.Tag.Get(\"path\"); path != \"\" && pb.Len() == 0 {\n\t\t\t\tpb.Push(\"path\")\n\t\t\t\tpb.Push(path)\n\t\t\t\tpops++\n\t\t\t} else if query := field.Tag.Get(\"query\"); query != \"\" && pb.Len() == 0 {\n\t\t\t\tpb.Push(\"query\")\n\t\t\t\tpb.Push(query)\n\t\t\t\tpops++\n\t\t\t} else if header := field.Tag.Get(\"header\"); header != \"\" && pb.Len() == 0 {\n\t\t\t\tpb.Push(\"header\")\n\t\t\t\tpb.Push(header)\n\t\t\t\tpops++\n\t\t\t} else {\n\t\t\t\t// The body is _always_ in a field called \"Body\", which turns into\n\t\t\t\t// `body` in the path buffer, so we don't need to push it separately\n\t\t\t\t// like the params fields above.\n\t\t\t\tpb.Push(jsonName(field))\n\t\t\t}\n\t\t}\n\t\tr.everyPB(current.Field(path[0]), path[1:], pb, v, f)\n\t\tfor i := 0; i < pops; i++ {\n\t\t\tpb.Pop()\n\t\t}\n\tcase reflect.Slice:\n\t\tfor j := 0; j < current.Len(); j++ {\n\t\t\tpb.PushIndex(j)\n\t\t\tr.everyPB(current.Index(j), path, pb, v, f)\n\t\t\tpb.Pop()\n\t\t}\n\tcase reflect.Map:\n\t\tfor _, k := range current.MapKeys() {\n\t\t\tif k.Kind() == reflect.String {\n\t\t\t\tpb.Push(k.String())\n\t\t\t} else {\n\t\t\t\tpb.Push(fmt.Sprintf(\"%v\", k.Interface()))\n\t\t\t}\n\t\t\tr.everyPB(current.MapIndex(k), path, pb, v, f)\n\t\t\tpb.Pop()\n\t\t}\n\tdefault:\n\t\tpanic(\"unsupported\")\n\t}\n}\n\nfunc (r *findResult[T]) EveryPB(pb *PathBuffer, v reflect.Value, f func(reflect.Value, T)) {\n\tfor i := range r.Paths {\n\t\tpb.Reset()\n\t\tr.everyPB(v, r.Paths[i].Path, pb, r.Paths[i].Value, f)\n\t}\n}\n\nfunc findInType[T comparable](t reflect.Type, onType func(reflect.Type, []int) T, onField func(reflect.StructField, []int) T, recurseFields bool, ignore ...string) *findResult[T] {\n\tresult := &findResult[T]{}\n\t_findInType(t, []int{}, result, onType, onField, recurseFields, make(map[reflect.Type]struct{}), ignore...)\n\treturn result\n}\n\nfunc _findInType[T comparable](t reflect.Type, path []int, result *findResult[T], onType func(reflect.Type, []int) T, onField func(reflect.StructField, []int) T, recurseFields bool, visited map[reflect.Type]struct{}, ignore ...string) {\n\tt = deref(t)\n\tzero := reflect.Zero(reflect.TypeOf((*T)(nil)).Elem()).Interface()\n\n\tignoreAnonymous := false\n\tif onType != nil {\n\t\tif v := onType(t, path); v != zero {\n\t\t\tresult.Paths = append(result.Paths, findResultPath[T]{path, v})\n\n\t\t\t// Found what we were looking for in the type, no need to go deeper.\n\t\t\t// We do still want to potentially process each non-anonymous field,\n\t\t\t// so only skip anonymous ones.\n\t\t\tignoreAnonymous = true\n\t\t}\n\t}\n\n\tswitch t.Kind() {\n\tcase reflect.Struct:\n\t\tif _, ok := visited[t]; ok {\n\t\t\treturn\n\t\t}\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tf := t.Field(i)\n\t\t\tif !f.IsExported() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif slices.Contains(ignore, f.Name) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ignoreAnonymous && f.Anonymous {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfi := append([]int{}, path...)\n\t\t\tfi = append(fi, i)\n\t\t\tif onField != nil {\n\t\t\t\tif v := onField(f, fi); v != zero {\n\t\t\t\t\tresult.Paths = append(result.Paths, findResultPath[T]{fi, v})\n\t\t\t\t}\n\t\t\t}\n\t\t\tif f.Anonymous || recurseFields || deref(f.Type).Kind() != reflect.Struct {\n\t\t\t\t// Always process embedded structs and named fields which are not\n\t\t\t\t// structs. If `recurseFields` is true then we also process named\n\t\t\t\t// struct fields recursively.\n\t\t\t\tvisited[t] = struct{}{}\n\t\t\t\t_findInType(f.Type, fi, result, onType, onField, recurseFields, visited, ignore...)\n\t\t\t\tdelete(visited, t)\n\t\t\t}\n\t\t}\n\tcase reflect.Slice:\n\t\t_findInType(t.Elem(), path, result, onType, onField, recurseFields, visited, ignore...)\n\tcase reflect.Map:\n\t\t_findInType(t.Elem(), path, result, onType, onField, recurseFields, visited, ignore...)\n\t}\n}\n\nfunc getHint(parent reflect.Type, name string, other string) string {\n\tif parent.Name() != \"\" {\n\t\treturn parent.Name() + name\n\t} else {\n\t\treturn other\n\t}\n}\n\ntype validateDeps struct {\n\tpb  *PathBuffer\n\tres *ValidateResult\n}\n\nvar validatePool = sync.Pool{\n\tNew: func() any {\n\t\treturn &validateDeps{\n\t\t\tpb:  &PathBuffer{buf: make([]byte, 0, 128)},\n\t\t\tres: &ValidateResult{},\n\t\t}\n\t},\n}\n\nvar bufPool = sync.Pool{\n\tNew: func() any {\n\t\treturn bytes.NewBuffer(make([]byte, 0, 128))\n\t},\n}\n\nfunc writeResponse(api API, ctx Context, status int, ct string, body any) error {\n\tif ct == \"\" {\n\t\t// If no content type was provided, try to negotiate one with the client.\n\t\tvar err error\n\t\tct, err = api.Negotiate(ctx.Header(\"Accept\"))\n\t\tif err != nil {\n\t\t\tnotAccept := NewErrorWithContext(ctx, http.StatusNotAcceptable, \"unable to marshal response\", err)\n\t\t\tif e := transformAndWrite(api, ctx, http.StatusNotAcceptable, \"application/json\", notAccept); e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif ctf, ok := body.(ContentTypeFilter); ok {\n\t\t\tct = ctf.ContentType(ct)\n\t\t}\n\n\t\tctx.SetHeader(\"Content-Type\", ct)\n\t}\n\n\tif err := transformAndWrite(api, ctx, status, ct, body); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc writeResponseWithPanic(api API, ctx Context, status int, ct string, body any) {\n\tif err := writeResponse(api, ctx, status, ct, body); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// transformAndWrite is a utility function to transform and write a response.\n// It is best-effort as the status code and headers may have already been sent.\nfunc transformAndWrite(api API, ctx Context, status int, ct string, body any) error {\n\t// Try to transform and then marshal/write the response.\n\t// Status code was already sent, so just log the error if something fails,\n\t// and do our best to stuff it into the body of the response.\n\ttval, terr := api.Transform(ctx, strconv.Itoa(status), body)\n\tif terr != nil {\n\t\tctx.BodyWriter().Write([]byte(\"error transforming response\"))\n\t\t// When including tval in the panic message, the server may become unresponsive for some time if the value is very large\n\t\t// therefore, it has been removed from the panic message\n\t\treturn fmt.Errorf(\"error transforming response for %s %s %d: %w\", ctx.Operation().Method, ctx.Operation().Path, status, terr)\n\t}\n\tctx.SetStatus(status)\n\tif status != http.StatusNoContent && status != http.StatusNotModified {\n\t\tif merr := api.Marshal(ctx.BodyWriter(), ct, tval); merr != nil {\n\t\t\tif errors.Is(ctx.Context().Err(), context.Canceled) {\n\t\t\t\t// The client disconnected, so don't bother writing anything. Attempt\n\t\t\t\t// to set the status in case it'll get logged. Technically this was\n\t\t\t\t// not a normal successful request.\n\t\t\t\tctx.SetStatus(499)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tctx.BodyWriter().Write([]byte(\"error marshaling response\"))\n\t\t\t// When including tval in the panic message, the server may become unresponsive for some time if the value is very large\n\t\t\t// therefore, it has been removed from the panic message\n\t\t\treturn fmt.Errorf(\"error marshaling response for %s %s %d: %w\", ctx.Operation().Method, ctx.Operation().Path, status, merr)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc parseArrElement[T any](values []string, parse func(string) (T, error)) ([]T, error) {\n\tresult := make([]T, 0, len(values))\n\n\tfor i := 0; i < len(values); i++ {\n\t\tv, err := parse(values[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult = append(result, v)\n\t}\n\n\treturn result, nil\n}\n\n// writeHeader is a utility function to write a header value to the response.\n// the `write` function should be either `ctx.SetHeader` or `ctx.AppendHeader`.\nfunc writeHeader(write func(string, string), info *headerInfo, f reflect.Value) {\n\tswitch f.Kind() {\n\tcase reflect.String:\n\t\tif f.String() == \"\" {\n\t\t\t// Don't set empty headers.\n\t\t\treturn\n\t\t}\n\t\twrite(info.Name, f.String())\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\twrite(info.Name, strconv.FormatInt(f.Int(), 10))\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\twrite(info.Name, strconv.FormatUint(f.Uint(), 10))\n\tcase reflect.Float32, reflect.Float64:\n\t\twrite(info.Name, strconv.FormatFloat(f.Float(), 'f', -1, 64))\n\tcase reflect.Bool:\n\t\twrite(info.Name, strconv.FormatBool(f.Bool()))\n\tdefault:\n\t\tif f.Type() == timeType && !f.Interface().(time.Time).IsZero() {\n\t\t\twrite(info.Name, f.Interface().(time.Time).Format(info.TimeFormat))\n\t\t\treturn\n\t\t}\n\n\t\t// If the field value has a `String() string` method, use it.\n\t\tif f.CanAddr() {\n\t\t\tif s, ok := f.Addr().Interface().(fmt.Stringer); ok {\n\t\t\t\twrite(info.Name, s.String())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\twrite(info.Name, fmt.Sprintf(\"%v\", f.Interface()))\n\t}\n}\n\n// Register an operation handler for an API. The handler must be a function that\n// takes a context and a pointer to the input struct and returns a pointer to the\n// output struct and an error. The input struct must be a struct with fields\n// for the request path/query/header/cookie parameters and/or body. The output\n// struct must be a struct with fields for the output headers and body of the\n// operation, if any.\n//\n//\thuma.Register(api, huma.Operation{\n//\t\tOperationID: \"get-greeting\",\n//\t\tMethod:      http.MethodGet,\n//\t\tPath:        \"/greeting/{name}\",\n//\t\tSummary:     \"Get a greeting\",\n//\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n//\t\tif input.Name == \"bob\" {\n//\t\t\treturn nil, huma.Error404NotFound(\"no greeting for bob\")\n//\t\t}\n//\t\tresp := &GreetingOutput{}\n//\t\tresp.MyHeader = \"MyValue\"\n//\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n//\t\treturn resp, nil\n//\t})\nfunc Register[I, O any](api API, op Operation, handler func(context.Context, *I) (*O, error)) {\n\toapi := api.OpenAPI()\n\tregistry := oapi.Components.Schemas\n\n\tif op.Method == \"\" || op.Path == \"\" {\n\t\tpanic(\"method and path must be specified in operation\")\n\t}\n\n\tinputType := reflect.TypeOf((*I)(nil)).Elem()\n\tif inputType.Kind() != reflect.Struct {\n\t\tpanic(\"input must be a struct\")\n\t}\n\tinputParams := findParams(registry, &op, inputType)\n\tinputBodyIndex := []int{}\n\thasInputBody := false\n\tif f, ok := inputType.FieldByName(\"Body\"); ok {\n\t\thasInputBody = true\n\t\tinputBodyIndex = f.Index\n\t\tif op.RequestBody == nil {\n\t\t\top.RequestBody = &RequestBody{}\n\t\t}\n\n\t\trequired := f.Type.Kind() != reflect.Ptr && f.Type.Kind() != reflect.Interface\n\t\tif f.Tag.Get(\"required\") == \"true\" {\n\t\t\trequired = true\n\t\t}\n\n\t\tcontentType := \"application/json\"\n\t\tif c := f.Tag.Get(\"contentType\"); c != \"\" {\n\t\t\tcontentType = c\n\t\t}\n\t\thint := getHint(inputType, f.Name, op.OperationID+\"Request\")\n\t\tif nameHint := f.Tag.Get(\"nameHint\"); nameHint != \"\" {\n\t\t\thint = nameHint\n\t\t}\n\t\ts := SchemaFromField(registry, f, hint)\n\n\t\top.RequestBody.Required = required\n\n\t\tif op.RequestBody.Content == nil {\n\t\t\top.RequestBody.Content = map[string]*MediaType{}\n\t\t}\n\t\top.RequestBody.Content[contentType] = &MediaType{Schema: s}\n\n\t\tif op.BodyReadTimeout == 0 {\n\t\t\t// 5 second default\n\t\t\top.BodyReadTimeout = 5 * time.Second\n\t\t}\n\n\t\tif op.MaxBodyBytes == 0 {\n\t\t\t// 1 MB default\n\t\t\top.MaxBodyBytes = 1024 * 1024\n\t\t}\n\t}\n\trawBodyIndex := []int{}\n\trawBodyMultipart := false\n\trawBodyDecodedMultipart := false\n\tif f, ok := inputType.FieldByName(\"RawBody\"); ok {\n\t\trawBodyIndex = f.Index\n\t\tif op.RequestBody == nil {\n\t\t\top.RequestBody = &RequestBody{\n\t\t\t\tRequired: true,\n\t\t\t}\n\t\t}\n\n\t\tif op.RequestBody.Content == nil {\n\t\t\top.RequestBody.Content = map[string]*MediaType{}\n\t\t}\n\n\t\tcontentType := \"application/octet-stream\"\n\n\t\tif f.Type.String() == \"multipart.Form\" {\n\t\t\tcontentType = \"multipart/form-data\"\n\t\t\trawBodyMultipart = true\n\t\t}\n\t\tif strings.HasPrefix(f.Type.Name(), \"MultipartFormFiles\") {\n\t\t\tcontentType = \"multipart/form-data\"\n\t\t\trawBodyDecodedMultipart = true\n\t\t}\n\n\t\tif c := f.Tag.Get(\"contentType\"); c != \"\" {\n\t\t\tcontentType = c\n\t\t}\n\n\t\tswitch contentType {\n\t\tcase \"multipart/form-data\":\n\t\t\tif op.RequestBody.Content[\"multipart/form-data\"] != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif rawBodyMultipart {\n\t\t\t\top.RequestBody.Content[\"multipart/form-data\"] = &MediaType{\n\t\t\t\t\tSchema: &Schema{\n\t\t\t\t\t\tType: \"object\",\n\t\t\t\t\t\tProperties: map[string]*Schema{\n\t\t\t\t\t\t\t\"name\": {\n\t\t\t\t\t\t\t\tType:        \"string\",\n\t\t\t\t\t\t\t\tDescription: \"general purpose name for multipart form value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"filename\": {\n\t\t\t\t\t\t\t\tType:        \"string\",\n\t\t\t\t\t\t\t\tFormat:      \"binary\",\n\t\t\t\t\t\t\t\tDescription: \"filename of the file being uploaded\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tif rawBodyDecodedMultipart {\n\t\t\t\tdataField, ok := f.Type.FieldByName(\"data\")\n\t\t\t\tif !ok {\n\t\t\t\t\tpanic(\"Expected type MultipartFormFiles[T] to have a 'data *T' generic pointer field\")\n\t\t\t\t}\n\t\t\t\top.RequestBody.Content[\"multipart/form-data\"] = &MediaType{\n\t\t\t\t\tSchema:   multiPartFormFileSchema(dataField.Type.Elem()),\n\t\t\t\t\tEncoding: multiPartContentEncoding(dataField.Type.Elem()),\n\t\t\t\t}\n\t\t\t\top.RequestBody.Required = false\n\t\t\t}\n\t\tdefault:\n\t\t\top.RequestBody.Content[contentType] = &MediaType{\n\t\t\t\tSchema: &Schema{\n\t\t\t\t\tType:   \"string\",\n\t\t\t\t\tFormat: \"binary\",\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tif op.RequestBody != nil {\n\t\tfor _, mediatype := range op.RequestBody.Content {\n\t\t\tif mediatype.Schema != nil {\n\t\t\t\t// Ensure all schema validation errors are set up properly as some\n\t\t\t\t// parts of the schema may have been user-supplied.\n\t\t\t\tmediatype.Schema.PrecomputeMessages()\n\t\t\t}\n\t\t}\n\t}\n\n\tvar inSchema *Schema\n\tif op.RequestBody != nil && op.RequestBody.Content != nil && op.RequestBody.Content[\"application/json\"] != nil && op.RequestBody.Content[\"application/json\"].Schema != nil {\n\t\thasInputBody = true\n\t\tinSchema = op.RequestBody.Content[\"application/json\"].Schema\n\t}\n\n\tresolvers := findResolvers(resolverType, inputType)\n\tdefaults := findDefaults(registry, inputType)\n\n\tif op.Responses == nil {\n\t\top.Responses = map[string]*Response{}\n\t}\n\toutputType := reflect.TypeOf((*O)(nil)).Elem()\n\tif outputType.Kind() != reflect.Struct {\n\t\tpanic(\"output must be a struct\")\n\t}\n\n\toutStatusIndex := -1\n\tif f, ok := outputType.FieldByName(\"Status\"); ok {\n\t\toutStatusIndex = f.Index[0]\n\t\tif f.Type.Kind() != reflect.Int {\n\t\t\tpanic(\"status field must be an int\")\n\t\t}\n\t\t// TODO: enum tag?\n\t\t// TODO: register each of the possible responses with the right model\n\t\t//       and headers down below.\n\t}\n\toutHeaders := findHeaders(outputType)\n\toutBodyIndex := -1\n\toutBodyFunc := false\n\tif f, ok := outputType.FieldByName(\"Body\"); ok {\n\t\toutBodyIndex = f.Index[0]\n\t\tif f.Type.Kind() == reflect.Func {\n\t\t\toutBodyFunc = true\n\n\t\t\tif f.Type != bodyCallbackType {\n\t\t\t\tpanic(\"body field must be a function with signature func(huma.Context)\")\n\t\t\t}\n\t\t}\n\t\tstatus := op.DefaultStatus\n\t\tif status == 0 {\n\t\t\tstatus = http.StatusOK\n\t\t}\n\t\tstatusStr := strconv.Itoa(status)\n\t\tif op.Responses[statusStr] == nil {\n\t\t\top.Responses[statusStr] = &Response{}\n\t\t}\n\t\tif op.Responses[statusStr].Description == \"\" {\n\t\t\top.Responses[statusStr].Description = http.StatusText(status)\n\t\t}\n\t\tif op.Responses[statusStr].Headers == nil {\n\t\t\top.Responses[statusStr].Headers = map[string]*Param{}\n\t\t}\n\t\tif !outBodyFunc {\n\t\t\thint := getHint(outputType, f.Name, op.OperationID+\"Response\")\n\t\t\tif nameHint := f.Tag.Get(\"nameHint\"); nameHint != \"\" {\n\t\t\t\thint = nameHint\n\t\t\t}\n\t\t\toutSchema := SchemaFromField(registry, f, hint)\n\t\t\tif op.Responses[statusStr].Content == nil {\n\t\t\t\top.Responses[statusStr].Content = map[string]*MediaType{}\n\t\t\t}\n\t\t\t// Check if the field's type implements ContentTypeFilter\n\t\t\tcontentType := \"application/json\"\n\t\t\tif reflect.PointerTo(f.Type).Implements(reflect.TypeFor[ContentTypeFilter]()) {\n\t\t\t\tinstance := reflect.New(f.Type).Interface().(ContentTypeFilter)\n\t\t\t\tcontentType = instance.ContentType(contentType)\n\t\t\t}\n\t\t\tif len(op.Responses[statusStr].Content) == 0 {\n\t\t\t\top.Responses[statusStr].Content[contentType] = &MediaType{}\n\t\t\t}\n\t\t\tif op.Responses[statusStr].Content[contentType] != nil && op.Responses[statusStr].Content[contentType].Schema == nil {\n\t\t\t\top.Responses[statusStr].Content[contentType].Schema = outSchema\n\t\t\t}\n\t\t}\n\t}\n\tif op.DefaultStatus == 0 {\n\t\tif outBodyIndex != -1 {\n\t\t\top.DefaultStatus = http.StatusOK\n\t\t} else {\n\t\t\top.DefaultStatus = http.StatusNoContent\n\t\t}\n\t}\n\tdefaultStatusStr := strconv.Itoa(op.DefaultStatus)\n\tif op.Responses[defaultStatusStr] == nil {\n\t\top.Responses[defaultStatusStr] = &Response{\n\t\t\tDescription: http.StatusText(op.DefaultStatus),\n\t\t}\n\t}\n\tfor _, entry := range outHeaders.Paths {\n\t\t// Document the header's name and type.\n\t\tif op.Responses[defaultStatusStr].Headers == nil {\n\t\t\top.Responses[defaultStatusStr].Headers = map[string]*Param{}\n\t\t}\n\t\tv := entry.Value\n\t\tf := v.Field\n\t\tif f.Type.Kind() == reflect.Slice {\n\t\t\tf.Type = deref(f.Type.Elem())\n\t\t}\n\t\tif reflect.PointerTo(f.Type).Implements(fmtStringerType) {\n\t\t\t// Special case: this field will be written as a string by calling\n\t\t\t// `.String()` on the value.\n\t\t\tf.Type = stringType\n\t\t}\n\t\top.Responses[defaultStatusStr].Headers[v.Name] = &Header{\n\t\t\t// We need to generate the schema from the field to get validation info\n\t\t\t// like min/max and enums. Useful to let the client know possible values.\n\t\t\tSchema: SchemaFromField(registry, f, getHint(outputType, f.Name, op.OperationID+defaultStatusStr+v.Name)),\n\t\t}\n\t}\n\n\tif len(op.Errors) > 0 && (len(inputParams.Paths) > 0 || hasInputBody) {\n\t\top.Errors = append(op.Errors, http.StatusUnprocessableEntity)\n\t}\n\tif len(op.Errors) > 0 {\n\t\top.Errors = append(op.Errors, http.StatusInternalServerError)\n\t}\n\n\texampleErr := NewError(0, \"\")\n\terrContentType := \"application/json\"\n\tif ctf, ok := exampleErr.(ContentTypeFilter); ok {\n\t\terrContentType = ctf.ContentType(errContentType)\n\t}\n\terrType := deref(reflect.TypeOf(exampleErr))\n\terrSchema := registry.Schema(errType, true, getHint(errType, \"\", \"Error\"))\n\tfor _, code := range op.Errors {\n\t\top.Responses[strconv.Itoa(code)] = &Response{\n\t\t\tDescription: http.StatusText(code),\n\t\t\tContent: map[string]*MediaType{\n\t\t\t\terrContentType: {\n\t\t\t\t\tSchema: errSchema,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\tif len(op.Responses) <= 1 && len(op.Errors) == 0 {\n\t\t// No errors are defined, so set a default response.\n\t\top.Responses[\"default\"] = &Response{\n\t\t\tDescription: \"Error\",\n\t\t\tContent: map[string]*MediaType{\n\t\t\t\terrContentType: {\n\t\t\t\t\tSchema: errSchema,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tif !op.Hidden {\n\t\toapi.AddOperation(&op)\n\t}\n\n\ta := api.Adapter()\n\n\ta.Handle(&op, api.Middlewares().Handler(op.Middlewares.Handler(func(ctx Context) {\n\t\tvar input I\n\n\t\t// Get the validation dependencies from the shared pool.\n\t\tdeps := validatePool.Get().(*validateDeps)\n\t\tdefer func() {\n\t\t\tdeps.pb.Reset()\n\t\t\tdeps.res.Reset()\n\t\t\tvalidatePool.Put(deps)\n\t\t}()\n\t\tpb := deps.pb\n\t\tres := deps.res\n\n\t\terrStatus := http.StatusUnprocessableEntity\n\n\t\tvar cookies map[string]*http.Cookie\n\n\t\tv := reflect.ValueOf(&input).Elem()\n\t\tinputParams.Every(v, func(f reflect.Value, p *paramFieldInfo) {\n\t\t\tf = reflect.Indirect(f)\n\t\t\tif f.Kind() == reflect.Invalid {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar value string\n\t\t\tswitch p.Loc {\n\t\t\tcase \"path\":\n\t\t\t\tvalue = ctx.Param(p.Name)\n\t\t\tcase \"query\":\n\t\t\t\tvalue = ctx.Query(p.Name)\n\t\t\tcase \"header\":\n\t\t\t\tvalue = ctx.Header(p.Name)\n\t\t\tcase \"cookie\":\n\t\t\t\tif cookies == nil {\n\t\t\t\t\t// Only parse the cookie headers once, on-demand.\n\t\t\t\t\tcookies = map[string]*http.Cookie{}\n\t\t\t\t\tfor _, c := range ReadCookies(ctx) {\n\t\t\t\t\t\tcookies[c.Name] = c\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif c, ok := cookies[p.Name]; ok {\n\t\t\t\t\t// Special case: http.Cookie type, meaning we want the entire parsed\n\t\t\t\t\t// cookie struct, not just the value.\n\t\t\t\t\tif f.Type() == cookieType {\n\t\t\t\t\t\tf.Set(reflect.ValueOf(cookies[p.Name]).Elem())\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = c.Value\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpb.Reset()\n\t\t\tpb.Push(p.Loc)\n\t\t\tpb.Push(p.Name)\n\n\t\t\tif value == \"\" && p.Default != \"\" {\n\t\t\t\tvalue = p.Default\n\t\t\t}\n\n\t\t\tif !op.SkipValidateParams && p.Required && value == \"\" {\n\t\t\t\t// Path params are always required.\n\t\t\t\tres.Add(pb, \"\", \"required \"+p.Loc+\" parameter is missing\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif value != \"\" {\n\t\t\t\tvar pv any\n\n\t\t\t\tswitch p.Type.Kind() {\n\t\t\t\tcase reflect.String:\n\t\t\t\t\tf.SetString(value)\n\t\t\t\t\tpv = value\n\t\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\t\t\tv, err := strconv.ParseInt(value, 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tf.SetInt(v)\n\t\t\t\t\tpv = v\n\t\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\t\t\tv, err := strconv.ParseUint(value, 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tf.SetUint(v)\n\t\t\t\t\tpv = v\n\t\t\t\tcase reflect.Float32, reflect.Float64:\n\t\t\t\t\tv, err := strconv.ParseFloat(value, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tres.Add(pb, value, \"invalid float\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tf.SetFloat(v)\n\t\t\t\t\tpv = v\n\t\t\t\tcase reflect.Bool:\n\t\t\t\t\tv, err := strconv.ParseBool(value)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tres.Add(pb, value, \"invalid boolean\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tf.SetBool(v)\n\t\t\t\t\tpv = v\n\t\t\t\tdefault:\n\t\t\t\t\tif f.Type().Kind() == reflect.Slice {\n\t\t\t\t\t\tvar values []string\n\t\t\t\t\t\tif p.Explode {\n\t\t\t\t\t\t\tu := ctx.URL()\n\t\t\t\t\t\t\tvalues = (&u).Query()[p.Name]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalues = strings.Split(value, \",\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch f.Type().Elem().Kind() {\n\n\t\t\t\t\t\tcase reflect.String:\n\t\t\t\t\t\t\tif f.Type() == reflect.TypeOf(values) {\n\t\t\t\t\t\t\t\tf.Set(reflect.ValueOf(values))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Change element type to support slice of string subtypes (enums)\n\t\t\t\t\t\t\t\tenumValues := reflect.New(f.Type()).Elem()\n\t\t\t\t\t\t\t\tfor _, val := range values {\n\t\t\t\t\t\t\t\t\tenumVal := reflect.New(f.Type().Elem()).Elem()\n\t\t\t\t\t\t\t\t\tenumVal.SetString(val)\n\t\t\t\t\t\t\t\t\tenumValues.Set(reflect.Append(enumValues, enumVal))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tf.Set(enumValues)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpv = values\n\n\t\t\t\t\t\tcase reflect.Int:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (int, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseInt(s, 10, strconv.IntSize)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn int(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Int8:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (int8, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseInt(s, 10, 8)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn int8(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Int16:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (int16, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseInt(s, 10, 16)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn int16(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Int32:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (int32, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseInt(s, 10, 32)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn int32(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Int64:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (int64, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseInt(s, 10, 64)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn val, nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Uint:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (uint, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseUint(s, 10, strconv.IntSize)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn uint(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Uint16:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (uint16, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseUint(s, 10, 16)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn uint16(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Uint32:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (uint32, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseUint(s, 10, 32)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn uint32(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Uint64:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (uint64, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseUint(s, 10, 64)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn val, nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid integer\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Float32:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (float32, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseFloat(s, 32)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn float32(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid floating value\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\n\t\t\t\t\t\tcase reflect.Float64:\n\t\t\t\t\t\t\tvs, err := parseArrElement(values, func(s string) (float64, error) {\n\t\t\t\t\t\t\t\tval, err := strconv.ParseFloat(s, 64)\n\t\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn float64(val), nil\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tres.Add(pb, value, \"invalid floating value\")\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tf.Set(reflect.ValueOf(vs))\n\t\t\t\t\t\t\tpv = vs\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\t// Special case: time.Time\n\t\t\t\t\tif f.Type() == timeType {\n\t\t\t\t\t\tt, err := time.Parse(p.TimeFormat, value)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tres.Add(pb, value, \"invalid date/time for format \"+p.TimeFormat)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf.Set(reflect.ValueOf(t))\n\t\t\t\t\t\tpv = value\n\t\t\t\t\t\tbreak\n\t\t\t\t\t\t// Special case: url.URL\n\t\t\t\t\t} else if f.Type() == urlType {\n\t\t\t\t\t\tu, err := url.Parse(value)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tres.Add(pb, value, \"invalid url.URL value\")\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf.Set(reflect.ValueOf(*u))\n\t\t\t\t\t\tpv = value\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\t// Last resort: use the `encoding.TextUnmarshaler` interface.\n\t\t\t\t\tif fn, ok := f.Addr().Interface().(encoding.TextUnmarshaler); ok {\n\t\t\t\t\t\tif err := fn.UnmarshalText([]byte(value)); err != nil {\n\t\t\t\t\t\t\tres.Add(pb, value, \"invalid value: \"+err.Error())\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpv = value\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tpanic(\"unsupported param type \" + p.Type.String())\n\t\t\t\t}\n\n\t\t\t\tif !op.SkipValidateParams {\n\t\t\t\t\tValidate(oapi.Components.Schemas, p.Schema, pb, ModeWriteToServer, pv, res)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\t// Read input body if defined.\n\t\tif hasInputBody || len(rawBodyIndex) > 0 {\n\t\t\tif op.BodyReadTimeout > 0 {\n\t\t\t\tctx.SetReadDeadline(time.Now().Add(op.BodyReadTimeout))\n\t\t\t} else if op.BodyReadTimeout < 0 {\n\t\t\t\t// Disable any server-wide deadline.\n\t\t\t\tctx.SetReadDeadline(time.Time{})\n\t\t\t}\n\n\t\t\tif rawBodyMultipart || rawBodyDecodedMultipart {\n\t\t\t\tform, err := ctx.GetMultipartForm()\n\t\t\t\tif err != nil {\n\t\t\t\t\tres.Errors = append(res.Errors, &ErrorDetail{\n\t\t\t\t\t\tLocation: \"body\",\n\t\t\t\t\t\tMessage:  \"cannot read multipart form: \" + err.Error(),\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tf := v\n\t\t\t\t\tfor _, i := range rawBodyIndex {\n\t\t\t\t\t\tf = f.Field(i)\n\t\t\t\t\t}\n\t\t\t\t\tif rawBodyMultipart {\n\t\t\t\t\t\tf.Set(reflect.ValueOf(*form))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf.FieldByName(\"Form\").Set(reflect.ValueOf(form))\n\t\t\t\t\t\tr := f.Addr().\n\t\t\t\t\t\t\tMethodByName(\"Decode\").\n\t\t\t\t\t\t\tCall([]reflect.Value{\n\t\t\t\t\t\t\t\treflect.ValueOf(op.RequestBody.Content[\"multipart/form-data\"]),\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\terrs := r[0].Interface().([]error)\n\t\t\t\t\t\tif errs != nil {\n\t\t\t\t\t\t\tWriteErr(api, ctx, http.StatusUnprocessableEntity, \"validation failed\", errs...)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuf := bufPool.Get().(*bytes.Buffer)\n\t\t\t\treader := ctx.BodyReader()\n\t\t\t\tif reader == nil {\n\t\t\t\t\treader = bytes.NewReader(nil)\n\t\t\t\t}\n\t\t\t\tif closer, ok := reader.(io.Closer); ok {\n\t\t\t\t\tdefer closer.Close()\n\t\t\t\t}\n\t\t\t\tif op.MaxBodyBytes > 0 {\n\t\t\t\t\treader = io.LimitReader(reader, op.MaxBodyBytes)\n\t\t\t\t}\n\t\t\t\tcount, err := io.Copy(buf, reader)\n\t\t\t\tif op.MaxBodyBytes > 0 {\n\t\t\t\t\tif count == op.MaxBodyBytes {\n\t\t\t\t\t\tbuf.Reset()\n\t\t\t\t\t\tbufPool.Put(buf)\n\t\t\t\t\t\tWriteErr(api, ctx, http.StatusRequestEntityTooLarge, fmt.Sprintf(\"request body is too large limit=%d bytes\", op.MaxBodyBytes), res.Errors...)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tbuf.Reset()\n\t\t\t\t\tbufPool.Put(buf)\n\n\t\t\t\t\tif e, ok := err.(net.Error); ok && e.Timeout() {\n\t\t\t\t\t\tWriteErr(api, ctx, http.StatusRequestTimeout, \"request body read timeout\", res.Errors...)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tWriteErr(api, ctx, http.StatusInternalServerError, \"cannot read request body\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbody := buf.Bytes()\n\n\t\t\t\tif len(rawBodyIndex) > 0 {\n\t\t\t\t\tf := v\n\t\t\t\t\tfor _, i := range rawBodyIndex {\n\t\t\t\t\t\tf = f.Field(i)\n\t\t\t\t\t}\n\t\t\t\t\tf.SetBytes(body)\n\t\t\t\t}\n\n\t\t\t\tif len(body) == 0 {\n\t\t\t\t\tif op.RequestBody != nil && op.RequestBody.Required {\n\t\t\t\t\t\tbuf.Reset()\n\t\t\t\t\t\tbufPool.Put(buf)\n\t\t\t\t\t\tWriteErr(api, ctx, http.StatusBadRequest, \"request body is required\", res.Errors...)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparseErrCount := 0\n\t\t\t\t\tif hasInputBody && !op.SkipValidateBody {\n\t\t\t\t\t\t// Validate the input. First, parse the body into []any or map[string]any\n\t\t\t\t\t\t// or equivalent, which can be easily validated. Then, convert to the\n\t\t\t\t\t\t// expected struct type to call the handler.\n\t\t\t\t\t\tvar parsed any\n\t\t\t\t\t\tif err := api.Unmarshal(ctx.Header(\"Content-Type\"), body, &parsed); err != nil {\n\t\t\t\t\t\t\terrStatus = http.StatusBadRequest\n\t\t\t\t\t\t\tif errors.Is(err, ErrUnknownContentType) {\n\t\t\t\t\t\t\t\terrStatus = http.StatusUnsupportedMediaType\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tres.Errors = append(res.Errors, &ErrorDetail{\n\t\t\t\t\t\t\t\tLocation: \"body\",\n\t\t\t\t\t\t\t\tMessage:  err.Error(),\n\t\t\t\t\t\t\t\tValue:    string(body),\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tparseErrCount++\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpb.Reset()\n\t\t\t\t\t\t\tpb.Push(\"body\")\n\t\t\t\t\t\t\tcount := len(res.Errors)\n\t\t\t\t\t\t\tValidate(oapi.Components.Schemas, inSchema, pb, ModeWriteToServer, parsed, res)\n\t\t\t\t\t\t\tparseErrCount = len(res.Errors) - count\n\t\t\t\t\t\t\tif parseErrCount > 0 {\n\t\t\t\t\t\t\t\terrStatus = http.StatusUnprocessableEntity\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif hasInputBody && len(inputBodyIndex) > 0 {\n\t\t\t\t\t\t// We need to get the body into the correct type now that it has been\n\t\t\t\t\t\t// validated. Benchmarks on Go 1.20 show that using `json.Unmarshal` a\n\t\t\t\t\t\t// second time is faster than `mapstructure.Decode` or any of the other\n\t\t\t\t\t\t// common reflection-based approaches when using real-world medium-sized\n\t\t\t\t\t\t// JSON payloads with lots of strings.\n\t\t\t\t\t\tf := v\n\t\t\t\t\t\tfor _, index := range inputBodyIndex {\n\t\t\t\t\t\t\tf = f.Field(index)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif err := api.Unmarshal(ctx.Header(\"Content-Type\"), body, f.Addr().Interface()); err != nil {\n\t\t\t\t\t\t\tif parseErrCount == 0 {\n\t\t\t\t\t\t\t\t// Hmm, this should have worked... validator missed something?\n\t\t\t\t\t\t\t\tres.Errors = append(res.Errors, &ErrorDetail{\n\t\t\t\t\t\t\t\t\tLocation: \"body\",\n\t\t\t\t\t\t\t\t\tMessage:  err.Error(),\n\t\t\t\t\t\t\t\t\tValue:    string(body),\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Set defaults for any fields that were not in the input.\n\t\t\t\t\t\t\tdefaults.Every(v, func(item reflect.Value, def any) {\n\t\t\t\t\t\t\t\tif item.IsZero() {\n\t\t\t\t\t\t\t\t\tif item.Kind() == reflect.Pointer {\n\t\t\t\t\t\t\t\t\t\titem.Set(reflect.New(item.Type().Elem()))\n\t\t\t\t\t\t\t\t\t\titem = item.Elem()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\titem.Set(reflect.Indirect(reflect.ValueOf(def)))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(rawBodyIndex) > 0 {\n\t\t\t\t\t\t// If the raw body is used, then we must wait until *AFTER* the\n\t\t\t\t\t\t// handler has run to return the body byte buffer to the pool, as\n\t\t\t\t\t\t// the handler can read and modify this buffer. The safest way is\n\t\t\t\t\t\t// to just wait until the end of this handler via defer.\n\t\t\t\t\t\tdefer bufPool.Put(buf)\n\t\t\t\t\t\tdefer buf.Reset()\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No raw body, and the body has already been unmarshalled above, so\n\t\t\t\t\t\t// we can return the buffer to the pool now as we don't need the\n\t\t\t\t\t\t// bytes any more.\n\t\t\t\t\t\tbuf.Reset()\n\t\t\t\t\t\tbufPool.Put(buf)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tresolvers.EveryPB(pb, v, func(item reflect.Value, _ bool) {\n\t\t\titem = reflect.Indirect(item)\n\t\t\tif item.Kind() == reflect.Invalid {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif item.CanAddr() {\n\t\t\t\titem = item.Addr()\n\t\t\t} else {\n\t\t\t\t// If the item is non-addressable (example: primitive custom type with\n\t\t\t\t// a resolver as a map value), then we need to create a new pointer to\n\t\t\t\t// the value to ensure the resolver can be called, regardless of whether\n\t\t\t\t// is a value or pointer resolver type.\n\t\t\t\t// TODO: this is inefficient and could be improved in the future.\n\t\t\t\tptr := reflect.New(item.Type())\n\t\t\t\telem := ptr.Elem()\n\t\t\t\telem.Set(item)\n\t\t\t\titem = ptr\n\t\t\t}\n\t\t\tvar errs []error\n\t\t\tswitch resolver := item.Interface().(type) {\n\t\t\tcase Resolver:\n\t\t\t\terrs = resolver.Resolve(ctx)\n\t\t\tcase ResolverWithPath:\n\t\t\t\terrs = resolver.Resolve(ctx, pb)\n\t\t\tdefault:\n\t\t\t\tpanic(\"matched resolver cannot be run, please file a bug\")\n\t\t\t}\n\t\t\tif len(errs) > 0 {\n\t\t\t\tres.Errors = append(res.Errors, errs...)\n\t\t\t}\n\t\t})\n\n\t\tif len(res.Errors) > 0 {\n\t\t\tfor i := len(res.Errors) - 1; i >= 0; i-- {\n\t\t\t\t// If there are errors, and they provide a status, then update the\n\t\t\t\t// response status code to match. Otherwise, use the default status\n\t\t\t\t// code is used. Since these run in order, the last error code wins.\n\t\t\t\tif s, ok := res.Errors[i].(StatusError); ok {\n\t\t\t\t\terrStatus = s.GetStatus()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tWriteErr(api, ctx, errStatus, \"validation failed\", res.Errors...)\n\t\t\treturn\n\t\t}\n\n\t\toutput, err := handler(ctx.Context(), &input)\n\t\tif err != nil {\n\t\t\tvar he HeadersError\n\t\t\tif errors.As(err, &he) {\n\t\t\t\tfor k, values := range he.GetHeaders() {\n\t\t\t\t\tfor _, v := range values {\n\t\t\t\t\t\tctx.AppendHeader(k, v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatus := http.StatusInternalServerError\n\n\t\t\t// handle status error\n\t\t\tvar se StatusError\n\t\t\tif errors.As(err, &se) {\n\t\t\t\twriteResponseWithPanic(api, ctx, se.GetStatus(), \"\", se)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tse = NewErrorWithContext(ctx, status, \"unexpected error occurred\", err)\n\t\t\twriteResponseWithPanic(api, ctx, se.GetStatus(), \"\", se)\n\t\t\treturn\n\t\t}\n\n\t\tif output == nil {\n\t\t\t// Special case: No err or output, so just set the status code and return.\n\t\t\t// This is a weird case, but it's better than panicking or returning 500.\n\t\t\tctx.SetStatus(op.DefaultStatus)\n\t\t\treturn\n\t\t}\n\n\t\t// Serialize output headers\n\t\tct := \"\"\n\t\tvo := reflect.ValueOf(output).Elem()\n\t\toutHeaders.Every(vo, func(f reflect.Value, info *headerInfo) {\n\t\t\tf = reflect.Indirect(f)\n\t\t\tif f.Kind() == reflect.Invalid {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif f.Kind() == reflect.Slice {\n\t\t\t\tfor i := 0; i < f.Len(); i++ {\n\t\t\t\t\twriteHeader(ctx.AppendHeader, info, f.Index(i))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif f.Kind() == reflect.String && info.Name == \"Content-Type\" {\n\t\t\t\t\t// Track custom content type. This overrides any content negotiation\n\t\t\t\t\t// that would happen when writing the response.\n\t\t\t\t\tct = f.String()\n\t\t\t\t}\n\t\t\t\twriteHeader(ctx.SetHeader, info, f)\n\t\t\t}\n\t\t})\n\n\t\tstatus := op.DefaultStatus\n\t\tif outStatusIndex != -1 {\n\t\t\tstatus = int(vo.Field(outStatusIndex).Int())\n\t\t}\n\n\t\tif outBodyIndex != -1 {\n\t\t\t// Serialize output body\n\t\t\tbody := vo.Field(outBodyIndex).Interface()\n\n\t\t\tif outBodyFunc {\n\t\t\t\tbody.(func(Context))(ctx)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif b, ok := body.([]byte); ok {\n\t\t\t\tctx.SetStatus(status)\n\t\t\t\tctx.BodyWriter().Write(b)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\twriteResponseWithPanic(api, ctx, status, ct, body)\n\t\t} else {\n\t\t\tctx.SetStatus(status)\n\t\t}\n\t})))\n}\n\n// AutoRegister auto-detects operation registration methods and registers them\n// with the given API. Any method named `Register...` will be called and\n// passed the API as the only argument. Since registration happens at\n// service startup, no errors are returned and methods should panic on error.\n//\n//\ttype ItemsHandler struct {}\n//\n//\tfunc (s *ItemsHandler) RegisterListItems(api API) {\n//\t\thuma.Register(api, huma.Operation{\n//\t\t\tOperationID: \"ListItems\",\n//\t\t\tMethod: http.MethodGet,\n//\t\t\tPath: \"/items\",\n//\t\t}, s.ListItems)\n//\t}\n//\n//\tfunc main() {\n//\t\trouter := chi.NewMux()\n//\t\tconfig := huma.DefaultConfig(\"My Service\", \"1.0.0\")\n//\t\tapi := huma.NewExampleAPI(router, config)\n//\n//\t\titemsHandler := &ItemsHandler{}\n//\t\thuma.AutoRegister(api, itemsHandler)\n//\t}\nfunc AutoRegister(api API, server any) {\n\targs := []reflect.Value{reflect.ValueOf(server), reflect.ValueOf(api)}\n\n\tt := reflect.TypeOf(server)\n\tfor i := 0; i < t.NumMethod(); i++ {\n\t\tm := t.Method(i)\n\t\tif strings.HasPrefix(m.Name, \"Register\") && len(m.Name) > 8 {\n\t\t\tm.Func.Call(args)\n\t\t}\n\t}\n}\n\nvar reRemoveIDs = regexp.MustCompile(`\\{([^}]+)\\}`)\n\n// GenerateOperationID generates an operation ID from the method, path,\n// and response type. The operation ID is used to uniquely identify an\n// operation in the OpenAPI spec. The generated ID is kebab-cased and\n// includes the method and path, with any path parameters replaced by\n// their names.\n//\n// Examples:\n//\n//   - GET /things` -> `list-things\n//   - GET /things/{thing-id} -> get-things-by-thing-id\n//   - PUT /things/{thingId}/favorite -> put-things-by-thing-id-favorite\n//\n// This function can be overridden to provide custom operation IDs.\nvar GenerateOperationID = func(method, path string, response any) string {\n\taction := method\n\tt := deref(reflect.TypeOf(response))\n\tif t.Kind() != reflect.Struct {\n\t\tpanic(\"Response type must be a struct\")\n\t}\n\tbody, hasBody := t.FieldByName(\"Body\")\n\tif hasBody && method == http.MethodGet && deref(body.Type).Kind() == reflect.Slice {\n\t\t// Special case: GET with a slice response body is a list operation.\n\t\taction = \"list\"\n\t}\n\treturn casing.Kebab(action + \"-\" + reRemoveIDs.ReplaceAllString(path, \"by-$1\"))\n}\n\n// GenerateSummary generates an operation summary from the method, path,\n// and response type. The summary is used to describe an operation in the\n// OpenAPI spec. The generated summary is capitalized and includes the\n// method and path, with any path parameters replaced by their names.\n//\n// Examples:\n//\n//   - GET /things` -> `List things`\n//   - GET /things/{thing-id} -> `Get things by thing id`\n//   - PUT /things/{thingId}/favorite -> `Put things by thing id favorite`\n//\n// This function can be overridden to provide custom operation summaries.\nvar GenerateSummary = func(method, path string, response any) string {\n\taction := method\n\tt := deref(reflect.TypeOf(response))\n\tif t.Kind() != reflect.Struct {\n\t\tpanic(\"Response type must be a struct\")\n\t}\n\tbody, hasBody := t.FieldByName(\"Body\")\n\tif hasBody && method == http.MethodGet && deref(body.Type).Kind() == reflect.Slice {\n\t\t// Special case: GET with a slice response body is a list operation.\n\t\taction = \"list\"\n\t}\n\tpath = reRemoveIDs.ReplaceAllString(path, \"by-$1\")\n\tphrase := strings.ReplaceAll(casing.Kebab(strings.ToLower(action)+\" \"+path, strings.ToLower, casing.Initialism), \"-\", \" \")\n\treturn strings.ToUpper(phrase[:1]) + phrase[1:]\n}\n\nfunc OperationTags(tags ...string) func(o *Operation) {\n\treturn func(o *Operation) {\n\t\to.Tags = tags\n\t}\n}\n\nfunc convenience[I, O any](api API, method, path string, handler func(context.Context, *I) (*O, error), operationHandlers ...func(o *Operation)) {\n\tvar o *O\n\toperation := Operation{\n\t\tOperationID: GenerateOperationID(method, path, o),\n\t\tSummary:     GenerateSummary(method, path, o),\n\t\tMethod:      method,\n\t\tPath:        path,\n\t}\n\tfor _, oh := range operationHandlers {\n\t\toh(&operation)\n\t}\n\tRegister(api, operation, handler)\n}\n\n// Get HTTP operation handler for an API. The handler must be a function that\n// takes a context and a pointer to the input struct and returns a pointer to the\n// output struct and an error. The input struct must be a struct with fields\n// for the request path/query/header/cookie parameters and/or body. The output\n// struct must be a struct with fields for the output headers and body of the\n// operation, if any.\n//\n//\thuma.Get(api, \"/things\", func(ctx context.Context, input *struct{\n//\t\tBody []Thing\n//\t}) (*ListThingOutput, error) {\n//\t\t// TODO: list things from DB...\n//\t\tresp := &PostThingOutput{}\n//\t\tresp.Body = []Thing{{ID: \"1\", Name: \"Thing 1\"}}\n//\t\treturn resp, nil\n//\t})\n//\n// This is a convenience wrapper around `huma.Register`.\nfunc Get[I, O any](api API, path string, handler func(context.Context, *I) (*O, error), operationHandlers ...func(o *Operation)) {\n\tconvenience(api, http.MethodGet, path, handler, operationHandlers...)\n}\n\n// Post HTTP operation handler for an API. The handler must be a function that\n// takes a context and a pointer to the input struct and returns a pointer to the\n// output struct and an error. The input struct must be a struct with fields\n// for the request path/query/header/cookie parameters and/or body. The output\n// struct must be a struct with fields for the output headers and body of the\n// operation, if any.\n//\n//\thuma.Post(api, \"/things\", func(ctx context.Context, input *struct{\n//\t\tBody Thing\n//\t}) (*PostThingOutput, error) {\n//\t\t// TODO: save thing to DB...\n//\t\tresp := &PostThingOutput{}\n//\t\tresp.Location = \"/things/\" + input.Body.ID\n//\t\treturn resp, nil\n//\t})\n//\n// This is a convenience wrapper around `huma.Register`.\nfunc Post[I, O any](api API, path string, handler func(context.Context, *I) (*O, error), operationHandlers ...func(o *Operation)) {\n\tconvenience(api, http.MethodPost, path, handler, operationHandlers...)\n}\n\n// Put HTTP operation handler for an API. The handler must be a function that\n// takes a context and a pointer to the input struct and returns a pointer to the\n// output struct and an error. The input struct must be a struct with fields\n// for the request path/query/header/cookie parameters and/or body. The output\n// struct must be a struct with fields for the output headers and body of the\n// operation, if any.\n//\n//\thuma.Put(api, \"/things/{thing-id}\", func(ctx context.Context, input *struct{\n//\t\tID string `path:\"thing-id\"`\n//\t\tBody Thing\n//\t}) (*PutThingOutput, error) {\n//\t\t// TODO: save thing to DB...\n//\t\tresp := &PutThingOutput{}\n//\t\treturn resp, nil\n//\t})\n//\n// This is a convenience wrapper around `huma.Register`.\nfunc Put[I, O any](api API, path string, handler func(context.Context, *I) (*O, error), operationHandlers ...func(o *Operation)) {\n\tconvenience(api, http.MethodPut, path, handler, operationHandlers...)\n}\n\n// Patch HTTP operation handler for an API. The handler must be a function that\n// takes a context and a pointer to the input struct and returns a pointer to the\n// output struct and an error. The input struct must be a struct with fields\n// for the request path/query/header/cookie parameters and/or body. The output\n// struct must be a struct with fields for the output headers and body of the\n// operation, if any.\n//\n//\thuma.Patch(api, \"/things/{thing-id}\", func(ctx context.Context, input *struct{\n//\t\tID string `path:\"thing-id\"`\n//\t\tBody ThingPatch\n//\t}) (*PatchThingOutput, error) {\n//\t\t// TODO: save thing to DB...\n//\t\tresp := &PutThingOutput{}\n//\t\treturn resp, nil\n//\t})\n//\n// This is a convenience wrapper around `huma.Register`.\nfunc Patch[I, O any](api API, path string, handler func(context.Context, *I) (*O, error), operationHandlers ...func(o *Operation)) {\n\tconvenience(api, http.MethodPatch, path, handler, operationHandlers...)\n}\n\n// Delete HTTP operation handler for an API. The handler must be a function that\n// takes a context and a pointer to the input struct and returns a pointer to the\n// output struct and an error. The input struct must be a struct with fields\n// for the request path/query/header/cookie parameters and/or body. The output\n// struct must be a struct with fields for the output headers and body of the\n// operation, if any.\n//\n//\thuma.Delete(api, \"/things/{thing-id}\", func(ctx context.Context, input *struct{\n//\t\tID string `path:\"thing-id\"`\n//\t}) (*struct{}, error) {\n//\t\t// TODO: remove thing from DB...\n//\t\treturn nil, nil\n//\t})\n//\n// This is a convenience wrapper around `huma.Register`.\nfunc Delete[I, O any](api API, path string, handler func(context.Context, *I) (*O, error), operationHandlers ...func(o *Operation)) {\n\tconvenience(api, http.MethodDelete, path, handler, operationHandlers...)\n}\n"
        },
        {
          "name": "huma_test.go",
          "type": "blob",
          "size": 83.5712890625,
          "content": "package huma_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humago\"\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nvar NewExampleAdapter = humatest.NewAdapter\nvar NewExampleAPI = humago.New\n\n// Recoverer is a really simple recovery middleware we can use during tests.\nfunc Recoverer(next http.Handler) http.Handler {\n\tfn := func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tif rvr := recover(); rvr != nil {\n\t\t\t\tfmt.Println(rvr)\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t}\n\t\t}()\n\n\t\tnext.ServeHTTP(w, r)\n\t}\n\n\treturn http.HandlerFunc(fn)\n}\n\n// UUID is a custom type for testing SchemaProvider\ntype UUID struct {\n\tuuid.UUID\n}\n\n// Node is a custom type for testing recursive definition for huma.Register\ntype Node struct {\n\tName  string          `json:\"name\"`\n\tNodes []Node          `json:\"nodes,omitempty\"`\n\tLeft  *Node           `json:\"left,omitempty\"`\n\tNamed map[string]Node `json:\"named,omitempty\"`\n}\n\nfunc (UUID) Schema(r huma.Registry) *huma.Schema {\n\treturn &huma.Schema{Type: huma.TypeString, Format: \"uuid\"}\n}\n\n// BodyContainer is an embed request body struct to test request body unmarshalling\ntype BodyContainer struct {\n\tBody struct {\n\t\tName string `json:\"name\"`\n\t}\n}\n\ntype CustomStringParam string\n\ntype StructWithDefaultField struct {\n\tField string `json:\"field\" default:\"default\"`\n}\n\nfunc TestFeatures(t *testing.T) {\n\tfor _, feature := range []struct {\n\t\tName         string\n\t\tTransformers []huma.Transformer\n\t\tRegister     func(t *testing.T, api huma.API)\n\t\tMethod       string\n\t\tURL          string\n\t\tHeaders      map[string]string\n\t\tBody         string\n\t\tAssert       func(t *testing.T, resp *httptest.ResponseRecorder)\n\t}{\n\t\t{\n\t\t\tName: \"middleware\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\t// Just a do-nothing passthrough. Shows that chaining works.\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\t// Return an error response, never calling the next handler.\n\t\t\t\t\tctx.SetStatus(299)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\t// This should never be called because of the middleware.\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\t// We should get the error response from the middleware.\n\t\t\t\tassert.Equal(t, 299, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"foo\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, \"bar\", cookie.Value)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": \"foo=bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-empty-cookie\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"foo\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": \"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie-only-semicolon\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"foo\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": \";\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-read-no-cookie-in-header\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"foo\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie-invalid-name\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"foo\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": \"=bar;\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie-filter-skip\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"foo\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": \"bar=foo;\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie-parse-double-quote\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"bar\")\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.NotNil(t, cookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": `bar=\"foo\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie-invalid-value-byte-with-semicolon\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"bar\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": `bar=\"fo;o\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-cookie-invalid-value-byte-with-double-backslash\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcookie, err := huma.ReadCookie(ctx, \"bar\")\n\t\t\t\t\tassert.Nil(t, cookie)\n\t\t\t\t\trequire.ErrorIs(t, err, http.ErrNoCookie)\n\n\t\t\t\t\tnext(ctx)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"Cookie\": `bar=\"fo\\\\o\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"middleware-operation\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/middleware\",\n\t\t\t\t\tMiddlewares: huma.Middlewares{\n\t\t\t\t\t\tfunc(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\t\t\t// Just a do-nothing passthrough. Shows that chaining works.\n\t\t\t\t\t\t\tnext(ctx)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunc(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\t\t\t// Return an error response, never calling the next handler.\n\t\t\t\t\t\t\tctx.SetStatus(299)\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\t// This should never be called because of the middleware.\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/middleware\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\t// We should get the error response from the middleware.\n\t\t\t\tassert.Equal(t, 299, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"params\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/test-params/{string}/{int}/{uuid}\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tPathString         string              `path:\"string\" doc:\"Some docs\"`\n\t\t\t\t\tPathInt            int                 `path:\"int\"`\n\t\t\t\t\tPathUUID           UUID                `path:\"uuid\"`\n\t\t\t\t\tQueryString        string              `query:\"string\"`\n\t\t\t\t\tQueryCustomString  CustomStringParam   `query:\"customString\"`\n\t\t\t\t\tQueryInt           int                 `query:\"int\"`\n\t\t\t\t\tQueryDefault       float32             `query:\"def\" default:\"135\" example:\"5\"`\n\t\t\t\t\tQueryBefore        time.Time           `query:\"before\"`\n\t\t\t\t\tQueryDate          time.Time           `query:\"date\" timeFormat:\"2006-01-02\"`\n\t\t\t\t\tQueryURL           url.URL             `query:\"url\"`\n\t\t\t\t\tQueryUint          uint32              `query:\"uint\"`\n\t\t\t\t\tQueryBool          bool                `query:\"bool\"`\n\t\t\t\t\tQueryStrings       []string            `query:\"strings\"`\n\t\t\t\t\tQueryCustomStrings []CustomStringParam `query:\"customStrings\"`\n\t\t\t\t\tQueryInts          []int               `query:\"ints\"`\n\t\t\t\t\tQueryInts8         []int8              `query:\"ints8\"`\n\t\t\t\t\tQueryInts16        []int16             `query:\"ints16\"`\n\t\t\t\t\tQueryInts32        []int32             `query:\"ints32\"`\n\t\t\t\t\tQueryInts64        []int64             `query:\"ints64\"`\n\t\t\t\t\tQueryUints         []uint              `query:\"uints\"`\n\t\t\t\t\t// QueryUints8   []uint8   `query:\"uints8\"`\n\t\t\t\t\tQueryUints16  []uint16    `query:\"uints16\"`\n\t\t\t\t\tQueryUints32  []uint32    `query:\"uints32\"`\n\t\t\t\t\tQueryUints64  []uint64    `query:\"uints64\"`\n\t\t\t\t\tQueryFloats32 []float32   `query:\"floats32\"`\n\t\t\t\t\tQueryFloats64 []float64   `query:\"floats64\"`\n\t\t\t\t\tQueryExploded []string    `query:\"exploded,explode\"`\n\t\t\t\t\tHeaderString  string      `header:\"String\"`\n\t\t\t\t\tHeaderInt     int         `header:\"Int\"`\n\t\t\t\t\tHeaderDate    time.Time   `header:\"Date\"`\n\t\t\t\t\tCookieValue   string      `cookie:\"one\"`\n\t\t\t\t\tCookieInt     int         `cookie:\"two\"`\n\t\t\t\t\tCookieFull    http.Cookie `cookie:\"three\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, \"foo\", input.PathString)\n\t\t\t\t\tassert.Equal(t, 123, input.PathInt)\n\t\t\t\t\tassert.Equal(t, UUID{UUID: uuid.MustParse(\"fba4f46b-4539-4d19-8e3f-a0e629a243b5\")}, input.PathUUID)\n\t\t\t\t\tassert.Equal(t, \"bar\", input.QueryString)\n\t\t\t\t\tassert.Equal(t, CustomStringParam(\"bar\"), input.QueryCustomString)\n\t\t\t\t\tassert.Equal(t, 456, input.QueryInt)\n\t\t\t\t\tassert.InDelta(t, 135, input.QueryDefault, 0)\n\t\t\t\t\tassert.True(t, input.QueryBefore.Equal(time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC)))\n\t\t\t\t\tassert.True(t, input.QueryDate.Equal(time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC)))\n\t\t\t\t\tassert.Equal(t, url.URL{Scheme: \"http\", Host: \"foo.com\", Path: \"/bar\"}, input.QueryURL)\n\t\t\t\t\tassert.EqualValues(t, 1, input.QueryUint)\n\t\t\t\t\tassert.True(t, input.QueryBool)\n\t\t\t\t\tassert.Equal(t, []string{\"foo\", \"bar\"}, input.QueryStrings)\n\t\t\t\t\tassert.Equal(t, []CustomStringParam{\"foo\", \"bar\"}, input.QueryCustomStrings)\n\t\t\t\t\tassert.Equal(t, \"baz\", input.HeaderString)\n\t\t\t\t\tassert.Equal(t, 789, input.HeaderInt)\n\t\t\t\t\tassert.Equal(t, []int{2, 3}, input.QueryInts)\n\t\t\t\t\tassert.Equal(t, []int8{4, 5}, input.QueryInts8)\n\t\t\t\t\tassert.Equal(t, []int16{4, 5}, input.QueryInts16)\n\t\t\t\t\tassert.Equal(t, []int32{4, 5}, input.QueryInts32)\n\t\t\t\t\tassert.Equal(t, []int64{4, 5}, input.QueryInts64)\n\t\t\t\t\tassert.Equal(t, []uint{1, 2}, input.QueryUints)\n\t\t\t\t\tassert.Equal(t, []uint16{10, 15}, input.QueryUints16)\n\t\t\t\t\tassert.Equal(t, []uint32{10, 15}, input.QueryUints32)\n\t\t\t\t\tassert.Equal(t, []uint64{10, 15}, input.QueryUints64)\n\t\t\t\t\tassert.Equal(t, []float32{2.2, 2.3}, input.QueryFloats32)\n\t\t\t\t\tassert.Equal(t, []float64{3.2, 3.3}, input.QueryFloats64)\n\t\t\t\t\tassert.Equal(t, \"foo\", input.CookieValue)\n\t\t\t\t\tassert.Equal(t, 123, input.CookieInt)\n\t\t\t\t\tassert.Equal(t, \"bar\", input.CookieFull.Value)\n\t\t\t\t\tassert.Equal(t, []string{\"foo\", \"bar\"}, input.QueryExploded)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\n\t\t\t\t// Docs should be available on the param object, not just the schema.\n\t\t\t\tassert.Equal(t, \"Some docs\", api.OpenAPI().Paths[\"/test-params/{string}/{int}/{uuid}\"].Get.Parameters[0].Description)\n\n\t\t\t\t// `http.Cookie` should be treated as a string.\n\t\t\t\tassert.Equal(t, \"string\", api.OpenAPI().Paths[\"/test-params/{string}/{int}/{uuid}\"].Get.Parameters[29].Schema.Type)\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/test-params/foo/123/fba4f46b-4539-4d19-8e3f-a0e629a243b5?string=bar&customString=bar&int=456&before=2023-01-01T12:00:00Z&date=2023-01-01&url=http%3A%2F%2Ffoo.com%2Fbar&uint=1&bool=true&strings=foo,bar&customStrings=foo,bar&ints=2,3&ints8=4,5&ints16=4,5&ints32=4,5&ints64=4,5&uints=1,2&uints16=10,15&uints32=10,15&uints64=10,15&floats32=2.2,2.3&floats64=3.2,3.3&exploded=foo&exploded=bar\",\n\t\t\tHeaders: map[string]string{\n\t\t\t\t\"string\": \"baz\",\n\t\t\t\t\"int\":    \"789\",\n\t\t\t\t\"date\":   \"Mon, 01 Jan 2023 12:00:00 GMT\",\n\t\t\t\t\"cookie\": \"one=foo; two=123; three=bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"params-error\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/test-params/{int}/{uuid}\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tPathInt       string    `path:\"int\"`\n\t\t\t\t\tPathUUID      UUID      `path:\"uuid\"`\n\t\t\t\t\tQueryInt      int       `query:\"int\"`\n\t\t\t\t\tQueryFloat    float32   `query:\"float\"`\n\t\t\t\t\tQueryBefore   time.Time `query:\"before\"`\n\t\t\t\t\tQueryDate     time.Time `query:\"date\" timeFormat:\"2006-01-02\"`\n\t\t\t\t\tQueryURL      url.URL   `query:\"url\"`\n\t\t\t\t\tQueryUint     uint32    `query:\"uint\"`\n\t\t\t\t\tQueryBool     bool      `query:\"bool\"`\n\t\t\t\t\tQueryInts     []int     `query:\"ints\"`\n\t\t\t\t\tQueryInts8    []int8    `query:\"ints8\"`\n\t\t\t\t\tQueryInts16   []int16   `query:\"ints16\"`\n\t\t\t\t\tQueryInts32   []int32   `query:\"ints32\"`\n\t\t\t\t\tQueryInts64   []int64   `query:\"ints64\"`\n\t\t\t\t\tQueryUints    []uint    `query:\"uints\"`\n\t\t\t\t\tQueryUints16  []uint16  `query:\"uints16\"`\n\t\t\t\t\tQueryUints32  []uint32  `query:\"uints32\"`\n\t\t\t\t\tQueryUints64  []uint64  `query:\"uints64\"`\n\t\t\t\t\tQueryFloats32 []float32 `query:\"floats32\"`\n\t\t\t\t\tQueryFloats64 []float64 `query:\"floats64\"`\n\t\t\t\t\tQueryReq      bool      `query:\"req\" required:\"true\"`\n\t\t\t\t\tHeaderReq     string    `header:\"req\" required:\"true\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/test-params/bad/not-a-uuid?int=bad&float=bad&before=bad&date=bad&url=:&uint=bad&bool=bad&ints=bad&ints8=bad&ints16=bad&ints32=bad&ints64=bad&uints=bad&uints16=bad&uints32=bad&uints64=bad&floats32=bad&floats64=bad\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusUnprocessableEntity, resp.Code)\n\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"invalid integer\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"invalid value: invalid UUID length: 10\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"invalid float\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"invalid date/time\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"invalid url.URL\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"invalid bool\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"required query parameter is missing\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"required header parameter is missing\")\n\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.ints\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.ints8\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.ints16\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.ints32\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.ints64\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.uints\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.uints16\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.uints32\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.uints64\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.floats32\")\n\t\t\t\tassert.Contains(t, resp.Body.String(), \"query.floats64\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"param-unsupported-500\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/test-params/{ipnet}\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tPathIPNet net.IPNet `path:\"ipnet\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/test-params/255.255.0.0\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusInternalServerError, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"param-bypass-validation\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod:             http.MethodGet,\n\t\t\t\t\tPath:               \"/test\",\n\t\t\t\t\tSkipValidateParams: true,\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tSearch uint `query:\"search\" required:\"true\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\t// ... do custom validation here ...\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/test\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusNoContent, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody []byte\n\t\t\t\t\tBody    struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, `{\"name\":\"foo\"}`, string(input.RawBody))\n\t\t\t\t\tassert.Equal(t, \"foo\", input.Body.Name)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\t// Headers: map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\tBody: `{\"name\":\"foo\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-embed\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Input struct {\n\t\t\t\t\tRawBody []byte\n\t\t\t\t\tBody    struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tInput\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, `{\"name\":\"foo\"}`, string(input.RawBody))\n\t\t\t\t\tassert.Equal(t, \"foo\", input.Body.Name)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"name\":\"foo\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-description\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t\tRequestBody: &huma.RequestBody{\n\t\t\t\t\t\tDescription: \"A description\",\n\t\t\t\t\t},\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, \"foo\", input.Body.Name)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t\t// Note: the description should be set, but *also* the generated\n\t\t\t\t// schema should be present since we didn't set it up ourselves.\n\t\t\t\tb, _ := api.OpenAPI().Paths[\"/body\"].Put.RequestBody.MarshalJSON()\n\t\t\t\tassert.JSONEq(t, `{\n\t\t\t\t\t\"description\": \"A description\",\n\t\t\t\t\t\"required\": true,\n\t\t\t\t\t\"content\": {\n\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\"schema\": {\n\t\t\t\t\t\t\t\t\"$ref\": \"#/components/schemas/Request\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}`, string(b))\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"name\":\"foo\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-nested-struct-readOnly\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype NestedStruct struct {\n\t\t\t\t\tFoo struct {\n\t\t\t\t\t\tBar string `json:\"bar\"`\n\t\t\t\t\t} `json:\"foo\" readOnly:\"true\"`\n\t\t\t\t\tValue string `json:\"value\"`\n\t\t\t\t}\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody *NestedStruct\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"value\":\"test\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-defaults\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\t// Test defaults for primitive types.\n\t\t\t\t\t\tName  string `json:\"name,omitempty\" default:\"Huma\"`\n\t\t\t\t\t\tCount int    `json:\"count,omitempty\" default:\"5\"`\n\t\t\t\t\t\t// Test defaults for slices of primitives.\n\t\t\t\t\t\tTags    []string `json:\"tags,omitempty\" default:\"foo, bar\"`\n\t\t\t\t\t\tNumbers []int    `json:\"numbers,omitempty\" default:\"[1, 2, 3]\"`\n\t\t\t\t\t\t// Test defaults for fields within slices of structs.\n\t\t\t\t\t\tItems []struct {\n\t\t\t\t\t\t\tID       int  `json:\"id\"`\n\t\t\t\t\t\t\tVerified bool `json:\"verified,omitempty\" default:\"true\"`\n\t\t\t\t\t\t} `json:\"items,omitempty\"`\n\t\t\t\t\t\t// Test defaults for fields in the same linked struct. Even though\n\t\t\t\t\t\t// we have seen the struct before we still need to set the default\n\t\t\t\t\t\t// since it's a new/different field.\n\t\t\t\t\t\tS1 StructWithDefaultField `json:\"s1,omitempty\"`\n\t\t\t\t\t\tS2 StructWithDefaultField `json:\"s2,omitempty\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, \"Huma\", input.Body.Name)\n\t\t\t\t\tassert.Equal(t, 5, input.Body.Count)\n\t\t\t\t\tassert.Equal(t, []string{\"foo\", \"bar\"}, input.Body.Tags)\n\t\t\t\t\tassert.Equal(t, []int{1, 2, 3}, input.Body.Numbers)\n\t\t\t\t\tassert.Equal(t, 1, input.Body.Items[0].ID)\n\t\t\t\t\tassert.True(t, input.Body.Items[0].Verified)\n\t\t\t\t\tassert.Equal(t, \"default\", input.Body.S1.Field)\n\t\t\t\t\tassert.Equal(t, \"default\", input.Body.S2.Field)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"items\": [{\"id\": 1}]}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-pointer-defaults\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\t// Test defaults for primitive types.\n\t\t\t\t\t\tName    *string `json:\"name,omitempty\" default:\"Huma\"`\n\t\t\t\t\t\tEnabled *bool   `json:\"enabled,omitempty\" default:\"true\"`\n\t\t\t\t\t\t// Test defaults for slices of primitives.\n\t\t\t\t\t\tTags    []*string `json:\"tags,omitempty\" default:\"foo, bar\"`\n\t\t\t\t\t\tNumbers []*int    `json:\"numbers,omitempty\" default:\"[1, 2, 3]\"`\n\t\t\t\t\t\t// Test defaults for fields within slices of structs.\n\t\t\t\t\t\tItems []*struct {\n\t\t\t\t\t\t\tID       int   `json:\"id\"`\n\t\t\t\t\t\t\tVerified *bool `json:\"verified,omitempty\" default:\"true\"`\n\t\t\t\t\t\t} `json:\"items,omitempty\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.EqualValues(t, \"Huma\", *input.Body.Name)\n\t\t\t\t\tassert.True(t, *input.Body.Enabled)\n\t\t\t\t\tassert.EqualValues(t, []*string{Ptr(\"foo\"), Ptr(\"bar\")}, input.Body.Tags)\n\t\t\t\t\tassert.EqualValues(t, []*int{Ptr(1), Ptr(2), Ptr(3)}, input.Body.Numbers)\n\t\t\t\t\tassert.Equal(t, 1, input.Body.Items[0].ID)\n\t\t\t\t\tassert.True(t, *input.Body.Items[0].Verified)\n\t\t\t\t\tassert.Equal(t, 2, input.Body.Items[1].ID)\n\t\t\t\t\tassert.False(t, *input.Body.Items[1].Verified)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"items\": [{\"id\": 1}, {\"id\": 2, \"verified\": false}]}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-pointer-defaults-set\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\t// Test defaults for primitive types.\n\t\t\t\t\t\tName    *string `json:\"name,omitempty\" default:\"Huma\"`\n\t\t\t\t\t\tEnabled *bool   `json:\"enabled,omitempty\" default:\"true\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\t// Ensure we can send the zero value and it doesn't get overridden.\n\t\t\t\t\tassert.EqualValues(t, \"\", *input.Body.Name)\n\t\t\t\t\tassert.False(t, *input.Body.Enabled)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"name\": \"\", \"enabled\": false}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-required\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusBadRequest, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-nameHint\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t} `nameHint:\"ANameHint\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t\tassert.Equal(t, \"#/components/schemas/ANameHint\", api.OpenAPI().Paths[\"/body\"].Put.RequestBody.Content[\"application/json\"].Schema.Ref)\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"name\": \"Name\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-embed-struct\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBodyContainer\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, \"Name\", input.Body.Name)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   `{\"name\": \"Name\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-ptr-body-required\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody *struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t} `required:\"true\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusBadRequest, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-too-large\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod:       http.MethodPut,\n\t\t\t\t\tPath:         \"/body\",\n\t\t\t\t\tMaxBodyBytes: 1,\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   \"foobarbaz\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusRequestEntityTooLarge, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-bad-json\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/body\",\n\t\t\tBody:   \"{{{\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusBadRequest, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-unsupported-media-type\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/body\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody []byte\n\t\t\t\t\tBody    struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, `{\"name\":\"foo\"}`, string(input.RawBody))\n\t\t\t\t\tassert.Equal(t, \"foo\", input.Body.Name)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPut,\n\t\t\tURL:     \"/body\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"application/foo\"},\n\t\t\tBody:    `abcd`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusUnsupportedMediaType, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-file-upload\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/file\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody []byte `contentType:\"application/foo\"`\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.Equal(t, `some-data`, string(input.RawBody))\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\n\t\t\t\t// Ensure OpenAPI spec is listed as a binary upload. This enables\n\t\t\t\t// generated documentation to show a file upload button.\n\t\t\t\tassert.Equal(t, \"binary\", api.OpenAPI().Paths[\"/file\"].Put.RequestBody.Content[\"application/foo\"].Schema.Format)\n\t\t\t},\n\t\t\tMethod:  http.MethodPut,\n\t\t\tURL:     \"/file\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"application/foo\"},\n\t\t\tBody:    `some-data`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tHelloWorld   huma.FormFile   `form:\"file\" contentType:\"text/plain\" required:\"true\"`\n\t\t\t\t\t\tGreetings    []huma.FormFile `form:\"greetings\" contentType:\"text/plain\" required:\"true\"`\n\t\t\t\t\t\tNoTagBinding huma.FormFile   `contentType:\"text/plain\"`\n\t\t\t\t\t\tUnusedField  string          // Ignored altogether\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfileData := input.RawBody.Data()\n\n\t\t\t\t\tassert.Equal(t, \"text/plain\", fileData.HelloWorld.ContentType)\n\t\t\t\t\tassert.Equal(t, \"test.txt\", fileData.HelloWorld.Filename)\n\t\t\t\t\tassert.Equal(t, len(\"Hello, World!\"), int(fileData.HelloWorld.Size))\n\t\t\t\t\tassert.True(t, fileData.HelloWorld.IsSet)\n\t\t\t\t\tb, err := io.ReadAll(fileData.HelloWorld)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, \"Hello, World!\", string(b))\n\n\t\t\t\t\tassert.Equal(t, \"text/plain\", fileData.NoTagBinding.ContentType)\n\t\t\t\t\tassert.True(t, fileData.NoTagBinding.IsSet)\n\t\t\t\t\tb, err = io.ReadAll(fileData.NoTagBinding)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, `Use struct field name as fallback when no \"form\" tag is provided.`, string(b))\n\n\t\t\t\t\texpected := []string{\"Hello\", \"World\"}\n\t\t\t\t\tfor i, e := range expected {\n\t\t\t\t\t\tassert.Equal(t, \"text/plain\", fileData.Greetings[i].ContentType)\n\t\t\t\t\t\tassert.Equal(t, fmt.Sprintf(\"greetings_%d.txt\", i+1), fileData.Greetings[i].Filename)\n\t\t\t\t\t\tassert.Equal(t, len(e), int(fileData.Greetings[i].Size))\n\t\t\t\t\t\tassert.True(t, fileData.Greetings[i].IsSet)\n\n\t\t\t\t\t\tb, err := io.ReadAll(fileData.Greetings[i])\n\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\tassert.Equal(t, e, string(b))\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\n\t\t\t\t// Ensure OpenAPI spec is listed as a multipart/form-data upload with\n\t\t\t\t// the appropriate schema.\n\t\t\t\tmpContent := api.OpenAPI().Paths[\"/upload\"].Post.RequestBody.Content[\"multipart/form-data\"]\n\t\t\t\tassert.Equal(t, \"text/plain\", mpContent.Encoding[\"file\"].ContentType)\n\t\t\t\tassert.Equal(t, \"text/plain\", mpContent.Encoding[\"greetings\"].ContentType)\n\t\t\t\tassert.Equal(t, \"object\", mpContent.Schema.Type)\n\t\t\t\tassert.Equal(t, \"binary\", mpContent.Schema.Properties[\"file\"].Format)\n\t\t\t\tassert.Equal(t, \"binary\", mpContent.Schema.Properties[\"greetings\"].Items.Format)\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nHello, World!\n--SimpleBoundary\nContent-Disposition: form-data; name=\"greetings\"; filename=\"greetings_1.txt\"\nContent-Type: text/plain\n\nHello\n--SimpleBoundary\nContent-Disposition: form-data; name=\"greetings\"; filename=\"greetings_2.txt\"\nContent-Type: text/plain\n\nWorld\n--SimpleBoundary\nContent-Disposition: form-data; name=\"NoTagBinding\"; filename=\"notag.txt\"\nContent-Type: text/plain\n\nUse struct field name as fallback when no \"form\" tag is provided.\n--SimpleBoundary--`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-required\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tHelloWorld huma.FormFile   `form:\"file\" contentType:\"text/plain\" required:\"true\"`\n\t\t\t\t\t\tSentences  []huma.FormFile `form:\"greetings\" contentType:\"text/plain\" required:\"true\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\n\t\t\t\t// Ensure OpenAPI spec is listed as a multipart/form-data upload with\n\t\t\t\t// the appropriate schema.\n\t\t\t\tmpContent := api.OpenAPI().Paths[\"/upload\"].Post.RequestBody.Content[\"multipart/form-data\"]\n\t\t\t\tassert.Equal(t, \"text/plain\", mpContent.Encoding[\"file\"].ContentType)\n\t\t\t\tassert.Equal(t, \"object\", mpContent.Schema.Type)\n\t\t\t\tassert.Equal(t, \"binary\", mpContent.Schema.Properties[\"file\"].Format)\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"bad_key_name\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nHello, World!\n--SimpleBoundary--`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tif ok := assert.Equal(t, http.StatusUnprocessableEntity, resp.Code); ok {\n\t\t\t\t\tvar errors huma.ErrorModel\n\t\t\t\t\terr := json.Unmarshal(resp.Body.Bytes(), &errors)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, \"file\", errors.Errors[0].Location)\n\t\t\t\t\tassert.Equal(t, \"greetings\", errors.Errors[1].Location)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-optional\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tHelloWorld huma.FormFile `form:\"file\" contentType:\"text/plain\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tassert.False(t, input.RawBody.Data().HelloWorld.IsSet)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody:    `--SimpleBoundary--`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-bad-cardinality\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tHelloWorld huma.FormFile `form:\"file\" contentType:\"text/plain\" required:\"true\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nHello, World!\n--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"text.txt\"\nContent-Type: text/plain\n\nWhat are you doing here ?\n--SimpleBoundary--`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tif ok := assert.Equal(t, http.StatusUnprocessableEntity, resp.Code); ok {\n\t\t\t\t\tvar errors huma.ErrorModel\n\t\t\t\t\terr := json.Unmarshal(resp.Body.Bytes(), &errors)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, \"file\", errors.Errors[0].Location)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-invalid-content-type\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\t// Expecting 'image/png', will receive 'text/plain'\n\t\t\t\t\t\tImage  huma.FormFile   `form:\"file\" contentType:\"image/png\"`\n\t\t\t\t\t\tImages []huma.FormFile `form:\"file\" contentType:\"image/png\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nHello, World!\n--SimpleBoundary--`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tvar errors huma.ErrorModel\n\t\t\t\terr := json.Unmarshal(resp.Body.Bytes(), &errors)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Len(t, errors.Errors, 2) // Both single and multiple file receiver should fail\n\t\t\t\tassert.Equal(t, \"file\", errors.Errors[0].Location)\n\t\t\t\tassert.Equal(t, http.StatusUnprocessableEntity, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-content-type-default\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\t// No contentType tag: default to \"application/octet-stream\"\n\t\t\t\t\t\tImage huma.FormFile `form:\"file\" required:\"true\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfileData := input.RawBody.Data()\n\t\t\t\t\tb, err := io.ReadAll(fileData.Image.File)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, \"console.log('Hello, World!')\", string(b))\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.js\"\nContent-Type: text/javascript\n\nconsole.log('Hello, World!')\n--SimpleBoundary--`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-content-type-wildcard\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tFile huma.FormFile `form:\"file\" contentType:\"text/*\" required:\"true\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfileData := input.RawBody.Data()\n\t\t\t\t\tb, err := io.ReadAll(fileData.File)\n\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\tassert.Equal(t, \"console.log('Hello, World!')\", string(b))\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.js\"\nContent-Type: text/javascript\n\nconsole.log('Hello, World!')\n--SimpleBoundary--`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-image\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tImage huma.FormFile `form:\"file\" contentType:\"image/jpeg,image/png\" required:\"true\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfileData := input.RawBody.Data()\n\t\t\t\t\tassert.Equal(t, \"image/png\", fileData.Image.ContentType)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: func() string {\n\t\t\t\tfile, err := os.Open(\"docs/docs/huma.png\")\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tb, err := io.ReadAll(file)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\treturn fmt.Sprintf(`--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.js\"\nContent-Type: image/png\n\n%s\n--SimpleBoundary--`, string(b))\n\t\t\t}(),\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file-decoded-image-detect-type\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody huma.MultipartFormFiles[struct {\n\t\t\t\t\t\tImage huma.FormFile `form:\"file\" contentType:\"image/jpeg,image/png\" required:\"true\"`\n\t\t\t\t\t}]\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfileData := input.RawBody.Data()\n\t\t\t\t\tassert.Equal(t, \"image/png\", fileData.Image.ContentType)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: func() string {\n\t\t\t\tfile, err := os.Open(\"docs/docs/huma.png\")\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tb, err := io.ReadAll(file)\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\treturn fmt.Sprintf(`--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.js\"\n\n%s\n--SimpleBoundary--`, string(b))\n\t\t\t}(),\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-file\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody multipart.Form\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfor name, fh := range input.RawBody.File {\n\t\t\t\t\t\tfor _, f := range fh {\n\t\t\t\t\t\t\tr, err := f.Open()\n\t\t\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t\t\tb, err := io.ReadAll(r)\n\t\t\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t\t\t_ = r.Close()\n\n\t\t\t\t\t\t\tassert.Equal(t, \"test.txt\", f.Filename)\n\t\t\t\t\t\t\tassert.Equal(t, \"text/plain\", f.Header.Get(\"Content-Type\"))\n\t\t\t\t\t\t\tassert.Equal(t, \"Hello, World!\", string(b))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert.Equal(t, \"file\", name)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\n\t\t\t\t// Ensure OpenAPI spec is listed as a multipart/form-data upload with\n\t\t\t\t// the appropriate schema.\n\t\t\t\tmpContent := api.OpenAPI().Paths[\"/upload\"].Post.RequestBody.Content[\"multipart/form-data\"]\n\t\t\t\tassert.Equal(t, \"object\", mpContent.Schema.Type)\n\t\t\t\tassert.Equal(t, \"binary\", mpContent.Schema.Properties[\"filename\"].Format)\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody: `--SimpleBoundary\nContent-Disposition: form-data; name=\"file\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nHello, World!\n--SimpleBoundary--`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-files\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/upload-files\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody multipart.Form\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\tfor name, fh := range input.RawBody.File {\n\t\t\t\t\t\tfor _, f := range fh {\n\t\t\t\t\t\t\tr, err := f.Open()\n\t\t\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t\t\tb, err := io.ReadAll(r)\n\t\t\t\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\t\t\t\t_ = r.Close()\n\n\t\t\t\t\t\t\t// get the last char of name\n\t\t\t\t\t\t\tindex := name[len(name)-1:]\n\t\t\t\t\t\t\tassert.Equal(t, \"example\"+index+\".txt\", f.Filename)\n\t\t\t\t\t\t\tassert.Equal(t, \"text/plain\", f.Header.Get(\"Content-Type\"))\n\t\t\t\t\t\t\tassert.Equal(t, \"Content of example\"+index+\".txt.\", string(b))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\n\t\t\t\t// Ensure OpenAPI spec is listed as a multipart/form-data upload with\n\t\t\t\t// the appropriate schema.\n\t\t\t\tmpContent := api.OpenAPI().Paths[\"/upload-files\"].Post.RequestBody.Content[\"multipart/form-data\"]\n\t\t\t\tassert.Equal(t, \"object\", mpContent.Schema.Type)\n\t\t\t\tassert.Equal(t, \"binary\", mpContent.Schema.Properties[\"filename\"].Format)\n\t\t\t},\n\t\t\tMethod:  http.MethodPost,\n\t\t\tURL:     \"/upload-files\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=AnotherBoundary\"},\n\t\t\tBody: `--AnotherBoundary\nContent-Disposition: form-data; name=\"file1\"; filename=\"example1.txt\"\nContent-Type: text/plain\n\nContent of example1.txt.\n--AnotherBoundary\nContent-Disposition: form-data; name=\"file2\"; filename=\"example2.txt\"\nContent-Type: text/plain\n\nContent of example2.txt.\n--AnotherBoundary--`,\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-wrong-content-type\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody multipart.Form\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPut,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"wrong/type\"},\n\t\t\tBody:    `some-data`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusUnprocessableEntity, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"request-body-multipart-invalid-data\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/upload\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tRawBody multipart.Form\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod:  http.MethodPut,\n\t\t\tURL:     \"/upload\",\n\t\t\tHeaders: map[string]string{\"Content-Type\": \"multipart/form-data; boundary=SimpleBoundary\"},\n\t\t\tBody:    `invalid`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusUnprocessableEntity, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"handler-error\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/error\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, huma.Error403Forbidden(\"nope\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/error\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusForbidden, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"handler-wrapped-error\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/error\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, fmt.Errorf(\"wrapped: %w\", huma.Error403Forbidden(\"nope\"))\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/error\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusForbidden, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"handler-generic-error\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/error\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, errors.New(\"whoops\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/error\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusInternalServerError, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-headers\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tStr   string    `header:\"str\"`\n\t\t\t\t\tInt   int       `header:\"int\"`\n\t\t\t\t\tUint  uint      `header:\"uint\"`\n\t\t\t\t\tFloat float64   `header:\"float\"`\n\t\t\t\t\tBool  bool      `header:\"bool\"`\n\t\t\t\t\tDate  time.Time `header:\"date\"`\n\t\t\t\t\tEmpty string    `header:\"empty\"`\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response-headers\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.Str = \"str\"\n\t\t\t\t\tresp.Int = 1\n\t\t\t\t\tresp.Uint = 2\n\t\t\t\t\tresp.Float = 3.45\n\t\t\t\t\tresp.Bool = true\n\t\t\t\t\tresp.Date = time.Date(2023, 1, 1, 12, 0, 0, 0, time.UTC)\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response-headers\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusNoContent, resp.Code)\n\t\t\t\tassert.Equal(t, \"str\", resp.Header().Get(\"Str\"))\n\t\t\t\tassert.Equal(t, \"1\", resp.Header().Get(\"Int\"))\n\t\t\t\tassert.Equal(t, \"2\", resp.Header().Get(\"Uint\"))\n\t\t\t\tassert.Equal(t, \"3.45\", resp.Header().Get(\"Float\"))\n\t\t\t\tassert.Equal(t, \"true\", resp.Header().Get(\"Bool\"))\n\t\t\t\tassert.Equal(t, \"Sun, 01 Jan 2023 12:00:00 GMT\", resp.Header().Get(\"Date\"))\n\t\t\t\tassert.Empty(t, resp.Header().Values(\"Empty\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-cookie\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tSetCookie http.Cookie `header:\"Set-Cookie\"`\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response-cookie\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.SetCookie = http.Cookie{\n\t\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\t\tValue: \"bar\",\n\t\t\t\t\t}\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\n\t\t\t\t// `http.Cookie` should be treated as a string.\n\t\t\t\tassert.Equal(t, \"string\", api.OpenAPI().Paths[\"/response-cookie\"].Get.Responses[\"204\"].Headers[\"Set-Cookie\"].Schema.Type)\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response-cookie\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusNoContent, resp.Code)\n\t\t\t\tassert.Equal(t, \"foo=bar\", resp.Header().Get(\"Set-Cookie\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-cookies\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tSetCookie []http.Cookie `header:\"Set-Cookie\"`\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response-cookies\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.SetCookie = []http.Cookie{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"foo\",\n\t\t\t\t\t\t\tValue: \"bar\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"baz\",\n\t\t\t\t\t\t\tValue: \"123\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\n\t\t\t\t// `[]http.Cookie` should be treated as a string.\n\t\t\t\tassert.Equal(t, \"string\", api.OpenAPI().Paths[\"/response-cookies\"].Get.Responses[\"204\"].Headers[\"Set-Cookie\"].Schema.Type)\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response-cookies\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusNoContent, resp.Code)\n\t\t\t\tassert.Equal(t, \"foo=bar\", resp.Header()[\"Set-Cookie\"][0])\n\t\t\t\tassert.Equal(t, \"baz=123\", resp.Header()[\"Set-Cookie\"][1])\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-custom-content-type\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tContentType string `header:\"Content-Type\"`\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response-custom-ct\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.ContentType = \"application/custom-type\"\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response-custom-ct\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusNoContent, resp.Code)\n\t\t\t\tassert.Equal(t, \"application/custom-type\", resp.Header().Get(\"Content-Type\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-body-nameHint\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tGreeting string `json:\"greeting\" `\n\t\t\t\t\t} `nameHint:\"GreetingResp\"`\n\t\t\t\t}\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.Body.Greeting = \"Hello, world!\"\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\t\t\t\tassert.Equal(t, \"#/components/schemas/GreetingResp\", api.OpenAPI().Paths[\"/response\"].Get.Responses[\"200\"].Content[\"application/json\"].Schema.Ref)\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response\",\n\t\t},\n\t\t{\n\t\t\tName: \"response\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tGreeting string `json:\"greeting\"`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.Body.Greeting = \"Hello, world!\"\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.JSONEq(t, `{\"$schema\": \"https:///schemas/RespBody.json\", \"greeting\":\"Hello, world!\"}`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-nil\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tGreeting string `json:\"greeting\"`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\t// This should not panic and should return the default status code,\n\t\t\t\t// which for responses which normally have a body is 200.\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-raw\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tBody []byte\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response-raw\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\treturn &Resp{Body: []byte(\"hello\")}, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response-raw\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.Equal(t, `hello`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-image\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tContentType string `header:\"Content-Type\"`\n\t\t\t\t\tBody        []byte\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response-image\",\n\t\t\t\t\tResponses: map[string]*huma.Response{\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tDescription: \"Image response\",\n\t\t\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\t\t\"image/png\": {\n\t\t\t\t\t\t\t\t\tSchema: &huma.Schema{Type: \"string\", Format: \"binary\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\treturn &Resp{ContentType: \"image/png\", Body: []byte(\"abc\")}, nil\n\t\t\t\t})\n\n\t\t\t\t// Ensure the OpenAPI spec is correct.\n\t\t\t\tassert.Len(t, api.OpenAPI().Paths[\"/response-image\"].Get.Responses[\"200\"].Content, 1)\n\t\t\t\tassert.NotEmpty(t, api.OpenAPI().Paths[\"/response-image\"].Get.Responses[\"200\"].Content[\"image/png\"])\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response-image\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.Equal(t, `abc`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-stream\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/stream\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*huma.StreamResponse, error) {\n\t\t\t\t\treturn &huma.StreamResponse{\n\t\t\t\t\t\tBody: func(ctx huma.Context) {\n\t\t\t\t\t\t\twriter := ctx.BodyWriter()\n\t\t\t\t\t\t\twriter.Write([]byte(\"hel\"))\n\t\t\t\t\t\t\twriter.Write([]byte(\"lo\"))\n\t\t\t\t\t\t},\n\t\t\t\t\t}, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/stream\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.Equal(t, `hello`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-transform-nil-body\",\n\t\t\tTransformers: []huma.Transformer{\n\t\t\t\thuma.NewSchemaLinkTransformer(\"/\", \"/\").Transform,\n\t\t\t},\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Get(api, \"/transform\", func(ctx context.Context, i *struct{}) (*struct {\n\t\t\t\t\tBody *struct {\n\t\t\t\t\t\tField string `json:\"field\"`\n\t\t\t\t\t}\n\t\t\t\t}, error) {\n\t\t\t\t\treturn &struct {\n\t\t\t\t\t\tBody *struct {\n\t\t\t\t\t\t\tField string `json:\"field\"`\n\t\t\t\t\t\t}\n\t\t\t\t\t}{}, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/transform\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-transform-error\",\n\t\t\tTransformers: []huma.Transformer{\n\t\t\t\tfunc(ctx huma.Context, status string, v any) (any, error) {\n\t\t\t\t\treturn nil, http.ErrNotSupported\n\t\t\t\t},\n\t\t\t},\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\tapi.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t\t\t\t\tcalled := false\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\t\t\t// Ensure the error is the one we expect, possibly wrapped with\n\t\t\t\t\t\t\t// additional info.\n\t\t\t\t\t\t\tassert.ErrorIs(t, err.(error), http.ErrNotSupported)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalled = true\n\t\t\t\t\t}()\n\t\t\t\t\tnext(ctx)\n\t\t\t\t\tassert.True(t, called)\n\t\t\t\t})\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{ Body string }, error) {\n\t\t\t\t\treturn &struct{ Body string }{\"foo\"}, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\t// Since the handler completed, this returns a 204, however while\n\t\t\t\t// writing the body there is an error, so that is written as a message\n\t\t\t\t// into the body and dumped via a panic.\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.Equal(t, `error transforming response`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"response-marshal-error\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tGreeting any `json:\"greeting\"`\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/response\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.Body.Greeting = func() {}\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/response\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.Equal(t, `error marshaling response`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"dynamic-status\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\ttype Resp struct {\n\t\t\t\t\tStatus int\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodGet,\n\t\t\t\t\tPath:   \"/status\",\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\t\t\t\tresp := &Resp{}\n\t\t\t\t\tresp.Status = 256\n\t\t\t\t\treturn resp, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/status\",\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, 256, resp.Code)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t// Simulate a request with a body that came from another call, which\n\t\t\t// includes the `$schema` field. It should be allowed to be passed\n\t\t\t// to the new operation as input without modification.\n\t\t\tName: \"round-trip-schema-field\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/round-trip\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody struct {\n\t\t\t\t\t\tName string `json:\"name\"`\n\t\t\t\t\t}\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/round-trip\",\n\t\t\tBody:   `{\"$schema\": \"...\", \"name\": \"foo\"}`,\n\t\t},\n\t\t{\n\t\t\tName: \"recursive schema\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPost,\n\t\t\t\t\tPath:   \"/recursive-schema\",\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\tBody Node\n\t\t\t\t}) (*struct {\n\t\t\t\t\tBody Node\n\t\t\t\t}, error) {\n\t\t\t\t\treturn input, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPost,\n\t\t\tURL:    \"/recursive-schema\",\n\t\t\tBody:   `{\"name\": \"root\", \"nodes\": [{\"name\": \"child\"}], \"left\": {\"name\": \"left\"}, \"named\": {\"child1\": {\"name\": \"child1\"}}}`,\n\t\t\tAssert: func(t *testing.T, resp *httptest.ResponseRecorder) {\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.Code)\n\t\t\t\tassert.JSONEq(t, `{\"name\": \"root\", \"nodes\": [{\"name\": \"child\"}], \"left\": {\"name\": \"left\"}, \"named\": {\"child1\": {\"name\": \"child1\"}}}`, resp.Body.String())\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"one-of input\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\t// Step 1: create a custom schema\n\t\t\t\tcustomSchema := &huma.Schema{\n\t\t\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType: huma.TypeObject,\n\t\t\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\t\t\"foo\": {Type: huma.TypeString},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType: huma.TypeArray,\n\t\t\t\t\t\t\tItems: &huma.Schema{\n\t\t\t\t\t\t\t\tType: huma.TypeObject,\n\t\t\t\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\t\t\t\"foo\": {Type: huma.TypeString},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod: http.MethodPut,\n\t\t\t\t\tPath:   \"/one-of\",\n\t\t\t\t\t// Step 2: register an operation with a custom schema\n\t\t\t\t\tRequestBody: &huma.RequestBody{\n\t\t\t\t\t\tRequired: true,\n\t\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\tSchema: customSchema,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}, func(ctx context.Context, input *struct {\n\t\t\t\t\t// Step 3: only take in raw bytes\n\t\t\t\t\tRawBody []byte\n\t\t\t\t}) (*struct{}, error) {\n\t\t\t\t\t// Step 4: determine which it is and parse it into the right type.\n\t\t\t\t\t// We will check the first byte but there are other ways to do this.\n\t\t\t\t\tassert.EqualValues(t, '[', input.RawBody[0])\n\t\t\t\t\tvar parsed []struct {\n\t\t\t\t\t\tFoo string `json:\"foo\"`\n\t\t\t\t\t}\n\t\t\t\t\trequire.NoError(t, json.Unmarshal(input.RawBody, &parsed))\n\t\t\t\t\tassert.Len(t, parsed, 2)\n\t\t\t\t\tassert.Equal(t, \"first\", parsed[0].Foo)\n\t\t\t\t\tassert.Equal(t, \"second\", parsed[1].Foo)\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t},\n\t\t\tMethod: http.MethodPut,\n\t\t\tURL:    \"/one-of\",\n\t\t\tBody:   `[{\"foo\": \"first\"}, {\"foo\": \"second\"}]`,\n\t\t},\n\t\t{\n\t\t\tName: \"security-override-public\",\n\t\t\tRegister: func(t *testing.T, api huma.API) {\n\t\t\t\thuma.Register(api, huma.Operation{\n\t\t\t\t\tMethod:   http.MethodGet,\n\t\t\t\t\tPath:     \"/public\",\n\t\t\t\t\tSecurity: []map[string][]string{}, // No security for this call!\n\t\t\t\t}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t})\n\t\t\t\t// Note: the empty security object should be serialized as an empty\n\t\t\t\t// array in the OpenAPI document.\n\t\t\t\tb, _ := api.OpenAPI().Paths[\"/public\"].Get.MarshalJSON()\n\t\t\t\tassert.Contains(t, string(b), `\"security\":[]`)\n\t\t\t},\n\t\t\tMethod: http.MethodGet,\n\t\t\tURL:    \"/public\",\n\t\t},\n\t} {\n\t\tt.Run(feature.Name, func(t *testing.T) {\n\t\t\tr := http.NewServeMux()\n\t\t\tconfig := huma.DefaultConfig(\"Features Test API\", \"1.0.0\")\n\t\t\tif feature.Transformers != nil {\n\t\t\t\tconfig.Transformers = append(config.Transformers, feature.Transformers...)\n\t\t\t}\n\t\t\tapi := humatest.Wrap(t, humago.New(r, config))\n\t\t\tfeature.Register(t, api)\n\n\t\t\tvar body io.Reader = nil\n\t\t\tif feature.Body != \"\" {\n\t\t\t\tbody = strings.NewReader(feature.Body)\n\t\t\t}\n\t\t\treq, _ := http.NewRequest(feature.Method, feature.URL, body)\n\t\t\tfor k, v := range feature.Headers {\n\t\t\t\treq.Header.Set(k, v)\n\t\t\t}\n\t\t\tw := httptest.NewRecorder()\n\t\t\tRecoverer(r).ServeHTTP(w, req)\n\t\t\tb, _ := api.OpenAPI().YAML()\n\t\t\tt.Log(string(b))\n\t\t\tb, _ = httputil.DumpResponse(w.Result(), true)\n\t\t\tt.Log(string(b))\n\t\t\tif feature.Assert != nil {\n\t\t\t\tfeature.Assert(t, w)\n\t\t\t} else {\n\t\t\t\tcn := w.Body.String()\n\t\t\t\tassert.Less(t, w.Code, 300, cn)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpenAPI(t *testing.T) {\n\tr, api := humatest.New(t, huma.DefaultConfig(\"Features Test API\", \"1.0.0\"))\n\n\t// Used to validate exclusion of embedded structs from response headers\n\ttype PaginationHeaders struct {\n\t\tLink string `header:\"link\"`\n\t}\n\n\ttype Resp struct {\n\t\tPaginationHeaders\n\t\tBody struct {\n\t\t\tGreeting string `json:\"greeting\"`\n\t\t}\n\t}\n\n\thuma.Register(api, huma.Operation{\n\t\tMethod: http.MethodGet,\n\t\tPath:   \"/test\",\n\t}, func(ctx context.Context, input *struct{}) (*Resp, error) {\n\t\tresp := &Resp{}\n\t\tresp.Body.Greeting = \"Hello, world\"\n\t\treturn resp, nil\n\t})\n\n\tfor _, url := range []string{\n\t\t\"/openapi.json\",\n\t\t\"/openapi-3.0.json\",\n\t\t\"/openapi.yaml\",\n\t\t\"/openapi-3.0.yaml\",\n\t\t\"/docs\",\n\t\t\"/schemas/RespBody.json\",\n\t} {\n\t\treq, _ := http.NewRequest(http.MethodGet, url, nil)\n\t\tw := httptest.NewRecorder()\n\t\tr.ServeHTTP(w, req)\n\n\t\tassert.Equal(t, 200, w.Code, w.Body.String())\n\t}\n\n\tt.Run(\"ignore-anonymous-header-structs\", func(t *testing.T) {\n\t\treq, _ := http.NewRequest(http.MethodGet, \"/openapi.yaml\", nil)\n\t\tw := httptest.NewRecorder()\n\t\tr.ServeHTTP(w, req)\n\n\t\topenapiBody := w.Body.String()\n\t\tassert.Equal(t, 200, w.Code, openapiBody)\n\t\tassert.Contains(t, openapiBody, \"link\")\n\t\tassert.NotContains(t, openapiBody, \"PaginationHeaders\")\n\t})\n}\n\ntype CTFilterBody struct {\n\tField string `json:\"field\"`\n}\n\nfunc (b *CTFilterBody) ContentType(ct string) string {\n\treturn \"application/custom+json\"\n}\n\nvar _ huma.ContentTypeFilter = (*CTFilterBody)(nil)\n\nfunc TestContentTypeFilter(t *testing.T) {\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Get(api, \"/ct-filter\", func(ctx context.Context, i *struct{}) (*struct {\n\t\tBody CTFilterBody\n\t}, error) {\n\t\treturn nil, nil\n\t})\n\n\tresponses := api.OpenAPI().Paths[\"/ct-filter\"].Get.Responses[\"200\"].Content\n\tassert.Len(t, responses, 1)\n\tfor k := range responses {\n\t\tassert.Equal(t, \"application/custom+json\", k)\n\t}\n}\n\ntype IntNot3 int\n\nfunc (i IntNot3) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\tif i != 0 && i%3 == 0 {\n\t\treturn []error{&huma.ErrorDetail{\n\t\t\tLocation: prefix.String(),\n\t\t\tMessage:  \"Value cannot be a multiple of three\",\n\t\t\tValue:    i,\n\t\t}}\n\t}\n\treturn nil\n}\n\nvar _ huma.ResolverWithPath = (*IntNot3)(nil)\n\ntype ExhaustiveErrorsInputBody struct {\n\tName  string  `json:\"name\" maxLength:\"10\"`\n\tCount IntNot3 `json:\"count\" minimum:\"1\"`\n\n\t// Having a pointer which is never loaded should not cause\n\t// the tests to fail when running resolvers.\n\tPtr *IntNot3 `json:\"ptr,omitempty\" minimum:\"1\"`\n}\n\nfunc (b *ExhaustiveErrorsInputBody) Resolve(ctx huma.Context) []error {\n\treturn []error{errors.New(\"body resolver error\")}\n}\n\ntype ExhaustiveErrorsInput struct {\n\tID     IntNot3                   `path:\"id\" maximum:\"10\"`\n\tQuery  IntNot3                   `query:\"query\"`\n\tHeader IntNot3                   `header:\"header\"`\n\tBody   ExhaustiveErrorsInputBody `json:\"body\"`\n}\n\nfunc (i *ExhaustiveErrorsInput) Resolve(ctx huma.Context) []error {\n\treturn []error{&huma.ErrorDetail{\n\t\tLocation: \"path.id\",\n\t\tMessage:  \"input resolver error\",\n\t\tValue:    i.ID,\n\t}}\n}\n\nvar _ huma.Resolver = (*ExhaustiveErrorsInput)(nil)\n\nfunc TestExhaustiveErrors(t *testing.T) {\n\tr, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Register(app, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodPut,\n\t\tPath:        \"/errors/{id}\",\n\t}, func(ctx context.Context, input *ExhaustiveErrorsInput) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\treq, _ := http.NewRequest(http.MethodPut, \"/errors/15?query=3\", strings.NewReader(`{\"name\": \"12345678901\", \"count\": -6}`))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\treq.Header.Set(\"Header\", \"3\")\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\tassert.Equal(t, http.StatusUnprocessableEntity, w.Code)\n\tassert.JSONEq(t, `{\n\t\t\"$schema\": \"https:///schemas/ErrorModel.json\",\n\t\t\"title\": \"Unprocessable Entity\",\n\t\t\"status\": 422,\n\t\t\"detail\": \"validation failed\",\n\t\t\"errors\": [\n\t\t\t{\n\t\t\t\t\"message\": \"expected number <= 10\",\n\t\t\t\t\"location\": \"path.id\",\n\t\t\t\t\"value\": 15\n\t\t\t}, {\n\t\t\t\t\"message\": \"expected number >= 1\",\n\t\t\t\t\"location\": \"body.count\",\n\t\t\t\t\"value\": -6\n\t\t\t}, {\n\t\t\t\t\"message\": \"expected length <= 10\",\n\t\t\t\t\"location\": \"body.name\",\n\t\t\t\t\"value\": \"12345678901\"\n\t\t\t}, {\n\t\t\t\t\"message\": \"input resolver error\",\n\t\t\t\t\"location\": \"path.id\",\n\t\t\t\t\"value\": 15\n\t\t\t}, {\n\t\t\t\t\"message\": \"Value cannot be a multiple of three\",\n\t\t\t\t\"location\": \"path.id\",\n\t\t\t\t\"value\": 15\n\t\t\t}, {\n\t\t\t\t\"message\": \"Value cannot be a multiple of three\",\n\t\t\t\t\"location\": \"query.query\",\n\t\t\t\t\"value\": 3\n\t\t\t}, {\n\t\t\t\t\"message\": \"Value cannot be a multiple of three\",\n\t\t\t\t\"location\": \"header.header\",\n\t\t\t\t\"value\": 3\n\t\t\t}, {\n\t\t\t\t\"message\": \"body resolver error\"\n\t\t\t}, {\n\t\t\t\t\"message\": \"Value cannot be a multiple of three\",\n\t\t\t\t\"location\": \"body.count\",\n\t\t\t\t\"value\": -6\n\t\t\t}\n\t\t]\n\t}`, w.Body.String())\n}\n\ntype MyError struct {\n\tstatus  int\n\tMessage string   `json:\"message\"`\n\tDetails []string `json:\"details\"`\n}\n\nfunc (e *MyError) Error() string {\n\treturn e.Message\n}\n\nfunc (e *MyError) GetStatus() int {\n\treturn e.status\n}\n\nfunc TestCustomError(t *testing.T) {\n\torig := huma.NewError\n\tdefer func() {\n\t\thuma.NewError = orig\n\t}()\n\thuma.NewError = func(status int, message string, errs ...error) huma.StatusError {\n\t\tdetails := make([]string, len(errs))\n\t\tfor i, err := range errs {\n\t\t\tdetails[i] = err.Error()\n\t\t}\n\t\treturn &MyError{\n\t\t\tstatus:  status,\n\t\t\tMessage: message,\n\t\t\tDetails: details,\n\t\t}\n\t}\n\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-error\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/error\",\n\t}, func(ctx context.Context, i *struct{}) (*struct{}, error) {\n\t\treturn nil, huma.Error404NotFound(\"not found\", errors.New(\"some-other-error\"))\n\t})\n\n\tresp := api.Get(\"/error\", \"Host: localhost\")\n\tassert.Equal(t, `{\"$schema\":\"http://localhost/schemas/MyError.json\",\"message\":\"not found\",\"details\":[\"some-other-error\"]}`+\"\\n\", resp.Body.String())\n}\n\ntype BrokenWriter struct {\n\thttp.ResponseWriter\n}\n\nfunc (br *BrokenWriter) Write(p []byte) (n int, err error) {\n\treturn 0, errors.New(\"failed writing\")\n}\n\nfunc TestClientDisconnect(t *testing.T) {\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\thuma.Get(api, \"/error\", func(ctx context.Context, i *struct{}) (*struct {\n\t\tBody string\n\t}, error) {\n\t\treturn &struct{ Body string }{Body: \"test\"}, nil\n\t})\n\n\t// Create and immediately cancel the context. This simulates a client\n\t// that has disconnected.\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\treq, _ := http.NewRequestWithContext(ctx, http.MethodGet, \"/error\", nil)\n\n\t// Also make the response writer fail when writing.\n\trecorder := httptest.NewRecorder()\n\tresp := &BrokenWriter{recorder}\n\n\t// We do not want any panics as this is not a real error.\n\tassert.NotPanics(t, func() {\n\t\tapi.Adapter().ServeHTTP(resp, req)\n\t})\n}\n\ntype NestedResolversStruct struct {\n\tField2 string `json:\"field2\"`\n}\n\nfunc (b *NestedResolversStruct) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\treturn []error{&huma.ErrorDetail{\n\t\tLocation: prefix.With(\"field2\"),\n\t\tMessage:  \"resolver error\",\n\t\tValue:    b.Field2,\n\t}}\n}\n\nvar _ huma.ResolverWithPath = (*NestedResolversStruct)(nil)\n\ntype NestedResolversBody struct {\n\tField1 map[string][]NestedResolversStruct `json:\"field1\"`\n}\n\ntype NestedResolverRequest struct {\n\tBody NestedResolversBody\n}\n\nfunc TestNestedResolverWithPath(t *testing.T) {\n\tr, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Register(app, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodPut,\n\t\tPath:        \"/test\",\n\t}, func(ctx context.Context, input *NestedResolverRequest) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\treq, _ := http.NewRequest(http.MethodPut, \"/test\", strings.NewReader(`{\"field1\": {\"foo\": [{\"field2\": \"bar\"}]}}`))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\tassert.Equal(t, http.StatusUnprocessableEntity, w.Code, w.Body.String())\n\tassert.Contains(t, w.Body.String(), `\"location\":\"body.field1.foo[0].field2\"`)\n}\n\ntype ResolverCustomStatus struct{}\n\nfunc (r *ResolverCustomStatus) Resolve(ctx huma.Context) []error {\n\treturn []error{huma.Error403Forbidden(\"nope\")}\n}\n\nfunc TestResolverCustomStatus(t *testing.T) {\n\tr, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Register(app, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodPut,\n\t\tPath:        \"/test\",\n\t}, func(ctx context.Context, input *ResolverCustomStatus) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\treq, _ := http.NewRequest(http.MethodPut, \"/test\", strings.NewReader(`{}`))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\tassert.Equal(t, http.StatusForbidden, w.Code, w.Body.String())\n\tassert.Contains(t, w.Body.String(), \"nope\")\n}\n\ntype ResolverCalls struct {\n\tCalls int\n}\n\nfunc (r *ResolverCalls) Resolve(ctx huma.Context) []error {\n\tr.Calls++\n\treturn nil\n}\n\nfunc TestResolverCompositionCalledOnce(t *testing.T) {\n\tr, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Register(app, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodPut,\n\t\tPath:        \"/test\",\n\t}, func(ctx context.Context, input *struct {\n\t\tResolverCalls\n\t}) (*struct{}, error) {\n\t\t// Exactly one call should have been made to the resolver.\n\t\tassert.Equal(t, 1, input.Calls)\n\t\treturn nil, nil\n\t})\n\n\treq, _ := http.NewRequest(http.MethodPut, \"/test\", strings.NewReader(`{}`))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\tassert.Equal(t, http.StatusNoContent, w.Code, w.Body.String())\n}\n\ntype ResolverWithPointer struct {\n\tPtr *string\n}\n\nfunc (r *ResolverWithPointer) Resolve(ctx huma.Context) []error {\n\tr.Ptr = new(string)\n\t*r.Ptr = \"String\"\n\treturn nil\n}\n\nfunc TestResolverWithPointer(t *testing.T) {\n\t// Allow using pointers in input structs if they are not path/query/header/cookie parameters\n\tr, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Register(app, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodPut,\n\t\tPath:        \"/test\",\n\t}, func(ctx context.Context, input *struct {\n\t\tResolverWithPointer\n\t}) (*struct{}, error) {\n\t\t// Exactly one call should have been made to the resolver.\n\t\tassert.Equal(t, \"String\", *input.Ptr)\n\t\treturn nil, nil\n\t})\n\n\treq, _ := http.NewRequest(http.MethodPut, \"/test\", strings.NewReader(`{}`))\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\tassert.Equal(t, http.StatusNoContent, w.Code, w.Body.String())\n}\n\nfunc TestParamPointerPanics(t *testing.T) {\n\t// For now, we don't support these, so we panic rather than have subtle\n\t// bugs that are hard to track down.\n\t_, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\tassert.Panics(t, func() {\n\t\thuma.Register(app, huma.Operation{\n\t\t\tOperationID: \"bug\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/bug\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tParam *string `query:\"param\"`\n\t\t}) (*struct{}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\t})\n}\n\nfunc TestPointerDefaultPanics(t *testing.T) {\n\t// For now, we don't support these, so we panic rather than have subtle\n\t// bugs that are hard to track down.\n\t_, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\tassert.Panics(t, func() {\n\t\thuma.Register(app, huma.Operation{\n\t\t\tOperationID: \"bug\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/bug\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tBody struct {\n\t\t\t\tValue *struct {\n\t\t\t\t\tField string `json:\"field\"`\n\t\t\t\t} `json:\"value,omitempty\" default:\"{}\"`\n\t\t\t}\n\t\t}) (*struct{}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\t})\n}\n\nfunc TestConvenienceMethods(t *testing.T) {\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\tpath := \"/things\"\n\ttype Input struct {\n\t\tOwner string `path:\"owner\"`\n\t\tRepo  string `path:\"repo\"`\n\t}\n\n\thuma.Get(api, path, func(ctx context.Context, input *Input) (*struct {\n\t\tBody []struct{}\n\t}, error) {\n\t\treturn nil, nil\n\t}, huma.OperationTags(\"Things\"))\n\tassert.Equal(t, \"list-things\", api.OpenAPI().Paths[path].Get.OperationID)\n\tassert.Equal(t, []string{\"Things\"}, api.OpenAPI().Paths[path].Get.Tags)\n\n\thuma.Post(api, path, func(ctx context.Context, input *Input) (*struct{}, error) {\n\t\treturn nil, nil\n\t}, huma.OperationTags(\"Things\"))\n\tassert.Equal(t, \"post-things\", api.OpenAPI().Paths[path].Post.OperationID)\n\tassert.Equal(t, []string{\"Things\"}, api.OpenAPI().Paths[path].Post.Tags)\n\n\tpath = path + \"/{thing-id}\"\n\thuma.Put(api, path, func(ctx context.Context, input *Input) (*struct{}, error) {\n\t\treturn nil, nil\n\t}, huma.OperationTags(\"Things\"))\n\tassert.Equal(t, \"put-things-by-thing-id\", api.OpenAPI().Paths[path].Put.OperationID)\n\tassert.Equal(t, []string{\"Things\"}, api.OpenAPI().Paths[path].Put.Tags)\n\n\thuma.Patch(api, path, func(ctx context.Context, input *Input) (*struct{}, error) {\n\t\treturn nil, nil\n\t}, huma.OperationTags(\"Things\"))\n\tassert.Equal(t, \"patch-things-by-thing-id\", api.OpenAPI().Paths[path].Patch.OperationID)\n\tassert.Equal(t, []string{\"Things\"}, api.OpenAPI().Paths[path].Patch.Tags)\n\n\thuma.Delete(api, path, func(ctx context.Context, input *Input) (*struct{}, error) {\n\t\treturn nil, nil\n\t}, huma.OperationTags(\"Things\"))\n\tassert.Equal(t, \"delete-things-by-thing-id\", api.OpenAPI().Paths[path].Delete.OperationID)\n\tassert.Equal(t, []string{\"Things\"}, api.OpenAPI().Paths[path].Delete.Tags)\n}\n\ntype EmbeddedWithMethod struct{}\n\nfunc (e EmbeddedWithMethod) Method() {}\n\nfunc TestUnsupportedEmbeddedTypeWithMethods(t *testing.T) {\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\t// Should not panic!\n\thuma.Post(api, \"/things\", func(ctx context.Context, input *struct{}) (*struct {\n\t\tBody struct {\n\t\t\tEmbeddedWithMethod\n\t\t}\n\t}, error) {\n\t\treturn nil, nil\n\t})\n}\n\ntype SchemaWithExample int\n\nfunc (*SchemaWithExample) Schema(r huma.Registry) *huma.Schema {\n\tschema := &huma.Schema{\n\t\tType:     huma.TypeInteger,\n\t\tExamples: []any{1},\n\t}\n\treturn schema\n}\n\nfunc TestSchemaWithExample(t *testing.T) {\n\t_, app := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Register(app, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/test\",\n\t}, func(ctx context.Context, input *struct {\n\t\tTest SchemaWithExample `query:\"test\"`\n\t}) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\texample := app.OpenAPI().Paths[\"/test\"].Get.Parameters[0].Example\n\tassert.Equal(t, 1, example)\n}\n\nfunc TestCustomSchemaErrors(t *testing.T) {\n\t// Ensure that custom schema errors are correctly reported without having\n\t// to manually call `schema.PrecomputeMessages()`.\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"test\",\n\t\tMethod:      http.MethodPost,\n\t\tPath:        \"/test\",\n\t\tRequestBody: &huma.RequestBody{\n\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\"application/json\": {\n\t\t\t\t\tSchema: &huma.Schema{\n\t\t\t\t\t\tType:                 huma.TypeObject,\n\t\t\t\t\t\tRequired:             []string{\"test\"},\n\t\t\t\t\t\tAdditionalProperties: false,\n\t\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\t\"test\": {\n\t\t\t\t\t\t\t\tType:    huma.TypeInteger,\n\t\t\t\t\t\t\t\tMinimum: Ptr(10.0),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, func(ctx context.Context, input *struct {\n\t\tRawBody []byte\n\t}) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\tresp := api.Post(\"/test\", map[string]any{\"test\": 1})\n\n\tassert.Equal(t, http.StatusUnprocessableEntity, resp.Result().StatusCode)\n\tassert.Contains(t, resp.Body.String(), `expected number \\u003e= 10`)\n}\n\nfunc TestBodyRace(t *testing.T) {\n\t// Run with the following:\n\t// go test -run=TestBodyRace -race -parallel=100\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Post(api, \"/ping\", func(ctx context.Context, input *struct {\n\t\tBody struct {\n\t\t\tValue string `json:\"value\"`\n\t\t}\n\t\tRawBody []byte\n\t}) (*struct{}, error) {\n\t\t// Access/modify the raw input to detect races.\n\t\tinput.RawBody[1] = 'a'\n\t\treturn nil, nil\n\t})\n\n\tfor i := 0; i < 100; i++ {\n\t\tt.Run(fmt.Sprintf(\"test-%d\", i), func(tt *testing.T) {\n\t\t\ttt.Parallel()\n\t\t\tresp := api.Post(\"/ping\", map[string]any{\"value\": \"hello\"})\n\t\t\tassert.Equal(tt, 204, resp.Result().StatusCode)\n\t\t})\n\t}\n}\n\ntype CustomMapValue string\n\nfunc (v *CustomMapValue) Resolve(ctx huma.Context) []error {\n\treturn nil\n}\n\nfunc TestResolverCustomTypePrimitive(t *testing.T) {\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Post(api, \"/test\", func(ctx context.Context, input *struct {\n\t\tBody struct {\n\t\t\tTags map[string]CustomMapValue `json:\"tags\"`\n\t\t}\n\t}) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\tassert.NotPanics(t, func() {\n\t\tapi.Post(\"/test\", map[string]any{\"tags\": map[string]string{\"foo\": \"bar\"}})\n\t})\n}\n\nfunc TestCustomValidationErrorStatus(t *testing.T) {\n\torig := huma.NewError\n\thuma.NewError = func(status int, message string, errs ...error) huma.StatusError {\n\t\tif status == 422 {\n\t\t\tstatus = 400\n\t\t}\n\t\treturn orig(status, message, errs...)\n\t}\n\tt.Cleanup(func() {\n\t\thuma.NewError = orig\n\t})\n\n\t_, api := humatest.New(t, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\thuma.Post(api, \"/test\", func(ctx context.Context, input *struct {\n\t\tBody struct {\n\t\t\tValue string `json:\"value\" minLength:\"5\"`\n\t\t}\n\t}) (*struct{}, error) {\n\t\treturn nil, nil\n\t})\n\n\tresp := api.Post(\"/test\", map[string]any{\"value\": \"foo\"})\n\tassert.Equal(t, http.StatusBadRequest, resp.Result().StatusCode)\n\tassert.Contains(t, resp.Body.String(), \"Bad Request\")\n}\n\n// func BenchmarkSecondDecode(b *testing.B) {\n// \t//nolint: musttag\n// \ttype MediumSized struct {\n// \t\tID   int      `json:\"id\"`\n// \t\tName string   `json:\"name\"`\n// \t\tTags []string `json:\"tags\"`\n// \t\t// Created time.Time `json:\"created\"`\n// \t\t// Updated time.Time `json:\"updated\"`\n// \t\tRating float64 `json:\"rating\"`\n// \t\tOwner  struct {\n// \t\t\tID    int    `json:\"id\"`\n// \t\t\tName  string `json:\"name\"`\n// \t\t\tEmail string `json:\"email\"`\n// \t\t} `json:\"owner\"`\n// \t\tCategories []struct {\n// \t\t\tName    string   `json:\"name\"`\n// \t\t\tOrder   int      `json:\"order\"`\n// \t\t\tVisible bool     `json:\"visible\"`\n// \t\t\tAliases []string `json:\"aliases\"`\n// \t\t} `json:\"categories\"`\n// \t}\n\n// \tdata := []byte(`{\n// \t\t\"id\": 123,\n// \t\t\"name\": \"Test\",\n// \t\t\"tags\": [\"one\", \"two\", \"three\"],\n// \t\t\"created\": \"2021-01-01T12:00:00Z\",\n// \t\t\"updated\": \"2021-01-01T12:00:00Z\",\n// \t\t\"rating\": 5.0,\n// \t\t\"owner\": {\n// \t\t\t\"id\": 4,\n// \t\t\t\"name\": \"Alice\",\n// \t\t\t\"email\": \"alice@example.com\"\n// \t\t},\n// \t\t\"categories\": [\n// \t\t\t{\n// \t\t\t\t\"name\": \"First\",\n// \t\t\t\t\"order\": 1,\n// \t\t\t\t\"visible\": true\n// \t\t\t},\n// \t\t\t{\n// \t\t\t\t\"name\": \"Second\",\n// \t\t\t\t\"order\": 2,\n// \t\t\t\t\"visible\": false,\n// \t\t\t\t\"aliases\": [\"foo\", \"bar\"]\n// \t\t\t}\n// \t\t]\n// \t}`)\n\n// \tpb := huma.NewPathBuffer([]byte{}, 0)\n// \tres := &huma.ValidateResult{}\n// \tregistry := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n// \tfmt.Println(\"name\", reflect.TypeOf(MediumSized{}).Name())\n// \tschema := registry.Schema(reflect.TypeOf(MediumSized{}), false, \"\")\n\n// \tb.Run(\"json.Unmarshal\", func(b *testing.B) {\n// \t\tb.ReportAllocs()\n// \t\tfor i := 0; i < b.N; i++ {\n// \t\t\tvar tmp any\n// \t\t\tif err := json.Unmarshal(data, &tmp); err != nil {\n// \t\t\t\tpanic(err)\n// \t\t\t}\n\n// \t\t\thuma.Validate(registry, schema, pb, huma.ModeReadFromServer, tmp, res)\n\n// \t\t\tvar out MediumSized\n// \t\t\tif err := json.Unmarshal(data, &out); err != nil {\n// \t\t\t\tpanic(err)\n// \t\t\t}\n// \t\t}\n// \t})\n\n// \tb.Run(\"mapstructure.Decode\", func(b *testing.B) {\n// \t\tb.ReportAllocs()\n// \t\tfor i := 0; i < b.N; i++ {\n// \t\t\tvar tmp any\n// \t\t\tif err := json.Unmarshal(data, &tmp); err != nil {\n// \t\t\t\tpanic(err)\n// \t\t\t}\n\n// \t\t\thuma.Validate(registry, schema, pb, huma.ModeReadFromServer, tmp, res)\n\n// \t\t\tvar out MediumSized\n// \t\t\tif err := mapstructure.Decode(tmp, &out); err != nil {\n// \t\t\t\tpanic(err)\n// \t\t\t}\n// \t\t}\n// \t})\n// }\n\nfunc globalHandler(ctx context.Context, input *struct {\n\tCount int `query:\"count\"`\n}) (*struct{ Body int }, error) {\n\treturn &struct{ Body int }{Body: input.Count * 3 / 2}, nil\n}\n\nvar BenchmarkHandlerResponse *httptest.ResponseRecorder\n\n// BenchmarkHandlerFunc compares the performance of a global handler function\n// defined via `func name(...) { ... }` versus an inline handler function\n// which is defined as `func(...) { ... }` as an argument to `huma.Register`.\n// Performance should not be impacted much (if any) between the two.\nfunc BenchmarkHandlerFunc(b *testing.B) {\n\t_, api := humatest.New(b, huma.DefaultConfig(\"Test API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"global\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/global\",\n\t}, globalHandler)\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"inline\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/inline\",\n\t}, func(ctx context.Context, input *struct {\n\t\tCount int `query:\"count\"`\n\t}) (*struct{ Body int }, error) {\n\t\treturn &struct{ Body int }{Body: input.Count * 3 / 2}, nil\n\t})\n\n\tb.Run(\"global\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tBenchmarkHandlerResponse = api.Get(\"/global\")\n\t\t}\n\t})\n\n\tb.Run(\"inline\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tBenchmarkHandlerResponse = api.Get(\"/inline\")\n\t\t}\n\t})\n}\n\nfunc TestGenerateFuncsPanicWithDescriptiveMessage(t *testing.T) {\n\tvar resp *int\n\tassert.PanicsWithValue(t, \"Response type must be a struct\", func() {\n\t\thuma.GenerateOperationID(\"GET\", \"/foo\", resp)\n\t})\n\n\tassert.PanicsWithValue(t, \"Response type must be a struct\", func() {\n\t\thuma.GenerateSummary(\"GET\", \"/foo\", resp)\n\t})\n\n}\n"
        },
        {
          "name": "humacli",
          "type": "tree",
          "content": null
        },
        {
          "name": "humatest",
          "type": "tree",
          "content": null
        },
        {
          "name": "negotiation",
          "type": "tree",
          "content": null
        },
        {
          "name": "openapi.go",
          "type": "blob",
          "size": 59.76953125,
          "content": "package huma\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2/yaml\"\n)\n\ntype omitType int\n\nconst (\n\t// omitNever means the field will always be included.\n\tomitNever omitType = iota\n\n\t// omitEmpty means the field will be omitted if it is empty.\n\tomitEmpty\n\n\t// omitNil means the field will be omitted if it is nil. This is used for\n\t// fields which are `any` and may be the zero value of the type.\n\tomitNil\n)\n\ntype jsonFieldInfo struct {\n\tname  string\n\tvalue any\n\tomit  omitType\n}\n\n// isEmptyValue returns true if the given value is empty. This is a copy of\n// isEmptyValue from encoding/json to help determine when to write a field\n// with `omitempty` set.\nfunc isEmptyValue(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Interface, reflect.Pointer:\n\t\treturn v.IsNil()\n\t}\n\treturn false\n}\n\n// isNilValue returns true if the given value is nil.\nfunc isNilValue(v any) bool {\n\tif v == nil {\n\t\treturn true\n\t}\n\n\t// Nil is typed and may not always match above, so for some types we can\n\t// use reflection instead. This is a bit slower, but works.\n\t// https://www.calhoun.io/when-nil-isnt-equal-to-nil/\n\t// https://go.dev/doc/faq#nil_error\n\tvv := reflect.ValueOf(v)\n\tswitch vv.Kind() {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:\n\t\treturn vv.IsNil()\n\t}\n\n\treturn false\n}\n\n// marshalJSON marshals a list of fields and their values into JSON. It supports\n// inlined extensions.\nfunc marshalJSON(fields []jsonFieldInfo, extensions map[string]any) ([]byte, error) {\n\tvalue := make(map[string]any, len(extensions)+len(fields))\n\n\tfor _, v := range fields {\n\t\tif v.omit == omitNil && isNilValue(v.value) {\n\t\t\tcontinue\n\t\t}\n\t\tif v.omit == omitEmpty {\n\t\t\tif isEmptyValue(reflect.ValueOf(v.value)) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tvalue[v.name] = v.value\n\t}\n\n\tfor k, v := range extensions {\n\t\tvalue[k] = v\n\t}\n\n\treturn json.Marshal(value)\n}\n\n// Contact information to get support for the API.\n//\n//\tname: API Support\n//\turl: https://www.example.com/support\n//\temail: support@example.com\ntype Contact struct {\n\t// Name of the contact person/organization.\n\tName string `yaml:\"name,omitempty\"`\n\n\t// URL pointing to the contact information.\n\tURL string `yaml:\"url,omitempty\"`\n\n\t// Email address of the contact person/organization.\n\tEmail string `yaml:\"email,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (c *Contact) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"name\", c.Name, omitEmpty},\n\t\t{\"url\", c.URL, omitEmpty},\n\t\t{\"email\", c.Email, omitEmpty},\n\t}, c.Extensions)\n}\n\n// License name & link for using the API.\n//\n//\tname: Apache 2.0\n//\tidentifier: Apache-2.0\ntype License struct {\n\t// Name of the license.\n\tName string `yaml:\"name\"`\n\n\t// Identifier SPDX license expression for the API. This field is mutually\n\t// exclusive with the URL field.\n\tIdentifier string `yaml:\"identifier,omitempty\"`\n\n\t// URL pointing to the license. This field is mutually exclusive with the\n\t// Identifier field.\n\tURL string `yaml:\"url,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (l *License) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"name\", l.Name, omitNever},\n\t\t{\"identifier\", l.Identifier, omitEmpty},\n\t\t{\"url\", l.URL, omitEmpty},\n\t}, l.Extensions)\n}\n\n// Info object that provides metadata about the API. The metadata MAY be used by\n// the clients if needed, and MAY be presented in editing or documentation\n// generation tools for convenience.\n//\n//\ttitle: Sample Pet Store App\n//\tsummary: A pet store manager.\n//\tdescription: This is a sample server for a pet store.\n//\ttermsOfService: https://example.com/terms/\n//\tcontact:\n//\t  name: API Support\n//\t  url: https://www.example.com/support\n//\t  email: support@example.com\n//\tlicense:\n//\t  name: Apache 2.0\n//\t  url: https://www.apache.org/licenses/LICENSE-2.0.html\n//\tversion: 1.0.1\ntype Info struct {\n\t// Title of the API.\n\tTitle string `yaml:\"title\"`\n\n\t// Description of the API. CommonMark syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// TermsOfService URL for the API.\n\tTermsOfService string `yaml:\"termsOfService,omitempty\"`\n\n\t// Contact information to get support for the API.\n\tContact *Contact `yaml:\"contact,omitempty\"`\n\n\t// License name & link for using the API.\n\tLicense *License `yaml:\"license,omitempty\"`\n\n\t// Version of the OpenAPI document (which is distinct from the OpenAPI Specification version or the API implementation version).\n\tVersion string `yaml:\"version\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (i *Info) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"title\", i.Title, omitNever},\n\t\t{\"description\", i.Description, omitEmpty},\n\t\t{\"termsOfService\", i.TermsOfService, omitEmpty},\n\t\t{\"contact\", i.Contact, omitEmpty},\n\t\t{\"license\", i.License, omitEmpty},\n\t\t{\"version\", i.Version, omitNever},\n\t}, i.Extensions)\n}\n\n// ServerVariable for server URL template substitution.\ntype ServerVariable struct {\n\t// Enumeration of string values to be used if the substitution options are from a limited set. The array MUST NOT be empty.\n\tEnum []string `yaml:\"enum,omitempty\"`\n\n\t// Default value to use for substitution, which SHALL be sent if an alternate value is not supplied.\n\tDefault string `yaml:\"default\"`\n\n\t// Description for the server variable. CommonMark syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (v *ServerVariable) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"enum\", v.Enum, omitEmpty},\n\t\t{\"default\", v.Default, omitNever},\n\t\t{\"description\", v.Description, omitEmpty},\n\t}, v.Extensions)\n}\n\n// Server URL, optionally with variables.\n//\n//\tservers:\n//\t- url: https://development.gigantic-server.com/v1\n//\t  description: Development server\n//\t- url: https://staging.gigantic-server.com/v1\n//\t  description: Staging server\n//\t- url: https://api.gigantic-server.com/v1\n//\t  description: Production server\ntype Server struct {\n\t// URL to the target host. This URL supports Server Variables and MAY be relative, to indicate that the host location is relative to the location where the OpenAPI document is being served. Variable substitutions will be made when a variable is named in {brackets}.\n\tURL string `yaml:\"url\"`\n\n\t// Description of the host designated by the URL. CommonMark syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Variables map between a variable name and its value. The value is used for substitution in the server‚Äôs URL template.\n\tVariables map[string]*ServerVariable `yaml:\"variables,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (s *Server) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"url\", s.URL, omitNever},\n\t\t{\"description\", s.Description, omitEmpty},\n\t\t{\"variables\", s.Variables, omitEmpty},\n\t}, s.Extensions)\n}\n\n// Example value of a request param or body or response header or body.\n//\n//\trequestBody:\n//\t  content:\n//\t    'application/json':\n//\t      schema:\n//\t        $ref: '#/components/schemas/Address'\n//\t      examples:\n//\t        foo:\n//\t          summary: A foo example\n//\t          value: {\"foo\": \"bar\"}\n//\t        bar:\n//\t          summary: A bar example\n//\t          value: {\"bar\": \"baz\"}\ntype Example struct {\n\t// Ref is a reference to another example. This field is mutually exclusive\n\t// with the other fields.\n\tRef string `yaml:\"$ref,omitempty\"`\n\n\t// Summary is a short summary of the example.\n\tSummary string `yaml:\"summary,omitempty\"`\n\n\t// Description is a long description of the example. CommonMark syntax MAY\n\t// be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Value is an embedded literal example. The `value` field and `externalValue`\n\t// field are mutually exclusive. To represent examples of media types that\n\t// cannot naturally represented in JSON or YAML, use a string value to contain\n\t// the example, escaping where necessary.\n\tValue any `yaml:\"value,omitempty\"`\n\n\t// ExternalValue is a URI that points to the literal example. This provides\n\t// the capability to reference examples that cannot easily be included in JSON\n\t// or YAML documents. The `value` field and `externalValue` field are mutually\n\t// exclusive. See the rules for resolving Relative References.\n\tExternalValue string `yaml:\"externalValue,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (e *Example) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"$ref\", e.Ref, omitEmpty},\n\t\t{\"summary\", e.Summary, omitEmpty},\n\t\t{\"description\", e.Description, omitEmpty},\n\t\t{\"value\", e.Value, omitNil},\n\t\t{\"externalValue\", e.ExternalValue, omitEmpty},\n\t}, e.Extensions)\n}\n\n// Encoding is a single encoding definition applied to a single schema property.\n//\n//\trequestBody:\n//\t  content:\n//\t    multipart/form-data:\n//\t      schema:\n//\t        type: object\n//\t        properties:\n//\t          id:\n//\t            # default is text/plain\n//\t            type: string\n//\t            format: uuid\n//\t          address:\n//\t            # default is application/json\n//\t            type: object\n//\t            properties: {}\n//\t          historyMetadata:\n//\t            # need to declare XML format!\n//\t            description: metadata in XML format\n//\t            type: object\n//\t            properties: {}\n//\t          profileImage: {}\n//\t      encoding:\n//\t        historyMetadata:\n//\t          # require XML Content-Type in utf-8 encoding\n//\t          contentType: application/xml; charset=utf-8\n//\t        profileImage:\n//\t          # only accept png/jpeg\n//\t          contentType: image/png, image/jpeg\n//\t          headers:\n//\t            X-Rate-Limit-Limit:\n//\t              description: The number of allowed requests in the current period\n//\t              schema:\n//\t                type: integer\ntype Encoding struct {\n\t// ContentType for encoding a specific property. Default value depends on the\n\t// property type: for object - application/json; for array ‚Äì the default is\n\t// defined based on the inner type; for all other cases the default is\n\t// application/octet-stream. The value can be a specific media type (e.g.\n\t// application/json), a wildcard media type (e.g. image/*), or a\n\t// comma-separated list of the two types.\n\tContentType string `yaml:\"contentType,omitempty\"`\n\n\t// Headers is a map allowing additional information to be provided as headers,\n\t// for example Content-Disposition. Content-Type is described separately and\n\t// SHALL be ignored in this section. This property SHALL be ignored if the\n\t// request body media type is not a multipart.\n\tHeaders map[string]*Header `yaml:\"headers,omitempty\"`\n\n\t// Style describes how a specific property value will be serialized depending\n\t// on its type. See Parameter Object for details on the style property. The\n\t// behavior follows the same values as query parameters, including default\n\t// values. This property SHALL be ignored if the request body media type is\n\t// not application/x-www-form-urlencoded or multipart/form-data. If a value is\n\t// explicitly defined, then the value of contentType (implicit or explicit)\n\t// SHALL be ignored.\n\tStyle string `yaml:\"style,omitempty\"`\n\n\t// Explode, when true, property values of type array or object generate\n\t// separate parameters for each value of the array, or key-value-pair of the\n\t// map. For other types of properties this property has no effect. When style\n\t// is form, the default value is true. For all other styles, the default value\n\t// is false. This property SHALL be ignored if the request body media type is\n\t// not application/x-www-form-urlencoded or multipart/form-data. If a value is\n\t// explicitly defined, then the value of contentType (implicit or explicit)\n\t// SHALL be ignored.\n\tExplode *bool `yaml:\"explode,omitempty\"`\n\n\t// AllowReserved determines whether the parameter value SHOULD allow reserved\n\t// characters, as defined by [RFC3986] :/?#[]@!$&'()*+,;= to be included\n\t// without percent-encoding. The default value is false. This property SHALL\n\t// be ignored if the request body media type is not\n\t// application/x-www-form-urlencoded or multipart/form-data. If a value is\n\t// explicitly defined, then the value of contentType (implicit or explicit)\n\t// SHALL be ignored.\n\tAllowReserved bool `yaml:\"allowReserved,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (e *Encoding) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"contentType\", e.ContentType, omitEmpty},\n\t\t{\"headers\", e.Headers, omitEmpty},\n\t\t{\"style\", e.Style, omitEmpty},\n\t\t{\"explode\", e.Explode, omitEmpty},\n\t\t{\"allowReserved\", e.AllowReserved, omitEmpty},\n\t}, e.Extensions)\n}\n\n// MediaType object provides schema and examples for the media type identified\n// by its key.\n//\n//\tapplication/json:\n//\t  schema:\n//\t    $ref: \"#/components/schemas/Pet\"\n//\t  examples:\n//\t    cat:\n//\t      summary: An example of a cat\n//\t      value:\n//\t        name: Fluffy\n//\t        petType: Cat\n//\t        color: White\n//\t        gender: male\n//\t        breed: Persian\ntype MediaType struct {\n\t// Schema defining the content of the request, response, or parameter.\n\tSchema *Schema `yaml:\"schema,omitempty\"`\n\n\t// Example of the media type. The example object SHOULD be in the correct\n\t// format as specified by the media type. The example field is mutually\n\t// exclusive of the examples field. Furthermore, if referencing a schema which\n\t// contains an example, the example value SHALL override the example provided\n\t// by the schema.\n\tExample any `yaml:\"example,omitempty\"`\n\n\t// Examples of the media type. Each example object SHOULD match the media type\n\t// and specified schema if present. The examples field is mutually exclusive\n\t// of the example field. Furthermore, if referencing a schema which contains\n\t// an example, the examples value SHALL override the example provided by the\n\t// schema.\n\tExamples map[string]*Example `yaml:\"examples,omitempty\"`\n\n\t// Encoding is a map between a property name and its encoding information. The\n\t// key, being the property name, MUST exist in the schema as a property. The\n\t// encoding object SHALL only apply to requestBody objects when the media type\n\t// is multipart or application/x-www-form-urlencoded.\n\tEncoding map[string]*Encoding `yaml:\"encoding,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (m *MediaType) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"schema\", m.Schema, omitEmpty},\n\t\t{\"example\", m.Example, omitNil},\n\t\t{\"examples\", m.Examples, omitEmpty},\n\t\t{\"encoding\", m.Encoding, omitEmpty},\n\t}, m.Extensions)\n}\n\n// Param Describes a single operation parameter.\n//\n// A unique parameter is defined by a combination of a name and location.\n//\n//\tname: username\n//\tin: path\n//\tdescription: username to fetch\n//\trequired: true\n//\tschema:\n//\t  type: string\ntype Param struct {\n\t// Ref is a reference to another example. This field is mutually exclusive\n\t// with the other fields.\n\tRef string `yaml:\"$ref,omitempty\"`\n\n\t// Name is REQUIRED. The name of the parameter. Parameter names are case\n\t// sensitive.\n\t//\n\t//   - If in is \"path\", the name field MUST correspond to a template expression\n\t//     occurring within the path field in the Paths Object. See Path Templating\n\t//     for further information.\n\t//\n\t//   - If in is \"header\" and the name field is \"Accept\", \"Content-Type\" or\n\t//     \"Authorization\", the parameter definition SHALL be ignored.\n\t//\n\t//   - For all other cases, the name corresponds to the parameter name used by\n\t//     the in property.\n\tName string `yaml:\"name,omitempty\"`\n\n\t// In is REQUIRED. The location of the parameter. Possible values are \"query\",\n\t// \"header\", \"path\" or \"cookie\".\n\tIn string `yaml:\"in,omitempty\"`\n\n\t// Description of the parameter. This could contain examples of use.\n\t// CommonMark syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Required determines whether this parameter is mandatory. If the parameter\n\t// location is \"path\", this property is REQUIRED and its value MUST be true.\n\t// Otherwise, the property MAY be included and its default value is false.\n\tRequired bool `yaml:\"required,omitempty\"`\n\n\t// Deprecated specifies that a parameter is deprecated and SHOULD be\n\t// transitioned out of usage. Default value is false.\n\tDeprecated bool `yaml:\"deprecated,omitempty\"`\n\n\t// AllowEmptyValue sets the ability to pass empty-valued parameters. This is\n\t// valid only for query parameters and allows sending a parameter with an\n\t// empty value. Default value is false. If style is used, and if behavior is\n\t// n/a (cannot be serialized), the value of allowEmptyValue SHALL be ignored.\n\t// Use of this property is NOT RECOMMENDED, as it is likely to be removed in a\n\t// later revision.\n\tAllowEmptyValue bool `yaml:\"allowEmptyValue,omitempty\"`\n\n\t// Style describes how the parameter value will be serialized depending on the\n\t// type of the parameter value. Default values (based on value of in): for\n\t// query - form; for path - simple; for header - simple; for cookie - form.\n\tStyle string `yaml:\"style,omitempty\"`\n\n\t// Explode, when true, makes parameter values of type array or object generate\n\t// separate parameters for each value of the array or key-value pair of the\n\t// map. For other types of parameters this property has no effect. When style\n\t// is form, the default value is true. For all other styles, the default value\n\t// is false.\n\tExplode *bool `yaml:\"explode,omitempty\"`\n\n\t// AllowReserved determines whether the parameter value SHOULD allow reserved\n\t// characters, as defined by [RFC3986] :/?#[]@!$&'()*+,;= to be included\n\t// without percent-encoding. This property only applies to parameters with an\n\t// in value of query. The default value is false.\n\tAllowReserved bool `yaml:\"allowReserved,omitempty\"`\n\n\t// Schema defining the type used for the parameter.\n\tSchema *Schema `yaml:\"schema,omitempty\"`\n\n\t// Example of the parameter‚Äôs potential value. The example SHOULD match the\n\t// specified schema and encoding properties if present. The example field is\n\t// mutually exclusive of the examples field. Furthermore, if referencing a\n\t// schema that contains an example, the example value SHALL override the\n\t// example provided by the schema. To represent examples of media types that\n\t// cannot naturally be represented in JSON or YAML, a string value can contain\n\t// the example with escaping where necessary.\n\tExample any `yaml:\"example,omitempty\"`\n\n\t// Examples of the parameter‚Äôs potential value. Each example SHOULD contain a\n\t// value in the correct format as specified in the parameter encoding. The\n\t// examples field is mutually exclusive of the example field. Furthermore, if\n\t// referencing a schema that contains an example, the examples value SHALL\n\t// override the example provided by the schema.\n\tExamples map[string]*Example `yaml:\"examples,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (p *Param) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"$ref\", p.Ref, omitEmpty},\n\t\t{\"name\", p.Name, omitEmpty},\n\t\t{\"in\", p.In, omitEmpty},\n\t\t{\"description\", p.Description, omitEmpty},\n\t\t{\"required\", p.Required, omitEmpty},\n\t\t{\"deprecated\", p.Deprecated, omitEmpty},\n\t\t{\"allowEmptyValue\", p.AllowEmptyValue, omitEmpty},\n\t\t{\"style\", p.Style, omitEmpty},\n\t\t{\"explode\", p.Explode, omitEmpty},\n\t\t{\"allowReserved\", p.AllowReserved, omitEmpty},\n\t\t{\"schema\", p.Schema, omitEmpty},\n\t\t{\"example\", p.Example, omitNil},\n\t\t{\"examples\", p.Examples, omitEmpty},\n\t}, p.Extensions)\n}\n\n// Header object follows the structure of the Parameter Object with the\n// following changes:\n//\n//   - name MUST NOT be specified, it is given in the corresponding headers map.\n//\n//   - in MUST NOT be specified, it is implicitly in header.\n//\n//   - All traits that are affected by the location MUST be applicable to a\n//     location of header (for example, style).\n//\n// Example:\n//\n//\tdescription: The number of allowed requests in the current period\n//\tschema:\n//\t  type: integer\ntype Header = Param\n\n// RequestBody describes a single request body.\n//\n//\tdescription: user to add to the system\n//\tcontent:\n//\t  'application/json':\n//\t    schema:\n//\t      $ref: '#/components/schemas/User'\n//\t    examples:\n//\t      user:\n//\t        summary: User Example\n//\t        externalValue: 'https://foo.bar/examples/user-example.json'\ntype RequestBody struct {\n\t// Ref is a reference to another example. This field is mutually exclusive\n\t// with the other fields.\n\tRef string `yaml:\"$ref,omitempty\"`\n\n\t// Description of the request body. This could contain examples of use.\n\t// CommonMark syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Content is REQUIRED. The content of the request body. The key is a media\n\t// type or media type range and the value describes it. For requests that\n\t// match multiple keys, only the most specific key is applicable. e.g.\n\t// text/plain overrides text/*\n\tContent map[string]*MediaType `yaml:\"content\"`\n\n\t// Required Determines if the request body is required in the request.\n\t// Defaults to false.\n\tRequired bool `yaml:\"required,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (r *RequestBody) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"$ref\", r.Ref, omitEmpty},\n\t\t{\"description\", r.Description, omitEmpty},\n\t\t{\"content\", r.Content, omitNever},\n\t\t{\"required\", r.Required, omitEmpty},\n\t}, r.Extensions)\n}\n\n// Link object represents a possible design-time link for a response. The\n// presence of a link does not guarantee the caller‚Äôs ability to successfully\n// invoke it, rather it provides a known relationship and traversal mechanism\n// between responses and other operations.\n//\n// Unlike dynamic links (i.e. links provided in the response payload), the OAS\n// linking mechanism does not require link information in the runtime response.\n//\n// For computing links, and providing instructions to execute them, a runtime\n// expression is used for accessing values in an operation and using them as\n// parameters while invoking the linked operation.\n//\n//\tpaths:\n//\t  /users/{id}:\n//\t    parameters:\n//\t    - name: id\n//\t      in: path\n//\t      required: true\n//\t      description: the user identifier, as userId\n//\t      schema:\n//\t        type: string\n//\t    get:\n//\t      responses:\n//\t        '200':\n//\t          description: the user being returned\n//\t          content:\n//\t            application/json:\n//\t              schema:\n//\t                type: object\n//\t                properties:\n//\t                  uuid: # the unique user id\n//\t                    type: string\n//\t                    format: uuid\n//\t          links:\n//\t            address:\n//\t              # the target link operationId\n//\t              operationId: getUserAddress\n//\t              parameters:\n//\t                # get the `id` field from the request path parameter named `id`\n//\t                userId: $request.path.id\n//\t  # the path item of the linked operation\n//\t  /users/{userid}/address:\n//\t    parameters:\n//\t    - name: userid\n//\t      in: path\n//\t      required: true\n//\t      description: the user identifier, as userId\n//\t      schema:\n//\t        type: string\n//\t    # linked operation\n//\t    get:\n//\t      operationId: getUserAddress\n//\t      responses:\n//\t        '200':\n//\t          description: the user's address\ntype Link struct {\n\t// Ref is a reference to another example. This field is mutually exclusive\n\t// with the other fields.\n\tRef string `yaml:\"$ref,omitempty\"`\n\n\t// OperationRef is a relative or absolute URI reference to an OAS operation.\n\t// This field is mutually exclusive of the operationId field, and MUST point\n\t// to an Operation Object. Relative operationRef values MAY be used to locate\n\t// an existing Operation Object in the OpenAPI definition. See the rules for\n\t// resolving Relative References.\n\tOperationRef string `yaml:\"operationRef,omitempty\"`\n\n\t// OperationID is the name of an existing, resolvable OAS operation, as\n\t// defined with a unique operationId. This field is mutually exclusive of the\n\t// operationRef field.\n\tOperationID string `yaml:\"operationId,omitempty\"`\n\n\t// Parameters is a map representing parameters to pass to an operation as\n\t// specified with operationId or identified via operationRef. The key is the\n\t// parameter name to be used, whereas the value can be a constant or an\n\t// expression to be evaluated and passed to the linked operation. The\n\t// parameter name can be qualified using the parameter location [{in}.]{name}\n\t// for operations that use the same parameter name in different locations\n\t// (e.g. path.id).\n\tParameters map[string]any `yaml:\"parameters,omitempty\"`\n\n\t// RequestBody is a literal value or {expression} to use as a request body\n\t// when calling the target operation.\n\tRequestBody any `yaml:\"requestBody,omitempty\"`\n\n\t// Description of the link. CommonMark syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Server object to be used by the target operation.\n\tServer *Server `yaml:\"server,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (l *Link) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"$ref\", l.Ref, omitEmpty},\n\t\t{\"operationRef\", l.OperationRef, omitEmpty},\n\t\t{\"operationId\", l.OperationID, omitEmpty},\n\t\t{\"parameters\", l.Parameters, omitEmpty},\n\t\t{\"requestBody\", l.RequestBody, omitNil},\n\t\t{\"description\", l.Description, omitEmpty},\n\t\t{\"server\", l.Server, omitEmpty},\n\t}, l.Extensions)\n}\n\n// Response describes a single response from an API Operation, including\n// design-time, static links to operations based on the response.\n//\n//\tdescription: A complex object array response\n//\tcontent:\n//\t  application/json:\n//\t    schema:\n//\t      type: array\n//\t      items:\n//\t        $ref: '#/components/schemas/VeryComplexType'\ntype Response struct {\n\t// Ref is a reference to another example. This field is mutually exclusive\n\t// with the other fields.\n\tRef string `yaml:\"$ref,omitempty\"`\n\n\t// Description is REQUIRED. A description of the response. CommonMark syntax\n\t// MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Headers maps a header name to its definition. [RFC7230] states header names\n\t// are case insensitive. If a response header is defined with the name\n\t// \"Content-Type\", it SHALL be ignored.\n\tHeaders map[string]*Param `yaml:\"headers,omitempty\"`\n\n\t// Content is a map containing descriptions of potential response payloads.\n\t// The key is a media type or media type range and the value describes it. For\n\t// responses that match multiple keys, only the most specific key is\n\t// applicable. e.g. text/plain overrides text/*\n\tContent map[string]*MediaType `yaml:\"content,omitempty\"`\n\n\t// Links is a map of operations links that can be followed from the response.\n\t// The key of the map is a short name for the link, following the naming\n\t// constraints of the names for Component Objects.\n\tLinks map[string]*Link `yaml:\"links,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (r *Response) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"$ref\", r.Ref, omitEmpty},\n\t\t{\"description\", r.Description, omitEmpty},\n\t\t{\"headers\", r.Headers, omitEmpty},\n\t\t{\"content\", r.Content, omitEmpty},\n\t\t{\"links\", r.Links, omitEmpty},\n\t}, r.Extensions)\n}\n\n// Operation describes a single API operation on a path.\n//\n//\ttags:\n//\t- pet\n//\tsummary: Updates a pet in the store with form data\n//\toperationId: updatePetWithForm\n//\tparameters:\n//\t- name: petId\n//\t  in: path\n//\t  description: ID of pet that needs to be updated\n//\t  required: true\n//\t  schema:\n//\t    type: string\n//\trequestBody:\n//\t  content:\n//\t    'application/x-www-form-urlencoded':\n//\t      schema:\n//\t       type: object\n//\t       properties:\n//\t          name:\n//\t            description: Updated name of the pet\n//\t            type: string\n//\t          status:\n//\t            description: Updated status of the pet\n//\t            type: string\n//\t       required:\n//\t         - status\n//\tresponses:\n//\t  '200':\n//\t    description: Pet updated.\n//\t    content:\n//\t      'application/json': {}\n//\t      'application/xml': {}\n//\t  '405':\n//\t    description: Method Not Allowed\n//\t    content:\n//\t      'application/json': {}\n//\t      'application/xml': {}\n//\tsecurity:\n//\t- petstore_auth:\n//\t  - write:pets\n//\t  - read:pets\ntype Operation struct {\n\t// --- Huma-specific fields ---\n\n\t// Method is the HTTP method for this operation\n\tMethod string `yaml:\"-\"`\n\n\t// Path is the URL path for this operation\n\tPath string `yaml:\"-\"`\n\n\t// DefaultStatus is the default HTTP status code for this operation. It will\n\t// be set to 200 or 204 if not specified, depending on whether the handler\n\t// returns a response body.\n\tDefaultStatus int `yaml:\"-\"`\n\n\t// MaxBodyBytes is the maximum number of bytes to read from the request\n\t// body. If not specified, the default is 1MB. Use -1 for unlimited. If\n\t// the limit is reached, then an HTTP 413 error is returned.\n\tMaxBodyBytes int64 `yaml:\"-\"`\n\n\t// BodyReadTimeout is the maximum amount of time to wait for the request\n\t// body to be read. If not specified, the default is 5 seconds. Use -1\n\t// for unlimited. If the timeout is reached, then an HTTP 408 error is\n\t// returned. This value supersedes the server's read timeout, and a value\n\t// of -1 can unset the server's timeout.\n\tBodyReadTimeout time.Duration `yaml:\"-\"`\n\n\t// Errors is a list of HTTP status codes that the handler may return. If\n\t// not specified, then a default error response is added to the OpenAPI.\n\t// This is a convenience for handlers that return a fixed set of errors\n\t// where you do not wish to provide each one as an OpenAPI response object.\n\t// Each error specified here is expanded into a response object with the\n\t// schema generated from the type returned by `huma.NewError()`\n\t// or `huma.NewErrorWithContext`.\n\tErrors []int `yaml:\"-\"`\n\n\t// SkipValidateParams disables validation of path, query, and header\n\t// parameters. This can speed up request processing if you want to handle\n\t// your own validation. Use with caution!\n\tSkipValidateParams bool `yaml:\"-\"`\n\n\t// SkipValidateBody disables validation of the request body. This can speed\n\t// up request processing if you want to handle your own validation. Use with\n\t// caution!\n\tSkipValidateBody bool `yaml:\"-\"`\n\n\t// Hidden will skip documenting this operation in the OpenAPI. This is\n\t// useful for operations that are not intended to be used by clients but\n\t// you'd still like the benefits of using Huma. Generally not recommended.\n\tHidden bool `yaml:\"-\"`\n\n\t// Metadata is a map of arbitrary data that can be attached to the operation.\n\t// This can be used to store custom data, such as custom settings for\n\t// functions which generate operations.\n\tMetadata map[string]any `yaml:\"-\"`\n\n\t// Middlewares is a list of middleware functions to run before the handler.\n\t// This is useful for adding custom logic to operations, such as logging,\n\t// authentication, or rate limiting.\n\tMiddlewares Middlewares `yaml:\"-\"`\n\n\t// --- OpenAPI fields ---\n\n\t// Tags is a list of tags for API documentation control. Tags can be used for\n\t// logical grouping of operations by resources or any other qualifier.\n\tTags []string `yaml:\"tags,omitempty\"`\n\n\t// Summary is a short summary of what the operation does.\n\tSummary string `yaml:\"summary,omitempty\"`\n\n\t// Description is a verbose explanation of the operation behavior. CommonMark\n\t// syntax MAY be used for rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// ExternalDocs describes additional external documentation for this\n\t// operation.\n\tExternalDocs *ExternalDocs `yaml:\"externalDocs,omitempty\"`\n\n\t// OperationID is a unique string used to identify the operation. The id MUST\n\t// be unique among all operations described in the API. The operationId value\n\t// is case-sensitive. Tools and libraries MAY use the operationId to uniquely\n\t// identify an operation, therefore, it is RECOMMENDED to follow common\n\t// programming naming conventions.\n\tOperationID string `yaml:\"operationId,omitempty\"`\n\n\t// Parameters is a list of parameters that are applicable for this operation.\n\t// If a parameter is already defined at the Path Item, the new definition will\n\t// override it but can never remove it. The list MUST NOT include duplicated\n\t// parameters. A unique parameter is defined by a combination of a name and\n\t// location. The list can use the Reference Object to link to parameters that\n\t// are defined at the OpenAPI Object‚Äôs components/parameters.\n\tParameters []*Param `yaml:\"parameters,omitempty\"`\n\n\t// RequestBody applicable for this operation. The requestBody is fully\n\t// supported in HTTP methods where the HTTP 1.1 specification [RFC7231] has\n\t// explicitly defined semantics for request bodies. In other cases where the\n\t// HTTP spec is vague (such as GET, HEAD and DELETE), requestBody is permitted\n\t// but does not have well-defined semantics and SHOULD be avoided if possible.\n\tRequestBody *RequestBody `yaml:\"requestBody,omitempty\"`\n\n\t// Responses is the list of possible responses as they are returned from\n\t// executing this operation.\n\tResponses map[string]*Response `yaml:\"responses,omitempty\"`\n\n\t// Callbacks is a map of possible out-of band callbacks related to the parent\n\t// operation. The key is a unique identifier for the Callback Object. Each\n\t// value in the map is a Callback Object that describes a request that may be\n\t// initiated by the API provider and the expected responses. The Callback\n\t// Object consists of a map of possible request URL expressions to PathItem\n\t// objects describing the request.\n\t//\n\t// \tcallbacks:\n\t// \t  myName:\n\t// \t    '{$request.body#/url}':\n\t// \t      post:\n\t// \t        requestBody:\n\t// \t          description: callback payload\n\t// \t          content:\n\t// \t            application/json:\n\t// \t              schema:\n\t// \t                $ref: '#/components/schemas/SomePayload'\n\t// \t        responses:\n\t// \t          '200':\n\t// \t            description: callback response\n\tCallbacks map[string]map[string]*PathItem `yaml:\"callbacks,omitempty\"`\n\n\t// Deprecated declares this operation to be deprecated. Consumers SHOULD\n\t// refrain from usage of the declared operation. Default value is false.\n\tDeprecated bool `yaml:\"deprecated,omitempty\"`\n\n\t// Security is a declaration of which security mechanisms can be used for this\n\t// operation. The list of values includes alternative security requirement\n\t// objects that can be used. Only one of the security requirement objects need\n\t// to be satisfied to authorize a request. To make security optional, an empty\n\t// security requirement ({}) can be included in the array. This definition\n\t// overrides any declared top-level security. To remove a top-level security\n\t// declaration, an empty array can be used.\n\tSecurity []map[string][]string `yaml:\"security,omitempty\"`\n\n\t// Servers is an alternative server array to service this operation. If an\n\t// alternative server object is specified at the Path Item Object or Root\n\t// level, it will be overridden by this value.\n\tServers []*Server `yaml:\"servers,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (o *Operation) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"tags\", o.Tags, omitEmpty},\n\t\t{\"summary\", o.Summary, omitEmpty},\n\t\t{\"description\", o.Description, omitEmpty},\n\t\t{\"externalDocs\", o.ExternalDocs, omitEmpty},\n\t\t{\"operationId\", o.OperationID, omitEmpty},\n\t\t{\"parameters\", o.Parameters, omitEmpty},\n\t\t{\"requestBody\", o.RequestBody, omitEmpty},\n\t\t{\"responses\", o.Responses, omitEmpty},\n\t\t{\"callbacks\", o.Callbacks, omitEmpty},\n\t\t{\"deprecated\", o.Deprecated, omitEmpty},\n\t\t{\"security\", o.Security, omitNil},\n\t\t{\"servers\", o.Servers, omitEmpty},\n\t}, o.Extensions)\n}\n\n// PathItem describes the operations available on a single path. A Path Item MAY\n// be empty, due to ACL constraints. The path itself is still exposed to the\n// documentation viewer but they will not know which operations and parameters\n// are available.\n//\n//\tget:\n//\t  description: Returns pets based on ID\n//\t  summary: Find pets by ID\n//\t  operationId: getPetsById\n//\t  responses:\n//\t    '200':\n//\t      description: pet response\n//\t      content:\n//\t        '*/*' :\n//\t          schema:\n//\t            type: array\n//\t            items:\n//\t              $ref: '#/components/schemas/Pet'\n//\t    default:\n//\t      description: error payload\n//\t      content:\n//\t        'text/html':\n//\t          schema:\n//\t            $ref: '#/components/schemas/ErrorModel'\n//\tparameters:\n//\t- name: id\n//\t  in: path\n//\t  description: ID of pet to use\n//\t  required: true\n//\t  schema:\n//\t    type: array\n//\t    items:\n//\t      type: string\n//\t  style: simple\ntype PathItem struct {\n\t// Ref is a reference to another example. This field is mutually exclusive\n\t// with the other fields.\n\tRef string `yaml:\"$ref,omitempty\"`\n\n\t// Summary is an optional, string summary, intended to apply to all operations\n\t// in this path.\n\tSummary string `yaml:\"summary,omitempty\"`\n\n\t// Description is an optional, string description, intended to apply to all\n\t// operations in this path. CommonMark syntax MAY be used for rich text\n\t// representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Get is a definition of a GET operation on this path.\n\tGet *Operation `yaml:\"get,omitempty\"`\n\n\t// Put is a definition of a PUT operation on this path.\n\tPut *Operation `yaml:\"put,omitempty\"`\n\n\t// Post is a definition of a POST operation on this path.\n\tPost *Operation `yaml:\"post,omitempty\"`\n\n\t// Delete is a definition of a DELETE operation on this path.\n\tDelete *Operation `yaml:\"delete,omitempty\"`\n\n\t// Options is a definition of a OPTIONS operation on this path.\n\tOptions *Operation `yaml:\"options,omitempty\"`\n\n\t// Head is a definition of a HEAD operation on this path.\n\tHead *Operation `yaml:\"head,omitempty\"`\n\n\t// Patch is a definition of a PATCH operation on this path.\n\tPatch *Operation `yaml:\"patch,omitempty\"`\n\n\t// Trace is a definition of a TRACE operation on this path.\n\tTrace *Operation `yaml:\"trace,omitempty\"`\n\n\t// Servers is an alternative server array to service all operations in this\n\t// path.\n\tServers []*Server `yaml:\"servers,omitempty\"`\n\n\t// Parameters is a list of parameters that are applicable for all the\n\t// operations described under this path. These parameters can be overridden at\n\t// the operation level, but cannot be removed there. The list MUST NOT include\n\t// duplicated parameters. A unique parameter is defined by a combination of a\n\t// name and location. The list can use the Reference Object to link to\n\t// parameters that are defined at the OpenAPI Object‚Äôs components/parameters.\n\tParameters []*Param `yaml:\"parameters,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (p *PathItem) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"$ref\", p.Ref, omitEmpty},\n\t\t{\"summary\", p.Summary, omitEmpty},\n\t\t{\"description\", p.Description, omitEmpty},\n\t\t{\"get\", p.Get, omitEmpty},\n\t\t{\"put\", p.Put, omitEmpty},\n\t\t{\"post\", p.Post, omitEmpty},\n\t\t{\"delete\", p.Delete, omitEmpty},\n\t\t{\"options\", p.Options, omitEmpty},\n\t\t{\"head\", p.Head, omitEmpty},\n\t\t{\"patch\", p.Patch, omitEmpty},\n\t\t{\"trace\", p.Trace, omitEmpty},\n\t\t{\"servers\", p.Servers, omitEmpty},\n\t\t{\"parameters\", p.Parameters, omitEmpty},\n\t}, p.Extensions)\n}\n\n// OAuthFlow stores configuration details for a supported OAuth Flow.\n//\n//\ttype: oauth2\n//\tflows:\n//\t  implicit:\n//\t    authorizationUrl: https://example.com/api/oauth/dialog\n//\t    scopes:\n//\t      write:pets: modify pets in your account\n//\t      read:pets: read your pets\n//\t  authorizationCode:\n//\t    authorizationUrl: https://example.com/api/oauth/dialog\n//\t    tokenUrl: https://example.com/api/oauth/token\n//\t    scopes:\n//\t      write:pets: modify pets in your account\n//\t      read:pets: read your pets\ntype OAuthFlow struct {\n\t// AuthorizationURL is REQUIRED for `implicit` and `authorizationCode` flows.\n\t// The authorization URL to be used for this flow. This MUST be in the form of\n\t// a URL. The OAuth2 standard requires the use of TLS.\n\tAuthorizationURL string `yaml:\"authorizationUrl,omitempty\"`\n\n\t// TokenURL is REQUIRED. The token URL to be used for this flow. This MUST be\n\t// in the form of a URL. The OAuth2 standard requires the use of TLS.\n\tTokenURL string `yaml:\"tokenUrl\"`\n\n\t// RefreshURL is the URL to be used for obtaining refresh tokens. This MUST be\n\t// in the form of a URL. The OAuth2 standard requires the use of TLS.\n\tRefreshURL string `yaml:\"refreshUrl,omitempty\"`\n\n\t// Scopes are REQUIRED. The available scopes for the OAuth2 security scheme. A\n\t// map between the scope name and a short description for it. The map MAY be\n\t// empty.\n\tScopes map[string]string `yaml:\"scopes\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (o *OAuthFlow) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"authorizationUrl\", o.AuthorizationURL, omitEmpty},\n\t\t{\"tokenUrl\", o.TokenURL, omitNever},\n\t\t{\"refreshUrl\", o.RefreshURL, omitEmpty},\n\t\t{\"scopes\", o.Scopes, omitNever},\n\t}, o.Extensions)\n}\n\n// OAuthFlows allows configuration of the supported OAuth Flows.\ntype OAuthFlows struct {\n\t// Implicit is the configuration for the OAuth Implicit flow.\n\tImplicit *OAuthFlow `yaml:\"implicit,omitempty\"`\n\n\t// Password is the configuration for the OAuth Resource Owner Password flow.\n\tPassword *OAuthFlow `yaml:\"password,omitempty\"`\n\n\t// ClientCredentials is the configuration for the OAuth Client Credentials\n\t// flow. Previously called application in OpenAPI 2.0.\n\tClientCredentials *OAuthFlow `yaml:\"clientCredentials,omitempty\"`\n\n\t// AuthorizationCode is the configuration for the OAuth Authorization Code\n\t// flow. Previously called accessCode in OpenAPI 2.0.\n\tAuthorizationCode *OAuthFlow `yaml:\"authorizationCode,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (o *OAuthFlows) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"implicit\", o.Implicit, omitEmpty},\n\t\t{\"password\", o.Password, omitEmpty},\n\t\t{\"clientCredentials\", o.ClientCredentials, omitEmpty},\n\t\t{\"authorizationCode\", o.AuthorizationCode, omitEmpty},\n\t}, o.Extensions)\n}\n\n// SecurityScheme defines a security scheme that can be used by the operations.\n//\n// Supported schemes are HTTP authentication, an API key (either as a header, a\n// cookie parameter or as a query parameter), mutual TLS (use of a client\n// certificate), OAuth2‚Äôs common flows (implicit, password, client credentials\n// and authorization code) as defined in [RFC6749], and OpenID Connect\n// Discovery. Please note that as of 2020, the implicit flow is about to be\n// deprecated by OAuth 2.0 Security Best Current Practice. Recommended for most\n// use case is Authorization Code Grant flow with PKCE.\n//\n//\ttype: http\n//\tscheme: bearer\n//\tbearerFormat: JWT\ntype SecurityScheme struct {\n\t// Type is REQUIRED. The type of the security scheme. Valid values are\n\t// \"apiKey\", \"http\", \"mutualTLS\", \"oauth2\", \"openIdConnect\".\n\tType string `yaml:\"type\"`\n\n\t// Description for security scheme. CommonMark syntax MAY be used for rich\n\t// text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// Name is REQUIRED. The name of the header, query or cookie parameter to be\n\t// used.\n\tName string `yaml:\"name,omitempty\"`\n\n\t// In is REQUIRED. The location of the API key. Valid values are \"query\",\n\t// \"header\" or \"cookie\".\n\tIn string `yaml:\"in,omitempty\"`\n\n\t// Scheme is REQUIRED. The name of the HTTP Authorization scheme to be used in\n\t// the Authorization header as defined in [RFC7235]. The values used SHOULD be\n\t// registered in the IANA Authentication Scheme registry.\n\tScheme string `yaml:\"scheme,omitempty\"`\n\n\t// BearerFormat is a hint to the client to identify how the bearer token is\n\t// formatted. Bearer tokens are usually generated by an authorization server,\n\t// so this information is primarily for documentation purposes.\n\tBearerFormat string `yaml:\"bearerFormat,omitempty\"`\n\n\t// Flows is REQUIRED. An object containing configuration information for the\n\t// flow types supported.\n\tFlows *OAuthFlows `yaml:\"flows,omitempty\"`\n\n\t// OpenIDConnectURL is REQUIRED. OpenId Connect URL to discover OAuth2\n\t// configuration values. This MUST be in the form of a URL. The OpenID Connect\n\t// standard requires the use of TLS.\n\tOpenIDConnectURL string `yaml:\"openIdConnectUrl,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (s *SecurityScheme) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"type\", s.Type, omitNever},\n\t\t{\"description\", s.Description, omitEmpty},\n\t\t{\"name\", s.Name, omitEmpty},\n\t\t{\"in\", s.In, omitEmpty},\n\t\t{\"scheme\", s.Scheme, omitEmpty},\n\t\t{\"bearerFormat\", s.BearerFormat, omitEmpty},\n\t\t{\"flows\", s.Flows, omitEmpty},\n\t\t{\"openIdConnectUrl\", s.OpenIDConnectURL, omitEmpty},\n\t}, s.Extensions)\n}\n\n// Components holds a set of reusable objects for different aspects of the OAS.\n// All objects defined within the components object will have no effect on the\n// API unless they are explicitly referenced from properties outside the\n// components object.\n//\n//\tcomponents:\n//\t  schemas:\n//\t    GeneralError:\n//\t      type: object\n//\t      properties:\n//\t        code:\n//\t          type: integer\n//\t          format: int32\n//\t        message:\n//\t          type: string\n//\t    Category:\n//\t      type: object\n//\t      properties:\n//\t        id:\n//\t          type: integer\n//\t          format: int64\n//\t        name:\n//\t          type: string\n//\t    Tag:\n//\t      type: object\n//\t      properties:\n//\t        id:\n//\t          type: integer\n//\t          format: int64\n//\t        name:\n//\t          type: string\n//\t  parameters:\n//\t    skipParam:\n//\t      name: skip\n//\t      in: query\n//\t      description: number of items to skip\n//\t      required: true\n//\t      schema:\n//\t        type: integer\n//\t        format: int32\n//\t    limitParam:\n//\t      name: limit\n//\t      in: query\n//\t      description: max records to return\n//\t      required: true\n//\t      schema:\n//\t        type: integer\n//\t        format: int32\n//\t  responses:\n//\t    NotFound:\n//\t      description: Entity not found.\n//\t    IllegalInput:\n//\t      description: Illegal input for operation.\n//\t    GeneralError:\n//\t      description: General Error\n//\t      content:\n//\t        application/json:\n//\t          schema:\n//\t            $ref: '#/components/schemas/GeneralError'\n//\t  securitySchemes:\n//\t    api_key:\n//\t      type: apiKey\n//\t      name: api_key\n//\t      in: header\n//\t    petstore_auth:\n//\t      type: oauth2\n//\t      flows:\n//\t        implicit:\n//\t          authorizationUrl: https://example.org/api/oauth/dialog\n//\t          scopes:\n//\t            write:pets: modify pets in your account\n//\t            read:pets: read your pets\ntype Components struct {\n\t// Schemas is an object to hold reusable Schema Objects.\n\tSchemas Registry `yaml:\"schemas,omitempty\"`\n\n\t// Responses is an object to hold reusable Response Objects.\n\tResponses map[string]*Response `yaml:\"responses,omitempty\"`\n\n\t// Parameters is an object to hold reusable Parameter Objects.\n\tParameters map[string]*Param `yaml:\"parameters,omitempty\"`\n\n\t// Examples is an object to hold reusable Example Objects.\n\tExamples map[string]*Example `yaml:\"examples,omitempty\"`\n\n\t// RequestBodies is an object to hold reusable Request Body Objects.\n\tRequestBodies map[string]*RequestBody `yaml:\"requestBodies,omitempty\"`\n\n\t// Headers is an object to hold reusable Header Objects.\n\tHeaders map[string]*Header `yaml:\"headers,omitempty\"`\n\n\t// SecuritySchemes is an object to hold reusable Security Scheme Objects.\n\tSecuritySchemes map[string]*SecurityScheme `yaml:\"securitySchemes,omitempty\"`\n\n\t// Links is an object to hold reusable Link Objects.\n\tLinks map[string]*Link `yaml:\"links,omitempty\"`\n\n\t// Callbacks is an object to hold reusable Callback Objects.\n\tCallbacks map[string]*PathItem `yaml:\"callbacks,omitempty\"`\n\n\t// PathItems is an object to hold reusable Path Item Objects.\n\tPathItems map[string]*PathItem `yaml:\"pathItems,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (c *Components) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"schemas\", c.Schemas, omitEmpty},\n\t\t{\"responses\", c.Responses, omitEmpty},\n\t\t{\"parameters\", c.Parameters, omitEmpty},\n\t\t{\"examples\", c.Examples, omitEmpty},\n\t\t{\"requestBodies\", c.RequestBodies, omitEmpty},\n\t\t{\"headers\", c.Headers, omitEmpty},\n\t\t{\"securitySchemes\", c.SecuritySchemes, omitEmpty},\n\t\t{\"links\", c.Links, omitEmpty},\n\t\t{\"callbacks\", c.Callbacks, omitEmpty},\n\t\t{\"pathItems\", c.PathItems, omitEmpty},\n\t}, c.Extensions)\n}\n\n// ExternalDocs allows referencing an external resource for extended\n// documentation.\n//\n//\tdescription: Find more info here\n//\turl: https://example.com\ntype ExternalDocs struct {\n\t// Description of the target documentation. CommonMark syntax MAY be used for\n\t// rich text representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// URL is REQUIRED. The URL for the target documentation. Value MUST be in the\n\t// format of a URL.\n\tURL string `yaml:\"url\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (e *ExternalDocs) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"description\", e.Description, omitEmpty},\n\t\t{\"url\", e.URL, omitNever},\n\t}, e.Extensions)\n}\n\n// Tag adds metadata to a single tag that is used by the Operation Object. It is\n// not mandatory to have a Tag Object per tag defined in the Operation Object\n// instances.\ntype Tag struct {\n\t// Name is REQUIRED. The name of the tag.\n\tName string `yaml:\"name\"`\n\n\t// Description for the tag. CommonMark syntax MAY be used for rich text\n\t// representation.\n\tDescription string `yaml:\"description,omitempty\"`\n\n\t// ExternalDocs is additional external documentation for this tag.\n\tExternalDocs *ExternalDocs `yaml:\"externalDocs,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n}\n\nfunc (t *Tag) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"name\", t.Name, omitNever},\n\t\t{\"description\", t.Description, omitEmpty},\n\t\t{\"externalDocs\", t.ExternalDocs, omitEmpty},\n\t}, t.Extensions)\n}\n\ntype AddOpFunc func(oapi *OpenAPI, op *Operation)\n\n// OpenAPI is the root object of the OpenAPI document.\ntype OpenAPI struct {\n\t// OpenAPI is REQUIRED. This string MUST be the version number of the OpenAPI\n\t// Specification that the OpenAPI document uses. The openapi field SHOULD be\n\t// used by tooling to interpret the OpenAPI document. This is not related to\n\t// the API info.version string.\n\tOpenAPI string `yaml:\"openapi\"`\n\n\t// Info is REQUIRED. Provides metadata about the API. The metadata MAY be used\n\t// by tooling as required.\n\tInfo *Info `yaml:\"info\"`\n\n\t// JSONSchemaDialect is the default value for the $schema keyword within Schema\n\t// Objects contained within this OAS document. This MUST be in the form of a\n\t// URI.\n\tJSONSchemaDialect string `yaml:\"jsonSchemaDialect,omitempty\"`\n\n\t// Servers is an array of Server Objects, which provide connectivity\n\t// information to a target server. If the servers property is not provided, or\n\t// is an empty array, the default value would be a Server Object with a url\n\t// value of /.\n\tServers []*Server `yaml:\"servers,omitempty\"`\n\n\t// Paths are the available paths and operations for the API.\n\tPaths map[string]*PathItem `yaml:\"paths,omitempty\"`\n\n\t// Webhooks that MAY be received as part of this API and that the API consumer\n\t// MAY choose to implement. Closely related to the callbacks feature, this\n\t// section describes requests initiated other than by an API call, for example\n\t// by an out of band registration. The key name is a unique string to refer to\n\t// each webhook, while the (optionally referenced) Path Item Object describes\n\t// a request that may be initiated by the API provider and the expected\n\t// responses. An example is available.\n\tWebhooks map[string]*PathItem `yaml:\"webhooks,omitempty\"`\n\n\t// Components is an element to hold various schemas for the document.\n\tComponents *Components `yaml:\"components,omitempty\"`\n\n\t// Security is a declaration of which security mechanisms can be used across\n\t// the API. The list of values includes alternative security requirement\n\t// objects that can be used. Only one of the security requirement objects need\n\t// to be satisfied to authorize a request. Individual operations can override\n\t// this definition. To make security optional, an empty security requirement\n\t// ({}) can be included in the array.\n\tSecurity []map[string][]string `yaml:\"security,omitempty\"`\n\n\t// Tags are a list of tags used by the document with additional metadata. The\n\t// order of the tags can be used to reflect on their order by the parsing\n\t// tools. Not all tags that are used by the Operation Object must be declared.\n\t// The tags that are not declared MAY be organized randomly or based on the\n\t// tools‚Äô logic. Each tag name in the list MUST be unique.\n\tTags []*Tag `yaml:\"tags,omitempty\"`\n\n\t// ExternalDocs is additional external documentation.\n\tExternalDocs *ExternalDocs `yaml:\"externalDocs,omitempty\"`\n\n\t// Extensions (user-defined properties), if any. Values in this map will\n\t// be marshalled as siblings of the other properties above.\n\tExtensions map[string]any `yaml:\",inline\"`\n\n\t// OnAddOperation is called when an operation is added to the OpenAPI via\n\t// `AddOperation`. You may bypass this by directly writing to the `Paths`\n\t// map instead.\n\tOnAddOperation []AddOpFunc `yaml:\"-\"`\n}\n\n// AddOperation adds an operation to the OpenAPI. This is the preferred way to\n// add operations to the OpenAPI, as it will ensure that the operation is\n// properly added to the Paths map, and will call any registered OnAddOperation\n// functions.\nfunc (o *OpenAPI) AddOperation(op *Operation) {\n\tif o.Paths == nil {\n\t\to.Paths = map[string]*PathItem{}\n\t}\n\n\titem := o.Paths[op.Path]\n\tif item == nil {\n\t\titem = &PathItem{}\n\t\to.Paths[op.Path] = item\n\t}\n\n\tswitch op.Method {\n\tcase http.MethodGet:\n\t\titem.Get = op\n\tcase http.MethodPost:\n\t\titem.Post = op\n\tcase http.MethodPut:\n\t\titem.Put = op\n\tcase http.MethodPatch:\n\t\titem.Patch = op\n\tcase http.MethodDelete:\n\t\titem.Delete = op\n\tcase http.MethodHead:\n\t\titem.Head = op\n\tcase http.MethodOptions:\n\t\titem.Options = op\n\tcase http.MethodTrace:\n\t\titem.Trace = op\n\tdefault:\n\t\tpanic(\"unknown method \" + op.Method)\n\t}\n\n\tfor _, f := range o.OnAddOperation {\n\t\tf(o, op)\n\t}\n}\n\nfunc (o *OpenAPI) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"openapi\", o.OpenAPI, omitNever},\n\t\t{\"info\", o.Info, omitNever},\n\t\t{\"jsonSchemaDialect\", o.JSONSchemaDialect, omitEmpty},\n\t\t{\"servers\", o.Servers, omitEmpty},\n\t\t{\"paths\", o.Paths, omitEmpty},\n\t\t{\"webhooks\", o.Webhooks, omitEmpty},\n\t\t{\"components\", o.Components, omitEmpty},\n\t\t{\"security\", o.Security, omitNil},\n\t\t{\"tags\", o.Tags, omitEmpty},\n\t\t{\"externalDocs\", o.ExternalDocs, omitEmpty},\n\t}, o.Extensions)\n}\n\n// YAML returns the OpenAPI represented as YAML without needing to include a\n// library to serialize YAML.\nfunc (o *OpenAPI) YAML() ([]byte, error) {\n\tspecJSON, err := json.Marshal(o)\n\tbuf := bytes.NewBuffer([]byte{})\n\tif err == nil {\n\t\terr = yaml.Convert(buf, bytes.NewReader(specJSON))\n\t}\n\treturn buf.Bytes(), err\n}\n\nfunc downgradeSpec(input any) {\n\tswitch value := input.(type) {\n\tcase map[string]any:\n\t\tm := value\n\t\tkeys := make([]string, 0, len(m))\n\t\tfor k := range m {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tfor _, k := range keys {\n\t\t\tv := m[k]\n\t\t\tif k == \"openapi\" && v == \"3.1.0\" {\n\t\t\t\t// Update version.\n\t\t\t\tm[k] = \"3.0.3\"\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif k == \"type\" {\n\t\t\t\t// OpenAPI 3.1 supports type arrays, which need to be converted.\n\t\t\t\t// This may be lossy, but we want to keep it simple.\n\t\t\t\t// TODO: If we run into more complex cases, split into one-of?\n\t\t\t\tif types, ok := v.([]any); ok {\n\t\t\t\t\tfor _, t := range types {\n\t\t\t\t\t\tif t == \"null\" {\n\t\t\t\t\t\t\t// The \"null\" type is a nullable field in 3.0.\n\t\t\t\t\t\t\tm[\"nullable\"] = true\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Last non-null wins.\n\t\t\t\t\t\t\tm[\"type\"] = t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Exclusive values were bools in 3.0.\n\t\t\tif k == \"exclusiveMinimum\" && reflect.TypeOf(v).Kind() == reflect.Float64 {\n\t\t\t\tm[\"minimum\"] = v\n\t\t\t\tm[\"exclusiveMinimum\"] = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif k == \"exclusiveMaximum\" && reflect.TypeOf(v).Kind() == reflect.Float64 {\n\t\t\t\tm[\"maximum\"] = v\n\t\t\t\tm[\"exclusiveMaximum\"] = true\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Provide single example for tools that read it.\n\t\t\tif k == \"examples\" {\n\t\t\t\tif examples, ok := v.([]any); ok {\n\t\t\t\t\tif len(examples) > 0 {\n\t\t\t\t\t\tm[\"example\"] = examples[0]\n\t\t\t\t\t}\n\t\t\t\t\tif len(examples) == 1 {\n\t\t\t\t\t\tdelete(m, k)\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Base64 / binary uploads\n\t\t\tif k == \"application/octet-stream\" {\n\t\t\t\tif ct, ok := v.(map[string]any); ok && len(ct) == 0 {\n\t\t\t\t\tm[k] = map[string]any{\n\t\t\t\t\t\t\"schema\": map[string]any{\n\t\t\t\t\t\t\t\"type\":   \"string\",\n\t\t\t\t\t\t\t\"format\": \"binary\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif k == \"contentEncoding\" && v == \"base64\" {\n\t\t\t\tdelete(m, k)\n\t\t\t\tm[\"format\"] = \"base64\"\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdowngradeSpec(v)\n\t\t}\n\tcase []any:\n\t\tfor _, item := range value {\n\t\t\tdowngradeSpec(item)\n\t\t}\n\t}\n}\n\n// Downgrade converts this OpenAPI 3.1 spec to OpenAPI 3.0.3, returning the\n// JSON []byte representation of the downgraded spec. This mostly exists\n// to provide an alternative spec for tools which are not yet 3.1 compatible.\n//\n// It reverses the changes documented at:\n// https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\nfunc (o OpenAPI) Downgrade() ([]byte, error) {\n\tb, err := o.MarshalJSON()\n\tif err == nil {\n\t\tvar v any\n\t\tjson.Unmarshal(b, &v)\n\n\t\tdowngradeSpec(v)\n\n\t\tb, err = json.Marshal(v)\n\t}\n\treturn b, err\n}\n\n// DowngradeYAML converts this OpenAPI 3.1 spec to OpenAPI 3.0.3, returning the\n// YAML []byte representation of the downgraded spec.\nfunc (o *OpenAPI) DowngradeYAML() ([]byte, error) {\n\tspecJSON, err := o.Downgrade()\n\tbuf := bytes.NewBuffer([]byte{})\n\tif err == nil {\n\t\terr = yaml.Convert(buf, bytes.NewReader(specJSON))\n\t}\n\treturn buf.Bytes(), err\n}\n"
        },
        {
          "name": "openapi_test.go",
          "type": "blob",
          "size": 5.646484375,
          "content": "package huma_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestOpenAPIMarshal(t *testing.T) {\n\t// Simple spot check to make sure we are generating valid YAML and that\n\t// the OpenAPI generally works as expected.\n\n\tnum := 1.0\n\n\tv := huma.OpenAPI{\n\t\tOpenAPI: \"3.0.0\",\n\t\tInfo: &huma.Info{\n\t\t\tTitle:   \"Test API\",\n\t\t\tVersion: \"1.0.0\",\n\t\t\tContact: &huma.Contact{\n\t\t\t\tName: \"Daniel Taylor\",\n\t\t\t},\n\t\t\tLicense: &huma.License{\n\t\t\t\tName: \"MIT\",\n\t\t\t},\n\t\t},\n\t\tExternalDocs: &huma.ExternalDocs{\n\t\t\tURL: \"https://example.com\",\n\t\t},\n\t\tTags: []*huma.Tag{\n\t\t\t{\n\t\t\t\tName: \"test\",\n\t\t\t},\n\t\t},\n\t\tServers: []*huma.Server{\n\t\t\t{\n\t\t\t\tURL: \"https://example.com/{foo}\",\n\t\t\t\tVariables: map[string]*huma.ServerVariable{\n\t\t\t\t\t\"foo\": {\n\t\t\t\t\t\tDefault: \"bar\",\n\t\t\t\t\t\tEnum:    []string{\"bar\", \"baz\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tComponents: &huma.Components{\n\t\t\tSchemas: huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer),\n\t\t\tSecuritySchemes: map[string]*huma.SecurityScheme{\n\t\t\t\t\"oauth2\": {\n\t\t\t\t\tType: \"oauth2\",\n\t\t\t\t\tFlows: &huma.OAuthFlows{\n\t\t\t\t\t\tClientCredentials: &huma.OAuthFlow{\n\t\t\t\t\t\t\tAuthorizationURL: \"https://example.com/oauth2/authorize\",\n\t\t\t\t\t\t\tTokenURL:         \"https://example.com/oauth2/token\",\n\t\t\t\t\t\t\tScopes: map[string]string{\n\t\t\t\t\t\t\t\t\"test\": \"Test scope\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tPaths: map[string]*huma.PathItem{\n\t\t\t\"/test\": {\n\t\t\t\tGet: &huma.Operation{\n\t\t\t\t\tResponses: map[string]*huma.Response{\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tDescription: \"OK\",\n\t\t\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tExamples: map[string]*huma.Example{\n\t\t\t\t\t\t\t\t\t\t\"test\": {\n\t\t\t\t\t\t\t\t\t\t\tValue: `{\"test\": \"example\"}`,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tEncoding: map[string]*huma.Encoding{\n\t\t\t\t\t\t\t\t\t\t\"test\": {\n\t\t\t\t\t\t\t\t\t\t\tContentType: \"application/json\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tSchema: &huma.Schema{\n\t\t\t\t\t\t\t\t\t\tType: \"object\",\n\t\t\t\t\t\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\t\t\t\t\t\"test\": {\n\t\t\t\t\t\t\t\t\t\t\t\tType:    \"integer\",\n\t\t\t\t\t\t\t\t\t\t\t\tMinimum: &num,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLinks: map[string]*huma.Link{\n\t\t\t\t\t\t\t\t\"related\": {\n\t\t\t\t\t\t\t\t\tOperationID: \"another-operation\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tExtensions: map[string]any{\n\t\t\t\"x-test\": 123,\n\t\t},\n\t}\n\n\t// This will marshal to JSON, then convert to YAML.\n\tout, err := v.YAML()\n\trequire.NoError(t, err)\n\n\texpected := `components:\n  schemas: {}\n  securitySchemes:\n    oauth2:\n      flows:\n        clientCredentials:\n          authorizationUrl: https://example.com/oauth2/authorize\n          scopes:\n            test: Test scope\n          tokenUrl: https://example.com/oauth2/token\n      type: oauth2\nexternalDocs:\n  url: https://example.com\ninfo:\n  contact:\n    name: Daniel Taylor\n  license:\n    name: MIT\n  title: Test API\n  version: 1.0.0\nopenapi: 3.0.0\npaths:\n  /test:\n    get:\n      responses:\n        \"200\":\n          content:\n            application/json:\n              encoding:\n                test:\n                  contentType: application/json\n              examples:\n                test:\n                  value: \"{\\\"test\\\": \\\"example\\\"}\"\n              schema:\n                properties:\n                  test:\n                    minimum: 1\n                    type: integer\n                type: object\n          description: OK\n          links:\n            related:\n              operationId: another-operation\nservers:\n  - url: https://example.com/{foo}\n    variables:\n      foo:\n        default: bar\n        enum:\n          - bar\n          - baz\ntags:\n  - name: test\nx-test: 123\n`\n\n\trequire.Equal(t, expected, string(out))\n}\n\nfunc TestDowngrade(t *testing.T) {\n\t// Test that we can downgrade a v3 OpenAPI document to v2.\n\tv31 := &huma.OpenAPI{\n\t\tOpenAPI: \"3.1.0\",\n\t\tInfo: &huma.Info{\n\t\t\tTitle:   \"Test API\",\n\t\t\tVersion: \"1.0.0\",\n\t\t},\n\t\tPaths: map[string]*huma.PathItem{\n\t\t\t\"/test\": {\n\t\t\t\tGet: &huma.Operation{\n\t\t\t\t\tResponses: map[string]*huma.Response{\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\tDescription: \"OK\",\n\t\t\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\tSchema: &huma.Schema{\n\t\t\t\t\t\t\t\t\t\tType: \"object\",\n\t\t\t\t\t\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\t\t\t\t\t\"test\": {\n\t\t\t\t\t\t\t\t\t\t\t\tType:             \"integer\",\n\t\t\t\t\t\t\t\t\t\t\t\tExclusiveMinimum: Ptr(0.0),\n\t\t\t\t\t\t\t\t\t\t\t\tExclusiveMaximum: Ptr(100.0),\n\t\t\t\t\t\t\t\t\t\t\t\tNullable:         true,\n\t\t\t\t\t\t\t\t\t\t\t\tExamples:         []any{100},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\"encoding\": {\n\t\t\t\t\t\t\t\t\t\t\t\tType:            huma.TypeString,\n\t\t\t\t\t\t\t\t\t\t\t\tContentEncoding: \"base64\",\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"application/octet-stream\": {},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tv30, err := v31.Downgrade()\n\trequire.NoError(t, err)\n\n\texpected := `{\n\t\t\"openapi\": \"3.0.3\",\n\t\t\"info\": {\n\t\t\t\"title\": \"Test API\",\n\t\t\t\"version\": \"1.0.0\"\n\t\t},\n\t\t\"paths\": {\n\t\t\t\"/test\": {\n\t\t\t\t\"get\": {\n\t\t\t\t\t\"responses\": {\n\t\t\t\t\t\t\"200\": {\n\t\t\t\t\t\t\t\"description\": \"OK\",\n\t\t\t\t\t\t\t\"content\": {\n\t\t\t\t\t\t\t\t\"application/json\": {\n\t\t\t\t\t\t\t\t\t\"schema\": {\n\t\t\t\t\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\t\t\t\t\"test\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"nullable\": true,\n\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\": 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\"exclusiveMinimum\": true,\n\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\": 100,\n\t\t\t\t\t\t\t\t\t\t\t\t\"exclusiveMaximum\": true,\n\t\t\t\t\t\t\t\t\t\t\t\t\"example\": 100\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\"encoding\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"format\": \"base64\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"application/octet-stream\": {\n\t\t\t\t\t\t\t\t\t\"schema\": {\n\t\t\t\t\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\t\t\t\t\"format\": \"binary\"\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}`\n\n\t// Check that the downgrade worked as expected.\n\tassert.JSONEq(t, expected, string(v30))\n}\n"
        },
        {
          "name": "queryparam",
          "type": "tree",
          "content": null
        },
        {
          "name": "registry.go",
          "type": "blob",
          "size": 4.8330078125,
          "content": "package huma\n\nimport (\n\t\"encoding\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\n// Registry creates and stores schemas and their references, and supports\n// marshalling to JSON/YAML for use as an OpenAPI #/components/schemas object.\n// Behavior is implementation-dependent, but the design allows for recursive\n// schemas to exist while being flexible enough to support other use cases\n// like only inline objects (no refs) or always using refs for structs.\ntype Registry interface {\n\tSchema(t reflect.Type, allowRef bool, hint string) *Schema\n\tSchemaFromRef(ref string) *Schema\n\tTypeFromRef(ref string) reflect.Type\n\tMap() map[string]*Schema\n\tRegisterTypeAlias(t reflect.Type, alias reflect.Type)\n}\n\n// DefaultSchemaNamer provides schema names for types. It uses the type name\n// when possible, ignoring the package name. If the type is generic, e.g.\n// `MyType[SubType]`, then the brackets are removed like `MyTypeSubType`.\n// If the type is unnamed, then the name hint is used.\n// Note: if you plan to use types with the same name from different packages,\n// you should implement your own namer function to prevent issues. Nested\n// anonymous types can also present naming issues.\nfunc DefaultSchemaNamer(t reflect.Type, hint string) string {\n\tname := deref(t).Name()\n\n\tif name == \"\" {\n\t\tname = hint\n\t}\n\n\t// Better support for lists, so e.g. `[]int` becomes `ListInt`.\n\tname = strings.ReplaceAll(name, \"[]\", \"List[\")\n\n\tresult := \"\"\n\tfor _, part := range strings.FieldsFunc(name, func(r rune) bool {\n\t\t// Split on special characters. Note that `,` is used when there are\n\t\t// multiple inputs to a generic type.\n\t\treturn r == '[' || r == ']' || r == '*' || r == ','\n\t}) {\n\t\t// Split fully qualified names like `github.com/foo/bar.Baz` into `Baz`.\n\t\tfqn := strings.Split(part, \".\")\n\t\tbase := fqn[len(fqn)-1]\n\n\t\t// Add to result, and uppercase for better scalar support (`int` -> `Int`).\n\t\t// Use unicode-aware uppercase to support non-ASCII characters.\n\t\tr, size := utf8.DecodeRuneInString(base)\n\t\tresult += strings.ToUpper(string(r)) + base[size:]\n\t}\n\tname = result\n\n\treturn name\n}\n\ntype mapRegistry struct {\n\tprefix  string\n\tschemas map[string]*Schema\n\ttypes   map[string]reflect.Type\n\tseen    map[reflect.Type]bool\n\tnamer   func(reflect.Type, string) string\n\taliases map[reflect.Type]reflect.Type\n}\n\nfunc (r *mapRegistry) Schema(t reflect.Type, allowRef bool, hint string) *Schema {\n\torigType := t\n\tt = deref(t)\n\n\t// Pointer to array should decay to array\n\tif t.Kind() == reflect.Array || t.Kind() == reflect.Slice {\n\t\torigType = t\n\t}\n\n\talias, ok := r.aliases[t]\n\tif ok {\n\t\treturn r.Schema(alias, allowRef, hint)\n\t}\n\n\tgetsRef := t.Kind() == reflect.Struct\n\tif t == timeType {\n\t\t// Special case: time.Time is always a string.\n\t\tgetsRef = false\n\t}\n\n\tv := reflect.New(t).Interface()\n\tif _, ok := v.(SchemaProvider); ok {\n\t\t// Special case: type provides its own schema\n\t\tgetsRef = false\n\t}\n\tif _, ok := v.(encoding.TextUnmarshaler); ok {\n\t\t// Special case: type can be unmarshalled from text so will be a `string`\n\t\t// and doesn't need a ref. This simplifies the schema a little bit.\n\t\tgetsRef = false\n\t}\n\n\tname := r.namer(origType, hint)\n\n\tif getsRef {\n\t\tif s, ok := r.schemas[name]; ok {\n\t\t\tif _, ok := r.seen[t]; !ok {\n\t\t\t\t// Name matches but type is different, so we have a dupe.\n\n\t\t\t\tpanic(fmt.Errorf(\"duplicate name: %s, new type: %s, existing type: %s\", name, t, r.types[name]))\n\t\t\t}\n\t\t\tif allowRef {\n\t\t\t\treturn &Schema{Ref: r.prefix + name}\n\t\t\t}\n\t\t\treturn s\n\t\t}\n\t}\n\n\t// First, register the type so refs can be created above for recursive types.\n\tif getsRef {\n\t\tr.schemas[name] = &Schema{}\n\t\tr.types[name] = t\n\t\tr.seen[t] = true\n\t}\n\ts := SchemaFromType(r, origType)\n\tif getsRef {\n\t\tr.schemas[name] = s\n\t}\n\n\tif getsRef && allowRef {\n\t\treturn &Schema{Ref: r.prefix + name}\n\t}\n\treturn s\n}\n\nfunc (r *mapRegistry) SchemaFromRef(ref string) *Schema {\n\tif !strings.HasPrefix(ref, r.prefix) {\n\t\treturn nil\n\t}\n\treturn r.schemas[ref[len(r.prefix):]]\n}\n\nfunc (r *mapRegistry) TypeFromRef(ref string) reflect.Type {\n\treturn r.types[ref[len(r.prefix):]]\n}\n\nfunc (r *mapRegistry) Map() map[string]*Schema {\n\treturn r.schemas\n}\n\nfunc (r *mapRegistry) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(r.schemas)\n}\n\nfunc (r *mapRegistry) MarshalYAML() (interface{}, error) {\n\treturn r.schemas, nil\n}\n\n// RegisterTypeAlias(t, alias) makes the schema generator use the `alias` type instead of `t`.\nfunc (r *mapRegistry) RegisterTypeAlias(t reflect.Type, alias reflect.Type) {\n\tr.aliases[t] = alias\n}\n\n// NewMapRegistry creates a new registry that stores schemas in a map and\n// returns references to them using the given prefix.\nfunc NewMapRegistry(prefix string, namer func(t reflect.Type, hint string) string) Registry {\n\treturn &mapRegistry{\n\t\tprefix:  prefix,\n\t\tschemas: map[string]*Schema{},\n\t\ttypes:   map[string]reflect.Type{},\n\t\tseen:    map[reflect.Type]bool{},\n\t\taliases: map[reflect.Type]reflect.Type{},\n\t\tnamer:   namer,\n\t}\n}\n"
        },
        {
          "name": "registry_test.go",
          "type": "blob",
          "size": 2.1015625,
          "content": "package huma\n\nimport (\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype Output[T any] struct{}\n\ntype Embedded[P any] struct{}\n\ntype EmbeddedTwo[P, V any] struct{}\n\ntype S struct{}\n\ntype √º struct{}\n\ntype MP4 struct{}\n\nfunc TestDefaultSchemaNamer(t *testing.T) {\n\ttype Renamed Output[*[]Embedded[time.Time]]\n\n\tfor _, example := range []struct {\n\t\ttyp  any\n\t\tname string\n\t\thint string\n\t}{\n\t\t{int(0), \"Int\", \"\"},\n\t\t{int64(0), \"Int64\", \"\"},\n\t\t{S{}, \"S\", \"\"},\n\t\t{time.Time{}, \"Time\", \"\"},\n\t\t{Output[int]{}, \"OutputInt\", \"\"},\n\t\t{Output[*int]{}, \"OutputInt\", \"\"},\n\t\t{Output[[]int]{}, \"OutputListInt\", \"\"},\n\t\t{Output[[]*int]{}, \"OutputListInt\", \"\"},\n\t\t{Output[[][]int]{}, \"OutputListListInt\", \"\"},\n\t\t{Output[map[string]int]{}, \"OutputMapStringInt\", \"\"},\n\t\t{Output[map[string][]*int]{}, \"OutputMapStringListInt\", \"\"},\n\t\t{Output[S]{}, \"OutputS\", \"\"},\n\t\t{Output[√º]{}, \"Output√ú\", \"\"},\n\t\t{Output[MP4]{}, \"OutputMP4\", \"\"},\n\t\t{Output[Embedded[*time.Time]]{}, \"OutputEmbeddedTime\", \"\"},\n\t\t{Output[*[]Embedded[time.Time]]{}, \"OutputListEmbeddedTime\", \"\"},\n\t\t{Output[EmbeddedTwo[[]time.Time, **url.URL]]{}, \"OutputEmbeddedTwoListTimeURL\", \"\"},\n\t\t{Renamed{}, \"Renamed\", \"\"},\n\t\t{struct{}{}, \"SomeGenericThing\", \"Some[pkg.Generic]Thing\"},\n\t\t{struct{}{}, \"Type1Type2Type3\", \"pkg1.Type1[path/to/pkg2.Type2]pkg3.Type3\"},\n\t} {\n\t\tt.Run(example.name, func(t *testing.T) {\n\t\t\tname := DefaultSchemaNamer(reflect.TypeOf(example.typ), example.hint)\n\t\t\tassert.Equal(t, example.name, name)\n\t\t})\n\t}\n}\n\nfunc TestSchemaAlias(t *testing.T) {\n\ttype StringContainer struct {\n\t\tValue string\n\t}\n\ttype StructWithStringContainer struct {\n\t\tName StringContainer `json:\"name,omitempty\"`\n\t}\n\ttype StructWithString struct {\n\t\tName string `json:\"name,omitempty\"`\n\t}\n\tregistry := NewMapRegistry(\"#/components/schemas\", DefaultSchemaNamer)\n\tregistry.RegisterTypeAlias(reflect.TypeOf(StringContainer{}), reflect.TypeOf(\"\"))\n\tschemaWithContainer := registry.Schema(reflect.TypeOf(StructWithStringContainer{}), false, \"\")\n\tschemaWithString := registry.Schema(reflect.TypeOf(StructWithString{}), false, \"\")\n\tassert.Equal(t, schemaWithString, schemaWithContainer)\n}\n"
        },
        {
          "name": "resolver_test.go",
          "type": "blob",
          "size": 2.0205078125,
          "content": "package huma_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n)\n\n// Step 1: Create your input struct where you want to do additional validation.\n// This struct must implement the `huma.Resolver` interface.\ntype ExampleInputBody struct {\n\tCount int `json:\"count\" minimum:\"0\"`\n}\n\nfunc (b *ExampleInputBody) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\t// Return an error if some arbitrary rule is broken. In this case, if it's\n\t// a multiple of 30 we return an error.\n\tif b.Count%30 == 0 {\n\t\treturn []error{&huma.ErrorDetail{\n\t\t\tLocation: prefix.With(\"count\"),\n\t\t\tMessage:  \"multiples of 30 are not allowed\",\n\t\t\tValue:    b.Count,\n\t\t}}\n\t}\n\n\treturn nil\n}\n\nfunc ExampleResolver() {\n\t// Create the API.\n\tr := http.NewServeMux()\n\tapi := NewExampleAPI(r, huma.DefaultConfig(\"Example API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"resolver-example\",\n\t\tMethod:      http.MethodPut,\n\t\tPath:        \"/resolver\",\n\t}, func(ctx context.Context, input *struct {\n\t\t// Step 2: Use your custom struct with the resolver as a field in the\n\t\t// request input. Here we use it as the body of the request.\n\t\tBody ExampleInputBody\n\t}) (*struct{}, error) {\n\t\t// Do nothing. Validation should catch the error!\n\t\treturn nil, nil\n\t})\n\n\t// Make an example request showing the validation error response.\n\treq, _ := http.NewRequest(http.MethodPut, \"/resolver\", strings.NewReader(`{\"count\": 30}`))\n\treq.Host = \"example.com\"\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\tw := httptest.NewRecorder()\n\n\tr.ServeHTTP(w, req)\n\n\tout := bytes.NewBuffer(nil)\n\tjson.Indent(out, w.Body.Bytes(), \"\", \"  \")\n\tfmt.Println(out.String())\n\t// Output: {\n\t//   \"$schema\": \"https://example.com/schemas/ErrorModel.json\",\n\t//   \"title\": \"Unprocessable Entity\",\n\t//   \"status\": 422,\n\t//   \"detail\": \"validation failed\",\n\t//   \"errors\": [\n\t//     {\n\t//       \"message\": \"multiples of 30 are not allowed\",\n\t//       \"location\": \"body.count\",\n\t//       \"value\": 30\n\t//     }\n\t//   ]\n\t// }\n}\n"
        },
        {
          "name": "schema.go",
          "type": "blob",
          "size": 29.3759765625,
          "content": "package huma\n\nimport (\n\t\"encoding\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/bits\"\n\t\"net\"\n\t\"net/netip\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2/validation\"\n)\n\n// ErrSchemaInvalid is sent when there is a problem building the schema.\nvar ErrSchemaInvalid = errors.New(\"schema is invalid\")\n\n// DefaultArrayNullable controls whether arrays are nullable by default. Set\n// this to `false` to make arrays non-nullable by default, but be aware that\n// any `nil` slice will still encode as `null` in JSON. See also:\n// https://pkg.go.dev/encoding/json#Marshal.\nvar DefaultArrayNullable = true\n\n// JSON Schema type constants\nconst (\n\tTypeBoolean = \"boolean\"\n\tTypeInteger = \"integer\"\n\tTypeNumber  = \"number\"\n\tTypeString  = \"string\"\n\tTypeArray   = \"array\"\n\tTypeObject  = \"object\"\n)\n\n// Special JSON Schema formats.\nvar (\n\ttimeType       = reflect.TypeOf(time.Time{})\n\tipType         = reflect.TypeOf(net.IP{})\n\tipAddrType     = reflect.TypeOf(netip.Addr{})\n\turlType        = reflect.TypeOf(url.URL{})\n\trawMessageType = reflect.TypeOf(json.RawMessage{})\n)\n\nfunc deref(t reflect.Type) reflect.Type {\n\tfor t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn t\n}\n\n// Discriminator object when request bodies or response payloads may be one of a\n// number of different schemas, can be used to aid in serialization,\n// deserialization, and validation. The discriminator is a specific object in a\n// schema which is used to inform the consumer of the document of an alternative\n// schema based on the value associated with it.\ntype Discriminator struct {\n\t// PropertyName in the payload that will hold the discriminator value.\n\t// REQUIRED.\n\tPropertyName string `yaml:\"propertyName\"`\n\n\t// Mapping object to hold mappings between payload values and schema names or\n\t// references.\n\tMapping map[string]string `yaml:\"mapping,omitempty\"`\n}\n\nfunc (d *Discriminator) MarshalJSON() ([]byte, error) {\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"propertyName\", d.PropertyName, omitNever},\n\t\t{\"mapping\", d.Mapping, omitEmpty},\n\t}, nil)\n}\n\n// Schema represents a JSON Schema compatible with OpenAPI 3.1. It is extensible\n// with your own custom properties. It supports a subset of the full JSON Schema\n// spec, designed specifically for use with Go structs and to enable fast zero\n// or near-zero allocation happy-path validation for incoming requests.\n//\n// Typically you will use a registry and `huma.SchemaFromType` to generate\n// schemas for your types. You can then use `huma.Validate` to validate\n// incoming requests.\n//\n//\t// Create a registry and register a type.\n//\tregistry := huma.NewMapRegistry(\"#/prefix\", huma.DefaultSchemaNamer)\n//\tschema := huma.SchemaFromType(registry, reflect.TypeOf(MyType{}))\n//\n// Note that the registry may create references for your types.\ntype Schema struct {\n\tType                 string              `yaml:\"type,omitempty\"`\n\tNullable             bool                `yaml:\"-\"`\n\tTitle                string              `yaml:\"title,omitempty\"`\n\tDescription          string              `yaml:\"description,omitempty\"`\n\tRef                  string              `yaml:\"$ref,omitempty\"`\n\tFormat               string              `yaml:\"format,omitempty\"`\n\tContentEncoding      string              `yaml:\"contentEncoding,omitempty\"`\n\tDefault              any                 `yaml:\"default,omitempty\"`\n\tExamples             []any               `yaml:\"examples,omitempty\"`\n\tItems                *Schema             `yaml:\"items,omitempty\"`\n\tAdditionalProperties any                 `yaml:\"additionalProperties,omitempty\"`\n\tProperties           map[string]*Schema  `yaml:\"properties,omitempty\"`\n\tEnum                 []any               `yaml:\"enum,omitempty\"`\n\tMinimum              *float64            `yaml:\"minimum,omitempty\"`\n\tExclusiveMinimum     *float64            `yaml:\"exclusiveMinimum,omitempty\"`\n\tMaximum              *float64            `yaml:\"maximum,omitempty\"`\n\tExclusiveMaximum     *float64            `yaml:\"exclusiveMaximum,omitempty\"`\n\tMultipleOf           *float64            `yaml:\"multipleOf,omitempty\"`\n\tMinLength            *int                `yaml:\"minLength,omitempty\"`\n\tMaxLength            *int                `yaml:\"maxLength,omitempty\"`\n\tPattern              string              `yaml:\"pattern,omitempty\"`\n\tPatternDescription   string              `yaml:\"patternDescription,omitempty\"`\n\tMinItems             *int                `yaml:\"minItems,omitempty\"`\n\tMaxItems             *int                `yaml:\"maxItems,omitempty\"`\n\tUniqueItems          bool                `yaml:\"uniqueItems,omitempty\"`\n\tRequired             []string            `yaml:\"required,omitempty\"`\n\tMinProperties        *int                `yaml:\"minProperties,omitempty\"`\n\tMaxProperties        *int                `yaml:\"maxProperties,omitempty\"`\n\tReadOnly             bool                `yaml:\"readOnly,omitempty\"`\n\tWriteOnly            bool                `yaml:\"writeOnly,omitempty\"`\n\tDeprecated           bool                `yaml:\"deprecated,omitempty\"`\n\tExtensions           map[string]any      `yaml:\",inline\"`\n\tDependentRequired    map[string][]string `yaml:\"dependentRequired,omitempty\"`\n\n\tOneOf []*Schema `yaml:\"oneOf,omitempty\"`\n\tAnyOf []*Schema `yaml:\"anyOf,omitempty\"`\n\tAllOf []*Schema `yaml:\"allOf,omitempty\"`\n\tNot   *Schema   `yaml:\"not,omitempty\"`\n\n\t// OpenAPI specific fields\n\tDiscriminator *Discriminator `yaml:\"discriminator,omitempty\"`\n\n\tpatternRe     *regexp.Regexp  `yaml:\"-\"`\n\trequiredMap   map[string]bool `yaml:\"-\"`\n\tpropertyNames []string        `yaml:\"-\"`\n\thidden        bool            `yaml:\"-\"`\n\n\t// Precomputed validation messages. These prevent allocations during\n\t// validation and are known at schema creation time.\n\tmsgEnum              string                       `yaml:\"-\"`\n\tmsgMinimum           string                       `yaml:\"-\"`\n\tmsgExclusiveMinimum  string                       `yaml:\"-\"`\n\tmsgMaximum           string                       `yaml:\"-\"`\n\tmsgExclusiveMaximum  string                       `yaml:\"-\"`\n\tmsgMultipleOf        string                       `yaml:\"-\"`\n\tmsgMinLength         string                       `yaml:\"-\"`\n\tmsgMaxLength         string                       `yaml:\"-\"`\n\tmsgPattern           string                       `yaml:\"-\"`\n\tmsgMinItems          string                       `yaml:\"-\"`\n\tmsgMaxItems          string                       `yaml:\"-\"`\n\tmsgMinProperties     string                       `yaml:\"-\"`\n\tmsgMaxProperties     string                       `yaml:\"-\"`\n\tmsgRequired          map[string]string            `yaml:\"-\"`\n\tmsgDependentRequired map[string]map[string]string `yaml:\"-\"`\n}\n\n// MarshalJSON marshals the schema into JSON, respecting the `Extensions` map\n// to marshal extensions inline.\nfunc (s *Schema) MarshalJSON() ([]byte, error) {\n\tvar typ any = s.Type\n\tif s.Nullable {\n\t\ttyp = []string{s.Type, \"null\"}\n\t}\n\n\tvar contentMediaType string\n\tif s.Format == \"binary\" {\n\t\tcontentMediaType = \"application/octet-stream\"\n\t}\n\n\tprops := s.Properties\n\tfor _, ps := range props {\n\t\tif ps.hidden {\n\t\t\t// Copy the map to avoid modifying the original schema.\n\t\t\tprops = make(map[string]*Schema, len(s.Properties))\n\t\t\tfor k, v := range s.Properties {\n\t\t\t\tif !v.hidden {\n\t\t\t\t\tprops[k] = v\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn marshalJSON([]jsonFieldInfo{\n\t\t{\"type\", typ, omitEmpty},\n\t\t{\"title\", s.Title, omitEmpty},\n\t\t{\"description\", s.Description, omitEmpty},\n\t\t{\"$ref\", s.Ref, omitEmpty},\n\t\t{\"format\", s.Format, omitEmpty},\n\t\t{\"contentMediaType\", contentMediaType, omitEmpty},\n\t\t{\"contentEncoding\", s.ContentEncoding, omitEmpty},\n\t\t{\"default\", s.Default, omitNil},\n\t\t{\"examples\", s.Examples, omitEmpty},\n\t\t{\"items\", s.Items, omitEmpty},\n\t\t{\"additionalProperties\", s.AdditionalProperties, omitNil},\n\t\t{\"properties\", props, omitEmpty},\n\t\t{\"enum\", s.Enum, omitEmpty},\n\t\t{\"minimum\", s.Minimum, omitEmpty},\n\t\t{\"exclusiveMinimum\", s.ExclusiveMinimum, omitEmpty},\n\t\t{\"maximum\", s.Maximum, omitEmpty},\n\t\t{\"exclusiveMaximum\", s.ExclusiveMaximum, omitEmpty},\n\t\t{\"multipleOf\", s.MultipleOf, omitEmpty},\n\t\t{\"minLength\", s.MinLength, omitEmpty},\n\t\t{\"maxLength\", s.MaxLength, omitEmpty},\n\t\t{\"pattern\", s.Pattern, omitEmpty},\n\t\t{\"patternDescription\", s.PatternDescription, omitEmpty},\n\t\t{\"minItems\", s.MinItems, omitEmpty},\n\t\t{\"maxItems\", s.MaxItems, omitEmpty},\n\t\t{\"uniqueItems\", s.UniqueItems, omitEmpty},\n\t\t{\"required\", s.Required, omitEmpty},\n\t\t{\"dependentRequired\", s.DependentRequired, omitEmpty},\n\t\t{\"minProperties\", s.MinProperties, omitEmpty},\n\t\t{\"maxProperties\", s.MaxProperties, omitEmpty},\n\t\t{\"readOnly\", s.ReadOnly, omitEmpty},\n\t\t{\"writeOnly\", s.WriteOnly, omitEmpty},\n\t\t{\"deprecated\", s.Deprecated, omitEmpty},\n\t\t{\"oneOf\", s.OneOf, omitEmpty},\n\t\t{\"anyOf\", s.AnyOf, omitEmpty},\n\t\t{\"allOf\", s.AllOf, omitEmpty},\n\t\t{\"not\", s.Not, omitEmpty},\n\t\t{\"discriminator\", s.Discriminator, omitEmpty},\n\t}, s.Extensions)\n}\n\n// PrecomputeMessages tries to precompute as many validation error messages\n// as possible so that new strings aren't allocated during request validation.\nfunc (s *Schema) PrecomputeMessages() {\n\ts.msgEnum = ErrorFormatter(validation.MsgExpectedOneOf, strings.Join(mapTo(s.Enum, func(v any) string {\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}), \", \"))\n\tif s.Minimum != nil {\n\t\ts.msgMinimum = ErrorFormatter(validation.MsgExpectedMinimumNumber, *s.Minimum)\n\t}\n\tif s.ExclusiveMinimum != nil {\n\t\ts.msgExclusiveMinimum = ErrorFormatter(validation.MsgExpectedExclusiveMinimumNumber, *s.ExclusiveMinimum)\n\t}\n\tif s.Maximum != nil {\n\t\ts.msgMaximum = ErrorFormatter(validation.MsgExpectedMaximumNumber, *s.Maximum)\n\t}\n\tif s.ExclusiveMaximum != nil {\n\t\ts.msgExclusiveMaximum = ErrorFormatter(validation.MsgExpectedExclusiveMaximumNumber, *s.ExclusiveMaximum)\n\t}\n\tif s.MultipleOf != nil {\n\t\ts.msgMultipleOf = ErrorFormatter(validation.MsgExpectedNumberBeMultipleOf, *s.MultipleOf)\n\t}\n\tif s.MinLength != nil {\n\t\ts.msgMinLength = ErrorFormatter(validation.MsgExpectedMinLength, *s.MinLength)\n\t}\n\tif s.MaxLength != nil {\n\t\ts.msgMaxLength = ErrorFormatter(validation.MsgExpectedMaxLength, *s.MaxLength)\n\t}\n\tif s.Pattern != \"\" {\n\t\ts.patternRe = regexp.MustCompile(s.Pattern)\n\t\tif s.PatternDescription != \"\" {\n\t\t\ts.msgPattern = ErrorFormatter(validation.MsgExpectedBePattern, s.PatternDescription)\n\t\t} else {\n\t\t\ts.msgPattern = ErrorFormatter(validation.MsgExpectedMatchPattern, s.Pattern)\n\t\t}\n\t}\n\tif s.MinItems != nil {\n\t\ts.msgMinItems = ErrorFormatter(validation.MsgExpectedMinItems, *s.MinItems)\n\t}\n\tif s.MaxItems != nil {\n\t\ts.msgMaxItems = ErrorFormatter(validation.MsgExpectedMaxItems, *s.MaxItems)\n\t}\n\tif s.MinProperties != nil {\n\t\ts.msgMinProperties = ErrorFormatter(validation.MsgExpectedMinProperties, *s.MinProperties)\n\t}\n\tif s.MaxProperties != nil {\n\t\ts.msgMaxProperties = ErrorFormatter(validation.MsgExpectedMaxProperties, *s.MaxProperties)\n\t}\n\n\tif s.Required != nil {\n\t\tif s.msgRequired == nil {\n\t\t\ts.msgRequired = map[string]string{}\n\t\t}\n\t\tfor _, name := range s.Required {\n\t\t\ts.msgRequired[name] = ErrorFormatter(validation.MsgExpectedRequiredProperty, name)\n\t\t}\n\t}\n\n\tif s.DependentRequired != nil {\n\t\tif s.msgDependentRequired == nil {\n\t\t\ts.msgDependentRequired = map[string]map[string]string{}\n\t\t}\n\t\tfor name, dependents := range s.DependentRequired {\n\t\t\tfor _, dependent := range dependents {\n\t\t\t\tif s.msgDependentRequired[name] == nil {\n\t\t\t\t\ts.msgDependentRequired[name] = map[string]string{}\n\t\t\t\t}\n\t\t\t\ts.msgDependentRequired[name][dependent] = ErrorFormatter(validation.MsgExpectedDependentRequiredProperty, dependent, name)\n\t\t\t}\n\t\t}\n\t}\n\n\ts.propertyNames = make([]string, 0, len(s.Properties))\n\tfor name := range s.Properties {\n\t\ts.propertyNames = append(s.propertyNames, name)\n\t}\n\tsort.Strings(s.propertyNames)\n\n\ts.requiredMap = map[string]bool{}\n\tfor _, name := range s.Required {\n\t\ts.requiredMap[name] = true\n\t}\n\n\tif s.Items != nil {\n\t\ts.Items.PrecomputeMessages()\n\t}\n\n\tfor _, prop := range s.Properties {\n\t\tprop.PrecomputeMessages()\n\t}\n\n\tfor _, sub := range s.OneOf {\n\t\tsub.PrecomputeMessages()\n\t}\n\n\tfor _, sub := range s.AnyOf {\n\t\tsub.PrecomputeMessages()\n\t}\n\n\tfor _, sub := range s.AllOf {\n\t\tsub.PrecomputeMessages()\n\t}\n\n\tif sub := s.Not; sub != nil {\n\t\tsub.PrecomputeMessages()\n\t}\n}\n\nfunc boolTag(f reflect.StructField, tag string, def bool) bool {\n\tif v := f.Tag.Get(tag); v != \"\" {\n\t\tswitch v {\n\t\tcase \"true\":\n\t\t\treturn true\n\t\tcase \"false\":\n\t\t\treturn false\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf(\"invalid bool tag '%s' for field '%s': %v\", tag, f.Name, v))\n\t\t}\n\t}\n\treturn def\n}\n\nfunc intTag(f reflect.StructField, tag string, def *int) *int {\n\tif v := f.Tag.Get(tag); v != \"\" {\n\t\tif i, err := strconv.Atoi(v); err == nil {\n\t\t\treturn &i\n\t\t} else {\n\t\t\tpanic(fmt.Errorf(\"invalid int tag '%s' for field '%s': %v (%w)\", tag, f.Name, v, err))\n\t\t}\n\t}\n\treturn def\n}\n\nfunc floatTag(f reflect.StructField, tag string, def *float64) *float64 {\n\tif v := f.Tag.Get(tag); v != \"\" {\n\t\tif i, err := strconv.ParseFloat(v, 64); err == nil {\n\t\t\treturn &i\n\t\t} else {\n\t\t\tpanic(fmt.Errorf(\"invalid float tag '%s' for field '%s': %v (%w)\", tag, f.Name, v, err))\n\t\t}\n\t}\n\treturn def\n}\n\nfunc stringTag(f reflect.StructField, tag string, def string) string {\n\tif v := f.Tag.Get(tag); v != \"\" {\n\t\treturn v\n\t}\n\treturn def\n}\n\n// ensureType panics if the given value does not match the JSON Schema type.\nfunc ensureType(r Registry, fieldName string, s *Schema, value string, v any) {\n\tif s.Ref != \"\" {\n\t\ts = r.SchemaFromRef(s.Ref)\n\t\tif s == nil {\n\t\t\t// We may not have access to this type, e.g. custom schema provided\n\t\t\t// by the user with remote refs. Skip validation.\n\t\t\treturn\n\t\t}\n\t}\n\n\tswitch s.Type {\n\tcase TypeBoolean:\n\t\tif _, ok := v.(bool); !ok {\n\t\t\tpanic(fmt.Errorf(\"invalid boolean tag value '%s' for field '%s': %w\", value, fieldName, ErrSchemaInvalid))\n\t\t}\n\tcase TypeInteger, TypeNumber:\n\t\tif _, ok := v.(float64); !ok {\n\t\t\tpanic(fmt.Errorf(\"invalid number tag value '%s' for field '%s': %w\", value, fieldName, ErrSchemaInvalid))\n\t\t}\n\n\t\tif s.Type == TypeInteger {\n\t\t\tif v.(float64) != float64(int(v.(float64))) {\n\t\t\t\tpanic(fmt.Errorf(\"invalid integer tag value '%s' for field '%s': %w\", value, fieldName, ErrSchemaInvalid))\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tif _, ok := v.(string); !ok {\n\t\t\tpanic(fmt.Errorf(\"invalid string tag value '%s' for field '%s': %w\", value, fieldName, ErrSchemaInvalid))\n\t\t}\n\tcase TypeArray:\n\t\tif _, ok := v.([]any); !ok {\n\t\t\tpanic(fmt.Errorf(\"invalid array tag value '%s' for field '%s': %w\", value, fieldName, ErrSchemaInvalid))\n\t\t}\n\n\t\tif s.Items != nil {\n\t\t\tfor i, item := range v.([]any) {\n\t\t\t\tb, _ := json.Marshal(item)\n\t\t\t\tensureType(r, fieldName+\"[\"+strconv.Itoa(i)+\"]\", s.Items, string(b), item)\n\t\t\t}\n\t\t}\n\tcase TypeObject:\n\t\tif _, ok := v.(map[string]any); !ok {\n\t\t\tpanic(fmt.Errorf(\"invalid object tag value '%s' for field '%s': %w\", value, fieldName, ErrSchemaInvalid))\n\t\t}\n\n\t\tfor name, prop := range s.Properties {\n\t\t\tif val, ok := v.(map[string]any)[name]; ok {\n\t\t\t\tb, _ := json.Marshal(val)\n\t\t\t\tensureType(r, fieldName+\".\"+name, prop, string(b), val)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// convertType panics if the given value does not match or cannot be converted\n// to the field's Go type.\nfunc convertType(fieldName string, t reflect.Type, v any) any {\n\tvv := reflect.ValueOf(v)\n\ttv := reflect.TypeOf(v)\n\tif v != nil && tv != t {\n\t\tif tv.Kind() == reflect.Slice {\n\t\t\t// Slices can't be cast due to the different layouts. Instead, we make a\n\t\t\t// new instance of the destination slice, and convert each value in\n\t\t\t// the original to the new type.\n\t\t\ttmp := reflect.MakeSlice(t, 0, vv.Len())\n\t\t\tfor i := 0; i < vv.Len(); i++ {\n\t\t\t\titem := vv.Index(i)\n\t\t\t\tif item.Kind() == reflect.Interface {\n\t\t\t\t\t// E.g. []any and we want the underlying type.\n\t\t\t\t\titem = item.Elem()\n\t\t\t\t}\n\t\t\t\titem = reflect.Indirect(item)\n\t\t\t\ttyp := deref(t.Elem())\n\t\t\t\tif !item.Type().ConvertibleTo(typ) {\n\t\t\t\t\tpanic(fmt.Errorf(\"unable to convert %v to %v for field '%s': %w\", item.Interface(), t.Elem(), fieldName, ErrSchemaInvalid))\n\t\t\t\t}\n\n\t\t\t\tvalue := item.Convert(typ)\n\t\t\t\tif t.Elem().Kind() == reflect.Ptr {\n\t\t\t\t\t// Special case: if the field is a pointer, we need to get a pointer\n\t\t\t\t\t// to the converted value.\n\t\t\t\t\tptr := reflect.New(value.Type())\n\t\t\t\t\tptr.Elem().Set(value)\n\t\t\t\t\tvalue = ptr\n\t\t\t\t}\n\n\t\t\t\ttmp = reflect.Append(tmp, value)\n\t\t\t}\n\t\t\tv = tmp.Interface()\n\t\t} else if !tv.ConvertibleTo(deref(t)) {\n\t\t\tpanic(fmt.Errorf(\"unable to convert %v to %v for field '%s': %w\", tv, t, fieldName, ErrSchemaInvalid))\n\t\t}\n\n\t\tconverted := reflect.ValueOf(v).Convert(deref(t))\n\t\tif t.Kind() == reflect.Ptr {\n\t\t\t// Special case: if the field is a pointer, we need to get a pointer\n\t\t\t// to the converted value.\n\t\t\ttmp := reflect.New(t.Elem())\n\t\t\ttmp.Elem().Set(converted)\n\t\t\tconverted = tmp\n\t\t}\n\t\tv = converted.Interface()\n\t}\n\treturn v\n}\n\nfunc jsonTagValue(r Registry, fieldName string, s *Schema, value string) any {\n\tif s.Ref != \"\" {\n\t\ts = r.SchemaFromRef(s.Ref)\n\t\tif s == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Special case: strings don't need quotes.\n\tif s.Type == TypeString {\n\t\treturn value\n\t}\n\n\t// Special case: array of strings with comma-separated values and no quotes.\n\tif s.Type == TypeArray && s.Items != nil && s.Items.Type == TypeString && value[0] != '[' {\n\t\tvalues := []string{}\n\t\tfor _, s := range strings.Split(value, \",\") {\n\t\t\tvalues = append(values, strings.TrimSpace(s))\n\t\t}\n\t\treturn values\n\t}\n\n\tvar v any\n\tif err := json.Unmarshal([]byte(value), &v); err != nil {\n\t\tpanic(fmt.Errorf(\"invalid %s tag value '%s' for field '%s': %w\", s.Type, value, fieldName, err))\n\t}\n\n\tensureType(r, fieldName, s, value, v)\n\n\treturn v\n}\n\n// jsonTag returns a value of the schema's type for the given tag string.\n// Uses JSON parsing if the schema is not a string.\nfunc jsonTag(r Registry, f reflect.StructField, s *Schema, name string) any {\n\tt := f.Type\n\tif value := f.Tag.Get(name); value != \"\" {\n\t\treturn convertType(f.Name, t, jsonTagValue(r, f.Name, s, value))\n\t}\n\treturn nil\n}\n\n// SchemaFromField generates a schema for a given struct field. If the field\n// is a struct (or slice/map of structs) then the registry is used to\n// potentially get a reference to that type.\n//\n// This is used by `huma.SchemaFromType` when it encounters a struct, and\n// is used to generate schemas for path/query/header parameters.\nfunc SchemaFromField(registry Registry, f reflect.StructField, hint string) *Schema {\n\tfs := registry.Schema(f.Type, true, hint)\n\tif fs == nil {\n\t\treturn fs\n\t}\n\tfs.Description = stringTag(f, \"doc\", fs.Description)\n\tif fs.Format == \"date-time\" && f.Tag.Get(\"header\") != \"\" {\n\t\t// Special case: this is a header and uses a different date/time format.\n\t\t// Note that it can still be overridden by the `format` or `timeFormat`\n\t\t// tags later.\n\t\tfs.Format = \"date-time-http\"\n\t}\n\tfs.Format = stringTag(f, \"format\", fs.Format)\n\tif timeFmt := f.Tag.Get(\"timeFormat\"); timeFmt != \"\" {\n\t\tswitch timeFmt {\n\t\tcase \"2006-01-02\":\n\t\t\tfs.Format = \"date\"\n\t\tcase \"15:04:05\":\n\t\t\tfs.Format = \"time\"\n\t\tdefault:\n\t\t\tfs.Format = timeFmt\n\t\t}\n\t}\n\tfs.ContentEncoding = stringTag(f, \"encoding\", fs.ContentEncoding)\n\tif defaultValue := jsonTag(registry, f, fs, \"default\"); defaultValue != nil {\n\t\tfs.Default = defaultValue\n\t}\n\n\tif value := f.Tag.Get(\"example\"); value != \"\" {\n\t\tif e := jsonTagValue(registry, f.Name, fs, value); e != nil {\n\t\t\tfs.Examples = []any{e}\n\t\t}\n\t}\n\n\tif enum := f.Tag.Get(\"enum\"); enum != \"\" {\n\t\ts := fs\n\t\tif s.Type == TypeArray {\n\t\t\ts = s.Items\n\t\t}\n\t\tenumValues := []any{}\n\t\tfor _, e := range strings.Split(enum, \",\") {\n\t\t\tenumValues = append(enumValues, jsonTagValue(registry, f.Name, s, e))\n\t\t}\n\t\tif fs.Type == TypeArray {\n\t\t\tfs.Items.Enum = enumValues\n\t\t} else {\n\t\t\tfs.Enum = enumValues\n\t\t}\n\t}\n\n\tfs.Nullable = boolTag(f, \"nullable\", fs.Nullable)\n\tif fs.Nullable && fs.Ref != \"\" && registry.SchemaFromRef(fs.Ref).Type == \"object\" {\n\t\t// Nullability is only supported for scalar types for now. Objects are\n\t\t// much more complicated because the `null` type lives within the object\n\t\t// definition (requiring multiple copies of the object) or needs to use\n\t\t// `anyOf` or `not` which is not supported by all code generators, or is\n\t\t// supported poorly & generates hard-to-use code. This is less than ideal\n\t\t// but a compromise for now to support some nullability built-in.\n\t\tpanic(fmt.Errorf(\"nullable is not supported for field '%s' which is type '%s'\", f.Name, fs.Ref))\n\t}\n\n\tfs.Minimum = floatTag(f, \"minimum\", fs.Minimum)\n\tfs.ExclusiveMinimum = floatTag(f, \"exclusiveMinimum\", fs.ExclusiveMinimum)\n\tfs.Maximum = floatTag(f, \"maximum\", fs.Maximum)\n\tfs.ExclusiveMaximum = floatTag(f, \"exclusiveMaximum\", fs.ExclusiveMaximum)\n\tfs.MultipleOf = floatTag(f, \"multipleOf\", fs.MultipleOf)\n\tfs.MinLength = intTag(f, \"minLength\", fs.MinLength)\n\tfs.MaxLength = intTag(f, \"maxLength\", fs.MaxLength)\n\tfs.Pattern = stringTag(f, \"pattern\", fs.Pattern)\n\tfs.PatternDescription = stringTag(f, \"patternDescription\", fs.PatternDescription)\n\tfs.MinItems = intTag(f, \"minItems\", fs.MinItems)\n\tfs.MaxItems = intTag(f, \"maxItems\", fs.MaxItems)\n\tfs.UniqueItems = boolTag(f, \"uniqueItems\", fs.UniqueItems)\n\tfs.MinProperties = intTag(f, \"minProperties\", fs.MinProperties)\n\tfs.MaxProperties = intTag(f, \"maxProperties\", fs.MaxProperties)\n\tfs.ReadOnly = boolTag(f, \"readOnly\", fs.ReadOnly)\n\tfs.WriteOnly = boolTag(f, \"writeOnly\", fs.WriteOnly)\n\tfs.Deprecated = boolTag(f, \"deprecated\", fs.Deprecated)\n\tfs.PrecomputeMessages()\n\n\tfs.hidden = boolTag(f, \"hidden\", fs.hidden)\n\n\treturn fs\n}\n\n// fieldInfo stores information about a field, which may come from an\n// embedded type. The `Parent` stores the field's direct parent.\ntype fieldInfo struct {\n\tParent reflect.Type\n\tField  reflect.StructField\n}\n\n// getFields performs a breadth-first search for all fields including embedded\n// ones. It may return multiple fields with the same name, the first of which\n// represents the outermost declaration.\nfunc getFields(typ reflect.Type, visited map[reflect.Type]struct{}) []fieldInfo {\n\tfields := make([]fieldInfo, 0, typ.NumField())\n\tvar embedded []reflect.StructField\n\n\tif _, ok := visited[typ]; ok {\n\t\treturn fields\n\t}\n\tvisited[typ] = struct{}{}\n\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tf := typ.Field(i)\n\t\tif !f.IsExported() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif f.Anonymous {\n\t\t\tembedded = append(embedded, f)\n\t\t\tcontinue\n\t\t}\n\n\t\tfields = append(fields, fieldInfo{typ, f})\n\t}\n\n\tfor _, f := range embedded {\n\t\tnewTyp := f.Type\n\t\tfor newTyp.Kind() == reflect.Ptr {\n\t\t\tnewTyp = newTyp.Elem()\n\t\t}\n\t\tif newTyp.Kind() == reflect.Struct {\n\t\t\tfields = append(fields, getFields(newTyp, visited)...)\n\t\t}\n\t}\n\n\treturn fields\n}\n\n// SchemaProvider is an interface that can be implemented by types to provide\n// a custom schema for themselves, overriding the built-in schema generation.\n// This can be used by custom types with their own special serialization rules.\ntype SchemaProvider interface {\n\tSchema(r Registry) *Schema\n}\n\n// SchemaTransformer is an interface that can be implemented by types\n// to transform the generated schema as needed.\n// This can be used to leverage the default schema generation for a type,\n// and arbitrarily modify parts of it.\ntype SchemaTransformer interface {\n\tTransformSchema(r Registry, s *Schema) *Schema\n}\n\n// SchemaFromType returns a schema for a given type, using the registry to\n// possibly create references for nested structs. The schema that is returned\n// can then be passed to `huma.Validate` to efficiently validate incoming\n// requests.\n//\n//\t// Create a registry and register a type.\n//\tregistry := huma.NewMapRegistry(\"#/prefix\", huma.DefaultSchemaNamer)\n//\tschema := huma.SchemaFromType(registry, reflect.TypeOf(MyType{}))\nfunc SchemaFromType(r Registry, t reflect.Type) *Schema {\n\ts := schemaFromType(r, t)\n\tt = deref(t)\n\n\t// Transform generated schema if type implements SchemaTransformer\n\tv := reflect.New(t).Interface()\n\tif st, ok := v.(SchemaTransformer); ok {\n\t\ts = st.TransformSchema(r, s)\n\n\t\t// The schema may have been modified, so recompute the error messages.\n\t\ts.PrecomputeMessages()\n\t}\n\treturn s\n}\n\nfunc schemaFromType(r Registry, t reflect.Type) *Schema {\n\tisPointer := t.Kind() == reflect.Pointer\n\n\ts := Schema{}\n\tt = deref(t)\n\n\tv := reflect.New(t).Interface()\n\tif sp, ok := v.(SchemaProvider); ok {\n\t\t// Special case: type provides its own schema. Do not try to generate.\n\t\tcustom := sp.Schema(r)\n\t\tcustom.PrecomputeMessages()\n\t\treturn custom\n\t}\n\n\t// Handle special cases for known stdlib types.\n\tswitch t {\n\tcase timeType:\n\t\treturn &Schema{Type: TypeString, Nullable: isPointer, Format: \"date-time\"}\n\tcase urlType:\n\t\treturn &Schema{Type: TypeString, Nullable: isPointer, Format: \"uri\"}\n\tcase ipType:\n\t\treturn &Schema{Type: TypeString, Nullable: isPointer, Format: \"ipv4\"}\n\tcase ipAddrType:\n\t\treturn &Schema{Type: TypeString, Nullable: isPointer, Format: \"ipv4\"}\n\tcase rawMessageType:\n\t\treturn &Schema{}\n\t}\n\n\tif _, ok := v.(encoding.TextUnmarshaler); ok {\n\t\t// Special case: types that implement encoding.TextUnmarshaler are able to\n\t\t// be loaded from plain text, and so should be treated as strings.\n\t\t// This behavior can be overridden by implementing `huma.SchemaProvider`\n\t\t// and returning a custom schema.\n\t\treturn &Schema{Type: TypeString, Nullable: isPointer}\n\t}\n\n\tminZero := 0.0\n\tswitch t.Kind() {\n\tcase reflect.Bool:\n\t\ts.Type = TypeBoolean\n\tcase reflect.Int:\n\t\ts.Type = TypeInteger\n\t\tif bits.UintSize == 32 {\n\t\t\ts.Format = \"int32\"\n\t\t} else {\n\t\t\ts.Format = \"int64\"\n\t\t}\n\tcase reflect.Int8, reflect.Int16, reflect.Int32:\n\t\ts.Type = TypeInteger\n\t\ts.Format = \"int32\"\n\tcase reflect.Int64:\n\t\ts.Type = TypeInteger\n\t\ts.Format = \"int64\"\n\tcase reflect.Uint:\n\t\ts.Type = TypeInteger\n\t\tif bits.UintSize == 32 {\n\t\t\ts.Format = \"int32\"\n\t\t} else {\n\t\t\ts.Format = \"int64\"\n\t\t}\n\t\ts.Minimum = &minZero\n\tcase reflect.Uint8, reflect.Uint16, reflect.Uint32:\n\t\t// Unsigned integers can't be negative.\n\t\ts.Type = TypeInteger\n\t\ts.Format = \"int32\"\n\t\ts.Minimum = &minZero\n\tcase reflect.Uint64:\n\t\t// Unsigned integers can't be negative.\n\t\ts.Type = TypeInteger\n\t\ts.Format = \"int64\"\n\t\ts.Minimum = &minZero\n\tcase reflect.Float32:\n\t\ts.Type = TypeNumber\n\t\ts.Format = \"float\"\n\tcase reflect.Float64:\n\t\ts.Type = TypeNumber\n\t\ts.Format = \"double\"\n\tcase reflect.String:\n\t\ts.Type = TypeString\n\tcase reflect.Slice, reflect.Array:\n\t\tif t.Elem().Kind() == reflect.Uint8 {\n\t\t\t// Special case: []byte will be serialized as a base64 string.\n\t\t\ts.Type = TypeString\n\t\t\ts.ContentEncoding = \"base64\"\n\t\t} else {\n\t\t\ts.Type = TypeArray\n\t\t\ts.Nullable = DefaultArrayNullable\n\t\t\ts.Items = r.Schema(t.Elem(), true, t.Name()+\"Item\")\n\n\t\t\tif t.Kind() == reflect.Array {\n\t\t\t\tl := t.Len()\n\t\t\t\ts.MinItems = &l\n\t\t\t\ts.MaxItems = &l\n\t\t\t}\n\t\t}\n\tcase reflect.Map:\n\t\ts.Type = TypeObject\n\t\ts.AdditionalProperties = r.Schema(t.Elem(), true, t.Name()+\"Value\")\n\tcase reflect.Struct:\n\t\tvar required []string\n\t\trequiredMap := map[string]bool{}\n\t\tvar propNames []string\n\t\tfieldSet := map[string]struct{}{}\n\t\tprops := map[string]*Schema{}\n\t\tdependentRequiredMap := map[string][]string{}\n\t\tfor _, info := range getFields(t, make(map[reflect.Type]struct{})) {\n\t\t\tf := info.Field\n\n\t\t\tif _, ok := fieldSet[f.Name]; ok {\n\t\t\t\t// This field was overridden by an ancestor type, so we\n\t\t\t\t// should ignore it.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfieldSet[f.Name] = struct{}{}\n\n\t\t\t// Controls whether the field is required or not. All fields start as\n\t\t\t// required, then can be made optional with the `omitempty` JSON tag or it\n\t\t\t// can be overridden manually via the `required` tag.\n\t\t\tfieldRequired := true\n\n\t\t\tname := f.Name\n\t\t\tif j := f.Tag.Get(\"json\"); j != \"\" {\n\t\t\t\tif n := strings.Split(j, \",\")[0]; n != \"\" {\n\t\t\t\t\tname = n\n\t\t\t\t}\n\t\t\t\tif strings.Contains(j, \"omitempty\") {\n\t\t\t\t\tfieldRequired = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif name == \"-\" {\n\t\t\t\t// This field is deliberately ignored.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif _, ok := f.Tag.Lookup(\"required\"); ok {\n\t\t\t\tfieldRequired = boolTag(f, \"required\", false)\n\t\t\t}\n\n\t\t\tif dr := f.Tag.Get(\"dependentRequired\"); strings.TrimSpace(dr) != \"\" {\n\t\t\t\tdependentRequiredMap[name] = strings.Split(dr, \",\")\n\t\t\t}\n\n\t\t\tfs := SchemaFromField(r, f, t.Name()+f.Name+\"Struct\")\n\t\t\tif fs != nil {\n\t\t\t\tprops[name] = fs\n\t\t\t\tpropNames = append(propNames, name)\n\n\t\t\t\tif fs.hidden {\n\t\t\t\t\t// This field is deliberately ignored. It may still exist, but won't\n\t\t\t\t\t// be documented as a required field.\n\t\t\t\t\tfieldRequired = false\n\t\t\t\t}\n\n\t\t\t\tif fieldRequired {\n\t\t\t\t\trequired = append(required, name)\n\t\t\t\t\trequiredMap[name] = true\n\t\t\t\t}\n\n\t\t\t\t// Special case: pointer with omitempty and not manually set to\n\t\t\t\t// nullable, which will never get `null` sent over the wire.\n\t\t\t\tif f.Type.Kind() == reflect.Ptr && strings.Contains(f.Tag.Get(\"json\"), \"omitempty\") && f.Tag.Get(\"nullable\") != \"true\" {\n\t\t\t\t\tfs.Nullable = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts.Type = TypeObject\n\n\t\t// Check if the dependent fields exists. If they don't, panic with the correct message.\n\t\tvar errs []string\n\t\tdepKeys := make([]string, 0, len(dependentRequiredMap))\n\t\tfor field := range dependentRequiredMap {\n\t\t\tdepKeys = append(depKeys, field)\n\t\t}\n\t\tsort.Strings(depKeys)\n\t\tfor _, field := range depKeys {\n\t\t\tdependents := dependentRequiredMap[field]\n\t\t\tfor _, dependent := range dependents {\n\t\t\t\tif _, ok := props[dependent]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\terrs = append(errs, fmt.Sprintf(\"dependent field '%s' for field '%s' does not exist\", dependent, field))\n\t\t\t}\n\t\t}\n\t\tif errs != nil {\n\t\t\tpanic(errors.New(strings.Join(errs, \"; \")))\n\t\t}\n\n\t\tadditionalProps := false\n\t\tif f, ok := t.FieldByName(\"_\"); ok {\n\t\t\tif _, ok = f.Tag.Lookup(\"additionalProperties\"); ok {\n\t\t\t\tadditionalProps = boolTag(f, \"additionalProperties\", false)\n\t\t\t}\n\n\t\t\tif _, ok := f.Tag.Lookup(\"nullable\"); ok {\n\t\t\t\t// Allow overriding nullability per struct.\n\t\t\t\ts.Nullable = boolTag(f, \"nullable\", false)\n\t\t\t}\n\t\t}\n\t\ts.AdditionalProperties = additionalProps\n\n\t\ts.Properties = props\n\t\ts.propertyNames = propNames\n\t\ts.Required = required\n\t\ts.DependentRequired = dependentRequiredMap\n\t\ts.requiredMap = requiredMap\n\t\ts.PrecomputeMessages()\n\tcase reflect.Interface:\n\t\t// Interfaces mean any object.\n\tdefault:\n\t\treturn nil\n\t}\n\n\tswitch s.Type {\n\tcase TypeBoolean, TypeInteger, TypeNumber, TypeString:\n\t\t// Scalar types which are pointers are nullable by default. This can be\n\t\t// overridden via the `nullable:\"false\"` field tag in structs.\n\t\ts.Nullable = isPointer\n\t}\n\n\treturn &s\n}\n"
        },
        {
          "name": "schema_test.go",
          "type": "blob",
          "size": 34.7021484375,
          "content": "package huma_test\n\nimport (\n\t\"bytes\"\n\t\"encoding\"\n\t\"encoding/json\"\n\t\"math/bits\"\n\t\"net\"\n\t\"net/netip\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n)\n\ntype RecursiveChildKey struct {\n\tKey  string             `json:\"key\"`\n\tSelf *RecursiveChildKey `json:\"self,omitempty\"`\n}\n\ntype RecursiveChild struct {\n\tRecursiveChildLoop\n}\n\ntype RecursiveChildLoop struct {\n\t*RecursiveChild\n\tSlice   []*RecursiveChildLoop                    `json:\"slice\"`\n\tArray   [1]*RecursiveChildLoop                   `json:\"array\"`\n\tMap     map[RecursiveChildKey]RecursiveChildLoop `json:\"map\"`\n\tByValue RecursiveChildKey                        `json:\"byValue\"`\n\tByRef   *RecursiveChildKey                       `json:\"byRef\"`\n}\n\ntype EmbeddedChild struct {\n\t// This one should be ignored as it is overridden by `Embedded`.\n\tValue string `json:\"value\" doc:\"old doc\"`\n}\n\ntype Embedded struct {\n\tEmbeddedChild\n\tValue string `json:\"value\" doc:\"new doc\"`\n}\n\ntype CustomSchema struct{}\n\nfunc (c CustomSchema) Schema(r huma.Registry) *huma.Schema {\n\treturn &huma.Schema{\n\t\tType: \"string\",\n\t}\n}\n\nvar _ huma.SchemaProvider = CustomSchema{}\n\ntype BadRefSchema struct{}\n\nfunc (c BadRefSchema) Schema(r huma.Registry) *huma.Schema {\n\treturn &huma.Schema{\n\t\tRef: \"bad\",\n\t}\n}\n\nvar _ huma.SchemaProvider = BadRefSchema{}\n\ntype TypedArrayWithCustomDesc [4]float64\n\nfunc (t *TypedArrayWithCustomDesc) TransformSchema(r huma.Registry, s *huma.Schema) *huma.Schema {\n\ts.Description = \"custom description\"\n\treturn s\n}\n\nvar _ huma.SchemaTransformer = (*CustomSchemaPtr)(nil)\n\ntype CustomSchemaPtr struct {\n\tValue string `json:\"value\"`\n}\n\nfunc (c *CustomSchemaPtr) TransformSchema(r huma.Registry, s *huma.Schema) *huma.Schema {\n\ts.Description = \"custom description\"\n\treturn s\n}\n\ntype TypedStringWithCustomLength string\n\nfunc (c TypedStringWithCustomLength) Schema(r huma.Registry) *huma.Schema {\n\treturn &huma.Schema{\n\t\tType:      \"string\",\n\t\tMinLength: Ptr(1),\n\t\tMaxLength: Ptr(10),\n\t}\n}\n\ntype TypedIntegerWithCustomLimits int\n\nfunc (c *TypedIntegerWithCustomLimits) TransformSchema(r huma.Registry, s *huma.Schema) *huma.Schema {\n\ts.Minimum = Ptr(float64(1))\n\ts.Maximum = Ptr(float64(10))\n\treturn s\n}\n\nfunc TestSchema(t *testing.T) {\n\tbitSize := strconv.Itoa(bits.UintSize)\n\n\tcases := []struct {\n\t\tname     string\n\t\tinput    any\n\t\texpected string\n\t\tpanics   string\n\t}{\n\t\t{\n\t\t\tname:     \"bool\",\n\t\t\tinput:    true,\n\t\t\texpected: `{\"type\": \"boolean\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"bool-pointer\",\n\t\t\tinput:    Ptr(true),\n\t\t\texpected: `{\"type\": [\"boolean\", \"null\"]}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"int\",\n\t\t\tinput:    1,\n\t\t\texpected: `{\"type\": \"integer\", \"format\": \"int` + bitSize + `\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"int32\",\n\t\t\tinput:    int32(1),\n\t\t\texpected: `{\"type\": \"integer\", \"format\": \"int32\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"int64\",\n\t\t\tinput:    int64(1),\n\t\t\texpected: `{\"type\": \"integer\", \"format\": \"int64\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"uint\",\n\t\t\tinput:    uint(1),\n\t\t\texpected: `{\"type\": \"integer\", \"format\": \"int` + bitSize + `\", \"minimum\": 0}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"uint32\",\n\t\t\tinput:    uint32(1),\n\t\t\texpected: `{\"type\": \"integer\", \"format\": \"int32\", \"minimum\": 0}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64\",\n\t\t\tinput:    uint64(1),\n\t\t\texpected: `{\"type\": \"integer\", \"format\": \"int64\", \"minimum\": 0}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"float64\",\n\t\t\tinput:    1.0,\n\t\t\texpected: `{\"type\": \"number\", \"format\": \"double\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"float32\",\n\t\t\tinput:    float32(1.0),\n\t\t\texpected: `{\"type\": \"number\", \"format\": \"float\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"string\",\n\t\t\tinput:    \"test\",\n\t\t\texpected: `{\"type\": \"string\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"time\",\n\t\t\tinput:    time.Now(),\n\t\t\texpected: `{\"type\": \"string\", \"format\": \"date-time\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"time-pointer\",\n\t\t\tinput:    Ptr(time.Now()),\n\t\t\texpected: `{\"type\": [\"string\", \"null\"], \"format\": \"date-time\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"url\",\n\t\t\tinput:    url.URL{},\n\t\t\texpected: `{\"type\": \"string\", \"format\": \"uri\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"ip\",\n\t\t\tinput:    net.IPv4(127, 0, 0, 1),\n\t\t\texpected: `{\"type\": \"string\", \"format\": \"ipv4\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"ipAddr\",\n\t\t\tinput:    netip.AddrFrom4([4]byte{127, 0, 0, 1}),\n\t\t\texpected: `{\"type\": \"string\", \"format\": \"ipv4\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"json.RawMessage\",\n\t\t\tinput:    &json.RawMessage{},\n\t\t\texpected: `{}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"bytes\",\n\t\t\tinput:    []byte(\"test\"),\n\t\t\texpected: `{\"type\": \"string\", \"contentEncoding\": \"base64\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"array\",\n\t\t\tinput:    [2]int{1, 2},\n\t\t\texpected: `{\"type\": [\"array\", \"null\"], \"items\": {\"type\": \"integer\", \"format\": \"int64\"}, \"minItems\": 2, \"maxItems\": 2}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"slice\",\n\t\t\tinput:    []int{1, 2, 3},\n\t\t\texpected: `{\"type\": [\"array\", \"null\"], \"items\": {\"type\": \"integer\", \"format\": \"int64\"}}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"map\",\n\t\t\tinput:    map[string]string{\"foo\": \"bar\"},\n\t\t\texpected: `{\"type\": \"object\", \"additionalProperties\": {\"type\": \"string\"}}`,\n\t\t},\n\t\t{\n\t\t\tname: \"additionalProps\",\n\t\t\tinput: struct {\n\t\t\t\t_     struct{} `json:\"-\" additionalProperties:\"true\"`\n\t\t\t\tValue string   `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": true\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-int\",\n\t\t\tinput: struct {\n\t\t\t\tValue int `json:\"value\" minimum:\"1\" exclusiveMinimum:\"0\" maximum:\"10\" exclusiveMaximum:\"11\" multipleOf:\"2\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\"format\": \"int64\",\n\t\t\t\t\t\t\"minimum\": 1,\n\t\t\t\t\t\t\"exclusiveMinimum\": 0,\n\t\t\t\t\t\t\"maximum\": 10,\n\t\t\t\t\t\t\"exclusiveMaximum\": 11,\n\t\t\t\t\t\t\"multipleOf\": 2\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-string\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\"value\" minLength:\"1\" maxLength:\"10\" pattern:\"^foo$\" format:\"foo\" encoding:\"bar\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"minLength\": 1,\n\t\t\t\t\t\t\"maxLength\": 10,\n\t\t\t\t\t\t\"pattern\": \"^foo$\",\n\t\t\t\t\t\t\"format\": \"foo\",\n\t\t\t\t\t\t\"contentEncoding\": \"bar\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-array\",\n\t\t\tinput: struct {\n\t\t\t\tValue []int `json:\"value\" minItems:\"1\" maxItems:\"10\" uniqueItems:\"true\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": [\"array\", \"null\"],\n\t\t\t\t\t\t\"minItems\": 1,\n\t\t\t\t\t\t\"maxItems\": 10,\n\t\t\t\t\t\t\"uniqueItems\": true,\n\t\t\t\t\t\t\"items\": {\"type\": \"integer\", \"format\": \"int64\"}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-map\",\n\t\t\tinput: struct {\n\t\t\t\tValue map[string]string `json:\"value\" minProperties:\"2\" maxProperties:\"5\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\"minProperties\": 2,\n\t\t\t\t\t\t\"maxProperties\": 5,\n\t\t\t\t\t\t\"additionalProperties\": {\n\t\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-enum\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\"value\" enum:\"one,two\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"enum\": [\"one\", \"two\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-array-enum\",\n\t\t\tinput: struct {\n\t\t\t\tValue []int `json:\"value\" enum:\"1,2,3,5,8,11\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": [\"array\", \"null\"],\n\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\t\"format\": \"int64\",\n\t\t\t\t\t\t\t\"enum\": [1, 2, 3, 5, 8, 11]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"value\"],\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-readonly\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\"value\" readOnly:\"true\" writeOnly:\"false\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"readOnly\": true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-readonly-struct\",\n\t\t\tinput: struct {\n\t\t\t\tValue struct {\n\t\t\t\t\tFoo string `json:\"foo\"`\n\t\t\t\t} `json:\"value\" readOnly:\"true\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"$ref\": \"#/components/schemas/ValueStruct\",\n\t\t\t\t\t\t\"readOnly\": true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-default-string\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\"value\" default:\"foo\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"default\": \"foo\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-default-string-pointer\",\n\t\t\tinput: struct {\n\t\t\t\tValue *string `json:\"value,omitempty\" default:\"foo\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"default\": \"foo\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-default-array-string\",\n\t\t\tinput: struct {\n\t\t\t\tValue []string `json:\"value\" default:\"foo,bar\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": [\"array\", \"null\"],\n\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"default\": [\"foo\", \"bar\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-default-array-int\",\n\t\t\tinput: struct {\n\t\t\t\tValue []int `json:\"value\" default:\"[1,2]\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": [\"array\", \"null\"],\n\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\t\"format\": \"int64\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"default\": [1, 2]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-default-duration\",\n\t\t\tinput: struct {\n\t\t\t\tValue time.Duration `json:\"value\" default:\"5000\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\"format\": \"int64\",\n\t\t\t\t\t\t\"default\": 5000\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-optional-without-name\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\",omitempty\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"Value\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-example-custom\",\n\t\t\tinput: struct {\n\t\t\t\tValue CustomSchema `json:\"value\" example:\"foo\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"examples\": [\"foo\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-example-custom-pointer\",\n\t\t\tinput: struct {\n\t\t\t\tValue *CustomSchema `json:\"value\" example:\"foo\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"examples\": [\"foo\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-enum-custom\",\n\t\t\tinput: struct {\n\t\t\t\tValue OmittableNullable[string] `json:\"value,omitempty\" enum:\"foo,bar\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": [\"string\", \"null\"],\n\t\t\t\t\t\t\"enum\": [\"foo\", \"bar\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-any\",\n\t\t\tinput: struct {\n\t\t\t\tValue any `json:\"value\" doc:\"Some value\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"description\": \"Some value\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-dependent-required\",\n\t\t\tinput: struct {\n\t\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"dependent\"`\n\t\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t\t\tIgnored   string `json:\"ignored,omitempty\" dependentRequired:\"\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"dependent\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t},\n\t\t\t\t\t\"ignored\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"dependentRequired\": {\n\t\t\t\t\t\"value\": [\"dependent\"]\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\t// Bad ref should not panic, but should be ignored. These could be valid\n\t\t\t// custom schemas that Huma won't understand.\n\t\t\tname: \"field-custom-bad-ref\",\n\t\t\tinput: struct {\n\t\t\t\tValue  BadRefSchema `json:\"value\" example:\"true\"`\n\t\t\t\tValue2 struct {\n\t\t\t\t\tFoo BadRefSchema `json:\"foo\"`\n\t\t\t\t} `json:\"value2\" example:\"{\\\"foo\\\": true}\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"$ref\": \"bad\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value2\": {\n\t\t\t\t\t\t\"$ref\": \"#/components/schemas/Value2Struct\",\n\t\t\t\t\t\t\"examples\": [{\"foo\": true}]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value\", \"value2\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-skip\",\n\t\t\tinput: struct {\n\t\t\t\t// Not filtered out (just a normal field)\n\t\t\t\tValue1 string `json:\"value1\"`\n\t\t\t\t// Filtered out from JSON tag\n\t\t\t\tValue2 string `json:\"-\"`\n\t\t\t\t// Filtered because it's private\n\t\t\t\tvalue3 string\n\t\t\t\t// Filtered due to being an unsupported type\n\t\t\t\tValue4 func()\n\t\t\t\t// Filtered due to being hidden\n\t\t\t\tValue5 string `json:\"value4,omitempty\" hidden:\"true\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value1\"],\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value1\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-embed\",\n\t\t\tinput: struct {\n\t\t\t\t// Because this is embedded, the fields should be merged into\n\t\t\t\t// the parent object.\n\t\t\t\t*Embedded\n\t\t\t\tValue2 string `json:\"value2\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"value2\", \"value\"],\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"value\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"description\": \"new doc\"\n\t\t\t\t\t},\n\t\t\t\t\t\"value2\": {\n\t\t\t\t\t\t\"type\": \"string\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-embed-override\",\n\t\t\tinput: struct {\n\t\t\t\tEmbedded\n\t\t\t\tValue string `json:\"override\" doc:\"override\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"required\": [\"override\"],\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"override\": {\n\t\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\t\"description\": \"override\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-pointer-example\",\n\t\t\tinput: struct {\n\t\t\t\tInt *int64  `json:\"int\" example:\"123\"`\n\t\t\t\tStr *string `json:\"str\" example:\"foo\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"int\": {\n\t\t\t\t\t\t\"type\": [\"integer\", \"null\"],\n\t\t\t\t\t\t\"format\": \"int64\",\n\t\t\t\t\t\t\"examples\": [123]\n\t\t\t\t\t},\n\t\t\t\t\t\"str\": {\n\t\t\t\t\t\t\"type\": [\"string\", \"null\"],\n\t\t\t\t\t\t\"examples\": [\"foo\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"int\", \"str\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-nullable\",\n\t\t\tinput: struct {\n\t\t\t\tInt *int64 `json:\"int\" nullable:\"true\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"int\": {\n\t\t\t\t\t\t\"type\": [\"integer\", \"null\"],\n\t\t\t\t\t\t\"format\": \"int64\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"int\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-nullable-array\",\n\t\t\tinput: struct {\n\t\t\t\tInt []int64 `json:\"int\" nullable:\"true\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"int\": {\n\t\t\t\t\t\t\"type\": [\"array\", \"null\"],\n\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\t\"format\": \"int64\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"int\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-non-nullable-array\",\n\t\t\tinput: struct {\n\t\t\t\tInt []int64 `json:\"int\" nullable:\"false\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"int\": {\n\t\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\t\"type\": \"integer\",\n\t\t\t\t\t\t\t\"format\": \"int64\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"int\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-nullable-struct\",\n\t\t\tinput: struct {\n\t\t\t\tField struct {\n\t\t\t\t\t_   struct{} `json:\"-\" nullable:\"true\"`\n\t\t\t\t\tFoo string   `json:\"foo\"`\n\t\t\t\t} `json:\"field\"`\n\t\t\t}{},\n\t\t\texpected: `{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"additionalProperties\": false,\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"field\": {\n\t\t\t\t\t\t\"$ref\": \"#/components/schemas/FieldStruct\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\": [\"field\"]\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"recursive-embedded-structure\",\n\t\t\tinput: RecursiveChild{},\n\t\t\texpected: `{\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"array\":{\n\t\t\t\t\t\t\"items\":{\n\t\t\t\t\t\t\t\"$ref\":\"#/components/schemas/RecursiveChildLoop\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"maxItems\":1,\n\t\t\t\t\t\t\"minItems\":1,\n\t\t\t\t\t\t\"type\":[\"array\", \"null\"]\n\t\t\t\t\t},\n\t\t\t\t\t\"byRef\":{\n\t\t\t\t\t\t\"$ref\":\"#/components/schemas/RecursiveChildKey\"\n\t\t\t\t\t},\n\t\t\t\t\t\"byValue\":{\n\t\t\t\t\t\t\"$ref\":\"#/components/schemas/RecursiveChildKey\"\n\t\t\t\t\t},\n\t\t\t\t\t\"map\":{\n\t\t\t\t\t\t\"additionalProperties\":{\n\t\t\t\t\t\t\t\"$ref\":\"#/components/schemas/RecursiveChildLoop\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"type\":\"object\"\n\t\t\t\t\t},\n\t\t\t\t\t\"slice\":{\n\t\t\t\t\t\t\"items\":{\n\t\t\t\t\t\t\t\"$ref\":\"#/components/schemas/RecursiveChildLoop\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"type\":[\"array\", \"null\"]}\n\t\t\t\t\t},\n\t\t\t\t\t\"required\":[\"slice\",\"array\",\"map\",\"byValue\", \"byRef\"],\n\t\t\t\t\t\"type\":\"object\"\n\t\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-bool\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\"value\" readOnly:\"bad\"`\n\t\t\t}{},\n\t\t\tpanics: \"invalid bool tag 'readOnly' for field 'Value': bad\",\n\t\t},\n\t\t{\n\t\t\tname: \"panic-int\",\n\t\t\tinput: struct {\n\t\t\t\tValue string `json:\"value\" minLength:\"bad\"`\n\t\t\t}{},\n\t\t\tpanics: \"invalid int tag 'minLength' for field 'Value': bad (strconv.Atoi: parsing \\\"bad\\\": invalid syntax)\",\n\t\t},\n\t\t{\n\t\t\tname: \"panic-float\",\n\t\t\tinput: struct {\n\t\t\t\tValue int `json:\"value\" minimum:\"bad\"`\n\t\t\t}{},\n\t\t\tpanics: \"invalid float tag 'minimum' for field 'Value': bad (strconv.ParseFloat: parsing \\\"bad\\\": invalid syntax)\",\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json\",\n\t\t\tinput: struct {\n\t\t\t\tValue int `json:\"value\" default:\"bad\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid integer tag value 'bad' for field 'Value': invalid character 'b' looking for beginning of value`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-bool\",\n\t\t\tinput: struct {\n\t\t\t\tValue bool `json:\"value\" default:\"123\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid boolean tag value '123' for field 'Value': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-int\",\n\t\t\tinput: struct {\n\t\t\t\tValue int `json:\"value\" default:\"true\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid number tag value 'true' for field 'Value': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-int2\",\n\t\t\tinput: struct {\n\t\t\t\tValue int `json:\"value\" default:\"1.23\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid integer tag value '1.23' for field 'Value': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-array\",\n\t\t\tinput: struct {\n\t\t\t\tValue []int `json:\"value\" default:\"true\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid array tag value 'true' for field 'Value': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-array-value\",\n\t\t\tinput: struct {\n\t\t\t\tValue []string `json:\"value\" default:\"[true]\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid string tag value 'true' for field 'Value[0]': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-array-value\",\n\t\t\tinput: struct {\n\t\t\t\tValue []int `json:\"value\" default:\"[true]\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid number tag value 'true' for field 'Value[0]': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-object\",\n\t\t\tinput: struct {\n\t\t\t\tValue struct {\n\t\t\t\t\tFoo string `json:\"foo\"`\n\t\t\t\t} `json:\"value\" default:\"true\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid object tag value 'true' for field 'Value': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-json-object-field\",\n\t\t\tinput: struct {\n\t\t\t\tValue struct {\n\t\t\t\t\tFoo string `json:\"foo\"`\n\t\t\t\t} `json:\"value\" default:\"{\\\"foo\\\": true}\"`\n\t\t\t}{},\n\t\t\tpanics: `invalid string tag value 'true' for field 'Value.foo': schema is invalid`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-dependent-required\",\n\t\t\tinput: struct {\n\t\t\t\tValue1    string `json:\"value1,omitempty\" dependentRequired:\"missing1,missing2\"`\n\t\t\t\tValue2    string `json:\"value2,omitempty\" dependentRequired:\"missing2\"`\n\t\t\t\tValue3    string `json:\"value3,omitempty\" dependentRequired:\"dependent\"`\n\t\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t\t}{},\n\t\t\tpanics: `dependent field 'missing1' for field 'value1' does not exist; dependent field 'missing2' for field 'value1' does not exist; dependent field 'missing2' for field 'value2' does not exist`,\n\t\t},\n\t\t{\n\t\t\tname: \"panic-nullable-struct\",\n\t\t\tinput: struct {\n\t\t\t\tValue *struct {\n\t\t\t\t\tFoo string `json:\"foo\"`\n\t\t\t\t} `json:\"value\" nullable:\"true\"`\n\t\t\t}{},\n\t\t\tpanics: `nullable is not supported for field 'Value' which is type '#/components/schemas/ValueStruct'`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-custom-length-string-in-slice\",\n\t\t\tinput: struct {\n\t\t\t\tValues []TypedStringWithCustomLength `json:\"values\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"values\":{\n\t\t\t\t\t\t\"type\":[\"array\", \"null\"],\n\t\t\t\t\t\t\"items\":{\n\t\t\t\t\t\t\t\"type\":\"string\",\n\t\t\t\t\t\t\t\"minLength\":1,\n\t\t\t\t\t\t\t\"maxLength\":10\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"values\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-custom-length-string\",\n\t\t\tinput: struct {\n\t\t\t\tValue TypedStringWithCustomLength `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"type\":\"string\",\n\t\t\t\t\t\t\"minLength\":1,\n\t\t\t\t\t\t\"maxLength\":10\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-custom-length-string-with-tag\",\n\t\t\tinput: struct {\n\t\t\t\tValue TypedStringWithCustomLength `json:\"value\" maxLength:\"20\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"type\":\"string\",\n\t\t\t\t\t\t\"minLength\":1,\n\t\t\t\t\t\t\"maxLength\":20\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-ptr-to-custom-length-string\",\n\t\t\tinput: struct {\n\t\t\t\tValue *TypedStringWithCustomLength `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"type\":\"string\",\n\t\t\t\t\t\t\"minLength\":1,\n\t\t\t\t\t\t\"maxLength\":10\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-ptr-to-custom-length-string-with-tag\",\n\t\t\tinput: struct {\n\t\t\t\tValue *TypedStringWithCustomLength `json:\"value\" minLength:\"0\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"type\":\"string\",\n\t\t\t\t\t\t\"minLength\":0,\n\t\t\t\t\t\t\"maxLength\":10\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-custom-limits-int\",\n\t\t\tinput: struct {\n\t\t\t\tValue TypedIntegerWithCustomLimits `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\t\"properties\":{\n\t\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\t\"type\":\"integer\",\n\t\t\t\t\t\t\t\"format\":\"int64\",\n\t\t\t\t\t\t\t\"minimum\":1,\n\t\t\t\t\t\t\t\"maximum\":10\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\t\"type\":\"object\"\n\t\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-custom-limits-int-with-tag\",\n\t\t\tinput: struct {\n\t\t\t\tValue TypedIntegerWithCustomLimits `json:\"value\" minimum:\"2\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\t\"properties\":{\n\t\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\t\"type\":\"integer\",\n\t\t\t\t\t\t\t\"format\":\"int64\",\n\t\t\t\t\t\t\t\"minimum\":2,\n\t\t\t\t\t\t\t\"maximum\":10\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\t\"type\":\"object\"\n\t\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-ptr-to-custom-limits-int\",\n\t\t\tinput: struct {\n\t\t\t\tValue *TypedIntegerWithCustomLimits `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"format\":\"int64\",\n\t\t\t\t\t\t\"type\": [\"integer\", \"null\"],\n\t\t\t\t\t\t\"minimum\":1,\n\t\t\t\t\t\t\"maximum\":10\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-custom-array\",\n\t\t\tinput: struct {\n\t\t\t\tValue TypedArrayWithCustomDesc `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"description\":\"custom description\",\n\t\t\t\t\t\t\"items\":{\n\t\t\t\t\t\t\t\"format\":\"double\",\n\t\t\t\t\t\t\t\"type\":\"number\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"maxItems\":4,\n\t\t\t\t\t\t\"minItems\":4,\n\t\t\t\t\t\t\"type\":[\"array\", \"null\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname: \"field-ptr-to-custom-array\",\n\t\t\tinput: struct {\n\t\t\t\tValue *TypedArrayWithCustomDesc `json:\"value\"`\n\t\t\t}{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"description\":\"custom description\",\n\t\t\t\t\t\t\"items\":{\n\t\t\t\t\t\t\t\"format\":\"double\",\n\t\t\t\t\t\t\t\"type\":\"number\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"maxItems\":4,\n\t\t\t\t\t\t\"minItems\":4,\n\t\t\t\t\t\t\"type\":[\"array\", \"null\"]\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"schema-transformer-for-ptr\",\n\t\t\tinput: &CustomSchemaPtr{},\n\t\t\texpected: ` {\n\t\t\t\t\"additionalProperties\":false,\n\t\t\t\t\"description\":\"custom description\",\n\t\t\t\t\"properties\":{\n\t\t\t\t\t\"value\":{\n\t\t\t\t\t\t\"type\":\"string\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"required\":[\"value\"],\n\t\t\t\t\"type\":\"object\"\n\t\t\t}`,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\n\t\t\tif c.panics != \"\" {\n\t\t\t\tassert.PanicsWithError(t, c.panics, func() {\n\t\t\t\t\tr.Schema(reflect.TypeOf(c.input), false, \"\")\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\ts := r.Schema(reflect.TypeOf(c.input), false, \"\")\n\t\t\t\tb, _ := json.Marshal(s)\n\t\t\t\tassert.JSONEq(t, c.expected, string(b))\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype GreetingInput struct {\n\tID string `path:\"id\"`\n}\n\ntype TestInputSub struct {\n\tNum int `json:\"num\" minimum:\"1\"`\n}\n\ntype TestInput struct {\n\tName string       `json:\"name\" minLength:\"1\"`\n\tSub  TestInputSub `json:\"sub\"`\n}\n\ntype RecursiveInput struct {\n\tValue *RecursiveInput\n}\n\nfunc TestSchemaOld(t *testing.T) {\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\n\ts := r.Schema(reflect.TypeOf(GreetingInput{}), false, \"\")\n\tassert.Equal(t, \"object\", s.Type)\n\tassert.Len(t, s.Properties, 1)\n\tassert.Equal(t, \"string\", s.Properties[\"ID\"].Type)\n\n\tr.Schema(reflect.TypeOf(RecursiveInput{}), false, \"\")\n\n\ts2 := r.Schema(reflect.TypeOf(TestInput{}), false, \"\")\n\tpb := huma.NewPathBuffer(make([]byte, 0, 128), 0)\n\tres := huma.ValidateResult{}\n\thuma.Validate(r, s2, pb, huma.ModeReadFromServer, map[string]any{\n\t\t\"name\": \"foo\",\n\t\t\"sub\": map[string]any{\n\t\t\t\"num\": 1.0,\n\t\t},\n\t}, &res)\n\tassert.Empty(t, res.Errors)\n}\n\nfunc TestSchemaGenericNaming(t *testing.T) {\n\ttype SchemaGeneric[T any] struct {\n\t\tValue T `json:\"value\"`\n\t}\n\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := r.Schema(reflect.TypeOf(SchemaGeneric[int]{}), true, \"\")\n\n\tb, _ := json.Marshal(s)\n\tassert.JSONEq(t, `{\n\t\t\"$ref\": \"#/components/schemas/SchemaGenericInt\"\n\t}`, string(b))\n}\n\nfunc TestSchemaGenericNamingFromModule(t *testing.T) {\n\ttype SchemaGeneric[T any] struct {\n\t\tValue T `json:\"value\"`\n\t}\n\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := r.Schema(reflect.TypeOf(SchemaGeneric[time.Time]{}), true, \"\")\n\n\tb, _ := json.Marshal(s)\n\tassert.JSONEq(t, `{\n\t\t\"$ref\": \"#/components/schemas/SchemaGenericTime\"\n\t}`, string(b))\n}\n\ntype MyDate time.Time\n\nfunc (d *MyDate) UnmarshalText(data []byte) error {\n\tt, err := time.Parse(time.RFC3339, string(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\t*d = MyDate(t)\n\treturn nil\n}\n\nvar _ encoding.TextUnmarshaler = (*MyDate)(nil)\n\nfunc TestCustomDateType(t *testing.T) {\n\ttype O struct {\n\t\tDate MyDate `json:\"date\"`\n\t}\n\n\tvar o O\n\terr := json.Unmarshal([]byte(`{\"date\": \"2022-01-01T00:00:00Z\"}`), &o)\n\trequire.NoError(t, err)\n\tassert.Equal(t, MyDate(time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)), o.Date)\n\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := r.Schema(reflect.TypeOf(o), false, \"\")\n\tassert.Equal(t, \"string\", s.Properties[\"date\"].Type)\n}\n\ntype OmittableNullable[T any] struct {\n\tSent  bool\n\tNull  bool\n\tValue T\n}\n\nfunc (o *OmittableNullable[T]) UnmarshalJSON(b []byte) error {\n\tif len(b) > 0 {\n\t\to.Sent = true\n\t\tif bytes.Equal(b, []byte(\"null\")) {\n\t\t\to.Null = true\n\t\t\treturn nil\n\t\t}\n\t\treturn json.Unmarshal(b, &o.Value)\n\t}\n\treturn nil\n}\n\nfunc (o OmittableNullable[T]) Schema(r huma.Registry) *huma.Schema {\n\ts := r.Schema(reflect.TypeOf(o.Value), true, \"\")\n\ts.Nullable = true\n\treturn s\n}\n\nfunc TestCustomUnmarshalType(t *testing.T) {\n\ttype O struct {\n\t\tField OmittableNullable[int] `json:\"field\" maximum:\"10\" example:\"5\"`\n\t}\n\n\tvar o O\n\n\t// Confirm the schema is generated properly, including field constraints.\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := r.Schema(reflect.TypeOf(o), false, \"\")\n\tassert.Equal(t, \"integer\", s.Properties[\"field\"].Type, s)\n\tassert.Equal(t, Ptr(float64(10)), s.Properties[\"field\"].Maximum, s)\n\tassert.InDelta(t, float64(5), s.Properties[\"field\"].Examples[0], 0, s.Properties[\"field\"])\n\n\t// Confirm the field works as expected when loading JSON.\n\to = O{}\n\terr := json.Unmarshal([]byte(`{\"field\": 123}`), &o)\n\trequire.NoError(t, err)\n\tassert.True(t, o.Field.Sent)\n\tassert.False(t, o.Field.Null)\n\tassert.Equal(t, 123, o.Field.Value)\n\n\to = O{}\n\terr = json.Unmarshal([]byte(`{\"field\": null}`), &o)\n\trequire.NoError(t, err)\n\tassert.True(t, o.Field.Sent)\n\tassert.True(t, o.Field.Null)\n\tassert.Equal(t, 0, o.Field.Value)\n\n\to = O{}\n\terr = json.Unmarshal([]byte(`{}`), &o)\n\trequire.NoError(t, err)\n\tassert.False(t, o.Field.Sent)\n\tassert.False(t, o.Field.Null)\n\tassert.Equal(t, 0, o.Field.Value)\n}\n\nfunc TestMarshalDiscriminator(t *testing.T) {\n\ts := &huma.Schema{\n\t\tOneOf: []*huma.Schema{\n\t\t\t{Type: \"object\", Properties: map[string]*huma.Schema{\n\t\t\t\t\"type\": {Type: \"string\", Enum: []any{\"foo\"}},\n\t\t\t\t\"foo\":  {Type: \"string\"},\n\t\t\t}},\n\t\t\t{Type: \"object\", Properties: map[string]*huma.Schema{\n\t\t\t\t\"type\": {Type: \"string\", Enum: []any{\"bar\"}},\n\t\t\t\t\"bar\":  {Type: \"string\"},\n\t\t\t}},\n\t\t},\n\t\tDiscriminator: &huma.Discriminator{\n\t\t\tPropertyName: \"type\",\n\t\t\tMapping: map[string]string{\n\t\t\t\t\"foo\": \"#/components/schemas/Foo\",\n\t\t\t\t\"bar\": \"#/components/schemas/Bar\",\n\t\t\t},\n\t\t},\n\t}\n\n\tb, _ := json.Marshal(s)\n\tassert.JSONEq(t, `{\n\t\t\"oneOf\": [\n\t\t\t{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"type\": {\"type\": \"string\", \"enum\": [\"foo\"]},\n\t\t\t\t\t\"foo\": {\"type\": \"string\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"type\": \"object\",\n\t\t\t\t\"properties\": {\n\t\t\t\t\t\"type\": {\"type\": \"string\", \"enum\": [\"bar\"]},\n\t\t\t\t\t\"bar\": {\"type\": \"string\"}\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t\"discriminator\": {\n\t\t\t\"propertyName\": \"type\",\n\t\t\t\"mapping\": {\n\t\t\t\t\"foo\": \"#/components/schemas/Foo\",\n\t\t\t\t\"bar\": \"#/components/schemas/Bar\"\n\t\t\t}\n\t\t}\n\t}`, string(b))\n}\n\nfunc TestSchemaArrayNotNullable(t *testing.T) {\n\thuma.DefaultArrayNullable = false\n\tdefer func() {\n\t\thuma.DefaultArrayNullable = true\n\t}()\n\n\ttype Value struct {\n\t\tField []string `json:\"field\"`\n\t}\n\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := r.Schema(reflect.TypeOf(Value{}), false, \"\")\n\n\tassert.Equal(t, \"array\", s.Properties[\"field\"].Type)\n}\n\ntype BenchSub struct {\n\tVisible bool      `json:\"visible\" default:\"true\"`\n\tMetrics []float64 `json:\"metrics\" maxItems:\"31\"`\n}\n\ntype BenchStruct struct {\n\tName   string    `json:\"name\" minLength:\"1\"`\n\tCode   string    `json:\"code\" pattern:\"^[a-z]{3}-[0-9]+$\"`\n\tCount  uint      `json:\"count\" maximum:\"10\"`\n\tRating float32   `json:\"rating\" minimum:\"0\" maximum:\"5\"`\n\tRegion string    `json:\"region,omitempty\" enum:\"east,west\"`\n\tLabels []string  `json:\"labels,omitempty\" maxItems:\"5\" uniqueItems:\"true\"`\n\tSub    *BenchSub `json:\"sub,omitempty\"`\n}\n\nfunc BenchmarkSchema(b *testing.B) {\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\n\ts2 := r.Schema(reflect.TypeOf(BenchStruct{}), false, \"\")\n\n\t// data, _ := json.MarshalIndent(r.Map(), \"\", \"  \")\n\t// fmt.Println(string(data))\n\n\tinput := map[string]interface{}{\n\t\t\"name\":   \"foo\",\n\t\t\"code\":   \"bar-123\",\n\t\t\"count\":  8,\n\t\t\"rating\": 3.5,\n\t\t\"region\": \"west\",\n\t\t\"labels\": []any{\"a\", \"b\"},\n\t\t\"sub\": map[string]any{\n\t\t\t\"visible\": true,\n\t\t\t\"metrics\": []any{1.0, 2.0, 3.0},\n\t\t},\n\t}\n\tpb := huma.NewPathBuffer(make([]byte, 0, 128), 0)\n\tres := huma.ValidateResult{}\n\thuma.Validate(r, s2, pb, huma.ModeReadFromServer, input, &res)\n\tassert.Empty(b, res.Errors)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tpb.Reset()\n\t\tres.Reset()\n\t\thuma.Validate(r, s2, pb, huma.ModeReadFromServer, input, &res)\n\t\tif len(res.Errors) > 0 {\n\t\t\tb.Fatal(res.Errors)\n\t\t}\n\t}\n}\n\nfunc BenchmarkSchemaErrors(b *testing.B) {\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\n\ts2 := r.Schema(reflect.TypeOf(BenchStruct{}), false, \"\")\n\n\tinput := map[string]any{\n\t\t\"name\":   true,\n\t\t\"code\":   \"wrong\",\n\t\t\"count\":  20,\n\t\t\"rating\": 5.5,\n\t\t\"region\": \"error\",\n\t\t\"labels\": []any{\"dupe\", \"dupe\"},\n\t\t\"sub\": map[string]any{\n\t\t\t\"visible\":    1,\n\t\t\t\"unexpected\": 2,\n\t\t},\n\t}\n\tpb := huma.NewPathBuffer(make([]byte, 0, 128), 0)\n\tres := huma.ValidateResult{}\n\thuma.Validate(r, s2, pb, huma.ModeReadFromServer, input, &res)\n\tassert.NotEmpty(b, res.Errors)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tpb.Reset()\n\t\tres.Reset()\n\t\thuma.Validate(r, s2, pb, huma.ModeReadFromServer, input, &res)\n\t\tif len(res.Errors) == 0 {\n\t\t\tb.Fatal(\"expected error\")\n\t\t}\n\t}\n}\n\n// Struct that defines schemas for its property, to be reused by a SchemaTransformer\ntype ExampleInputStruct struct {\n\tName    string `json:\"name\" minLength:\"2\" example:\"Jane Doe\"`\n\tEmail   string `json:\"email\" format:\"email\" doc:\"Contact e-mail address\"`\n\tAge     *int   `json:\"age,omitempty\" minimum:\"0\"`\n\tComment string `json:\"comment,omitempty\" maxLength:\"256\"`\n\tPattern string `json:\"pattern\" pattern:\"^[a-z]+$\"`\n}\n\n// Implements SchemaTransformer interface, reusing parts of the schema from `ExampleInputStruct`\ntype ExampleUpdateStruct struct {\n\tName    *string                   `json:\"name\"`\n\tEmail   *string                   `json:\"email\" doc:\"Override doc for email\"`\n\tAge     OmittableNullable[int]    `json:\"age\"`\n\tComment OmittableNullable[string] `json:\"comment\"`\n\tPattern string                    `json:\"pattern\"`\n}\n\nfunc (u *ExampleUpdateStruct) TransformSchema(r huma.Registry, s *huma.Schema) *huma.Schema {\n\tinputSchema := r.Schema(reflect.TypeOf((*ExampleInputStruct)(nil)), false, \"\")\n\tfor propName, schema := range s.Properties {\n\t\tpropSchema := inputSchema.Properties[propName]\n\t\tif schema.Description != \"\" {\n\t\t\tpropSchema.Description = schema.Description\n\t\t}\n\t\tpropSchema.Nullable = schema.Nullable\n\t\ts.Properties[propName] = propSchema\n\t}\n\ts.Required = []string{} // make everything optional\n\treturn s\n}\n\nfunc TestSchemaTransformer(t *testing.T) {\n\tr := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\tinputSchema := r.Schema(reflect.TypeOf((*ExampleInputStruct)(nil)), false, \"\")\n\tvalidateSchema := func(s *huma.Schema) {\n\t\tif s.Ref != \"\" {\n\t\t\ts = r.SchemaFromRef(s.Ref)\n\t\t}\n\t\tassert.Equal(t, inputSchema.Properties[\"name\"].Examples, s.Properties[\"name\"].Examples)\n\t\tassert.Equal(t, \"Override doc for email\", s.Properties[\"email\"].Description)\n\t\tassert.Equal(t, inputSchema.Properties[\"email\"].Format, s.Properties[\"email\"].Format)\n\t\tassert.Equal(t, inputSchema.Properties[\"age\"].Minimum, s.Properties[\"age\"].Minimum)\n\t\tassert.True(t, s.Properties[\"age\"].Nullable)\n\t\tassert.Equal(t, inputSchema.Properties[\"comment\"].MaxLength, s.Properties[\"comment\"].MaxLength)\n\t\tassert.True(t, s.Properties[\"comment\"].Nullable)\n\t\tassert.Equal(t, inputSchema.Properties[\"pattern\"].Pattern, s.Properties[\"pattern\"].Pattern)\n\t}\n\tupdateSchema1 := r.Schema(reflect.TypeOf(ExampleUpdateStruct{}), false, \"\")\n\tvalidateSchema(updateSchema1)\n\tupdateSchema2 := huma.SchemaFromType(r, reflect.TypeOf(ExampleUpdateStruct{}))\n\tvalidateSchema(updateSchema2)\n}\n"
        },
        {
          "name": "sse",
          "type": "tree",
          "content": null
        },
        {
          "name": "transforms.go",
          "type": "blob",
          "size": 5.837890625,
          "content": "package huma\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n)\n\ntype schemaField struct {\n\tSchema string `json:\"$schema\"`\n}\n\n// SchemaLinkTransformer is a transform that adds a `$schema` field to the\n// response (if it is a struct) and a Link header pointing to the JSON\n// Schema that describes the response structure. This is useful for clients\n// to understand the structure of the response and enables things like\n// as-you-type validation & completion of HTTP resources in editors like\n// VSCode.\ntype SchemaLinkTransformer struct {\n\tprefix      string\n\tschemasPath string\n\ttypes       map[any]struct {\n\t\tt      reflect.Type\n\t\tfields []int\n\t\tref    string\n\t\theader string\n\t}\n}\n\n// NewSchemaLinkTransformer creates a new transformer that will add a `$schema`\n// field to the response (if it is a struct) and a Link header pointing to the\n// JSON Schema that describes the response structure. This is useful for clients\n// to understand the structure of the response and enables things like\n// as-you-type validation & completion of HTTP resources in editors like\n// VSCode.\nfunc NewSchemaLinkTransformer(prefix, schemasPath string) *SchemaLinkTransformer {\n\treturn &SchemaLinkTransformer{\n\t\tprefix:      prefix,\n\t\tschemasPath: schemasPath,\n\t\ttypes: map[any]struct {\n\t\t\tt      reflect.Type\n\t\t\tfields []int\n\t\t\tref    string\n\t\t\theader string\n\t\t}{},\n\t}\n}\n\nfunc (t *SchemaLinkTransformer) addSchemaField(oapi *OpenAPI, content *MediaType) bool {\n\tif content == nil || content.Schema == nil || content.Schema.Ref == \"\" {\n\t\treturn true\n\t}\n\n\tschema := oapi.Components.Schemas.SchemaFromRef(content.Schema.Ref)\n\tif schema.Type != TypeObject || (schema.Properties != nil && schema.Properties[\"$schema\"] != nil) {\n\t\treturn true\n\t}\n\n\t// Create an example so it's easier for users to find the schema URL when\n\t// they are reading the documentation.\n\tserver := \"https://example.com\"\n\tfor _, s := range oapi.Servers {\n\t\tif s.URL != \"\" {\n\t\t\tserver = s.URL\n\t\t\tbreak\n\t\t}\n\t}\n\n\tschema.Properties[\"$schema\"] = &Schema{\n\t\tType:        TypeString,\n\t\tFormat:      \"uri\",\n\t\tDescription: \"A URL to the JSON Schema for this object.\",\n\t\tReadOnly:    true,\n\t\tExamples:    []any{server + t.schemasPath + \"/\" + path.Base(content.Schema.Ref) + \".json\"},\n\t}\n\treturn false\n}\n\n// OnAddOperation is triggered whenever a new operation is added to the API,\n// enabling this transformer to precompute & cache information about the\n// response and schema.\nfunc (t *SchemaLinkTransformer) OnAddOperation(oapi *OpenAPI, op *Operation) {\n\t// Update registry to be able to get the type from a schema ref.\n\t// Register the type in t.types with the generated ref\n\tif op.RequestBody != nil && op.RequestBody.Content != nil {\n\t\tfor _, content := range op.RequestBody.Content {\n\t\t\tt.addSchemaField(oapi, content)\n\t\t}\n\t}\n\n\t// Figure out if there should be a base path prefix. This might be set when\n\t// using a sub-router / group or if the gateway consumes a part of the path.\n\tschemasPath := t.schemasPath\n\tif prefix := getAPIPrefix(oapi); prefix != \"\" {\n\t\tschemasPath = path.Join(prefix, schemasPath)\n\t}\n\n\tregistry := oapi.Components.Schemas\n\tfor _, resp := range op.Responses {\n\t\tfor _, content := range resp.Content {\n\t\t\tif t.addSchemaField(oapi, content) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Then, create the wrapper Go type that has the $schema field.\n\t\t\ttyp := deref(registry.TypeFromRef(content.Schema.Ref))\n\n\t\t\textra := schemaField{\n\t\t\t\tSchema: schemasPath + \"/\" + path.Base(content.Schema.Ref) + \".json\",\n\t\t\t}\n\n\t\t\tfieldIndexes := []int{}\n\t\t\tfields := []reflect.StructField{\n\t\t\t\treflect.TypeOf(extra).Field(0),\n\t\t\t}\n\t\t\tfor i := 0; i < typ.NumField(); i++ {\n\t\t\t\tf := typ.Field(i)\n\t\t\t\tif f.IsExported() {\n\t\t\t\t\tfields = append(fields, f)\n\n\t\t\t\t\t// Track which fields are exported, so we can copy them over.\n\t\t\t\t\t// It's preferred to track/compute this here to avoid allocations in\n\t\t\t\t\t// the transform function from looking up what is exported.\n\t\t\t\t\tfieldIndexes = append(fieldIndexes, i)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\t// Catch some scenarios that just aren't supported in Go at the\n\t\t\t\t\t\t// moment. Logs an error so people know what's going on.\n\t\t\t\t\t\t// https://github.com/danielgtaylor/huma/issues/371\n\t\t\t\t\t\tfmt.Fprintln(os.Stderr, \"Warning: unable to create schema link for type\", typ, \":\", r)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tnewType := reflect.StructOf(fields)\n\t\t\t\tinfo := t.types[typ]\n\t\t\t\tinfo.t = newType\n\t\t\t\tinfo.fields = fieldIndexes\n\t\t\t\tinfo.ref = extra.Schema\n\t\t\t\tinfo.header = \"<\" + extra.Schema + \">; rel=\\\"describedBy\\\"\"\n\t\t\t\tt.types[typ] = info\n\t\t\t}()\n\t\t}\n\t}\n}\n\n// Transform is called for every response to add the `$schema` field and/or\n// the Link header pointing to the JSON Schema.\nfunc (t *SchemaLinkTransformer) Transform(ctx Context, status string, v any) (any, error) {\n\tvv := reflect.ValueOf(v)\n\tif vv.Kind() == reflect.Pointer && vv.IsNil() {\n\t\treturn v, nil\n\t}\n\n\ttyp := deref(reflect.TypeOf(v))\n\n\tif typ.Kind() != reflect.Struct {\n\t\treturn v, nil\n\t}\n\n\tinfo := t.types[typ]\n\tif info.t == nil {\n\t\treturn v, nil\n\t}\n\n\thost := ctx.Host()\n\tctx.AppendHeader(\"Link\", info.header)\n\n\ttmp := reflect.New(info.t).Elem()\n\n\t// Set the `$schema` field.\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tif len(host) >= 9 && (host[:9] == \"localhost\" || host[:9] == \"127.0.0.1\") {\n\t\tbuf.WriteString(\"http://\")\n\t} else {\n\t\tbuf.WriteString(\"https://\")\n\t}\n\tbuf.WriteString(host)\n\tbuf.WriteString(info.ref)\n\ttmp.Field(0).SetString(buf.String())\n\tbuf.Reset()\n\tbufPool.Put(buf)\n\n\t// Copy over all the exported fields.\n\tvv = reflect.Indirect(vv)\n\tfor i, j := range info.fields {\n\t\t// Field 0 is the $schema field, so we need to offset the index by one.\n\t\t// There might have been unexported fields in the struct declared in the schema,\n\t\t// but these have been filtered out when creating the new type.\n\t\t// Therefore, the field with index i on the new type maps to the field with index j\n\t\t// in the original struct.\n\t\ttmp.Field(i + 1).Set(vv.Field(j))\n\t}\n\n\treturn tmp.Addr().Interface(), nil\n}\n"
        },
        {
          "name": "validate.go",
          "type": "blob",
          "size": 25.7138671875,
          "content": "package huma\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"net/mail\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode/utf8\"\n\t\"unsafe\"\n\n\t\"github.com/danielgtaylor/huma/v2/validation\"\n)\n\n// ValidateMode describes the direction of validation (server -> client or\n// client -> server). It impacts things like how read-only or write-only fields\n// are handled.\ntype ValidateMode int\n\nconst (\n\t// ModeReadFromServer is a read mode (response output) that may ignore or\n\t// reject write-only fields that are non-zero, as these write-only fields\n\t// are meant to be sent by the client.\n\tModeReadFromServer ValidateMode = iota\n\n\t// ModeWriteToServer is a write mode (request input) that may ignore or\n\t// reject read-only fields that are non-zero, as these are owned by the\n\t// server and the client should not try to modify them.\n\tModeWriteToServer\n)\n\n// ValidateStrictCasing controls whether or not field names are case-sensitive\n// during validation. This is useful for clients that may send fields in a\n// different case than expected by the server. For example, a legacy client may\n// send `{\"Foo\": \"bar\"}` when the server expects `{\"foo\": \"bar\"}`. This is\n// disabled by default to match Go's JSON unmarshaling behavior.\nvar ValidateStrictCasing = false\n\nvar rxHostname = regexp.MustCompile(`^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$`)\nvar rxURITemplate = regexp.MustCompile(\"^([^{]*({[^}]*})?)*$\")\nvar rxJSONPointer = regexp.MustCompile(\"^(?:/(?:[^~/]|~0|~1)*)*$\")\nvar rxRelJSONPointer = regexp.MustCompile(\"^(?:0|[1-9][0-9]*)(?:#|(?:/(?:[^~/]|~0|~1)*)*)$\")\nvar rxBase64 = regexp.MustCompile(`^[a-zA-Z0-9+/_-]+=*$`)\n\nfunc mapTo[A, B any](s []A, f func(A) B) []B {\n\tr := make([]B, len(s))\n\tfor i, v := range s {\n\t\tr[i] = f(v)\n\t}\n\treturn r\n}\n\n// PathBuffer is a low-allocation helper for building a path string like\n// `foo.bar.baz`. It is not goroutine-safe. Combined with `sync.Pool` it can\n// result in zero allocations, and is used for validation. It is significantly\n// better than `strings.Builder` and `bytes.Buffer` for this use case.\n//\n// Path buffers can be converted to strings for use in responses or printing\n// using either the `pb.String()` or `pb.With(\"field\")` methods.\n//\n//\tpb := NewPathBuffer([]byte{}, 0)\n//\tpb.Push(\"foo\")  // foo\n//\tpb.PushIndex(1) // foo[1]\n//\tpb.Push(\"bar\")  // foo[1].bar\n//\tpb.Pop()        // foo[1]\n//\tpb.Pop()        // foo\ntype PathBuffer struct {\n\tbuf []byte\n\toff int\n}\n\n// Push an entry onto the path, adding a `.` separator as needed.\n//\n//\tpb.Push(\"foo\") // foo\n//\tpb.Push(\"bar\") // foo.bar\nfunc (b *PathBuffer) Push(s string) {\n\tif b.off > 0 {\n\t\tb.buf = append(b.buf, '.')\n\t\tb.off++\n\t}\n\tb.buf = append(b.buf, s...)\n\tb.off += len(s)\n}\n\n// PushIndex pushes an entry onto the path surrounded by `[` and `]`.\n//\n//\tpb.Push(\"foo\")  // foo\n//\tpb.PushIndex(1) // foo[1]\nfunc (b *PathBuffer) PushIndex(i int) {\n\tl := len(b.buf)\n\tb.buf = append(b.buf, '[')\n\tb.buf = append(b.buf, strconv.Itoa(i)...)\n\tb.buf = append(b.buf, ']')\n\tb.off += len(b.buf) - l\n}\n\n// Pop the latest entry off the path.\n//\n//\tpb.Push(\"foo\")  // foo\n//\tpb.PushIndex(1) // foo[1]\n//\tpb.Push(\"bar\")  // foo[1].bar\n//\tpb.Pop()        // foo[1]\n//\tpb.Pop()        // foo\nfunc (b *PathBuffer) Pop() {\n\tfor b.off > 0 {\n\t\tb.off--\n\t\tif b.buf[b.off] == '.' || b.buf[b.off] == '[' {\n\t\t\tbreak\n\t\t}\n\t}\n\tb.buf = b.buf[:b.off]\n}\n\n// With is shorthand for push, convert to string, and pop. This is useful\n// when you want the location of a field given a path buffer as a prefix.\n//\n//\tpb.Push(\"foo\")\n//\tpb.With(\"bar\") // returns foo.bar\nfunc (b *PathBuffer) With(s string) string {\n\tb.Push(s)\n\ttmp := b.String()\n\tb.Pop()\n\treturn tmp\n}\n\n// Len returns the length of the current path.\nfunc (b *PathBuffer) Len() int {\n\treturn b.off\n}\n\n// Bytes returns the underlying slice of bytes of the path.\nfunc (b *PathBuffer) Bytes() []byte {\n\treturn b.buf[:b.off]\n}\n\n// String converts the path buffer to a string.\nfunc (b *PathBuffer) String() string {\n\treturn string(b.buf[:b.off])\n}\n\n// Reset the path buffer to empty, keeping and reusing the underlying bytes.\nfunc (b *PathBuffer) Reset() {\n\tb.buf = b.buf[:0]\n\tb.off = 0\n}\n\n// NewPathBuffer creates a new path buffer given an existing byte slice.\n// Tip: using `sync.Pool` can significantly reduce buffer allocations.\n//\n//\tpb := NewPathBuffer([]byte{}, 0)\n//\tpb.Push(\"foo\")\nfunc NewPathBuffer(buf []byte, offset int) *PathBuffer {\n\treturn &PathBuffer{buf: buf, off: offset}\n}\n\n// ValidateResult tracks validation errors. It is safe to use for multiple\n// validations as long as `Reset()` is called between uses.\ntype ValidateResult struct {\n\tErrors []error\n}\n\n// Add an error to the validation result at the given path and with the\n// given value.\nfunc (r *ValidateResult) Add(path *PathBuffer, v any, msg string) {\n\tr.Errors = append(r.Errors, &ErrorDetail{\n\t\tMessage:  msg,\n\t\tLocation: path.String(),\n\t\tValue:    v,\n\t})\n}\n\n// Addf adds an error to the validation result at the given path and with\n// the given value, allowing for fmt.Printf-style formatting.\nfunc (r *ValidateResult) Addf(path *PathBuffer, v any, format string, args ...any) {\n\tr.Errors = append(r.Errors, &ErrorDetail{\n\t\tMessage:  fmt.Sprintf(format, args...),\n\t\tLocation: path.String(),\n\t\tValue:    v,\n\t})\n}\n\n// Reset the validation error so it can be used again.\nfunc (r *ValidateResult) Reset() {\n\tr.Errors = r.Errors[:0]\n}\n\nfunc validateFormat(path *PathBuffer, str string, s *Schema, res *ValidateResult) {\n\tswitch s.Format {\n\tcase \"date-time\":\n\t\tfound := false\n\t\tfor _, format := range []string{time.RFC3339, time.RFC3339Nano} {\n\t\t\tif _, err := time.Parse(format, str); err == nil {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC3339DateTime)\n\t\t}\n\tcase \"date-time-http\":\n\t\tif _, err := time.Parse(time.RFC1123, str); err != nil {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC1123DateTime)\n\t\t}\n\tcase \"date\":\n\t\tif _, err := time.Parse(\"2006-01-02\", str); err != nil {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC3339Date)\n\t\t}\n\tcase \"time\":\n\t\tif _, err := time.Parse(\"15:04:05\", str); err != nil {\n\t\t\tif _, err := time.Parse(\"15:04:05Z07:00\", str); err != nil {\n\t\t\t\tres.Add(path, str, validation.MsgExpectedRFC3339Time)\n\t\t\t}\n\t\t}\n\t\t// TODO: duration\n\tcase \"email\", \"idn-email\":\n\t\tif _, err := mail.ParseAddress(str); err != nil {\n\t\t\tres.Add(path, str, ErrorFormatter(validation.MsgExpectedRFC5322Email, err))\n\t\t}\n\tcase \"hostname\":\n\t\tif !(rxHostname.MatchString(str) && len(str) < 256) {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC5890Hostname)\n\t\t}\n\t// TODO: proper idn-hostname support... need to figure out how.\n\tcase \"ipv4\":\n\t\tif ip := net.ParseIP(str); ip == nil || ip.To4() == nil {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC2673IPv4)\n\t\t}\n\tcase \"ipv6\":\n\t\tif ip := net.ParseIP(str); ip == nil || ip.To16() == nil {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC2373IPv6)\n\t\t}\n\tcase \"uri\", \"uri-reference\", \"iri\", \"iri-reference\":\n\t\tif _, err := url.Parse(str); err != nil {\n\t\t\tres.Add(path, str, ErrorFormatter(validation.MsgExpectedRFC3986URI, err))\n\t\t}\n\t\t// TODO: check if it's actually a reference?\n\tcase \"uuid\":\n\t\tif err := validateUUID(str); err != nil {\n\t\t\tres.Add(path, str, ErrorFormatter(validation.MsgExpectedRFC4122UUID, err))\n\t\t}\n\tcase \"uri-template\":\n\t\tu, err := url.Parse(str)\n\t\tif err != nil {\n\t\t\tres.Add(path, str, ErrorFormatter(validation.MsgExpectedRFC3986URI, err))\n\t\t\treturn\n\t\t}\n\t\tif !rxURITemplate.MatchString(u.Path) {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC6570URITemplate)\n\t\t}\n\tcase \"json-pointer\":\n\t\tif !rxJSONPointer.MatchString(str) {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC6901JSONPointer)\n\t\t}\n\tcase \"relative-json-pointer\":\n\t\tif !rxRelJSONPointer.MatchString(str) {\n\t\t\tres.Add(path, str, validation.MsgExpectedRFC6901RelativeJSONPointer)\n\t\t}\n\tcase \"regex\":\n\t\tif _, err := regexp.Compile(str); err != nil {\n\t\t\tres.Add(path, str, ErrorFormatter(validation.MsgExpectedRegexp, err))\n\t\t}\n\t}\n}\n\nfunc validateOneOf(r Registry, s *Schema, path *PathBuffer, mode ValidateMode, v any, res *ValidateResult) {\n\tfound := false\n\tsubRes := &ValidateResult{}\n\tfor _, sub := range s.OneOf {\n\t\tValidate(r, sub, path, mode, v, subRes)\n\t\tif len(subRes.Errors) == 0 {\n\t\t\tif found {\n\t\t\t\tres.Add(path, v, \"expected value to match exactly one schema but matched multiple\")\n\t\t\t}\n\t\t\tfound = true\n\t\t}\n\t\tsubRes.Reset()\n\t}\n\tif !found {\n\t\tres.Add(path, v, validation.MsgExpectedMatchExactlyOneSchema)\n\t}\n}\n\nfunc validateAnyOf(r Registry, s *Schema, path *PathBuffer, mode ValidateMode, v any, res *ValidateResult) {\n\tmatches := 0\n\tsubRes := &ValidateResult{}\n\tfor _, sub := range s.AnyOf {\n\t\tValidate(r, sub, path, mode, v, subRes)\n\t\tif len(subRes.Errors) == 0 {\n\t\t\tmatches++\n\t\t}\n\t\tsubRes.Reset()\n\t}\n\n\tif matches == 0 {\n\t\tres.Add(path, v, validation.MsgExpectedMatchAtLeastOneSchema)\n\t}\n}\n\nfunc validateDiscriminator(r Registry, s *Schema, path *PathBuffer, mode ValidateMode, v any, res *ValidateResult) {\n\tvar kk any\n\tfound := true\n\n\tif vv, ok := v.(map[string]any); ok {\n\t\tkk, found = vv[s.Discriminator.PropertyName]\n\t}\n\n\tif vv, ok := v.(map[any]any); ok {\n\t\tkk, found = vv[s.Discriminator.PropertyName]\n\t}\n\n\tif !found {\n\t\tpath.Push(s.Discriminator.PropertyName)\n\t\tres.Add(path, v, validation.MsgExpectedPropertyNameInObject)\n\t\treturn\n\t}\n\n\tif kk == nil {\n\t\t// Either `v` is not a map or the property is set to null. Return so that\n\t\t// type and enum checks on the field can complete elsewhere.\n\t\treturn\n\t}\n\n\tkey, ok := kk.(string)\n\tif !ok {\n\t\tpath.Push(s.Discriminator.PropertyName)\n\t\treturn\n\t}\n\n\tref, found := s.Discriminator.Mapping[key]\n\tif !found {\n\t\tvalidateOneOf(r, s, path, mode, v, res)\n\t\treturn\n\t}\n\n\tValidate(r, r.SchemaFromRef(ref), path, mode, v, res)\n}\n\n// Validate an input value against a schema, collecting errors in the validation\n// result object. If successful, `res.Errors` will be empty. It is suggested\n// to use a `sync.Pool` to reuse the PathBuffer and ValidateResult objects,\n// making sure to call `Reset()` on them before returning them to the pool.\n//\n//\tregistry := huma.NewMapRegistry(\"#/prefix\", huma.DefaultSchemaNamer)\n//\tschema := huma.SchemaFromType(registry, reflect.TypeOf(MyType{}))\n//\tpb := huma.NewPathBuffer([]byte(\"\"), 0)\n//\tres := &huma.ValidateResult{}\n//\n//\tvar value any\n//\tjson.Unmarshal([]byte(`{\"foo\": \"bar\"}`), &v)\n//\thuma.Validate(registry, schema, pb, huma.ModeWriteToServer, value, res)\n//\tfor _, err := range res.Errors {\n//\t\tfmt.Println(err.Error())\n//\t}\nfunc Validate(r Registry, s *Schema, path *PathBuffer, mode ValidateMode, v any, res *ValidateResult) {\n\t// Get the actual schema if this is a reference.\n\tfor s.Ref != \"\" {\n\t\ts = r.SchemaFromRef(s.Ref)\n\t}\n\n\tif s.OneOf != nil {\n\t\tif s.Discriminator != nil {\n\t\t\tvalidateDiscriminator(r, s, path, mode, v, res)\n\t\t} else {\n\t\t\tvalidateOneOf(r, s, path, mode, v, res)\n\t\t}\n\t}\n\n\tif s.AnyOf != nil {\n\t\tvalidateAnyOf(r, s, path, mode, v, res)\n\t}\n\n\tif s.AllOf != nil {\n\t\tfor _, sub := range s.AllOf {\n\t\t\tValidate(r, sub, path, mode, v, res)\n\t\t}\n\t}\n\n\tif s.Not != nil {\n\t\tsubRes := &ValidateResult{}\n\t\tValidate(r, s.Not, path, mode, v, subRes)\n\t\tif len(subRes.Errors) == 0 {\n\t\t\tres.Add(path, v, validation.MsgExpectedNotMatchSchema)\n\t\t}\n\t}\n\n\tif s.Nullable && v == nil {\n\t\treturn\n\t}\n\n\tswitch s.Type {\n\tcase TypeBoolean:\n\t\tif _, ok := v.(bool); !ok {\n\t\t\tres.Add(path, v, validation.MsgExpectedBoolean)\n\t\t\treturn\n\t\t}\n\tcase TypeNumber, TypeInteger:\n\t\tvar num float64\n\n\t\tswitch v := v.(type) {\n\t\tcase float64:\n\t\t\tnum = v\n\t\tcase float32:\n\t\t\tnum = float64(v)\n\t\tcase int:\n\t\t\tnum = float64(v)\n\t\tcase int8:\n\t\t\tnum = float64(v)\n\t\tcase int16:\n\t\t\tnum = float64(v)\n\t\tcase int32:\n\t\t\tnum = float64(v)\n\t\tcase int64:\n\t\t\tnum = float64(v)\n\t\tcase uint:\n\t\t\tnum = float64(v)\n\t\tcase uint8:\n\t\t\tnum = float64(v)\n\t\tcase uint16:\n\t\t\tnum = float64(v)\n\t\tcase uint32:\n\t\t\tnum = float64(v)\n\t\tcase uint64:\n\t\t\tnum = float64(v)\n\t\tdefault:\n\t\t\tres.Add(path, v, validation.MsgExpectedNumber)\n\t\t\treturn\n\t\t}\n\n\t\tif s.Minimum != nil {\n\t\t\tif num < *s.Minimum {\n\t\t\t\tres.Add(path, v, s.msgMinimum)\n\t\t\t}\n\t\t}\n\t\tif s.ExclusiveMinimum != nil {\n\t\t\tif num <= *s.ExclusiveMinimum {\n\t\t\t\tres.Add(path, v, s.msgExclusiveMinimum)\n\t\t\t}\n\t\t}\n\t\tif s.Maximum != nil {\n\t\t\tif num > *s.Maximum {\n\t\t\t\tres.Add(path, v, s.msgMaximum)\n\t\t\t}\n\t\t}\n\t\tif s.ExclusiveMaximum != nil {\n\t\t\tif num >= *s.ExclusiveMaximum {\n\t\t\t\tres.Add(path, v, s.msgExclusiveMaximum)\n\t\t\t}\n\t\t}\n\t\tif s.MultipleOf != nil {\n\t\t\tif math.Mod(num, *s.MultipleOf) != 0 {\n\t\t\t\tres.Add(path, v, s.msgMultipleOf)\n\t\t\t}\n\t\t}\n\tcase TypeString:\n\t\tstr, ok := v.(string)\n\t\tif !ok {\n\t\t\tif b, ok := v.([]byte); ok {\n\t\t\t\tstr = *(*string)(unsafe.Pointer(&b))\n\t\t\t} else {\n\t\t\t\tres.Add(path, v, validation.MsgExpectedString)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif s.MinLength != nil {\n\t\t\tif utf8.RuneCountInString(str) < *s.MinLength {\n\t\t\t\tres.Add(path, str, s.msgMinLength)\n\t\t\t}\n\t\t}\n\t\tif s.MaxLength != nil {\n\t\t\tif utf8.RuneCountInString(str) > *s.MaxLength {\n\t\t\t\tres.Add(path, str, s.msgMaxLength)\n\t\t\t}\n\t\t}\n\t\tif s.patternRe != nil {\n\t\t\tif !s.patternRe.MatchString(str) {\n\t\t\t\tres.Add(path, v, s.msgPattern)\n\t\t\t}\n\t\t}\n\n\t\tif s.Format != \"\" {\n\t\t\tvalidateFormat(path, str, s, res)\n\t\t}\n\n\t\tif s.ContentEncoding == \"base64\" {\n\t\t\tif !rxBase64.MatchString(str) {\n\t\t\t\tres.Add(path, str, validation.MsgExpectedBase64String)\n\t\t\t}\n\t\t}\n\tcase TypeArray:\n\t\tswitch arr := v.(type) {\n\t\tcase []any:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\t// Special cases for params which are lists.\n\t\tcase []string:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []int:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []int8:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []int16:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []int32:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []int64:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []uint:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []uint16:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []uint32:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []uint64:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []float32:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tcase []float64:\n\t\t\thandleArray(r, s, path, mode, res, arr)\n\t\tdefault:\n\t\t\tres.Add(path, v, validation.MsgExpectedArray)\n\t\t\treturn\n\t\t}\n\tcase TypeObject:\n\t\tswitch vv := v.(type) {\n\t\tcase map[string]any:\n\t\t\thandleMapString(r, s, path, mode, vv, res)\n\t\tcase map[any]any:\n\t\t\thandleMapAny(r, s, path, mode, vv, res)\n\t\tdefault:\n\t\t\tres.Add(path, v, validation.MsgExpectedObject)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif len(s.Enum) > 0 {\n\t\tfound := false\n\t\tfor _, e := range s.Enum {\n\t\t\tif e == v {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tres.Add(path, v, s.msgEnum)\n\t\t}\n\t}\n}\n\nfunc handleArray[T any](r Registry, s *Schema, path *PathBuffer, mode ValidateMode, res *ValidateResult, arr []T) {\n\tif s.MinItems != nil {\n\t\tif len(arr) < *s.MinItems {\n\t\t\tres.Add(path, arr, s.msgMinItems)\n\t\t}\n\t}\n\tif s.MaxItems != nil {\n\t\tif len(arr) > *s.MaxItems {\n\t\t\tres.Add(path, arr, s.msgMaxItems)\n\t\t}\n\t}\n\n\tif s.UniqueItems {\n\t\tseen := make(map[any]struct{}, len(arr))\n\t\tfor _, item := range arr {\n\t\t\tif _, ok := seen[item]; ok {\n\t\t\t\tres.Add(path, arr, validation.MsgExpectedArrayItemsUnique)\n\t\t\t}\n\t\t\tseen[item] = struct{}{}\n\t\t}\n\t}\n\n\tfor i, item := range arr {\n\t\tpath.PushIndex(i)\n\t\tValidate(r, s.Items, path, mode, item, res)\n\t\tpath.Pop()\n\t}\n}\n\nfunc handleMapString(r Registry, s *Schema, path *PathBuffer, mode ValidateMode, m map[string]any, res *ValidateResult) {\n\tif s.MinProperties != nil {\n\t\tif len(m) < *s.MinProperties {\n\t\t\tres.Add(path, m, s.msgMinProperties)\n\t\t}\n\t}\n\tif s.MaxProperties != nil {\n\t\tif len(m) > *s.MaxProperties {\n\t\t\tres.Add(path, m, s.msgMaxProperties)\n\t\t}\n\t}\n\n\tfor _, k := range s.propertyNames {\n\t\tv := s.Properties[k]\n\n\t\t// Schemas are generated such that the read/write-only properties are set\n\t\t// alongside the `$ref`, if it is present (i.e. for objects). If not,\n\t\t// then the read/write-only properties are set directly on the schema and\n\t\t// the `for` loop never runs.\n\t\treadOnly := v.ReadOnly\n\t\twriteOnly := v.WriteOnly\n\t\tfor v.Ref != \"\" {\n\t\t\tv = r.SchemaFromRef(v.Ref)\n\t\t}\n\n\t\t// We should be permissive by default to enable easy round-trips for the\n\t\t// client without needing to remove read-only values.\n\t\t// TODO: should we make this configurable?\n\n\t\t// Be stricter for responses, enabling validation of the server if desired.\n\t\tif mode == ModeReadFromServer && writeOnly && m[k] != nil && !reflect.ValueOf(m[k]).IsZero() {\n\t\t\tres.Add(path, m[k], \"write only property is non-zero\")\n\t\t\tcontinue\n\t\t}\n\n\t\tactualKey := k\n\t\t_, ok := m[k]\n\t\tif !ok && !ValidateStrictCasing {\n\t\t\tfor actual := range m {\n\t\t\t\tif strings.EqualFold(actual, k) {\n\t\t\t\t\t// Case-insensitive match found, so this is not an error.\n\t\t\t\t\tactualKey = actual\n\t\t\t\t\tok = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !ok {\n\t\t\tif !s.requiredMap[k] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (mode == ModeWriteToServer && readOnly) ||\n\t\t\t\t(mode == ModeReadFromServer && writeOnly) {\n\t\t\t\t// These are not required for the current mode.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres.Add(path, m, s.msgRequired[k])\n\t\t\tcontinue\n\t\t}\n\n\t\tif m[actualKey] == nil && (!s.requiredMap[k] || s.Nullable) {\n\t\t\t// This is a non-required field which is null, or a nullable field set\n\t\t\t// to null, so ignore it.\n\t\t\tcontinue\n\t\t}\n\n\t\tif m[actualKey] != nil && s.DependentRequired[k] != nil {\n\t\t\tfor _, dependent := range s.DependentRequired[k] {\n\t\t\t\tif m[dependent] != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tres.Add(path, m, s.msgDependentRequired[k][dependent])\n\t\t\t}\n\t\t}\n\n\t\tpath.Push(k)\n\t\tValidate(r, v, path, mode, m[actualKey], res)\n\t\tpath.Pop()\n\t}\n\n\tif addl, ok := s.AdditionalProperties.(bool); ok && !addl {\n\taddlPropLoop:\n\t\tfor k := range m {\n\t\t\t// No additional properties allowed.\n\t\t\tif _, ok := s.Properties[k]; !ok {\n\t\t\t\tif !ValidateStrictCasing {\n\t\t\t\t\tfor propName := range s.Properties {\n\t\t\t\t\t\tif strings.EqualFold(propName, k) {\n\t\t\t\t\t\t\t// Case-insensitive match found, so this is not an error.\n\t\t\t\t\t\t\tcontinue addlPropLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpath.Push(k)\n\t\t\t\tres.Add(path, m, validation.MsgUnexpectedProperty)\n\t\t\t\tpath.Pop()\n\t\t\t}\n\t\t}\n\t}\n\n\tif addl, ok := s.AdditionalProperties.(*Schema); ok {\n\t\t// Additional properties are allowed, but must match the given schema.\n\t\tfor k, v := range m {\n\t\t\tif _, ok := s.Properties[k]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpath.Push(k)\n\t\t\tValidate(r, addl, path, mode, v, res)\n\t\t\tpath.Pop()\n\t\t}\n\t}\n}\n\nfunc handleMapAny(r Registry, s *Schema, path *PathBuffer, mode ValidateMode, m map[any]any, res *ValidateResult) {\n\tif s.MinProperties != nil {\n\t\tif len(m) < *s.MinProperties {\n\t\t\tres.Add(path, m, s.msgMinProperties)\n\t\t}\n\t}\n\tif s.MaxProperties != nil {\n\t\tif len(m) > *s.MaxProperties {\n\t\t\tres.Add(path, m, s.msgMaxProperties)\n\t\t}\n\t}\n\n\tfor _, k := range s.propertyNames {\n\t\tv := s.Properties[k]\n\n\t\t// Schemas are generated such that the read/write-only properties are set\n\t\t// alongside the `$ref`, if it is present (i.e. for objects). If not,\n\t\t// then the read/write-only properties are set directly on the schema and\n\t\t// the `for` loop never runs.\n\t\treadOnly := v.ReadOnly\n\t\twriteOnly := v.WriteOnly\n\t\tfor v.Ref != \"\" {\n\t\t\tv = r.SchemaFromRef(v.Ref)\n\t\t}\n\n\t\t// We should be permissive by default to enable easy round-trips for the\n\t\t// client without needing to remove read-only values.\n\t\t// TODO: should we make this configurable?\n\n\t\t// Be stricter for responses, enabling validation of the server if desired.\n\t\tif mode == ModeReadFromServer && writeOnly && m[k] != nil && !reflect.ValueOf(m[k]).IsZero() {\n\t\t\tres.Add(path, m[k], \"write only property is non-zero\")\n\t\t\tcontinue\n\t\t}\n\n\t\tif _, ok := m[k]; !ok {\n\t\t\tif !s.requiredMap[k] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (mode == ModeWriteToServer && readOnly) ||\n\t\t\t\t(mode == ModeReadFromServer && writeOnly) {\n\t\t\t\t// These are not required for the current mode.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tres.Add(path, m, s.msgRequired[k])\n\t\t\tcontinue\n\t\t}\n\n\t\tif m[k] == nil && (!s.requiredMap[k] || s.Nullable) {\n\t\t\t// This is a non-required field which is null, or a nullable field set\n\t\t\t// to null, so ignore it.\n\t\t\tcontinue\n\t\t}\n\n\t\tif m[k] != nil && s.DependentRequired[k] != nil {\n\t\t\tfor _, dependent := range s.DependentRequired[k] {\n\t\t\t\tif m[dependent] != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tres.Add(path, m, s.msgDependentRequired[k][dependent])\n\t\t\t}\n\t\t}\n\n\t\tpath.Push(k)\n\t\tValidate(r, v, path, mode, m[k], res)\n\t\tpath.Pop()\n\t}\n\n\tif addl, ok := s.AdditionalProperties.(bool); ok && !addl {\n\t\tfor k := range m {\n\t\t\t// No additional properties allowed.\n\t\t\tvar kStr string\n\t\t\tif s, ok := k.(string); ok {\n\t\t\t\tkStr = s\n\t\t\t} else {\n\t\t\t\tkStr = fmt.Sprint(k)\n\t\t\t}\n\t\t\tif _, ok := s.Properties[kStr]; !ok {\n\t\t\t\tpath.Push(kStr)\n\t\t\t\tres.Add(path, m, validation.MsgUnexpectedProperty)\n\t\t\t\tpath.Pop()\n\t\t\t}\n\t\t}\n\t}\n\n\tif addl, ok := s.AdditionalProperties.(*Schema); ok {\n\t\t// Additional properties are allowed, but must match the given schema.\n\t\tfor k, v := range m {\n\t\t\tvar kStr string\n\t\t\tif s, ok := k.(string); ok {\n\t\t\t\tkStr = s\n\t\t\t} else {\n\t\t\t\tkStr = fmt.Sprint(k)\n\t\t\t}\n\t\t\tpath.Push(kStr)\n\t\t\tValidate(r, addl, path, mode, v, res)\n\t\t\tpath.Pop()\n\t\t}\n\t}\n}\n\n// ModelValidator is a utility for validating e.g. JSON loaded data against a\n// Go struct model. It is not goroutine-safe and should not be used in HTTP\n// handlers! Schemas are generated on-the-fly on first use and re-used on\n// subsequent calls. This utility can be used to easily validate data outside\n// of the normal request/response flow, for example on application startup:\n//\n//\ttype MyExample struct {\n//\t\tName string `json:\"name\" maxLength:\"5\"`\n//\t\tAge int `json:\"age\" minimum:\"25\"`\n//\t}\n//\n//\tvar value any\n//\tjson.Unmarshal([]byte(`{\"name\": \"abcdefg\", \"age\": 1}`), &value)\n//\n//\tvalidator := ModelValidator()\n//\terrs := validator.Validate(reflect.TypeOf(MyExample{}), value)\n//\tif errs != nil {\n//\t\tfmt.Println(\"Validation error\", errs)\n//\t}\ntype ModelValidator struct {\n\tregistry Registry\n\tpb       *PathBuffer\n\tresult   *ValidateResult\n}\n\n// NewModelValidator creates a new model validator with all the components\n// it needs to create schemas, validate them, and return any errors.\nfunc NewModelValidator() *ModelValidator {\n\treturn &ModelValidator{\n\t\tregistry: NewMapRegistry(\"#/components/schemas/\", DefaultSchemaNamer),\n\t\tpb:       NewPathBuffer([]byte(\"\"), 0),\n\t\tresult:   &ValidateResult{},\n\t}\n}\n\n// Validate the inputs. The type should be the Go struct with validation field\n// tags and the value should be e.g. JSON loaded into an `any`. A list of\n// errors is returned if validation failed, otherwise `nil`.\n//\n//\ttype MyExample struct {\n//\t\tName string `json:\"name\" maxLength:\"5\"`\n//\t\tAge int `json:\"age\" minimum:\"25\"`\n//\t}\n//\n//\tvar value any\n//\tjson.Unmarshal([]byte(`{\"name\": \"abcdefg\", \"age\": 1}`), &value)\n//\n//\tvalidator := ModelValidator()\n//\terrs := validator.Validate(reflect.TypeOf(MyExample{}), value)\n//\tif errs != nil {\n//\t\tfmt.Println(\"Validation error\", errs)\n//\t}\nfunc (v *ModelValidator) Validate(typ reflect.Type, value any) []error {\n\tv.pb.Reset()\n\tv.result.Reset()\n\n\ts := v.registry.Schema(typ, true, typ.Name())\n\n\tValidate(v.registry, s, v.pb, ModeReadFromServer, value, v.result)\n\n\tif len(v.result.Errors) > 0 {\n\t\treturn v.result.Errors\n\t}\n\treturn nil\n}\n\n// The following is borrowed from the Google UUID package:\n// https://github.com/google/uuid/blob/v1.6.0/uuid.go\n// Copyright (c) 2009,2014 Google Inc. All rights reserved.\n// BSD licensed.\n\ntype invalidLengthError struct{ len int }\n\nfunc (err invalidLengthError) Error() string {\n\treturn fmt.Sprintf(\"invalid UUID length: %d\", err.len)\n}\n\n// xvalues returns the value of a byte as a hexadecimal digit or 255.\nvar xvalues = [256]byte{\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255, 255, 255, 255, 255, 255,\n\t255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n\t255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n}\n\n// xtob converts hex characters x1 and x2 into a byte.\n//\n//nolint:unparam\nfunc xtob(x1, x2 byte) (byte, bool) {\n\tb1 := xvalues[x1]\n\tb2 := xvalues[x2]\n\treturn (b1 << 4) | b2, b1 != 255 && b2 != 255\n}\n\n// validateUUID returns an error if s is not a properly formatted UUID in one of the following formats:\n//\n//\txxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n//\turn:uuid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n//\txxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n//\t{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\n//\n// It returns an error if the format is invalid, otherwise nil.\nfunc validateUUID(s string) error {\n\tswitch len(s) {\n\t// Standard UUID format\n\tcase 36:\n\n\t// UUID with \"urn:uuid:\" prefix\n\tcase 36 + 9:\n\t\tif !strings.EqualFold(s[:9], \"urn:uuid:\") {\n\t\t\treturn fmt.Errorf(\"invalid urn prefix: %q\", s[:9])\n\t\t}\n\t\ts = s[9:]\n\n\t// UUID enclosed in braces\n\tcase 36 + 2:\n\t\tif s[0] != '{' || s[len(s)-1] != '}' {\n\t\t\treturn errors.New(\"invalid bracketed UUID format\")\n\t\t}\n\t\ts = s[1 : len(s)-1]\n\n\t// UUID without hyphens\n\tcase 32:\n\t\tfor i := 0; i < len(s); i += 2 {\n\t\t\t_, ok := xtob(s[i], s[i+1])\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"invalid UUID format\")\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\treturn invalidLengthError{len(s)}\n\t}\n\n\t// Check for standard UUID format\n\tif len(s) == 36 {\n\t\tif s[8] != '-' || s[13] != '-' || s[18] != '-' || s[23] != '-' {\n\t\t\treturn errors.New(\"invalid UUID format\")\n\t\t}\n\t\tfor _, x := range []int{0, 2, 4, 6, 9, 11, 14, 16, 19, 21, 24, 26, 28, 30, 32, 34} {\n\t\t\tif _, ok := xtob(s[x], s[x+1]); !ok {\n\t\t\t\treturn errors.New(\"invalid UUID format\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "validate_test.go",
          "type": "blob",
          "size": 41.662109375,
          "content": "package huma_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/validation\"\n)\n\nfunc Ptr[T any](v T) *T {\n\treturn &v\n}\n\nfunc mapTo[A, B any](s []A, f func(A) B) []B {\n\tr := make([]B, len(s))\n\tfor i, v := range s {\n\t\tr[i] = f(v)\n\t}\n\treturn r\n}\n\nvar validateTests = []struct {\n\tname    string\n\ttyp     reflect.Type\n\ts       *huma.Schema\n\tinput   any\n\tmode    huma.ValidateMode\n\terrs    []string\n\tpanic   string\n\tbefore  func()\n\tcleanup func()\n}{\n\t{\n\t\tname:  \"bool success\",\n\t\ttyp:   reflect.TypeOf(true),\n\t\tinput: true,\n\t},\n\t{\n\t\tname:  \"expected bool\",\n\t\ttyp:   reflect.TypeOf(true),\n\t\tinput: 1.23,\n\t\terrs:  []string{\"expected boolean\"},\n\t},\n\t{\n\t\tname:  \"int success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: 0,\n\t},\n\t{\n\t\tname:  \"int from float64 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: float64(0),\n\t},\n\t{\n\t\tname:  \"int from int8 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: int8(0),\n\t},\n\t{\n\t\tname:  \"int from int16 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: int16(0),\n\t},\n\t{\n\t\tname:  \"int from int32 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: int32(0),\n\t},\n\t{\n\t\tname:  \"int from int64 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: int64(0),\n\t},\n\t{\n\t\tname:  \"int from uint success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: uint(0),\n\t},\n\t{\n\t\tname:  \"int from uint8 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: uint8(0),\n\t},\n\t{\n\t\tname:  \"int from uint16 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: uint16(0),\n\t},\n\t{\n\t\tname:  \"int from uint32 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: uint32(0),\n\t},\n\t{\n\t\tname:  \"int from uint64 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: uint64(0),\n\t},\n\t{\n\t\tname:  \"float64 from int success\",\n\t\ttyp:   reflect.TypeOf(0.0),\n\t\tinput: 0,\n\t},\n\t{\n\t\tname:  \"float64 from float32 success\",\n\t\ttyp:   reflect.TypeOf(0.0),\n\t\tinput: float32(0),\n\t},\n\t{\n\t\tname:  \"int64 success\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: int64(0),\n\t},\n\t{\n\t\tname:  \"expected number int\",\n\t\ttyp:   reflect.TypeOf(0),\n\t\tinput: \"\",\n\t\terrs:  []string{\"expected number\"},\n\t},\n\t{\n\t\tname:  \"expected number float64\",\n\t\ttyp:   reflect.TypeOf(float64(0)),\n\t\tinput: \"\",\n\t\terrs:  []string{\"expected number\"},\n\t},\n\t{\n\t\tname: \"minimum success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" minimum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 1},\n\t},\n\t{\n\t\tname: \"minimum fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" minimum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 0},\n\t\terrs:  []string{\"expected number >= 1\"},\n\t},\n\t{\n\t\tname: \"exclusive minimum success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" exclusiveMinimum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 2},\n\t},\n\t{\n\t\tname: \"exclusive minimum fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" exclusiveMinimum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 1},\n\t\terrs:  []string{\"expected number > 1\"},\n\t},\n\t{\n\t\tname: \"maximum success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" maximum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 1},\n\t},\n\t{\n\t\tname: \"maximum fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" maximum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 2},\n\t\terrs:  []string{\"expected number <= 1\"},\n\t},\n\t{\n\t\tname: \"exclusive maximum success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" exclusiveMaximum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 0},\n\t},\n\t{\n\t\tname: \"exclusive maximum fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" exclusiveMaximum:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 1},\n\t\terrs:  []string{\"expected number < 1\"},\n\t},\n\t{\n\t\tname: \"multiple of success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" multipleOf:\"5\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 10},\n\t},\n\t{\n\t\tname: \"multiple of fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" multipleOf:\"5\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 2},\n\t\terrs:  []string{\"expected number to be a multiple of 5\"},\n\t},\n\t{\n\t\tname:  \"string success\",\n\t\ttyp:   reflect.TypeOf(\"\"),\n\t\tinput: \"\",\n\t},\n\t{\n\t\tname:  \"expected string\",\n\t\ttyp:   reflect.TypeOf(\"\"),\n\t\tinput: 1,\n\t\terrs:  []string{\"expected string\"},\n\t},\n\t{\n\t\tname: \"min length success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" minLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"a\"},\n\t},\n\t{\n\t\tname: \"min length fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" minLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"\"},\n\t\terrs:  []string{\"expected length >= 1\"},\n\t},\n\t{\n\t\tname: \"max length success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" maxLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"a\"},\n\t},\n\t{\n\t\tname: \"non ascii max length success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" maxLength:\"2\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"–∞–±\"},\n\t},\n\t{\n\t\tname: \"max length fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" maxLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"ab\"},\n\t\terrs:  []string{\"expected length <= 1\"},\n\t},\n\t{\n\t\tname: \"pattern success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" pattern:\"^[a-z]+$\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"a\"},\n\t},\n\t{\n\t\tname: \"pattern fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" pattern:\"^[a-z]+$\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"a1\"},\n\t\terrs:  []string{\"expected string to match pattern ^[a-z]+$\"},\n\t},\n\t{\n\t\tname: \"pattern custom message fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" pattern:\"^[a-z]+$\" patternDescription:\"alphabetical\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"b@2\"},\n\t\terrs:  []string{\"expected string to be alphabetical\"},\n\t},\n\t{\n\t\tname: \"pattern invalid\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" pattern:\"^[a-\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"a1\"},\n\t\tpanic: \"error parsing regexp\",\n\t},\n\t{\n\t\tname: \"datetime success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue time.Time `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []byte(\"2020-03-07T22:22:06-08:00\")},\n\t},\n\t{\n\t\tname: \"datetime string success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"date-time\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []byte(\"2020-03-07T22:22:06-08:00\")},\n\t},\n\t{\n\t\tname: \"expected datetime\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue time.Time `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"bad\"},\n\t\terrs:  []string{\"expected string to be RFC 3339 date-time\"},\n\t},\n\t{\n\t\tname: \"date-time-http success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"date-time-http\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []byte(\"Mon, 01 Jan 2023 12:00:00 GMT\")},\n\t},\n\t{\n\t\tname: \"expected date-time-http\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue time.Time `json:\"value\" format:\"date-time-http\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"bad\"},\n\t\terrs:  []string{\"expected string to be RFC 1123 date-time\"},\n\t},\n\t{\n\t\tname: \"date success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue time.Time `json:\"value\" format:\"date\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"2020-03-07\"},\n\t},\n\t{\n\t\tname: \"expected date\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue time.Time `json:\"value\" format:\"date\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"bad\"},\n\t\terrs:  []string{\"expected string to be RFC 3339 date\"},\n\t},\n\t{\n\t\tname: \"time success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"time\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"22:22:06-08:00\"},\n\t},\n\t{\n\t\tname: \"expected time\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"time\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"bad\"},\n\t\terrs:  []string{\"expected string to be RFC 3339 time\"},\n\t},\n\t{\n\t\tname: \"email success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"email\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"alice@example.com\"},\n\t},\n\t{\n\t\tname: \"expected email\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"email\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"alice\"},\n\t\terrs:  []string{\"expected string to be RFC 5322 email: mail: missing '@' or angle-addr\"},\n\t},\n\t{\n\t\tname: \"hostname success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"hostname\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"example.com\"},\n\t},\n\t{\n\t\tname: \"expected hostname\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"hostname\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"%$^\"},\n\t\terrs:  []string{\"expected string to be RFC 5890 hostname\"},\n\t},\n\t{\n\t\tname: \"idn-hostname success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"idn-hostname\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"√´xample.com\"},\n\t},\n\t// {\n\t// \tname: \"expected idn-hostname\",\n\t// \ttyp: reflect.TypeOf(struct {\n\t// \t\tValue string `json:\"value\" format:\"idn-hostname\"`\n\t// \t}{}),\n\t// \tinput: map[string]any{\"value\": \"\\\\\"},\n\t// \terrs:  []string{\"expected string to be RFC 5890 hostname\"},\n\t// },\n\t{\n\t\tname: \"ipv4 success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"ipv4\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"127.0.0.1\"},\n\t},\n\t{\n\t\tname: \"expected ipv4\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"ipv4\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"1234\"},\n\t\terrs:  []string{\"expected string to be RFC 2673 ipv4\"},\n\t},\n\t{\n\t\tname: \"ipv6 success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"ipv6\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"},\n\t},\n\t{\n\t\tname: \"expected ipv6\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"ipv6\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"1234\"},\n\t\terrs:  []string{\"expected string to be RFC 2373 ipv6\"},\n\t},\n\t{\n\t\tname: \"uri success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uri\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"http://example.com\"},\n\t},\n\t{\n\t\tname: \"expected uri\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uri\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \":\"},\n\t\terrs:  []string{\"expected string to be RFC 3986 uri: parse \\\":\\\": missing protocol scheme\"},\n\t},\n\t{\n\t\tname: \"uuid success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"123e4567-e89b-12d3-a456-426655440000\"},\n\t},\n\t{\n\t\tname: \"uuid success prefix\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"urn:uuid:123e4567-e89b-12d3-a456-426655440000\"},\n\t},\n\t{\n\t\tname: \"uuid success braces\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"{123e4567-e89b-12d3-a456-426655440000}\"},\n\t},\n\t{\n\t\tname: \"expected uuid\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"bad\"},\n\t\terrs:  []string{\"expected string to be RFC 4122 uuid: invalid UUID length: 3\"},\n\t},\n\t{\n\t\tname: \"expected uuid prefix\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"urn:test:123e4567-e89b-12d3-a456-426655440000\"},\n\t\terrs:  []string{\"expected string to be RFC 4122 uuid: invalid urn prefix: \\\"urn:test:\\\"\"},\n\t},\n\t{\n\t\tname: \"expected uuid bracket\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"[123e4567-e89b-12d3-a456-426655440000]\"},\n\t\terrs:  []string{\"expected string to be RFC 4122 uuid: invalid bracketed UUID format\"},\n\t},\n\t{\n\t\tname: \"expected uuid format\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"12345678gabc1234abcd1234abcd1234\"},\n\t\terrs:  []string{\"expected string to be RFC 4122 uuid: invalid UUID format\"},\n\t},\n\t{\n\t\tname: \"expected uuid format\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"12345678gabc1234abcd1234abcd12345678\"},\n\t\terrs:  []string{\"expected string to be RFC 4122 uuid: invalid UUID format\"},\n\t},\n\t{\n\t\tname: \"expected uuid format\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uuid\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"\\n23e4567-e89b-12d3-a456-426655440000\"},\n\t\terrs:  []string{\"expected string to be RFC 4122 uuid: invalid UUID format\"},\n\t},\n\t{\n\t\tname: \"uritemplate success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uri-template\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"/items/{item-id}/history\"},\n\t},\n\t{\n\t\tname: \"expected uritemplate bad url\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uri-template\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \":\"},\n\t\terrs:  []string{\"expected string to be RFC 3986 uri: parse \\\":\\\": missing protocol scheme\"},\n\t},\n\t{\n\t\tname: \"expected uritemplate\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"uri-template\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"missing{\"},\n\t\terrs:  []string{\"expected string to be RFC 6570 uri-template\"},\n\t},\n\t{\n\t\tname: \"jsonpointer success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"json-pointer\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"/foo/bar\"},\n\t},\n\t{\n\t\tname: \"expected jsonpointer\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"json-pointer\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"bad\"},\n\t\terrs:  []string{\"expected string to be RFC 6901 json-pointer\"},\n\t},\n\t{\n\t\tname: \"rel jsonpointer success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"relative-json-pointer\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"0\"},\n\t},\n\t{\n\t\tname: \"expected rel jsonpointer\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"relative-json-pointer\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"/bad\"},\n\t\terrs:  []string{\"expected string to be RFC 6901 relative-json-pointer\"},\n\t},\n\t{\n\t\tname: \"regex success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"regex\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"^[0-9a-f]+$\"},\n\t},\n\t{\n\t\tname: \"expected regex\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" format:\"regex\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"^[bad\"},\n\t\terrs:  []string{\"expected string to be regex: error parsing regexp: missing closing ]: `[bad`\"},\n\t},\n\t{\n\t\tname: \"base64 byte success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []byte `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []byte(\"ABCD\")},\n\t},\n\t{\n\t\tname: \"base64 string success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" encoding:\"base64\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"ABCD\"},\n\t},\n\t{\n\t\tname: \"base64 fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []byte `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []byte(\"!\")},\n\t\terrs:  []string{\"expected string to be base64 encoded\"},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]any{}),\n\t\tinput: []any{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]int{}),\n\t\tinput: []int{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]int8{}),\n\t\tinput: []int8{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]int16{}),\n\t\tinput: []int16{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]int32{}),\n\t\tinput: []int32{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]int64{}),\n\t\tinput: []int64{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]uint{}),\n\t\tinput: []uint{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]uint16{}),\n\t\tinput: []uint16{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]uint32{}),\n\t\tinput: []uint32{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]uint64{}),\n\t\tinput: []uint64{1, 2, 3},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]float32{}),\n\t\tinput: []float32{1.1, 2.3, 3.52},\n\t},\n\t{\n\t\tname:  \"array success\",\n\t\ttyp:   reflect.TypeOf([]float64{}),\n\t\tinput: []float64{3.1, 2.3, 3.62},\n\t},\n\t{\n\t\tname:  \"expected array\",\n\t\ttyp:   reflect.TypeOf([]any{}),\n\t\tinput: 1,\n\t\terrs:  []string{\"expected array\"},\n\t},\n\t{\n\t\tname: \"min items success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []any `json:\"value\" minItems:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{1}},\n\t},\n\t{\n\t\tname: \"expected min items\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []any `json:\"value\" minItems:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{}},\n\t\terrs:  []string{\"expected array length >= 1\"},\n\t},\n\t{\n\t\tname: \"max items success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []any `json:\"value\" maxItems:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{1}},\n\t},\n\t{\n\t\tname: \"expected max items\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []any `json:\"value\" maxItems:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{1, 2}},\n\t\terrs:  []string{\"expected array length <= 1\"},\n\t},\n\t{\n\t\tname: \"unique success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []any `json:\"value\" uniqueItems:\"true\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{1, 2, 3, 4, 5}},\n\t},\n\t{\n\t\tname: \"expected unique\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []any `json:\"value\" uniqueItems:\"true\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{1, 2, 1, 3}},\n\t\terrs:  []string{\"expected array items to be unique\"},\n\t},\n\t{\n\t\tname:  \"map success\",\n\t\ttyp:   reflect.TypeOf(map[string]int{}),\n\t\tinput: map[string]any{\"one\": 1, \"two\": 2},\n\t},\n\t{\n\t\tname:  \"map any success\",\n\t\ttyp:   reflect.TypeOf(map[string]int{}),\n\t\tinput: map[any]any{\"one\": 1, \"two\": 2},\n\t},\n\t{\n\t\tname:  \"map any int success\",\n\t\ttyp:   reflect.TypeOf(map[int]string{}),\n\t\tinput: map[any]any{1: \"one\", 2: \"two\"},\n\t},\n\t{\n\t\tname:  \"expected map item\",\n\t\ttyp:   reflect.TypeOf(map[any]int{}),\n\t\tinput: map[string]any{\"one\": 1, \"two\": true},\n\t\terrs:  []string{\"expected number\"},\n\t},\n\t{\n\t\tname:  \"expected map any item\",\n\t\ttyp:   reflect.TypeOf(map[any]int{}),\n\t\tinput: map[any]any{\"one\": 1, \"two\": true},\n\t\terrs:  []string{\"expected number\"},\n\t},\n\t{\n\t\tname: \"map minProps success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[string]int `json:\"value\" minProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\n\t\t\t\"value\": map[string]any{\"one\": 1},\n\t\t},\n\t},\n\t{\n\t\tname: \"map any minProps success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[any]int `json:\"value\" minProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[any]any{\n\t\t\t\"value\": map[any]any{\"one\": 1},\n\t\t},\n\t},\n\t{\n\t\tname: \"expected map minProps\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[string]int `json:\"value\" minProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\n\t\t\t\"value\": map[string]any{},\n\t\t},\n\t\terrs: []string{\"expected object with at least 1 properties\"},\n\t},\n\t{\n\t\tname: \"expected map any minProps\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[any]int `json:\"value\" minProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[any]any{\n\t\t\t\"value\": map[any]any{},\n\t\t},\n\t\terrs: []string{\"expected object with at least 1 properties\"},\n\t},\n\t{\n\t\tname: \"map maxProps success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[string]int `json:\"value\" maxProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\n\t\t\t\"value\": map[string]any{\"one\": 1},\n\t\t},\n\t},\n\t{\n\t\tname: \"map any maxProps success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[any]int `json:\"value\" maxProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[any]any{\n\t\t\t\"value\": map[any]any{\"one\": 1},\n\t\t},\n\t},\n\t{\n\t\tname: \"expected map maxProps\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[string]int `json:\"value\" maxProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\n\t\t\t\"value\": map[string]any{\"one\": 1, \"two\": 2},\n\t\t},\n\t\terrs: []string{\"expected object with at most 1 properties\"},\n\t},\n\t{\n\t\tname: \"expected map any maxProps\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue map[any]int `json:\"value\" maxProperties:\"1\"`\n\t\t}{}),\n\t\tinput: map[any]any{\n\t\t\t\"value\": map[any]any{\"one\": 1, \"two\": 2},\n\t\t},\n\t\terrs: []string{\"expected object with at most 1 properties\"},\n\t},\n\t{\n\t\tname: \"json.RawMessage success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue json.RawMessage `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": map[string]any{\"some\": []any{\"thing\"}}},\n\t},\n\t{\n\t\tname:  \"object struct success\",\n\t\ttyp:   reflect.TypeOf(struct{}{}),\n\t\tinput: map[string]any{},\n\t},\n\t{\n\t\tname:  \"object struct any success\",\n\t\ttyp:   reflect.TypeOf(struct{}{}),\n\t\tinput: map[any]any{},\n\t},\n\t{\n\t\tname:  \"expected object\",\n\t\ttyp:   reflect.TypeOf(struct{}{}),\n\t\tinput: true,\n\t\terrs:  []string{\"expected object\"},\n\t},\n\t{\n\t\tname: \"object optional success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value,omitempty\"`\n\t\t}{}),\n\t\tinput: map[string]any{},\n\t},\n\t{\n\t\tname: \"object any optional success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value,omitempty\"`\n\t\t}{}),\n\t\tinput: map[any]any{},\n\t},\n\t{\n\t\tname: \"readOnly set success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" readOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeWriteToServer,\n\t\tinput: map[string]any{\"value\": \"whoops\"},\n\t},\n\t{\n\t\tname: \"readOnly any set success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" readOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeWriteToServer,\n\t\tinput: map[any]any{\"value\": \"whoops\"},\n\t},\n\t{\n\t\tname: \"readOnly missing success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" readOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeWriteToServer,\n\t\tinput: map[string]any{},\n\t},\n\t{\n\t\tname: \"readOnly any missing success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" readOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeWriteToServer,\n\t\tinput: map[any]any{},\n\t},\n\t{\n\t\tname: \"readOnly missing fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" readOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeReadFromServer,\n\t\tinput: map[string]any{},\n\t\terrs:  []string{\"expected required property value to be present\"},\n\t},\n\t{\n\t\tname: \"readOnly any missing fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" readOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeReadFromServer,\n\t\tinput: map[any]any{},\n\t\terrs:  []string{\"expected required property value to be present\"},\n\t},\n\t{\n\t\tname: \"writeOnly missing fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" writeOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeReadFromServer,\n\t\tinput: map[string]any{\"value\": \"should not be set\"},\n\t\terrs:  []string{\"write only property is non-zero\"},\n\t},\n\t{\n\t\tname: \"writeOnly any missing fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" writeOnly:\"true\"`\n\t\t}{}),\n\t\tmode:  huma.ModeReadFromServer,\n\t\tinput: map[any]any{\"value\": \"should not be set\"},\n\t\terrs:  []string{\"write only property is non-zero\"},\n\t},\n\t{\n\t\tname: \"case-insensive success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"VaLuE\": \"works\"},\n\t},\n\t{\n\t\tname: \"case-insensive fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" maxLength:\"3\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"VaLuE\": \"fails\"},\n\t\terrs:  []string{\"expected length <= 3\"},\n\t},\n\t{\n\t\tname:    \"case-sensive fail\",\n\t\tbefore:  func() { huma.ValidateStrictCasing = true },\n\t\tcleanup: func() { huma.ValidateStrictCasing = false },\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"VaLuE\": \"fails due to casing\"},\n\t\terrs: []string{\n\t\t\t\"expected required property value to be present\",\n\t\t\t\"unexpected property\",\n\t\t},\n\t},\n\t{\n\t\tname: \"unexpected property\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value,omitempty\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value2\": \"whoops\"},\n\t\terrs:  []string{\"unexpected property\"},\n\t},\n\t{\n\t\tname: \"unexpected property any\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value,omitempty\"`\n\t\t}{}),\n\t\tinput: map[any]any{123: \"whoops\"},\n\t\terrs:  []string{\"unexpected property\"},\n\t},\n\t{\n\t\tname: \"nested success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tItems []struct {\n\t\t\t\tValue string `json:\"value\"`\n\t\t\t} `json:\"items\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"items\": []any{map[string]any{\"value\": \"hello\"}}},\n\t},\n\t{\n\t\tname: \"nested any success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tItems []struct {\n\t\t\t\tValue string `json:\"value\"`\n\t\t\t} `json:\"items\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"items\": []any{map[any]any{\"value\": \"hello\"}}},\n\t},\n\t{\n\t\tname: \"expected nested\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tItems []struct {\n\t\t\t\tValue string `json:\"value\"`\n\t\t\t} `json:\"items\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"items\": []any{map[string]any{}}},\n\t\terrs:  []string{\"expected required property value to be present\"},\n\t},\n\t{\n\t\tname: \"expected nested any\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tItems []struct {\n\t\t\t\tValue string `json:\"value\"`\n\t\t\t} `json:\"items\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"items\": []any{map[any]any{}}},\n\t\terrs:  []string{\"expected required property value to be present\"},\n\t},\n\t{\n\t\tname: \"manual object property required\",\n\t\ts: &huma.Schema{\n\t\t\tType:     huma.TypeObject,\n\t\t\tRequired: []string{\"value\"},\n\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\"value\": {Type: huma.TypeString},\n\t\t\t},\n\t\t},\n\t\tinput: map[string]any{},\n\t\terrs:  []string{\"expected required property value to be present\"},\n\t},\n\t{\n\t\tname: \"enum string success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" enum:\"one,two\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"one\"},\n\t},\n\t{\n\t\tname: \"enum int success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue int `json:\"value\" enum:\"1,5,9\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 1.0},\n\t},\n\t{\n\t\tname: \"enum uint16 success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue uint16 `json:\"value\" enum:\"1,5,9\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": 1.0},\n\t},\n\t{\n\t\tname: \"enum array success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue []int `json:\"value\" enum:\"1,5,9\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": []any{1.0}},\n\t},\n\t{\n\t\tname: \"expected enum\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" enum:\"one,two\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"three\"},\n\t\terrs:  []string{\"expected value to be one of \\\"one, two\\\"\"},\n\t},\n\t{\n\t\tname: \"optional success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value,omitempty\" minLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{},\n\t},\n\t{\n\t\tname: \"optional null success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue *string `json:\"value,omitempty\" minLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": nil},\n\t},\n\t{\n\t\tname: \"optional any null success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue *string `json:\"value,omitempty\" minLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"value\": nil},\n\t},\n\t{\n\t\tname: \"optional fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value,omitempty\" minLength:\"1\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"\"},\n\t\terrs:  []string{\"expected length >= 1\"},\n\t},\n\t{\n\t\tname: \"hidden is optional\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" minLength:\"5\" hidden:\"true\"`\n\t\t}{}),\n\t\tinput: map[any]any{},\n\t},\n\t{\n\t\tname: \"hidden success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" minLength:\"5\" hidden:\"true\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"value\": \"abcde\"},\n\t},\n\t{\n\t\tname: \"hidden fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue string `json:\"value\" minLength:\"5\" hidden:\"true\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"value\": \"abc\"},\n\t\terrs:  []string{\"expected length >= 5\"},\n\t},\n\t{\n\t\tname: \"dependentRequired empty success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"dependent\"`\n\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t}{}),\n\t\tinput: map[string]any{},\n\t\terrs:  nil,\n\t},\n\t{\n\t\tname: \"dependentRequired filled success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"dependent\"`\n\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value\": \"abc\", \"dependent\": \"123\"},\n\t\terrs:  nil,\n\t},\n\t{\n\t\tname: \"dependentRequired ignored success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"\"`\n\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t}{}),\n\t\tinput: map[string]any{},\n\t\terrs:  nil,\n\t},\n\t{\n\t\tname: \"dependentRequired failure\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue1     string `json:\"value1,omitempty\" dependentRequired:\"dependent1,dependent3\"`\n\t\t\tDependent1 string `json:\"dependent1,omitempty\"`\n\t\t\tValue2     string `json:\"value2,omitempty\" dependentRequired:\"dependent2,dependent3\"`\n\t\t\tDependent2 string `json:\"dependent2,omitempty\"`\n\t\t\tDependent3 string `json:\"dependent3,omitempty\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"value1\": \"abc\", \"value2\": \"123\"},\n\t\terrs: []string{\n\t\t\t\"expected property dependent1 to be present when value1 is present\",\n\t\t\t\"expected property dependent3 to be present when value1 is present\",\n\t\t\t\"expected property dependent2 to be present when value2 is present\",\n\t\t\t\"expected property dependent3 to be present when value2 is present\",\n\t\t},\n\t},\n\t{\n\t\tname: \"dependentRequired empty success any\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"dependent\"`\n\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t}{}),\n\t\tinput: map[any]any{},\n\t\terrs:  nil,\n\t},\n\t{\n\t\tname: \"dependentRequired filled success any\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"dependent\"`\n\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"value\": \"abc\", \"dependent\": \"123\"},\n\t\terrs:  nil,\n\t},\n\t{\n\t\tname: \"dependentRequired ignored success any\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue     string `json:\"value,omitempty\" dependentRequired:\"\"`\n\t\t\tDependent string `json:\"dependent,omitempty\"`\n\t\t}{}),\n\t\tinput: map[any]any{},\n\t\terrs:  nil,\n\t},\n\t{\n\t\tname: \"dependentRequired failure any\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tValue1     string `json:\"value1,omitempty\" dependentRequired:\"dependent1,dependent3\"`\n\t\t\tDependent1 string `json:\"dependent1,omitempty\"`\n\t\t\tValue2     string `json:\"value2,omitempty\" dependentRequired:\"dependent2,dependent3\"`\n\t\t\tDependent2 string `json:\"dependent2,omitempty\"`\n\t\t\tDependent3 string `json:\"dependent3,omitempty\"`\n\t\t}{}),\n\t\tinput: map[any]any{\"value1\": \"abc\", \"value2\": \"123\"},\n\t\terrs: []string{\n\t\t\t\"expected property dependent1 to be present when value1 is present\",\n\t\t\t\"expected property dependent3 to be present when value1 is present\",\n\t\t\t\"expected property dependent2 to be present when value2 is present\",\n\t\t\t\"expected property dependent3 to be present when value2 is present\",\n\t\t},\n\t},\n\t{\n\t\tname: \"oneOf success bool\",\n\t\ts: &huma.Schema{\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeBoolean},\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t},\n\t\tinput: true,\n\t},\n\t{\n\t\tname: \"oneOf success string\",\n\t\ts: &huma.Schema{\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeBoolean},\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t},\n\t\tinput: \"hello\",\n\t},\n\t{\n\t\tname: \"oneOf fail zero\",\n\t\ts: &huma.Schema{\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeBoolean},\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t},\n\t\tinput: 123,\n\t\terrs:  []string{\"expected value to match exactly one schema but matched none\"},\n\t},\n\t{\n\t\tname: \"oneOf fail multi\",\n\t\ts: &huma.Schema{\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeNumber, Minimum: Ptr(float64(5))},\n\t\t\t\t{Type: huma.TypeNumber, Maximum: Ptr(float64(10))},\n\t\t\t},\n\t\t},\n\t\tinput: 8,\n\t\terrs:  []string{\"expected value to match exactly one schema but matched multiple\"},\n\t},\n\t{\n\t\tname: \"anyOf success\",\n\t\ts: &huma.Schema{\n\t\t\tAnyOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeNumber, Minimum: Ptr(float64(5))},\n\t\t\t\t{Type: huma.TypeNumber, Maximum: Ptr(float64(10))},\n\t\t\t},\n\t\t},\n\t\tinput: 8,\n\t},\n\t{\n\t\tname: \"anyOf fail\",\n\t\ts: &huma.Schema{\n\t\t\tAnyOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeNumber, Minimum: Ptr(float64(5))},\n\t\t\t\t{Type: huma.TypeNumber, Minimum: Ptr(float64(10))},\n\t\t\t},\n\t\t},\n\t\tinput: 1,\n\t\terrs:  []string{\"expected value to match at least one schema but matched none\"},\n\t},\n\t{\n\t\tname: \"allOf success\",\n\t\ts: &huma.Schema{\n\t\t\tAllOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeNumber, Minimum: Ptr(float64(5))},\n\t\t\t\t{Type: huma.TypeNumber, Maximum: Ptr(float64(10))},\n\t\t\t},\n\t\t},\n\t\tinput: 8,\n\t},\n\t{\n\t\tname: \"allOf fail\",\n\t\ts: &huma.Schema{\n\t\t\tAllOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeNumber, Minimum: Ptr(float64(5))},\n\t\t\t\t{Type: huma.TypeNumber, Maximum: Ptr(float64(10))},\n\t\t\t},\n\t\t},\n\t\tinput: 12,\n\t\terrs:  []string{\"expected number <= 10\"},\n\t},\n\t{\n\t\tname: \"not success\",\n\t\ts: &huma.Schema{\n\t\t\tNot: &huma.Schema{Type: huma.TypeNumber},\n\t\t},\n\t\tinput: \"hello\",\n\t},\n\t{\n\t\tname: \"not fail\",\n\t\ts: &huma.Schema{\n\t\t\tNot: &huma.Schema{Type: huma.TypeNumber},\n\t\t},\n\t\tinput: 5,\n\t\terrs:  []string{\"expected value to not match schema\"},\n\t},\n\t{\n\t\tname:  \"nullable success\",\n\t\ts:     &huma.Schema{Type: huma.TypeNumber, Nullable: true},\n\t\tinput: nil,\n\t},\n\t{\n\t\tname: \"pointer required field success\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tField *int `json:\"field\" required:\"true\" nullable:\"true\"`\n\t\t}{}),\n\t\tinput: map[string]any{\"field\": nil},\n\t},\n\t{\n\t\tname: \"pointer required field fail\",\n\t\ttyp: reflect.TypeOf(struct {\n\t\t\tField *int `json:\"field\" required:\"true\" nullable:\"true\"`\n\t\t}{}),\n\t\tinput: map[string]any{},\n\t\terrs:  []string{\"expected required property field to be present\"},\n\t},\n\t{\n\t\tname: \"discriminator: input expected to be an object\",\n\t\ts: &huma.Schema{\n\t\t\tType: huma.TypeObject,\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t\tDiscriminator: &huma.Discriminator{\n\t\t\t\tPropertyName: \"inputType\",\n\t\t\t},\n\t\t},\n\t\tinput: \"test\",\n\t\terrs:  []string{validation.MsgExpectedObject},\n\t},\n\t{\n\t\tname: \"discriminator: propertyName expected to be present in object\",\n\t\ts: &huma.Schema{\n\t\t\tType: huma.TypeObject,\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\"inputType\": {Type: huma.TypeString},\n\t\t\t},\n\t\t\tDiscriminator: &huma.Discriminator{\n\t\t\t\tPropertyName: \"inputType\",\n\t\t\t},\n\t\t},\n\t\tinput: map[string]any{\"undefined\": \"\"},\n\t\terrs:  []string{validation.MsgExpectedPropertyNameInObject},\n\t},\n\t{\n\t\tname: \"discriminator: propertyName expected to be present in any object\",\n\t\ts: &huma.Schema{\n\t\t\tType: huma.TypeObject,\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\"inputType\": {Type: huma.TypeString},\n\t\t\t},\n\t\t\tDiscriminator: &huma.Discriminator{\n\t\t\t\tPropertyName: \"inputType\",\n\t\t\t},\n\t\t},\n\t\tinput: map[any]any{\"undefined\": \"\"},\n\t\terrs:  []string{validation.MsgExpectedPropertyNameInObject},\n\t},\n\t{\n\t\tname: \"discriminator: propertyName expected to be string\",\n\t\ts: &huma.Schema{\n\t\t\tType: huma.TypeObject,\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\"inputType\": {Type: huma.TypeString},\n\t\t\t},\n\t\t\tDiscriminator: &huma.Discriminator{\n\t\t\t\tPropertyName: \"inputType\",\n\t\t\t},\n\t\t},\n\t\tinput: map[string]any{\"inputType\": 1},\n\t\terrs:  []string{validation.MsgExpectedString},\n\t},\n\t{\n\t\tname: \"discriminator: propertyName not explicitly mapped\",\n\t\ts: &huma.Schema{\n\t\t\tType: huma.TypeObject,\n\t\t\tOneOf: []*huma.Schema{\n\t\t\t\t{Type: huma.TypeString},\n\t\t\t},\n\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\"inputType\": {Type: huma.TypeString},\n\t\t\t},\n\t\t\tDiscriminator: &huma.Discriminator{\n\t\t\t\tPropertyName: \"inputType\",\n\t\t\t},\n\t\t},\n\t\tinput: map[string]any{\"inputType\": \"test\"},\n\t\terrs:  []string{validation.MsgExpectedMatchExactlyOneSchema},\n\t},\n}\n\nfunc TestValidate(t *testing.T) {\n\tpb := huma.NewPathBuffer([]byte(\"\"), 0)\n\tres := &huma.ValidateResult{}\n\n\tfor _, test := range validateTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif test.before != nil {\n\t\t\t\ttest.before()\n\t\t\t}\n\t\t\tif test.cleanup != nil {\n\t\t\t\tdefer test.cleanup()\n\t\t\t}\n\n\t\t\tregistry := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\n\t\t\tvar s *huma.Schema\n\t\t\tif test.panic != \"\" {\n\t\t\t\tassert.Panics(t, func() {\n\t\t\t\t\tregistry.Schema(test.typ, true, \"TestInput\")\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tif test.s != nil {\n\t\t\t\t\ts = test.s\n\t\t\t\t\ts.PrecomputeMessages()\n\t\t\t\t} else {\n\t\t\t\t\ts = registry.Schema(test.typ, true, \"TestInput\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpb.Reset()\n\t\t\tres.Reset()\n\n\t\t\thuma.Validate(registry, s, pb, test.mode, test.input, res)\n\n\t\t\tassert.Len(t, res.Errors, len(test.errs))\n\t\t\tif len(test.errs) > 0 {\n\t\t\t\terrs := mapTo(res.Errors, func(e error) string {\n\t\t\t\t\treturn e.(*huma.ErrorDetail).Message\n\t\t\t\t})\n\t\t\t\tschemaJSON, _ := json.MarshalIndent(registry.Map(), \"\", \"  \")\n\t\t\t\tfor _, err := range test.errs {\n\t\t\t\t\tassert.Contains(t, errs, err, string(schemaJSON))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Empty(t, res.Errors)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateCustomFormatter(t *testing.T) {\n\toriginalFormatter := huma.ErrorFormatter\n\tdefer func() {\n\t\thuma.ErrorFormatter = originalFormatter\n\t}()\n\n\thuma.ErrorFormatter = func(format string, a ...any) string {\n\t\treturn fmt.Sprintf(\"custom: %v\", a)\n\t}\n\n\tregistry := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := registry.Schema(reflect.TypeOf(struct {\n\t\tValue string `json:\"value\" format:\"email\"`\n\t}{}), true, \"TestInput\")\n\tpb := huma.NewPathBuffer([]byte(\"\"), 0)\n\tres := &huma.ValidateResult{}\n\n\thuma.Validate(registry, s, pb, huma.ModeReadFromServer, map[string]any{\"value\": \"alice\"}, res)\n\tassert.Len(t, res.Errors, 1)\n\tassert.Equal(t, \"custom: [mail: missing '@' or angle-addr] (value: alice)\", res.Errors[0].Error())\n}\n\ntype TransformDeleteField struct {\n\tField1 string `json:\"field1\"`\n\tField2 string `json:\"field2\"`\n}\n\nvar _ huma.SchemaTransformer = (*TransformDeleteField)(nil)\n\nfunc (t *TransformDeleteField) TransformSchema(r huma.Registry, s *huma.Schema) *huma.Schema {\n\tdelete(s.Properties, \"field2\")\n\treturn s\n}\n\nfunc TestValidateSchemaTransformerDeleteField(t *testing.T) {\n\tregistry := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\ts := registry.Schema(reflect.TypeOf(&TransformDeleteField{}), true, \"TestInput\")\n\tpb := huma.NewPathBuffer([]byte(\"\"), 0)\n\tres := &huma.ValidateResult{}\n\n\thuma.Validate(registry, s, pb, huma.ModeReadFromServer, map[string]any{\"field1\": \"value1\"}, res)\n\t// We should have no errors and no panics.\n\tassert.Empty(t, res.Errors)\n\tassert.NotContains(t, s.Properties, \"field2\")\n}\n\nfunc ExampleModelValidator() {\n\t// Define a type you want to validate.\n\ttype Model struct {\n\t\tName string `json:\"name\" maxLength:\"5\"`\n\t\tAge  int    `json:\"age\" minimum:\"25\"`\n\t}\n\n\ttyp := reflect.TypeOf(Model{})\n\n\t// Unmarshal some JSON into an `any` for validation. This input should not\n\t// validate against the schema for the struct above.\n\tvar val any\n\tjson.Unmarshal([]byte(`{\"name\": \"abcdefg\", \"age\": 1}`), &val)\n\n\t// Validate the unmarshaled data against the type and print errors.\n\tvalidator := huma.NewModelValidator()\n\terrs := validator.Validate(typ, val)\n\tfmt.Println(errs)\n\n\t// Try again with valid data!\n\tjson.Unmarshal([]byte(`{\"name\": \"foo\", \"age\": 25}`), &val)\n\terrs = validator.Validate(typ, val)\n\tfmt.Println(errs)\n\n\t// Output: [expected number >= 25 (age: 1) expected length <= 5 (name: abcdefg)]\n\t// []\n}\n\nvar BenchValidatePB *huma.PathBuffer\nvar BenchValidateRes *huma.ValidateResult\n\nfunc BenchmarkValidate(b *testing.B) {\n\tpb := huma.NewPathBuffer([]byte(\"\"), 0)\n\tres := &huma.ValidateResult{}\n\tBenchValidatePB = pb\n\tBenchValidateRes = res\n\n\tfor _, test := range validateTests {\n\t\tif test.panic != \"\" || len(test.errs) > 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tb.Run(strings.TrimSuffix(test.name, \" success\"), func(b *testing.B) {\n\t\t\tregistry := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\t\t\ts := registry.Schema(test.typ, false, \"TestInput\")\n\n\t\t\tinput := test.input\n\t\t\tif s.Type == huma.TypeObject && s.Properties[\"value\"] != nil {\n\t\t\t\tswitch i := input.(type) {\n\t\t\t\tcase map[string]any:\n\t\t\t\t\tfor k := range i {\n\t\t\t\t\t\tif strings.EqualFold(k, \"value\") {\n\t\t\t\t\t\t\tinput = i[k]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = s.Properties[\"value\"]\n\t\t\t\tcase map[any]any:\n\t\t\t\t\tfor k := range i {\n\t\t\t\t\t\tif strings.EqualFold(fmt.Sprintf(\"%v\", k), \"value\") {\n\t\t\t\t\t\t\tinput = i[k]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = s.Properties[\"value\"]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb.ReportAllocs()\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tpb.Reset()\n\t\t\t\tres.Reset()\n\t\t\t\thuma.Validate(registry, s, pb, test.mode, input, res)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype Cat struct {\n\tName string `json:\"name\" minLength:\"2\" maxLength:\"10\"`\n\tKind string `json:\"kind\" enum:\"cat\"`\n}\n\ntype Dog struct {\n\tColor string `json:\"color\" enum:\"black,white,brown\"`\n\tKind  string `json:\"kind\" enum:\"dog\"`\n}\n\nfunc Test_validateWithDiscriminator(t *testing.T) {\n\tregistry := huma.NewMapRegistry(\"#/components/schemas/\", huma.DefaultSchemaNamer)\n\tcatSchema := registry.Schema(reflect.TypeOf(Cat{}), true, \"Cat\")\n\tdogSchema := registry.Schema(reflect.TypeOf(Dog{}), true, \"Dog\")\n\n\ts := &huma.Schema{\n\t\tType:        huma.TypeObject,\n\t\tDescription: \"Animal\",\n\t\tOneOf: []*huma.Schema{\n\t\t\t{Ref: catSchema.Ref},\n\t\t\t{Ref: dogSchema.Ref},\n\t\t},\n\t\tDiscriminator: &huma.Discriminator{\n\t\t\tPropertyName: \"kind\",\n\t\t\tMapping: map[string]string{\n\t\t\t\t\"cat\": catSchema.Ref,\n\t\t\t\t\"dog\": dogSchema.Ref,\n\t\t\t},\n\t\t},\n\t}\n\n\tpb := huma.NewPathBuffer([]byte(\"\"), 0)\n\tres := &huma.ValidateResult{}\n\n\ttests := []struct {\n\t\tname     string\n\t\tinput    any\n\t\twantErrs []string\n\t}{\n\t\t{\n\t\t\tname: \"cat - minLength case\",\n\t\t\tinput: map[string]any{\n\t\t\t\t\"kind\": \"cat\",\n\t\t\t\t\"name\": \"c\",\n\t\t\t},\n\t\t\twantErrs: []string{\"expected length >= 2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"cat - maxLength case\",\n\t\t\tinput: map[string]any{\n\t\t\t\t\"kind\": \"cat\",\n\t\t\t\t\"name\": \"aaaaaaaaaaa\",\n\t\t\t},\n\t\t\twantErrs: []string{\"expected length <= 10\"},\n\t\t},\n\t\t{\n\t\t\tname: \"cat - invalid schema\",\n\t\t\tinput: map[string]any{\n\t\t\t\t\"kind\": \"dog\",\n\t\t\t\t\"name\": \"cat\",\n\t\t\t},\n\t\t\twantErrs: []string{\n\t\t\t\t\"expected required property color to be present\",\n\t\t\t\t\"unexpected property\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"cat - any invalid schema\",\n\t\t\tinput: map[any]any{\n\t\t\t\t\"kind\": \"dog\",\n\t\t\t\t\"name\": \"cat\",\n\t\t\t},\n\t\t\twantErrs: []string{\n\t\t\t\t\"expected required property color to be present\",\n\t\t\t\t\"unexpected property\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"cat - ok\",\n\t\t\tinput: map[string]any{\n\t\t\t\t\"kind\": \"cat\",\n\t\t\t\t\"name\": \"meow\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"cat - any ok\",\n\t\t\tinput: map[any]any{\n\t\t\t\t\"kind\": \"cat\",\n\t\t\t\t\"name\": \"meow\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"dog - wrong color\",\n\t\t\tinput: map[string]any{\n\t\t\t\t\"kind\":  \"dog\",\n\t\t\t\t\"color\": \"red\",\n\t\t\t},\n\t\t\twantErrs: []string{\"expected value to be one of \\\"black, white, brown\\\"\"},\n\t\t},\n\t\t{\n\t\t\tname: \"unknown kind\",\n\t\t\tinput: map[string]any{\n\t\t\t\t\"kind\": \"unknown\",\n\t\t\t\t\"foo\":  \"bar\",\n\t\t\t},\n\t\t\twantErrs: []string{validation.MsgExpectedMatchExactlyOneSchema},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tpb.Reset()\n\t\t\tres.Reset()\n\t\t\thuma.Validate(registry, s, pb, huma.ModeWriteToServer, tc.input, res)\n\t\t\trequire.Len(t, res.Errors, len(tc.wantErrs))\n\t\t\tfor i, wantErr := range tc.wantErrs {\n\t\t\t\tassert.Contains(t, res.Errors[i].Error(), wantErr)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "validation",
          "type": "tree",
          "content": null
        },
        {
          "name": "wrk.lua",
          "type": "blob",
          "size": 0.0693359375,
          "content": "wrk.method = \"GET\"\n-- wrk.headers[\"Content-Type\"] = \"application/json\"\n"
        },
        {
          "name": "yaml",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}