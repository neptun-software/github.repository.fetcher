{
  "metadata": {
    "timestamp": 1736566787435,
    "page": 348,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ahmetb/go-linq",
      "stars": 3543,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3447265625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n### Code ###\n# Visual Studio Code - https://code.visualstudio.com/\n.settings/\n.vscode/"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.458984375,
          "content": "sudo: false\n\nlanguage: go\ngo:\n  - 1.11\n  - tip\n\ninstall: true\nenv:\n  - GO111MODULE=on\n\nscript:\n  - go vet -x ./...\n  - test -z \"$(golint ./...)\"\n  - test -z \"$(gofmt -s -l -w . | tee /dev/stderr)\"\n  - go test -v  ./...\n  - go test -covermode=count -coverprofile=profile.cov\n  - test -z \"$(apicompat -before ${TRAVIS_COMMIT_RANGE%...*} -after ${TRAVIS_COMMIT_RANGE#*...} ./... | tee /dev/stderr)\"\n\nafter_script:\n  - goveralls -coverprofile=profile.cov -service=travis-ci\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.080078125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2016 Ahmet Alp Balkan\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.369140625,
          "content": "# go-linq [![GoDoc](https://godoc.org/github.com/ahmetb/go-linq?status.svg)](https://godoc.org/github.com/ahmetb/go-linq) [![Build Status](https://travis-ci.org/ahmetb/go-linq.svg?branch=master)](https://travis-ci.org/ahmetb/go-linq) [![Coverage Status](https://coveralls.io/repos/github/ahmetb/go-linq/badge.svg?branch=master)](https://coveralls.io/github/ahmetb/go-linq?branch=master) [![Go Report Card](https://goreportcard.com/badge/github.com/ahmetb/go-linq)](https://goreportcard.com/report/github.com/ahmetb/go-linq)\n\nA powerful language integrated query (LINQ) library for Go.\n\n* Written in vanilla Go, no dependencies!\n* Complete lazy evaluation with iterator pattern\n* Safe for concurrent use\n* Supports generic functions to make your code cleaner and free of type assertions\n* Supports arrays, slices, maps, strings, channels and custom collections\n\n## Installation\n\nWhen used with Go modules, use the following import path:\n\n    go get github.com/ahmetb/go-linq/v3\n\nOlder versions of Go using different dependency management tools can use the\nfollowing import path to prevent breaking API changes:\n\n    go get gopkg.in/ahmetb/go-linq.v3\n\n## Quickstart\n\nUsage is as easy as chaining methods like:\n\n`From(slice)` `.Where(predicate)` `.Select(selector)` `.Union(data)`\n\n**Example 1: Find all owners of cars manufactured after 2015**\n\n```go\nimport . \"github.com/ahmetb/go-linq/v3\"\n\ntype Car struct {\n    year int\n    owner, model string\n}\n\n...\n\n\nvar owners []string\n\nFrom(cars).Where(func(c interface{}) bool {\n\treturn c.(Car).year >= 2015\n}).Select(func(c interface{}) interface{} {\n\treturn c.(Car).owner\n}).ToSlice(&owners)\n```\n\nOr, you can use generic functions, like `WhereT` and `SelectT` to simplify your code\n(at a performance penalty):\n\n```go\nvar owners []string\n\nFrom(cars).WhereT(func(c Car) bool {\n\treturn c.year >= 2015\n}).SelectT(func(c Car) string {\n\treturn c.owner\n}).ToSlice(&owners)\n```\n\n**Example 2: Find the author who has written the most books**\n\n```go\nimport . \"github.com/ahmetb/go-linq/v3\"\n\ntype Book struct {\n\tid      int\n\ttitle   string\n\tauthors []string\n}\n\nauthor := From(books).SelectMany( // make a flat array of authors\n\tfunc(book interface{}) Query {\n\t\treturn From(book.(Book).authors)\n\t}).GroupBy( // group by author\n\tfunc(author interface{}) interface{} {\n\t\treturn author // author as key\n\t}, func(author interface{}) interface{} {\n\t\treturn author // author as value\n\t}).OrderByDescending( // sort groups by its length\n\tfunc(group interface{}) interface{} {\n\t\treturn len(group.(Group).Group)\n\t}).Select( // get authors out of groups\n\tfunc(group interface{}) interface{} {\n\t\treturn group.(Group).Key\n\t}).First() // take the first author\n```\n\n**Example 3: Implement a custom method that leaves only values greater than the specified threshold**\n\n```go\ntype MyQuery Query\n\nfunc (q MyQuery) GreaterThan(threshold int) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\tif item.(int) > threshold {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\nresult := MyQuery(Range(1,10)).GreaterThan(5).Results()\n```\n\n## Generic Functions\n\nAlthough Go doesn't implement generics, with some reflection tricks, you can use go-linq without\ntyping `interface{}`s and type assertions. This will introduce a performance penalty (5x-10x slower)\nbut will yield in a cleaner and more readable code.\n\nMethods with `T` suffix (such as `WhereT`) accept functions with generic types. So instead of\n\n    .Select(func(v interface{}) interface{} {...})\n\nyou can type:\n\n    .SelectT(func(v YourType) YourOtherType {...})\n\nThis will make your code free of `interface{}` and type assertions.\n\n**Example 4: \"MapReduce\" in a slice of string sentences to list the top 5 most used words using generic functions**\n\n```go\nvar results []string\n\nFrom(sentences).\n\t// split sentences to words\n\tSelectManyT(func(sentence string) Query {\n\t\treturn From(strings.Split(sentence, \" \"))\n\t}).\n\t// group the words\n\tGroupByT(\n\t\tfunc(word string) string { return word },\n\t\tfunc(word string) string { return word },\n\t).\n\t// order by count\n\tOrderByDescendingT(func(wordGroup Group) int {\n\t\treturn len(wordGroup.Group)\n\t}).\n\t// order by the word\n\tThenByT(func(wordGroup Group) string {\n\t\treturn wordGroup.Key.(string)\n\t}).\n\tTake(5).  // take the top 5\n\t// project the words using the index as rank\n\tSelectIndexedT(func(index int, wordGroup Group) string {\n\t\treturn fmt.Sprintf(\"Rank: #%d, Word: %s, Counts: %d\", index+1, wordGroup.Key, len(wordGroup.Group))\n\t}).\n\tToSlice(&results)\n```\n\n**More examples** can be found in the [documentation](https://godoc.org/github.com/ahmetb/go-linq).\n\n## Release Notes\n\n```text\nv3.2.0 (2020-12-29)\n* Added FromChannelT().\n* Added DefaultIfEmpty().\n\nv3.1.0 (2019-07-09)\n* Support for Go modules\n* Added IndexOf()/IndexOfT().\n\nv3.0.0 (2017-01-10)\n* Breaking change: ToSlice() now overwrites existing slice starting\n  from index 0 and grows/reslices it as needed.\n* Generic methods support (thanks @cleitonmarx!)\n  - Accepting parametrized functions was originally proposed in #26\n  - You can now avoid type assertions and interface{}s\n  - Functions with generic methods are named as \"MethodNameT\" and\n    signature for the existing LINQ methods are unchanged.\n* Added ForEach(), ForEachIndexed() and AggregateWithSeedBy().\n\nv2.0.0 (2016-09-02)\n* IMPORTANT: This release is a BREAKING CHANGE. The old version\n  is archived at the 'archive/0.9' branch or the 0.9 tags.\n* A COMPLETE REWRITE of go-linq with better performance and memory\n  efficiency. (thanks @kalaninja!)\n* API has significantly changed. Most notably:\n  - linq.T removed in favor of interface{}\n  - library methods no longer return errors\n  - PLINQ removed for now (see channels support)\n  - support for channels, custom collections and comparables\n\nv0.9-rc4\n* GroupBy()\n\nv0.9-rc3.2\n* bugfix: All() iterating over values instead of indices\n\nv0.9-rc3.1\n* bugfix: modifying result slice affects subsequent query methods\n\nv0.9-rc3\n* removed FirstOrNil, LastOrNil, ElementAtOrNil methods\n\nv0.9-rc2.5\n* slice-accepting methods accept slices of any type with reflections\n\nv0.9-rc2\n* parallel linq (plinq) implemented\n* Queryable separated into Query & ParallelQuery\n* fixed early termination for All\n\nv0.9-rc1\n* many linq methods are implemented\n* methods have error handling support\n* type assertion limitations are unresolved\n* travis-ci.org build integrated\n* open sourced on github, master & dev branches\n```\n"
        },
        {
          "name": "aggregate.go",
          "type": "blob",
          "size": 5.1259765625,
          "content": "package linq\n\n// Aggregate applies an accumulator function over a sequence.\n//\n// Aggregate method makes it simple to perform a calculation over a sequence of\n// values. This method works by calling f() one time for each element in source\n// except the first one. Each time f() is called, Aggregate passes both the\n// element from the sequence and an aggregated value (as the first argument to\n// f()). The first element of source is used as the initial aggregate value. The\n// result of f() replaces the previous aggregated value.\n//\n// Aggregate returns the final result of f().\nfunc (q Query) Aggregate(f func(interface{}, interface{}) interface{}) interface{} {\n\tnext := q.Iterate()\n\n\tresult, any := next()\n\tif !any {\n\t\treturn nil\n\t}\n\n\tfor current, ok := next(); ok; current, ok = next() {\n\t\tresult = f(result, current)\n\t}\n\n\treturn result\n}\n\n// AggregateT is the typed version of Aggregate.\n//\n//   - f is of type: func(TSource, TSource) TSource\n//\n// NOTE: Aggregate has better performance than AggregateT.\nfunc (q Query) AggregateT(f interface{}) interface{} {\n\tfGenericFunc, err := newGenericFunc(\n\t\t\"AggregateT\", \"f\", f,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfFunc := func(result interface{}, current interface{}) interface{} {\n\t\treturn fGenericFunc.Call(result, current)\n\t}\n\n\treturn q.Aggregate(fFunc)\n}\n\n// AggregateWithSeed applies an accumulator function over a sequence. The\n// specified seed value is used as the initial accumulator value.\n//\n// Aggregate method makes it simple to perform a calculation over a sequence of\n// values. This method works by calling f() one time for each element in source\n// except the first one. Each time f() is called, Aggregate passes both the\n// element from the sequence and an aggregated value (as the first argument to\n// f()). The value of the seed parameter is used as the initial aggregate value.\n// The result of f() replaces the previous aggregated value.\n//\n// Aggregate returns the final result of f().\nfunc (q Query) AggregateWithSeed(seed interface{},\n\tf func(interface{}, interface{}) interface{}) interface{} {\n\n\tnext := q.Iterate()\n\tresult := seed\n\n\tfor current, ok := next(); ok; current, ok = next() {\n\t\tresult = f(result, current)\n\t}\n\n\treturn result\n}\n\n// AggregateWithSeedT is the typed version of AggregateWithSeed.\n//\n//   - f is of type \"func(TAccumulate, TSource) TAccumulate\"\n//\n// NOTE: AggregateWithSeed has better performance than\n// AggregateWithSeedT.\nfunc (q Query) AggregateWithSeedT(seed interface{},\n\tf interface{}) interface{} {\n\tfGenericFunc, err := newGenericFunc(\n\t\t\"AggregateWithSeed\", \"f\", f,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfFunc := func(result interface{}, current interface{}) interface{} {\n\t\treturn fGenericFunc.Call(result, current)\n\t}\n\n\treturn q.AggregateWithSeed(seed, fFunc)\n}\n\n// AggregateWithSeedBy applies an accumulator function over a sequence. The\n// specified seed value is used as the initial accumulator value, and the\n// specified function is used to select the result value.\n//\n// Aggregate method makes it simple to perform a calculation over a sequence of\n// values. This method works by calling f() one time for each element in source.\n// Each time func is called, Aggregate passes both the element from the sequence\n// and an aggregated value (as the first argument to func). The value of the\n// seed parameter is used as the initial aggregate value. The result of func\n// replaces the previous aggregated value.\n//\n// The final result of func is passed to resultSelector to obtain the final\n// result of Aggregate.\nfunc (q Query) AggregateWithSeedBy(seed interface{},\n\tf func(interface{}, interface{}) interface{},\n\tresultSelector func(interface{}) interface{}) interface{} {\n\n\tnext := q.Iterate()\n\tresult := seed\n\n\tfor current, ok := next(); ok; current, ok = next() {\n\t\tresult = f(result, current)\n\t}\n\n\treturn resultSelector(result)\n}\n\n// AggregateWithSeedByT is the typed version of AggregateWithSeedBy.\n//\n//   - f is of type \"func(TAccumulate, TSource) TAccumulate\"\n//   - resultSelectorFn is of type \"func(TAccumulate) TResult\"\n//\n// NOTE: AggregateWithSeedBy has better performance than\n// AggregateWithSeedByT.\nfunc (q Query) AggregateWithSeedByT(seed interface{},\n\tf interface{},\n\tresultSelectorFn interface{}) interface{} {\n\tfGenericFunc, err := newGenericFunc(\n\t\t\"AggregateWithSeedByT\", \"f\", f,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfFunc := func(result interface{}, current interface{}) interface{} {\n\t\treturn fGenericFunc.Call(result, current)\n\t}\n\n\tresultSelectorGenericFunc, err := newGenericFunc(\n\t\t\"AggregateWithSeedByT\", \"resultSelectorFn\", resultSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tresultSelectorFunc := func(result interface{}) interface{} {\n\t\treturn resultSelectorGenericFunc.Call(result)\n\t}\n\n\treturn q.AggregateWithSeedBy(seed, fFunc, resultSelectorFunc)\n}\n"
        },
        {
          "name": "aggregate_test.go",
          "type": "blob",
          "size": 3.1064453125,
          "content": "package linq\n\nimport \"testing\"\nimport \"strings\"\n\nfunc TestAggregate(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]string{\"apple\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}, \"passionfruit\"},\n\t\t{[]string{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tr := From(test.input).Aggregate(func(r interface{}, i interface{}) interface{} {\n\t\t\tif len(r.(string)) > len(i.(string)) {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\treturn i\n\t\t})\n\n\t\tif r != test.want {\n\t\t\tt.Errorf(\"From(%v).Aggregate()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestAggregateT_PanicWhenFunctionIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"AggregateT: parameter [f] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func(int,string,string)string'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).AggregateT(func(x int, r string, i string) string {\n\t\t\tif len(r) > len(i) {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\treturn i\n\t\t})\n\t})\n}\n\nfunc TestAggregateWithSeed(t *testing.T) {\n\tinput := []string{\"apple\", \"mango\", \"orange\", \"banana\", \"grape\"}\n\twant := \"passionfruit\"\n\n\tr := From(input).AggregateWithSeed(want,\n\t\tfunc(r interface{}, i interface{}) interface{} {\n\t\t\tif len(r.(string)) > len(i.(string)) {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\treturn i\n\t\t})\n\n\tif r != want {\n\t\tt.Errorf(\"From(%v).AggregateWithSeed()=%v expected %v\", input, r, want)\n\t}\n}\n\nfunc TestAggregateWithSeedT_PanicWhenFunctionIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"AggregateWithSeed: parameter [f] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func(int,string,string)string'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).AggregateWithSeedT(3, func(x int, r string, i string) string {\n\t\t\tif len(r) > len(i) {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\treturn i\n\t\t})\n\t})\n}\n\nfunc TestAggregateWithSeedBy(t *testing.T) {\n\tinput := []string{\"apple\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\twant := \"PASSIONFRUIT\"\n\n\tr := From(input).AggregateWithSeedBy(\"banana\",\n\t\tfunc(r interface{}, i interface{}) interface{} {\n\t\t\tif len(r.(string)) > len(i.(string)) {\n\t\t\t\treturn r\n\t\t\t}\n\t\t\treturn i\n\t\t},\n\t\tfunc(r interface{}) interface{} {\n\t\t\treturn strings.ToUpper(r.(string))\n\t\t},\n\t)\n\n\tif r != want {\n\t\tt.Errorf(\"From(%v).AggregateWithSeed()=%v expected %v\", input, r, want)\n\t}\n}\n\nfunc TestAggregateWithSeedByT_PanicWhenFunctionIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"AggregateWithSeedByT: parameter [f] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func(int,string,string)string'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).AggregateWithSeedByT(3,\n\t\t\tfunc(x int, r string, i string) string {\n\t\t\t\tif len(r) > len(i) {\n\t\t\t\t\treturn r\n\t\t\t\t}\n\t\t\t\treturn i\n\t\t\t},\n\t\t\tfunc(r string) string {\n\t\t\t\treturn r\n\t\t\t},\n\t\t)\n\t})\n}\n\nfunc TestAggregateWithSeedByT_PanicWhenResultSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"AggregateWithSeedByT: parameter [resultSelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(string,int)string'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).AggregateWithSeedByT(3,\n\t\t\tfunc(x int, r int) int {\n\t\t\t\tif x > r {\n\t\t\t\t\treturn x\n\t\t\t\t}\n\t\t\t\treturn r\n\t\t\t},\n\t\t\tfunc(r string, t int) string {\n\t\t\t\treturn r\n\t\t\t},\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 1.77734375,
          "content": "package linq\n\nimport \"testing\"\n\nconst (\n\tsize = 1000000\n)\n\nfunc BenchmarkSelectWhereFirst(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tRange(1, size).Select(func(i interface{}) interface{} {\n\t\t\treturn -i.(int)\n\t\t}).Where(func(i interface{}) bool {\n\t\t\treturn i.(int) > -1000\n\t\t}).First()\n\t}\n}\n\nfunc BenchmarkSelectWhereFirst_generics(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tRange(1, size).SelectT(func(i int) int {\n\t\t\treturn -i\n\t\t}).WhereT(func(i int) bool {\n\t\t\treturn i > -1000\n\t\t}).First()\n\t}\n}\n\nfunc BenchmarkSum(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tRange(1, size).Where(func(i interface{}) bool {\n\t\t\treturn i.(int)%2 == 0\n\t\t}).SumInts()\n\t}\n}\n\nfunc BenchmarkSum_generics(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tRange(1, size).WhereT(func(i int) bool {\n\t\t\treturn i%2 == 0\n\t\t}).SumInts()\n\t}\n}\n\nfunc BenchmarkZipSkipTake(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tRange(1, size).Zip(Range(1, size).Select(func(i interface{}) interface{} {\n\t\t\treturn i.(int) * 2\n\t\t}), func(i, j interface{}) interface{} {\n\t\t\treturn i.(int) + j.(int)\n\t\t}).Skip(2).Take(5)\n\t}\n}\n\nfunc BenchmarkZipSkipTake_generics(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tRange(1, size).ZipT(Range(1, size).SelectT(func(i int) int {\n\t\t\treturn i * 2\n\t\t}), func(i, j int) int {\n\t\t\treturn i + j\n\t\t}).Skip(2).Take(5)\n\t}\n}\n\nfunc BenchmarkFromChannel(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tch := make(chan interface{})\n\t\tgo func() {\n\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\tch <- i\n\t\t\t}\n\n\t\t\tclose(ch)\n\t\t}()\n\n\t\tFromChannel(ch).All(func(i interface{}) bool { return true })\n\t}\n}\n\nfunc BenchmarkFromChannelT(b *testing.B) {\n\tfor n := 0; n < b.N; n++ {\n\t\tch := make(chan interface{})\n\t\tgo func() {\n\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\tch <- i\n\t\t\t}\n\n\t\t\tclose(ch)\n\t\t}()\n\n\t\tFromChannelT(ch).All(func(i interface{}) bool { return true })\n\t}\n}\n"
        },
        {
          "name": "compare.go",
          "type": "blob",
          "size": 3.1630859375,
          "content": "package linq\n\ntype comparer func(interface{}, interface{}) int\n\n// Comparable is an interface that has to be implemented by a custom collection\n// elements in order to work with linq.\n//\n// Example:\n// \tfunc (f foo) CompareTo(c Comparable) int {\n// \t\ta, b := f.f1, c.(foo).f1\n//\n// \t\tif a < b {\n// \t\t\treturn -1\n// \t\t} else if a > b {\n// \t\t\treturn 1\n// \t\t}\n//\n// \t\treturn 0\n// \t}\ntype Comparable interface {\n\tCompareTo(Comparable) int\n}\n\nfunc getComparer(data interface{}) comparer {\n\tswitch data.(type) {\n\tcase int:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(int), y.(int)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase int8:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(int8), y.(int8)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase int16:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(int16), y.(int16)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase int32:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(int32), y.(int32)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase int64:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(int64), y.(int64)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase uint:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(uint), y.(uint)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase uint8:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(uint8), y.(uint8)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase uint16:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(uint16), y.(uint16)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase uint32:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(uint32), y.(uint32)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase uint64:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(uint64), y.(uint64)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase float32:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(float32), y.(float32)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase float64:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(float64), y.(float64)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase string:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(string), y.(string)\n\t\t\tswitch {\n\t\t\tcase a > b:\n\t\t\t\treturn 1\n\t\t\tcase b > a:\n\t\t\t\treturn -1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\tcase bool:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(bool), y.(bool)\n\t\t\tswitch {\n\t\t\tcase a == b:\n\t\t\t\treturn 0\n\t\t\tcase a:\n\t\t\t\treturn 1\n\t\t\tdefault:\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn func(x, y interface{}) int {\n\t\t\ta, b := x.(Comparable), y.(Comparable)\n\t\t\treturn a.CompareTo(b)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "compare_test.go",
          "type": "blob",
          "size": 1.65234375,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestGetComparer(t *testing.T) {\n\ttests := []struct {\n\t\tx    interface{}\n\t\ty    interface{}\n\t\twant int\n\t}{\n\t\t{100, 500, -1},\n\t\t{-100, -500, 1},\n\t\t{256, 256, 0},\n\t\t{int8(100), int8(-100), 1},\n\t\t{int8(-100), int8(100), -1},\n\t\t{int8(100), int8(100), 0},\n\t\t{int16(100), int16(-100), 1},\n\t\t{int16(-100), int16(100), -1},\n\t\t{int16(100), int16(100), 0},\n\t\t{int32(100), int32(-100), 1},\n\t\t{int32(-100), int32(100), -1},\n\t\t{int32(100), int32(100), 0},\n\t\t{int64(100), int64(-100), 1},\n\t\t{int64(-100), int64(100), -1},\n\t\t{int64(100), int64(100), 0},\n\t\t{uint(100), uint(0), 1},\n\t\t{uint(0), uint(100), -1},\n\t\t{uint(100), uint(100), 0},\n\t\t{uint8(100), uint8(0), 1},\n\t\t{uint8(0), uint8(100), -1},\n\t\t{uint8(100), uint8(100), 0},\n\t\t{uint16(100), uint16(0), 1},\n\t\t{uint16(0), uint16(100), -1},\n\t\t{uint16(100), uint16(100), 0},\n\t\t{uint32(100), uint32(0), 1},\n\t\t{uint32(0), uint32(100), -1},\n\t\t{uint32(100), uint32(100), 0},\n\t\t{uint64(100), uint64(0), 1},\n\t\t{uint64(0), uint64(100), -1},\n\t\t{uint64(100), uint64(100), 0},\n\t\t{float32(5.), float32(1.), 1},\n\t\t{float32(1.), float32(5.), -1},\n\t\t{float32(0), float32(0), 0},\n\t\t{float64(5.), float64(1.), 1},\n\t\t{float64(1.), float64(5.), -1},\n\t\t{float64(0), float64(0), 0},\n\t\t{true, true, 0},\n\t\t{false, false, 0},\n\t\t{true, false, 1},\n\t\t{false, true, -1},\n\t\t{\"foo\", \"foo\", 0},\n\t\t{\"foo\", \"bar\", 1},\n\t\t{\"bar\", \"foo\", -1},\n\t\t{\"FOO\", \"bar\", -1},\n\t\t{foo{f1: 1}, foo{f1: 5}, -1},\n\t\t{foo{f1: 5}, foo{f1: 1}, 1},\n\t\t{foo{f1: 1}, foo{f1: 1}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := getComparer(test.x)(test.x, test.y); r != test.want {\n\t\t\tt.Errorf(\"getComparer(%v)(%v,%v)=%v expected %v\", test.x, test.x, test.y, r, test.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "concat.go",
          "type": "blob",
          "size": 1.341796875,
          "content": "package linq\n\n// Append inserts an item to the end of a collection, so it becomes the last\n// item.\nfunc (q Query) Append(item interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tappended := false\n\n\t\t\treturn func() (interface{}, bool) {\n\t\t\t\ti, ok := next()\n\t\t\t\tif ok {\n\t\t\t\t\treturn i, ok\n\t\t\t\t}\n\n\t\t\t\tif !appended {\n\t\t\t\t\tappended = true\n\t\t\t\t\treturn item, true\n\t\t\t\t}\n\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t},\n\t}\n}\n\n// Concat concatenates two collections.\n//\n// The Concat method differs from the Union method because the Concat method\n// returns all the original elements in the input sequences. The Union method\n// returns only unique elements.\nfunc (q Query) Concat(q2 Query) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tnext2 := q2.Iterate()\n\t\t\tuse1 := true\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif use1 {\n\t\t\t\t\titem, ok = next()\n\t\t\t\t\tif ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tuse1 = false\n\t\t\t\t}\n\n\t\t\t\treturn next2()\n\t\t\t}\n\t\t},\n\t}\n}\n\n// Prepend inserts an item to the beginning of a collection, so it becomes the\n// first item.\nfunc (q Query) Prepend(item interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tprepended := false\n\n\t\t\treturn func() (interface{}, bool) {\n\t\t\t\tif prepended {\n\t\t\t\t\treturn next()\n\t\t\t\t}\n\n\t\t\t\tprepended = true\n\t\t\t\treturn item, true\n\t\t\t}\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "concat_test.go",
          "type": "blob",
          "size": 0.7646484375,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestAppend(t *testing.T) {\n\tinput := []int{1, 2, 3, 4}\n\twant := []interface{}{1, 2, 3, 4, 5}\n\n\tif q := From(input).Append(5); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Append()=%v expected %v\", input, toSlice(q), want)\n\t}\n}\n\nfunc TestConcat(t *testing.T) {\n\tinput1 := []int{1, 2, 3}\n\tinput2 := []int{4, 5}\n\twant := []interface{}{1, 2, 3, 4, 5}\n\n\tif q := From(input1).Concat(From(input2)); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Concat(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n\nfunc TestPrepend(t *testing.T) {\n\tinput := []int{1, 2, 3, 4}\n\twant := []interface{}{0, 1, 2, 3, 4}\n\n\tif q := From(input).Prepend(0); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Prepend()=%v expected %v\", input, toSlice(q), want)\n\t}\n}\n"
        },
        {
          "name": "convert.go",
          "type": "blob",
          "size": 1.310546875,
          "content": "package linq\n\ntype intConverter func(interface{}) int64\n\nfunc getIntConverter(data interface{}) intConverter {\n\tswitch data.(type) {\n\tcase (int):\n\t\treturn func(i interface{}) int64 {\n\t\t\treturn int64(i.(int))\n\t\t}\n\tcase (int8):\n\t\treturn func(i interface{}) int64 {\n\t\t\treturn int64(i.(int8))\n\t\t}\n\tcase (int16):\n\t\treturn func(i interface{}) int64 {\n\t\t\treturn int64(i.(int16))\n\t\t}\n\tcase (int32):\n\t\treturn func(i interface{}) int64 {\n\t\t\treturn int64(i.(int32))\n\t\t}\n\t}\n\n\treturn func(i interface{}) int64 {\n\t\treturn i.(int64)\n\t}\n}\n\ntype uintConverter func(interface{}) uint64\n\nfunc getUIntConverter(data interface{}) uintConverter {\n\tswitch data.(type) {\n\tcase (uint):\n\t\treturn func(i interface{}) uint64 {\n\t\t\treturn uint64(i.(uint))\n\t\t}\n\tcase (uint8):\n\t\treturn func(i interface{}) uint64 {\n\t\t\treturn uint64(i.(uint8))\n\t\t}\n\tcase (uint16):\n\t\treturn func(i interface{}) uint64 {\n\t\t\treturn uint64(i.(uint16))\n\t\t}\n\tcase (uint32):\n\t\treturn func(i interface{}) uint64 {\n\t\t\treturn uint64(i.(uint32))\n\t\t}\n\t}\n\n\treturn func(i interface{}) uint64 {\n\t\treturn i.(uint64)\n\t}\n}\n\ntype floatConverter func(interface{}) float64\n\nfunc getFloatConverter(data interface{}) floatConverter {\n\tswitch data.(type) {\n\tcase (float32):\n\t\treturn func(i interface{}) float64 {\n\t\t\treturn float64(i.(float32))\n\t\t}\n\t}\n\n\treturn func(i interface{}) float64 {\n\t\treturn i.(float64)\n\t}\n}\n"
        },
        {
          "name": "convert_test.go",
          "type": "blob",
          "size": 1.03515625,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestIntConverter(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  int64\n\t}{\n\t\t{2, 2},\n\t\t{int8(-1), -1},\n\t\t{int16(0), 0},\n\t\t{int32(10), 10},\n\t\t{int64(5), 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tif conv := getIntConverter(test.input); conv(test.input) != test.want {\n\t\t\tt.Errorf(\"IntConverter for %v failed\", test.input)\n\t\t}\n\t}\n}\n\nfunc TestUIntConverter(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  uint64\n\t}{\n\t\t{uint(2), 2},\n\t\t{uint8(1), 1},\n\t\t{uint16(0), 0},\n\t\t{uint32(10), 10},\n\t\t{uint64(5), 5},\n\t}\n\n\tfor _, test := range tests {\n\t\tif conv := getUIntConverter(test.input); conv(test.input) != test.want {\n\t\t\tt.Errorf(\"UIntConverter for %v failed\", test.input)\n\t\t}\n\t}\n}\n\nfunc TestFloatConverter(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  float64\n\t}{\n\t\t{float32(-1), -1},\n\t\t{float64(0), 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif conv := getFloatConverter(test.input); conv(test.input) != test.want {\n\t\t\tt.Errorf(\"FloatConverter for %v failed\", test.input)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "defaultifempty.go",
          "type": "blob",
          "size": 0.58984375,
          "content": "package linq\n\n// DefaultIfEmpty returns the elements of the specified sequence\n// if the sequence is empty.\nfunc (q Query) DefaultIfEmpty(defaultValue interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tstate := 1\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tswitch state {\n\t\t\t\tcase 1:\n\t\t\t\t\titem, ok = next()\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tstate = 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem = defaultValue\n\t\t\t\t\t\tok = true\n\t\t\t\t\t\tstate = -1\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\tcase 2:\n\t\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "defaultifempty_test.go",
          "type": "blob",
          "size": 0.5078125,
          "content": "package linq\n\nimport (\n\t\"testing\"\n)\n\nfunc TestDefaultIfEmpty(t *testing.T) {\n\tdefaultValue := 0\n\ttests := []struct {\n\t\tinput []interface{}\n\t\twant  []interface{}\n\t}{\n\t\t{[]interface{}{}, []interface{}{defaultValue}},\n\t\t{[]interface{}{1, 2, 3, 4, 5}, []interface{}{1, 2, 3, 4, 5}},\n\t}\n\n\tfor _, test := range tests {\n\t\tq := From(test.input).DefaultIfEmpty(defaultValue)\n\n\t\tif !validateQuery(q, test.want) {\n\t\t\tt.Errorf(\"From(%v).DefaultIfEmpty(%v)=%v expected %v\", test.input, defaultValue, toSlice(q), test.want)\n\t\t}\n\t}\n\n}\n"
        },
        {
          "name": "distinct.go",
          "type": "blob",
          "size": 2.4072265625,
          "content": "package linq\n\n// Distinct method returns distinct elements from a collection. The result is an\n// unordered collection that contains no duplicate values.\nfunc (q Query) Distinct() Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tset := make(map[interface{}]bool)\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\tif _, has := set[item]; !has {\n\t\t\t\t\t\tset[item] = true\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// Distinct method returns distinct elements from a collection. The result is an\n// ordered collection that contains no duplicate values.\n//\n// NOTE: Distinct method on OrderedQuery type has better performance than\n// Distinct method on Query type.\nfunc (oq OrderedQuery) Distinct() OrderedQuery {\n\treturn OrderedQuery{\n\t\torders: oq.orders,\n\t\tQuery: Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\tnext := oq.Iterate()\n\t\t\t\tvar prev interface{}\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\t\tif item != prev {\n\t\t\t\t\t\t\tprev = item\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\n// DistinctBy method returns distinct elements from a collection. This method\n// executes selector function for each element to determine a value to compare.\n// The result is an unordered collection that contains no duplicate values.\nfunc (q Query) DistinctBy(selector func(interface{}) interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tset := make(map[interface{}]bool)\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\ts := selector(item)\n\t\t\t\t\tif _, has := set[s]; !has {\n\t\t\t\t\t\tset[s] = true\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// DistinctByT is the typed version of DistinctBy.\n//\n//   - selectorFn is of type \"func(TSource) TSource\".\n//\n// NOTE: DistinctBy has better performance than DistinctByT.\nfunc (q Query) DistinctByT(selectorFn interface{}) Query {\n\tselectorFunc, ok := selectorFn.(func(interface{}) interface{})\n\tif !ok {\n\t\tselectorGenericFunc, err := newGenericFunc(\n\t\t\t\"DistinctByT\", \"selectorFn\", selectorFn,\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t\t)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tselectorFunc = func(item interface{}) interface{} {\n\t\t\treturn selectorGenericFunc.Call(item)\n\t\t}\n\t}\n\treturn q.DistinctBy(selectorFunc)\n}\n"
        },
        {
          "name": "distinct_test.go",
          "type": "blob",
          "size": 1.7412109375,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestDistinct(t *testing.T) {\n\ttests := []struct {\n\t\tinput  interface{}\n\t\toutput []interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, []interface{}{1, 2, 3}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, []interface{}{1, 2, 3, 4}},\n\t\t{\"sstr\", []interface{}{'s', 't', 'r'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).Distinct(); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).Distinct()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestDistinctForOrderedQuery(t *testing.T) {\n\ttests := []struct {\n\t\tinput  interface{}\n\t\toutput []interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, []interface{}{1, 2, 3}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, []interface{}{1, 2, 3, 4}},\n\t\t{\"sstr\", []interface{}{'r', 's', 't'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).OrderBy(func(i interface{}) interface{} {\n\t\t\treturn i\n\t\t}).Distinct(); !validateQuery(q.Query, test.output) {\n\t\t\tt.Errorf(\"From(%v).Distinct()=%v expected %v\", test.input, toSlice(q.Query), test.output)\n\t\t}\n\t}\n}\n\nfunc TestDistinctBy(t *testing.T) {\n\ttype user struct {\n\t\tid   int\n\t\tname string\n\t}\n\n\tusers := []user{{1, \"Foo\"}, {2, \"Bar\"}, {3, \"Foo\"}}\n\twant := []interface{}{user{1, \"Foo\"}, user{2, \"Bar\"}}\n\n\tif q := From(users).DistinctBy(func(u interface{}) interface{} {\n\t\treturn u.(user).name\n\t}); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).DistinctBy()=%v expected %v\", users, toSlice(q), want)\n\t}\n}\n\nfunc TestDistinctByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"DistinctByT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(string,string)bool'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).DistinctByT(func(indice, item string) bool { return item == \"2\" })\n\t})\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2236328125,
          "content": "// Package linq provides methods for querying and manipulating slices, arrays,\n// maps, strings, channels and collections.\n//\n// Authors: Alexander Kalankhodzhaev (kalan), Ahmet Alp Balkan, Cleiton Marques\n// Souza.\npackage linq\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 60.3974609375,
          "content": "package linq\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc ExampleKeyValue() {\n\tm := make(map[int]bool)\n\tm[10] = true\n\n\tfmt.Println(From(m).Results())\n\t// Output:\n\t// [{10 true}]\n}\n\nfunc ExampleKeyValue_second() {\n\tinput := []KeyValue{\n\t\t{10, true},\n\t}\n\n\tm := make(map[int]bool)\n\tFrom(input).\n\t\tToMap(&m)\n\n\tfmt.Println(m)\n\t// Output:\n\t// map[10:true]\n}\n\n// The following code example demonstrates how\n// to use Range to generate a slice of values.\nfunc ExampleRange() {\n\t// Generate a slice of integers from 1 to 10\n\t// and then select their squares.\n\tvar squares []int\n\tRange(1, 10).\n\t\tSelectT(\n\t\t\tfunc(x int) int { return x * x },\n\t\t).\n\t\tToSlice(&squares)\n\n\tfor _, num := range squares {\n\t\tfmt.Println(num)\n\t}\n\t//Output:\n\t//1\n\t//4\n\t//9\n\t//16\n\t//25\n\t//36\n\t//49\n\t//64\n\t//81\n\t//100\n}\n\n// The following code example demonstrates how to use Repeat\n// to generate a slice of a repeated value.\nfunc ExampleRepeat() {\n\tvar slice []string\n\tRepeat(\"I like programming.\", 5).\n\t\tToSlice(&slice)\n\n\tfor _, str := range slice {\n\t\tfmt.Println(str)\n\t}\n\t//Output:\n\t//I like programming.\n\t//I like programming.\n\t//I like programming.\n\t//I like programming.\n\t//I like programming.\n\n}\n\nfunc ExampleQuery() {\n\tquery := From([]int{1, 2, 3, 4, 5}).Where(func(i interface{}) bool {\n\t\treturn i.(int) <= 3\n\t})\n\n\tnext := query.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tfmt.Println(item)\n\t}\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n}\n\n// The following code example demonstrates how to use Aggregate function\nfunc ExampleQuery_Aggregate() {\n\tfruits := []string{\"apple\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\t// Determine which string in the slice is the longest.\n\tlongestName := From(fruits).\n\t\tAggregate(\n\t\t\tfunc(r interface{}, i interface{}) interface{} {\n\t\t\t\tif len(r.(string)) > len(i.(string)) {\n\t\t\t\t\treturn r\n\t\t\t\t}\n\t\t\t\treturn i\n\t\t\t},\n\t\t)\n\n\tfmt.Println(longestName)\n\t// Output:\n\t// passionfruit\n}\n\n// The following code example demonstrates how to use AggregateWithSeed function\nfunc ExampleQuery_AggregateWithSeed() {\n\tints := []int{4, 8, 8, 3, 9, 0, 7, 8, 2}\n\n\t// Count the even numbers in the array, using a seed value of 0.\n\tnumEven := From(ints).\n\t\tAggregateWithSeed(0,\n\t\t\tfunc(total, next interface{}) interface{} {\n\t\t\t\tif next.(int)%2 == 0 {\n\t\t\t\t\treturn total.(int) + 1\n\t\t\t\t}\n\t\t\t\treturn total\n\t\t\t},\n\t\t)\n\n\tfmt.Printf(\"The number of even integers is: %d\", numEven)\n\t// Output:\n\t// The number of even integers is: 6\n}\n\n// The following code example demonstrates how to use AggregateWithSeedBy function\nfunc ExampleQuery_AggregateWithSeedBy() {\n\tinput := []string{\"apple\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\t// Determine whether any string in the array is longer than \"banana\".\n\tlongestName := From(input).\n\t\tAggregateWithSeedBy(\"banana\",\n\t\t\tfunc(longest interface{}, next interface{}) interface{} {\n\t\t\t\tif len(longest.(string)) > len(next.(string)) {\n\t\t\t\t\treturn longest\n\t\t\t\t}\n\t\t\t\treturn next\n\n\t\t\t},\n\t\t\t// Return the final result\n\t\t\tfunc(result interface{}) interface{} {\n\t\t\t\treturn fmt.Sprintf(\"The fruit with the longest name is %s.\", result)\n\t\t\t},\n\t\t)\n\n\tfmt.Println(longestName)\n\t// Output:\n\t// The fruit with the longest name is passionfruit.\n}\n\n// The following code example demonstrates how to\n// use Distinct to return distinct elements from a slice of integers.\nfunc ExampleOrderedQuery_Distinct() {\n\tages := []int{21, 46, 46, 55, 17, 21, 55, 55}\n\n\tvar distinctAges []int\n\tFrom(ages).\n\t\tOrderBy(\n\t\t\tfunc(item interface{}) interface{} { return item },\n\t\t).\n\t\tDistinct().\n\t\tToSlice(&distinctAges)\n\n\tfmt.Println(distinctAges)\n\t// Output:\n\t// [17 21 46 55]\n}\n\n// The following code example demonstrates how to\n// use DistinctBy to return distinct elements from a ordered slice of elements.\nfunc ExampleOrderedQuery_DistinctBy() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tproducts := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\t//Order and exclude duplicates.\n\tvar noduplicates []Product\n\tFrom(products).\n\t\tOrderBy(\n\t\t\tfunc(item interface{}) interface{} { return item.(Product).Name },\n\t\t).\n\t\tDistinctBy(\n\t\t\tfunc(item interface{}) interface{} { return item.(Product).Code },\n\t\t).\n\t\tToSlice(&noduplicates)\n\n\tfor _, product := range noduplicates {\n\t\tfmt.Printf(\"%s %d\\n\", product.Name, product.Code)\n\t}\n\t// Output:\n\t// apple 9\n\t// lemon 12\n\t// orange 4\n}\n\n// The following code example demonstrates how to use ThenBy to perform\n// a secondary ordering of the elements in a slice.\nfunc ExampleOrderedQuery_ThenBy() {\n\tfruits := []string{\"grape\", \"passionfruit\", \"banana\", \"mango\", \"orange\", \"raspberry\", \"apple\", \"blueberry\"}\n\n\t// Sort the strings first by their length and then\n\t//alphabetically by passing the identity selector function.\n\tvar query []string\n\tFrom(fruits).\n\t\tOrderBy(\n\t\t\tfunc(fruit interface{}) interface{} { return len(fruit.(string)) },\n\t\t).\n\t\tThenBy(\n\t\t\tfunc(fruit interface{}) interface{} { return fruit },\n\t\t).\n\t\tToSlice(&query)\n\n\tfor _, fruit := range query {\n\t\tfmt.Println(fruit)\n\t}\n\t// Output:\n\t// apple\n\t// grape\n\t// mango\n\t// banana\n\t// orange\n\t// blueberry\n\t// raspberry\n\t// passionfruit\n}\n\n// The following code example demonstrates how to use All to determine\n// whether all the elements in a slice satisfy a condition.\n// Variable allStartWithB is true if all the pet names start with \"B\"\n// or if the pets array is empty.\nfunc ExampleQuery_All() {\n\n\ttype Pet struct {\n\t\tName string\n\t\tAge  int\n\t}\n\n\tpets := []Pet{\n\t\t{Name: \"Barley\", Age: 10},\n\t\t{Name: \"Boots\", Age: 4},\n\t\t{Name: \"Whiskers\", Age: 6},\n\t}\n\n\t// Determine whether all pet names\n\t// in the array start with 'B'.\n\tallStartWithB := From(pets).\n\t\tAll(\n\t\t\tfunc(pet interface{}) bool { return strings.HasPrefix(pet.(Pet).Name, \"B\") },\n\t\t)\n\n\tfmt.Printf(\"All pet names start with 'B'? %t\", allStartWithB)\n\t// Output:\n\t//\n\t//  All pet names start with 'B'? false\n}\n\n// The following code example demonstrates how to use Any to determine\n// whether a slice contains any elements.\nfunc ExampleQuery_Any() {\n\n\tnumbers := []int{1, 2}\n\thasElements := From(numbers).Any()\n\n\tfmt.Printf(\"Are there any element in the list? %t\", hasElements)\n\t// Output:\n\t// Are there any element in the list? true\n}\n\n// The following code example demonstrates how to use AnyWith\n// to determine whether any element in a slice satisfies a condition.\nfunc ExampleQuery_AnyWith() {\n\n\ttype Pet struct {\n\t\tName       string\n\t\tAge        int\n\t\tVaccinated bool\n\t}\n\n\tpets := []Pet{\n\t\t{Name: \"Barley\", Age: 8, Vaccinated: true},\n\t\t{Name: \"Boots\", Age: 4, Vaccinated: false},\n\t\t{Name: \"Whiskers\", Age: 1, Vaccinated: false},\n\t}\n\n\t// Determine whether any pets over age 1 are also unvaccinated.\n\tunvaccinated := From(pets).\n\t\tAnyWith(\n\t\t\tfunc(p interface{}) bool {\n\t\t\t\treturn p.(Pet).Age > 1 && p.(Pet).Vaccinated == false\n\t\t\t},\n\t\t)\n\n\tfmt.Printf(\"Are there any unvaccinated animals over age one? %t\", unvaccinated)\n\t// Output:\n\t//\n\t// Are there any unvaccinated animals over age one? true\n}\n\n// The following code example demonstrates how to use Append\n// to include an elements in the last position of a slice.\nfunc ExampleQuery_Append() {\n\tinput := []int{1, 2, 3, 4}\n\n\tq := From(input).Append(5)\n\n\tlast := q.Last()\n\n\tfmt.Println(last)\n\t// Output:\n\t// 5\n}\n\n//The following code example demonstrates how to use Average\n//to calculate the average of a slice of values.\nfunc ExampleQuery_Average() {\n\tgrades := []int{78, 92, 100, 37, 81}\n\taverage := From(grades).Average()\n\n\tfmt.Println(average)\n\t// Output:\n\t// 77.6\n}\n\n// The following code example demonstrates how to use Count\n// to count the elements in an array.\nfunc ExampleQuery_Count() {\n\tfruits := []string{\"apple\", \"banana\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\tnumberOfFruits := From(fruits).Count()\n\n\tfmt.Println(numberOfFruits)\n\t// Output:\n\t// 6\n}\n\n// The following code example demonstrates how to use Contains\n// to determine whether a slice contains a specific element.\nfunc ExampleQuery_Contains() {\n\tslice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n\thas5 := From(slice).Contains(5)\n\n\tfmt.Printf(\"Does the slice contains 5? %t\", has5)\n\t// Output:\n\t// Does the slice contains 5? true\n}\n\n//The following code example demonstrates how to use CountWith\n//to count the even numbers in an array.\nfunc ExampleQuery_CountWith() {\n\tslice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\n\tevenCount := From(slice).\n\t\tCountWith(\n\t\t\tfunc(item interface{}) bool { return item.(int)%2 == 0 },\n\t\t)\n\n\tfmt.Println(evenCount)\n\t// Output:\n\t// 6\n}\n\n// The following example demonstrates how to use the DefaultIfEmpty\n// method on the results of a group join to perform a left outer join.\n//\n// The first step in producing a left outer join of two collections is to perform\n// an inner join by using a group join. In this example, the list of Person objects\n// is inner-joined to the list of Pet objects based on a Person object that matches Pet.Owner.\n//\n// The second step is to include each element of the first (left) collection in the\n// result set even if that element has no matches in the right collection.\n// This is accomplished by calling DefaultIfEmpty on each sequence of matching\n// elements from the group join.\n// In this example, DefaultIfEmpty is called on each sequence of matching Pet elements.\n// The method returns a collection that contains a single, default value if the sequence\n// of matching Pet elements is empty for any Person element, thereby ensuring that each\n// Person element is represented in the result collection.\nfunc ExampleQuery_DefaultIfEmpty() {\n\ttype Person struct {\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\n\ttype Pet struct {\n\t\tName  string\n\t\tOwner Person\n\t}\n\n\tmagnus := Person{FirstName: \"Magnus\", LastName: \"Hedlund\"}\n\tterry := Person{FirstName: \"Terry\", LastName: \"Adams\"}\n\tcharlotte := Person{FirstName: \"Charlotte\", LastName: \"Weiss\"}\n\tarlene := Person{FirstName: \"Arlene\", LastName: \"Huff\"}\n\n\tbarley := Pet{Name: \"Barley\", Owner: terry}\n\tboots := Pet{Name: \"Boots\", Owner: terry}\n\twhiskers := Pet{Name: \"Whiskers\", Owner: charlotte}\n\tbluemoon := Pet{Name: \"Blue Moon\", Owner: terry}\n\tdaisy := Pet{Name: \"Daisy\", Owner: magnus}\n\n\t// Create two lists.\n\tpeople := []Person{magnus, terry, charlotte, arlene}\n\tpets := []Pet{barley, boots, whiskers, bluemoon, daisy}\n\n\tresults := []string{}\n\tFrom(people).\n\t\tGroupJoinT(\n\t\t\tFrom(pets),\n\t\t\tfunc(person Person) Person { return person },\n\t\t\tfunc(pet Pet) Person { return pet.Owner },\n\t\t\tfunc(person Person, pets []Pet) Group { return Group{Key: person, Group: From(pets).Results()} },\n\t\t).\n\t\tSelectManyByT(\n\t\t\tfunc(g Group) Query { return From(g.Group).DefaultIfEmpty(Pet{}) },\n\t\t\tfunc(pet Pet, group Group) string {\n\t\t\t\treturn fmt.Sprintf(\"%s: %s\", group.Key.(Person).FirstName, pet.Name)\n\t\t\t},\n\t\t).\n\t\tToSlice(&results)\n\n\tfor _, s := range results {\n\t\tfmt.Println(s)\n\t}\n\t// Output:\n\t// Magnus: Daisy\n\t// Terry: Barley\n\t// Terry: Boots\n\t// Terry: Blue Moon\n\t// Charlotte: Whiskers\n\t// Arlene:\n\n}\n\n//The following code example demonstrates how to use Distinct\n//to return distinct elements from a slice of integers.\nfunc ExampleQuery_Distinct() {\n\tages := []int{21, 46, 46, 55, 17, 21, 55, 55}\n\n\tvar distinctAges []int\n\tFrom(ages).\n\t\tDistinct().\n\t\tToSlice(&distinctAges)\n\n\tfmt.Println(distinctAges)\n\t// Output:\n\t// [21 46 55 17]\n}\n\n// The following code example demonstrates how to\n// use DistinctBy to return distinct elements from a ordered slice of elements.\nfunc ExampleQuery_DistinctBy() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tproducts := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\t//Order and exclude duplicates.\n\tvar noduplicates []Product\n\tFrom(products).\n\t\tDistinctBy(\n\t\t\tfunc(item interface{}) interface{} { return item.(Product).Code },\n\t\t).\n\t\tToSlice(&noduplicates)\n\n\tfor _, product := range noduplicates {\n\t\tfmt.Printf(\"%s %d\\n\", product.Name, product.Code)\n\t}\n\t// Output:\n\t// orange 4\n\t// apple 9\n\t// lemon 12\n\n}\n\n// The following code example demonstrates how to use the Except\n// method to compare two slices of numbers and return elements\n// that appear only in the first slice.\nfunc ExampleQuery_Except() {\n\tnumbers1 := []float32{2.0, 2.1, 2.2, 2.3, 2.4, 2.5}\n\tnumbers2 := []float32{2.2}\n\n\tvar onlyInFirstSet []float32\n\tFrom(numbers1).\n\t\tExcept(From(numbers2)).\n\t\tToSlice(&onlyInFirstSet)\n\n\tfor _, number := range onlyInFirstSet {\n\t\tfmt.Println(number)\n\t}\n\t// Output:\n\t//2\n\t//2.1\n\t//2.3\n\t//2.4\n\t//2.5\n\n}\n\n// The following code example demonstrates how to use the Except\n// method to compare two slices of numbers and return elements\n// that appear only in the first slice.\nfunc ExampleQuery_ExceptBy() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tfruits1 := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tfruits2 := []Product{\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\t//Order and exclude duplicates.\n\tvar except []Product\n\tFrom(fruits1).\n\t\tExceptBy(From(fruits2),\n\t\t\tfunc(item interface{}) interface{} { return item.(Product).Code },\n\t\t).\n\t\tToSlice(&except)\n\n\tfor _, product := range except {\n\t\tfmt.Printf(\"%s %d\\n\", product.Name, product.Code)\n\t}\n\t// Output:\n\t// orange 4\n\t// lemon 12\n\n}\n\n// The following code example demonstrates how to use First\n// to return the first element of an array.\nfunc ExampleQuery_First() {\n\tnumbers := []int{9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 435, 67, 12, 19}\n\n\tfirst := From(numbers).First()\n\n\tfmt.Println(first)\n\t// Output:\n\t// 9\n\n}\n\n//The following code example demonstrates how to use FirstWith\n// to return the first element of an array that satisfies a condition.\nfunc ExampleQuery_FirstWith() {\n\tnumbers := []int{9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 435, 67, 12, 19}\n\n\tfirst := From(numbers).\n\t\tFirstWith(\n\t\t\tfunc(item interface{}) bool { return item.(int) > 80 },\n\t\t)\n\n\tfmt.Println(first)\n\t// Output:\n\t// 92\n\n}\n\n//The following code example demonstrates how to use Intersect\n//to return the elements that appear in each of two slices of integers.\nfunc ExampleQuery_Intersect() {\n\tid1 := []int{44, 26, 92, 30, 71, 38}\n\tid2 := []int{39, 59, 83, 47, 26, 4, 30}\n\n\tvar both []int\n\tFrom(id1).\n\t\tIntersect(From(id2)).\n\t\tToSlice(&both)\n\n\tfor _, id := range both {\n\t\tfmt.Println(id)\n\t}\n\t// Output:\n\t// 26\n\t// 30\n\n}\n\n//The following code example demonstrates how to use IntersectBy\n//to return the elements that appear in each of two slices of products with same Code.\nfunc ExampleQuery_IntersectBy() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tstore1 := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tstore2 := []Product{\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tvar duplicates []Product\n\tFrom(store1).\n\t\tIntersectBy(From(store2),\n\t\t\tfunc(p interface{}) interface{} { return p.(Product).Code },\n\t\t).\n\t\tToSlice(&duplicates)\n\n\tfor _, p := range duplicates {\n\t\tfmt.Println(p.Name, \"\", p.Code)\n\t}\n\t// Output:\n\t// apple  9\n\n}\n\n// The following code example demonstrates how to use Last\n// to return the last element of an array.\nfunc ExampleQuery_Last() {\n\tnumbers := []int{9, 34, 65, 92, 87, 435, 3, 54,\n\t\t83, 23, 87, 67, 12, 19}\n\n\tlast := From(numbers).Last()\n\n\tfmt.Println(last)\n\n\t//Output:\n\t//19\n\n}\n\n// The following code example demonstrates how to use LastWith\n// to return the last element of an array.\nfunc ExampleQuery_LastWith() {\n\tnumbers := []int{9, 34, 65, 92, 87, 435, 3, 54,\n\t\t83, 23, 87, 67, 12, 19}\n\n\tlast := From(numbers).\n\t\tLastWith(\n\t\t\tfunc(n interface{}) bool { return n.(int) > 80 },\n\t\t)\n\n\tfmt.Println(last)\n\n\t//Output:\n\t//87\n\n}\n\n// The following code example demonstrates how to use Max\n// to determine the maximum value in a slice.\nfunc ExampleQuery_Max() {\n\tnumbers := []int64{4294967296, 466855135, 81125}\n\n\tlast := From(numbers).Max()\n\n\tfmt.Println(last)\n\n\t//Output:\n\t//4294967296\n\n}\n\n// The following code example demonstrates how to use Min\n// to determine the minimum value in a slice.\nfunc ExampleQuery_Min() {\n\tgrades := []int{78, 92, 99, 37, 81}\n\n\tmin := From(grades).Min()\n\n\tfmt.Println(min)\n\n\t//Output:\n\t//37\n\n}\n\n// The following code example demonstrates how to use OrderByDescending\n// to sort the elements of a slice in descending order by using a selector function\nfunc ExampleQuery_OrderByDescending() {\n\tnames := []string{\"Ned\", \"Ben\", \"Susan\"}\n\n\tvar result []string\n\tFrom(names).\n\t\tOrderByDescending(\n\t\t\tfunc(n interface{}) interface{} { return n },\n\t\t).ToSlice(&result)\n\n\tfmt.Println(result)\n\t// Output:\n\t// [Susan Ned Ben]\n}\n\n// The following code example demonstrates how to use ThenByDescending to perform\n// a secondary ordering of the elements in a slice in descending order.\nfunc ExampleOrderedQuery_ThenByDescending() {\n\tfruits := []string{\"apPLe\", \"baNanA\", \"apple\", \"APple\", \"orange\", \"BAnana\", \"ORANGE\", \"apPLE\"}\n\n\t// Sort the strings first ascending by their length and\n\t// then descending using a custom case insensitive comparer.\n\tvar query []string\n\tFrom(fruits).\n\t\tOrderBy(\n\t\t\tfunc(fruit interface{}) interface{} { return len(fruit.(string)) },\n\t\t).\n\t\tThenByDescending(\n\t\t\tfunc(fruit interface{}) interface{} { return fruit.(string)[0] },\n\t\t).\n\t\tToSlice(&query)\n\n\tfor _, fruit := range query {\n\t\tfmt.Println(fruit)\n\t}\n\t// Output:\n\t// apPLe\n\t// apPLE\n\t// apple\n\t// APple\n\t// orange\n\t// baNanA\n\t// ORANGE\n\t// BAnana\n\n}\n\n// The following code example demonstrates how to use Concat\n// to concatenate two slices.\nfunc ExampleQuery_Concat() {\n\tq := From([]int{1, 2, 3}).\n\t\tConcat(From([]int{4, 5, 6}))\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [1 2 3 4 5 6]\n}\n\nfunc ExampleQuery_GroupBy() {\n\tinput := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\tq := From(input).GroupBy(\n\t\tfunc(i interface{}) interface{} { return i.(int) % 2 },\n\t\tfunc(i interface{}) interface{} { return i.(int) })\n\n\tfmt.Println(q.OrderBy(func(i interface{}) interface{} {\n\t\treturn i.(Group).Key\n\t}).Results())\n\t// Output:\n\t// [{0 [2 4 6 8]} {1 [1 3 5 7 9]}]\n}\n\n// The following code example demonstrates how to use GroupJoin\n// to perform a grouped join on two slices\nfunc ExampleQuery_GroupJoin() {\n\tfruits := []string{\n\t\t\"apple\",\n\t\t\"banana\",\n\t\t\"apricot\",\n\t\t\"cherry\",\n\t\t\"clementine\",\n\t}\n\n\tq := FromString(\"abc\").\n\t\tGroupJoin(From(fruits),\n\t\t\tfunc(i interface{}) interface{} { return i },\n\t\t\tfunc(i interface{}) interface{} { return []rune(i.(string))[0] },\n\t\t\tfunc(outer interface{}, inners []interface{}) interface{} {\n\t\t\t\treturn KeyValue{string(outer.(rune)), inners}\n\t\t\t},\n\t\t)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [{a [apple apricot]} {b [banana]} {c [cherry clementine]}]\n}\n\n// The following code example demonstrates how to use IndexOf\n// to retrieve the position of an item in the array and then\n// update that item.\nfunc ExampleQuery_IndexOf() {\n\ttype Item struct {\n\t\tID   uint64\n\t\tName string\n\t}\n\titems := []Item{\n\t\t{\n\t\t\tID:   1,\n\t\t\tName: \"Joe\",\n\t\t},\n\t\t{\n\t\t\tID:   2,\n\t\t\tName: \"Bob\",\n\t\t},\n\t\t{\n\t\t\tID:   3,\n\t\t\tName: \"Rickster\",\n\t\t},\n\t\t{\n\t\t\tID:   4,\n\t\t\tName: \"Jim\",\n\t\t},\n\t}\n\n\tindex := From(items).IndexOf(func(i interface{}) bool {\n\t\titem, ok := i.(Item)\n\t\treturn ok && item.Name == \"Rickster\"\n\t})\n\n\tif index >= 0 {\n\t\t// We found the item in the array. Change the name using the index.\n\t\titems[index].Name = \"Joshua\"\n\t\tfmt.Println(\"Item found at:\", index, \"new name:\", items[index].Name)\n\t}\n\t// Output:\n\t// Item found at: 2 new name: Joshua\n}\n\n// The following code example demonstrates how to use Join\n// to perform an inner join of two slices based on a common key.\nfunc ExampleQuery_Join() {\n\tfruits := []string{\n\t\t\"apple\",\n\t\t\"banana\",\n\t\t\"apricot\",\n\t\t\"cherry\",\n\t\t\"clementine\",\n\t}\n\n\tq := Range(1, 10).\n\t\tJoin(From(fruits),\n\t\t\tfunc(i interface{}) interface{} { return i },\n\t\t\tfunc(i interface{}) interface{} { return len(i.(string)) },\n\t\t\tfunc(outer interface{}, inner interface{}) interface{} {\n\t\t\t\treturn KeyValue{outer, inner}\n\t\t\t},\n\t\t)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [{5 apple} {6 banana} {6 cherry} {7 apricot} {10 clementine}]\n}\n\n// The following code example demonstrates how to use OrderBy\n// to sort the elements of a slice.\nfunc ExampleQuery_OrderBy() {\n\tq := Range(1, 10).\n\t\tOrderBy(\n\t\t\tfunc(i interface{}) interface{} { return i.(int) % 2 },\n\t\t).\n\t\tThenByDescending(\n\t\t\tfunc(i interface{}) interface{} { return i },\n\t\t)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [10 8 6 4 2 9 7 5 3 1]\n}\n\n// The following code example demonstrates how to use Prepend\n// to include an elements in the first position of a slice.\nfunc ExampleQuery_Prepend() {\n\tinput := []int{2, 3, 4, 5}\n\n\tq := From(input).Prepend(1)\n\tfirst := q.First()\n\n\tfmt.Println(first)\n\t// Output:\n\t// 1\n}\n\n// The following code example demonstrates how to use Reverse\n// to reverse the order of elements in a string.\nfunc ExampleQuery_Reverse() {\n\tinput := \"apple\"\n\n\tvar output []rune\n\tFrom(input).\n\t\tReverse().\n\t\tToSlice(&output)\n\n\tfmt.Println(string(output))\n\t// Output:\n\t// elppa\n}\n\n// The following code example demonstrates how to use Select\n// to project over a slice of values.\nfunc ExampleQuery_Select() {\n\tsquares := []int{}\n\n\tRange(1, 10).\n\t\tSelect(\n\t\t\tfunc(x interface{}) interface{} { return x.(int) * x.(int) },\n\t\t).\n\t\tToSlice(&squares)\n\n\tfmt.Println(squares)\n\t// Output:\n\t// [1 4 9 16 25 36 49 64 81 100]\n}\n\nfunc ExampleQuery_SelectMany() {\n\tinput := [][]int{{1, 2, 3}, {4, 5, 6, 7}}\n\n\tq := From(input).\n\t\tSelectMany(\n\t\t\tfunc(i interface{}) Query { return From(i) },\n\t\t)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [1 2 3 4 5 6 7]\n}\n\n// The following code example demonstrates how to use Select\n// to project over a slice of values and use the index of each element.\nfunc ExampleQuery_SelectIndexed() {\n\tfruits := []string{\"apple\", \"banana\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\tresult := []string{}\n\tFrom(fruits).\n\t\tSelectIndexed(\n\t\t\tfunc(index int, fruit interface{}) interface{} { return fruit.(string)[:index] },\n\t\t).\n\t\tToSlice(&result)\n\n\tfmt.Println(result)\n\t// Output:\n\t// [ b ma ora pass grape]\n\n}\n\n// The following code example demonstrates how to use SelectManyByIndexed\n// to perform a one-to-many projection over an array and use the index of each outer element.\nfunc ExampleQuery_SelectManyByIndexed() {\n\ttype Pet struct {\n\t\tName string\n\t}\n\n\ttype Person struct {\n\t\tName string\n\t\tPets []Pet\n\t}\n\n\tmagnus := Person{\n\t\tName: \"Hedlund, Magnus\",\n\t\tPets: []Pet{{Name: \"Daisy\"}},\n\t}\n\n\tterry := Person{\n\t\tName: \"Adams, Terry\",\n\t\tPets: []Pet{{Name: \"Barley\"}, {Name: \"Boots\"}},\n\t}\n\tcharlotte := Person{\n\t\tName: \"Weiss, Charlotte\",\n\t\tPets: []Pet{{Name: \"Whiskers\"}},\n\t}\n\n\tpeople := []Person{magnus, terry, charlotte}\n\tvar results []string\n\n\tFrom(people).\n\t\tSelectManyByIndexed(\n\t\t\tfunc(index int, person interface{}) Query {\n\t\t\t\treturn From(person.(Person).Pets).\n\t\t\t\t\tSelect(func(pet interface{}) interface{} {\n\t\t\t\t\t\treturn fmt.Sprintf(\"%d - %s\", index, pet.(Pet).Name)\n\t\t\t\t\t})\n\t\t\t},\n\t\t\tfunc(indexedPet, person interface{}) interface{} {\n\t\t\t\treturn fmt.Sprintf(\"Pet: %s, Owner: %s\", indexedPet, person.(Person).Name)\n\t\t\t},\n\t\t).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// Pet: 0 - Daisy, Owner: Hedlund, Magnus\n\t// Pet: 1 - Barley, Owner: Adams, Terry\n\t// Pet: 1 - Boots, Owner: Adams, Terry\n\t// Pet: 2 - Whiskers, Owner: Weiss, Charlotte\n\n}\n\n// The following code example demonstrates how to use SelectManyIndexed\n// to perform a one-to-many projection over an slice of log data and print out their contents.\nfunc ExampleQuery_SelectManyIndexed() {\n\ttype LogFile struct {\n\t\tName  string\n\t\tLines []string\n\t}\n\n\tfile1 := LogFile{\n\t\tName: \"file1.log\",\n\t\tLines: []string{\n\t\t\t\"INFO: 2013/11/05 18:11:01 main.go:44: Special Information\",\n\t\t\t\"WARNING: 2013/11/05 18:11:01 main.go:45: There is something you need to know about\",\n\t\t\t\"ERROR: 2013/11/05 18:11:01 main.go:46: Something has failed\",\n\t\t},\n\t}\n\n\tfile2 := LogFile{\n\t\tName: \"file2.log\",\n\t\tLines: []string{\n\t\t\t\"INFO: 2013/11/05 18:11:01 main.go:46: Everything is ok\",\n\t\t},\n\t}\n\n\tfile3 := LogFile{\n\t\tName: \"file3.log\",\n\t\tLines: []string{\n\t\t\t\"2013/11/05 18:42:26 Hello World\",\n\t\t},\n\t}\n\n\tlogFiles := []LogFile{file1, file2, file3}\n\tvar results []string\n\n\tFrom(logFiles).\n\t\tSelectManyIndexedT(func(fileIndex int, file LogFile) Query {\n\t\t\treturn From(file.Lines).\n\t\t\t\tSelectIndexedT(func(lineIndex int, line string) string {\n\t\t\t\t\treturn fmt.Sprintf(\"File:[%d] - %s => line: %d - %s\", fileIndex+1, file.Name, lineIndex+1, line)\n\t\t\t\t})\n\t\t}).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// File:[1] - file1.log => line: 1 - INFO: 2013/11/05 18:11:01 main.go:44: Special Information\n\t// File:[1] - file1.log => line: 2 - WARNING: 2013/11/05 18:11:01 main.go:45: There is something you need to know about\n\t// File:[1] - file1.log => line: 3 - ERROR: 2013/11/05 18:11:01 main.go:46: Something has failed\n\t// File:[2] - file2.log => line: 1 - INFO: 2013/11/05 18:11:01 main.go:46: Everything is ok\n\t// File:[3] - file3.log => line: 1 - 2013/11/05 18:42:26 Hello World\n\n}\n\n// The following code example demonstrates how to use SelectMany\n// to perform a one-to-many projection over a slice\nfunc ExampleQuery_SelectManyBy() {\n\n\ttype Pet struct {\n\t\tName string\n\t}\n\n\ttype Person struct {\n\t\tName string\n\t\tPets []Pet\n\t}\n\n\tmagnus := Person{\n\t\tName: \"Hedlund, Magnus\",\n\t\tPets: []Pet{{Name: \"Daisy\"}},\n\t}\n\n\tterry := Person{\n\t\tName: \"Adams, Terry\",\n\t\tPets: []Pet{{Name: \"Barley\"}, {Name: \"Boots\"}},\n\t}\n\tcharlotte := Person{\n\t\tName: \"Weiss, Charlotte\",\n\t\tPets: []Pet{{Name: \"Whiskers\"}},\n\t}\n\n\tpeople := []Person{magnus, terry, charlotte}\n\tvar results []string\n\tFrom(people).\n\t\tSelectManyBy(\n\t\t\tfunc(person interface{}) Query { return From(person.(Person).Pets) },\n\t\t\tfunc(pet, person interface{}) interface{} {\n\t\t\t\treturn fmt.Sprintf(\"Owner: %s, Pet: %s\", person.(Person).Name, pet.(Pet).Name)\n\t\t\t},\n\t\t).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// Owner: Hedlund, Magnus, Pet: Daisy\n\t// Owner: Adams, Terry, Pet: Barley\n\t// Owner: Adams, Terry, Pet: Boots\n\t// Owner: Weiss, Charlotte, Pet: Whiskers\n}\n\n// The following code example demonstrates how to use SequenceEqual\n// to determine whether two slices are equal.\nfunc ExampleQuery_SequenceEqual() {\n\ttype Pet struct {\n\t\tName string\n\t\tAge  int\n\t}\n\n\tpets1 := []Pet{\n\t\t{Name: \"Barley\", Age: 8},\n\t\t{Name: \"Boots\", Age: 4},\n\t\t{Name: \"Whiskers\", Age: 1},\n\t\t{Name: \"Daisy\", Age: 4},\n\t}\n\n\tpets2 := []Pet{\n\t\t{Name: \"Barley\", Age: 8},\n\t\t{Name: \"Boots\", Age: 4},\n\t\t{Name: \"Whiskers\", Age: 1},\n\t\t{Name: \"Daisy\", Age: 4},\n\t}\n\n\tequal := From(pets1).SequenceEqual(From(pets2))\n\n\tfmt.Printf(\"Are the lists equals? %t\", equal)\n\t// Output:\n\t// Are the lists equals? true\n}\n\n// The following code example demonstrates how to use Single\n// to select the only element of a slice.\nfunc ExampleQuery_Single() {\n\tfruits1 := []string{\"orange\"}\n\n\tfruit1 := From(fruits1).Single()\n\n\tfmt.Println(fruit1)\n\t// Output:\n\t// orange\n}\n\n// The following code example demonstrates how to use SingleWith\n// to select the only element of a slice that satisfies a condition.\nfunc ExampleQuery_SingleWith() {\n\tfruits := []string{\"apple\", \"banana\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\tfruit := From(fruits).\n\t\tSingleWith(\n\t\t\tfunc(f interface{}) bool { return len(f.(string)) > 10 },\n\t\t)\n\n\tfmt.Println(fruit)\n\t// Output:\n\t// passionfruit\n}\n\n// The following code example demonstrates how to use Skip\n// to skip a specified number of elements in a sorted array\n// and return the remaining elements.\nfunc ExampleQuery_Skip() {\n\tgrades := []int{59, 82, 70, 56, 92, 98, 85}\n\tvar lowerGrades []int\n\tFrom(grades).\n\t\tOrderByDescending(\n\t\t\tfunc(g interface{}) interface{} { return g },\n\t\t).\n\t\tSkip(3).\n\t\tToSlice(&lowerGrades)\n\n\t//All grades except the top three are:\n\tfmt.Println(lowerGrades)\n\t// Output:\n\t// [82 70 59 56]\n}\n\n// The following code example demonstrates how to use SkipWhile\n// to skip elements of an array as long as a condition is true.\nfunc ExampleQuery_SkipWhile() {\n\tgrades := []int{59, 82, 70, 56, 92, 98, 85}\n\tvar lowerGrades []int\n\tFrom(grades).\n\t\tOrderByDescending(\n\t\t\tfunc(g interface{}) interface{} { return g },\n\t\t).\n\t\tSkipWhile(\n\t\t\tfunc(g interface{}) bool { return g.(int) >= 80 },\n\t\t).\n\t\tToSlice(&lowerGrades)\n\n\t// All grades below 80:\n\tfmt.Println(lowerGrades)\n\t// Output:\n\t// [70 59 56]\n}\n\n// The following code example demonstrates how to use SkipWhileIndexed\n// to skip elements of an array as long as a condition that depends\n// on the element's index is true.\nfunc ExampleQuery_SkipWhileIndexed() {\n\tamounts := []int{5000, 2500, 9000, 8000, 6500, 4000, 1500, 5500}\n\n\tvar query []int\n\tFrom(amounts).\n\t\tSkipWhileIndexed(\n\t\t\tfunc(index int, amount interface{}) bool { return amount.(int) > index*1000 },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [4000 1500 5500]\n\n}\n\n// The following code example demonstrates how to use Sort\n// to order elements of an slice.\nfunc ExampleQuery_Sort() {\n\tamounts := []int{5000, 2500, 9000, 8000, 6500, 4000, 1500, 5500}\n\n\tvar query []int\n\tFrom(amounts).\n\t\tSort(\n\t\t\tfunc(i interface{}, j interface{}) bool { return i.(int) < j.(int) },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [1500 2500 4000 5000 5500 6500 8000 9000]\n\n}\n\n// The following code example demonstrates how to use SumFloats\n// to sum the values of a slice.\nfunc ExampleQuery_SumFloats() {\n\tnumbers := []float64{43.68, 1.25, 583.7, 6.5}\n\n\tsum := From(numbers).SumFloats()\n\n\tfmt.Printf(\"The sum of the numbers is %f.\", sum)\n\t// Output:\n\t// The sum of the numbers is 635.130000.\n\n}\n\n// The following code example demonstrates how to use SumInts\n// to sum the values of a slice.\nfunc ExampleQuery_SumInts() {\n\tnumbers := []int{43, 1, 583, 6}\n\n\tsum := From(numbers).SumInts()\n\n\tfmt.Printf(\"The sum of the numbers is %d.\", sum)\n\t// Output:\n\t// The sum of the numbers is 633.\n\n}\n\n// The following code example demonstrates how to use SumUInts\n// to sum the values of a slice.\nfunc ExampleQuery_SumUInts() {\n\tnumbers := []uint{43, 1, 583, 6}\n\n\tsum := From(numbers).SumUInts()\n\n\tfmt.Printf(\"The sum of the numbers is %d.\", sum)\n\t// Output:\n\t// The sum of the numbers is 633.\n\n}\n\n// The following code example demonstrates how to use Take\n//  to return elements from the start of a slice.\nfunc ExampleQuery_Take() {\n\tgrades := []int{59, 82, 70, 56, 92, 98, 85}\n\n\tvar topThreeGrades []int\n\tFrom(grades).\n\t\tOrderByDescending(\n\t\t\tfunc(grade interface{}) interface{} { return grade },\n\t\t).\n\t\tTake(3).\n\t\tToSlice(&topThreeGrades)\n\n\tfmt.Printf(\"The top three grades are: %v\", topThreeGrades)\n\t// Output:\n\t// The top three grades are: [98 92 85]\n}\n\n// The following code example demonstrates how to use TakeWhile\n// to return elements from the start of a slice.\nfunc ExampleQuery_TakeWhile() {\n\tfruits := []string{\"apple\", \"banana\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\tvar query []string\n\tFrom(fruits).\n\t\tTakeWhile(\n\t\t\tfunc(fruit interface{}) bool { return fruit.(string) != \"orange\" },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [apple banana mango]\n}\n\n// The following code example demonstrates how to use TakeWhileIndexed\n// to return elements from the start of a slice as long as\n// a condition that uses the element's index is true.\nfunc ExampleQuery_TakeWhileIndexed() {\n\n\tfruits := []string{\"apple\", \"passionfruit\", \"banana\", \"mango\",\n\t\t\"orange\", \"blueberry\", \"grape\", \"strawberry\"}\n\n\tvar query []string\n\tFrom(fruits).\n\t\tTakeWhileIndexed(\n\t\t\tfunc(index int, fruit interface{}) bool { return len(fruit.(string)) >= index },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [apple passionfruit banana mango orange blueberry]\n}\n\n// The following code example demonstrates how to use ToChannel\n// to send a slice to a channel.\nfunc ExampleQuery_ToChannel() {\n\tc := make(chan interface{})\n\n\tgo func() {\n\t\tRepeat(10, 3).ToChannel(c)\n\t}()\n\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n\t// Output:\n\t// 10\n\t// 10\n\t// 10\n}\n\n// The following code example demonstrates how to use ToChannelT\n// to send a slice to a typed channel.\nfunc ExampleQuery_ToChannelT() {\n\tc := make(chan string)\n\n\tgo Repeat(\"ten\", 3).ToChannelT(c)\n\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n\t// Output:\n\t// ten\n\t// ten\n\t// ten\n}\n\n// The following code example demonstrates how to use ToMap to populate a map.\nfunc ExampleQuery_ToMap() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tproducts := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tmap1 := map[int]string{}\n\tFrom(products).\n\t\tSelectT(\n\t\t\tfunc(item Product) KeyValue { return KeyValue{Key: item.Code, Value: item.Name} },\n\t\t).\n\t\tToMap(&map1)\n\n\tfmt.Println(map1[4])\n\tfmt.Println(map1[9])\n\tfmt.Println(map1[12])\n\t// Output:\n\t// orange\n\t// apple\n\t// lemon\n}\n\n// The following code example demonstrates how to use ToMapBy\n// by using a key and value selectors to populate a map.\nfunc ExampleQuery_ToMapBy() {\n\tinput := [][]interface{}{{1, true}}\n\n\tresult := make(map[int]bool)\n\tFrom(input).\n\t\tToMapBy(&result,\n\t\t\tfunc(i interface{}) interface{} {\n\t\t\t\treturn i.([]interface{})[0]\n\t\t\t},\n\t\t\tfunc(i interface{}) interface{} {\n\t\t\t\treturn i.([]interface{})[1]\n\t\t\t},\n\t\t)\n\n\tfmt.Println(result)\n\t// Output:\n\t// map[1:true]\n}\n\n// The following code example demonstrates how to use ToSlice to populate a slice.\nfunc ExampleQuery_ToSlice() {\n\tvar result []int\n\tRange(1, 10).ToSlice(&result)\n\n\tfmt.Println(result)\n\t// Output:\n\t// [1 2 3 4 5 6 7 8 9 10]\n}\n\n// The following code example demonstrates how to use Union\n// to obtain the union of two slices of integers.\nfunc ExampleQuery_Union() {\n\tq := Range(1, 10).Union(Range(6, 10))\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]\n}\n\n// The following code example demonstrates how to use Where\n// to filter a slices.\nfunc ExampleQuery_Where() {\n\tfruits := []string{\"apple\", \"passionfruit\", \"banana\", \"mango\",\n\t\t\"orange\", \"blueberry\", \"grape\", \"strawberry\"}\n\tvar query []string\n\tFrom(fruits).\n\t\tWhere(\n\t\t\tfunc(f interface{}) bool { return len(f.(string)) > 6 },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [passionfruit blueberry strawberry]\n}\n\n// The following code example demonstrates how to use WhereIndexed\n// to filter a slice based on a predicate that involves the index of each element.\nfunc ExampleQuery_WhereIndexed() {\n\tnumbers := []int{0, 30, 20, 15, 90, 85, 40, 75}\n\n\tvar query []int\n\tFrom(numbers).\n\t\tWhereIndexed(\n\t\t\tfunc(index int, number interface{}) bool { return number.(int) <= index*10 },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [0 20 15 40]\n}\n\n// The following code example demonstrates how to use the Zip\n// method to merge two slices.\nfunc ExampleQuery_Zip() {\n\tnumber := []int{1, 2, 3, 4, 5}\n\twords := []string{\"one\", \"two\", \"three\"}\n\n\tq := From(number).\n\t\tZip(From(words),\n\t\t\tfunc(a interface{}, b interface{}) interface{} { return []interface{}{a, b} },\n\t\t)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [[1 one] [2 two] [3 three]]\n}\n\n// The following code example demonstrates how to use ThenByDescendingT to perform\n// a order in a slice of dates by year, and then by month descending.\nfunc ExampleOrderedQuery_ThenByDescendingT() {\n\tdates := []time.Time{\n\t\ttime.Date(2015, 3, 23, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2014, 7, 11, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2013, 5, 4, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2015, 1, 2, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2015, 7, 10, 0, 0, 0, 0, time.Local),\n\t}\n\n\tvar orderedDates []time.Time\n\tFrom(dates).\n\t\tOrderByT(\n\t\t\tfunc(date time.Time) int {\n\t\t\t\treturn date.Year()\n\t\t\t}).\n\t\tThenByDescendingT(\n\t\t\tfunc(date time.Time) int { return int(date.Month()) },\n\t\t).\n\t\tToSlice(&orderedDates)\n\n\tfor _, date := range orderedDates {\n\t\tfmt.Println(date.Format(\"2006-Jan-02\"))\n\t}\n\t// Output:\n\t// 2013-May-04\n\t// 2014-Jul-11\n\t// 2015-Jul-10\n\t// 2015-Mar-23\n\t// 2015-Jan-02\n\n}\n\n// The following code example demonstrates how to use ThenByT to perform\n// a orders in a slice of dates by year, and then by day.\nfunc ExampleOrderedQuery_ThenByT() {\n\tdates := []time.Time{\n\t\ttime.Date(2015, 3, 23, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2014, 7, 11, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2013, 5, 4, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2015, 1, 2, 0, 0, 0, 0, time.Local),\n\t\ttime.Date(2015, 7, 10, 0, 0, 0, 0, time.Local),\n\t}\n\n\tvar orderedDates []time.Time\n\tFrom(dates).\n\t\tOrderByT(\n\t\t\tfunc(date time.Time) int { return date.Year() },\n\t\t).\n\t\tThenByT(\n\t\t\tfunc(date time.Time) int { return int(date.Day()) },\n\t\t).\n\t\tToSlice(&orderedDates)\n\n\tfor _, date := range orderedDates {\n\t\tfmt.Println(date.Format(\"2006-Jan-02\"))\n\t}\n\t// Output:\n\t// 2013-May-04\n\t// 2014-Jul-11\n\t// 2015-Jan-02\n\t// 2015-Jul-10\n\t// 2015-Mar-23\n\n}\n\n// The following code example demonstrates how to reverse\n// the order of words in a string using AggregateT.\nfunc ExampleQuery_AggregateT() {\n\tsentence := \"the quick brown fox jumps over the lazy dog\"\n\t// Split the string into individual words.\n\twords := strings.Split(sentence, \" \")\n\n\t// Prepend each word to the beginning of the\n\t// new sentence to reverse the word order.\n\treversed := From(words).AggregateT(\n\t\tfunc(workingSentence string, next string) string { return next + \" \" + workingSentence },\n\t)\n\n\tfmt.Println(reversed)\n\t// Output:\n\t// dog lazy the over jumps fox brown quick the\n}\n\n// The following code example demonstrates how to use AggregateWithSeed function\nfunc ExampleQuery_AggregateWithSeedT() {\n\n\tfruits := []string{\"apple\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\t// Determine whether any string in the array is longer than \"banana\".\n\tlongestName := From(fruits).\n\t\tAggregateWithSeedT(\"banana\",\n\t\t\tfunc(longest, next string) string {\n\t\t\t\tif len(next) > len(longest) {\n\t\t\t\t\treturn next\n\t\t\t\t}\n\t\t\t\treturn longest\n\t\t\t},\n\t\t)\n\n\tfmt.Printf(\"The fruit with the longest name is %s.\", longestName)\n\t// Output:\n\t// The fruit with the longest name is passionfruit.\n\n}\n\n// The following code example demonstrates how to use AggregateWithSeedByT function\nfunc ExampleQuery_AggregateWithSeedByT() {\n\tinput := []string{\"apple\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\t// Determine whether any string in the array is longer than \"banana\".\n\tlongestName := From(input).AggregateWithSeedByT(\"banana\",\n\t\tfunc(longest string, next string) string {\n\t\t\tif len(longest) > len(next) {\n\t\t\t\treturn longest\n\t\t\t}\n\t\t\treturn next\n\n\t\t},\n\t\t// Return the final result\n\t\tfunc(result string) string {\n\t\t\treturn fmt.Sprintf(\"The fruit with the longest name is %s.\", result)\n\t\t},\n\t)\n\n\tfmt.Println(longestName)\n\t// Output:\n\t// The fruit with the longest name is passionfruit.\n}\n\n// The following code example demonstrates how to use AllT\n// to get the students having all marks greater than 70.\nfunc ExampleQuery_AllT() {\n\n\ttype Student struct {\n\t\tName  string\n\t\tMarks []int\n\t}\n\n\tstudents := []Student{\n\t\t{Name: \"Hugo\", Marks: []int{91, 88, 76, 93}},\n\t\t{Name: \"Rick\", Marks: []int{70, 73, 66, 90}},\n\t\t{Name: \"Michael\", Marks: []int{73, 80, 75, 88}},\n\t\t{Name: \"Fadi\", Marks: []int{82, 75, 66, 84}},\n\t\t{Name: \"Peter\", Marks: []int{67, 78, 70, 82}},\n\t}\n\n\tvar approvedStudents []Student\n\tFrom(students).\n\t\tWhereT(\n\t\t\tfunc(student Student) bool {\n\t\t\t\treturn From(student.Marks).\n\t\t\t\t\tAllT(\n\t\t\t\t\t\tfunc(mark int) bool { return mark > 70 },\n\t\t\t\t\t)\n\t\t\t},\n\t\t).\n\t\tToSlice(&approvedStudents)\n\n\t//List of approved students\n\tfor _, student := range approvedStudents {\n\t\tfmt.Println(student.Name)\n\t}\n\t// Output:\n\t// Hugo\n\t// Michael\n}\n\n// The following code example demonstrates how to use AnyWithT\n// to get the students with any mark lower than 70.\nfunc ExampleQuery_AnyWithT() {\n\ttype Student struct {\n\t\tName  string\n\t\tMarks []int\n\t}\n\n\tstudents := []Student{\n\t\t{Name: \"Hugo\", Marks: []int{91, 88, 76, 93}},\n\t\t{Name: \"Rick\", Marks: []int{70, 73, 66, 90}},\n\t\t{Name: \"Michael\", Marks: []int{73, 80, 75, 88}},\n\t\t{Name: \"Fadi\", Marks: []int{82, 75, 66, 84}},\n\t\t{Name: \"Peter\", Marks: []int{67, 78, 70, 82}},\n\t}\n\n\tvar studentsWithAnyMarkLt70 []Student\n\tFrom(students).\n\t\tWhereT(\n\t\t\tfunc(student Student) bool {\n\t\t\t\treturn From(student.Marks).\n\t\t\t\t\tAnyWithT(\n\t\t\t\t\t\tfunc(mark int) bool { return mark < 70 },\n\t\t\t\t\t)\n\t\t\t},\n\t\t).\n\t\tToSlice(&studentsWithAnyMarkLt70)\n\n\t//List of students with any mark lower than 70\n\tfor _, student := range studentsWithAnyMarkLt70 {\n\t\tfmt.Println(student.Name)\n\t}\n\t// Output:\n\t// Rick\n\t// Fadi\n\t// Peter\n\n}\n\n// The following code example demonstrates how to use CountWithT\n// to count the elements in an slice that satisfy a condition.\nfunc ExampleQuery_CountWithT() {\n\ttype Pet struct {\n\t\tName       string\n\t\tVaccinated bool\n\t}\n\n\tpets := []Pet{\n\t\t{Name: \"Barley\", Vaccinated: true},\n\t\t{Name: \"Boots\", Vaccinated: false},\n\t\t{Name: \"Whiskers\", Vaccinated: false},\n\t}\n\n\tnumberUnvaccinated := From(pets).\n\t\tCountWithT(\n\t\t\tfunc(p Pet) bool { return p.Vaccinated == false },\n\t\t)\n\n\tfmt.Printf(\"There are %d unvaccinated animals.\", numberUnvaccinated)\n\n\t//Output:\n\t//There are 2 unvaccinated animals.\n}\n\n// The following code example demonstrates how to use DistinctByT\n// to return distinct elements from a slice of structs.\nfunc ExampleQuery_DistinctByT() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tproducts := []Product{\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t}\n\n\t//Exclude duplicates.\n\tvar noduplicates []Product\n\tFrom(products).\n\t\tDistinctByT(\n\t\t\tfunc(item Product) int { return item.Code },\n\t\t).\n\t\tToSlice(&noduplicates)\n\n\tfor _, product := range noduplicates {\n\t\tfmt.Printf(\"%s %d\\n\", product.Name, product.Code)\n\t}\n\t// Output:\n\t// apple 9\n\t// orange 4\n\t// lemon 12\n}\n\n// The following code example demonstrates how to use ExceptByT\nfunc ExampleQuery_ExceptByT() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tfruits1 := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tfruits2 := []Product{\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\t//Order and exclude duplicates.\n\tvar except []Product\n\tFrom(fruits1).\n\t\tExceptByT(From(fruits2),\n\t\t\tfunc(item Product) int { return item.Code },\n\t\t).\n\t\tToSlice(&except)\n\n\tfor _, product := range except {\n\t\tfmt.Printf(\"%s %d\\n\", product.Name, product.Code)\n\t}\n\t// Output:\n\t// orange 4\n\t// lemon 12\n\n}\n\n// The following code example demonstrates how to use FirstWithT\n// to return the first element of an array that satisfies a condition.\nfunc ExampleQuery_FirstWithT() {\n\tnumbers := []int{9, 34, 65, 92, 87, 435, 3, 54, 83, 23, 87, 435, 67, 12, 19}\n\n\tfirst := From(numbers).\n\t\tFirstWithT(\n\t\t\tfunc(item int) bool { return item > 80 },\n\t\t)\n\n\tfmt.Println(first)\n\t// Output:\n\t// 92\n\n}\n\n// The following code example demonstrates how to use ForEach\n// to output all elements of an array.\nfunc ExampleQuery_ForEach() {\n\tfruits := []string{\"orange\", \"apple\", \"lemon\", \"apple\"}\n\n\tFrom(fruits).ForEach(func(fruit interface{}) {\n\t\tfmt.Println(fruit)\n\t})\n\t// Output:\n\t// orange\n\t// apple\n\t// lemon\n\t// apple\n}\n\n// The following code example demonstrates how to use ForEachIndexed\n// to output all elements of an array with its index.\nfunc ExampleQuery_ForEachIndexed() {\n\tfruits := []string{\"orange\", \"apple\", \"lemon\", \"apple\"}\n\n\tFrom(fruits).ForEachIndexed(func(i int, fruit interface{}) {\n\t\tfmt.Printf(\"%d.%s\\n\", i, fruit)\n\t})\n\t// Output:\n\t// 0.orange\n\t// 1.apple\n\t// 2.lemon\n\t// 3.apple\n}\n\n// The following code example demonstrates how to use ForEachT\n// to output all elements of an array.\nfunc ExampleQuery_ForEachT() {\n\tfruits := []string{\"orange\", \"apple\", \"lemon\", \"apple\"}\n\n\tFrom(fruits).ForEachT(func(fruit string) {\n\t\tfmt.Println(fruit)\n\t})\n\t// Output:\n\t// orange\n\t// apple\n\t// lemon\n\t// apple\n}\n\n// The following code example demonstrates how to use ForEachIndexedT\n// to output all elements of an array with its index.\nfunc ExampleQuery_ForEachIndexedT() {\n\tfruits := []string{\"orange\", \"apple\", \"lemon\", \"apple\"}\n\n\tFrom(fruits).ForEachIndexedT(func(i int, fruit string) {\n\t\tfmt.Printf(\"%d.%s\\n\", i, fruit)\n\t})\n\t// Output:\n\t// 0.orange\n\t// 1.apple\n\t// 2.lemon\n\t// 3.apple\n}\n\n// The following code example demonstrates how to use GroupByT\n// to group the elements of a slice.\nfunc ExampleQuery_GroupByT() {\n\n\ttype Pet struct {\n\t\tName string\n\t\tAge  int\n\t}\n\t// Create a list of pets.\n\tpets := []Pet{\n\t\t{Name: \"Barley\", Age: 8},\n\t\t{Name: \"Boots\", Age: 4},\n\t\t{Name: \"Whiskers\", Age: 1},\n\t\t{Name: \"Daisy\", Age: 4},\n\t}\n\n\t// Group the pets using Age as the key value\n\t// and selecting only the pet's Name for each value.\n\tvar query []Group\n\tFrom(pets).GroupByT(\n\t\tfunc(p Pet) int { return p.Age },\n\t\tfunc(p Pet) string { return p.Name },\n\t).OrderByT(\n\t\tfunc(g Group) int { return g.Key.(int) },\n\t).ToSlice(&query)\n\n\tfor _, petGroup := range query {\n\t\tfmt.Printf(\"%d\\n\", petGroup.Key)\n\t\tfor _, petName := range petGroup.Group {\n\t\t\tfmt.Printf(\"  %s\\n\", petName)\n\t\t}\n\n\t}\n\t// Output:\n\t// 1\n\t//   Whiskers\n\t// 4\n\t//   Boots\n\t//   Daisy\n\t// 8\n\t//   Barley\n}\n\n// The following code example demonstrates how to use GroupJoinT\n//  to perform a grouped join on two slices.\nfunc ExampleQuery_GroupJoinT() {\n\n\ttype Person struct {\n\t\tName string\n\t}\n\n\ttype Pet struct {\n\t\tName  string\n\t\tOwner Person\n\t}\n\n\tmagnus := Person{Name: \"Hedlund, Magnus\"}\n\tterry := Person{Name: \"Adams, Terry\"}\n\tcharlotte := Person{Name: \"Weiss, Charlotte\"}\n\n\tbarley := Pet{Name: \"Barley\", Owner: terry}\n\tboots := Pet{Name: \"Boots\", Owner: terry}\n\twhiskers := Pet{Name: \"Whiskers\", Owner: charlotte}\n\tdaisy := Pet{Name: \"Daisy\", Owner: magnus}\n\n\tpeople := []Person{magnus, terry, charlotte}\n\tpets := []Pet{barley, boots, whiskers, daisy}\n\n\t// Create a slice where each element is a KeyValue\n\t// that contains a person's name as the key and a slice of strings\n\t// of names of the pets they own as a value.\n\n\tq := []KeyValue{}\n\tFrom(people).\n\t\tGroupJoinT(From(pets),\n\t\t\tfunc(p Person) Person { return p },\n\t\t\tfunc(p Pet) Person { return p.Owner },\n\t\t\tfunc(person Person, pets []Pet) KeyValue {\n\t\t\t\tvar petNames []string\n\t\t\t\tFrom(pets).\n\t\t\t\t\tSelectT(\n\t\t\t\t\t\tfunc(pet Pet) string { return pet.Name },\n\t\t\t\t\t).\n\t\t\t\t\tToSlice(&petNames)\n\t\t\t\treturn KeyValue{person.Name, petNames}\n\t\t\t},\n\t\t).ToSlice(&q)\n\n\tfor _, obj := range q {\n\t\t// Output the owner's name.\n\t\tfmt.Printf(\"%s:\\n\", obj.Key)\n\t\t// Output each of the owner's pet's names.\n\t\tfor _, petName := range obj.Value.([]string) {\n\t\t\tfmt.Printf(\"  %s\\n\", petName)\n\t\t}\n\t}\n\t// Output:\n\t// Hedlund, Magnus:\n\t//   Daisy\n\t// Adams, Terry:\n\t//   Barley\n\t//   Boots\n\t// Weiss, Charlotte:\n\t//   Whiskers\n}\n\n// The following code example demonstrates how to use IntersectByT\n// to return the elements that appear in each of two slices of products\n// with same Code.\nfunc ExampleQuery_IntersectByT() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tstore1 := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tstore2 := []Product{\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tvar duplicates []Product\n\tFrom(store1).\n\t\tIntersectByT(From(store2),\n\t\t\tfunc(p Product) int { return p.Code },\n\t\t).\n\t\tToSlice(&duplicates)\n\n\tfor _, p := range duplicates {\n\t\tfmt.Println(p.Name, \"\", p.Code)\n\t}\n\t// Output:\n\t// apple  9\n\n}\n\n// The following code example demonstrates how to use JoinT\n// to perform an inner join of two slices based on a common key.\nfunc ExampleQuery_JoinT() {\n\ttype Person struct {\n\t\tName string\n\t}\n\n\ttype Pet struct {\n\t\tName  string\n\t\tOwner Person\n\t}\n\n\tmagnus := Person{Name: \"Hedlund, Magnus\"}\n\tterry := Person{Name: \"Adams, Terry\"}\n\tcharlotte := Person{Name: \"Weiss, Charlotte\"}\n\n\tbarley := Pet{Name: \"Barley\", Owner: terry}\n\tboots := Pet{Name: \"Boots\", Owner: terry}\n\twhiskers := Pet{Name: \"Whiskers\", Owner: charlotte}\n\tdaisy := Pet{Name: \"Daisy\", Owner: magnus}\n\n\tpeople := []Person{magnus, terry, charlotte}\n\tpets := []Pet{barley, boots, whiskers, daisy}\n\n\t// Create a list of Person-Pet pairs where\n\t// each element is an anonymous type that contains a\n\t// Pet's name and the name of the Person that owns the Pet.\n\n\tquery := []string{}\n\tFrom(people).\n\t\tJoinT(From(pets),\n\t\t\tfunc(person Person) Person { return person },\n\t\t\tfunc(pet Pet) Person { return pet.Owner },\n\t\t\tfunc(person Person, pet Pet) string { return fmt.Sprintf(\"%s - %s\", person.Name, pet.Name) },\n\t\t).ToSlice(&query)\n\n\tfor _, line := range query {\n\t\tfmt.Println(line)\n\t}\n\t//Output:\n\t//Hedlund, Magnus - Daisy\n\t//Adams, Terry - Barley\n\t//Adams, Terry - Boots\n\t//Weiss, Charlotte - Whiskers\n}\n\n// The following code example demonstrates how to use LastWithT\n// to return the last element of an array.\nfunc ExampleQuery_LastWithT() {\n\tnumbers := []int{9, 34, 65, 92, 87, 435, 3, 54,\n\t\t83, 23, 87, 67, 12, 19}\n\n\tlast := From(numbers).\n\t\tLastWithT(\n\t\t\tfunc(n int) bool { return n > 80 },\n\t\t)\n\n\tfmt.Println(last)\n\n\t//Output:\n\t//87\n\n}\n\n// The following code example demonstrates how to use OrderByDescendingT\n// to order an slice.\nfunc ExampleQuery_OrderByDescendingT() {\n\ttype Player struct {\n\t\tName   string\n\t\tPoints int64\n\t}\n\n\tplayers := []Player{\n\t\t{Name: \"Hugo\", Points: 4757},\n\t\t{Name: \"Rick\", Points: 7365},\n\t\t{Name: \"Michael\", Points: 2857},\n\t\t{Name: \"Fadi\", Points: 85897},\n\t\t{Name: \"Peter\", Points: 48576},\n\t}\n\n\t//Order and get the top 3 players\n\tvar top3Players []KeyValue\n\tFrom(players).\n\t\tOrderByDescendingT(\n\t\t\tfunc(p Player) int64 { return p.Points },\n\t\t).\n\t\tTake(3).\n\t\tSelectIndexedT(\n\t\t\tfunc(i int, p Player) KeyValue { return KeyValue{Key: i + 1, Value: p} },\n\t\t).\n\t\tToSlice(&top3Players)\n\n\tfor _, rank := range top3Players {\n\t\tfmt.Printf(\n\t\t\t\"Rank: #%d - Player: %s - Points: %d\\n\",\n\t\t\trank.Key,\n\t\t\trank.Value.(Player).Name,\n\t\t\trank.Value.(Player).Points,\n\t\t)\n\n\t}\n\t// Output:\n\t// Rank: #1 - Player: Fadi - Points: 85897\n\t// Rank: #2 - Player: Peter - Points: 48576\n\t// Rank: #3 - Player: Rick - Points: 7365\n}\n\n// The following code example demonstrates how to use OrderByT\n// to sort the elements of a slice.\nfunc ExampleQuery_OrderByT() {\n\ttype Pet struct {\n\t\tName string\n\t\tAge  int\n\t}\n\t// Create a list of pets.\n\tpets := []Pet{\n\t\t{Name: \"Barley\", Age: 8},\n\t\t{Name: \"Boots\", Age: 4},\n\t\t{Name: \"Whiskers\", Age: 1},\n\t\t{Name: \"Daisy\", Age: 4},\n\t}\n\n\tvar orderedPets []Pet\n\tFrom(pets).\n\t\tOrderByT(\n\t\t\tfunc(pet Pet) int { return pet.Age },\n\t\t).\n\t\tToSlice(&orderedPets)\n\n\tfor _, pet := range orderedPets {\n\t\tfmt.Println(pet.Name, \"-\", pet.Age)\n\t}\n\t// Output:\n\t// Whiskers - 1\n\t// Boots - 4\n\t// Daisy - 4\n\t// Barley - 8\n}\n\n// The following code example demonstrates how to use SelectT\n// to project over a slice.\nfunc ExampleQuery_SelectT() {\n\tsquares := []int{}\n\n\tRange(1, 10).\n\t\tSelectT(\n\t\t\tfunc(x int) int { return x * x },\n\t\t).\n\t\tToSlice(&squares)\n\n\tfmt.Println(squares)\n\t// Output:\n\t// [1 4 9 16 25 36 49 64 81 100]\n}\n\n// The following code example demonstrates how to use SelectIndexedT\n// to determine if the value in a slice of int match their position\n// in the slice.\nfunc ExampleQuery_SelectIndexedT() {\n\tnumbers := []int{5, 4, 1, 3, 9, 8, 6, 7, 2, 0}\n\n\tvar numsInPlace []KeyValue\n\n\tFrom(numbers).\n\t\tSelectIndexedT(\n\t\t\tfunc(index, num int) KeyValue { return KeyValue{Key: num, Value: (num == index)} },\n\t\t).\n\t\tToSlice(&numsInPlace)\n\n\tfmt.Println(\"Number: In-place?\")\n\tfor _, n := range numsInPlace {\n\t\tfmt.Printf(\"%d: %t\\n\", n.Key, n.Value)\n\t}\n\t// Output:\n\t// Number: In-place?\n\t// 5: false\n\t// 4: false\n\t// 1: false\n\t// 3: true\n\t// 9: false\n\t// 8: false\n\t// 6: true\n\t// 7: true\n\t// 2: false\n\t// 0: false\n\n}\n\n// The following code example demonstrates how to use SelectManyT\n// to perform a one-to-many projection over a slice\nfunc ExampleQuery_SelectManyByT() {\n\n\ttype Pet struct {\n\t\tName string\n\t}\n\n\ttype Person struct {\n\t\tName string\n\t\tPets []Pet\n\t}\n\n\tmagnus := Person{\n\t\tName: \"Hedlund, Magnus\",\n\t\tPets: []Pet{{Name: \"Daisy\"}},\n\t}\n\n\tterry := Person{\n\t\tName: \"Adams, Terry\",\n\t\tPets: []Pet{{Name: \"Barley\"}, {Name: \"Boots\"}},\n\t}\n\tcharlotte := Person{\n\t\tName: \"Weiss, Charlotte\",\n\t\tPets: []Pet{{Name: \"Whiskers\"}},\n\t}\n\n\tpeople := []Person{magnus, terry, charlotte}\n\tvar results []string\n\tFrom(people).\n\t\tSelectManyByT(\n\t\t\tfunc(person Person) Query { return From(person.Pets) },\n\t\t\tfunc(pet Pet, person Person) interface{} {\n\t\t\t\treturn fmt.Sprintf(\"Owner: %s, Pet: %s\", person.Name, pet.Name)\n\t\t\t},\n\t\t).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// Owner: Hedlund, Magnus, Pet: Daisy\n\t// Owner: Adams, Terry, Pet: Barley\n\t// Owner: Adams, Terry, Pet: Boots\n\t// Owner: Weiss, Charlotte, Pet: Whiskers\n}\n\n// The following code example demonstrates how to use SelectManyT\n// to perform a projection over a list of sentences and rank the\n// top 5 most used words\nfunc ExampleQuery_SelectManyT() {\n\tsentences := []string{\n\t\t\"the quick brown fox jumps over the lazy dog\",\n\t\t\"pack my box with five dozen liquor jugs\",\n\t\t\"several fabulous dixieland jazz groups played with quick tempo\",\n\t\t\"back in my quaint garden jaunty zinnias vie with flaunting phlox\",\n\t\t\"five or six big jet planes zoomed quickly by the new tower\",\n\t\t\"I quickly explained that many big jobs involve few hazards\",\n\t\t\"The wizard quickly jinxed the gnomes before they vaporized\",\n\t}\n\n\tvar results []string\n\tFrom(sentences).\n\t\t//Split the sentences in words\n\t\tSelectManyT(func(sentence string) Query {\n\t\t\treturn From(strings.Split(sentence, \" \"))\n\t\t}).\n\t\t//Grouping by word\n\t\tGroupByT(\n\t\t\tfunc(word string) string { return word },\n\t\t\tfunc(word string) string { return word },\n\t\t).\n\t\t//Ordering by word counts\n\t\tOrderByDescendingT(func(wordGroup Group) int {\n\t\t\treturn len(wordGroup.Group)\n\t\t}).\n\t\t//Then order by word\n\t\tThenByT(func(wordGroup Group) string {\n\t\t\treturn wordGroup.Key.(string)\n\t\t}).\n\t\t//Take the top 5\n\t\tTake(5).\n\t\t//Project the words using the index as rank\n\t\tSelectIndexedT(func(index int, wordGroup Group) string {\n\t\t\treturn fmt.Sprintf(\"Rank: #%d, Word: %s, Counts: %d\", index+1, wordGroup.Key, len(wordGroup.Group))\n\t\t}).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// Rank: #1, Word: the, Counts: 4\n\t// Rank: #2, Word: quickly, Counts: 3\n\t// Rank: #3, Word: with, Counts: 3\n\t// Rank: #4, Word: big, Counts: 2\n\t// Rank: #5, Word: five, Counts: 2\n}\n\n// The following code example demonstrates how to use SelectManyIndexedT\n// to perform a one-to-many projection over an slice of log files and\n// print out their contents.\nfunc ExampleQuery_SelectManyIndexedT() {\n\ttype LogFile struct {\n\t\tName  string\n\t\tLines []string\n\t}\n\n\tfile1 := LogFile{\n\t\tName: \"file1.log\",\n\t\tLines: []string{\n\t\t\t\"INFO: 2013/11/05 18:11:01 main.go:44: Special Information\",\n\t\t\t\"WARNING: 2013/11/05 18:11:01 main.go:45: There is something you need to know about\",\n\t\t\t\"ERROR: 2013/11/05 18:11:01 main.go:46: Something has failed\",\n\t\t},\n\t}\n\n\tfile2 := LogFile{\n\t\tName: \"file2.log\",\n\t\tLines: []string{\n\t\t\t\"INFO: 2013/11/05 18:11:01 main.go:46: Everything is ok\",\n\t\t},\n\t}\n\n\tfile3 := LogFile{\n\t\tName: \"file3.log\",\n\t\tLines: []string{\n\t\t\t\"2013/11/05 18:42:26 Hello World\",\n\t\t},\n\t}\n\n\tlogFiles := []LogFile{file1, file2, file3}\n\tvar results []string\n\n\tFrom(logFiles).\n\t\tSelectManyIndexedT(func(fileIndex int, file LogFile) Query {\n\t\t\treturn From(file.Lines).\n\t\t\t\tSelectIndexedT(func(lineIndex int, line string) string {\n\t\t\t\t\treturn fmt.Sprintf(\"File:[%d] - %s => line: %d - %s\", fileIndex+1, file.Name, lineIndex+1, line)\n\t\t\t\t})\n\t\t}).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// File:[1] - file1.log => line: 1 - INFO: 2013/11/05 18:11:01 main.go:44: Special Information\n\t// File:[1] - file1.log => line: 2 - WARNING: 2013/11/05 18:11:01 main.go:45: There is something you need to know about\n\t// File:[1] - file1.log => line: 3 - ERROR: 2013/11/05 18:11:01 main.go:46: Something has failed\n\t// File:[2] - file2.log => line: 1 - INFO: 2013/11/05 18:11:01 main.go:46: Everything is ok\n\t// File:[3] - file3.log => line: 1 - 2013/11/05 18:42:26 Hello World\n\n}\n\n// The following code example demonstrates how to use SelectManyByIndexedT\n// to perform a one-to-many projection over an array and use the index of\n// each outer element.\nfunc ExampleQuery_SelectManyByIndexedT() {\n\ttype Pet struct {\n\t\tName string\n\t}\n\n\ttype Person struct {\n\t\tName string\n\t\tPets []Pet\n\t}\n\n\tmagnus := Person{\n\t\tName: \"Hedlund, Magnus\",\n\t\tPets: []Pet{{Name: \"Daisy\"}},\n\t}\n\n\tterry := Person{\n\t\tName: \"Adams, Terry\",\n\t\tPets: []Pet{{Name: \"Barley\"}, {Name: \"Boots\"}},\n\t}\n\tcharlotte := Person{\n\t\tName: \"Weiss, Charlotte\",\n\t\tPets: []Pet{{Name: \"Whiskers\"}},\n\t}\n\n\tpeople := []Person{magnus, terry, charlotte}\n\tvar results []string\n\n\tFrom(people).\n\t\tSelectManyByIndexedT(\n\t\t\tfunc(index int, person Person) Query {\n\t\t\t\treturn From(person.Pets).\n\t\t\t\t\tSelectT(func(pet Pet) string {\n\t\t\t\t\t\treturn fmt.Sprintf(\"%d - %s\", index, pet.Name)\n\t\t\t\t\t})\n\t\t\t},\n\t\t\tfunc(indexedPet string, person Person) string {\n\t\t\t\treturn fmt.Sprintf(\"Pet: %s, Owner: %s\", indexedPet, person.Name)\n\t\t\t},\n\t\t).\n\t\tToSlice(&results)\n\n\tfor _, result := range results {\n\t\tfmt.Println(result)\n\t}\n\t// Output:\n\t// Pet: 0 - Daisy, Owner: Hedlund, Magnus\n\t// Pet: 1 - Barley, Owner: Adams, Terry\n\t// Pet: 1 - Boots, Owner: Adams, Terry\n\t// Pet: 2 - Whiskers, Owner: Weiss, Charlotte\n\n}\n\n//The following code example demonstrates how to use SingleWithT\n// to select the only element of a slice that satisfies a condition.\nfunc ExampleQuery_SingleWithT() {\n\tfruits := []string{\"apple\", \"banana\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\tfruit := From(fruits).\n\t\tSingleWithT(\n\t\t\tfunc(f string) bool { return len(f) > 10 },\n\t\t)\n\n\tfmt.Println(fruit)\n\t// Output:\n\t// passionfruit\n}\n\n// The following code example demonstrates how to use SkipWhileT\n// to skip elements of an array as long as a condition is true.\nfunc ExampleQuery_SkipWhileT() {\n\tgrades := []int{59, 82, 70, 56, 92, 98, 85}\n\tvar lowerGrades []int\n\tFrom(grades).\n\t\tOrderByDescendingT(\n\t\t\tfunc(g int) int { return g },\n\t\t).\n\t\tSkipWhileT(\n\t\t\tfunc(g int) bool { return g >= 80 },\n\t\t).\n\t\tToSlice(&lowerGrades)\n\n\t//\"All grades below 80:\n\tfmt.Println(lowerGrades)\n\t// Output:\n\t// [70 59 56]\n}\n\n// The following code example demonstrates how to use SkipWhileIndexedT\n// to skip elements of an array as long as a condition that depends\n// on the element's index is true.\nfunc ExampleQuery_SkipWhileIndexedT() {\n\tamounts := []int{5000, 2500, 9000, 8000, 6500, 4000, 1500, 5500}\n\n\tvar query []int\n\tFrom(amounts).\n\t\tSkipWhileIndexedT(\n\t\t\tfunc(index int, amount int) bool { return amount > index*1000 },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [4000 1500 5500]\n\n}\n\n// The following code example demonstrates how to use SortT\n// to order elements of an slice.\nfunc ExampleQuery_SortT() {\n\ttype Pet struct {\n\t\tName string\n\t\tAge  int\n\t}\n\t// Create a list of pets.\n\tpets := []Pet{\n\t\t{Name: \"Barley\", Age: 8},\n\t\t{Name: \"Boots\", Age: 4},\n\t\t{Name: \"Whiskers\", Age: 1},\n\t\t{Name: \"Daisy\", Age: 4},\n\t}\n\n\torderedPets := []Pet{}\n\tFrom(pets).\n\t\tSortT(\n\t\t\tfunc(pet1 Pet, pet2 Pet) bool { return pet1.Age < pet2.Age },\n\t\t).\n\t\tToSlice(&orderedPets)\n\n\tfor _, pet := range orderedPets {\n\t\tfmt.Println(pet.Name, \"-\", pet.Age)\n\t}\n\t// Output:\n\t// Whiskers - 1\n\t// Boots - 4\n\t// Daisy - 4\n\t// Barley - 8\n\n}\n\n// The following code example demonstrates how to use TakeWhileT\n// to return elements from the start of a slice.\nfunc ExampleQuery_TakeWhileT() {\n\tfruits := []string{\"apple\", \"banana\", \"mango\", \"orange\", \"passionfruit\", \"grape\"}\n\n\tvar query []string\n\tFrom(fruits).\n\t\tTakeWhileT(\n\t\t\tfunc(fruit string) bool { return fruit != \"orange\" },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [apple banana mango]\n}\n\n// The following code example demonstrates how to use TakeWhileIndexedT\n// to return elements from the start of a slice as long asa condition\n// that uses the element's index is true.\nfunc ExampleQuery_TakeWhileIndexedT() {\n\n\tfruits := []string{\"apple\", \"passionfruit\", \"banana\", \"mango\",\n\t\t\"orange\", \"blueberry\", \"grape\", \"strawberry\"}\n\n\tvar query []string\n\tFrom(fruits).\n\t\tTakeWhileIndexedT(\n\t\t\tfunc(index int, fruit string) bool { return len(fruit) >= index },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [apple passionfruit banana mango orange blueberry]\n}\n\n// The following code example demonstrates how to use ToMapBy\n// by using a key and value selectors to populate a map.\nfunc ExampleQuery_ToMapByT() {\n\ttype Product struct {\n\t\tName string\n\t\tCode int\n\t}\n\n\tproducts := []Product{\n\t\t{Name: \"orange\", Code: 4},\n\t\t{Name: \"apple\", Code: 9},\n\t\t{Name: \"lemon\", Code: 12},\n\t\t{Name: \"apple\", Code: 9},\n\t}\n\n\tmap1 := map[int]string{}\n\tFrom(products).\n\t\tToMapByT(&map1,\n\t\t\tfunc(item Product) int { return item.Code },\n\t\t\tfunc(item Product) string { return item.Name },\n\t\t)\n\n\tfmt.Println(map1[4])\n\tfmt.Println(map1[9])\n\tfmt.Println(map1[12])\n\t// Output:\n\t// orange\n\t// apple\n\t// lemon\n}\n\n// The following code example demonstrates how to use WhereT\n// to filter a slices.\nfunc ExampleQuery_WhereT() {\n\tfruits := []string{\"apple\", \"passionfruit\", \"banana\", \"mango\",\n\t\t\"orange\", \"blueberry\", \"grape\", \"strawberry\"}\n\tvar query []string\n\tFrom(fruits).\n\t\tWhereT(\n\t\t\tfunc(f string) bool { return len(f) > 6 },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [passionfruit blueberry strawberry]\n}\n\n// The following code example demonstrates how to use WhereIndexedT\n// to filter a slice based on a predicate that involves the index of each element.\nfunc ExampleQuery_WhereIndexedT() {\n\tnumbers := []int{0, 30, 20, 15, 90, 85, 40, 75}\n\n\tvar query []int\n\tFrom(numbers).\n\t\tWhereIndexedT(\n\t\t\tfunc(index int, number int) bool { return number <= index*10 },\n\t\t).\n\t\tToSlice(&query)\n\n\tfmt.Println(query)\n\t// Output:\n\t// [0 20 15 40]\n}\n\n// The following code example demonstrates how to use the ZipT\n// method to merge two slices.\nfunc ExampleQuery_ZipT() {\n\tnumber := []int{1, 2, 3, 4, 5}\n\twords := []string{\"one\", \"two\", \"three\"}\n\n\tq := From(number).\n\t\tZipT(From(words),\n\t\t\tfunc(a int, b string) []interface{} { return []interface{}{a, b} },\n\t\t)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [[1 one] [2 two] [3 three]]\n}\n\n// The following code example demonstrates how to use the FromChannelT\n// to make a Query from typed channel.\nfunc ExampleFromChannelT() {\n\tch := make(chan string, 3)\n\tch <- \"one\"\n\tch <- \"two\"\n\tch <- \"three\"\n\tclose(ch)\n\n\tq := FromChannelT(ch)\n\n\tfmt.Println(q.Results())\n\t// Output:\n\t// [one two three]\n}\n"
        },
        {
          "name": "except.go",
          "type": "blob",
          "size": 1.8837890625,
          "content": "package linq\n\n// Except produces the set difference of two sequences. The set difference is\n// the members of the first sequence that don't appear in the second sequence.\nfunc (q Query) Except(q2 Query) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\n\t\t\tnext2 := q2.Iterate()\n\t\t\tset := make(map[interface{}]bool)\n\t\t\tfor i, ok := next2(); ok; i, ok = next2() {\n\t\t\t\tset[i] = true\n\t\t\t}\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\tif _, has := set[item]; !has {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// ExceptBy invokes a transform function on each element of a collection and\n// produces the set difference of two sequences. The set difference is the\n// members of the first sequence that don't appear in the second sequence.\nfunc (q Query) ExceptBy(q2 Query,\n\tselector func(interface{}) interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\n\t\t\tnext2 := q2.Iterate()\n\t\t\tset := make(map[interface{}]bool)\n\t\t\tfor i, ok := next2(); ok; i, ok = next2() {\n\t\t\t\ts := selector(i)\n\t\t\t\tset[s] = true\n\t\t\t}\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\ts := selector(item)\n\t\t\t\t\tif _, has := set[s]; !has {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// ExceptByT is the typed version of ExceptBy.\n//\n//   - selectorFn is of type \"func(TSource) TSource\"\n//\n// NOTE: ExceptBy has better performance than ExceptByT.\nfunc (q Query) ExceptByT(q2 Query,\n\tselectorFn interface{}) Query {\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"ExceptByT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(item interface{}) interface{} {\n\t\treturn selectorGenericFunc.Call(item)\n\t}\n\n\treturn q.ExceptBy(q2, selectorFunc)\n}\n"
        },
        {
          "name": "except_test.go",
          "type": "blob",
          "size": 0.9814453125,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestExcept(t *testing.T) {\n\tinput1 := []int{1, 2, 3, 4, 5, 1, 2, 5}\n\tinput2 := []int{1, 2}\n\twant := []interface{}{3, 4, 5, 5}\n\n\tif q := From(input1).Except(From(input2)); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Except(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n\nfunc TestExceptBy(t *testing.T) {\n\tinput1 := []int{1, 2, 3, 4, 5, 1, 2, 5}\n\tinput2 := []int{1}\n\twant := []interface{}{2, 4, 2}\n\n\tif q := From(input1).ExceptBy(From(input2), func(i interface{}) interface{} {\n\t\treturn i.(int) % 2\n\t}); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).ExceptBy(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n\nfunc TestExceptByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ExceptByT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).ExceptByT(From([]int{1}), func(x, item int) int { return item + 2 })\n\t})\n}\n"
        },
        {
          "name": "from.go",
          "type": "blob",
          "size": 4.0390625,
          "content": "package linq\n\nimport \"reflect\"\n\n// Iterator is an alias for function to iterate over data.\ntype Iterator func() (item interface{}, ok bool)\n\n// Query is the type returned from query functions. It can be iterated manually\n// as shown in the example.\ntype Query struct {\n\tIterate func() Iterator\n}\n\n// KeyValue is a type that is used to iterate over a map (if query is created\n// from a map). This type is also used by ToMap() method to output result of a\n// query into a map.\ntype KeyValue struct {\n\tKey   interface{}\n\tValue interface{}\n}\n\n// Iterable is an interface that has to be implemented by a custom collection in\n// order to work with linq.\ntype Iterable interface {\n\tIterate() Iterator\n}\n\n// From initializes a linq query with passed slice, array or map as the source.\n// String, channel or struct implementing Iterable interface can be used as an\n// input. In this case From delegates it to FromString, FromChannel and\n// FromIterable internally.\nfunc From(source interface{}) Query {\n\tsrc := reflect.ValueOf(source)\n\n\tswitch src.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tlen := src.Len()\n\n\t\treturn Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\tindex := 0\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tok = index < len\n\t\t\t\t\tif ok {\n\t\t\t\t\t\titem = src.Index(index).Interface()\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\tcase reflect.Map:\n\t\tlen := src.Len()\n\n\t\treturn Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\tindex := 0\n\t\t\t\tkeys := src.MapKeys()\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tok = index < len\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tkey := keys[index]\n\t\t\t\t\t\titem = KeyValue{\n\t\t\t\t\t\t\tKey:   key.Interface(),\n\t\t\t\t\t\t\tValue: src.MapIndex(key).Interface(),\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\tcase reflect.String:\n\t\treturn FromString(source.(string))\n\tcase reflect.Chan:\n\t\tif _, ok := source.(chan interface{}); ok {\n\t\t\treturn FromChannel(source.(chan interface{}))\n\t\t} else {\n\t\t\treturn FromChannelT(source)\n\t\t}\n\tdefault:\n\t\treturn FromIterable(source.(Iterable))\n\t}\n}\n\n// FromChannel initializes a linq query with passed channel, linq iterates over\n// channel until it is closed.\nfunc FromChannel(source <-chan interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\titem, ok = <-source\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// FromChannelT is the typed version of FromChannel.\n//\n//   - source is of type \"chan TSource\"\n//\n// NOTE: FromChannel has better performance than FromChannelT.\nfunc FromChannelT(source interface{}) Query {\n\tsrc := reflect.ValueOf(source)\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\treturn func() (interface{}, bool) {\n\t\t\t\tvalue, ok := src.Recv()\n\t\t\t\treturn value.Interface(), ok\n\t\t\t}\n\t\t},\n\t}\n}\n\n// FromString initializes a linq query with passed string, linq iterates over\n// runes of string.\nfunc FromString(source string) Query {\n\trunes := []rune(source)\n\tlen := len(runes)\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tok = index < len\n\t\t\t\tif ok {\n\t\t\t\t\titem = runes[index]\n\t\t\t\t\tindex++\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// FromIterable initializes a linq query with custom collection passed. This\n// collection has to implement Iterable interface, linq iterates over items,\n// that has to implement Comparable interface or be basic types.\nfunc FromIterable(source Iterable) Query {\n\treturn Query{\n\t\tIterate: source.Iterate,\n\t}\n}\n\n// Range generates a sequence of integral numbers within a specified range.\nfunc Range(start, count int) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tindex := 0\n\t\t\tcurrent := start\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif index >= count {\n\t\t\t\t\treturn nil, false\n\t\t\t\t}\n\n\t\t\t\titem, ok = current, true\n\n\t\t\t\tindex++\n\t\t\t\tcurrent++\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// Repeat generates a sequence that contains one repeated value.\nfunc Repeat(value interface{}, count int) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif index >= count {\n\t\t\t\t\treturn nil, false\n\t\t\t\t}\n\n\t\t\t\titem, ok = value, true\n\n\t\t\t\tindex++\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "from_test.go",
          "type": "blob",
          "size": 2.3857421875,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestFrom(t *testing.T) {\n\tc := make(chan interface{}, 3)\n\tc <- -1\n\tc <- 0\n\tc <- 1\n\tclose(c)\n\n\tct := make(chan int, 3)\n\tct <- -10\n\tct <- 0\n\tct <- 10\n\tclose(ct)\n\n\ttests := []struct {\n\t\tinput  interface{}\n\t\toutput []interface{}\n\t\twant   bool\n\t}{\n\t\t{[]int{1, 2, 3}, []interface{}{1, 2, 3}, true},\n\t\t{[]int{1, 2, 4}, []interface{}{1, 2, 3}, false},\n\t\t{[3]int{1, 2, 3}, []interface{}{1, 2, 3}, true},\n\t\t{[3]int{1, 2, 4}, []interface{}{1, 2, 3}, false},\n\t\t{\"str\", []interface{}{'s', 't', 'r'}, true},\n\t\t{\"str\", []interface{}{'s', 't', 'g'}, false},\n\t\t{map[string]bool{\"foo\": true}, []interface{}{KeyValue{\"foo\", true}}, true},\n\t\t{map[string]bool{\"foo\": true}, []interface{}{KeyValue{\"foo\", false}}, false},\n\t\t{c, []interface{}{-1, 0, 1}, true},\n\t\t{ct, []interface{}{-10, 0, 10}, true},\n\t\t{foo{f1: 1, f2: true, f3: \"string\"}, []interface{}{1, true, \"string\"}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input); validateQuery(q, test.output) != test.want {\n\t\t\tif test.want {\n\t\t\t\tt.Errorf(\"From(%v)=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"From(%v)=%v expected not equal\", test.input, test.output)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestFromChannel(t *testing.T) {\n\tc := make(chan interface{}, 3)\n\tc <- 10\n\tc <- 15\n\tc <- -3\n\tclose(c)\n\n\tw := []interface{}{10, 15, -3}\n\n\tif q := FromChannel(c); !validateQuery(q, w) {\n\t\tt.Errorf(\"FromChannel() failed expected %v\", w)\n\t}\n}\n\nfunc TestFromChannelT(t *testing.T) {\n\tc := make(chan int, 3)\n\tc <- 10\n\tc <- 15\n\tc <- -3\n\tclose(c)\n\n\tw := []interface{}{10, 15, -3}\n\n\tif q := FromChannelT(c); !validateQuery(q, w) {\n\t\tt.Errorf(\"FromChannelT() failed expected %v\", w)\n\t}\n}\n\nfunc TestFromString(t *testing.T) {\n\ts := \"string\"\n\tw := []interface{}{'s', 't', 'r', 'i', 'n', 'g'}\n\n\tif q := FromString(s); !validateQuery(q, w) {\n\t\tt.Errorf(\"FromString(%v)!=%v\", s, w)\n\t}\n}\n\nfunc TestFromIterable(t *testing.T) {\n\ts := foo{f1: 1, f2: true, f3: \"string\"}\n\tw := []interface{}{1, true, \"string\"}\n\n\tif q := FromIterable(s); !validateQuery(q, w) {\n\t\tt.Errorf(\"FromIterable(%v)!=%v\", s, w)\n\t}\n}\n\nfunc TestRange(t *testing.T) {\n\tw := []interface{}{-2, -1, 0, 1, 2}\n\n\tif q := Range(-2, 5); !validateQuery(q, w) {\n\t\tt.Errorf(\"Range(-2, 5)=%v expected %v\", toSlice(q), w)\n\t}\n}\n\nfunc TestRepeat(t *testing.T) {\n\tw := []interface{}{1, 1, 1, 1, 1}\n\n\tif q := Repeat(1, 5); !validateQuery(q, w) {\n\t\tt.Errorf(\"Repeat(1, 5)=%v expected %v\", toSlice(q), w)\n\t}\n}\n"
        },
        {
          "name": "general_test.go",
          "type": "blob",
          "size": 0.576171875,
          "content": "package linq\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestChannelToChannel(t *testing.T) {\n\tinput := []int{30, 40, 50}\n\n\tinpCh := make(chan interface{})\n\tresCh := make(chan interface{})\n\n\tgo func() {\n\t\tfor _, i := range input {\n\t\t\tinpCh <- i\n\t\t}\n\n\t\tclose(inpCh)\n\t}()\n\n\tgo func() {\n\t\tFromChannel(inpCh).Where(func(i interface{}) bool {\n\t\t\treturn i.(int) > 20\n\t\t}).ToChannel(resCh)\n\t}()\n\n\tresult := []int{}\n\tfor value := range resCh {\n\t\tresult = append(result, value.(int))\n\t}\n\n\tif !reflect.DeepEqual(result, input) {\n\t\tt.Errorf(\"FromChannel().ToChannel()=%v expected %v\", result, input)\n\t}\n}\n"
        },
        {
          "name": "genericfunc.go",
          "type": "blob",
          "size": 3.708984375,
          "content": "package linq\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// genericType represents a any reflect.Type.\ntype genericType int\n\nvar genericTp = reflect.TypeOf(new(genericType)).Elem()\n\n// functionCache keeps genericFunc reflection objects in cache.\ntype functionCache struct {\n\tMethodName string\n\tParamName  string\n\tFnValue    reflect.Value\n\tFnType     reflect.Type\n\tTypesIn    []reflect.Type\n\tTypesOut   []reflect.Type\n}\n\n// genericFunc is a type used to validate and call dynamic functions.\ntype genericFunc struct {\n\tCache *functionCache\n}\n\n// Call calls a dynamic function.\nfunc (g *genericFunc) Call(params ...interface{}) interface{} {\n\tparamsIn := make([]reflect.Value, len(params))\n\tfor i, param := range params {\n\t\tparamsIn[i] = reflect.ValueOf(param)\n\t}\n\tparamsOut := g.Cache.FnValue.Call(paramsIn)\n\tif len(paramsOut) >= 1 {\n\t\treturn paramsOut[0].Interface()\n\t}\n\treturn nil\n}\n\n// newGenericFunc instantiates a new genericFunc pointer\nfunc newGenericFunc(methodName, paramName string, fn interface{}, validateFunc func(*functionCache) error) (*genericFunc, error) {\n\tcache := &functionCache{}\n\tcache.FnValue = reflect.ValueOf(fn)\n\n\tif cache.FnValue.Kind() != reflect.Func {\n\t\treturn nil, fmt.Errorf(\"%s: parameter [%s] is not a function type. It is a '%s'\", methodName, paramName, cache.FnValue.Type())\n\t}\n\tcache.MethodName = methodName\n\tcache.ParamName = paramName\n\tcache.FnType = cache.FnValue.Type()\n\tnumTypesIn := cache.FnType.NumIn()\n\tcache.TypesIn = make([]reflect.Type, numTypesIn)\n\tfor i := 0; i < numTypesIn; i++ {\n\t\tcache.TypesIn[i] = cache.FnType.In(i)\n\t}\n\n\tnumTypesOut := cache.FnType.NumOut()\n\tcache.TypesOut = make([]reflect.Type, numTypesOut)\n\tfor i := 0; i < numTypesOut; i++ {\n\t\tcache.TypesOut[i] = cache.FnType.Out(i)\n\t}\n\tif err := validateFunc(cache); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &genericFunc{Cache: cache}, nil\n}\n\n// simpleParamValidator creates a function to validate genericFunc based in the\n// In and Out function parameters.\nfunc simpleParamValidator(In []reflect.Type, Out []reflect.Type) func(cache *functionCache) error {\n\treturn func(cache *functionCache) error {\n\t\tvar isValid = func() bool {\n\t\t\tif In != nil {\n\t\t\t\tif len(In) != len(cache.TypesIn) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tfor i, paramIn := range In {\n\t\t\t\t\tif paramIn != genericTp && paramIn != cache.TypesIn[i] {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif Out != nil {\n\t\t\t\tif len(Out) != len(cache.TypesOut) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tfor i, paramOut := range Out {\n\t\t\t\t\tif paramOut != genericTp && paramOut != cache.TypesOut[i] {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tif !isValid() {\n\t\t\treturn fmt.Errorf(\"%s: parameter [%s] has a invalid function signature. Expected: '%s', actual: '%s'\", cache.MethodName, cache.ParamName, formatFnSignature(In, Out), formatFnSignature(cache.TypesIn, cache.TypesOut))\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// newElemTypeSlice creates a slice of items elem types.\nfunc newElemTypeSlice(items ...interface{}) []reflect.Type {\n\ttypeList := make([]reflect.Type, len(items))\n\tfor i, item := range items {\n\t\ttypeItem := reflect.TypeOf(item)\n\t\tif typeItem.Kind() == reflect.Ptr {\n\t\t\ttypeList[i] = typeItem.Elem()\n\t\t}\n\t}\n\treturn typeList\n}\n\n// formatFnSignature formats the func signature based in the parameters types.\nfunc formatFnSignature(In []reflect.Type, Out []reflect.Type) string {\n\tparamInNames := make([]string, len(In))\n\tfor i, typeIn := range In {\n\t\tif typeIn == genericTp {\n\t\t\tparamInNames[i] = \"T\"\n\t\t} else {\n\t\t\tparamInNames[i] = typeIn.String()\n\t\t}\n\n\t}\n\tparamOutNames := make([]string, len(Out))\n\tfor i, typeOut := range Out {\n\t\tif typeOut == genericTp {\n\t\t\tparamOutNames[i] = \"T\"\n\t\t} else {\n\t\t\tparamOutNames[i] = typeOut.String()\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"func(%s)%s\", strings.Join(paramInNames, \",\"), strings.Join(paramOutNames, \",\"))\n}\n"
        },
        {
          "name": "genericfunc_test.go",
          "type": "blob",
          "size": 4.5,
          "content": "package linq\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestNewGenericFunc(t *testing.T) {\n\ttests := []struct {\n\t\tmethodName     string\n\t\tparamName      string\n\t\tfunction       interface{}\n\t\tvalidationFunc func(*functionCache) error\n\t\texception      error\n\t}{\n\t\t{ // A valid function\n\t\t\t\"TestNewGenericFunc\", \"test1\",\n\t\t\tfunc(item int) bool { return item > 10 },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(int)), newElemTypeSlice(new(bool))),\n\t\t\tnil,\n\t\t},\n\t\t{ // A valid generic function\n\t\t\t\"TestNewGenericFunc\", \"test1\",\n\t\t\tfunc(item int) bool { return item > 10 },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t\t\tnil,\n\t\t},\n\t\t{ //returns error when the function parameter has not the function kind\n\t\t\t\"TestNewGenericFunc\", \"test2\",\n\t\t\t\"Not a function\",\n\t\t\tsimpleParamValidator(nil, []reflect.Type{}),\n\t\t\terrors.New(\"TestNewGenericFunc: parameter [test2] is not a function type. It is a 'string'\"),\n\t\t},\n\t\t{ // Returns error when expected parameters number are not equal\n\t\t\t\"TestNewGenericFunc\", \"test3\",\n\t\t\tfunc(idx, item int) {},\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(int)), []reflect.Type{}),\n\t\t\terrors.New(\"TestNewGenericFunc: parameter [test3] has a invalid function signature. Expected: 'func(int)', actual: 'func(int,int)'\"),\n\t\t},\n\t\t{ // Returns error when expected parameters types are not equal\n\t\t\t\"TestNewGenericFunc\", \"test4\",\n\t\t\tfunc(items ...int) bool { return false },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new([]bool)), newElemTypeSlice(new(bool))),\n\t\t\terrors.New(\"TestNewGenericFunc: parameter [test4] has a invalid function signature. Expected: 'func([]bool)bool', actual: 'func([]int)bool'\"),\n\t\t},\n\t\t{ // Returns error when expected returns number are not equal\n\t\t\t\"TestNewGenericFunc\", \"test5\",\n\t\t\tfunc(item int) bool { return item > 10 },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(int)), []reflect.Type{}),\n\t\t\terrors.New(\"TestNewGenericFunc: parameter [test5] has a invalid function signature. Expected: 'func(int)', actual: 'func(int)bool'\"),\n\t\t},\n\t\t{ // Returns error when expected return types are not equal\n\t\t\t\"TestNewGenericFunc\", \"test6\",\n\t\t\tfunc(items ...int) bool { return false },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new([]int)), newElemTypeSlice(new(int64))),\n\t\t\terrors.New(\"TestNewGenericFunc: parameter [test6] has a invalid function signature. Expected: 'func([]int)int64', actual: 'func([]int)bool'\"),\n\t\t},\n\t\t{ // Returns error when expected return types are not equal\n\t\t\t\"TestNewGenericFunc\", \"test7\",\n\t\t\tfunc(items ...int) bool { return false },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(int64))),\n\t\t\terrors.New(\"TestNewGenericFunc: parameter [test7] has a invalid function signature. Expected: 'func(T)int64', actual: 'func([]int)bool'\"),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t_, err := newGenericFunc(test.methodName, test.paramName, test.function, test.validationFunc)\n\t\tif !(err == test.exception || err.Error() == test.exception.Error()) {\n\t\t\tt.Errorf(\"Validate expect error: %s, actual: %s\", test.exception, err)\n\t\t}\n\t}\n}\n\nfunc TestCall(t *testing.T) {\n\ttests := []struct {\n\t\tmethodName     string\n\t\tparamName      string\n\t\tfunction       interface{}\n\t\tvalidationFunc func(*functionCache) error\n\t\tfnParameter    interface{}\n\t\tresult         interface{}\n\t\texception      error\n\t}{\n\t\t{ // A valid function and parameters\n\t\t\t\"TestCall\", \"test1\",\n\t\t\tfunc(i int) int { return i * 3 },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(int))),\n\t\t\t3,\n\t\t\t9,\n\t\t\tnil,\n\t\t},\n\t\t{ // Returns error when the required type doesn't match with the specification\n\t\t\t\"TestCall\", \"test2\",\n\t\t\tfunc(i int) int { return i * 3 },\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(int)), newElemTypeSlice(new(int))),\n\t\t\t\"not a int\",\n\t\t\t9,\n\t\t\terrors.New(\"reflect: Call using string as type int\"),\n\t\t},\n\t\t{ // A valid function and parameters\n\t\t\t\"TestCall\", \"test3\",\n\t\t\tfunc(i int) {},\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), []reflect.Type{}),\n\t\t\t3,\n\t\t\tnil,\n\t\t\tnil,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tfunc() {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif !(r == test.exception || r == test.exception.Error()) {\n\t\t\t\t\tt.Errorf(\"expect error: nil, actual: %s\", r)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdynaFunc, err := newGenericFunc(test.methodName, test.paramName, test.function, test.validationFunc)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"expect error: nil, actual: %s\", err)\n\t\t\t}\n\t\t\tresult := dynaFunc.Call(test.fnParameter)\n\n\t\t\tif result != nil && result != test.result {\n\t\t\t\tt.Errorf(\"expect result: %d, actual: %d\", test.result, result)\n\t\t\t}\n\t\t}()\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0439453125,
          "content": "module github.com/ahmetb/go-linq/v3\n\ngo 1.11\n"
        },
        {
          "name": "groupby.go",
          "type": "blob",
          "size": 2.0029296875,
          "content": "package linq\n\n// Group is a type that is used to store the result of GroupBy method.\ntype Group struct {\n\tKey   interface{}\n\tGroup []interface{}\n}\n\n// GroupBy method groups the elements of a collection according to a specified\n// key selector function and projects the elements for each group by using a\n// specified function.\nfunc (q Query) GroupBy(keySelector func(interface{}) interface{},\n\telementSelector func(interface{}) interface{}) Query {\n\treturn Query{\n\t\tfunc() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tset := make(map[interface{}][]interface{})\n\n\t\t\tfor item, ok := next(); ok; item, ok = next() {\n\t\t\t\tkey := keySelector(item)\n\t\t\t\tset[key] = append(set[key], elementSelector(item))\n\t\t\t}\n\n\t\t\tlen := len(set)\n\t\t\tidx := 0\n\t\t\tgroups := make([]Group, len)\n\t\t\tfor k, v := range set {\n\t\t\t\tgroups[idx] = Group{k, v}\n\t\t\t\tidx++\n\t\t\t}\n\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tok = index < len\n\t\t\t\tif ok {\n\t\t\t\t\titem = groups[index]\n\t\t\t\t\tindex++\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// GroupByT is the typed version of GroupBy.\n//\n//   - keySelectorFn is of type \"func(TSource) TKey\"\n//   - elementSelectorFn is of type \"func(TSource) TElement\"\n//\n// NOTE: GroupBy has better performance than GroupByT.\nfunc (q Query) GroupByT(keySelectorFn interface{},\n\telementSelectorFn interface{}) Query {\n\tkeySelectorGenericFunc, err := newGenericFunc(\n\t\t\"GroupByT\", \"keySelectorFn\", keySelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tkeySelectorFunc := func(item interface{}) interface{} {\n\t\treturn keySelectorGenericFunc.Call(item)\n\t}\n\n\telementSelectorGenericFunc, err := newGenericFunc(\n\t\t\"GroupByT\", \"elementSelectorFn\", elementSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\telementSelectorFunc := func(item interface{}) interface{} {\n\t\treturn elementSelectorGenericFunc.Call(item)\n\n\t}\n\n\treturn q.GroupBy(keySelectorFunc, elementSelectorFunc)\n}\n"
        },
        {
          "name": "groupby_test.go",
          "type": "blob",
          "size": 1.478515625,
          "content": "package linq\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGroupBy(t *testing.T) {\n\tinput := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\twantEven := []interface{}{2, 4, 6, 8}\n\twantOdd := []interface{}{1, 3, 5, 7, 9}\n\n\tq := From(input).GroupBy(\n\t\tfunc(i interface{}) interface{} { return i.(int) % 2 },\n\t\tfunc(i interface{}) interface{} { return i.(int) },\n\t)\n\n\tnext := q.Iterate()\n\teq := true\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tgroup := item.(Group)\n\t\tswitch group.Key.(int) {\n\t\tcase 0:\n\t\t\tif !reflect.DeepEqual(group.Group, wantEven) {\n\t\t\t\teq = false\n\t\t\t}\n\t\tcase 1:\n\t\t\tif !reflect.DeepEqual(group.Group, wantOdd) {\n\t\t\t\teq = false\n\t\t\t}\n\t\tdefault:\n\t\t\teq = false\n\t\t}\n\t}\n\n\tif !eq {\n\t\tt.Errorf(\"From(%v).GroupBy()=%v\", input, toSlice(q))\n\t}\n}\n\nfunc TestGroupByT_PanicWhenKeySelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"GroupByT: parameter [keySelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)bool'\", func() {\n\t\tvar r []int\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).GroupByT(\n\t\t\tfunc(i, j int) bool { return true },\n\t\t\tfunc(i int) int { return i },\n\t\t).ToSlice(&r)\n\t})\n}\n\nfunc TestGroupByT_PanicWhenElementSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"GroupByT: parameter [elementSelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tvar r []int\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).GroupByT(\n\t\t\tfunc(i int) bool { return true },\n\t\t\tfunc(i, j int) int { return i },\n\t\t).ToSlice(&r)\n\t})\n}\n"
        },
        {
          "name": "groupjoin.go",
          "type": "blob",
          "size": 3.65234375,
          "content": "package linq\n\nimport \"reflect\"\n\n// GroupJoin correlates the elements of two collections based on key equality,\n// and groups the results.\n//\n// This method produces hierarchical results, which means that elements from\n// outer query are paired with collections of matching elements from inner.\n// GroupJoin enables you to base your results on a whole set of matches for each\n// element of outer query.\n//\n// The resultSelector function is called only one time for each outer element\n// together with a collection of all the inner elements that match the outer\n// element. This differs from the Join method, in which the result selector\n// function is invoked on pairs that contain one element from outer and one\n// element from inner.\n//\n// GroupJoin preserves the order of the elements of outer, and for each element\n// of outer, the order of the matching elements from inner.\nfunc (q Query) GroupJoin(inner Query,\n\touterKeySelector func(interface{}) interface{},\n\tinnerKeySelector func(interface{}) interface{},\n\tresultSelector func(outer interface{}, inners []interface{}) interface{}) Query {\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\touternext := q.Iterate()\n\t\t\tinnernext := inner.Iterate()\n\n\t\t\tinnerLookup := make(map[interface{}][]interface{})\n\t\t\tfor innerItem, ok := innernext(); ok; innerItem, ok = innernext() {\n\t\t\t\tinnerKey := innerKeySelector(innerItem)\n\t\t\t\tinnerLookup[innerKey] = append(innerLookup[innerKey], innerItem)\n\t\t\t}\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif item, ok = outernext(); !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif group, has := innerLookup[outerKeySelector(item)]; !has {\n\t\t\t\t\titem = resultSelector(item, []interface{}{})\n\t\t\t\t} else {\n\t\t\t\t\titem = resultSelector(item, group)\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// GroupJoinT is the typed version of GroupJoin.\n//\n//   - inner: The query to join to the outer query.\n//   - outerKeySelectorFn is of type \"func(TOuter) TKey\"\n//   - innerKeySelectorFn is of type \"func(TInner) TKey\"\n//   - resultSelectorFn: is of type \"func(TOuter, inners []TInner) TResult\"\n//\n// NOTE: GroupJoin has better performance than GroupJoinT.\nfunc (q Query) GroupJoinT(inner Query,\n\touterKeySelectorFn interface{},\n\tinnerKeySelectorFn interface{},\n\tresultSelectorFn interface{}) Query {\n\touterKeySelectorGenericFunc, err := newGenericFunc(\n\t\t\"GroupJoinT\", \"outerKeySelectorFn\", outerKeySelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\touterKeySelectorFunc := func(item interface{}) interface{} {\n\t\treturn outerKeySelectorGenericFunc.Call(item)\n\t}\n\n\tinnerKeySelectorFuncGenericFunc, err := newGenericFunc(\n\t\t\"GroupJoinT\", \"innerKeySelectorFn\", innerKeySelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinnerKeySelectorFunc := func(item interface{}) interface{} {\n\t\treturn innerKeySelectorFuncGenericFunc.Call(item)\n\t}\n\n\tresultSelectorGenericFunc, err := newGenericFunc(\n\t\t\"GroupJoinT\", \"resultSelectorFn\", resultSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tresultSelectorFunc := func(outer interface{}, inners []interface{}) interface{} {\n\t\tinnerSliceType := reflect.MakeSlice(resultSelectorGenericFunc.Cache.TypesIn[1], 0, 0)\n\t\tinnersSlicePointer := reflect.New(innerSliceType.Type())\n\t\tFrom(inners).ToSlice(innersSlicePointer.Interface())\n\t\tinnersTyped := reflect.Indirect(innersSlicePointer).Interface()\n\t\treturn resultSelectorGenericFunc.Call(outer, innersTyped)\n\t}\n\n\treturn q.GroupJoin(inner, outerKeySelectorFunc, innerKeySelectorFunc, resultSelectorFunc)\n}\n"
        },
        {
          "name": "groupjoin_test.go",
          "type": "blob",
          "size": 1.978515625,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestGroupJoin(t *testing.T) {\n\touter := []int{0, 1, 2}\n\tinner := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\twant := []interface{}{\n\t\tKeyValue{0, 4},\n\t\tKeyValue{1, 5},\n\t\tKeyValue{2, 0},\n\t}\n\n\tq := From(outer).GroupJoin(\n\t\tFrom(inner),\n\t\tfunc(i interface{}) interface{} { return i },\n\t\tfunc(i interface{}) interface{} { return i.(int) % 2 },\n\t\tfunc(outer interface{}, inners []interface{}) interface{} {\n\t\t\treturn KeyValue{outer, len(inners)}\n\t\t})\n\n\tif !validateQuery(q, want) {\n\t\tt.Errorf(\"From().GroupJoin()=%v expected %v\", toSlice(q), want)\n\t}\n}\n\nfunc TestGroupJoinT_PanicWhenOuterKeySelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"GroupJoinT: parameter [outerKeySelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{0, 1, 2}).GroupJoinT(\n\t\t\tFrom([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}),\n\t\t\tfunc(i, j int) int { return i },\n\t\t\tfunc(i int) int { return i % 2 },\n\t\t\tfunc(outer int, inners []int) KeyValue { return KeyValue{outer, len(inners)} },\n\t\t)\n\t})\n}\n\nfunc TestGroupJoinT_PanicWhenInnerKeySelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"GroupJoinT: parameter [innerKeySelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{0, 1, 2}).GroupJoinT(\n\t\t\tFrom([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}),\n\t\t\tfunc(i int) int { return i },\n\t\t\tfunc(i, j int) int { return i % 2 },\n\t\t\tfunc(outer int, inners []int) KeyValue { return KeyValue{outer, len(inners)} },\n\t\t)\n\t})\n}\n\nfunc TestGroupJoinT_PanicWhenResultSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"GroupJoinT: parameter [resultSelectorFn] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func(int,int,[]int)linq.KeyValue'\", func() {\n\t\tFrom([]int{0, 1, 2}).GroupJoinT(\n\t\t\tFrom([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}),\n\t\t\tfunc(i int) int { return i },\n\t\t\tfunc(i int) int { return i % 2 },\n\t\t\tfunc(outer, j int, inners []int) KeyValue { return KeyValue{outer, len(inners)} },\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "index.go",
          "type": "blob",
          "size": 1.029296875,
          "content": "package linq\n\n// IndexOf searches for an element that matches the conditions defined by a specified predicate\n// and returns the zero-based index of the first occurrence within the collection. This method\n// returns -1 if an item that matches the conditions is not found.\nfunc (q Query) IndexOf(predicate func(interface{}) bool) int {\n\tindex := 0\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif predicate(item) {\n\t\t\treturn index\n\t\t}\n\t\tindex++\n\t}\n\n\treturn -1\n}\n\n// IndexOfT is the typed version of IndexOf.\n//\n//   - predicateFn is of type \"func(int,TSource)bool\"\n//\n// NOTE: IndexOf has better performance than IndexOfT.\nfunc (q Query) IndexOfT(predicateFn interface{}) int {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"IndexOfT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.IndexOf(predicateFunc)\n}\n"
        },
        {
          "name": "index_test.go",
          "type": "blob",
          "size": 1.2333984375,
          "content": "package linq\n\nimport (\n\t\"testing\"\n)\n\nfunc TestIndexOf(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(interface{}) bool\n\t\texpected  int\n\t}{\n\t\t{\n\t\t\tinput: [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t\tpredicate: func(i interface{}) bool {\n\t\t\t\treturn i.(int) == 3\n\t\t\t},\n\t\t\texpected: 2,\n\t\t},\n\t\t{\n\t\t\tinput: \"sstr\",\n\t\t\tpredicate: func(i interface{}) bool {\n\t\t\t\treturn i.(rune) == 'r'\n\t\t\t},\n\t\t\texpected: 3,\n\t\t},\n\t\t{\n\t\t\tinput: \"gadsgsadgsda\",\n\t\t\tpredicate: func(i interface{}) bool {\n\t\t\t\treturn i.(rune) == 'z'\n\t\t\t},\n\t\t\texpected: -1,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tindex := From(test.input).IndexOf(test.predicate)\n\t\tif index != test.expected {\n\t\t\tt.Errorf(\"From(%v).IndexOf() expected %v received %v\", test.input, test.expected, index)\n\t\t}\n\n\t\tindex = From(test.input).IndexOfT(test.predicate)\n\t\tif index != test.expected {\n\t\t\tt.Errorf(\"From(%v).IndexOfT() expected %v received %v\", test.input, test.expected, index)\n\t\t}\n\t}\n}\n\nfunc TestIndexOfT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"IndexOfT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).IndexOfT(func(item int) int { return item + 2 })\n\t})\n}\n"
        },
        {
          "name": "intersect.go",
          "type": "blob",
          "size": 2.173828125,
          "content": "package linq\n\n// Intersect produces the set intersection of the source collection and the\n// provided input collection. The intersection of two sets A and B is defined as\n// the set that contains all the elements of A that also appear in B, but no\n// other elements.\nfunc (q Query) Intersect(q2 Query) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tnext2 := q2.Iterate()\n\n\t\t\tset := make(map[interface{}]bool)\n\t\t\tfor item, ok := next2(); ok; item, ok = next2() {\n\t\t\t\tset[item] = true\n\t\t\t}\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\tif _, has := set[item]; has {\n\t\t\t\t\t\tdelete(set, item)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// IntersectBy produces the set intersection of the source collection and the\n// provided input collection. The intersection of two sets A and B is defined as\n// the set that contains all the elements of A that also appear in B, but no\n// other elements.\n//\n// IntersectBy invokes a transform function on each element of both collections.\nfunc (q Query) IntersectBy(q2 Query,\n\tselector func(interface{}) interface{}) Query {\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tnext2 := q2.Iterate()\n\n\t\t\tset := make(map[interface{}]bool)\n\t\t\tfor item, ok := next2(); ok; item, ok = next2() {\n\t\t\t\ts := selector(item)\n\t\t\t\tset[s] = true\n\t\t\t}\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\ts := selector(item)\n\t\t\t\t\tif _, has := set[s]; has {\n\t\t\t\t\t\tdelete(set, s)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// IntersectByT is the typed version of IntersectBy.\n//\n//   - selectorFn is of type \"func(TSource) TSource\"\n//\n// NOTE: IntersectBy has better performance than IntersectByT.\nfunc (q Query) IntersectByT(q2 Query,\n\tselectorFn interface{}) Query {\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"IntersectByT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(item interface{}) interface{} {\n\t\treturn selectorGenericFunc.Call(item)\n\t}\n\n\treturn q.IntersectBy(q2, selectorFunc)\n}\n"
        },
        {
          "name": "intersect_test.go",
          "type": "blob",
          "size": 0.9951171875,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestIntersect(t *testing.T) {\n\tinput1 := []int{1, 2, 3}\n\tinput2 := []int{1, 4, 7, 9, 12, 3}\n\twant := []interface{}{1, 3}\n\n\tif q := From(input1).Intersect(From(input2)); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Intersect(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n\nfunc TestIntersectBy(t *testing.T) {\n\tinput1 := []int{5, 7, 8}\n\tinput2 := []int{1, 4, 7, 9, 12, 3}\n\twant := []interface{}{5, 8}\n\n\tif q := From(input1).IntersectBy(From(input2), func(i interface{}) interface{} {\n\t\treturn i.(int) % 2\n\t}); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).IntersectBy(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n\nfunc TestIntersectByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"IntersectByT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{5, 7, 8}).IntersectByT(From([]int{1, 4, 7, 9, 12, 3}), func(i, x int) int {\n\t\t\treturn i % 2\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "join.go",
          "type": "blob",
          "size": 3.2041015625,
          "content": "package linq\n\n// Join correlates the elements of two collection based on matching keys.\n//\n// A join refers to the operation of correlating the elements of two sources of\n// information based on a common key. Join brings the two information sources\n// and the keys by which they are matched together in one method call. This\n// differs from the use of SelectMany, which requires more than one method call\n// to perform the same operation.\n//\n// Join preserves the order of the elements of outer collection, and for each of\n// these elements, the order of the matching elements of inner.\nfunc (q Query) Join(inner Query,\n\touterKeySelector func(interface{}) interface{},\n\tinnerKeySelector func(interface{}) interface{},\n\tresultSelector func(outer interface{}, inner interface{}) interface{}) Query {\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\touternext := q.Iterate()\n\t\t\tinnernext := inner.Iterate()\n\n\t\t\tinnerLookup := make(map[interface{}][]interface{})\n\t\t\tfor innerItem, ok := innernext(); ok; innerItem, ok = innernext() {\n\t\t\t\tinnerKey := innerKeySelector(innerItem)\n\t\t\t\tinnerLookup[innerKey] = append(innerLookup[innerKey], innerItem)\n\t\t\t}\n\n\t\t\tvar outerItem interface{}\n\t\t\tvar innerGroup []interface{}\n\t\t\tinnerLen, innerIndex := 0, 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif innerIndex >= innerLen {\n\t\t\t\t\thas := false\n\t\t\t\t\tfor !has {\n\t\t\t\t\t\touterItem, ok = outernext()\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinnerGroup, has = innerLookup[outerKeySelector(outerItem)]\n\t\t\t\t\t\tinnerLen = len(innerGroup)\n\t\t\t\t\t\tinnerIndex = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem = resultSelector(outerItem, innerGroup[innerIndex])\n\t\t\t\tinnerIndex++\n\t\t\t\treturn item, true\n\t\t\t}\n\t\t},\n\t}\n}\n\n// JoinT is the typed version of Join.\n//\n//   - outerKeySelectorFn is of type \"func(TOuter) TKey\"\n//   - innerKeySelectorFn is of type \"func(TInner) TKey\"\n//   - resultSelectorFn is of type \"func(TOuter,TInner) TResult\"\n//\n// NOTE: Join has better performance than JoinT.\nfunc (q Query) JoinT(inner Query,\n\touterKeySelectorFn interface{},\n\tinnerKeySelectorFn interface{},\n\tresultSelectorFn interface{}) Query {\n\touterKeySelectorGenericFunc, err := newGenericFunc(\n\t\t\"JoinT\", \"outerKeySelectorFn\", outerKeySelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\touterKeySelectorFunc := func(item interface{}) interface{} {\n\t\treturn outerKeySelectorGenericFunc.Call(item)\n\t}\n\n\tinnerKeySelectorFuncGenericFunc, err := newGenericFunc(\n\t\t\"JoinT\", \"innerKeySelectorFn\",\n\t\tinnerKeySelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tinnerKeySelectorFunc := func(item interface{}) interface{} {\n\t\treturn innerKeySelectorFuncGenericFunc.Call(item)\n\t}\n\n\tresultSelectorGenericFunc, err := newGenericFunc(\n\t\t\"JoinT\", \"resultSelectorFn\", resultSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tresultSelectorFunc := func(outer interface{}, inner interface{}) interface{} {\n\t\treturn resultSelectorGenericFunc.Call(outer, inner)\n\t}\n\n\treturn q.Join(inner, outerKeySelectorFunc, innerKeySelectorFunc, resultSelectorFunc)\n}\n"
        },
        {
          "name": "join_test.go",
          "type": "blob",
          "size": 1.92578125,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestJoin(t *testing.T) {\n\touter := []int{0, 1, 2, 3, 4, 5, 8}\n\tinner := []int{1, 2, 1, 4, 7, 6, 7, 2}\n\twant := []interface{}{\n\t\tKeyValue{1, 1},\n\t\tKeyValue{1, 1},\n\t\tKeyValue{2, 2},\n\t\tKeyValue{2, 2},\n\t\tKeyValue{4, 4},\n\t}\n\n\tq := From(outer).Join(\n\t\tFrom(inner),\n\t\tfunc(i interface{}) interface{} { return i },\n\t\tfunc(i interface{}) interface{} { return i },\n\t\tfunc(outer interface{}, inner interface{}) interface{} {\n\t\t\treturn KeyValue{outer, inner}\n\t\t})\n\n\tif !validateQuery(q, want) {\n\t\tt.Errorf(\"From().Join()=%v expected %v\", toSlice(q), want)\n\t}\n}\n\nfunc TestJoinT_PanicWhenOuterKeySelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"JoinT: parameter [outerKeySelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{0, 1, 2}).JoinT(\n\t\t\tFrom([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}),\n\t\t\tfunc(i, j int) int { return i },\n\t\t\tfunc(i int) int { return i % 2 },\n\t\t\tfunc(outer int, inner int) KeyValue { return KeyValue{outer, inner} },\n\t\t)\n\t})\n}\n\nfunc TestJoinT_PanicWhenInnerKeySelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"JoinT: parameter [innerKeySelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{0, 1, 2}).JoinT(\n\t\t\tFrom([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}),\n\t\t\tfunc(i int) int { return i },\n\t\t\tfunc(i, j int) int { return i % 2 },\n\t\t\tfunc(outer int, inners []int) KeyValue { return KeyValue{outer, len(inners)} },\n\t\t)\n\t})\n}\n\nfunc TestJoinT_PanicWhenResultSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"JoinT: parameter [resultSelectorFn] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func(int,int,int)linq.KeyValue'\", func() {\n\t\tFrom([]int{0, 1, 2}).JoinT(\n\t\t\tFrom([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}),\n\t\t\tfunc(i int) int { return i },\n\t\t\tfunc(i int) int { return i % 2 },\n\t\t\tfunc(outer int, inner, j int) KeyValue { return KeyValue{outer, inner} },\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "orderby.go",
          "type": "blob",
          "size": 7.619140625,
          "content": "package linq\n\nimport \"sort\"\n\ntype order struct {\n\tselector func(interface{}) interface{}\n\tcompare  comparer\n\tdesc     bool\n}\n\n// OrderedQuery is the type returned from OrderBy, OrderByDescending ThenBy and\n// ThenByDescending functions.\ntype OrderedQuery struct {\n\tQuery\n\toriginal Query\n\torders   []order\n}\n\n// OrderBy sorts the elements of a collection in ascending order. Elements are\n// sorted according to a key.\nfunc (q Query) OrderBy(selector func(interface{}) interface{}) OrderedQuery {\n\treturn OrderedQuery{\n\t\torders:   []order{{selector: selector}},\n\t\toriginal: q,\n\t\tQuery: Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\titems := q.sort([]order{{selector: selector}})\n\t\t\t\tlen := len(items)\n\t\t\t\tindex := 0\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tok = index < len\n\t\t\t\t\tif ok {\n\t\t\t\t\t\titem = items[index]\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\n// OrderByT is the typed version of OrderBy.\n//\n//   - selectorFn is of type \"func(TSource) TKey\"\n//\n// NOTE: OrderBy has better performance than OrderByT.\nfunc (q Query) OrderByT(selectorFn interface{}) OrderedQuery {\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"OrderByT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(item interface{}) interface{} {\n\t\treturn selectorGenericFunc.Call(item)\n\t}\n\n\treturn q.OrderBy(selectorFunc)\n}\n\n// OrderByDescending sorts the elements of a collection in descending order.\n// Elements are sorted according to a key.\nfunc (q Query) OrderByDescending(selector func(interface{}) interface{}) OrderedQuery {\n\treturn OrderedQuery{\n\t\torders:   []order{{selector: selector, desc: true}},\n\t\toriginal: q,\n\t\tQuery: Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\titems := q.sort([]order{{selector: selector, desc: true}})\n\t\t\t\tlen := len(items)\n\t\t\t\tindex := 0\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tok = index < len\n\t\t\t\t\tif ok {\n\t\t\t\t\t\titem = items[index]\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\n// OrderByDescendingT is the typed version of OrderByDescending.\n//   - selectorFn is of type \"func(TSource) TKey\"\n// NOTE: OrderByDescending has better performance than OrderByDescendingT.\nfunc (q Query) OrderByDescendingT(selectorFn interface{}) OrderedQuery {\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"OrderByDescendingT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(item interface{}) interface{} {\n\t\treturn selectorGenericFunc.Call(item)\n\t}\n\n\treturn q.OrderByDescending(selectorFunc)\n}\n\n// ThenBy performs a subsequent ordering of the elements in a collection in\n// ascending order. This method enables you to specify multiple sort criteria by\n// applying any number of ThenBy or ThenByDescending methods.\nfunc (oq OrderedQuery) ThenBy(\n\tselector func(interface{}) interface{}) OrderedQuery {\n\treturn OrderedQuery{\n\t\torders:   append(oq.orders, order{selector: selector}),\n\t\toriginal: oq.original,\n\t\tQuery: Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\titems := oq.original.sort(append(oq.orders, order{selector: selector}))\n\t\t\t\tlen := len(items)\n\t\t\t\tindex := 0\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tok = index < len\n\t\t\t\t\tif ok {\n\t\t\t\t\t\titem = items[index]\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\n// ThenByT is the typed version of ThenBy.\n//   - selectorFn is of type \"func(TSource) TKey\"\n// NOTE: ThenBy has better performance than ThenByT.\nfunc (oq OrderedQuery) ThenByT(selectorFn interface{}) OrderedQuery {\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"ThenByT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(item interface{}) interface{} {\n\t\treturn selectorGenericFunc.Call(item)\n\t}\n\n\treturn oq.ThenBy(selectorFunc)\n}\n\n// ThenByDescending performs a subsequent ordering of the elements in a\n// collection in descending order. This method enables you to specify multiple\n// sort criteria by applying any number of ThenBy or ThenByDescending methods.\nfunc (oq OrderedQuery) ThenByDescending(selector func(interface{}) interface{}) OrderedQuery {\n\treturn OrderedQuery{\n\t\torders:   append(oq.orders, order{selector: selector, desc: true}),\n\t\toriginal: oq.original,\n\t\tQuery: Query{\n\t\t\tIterate: func() Iterator {\n\t\t\t\titems := oq.original.sort(append(oq.orders, order{selector: selector, desc: true}))\n\t\t\t\tlen := len(items)\n\t\t\t\tindex := 0\n\n\t\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\t\tok = index < len\n\t\t\t\t\tif ok {\n\t\t\t\t\t\titem = items[index]\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\n// ThenByDescendingT is the typed version of ThenByDescending.\n//   - selectorFn is of type \"func(TSource) TKey\"\n// NOTE: ThenByDescending has better performance than ThenByDescendingT.\nfunc (oq OrderedQuery) ThenByDescendingT(selectorFn interface{}) OrderedQuery {\n\tselectorFunc, ok := selectorFn.(func(interface{}) interface{})\n\tif !ok {\n\t\tselectorGenericFunc, err := newGenericFunc(\n\t\t\t\"ThenByDescending\", \"selectorFn\", selectorFn,\n\t\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t\t)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tselectorFunc = func(item interface{}) interface{} {\n\t\t\treturn selectorGenericFunc.Call(item)\n\t\t}\n\t}\n\treturn oq.ThenByDescending(selectorFunc)\n}\n\n// Sort returns a new query by sorting elements with provided less function in\n// ascending order. The comparer function should return true if the parameter i\n// is less than j. While this method is uglier than chaining OrderBy,\n// OrderByDescending, ThenBy and ThenByDescending methods, it's performance is\n// much better.\nfunc (q Query) Sort(less func(i, j interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\titems := q.lessSort(less)\n\t\t\tlen := len(items)\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tok = index < len\n\t\t\t\tif ok {\n\t\t\t\t\titem = items[index]\n\t\t\t\t\tindex++\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SortT is the typed version of Sort.\n//   - lessFn is of type \"func(TSource,TSource) bool\"\n// NOTE: Sort has better performance than SortT.\nfunc (q Query) SortT(lessFn interface{}) Query {\n\tlessGenericFunc, err := newGenericFunc(\n\t\t\"SortT\", \"lessFn\", lessFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tlessFunc := func(i, j interface{}) bool {\n\t\treturn lessGenericFunc.Call(i, j).(bool)\n\t}\n\n\treturn q.Sort(lessFunc)\n}\n\ntype sorter struct {\n\titems []interface{}\n\tless  func(i, j interface{}) bool\n}\n\nfunc (s sorter) Len() int {\n\treturn len(s.items)\n}\n\nfunc (s sorter) Swap(i, j int) {\n\ts.items[i], s.items[j] = s.items[j], s.items[i]\n}\n\nfunc (s sorter) Less(i, j int) bool {\n\treturn s.less(s.items[i], s.items[j])\n}\n\nfunc (q Query) sort(orders []order) (r []interface{}) {\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tr = append(r, item)\n\t}\n\n\tif len(r) == 0 {\n\t\treturn\n\t}\n\n\tfor i, j := range orders {\n\t\torders[i].compare = getComparer(j.selector(r[0]))\n\t}\n\n\ts := sorter{\n\t\titems: r,\n\t\tless: func(i, j interface{}) bool {\n\t\t\tfor _, order := range orders {\n\t\t\t\tx, y := order.selector(i), order.selector(j)\n\t\t\t\tswitch order.compare(x, y) {\n\t\t\t\tcase 0:\n\t\t\t\t\tcontinue\n\t\t\t\tcase -1:\n\t\t\t\t\treturn !order.desc\n\t\t\t\tdefault:\n\t\t\t\t\treturn order.desc\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false\n\t\t}}\n\n\tsort.Sort(s)\n\treturn\n}\n\nfunc (q Query) lessSort(less func(i, j interface{}) bool) (r []interface{}) {\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tr = append(r, item)\n\t}\n\n\ts := sorter{items: r, less: less}\n\n\tsort.Sort(s)\n\treturn\n}\n"
        },
        {
          "name": "orderby_test.go",
          "type": "blob",
          "size": 4.046875,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestEmpty(t *testing.T) {\n\tq := From([]string{}).OrderBy(func(in interface{}) interface{} {\n\t\treturn 0\n\t})\n\n\t_, ok := q.Iterate()()\n\tif ok {\n\t\tt.Errorf(\"Iterator for empty collection must return ok=false\")\n\t}\n}\n\nfunc TestOrderBy(t *testing.T) {\n\tslice := make([]foo, 100)\n\n\tfor i := len(slice) - 1; i >= 0; i-- {\n\t\tslice[i].f1 = i\n\t}\n\n\tq := From(slice).OrderBy(func(i interface{}) interface{} {\n\t\treturn i.(foo).f1\n\t})\n\n\tj := 0\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif item.(foo).f1 != j {\n\t\t\tt.Errorf(\"OrderBy()[%v]=%v expected %v\", j, item, foo{f1: j})\n\t\t}\n\n\t\tj++\n\t}\n}\n\nfunc TestOrderByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"OrderByT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).OrderByT(func(item, j int) int { return item + 2 })\n\t})\n}\n\nfunc TestOrderByDescending(t *testing.T) {\n\tslice := make([]foo, 100)\n\n\tfor i := 0; i < len(slice); i++ {\n\t\tslice[i].f1 = i\n\t}\n\n\tq := From(slice).OrderByDescending(func(i interface{}) interface{} {\n\t\treturn i.(foo).f1\n\t})\n\n\tj := len(slice) - 1\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif item.(foo).f1 != j {\n\t\t\tt.Errorf(\"OrderByDescending()[%v]=%v expected %v\", j, item, foo{f1: j})\n\t\t}\n\n\t\tj--\n\t}\n}\n\nfunc TestOrderByDescendingT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"OrderByDescendingT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).OrderByDescendingT(func(item, j int) int { return item + 2 })\n\t})\n}\n\nfunc TestThenBy(t *testing.T) {\n\tslice := make([]foo, 1000)\n\n\tfor i := len(slice) - 1; i >= 0; i-- {\n\t\tslice[i].f1 = i\n\t\tslice[i].f2 = i%2 == 0\n\t}\n\n\tq := From(slice).OrderBy(func(i interface{}) interface{} {\n\t\treturn i.(foo).f2\n\t}).ThenBy(func(i interface{}) interface{} {\n\t\treturn i.(foo).f1\n\t})\n\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif item.(foo).f2 != (item.(foo).f1%2 == 0) {\n\t\t\tt.Errorf(\"OrderBy().ThenBy()=%v\", item)\n\t\t}\n\t}\n}\n\nfunc TestThenByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ThenByT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)bool'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).\n\t\t\tOrderByT(func(item int) int { return item }).\n\t\t\tThenByT(func(item, j int) bool { return true })\n\t})\n}\n\nfunc TestThenByDescending(t *testing.T) {\n\tslice := make([]foo, 1000)\n\n\tfor i := len(slice) - 1; i >= 0; i-- {\n\t\tslice[i].f1 = i\n\t\tslice[i].f2 = i%2 == 0\n\t}\n\n\tq := From(slice).OrderBy(func(i interface{}) interface{} {\n\t\treturn i.(foo).f2\n\t}).ThenByDescending(func(i interface{}) interface{} {\n\t\treturn i.(foo).f1\n\t})\n\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif item.(foo).f2 != (item.(foo).f1%2 == 0) {\n\t\t\tt.Errorf(\"OrderBy().ThenByDescending()=%v\", item)\n\t\t}\n\t}\n}\n\nfunc TestThenByDescendingT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ThenByDescending: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)bool'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).\n\t\t\tOrderByT(func(item int) int { return item }).\n\t\t\tThenByDescendingT(func(item, j int) bool { return true })\n\t})\n}\n\nfunc TestSort(t *testing.T) {\n\tslice := make([]foo, 100)\n\n\tfor i := len(slice) - 1; i >= 0; i-- {\n\t\tslice[i].f1 = i\n\t}\n\n\tq := From(slice).Sort(func(i, j interface{}) bool {\n\t\treturn i.(foo).f1 < j.(foo).f1\n\t})\n\n\tj := 0\n\tnext := q.Iterate()\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif item.(foo).f1 != j {\n\t\t\tt.Errorf(\"Sort()[%v]=%v expected %v\", j, item, foo{f1: j})\n\t\t}\n\n\t\tj++\n\t}\n}\n\nfunc TestSortT_PanicWhenLessFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SortT: parameter [lessFn] has a invalid function signature. Expected: 'func(T,T)bool', actual: 'func(int,int)string'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SortT(func(i, j int) string { return \"\" })\n\t})\n}\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 15.4716796875,
          "content": "package linq\n\nimport (\n\t\"math\"\n\t\"reflect\"\n)\n\n// All determines whether all elements of a collection satisfy a condition.\nfunc (q Query) All(predicate func(interface{}) bool) bool {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif !predicate(item) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// AllT is the typed version of All.\n//\n//   - predicateFn is of type \"func(TSource) bool\"\n//\n// NOTE: All has better performance than AllT.\nfunc (q Query) AllT(predicateFn interface{}) bool {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"AllT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.All(predicateFunc)\n}\n\n// Any determines whether any element of a collection exists.\nfunc (q Query) Any() bool {\n\t_, ok := q.Iterate()()\n\treturn ok\n}\n\n// AnyWith determines whether any element of a collection satisfies a condition.\nfunc (q Query) AnyWith(predicate func(interface{}) bool) bool {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif predicate(item) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// AnyWithT is the typed version of AnyWith.\n//\n//   - predicateFn is of type \"func(TSource) bool\"\n//\n// NOTE: AnyWith has better performance than AnyWithT.\nfunc (q Query) AnyWithT(predicateFn interface{}) bool {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"AnyWithT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.AnyWith(predicateFunc)\n}\n\n// Average computes the average of a collection of numeric values.\nfunc (q Query) Average() (r float64) {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn math.NaN()\n\t}\n\n\tn := 1\n\tswitch item.(type) {\n\tcase int, int8, int16, int32, int64:\n\t\tconv := getIntConverter(item)\n\t\tsum := conv(item)\n\n\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\tsum += conv(item)\n\t\t\tn++\n\t\t}\n\n\t\tr = float64(sum)\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\tconv := getUIntConverter(item)\n\t\tsum := conv(item)\n\n\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\tsum += conv(item)\n\t\t\tn++\n\t\t}\n\n\t\tr = float64(sum)\n\tdefault:\n\t\tconv := getFloatConverter(item)\n\t\tr = conv(item)\n\n\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\tr += conv(item)\n\t\t\tn++\n\t\t}\n\t}\n\n\treturn r / float64(n)\n}\n\n// Contains determines whether a collection contains a specified element.\nfunc (q Query) Contains(value interface{}) bool {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif item == value {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Count returns the number of elements in a collection.\nfunc (q Query) Count() (r int) {\n\tnext := q.Iterate()\n\n\tfor _, ok := next(); ok; _, ok = next() {\n\t\tr++\n\t}\n\n\treturn\n}\n\n// CountWith returns a number that represents how many elements in the specified\n// collection satisfy a condition.\nfunc (q Query) CountWith(predicate func(interface{}) bool) (r int) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif predicate(item) {\n\t\t\tr++\n\t\t}\n\t}\n\n\treturn\n}\n\n// CountWithT is the typed version of CountWith.\n//\n//   - predicateFn is of type \"func(TSource) bool\"\n//\n// NOTE: CountWith has better performance than CountWithT.\nfunc (q Query) CountWithT(predicateFn interface{}) int {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"CountWithT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.CountWith(predicateFunc)\n}\n\n// First returns the first element of a collection.\nfunc (q Query) First() interface{} {\n\titem, _ := q.Iterate()()\n\treturn item\n}\n\n// FirstWith returns the first element of a collection that satisfies a\n// specified condition.\nfunc (q Query) FirstWith(predicate func(interface{}) bool) interface{} {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif predicate(item) {\n\t\t\treturn item\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// FirstWithT is the typed version of FirstWith.\n//\n//   - predicateFn is of type \"func(TSource) bool\"\n//\n// NOTE: FirstWith has better performance than FirstWithT.\nfunc (q Query) FirstWithT(predicateFn interface{}) interface{} {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"FirstWithT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.FirstWith(predicateFunc)\n}\n\n// ForEach performs the specified action on each element of a collection.\nfunc (q Query) ForEach(action func(interface{})) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\taction(item)\n\t}\n}\n\n// ForEachT is the typed version of ForEach.\n//\n//   - actionFn is of type \"func(TSource)\"\n//\n// NOTE: ForEach has better performance than ForEachT.\nfunc (q Query) ForEachT(actionFn interface{}) {\n\tactionGenericFunc, err := newGenericFunc(\n\t\t\"ForEachT\", \"actionFn\", actionFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), nil),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tactionFunc := func(item interface{}) {\n\t\tactionGenericFunc.Call(item)\n\t}\n\n\tq.ForEach(actionFunc)\n}\n\n// ForEachIndexed performs the specified action on each element of a collection.\n//\n// The first argument to action represents the zero-based index of that\n// element in the source collection. This can be useful if the elements are in a\n// known order and you want to do something with an element at a particular\n// index, for example. It can also be useful if you want to retrieve the index\n// of one or more elements. The second argument to action represents the\n// element to process.\nfunc (q Query) ForEachIndexed(action func(int, interface{})) {\n\tnext := q.Iterate()\n\tindex := 0\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\taction(index, item)\n\t\tindex++\n\t}\n}\n\n// ForEachIndexedT is the typed version of ForEachIndexed.\n//\n//   - actionFn is of type \"func(int, TSource)\"\n//\n// NOTE: ForEachIndexed has better performance than ForEachIndexedT.\nfunc (q Query) ForEachIndexedT(actionFn interface{}) {\n\tactionGenericFunc, err := newGenericFunc(\n\t\t\"ForEachIndexedT\", \"actionFn\", actionFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), nil),\n\t)\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tactionFunc := func(index int, item interface{}) {\n\t\tactionGenericFunc.Call(index, item)\n\t}\n\n\tq.ForEachIndexed(actionFunc)\n}\n\n// Last returns the last element of a collection.\nfunc (q Query) Last() (r interface{}) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tr = item\n\t}\n\n\treturn\n}\n\n// LastWith returns the last element of a collection that satisfies a specified\n// condition.\nfunc (q Query) LastWith(predicate func(interface{}) bool) (r interface{}) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif predicate(item) {\n\t\t\tr = item\n\t\t}\n\t}\n\n\treturn\n}\n\n// LastWithT is the typed version of LastWith.\n//\n//   - predicateFn is of type \"func(TSource) bool\"\n//\n// NOTE: LastWith has better performance than LastWithT.\nfunc (q Query) LastWithT(predicateFn interface{}) interface{} {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"LastWithT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.LastWith(predicateFunc)\n}\n\n// Max returns the maximum value in a collection of values.\nfunc (q Query) Max() (r interface{}) {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tcompare := getComparer(item)\n\tr = item\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif compare(item, r) > 0 {\n\t\t\tr = item\n\t\t}\n\t}\n\n\treturn\n}\n\n// Min returns the minimum value in a collection of values.\nfunc (q Query) Min() (r interface{}) {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tcompare := getComparer(item)\n\tr = item\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif compare(item, r) < 0 {\n\t\t\tr = item\n\t\t}\n\t}\n\n\treturn\n}\n\n// Results iterates over a collection and returnes slice of interfaces\nfunc (q Query) Results() (r []interface{}) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tr = append(r, item)\n\t}\n\n\treturn\n}\n\n// SequenceEqual determines whether two collections are equal.\nfunc (q Query) SequenceEqual(q2 Query) bool {\n\tnext := q.Iterate()\n\tnext2 := q2.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\titem2, ok2 := next2()\n\t\tif !ok2 || item != item2 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t_, ok2 := next2()\n\treturn !ok2\n}\n\n// Single returns the only element of a collection, and nil if there is not\n// exactly one element in the collection.\nfunc (q Query) Single() interface{} {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\t_, ok = next()\n\tif ok {\n\t\treturn nil\n\t}\n\n\treturn item\n}\n\n// SingleWith returns the only element of a collection that satisfies a\n// specified condition, and nil if more than one such element exists.\nfunc (q Query) SingleWith(predicate func(interface{}) bool) (r interface{}) {\n\tnext := q.Iterate()\n\tfound := false\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif predicate(item) {\n\t\t\tif found {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tfound = true\n\t\t\tr = item\n\t\t}\n\t}\n\n\treturn\n}\n\n// SingleWithT is the typed version of SingleWith.\n//\n//   - predicateFn is of type \"func(TSource) bool\"\n//\n// NOTE: SingleWith has better performance than SingleWithT.\nfunc (q Query) SingleWithT(predicateFn interface{}) interface{} {\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"SingleWithT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.SingleWith(predicateFunc)\n}\n\n// SumInts computes the sum of a collection of numeric values.\n//\n// Values can be of any integer type: int, int8, int16, int32, int64. The result\n// is int64. Method returns zero if collection contains no elements.\nfunc (q Query) SumInts() (r int64) {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn 0\n\t}\n\n\tconv := getIntConverter(item)\n\tr = conv(item)\n\n\tfor item, ok = next(); ok; item, ok = next() {\n\t\tr += conv(item)\n\t}\n\n\treturn\n}\n\n// SumUInts computes the sum of a collection of numeric values.\n//\n// Values can be of any unsigned integer type: uint, uint8, uint16, uint32,\n// uint64. The result is uint64. Method returns zero if collection contains no\n// elements.\nfunc (q Query) SumUInts() (r uint64) {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn 0\n\t}\n\n\tconv := getUIntConverter(item)\n\tr = conv(item)\n\n\tfor item, ok = next(); ok; item, ok = next() {\n\t\tr += conv(item)\n\t}\n\n\treturn\n}\n\n// SumFloats computes the sum of a collection of numeric values.\n//\n// Values can be of any float type: float32 or float64. The result is float64.\n// Method returns zero if collection contains no elements.\nfunc (q Query) SumFloats() (r float64) {\n\tnext := q.Iterate()\n\titem, ok := next()\n\tif !ok {\n\t\treturn 0\n\t}\n\n\tconv := getFloatConverter(item)\n\tr = conv(item)\n\n\tfor item, ok = next(); ok; item, ok = next() {\n\t\tr += conv(item)\n\t}\n\n\treturn\n}\n\n// ToChannel iterates over a collection and outputs each element to a channel,\n// then closes it.\nfunc (q Query) ToChannel(result chan<- interface{}) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tresult <- item\n\t}\n\n\tclose(result)\n}\n\n// ToChannelT is the typed version of ToChannel.\n//\n//   - result is of type \"chan TSource\"\n//\n// NOTE: ToChannel has better performance than ToChannelT.\nfunc (q Query) ToChannelT(result interface{}) {\n\tr := reflect.ValueOf(result)\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tr.Send(reflect.ValueOf(item))\n\t}\n\n\tr.Close()\n}\n\n// ToMap iterates over a collection and populates result map with elements.\n// Collection elements have to be of KeyValue type to use this method. To\n// populate a map with elements of different type use ToMapBy method. ToMap\n// doesn't empty the result map before populating it.\nfunc (q Query) ToMap(result interface{}) {\n\tq.ToMapBy(\n\t\tresult,\n\t\tfunc(i interface{}) interface{} {\n\t\t\treturn i.(KeyValue).Key\n\t\t},\n\t\tfunc(i interface{}) interface{} {\n\t\t\treturn i.(KeyValue).Value\n\t\t})\n}\n\n// ToMapBy iterates over a collection and populates the result map with\n// elements. Functions keySelector and valueSelector are executed for each\n// element of the collection to generate key and value for the map. Generated\n// key and value types must be assignable to the map's key and value types.\n// ToMapBy doesn't empty the result map before populating it.\nfunc (q Query) ToMapBy(result interface{},\n\tkeySelector func(interface{}) interface{},\n\tvalueSelector func(interface{}) interface{}) {\n\tres := reflect.ValueOf(result)\n\tm := reflect.Indirect(res)\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tkey := reflect.ValueOf(keySelector(item))\n\t\tvalue := reflect.ValueOf(valueSelector(item))\n\n\t\tm.SetMapIndex(key, value)\n\t}\n\n\tres.Elem().Set(m)\n}\n\n// ToMapByT is the typed version of ToMapBy.\n//\n//   - keySelectorFn is of type \"func(TSource)TKey\"\n//   - valueSelectorFn is of type \"func(TSource)TValue\"\n//\n// NOTE: ToMapBy has better performance than ToMapByT.\nfunc (q Query) ToMapByT(result interface{},\n\tkeySelectorFn interface{}, valueSelectorFn interface{}) {\n\tkeySelectorGenericFunc, err := newGenericFunc(\n\t\t\"ToMapByT\", \"keySelectorFn\", keySelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tkeySelectorFunc := func(item interface{}) interface{} {\n\t\treturn keySelectorGenericFunc.Call(item)\n\t}\n\n\tvalueSelectorGenericFunc, err := newGenericFunc(\n\t\t\"ToMapByT\", \"valueSelectorFn\", valueSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvalueSelectorFunc := func(item interface{}) interface{} {\n\t\treturn valueSelectorGenericFunc.Call(item)\n\t}\n\n\tq.ToMapBy(result, keySelectorFunc, valueSelectorFunc)\n}\n\n// ToSlice iterates over a collection and saves the results in the slice pointed\n// by v. It overwrites the existing slice, starting from index 0.\n//\n// If the slice pointed by v has sufficient capacity, v will be pointed to a\n// resliced slice. If it does not, a new underlying array will be allocated and\n// v will point to it.\nfunc (q Query) ToSlice(v interface{}) {\n\tres := reflect.ValueOf(v)\n\tslice := reflect.Indirect(res)\n\n\tcap := slice.Cap()\n\tres.Elem().Set(slice.Slice(0, cap)) // make len(slice)==cap(slice) from now on\n\n\tnext := q.Iterate()\n\tindex := 0\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tif index >= cap {\n\t\t\tslice, cap = grow(slice)\n\t\t}\n\t\tslice.Index(index).Set(reflect.ValueOf(item))\n\t\tindex++\n\t}\n\n\t// reslice the len(res)==cap(res) actual res size\n\tres.Elem().Set(slice.Slice(0, index))\n}\n\n// grow grows the slice s by doubling its capacity, then it returns the new\n// slice (resliced to its full capacity) and the new capacity.\nfunc grow(s reflect.Value) (v reflect.Value, newCap int) {\n\tcap := s.Cap()\n\tif cap == 0 {\n\t\tcap = 1\n\t} else {\n\t\tcap *= 2\n\t}\n\tnewSlice := reflect.MakeSlice(s.Type(), cap, cap)\n\treflect.Copy(newSlice, s)\n\treturn newSlice, cap\n}\n"
        },
        {
          "name": "result_test.go",
          "type": "blob",
          "size": 15.1142578125,
          "content": "package linq\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\t\"unsafe\"\n)\n\nfunc TestAll(t *testing.T) {\n\tinput := []int{2, 4, 6, 8}\n\n\tr1 := From(input).All(func(i interface{}) bool {\n\t\treturn i.(int)%2 == 0\n\t})\n\tr2 := From(input).All(func(i interface{}) bool {\n\t\treturn i.(int)%2 != 0\n\t})\n\n\tif !r1 {\n\t\tt.Errorf(\"From(%v).All()=%v\", input, r1)\n\t}\n\n\tif r2 {\n\t\tt.Errorf(\"From(%v).All()=%v\", input, r2)\n\t}\n}\n\nfunc TestAllT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"AllT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).AllT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestAny(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  bool\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, true},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, true},\n\t\t{\"sstr\", true},\n\t\t{[]int{}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Any(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Any()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestAnyWith(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  bool\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, false},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, true},\n\t\t{[]int{}, false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).AnyWith(func(i interface{}) bool {\n\t\t\treturn i.(int) == 4\n\t\t}); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Any()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestAnyWithT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"AnyWithT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).AnyWithT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestAverage(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  float64\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 1.8},\n\t\t{[5]uint{1, 2, 5, 7, 10}, 5.},\n\t\t{[]float32{1., 1.}, 1.},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Average(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Average()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestAverageForNaN(t *testing.T) {\n\tif r := From([]int{}).Average(); !math.IsNaN(r) {\n\t\tt.Errorf(\"From([]int{}).Average()=%v expected %v\", r, math.NaN())\n\t}\n}\n\nfunc TestContains(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\tvalue interface{}\n\t\twant  bool\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 10, false},\n\t\t{[5]uint{1, 2, 5, 7, 10}, uint(5), true},\n\t\t{[]float32{}, 1., false},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Contains(test.value); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Contains(%v)=%v expected %v\", test.input, test.value, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestCount(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  int\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 5},\n\t\t{[7]uint{1, 2, 5, 7, 10, 12, 15}, 7},\n\t\t{[]float32{}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Count(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Count()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestCountWith(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  int\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 4},\n\t\t{[]int{}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).CountWith(func(i interface{}) bool {\n\t\t\treturn i.(int) <= 2\n\t\t}); r != test.want {\n\t\t\tt.Errorf(\"From(%v).CountWith()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestCountWithT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"CountWithT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).CountWithT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestFirst(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 1},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).First(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).First()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestFirstWith(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 3},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).FirstWith(func(i interface{}) bool {\n\t\t\treturn i.(int) > 2\n\t\t}); r != test.want {\n\t\t\tt.Errorf(\"From(%v).FirstWith()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestFirstWithT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"FirstWithT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).FirstWithT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestForEach(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[5]int{1, 2, 2, 35, 111}, []int{2, 4, 4, 70, 222}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput := []int{}\n\t\tFrom(test.input).ForEach(func(item interface{}) {\n\t\t\toutput = append(output, item.(int)*2)\n\t\t})\n\n\t\tif !reflect.DeepEqual(output, test.want) {\n\t\t\tt.Fatalf(\"From(%#v).ForEach()=%#v expected=%#v\", test.input, output, test.want)\n\t\t}\n\t}\n}\n\nfunc TestForEachT_PanicWhenActionFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ForEachT: parameter [actionFn] has a invalid function signature. Expected: 'func(T)', actual: 'func(int,int)'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).ForEachT(func(item, idx int) { item = item + 2 })\n\t})\n}\n\nfunc TestForEachIndexed(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[5]int{1, 2, 2, 35, 111}, []int{1, 3, 4, 38, 115}},\n\t\t{[]int{}, []int{}},\n\t}\n\n\tfor _, test := range tests {\n\t\toutput := []int{}\n\t\tFrom(test.input).ForEachIndexed(func(index int, item interface{}) {\n\t\t\toutput = append(output, item.(int)+index)\n\t\t})\n\n\t\tif !reflect.DeepEqual(output, test.want) {\n\t\t\tt.Fatalf(\"From(%#v).ForEachIndexed()=%#v expected=%#v\", test.input, output, test.want)\n\t\t}\n\t}\n}\n\nfunc TestForEachIndexedT_PanicWhenActionFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ForEachIndexedT: parameter [actionFn] has a invalid function signature. Expected: 'func(int,T)', actual: 'func(int)'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).ForEachIndexedT(func(item int) { item = item + 2 })\n\t})\n}\n\nfunc TestLast(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 1},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Last(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Last()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestLastWith(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1, 4, 2, 5, 1, 1}, 5},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).LastWith(func(i interface{}) bool {\n\t\t\treturn i.(int) > 2\n\t\t}); r != test.want {\n\t\t\tt.Errorf(\"From(%v).LastWith()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestLastWithT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"LastWithT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).LastWithT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestMax(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 3},\n\t\t{[]int{1}, 1},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Max(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Max()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestMin(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 0}, 0},\n\t\t{[]int{1}, 1},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Min(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Min()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestResults(t *testing.T) {\n\tinput := []int{1, 2, 3}\n\twant := []interface{}{1, 2, 3}\n\n\tif r := From(input).Results(); !reflect.DeepEqual(r, want) {\n\t\tt.Errorf(\"From(%v).Raw()=%v expected %v\", input, r, want)\n\t}\n}\n\nfunc TestSequenceEqual(t *testing.T) {\n\ttests := []struct {\n\t\tinput  interface{}\n\t\tinput2 interface{}\n\t\twant   bool\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, []int{4, 6}, false},\n\t\t{[]int{1, -1, 100}, []int{1, -1, 100}, true},\n\t\t{[]int{}, []int{}, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).SequenceEqual(From(test.input2)); r != test.want {\n\t\t\tt.Errorf(\"From(%v).SequenceEqual(%v)=%v expected %v\", test.input, test.input2, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestSingle(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, nil},\n\t\t{[]int{1}, 1},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).Single(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).Single()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestSingleWith(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 3},\n\t\t{[]int{1, 1, 1}, nil},\n\t\t{[]int{5, 1, 1, 10, 2, 2}, nil},\n\t\t{[]int{}, nil},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).SingleWith(func(i interface{}) bool {\n\t\t\treturn i.(int) > 2\n\t\t}); r != test.want {\n\t\t\tt.Errorf(\"From(%v).SingleWith()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestSingleWithT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SingleWithT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SingleWithT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestSumInts(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  int64\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, 9},\n\t\t{[]int{1}, 1},\n\t\t{[]int{}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).SumInts(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).SumInts()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestSumUInts(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  uint64\n\t}{\n\t\t{[]uint{1, 2, 2, 3, 1}, 9},\n\t\t{[]uint{1}, 1},\n\t\t{[]uint{}, 0},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).SumUInts(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).SumInts()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestSumFloats(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  float64\n\t}{\n\t\t{[]float32{1., 2., 2., 3., 1.}, 9.},\n\t\t{[]float64{1.}, 1.},\n\t\t{[]float32{}, 0.},\n\t}\n\n\tfor _, test := range tests {\n\t\tif r := From(test.input).SumFloats(); r != test.want {\n\t\t\tt.Errorf(\"From(%v).SumFloats()=%v expected %v\", test.input, r, test.want)\n\t\t}\n\t}\n}\n\nfunc TestToChannel(t *testing.T) {\n\tc := make(chan interface{})\n\tinput := []int{1, 2, 3, 4, 5}\n\n\tgo func() {\n\t\tFrom(input).ToChannel(c)\n\t}()\n\n\tresult := []int{}\n\tfor value := range c {\n\t\tresult = append(result, value.(int))\n\t}\n\n\tif !reflect.DeepEqual(result, input) {\n\t\tt.Errorf(\"From(%v).ToChannel()=%v expected %v\", input, result, input)\n\t}\n}\n\nfunc TestToChannelT(t *testing.T) {\n\tc := make(chan string)\n\tinput := []string{\"1\", \"2\", \"3\", \"4\", \"5\"}\n\n\tgo From(input).ToChannelT(c)\n\n\tresult := []string{}\n\tfor value := range c {\n\t\tresult = append(result, value)\n\t}\n\n\tif !reflect.DeepEqual(result, input) {\n\t\tt.Errorf(\"From(%v).ToChannelT()=%v expected %v\", input, result, input)\n\t}\n}\n\nfunc TestToMap(t *testing.T) {\n\tinput := make(map[int]bool)\n\tinput[1] = true\n\tinput[2] = false\n\tinput[3] = true\n\n\tresult := make(map[int]bool)\n\tFrom(input).ToMap(&result)\n\n\tif !reflect.DeepEqual(result, input) {\n\t\tt.Errorf(\"From(%v).ToMap()=%v expected %v\", input, result, input)\n\t}\n}\n\nfunc TestToMapBy(t *testing.T) {\n\tinput := make(map[int]bool)\n\tinput[1] = true\n\tinput[2] = false\n\tinput[3] = true\n\n\tresult := make(map[int]bool)\n\tFrom(input).ToMapBy(&result,\n\t\tfunc(i interface{}) interface{} {\n\t\t\treturn i.(KeyValue).Key\n\t\t},\n\t\tfunc(i interface{}) interface{} {\n\t\t\treturn i.(KeyValue).Value\n\t\t})\n\n\tif !reflect.DeepEqual(result, input) {\n\t\tt.Errorf(\"From(%v).ToMapBy()=%v expected %v\", input, result, input)\n\t}\n}\n\nfunc TestToMapByT_PanicWhenKeySelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ToMapByT: parameter [keySelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tresult := make(map[int]bool)\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).ToMapByT(\n\t\t\t&result,\n\t\t\tfunc(item, j int) int { return item + 2 },\n\t\t\tfunc(item int) int { return item + 2 },\n\t\t)\n\t})\n}\n\nfunc TestToMapByT_PanicWhenValueSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ToMapByT: parameter [valueSelectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tresult := make(map[int]bool)\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).ToMapByT(\n\t\t\t&result,\n\t\t\tfunc(item int) int { return item + 2 },\n\t\t\tfunc(item, j int) int { return item + 2 },\n\t\t)\n\t})\n}\n\nfunc TestToSlice(t *testing.T) {\n\ttests := []struct {\n\t\tinput             []int\n\t\toutput            []int\n\t\twant              []int\n\t\twantedOutputCap   int\n\t\toutputIsANewSlice bool\n\t}{\n\t\t// output is nil slice\n\t\t{\n\t\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\tnil,\n\t\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\t16,\n\t\t\ttrue},\n\t\t// output is empty slice (cap=0)\n\t\t{\n\t\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\t[]int{},\n\t\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t\t16,\n\t\t\ttrue},\n\t\t// ToSlice() overwrites existing elements and reslices.\n\t\t{[]int{1, 2, 3},\n\t\t\t[]int{99, 98, 97, 96, 95},\n\t\t\t[]int{1, 2, 3},\n\t\t\t5,\n\t\t\tfalse},\n\t\t// cap(out)>len(result): we get the same slice, resliced. cap unchanged.\n\t\t{[]int{1, 2, 3, 4, 5},\n\t\t\tmake([]int, 0, 11),\n\t\t\t[]int{1, 2, 3, 4, 5},\n\t\t\t11,\n\t\t\tfalse},\n\t\t// cap(out)==len(result): we get the same slice, cap unchanged.\n\t\t{[]int{1, 2, 3, 4, 5},\n\t\t\tmake([]int, 0, 5),\n\t\t\t[]int{1, 2, 3, 4, 5},\n\t\t\t5,\n\t\t\tfalse},\n\t\t// cap(out)<len(result): we get a new slice with len(out)=len(result) and cap doubled: cap(out')==2*cap(out)\n\t\t{[]int{1, 2, 3, 4, 5},\n\t\t\tmake([]int, 0, 4),\n\t\t\t[]int{1, 2, 3, 4, 5},\n\t\t\t8,\n\t\t\ttrue},\n\t\t// cap(out)<<len(result): trigger capacity to double more than once (26 -> 52 -> 104)\n\t\t{make([]int, 100),\n\t\t\tmake([]int, 0, 26),\n\t\t\tmake([]int, 100),\n\t\t\t104,\n\t\t\ttrue},\n\t\t// len(out) > len(result): we get the same slice with len(out)=len(result) and cap unchanged: cap(out')==cap(out)\n\t\t{[]int{1, 2, 3, 4, 5},\n\t\t\tmake([]int, 0, 50),\n\t\t\t[]int{1, 2, 3, 4, 5},\n\t\t\t50,\n\t\t\tfalse},\n\t}\n\n\tfor c, test := range tests {\n\t\tinitialOutputValue := test.output\n\t\tFrom(test.input).ToSlice(&test.output)\n\t\tmodifiedOutputValue := test.output\n\n\t\t// test slice values\n\t\tif !reflect.DeepEqual(test.output, test.want) {\n\t\t\tt.Fatalf(\"case #%d: From(%#v).ToSlice()=%#v expected=%#v\", c, test.input, test.output, test.want)\n\t\t}\n\n\t\t// test capacity of output slice\n\t\tif cap(test.output) != test.wantedOutputCap {\n\t\t\tt.Fatalf(\"case #%d: cap(output)=%d expected=%d\", c, cap(test.output), test.wantedOutputCap)\n\t\t}\n\n\t\t// test if a new slice is allocated\n\t\tinPtr := (*reflect.SliceHeader)(unsafe.Pointer(&initialOutputValue)).Data\n\t\toutPtr := (*reflect.SliceHeader)(unsafe.Pointer(&modifiedOutputValue)).Data\n\t\tisNewSlice := inPtr != outPtr\n\t\tif isNewSlice != test.outputIsANewSlice {\n\t\t\tt.Fatalf(\"case #%d: isNewSlice=%v (in=0x%X out=0x%X) expected=%v\", c, isNewSlice, inPtr, outPtr, test.outputIsANewSlice)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "reverse.go",
          "type": "blob",
          "size": 0.6953125,
          "content": "package linq\n\n// Reverse inverts the order of the elements in a collection.\n//\n// Unlike OrderBy, this sorting method does not consider the actual values\n// themselves in determining the order. Rather, it just returns the elements in\n// the reverse order from which they are produced by the underlying source.\nfunc (q Query) Reverse() Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\n\t\t\titems := []interface{}{}\n\t\t\tfor item, ok := next(); ok; item, ok = next() {\n\t\t\t\titems = append(items, item)\n\t\t\t}\n\n\t\t\tindex := len(items) - 1\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif index < 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\titem, ok = items[index], true\n\t\t\t\tindex--\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "reverse_test.go",
          "type": "blob",
          "size": 0.36328125,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tinput interface{}\n\t\twant  []interface{}\n\t}{\n\t\t{[]int{1, 2, 3}, []interface{}{3, 2, 1}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).Reverse(); !validateQuery(q, test.want) {\n\t\t\tt.Errorf(\"From(%v).Reverse()=%v expected %v\", test.input, toSlice(q), test.want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "select.go",
          "type": "blob",
          "size": 3.77734375,
          "content": "package linq\n\n// Select projects each element of a collection into a new form. Returns a query\n// with the result of invoking the transform function on each element of\n// original source.\n//\n// This projection method requires the transform function, selector, to produce\n// one value for each value in the source collection. If selector returns a\n// value that is itself a collection, it is up to the consumer to traverse the\n// subcollections manually. In such a situation, it might be better for your\n// query to return a single coalesced collection of values. To achieve this, use\n// the SelectMany method instead of Select. Although SelectMany works similarly\n// to Select, it differs in that the transform function returns a collection\n// that is then expanded by SelectMany before it is returned.\nfunc (q Query) Select(selector func(interface{}) interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tvar it interface{}\n\t\t\t\tit, ok = next()\n\t\t\t\tif ok {\n\t\t\t\t\titem = selector(it)\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SelectT is the typed version of Select.\n//   - selectorFn is of type \"func(TSource)TResult\"\n// NOTE: Select has better performance than SelectT.\nfunc (q Query) SelectT(selectorFn interface{}) Query {\n\n\tselectGenericFunc, err := newGenericFunc(\n\t\t\"SelectT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(item interface{}) interface{} {\n\t\treturn selectGenericFunc.Call(item)\n\t}\n\n\treturn q.Select(selectorFunc)\n}\n\n// SelectIndexed projects each element of a collection into a new form by\n// incorporating the element's index. Returns a query with the result of\n// invoking the transform function on each element of original source.\n//\n// The first argument to selector represents the zero-based index of that\n// element in the source collection. This can be useful if the elements are in a\n// known order and you want to do something with an element at a particular\n// index, for example. It can also be useful if you want to retrieve the index\n// of one or more elements. The second argument to selector represents the\n// element to process.\n//\n// This projection method requires the transform function, selector, to produce\n// one value for each value in the source collection. If selector returns a\n// value that is itself a collection, it is up to the consumer to traverse the\n// subcollections manually. In such a situation, it might be better for your\n// query to return a single coalesced collection of values. To achieve this, use\n// the SelectMany method instead of Select. Although SelectMany works similarly\n// to Select, it differs in that the transform function returns a collection\n// that is then expanded by SelectMany before it is returned.\nfunc (q Query) SelectIndexed(selector func(int, interface{}) interface{}) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tvar it interface{}\n\t\t\t\tit, ok = next()\n\t\t\t\tif ok {\n\t\t\t\t\titem = selector(index, it)\n\t\t\t\t\tindex++\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SelectIndexedT is the typed version of SelectIndexed.\n//   - selectorFn is of type \"func(int,TSource)TResult\"\n// NOTE: SelectIndexed has better performance than SelectIndexedT.\nfunc (q Query) SelectIndexedT(selectorFn interface{}) Query {\n\tselectGenericFunc, err := newGenericFunc(\n\t\t\"SelectIndexedT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(index int, item interface{}) interface{} {\n\t\treturn selectGenericFunc.Call(index, item)\n\t}\n\n\treturn q.SelectIndexed(selectorFunc)\n}\n"
        },
        {
          "name": "select_test.go",
          "type": "blob",
          "size": 1.875,
          "content": "package linq\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestSelect(t *testing.T) {\n\ttests := []struct {\n\t\tinput    interface{}\n\t\tselector func(interface{}) interface{}\n\t\toutput   []interface{}\n\t}{\n\t\t{[]int{1, 2, 3}, func(i interface{}) interface{} {\n\t\t\treturn i.(int) * 2\n\t\t}, []interface{}{2, 4, 6}},\n\t\t{\"str\", func(i interface{}) interface{} {\n\t\t\treturn string(i.(rune)) + \"1\"\n\t\t}, []interface{}{\"s1\", \"t1\", \"r1\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).Select(test.selector); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).Select()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSelectT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)T', actual: 'func(int,int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SelectT(func(item, idx int) int { return item + 2 })\n\t})\n}\n\nfunc TestSelectIndexed(t *testing.T) {\n\ttests := []struct {\n\t\tinput    interface{}\n\t\tselector func(int, interface{}) interface{}\n\t\toutput   []interface{}\n\t}{\n\t\t{[]int{1, 2, 3}, func(i int, x interface{}) interface{} {\n\t\t\treturn x.(int) * i\n\t\t}, []interface{}{0, 2, 6}},\n\t\t{\"str\", func(i int, x interface{}) interface{} {\n\t\t\treturn string(x.(rune)) + strconv.Itoa(i)\n\t\t}, []interface{}{\"s0\", \"t1\", \"r2\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SelectIndexed(test.selector); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SelectIndexed()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSelectIndexedT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectIndexedT: parameter [selectorFn] has a invalid function signature. Expected: 'func(int,T)T', actual: 'func(string,int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SelectIndexedT(func(index string, item int) int { return item + 2 })\n\t})\n}\n"
        },
        {
          "name": "selectmany.go",
          "type": "blob",
          "size": 6.9169921875,
          "content": "package linq\n\n// SelectMany projects each element of a collection to a Query, iterates and\n// flattens the resulting collection into one collection.\nfunc (q Query) SelectMany(selector func(interface{}) Query) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\touternext := q.Iterate()\n\t\t\tvar inner interface{}\n\t\t\tvar innernext Iterator\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !ok {\n\t\t\t\t\tif inner == nil {\n\t\t\t\t\t\tinner, ok = outernext()\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinnernext = selector(inner).Iterate()\n\t\t\t\t\t}\n\n\t\t\t\t\titem, ok = innernext()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tinner = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SelectManyT is the typed version of SelectMany.\n//\n//   - selectorFn is of type \"func(TSource)Query\"\n//\n// NOTE: SelectMany has better performance than SelectManyT.\nfunc (q Query) SelectManyT(selectorFn interface{}) Query {\n\n\tselectManyGenericFunc, err := newGenericFunc(\n\t\t\"SelectManyT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(Query))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(inner interface{}) Query {\n\t\treturn selectManyGenericFunc.Call(inner).(Query)\n\t}\n\treturn q.SelectMany(selectorFunc)\n\n}\n\n// SelectManyIndexed projects each element of a collection to a Query, iterates\n// and flattens the resulting collection into one collection.\n//\n// The first argument to selector represents the zero-based index of that\n// element in the source collection. This can be useful if the elements are in a\n// known order and you want to do something with an element at a particular\n// index, for example. It can also be useful if you want to retrieve the index\n// of one or more elements. The second argument to selector represents the\n// element to process.\nfunc (q Query) SelectManyIndexed(selector func(int, interface{}) Query) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\touternext := q.Iterate()\n\t\t\tindex := 0\n\t\t\tvar inner interface{}\n\t\t\tvar innernext Iterator\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !ok {\n\t\t\t\t\tif inner == nil {\n\t\t\t\t\t\tinner, ok = outernext()\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinnernext = selector(index, inner).Iterate()\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\titem, ok = innernext()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tinner = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SelectManyIndexedT is the typed version of SelectManyIndexed.\n//\n//   - selectorFn is of type \"func(int,TSource)Query\"\n//\n// NOTE: SelectManyIndexed has better performance than SelectManyIndexedT.\nfunc (q Query) SelectManyIndexedT(selectorFn interface{}) Query {\n\n\tselectManyIndexedGenericFunc, err := newGenericFunc(\n\t\t\"SelectManyIndexedT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), newElemTypeSlice(new(Query))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(index int, inner interface{}) Query {\n\t\treturn selectManyIndexedGenericFunc.Call(index, inner).(Query)\n\t}\n\n\treturn q.SelectManyIndexed(selectorFunc)\n}\n\n// SelectManyBy projects each element of a collection to a Query, iterates and\n// flattens the resulting collection into one collection, and invokes a result\n// selector function on each element therein.\nfunc (q Query) SelectManyBy(selector func(interface{}) Query,\n\tresultSelector func(interface{}, interface{}) interface{}) Query {\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\touternext := q.Iterate()\n\t\t\tvar outer interface{}\n\t\t\tvar innernext Iterator\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !ok {\n\t\t\t\t\tif outer == nil {\n\t\t\t\t\t\touter, ok = outernext()\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinnernext = selector(outer).Iterate()\n\t\t\t\t\t}\n\n\t\t\t\t\titem, ok = innernext()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\touter = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem = resultSelector(item, outer)\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SelectManyByT is the typed version of SelectManyBy.\n//\n//   - selectorFn is of type \"func(TSource)Query\"\n//   - resultSelectorFn is of type \"func(TSource,TCollection)TResult\"\n//\n// NOTE: SelectManyBy has better performance than SelectManyByT.\nfunc (q Query) SelectManyByT(selectorFn interface{},\n\tresultSelectorFn interface{}) Query {\n\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"SelectManyByT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(Query))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(outer interface{}) Query {\n\t\treturn selectorGenericFunc.Call(outer).(Query)\n\t}\n\n\tresultSelectorGenericFunc, err := newGenericFunc(\n\t\t\"SelectManyByT\", \"resultSelectorFn\", resultSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tresultSelectorFunc := func(outer interface{}, item interface{}) interface{} {\n\t\treturn resultSelectorGenericFunc.Call(outer, item)\n\t}\n\n\treturn q.SelectManyBy(selectorFunc, resultSelectorFunc)\n}\n\n// SelectManyByIndexed projects each element of a collection to a Query,\n// iterates and flattens the resulting collection into one collection, and\n// invokes a result selector function on each element therein. The index of each\n// source element is used in the intermediate projected form of that element.\nfunc (q Query) SelectManyByIndexed(selector func(int, interface{}) Query,\n\tresultSelector func(interface{}, interface{}) interface{}) Query {\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\touternext := q.Iterate()\n\t\t\tindex := 0\n\t\t\tvar outer interface{}\n\t\t\tvar innernext Iterator\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !ok {\n\t\t\t\t\tif outer == nil {\n\t\t\t\t\t\touter, ok = outernext()\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinnernext = selector(index, outer).Iterate()\n\t\t\t\t\t\tindex++\n\t\t\t\t\t}\n\n\t\t\t\t\titem, ok = innernext()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\touter = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem = resultSelector(item, outer)\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SelectManyByIndexedT is the typed version of SelectManyByIndexed.\n//\n//   - selectorFn is of type \"func(int,TSource)Query\"\n//   - resultSelectorFn is of type \"func(TSource,TCollection)TResult\"\n//\n// NOTE: SelectManyByIndexed has better performance than\n// SelectManyByIndexedT.\nfunc (q Query) SelectManyByIndexedT(selectorFn interface{},\n\tresultSelectorFn interface{}) Query {\n\tselectorGenericFunc, err := newGenericFunc(\n\t\t\"SelectManyByIndexedT\", \"selectorFn\", selectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), newElemTypeSlice(new(Query))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tselectorFunc := func(index int, outer interface{}) Query {\n\t\treturn selectorGenericFunc.Call(index, outer).(Query)\n\t}\n\n\tresultSelectorGenericFunc, err := newGenericFunc(\n\t\t\"SelectManyByIndexedT\", \"resultSelectorFn\", resultSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tresultSelectorFunc := func(outer interface{}, item interface{}) interface{} {\n\t\treturn resultSelectorGenericFunc.Call(outer, item)\n\t}\n\n\treturn q.SelectManyByIndexed(selectorFunc, resultSelectorFunc)\n}\n"
        },
        {
          "name": "selectmany_test.go",
          "type": "blob",
          "size": 5.4443359375,
          "content": "package linq\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestSelectMany(t *testing.T) {\n\ttests := []struct {\n\t\tinput    interface{}\n\t\tselector func(interface{}) Query\n\t\toutput   []interface{}\n\t}{\n\t\t{[][]int{{1, 2, 3}, {4, 5, 6, 7}}, func(i interface{}) Query {\n\t\t\treturn From(i)\n\t\t}, []interface{}{1, 2, 3, 4, 5, 6, 7}},\n\t\t{[]string{\"str\", \"ing\"}, func(i interface{}) Query {\n\t\t\treturn FromString(i.(string))\n\t\t}, []interface{}{'s', 't', 'r', 'i', 'n', 'g'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SelectMany(test.selector); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SelectMany()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSelectManyT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectManyT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)linq.Query', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SelectManyT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestSelectManyIndexed(t *testing.T) {\n\ttests := []struct {\n\t\tinput    interface{}\n\t\tselector func(int, interface{}) Query\n\t\toutput   []interface{}\n\t}{\n\t\t{[][]int{{1, 2, 3}, {4, 5, 6, 7}}, func(i int, x interface{}) Query {\n\t\t\tif i > 0 {\n\t\t\t\treturn From(x.([]int)[1:])\n\t\t\t}\n\t\t\treturn From(x)\n\t\t}, []interface{}{1, 2, 3, 5, 6, 7}},\n\t\t{[]string{\"str\", \"ing\"}, func(i int, x interface{}) Query {\n\t\t\treturn FromString(x.(string) + strconv.Itoa(i))\n\t\t}, []interface{}{'s', 't', 'r', '0', 'i', 'n', 'g', '1'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SelectManyIndexed(test.selector); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SelectManyIndexed()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSelectManyIndexedT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectManyIndexedT: parameter [selectorFn] has a invalid function signature. Expected: 'func(int,T)linq.Query', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SelectManyIndexedT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestSelectManyBy(t *testing.T) {\n\ttests := []struct {\n\t\tinput          interface{}\n\t\tselector       func(interface{}) Query\n\t\tresultSelector func(interface{}, interface{}) interface{}\n\t\toutput         []interface{}\n\t}{\n\t\t{[][]int{{1, 2, 3}, {4, 5, 6, 7}}, func(i interface{}) Query {\n\t\t\treturn From(i)\n\t\t}, func(x interface{}, y interface{}) interface{} {\n\t\t\treturn x.(int) + 1\n\t\t}, []interface{}{2, 3, 4, 5, 6, 7, 8}},\n\t\t{[]string{\"str\", \"ing\"}, func(i interface{}) Query {\n\t\t\treturn FromString(i.(string))\n\t\t}, func(x interface{}, y interface{}) interface{} {\n\t\t\treturn string(x.(rune)) + \"_\"\n\t\t}, []interface{}{\"s_\", \"t_\", \"r_\", \"i_\", \"n_\", \"g_\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SelectManyBy(test.selector, test.resultSelector); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SelectManyBy()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSelectManyByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectManyByT: parameter [selectorFn] has a invalid function signature. Expected: 'func(T)linq.Query', actual: 'func(int)interface {}'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SelectManyByT(func(item int) interface{} { return item + 2 }, 2)\n\t})\n}\n\nfunc TestSelectManyByT_PanicWhenResultSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectManyByT: parameter [resultSelectorFn] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func()'\", func() {\n\t\tFrom([][]int{{1, 1, 1, 2}, {1, 2, 3, 4, 2}}).SelectManyByT(\n\t\t\tfunc(item interface{}) Query { return From(item) },\n\t\t\tfunc() {},\n\t\t)\n\t})\n}\n\nfunc TestSelectManyIndexedBy(t *testing.T) {\n\ttests := []struct {\n\t\tinput          interface{}\n\t\tselector       func(int, interface{}) Query\n\t\tresultSelector func(interface{}, interface{}) interface{}\n\t\toutput         []interface{}\n\t}{\n\t\t{[][]int{{1, 2, 3}, {4, 5, 6, 7}}, func(i int, x interface{}) Query {\n\t\t\tif i == 0 {\n\t\t\t\treturn From([]int{10, 20, 30})\n\t\t\t}\n\t\t\treturn From(x)\n\t\t}, func(x interface{}, y interface{}) interface{} {\n\t\t\treturn x.(int) + 1\n\t\t}, []interface{}{11, 21, 31, 5, 6, 7, 8}},\n\t\t{[]string{\"st\", \"ng\"}, func(i int, x interface{}) Query {\n\t\t\tif i == 0 {\n\t\t\t\treturn FromString(x.(string) + \"r\")\n\t\t\t}\n\t\t\treturn FromString(\"i\" + x.(string))\n\t\t}, func(x interface{}, y interface{}) interface{} {\n\t\t\treturn string(x.(rune)) + \"_\"\n\t\t}, []interface{}{\"s_\", \"t_\", \"r_\", \"i_\", \"n_\", \"g_\"}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SelectManyByIndexed(test.selector, test.resultSelector); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SelectManyIndexedBy()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSelectManyIndexedByT_PanicWhenSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectManyByIndexedT: parameter [selectorFn] has a invalid function signature. Expected: 'func(int,T)linq.Query', actual: 'func(int)interface {}'\", func() {\n\t\tFrom([][]int{{1, 1, 1, 2}, {1, 2, 3, 4, 2}}).SelectManyByIndexedT(\n\t\t\tfunc(item int) interface{} { return item + 2 },\n\t\t\t2,\n\t\t)\n\t})\n}\n\nfunc TestSelectManyIndexedByT_PanicWhenResultSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SelectManyByIndexedT: parameter [resultSelectorFn] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func()'\", func() {\n\t\tFrom([][]int{{1, 1, 1, 2}, {1, 2, 3, 4, 2}}).SelectManyByIndexedT(\n\t\t\tfunc(index int, item interface{}) Query { return From(item) },\n\t\t\tfunc() {},\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "setup_test.go",
          "type": "blob",
          "size": 1.109375,
          "content": "package linq\n\nimport \"testing\"\n\nimport \"fmt\"\n\ntype foo struct {\n\tf1 int\n\tf2 bool\n\tf3 string\n}\n\nfunc (f foo) Iterate() Iterator {\n\ti := 0\n\n\treturn func() (item interface{}, ok bool) {\n\t\tswitch i {\n\t\tcase 0:\n\t\t\titem = f.f1\n\t\t\tok = true\n\t\tcase 1:\n\t\t\titem = f.f2\n\t\t\tok = true\n\t\tcase 2:\n\t\t\titem = f.f3\n\t\t\tok = true\n\t\tdefault:\n\t\t\tok = false\n\t\t}\n\n\t\ti++\n\t\treturn\n\t}\n}\n\nfunc (f foo) CompareTo(c Comparable) int {\n\ta, b := f.f1, c.(foo).f1\n\n\tif a < b {\n\t\treturn -1\n\t} else if a > b {\n\t\treturn 1\n\t}\n\n\treturn 0\n}\n\nfunc toSlice(q Query) (result []interface{}) {\n\tnext := q.Iterate()\n\n\tfor item, ok := next(); ok; item, ok = next() {\n\t\tresult = append(result, item)\n\t}\n\n\treturn\n}\n\nfunc validateQuery(q Query, output []interface{}) bool {\n\tnext := q.Iterate()\n\n\tfor _, oitem := range output {\n\t\tqitem, _ := next()\n\n\t\tif oitem != qitem {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t_, ok := next()\n\t_, ok2 := next()\n\treturn !(ok || ok2)\n}\n\nfunc mustPanicWithError(t *testing.T, expectedErr string, f func()) {\n\tdefer func() {\n\t\tr := recover()\n\t\terr := fmt.Sprintf(\"%s\", r)\n\t\tif err != expectedErr {\n\t\t\tt.Fatalf(\"got=[%v] expected=[%v]\", err, expectedErr)\n\t\t}\n\t}()\n\tf()\n}\n"
        },
        {
          "name": "skip.go",
          "type": "blob",
          "size": 3.2802734375,
          "content": "package linq\n\n// Skip bypasses a specified number of elements in a collection and then returns\n// the remaining elements.\nfunc (q Query) Skip(count int) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tn := count\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor ; n > 0; n-- {\n\t\t\t\t\titem, ok = next()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn next()\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SkipWhile bypasses elements in a collection as long as a specified condition\n// is true and then returns the remaining elements.\n//\n// This method tests each element by using predicate and skips the element if\n// the result is true. After the predicate function returns false for an\n// element, that element and the remaining elements in source are returned and\n// there are no more invocations of predicate.\nfunc (q Query) SkipWhile(predicate func(interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tready := false\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !ready {\n\t\t\t\t\titem, ok = next()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tready = !predicate(item)\n\t\t\t\t\tif ready {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn next()\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SkipWhileT is the typed version of SkipWhile.\n//\n//   - predicateFn is of type \"func(TSource)bool\"\n//\n// NOTE: SkipWhile has better performance than SkipWhileT.\nfunc (q Query) SkipWhileT(predicateFn interface{}) Query {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"SkipWhileT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.SkipWhile(predicateFunc)\n}\n\n// SkipWhileIndexed bypasses elements in a collection as long as a specified\n// condition is true and then returns the remaining elements. The element's\n// index is used in the logic of the predicate function.\n//\n// This method tests each element by using predicate and skips the element if\n// the result is true. After the predicate function returns false for an\n// element, that element and the remaining elements in source are returned and\n// there are no more invocations of predicate.\nfunc (q Query) SkipWhileIndexed(predicate func(int, interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tready := false\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor !ready {\n\t\t\t\t\titem, ok = next()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tready = !predicate(index, item)\n\t\t\t\t\tif ready {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++\n\t\t\t\t}\n\n\t\t\t\treturn next()\n\t\t\t}\n\t\t},\n\t}\n}\n\n// SkipWhileIndexedT is the typed version of SkipWhileIndexed.\n//\n//   - predicateFn is of type \"func(int,TSource)bool\"\n//\n// NOTE: SkipWhileIndexed has better performance than SkipWhileIndexedT.\nfunc (q Query) SkipWhileIndexedT(predicateFn interface{}) Query {\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"SkipWhileIndexedT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(index int, item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(index, item).(bool)\n\t}\n\n\treturn q.SkipWhileIndexed(predicateFunc)\n}\n"
        },
        {
          "name": "skip_test.go",
          "type": "blob",
          "size": 2.75,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestSkip(t *testing.T) {\n\ttests := []struct {\n\t\tinput  interface{}\n\t\toutput []interface{}\n\t}{\n\t\t{[]int{1, 2}, []interface{}{}},\n\t\t{[]int{1, 2, 2, 3, 1}, []interface{}{3, 1}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, []interface{}{2, 1, 2, 3, 4, 2}},\n\t\t{\"sstr\", []interface{}{'r'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).Skip(3); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).Skip(3)=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSkipWhile(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(interface{}) bool\n\t\toutput    []interface{}\n\t}{\n\t\t{[]int{1, 2}, func(i interface{}) bool {\n\t\t\treturn i.(int) < 3\n\t\t}, []interface{}{}},\n\t\t{[]int{4, 1, 2}, func(i interface{}) bool {\n\t\t\treturn i.(int) < 3\n\t\t}, []interface{}{4, 1, 2}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, func(i interface{}) bool {\n\t\t\treturn i.(int) < 3\n\t\t}, []interface{}{3, 4, 2}},\n\t\t{\"sstr\", func(i interface{}) bool {\n\t\t\treturn i.(rune) == 's'\n\t\t}, []interface{}{'t', 'r'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SkipWhile(test.predicate); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SkipWhile()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSkipWhileT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SkipWhileT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int,int)bool'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SkipWhileT(func(item int, x int) bool { return item == 1 })\n\t})\n}\n\nfunc TestSkipWhileIndexed(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(int, interface{}) bool\n\t\toutput    []interface{}\n\t}{\n\t\t{[]int{1, 2}, func(i int, x interface{}) bool {\n\t\t\treturn x.(int) < 3\n\t\t}, []interface{}{}},\n\t\t{[]int{4, 1, 2}, func(i int, x interface{}) bool {\n\t\t\treturn x.(int) < 3\n\t\t}, []interface{}{4, 1, 2}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, func(i int, x interface{}) bool {\n\t\t\treturn x.(int) < 2 || i < 5\n\t\t}, []interface{}{2, 3, 4, 2}},\n\t\t{\"sstr\", func(i int, x interface{}) bool {\n\t\t\treturn x.(rune) == 's' && i < 1\n\t\t}, []interface{}{'s', 't', 'r'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).SkipWhileIndexed(test.predicate); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).SkipWhileIndexed()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestSkipWhileIndexedT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"SkipWhileIndexedT: parameter [predicateFn] has a invalid function signature. Expected: 'func(int,T)bool', actual: 'func(int,int,int)bool'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).SkipWhileIndexedT(func(item int, x int, y int) bool { return item == 1 })\n\t})\n}\n"
        },
        {
          "name": "take.go",
          "type": "blob",
          "size": 2.8046875,
          "content": "package linq\n\n// Take returns a specified number of contiguous elements from the start of a\n// collection.\nfunc (q Query) Take(count int) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tn := count\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif n <= 0 {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tn--\n\t\t\t\treturn next()\n\t\t\t}\n\t\t},\n\t}\n}\n\n// TakeWhile returns elements from a collection as long as a specified condition\n// is true, and then skips the remaining elements.\nfunc (q Query) TakeWhile(predicate func(interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tdone := false\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif done {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\titem, ok = next()\n\t\t\t\tif !ok {\n\t\t\t\t\tdone = true\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif predicate(item) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdone = true\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t},\n\t}\n}\n\n// TakeWhileT is the typed version of TakeWhile.\n//\n//   - predicateFn is of type \"func(TSource)bool\"\n//\n// NOTE: TakeWhile has better performance than TakeWhileT.\nfunc (q Query) TakeWhileT(predicateFn interface{}) Query {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"TakeWhileT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.TakeWhile(predicateFunc)\n}\n\n// TakeWhileIndexed returns elements from a collection as long as a specified\n// condition is true. The element's index is used in the logic of the predicate\n// function. The first argument of predicate represents the zero-based index of\n// the element within collection. The second argument represents the element to\n// test.\nfunc (q Query) TakeWhileIndexed(predicate func(int, interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tdone := false\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif done {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\titem, ok = next()\n\t\t\t\tif !ok {\n\t\t\t\t\tdone = true\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif predicate(index, item) {\n\t\t\t\t\tindex++\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tdone = true\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t},\n\t}\n}\n\n// TakeWhileIndexedT is the typed version of TakeWhileIndexed.\n//\n//   - predicateFn is of type \"func(int,TSource)bool\"\n//\n// NOTE: TakeWhileIndexed has better performance than TakeWhileIndexedT.\nfunc (q Query) TakeWhileIndexedT(predicateFn interface{}) Query {\n\twhereFunc, err := newGenericFunc(\n\t\t\"TakeWhileIndexedT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(index int, item interface{}) bool {\n\t\treturn whereFunc.Call(index, item).(bool)\n\t}\n\n\treturn q.TakeWhileIndexed(predicateFunc)\n}\n"
        },
        {
          "name": "take_test.go",
          "type": "blob",
          "size": 2.5380859375,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestTake(t *testing.T) {\n\ttests := []struct {\n\t\tinput  interface{}\n\t\toutput []interface{}\n\t}{\n\t\t{[]int{1, 2, 2, 3, 1}, []interface{}{1, 2, 2}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, []interface{}{1, 1, 1}},\n\t\t{\"sstr\", []interface{}{'s', 's', 't'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).Take(3); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).Take(3)=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestTakeWhile(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(interface{}) bool\n\t\toutput    []interface{}\n\t}{\n\t\t{[]int{1, 1, 1, 2, 1, 2}, func(i interface{}) bool {\n\t\t\treturn i.(int) < 3\n\t\t}, []interface{}{1, 1, 1, 2, 1, 2}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, func(i interface{}) bool {\n\t\t\treturn i.(int) < 3\n\t\t}, []interface{}{1, 1, 1, 2, 1, 2}},\n\t\t{\"sstr\", func(i interface{}) bool {\n\t\t\treturn i.(rune) == 's'\n\t\t}, []interface{}{'s', 's'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).TakeWhile(test.predicate); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).TakeWhile()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestTakeWhileT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"TakeWhileT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).TakeWhileT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestTakeWhileIndexed(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(int, interface{}) bool\n\t\toutput    []interface{}\n\t}{\n\t\t{[]int{1, 1, 1, 2}, func(i int, x interface{}) bool {\n\t\t\treturn x.(int) < 2 || i < 5\n\t\t}, []interface{}{1, 1, 1, 2}},\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, func(i int, x interface{}) bool {\n\t\t\treturn x.(int) < 2 || i < 5\n\t\t}, []interface{}{1, 1, 1, 2, 1}},\n\t\t{\"sstr\", func(i int, x interface{}) bool {\n\t\t\treturn x.(rune) == 's' && i < 1\n\t\t}, []interface{}{'s'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).TakeWhileIndexed(test.predicate); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).TakeWhileIndexed()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestTakeWhileIndexedT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"TakeWhileIndexedT: parameter [predicateFn] has a invalid function signature. Expected: 'func(int,T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).TakeWhileIndexedT(func(item int) int { return item + 2 })\n\t})\n}\n"
        },
        {
          "name": "union.go",
          "type": "blob",
          "size": 0.8173828125,
          "content": "package linq\n\n// Union produces the set union of two collections.\n//\n// This method excludes duplicates from the return set. This is different\n// behavior to the Concat method, which returns all the elements in the input\n// collection including duplicates.\nfunc (q Query) Union(q2 Query) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tnext2 := q2.Iterate()\n\n\t\t\tset := make(map[interface{}]bool)\n\t\t\tuse1 := true\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tif use1 {\n\t\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\t\tif _, has := set[item]; !has {\n\t\t\t\t\t\t\tset[item] = true\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tuse1 = false\n\t\t\t\t}\n\n\t\t\t\tfor item, ok = next2(); ok; item, ok = next2() {\n\t\t\t\t\tif _, has := set[item]; !has {\n\t\t\t\t\t\tset[item] = true\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "union_test.go",
          "type": "blob",
          "size": 0.3056640625,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestUnion(t *testing.T) {\n\tinput1 := []int{1, 2, 3}\n\tinput2 := []int{2, 4, 5, 1}\n\twant := []interface{}{1, 2, 3, 4, 5}\n\n\tif q := From(input1).Union(From(input2)); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Union(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n"
        },
        {
          "name": "where.go",
          "type": "blob",
          "size": 2.181640625,
          "content": "package linq\n\n// Where filters a collection of values based on a predicate.\nfunc (q Query) Where(predicate func(interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\tif predicate(item) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// WhereT is the typed version of Where.\n//\n//   - predicateFn is of type \"func(TSource)bool\"\n//\n// NOTE: Where has better performance than WhereT.\nfunc (q Query) WhereT(predicateFn interface{}) Query {\n\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"WhereT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(item).(bool)\n\t}\n\n\treturn q.Where(predicateFunc)\n}\n\n// WhereIndexed filters a collection of values based on a predicate. Each\n// element's index is used in the logic of the predicate function.\n//\n// The first argument represents the zero-based index of the element within\n// collection. The second argument of predicate represents the element to test.\nfunc (q Query) WhereIndexed(predicate func(int, interface{}) bool) Query {\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext := q.Iterate()\n\t\t\tindex := 0\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\tfor item, ok = next(); ok; item, ok = next() {\n\t\t\t\t\tif predicate(index, item) {\n\t\t\t\t\t\tindex++\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}\n}\n\n// WhereIndexedT is the typed version of WhereIndexed.\n//\n//   - predicateFn is of type \"func(int,TSource)bool\"\n//\n// NOTE: WhereIndexed has better performance than WhereIndexedT.\nfunc (q Query) WhereIndexedT(predicateFn interface{}) Query {\n\tpredicateGenericFunc, err := newGenericFunc(\n\t\t\"WhereIndexedT\", \"predicateFn\", predicateFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(int), new(genericType)), newElemTypeSlice(new(bool))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpredicateFunc := func(index int, item interface{}) bool {\n\t\treturn predicateGenericFunc.Call(index, item).(bool)\n\t}\n\n\treturn q.WhereIndexed(predicateFunc)\n}\n"
        },
        {
          "name": "where_test.go",
          "type": "blob",
          "size": 1.8876953125,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestWhere(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(interface{}) bool\n\t\toutput    []interface{}\n\t}{\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, func(i interface{}) bool {\n\t\t\treturn i.(int) >= 3\n\t\t}, []interface{}{3, 4}},\n\t\t{\"sstr\", func(i interface{}) bool {\n\t\t\treturn i.(rune) != 's'\n\t\t}, []interface{}{'t', 'r'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).Where(test.predicate); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).Where()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestWhereT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"WhereT: parameter [predicateFn] has a invalid function signature. Expected: 'func(T)bool', actual: 'func(int)int'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).WhereT(func(item int) int { return item + 2 })\n\t})\n}\n\nfunc TestWhereIndexed(t *testing.T) {\n\ttests := []struct {\n\t\tinput     interface{}\n\t\tpredicate func(int, interface{}) bool\n\t\toutput    []interface{}\n\t}{\n\t\t{[9]int{1, 1, 1, 2, 1, 2, 3, 4, 2}, func(i int, x interface{}) bool {\n\t\t\treturn x.(int) < 4 && i > 4\n\t\t}, []interface{}{2, 3, 2}},\n\t\t{\"sstr\", func(i int, x interface{}) bool {\n\t\t\treturn x.(rune) != 's' || i == 1\n\t\t}, []interface{}{'s', 't', 'r'}},\n\t\t{\"abcde\", func(i int, _ interface{}) bool {\n\t\t\treturn i < 2\n\t\t}, []interface{}{'a', 'b'}},\n\t}\n\n\tfor _, test := range tests {\n\t\tif q := From(test.input).WhereIndexed(test.predicate); !validateQuery(q, test.output) {\n\t\t\tt.Errorf(\"From(%v).WhereIndexed()=%v expected %v\", test.input, toSlice(q), test.output)\n\t\t}\n\t}\n}\n\nfunc TestWhereIndexedT_PanicWhenPredicateFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"WhereIndexedT: parameter [predicateFn] has a invalid function signature. Expected: 'func(int,T)bool', actual: 'func(string)'\", func() {\n\t\tFrom([]int{1, 1, 1, 2, 1, 2, 3, 4, 2}).WhereIndexedT(func(item string) {})\n\t})\n}\n"
        },
        {
          "name": "zip.go",
          "type": "blob",
          "size": 1.671875,
          "content": "package linq\n\n// Zip applies a specified function to the corresponding elements of two\n// collections, producing a collection of the results.\n//\n// The method steps through the two input collections, applying function\n// resultSelector to corresponding elements of the two collections. The method\n// returns a collection of the values that are returned by resultSelector. If\n// the input collections do not have the same number of elements, the method\n// combines elements until it reaches the end of one of the collections. For\n// example, if one collection has three elements and the other one has four, the\n// result collection has only three elements.\nfunc (q Query) Zip(q2 Query,\n\tresultSelector func(interface{}, interface{}) interface{}) Query {\n\n\treturn Query{\n\t\tIterate: func() Iterator {\n\t\t\tnext1 := q.Iterate()\n\t\t\tnext2 := q2.Iterate()\n\n\t\t\treturn func() (item interface{}, ok bool) {\n\t\t\t\titem1, ok1 := next1()\n\t\t\t\titem2, ok2 := next2()\n\n\t\t\t\tif ok1 && ok2 {\n\t\t\t\t\treturn resultSelector(item1, item2), true\n\t\t\t\t}\n\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t},\n\t}\n}\n\n// ZipT is the typed version of Zip.\n//\n//   - resultSelectorFn is of type \"func(TFirst,TSecond)TResult\"\n//\n// NOTE: Zip has better performance than ZipT.\nfunc (q Query) ZipT(q2 Query,\n\tresultSelectorFn interface{}) Query {\n\tresultSelectorGenericFunc, err := newGenericFunc(\n\t\t\"ZipT\", \"resultSelectorFn\", resultSelectorFn,\n\t\tsimpleParamValidator(newElemTypeSlice(new(genericType), new(genericType)), newElemTypeSlice(new(genericType))),\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tresultSelectorFunc := func(item1 interface{}, item2 interface{}) interface{} {\n\t\treturn resultSelectorGenericFunc.Call(item1, item2)\n\t}\n\n\treturn q.Zip(q2, resultSelectorFunc)\n}\n"
        },
        {
          "name": "zip_test.go",
          "type": "blob",
          "size": 0.7197265625,
          "content": "package linq\n\nimport \"testing\"\n\nfunc TestZip(t *testing.T) {\n\tinput1 := []int{1, 2, 3}\n\tinput2 := []int{2, 4, 5, 1}\n\twant := []interface{}{3, 6, 8}\n\n\tif q := From(input1).Zip(From(input2), func(i, j interface{}) interface{} {\n\t\treturn i.(int) + j.(int)\n\t}); !validateQuery(q, want) {\n\t\tt.Errorf(\"From(%v).Zip(%v)=%v expected %v\", input1, input2, toSlice(q), want)\n\t}\n}\n\nfunc TestZipT_PanicWhenResultSelectorFnIsInvalid(t *testing.T) {\n\tmustPanicWithError(t, \"ZipT: parameter [resultSelectorFn] has a invalid function signature. Expected: 'func(T,T)T', actual: 'func(int,int,int)int'\", func() {\n\t\tinput1 := []int{1, 2, 3}\n\t\tinput2 := []int{2, 4, 5, 1}\n\n\t\tFrom(input1).ZipT(From(input2), func(i, j, k int) int {\n\t\t\treturn i + j\n\t\t})\n\t})\n}\n"
        }
      ]
    }
  ]
}