{
  "metadata": {
    "timestamp": 1736567060972,
    "page": 646,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "h2non/bimg",
      "stars": 2754,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.310546875,
          "content": "root = true\n\n[*.go]\ncharset = utf-8\nindent_style = tab\nindent_size = 2\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[Makefile]\ncharset = utf-8\nindent_style = tab\nindent_size = 2\nend_of_line = lf\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.yml]\nindent_style = space\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0927734375,
          "content": "/bimg\n/bundle\nbin\n/*.jpg\n/*.png\n/*.webp\n/testdata/*_out.*\n/.idea/\ntestdata/test_vertical_*.jpg\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.744140625,
          "content": "language: go\n\ndist: focal\nsudo: required\n\nservices:\n  - docker\n\nenv:\n  # - LIBVIPS=8.6.2\n  # - LIBVIPS=8.7.4\n  # - LIBVIPS=8.8.4\n  # - LIBVIPS=8.9.2\n  - LIBVIPS=8.10.1\n  - LIBVIPS=8.10.2\n\nmatrix:\n  allow_failures:\n    - env: LIBVIPS=8.8.4\n\ncache:\n  apt:\n  directories:\n    - $HOME/libvips\n\ninstall:\n  - docker build -t h2non/bimg:ci --build-arg LIBVIPS_VERSION=$LIBVIPS .\n\nscript:\n  - docker run h2non/bimg:ci sh -c 'export LD_LIBRARY_PATH=/vips/lib:/usr/local/lib:$LD_LIBRARY_PATH; export PKG_CONFIG_PATH=/vips/lib/pkgconfig:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig:/usr/X11/lib/pkgconfig;  go vet . && golint . && go test -v -race -covermode=atomic -coverprofile=coverage.out'\n\n# after_success:\n#   - goveralls -coverprofile=coverage.out -service=travis-ci\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 2.83203125,
          "content": "FROM golang:1.14\nLABEL maintainer \"tomas@aparicio.me\"\n\nARG LIBVIPS_VERSION=8.9.2\nARG LIBHEIF_VERSION=1.9.1\nARG GOLANGCILINT_VERSION=1.29.0\n\n# Installs libvips + required libraries\nRUN DEBIAN_FRONTEND=noninteractive \\\n  apt-get update && \\\n  apt-get install --no-install-recommends -y \\\n  ca-certificates \\\n  automake build-essential curl \\\n  gobject-introspection gtk-doc-tools libglib2.0-dev libjpeg62-turbo-dev libpng-dev \\\n  libwebp-dev libtiff5-dev libgif-dev libexif-dev libxml2-dev libpoppler-glib-dev \\\n  swig libmagickwand-dev libpango1.0-dev libmatio-dev libopenslide-dev libcfitsio-dev \\\n  libgsf-1-dev fftw3-dev liborc-0.4-dev librsvg2-dev libimagequant-dev libaom-dev && \\\n  cd /tmp && \\\n  curl -fsSLO https://github.com/strukturag/libheif/releases/download/v${LIBHEIF_VERSION}/libheif-${LIBHEIF_VERSION}.tar.gz && \\\n  tar zvxf libheif-${LIBHEIF_VERSION}.tar.gz && \\\n  cd /tmp/libheif-${LIBHEIF_VERSION} && \\\n  ./configure --prefix=/vips && \\\n  make && \\\n  make install && \\\n  echo '/vips/lib' > /etc/ld.so.conf.d/vips.conf && \\\n  ldconfig -v && \\\n  export LD_LIBRARY_PATH=\"/vips/lib:$LD_LIBRARY_PATH\" && \\\n  export PKG_CONFIG_PATH=\"/vips/lib/pkgconfig:$PKG_CONFIG_PATH\" && \\\n  cd /tmp && \\\n  curl -fsSLO https://github.com/libvips/libvips/releases/download/v${LIBVIPS_VERSION}/vips-${LIBVIPS_VERSION}.tar.gz && \\\n  tar zvxf vips-${LIBVIPS_VERSION}.tar.gz && \\\n  cd /tmp/vips-${LIBVIPS_VERSION} && \\\n\tCFLAGS=\"-g -O3\" CXXFLAGS=\"-D_GLIBCXX_USE_CXX11_ABI=0 -g -O3\" \\\n    ./configure \\\n    --disable-debug \\\n    --disable-dependency-tracking \\\n    --disable-introspection \\\n    --disable-static \\\n    --enable-gtk-doc-html=no \\\n    --enable-gtk-doc=no \\\n    --enable-pyvips8=no \\\n    --prefix=/vips && \\\n  make && \\\n  make install && \\\n  ldconfig\n\nENV LD_LIBRARY_PATH=\"/usr/local/lib:$LD_LIBRARY_PATH\"\n\n# Install runtime dependencies\n# RUN DEBIAN_FRONTEND=noninteractive \\\n#   apt-get update && \\\n#   apt-get install --no-install-recommends -y \\\n#   libglib2.0-0 libjpeg62-turbo libpng16-16 libopenexr23 \\\n#   libwebp6 libwebpmux3 libwebpdemux2 libtiff5 libgif7 libexif12 libxml2 libpoppler-glib8 \\\n#   libmagickwand-6.q16-6 libpango1.0-0 libmatio4 libopenslide0 \\\n#   libgsf-1-114 fftw3 liborc-0.4-0 librsvg2-2 libcfitsio7 libimagequant0 libheif1 && \\\n#   apt-get autoremove -y && \\\n#   apt-get autoclean && \\\n#   apt-get clean && \\\n#   rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\n# Install Go lint\nRUN go get -u golang.org/x/lint/golint\n\n# ENV LD_LIBRARY_PATH=\"/vips/lib:$LD_LIBRARY_PATH\"\n# ENV PKG_CONFIG_PATH=\"/vips/lib/pkgconfig:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig:/usr/X11/lib/pkgconfig\"\n\nWORKDIR ${GOPATH}/src/github.com/h2non/bimg\nCOPY . .\n\n# RUN \\\n#   # Clean up\n#   apt-get remove -y automake curl build-essential && \\\n#   apt-get autoremove -y && \\\n#   apt-get autoclean && \\\n#   apt-get clean && \\\n#   rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*\n\nCMD [ \"/bin/bash\" ]\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 0.279296875,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  inputs-digest = \"ab4fef131ee828e96ba67d31a7d690bd5f2f42040c6766b1b12fe856f87e0ff7\"\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.5224609375,
          "content": "\n# Gopkg.toml example\n#\n# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#  name = \"github.com/x/y\"\n#  version = \"2.4.0\"\n\n"
        },
        {
          "name": "History.md",
          "type": "blob",
          "size": 34.9208984375,
          "content": "\nv1.1.9 / 2022-04-05\n===================\n\n  * chore(History): version changes\n  * Merge pull request #374 from Mereng/brightness_contrast\n  * Merge pull request #393 from lucor/gifsave\n  * Add GIF save support from libvips 8.12\n  * Support brightness and contrast\n\nv1.1.8 / 2022-04-05\n===================\n\n  * chore(version): bump\n  * Merge pull request #405 from igsr5/feat/#404-support-way-to-change–MaxSize\n  * Fix review\n  * Add getter, setter for MaxSize\n\nv1.1.7 / 2022-02-23\n===================\n\n  * Merge pull request #398 from vaibsharma/vaibsharma/feature/speed_for_png_buffer\n  * reason for speed=3 added\n  * allow effort param for png encoding when palette is true\n\nv1.1.6 / 2022-01-28\n===================\n\n  * Update README.md\n  * Merge pull request #368 from exaring/fix-shrinking-on-small-webp-images\n  * Merge pull request #360 from jaberwoky/master\n  * Merge pull request #378 from kyfk/fix_typo_and_format\n  * goimports\n  * fix typo in comments\n  * Merge pull request #377 from ZloyDyadka/vector-flag\n  * Vips: cast go.int to c.INT in VipsVectorSetEnabled\n  * Vips: add VipsVectorSetEnabled\n  * Remove debug output\n  * Fix for blurry images from WEBP input and small output dimensions\n  * Merge pull request #367 from Keruspe/segv\n  * unref the image *after* we used it\n  * add test\n  * fix panic on reading Exif\n\nv1.1.5 / 2020-11-21\n===================\n\n  * Adds AVIF support [#356](https://github.com/h2non/bimg/pull/356)\n  \nv1.1.4 / 2020-08-04\n==================\n\n  * Merge pull request #346 from fredeastside/more_exif_data\n  * add most useful exif data to metadata\n\nv1.1.3 / 2020-08-04\n===================\n\n  * feat: version history v1.1.3\n  * fix(ci): disable <8.7 libvips\n  * feat: autorotate\n  * feat: bump version\n  * Merge pull request #347 from vansante/master\n  * Merge pull request #345 from fredeastside/more_exif_data\n  * add more exif data to metadata\n  * Merge pull request #3 from laurentiuilie/add-support-for-heifs-file\n  * add brands heis, hevc\n  * Merge pull request #2 from laurentiuilie/add-support-for-heifs-file\n  * add test image for heifs\n  * remove test file and add the check\n  * add support for HEIFS file\n  * fix(palette): indentation\n  * Merge pull request #337 from theplant/master\n  * support Palette option for png\n\nv1.1.2 / 2020-06-08\n===================\n\n  * feat(history): add changes\n  * fix(#335): disable image flatten type conditional\n\nv1.1.1 / 2020-06-08\n===================\n\n  * feat(history): add changes\n  * feat(version): bump patch\n  * refactor(docs): add libvips install reference\n  * fix(ci): disable old libvips versions\n  * fix(install): use latest libvips version\n  * fix(tests): add heif exception in libvips < 8.8\n  * refactor(ci): use libvips 8.7\n  * fix(History): use proper version\n\nv1.1.0 / 2020-06-07\n===================\n\n  * refactor(ci): update libvips versions\n  * refactor(ci): update libvips versions\n  * refactor(ci): temporarely disable libvips\n  * feat(history): add version changes\n  * feat(ci): enable libvips versions\n  * fix(ci)\n  * fix(ci)\n  * fix(ci): try exporting env vars\n  * fix\n  * feat: add Dockerfile / Docker-driven CI job\n  * fix(co)\n  * feat(version): bump minor to 1\n  * fix(ci): try new install\n  * fix(ci): try new install\n  * fix(ci): add curl package\n  * fix(ci): add curl package\n  * fix(ci): add curl package\n  * fix(ci): try new install\n  * fix(ci): indent style\n  * fix(ci): indent style\n  * fix(ci): indent style\n  * Merge pull request #299 from evanoberholster/master\n  * refactor(ci): disable verions matrix\n  * refactor(docs): use github.com package import path\n  * feat: add test image\n  * Merge pull request #281 from pohang/skip_smartcrop\n  * Merge pull request #317 from larrabee/master\n  * Merge pull request #307 from OrderMyGear/eslam/ch15924/some-product-images-have-a-border\n  * refactor(travis): adjust matrix versions\n  * Merge pull request #333 from simia-tech/master\n  * Fix orientation in vipsFlip call (resizer rotateAndFlipImage)\n  * chore(docs): delete old contributor\n  * enable vipsAffine to use  `Extend` option value and send it to lipvips this will change the default from the one that lipvips use which is `background` to the ones that bimg use which is  `C.VIPS_EXTEND_BLACK` but because the lip add extra 1 or .5 pix the background is considered black anyway so this will not affect anyone but will fix the bug of having border on the right and bottom of some images\n  * Merge pull request #327 from shoreward/master\n  * update libvips documentation links\n  * fix(vips.h): delete preprocessor HEIF version check\n  * Merge pull request #320 from cgroschupp/feat/reduce-png-save-size\n  * use VIPS_FOREIGN_PNG_FILTER_ALL in vips_pngsave_bridge\n  * fix(resizer): add exported error comment\n  * Merge branch 'master' of https://github.com/h2non/bimg\n  * chore(ci): temporarily disable go/libvips versions\n  * Merge pull request #291 from andrioid/patch-1\n  * Merge pull request #293 from team-lab/gammaFilter\n  * Merge pull request #315 from vansante/heif\n  * feat(version): bump patch\n  * Fix bug with images with alpha channel on embeding background\n  * Fix typo\n  * Dont upgrade version, add missing test file\n  * Add support for other HEIF mimetype\n  * Supporting auto rotate for HEIF/HEIC images.\n  * Adding support for heif (i.e. heic files).\n  * Merge branch 'master' into master\n  * feat(travis): add libvips 8.6.0 matrix\n  * GammaFilter\n  * Adds support to Elementary OS Loki\n  * Add min dimension logic to smartcrop\n  * Merge pull request #271 from Dynom/ImprovingAreaWidthTestCoverage\n  * Adding a test case that verifies #250\n  * Bumping versions in preinstall script\n  * Update Transform ICC Profiles with Input Profile\n\nv1.0.19 / 2018-12-09\n====================\n\n  * feat(travis): remove old Go versions, add Go 1.11\n  * Merge pull request #224 from kishorgandham/patch-1\n  * Merge pull request #242 from acaloiaro/documentation-url-updates\n  * Merge pull request #266 from bbernhard/master\n  * Merge pull request #250 from fisherking/master\n  * set vips version to 8.6.5\n  * add support for Debian 9 to preinstall.sh\n  * Merge pull request #265 from c93614/master\n  * Merge branch 'master' into master\n  * Merge pull request #262 from danpersa/update-vips\n  * Updated the libvips tarbal_url and also updated the vips version\n  * Merge pull request #264 from golint-fixer/master\n  * Fix golint import path\n  * Make it compatible with the latest vips. Fixes #255\n  * Fix AreaWidth calculation\n  * Libvips documentation URL and README copy updates\n  * feat(travis): add latest libvips and Go runtime versions\n  * Merge pull request #226 from muxinc/fix-flip-and-flop-axes\n  * Fixes #225 by correcting the flip and flop directions\n  * Fix image crop during embed\n\nv1.0.18 / 2017-12-22\n====================\n\n  * feat(version): bump to v1.0.18\n  * Merge pull request #216 from Bynder/master\n  * Merge pull request #208 from mikestead/feature/webp-lossless\n  * Remove go-debug usage\n  * refactor(docs): remove codesponsor :(\n  * fix(options): use float64 type in Options.Threshold\n  * Merge pull request #206 from tstm/add-trim-options\n  * Add lossless option for saving webp\n  * Set the test file to write its own file\n  * Add the option to use background and threshold options on trim\n\nv1.0.17 / 2017-11-14\n====================\n\n  * feat(version): bump to v1.0.17\n  * refactor(resizer): remove fmt statement\n  * fix(type_test): use string formatting\n  * Merge pull request #207 from traum-ferienwohnungen/nearest-neighbour\n  * Add nearest-neighbour interpolation\n  * Merge pull request #203 from traum-ferienwohnungen/fix_icc_memory_leak\n  * Fix memory leak on icc_transform\n\nv1.0.16 / 2017-10-30\n====================\n\n  * feat(version): bump to v1.0.16\n  * fix(travis): use install directive\n  * Merge branch 'master' of https://github.com/h2non/bimg\n  * feat: add Gopkg manifests, move fixtures to testdata, add vendor dependencies\n  * Merge pull request #202 from openskydoor/openskydoor/fix-build-tag\n  * fix build tag\n  * fix(#199): presinstall.sh tarball download URL\n\nv1.0.15 / 2017-10-05\n====================\n\n  * feat(version): bump to v1.0.15\n  * feat(History): update version changes\n  * Merge pull request #198 from greut/webpload\n  * Add shrink-on-load for webp.\n  * Merge pull request #197 from greut/typos\n  * Small typo.\n  * feat(docs): add codesponsor\n\nv1.0.14 / 2017-09-12\n====================\n\n  * feat(version): bump to v1.0.14\n  * Merge pull request #192 from greut/trim\n  * Adding trim operation.\n  * Merge pull request #191 from greut/alpha4\n  * Update 8.6 to alpha4.\n\nv1.0.13 / 2017-09-11\n====================\n\n  * feat(version). bump to v1.0.13\n  * Merge pull request #190 from greut/typos\n  * Fix typo and small cleanup.\n\nv1.0.12 / 2017-09-10\n====================\n\n  * feat(version): bump to v1.0.12\n  * feat(History): update version changes\n  * Merge branch '99designs-vips-reduce'\n  * fix(reduce): resolve conflicts with master\n  * Use vips reduce when downscaling\n\nv1.0.11 / 2017-09-10\n====================\n\n  * Merge pull request #186 from h2non/fix/#162-resize-garbage-collection\n  * feat(version): bump to v1.0.11\n  * feat(History): update version changes\n  * feat(#189): allow strip image metadata via bimg.Options.StripMetadata = bool\n  * fix(resize): code format issue\n  * refactor(resize): add Go version comment\n  * refactor(tests): fix minor code formatting issues\n  * fix(#162): garbage collection fix. split Resize() implementation for Go runtime specific\n  * feat(travis): add go 1.9\n  * Merge pull request #183 from greut/autorotate\n  * Proper handling of the EXIF cases.\n  * Merge pull request #184 from greut/libvips858\n  * Merge branch 'master' into libvips858\n  * Merge pull request #185 from greut/libvips860\n  * Add libvips 8.6 pre-release\n  * Update to libvips 8.5.8\n  * fix(resize): runtime.KeepAlive is only Go\n  * fix(#159): prevent buf to be freed by the GC before resize function exits\n  * Merge pull request #171 from greut/fix-170\n  * Check the length before jumping into buffer.\n  * Merge pull request #168 from Traum-Ferienwohnungen/icc_transform\n  * Add option to convert embedded ICC profiles\n  * Merge pull request #166 from danjou-a/patch-1\n  * Fix Resize verification value\n  * Merge pull request #165 from greut/libvips846\n  * Testing using libvips8.4.6 from Github.\n\nv1.0.10 / 2017-06-25\n====================\n\n  * feat(version): bump minor\n  * Merge pull request #164 from greut/length\n  * Add Image.Length()\n  * Merge pull request #163 from greut/libvips856\n  * Run libvips 8.5.6 on Travis.\n  * Merge pull request #161 from henry-blip/master\n  * Expose vips cache memory management functions.\n  * feat(docs): add watermark image note in features\n\nv1.0.9 / 2017-05-25\n===================\n\n  * feat(docs): add smart crop note\n  * feat(version): bump to v1.0.9\n  * feat(History): update changes\n  * Merge pull request #156 from Dynom/SmartCropToGravity\n  * Adding a test, verifying both ways of enabling SmartCrop work\n  * Merge pull request #149 from waldophotos/master\n  * Replacing SmartCrop with a Gravity option\n  * refactor(docs): v8.4\n  * Change for older LIBVIPS versions. `vips_bandjoin_const1` is added in libvips 8.2.\n  * Second try, watermarking memory issue fix\n\nv1.0.8 / 2017-05-18\n===================\n\n  * refactor(docs): upgrade recommended version to libvips 8.5\n  * feat(version): bump to 1.0.8\n  * Merge pull request #145 from greut/smartcrop\n  * Merge pull request #155 from greut/libvips8.5.5\n  * Update libvips to 8.5.5.\n  * Adding basic smartcrop support.\n  * Merge pull request #153 from abracadaber/master\n  * Added Linux Mint 17.3+ distro names\n  * feat(docs): add new maintainer notice (thanks to @kirillDanshin)\n  * Merge pull request #152 from greut/libvips85\n  * Download latest version of libvips from github.\n  * Merge pull request #147 from h2non/revert-143-master\n  * Revert \"Fix for memory issue when watermarking images\"\n  * Merge pull request #146 from greut/minor-major\n  * Merge pull request #143 from waldophotos/master\n  * Merge pull request #144 from greut/go18\n  * Fix tests where minor/major were mixed up\n  * Enabled go 1.8 builds.\n  * Fix the unref of images, when image isn't transparent\n  * Fix for memory issue when watermarking images\n  * feat(docs): add maintainers sections\n  * Merge pull request #132 from jaume-pinyol/WATERMARK_SUPPORT\n  * Add support for image watermarks\n  * Merge pull request #131 from greut/versions\n  * Running tests on more specific versions.\n  * refactor(preinstall.sh): remove deprecation notice\n  * Update preinstall.sh\n  * fix(requirements): required libvips 7.42\n  * fix(History): typo\n  * chore(History): add breaking change note\n\nv1.0.7 / 2017-01-13\n===================\n\n  * feat(History): update changes\n  * Merge pull request #124 from greut/tiffsave\n  * feat(version): bump to v1.0.7\n  * Merge pull request #129 from danpersa/fix-128\n  * Fix: Crop is doing resize. Closes #128\n  * Refactoring IsTypeSupport to deal with save.\n  * Adding support for TIFF save.\n  * Saving to TIFF should also fail\n  * feat(docs): link to preinstall.sh from bimg reposityr\n  * feat: adds preinstall.sh from sharp project\n  * Merge pull request #122 from greut/magick\n  * Raise an error when trying to save as MAGICK type\n  * Testing the formats that cannot be saved\n  * feat(docs): update badges\n  * feat(docs): update badges\n\nv1.0.6 / 2016-11-12\n===================\n\n  * feat(version): bump to 1.0.6\n  * Merge pull request #118 from shoeboxapp/png16\n  * Merge pull request #119 from greut/jp2\n  * Merge pull request #121 from greut/matrix\n  * Build against various libvips versions\n  * Do not free a pointer you don't own\n  * Adding JPEG2000 file for the type tests\n  * Cleaner fix\n  * Handle 16-bit PNGs\n  * Fix: remove travis 1.5 golang\n  * Merge pull request #120 from chonthu/patch-1\n  * Update README.md\n  * Merge pull request #115 from h2non/develop\n  * Merge pull request #113 from h2non/develop\n  * Merge pull request #112 from h2non/develop\n  * Merge pull request #110 from h2non/develop\n  * Merge pull request #109 from h2non/develop\n\nv1.0.5 / 2016-10-01\n===================\n\n  * feat(options): add link to libvips API docs for Extend\n  * feat(version): bump to 1.0.5\n  * fix(options): code style comment\n  * refactor(resize): use not equal operator (again)\n  * fix(#106): allow custom area extraction without x/y axis\n  * feat(#92): support Extend param with optional background\n\nv1.0.4 / 2016-09-29\n===================\n\n  * feat(version): bump to 1.0.4\n  * fix(vips): check magick type support\n\nv1.0.3 / 2016-09-28\n===================\n\n  * feat(docs): update History with API changes\n  * feat(version): bump to 1.0.3\n  * fix(background): pass proper background RGB color\n  * feat(types): infer types in runtime\n  * fix(type): svg type checking\n  * fix(type): check buffer length\n  * refactor(types): do proper image typ casting\n  * refactor(docs)\n  * fix(lint): fix code style\n\nv1.0.2 / 2016-09-27\n===================\n\n  * merge(master)\n  * feat(version): bump to 1.0.2\n  * feat(#95): support multiple formats\n  * fix(tests)\n  * Merge pull request #108 from mikepulaski/master\n  * Auto-width and height calculations now round instead of floor.\n  * Merge pull request #105 from jibingeo/master\n  * Fixes issue with typecast from GType to int\n  * Add test to check ICC profile\n  * Merge pull request #104 from nvartolomei/png-16bit-alpha-background\n  * fix(flatten): fix flattening with background for 16bit transparent pngs\n  * Merge pull request #102 from aarti/master\n  * fix go vet issues\n  * Build on Go1.7\n  * Update travis build\n  * Adding GIF, PDF and SVG support (libvips 8.3)\n  * Documentation error\n  * Merge pull request #96 from greut/rot45\n  * Add support for 45° rotation.\n  * Merge pull request #92 from h2non/develop\n\nv1.0.1 / 2016-06-22\n===================\n\n  * chore(version): bump to 1.0.1\n  * Merge pull request #91 from h2non/master\n  * Merge pull request #90 from aarti/master\n  * Take care to not dereference the original image a second time\n  * Merge pull request #88 from blippar/master\n  * Merge pull request #1 from blippar/check_alpha\n  * Fix formatting\n  * Check if there is an alpha channel before flattening\n  * feat(docs): add production note\n  * Merge pull request #86 from h2non/develop\n  * Merge pull request #85 from h2non/develop\n\nv1.0.0 / 2016-04-21\n===================\n\n  * feat(docs): use v1 in go get\n  * refactor(travis): remove duplicated command\n  * feat(version): v1 release. see history for details\n\nv0.1.24 / 2016-03-01\n====================\n\n  * fix(docs): minor typo\n  * Merge pull request #81 from h2non/develop\n  * feat(travis): use go 1.6\n  * feat(docs): add coverage badge\n  * Merge pull request #79 from h2non/develop\n  * Merge pull request #77 from h2non/develop\n  * Merge pull request #76 from h2non/develop\n\n0.1.24 / 2016-02-09\n===================\n\n  * feat(version): bump\n  * fix(resize): auto rotate image before resize calculus\n\n0.1.23 / 2016-02-05\n===================\n\n  * feat(versio): bump\n  * fix(rotation)\n\n0.1.22 / 2016-01-30\n===================\n\n  * feat(travis): add GO 1.5\n  * feat(version): bump\n  * fix(rotate): pre-rotate image based on EXIT orientation\n  * Merge pull request #75 from h2non/master\n  * feat(test): resize only by height o width\n  * merge(upstream)\n  * feat(#72): add helpful debug info in docs\n  * feat(test): add vertical image fixtures with multiple test cases\n  * feat(docs): add goreport badge\n  * Merge pull request #67 from h2non/master\n  * Merge pull request #66 from cneerdaels/sharpen\n  * Added interface and test for sharpen\n  * refactor(resize): clone options by value\n  * merge(upstream)\n  * refactor(docs)\n  * refactor(resize): simplify code\n  * fix(docs): typo\n  * feat(docs): add toc, remove API docs\n  * merge(master)\n  * refactor(vips): define constant\n  * fix(docs): typo\n  * feat(#60): support zero top and left params in extract operation\n  * refactor(docs): support with libvips 8.0 is stable for now\n  * feat(docs): add libvips version compatibility note\n  * refactor(type): simplify image type matching\n\n0.1.21 / 2015-09-29\n===================\n\n  * feat(version): bump\n  * fix(#56)\n  * merge(#55)\n  * refactor(#55): minor changes, use proper declarations, unref image\n  * - Adding a Background option when flattening out a transparent PNG\n  * feat(docs): update benchmarks\n  * feat(docs): add list of contributors\n  * feat(docs): update API docs\n  * feat(#52): add test case\n  * vips_gaussblur: remove dependency on libmath\n  * vips__gaussblur: renamed to vips_gaussblur_bridge\n  * resize: move effects to more explicit methods\n  * vips__gaussblur: add the missing sentinel\n  * transformImage: apply gaussian blur if needed\n  * vips: add a vips__gaussblur method\n\n0.1.20 / 2015-09-08\n===================\n\n  * feat(version): bump\n  * merge(zllak-debian)\n  * merge(zllak-debian)\n  * vips.h: problem with vips_init()\n  * vips.h: fail to build on Debian Jessie\n  * refactor(vips): free watermark cache. refactor vips.h\n  * refactor(vips): use shortcut to VipsImage C type\n  * fix(docs): remove old badge\n\n0.1.19 / 2015-07-28\n===================\n\n  * version(bump)\n  * feat(#49)\n  * feat(#49)\n  * refactor(docs): description\n\n0.1.18 / 2015-07-11\n===================\n\n  * feat(version): bump\n  * refactor(colourspace)\n  * feat(docs): add force resize example\n  * fix(#46): transform to proper image size\n  * feat: remove fixture\n  * refactor(#47): minor refactors, code normalization and test coverage\n  * Merge pull request #47 from greut/45-grayscale\n  * Add support for colourspace (fix #45)\n  * fix(resize): default options\n  * refactor(resize)\n  * fix(#46): infer resize operation\n  * fix(#46): infer resize operation\n  * refactor(docs): description\n  * fix(docs)\n  * fix(test): bad option field\n\n0.1.17 / 2015-06-13\n===================\n\n  * feat(version): bump\n  * feat(docs): update API\n  * feat: allow to remove ICC profile metadata\n\n0.1.16 / 2015-06-13\n===================\n\n  * feat: save a RGB colorspace\n  * feat(version): bump\n  * fix(#43)\n\n0.1.15 / 2015-06-12\n===================\n\n  * feat(version): bump\n  * feat(docs): update API docs\n  * merge(#42)\n  * fix(#42): change interlace type. fix C bindings\n  * This should not have been added.\n  * Added progressive jpeg functionality.\n  * fix(docs): minor typo fixes\n  * feat(docs): add openslide how to install. Related with #40\n  * refactor(docs): feature list\n  * refactor(vips): switch option\n  * refactor(vips): remove debug statement, add comments\n  * Merge pull request #39 from bfitzsimmons/patch-1\n  * Fixed the JPEG watermark benchmark.\n\n0.1.14 / 2015-05-24\n===================\n\n  * feat(version): bump\n  * refactor(docs): description\n  * refactor(docs): description\n  * merge\n  * refactor(vips)\n  * fix(badge)\n  * refactor(badge): release\n  * refactor(docs): description\n  * refactor(docs): remove beta note\n  * fix(docs): watermark example\n\n0.1.13 / 2015-04-27\n===================\n\n  * feat(version): bump\n  * feat(crop): add method shortcuts for crop\n\n0.1.12 / 2015-04-26\n===================\n\n  * feat(version): bump\n  * fix(#35): save webp\n  * fix(travis): fuck coveralls\n\n0.1.11 / 2015-04-25\n===================\n\n  * feat(version): bump\n  * refactor(docs): description\n  * fix(#32): bad crop\n  * fix(#33): bad auto rotatino\n  * refactor(docs): links\n  * merge\n  * feat(docs): update API\n  * refactor(docs): description\n  * fix(test): resize\n\n0.1.10 / 2015-04-16\n===================\n\n  * fix(test)\n  * feat(version): bump\n  * fix(#31)\n  * refactor(vips): remove obvious code\n\n0.1.9 / 2015-04-15\n==================\n\n  * ffeat(version): bump\n  * fix(#30): one concurrent thread by default\n  * refactor(docs)\n  * refactor(docs): update badge\n  * refactor(file)\n  * feat(docs): add imaginary link\n  * feat(docs): add imaginary link\n\n0.1.8 / 2015-04-12\n==================\n\n  * feat(version): bump\n  * fix(vips): panic error on exif orientation\n  * refactor(watermark): auto define width\n  * fix(#28): zoom requires extract params\n  * fix(#28): zoom requires extract params\n  * refactor: comparse as pure string\n\n0.1.7 / 2015-04-11\n==================\n\n  * feat(version): bump\n  * feat(docs): update docs\n  * feat(test): better coverage for vips interface\n  * refactor(vips.h): watermark replicate\n  * refactor: vips.h, fix(docs):\n\n0.1.6 / 2015-04-11\n==================\n\n  * refactor(vips.h)\n  * refactor(resize)\n  * feat(docs): update benchmark\n  * refactor(debug)\n  * refactor: remove colorspace feature\n  * feat(version): bump\n  * feat(#15): more benchmarks\n  * feat: add fixture\n  * feat(#27, #25): new features\n  * feat(#26): support zoom. several refactors and fixes\n  * feat(#25, #21)\n\n0.1.5 / 2015-04-08\n==================\n\n  * feat(version): bump\n  * fix(vips): clean reference for interpolator\n  * feat(image): add method to retrieve the image\n  * feat(docs): update\n  * feat: add tests\n\n0.1.4 / 2015-04-08\n==================\n\n  * feat(version): bump\n  * feat(image): pass gravity to crop\n  * fix(rotate): max angle to 270\n  * refactor(vips): rename C bridge function\n\n0.1.3 / 2015-04-08\n==================\n\n  * feat(version): bump\n  * refactor(resize): remove debug statement\n  * feat(test): vips\n  * feat(#20): support flop operation (interface broken, sorry im still beta)\n  * fix(test): image\n  * fix(image): tests\n  * fix(image): tests\n  * feat(#19): maximum image size\n  * feat(#15): add benchmark tests\n  * feat(#18, #17)\n  * fix(vips): bad argument\n  * fix(docs): example\n  * fix(docs): description\n  * feat(docs): add link to memory tests\n  * refactor(docs): description\n  * fix(docs): description\n  * refactor(docs): description\n  * fix(docs): description\n  * refactor(docs): normalize description and examples\n  * refactor(docs): normalize description and examples\n  * refactor(docs): description\n\n0.1.2 / 2015-04-07\n==================\n\n  * feat(version): chore\n  * fix(extract): detect area options\n  * feat(version): bump\n  * feat(docs): force update\n\n0.1.1 / 2015-04-07\n==================\n\n  * feat(#15): add benchmark tests\n  * fix(vips): memory inconsistency\n  * merge\n  * fix: possible leaks\n  * refactor(docs)\n  * feat(travis): add coveralls support\n  * feat(travis): add coveralls support\n  * fix(docs): add releases link\n\n0.1.0 / 2015-04-07\n==================\n\n  * fix(test)\n  * refactor(docs)\n  * fix(test): image metadata\n  * fix(test): image metadata\n  * feat(docs): add API and examples\n  * refactor(resize): extract\n  * feat: add fixtures\n  * fix(resize): support rotate\n  * refactor(resize)\n  * feat(#13): metadata tests\n  * refactor: bindings\n  * refactor(vips)\n  * refactor(vips)\n  * refactor: remove file\n  * feat(metadata): add tests\n  * refactor(docs)\n\n0.1.0-beta.0 / 2015-04-06\n=========================\n\n  * fix(crop): tests\n  * refactor: crop and tests\n  * feat: support resize and enlarge images\n  * feat: add file helper\n  * feat: support multiple outputs\n  * feat(#6, #10, #11)\n  * refactor\n  * refactor. feat(test): add fixtures\n  * refactor(vips): check image type\n  * refactor(docs): go version\n  * feat(docs): add Go version support\n  * update travis.yaml\n  * feat(#9): add Travis support\n  * feat(#8): add type alias\n  * feat(docs): add badge\n  * refactor: vips.h\n  * feat(docs): add API example\n  * refactor(type)\n  * refactor: indent style\n  * feat(#3, #5): support image operations\n  * feat(#1): initial implementation\n  * feat: add version file\n  * refactor(docs): description\n  * feat: add file\n  * feat: add readme\n\nv1.1.3 / 2020-08-04\n==================\n\n  * fix(ci): disable <8.7 libvips\n  * feat: autorotate\n  * feat: bump version\n  * Merge pull request #347 from vansante/master\n  * Merge pull request #345 from fredeastside/more_exif_data\n  * add more exif data to metadata\n  * Merge pull request #3 from laurentiuilie/add-support-for-heifs-file\n  * add brands heis, hevc\n  * Merge pull request #2 from laurentiuilie/add-support-for-heifs-file\n  * add test image for heifs\n  * remove test file and add the check\n  * add support for HEIFS file\n  * fix(palette): indentation\n  * Merge pull request #337 from theplant/master\n  * support Palette option for png\n\nv1.1.2 / 2020-06-08\n===================\n\n  * fix(#335): disable image flatten type conditional\n\nv1.1.1 / 2020-06-08\n===================\n\n  * feat(version): bump patch\n  * refactor(docs): add libvips install reference\n  * fix(ci): disable old libvips versions\n  * fix(install): use latest libvips version\n  * fix(tests): add heif exception in libvips < 8.8\n  * refactor(ci): use libvips 8.7\n  * fix(History): use proper version\n\n\nv1.1.0 / 2020-06-07\n===================\n\n  * feat(ci): enable libvips versions\n  * fix(ci)\n  * fix(ci)\n  * fix(ci): try exporting env vars\n  * fix\n  * feat: add Dockerfile / Docker-driven CI job\n  * fix(co)\n  * feat(version): bump minor to 1\n  * fix(ci): try new install\n  * fix(ci): try new install\n  * fix(ci): add curl package\n  * fix(ci): add curl package\n  * fix(ci): add curl package\n  * fix(ci): try new install\n  * fix(ci): indent style\n  * fix(ci): indent style\n  * fix(ci): indent style\n  * Merge pull request #299 from evanoberholster/master\n  * refactor(ci): disable verions matrix\n  * refactor(docs): use github.com package import path\n  * feat: add test image\n  * Merge pull request #281 from pohang/skip_smartcrop\n  * Merge pull request #317 from larrabee/master\n  * Merge pull request #307 from OrderMyGear/eslam/ch15924/some-product-images-have-a-border\n  * refactor(travis): adjust matrix versions\n  * Merge pull request #333 from simia-tech/master\n  * Fix orientation in vipsFlip call (resizer rotateAndFlipImage)\n  * chore(docs): delete old contributor\n  * enable vipsAffine to use  `Extend` option value and send it to lipvips this will change the default from the one that lipvips use which is `background` to the ones that bimg use which is  `C.VIPS_EXTEND_BLACK` but because the lip add extra 1 or .5 pix the background is considered black anyway so this will not affect anyone but will fix the bug of having border on the right and bottom of some images\n  * Merge pull request #327 from shoreward/master\n  * update libvips documentation links\n  * fix(vips.h): delete preprocessor HEIF version check\n  * Merge pull request #320 from cgroschupp/feat/reduce-png-save-size\n  * use VIPS_FOREIGN_PNG_FILTER_ALL in vips_pngsave_bridge\n  * fix(resizer): add exported error comment\n  * Merge branch 'master' of https://github.com/h2non/bimg\n  * chore(ci): temporarily disable go/libvips versions\n  * Merge pull request #291 from andrioid/patch-1\n  * Merge pull request #293 from team-lab/gammaFilter\n  * Merge pull request #315 from vansante/heif\n  * feat(version): bump patch\n  * Fix bug with images with alpha channel on embeding background\n  * Fix typo\n  * Dont upgrade version, add missing test file\n  * Add support for other HEIF mimetype\n  * Supporting auto rotate for HEIF/HEIC images.\n  * Adding support for heif (i.e. heic files).\n  * Merge branch 'master' into master\n  * feat(travis): add libvips 8.6.0 matrix\n  * GammaFilter\n  * Adds support to Elementary OS Loki\n  * Add min dimension logic to smartcrop\n  * Merge pull request #271 from Dynom/ImprovingAreaWidthTestCoverage\n  * Adding a test case that verifies #250\n  * Bumping versions in preinstall script\n  * Update Transform ICC Profiles with Input Profile\n\n## v1.0.18 / 2017-12-22\n\n  * Merge pull request #216 from Bynder/master\n  * Merge pull request #208 from mikestead/feature/webp-lossless\n  * Remove go-debug usage\n  * refactor(docs): remove codesponsor :(\n  * fix(options): use float64 type in Options.Threshold\n  * Merge pull request #206 from tstm/add-trim-options\n  * Add lossless option for saving webp\n  * Set the test file to write its own file\n  * Add the option to use background and threshold options on trim\n\n## v1.0.17 / 2017-11-14\n\n  * refactor(resizer): remove fmt statement\n  * fix(type_test): use string formatting\n  * Merge pull request #207 from traum-ferienwohnungen/nearest-neighbour\n  * Add nearest-neighbour interpolation\n  * Merge pull request #203 from traum-ferienwohnungen/fix_icc_memory_leak\n  * Fix memory leak on icc_transform\n\n## v1.0.16 / 2017-10-30\n\n  * fix(travis): use install directive\n  * Merge branch 'master' of https://github.com/h2non/bimg\n  * feat: add Gopkg manifests, move fixtures to testdata, add vendor dependencies\n  * Merge pull request #202 from openskydoor/openskydoor/fix-build-tag\n  * fix build tag\n  * fix(#199): presinstall.sh tarball download URL\n\n## v1.0.15 / 2017-10-05\n\n  * Merge pull request #198 from greut/webpload\n  * Add shrink-on-load for webp.\n  * Merge pull request #197 from greut/typos\n  * Small typo.\n  * feat(docs): add codesponsor\n\n## v1.0.14 / 2017-09-12\n\n  * Merge pull request #192 from greut/trim\n  * Adding trim operation.\n  * Merge pull request #191 from greut/alpha4\n  * Update 8.6 to alpha4.\n\n## v1.0.13 / 2017-09-11\n\n  * Merge pull request #190 from greut/typos\n  * Fix typo and small cleanup.\n\n## v1.0.12 / 2017-09-10\n\n  * Merge branch '99designs-vips-reduce'\n  * fix(reduce): resolve conflicts with master\n  * Use vips reduce when downscaling\n\n## v1.0.11 / 2017-09-10\n\n  * feat(#189): allow strip image metadata via bimg.Options.StripMetadata = bool\n  * fix(resize): code format issue\n  * refactor(resize): add Go version comment\n  * refactor(tests): fix minor code formatting issues\n  * fix(#162): garbage collection fix. split Resize() implementation for Go runtime specific\n  * feat(travis): add go 1.9\n  * Merge pull request #183 from greut/autorotate\n  * Proper handling of the EXIF cases.\n  * Merge pull request #184 from greut/libvips858\n  * Merge branch 'master' into libvips858\n  * Merge pull request #185 from greut/libvips860\n  * Add libvips 8.6 pre-release\n  * Update to libvips 8.5.8\n  * fix(resize): runtime.KeepAlive is only Go\n  * fix(#159): prevent buf to be freed by the GC before resize function exits\n  * Merge pull request #171 from greut/fix-170\n  * Check the length before jumping into buffer.\n  * Merge pull request #168 from Traum-Ferienwohnungen/icc_transform\n  * Add option to convert embedded ICC profiles\n  * Merge pull request #166 from danjou-a/patch-1\n  * Fix Resize verification value\n  * Merge pull request #165 from greut/libvips846\n  * Testing using libvips8.4.6 from Github.\n\n## v1.0.10 / 2017-06-25\n\n  * Merge pull request #164 from greut/length\n  * Add Image.Length()\n  * Merge pull request #163 from greut/libvips856\n  * Run libvips 8.5.6 on Travis.\n  * Merge pull request #161 from henry-blip/master\n  * Expose vips cache memory management functions.\n  * feat(docs): add watermark image note in features\n\n## v1.0.9 / 2017-05-25\n\n  * Merge pull request #156 from Dynom/SmartCropToGravity\n  * Adding a test, verifying both ways of enabling SmartCrop work\n  * Merge pull request #149 from waldophotos/master\n  * Replacing SmartCrop with a Gravity option\n  * refactor(docs): v8.4\n  * Change for older LIBVIPS versions. `vips_bandjoin_const1` is added in libvips 8.2.\n  * Second try, watermarking memory issue fix\n\n## v1.0.8 / 2017-05-18\n\n  * Merge pull request #145 from greut/smartcrop\n  * Merge pull request #155 from greut/libvips8.5.5\n  * Update libvips to 8.5.5.\n  * Adding basic smartcrop support.\n  * Merge pull request #153 from abracadaber/master\n  * Added Linux Mint 17.3+ distro names\n  * feat(docs): add new maintainer notice (thanks to @kirillDanshin)\n  * Merge pull request #152 from greut/libvips85\n  * Download latest version of libvips from github.\n  * Merge pull request #147 from h2non/revert-143-master\n  * Revert \"Fix for memory issue when watermarking images\"\n  * Merge pull request #146 from greut/minor-major\n  * Merge pull request #143 from waldophotos/master\n  * Merge pull request #144 from greut/go18\n  * Fix tests where minor/major were mixed up\n  * Enabled go 1.8 builds.\n  * Fix the unref of images, when image isn't transparent\n  * Fix for memory issue when watermarking images\n  * feat(docs): add maintainers sections\n  * Merge pull request #132 from jaume-pinyol/WATERMARK_SUPPORT\n  * Add support for image watermarks\n  * Merge pull request #131 from greut/versions\n  * Running tests on more specific versions.\n  * refactor(preinstall.sh): remove deprecation notice\n  * Update preinstall.sh\n  * fix(requirements): required libvips 7.42\n  * fix(History): typo\n  * chore(History): add breaking change note\n\n## v1.0.7 / 13-01-2017\n\n- fix(#128): crop image calculation for missing width or height axis.\n- feat: add TIFF save output format (**note**: this introduces a minor interface breaking change in `bimg.IsImageTypeSupportedByVips` auxiliary function).\n\n## v1.0.6 / 12-11-2016\n\n- feat(#118): handle 16-bit PNGs.\n- feat(#119): adds JPEG2000 file for the type tests.\n- feat(#121): test bimg against multiple libvips versions.\n\n## v1.0.5 / 01-10-2016\n\n- feat(#92): support Extend param with optional background.\n- fix(#106): allow image area extraction without explicit x/y axis.\n- feat(api): add Extend type with `libvips` enum alias.\n\n## v1.0.4 / 29-09-2016\n\n- fix(#111): safe check of magick image type support.\n\n## v1.0.3 / 28-09-2016\n\n- fix(#95): better image type inference and support check.\n- fix(background): pass proper background RGB color for PNG image conversion.\n- feat(types): validate supported image types by current `libvips` compilation.\n- feat(types): consistent SVG image checking.\n- feat(api): add public functions `VipsIsTypeSupported()`, `IsImageTypeSupportedByVips()` and `IsSVGImage()`.\n\n## v1.0.2 / 27-09-2016\n\n- feat(#95): support GIF, SVG and PDF formats.\n- fix(#108): auto-width and height calculations now round instead of floor.\n\n## v1.0.1 / 22-06-2016\n\n- fix(#90): Do not not dereference the original image a second time.\n\n## v1.0.0 / 21-04-2016\n\n- refactor(api): breaking changes: normalize public members to follow Go naming idioms.\n- feat(version): bump to major version. API contract won't be compromised in `v1`.\n- feat(docs): add missing inline godoc documentation.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.060546875,
          "content": "The MIT License\n\nCopyright (c) Tomas Aparicio and contributors\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.8310546875,
          "content": "# bimg [![GoDoc](https://godoc.org/github.com/h2non/bimg?status.svg)](https://godoc.org/github.com/h2non/bimg) [![Coverage Status](https://coveralls.io/repos/github/h2non/bimg/badge.svg?branch=master)](https://coveralls.io/github/h2non/bimg?branch=master) ![License](https://img.shields.io/badge/license-MIT-blue.svg)\n\nSmall [Go](http://golang.org) package for fast high-level image processing using [libvips](https://github.com/jcupitt/libvips) via C bindings, providing a simple [programmatic API](#examples).\n\nbimg was designed to be a small and efficient library supporting common [image operations](#supported-image-operations) such as crop, resize, rotate, zoom or watermark. It can read JPEG, PNG, WEBP natively, and optionally TIFF, PDF, GIF and SVG formats if `libvips@8.3+` is compiled with proper library bindings. Lastly AVIF is supported as of `libvips@8.9+`. For AVIF support `libheif` needs to be [compiled with an applicable AVIF en-/decoder](https://github.com/strukturag/libheif#compiling).\n\nbimg is able to output images as JPEG, PNG and WEBP formats, including transparent conversion across them.\n\nbimg uses internally libvips, a powerful library written in C for image processing which requires a [low memory footprint](https://github.com/jcupitt/libvips/wiki/Speed_and_Memory_Use)\nand it's typically 4x faster than using the quickest ImageMagick and GraphicsMagick settings or Go native `image` package, and in some cases it's even 8x faster processing JPEG images.\n\nIf you're looking for an HTTP based image processing solution, see [imaginary](https://github.com/h2non/imaginary).\n\nbimg was heavily inspired in [sharp](https://github.com/lovell/sharp), its homologous package built for [node.js](http://nodejs.org). bimg is used in production environments processing thousands of images per day.\n\n**v1 notice**: `bimg` introduces some minor breaking changes in `v1` release.\nIf you're using `gopkg.in`, you can still rely in the `v0` without worrying about API breaking changes.\n\n## Contents\n\n- [Supported image operations](#supported-image-operations)\n- [Prerequisites](#prerequisites)\n- [Installation](#installation)\n- [Performance](#performance)\n- [Benchmark](#benchmark)\n- [Examples](#examples)\n- [Debugging](#debugging)\n- [API](#api)\n- [Authors](#authors)\n- [Credits](#credits)\n\n## Supported image operations\n\n- Resize\n- Enlarge\n- Crop (including smart crop support, libvips 8.5+)\n- Rotate (with auto-rotate based on EXIF orientation)\n- Flip (with auto-flip based on EXIF metadata)\n- Flop\n- Zoom\n- Thumbnail\n- Extract area\n- Watermark (using text or image)\n- Gaussian blur effect\n- Custom output color space (RGB, grayscale...)\n- Format conversion (with additional quality/compression settings)\n- EXIF metadata (size, alpha channel, profile, orientation...)\n- Trim (libvips 8.6+)\n\n## Prerequisites\n\n- [libvips](https://github.com/libvips/libvips) 8.3+ (8.8+ recommended)\n- C compatible compiler such as gcc 4.6+ or clang 3.0+\n- Go 1.3+\n\n**Note**: \n * `libvips` v8.3+ is required for GIF, PDF and SVG support.\n * `libvips` v8.9+ is required for AVIF support. `libheif` compiled with a AVIF en-/decoder also needs to be present.\n\n## Installation\n\n```bash\ngo get -u github.com/h2non/bimg\n```\n\n### libvips\n\nFollow `libvips` installation instructions:\n\n[https://libvips.github.io/libvips/install.html](https://libvips.github.io/libvips/install.html)\n\n##### Installation script\n\n**Note**: install script is officially deprecated, it might not work as expected. We recommend following [libvips install](https://libvips.github.io/libvips/install.html) instructions.\n\nRun the following script as `sudo` (supports OSX, Debian/Ubuntu, Redhat, Fedora, Amazon Linux):\n```bash\ncurl -s https://raw.githubusercontent.com/h2non/bimg/master/preinstall.sh | sudo bash -\n```\n\nIf you want to take the advantage of [OpenSlide](http://openslide.org/), simply add `--with-openslide` to enable it:\n```bash\ncurl -s https://raw.githubusercontent.com/h2non/bimg/master/preinstall.sh | sudo bash -s --with-openslide\n```\n\nThe [install script](https://github.com/h2non/bimg/blob/master/preinstall.sh) requires `curl` and `pkg-config`.\n\n## Performance\n\nlibvips is probably the fastest open source solution for image processing.\nHere you can see some performance test comparisons for multiple scenarios:\n\n- [libvips speed and memory usage](https://github.com/jcupitt/libvips/wiki/Speed-and-memory-use)\n\n## Benchmark\n\nTested using Go 1.5.1 and libvips-7.42.3 in OSX i7 2.7Ghz\n```\nBenchmarkRotateJpeg-8     \t      20\t  64686945 ns/op\nBenchmarkResizeLargeJpeg-8\t      20\t  63390416 ns/op\nBenchmarkResizePng-8      \t     100\t  18147294 ns/op\nBenchmarkResizeWebP-8     \t     100\t  20836741 ns/op\nBenchmarkConvertToJpeg-8  \t     100\t  12831812 ns/op\nBenchmarkConvertToPng-8   \t      10\t 128901422 ns/op\nBenchmarkConvertToWebp-8  \t      10\t 204027990 ns/op\nBenchmarkCropJpeg-8       \t      30\t  59068572 ns/op\nBenchmarkCropPng-8        \t      10\t 117303259 ns/op\nBenchmarkCropWebP-8       \t      10\t 107060659 ns/op\nBenchmarkExtractJpeg-8    \t      50\t  30708919 ns/op\nBenchmarkExtractPng-8     \t    3000\t    595546 ns/op\nBenchmarkExtractWebp-8    \t    3000\t    386379 ns/op\nBenchmarkZoomJpeg-8       \t      10\t 160005424 ns/op\nBenchmarkZoomPng-8        \t      30\t  44561047 ns/op\nBenchmarkZoomWebp-8       \t      10\t 126732678 ns/op\nBenchmarkWatermarkJpeg-8  \t      20\t  79006133 ns/op\nBenchmarkWatermarPng-8    \t     200\t   8197291 ns/op\nBenchmarkWatermarWebp-8   \t      30\t  49360369 ns/op\n```\n\n## Examples\n\n```go\nimport (\n  \"fmt\"\n  \"os\"\n  \"github.com/h2non/bimg\"\n)\n```\n\n#### Resize\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nnewImage, err := bimg.NewImage(buffer).Resize(800, 600)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nsize, err := bimg.NewImage(newImage).Size()\nif size.Width == 800 && size.Height == 600 {\n  fmt.Println(\"The image size is valid\")\n}\n\nbimg.Write(\"new.jpg\", newImage)\n```\n\n#### Rotate\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nnewImage, err := bimg.NewImage(buffer).Rotate(90)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nbimg.Write(\"new.jpg\", newImage)\n```\n\n#### Convert\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nnewImage, err := bimg.NewImage(buffer).Convert(bimg.PNG)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nif bimg.NewImage(newImage).Type() == \"png\" {\n  fmt.Fprintln(os.Stderr, \"The image was converted into png\")\n}\n```\n\n#### Force resize\n\nForce resize operation without preserving the aspect ratio:\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nnewImage, err := bimg.NewImage(buffer).ForceResize(1000, 500)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nsize := bimg.Size(newImage)\nif size.Width != 1000 || size.Height != 500 {\n  fmt.Fprintln(os.Stderr, \"Incorrect image size\")\n}\n```\n\n#### Custom colour space (black & white)\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nnewImage, err := bimg.NewImage(buffer).Colourspace(bimg.INTERPRETATION_B_W)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\ncolourSpace, _ := bimg.ImageInterpretation(newImage)\nif colourSpace != bimg.INTERPRETATION_B_W {\n  fmt.Fprintln(os.Stderr, \"Invalid colour space\")\n}\n```\n\n#### Custom options\n\nSee [Options](https://godoc.org/github.com/h2non/bimg#Options) struct to discover all the available fields\n\n```go\noptions := bimg.Options{\n  Width:        800,\n  Height:       600,\n  Crop:         true,\n  Quality:      95,\n  Rotate:       180,\n  Interlace:    true,\n}\n\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nnewImage, err := bimg.NewImage(buffer).Process(options)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nbimg.Write(\"new.jpg\", newImage)\n```\n\n#### Watermark\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nwatermark := bimg.Watermark{\n  Text:       \"Chuck Norris (c) 2315\",\n  Opacity:    0.25,\n  Width:      200,\n  DPI:        100,\n  Margin:     150,\n  Font:       \"sans bold 12\",\n  Background: bimg.Color{255, 255, 255},\n}\n\nnewImage, err := bimg.NewImage(buffer).Watermark(watermark)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nbimg.Write(\"new.jpg\", newImage)\n```\n\n#### Fluent interface\n\n```go\nbuffer, err := bimg.Read(\"image.jpg\")\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\nimage := bimg.NewImage(buffer)\n\n// first crop image\n_, err := image.CropByWidth(300)\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\n// then flip it\nnewImage, err := image.Flip()\nif err != nil {\n  fmt.Fprintln(os.Stderr, err)\n}\n\n// save the cropped and flipped image\nbimg.Write(\"new.jpg\", newImage)\n```\n\n## Debugging\n\nRun the process passing the `DEBUG` environment variable\n```\nDEBUG=bimg ./app\n```\n\nEnable libvips traces (note that a lot of data will be written in stdout):\n```\nVIPS_TRACE=1 ./app\n```\n\nYou can also dump a core on failure, as [John Cuppit](https://github.com/jcupitt) said:\n```c\ng_log_set_always_fatal(\n                G_LOG_FLAG_RECURSION |\n                G_LOG_FLAG_FATAL |\n                G_LOG_LEVEL_ERROR |\n                G_LOG_LEVEL_CRITICAL |\n                G_LOG_LEVEL_WARNING );\n```\n\nOr set the G_DEBUG environment variable:\n```\nexport G_DEBUG=fatal-warnings,fatal-criticals\n```\n\n## API\n\nSee [godoc reference](https://godoc.org/github.com/h2non/bimg) for detailed API documentation.\n\n## Authors\n\n- [Tomás Aparicio](https://github.com/h2non) - Original author and architect.\n\n## Credits\n\nPeople who recurrently contributed to improve `bimg` in some way.\n\n- [John Cupitt](https://github.com/jcupitt)\n- [Yoan Blanc](https://github.com/greut)\n- [Christophe Eblé](https://github.com/chreble)\n- [Brant Fitzsimmons](https://github.com/bfitzsimmons)\n- [Thomas Meson](https://github.com/zllak)\n\nThank you!\n\n## License\n\nMIT - Tomas Aparicio\n\n[![views](https://sourcegraph.com/api/repos/github.com/h2non/bimg/.counters/views.svg)](https://sourcegraph.com/github.com/h2non/bimg)\n"
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 0.349609375,
          "content": "package bimg\n\nimport \"io/ioutil\"\n\n// Read reads all the content of the given file path\n// and returns it as byte buffer.\nfunc Read(path string) ([]byte, error) {\n\treturn ioutil.ReadFile(path)\n}\n\n// Write writes the given byte buffer into disk\n// to the given file path.\nfunc Write(path string, buf []byte) error {\n\treturn ioutil.WriteFile(path, buf, 0644)\n}\n"
        },
        {
          "name": "file_test.go",
          "type": "blob",
          "size": 0.58984375,
          "content": "package bimg\n\nimport (\n\t\"testing\"\n)\n\nfunc TestRead(t *testing.T) {\n\tbuf, err := Read(\"testdata/test.jpg\")\n\n\tif err != nil {\n\t\tt.Errorf(\"Cannot read the image: %#v\", err)\n\t}\n\n\tif len(buf) == 0 {\n\t\tt.Fatal(\"Empty buffer\")\n\t}\n\n\tif DetermineImageType(buf) != JPEG {\n\t\tt.Fatal(\"Image is not jpeg\")\n\t}\n}\n\nfunc TestWrite(t *testing.T) {\n\tbuf, err := Read(\"testdata/test.jpg\")\n\n\tif err != nil {\n\t\tt.Errorf(\"Cannot read the image: %#v\", err)\n\t}\n\n\tif len(buf) == 0 {\n\t\tt.Fatal(\"Empty buffer\")\n\t}\n\n\terr = Write(\"testdata/test_write_out.jpg\", buf)\n\tif err != nil {\n\t\tt.Fatalf(\"Cannot write the file: %#v\", err)\n\t}\n}\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 6.3974609375,
          "content": "package bimg\n\n// Image provides a simple method DSL to transform a given image as byte buffer.\ntype Image struct {\n\tbuffer []byte\n}\n\n// NewImage creates a new Image struct with method DSL.\nfunc NewImage(buf []byte) *Image {\n\treturn &Image{buf}\n}\n\n// Resize resizes the image to fixed width and height.\nfunc (i *Image) Resize(width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:  width,\n\t\tHeight: height,\n\t\tEmbed:  true,\n\t}\n\treturn i.Process(options)\n}\n\n// ForceResize resizes with custom size (aspect ratio won't be maintained).\nfunc (i *Image) ForceResize(width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:  width,\n\t\tHeight: height,\n\t\tForce:  true,\n\t}\n\treturn i.Process(options)\n}\n\n// ResizeAndCrop resizes the image to fixed width and height with additional crop transformation.\nfunc (i *Image) ResizeAndCrop(width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:  width,\n\t\tHeight: height,\n\t\tEmbed:  true,\n\t\tCrop:   true,\n\t}\n\treturn i.Process(options)\n}\n\n// SmartCrop produces a thumbnail aiming at focus on the interesting part.\nfunc (i *Image) SmartCrop(width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:   width,\n\t\tHeight:  height,\n\t\tCrop:    true,\n\t\tGravity: GravitySmart,\n\t}\n\treturn i.Process(options)\n}\n\n// Extract area from the by X/Y axis in the current image.\nfunc (i *Image) Extract(top, left, width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tTop:        top,\n\t\tLeft:       left,\n\t\tAreaWidth:  width,\n\t\tAreaHeight: height,\n\t}\n\n\tif top == 0 && left == 0 {\n\t\toptions.Top = -1\n\t}\n\n\treturn i.Process(options)\n}\n\n// Enlarge enlarges the image by width and height. Aspect ratio is maintained.\nfunc (i *Image) Enlarge(width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:   width,\n\t\tHeight:  height,\n\t\tEnlarge: true,\n\t}\n\treturn i.Process(options)\n}\n\n// EnlargeAndCrop enlarges the image by width and height with additional crop transformation.\nfunc (i *Image) EnlargeAndCrop(width, height int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:   width,\n\t\tHeight:  height,\n\t\tEnlarge: true,\n\t\tCrop:    true,\n\t}\n\treturn i.Process(options)\n}\n\n// Crop crops the image to the exact size specified.\nfunc (i *Image) Crop(width, height int, gravity Gravity) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:   width,\n\t\tHeight:  height,\n\t\tGravity: gravity,\n\t\tCrop:    true,\n\t}\n\treturn i.Process(options)\n}\n\n// CropByWidth crops an image by width only param (auto height).\nfunc (i *Image) CropByWidth(width int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth: width,\n\t\tCrop:  true,\n\t}\n\treturn i.Process(options)\n}\n\n// CropByHeight crops an image by height (auto width).\nfunc (i *Image) CropByHeight(height int) ([]byte, error) {\n\toptions := Options{\n\t\tHeight: height,\n\t\tCrop:   true,\n\t}\n\treturn i.Process(options)\n}\n\n// Thumbnail creates a thumbnail of the image by the a given width by aspect ratio 4:4.\nfunc (i *Image) Thumbnail(pixels int) ([]byte, error) {\n\toptions := Options{\n\t\tWidth:   pixels,\n\t\tHeight:  pixels,\n\t\tCrop:    true,\n\t\tQuality: 95,\n\t}\n\treturn i.Process(options)\n}\n\n// Watermark adds text as watermark on the given image.\nfunc (i *Image) Watermark(w Watermark) ([]byte, error) {\n\toptions := Options{Watermark: w}\n\treturn i.Process(options)\n}\n\n// WatermarkImage adds image as watermark on the given image.\nfunc (i *Image) WatermarkImage(w WatermarkImage) ([]byte, error) {\n\toptions := Options{WatermarkImage: w}\n\treturn i.Process(options)\n}\n\n// Zoom zooms the image by the given factor.\n// You should probably call Extract() before.\nfunc (i *Image) Zoom(factor int) ([]byte, error) {\n\toptions := Options{Zoom: factor}\n\treturn i.Process(options)\n}\n\n// Rotate rotates the image by given angle degrees (0, 90, 180 or 270).\nfunc (i *Image) Rotate(a Angle) ([]byte, error) {\n\toptions := Options{Rotate: a}\n\treturn i.Process(options)\n}\n\n// AutoRotate automatically rotates the image with no additional transformation based on the EXIF oritentation metadata, if available.\nfunc (i *Image) AutoRotate() ([]byte, error) {\n\treturn i.Process(Options{autoRotateOnly: true})\n}\n\n// Flip flips the image about the vertical Y axis.\nfunc (i *Image) Flip() ([]byte, error) {\n\toptions := Options{Flip: true}\n\treturn i.Process(options)\n}\n\n// Flop flops the image about the horizontal X axis.\nfunc (i *Image) Flop() ([]byte, error) {\n\toptions := Options{Flop: true}\n\treturn i.Process(options)\n}\n\n// Convert converts image to another format.\nfunc (i *Image) Convert(t ImageType) ([]byte, error) {\n\toptions := Options{Type: t}\n\treturn i.Process(options)\n}\n\n// Colourspace performs a color space conversion based on the given interpretation.\nfunc (i *Image) Colourspace(c Interpretation) ([]byte, error) {\n\toptions := Options{Interpretation: c}\n\treturn i.Process(options)\n}\n\n// Trim removes the background from the picture. It can result in a 0x0 output\n// if the image is all background.\nfunc (i *Image) Trim() ([]byte, error) {\n\toptions := Options{Trim: true}\n\treturn i.Process(options)\n}\n\n// Gamma returns the gamma filtered image buffer.\nfunc (i *Image) Gamma(exponent float64) ([]byte, error) {\n\toptions := Options{Gamma: exponent}\n\treturn i.Process(options)\n}\n\n// Process processes the image based on the given transformation options,\n// talking with libvips bindings accordingly and returning the resultant\n// image buffer.\nfunc (i *Image) Process(o Options) ([]byte, error) {\n\timage, err := Resize(i.buffer, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ti.buffer = image\n\treturn image, nil\n}\n\n// Metadata returns the image metadata (size, alpha channel, profile, EXIF rotation).\nfunc (i *Image) Metadata() (ImageMetadata, error) {\n\treturn Metadata(i.buffer)\n}\n\n// Interpretation gets the image interpretation type.\n// See: https://libvips.github.io/libvips/API/current/VipsImage.html#VipsInterpretation\nfunc (i *Image) Interpretation() (Interpretation, error) {\n\treturn ImageInterpretation(i.buffer)\n}\n\n// ColourspaceIsSupported checks if the current image\n// color space is supported.\nfunc (i *Image) ColourspaceIsSupported() (bool, error) {\n\treturn ColourspaceIsSupported(i.buffer)\n}\n\n// Type returns the image type format (jpeg, png, webp, tiff).\nfunc (i *Image) Type() string {\n\treturn DetermineImageTypeName(i.buffer)\n}\n\n// Size returns the image size as form of width and height pixels.\nfunc (i *Image) Size() (ImageSize, error) {\n\treturn Size(i.buffer)\n}\n\n// Image returns the current resultant image buffer.\nfunc (i *Image) Image() []byte {\n\treturn i.buffer\n}\n\n// Length returns the size in bytes of the image buffer.\nfunc (i *Image) Length() int {\n\treturn len(i.buffer)\n}\n"
        },
        {
          "name": "image_test.go",
          "type": "blob",
          "size": 12.673828125,
          "content": "package bimg\n\nimport (\n\t\"fmt\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestImageResize(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Resize(300, 240)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 300, 240)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_resize_out.jpg\", buf)\n}\n\nfunc TestImageGifResize(t *testing.T) {\n\tif VipsMajorVersion >= 8 && VipsMinorVersion >= 12 {\n\t\tbuf, err := initImage(\"test.gif\").Resize(300, 240)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t\t}\n\n\t\terr = assertSize(buf, 300, 240)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tWrite(\"testdata/test_resize_out.gif\", buf)\n\t}\n}\n\nfunc TestImagePdfResize(t *testing.T) {\n\t_, err := initImage(\"test.pdf\").Resize(300, 240)\n\tif err == nil {\n\t\tt.Errorf(\"PDF cannot be saved within VIPS\")\n\t}\n}\n\nfunc TestImageSvgResize(t *testing.T) {\n\t_, err := initImage(\"test.svg\").Resize(300, 240)\n\tif err == nil {\n\t\tt.Errorf(\"SVG cannot be saved within VIPS\")\n\t}\n}\n\nfunc TestImageGifToJpeg(t *testing.T) {\n\tif VipsMajorVersion >= 8 && VipsMinorVersion > 2 {\n\t\ti := initImage(\"test.gif\")\n\t\toptions := Options{\n\t\t\tType: JPEG,\n\t\t}\n\t\tbuf, err := i.Process(options)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t\t}\n\n\t\tWrite(\"testdata/test_gif.jpg\", buf)\n\t}\n}\n\nfunc TestImagePdfToJpeg(t *testing.T) {\n\tif VipsMajorVersion >= 8 && VipsMinorVersion > 2 {\n\t\ti := initImage(\"test.pdf\")\n\t\toptions := Options{\n\t\t\tType: JPEG,\n\t\t}\n\t\tbuf, err := i.Process(options)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t\t}\n\n\t\tWrite(\"testdata/test_pdf.jpg\", buf)\n\t}\n}\n\nfunc TestImageSvgToJpeg(t *testing.T) {\n\tif VipsMajorVersion >= 8 && VipsMinorVersion > 2 {\n\t\ti := initImage(\"test.svg\")\n\t\toptions := Options{\n\t\t\tType: JPEG,\n\t\t}\n\t\tbuf, err := i.Process(options)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t\t}\n\n\t\tWrite(\"testdata/test_svg.jpg\", buf)\n\t}\n}\n\nfunc TestImageResizeAndCrop(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").ResizeAndCrop(300, 200)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 300, 200)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_resize_crop_out.jpg\", buf)\n}\n\nfunc TestImageExtract(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Extract(100, 100, 300, 200)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 300, 200)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_extract_out.jpg\", buf)\n}\n\nfunc TestImageExtractZero(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Extract(0, 0, 300, 200)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 300, 200)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_extract_zero_out.jpg\", buf)\n}\n\nfunc TestImageEnlarge(t *testing.T) {\n\tbuf, err := initImage(\"test.png\").Enlarge(500, 375)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 500, 375)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_enlarge_out.jpg\", buf)\n}\n\nfunc TestImageEnlargeAndCrop(t *testing.T) {\n\tbuf, err := initImage(\"test.png\").EnlargeAndCrop(800, 480)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 800, 480)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_enlarge_crop_out.jpg\", buf)\n}\n\nfunc TestImageCrop(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Crop(800, 600, GravityNorth)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 800, 600)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_crop_out.jpg\", buf)\n}\n\nfunc TestImageCropByWidth(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").CropByWidth(600)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 600, 1050)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_crop_width_out.jpg\", buf)\n}\n\nfunc TestImageCropByHeight(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").CropByHeight(300)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 1680, 300)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_crop_height_out.jpg\", buf)\n}\n\nfunc TestImageThumbnail(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Thumbnail(100)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 100, 100)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_thumbnail_out.jpg\", buf)\n}\n\nfunc TestImageWatermark(t *testing.T) {\n\timage := initImage(\"test.jpg\")\n\t_, err := image.Crop(800, 600, GravityNorth)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\tbuf, err := image.Watermark(Watermark{\n\t\tText:       \"Copy me if you can\",\n\t\tOpacity:    0.5,\n\t\tWidth:      200,\n\t\tDPI:        100,\n\t\tBackground: Color{255, 255, 255},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\terr = assertSize(buf, 800, 600)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif DetermineImageType(buf) != JPEG {\n\t\tt.Fatal(\"Image is not jpeg\")\n\t}\n\n\tWrite(\"testdata/test_watermark_text_out.jpg\", buf)\n}\n\nfunc TestImageWatermarkWithImage(t *testing.T) {\n\timage := initImage(\"test.jpg\")\n\twatermark, _ := imageBuf(\"transparent.png\")\n\n\t_, err := image.Crop(800, 600, GravityNorth)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\tbuf, err := image.WatermarkImage(WatermarkImage{Left: 100, Top: 100, Buf: watermark})\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\terr = assertSize(buf, 800, 600)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif DetermineImageType(buf) != JPEG {\n\t\tt.Fatal(\"Image is not jpeg\")\n\t}\n\n\tWrite(\"testdata/test_watermark_image_out.jpg\", buf)\n}\n\nfunc TestImageWatermarkNoReplicate(t *testing.T) {\n\timage := initImage(\"test.jpg\")\n\t_, err := image.Crop(800, 600, GravityNorth)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\tbuf, err := image.Watermark(Watermark{\n\t\tText:        \"Copy me if you can\",\n\t\tOpacity:     0.5,\n\t\tWidth:       200,\n\t\tDPI:         100,\n\t\tNoReplicate: true,\n\t\tBackground:  Color{255, 255, 255},\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\terr = assertSize(buf, 800, 600)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif DetermineImageType(buf) != JPEG {\n\t\tt.Fatal(\"Image is not jpeg\")\n\t}\n\n\tWrite(\"testdata/test_watermark_replicate_out.jpg\", buf)\n}\n\nfunc TestImageZoom(t *testing.T) {\n\timage := initImage(\"test.jpg\")\n\n\t_, err := image.Extract(100, 100, 400, 300)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot extract the image: %s\", err)\n\t}\n\n\tbuf, err := image.Zoom(1)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %s\", err)\n\t}\n\n\terr = assertSize(buf, 800, 600)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_zoom_out.jpg\", buf)\n}\n\nfunc TestImageFlip(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Flip()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tWrite(\"testdata/test_flip_out.jpg\", buf)\n}\n\nfunc TestImageFlop(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Flop()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tWrite(\"testdata/test_flop_out.jpg\", buf)\n}\n\nfunc TestImageRotate(t *testing.T) {\n\tbuf, err := initImage(\"test_flip_out.jpg\").Rotate(90)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tWrite(\"testdata/test_image_rotate_out.jpg\", buf)\n}\n\nfunc TestImageAutoRotate(t *testing.T) {\n\tif VipsMajorVersion <= 8 && VipsMinorVersion < 10 {\n\t\tt.Skip(\"Skip test in libvips < 8.10\")\n\t\treturn\n\t}\n\n\ttests := []struct {\n\t\tfile        string\n\t\torientation int\n\t}{\n\t\t{\"exif/Landscape_1.jpg\", 1},\n\t\t{\"exif/Landscape_2.jpg\", 1},\n\t\t{\"exif/Landscape_3.jpg\", 1},\n\t\t{\"exif/Landscape_4.jpg\", 1},\n\t\t{\"exif/Landscape_5.jpg\", 1},\n\t\t{\"exif/Landscape_6.jpg\", 1},\n\t\t{\"exif/Landscape_7.jpg\", 1},\n\t}\n\n\tfor index, test := range tests {\n\t\timg := initImage(test.file)\n\t\tbuf, err := img.AutoRotate()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t\t}\n\t\tWrite(fmt.Sprintf(\"testdata/test_autorotate_%d_out.jpg\", index), buf)\n\n\t\tmeta, err := img.Metadata()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot read image metadata: %#v\", err)\n\t\t}\n\t\tif meta.Orientation != test.orientation {\n\t\t\tt.Errorf(\"Invalid image orientation for %s: %d != %d\", test.file, meta.Orientation, test.orientation)\n\t\t}\n\t}\n}\n\nfunc TestImageConvert(t *testing.T) {\n\tbuf, err := initImage(\"test.jpg\").Convert(PNG)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tWrite(\"testdata/test_image_convert_out.png\", buf)\n}\n\nfunc TestTransparentImageConvert(t *testing.T) {\n\timage := initImage(\"transparent.png\")\n\toptions := Options{\n\t\tType:       JPEG,\n\t\tBackground: Color{255, 255, 255},\n\t}\n\tbuf, err := image.Process(options)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tWrite(\"testdata/test_transparent_image_convert_out.jpg\", buf)\n}\n\nfunc TestImageMetadata(t *testing.T) {\n\tdata, err := initImage(\"test.png\").Metadata()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tif data.Alpha != true {\n\t\tt.Fatal(\"Invalid alpha channel\")\n\t}\n\tif data.Size.Width != 400 {\n\t\tt.Fatal(\"Invalid width size\")\n\t}\n\tif data.Type != \"png\" {\n\t\tt.Fatal(\"Invalid image type\")\n\t}\n}\n\nfunc TestInterpretation(t *testing.T) {\n\tinterpretation, err := initImage(\"test.jpg\").Interpretation()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tif interpretation != InterpretationSRGB {\n\t\tt.Errorf(\"Invalid interpretation: %d\", interpretation)\n\t}\n}\n\nfunc TestImageColourspace(t *testing.T) {\n\ttests := []struct {\n\t\tfile           string\n\t\tinterpretation Interpretation\n\t}{\n\t\t{\"test.jpg\", InterpretationSRGB},\n\t\t{\"test.jpg\", InterpretationBW},\n\t}\n\n\tfor _, test := range tests {\n\t\tbuf, err := initImage(test.file).Colourspace(test.interpretation)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t\t}\n\n\t\tinterpretation, err := ImageInterpretation(buf)\n\t\tif interpretation != test.interpretation {\n\t\t\tt.Errorf(\"Invalid colourspace\")\n\t\t}\n\t}\n}\n\nfunc TestImageColourspaceIsSupported(t *testing.T) {\n\tsupported, err := initImage(\"test.jpg\").ColourspaceIsSupported()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tif supported != true {\n\t\tt.Errorf(\"Non-supported colourspace\")\n\t}\n}\n\nfunc TestFluentInterface(t *testing.T) {\n\timage := initImage(\"test.jpg\")\n\t_, err := image.CropByWidth(300)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\t_, err = image.Flip()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\t_, err = image.Convert(PNG)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\tdata, _ := image.Metadata()\n\tif data.Alpha != false {\n\t\tt.Fatal(\"Invalid alpha channel\")\n\t}\n\tif data.Size.Width != 300 {\n\t\tt.Fatal(\"Invalid width size\")\n\t}\n\tif data.Type != \"png\" {\n\t\tt.Fatal(\"Invalid image type\")\n\t}\n\n\tWrite(\"testdata/test_image_fluent_out.png\", image.Image())\n}\n\nfunc TestImageSmartCrop(t *testing.T) {\n\n\tif !(VipsMajorVersion >= 8 && VipsMinorVersion >= 5) {\n\t\tt.Skipf(\"Skipping this test, libvips doesn't meet version requirement %s >= 8.5\", VipsVersion)\n\t}\n\n\ti := initImage(\"northern_cardinal_bird.jpg\")\n\tbuf, err := i.SmartCrop(300, 300)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 300, 300)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tWrite(\"testdata/test_smart_crop.jpg\", buf)\n}\n\nfunc TestImageTrim(t *testing.T) {\n\n\tif !(VipsMajorVersion >= 8 && VipsMinorVersion >= 6) {\n\t\tt.Skipf(\"Skipping this test, libvips doesn't meet version requirement %s >= 8.6\", VipsVersion)\n\t}\n\n\ti := initImage(\"transparent.png\")\n\tbuf, err := i.Trim()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 250, 208)\n\tif err != nil {\n\t\tt.Errorf(\"The image wasn't trimmed.\")\n\t}\n\n\tWrite(\"testdata/transparent_trim.png\", buf)\n}\n\nfunc TestImageTrimParameters(t *testing.T) {\n\n\tif !(VipsMajorVersion >= 8 && VipsMinorVersion >= 6) {\n\t\tt.Skipf(\"Skipping this test, libvips doesn't meet version requirement %s >= 8.6\", VipsVersion)\n\t}\n\n\ti := initImage(\"test.png\")\n\toptions := Options{\n\t\tTrim:       true,\n\t\tBackground: Color{0.0, 0.0, 0.0},\n\t\tThreshold:  10.0,\n\t}\n\tbuf, err := i.Process(options)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\n\terr = assertSize(buf, 400, 257)\n\tif err != nil {\n\t\tt.Errorf(\"The image wasn't trimmed.\")\n\t}\n\n\tWrite(\"testdata/parameter_trim.png\", buf)\n}\n\nfunc TestImageLength(t *testing.T) {\n\ti := initImage(\"test.jpg\")\n\n\tactual := i.Length()\n\texpected := 53653\n\n\tif expected != actual {\n\t\tt.Errorf(\"Size in Bytes of the image doesn't correspond. %d != %d\", expected, actual)\n\t}\n}\n\nfunc initImage(file string) *Image {\n\tbuf, _ := imageBuf(file)\n\treturn NewImage(buf)\n}\n\nfunc imageBuf(file string) ([]byte, error) {\n\treturn Read(path.Join(\"testdata\", file))\n}\n\nfunc assertSize(buf []byte, width, height int) error {\n\tsize, err := NewImage(buf).Size()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif size.Width != width || size.Height != height {\n\t\treturn fmt.Errorf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "metadata.go",
          "type": "blob",
          "size": 9.513671875,
          "content": "package bimg\n\n/*\n#cgo pkg-config: vips\n#include \"vips/vips.h\"\n*/\nimport \"C\"\n\n// Common EXIF fields for data extraction\nconst (\n\tMake                    = \"exif-ifd0-Make\"\n\tModel                   = \"exif-ifd0-Model\"\n\tOrientation             = \"exif-ifd0-Orientation\"\n\tXResolution             = \"exif-ifd0-XResolution\"\n\tYResolution             = \"exif-ifd0-YResolution\"\n\tResolutionUnit          = \"exif-ifd0-ResolutionUnit\"\n\tSoftware                = \"exif-ifd0-Software\"\n\tDatetime                = \"exif-ifd0-DateTime\"\n\tYCbCrPositioning        = \"exif-ifd0-YCbCrPositioning\"\n\tCompression             = \"exif-ifd1-Compression\"\n\tExposureTime            = \"exif-ifd2-ExposureTime\"\n\tFNumber                 = \"exif-ifd2-FNumber\"\n\tExposureProgram         = \"exif-ifd2-ExposureProgram\"\n\tISOSpeedRatings         = \"exif-ifd2-ISOSpeedRatings\"\n\tExifVersion             = \"exif-ifd2-ExifVersion\"\n\tDateTimeOriginal        = \"exif-ifd2-DateTimeOriginal\"\n\tDateTimeDigitized       = \"exif-ifd2-DateTimeDigitized\"\n\tComponentsConfiguration = \"exif-ifd2-ComponentsConfiguration\"\n\tShutterSpeedValue       = \"exif-ifd2-ShutterSpeedValue\"\n\tApertureValue           = \"exif-ifd2-ApertureValue\"\n\tBrightnessValue         = \"exif-ifd2-BrightnessValue\"\n\tExposureBiasValue       = \"exif-ifd2-ExposureBiasValue\"\n\tMeteringMode            = \"exif-ifd2-MeteringMode\"\n\tFlash                   = \"exif-ifd2-Flash\"\n\tFocalLength             = \"exif-ifd2-FocalLength\"\n\tSubjectArea             = \"exif-ifd2-SubjectArea\"\n\tMakerNote               = \"exif-ifd2-MakerNote\"\n\tSubSecTimeOriginal      = \"exif-ifd2-SubSecTimeOriginal\"\n\tSubSecTimeDigitized     = \"exif-ifd2-SubSecTimeDigitized\"\n\tColorSpace              = \"exif-ifd2-ColorSpace\"\n\tPixelXDimension         = \"exif-ifd2-PixelXDimension\"\n\tPixelYDimension         = \"exif-ifd2-PixelYDimension\"\n\tSensingMethod           = \"exif-ifd2-SensingMethod\"\n\tSceneType               = \"exif-ifd2-SceneType\"\n\tExposureMode            = \"exif-ifd2-ExposureMode\"\n\tWhiteBalance            = \"exif-ifd2-WhiteBalance\"\n\tFocalLengthIn35mmFilm   = \"exif-ifd2-FocalLengthIn35mmFilm\"\n\tSceneCaptureType        = \"exif-ifd2-SceneCaptureType\"\n\tGPSLatitudeRef          = \"exif-ifd3-GPSLatitudeRef\"\n\tGPSLatitude             = \"exif-ifd3-GPSLatitude\"\n\tGPSLongitudeRef         = \"exif-ifd3-GPSLongitudeRef\"\n\tGPSLongitude            = \"exif-ifd3-GPSLongitude\"\n\tGPSAltitudeRef          = \"exif-ifd3-GPSAltitudeRef\"\n\tGPSAltitude             = \"exif-ifd3-GPSAltitude\"\n\tGPSSpeedRef             = \"exif-ifd3-GPSSpeedRef\"\n\tGPSSpeed                = \"exif-ifd3-GPSSpeed\"\n\tGPSImgDirectionRef      = \"exif-ifd3-GPSImgDirectionRef\"\n\tGPSImgDirection         = \"exif-ifd3-GPSImgDirection\"\n\tGPSDestBearingRef       = \"exif-ifd3-GPSDestBearingRef\"\n\tGPSDestBearing          = \"exif-ifd3-GPSDestBearing\"\n\tGPSDateStamp            = \"exif-ifd3-GPSDateStamp\"\n)\n\n// ImageSize represents the image width and height values\ntype ImageSize struct {\n\tWidth  int\n\tHeight int\n}\n\n// ImageMetadata represents the basic metadata fields\ntype ImageMetadata struct {\n\tOrientation int\n\tChannels    int\n\tAlpha       bool\n\tProfile     bool\n\tType        string\n\tSpace       string\n\tColourspace string\n\tSize        ImageSize\n\tEXIF        EXIF\n}\n\n// EXIF image metadata\ntype EXIF struct {\n\tMake                    string\n\tModel                   string\n\tOrientation             int\n\tXResolution             string\n\tYResolution             string\n\tResolutionUnit          int\n\tSoftware                string\n\tDatetime                string\n\tYCbCrPositioning        int\n\tCompression             int\n\tExposureTime            string\n\tFNumber                 string\n\tExposureProgram         int\n\tISOSpeedRatings         int\n\tExifVersion             string\n\tDateTimeOriginal        string\n\tDateTimeDigitized       string\n\tComponentsConfiguration string\n\tShutterSpeedValue       string\n\tApertureValue           string\n\tBrightnessValue         string\n\tExposureBiasValue       string\n\tMeteringMode            int\n\tFlash                   int\n\tFocalLength             string\n\tSubjectArea             string\n\tMakerNote               string\n\tSubSecTimeOriginal      string\n\tSubSecTimeDigitized     string\n\tColorSpace              int\n\tPixelXDimension         int\n\tPixelYDimension         int\n\tSensingMethod           int\n\tSceneType               string\n\tExposureMode            int\n\tWhiteBalance            int\n\tFocalLengthIn35mmFilm   int\n\tSceneCaptureType        int\n\tGPSLatitudeRef          string\n\tGPSLatitude             string\n\tGPSLongitudeRef         string\n\tGPSLongitude            string\n\tGPSAltitudeRef          string\n\tGPSAltitude             string\n\tGPSSpeedRef             string\n\tGPSSpeed                string\n\tGPSImgDirectionRef      string\n\tGPSImgDirection         string\n\tGPSDestBearingRef       string\n\tGPSDestBearing          string\n\tGPSDateStamp            string\n}\n\n// Size returns the image size by width and height pixels.\nfunc Size(buf []byte) (ImageSize, error) {\n\tmetadata, err := Metadata(buf)\n\tif err != nil {\n\t\treturn ImageSize{}, err\n\t}\n\n\treturn ImageSize{\n\t\tWidth:  int(metadata.Size.Width),\n\t\tHeight: int(metadata.Size.Height),\n\t}, nil\n}\n\n// ColourspaceIsSupported checks if the image colourspace is supported by libvips.\nfunc ColourspaceIsSupported(buf []byte) (bool, error) {\n\treturn vipsColourspaceIsSupportedBuffer(buf)\n}\n\n// ImageInterpretation returns the image interpretation type.\n// See: https://libvips.github.io/libvips/API/current/VipsImage.html#VipsInterpretation\nfunc ImageInterpretation(buf []byte) (Interpretation, error) {\n\treturn vipsInterpretationBuffer(buf)\n}\n\n// Metadata returns the image metadata (size, type, alpha channel, profile, EXIF orientation...).\nfunc Metadata(buf []byte) (ImageMetadata, error) {\n\tdefer C.vips_thread_shutdown()\n\n\timage, imageType, err := vipsRead(buf)\n\tif err != nil {\n\t\treturn ImageMetadata{}, err\n\t}\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\tsize := ImageSize{\n\t\tWidth:  int(image.Xsize),\n\t\tHeight: int(image.Ysize),\n\t}\n\n\torientation := vipsExifIntTag(image, Orientation)\n\n\tmetadata := ImageMetadata{\n\t\tSize:        size,\n\t\tChannels:    int(image.Bands),\n\t\tOrientation: orientation,\n\t\tAlpha:       vipsHasAlpha(image),\n\t\tProfile:     vipsHasProfile(image),\n\t\tSpace:       vipsSpace(image),\n\t\tType:        ImageTypeName(imageType),\n\t\tEXIF: EXIF{\n\t\t\tMake:                    vipsExifStringTag(image, Make),\n\t\t\tModel:                   vipsExifStringTag(image, Model),\n\t\t\tOrientation:             orientation,\n\t\t\tXResolution:             vipsExifStringTag(image, XResolution),\n\t\t\tYResolution:             vipsExifStringTag(image, YResolution),\n\t\t\tResolutionUnit:          vipsExifIntTag(image, ResolutionUnit),\n\t\t\tSoftware:                vipsExifStringTag(image, Software),\n\t\t\tDatetime:                vipsExifStringTag(image, Datetime),\n\t\t\tYCbCrPositioning:        vipsExifIntTag(image, YCbCrPositioning),\n\t\t\tCompression:             vipsExifIntTag(image, Compression),\n\t\t\tExposureTime:            vipsExifStringTag(image, ExposureTime),\n\t\t\tFNumber:                 vipsExifStringTag(image, FNumber),\n\t\t\tExposureProgram:         vipsExifIntTag(image, ExposureProgram),\n\t\t\tISOSpeedRatings:         vipsExifIntTag(image, ISOSpeedRatings),\n\t\t\tExifVersion:             vipsExifStringTag(image, ExifVersion),\n\t\t\tDateTimeOriginal:        vipsExifStringTag(image, DateTimeOriginal),\n\t\t\tDateTimeDigitized:       vipsExifStringTag(image, DateTimeDigitized),\n\t\t\tComponentsConfiguration: vipsExifStringTag(image, ComponentsConfiguration),\n\t\t\tShutterSpeedValue:       vipsExifStringTag(image, ShutterSpeedValue),\n\t\t\tApertureValue:           vipsExifStringTag(image, ApertureValue),\n\t\t\tBrightnessValue:         vipsExifStringTag(image, BrightnessValue),\n\t\t\tExposureBiasValue:       vipsExifStringTag(image, ExposureBiasValue),\n\t\t\tMeteringMode:            vipsExifIntTag(image, MeteringMode),\n\t\t\tFlash:                   vipsExifIntTag(image, Flash),\n\t\t\tFocalLength:             vipsExifStringTag(image, FocalLength),\n\t\t\tSubjectArea:             vipsExifStringTag(image, SubjectArea),\n\t\t\tMakerNote:               vipsExifStringTag(image, MakerNote),\n\t\t\tSubSecTimeOriginal:      vipsExifStringTag(image, SubSecTimeOriginal),\n\t\t\tSubSecTimeDigitized:     vipsExifStringTag(image, SubSecTimeDigitized),\n\t\t\tColorSpace:              vipsExifIntTag(image, ColorSpace),\n\t\t\tPixelXDimension:         vipsExifIntTag(image, PixelXDimension),\n\t\t\tPixelYDimension:         vipsExifIntTag(image, PixelYDimension),\n\t\t\tSensingMethod:           vipsExifIntTag(image, SensingMethod),\n\t\t\tSceneType:               vipsExifStringTag(image, SceneType),\n\t\t\tExposureMode:            vipsExifIntTag(image, ExposureMode),\n\t\t\tWhiteBalance:            vipsExifIntTag(image, WhiteBalance),\n\t\t\tFocalLengthIn35mmFilm:   vipsExifIntTag(image, FocalLengthIn35mmFilm),\n\t\t\tSceneCaptureType:        vipsExifIntTag(image, SceneCaptureType),\n\t\t\tGPSLatitudeRef:          vipsExifStringTag(image, GPSLatitudeRef),\n\t\t\tGPSLatitude:             vipsExifStringTag(image, GPSLatitude),\n\t\t\tGPSLongitudeRef:         vipsExifStringTag(image, GPSLongitudeRef),\n\t\t\tGPSLongitude:            vipsExifStringTag(image, GPSLongitude),\n\t\t\tGPSAltitudeRef:          vipsExifStringTag(image, GPSAltitudeRef),\n\t\t\tGPSAltitude:             vipsExifStringTag(image, GPSAltitude),\n\t\t\tGPSSpeedRef:             vipsExifStringTag(image, GPSSpeedRef),\n\t\t\tGPSSpeed:                vipsExifStringTag(image, GPSSpeed),\n\t\t\tGPSImgDirectionRef:      vipsExifStringTag(image, GPSImgDirectionRef),\n\t\t\tGPSImgDirection:         vipsExifStringTag(image, GPSImgDirection),\n\t\t\tGPSDestBearingRef:       vipsExifStringTag(image, GPSDestBearingRef),\n\t\t\tGPSDestBearing:          vipsExifStringTag(image, GPSDestBearing),\n\t\t\tGPSDateStamp:            vipsExifStringTag(image, GPSDateStamp),\n\t\t},\n\t}\n\n\treturn metadata, nil\n}\n"
        },
        {
          "name": "metadata_test.go",
          "type": "blob",
          "size": 15.4326171875,
          "content": "package bimg\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestSize(t *testing.T) {\n\tfiles := []struct {\n\t\tname   string\n\t\twidth  int\n\t\theight int\n\t}{\n\t\t{\"test.jpg\", 1680, 1050},\n\t\t{\"test.png\", 400, 300},\n\t\t{\"test.webp\", 550, 368},\n\t}\n\tfor _, file := range files {\n\t\tsize, err := Size(readFile(file.name))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot read the image: %#v\", err)\n\t\t}\n\n\t\tif size.Width != file.width || size.Height != file.height {\n\t\t\tt.Fatalf(\"Unexpected image size: %dx%d\", size.Width, size.Height)\n\t\t}\n\t}\n}\n\nfunc TestMetadata(t *testing.T) {\n\tfiles := []struct {\n\t\tname        string\n\t\tformat      string\n\t\torientation int\n\t\talpha       bool\n\t\tprofile     bool\n\t\tspace       string\n\t}{\n\t\t{\"test.jpg\", \"jpeg\", 0, false, false, \"srgb\"},\n\t\t{\"test_icc_prophoto.jpg\", \"jpeg\", 0, false, true, \"srgb\"},\n\t\t{\"test.png\", \"png\", 0, true, false, \"srgb\"},\n\t\t{\"test.webp\", \"webp\", 0, false, false, \"srgb\"},\n\t\t{\"test.avif\", \"avif\", 0, false, false, \"srgb\"},\n\t}\n\n\tfor _, file := range files {\n\t\tmetadata, err := Metadata(readFile(file.name))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot read the image: %s -> %s\", file.name, err)\n\t\t}\n\t\tif metadata.Type != file.format {\n\t\t\tt.Fatalf(\"Unexpected image format: %s\", file.format)\n\t\t}\n\t\tif metadata.Orientation != file.orientation {\n\t\t\tt.Fatalf(\"Unexpected image orientation: %d != %d\", metadata.Orientation, file.orientation)\n\t\t}\n\t\tif metadata.Alpha != file.alpha {\n\t\t\tt.Fatalf(\"Unexpected image alpha: %t != %t\", metadata.Alpha, file.alpha)\n\t\t}\n\t\tif metadata.Profile != file.profile {\n\t\t\tt.Fatalf(\"Unexpected image profile: %t != %t\", metadata.Profile, file.profile)\n\t\t}\n\t\tif metadata.Space != file.space {\n\t\t\tt.Fatalf(\"Unexpected image profile: %t != %t\", metadata.Profile, file.profile)\n\t\t}\n\t}\n}\n\nfunc TestImageInterpretation(t *testing.T) {\n\tfiles := []struct {\n\t\tname           string\n\t\tinterpretation Interpretation\n\t}{\n\t\t{\"test.jpg\", InterpretationSRGB},\n\t\t{\"test.png\", InterpretationSRGB},\n\t\t{\"test.webp\", InterpretationSRGB},\n\t}\n\n\tfor _, file := range files {\n\t\tinterpretation, err := ImageInterpretation(readFile(file.name))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot read the image: %s -> %s\", file.name, err)\n\t\t}\n\t\tif interpretation != file.interpretation {\n\t\t\tt.Fatalf(\"Unexpected image interpretation\")\n\t\t}\n\t}\n}\n\nfunc TestEXIF(t *testing.T) {\n\tif VipsMajorVersion <= 8 && VipsMinorVersion < 10 {\n\t\tt.Skip(\"Skip test in libvips < 8.10\")\n\t\treturn\n\t}\n\n\tfiles := map[string]EXIF{\n\t\t\"test.jpg\": {},\n\t\t\"exif/Landscape_1.jpg\": {\n\t\t\tOrientation:      1,\n\t\t\tXResolution:      \"72/1\",\n\t\t\tYResolution:      \"72/1\",\n\t\t\tResolutionUnit:   2,\n\t\t\tYCbCrPositioning: 1,\n\t\t\tExifVersion:      \"Exif Version 2.1\",\n\t\t\tColorSpace:       65535,\n\t\t},\n\t\t\"test_exif.jpg\": {\n\t\t\tMake:              \"Jolla\",\n\t\t\tModel:             \"Jolla\",\n\t\t\tXResolution:       \"72/1\",\n\t\t\tYResolution:       \"72/1\",\n\t\t\tResolutionUnit:    2,\n\t\t\tOrientation:       1,\n\t\t\tDatetime:          \"2014:09:21 16:00:56\",\n\t\t\tExposureTime:      \"1/25\",\n\t\t\tFNumber:           \"12/5\",\n\t\t\tISOSpeedRatings:   320,\n\t\t\tExifVersion:       \"Exif Version 2.3\",\n\t\t\tDateTimeOriginal:  \"2014:09:21 16:00:56\",\n\t\t\tShutterSpeedValue: \"205447286/44240665\",\n\t\t\tApertureValue:     \"334328577/132351334\",\n\t\t\tExposureBiasValue: \"0/1\",\n\t\t\tMeteringMode:      1,\n\t\t\tFlash:             0,\n\t\t\tFocalLength:       \"4/1\",\n\t\t\tWhiteBalance:      1,\n\t\t\tColorSpace:        65535,\n\t\t},\n\t\t\"test_exif_canon.jpg\": {\n\t\t\tMake:                    \"Canon\",\n\t\t\tModel:                   \"Canon EOS 40D\",\n\t\t\tOrientation:             1,\n\t\t\tXResolution:             \"72/1\",\n\t\t\tYResolution:             \"72/1\",\n\t\t\tResolutionUnit:          2,\n\t\t\tSoftware:                \"GIMP 2.4.5\",\n\t\t\tDatetime:                \"2008:07:31 10:38:11\",\n\t\t\tYCbCrPositioning:        2,\n\t\t\tCompression:             6,\n\t\t\tExposureTime:            \"1/160\",\n\t\t\tFNumber:                 \"71/10\",\n\t\t\tExposureProgram:         1,\n\t\t\tISOSpeedRatings:         100,\n\t\t\tExifVersion:             \"Exif Version 2.21\",\n\t\t\tDateTimeOriginal:        \"2008:05:30 15:56:01\",\n\t\t\tDateTimeDigitized:       \"2008:05:30 15:56:01\",\n\t\t\tComponentsConfiguration: \"Y Cb Cr -\",\n\t\t\tShutterSpeedValue:       \"483328/65536\",\n\t\t\tApertureValue:           \"368640/65536\",\n\t\t\tExposureBiasValue:       \"0/1\",\n\t\t\tMeteringMode:            5,\n\t\t\tFlash:                   9,\n\t\t\tFocalLength:             \"135/1\",\n\t\t\tSubSecTimeOriginal:      \"00\",\n\t\t\tSubSecTimeDigitized:     \"00\",\n\t\t\tColorSpace:              1,\n\t\t\tPixelXDimension:         100,\n\t\t\tPixelYDimension:         68,\n\t\t\tExposureMode:            1,\n\t\t\tWhiteBalance:            0,\n\t\t\tSceneCaptureType:        0,\n\t\t},\n\t\t\"test_exif_full.jpg\": {\n\t\t\tMake:                    \"Apple\",\n\t\t\tModel:                   \"iPhone XS\",\n\t\t\tOrientation:             6,\n\t\t\tXResolution:             \"72/1\",\n\t\t\tYResolution:             \"72/1\",\n\t\t\tResolutionUnit:          2,\n\t\t\tSoftware:                \"13.3.1\",\n\t\t\tDatetime:                \"2020:07:28 19:18:49\",\n\t\t\tYCbCrPositioning:        1,\n\t\t\tCompression:             6,\n\t\t\tExposureTime:            \"1/835\",\n\t\t\tFNumber:                 \"9/5\",\n\t\t\tExposureProgram:         2,\n\t\t\tISOSpeedRatings:         25,\n\t\t\tExifVersion:             \"Unknown Exif Version\",\n\t\t\tDateTimeOriginal:        \"2020:07:28 19:18:49\",\n\t\t\tDateTimeDigitized:       \"2020:07:28 19:18:49\",\n\t\t\tComponentsConfiguration: \"Y Cb Cr -\",\n\t\t\tShutterSpeedValue:       \"77515/7986\",\n\t\t\tApertureValue:           \"54823/32325\",\n\t\t\tBrightnessValue:         \"77160/8623\",\n\t\t\tExposureBiasValue:       \"0/1\",\n\t\t\tMeteringMode:            5,\n\t\t\tFlash:                   16,\n\t\t\tFocalLength:             \"17/4\",\n\t\t\tSubjectArea:             \"2013 1511 2217 1330\",\n\t\t\tMakerNote:               \"1110 bytes undefined data\",\n\t\t\tSubSecTimeOriginal:      \"777\",\n\t\t\tSubSecTimeDigitized:     \"777\",\n\t\t\tColorSpace:              65535,\n\t\t\tPixelXDimension:         4032,\n\t\t\tPixelYDimension:         3024,\n\t\t\tSensingMethod:           2,\n\t\t\tSceneType:               \"Directly photographed\",\n\t\t\tExposureMode:            0,\n\t\t\tWhiteBalance:            0,\n\t\t\tFocalLengthIn35mmFilm:   26,\n\t\t\tSceneCaptureType:        0,\n\t\t\tGPSLatitudeRef:          \"N\",\n\t\t\tGPSLatitude:             \"55/1 43/1 5287/100\",\n\t\t\tGPSLongitudeRef:         \"E\",\n\t\t\tGPSLongitude:            \"37/1 35/1 5571/100\",\n\t\t\tGPSAltitudeRef:          \"Sea level\",\n\t\t\tGPSAltitude:             \"90514/693\",\n\t\t\tGPSSpeedRef:             \"K\",\n\t\t\tGPSSpeed:                \"114272/41081\",\n\t\t\tGPSImgDirectionRef:      \"M\",\n\t\t\tGPSImgDirection:         \"192127/921\",\n\t\t\tGPSDestBearingRef:       \"M\",\n\t\t\tGPSDestBearing:          \"192127/921\",\n\t\t\tGPSDateStamp:            \"2020:07:28\",\n\t\t},\n\t}\n\n\tfor name, file := range files {\n\t\tmetadata, err := Metadata(readFile(name))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot read the image: %s -> %s\", name, err)\n\t\t}\n\t\tif metadata.EXIF.Make != file.Make {\n\t\t\tt.Fatalf(\"Unexpected image exif Make: %s != %s\", metadata.EXIF.Make, file.Make)\n\t\t}\n\t\tif metadata.EXIF.Model != file.Model {\n\t\t\tt.Fatalf(\"Unexpected image exif Model: %s != %s\", metadata.EXIF.Model, file.Model)\n\t\t}\n\t\tif metadata.EXIF.Orientation != file.Orientation {\n\t\t\tt.Fatalf(\"Unexpected image exif Orientation: %d != %d\", metadata.EXIF.Orientation, file.Orientation)\n\t\t}\n\t\tif metadata.EXIF.XResolution != file.XResolution {\n\t\t\tt.Fatalf(\"Unexpected image exif XResolution: %s != %s\", metadata.EXIF.XResolution, file.XResolution)\n\t\t}\n\t\tif metadata.EXIF.YResolution != file.YResolution {\n\t\t\tt.Fatalf(\"Unexpected image exif YResolution: %s != %s\", metadata.EXIF.YResolution, file.YResolution)\n\t\t}\n\t\tif metadata.EXIF.ResolutionUnit != file.ResolutionUnit {\n\t\t\tt.Fatalf(\"Unexpected image exif ResolutionUnit: %d != %d\", metadata.EXIF.ResolutionUnit, file.ResolutionUnit)\n\t\t}\n\t\tif metadata.EXIF.Software != file.Software {\n\t\t\tt.Fatalf(\"Unexpected image exif Software: %s != %s\", metadata.EXIF.Software, file.Software)\n\t\t}\n\t\tif metadata.EXIF.Datetime != file.Datetime {\n\t\t\tt.Fatalf(\"Unexpected image exif Datetime: %s != %s\", metadata.EXIF.Datetime, file.Datetime)\n\t\t}\n\t\tif metadata.EXIF.YCbCrPositioning != file.YCbCrPositioning {\n\t\t\tt.Fatalf(\"Unexpected image exif YCbCrPositioning: %d != %d\", metadata.EXIF.YCbCrPositioning, file.YCbCrPositioning)\n\t\t}\n\t\tif metadata.EXIF.Compression != file.Compression {\n\t\t\tt.Fatalf(\"Unexpected image exif Compression: %d != %d\", metadata.EXIF.Compression, file.Compression)\n\t\t}\n\t\tif metadata.EXIF.ExposureTime != file.ExposureTime {\n\t\t\tt.Fatalf(\"Unexpected image exif ExposureTime: %s != %s\", metadata.EXIF.ExposureTime, file.ExposureTime)\n\t\t}\n\t\tif metadata.EXIF.FNumber != file.FNumber {\n\t\t\tt.Fatalf(\"Unexpected image exif FNumber: %s != %s\", metadata.EXIF.FNumber, file.FNumber)\n\t\t}\n\t\tif metadata.EXIF.ExposureProgram != file.ExposureProgram {\n\t\t\tt.Fatalf(\"Unexpected image exif ExposureProgram: %d != %d\", metadata.EXIF.ExposureProgram, file.ExposureProgram)\n\t\t}\n\t\tif metadata.EXIF.ISOSpeedRatings != file.ISOSpeedRatings {\n\t\t\tt.Fatalf(\"Unexpected image exif ISOSpeedRatings: %d != %d\", metadata.EXIF.ISOSpeedRatings, file.ISOSpeedRatings)\n\t\t}\n\t\tif metadata.EXIF.ExifVersion != file.ExifVersion {\n\t\t\tt.Fatalf(\"Unexpected image exif ExifVersion: %s != %s\", metadata.EXIF.ExifVersion, file.ExifVersion)\n\t\t}\n\t\tif metadata.EXIF.DateTimeOriginal != file.DateTimeOriginal {\n\t\t\tt.Fatalf(\"Unexpected image exif DateTimeOriginal: %s != %s\", metadata.EXIF.DateTimeOriginal, file.DateTimeOriginal)\n\t\t}\n\t\tif metadata.EXIF.DateTimeDigitized != file.DateTimeDigitized {\n\t\t\tt.Fatalf(\"Unexpected image exif DateTimeDigitized: %s != %s\", metadata.EXIF.DateTimeDigitized, file.DateTimeDigitized)\n\t\t}\n\t\tif metadata.EXIF.ComponentsConfiguration != file.ComponentsConfiguration {\n\t\t\tt.Fatalf(\"Unexpected image exif ComponentsConfiguration: %s != %s\", metadata.EXIF.ComponentsConfiguration, file.ComponentsConfiguration)\n\t\t}\n\t\tif metadata.EXIF.ShutterSpeedValue != file.ShutterSpeedValue {\n\t\t\tt.Fatalf(\"Unexpected image exif ShutterSpeedValue: %s != %s\", metadata.EXIF.ShutterSpeedValue, file.ShutterSpeedValue)\n\t\t}\n\t\tif metadata.EXIF.ApertureValue != file.ApertureValue {\n\t\t\tt.Fatalf(\"Unexpected image exif ApertureValue: %s != %s\", metadata.EXIF.ApertureValue, file.ApertureValue)\n\t\t}\n\t\tif metadata.EXIF.BrightnessValue != file.BrightnessValue {\n\t\t\tt.Fatalf(\"Unexpected image exif BrightnessValue: %s != %s\", metadata.EXIF.BrightnessValue, file.BrightnessValue)\n\t\t}\n\t\tif metadata.EXIF.ExposureBiasValue != file.ExposureBiasValue {\n\t\t\tt.Fatalf(\"Unexpected image exif ExposureBiasValue: %s != %s\", metadata.EXIF.ExposureBiasValue, file.ExposureBiasValue)\n\t\t}\n\t\tif metadata.EXIF.MeteringMode != file.MeteringMode {\n\t\t\tt.Fatalf(\"Unexpected image exif MeteringMode: %d != %d\", metadata.EXIF.MeteringMode, file.MeteringMode)\n\t\t}\n\t\tif metadata.EXIF.Flash != file.Flash {\n\t\t\tt.Fatalf(\"Unexpected image exif Flash: %d != %d\", metadata.EXIF.Flash, file.Flash)\n\t\t}\n\t\tif metadata.EXIF.FocalLength != file.FocalLength {\n\t\t\tt.Fatalf(\"Unexpected image exif FocalLength: %s != %s\", metadata.EXIF.FocalLength, file.FocalLength)\n\t\t}\n\t\tif metadata.EXIF.SubjectArea != file.SubjectArea {\n\t\t\tt.Fatalf(\"Unexpected image exif SubjectArea: %s != %s\", metadata.EXIF.SubjectArea, file.SubjectArea)\n\t\t}\n\t\tif metadata.EXIF.MakerNote != file.MakerNote {\n\t\t\tt.Fatalf(\"Unexpected image exif MakerNote: %s != %s\", metadata.EXIF.MakerNote, file.MakerNote)\n\t\t}\n\t\tif metadata.EXIF.SubSecTimeOriginal != file.SubSecTimeOriginal {\n\t\t\tt.Fatalf(\"Unexpected image exif SubSecTimeOriginal: %s != %s\", metadata.EXIF.SubSecTimeOriginal, file.SubSecTimeOriginal)\n\t\t}\n\t\tif metadata.EXIF.SubSecTimeDigitized != file.SubSecTimeDigitized {\n\t\t\tt.Fatalf(\"Unexpected image exif SubSecTimeDigitized: %s != %s\", metadata.EXIF.SubSecTimeDigitized, file.SubSecTimeDigitized)\n\t\t}\n\t\tif metadata.EXIF.ColorSpace != file.ColorSpace {\n\t\t\tt.Fatalf(\"Unexpected image exif ColorSpace: %d != %d\", metadata.EXIF.ColorSpace, file.ColorSpace)\n\t\t}\n\t\tif metadata.EXIF.PixelXDimension != file.PixelXDimension {\n\t\t\tt.Fatalf(\"Unexpected image exif PixelXDimension: %d != %d\", metadata.EXIF.PixelXDimension, file.PixelXDimension)\n\t\t}\n\t\tif metadata.EXIF.PixelYDimension != file.PixelYDimension {\n\t\t\tt.Fatalf(\"Unexpected image exif PixelYDimension: %d != %d\", metadata.EXIF.PixelYDimension, file.PixelYDimension)\n\t\t}\n\t\tif metadata.EXIF.SensingMethod != file.SensingMethod {\n\t\t\tt.Fatalf(\"Unexpected image exif SensingMethod: %d != %d\", metadata.EXIF.SensingMethod, file.SensingMethod)\n\t\t}\n\t\tif metadata.EXIF.SceneType != file.SceneType {\n\t\t\tt.Fatalf(\"Unexpected image exif SceneType: %s != %s\", metadata.EXIF.SceneType, file.SceneType)\n\t\t}\n\t\tif metadata.EXIF.ExposureMode != file.ExposureMode {\n\t\t\tt.Fatalf(\"Unexpected image exif ExposureMode: %d != %d\", metadata.EXIF.ExposureMode, file.ExposureMode)\n\t\t}\n\t\tif metadata.EXIF.WhiteBalance != file.WhiteBalance {\n\t\t\tt.Fatalf(\"Unexpected image exif WhiteBalance: %d != %d\", metadata.EXIF.WhiteBalance, file.WhiteBalance)\n\t\t}\n\t\tif metadata.EXIF.FocalLengthIn35mmFilm != file.FocalLengthIn35mmFilm {\n\t\t\tt.Fatalf(\"Unexpected image exif FocalLengthIn35mmFilm: %d != %d\", metadata.EXIF.FocalLengthIn35mmFilm, file.FocalLengthIn35mmFilm)\n\t\t}\n\t\tif metadata.EXIF.SceneCaptureType != file.SceneCaptureType {\n\t\t\tt.Fatalf(\"Unexpected image exif SceneCaptureType: %d != %d\", metadata.EXIF.SceneCaptureType, file.SceneCaptureType)\n\t\t}\n\t\tif metadata.EXIF.GPSLongitudeRef != file.GPSLongitudeRef {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSLongitudeRef: %s != %s\", metadata.EXIF.GPSLongitudeRef, file.GPSLongitudeRef)\n\t\t}\n\t\tif metadata.EXIF.GPSLongitude != file.GPSLongitude {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSLongitude: %s != %s\", metadata.EXIF.GPSLongitude, file.GPSLongitude)\n\t\t}\n\t\tif metadata.EXIF.GPSAltitudeRef != file.GPSAltitudeRef {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSAltitudeRef: %s != %s\", metadata.EXIF.GPSAltitudeRef, file.GPSAltitudeRef)\n\t\t}\n\t\tif metadata.EXIF.GPSAltitude != file.GPSAltitude {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSAltitude: %s != %s\", metadata.EXIF.GPSAltitude, file.GPSAltitude)\n\t\t}\n\t\tif metadata.EXIF.GPSSpeedRef != file.GPSSpeedRef {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSSpeedRef: %s != %s\", metadata.EXIF.GPSSpeedRef, file.GPSSpeedRef)\n\t\t}\n\t\tif metadata.EXIF.GPSSpeed != file.GPSSpeed {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSSpeed: %s != %s\", metadata.EXIF.GPSSpeed, file.GPSSpeed)\n\t\t}\n\t\tif metadata.EXIF.GPSImgDirectionRef != file.GPSImgDirectionRef {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSImgDirectionRef: %s != %s\", metadata.EXIF.GPSImgDirectionRef, file.GPSImgDirectionRef)\n\t\t}\n\t\tif metadata.EXIF.GPSImgDirection != file.GPSImgDirection {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSImgDirection: %s != %s\", metadata.EXIF.GPSImgDirection, file.GPSImgDirection)\n\t\t}\n\t\tif metadata.EXIF.GPSDestBearingRef != file.GPSDestBearingRef {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSDestBearingRef: %s != %s\", metadata.EXIF.GPSDestBearingRef, file.GPSDestBearingRef)\n\t\t}\n\t\tif metadata.EXIF.GPSDestBearing != file.GPSDestBearing {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSDestBearing: %s != %s\", metadata.EXIF.GPSDestBearing, file.GPSDestBearing)\n\t\t}\n\t\tif metadata.EXIF.GPSDateStamp != file.GPSDateStamp {\n\t\t\tt.Fatalf(\"Unexpected image exif GPSDateStamp: %s != %s\", metadata.EXIF.GPSDateStamp, file.GPSDateStamp)\n\t\t}\n\t}\n}\n\nfunc TestColourspaceIsSupported(t *testing.T) {\n\tfiles := []struct {\n\t\tname string\n\t}{\n\t\t{\"test.jpg\"},\n\t\t{\"test.png\"},\n\t\t{\"test.webp\"},\n\t}\n\n\tfor _, file := range files {\n\t\tsupported, err := ColourspaceIsSupported(readFile(file.name))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot read the image: %s -> %s\", file.name, err)\n\t\t}\n\t\tif supported != true {\n\t\t\tt.Fatalf(\"Unsupported image colourspace\")\n\t\t}\n\t}\n\n\tsupported, err := initImage(\"test.jpg\").ColourspaceIsSupported()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot process the image: %#v\", err)\n\t}\n\tif supported != true {\n\t\tt.Errorf(\"Non-supported colourspace\")\n\t}\n}\n\nfunc readFile(file string) []byte {\n\tdata, _ := os.Open(path.Join(\"testdata\", file))\n\tbuf, _ := ioutil.ReadAll(data)\n\treturn buf\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 7.69140625,
          "content": "package bimg\n\n/*\n#cgo pkg-config: vips\n#include \"vips/vips.h\"\n*/\nimport \"C\"\nimport \"errors\"\n\nconst (\n\t// Quality defines the default JPEG quality to be used.\n\tQuality = 75\n)\n\n// maxSize defines maximum pixels width or height supported.\nvar maxSize = 16383\n\n// MaxSize returns maxSize.\nfunc MaxSize() int {\n\treturn maxSize\n}\n\n// SetMaxSize sets maxSize.\nfunc SetMaxsize(s int) error {\n\tif s <= 0 {\n\t\treturn errors.New(\"Size must be higher than zero.\")\n\t}\n\n\tmaxSize = s\n\n\treturn nil\n}\n\n// Gravity represents the image gravity value.\ntype Gravity int\n\nconst (\n\t// GravityCentre represents the centre value used for image gravity orientation.\n\tGravityCentre Gravity = iota\n\t// GravityNorth represents the north value used for image gravity orientation.\n\tGravityNorth\n\t// GravityEast represents the east value used for image gravity orientation.\n\tGravityEast\n\t// GravitySouth represents the south value used for image gravity orientation.\n\tGravitySouth\n\t// GravityWest represents the west value used for image gravity orientation.\n\tGravityWest\n\t// GravitySmart enables libvips Smart Crop algorithm for image gravity orientation.\n\tGravitySmart\n)\n\n// Interpolator represents the image interpolation value.\ntype Interpolator int\n\nconst (\n\t// Bicubic interpolation value.\n\tBicubic Interpolator = iota\n\t// Bilinear interpolation value.\n\tBilinear\n\t// Nohalo interpolation value.\n\tNohalo\n\t// Nearest neighbour interpolation value.\n\tNearest\n)\n\n// resampling kernels\ntype Kernel int\n\nconst (\n\t//The nearest pixel to the point.\n\tNearestKernel Kernel = iota\n\n\t//Convolve with a triangle filter.\n\tLinearKernel\n\n\t//Convolve with a cubic filter.\n\tCubicKernel\n\n\t//Convolve with a Mitchell kernel.\n\tMitchellKernel\n\n\t//Convolve with a two-lobe Lanczos kernel.\n\tLanczos2Kernel\n\n\t//Convolve with a three-lobe Lanczos kernel.\n\tLanczos3Kernel\n\n\tLastKernel\n)\n\nvar interpolations = map[Interpolator]string{\n\tBicubic:  \"bicubic\",\n\tBilinear: \"bilinear\",\n\tNohalo:   \"nohalo\",\n\tNearest:  \"nearest\",\n}\n\nfunc (i Interpolator) String() string {\n\treturn interpolations[i]\n}\n\n// Angle represents the image rotation angle value.\ntype Angle int\n\nconst (\n\t// D0 represents the rotation angle 0 degrees.\n\tD0 Angle = 0\n\t// D45 represents the rotation angle 45 degrees.\n\tD45 Angle = 45\n\t// D90 represents the rotation angle 90 degrees.\n\tD90 Angle = 90\n\t// D135 represents the rotation angle 135 degrees.\n\tD135 Angle = 135\n\t// D180 represents the rotation angle 180 degrees.\n\tD180 Angle = 180\n\t// D235 represents the rotation angle 235 degrees.\n\tD235 Angle = 235\n\t// D270 represents the rotation angle 270 degrees.\n\tD270 Angle = 270\n\t// D315 represents the rotation angle 315 degrees.\n\tD315 Angle = 315\n)\n\n// Direction represents the image direction value.\ntype Direction int\n\nconst (\n\t// Horizontal represents the orizontal image direction value.\n\tHorizontal Direction = C.VIPS_DIRECTION_HORIZONTAL\n\t// Vertical represents the vertical image direction value.\n\tVertical Direction = C.VIPS_DIRECTION_VERTICAL\n)\n\n// Interpretation represents the image interpretation type.\n// See: https://libvips.github.io/libvips/API/current/VipsImage.html#VipsInterpretation\ntype Interpretation int\n\nconst (\n\t// InterpretationError points to the libvips interpretation error type.\n\tInterpretationError Interpretation = C.VIPS_INTERPRETATION_ERROR\n\t// InterpretationMultiband points to its libvips interpretation equivalent type.\n\tInterpretationMultiband Interpretation = C.VIPS_INTERPRETATION_MULTIBAND\n\t// InterpretationBW points to its libvips interpretation equivalent type.\n\tInterpretationBW Interpretation = C.VIPS_INTERPRETATION_B_W\n\t// InterpretationCMYK points to its libvips interpretation equivalent type.\n\tInterpretationCMYK Interpretation = C.VIPS_INTERPRETATION_CMYK\n\t// InterpretationRGB points to its libvips interpretation equivalent type.\n\tInterpretationRGB Interpretation = C.VIPS_INTERPRETATION_RGB\n\t// InterpretationSRGB points to its libvips interpretation equivalent type.\n\tInterpretationSRGB Interpretation = C.VIPS_INTERPRETATION_sRGB\n\t// InterpretationRGB16 points to its libvips interpretation equivalent type.\n\tInterpretationRGB16 Interpretation = C.VIPS_INTERPRETATION_RGB16\n\t// InterpretationGREY16 points to its libvips interpretation equivalent type.\n\tInterpretationGREY16 Interpretation = C.VIPS_INTERPRETATION_GREY16\n\t// InterpretationScRGB points to its libvips interpretation equivalent type.\n\tInterpretationScRGB Interpretation = C.VIPS_INTERPRETATION_scRGB\n\t// InterpretationLAB points to its libvips interpretation equivalent type.\n\tInterpretationLAB Interpretation = C.VIPS_INTERPRETATION_LAB\n\t// InterpretationXYZ points to its libvips interpretation equivalent type.\n\tInterpretationXYZ Interpretation = C.VIPS_INTERPRETATION_XYZ\n)\n\n// Extend represents the image extend mode, used when the edges\n// of an image are extended, you can specify how you want the extension done.\n// See: https://libvips.github.io/libvips/API/current/libvips-conversion.html#VIPS-EXTEND-BACKGROUND:CAPS\ntype Extend int\n\nconst (\n\t// ExtendBlack extend with black (all 0) pixels mode.\n\tExtendBlack Extend = C.VIPS_EXTEND_BLACK\n\t// ExtendCopy copy the image edges.\n\tExtendCopy Extend = C.VIPS_EXTEND_COPY\n\t// ExtendRepeat repeat the whole image.\n\tExtendRepeat Extend = C.VIPS_EXTEND_REPEAT\n\t// ExtendMirror mirror the whole image.\n\tExtendMirror Extend = C.VIPS_EXTEND_MIRROR\n\t// ExtendWhite extend with white (all bits set) pixels.\n\tExtendWhite Extend = C.VIPS_EXTEND_WHITE\n\t// ExtendBackground with colour from the background property.\n\tExtendBackground Extend = C.VIPS_EXTEND_BACKGROUND\n\t// ExtendLast extend with last pixel.\n\tExtendLast Extend = C.VIPS_EXTEND_LAST\n)\n\n// WatermarkFont defines the default watermark font to be used.\nvar WatermarkFont = \"sans 10\"\n\n// Color represents a traditional RGB color scheme.\ntype Color struct {\n\tR, G, B uint8\n}\n\n// ColorBlack is a shortcut to black RGB color representation.\nvar ColorBlack = Color{0, 0, 0}\n\n// Watermark represents the text-based watermark supported options.\ntype Watermark struct {\n\tWidth       int\n\tDPI         int\n\tMargin      int\n\tOpacity     float32\n\tNoReplicate bool\n\tText        string\n\tFont        string\n\tBackground  Color\n}\n\n// WatermarkImage represents the image-based watermark supported options.\ntype WatermarkImage struct {\n\tLeft    int\n\tTop     int\n\tBuf     []byte\n\tOpacity float32\n}\n\n// GaussianBlur represents the gaussian image transformation values.\ntype GaussianBlur struct {\n\tSigma   float64\n\tMinAmpl float64\n}\n\n// Sharpen represents the image sharp transformation options.\ntype Sharpen struct {\n\tRadius int\n\tX1     float64\n\tY2     float64\n\tY3     float64\n\tM1     float64\n\tM2     float64\n}\n\n// Options represents the supported image transformation options.\ntype Options struct {\n\tHeight         int\n\tWidth          int\n\tAreaHeight     int\n\tAreaWidth      int\n\tTop            int\n\tLeft           int\n\tQuality        int\n\tCompression    int\n\tZoom           int\n\tCrop           bool\n\tSmartCrop      bool // Deprecated, use: bimg.Options.Gravity = bimg.GravitySmart\n\tEnlarge        bool\n\tEmbed          bool\n\tFlip           bool\n\tFlop           bool\n\tForce          bool\n\tNoAutoRotate   bool\n\tNoProfile      bool\n\tInterlace      bool\n\tStripMetadata  bool\n\tTrim           bool\n\tLossless       bool\n\tExtend         Extend\n\tRotate         Angle\n\tBackground     Color\n\tGravity        Gravity\n\tWatermark      Watermark\n\tWatermarkImage WatermarkImage\n\tType           ImageType\n\tInterpolator   Interpolator\n\tKernel         Kernel\n\tInterpretation Interpretation\n\tGaussianBlur   GaussianBlur\n\tSharpen        Sharpen\n\tThreshold      float64\n\tGamma          float64\n\tBrightness     float64\n\tContrast       float64\n\tOutputICC      string\n\tInputICC       string\n\tPalette        bool\n\t// Speed defines the AVIF encoders CPU effort. Valid values are:\n\t// 0-8 for AVIF encoding.\n\t// 0-9 for PNG encoding.\n\tSpeed int\n\n\t// private fields\n\tautoRotateOnly bool\n}\n"
        },
        {
          "name": "preinstall.sh",
          "type": "blob",
          "size": 13.1806640625,
          "content": "#!/bin/bash\n\n#\n# NOTE: deprecated! Try libvips installation: https://libvips.github.io/libvips/install.html\n#\n\nvips_version_minimum=8.9.2\nvips_version_latest_major_minor=8.9\nvips_version_latest_patch=2\nvips_version_full=\"$vips_version_latest_major_minor.$vips_version_latest_patch\"\n\nopenslide_version_minimum=3.4.0\nopenslide_version_latest_major_minor=3.4\nopenslide_version_latest_patch=1\n\ntarbal_url=\"https://github.com/libvips/libvips/releases/download/v$vips_version_full/vips-$vips_version_full.tar.gz\"\n\ninstall_libvips_from_source() {\n  # Download tarball\n  echo \"Compiling libvips v$vips_version_full from source\"\n  curl -L -o vips-$vips_version_full.tar.gz $tarbal_url\n  tar zvxf vips-$vips_version_full.tar.gz\n  cd vips-$vips_version_full\n\n  # Compile\n  CXXFLAGS=\"-D_GLIBCXX_USE_CXX11_ABI=0\" ./configure --disable-debug --disable-docs --disable-static --disable-introspection --disable-dependency-tracking --enable-cxx=yes --without-python --without-orc --without-fftw $1\n  make\n  make install\n  cd ..\n  rm -rf vips-$vips_version_latest_major_minor.$vips_version_latest_patch\n  rm vips-$vips_version_latest_major_minor.$vips_version_latest_patch.tar.gz\n  ldconfig\n  echo \"Installed libvips $(PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig pkg-config --modversion vips)\"\n}\n\ninstall_libopenslide_from_source() {\n  echo \"Compiling openslide $openslide_version_latest_major_minor.$openslide_version_latest_patch from source\"\n  curl -O -L https://github.com/openslide/openslide/releases/download/v$openslide_version_latest_major_minor.$openslide_version_latest_patch/openslide-$openslide_version_latest_major_minor.$openslide_version_latest_patch.tar.gz\n  tar xzvf openslide-$openslide_version_latest_major_minor.$openslide_version_latest_patch.tar.gz\n  cd openslide-$openslide_version_latest_major_minor.$openslide_version_latest_patch\n  PKG_CONFIG_PATH=$pkg_config_path ./configure $1\n  make\n  make install\n  cd ..\n  rm -rf openslide-$openslide_version_latest_major_minor.$openslide_version_latest_patch\n  rm openslide-$openslide_version_latest_major_minor.$openslide_version_latest_patch.tar.gz\n  ldconfig\n  echo \"Installed libopenslide $openslide_version_latest_major_minor.$openslide_version_latest_patch\"\n}\n\nsorry() {\n  echo \"Sorry, I don't yet know how to install lib$1 on $2\"\n  exit 1\n}\n\npkg_config_path=\"$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig:/usr/lib/pkgconfig\"\n\ncheck_if_library_exists() {\n  PKG_CONFIG_PATH=$pkg_config_path pkg-config --exists $1\n  if [ $? -eq 0 ]; then\n    version_found=$(PKG_CONFIG_PATH=$pkg_config_path pkg-config --modversion $1)\n    PKG_CONFIG_PATH=$pkg_config_path pkg-config --atleast-version=$2 $1\n    if [ $? -eq 0 ]; then\n      # Found suitable version of libvips\n      echo \"Found lib$1 $version_found\"\n      return 1\n    fi\n    echo \"Found lib$1 $version_found but require $2\"\n  else\n    echo \"Could not find lib$1 using a PKG_CONFIG_PATH of '$pkg_config_path'\"\n  fi\n  return 0\n}\n\nenable_openslide=0\n# Is libvips already installed, and is it at least the minimum required version?\nif [ $# -eq 1 ]; then\n  if [ \"$1\" = \"--with-openslide\" ]; then\n    echo \"Installing vips with openslide support\"\n    enable_openslide=1\n  else\n    echo \"Sorry, $1 is not supported. Did you mean --with-openslide?\"\n    exit 1\n  fi\nfi\n\nif ! type pkg-config >/dev/null; then\n  sorry \"vips\" \"a system without pkg-config\"\nfi\n\nopenslide_exists=0\nif [ $enable_openslide -eq 1 ]; then\n  check_if_library_exists \"openslide\" \"$openslide_version_minimum\"\n  openslide_exists=$?\nfi\n\ncheck_if_library_exists \"vips\" \"$vips_version_minimum\"\nvips_exists=$?\nif [ $vips_exists -eq 1 ] && [ $enable_openslide -eq 1 ]; then\n  if [ $openslide_exists -eq 1 ]; then\n    # Check if vips compiled with openslide support\n    vips_with_openslide=`vips list classes | grep -i opensli`\n    if [ -z $vips_with_openslide ]; then\n      echo \"Vips compiled without openslide support.\"\n    else\n      exit 0\n    fi\n  fi\nelif [ $vips_exists -eq 1 ] && [ $enable_openslide -eq 0 ]; then\n  exit 0\nfi\n\n# Verify root/sudo access\nif [ \"$(id -u)\" -ne \"0\" ]; then\n  echo \"Sorry, I need root/sudo access to continue\"\n  exit 1\nfi\n\n# Deprecation warning\nif [ \"$(arch)\" == \"x86_64\" ]; then\n  echo \"This script is no longer required on most 64-bit Linux systems when using sharp v0.12.0+\"\nfi\n\n# OS-specific installations of libopenslide follows\n# Either openslide does not exist, or vips is installed without openslide support\nif [ $enable_openslide -eq 1 ] && [ -z $vips_with_openslide ] && [ $openslide_exists -eq 0 ]; then\n  if [ -f /etc/debian_version ]; then\n    # Debian Linux\n    DISTRO=$(lsb_release -c -s)\n    echo \"Detected Debian Linux '$DISTRO'\"\n    case \"$DISTRO\" in\n      jessie|vivid|wily|xenial|stretch|loki|bullseye)\n        # Debian 9, Debian 8, Ubuntu 15\n        echo \"Installing libopenslide via apt-get\"\n        apt-get install -y libopenslide-dev\n        ;;\n      trusty|utopic|qiana|rebecca|rafaela|freya|rosa|sarah|serena)\n        # Ubuntu 14, Mint 17+\n        echo \"Installing libopenslide dependencies via apt-get\"\n        apt-get install -y automake build-essential curl zlib1g-dev libopenjpeg-dev libpng12-dev libjpeg-dev libtiff5-dev libgdk-pixbuf2.0-dev libxml2-dev libsqlite3-dev libcairo2-dev libglib2.0-dev sqlite3 libsqlite3-dev\n        install_libopenslide_from_source\n        ;;\n      precise|wheezy|maya)\n        # Debian 7, Ubuntu 12.04, Mint 13\n        echo \"Installing libopenslide dependencies via apt-get\"\n        apt-get install -y automake build-essential curl zlib1g-dev libopenjpeg-dev libpng12-dev libjpeg-dev libtiff5-dev libgdk-pixbuf2.0-dev libxml2-dev libsqlite3-dev libcairo2-dev libglib2.0-dev sqlite3 libsqlite3-dev\n        install_libopenslide_from_source\n        ;;\n      *)\n        # Unsupported Debian-based OS\n        sorry \"openslide\" \"Debian-based $DISTRO\"\n        ;;\n    esac\n  elif [ -f /etc/redhat-release ]; then\n    # Red Hat Linux\n    RELEASE=$(cat /etc/redhat-release)\n    echo \"Detected Red Hat Linux '$RELEASE'\"\n    case $RELEASE in\n      \"Red Hat Enterprise Linux release 7.\"*|\"CentOS Linux release 7.\"*|\"Scientific Linux release 7.\"*)\n        # RHEL/CentOS 7\n        echo \"Installing libopenslide dependencies via yum\"\n        yum groupinstall -y \"Development Tools\"\n        yum install -y tar curl libpng-devel libjpeg-devel libxml2-devel zlib-devel openjpeg-devel libtiff-devel gdk-pixbuf2-devel sqlite-devel cairo-devel glib2-devel expat-devel\n        install_libopenslide_from_source \"--prefix=/usr\"\n        ;;\n      \"Red Hat Enterprise Linux release 6.\"*|\"CentOS release 6.\"*|\"Scientific Linux release 6.\"*)\n        # RHEL/CentOS 6\n        echo \"Installing libopenslide dependencies via yum\"\n        yum groupinstall -y \"Development Tools\"\n        yum install -y tar curl libpng-devel libjpeg-devel libxml2-devel zlib-devel openjpeg-devel libtiff-devel gdk-pixbuf2-devel sqlite-devel cairo-devel glib2-devel\n        install_libopenslide_from_source \"--prefix=/usr\"\n        ;;\n      \"Fedora release 21 \"*|\"Fedora release 22 \"*)\n        # Fedora 21, 22\n        echo \"Installing libopenslide via yum\"\n        yum install -y openslide-devel\n        ;;\n      *)\n        # Unsupported RHEL-based OS\n        sorry \"openslide\" \"$RELEASE\"\n        ;;\n    esac\n  elif [ -f /etc/os-release ]; then\n    RELEASE=$(cat /etc/os-release | grep VERSION)\n    echo \"Detected OpenSuse Linux '$RELEASE'\"\n    case $RELEASE in\n      *\"13.2\"*)\n      echo \"Installing libopenslide via zypper\"\n      zypper --gpg-auto-import-keys install -y libopenslide-devel\n      ;;\n    esac\n  elif [ -f /etc/SuSE-brand ]; then\n    RELEASE=$(cat /etc/SuSE-brand | grep VERSION)\n    echo \"Detected OpenSuse Linux '$RELEASE'\"\n    case $RELEASE in\n      *\"13.1\")\n      echo \"Installing libopenslide dependencies via zypper\"\n      zypper --gpg-auto-import-keys install -y --type pattern devel_basis\n      zypper --gpg-auto-import-keys install -y tar curl libpng16-devel libjpeg-turbo libjpeg8-devel libxml2-devel zlib-devel openjpeg-devel libtiff-devel libgdk_pixbuf-2_0-0 sqlite3-devel cairo-devel glib2-devel\n      install_libopenslide_from_source\n      ;;\n    esac\n  else\n    # Unsupported OS\n    sorry \"openslide\" \"$(uname -a)\"\n  fi\nfi\n\n# OS-specific installations of libvips follows\n\nif [ -f /etc/debian_version ]; then\n  # Debian Linux\n  DISTRO=$(lsb_release -c -s)\n  echo \"Detected Debian Linux '$DISTRO'\"\n  case \"$DISTRO\" in\n    jessie|trusty|utopic|vivid|wily|xenial|qiana|rebecca|rafaela|freya|rosa|sarah|serena|loki)\n      # Debian 8, Ubuntu 14.04+, Mint 17+\n      echo \"Installing libvips dependencies via apt-get\"\n      apt-get install -y automake build-essential gobject-introspection gtk-doc-tools libglib2.0-dev libjpeg-dev libpng12-dev libwebp-dev libtiff5-dev libexif-dev libgsf-1-dev liblcms2-dev libxml2-dev swig libmagickcore-dev curl\n      install_libvips_from_source\n      ;;\n    stretch|bullseye)\n      # Debian 9\n      echo \"Installing libvips dependencies via apt-get\"\n      apt-get install -y automake build-essential gobject-introspection gtk-doc-tools libglib2.0-dev libjpeg-dev libpng-dev libwebp-dev libtiff5-dev libexif-dev libgsf-1-dev liblcms2-dev libxml2-dev swig libmagickcore-dev curl\n      install_libvips_from_source\n      ;;\n    precise|wheezy|maya)\n      # Debian 7, Ubuntu 12.04, Mint 13\n      echo \"Installing libvips dependencies via apt-get\"\n      add-apt-repository -y ppa:lyrasis/precise-backports\n      apt-get update\n      apt-get install -y automake build-essential gobject-introspection gtk-doc-tools libglib2.0-dev libjpeg-dev libpng12-dev libwebp-dev libtiff4-dev libexif-dev libgsf-1-dev liblcms2-dev libxml2-dev swig libmagickcore-dev curl\n      install_libvips_from_source\n      ;;\n    *)\n      # Unsupported Debian-based OS\n      sorry \"vips\" \"Debian-based $DISTRO\"\n      ;;\n  esac\nelif [ -f /etc/redhat-release ]; then\n  # Red Hat Linux\n  RELEASE=$(cat /etc/redhat-release)\n  echo \"Detected Red Hat Linux '$RELEASE'\"\n  case $RELEASE in\n    \"Red Hat Enterprise Linux release 7.\"*|\"CentOS Linux release 7.\"*|\"Scientific Linux release 7.\"*)\n      # RHEL/CentOS 7\n      echo \"Installing libvips dependencies via yum\"\n      yum groupinstall -y \"Development Tools\"\n      yum install -y tar curl gtk-doc libxml2-devel libjpeg-turbo-devel libpng-devel libtiff-devel libexif-devel libgsf-devel lcms2-devel ImageMagick-devel gobject-introspection-devel libwebp-devel\n      install_libvips_from_source \"--prefix=/usr\"\n      ;;\n    \"Red Hat Enterprise Linux release 6.\"*|\"CentOS release 6.\"*|\"Scientific Linux release 6.\"*)\n      # RHEL/CentOS 6\n      echo \"Installing libvips dependencies via yum\"\n      yum groupinstall -y \"Development Tools\"\n      yum install -y tar curl gtk-doc libxml2-devel libjpeg-turbo-devel libpng-devel libtiff-devel libexif-devel libgsf-devel lcms-devel ImageMagick-devel\n      yum install -y http://li.nux.ro/download/nux/dextop/el6/x86_64/nux-dextop-release-0-2.el6.nux.noarch.rpm\n      yum install -y --enablerepo=nux-dextop gobject-introspection-devel\n      yum install -y http://rpms.famillecollet.com/enterprise/remi-release-6.rpm\n      yum install -y --enablerepo=remi libwebp-devel\n      install_libvips_from_source \"--prefix=/usr\"\n      ;;\n    \"Fedora\"*)\n      # Fedora 21, 22, 23\n      echo \"Installing libvips dependencies via yum\"\n      yum groupinstall -y \"Development Tools\"\n      yum install -y gcc-c++ gtk-doc libxml2-devel libjpeg-turbo-devel libpng-devel libtiff-devel libexif-devel lcms-devel ImageMagick-devel gobject-introspection-devel libwebp-devel curl\n      install_libvips_from_source \"--prefix=/usr\"\n      ;;\n    *)\n      # Unsupported RHEL-based OS\n      sorry \"vips\" \"$RELEASE\"\n      ;;\n  esac\nelif [ -f /etc/system-release ]; then\n  # Probably Amazon Linux\n  RELEASE=$(cat /etc/system-release)\n  case $RELEASE in\n    \"Amazon Linux AMI release 2015.03\"|\"Amazon Linux AMI release 2015.09\")\n      # Amazon Linux\n      echo \"Detected '$RELEASE'\"\n      echo \"Installing libvips dependencies via yum\"\n      yum groupinstall -y \"Development Tools\"\n      yum install -y gtk-doc libxml2-devel libjpeg-turbo-devel libpng-devel libtiff-devel libexif-devel libgsf-devel lcms2-devel ImageMagick-devel gobject-introspection-devel libwebp-devel curl\n      install_libvips_from_source \"--prefix=/usr\"\n      ;;\n    *)\n      # Unsupported Amazon Linux version\n      sorry \"vips\" \"$RELEASE\"\n      ;;\n  esac\nelif [ -f /etc/os-release ]; then\n  RELEASE=$(cat /etc/os-release | grep VERSION)\n  echo \"Detected OpenSuse Linux '$RELEASE'\"\n  case $RELEASE in\n    *\"13.2\"*)\n    echo \"Installing libvips dependencies via zypper\"\n    zypper --gpg-auto-import-keys install -y --type pattern devel_basis\n    zypper --gpg-auto-import-keys install -y tar curl gtk-doc libxml2-devel libjpeg-turbo libjpeg8-devel libpng16-devel libtiff-devel libexif-devel liblcms2-devel ImageMagick-devel gobject-introspection-devel libwebp-devel\n    install_libvips_from_source\n    ;;\n  esac\nelif [ -f /etc/SuSE-brand ]; then\n  RELEASE=$(cat /etc/SuSE-brand | grep VERSION)\n  echo \"Detected OpenSuse Linux '$RELEASE'\"\n  case $RELEASE in\n    *\"13.1\")\n    echo \"Installing libvips dependencies via zypper\"\n    zypper --gpg-auto-import-keys install -y --type pattern devel_basis\n    zypper --gpg-auto-import-keys install -y tar curl gtk-doc libxml2-devel libjpeg-turbo libjpeg8-devel libpng16-devel libtiff-devel libexif-devel liblcms2-devel ImageMagick-devel gobject-introspection-devel libwebp-devel\n    install_libvips_from_source\n    ;;\n  esac\nelse\n  # Unsupported OS\n  sorry \"vips\" \"$(uname -a)\"\nfi\n"
        },
        {
          "name": "resize.go",
          "type": "blob",
          "size": 0.353515625,
          "content": "// +build go1.7\n\npackage bimg\n\nimport (\n\t\"runtime\"\n)\n\n// Resize is used to transform a given image as byte buffer\n// with the passed options.\nfunc Resize(buf []byte, o Options) ([]byte, error) {\n\t// Required in order to prevent premature garbage collection. See:\n\t// https://github.com/h2non/bimg/pull/162\n\tdefer runtime.KeepAlive(buf)\n\treturn resizer(buf, o)\n}\n"
        },
        {
          "name": "resize_legacy.go",
          "type": "blob",
          "size": 0.25,
          "content": "// +build !go1.7\n\npackage bimg\n\n// Resize is used to transform a given image as byte buffer\n// with the passed options.\n// Used as proxy to resizer() only in Go <= 1.6 versions\nfunc Resize(buf []byte, o Options) ([]byte, error) {\n\treturn resizer(buf, o)\n}\n"
        },
        {
          "name": "resizer.go",
          "type": "blob",
          "size": 14.634765625,
          "content": "package bimg\n\n/*\n#cgo pkg-config: vips\n#include \"vips/vips.h\"\n*/\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n)\n\nvar (\n\t// ErrExtractAreaParamsRequired defines a generic extract area error\n\tErrExtractAreaParamsRequired = errors.New(\"extract area width/height params are required\")\n)\n\n// resizer is used to transform a given image as byte buffer\n// with the passed options.\nfunc resizer(buf []byte, o Options) ([]byte, error) {\n\tdefer C.vips_thread_shutdown()\n\n\timage, imageType, err := loadImage(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Clone and define default options\n\to = applyDefaults(o, imageType)\n\n\t// Ensure supported type\n\tif !IsTypeSupportedSave(o.Type) {\n\t\treturn nil, errors.New(\"Unsupported image output type\")\n\t}\n\n\t// Autorate only\n\tif o.autoRotateOnly {\n\t\timage, err = vipsAutoRotate(image)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn saveImage(image, o)\n\t}\n\n\t// Auto rotate image based on EXIF orientation header\n\timage, rotated, err := rotateAndFlipImage(image, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If JPEG or HEIF image, retrieve the buffer\n\tif rotated && (imageType == JPEG || imageType == HEIF || imageType == AVIF) && !o.NoAutoRotate {\n\t\tbuf, err = getImageBuffer(image)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tinWidth := int(image.Xsize)\n\tinHeight := int(image.Ysize)\n\n\t// Infer the required operation based on the in/out image sizes for a coherent transformation\n\tnormalizeOperation(&o, inWidth, inHeight)\n\n\t// image calculations\n\tfactor := imageCalculations(&o, inWidth, inHeight)\n\tshrink := calculateShrink(factor, o.Interpolator)\n\tresidual := calculateResidual(factor, shrink)\n\n\t// Do not enlarge the output if the input width or height\n\t// are already less than the required dimensions\n\tif !o.Enlarge && !o.Force {\n\t\tif inWidth < o.Width && inHeight < o.Height {\n\t\t\tfactor = 1.0\n\t\t\tshrink = 1\n\t\t\tresidual = 0\n\t\t\to.Width = inWidth\n\t\t\to.Height = inHeight\n\t\t}\n\t}\n\n\t// Try to use libjpeg/libwebp shrink-on-load\n\tsupportsShrinkOnLoad := imageType == WEBP && VipsMajorVersion >= 8 && VipsMinorVersion >= 3\n\tsupportsShrinkOnLoad = supportsShrinkOnLoad || imageType == JPEG\n\tif supportsShrinkOnLoad && shrink >= 2 {\n\t\ttmpImage, factor, err := shrinkOnLoad(buf, image, imageType, factor, shrink)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\timage = tmpImage\n\t\tfactor = math.Max(factor, 1.0)\n\t\tshrink = int(math.Floor(factor))\n\t\tresidual = float64(shrink) / factor\n\t}\n\n\t// Zoom image, if necessary\n\timage, err = zoomImage(image, o.Zoom)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Transform image, if necessary\n\tif shouldTransformImage(o, inWidth, inHeight) {\n\t\timage, err = transformImage(image, o, shrink, residual)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Apply effects, if necessary\n\tif shouldApplyEffects(o) {\n\t\timage, err = applyEffects(image, o)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Add watermark, if necessary\n\timage, err = watermarkImageWithText(image, o.Watermark)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Add watermark, if necessary\n\timage, err = watermarkImageWithAnotherImage(image, o.WatermarkImage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Flatten image on a background, if necessary\n\timage, err = imageFlatten(image, imageType, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Apply Gamma filter, if necessary\n\timage, err = applyGamma(image, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Apply brightness, if necessary\n\timage, err = applyBrightness(image, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Apply contrast, if necessary\n\timage, err = applyContrast(image, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn saveImage(image, o)\n}\n\nfunc loadImage(buf []byte) (*C.VipsImage, ImageType, error) {\n\tif len(buf) == 0 {\n\t\treturn nil, JPEG, errors.New(\"Image buffer is empty\")\n\t}\n\n\timage, imageType, err := vipsRead(buf)\n\tif err != nil {\n\t\treturn nil, JPEG, err\n\t}\n\n\treturn image, imageType, nil\n}\n\nfunc applyDefaults(o Options, imageType ImageType) Options {\n\tif o.Quality == 0 {\n\t\to.Quality = Quality\n\t}\n\tif o.Compression == 0 {\n\t\to.Compression = 6\n\t}\n\tif o.Type == 0 {\n\t\to.Type = imageType\n\t}\n\tif o.Interpretation == 0 {\n\t\to.Interpretation = InterpretationSRGB\n\t}\n\tif o.Palette {\n\t\t// Default value of effort in libvips is 7.\n\t\to.Speed = 3\n\t}\n\treturn o\n}\n\nfunc saveImage(image *C.VipsImage, o Options) ([]byte, error) {\n\tsaveOptions := vipsSaveOptions{\n\t\tQuality:        o.Quality,\n\t\tType:           o.Type,\n\t\tCompression:    o.Compression,\n\t\tInterlace:      o.Interlace,\n\t\tNoProfile:      o.NoProfile,\n\t\tInterpretation: o.Interpretation,\n\t\tInputICC:       o.InputICC,\n\t\tOutputICC:      o.OutputICC,\n\t\tStripMetadata:  o.StripMetadata,\n\t\tLossless:       o.Lossless,\n\t\tPalette:        o.Palette,\n\t\tSpeed:          o.Speed,\n\t}\n\t// Finally get the resultant buffer\n\treturn vipsSave(image, saveOptions)\n}\n\nfunc normalizeOperation(o *Options, inWidth, inHeight int) {\n\tif !o.Force && !o.Crop && !o.Embed && !o.Enlarge && o.Rotate == 0 && (o.Width > 0 || o.Height > 0) {\n\t\to.Force = true\n\t}\n}\n\nfunc shouldTransformImage(o Options, inWidth, inHeight int) bool {\n\treturn o.Force || (o.Width > 0 && o.Width != inWidth) ||\n\t\t(o.Height > 0 && o.Height != inHeight) || o.AreaWidth > 0 || o.AreaHeight > 0 ||\n\t\to.Trim\n}\n\nfunc shouldApplyEffects(o Options) bool {\n\treturn o.GaussianBlur.Sigma > 0 || o.GaussianBlur.MinAmpl > 0 || o.Sharpen.Radius > 0 && o.Sharpen.Y2 > 0 || o.Sharpen.Y3 > 0\n}\n\nfunc transformImage(image *C.VipsImage, o Options, shrink int, residual float64) (*C.VipsImage, error) {\n\tvar err error\n\t// Use vips_shrink with the integral reduction\n\tif shrink > 1 {\n\t\timage, residual, err = shrinkImage(image, o, residual, shrink)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tresidualx, residualy := residual, residual\n\tif o.Force {\n\t\tresidualx = float64(o.Width) / float64(image.Xsize)\n\t\tresidualy = float64(o.Height) / float64(image.Ysize)\n\t}\n\n\tif o.Force || residual != 0 {\n\t\tif residualx < 1 && residualy < 1 {\n\t\t\timage, err = vipsReduce(image, 1/residualx, 1/residualy, o.Kernel)\n\t\t} else {\n\t\t\timage, err = vipsAffine(image, residualx, residualy, o.Interpolator, o.Extend)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif o.Force {\n\t\to.Crop = false\n\t\to.Embed = false\n\t}\n\n\timage, err = extractOrEmbedImage(image, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn image, nil\n}\n\nfunc applyEffects(image *C.VipsImage, o Options) (*C.VipsImage, error) {\n\tvar err error\n\n\tif o.GaussianBlur.Sigma > 0 || o.GaussianBlur.MinAmpl > 0 {\n\t\timage, err = vipsGaussianBlur(image, o.GaussianBlur)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif o.Sharpen.Radius > 0 && o.Sharpen.Y2 > 0 || o.Sharpen.Y3 > 0 {\n\t\timage, err = vipsSharpen(image, o.Sharpen)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn image, nil\n}\n\nfunc extractOrEmbedImage(image *C.VipsImage, o Options) (*C.VipsImage, error) {\n\tvar err error\n\tinWidth := int(image.Xsize)\n\tinHeight := int(image.Ysize)\n\n\tswitch {\n\tcase o.Gravity == GravitySmart, o.SmartCrop:\n\t\t// it's already at an appropriate size, return immediately\n\t\tif inWidth <= o.Width && inHeight <= o.Height {\n\t\t\tbreak\n\t\t}\n\t\twidth := int(math.Min(float64(inWidth), float64(o.Width)))\n\t\theight := int(math.Min(float64(inHeight), float64(o.Height)))\n\t\timage, err = vipsSmartCrop(image, width, height)\n\t\tbreak\n\tcase o.Crop:\n\t\t// it's already at an appropriate size, return immediately\n\t\tif inWidth <= o.Width && inHeight <= o.Height {\n\t\t\tbreak\n\t\t}\n\t\twidth := int(math.Min(float64(inWidth), float64(o.Width)))\n\t\theight := int(math.Min(float64(inHeight), float64(o.Height)))\n\t\tleft, top := calculateCrop(inWidth, inHeight, o.Width, o.Height, o.Gravity)\n\t\tleft, top = int(math.Max(float64(left), 0)), int(math.Max(float64(top), 0))\n\t\timage, err = vipsExtract(image, left, top, width, height)\n\t\tbreak\n\tcase o.Embed:\n\t\tleft, top := (o.Width-inWidth)/2, (o.Height-inHeight)/2\n\t\timage, err = vipsEmbed(image, left, top, o.Width, o.Height, o.Extend, o.Background)\n\t\tbreak\n\tcase o.Trim:\n\t\tleft, top, width, height, err := vipsTrim(image, o.Background, o.Threshold)\n\t\tif err == nil {\n\t\t\timage, err = vipsExtract(image, left, top, width, height)\n\t\t}\n\t\tbreak\n\tcase o.Top != 0 || o.Left != 0 || o.AreaWidth != 0 || o.AreaHeight != 0:\n\t\tif o.AreaWidth == 0 {\n\t\t\to.AreaWidth = o.Width\n\t\t}\n\t\tif o.AreaHeight == 0 {\n\t\t\to.AreaHeight = o.Height\n\t\t}\n\t\tif o.AreaWidth == 0 || o.AreaHeight == 0 {\n\t\t\treturn nil, errors.New(\"Extract area width/height params are required\")\n\t\t}\n\t\timage, err = vipsExtract(image, o.Left, o.Top, o.AreaWidth, o.AreaHeight)\n\t\tbreak\n\t}\n\n\treturn image, err\n}\n\nfunc rotateAndFlipImage(image *C.VipsImage, o Options) (*C.VipsImage, bool, error) {\n\tvar err error\n\tvar rotated bool\n\n\tif o.NoAutoRotate == false {\n\t\trotation, flip := calculateRotationAndFlip(image, o.Rotate)\n\t\tif flip {\n\t\t\to.Flip = flip\n\t\t}\n\t\tif rotation > 0 && o.Rotate == 0 {\n\t\t\to.Rotate = rotation\n\t\t}\n\t}\n\n\tif o.Rotate > 0 {\n\t\trotated = true\n\t\timage, err = vipsRotate(image, getAngle(o.Rotate))\n\t}\n\n\tif o.Flip {\n\t\trotated = true\n\t\timage, err = vipsFlip(image, Horizontal)\n\t}\n\n\tif o.Flop {\n\t\trotated = true\n\t\timage, err = vipsFlip(image, Vertical)\n\t}\n\treturn image, rotated, err\n}\n\nfunc watermarkImageWithText(image *C.VipsImage, w Watermark) (*C.VipsImage, error) {\n\tif w.Text == \"\" {\n\t\treturn image, nil\n\t}\n\n\t// Defaults\n\tif w.Font == \"\" {\n\t\tw.Font = WatermarkFont\n\t}\n\tif w.Width == 0 {\n\t\tw.Width = int(math.Floor(float64(image.Xsize / 6)))\n\t}\n\tif w.DPI == 0 {\n\t\tw.DPI = 150\n\t}\n\tif w.Margin == 0 {\n\t\tw.Margin = w.Width\n\t}\n\tif w.Opacity == 0 {\n\t\tw.Opacity = 0.25\n\t} else if w.Opacity > 1 {\n\t\tw.Opacity = 1\n\t}\n\n\timage, err := vipsWatermark(image, w)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn image, nil\n}\n\nfunc watermarkImageWithAnotherImage(image *C.VipsImage, w WatermarkImage) (*C.VipsImage, error) {\n\tif len(w.Buf) == 0 {\n\t\treturn image, nil\n\t}\n\n\tif w.Opacity == 0.0 {\n\t\tw.Opacity = 1.0\n\t}\n\n\timage, err := vipsDrawWatermark(image, w)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn image, nil\n}\n\nfunc imageFlatten(image *C.VipsImage, imageType ImageType, o Options) (*C.VipsImage, error) {\n\tif o.Background == ColorBlack {\n\t\treturn image, nil\n\t}\n\treturn vipsFlattenBackground(image, o.Background)\n}\n\nfunc applyGamma(image *C.VipsImage, o Options) (*C.VipsImage, error) {\n\tvar err error\n\tif o.Gamma > 0 {\n\t\timage, err = vipsGamma(image, o.Gamma)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn image, nil\n}\n\nfunc zoomImage(image *C.VipsImage, zoom int) (*C.VipsImage, error) {\n\tif zoom == 0 {\n\t\treturn image, nil\n\t}\n\treturn vipsZoom(image, zoom+1)\n}\n\nfunc shrinkImage(image *C.VipsImage, o Options, residual float64, shrink int) (*C.VipsImage, float64, error) {\n\t// Use vips_shrink with the integral reduction\n\timage, err := vipsShrink(image, shrink)\n\tif err != nil {\n\t\treturn nil, 0, err\n\t}\n\n\t// Recalculate residual float based on dimensions of required vs shrunk images\n\tresidualx := float64(o.Width) / float64(image.Xsize)\n\tresidualy := float64(o.Height) / float64(image.Ysize)\n\n\tif o.Crop {\n\t\tresidual = math.Max(residualx, residualy)\n\t} else {\n\t\tresidual = math.Min(residualx, residualy)\n\t}\n\n\treturn image, residual, nil\n}\n\nfunc shrinkOnLoad(buf []byte, input *C.VipsImage, imageType ImageType, factor float64, shrink int) (*C.VipsImage, float64, error) {\n\tvar (\n\t\timage *C.VipsImage\n\t\terr   error\n\t)\n\n\tif shrink < 2 {\n\t\treturn nil, 0, fmt.Errorf(\"only available for shrink >=2\")\n\t}\n\n\tshrinkOnLoad := 1\n\t// Recalculate integral shrink and double residual\n\tswitch {\n\tcase shrink >= 8:\n\t\tfactor = factor / 8\n\t\tshrinkOnLoad = 8\n\tcase shrink >= 4:\n\t\tfactor = factor / 4\n\t\tshrinkOnLoad = 4\n\tcase shrink >= 2:\n\t\tfactor = factor / 2\n\t\tshrinkOnLoad = 2\n\t}\n\n\t// Reload input using shrink-on-load\n\tswitch imageType {\n\tcase JPEG:\n\t\timage, err = vipsShrinkJpeg(buf, input, shrinkOnLoad)\n\tcase WEBP:\n\t\timage, err = vipsShrinkWebp(buf, input, shrinkOnLoad)\n\tdefault:\n\t\treturn nil, 0, fmt.Errorf(\"%v doesn't support shrink on load\", ImageTypeName(imageType))\n\t}\n\n\treturn image, factor, err\n}\n\nfunc imageCalculations(o *Options, inWidth, inHeight int) float64 {\n\tfactor := 1.0\n\txfactor := float64(inWidth) / float64(o.Width)\n\tyfactor := float64(inHeight) / float64(o.Height)\n\n\tswitch {\n\t// Fixed width and height\n\tcase o.Width > 0 && o.Height > 0:\n\t\tif o.Crop {\n\t\t\tfactor = math.Min(xfactor, yfactor)\n\t\t} else {\n\t\t\tfactor = math.Max(xfactor, yfactor)\n\t\t}\n\t// Fixed width, auto height\n\tcase o.Width > 0:\n\t\tif o.Crop {\n\t\t\to.Height = inHeight\n\t\t} else {\n\t\t\tfactor = xfactor\n\t\t\to.Height = roundFloat(float64(inHeight) / factor)\n\t\t}\n\t// Fixed height, auto width\n\tcase o.Height > 0:\n\t\tif o.Crop {\n\t\t\to.Width = inWidth\n\t\t} else {\n\t\t\tfactor = yfactor\n\t\t\to.Width = roundFloat(float64(inWidth) / factor)\n\t\t}\n\t// Identity transform\n\tdefault:\n\t\to.Width = inWidth\n\t\to.Height = inHeight\n\t\tbreak\n\t}\n\n\treturn factor\n}\n\nfunc roundFloat(f float64) int {\n\tif f < 0 {\n\t\treturn int(math.Ceil(f - 0.5))\n\t}\n\treturn int(math.Floor(f + 0.5))\n}\n\nfunc calculateCrop(inWidth, inHeight, outWidth, outHeight int, gravity Gravity) (int, int) {\n\tleft, top := 0, 0\n\n\tswitch gravity {\n\tcase GravityNorth:\n\t\tleft = (inWidth - outWidth + 1) / 2\n\tcase GravityEast:\n\t\tleft = inWidth - outWidth\n\t\ttop = (inHeight - outHeight + 1) / 2\n\tcase GravitySouth:\n\t\tleft = (inWidth - outWidth + 1) / 2\n\t\ttop = inHeight - outHeight\n\tcase GravityWest:\n\t\ttop = (inHeight - outHeight + 1) / 2\n\tdefault:\n\t\tleft = (inWidth - outWidth + 1) / 2\n\t\ttop = (inHeight - outHeight + 1) / 2\n\t}\n\n\treturn left, top\n}\n\nfunc calculateRotationAndFlip(image *C.VipsImage, angle Angle) (Angle, bool) {\n\trotate := D0\n\tflip := false\n\n\tif angle > 0 {\n\t\treturn rotate, flip\n\t}\n\n\tswitch vipsExifOrientation(image) {\n\tcase 6:\n\t\trotate = D90\n\t\tbreak\n\tcase 3:\n\t\trotate = D180\n\t\tbreak\n\tcase 8:\n\t\trotate = D270\n\t\tbreak\n\tcase 2:\n\t\tflip = true\n\t\tbreak // flip 1\n\tcase 7:\n\t\tflip = true\n\t\trotate = D270\n\t\tbreak // flip 6\n\tcase 4:\n\t\tflip = true\n\t\trotate = D180\n\t\tbreak // flip 3\n\tcase 5:\n\t\tflip = true\n\t\trotate = D90\n\t\tbreak // flip 8\n\t}\n\n\treturn rotate, flip\n}\n\nfunc calculateShrink(factor float64, i Interpolator) int {\n\tvar shrink float64\n\n\t// Calculate integral box shrink\n\twindowSize := vipsWindowSize(i.String())\n\tif factor >= 2 && windowSize > 3 {\n\t\t// Shrink less, affine more with interpolators that use at least 4x4 pixel window, e.g. bicubic\n\t\tshrink = float64(math.Floor(factor * 3.0 / windowSize))\n\t} else {\n\t\tshrink = math.Floor(factor)\n\t}\n\n\treturn int(math.Max(shrink, 1))\n}\n\nfunc calculateResidual(factor float64, shrink int) float64 {\n\treturn float64(shrink) / factor\n}\n\nfunc getAngle(angle Angle) Angle {\n\tdivisor := angle % 90\n\tif divisor != 0 {\n\t\tangle = angle - divisor\n\t}\n\treturn Angle(math.Min(float64(angle), 270))\n}\n\nfunc applyBrightness(image *C.VipsImage, o Options) (*C.VipsImage, error) {\n\tvar err error\n\tif o.Brightness != 0 {\n\t\timage, err = vipsBrightness(image, o.Brightness)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn image, nil\n}\n\nfunc applyContrast(image *C.VipsImage, o Options) (*C.VipsImage, error) {\n\tvar err error\n\tif o.Contrast > 0 {\n\t\timage, err = vipsContrast(image, o.Contrast)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn image, nil\n}\n"
        },
        {
          "name": "resizer_test.go",
          "type": "blob",
          "size": 19.744140625,
          "content": "package bimg\n\nimport (\n\t\"bytes\"\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/jpeg\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestResize(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tif DetermineImageType(newImg) != JPEG {\n\t\tt.Fatal(\"Image is not jpeg\")\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_out.jpg\", newImg)\n}\n\nfunc TestResizeVerticalImage(t *testing.T) {\n\ttests := []Options{\n\t\t{Width: 800, Height: 600},\n\t\t{Width: 1000, Height: 1000},\n\t\t{Width: 1000, Height: 1500},\n\t\t{Width: 1000},\n\t\t{Height: 1500},\n\t\t{Width: 200, Height: 120},\n\t\t{Width: 2000, Height: 2000},\n\t\t{Width: 500, Height: 1000},\n\t\t{Width: 500},\n\t\t{Height: 500},\n\t\t{Crop: true, Width: 500, Height: 1000},\n\t\t{Crop: true, Enlarge: true, Width: 2000, Height: 1400},\n\t\t{Enlarge: true, Force: true, Width: 2000, Height: 2000},\n\t\t{Force: true, Width: 2000, Height: 2000},\n\t}\n\n\tbufJpeg, err := Read(\"testdata/vertical.jpg\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbufWebp, err := Read(\"testdata/vertical.webp\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\timages := []struct {\n\t\tformat ImageType\n\t\tbuf    []byte\n\t}{\n\t\t{JPEG, bufJpeg},\n\t\t{WEBP, bufWebp},\n\t}\n\n\tfor _, source := range images {\n\t\tfor _, options := range tests {\n\t\t\timage, err := Resize(source.buf, options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t\t\t}\n\n\t\t\tformat := DetermineImageType(image)\n\t\t\tif format != source.format {\n\t\t\t\tt.Fatalf(\"Image format is invalid. Expected: %#v got %v\", ImageTypeName(source.format), ImageTypeName(format))\n\t\t\t}\n\n\t\t\tsize, _ := Size(image)\n\t\t\tif options.Height > 0 && size.Height != options.Height {\n\t\t\t\tt.Fatalf(\"Invalid height: %d\", size.Height)\n\t\t\t}\n\t\t\tif options.Width > 0 && size.Width != options.Width {\n\t\t\t\tt.Fatalf(\"Invalid width: %d\", size.Width)\n\t\t\t}\n\n\t\t\tWrite(\n\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\"testdata/test_vertical_%dx%d_out.%s\",\n\t\t\t\t\toptions.Width,\n\t\t\t\t\toptions.Height,\n\t\t\t\t\tImageTypeName(source.format)),\n\t\t\t\timage)\n\t\t}\n\t}\n}\n\nfunc TestResizeCustomSizes(t *testing.T) {\n\ttests := []Options{\n\t\t{Width: 800, Height: 600},\n\t\t{Width: 1000, Height: 1000},\n\t\t{Width: 100, Height: 50},\n\t\t{Width: 2000, Height: 2000},\n\t\t{Width: 500, Height: 1000},\n\t\t{Width: 500},\n\t\t{Height: 500},\n\t\t{Crop: true, Width: 500, Height: 1000},\n\t\t{Crop: true, Enlarge: true, Width: 2000, Height: 1400},\n\t\t{Enlarge: true, Force: true, Width: 2000, Height: 2000},\n\t\t{Force: true, Width: 2000, Height: 2000},\n\t}\n\n\tbufJpeg, err := Read(\"testdata/test.jpg\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbufWebp, err := Read(\"testdata/test.webp\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\timages := []struct {\n\t\tformat ImageType\n\t\tbuf    []byte\n\t}{\n\t\t{JPEG, bufJpeg},\n\t\t{WEBP, bufWebp},\n\t}\n\n\tfor _, source := range images {\n\t\tfor _, options := range tests {\n\t\t\timage, err := Resize(source.buf, options)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t\t\t}\n\n\t\t\tif DetermineImageType(image) != source.format {\n\t\t\t\tt.Fatalf(\"Image format is invalid. Expected: %#v\", source.format)\n\t\t\t}\n\n\t\t\tsize, _ := Size(image)\n\n\t\t\tinvalidHeight := options.Height > 0 && size.Height != options.Height\n\t\t\tif !options.Crop && invalidHeight {\n\t\t\t\tt.Fatalf(\"Invalid height: %d, expected %d\", size.Height, options.Height)\n\t\t\t}\n\n\t\t\tinvalidWidth := options.Width > 0 && size.Width != options.Width\n\t\t\tif !options.Crop && invalidWidth {\n\t\t\t\tt.Fatalf(\"Invalid width: %d, expected %d\", size.Width, options.Width)\n\t\t\t}\n\n\t\t\tif options.Crop && invalidHeight && invalidWidth {\n\t\t\t\tt.Fatalf(\"Invalid width or height: %dx%d, expected %dx%d (crop)\", size.Width, size.Height, options.Width, options.Height)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestResizePrecision(t *testing.T) {\n\t// see https://github.com/h2non/bimg/issues/99\n\timg := image.NewGray16(image.Rect(0, 0, 1920, 1080))\n\tinput := &bytes.Buffer{}\n\tjpeg.Encode(input, img, nil)\n\n\topts := Options{Width: 300}\n\tnewImg, err := Resize(input.Bytes(), opts)\n\tif err != nil {\n\t\tt.Fatalf(\"Resize(imgData, %#v) error: %#v\", opts, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Width != opts.Width {\n\t\tt.Fatalf(\"Invalid width: %d\", size.Width)\n\t}\n}\n\nfunc TestRotate(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600, Rotate: 270, Crop: true}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tif DetermineImageType(newImg) != JPEG {\n\t\tt.Error(\"Image is not jpeg\")\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Width != options.Width || size.Height != options.Height {\n\t\tt.Errorf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_rotate_out.jpg\", newImg)\n}\n\nfunc TestInvalidRotateDegrees(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600, Rotate: 111, Crop: true}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tif DetermineImageType(newImg) != JPEG {\n\t\tt.Errorf(\"Image is not jpeg\")\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Width != options.Width || size.Height != options.Height {\n\t\tt.Errorf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_rotate_invalid_out.jpg\", newImg)\n}\n\nfunc TestCorruptedImage(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600}\n\tbuf, _ := Read(\"testdata/corrupt.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tif DetermineImageType(newImg) != JPEG {\n\t\tt.Fatal(\"Image is not jpeg\")\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_corrupt_out.jpg\", newImg)\n}\n\nfunc TestNoColorProfile(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600, NoProfile: true}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tmetadata, err := Metadata(newImg)\n\tif metadata.Profile == true {\n\t\tt.Fatal(\"Invalid profile data\")\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n}\n\nfunc TestEmbedExtendColor(t *testing.T) {\n\toptions := Options{Width: 400, Height: 600, Crop: false, Embed: true, Extend: ExtendWhite, Background: Color{255, 20, 10}}\n\tbuf, _ := Read(\"testdata/test_issue.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_extend_white_out.jpg\", newImg)\n}\n\nfunc TestEmbedExtendWithCustomColor(t *testing.T) {\n\toptions := Options{Width: 400, Height: 600, Crop: false, Embed: true, Extend: 5, Background: Color{255, 20, 10}}\n\tbuf, _ := Read(\"testdata/test_issue.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_extend_background_out.jpg\", newImg)\n}\n\nfunc TestGaussianBlur(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600, GaussianBlur: GaussianBlur{Sigma: 5}}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_gaussian_out.jpg\", newImg)\n}\n\nfunc TestSharpen(t *testing.T) {\n\toptions := Options{Width: 800, Height: 600, Sharpen: Sharpen{Radius: 1, X1: 1.5, Y2: 20, Y3: 50, M1: 1, M2: 2}}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.Height || size.Width != options.Width {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_sharpen_out.jpg\", newImg)\n}\n\nfunc TestExtractWithDefaultAxis(t *testing.T) {\n\toptions := Options{AreaWidth: 200, AreaHeight: 200}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.AreaHeight || size.Width != options.AreaWidth {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_extract_defaults_out.jpg\", newImg)\n}\n\nfunc TestExtractCustomAxis(t *testing.T) {\n\toptions := Options{Top: 100, Left: 100, AreaWidth: 200, AreaHeight: 200}\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != options.AreaHeight || size.Width != options.AreaWidth {\n\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t}\n\n\tWrite(\"testdata/test_extract_custom_axis_out.jpg\", newImg)\n}\n\nfunc TestExtractOrEmbedImage(t *testing.T) {\n\tbuf, _ := Read(\"testdata/test.jpg\")\n\tinput, _, err := loadImage(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to load image %s\", err)\n\t}\n\n\to := Options{\n\t\tTop:    10,\n\t\tLeft:   10,\n\t\tWidth:  100,\n\t\tHeight: 200,\n\n\t\t// Fields to test\n\t\tAreaHeight: 0,\n\t\tAreaWidth:  0,\n\n\t\tQuality: 100, /* Needs a value to satisfy libvips */\n\t}\n\n\tresult, err := extractOrEmbedImage(input, o)\n\tif err != nil {\n\t\tif err == ErrExtractAreaParamsRequired {\n\t\t\tt.Fatalf(\"Expecting AreaWidth and AreaHeight to have been defined\")\n\t\t}\n\n\t\tt.Fatalf(\"Unknown error occurred %s\", err)\n\t}\n\n\timage, err := saveImage(result, o)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed saving image %s\", err)\n\t}\n\n\ttest, err := Size(image)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed fetching the size %s\", err)\n\t}\n\n\tif test.Height != o.Height {\n\t\tt.Errorf(\"Extract failed, resulting Height %d doesn't match %d\", test.Height, o.Height)\n\t}\n\n\tif test.Width != o.Width {\n\t\tt.Errorf(\"Extract failed, resulting Width %d doesn't match %d\", test.Width, o.Width)\n\t}\n}\n\nfunc TestConvert(t *testing.T) {\n\twidth, height := 300, 240\n\tformats := [3]ImageType{PNG, WEBP, JPEG}\n\n\tfiles := []string{\n\t\t\"test.jpg\",\n\t\t\"test.png\",\n\t\t\"test.webp\",\n\t}\n\n\tfor _, file := range files {\n\t\timg, err := os.Open(\"testdata/\" + file)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tbuf, err := ioutil.ReadAll(img)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\timg.Close()\n\n\t\tfor _, format := range formats {\n\t\t\toptions := Options{Width: width, Height: height, Crop: true, Type: format}\n\n\t\t\tnewImg, err := Resize(buf, options)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t\t\t}\n\n\t\t\tif DetermineImageType(newImg) != format {\n\t\t\t\tt.Fatal(\"Image is not png\")\n\t\t\t}\n\n\t\t\tsize, _ := Size(newImg)\n\t\t\tif size.Height != height || size.Width != width {\n\t\t\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestResizePngWithTransparency(t *testing.T) {\n\twidth, height := 300, 240\n\n\toptions := Options{Width: width, Height: height, Crop: true}\n\timg, err := os.Open(\"testdata/transparent.png\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer img.Close()\n\n\tbuf, err := ioutil.ReadAll(img)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tnewImg, err := Resize(buf, options)\n\tif err != nil {\n\t\tt.Errorf(\"Resize(imgData, %#v) error: %#v\", options, err)\n\t}\n\n\tif DetermineImageType(newImg) != PNG {\n\t\tt.Fatal(\"Image is not png\")\n\t}\n\n\tsize, _ := Size(newImg)\n\tif size.Height != height || size.Width != width {\n\t\tt.Fatal(\"Invalid image size\")\n\t}\n\n\tWrite(\"testdata/transparent_out.png\", newImg)\n}\n\nfunc TestRotationAndFlip(t *testing.T) {\n\tfiles := []struct {\n\t\tName  string\n\t\tAngle Angle\n\t\tFlip  bool\n\t}{\n\t\t{\"Landscape_1\", 0, false},\n\t\t{\"Landscape_2\", 0, true},\n\t\t{\"Landscape_3\", D180, false},\n\t\t{\"Landscape_4\", D180, true},\n\t\t{\"Landscape_5\", D90, true},\n\t\t{\"Landscape_6\", D90, false},\n\t\t{\"Landscape_7\", D270, true},\n\t\t{\"Landscape_8\", D270, false},\n\t\t{\"Portrait_1\", 0, false},\n\t\t{\"Portrait_2\", 0, true},\n\t\t{\"Portrait_3\", D180, false},\n\t\t{\"Portrait_4\", D180, true},\n\t\t{\"Portrait_5\", D90, true},\n\t\t{\"Portrait_6\", D90, false},\n\t\t{\"Portrait_7\", D270, true},\n\t\t{\"Portrait_8\", D270, false},\n\t}\n\n\tfor _, file := range files {\n\t\timg, err := os.Open(fmt.Sprintf(\"testdata/exif/%s.jpg\", file.Name))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tbuf, err := ioutil.ReadAll(img)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\timg.Close()\n\n\t\timage, _, err := loadImage(buf)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tangle, flip := calculateRotationAndFlip(image, D0)\n\t\tif angle != file.Angle {\n\t\t\tt.Errorf(\"Rotation for %v expected to be %v. got %v\", file.Name, file.Angle, angle)\n\t\t}\n\t\tif flip != file.Flip {\n\t\t\tt.Errorf(\"Flip for %v expected to be %v. got %v\", file.Name, file.Flip, flip)\n\t\t}\n\n\t\t// Visual debugging.\n\t\tnewImg, err := Resize(buf, Options{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tWrite(fmt.Sprintf(\"testdata/exif/%s_out.jpg\", file.Name), newImg)\n\t}\n}\n\nfunc TestIfBothSmartCropOptionsAreIdentical(t *testing.T) {\n\tif !(VipsMajorVersion >= 8 && VipsMinorVersion > 4) {\n\t\tt.Skipf(\"Skipping this test, libvips doesn't meet version requirement %s > 8.4\", VipsVersion)\n\t}\n\n\tbenchmarkOptions := Options{Width: 100, Height: 100, Crop: true}\n\tsmartCropOptions := Options{Width: 100, Height: 100, Crop: true, SmartCrop: true}\n\tgravityOptions := Options{Width: 100, Height: 100, Crop: true, Gravity: GravitySmart}\n\n\ttestImg, err := os.Open(\"testdata/northern_cardinal_bird.jpg\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testImg.Close()\n\n\ttestImgByte, err := ioutil.ReadAll(testImg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tscImg, err := Resize(testImgByte, smartCropOptions)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgImg, err := Resize(testImgByte, gravityOptions)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbenchmarkImg, err := Resize(testImgByte, benchmarkOptions)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsch, gh, bh := md5.Sum(scImg), md5.Sum(gImg), md5.Sum(benchmarkImg)\n\tif gh == bh || sch == bh {\n\t\tt.Error(\"Expected both options produce a different result from a standard crop.\")\n\t}\n\n\tif sch != gh {\n\t\tt.Errorf(\"Expected both options to result in the same output, %x != %x\", sch, gh)\n\t}\n}\n\nfunc TestSkipCropIfTooSmall(t *testing.T) {\n\ttestCases := []struct {\n\t\tname    string\n\t\toptions Options\n\t}{\n\t\t{\n\t\t\tname: \"smart crop\",\n\t\t\toptions: Options{\n\t\t\t\tWidth:   140,\n\t\t\t\tHeight:  140,\n\t\t\t\tCrop:    true,\n\t\t\t\tGravity: GravitySmart,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"centre crop\",\n\t\t\toptions: Options{\n\t\t\t\tWidth:   140,\n\t\t\t\tHeight:  140,\n\t\t\t\tCrop:    true,\n\t\t\t\tGravity: GravityCentre,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"embed\",\n\t\t\toptions: Options{\n\t\t\t\tWidth:  140,\n\t\t\t\tHeight: 140,\n\t\t\t\tEmbed:  true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"extract\",\n\t\t\toptions: Options{\n\t\t\t\tTop:        0,\n\t\t\t\tLeft:       0,\n\t\t\t\tAreaWidth:  140,\n\t\t\t\tAreaHeight: 140,\n\t\t\t},\n\t\t},\n\t}\n\n\ttestImg, err := os.Open(\"testdata/test_bad_extract_area.jpg\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer testImg.Close()\n\n\ttestImgByte, err := ioutil.ReadAll(testImg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\n\t\t\tcroppedImage, err := Resize(testImgByte, tc.options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tsize, _ := Size(croppedImage)\n\t\t\tif tc.options.Height-size.Height > 1 || tc.options.Width-size.Width > 1 {\n\t\t\t\tt.Fatalf(\"Invalid image size: %dx%d\", size.Width, size.Height)\n\t\t\t}\n\t\t\tt.Logf(\"size for %s is %dx%d\", tc.name, size.Width, size.Height)\n\t\t})\n\t}\n}\n\nfunc runBenchmarkResize(file string, o Options, b *testing.B) {\n\tbuf, _ := Read(path.Join(\"testdata\", file))\n\n\tfor n := 0; n < b.N; n++ {\n\t\tResize(buf, o)\n\t}\n}\n\nfunc BenchmarkRotateJpeg(b *testing.B) {\n\toptions := Options{Rotate: 180}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkResizeLargeJpeg(b *testing.B) {\n\toptions := Options{\n\t\tWidth:  800,\n\t\tHeight: 600,\n\t}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkResizePng(b *testing.B) {\n\toptions := Options{\n\t\tWidth:  200,\n\t\tHeight: 200,\n\t}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkResizeWebp(b *testing.B) {\n\toptions := Options{\n\t\tWidth:  200,\n\t\tHeight: 200,\n\t}\n\trunBenchmarkResize(\"test.webp\", options, b)\n}\n\nfunc BenchmarkConvertToJpeg(b *testing.B) {\n\toptions := Options{Type: JPEG}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkConvertToPng(b *testing.B) {\n\toptions := Options{Type: PNG}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkConvertToWebp(b *testing.B) {\n\toptions := Options{Type: WEBP}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkCropJpeg(b *testing.B) {\n\toptions := Options{\n\t\tWidth:  800,\n\t\tHeight: 600,\n\t}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkCropPng(b *testing.B) {\n\toptions := Options{\n\t\tWidth:  800,\n\t\tHeight: 600,\n\t}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkCropWebp(b *testing.B) {\n\toptions := Options{\n\t\tWidth:  800,\n\t\tHeight: 600,\n\t}\n\trunBenchmarkResize(\"test.webp\", options, b)\n}\n\nfunc BenchmarkExtractJpeg(b *testing.B) {\n\toptions := Options{\n\t\tTop:        100,\n\t\tLeft:       50,\n\t\tAreaWidth:  600,\n\t\tAreaHeight: 480,\n\t}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkExtractPng(b *testing.B) {\n\toptions := Options{\n\t\tTop:        100,\n\t\tLeft:       50,\n\t\tAreaWidth:  600,\n\t\tAreaHeight: 480,\n\t}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkExtractWebp(b *testing.B) {\n\toptions := Options{\n\t\tTop:        100,\n\t\tLeft:       50,\n\t\tAreaWidth:  600,\n\t\tAreaHeight: 480,\n\t}\n\trunBenchmarkResize(\"test.webp\", options, b)\n}\n\nfunc BenchmarkZoomJpeg(b *testing.B) {\n\toptions := Options{Zoom: 1}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkZoomPng(b *testing.B) {\n\toptions := Options{Zoom: 1}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkZoomWebp(b *testing.B) {\n\toptions := Options{Zoom: 1}\n\trunBenchmarkResize(\"test.webp\", options, b)\n}\n\nfunc BenchmarkWatermarkJpeg(b *testing.B) {\n\toptions := Options{\n\t\tWatermark: Watermark{\n\t\t\tText:       \"Chuck Norris (c) 2315\",\n\t\t\tOpacity:    0.25,\n\t\t\tWidth:      200,\n\t\t\tDPI:        100,\n\t\t\tMargin:     150,\n\t\t\tFont:       \"sans bold 12\",\n\t\t\tBackground: Color{255, 255, 255},\n\t\t},\n\t}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkWatermarkPng(b *testing.B) {\n\toptions := Options{\n\t\tWatermark: Watermark{\n\t\t\tText:       \"Chuck Norris (c) 2315\",\n\t\t\tOpacity:    0.25,\n\t\t\tWidth:      200,\n\t\t\tDPI:        100,\n\t\t\tMargin:     150,\n\t\t\tFont:       \"sans bold 12\",\n\t\t\tBackground: Color{255, 255, 255},\n\t\t},\n\t}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkWatermarkWebp(b *testing.B) {\n\toptions := Options{\n\t\tWatermark: Watermark{\n\t\t\tText:       \"Chuck Norris (c) 2315\",\n\t\t\tOpacity:    0.25,\n\t\t\tWidth:      200,\n\t\t\tDPI:        100,\n\t\t\tMargin:     150,\n\t\t\tFont:       \"sans bold 12\",\n\t\t\tBackground: Color{255, 255, 255},\n\t\t},\n\t}\n\trunBenchmarkResize(\"test.webp\", options, b)\n}\n\nfunc BenchmarkWatermarkImageJpeg(b *testing.B) {\n\twatermark := readFile(\"transparent.png\")\n\toptions := Options{\n\t\tWatermarkImage: WatermarkImage{\n\t\t\tBuf:     watermark,\n\t\t\tOpacity: 0.25,\n\t\t\tLeft:    100,\n\t\t\tTop:     100,\n\t\t},\n\t}\n\trunBenchmarkResize(\"test.jpg\", options, b)\n}\n\nfunc BenchmarkWatermarkImagePng(b *testing.B) {\n\twatermark := readFile(\"transparent.png\")\n\toptions := Options{\n\t\tWatermarkImage: WatermarkImage{\n\t\t\tBuf:     watermark,\n\t\t\tOpacity: 0.25,\n\t\t\tLeft:    100,\n\t\t\tTop:     100,\n\t\t},\n\t}\n\trunBenchmarkResize(\"test.png\", options, b)\n}\n\nfunc BenchmarkWatermarkImageWebp(b *testing.B) {\n\twatermark := readFile(\"transparent.png\")\n\toptions := Options{\n\t\tWatermarkImage: WatermarkImage{\n\t\t\tBuf:     watermark,\n\t\t\tOpacity: 0.25,\n\t\t\tLeft:    100,\n\t\t\tTop:     100,\n\t\t},\n\t}\n\trunBenchmarkResize(\"test.webp\", options, b)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "type.go",
          "type": "blob",
          "size": 4.5986328125,
          "content": "package bimg\n\nimport (\n\t\"regexp\"\n\t\"sync\"\n\t\"unicode/utf8\"\n)\n\n// ImageType represents an image type value.\ntype ImageType int\n\nconst (\n\t// UNKNOWN represents an unknow image type value.\n\tUNKNOWN ImageType = iota\n\t// JPEG represents the JPEG image type.\n\tJPEG\n\t// WEBP represents the WEBP image type.\n\tWEBP\n\t// PNG represents the PNG image type.\n\tPNG\n\t// TIFF represents the TIFF image type.\n\tTIFF\n\t// GIF represents the GIF image type.\n\tGIF\n\t// PDF represents the PDF type.\n\tPDF\n\t// SVG represents the SVG image type.\n\tSVG\n\t// MAGICK represents the libmagick compatible genetic image type.\n\tMAGICK\n\t// HEIF represents the HEIC/HEIF/HVEC image type\n\tHEIF\n\t// AVIF represents the AVIF image type.\n\tAVIF\n\t// JXL represents the JPEG XL image type.\n\tJXL\n)\n\nvar (\n\thtmlCommentRegex = regexp.MustCompile(\"(?i)<!--([\\\\s\\\\S]*?)-->\")\n\tsvgRegex         = regexp.MustCompile(`(?i)^\\s*(?:<\\?xml[^>]*>\\s*)?(?:<!doctype svg[^>]*>\\s*)?<svg[^>]*>[^*]*<\\/svg>\\s*$`)\n)\n\n// ImageTypes stores as pairs of image types supported and its alias names.\nvar ImageTypes = map[ImageType]string{\n\tJPEG:   \"jpeg\",\n\tPNG:    \"png\",\n\tWEBP:   \"webp\",\n\tTIFF:   \"tiff\",\n\tGIF:    \"gif\",\n\tPDF:    \"pdf\",\n\tSVG:    \"svg\",\n\tMAGICK: \"magick\",\n\tHEIF:   \"heif\",\n\tAVIF:   \"avif\",\n\tJXL:    \"jxl\",\n}\n\n// imageMutex is used to provide thread-safe synchronization\n// for SupportedImageTypes map.\nvar imageMutex = &sync.RWMutex{}\n\n// SupportedImageType represents whether a type can be loaded and/or saved by\n// the current libvips compilation.\ntype SupportedImageType struct {\n\tLoad bool\n\tSave bool\n}\n\n// SupportedImageTypes stores the optional image type supported\n// by the current libvips compilation.\n// Note: lazy evaluation as demand is required due\n// to bootstrap runtime limitation with C/libvips world.\nvar SupportedImageTypes = map[ImageType]SupportedImageType{}\n\n// discoverSupportedImageTypes is used to fill SupportedImageTypes map.\nfunc discoverSupportedImageTypes() {\n\timageMutex.Lock()\n\tfor imageType := range ImageTypes {\n\t\tSupportedImageTypes[imageType] = SupportedImageType{\n\t\t\tLoad: VipsIsTypeSupported(imageType),\n\t\t\tSave: VipsIsTypeSupportedSave(imageType),\n\t\t}\n\t}\n\timageMutex.Unlock()\n}\n\n// isBinary checks if the given buffer is a binary file.\nfunc isBinary(buf []byte) bool {\n\tif len(buf) < 24 {\n\t\treturn false\n\t}\n\tfor i := 0; i < 24; i++ {\n\t\tcharCode, _ := utf8.DecodeRuneInString(string(buf[i]))\n\t\tif charCode == 65533 || charCode <= 8 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsSVGImage returns true if the given buffer is a valid SVG image.\nfunc IsSVGImage(buf []byte) bool {\n\treturn !isBinary(buf) && svgRegex.Match(htmlCommentRegex.ReplaceAll(buf, []byte{}))\n}\n\n// DetermineImageType determines the image type format (jpeg, png, webp or tiff)\nfunc DetermineImageType(buf []byte) ImageType {\n\treturn vipsImageType(buf)\n}\n\n// DetermineImageTypeName determines the image type format by name (jpeg, png, webp or tiff)\nfunc DetermineImageTypeName(buf []byte) string {\n\treturn ImageTypeName(vipsImageType(buf))\n}\n\n// IsImageTypeSupportedByVips returns true if the given image type\n// is supported by current libvips compilation.\nfunc IsImageTypeSupportedByVips(t ImageType) SupportedImageType {\n\timageMutex.RLock()\n\n\t// Discover supported image types and cache the result\n\titShouldDiscover := len(SupportedImageTypes) == 0\n\tif itShouldDiscover {\n\t\timageMutex.RUnlock()\n\t\tdiscoverSupportedImageTypes()\n\t}\n\n\t// Check if image type is actually supported\n\tsupported, ok := SupportedImageTypes[t]\n\tif !itShouldDiscover {\n\t\timageMutex.RUnlock()\n\t}\n\n\tif ok {\n\t\treturn supported\n\t}\n\treturn SupportedImageType{Load: false, Save: false}\n}\n\n// IsTypeSupported checks if a given image type is supported\nfunc IsTypeSupported(t ImageType) bool {\n\t_, ok := ImageTypes[t]\n\treturn ok && IsImageTypeSupportedByVips(t).Load\n}\n\n// IsTypeNameSupported checks if a given image type name is supported\nfunc IsTypeNameSupported(t string) bool {\n\tfor imageType, name := range ImageTypes {\n\t\tif name == t {\n\t\t\treturn IsImageTypeSupportedByVips(imageType).Load\n\t\t}\n\t}\n\treturn false\n}\n\n// IsTypeSupportedSave checks if a given image type is support for saving\nfunc IsTypeSupportedSave(t ImageType) bool {\n\t_, ok := ImageTypes[t]\n\treturn ok && IsImageTypeSupportedByVips(t).Save\n}\n\n// IsTypeNameSupportedSave checks if a given image type name is supported for\n// saving\nfunc IsTypeNameSupportedSave(t string) bool {\n\tfor imageType, name := range ImageTypes {\n\t\tif name == t {\n\t\t\treturn IsImageTypeSupportedByVips(imageType).Save\n\t\t}\n\t}\n\treturn false\n}\n\n// ImageTypeName is used to get the human friendly name of an image format.\nfunc ImageTypeName(t ImageType) string {\n\timageType := ImageTypes[t]\n\tif imageType == \"\" {\n\t\treturn \"unknown\"\n\t}\n\treturn imageType\n}\n"
        },
        {
          "name": "type_test.go",
          "type": "blob",
          "size": 4.0888671875,
          "content": "package bimg\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestDeterminateImageType(t *testing.T) {\n\tfiles := []struct {\n\t\tname     string\n\t\texpected ImageType\n\t}{\n\t\t{\"test.jpg\", JPEG},\n\t\t{\"test.png\", PNG},\n\t\t{\"test.webp\", WEBP},\n\t\t{\"test.gif\", GIF},\n\t\t{\"test.pdf\", PDF},\n\t\t{\"test.svg\", SVG},\n\t\t// {\"test.jp2\", MAGICK},\n\t\t{\"test.heic\", HEIF},\n\t\t{\"test2.heic\", HEIF},\n\t\t{\"test3.heic\", HEIF},\n\t\t{\"test.avif\", AVIF},\n\t\t{\"test.jxl\", JXL},\n\t}\n\n\tfor _, file := range files {\n\t\timg, _ := os.Open(path.Join(\"testdata\", file.name))\n\t\tbuf, _ := ioutil.ReadAll(img)\n\t\tdefer img.Close()\n\n\t\tif VipsIsTypeSupported(file.expected) {\n\t\t\tvalue := DetermineImageType(buf)\n\t\t\tif value != file.expected {\n\t\t\t\tt.Fatalf(\"Image type is not valid: %s != %s, got: %s\", file.name, ImageTypes[file.expected], ImageTypes[value])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDeterminateImageTypeName(t *testing.T) {\n\tfiles := []struct {\n\t\tname     string\n\t\texpected string\n\t}{\n\t\t{\"test.jpg\", \"jpeg\"},\n\t\t{\"test.png\", \"png\"},\n\t\t{\"test.webp\", \"webp\"},\n\t\t{\"test.gif\", \"gif\"},\n\t\t{\"test.pdf\", \"pdf\"},\n\t\t{\"test.svg\", \"svg\"},\n\t\t// {\"test.jp2\", \"magick\"},\n\t\t{\"test.heic\", \"heif\"},\n\t\t{\"test.avif\", \"avif\"},\n\t\t{\"test.jxl\", \"jxl\"},\n\t}\n\n\tfor _, file := range files {\n\t\tif file.expected == \"heif\" && VipsMajorVersion <= 8 && VipsMinorVersion < 8 {\n\t\t\tcontinue\n\t\t}\n\t\tif file.expected == \"avif\" && VipsMajorVersion <= 8 && VipsMinorVersion < 9 {\n\t\t\tcontinue\n\t\t}\n\t\tif file.expected == \"jxl\" && VipsMajorVersion <= 8 && VipsMinorVersion < 11 {\n\t\t\tcontinue\n\t\t}\n\n\t\timg, _ := os.Open(path.Join(\"testdata\", file.name))\n\t\tbuf, _ := ioutil.ReadAll(img)\n\t\tdefer img.Close()\n\n\t\tvalue := DetermineImageTypeName(buf)\n\t\tif value != file.expected {\n\t\t\tt.Fatalf(\"Image type is not valid: %s != %s, got: %s\", file.name, file.expected, value)\n\t\t}\n\t}\n}\n\nfunc TestIsTypeSupported(t *testing.T) {\n\ttypes := []struct {\n\t\tname ImageType\n\t}{\n\t\t{JPEG}, {PNG}, {WEBP}, {GIF}, {PDF}, {HEIF}, {AVIF}, {JXL},\n\t}\n\n\tfor _, n := range types {\n\t\tif n.name == HEIF && VipsMajorVersion <= 8 && VipsMinorVersion < 8 {\n\t\t\tcontinue\n\t\t}\n\t\tif n.name == AVIF && VipsMajorVersion <= 8 && VipsMinorVersion < 9 {\n\t\t\tcontinue\n\t\t}\n\t\tif n.name == JXL && VipsMajorVersion <= 8 && VipsMinorVersion < 11 {\n\t\t\tcontinue\n\t\t}\n\t\tif IsTypeSupported(n.name) == false {\n\t\t\tt.Fatalf(\"Image type %s is not valid\", ImageTypes[n.name])\n\t\t}\n\t}\n}\n\nfunc TestIsTypeNameSupported(t *testing.T) {\n\ttypes := []struct {\n\t\tname     string\n\t\texpected bool\n\t}{\n\t\t{\"jpeg\", true},\n\t\t{\"png\", true},\n\t\t{\"webp\", true},\n\t\t{\"gif\", true},\n\t\t{\"pdf\", true},\n\t\t{\"heif\", true},\n\t\t{\"avif\", true},\n\t\t{\"jxl\", true},\n\t}\n\n\tfor _, n := range types {\n\t\tif n.name == \"heif\" && VipsMajorVersion <= 8 && VipsMinorVersion < 8 {\n\t\t\tcontinue\n\t\t}\n\t\tif n.name == \"avif\" && VipsMajorVersion <= 8 && VipsMinorVersion < 9 {\n\t\t\tcontinue\n\t\t}\n\t\tif n.name == \"jxl\" && VipsMajorVersion <= 8 && VipsMinorVersion < 11 {\n\t\t\tcontinue\n\t\t}\n\t\tif IsTypeNameSupported(n.name) != n.expected {\n\t\t\tt.Fatalf(\"Image type %s is not valid\", n.name)\n\t\t}\n\t}\n}\n\nfunc TestIsTypeSupportedSave(t *testing.T) {\n\ttypes := []struct {\n\t\tname ImageType\n\t}{\n\t\t{JPEG}, {PNG}, {WEBP},\n\t}\n\tif VipsVersion >= \"8.5.0\" {\n\t\ttypes = append(types, struct{ name ImageType }{TIFF})\n\t}\n\tif VipsVersion >= \"8.8.0\" {\n\t\ttypes = append(types, struct{ name ImageType }{HEIF})\n\t}\n\tif VipsVersion >= \"8.9.0\" {\n\t\ttypes = append(types, struct{ name ImageType }{AVIF})\n\t}\n\tif VipsVersion >= \"8.11.0\" {\n\t\ttypes = append(types, struct{ name ImageType }{name: JXL})\n\t}\n\tif VipsVersion >= \"8.12.0\" {\n\t\ttypes = append(types, struct{ name ImageType }{GIF})\n\t}\n\n\tfor _, n := range types {\n\t\tif IsTypeSupportedSave(n.name) == false {\n\t\t\tt.Fatalf(\"Image type %s is not valid\", ImageTypes[n.name])\n\t\t}\n\t}\n}\n\nfunc TestIsTypeNameSupportedSave(t *testing.T) {\n\ttypes := []struct {\n\t\tname     string\n\t\texpected bool\n\t}{\n\t\t{\"jpeg\", true},\n\t\t{\"png\", true},\n\t\t{\"webp\", true},\n\t\t{\"pdf\", false},\n\t\t{\"tiff\", VipsVersion >= \"8.5.0\"},\n\t\t{\"heif\", VipsVersion >= \"8.8.0\"},\n\t\t{\"avif\", VipsVersion >= \"8.9.0\"},\n\t\t{\"jxl\", VipsVersion >= \"8.11.0\"},\n\t\t{\"gif\", VipsVersion >= \"8.12.0\"},\n\t}\n\n\tfor _, n := range types {\n\t\tif IsTypeNameSupportedSave(n.name) != n.expected {\n\t\t\tt.Fatalf(\"Image type %s is not valid\", n.name)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.095703125,
          "content": "package bimg\n\n// Version represents the current package semantic version.\nconst Version = \"1.1.9\"\n"
        },
        {
          "name": "vips.go",
          "type": "blob",
          "size": 23.1826171875,
          "content": "package bimg\n\n/*\n#cgo pkg-config: vips\n#include \"vips.h\"\n*/\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\n// VipsVersion exposes the current libvips semantic version\nconst VipsVersion = string(C.VIPS_VERSION)\n\n// VipsMajorVersion exposes the current libvips major version number\nconst VipsMajorVersion = int(C.VIPS_MAJOR_VERSION)\n\n// VipsMinorVersion exposes the current libvips minor version number\nconst VipsMinorVersion = int(C.VIPS_MINOR_VERSION)\n\nconst (\n\tmaxCacheMem  = 100 * 1024 * 1024\n\tmaxCacheSize = 500\n)\n\nvar (\n\tm           sync.Mutex\n\tinitialized bool\n)\n\n// VipsMemoryInfo represents the memory stats provided by libvips.\ntype VipsMemoryInfo struct {\n\tMemory          int64\n\tMemoryHighwater int64\n\tAllocations     int64\n}\n\n// vipsSaveOptions represents the internal option used to talk with libvips.\ntype vipsSaveOptions struct {\n\tSpeed          int\n\tQuality        int\n\tCompression    int\n\tType           ImageType\n\tInterlace      bool\n\tNoProfile      bool\n\tStripMetadata  bool\n\tLossless       bool\n\tInputICC       string // Absolute path to the input ICC profile\n\tOutputICC      string // Absolute path to the output ICC profile\n\tInterpretation Interpretation\n\tPalette        bool\n}\n\ntype vipsWatermarkOptions struct {\n\tWidth       C.int\n\tDPI         C.int\n\tMargin      C.int\n\tNoReplicate C.int\n\tOpacity     C.float\n\tBackground  [3]C.double\n}\n\ntype vipsWatermarkImageOptions struct {\n\tLeft    C.int\n\tTop     C.int\n\tOpacity C.float\n}\n\ntype vipsWatermarkTextOptions struct {\n\tText *C.char\n\tFont *C.char\n}\n\nfunc init() {\n\tInitialize()\n}\n\n// Initialize is used to explicitly start libvips in thread-safe way.\n// Only call this function if you have previously turned off libvips.\nfunc Initialize() {\n\tif C.VIPS_MAJOR_VERSION <= 7 && C.VIPS_MINOR_VERSION < 40 {\n\t\tpanic(\"unsupported libvips version!\")\n\t}\n\n\tm.Lock()\n\truntime.LockOSThread()\n\tdefer m.Unlock()\n\tdefer runtime.UnlockOSThread()\n\n\terr := C.vips_init(C.CString(\"bimg\"))\n\tif err != 0 {\n\t\tpanic(\"unable to start vips!\")\n\t}\n\n\t// Set libvips cache params\n\tC.vips_cache_set_max_mem(maxCacheMem)\n\tC.vips_cache_set_max(maxCacheSize)\n\n\t// Define a custom thread concurrency limit in libvips (this may generate thread-unsafe issues)\n\t// See: https://github.com/jcupitt/libvips/issues/261#issuecomment-92850414\n\tif os.Getenv(\"VIPS_CONCURRENCY\") == \"\" {\n\t\tC.vips_concurrency_set(1)\n\t}\n\n\t// Enable libvips cache tracing\n\tif os.Getenv(\"VIPS_TRACE\") != \"\" {\n\t\tC.vips_enable_cache_set_trace()\n\t}\n\n\tinitialized = true\n}\n\n// Shutdown is used to shutdown libvips in a thread-safe way.\n// You can call this to drop caches as well.\n// If libvips was already initialized, the function is no-op\nfunc Shutdown() {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tif initialized {\n\t\tC.vips_shutdown()\n\t\tinitialized = false\n\t}\n}\n\n// VipsCacheSetMaxMem Sets the maximum amount of tracked memory allowed before the vips operation cache\n// begins to drop entries.\nfunc VipsCacheSetMaxMem(maxCacheMem int) {\n\tC.vips_cache_set_max_mem(C.size_t(maxCacheMem))\n}\n\n// VipsCacheSetMax sets the maximum number of operations to keep in the vips operation cache.\nfunc VipsCacheSetMax(maxCacheSize int) {\n\tC.vips_cache_set_max(C.int(maxCacheSize))\n}\n\n// VipsCacheDropAll drops the vips operation cache, freeing the allocated memory.\nfunc VipsCacheDropAll() {\n\tC.vips_cache_drop_all()\n}\n\n// VipsVectorSetEnabled enables or disables SIMD vector instructions. This can give speed-up,\n// but can also be unstable on some systems and versions.\nfunc VipsVectorSetEnabled(enable bool) {\n\tflag := 0\n\tif enable {\n\t\tflag = 1\n\t}\n\n\tC.vips_vector_set_enabled(C.int(flag))\n}\n\n// VipsDebugInfo outputs to stdout libvips collected data. Useful for debugging.\nfunc VipsDebugInfo() {\n\tC.vips_object_print_all()\n}\n\n// VipsMemory gets memory info stats from libvips (cache size, memory allocs...)\nfunc VipsMemory() VipsMemoryInfo {\n\treturn VipsMemoryInfo{\n\t\tMemory:          int64(C.vips_tracked_get_mem()),\n\t\tMemoryHighwater: int64(C.vips_tracked_get_mem_highwater()),\n\t\tAllocations:     int64(C.vips_tracked_get_allocs()),\n\t}\n}\n\n// VipsIsTypeSupported returns true if the given image type\n// is supported by the current libvips compilation.\nfunc VipsIsTypeSupported(t ImageType) bool {\n\tif t == JPEG {\n\t\treturn int(C.vips_type_find_bridge(C.JPEG)) != 0\n\t}\n\tif t == WEBP {\n\t\treturn int(C.vips_type_find_bridge(C.WEBP)) != 0\n\t}\n\tif t == PNG {\n\t\treturn int(C.vips_type_find_bridge(C.PNG)) != 0\n\t}\n\tif t == GIF {\n\t\treturn int(C.vips_type_find_bridge(C.GIF)) != 0\n\t}\n\tif t == PDF {\n\t\treturn int(C.vips_type_find_bridge(C.PDF)) != 0\n\t}\n\tif t == SVG {\n\t\treturn int(C.vips_type_find_bridge(C.SVG)) != 0\n\t}\n\tif t == TIFF {\n\t\treturn int(C.vips_type_find_bridge(C.TIFF)) != 0\n\t}\n\tif t == MAGICK {\n\t\treturn int(C.vips_type_find_bridge(C.MAGICK)) != 0\n\t}\n\tif t == HEIF {\n\t\treturn int(C.vips_type_find_bridge(C.HEIF)) != 0\n\t}\n\tif t == AVIF {\n\t\treturn int(C.vips_type_find_bridge(C.HEIF)) != 0\n\t}\n\tif t == JXL {\n\t\treturn int(C.vips_type_find_bridge(C.JXL)) != 0\n\t}\n\treturn false\n}\n\n// VipsIsTypeSupportedSave returns true if the given image type\n// is supported by the current libvips compilation for the\n// save operation.\nfunc VipsIsTypeSupportedSave(t ImageType) bool {\n\tif t == JPEG {\n\t\treturn int(C.vips_type_find_save_bridge(C.JPEG)) != 0\n\t}\n\tif t == WEBP {\n\t\treturn int(C.vips_type_find_save_bridge(C.WEBP)) != 0\n\t}\n\tif t == PNG {\n\t\treturn int(C.vips_type_find_save_bridge(C.PNG)) != 0\n\t}\n\tif t == TIFF {\n\t\treturn int(C.vips_type_find_save_bridge(C.TIFF)) != 0\n\t}\n\tif t == HEIF {\n\t\treturn int(C.vips_type_find_save_bridge(C.HEIF)) != 0\n\t}\n\tif t == AVIF {\n\t\treturn int(C.vips_type_find_save_bridge(C.HEIF)) != 0\n\t}\n\tif t == GIF {\n\t\treturn int(C.vips_type_find_save_bridge(C.GIF)) != 0\n\t}\n\tif t == JXL {\n\t\treturn int(C.vips_type_find_save_bridge(C.JXL)) != 0\n\t}\n\treturn false\n}\n\nfunc vipsExifStringTag(image *C.VipsImage, tag string) string {\n\treturn vipsExifShort(C.GoString(C.vips_exif_tag(image, C.CString(tag))))\n}\n\nfunc vipsExifIntTag(image *C.VipsImage, tag string) int {\n\treturn int(C.vips_exif_tag_to_int(image, C.CString(tag)))\n}\n\nfunc vipsExifOrientation(image *C.VipsImage) int {\n\treturn int(C.vips_exif_orientation(image))\n}\n\nfunc vipsExifShort(s string) string {\n\ti := strings.Index(s, \" (\")\n\tif i > 0 {\n\t\treturn s[:i]\n\t}\n\treturn s\n}\n\nfunc vipsHasAlpha(image *C.VipsImage) bool {\n\treturn int(C.has_alpha_channel(image)) > 0\n}\n\nfunc vipsHasProfile(image *C.VipsImage) bool {\n\treturn int(C.has_profile_embed(image)) > 0\n}\n\nfunc vipsWindowSize(name string) float64 {\n\tcname := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cname))\n\treturn float64(C.interpolator_window_size(cname))\n}\n\nfunc vipsSpace(image *C.VipsImage) string {\n\treturn C.GoString(C.vips_enum_nick_bridge(image))\n}\n\nfunc vipsRotate(image *C.VipsImage, angle Angle) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_rotate_bridge(image, &out, C.int(angle))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsAutoRotate(image *C.VipsImage) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_autorot_bridge(image, &out)\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsTransformICC(image *C.VipsImage, inputICC string, outputICC string) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\toutputIccPath := C.CString(outputICC)\n\tdefer C.free(unsafe.Pointer(outputIccPath))\n\tinputIccPath := C.CString(inputICC)\n\tdefer C.free(unsafe.Pointer(inputIccPath))\n\terr := C.vips_icc_transform_with_default_bridge(image, &out, outputIccPath, inputIccPath)\n\t//err := C.vips_icc_transform_bridge2(image, &outImage, outputIccPath, inputIccPath)\n\tif int(err) != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsFlip(image *C.VipsImage, direction Direction) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_flip_bridge(image, &out, C.int(direction))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsZoom(image *C.VipsImage, zoom int) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_zoom_bridge(image, &out, C.int(zoom), C.int(zoom))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsWatermark(image *C.VipsImage, w Watermark) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\n\t// Defaults\n\tnoReplicate := 0\n\tif w.NoReplicate {\n\t\tnoReplicate = 1\n\t}\n\n\ttext := C.CString(w.Text)\n\tfont := C.CString(w.Font)\n\tbackground := [3]C.double{C.double(w.Background.R), C.double(w.Background.G), C.double(w.Background.B)}\n\n\ttextOpts := vipsWatermarkTextOptions{text, font}\n\topts := vipsWatermarkOptions{C.int(w.Width), C.int(w.DPI), C.int(w.Margin), C.int(noReplicate), C.float(w.Opacity), background}\n\n\tdefer C.free(unsafe.Pointer(text))\n\tdefer C.free(unsafe.Pointer(font))\n\n\terr := C.vips_watermark(image, &out, (*C.WatermarkTextOptions)(unsafe.Pointer(&textOpts)), (*C.WatermarkOptions)(unsafe.Pointer(&opts)))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsRead(buf []byte) (*C.VipsImage, ImageType, error) {\n\tvar image *C.VipsImage\n\timageType := vipsImageType(buf)\n\n\tif imageType == UNKNOWN {\n\t\treturn nil, UNKNOWN, errors.New(\"Unsupported image format\")\n\t}\n\n\tlength := C.size_t(len(buf))\n\timageBuf := unsafe.Pointer(&buf[0])\n\n\terr := C.vips_init_image(imageBuf, length, C.int(imageType), &image)\n\tif err != 0 {\n\t\treturn nil, UNKNOWN, catchVipsError()\n\t}\n\n\treturn image, imageType, nil\n}\n\nfunc vipsColourspaceIsSupportedBuffer(buf []byte) (bool, error) {\n\timage, _, err := vipsRead(buf)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tC.g_object_unref(C.gpointer(image))\n\treturn vipsColourspaceIsSupported(image), nil\n}\n\nfunc vipsColourspaceIsSupported(image *C.VipsImage) bool {\n\treturn int(C.vips_colourspace_issupported_bridge(image)) == 1\n}\n\nfunc vipsInterpretationBuffer(buf []byte) (Interpretation, error) {\n\timage, _, err := vipsRead(buf)\n\tif err != nil {\n\t\treturn InterpretationError, err\n\t}\n\tinterp := vipsInterpretation(image)\n\tC.g_object_unref(C.gpointer(image))\n\treturn interp, nil\n}\n\nfunc vipsInterpretation(image *C.VipsImage) Interpretation {\n\treturn Interpretation(C.vips_image_guess_interpretation_bridge(image))\n}\n\nfunc vipsFlattenBackground(image *C.VipsImage, background Color) (*C.VipsImage, error) {\n\tvar outImage *C.VipsImage\n\n\tbackgroundC := [3]C.double{\n\t\tC.double(background.R),\n\t\tC.double(background.G),\n\t\tC.double(background.B),\n\t}\n\n\tif vipsHasAlpha(image) {\n\t\terr := C.vips_flatten_background_brigde(image, &outImage,\n\t\t\tbackgroundC[0], backgroundC[1], backgroundC[2])\n\t\tif int(err) != 0 {\n\t\t\treturn nil, catchVipsError()\n\t\t}\n\t\tC.g_object_unref(C.gpointer(image))\n\t\timage = outImage\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsPreSave(image *C.VipsImage, o *vipsSaveOptions) (*C.VipsImage, error) {\n\tvar outImage *C.VipsImage\n\t// Remove ICC profile metadata\n\tif o.NoProfile {\n\t\tC.remove_profile(image)\n\t}\n\n\t// Use a default interpretation and cast it to C type\n\tif o.Interpretation == 0 {\n\t\to.Interpretation = InterpretationSRGB\n\t}\n\tinterpretation := C.VipsInterpretation(o.Interpretation)\n\n\t// Apply the proper colour space\n\tif vipsColourspaceIsSupported(image) {\n\t\terr := C.vips_colourspace_bridge(image, &outImage, interpretation)\n\t\tif int(err) != 0 {\n\t\t\treturn nil, catchVipsError()\n\t\t}\n\t\timage = outImage\n\t}\n\n\tif o.OutputICC != \"\" && o.InputICC != \"\" {\n\t\toutputIccPath := C.CString(o.OutputICC)\n\t\tdefer C.free(unsafe.Pointer(outputIccPath))\n\n\t\tinputIccPath := C.CString(o.InputICC)\n\t\tdefer C.free(unsafe.Pointer(inputIccPath))\n\n\t\terr := C.vips_icc_transform_with_default_bridge(image, &outImage, outputIccPath, inputIccPath)\n\t\tif int(err) != 0 {\n\t\t\treturn nil, catchVipsError()\n\t\t}\n\t\tC.g_object_unref(C.gpointer(image))\n\t\treturn outImage, nil\n\t}\n\n\tif o.OutputICC != \"\" && vipsHasProfile(image) {\n\t\toutputIccPath := C.CString(o.OutputICC)\n\t\tdefer C.free(unsafe.Pointer(outputIccPath))\n\n\t\terr := C.vips_icc_transform_bridge(image, &outImage, outputIccPath)\n\t\tif int(err) != 0 {\n\t\t\treturn nil, catchVipsError()\n\t\t}\n\t\tC.g_object_unref(C.gpointer(image))\n\t\timage = outImage\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsSave(image *C.VipsImage, o vipsSaveOptions) ([]byte, error) {\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\ttmpImage, err := vipsPreSave(image, &o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// When an image has an unsupported color space, vipsPreSave\n\t// returns the pointer of the image passed to it unmodified.\n\t// When this occurs, we must take care to not dereference the\n\t// original image a second time; we may otherwise erroneously\n\t// free the object twice.\n\tif tmpImage != image {\n\t\tdefer C.g_object_unref(C.gpointer(tmpImage))\n\t}\n\n\tlength := C.size_t(0)\n\tsaveErr := C.int(0)\n\tinterlace := C.int(boolToInt(o.Interlace))\n\tquality := C.int(o.Quality)\n\tstrip := C.int(boolToInt(o.StripMetadata))\n\tlossless := C.int(boolToInt(o.Lossless))\n\tpalette := C.int(boolToInt(o.Palette))\n\tspeed := C.int(o.Speed)\n\n\tif o.Type != 0 && !IsTypeSupportedSave(o.Type) {\n\t\treturn nil, fmt.Errorf(\"VIPS cannot save to %#v\", ImageTypes[o.Type])\n\t}\n\tvar ptr unsafe.Pointer\n\tswitch o.Type {\n\tcase WEBP:\n\t\tsaveErr = C.vips_webpsave_bridge(tmpImage, &ptr, &length, strip, quality, lossless)\n\tcase PNG:\n\t\tsaveErr = C.vips_pngsave_bridge(tmpImage, &ptr, &length, strip, C.int(o.Compression), quality, interlace, palette, speed)\n\tcase TIFF:\n\t\tsaveErr = C.vips_tiffsave_bridge(tmpImage, &ptr, &length)\n\tcase HEIF:\n\t\tsaveErr = C.vips_heifsave_bridge(tmpImage, &ptr, &length, strip, quality, lossless)\n\tcase AVIF:\n\t\tsaveErr = C.vips_avifsave_bridge(tmpImage, &ptr, &length, strip, quality, lossless, speed)\n\tcase GIF:\n\t\tsaveErr = C.vips_gifsave_bridge(tmpImage, &ptr, &length, strip)\n\tcase JXL:\n\t\tsaveErr = C.vips_jxlsave_bridge(tmpImage, &ptr, &length, strip, quality, lossless)\n\tdefault:\n\t\tsaveErr = C.vips_jpegsave_bridge(tmpImage, &ptr, &length, strip, quality, interlace)\n\t}\n\n\tif int(saveErr) != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\tbuf := C.GoBytes(ptr, C.int(length))\n\n\t// Clean up\n\tC.g_free(C.gpointer(ptr))\n\tC.vips_error_clear()\n\n\treturn buf, nil\n}\n\nfunc getImageBuffer(image *C.VipsImage) ([]byte, error) {\n\tvar ptr unsafe.Pointer\n\n\tlength := C.size_t(0)\n\tinterlace := C.int(0)\n\tquality := C.int(100)\n\n\terr := C.int(0)\n\terr = C.vips_jpegsave_bridge(image, &ptr, &length, 1, quality, interlace)\n\tif int(err) != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\tdefer C.g_free(C.gpointer(ptr))\n\tdefer C.vips_error_clear()\n\n\treturn C.GoBytes(ptr, C.int(length)), nil\n}\n\nfunc vipsExtract(image *C.VipsImage, left, top, width, height int) (*C.VipsImage, error) {\n\tvar buf *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\tif width > maxSize || height > maxSize {\n\t\treturn nil, errors.New(\"Maximum image size exceeded\")\n\t}\n\n\ttop, left = max(top), max(left)\n\terr := C.vips_extract_area_bridge(image, &buf, C.int(left), C.int(top), C.int(width), C.int(height))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn buf, nil\n}\n\nfunc vipsSmartCrop(image *C.VipsImage, width, height int) (*C.VipsImage, error) {\n\tvar buf *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\tif width > maxSize || height > maxSize {\n\t\treturn nil, errors.New(\"Maximum image size exceeded\")\n\t}\n\n\terr := C.vips_smartcrop_bridge(image, &buf, C.int(width), C.int(height))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn buf, nil\n}\n\nfunc vipsTrim(image *C.VipsImage, background Color, threshold float64) (int, int, int, int, error) {\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\ttop := C.int(0)\n\tleft := C.int(0)\n\twidth := C.int(0)\n\theight := C.int(0)\n\n\terr := C.vips_find_trim_bridge(image,\n\t\t&top, &left, &width, &height,\n\t\tC.double(background.R), C.double(background.G), C.double(background.B),\n\t\tC.double(threshold))\n\tif err != 0 {\n\t\treturn 0, 0, 0, 0, catchVipsError()\n\t}\n\n\treturn int(top), int(left), int(width), int(height), nil\n}\n\nfunc vipsShrinkJpeg(buf []byte, input *C.VipsImage, shrink int) (*C.VipsImage, error) {\n\tvar image *C.VipsImage\n\tvar ptr = unsafe.Pointer(&buf[0])\n\tdefer C.g_object_unref(C.gpointer(input))\n\n\terr := C.vips_jpegload_buffer_shrink(ptr, C.size_t(len(buf)), &image, C.int(shrink))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsShrinkWebp(buf []byte, input *C.VipsImage, shrink int) (*C.VipsImage, error) {\n\tvar image *C.VipsImage\n\tvar ptr = unsafe.Pointer(&buf[0])\n\tdefer C.g_object_unref(C.gpointer(input))\n\n\terr := C.vips_webpload_buffer_shrink(ptr, C.size_t(len(buf)), &image, C.int(shrink))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsShrink(input *C.VipsImage, shrink int) (*C.VipsImage, error) {\n\tvar image *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(input))\n\n\terr := C.vips_shrink_bridge(input, &image, C.double(float64(shrink)), C.double(float64(shrink)))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsReduce(input *C.VipsImage, xshrink float64, yshrink float64, kernel Kernel) (*C.VipsImage, error) {\n\tvar image *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(input))\n\n\terr := C.vips_reduce_bridge(input, &image, C.double(xshrink), C.double(yshrink), kernel)\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsEmbed(input *C.VipsImage, left, top, width, height int, extend Extend, background Color) (*C.VipsImage, error) {\n\tvar image *C.VipsImage\n\n\t// Max extend value, see: https://libvips.github.io/libvips/API/current/libvips-conversion.html#VipsExtend\n\tif extend > 5 {\n\t\textend = ExtendBackground\n\t}\n\n\tdefer C.g_object_unref(C.gpointer(input))\n\terr := C.vips_embed_bridge(input, &image, C.int(left), C.int(top), C.int(width),\n\t\tC.int(height), C.int(extend), C.double(background.R), C.double(background.G), C.double(background.B))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsAffine(input *C.VipsImage, residualx, residualy float64, i Interpolator, extend Extend) (*C.VipsImage, error) {\n\tif extend > 5 {\n\t\textend = ExtendBackground\n\t}\n\n\tvar image *C.VipsImage\n\tcstring := C.CString(i.String())\n\tinterpolator := C.vips_interpolate_new(cstring)\n\n\tdefer C.free(unsafe.Pointer(cstring))\n\tdefer C.g_object_unref(C.gpointer(input))\n\tdefer C.g_object_unref(C.gpointer(interpolator))\n\n\terr := C.vips_affine_interpolator(input, &image, C.double(residualx), 0, 0, C.double(residualy), interpolator, C.int(extend))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn image, nil\n}\n\nfunc vipsImageType(buf []byte) ImageType {\n\tif len(buf) < 12 {\n\t\treturn UNKNOWN\n\t}\n\tif buf[0] == 0xFF && buf[1] == 0xD8 && buf[2] == 0xFF {\n\t\treturn JPEG\n\t}\n\tif IsTypeSupported(GIF) && buf[0] == 0x47 && buf[1] == 0x49 && buf[2] == 0x46 {\n\t\treturn GIF\n\t}\n\tif buf[0] == 0x89 && buf[1] == 0x50 && buf[2] == 0x4E && buf[3] == 0x47 {\n\t\treturn PNG\n\t}\n\tif IsTypeSupported(TIFF) &&\n\t\t((buf[0] == 0x49 && buf[1] == 0x49 && buf[2] == 0x2A && buf[3] == 0x0) ||\n\t\t\t(buf[0] == 0x4D && buf[1] == 0x4D && buf[2] == 0x0 && buf[3] == 0x2A)) {\n\t\treturn TIFF\n\t}\n\tif IsTypeSupported(PDF) && buf[0] == 0x25 && buf[1] == 0x50 && buf[2] == 0x44 && buf[3] == 0x46 {\n\t\treturn PDF\n\t}\n\tif IsTypeSupported(WEBP) && buf[8] == 0x57 && buf[9] == 0x45 && buf[10] == 0x42 && buf[11] == 0x50 {\n\t\treturn WEBP\n\t}\n\tif IsTypeSupported(SVG) && IsSVGImage(buf) {\n\t\treturn SVG\n\t}\n\tif IsTypeSupported(MAGICK) && strings.HasSuffix(readImageType(buf), \"MagickBuffer\") {\n\t\treturn MAGICK\n\t}\n\t// NOTE: libheif currently only supports heic sub types; see:\n\t//   https://github.com/strukturag/libheif/issues/83#issuecomment-421427091\n\tif IsTypeSupported(HEIF) && buf[4] == 0x66 && buf[5] == 0x74 && buf[6] == 0x79 && buf[7] == 0x70 &&\n\t\tbuf[8] == 0x68 && buf[9] == 0x65 && buf[10] == 0x69 && buf[11] == 0x63 {\n\t\t// This is a HEIC file, ftypheic\n\t\treturn HEIF\n\t}\n\tif IsTypeSupported(HEIF) && buf[4] == 0x66 && buf[5] == 0x74 && buf[6] == 0x79 && buf[7] == 0x70 &&\n\t\tbuf[8] == 0x6d && buf[9] == 0x69 && buf[10] == 0x66 && buf[11] == 0x31 {\n\t\t// This is a HEIF file, ftypmif1\n\t\treturn HEIF\n\t}\n\tif IsTypeSupported(HEIF) && buf[4] == 0x66 && buf[5] == 0x74 && buf[6] == 0x79 && buf[7] == 0x70 &&\n\t\tbuf[8] == 0x6d && buf[9] == 0x73 && buf[10] == 0x66 && buf[11] == 0x31 {\n\t\t// This is a HEIFS file, ftypmsf1\n\t\treturn HEIF\n\t}\n\tif IsTypeSupported(HEIF) && buf[4] == 0x66 && buf[5] == 0x74 && buf[6] == 0x79 && buf[7] == 0x70 &&\n\t\tbuf[8] == 0x68 && buf[9] == 0x65 && buf[10] == 0x69 && buf[11] == 0x73 {\n\t\t// This is a HEIFS file, ftypheis\n\t\treturn HEIF\n\t}\n\tif IsTypeSupported(HEIF) && buf[4] == 0x66 && buf[5] == 0x74 && buf[6] == 0x79 && buf[7] == 0x70 &&\n\t\tbuf[8] == 0x68 && buf[9] == 0x65 && buf[10] == 0x76 && buf[11] == 0x63 {\n\t\t// This is a HEIFS file, ftyphevc\n\t\treturn HEIF\n\t}\n\tif IsTypeSupported(HEIF) && buf[4] == 0x66 && buf[5] == 0x74 && buf[6] == 0x79 && buf[7] == 0x70 &&\n\t\tbuf[8] == 0x61 && buf[9] == 0x76 && buf[10] == 0x69 && buf[11] == 0x66 {\n\t\treturn AVIF\n\t}\n\tif IsTypeSupported(JXL) && buf[0] == 0xFF && buf[1] == 0x0A {\n\t\t// This is naked jxl file header\n\t\treturn JXL\n\t}\n\tif IsTypeSupported(JXL) && buf[0] == 0x0 && buf[1] == 0x0 && buf[2] == 0x0 && buf[3] == 0x0C &&\n\t\tbuf[4] == 0x4A && buf[5] == 0x58 && buf[6] == 0x4C && buf[7] == 0x20 &&\n\t\tbuf[8] == 0x0D && buf[9] == 0x0A && buf[10] == 0x87 && buf[11] == 0x0A {\n\t\t// This is an ISOBMFF-based container\n\t\treturn JXL\n\t}\n\n\treturn UNKNOWN\n}\n\nfunc readImageType(buf []byte) string {\n\tlength := C.size_t(len(buf))\n\timageBuf := unsafe.Pointer(&buf[0])\n\tload := C.vips_foreign_find_load_buffer(imageBuf, length)\n\treturn C.GoString(load)\n}\n\nfunc catchVipsError() error {\n\ts := C.GoString(C.vips_error_buffer())\n\tC.vips_error_clear()\n\tC.vips_thread_shutdown()\n\treturn errors.New(s)\n}\n\nfunc boolToInt(b bool) int {\n\tif b {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc vipsGaussianBlur(image *C.VipsImage, o GaussianBlur) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_gaussblur_bridge(image, &out, C.double(o.Sigma), C.double(o.MinAmpl))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\treturn out, nil\n}\n\nfunc vipsSharpen(image *C.VipsImage, o Sharpen) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_sharpen_bridge(image, &out, C.int(o.Radius), C.double(o.X1), C.double(o.Y2), C.double(o.Y3), C.double(o.M1), C.double(o.M2))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\treturn out, nil\n}\n\nfunc max(x int) int {\n\treturn int(math.Max(float64(x), 0))\n}\n\nfunc vipsDrawWatermark(image *C.VipsImage, o WatermarkImage) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\n\twatermark, _, e := vipsRead(o.Buf)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\n\topts := vipsWatermarkImageOptions{C.int(o.Left), C.int(o.Top), C.float(o.Opacity)}\n\n\terr := C.vips_watermark_image(image, watermark, &out, (*C.WatermarkImageOptions)(unsafe.Pointer(&opts)))\n\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\n\treturn out, nil\n}\n\nfunc vipsGamma(image *C.VipsImage, Gamma float64) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_gamma_bridge(image, &out, C.double(Gamma))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\treturn out, nil\n}\n\nfunc vipsBrightness(image *C.VipsImage, brightness float64) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_brightness_bridge(image, &out, C.double(brightness))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\treturn out, nil\n}\n\nfunc vipsContrast(image *C.VipsImage, contrast float64) (*C.VipsImage, error) {\n\tvar out *C.VipsImage\n\tdefer C.g_object_unref(C.gpointer(image))\n\n\terr := C.vips_contrast_bridge(image, &out, C.double(contrast))\n\tif err != 0 {\n\t\treturn nil, catchVipsError()\n\t}\n\treturn out, nil\n}\n"
        },
        {
          "name": "vips.h",
          "type": "blob",
          "size": 20.08203125,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <vips/vips.h>\n#include <vips/foreign.h>\n#include <vips/vector.h>\n\n/**\n * Starting libvips 7.41, VIPS_ANGLE_x has been renamed to VIPS_ANGLE_Dx\n * \"to help python\". So we provide the macro to correctly build for versions\n * before 7.41.x.\n * https://github.com/jcupitt/libvips/blob/master/ChangeLog#L128\n */\n\n#if (VIPS_MAJOR_VERSION == 7 && VIPS_MINOR_VERSION < 41)\n#define VIPS_ANGLE_D0 VIPS_ANGLE_0\n#define VIPS_ANGLE_D90 VIPS_ANGLE_90\n#define VIPS_ANGLE_D180 VIPS_ANGLE_180\n#define VIPS_ANGLE_D270 VIPS_ANGLE_270\n#endif\n\n#define EXIF_IFD0_ORIENTATION \"exif-ifd0-Orientation\"\n\n#define INT_TO_GBOOLEAN(bool) (bool > 0 ? TRUE : FALSE)\n\n\nenum types {\n\tUNKNOWN = 0,\n\tJPEG,\n\tWEBP,\n\tPNG,\n\tTIFF,\n\tGIF,\n\tPDF,\n\tSVG,\n\tMAGICK,\n\tHEIF,\n\tAVIF,\n\tJXL\n};\n\ntypedef struct {\n\tconst char *Text;\n\tconst char *Font;\n} WatermarkTextOptions;\n\ntypedef struct {\n\tint    Width;\n\tint    DPI;\n\tint    Margin;\n\tint    NoReplicate;\n\tfloat  Opacity;\n\tdouble Background[3];\n} WatermarkOptions;\n\ntypedef struct {\n\tint    Left;\n\tint    Top;\n\tfloat    Opacity;\n} WatermarkImageOptions;\n\nstatic unsigned long\nhas_profile_embed(VipsImage *image) {\n\treturn vips_image_get_typeof(image, VIPS_META_ICC_NAME);\n}\n\nstatic void\nremove_profile(VipsImage *image) {\n\tvips_image_remove(image, VIPS_META_ICC_NAME);\n}\n\nstatic int\nhas_alpha_channel(VipsImage *image) {\n\treturn (\n\t\t(image->Bands == 2 && image->Type == VIPS_INTERPRETATION_B_W) ||\n\t\t(image->Bands == 4 && image->Type != VIPS_INTERPRETATION_CMYK) ||\n\t\t(image->Bands == 5 && image->Type == VIPS_INTERPRETATION_CMYK)\n\t) ? 1 : 0;\n}\n\n/**\n * This method is here to handle the weird initialization of the vips lib.\n * libvips use a macro VIPS_INIT() that call vips__init() in version < 7.41,\n * or calls vips_init() in version >= 7.41.\n *\n * Anyway, it's not possible to build bimg on Debian Jessie with libvips 7.40.x,\n * as vips_init() is a macro to VIPS_INIT(), which is also a macro, hence, cgo\n * is unable to determine the return type of vips_init(), making the build impossible.\n * In order to correctly build bimg, for version < 7.41, we should undef vips_init and\n * creates a vips_init() method that calls VIPS_INIT().\n */\n\n#if (VIPS_MAJOR_VERSION == 7 && VIPS_MINOR_VERSION < 41)\n#undef vips_init\nint\nvips_init(const char *argv0)\n{\n\treturn VIPS_INIT(argv0);\n}\n#endif\n\nvoid\nvips_enable_cache_set_trace() {\n\tvips_cache_set_trace(TRUE);\n}\n\nint\nvips_affine_interpolator(VipsImage *in, VipsImage **out, double a, double b, double c, double d, VipsInterpolate *interpolator, int extend) {\n\treturn vips_affine(in, out, a, b, c, d, \"interpolate\", interpolator, \"extend\", extend, NULL);\n}\n\nint\nvips_jpegload_buffer_shrink(void *buf, size_t len, VipsImage **out, int shrink) {\n\treturn vips_jpegload_buffer(buf, len, out, \"shrink\", shrink, NULL);\n}\n\nint\nvips_webpload_buffer_shrink(void *buf, size_t len, VipsImage **out, int shrink) {\n\treturn vips_webpload_buffer(buf, len, out, \"shrink\", shrink, NULL);\n}\n\nint\nvips_flip_bridge(VipsImage *in, VipsImage **out, int direction) {\n\treturn vips_flip(in, out, direction, NULL);\n}\n\nint\nvips_shrink_bridge(VipsImage *in, VipsImage **out, double xshrink, double yshrink) {\n\treturn vips_shrink(in, out, xshrink, yshrink, NULL);\n}\n\nint\nvips_reduce_bridge(VipsImage *in, VipsImage **out, double xshrink, double yshrink, int kernel) {\n\treturn vips_reduce(in, out, xshrink, yshrink, \"kernel\", kernel);\n}\n\nint\nvips_type_find_bridge(int t) {\n\tif (t == GIF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"gifload\");\n\t}\n\tif (t == PDF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"pdfload\");\n\t}\n\tif (t == TIFF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"tiffload\");\n\t}\n\tif (t == SVG) {\n\t\treturn vips_type_find(\"VipsOperation\", \"svgload\");\n\t}\n\tif (t == WEBP) {\n\t\treturn vips_type_find(\"VipsOperation\", \"webpload\");\n\t}\n\tif (t == PNG) {\n\t\treturn vips_type_find(\"VipsOperation\", \"pngload\");\n\t}\n\tif (t == JPEG) {\n\t\treturn vips_type_find(\"VipsOperation\", \"jpegload\");\n\t}\n\tif (t == MAGICK) {\n\t\treturn vips_type_find(\"VipsOperation\", \"magickload\");\n\t}\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 8))\n\tif (t == HEIF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"heifload\");\n\t}\n#endif\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 11))\n\tif (t == JXL) {\n\t\treturn vips_type_find(\"VipsOperation\", \"jxlload\");\n\t}\n#endif\n\treturn 0;\n}\n\nint\nvips_type_find_save_bridge(int t) {\n\tif (t == TIFF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"tiffsave_buffer\");\n\t}\n\tif (t == WEBP) {\n\t\treturn vips_type_find(\"VipsOperation\", \"webpsave_buffer\");\n\t}\n\tif (t == PNG) {\n\t\treturn vips_type_find(\"VipsOperation\", \"pngsave_buffer\");\n\t}\n\tif (t == JPEG) {\n\t\treturn vips_type_find(\"VipsOperation\", \"jpegsave_buffer\");\n\t}\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 8))\n\tif (t == HEIF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"heifsave_buffer\");\n\t}\n#endif\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 11))\n    if (t == JXL) {\n\t\treturn vips_type_find(\"VipsOperation\", \"jxlsave_buffer\");\n\t}\n#endif\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 12))\n\tif (t == GIF) {\n\t\treturn vips_type_find(\"VipsOperation\", \"gifsave_buffer\");\n\t}\n#endif\n\treturn 0;\n}\n\nint\nvips_rotate_bridge(VipsImage *in, VipsImage **out, int angle) {\n\tint rotate = VIPS_ANGLE_D0;\n\n\tangle %= 360;\n\n\tif (angle == 45) {\n\t\trotate = VIPS_ANGLE45_D45;\n\t} else if (angle == 90) {\n\t\trotate = VIPS_ANGLE_D90;\n\t} else if (angle == 135) {\n\t\trotate = VIPS_ANGLE45_D135;\n\t} else if (angle == 180) {\n\t\trotate = VIPS_ANGLE_D180;\n\t} else if (angle == 225) {\n\t\trotate = VIPS_ANGLE45_D225;\n\t} else if (angle == 270) {\n\t\trotate = VIPS_ANGLE_D270;\n\t} else if (angle == 315) {\n\t\trotate = VIPS_ANGLE45_D315;\n\t} else {\n\t\tangle = 0;\n\t}\n\n\tif (angle > 0 && angle % 90 != 0) {\n\t\treturn vips_rot45(in, out, \"angle\", rotate, NULL);\n\t} else {\n\t\treturn vips_rot(in, out, rotate, NULL);\n\t}\n}\n\nint\nvips_autorot_bridge(VipsImage *in, VipsImage **out) {\n\treturn vips_autorot(in, out, NULL);\n}\n\nconst char *\nvips_exif_tag(VipsImage *image, const char *tag) {\n\tconst char *exif;\n\tif (\n\t\tvips_image_get_typeof(image, tag) != 0 &&\n\t\t!vips_image_get_string(image, tag, &exif)\n\t) {\n\t\treturn &exif[0];\n\t}\n\treturn \"\";\n}\n\nint\nvips_exif_tag_to_int(VipsImage *image, const char *tag) {\n\tint value = 0;\n\tconst char *exif = vips_exif_tag(image, tag);\n\tif (strcmp(exif, \"\")) {\n\t\tvalue = atoi(&exif[0]);\n\t}\n\treturn value;\n}\n\nint\nvips_exif_orientation(VipsImage *image) {\n\treturn vips_exif_tag_to_int(image, EXIF_IFD0_ORIENTATION);\n}\n\nint\ninterpolator_window_size(char const *name) {\n\tVipsInterpolate *interpolator = vips_interpolate_new(name);\n\tint window_size = vips_interpolate_get_window_size(interpolator);\n\tg_object_unref(interpolator);\n\treturn window_size;\n}\n\nconst char *\nvips_enum_nick_bridge(VipsImage *image) {\n\treturn vips_enum_nick(VIPS_TYPE_INTERPRETATION, image->Type);\n}\n\nint\nvips_zoom_bridge(VipsImage *in, VipsImage **out, int xfac, int yfac) {\n\treturn vips_zoom(in, out, xfac, yfac, NULL);\n}\n\nint\nvips_embed_bridge(VipsImage *in, VipsImage **out, int left, int top, int width, int height, int extend, double r, double g, double b) {\n\tif (extend == VIPS_EXTEND_BACKGROUND) {\n\tif (has_alpha_channel(in) == 1) {\n\t\tdouble background[4] = {r, g, b, 0.0};\n  \tVipsArrayDouble *vipsBackground = vips_array_double_new(background, 4);\n  \treturn vips_embed(in, out, left, top, width, height, \"extend\", extend, \"background\", vipsBackground, NULL);\n\t} else {\n\t\tdouble background[3] = {r, g, b};\n  \tVipsArrayDouble *vipsBackground = vips_array_double_new(background, 3);\n  \treturn vips_embed(in, out, left, top, width, height, \"extend\", extend, \"background\", vipsBackground, NULL);}\n\t}\n\treturn vips_embed(in, out, left, top, width, height, \"extend\", extend, NULL);\n}\n\nint\nvips_extract_area_bridge(VipsImage *in, VipsImage **out, int left, int top, int width, int height) {\n\treturn vips_extract_area(in, out, left, top, width, height, NULL);\n}\n\nint\nvips_colourspace_issupported_bridge(VipsImage *in) {\n\treturn vips_colourspace_issupported(in) ? 1 : 0;\n}\n\nVipsInterpretation\nvips_image_guess_interpretation_bridge(VipsImage *in) {\n\treturn vips_image_guess_interpretation(in);\n}\n\nint\nvips_colourspace_bridge(VipsImage *in, VipsImage **out, VipsInterpretation space) {\n\treturn vips_colourspace(in, out, space, NULL);\n}\n\nint\nvips_icc_transform_bridge (VipsImage *in, VipsImage **out, const char *output_icc_profile) {\n\t// `output_icc_profile` represents the absolute path to the output ICC profile file\n\treturn vips_icc_transform(in, out, output_icc_profile, \"embedded\", TRUE, NULL);\n}\n\n\nint\nvips_icc_transform_with_default_bridge (VipsImage *in, VipsImage **out, const char *output_icc_profile, const char *input_icc_profile) {\n\t// `output_icc_profile` represents the absolute path to the output ICC profile file\n\treturn vips_icc_transform(in, out, output_icc_profile, \"input_profile\", input_icc_profile, \"embedded\", FALSE, NULL);\n}\n\nint\nvips_jpegsave_bridge(VipsImage *in, void **buf, size_t *len, int strip, int quality, int interlace) {\n\treturn vips_jpegsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\t\"Q\", quality,\n\t\t\"optimize_coding\", TRUE,\n\t\t\"interlace\", INT_TO_GBOOLEAN(interlace),\n\t\tNULL\n\t);\n}\n\nint\nvips_pngsave_bridge(VipsImage *in, void **buf, size_t *len, int strip, int compression, int quality, int interlace, int palette, int speed) {\n#if (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 12)\n\tint effort = 10 - speed;\n\treturn vips_pngsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\t\"compression\", compression,\n\t\t\"interlace\", INT_TO_GBOOLEAN(interlace),\n\t\t\"filter\", VIPS_FOREIGN_PNG_FILTER_ALL,\n\t\t\"palette\", INT_TO_GBOOLEAN(palette),\n\t\t\"Q\", quality,\n\t\t\"effort\", effort,\n\t\tNULL\n\t);\n#elif (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 7)\n\treturn vips_pngsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\t\"compression\", compression,\n\t\t\"interlace\", INT_TO_GBOOLEAN(interlace),\n\t\t\"filter\", VIPS_FOREIGN_PNG_FILTER_ALL,\n\t\t\"palette\", INT_TO_GBOOLEAN(palette),\n\t\tNULL\n\t);\n#else\n\treturn vips_pngsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\t\"compression\", compression,\n\t\t\"interlace\", INT_TO_GBOOLEAN(interlace),\n\t\tNULL\n\t);\n#endif\n}\n\nint\nvips_webpsave_bridge(VipsImage *in, void **buf, size_t *len, int strip, int quality, int lossless) {\n\treturn vips_webpsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\t\"Q\", quality,\n\t\t\"lossless\", INT_TO_GBOOLEAN(lossless),\n\t\tNULL\n\t);\n}\n\nint\nvips_tiffsave_bridge(VipsImage *in, void **buf, size_t *len) {\n#if (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 5)\n\treturn vips_tiffsave_buffer(in, buf, len, NULL);\n#else\n\treturn 0;\n#endif\n}\n\nint\nvips_avifsave_bridge(VipsImage *in, void **buf, size_t *len, int strip, int quality, int lossless, int speed) {\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION > 10) || (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 10 && VIPS_MICRO_VERSION >= 2))\n    return vips_heifsave_buffer(in, buf, len,\n    \"strip\", INT_TO_GBOOLEAN(strip),\n    \"Q\", quality,\n    \"lossless\", INT_TO_GBOOLEAN(lossless),\n    \"compression\", VIPS_FOREIGN_HEIF_COMPRESSION_AV1,\n    \"speed\", speed,\n    NULL\n    );\n#elif (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 9))\n    return vips_heifsave_buffer(in, buf, len,\n    \"strip\", INT_TO_GBOOLEAN(strip),\n    \"Q\", quality,\n    \"lossless\", INT_TO_GBOOLEAN(lossless),\n    \"compression\", VIPS_FOREIGN_HEIF_COMPRESSION_AV1,\n    NULL\n    );\n#else\n    return 0;\n#endif\n}\n\nint\nvips_heifsave_bridge(VipsImage *in, void **buf, size_t *len, int strip, int quality, int lossless) {\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 8))\n\treturn vips_heifsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\t\"Q\", quality,\n\t\t\"lossless\", INT_TO_GBOOLEAN(lossless),\n\t\tNULL\n\t);\n#else\n\treturn 0;\n#endif\n}\n\nint vips_jxlsave_bridge(VipsImage *in, void **buf, size_t *len, int strip, int quality, int lossless) {\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 11))\n    return vips_jxlsave_buffer(in, buf, len,\n    \t\"strip\", INT_TO_GBOOLEAN(strip),\n    \t\"Q\", quality,\n        \"lossless\", INT_TO_GBOOLEAN(lossless),\n        NULL\n    );\n#else\n\treturn 0;\n#endif\n}\n\nint\nvips_gifsave_bridge(VipsImage *in, void **buf, size_t *len, int strip) {\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 12))\n\treturn vips_gifsave_buffer(in, buf, len,\n\t\t\"strip\", INT_TO_GBOOLEAN(strip),\n\t\tNULL\n\t);\n#else\n\treturn 0;\n#endif\n}\n\nint\nvips_is_16bit (VipsInterpretation interpretation) {\n\treturn interpretation == VIPS_INTERPRETATION_RGB16 || interpretation == VIPS_INTERPRETATION_GREY16;\n}\n\nint\nvips_flatten_background_brigde(VipsImage *in, VipsImage **out, double r, double g, double b) {\n\tif (vips_is_16bit(in->Type)) {\n\t\tr = 65535 * r / 255;\n\t\tg = 65535 * g / 255;\n\t\tb = 65535 * b / 255;\n\t}\n\n\tdouble background[3] = {r, g, b};\n\tVipsArrayDouble *vipsBackground = vips_array_double_new(background, 3);\n\n\treturn vips_flatten(in, out,\n\t\t\"background\", vipsBackground,\n\t\t\"max_alpha\", vips_is_16bit(in->Type) ? 65535.0 : 255.0,\n\t\tNULL\n\t);\n}\n\nint\nvips_init_image (void *buf, size_t len, int imageType, VipsImage **out) {\n\tint code = 1;\n\n\tif (imageType == JPEG) {\n\t\tcode = vips_jpegload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n\t} else if (imageType == PNG) {\n\t\tcode = vips_pngload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n\t} else if (imageType == WEBP) {\n\t\tcode = vips_webpload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n\t} else if (imageType == TIFF) {\n\t\tcode = vips_tiffload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n#if (VIPS_MAJOR_VERSION >= 8)\n#if (VIPS_MINOR_VERSION >= 3)\n\t} else if (imageType == GIF) {\n\t\tcode = vips_gifload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n\t} else if (imageType == PDF) {\n\t\tcode = vips_pdfload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n\t} else if (imageType == SVG) {\n\t\tcode = vips_svgload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n#endif\n\t} else if (imageType == MAGICK) {\n\t\tcode = vips_magickload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n#endif\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 8))\n\t} else if (imageType == HEIF) {\n\t\tcode = vips_heifload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n#endif\n#if (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 9)\n\t} else if (imageType == AVIF) {\n\t\tcode = vips_heifload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n#endif\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION == 8 && VIPS_MINOR_VERSION >= 11))\n\t} else if (imageType == JXL) {\n\t\tcode = vips_jxlload_buffer(buf, len, out, \"access\", VIPS_ACCESS_RANDOM, NULL);\n#endif\n\t}\n\n\treturn code;\n}\n\nint\nvips_watermark_replicate (VipsImage *orig, VipsImage *in, VipsImage **out) {\n\tVipsImage *cache = vips_image_new();\n\n\tif (\n\t\tvips_replicate(in, &cache,\n\t\t\t1 + orig->Xsize / in->Xsize,\n\t\t\t1 + orig->Ysize / in->Ysize, NULL) ||\n\t\tvips_crop(cache, out, 0, 0, orig->Xsize, orig->Ysize, NULL)\n\t) {\n\t\tg_object_unref(cache);\n\t\treturn 1;\n\t}\n\n\tg_object_unref(cache);\n\treturn 0;\n}\n\nint\nvips_watermark(VipsImage *in, VipsImage **out, WatermarkTextOptions *to, WatermarkOptions *o) {\n\tdouble ones[3] = { 1, 1, 1 };\n\n\tVipsImage *base = vips_image_new();\n\tVipsImage **t = (VipsImage **) vips_object_local_array(VIPS_OBJECT(base), 10);\n\tt[0] = in;\n\n\t// Make the mask.\n\tif (\n\t\tvips_text(&t[1], to->Text,\n\t\t\t\"width\", o->Width,\n\t\t\t\"dpi\", o->DPI,\n\t\t\t\"font\", to->Font,\n\t\t\tNULL) ||\n\t\tvips_linear1(t[1], &t[2], o->Opacity, 0.0, NULL) ||\n\t\tvips_cast(t[2], &t[3], VIPS_FORMAT_UCHAR, NULL) ||\n\t\tvips_embed(t[3], &t[4], 100, 100, t[3]->Xsize + o->Margin, t[3]->Ysize + o->Margin, NULL)\n\t\t) {\n\t\tg_object_unref(base);\n\t\treturn 1;\n\t}\n\n\t// Replicate if necessary\n\tif (o->NoReplicate != 1) {\n\t\tVipsImage *cache = vips_image_new();\n\t\tif (vips_watermark_replicate(t[0], t[4], &cache)) {\n\t\t\tg_object_unref(cache);\n\t\t\tg_object_unref(base);\n\t\t\treturn 1;\n\t\t}\n\t\tg_object_unref(t[4]);\n\t\tt[4] = cache;\n\t}\n\n\t// Make the constant image to paint the text with.\n\tif (\n\t\tvips_black(&t[5], 1, 1, NULL) ||\n\t\tvips_linear(t[5], &t[6], ones, o->Background, 3, NULL) ||\n\t\tvips_cast(t[6], &t[7], VIPS_FORMAT_UCHAR, NULL) ||\n\t\tvips_copy(t[7], &t[8], \"interpretation\", t[0]->Type, NULL) ||\n\t\tvips_embed(t[8], &t[9], 0, 0, t[0]->Xsize, t[0]->Ysize, \"extend\", VIPS_EXTEND_COPY, NULL)\n\t\t) {\n\t\tg_object_unref(base);\n\t\treturn 1;\n\t}\n\n\t// Blend the mask and text and write to output.\n\tif (vips_ifthenelse(t[4], t[9], t[0], out, \"blend\", TRUE, NULL)) {\n\t\tg_object_unref(base);\n\t\treturn 1;\n\t}\n\n\tg_object_unref(base);\n\treturn 0;\n}\n\nint\nvips_gaussblur_bridge(VipsImage *in, VipsImage **out, double sigma, double min_ampl) {\n#if (VIPS_MAJOR_VERSION == 7 && VIPS_MINOR_VERSION < 41)\n\treturn vips_gaussblur(in, out, (int) sigma, NULL);\n#else\n\treturn vips_gaussblur(in, out, sigma, NULL, \"min_ampl\", min_ampl, NULL);\n#endif\n}\n\nint\nvips_sharpen_bridge(VipsImage *in, VipsImage **out, int radius, double x1, double y2, double y3, double m1, double m2) {\n#if (VIPS_MAJOR_VERSION == 7 && VIPS_MINOR_VERSION < 41)\n\treturn vips_sharpen(in, out, radius, x1, y2, y3, m1, m2, NULL);\n#else\n\treturn vips_sharpen(in, out, \"radius\", radius, \"x1\", x1, \"y2\", y2, \"y3\", y3, \"m1\", m1, \"m2\", m2, NULL);\n#endif\n}\n\nint\nvips_add_band(VipsImage *in, VipsImage **out, double c) {\n#if (VIPS_MAJOR_VERSION > 8 || (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 2))\n\treturn vips_bandjoin_const1(in, out, c, NULL);\n#else\n\tVipsImage *base = vips_image_new();\n\tif (\n\t\tvips_black(&base, in->Xsize, in->Ysize, NULL) ||\n\t\tvips_linear1(base, &base, 1, c, NULL)) {\n\t\t\tg_object_unref(base);\n\t\t\treturn 1;\n\t\t}\n\tg_object_unref(base);\n\treturn vips_bandjoin2(in, base, out, c, NULL);\n#endif\n}\n\nint\nvips_watermark_image(VipsImage *in, VipsImage *sub, VipsImage **out, WatermarkImageOptions *o) {\n\tVipsImage *base = vips_image_new();\n\tVipsImage **t = (VipsImage **) vips_object_local_array(VIPS_OBJECT(base), 10);\n\n  // add in and sub for unreffing and later use\n\tt[0] = in;\n\tt[1] = sub;\n\n  if (has_alpha_channel(in) == 0) {\n\t\tvips_add_band(in, &t[0], 255.0);\n\t\t// in is no longer in the array and won't be unreffed, so add it at the end\n\t\tt[8] = in;\n\t}\n\n\tif (has_alpha_channel(sub) == 0) {\n\t\tvips_add_band(sub, &t[1], 255.0);\n\t\t// sub is no longer in the array and won't be unreffed, so add it at the end\n\t\tt[9] = sub;\n\t}\n\n\t// Place watermark image in the right place and size it to the size of the\n\t// image that should be watermarked\n\tif (\n\t\tvips_embed(t[1], &t[2], o->Left, o->Top, t[0]->Xsize, t[0]->Ysize, NULL)) {\n\t\t\tg_object_unref(base);\n\t\treturn 1;\n\t}\n\n\t// Create a mask image based on the alpha band from the watermark image\n\t// and place it in the right position\n\tif (\n\t\tvips_extract_band(t[1], &t[3], t[1]->Bands - 1, \"n\", 1, NULL) ||\n\t\tvips_linear1(t[3], &t[4], o->Opacity, 0.0, NULL) ||\n\t\tvips_cast(t[4], &t[5], VIPS_FORMAT_UCHAR, NULL) ||\n\t\tvips_copy(t[5], &t[6], \"interpretation\", t[0]->Type, NULL) ||\n\t\tvips_embed(t[6], &t[7], o->Left, o->Top, t[0]->Xsize, t[0]->Ysize, NULL))\t{\n\t\t\tg_object_unref(base);\n\t\treturn 1;\n\t}\n\n\t// Blend the mask and watermark image and write to output.\n\tif (vips_ifthenelse(t[7], t[2], t[0], out, \"blend\", TRUE, NULL)) {\n\t\tg_object_unref(base);\n\t\treturn 1;\n\t}\n\n\tg_object_unref(base);\n\treturn 0;\n}\n\nint\nvips_smartcrop_bridge(VipsImage *in, VipsImage **out, int width, int height) {\n#if (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 5)\n\treturn vips_smartcrop(in, out, width, height, NULL);\n#else\n\treturn 0;\n#endif\n}\n\nint vips_find_trim_bridge(VipsImage *in, int *top, int *left, int *width, int *height, double r, double g, double b, double threshold) {\n#if (VIPS_MAJOR_VERSION >= 8 && VIPS_MINOR_VERSION >= 6)\n\tif (vips_is_16bit(in->Type)) {\n\t\tr = 65535 * r / 255;\n\t\tg = 65535 * g / 255;\n\t\tb = 65535 * b / 255;\n\t}\n\n\tdouble background[3] = {r, g, b};\n\tVipsArrayDouble *vipsBackground = vips_array_double_new(background, 3);\n\treturn vips_find_trim(in, top, left, width, height, \"background\", vipsBackground, \"threshold\", threshold, NULL);\n#else\n\treturn 0;\n#endif\n}\n\nint vips_gamma_bridge(VipsImage *in, VipsImage **out, double exponent)\n{\n  return vips_gamma(in, out, \"exponent\", 1.0 / exponent, NULL);\n}\n\nint vips_brightness_bridge(VipsImage *in, VipsImage **out, double k)\n{\n    return vips_linear1(in, out, 1.0 , k, NULL);\n}\n\nint vips_contrast_bridge(VipsImage *in, VipsImage **out, double k)\n{\n    return vips_linear1(in, out, k , 0.0, NULL);\n}\n"
        },
        {
          "name": "vips_test.go",
          "type": "blob",
          "size": 5.23046875,
          "content": "package bimg\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n)\n\nfunc TestVipsRead(t *testing.T) {\n\tfiles := []struct {\n\t\tname     string\n\t\texpected ImageType\n\t}{\n\t\t{\"test.jpg\", JPEG},\n\t\t{\"test.png\", PNG},\n\t\t{\"test.webp\", WEBP},\n\t}\n\n\tfor _, file := range files {\n\t\timage, imageType, _ := vipsRead(readImage(file.name))\n\t\tif image == nil {\n\t\t\tt.Fatal(\"Empty image\")\n\t\t}\n\t\tif imageType != file.expected {\n\t\t\tt.Fatal(\"Invalid image type\")\n\t\t}\n\t}\n}\n\nfunc TestVipsSave(t *testing.T) {\n\ttypes := [...]ImageType{JPEG, PNG, WEBP}\n\n\tfor _, typ := range types {\n\t\timage, _, _ := vipsRead(readImage(\"test.jpg\"))\n\t\toptions := vipsSaveOptions{Quality: 95, Type: typ, StripMetadata: true}\n\n\t\tbuf, err := vipsSave(image, options)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot save the image as '%v'\", ImageTypes[typ])\n\t\t}\n\t\tif len(buf) == 0 {\n\t\t\tt.Fatalf(\"Empty saved '%v' image\", ImageTypes[typ])\n\t\t}\n\t}\n}\n\nfunc TestVipsSaveTiff(t *testing.T) {\n\tif !IsTypeSupportedSave(TIFF) {\n\t\tt.Skipf(\"Format %#v is not supported\", ImageTypes[TIFF])\n\t}\n\timage, _, _ := vipsRead(readImage(\"test.jpg\"))\n\toptions := vipsSaveOptions{Quality: 95, Type: TIFF}\n\tbuf, _ := vipsSave(image, options)\n\n\tif len(buf) == 0 {\n\t\tt.Fatalf(\"Empty saved '%v' image\", ImageTypes[TIFF])\n\t}\n}\n\nfunc TestVipsSaveAvif(t *testing.T) {\n\tif !IsTypeSupportedSave(AVIF) {\n\t\tt.Skipf(\"Format %#v is not supported\", ImageTypes[AVIF])\n\t}\n\timage, _, _ := vipsRead(readImage(\"test.jpg\"))\n\toptions := vipsSaveOptions{Quality: 95, Type: AVIF, Speed: 8}\n\tbuf, err := vipsSave(image, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Error saving image type %v: %v\", ImageTypes[AVIF], err)\n\t}\n\n\tif len(buf) == 0 {\n\t\tt.Fatalf(\"Empty saved '%v' image\", ImageTypes[AVIF])\n\t}\n}\n\nfunc TestVipsRotate(t *testing.T) {\n\tfiles := []struct {\n\t\tname   string\n\t\trotate Angle\n\t}{\n\t\t{\"test.jpg\", D90},\n\t\t{\"test_square.jpg\", D45},\n\t}\n\n\tfor _, file := range files {\n\t\timage, _, _ := vipsRead(readImage(file.name))\n\n\t\tnewImg, err := vipsRotate(image, file.rotate)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Cannot rotate the image\")\n\t\t}\n\n\t\tbuf, _ := vipsSave(newImg, vipsSaveOptions{Quality: 95})\n\t\tif len(buf) == 0 {\n\t\t\tt.Fatal(\"Empty image\")\n\t\t}\n\t}\n}\n\nfunc TestVipsAutoRotate(t *testing.T) {\n\tif VipsMajorVersion <= 8 && VipsMinorVersion < 10 {\n\t\tt.Skip(\"Skip test in libvips < 8.10\")\n\t\treturn\n\t}\n\n\tfiles := []struct {\n\t\tname        string\n\t\torientation int\n\t}{\n\t\t{\"test.jpg\", 0},\n\t\t{\"test_exif.jpg\", 0},\n\t\t{\"exif/Landscape_1.jpg\", 0},\n\t\t{\"exif/Landscape_2.jpg\", 0},\n\t\t{\"exif/Landscape_3.jpg\", 0},\n\t\t{\"exif/Landscape_4.jpg\", 0},\n\t\t{\"exif/Landscape_5.jpg\", 5},\n\t\t{\"exif/Landscape_6.jpg\", 0},\n\t\t{\"exif/Landscape_7.jpg\", 7},\n\t}\n\n\tfor _, file := range files {\n\t\timage, _, _ := vipsRead(readImage(file.name))\n\n\t\tnewImg, err := vipsAutoRotate(image)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Cannot auto rotate the image\")\n\t\t}\n\n\t\torientation := vipsExifOrientation(newImg)\n\t\tif orientation != file.orientation {\n\t\t\tt.Fatalf(\"Invalid image orientation: %d != %d\", orientation, file.orientation)\n\t\t}\n\n\t\tbuf, _ := vipsSave(newImg, vipsSaveOptions{Quality: 95})\n\t\tif len(buf) == 0 {\n\t\t\tt.Fatal(\"Empty image\")\n\t\t}\n\t}\n}\n\nfunc TestVipsZoom(t *testing.T) {\n\timage, _, _ := vipsRead(readImage(\"test.jpg\"))\n\n\tnewImg, err := vipsZoom(image, 1)\n\tif err != nil {\n\t\tt.Fatal(\"Cannot save the image\")\n\t}\n\n\tbuf, _ := vipsSave(newImg, vipsSaveOptions{Quality: 95})\n\tif len(buf) == 0 {\n\t\tt.Fatal(\"Empty image\")\n\t}\n}\n\nfunc TestVipsWatermark(t *testing.T) {\n\timage, _, _ := vipsRead(readImage(\"test.jpg\"))\n\n\twatermark := Watermark{\n\t\tText:       \"Copy me if you can\",\n\t\tFont:       \"sans bold 12\",\n\t\tOpacity:    0.5,\n\t\tWidth:      200,\n\t\tDPI:        100,\n\t\tMargin:     100,\n\t\tBackground: Color{255, 255, 255},\n\t}\n\n\tnewImg, err := vipsWatermark(image, watermark)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot add watermark: %s\", err)\n\t}\n\n\tbuf, _ := vipsSave(newImg, vipsSaveOptions{Quality: 95})\n\tif len(buf) == 0 {\n\t\tt.Fatal(\"Empty image\")\n\t}\n}\n\nfunc TestVipsWatermarkWithImage(t *testing.T) {\n\timage, _, _ := vipsRead(readImage(\"test.jpg\"))\n\n\twatermark := readImage(\"transparent.png\")\n\n\toptions := WatermarkImage{Left: 100, Top: 100, Opacity: 1.0, Buf: watermark}\n\tnewImg, err := vipsDrawWatermark(image, options)\n\tif err != nil {\n\t\tt.Errorf(\"Cannot add watermark: %s\", err)\n\t}\n\n\tbuf, _ := vipsSave(newImg, vipsSaveOptions{Quality: 95})\n\tif len(buf) == 0 {\n\t\tt.Fatal(\"Empty image\")\n\t}\n}\n\nfunc TestVipsImageType(t *testing.T) {\n\timgType := vipsImageType(readImage(\"test.jpg\"))\n\tif imgType != JPEG {\n\t\tt.Fatal(\"Invalid image type\")\n\t}\n}\n\nfunc TestVipsImageTypeInvalid(t *testing.T) {\n\timgType := vipsImageType([]byte(\"vip\"))\n\tif imgType != UNKNOWN {\n\t\tt.Fatal(\"Invalid image type\")\n\t}\n}\n\nfunc TestVipsMemory(t *testing.T) {\n\tmem := VipsMemory()\n\n\tif mem.Memory < 1024 {\n\t\tt.Fatal(\"Invalid memory\")\n\t}\n\tif mem.Allocations == 0 {\n\t\tt.Fatal(\"Invalid memory allocations\")\n\t}\n}\n\nfunc TestVipsExifShort(t *testing.T) {\n\ttt := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tinput:    `( ()`,\n\t\t\texpected: `(`,\n\t\t},\n\t\t{\n\t\t\tinput:    ` ()`,\n\t\t\texpected: ` ()`,\n\t\t},\n\t\t{\n\t\t\tinput:    `sRGB`,\n\t\t\texpected: `sRGB`,\n\t\t},\n\t}\n\n\tfor _, tc := range tt {\n\t\tgot := vipsExifShort(tc.input)\n\t\tif got != tc.expected {\n\t\t\tt.Fatalf(\"expected: %s; got: %s\", tc.expected, got)\n\t\t}\n\t}\n}\n\nfunc readImage(file string) []byte {\n\timg, _ := os.Open(path.Join(\"testdata\", file))\n\tbuf, _ := ioutil.ReadAll(img)\n\tdefer img.Close()\n\treturn buf\n}\n"
        }
      ]
    }
  ]
}