{
  "metadata": {
    "timestamp": 1736567065754,
    "page": 650,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "samber/mo",
      "stars": 2747,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.736328125,
          "content": "\n# Created by https://www.toptal.com/developers/gitignore/api/go\n# Edit at https://www.toptal.com/developers/gitignore?templates=go\n\n### Go ###\n# If you prefer the allow list template instead of the deny list, see community template:\n# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore\n#\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\n\n### Go Patch ###\n/vendor/\n/Godeps/\n\n# End of https://www.toptal.com/developers/gitignore/api/go\n\ncover.out\ncover.html\n.vscode\n.idea"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.103515625,
          "content": "\nFROM golang:1.23.0-bullseye\n\nWORKDIR /go/src/github.com/samber/mo\n\nCOPY Makefile go.* ./\n\nRUN make tools\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2022 Samuel Berthe\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.03125,
          "content": "\nbuild:\n\tgo build -v ./...\n\ntest:\n\tgo test -v ./...\nwatch-test:\n\treflex -t 50ms -s -- sh -c 'gotest -v ./...'\n\nbench:\n\tgo test -benchmem -count 3 -bench ./...\nwatch-bench:\n\treflex -t 50ms -s -- sh -c 'go test -benchmem -count 3 -bench ./...'\n\ncoverage:\n\tgo test -v -coverprofile=cover.out -covermode=atomic ./...\n\tgo tool cover -html=cover.out -o cover.html\n\n# tools\ntools:\n\tgo install github.com/cespare/reflex@latest\n\tgo install github.com/rakyll/gotest@latest\n\tgo install github.com/psampaz/go-mod-outdated@latest\n\tgo install github.com/jondot/goweight@latest\n\tgo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\tgo get -t -u golang.org/x/tools/cmd/cover\n\tgo get -t -u github.com/sonatype-nexus-community/nancy@latest\n\tgo mod tidy\n\nlint:\n\tgolangci-lint run --timeout 60s --max-same-issues 50 ./...\nlint-fix:\n\tgolangci-lint run --timeout 60s --max-same-issues 50 --fix ./...\n\naudit:\n\tgo mod tidy\n\tgo list -json -m all | nancy sleuth\n\noutdated:\n\tgo mod tidy\n\tgo list -u -m -json all | go-mod-outdated -update -direct\n\nweight:\n\tgoweight\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.333984375,
          "content": "# mo - Monads\n\n[![tag](https://img.shields.io/github/tag/samber/mo.svg)](https://github.com/samber/mo/releases)\n![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.18-%23007d9c)\n[![GoDoc](https://godoc.org/github.com/samber/mo?status.svg)](https://pkg.go.dev/github.com/samber/mo)\n![Build Status](https://github.com/samber/mo/actions/workflows/test.yml/badge.svg)\n[![Go report](https://goreportcard.com/badge/github.com/samber/mo)](https://goreportcard.com/report/github.com/samber/mo)\n[![Coverage](https://img.shields.io/codecov/c/github/samber/do)](https://codecov.io/gh/samber/mo)\n[![License](https://img.shields.io/github/license/samber/mo)](./LICENSE)\n\nü¶Ñ **`samber/mo` brings monads and popular FP abstractions to Go projects. `samber/mo` uses the recent Go 1.18+ Generics.**\n\n**Inspired by:**\n\n- Scala\n- Rust\n- FP-TS\n\n**See also:**\n\n- [samber/lo](https://github.com/samber/lo): A Lodash-style Go library based on Go 1.18+ Generics\n- [samber/do](https://github.com/samber/do): A dependency injection toolkit based on Go 1.18+ Generics\n\n**Why this name?**\n\nI love **short name** for such utility library. This name is similar to \"Monad Go\" and no Go package uses this name.\n\n## üí° Features\n\nWe currently support the following data types:\n\n- `Option[T]` (Maybe)\n- `Result[T]`\n- `Either[A, B]`\n- `EitherX[T1, ..., TX]` (With X between 3 and 5)\n- `Future[T]`\n- `IO[T]`\n- `IOEither[T]`\n- `Task[T]`\n- `TaskEither[T]`\n- `State[S, A]`\n\n## üöÄ Install\n\n```sh\ngo get github.com/samber/mo@v1\n```\n\nThis library is v1 and follows SemVer strictly.\n\nNo breaking changes will be made to exported APIs before v2.0.0.\n\nThis library has no dependencies except the Go std lib.\n\n## üí° Quick start\n\nYou can import `mo` using:\n\n```go\nimport (\n    \"github.com/samber/mo\"\n)\n```\n\nThen use one of the helpers below:\n\n```go\noption1 := mo.Some(42)\n// Some(42)\n\noption1.\n    FlatMap(func (value int) Option[int] {\n        return Some(value*2)\n    }).\n    FlatMap(func (value int) Option[int] {\n        return Some(value%2)\n    }).\n    FlatMap(func (value int) Option[int] {\n        return Some(value+21)\n    }).\n    OrElse(1234)\n// 21\n\noption2 := mo.None[int]()\n// None\n\noption2.OrElse(1234)\n// 1234\n\noption3 := option1.Match(\n    func(i int) (int, bool) {\n        // when value is present\n        return i * 2, true\n    },\n    func() (int, bool) {\n        // when value is absent\n        return 0, false\n    },\n)\n// Some(42)\n```\n\nMore examples in [documentation](https://godoc.org/github.com/samber/mo).\n\n### Tips for lazy developers\n\nI cannot recommend it, but in case you are too lazy for repeating `mo.` everywhere, you can import the entire library into the namespace.\n\n```go\nimport (\n    . \"github.com/samber/mo\"\n)\n```\n\nI take no responsibility on this junk. üòÅ üí©\n\n## ü§† Documentation and examples\n\n[GoDoc: https://godoc.org/github.com/samber/mo](https://godoc.org/github.com/samber/mo)\n\n### Option[T any]\n\n`Option` is a container for an optional value of type `T`. If value exists, `Option` is of type `Some`. If the value is absent, `Option` is of type `None`.\n\nImplements:\n- `mo.Foldable[T, U]`\n\nConstructors:\n\n- `mo.Some()` [doc](https://pkg.go.dev/github.com/samber/mo#Some) - [play](https://go.dev/play/p/iqz2n9n0tDM)\n- `mo.None()` [doc](https://pkg.go.dev/github.com/samber/mo#None) - [play](https://go.dev/play/p/yYQPsYCSYlD)\n- `mo.TupleToOption()` [doc](https://pkg.go.dev/github.com/samber/mo#TupleToOption) - [play](https://go.dev/play/p/gkrg2pZwOty)\n- `mo.EmptyableToOption()` [doc](https://pkg.go.dev/github.com/samber/mo#EmptyableToOption) - [play](https://go.dev/play/p/GSpQQ-q-UES)\n- `mo.PointerToOption()` [doc](https://pkg.go.dev/github.com/samber/mo#PointerToOption) - [play](https://go.dev/play/p/yPVMj4DUb-I)\n\nMethods:\n\n- `.IsPresent()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.IsPresent) - [play](https://go.dev/play/p/nDqIaiihyCA)\n- `.IsAbsent()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.IsAbsent) - [play](https://go.dev/play/p/23e2zqyVOQm)\n- `.Size()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.Size) - [play](https://go.dev/play/p/7ixCNG1E9l7)\n- `.Get()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.Get) - [play](https://go.dev/play/p/0-JBa1usZRT)\n- `.MustGet()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.MustGet) - [play](https://go.dev/play/p/RVBckjdi5WR)\n- `.OrElse()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.OrElse) - [play](https://go.dev/play/p/TrGByFWCzXS)\n- `.OrEmpty()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.OrEmpty) - [play](https://go.dev/play/p/SpSUJcE-tQm)\n- `.ToPointer()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.ToPointer) - [play](https://go.dev/play/p/N43w92SM-Bs)\n- `.ForEach()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.ForEach)\n- `.Match()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.Match) - [play](https://go.dev/play/p/1V6st3LDJsM)\n- `.Map()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.Map) - [play](https://go.dev/play/p/mvfP3pcP_eJ)\n- `.MapNone()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.MapNone) - [play](https://go.dev/play/p/_KaHWZ6Q17b)\n- `.FlatMap()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.FlatMap) - [play](https://go.dev/play/p/OXO-zJx6n5r)\n- `.MarshalJSON()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.MarshalJSON)\n- `.UnmarshalJSON()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.UnmarshalJSON)\n- `.MarshalText()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.MarshalText)\n- `.UnmarshalText()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.UnmarshalText)\n- `.MarshalBinary()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.MarshalBinary)\n- `.UnmarshalBinary()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.UnmarshalBinary)\n- `.GobEncode()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.GobEncode)\n- `.GobDecode()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.GobDecode)\n- `.Scan()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.Scan)\n- `.Value()` [doc](https://pkg.go.dev/github.com/samber/mo#Option.Value)\n\nOther:\n\n- `mo.Fold[T, U, R any](f Foldable[T, U], successFunc func(U) R, failureFunc func(T) R) R` [doc](https://pkg.go.dev/github.com/samber/mo#Fold)\n\n### Result[T any]\n\n`Result` respresent a result of an action having one of the following output: success or failure. An instance of `Result` is an instance of either `Ok` or `Err`. It could be compared to `Either[error, T]`.\n\nImplements:\n- `mo.Foldable[T, U]`\n\nConstructors:\n\n- `mo.Ok()` [doc](https://pkg.go.dev/github.com/samber/mo#Ok) - [play](https://go.dev/play/p/PDwADdzNoyZ)\n- `mo.Err()` [doc](https://pkg.go.dev/github.com/samber/mo#Err) - [play](https://go.dev/play/p/PDwADdzNoyZ)\n- `mo.Errf()` [doc](https://pkg.go.dev/github.com/samber/mo#Errf) - [play](https://go.dev/play/p/N43w92SM-Bs)\n- `mo.TupleToResult()` [doc](https://pkg.go.dev/github.com/samber/mo#TupleToResult) - [play](https://go.dev/play/p/KWjfqQDHQwa)\n- `mo.Try()` [doc](https://pkg.go.dev/github.com/samber/mo#Try) - [play](https://go.dev/play/p/ilOlQx-Mx42)\n\nMethods:\n\n- `.IsOk()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.IsOk) - [play](https://go.dev/play/p/sfNvBQyZfgU)\n- `.IsError()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.IsError) - [play](https://go.dev/play/p/xkV9d464scV)\n- `.Error()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.Error) - [play](https://go.dev/play/p/CSkHGTyiXJ5)\n- `.Get()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.Get) - [play](https://go.dev/play/p/8KyX3z6TuNo)\n- `.MustGet()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.MustGet) - [play](https://go.dev/play/p/8LSlndHoTAE)\n- `.OrElse()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.OrElse) - [play](https://go.dev/play/p/MN_ULx0soi6)\n- `.OrEmpty()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.OrEmpty) - [play](https://go.dev/play/p/rdKtBmOcMLh)\n- `.ToEither()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.ToEither) - [play](https://go.dev/play/p/Uw1Zz6b952q)\n- `.ForEach()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.ForEach)\n- `.Match()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.Match) - [play](https://go.dev/play/p/-_eFaLJ31co)\n- `.Map()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.Map) - [play](https://go.dev/play/p/-ndpN_b_OSc)\n- `.MapErr()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.MapErr) - [play](https://go.dev/play/p/WraZixg9GGf)\n- `.FlatMap()` [doc](https://pkg.go.dev/github.com/samber/mo#Result.FlatMap) - [play](https://go.dev/play/p/Ud5QjZOqg-7)\n\nOther:\n\n- `mo.Fold[T, U, R any](f Foldable[T, U], successFunc func(U) R, failureFunc func(T) R) R` [doc](https://pkg.go.dev/github.com/samber/mo#Fold)\n- `mo.Do[T any](fn func() T) (result mo.Result[T])` [doc](https://pkg.go.dev/github.com/samber/mo#Do)\n\n### Either[L any, R any]\n\n`Either` represents a value of 2 possible types. An instance of `Either` is an instance of either `A` or `B`.\n\nImplements:\n- `mo.Foldable[T, U]`\n\nConstructors:\n\n- `mo.Left()` [doc](https://pkg.go.dev/github.com/samber/mo#Left)\n- `mo.Right()` [doc](https://pkg.go.dev/github.com/samber/mo#Right)\n\nMethods:\n\n- `.IsLeft()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.IsLeft)\n- `.IsRight()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.IsRight)\n- `.Left()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.Left)\n- `.Right()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.Right)\n- `.MustLeft()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.MustLeft)\n- `.MustRight()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.MustRight)\n- `.Unpack()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.Unpack)\n- `.LeftOrElse()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.LeftOrElse)\n- `.RightOrElse()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.RightOrElse)\n- `.LeftOrEmpty()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.LeftOrEmpty)\n- `.RightOrEmpty()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.RightOrEmpty)\n- `.Swap()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.Swap)\n- `.ForEach()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.ForEach)\n- `.Match()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.Match)\n- `.MapLeft()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.MapLeft)\n- `.MapRight()` [doc](https://pkg.go.dev/github.com/samber/mo#Either.MapRight)\n\nOther:\n\n- `mo.Fold[T, U, R any](f Foldable[T, U], successFunc func(U) R, failureFunc func(T) R) R` [doc](https://pkg.go.dev/github.com/samber/mo#Fold)\n\n### EitherX[T1, ..., TX] (With X between 3 and 5)\n\n`EitherX` respresents a value of X possible types. For example, an `Either3` value is either `T1`, `T2` or `T3`.\n\nConstructors:\n\n- `mo.NewEitherXArgY()` [doc](https://pkg.go.dev/github.com/samber/mo#NewEither5Arg1). Eg:\n  - `mo.NewEither3Arg1[A, B, C](A)`\n  - `mo.NewEither3Arg2[A, B, C](B)`\n  - `mo.NewEither3Arg3[A, B, C](C)`\n  - `mo.NewEither4Arg1[A, B, C, D](A)`\n  - `mo.NewEither4Arg2[A, B, C, D](B)`\n  - ...\n\nMethods:\n\n- `.IsArgX()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.IsArg1)\n- `.ArgX()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.Arg1)\n- `.MustArgX()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.MustArg1)\n- `.Unpack()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.Unpack)\n- `.ArgXOrElse()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.Arg1OrElse)\n- `.ArgXOrEmpty()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.Arg1OrEmpty)\n- `.ForEach()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.ForEach)\n- `.Match()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.Match)\n- `.MapArgX()` [doc](https://pkg.go.dev/github.com/samber/mo#Either5.MapArg1)\n\n### Future[T any]\n\n`Future` represents a value which may or may not currently be available, but will be available at some point, or an exception if that value could not be made available.\n\nConstructors:\n\n- `mo.NewFuture()` [doc](https://pkg.go.dev/github.com/samber/mo#NewFuture)\n\nMethods:\n\n- `.Then()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Then)\n- `.Catch()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Catch)\n- `.Finally()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Finally)\n- `.Collect()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Collect)\n- `.Result()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Result)\n- `.Cancel()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Cancel)\n\n### IO[T any]\n\n`IO` represents a non-deterministic synchronous computation that can cause side effects, yields a value of type `R` and never fails.\n\nConstructors:\n\n- `mo.NewIO()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIO)\n- `mo.NewIO1()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIO1)\n- `mo.NewIO2()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIO2)\n- `mo.NewIO3()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIO3)\n- `mo.NewIO4()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIO4)\n- `mo.NewIO5()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIO5)\n\nMethods:\n\n- `.Run()` [doc](https://pkg.go.dev/github.com/samber/mo#Future.Run)\n\n### IOEither[T any]\n\n`IO` represents a non-deterministic synchronous computation that can cause side effects, yields a value of type `R` and can fail.\n\nConstructors:\n\n- `mo.NewIOEither()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIOEither)\n- `mo.NewIOEither1()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIOEither1)\n- `mo.NewIOEither2()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIOEither2)\n- `mo.NewIOEither3()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIOEither3)\n- `mo.NewIOEither4()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIOEither4)\n- `mo.NewIOEither5()` [doc](https://pkg.go.dev/github.com/samber/mo#NewIOEither5)\n\nMethods:\n\n- `.Run()` [doc](https://pkg.go.dev/github.com/samber/mo#IOEither.Run)\n\n### Task[T any]\n\n`Task` represents a non-deterministic asynchronous computation that can cause side effects, yields a value of type `R` and never fails.\n\nConstructors:\n\n- `mo.NewTask()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTask)\n- `mo.NewTask1()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTask1)\n- `mo.NewTask2()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTask2)\n- `mo.NewTask3()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTask3)\n- `mo.NewTask4()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTask4)\n- `mo.NewTask5()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTask5)\n- `mo.NewTaskFromIO()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskFromIO)\n- `mo.NewTaskFromIO1()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskFromIO1)\n- `mo.NewTaskFromIO2()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskFromIO2)\n- `mo.NewTaskFromIO3()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskFromIO3)\n- `mo.NewTaskFromIO4()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskFromIO4)\n- `mo.NewTaskFromIO5()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskFromIO5)\n\nMethods:\n\n- `.Run()` [doc](https://pkg.go.dev/github.com/samber/mo#Task.Run)\n\n### TaskEither[T any]\n\n`TaskEither` represents a non-deterministic asynchronous computation that can cause side effects, yields a value of type `R` and can fail.\n\nConstructors:\n\n- `mo.NewTaskEither()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskEither)\n- `mo.NewTaskEitherFromIOEither()` [doc](https://pkg.go.dev/github.com/samber/mo#NewTaskEitherFromIOEither)\n\nMethods:\n\n- `.Run()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.Run)\n- `.OrElse()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.OrElse)\n- `.Match()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.Match)\n- `.TryCatch()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.TryCatch)\n- `.ToTask()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.ToTask)\n- `.ToEither()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.ToEither)\n\n### State[S any, A any]\n\n`State` represents a function `(S) -> (A, S)`, where `S` is state, `A` is result.\n\nConstructors:\n\n- `mo.NewState()` [doc](https://pkg.go.dev/github.com/samber/mo#NewState)\n- `mo.ReturnState()` [doc](https://pkg.go.dev/github.com/samber/mo#ReturnState)\n\nMethods:\n\n- `.Run()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.Run)\n- `.Get()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.Get)\n- `.Modify()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.Modify)\n- `.Put()` [doc](https://pkg.go.dev/github.com/samber/mo#TaskEither.Put)\n\n### Foldable[T, U]\n\nFoldable represents a type that can be folded into a single value based on its state.\n\n- `mo.Fold[T, U, R any](f Foldable[T, U], successFunc func(U) R, failureFunc func(T) R) R` [doc](https://pkg.go.dev/github.com/samber/mo#Fold)\n\n## üõ© Benchmark\n\n// @TODO\n\nThis library does not use `reflect` package. We don't expect overhead.\n\n## ü§ù Contributing\n\n- Ping me on Twitter [@samuelberthe](https://twitter.com/samuelberthe) (DMs, mentions, whatever :))\n- Fork the [project](https://github.com/samber/mo)\n- Fix [open issues](https://github.com/samber/mo/issues) or request new features\n\nDon't hesitate ;)\n\n### With Docker\n\n```bash\ndocker-compose run --rm dev\n```\n\n### Without Docker\n\n```bash\n# Install some dev dependencies\nmake tools\n\n# Run tests\nmake test\n# or\nmake watch-test\n```\n\n## üë§ Contributors\n\n![Contributors](https://contrib.rocks/image?repo=samber/mo)\n\n## üí´ Show your support\n\nGive a ‚≠êÔ∏è if this project helped you!\n\n[![GitHub Sponsors](https://img.shields.io/github/sponsors/samber?style=for-the-badge)](https://github.com/sponsors/samber)\n\n## üìù License\n\nCopyright ¬© 2022 [Samuel Berthe](https://github.com/samber).\n\nThis project is [MIT](./LICENSE) licensed.\n"
        },
        {
          "name": "do.go",
          "type": "blob",
          "size": 0.5537109375,
          "content": "package mo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Do executes a function within a monadic context, capturing any errors that occur.\n// If the function executes successfully, its result is wrapped in a successful Result.\n// If the function panics (indicating a failure), the panic is caught and converted into an error Result.\nfunc Do[T any](fn func() T) (result Result[T]) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif err, ok := r.(error); ok {\n\t\t\t\tresult = Err[T](err)\n\t\t\t} else {\n\t\t\t\tresult = Err[T](errors.New(fmt.Sprint(r)))\n\t\t\t}\n\t\t}\n\t}()\n\treturn Ok(fn())\n}\n"
        },
        {
          "name": "do_example_test.go",
          "type": "blob",
          "size": 0.65625,
          "content": "package mo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc ExampleDo() {\n\ta := Ok(\"Hello, World!\")\n\tb := Some(\"42\")\n\n\tresult := Do(func() []string {\n\t\treturn []string{\n\t\t\ta.MustGet(),\n\t\t\tb.MustGet(),\n\t\t}\n\t})\n\n\tfmt.Println(result.IsError())\n\tfmt.Println(result.MustGet())\n\t// Output:\n\t// false\n\t// [Hello, World! 42]\n}\n\nfunc ExampleDo_panic() {\n\ta := Ok(\"Hello, World!\")\n\tb := Some(\"42\")\n\tc := Err[string](errors.New(\"result error\"))\n\n\tresult := Do(func() []string {\n\t\treturn []string{\n\t\t\ta.MustGet(),\n\t\t\tb.MustGet(),\n\t\t\tc.MustGet(), // would panic without Do-notation\n\t\t}\n\t})\n\n\tfmt.Println(result.IsError())\n\tfmt.Println(result.Error().Error())\n\t// Output:\n\t// true\n\t// result error\n}\n"
        },
        {
          "name": "do_test.go",
          "type": "blob",
          "size": 2.884765625,
          "content": "package mo\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDo_Success(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult := Do(func() string {\n\t\treturn \"Hello, World!\"\n\t})\n\n\tis.False(result.IsError())\n\tis.Equal(\"Hello, World!\", result.MustGet())\n}\n\nfunc TestDo_Error(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult := Do(func() string {\n\t\tpanic(errors.New(\"something went wrong\"))\n\t})\n\n\tis.True(result.IsError())\n\tis.EqualError(result.Error(), \"something went wrong\")\n}\n\nfunc TestDo_ComplexSuccess(t *testing.T) {\n\tis := assert.New(t)\n\n\tvalidateBooking := func(params map[string]string) Result[map[string]string] {\n\t\tif params[\"guest\"] != \"\" && params[\"roomType\"] != \"\" {\n\t\t\treturn Ok(params)\n\t\t}\n\t\treturn Err[map[string]string](errors.New(\"validation failed\"))\n\t}\n\n\tcreateBooking := func(guest string) Result[string] {\n\t\tif guest != \"\" {\n\t\t\treturn Ok(\"Booking Created for: \" + guest)\n\t\t}\n\t\treturn Err[string](errors.New(\"booking creation failed\"))\n\t}\n\n\tassignRoom := func(booking string, roomType string) Result[string] {\n\t\tif roomType != \"\" {\n\t\t\treturn Ok(\"Room Assigned: \" + roomType + \" for \" + booking)\n\t\t}\n\t\treturn Err[string](errors.New(\"room assignment failed\"))\n\t}\n\n\tbookRoom := func(params map[string]string) Result[[]string] {\n\t\treturn Do(func() []string {\n\t\t\tvalues := validateBooking(params).MustGet()\n\t\t\tbooking := createBooking(values[\"guest\"]).MustGet()\n\t\t\troom := assignRoom(booking, values[\"roomType\"]).MustGet()\n\t\t\treturn []string{booking, room}\n\t\t})\n\t}\n\n\tparams := map[string]string{\n\t\t\"guest\":    \"Foo Bar\",\n\t\t\"roomType\": \"Suite\",\n\t}\n\n\tresult := bookRoom(params)\n\tis.False(result.IsError())\n\tis.Equal([]string{\"Booking Created for: Foo Bar\", \"Room Assigned: Suite for Booking Created for: Foo Bar\"}, result.MustGet())\n}\n\nfunc TestDo_ComplexError(t *testing.T) {\n\tis := assert.New(t)\n\n\tvalidateBooking := func(params map[string]string) Result[map[string]string] {\n\t\tif params[\"guest\"] != \"\" && params[\"roomType\"] != \"\" {\n\t\t\treturn Ok(params)\n\t\t}\n\t\treturn Err[map[string]string](errors.New(\"validation failed\"))\n\t}\n\n\tcreateBooking := func(guest string) Result[string] {\n\t\tif guest != \"\" {\n\t\t\treturn Ok(\"Booking Created for: \" + guest)\n\t\t}\n\t\treturn Err[string](errors.New(\"booking creation failed\"))\n\t}\n\n\tassignRoom := func(booking string, roomType string) Result[string] {\n\t\tif roomType != \"\" {\n\t\t\treturn Ok(\"Room Assigned: \" + roomType + \" for \" + booking)\n\t\t}\n\t\treturn Err[string](errors.New(\"room assignment failed\"))\n\t}\n\n\tbookRoom := func(params map[string]string) Result[[]string] {\n\t\treturn Do(func() []string {\n\t\t\tvalues := validateBooking(params).MustGet()\n\t\t\tbooking := createBooking(values[\"guest\"]).MustGet()\n\t\t\troom := assignRoom(booking, values[\"roomType\"]).MustGet()\n\t\t\treturn []string{booking, room}\n\t\t})\n\t}\n\n\tparams := map[string]string{\n\t\t\"guest\":    \"\",\n\t\t\"roomType\": \"Suite\",\n\t}\n\n\tresult := bookRoom(params)\n\tis.True(result.IsError())\n\tis.EqualError(result.Error(), \"validation failed\")\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.1904296875,
          "content": "version: '3'\n\nservices:\n  dev:\n    build: .\n    volumes:\n      - ./:/go/src/github.com/samber/mo\n    working_dir: /go/src/github.com/samber/mo\n    command: bash -c 'make tools ; make watch-test'\n"
        },
        {
          "name": "either.go",
          "type": "blob",
          "size": 4.20703125,
          "content": "package mo\n\nimport \"fmt\"\n\nvar eitherShouldBeLeftOrRight = fmt.Errorf(\"either should be Left or Right\")\nvar eitherMissingLeftValue = fmt.Errorf(\"no such Left value\")\nvar eitherMissingRightValue = fmt.Errorf(\"no such Right value\")\n\n// Left builds the left side of the Either struct, as opposed to the Right side.\nfunc Left[L any, R any](value L) Either[L, R] {\n\treturn Either[L, R]{\n\t\tisLeft: true,\n\t\tleft:   value,\n\t}\n}\n\n// Right builds the right side of the Either struct, as opposed to the Left side.\nfunc Right[L any, R any](value R) Either[L, R] {\n\treturn Either[L, R]{\n\t\tisLeft: false,\n\t\tright:  value,\n\t}\n}\n\n// Either respresents a value of 2 possible types.\n// An instance of Either is an instance of either A or B.\ntype Either[L any, R any] struct {\n\tisLeft bool\n\n\tleft  L\n\tright R\n}\n\n// IsLeft returns true if Either is an instance of Left.\nfunc (e Either[L, R]) IsLeft() bool {\n\treturn e.isLeft\n}\n\n// IsRight returns true if Either is an instance of Right.\nfunc (e Either[L, R]) IsRight() bool {\n\treturn !e.isLeft\n}\n\n// Left returns left value of a Either struct.\nfunc (e Either[L, R]) Left() (L, bool) {\n\tif e.IsLeft() {\n\t\treturn e.left, true\n\t}\n\treturn empty[L](), false\n}\n\n// Right returns right value of a Either struct.\nfunc (e Either[L, R]) Right() (R, bool) {\n\tif e.IsRight() {\n\t\treturn e.right, true\n\t}\n\treturn empty[R](), false\n}\n\n// MustLeft returns left value of a Either struct or panics.\nfunc (e Either[L, R]) MustLeft() L {\n\tif !e.IsLeft() {\n\t\tpanic(eitherMissingLeftValue)\n\t}\n\n\treturn e.left\n}\n\n// MustRight returns right value of a Either struct or panics.\nfunc (e Either[L, R]) MustRight() R {\n\tif !e.IsRight() {\n\t\tpanic(eitherMissingRightValue)\n\t}\n\n\treturn e.right\n}\n\n// Unpack returns all values\nfunc (e Either[L, R]) Unpack() (L, R) {\n\treturn e.left, e.right\n}\n\n// LeftOrElse returns left value of a Either struct or fallback.\nfunc (e Either[L, R]) LeftOrElse(fallback L) L {\n\tif e.IsLeft() {\n\t\treturn e.left\n\t}\n\n\treturn fallback\n}\n\n// RightOrElse returns right value of a Either struct or fallback.\nfunc (e Either[L, R]) RightOrElse(fallback R) R {\n\tif e.IsRight() {\n\t\treturn e.right\n\t}\n\n\treturn fallback\n}\n\n// LeftOrEmpty returns left value of a Either struct or empty value.\nfunc (e Either[L, R]) LeftOrEmpty() L {\n\tif e.IsLeft() {\n\t\treturn e.left\n\t}\n\n\treturn empty[L]()\n}\n\n// RightOrEmpty returns right value of a Either struct or empty value.\nfunc (e Either[L, R]) RightOrEmpty() R {\n\tif e.IsRight() {\n\t\treturn e.right\n\t}\n\n\treturn empty[R]()\n}\n\n// Swap returns the left value in Right and vice versa.\nfunc (e Either[L, R]) Swap() Either[R, L] {\n\tif e.IsLeft() {\n\t\treturn Right[R, L](e.left)\n\t}\n\n\treturn Left[R, L](e.right)\n}\n\n// ForEach executes the given side-effecting function, depending of value is Left or Right.\nfunc (e Either[L, R]) ForEach(leftCb func(L), rightCb func(R)) {\n\tif e.IsLeft() {\n\t\tleftCb(e.left)\n\t} else if e.IsRight() {\n\t\trightCb(e.right)\n\t}\n}\n\n// Match executes the given function, depending of value is Left or Right, and returns result.\nfunc (e Either[L, R]) Match(onLeft func(L) Either[L, R], onRight func(R) Either[L, R]) Either[L, R] {\n\tif e.IsLeft() {\n\t\treturn onLeft(e.left)\n\t} else if e.IsRight() {\n\t\treturn onRight(e.right)\n\t}\n\n\tpanic(eitherShouldBeLeftOrRight)\n}\n\n// MapLeft executes the given function, if Either is of type Left, and returns result.\nfunc (e Either[L, R]) MapLeft(mapper func(L) Either[L, R]) Either[L, R] {\n\tif e.IsLeft() {\n\t\treturn mapper(e.left)\n\t} else if e.IsRight() {\n\t\treturn Right[L, R](e.right)\n\t}\n\n\tpanic(eitherShouldBeLeftOrRight)\n}\n\n// MapRight executes the given function, if Either is of type Right, and returns result.\nfunc (e Either[L, R]) MapRight(mapper func(R) Either[L, R]) Either[L, R] {\n\tif e.isLeft {\n\t\treturn Left[L, R](e.left)\n\t} else if e.IsRight() {\n\t\treturn mapper(e.right)\n\t}\n\n\tpanic(eitherShouldBeLeftOrRight)\n}\n\n// leftValue returns left value of a Either struct.(implementation of Foldable interface)\n//\n//nolint:unused\nfunc (e Either[L, R]) leftValue() L {\n\treturn e.left\n}\n\n// rightValue returns right value of a Either struct.(implementation of Foldable interface)\n//\n//nolint:unused\nfunc (e Either[L, R]) rightValue() R {\n\treturn e.right\n}\n\n// hasLeft returns true if the Result represents an error state.\n//\n//nolint:unused\nfunc (e Either[L, R]) hasLeftValue() bool {\n\treturn e.isLeft\n}\n"
        },
        {
          "name": "either3.go",
          "type": "blob",
          "size": 5.423828125,
          "content": "package mo\n\nimport \"fmt\"\n\nconst (\n\teither3ArgId1 = iota\n\teither3ArgId2\n\teither3ArgId3\n)\n\nvar (\n\teither3InvalidArgumentId = fmt.Errorf(\"either3 argument should be between 1 and 3\")\n\teither3MissingArg1       = fmt.Errorf(\"either3 doesn't contain expected argument 1\")\n\teither3MissingArg2       = fmt.Errorf(\"either3 doesn't contain expected argument 2\")\n\teither3MissingArg3       = fmt.Errorf(\"either3 doesn't contain expected argument 3\")\n)\n\n// NewEither3Arg1 builds the first argument of the Either3 struct.\nfunc NewEither3Arg1[T1 any, T2 any, T3 any](value T1) Either3[T1, T2, T3] {\n\treturn Either3[T1, T2, T3]{\n\t\targId: either3ArgId1,\n\t\targ1:  value,\n\t}\n}\n\n// NewEither3Arg2 builds the second argument of the Either3 struct.\nfunc NewEither3Arg2[T1 any, T2 any, T3 any](value T2) Either3[T1, T2, T3] {\n\treturn Either3[T1, T2, T3]{\n\t\targId: either3ArgId2,\n\t\targ2:  value,\n\t}\n}\n\n// NewEither3Arg3 builds the third argument of the Either3 struct.\nfunc NewEither3Arg3[T1 any, T2 any, T3 any](value T3) Either3[T1, T2, T3] {\n\treturn Either3[T1, T2, T3]{\n\t\targId: either3ArgId3,\n\t\targ3:  value,\n\t}\n}\n\n// Either3 represents a value of 3 possible types.\n// An instance of Either3 is an instance of either T1, T2 or T3.\ntype Either3[T1 any, T2 any, T3 any] struct {\n\targId int8\n\n\targ1 T1\n\targ2 T2\n\targ3 T3\n}\n\n// IsArg1 returns true if Either3 uses the first argument.\nfunc (e Either3[T1, T2, T3]) IsArg1() bool {\n\treturn e.argId == either3ArgId1\n}\n\n// IsArg2 returns true if Either3 uses the second argument.\nfunc (e Either3[T1, T2, T3]) IsArg2() bool {\n\treturn e.argId == either3ArgId2\n}\n\n// IsArg3 returns true if Either3 uses the third argument.\nfunc (e Either3[T1, T2, T3]) IsArg3() bool {\n\treturn e.argId == either3ArgId3\n}\n\n// Arg1 returns the first argument of a Either3 struct.\nfunc (e Either3[T1, T2, T3]) Arg1() (T1, bool) {\n\tif e.IsArg1() {\n\t\treturn e.arg1, true\n\t}\n\treturn empty[T1](), false\n}\n\n// Arg2 returns the second argument of a Either3 struct.\nfunc (e Either3[T1, T2, T3]) Arg2() (T2, bool) {\n\tif e.IsArg2() {\n\t\treturn e.arg2, true\n\t}\n\treturn empty[T2](), false\n}\n\n// Arg3 returns the third argument of a Either3 struct.\nfunc (e Either3[T1, T2, T3]) Arg3() (T3, bool) {\n\tif e.IsArg3() {\n\t\treturn e.arg3, true\n\t}\n\treturn empty[T3](), false\n}\n\n// MustArg1 returns the first argument of a Either3 struct or panics.\nfunc (e Either3[T1, T2, T3]) MustArg1() T1 {\n\tif !e.IsArg1() {\n\t\tpanic(either3MissingArg1)\n\t}\n\treturn e.arg1\n}\n\n// MustArg2 returns the second argument of a Either3 struct or panics.\nfunc (e Either3[T1, T2, T3]) MustArg2() T2 {\n\tif !e.IsArg2() {\n\t\tpanic(either3MissingArg2)\n\t}\n\treturn e.arg2\n}\n\n// MustArg3 returns the third argument of a Either3 struct or panics.\nfunc (e Either3[T1, T2, T3]) MustArg3() T3 {\n\tif !e.IsArg3() {\n\t\tpanic(either3MissingArg3)\n\t}\n\treturn e.arg3\n}\n\n// Unpack returns all values\nfunc (e Either3[T1, T2, T3]) Unpack() (T1, T2, T3) {\n\treturn e.arg1, e.arg2, e.arg3\n}\n\n// Arg1OrElse returns the first argument of a Either3 struct or fallback.\nfunc (e Either3[T1, T2, T3]) Arg1OrElse(fallback T1) T1 {\n\tif e.IsArg1() {\n\t\treturn e.arg1\n\t}\n\treturn fallback\n}\n\n// Arg2OrElse returns the second argument of a Either3 struct or fallback.\nfunc (e Either3[T1, T2, T3]) Arg2OrElse(fallback T2) T2 {\n\tif e.IsArg2() {\n\t\treturn e.arg2\n\t}\n\treturn fallback\n}\n\n// Arg3OrElse returns the third argument of a Either3 struct or fallback.\nfunc (e Either3[T1, T2, T3]) Arg3OrElse(fallback T3) T3 {\n\tif e.IsArg3() {\n\t\treturn e.arg3\n\t}\n\treturn fallback\n}\n\n// Arg1OrEmpty returns the first argument of a Either3 struct or empty value.\nfunc (e Either3[T1, T2, T3]) Arg1OrEmpty() T1 {\n\tif e.IsArg1() {\n\t\treturn e.arg1\n\t}\n\treturn empty[T1]()\n}\n\n// Arg2OrEmpty returns the second argument of a Either3 struct or empty value.\nfunc (e Either3[T1, T2, T3]) Arg2OrEmpty() T2 {\n\tif e.IsArg2() {\n\t\treturn e.arg2\n\t}\n\treturn empty[T2]()\n}\n\n// Arg3OrEmpty returns the third argument of a Either3 struct or empty value.\nfunc (e Either3[T1, T2, T3]) Arg3OrEmpty() T3 {\n\tif e.IsArg3() {\n\t\treturn e.arg3\n\t}\n\treturn empty[T3]()\n}\n\n// ForEach executes the given side-effecting function, depending of the argument set.\nfunc (e Either3[T1, T2, T3]) ForEach(arg1Cb func(T1), arg2Cb func(T2), arg3Cb func(T3)) {\n\tswitch e.argId {\n\tcase either3ArgId1:\n\t\targ1Cb(e.arg1)\n\tcase either3ArgId2:\n\t\targ2Cb(e.arg2)\n\tcase either3ArgId3:\n\t\targ3Cb(e.arg3)\n\t}\n}\n\n// Match executes the given function, depending of the argument set, and returns result.\nfunc (e Either3[T1, T2, T3]) Match(\n\tonArg1 func(T1) Either3[T1, T2, T3],\n\tonArg2 func(T2) Either3[T1, T2, T3],\n\tonArg3 func(T3) Either3[T1, T2, T3]) Either3[T1, T2, T3] {\n\n\tswitch e.argId {\n\tcase either3ArgId1:\n\t\treturn onArg1(e.arg1)\n\tcase either3ArgId2:\n\t\treturn onArg2(e.arg2)\n\tcase either3ArgId3:\n\t\treturn onArg3(e.arg3)\n\t}\n\n\tpanic(either3InvalidArgumentId)\n}\n\n// MapArg1 executes the given function, if Either3 use the first argument, and returns result.\nfunc (e Either3[T1, T2, T3]) MapArg1(mapper func(T1) Either3[T1, T2, T3]) Either3[T1, T2, T3] {\n\tif e.IsArg1() {\n\t\treturn mapper(e.arg1)\n\t}\n\n\treturn e\n}\n\n// MapArg2 executes the given function, if Either3 use the second argument, and returns result.\nfunc (e Either3[T1, T2, T3]) MapArg2(mapper func(T2) Either3[T1, T2, T3]) Either3[T1, T2, T3] {\n\tif e.IsArg2() {\n\t\treturn mapper(e.arg2)\n\t}\n\n\treturn e\n}\n\n// MapArg3 executes the given function, if Either3 use the third argument, and returns result.\nfunc (e Either3[T1, T2, T3]) MapArg3(mapper func(T3) Either3[T1, T2, T3]) Either3[T1, T2, T3] {\n\tif e.IsArg3() {\n\t\treturn mapper(e.arg3)\n\t}\n\n\treturn e\n}\n"
        },
        {
          "name": "either3_test.go",
          "type": "blob",
          "size": 8.1962890625,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewEither3(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\tis.Equal(Either3[int, bool, float64]{argId: either3ArgId1, arg1: 42}, either3Arg1)\n\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\tis.Equal(Either3[int, bool, float64]{argId: either3ArgId2, arg2: true}, either3Arg2)\n\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\tis.Equal(Either3[int, bool, float64]{argId: either3ArgId3, arg3: 1.2}, either3Arg3)\n}\n\nfunc TestEither3IsArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\n\tis.True(either3Arg1.IsArg1())\n\tis.False(either3Arg1.IsArg2())\n\tis.False(either3Arg1.IsArg3())\n\n\tis.False(either3Arg2.IsArg1())\n\tis.True(either3Arg2.IsArg2())\n\tis.False(either3Arg2.IsArg3())\n\n\tis.False(either3Arg3.IsArg1())\n\tis.False(either3Arg3.IsArg2())\n\tis.True(either3Arg3.IsArg3())\n}\n\nfunc TestEither3GetArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\n\tresult1_1, ok1_1 := either3Arg1.Arg1()\n\t_, ok1_2 := either3Arg1.Arg2()\n\t_, ok1_3 := either3Arg1.Arg3()\n\n\tis.Equal(42, result1_1)\n\tis.True(ok1_1)\n\tis.False(ok1_2)\n\tis.False(ok1_3)\n\n\t_, ok2_1 := either3Arg2.Arg1()\n\tresult2, ok2_2 := either3Arg2.Arg2()\n\t_, ok2_3 := either3Arg2.Arg3()\n\n\tis.Equal(true, result2)\n\tis.False(ok2_1)\n\tis.True(ok2_2)\n\tis.False(ok2_3)\n\n\t_, ok3_1 := either3Arg3.Arg1()\n\t_, ok3_2 := either3Arg3.Arg2()\n\tresult3, ok3_3 := either3Arg3.Arg3()\n\n\tis.Equal(1.2, result3)\n\tis.False(ok3_1)\n\tis.False(ok3_2)\n\tis.True(ok3_3)\n}\n\nfunc TestEither3MustArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\n\tis.NotPanics(func() {\n\t\tis.Equal(42, either3Arg1.MustArg1())\n\t})\n\tis.Panics(func() {\n\t\teither3Arg1.MustArg2()\n\t})\n\tis.Panics(func() {\n\t\teither3Arg1.MustArg3()\n\t})\n\n\tis.Panics(func() {\n\t\teither3Arg2.MustArg1()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(true, either3Arg2.MustArg2())\n\t})\n\tis.Panics(func() {\n\t\teither3Arg2.MustArg3()\n\t})\n\n\tis.Panics(func() {\n\t\teither3Arg3.MustArg1()\n\t})\n\tis.Panics(func() {\n\t\teither3Arg3.MustArg2()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(1.2, either3Arg3.MustArg3())\n\t})\n}\n\nfunc TestEither3Unpack(t *testing.T) {\n\tis := assert.New(t)\n\n\teither := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg1, either3Arg2, either3Arg3 := either.Unpack()\n\n\tis.Equal(42, either3Arg1)\n\tis.Equal(false, either3Arg2)\n\tis.Equal(float64(0), either3Arg3)\n}\n\nfunc TestEither3GetOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\n\tis.Equal(42, either3Arg1.Arg1OrElse(21))\n\tis.Equal(false, either3Arg1.Arg2OrElse(false))\n\tis.Equal(2.1, either3Arg1.Arg3OrElse(2.1))\n\n\tis.Equal(21, either3Arg2.Arg1OrElse(21))\n\tis.Equal(true, either3Arg2.Arg2OrElse(false))\n\tis.Equal(2.1, either3Arg2.Arg3OrElse(2.1))\n\n\tis.Equal(21, either3Arg3.Arg1OrElse(21))\n\tis.Equal(false, either3Arg3.Arg2OrElse(false))\n\tis.Equal(1.2, either3Arg3.Arg3OrElse(2.1))\n}\n\nfunc TestEither3GetOrEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\n\tis.Equal(42, either3Arg1.Arg1OrEmpty())\n\tis.Equal(false, either3Arg1.Arg2OrEmpty())\n\tis.Equal(0.0, either3Arg1.Arg3OrEmpty())\n\n\tis.Equal(0, either3Arg2.Arg1OrEmpty())\n\tis.Equal(true, either3Arg2.Arg2OrEmpty())\n\tis.Equal(0.0, either3Arg2.Arg3OrEmpty())\n\n\tis.Equal(0, either3Arg3.Arg1OrEmpty())\n\tis.Equal(false, either3Arg3.Arg2OrEmpty())\n\tis.Equal(1.2, either3Arg3.Arg3OrEmpty())\n}\n\nfunc TestEither3ForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\tNewEither3Arg1[int, bool, float64](42).ForEach(func(v1 int) {\n\t\tis.Equal(42, v1)\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither3Arg2[int, bool, float64](true).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Equal(true, v2)\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither3Arg3[int, bool, float64](1.2).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Equal(1.2, v3)\n\t})\n}\n\nfunc TestEither3Match(t *testing.T) {\n\tis := assert.New(t)\n\n\te1 := NewEither3Arg1[int, bool, float64](42).Match(func(v1 int) Either3[int, bool, float64] {\n\t\tis.Equal(42, v1)\n\t\treturn NewEither3Arg1[int, bool, float64](21)\n\t}, func(v2 bool) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg2[int, bool, float64](false)\n\t}, func(v3 float64) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg3[int, bool, float64](2.1)\n\t})\n\n\tis.Equal(NewEither3Arg1[int, bool, float64](21), e1)\n\n\te2 := NewEither3Arg2[int, bool, float64](true).Match(func(v1 int) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg1[int, bool, float64](21)\n\t}, func(v2 bool) Either3[int, bool, float64] {\n\t\tis.Equal(true, v2)\n\t\treturn NewEither3Arg2[int, bool, float64](false)\n\t}, func(v3 float64) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg3[int, bool, float64](2.1)\n\t})\n\n\tis.Equal(NewEither3Arg2[int, bool, float64](false), e2)\n\n\te3 := NewEither3Arg3[int, bool, float64](1.2).Match(func(v1 int) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg1[int, bool, float64](21)\n\t}, func(v2 bool) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg2[int, bool, float64](false)\n\t}, func(v3 float64) Either3[int, bool, float64] {\n\t\tis.Equal(1.2, v3)\n\t\treturn NewEither3Arg3[int, bool, float64](2.1)\n\t})\n\n\tis.Equal(NewEither3Arg3[int, bool, float64](2.1), e3)\n}\n\nfunc TestEither3MapArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither3Arg1 := NewEither3Arg1[int, bool, float64](42)\n\teither3Arg2 := NewEither3Arg2[int, bool, float64](true)\n\teither3Arg3 := NewEither3Arg3[int, bool, float64](1.2)\n\n\tresult1_1 := either3Arg1.MapArg1(func(v int) Either3[int, bool, float64] {\n\t\tis.Equal(42, v)\n\t\treturn NewEither3Arg1[int, bool, float64](21)\n\t})\n\tis.Equal(NewEither3Arg1[int, bool, float64](21), result1_1)\n\n\tresult1_2 := either3Arg1.MapArg2(func(v bool) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg2[int, bool, float64](false)\n\t})\n\tis.Equal(either3Arg1, result1_2)\n\n\tresult1_3 := either3Arg1.MapArg3(func(v float64) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg3[int, bool, float64](2.1)\n\t})\n\tis.Equal(either3Arg1, result1_3)\n\n\tresult2_1 := either3Arg2.MapArg1(func(v int) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg1[int, bool, float64](21)\n\t})\n\tis.Equal(either3Arg2, result2_1)\n\n\tresult2_2 := either3Arg2.MapArg2(func(v bool) Either3[int, bool, float64] {\n\t\tis.Equal(true, v)\n\t\treturn NewEither3Arg2[int, bool, float64](false)\n\t})\n\tis.Equal(NewEither3Arg2[int, bool, float64](false), result2_2)\n\n\tresult2_3 := either3Arg2.MapArg3(func(v float64) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg3[int, bool, float64](2.1)\n\t})\n\tis.Equal(either3Arg2, result2_3)\n\n\tresult3_1 := either3Arg3.MapArg1(func(v int) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg3[int, bool, float64](21)\n\t})\n\tis.Equal(either3Arg3, result3_1)\n\n\tresult3_2 := either3Arg3.MapArg2(func(v bool) Either3[int, bool, float64] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither3Arg2[int, bool, float64](false)\n\t})\n\tis.Equal(either3Arg3, result3_2)\n\n\tresult3_3 := either3Arg3.MapArg3(func(v float64) Either3[int, bool, float64] {\n\t\tis.Equal(1.2, v)\n\t\treturn NewEither3Arg3[int, bool, float64](2.1)\n\t})\n\tis.Equal(NewEither3Arg3[int, bool, float64](2.1), result3_3)\n}\n"
        },
        {
          "name": "either4.go",
          "type": "blob",
          "size": 7.2236328125,
          "content": "package mo\n\nimport \"fmt\"\n\nconst (\n\teither4ArgId1 = iota\n\teither4ArgId2\n\teither4ArgId3\n\teither4ArgId4\n)\n\nvar (\n\teither4InvalidArgumentId = fmt.Errorf(\"either4 argument should be between 1 and 4\")\n\teither4MissingArg1       = fmt.Errorf(\"either4 doesn't contain expected argument 1\")\n\teither4MissingArg2       = fmt.Errorf(\"either4 doesn't contain expected argument 2\")\n\teither4MissingArg3       = fmt.Errorf(\"either4 doesn't contain expected argument 3\")\n\teither4MissingArg4       = fmt.Errorf(\"either4 doesn't contain expected argument 4\")\n)\n\n// NewEither4Arg1 builds the first argument of the Either4 struct.\nfunc NewEither4Arg1[T1 any, T2 any, T3 any, T4 any](value T1) Either4[T1, T2, T3, T4] {\n\treturn Either4[T1, T2, T3, T4]{\n\t\targId: either4ArgId1,\n\t\targ1:  value,\n\t}\n}\n\n// NewEither4Arg2 builds the second argument of the Either4 struct.\nfunc NewEither4Arg2[T1 any, T2 any, T3 any, T4 any](value T2) Either4[T1, T2, T3, T4] {\n\treturn Either4[T1, T2, T3, T4]{\n\t\targId: either4ArgId2,\n\t\targ2:  value,\n\t}\n}\n\n// NewEither4Arg3 builds the third argument of the Either4 struct.\nfunc NewEither4Arg3[T1 any, T2 any, T3 any, T4 any](value T3) Either4[T1, T2, T3, T4] {\n\treturn Either4[T1, T2, T3, T4]{\n\t\targId: either4ArgId3,\n\t\targ3:  value,\n\t}\n}\n\n// NewEither4Arg4 builds the fourth argument of the Either4 struct.\nfunc NewEither4Arg4[T1 any, T2 any, T3 any, T4 any](value T4) Either4[T1, T2, T3, T4] {\n\treturn Either4[T1, T2, T3, T4]{\n\t\targId: either4ArgId4,\n\t\targ4:  value,\n\t}\n}\n\n// Either4 respresents a value of 4 possible types.\n// An instance of Either4 is an instance of either T1, T2, T3 or T4.\ntype Either4[T1 any, T2 any, T3 any, T4 any] struct {\n\targId int8\n\n\targ1 T1\n\targ2 T2\n\targ3 T3\n\targ4 T4\n}\n\n// IsArg1 returns true if Either4 uses the first argument.\nfunc (e Either4[T1, T2, T3, T4]) IsArg1() bool {\n\treturn e.argId == either4ArgId1\n}\n\n// IsArg2 returns true if Either4 uses the second argument.\nfunc (e Either4[T1, T2, T3, T4]) IsArg2() bool {\n\treturn e.argId == either4ArgId2\n}\n\n// IsArg3 returns true if Either4 uses the third argument.\nfunc (e Either4[T1, T2, T3, T4]) IsArg3() bool {\n\treturn e.argId == either4ArgId3\n}\n\n// IsArg4 returns true if Either4 uses the fourth argument.\nfunc (e Either4[T1, T2, T3, T4]) IsArg4() bool {\n\treturn e.argId == either4ArgId4\n}\n\n// Arg1 returns the first argument of a Either4 struct.\nfunc (e Either4[T1, T2, T3, T4]) Arg1() (T1, bool) {\n\tif e.IsArg1() {\n\t\treturn e.arg1, true\n\t}\n\treturn empty[T1](), false\n}\n\n// Arg2 returns the second argument of a Either4 struct.\nfunc (e Either4[T1, T2, T3, T4]) Arg2() (T2, bool) {\n\tif e.IsArg2() {\n\t\treturn e.arg2, true\n\t}\n\treturn empty[T2](), false\n}\n\n// Arg3 returns the third argument of a Either4 struct.\nfunc (e Either4[T1, T2, T3, T4]) Arg3() (T3, bool) {\n\tif e.IsArg3() {\n\t\treturn e.arg3, true\n\t}\n\treturn empty[T3](), false\n}\n\n// Arg4 returns the fourth argument of a Either4 struct.\nfunc (e Either4[T1, T2, T3, T4]) Arg4() (T4, bool) {\n\tif e.IsArg4() {\n\t\treturn e.arg4, true\n\t}\n\treturn empty[T4](), false\n}\n\n// MustArg1 returns the first argument of a Either4 struct or panics.\nfunc (e Either4[T1, T2, T3, T4]) MustArg1() T1 {\n\tif !e.IsArg1() {\n\t\tpanic(either4MissingArg1)\n\t}\n\treturn e.arg1\n}\n\n// MustArg2 returns the second argument of a Either4 struct or panics.\nfunc (e Either4[T1, T2, T3, T4]) MustArg2() T2 {\n\tif !e.IsArg2() {\n\t\tpanic(either4MissingArg2)\n\t}\n\treturn e.arg2\n}\n\n// MustArg3 returns the third argument of a Either4 struct or panics.\nfunc (e Either4[T1, T2, T3, T4]) MustArg3() T3 {\n\tif !e.IsArg3() {\n\t\tpanic(either4MissingArg3)\n\t}\n\treturn e.arg3\n}\n\n// MustArg4 returns the fourth argument of a Either4 struct or panics.\nfunc (e Either4[T1, T2, T3, T4]) MustArg4() T4 {\n\tif !e.IsArg4() {\n\t\tpanic(either4MissingArg4)\n\t}\n\treturn e.arg4\n}\n\n// Unpack returns all values\nfunc (e Either4[T1, T2, T3, T4]) Unpack() (T1, T2, T3, T4) {\n\treturn e.arg1, e.arg2, e.arg3, e.arg4\n}\n\n// Arg1OrElse returns the first argument of a Either4 struct or fallback.\nfunc (e Either4[T1, T2, T3, T4]) Arg1OrElse(fallback T1) T1 {\n\tif e.IsArg1() {\n\t\treturn e.arg1\n\t}\n\treturn fallback\n}\n\n// Arg2OrElse returns the second argument of a Either4 struct or fallback.\nfunc (e Either4[T1, T2, T3, T4]) Arg2OrElse(fallback T2) T2 {\n\tif e.IsArg2() {\n\t\treturn e.arg2\n\t}\n\treturn fallback\n}\n\n// Arg3OrElse returns the third argument of a Either4 struct or fallback.\nfunc (e Either4[T1, T2, T3, T4]) Arg3OrElse(fallback T3) T3 {\n\tif e.IsArg3() {\n\t\treturn e.arg3\n\t}\n\treturn fallback\n}\n\n// Arg4OrElse returns the fourth argument of a Either4 struct or fallback.\nfunc (e Either4[T1, T2, T3, T4]) Arg4OrElse(fallback T4) T4 {\n\tif e.IsArg4() {\n\t\treturn e.arg4\n\t}\n\treturn fallback\n}\n\n// Arg1OrEmpty returns the first argument of a Either4 struct or empty value.\nfunc (e Either4[T1, T2, T3, T4]) Arg1OrEmpty() T1 {\n\tif e.IsArg1() {\n\t\treturn e.arg1\n\t}\n\treturn empty[T1]()\n}\n\n// Arg2OrEmpty returns the second argument of a Either4 struct or empty value.\nfunc (e Either4[T1, T2, T3, T4]) Arg2OrEmpty() T2 {\n\tif e.IsArg2() {\n\t\treturn e.arg2\n\t}\n\treturn empty[T2]()\n}\n\n// Arg3OrEmpty returns the third argument of a Either4 struct or empty value.\nfunc (e Either4[T1, T2, T3, T4]) Arg3OrEmpty() T3 {\n\tif e.IsArg3() {\n\t\treturn e.arg3\n\t}\n\treturn empty[T3]()\n}\n\n// Arg4OrEmpty returns the fourth argument of a Either4 struct or empty value.\nfunc (e Either4[T1, T2, T3, T4]) Arg4OrEmpty() T4 {\n\tif e.IsArg4() {\n\t\treturn e.arg4\n\t}\n\treturn empty[T4]()\n}\n\n// ForEach executes the given side-effecting function, depending of the argument set.\nfunc (e Either4[T1, T2, T3, T4]) ForEach(arg1Cb func(T1), arg2Cb func(T2), arg3Cb func(T3), arg4Cb func(T4)) {\n\tswitch e.argId {\n\tcase either4ArgId1:\n\t\targ1Cb(e.arg1)\n\tcase either4ArgId2:\n\t\targ2Cb(e.arg2)\n\tcase either4ArgId3:\n\t\targ3Cb(e.arg3)\n\tcase either4ArgId4:\n\t\targ4Cb(e.arg4)\n\t}\n}\n\n// Match executes the given function, depending of the argument set, and returns result.\nfunc (e Either4[T1, T2, T3, T4]) Match(\n\tonArg1 func(T1) Either4[T1, T2, T3, T4],\n\tonArg2 func(T2) Either4[T1, T2, T3, T4],\n\tonArg3 func(T3) Either4[T1, T2, T3, T4],\n\tonArg4 func(T4) Either4[T1, T2, T3, T4]) Either4[T1, T2, T3, T4] {\n\n\tswitch e.argId {\n\tcase either4ArgId1:\n\t\treturn onArg1(e.arg1)\n\tcase either4ArgId2:\n\t\treturn onArg2(e.arg2)\n\tcase either4ArgId3:\n\t\treturn onArg3(e.arg3)\n\tcase either4ArgId4:\n\t\treturn onArg4(e.arg4)\n\t}\n\n\tpanic(either4InvalidArgumentId)\n}\n\n// MapArg1 executes the given function, if Either4 use the first argument, and returns result.\nfunc (e Either4[T1, T2, T3, T4]) MapArg1(mapper func(T1) Either4[T1, T2, T3, T4]) Either4[T1, T2, T3, T4] {\n\tif e.IsArg1() {\n\t\treturn mapper(e.arg1)\n\t}\n\n\treturn e\n}\n\n// MapArg2 executes the given function, if Either4 use the second argument, and returns result.\nfunc (e Either4[T1, T2, T3, T4]) MapArg2(mapper func(T2) Either4[T1, T2, T3, T4]) Either4[T1, T2, T3, T4] {\n\tif e.IsArg2() {\n\t\treturn mapper(e.arg2)\n\t}\n\n\treturn e\n}\n\n// MapArg3 executes the given function, if Either4 use the third argument, and returns result.\nfunc (e Either4[T1, T2, T3, T4]) MapArg3(mapper func(T3) Either4[T1, T2, T3, T4]) Either4[T1, T2, T3, T4] {\n\tif e.IsArg3() {\n\t\treturn mapper(e.arg3)\n\t}\n\n\treturn e\n}\n\n// MapArg4 executes the given function, if Either4 use the fourth argument, and returns result.\nfunc (e Either4[T1, T2, T3, T4]) MapArg4(mapper func(T4) Either4[T1, T2, T3, T4]) Either4[T1, T2, T3, T4] {\n\tif e.IsArg4() {\n\t\treturn mapper(e.arg4)\n\t}\n\n\treturn e\n}\n"
        },
        {
          "name": "either4_test.go",
          "type": "blob",
          "size": 14.0263671875,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewEither4(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\tis.Equal(Either4[int, bool, float64, string]{argId: either4ArgId1, arg1: 42}, either4Arg1)\n\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\tis.Equal(Either4[int, bool, float64, string]{argId: either4ArgId2, arg2: true}, either4Arg2)\n\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\tis.Equal(Either4[int, bool, float64, string]{argId: either4ArgId3, arg3: 1.2}, either4Arg3)\n\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\tis.Equal(Either4[int, bool, float64, string]{argId: either4ArgId4, arg4: \"Hello\"}, either4Arg4)\n}\n\nfunc TestEither4IsArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\n\tis.True(either4Arg1.IsArg1())\n\tis.False(either4Arg1.IsArg2())\n\tis.False(either4Arg1.IsArg3())\n\tis.False(either4Arg1.IsArg4())\n\n\tis.False(either4Arg2.IsArg1())\n\tis.True(either4Arg2.IsArg2())\n\tis.False(either4Arg2.IsArg3())\n\tis.False(either4Arg2.IsArg4())\n\n\tis.False(either4Arg3.IsArg1())\n\tis.False(either4Arg3.IsArg2())\n\tis.True(either4Arg3.IsArg3())\n\tis.False(either4Arg3.IsArg4())\n\n\tis.False(either4Arg4.IsArg1())\n\tis.False(either4Arg4.IsArg2())\n\tis.False(either4Arg4.IsArg3())\n\tis.True(either4Arg4.IsArg4())\n}\n\nfunc TestEither4GetArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\n\tresult1_1, ok1_1 := either4Arg1.Arg1()\n\t_, ok1_2 := either4Arg1.Arg2()\n\t_, ok1_3 := either4Arg1.Arg3()\n\t_, ok1_4 := either4Arg1.Arg4()\n\n\tis.Equal(42, result1_1)\n\tis.True(ok1_1)\n\tis.False(ok1_2)\n\tis.False(ok1_3)\n\tis.False(ok1_4)\n\n\t_, ok2_1 := either4Arg2.Arg1()\n\tresult2, ok2_2 := either4Arg2.Arg2()\n\t_, ok2_3 := either4Arg2.Arg3()\n\t_, ok2_4 := either4Arg2.Arg4()\n\n\tis.Equal(true, result2)\n\tis.False(ok2_1)\n\tis.True(ok2_2)\n\tis.False(ok2_3)\n\tis.False(ok2_4)\n\n\t_, ok3_1 := either4Arg3.Arg1()\n\t_, ok3_2 := either4Arg3.Arg2()\n\tresult3, ok3_3 := either4Arg3.Arg3()\n\t_, ok3_4 := either4Arg3.Arg4()\n\n\tis.Equal(1.2, result3)\n\tis.False(ok3_1)\n\tis.False(ok3_2)\n\tis.True(ok3_3)\n\tis.False(ok3_4)\n\n\t_, ok4_1 := either4Arg4.Arg1()\n\t_, ok4_2 := either4Arg4.Arg2()\n\t_, ok4_3 := either4Arg4.Arg3()\n\tresult4, ok4_4 := either4Arg4.Arg4()\n\n\tis.Equal(\"Hello\", result4)\n\tis.False(ok4_1)\n\tis.False(ok4_2)\n\tis.False(ok4_3)\n\tis.True(ok4_4)\n}\n\nfunc TestEither4MustArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\n\tis.NotPanics(func() {\n\t\tis.Equal(42, either4Arg1.MustArg1())\n\t})\n\tis.Panics(func() {\n\t\teither4Arg1.MustArg2()\n\t})\n\tis.Panics(func() {\n\t\teither4Arg1.MustArg3()\n\t})\n\tis.Panics(func() {\n\t\teither4Arg1.MustArg4()\n\t})\n\n\tis.Panics(func() {\n\t\teither4Arg2.MustArg1()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(true, either4Arg2.MustArg2())\n\t})\n\tis.Panics(func() {\n\t\teither4Arg2.MustArg3()\n\t})\n\tis.Panics(func() {\n\t\teither4Arg2.MustArg4()\n\t})\n\n\tis.Panics(func() {\n\t\teither4Arg3.MustArg1()\n\t})\n\tis.Panics(func() {\n\t\teither4Arg3.MustArg2()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(1.2, either4Arg3.MustArg3())\n\t})\n\tis.Panics(func() {\n\t\teither4Arg3.MustArg4()\n\t})\n\n\tis.Panics(func() {\n\t\teither4Arg4.MustArg1()\n\t})\n\tis.Panics(func() {\n\t\teither4Arg4.MustArg2()\n\t})\n\tis.Panics(func() {\n\t\teither4Arg4.MustArg3()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(\"Hello\", either4Arg4.MustArg4())\n\t})\n}\n\nfunc TestEither4Unpack(t *testing.T) {\n\tis := assert.New(t)\n\n\teither := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg1, either4Arg2, either4Arg3, either4Arg4 := either.Unpack()\n\n\tis.Equal(42, either4Arg1)\n\tis.Equal(false, either4Arg2)\n\tis.Equal(float64(0), either4Arg3)\n\tis.Equal(\"\", either4Arg4)\n}\n\nfunc TestEither4GetOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\n\tis.Equal(42, either4Arg1.Arg1OrElse(21))\n\tis.Equal(false, either4Arg1.Arg2OrElse(false))\n\tis.Equal(2.1, either4Arg1.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either4Arg1.Arg4OrElse(\"Bye\"))\n\n\tis.Equal(21, either4Arg2.Arg1OrElse(21))\n\tis.Equal(true, either4Arg2.Arg2OrElse(false))\n\tis.Equal(2.1, either4Arg2.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either4Arg2.Arg4OrElse(\"Bye\"))\n\n\tis.Equal(21, either4Arg3.Arg1OrElse(21))\n\tis.Equal(false, either4Arg3.Arg2OrElse(false))\n\tis.Equal(1.2, either4Arg3.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either4Arg3.Arg4OrElse(\"Bye\"))\n\n\tis.Equal(21, either4Arg4.Arg1OrElse(21))\n\tis.Equal(false, either4Arg4.Arg2OrElse(false))\n\tis.Equal(2.1, either4Arg4.Arg3OrElse(2.1))\n\tis.Equal(\"Hello\", either4Arg4.Arg4OrElse(\"Bye\"))\n}\n\nfunc TestEither4GetOrEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\n\tis.Equal(42, either4Arg1.Arg1OrEmpty())\n\tis.Equal(false, either4Arg1.Arg2OrEmpty())\n\tis.Equal(0.0, either4Arg1.Arg3OrEmpty())\n\tis.Equal(\"\", either4Arg1.Arg4OrEmpty())\n\n\tis.Equal(0, either4Arg2.Arg1OrEmpty())\n\tis.Equal(true, either4Arg2.Arg2OrEmpty())\n\tis.Equal(0.0, either4Arg2.Arg3OrEmpty())\n\tis.Equal(\"\", either4Arg2.Arg4OrEmpty())\n\n\tis.Equal(0, either4Arg3.Arg1OrEmpty())\n\tis.Equal(false, either4Arg3.Arg2OrEmpty())\n\tis.Equal(1.2, either4Arg3.Arg3OrEmpty())\n\tis.Equal(\"\", either4Arg3.Arg4OrEmpty())\n\n\tis.Equal(0, either4Arg4.Arg1OrEmpty())\n\tis.Equal(false, either4Arg4.Arg2OrEmpty())\n\tis.Equal(0.0, either4Arg4.Arg3OrEmpty())\n\tis.Equal(\"Hello\", either4Arg4.Arg4OrEmpty())\n}\n\nfunc TestEither4ForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\tNewEither4Arg1[int, bool, float64, string](42).ForEach(func(v1 int) {\n\t\tis.Equal(42, v1)\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither4Arg2[int, bool, float64, string](true).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Equal(true, v2)\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither4Arg3[int, bool, float64, string](1.2).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Equal(1.2, v3)\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither4Arg4[int, bool, float64, string](\"Hello\").ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Equal(\"Hello\", v4)\n\t})\n}\n\nfunc TestEither4Match(t *testing.T) {\n\tis := assert.New(t)\n\n\te1 := NewEither4Arg1[int, bool, float64, string](42).Match(func(v1 int) Either4[int, bool, float64, string] {\n\t\tis.Equal(42, v1)\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t}, func(v2 bool) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t}, func(v3 float64) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t}, func(v4 string) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\n\tis.Equal(NewEither4Arg1[int, bool, float64, string](21), e1)\n\n\te2 := NewEither4Arg2[int, bool, float64, string](true).Match(func(v1 int) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t}, func(v2 bool) Either4[int, bool, float64, string] {\n\t\tis.Equal(true, v2)\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t}, func(v3 float64) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t}, func(v4 string) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\n\tis.Equal(NewEither4Arg2[int, bool, float64, string](false), e2)\n\n\te3 := NewEither4Arg3[int, bool, float64, string](1.2).Match(func(v1 int) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t}, func(v2 bool) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t}, func(v3 float64) Either4[int, bool, float64, string] {\n\t\tis.Equal(1.2, v3)\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t}, func(v4 string) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\n\tis.Equal(NewEither4Arg3[int, bool, float64, string](2.1), e3)\n\n\te4 := NewEither4Arg4[int, bool, float64, string](\"Hello\").Match(func(v1 int) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t}, func(v2 bool) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t}, func(v3 float64) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t}, func(v4 string) Either4[int, bool, float64, string] {\n\t\tis.Equal(\"Hello\", v4)\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\n\tis.Equal(NewEither4Arg4[int, bool, float64, string](\"Bye\"), e4)\n}\n\nfunc TestEither4MapArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither4Arg1 := NewEither4Arg1[int, bool, float64, string](42)\n\teither4Arg2 := NewEither4Arg2[int, bool, float64, string](true)\n\teither4Arg3 := NewEither4Arg3[int, bool, float64, string](1.2)\n\teither4Arg4 := NewEither4Arg4[int, bool, float64, string](\"Hello\")\n\n\tresult1_1 := either4Arg1.MapArg1(func(v int) Either4[int, bool, float64, string] {\n\t\tis.Equal(42, v)\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t})\n\tis.Equal(NewEither4Arg1[int, bool, float64, string](21), result1_1)\n\n\tresult1_2 := either4Arg1.MapArg2(func(v bool) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t})\n\tis.Equal(either4Arg1, result1_2)\n\n\tresult1_3 := either4Arg1.MapArg3(func(v float64) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t})\n\tis.Equal(either4Arg1, result1_3)\n\n\tresult1_4 := either4Arg1.MapArg4(func(v string) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\tis.Equal(either4Arg1, result1_4)\n\n\tresult2_1 := either4Arg2.MapArg1(func(v int) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t})\n\tis.Equal(either4Arg2, result2_1)\n\n\tresult2_2 := either4Arg2.MapArg2(func(v bool) Either4[int, bool, float64, string] {\n\t\tis.Equal(true, v)\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t})\n\tis.Equal(NewEither4Arg2[int, bool, float64, string](false), result2_2)\n\n\tresult2_3 := either4Arg2.MapArg3(func(v float64) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t})\n\tis.Equal(either4Arg2, result2_3)\n\n\tresult2_4 := either4Arg2.MapArg4(func(v string) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\tis.Equal(either4Arg2, result2_4)\n\n\tresult3_1 := either4Arg3.MapArg1(func(v int) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](21)\n\t})\n\tis.Equal(either4Arg3, result3_1)\n\n\tresult3_2 := either4Arg3.MapArg2(func(v bool) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t})\n\tis.Equal(either4Arg3, result3_2)\n\n\tresult3_3 := either4Arg3.MapArg3(func(v float64) Either4[int, bool, float64, string] {\n\t\tis.Equal(1.2, v)\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t})\n\tis.Equal(NewEither4Arg3[int, bool, float64, string](2.1), result3_3)\n\n\tresult3_4 := either4Arg3.MapArg4(func(v string) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\tis.Equal(either4Arg3, result3_4)\n\n\tresult4_1 := either4Arg4.MapArg1(func(v int) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg1[int, bool, float64, string](21)\n\t})\n\tis.Equal(either4Arg4, result4_1)\n\n\tresult4_2 := either4Arg4.MapArg2(func(v bool) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg2[int, bool, float64, string](false)\n\t})\n\tis.Equal(either4Arg4, result4_2)\n\n\tresult4_3 := either4Arg4.MapArg3(func(v float64) Either4[int, bool, float64, string] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither4Arg3[int, bool, float64, string](2.1)\n\t})\n\tis.Equal(either4Arg4, result4_3)\n\n\tresult4_4 := either4Arg4.MapArg4(func(v string) Either4[int, bool, float64, string] {\n\t\tis.Equal(\"Hello\", v)\n\t\treturn NewEither4Arg4[int, bool, float64, string](\"Bye\")\n\t})\n\tis.Equal(NewEither4Arg4[int, bool, float64, string](\"Bye\"), result4_4)\n}\n"
        },
        {
          "name": "either5.go",
          "type": "blob",
          "size": 9.1123046875,
          "content": "package mo\n\nimport \"fmt\"\n\nconst (\n\teither5ArgId1 = iota\n\teither5ArgId2\n\teither5ArgId3\n\teither5ArgId4\n\teither5ArgId5\n)\n\nvar (\n\teither5InvalidArgumentId = fmt.Errorf(\"either5 argument should be between 1 and 5\")\n\teither5MissingArg1       = fmt.Errorf(\"either5 doesn't contain expected argument 1\")\n\teither5MissingArg2       = fmt.Errorf(\"either5 doesn't contain expected argument 2\")\n\teither5MissingArg3       = fmt.Errorf(\"either5 doesn't contain expected argument 3\")\n\teither5MissingArg4       = fmt.Errorf(\"either5 doesn't contain expected argument 4\")\n\teither5MissingArg5       = fmt.Errorf(\"either5 doesn't contain expected argument 5\")\n)\n\n// NewEither5Arg1 builds the first argument of the Either5 struct.\nfunc NewEither5Arg1[T1 any, T2 any, T3 any, T4 any, T5 any](value T1) Either5[T1, T2, T3, T4, T5] {\n\treturn Either5[T1, T2, T3, T4, T5]{\n\t\targId: either5ArgId1,\n\t\targ1:  value,\n\t}\n}\n\n// NewEither5Arg2 builds the second argument of the Either5 struct.\nfunc NewEither5Arg2[T1 any, T2 any, T3 any, T4 any, T5 any](value T2) Either5[T1, T2, T3, T4, T5] {\n\treturn Either5[T1, T2, T3, T4, T5]{\n\t\targId: either5ArgId2,\n\t\targ2:  value,\n\t}\n}\n\n// NewEither5Arg3 builds the third argument of the Either5 struct.\nfunc NewEither5Arg3[T1 any, T2 any, T3 any, T4 any, T5 any](value T3) Either5[T1, T2, T3, T4, T5] {\n\treturn Either5[T1, T2, T3, T4, T5]{\n\t\targId: either5ArgId3,\n\t\targ3:  value,\n\t}\n}\n\n// NewEither5Arg4 builds the fourth argument of the Either5 struct.\nfunc NewEither5Arg4[T1 any, T2 any, T3 any, T4 any, T5 any](value T4) Either5[T1, T2, T3, T4, T5] {\n\treturn Either5[T1, T2, T3, T4, T5]{\n\t\targId: either5ArgId4,\n\t\targ4:  value,\n\t}\n}\n\n// NewEither5Arg5 builds the fith argument of the Either5 struct.\nfunc NewEither5Arg5[T1 any, T2 any, T3 any, T4 any, T5 any](value T5) Either5[T1, T2, T3, T4, T5] {\n\treturn Either5[T1, T2, T3, T4, T5]{\n\t\targId: either5ArgId5,\n\t\targ5:  value,\n\t}\n}\n\n// Either5 respresents a value of 5 possible types.\n// An instance of Either5 is an instance of either T1, T2, T3, T4, or T5.\ntype Either5[T1 any, T2 any, T3 any, T4 any, T5 any] struct {\n\targId int8\n\n\targ1 T1\n\targ2 T2\n\targ3 T3\n\targ4 T4\n\targ5 T5\n}\n\n// IsArg1 returns true if Either5 uses the first argument.\nfunc (e Either5[T1, T2, T3, T4, T5]) IsArg1() bool {\n\treturn e.argId == either5ArgId1\n}\n\n// IsArg2 returns true if Either5 uses the second argument.\nfunc (e Either5[T1, T2, T3, T4, T5]) IsArg2() bool {\n\treturn e.argId == either5ArgId2\n}\n\n// IsArg3 returns true if Either5 uses the third argument.\nfunc (e Either5[T1, T2, T3, T4, T5]) IsArg3() bool {\n\treturn e.argId == either5ArgId3\n}\n\n// IsArg4 returns true if Either5 uses the fourth argument.\nfunc (e Either5[T1, T2, T3, T4, T5]) IsArg4() bool {\n\treturn e.argId == either5ArgId4\n}\n\n// IsArg5 returns true if Either5 uses the fith argument.\nfunc (e Either5[T1, T2, T3, T4, T5]) IsArg5() bool {\n\treturn e.argId == either5ArgId5\n}\n\n// Arg1 returns the first argument of a Either5 struct.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg1() (T1, bool) {\n\tif e.IsArg1() {\n\t\treturn e.arg1, true\n\t}\n\treturn empty[T1](), false\n}\n\n// Arg2 returns the second argument of a Either5 struct.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg2() (T2, bool) {\n\tif e.IsArg2() {\n\t\treturn e.arg2, true\n\t}\n\treturn empty[T2](), false\n}\n\n// Arg3 returns the third argument of a Either5 struct.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg3() (T3, bool) {\n\tif e.IsArg3() {\n\t\treturn e.arg3, true\n\t}\n\treturn empty[T3](), false\n}\n\n// Arg4 returns the fourth argument of a Either5 struct.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg4() (T4, bool) {\n\tif e.IsArg4() {\n\t\treturn e.arg4, true\n\t}\n\treturn empty[T4](), false\n}\n\n// Arg5 returns the fith argument of a Either5 struct.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg5() (T5, bool) {\n\tif e.IsArg5() {\n\t\treturn e.arg5, true\n\t}\n\treturn empty[T5](), false\n}\n\n// MustArg1 returns the first argument of a Either5 struct or panics.\nfunc (e Either5[T1, T2, T3, T4, T5]) MustArg1() T1 {\n\tif !e.IsArg1() {\n\t\tpanic(either5MissingArg1)\n\t}\n\treturn e.arg1\n}\n\n// MustArg2 returns the second argument of a Either5 struct or panics.\nfunc (e Either5[T1, T2, T3, T4, T5]) MustArg2() T2 {\n\tif !e.IsArg2() {\n\t\tpanic(either5MissingArg2)\n\t}\n\treturn e.arg2\n}\n\n// MustArg3 returns the third argument of a Either5 struct or panics.\nfunc (e Either5[T1, T2, T3, T4, T5]) MustArg3() T3 {\n\tif !e.IsArg3() {\n\t\tpanic(either5MissingArg3)\n\t}\n\treturn e.arg3\n}\n\n// MustArg4 returns the fourth argument of a Either5 struct or panics.\nfunc (e Either5[T1, T2, T3, T4, T5]) MustArg4() T4 {\n\tif !e.IsArg4() {\n\t\tpanic(either5MissingArg4)\n\t}\n\treturn e.arg4\n}\n\n// MustArg5 returns the fith argument of a Either5 struct or panics.\nfunc (e Either5[T1, T2, T3, T4, T5]) MustArg5() T5 {\n\tif !e.IsArg5() {\n\t\tpanic(either5MissingArg5)\n\t}\n\treturn e.arg5\n}\n\n// Unpack returns all values\nfunc (e Either5[T1, T2, T3, T4, T5]) Unpack() (T1, T2, T3, T4, T5) {\n\treturn e.arg1, e.arg2, e.arg3, e.arg4, e.arg5\n}\n\n// Arg1OrElse returns the first argument of a Either5 struct or fallback.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg1OrElse(fallback T1) T1 {\n\tif e.IsArg1() {\n\t\treturn e.arg1\n\t}\n\treturn fallback\n}\n\n// Arg2OrElse returns the second argument of a Either5 struct or fallback.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg2OrElse(fallback T2) T2 {\n\tif e.IsArg2() {\n\t\treturn e.arg2\n\t}\n\treturn fallback\n}\n\n// Arg3OrElse returns the third argument of a Either5 struct or fallback.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg3OrElse(fallback T3) T3 {\n\tif e.IsArg3() {\n\t\treturn e.arg3\n\t}\n\treturn fallback\n}\n\n// Arg4OrElse returns the fourth argument of a Either5 struct or fallback.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg4OrElse(fallback T4) T4 {\n\tif e.IsArg4() {\n\t\treturn e.arg4\n\t}\n\treturn fallback\n}\n\n// Arg5OrElse returns the fith argument of a Either5 struct or fallback.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg5OrElse(fallback T5) T5 {\n\tif e.IsArg5() {\n\t\treturn e.arg5\n\t}\n\treturn fallback\n}\n\n// Arg1OrEmpty returns the first argument of a Either5 struct or empty value.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg1OrEmpty() T1 {\n\tif e.IsArg1() {\n\t\treturn e.arg1\n\t}\n\treturn empty[T1]()\n}\n\n// Arg2OrEmpty returns the second argument of a Either5 struct or empty value.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg2OrEmpty() T2 {\n\tif e.IsArg2() {\n\t\treturn e.arg2\n\t}\n\treturn empty[T2]()\n}\n\n// Arg3OrEmpty returns the third argument of a Either5 struct or empty value.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg3OrEmpty() T3 {\n\tif e.IsArg3() {\n\t\treturn e.arg3\n\t}\n\treturn empty[T3]()\n}\n\n// Arg4OrEmpty returns the fourth argument of a Either5 struct or empty value.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg4OrEmpty() T4 {\n\tif e.IsArg4() {\n\t\treturn e.arg4\n\t}\n\treturn empty[T4]()\n}\n\n// Arg5OrEmpty returns the fifth argument of a Either5 struct or empty value.\nfunc (e Either5[T1, T2, T3, T4, T5]) Arg5OrEmpty() T5 {\n\tif e.IsArg5() {\n\t\treturn e.arg5\n\t}\n\treturn empty[T5]()\n}\n\n// ForEach executes the given side-effecting function, depending of the argument set.\nfunc (e Either5[T1, T2, T3, T4, T5]) ForEach(arg1Cb func(T1), arg2Cb func(T2), arg3Cb func(T3), arg4Cb func(T4), arg5Cb func(T5)) {\n\tswitch e.argId {\n\tcase either5ArgId1:\n\t\targ1Cb(e.arg1)\n\tcase either5ArgId2:\n\t\targ2Cb(e.arg2)\n\tcase either5ArgId3:\n\t\targ3Cb(e.arg3)\n\tcase either5ArgId4:\n\t\targ4Cb(e.arg4)\n\tcase either5ArgId5:\n\t\targ5Cb(e.arg5)\n\t}\n}\n\n// Match executes the given function, depending of the argument set, and returns result.\nfunc (e Either5[T1, T2, T3, T4, T5]) Match(\n\tonArg1 func(T1) Either5[T1, T2, T3, T4, T5],\n\tonArg2 func(T2) Either5[T1, T2, T3, T4, T5],\n\tonArg3 func(T3) Either5[T1, T2, T3, T4, T5],\n\tonArg4 func(T4) Either5[T1, T2, T3, T4, T5],\n\tonArg5 func(T5) Either5[T1, T2, T3, T4, T5]) Either5[T1, T2, T3, T4, T5] {\n\n\tswitch e.argId {\n\tcase either5ArgId1:\n\t\treturn onArg1(e.arg1)\n\tcase either5ArgId2:\n\t\treturn onArg2(e.arg2)\n\tcase either5ArgId3:\n\t\treturn onArg3(e.arg3)\n\tcase either5ArgId4:\n\t\treturn onArg4(e.arg4)\n\tcase either5ArgId5:\n\t\treturn onArg5(e.arg5)\n\t}\n\n\tpanic(either5InvalidArgumentId)\n}\n\n// MapArg1 executes the given function, if Either5 use the first argument, and returns result.\nfunc (e Either5[T1, T2, T3, T4, T5]) MapArg1(mapper func(T1) Either5[T1, T2, T3, T4, T5]) Either5[T1, T2, T3, T4, T5] {\n\tif e.IsArg1() {\n\t\treturn mapper(e.arg1)\n\t}\n\n\treturn e\n}\n\n// MapArg2 executes the given function, if Either5 use the second argument, and returns result.\nfunc (e Either5[T1, T2, T3, T4, T5]) MapArg2(mapper func(T2) Either5[T1, T2, T3, T4, T5]) Either5[T1, T2, T3, T4, T5] {\n\tif e.IsArg2() {\n\t\treturn mapper(e.arg2)\n\t}\n\n\treturn e\n}\n\n// MapArg3 executes the given function, if Either5 use the third argument, and returns result.\nfunc (e Either5[T1, T2, T3, T4, T5]) MapArg3(mapper func(T3) Either5[T1, T2, T3, T4, T5]) Either5[T1, T2, T3, T4, T5] {\n\tif e.IsArg3() {\n\t\treturn mapper(e.arg3)\n\t}\n\n\treturn e\n}\n\n// MapArg4 executes the given function, if Either5 use the fourth argument, and returns result.\nfunc (e Either5[T1, T2, T3, T4, T5]) MapArg4(mapper func(T4) Either5[T1, T2, T3, T4, T5]) Either5[T1, T2, T3, T4, T5] {\n\tif e.IsArg4() {\n\t\treturn mapper(e.arg4)\n\t}\n\n\treturn e\n}\n\n// MapArg5 executes the given function, if Either5 use the fith argument, and returns result.\nfunc (e Either5[T1, T2, T3, T4, T5]) MapArg5(mapper func(T5) Either5[T1, T2, T3, T4, T5]) Either5[T1, T2, T3, T4, T5] {\n\tif e.IsArg5() {\n\t\treturn mapper(e.arg5)\n\t}\n\n\treturn e\n}\n"
        },
        {
          "name": "either5_example_test.go",
          "type": "blob",
          "size": 2.8837890625,
          "content": "package mo\n\nimport \"fmt\"\n\nfunc ExampleNewEither5Arg1() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\tresult1 := either5Arg1.Arg1OrElse(21)\n\tresult2 := either5Arg1.Arg4OrElse(\"Bye\")\n\n\tfmt.Println(result1, result2)\n\t// Output: 42 Bye\n}\n\nfunc ExampleEither5_IsArg1() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\tresult1 := either5Arg1.IsArg1()\n\tresult2 := either5Arg1.IsArg4()\n\n\tfmt.Println(result1, result2)\n\t// Output: true false\n}\n\nfunc ExampleEither5_Arg1() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\tresult1, ok1 := either5Arg1.Arg1()\n\tresult2, ok2 := either5Arg1.Arg3()\n\n\tfmt.Println(result1, ok1)\n\tfmt.Println(result2, ok2)\n\t// Output:\n\t// 42 true\n\t// 0 false\n}\n\nfunc ExampleEither5_MustArg1() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\n\t// result = either5Arg1.MustArg4()\n\t// Panics\n\n\tresult := either5Arg1.MustArg1()\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleEither5_Unpack() {\n\teither5 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\ta, b, c, d, e := either5.Unpack()\n\n\tfmt.Println(a, b, c, d, e)\n\t// Output: 42 false 0  0\n}\n\nfunc ExampleEither5_Arg1OrElse() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\tresult1 := either5Arg1.Arg1OrElse(21)\n\tresult2 := either5Arg1.Arg4OrElse(\"Bye\")\n\n\tfmt.Println(result1, result2)\n\t// Output: 42 Bye\n}\n\nfunc ExampleEither5_Arg1OrEmpty() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\tresult1 := either5Arg1.Arg1OrEmpty()\n\tresult2 := either5Arg1.Arg2OrEmpty()\n\n\tfmt.Println(result1, result2)\n\t// Output: 42 false\n}\n\nfunc ExampleEither5_Match() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\n\tresult1 := either5Arg1.Match(func(v int) Either5[int, bool, float64, string, byte] {\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t}, func(v bool) Either5[int, bool, float64, string, byte] {\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t}, func(v float64) Either5[int, bool, float64, string, byte] {\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t}, func(v string) Either5[int, bool, float64, string, byte] {\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t}, func(v byte) Either5[int, bool, float64, string, byte] {\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\n\tfmt.Println(result1.MustArg1())\n\t// Output: 21\n}\n\nfunc ExampleEither5_MapArg1() {\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\n\tresult1 := either5Arg1.MapArg1(\n\t\tfunc(v int) Either5[int, bool, float64, string, byte] {\n\t\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t\t},\n\t)\n\n\tresult2 := either5Arg1.MapArg4(\n\t\tfunc(v string) Either5[int, bool, float64, string, byte] {\n\t\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t\t},\n\t)\n\n\tfmt.Println(result1.MustArg1(), result2.MustArg1())\n\t// Output: 21 42\n}\n"
        },
        {
          "name": "either5_test.go",
          "type": "blob",
          "size": 21.390625,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewEither5(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\tis.Equal(Either5[int, bool, float64, string, byte]{argId: either5ArgId1, arg1: 42}, either5Arg1)\n\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\tis.Equal(Either5[int, bool, float64, string, byte]{argId: either5ArgId2, arg2: true}, either5Arg2)\n\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\tis.Equal(Either5[int, bool, float64, string, byte]{argId: either5ArgId3, arg3: 1.2}, either5Arg3)\n\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\tis.Equal(Either5[int, bool, float64, string, byte]{argId: either5ArgId4, arg4: \"Hello\"}, either5Arg4)\n\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\tis.Equal(Either5[int, bool, float64, string, byte]{argId: either5ArgId5, arg5: 5}, either5Arg5)\n}\n\nfunc TestEither5IsArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\n\tis.True(either5Arg1.IsArg1())\n\tis.False(either5Arg1.IsArg2())\n\tis.False(either5Arg1.IsArg3())\n\tis.False(either5Arg1.IsArg4())\n\tis.False(either5Arg1.IsArg5())\n\n\tis.False(either5Arg2.IsArg1())\n\tis.True(either5Arg2.IsArg2())\n\tis.False(either5Arg2.IsArg3())\n\tis.False(either5Arg2.IsArg4())\n\tis.False(either5Arg2.IsArg5())\n\n\tis.False(either5Arg3.IsArg1())\n\tis.False(either5Arg3.IsArg2())\n\tis.True(either5Arg3.IsArg3())\n\tis.False(either5Arg3.IsArg4())\n\tis.False(either5Arg3.IsArg5())\n\n\tis.False(either5Arg4.IsArg1())\n\tis.False(either5Arg4.IsArg2())\n\tis.False(either5Arg4.IsArg3())\n\tis.True(either5Arg4.IsArg4())\n\tis.False(either5Arg4.IsArg5())\n\n\tis.False(either5Arg5.IsArg1())\n\tis.False(either5Arg5.IsArg2())\n\tis.False(either5Arg5.IsArg3())\n\tis.False(either5Arg5.IsArg4())\n\tis.True(either5Arg5.IsArg5())\n}\n\nfunc TestEither5GetArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\n\tresult1_1, ok1_1 := either5Arg1.Arg1()\n\t_, ok1_2 := either5Arg1.Arg2()\n\t_, ok1_3 := either5Arg1.Arg3()\n\t_, ok1_4 := either5Arg1.Arg4()\n\t_, ok1_5 := either5Arg1.Arg5()\n\n\tis.Equal(42, result1_1)\n\tis.True(ok1_1)\n\tis.False(ok1_2)\n\tis.False(ok1_3)\n\tis.False(ok1_4)\n\tis.False(ok1_5)\n\n\t_, ok2_1 := either5Arg2.Arg1()\n\tresult2, ok2_2 := either5Arg2.Arg2()\n\t_, ok2_3 := either5Arg2.Arg3()\n\t_, ok2_4 := either5Arg2.Arg4()\n\t_, ok2_5 := either5Arg2.Arg5()\n\n\tis.Equal(true, result2)\n\tis.False(ok2_1)\n\tis.True(ok2_2)\n\tis.False(ok2_3)\n\tis.False(ok2_4)\n\tis.False(ok2_5)\n\n\t_, ok3_1 := either5Arg3.Arg1()\n\t_, ok3_2 := either5Arg3.Arg2()\n\tresult3, ok3_3 := either5Arg3.Arg3()\n\t_, ok3_4 := either5Arg3.Arg4()\n\t_, ok3_5 := either5Arg3.Arg5()\n\n\tis.Equal(1.2, result3)\n\tis.False(ok3_1)\n\tis.False(ok3_2)\n\tis.True(ok3_3)\n\tis.False(ok3_4)\n\tis.False(ok3_5)\n\n\t_, ok4_1 := either5Arg4.Arg1()\n\t_, ok4_2 := either5Arg4.Arg2()\n\t_, ok4_3 := either5Arg4.Arg3()\n\tresult4, ok4_4 := either5Arg4.Arg4()\n\t_, ok4_5 := either5Arg4.Arg5()\n\n\tis.Equal(\"Hello\", result4)\n\tis.False(ok4_1)\n\tis.False(ok4_2)\n\tis.False(ok4_3)\n\tis.True(ok4_4)\n\tis.False(ok4_5)\n\n\t_, ok5_1 := either5Arg5.Arg1()\n\t_, ok5_2 := either5Arg5.Arg2()\n\t_, ok5_3 := either5Arg5.Arg3()\n\t_, ok5_4 := either5Arg5.Arg4()\n\tresult5, ok5_5 := either5Arg5.Arg5()\n\n\tis.Equal(byte(5), result5)\n\tis.False(ok5_1)\n\tis.False(ok5_2)\n\tis.False(ok5_3)\n\tis.False(ok5_4)\n\tis.True(ok5_5)\n}\n\nfunc TestEither5MustArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\n\tis.NotPanics(func() {\n\t\tis.Equal(42, either5Arg1.MustArg1())\n\t})\n\tis.Panics(func() {\n\t\teither5Arg1.MustArg2()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg1.MustArg3()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg1.MustArg4()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg1.MustArg5()\n\t})\n\n\tis.Panics(func() {\n\t\teither5Arg2.MustArg1()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(true, either5Arg2.MustArg2())\n\t})\n\tis.Panics(func() {\n\t\teither5Arg2.MustArg3()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg2.MustArg4()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg2.MustArg5()\n\t})\n\n\tis.Panics(func() {\n\t\teither5Arg3.MustArg1()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg3.MustArg2()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(1.2, either5Arg3.MustArg3())\n\t})\n\tis.Panics(func() {\n\t\teither5Arg3.MustArg4()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg3.MustArg5()\n\t})\n\n\tis.Panics(func() {\n\t\teither5Arg4.MustArg1()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg4.MustArg2()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg4.MustArg3()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(\"Hello\", either5Arg4.MustArg4())\n\t})\n\tis.Panics(func() {\n\t\teither5Arg4.MustArg5()\n\t})\n\n\tis.Panics(func() {\n\t\teither5Arg5.MustArg1()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg5.MustArg2()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg5.MustArg3()\n\t})\n\tis.Panics(func() {\n\t\teither5Arg5.MustArg4()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(byte(5), either5Arg5.MustArg5())\n\t})\n}\n\nfunc TestEither5Unpack(t *testing.T) {\n\tis := assert.New(t)\n\n\teither := NewEither5Arg1[int, bool, float64, string, string](42)\n\teither5Arg1, either5Arg2, either5Arg3, either5Arg4, either5Arg5 := either.Unpack()\n\n\tis.Equal(42, either5Arg1)\n\tis.Equal(false, either5Arg2)\n\tis.Equal(float64(0), either5Arg3)\n\tis.Equal(\"\", either5Arg4)\n\tis.Equal(\"\", either5Arg5)\n}\n\nfunc TestEither5GetOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\n\tis.Equal(42, either5Arg1.Arg1OrElse(21))\n\tis.Equal(false, either5Arg1.Arg2OrElse(false))\n\tis.Equal(2.1, either5Arg1.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either5Arg1.Arg4OrElse(\"Bye\"))\n\tis.Equal(byte(10), either5Arg1.Arg5OrElse(10))\n\n\tis.Equal(21, either5Arg2.Arg1OrElse(21))\n\tis.Equal(true, either5Arg2.Arg2OrElse(false))\n\tis.Equal(2.1, either5Arg2.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either5Arg2.Arg4OrElse(\"Bye\"))\n\tis.Equal(byte(10), either5Arg2.Arg5OrElse(10))\n\n\tis.Equal(21, either5Arg3.Arg1OrElse(21))\n\tis.Equal(false, either5Arg3.Arg2OrElse(false))\n\tis.Equal(1.2, either5Arg3.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either5Arg3.Arg4OrElse(\"Bye\"))\n\tis.Equal(byte(10), either5Arg3.Arg5OrElse(10))\n\n\tis.Equal(21, either5Arg4.Arg1OrElse(21))\n\tis.Equal(false, either5Arg4.Arg2OrElse(false))\n\tis.Equal(2.1, either5Arg4.Arg3OrElse(2.1))\n\tis.Equal(\"Hello\", either5Arg4.Arg4OrElse(\"Bye\"))\n\tis.Equal(byte(10), either5Arg4.Arg5OrElse(10))\n\n\tis.Equal(21, either5Arg5.Arg1OrElse(21))\n\tis.Equal(false, either5Arg5.Arg2OrElse(false))\n\tis.Equal(2.1, either5Arg5.Arg3OrElse(2.1))\n\tis.Equal(\"Bye\", either5Arg5.Arg4OrElse(\"Bye\"))\n\tis.Equal(byte(5), either5Arg5.Arg5OrElse(10))\n}\n\nfunc TestEither5GetOrEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\n\tis.Equal(42, either5Arg1.Arg1OrEmpty())\n\tis.Equal(false, either5Arg1.Arg2OrEmpty())\n\tis.Equal(0.0, either5Arg1.Arg3OrEmpty())\n\tis.Equal(\"\", either5Arg1.Arg4OrEmpty())\n\tis.Equal(byte(0), either5Arg1.Arg5OrEmpty())\n\n\tis.Equal(0, either5Arg2.Arg1OrEmpty())\n\tis.Equal(true, either5Arg2.Arg2OrEmpty())\n\tis.Equal(0.0, either5Arg2.Arg3OrEmpty())\n\tis.Equal(\"\", either5Arg2.Arg4OrEmpty())\n\tis.Equal(byte(0), either5Arg2.Arg5OrEmpty())\n\n\tis.Equal(0, either5Arg3.Arg1OrEmpty())\n\tis.Equal(false, either5Arg3.Arg2OrEmpty())\n\tis.Equal(1.2, either5Arg3.Arg3OrEmpty())\n\tis.Equal(\"\", either5Arg3.Arg4OrEmpty())\n\tis.Equal(byte(0), either5Arg3.Arg5OrEmpty())\n\n\tis.Equal(0, either5Arg4.Arg1OrEmpty())\n\tis.Equal(false, either5Arg4.Arg2OrEmpty())\n\tis.Equal(0.0, either5Arg4.Arg3OrEmpty())\n\tis.Equal(\"Hello\", either5Arg4.Arg4OrEmpty())\n\tis.Equal(byte(0), either5Arg4.Arg5OrEmpty())\n\n\tis.Equal(0, either5Arg5.Arg1OrEmpty())\n\tis.Equal(false, either5Arg5.Arg2OrEmpty())\n\tis.Equal(0.0, either5Arg5.Arg3OrEmpty())\n\tis.Equal(\"\", either5Arg5.Arg4OrEmpty())\n\tis.Equal(byte(5), either5Arg5.Arg5OrEmpty())\n}\n\nfunc TestEither5ForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\tNewEither5Arg1[int, bool, float64, string, byte](42).ForEach(func(v1 int) {\n\t\tis.Equal(42, v1)\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v5 byte) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither5Arg2[int, bool, float64, string, byte](true).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Equal(true, v2)\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v5 byte) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither5Arg3[int, bool, float64, string, byte](1.2).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Equal(1.2, v3)\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v5 byte) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither5Arg4[int, bool, float64, string, byte](\"Hello\").ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Equal(\"Hello\", v4)\n\t}, func(v5 byte) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tNewEither5Arg5[int, bool, float64, string, byte](5).ForEach(func(v1 int) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v2 bool) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v3 float64) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v4 string) {\n\t\tis.Fail(\"should not enter here\")\n\t}, func(v5 byte) {\n\t\tis.Equal(byte(5), v5)\n\t})\n}\n\nfunc TestEither5Match(t *testing.T) {\n\tis := assert.New(t)\n\n\te1 := NewEither5Arg1[int, bool, float64, string, byte](42).Match(func(v1 int) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(42, v1)\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t}, func(v2 bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t}, func(v3 float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t}, func(v4 string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t}, func(v5 byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\n\tis.Equal(NewEither5Arg1[int, bool, float64, string, byte](21), e1)\n\n\te2 := NewEither5Arg2[int, bool, float64, string, byte](true).Match(func(v1 int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t}, func(v2 bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(true, v2)\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t}, func(v3 float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t}, func(v4 string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t}, func(v5 byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\n\tis.Equal(NewEither5Arg2[int, bool, float64, string, byte](false), e2)\n\n\te3 := NewEither5Arg3[int, bool, float64, string, byte](1.2).Match(func(v1 int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t}, func(v2 bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t}, func(v3 float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(1.2, v3)\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t}, func(v4 string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t}, func(v5 byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\n\tis.Equal(NewEither5Arg3[int, bool, float64, string, byte](2.1), e3)\n\n\te4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\").Match(func(v1 int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t}, func(v2 bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t}, func(v3 float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t}, func(v4 string) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(\"Hello\", v4)\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t}, func(v5 byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\n\tis.Equal(NewEither5Arg4[int, bool, float64, string, byte](\"Bye\"), e4)\n\n\te5 := NewEither5Arg5[int, bool, float64, string, byte](5).Match(func(v1 int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t}, func(v2 bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t}, func(v3 float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t}, func(v4 string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t}, func(v5 byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(byte(5), v5)\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\n\tis.Equal(NewEither5Arg5[int, bool, float64, string, byte](10), e5)\n}\n\nfunc TestEither5MapArg(t *testing.T) {\n\tis := assert.New(t)\n\n\teither5Arg1 := NewEither5Arg1[int, bool, float64, string, byte](42)\n\teither5Arg2 := NewEither5Arg2[int, bool, float64, string, byte](true)\n\teither5Arg3 := NewEither5Arg3[int, bool, float64, string, byte](1.2)\n\teither5Arg4 := NewEither5Arg4[int, bool, float64, string, byte](\"Hello\")\n\teither5Arg5 := NewEither5Arg5[int, bool, float64, string, byte](5)\n\n\tresult1_1 := either5Arg1.MapArg1(func(v int) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(42, v)\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t})\n\tis.Equal(NewEither5Arg1[int, bool, float64, string, byte](21), result1_1)\n\n\tresult1_2 := either5Arg1.MapArg2(func(v bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t})\n\tis.Equal(either5Arg1, result1_2)\n\n\tresult1_3 := either5Arg1.MapArg3(func(v float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t})\n\tis.Equal(either5Arg1, result1_3)\n\n\tresult1_4 := either5Arg1.MapArg4(func(v string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t})\n\tis.Equal(either5Arg1, result1_4)\n\n\tresult1_5 := either5Arg1.MapArg5(func(v byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\tis.Equal(either5Arg1, result1_5)\n\n\tresult2_1 := either5Arg2.MapArg1(func(v int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t})\n\tis.Equal(either5Arg2, result2_1)\n\n\tresult2_2 := either5Arg2.MapArg2(func(v bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(true, v)\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t})\n\tis.Equal(NewEither5Arg2[int, bool, float64, string, byte](false), result2_2)\n\n\tresult2_3 := either5Arg2.MapArg3(func(v float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t})\n\tis.Equal(either5Arg2, result2_3)\n\n\tresult2_4 := either5Arg2.MapArg4(func(v string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t})\n\tis.Equal(either5Arg2, result2_4)\n\n\tresult2_5 := either5Arg2.MapArg5(func(v byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\tis.Equal(either5Arg2, result2_5)\n\n\tresult3_1 := either5Arg3.MapArg1(func(v int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](21)\n\t})\n\tis.Equal(either5Arg3, result3_1)\n\n\tresult3_2 := either5Arg3.MapArg2(func(v bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t})\n\tis.Equal(either5Arg3, result3_2)\n\n\tresult3_3 := either5Arg3.MapArg3(func(v float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(1.2, v)\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t})\n\tis.Equal(NewEither5Arg3[int, bool, float64, string, byte](2.1), result3_3)\n\n\tresult3_4 := either5Arg3.MapArg4(func(v string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t})\n\tis.Equal(either5Arg3, result3_4)\n\n\tresult3_5 := either5Arg3.MapArg5(func(v byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\tis.Equal(either5Arg3, result3_5)\n\n\tresult4_1 := either5Arg4.MapArg1(func(v int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t})\n\tis.Equal(either5Arg4, result4_1)\n\n\tresult4_2 := either5Arg4.MapArg2(func(v bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t})\n\tis.Equal(either5Arg4, result4_2)\n\n\tresult4_3 := either5Arg4.MapArg3(func(v float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t})\n\tis.Equal(either5Arg4, result4_3)\n\n\tresult4_4 := either5Arg4.MapArg4(func(v string) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(\"Hello\", v)\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t})\n\tis.Equal(NewEither5Arg4[int, bool, float64, string, byte](\"Bye\"), result4_4)\n\n\tresult4_5 := either5Arg4.MapArg5(func(v byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\tis.Equal(either5Arg4, result4_5)\n\n\tresult5_1 := either5Arg5.MapArg1(func(v int) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg1[int, bool, float64, string, byte](21)\n\t})\n\tis.Equal(either5Arg5, result5_1)\n\n\tresult5_2 := either5Arg5.MapArg2(func(v bool) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg2[int, bool, float64, string, byte](false)\n\t})\n\tis.Equal(either5Arg5, result5_2)\n\n\tresult5_3 := either5Arg5.MapArg3(func(v float64) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg3[int, bool, float64, string, byte](2.1)\n\t})\n\tis.Equal(either5Arg5, result5_3)\n\n\tresult5_4 := either5Arg5.MapArg4(func(v string) Either5[int, bool, float64, string, byte] {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn NewEither5Arg4[int, bool, float64, string, byte](\"Bye\")\n\t})\n\tis.Equal(either5Arg5, result5_4)\n\n\tresult5_5 := either5Arg5.MapArg5(func(v byte) Either5[int, bool, float64, string, byte] {\n\t\tis.Equal(byte(5), v)\n\t\treturn NewEither5Arg5[int, bool, float64, string, byte](10)\n\t})\n\tis.Equal(NewEither5Arg5[int, bool, float64, string, byte](10), result5_5)\n}\n"
        },
        {
          "name": "either_example_test.go",
          "type": "blob",
          "size": 6.4580078125,
          "content": "package mo\n\nimport \"fmt\"\n\nfunc ExampleLeft() {\n\tleft := Left[string, int](\"hello\")\n\tresult1 := left.LeftOrElse(\"world\")\n\tresult2 := left.RightOrElse(1234)\n\n\tfmt.Println(result1, result2)\n\t// Output: hello 1234\n}\n\nfunc ExampleRight() {\n\tright := Right[string, int](42)\n\tresult1 := right.LeftOrElse(\"world\")\n\tresult2 := right.RightOrElse(1234)\n\n\tfmt.Println(result1, result2)\n\t// Output: world 42\n}\n\nfunc ExampleEither_Unpack_left() {\n\teither := Left[string, int](\"42\")\n\tleft, right := either.Unpack()\n\n\tfmt.Println(left, right)\n\t// Output: 42 0\n}\n\nfunc ExampleEither_Unpack_right() {\n\teither := Right[string, int](42)\n\tleft, right := either.Unpack()\n\n\tfmt.Println(left, right)\n\t// Output: 42\n}\n\nfunc ExampleEither_IsLeft_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.IsLeft()\n\n\tfmt.Println(result)\n\t// Output: true\n}\n\nfunc ExampleEither_IsLeft_right() {\n\tright := Right[string, int](42)\n\tresult := right.IsLeft()\n\n\tfmt.Println(result)\n\t// Output: false\n}\n\nfunc ExampleEither_IsRight_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.IsRight()\n\n\tfmt.Println(result)\n\t// Output: false\n}\n\nfunc ExampleEither_IsRight_right() {\n\tright := Right[string, int](42)\n\tresult := right.IsRight()\n\n\tfmt.Println(result)\n\t// Output: true\n}\n\nfunc ExampleEither_Left_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult, ok := left.Left()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// hello\n\t// true\n}\n\nfunc ExampleEither_Left_right() {\n\tright := Right[string, int](42)\n\tresult, ok := right.Left()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// false\n}\n\nfunc ExampleEither_Right_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult, ok := left.Right()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// 0\n\t// false\n}\n\nfunc ExampleEither_Right_right() {\n\tright := Right[string, int](42)\n\tresult, ok := right.Right()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// 42\n\t// true\n}\n\nfunc ExampleEither_MustLeft_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.MustLeft()\n\n\tfmt.Println(result)\n\t// Output: hello\n}\n\n// func ExampleEither_MustLeft_right() {\n// \tright := Right[string, int](42)\n// \tresult := right.MustLeft()\n\n// \tfmt.Println(result)\n// \t// Output: panics\n// }\n\n// func ExampleEither_MustRight_left() {\n// \tleft := Left[string, int](\"hello\")\n// \tresult := left.MustRight()\n\n// \tfmt.Println(result)\n// \t// Output: panics\n// }\n\nfunc ExampleEither_MustRight_right() {\n\tright := Right[string, int](42)\n\tresult := right.MustRight()\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleEither_LeftOrElse_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.LeftOrElse(\"world\")\n\n\tfmt.Println(result)\n\t// Output: hello\n}\n\nfunc ExampleEither_LeftOrElse_right() {\n\tright := Right[string, int](42)\n\tresult := right.LeftOrElse(\"world\")\n\n\tfmt.Println(result)\n\t// Output: world\n}\n\nfunc ExampleEither_RightOrElse_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.RightOrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleEither_RightOrElse_right() {\n\tright := Right[string, int](42)\n\tresult := right.RightOrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleEither_LeftOrEmpty_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.LeftOrEmpty()\n\n\tfmt.Println(result)\n\t// Output: hello\n}\n\nfunc ExampleEither_LeftOrEmpty_right() {\n\tright := Right[string, int](42)\n\tresult := right.LeftOrEmpty()\n\n\tfmt.Println(result)\n\t// Output:\n}\n\nfunc ExampleEither_RightOrEmpty_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.RightOrEmpty()\n\n\tfmt.Println(result)\n\t// Output: 0\n}\n\nfunc ExampleEither_RightOrEmpty_right() {\n\tright := Right[string, int](42)\n\tresult := right.RightOrEmpty()\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleEither_Swap_left() {\n\tleft := Left[string, int](\"hello\")\n\tright := left.Swap()\n\tresult1, ok1 := right.Left()\n\tresult2, ok2 := right.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// 0\n\t// false\n\t// hello\n\t// true\n}\n\nfunc ExampleEither_Swap_right() {\n\tright := Right[string, int](42)\n\tleft := right.Swap()\n\tresult1, ok1 := left.Left()\n\tresult2, ok2 := left.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// 42\n\t// true\n\t//\n\t// false\n}\n\nfunc ExampleEither_Match_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.Match(\n\t\tfunc(s string) Either[string, int] {\n\t\t\treturn Right[string, int](1234)\n\t\t},\n\t\tfunc(i int) Either[string, int] {\n\t\t\treturn Right[string, int](i * 42)\n\t\t},\n\t)\n\tresult1, ok1 := result.Left()\n\tresult2, ok2 := result.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// false\n\t// 1234\n\t// true\n}\nfunc ExampleEither_Match_right() {\n\tright := Right[string, int](42)\n\tresult := right.Match(\n\t\tfunc(s string) Either[string, int] {\n\t\t\treturn Left[string, int](\"world\")\n\t\t},\n\t\tfunc(i int) Either[string, int] {\n\t\t\treturn Left[string, int](\"foobar\")\n\t\t},\n\t)\n\tresult1, ok1 := result.Left()\n\tresult2, ok2 := result.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// foobar\n\t// true\n\t// 0\n\t// false\n}\n\nfunc ExampleEither_MapLeft_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.MapLeft(\n\t\tfunc(s string) Either[string, int] {\n\t\t\treturn Right[string, int](1234)\n\t\t},\n\t)\n\tresult1, ok1 := result.Left()\n\tresult2, ok2 := result.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// false\n\t// 1234\n\t// true\n}\nfunc ExampleEither_MapLeft_right() {\n\tright := Right[string, int](42)\n\tresult := right.MapLeft(\n\t\tfunc(s string) Either[string, int] {\n\t\t\treturn Left[string, int](\"world\")\n\t\t},\n\t)\n\tresult1, ok1 := result.Left()\n\tresult2, ok2 := result.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// false\n\t// 42\n\t// true\n}\n\nfunc ExampleEither_MapRight_left() {\n\tleft := Left[string, int](\"hello\")\n\tresult := left.MapRight(\n\t\tfunc(i int) Either[string, int] {\n\t\t\treturn Right[string, int](1234)\n\t\t},\n\t)\n\tresult1, ok1 := result.Left()\n\tresult2, ok2 := result.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// hello\n\t// true\n\t// 0\n\t// false\n}\nfunc ExampleEither_MapRight_right() {\n\tright := Right[string, int](42)\n\tresult := right.MapRight(\n\t\tfunc(i int) Either[string, int] {\n\t\t\treturn Right[string, int](1234)\n\t\t},\n\t)\n\tresult1, ok1 := result.Left()\n\tresult2, ok2 := result.Right()\n\n\tfmt.Println(result1)\n\tfmt.Println(ok1)\n\tfmt.Println(result2)\n\tfmt.Println(ok2)\n\t// Output:\n\t// false\n\t// 1234\n\t// true\n}\n"
        },
        {
          "name": "either_test.go",
          "type": "blob",
          "size": 5.5517578125,
          "content": "package mo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestEitherLeft(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, bool](42)\n\tis.Equal(Either[int, bool]{left: 42, right: false, isLeft: true}, left)\n}\n\nfunc TestEitherRight(t *testing.T) {\n\tis := assert.New(t)\n\n\tright := Right[int, bool](true)\n\tis.Equal(Either[int, bool]{left: 0, right: true, isLeft: false}, right)\n}\n\nfunc TestEitherUnpack(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft1, right1 := Left[int, bool](42).Unpack()\n\tleft2, right2 := Right[int, bool](true).Unpack()\n\n\tis.Equal(42, left1)\n\tis.Equal(false, right1)\n\tis.Equal(0, left2)\n\tis.Equal(true, right2)\n}\n\nfunc TestEitherIsLeftOrRight(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, bool](42)\n\tright := Right[int, bool](true)\n\n\tis.True(left.IsLeft())\n\tis.False(left.IsRight())\n\tis.False(right.IsLeft())\n\tis.True(right.IsRight())\n}\n\nfunc TestEitherLeftOrRight(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, bool](42)\n\tright := Right[int, bool](true)\n\n\tresult1, ok1 := left.Left()\n\tresult2, ok2 := left.Right()\n\tresult3, ok3 := right.Left()\n\tresult4, ok4 := right.Right()\n\n\tis.Equal(42, result1)\n\tis.True(ok1)\n\tis.Equal(false, result2)\n\tis.False(ok2)\n\tis.Equal(0, result3)\n\tis.False(ok3)\n\tis.Equal(true, result4)\n\tis.True(ok4)\n}\n\nfunc TestEitherMustLeftOrRight(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, bool](42)\n\tright := Right[int, bool](true)\n\n\tis.NotPanics(func() {\n\t\tis.Equal(42, left.MustLeft())\n\t})\n\tis.Panics(func() {\n\t\tleft.MustRight()\n\t})\n\tis.Panics(func() {\n\t\tright.MustLeft()\n\t})\n\tis.NotPanics(func() {\n\t\tis.Equal(true, right.MustRight())\n\t})\n}\n\nfunc TestEitherGetOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, string](42)\n\tright := Right[int, string](\"foobar\")\n\n\tis.Equal(42, left.LeftOrElse(21))\n\tis.Equal(21, right.LeftOrElse(21))\n\tis.Equal(\"baz\", left.RightOrElse(\"baz\"))\n\tis.Equal(\"foobar\", right.RightOrElse(\"baz\"))\n}\n\nfunc TestEitherGetOrEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, string](42)\n\tright := Right[int, string](\"foobar\")\n\n\tis.Equal(42, left.LeftOrEmpty())\n\tis.Equal(0, right.LeftOrEmpty())\n\tis.Equal(\"\", left.RightOrEmpty())\n\tis.Equal(\"foobar\", right.RightOrEmpty())\n}\n\nfunc TestEitherSwap(t *testing.T) {\n\tis := assert.New(t)\n\n\tleft := Left[int, string](42)\n\tright := Right[int, string](\"foobar\")\n\n\tis.Equal(Either[string, int]{left: \"\", right: 42, isLeft: false}, left.Swap())\n\tis.Equal(Either[string, int]{left: \"foobar\", right: 0, isLeft: true}, right.Swap())\n}\n\nfunc TestEitherForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\tLeft[int, string](42).ForEach(\n\t\tfunc(a int) {\n\t\t\tis.Equal(42, a)\n\t\t},\n\t\tfunc(b string) {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t},\n\t)\n\n\tRight[int, string](\"foobar\").ForEach(\n\t\tfunc(a int) {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t},\n\t\tfunc(b string) {\n\t\t\tis.Equal(\"foobar\", b)\n\t\t},\n\t)\n}\n\nfunc TestEitherMatch(t *testing.T) {\n\tis := assert.New(t)\n\n\te1 := Left[int, string](42).Match(\n\t\tfunc(a int) Either[int, string] {\n\t\t\tis.Equal(42, a)\n\t\t\treturn Left[int, string](21)\n\t\t},\n\t\tfunc(b string) Either[int, string] {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t\treturn Left[int, string](1)\n\t\t},\n\t)\n\n\te2 := Right[int, string](\"foobar\").Match(\n\t\tfunc(a int) Either[int, string] {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t\treturn Right[int, string](\"baz\")\n\t\t},\n\t\tfunc(b string) Either[int, string] {\n\t\t\tis.Equal(\"foobar\", b)\n\t\t\treturn Right[int, string](\"plop\")\n\t\t},\n\t)\n\n\tis.Equal(Either[int, string]{left: 21, right: \"\", isLeft: true}, e1)\n\tis.Equal(Either[int, string]{left: 0, right: \"plop\", isLeft: false}, e2)\n}\n\nfunc TestEitherMapLeft(t *testing.T) {\n\tis := assert.New(t)\n\n\te1 := Left[int, string](42).MapLeft(\n\t\tfunc(a int) Either[int, string] {\n\t\t\tis.Equal(42, a)\n\t\t\treturn Left[int, string](21)\n\t\t},\n\t)\n\n\te2 := Right[int, string](\"foobar\").MapLeft(\n\t\tfunc(a int) Either[int, string] {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t\treturn Right[int, string](\"plop\")\n\t\t},\n\t)\n\n\tis.Equal(Either[int, string]{left: 21, right: \"\", isLeft: true}, e1)\n\tis.Equal(Either[int, string]{left: 0, right: \"foobar\", isLeft: false}, e2)\n}\n\nfunc TestEitherMapRight(t *testing.T) {\n\tis := assert.New(t)\n\n\te1 := Left[int, string](42).MapRight(\n\t\tfunc(b string) Either[int, string] {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t\treturn Left[int, string](21)\n\t\t},\n\t)\n\n\te2 := Right[int, string](\"foobar\").MapRight(\n\t\tfunc(b string) Either[int, string] {\n\t\t\tis.Equal(\"foobar\", b)\n\t\t\treturn Right[int, string](\"plop\")\n\t\t},\n\t)\n\n\tis.Equal(Either[int, string]{left: 42, right: \"\", isLeft: true}, e1)\n\tis.Equal(Either[int, string]{left: 0, right: \"plop\", isLeft: false}, e2)\n}\n\n// TestEitherFoldSuccess tests the Fold method with a successful result.\nfunc TestEitherFoldSuccess(t *testing.T) {\n\tis := assert.New(t)\n\teither := Either[error, int]{left: nil, right: 10, isLeft: false}\n\n\tsuccessFunc := func(value int) string {\n\t\treturn fmt.Sprintf(\"Success: %v\", value)\n\t}\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure: %v\", err)\n\t}\n\n\tfolded := Fold[error, int, string](either, successFunc, failureFunc)\n\texpected := \"Success: 10\"\n\n\tis.Equal(expected, folded)\n}\n\n// TestEitherFoldFailure tests the Fold method with a failure result.\nfunc TestEitherFoldFailure(t *testing.T) {\n\terr := errors.New(\"either error\")\n\tis := assert.New(t)\n\n\teither := Either[error, int]{left: err, right: 0, isLeft: true}\n\n\tsuccessFunc := func(value int) string {\n\t\treturn fmt.Sprintf(\"Success: %v\", value)\n\t}\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure: %v\", err)\n\t}\n\n\tfolded := Fold[error, int, string](either, successFunc, failureFunc)\n\texpected := fmt.Sprintf(\"Failure: %v\", err)\n\n\tis.Equal(expected, folded)\n}\n"
        },
        {
          "name": "fold.go",
          "type": "blob",
          "size": 1.009765625,
          "content": "package mo\n\n// Foldable represents a type that can be folded into a single value\n// based on its state.\n//\n// - T: the type of the value in the failure state (e.g., an error type).\n// - U: the type of the value in the success state.\ntype Foldable[T any, U any] interface {\n\tleftValue() T\n\trightValue() U\n\thasLeftValue() bool\n}\n\n// Fold applies one of the two functions based on the state of the Foldable type,\n// and it returns the result of applying either successFunc or failureFunc.\n//\n// - T: the type of the failure value (e.g., an error type)\n// - U: the type of the success value\n// - R: the type of the return value from the folding functions\n//\n// successFunc is applied when the Foldable is in the success state (i.e., isLeft() is false).\n// failureFunc is applied when the Foldable is in the failure state (i.e., isLeft() is true).\nfunc Fold[T, U, R any](f Foldable[T, U], successFunc func(U) R, failureFunc func(T) R) R {\n\tif f.hasLeftValue() {\n\t\treturn failureFunc(f.leftValue())\n\t}\n\treturn successFunc(f.rightValue())\n}\n"
        },
        {
          "name": "fold_example_test.go",
          "type": "blob",
          "size": 1.677734375,
          "content": "package mo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc ExampleFold_result() {\n\tres1 := Result[int]{value: 42, isErr: false, err: nil}\n\tres2 := Result[int]{value: 0, isErr: true, err: errors.New(\"error\")}\n\n\tsuccessFunc := func(val int) string {\n\t\treturn fmt.Sprintf(\"Success with value %d\", val)\n\t}\n\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure with error %s\", err)\n\t}\n\n\tfmt.Println(Fold[error, int, string](res1, successFunc, failureFunc))\n\tfmt.Println(Fold[error, int, string](res2, successFunc, failureFunc))\n\t// Output:\n\t// Success with value 42\n\t// Failure with error error\n}\n\nfunc ExampleFold_either() {\n\teither1 := Either[error, int]{isLeft: false, right: 42}\n\teither2 := Either[error, int]{isLeft: true, left: errors.New(\"either error\")}\n\n\tsuccessFunc := func(val int) string {\n\t\treturn fmt.Sprintf(\"Success with value %d\", val)\n\t}\n\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure with error %s\", err)\n\t}\n\n\tfmt.Println(Fold[error, int, string](either1, successFunc, failureFunc))\n\tfmt.Println(Fold[error, int, string](either2, successFunc, failureFunc))\n\t// Output:\n\t// Success with value 42\n\t// Failure with error either error\n}\n\nfunc ExampleFold_option() {\n\toption1 := Option[int]{isPresent: true, value: 42}\n\toption2 := Option[int]{isPresent: false}\n\n\tsuccessFunc := func(val int) string {\n\t\treturn fmt.Sprintf(\"Success with value %d\", val)\n\t}\n\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure with error %s\", err)\n\t}\n\n\tfmt.Println(Fold[error, int, string](option1, successFunc, failureFunc))\n\tfmt.Println(Fold[error, int, string](option2, successFunc, failureFunc))\n\t// Output:\n\t// Success with value 42\n\t// Failure with error no such element\n}\n"
        },
        {
          "name": "future.go",
          "type": "blob",
          "size": 3.3056640625,
          "content": "package mo\n\nimport (\n\t\"sync\"\n)\n\n// NewFuture instanciate a new future.\nfunc NewFuture[T any](cb func(resolve func(T), reject func(error))) *Future[T] {\n\tfuture := Future[T]{\n\t\tcb:       cb,\n\t\tcancelCb: func() {},\n\t\tdone:     make(chan struct{}),\n\t}\n\n\tfuture.active()\n\n\treturn &future\n}\n\n// Future represents a value which may or may not currently be available, but will be\n// available at some point, or an exception if that value could not be made available.\ntype Future[T any] struct {\n\tmu sync.Mutex\n\n\tcb       func(func(T), func(error))\n\tcancelCb func()\n\tnext     *Future[T]\n\tdone     chan struct{}\n\tresult   Result[T]\n}\n\nfunc (f *Future[T]) active() {\n\tgo f.cb(f.resolve, f.reject)\n}\n\nfunc (f *Future[T]) activeSync() {\n\tf.cb(f.resolve, f.reject)\n}\n\nfunc (f *Future[T]) resolve(value T) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tf.result = Ok(value)\n\tif f.next != nil {\n\t\tf.next.activeSync()\n\t}\n\tclose(f.done)\n}\n\nfunc (f *Future[T]) reject(err error) {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tf.result = Err[T](err)\n\tif f.next != nil {\n\t\tf.next.activeSync()\n\t}\n\tclose(f.done)\n}\n\n// Then is called when Future is resolved. It returns a new Future.\nfunc (f *Future[T]) Then(cb func(T) (T, error)) *Future[T] {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tf.next = &Future[T]{\n\t\tcb: func(resolve func(T), reject func(error)) {\n\t\t\tif f.result.IsError() {\n\t\t\t\treject(f.result.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnewValue, err := cb(f.result.MustGet())\n\t\t\tif err != nil {\n\t\t\t\treject(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresolve(newValue)\n\t\t},\n\t\tcancelCb: func() {\n\t\t\tf.Cancel()\n\t\t},\n\t\tdone: make(chan struct{}),\n\t}\n\n\tselect {\n\tcase <-f.done:\n\t\tf.next.active()\n\tdefault:\n\t}\n\treturn f.next\n}\n\n// Catch is called when Future is rejected. It returns a new Future.\nfunc (f *Future[T]) Catch(cb func(error) (T, error)) *Future[T] {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tf.next = &Future[T]{\n\t\tcb: func(resolve func(T), reject func(error)) {\n\t\t\tif f.result.IsOk() {\n\t\t\t\tresolve(f.result.MustGet())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnewValue, err := cb(f.result.Error())\n\t\t\tif err != nil {\n\t\t\t\treject(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresolve(newValue)\n\t\t},\n\t\tcancelCb: func() {\n\t\t\tf.Cancel()\n\t\t},\n\t\tdone: make(chan struct{}),\n\t}\n\n\tselect {\n\tcase <-f.done:\n\t\tf.next.active()\n\tdefault:\n\t}\n\treturn f.next\n}\n\n// Finally is called when Future is processed either resolved or rejected. It returns a new Future.\nfunc (f *Future[T]) Finally(cb func(T, error) (T, error)) *Future[T] {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tf.next = &Future[T]{\n\t\tcb: func(resolve func(T), reject func(error)) {\n\t\t\tnewValue, err := cb(f.result.Get())\n\t\t\tif err != nil {\n\t\t\t\treject(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tresolve(newValue)\n\t\t},\n\t\tcancelCb: func() {\n\t\t\tf.Cancel()\n\t\t},\n\t\tdone: make(chan struct{}),\n\t}\n\n\tselect {\n\tcase <-f.done:\n\t\tf.next.active()\n\tdefault:\n\t}\n\treturn f.next\n}\n\n// Cancel cancels the Future chain.\nfunc (f *Future[T]) Cancel() {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tf.next = nil\n\tif f.cancelCb != nil {\n\t\tf.cancelCb()\n\t}\n}\n\n// Collect awaits and return result of the Future.\nfunc (f *Future[T]) Collect() (T, error) {\n\t<-f.done\n\treturn f.result.Get()\n}\n\n// Result wraps Collect and returns a Result.\nfunc (f *Future[T]) Result() Result[T] {\n\treturn TupleToResult(f.Collect())\n}\n\n// Either wraps Collect and returns a Either.\nfunc (f *Future[T]) Either() Either[error, T] {\n\tv, err := f.Collect()\n\tif err != nil {\n\t\treturn Left[error, T](err)\n\t}\n\treturn Right[error, T](v)\n}\n"
        },
        {
          "name": "future_example_test.go",
          "type": "blob",
          "size": 3.4599609375,
          "content": "package mo\n\nimport \"fmt\"\n\nfunc ExampleNewFuture_resolve() {\n\tvalue, err := NewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Collect()\n\n\tfmt.Println(value)\n\tfmt.Println(err)\n\t// Output:\n\t// foobar\n\t// <nil>\n}\n\nfunc ExampleNewFuture_reject() {\n\tvalue, err := NewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Collect()\n\n\tfmt.Println(value)\n\tfmt.Println(err)\n\t// Output:\n\t//\n\t// failure\n}\n\nfunc ExampleFuture_Collect_resolve() {\n\tvalue, err := NewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Collect()\n\n\tfmt.Println(value)\n\tfmt.Println(err)\n\t// Output:\n\t// foobar\n\t// <nil>\n}\n\nfunc ExampleFuture_Collect_reject() {\n\tvalue, err := NewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Collect()\n\n\tfmt.Println(value)\n\tfmt.Println(err)\n\t// Output:\n\t//\n\t// failure\n}\n\nfunc ExampleFuture_Result_resolve() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t// foobar\n\t// <nil>\n}\n\nfunc ExampleFuture_Result_reject() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t//\n\t// failure\n}\n\nfunc ExampleFuture_Then_resolve() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Then(func(s string) (string, error) {\n\t\treturn \"baz\", nil\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t// baz\n\t// <nil>\n}\n\nfunc ExampleFuture_Then_reject() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Then(func(s string) (string, error) {\n\t\treturn \"foobar\", nil\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t//\n\t// failure\n}\n\nfunc ExampleFuture_Catch_resolve() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Catch(func(err error) (string, error) {\n\t\treturn \"baz\", nil\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t// foobar\n\t// <nil>\n}\n\nfunc ExampleFuture_Catch_reject() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Catch(func(err error) (string, error) {\n\t\treturn \"foobar\", nil\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t// foobar\n\t// <nil>\n}\n\nfunc ExampleFuture_Finally_resolve() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Finally(func(value string, err error) (string, error) {\n\t\treturn \"baz\", nil\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t// baz\n\t// <nil>\n}\n\nfunc ExampleFuture_Finally_reject() {\n\tresult := NewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Finally(func(value string, err error) (string, error) {\n\t\treturn \"foobar\", nil\n\t}).Result()\n\n\tfmt.Println(result.OrEmpty())\n\tfmt.Println(result.Error())\n\t// Output:\n\t// foobar\n\t// <nil>\n}\n\nfunc ExampleFuture_Cancel_resolve() {\n\tNewFuture(func(resolve func(string), reject func(error)) {\n\t\tresolve(\"foobar\")\n\t}).Cancel()\n}\n\nfunc ExampleFuture_Cancel_reject() {\n\tNewFuture(func(resolve func(string), reject func(error)) {\n\t\treject(fmt.Errorf(\"failure\"))\n\t}).Cancel()\n}\n"
        },
        {
          "name": "future_test.go",
          "type": "blob",
          "size": 6.6259765625,
          "content": "package mo\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc assertAndIncrement(is *assert.Assertions, expected int, i *int32) {\n\tgot := atomic.LoadInt32(i)\n\n\tis.Equal(int32(expected), got)\n\n\tatomic.AddInt32(i, 1)\n}\n\nfunc TestFuture(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tis.Equal(42, value)\n\t\treturn 21, assert.AnError\n\t}).Catch(func(err error) (int, error) {\n\t\tis.Equal(assert.AnError, err)\n\t\treturn 0, nil\n\t}).Then(func(value int) (int, error) {\n\t\tis.Equal(0, value)\n\t\treturn 84, nil\n\t}).Collect()\n\n\tis.Equal(84, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureSimpleResolve(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tresolve(42)\n\t}).Collect()\n\n\tis.Equal(42, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureSimpleReject(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\treject(assert.AnError)\n\t}).Collect()\n\n\tis.Equal(0, result)\n\tis.NotNil(err)\n\tis.Equal(assert.AnError, err)\n}\n\nfunc TestFutureMultipleResolve(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tis.Equal(42, value)\n\t\treturn 84, nil\n\t}).Then(func(value int) (int, error) {\n\t\tis.Equal(84, value)\n\t\treturn 21, nil\n\t}).Collect()\n\n\tis.Equal(21, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureMultipleReject(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tresolve(42)\n\t}).Catch(func(err error) (int, error) {\n\t\tis.Fail(\"should not enter here\")\n\t\treturn 84, assert.AnError\n\t}).Then(func(value int) (int, error) {\n\t\tis.Equal(42, value)\n\t\treturn 21, assert.AnError\n\t}).Catch(func(err error) (int, error) {\n\t\tis.Equal(assert.AnError, err)\n\t\treturn 1, nil\n\t}).Collect()\n\n\tis.Equal(1, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureSingleReject(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\treject(assert.AnError)\n\t}).Catch(func(err error) (int, error) {\n\t\tis.Equal(assert.AnError, err)\n\t\treturn 84, nil\n\t}).Collect()\n\n\tis.Equal(84, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureErrorResult(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\treject(assert.AnError)\n\t}).Collect()\n\n\tis.Equal(0, result)\n\tis.NotNil(err)\n\tis.Equal(assert.AnError, err)\n}\n\nfunc TestFutureFinallyResolve(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tresolve(21)\n\t}).Finally(func(value int, err error) (int, error) {\n\t\tis.Equal(21, value)\n\t\tis.Nil(err)\n\n\t\treturn 42, nil\n\t}).Collect()\n\n\tis.Equal(42, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureFinallyReject(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult, err := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\treject(assert.AnError)\n\t}).Finally(func(value int, err error) (int, error) {\n\t\tis.Equal(0, value)\n\t\tis.NotNil(err)\n\t\tis.Equal(assert.AnError, err)\n\n\t\treturn 42, nil\n\t}).Collect()\n\n\tis.Equal(42, result)\n\tis.Nil(err)\n}\n\nfunc TestFutureOrder(t *testing.T) {\n\tis := assert.New(t)\n\n\tvar i int32 = 0\n\n\t_ = NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tassertAndIncrement(is, 1, &i)\n\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tassertAndIncrement(is, 2, &i)\n\n\t\treturn 21, assert.AnError\n\t}).Catch(func(err error) (int, error) {\n\t\tassertAndIncrement(is, 3, &i)\n\n\t\treturn 1, nil\n\t}).Finally(func(value int, err error) (int, error) {\n\t\tassertAndIncrement(is, 4, &i)\n\n\t\treturn 21, nil\n\t})\n\n\tassertAndIncrement(is, 0, &i)\n}\n\nfunc TestFutureOrderCollect(t *testing.T) {\n\tis := assert.New(t)\n\n\tvar i int32 = 0\n\n\t_, _ = NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tassertAndIncrement(is, 0, &i)\n\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tassertAndIncrement(is, 1, &i)\n\n\t\treturn 21, assert.AnError\n\t}).Catch(func(err error) (int, error) {\n\t\tassertAndIncrement(is, 2, &i)\n\n\t\treturn 1, nil\n\t}).Finally(func(value int, err error) (int, error) {\n\t\tassertAndIncrement(is, 3, &i)\n\n\t\treturn 1, nil\n\t}).Collect()\n\n\tassertAndIncrement(is, 4, &i)\n}\n\nfunc TestFutureCancel(t *testing.T) {\n\tis := assert.New(t)\n\n\tvar i int32 = 0\n\n\tfuture := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\tassertAndIncrement(is, 0, &i)\n\n\t\ttime.Sleep(5 * time.Millisecond)\n\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tassertAndIncrement(is, 3, &i)\n\t\tis.Fail(\"should not enter here\")\n\n\t\treturn 21, assert.AnError\n\t})\n\n\ttime.Sleep(1 * time.Millisecond)\n\tassertAndIncrement(is, 1, &i)\n\tfuture.Cancel()\n\n\ttime.Sleep(10 * time.Millisecond)\n\tassertAndIncrement(is, 2, &i)\n}\n\nfunc TestFutureCancelDelayed(t *testing.T) {\n\tis := assert.New(t)\n\n\tvar i int32 = 0\n\n\tfuture := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tassertAndIncrement(is, 1, &i)\n\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tassertAndIncrement(is, 2, &i)\n\n\t\treturn 21, assert.AnError\n\t})\n\n\tassertAndIncrement(is, 0, &i)\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tfuture.Cancel()\n\n\tassertAndIncrement(is, 3, &i)\n}\n\nfunc TestFutureCancelTerminated(t *testing.T) {\n\tis := assert.New(t)\n\n\tvar i int32 = 0\n\n\tfuture := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tassertAndIncrement(is, 1, &i)\n\n\t\tresolve(42)\n\t}).Then(func(value int) (int, error) {\n\t\tassertAndIncrement(is, 2, &i)\n\n\t\treturn 21, assert.AnError\n\t})\n\n\tassertAndIncrement(is, 0, &i)\n\n\t_, _ = future.Collect()\n\n\tassertAndIncrement(is, 3, &i)\n\n\tfuture.Cancel()\n\n\tassertAndIncrement(is, 4, &i)\n}\n\nfunc TestFutureResultResult(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\treject(assert.AnError)\n\t}).Result()\n\n\tis.Equal(Err[int](assert.AnError), result)\n\tis.NotNil(result.Error())\n\tis.Equal(assert.AnError, result.Error())\n}\n\nfunc TestFutureResultEither(t *testing.T) {\n\tis := assert.New(t)\n\n\teither := NewFuture[int](func(resolve func(int), reject func(error)) {\n\t\treject(assert.AnError)\n\t}).Either()\n\n\tis.Equal(Left[error, int](assert.AnError), either)\n\tis.NotNil(either.Left())\n\tis.Equal(assert.AnError, either.MustLeft())\n}\n\nfunc TestFutureCompleteBeforeThen(t *testing.T) {\n\tcompleted := make(chan struct{})\n\tfut := NewFuture(func(resolve func(int), reject func(error)) {\n\t\tresolve(1)\n\t\tclose(completed)\n\t})\n\n\t<-completed\n\t//nolint:errcheck\n\tfut.Then(func(in int) (int, error) {\n\t\tfmt.Println(in) // will never been print\n\t\treturn in, nil\n\t}).Collect() // deadlock\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5361328125,
          "content": "module github.com/samber/mo\n\ngo 1.18\n\n//\n// Dependencies are excluded from releases. Please check CI.\n//\n\nrequire (\n\tgithub.com/stretchr/testify v1.10.0\n\tgo.uber.org/goleak v1.2.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect\n\tgithub.com/rogpeppe/go-internal v1.12.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.2412109375,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=\ngithub.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngo.uber.org/goleak v1.2.1 h1:NBol2c7O1ZokfZ0LEU9K6Whx/KnwvepVetCUhtKja4A=\ngo.uber.org/goleak v1.2.1/go.mod h1:qlT2yGI9QafXHhZZLxlSuNsMw3FFLxBr+tBRlmO1xH4=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "io.go",
          "type": "blob",
          "size": 3.0859375,
          "content": "package mo\n\n// NewIO instanciates a new IO.\nfunc NewIO[R any](f f0[R]) IO[R] {\n\treturn IO[R]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IO represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype IO[R any] struct {\n\tunsafePerform f0[R]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IO[R]) Run() R {\n\treturn io.unsafePerform()\n}\n\n// NewIO1 instanciates a new IO1.\nfunc NewIO1[R any, A any](f f1[R, A]) IO1[R, A] {\n\treturn IO1[R, A]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IO1 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype IO1[R any, A any] struct {\n\tunsafePerform f1[R, A]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IO1[R, A]) Run(a A) R {\n\treturn io.unsafePerform(a)\n}\n\n// NewIO2 instanciates a new IO2.\nfunc NewIO2[R any, A any, B any](f f2[R, A, B]) IO2[R, A, B] {\n\treturn IO2[R, A, B]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IO2 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype IO2[R any, A any, B any] struct {\n\tunsafePerform f2[R, A, B]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IO2[R, A, B]) Run(a A, b B) R {\n\treturn io.unsafePerform(a, b)\n}\n\n// NewIO3 instanciates a new IO3.\nfunc NewIO3[R any, A any, B any, C any](f f3[R, A, B, C]) IO3[R, A, B, C] {\n\treturn IO3[R, A, B, C]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IO3 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype IO3[R any, A any, B any, C any] struct {\n\tunsafePerform f3[R, A, B, C]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IO3[R, A, B, C]) Run(a A, b B, c C) R {\n\treturn io.unsafePerform(a, b, c)\n}\n\n// NewIO4 instanciates a new IO4.\nfunc NewIO4[R any, A any, B any, C any, D any](f f4[R, A, B, C, D]) IO4[R, A, B, C, D] {\n\treturn IO4[R, A, B, C, D]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IO4 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype IO4[R any, A any, B any, C any, D any] struct {\n\tunsafePerform f4[R, A, B, C, D]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IO4[R, A, B, C, D]) Run(a A, b B, c C, d D) R {\n\treturn io.unsafePerform(a, b, c, d)\n}\n\n// NewIO5 instanciates a new IO5.\nfunc NewIO5[R any, A any, B any, C any, D any, E any](f f5[R, A, B, C, D, E]) IO5[R, A, B, C, D, E] {\n\treturn IO5[R, A, B, C, D, E]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IO5 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype IO5[R any, A any, B any, C any, D any, E any] struct {\n\tunsafePerform f5[R, A, B, C, D, E]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IO5[R, A, B, C, D, E]) Run(a A, b B, c C, d D, e E) R {\n\treturn io.unsafePerform(a, b, c, d, e)\n}\n"
        },
        {
          "name": "io_either.go",
          "type": "blob",
          "size": 3.8828125,
          "content": "package mo\n\n// NewIOEither instanciates a new IO.\nfunc NewIOEither[R any](f fe0[R]) IOEither[R] {\n\treturn IOEither[R]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IOEither represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype IOEither[R any] struct {\n\tunsafePerform fe0[R]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IOEither[R]) Run() Either[error, R] {\n\tv, err := io.unsafePerform()\n\tif err != nil {\n\t\treturn Left[error, R](err)\n\t}\n\n\treturn Right[error, R](v)\n}\n\n// NewIOEither1 instanciates a new IO1.\nfunc NewIOEither1[R any, A any](f fe1[R, A]) IOEither1[R, A] {\n\treturn IOEither1[R, A]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IOEither1 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype IOEither1[R any, A any] struct {\n\tunsafePerform fe1[R, A]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IOEither1[R, A]) Run(a A) Either[error, R] {\n\tv, err := io.unsafePerform(a)\n\tif err != nil {\n\t\treturn Left[error, R](err)\n\t}\n\n\treturn Right[error, R](v)\n}\n\n// NewIOEither2 instanciates a new IO2.\nfunc NewIOEither2[R any, A any, B any](f fe2[R, A, B]) IOEither2[R, A, B] {\n\treturn IOEither2[R, A, B]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IOEither2 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype IOEither2[R any, A any, B any] struct {\n\tunsafePerform fe2[R, A, B]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IOEither2[R, A, B]) Run(a A, b B) Either[error, R] {\n\tv, err := io.unsafePerform(a, b)\n\tif err != nil {\n\t\treturn Left[error, R](err)\n\t}\n\n\treturn Right[error, R](v)\n}\n\n// NewIOEither3 instanciates a new IO3.\nfunc NewIOEither3[R any, A any, B any, C any](f fe3[R, A, B, C]) IOEither3[R, A, B, C] {\n\treturn IOEither3[R, A, B, C]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IOEither3 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype IOEither3[R any, A any, B any, C any] struct {\n\tunsafePerform fe3[R, A, B, C]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IOEither3[R, A, B, C]) Run(a A, b B, c C) Either[error, R] {\n\tv, err := io.unsafePerform(a, b, c)\n\tif err != nil {\n\t\treturn Left[error, R](err)\n\t}\n\n\treturn Right[error, R](v)\n}\n\n// NewIOEither4 instanciates a new IO4.\nfunc NewIOEither4[R any, A any, B any, C any, D any](f fe4[R, A, B, C, D]) IOEither4[R, A, B, C, D] {\n\treturn IOEither4[R, A, B, C, D]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IOEither4 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype IOEither4[R any, A any, B any, C any, D any] struct {\n\tunsafePerform fe4[R, A, B, C, D]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IOEither4[R, A, B, C, D]) Run(a A, b B, c C, d D) Either[error, R] {\n\tv, err := io.unsafePerform(a, b, c, d)\n\tif err != nil {\n\t\treturn Left[error, R](err)\n\t}\n\n\treturn Right[error, R](v)\n}\n\n// NewIOEither5 instanciates a new IO5.\nfunc NewIOEither5[R any, A any, B any, C any, D any, E any](f fe5[R, A, B, C, D, E]) IOEither5[R, A, B, C, D, E] {\n\treturn IOEither5[R, A, B, C, D, E]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// IOEither5 represents a non-deterministic synchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype IOEither5[R any, A any, B any, C any, D any, E any] struct {\n\tunsafePerform fe5[R, A, B, C, D, E]\n}\n\n// Run execute the non-deterministic synchronous computation, with side effect.\nfunc (io IOEither5[R, A, B, C, D, E]) Run(a A, b B, c C, d D, e E) Either[error, R] {\n\tv, err := io.unsafePerform(a, b, c, d, e)\n\tif err != nil {\n\t\treturn Left[error, R](err)\n\t}\n\n\treturn Right[error, R](v)\n}\n"
        },
        {
          "name": "io_either_example_test.go",
          "type": "blob",
          "size": 0.50390625,
          "content": "package mo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc ExampleIOEither1() {\n\tio := NewIOEither1(func(path string) (bool, error) {\n\t\t_, err := os.Stat(path)\n\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn false, nil\n\t\t} else if err != nil {\n\t\t\t// other errors\n\t\t\treturn false, err\n\t\t}\n\n\t\treturn true, nil\n\t})\n\n\teither1 := io.Run(\"./io_either.go\")\n\teither2 := io.Run(\"./foo_bar.go\")\n\n\texist1, _ := either1.Right()\n\texist2, _ := either2.Right()\n\n\tfmt.Println(exist1)\n\tfmt.Println(exist2)\n\t// Output:\n\t// true\n\t// false\n}\n"
        },
        {
          "name": "io_either_test.go",
          "type": "blob",
          "size": 2.16796875,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIOEither(t *testing.T) {\n\tis := assert.New(t)\n\n\tioEither := NewIOEither(func() (int, error) {\n\t\treturn 42, nil\n\t})\n\tresult := ioEither.Run()\n\n\tis.False(result.isLeft)\n\tis.Nil(result.Left())\n\tis.True(result.IsRight())\n\tis.Equal(42, result.MustRight())\n}\n\nfunc TestIOEither1(t *testing.T) {\n\tis := assert.New(t)\n\n\tioEither := NewIOEither1(func(a string) (int, error) {\n\t\tis.Equal(\"foo\", a)\n\t\treturn 42, nil\n\t})\n\tresult := ioEither.Run(\"foo\")\n\n\tis.False(result.isLeft)\n\tis.Nil(result.Left())\n\tis.True(result.IsRight())\n\tis.Equal(42, result.MustRight())\n}\n\nfunc TestIOEither2(t *testing.T) {\n\tis := assert.New(t)\n\n\tioEither := NewIOEither2(func(a string, b string) (int, error) {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\treturn 42, nil\n\t})\n\tresult := ioEither.Run(\"foo\", \"bar\")\n\n\tis.False(result.isLeft)\n\tis.Nil(result.Left())\n\tis.True(result.IsRight())\n\tis.Equal(42, result.MustRight())\n}\n\nfunc TestIOEither3(t *testing.T) {\n\tis := assert.New(t)\n\n\tioEither := NewIOEither3(func(a string, b string, c string) (int, error) {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\tis.Equal(\"hello\", c)\n\t\treturn 42, nil\n\t})\n\tresult := ioEither.Run(\"foo\", \"bar\", \"hello\")\n\n\tis.False(result.isLeft)\n\tis.Nil(result.Left())\n\tis.True(result.IsRight())\n\tis.Equal(42, result.MustRight())\n}\n\nfunc TestIOEither4(t *testing.T) {\n\tis := assert.New(t)\n\n\tioEither := NewIOEither4(func(a string, b string, c string, d string) (int, error) {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\tis.Equal(\"hello\", c)\n\t\tis.Equal(\"world\", d)\n\t\treturn 42, nil\n\t})\n\tresult := ioEither.Run(\"foo\", \"bar\", \"hello\", \"world\")\n\n\tis.False(result.isLeft)\n\tis.Nil(result.Left())\n\tis.True(result.IsRight())\n\tis.Equal(42, result.MustRight())\n}\n\nfunc TestIOEither5(t *testing.T) {\n\tis := assert.New(t)\n\n\tioEither := NewIOEither5(func(a string, b string, c string, d string, e bool) (int, error) {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\tis.Equal(\"hello\", c)\n\t\tis.Equal(\"world\", d)\n\t\tis.True(e)\n\t\treturn 42, nil\n\t})\n\tresult := ioEither.Run(\"foo\", \"bar\", \"hello\", \"world\", true)\n\n\tis.False(result.isLeft)\n\tis.Nil(result.Left())\n\tis.True(result.IsRight())\n\tis.Equal(42, result.MustRight())\n}\n"
        },
        {
          "name": "io_example_test.go",
          "type": "blob",
          "size": 0.32421875,
          "content": "package mo\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc ExampleIO() {\n\tt := time.Date(2024, 6, 22, 0, 0, 0, 0, time.Local)\n\n\tio := NewIO(func() int {\n\t\treturn t.Year()\n\t})\n\n\tresult1 := io.Run()\n\tresult2 := io.Run()\n\tresult3 := io.Run()\n\n\tfmt.Println(result1)\n\tfmt.Println(result2)\n\tfmt.Println(result3)\n\t// Output:\n\t// 2024\n\t// 2024\n\t// 2024\n}\n"
        },
        {
          "name": "io_test.go",
          "type": "blob",
          "size": 1.435546875,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIO(t *testing.T) {\n\tis := assert.New(t)\n\n\tio := NewIO(func() int {\n\t\treturn 42\n\t})\n\tresult := io.Run()\n\n\tis.Equal(42, result)\n}\n\nfunc TestIO1(t *testing.T) {\n\tis := assert.New(t)\n\n\tio := NewIO1(func(a string) int {\n\t\tis.Equal(\"foo\", a)\n\t\treturn 42\n\t})\n\tresult := io.Run(\"foo\")\n\n\tis.Equal(42, result)\n}\n\nfunc TestIO2(t *testing.T) {\n\tis := assert.New(t)\n\n\tio := NewIO2(func(a string, b string) int {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\treturn 42\n\t})\n\tresult := io.Run(\"foo\", \"bar\")\n\n\tis.Equal(42, result)\n}\n\nfunc TestIO3(t *testing.T) {\n\tis := assert.New(t)\n\n\tio := NewIO3(func(a string, b string, c string) int {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\tis.Equal(\"hello\", c)\n\t\treturn 42\n\t})\n\tresult := io.Run(\"foo\", \"bar\", \"hello\")\n\n\tis.Equal(42, result)\n}\n\nfunc TestIO4(t *testing.T) {\n\tis := assert.New(t)\n\n\tio := NewIO4(func(a string, b string, c string, d string) int {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\tis.Equal(\"hello\", c)\n\t\tis.Equal(\"world\", d)\n\t\treturn 42\n\t})\n\tresult := io.Run(\"foo\", \"bar\", \"hello\", \"world\")\n\n\tis.Equal(42, result)\n}\n\nfunc TestIO5(t *testing.T) {\n\tis := assert.New(t)\n\n\tio := NewIO5(func(a string, b string, c string, d string, e bool) int {\n\t\tis.Equal(\"foo\", a)\n\t\tis.Equal(\"bar\", b)\n\t\tis.Equal(\"hello\", c)\n\t\tis.Equal(\"world\", d)\n\t\tis.True(e)\n\t\treturn 42\n\t})\n\tresult := io.Run(\"foo\", \"bar\", \"hello\", \"world\", true)\n\n\tis.Equal(42, result)\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 0.11328125,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 7.607421875,
          "content": "package mo\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/gob\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar optionNoSuchElement = fmt.Errorf(\"no such element\")\n\n// Some builds an Option when value is present.\n// Play: https://go.dev/play/p/iqz2n9n0tDM\nfunc Some[T any](value T) Option[T] {\n\treturn Option[T]{\n\t\tisPresent: true,\n\t\tvalue:     value,\n\t}\n}\n\n// None builds an Option when value is absent.\n// Play: https://go.dev/play/p/yYQPsYCSYlD\nfunc None[T any]() Option[T] {\n\treturn Option[T]{\n\t\tisPresent: false,\n\t}\n}\n\n// TupleToOption builds a Some Option when second argument is true, or None.\n// Play: https://go.dev/play/p/gkrg2pZwOty\nfunc TupleToOption[T any](value T, ok bool) Option[T] {\n\tif ok {\n\t\treturn Some(value)\n\t}\n\treturn None[T]()\n}\n\n// EmptyableToOption builds a Some Option when value is not empty, or None.\n// Play: https://go.dev/play/p/GSpQQ-q-UES\nfunc EmptyableToOption[T any](value T) Option[T] {\n\t// ü§Æ\n\tisZero := reflect.ValueOf(&value).Elem().IsZero()\n\tif isZero {\n\t\treturn None[T]()\n\t}\n\n\treturn Some(value)\n}\n\n// PointerToOption builds a Some Option when value is not nil, or None.\n// Play: https://go.dev/play/p/yPVMj4DUb-I\nfunc PointerToOption[T any](value *T) Option[T] {\n\tif value == nil {\n\t\treturn None[T]()\n\t}\n\n\treturn Some(*value)\n}\n\n// Option is a container for an optional value of type T. If value exists, Option is\n// of type Some. If the value is absent, Option is of type None.\ntype Option[T any] struct {\n\tisPresent bool\n\tvalue     T\n}\n\n// IsPresent returns false when value is absent.\n// Play: https://go.dev/play/p/nDqIaiihyCA\nfunc (o Option[T]) IsPresent() bool {\n\treturn o.isPresent\n}\n\n// IsAbsent returns false when value is present.\n// Play: https://go.dev/play/p/23e2zqyVOQm\nfunc (o Option[T]) IsAbsent() bool {\n\treturn !o.isPresent\n}\n\n// Size returns 1 when value is present or 0 instead.\n// Play: https://go.dev/play/p/7ixCNG1E9l7\nfunc (o Option[T]) Size() int {\n\tif o.isPresent {\n\t\treturn 1\n\t}\n\n\treturn 0\n}\n\n// Get returns value and presence.\n// Play: https://go.dev/play/p/0-JBa1usZRT\nfunc (o Option[T]) Get() (T, bool) {\n\tif !o.isPresent {\n\t\treturn empty[T](), false\n\t}\n\n\treturn o.value, true\n}\n\n// MustGet returns value if present or panics instead.\n// Play: https://go.dev/play/p/RVBckjdi5WR\nfunc (o Option[T]) MustGet() T {\n\tif !o.isPresent {\n\t\tpanic(optionNoSuchElement)\n\t}\n\n\treturn o.value\n}\n\n// OrElse returns value if present or default value.\n// Play: https://go.dev/play/p/TrGByFWCzXS\nfunc (o Option[T]) OrElse(fallback T) T {\n\tif !o.isPresent {\n\t\treturn fallback\n\t}\n\n\treturn o.value\n}\n\n// OrEmpty returns value if present or empty value.\n// Play: https://go.dev/play/p/SpSUJcE-tQm\nfunc (o Option[T]) OrEmpty() T {\n\treturn o.value\n}\n\n// ForEach executes the given side-effecting function of value is present.\nfunc (o Option[T]) ForEach(onValue func(value T)) {\n\tif o.isPresent {\n\t\tonValue(o.value)\n\t}\n}\n\n// Match executes the first function if value is present and second function if absent.\n// It returns a new Option.\n// Play: https://go.dev/play/p/1V6st3LDJsM\nfunc (o Option[T]) Match(onValue func(value T) (T, bool), onNone func() (T, bool)) Option[T] {\n\tif o.isPresent {\n\t\treturn TupleToOption(onValue(o.value))\n\t}\n\treturn TupleToOption(onNone())\n}\n\n// Map executes the mapper function if value is present or returns None if absent.\n// Play: https://go.dev/play/p/mvfP3pcP_eJ\nfunc (o Option[T]) Map(mapper func(value T) (T, bool)) Option[T] {\n\tif o.isPresent {\n\t\treturn TupleToOption(mapper(o.value))\n\t}\n\n\treturn None[T]()\n}\n\n// MapNone executes the mapper function if value is absent or returns Option.\n// Play: https://go.dev/play/p/_KaHWZ6Q17b\nfunc (o Option[T]) MapNone(mapper func() (T, bool)) Option[T] {\n\tif o.isPresent {\n\t\treturn Some(o.value)\n\t}\n\n\treturn TupleToOption(mapper())\n}\n\n// FlatMap executes the mapper function if value is present or returns None if absent.\n// Play: https://go.dev/play/p/OXO-zJx6n5r\nfunc (o Option[T]) FlatMap(mapper func(value T) Option[T]) Option[T] {\n\tif o.isPresent {\n\t\treturn mapper(o.value)\n\t}\n\n\treturn None[T]()\n}\n\n// ToPointer returns value if present or a nil pointer.\n// Play: https://go.dev/play/p/N43w92SM-Bs\nfunc (o Option[T]) ToPointer() *T {\n\tif !o.isPresent {\n\t\treturn nil\n\t}\n\n\treturn &o.value\n}\n\n// MarshalJSON encodes Option into json.\nfunc (o Option[T]) MarshalJSON() ([]byte, error) {\n\tif o.isPresent {\n\t\treturn json.Marshal(o.value)\n\t}\n\n\t// if anybody find a way to support `omitempty` param, please contribute!\n\treturn json.Marshal(nil)\n}\n\n// UnmarshalJSON decodes Option from json.\nfunc (o *Option[T]) UnmarshalJSON(b []byte) error {\n\tif bytes.Equal(b, []byte(\"null\")) {\n\t\to.isPresent = false\n\t\treturn nil\n\t}\n\n\terr := json.Unmarshal(b, &o.value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\to.isPresent = true\n\treturn nil\n}\n\n// MarshalText implements the encoding.TextMarshaler interface.\nfunc (o Option[T]) MarshalText() ([]byte, error) {\n\treturn json.Marshal(o)\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface.\nfunc (o *Option[T]) UnmarshalText(data []byte) error {\n\treturn json.Unmarshal(data, o)\n}\n\n// MarshalBinary is the interface implemented by an object that can marshal itself into a binary form.\nfunc (o Option[T]) MarshalBinary() ([]byte, error) {\n\tif !o.isPresent {\n\t\treturn []byte{0}, nil\n\t}\n\n\tvar buf bytes.Buffer\n\n\tenc := gob.NewEncoder(&buf)\n\tif err := enc.Encode(o.value); err != nil {\n\t\treturn []byte{}, err\n\t}\n\n\treturn append([]byte{1}, buf.Bytes()...), nil\n}\n\n// UnmarshalBinary is the interface implemented by an object that can unmarshal a binary representation of itself.\nfunc (o *Option[T]) UnmarshalBinary(data []byte) error {\n\tif len(data) == 0 {\n\t\treturn errors.New(\"Option[T].UnmarshalBinary: no data\")\n\t}\n\n\tif data[0] == 0 {\n\t\to.isPresent = false\n\t\to.value = empty[T]()\n\t\treturn nil\n\t}\n\n\tbuf := bytes.NewBuffer(data[1:])\n\tdec := gob.NewDecoder(buf)\n\terr := dec.Decode(&o.value)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\to.isPresent = true\n\treturn nil\n}\n\n// GobEncode implements the gob.GobEncoder interface.\nfunc (o Option[T]) GobEncode() ([]byte, error) {\n\treturn o.MarshalBinary()\n}\n\n// GobDecode implements the gob.GobDecoder interface.\nfunc (o *Option[T]) GobDecode(data []byte) error {\n\treturn o.UnmarshalBinary(data)\n}\n\n// Scan implements the SQL sql.Scanner interface.\nfunc (o *Option[T]) Scan(src any) error {\n\tif src == nil {\n\t\to.isPresent = false\n\t\to.value = empty[T]()\n\t\treturn nil\n\t}\n\n\t// is is only possible to assert interfaces, so convert first\n\t// https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#why-not-permit-type-assertions-on-values-whose-type-is-a-type-parameter\n\tvar t T\n\tif tScanner, ok := interface{}(&t).(sql.Scanner); ok {\n\t\tif err := tScanner.Scan(src); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to scan: %w\", err)\n\t\t}\n\n\t\to.isPresent = true\n\t\to.value = t\n\t\treturn nil\n\t}\n\n\tif av, err := driver.DefaultParameterConverter.ConvertValue(src); err == nil {\n\t\tif v, ok := av.(T); ok {\n\t\t\to.isPresent = true\n\t\t\to.value = v\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn o.scanConvertValue(src)\n}\n\n// Value implements the driver Valuer interface.\nfunc (o Option[T]) Value() (driver.Value, error) {\n\tif !o.isPresent {\n\t\treturn nil, nil\n\t}\n\n\treturn driver.DefaultParameterConverter.ConvertValue(o.value)\n}\n\n// leftValue returns an error if the Option is None, otherwise nil\n//\n//nolint:unused\nfunc (o Option[T]) leftValue() error {\n\tif !o.isPresent {\n\t\treturn optionNoSuchElement\n\t}\n\treturn nil\n}\n\n// rightValue returns the value if the Option is Some, otherwise the zero value of T\n//\n//nolint:unused\nfunc (o Option[T]) rightValue() T {\n\tif !o.isPresent {\n\t\tvar zero T\n\t\treturn zero\n\t}\n\treturn o.value\n}\n\n// hasLeftValue returns true if the Option represents a None state\n//\n//nolint:unused\nfunc (o Option[T]) hasLeftValue() bool {\n\treturn !o.isPresent\n}\n"
        },
        {
          "name": "option_example_test.go",
          "type": "blob",
          "size": 5.7890625,
          "content": "package mo\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\nfunc ExampleSome() {\n\tsome := Some(42)\n\tresult := some.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleNone() {\n\tnone := None[int]()\n\tresult := none.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleTupleToOption() {\n\tm := map[string]int{\n\t\t\"foo\": 21,\n\t\t\"bar\": 42,\n\t\t\"baz\": 84,\n\t}\n\n\tvalue, ok := m[\"hello world\"]\n\n\tnone := TupleToOption(value, ok)\n\tresult := none.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleEmptyableToOption() {\n\tcb := func(ok bool) error {\n\t\tif ok {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn fmt.Errorf(\"an error\")\n\t}\n\n\terr := cb(false)\n\n\tnone := EmptyableToOption(err)\n\tresult, ok := none.Get()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// an error\n\t// true\n}\n\nfunc ExampleOption_some() {\n\tsome := Some(42)\n\tresult := some.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleOption_none() {\n\tnone := None[int]()\n\tresult := none.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleOption_IsPresent_some() {\n\tsome := Some(42)\n\tresult := some.IsPresent()\n\n\tfmt.Println(result)\n\t// Output: true\n}\n\nfunc ExampleOption_IsPresent_none() {\n\tnone := None[int]()\n\tresult := none.IsPresent()\n\n\tfmt.Println(result)\n\t// Output: false\n}\n\nfunc ExampleOption_IsAbsent_some() {\n\tsome := Some(42)\n\tresult := some.IsAbsent()\n\n\tfmt.Println(result)\n\t// Output: false\n}\n\nfunc ExampleOption_IsAbsent_none() {\n\tnone := None[int]()\n\tresult := none.IsAbsent()\n\n\tfmt.Println(result)\n\t// Output: true\n}\n\nfunc ExampleOption_Size_some() {\n\tsome := Some(42)\n\tresult := some.Size()\n\n\tfmt.Println(result)\n\t// Output: 1\n}\n\nfunc ExampleOption_Size_none() {\n\tnone := None[int]()\n\tresult := none.Size()\n\n\tfmt.Println(result)\n\t// Output: 0\n}\n\nfunc ExampleOption_Get_some() {\n\tsome := Some(42)\n\tresult, ok := some.Get()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// 42\n\t// true\n}\n\nfunc ExampleOption_Get_none() {\n\tnone := None[int]()\n\tresult, ok := none.Get()\n\n\tfmt.Println(result)\n\tfmt.Println(ok)\n\t// Output:\n\t// 0\n\t// false\n}\n\nfunc ExampleOption_MustGet_some() {\n\tsome := Some(42)\n\tresult := some.MustGet()\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\n// func ExampleOption_MustGet_none() {\n// \tnone := None[int]()\n// \tresult := none.MustGet()\n\n// \tfmt.Println(result)\n// \t// Output: panics\n// }\n\nfunc ExampleOption_OrElse_some() {\n\tsome := Some(42)\n\tresult := some.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleOption_OrElse_none() {\n\tnone := None[int]()\n\tresult := none.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleOption_OrEmpty_some() {\n\tsome := Some(42)\n\tresult := some.OrEmpty()\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleOption_OrEmpty_none() {\n\tnone := None[int]()\n\tresult := none.OrEmpty()\n\n\tfmt.Println(result)\n\t// Output: 0\n}\n\nfunc ExampleOption_ToPointer_some() {\n\tsome := Some(42)\n\tresult := some.ToPointer()\n\n\tfmt.Println(*result)\n\t// Output: 42\n}\n\nfunc ExampleOption_ToPointer_none() {\n\tnone := None[int]()\n\tresult := none.ToPointer()\n\n\tfmt.Println(result)\n\t// Output: <nil>\n}\n\nfunc ExampleOption_Match_some() {\n\tsome := Some(42)\n\tresult := some.Match(\n\t\tfunc(i int) (int, bool) {\n\t\t\treturn 0, false\n\t\t},\n\t\tfunc() (int, bool) {\n\t\t\treturn 2, true\n\t\t},\n\t)\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: false 0\n}\n\nfunc ExampleOption_Match_none() {\n\tnone := None[int]()\n\tresult := none.Match(\n\t\tfunc(i int) (int, bool) {\n\t\t\treturn 0, false\n\t\t},\n\t\tfunc() (int, bool) {\n\t\t\treturn 2, true\n\t\t},\n\t)\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: true 2\n}\n\nfunc ExampleOption_Map_some() {\n\tsome := Some(42)\n\tresult := some.Map(func(i int) (int, bool) {\n\t\treturn 1234, true\n\t})\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: true 1234\n}\n\nfunc ExampleOption_Map_none() {\n\tnone := None[int]()\n\tresult := none.Map(func(i int) (int, bool) {\n\t\treturn 1234, true\n\t})\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: false 0\n}\n\nfunc ExampleOption_MapNone_some() {\n\tsome := Some(42)\n\tresult := some.MapNone(func() (int, bool) {\n\t\treturn 1234, true\n\t})\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: true 42\n}\n\nfunc ExampleOption_MapNone_none() {\n\tnone := None[int]()\n\tresult := none.MapNone(func() (int, bool) {\n\t\treturn 1234, true\n\t})\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: true 1234\n}\n\nfunc ExampleOption_FlatMap_some() {\n\tsome := Some(42)\n\tresult := some.FlatMap(func(i int) Option[int] {\n\t\treturn Some(21)\n\t})\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: true 21\n}\n\nfunc ExampleOption_FlatMap_none() {\n\tnone := None[int]()\n\tresult := none.FlatMap(func(i int) Option[int] {\n\t\treturn Some(21)\n\t})\n\n\tfmt.Println(result.IsPresent(), result.OrEmpty())\n\t// Output: false 0\n}\n\nfunc ExampleOption_MarshalJSON_some() {\n\ttype test struct {\n\t\tEmail Option[string] `json:\"email\"`\n\t}\n\n\tvalue := test{Email: Some(\"samuel@example.com\")}\n\tresult, err := json.Marshal(value)\n\n\tfmt.Println(string(result))\n\tfmt.Println(err)\n\t// Output:\n\t// {\"email\":\"samuel@example.com\"}\n\t// <nil>\n}\n\nfunc ExampleOption_MarshalJSON_none() {\n\ttype test struct {\n\t\tEmail Option[string] `json:\"email\"`\n\t}\n\n\tvalue := test{Email: None[string]()}\n\tresult, err := json.Marshal(value)\n\n\tfmt.Println(string(result))\n\tfmt.Println(err)\n\t// Output:\n\t// {\"email\":null}\n\t// <nil>\n}\n\nfunc ExampleOption_UnmarshalJSON_some() {\n\ttype test struct {\n\t\tEmail Option[string] `json:\"email\"`\n\t}\n\n\tvalue := []byte(`{\"email\":\"samuel@example.com\"}`)\n\n\tvar result test\n\terr := json.Unmarshal(value, &result)\n\n\tfmt.Println(result.Email.Get())\n\tfmt.Println(err)\n\t// Output:\n\t// samuel@example.com true\n\t// <nil>\n}\n\nfunc ExampleOption_UnmarshalJSON_none() {\n\ttype test struct {\n\t\tEmail Option[string] `json:\"email\"`\n\t}\n\n\tvalue := []byte(`{\"email\":null}`)\n\n\tvar result test\n\terr := json.Unmarshal(value, &result)\n\n\tfmt.Println(result.Email.Get())\n\tfmt.Println(err)\n\t// Output:\n\t// false\n\t// <nil>\n}\n"
        },
        {
          "name": "option_go118.go",
          "type": "blob",
          "size": 7.5078125,
          "content": "//go:build !go1.22\n// +build !go1.22\n\npackage mo\n\n//\n// sql.Null[T] has been introduce in go1.22\n// This file is a copy of stdlib and ensure retro-compatibility.\n// See https://github.com/samber/mo/pull/49\n//\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar errNilPtr = errors.New(\"destination pointer is nil\")\n\nfunc cloneBytes(b []byte) []byte {\n\tif b == nil {\n\t\treturn nil\n\t}\n\tc := make([]byte, len(b))\n\tcopy(c, b)\n\treturn c\n}\n\nfunc asString(src any) string {\n\tswitch v := src.(type) {\n\tcase string:\n\t\treturn v\n\tcase []byte:\n\t\treturn string(v)\n\t}\n\trv := reflect.ValueOf(src)\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.FormatInt(rv.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.FormatUint(rv.Uint(), 10)\n\tcase reflect.Float64:\n\t\treturn strconv.FormatFloat(rv.Float(), 'g', -1, 64)\n\tcase reflect.Float32:\n\t\treturn strconv.FormatFloat(rv.Float(), 'g', -1, 32)\n\tcase reflect.Bool:\n\t\treturn strconv.FormatBool(rv.Bool())\n\t}\n\treturn fmt.Sprintf(\"%v\", src)\n}\n\nfunc asBytes(buf []byte, rv reflect.Value) (b []byte, ok bool) {\n\tswitch rv.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.AppendInt(buf, rv.Int(), 10), true\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.AppendUint(buf, rv.Uint(), 10), true\n\tcase reflect.Float32:\n\t\treturn strconv.AppendFloat(buf, rv.Float(), 'g', -1, 32), true\n\tcase reflect.Float64:\n\t\treturn strconv.AppendFloat(buf, rv.Float(), 'g', -1, 64), true\n\tcase reflect.Bool:\n\t\treturn strconv.AppendBool(buf, rv.Bool()), true\n\tcase reflect.String:\n\t\ts := rv.String()\n\t\treturn append(buf, s...), true\n\t}\n\treturn\n}\n\nfunc strconvErr(err error) error {\n\tif ne, ok := err.(*strconv.NumError); ok {\n\t\treturn ne.Err\n\t}\n\treturn err\n}\n\n// convertAssignRows copies to dest the value in src, converting it if possible.\n// An error is returned if the copy would result in loss of information.\n// dest should be a pointer type. If rows is passed in, the rows will\n// be used as the parent for any cursor values converted from a\n// driver.Rows to a *Rows.\nfunc convertAssign(dest, src any) error {\n\t// Common cases, without reflect.\n\tswitch s := src.(type) {\n\tcase string:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = []byte(s)\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = append((*d)[:0], s...)\n\t\t\treturn nil\n\t\t}\n\tcase []byte:\n\t\tswitch d := dest.(type) {\n\t\tcase *string:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = string(s)\n\t\t\treturn nil\n\t\tcase *any:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = cloneBytes(s)\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = cloneBytes(s)\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s\n\t\t\treturn nil\n\t\t}\n\tcase time.Time:\n\t\tswitch d := dest.(type) {\n\t\tcase *time.Time:\n\t\t\t*d = s\n\t\t\treturn nil\n\t\tcase *string:\n\t\t\t*d = s.Format(time.RFC3339Nano)\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = []byte(s.Format(time.RFC3339Nano))\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = s.AppendFormat((*d)[:0], time.RFC3339Nano)\n\t\t\treturn nil\n\t\t}\n\tcase nil:\n\t\tswitch d := dest.(type) {\n\t\tcase *any:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\tcase *[]byte:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\tcase *sql.RawBytes:\n\t\t\tif d == nil {\n\t\t\t\treturn errNilPtr\n\t\t\t}\n\t\t\t*d = nil\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvar sv reflect.Value\n\n\tswitch d := dest.(type) {\n\tcase *string:\n\t\tsv = reflect.ValueOf(src)\n\t\tswitch sv.Kind() {\n\t\tcase reflect.Bool,\n\t\t\treflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,\n\t\t\treflect.Float32, reflect.Float64:\n\t\t\t*d = asString(src)\n\t\t\treturn nil\n\t\t}\n\tcase *[]byte:\n\t\tsv = reflect.ValueOf(src)\n\t\tif b, ok := asBytes(nil, sv); ok {\n\t\t\t*d = b\n\t\t\treturn nil\n\t\t}\n\tcase *sql.RawBytes:\n\t\tsv = reflect.ValueOf(src)\n\t\tif b, ok := asBytes([]byte(*d)[:0], sv); ok {\n\t\t\t*d = sql.RawBytes(b)\n\t\t\treturn nil\n\t\t}\n\tcase *bool:\n\t\tbv, err := driver.Bool.ConvertValue(src)\n\t\tif err == nil {\n\t\t\t*d = bv.(bool)\n\t\t}\n\t\treturn err\n\tcase *any:\n\t\t*d = src\n\t\treturn nil\n\t}\n\n\tif scanner, ok := dest.(sql.Scanner); ok {\n\t\treturn scanner.Scan(src)\n\t}\n\n\tdpv := reflect.ValueOf(dest)\n\tif dpv.Kind() != reflect.Pointer {\n\t\treturn errors.New(\"destination not a pointer\")\n\t}\n\tif dpv.IsNil() {\n\t\treturn errNilPtr\n\t}\n\n\tif !sv.IsValid() {\n\t\tsv = reflect.ValueOf(src)\n\t}\n\n\tdv := reflect.Indirect(dpv)\n\tif sv.IsValid() && sv.Type().AssignableTo(dv.Type()) {\n\t\tswitch b := src.(type) {\n\t\tcase []byte:\n\t\t\tdv.Set(reflect.ValueOf(cloneBytes(b)))\n\t\tdefault:\n\t\t\tdv.Set(sv)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif dv.Kind() == sv.Kind() && sv.Type().ConvertibleTo(dv.Type()) {\n\t\tdv.Set(sv.Convert(dv.Type()))\n\t\treturn nil\n\t}\n\n\t// The following conversions use a string value as an intermediate representation\n\t// to convert between various numeric types.\n\t//\n\t// This also allows scanning into user defined types such as \"type Int int64\".\n\t// For symmetry, also check for string destination types.\n\tswitch dv.Kind() {\n\tcase reflect.Pointer:\n\t\tif src == nil {\n\t\t\tdv.Set(reflect.Zero(dv.Type()))\n\t\t\treturn nil\n\t\t}\n\t\tdv.Set(reflect.New(dv.Type().Elem()))\n\t\treturn convertAssign(dv.Interface(), src)\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"converting NULL to %s is unsupported\", dv.Kind())\n\t\t}\n\t\ts := asString(src)\n\t\ti64, err := strconv.ParseInt(s, 10, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetInt(i64)\n\t\treturn nil\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"converting NULL to %s is unsupported\", dv.Kind())\n\t\t}\n\t\ts := asString(src)\n\t\tu64, err := strconv.ParseUint(s, 10, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetUint(u64)\n\t\treturn nil\n\tcase reflect.Float32, reflect.Float64:\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"converting NULL to %s is unsupported\", dv.Kind())\n\t\t}\n\t\ts := asString(src)\n\t\tf64, err := strconv.ParseFloat(s, dv.Type().Bits())\n\t\tif err != nil {\n\t\t\terr = strconvErr(err)\n\t\t\treturn fmt.Errorf(\"converting driver.Value type %T (%q) to a %s: %v\", src, s, dv.Kind(), err)\n\t\t}\n\t\tdv.SetFloat(f64)\n\t\treturn nil\n\tcase reflect.String:\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"converting NULL to %s is unsupported\", dv.Kind())\n\t\t}\n\t\tswitch v := src.(type) {\n\t\tcase string:\n\t\t\tdv.SetString(v)\n\t\t\treturn nil\n\t\tcase []byte:\n\t\t\tdv.SetString(string(v))\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"unsupported Scan, storing driver.Value type %T into type %T\", src, dest)\n}\n\nfunc (o *Option[T]) scanConvertValue(src any) error {\n\t// we try to convertAssign values that we can't directly assign because ConvertValue\n\t// will return immediately for v that is already a Value, even if it is a different\n\t// Value type than the one we expect here.\n\tvar dest T\n\tif err := convertAssign(&dest, src); err == nil {\n\t\to.isPresent = true\n\t\to.value = dest\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"failed to scan Option[T]\")\n}\n"
        },
        {
          "name": "option_go122.go",
          "type": "blob",
          "size": 0.5009765625,
          "content": "//go:build go1.22\n// +build go1.22\n\npackage mo\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n)\n\nfunc (o *Option[T]) scanConvertValue(src any) error {\n\t// we try to convertAssign values that we can't directly assign because ConvertValue\n\t// will return immediately for v that is already a Value, even if it is a different\n\t// Value type than the one we expect here.\n\tvar st sql.Null[T]\n\tif err := st.Scan(src); err == nil {\n\t\to.isPresent = true\n\t\to.value = st.V\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"failed to scan Option[T]\")\n}\n"
        },
        {
          "name": "option_test.go",
          "type": "blob",
          "size": 11.8505859375,
          "content": "package mo\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOptionSome(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Option[int]{value: 42, isPresent: true}, Some(42))\n}\n\nfunc TestOptionNone(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Option[int]{isPresent: false}, None[int]())\n}\n\nfunc TestTupleToOption(t *testing.T) {\n\tis := assert.New(t)\n\n\tcb := func(v int, ok bool) func() (int, bool) {\n\t\treturn func() (int, bool) {\n\t\t\treturn v, ok\n\t\t}\n\t}\n\n\tis.Equal(Option[int]{isPresent: false}, TupleToOption(cb(42, false)()))\n\tis.Equal(Option[int]{isPresent: true, value: 42}, TupleToOption(cb(42, true)()))\n}\n\nfunc TestOptionEmptyableToOption(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Option[error]{isPresent: false}, EmptyableToOption[error](nil))\n\tis.Equal(Option[error]{isPresent: true, value: assert.AnError}, EmptyableToOption(assert.AnError))\n\n\tis.Equal(Option[int]{isPresent: false}, EmptyableToOption(0))\n\tis.Equal(Option[int]{isPresent: true, value: 42}, EmptyableToOption(42))\n}\n\nfunc TestOptionPointerToOption(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Option[error]{isPresent: false}, PointerToOption[error](nil))\n\tis.Equal(Option[error]{isPresent: true, value: assert.AnError}, PointerToOption(&assert.AnError))\n\n\tzero := 0\n\tfortyTwo := 42\n\tis.Equal(Option[int]{isPresent: true, value: 0}, PointerToOption(&zero))\n\tis.Equal(Option[int]{isPresent: true, value: 42}, PointerToOption(&fortyTwo))\n}\n\nfunc TestOptionIsPresent(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(Some(42).IsPresent())\n\tis.False(None[int]().IsPresent())\n}\n\nfunc TestOptionIsAbsent(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.False(Some(42).IsAbsent())\n\tis.True(None[int]().IsAbsent())\n}\n\nfunc TestOptionSize(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(1, Some(42).Size())\n\tis.Equal(0, None[int]().Size())\n}\n\nfunc TestOptionGet(t *testing.T) {\n\tis := assert.New(t)\n\n\tv1, ok1 := Some(42).Get()\n\tv2, ok2 := None[int]().Get()\n\n\tis.Equal(42, v1)\n\tis.Equal(true, ok1)\n\tis.Equal(0, v2)\n\tis.Equal(false, ok2)\n}\n\nfunc TestOptionMustGet(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.NotPanics(func() {\n\t\tSome(42).MustGet()\n\t})\n\tis.Panics(func() {\n\t\tNone[int]().MustGet()\n\t})\n\n\tis.Equal(42, Some(42).MustGet())\n}\n\nfunc TestOptionOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(42, Some(42).OrElse(21))\n\tis.Equal(21, None[int]().OrElse(21))\n}\n\nfunc TestOptionOrEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(42, Some(42).OrEmpty())\n\tis.Equal(0, None[int]().OrEmpty())\n}\n\nfunc TestOptionToPointer(t *testing.T) {\n\tis := assert.New(t)\n\n\tp := Some(42).ToPointer()\n\tis.NotNil(p)\n\tis.Equal(42, *p)\n\n\tis.Nil(None[int]().ToPointer())\n}\n\nfunc TestOptionForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\ttmp := 0\n\tf := func(x int) {\n\t\ttmp = x\n\t}\n\n\tNone[int]().ForEach(f)\n\tis.Equal(0, tmp)\n\n\tSome(42).ForEach(f)\n\tis.Equal(42, tmp)\n}\n\nfunc TestOptionMatch(t *testing.T) {\n\tis := assert.New(t)\n\n\tonValue := func(i int) (int, bool) {\n\t\treturn i * 2, true\n\t}\n\tonNone := func() (int, bool) {\n\t\treturn 0, false\n\t}\n\n\topt1 := Some(21).Match(onValue, onNone)\n\topt2 := None[int]().Match(onValue, onNone)\n\n\tis.Equal(Option[int]{value: 42, isPresent: true}, opt1)\n\tis.Equal(Option[int]{value: 0, isPresent: false}, opt2)\n}\n\nfunc TestOptionMap(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Some(21).Map(func(i int) (int, bool) {\n\t\treturn i * 2, true\n\t})\n\topt2 := None[int]().Map(func(i int) (int, bool) {\n\t\tis.Fail(\"should not be called\")\n\t\treturn 42, true\n\t})\n\n\tis.Equal(Option[int]{value: 42, isPresent: true}, opt1)\n\tis.Equal(Option[int]{value: 0, isPresent: false}, opt2)\n}\n\nfunc TestOptionMapNone(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Some(21).MapNone(func() (int, bool) {\n\t\tis.Fail(\"should not be called\")\n\t\treturn 42, true\n\t})\n\topt2 := None[int]().MapNone(func() (int, bool) {\n\t\treturn 42, true\n\t})\n\n\tis.Equal(Option[int]{value: 21, isPresent: true}, opt1)\n\tis.Equal(Option[int]{value: 42, isPresent: true}, opt2)\n}\n\nfunc TestOptionFlatMap(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Some(21).FlatMap(func(i int) Option[int] {\n\t\treturn Some(42)\n\t})\n\topt2 := None[int]().FlatMap(func(i int) Option[int] {\n\t\treturn Some(42)\n\t})\n\n\tis.Equal(Option[int]{value: 42, isPresent: true}, opt1)\n\tis.Equal(Option[int]{value: 0, isPresent: false}, opt2)\n}\n\nfunc TestOptionMarshalJSON(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Some(\"foo\")\n\toption2 := None[string]()\n\toption3 := Some(\"\")\n\n\tvalue, err := option1.MarshalJSON()\n\tis.NoError(err)\n\tis.Equal(`\"foo\"`, string(value))\n\n\tvalue, err = option2.MarshalJSON()\n\tis.NoError(err)\n\tis.Equal(`null`, string(value))\n\n\tvalue, err = option3.MarshalJSON()\n\tis.NoError(err)\n\tis.Equal(`\"\"`, string(value))\n\n\ttype testStruct struct {\n\t\tField Option[string]\n\t}\n\n\toptionInStruct := testStruct{\n\t\tField: option1,\n\t}\n\tvar marshalled []byte\n\tmarshalled, err = json.Marshal(optionInStruct)\n\tis.NoError(err)\n\tis.Equal(`{\"Field\":\"foo\"}`, string(marshalled))\n}\n\nfunc TestOptionUnmarshalJSON(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Some(\"foo\")\n\toption2 := None[string]()\n\n\terr := option1.UnmarshalJSON([]byte(`\"foo\"`))\n\tis.NoError(err)\n\tis.Equal(Some(\"foo\"), option1)\n\n\tvar res Option[string]\n\terr = json.Unmarshal([]byte(`\"foo\"`), &res)\n\tis.NoError(err)\n\tis.Equal(res, option1)\n\n\terr = option2.UnmarshalJSON([]byte(`null`))\n\tis.NoError(err)\n\tis.Equal(None[string](), option2)\n\n\ttype testStruct struct {\n\t\tField Option[string]\n\t}\n\n\tunmarshal := testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\": \"foo\"}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{\n\t\tField: Some(\"foo\"),\n\t}, unmarshal)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\": null}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: None[string]()}, unmarshal)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: None[string]()}, unmarshal)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\": \"\"}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: Some(\"\")}, unmarshal)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\": \"}`), &unmarshal)\n\tis.Error(err)\n}\n\nfunc TestOptionMarshalText(t *testing.T) {\n\tis := assert.New(t)\n\n\tbytes1, err1 := Some(42).MarshalText()\n\tbytes2, err2 := None[int]().MarshalText()\n\tbytes3, err3 := Some(\"42\").MarshalText()\n\n\tis.Equal([]byte(\"42\"), bytes1)\n\tis.Nil(err1)\n\tis.Equal([]byte(\"null\"), bytes2)\n\tis.Nil(err2)\n\tis.Equal([]byte(\"\\\"42\\\"\"), bytes3)\n\tis.Nil(err3)\n}\n\nfunc TestOptionUnmarshalText(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Option[int]{}\n\toption2 := Option[int]{}\n\toption3 := Option[string]{}\n\n\terr1 := option1.UnmarshalText([]byte(\"null\"))\n\terr2 := option2.UnmarshalText([]byte(\"42\"))\n\terr3 := option3.UnmarshalText([]byte(\"\\\"42\\\"\"))\n\n\tis.Equal(None[int](), option1)\n\tis.Nil(err1)\n\tis.Equal(Some[int](42), option2)\n\tis.Nil(err2)\n\tis.Equal(Some[string](\"42\"), option3)\n\tis.Nil(err3)\n}\n\nfunc TestOptionMarshalBinary(t *testing.T) {\n\tis := assert.New(t)\n\n\tbinary1, err1 := Some(42).MarshalBinary()\n\tbinary2, err2 := None[int]().MarshalBinary()\n\tbinary3, err3 := Some(\"42\").MarshalBinary()\n\n\tis.Equal([]byte{1, 0x3, 0x4, 0x0, 0x54}, binary1)\n\tis.Nil(err1)\n\tis.Equal([]byte{0}, binary2)\n\tis.Nil(err2)\n\tis.Equal([]byte{1, 0x5, 0xc, 0x0, 0x2, 0x34, 0x32}, binary3)\n\tis.Nil(err3)\n}\n\nfunc TestOptionUnmarshalBinary(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Option[int]{}\n\toption2 := Option[int]{}\n\toption3 := Option[string]{}\n\n\terr1 := option1.UnmarshalBinary([]byte{0})\n\terr2 := option2.UnmarshalBinary([]byte{1, 0x3, 0x4, 0x0, 0x54})\n\terr3 := option3.UnmarshalBinary([]byte{1, 0x5, 0xc, 0x0, 0x2, 0x34, 0x32})\n\n\tis.Equal(None[int](), option1)\n\tis.Nil(err1)\n\tis.Equal(Some[int](42), option2)\n\tis.Nil(err2)\n\tis.Equal(Some[string](\"42\"), option3)\n\tis.Nil(err3)\n}\n\nfunc TestOptionGobEncode(t *testing.T) {\n\tis := assert.New(t)\n\n\tbinary1, err1 := Some(42).GobEncode()\n\tbinary2, err2 := None[int]().GobEncode()\n\tbinary3, err3 := Some(\"42\").GobEncode()\n\n\tis.Equal([]byte{1, 0x3, 0x4, 0x0, 0x54}, binary1)\n\tis.Nil(err1)\n\tis.Equal([]byte{0}, binary2)\n\tis.Nil(err2)\n\tis.Equal([]byte{1, 0x5, 0xc, 0x0, 0x2, 0x34, 0x32}, binary3)\n\tis.Nil(err3)\n}\n\nfunc TestOptionGobDecode(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Option[int]{}\n\toption2 := Option[int]{}\n\toption3 := Option[string]{}\n\n\terr1 := option1.GobDecode([]byte{0})\n\terr2 := option2.GobDecode([]byte{1, 0x3, 0x4, 0x0, 0x54})\n\terr3 := option3.GobDecode([]byte{1, 0x5, 0xc, 0x0, 0x2, 0x34, 0x32})\n\n\tis.Equal(None[int](), option1)\n\tis.Nil(err1)\n\tis.Equal(Some[int](42), option2)\n\tis.Nil(err2)\n\tis.Equal(Some[string](\"42\"), option3)\n\tis.Nil(err3)\n}\n\nfunc TestOptionScan(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Some(\"foo\")\n\toption2 := None[string]()\n\n\tnullString1 := sql.NullString{String: \"foo\", Valid: true}\n\tnullString2 := sql.NullString{String: \"\", Valid: false}\n\n\tres1Exp, err1Exp := nullString1.Value()\n\tres1, err1 := option1.Value()\n\n\tres2Exp, err2Exp := nullString2.Value()\n\tres2, err2 := option2.Value()\n\n\tis.Equal(res1Exp, res1)\n\tis.Equal(err1Exp, err1)\n\tis.Equal(res2Exp, res2)\n\tis.Equal(err2Exp, err2)\n}\n\nfunc TestOptionScanWithPossibleConvert(t *testing.T) {\n\tis := assert.New(t)\n\n\t// As passed by the sql package in some cases, src is a []byte.\n\t// https://github.com/golang/go/blob/071b8d51c1a70fa6b12f0bed2e93370e193333fd/src/database/sql/convert.go#L396\n\tsrc1 := []byte{65, 66, 67}\n\tdest1 := None[string]()\n\tsrc2 := int32(32)\n\tdest2 := None[int]()\n\n\terr1 := dest1.Scan(src1)\n\terr2 := dest2.Scan(src2)\n\n\tis.Nil(err1)\n\tis.Equal(Some(\"ABC\"), dest1)\n\tis.Nil(err2)\n\tis.Equal(Some(32), dest2)\n}\n\nfunc TestOptionValue(t *testing.T) {\n\tis := assert.New(t)\n\n\toption1 := Option[string]{}\n\toption2 := Option[string]{}\n\n\tnullString1, _ := sql.NullString{String: \"foo\", Valid: true}.Value()\n\tnullString2, _ := sql.NullString{String: \"\", Valid: false}.Value()\n\n\terr1 := option1.Scan(nullString1)\n\terr2 := option2.Scan(nullString2)\n\n\tis.EqualValues(Some(\"foo\"), option1)\n\tis.Nil(err1)\n\tis.EqualValues(None[string](), option2)\n\tis.Nil(err2)\n}\n\nfunc TestOptionValueWithPossibleConvert(t *testing.T) {\n\tis := assert.New(t)\n\n\topt := Some(uint32(42))\n\texpected := int64(42)\n\n\tvalue, err := opt.Value()\n\tis.Nil(err)\n\tis.Equal(expected, value)\n}\n\ntype SomeScanner struct {\n\tCool bool\n\tSome int\n}\n\nfunc (ss *SomeScanner) Scan(src any) error {\n\tval, ok := src.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"cannot scan - src is not a string\")\n\t}\n\n\tvar unmarshalled SomeScanner\n\tif err := json.Unmarshal([]byte(val), &unmarshalled); err != nil {\n\t\treturn fmt.Errorf(\"failed to unmarshal json: %w\", err)\n\t}\n\n\t*ss = unmarshalled\n\treturn nil\n}\n\n// If T is a sql.Scanner, make use of that.\nfunc TestOptionScanner(t *testing.T) {\n\tis := assert.New(t)\n\n\tjsonString := `{\"cool\": true, \"some\": 123}`\n\tnullString, _ := sql.NullString{}.Value()\n\n\tvar someScanner Option[SomeScanner]\n\tvar noneScanner Option[SomeScanner]\n\n\terr1 := someScanner.Scan(jsonString)\n\terr2 := noneScanner.Scan(nullString)\n\n\tis.NoError(err1)\n\tis.EqualValues(Some(SomeScanner{Cool: true, Some: 123}), someScanner)\n\tis.NoError(err2)\n\tis.EqualValues(None[SomeScanner](), noneScanner)\n}\n\n// TestOptionFoldSuccess tests the Fold method with a successful result.\nfunc TestOptionFoldSuccess(t *testing.T) {\n\tis := assert.New(t)\n\toption := Option[int]{isPresent: true, value: 10}\n\n\tsuccessFunc := func(value int) string {\n\t\treturn fmt.Sprintf(\"Success: %v\", value)\n\t}\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure: %v\", err)\n\t}\n\n\tfolded := Fold[error, int, string](option, successFunc, failureFunc)\n\texpected := \"Success: 10\"\n\n\tis.Equal(expected, folded)\n}\n\n// TestOptionFoldFailure tests the Fold method with a failure result.\nfunc TestOptionFoldFailure(t *testing.T) {\n\tis := assert.New(t)\n\toption := Option[int]{isPresent: false}\n\n\tsuccessFunc := func(value int) string {\n\t\treturn fmt.Sprintf(\"Success: %v\", value)\n\t}\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure: %v\", err)\n\t}\n\n\tfolded := Fold[error, int, string](option, successFunc, failureFunc)\n\texpected := fmt.Sprintf(\"Failure: %v\", optionNoSuchElement)\n\n\tis.Equal(expected, folded)\n}\n"
        },
        {
          "name": "options",
          "type": "tree",
          "content": null
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 5.84375,
          "content": "package mo\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Ok builds a Result when value is valid.\n// Play: https://go.dev/play/p/PDwADdzNoyZ\nfunc Ok[T any](value T) Result[T] {\n\treturn Result[T]{\n\t\tvalue: value,\n\t\tisErr: false,\n\t}\n}\n\n// Err builds a Result when value is invalid.\n// Play: https://go.dev/play/p/PDwADdzNoyZ\nfunc Err[T any](err error) Result[T] {\n\treturn Result[T]{\n\t\terr:   err,\n\t\tisErr: true,\n\t}\n}\n\n// Errf builds a Result when value is invalid.\n// Errf formats according to a format specifier and returns the error as a value that satisfies Result[T].\n// Play: https://go.dev/play/p/N43w92SM-Bs\nfunc Errf[T any](format string, a ...any) Result[T] {\n\treturn Err[T](fmt.Errorf(format, a...))\n}\n\n// TupleToResult convert a pair of T and error into a Result.\n// Play: https://go.dev/play/p/KWjfqQDHQwa\nfunc TupleToResult[T any](value T, err error) Result[T] {\n\tif err != nil {\n\t\treturn Err[T](err)\n\t}\n\treturn Ok(value)\n}\n\n// Try returns either a Ok or Err object.\n// Play: https://go.dev/play/p/ilOlQx-Mx42\nfunc Try[T any](f func() (T, error)) Result[T] {\n\treturn TupleToResult(f())\n}\n\n// Result represents a result of an action having one\n// of the following output: success or failure.\n// An instance of Result is an instance of either Ok or Err.\n// It could be compared to `Either[error, T]`.\ntype Result[T any] struct {\n\tisErr bool\n\tvalue T\n\terr   error\n}\n\n// IsOk returns true when value is valid.\n// Play: https://go.dev/play/p/sfNvBQyZfgU\nfunc (r Result[T]) IsOk() bool {\n\treturn !r.isErr\n}\n\n// IsError returns true when value is invalid.\n// Play: https://go.dev/play/p/xkV9d464scV\nfunc (r Result[T]) IsError() bool {\n\treturn r.isErr\n}\n\n// Error returns error when value is invalid or nil.\n// Play: https://go.dev/play/p/CSkHGTyiXJ5\nfunc (r Result[T]) Error() error {\n\treturn r.err\n}\n\n// Get returns value and error.\n// Play: https://go.dev/play/p/8KyX3z6TuNo\nfunc (r Result[T]) Get() (T, error) {\n\tif r.isErr {\n\t\treturn empty[T](), r.err\n\t}\n\n\treturn r.value, nil\n}\n\n// MustGet returns value when Result is valid or panics.\n// Play: https://go.dev/play/p/8LSlndHoTAE\nfunc (r Result[T]) MustGet() T {\n\tif r.isErr {\n\t\tpanic(r.err)\n\t}\n\n\treturn r.value\n}\n\n// OrElse returns value when Result is valid or default value.\n// Play: https://go.dev/play/p/MN_ULx0soi6\nfunc (r Result[T]) OrElse(fallback T) T {\n\tif r.isErr {\n\t\treturn fallback\n\t}\n\n\treturn r.value\n}\n\n// OrEmpty returns value when Result is valid or empty value.\n// Play: https://go.dev/play/p/rdKtBmOcMLh\nfunc (r Result[T]) OrEmpty() T {\n\treturn r.value\n}\n\n// ToEither transforms a Result into an Either type.\n// Play: https://go.dev/play/p/Uw1Zz6b952q\nfunc (r Result[T]) ToEither() Either[error, T] {\n\tif r.isErr {\n\t\treturn Left[error, T](r.err)\n\t}\n\n\treturn Right[error, T](r.value)\n}\n\n// ForEach executes the given side-effecting function if Result is valid.\nfunc (r Result[T]) ForEach(mapper func(value T)) {\n\tif !r.isErr {\n\t\tmapper(r.value)\n\t}\n}\n\n// Match executes the first function if Result is valid and second function if invalid.\n// It returns a new Result.\n// Play: https://go.dev/play/p/-_eFaLJ31co\nfunc (r Result[T]) Match(onSuccess func(value T) (T, error), onError func(err error) (T, error)) Result[T] {\n\tif r.isErr {\n\t\treturn TupleToResult(onError(r.err))\n\t}\n\treturn TupleToResult(onSuccess(r.value))\n}\n\n// Map executes the mapper function if Result is valid. It returns a new Result.\n// Play: https://go.dev/play/p/-ndpN_b_OSc\nfunc (r Result[T]) Map(mapper func(value T) (T, error)) Result[T] {\n\tif !r.isErr {\n\t\treturn TupleToResult(mapper(r.value))\n\t}\n\n\treturn Err[T](r.err)\n}\n\n// MapErr executes the mapper function if Result is invalid. It returns a new Result.\n// Play: https://go.dev/play/p/WraZixg9GGf\nfunc (r Result[T]) MapErr(mapper func(error) (T, error)) Result[T] {\n\tif r.isErr {\n\t\treturn TupleToResult(mapper(r.err))\n\t}\n\n\treturn Ok(r.value)\n}\n\n// FlatMap executes the mapper function if Result is valid. It returns a new Result.\n// Play: https://go.dev/play/p/Ud5QjZOqg-7\nfunc (r Result[T]) FlatMap(mapper func(value T) Result[T]) Result[T] {\n\tif !r.isErr {\n\t\treturn mapper(r.value)\n\t}\n\n\treturn Err[T](r.err)\n}\n\n// MarshalJSON encodes Result into json, following the JSON-RPC specification for results,\n// with one exception: when the result is an error, the \"code\" field is not included.\n// Reference: https://www.jsonrpc.org/specification\nfunc (o Result[T]) MarshalJSON() ([]byte, error) {\n\tif o.isErr {\n\t\treturn json.Marshal(map[string]any{\n\t\t\t\"error\": map[string]any{\n\t\t\t\t\"message\": o.err.Error(),\n\t\t\t},\n\t\t})\n\t}\n\n\treturn json.Marshal(map[string]any{\n\t\t\"result\": o.value,\n\t})\n}\n\n// UnmarshalJSON decodes json into Result. If \"error\" is set, the result is an\n// Err containing the error message as a generic error object. Otherwise, the\n// result is an Ok containing the result. If the JSON object contains netiher\n// an error nor a result, the result is an Ok containing an empty value. If the\n// JSON object contains both an error and a result, the result is an Err. Finally,\n// if the JSON object contains an error but is not structured correctly (no message\n// field), the unmarshaling fails.\nfunc (o *Result[T]) UnmarshalJSON(data []byte) error {\n\tvar result struct {\n\t\tResult T `json:\"result\"`\n\t\tError  struct {\n\t\t\tMessage string `json:\"message\"`\n\t\t} `json:\"error\"`\n\t}\n\n\tif err := json.Unmarshal(data, &result); err != nil {\n\t\treturn err\n\t}\n\n\tif result.Error.Message != \"\" {\n\t\to.err = errors.New(result.Error.Message)\n\t\to.isErr = true\n\t\treturn nil\n\t}\n\n\to.value = result.Result\n\to.isErr = false\n\treturn nil\n}\n\n// leftValue returns the error if the Result is an error, otherwise nil\n//\n//nolint:unused\nfunc (r Result[T]) leftValue() error {\n\treturn r.err\n}\n\n// rightValue returns the value if the Result is a success, otherwise the zero value of T\n//\n//nolint:unused\nfunc (r Result[T]) rightValue() T {\n\treturn r.value\n}\n\n// hasLeftValue returns true if the Result represents an error state.\n//\n//nolint:unused\nfunc (r Result[T]) hasLeftValue() bool {\n\treturn r.isErr\n}\n"
        },
        {
          "name": "result_example_test.go",
          "type": "blob",
          "size": 5.4189453125,
          "content": "package mo\n\nimport (\n\t\"fmt\"\n)\n\nvar err = fmt.Errorf(\"error\")\n\nfunc ExampleOk() {\n\tok := Ok(42)\n\tresult := ok.OrElse(1234)\n\t_err := ok.Error()\n\n\tfmt.Println(result, _err)\n\t// Output: 42 <nil>\n}\n\nfunc ExampleErr() {\n\tko := Err[int](err)\n\tresult := ko.OrElse(1234)\n\t_err := ko.Error()\n\n\tfmt.Println(result, _err)\n\t// Output: 1234 error\n}\n\nfunc ExampleErrf() {\n\tko := Errf[int](\"error\")\n\tresult := ko.OrElse(1234)\n\t_err := ko.Error()\n\n\tfmt.Println(result, _err)\n\t// Output: 1234 error\n}\n\nfunc ExampleTupleToResult() {\n\trandomFunc := func() (int, error) {\n\t\treturn 42, err\n\t}\n\n\tvalue, _err := randomFunc()\n\n\tnone := TupleToResult(value, _err)\n\tresult := none.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleTry_ok() {\n\trandomFunc := func() (int, error) {\n\t\treturn 42, nil\n\t}\n\n\tresult := Try(randomFunc)\n\tvalue, err := result.Get()\n\n\tfmt.Println(value)\n\tfmt.Println(err)\n\t// Output:\n\t// 42\n\t// <nil>\n}\n\nfunc ExampleTry_err() {\n\trandomFunc := func() (int, error) {\n\t\treturn 42, err\n\t}\n\n\tresult := Try(randomFunc)\n\tvalue, err := result.Get()\n\n\tfmt.Println(value)\n\tfmt.Println(err)\n\t// Output:\n\t// 0\n\t// error\n}\n\nfunc ExampleResult_ok() {\n\tok := Ok(42)\n\tresult := ok.OrElse(1234)\n\t_err := ok.Error()\n\n\tfmt.Println(result, _err)\n\t// Output: 42 <nil>\n}\n\nfunc ExampleResult_err() {\n\tko := Err[int](err)\n\tresult := ko.OrElse(1234)\n\t_err := ko.Error()\n\n\tfmt.Println(result, _err)\n\t// Output: 1234 error\n}\n\nfunc ExampleResult_IsOk_ok() {\n\tok := Ok(42)\n\tresult := ok.IsOk()\n\n\tfmt.Println(result)\n\t// Output: true\n}\n\nfunc ExampleResult_IsOk_err() {\n\tko := Err[int](err)\n\tresult := ko.IsOk()\n\n\tfmt.Println(result)\n\t// Output: false\n}\n\nfunc ExampleResult_IsError_ok() {\n\tok := Ok(42)\n\tresult := ok.IsError()\n\n\tfmt.Println(result)\n\t// Output: false\n}\n\nfunc ExampleResult_IsError_err() {\n\tko := Err[int](err)\n\tresult := ko.IsError()\n\n\tfmt.Println(result)\n\t// Output: true\n}\n\nfunc ExampleResult_Error_ok() {\n\tok := Ok(42)\n\tresult := ok.Error()\n\n\tfmt.Println(result)\n\t// Output: <nil>\n}\n\nfunc ExampleResult_Error_err() {\n\tko := Err[int](err)\n\tresult := ko.Error()\n\n\tfmt.Println(result)\n\t// Output: error\n}\n\nfunc ExampleResult_Get_ok() {\n\tok := Ok(42)\n\tresult, err := ok.Get()\n\n\tfmt.Println(result)\n\tfmt.Println(err)\n\t// Output:\n\t// 42\n\t// <nil>\n}\n\nfunc ExampleResult_Get_err() {\n\tko := Err[int](err)\n\tresult, err := ko.Get()\n\n\tfmt.Println(result)\n\tfmt.Println(err)\n\t// Output:\n\t// 0\n\t// error\n}\n\nfunc ExampleResult_MustGet_ok() {\n\tok := Ok(42)\n\tresult := ok.MustGet()\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\n// func ExampleResult_MustGet_err() {\n// \tko := Err[int](err)\n// \tresult := ko.MustGet()\n\n// \tfmt.Println(result)\n// \t// Output: panics\n// }\n\nfunc ExampleResult_OrElse_ok() {\n\tok := Ok(42)\n\tresult := ok.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleResult_OrElse_err() {\n\tko := Err[int](err)\n\tresult := ko.OrElse(1234)\n\n\tfmt.Println(result)\n\t// Output: 1234\n}\n\nfunc ExampleResult_OrEmpty_ok() {\n\tok := Ok(42)\n\tresult := ok.OrEmpty()\n\n\tfmt.Println(result)\n\t// Output: 42\n}\n\nfunc ExampleResult_OrEmpty_err() {\n\tko := Err[int](err)\n\tresult := ko.OrEmpty()\n\n\tfmt.Println(result)\n\t// Output: 0\n}\n\nfunc ExampleResult_ToEither_ok() {\n\tok := Ok(42)\n\teither := ok.ToEither()\n\n\terr, isLeft := either.Left()\n\tvalue, isRight := either.Right()\n\n\tfmt.Println(isLeft, isRight)\n\tfmt.Println(err)\n\tfmt.Println(value)\n\t// Output:\n\t// false true\n\t// <nil>\n\t// 42\n}\n\nfunc ExampleResult_ToEither_err() {\n\tko := Err[int](err)\n\teither := ko.ToEither()\n\n\terr, isLeft := either.Left()\n\tvalue, isRight := either.Right()\n\n\tfmt.Println(isLeft, isRight)\n\tfmt.Println(err)\n\tfmt.Println(value)\n\t// Output:\n\t// true false\n\t// error\n\t// 0\n}\n\nfunc ExampleResult_Match_ok() {\n\tok := Ok(42)\n\tresult := ok.Match(\n\t\tfunc(i int) (int, error) {\n\t\t\treturn i * 2, nil\n\t\t},\n\t\tfunc(err error) (int, error) {\n\t\t\treturn 21, nil\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: false 84 <nil>\n}\n\nfunc ExampleResult_Match_err() {\n\tko := Err[int](err)\n\tresult := ko.Match(\n\t\tfunc(i int) (int, error) {\n\t\t\treturn i * 2, nil\n\t\t},\n\t\tfunc(err error) (int, error) {\n\t\t\treturn 21, nil\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: false 21 <nil>\n}\n\nfunc ExampleResult_Map_ok() {\n\tok := Ok(42)\n\tresult := ok.Map(\n\t\tfunc(i int) (int, error) {\n\t\t\treturn i * 2, nil\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: false 84 <nil>\n}\n\nfunc ExampleResult_Map_err() {\n\tko := Err[int](err)\n\tresult := ko.Map(\n\t\tfunc(i int) (int, error) {\n\t\t\treturn i * 2, nil\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: true 0 error\n}\n\nfunc ExampleResult_MapErr_ok() {\n\tok := Ok(42)\n\tresult := ok.MapErr(\n\t\tfunc(_err error) (int, error) {\n\t\t\treturn 1234, nil\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: false 42 <nil>\n}\n\nfunc ExampleResult_MapErr_err() {\n\tko := Err[int](err)\n\tresult := ko.MapErr(\n\t\tfunc(_err error) (int, error) {\n\t\t\treturn 1234, nil\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: false 1234 <nil>\n}\n\nfunc ExampleResult_FlatMap_ok() {\n\tok := Ok(42)\n\tresult := ok.FlatMap(\n\t\tfunc(i int) Result[int] {\n\t\t\treturn Ok(1234)\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: false 1234 <nil>\n}\n\nfunc ExampleResult_FlatMap_err() {\n\tko := Err[int](err)\n\tresult := ko.FlatMap(\n\t\tfunc(i int) Result[int] {\n\t\t\treturn Ok(1234)\n\t\t},\n\t)\n\n\tfmt.Println(result.IsError(), result.OrEmpty(), result.Error())\n\t// Output: true 0 error\n}\n"
        },
        {
          "name": "result_test.go",
          "type": "blob",
          "size": 7.8125,
          "content": "package mo\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestResultOk(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Result[int]{value: 42, isErr: false, err: nil}, Ok(42))\n}\n\nfunc TestResultErr(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, Err[int](assert.AnError))\n}\n\nfunc TestResultErrf(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, Errf[int](assert.AnError.Error())) //nolint:govet\n}\n\nfunc TestResultTupleToResult(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, TupleToResult(42, assert.AnError))\n}\n\nfunc TestResultTry(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(Result[int]{value: 42, isErr: false, err: nil}, Try(func() (int, error) {\n\t\treturn 42, nil\n\t}))\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, Try(func() (int, error) {\n\t\treturn 42, assert.AnError\n\t}))\n}\n\nfunc TestResultIsOk(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.True(Ok(42).IsOk())\n\tis.False(Err[int](assert.AnError).IsOk())\n}\n\nfunc TestResultIsError(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.False(Ok(42).IsError())\n\tis.True(Err[int](assert.AnError).IsError())\n}\n\nfunc TestResultError(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Nil(Ok(42).Error())\n\tis.NotNil(Err[int](assert.AnError).Error())\n\tis.Equal(assert.AnError, Err[int](assert.AnError).Error())\n}\n\nfunc TestResultGet(t *testing.T) {\n\tis := assert.New(t)\n\n\tv1, err1 := Ok(42).Get()\n\tv2, err2 := Err[int](assert.AnError).Get()\n\n\tis.Equal(42, v1)\n\tis.Nil(err1)\n\tis.Error(assert.AnError, err1)\n\n\tis.Equal(0, v2)\n\tis.NotNil(err2)\n\tis.Error(assert.AnError, err2)\n}\n\nfunc TestResultMustGet(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.NotPanics(func() {\n\t\tOk(42).MustGet()\n\t})\n\tis.Panics(func() {\n\t\tErr[int](assert.AnError).MustGet()\n\t})\n\n\tis.Equal(42, Ok(42).MustGet())\n}\n\nfunc TestResultOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(42, Ok(42).OrElse(21))\n\tis.Equal(21, Err[int](assert.AnError).OrElse(21))\n}\n\nfunc TestResultOrEmpty(t *testing.T) {\n\tis := assert.New(t)\n\n\tis.Equal(42, Ok(42).OrEmpty())\n\tis.Equal(0, Err[int](assert.AnError).OrEmpty())\n}\n\nfunc TestResultToEither(t *testing.T) {\n\tis := assert.New(t)\n\n\tright, ok1 := Ok(42).ToEither().Right()\n\tleft, ok2 := Err[int](assert.AnError).ToEither().Left()\n\n\tis.Equal(42, right)\n\tis.True(ok1)\n\tis.Equal(assert.AnError, left)\n\tis.True(ok2)\n}\n\nfunc TestResultForEach(t *testing.T) {\n\tis := assert.New(t)\n\n\tErr[int](assert.AnError).ForEach(func(i int) {\n\t\tis.Fail(\"should not enter here\")\n\t})\n\n\tOk(42).ForEach(func(i int) {\n\t\tis.Equal(42, i)\n\t})\n}\n\nfunc TestResultMatch(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Ok(21).Match(\n\t\tfunc(i int) (int, error) {\n\t\t\tis.Equal(21, i)\n\t\t\treturn i * 2, nil\n\t\t},\n\t\tfunc(err error) (int, error) {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t\treturn 0, err\n\t\t},\n\t)\n\topt2 := Err[int](assert.AnError).Match(\n\t\tfunc(i int) (int, error) {\n\t\t\tis.Fail(\"should not enter here\")\n\t\t\treturn i * 2, nil\n\t\t},\n\t\tfunc(err error) (int, error) {\n\t\t\tis.Equal(assert.AnError, err)\n\t\t\treturn 0, err\n\t\t},\n\t)\n\n\tis.Equal(Result[int]{value: 42, isErr: false, err: nil}, opt1)\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, opt2)\n}\n\nfunc TestResultMap(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Ok(21).Map(func(i int) (int, error) {\n\t\treturn i * 2, nil\n\t})\n\topt2 := Err[int](assert.AnError).Map(func(i int) (int, error) {\n\t\tis.Fail(\"should not be called\")\n\t\treturn 42, nil\n\t})\n\n\tis.Equal(Result[int]{value: 42, isErr: false, err: nil}, opt1)\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, opt2)\n}\n\nfunc TestResultMapErr(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Ok(21).MapErr(func(err error) (int, error) {\n\t\tis.Fail(\"should not be called\")\n\t\treturn 42, nil\n\t})\n\topt2 := Err[int](assert.AnError).MapErr(func(err error) (int, error) {\n\t\treturn 42, nil\n\t})\n\n\tis.Equal(Result[int]{value: 21, isErr: false, err: nil}, opt1)\n\tis.Equal(Result[int]{value: 42, isErr: false, err: nil}, opt2)\n}\n\nfunc TestResultFlatMap(t *testing.T) {\n\tis := assert.New(t)\n\n\topt1 := Ok(21).FlatMap(func(i int) Result[int] {\n\t\treturn Ok(42)\n\t})\n\topt2 := Err[int](assert.AnError).FlatMap(func(i int) Result[int] {\n\t\tis.Fail(\"should not be called\")\n\t\treturn Ok(42)\n\t})\n\n\tis.Equal(Result[int]{value: 42, isErr: false, err: nil}, opt1)\n\tis.Equal(Result[int]{value: 0, isErr: true, err: assert.AnError}, opt2)\n}\n\nfunc TestResultMarshalJSON(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult1 := Ok(\"foo\")\n\tresult2 := Err[string](fmt.Errorf(\"an error\"))\n\tresult3 := Ok(\"\")\n\n\tvalue, err := result1.MarshalJSON()\n\tis.NoError(err)\n\tis.Equal(`{\"result\":\"foo\"}`, string(value))\n\n\tvalue, err = result2.MarshalJSON()\n\tis.NoError(err)\n\tis.Equal(`{\"error\":{\"message\":\"an error\"}}`, string(value))\n\n\tvalue, err = result3.MarshalJSON()\n\tis.NoError(err)\n\tis.Equal(`{\"result\":\"\"}`, string(value))\n\n\ttype testStruct struct {\n\t\tField Result[string]\n\t}\n\n\tresultInStruct := testStruct{\n\t\tField: result1,\n\t}\n\tvar marshalled []byte\n\tmarshalled, err = json.Marshal(resultInStruct)\n\tis.NoError(err)\n\tis.Equal(`{\"Field\":{\"result\":\"foo\"}}`, string(marshalled))\n}\n\nfunc TestResultUnmarshalJSON(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult1 := Ok(\"foo\")\n\tresult2 := Err[string](fmt.Errorf(\"an error\"))\n\tresult3 := Ok(\"\")\n\n\terr := result1.UnmarshalJSON([]byte(`{\"result\":\"foo\"}`))\n\tis.NoError(err)\n\tis.Equal(Ok(\"foo\"), result1)\n\n\tvar res Result[string]\n\terr = json.Unmarshal([]byte(`{\"result\":\"foo\"}`), &res)\n\tis.NoError(err)\n\tis.Equal(res, result1)\n\n\terr = result2.UnmarshalJSON([]byte(`{\"error\":{\"message\":\"an error\"}}`))\n\tis.NoError(err)\n\tis.Equal(Err[string](fmt.Errorf(\"an error\")), result2)\n\n\terr = result3.UnmarshalJSON([]byte(`{\"result\":\"\"}`))\n\tis.NoError(err)\n\tis.Equal(Ok(\"\"), result3)\n\n\ttype testStruct struct {\n\t\tField Result[string]\n\t}\n\n\tunmarshal := testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\":{\"result\":\"foo\"}}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: Ok(\"foo\")}, unmarshal)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\":{\"error\":{\"message\":\"an error\"}}}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: Err[string](fmt.Errorf(\"an error\"))}, unmarshal)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: Ok(\"\")}, unmarshal)\n\n\t// Both result and error are set; unmarshal to Err\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\":{\"result\":\"foo\",\"error\":{\"message\":\"an error\"}}}`), &unmarshal)\n\tis.NoError(err)\n\tis.Equal(testStruct{Field: Err[string](fmt.Errorf(\"an error\"))}, unmarshal)\n\n\t// Bad structure for error; cannot unmarshal\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\":{\"result\":\"foo\",\"error\":true}}`), &unmarshal)\n\tis.Error(err)\n\n\tunmarshal = testStruct{}\n\terr = json.Unmarshal([]byte(`{\"Field\": \"}`), &unmarshal)\n\tis.Error(err)\n}\n\n// TestResultFoldSuccess tests the Fold method with a successful result.\nfunc TestResultFoldSuccess(t *testing.T) {\n\tis := assert.New(t)\n\tresult := Result[int]{value: 42, isErr: false, err: nil}\n\n\tsuccessFunc := func(value int) string {\n\t\treturn fmt.Sprintf(\"Success: %v\", value)\n\t}\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure: %v\", err)\n\t}\n\n\tfolded := Fold[error, int, string](result, successFunc, failureFunc)\n\texpected := \"Success: 42\"\n\n\tis.Equal(expected, folded)\n}\n\n// TestResultFoldFailure tests the Fold method with a failure result.\nfunc TestResultFoldFailure(t *testing.T) {\n\terr := errors.New(\"result error\")\n\tis := assert.New(t)\n\n\tresult := Result[int]{value: 0, isErr: true, err: err}\n\n\tsuccessFunc := func(value int) string {\n\t\treturn fmt.Sprintf(\"Success: %v\", value)\n\t}\n\tfailureFunc := func(err error) string {\n\t\treturn fmt.Sprintf(\"Failure: %v\", err)\n\t}\n\n\tfolded := Fold[error, int, string](result, successFunc, failureFunc)\n\texpected := fmt.Sprintf(\"Failure: %v\", err)\n\n\tis.Equal(expected, folded)\n}\n"
        },
        {
          "name": "state.go",
          "type": "blob",
          "size": 1.0224609375,
          "content": "package mo\n\nfunc NewState[S any, A any](f func(state S) (A, S)) State[S, A] {\n\treturn State[S, A]{\n\t\trun: f,\n\t}\n}\n\nfunc ReturnState[S any, A any](x A) State[S, A] {\n\treturn State[S, A]{\n\t\trun: func(state S) (A, S) {\n\t\t\treturn x, state\n\t\t},\n\t}\n}\n\n// State represents a function `(S) -> (A, S)`, where `S` is state, `A` is result.\ntype State[S any, A any] struct {\n\trun func(state S) (A, S)\n}\n\n// Run executes a computation in the State monad.\nfunc (s State[S, A]) Run(state S) (A, S) {\n\treturn s.run(state)\n}\n\n// Get returns the current state.\nfunc (s State[S, A]) Get() State[S, S] {\n\treturn State[S, S]{\n\t\trun: func(state S) (S, S) {\n\t\t\treturn state, state\n\t\t},\n\t}\n}\n\n// Modify the state by applying a function to the current state.\nfunc (s State[S, A]) Modify(f func(state S) S) State[S, A] {\n\treturn State[S, A]{\n\t\trun: func(state S) (A, S) {\n\t\t\treturn empty[A](), f(state)\n\t\t},\n\t}\n}\n\n// Put set the state.\nfunc (s State[S, A]) Put(state S) State[S, A] {\n\treturn State[S, A]{\n\t\trun: func(state S) (A, S) {\n\t\t\treturn empty[A](), state\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "task.go",
          "type": "blob",
          "size": 5.2392578125,
          "content": "package mo\n\n// NewTask instanciates a new Task.\nfunc NewTask[R any](f ff0[R]) Task[R] {\n\treturn Task[R]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// NewTaskFromIO instanciates a new Task from an existing IO.\nfunc NewTaskFromIO[R any](io IO[R]) Task[R] {\n\treturn Task[R]{\n\t\tunsafePerform: func() *Future[R] {\n\t\t\treturn NewFuture[R](func(resolve func(R), reject func(error)) {\n\t\t\t\tresolve(io.unsafePerform())\n\t\t\t})\n\t\t},\n\t}\n}\n\n// Task represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype Task[R any] struct {\n\tunsafePerform ff0[R]\n}\n\n// Run execute the non-deterministic asynchronous computation, with side effect.\nfunc (t Task[R]) Run() *Future[R] {\n\treturn t.unsafePerform()\n}\n\n// NewTask1 instanciates a new Task1.\nfunc NewTask1[R any, A any](f ff1[R, A]) Task1[R, A] {\n\treturn Task1[R, A]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// NewTaskFromIO1 instanciates a new Task1 from an existing IO1.\nfunc NewTaskFromIO1[R any, A any](io IO1[R, A]) Task1[R, A] {\n\treturn Task1[R, A]{\n\t\tunsafePerform: func(a A) *Future[R] {\n\t\t\treturn NewFuture[R](func(resolve func(R), reject func(error)) {\n\t\t\t\tresolve(io.unsafePerform(a))\n\t\t\t})\n\t\t},\n\t}\n}\n\n// Task1 represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype Task1[R any, A any] struct {\n\tunsafePerform ff1[R, A]\n}\n\n// Run execute the non-deterministic asynchronous computation, with side effect.\nfunc (t Task1[R, A]) Run(a A) *Future[R] {\n\treturn t.unsafePerform(a)\n}\n\n// NewTask2 instanciates a new Task2.\nfunc NewTask2[R any, A any, B any](f ff2[R, A, B]) Task2[R, A, B] {\n\treturn Task2[R, A, B]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// NewTaskFromIO2 instanciates a new Task2 from an existing IO2.\nfunc NewTaskFromIO2[R any, A any, B any](io IO2[R, A, B]) Task2[R, A, B] {\n\treturn Task2[R, A, B]{\n\t\tunsafePerform: func(a A, b B) *Future[R] {\n\t\t\treturn NewFuture[R](func(resolve func(R), reject func(error)) {\n\t\t\t\tresolve(io.unsafePerform(a, b))\n\t\t\t})\n\t\t},\n\t}\n}\n\n// Task2 represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype Task2[R any, A any, B any] struct {\n\tunsafePerform ff2[R, A, B]\n}\n\n// Run execute the non-deterministic asynchronous computation, with side effect.\nfunc (t Task2[R, A, B]) Run(a A, b B) *Future[R] {\n\treturn t.unsafePerform(a, b)\n}\n\n// NewTask3 instanciates a new Task3.\nfunc NewTask3[R any, A any, B any, C any](f ff3[R, A, B, C]) Task3[R, A, B, C] {\n\treturn Task3[R, A, B, C]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// NewTaskFromIO3 instanciates a new Task3 from an existing IO3.\nfunc NewTaskFromIO3[R any, A any, B any, C any](io IO3[R, A, B, C]) Task3[R, A, B, C] {\n\treturn Task3[R, A, B, C]{\n\t\tunsafePerform: func(a A, b B, c C) *Future[R] {\n\t\t\treturn NewFuture[R](func(resolve func(R), reject func(error)) {\n\t\t\t\tresolve(io.unsafePerform(a, b, c))\n\t\t\t})\n\t\t},\n\t}\n}\n\n// Task3 represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype Task3[R any, A any, B any, C any] struct {\n\tunsafePerform ff3[R, A, B, C]\n}\n\n// Run execute the non-deterministic asynchronous computation, with side effect.\nfunc (t Task3[R, A, B, C]) Run(a A, b B, c C) *Future[R] {\n\treturn t.unsafePerform(a, b, c)\n}\n\n// NewTask4 instanciates a new Task4.\nfunc NewTask4[R any, A any, B any, C any, D any](f ff4[R, A, B, C, D]) Task4[R, A, B, C, D] {\n\treturn Task4[R, A, B, C, D]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// NewTaskFromIO4 instanciates a new Task4 from an existing IO4.\nfunc NewTaskFromIO4[R any, A any, B any, C any, D any](io IO4[R, A, B, C, D]) Task4[R, A, B, C, D] {\n\treturn Task4[R, A, B, C, D]{\n\t\tunsafePerform: func(a A, b B, c C, d D) *Future[R] {\n\t\t\treturn NewFuture[R](func(resolve func(R), reject func(error)) {\n\t\t\t\tresolve(io.unsafePerform(a, b, c, d))\n\t\t\t})\n\t\t},\n\t}\n}\n\n// Task4 represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype Task4[R any, A any, B any, C any, D any] struct {\n\tunsafePerform ff4[R, A, B, C, D]\n}\n\n// Run execute the non-deterministic asynchronous computation, with side effect.\nfunc (t Task4[R, A, B, C, D]) Run(a A, b B, c C, d D) *Future[R] {\n\treturn t.unsafePerform(a, b, c, d)\n}\n\n// NewTask5 instanciates a new Task5.\nfunc NewTask5[R any, A any, B any, C any, D any, E any](f ff5[R, A, B, C, D, E]) Task5[R, A, B, C, D, E] {\n\treturn Task5[R, A, B, C, D, E]{\n\t\tunsafePerform: f,\n\t}\n}\n\n// NewTaskFromIO5 instanciates a new Task5 from an existing IO5.\nfunc NewTaskFromIO5[R any, A any, B any, C any, D any, E any](io IO5[R, A, B, C, D, E]) Task5[R, A, B, C, D, E] {\n\treturn Task5[R, A, B, C, D, E]{\n\t\tunsafePerform: func(a A, b B, c C, d D, e E) *Future[R] {\n\t\t\treturn NewFuture[R](func(resolve func(R), reject func(error)) {\n\t\t\t\tresolve(io.unsafePerform(a, b, c, d, e))\n\t\t\t})\n\t\t},\n\t}\n}\n\n// Task5 represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and never fails.\ntype Task5[R any, A any, B any, C any, D any, E any] struct {\n\tunsafePerform ff5[R, A, B, C, D, E]\n}\n\n// Run execute the non-deterministic asynchronous computation, with side effect.\nfunc (t Task5[R, A, B, C, D, E]) Run(a A, b B, c C, d D, e E) *Future[R] {\n\treturn t.unsafePerform(a, b, c, d, e)\n}\n"
        },
        {
          "name": "task_either.go",
          "type": "blob",
          "size": 1.544921875,
          "content": "package mo\n\n// NewTaskEither instanciates a new TaskEither.\nfunc NewTaskEither[R any](f ff0[R]) TaskEither[R] {\n\treturn TaskEither[R]{NewTask[R](f)}\n}\n\n// NewTaskEitherFromIO instanciates a new TaskEither from an existing IO.\nfunc NewTaskEitherFromIO[R any](io IO[R]) TaskEither[R] {\n\treturn TaskEither[R]{NewTaskFromIO[R](io)}\n}\n\n// TaskEither represents a non-deterministic asynchronous computation that\n// can cause side effects, yields a value of type `R` and can fail.\ntype TaskEither[R any] struct {\n\tTask[R]\n}\n\n// OrElse returns value if task succeeded or default value.\nfunc (t TaskEither[R]) OrElse(fallback R) R {\n\teither := t.Run().Either()\n\n\tright, isRight := either.Right()\n\tif !isRight {\n\t\treturn fallback\n\t}\n\n\treturn right\n}\n\n// Match executes the first function if task succeeded and second function if task failed.\n// It returns a new Option.\nfunc (t TaskEither[R]) Match(onLeft func(error) Either[error, R], onRight func(R) Either[error, R]) Either[error, R] {\n\teither := t.Run().Either()\n\treturn either.Match(onLeft, onRight)\n}\n\n// TryCatch is an alias to Match\nfunc (t TaskEither[R]) TryCatch(onLeft func(error) Either[error, R], onRight func(R) Either[error, R]) Either[error, R] {\n\treturn t.Match(onLeft, onRight)\n}\n\n// ToTask converts TaskEither to Task\nfunc (t TaskEither[R]) ToTask(fallback R) Task[R] {\n\treturn NewTask(func() *Future[R] {\n\t\treturn t.Run().\n\t\t\tCatch(func(err error) (R, error) {\n\t\t\t\treturn fallback, nil\n\t\t\t})\n\t})\n}\n\n// ToEither converts TaskEither to Either.\nfunc (t TaskEither[R]) ToEither() Either[error, R] {\n\treturn t.Run().Either()\n}\n"
        },
        {
          "name": "task_either_test.go",
          "type": "blob",
          "size": 2.3388671875,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTaskEither(t *testing.T) {\n\tis := assert.New(t)\n\n\ttaskEither := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tresolve(42)\n\t\t})\n\t})\n\n\tresult := taskEither.Run().Result().MustGet()\n\n\tis.Equal(42, result)\n}\n\nfunc TestTaskEitherOrElse(t *testing.T) {\n\tis := assert.New(t)\n\n\ttaskEither1 := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tresolve(42)\n\t\t})\n\t})\n\ttaskEither2 := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\treject(assert.AnError)\n\t\t})\n\t})\n\n\tresult1 := taskEither1.OrElse(1234)\n\tresult2 := taskEither2.OrElse(1234)\n\n\tis.Equal(42, result1)\n\tis.Equal(1234, result2)\n}\n\nfunc TestTaskEitherMatch(t *testing.T) {\n\tis := assert.New(t)\n\n\ttaskEither := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tresolve(42)\n\t\t})\n\t})\n\n\tmapped := taskEither.Match(\n\t\tfunc(err error) Either[error, int] {\n\t\t\treturn Right[error, int](1234)\n\t\t},\n\t\tfunc(i int) Either[error, int] {\n\t\t\treturn Right[error, int](i)\n\t\t},\n\t)\n\n\tv, ok := mapped.Right()\n\n\tis.Equal(42, v)\n\tis.True(ok)\n}\n\nfunc TestTaskEitherTryCatch(t *testing.T) {\n\tis := assert.New(t)\n\n\ttaskEither := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tresolve(42)\n\t\t})\n\t})\n\n\tmapped := taskEither.TryCatch(\n\t\tfunc(err error) Either[error, int] {\n\t\t\treturn Right[error, int](1234)\n\t\t},\n\t\tfunc(i int) Either[error, int] {\n\t\t\treturn Right[error, int](i)\n\t\t},\n\t)\n\n\tv, ok := mapped.Right()\n\n\tis.Equal(42, v)\n\tis.True(ok)\n}\n\nfunc TestTaskEitherToTask(t *testing.T) {\n\tis := assert.New(t)\n\n\ttaskEither := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\treject(assert.AnError)\n\t\t})\n\t})\n\n\ttask := taskEither.ToTask(1234)\n\n\tresult := task.Run().Result().MustGet()\n\n\tis.Equal(1234, result)\n}\n\nfunc TestTaskEitherToEither(t *testing.T) {\n\tis := assert.New(t)\n\n\ttaskEither := NewTaskEither(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\treject(assert.AnError)\n\t\t})\n\t})\n\n\teither := taskEither.ToEither()\n\terr, isError := either.Left()\n\n\tis.True(isError)\n\tis.NotNil(err)\n\tis.Equal(assert.AnError, err)\n}\n"
        },
        {
          "name": "task_example_test.go",
          "type": "blob",
          "size": 0.3818359375,
          "content": "package mo\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc ExampleTask() {\n\tt := time.Date(2024, 6, 22, 0, 0, 0, 0, time.Local)\n\n\ttask := NewTask(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tresolve(t.Year())\n\t\t})\n\t})\n\n\t// returns a future\n\tfuture := task.Run()\n\n\t// a Task never fail\n\tresult, _ := future.Collect()\n\n\tfmt.Println(result)\n\t// Output:\n\t// 2024\n}\n"
        },
        {
          "name": "task_test.go",
          "type": "blob",
          "size": 2.0888671875,
          "content": "package mo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTask(t *testing.T) {\n\tis := assert.New(t)\n\n\ttask := NewTask(func() *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tresolve(42)\n\t\t})\n\t})\n\tresult := task.Run().Result().MustGet()\n\n\tis.Equal(42, result)\n}\n\nfunc TestTask1(t *testing.T) {\n\tis := assert.New(t)\n\n\ttask := NewTask1(func(a string) *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tis.Equal(\"foo\", a)\n\t\t\tresolve(42)\n\t\t})\n\t})\n\tresult := task.Run(\"foo\").Result().MustGet()\n\n\tis.Equal(42, result)\n}\n\nfunc TestTask2(t *testing.T) {\n\tis := assert.New(t)\n\n\ttask := NewTask2(func(a string, b string) *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tis.Equal(\"foo\", a)\n\t\t\tis.Equal(\"bar\", b)\n\t\t\tresolve(42)\n\t\t})\n\t})\n\tresult := task.Run(\"foo\", \"bar\").Result().MustGet()\n\n\tis.Equal(42, result)\n}\n\nfunc TestTask3(t *testing.T) {\n\tis := assert.New(t)\n\n\ttask := NewTask3(func(a string, b string, c string) *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tis.Equal(\"foo\", a)\n\t\t\tis.Equal(\"bar\", b)\n\t\t\tis.Equal(\"hello\", c)\n\t\t\tresolve(42)\n\t\t})\n\t})\n\tresult := task.Run(\"foo\", \"bar\", \"hello\").Result().MustGet()\n\n\tis.Equal(42, result)\n}\n\nfunc TestTask4(t *testing.T) {\n\tis := assert.New(t)\n\n\ttask := NewTask4(func(a string, b string, c string, d string) *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tis.Equal(\"foo\", a)\n\t\t\tis.Equal(\"bar\", b)\n\t\t\tis.Equal(\"hello\", c)\n\t\t\tis.Equal(\"world\", d)\n\t\t\tresolve(42)\n\t\t})\n\t})\n\tresult := task.Run(\"foo\", \"bar\", \"hello\", \"world\").Result().MustGet()\n\n\tis.Equal(42, result)\n}\n\nfunc TestTask5(t *testing.T) {\n\tis := assert.New(t)\n\n\ttask := NewTask5(func(a string, b string, c string, d string, e bool) *Future[int] {\n\t\treturn NewFuture(func(resolve func(int), reject func(error)) {\n\t\t\tis.Equal(\"foo\", a)\n\t\t\tis.Equal(\"bar\", b)\n\t\t\tis.Equal(\"hello\", c)\n\t\t\tis.Equal(\"world\", d)\n\t\t\tis.True(e)\n\t\t\tresolve(42)\n\t\t})\n\t})\n\tresult := task.Run(\"foo\", \"bar\", \"hello\", \"world\", true).Result().MustGet()\n\n\tis.Equal(42, result)\n}\n"
        },
        {
          "name": "typeclass",
          "type": "tree",
          "content": null
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 0.962890625,
          "content": "package mo\n\ntype f0[R any] func() R\ntype f1[R any, A any] func(A) R\ntype f2[R any, A any, B any] func(A, B) R\ntype f3[R any, A any, B any, C any] func(A, B, C) R\ntype f4[R any, A any, B any, C any, D any] func(A, B, C, D) R\ntype f5[R any, A any, B any, C any, D any, E any] func(A, B, C, D, E) R\n\ntype ff0[R any] func() *Future[R]\ntype ff1[R any, A any] func(A) *Future[R]\ntype ff2[R any, A any, B any] func(A, B) *Future[R]\ntype ff3[R any, A any, B any, C any] func(A, B, C) *Future[R]\ntype ff4[R any, A any, B any, C any, D any] func(A, B, C, D) *Future[R]\ntype ff5[R any, A any, B any, C any, D any, E any] func(A, B, C, D, E) *Future[R]\n\ntype fe0[R any] func() (R, error)\ntype fe1[R any, A any] func(A) (R, error)\ntype fe2[R any, A any, B any] func(A, B) (R, error)\ntype fe3[R any, A any, B any, C any] func(A, B, C) (R, error)\ntype fe4[R any, A any, B any, C any, D any] func(A, B, C, D) (R, error)\ntype fe5[R any, A any, B any, C any, D any, E any] func(A, B, C, D, E) (R, error)\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 0.048828125,
          "content": "package mo\n\nfunc empty[T any]() (t T) {\n\treturn\n}\n"
        }
      ]
    }
  ]
}