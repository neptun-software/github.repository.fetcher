{
  "metadata": {
    "timestamp": 1736566690764,
    "page": 247,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gopherdata/gophernotes",
      "stars": 3876,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0458984375,
          "content": "gophernotes\n.ipynb_checkpoints\nUntitled*.ipynb\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.255859375,
          "content": "language: go\n\ngo:\n  - 1.15.x\n  - 1.14.x\n  - 1.13.x\n  - master\n\nmatrix:\n fast_finish: true\n allow_failures:\n   - go: master\n\nsudo: true\n\nbefore_install:\n  - sudo apt-get install build-essential python3-pip\n\nscript:\n  - go test -v ./...\n  - go test -race -v ./...\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 1.1044921875,
          "content": "# This is the official list of people who can contribute\n# (and typically have contributed) code to the gophernotes\n# repository.\n#\n# Names should be added to this file only after verifying that\n# the individual or the individual's organization has agreed to\n# the appropriate Contributor License Agreement, found here:\n#\n#     http://code.google.com/legal/individual-cla-v1.0.html\n#     http://code.google.com/legal/corporate-cla-v1.0.html\n#\n# The agreement for individuals can be filled out on the web.\n#\n# Names should be added to this file like so:\n#     Name <email address>\n#\n# Please keep the list sorted.\n\nBobby Norton <bobby@testedminds.com>\nDan Kortschak <dan@kortschak.io>\nDaniel Whitenack <whitenack.daniel@gmail.com>\nFransesc Campoy <campoy@golang.org>\nHarry Moreno <harry@capsulerx.com>\nJosh Cheek <josh.cheek@gmail.com>\nKevin Burke <kev@inburke.com>\nMassimiliano Ghilardi <massimiliano.ghilardi@gmail.com>\nMatthew Steffen <matt@pachyderm.io>\nSebastien Binet <binet@cern.ch>\nSpencer Park <spinnr95@gmail.com>\nThomas Kluyver <thomas@kluyver.me.uk>\nYang Yang <wdscxsj@gmail.com>\nYasuhiro Matsumoto <mattn.jp@gmail.com>\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.5859375,
          "content": "FROM alpine:3.15\nMAINTAINER dwhitena\n\n# Add gophernotes\nADD . /go/src/github.com/gopherdata/gophernotes/\n\n# Install Jupyter and gophernotes.\nRUN set -x \\\n    # install python and dependencies\n    && apk update \\\n    && apk --no-cache \\\n        --repository http://dl-4.alpinelinux.org/alpine/v3.15/community \\\n        --repository http://dl-4.alpinelinux.org/alpine/v3.15/main \\\n        --arch=x86_64 add \\\n        ca-certificates \\\n        g++ \\\n        gcc \\\n        git \\\n        libffi-dev \\\n        pkgconfig \\\n        python3 python3-dev \\\n        py3-pip \\\n        py3-pyzmq \\\n        mercurial \\\n        mesa-dev \\\n        musl-dev \\\n        su-exec \\\n        zeromq-dev \\\n    && pip3 install --upgrade pip==21.3.1 \\\n    && ln -s /usr/bin/python3.9 /usr/bin/python \\\n    ## install Go\n    && apk --update-cache \\\n        --arch=x86_64 add \\\n        go \\\n    ## jupyter notebook\n    && ln -s /usr/include/locale.h /usr/include/xlocale.h \\\n    && pip3 install jupyter notebook pyzmq tornado ipykernel \\\n    ## install gophernotes\n    && cd /go/src/github.com/gopherdata/gophernotes \\\n    && GOPATH=/go GO111MODULE=on go install . \\\n    && cp /go/bin/gophernotes /usr/local/bin/ \\\n    && mkdir -p ~/.local/share/jupyter/kernels/gophernotes \\\n    && cp -r ./kernel/* ~/.local/share/jupyter/kernels/gophernotes \\\n    && cd - \\\n    ## clean\n    && find /usr/lib/python3.9 -name __pycache__ | xargs rm -r \\\n    && rm -rf \\\n        /root/.[acpw]* \\\n        ipaexg00301* \\\n    && rm -rf /var/cache/apk/*\n\n# Set GOPATH.\nENV GOPATH /go\n\nEXPOSE 8888\nCMD [ \"jupyter\", \"notebook\", \"--no-browser\", \"--allow-root\", \"--ip=0.0.0.0\" ]\n"
        },
        {
          "name": "Dockerfile.DS",
          "type": "blob",
          "size": 2.43359375,
          "content": "FROM alpine:3.15\nMAINTAINER dwhitena\n\n# Add gophernotes\nADD . /go/src/github.com/gopherdata/gophernotes/\n\n# Install Jupyter and gophernotes.\nRUN set -x \\\n    # install python and dependencies\n    && apk update \\\n    && apk --no-cache \\\n        --repository http://dl-4.alpinelinux.org/alpine/v3.15/community \\\n        --repository http://dl-4.alpinelinux.org/alpine/v3.15/main \\\n        --arch=x86_64 add \\\n        ca-certificates \\\n        g++ \\\n        gcc \\\n        git \\\n        libffi-dev \\\n        pkgconfig \\\n        python3 python3-dev \\\n        py3-pip \\\n        py3-pyzmq \\\n        mercurial \\\n        mesa-dev \\\n        musl-dev \\\n        su-exec \\\n        zeromq-dev \\\n    && pip3 install --upgrade pip==21.3.1 \\\n    && cp /usr/bin/python3.9 /usr/bin/python \\\n    ## install Go\n    && apk --update-cache \\\n        --arch=x86_64 add \\\n        go \\\n    ## jupyter notebook\n    && ln -s /usr/include/locale.h /usr/include/xlocale.h \\\n    && pip3 install jupyter notebook pyzmq tornado ipykernel \\\n    ## install gophernotes\n    && cd /go/src/github.com/gopherdata/gophernotes \\\n    && export GOPATH=/go \\\n    && export GO111MODULE=on \\\n    && go install . \\\n    && cp /go/bin/gophernotes /usr/local/bin/ \\\n    && mkdir -p ~/.local/share/jupyter/kernels/gophernotes \\\n    && cp -r ./kernel/* ~/.local/share/jupyter/kernels/gophernotes \\\n    && cd - \\\n    ## get the relevant Go packages\n    && go get gonum.org/v1/plot/... \\\n    && go get gonum.org/v1/gonum/... \\\n    && go get github.com/go-gota/gota/... \\\n    && go get github.com/sajari/regression \\\n    && go get github.com/sjwhitworth/golearn/... \\\n    && go get go-hep.org/x/hep/csvutil/... \\\n    && go get go-hep.org/x/hep/fit \\\n    && go get go-hep.org/x/hep/hbook \\\n    && go get github.com/montanaflynn/stats \\\n    && go get github.com/boltdb/bolt \\\n    && go get github.com/patrickmn/go-cache \\\n    && go get github.com/chewxy/math32 \\\n    && go get github.com/chewxy/hm \\\n    && go get gorgonia.org/vecf64 \\\n    && go get gorgonia.org/vecf32 \\\n    && go get github.com/awalterschulze/gographviz \\\n    && go get github.com/leesper/go_rng \\\n    && go get github.com/pkg/errors \\\n    && go get github.com/stretchr/testify/assert \\\n    ## clean\n    && find /usr/lib/python3.9 -name __pycache__ | xargs rm -r \\\n    && rm -rf \\\n        /root/.[acpw]* \\\n        ipaexg00301* \\\n    && rm -rf /var/cache/apk/*\n\n# Set GOPATH.\nENV GOPATH /go\n\nEXPOSE 8888\nCMD [ \"jupyter\", \"notebook\", \"--no-browser\", \"--allow-root\", \"--ip=0.0.0.0\" ]\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 1.2216796875,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  branch = \"stable\"\n  name = \"github.com/cosmos72/gomacro\"\n  packages = [\n    \"ast2\",\n    \"atomic\",\n    \"base\",\n    \"base/dep\",\n    \"base/untyped\",\n    \"fast\",\n    \"gls\",\n    \"imports\",\n    \"imports/syscall\",\n    \"imports/thirdparty\",\n    \"parser\",\n    \"scanner\",\n    \"token\",\n    \"typeutil\",\n    \"xreflect\"\n  ]\n  revision = \"515faf9893ffc98ff66aab992cefbd8065aab308\"\n\n[[projects]]\n  name = \"github.com/mattn/go-runewidth\"\n  packages = [\".\"]\n  revision = \"9e777a8366cce605130a531d2cd6363d07ad7317\"\n  version = \"v0.0.2\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/pebbe/zmq4\"\n  packages = [\".\"]\n  revision = \"90d69e412a09549f2e90bac70fbb449081f1e5c1\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/peterh/liner\"\n  packages = [\".\"]\n  revision = \"80ce870644db1b043e8dc2cf836bde5c347e2701\"\n\n[[projects]]\n  branch = \"master\"\n  name = \"github.com/satori/go.uuid\"\n  packages = [\".\"]\n  revision = \"36e9d2ebbde5e3f13ab2e25625fd453271d6522e\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  inputs-digest = \"5c1eb9af5482e159ee019ac0c87aaf5d16822f45a866946aefea60eb0a29c157\"\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.734375,
          "content": "\n# Gopkg.toml example\n#\n# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#  name = \"github.com/x/y\"\n#  version = \"2.4.0\"\n\n\n[[constraint]]\n  branch = \"stable\"\n  name = \"github.com/cosmos72/gomacro\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/satori/go.uuid\"\n\n[[constraint]]\n  branch = \"master\"\n  name = \"github.com/pebbe/zmq4\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 \n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.521484375,
          "content": "![alt tag](files/gophernotes-logo.png)\n\n[![Build Status](https://travis-ci.org/gopherdata/gophernotes.svg?branch=master)](https://travis-ci.org/gopherdata/gophernotes)\n[![License](https://img.shields.io/badge/License-MIT-blue.svg)](https://github.com/gopherdata/gophernotes/blob/master/LICENSE)\n\n# gophernotes - Use Go in Jupyter notebooks and nteract\n\n`gophernotes` is a Go kernel for [Jupyter](http://jupyter.org/) notebooks and [nteract](https://nteract.io/).  It lets you use Go interactively in a browser-based notebook or desktop app.  Use `gophernotes` to create and share documents that contain live Go code, equations, visualizations and explanatory text.  These notebooks, with the live Go code, can then be shared with others via email, Dropbox, GitHub and the [Jupyter Notebook Viewer](http://nbviewer.jupyter.org/). Go forth and do data science, or anything else interesting, with Go notebooks!\n\n**Acknowledgements** - This project utilizes a Go interpreter called [gomacro](https://github.com/cosmos72/gomacro) under the hood to evaluate Go code interactively. The gophernotes logo was designed by the brilliant [Marcus Olsson](https://github.com/marcusolsson) and was inspired by Renee French's original Go Gopher design.\n\n- [Examples](#examples)\n- Install gophernotes:\n  - [Prerequisites](#prerequisites)\n  - [FreeBSD](#linux-or-freebsd)\n  - [Linux](#linux-or-freebsd)\n  - [Mac](#mac)\n  - [Windows](#windows)\n  - [Docker](#docker)\n- [Getting Started](#getting-started)\n- [Limitations](#limitations)\n- [Troubleshooting](#troubleshooting)\n\n## Examples\n\n### Jupyter Notebook:\n\n![](files/jupyter.gif)\n\n### nteract:\n\n![](files/nteract.gif)\n\n### Example Notebooks (download and run them locally, follow the links to view in Github, or use the [Jupyter Notebook Viewer](http://nbviewer.jupyter.org/)):\n- [Worker Pools](examples/Worker_Pools.ipynb)\n- [Matrix Operations](examples/Matrix_Operations.ipynb)\n- [Facial Recognition](examples/Facial_Recognition_MachineBox.ipynb)\n- [Display Images, HTML, LaTeX...](examples/Display.ipynb)\n\n## Installation\n\n### Prerequisites\n\n- [Go 1.13+](https://golang.org/doc/install) - including GOPATH/bin added to your PATH (i.e., you can run Go binaries that you `go install`).\n- [Jupyter Notebook](http://jupyter.readthedocs.io/en/latest/install.html) or [nteract](https://nteract.io/desktop)\n- [git](https://git-scm.com/download) - usually already present on Linux and Mac OS X. If not present, follow the instructions at [https://git-scm.com/download](https://git-scm.com/download)\n\n### Linux or FreeBSD\n\nThe instructions below should work both on Linux and on FreeBSD.\n\nMethod 1: quick installation as module\n```sh\n  go install github.com/gopherdata/gophernotes@v0.7.5\n  mkdir -p ~/.local/share/jupyter/kernels/gophernotes\n  cd ~/.local/share/jupyter/kernels/gophernotes\n  cp \"$(go env GOPATH)\"/pkg/mod/github.com/gopherdata/gophernotes@v0.7.5/kernel/*  \".\"\n  chmod +w ./kernel.json # in case copied kernel.json has no write permission\n  sed \"s|gophernotes|$(go env GOPATH)/bin/gophernotes|\" < kernel.json.in > kernel.json\n```\n\nMethod 2: manual installation from GOPATH\n```sh\n  mkdir -p \"$(go env GOPATH)\"/src/github.com/gopherdata\n  cd \"$(go env GOPATH)\"/src/github.com/gopherdata\n  git clone https://github.com/gopherdata/gophernotes\n  cd gophernotes\n  git checkout -f v0.7.5\n  go install\n  mkdir -p ~/.local/share/jupyter/kernels/gophernotes\n  cp kernel/* ~/.local/share/jupyter/kernels/gophernotes\n  cd ~/.local/share/jupyter/kernels/gophernotes\n  chmod +w ./kernel.json # in case copied kernel.json has no write permission\n  sed \"s|gophernotes|$(go env GOPATH)/bin/gophernotes|\" < kernel.json.in > kernel.json\n```\n\nTo confirm that the `gophernotes` binary is installed in GOPATH, execute it directly:\n```sh\n  \"$(go env GOPATH)\"/bin/gophernotes\n```\nand you should see the following:\n```sh\n2017/09/20 10:33:12 Need a command line argument specifying the connection file.\n```\n\n**Note** - if you have the `JUPYTER_PATH` environmental variable set or if you are using an older version of Jupyter, you may need to copy this kernel config to another directory.  You can check which directories will be searched by executing:\n\n```sh\n  jupyter --data-dir\n```\n\n### Mac\n\n**Important Note** - gomacro relies on the `plugin` package when importing third party libraries. This package works reliably on Mac OS X with Go 1.10.2+ as long as you **never** execute the command `strip gophernotes`.\n\nMethod 1: quick installation as module\n```sh\n  go install github.com/gopherdata/gophernotes@v0.7.5\n  mkdir -p ~/Library/Jupyter/kernels/gophernotes\n  cd ~/Library/Jupyter/kernels/gophernotes\n  cp \"$(go env GOPATH)\"/pkg/mod/github.com/gopherdata/gophernotes@v0.7.5/kernel/*  \".\"\n  chmod +w ./kernel.json # in case copied kernel.json has no write permission\n  sed \"s|gophernotes|$(go env GOPATH)/bin/gophernotes|\" < kernel.json.in > kernel.json\n```\n\nMethod 2: manual installation from GOPATH\n```sh\n  mkdir -p \"$(go env GOPATH)\"/src/github.com/gopherdata\n  cd \"$(go env GOPATH)\"/src/github.com/gopherdata\n  git clone https://github.com/gopherdata/gophernotes\n  cd gophernotes\n  git checkout -f v0.7.5\n  go install\n  mkdir -p ~/Library/Jupyter/kernels/gophernotes\n  cp kernel/* ~/Library/Jupyter/kernels/gophernotes\n  cd ~/Library/Jupyter/kernels/gophernotes\n  chmod +w ./kernel.json # in case copied kernel.json has no write permission\n  sed \"s|gophernotes|$(go env GOPATH)/bin/gophernotes|\" < kernel.json.in > kernel.json\n```\n\nTo confirm that the `gophernotes` binary is installed in GOPATH, execute it directly:\n```sh\n  \"$(go env GOPATH)\"/bin/gophernotes\n```\nand you should see the following:\n```sh\n2017/09/20 10:33:12 Need a command line argument specifying the connection file.\n```\n\n**Note** - if you have the `JUPYTER_PATH` environmental variable set or if you are using an older version of Jupyter, you may need to copy this kernel config to another directory.  You can check which directories will be searched by executing:\n\n```sh\n  jupyter --data-dir\n```\n\n### Windows\n\n**Important Note** - gomacro relies on the `plugin` package when importing third party libraries.  This package is only supported on Linux and Mac OS X currently.  Thus, if you need to utilize third party packages in your Go notebooks and you are running on Windows, you should use the [Docker](#docker) install and run gophernotes/Jupyter in Docker.\n\n1. Download gophernotes inside GOPATH, compile and install it\n\n    ```\n    go env GOPATH > temp.txt\n    set /p GOPATH=<temp.txt\n    mkdir %GOPATH%\\src\\github.com\\gopherdata\n    cd /d %GOPATH%\\src\\github.com\\gopherdata\n    git clone https://github.com/gopherdata/gophernotes\n    cd gophernotes\n    git checkout -f v0.7.5\n    go install\n    ```\n\n2. Copy the kernel config:\n\n    ```\n    mkdir %APPDATA%\\jupyter\\kernels\\gophernotes\n    xcopy %GOPATH%\\src\\github.com\\gopherdata\\gophernotes\\kernel %APPDATA%\\jupyter\\kernels\\gophernotes /s\n    ```\n\n    Note, if you have the `JUPYTER_PATH` environmental variable set or if you are using an older version of Jupyter, you may need to copy this kernel config to another directory.  You can check which directories will be searched by executing:\n\n    ```\n    jupyter --data-dir\n    ```\n\n3. Update `%APPDATA%\\jupyter\\kernels\\gophernotes\\kernel.json` with the FULL PATH to your gophernotes.exe (usually in %GOPATH%\\bin).  For example:\n\n    ```\n    {\n        \"argv\": [\n          \"C:\\\\gopath\\\\bin\\\\gophernotes.exe\",\n          \"{connection_file}\"\n          ],\n        \"display_name\": \"Go\",\n        \"language\": \"go\",\n        \"name\": \"go\"\n    }\n    ```\n\n### Docker\n\nYou can try out or run Jupyter + gophernotes without installing anything using Docker. To run a Go notebook that only needs things from the standard library, run:\n\n```\n  docker run -it -p 8888:8888 gopherdata/gophernotes\n```\n\nOr to run a Go notebook with access to common Go data science packages (gonum, gota, golearn, etc.), run:\n\n```\n  docker run -it -p 8888:8888 gopherdata/gophernotes:latest-ds\n```\n\nIn either case, running this command should output a link that you can follow to access Jupyter in a browser. Also, to save notebooks to and/or load notebooks from a location outside of the Docker image, you should utilize a volume mount.  For example:\n\n```\n  docker run -it -p 8888:8888 -v /path/to/local/notebooks:/path/to/notebooks/in/docker gopherdata/gophernotes\n```\n\n## Getting Started\n\n### Jupyter\n\n- If you completed one of the local installs above (i.e., not the Docker install), start the jupyter notebook server:\n\n  ```\n  jupyter notebook\n  ```\n\n- Select `Go` from the `New` drop down menu.\n\n- Have fun!\n\n### nteract\n\n- Launch nteract.\n\n- From the nteract menu select Language -> Go.\n\n- Have fun!\n\n## Special commands\n\nIn addition to Go code, the following special commands are also supported - they must be on a line by their own:\n- %cd [path]\n- %go111module {on|off}\n- %help\n- $ shell_command [args...]\n\n## Limitations\n\ngophernotes uses [gomacro](https://github.com/cosmos72/gomacro) under the hood to evaluate Go code interactively. You can evaluate most any Go code with gomacro, but there are some limitations, which are discussed in further detail [here](https://github.com/cosmos72/gomacro#current-status).  Most notably, gophernotes does NOT support:\n\n- importing third party packages when running natively on Windows - This is a current limitation of the Go `plugin` package.\n- some corner cases on interpreted interfaces, as interface -&gt; interface type switch and type assertion, are not implemented yet.\n- some corner cases on recursive types may not work correctly.\n- conversion from typed constant to interpreted interface is not implemented. Workaround: assign the constant to a variable, then convert the variable to the interpreted interface type.\n- conversions from/to unsafe.Pointer are not supported.\n- goto is only partially implemented.\n- out-of-order code in the same cell is supported, but not heavily tested. It has some known limitations for composite literals.\n\nAlso, creation of new named types is emulated, and their methods are visible only to interpreted code.\n\n## Troubleshooting\n\n### gophernotes not found\n\nDepending on your environment, you may need to manually change the path to the `gophernotes` executable in `kernel/kernel.json` before copying it to `~/.local/share/jupyter/kernels/gophernotes`.  You can put the **full path** to the `gophernotes` executable here, and you shouldn't have any further issues.\n\n### \"Kernel error\" in a running notebook\n\n```\nTraceback (most recent call last):\n  File \"/usr/local/lib/python2.7/site-packages/notebook/base/handlers.py\", line 458, in wrapper\n    result = yield gen.maybe_future(method(self, *args, **kwargs))\n  File \"/usr/local/lib/python2.7/site-packages/tornado/gen.py\", line 1008, in run\n    value = future.result()\n  ...\n  File \"/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py\", line 1335, in _execute_child\n    raise child_exception\nOSError: [Errno 2] No such file or directory\n```\n\nStop jupyter, if it's already running.\n\nAdd a symlink to `/go/bin/gophernotes` from your path to the gophernotes executable. If you followed the instructions above, this will be:\n\n```\nsudo ln -s $HOME/go/bin/gophernotes /go/bin/gophernotes\n```\n\nRestart jupyter, and you should now be up and running.\n\n### error \"could not import C (no metadata for C)\" when importing a package\n\nAt a first analysis, it seems to be a limitation of the new import mechanism that supports Go modules.\nYou can switch the old (non module-aware) mechanism with the command `%go111module off`\n\nTo re-enable modules support, execute `%go111module on`\n\n### Look at Jupyter notebook's logs for debugging\n\nIn order to see the logs for your Jupyter notebook, use the --log-level option\n```\njupyter notebook --log-level DEBUG\n```\n"
        },
        {
          "name": "codemeta.json",
          "type": "blob",
          "size": 0.5087890625,
          "content": "{\n  \"@context\": \"https://raw.githubusercontent.com/codemeta/codemeta/master/codemeta.jsonld\",\n  \"@type\": \"Code\",\n  \"author\": [\n\n  ],\n  \"identifier\": \"\",\n  \"codeRepository\": \"https://github.com/gopherdata/gophernotes\",\n  \"datePublished\": \"2017-12-13\",\n  \"dateModified\": \"2017-12-13\",\n  \"dateCreated\": \"2017-12-13\",\n  \"description\": \"The Go kernel for Jupyter notebooks and nteract. \",\n  \"keywords\": \"go, jupyter, nteract, golang, data science\",\n  \"license\": \"GPL v3.0\",\n  \"title\": \"gophernotes\",\n  \"version\": \"v1.0.0-RC\"\n}"
        },
        {
          "name": "compiler_version.go",
          "type": "blob",
          "size": 0.1494140625,
          "content": "// +build !go1.11\n\n// cause a compile error if Go compiler version < 1.11\n\npackage main\n\nvar _ int = \"error: Go >= 1.11 required to compile Gophernotes\"\n"
        },
        {
          "name": "complete.go",
          "type": "blob",
          "size": 1.19140625,
          "content": "package main\n\nimport (\n\tinterp \"github.com/cosmos72/gomacro/fast\"\n)\n\ntype Completion struct {\n\tclass,\n\tname,\n\ttyp string\n}\n\ntype CompletionResponse struct {\n\tpartial     int\n\tcompletions []Completion\n}\n\n/************************************************************\n* entry function\n************************************************************/\nfunc handleCompleteRequest(ir *interp.Interp, receipt msgReceipt) error {\n\t// Extract the data from the request.\n\treqcontent := receipt.Msg.Content.(map[string]interface{})\n\tcode := reqcontent[\"code\"].(string)\n\tcursorPos := int(reqcontent[\"cursor_pos\"].(float64))\n\n\t// autocomplete the code at the cursor position\n\tprefix, matches, _ := ir.CompleteWords(code, cursorPos)\n\n\t// prepare the reply\n\tcontent := make(map[string]interface{})\n\n\tif len(matches) == 0 {\n\t\tcontent[\"ename\"] = \"ERROR\"\n\t\tcontent[\"evalue\"] = \"no completions found\"\n\t\tcontent[\"traceback\"] = nil\n\t\tcontent[\"status\"] = \"error\"\n\t} else {\n\t\tpartialWord := interp.TailIdentifier(prefix)\n\t\tcontent[\"cursor_start\"] = float64(len(prefix) - len(partialWord))\n\t\tcontent[\"cursor_end\"] = float64(cursorPos)\n\t\tcontent[\"matches\"] = matches\n\t\tcontent[\"status\"] = \"ok\"\n\t}\n\n\treturn receipt.Reply(\"complete_reply\", content)\n}\n"
        },
        {
          "name": "display.go",
          "type": "blob",
          "size": 10.955078125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strings\"\n\n\tbasereflect \"github.com/cosmos72/gomacro/base/reflect\"\n\t\"github.com/cosmos72/gomacro/xreflect\"\n)\n\n// Support an interface similar - but not identical - to the IPython (canonical Jupyter kernel).\n// See http://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html#IPython.display.display\n// for a good overview of the support types.\n\nconst (\n\tMIMETypeHTML       = \"text/html\"\n\tMIMETypeJavaScript = \"application/javascript\"\n\tMIMETypeJPEG       = \"image/jpeg\"\n\tMIMETypeJSON       = \"application/json\"\n\tMIMETypeLatex      = \"text/latex\"\n\tMIMETypeMarkdown   = \"text/markdown\"\n\tMIMETypePNG        = \"image/png\"\n\tMIMETypePDF        = \"application/pdf\"\n\tMIMETypeSVG        = \"image/svg+xml\"\n\tMIMETypeText       = \"text/plain\"\n)\n\n/**\n * general interface, allows libraries to fully specify\n * how their data is displayed by Jupyter.\n * Supports multiple MIME formats.\n *\n * Note that Data defined above is an alias:\n * libraries can implement Renderer without importing gophernotes\n */\ntype Renderer = interface {\n\tRender() Data\n}\n\n/**\n * simplified interface, allows libraries to specify\n * how their data is displayed by Jupyter.\n * Supports multiple MIME formats.\n *\n * Note that MIMEMap defined above is an alias:\n * libraries can implement SimpleRenderer without importing gophernotes\n */\ntype SimpleRenderer = interface {\n\tSimpleRender() MIMEMap\n}\n\n/**\n * specialized interfaces, each is dedicated to a specific MIME type.\n *\n * They are type aliases to emphasize that method signatures\n * are the only important thing, not the interface names.\n * Thus libraries can implement them without importing gophernotes\n */\ntype HTMLer = interface {\n\tHTML() string\n}\ntype JavaScripter = interface {\n\tJavaScript() string\n}\ntype JPEGer = interface {\n\tJPEG() []byte\n}\ntype JSONer = interface {\n\tJSON() map[string]interface{}\n}\ntype Latexer = interface {\n\tLatex() string\n}\ntype Markdowner = interface {\n\tMarkdown() string\n}\ntype PNGer = interface {\n\tPNG() []byte\n}\ntype PDFer = interface {\n\tPDF() []byte\n}\ntype SVGer = interface {\n\tSVG() string\n}\n\n// injected as placeholder in the interpreter, it's then replaced at runtime\n// by a closure that knows how to talk with Jupyter\nfunc stubDisplay(Data) error {\n\treturn errors.New(\"cannot display: connection with Jupyter not available\")\n}\n\n// fill kernel.renderer map used to convert interpreted types\n// to known rendering interfaces\nfunc (kernel *Kernel) initRenderers() {\n\tkernel.render = make(map[string]xreflect.Type)\n\tfor name, typ := range kernel.display.Types {\n\t\tif typ.Kind() == reflect.Interface {\n\t\t\tkernel.render[name] = typ\n\t\t}\n\t}\n}\n\n// if vals[] contain a single non-nil value which is auto-renderable,\n// convert it to Data and return it.\n// otherwise return MakeData(\"text/plain\", fmt.Sprint(vals...))\nfunc (kernel *Kernel) autoRenderResults(vals []interface{}, types []xreflect.Type) Data {\n\tvar nilcount int\n\tvar obj interface{}\n\tvar typ xreflect.Type\n\tfor i, val := range vals {\n\t\tif kernel.canAutoRender(val, types[i]) {\n\t\t\tobj = val\n\t\t\ttyp = types[i]\n\t\t} else if val == nil {\n\t\t\tnilcount++\n\t\t}\n\t}\n\tif obj != nil && nilcount == len(vals)-1 {\n\t\treturn kernel.autoRender(\"\", obj, typ)\n\t}\n\tif nilcount == len(vals) {\n\t\t// if all values are nil, return empty Data\n\t\treturn Data{}\n\t}\n\treturn MakeData(MIMETypeText, anyToString(vals...))\n}\n\nfunc anyToString(vals ...interface{}) string {\n\tvar buf strings.Builder\n\tfor i, val := range vals {\n\t\tif i != 0 {\n\t\t\tbuf.WriteByte(' ')\n\t\t}\n\t\tfmt.Fprint(&buf, val)\n\t}\n\treturn buf.String()\n}\n\n// return true if data type should be auto-rendered graphically\nfunc (kernel *Kernel) canAutoRender(data interface{}, typ xreflect.Type) bool {\n\tswitch data.(type) {\n\tcase Data, Renderer, SimpleRenderer, HTMLer, JavaScripter, JPEGer, JSONer,\n\t\tLatexer, Markdowner, PNGer, PDFer, SVGer, image.Image:\n\t\treturn true\n\t}\n\tif kernel == nil || typ == nil {\n\t\treturn false\n\t}\n\t// in gomacro, methods of interpreted types are emulated,\n\t// thus type-asserting them to interface types as done above cannot succeed.\n\t// Manually check if emulated type \"pretends\" to implement\n\t// at least one of the interfaces above\n\tfor _, xtyp := range kernel.render {\n\t\tif typ.Implements(xtyp) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nvar autoRenderers = map[string]func(Data, interface{}) Data{\n\t\"Renderer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(Renderer); ok {\n\t\t\tx := r.Render()\n\t\t\td.Data = merge(d.Data, x.Data)\n\t\t\td.Metadata = merge(d.Metadata, x.Metadata)\n\t\t\td.Transient = merge(d.Transient, x.Transient)\n\t\t}\n\t\treturn d\n\t},\n\t\"SimpleRenderer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(SimpleRenderer); ok {\n\t\t\tx := r.SimpleRender()\n\t\t\td.Data = merge(d.Data, x)\n\t\t}\n\t\treturn d\n\t},\n\t\"HTMLer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(HTMLer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeHTML] = r.HTML()\n\t\t}\n\t\treturn d\n\t},\n\t\"JavaScripter\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(JavaScripter); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeJavaScript] = r.JavaScript()\n\t\t}\n\t\treturn d\n\t},\n\t\"JPEGer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(JPEGer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeJPEG] = r.JPEG()\n\t\t}\n\t\treturn d\n\t},\n\t\"JSONer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(JSONer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeJSON] = r.JSON()\n\t\t}\n\t\treturn d\n\t},\n\t\"Latexer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(Latexer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeLatex] = r.Latex()\n\t\t}\n\t\treturn d\n\t},\n\t\"Markdowner\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(Markdowner); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeMarkdown] = r.Markdown()\n\t\t}\n\t\treturn d\n\t},\n\t\"PNGer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(PNGer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypePNG] = r.PNG()\n\t\t}\n\t\treturn d\n\t},\n\t\"PDFer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(PDFer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypePDF] = r.PDF()\n\t\t}\n\t\treturn d\n\t},\n\t\"SVGer\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(SVGer); ok {\n\t\t\td.Data = ensure(d.Data)\n\t\t\td.Data[MIMETypeSVG] = r.SVG()\n\t\t}\n\t\treturn d\n\t},\n\t\"Image\": func(d Data, i interface{}) Data {\n\t\tif r, ok := i.(image.Image); ok {\n\t\t\tb, mimeType, err := encodePng(r)\n\t\t\tif err != nil {\n\t\t\t\td = makeDataErr(err)\n\t\t\t} else {\n\t\t\t\td.Data = ensure(d.Data)\n\t\t\t\td.Data[mimeType] = b\n\t\t\t\td.Metadata = merge(d.Metadata, imageMetadata(r))\n\t\t\t}\n\t\t}\n\t\treturn d\n\t},\n}\n\n// detect and render data types that should be auto-rendered graphically\nfunc (kernel *Kernel) autoRender(mimeType string, arg interface{}, typ xreflect.Type) Data {\n\tvar data Data\n\t// try Data\n\tif x, ok := arg.(Data); ok {\n\t\tdata = x\n\t}\n\n\tif kernel == nil || typ == nil {\n\t\t// try all autoRenderers\n\t\tfor _, fun := range autoRenderers {\n\t\t\tdata = fun(data, arg)\n\t\t}\n\t} else {\n\t\t// in gomacro, methods of interpreted types are emulated.\n\t\t// Thus type-asserting them to interface types as done by autoRenderer functions above cannot succeed.\n\t\t// Manually check if emulated type \"pretends\" to implement one or more of the above interfaces\n\t\t// and, in case, tell the interpreter to convert to them\n\t\tfor name, xtyp := range kernel.render {\n\t\t\tfun := autoRenderers[name]\n\t\t\tif fun == nil || !typ.Implements(xtyp) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconv := kernel.ir.Comp.Converter(typ, xtyp)\n\t\t\tx := arg\n\t\t\tif conv != nil {\n\t\t\t\tx = basereflect.ValueInterface(conv(xreflect.ValueOf(x)))\n\t\t\t\tif x == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tdata = fun(data, x)\n\t\t}\n\t}\n\treturn fillDefaults(data, arg, \"\", nil, \"\", nil)\n}\n\nfunc fillDefaults(data Data, arg interface{}, s string, b []byte, mimeType string, err error) Data {\n\tif err != nil {\n\t\treturn makeDataErr(err)\n\t}\n\tif data.Data == nil {\n\t\tdata.Data = make(MIMEMap)\n\t}\n\t// cannot autodetect the mime type of a string\n\tif len(s) != 0 && len(mimeType) != 0 {\n\t\tdata.Data[mimeType] = s\n\t}\n\t// ensure plain text is set\n\tif data.Data[MIMETypeText] == \"\" {\n\t\tif len(s) == 0 {\n\t\t\ts = fmt.Sprint(arg)\n\t\t}\n\t\tdata.Data[MIMETypeText] = s\n\t}\n\t// if []byte is available, use it\n\tif len(b) != 0 {\n\t\tif len(mimeType) == 0 {\n\t\t\tmimeType = http.DetectContentType(b)\n\t\t}\n\t\tif len(mimeType) != 0 && mimeType != MIMETypeText {\n\t\t\tdata.Data[mimeType] = b\n\t\t}\n\t}\n\treturn data\n}\n\n// do our best to render data graphically\nfunc render(mimeType string, data interface{}) Data {\n\tvar kernel *Kernel // intentionally nil\n\tif kernel.canAutoRender(data, nil) {\n\t\treturn kernel.autoRender(mimeType, data, nil)\n\t}\n\tvar s string\n\tvar b []byte\n\tvar err error\n\tswitch data := data.(type) {\n\tcase string:\n\t\ts = data\n\tcase []byte:\n\t\tb = data\n\tcase io.Reader:\n\t\tb, err = ioutil.ReadAll(data)\n\tcase io.WriterTo:\n\t\tvar buf bytes.Buffer\n\t\tdata.WriteTo(&buf)\n\t\tb = buf.Bytes()\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unsupported type, cannot render: %T\", data))\n\t}\n\treturn fillDefaults(Data{}, data, s, b, mimeType, err)\n}\n\nfunc makeDataErr(err error) Data {\n\treturn Data{\n\t\tData: MIMEMap{\n\t\t\t\"ename\":     \"ERROR\",\n\t\t\t\"evalue\":    err.Error(),\n\t\t\t\"traceback\": nil,\n\t\t\t\"status\":    \"error\",\n\t\t},\n\t}\n}\n\nfunc Any(mimeType string, data interface{}) Data {\n\treturn render(mimeType, data)\n}\n\n// same as Any(\"\", data), autodetects MIME type\nfunc Auto(data interface{}) Data {\n\treturn render(\"\", data)\n}\n\nfunc MakeData(mimeType string, data interface{}) Data {\n\td := Data{\n\t\tData: MIMEMap{\n\t\t\tmimeType: data,\n\t\t},\n\t}\n\tif mimeType != MIMETypeText {\n\t\td.Data[MIMETypeText] = fmt.Sprint(data)\n\t}\n\treturn d\n}\n\nfunc MakeData3(mimeType string, plaintext string, data interface{}) Data {\n\treturn Data{\n\t\tData: MIMEMap{\n\t\t\tMIMETypeText: plaintext,\n\t\t\tmimeType:     data,\n\t\t},\n\t}\n}\n\nfunc File(mimeType string, path string) Data {\n\tbytes, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn Any(mimeType, bytes)\n}\n\nfunc HTML(html string) Data {\n\treturn MakeData(MIMETypeHTML, html)\n}\n\nfunc JavaScript(javascript string) Data {\n\treturn MakeData(MIMETypeJavaScript, javascript)\n}\n\nfunc JPEG(jpeg []byte) Data {\n\treturn MakeData(MIMETypeJPEG, jpeg)\n}\n\nfunc JSON(json map[string]interface{}) Data {\n\treturn MakeData(MIMETypeJSON, json)\n}\n\nfunc Latex(latex string) Data {\n\treturn MakeData3(MIMETypeLatex, latex, \"$\"+strings.Trim(latex, \"$\")+\"$\")\n}\n\nfunc Markdown(markdown string) Data {\n\treturn MakeData(MIMETypeMarkdown, markdown)\n}\n\nfunc Math(latex string) Data {\n\treturn MakeData3(MIMETypeLatex, latex, \"$$\"+strings.Trim(latex, \"$\")+\"$$\")\n}\n\nfunc PDF(pdf []byte) Data {\n\treturn MakeData(MIMETypePDF, pdf)\n}\n\nfunc PNG(png []byte) Data {\n\treturn MakeData(MIMETypePNG, png)\n}\n\nfunc SVG(svg string) Data {\n\treturn MakeData(MIMETypeSVG, svg)\n}\n\n// MIME encapsulates the data and metadata into a Data.\n// The 'data' map is expected to contain at least one {key,value} pair,\n// with value being a string, []byte or some other JSON serializable representation,\n// and key equal to the MIME type of such value.\n// The exact structure of value is determined by what the frontend expects.\n// Some easier-to-use functions for common formats supported by the Jupyter frontend\n// are provided by the various functions above.\nfunc MIME(data, metadata MIMEMap) Data {\n\treturn Data{data, metadata, nil}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "files",
          "type": "tree",
          "content": null
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2001953125,
          "content": "module github.com/gopherdata/gophernotes\n\ngo 1.13\n\nrequire (\n\tgithub.com/cosmos72/gomacro v0.0.0-20231101204900-3dc08f5f8fea\n\tgithub.com/go-zeromq/zmq4 v0.15.0\n\tgithub.com/gofrs/uuid v4.4.0+incompatible\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 6.248046875,
          "content": "github.com/cosmos72/gomacro v0.0.0-20231101204900-3dc08f5f8fea h1:UaXbB+Mv9i2roIj0Ka1ATyHrC8JFnycDdj9dZ9RK/sg=\ngithub.com/cosmos72/gomacro v0.0.0-20231101204900-3dc08f5f8fea/go.mod h1:5e35wR9cfXppxd99a3QlRkj0E5qVg2nSA8z5XG0biTc=\ngithub.com/go-zeromq/goczmq/v4 v4.2.2 h1:HAJN+i+3NW55ijMJJhk7oWxHKXgAuSBkoFfvr8bYj4U=\ngithub.com/go-zeromq/goczmq/v4 v4.2.2/go.mod h1:Sm/lxrfxP/Oxqs0tnHD6WAhwkWrx+S+1MRrKzcxoaYE=\ngithub.com/go-zeromq/zmq4 v0.15.0 h1:SLqukpmLTx0JsLaOaCCjwy5eBdfJ+ouJX/677HoFbJM=\ngithub.com/go-zeromq/zmq4 v0.15.0/go.mod h1:sD47DcXifeUFsVTB2ps8ijqTpEuTAlYgfuLoiWEXdCE=\ngithub.com/gofrs/uuid v4.4.0+incompatible h1:3qXRTX8/NbyulANqlc0lchS1gqAVxRgsuW1YrTJupqA=\ngithub.com/gofrs/uuid v4.4.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/mattn/go-runewidth v0.0.3/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/peterh/liner v1.2.2 h1:aJ4AOodmL+JxOZZEL2u9iJf8omNRpqHc/EbrK+3mAXw=\ngithub.com/peterh/liner v1.2.2/go.mod h1:xFwJyiKIXJZUKItq5dGHZSTBRAuG/CpeNpWLyiNRNwI=\ngithub.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.14.0/go.mod h1:MVFd36DqK4CsrnJYDkBA3VC4m2GkXAM0PvzMCn4JQf4=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.13.0 h1:I/DsJXRlw/8l/0c24sM9yb0T4z9liZTduXvdAWYiysY=\ngolang.org/x/mod v0.13.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.16.0/go.mod h1:NxSsAGuq816PNPmqtQdLE42eU2Fs7NoRIZrHJAlaCOE=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220601150217-0de741cfad7f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.4.0 h1:zxkM55ReGkDlKSM+Fu41A+zmbZuaPVbGMzvvdUPznYQ=\ngolang.org/x/sync v0.4.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211117180635-dee7805ff2e1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.13.0 h1:Af8nKPmuFypiUBjVoU9V20FiaFXOcuZI21p0ycVYYGE=\ngolang.org/x/sys v0.13.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.13.0/go.mod h1:LTmsnFJwVN6bCy1rVCoS+qHT1HhALEFxKncY3WNNh4U=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0 h1:ablQoSUd0tRdKxZewP80B+BaqeKJuVhuRxj/dkrun3k=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.14.0 h1:jvNa2pY0M4r62jkRQ6RwEZZyPcymeL9XZMLBbV7U2nc=\ngolang.org/x/tools v0.14.0/go.mod h1:uYBEerGOWcJyEORxN+Ek8+TT266gXkNlHdJBwexUsBg=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 0.9013671875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"image\"\n\t\"image/png\"\n)\n\n// Image converts an image.Image to DisplayData containing PNG []byte,\n// or to DisplayData containing error if the conversion fails\nfunc Image(img image.Image) Data {\n\tbytes, mimeType, err := encodePng(img)\n\tif err != nil {\n\t\treturn makeDataErr(err)\n\t}\n\treturn Data{\n\t\tData: MIMEMap{\n\t\t\tmimeType: bytes,\n\t\t},\n\t\tMetadata: MIMEMap{\n\t\t\tmimeType: imageMetadata(img),\n\t\t},\n\t}\n}\n\n// encodePng converts an image.Image to PNG []byte\nfunc encodePng(img image.Image) (data []byte, mimeType string, err error) {\n\tvar buf bytes.Buffer\n\terr = png.Encode(&buf, img)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\treturn buf.Bytes(), MIMETypePNG, nil\n}\n\n// imageMetadata returns image size, represented as MIMEMap{\"width\": width, \"height\": height}\nfunc imageMetadata(img image.Image) MIMEMap {\n\trect := img.Bounds()\n\treturn MIMEMap{\n\t\t\"width\":  rect.Dx(),\n\t\t\"height\": rect.Dy(),\n\t}\n}\n"
        },
        {
          "name": "imports",
          "type": "tree",
          "content": null
        },
        {
          "name": "kernel.go",
          "type": "blob",
          "size": 20.8720703125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/go-zeromq/zmq4\"\n\n\t\"github.com/cosmos72/gomacro/ast2\"\n\t\"github.com/cosmos72/gomacro/base\"\n\tbasereflect \"github.com/cosmos72/gomacro/base/reflect\"\n\tinterp \"github.com/cosmos72/gomacro/fast\"\n\tmp \"github.com/cosmos72/gomacro/go/parser\"\n\t\"github.com/cosmos72/gomacro/xreflect\"\n\n\t// compile and link files generated in imports/\n\t_ \"github.com/gopherdata/gophernotes/imports\"\n)\n\n// ExecCounter is incremented each time we run user code in the notebook.\nvar ExecCounter int\n\n// ConnectionInfo stores the contents of the kernel connection\n// file created by Jupyter.\ntype ConnectionInfo struct {\n\tSignatureScheme string `json:\"signature_scheme\"`\n\tTransport       string `json:\"transport\"`\n\tStdinPort       int    `json:\"stdin_port\"`\n\tControlPort     int    `json:\"control_port\"`\n\tIOPubPort       int    `json:\"iopub_port\"`\n\tHBPort          int    `json:\"hb_port\"`\n\tShellPort       int    `json:\"shell_port\"`\n\tKey             string `json:\"key\"`\n\tIP              string `json:\"ip\"`\n}\n\n// Socket wraps a zmq socket with a lock which should be used to control write access.\ntype Socket struct {\n\tSocket zmq4.Socket\n\tLock   *sync.Mutex\n}\n\n// SocketGroup holds the sockets needed to communicate with the kernel,\n// and the key for message signing.\ntype SocketGroup struct {\n\tShellSocket   Socket\n\tControlSocket Socket\n\tStdinSocket   Socket\n\tIOPubSocket   Socket\n\tHBSocket      Socket\n\tKey           []byte\n}\n\n// KernelLanguageInfo holds information about the language that this kernel executes code in.\ntype kernelLanguageInfo struct {\n\tName              string `json:\"name\"`\n\tVersion           string `json:\"version\"`\n\tMIMEType          string `json:\"mimetype\"`\n\tFileExtension     string `json:\"file_extension\"`\n\tPygmentsLexer     string `json:\"pygments_lexer\"`\n\tCodeMirrorMode    string `json:\"codemirror_mode\"`\n\tNBConvertExporter string `json:\"nbconvert_exporter\"`\n}\n\n// HelpLink stores data to be displayed in the help menu of the notebook.\ntype helpLink struct {\n\tText string `json:\"text\"`\n\tURL  string `json:\"url\"`\n}\n\n// KernelInfo holds information about the igo kernel, for kernel_info_reply messages.\ntype kernelInfo struct {\n\tProtocolVersion       string             `json:\"protocol_version\"`\n\tImplementation        string             `json:\"implementation\"`\n\tImplementationVersion string             `json:\"implementation_version\"`\n\tLanguageInfo          kernelLanguageInfo `json:\"language_info\"`\n\tBanner                string             `json:\"banner\"`\n\tHelpLinks             []helpLink         `json:\"help_links\"`\n}\n\n// shutdownReply encodes a boolean indication of shutdown/restart.\ntype shutdownReply struct {\n\tRestart bool `json:\"restart\"`\n}\n\n// isCompleteReply holds information about the statement is complete or not, for is_complete_reply messages.\ntype isCompleteReply struct {\n\tStatus string `json:\"status\"`\n\tIndent string `json:\"indent\"`\n}\n\nconst (\n\tkernelStarting = \"starting\"\n\tkernelBusy     = \"busy\"\n\tkernelIdle     = \"idle\"\n)\n\n// RunWithSocket invokes the `run` function after acquiring the `Socket.Lock` and releases the lock when done.\nfunc (s *Socket) RunWithSocket(run func(socket zmq4.Socket) error) error {\n\ts.Lock.Lock()\n\tdefer s.Lock.Unlock()\n\treturn run(s.Socket)\n}\n\ntype Kernel struct {\n\tir      *interp.Interp\n\tdisplay *interp.Import\n\t// map name -> HTMLer, JSONer, Renderer...\n\t// used to convert interpreted types to one of these interfaces\n\trender map[string]xreflect.Type\n}\n\n// runKernel is the main entry point to start the kernel.\nfunc runKernel(connectionFile string) {\n\n\t// Create a new interpreter for evaluating notebook code.\n\tir := interp.New()\n\n\t// Throw out the error/warning messages that gomacro outputs writes to these streams.\n\tir.Comp.Stdout = ioutil.Discard\n\tir.Comp.Stderr = ioutil.Discard\n\n\t// Inject the \"display\" package to render HTML, JSON, PNG, JPEG, SVG... from interpreted code\n\t// maybe a dot-import is easier to use?\n\tdisplay := importPackage(ir, \"display\", \"display\")\n\n\t// Inject the stub \"Display\" function. declare a variable\n\t// instead of a function, because we want to later change\n\t// its value to the closure that holds a reference to msgReceipt\n\tir.DeclVar(\"Display\", nil, stubDisplay)\n\n\t// Parse the connection info.\n\tvar connInfo ConnectionInfo\n\n\tconnData, err := ioutil.ReadFile(connectionFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err = json.Unmarshal(connData, &connInfo); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Set up the ZMQ sockets through which the kernel will communicate.\n\tsockets, err := prepareSockets(connInfo)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// TODO connect all channel handlers to a WaitGroup to ensure shutdown before returning from runKernel.\n\n\t// Start up the heartbeat handler.\n\tstartHeartbeat(sockets.HBSocket, &sync.WaitGroup{})\n\n\t// TODO gracefully shutdown the heartbeat handler on kernel shutdown by closing the chan returned by startHeartbeat.\n\n\ttype msgType struct {\n\t\tMsg zmq4.Msg\n\t\tErr error\n\t}\n\n\tvar (\n\t\tshell = make(chan msgType)\n\t\tstdin = make(chan msgType)\n\t\tctl   = make(chan msgType)\n\t\tquit  = make(chan int)\n\t)\n\n\tdefer close(quit)\n\tpoll := func(msgs chan msgType, sck zmq4.Socket) {\n\t\tdefer close(msgs)\n\t\tfor {\n\t\t\tmsg, err := sck.Recv()\n\t\t\tselect {\n\t\t\tcase msgs <- msgType{Msg: msg, Err: err}:\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tgo poll(shell, sockets.ShellSocket.Socket)\n\tgo poll(stdin, sockets.StdinSocket.Socket)\n\tgo poll(ctl, sockets.ControlSocket.Socket)\n\n\tkernel := Kernel{\n\t\tir,\n\t\tdisplay,\n\t\tnil,\n\t}\n\tkernel.initRenderers()\n\n\t// Start a message receiving loop.\n\tfor {\n\t\tselect {\n\t\tcase v := <-shell:\n\t\t\t// Handle shell messages.\n\t\t\tif v.Err != nil {\n\t\t\t\tlog.Println(v.Err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmsg, ids, err := WireMsgToComposedMsg(v.Msg.Frames, sockets.Key)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tkernel.handleShellMsg(msgReceipt{msg, ids, sockets})\n\n\t\tcase <-stdin:\n\t\t\t// TODO Handle stdin socket.\n\t\t\tcontinue\n\n\t\tcase v := <-ctl:\n\t\t\tif v.Err != nil {\n\t\t\t\tlog.Println(v.Err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmsg, ids, err := WireMsgToComposedMsg(v.Msg.Frames, sockets.Key)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tkernel.handleShellMsg(msgReceipt{msg, ids, sockets})\n\t\t}\n\t}\n}\n\nfunc importPackage(ir *interp.Interp, path string, alias string) *interp.Import {\n\tpackages, err := ir.ImportPackagesOrError(\n\t\tmap[string]interp.PackageName{\n\t\t\tpath: interp.PackageName(alias),\n\t\t})\n\tif err != nil {\n\t\tlog.Print(err)\n\t}\n\treturn packages[path]\n}\n\n// prepareSockets sets up the ZMQ sockets through which the kernel\n// will communicate.\nfunc prepareSockets(connInfo ConnectionInfo) (SocketGroup, error) {\n\t// Initialize the socket group.\n\tvar (\n\t\tsg  SocketGroup\n\t\terr error\n\t\tctx = context.Background()\n\t)\n\n\t// Create the shell socket, a request-reply socket that may receive messages from multiple frontend for\n\t// code execution, introspection, auto-completion, etc.\n\tsg.ShellSocket.Socket = zmq4.NewRouter(ctx)\n\tsg.ShellSocket.Lock = &sync.Mutex{}\n\n\t// Create the control socket. This socket is a duplicate of the shell socket where messages on this channel\n\t// should jump ahead of queued messages on the shell socket.\n\tsg.ControlSocket.Socket = zmq4.NewRouter(ctx)\n\tsg.ControlSocket.Lock = &sync.Mutex{}\n\n\t// Create the stdin socket, a request-reply socket used to request user input from a front-end. This is analogous\n\t// to a standard input stream.\n\tsg.StdinSocket.Socket = zmq4.NewRouter(ctx)\n\tsg.StdinSocket.Lock = &sync.Mutex{}\n\n\t// Create the iopub socket, a publisher for broadcasting data like stdout/stderr output, displaying execution\n\t// results or errors, kernel status, etc. to connected subscribers.\n\tsg.IOPubSocket.Socket = zmq4.NewPub(ctx)\n\tsg.IOPubSocket.Lock = &sync.Mutex{}\n\n\t// Create the heartbeat socket, a request-reply socket that only allows alternating recv-send (request-reply)\n\t// calls. It should echo the byte strings it receives to let the requester know the kernel is still alive.\n\tsg.HBSocket.Socket = zmq4.NewRep(ctx)\n\tsg.HBSocket.Lock = &sync.Mutex{}\n\n\t// Bind the sockets.\n\taddress := fmt.Sprintf(\"%v://%v:%%v\", connInfo.Transport, connInfo.IP)\n\terr = sg.ShellSocket.Socket.Listen(fmt.Sprintf(address, connInfo.ShellPort))\n\tif err != nil {\n\t\treturn sg, fmt.Errorf(\"could not listen on shell-socket: %w\", err)\n\t}\n\n\terr = sg.ControlSocket.Socket.Listen(fmt.Sprintf(address, connInfo.ControlPort))\n\tif err != nil {\n\t\treturn sg, fmt.Errorf(\"could not listen on control-socket: %w\", err)\n\t}\n\n\terr = sg.StdinSocket.Socket.Listen(fmt.Sprintf(address, connInfo.StdinPort))\n\tif err != nil {\n\t\treturn sg, fmt.Errorf(\"could not listen on stdin-socket: %w\", err)\n\t}\n\n\terr = sg.IOPubSocket.Socket.Listen(fmt.Sprintf(address, connInfo.IOPubPort))\n\tif err != nil {\n\t\treturn sg, fmt.Errorf(\"could not listen on iopub-socket: %w\", err)\n\t}\n\n\terr = sg.HBSocket.Socket.Listen(fmt.Sprintf(address, connInfo.HBPort))\n\tif err != nil {\n\t\treturn sg, fmt.Errorf(\"could not listen on hbeat-socket: %w\", err)\n\t}\n\n\t// Set the message signing key.\n\tsg.Key = []byte(connInfo.Key)\n\n\treturn sg, nil\n}\n\n// handleShellMsg responds to a message on the shell ROUTER socket.\nfunc (kernel *Kernel) handleShellMsg(receipt msgReceipt) {\n\t// Tell the front-end that the kernel is working and when finished notify the\n\t// front-end that the kernel is idle again.\n\tif err := receipt.PublishKernelStatus(kernelBusy); err != nil {\n\t\tlog.Printf(\"Error publishing kernel status 'busy': %v\\n\", err)\n\t}\n\tdefer func() {\n\t\tif err := receipt.PublishKernelStatus(kernelIdle); err != nil {\n\t\t\tlog.Printf(\"Error publishing kernel status 'idle': %v\\n\", err)\n\t\t}\n\t}()\n\n\tir := kernel.ir\n\n\tswitch receipt.Msg.Header.MsgType {\n\tcase \"kernel_info_request\":\n\t\tif err := sendKernelInfo(receipt); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\tcase \"is_complete_request\":\n\t\tif err := kernel.handleIsCompleteRequest(receipt); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\tcase \"complete_request\":\n\t\tif err := handleCompleteRequest(ir, receipt); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\tcase \"execute_request\":\n\t\tif err := kernel.handleExecuteRequest(receipt); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\tcase \"shutdown_request\":\n\t\thandleShutdownRequest(receipt)\n\tdefault:\n\t\tlog.Println(\"Unhandled shell message: \", receipt.Msg.Header.MsgType)\n\t}\n}\n\n// sendKernelInfo sends a kernel_info_reply message.\nfunc sendKernelInfo(receipt msgReceipt) error {\n\treturn receipt.Reply(\"kernel_info_reply\",\n\t\tkernelInfo{\n\t\t\tProtocolVersion:       ProtocolVersion,\n\t\t\tImplementation:        \"gophernotes\",\n\t\t\tImplementationVersion: Version,\n\t\t\tBanner:                fmt.Sprintf(\"Go kernel: gophernotes - v%s\", Version),\n\t\t\tLanguageInfo: kernelLanguageInfo{\n\t\t\t\tName:          \"go\",\n\t\t\t\tVersion:       runtime.Version(),\n\t\t\t\tFileExtension: \".go\",\n\t\t\t},\n\t\t\tHelpLinks: []helpLink{\n\t\t\t\t{Text: \"Go\", URL: \"https://golang.org/\"},\n\t\t\t\t{Text: \"gophernotes\", URL: \"https://github.com/gopherdata/gophernotes\"},\n\t\t\t},\n\t\t},\n\t)\n}\n\n// checkComplete checks whether the `code` is complete or not.\nfunc checkComplete(code string, ir *interp.Interp) (status, indent string) {\n\tstatus, indent = \"unknown\", \"\"\n\n\tif len(code) == 0 {\n\t\treturn status, indent\n\t}\n\treadline := base.MakeBufReadline(bufio.NewReader(strings.NewReader(code)))\n\tfor {\n\t\t_, _, err := base.ReadMultiline(readline, base.ReadOptions(0), \"\")\n\t\tif err == io.EOF {\n\t\t\treturn \"complete\", indent\n\t\t} else if err == io.ErrUnexpectedEOF {\n\t\t\treturn \"incomplete\", indent\n\t\t} else if err != nil {\n\t\t\treturn \"invalid\", indent\n\t\t}\n\t}\n\n\tvar parser mp.Parser\n\tg := ir.Comp\n\tparser.Configure(g.ParserMode, g.MacroChar)\n\tparser.Init(g.Fileset, g.Filepath, g.Line, []byte(code))\n\n\t_, err := parser.Parse()\n\tif err != nil {\n\t\tstatus = \"invalid\"\n\t} else {\n\t\tstatus = \"complete\"\n\t}\n\treturn status, indent\n}\n\n// handleIsCompleteRequest sends a is_complete_reply message.\nfunc (kernel *Kernel) handleIsCompleteRequest(receipt msgReceipt) error {\n\n\t// Extract the data from the request.\n\treqcontent := receipt.Msg.Content.(map[string]interface{})\n\tcode := reqcontent[\"code\"].(string)\n\tstatus, indent := checkComplete(code, kernel.ir)\n\n\treturn receipt.Reply(\"is_complete_reply\",\n\t\tisCompleteReply{\n\t\t\tStatus: status,\n\t\t\tIndent: indent,\n\t\t},\n\t)\n}\n\n// handleExecuteRequest runs code from an execute_request method,\n// and sends the various reply messages.\nfunc (kernel *Kernel) handleExecuteRequest(receipt msgReceipt) error {\n\n\t// Extract the data from the request.\n\treqcontent := receipt.Msg.Content.(map[string]interface{})\n\tcode := reqcontent[\"code\"].(string)\n\tsilent := reqcontent[\"silent\"].(bool)\n\n\tif !silent {\n\t\tExecCounter++\n\t}\n\n\t// Prepare the map that will hold the reply content.\n\tcontent := make(map[string]interface{})\n\tcontent[\"execution_count\"] = ExecCounter\n\n\t// Tell the front-end what the kernel is about to execute.\n\tif err := receipt.PublishExecutionInput(ExecCounter, code); err != nil {\n\t\tlog.Printf(\"Error publishing execution input: %v\\n\", err)\n\t}\n\n\t// Redirect the standard out from the REPL.\n\toldStdout := os.Stdout\n\trOut, wOut, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tos.Stdout = wOut\n\n\t// Redirect the standard error from the REPL.\n\toldStderr := os.Stderr\n\trErr, wErr, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\tos.Stderr = wErr\n\n\tvar writersWG sync.WaitGroup\n\twritersWG.Add(2)\n\n\tjupyterStdOut := JupyterStreamWriter{StreamStdout, &receipt}\n\tjupyterStdErr := JupyterStreamWriter{StreamStderr, &receipt}\n\touterr := OutErr{&jupyterStdOut, &jupyterStdErr}\n\n\t// Forward all data written to stdout/stderr to the front-end.\n\tgo func() {\n\t\tdefer writersWG.Done()\n\t\tio.Copy(&jupyterStdOut, rOut)\n\t}()\n\n\tgo func() {\n\t\tdefer writersWG.Done()\n\t\tio.Copy(&jupyterStdErr, rErr)\n\t}()\n\n\t// inject the actual \"Display\" closure that displays multimedia data in Jupyter\n\tir := kernel.ir\n\tdisplayPlace := ir.ValueOf(\"Display\")\n\tdisplayPlace.Set(xreflect.ValueOf(receipt.PublishDisplayData))\n\tdefer func() {\n\t\t// remove the closure before returning\n\t\tdisplayPlace.Set(xreflect.ValueOf(stubDisplay))\n\t}()\n\n\t// eval\n\tvals, types, executionErr := doEval(ir, outerr, code)\n\n\t// Close and restore the streams.\n\twOut.Close()\n\tos.Stdout = oldStdout\n\n\twErr.Close()\n\tos.Stderr = oldStderr\n\n\t// Wait for the writers to finish forwarding the data.\n\twritersWG.Wait()\n\n\tif executionErr == nil {\n\t\t// if the only non-nil value should be auto-rendered graphically, render it\n\t\tdata := kernel.autoRenderResults(vals, types)\n\n\t\tcontent[\"status\"] = \"ok\"\n\t\tcontent[\"user_expressions\"] = make(map[string]string)\n\n\t\tif !silent && len(data.Data) != 0 {\n\t\t\t// Publish the result of the execution.\n\t\t\tif err := receipt.PublishExecutionResult(ExecCounter, data); err != nil {\n\t\t\t\tlog.Printf(\"Error publishing execution result: %v\\n\", err)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcontent[\"status\"] = \"error\"\n\t\tcontent[\"ename\"] = \"ERROR\"\n\t\tcontent[\"evalue\"] = executionErr.Error()\n\t\tcontent[\"traceback\"] = nil\n\n\t\tif err := receipt.PublishExecutionError(executionErr.Error(), []string{executionErr.Error()}); err != nil {\n\t\t\tlog.Printf(\"Error publishing execution error: %v\\n\", err)\n\t\t}\n\t}\n\n\t// Send the output back to the notebook.\n\treturn receipt.Reply(\"execute_reply\", content)\n}\n\n// doEval evaluates the code in the interpreter. This function captures an uncaught panic\n// as well as the values of the last statement/expression.\nfunc doEval(ir *interp.Interp, outerr OutErr, code string) (val []interface{}, typ []xreflect.Type, err error) {\n\n\t// Capture a panic from the evaluation if one occurs and store it in the `err` return parameter.\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tvar ok bool\n\t\t\tif err, ok = r.(error); !ok {\n\t\t\t\terr = errors.New(fmt.Sprint(r))\n\t\t\t}\n\t\t}\n\t}()\n\n\tcode = evalSpecialCommands(ir, outerr, code)\n\n\t// Prepare and perform the multiline evaluation.\n\tcompiler := ir.Comp\n\n\t// Don't show the gomacro prompt.\n\tcompiler.Options &^= base.OptShowPrompt\n\n\t// Don't swallow panics as they are recovered above and handled with a Jupyter `error` message instead.\n\tcompiler.Options &^= base.OptTrapPanic\n\n\t// Reset the error line so that error messages correspond to the lines from the cell.\n\tcompiler.Line = 0\n\n\t// Parse the input code (and don't perform gomacro's macroexpansion).\n\t// These may panic but this will be recovered by the deferred recover() above so that the error\n\t// may be returned instead.\n\tnodes := compiler.ParseBytes([]byte(code))\n\tsrcAst := ast2.AnyToAst(nodes, \"doEval\")\n\n\t// If there is no srcAst then we must be evaluating nothing. The result must be nil then.\n\tif srcAst == nil {\n\t\treturn nil, nil, nil\n\t}\n\n\t// Compile the ast.\n\tcompiledSrc := ir.CompileAst(srcAst)\n\n\t// Evaluate the code.\n\tresults, types := ir.RunExpr(compiledSrc)\n\n\t// Convert results from xreflect.Value to interface{}\n\tvalues := make([]interface{}, len(results))\n\tfor i, result := range results {\n\t\tvalues[i] = basereflect.ValueInterface(result)\n\t}\n\n\treturn values, types, nil\n}\n\n// handleShutdownRequest sends a \"shutdown\" message.\nfunc handleShutdownRequest(receipt msgReceipt) {\n\tcontent := receipt.Msg.Content.(map[string]interface{})\n\trestart := content[\"restart\"].(bool)\n\n\treply := shutdownReply{\n\t\tRestart: restart,\n\t}\n\n\tif err := receipt.Reply(\"shutdown_reply\", reply); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"Shutting down in response to shutdown_request\")\n\tos.Exit(0)\n}\n\n// startHeartbeat starts a go-routine for handling heartbeat ping messages sent over the given `hbSocket`. The `wg`'s\n// `Done` method is invoked after the thread is completely shutdown. To request a shutdown the returned `shutdown` channel\n// can be closed.\nfunc startHeartbeat(hbSocket Socket, wg *sync.WaitGroup) (shutdown chan struct{}) {\n\tquit := make(chan struct{})\n\n\t// Start the handler that will echo any received messages back to the sender.\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\ttype msgType struct {\n\t\t\tMsg zmq4.Msg\n\t\t\tErr error\n\t\t}\n\n\t\tmsgs := make(chan msgType)\n\n\t\tgo func() {\n\t\t\tdefer close(msgs)\n\t\t\tfor {\n\t\t\t\tmsg, err := hbSocket.Socket.Recv()\n\t\t\t\tselect {\n\t\t\t\tcase msgs <- msgType{msg, err}:\n\t\t\t\tcase <-quit:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\ttimeout := time.NewTimer(500 * time.Second)\n\t\tdefer timeout.Stop()\n\n\t\tfor {\n\t\t\ttimeout.Reset(500 * time.Second)\n\t\t\tselect {\n\t\t\tcase <-quit:\n\t\t\t\treturn\n\t\t\tcase <-timeout.C:\n\t\t\t\tcontinue\n\t\t\tcase v := <-msgs:\n\t\t\t\thbSocket.RunWithSocket(func(echo zmq4.Socket) error {\n\t\t\t\t\tif v.Err != nil {\n\t\t\t\t\t\tlog.Fatalf(\"Error reading heartbeat ping bytes: %v\\n\", v.Err)\n\t\t\t\t\t\treturn v.Err\n\t\t\t\t\t}\n\n\t\t\t\t\t// Send the received byte string back to let the front-end know that the kernel is alive.\n\t\t\t\t\tif err := echo.Send(v.Msg); err != nil {\n\t\t\t\t\t\tlog.Printf(\"Error sending heartbeat pong bytes: %b\\n\", err)\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn quit\n}\n\n// find and execute special commands in code, remove them from returned string\nfunc evalSpecialCommands(ir *interp.Interp, outerr OutErr, code string) string {\n\tlines := strings.Split(code, \"\\n\")\n\tstop := false\n\tfor i, line := range lines {\n\t\tline = strings.TrimSpace(line)\n\t\tif len(line) != 0 {\n\t\t\tswitch line[0] {\n\t\t\tcase '%':\n\t\t\t\tevalSpecialCommand(ir, outerr, line)\n\t\t\t\tlines[i] = \"\"\n\t\t\tcase '$':\n\t\t\t\tevalShellCommand(ir, outerr, line)\n\t\t\t\tlines[i] = \"\"\n\t\t\tdefault:\n\t\t\t\t// if a line is NOT a special command,\n\t\t\t\t// stop processing special commands\n\t\t\t\tstop = true\n\t\t\t}\n\t\t}\n\t\tif stop {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn strings.Join(lines, \"\\n\")\n}\n\n// execute special command. line must start with '%'\nfunc evalSpecialCommand(ir *interp.Interp, outerr OutErr, line string) {\n\tconst help string = `\navailable special commands (%):\n%cd [path]\n%go111module {on|off}\n%help\n\nexecute shell commands ($): $command [args...]\nexample:\n$ls -l\n`\n\n\targs := strings.SplitN(line, \" \", 2)\n\tcmd := args[0]\n\targ := \"\"\n\tif len(args) > 1 {\n\t\targ = args[1]\n\t}\n\tswitch cmd {\n\tcase \"%cd\":\n\t\tif arg == \"\" {\n\t\t\thome, err := os.UserHomeDir()\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"error getting user home directory: %v\", err))\n\t\t\t}\n\t\t\targ = home\n\t\t}\n\t\terr := os.Chdir(arg)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Errorf(\"error setting current directory to %q: %v\", arg, err))\n\t\t}\n\tcase \"%go111module\":\n\t\tif arg == \"on\" {\n\t\t\tir.Comp.CompGlobals.Options |= base.OptModuleImport\n\t\t} else if arg == \"off\" {\n\t\t\tir.Comp.CompGlobals.Options &^= base.OptModuleImport\n\t\t} else {\n\t\t\tpanic(fmt.Errorf(\"special command %s: expecting a single argument 'on' or 'off', found: %q\", cmd, arg))\n\t\t}\n\tcase \"%help\":\n\t\touterr.out.Write([]byte(help))\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown special command: %q\\n%s\", line, help))\n\t}\n}\n\n// execute shell command. line must start with '$'\nfunc evalShellCommand(ir *interp.Interp, outerr OutErr, line string) {\n\targs := strings.Fields(line[1:])\n\tif len(args) <= 0 {\n\t\treturn\n\t}\n\n\tvar writersWG sync.WaitGroup\n\twritersWG.Add(2)\n\n\tcmd := exec.Command(args[0], args[1:]...)\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"Command.StdoutPipe() failed: %v\", err))\n\t}\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"Command.StderrPipe() failed: %v\", err))\n\t}\n\n\tgo func() {\n\t\tdefer writersWG.Done()\n\t\tio.Copy(outerr.out, stdout)\n\t}()\n\n\tgo func() {\n\t\tdefer writersWG.Done()\n\t\tio.Copy(outerr.err, stderr)\n\t}()\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"error starting command '%s': %v\", line[1:], err))\n\t}\n\n\terr = cmd.Wait()\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"error waiting for command '%s': %v\", line[1:], err))\n\t}\n\n\twritersWG.Wait()\n}\n"
        },
        {
          "name": "kernel",
          "type": "tree",
          "content": null
        },
        {
          "name": "kernel_test.go",
          "type": "blob",
          "size": 16.740234375,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-zeromq/zmq4\"\n)\n\nconst (\n\tfailure = \"\\u2717\"\n\tsuccess = \"\\u2713\"\n)\n\nconst (\n\tconnectionFile = \"fixtures/connection_file.json\"\n\tsessionID      = \"ba65a05c-106a-4799-9a94-7f5631bbe216\"\n)\n\nvar (\n\tconnectionKey string\n\ttransport     string\n\tip            string\n\tshellPort     int\n\tiopubPort     int\n)\n\n//==============================================================================\n\nfunc TestMain(m *testing.M) {\n\tos.Exit(runTest(m))\n}\n\n// runTest initializes the environment for the tests and allows for\n// the proper exit if the test fails or succeeds.\nfunc runTest(m *testing.M) int {\n\t// Parse the connection info.\n\tvar connInfo ConnectionInfo\n\n\tconnData, err := ioutil.ReadFile(connectionFile)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tif err = json.Unmarshal(connData, &connInfo); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Store the connection parameters globally for use by the test client.\n\tconnectionKey = connInfo.Key\n\ttransport = connInfo.Transport\n\tip = connInfo.IP\n\tshellPort = connInfo.ShellPort\n\tiopubPort = connInfo.IOPubPort\n\n\t// Start the kernel.\n\tgo runKernel(connectionFile)\n\n\treturn m.Run()\n}\n\n//==============================================================================\n\n// TestEvaluate tests the evaluation of consecutive cells.\nfunc TestEvaluate(t *testing.T) {\n\tcases := []struct {\n\t\tInput  []string\n\t\tOutput string\n\t}{\n\t\t{[]string{\n\t\t\t\"a := 1\",\n\t\t\t\"a\",\n\t\t}, \"1\"},\n\t\t{[]string{\n\t\t\t\"a = 2\",\n\t\t\t\"a + 3\",\n\t\t}, \"5\"},\n\t\t{[]string{\n\t\t\t\"func myFunc(x int) int {\",\n\t\t\t\"    return x+1\",\n\t\t\t\"}\",\n\t\t\t\"myFunc(1)\",\n\t\t}, \"2\"},\n\t\t{[]string{\n\t\t\t\"b := myFunc(1)\",\n\t\t}, \"\"},\n\t\t{[]string{\n\t\t\t\"type Rect struct {\",\n\t\t\t\"    Width, Height int\",\n\t\t\t\"}\",\n\t\t\t\"Rect{10, 30}\",\n\t\t}, \"{10 30}\"},\n\t\t{[]string{\n\t\t\t\"type Rect struct {\",\n\t\t\t\"    Width, Height int\",\n\t\t\t\"}\",\n\t\t\t\"&Rect{10, 30}\",\n\t\t}, \"&{10 30}\"},\n\t\t{[]string{\n\t\t\t\"func a(b int) (int, int) {\",\n\t\t\t\"    return 2 + b, b\",\n\t\t\t\"}\",\n\t\t\t\"a(10)\",\n\t\t}, \"12 10\"},\n\t\t{[]string{\n\t\t\t`import \"errors\"`,\n\t\t\t\"func a() (interface{}, error) {\",\n\t\t\t`    return nil, errors.New(\"To err is human\")`,\n\t\t\t\"}\",\n\t\t\t\"a()\",\n\t\t}, \"<nil> To err is human\"},\n\t\t{[]string{\n\t\t\t`c := []string{\"gophernotes\", \"is\", \"super\", \"bad\"}`,\n\t\t\t\"c[:3]\",\n\t\t}, \"[gophernotes is super]\"},\n\t\t{[]string{\n\t\t\t\"m := map[string]int{\",\n\t\t\t`    \"a\": 10,`,\n\t\t\t`    \"c\": 30,`,\n\t\t\t\"}\",\n\t\t\t`m[\"c\"]`,\n\t\t}, \"30 true\"},\n\t\t{[]string{\n\t\t\t\"if 1 < 2 {\",\n\t\t\t\"    3\",\n\t\t\t\"}\",\n\t\t}, \"\"},\n\t\t{[]string{\n\t\t\t\"d := 10\",\n\t\t\t\"d++\",\n\t\t}, \"\"},\n\t\t{[]string{\n\t\t\t\"out := make(chan int)\",\n\t\t\t\"go func() {\",\n\t\t\t\"    out <- 123\",\n\t\t\t\"}()\",\n\t\t\t\"<-out\",\n\t\t}, \"123 true\"},\n\t}\n\n\tt.Logf(\"Should be able to evaluate valid code in notebook cells.\")\n\n\tfor k, tc := range cases {\n\n\t\t// Give a progress report.\n\t\tt.Logf(\"  Evaluating code snippet %d/%d.\", k+1, len(cases))\n\n\t\t// Get the result.\n\t\tresult := testEvaluate(t, strings.Join(tc.Input, \"\\n\"))\n\n\t\t// Compare the result.\n\t\tif result != tc.Output {\n\t\t\tt.Errorf(\"\\t%s Test case produced unexpected results.\", failure)\n\t\t\tcontinue\n\t\t}\n\t\tt.Logf(\"\\t%s Should return the correct cell output.\", success)\n\t}\n}\n\n// testEvaluate evaluates a cell.\nfunc testEvaluate(t *testing.T, codeIn string) string {\n\tclient, closeClient := newTestJupyterClient(t)\n\tdefer closeClient()\n\n\tcontent, pub := client.executeCode(t, codeIn)\n\n\tstatus := getString(t, \"content\", content, \"status\")\n\n\tif status != \"ok\" {\n\t\tt.Fatalf(\"\\t%s Execution encountered error [%s]: %s\", failure, content[\"ename\"], content[\"evalue\"])\n\t}\n\n\tfor _, pubMsg := range pub {\n\t\tif pubMsg.Header.MsgType == \"execute_result\" {\n\t\t\tcontent = getMsgContentAsJSONObject(t, pubMsg)\n\n\t\t\tbundledMIMEData := getJSONObject(t, \"content\", content, \"data\")\n\t\t\ttextRep := getString(t, `content[\"data\"]`, bundledMIMEData, \"text/plain\")\n\n\t\t\treturn textRep\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\n// TestPanicGeneratesError tests that executing code with an un-recovered panic properly generates both\n// an error \"execute_reply\" and publishes an \"error\" message.\nfunc TestPanicGeneratesError(t *testing.T) {\n\tclient, closeClient := newTestJupyterClient(t)\n\tdefer closeClient()\n\n\tcontent, pub := client.executeCode(t, `panic(\"error\")`)\n\n\tstatus := getString(t, \"content\", content, \"status\")\n\n\tif status != \"error\" {\n\t\tt.Fatalf(\"\\t%s Execution did not raise expected error\", failure)\n\t}\n\n\tvar foundPublishedError bool\n\tfor _, pubMsg := range pub {\n\t\tif pubMsg.Header.MsgType == \"error\" {\n\t\t\tfoundPublishedError = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !foundPublishedError {\n\t\tt.Fatalf(\"\\t%s Execution did not publish an expected \\\"error\\\" message\", failure)\n\t}\n}\n\n// TestPrintStdout tests that data written to stdout publishes the same data in a \"stdout\" \"stream\" message.\nfunc TestPrintStdout(t *testing.T) {\n\tcases := []struct {\n\t\tInput  []string\n\t\tOutput []string\n\t}{\n\t\t{[]string{\n\t\t\t`import \"fmt\"`,\n\t\t\t\"a := 1\",\n\t\t\t\"fmt.Println(a)\",\n\t\t}, []string{\"1\\n\"}},\n\t\t{[]string{\n\t\t\t\"a = 2\",\n\t\t\t\"fmt.Print(a)\",\n\t\t}, []string{\"2\"}},\n\t\t{[]string{\n\t\t\t`import \"os\"`,\n\t\t\t`os.Stdout.WriteString(\"3\")`,\n\t\t}, []string{\"3\"}},\n\t\t{[]string{\n\t\t\t`fmt.Fprintf(os.Stdout, \"%d\\n\", 4)`,\n\t\t}, []string{\"4\\n\"}},\n\t\t{[]string{\n\t\t\t`import \"time\"`,\n\t\t\t\"for i := 0; i < 3; i++ {\",\n\t\t\t\"    fmt.Println(i)\",\n\t\t\t\"    time.Sleep(500 * time.Millisecond)\", // Stall to prevent prints from buffering into single message.\n\t\t\t\"}\",\n\t\t}, []string{\"0\\n\", \"1\\n\", \"2\\n\"}},\n\t}\n\n\tt.Logf(\"Should produce stdout stream messages when writing to stdout\")\n\ncases:\n\tfor k, tc := range cases {\n\t\t// Give a progress report.\n\t\tt.Logf(\"  Evaluating code snippet %d/%d.\", k+1, len(cases))\n\n\t\t// Get the result.\n\t\tstdout, _ := testOutputStream(t, strings.Join(tc.Input, \"\\n\"))\n\n\t\t// Compare the result.\n\t\tif len(stdout) != len(tc.Output) {\n\t\t\tt.Errorf(\"\\t%s Test case expected %d message(s) on stdout but got %d.\", failure, len(tc.Output), len(stdout))\n\t\t\tcontinue\n\t\t}\n\t\tfor i, expected := range tc.Output {\n\t\t\tif stdout[i] != expected {\n\t\t\t\tt.Errorf(\"\\t%s Test case returned unexpected messages on stdout.\", failure)\n\t\t\t\tcontinue cases\n\t\t\t}\n\t\t}\n\t\tt.Logf(\"\\t%s Returned the expected messages on stdout.\", success)\n\t}\n}\n\n// TestPrintStderr tests that data written to stderr publishes the same data in a \"stderr\" \"stream\" message.\nfunc TestPrintStderr(t *testing.T) {\n\tcases := []struct {\n\t\tInput  []string\n\t\tOutput []string\n\t}{\n\t\t{[]string{\n\t\t\t`import \"fmt\"`,\n\t\t\t`import \"os\"`,\n\t\t\t\"a := 1\",\n\t\t\t\"fmt.Fprintln(os.Stderr, a)\",\n\t\t}, []string{\"1\\n\"}},\n\t\t{[]string{\n\t\t\t`os.Stderr.WriteString(\"2\")`,\n\t\t}, []string{\"2\"}},\n\t\t{[]string{\n\t\t\t`import \"time\"`,\n\t\t\t\"for i := 0; i < 3; i++ {\",\n\t\t\t\"    fmt.Fprintln(os.Stderr, i)\",\n\t\t\t\"    time.Sleep(500 * time.Millisecond)\", // Stall to prevent prints from buffering into single message.\n\t\t\t\"}\",\n\t\t}, []string{\"0\\n\", \"1\\n\", \"2\\n\"}},\n\t}\n\n\tt.Logf(\"Should produce stderr stream messages when writing to stderr\")\n\ncases:\n\tfor k, tc := range cases {\n\t\t// Give a progress report.\n\t\tt.Logf(\"  Evaluating code snippet %d/%d.\", k+1, len(cases))\n\n\t\t// Get the result.\n\t\t_, stderr := testOutputStream(t, strings.Join(tc.Input, \"\\n\"))\n\n\t\t// Compare the result.\n\t\tif len(stderr) != len(tc.Output) {\n\t\t\tt.Errorf(\"\\t%s Test case expected %d message(s) on stderr but got %d.\", failure, len(tc.Output), len(stderr))\n\t\t\tcontinue\n\t\t}\n\t\tfor i, expected := range tc.Output {\n\t\t\tif stderr[i] != expected {\n\t\t\t\tt.Errorf(\"\\t%s Test case returned unexpected messages on stderr.\", failure)\n\t\t\t\tcontinue cases\n\t\t\t}\n\t\t}\n\t\tt.Logf(\"\\t%s Returned the expected messages on stderr.\", success)\n\t}\n}\n\n//==============================================================================\n\n// testJupyterClient holds references to the 2 sockets it uses to communicate with the kernel.\ntype testJupyterClient struct {\n\tshellSocket zmq4.Socket\n\tioSocket    zmq4.Socket\n}\n\n// newTestJupyterClient creates and connects a fresh client to the kernel. Upon error, newTestJupyterClient\n// will Fail the test.\nfunc newTestJupyterClient(t *testing.T) (testJupyterClient, func()) {\n\tt.Helper()\n\n\tvar (\n\t\terr       error\n\t\tctx       = context.Background()\n\t\taddrShell = fmt.Sprintf(\"%s://%s:%d\", transport, ip, shellPort)\n\t\taddrIO    = fmt.Sprintf(\"%s://%s:%d\", transport, ip, iopubPort)\n\t)\n\n\t// Prepare the shell socket.\n\tshell := zmq4.NewReq(ctx)\n\tif err = shell.Dial(addrShell); err != nil {\n\t\tt.Fatalf(\"\\t%s shell.Connect: %s\", failure, err)\n\t}\n\n\t// Prepare the IOPub socket.\n\tiopub := zmq4.NewSub(ctx)\n\tif err = iopub.Dial(addrIO); err != nil {\n\t\tt.Fatalf(\"\\t%s iopub.Connect: %s\", failure, err)\n\t}\n\n\tif err = iopub.SetOption(zmq4.OptionSubscribe, \"\"); err != nil {\n\t\tt.Fatalf(\"\\t%s iopub.SetSubscribe: %s\", failure, err)\n\t}\n\n\t// Wait for a second to give the tcp connection time to complete to avoid missing the early pub messages.\n\ttime.Sleep(1 * time.Second)\n\n\treturn testJupyterClient{shell, iopub}, func() {\n\t\tif err := shell.Close(); err != nil {\n\t\t\tt.Errorf(\"\\t%s shell.Close: %s\", failure, err)\n\t\t}\n\t\tif err = iopub.Close(); err != nil {\n\t\t\tt.Errorf(\"\\t%s iopub.Close: %s\", failure, err)\n\t\t}\n\t}\n}\n\n// sendShellRequest sends a message to the kernel over the shell channel. Upon error, sendShellRequest\n// will Fail the test.\nfunc (client *testJupyterClient) sendShellRequest(t *testing.T, request ComposedMsg) {\n\tt.Helper()\n\n\tvar (\n\t\tframes [][]byte\n\t\terr    error\n\t)\n\n\tframes = append(frames, []byte(\"<IDS|MSG>\"))\n\n\treqMsgParts, err := request.ToWireMsg([]byte(connectionKey))\n\tif err != nil {\n\t\tt.Fatalf(\"\\t%s request.ToWireMsg: %s\", failure, err)\n\t}\n\tframes = append(frames, reqMsgParts...)\n\n\tif err = client.shellSocket.SendMulti(zmq4.NewMsgFrom(frames...)); err != nil {\n\t\tt.Fatalf(\"\\t%s shellSocket.SendMessage: %s\", failure, err)\n\t}\n}\n\n// recvShellReply tries to read a reply message from the shell channel. It will timeout after the given\n// timeout delay. Upon error or timeout, recvShellReply will Fail the test.\nfunc (client *testJupyterClient) recvShellReply(t *testing.T, timeout time.Duration) ComposedMsg {\n\tt.Helper()\n\n\tch := make(chan ComposedMsg)\n\n\tgo func() {\n\t\trepMsgParts, err := client.shellSocket.Recv()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"\\t%s Shell socket RecvMessageBytes: %s\", failure, err)\n\t\t}\n\n\t\tmsgParsed, _, err := WireMsgToComposedMsg(repMsgParts.Frames, []byte(connectionKey))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"\\t%s Could not parse wire message: %s\", failure, err)\n\t\t}\n\n\t\tch <- msgParsed\n\t}()\n\n\tvar reply ComposedMsg\n\n\tselect {\n\tcase reply = <-ch:\n\t\treturn reply\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"\\t%s recvShellReply timed out\", failure)\n\t}\n\n\treturn reply\n}\n\n// recvIOSub tries to read a published message from the IOPub channel. It will timeout after the given\n// timeout delay. Upon error or timeout, recvIOSub will Fail the test.\nfunc (client *testJupyterClient) recvIOSub(t *testing.T, timeout time.Duration) ComposedMsg {\n\tt.Helper()\n\n\tch := make(chan ComposedMsg)\n\n\tgo func() {\n\t\trepMsgParts, err := client.ioSocket.Recv()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"\\t%s IOPub socket RecvMessageBytes: %s\", failure, err)\n\t\t}\n\n\t\tmsgParsed, _, err := WireMsgToComposedMsg(repMsgParts.Frames, []byte(connectionKey))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"\\t%s Could not parse wire message: %s\", failure, err)\n\t\t}\n\n\t\tch <- msgParsed\n\t}()\n\n\tvar sub ComposedMsg\n\tselect {\n\tcase sub = <-ch:\n\tcase <-time.After(timeout):\n\t\tt.Fatalf(\"\\t%s recvIOSub timed out\", failure)\n\t}\n\n\treturn sub\n}\n\n// performJupyterRequest preforms a request and awaits a reply on the shell channel. Additionally all messages on the\n// IOPub channel between the opening 'busy' messages and closing 'idle' message are captured and returned. The request\n// will timeout after the given timeout delay. Upon error or timeout, request will Fail the test.\nfunc (client *testJupyterClient) performJupyterRequest(t *testing.T, request ComposedMsg, timeout time.Duration) (ComposedMsg, []ComposedMsg) {\n\tt.Helper()\n\n\tclient.sendShellRequest(t, request)\n\treply := client.recvShellReply(t, timeout)\n\n\t// Read the expected 'busy' message and ensure it is in fact, a 'busy' message.\n\tsubMsg := client.recvIOSub(t, 1*time.Second)\n\tassertMsgTypeEquals(t, subMsg, \"status\")\n\n\tsubData := getMsgContentAsJSONObject(t, subMsg)\n\texecState := getString(t, \"content\", subData, \"execution_state\")\n\n\tif execState != kernelBusy {\n\t\tt.Fatalf(\"\\t%s Expected a 'busy' status message but got '%s'\", failure, execState)\n\t}\n\n\tvar pub []ComposedMsg\n\n\t// Read messages from the IOPub channel until an 'idle' message is received.\n\tfor {\n\t\tsubMsg = client.recvIOSub(t, 100*time.Millisecond)\n\n\t\t// If the message is a 'status' message, ensure it is an 'idle' status.\n\t\tif subMsg.Header.MsgType == \"status\" {\n\t\t\tsubData = getMsgContentAsJSONObject(t, subMsg)\n\t\t\texecState = getString(t, \"content\", subData, \"execution_state\")\n\n\t\t\tif execState != kernelIdle {\n\t\t\t\tt.Fatalf(\"\\t%s Expected a 'idle' status message but got '%s'\", failure, execState)\n\t\t\t}\n\n\t\t\t// Break from the loop as we don't expect any other IOPub messages after the 'idle'.\n\t\t\tbreak\n\t\t}\n\n\t\t// Add the message to the pub collection.\n\t\tpub = append(pub, subMsg)\n\t}\n\n\treturn reply, pub\n}\n\n// executeCode creates an execute request for the given code and preforms the request. It returns the content of the\n// reply as well as all of the messages captured from the IOPub channel during the execution.\nfunc (client *testJupyterClient) executeCode(t *testing.T, code string) (map[string]interface{}, []ComposedMsg) {\n\tt.Helper()\n\n\t// Create a message.\n\trequest, err := NewMsg(\"execute_request\", ComposedMsg{})\n\tif err != nil {\n\t\tt.Fatalf(\"\\t%s NewMsg: %s\", failure, err)\n\t}\n\n\t// Fill in remaining header information.\n\trequest.Header.Session = sessionID\n\trequest.Header.Username = \"KernelTester\"\n\n\t// Fill in Metadata.\n\trequest.Metadata = make(map[string]interface{})\n\n\t// Fill in content.\n\tcontent := make(map[string]interface{})\n\tcontent[\"code\"] = code\n\tcontent[\"silent\"] = false\n\trequest.Content = content\n\n\t// Make the request.\n\treply, pub := client.performJupyterRequest(t, request, 10*time.Second)\n\n\t// Ensure the reply is an execute_reply and extract the content from the reply.\n\tassertMsgTypeEquals(t, reply, \"execute_reply\")\n\tcontent = getMsgContentAsJSONObject(t, reply)\n\n\treturn content, pub\n}\n\n// assertMsgTypeEquals is a test helper that fails the test if the message header's MsgType is not the\n// expectedType.\nfunc assertMsgTypeEquals(t *testing.T, msg ComposedMsg, expectedType string) {\n\tt.Helper()\n\n\tif msg.Header.MsgType != expectedType {\n\t\tt.Fatalf(\"\\t%s Expected message of type '%s' but was '%s'\", failure, expectedType, msg.Header.MsgType)\n\t}\n}\n\n// getMsgContentAsJSONObject is a test helper that fails the rest if the message content is not a\n// map[string]interface{} and returns the content as a map[string]interface{} if it is of the correct type.\nfunc getMsgContentAsJSONObject(t *testing.T, msg ComposedMsg) map[string]interface{} {\n\tt.Helper()\n\n\tcontent, ok := msg.Content.(map[string]interface{})\n\tif !ok {\n\t\tt.Fatalf(\"\\t%s Message content is not a JSON object\", failure)\n\t}\n\n\treturn content\n}\n\n// getString is a test helper that retrieves a value as a string from the content at the given key. If the key\n// does not exist in the content map or the value is not a string this will fail the test. The jsonObjectName\n// parameter is a string used to name the content for more helpful fail messages.\nfunc getString(t *testing.T, jsonObjectName string, content map[string]interface{}, key string) string {\n\tt.Helper()\n\n\traw, ok := content[key]\n\tif !ok {\n\t\tt.Fatalf(\"\\t%s %s[\\\"%s\\\"] field not present\", failure, jsonObjectName, key)\n\t}\n\n\tvalue, ok := raw.(string)\n\tif !ok {\n\t\tt.Fatalf(\"\\t%s %s[\\\"%s\\\"] is not a string\", failure, jsonObjectName, key)\n\t}\n\n\treturn value\n}\n\n// getJSONObject is a test helper that retrieves a value as a map[string]interface{} from the content at the given key.\n// If the key  does not exist in the content map or the value is not a map[string]interface{} this will fail the test.\n// The jsonObjectName parameter is a string used to name the content for more helpful fail messages.\nfunc getJSONObject(t *testing.T, jsonObjectName string, content map[string]interface{}, key string) map[string]interface{} {\n\tt.Helper()\n\n\traw, ok := content[key]\n\tif !ok {\n\t\tt.Fatalf(\"\\t%s %s[\\\"%s\\\"] field not present\", failure, jsonObjectName, key)\n\t}\n\n\tvalue, ok := raw.(map[string]interface{})\n\tif !ok {\n\t\tt.Fatalf(\"\\t%s %s[\\\"%s\\\"] is not a JSON object\", failure, jsonObjectName, key)\n\t}\n\n\treturn value\n}\n\n// testOutputStream is a test helper that collects \"stream\" messages upon executing the codeIn.\nfunc testOutputStream(t *testing.T, codeIn string) ([]string, []string) {\n\tt.Helper()\n\n\tclient, closeClient := newTestJupyterClient(t)\n\tdefer closeClient()\n\n\t_, pub := client.executeCode(t, codeIn)\n\n\tvar stdout, stderr []string\n\tfor _, pubMsg := range pub {\n\t\tif pubMsg.Header.MsgType == \"stream\" {\n\t\t\tcontent := getMsgContentAsJSONObject(t, pubMsg)\n\t\t\tstreamType := getString(t, \"content\", content, \"name\")\n\t\t\tstreamData := getString(t, \"content\", content, \"text\")\n\n\t\t\tswitch streamType {\n\t\t\tcase StreamStdout:\n\t\t\t\tstdout = append(stdout, streamData)\n\t\t\tcase StreamStderr:\n\t\t\t\tstderr = append(stderr, streamData)\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unknown stream type '%s'\", streamType)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stdout, stderr\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 0.4150390625,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"log\"\n)\n\nconst (\n\n\t// Version defines the gophernotes version.\n\tVersion string = \"1.0.0\"\n\n\t// ProtocolVersion defines the Jupyter protocol version.\n\tProtocolVersion string = \"5.0\"\n)\n\nfunc main() {\n\n\t// Parse the connection file.\n\tflag.Parse()\n\tif flag.NArg() < 1 {\n\t\tlog.Fatalln(\"Need a command line argument specifying the connection file.\")\n\t}\n\n\t// Run the kernel.\n\trunKernel(flag.Arg(0))\n}\n"
        },
        {
          "name": "messages.go",
          "type": "blob",
          "size": 8.9931640625,
          "content": "package main\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/go-zeromq/zmq4\"\n\t\"github.com/gofrs/uuid\"\n)\n\n// MsgHeader encodes header info for ZMQ messages.\ntype MsgHeader struct {\n\tMsgID           string `json:\"msg_id\"`\n\tUsername        string `json:\"username\"`\n\tSession         string `json:\"session\"`\n\tMsgType         string `json:\"msg_type\"`\n\tProtocolVersion string `json:\"version\"`\n\tTimestamp       string `json:\"date\"`\n}\n\n// ComposedMsg represents an entire message in a high-level structure.\ntype ComposedMsg struct {\n\tHeader       MsgHeader\n\tParentHeader MsgHeader\n\tMetadata     map[string]interface{}\n\tContent      interface{}\n}\n\n// msgReceipt represents a received message, its return identities, and\n// the sockets for communication.\ntype msgReceipt struct {\n\tMsg        ComposedMsg\n\tIdentities [][]byte\n\tSockets    SocketGroup\n}\n\n// MIMEMap holds data that can be presented in multiple formats. The keys are MIME types\n// and the values are the data formatted with respect to its MIME type.\n// All maps should contain at least a \"text/plain\" representation with a string value.\ntype MIMEMap = map[string]interface{}\n\n// Data is the exact structure returned to Jupyter.\n// It allows to fully specify how a value should be displayed.\ntype Data = struct {\n\tData      MIMEMap\n\tMetadata  MIMEMap\n\tTransient MIMEMap\n}\n\n// InvalidSignatureError is returned when the signature on a received message does not\n// validate.\ntype InvalidSignatureError struct{}\n\nfunc (e *InvalidSignatureError) Error() string {\n\treturn \"A message had an invalid signature\"\n}\n\n// WireMsgToComposedMsg translates a multipart ZMQ messages received from a socket into\n// a ComposedMsg struct and a slice of return identities. This includes verifying the\n// message signature.\nfunc WireMsgToComposedMsg(msgparts [][]byte, signkey []byte) (ComposedMsg, [][]byte, error) {\n\n\ti := 0\n\tfor string(msgparts[i]) != \"<IDS|MSG>\" {\n\t\ti++\n\t}\n\tidentities := msgparts[:i]\n\n\t// Validate signature.\n\tvar msg ComposedMsg\n\tif len(signkey) != 0 {\n\t\tmac := hmac.New(sha256.New, signkey)\n\t\tfor _, msgpart := range msgparts[i+2 : i+6] {\n\t\t\tmac.Write(msgpart)\n\t\t}\n\t\tsignature := make([]byte, hex.DecodedLen(len(msgparts[i+1])))\n\t\thex.Decode(signature, msgparts[i+1])\n\t\tif !hmac.Equal(mac.Sum(nil), signature) {\n\t\t\treturn msg, nil, &InvalidSignatureError{}\n\t\t}\n\t}\n\n\t// Unmarshal contents.\n\tjson.Unmarshal(msgparts[i+2], &msg.Header)\n\tjson.Unmarshal(msgparts[i+3], &msg.ParentHeader)\n\tjson.Unmarshal(msgparts[i+4], &msg.Metadata)\n\tjson.Unmarshal(msgparts[i+5], &msg.Content)\n\treturn msg, identities, nil\n}\n\n// ToWireMsg translates a ComposedMsg into a multipart ZMQ message ready to send, and\n// signs it. This does not add the return identities or the delimiter.\nfunc (msg ComposedMsg) ToWireMsg(signkey []byte) ([][]byte, error) {\n\n\tmsgparts := make([][]byte, 5)\n\n\theader, err := json.Marshal(msg.Header)\n\tif err != nil {\n\t\treturn msgparts, err\n\t}\n\tmsgparts[1] = header\n\n\tparentHeader, err := json.Marshal(msg.ParentHeader)\n\tif err != nil {\n\t\treturn msgparts, err\n\t}\n\tmsgparts[2] = parentHeader\n\n\tif msg.Metadata == nil {\n\t\tmsg.Metadata = make(map[string]interface{})\n\t}\n\n\tmetadata, err := json.Marshal(msg.Metadata)\n\tif err != nil {\n\t\treturn msgparts, err\n\t}\n\tmsgparts[3] = metadata\n\n\tcontent, err := json.Marshal(msg.Content)\n\tif err != nil {\n\t\treturn msgparts, err\n\t}\n\tmsgparts[4] = content\n\n\t// Sign the message.\n\tif len(signkey) != 0 {\n\t\tmac := hmac.New(sha256.New, signkey)\n\t\tfor _, msgpart := range msgparts[1:] {\n\t\t\tmac.Write(msgpart)\n\t\t}\n\t\tmsgparts[0] = make([]byte, hex.EncodedLen(mac.Size()))\n\t\thex.Encode(msgparts[0], mac.Sum(nil))\n\t}\n\n\treturn msgparts, nil\n}\n\n// SendResponse sends a message back to return identities of the received message.\nfunc (receipt *msgReceipt) SendResponse(socket zmq4.Socket, msg ComposedMsg) error {\n\n\tmsgParts, err := msg.ToWireMsg(receipt.Sockets.Key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar frames = make([][]byte, 0, len(receipt.Identities)+1+len(msgParts))\n\tframes = append(frames, receipt.Identities...)\n\tframes = append(frames, []byte(\"<IDS|MSG>\"))\n\tframes = append(frames, msgParts...)\n\n\terr = socket.SendMulti(zmq4.NewMsgFrom(frames...))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// NewMsg creates a new ComposedMsg to respond to a parent message.\n// This includes setting up its headers.\nfunc NewMsg(msgType string, parent ComposedMsg) (ComposedMsg, error) {\n\tvar msg ComposedMsg\n\n\tmsg.ParentHeader = parent.Header\n\tmsg.Header.Session = parent.Header.Session\n\tmsg.Header.Username = parent.Header.Username\n\tmsg.Header.MsgType = msgType\n\tmsg.Header.ProtocolVersion = ProtocolVersion\n\tmsg.Header.Timestamp = time.Now().UTC().Format(time.RFC3339)\n\n\tu, err := uuid.NewV4()\n\tif err != nil {\n\t\treturn msg, err\n\t}\n\tmsg.Header.MsgID = u.String()\n\n\treturn msg, nil\n}\n\n// Publish creates a new ComposedMsg and sends it back to the return identities over the\n// IOPub channel.\nfunc (receipt *msgReceipt) Publish(msgType string, content interface{}) error {\n\tmsg, err := NewMsg(msgType, receipt.Msg)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmsg.Content = content\n\treturn receipt.Sockets.IOPubSocket.RunWithSocket(func(iopub zmq4.Socket) error {\n\t\treturn receipt.SendResponse(iopub, msg)\n\t})\n}\n\n// Reply creates a new ComposedMsg and sends it back to the return identities over the\n// Shell channel.\nfunc (receipt *msgReceipt) Reply(msgType string, content interface{}) error {\n\tmsg, err := NewMsg(msgType, receipt.Msg)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmsg.Content = content\n\treturn receipt.Sockets.ShellSocket.RunWithSocket(func(shell zmq4.Socket) error {\n\t\treturn receipt.SendResponse(shell, msg)\n\t})\n}\n\n// PublishKernelStatus publishes a status message notifying front-ends of the state the kernel is in. Supports\n// states \"starting\", \"busy\", and \"idle\".\nfunc (receipt *msgReceipt) PublishKernelStatus(status string) error {\n\treturn receipt.Publish(\"status\",\n\t\tstruct {\n\t\t\tExecutionState string `json:\"execution_state\"`\n\t\t}{\n\t\t\tExecutionState: status,\n\t\t},\n\t)\n}\n\n// PublishExecutionInput publishes a status message notifying front-ends of what code is\n// currently being executed.\nfunc (receipt *msgReceipt) PublishExecutionInput(execCount int, code string) error {\n\treturn receipt.Publish(\"execute_input\",\n\t\tstruct {\n\t\t\tExecCount int    `json:\"execution_count\"`\n\t\t\tCode      string `json:\"code\"`\n\t\t}{\n\t\t\tExecCount: execCount,\n\t\t\tCode:      code,\n\t\t},\n\t)\n}\n\nfunc ensure(bundle MIMEMap) MIMEMap {\n\tif bundle == nil {\n\t\tbundle = make(MIMEMap)\n\t}\n\treturn bundle\n}\n\nfunc merge(a MIMEMap, b MIMEMap) MIMEMap {\n\tif len(b) == 0 {\n\t\treturn a\n\t}\n\tif a == nil {\n\t\ta = make(MIMEMap)\n\t}\n\tfor k, v := range b {\n\t\ta[k] = v\n\t}\n\treturn a\n}\n\n// PublishExecuteResult publishes the result of the `execCount` execution as a string.\nfunc (receipt *msgReceipt) PublishExecutionResult(execCount int, data Data) error {\n\treturn receipt.Publish(\"execute_result\", struct {\n\t\tExecCount int     `json:\"execution_count\"`\n\t\tData      MIMEMap `json:\"data\"`\n\t\tMetadata  MIMEMap `json:\"metadata\"`\n\t}{\n\t\tExecCount: execCount,\n\t\tData:      data.Data,\n\t\tMetadata:  ensure(data.Metadata),\n\t})\n}\n\n// PublishExecuteResult publishes a serialized error that was encountered during execution.\nfunc (receipt *msgReceipt) PublishExecutionError(err string, trace []string) error {\n\treturn receipt.Publish(\"error\",\n\t\tstruct {\n\t\t\tName  string   `json:\"ename\"`\n\t\t\tValue string   `json:\"evalue\"`\n\t\t\tTrace []string `json:\"traceback\"`\n\t\t}{\n\t\t\tName:  \"ERROR\",\n\t\t\tValue: err,\n\t\t\tTrace: trace,\n\t\t},\n\t)\n}\n\n// PublishDisplayData publishes a single image.\nfunc (receipt *msgReceipt) PublishDisplayData(data Data) error {\n\t// copy Data in a struct with appropriate json tags\n\treturn receipt.Publish(\"display_data\", struct {\n\t\tData      MIMEMap `json:\"data\"`\n\t\tMetadata  MIMEMap `json:\"metadata\"`\n\t\tTransient MIMEMap `json:\"transient\"`\n\t}{\n\t\tData:      data.Data,\n\t\tMetadata:  ensure(data.Metadata),\n\t\tTransient: ensure(data.Transient),\n\t})\n}\n\nconst (\n\t// StreamStdout defines the stream name for standard out on the front-end. It\n\t// is used in `PublishWriteStream` to specify the stream to write to.\n\tStreamStdout = \"stdout\"\n\n\t// StreamStderr defines the stream name for standard error on the front-end. It\n\t// is used in `PublishWriteStream` to specify the stream to write to.\n\tStreamStderr = \"stderr\"\n)\n\n// PublishWriteStream prints the data string to a stream on the front-end. This is\n// either `StreamStdout` or `StreamStderr`.\nfunc (receipt *msgReceipt) PublishWriteStream(stream string, data string) error {\n\treturn receipt.Publish(\"stream\",\n\t\tstruct {\n\t\t\tStream string `json:\"name\"`\n\t\t\tData   string `json:\"text\"`\n\t\t}{\n\t\t\tStream: stream,\n\t\t\tData:   data,\n\t\t},\n\t)\n}\n\n// JupyterStreamWriter is an `io.Writer` implementation that writes the data to the notebook\n// front-end.\ntype JupyterStreamWriter struct {\n\tstream  string\n\treceipt *msgReceipt\n}\n\n// Write implements `io.Writer.Write` by publishing the data via `PublishWriteStream`\nfunc (writer *JupyterStreamWriter) Write(p []byte) (int, error) {\n\tdata := string(p)\n\tn := len(p)\n\n\tif err := writer.receipt.PublishWriteStream(writer.stream, data); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}\n\ntype OutErr struct {\n\tout io.Writer\n\terr io.Writer\n}\n"
        },
        {
          "name": "paper",
          "type": "tree",
          "content": null
        },
        {
          "name": "x_package.go",
          "type": "blob",
          "size": 6.9482421875,
          "content": "package main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\tr \"reflect\"\n\n\t\"github.com/cosmos72/gomacro/imports\"\n)\n\n// prepare imports.Package for interpreted code\nvar display = imports.Package{\n\tBinds: map[string]r.Value{\n\t\t\"Any\":                r.ValueOf(Any),\n\t\t\"Auto\":               r.ValueOf(Auto),\n\t\t\"File\":               r.ValueOf(File),\n\t\t\"HTML\":               r.ValueOf(HTML),\n\t\t\"Image\":              r.ValueOf(Image),\n\t\t\"JPEG\":               r.ValueOf(JPEG),\n\t\t\"JSON\":               r.ValueOf(JSON),\n\t\t\"JavaScript\":         r.ValueOf(JavaScript),\n\t\t\"Latex\":              r.ValueOf(Latex),\n\t\t\"MakeData\":           r.ValueOf(MakeData),\n\t\t\"MakeData3\":          r.ValueOf(MakeData3),\n\t\t\"Markdown\":           r.ValueOf(Markdown),\n\t\t\"Math\":               r.ValueOf(Math),\n\t\t\"MIME\":               r.ValueOf(MIME),\n\t\t\"MIMETypeHTML\":       r.ValueOf(MIMETypeHTML),\n\t\t\"MIMETypeJavaScript\": r.ValueOf(MIMETypeJavaScript),\n\t\t\"MIMETypeJPEG\":       r.ValueOf(MIMETypeJPEG),\n\t\t\"MIMETypeJSON\":       r.ValueOf(MIMETypeJSON),\n\t\t\"MIMETypeLatex\":      r.ValueOf(MIMETypeLatex),\n\t\t\"MIMETypeMarkdown\":   r.ValueOf(MIMETypeMarkdown),\n\t\t\"MIMETypePDF\":        r.ValueOf(MIMETypePDF),\n\t\t\"MIMETypePNG\":        r.ValueOf(MIMETypePNG),\n\t\t\"MIMETypeSVG\":        r.ValueOf(MIMETypeSVG),\n\t\t\"PDF\":                r.ValueOf(PDF),\n\t\t\"PNG\":                r.ValueOf(PNG),\n\t\t\"SVG\":                r.ValueOf(SVG),\n\t},\n\tTypes: map[string]r.Type{\n\t\t\"Data\":           r.TypeOf((*Data)(nil)).Elem(),\n\t\t\"HTMLer\":         r.TypeOf((*HTMLer)(nil)).Elem(),\n\t\t\"JavaScripter\":   r.TypeOf((*JavaScripter)(nil)).Elem(),\n\t\t\"Image\":          r.TypeOf((*image.Image)(nil)).Elem(),\n\t\t\"JPEGer\":         r.TypeOf((*JPEGer)(nil)).Elem(),\n\t\t\"JSONer\":         r.TypeOf((*JSONer)(nil)).Elem(),\n\t\t\"Latexer\":        r.TypeOf((*Latexer)(nil)).Elem(),\n\t\t\"Markdowner\":     r.TypeOf((*Markdowner)(nil)).Elem(),\n\t\t\"MIMEMap\":        r.TypeOf((*MIMEMap)(nil)).Elem(),\n\t\t\"PNGer\":          r.TypeOf((*PNGer)(nil)).Elem(),\n\t\t\"PDFer\":          r.TypeOf((*PDFer)(nil)).Elem(),\n\t\t\"Renderer\":       r.TypeOf((*Renderer)(nil)).Elem(),\n\t\t\"SimpleRenderer\": r.TypeOf((*SimpleRenderer)(nil)).Elem(),\n\t\t\"SVGer\":          r.TypeOf((*SVGer)(nil)).Elem(),\n\t}, Proxies: map[string]r.Type{\n\t\t// these are needed to allow interpreted types\n\t\t// to implement the corresponding interfaces\n\t\t\"HTMLer\":         r.TypeOf((*proxy_HTMLer)(nil)).Elem(),\n\t\t\"Image\":          r.TypeOf((*proxy_image_Image)(nil)).Elem(),\n\t\t\"JPEGer\":         r.TypeOf((*proxy_JPEGer)(nil)).Elem(),\n\t\t\"JSONer\":         r.TypeOf((*proxy_JSONer)(nil)).Elem(),\n\t\t\"Latexer\":        r.TypeOf((*proxy_Latexer)(nil)).Elem(),\n\t\t\"Markdowner\":     r.TypeOf((*proxy_Markdowner)(nil)).Elem(),\n\t\t\"PNGer\":          r.TypeOf((*proxy_PNGer)(nil)).Elem(),\n\t\t\"PDFer\":          r.TypeOf((*proxy_PDFer)(nil)).Elem(),\n\t\t\"Renderer\":       r.TypeOf((*proxy_Renderer)(nil)).Elem(),\n\t\t\"SimpleRenderer\": r.TypeOf((*proxy_SimpleRenderer)(nil)).Elem(),\n\t\t\"SVGer\":          r.TypeOf((*proxy_SVGer)(nil)).Elem(),\n\t},\n}\n\n// --------------- proxy for display.HTMLer ---------------\ntype proxy_HTMLer struct {\n\tObject interface{}\n\tHTML_  func(interface{}) string\n}\n\nfunc (P *proxy_HTMLer) HTML() string {\n\treturn P.HTML_(P.Object)\n}\n\n// compile-time check that *proxy_HTMLer implements HTMLer\nvar _ HTMLer = (*proxy_HTMLer)(nil)\n\n// --------------- proxy for display.JPEGer ---------------\ntype proxy_JPEGer struct {\n\tObject interface{}\n\tJPEG_  func(interface{}) []byte\n}\n\nfunc (P *proxy_JPEGer) JPEG() []byte {\n\treturn P.JPEG_(P.Object)\n}\n\n// compile-time check that *proxy_JPEGer implements JPEGer\nvar _ JPEGer = (*proxy_JPEGer)(nil)\n\n// --------------- proxy for display.JSONer ---------------\ntype proxy_JSONer struct {\n\tObject interface{}\n\tJSON_  func(interface{}) map[string]interface{}\n}\n\nfunc (P *proxy_JSONer) JSON() map[string]interface{} {\n\treturn P.JSON_(P.Object)\n}\n\n// compile-time check that *proxy_JSONer implements JSONer\nvar _ JSONer = (*proxy_JSONer)(nil)\n\n// --------------- proxy for display.Latexer ---------------\ntype proxy_Latexer struct {\n\tObject interface{}\n\tLatex_ func(interface{}) string\n}\n\nfunc (P *proxy_Latexer) Latex() string {\n\treturn P.Latex_(P.Object)\n}\n\n// compile-time check that *proxy_Latexer implements Latexer\nvar _ Latexer = (*proxy_Latexer)(nil)\n\n// --------------- proxy for display.Markdowner ---------------\ntype proxy_Markdowner struct {\n\tObject    interface{}\n\tMarkdown_ func(interface{}) string\n}\n\nfunc (P *proxy_Markdowner) Markdown() string {\n\treturn P.Markdown_(P.Object)\n}\n\n// compile-time check that *proxy_Markdowner implements Markdowner\nvar _ Markdowner = (*proxy_Markdowner)(nil)\n\n// --------------- proxy for display.PNGer ---------------\ntype proxy_PNGer struct {\n\tObject interface{}\n\tPNG_   func(interface{}) []byte\n}\n\nfunc (P *proxy_PNGer) PNG() []byte {\n\treturn P.PNG_(P.Object)\n}\n\n// compile-time check that *proxy_PNGer implements PNGer\nvar _ PNGer = (*proxy_PNGer)(nil)\n\n// --------------- proxy for display.PDFer ---------------\ntype proxy_PDFer struct {\n\tObject interface{}\n\tPDF_   func(interface{}) []byte\n}\n\nfunc (P *proxy_PDFer) PDF() []byte {\n\treturn P.PDF_(P.Object)\n}\n\n// compile-time check that *proxy_PNGer implements PNGer\nvar _ PNGer = (*proxy_PNGer)(nil)\n\n// --------------- proxy for display.Renderer ---------------\ntype proxy_Renderer struct {\n\tObject  interface{}\n\tRender_ func(interface{}) Data\n}\n\nfunc (P *proxy_Renderer) Render() Data {\n\treturn P.Render_(P.Object)\n}\n\n// compile-time check that *proxy_Renderer implements Renderer\nvar _ Renderer = (*proxy_Renderer)(nil)\n\n// --------------- proxy for display.SimpleRenderer ---------------\ntype proxy_SimpleRenderer struct {\n\tObject        interface{}\n\tSimpleRender_ func(interface{}) MIMEMap\n}\n\nfunc (P *proxy_SimpleRenderer) SimpleRender() MIMEMap {\n\treturn P.SimpleRender_(P.Object)\n}\n\n// compile-time check that *proxy_SimpleRenderer implements SimpleRenderer\nvar _ SimpleRenderer = (*proxy_SimpleRenderer)(nil)\n\n// --------------- proxy for display.SVGer ---------------\ntype proxy_SVGer struct {\n\tObject interface{}\n\tSVG_   func(interface{}) string\n}\n\nfunc (P *proxy_SVGer) SVG() string {\n\treturn P.SVG_(P.Object)\n}\n\n// compile-time check that *proxy_SVGer implements SVGer\nvar _ SVGer = (*proxy_SVGer)(nil)\n\n// --------------- proxy for image.Image ---------------\ntype proxy_image_Image struct {\n\tObject      interface{}\n\tAt_         func(_proxy_obj_ interface{}, x int, y int) color.Color\n\tBounds_     func(interface{}) image.Rectangle\n\tColorModel_ func(interface{}) color.Model\n}\n\nfunc (P *proxy_image_Image) At(x int, y int) color.Color {\n\treturn P.At_(P.Object, x, y)\n}\nfunc (P *proxy_image_Image) Bounds() image.Rectangle {\n\treturn P.Bounds_(P.Object)\n}\nfunc (P *proxy_image_Image) ColorModel() color.Model {\n\treturn P.ColorModel_(P.Object)\n}\n\n// compile-time check that *proxy_image_Image implements image.Image\nvar _ image.Image = (*proxy_image_Image)(nil)\n\n// --------------------------------------------------------\n// allow importing \"display\" and \"github.com/gopherdata/gophernotes\" packages\nfunc init() {\n\timports.Packages[\"display\"] = display\n\timports.Packages[\"github.com/gopherdata/gophernotes\"] = display\n}\n"
        }
      ]
    }
  ]
}