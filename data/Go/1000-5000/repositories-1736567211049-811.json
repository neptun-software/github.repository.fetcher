{
  "metadata": {
    "timestamp": 1736567211049,
    "page": 811,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "doug-martin/goqu",
      "stars": 2438,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.025390625,
          "content": ".idea\nsrc\n*.iml\ncoverage.*"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 2.8505859375,
          "content": "linters-settings:\n  funlen:\n    lines: 140\n    statements: 50\n  gci:\n    local-prefixes: github.com/golangci/golangci-lint\n  goconst:\n    min-len: 2\n    min-occurrences: 2\n  gocritic:\n    enabled-tags:\n      - diagnostic\n      - experimental\n      - opinionated\n      - performance\n      - style\n    disabled-checks:\n      - dupImport # https://github.com/go-critic/go-critic/issues/845\n      - ifElseChain\n      - octalLiteral\n      - whyNoLint\n      - wrapperFunc\n      - sqlQuery # used by tests\n  gocyclo:\n    min-complexity: 20\n  goimports:\n    local-prefixes: github.com/golangci/golangci-lint\n  gomnd:\n    settings:\n      mnd:\n        # don't include the \"operation\" and \"assign\"\n        checks: argument,case,condition,return\n  govet:\n    check-shadowing: true\n    settings:\n      printf:\n        funcs:\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Infof\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Warnf\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Errorf\n          - (github.com/golangci/golangci-lint/pkg/logutils.Log).Fatalf\n  lll:\n    line-length: 140\n  maligned:\n    suggest-new: true\n  misspell:\n    locale: US\n  nolintlint:\n    allow-unused: false # report any unused nolint directives\n    require-explanation: false # don't require an explanation for nolint directives\n    require-specific: false # don't require nolint directives to be specific about which linter is being skipped\n  exhaustive:\n    default-signifies-exhaustive: true\n\nlinters:\n  # please, do not use `enable-all`: it's deprecated and will be removed soon.\n  # inverted configuration with `enable-all` and `disable` is not scalable during updates of golangci-lint\n  disable-all: true\n  enable:\n    - asciicheck\n    - bodyclose\n    - dogsled\n    - errcheck\n    - exportloopref\n    - exhaustive\n    - errcheck\n    - errorlint\n    - funlen\n    - forbidigo\n    - goconst\n    - gocritic\n    - gocyclo\n    - gofmt\n    - goimports\n    - gomnd\n    - goprintffuncname\n    - gosec\n    - gosimple\n    - govet\n    - ineffassign\n    - lll\n    - makezero\n    - misspell\n    - nakedret\n    - nilerr\n    - noctx\n    - nolintlint\n    - prealloc\n    - predeclared\n    - revive\n    - rowserrcheck\n    - staticcheck\n    - stylecheck\n    - testpackage\n    - typecheck\n    - unconvert\n    - unparam\n    - unused\n    - whitespace\n\n  # don't enable:\n  # - gochecknoglobals\n  # - gocognit\n  # - godot\n  # - godox\n  # - goerr113\n  # - interfacer\n  # - maligned\n  # - nestif\n  # - revive\n  # - wsl\n  # - wrapcheck\n\nissues:\n  # Excluding configuration per-path, per-linter, per-text and per-source\n  exclude-rules:\n    - path: _test\\.go\n      linters:\n        - gomnd\n\n    # https://github.com/go-critic/go-critic/issues/926\n    - linters:\n        - gocritic\n      text: \"unnecessaryDefer:\"\n\nrun:\n  skip-dirs:\n    - test/testdata_etc\n    - internal/cache\n    - internal/renameio\n    - internal/robustio"
        },
        {
          "name": ".run",
          "type": "tree",
          "content": null
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1416015625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at doug@dougamartin.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.2939453125,
          "content": "## Contributions\n\nI am always welcoming contributions of any type. Please open an issue or create a PR if you find an issue with any of the following.\n\n* An issue with Documentation\n* You found the documentation lacking in some way\n\nIf you have an issue with the package please include the following\n\n* The dialect you are using\n* A description of the problem\n* A short example of how to reproduce (if applicable)\n\nWithout those basics it can be difficult to reproduce your issue locally. You may be asked for more information but that is a good starting point.\n\n### New Features\n\nNew features and/or enhancements are great and I encourage you to either submit a PR or create an issue. In both cases include the following as the need/requirement may not be readily apparent.\n\n1. The use case\n2. A short example\n\nIf you are issuing a PR also also include the following\n\n1. Tests - otherwise the PR will not be merged\n2. Documentation - otherwise the PR will not be merged\n3. Examples - [If applicable] see example_test.go for examples\n\nIf you find an issue you want to work on please comment on it letting other people know you are looking at it and I will assign the issue to you.\n\nIf want to work on an issue but dont know where to start just leave a comment and I'll be more than happy to point you in the right direction.\n"
        },
        {
          "name": "HISTORY.md",
          "type": "blob",
          "size": 19.7744140625,
          "content": "# v9.19.0\n* [FEATURE] Add support for omitempty and omitnil struct tags [#309](https://github.com/doug-martin/goqu/pull/309) - [@randallmlough](https://github.com/randallmlough)\n\n# v9.18.0\n* [FEATURE] Add support for aliasing insert datasets to support upsert alias [#306](https://github.com/doug-martin/goqu/pull/306) - [@XIELongDragon](https://github.com/XIELongDragon)\n* [FEATURE] Add support for aliasing BooleanExpressions [#307](https://github.com/doug-martin/goqu/pull/307) - [@XIELongDragon](https://github.com/XIELongDragon)\n\n# v9.17.0\n* [FEATURE] Add support bitwise operations [#303](https://github.com/doug-martin/goqu/pull/303) - [@XIELongDragon](https://github.com/XIELongDragon)\n* [FEATURE] Add support for specifying tables to be locked in ForUpdate, ForNoKeyUpdate, ForKeyShare, ForShare [#299](https://github.com/doug-martin/goqu/pull/299) - [@jbub](https://github.com/jbub)\n\n# v9.16.0\n* [FEATURE] Allow ordering by case expression [#282](https://github.com/doug-martin/goqu/issues/282), [#292](https://github.com/doug-martin/goqu/pull/292)\n\n# v9.15.1\n* [FIX] Field indexes in the columnMap getting overridden [290](https://github.com/doug-martin/goqu/issues/290), [#291](https://github.com/doug-martin/goqu/pull/291)\n\n# v9.15.0\n* [FEATURE] Add SetDefaultPrepared which controls query value interpolation [#288](https://github.com/doug-martin/goqu/pull/288) - [@Deiz](https://github.com/Deiz)\n\n# v9.14.0\n* [FEATURE] GroupByAppend to the SelectDataset and SelectClauses [#276](https://github.com/doug-martin/goqu/pull/276), [#287](https://github.com/doug-martin/goqu/pull/287) - [@ashishkf](https://github.com/ashishkf)\n* [FEATURE] Allow untagged fields to be ignored [#285](https://github.com/doug-martin/goqu/pull/285) - [@Deiz](https://github.com/Deiz)\n* [FIX] Nil valuer [#277](https://github.com/doug-martin/goqu/pull/277) - [@benzolium](https://github.com/benzolium), [@Diggs](https://github.com/Diggs)\n* [FIX] Fix old import URL in doc comments [#286](https://github.com/doug-martin/goqu/pull/286) - [@maito1201](https://github.com/maito1201)\n\n# v9.13.0\n\n* [ADDED] ScanStructs, ScanVals to Scanner interface [#273](https://github.com/doug-martin/goqu/issues/273) - [@vlanse](https://github.com/vlanse)\n\n# v9.12.0\n\n* Update golangci-lint and updates for all associated linters\n* Update dependencies\n  * github.com/DATA-DOG/go-sqlmock  v1.3.3 -> v1.5.0\n  * github.com/denisenkom/go-mssqldb v0.0.0-20200206145737-bbfc9a55622e -> v0.10.0\n  * github.com/go-sql-driver/mysql v1.4.1 -> v1.6.0\n  * github.com/lib/pq v1.2.0 -> v1.10.1\n  * github.com/mattn/go-sqlite3 v1.11.0 -> v1.14.7\n  * github.com/stretchr/testify -> v1.4.0 -> v1.7.0\n  \n\n# v9.11.1\n\n* [FIXED] Avoid mutation of join slice for separate datasets when joins slice capacity is not yet reached [#261](https://github.com/doug-martin/goqu/pull/261) - [@fhaifler](https://github.com/fhaifler)\n\n# v9.11.0\n\n* [FIXED] Use valid 'IS' operator for sqlserver dialect [#240](https://github.com/doug-martin/goqu/pull/240), [#239](https://github.com/doug-martin/goqu/pull/229)  - [@vlanse](https://github.com/vlanse)\n* [ADDED] Implement Orderable interface for SQL Functions [#251](https://github.com/doug-martin/goqu/pull/251)  - [@GlebBeloded](https://github.com/GlebBeloded)\n* [ADDED] Support for table hint in multi-table MySQL DELETE queries [#252](https://github.com/doug-martin/goqu/pull/252) - [@vlanse](https://github.com/vlanse)\n\n# v9.10.0\n\n* [FIXED] SELECT inherits dialect from INSERT in INSERT FROM SELECT.  [#229](https://github.com/doug-martin/goqu/pull/229), [#223](https://github.com/doug-martin/goqu/issues/223) - [@vlanse](https://github.com/vlanse)\n* [FIXED] SQLServer dialect: support prepared statements with TOP.  [#230](https://github.com/doug-martin/goqu/pull/230), [#225](https://github.com/doug-martin/goqu/issues/225) - [@vlanse](https://github.com/vlanse)\n* [ADDED] IsPrepared to SQLExpression interface.  [#231](https://github.com/doug-martin/goqu/pull/231) - [@vlanse](https://github.com/vlanse)\n\n# v9.9.0\n\n* [FIXED] SQLite do not add FOR UPDATE in SELECT. [#218](https://github.com/doug-martin/goqu/pull/218) - [@vlanse](https://github.com/vlanse)\n* [ADDED] Support for INSERT ON CONFLICT in SQLite. [#218](https://github.com/doug-martin/goqu/pull/218) - [@vlanse](https://github.com/vlanse)\n\n# v9.8.0\n\n* [ADDED] Support for ANY and ALL operators. [#196](https://github.com/doug-martin/goqu/issues/196)\n* [ADDED] Support for CASE statements [#193](https://github.com/doug-martin/goqu/issues/193) \n* [ADDED] Support for getting column identifiers from AliasExpressions. [#203](https://github.com/doug-martin/goqu/issues/203)  \n\n# v9.7.1\n\n* Fix all formatting for golangci-lint\n* Move to golangci-lint github action\n\n# v9.7.0\n\n* [ADDED] Support for sqlserver dialect [#197](https://github.com/doug-martin/goqu/issues/197),[#205](https://github.com/doug-martin/goqu/issues/205) - [@vlanse](https://github.com/vlanse)\n\n# v9.6.0\n\n* [ADDED] Support for Lateral queries [#182](https://github.com/doug-martin/goqu/issues/182)\n\n# v9.5.1\n\n* [FIXED] WITH clause without a RETURNING clause will panic [#177](https://github.com/doug-martin/goqu/issues/177)\n* [FIXED] SQlite dialect escapes single quotes wrong, leads to SQL syntax error [#178](https://github.com/doug-martin/goqu/issues/178)\n* [FIXED] Fix ReturnsColumns() nil pointer panic [#181](https://github.com/doug-martin/goqu/issues/181) - [@yeaha](https://github.com/yeaha)\n* [FIXED] SelectDataset From with Error [#183](https://github.com/doug-martin/goqu/issues/183)\n* [FIXED] Unable to execute union with order by expression [#185](https://github.com/doug-martin/goqu/issues/185)\n\n# v9.5.0\n\n* [ADDED] Ability to use regexp like, ilike, notlike, and notilike without a regexp [#172](https://github.com/doug-martin/goqu/issues/172)\n\n# v9.4.0\n\n* [ADDED] Ability to scan into struct fields from multiple tables [#160](https://github.com/doug-martin/goqu/issues/160)\n\n# v9.3.0\n\n* [ADDED] Using Update, Insert, or Delete datasets in sub selects and CTEs [#164](https://github.com/doug-martin/goqu/issues/164)\n\n# v9.2.0\n\n* [ADDED] exec.Scanner: New exposed scanner supports iterative scanning [#157](https://github.com/doug-martin/goqu/pull/157) - [@akarl](https://github.com/akarl)\n\n# v9.1.0\n\n* [FIXED] ExampleDoUpdate does't work in postgres [#156](https://github.com/doug-martin/goqu/issues/156)\n* [FIXED] Issue with timezone being lost [#163](https://github.com/doug-martin/goqu/issues/163) \n\n# v9.0.1\n\n* [FIXED] Issue where `NULL`, `TRUE` and `FALSE` are interpolated when using an `IS` clause. [#165](https://github.com/doug-martin/goqu/issues/165)\n    \n# v9.0.0\n\n* Changed `NULL`, `TRUE`, `FALSE` to not be interpolated when creating prepared statements. [#132](https://github.com/doug-martin/goqu/pull/132), [#158](https://github.com/doug-martin/goqu/pull/158) - [@marshallmcmullen](https://github.com/marshallmcmullen)\n* Updated dependencies\n    * `github.com/lib/pq v1.1.1 -> v1.2.0`\n    * `github.com/mattn/go-sqlite3 v1.10.0 -> v1.11.0`\n    * `github.com/stretchr/testify v1.3.0 -> v1.4.0`\n\n## v8.6.0\n\n* [ADDED] `SetError()` and `Error()` to all datasets. [#152](https://github.com/doug-martin/goqu/pull/152) and [#150](https://github.com/doug-martin/goqu/pull/150) - [@marshallmcmullen](https://github.com/marshallmcmullen)\n\n## v8.5.0\n\n* [ADDED] Window Function support [#128](https://github.com/doug-martin/goqu/issues/128) - [@Xuyuanp](https://github.com/Xuyuanp)\n\n## v8.4.1\n\n* [FIXED] Returning func be able to handle nil [#140](https://github.com/doug-martin/goqu/issues/140)\n\n## v8.4.0\n\n* Created new `sqlgen` module to encapsulate sql generation\n    * Broke SQLDialect inti new SQL generators for each statement type.\n* Test refactor\n    * Moved to a test case pattern to allow for quickly adding new test cases.\n    \n## v8.3.2\n\n* [FIXED] Data race during query factory initialization [#133](https://github.com/doug-martin/goqu/issues/133) and [#136](https://github.com/doug-martin/goqu/issues/136) - [@o1egl](https://github.com/o1egl)    \n\n## v8.3.1\n\n* [FIXED] InsertDataset.WithDialect return old dataset [#126](https://github.com/doug-martin/goqu/issues/126) - [@chen56](https://github.com/chen56)\n* Test clean up and more testing pattern consistency\n    * Changed to use assertion methods off of suite\n    * Updated Equals assertions to have expected output first \n* Increase overall test coverage.\n\n## v8.3.0\n\n* [Added] Support for `DISTINCT ON` clauses [#119](https://github.com/doug-martin/goqu/issues/119)\n\n## v8.2.2\n\n* [FIX] Scanner errors on pointers to primitive values [#122](https://github.com/doug-martin/goqu/issues/122)\n\n## v8.2.1\n\n* [FIX] Return an error when an empty identifier is encountered [#115](https://github.com/doug-martin/goqu/issues/115)\n\n## v8.2.0\n\n* [FIX] Fix reflection errors related to nil pointers and unexported fields [#118](https://github.com/doug-martin/goqu/issues/118)\n    * Unexported fields are ignored when creating a columnMap\n    * Nil embedded pointers will no longer cause a panic\n    * Fields on nil embedded pointers will be ignored when creating update or insert statements.\n* [ADDED] You can now ingore embedded structs and their fields by using `db:\"-\"` tag on the embedded struct.\n\n## v8.1.0\n\n* [ADDED] Support column DEFAULT when inserting/updating via struct [#27](https://github.com/doug-martin/goqu/issues/27)\n\n## v8.0.1\n\n* [ADDED] Multi table update support for `mysql` and `postgres` [#60](https://github.com/doug-martin/goqu/issues/60)\n* [ADDED] `goqu.V` so values can be used on the LHS of expressions [#104](https://github.com/doug-martin/goqu/issues/104)\n\n## v8.0.0\n\nA major change the the API was made in `v8` to seperate concerns between the different SQL statement types. \n\n**Why the change?**\n\n1. There were feature requests that could not be cleanly implemented with everything in a single dataset. \n2. Too much functionality was encapsulated in a single datastructure.\n    * It was unclear what methods could be used for each SQL statement type.\n    * Changing a feature for one statement type had the possiblity of breaking another statement type.\n    * Test coverage was decent but was almost solely concerned about SELECT statements, breaking them up allowed for focused testing on each statement type.\n    * Most the SQL generation methods (`ToInsertSQL`, `ToUpdateSQL` etc.) took arguments which lead to an ugly API that was not uniform for each statement type, and proved to be inflexible.\n\n**What Changed**\n\nThere are now five dataset types, `SelectDataset`, `InsertDataset`, `UpdateDataset`, `DeleteDataset` and `TruncateDataset`\n\nEach dataset type has its own entry point.\n\n* `goqu.From`, `Database#From`, `DialectWrapper#From` - Create SELECT\n* `goqu.Insert`, `Database#Insert`, `DialectWrapper#Insert` - Create INSERT\n* `goqu.Update`, `Database#db.Update`, `DialectWrapper#Update` - Create UPDATE\n* `goqu.Delete`, `Database#Delete`, `DialectWrapper#Delete` - Create DELETE\n* `goqu.Truncate`, `Database#Truncate`, `DialectWrapper#Truncate` - Create TRUNCATE\n  \n`ToInsertSQL`, `ToUpdateSQL`, `ToDeleteSQL`, and `ToTruncateSQL` (and variations of them) methods have been removed from the `SelectDataset`. Instead use the `ToSQL` methods on each dataset type.\n\nEach dataset type will have an `Executor` and `ToSQL` method so a common interface can be created for each type.\n\n\n## v7.4.0\n\n* [FIXED] literalTime use t.UTC() , This behavior is different from the original sql.DB [#106](https://github.com/doug-martin/goqu/issues/106) - [chen56](https://github.com/chen56)\n* [ADDED] Add new method WithTx for Database [#108](https://github.com/doug-martin/goqu/issues/108) - [Xuyuanp](https://github.com/Xuyuanp)\n\n## v7.3.1\n\n* [ADDED] Exposed `goqu.NewTx` to allow creating a goqu tx directly from a `sql.Tx` instead of using `goqu.Database#Begin` [#95](https://github.com/doug-martin/goqu/issues/95)\n* [ADDED] `goqu.Database.BeginTx` [#98](https://github.com/doug-martin/goqu/issues/98)\n\n## v7.3.0\n\n* [ADDED] UPDATE and INSERT should use struct Field name if db tag is not specified [#57](https://github.com/doug-martin/goqu/issues/57)\n* [CHANGE] Changed goqu.Database to accept a SQLDatabase interface to allow using goqu.Database with other libraries such as `sqlx` [#95](https://github.com/doug-martin/goqu/issues/95)\n\n## v7.2.0\n\n* [FIXED] Sqlite3 does not accept SELECT * UNION (SELECT *) [#79](https://github.com/doug-martin/goqu/issues/79)\n* [FIXED] Where(Ex{}) causes panics [mysql] [#49](https://github.com/doug-martin/goqu/issues/49)\n* [ADDED] Support for OrderPrepend [#61](https://github.com/doug-martin/goqu/issues/61)\n* [DOCS] Added new section about loading a dialect and using it to build SQL [#44](https://github.com/doug-martin/goqu/issues/44)\n\n## v7.1.0\n\n* [FIXED] Embedded pointers with property names that duplicate parent struct properties. [#23](https://github.com/doug-martin/goqu/issues/23)\n* [FIXED] Can't scan values using []byte or []string [#90](https://github.com/doug-martin/goqu/issues/90)\n    * When a slice that is `*sql.RawBytes`, `*[]byte` or `sql.Scanner` no errors will be returned. \n\n## v7.0.1\n\n* Fix issue where structs with pointer fields where not set properly [#86](https://github.com/doug-martin/goqu/pull/86) and [#89](https://github.com/doug-martin/goqu/pull/89) - [@efureev](https://github.com/efureev)\n\n## v7.0.0\n\n**Linting**\n* Add linting checks and fixed errors \n    * Renamed all snake_case variables to be camelCase.     \n    * Fixed examples to always map to a defined method\n* Renamed `adapters` to `dialect` to more closely match their intended purpose.\n\n**API Changes**\n* Updated all sql generations methods to from `Sql` to `SQL`\n    * `ToSql` -> `ToSQL`\n    * `ToInsertSql` -> `ToInsertSQL`\n    * `ToUpdateSql` -> `ToUpdateSQL`\n    * `ToDeleteSql` -> `ToDeleteSQL`\n    * `ToTruncateSql` -> `ToTruncateSQL`\n* Abstracted out `dialect_options` from the adapter to make the dialect self contained.\n    * This also removed the dataset<->adapter co dependency making the dialect self contained.\n* Refactored the `goqu.I` method.\n    * Added new `goqu.S`, `goqu.T` and `goqu.C` methods to clarify why type of identifier you are using.\n    * `goqu.I` should only be used when you have a qualified identifier (e.g. `goqu.I(\"my_schema.my_table.my_col\")\n* Added new `goqu.Dialect` method to make using `goqu` as an SQL builder easier.\n\n**Internal Changes**\n* Pulled expressions into their own package\n    * Broke up expressions.go into multiple files to make working with and defining them easier.\n    * Moved the user facing methods into the main `goqu` to keep the same API as before.\n* Added more examples\n* Moved non-user facing structs and interfaces to internal modules to clean up API.\n* Increased test coverage.\n \n\n## v6.1.0\n\n* Handle nil *time.Time Literal [#73](https://github.com/doug-martin/goqu/pull/73) and [#52](https://github.com/doug-martin/goqu/pull/52) - [@RoarkeRandall](https://github.com/RoarkeRandall) and [@quetz](https://github.com/quetz)\n* Add ability to change column rename function [#66](https://github.com/doug-martin/goqu/pull/66) - [@blainehansen](https://github.com/blainehansen)\n\n## v6.0.0\n\n* Updated go support to `1.10`, `1.11` and `1.12`\n* Change testify dependency from c2fo/testify back to stretchr/testify.\n* Add support for \"FOR UPDATE\" and \"SKIP LOCKED\" [#62](https://github.com/doug-martin/goqu/pull/62) - [@btubbs](https://github.com/btubbs)\n* Changed to use go modules\n\n## v5.0.0\n\n* Drop go 1.6 support, supported versions are `1.8`, `1.9` and latest\n* Add context support [#64](https://github.com/doug-martin/goqu/pull/64) - [@cmoad](https://github.com/cmoad)\n\n## v4.2.0\n\n* Add support for ON CONFLICT when using a dataset [#55](https://github.com/doug-martin/goqu/pull/55) - [@bobrnor](https://github.com/bobrnor)\n\n## v4.1.0\n\n* Support for defining WITH clauses for Common Table Expressions (CTE) [#39](https://github.com/doug-martin/goqu/pull/39) - [@Oscil8](https://github.com/Oscil8)\n\n## v4.0\n\n* Prepared(true) issues when using IS NULL comparisson operation [#33](https://github.com/doug-martin/goqu/pull/33) - [@danielfbm](https://github.com/danielfbm)\n\n## v3.3\n\n* Add `upsert` support via `InsertIgnore` and `InsertConflict` methods - [#25](https://github.com/doug-martin/goqu/pull/28) - [@aheuermann](https://github.com/aheuermann)\n* Adding vendor dependencies and updating tests to run in docker containers [#29](https://github.com/doug-martin/goqu/pull/29) - [@aheuermann](https://github.com/aheuermann)\n\n## v3.2\n\n* Add range clauses ([NOT] BETWEEN) support - [#25](https://github.com/doug-martin/goqu/pull/25) - [@denisvm](https://github.com/denisvm)\n* Readmefix [#26](https://github.com/doug-martin/goqu/pull/26) - [@tiagopotencia](https://github.com/tiagopotencia)\n\n## v3.1.3\n\n* Bugfix for chained Where() [#20](https://github.com/doug-martin/goqu/pull/20) - [@Emreu](https://github.com/Emreu)\n\n\n## v3.1.2\n\n* Fixing ScanStruct issue with embedded pointers in crud_exec [#20](https://github.com/doug-martin/goqu/pull/20) - [@ruzz311](https://github.com/ruzz311)\n\n## v3.1.1\n\n* Fixing race condition with struct_map_cache in crud_exec [#18](https://github.com/doug-martin/goqu/pull/18) - [@andymoon](https://github.com/andymoon), [@aheuermann](https://github.com/aheuermann)\n\n## v3.1.0\n\n* Version 3.1 [#14](https://github.com/doug-martin/goqu/pull/14) - [@andymoon](https://github.com/andymoon)\n    * Fix an issue with a nil pointer access on the inserts and updates.\n    * Allowing ScanStructs to take a struct with an embedded pointer to a struct.\n    * Change to check if struct is Anonymous when recursing through an embedded struct.\n    * Updated to use the latest version of github.com/DATA-DOG/go-sqlmock.\n\n## v3.0.1\n\n* Add literal bytes and update to c2fo testify [#15](https://github.com/doug-martin/goqu/pull/15) - [@TechnotronicOz](https://github.com/TechnotronicOz)\n\n## v3.0.0\n\n* Added support for embedded structs when inserting or updating. [#13](https://github.com/doug-martin/goqu/pull/13) - [@andymoon](https://github.com/andymoon)\n\n## v2.0.3\n\n* Fixed issue with transient columns and the auto select of columns.\n\n## v2.0.2\n\n* Changed references to \"github.com/doug-martin/goqu\" to \"gopkg.in/doug-martin/goqu.v2\"\n\n## v2.0.1\n\n* Fixed issue when `ScanStruct(s)` was used with `SelectDistinct` and caused a panic.\n\n## v2.0.0\n\n* When scanning a struct or slice of structs, the struct(s) will be parsed for the column names to select. [#9](https://github.com/doug-martin/goqu/pull/9) - [@technotronicoz](https://github.com/TechnotronicOz)\n\n## v1.0.0\n\n* You can now passed an IdentiferExpression to `As` [#8](https://github.com/doug-martin/goqu/pull/8) - [@croachrose](https://github.com/croachrose)\n* Added info about installation through [gopkg.in](http://labix.org/gopkg.in)\n\n## v0.3.1\n\n* Fixed issue setting Logger when starting a new transaction.\n\n## v0.3.0\n\n* Changed sql generation methods to use a common naming convention. `To(Sql|Insert|Update|Delete)`\n   * Also changed to have common return values `string, []interface{}, error)`\n* Added `Dataset.Prepared` which allows a user to specify whether or not SQL should be interpolated. [#7](https://github.com/doug-martin/goqu/issues/7)\n* Updated Docs\n    * More examples\n* Increased test coverage.\n\n## v0.2.0\n\n* Changed `CrudExec` to not wrap driver errors in a GoquError [#2](https://github.com/doug-martin/goqu/issues/2)\n* Added ability to use a dataset in an `Ex` map or `Eq` expression without having to use `In` [#3](https://github.com/doug-martin/goqu/issues/3)\n   * `db.From(\"test\").Where(goqu.Ex{\"a\": db.From(\"test\").Select(\"b\")})`\n* Updated readme with links to [`DefaultAdapter`](https://godoc.org/github.com/doug-martin/goqu#DefaultAdapter)\n\n## v0.1.1\n\n* Added SQLite3 adapter [#1](https://github.com/doug-martin/goqu/pull/1) - [@mattn](https://github.com/mattn)\n\n## v0.1.0\n\n* Added:\n    * [`Ex`](https://godoc.org/github.com/doug-martin/goqu#Ex)\n    * [`ExOr`](https://godoc.org/github.com/doug-martin/goqu#ExOr)\n    * [`Op`](https://godoc.org/github.com/doug-martin/goqu#Op)\n* More tests and examples\n* Added CONTRIBUTING.md\n* Added LICENSE information\n* Removed godoc introduction in favor of just maintaining the README.\n\n## v0.0.2\n\n* Fixed issue with goqu.New not returning a pointer to a Database\n\n## v0.0.1\n\n* Initial release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2017 Doug Martin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2470703125,
          "content": "#phony dependency task that does nothing\n#\"make executable\" does not run if there is a ./executable directory, unless the task has a dependency\nphony:\n\nlint:\n\tdocker run --rm -v ${CURDIR}:/app -w /app golangci/golangci-lint:v1.53.3 golangci-lint run -v\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.96875,
          "content": "```\n  __ _  ___   __ _ _   _\n / _` |/ _ \\ / _` | | | |\n| (_| | (_) | (_| | |_| |\n \\__, |\\___/ \\__, |\\__,_|\n |___/          |_|\n```\n[![GitHub tag](https://img.shields.io/github/tag/doug-martin/goqu.svg?style=flat)](https://github.com/doug-martin/goqu/releases)\n[![Test](https://github.com/doug-martin/goqu/workflows/Test/badge.svg?branch=master&event=push)](https://github.com/doug-martin/goqu/actions?query=workflow%3ATest+and+branch%3Amaster+)\n[![Go Reference](https://pkg.go.dev/badge/github.com/doug-martin/goqu/v9.svg)](https://pkg.go.dev/github.com/doug-martin/goqu/v9)\n[![codecov](https://codecov.io/gh/doug-martin/goqu/branch/master/graph/badge.svg)](https://codecov.io/gh/doug-martin/goqu)\n[![Go Report Card](https://goreportcard.com/badge/github.com/doug-martin/goqu/v9)](https://goreportcard.com/report/github.com/doug-martin/goqu/v9)\n\n`goqu` is an expressive SQL builder and executor\n    \nIf you are upgrading from an older version please read the [Migrating Between Versions](./docs/version_migration.md) docs.\n\n\n## Installation\n\nIf using go modules.\n\n```sh\ngo get -u github.com/doug-martin/goqu/v9\n```\n\nIf you are not using go modules...\n\n**NOTE** You should still be able to use this package if you are using go version `>v1.10` but, you will need to drop the version from the package. `import \"github.com/doug-martin/goqu/v9` -> `import \"github.com/doug-martin/goqu\"`\n\n```sh\ngo get -u github.com/doug-martin/goqu\n```\n\n### [Migrating Between Versions](./docs/version_migration.md)\n\n## Features\n\n`goqu` comes with many features but here are a few of the more notable ones\n\n* Query Builder\n* Parameter interpolation (e.g `SELECT * FROM \"items\" WHERE \"id\" = ?` -> `SELECT * FROM \"items\" WHERE \"id\" = 1`)\n* Built from the ground up with multiple dialects in mind\n* Insert, Multi Insert, Update, and Delete support\n* Scanning of rows to struct[s] or primitive value[s]\n\nWhile goqu may support the scanning of rows into structs it is not intended to be used as an ORM if you are looking for common ORM features like associations,\nor hooks I would recommend looking at some of the great ORM libraries such as:\n\n* [gorm](https://github.com/jinzhu/gorm)\n* [hood](https://github.com/eaigner/hood)\n\n## Why?\n\nWe tried a few other sql builders but each was a thin wrapper around sql fragments that we found error prone. `goqu` was built with the following goals in mind:\n\n* Make the generation of SQL easy and enjoyable\n* Create an expressive DSL that would find common errors with SQL at compile time.\n* Provide a DSL that accounts for the common SQL expressions, NOT every nuance for each database.\n* Provide developers the ability to:\n  * Use SQL when desired\n  * Easily scan results into primitive values and structs\n  * Use the native sql.Db methods when desired\n\n## Docs\n\n* [Dialect](./docs/dialect.md) - Introduction to different dialects (`mysql`, `postgres`, `sqlite3`, `sqlserver` etc) \n* [Expressions](./docs/expressions.md) - Introduction to `goqu` expressions and common examples.\n* [Select Dataset](./docs/selecting.md) - Docs and examples about creating and executing SELECT sql statements.\n* [Insert Dataset](./docs/inserting.md) - Docs and examples about creating and executing INSERT sql statements.\n* [Update Dataset](./docs/updating.md) - Docs and examples about creating and executing UPDATE sql statements.\n* [Delete Dataset](./docs/deleting.md) - Docs and examples about creating and executing DELETE sql statements.\n* [Prepared Statements](./docs/interpolation.md) - Docs about interpolation and prepared statements in `goqu`.\n* [Database](./docs/database.md) - Docs and examples of using a Database to execute queries in `goqu`\n* [Working with time.Time](./docs/time.md) - Docs on how to use alternate time locations.\n\n## Quick Examples\n\n### Select\n\nSee the [select dataset](./docs/selecting.md) docs for more in depth examples\n\n```go\nsql, _, _ := goqu.From(\"test\").ToSQL()\nfmt.Println(sql)\n```\n\nOutput:\n\n```\nSELECT * FROM \"test\"\n```\n\n```go\nsql, _, _ := goqu.From(\"test\").Where(goqu.Ex{\n\t\"d\": []string{\"a\", \"b\", \"c\"},\n}).ToSQL()\nfmt.Println(sql)\n```\n\nOutput:\n\n```\nSELECT * FROM \"test\" WHERE (\"d\" IN ('a', 'b', 'c'))\n```\n\n### Insert\n\nSee the [insert dataset](./docs/inserting.md) docs for more in depth examples\n\n```go\nds := goqu.Insert(\"user\").\n\tCols(\"first_name\", \"last_name\").\n\tVals(\n\t\tgoqu.Vals{\"Greg\", \"Farley\"},\n\t\tgoqu.Vals{\"Jimmy\", \"Stewart\"},\n\t\tgoqu.Vals{\"Jeff\", \"Jeffers\"},\n\t)\ninsertSQL, args, _ := ds.ToSQL()\nfmt.Println(insertSQL, args)\n```\n\nOutput: \n```sql\nINSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n```\n\n```go\nds := goqu.Insert(\"user\").Rows(\n\tgoqu.Record{\"first_name\": \"Greg\", \"last_name\": \"Farley\"},\n\tgoqu.Record{\"first_name\": \"Jimmy\", \"last_name\": \"Stewart\"},\n\tgoqu.Record{\"first_name\": \"Jeff\", \"last_name\": \"Jeffers\"},\n)\ninsertSQL, args, _ := ds.ToSQL()\nfmt.Println(insertSQL, args)\n```\n\nOutput:\n```\nINSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n```\n\n\n```go\ntype User struct {\n\tFirstName string `db:\"first_name\"`\n\tLastName  string `db:\"last_name\"`\n}\nds := goqu.Insert(\"user\").Rows(\n\tUser{FirstName: \"Greg\", LastName: \"Farley\"},\n\tUser{FirstName: \"Jimmy\", LastName: \"Stewart\"},\n\tUser{FirstName: \"Jeff\", LastName: \"Jeffers\"},\n)\ninsertSQL, args, _ := ds.ToSQL()\nfmt.Println(insertSQL, args)\n```\n\nOutput:\n```\nINSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n```\n\n```go\nds := goqu.Insert(\"user\").Prepared(true).\n\tFromQuery(goqu.From(\"other_table\"))\ninsertSQL, args, _ := ds.ToSQL()\nfmt.Println(insertSQL, args)\n```\n\nOutput:\n```\nINSERT INTO \"user\" SELECT * FROM \"other_table\" []\n```\n\n```go\nds := goqu.Insert(\"user\").Prepared(true).\n\tCols(\"first_name\", \"last_name\").\n\tFromQuery(goqu.From(\"other_table\").Select(\"fn\", \"ln\"))\ninsertSQL, args, _ := ds.ToSQL()\nfmt.Println(insertSQL, args)\n```\n\nOutput:\n```\nINSERT INTO \"user\" (\"first_name\", \"last_name\") SELECT \"fn\", \"ln\" FROM \"other_table\" []\n```\n\n### Update\n\nSee the [update dataset](./docs/updating.md) docs for more in depth examples\n\n```go\nsql, args, _ := goqu.Update(\"items\").Set(\n\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n).ToSQL()\nfmt.Println(sql, args)\n```\n\nOutput:\n```\nUPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n```\n\n```go\ntype item struct {\n\tAddress string `db:\"address\"`\n\tName    string `db:\"name\" goqu:\"skipupdate\"`\n}\nsql, args, _ := goqu.Update(\"items\").Set(\n\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n).ToSQL()\nfmt.Println(sql, args)\n```\n\nOutput:\n```\nUPDATE \"items\" SET \"address\"='111 Test Addr' []\n```\n\n```go\nsql, _, _ := goqu.Update(\"test\").\n\tSet(goqu.Record{\"foo\": \"bar\"}).\n\tWhere(goqu.Ex{\n\t\t\"a\": goqu.Op{\"gt\": 10}\n\t}).ToSQL()\nfmt.Println(sql)\n```\n\nOutput:\n```\nUPDATE \"test\" SET \"foo\"='bar' WHERE (\"a\" > 10)\n```\n\n### Delete\n\nSee the [delete dataset](./docs/deleting.md) docs for more in depth examples\n\n```go\nds := goqu.Delete(\"items\")\n\nsql, args, _ := ds.ToSQL()\nfmt.Println(sql, args)\n```\n\n```go\nsql, _, _ := goqu.Delete(\"test\").Where(goqu.Ex{\n\t\t\"c\": nil\n\t}).ToSQL()\nfmt.Println(sql)\n```\n\nOutput:\n```\nDELETE FROM \"test\" WHERE (\"c\" IS NULL)\n```\n\n<a name=\"contributions\"></a>\n## Contributions\n\nI am always welcoming contributions of any type. Please open an issue or create a PR if you find an issue with any of the following.\n\n* An issue with Documentation\n* You found the documentation lacking in some way\n\nIf you have an issue with the package please include the following\n\n* The dialect you are using\n* A description of the problem\n* A short example of how to reproduce (if applicable)\n\nWithout those basics it can be difficult to reproduce your issue locally. You may be asked for more information but that is a good starting point.\n\n### New Features\n\nNew features and/or enhancements are great and I encourage you to either submit a PR or create an issue. In both cases include the following as the need/requirement may not be readily apparent.\n\n1. The use case\n2. A short example\n\nIf you are issuing a PR also include the following\n\n1. Tests - otherwise the PR will not be merged\n2. Documentation - otherwise the PR will not be merged\n3. Examples - [If applicable] see example_test.go for examples\n\nIf you find an issue you want to work on please comment on it letting other people know you are looking at it and I will assign the issue to you.\n\nIf want to work on an issue but dont know where to start just leave a comment and I'll be more than happy to point you in the right direction.\n\n### Running tests\nThe test suite requires a postgres, mysql and sqlserver databases. You can override the connection strings with the [`MYSQL_URI`, `PG_URI`, `SQLSERVER_URI` environment variables](https://github.com/doug-martin/goqu/blob/2fe3349/docker-compose.yml#L26)*\n\n```sh\ngo test -v -race ./...\n```\n\nYou can also run the tests in a container using [docker-compose](https://docs.docker.com/compose/).\n\n```sh\nMYSQL_VERSION=8 POSTGRES_VERSION=13.4 SQLSERVER_VERSION=2017-CU8-ubuntu GO_VERSION=latest docker-compose run goqu\n```\n\n## License\n\n`goqu` is released under the [MIT License](http://www.opensource.org/licenses/MIT).\n\n\n\n\n\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.025390625,
          "content": "theme: jekyll-theme-cayman"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.0859375,
          "content": "ignore:\n  - \"**/mocks/**\"         # glob accepted\n  - \"mocks/**\"         # glob accepted"
        },
        {
          "name": "database.go",
          "type": "blob",
          "size": 20.484375,
          "content": "package goqu\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"sync\"\n\n\t\"github.com/doug-martin/goqu/v9/exec\"\n)\n\ntype (\n\tLogger interface {\n\t\tPrintf(format string, v ...interface{})\n\t}\n\t// Interface for sql.DB, an interface is used so you can use with other\n\t// libraries such as sqlx instead of the native sql.DB\n\tSQLDatabase interface {\n\t\tBegin() (*sql.Tx, error)\n\t\tBeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)\n\t\tExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\n\t\tPrepareContext(ctx context.Context, query string) (*sql.Stmt, error)\n\t\tQueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)\n\t\tQueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row\n\t}\n\t// This struct is the wrapper for a Db. The struct delegates most calls to either an Exec instance or to the Db\n\t// passed into the constructor.\n\tDatabase struct {\n\t\tlogger  Logger\n\t\tdialect string\n\t\t//nolint:stylecheck // keep for backwards compatibility\n\t\tDb     SQLDatabase\n\t\tqf     exec.QueryFactory\n\t\tqfOnce sync.Once\n\t}\n)\n\n// This is the common entry point into goqu.\n//\n// dialect: This is the adapter dialect, you should see your database adapter for the string to use. Built in adapters\n// can be found at https://github.com/doug-martin/goqu/tree/master/adapters\n//\n// db: A sql.Db to use for querying the database\n//\n//\timport (\n//\t    \"database/sql\"\n//\t    \"fmt\"\n//\t    \"github.com/doug-martin/goqu/v9\"\n//\t    _ \"github.com/doug-martin/goqu/v9/dialect/postgres\"\n//\t    _ \"github.com/lib/pq\"\n//\t)\n//\n//\tfunc main() {\n//\t    sqlDb, err := sql.Open(\"postgres\", \"user=postgres dbname=goqupostgres sslmode=disable \")\n//\t    if err != nil {\n//\t        panic(err.Error())\n//\t    }\n//\t    db := goqu.New(\"postgres\", sqlDb)\n//\t}\n//\n// The most commonly used Database method is From, which creates a new Dataset that uses the correct adapter and\n// supports queries.\n//\n//\tvar ids []uint32\n//\tif err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).Pluck(\"id\", &ids); err != nil {\n//\t    panic(err.Error())\n//\t}\n//\tfmt.Printf(\"%+v\", ids)\nfunc newDatabase(dialect string, db SQLDatabase) *Database {\n\treturn &Database{\n\t\tlogger:  nil,\n\t\tdialect: dialect,\n\t\tDb:      db,\n\t\tqf:      nil,\n\t\tqfOnce:  sync.Once{},\n\t}\n}\n\n// returns this databases dialect\nfunc (d *Database) Dialect() string {\n\treturn d.dialect\n}\n\n// Starts a new Transaction.\nfunc (d *Database) Begin() (*TxDatabase, error) {\n\tsqlTx, err := d.Db.Begin()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttx := NewTx(d.dialect, sqlTx)\n\ttx.Logger(d.logger)\n\treturn tx, nil\n}\n\n// Starts a new Transaction. See sql.DB#BeginTx for option description\nfunc (d *Database) BeginTx(ctx context.Context, opts *sql.TxOptions) (*TxDatabase, error) {\n\tsqlTx, err := d.Db.BeginTx(ctx, opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttx := NewTx(d.dialect, sqlTx)\n\ttx.Logger(d.logger)\n\treturn tx, nil\n}\n\n// WithTx starts a new transaction and executes it in Wrap method\nfunc (d *Database) WithTx(fn func(*TxDatabase) error) error {\n\ttx, err := d.Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn tx.Wrap(func() error { return fn(tx) })\n}\n\n// Creates a new Dataset that uses the correct adapter and supports queries.\n//\n//\tvar ids []uint32\n//\tif err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).Pluck(\"id\", &ids); err != nil {\n//\t    panic(err.Error())\n//\t}\n//\tfmt.Printf(\"%+v\", ids)\n//\n// from...: Sources for you dataset, could be table names (strings), a goqu.Literal or another goqu.Dataset\nfunc (d *Database) From(from ...interface{}) *SelectDataset {\n\treturn newDataset(d.dialect, d.queryFactory()).From(from...)\n}\n\nfunc (d *Database) Select(cols ...interface{}) *SelectDataset {\n\treturn newDataset(d.dialect, d.queryFactory()).Select(cols...)\n}\n\nfunc (d *Database) Update(table interface{}) *UpdateDataset {\n\treturn newUpdateDataset(d.dialect, d.queryFactory()).Table(table)\n}\n\nfunc (d *Database) Insert(table interface{}) *InsertDataset {\n\treturn newInsertDataset(d.dialect, d.queryFactory()).Into(table)\n}\n\nfunc (d *Database) Delete(table interface{}) *DeleteDataset {\n\treturn newDeleteDataset(d.dialect, d.queryFactory()).From(table)\n}\n\nfunc (d *Database) Truncate(table ...interface{}) *TruncateDataset {\n\treturn newTruncateDataset(d.dialect, d.queryFactory()).Table(table...)\n}\n\n// Sets the logger for to use when logging queries\nfunc (d *Database) Logger(logger Logger) {\n\td.logger = logger\n}\n\n// Logs a given operation with the specified sql and arguments\nfunc (d *Database) Trace(op, sqlString string, args ...interface{}) {\n\tif d.logger != nil {\n\t\tif sqlString != \"\" {\n\t\t\tif len(args) != 0 {\n\t\t\t\td.logger.Printf(\"[goqu] %s [query:=`%s` args:=%+v]\", op, sqlString, args)\n\t\t\t} else {\n\t\t\t\td.logger.Printf(\"[goqu] %s [query:=`%s`]\", op, sqlString)\n\t\t\t}\n\t\t} else {\n\t\t\td.logger.Printf(\"[goqu] %s\", op)\n\t\t}\n\t}\n}\n\n// Uses the db to Execute the query with arguments and return the sql.Result\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) Exec(query string, args ...interface{}) (sql.Result, error) {\n\treturn d.ExecContext(context.Background(), query, args...)\n}\n\n// Uses the db to Execute the query with arguments and return the sql.Result\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {\n\td.Trace(\"EXEC\", query, args...)\n\treturn d.Db.ExecContext(ctx, query, args...)\n}\n\n// Can be used to prepare a query.\n//\n// You can use this in tandem with a dataset by doing the following.\n//\n//\tsql, args, err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).ToSQL(true)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tstmt, err := db.Prepare(sql)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tdefer stmt.Close()\n//\trows, err := stmt.Query(args)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tdefer rows.Close()\n//\tfor rows.Next(){\n//\t          //scan your rows\n//\t}\n//\tif rows.Err() != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\n// query: The SQL statement to prepare.\nfunc (d *Database) Prepare(query string) (*sql.Stmt, error) {\n\treturn d.PrepareContext(context.Background(), query)\n}\n\n// Can be used to prepare a query.\n//\n// You can use this in tandem with a dataset by doing the following.\n//\n//\tsql, args, err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).ToSQL(true)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tstmt, err := db.Prepare(sql)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tdefer stmt.Close()\n//\trows, err := stmt.QueryContext(ctx, args)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tdefer rows.Close()\n//\tfor rows.Next(){\n//\t          //scan your rows\n//\t}\n//\tif rows.Err() != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\n// query: The SQL statement to prepare.\nfunc (d *Database) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {\n\td.Trace(\"PREPARE\", query)\n\treturn d.Db.PrepareContext(ctx, query)\n}\n\n// Used to query for multiple rows.\n//\n// You can use this in tandem with a dataset by doing the following.\n//\n//\tsql, err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).ToSQL()\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\trows, err := stmt.Query(args)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tdefer rows.Close()\n//\tfor rows.Next(){\n//\t          //scan your rows\n//\t}\n//\tif rows.Err() != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) Query(query string, args ...interface{}) (*sql.Rows, error) {\n\treturn d.QueryContext(context.Background(), query, args...)\n}\n\n// Used to query for multiple rows.\n//\n// You can use this in tandem with a dataset by doing the following.\n//\n//\tsql, err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).ToSQL()\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\trows, err := stmt.QueryContext(ctx, args)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\tdefer rows.Close()\n//\tfor rows.Next(){\n//\t          //scan your rows\n//\t}\n//\tif rows.Err() != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {\n\td.Trace(\"QUERY\", query, args...)\n\treturn d.Db.QueryContext(ctx, query, args...)\n}\n\n// Used to query for a single row.\n//\n// You can use this in tandem with a dataset by doing the following.\n//\n//\tsql, err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).Limit(1).ToSQL()\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\trows, err := stmt.QueryRow(args)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\t//scan your row\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) QueryRow(query string, args ...interface{}) *sql.Row {\n\treturn d.QueryRowContext(context.Background(), query, args...)\n}\n\n// Used to query for a single row.\n//\n// You can use this in tandem with a dataset by doing the following.\n//\n//\tsql, err := db.From(\"items\").Where(goqu.I(\"id\").Gt(10)).Limit(1).ToSQL()\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\trows, err := stmt.QueryRowContext(ctx, args)\n//\tif err != nil{\n//\t    panic(err.Error()) //you could gracefully handle the error also\n//\t}\n//\t//scan your row\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\td.Trace(\"QUERY ROW\", query, args...)\n\treturn d.Db.QueryRowContext(ctx, query, args...)\n}\n\nfunc (d *Database) queryFactory() exec.QueryFactory {\n\td.qfOnce.Do(func() {\n\t\td.qf = exec.NewQueryFactory(d)\n\t})\n\treturn d.qf\n}\n\n// Queries the database using the supplied query, and args and uses CrudExec.ScanStructs to scan the results into a\n// slice of structs\n//\n// i: A pointer to a slice of structs\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanStructs(i interface{}, query string, args ...interface{}) error {\n\treturn d.ScanStructsContext(context.Background(), i, query, args...)\n}\n\n// Queries the database using the supplied context, query, and args and uses CrudExec.ScanStructsContext to scan the\n// results into a slice of structs\n//\n// i: A pointer to a slice of structs\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanStructsContext(ctx context.Context, i interface{}, query string, args ...interface{}) error {\n\treturn d.queryFactory().FromSQL(query, args...).ScanStructsContext(ctx, i)\n}\n\n// Queries the database using the supplied query, and args and uses CrudExec.ScanStruct to scan the results into a\n// struct\n//\n// i: A pointer to a struct\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanStruct(i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn d.ScanStructContext(context.Background(), i, query, args...)\n}\n\n// Queries the database using the supplied context, query, and args and uses CrudExec.ScanStructContext to scan the\n// results into a struct\n//\n// i: A pointer to a struct\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanStructContext(ctx context.Context, i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn d.queryFactory().FromSQL(query, args...).ScanStructContext(ctx, i)\n}\n\n// Queries the database using the supplied query, and args and uses CrudExec.ScanVals to scan the results into a slice\n// of primitive values\n//\n// i: A pointer to a slice of primitive values\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanVals(i interface{}, query string, args ...interface{}) error {\n\treturn d.ScanValsContext(context.Background(), i, query, args...)\n}\n\n// Queries the database using the supplied context, query, and args and uses CrudExec.ScanValsContext to scan the\n// results into a slice of primitive values\n//\n// i: A pointer to a slice of primitive values\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanValsContext(ctx context.Context, i interface{}, query string, args ...interface{}) error {\n\treturn d.queryFactory().FromSQL(query, args...).ScanValsContext(ctx, i)\n}\n\n// Queries the database using the supplied query, and args and uses CrudExec.ScanVal to scan the results into a\n// primitive value\n//\n// i: A pointer to a primitive value\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanVal(i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn d.ScanValContext(context.Background(), i, query, args...)\n}\n\n// Queries the database using the supplied context, query, and args and uses CrudExec.ScanValContext to scan the\n// results into a primitive value\n//\n// i: A pointer to a primitive value\n//\n// query: The SQL to execute\n//\n// args...: for any placeholder parameters in the query\nfunc (d *Database) ScanValContext(ctx context.Context, i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn d.queryFactory().FromSQL(query, args...).ScanValContext(ctx, i)\n}\n\n// A wrapper around a sql.Tx and works the same way as Database\ntype (\n\t// Interface for sql.Tx, an interface is used so you can use with other\n\t// libraries such as sqlx instead of the native sql.DB\n\tSQLTx interface {\n\t\tExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\n\t\tPrepareContext(ctx context.Context, query string) (*sql.Stmt, error)\n\t\tQueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)\n\t\tQueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row\n\t\tCommit() error\n\t\tRollback() error\n\t}\n\tTxDatabase struct {\n\t\tlogger  Logger\n\t\tdialect string\n\t\tTx      SQLTx\n\t\tqf      exec.QueryFactory\n\t\tqfOnce  sync.Once\n\t}\n)\n\n// Creates a new TxDatabase\nfunc NewTx(dialect string, tx SQLTx) *TxDatabase {\n\treturn &TxDatabase{dialect: dialect, Tx: tx}\n}\n\n// returns this databases dialect\nfunc (td *TxDatabase) Dialect() string {\n\treturn td.dialect\n}\n\n// Creates a new Dataset for querying a Database.\nfunc (td *TxDatabase) From(cols ...interface{}) *SelectDataset {\n\treturn newDataset(td.dialect, td.queryFactory()).From(cols...)\n}\n\nfunc (td *TxDatabase) Select(cols ...interface{}) *SelectDataset {\n\treturn newDataset(td.dialect, td.queryFactory()).Select(cols...)\n}\n\nfunc (td *TxDatabase) Update(table interface{}) *UpdateDataset {\n\treturn newUpdateDataset(td.dialect, td.queryFactory()).Table(table)\n}\n\nfunc (td *TxDatabase) Insert(table interface{}) *InsertDataset {\n\treturn newInsertDataset(td.dialect, td.queryFactory()).Into(table)\n}\n\nfunc (td *TxDatabase) Delete(table interface{}) *DeleteDataset {\n\treturn newDeleteDataset(td.dialect, td.queryFactory()).From(table)\n}\n\nfunc (td *TxDatabase) Truncate(table ...interface{}) *TruncateDataset {\n\treturn newTruncateDataset(td.dialect, td.queryFactory()).Table(table...)\n}\n\n// Sets the logger\nfunc (td *TxDatabase) Logger(logger Logger) {\n\ttd.logger = logger\n}\n\nfunc (td *TxDatabase) Trace(op, sqlString string, args ...interface{}) {\n\tif td.logger != nil {\n\t\tif sqlString != \"\" {\n\t\t\tif len(args) != 0 {\n\t\t\t\ttd.logger.Printf(\"[goqu - transaction] %s [query:=`%s` args:=%+v] \", op, sqlString, args)\n\t\t\t} else {\n\t\t\t\ttd.logger.Printf(\"[goqu - transaction] %s [query:=`%s`] \", op, sqlString)\n\t\t\t}\n\t\t} else {\n\t\t\ttd.logger.Printf(\"[goqu - transaction] %s\", op)\n\t\t}\n\t}\n}\n\n// See Database#Exec\nfunc (td *TxDatabase) Exec(query string, args ...interface{}) (sql.Result, error) {\n\treturn td.ExecContext(context.Background(), query, args...)\n}\n\n// See Database#ExecContext\nfunc (td *TxDatabase) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {\n\ttd.Trace(\"EXEC\", query, args...)\n\treturn td.Tx.ExecContext(ctx, query, args...)\n}\n\n// See Database#Prepare\nfunc (td *TxDatabase) Prepare(query string) (*sql.Stmt, error) {\n\treturn td.PrepareContext(context.Background(), query)\n}\n\n// See Database#PrepareContext\nfunc (td *TxDatabase) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {\n\ttd.Trace(\"PREPARE\", query)\n\treturn td.Tx.PrepareContext(ctx, query)\n}\n\n// See Database#Query\nfunc (td *TxDatabase) Query(query string, args ...interface{}) (*sql.Rows, error) {\n\treturn td.QueryContext(context.Background(), query, args...)\n}\n\n// See Database#QueryContext\nfunc (td *TxDatabase) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {\n\ttd.Trace(\"QUERY\", query, args...)\n\treturn td.Tx.QueryContext(ctx, query, args...)\n}\n\n// See Database#QueryRow\nfunc (td *TxDatabase) QueryRow(query string, args ...interface{}) *sql.Row {\n\treturn td.QueryRowContext(context.Background(), query, args...)\n}\n\n// See Database#QueryRowContext\nfunc (td *TxDatabase) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\ttd.Trace(\"QUERY ROW\", query, args...)\n\treturn td.Tx.QueryRowContext(ctx, query, args...)\n}\n\nfunc (td *TxDatabase) queryFactory() exec.QueryFactory {\n\ttd.qfOnce.Do(func() {\n\t\ttd.qf = exec.NewQueryFactory(td)\n\t})\n\treturn td.qf\n}\n\n// See Database#ScanStructs\nfunc (td *TxDatabase) ScanStructs(i interface{}, query string, args ...interface{}) error {\n\treturn td.ScanStructsContext(context.Background(), i, query, args...)\n}\n\n// See Database#ScanStructsContext\nfunc (td *TxDatabase) ScanStructsContext(ctx context.Context, i interface{}, query string, args ...interface{}) error {\n\treturn td.queryFactory().FromSQL(query, args...).ScanStructsContext(ctx, i)\n}\n\n// See Database#ScanStruct\nfunc (td *TxDatabase) ScanStruct(i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn td.ScanStructContext(context.Background(), i, query, args...)\n}\n\n// See Database#ScanStructContext\nfunc (td *TxDatabase) ScanStructContext(ctx context.Context, i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn td.queryFactory().FromSQL(query, args...).ScanStructContext(ctx, i)\n}\n\n// See Database#ScanVals\nfunc (td *TxDatabase) ScanVals(i interface{}, query string, args ...interface{}) error {\n\treturn td.ScanValsContext(context.Background(), i, query, args...)\n}\n\n// See Database#ScanValsContext\nfunc (td *TxDatabase) ScanValsContext(ctx context.Context, i interface{}, query string, args ...interface{}) error {\n\treturn td.queryFactory().FromSQL(query, args...).ScanValsContext(ctx, i)\n}\n\n// See Database#ScanVal\nfunc (td *TxDatabase) ScanVal(i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn td.ScanValContext(context.Background(), i, query, args...)\n}\n\n// See Database#ScanValContext\nfunc (td *TxDatabase) ScanValContext(ctx context.Context, i interface{}, query string, args ...interface{}) (bool, error) {\n\treturn td.queryFactory().FromSQL(query, args...).ScanValContext(ctx, i)\n}\n\n// COMMIT the transaction\nfunc (td *TxDatabase) Commit() error {\n\ttd.Trace(\"COMMIT\", \"\")\n\treturn td.Tx.Commit()\n}\n\n// ROLLBACK the transaction\nfunc (td *TxDatabase) Rollback() error {\n\ttd.Trace(\"ROLLBACK\", \"\")\n\treturn td.Tx.Rollback()\n}\n\n// A helper method that will automatically COMMIT or ROLLBACK once the supplied function is done executing\n//\n//\ttx, err := db.Begin()\n//\tif err != nil{\n//\t     panic(err.Error()) // you could gracefully handle the error also\n//\t}\n//\tif err := tx.Wrap(func() error{\n//\t    if _, err := tx.From(\"test\").Insert(Record{\"a\":1, \"b\": \"b\"}).Exec(){\n//\t        // this error will be the return error from the Wrap call\n//\t        return err\n//\t    }\n//\t    return nil\n//\t}); err != nil{\n//\t     panic(err.Error()) // you could gracefully handle the error also\n//\t}\nfunc (td *TxDatabase) Wrap(fn func() error) (err error) {\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\t_ = td.Rollback()\n\t\t\tpanic(p)\n\t\t}\n\t\tif err != nil {\n\t\t\tif rollbackErr := td.Rollback(); rollbackErr != nil {\n\t\t\t\terr = rollbackErr\n\t\t\t}\n\t\t} else {\n\t\t\tif commitErr := td.Commit(); commitErr != nil {\n\t\t\t\terr = commitErr\n\t\t\t}\n\t\t}\n\t}()\n\treturn fn()\n}\n"
        },
        {
          "name": "database_example_test.go",
          "type": "blob",
          "size": 3.728515625,
          "content": "package goqu_test\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n)\n\nfunc ExampleDatabase_Begin() {\n\tdb := getDB()\n\n\ttx, err := db.Begin()\n\tif err != nil {\n\t\tfmt.Println(\"Error starting transaction\", err.Error())\n\t}\n\n\t// use tx.From to get a dataset that will execute within this transaction\n\tupdate := tx.Update(\"goqu_user\").\n\t\tSet(goqu.Record{\"last_name\": \"Ucon\"}).\n\t\tWhere(goqu.Ex{\"last_name\": \"Yukon\"}).\n\t\tReturning(\"id\").\n\t\tExecutor()\n\n\tvar ids []int64\n\tif err := update.ScanVals(&ids); err != nil {\n\t\tif rErr := tx.Rollback(); rErr != nil {\n\t\t\tfmt.Println(\"An error occurred while issuing ROLLBACK\\n\\t\", rErr.Error())\n\t\t} else {\n\t\t\tfmt.Println(\"An error occurred while updating users ROLLBACK transaction\\n\\t\", err.Error())\n\t\t}\n\t\treturn\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tfmt.Println(\"An error occurred while issuing COMMIT\\n\\t\", err.Error())\n\t} else {\n\t\tfmt.Printf(\"Updated users in transaction [ids:=%+v]\", ids)\n\t}\n\t// Output:\n\t// Updated users in transaction [ids:=[1 2 3]]\n}\n\nfunc ExampleDatabase_BeginTx() {\n\tdb := getDB()\n\n\tctx := context.Background()\n\ttx, err := db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelReadCommitted})\n\tif err != nil {\n\t\tfmt.Println(\"Error starting transaction\", err.Error())\n\t}\n\n\t// use tx.From to get a dataset that will execute within this transaction\n\tupdate := tx.Update(\"goqu_user\").\n\t\tSet(goqu.Record{\"last_name\": \"Ucon\"}).\n\t\tWhere(goqu.Ex{\"last_name\": \"Yukon\"}).\n\t\tReturning(\"id\").\n\t\tExecutor()\n\n\tvar ids []int64\n\tif err := update.ScanVals(&ids); err != nil {\n\t\tif rErr := tx.Rollback(); rErr != nil {\n\t\t\tfmt.Println(\"An error occurred while issuing ROLLBACK\\n\\t\", rErr.Error())\n\t\t} else {\n\t\t\tfmt.Println(\"An error occurred while updating users ROLLBACK transaction\\n\\t\", err.Error())\n\t\t}\n\t\treturn\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tfmt.Println(\"An error occurred while issuing COMMIT\\n\\t\", err.Error())\n\t} else {\n\t\tfmt.Printf(\"Updated users in transaction [ids:=%+v]\", ids)\n\t}\n\t// Output:\n\t// Updated users in transaction [ids:=[1 2 3]]\n}\n\nfunc ExampleDatabase_WithTx() {\n\tdb := getDB()\n\tvar ids []int64\n\tif err := db.WithTx(func(tx *goqu.TxDatabase) error {\n\t\t// use tx.From to get a dataset that will execute within this transaction\n\t\tupdate := tx.Update(\"goqu_user\").\n\t\t\tWhere(goqu.Ex{\"last_name\": \"Yukon\"}).\n\t\t\tReturning(\"id\").\n\t\t\tSet(goqu.Record{\"last_name\": \"Ucon\"}).\n\t\t\tExecutor()\n\n\t\treturn update.ScanVals(&ids)\n\t}); err != nil {\n\t\tfmt.Println(\"An error occurred in transaction\\n\\t\", err.Error())\n\t} else {\n\t\tfmt.Printf(\"Updated users in transaction [ids:=%+v]\", ids)\n\t}\n\t// Output:\n\t// Updated users in transaction [ids:=[1 2 3]]\n}\n\nfunc ExampleDatabase_Dialect() {\n\tdb := getDB()\n\n\tfmt.Println(db.Dialect())\n\n\t// Output:\n\t// postgres\n}\n\nfunc ExampleDatabase_Exec() {\n\tdb := getDB()\n\n\t_, err := db.Exec(`DROP TABLE \"user_role\"; DROP TABLE \"goqu_user\"`)\n\tif err != nil {\n\t\tfmt.Println(\"Error occurred while dropping tables\", err.Error())\n\t}\n\tfmt.Println(\"Dropped tables user_role and goqu_user\")\n\t// Output:\n\t// Dropped tables user_role and goqu_user\n}\n\nfunc ExampleDatabase_ExecContext() {\n\tdb := getDB()\n\td := time.Now().Add(50 * time.Millisecond)\n\tctx, cancel := context.WithDeadline(context.Background(), d)\n\tdefer cancel()\n\t_, err := db.ExecContext(ctx, `DROP TABLE \"user_role\"; DROP TABLE \"goqu_user\"`)\n\tif err != nil {\n\t\tfmt.Println(\"Error occurred while dropping tables\", err.Error())\n\t}\n\tfmt.Println(\"Dropped tables user_role and goqu_user\")\n\t// Output:\n\t// Dropped tables user_role and goqu_user\n}\n\nfunc ExampleDatabase_From() {\n\tdb := getDB()\n\tvar names []string\n\n\tif err := db.From(\"goqu_user\").Select(\"first_name\").ScanVals(&names); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Println(\"Fetched Users names:\", names)\n\t}\n\t// Output:\n\t// Fetched Users names: [Bob Sally Vinita John]\n}\n"
        },
        {
          "name": "database_test.go",
          "type": "blob",
          "size": 22.5478515625,
          "content": "package goqu_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype testActionItem struct {\n\tAddress string `db:\"address\"`\n\tName    string `db:\"name\"`\n}\n\ntype dbTestMockLogger struct {\n\tMessages []string\n}\n\nfunc (dtml *dbTestMockLogger) Printf(format string, v ...interface{}) {\n\tdtml.Messages = append(dtml.Messages, fmt.Sprintf(format, v...))\n}\n\nfunc (dtml *dbTestMockLogger) Reset() {\n\tdtml.Messages = dtml.Messages[0:0]\n}\n\ntype databaseSuite struct {\n\tsuite.Suite\n}\n\nfunc (ds *databaseSuite) TestLogger() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectExec(`SELECT \\* FROM \"items\" WHERE \"id\" = ?`).\n\t\tWithArgs(1).\n\t\tWillReturnResult(sqlmock.NewResult(0, 0))\n\n\tdb := goqu.New(\"db-mock\", mDB)\n\tlogger := new(dbTestMockLogger)\n\tdb.Logger(logger)\n\tvar items []testActionItem\n\tds.NoError(db.ScanStructs(&items, `SELECT * FROM \"items\"`))\n\t_, err = db.Exec(`SELECT * FROM \"items\" WHERE \"id\" = ?`, 1)\n\tds.NoError(err)\n\tdb.Trace(\"TEST\", \"\")\n\tds.Equal([]string{\n\t\t\"[goqu] QUERY [query:=`SELECT * FROM \\\"items\\\"`]\",\n\t\t\"[goqu] EXEC [query:=`SELECT * FROM \\\"items\\\" WHERE \\\"id\\\" = ?` args:=[1]]\",\n\t\t\"[goqu] TEST\",\n\t}, logger.Messages)\n}\n\nfunc (ds *databaseSuite) TestScanStructs() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tmock.ExpectQuery(`SELECT \"test\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tdb := goqu.New(\"db-mock\", mDB)\n\tvar items []testActionItem\n\tds.NoError(db.ScanStructs(&items, `SELECT * FROM \"items\"`))\n\tds.Len(items, 2)\n\tds.Equal(\"111 Test Addr\", items[0].Address)\n\tds.Equal(\"Test1\", items[0].Name)\n\n\tds.Equal(\"211 Test Addr\", items[1].Address)\n\tds.Equal(\"Test2\", items[1].Name)\n\n\titems = items[0:0]\n\tds.EqualError(db.ScanStructs(items, `SELECT * FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\tds.EqualError(db.ScanStructs(&testActionItem{}, `SELECT * FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\tds.EqualError(db.ScanStructs(&items, `SELECT \"test\" FROM \"items\"`),\n\t\t`goqu: unable to find corresponding field to column \"test\" returned by query`)\n}\n\nfunc (ds *databaseSuite) TestScanStruct() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).FromCSVString(\"111 Test Addr,Test1\"))\n\n\tmock.ExpectQuery(`SELECT \"test\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar item testActionItem\n\tfound, err := db.ScanStruct(&item, `SELECT * FROM \"items\" LIMIT 1`)\n\tds.NoError(err)\n\tds.True(found)\n\tds.Equal(\"111 Test Addr\", item.Address)\n\tds.Equal(\"Test1\", item.Name)\n\n\t_, err = db.ScanStruct(item, `SELECT * FROM \"items\" LIMIT 1`)\n\tds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = db.ScanStruct([]testActionItem{}, `SELECT * FROM \"items\" LIMIT 1`)\n\tds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = db.ScanStruct(&item, `SELECT \"test\" FROM \"items\" LIMIT 1`)\n\tds.EqualError(err, `goqu: unable to find corresponding field to column \"test\" returned by query`)\n}\n\nfunc (ds *databaseSuite) TestScanVals() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar ids []uint32\n\tds.NoError(db.ScanVals(&ids, `SELECT \"id\" FROM \"items\"`))\n\tds.Len(ids, 5)\n\n\tds.EqualError(db.ScanVals([]uint32{}, `SELECT \"id\" FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n\tds.EqualError(db.ScanVals(testActionItem{}, `SELECT \"id\" FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n}\n\nfunc (ds *databaseSuite) TestScanVal() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"10\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar id int64\n\tfound, err := db.ScanVal(&id, `SELECT \"id\" FROM \"items\"`)\n\tds.NoError(err)\n\tds.Equal(int64(10), id)\n\tds.True(found)\n\n\tfound, err = db.ScanVal([]int64{}, `SELECT \"id\" FROM \"items\"`)\n\tds.False(found)\n\tds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n\tfound, err = db.ScanVal(10, `SELECT \"id\" FROM \"items\"`)\n\tds.False(found)\n\tds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n}\n\nfunc (ds *databaseSuite) TestExec() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectExec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE \\(\"name\" IS NULL\\)`).\n\t\tWithArgs().\n\t\tWillReturnResult(sqlmock.NewResult(0, 0))\n\n\tmock.ExpectExec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE \\(\"name\" IS NULL\\)`).\n\t\tWithArgs().\n\t\tWillReturnError(errors.New(\"mock error\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\t_, err = db.Exec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE (\"name\" IS NULL)`)\n\tds.NoError(err)\n\t_, err = db.Exec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE (\"name\" IS NULL)`)\n\tds.EqualError(err, \"goqu: mock error\")\n}\n\nfunc (ds *databaseSuite) TestQuery() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnError(errors.New(\"mock error\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\t_, err = db.Query(`SELECT * FROM \"items\"`) //nolint:rowserrcheck // not checking row scan\n\tds.NoError(err, \"goqu - mock error\")\n\n\t_, err = db.Query(`SELECT * FROM \"items\"`) //nolint:rowserrcheck // not checking row scan\n\tds.EqualError(err, \"goqu: mock error\")\n}\n\nfunc (ds *databaseSuite) TestQueryRow() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnError(errors.New(\"mock error\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\trows := db.QueryRow(`SELECT * FROM \"items\"`)\n\tvar address string\n\tvar name string\n\tds.NoError(rows.Scan(&address, &name))\n\n\trows = db.QueryRow(`SELECT * FROM \"items\"`)\n\tds.EqualError(rows.Scan(&address, &name), \"goqu: mock error\")\n}\n\nfunc (ds *databaseSuite) TestPrepare() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectPrepare(\"SELECT \\\\* FROM test WHERE id = \\\\?\")\n\tdb := goqu.New(\"mock\", mDB)\n\tstmt, err := db.Prepare(\"SELECT * FROM test WHERE id = ?\")\n\tds.NoError(err)\n\tds.NotNil(stmt)\n}\n\nfunc (ds *databaseSuite) TestBegin() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectBegin().WillReturnError(errors.New(\"transaction error\"))\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\tds.NoError(err)\n\tds.Equal(\"mock\", tx.Dialect())\n\n\t_, err = db.Begin()\n\tds.EqualError(err, \"goqu: transaction error\")\n}\n\nfunc (ds *databaseSuite) TestBeginTx() {\n\tctx := context.Background()\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectBegin().WillReturnError(errors.New(\"transaction error\"))\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.BeginTx(ctx, nil)\n\tds.NoError(err)\n\tds.Equal(\"mock\", tx.Dialect())\n\n\t_, err = db.BeginTx(ctx, nil)\n\tds.EqualError(err, \"goqu: transaction error\")\n}\n\nfunc (ds *databaseSuite) TestWithTx() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\n\tdb := goqu.New(\"mock\", mDB)\n\n\tcases := []struct {\n\t\texpectf func(sqlmock.Sqlmock)\n\t\tf       func(*goqu.TxDatabase) error\n\t\twantErr bool\n\t\terrStr  string\n\t}{\n\t\t{\n\t\t\texpectf: func(mock sqlmock.Sqlmock) {\n\t\t\t\tmock.ExpectBegin()\n\t\t\t\tmock.ExpectCommit()\n\t\t\t},\n\t\t\tf:       func(_ *goqu.TxDatabase) error { return nil },\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\texpectf: func(mock sqlmock.Sqlmock) {\n\t\t\t\tmock.ExpectBegin().WillReturnError(errors.New(\"transaction begin error\"))\n\t\t\t},\n\t\t\tf:       func(_ *goqu.TxDatabase) error { return nil },\n\t\t\twantErr: true,\n\t\t\terrStr:  \"goqu: transaction begin error\",\n\t\t},\n\t\t{\n\t\t\texpectf: func(mock sqlmock.Sqlmock) {\n\t\t\t\tmock.ExpectBegin()\n\t\t\t\tmock.ExpectRollback()\n\t\t\t},\n\t\t\tf:       func(_ *goqu.TxDatabase) error { return errors.New(\"transaction error\") },\n\t\t\twantErr: true,\n\t\t\terrStr:  \"goqu: transaction error\",\n\t\t},\n\t\t{\n\t\t\texpectf: func(mock sqlmock.Sqlmock) {\n\t\t\t\tmock.ExpectBegin()\n\t\t\t\tmock.ExpectRollback().WillReturnError(errors.New(\"transaction rollback error\"))\n\t\t\t},\n\t\t\tf:       func(_ *goqu.TxDatabase) error { return errors.New(\"something wrong\") },\n\t\t\twantErr: true,\n\t\t\terrStr:  \"goqu: transaction rollback error\",\n\t\t},\n\t\t{\n\t\t\texpectf: func(mock sqlmock.Sqlmock) {\n\t\t\t\tmock.ExpectBegin()\n\t\t\t\tmock.ExpectCommit().WillReturnError(errors.New(\"commit error\"))\n\t\t\t},\n\t\t\tf:       func(_ *goqu.TxDatabase) error { return nil },\n\t\t\twantErr: true,\n\t\t\terrStr:  \"goqu: commit error\",\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tc.expectf(mock)\n\t\terr := db.WithTx(c.f)\n\t\tif c.wantErr {\n\t\t\tds.EqualError(err, c.errStr)\n\t\t} else {\n\t\t\tds.NoError(err)\n\t\t}\n\t}\n}\n\nfunc (ds *databaseSuite) TestRollbackOnPanic() {\n\tmDB, mock, err := sqlmock.New()\n\n\tdefer func() {\n\t\tp := recover()\n\t\tif p == nil {\n\t\t\tds.Fail(\"there should be a panic\")\n\t\t}\n\t\tds.Require().Equal(\"a problem has happened\", p.(string))\n\t\tds.Require().NoError(mock.ExpectationsWereMet())\n\t}()\n\n\tds.NoError(err)\n\n\tmock.ExpectBegin()\n\tmock.ExpectRollback()\n\n\tdb := goqu.New(\"mock\", mDB)\n\t_ = db.WithTx(func(_ *goqu.TxDatabase) error {\n\t\tpanic(\"a problem has happened\")\n\t})\n}\n\nfunc (ds *databaseSuite) TestDataRace() {\n\tmDB, mock, err := sqlmock.New()\n\tds.NoError(err)\n\tdb := goqu.New(\"mock\", mDB)\n\n\tconst concurrency = 10\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tmock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\t\tWithArgs().\n\t\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\t}\n\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tsql := db.From(\"items\").Limit(1)\n\t\t\tvar item testActionItem\n\t\t\tfound, err := sql.ScanStruct(&item)\n\t\t\tds.NoError(err)\n\t\t\tds.True(found)\n\t\t\tds.Equal(item.Address, \"111 Test Addr\")\n\t\t\tds.Equal(item.Name, \"Test1\")\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n\nfunc TestDatabaseSuite(t *testing.T) {\n\tsuite.Run(t, new(databaseSuite))\n}\n\ntype txdatabaseSuite struct {\n\tsuite.Suite\n}\n\nfunc (tds *txdatabaseSuite) TestLogger() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectExec(`SELECT \\* FROM \"items\" WHERE \"id\" = ?`).\n\t\tWithArgs(1).\n\t\tWillReturnResult(sqlmock.NewResult(0, 0))\n\tmock.ExpectCommit()\n\n\ttx, err := goqu.New(\"db-mock\", mDB).Begin()\n\ttds.NoError(err)\n\tlogger := new(dbTestMockLogger)\n\ttx.Logger(logger)\n\tvar items []testActionItem\n\ttds.NoError(tx.ScanStructs(&items, `SELECT * FROM \"items\"`))\n\t_, err = tx.Exec(`SELECT * FROM \"items\" WHERE \"id\" = ?`, 1)\n\ttds.NoError(err)\n\ttds.NoError(tx.Commit())\n\ttds.Equal([]string{\n\t\t\"[goqu - transaction] QUERY [query:=`SELECT * FROM \\\"items\\\"`] \",\n\t\t\"[goqu - transaction] EXEC [query:=`SELECT * FROM \\\"items\\\" WHERE \\\"id\\\" = ?` args:=[1]] \",\n\t\t\"[goqu - transaction] COMMIT\",\n\t}, logger.Messages)\n}\n\nfunc (tds *txdatabaseSuite) TestLogger_FromDb() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectExec(`SELECT \\* FROM \"items\" WHERE \"id\" = ?`).\n\t\tWithArgs(1).\n\t\tWillReturnResult(sqlmock.NewResult(0, 0))\n\tmock.ExpectCommit()\n\n\tdb := goqu.New(\"db-mock\", mDB)\n\tlogger := new(dbTestMockLogger)\n\tdb.Logger(logger)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\n\tvar items []testActionItem\n\ttds.NoError(tx.ScanStructs(&items, `SELECT * FROM \"items\"`))\n\t_, err = tx.Exec(`SELECT * FROM \"items\" WHERE \"id\" = ?`, 1)\n\ttds.NoError(err)\n\ttds.NoError(tx.Commit())\n\ttds.Equal([]string{\n\t\t\"[goqu - transaction] QUERY [query:=`SELECT * FROM \\\"items\\\"`] \",\n\t\t\"[goqu - transaction] EXEC [query:=`SELECT * FROM \\\"items\\\" WHERE \\\"id\\\" = ?` args:=[1]] \",\n\t\t\"[goqu - transaction] COMMIT\",\n\t}, logger.Messages)\n}\n\nfunc (tds *txdatabaseSuite) TestCommit() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestRollback() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectRollback()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\ttds.NoError(tx.Rollback())\n}\n\nfunc (tds *txdatabaseSuite) TestFrom() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\ttds.NotNil(goqu.From(\"test\"))\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestScanStructs() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tmock.ExpectQuery(`SELECT \"test\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\tvar items []testActionItem\n\ttds.NoError(tx.ScanStructs(&items, `SELECT * FROM \"items\"`))\n\ttds.Len(items, 2)\n\ttds.Equal(\"111 Test Addr\", items[0].Address)\n\ttds.Equal(\"Test1\", items[0].Name)\n\n\ttds.Equal(\"211 Test Addr\", items[1].Address)\n\ttds.Equal(\"Test2\", items[1].Name)\n\n\titems = items[0:0]\n\ttds.EqualError(tx.ScanStructs(items, `SELECT * FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\ttds.EqualError(tx.ScanStructs(&testActionItem{}, `SELECT * FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\ttds.EqualError(tx.ScanStructs(&items, `SELECT \"test\" FROM \"items\"`),\n\t\t`goqu: unable to find corresponding field to column \"test\" returned by query`)\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestScanStruct() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).FromCSVString(\"111 Test Addr,Test1\"))\n\n\tmock.ExpectQuery(`SELECT \"test\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\tvar item testActionItem\n\tfound, err := tx.ScanStruct(&item, `SELECT * FROM \"items\" LIMIT 1`)\n\ttds.NoError(err)\n\ttds.True(found)\n\ttds.Equal(\"111 Test Addr\", item.Address)\n\ttds.Equal(\"Test1\", item.Name)\n\n\t_, err = tx.ScanStruct(item, `SELECT * FROM \"items\" LIMIT 1`)\n\ttds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = tx.ScanStruct([]testActionItem{}, `SELECT * FROM \"items\" LIMIT 1`)\n\ttds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = tx.ScanStruct(&item, `SELECT \"test\" FROM \"items\" LIMIT 1`)\n\ttds.EqualError(err, `goqu: unable to find corresponding field to column \"test\" returned by query`)\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestScanVals() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\tvar ids []uint32\n\ttds.NoError(tx.ScanVals(&ids, `SELECT \"id\" FROM \"items\"`))\n\ttds.Len(ids, 5)\n\n\ttds.EqualError(tx.ScanVals([]uint32{}, `SELECT \"id\" FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n\ttds.EqualError(tx.ScanVals(testActionItem{}, `SELECT \"id\" FROM \"items\"`),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestScanVal() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"10\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\tvar id int64\n\tfound, err := tx.ScanVal(&id, `SELECT \"id\" FROM \"items\"`)\n\ttds.NoError(err)\n\ttds.Equal(int64(10), id)\n\ttds.True(found)\n\n\tfound, err = tx.ScanVal([]int64{}, `SELECT \"id\" FROM \"items\"`)\n\ttds.False(found)\n\ttds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n\tfound, err = tx.ScanVal(10, `SELECT \"id\" FROM \"items\"`)\n\ttds.False(found)\n\ttds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestExec() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectExec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE \\(\"name\" IS NULL\\)`).\n\t\tWithArgs().\n\t\tWillReturnResult(sqlmock.NewResult(0, 0))\n\n\tmock.ExpectExec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE \\(\"name\" IS NULL\\)`).\n\t\tWithArgs().\n\t\tWillReturnError(errors.New(\"mock error\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\t_, err = tx.Exec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE (\"name\" IS NULL)`)\n\ttds.NoError(err)\n\t_, err = tx.Exec(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE (\"name\" IS NULL)`)\n\ttds.EqualError(err, \"goqu: mock error\")\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestQuery() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnError(errors.New(\"mock error\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\t_, err = tx.Query(`SELECT * FROM \"items\"`) //nolint:rowserrcheck // not checking row scan\n\ttds.NoError(err, \"goqu - mock error\")\n\n\t_, err = tx.Query(`SELECT * FROM \"items\"`) //nolint:rowserrcheck // not checking row scan\n\ttds.EqualError(err, \"goqu: mock error\")\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestQueryRow() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tmock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnError(errors.New(\"mock error\"))\n\tmock.ExpectCommit()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\trows := tx.QueryRow(`SELECT * FROM \"items\"`)\n\tvar address string\n\tvar name string\n\ttds.NoError(rows.Scan(&address, &name))\n\n\trows = tx.QueryRow(`SELECT * FROM \"items\"`)\n\ttds.EqualError(rows.Scan(&address, &name), \"goqu: mock error\")\n\ttds.NoError(tx.Commit())\n}\n\nfunc (tds *txdatabaseSuite) TestWrap() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tmock.ExpectCommit()\n\tmock.ExpectBegin()\n\tmock.ExpectRollback()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\ttds.NoError(tx.Wrap(func() error {\n\t\treturn nil\n\t}))\n\ttx, err = db.Begin()\n\ttds.NoError(err)\n\ttds.EqualError(tx.Wrap(func() error {\n\t\treturn errors.New(\"tx error\")\n\t}), \"goqu: tx error\")\n}\n\nfunc (tds *txdatabaseSuite) TestDataRace() {\n\tmDB, mock, err := sqlmock.New()\n\ttds.NoError(err)\n\tmock.ExpectBegin()\n\tdb := goqu.New(\"mock\", mDB)\n\ttx, err := db.Begin()\n\ttds.NoError(err)\n\n\tconst concurrency = 10\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tmock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\t\tWithArgs().\n\t\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\t}\n\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < concurrency; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tsql := tx.From(\"items\").Limit(1)\n\t\t\tvar item testActionItem\n\t\t\tfound, err := sql.ScanStruct(&item)\n\t\t\ttds.NoError(err)\n\t\t\ttds.True(found)\n\t\t\ttds.Equal(item.Address, \"111 Test Addr\")\n\t\t\ttds.Equal(item.Name, \"Test1\")\n\t\t}()\n\t}\n\n\twg.Wait()\n\tmock.ExpectCommit()\n\ttds.NoError(tx.Commit())\n}\n\nfunc TestTxDatabaseSuite(t *testing.T) {\n\tsuite.Run(t, new(txdatabaseSuite))\n}\n"
        },
        {
          "name": "delete_dataset.go",
          "type": "blob",
          "size": 7.8017578125,
          "content": "package goqu\n\nimport (\n\t\"github.com/doug-martin/goqu/v9/exec\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n)\n\nvar ErrBadFromArgument = errors.New(\"unsupported DeleteDataset#From argument, a string or identifier expression is required\")\n\ntype DeleteDataset struct {\n\tdialect      SQLDialect\n\tclauses      exp.DeleteClauses\n\tisPrepared   prepared\n\tqueryFactory exec.QueryFactory\n\terr          error\n}\n\n// used internally by database to create a database with a specific adapter\nfunc newDeleteDataset(d string, queryFactory exec.QueryFactory) *DeleteDataset {\n\treturn &DeleteDataset{\n\t\tclauses:      exp.NewDeleteClauses(),\n\t\tdialect:      GetDialect(d),\n\t\tqueryFactory: queryFactory,\n\t\tisPrepared:   preparedNoPreference,\n\t\terr:          nil,\n\t}\n}\n\nfunc Delete(table interface{}) *DeleteDataset {\n\treturn newDeleteDataset(\"default\", nil).From(table)\n}\n\nfunc (dd *DeleteDataset) Expression() exp.Expression {\n\treturn dd\n}\n\n// Clones the dataset\nfunc (dd *DeleteDataset) Clone() exp.Expression {\n\treturn dd.copy(dd.clauses)\n}\n\n// Set the parameter interpolation behavior. See examples\n//\n// prepared: If true the dataset WILL NOT interpolate the parameters.\nfunc (dd *DeleteDataset) Prepared(prepared bool) *DeleteDataset {\n\tret := dd.copy(dd.clauses)\n\tret.isPrepared = preparedFromBool(prepared)\n\treturn ret\n}\n\n// Returns true if Prepared(true) has been called on this dataset\nfunc (dd *DeleteDataset) IsPrepared() bool {\n\treturn dd.isPrepared.Bool()\n}\n\n// Sets the adapter used to serialize values and create the SQL statement\nfunc (dd *DeleteDataset) WithDialect(dl string) *DeleteDataset {\n\tds := dd.copy(dd.GetClauses())\n\tds.dialect = GetDialect(dl)\n\treturn ds\n}\n\n// Returns the current SQLDialect on the dataset\nfunc (dd *DeleteDataset) Dialect() SQLDialect {\n\treturn dd.dialect\n}\n\n// Set the dialect for this dataset.\nfunc (dd *DeleteDataset) SetDialect(dialect SQLDialect) *DeleteDataset {\n\tcd := dd.copy(dd.GetClauses())\n\tcd.dialect = dialect\n\treturn cd\n}\n\n// Returns the current clauses on the dataset.\nfunc (dd *DeleteDataset) GetClauses() exp.DeleteClauses {\n\treturn dd.clauses\n}\n\n// used interally to copy the dataset\nfunc (dd *DeleteDataset) copy(clauses exp.DeleteClauses) *DeleteDataset {\n\treturn &DeleteDataset{\n\t\tdialect:      dd.dialect,\n\t\tclauses:      clauses,\n\t\tisPrepared:   dd.isPrepared,\n\t\tqueryFactory: dd.queryFactory,\n\t\terr:          dd.err,\n\t}\n}\n\n// Creates a WITH clause for a common table expression (CTE).\n//\n// The name will be available to SELECT from in the associated query; and can optionally\n// contain a list of column names \"name(col1, col2, col3)\".\n//\n// The name will refer to the results of the specified subquery.\nfunc (dd *DeleteDataset) With(name string, subquery exp.Expression) *DeleteDataset {\n\treturn dd.copy(dd.clauses.CommonTablesAppend(exp.NewCommonTableExpression(false, name, subquery)))\n}\n\n// Creates a WITH RECURSIVE clause for a common table expression (CTE)\n//\n// The name will be available to SELECT from in the associated query; and must\n// contain a list of column names \"name(col1, col2, col3)\" for a recursive clause.\n//\n// The name will refer to the results of the specified subquery. The subquery for\n// a recursive query will always end with a UNION or UNION ALL with a clause that\n// refers to the CTE by name.\nfunc (dd *DeleteDataset) WithRecursive(name string, subquery exp.Expression) *DeleteDataset {\n\treturn dd.copy(dd.clauses.CommonTablesAppend(exp.NewCommonTableExpression(true, name, subquery)))\n}\n\n// Adds a FROM clause. This return a new dataset with the original sources replaced. See examples.\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tDataset: Will be added as a sub select. If the Dataset is not aliased it will automatically be aliased\n//\tLiteralExpression: (See Literal) Will use the literal SQL\nfunc (dd *DeleteDataset) From(table interface{}) *DeleteDataset {\n\tswitch t := table.(type) {\n\tcase exp.IdentifierExpression:\n\t\treturn dd.copy(dd.clauses.SetFrom(t))\n\tcase string:\n\t\treturn dd.copy(dd.clauses.SetFrom(exp.ParseIdentifier(t)))\n\tdefault:\n\t\tpanic(ErrBadFromArgument)\n\t}\n}\n\n// Adds a WHERE clause. See examples.\nfunc (dd *DeleteDataset) Where(expressions ...exp.Expression) *DeleteDataset {\n\treturn dd.copy(dd.clauses.WhereAppend(expressions...))\n}\n\n// Removes the WHERE clause. See examples.\nfunc (dd *DeleteDataset) ClearWhere() *DeleteDataset {\n\treturn dd.copy(dd.clauses.ClearWhere())\n}\n\n// Adds a ORDER clause. If the ORDER is currently set it replaces it. See examples.\nfunc (dd *DeleteDataset) Order(order ...exp.OrderedExpression) *DeleteDataset {\n\treturn dd.copy(dd.clauses.SetOrder(order...))\n}\n\n// Adds a more columns to the current ORDER BY clause. If no order has be previously specified it is the same as\n// calling Order. See examples.\nfunc (dd *DeleteDataset) OrderAppend(order ...exp.OrderedExpression) *DeleteDataset {\n\treturn dd.copy(dd.clauses.OrderAppend(order...))\n}\n\n// Adds a more columns to the beginning of the current ORDER BY clause. If no order has be previously specified it is the same as\n// calling Order. See examples.\nfunc (dd *DeleteDataset) OrderPrepend(order ...exp.OrderedExpression) *DeleteDataset {\n\treturn dd.copy(dd.clauses.OrderPrepend(order...))\n}\n\n// Removes the ORDER BY clause. See examples.\nfunc (dd *DeleteDataset) ClearOrder() *DeleteDataset {\n\treturn dd.copy(dd.clauses.ClearOrder())\n}\n\n// Adds a LIMIT clause. If the LIMIT is currently set it replaces it. See examples.\nfunc (dd *DeleteDataset) Limit(limit uint) *DeleteDataset {\n\tif limit > 0 {\n\t\treturn dd.copy(dd.clauses.SetLimit(limit))\n\t}\n\treturn dd.copy(dd.clauses.ClearLimit())\n}\n\n// Adds a LIMIT ALL clause. If the LIMIT is currently set it replaces it. See examples.\nfunc (dd *DeleteDataset) LimitAll() *DeleteDataset {\n\treturn dd.copy(dd.clauses.SetLimit(L(\"ALL\")))\n}\n\n// Removes the LIMIT clause.\nfunc (dd *DeleteDataset) ClearLimit() *DeleteDataset {\n\treturn dd.copy(dd.clauses.ClearLimit())\n}\n\n// Adds a RETURNING clause to the dataset if the adapter supports it.\nfunc (dd *DeleteDataset) Returning(returning ...interface{}) *DeleteDataset {\n\treturn dd.copy(dd.clauses.SetReturning(exp.NewColumnListExpression(returning...)))\n}\n\n// Get any error that has been set or nil if no error has been set.\nfunc (dd *DeleteDataset) Error() error {\n\treturn dd.err\n}\n\n// Set an error on the dataset if one has not already been set. This error will be returned by a future call to Error\n// or as part of ToSQL. This can be used by end users to record errors while building up queries without having to\n// track those separately.\nfunc (dd *DeleteDataset) SetError(err error) *DeleteDataset {\n\tif dd.err == nil {\n\t\tdd.err = err\n\t}\n\n\treturn dd\n}\n\n// Generates a DELETE sql statement, if Prepared has been called with true then the parameters will not be interpolated.\n// See examples.\n//\n// Errors:\n//   - There is an error generating the SQL\nfunc (dd *DeleteDataset) ToSQL() (sql string, params []interface{}, err error) {\n\treturn dd.deleteSQLBuilder().ToSQL()\n}\n\n// Appends this Dataset's DELETE statement to the SQLBuilder\n// This is used internally when using deletes in CTEs\nfunc (dd *DeleteDataset) AppendSQL(b sb.SQLBuilder) {\n\tif dd.err != nil {\n\t\tb.SetError(dd.err)\n\t\treturn\n\t}\n\tdd.dialect.ToDeleteSQL(b, dd.GetClauses())\n}\n\nfunc (dd *DeleteDataset) GetAs() exp.IdentifierExpression {\n\treturn nil\n}\n\nfunc (dd *DeleteDataset) ReturnsColumns() bool {\n\treturn dd.clauses.HasReturning()\n}\n\n// Creates an QueryExecutor to execute the query.\n//\n//\tdb.Delete(\"test\").Exec()\n//\n// See Dataset#ToUpdateSQL for arguments\nfunc (dd *DeleteDataset) Executor() exec.QueryExecutor {\n\treturn dd.queryFactory.FromSQLBuilder(dd.deleteSQLBuilder())\n}\n\nfunc (dd *DeleteDataset) deleteSQLBuilder() sb.SQLBuilder {\n\tbuf := sb.NewSQLBuilder(dd.isPrepared.Bool())\n\tif dd.err != nil {\n\t\treturn buf.SetError(dd.err)\n\t}\n\tdd.dialect.ToDeleteSQL(buf, dd.clauses)\n\treturn buf\n}\n"
        },
        {
          "name": "delete_dataset_example_test.go",
          "type": "blob",
          "size": 8.1865234375,
          "content": "package goqu_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n\t_ \"github.com/doug-martin/goqu/v9/dialect/mysql\"\n)\n\nfunc ExampleDelete() {\n\tds := goqu.Delete(\"items\")\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// DELETE FROM \"items\" []\n}\n\nfunc ExampleDeleteDataset_Executor() {\n\tdb := getDB()\n\n\tde := db.Delete(\"goqu_user\").\n\t\tWhere(goqu.Ex{\"first_name\": \"Bob\"}).\n\t\tExecutor()\n\tif r, err := de.Exec(); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tc, _ := r.RowsAffected()\n\t\tfmt.Printf(\"Deleted %d users\", c)\n\t}\n\n\t// Output:\n\t// Deleted 1 users\n}\n\nfunc ExampleDeleteDataset_Executor_returning() {\n\tdb := getDB()\n\n\tde := db.Delete(\"goqu_user\").\n\t\tWhere(goqu.C(\"last_name\").Eq(\"Yukon\")).\n\t\tReturning(goqu.C(\"id\")).\n\t\tExecutor()\n\n\tvar ids []int64\n\tif err := de.ScanVals(&ids); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Printf(\"Deleted users [ids:=%+v]\", ids)\n\t}\n\n\t// Output:\n\t// Deleted users [ids:=[1 2 3]]\n}\n\nfunc ExampleDeleteDataset_With() {\n\tsql, _, _ := goqu.Delete(\"test\").\n\t\tWith(\"check_vals(val)\", goqu.From().Select(goqu.L(\"123\"))).\n\t\tWhere(goqu.C(\"val\").Eq(goqu.From(\"check_vals\").Select(\"val\"))).\n\t\tToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// WITH check_vals(val) AS (SELECT 123) DELETE FROM \"test\" WHERE (\"val\" IN (SELECT \"val\" FROM \"check_vals\"))\n}\n\nfunc ExampleDeleteDataset_WithRecursive() {\n\tsql, _, _ := goqu.Delete(\"nums\").\n\t\tWithRecursive(\"nums(x)\",\n\t\t\tgoqu.From().Select(goqu.L(\"1\")).\n\t\t\t\tUnionAll(goqu.From(\"nums\").\n\t\t\t\t\tSelect(goqu.L(\"x+1\")).Where(goqu.C(\"x\").Lt(5)))).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// WITH RECURSIVE nums(x) AS (SELECT 1 UNION ALL (SELECT x+1 FROM \"nums\" WHERE (\"x\" < 5))) DELETE FROM \"nums\"\n}\n\nfunc ExampleDeleteDataset_Where() {\n\t// By default everything is anded together\n\tsql, _, _ := goqu.Delete(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\t// You can use ExOr to get ORed expressions together\n\tsql, _, _ = goqu.Delete(\"test\").Where(goqu.ExOr{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\t// You can use Or with Ex to Or multiple Ex maps together\n\tsql, _, _ = goqu.Delete(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.Ex{\n\t\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t},\n\t\t\tgoqu.Ex{\n\t\t\t\t\"c\": nil,\n\t\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t\t},\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// By default everything is anded together\n\tsql, _, _ = goqu.Delete(\"test\").Where(\n\t\tgoqu.C(\"a\").Gt(10),\n\t\tgoqu.C(\"b\").Lt(10),\n\t\tgoqu.C(\"c\").IsNull(),\n\t\tgoqu.C(\"d\").In(\"a\", \"b\", \"c\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// You can use a combination of Ors and Ands\n\tsql, _, _ = goqu.Delete(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t),\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM \"test\" WHERE ((\"a\" > 10) AND (\"b\" < 10) AND (\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c')))\n\t// DELETE FROM \"test\" WHERE ((\"a\" > 10) OR (\"b\" < 10) OR (\"c\" IS NULL) OR (\"d\" IN ('a', 'b', 'c')))\n\t// DELETE FROM \"test\" WHERE (((\"a\" > 10) AND (\"b\" < 10)) OR ((\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c'))))\n\t// DELETE FROM \"test\" WHERE ((\"a\" > 10) AND (\"b\" < 10) AND (\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c')))\n\t// DELETE FROM \"test\" WHERE ((\"a\" > 10) OR ((\"b\" < 10) AND (\"c\" IS NULL)))\n}\n\nfunc ExampleDeleteDataset_Where_prepared() {\n\t// By default everything is anded together\n\tsql, args, _ := goqu.Delete(\"test\").Prepared(true).Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use ExOr to get ORed expressions together\n\tsql, args, _ = goqu.Delete(\"test\").Prepared(true).Where(goqu.ExOr{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use Or with Ex to Or multiple Ex maps together\n\tsql, args, _ = goqu.Delete(\"test\").Prepared(true).Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.Ex{\n\t\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t},\n\t\t\tgoqu.Ex{\n\t\t\t\t\"c\": nil,\n\t\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t\t},\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// By default everything is anded together\n\tsql, args, _ = goqu.Delete(\"test\").Prepared(true).Where(\n\t\tgoqu.C(\"a\").Gt(10),\n\t\tgoqu.C(\"b\").Lt(10),\n\t\tgoqu.C(\"c\").IsNull(),\n\t\tgoqu.C(\"d\").In(\"a\", \"b\", \"c\"),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use a combination of Ors and Ands\n\tsql, args, _ = goqu.Delete(\"test\").Prepared(true).Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t),\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// DELETE FROM \"test\" WHERE ((\"a\" > ?) AND (\"b\" < ?) AND (\"c\" IS NULL) AND (\"d\" IN (?, ?, ?))) [10 10 a b c]\n\t// DELETE FROM \"test\" WHERE ((\"a\" > ?) OR (\"b\" < ?) OR (\"c\" IS NULL) OR (\"d\" IN (?, ?, ?))) [10 10 a b c]\n\t// DELETE FROM \"test\" WHERE (((\"a\" > ?) AND (\"b\" < ?)) OR ((\"c\" IS NULL) AND (\"d\" IN (?, ?, ?)))) [10 10 a b c]\n\t// DELETE FROM \"test\" WHERE ((\"a\" > ?) AND (\"b\" < ?) AND (\"c\" IS NULL) AND (\"d\" IN (?, ?, ?))) [10 10 a b c]\n\t// DELETE FROM \"test\" WHERE ((\"a\" > ?) OR ((\"b\" < ?) AND (\"c\" IS NULL))) [10 10]\n}\n\nfunc ExampleDeleteDataset_ClearWhere() {\n\tds := goqu.Delete(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t),\n\t\t),\n\t)\n\tsql, _, _ := ds.ClearWhere().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM \"test\"\n}\n\nfunc ExampleDeleteDataset_Limit() {\n\tds := goqu.Dialect(\"mysql\").Delete(\"test\").Limit(10)\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM `test` LIMIT 10\n}\n\nfunc ExampleDeleteDataset_LimitAll() {\n\t// Using mysql dialect because it supports limit on delete\n\tds := goqu.Dialect(\"mysql\").Delete(\"test\").LimitAll()\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM `test` LIMIT ALL\n}\n\nfunc ExampleDeleteDataset_ClearLimit() {\n\t// Using mysql dialect because it supports limit on delete\n\tds := goqu.Dialect(\"mysql\").Delete(\"test\").Limit(10)\n\tsql, _, _ := ds.ClearLimit().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE `test` FROM `test`\n}\n\nfunc ExampleDeleteDataset_Order() {\n\t// use mysql dialect because it supports order by on deletes\n\tds := goqu.Dialect(\"mysql\").Delete(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM `test` ORDER BY `a` ASC\n}\n\nfunc ExampleDeleteDataset_OrderAppend() {\n\t// use mysql dialect because it supports order by on deletes\n\tds := goqu.Dialect(\"mysql\").Delete(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.OrderAppend(goqu.C(\"b\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM `test` ORDER BY `a` ASC, `b` DESC NULLS LAST\n}\n\nfunc ExampleDeleteDataset_OrderPrepend() {\n\t// use mysql dialect because it supports order by on deletes\n\tds := goqu.Dialect(\"mysql\").Delete(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.OrderPrepend(goqu.C(\"b\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM `test` ORDER BY `b` DESC NULLS LAST, `a` ASC\n}\n\nfunc ExampleDeleteDataset_ClearOrder() {\n\tds := goqu.Delete(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.ClearOrder().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// DELETE FROM \"test\"\n}\n\nfunc ExampleDeleteDataset_ToSQL() {\n\tsql, args, _ := goqu.Delete(\"items\").ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.Delete(\"items\").\n\t\tWhere(goqu.Ex{\"id\": goqu.Op{\"gt\": 10}}).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// DELETE FROM \"items\" []\n\t// DELETE FROM \"items\" WHERE (\"id\" > 10) []\n}\n\nfunc ExampleDeleteDataset_Prepared() {\n\tsql, args, _ := goqu.Delete(\"items\").Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.Delete(\"items\").\n\t\tPrepared(true).\n\t\tWhere(goqu.Ex{\"id\": goqu.Op{\"gt\": 10}}).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// DELETE FROM \"items\" []\n\t// DELETE FROM \"items\" WHERE (\"id\" > ?) [10]\n}\n\nfunc ExampleDeleteDataset_Returning() {\n\tds := goqu.Delete(\"items\")\n\tsql, args, _ := ds.Returning(\"id\").ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Returning(\"id\").Where(goqu.C(\"id\").IsNotNull()).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// DELETE FROM \"items\" RETURNING \"id\" []\n\t// DELETE FROM \"items\" WHERE (\"id\" IS NOT NULL) RETURNING \"id\" []\n}\n"
        },
        {
          "name": "delete_dataset_test.go",
          "type": "blob",
          "size": 12.68359375,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/mocks\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\tdeleteTestCase struct {\n\t\tds      *goqu.DeleteDataset\n\t\tclauses exp.DeleteClauses\n\t}\n\tdeleteDatasetSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (dds *deleteDatasetSuite) assertCases(cases ...deleteTestCase) {\n\tfor _, s := range cases {\n\t\tdds.Equal(s.clauses, s.ds.GetClauses())\n\t}\n}\n\nfunc (dds *deleteDatasetSuite) SetupSuite() {\n\tnoReturn := goqu.DefaultDialectOptions()\n\tnoReturn.SupportsReturn = false\n\tgoqu.RegisterDialect(\"no-return\", noReturn)\n\n\tlimitOnDelete := goqu.DefaultDialectOptions()\n\tlimitOnDelete.SupportsLimitOnDelete = true\n\tgoqu.RegisterDialect(\"limit-on-delete\", limitOnDelete)\n\n\torderOnDelete := goqu.DefaultDialectOptions()\n\torderOnDelete.SupportsOrderByOnDelete = true\n\tgoqu.RegisterDialect(\"order-on-delete\", orderOnDelete)\n}\n\nfunc (dds *deleteDatasetSuite) TearDownSuite() {\n\tgoqu.DeregisterDialect(\"no-return\")\n\tgoqu.DeregisterDialect(\"limit-on-delete\")\n\tgoqu.DeregisterDialect(\"order-on-delete\")\n}\n\nfunc (dds *deleteDatasetSuite) TestDelete() {\n\tds := goqu.Delete(\"test\")\n\tdds.IsType(&goqu.DeleteDataset{}, ds)\n\tdds.Implements((*exp.Expression)(nil), ds)\n\tdds.Implements((*exp.AppendableExpression)(nil), ds)\n}\n\nfunc (dds *deleteDatasetSuite) TestClone() {\n\tds := goqu.Delete(\"test\")\n\tdds.Equal(ds.Clone(), ds)\n}\n\nfunc (dds *deleteDatasetSuite) TestExpression() {\n\tds := goqu.Delete(\"test\")\n\tdds.Equal(ds.Expression(), ds)\n}\n\nfunc (dds *deleteDatasetSuite) TestDialect() {\n\tds := goqu.Delete(\"test\")\n\tdds.NotNil(ds.Dialect())\n}\n\nfunc (dds *deleteDatasetSuite) TestWithDialect() {\n\tds := goqu.Delete(\"test\")\n\tmd := new(mocks.SQLDialect)\n\tds = ds.SetDialect(md)\n\n\tdialect := goqu.GetDialect(\"default\")\n\tdialectDs := ds.WithDialect(\"default\")\n\tdds.Equal(md, ds.Dialect())\n\tdds.Equal(dialect, dialectDs.Dialect())\n}\n\nfunc (dds *deleteDatasetSuite) TestPrepared() {\n\tds := goqu.Delete(\"test\")\n\tpreparedDs := ds.Prepared(true)\n\tdds.True(preparedDs.IsPrepared())\n\tdds.False(ds.IsPrepared())\n\t// should apply the prepared to any datasets created from the root\n\tdds.True(preparedDs.Where(goqu.Ex{\"a\": 1}).IsPrepared())\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\t// should be prepared by default\n\tds = goqu.Delete(\"test\")\n\tdds.True(ds.IsPrepared())\n}\n\nfunc (dds *deleteDatasetSuite) TestGetClauses() {\n\tds := goqu.Delete(\"test\")\n\tce := exp.NewDeleteClauses().SetFrom(goqu.I(\"test\"))\n\tdds.Equal(ce, ds.GetClauses())\n}\n\nfunc (dds *deleteDatasetSuite) TestWith() {\n\tfrom := goqu.From(\"cte\")\n\tbd := goqu.Delete(\"items\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.With(\"test-cte\", from),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from)),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestWithRecursive() {\n\tfrom := goqu.From(\"cte\")\n\tbd := goqu.Delete(\"items\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.WithRecursive(\"test-cte\", from),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(true, \"test-cte\", from)),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestFrom_withIdentifier() {\n\tbd := goqu.Delete(\"items\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds:      bd.From(\"items2\"),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items2\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd.From(goqu.C(\"items2\")),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items2\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd.From(goqu.T(\"items2\")),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.T(\"items2\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd.From(\"schema.table\"),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.I(\"schema.table\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t)\n\n\tdds.PanicsWithValue(goqu.ErrBadFromArgument, func() {\n\t\tgoqu.Delete(\"test\").From(true)\n\t})\n}\n\nfunc (dds *deleteDatasetSuite) TestWhere() {\n\tbd := goqu.Delete(\"items\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.Where(goqu.Ex{\"a\": 1}),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tWhereAppend(goqu.Ex{\"a\": 1}),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Where(goqu.Ex{\"a\": 1}).Where(goqu.C(\"b\").Eq(\"c\")),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tWhereAppend(goqu.Ex{\"a\": 1}).\n\t\t\t\tWhereAppend(goqu.C(\"b\").Eq(\"c\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestClearWhere() {\n\tbd := goqu.Delete(\"items\").Where(goqu.Ex{\"a\": 1})\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.ClearWhere(),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tWhereAppend(goqu.Ex{\"a\": 1}),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestOrder() {\n\tbd := goqu.Delete(\"items\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Asc()),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Asc()).Order(goqu.C(\"b\").Desc()),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"b\").Desc()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestOrderAppend() {\n\tbd := goqu.Delete(\"items\").Order(goqu.C(\"a\").Asc())\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.OrderAppend(goqu.C(\"b\").Desc()),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestOrderPrepend() {\n\tbd := goqu.Delete(\"items\").Order(goqu.C(\"a\").Asc())\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.OrderPrepend(goqu.C(\"b\").Desc()),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"b\").Desc(), goqu.C(\"a\").Asc()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestClearOrder() {\n\tbd := goqu.Delete(\"items\").Order(goqu.C(\"a\").Asc())\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds:      bd.ClearOrder(),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestLimit() {\n\tbd := goqu.Delete(\"test\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.Limit(10),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"test\")).\n\t\t\t\tSetLimit(uint(10)),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd.Limit(0),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"test\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Limit(10).Limit(2),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"test\")).\n\t\t\t\tSetLimit(uint(2)),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd.Limit(10).Limit(0),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"test\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestLimitAll() {\n\tbd := goqu.Delete(\"test\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.LimitAll(),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"test\")).\n\t\t\t\tSetLimit(goqu.L(\"ALL\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Limit(10).LimitAll(),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"test\")).\n\t\t\t\tSetLimit(goqu.L(\"ALL\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestClearLimit() {\n\tbd := goqu.Delete(\"test\").Limit(10)\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds:      bd.ClearLimit(),\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"test\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"test\")).SetLimit(uint(10)),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestReturning() {\n\tbd := goqu.Delete(\"items\")\n\tdds.assertCases(\n\t\tdeleteTestCase{\n\t\t\tds: bd.Returning(\"a\"),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression(\"a\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Returning(),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Returning(nil),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds: bd.Returning(\"a\").Returning(\"b\"),\n\t\t\tclauses: exp.NewDeleteClauses().\n\t\t\t\tSetFrom(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression(\"b\")),\n\t\t},\n\t\tdeleteTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewDeleteClauses().SetFrom(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (dds *deleteDatasetSuite) TestReturnsColumns() {\n\tds := goqu.Delete(\"test\")\n\tdds.False(ds.ReturnsColumns())\n\tdds.True(ds.Returning(\"foo\", \"bar\").ReturnsColumns())\n}\n\nfunc (dds *deleteDatasetSuite) TestToSQL() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Delete(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToDeleteSQL\", sqlB, c).Return(nil).Once()\n\n\tsql, args, err := ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Nil(err)\n\tmd.AssertExpectations(dds.T())\n}\n\nfunc (dds *deleteDatasetSuite) TestToSQL_Prepared() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Delete(\"test\").Prepared(true).SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(true)\n\tmd.On(\"ToDeleteSQL\", sqlB, c).Return(nil).Once()\n\n\tsql, args, err := ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Nil(err)\n\tmd.AssertExpectations(dds.T())\n}\n\nfunc (dds *deleteDatasetSuite) TestToSQL_WithError() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Delete(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tee := errors.New(\"expected error\")\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToDeleteSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(ee)\n\t}).Once()\n\n\tsql, args, err := ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Equal(ee, err)\n\tmd.AssertExpectations(dds.T())\n}\n\nfunc (dds *deleteDatasetSuite) TestExecutor() {\n\tmDB, _, err := sqlmock.New()\n\tdds.NoError(err)\n\n\tds := goqu.New(\"mock\", mDB).Delete(\"items\").Where(goqu.Ex{\"id\": goqu.Op{\"gt\": 10}})\n\n\tdsql, args, err := ds.Executor().ToSQL()\n\tdds.NoError(err)\n\tdds.Empty(args)\n\tdds.Equal(`DELETE FROM \"items\" WHERE (\"id\" > 10)`, dsql)\n\n\tdsql, args, err = ds.Prepared(true).Executor().ToSQL()\n\tdds.NoError(err)\n\tdds.Equal([]interface{}{int64(10)}, args)\n\tdds.Equal(`DELETE FROM \"items\" WHERE (\"id\" > ?)`, dsql)\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\tdsql, args, err = ds.Executor().ToSQL()\n\tdds.NoError(err)\n\tdds.Equal([]interface{}{int64(10)}, args)\n\tdds.Equal(`DELETE FROM \"items\" WHERE (\"id\" > ?)`, dsql)\n}\n\nfunc (dds *deleteDatasetSuite) TestSetError() {\n\terr1 := errors.New(\"error #1\")\n\terr2 := errors.New(\"error #2\")\n\terr3 := errors.New(\"error #3\")\n\n\t// Verify initial error set/get works properly\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Delete(\"test\").SetDialect(md)\n\tds = ds.SetError(err1)\n\tdds.Equal(err1, ds.Error())\n\tsql, args, err := ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Equal(err1, err)\n\n\t// Repeated SetError calls on Dataset should not overwrite the original error\n\tds = ds.SetError(err2)\n\tdds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Equal(err1, err)\n\n\t// Builder functions should not lose the error\n\tds = ds.ClearLimit()\n\tdds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Equal(err1, err)\n\n\t// Deeper errors inside SQL generation should still return original error\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToDeleteSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(err3)\n\t}).Once()\n\n\tsql, args, err = ds.ToSQL()\n\tdds.Empty(sql)\n\tdds.Empty(args)\n\tdds.Equal(err1, err)\n}\n\nfunc TestDeleteDataset(t *testing.T) {\n\tsuite.Run(t, new(deleteDatasetSuite))\n}\n"
        },
        {
          "name": "dialect",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 1.9228515625,
          "content": "version: \"2\"\n\nservices:\n  postgres:\n    image: \"postgres:${POSTGRES_VERSION}\"\n    environment:\n      - \"POSTGRES_USER=postgres\"\n      - \"POSTGRES_DB=goqupostgres\"\n      - \"POSTGRES_HOST_AUTH_METHOD=trust\"\n    expose:\n      - \"5432\"\n    ports:\n      - \"5432:5432\"\n\n  mysql:\n    image: \"mysql:${MYSQL_VERSION}\"\n    environment:\n      - \"MYSQL_DATABASE=goqumysql\"\n      - \"MYSQL_ALLOW_EMPTY_PASSWORD=yes\"\n    expose:\n      - \"3306\"\n    ports:\n      - \"3306:3306\"\n\n  sqlserver:\n    image: \"mcr.microsoft.com/mssql/server:${SQLSERVER_VERSION}\"\n    environment:\n      - \"ACCEPT_EULA=Y\"\n      - \"SA_PASSWORD=qwe123QWE\"\n    expose:\n      - \"1433\"\n    ports:\n      - \"1433:1433\"\n\n  goqu:\n    image: \"golang:${GO_VERSION}\"\n    command: [\"./wait-for-it.sh\", \"postgres:5432\", \"--\", \"./wait-for-it.sh\", \"mysql:3306\", \"--\", \"./wait-for-it.sh\", \"sqlserver:1433\", \"--\", \"./go.test.sh\"]\n    working_dir: /go/src/github.com/doug-martin/goqu\n    volumes:\n      - \"./:/go/src/github.com/doug-martin/goqu\"\n    environment:\n      MYSQL_URI: 'root@tcp(mysql:3306)/goqumysql?parseTime=true'\n      PG_URI: 'postgres://postgres:@postgres:5432/goqupostgres?sslmode=disable'\n      SQLSERVER_URI: 'sqlserver://sa:qwe123QWE@sqlserver:1433?database=master&connection+timeout=30'\n    depends_on:\n      - postgres\n      - mysql\n      - sqlserver\n  goqu-coverage:\n    image: \"golang:${GO_VERSION}\"\n    command: [\"./wait-for-it.sh\", \"postgres:5432\", \"--\", \"./wait-for-it.sh\", \"mysql:3306\", \"--\",  \"./wait-for-it.sh\", \"sqlserver:1433\", \"--\", \"./go.coverage.sh\"]\n    working_dir: /go/src/github.com/doug-martin/goqu\n    volumes:\n      - \"./:/go/src/github.com/doug-martin/goqu\"\n    environment:\n      MYSQL_URI: 'root@tcp(mysql:3306)/goqumysql?parseTime=true'\n      PG_URI: 'postgres://postgres:@postgres:5432/goqupostgres?sslmode=disable'\n      SQLSERVER_URI: 'sqlserver://sa:qwe123QWE@sqlserver:1433?database=master&connection+timeout=30'\n    depends_on:\n      - postgres\n      - mysql\n      - sqlserver\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "exec",
          "type": "tree",
          "content": null
        },
        {
          "name": "exp",
          "type": "tree",
          "content": null
        },
        {
          "name": "expressions.go",
          "type": "blob",
          "size": 10.6357421875,
          "content": "package goqu\n\nimport (\n\t\"github.com/doug-martin/goqu/v9/exp\"\n)\n\ntype (\n\tExpression = exp.Expression\n\tEx         = exp.Ex\n\tExOr       = exp.ExOr\n\tOp         = exp.Op\n\tRecord     = exp.Record\n\tVals       = exp.Vals\n\t// Options to use when generating a TRUNCATE statement\n\tTruncateOptions = exp.TruncateOptions\n)\n\n// emptyWindow is an empty WINDOW clause without name\nvar emptyWindow = exp.NewWindowExpression(nil, nil, nil, nil)\n\nconst (\n\tWait       = exp.Wait\n\tNoWait     = exp.NoWait\n\tSkipLocked = exp.SkipLocked\n)\n\n// Creates a new Casted expression\n//\n//\tCast(I(\"a\"), \"NUMERIC\") -> CAST(\"a\" AS NUMERIC)\nfunc Cast(e exp.Expression, t string) exp.CastExpression {\n\treturn exp.NewCastExpression(e, t)\n}\n\n// Creates a conflict struct to be passed to InsertConflict to ignore constraint errors\n//\n//\tInsertConflict(DoNothing(),...) -> INSERT INTO ... ON CONFLICT DO NOTHING\nfunc DoNothing() exp.ConflictExpression {\n\treturn exp.NewDoNothingConflictExpression()\n}\n\n// Creates a ConflictUpdate struct to be passed to InsertConflict\n// Represents a ON CONFLICT DO UPDATE portion of an INSERT statement (ON DUPLICATE KEY UPDATE for mysql)\n//\n//\tInsertConflict(DoUpdate(\"target_column\", update),...) ->\n//\t\tINSERT INTO ... ON CONFLICT DO UPDATE SET a=b\n//\tInsertConflict(DoUpdate(\"target_column\", update).Where(Ex{\"a\": 1},...) ->\n//\t\tINSERT INTO ... ON CONFLICT DO UPDATE SET a=b WHERE a=1\nfunc DoUpdate(target string, update interface{}) exp.ConflictUpdateExpression {\n\treturn exp.NewDoUpdateConflictExpression(target, update)\n}\n\n// A list of expressions that should be ORed together\n//\n//\tOr(I(\"a\").Eq(10), I(\"b\").Eq(11)) //((\"a\" = 10) OR (\"b\" = 11))\nfunc Or(expressions ...exp.Expression) exp.ExpressionList {\n\treturn exp.NewExpressionList(exp.OrType, expressions...)\n}\n\n// A list of expressions that should be ANDed together\n//\n//\tAnd(I(\"a\").Eq(10), I(\"b\").Eq(11)) //((\"a\" = 10) AND (\"b\" = 11))\nfunc And(expressions ...exp.Expression) exp.ExpressionList {\n\treturn exp.NewExpressionList(exp.AndType, expressions...)\n}\n\n// Creates a new SQLFunctionExpression with the given name and arguments\nfunc Func(name string, args ...interface{}) exp.SQLFunctionExpression {\n\treturn exp.NewSQLFunctionExpression(name, args...)\n}\n\n// used internally to normalize the column name if passed in as a string it should be turned into an identifier\nfunc newIdentifierFunc(name string, col interface{}) exp.SQLFunctionExpression {\n\tif s, ok := col.(string); ok {\n\t\tcol = I(s)\n\t}\n\treturn Func(name, col)\n}\n\n// Creates a new DISTINCT sql function\n//\n//\tDISTINCT(\"a\") -> DISTINCT(\"a\")\n//\tDISTINCT(I(\"a\")) -> DISTINCT(\"a\")\nfunc DISTINCT(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"DISTINCT\", col) }\n\n// Creates a new COUNT sql function\n//\n//\tCOUNT(\"a\") -> COUNT(\"a\")\n//\tCOUNT(\"*\") -> COUNT(\"*\")\n//\tCOUNT(I(\"a\")) -> COUNT(\"a\")\nfunc COUNT(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"COUNT\", col) }\n\n// Creates a new MIN sql function\n//\n//\tMIN(\"a\") -> MIN(\"a\")\n//\tMIN(I(\"a\")) -> MIN(\"a\")\nfunc MIN(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"MIN\", col) }\n\n// Creates a new MAX sql function\n//\n//\tMAX(\"a\") -> MAX(\"a\")\n//\tMAX(I(\"a\")) -> MAX(\"a\")\nfunc MAX(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"MAX\", col) }\n\n// Creates a new AVG sql function\n//\n//\tAVG(\"a\") -> AVG(\"a\")\n//\tAVG(I(\"a\")) -> AVG(\"a\")\nfunc AVG(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"AVG\", col) }\n\n// Creates a new FIRST sql function\n//\n//\tFIRST(\"a\") -> FIRST(\"a\")\n//\tFIRST(I(\"a\")) -> FIRST(\"a\")\nfunc FIRST(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"FIRST\", col) }\n\n// Creates a new LAST sql function\n//\n//\tLAST(\"a\") -> LAST(\"a\")\n//\tLAST(I(\"a\")) -> LAST(\"a\")\nfunc LAST(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"LAST\", col) }\n\n// Creates a new SUM sql function\n//\n//\tSUM(\"a\") -> SUM(\"a\")\n//\tSUM(I(\"a\")) -> SUM(\"a\")\nfunc SUM(col interface{}) exp.SQLFunctionExpression { return newIdentifierFunc(\"SUM\", col) }\n\n// Creates a new COALESCE sql function\n//\n//\tCOALESCE(I(\"a\"), \"a\") -> COALESCE(\"a\", 'a')\n//\tCOALESCE(I(\"a\"), I(\"b\"), nil) -> COALESCE(\"a\", \"b\", NULL)\nfunc COALESCE(vals ...interface{}) exp.SQLFunctionExpression {\n\treturn Func(\"COALESCE\", vals...)\n}\n\n//nolint:stylecheck,revive // sql function name\nfunc ROW_NUMBER() exp.SQLFunctionExpression {\n\treturn Func(\"ROW_NUMBER\")\n}\n\nfunc RANK() exp.SQLFunctionExpression {\n\treturn Func(\"RANK\")\n}\n\n//nolint:stylecheck,revive // sql function name\nfunc DENSE_RANK() exp.SQLFunctionExpression {\n\treturn Func(\"DENSE_RANK\")\n}\n\n//nolint:stylecheck,revive // sql function name\nfunc PERCENT_RANK() exp.SQLFunctionExpression {\n\treturn Func(\"PERCENT_RANK\")\n}\n\n//nolint:stylecheck,revive //sql function name\nfunc CUME_DIST() exp.SQLFunctionExpression {\n\treturn Func(\"CUME_DIST\")\n}\n\nfunc NTILE(n int) exp.SQLFunctionExpression {\n\treturn Func(\"NTILE\", n)\n}\n\n//nolint:stylecheck,revive //sql function name\nfunc FIRST_VALUE(val interface{}) exp.SQLFunctionExpression {\n\treturn newIdentifierFunc(\"FIRST_VALUE\", val)\n}\n\n//nolint:stylecheck,revive //sql function name\nfunc LAST_VALUE(val interface{}) exp.SQLFunctionExpression {\n\treturn newIdentifierFunc(\"LAST_VALUE\", val)\n}\n\n//nolint:stylecheck,revive //sql function name\nfunc NTH_VALUE(val interface{}, nth int) exp.SQLFunctionExpression {\n\tif s, ok := val.(string); ok {\n\t\tval = I(s)\n\t}\n\treturn Func(\"NTH_VALUE\", val, nth)\n}\n\n// Creates a new Identifier, the generated sql will use adapter specific quoting or '\"' by default, this ensures case\n// sensitivity and in certain databases allows for special characters, (e.g. \"curr-table\", \"my table\").\n//\n// The identifier will be split by '.'\n//\n// Table and Column example\n//\n//\tI(\"table.column\") -> \"table\".\"column\" //A Column and table\n//\n// Schema table and column\n//\n//\tI(\"schema.table.column\") -> \"schema\".\"table\".\"column\"\n//\n// Table with star\n//\n//\tI(\"table.*\") -> \"table\".*\nfunc I(ident string) exp.IdentifierExpression {\n\treturn exp.ParseIdentifier(ident)\n}\n\n// Creates a new Column Identifier, the generated sql will use adapter specific quoting or '\"' by default, this ensures case\n// sensitivity and in certain databases allows for special characters, (e.g. \"curr-table\", \"my table\").\n// An Identifier can represent a one or a combination of schema, table, and/or column.\n//\n//\tC(\"column\") -> \"column\" //A Column\n//\tC(\"column\").Table(\"table\") -> \"table\".\"column\" //A Column and table\n//\tC(\"column\").Table(\"table\").Schema(\"schema\") //Schema table and column\n//\tC(\"*\") //Also handles the * operator\nfunc C(col string) exp.IdentifierExpression {\n\treturn exp.NewIdentifierExpression(\"\", \"\", col)\n}\n\n// Creates a new Schema Identifier, the generated sql will use adapter specific quoting or '\"' by default, this ensures case\n// sensitivity and in certain databases allows for special characters, (e.g. \"curr-schema\", \"my schema\").\n//\n//\tS(\"schema\") -> \"schema\" //A Schema\n//\tS(\"schema\").Table(\"table\") -> \"schema\".\"table\" //A Schema and table\n//\tS(\"schema\").Table(\"table\").Col(\"col\") //Schema table and column\n//\tS(\"schema\").Table(\"table\").Col(\"*\") //Schema table and all columns\nfunc S(schema string) exp.IdentifierExpression {\n\treturn exp.NewIdentifierExpression(schema, \"\", \"\")\n}\n\n// Creates a new Table Identifier, the generated sql will use adapter specific quoting or '\"' by default, this ensures case\n// sensitivity and in certain databases allows for special characters, (e.g. \"curr-table\", \"my table\").\n//\n//\tT(\"table\") -> \"table\" //A Column\n//\tT(\"table\").Col(\"col\") -> \"table\".\"column\" //A Column and table\n//\tT(\"table\").Schema(\"schema\").Col(\"col) -> \"schema\".\"table\".\"column\"  //Schema table and column\n//\tT(\"table\").Schema(\"schema\").Col(\"*\") -> \"schema\".\"table\".*  //Also handles the * operator\nfunc T(table string) exp.IdentifierExpression {\n\treturn exp.NewIdentifierExpression(\"\", table, \"\")\n}\n\n// Create a new WINDOW clause\n//\n//\tW() -> ()\n//\tW().PartitionBy(\"a\") -> (PARTITION BY \"a\")\n//\tW().PartitionBy(\"a\").OrderBy(\"b\") -> (PARTITION BY \"a\" ORDER BY \"b\")\n//\tW().PartitionBy(\"a\").OrderBy(\"b\").Inherit(\"w1\") -> (\"w1\" PARTITION BY \"a\" ORDER BY \"b\")\n//\tW().PartitionBy(\"a\").OrderBy(I(\"b\").Desc()).Inherit(\"w1\") -> (\"w1\" PARTITION BY \"a\" ORDER BY \"b\" DESC)\n//\tW(\"w\") -> \"w\" AS ()\n//\tW(\"w\", \"w1\") -> \"w\" AS (\"w1\")\n//\tW(\"w\").Inherit(\"w1\") -> \"w\" AS (\"w1\")\n//\tW(\"w\").PartitionBy(\"a\") -> \"w\" AS (PARTITION BY \"a\")\n//\tW(\"w\", \"w1\").PartitionBy(\"a\") -> \"w\" AS (\"w1\" PARTITION BY \"a\")\n//\tW(\"w\", \"w1\").PartitionBy(\"a\").OrderBy(\"b\") -> \"w\" AS (\"w1\" PARTITION BY \"a\" ORDER BY \"b\")\nfunc W(ws ...string) exp.WindowExpression {\n\tswitch len(ws) {\n\tcase 0:\n\t\treturn emptyWindow\n\tcase 1:\n\t\treturn exp.NewWindowExpression(I(ws[0]), nil, nil, nil)\n\tdefault:\n\t\treturn exp.NewWindowExpression(I(ws[0]), I(ws[1]), nil, nil)\n\t}\n}\n\n// Creates a new ON clause to be used within a join\n//\n//\tds.Join(goqu.T(\"my_table\"), goqu.On(\n//\t   goqu.I(\"my_table.fkey\").Eq(goqu.I(\"other_table.id\")),\n//\t))\nfunc On(expressions ...exp.Expression) exp.JoinCondition {\n\treturn exp.NewJoinOnCondition(expressions...)\n}\n\n// Creates a new USING clause to be used within a join\n//\n//\tds.Join(goqu.T(\"my_table\"), goqu.Using(\"fkey\"))\nfunc Using(columns ...interface{}) exp.JoinCondition {\n\treturn exp.NewJoinUsingCondition(columns...)\n}\n\n// Creates a new SQL literal with the provided arguments.\n//\n//\tL(\"a = 1\") -> a = 1\n//\n// You can also you placeholders. All placeholders within a Literal are represented by '?'\n//\n//\tL(\"a = ?\", \"b\") -> a = 'b'\n//\n// Literals can also contain placeholders for other expressions\n//\n//\tL(\"(? AND ?) OR (?)\", I(\"a\").Eq(1), I(\"b\").Eq(\"b\"), I(\"c\").In([]string{\"a\", \"b\", \"c\"}))\nfunc L(sql string, args ...interface{}) exp.LiteralExpression {\n\treturn Literal(sql, args...)\n}\n\n// Alias for goqu.L\nfunc Literal(sql string, args ...interface{}) exp.LiteralExpression {\n\treturn exp.NewLiteralExpression(sql, args...)\n}\n\n// Create a new SQL value ( alias for goqu.L(\"?\", val) ). The prrimary use case for this would be in selects.\n// See examples.\nfunc V(val interface{}) exp.LiteralExpression {\n\treturn exp.NewLiteralExpression(\"?\", val)\n}\n\n// Creates a new Range to be used with a Between expression\n//\n//\texp.C(\"col\").Between(exp.Range(1, 10))\nfunc Range(start, end interface{}) exp.RangeVal {\n\treturn exp.NewRangeVal(start, end)\n}\n\n// Creates a literal *\nfunc Star() exp.LiteralExpression { return exp.Star() }\n\n// Returns a literal for DEFAULT sql keyword\nfunc Default() exp.LiteralExpression {\n\treturn exp.Default()\n}\n\nfunc Lateral(table exp.AppendableExpression) exp.LateralExpression {\n\treturn exp.NewLateralExpression(table)\n}\n\n// Create a new ANY comparison\nfunc Any(val interface{}) exp.SQLFunctionExpression {\n\treturn Func(\"ANY \", val)\n}\n\n// Create a new ALL comparison\nfunc All(val interface{}) exp.SQLFunctionExpression {\n\treturn Func(\"ALL \", val)\n}\n\nfunc Case() exp.CaseExpression {\n\treturn exp.NewCaseExpression()\n}\n"
        },
        {
          "name": "expressions_example_test.go",
          "type": "blob",
          "size": 52.56640625,
          "content": "//nolint:lll // sql statements are long\npackage goqu_test\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n)\n\nfunc ExampleAVG() {\n\tds := goqu.From(\"test\").Select(goqu.AVG(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT AVG(\"col\") FROM \"test\" []\n\t// SELECT AVG(\"col\") FROM \"test\" []\n}\n\nfunc ExampleAVG_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.AVG(\"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT AVG(\"a\") AS \"a\" FROM \"test\"\n}\n\nfunc ExampleAVG_havingClause() {\n\tds := goqu.\n\t\tFrom(\"test\").\n\t\tSelect(goqu.AVG(\"a\").As(\"avg\")).\n\t\tGroupBy(\"a\").\n\t\tHaving(goqu.AVG(\"a\").Gt(10))\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT AVG(\"a\") AS \"avg\" FROM \"test\" GROUP BY \"a\" HAVING (AVG(\"a\") > 10) []\n\t// SELECT AVG(\"a\") AS \"avg\" FROM \"test\" GROUP BY \"a\" HAVING (AVG(\"a\") > ?) [10]\n}\n\nfunc ExampleAnd() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.And(\n\t\t\tgoqu.C(\"col\").Gt(10),\n\t\t\tgoqu.C(\"col\").Lt(20),\n\t\t),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"col\" > 10) AND (\"col\" < 20)) []\n\t// SELECT * FROM \"test\" WHERE ((\"col\" > ?) AND (\"col\" < ?)) [10 20]\n}\n\n// You can use And with Or to create more complex queries\nfunc ExampleAnd_withOr() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.And(\n\t\t\tgoqu.C(\"col1\").IsTrue(),\n\t\t\tgoqu.Or(\n\t\t\t\tgoqu.C(\"col2\").Gt(10),\n\t\t\t\tgoqu.C(\"col2\").Lt(20),\n\t\t\t),\n\t\t),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// by default expressions are anded together\n\tds = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col1\").IsTrue(),\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"col2\").Gt(10),\n\t\t\tgoqu.C(\"col2\").Lt(20),\n\t\t),\n\t)\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" IS TRUE) AND ((\"col2\" > 10) OR (\"col2\" < 20))) []\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" IS TRUE) AND ((\"col2\" > ?) OR (\"col2\" < ?))) [10 20]\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" IS TRUE) AND ((\"col2\" > 10) OR (\"col2\" < 20))) []\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" IS TRUE) AND ((\"col2\" > ?) OR (\"col2\" < ?))) [10 20]\n}\n\n// You can use ExOr inside of And expression lists.\nfunc ExampleAnd_withExOr() {\n\t// by default expressions are anded together\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col1\").IsTrue(),\n\t\tgoqu.ExOr{\n\t\t\t\"col2\": goqu.Op{\"gt\": 10},\n\t\t\t\"col3\": goqu.Op{\"lt\": 20},\n\t\t},\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" IS TRUE) AND ((\"col2\" > 10) OR (\"col3\" < 20))) []\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" IS TRUE) AND ((\"col2\" > ?) OR (\"col3\" < ?))) [10 20]\n}\n\nfunc ExampleC() {\n\tsql, args, _ := goqu.From(\"test\").\n\t\tSelect(goqu.C(\"*\")).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").\n\t\tSelect(goqu.C(\"col1\")).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col1\").Eq(10),\n\t\tgoqu.C(\"col2\").In([]int64{1, 2, 3, 4}),\n\t\tgoqu.C(\"col3\").Like(regexp.MustCompile(\"^[ab]\")),\n\t\tgoqu.C(\"col4\").IsNull(),\n\t)\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" []\n\t// SELECT \"col1\" FROM \"test\" []\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" = 10) AND (\"col2\" IN (1, 2, 3, 4)) AND (\"col3\" ~ '^[ab]') AND (\"col4\" IS NULL)) []\n\t// SELECT * FROM \"test\" WHERE ((\"col1\" = ?) AND (\"col2\" IN (?, ?, ?, ?)) AND (\"col3\" ~ ?) AND (\"col4\" IS NULL)) [10 1 2 3 4 ^[ab]]\n}\n\nfunc ExampleC_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.C(\"a\").As(\"as_a\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Select(goqu.C(\"a\").As(goqu.C(\"as_a\"))).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT \"a\" AS \"as_a\" FROM \"test\"\n\t// SELECT \"a\" AS \"as_a\" FROM \"test\"\n}\n\nfunc ExampleC_ordering() {\n\tsql, args, _ := goqu.From(\"test\").Order(goqu.C(\"a\").Asc()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Order(goqu.C(\"a\").Asc().NullsFirst()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Order(goqu.C(\"a\").Asc().NullsLast()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Order(goqu.C(\"a\").Desc()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Order(goqu.C(\"a\").Desc().NullsFirst()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Order(goqu.C(\"a\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" ORDER BY \"a\" ASC []\n\t// SELECT * FROM \"test\" ORDER BY \"a\" ASC NULLS FIRST []\n\t// SELECT * FROM \"test\" ORDER BY \"a\" ASC NULLS LAST []\n\t// SELECT * FROM \"test\" ORDER BY \"a\" DESC []\n\t// SELECT * FROM \"test\" ORDER BY \"a\" DESC NULLS FIRST []\n\t// SELECT * FROM \"test\" ORDER BY \"a\" DESC NULLS LAST []\n}\n\nfunc ExampleC_cast() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tSelect(goqu.C(\"json1\").Cast(\"TEXT\").As(\"json_text\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"json1\").Cast(\"TEXT\").Neq(\n\t\t\tgoqu.C(\"json2\").Cast(\"TEXT\"),\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT CAST(\"json1\" AS TEXT) AS \"json_text\" FROM \"test\"\n\t// SELECT * FROM \"test\" WHERE (CAST(\"json1\" AS TEXT) != CAST(\"json2\" AS TEXT))\n}\n\nfunc ExampleC_comparisons() {\n\t// used from an identifier\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.C(\"a\").Eq(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Neq(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Gt(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Gte(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Lt(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Lte(10)).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" = 10)\n\t// SELECT * FROM \"test\" WHERE (\"a\" != 10)\n\t// SELECT * FROM \"test\" WHERE (\"a\" > 10)\n\t// SELECT * FROM \"test\" WHERE (\"a\" >= 10)\n\t// SELECT * FROM \"test\" WHERE (\"a\" < 10)\n\t// SELECT * FROM \"test\" WHERE (\"a\" <= 10)\n}\n\nfunc ExampleC_inOperators() {\n\t// using identifiers\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.C(\"a\").In(\"a\", \"b\", \"c\")).ToSQL()\n\tfmt.Println(sql)\n\t// with a slice\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").In([]string{\"a\", \"b\", \"c\"})).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").NotIn(\"a\", \"b\", \"c\")).ToSQL()\n\tfmt.Println(sql)\n\t// with a slice\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").NotIn([]string{\"a\", \"b\", \"c\"})).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" IN ('a', 'b', 'c'))\n\t// SELECT * FROM \"test\" WHERE (\"a\" IN ('a', 'b', 'c'))\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT IN ('a', 'b', 'c'))\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT IN ('a', 'b', 'c'))\n}\n\nfunc ExampleC_likeComparisons() {\n\t// using identifiers\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.C(\"a\").Like(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Like(regexp.MustCompile(`[ab]`))).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").ILike(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").ILike(regexp.MustCompile(\"[ab]\"))).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").NotLike(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").NotLike(regexp.MustCompile(\"[ab]\"))).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").NotILike(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.C(\"a\").NotILike(regexp.MustCompile(`[ab]`))).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" LIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE (\"a\" ~ '[ab]')\n\t// SELECT * FROM \"test\" WHERE (\"a\" ILIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE (\"a\" ~* '[ab]')\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT LIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE (\"a\" !~ '[ab]')\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT ILIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE (\"a\" !~* '[ab]')\n}\n\nfunc ExampleC_isComparisons() {\n\tsql, args, _ := goqu.From(\"test\").Where(goqu.C(\"a\").Is(nil)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Is(true)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").Is(false)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNull()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsTrue()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsFalse()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNot(nil)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNot(true)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNot(false)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNotNull()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNotTrue()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.C(\"a\").IsNotFalse()).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT FALSE) []\n}\n\nfunc ExampleC_betweenComparisons() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.C(\"a\").Between(goqu.Range(1, 10)),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"a\").NotBetween(goqu.Range(1, 10)),\n\t)\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" BETWEEN ? AND ?) [1 10]\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT BETWEEN ? AND ?) [1 10]\n}\n\nfunc ExampleCOALESCE() {\n\tds := goqu.From(\"test\").Select(\n\t\tgoqu.COALESCE(goqu.C(\"a\"), \"a\"),\n\t\tgoqu.COALESCE(goqu.C(\"a\"), goqu.C(\"b\"), nil),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT COALESCE(\"a\", 'a'), COALESCE(\"a\", \"b\", NULL) FROM \"test\" []\n\t// SELECT COALESCE(\"a\", ?), COALESCE(\"a\", \"b\", ?) FROM \"test\" [a <nil>]\n}\n\nfunc ExampleCOALESCE_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.COALESCE(goqu.C(\"a\"), \"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT COALESCE(\"a\", 'a') AS \"a\" FROM \"test\"\n}\n\nfunc ExampleCOUNT() {\n\tds := goqu.From(\"test\").Select(goqu.COUNT(\"*\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT COUNT(*) FROM \"test\" []\n\t// SELECT COUNT(*) FROM \"test\" []\n}\n\nfunc ExampleCOUNT_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.COUNT(\"*\").As(\"count\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT COUNT(*) AS \"count\" FROM \"test\"\n}\n\nfunc ExampleCOUNT_havingClause() {\n\tds := goqu.\n\t\tFrom(\"test\").\n\t\tSelect(goqu.COUNT(\"a\").As(\"COUNT\")).\n\t\tGroupBy(\"a\").\n\t\tHaving(goqu.COUNT(\"a\").Gt(10))\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT COUNT(\"a\") AS \"COUNT\" FROM \"test\" GROUP BY \"a\" HAVING (COUNT(\"a\") > 10) []\n\t// SELECT COUNT(\"a\") AS \"COUNT\" FROM \"test\" GROUP BY \"a\" HAVING (COUNT(\"a\") > ?) [10]\n}\n\nfunc ExampleCast() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tSelect(goqu.Cast(goqu.C(\"json1\"), \"TEXT\").As(\"json_text\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.Cast(goqu.C(\"json1\"), \"TEXT\").Neq(\n\t\t\tgoqu.Cast(goqu.C(\"json2\"), \"TEXT\"),\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT CAST(\"json1\" AS TEXT) AS \"json_text\" FROM \"test\"\n\t// SELECT * FROM \"test\" WHERE (CAST(\"json1\" AS TEXT) != CAST(\"json2\" AS TEXT))\n}\n\nfunc ExampleDISTINCT() {\n\tds := goqu.From(\"test\").Select(goqu.DISTINCT(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT DISTINCT(\"col\") FROM \"test\" []\n\t// SELECT DISTINCT(\"col\") FROM \"test\" []\n}\n\nfunc ExampleDISTINCT_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.DISTINCT(\"a\").As(\"distinct_a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT DISTINCT(\"a\") AS \"distinct_a\" FROM \"test\"\n}\n\nfunc ExampleDefault() {\n\tds := goqu.Insert(\"items\")\n\n\tsql, args, _ := ds.Rows(goqu.Record{\n\t\t\"name\":    goqu.Default(),\n\t\t\"address\": goqu.Default(),\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).Rows(goqu.Record{\n\t\t\"name\":    goqu.Default(),\n\t\t\"address\": goqu.Default(),\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (DEFAULT, DEFAULT) []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (DEFAULT, DEFAULT) []\n}\n\nfunc ExampleDoNothing() {\n\tds := goqu.Insert(\"items\")\n\n\tsql, args, _ := ds.Rows(goqu.Record{\n\t\t\"address\": \"111 Address\",\n\t\t\"name\":    \"bob\",\n\t}).OnConflict(goqu.DoNothing()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).Rows(goqu.Record{\n\t\t\"address\": \"111 Address\",\n\t\t\"name\":    \"bob\",\n\t}).OnConflict(goqu.DoNothing()).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Address', 'bob') ON CONFLICT DO NOTHING []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?) ON CONFLICT DO NOTHING [111 Address bob]\n}\n\nfunc ExampleDoUpdate() {\n\tds := goqu.Insert(\"items\")\n\n\tsql, args, _ := ds.\n\t\tRows(goqu.Record{\"address\": \"111 Address\"}).\n\t\tOnConflict(goqu.DoUpdate(\"address\", goqu.C(\"address\").Set(goqu.I(\"excluded.address\")))).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).\n\t\tRows(goqu.Record{\"address\": \"111 Address\"}).\n\t\tOnConflict(goqu.DoUpdate(\"address\", goqu.C(\"address\").Set(goqu.I(\"excluded.address\")))).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\") VALUES ('111 Address') ON CONFLICT (address) DO UPDATE SET \"address\"=\"excluded\".\"address\" []\n\t// INSERT INTO \"items\" (\"address\") VALUES (?) ON CONFLICT (address) DO UPDATE SET \"address\"=\"excluded\".\"address\" [111 Address]\n}\n\nfunc ExampleDoUpdate_where() {\n\tds := goqu.Insert(\"items\")\n\n\tsql, args, _ := ds.\n\t\tRows(goqu.Record{\"address\": \"111 Address\"}).\n\t\tOnConflict(goqu.DoUpdate(\n\t\t\t\"address\",\n\t\t\tgoqu.C(\"address\").Set(goqu.I(\"excluded.address\"))).Where(goqu.I(\"items.updated\").IsNull()),\n\t\t).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).\n\t\tRows(goqu.Record{\"address\": \"111 Address\"}).\n\t\tOnConflict(goqu.DoUpdate(\n\t\t\t\"address\",\n\t\t\tgoqu.C(\"address\").Set(goqu.I(\"excluded.address\"))).Where(goqu.I(\"items.updated\").IsNull()),\n\t\t).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\") VALUES ('111 Address') ON CONFLICT (address) DO UPDATE SET \"address\"=\"excluded\".\"address\" WHERE (\"items\".\"updated\" IS NULL) []\n\t// INSERT INTO \"items\" (\"address\") VALUES (?) ON CONFLICT (address) DO UPDATE SET \"address\"=\"excluded\".\"address\" WHERE (\"items\".\"updated\" IS NULL) [111 Address]\n}\n\nfunc ExampleFIRST() {\n\tds := goqu.From(\"test\").Select(goqu.FIRST(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT FIRST(\"col\") FROM \"test\" []\n\t// SELECT FIRST(\"col\") FROM \"test\" []\n}\n\nfunc ExampleFIRST_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.FIRST(\"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT FIRST(\"a\") AS \"a\" FROM \"test\"\n}\n\n// This example shows how to create custom SQL Functions\nfunc ExampleFunc() {\n\tstragg := func(expression exp.Expression, delimiter string) exp.SQLFunctionExpression {\n\t\treturn goqu.Func(\"str_agg\", expression, goqu.L(delimiter))\n\t}\n\tsql, _, _ := goqu.From(\"test\").Select(stragg(goqu.C(\"col\"), \"|\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT str_agg(\"col\", |) FROM \"test\"\n}\n\nfunc ExampleI() {\n\tds := goqu.From(\"test\").\n\t\tSelect(\n\t\t\tgoqu.I(\"my_schema.table.col1\"),\n\t\t\tgoqu.I(\"table.col2\"),\n\t\t\tgoqu.I(\"col3\"),\n\t\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Select(goqu.I(\"test.*\"))\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT \"my_schema\".\"table\".\"col1\", \"table\".\"col2\", \"col3\" FROM \"test\" []\n\t// SELECT \"my_schema\".\"table\".\"col1\", \"table\".\"col2\", \"col3\" FROM \"test\" []\n\t// SELECT \"test\".* FROM \"test\" []\n\t// SELECT \"test\".* FROM \"test\" []\n}\n\nfunc ExampleL() {\n\tds := goqu.From(\"test\").Where(\n\t\t// literal with no args\n\t\tgoqu.L(`\"col\"::TEXT = \"\"other_col\"::text`),\n\t\t// literal with args they will be interpolated into the sql by default\n\t\tgoqu.L(\"col IN (?, ?, ?)\", \"a\", \"b\", \"c\"),\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"col\"::TEXT = \"\"other_col\"::text AND col IN ('a', 'b', 'c')) []\n\t// SELECT * FROM \"test\" WHERE (\"col\"::TEXT = \"\"other_col\"::text AND col IN (?, ?, ?)) [a b c]\n}\n\nfunc ExampleL_withArgs() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.L(\n\t\t\t\"(? AND ?) OR ?\",\n\t\t\tgoqu.C(\"a\").Eq(1),\n\t\t\tgoqu.C(\"b\").Eq(\"b\"),\n\t\t\tgoqu.C(\"c\").In([]string{\"a\", \"b\", \"c\"}),\n\t\t),\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"a\" = 1) AND (\"b\" = 'b')) OR (\"c\" IN ('a', 'b', 'c')) []\n\t// SELECT * FROM \"test\" WHERE ((\"a\" = ?) AND (\"b\" = ?)) OR (\"c\" IN (?, ?, ?)) [1 b a b c]\n}\n\nfunc ExampleL_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.L(\"json_col->>'totalAmount'\").As(\"total_amount\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT json_col->>'totalAmount' AS \"total_amount\" FROM \"test\"\n}\n\nfunc ExampleL_comparisons() {\n\t// used from a literal expression\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.L(\"(a + b)\").Eq(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a + b)\").Neq(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a + b)\").Gt(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a + b)\").Gte(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a + b)\").Lt(10)).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a + b)\").Lte(10)).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((a + b) = 10)\n\t// SELECT * FROM \"test\" WHERE ((a + b) != 10)\n\t// SELECT * FROM \"test\" WHERE ((a + b) > 10)\n\t// SELECT * FROM \"test\" WHERE ((a + b) >= 10)\n\t// SELECT * FROM \"test\" WHERE ((a + b) < 10)\n\t// SELECT * FROM \"test\" WHERE ((a + b) <= 10)\n}\n\nfunc ExampleL_inOperators() {\n\t// using identifiers\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.L(\"json_col->>'val'\").In(\"a\", \"b\", \"c\")).ToSQL()\n\tfmt.Println(sql)\n\t// with a slice\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"json_col->>'val'\").In([]string{\"a\", \"b\", \"c\"})).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"json_col->>'val'\").NotIn(\"a\", \"b\", \"c\")).ToSQL()\n\tfmt.Println(sql)\n\t// with a slice\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"json_col->>'val'\").NotIn([]string{\"a\", \"b\", \"c\"})).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (json_col->>'val' IN ('a', 'b', 'c'))\n\t// SELECT * FROM \"test\" WHERE (json_col->>'val' IN ('a', 'b', 'c'))\n\t// SELECT * FROM \"test\" WHERE (json_col->>'val' NOT IN ('a', 'b', 'c'))\n\t// SELECT * FROM \"test\" WHERE (json_col->>'val' NOT IN ('a', 'b', 'c'))\n}\n\nfunc ExampleL_likeComparisons() {\n\t// using identifiers\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.L(\"(a::text || 'bar')\").Like(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.L(\"(a::text || 'bar')\").Like(regexp.MustCompile(\"[ab]\")),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a::text || 'bar')\").ILike(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.L(\"(a::text || 'bar')\").ILike(regexp.MustCompile(\"[ab]\")),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a::text || 'bar')\").NotLike(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.L(\"(a::text || 'bar')\").NotLike(regexp.MustCompile(\"[ab]\")),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.L(\"(a::text || 'bar')\").NotILike(\"%a%\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.L(\"(a::text || 'bar')\").NotILike(regexp.MustCompile(\"[ab]\")),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') LIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') ~ '[ab]')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') ILIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') ~* '[ab]')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') NOT LIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') !~ '[ab]')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') NOT ILIKE '%a%')\n\t// SELECT * FROM \"test\" WHERE ((a::text || 'bar') !~* '[ab]')\n}\n\nfunc ExampleL_isComparisons() {\n\tsql, args, _ := goqu.From(\"test\").Where(goqu.L(\"a\").Is(nil)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").Is(true)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").Is(false)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNull()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsTrue()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsFalse()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNot(nil)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNot(true)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNot(false)).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNotNull()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNotTrue()).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"test\").Where(goqu.L(\"a\").IsNotFalse()).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (a IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (a IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (a IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (a IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (a IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (a IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (a IS NOT NULL) []\n\t// SELECT * FROM \"test\" WHERE (a IS NOT TRUE) []\n\t// SELECT * FROM \"test\" WHERE (a IS NOT FALSE) []\n\t// SELECT * FROM \"test\" WHERE (a IS NOT NULL) []\n\t// SELECT * FROM \"test\" WHERE (a IS NOT TRUE) []\n\t// SELECT * FROM \"test\" WHERE (a IS NOT FALSE) []\n}\n\nfunc ExampleL_betweenComparisons() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.L(\"(a + b)\").Between(goqu.Range(1, 10)),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(\n\t\tgoqu.L(\"(a + b)\").NotBetween(goqu.Range(1, 10)),\n\t)\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((a + b) BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE ((a + b) BETWEEN ? AND ?) [1 10]\n\t// SELECT * FROM \"test\" WHERE ((a + b) NOT BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE ((a + b) NOT BETWEEN ? AND ?) [1 10]\n}\n\nfunc ExampleLAST() {\n\tds := goqu.From(\"test\").Select(goqu.LAST(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT LAST(\"col\") FROM \"test\" []\n\t// SELECT LAST(\"col\") FROM \"test\" []\n}\n\nfunc ExampleLAST_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.LAST(\"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT LAST(\"a\") AS \"a\" FROM \"test\"\n}\n\nfunc ExampleMAX() {\n\tds := goqu.From(\"test\").Select(goqu.MAX(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT MAX(\"col\") FROM \"test\" []\n\t// SELECT MAX(\"col\") FROM \"test\" []\n}\n\nfunc ExampleMAX_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.MAX(\"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT MAX(\"a\") AS \"a\" FROM \"test\"\n}\n\nfunc ExampleMAX_havingClause() {\n\tds := goqu.\n\t\tFrom(\"test\").\n\t\tSelect(goqu.MAX(\"a\").As(\"MAX\")).\n\t\tGroupBy(\"a\").\n\t\tHaving(goqu.MAX(\"a\").Gt(10))\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT MAX(\"a\") AS \"MAX\" FROM \"test\" GROUP BY \"a\" HAVING (MAX(\"a\") > 10) []\n\t// SELECT MAX(\"a\") AS \"MAX\" FROM \"test\" GROUP BY \"a\" HAVING (MAX(\"a\") > ?) [10]\n}\n\nfunc ExampleMIN() {\n\tds := goqu.From(\"test\").Select(goqu.MIN(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT MIN(\"col\") FROM \"test\" []\n\t// SELECT MIN(\"col\") FROM \"test\" []\n}\n\nfunc ExampleMIN_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.MIN(\"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT MIN(\"a\") AS \"a\" FROM \"test\"\n}\n\nfunc ExampleMIN_havingClause() {\n\tds := goqu.\n\t\tFrom(\"test\").\n\t\tSelect(goqu.MIN(\"a\").As(\"MIN\")).\n\t\tGroupBy(\"a\").\n\t\tHaving(goqu.MIN(\"a\").Gt(10))\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT MIN(\"a\") AS \"MIN\" FROM \"test\" GROUP BY \"a\" HAVING (MIN(\"a\") > 10) []\n\t// SELECT MIN(\"a\") AS \"MIN\" FROM \"test\" GROUP BY \"a\" HAVING (MIN(\"a\") > ?) [10]\n}\n\nfunc ExampleOn() {\n\tds := goqu.From(\"test\").Join(\n\t\tgoqu.T(\"my_table\"),\n\t\tgoqu.On(goqu.I(\"my_table.fkey\").Eq(goqu.I(\"other_table.id\"))),\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" ON (\"my_table\".\"fkey\" = \"other_table\".\"id\") []\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" ON (\"my_table\".\"fkey\" = \"other_table\".\"id\") []\n}\n\nfunc ExampleOn_withEx() {\n\tds := goqu.From(\"test\").Join(\n\t\tgoqu.T(\"my_table\"),\n\t\tgoqu.On(goqu.Ex{\"my_table.fkey\": goqu.I(\"other_table.id\")}),\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" ON (\"my_table\".\"fkey\" = \"other_table\".\"id\") []\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" ON (\"my_table\".\"fkey\" = \"other_table\".\"id\") []\n}\n\nfunc ExampleOr() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"col\").Eq(10),\n\t\t\tgoqu.C(\"col\").Eq(20),\n\t\t),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"col\" = 10) OR (\"col\" = 20)) []\n\t// SELECT * FROM \"test\" WHERE ((\"col\" = ?) OR (\"col\" = ?)) [10 20]\n}\n\nfunc ExampleOr_withAnd() {\n\tds := goqu.From(\"items\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Eq(100),\n\t\t\t\tgoqu.C(\"c\").Neq(\"test\"),\n\t\t\t),\n\t\t),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"a\" > 10) OR ((\"b\" = 100) AND (\"c\" != 'test'))) []\n\t// SELECT * FROM \"items\" WHERE ((\"a\" > ?) OR ((\"b\" = ?) AND (\"c\" != ?))) [10 100 test]\n}\n\nfunc ExampleOr_withExMap() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\t// Ex will be anded together\n\t\t\tgoqu.Ex{\n\t\t\t\t\"col1\": 1,\n\t\t\t\t\"col2\": true,\n\t\t\t},\n\t\t\tgoqu.Ex{\n\t\t\t\t\"col3\": nil,\n\t\t\t\t\"col4\": \"foo\",\n\t\t\t},\n\t\t),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (((\"col1\" = 1) AND (\"col2\" IS TRUE)) OR ((\"col3\" IS NULL) AND (\"col4\" = 'foo'))) []\n\t// SELECT * FROM \"test\" WHERE (((\"col1\" = ?) AND (\"col2\" IS TRUE)) OR ((\"col3\" IS NULL) AND (\"col4\" = ?))) [1 foo]\n}\n\nfunc ExampleRange_numbers() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col\").Between(goqu.Range(1, 10)),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col\").NotBetween(goqu.Range(1, 10)),\n\t)\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"col\" BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE (\"col\" BETWEEN ? AND ?) [1 10]\n\t// SELECT * FROM \"test\" WHERE (\"col\" NOT BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE (\"col\" NOT BETWEEN ? AND ?) [1 10]\n}\n\nfunc ExampleRange_strings() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col\").Between(goqu.Range(\"a\", \"z\")),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col\").NotBetween(goqu.Range(\"a\", \"z\")),\n\t)\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"col\" BETWEEN 'a' AND 'z') []\n\t// SELECT * FROM \"test\" WHERE (\"col\" BETWEEN ? AND ?) [a z]\n\t// SELECT * FROM \"test\" WHERE (\"col\" NOT BETWEEN 'a' AND 'z') []\n\t// SELECT * FROM \"test\" WHERE (\"col\" NOT BETWEEN ? AND ?) [a z]\n}\n\nfunc ExampleRange_identifiers() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col1\").Between(goqu.Range(goqu.C(\"col2\"), goqu.C(\"col3\"))),\n\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"col1\").NotBetween(goqu.Range(goqu.C(\"col2\"), goqu.C(\"col3\"))),\n\t)\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"col1\" BETWEEN \"col2\" AND \"col3\") []\n\t// SELECT * FROM \"test\" WHERE (\"col1\" BETWEEN \"col2\" AND \"col3\") []\n\t// SELECT * FROM \"test\" WHERE (\"col1\" NOT BETWEEN \"col2\" AND \"col3\") []\n\t// SELECT * FROM \"test\" WHERE (\"col1\" NOT BETWEEN \"col2\" AND \"col3\") []\n}\n\nfunc ExampleS() {\n\ts := goqu.S(\"test_schema\")\n\tt := s.Table(\"test\")\n\tsql, args, _ := goqu.\n\t\tFrom(t).\n\t\tSelect(\n\t\t\tt.Col(\"col1\"),\n\t\t\tt.Col(\"col2\"),\n\t\t\tt.Col(\"col3\"),\n\t\t).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT \"test_schema\".\"test\".\"col1\", \"test_schema\".\"test\".\"col2\", \"test_schema\".\"test\".\"col3\" FROM \"test_schema\".\"test\" []\n}\n\nfunc ExampleSUM() {\n\tds := goqu.From(\"test\").Select(goqu.SUM(\"col\"))\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT SUM(\"col\") FROM \"test\" []\n\t// SELECT SUM(\"col\") FROM \"test\" []\n}\n\nfunc ExampleSUM_as() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.SUM(\"a\").As(\"a\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT SUM(\"a\") AS \"a\" FROM \"test\"\n}\n\nfunc ExampleSUM_havingClause() {\n\tds := goqu.\n\t\tFrom(\"test\").\n\t\tSelect(goqu.SUM(\"a\").As(\"SUM\")).\n\t\tGroupBy(\"a\").\n\t\tHaving(goqu.SUM(\"a\").Gt(10))\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT SUM(\"a\") AS \"SUM\" FROM \"test\" GROUP BY \"a\" HAVING (SUM(\"a\") > 10) []\n\t// SELECT SUM(\"a\") AS \"SUM\" FROM \"test\" GROUP BY \"a\" HAVING (SUM(\"a\") > ?) [10]\n}\n\nfunc ExampleStar() {\n\tds := goqu.From(\"test\").Select(goqu.Star())\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" []\n\t// SELECT * FROM \"test\" []\n}\n\nfunc ExampleT() {\n\tt := goqu.T(\"test\")\n\tsql, args, _ := goqu.\n\t\tFrom(t).\n\t\tSelect(\n\t\t\tt.Col(\"col1\"),\n\t\t\tt.Col(\"col2\"),\n\t\t\tt.Col(\"col3\"),\n\t\t).\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT \"test\".\"col1\", \"test\".\"col2\", \"test\".\"col3\" FROM \"test\" []\n}\n\nfunc ExampleUsing() {\n\tds := goqu.From(\"test\").Join(\n\t\tgoqu.T(\"my_table\"),\n\t\tgoqu.Using(\"fkey\"),\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" USING (\"fkey\") []\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" USING (\"fkey\") []\n}\n\nfunc ExampleUsing_withIdentifier() {\n\tds := goqu.From(\"test\").Join(\n\t\tgoqu.T(\"my_table\"),\n\t\tgoqu.Using(goqu.C(\"fkey\")),\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" USING (\"fkey\") []\n\t// SELECT * FROM \"test\" INNER JOIN \"my_table\" USING (\"fkey\") []\n}\n\nfunc ExampleEx() {\n\tds := goqu.From(\"items\").Where(\n\t\tgoqu.Ex{\n\t\t\t\"col1\": \"a\",\n\t\t\t\"col2\": 1,\n\t\t\t\"col3\": true,\n\t\t\t\"col4\": false,\n\t\t\t\"col5\": nil,\n\t\t\t\"col6\": []string{\"a\", \"b\", \"c\"},\n\t\t},\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" = 'a') AND (\"col2\" = 1) AND (\"col3\" IS TRUE) AND (\"col4\" IS FALSE) AND (\"col5\" IS NULL) AND (\"col6\" IN ('a', 'b', 'c'))) []\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" = ?) AND (\"col2\" = ?) AND (\"col3\" IS TRUE) AND (\"col4\" IS FALSE) AND (\"col5\" IS NULL) AND (\"col6\" IN (?, ?, ?))) [a 1 a b c]\n}\n\nfunc ExampleEx_withOp() {\n\tsql, args, _ := goqu.From(\"items\").Where(\n\t\tgoqu.Ex{\n\t\t\t\"col1\": goqu.Op{\"neq\": \"a\"},\n\t\t\t\"col3\": goqu.Op{\"isNot\": true},\n\t\t\t\"col6\": goqu.Op{\"notIn\": []string{\"a\", \"b\", \"c\"}},\n\t\t},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" != 'a') AND (\"col3\" IS NOT TRUE) AND (\"col6\" NOT IN ('a', 'b', 'c'))) []\n}\n\nfunc ExampleEx_in() {\n\t// using an Ex expression map\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" IN ('a', 'b', 'c'))\n}\n\nfunc ExampleExOr() {\n\tsql, args, _ := goqu.From(\"items\").Where(\n\t\tgoqu.ExOr{\n\t\t\t\"col1\": \"a\",\n\t\t\t\"col2\": 1,\n\t\t\t\"col3\": true,\n\t\t\t\"col4\": false,\n\t\t\t\"col5\": nil,\n\t\t\t\"col6\": []string{\"a\", \"b\", \"c\"},\n\t\t},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" = 'a') OR (\"col2\" = 1) OR (\"col3\" IS TRUE) OR (\"col4\" IS FALSE) OR (\"col5\" IS NULL) OR (\"col6\" IN ('a', 'b', 'c'))) []\n}\n\nfunc ExampleExOr_withOp() {\n\tsql, _, _ := goqu.From(\"items\").Where(goqu.ExOr{\n\t\t\"col1\": goqu.Op{\"neq\": \"a\"},\n\t\t\"col3\": goqu.Op{\"isNot\": true},\n\t\t\"col6\": goqu.Op{\"notIn\": []string{\"a\", \"b\", \"c\"}},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"items\").Where(goqu.ExOr{\n\t\t\"col1\": goqu.Op{\"gt\": 1},\n\t\t\"col2\": goqu.Op{\"gte\": 1},\n\t\t\"col3\": goqu.Op{\"lt\": 1},\n\t\t\"col4\": goqu.Op{\"lte\": 1},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"items\").Where(goqu.ExOr{\n\t\t\"col1\": goqu.Op{\"like\": \"a%\"},\n\t\t\"col2\": goqu.Op{\"notLike\": \"a%\"},\n\t\t\"col3\": goqu.Op{\"iLike\": \"a%\"},\n\t\t\"col4\": goqu.Op{\"notILike\": \"a%\"},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"items\").Where(goqu.ExOr{\n\t\t\"col1\": goqu.Op{\"like\": regexp.MustCompile(\"^[ab]\")},\n\t\t\"col2\": goqu.Op{\"notLike\": regexp.MustCompile(\"^[ab]\")},\n\t\t\"col3\": goqu.Op{\"iLike\": regexp.MustCompile(\"^[ab]\")},\n\t\t\"col4\": goqu.Op{\"notILike\": regexp.MustCompile(\"^[ab]\")},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" != 'a') OR (\"col3\" IS NOT TRUE) OR (\"col6\" NOT IN ('a', 'b', 'c')))\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" > 1) OR (\"col2\" >= 1) OR (\"col3\" < 1) OR (\"col4\" <= 1))\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" LIKE 'a%') OR (\"col2\" NOT LIKE 'a%') OR (\"col3\" ILIKE 'a%') OR (\"col4\" NOT ILIKE 'a%'))\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" ~ '^[ab]') OR (\"col2\" !~ '^[ab]') OR (\"col3\" ~* '^[ab]') OR (\"col4\" !~* '^[ab]'))\n}\n\nfunc ExampleOp_comparisons() {\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": 10,\n\t\t\"b\": goqu.Op{\"neq\": 10},\n\t\t\"c\": goqu.Op{\"gte\": 10},\n\t\t\"d\": goqu.Op{\"lt\": 10},\n\t\t\"e\": goqu.Op{\"lte\": 10},\n\t})\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"a\" = 10) AND (\"b\" != 10) AND (\"c\" >= 10) AND (\"d\" < 10) AND (\"e\" <= 10)) []\n\t// SELECT * FROM \"test\" WHERE ((\"a\" = ?) AND (\"b\" != ?) AND (\"c\" >= ?) AND (\"d\" < ?) AND (\"e\" <= ?)) [10 10 10 10 10]\n}\n\nfunc ExampleOp_inComparisons() {\n\t// using an Ex expression map\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"in\": []string{\"a\", \"b\", \"c\"}},\n\t})\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"notIn\": []string{\"a\", \"b\", \"c\"}},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" IN ('a', 'b', 'c')) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IN (?, ?, ?)) [a b c]\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT IN ('a', 'b', 'c')) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT IN (?, ?, ?)) [a b c]\n}\n\nfunc ExampleOp_likeComparisons() {\n\t// using an Ex expression map\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"like\": \"%a%\"},\n\t})\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"like\": regexp.MustCompile(\"[ab]\")},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"iLike\": \"%a%\"},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"iLike\": regexp.MustCompile(\"[ab]\")},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"notLike\": \"%a%\"},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"notLike\": regexp.MustCompile(\"[ab]\")},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"notILike\": \"%a%\"},\n\t})\n\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"notILike\": regexp.MustCompile(\"[ab]\")},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" LIKE '%a%') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" LIKE ?) [%a%]\n\t// SELECT * FROM \"test\" WHERE (\"a\" ~ '[ab]') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" ~ ?) [[ab]]\n\t// SELECT * FROM \"test\" WHERE (\"a\" ILIKE '%a%') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" ILIKE ?) [%a%]\n\t// SELECT * FROM \"test\" WHERE (\"a\" ~* '[ab]') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" ~* ?) [[ab]]\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT LIKE '%a%') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT LIKE ?) [%a%]\n\t// SELECT * FROM \"test\" WHERE (\"a\" !~ '[ab]') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" !~ ?) [[ab]]\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT ILIKE '%a%') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT ILIKE ?) [%a%]\n\t// SELECT * FROM \"test\" WHERE (\"a\" !~* '[ab]') []\n\t// SELECT * FROM \"test\" WHERE (\"a\" !~* ?) [[ab]]\n}\n\nfunc ExampleOp_isComparisons() {\n\t// using an Ex expression map\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": true,\n\t})\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"is\": true},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": false,\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"is\": false},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": nil,\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"is\": nil},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"isNot\": true},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"isNot\": false},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"isNot\": nil},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT TRUE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT FALSE) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT NULL) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" IS NOT NULL) []\n}\n\nfunc ExampleOp_betweenComparisons() {\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"between\": goqu.Range(1, 10)},\n\t})\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"notBetween\": goqu.Range(1, 10)},\n\t})\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"a\" BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" BETWEEN ? AND ?) [1 10]\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT BETWEEN 1 AND 10) []\n\t// SELECT * FROM \"test\" WHERE (\"a\" NOT BETWEEN ? AND ?) [1 10]\n}\n\n// When using a single op with multiple keys they are ORed together\nfunc ExampleOp_withMultipleKeys() {\n\tds := goqu.From(\"items\").Where(goqu.Ex{\n\t\t\"col1\": goqu.Op{\"is\": nil, \"eq\": 10},\n\t})\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" = 10) OR (\"col1\" IS NULL)) []\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" = ?) OR (\"col1\" IS NULL)) [10]\n}\n\nfunc ExampleRecord_insert() {\n\tds := goqu.Insert(\"test\")\n\n\trecords := []goqu.Record{\n\t\t{\"col1\": 1, \"col2\": \"foo\"},\n\t\t{\"col1\": 2, \"col2\": \"bar\"},\n\t}\n\n\tsql, args, _ := ds.Rows(records).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).Rows(records).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// INSERT INTO \"test\" (\"col1\", \"col2\") VALUES (1, 'foo'), (2, 'bar') []\n\t// INSERT INTO \"test\" (\"col1\", \"col2\") VALUES (?, ?), (?, ?) [1 foo 2 bar]\n}\n\nfunc ExampleRecord_update() {\n\tds := goqu.Update(\"test\")\n\tupdate := goqu.Record{\"col1\": 1, \"col2\": \"foo\"}\n\n\tsql, args, _ := ds.Set(update).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).Set(update).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// UPDATE \"test\" SET \"col1\"=1,\"col2\"='foo' []\n\t// UPDATE \"test\" SET \"col1\"=?,\"col2\"=? [1 foo]\n}\n\nfunc ExampleV() {\n\tds := goqu.From(\"user\").Select(\n\t\tgoqu.V(true).As(\"is_verified\"),\n\t\tgoqu.V(1.2).As(\"version\"),\n\t\t\"first_name\",\n\t\t\"last_name\",\n\t)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"user\").Where(goqu.V(1).Neq(1))\n\tsql, args, _ = ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT TRUE AS \"is_verified\", 1.2 AS \"version\", \"first_name\", \"last_name\" FROM \"user\" []\n\t// SELECT * FROM \"user\" WHERE (1 != 1) []\n}\n\nfunc ExampleV_prepared() {\n\tds := goqu.From(\"user\").Select(\n\t\tgoqu.V(true).As(\"is_verified\"),\n\t\tgoqu.V(1.2).As(\"version\"),\n\t\t\"first_name\",\n\t\t\"last_name\",\n\t)\n\n\tsql, args, _ := ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\tds = goqu.From(\"user\").Where(goqu.V(1).Neq(1))\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT ? AS \"is_verified\", ? AS \"version\", \"first_name\", \"last_name\" FROM \"user\" [true 1.2]\n\t// SELECT * FROM \"user\" WHERE (? != ?) [1 1]\n}\n\nfunc ExampleVals() {\n\tds := goqu.Insert(\"user\").\n\t\tCols(\"first_name\", \"last_name\", \"is_verified\").\n\t\tVals(\n\t\t\tgoqu.Vals{\"Greg\", \"Farley\", true},\n\t\t\tgoqu.Vals{\"Jimmy\", \"Stewart\", true},\n\t\t\tgoqu.Vals{\"Jeff\", \"Jeffers\", false},\n\t\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\", \"is_verified\") VALUES ('Greg', 'Farley', TRUE), ('Jimmy', 'Stewart', TRUE), ('Jeff', 'Jeffers', FALSE) []\n}\n\nfunc ExampleW() {\n\tds := goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().Over(goqu.W().PartitionBy(\"a\").OrderBy(goqu.I(\"b\").Asc())))\n\tquery, args, _ := ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tds = goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().OverName(goqu.I(\"w\"))).\n\t\tWindow(goqu.W(\"w\").PartitionBy(\"a\").OrderBy(goqu.I(\"b\").Asc()))\n\tquery, args, _ = ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tds = goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().OverName(goqu.I(\"w1\"))).\n\t\tWindow(\n\t\t\tgoqu.W(\"w1\").PartitionBy(\"a\"),\n\t\t\tgoqu.W(\"w\").Inherit(\"w1\").OrderBy(goqu.I(\"b\").Asc()),\n\t\t)\n\tquery, args, _ = ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tds = goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().Over(goqu.W().Inherit(\"w\").OrderBy(\"b\"))).\n\t\tWindow(goqu.W(\"w\").PartitionBy(\"a\"))\n\tquery, args, _ = ds.ToSQL()\n\tfmt.Println(query, args)\n\t// Output:\n\t// SELECT ROW_NUMBER() OVER (PARTITION BY \"a\" ORDER BY \"b\" ASC) FROM \"test\" []\n\t// SELECT ROW_NUMBER() OVER \"w\" FROM \"test\" WINDOW \"w\" AS (PARTITION BY \"a\" ORDER BY \"b\" ASC) []\n\t// SELECT ROW_NUMBER() OVER \"w1\" FROM \"test\" WINDOW \"w1\" AS (PARTITION BY \"a\"), \"w\" AS (\"w1\" ORDER BY \"b\" ASC) []\n\t// SELECT ROW_NUMBER() OVER (\"w\" ORDER BY \"b\") FROM \"test\" WINDOW \"w\" AS (PARTITION BY \"a\") []\n}\n\nfunc ExampleLateral() {\n\tmaxEntry := goqu.From(\"entry\").\n\t\tSelect(goqu.MAX(\"int\").As(\"max_int\")).\n\t\tWhere(goqu.Ex{\"time\": goqu.Op{\"lt\": goqu.I(\"e.time\")}}).\n\t\tAs(\"max_entry\")\n\n\tmaxID := goqu.From(\"entry\").\n\t\tSelect(\"id\").\n\t\tWhere(goqu.Ex{\"int\": goqu.I(\"max_entry.max_int\")}).\n\t\tAs(\"max_id\")\n\n\tds := goqu.\n\t\tSelect(\"e.id\", \"max_entry.max_int\", \"max_id.id\").\n\t\tFrom(\n\t\t\tgoqu.T(\"entry\").As(\"e\"),\n\t\t\tgoqu.Lateral(maxEntry),\n\t\t\tgoqu.Lateral(maxID),\n\t\t)\n\tquery, args, _ := ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tquery, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(query, args)\n\n\t// Output:\n\t// SELECT \"e\".\"id\", \"max_entry\".\"max_int\", \"max_id\".\"id\" FROM \"entry\" AS \"e\", LATERAL (SELECT MAX(\"int\") AS \"max_int\" FROM \"entry\" WHERE (\"time\" < \"e\".\"time\")) AS \"max_entry\", LATERAL (SELECT \"id\" FROM \"entry\" WHERE (\"int\" = \"max_entry\".\"max_int\")) AS \"max_id\" []\n\t// SELECT \"e\".\"id\", \"max_entry\".\"max_int\", \"max_id\".\"id\" FROM \"entry\" AS \"e\", LATERAL (SELECT MAX(\"int\") AS \"max_int\" FROM \"entry\" WHERE (\"time\" < \"e\".\"time\")) AS \"max_entry\", LATERAL (SELECT \"id\" FROM \"entry\" WHERE (\"int\" = \"max_entry\".\"max_int\")) AS \"max_id\" []\n}\n\nfunc ExampleLateral_join() {\n\tmaxEntry := goqu.From(\"entry\").\n\t\tSelect(goqu.MAX(\"int\").As(\"max_int\")).\n\t\tWhere(goqu.Ex{\"time\": goqu.Op{\"lt\": goqu.I(\"e.time\")}}).\n\t\tAs(\"max_entry\")\n\n\tmaxID := goqu.From(\"entry\").\n\t\tSelect(\"id\").\n\t\tWhere(goqu.Ex{\"int\": goqu.I(\"max_entry.max_int\")}).\n\t\tAs(\"max_id\")\n\n\tds := goqu.\n\t\tSelect(\"e.id\", \"max_entry.max_int\", \"max_id.id\").\n\t\tFrom(goqu.T(\"entry\").As(\"e\")).\n\t\tJoin(goqu.Lateral(maxEntry), goqu.On(goqu.V(true))).\n\t\tJoin(goqu.Lateral(maxID), goqu.On(goqu.V(true)))\n\tquery, args, _ := ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tquery, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(query, args)\n\n\t// Output:\n\t// SELECT \"e\".\"id\", \"max_entry\".\"max_int\", \"max_id\".\"id\" FROM \"entry\" AS \"e\" INNER JOIN LATERAL (SELECT MAX(\"int\") AS \"max_int\" FROM \"entry\" WHERE (\"time\" < \"e\".\"time\")) AS \"max_entry\" ON TRUE INNER JOIN LATERAL (SELECT \"id\" FROM \"entry\" WHERE (\"int\" = \"max_entry\".\"max_int\")) AS \"max_id\" ON TRUE []\n\t// SELECT \"e\".\"id\", \"max_entry\".\"max_int\", \"max_id\".\"id\" FROM \"entry\" AS \"e\" INNER JOIN LATERAL (SELECT MAX(\"int\") AS \"max_int\" FROM \"entry\" WHERE (\"time\" < \"e\".\"time\")) AS \"max_entry\" ON ? INNER JOIN LATERAL (SELECT \"id\" FROM \"entry\" WHERE (\"int\" = \"max_entry\".\"max_int\")) AS \"max_id\" ON ? [true true]\n}\n\nfunc ExampleAny() {\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"id\": goqu.Any(goqu.From(\"other\").Select(\"test_id\")),\n\t})\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"id\" = ANY ((SELECT \"test_id\" FROM \"other\"))) []\n\t// SELECT * FROM \"test\" WHERE (\"id\" = ANY ((SELECT \"test_id\" FROM \"other\"))) []\n}\n\nfunc ExampleAll() {\n\tds := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"id\": goqu.All(goqu.From(\"other\").Select(\"test_id\")),\n\t})\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE (\"id\" = ALL ((SELECT \"test_id\" FROM \"other\"))) []\n\t// SELECT * FROM \"test\" WHERE (\"id\" = ALL ((SELECT \"test_id\" FROM \"other\"))) []\n}\n\nfunc ExampleCase_search() {\n\tds := goqu.From(\"test\").\n\t\tSelect(\n\t\t\tgoqu.C(\"col\"),\n\t\t\tgoqu.Case().\n\t\t\t\tWhen(goqu.C(\"col\").Gt(0), true).\n\t\t\t\tWhen(goqu.C(\"col\").Lte(0), false).\n\t\t\t\tAs(\"is_gt_zero\"),\n\t\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT \"col\", CASE  WHEN (\"col\" > 0) THEN TRUE WHEN (\"col\" <= 0) THEN FALSE END AS \"is_gt_zero\" FROM \"test\" []\n\t// SELECT \"col\", CASE  WHEN (\"col\" > ?) THEN ? WHEN (\"col\" <= ?) THEN ? END AS \"is_gt_zero\" FROM \"test\" [0 true 0 false]\n}\n\nfunc ExampleCase_searchElse() {\n\tds := goqu.From(\"test\").\n\t\tSelect(\n\t\t\tgoqu.C(\"col\"),\n\t\t\tgoqu.Case().\n\t\t\t\tWhen(goqu.C(\"col\").Gt(10), \"Gt 10\").\n\t\t\t\tWhen(goqu.C(\"col\").Gt(20), \"Gt 20\").\n\t\t\t\tElse(\"Bad Val\").\n\t\t\t\tAs(\"str_val\"),\n\t\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT \"col\", CASE  WHEN (\"col\" > 10) THEN 'Gt 10' WHEN (\"col\" > 20) THEN 'Gt 20' ELSE 'Bad Val' END AS \"str_val\" FROM \"test\" []\n\t// SELECT \"col\", CASE  WHEN (\"col\" > ?) THEN ? WHEN (\"col\" > ?) THEN ? ELSE ? END AS \"str_val\" FROM \"test\" [10 Gt 10 20 Gt 20 Bad Val]\n}\n\nfunc ExampleCase_value() {\n\tds := goqu.From(\"test\").\n\t\tSelect(\n\t\t\tgoqu.C(\"col\"),\n\t\t\tgoqu.Case().\n\t\t\t\tValue(goqu.C(\"str\")).\n\t\t\t\tWhen(\"foo\", \"FOO\").\n\t\t\t\tWhen(\"bar\", \"BAR\").\n\t\t\t\tAs(\"foo_bar_upper\"),\n\t\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT \"col\", CASE \"str\" WHEN 'foo' THEN 'FOO' WHEN 'bar' THEN 'BAR' END AS \"foo_bar_upper\" FROM \"test\" []\n\t// SELECT \"col\", CASE \"str\" WHEN ? THEN ? WHEN ? THEN ? END AS \"foo_bar_upper\" FROM \"test\" [foo FOO bar BAR]\n}\n\nfunc ExampleCase_valueElse() {\n\tds := goqu.From(\"test\").\n\t\tSelect(\n\t\t\tgoqu.C(\"col\"),\n\t\t\tgoqu.Case().\n\t\t\t\tValue(goqu.C(\"str\")).\n\t\t\t\tWhen(\"foo\", \"FOO\").\n\t\t\t\tWhen(\"bar\", \"BAR\").\n\t\t\t\tElse(\"Baz\").\n\t\t\t\tAs(\"foo_bar_upper\"),\n\t\t)\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT \"col\", CASE \"str\" WHEN 'foo' THEN 'FOO' WHEN 'bar' THEN 'BAR' ELSE 'Baz' END AS \"foo_bar_upper\" FROM \"test\" []\n\t// SELECT \"col\", CASE \"str\" WHEN ? THEN ? WHEN ? THEN ? ELSE ? END AS \"foo_bar_upper\" FROM \"test\" [foo FOO bar BAR Baz]\n}\n"
        },
        {
          "name": "expressions_test.go",
          "type": "blob",
          "size": 5.794921875,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\tgoquExpressionsSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (ges *goquExpressionsSuite) TestCast() {\n\tges.Equal(exp.NewCastExpression(goqu.C(\"test\"), \"string\"), goqu.Cast(goqu.C(\"test\"), \"string\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestDoNothing() {\n\tges.Equal(exp.NewDoNothingConflictExpression(), goqu.DoNothing())\n}\n\nfunc (ges *goquExpressionsSuite) TestDoUpdate() {\n\tges.Equal(exp.NewDoUpdateConflictExpression(\"test\", goqu.Record{\"a\": \"b\"}), goqu.DoUpdate(\"test\", goqu.Record{\"a\": \"b\"}))\n}\n\nfunc (ges *goquExpressionsSuite) TestOr() {\n\te1 := goqu.C(\"a\").Eq(\"b\")\n\te2 := goqu.C(\"b\").Eq(2)\n\tges.Equal(exp.NewExpressionList(exp.OrType, e1, e2), goqu.Or(e1, e2))\n}\n\nfunc (ges *goquExpressionsSuite) TestAnd() {\n\te1 := goqu.C(\"a\").Eq(\"b\")\n\te2 := goqu.C(\"b\").Eq(2)\n\tges.Equal(exp.NewExpressionList(exp.AndType, e1, e2), goqu.And(e1, e2))\n}\n\nfunc (ges *goquExpressionsSuite) TestFunc() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"count\", goqu.L(\"*\")), goqu.Func(\"count\", goqu.L(\"*\")))\n}\n\nfunc (ges *goquExpressionsSuite) TestDISTINCT() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"DISTINCT\", goqu.I(\"col\")), goqu.DISTINCT(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestCOUNT() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"COUNT\", goqu.I(\"col\")), goqu.COUNT(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestMIN() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"MIN\", goqu.I(\"col\")), goqu.MIN(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestMAX() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"MAX\", goqu.I(\"col\")), goqu.MAX(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestAVG() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"AVG\", goqu.I(\"col\")), goqu.AVG(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestFIRST() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"FIRST\", goqu.I(\"col\")), goqu.FIRST(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestLAST() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"LAST\", goqu.I(\"col\")), goqu.LAST(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestSUM() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"SUM\", goqu.I(\"col\")), goqu.SUM(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestCOALESCE() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"COALESCE\", goqu.I(\"col\"), nil), goqu.COALESCE(goqu.I(\"col\"), nil))\n}\n\nfunc (ges *goquExpressionsSuite) TestROW_NUMBER() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"ROW_NUMBER\"), goqu.ROW_NUMBER())\n}\n\nfunc (ges *goquExpressionsSuite) TestRANK() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"RANK\"), goqu.RANK())\n}\n\nfunc (ges *goquExpressionsSuite) TestDENSE_RANK() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"DENSE_RANK\"), goqu.DENSE_RANK())\n}\n\nfunc (ges *goquExpressionsSuite) TestPERCENT_RANK() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"PERCENT_RANK\"), goqu.PERCENT_RANK())\n}\n\nfunc (ges *goquExpressionsSuite) TestCUME_DIST() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"CUME_DIST\"), goqu.CUME_DIST())\n}\n\nfunc (ges *goquExpressionsSuite) TestNTILE() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"NTILE\", 1), goqu.NTILE(1))\n}\n\nfunc (ges *goquExpressionsSuite) TestFIRST_VALUE() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"FIRST_VALUE\", goqu.I(\"col\")), goqu.FIRST_VALUE(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestLAST_VALUE() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"LAST_VALUE\", goqu.I(\"col\")), goqu.LAST_VALUE(\"col\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestNTH_VALUE() {\n\tges.Equal(exp.NewSQLFunctionExpression(\"NTH_VALUE\", goqu.I(\"col\"), 1), goqu.NTH_VALUE(\"col\", 1))\n\tges.Equal(exp.NewSQLFunctionExpression(\"NTH_VALUE\", goqu.I(\"col\"), 1), goqu.NTH_VALUE(goqu.C(\"col\"), 1))\n}\n\nfunc (ges *goquExpressionsSuite) TestI() {\n\tges.Equal(exp.NewIdentifierExpression(\"s\", \"t\", \"c\"), goqu.I(\"s.t.c\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestC() {\n\tges.Equal(exp.NewIdentifierExpression(\"\", \"\", \"c\"), goqu.C(\"c\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestS() {\n\tges.Equal(exp.NewIdentifierExpression(\"s\", \"\", \"\"), goqu.S(\"s\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestT() {\n\tges.Equal(exp.NewIdentifierExpression(\"\", \"t\", \"\"), goqu.T(\"t\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestW() {\n\tges.Equal(exp.NewWindowExpression(nil, nil, nil, nil), goqu.W())\n\tges.Equal(exp.NewWindowExpression(goqu.I(\"a\"), nil, nil, nil), goqu.W(\"a\"))\n\tges.Equal(exp.NewWindowExpression(goqu.I(\"a\"), goqu.I(\"b\"), nil, nil), goqu.W(\"a\", \"b\"))\n\tges.Equal(exp.NewWindowExpression(goqu.I(\"a\"), goqu.I(\"b\"), nil, nil), goqu.W(\"a\", \"b\", \"c\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestOn() {\n\tges.Equal(exp.NewJoinOnCondition(goqu.Ex{\"a\": \"b\"}), goqu.On(goqu.Ex{\"a\": \"b\"}))\n}\n\nfunc (ges *goquExpressionsSuite) TestUsing() {\n\tges.Equal(exp.NewJoinUsingCondition(\"a\", \"b\"), goqu.Using(\"a\", \"b\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestL() {\n\tges.Equal(exp.NewLiteralExpression(\"? + ?\", 1, 2), goqu.L(\"? + ?\", 1, 2))\n}\n\nfunc (ges *goquExpressionsSuite) TestLiteral() {\n\tges.Equal(exp.NewLiteralExpression(\"? + ?\", 1, 2), goqu.Literal(\"? + ?\", 1, 2))\n}\n\nfunc (ges *goquExpressionsSuite) TestV() {\n\tges.Equal(exp.NewLiteralExpression(\"?\", \"a\"), goqu.V(\"a\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestRange() {\n\tges.Equal(exp.NewRangeVal(\"a\", \"b\"), goqu.Range(\"a\", \"b\"))\n}\n\nfunc (ges *goquExpressionsSuite) TestStar() {\n\tges.Equal(exp.NewLiteralExpression(\"*\"), goqu.Star())\n}\n\nfunc (ges *goquExpressionsSuite) TestDefault() {\n\tges.Equal(exp.Default(), goqu.Default())\n}\n\nfunc (ges *goquExpressionsSuite) TestLateral() {\n\tds := goqu.From(\"test\")\n\tges.Equal(exp.NewLateralExpression(ds), goqu.Lateral(ds))\n}\n\nfunc (ges *goquExpressionsSuite) TestAny() {\n\tds := goqu.From(\"test\").Select(\"id\")\n\tges.Equal(exp.NewSQLFunctionExpression(\"ANY \", ds), goqu.Any(ds))\n}\n\nfunc (ges *goquExpressionsSuite) TestAll() {\n\tds := goqu.From(\"test\").Select(\"id\")\n\tges.Equal(exp.NewSQLFunctionExpression(\"ALL \", ds), goqu.All(ds))\n}\n\nfunc TestGoquExpressions(t *testing.T) {\n\tsuite.Run(t, new(goquExpressionsSuite))\n}\n"
        },
        {
          "name": "go.coverage.sh",
          "type": "blob",
          "size": 0.10546875,
          "content": "#!/usr/bin/env bash\n\nset -e\necho \"\" > coverage.txt\n\ngo test -coverprofile=coverage.txt -coverpkg=./... ./..."
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6240234375,
          "content": "module github.com/doug-martin/goqu/v9\n\ngo 1.19\n\nrequire (\n\tgithub.com/DATA-DOG/go-sqlmock v1.5.0\n\tgithub.com/denisenkom/go-mssqldb v0.12.3\n\tgithub.com/go-sql-driver/mysql v1.7.1\n\tgithub.com/lib/pq v1.10.9\n\tgithub.com/mattn/go-sqlite3 v1.14.17\n\tgithub.com/stretchr/testify v1.8.4\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 // indirect\n\tgithub.com/golang-sql/sqlexp v0.1.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/stretchr/objx v0.5.0 // indirect\n\tgolang.org/x/crypto v0.11.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.583984375,
          "content": "github.com/Azure/azure-sdk-for-go/sdk/azcore v0.19.0/go.mod h1:h6H6c8enJmmocHUbLiiGY6sx7f9i+X3m1CHdd5c6Rdw=\ngithub.com/Azure/azure-sdk-for-go/sdk/azidentity v0.11.0/go.mod h1:HcM1YX14R7CJcghJGOYCgdezslRSVzqwLf/q+4Y2r/0=\ngithub.com/Azure/azure-sdk-for-go/sdk/internal v0.7.0/go.mod h1:yqy467j36fJxcRV2TzfVZ1pCb5vxm4BtZPUdYWe/Xo8=\ngithub.com/DATA-DOG/go-sqlmock v1.5.0 h1:Shsta01QNfFxHCfpW6YH2STWB0MudeXXEWMr20OEh60=\ngithub.com/DATA-DOG/go-sqlmock v1.5.0/go.mod h1:f/Ixk793poVmq4qj/V1dPUg2JEAKC73Q5eFN3EC/SaM=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/denisenkom/go-mssqldb v0.12.3 h1:pBSGx9Tq67pBOTLmxNuirNTeB8Vjmf886Kx+8Y+8shw=\ngithub.com/denisenkom/go-mssqldb v0.12.3/go.mod h1:k0mtMFOnU+AihqFxPMiF05rtiDrorD1Vrm1KEz5hxDo=\ngithub.com/dnaeon/go-vcr v1.2.0/go.mod h1:R4UdLID7HZT3taECzJs4YgbbH6PIGXB6W/sc5OLb6RQ=\ngithub.com/go-sql-driver/mysql v1.7.1 h1:lUIinVbN1DY0xBg0eMOzmmtGoHwWBbvnWubQUrtU8EI=\ngithub.com/go-sql-driver/mysql v1.7.1/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=\ngithub.com/golang-sql/civil v0.0.0-20190719163853-cb61b32ac6fe/go.mod h1:8vg3r2VgvsThLBIFL93Qb5yWzgyZWhEmBwUJWevAkK0=\ngithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 h1:au07oEsX2xN0ktxqI+Sida1w446QrXBRJ0nee3SNZlA=\ngithub.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9/go.mod h1:8vg3r2VgvsThLBIFL93Qb5yWzgyZWhEmBwUJWevAkK0=\ngithub.com/golang-sql/sqlexp v0.1.0 h1:ZCD6MBpcuOVfGVqsEmY5/4FtYiKz6tSyUv9LPEDei6A=\ngithub.com/golang-sql/sqlexp v0.1.0/go.mod h1:J4ad9Vo8ZCWQ2GMrC4UCQy1JpCbwU9m3EOqtpKwwwHI=\ngithub.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=\ngithub.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/mattn/go-sqlite3 v1.14.17 h1:mCRHCLDUBXgpKAqIKsaAaAsrAlbkeomtRFKXh2L6YIM=\ngithub.com/mattn/go-sqlite3 v1.14.17/go.mod h1:2eHXhiwb8IkHr+BDWZGa96P6+rkvnG63S2DGjv9HUNg=\ngithub.com/modocache/gover v0.0.0-20171022184752-b58185e213c5/go.mod h1:caMODM3PzxT8aQXRPkAt8xlV/e7d7w8GM5g0fa5F0D8=\ngithub.com/pkg/browser v0.0.0-20180916011732-0a3d74bf9ce4/go.mod h1:4OwLy04Bl9Ef3GJJCoec+30X3LQs/0/m4HFRt/2LUSA=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0 h1:1zr/of2m5FGMsad5YfcqgdqdWrIhu+EBEJRhR1U7z/c=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\ngolang.org/x/crypto v0.11.0 h1:6Ewdq3tDic1mg5xRO4milcWCfMVQhI4NkqWWvqejpuA=\ngolang.org/x/crypto v0.11.0/go.mod h1:xgJhtzW8F9jGdVFWZESrid1U1bjeNy4zgy5cRr/CIio=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20210610132358-84b48f89b13b/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "go.test.sh",
          "type": "blob",
          "size": 0.072265625,
          "content": "#!/usr/bin/env bash\n\nset -e\necho \"\" > coverage.txt\n\ngo test -v -race ./..."
        },
        {
          "name": "goqu.go",
          "type": "blob",
          "size": 2.6748046875,
          "content": "/*\ngoqu an idiomatch SQL builder, and query package.\n\n\t  __ _  ___   __ _ _   _\n\t / _` |/ _ \\ / _` | | | |\n\t| (_| | (_) | (_| | |_| |\n\t \\__, |\\___/ \\__, |\\__,_|\n\t |___/          |_|\n\nPlease see https://github.com/doug-martin/goqu for an introduction to goqu.\n*/\npackage goqu\n\nimport (\n\t\"time\"\n\n\t\"github.com/doug-martin/goqu/v9/internal/util\"\n\t\"github.com/doug-martin/goqu/v9/sqlgen\"\n)\n\ntype DialectWrapper struct {\n\tdialect string\n}\n\n// Creates a new DialectWrapper to create goqu.Datasets or goqu.Databases with the specified dialect.\nfunc Dialect(dialect string) DialectWrapper {\n\treturn DialectWrapper{dialect: dialect}\n}\n\n// Create a new dataset for creating SELECT sql statements\nfunc (dw DialectWrapper) From(table ...interface{}) *SelectDataset {\n\treturn From(table...).WithDialect(dw.dialect)\n}\n\n// Create a new dataset for creating SELECT sql statements\nfunc (dw DialectWrapper) Select(cols ...interface{}) *SelectDataset {\n\treturn newDataset(dw.dialect, nil).Select(cols...)\n}\n\n// Create a new dataset for creating UPDATE sql statements\nfunc (dw DialectWrapper) Update(table interface{}) *UpdateDataset {\n\treturn Update(table).WithDialect(dw.dialect)\n}\n\n// Create a new dataset for creating INSERT sql statements\nfunc (dw DialectWrapper) Insert(table interface{}) *InsertDataset {\n\treturn Insert(table).WithDialect(dw.dialect)\n}\n\n// Create a new dataset for creating DELETE sql statements\nfunc (dw DialectWrapper) Delete(table interface{}) *DeleteDataset {\n\treturn Delete(table).WithDialect(dw.dialect)\n}\n\n// Create a new dataset for creating TRUNCATE sql statements\nfunc (dw DialectWrapper) Truncate(table ...interface{}) *TruncateDataset {\n\treturn Truncate(table...).WithDialect(dw.dialect)\n}\n\nfunc (dw DialectWrapper) DB(db SQLDatabase) *Database {\n\treturn newDatabase(dw.dialect, db)\n}\n\nfunc New(dialect string, db SQLDatabase) *Database {\n\treturn newDatabase(dialect, db)\n}\n\n// Set the behavior when encountering struct fields that do not have a db tag.\n// By default this is false; if set to true any field without a db tag will not\n// be targeted by Select or Scan operations.\nfunc SetIgnoreUntaggedFields(ignore bool) {\n\tutil.SetIgnoreUntaggedFields(ignore)\n}\n\n// Set the column rename function. This is used for struct fields that do not have a db tag to specify the column name\n// By default all struct fields that do not have a db tag will be converted lowercase\nfunc SetColumnRenameFunction(renameFunc func(string) string) {\n\tutil.SetColumnRenameFunction(renameFunc)\n}\n\n// Set the location to use when interpolating time.Time instances. See https://golang.org/pkg/time/#LoadLocation\n// NOTE: This has no effect when using prepared statements.\nfunc SetTimeLocation(loc *time.Location) {\n\tsqlgen.SetTimeLocation(loc)\n}\n"
        },
        {
          "name": "goqu_example_test.go",
          "type": "blob",
          "size": 6.8662109375,
          "content": "package goqu_test\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t_ \"github.com/doug-martin/goqu/v9/dialect/mysql\"\n\t_ \"github.com/doug-martin/goqu/v9/dialect/postgres\"\n\t_ \"github.com/doug-martin/goqu/v9/dialect/sqlite3\"\n)\n\n// Creating a mysql dataset. Be sure to import the mysql adapter.\nfunc ExampleDialect_datasetMysql() {\n\t// import _ \"github.com/doug-martin/goqu/v9/dialect/mysql\"\n\n\td := goqu.Dialect(\"mysql\")\n\tds := d.From(\"test\").Where(goqu.Ex{\n\t\t\"foo\": \"bar\",\n\t\t\"baz\": []int64{1, 2, 3},\n\t}).Limit(10)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM `test` WHERE ((`baz` IN (1, 2, 3)) AND (`foo` = 'bar')) LIMIT 10 []\n\t// SELECT * FROM `test` WHERE ((`baz` IN (?, ?, ?)) AND (`foo` = ?)) LIMIT ? [1 2 3 bar 10]\n}\n\n// Creating a mysql database. Be sure to import the mysql adapter.\nfunc ExampleDialect_dbMysql() {\n\t// import _ \"github.com/doug-martin/goqu/v9/dialect/mysql\"\n\n\ttype item struct {\n\t\tID      int64  `db:\"id\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\n\t// set up a mock db this would normally be\n\t// db, err := sql.Open(\"mysql\", dbURI)\n\t// \tif err != nil {\n\t// \t\tpanic(err.Error())\n\t// \t}\n\tmDB, mock, _ := sqlmock.New()\n\n\td := goqu.Dialect(\"mysql\")\n\n\tdb := d.DB(mDB)\n\n\t// use the db.From to get a dataset to execute queries\n\tds := db.From(\"items\").Where(goqu.C(\"id\").Eq(1))\n\n\t// set up mock for example purposes\n\tmock.ExpectQuery(\"SELECT `address`, `id`, `name` FROM `items` WHERE \\\\(`id` = 1\\\\) LIMIT 1\").\n\t\tWillReturnRows(\n\t\t\tsqlmock.NewRows([]string{\"id\", \"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"1, 111 Test Addr,Test1\"),\n\t\t)\n\tvar it item\n\tfound, err := ds.ScanStruct(&it)\n\tfmt.Println(it, found, err)\n\n\t// set up mock for example purposes\n\tmock.ExpectQuery(\"SELECT `address`, `id`, `name` FROM `items` WHERE \\\\(`id` = \\\\?\\\\) LIMIT \\\\?\").\n\t\tWithArgs(1, 1).\n\t\tWillReturnRows(\n\t\t\tsqlmock.NewRows([]string{\"id\", \"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"1, 111 Test Addr,Test1\"),\n\t\t)\n\n\tfound, err = ds.Prepared(true).ScanStruct(&it)\n\tfmt.Println(it, found, err)\n\n\t// Output:\n\t// {1 111 Test Addr Test1} true <nil>\n\t// {1 111 Test Addr Test1} true <nil>\n}\n\n// Creating a mysql dataset. Be sure to import the postgres adapter\nfunc ExampleDialect_datasetPostgres() {\n\t// import _ \"github.com/doug-martin/goqu/v9/dialect/postgres\"\n\n\td := goqu.Dialect(\"postgres\")\n\tds := d.From(\"test\").Where(goqu.Ex{\n\t\t\"foo\": \"bar\",\n\t\t\"baz\": []int64{1, 2, 3},\n\t}).Limit(10)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"baz\" IN (1, 2, 3)) AND (\"foo\" = 'bar')) LIMIT 10 []\n\t// SELECT * FROM \"test\" WHERE ((\"baz\" IN ($1, $2, $3)) AND (\"foo\" = $4)) LIMIT $5 [1 2 3 bar 10]\n}\n\n// Creating a postgres dataset. Be sure to import the postgres adapter\nfunc ExampleDialect_dbPostgres() {\n\t// import _ \"github.com/doug-martin/goqu/v9/dialect/postgres\"\n\n\ttype item struct {\n\t\tID      int64  `db:\"id\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\n\t// set up a mock db this would normally be\n\t// db, err := sql.Open(\"postgres\", dbURI)\n\t// \tif err != nil {\n\t// \t\tpanic(err.Error())\n\t// \t}\n\tmDB, mock, _ := sqlmock.New()\n\n\td := goqu.Dialect(\"postgres\")\n\n\tdb := d.DB(mDB)\n\n\t// use the db.From to get a dataset to execute queries\n\tds := db.From(\"items\").Where(goqu.C(\"id\").Eq(1))\n\n\t// set up mock for example purposes\n\tmock.ExpectQuery(`SELECT \"address\", \"id\", \"name\" FROM \"items\" WHERE \\(\"id\" = 1\\) LIMIT 1`).\n\t\tWillReturnRows(\n\t\t\tsqlmock.NewRows([]string{\"id\", \"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"1, 111 Test Addr,Test1\"),\n\t\t)\n\tvar it item\n\tfound, err := ds.ScanStruct(&it)\n\tfmt.Println(it, found, err)\n\n\t// set up mock for example purposes\n\tmock.ExpectQuery(`SELECT \"address\", \"id\", \"name\" FROM \"items\" WHERE \\(\"id\" = \\$1\\) LIMIT \\$2`).\n\t\tWithArgs(1, 1).\n\t\tWillReturnRows(\n\t\t\tsqlmock.NewRows([]string{\"id\", \"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"1, 111 Test Addr,Test1\"),\n\t\t)\n\n\tfound, err = ds.Prepared(true).ScanStruct(&it)\n\tfmt.Println(it, found, err)\n\n\t// Output:\n\t// {1 111 Test Addr Test1} true <nil>\n\t// {1 111 Test Addr Test1} true <nil>\n}\n\n// Creating a mysql dataset. Be sure to import the sqlite3 adapter\nfunc ExampleDialect_datasetSqlite3() {\n\t// import _ \"github.com/doug-martin/goqu/v9/dialect/sqlite3\"\n\n\td := goqu.Dialect(\"sqlite3\")\n\tds := d.From(\"test\").Where(goqu.Ex{\n\t\t\"foo\": \"bar\",\n\t\t\"baz\": []int64{1, 2, 3},\n\t}).Limit(10)\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM `test` WHERE ((`baz` IN (1, 2, 3)) AND (`foo` = 'bar')) LIMIT 10 []\n\t// SELECT * FROM `test` WHERE ((`baz` IN (?, ?, ?)) AND (`foo` = ?)) LIMIT ? [1 2 3 bar 10]\n}\n\n// Creating a sqlite3 database. Be sure to import the sqlite3 adapter\nfunc ExampleDialect_dbSqlite3() {\n\t// import _ \"github.com/doug-martin/goqu/v9/dialect/sqlite3\"\n\ttype item struct {\n\t\tID      int64  `db:\"id\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\n\t// set up a mock db this would normally be\n\t// db, err := sql.Open(\"sqlite3\", dbURI)\n\t// \tif err != nil {\n\t// \t\tpanic(err.Error())\n\t// \t}\n\tmDB, mock, _ := sqlmock.New()\n\n\td := goqu.Dialect(\"sqlite3\")\n\n\tdb := d.DB(mDB)\n\n\t// use the db.From to get a dataset to execute queries\n\tds := db.From(\"items\").Where(goqu.C(\"id\").Eq(1))\n\n\t// set up mock for example purposes\n\tmock.ExpectQuery(\"SELECT `address`, `id`, `name` FROM `items` WHERE \\\\(`id` = 1\\\\) LIMIT 1\").\n\t\tWillReturnRows(\n\t\t\tsqlmock.NewRows([]string{\"id\", \"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"1, 111 Test Addr,Test1\"),\n\t\t)\n\tvar it item\n\tfound, err := ds.ScanStruct(&it)\n\tfmt.Println(it, found, err)\n\n\t// set up mock for example purposes\n\tmock.ExpectQuery(\"SELECT `address`, `id`, `name` FROM `items` WHERE \\\\(`id` = \\\\?\\\\) LIMIT \\\\?\").\n\t\tWithArgs(1, 1).\n\t\tWillReturnRows(\n\t\t\tsqlmock.NewRows([]string{\"id\", \"address\", \"name\"}).\n\t\t\t\tFromCSVString(\"1, 111 Test Addr,Test1\"),\n\t\t)\n\n\tfound, err = ds.Prepared(true).ScanStruct(&it)\n\tfmt.Println(it, found, err)\n\n\t// Output:\n\t// {1 111 Test Addr Test1} true <nil>\n\t// {1 111 Test Addr Test1} true <nil>\n}\n\nfunc ExampleSetTimeLocation() {\n\tloc, err := time.LoadLocation(\"Asia/Shanghai\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tcreated, err := time.Parse(time.RFC3339, \"2019-10-01T15:01:00Z\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// use original time with tz info\n\tgoqu.SetTimeLocation(loc)\n\tds := goqu.Insert(\"test\").Rows(goqu.Record{\n\t\t\"address\": \"111 Address\",\n\t\t\"name\":    \"Bob Yukon\",\n\t\t\"created\": created,\n\t})\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\n\t// convert time to UTC\n\tgoqu.SetTimeLocation(time.UTC)\n\tsql, _, _ = ds.ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// INSERT INTO \"test\" (\"address\", \"created\", \"name\") VALUES ('111 Address', '2019-10-01T23:01:00+08:00', 'Bob Yukon')\n\t// INSERT INTO \"test\" (\"address\", \"created\", \"name\") VALUES ('111 Address', '2019-10-01T15:01:00Z', 'Bob Yukon')\n}\n"
        },
        {
          "name": "goqu_test.go",
          "type": "blob",
          "size": 1.4638671875,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\tdialectWrapperSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (dws *dialectWrapperSuite) SetupSuite() {\n\ttestDialect := goqu.DefaultDialectOptions()\n\t// override to some value to ensure correct dialect is set\n\tgoqu.RegisterDialect(\"test\", testDialect)\n}\n\nfunc (dws *dialectWrapperSuite) TearDownSuite() {\n\tgoqu.DeregisterDialect(\"test\")\n}\n\nfunc (dws *dialectWrapperSuite) TestFrom() {\n\tdw := goqu.Dialect(\"test\")\n\tdws.Equal(goqu.From(\"table\").WithDialect(\"test\"), dw.From(\"table\"))\n}\n\nfunc (dws *dialectWrapperSuite) TestSelect() {\n\tdw := goqu.Dialect(\"test\")\n\tdws.Equal(goqu.Select(\"col\").WithDialect(\"test\"), dw.Select(\"col\"))\n}\n\nfunc (dws *dialectWrapperSuite) TestInsert() {\n\tdw := goqu.Dialect(\"test\")\n\tdws.Equal(goqu.Insert(\"table\").WithDialect(\"test\"), dw.Insert(\"table\"))\n}\n\nfunc (dws *dialectWrapperSuite) TestDelete() {\n\tdw := goqu.Dialect(\"test\")\n\tdws.Equal(goqu.Delete(\"table\").WithDialect(\"test\"), dw.Delete(\"table\"))\n}\n\nfunc (dws *dialectWrapperSuite) TestTruncate() {\n\tdw := goqu.Dialect(\"test\")\n\tdws.Equal(goqu.Truncate(\"table\").WithDialect(\"test\"), dw.Truncate(\"table\"))\n}\n\nfunc (dws *dialectWrapperSuite) TestDB() {\n\tmDB, _, err := sqlmock.New()\n\tdws.Require().NoError(err)\n\tdw := goqu.Dialect(\"test\")\n\tdws.Equal(goqu.New(\"test\", mDB), dw.DB(mDB))\n}\n\nfunc TestDialectWrapper(t *testing.T) {\n\tsuite.Run(t, new(dialectWrapperSuite))\n}\n"
        },
        {
          "name": "insert_dataset.go",
          "type": "blob",
          "size": 8.8525390625,
          "content": "package goqu\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/doug-martin/goqu/v9/exec\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n)\n\ntype InsertDataset struct {\n\tdialect      SQLDialect\n\tclauses      exp.InsertClauses\n\tisPrepared   prepared\n\tqueryFactory exec.QueryFactory\n\terr          error\n}\n\nvar ErrUnsupportedIntoType = errors.New(\"unsupported table type, a string or identifier expression is required\")\n\n// used internally by database to create a database with a specific adapter\nfunc newInsertDataset(d string, queryFactory exec.QueryFactory) *InsertDataset {\n\treturn &InsertDataset{\n\t\tclauses:      exp.NewInsertClauses(),\n\t\tdialect:      GetDialect(d),\n\t\tqueryFactory: queryFactory,\n\t}\n}\n\n// Creates a new InsertDataset for the provided table. Using this method will only allow you\n// to create SQL user Database#From to create an InsertDataset with query capabilities\nfunc Insert(table interface{}) *InsertDataset {\n\treturn newInsertDataset(\"default\", nil).Into(table)\n}\n\n// Set the parameter interpolation behavior. See examples\n//\n// prepared: If true the dataset WILL NOT interpolate the parameters.\nfunc (id *InsertDataset) Prepared(prepared bool) *InsertDataset {\n\tret := id.copy(id.clauses)\n\tret.isPrepared = preparedFromBool(prepared)\n\treturn ret\n}\n\nfunc (id *InsertDataset) IsPrepared() bool {\n\treturn id.isPrepared.Bool()\n}\n\n// Sets the adapter used to serialize values and create the SQL statement\nfunc (id *InsertDataset) WithDialect(dl string) *InsertDataset {\n\tds := id.copy(id.GetClauses())\n\tds.dialect = GetDialect(dl)\n\treturn ds\n}\n\n// Returns the current adapter on the dataset\nfunc (id *InsertDataset) Dialect() SQLDialect {\n\treturn id.dialect\n}\n\n// Returns the current adapter on the dataset\nfunc (id *InsertDataset) SetDialect(dialect SQLDialect) *InsertDataset {\n\tcd := id.copy(id.GetClauses())\n\tcd.dialect = dialect\n\treturn cd\n}\n\nfunc (id *InsertDataset) Expression() exp.Expression {\n\treturn id\n}\n\n// Clones the dataset\nfunc (id *InsertDataset) Clone() exp.Expression {\n\treturn id.copy(id.clauses)\n}\n\n// Returns the current clauses on the dataset.\nfunc (id *InsertDataset) GetClauses() exp.InsertClauses {\n\treturn id.clauses\n}\n\n// used interally to copy the dataset\nfunc (id *InsertDataset) copy(clauses exp.InsertClauses) *InsertDataset {\n\treturn &InsertDataset{\n\t\tdialect:      id.dialect,\n\t\tclauses:      clauses,\n\t\tisPrepared:   id.isPrepared,\n\t\tqueryFactory: id.queryFactory,\n\t\terr:          id.err,\n\t}\n}\n\n// Creates a WITH clause for a common table expression (CTE).\n//\n// The name will be available to SELECT from in the associated query; and can optionally\n// contain a list of column names \"name(col1, col2, col3)\".\n//\n// The name will refer to the results of the specified subquery.\nfunc (id *InsertDataset) With(name string, subquery exp.Expression) *InsertDataset {\n\treturn id.copy(id.clauses.CommonTablesAppend(exp.NewCommonTableExpression(false, name, subquery)))\n}\n\n// Creates a WITH RECURSIVE clause for a common table expression (CTE)\n//\n// The name will be available to SELECT from in the associated query; and must\n// contain a list of column names \"name(col1, col2, col3)\" for a recursive clause.\n//\n// The name will refer to the results of the specified subquery. The subquery for\n// a recursive query will always end with a UNION or UNION ALL with a clause that\n// refers to the CTE by name.\nfunc (id *InsertDataset) WithRecursive(name string, subquery exp.Expression) *InsertDataset {\n\treturn id.copy(id.clauses.CommonTablesAppend(exp.NewCommonTableExpression(true, name, subquery)))\n}\n\n// Sets the table to insert INTO. This return a new dataset with the original table replaced. See examples.\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tExpression: Any valid expression (IdentifierExpression, AliasedExpression, Literal, etc.)\nfunc (id *InsertDataset) Into(into interface{}) *InsertDataset {\n\tswitch t := into.(type) {\n\tcase exp.Expression:\n\t\treturn id.copy(id.clauses.SetInto(t))\n\tcase string:\n\t\treturn id.copy(id.clauses.SetInto(exp.ParseIdentifier(t)))\n\tdefault:\n\t\tpanic(ErrUnsupportedIntoType)\n\t}\n}\n\n// Sets the Columns to insert into\nfunc (id *InsertDataset) Cols(cols ...interface{}) *InsertDataset {\n\treturn id.copy(id.clauses.SetCols(exp.NewColumnListExpression(cols...)))\n}\n\n// Clears the Columns to insert into\nfunc (id *InsertDataset) ClearCols() *InsertDataset {\n\treturn id.copy(id.clauses.SetCols(nil))\n}\n\n// Adds columns to the current list of columns clause. See examples\nfunc (id *InsertDataset) ColsAppend(cols ...interface{}) *InsertDataset {\n\treturn id.copy(id.clauses.ColsAppend(exp.NewColumnListExpression(cols...)))\n}\n\n// Adds a subquery to the insert. See examples.\nfunc (id *InsertDataset) FromQuery(from exp.AppendableExpression) *InsertDataset {\n\tif sds, ok := from.(*SelectDataset); ok {\n\t\tif sds.dialect != GetDialect(\"default\") && id.Dialect() != sds.dialect {\n\t\t\tpanic(\n\t\t\t\tfmt.Errorf(\n\t\t\t\t\t\"incompatible dialects for INSERT (%q) and SELECT (%q)\",\n\t\t\t\t\tid.dialect.Dialect(), sds.dialect.Dialect(),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t\tsds.dialect = id.dialect\n\t}\n\treturn id.copy(id.clauses.SetFrom(from))\n}\n\n// Manually set values to insert See examples.\nfunc (id *InsertDataset) Vals(vals ...[]interface{}) *InsertDataset {\n\treturn id.copy(id.clauses.ValsAppend(vals))\n}\n\n// Clears the values. See examples.\nfunc (id *InsertDataset) ClearVals() *InsertDataset {\n\treturn id.copy(id.clauses.SetVals(nil))\n}\n\n// Insert rows. Rows can be a map, goqu.Record or struct. See examples.\nfunc (id *InsertDataset) Rows(rows ...interface{}) *InsertDataset {\n\treturn id.copy(id.clauses.SetRows(rows))\n}\n\n// Clears the rows for this insert dataset. See examples.\nfunc (id *InsertDataset) ClearRows() *InsertDataset {\n\treturn id.copy(id.clauses.SetRows(nil))\n}\n\n// Adds a RETURNING clause to the dataset if the adapter supports it See examples.\nfunc (id *InsertDataset) Returning(returning ...interface{}) *InsertDataset {\n\treturn id.copy(id.clauses.SetReturning(exp.NewColumnListExpression(returning...)))\n}\n\n// Adds an (ON CONFLICT/ON DUPLICATE KEY) clause to the dataset if the dialect supports it. See examples.\nfunc (id *InsertDataset) OnConflict(conflict exp.ConflictExpression) *InsertDataset {\n\treturn id.copy(id.clauses.SetOnConflict(conflict))\n}\n\n// Clears the on conflict clause. See example\nfunc (id *InsertDataset) ClearOnConflict() *InsertDataset {\n\treturn id.OnConflict(nil)\n}\n\n// Get any error that has been set or nil if no error has been set.\nfunc (id *InsertDataset) Error() error {\n\treturn id.err\n}\n\n// Set an error on the dataset if one has not already been set. This error will be returned by a future call to Error\n// or as part of ToSQL. This can be used by end users to record errors while building up queries without having to\n// track those separately.\nfunc (id *InsertDataset) SetError(err error) *InsertDataset {\n\tif id.err == nil {\n\t\tid.err = err\n\t}\n\n\treturn id\n}\n\n// Generates the default INSERT statement. If Prepared has been called with true then the statement will not be\n// interpolated. See examples. When using structs you may specify a column to be skipped in the insert, (e.g. id) by\n// specifying a goqu tag with `skipinsert`\n//\n//\ttype Item struct{\n//\t   Id   uint32 `db:\"id\" goqu:\"skipinsert\"`\n//\t   Name string `db:\"name\"`\n//\t}\n//\n// rows: variable number arguments of either map[string]interface, Record, struct, or a single slice argument of the\n// accepted types.\n//\n// Errors:\n//   - There is no INTO clause\n//   - Different row types passed in, all rows must be of the same type\n//   - Maps with different numbers of K/V pairs\n//   - Rows of different lengths, (i.e. (Record{\"name\": \"a\"}, Record{\"name\": \"a\", \"age\": 10})\n//   - Error generating SQL\nfunc (id *InsertDataset) ToSQL() (sql string, params []interface{}, err error) {\n\treturn id.insertSQLBuilder().ToSQL()\n}\n\n// Appends this Dataset's INSERT statement to the SQLBuilder\n// This is used internally when using inserts in CTEs\nfunc (id *InsertDataset) AppendSQL(b sb.SQLBuilder) {\n\tif id.err != nil {\n\t\tb.SetError(id.err)\n\t\treturn\n\t}\n\tid.dialect.ToInsertSQL(b, id.GetClauses())\n}\n\nfunc (id *InsertDataset) GetAs() exp.IdentifierExpression {\n\treturn id.clauses.Alias()\n}\n\n// Sets the alias for this dataset. This is typically used when using a Dataset as MySQL upsert\nfunc (id *InsertDataset) As(alias string) *InsertDataset {\n\treturn id.copy(id.clauses.SetAlias(T(alias)))\n}\n\nfunc (id *InsertDataset) ReturnsColumns() bool {\n\treturn id.clauses.HasReturning()\n}\n\n// Generates the INSERT sql, and returns an QueryExecutor struct with the sql set to the INSERT statement\n//\n//\tdb.Insert(\"test\").Rows(Record{\"name\":\"Bob\"}).Executor().Exec()\nfunc (id *InsertDataset) Executor() exec.QueryExecutor {\n\treturn id.queryFactory.FromSQLBuilder(id.insertSQLBuilder())\n}\n\nfunc (id *InsertDataset) insertSQLBuilder() sb.SQLBuilder {\n\tbuf := sb.NewSQLBuilder(id.isPrepared.Bool())\n\tif id.err != nil {\n\t\treturn buf.SetError(id.err)\n\t}\n\tid.dialect.ToInsertSQL(buf, id.clauses)\n\treturn buf\n}\n"
        },
        {
          "name": "insert_dataset_example_test.go",
          "type": "blob",
          "size": 24.232421875,
          "content": "//nolint:lll // SQL statements are long\npackage goqu_test\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n\t_ \"github.com/doug-martin/goqu/v9/dialect/postgres\"\n)\n\nfunc ExampleInsert_goquRecord() {\n\tds := goqu.Insert(\"user\").Rows(\n\t\tgoqu.Record{\"first_name\": \"Greg\", \"last_name\": \"Farley\"},\n\t\tgoqu.Record{\"first_name\": \"Jimmy\", \"last_name\": \"Stewart\"},\n\t\tgoqu.Record{\"first_name\": \"Jeff\", \"last_name\": \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsert_map() {\n\tds := goqu.Insert(\"user\").Rows(\n\t\tmap[string]interface{}{\"first_name\": \"Greg\", \"last_name\": \"Farley\"},\n\t\tmap[string]interface{}{\"first_name\": \"Jimmy\", \"last_name\": \"Stewart\"},\n\t\tmap[string]interface{}{\"first_name\": \"Jeff\", \"last_name\": \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsert_struct() {\n\ttype User struct {\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\tds := goqu.Insert(\"user\").Rows(\n\t\tUser{FirstName: \"Greg\", LastName: \"Farley\"},\n\t\tUser{FirstName: \"Jimmy\", LastName: \"Stewart\"},\n\t\tUser{FirstName: \"Jeff\", LastName: \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsert_prepared() {\n\tds := goqu.Insert(\"user\").Prepared(true).Rows(\n\t\tgoqu.Record{\"first_name\": \"Greg\", \"last_name\": \"Farley\"},\n\t\tgoqu.Record{\"first_name\": \"Jimmy\", \"last_name\": \"Stewart\"},\n\t\tgoqu.Record{\"first_name\": \"Jeff\", \"last_name\": \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES (?, ?), (?, ?), (?, ?) [Greg Farley Jimmy Stewart Jeff Jeffers]\n}\n\nfunc ExampleInsert_fromQuery() {\n\tds := goqu.Insert(\"user\").Prepared(true).\n\t\tFromQuery(goqu.From(\"other_table\"))\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" SELECT * FROM \"other_table\" []\n}\n\nfunc ExampleInsert_fromQueryWithCols() {\n\tds := goqu.Insert(\"user\").Prepared(true).\n\t\tCols(\"first_name\", \"last_name\").\n\t\tFromQuery(goqu.From(\"other_table\").Select(\"fn\", \"ln\"))\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\") SELECT \"fn\", \"ln\" FROM \"other_table\" []\n}\n\nfunc ExampleInsert_colsAndVals() {\n\tds := goqu.Insert(\"user\").\n\t\tCols(\"first_name\", \"last_name\").\n\t\tVals(\n\t\t\tgoqu.Vals{\"Greg\", \"Farley\"},\n\t\t\tgoqu.Vals{\"Jimmy\", \"Stewart\"},\n\t\t\tgoqu.Vals{\"Jeff\", \"Jeffers\"},\n\t\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"first_name\", \"last_name\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsertDataset_Executor_withRecord() {\n\tdb := getDB()\n\tinsert := db.Insert(\"goqu_user\").Rows(\n\t\tgoqu.Record{\"first_name\": \"Jed\", \"last_name\": \"Riley\", \"created\": time.Now()},\n\t).Executor()\n\tif _, err := insert.Exec(); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Println(\"Inserted 1 user\")\n\t}\n\n\tusers := []goqu.Record{\n\t\t{\"first_name\": \"Greg\", \"last_name\": \"Farley\", \"created\": time.Now()},\n\t\t{\"first_name\": \"Jimmy\", \"last_name\": \"Stewart\", \"created\": time.Now()},\n\t\t{\"first_name\": \"Jeff\", \"last_name\": \"Jeffers\", \"created\": time.Now()},\n\t}\n\tif _, err := db.Insert(\"goqu_user\").Rows(users).Executor().Exec(); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Printf(\"Inserted %d users\", len(users))\n\t}\n\n\t// Output:\n\t// Inserted 1 user\n\t// Inserted 3 users\n}\n\nfunc ExampleInsertDataset_Executor_recordReturning() {\n\tdb := getDB()\n\n\ttype User struct {\n\t\tID        sql.NullInt64 `db:\"id\"`\n\t\tFirstName string        `db:\"first_name\"`\n\t\tLastName  string        `db:\"last_name\"`\n\t\tCreated   time.Time     `db:\"created\"`\n\t}\n\n\tinsert := db.Insert(\"goqu_user\").Returning(goqu.C(\"id\")).Rows(\n\t\tgoqu.Record{\"first_name\": \"Jed\", \"last_name\": \"Riley\", \"created\": time.Now()},\n\t).Executor()\n\tvar id int64\n\tif _, err := insert.ScanVal(&id); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Printf(\"Inserted 1 user id:=%d\\n\", id)\n\t}\n\n\tinsert = db.Insert(\"goqu_user\").Returning(goqu.Star()).Rows([]goqu.Record{\n\t\t{\"first_name\": \"Greg\", \"last_name\": \"Farley\", \"created\": time.Now()},\n\t\t{\"first_name\": \"Jimmy\", \"last_name\": \"Stewart\", \"created\": time.Now()},\n\t\t{\"first_name\": \"Jeff\", \"last_name\": \"Jeffers\", \"created\": time.Now()},\n\t}).Executor()\n\tvar insertedUsers []User\n\tif err := insert.ScanStructs(&insertedUsers); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfor _, u := range insertedUsers {\n\t\t\tfmt.Printf(\"Inserted user: [ID=%d], [FirstName=%+s] [LastName=%s]\\n\", u.ID.Int64, u.FirstName, u.LastName)\n\t\t}\n\t}\n\n\t// Output:\n\t// Inserted 1 user id:=5\n\t// Inserted user: [ID=6], [FirstName=Greg] [LastName=Farley]\n\t// Inserted user: [ID=7], [FirstName=Jimmy] [LastName=Stewart]\n\t// Inserted user: [ID=8], [FirstName=Jeff] [LastName=Jeffers]\n}\n\nfunc ExampleInsertDataset_Executor_scanStructs() {\n\tdb := getDB()\n\n\ttype User struct {\n\t\tID        sql.NullInt64 `db:\"id\" goqu:\"skipinsert\"`\n\t\tFirstName string        `db:\"first_name\"`\n\t\tLastName  string        `db:\"last_name\"`\n\t\tCreated   time.Time     `db:\"created\"`\n\t}\n\n\tinsert := db.Insert(\"goqu_user\").Returning(\"id\").Rows(\n\t\tUser{FirstName: \"Jed\", LastName: \"Riley\"},\n\t).Executor()\n\tvar id int64\n\tif _, err := insert.ScanVal(&id); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Printf(\"Inserted 1 user id:=%d\\n\", id)\n\t}\n\n\tinsert = db.Insert(\"goqu_user\").Returning(goqu.Star()).Rows([]User{\n\t\t{FirstName: \"Greg\", LastName: \"Farley\", Created: time.Now()},\n\t\t{FirstName: \"Jimmy\", LastName: \"Stewart\", Created: time.Now()},\n\t\t{FirstName: \"Jeff\", LastName: \"Jeffers\", Created: time.Now()},\n\t}).Executor()\n\tvar insertedUsers []User\n\tif err := insert.ScanStructs(&insertedUsers); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfor _, u := range insertedUsers {\n\t\t\tfmt.Printf(\"Inserted user: [ID=%d], [FirstName=%+s] [LastName=%s]\\n\", u.ID.Int64, u.FirstName, u.LastName)\n\t\t}\n\t}\n\n\t// Output:\n\t// Inserted 1 user id:=5\n\t// Inserted user: [ID=6], [FirstName=Greg] [LastName=Farley]\n\t// Inserted user: [ID=7], [FirstName=Jimmy] [LastName=Stewart]\n\t// Inserted user: [ID=8], [FirstName=Jeff] [LastName=Jeffers]\n}\n\nfunc ExampleInsertDataset_FromQuery() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tFromQuery(goqu.From(\"test2\").Where(goqu.C(\"age\").Gt(10))).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" SELECT * FROM \"test2\" WHERE (\"age\" > 10)\n}\n\nfunc ExampleInsertDataset_ToSQL() {\n\ttype item struct {\n\t\tID      uint32 `db:\"id\" goqu:\"skipinsert\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").Rows(\n\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").Rows(\n\t\tgoqu.Record{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\tgoqu.Record{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").Rows(\n\t\t[]item{\n\t\t\t{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.From(\"items\").Insert().Rows(\n\t\t[]goqu.Record{\n\t\t\t{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\t\t{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t\t}).ToSQL()\n\tfmt.Println(insertSQL, args)\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n}\n\nfunc ExampleInsertDataset_Prepared() {\n\ttype item struct {\n\t\tID      uint32 `db:\"id\" goqu:\"skipinsert\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\n\tinsertSQL, args, _ := goqu.Insert(\"items\").Prepared(true).Rows(\n\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").Prepared(true).Rows(\n\t\tgoqu.Record{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\tgoqu.Record{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").Prepared(true).Rows(\n\t\t[]item{\n\t\t\t{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").Prepared(true).Rows(\n\t\t[]goqu.Record{\n\t\t\t{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\t\t{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t\t}).ToSQL()\n\tfmt.Println(insertSQL, args)\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?), (?, ?) [111 Test Addr Test1 112 Test Addr Test2]\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?), (?, ?) [111 Test Addr Test1 112 Test Addr Test2]\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?), (?, ?) [111 Test Addr Test1 112 Test Addr Test2]\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?), (?, ?) [111 Test Addr Test1 112 Test Addr Test2]\n}\n\nfunc ExampleInsertDataset_ClearRows() {\n\ttype item struct {\n\t\tID      uint32 `goqu:\"skipinsert\"`\n\t\tAddress string\n\t\tName    string\n\t}\n\tds := goqu.Insert(\"items\").Rows(\n\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t)\n\tinsertSQL, args, _ := ds.ClearRows().ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" DEFAULT VALUES []\n}\n\nfunc ExampleInsertDataset_Rows_withNoDbTag() {\n\ttype item struct {\n\t\tID      uint32 `goqu:\"skipinsert\"`\n\t\tAddress string\n\t\tName    string\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").\n\t\tRows(\n\t\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").\n\t\tRows(\n\t\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").\n\t\tRows([]item{\n\t\t\t{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n}\n\nfunc ExampleInsertDataset_Rows_withGoquSkipInsertTag() {\n\ttype item struct {\n\t\tID      uint32 `goqu:\"skipinsert\"`\n\t\tAddress string\n\t\tName    string `goqu:\"skipinsert\"`\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").\n\t\tRows(\n\t\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").\n\t\tRows([]item{\n\t\t\t{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\") VALUES ('111 Test Addr'), ('112 Test Addr') []\n\t// INSERT INTO \"items\" (\"address\") VALUES ('111 Test Addr'), ('112 Test Addr') []\n}\n\nfunc ExampleInsertDataset_Rows_withOmitNilTag() {\n\ttype item struct {\n\t\tFirstName string  `db:\"first_name\" goqu:\"omitnil\"`\n\t\tLastName  string  `db:\"last_name\" goqu:\"omitnil\"`\n\t\tAddress1  *string `db:\"address1\" goqu:\"omitnil\"`\n\t\tAddress2  *string `db:\"address2\" goqu:\"omitnil\"`\n\t\tAddress3  *string `db:\"address3\" goqu:\"omitnil\"`\n\t}\n\taddress1 := \"111 Test Addr\"\n\tvar emptyString string\n\ti := item{\n\t\tFirstName: \"Test First Name\",\n\t\tLastName:  \"\",\n\t\tAddress1:  &address1,\n\t\tAddress2:  &emptyString,\n\t\tAddress3:  nil, // will omit nil pointer\n\t}\n\n\tinsertSQL, args, _ := goqu.Insert(\"items\").Rows(i).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address1\", \"address2\", \"first_name\", \"last_name\") VALUES ('111 Test Addr', '', 'Test First Name', '') []\n}\n\nfunc ExampleInsertDataset_Rows_withOmitEmptyTag() {\n\ttype item struct {\n\t\tFirstName string  `db:\"first_name\" goqu:\"omitempty\"`\n\t\tLastName  string  `db:\"last_name\" goqu:\"omitempty\"`\n\t\tAddress1  *string `db:\"address1\" goqu:\"omitempty\"`\n\t\tAddress2  *string `db:\"address2\" goqu:\"omitempty\"`\n\t\tAddress3  *string `db:\"address3\" goqu:\"omitempty\"`\n\t}\n\taddress1 := \"112 Test Addr\"\n\tvar emptyString string\n\ti := item{\n\t\tFirstName: \"Test First Name\",\n\t\tLastName:  \"\", // will omit zero field\n\t\tAddress1:  &address1,\n\t\tAddress2:  &emptyString,\n\t\tAddress3:  nil, // will omit nil pointer\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").Rows(i).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address1\", \"address2\", \"first_name\") VALUES ('112 Test Addr', '', 'Test First Name') []\n}\n\nfunc ExampleInsertDataset_Rows_withOmitEmptyTag_Valuer() {\n\ttype item struct {\n\t\tFirstName  sql.NullString  `db:\"first_name\" goqu:\"omitempty\"`\n\t\tMiddleName sql.NullString  `db:\"middle_name\" goqu:\"omitempty\"`\n\t\tLastName   sql.NullString  `db:\"last_name\" goqu:\"omitempty\"`\n\t\tAddress1   *sql.NullString `db:\"address1\" goqu:\"omitempty\"`\n\t\tAddress2   *sql.NullString `db:\"address2\" goqu:\"omitempty\"`\n\t\tAddress3   *sql.NullString `db:\"address3\" goqu:\"omitempty\"`\n\t\tAddress4   *sql.NullString `db:\"address4\" goqu:\"omitempty\"`\n\t}\n\ti := item{\n\t\tFirstName:  sql.NullString{Valid: true, String: \"Test First Name\"},\n\t\tMiddleName: sql.NullString{Valid: true, String: \"\"},\n\t\tLastName:   sql.NullString{}, // will omit zero valuer struct\n\t\tAddress1:   &sql.NullString{Valid: true, String: \"Test Address 1\"},\n\t\tAddress2:   &sql.NullString{Valid: true, String: \"\"},\n\t\tAddress3:   &sql.NullString{},\n\t\tAddress4:   nil, // will omit nil pointer\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").Rows(i).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address1\", \"address2\", \"address3\", \"first_name\", \"middle_name\") VALUES ('Test Address 1', '', NULL, 'Test First Name', '') []\n}\n\nfunc ExampleInsertDataset_Rows_withGoquDefaultIfEmptyTag() {\n\ttype item struct {\n\t\tID      uint32 `goqu:\"skipinsert\"`\n\t\tAddress string\n\t\tName    string `goqu:\"defaultifempty\"`\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").\n\t\tRows(\n\t\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\titem{Address: \"112 Test Addr\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\tinsertSQL, args, _ = goqu.Insert(\"items\").\n\t\tRows([]item{\n\t\t\t{Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', DEFAULT) []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', DEFAULT), ('112 Test Addr', 'Test2') []\n}\n\nfunc ExampleInsertDataset_Rows_withEmbeddedStruct() {\n\ttype Address struct {\n\t\tStreet string `db:\"address_street\"`\n\t\tState  string `db:\"address_state\"`\n\t}\n\ttype User struct {\n\t\tAddress\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\tds := goqu.Insert(\"user\").Rows(\n\t\tUser{Address: Address{Street: \"111 Street\", State: \"NY\"}, FirstName: \"Greg\", LastName: \"Farley\"},\n\t\tUser{Address: Address{Street: \"211 Street\", State: \"NY\"}, FirstName: \"Jimmy\", LastName: \"Stewart\"},\n\t\tUser{Address: Address{Street: \"311 Street\", State: \"NY\"}, FirstName: \"Jeff\", LastName: \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"address_state\", \"address_street\", \"firstname\", \"lastname\") VALUES ('NY', '111 Street', 'Greg', 'Farley'), ('NY', '211 Street', 'Jimmy', 'Stewart'), ('NY', '311 Street', 'Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsertDataset_Rows_withIgnoredEmbedded() {\n\ttype Address struct {\n\t\tStreet string\n\t\tState  string\n\t}\n\ttype User struct {\n\t\tAddress   `db:\"-\"`\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\tds := goqu.Insert(\"user\").Rows(\n\t\tUser{Address: Address{Street: \"111 Street\", State: \"NY\"}, FirstName: \"Greg\", LastName: \"Farley\"},\n\t\tUser{Address: Address{Street: \"211 Street\", State: \"NY\"}, FirstName: \"Jimmy\", LastName: \"Stewart\"},\n\t\tUser{Address: Address{Street: \"311 Street\", State: \"NY\"}, FirstName: \"Jeff\", LastName: \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"firstname\", \"lastname\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsertDataset_Rows_withNilEmbeddedPointer() {\n\ttype Address struct {\n\t\tStreet string\n\t\tState  string\n\t}\n\ttype User struct {\n\t\t*Address\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\tds := goqu.Insert(\"user\").Rows(\n\t\tUser{FirstName: \"Greg\", LastName: \"Farley\"},\n\t\tUser{FirstName: \"Jimmy\", LastName: \"Stewart\"},\n\t\tUser{FirstName: \"Jeff\", LastName: \"Jeffers\"},\n\t)\n\tinsertSQL, args, _ := ds.ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"user\" (\"firstname\", \"lastname\") VALUES ('Greg', 'Farley'), ('Jimmy', 'Stewart'), ('Jeff', 'Jeffers') []\n}\n\nfunc ExampleInsertDataset_ClearOnConflict() {\n\ttype item struct {\n\t\tID      uint32 `db:\"id\" goqu:\"skipinsert\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tds := goqu.Insert(\"items\").OnConflict(goqu.DoNothing())\n\tinsertSQL, args, _ := ds.ClearOnConflict().Rows(\n\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n}\n\nfunc ExampleInsertDataset_OnConflict_doNothing() {\n\ttype item struct {\n\t\tID      uint32 `db:\"id\" goqu:\"skipinsert\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").Rows(\n\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t).OnConflict(goqu.DoNothing()).ToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') ON CONFLICT DO NOTHING []\n}\n\nfunc ExampleInsertDataset_OnConflict_doUpdate() {\n\tinsertSQL, args, _ := goqu.Insert(\"items\").\n\t\tRows(\n\t\t\tgoqu.Record{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\t\tgoqu.Record{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t\t).\n\t\tOnConflict(goqu.DoUpdate(\"key\", goqu.Record{\"updated\": goqu.L(\"NOW()\")})).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') ON CONFLICT (key) DO UPDATE SET \"updated\"=NOW() []\n}\n\nfunc ExampleInsertDataset_OnConflict_doUpdateWithWhere() {\n\ttype item struct {\n\t\tID      uint32 `db:\"id\" goqu:\"skipinsert\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tinsertSQL, args, _ := goqu.Insert(\"items\").\n\t\tRows([]item{\n\t\t\t{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).\n\t\tOnConflict(goqu.DoUpdate(\n\t\t\t\"key\",\n\t\t\tgoqu.Record{\"updated\": goqu.L(\"NOW()\")}).Where(goqu.C(\"allow_update\").IsTrue()),\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL, args)\n\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') ON CONFLICT (key) DO UPDATE SET \"updated\"=NOW() WHERE (\"allow_update\" IS TRUE) []\n}\n\nfunc ExampleInsertDataset_Returning() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tReturning(\"id\").\n\t\tRows(goqu.Record{\"a\": \"a\", \"b\": \"b\"}).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\tinsertSQL, _, _ = goqu.Insert(\"test\").\n\t\tReturning(goqu.T(\"test\").All()).\n\t\tRows(goqu.Record{\"a\": \"a\", \"b\": \"b\"}).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\tinsertSQL, _, _ = goqu.Insert(\"test\").\n\t\tReturning(\"a\", \"b\").\n\t\tRows(goqu.Record{\"a\": \"a\", \"b\": \"b\"}).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" (\"a\", \"b\") VALUES ('a', 'b') RETURNING \"id\"\n\t// INSERT INTO \"test\" (\"a\", \"b\") VALUES ('a', 'b') RETURNING \"test\".*\n\t// INSERT INTO \"test\" (\"a\", \"b\") VALUES ('a', 'b') RETURNING \"a\", \"b\"\n}\n\nfunc ExampleInsertDataset_With() {\n\tinsertSQL, _, _ := goqu.Insert(\"foo\").\n\t\tWith(\"other\", goqu.From(\"bar\").Where(goqu.C(\"id\").Gt(10))).\n\t\tFromQuery(goqu.From(\"other\")).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\n\t// Output:\n\t// WITH other AS (SELECT * FROM \"bar\" WHERE (\"id\" > 10)) INSERT INTO \"foo\" SELECT * FROM \"other\"\n}\n\nfunc ExampleInsertDataset_WithRecursive() {\n\tinsertSQL, _, _ := goqu.Insert(\"num_count\").\n\t\tWithRecursive(\"nums(x)\",\n\t\t\tgoqu.From().Select(goqu.L(\"1\")).\n\t\t\t\tUnionAll(goqu.From(\"nums\").\n\t\t\t\t\tSelect(goqu.L(\"x+1\")).Where(goqu.C(\"x\").Lt(5))),\n\t\t).\n\t\tFromQuery(goqu.From(\"nums\")).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// WITH RECURSIVE nums(x) AS (SELECT 1 UNION ALL (SELECT x+1 FROM \"nums\" WHERE (\"x\" < 5))) INSERT INTO \"num_count\" SELECT * FROM \"nums\"\n}\n\nfunc ExampleInsertDataset_Into() {\n\tds := goqu.Insert(\"test\")\n\tinsertSQL, _, _ := ds.Into(\"test2\").Rows(goqu.Record{\"first_name\": \"bob\", \"last_name\": \"yukon\"}).ToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test2\" (\"first_name\", \"last_name\") VALUES ('bob', 'yukon')\n}\n\nfunc ExampleInsertDataset_Into_aliased() {\n\tds := goqu.Insert(\"test\")\n\tinsertSQL, _, _ := ds.\n\t\tInto(goqu.T(\"test\").As(\"t\")).\n\t\tRows(goqu.Record{\"first_name\": \"bob\", \"last_name\": \"yukon\"}).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" AS \"t\" (\"first_name\", \"last_name\") VALUES ('bob', 'yukon')\n}\n\nfunc ExampleInsertDataset_Cols() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\", \"c\").\n\t\tVals(\n\t\t\t[]interface{}{\"a1\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a2\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a3\", \"b1\", \"c1\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" (\"a\", \"b\", \"c\") VALUES ('a1', 'b1', 'c1'), ('a2', 'b1', 'c1'), ('a3', 'b1', 'c1')\n}\n\nfunc ExampleInsertDataset_Cols_withFromQuery() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\", \"c\").\n\t\tFromQuery(goqu.From(\"foo\").Select(\"d\", \"e\", \"f\")).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" (\"a\", \"b\", \"c\") SELECT \"d\", \"e\", \"f\" FROM \"foo\"\n}\n\nfunc ExampleInsertDataset_ColsAppend() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\").\n\t\tColsAppend(\"c\").\n\t\tVals(\n\t\t\t[]interface{}{\"a1\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a2\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a3\", \"b1\", \"c1\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" (\"a\", \"b\", \"c\") VALUES ('a1', 'b1', 'c1'), ('a2', 'b1', 'c1'), ('a3', 'b1', 'c1')\n}\n\nfunc ExampleInsertDataset_ClearCols() {\n\tds := goqu.Insert(\"test\").Cols(\"a\", \"b\", \"c\")\n\tinsertSQL, _, _ := ds.ClearCols().Cols(\"other_a\", \"other_b\", \"other_c\").\n\t\tFromQuery(goqu.From(\"foo\").Select(\"d\", \"e\", \"f\")).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" (\"other_a\", \"other_b\", \"other_c\") SELECT \"d\", \"e\", \"f\" FROM \"foo\"\n}\n\nfunc ExampleInsertDataset_Vals() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\", \"c\").\n\t\tVals(\n\t\t\t[]interface{}{\"a1\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a2\", \"b2\", \"c2\"},\n\t\t\t[]interface{}{\"a3\", \"b3\", \"c3\"},\n\t\t).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\n\tinsertSQL, _, _ = goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\", \"c\").\n\t\tVals([]interface{}{\"a1\", \"b1\", \"c1\"}).\n\t\tVals([]interface{}{\"a2\", \"b2\", \"c2\"}).\n\t\tVals([]interface{}{\"a3\", \"b3\", \"c3\"}).\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\n\t// Output:\n\t// INSERT INTO \"test\" (\"a\", \"b\", \"c\") VALUES ('a1', 'b1', 'c1'), ('a2', 'b2', 'c2'), ('a3', 'b3', 'c3')\n\t// INSERT INTO \"test\" (\"a\", \"b\", \"c\") VALUES ('a1', 'b1', 'c1'), ('a2', 'b2', 'c2'), ('a3', 'b3', 'c3')\n}\n\nfunc ExampleInsertDataset_ClearVals() {\n\tinsertSQL, _, _ := goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\", \"c\").\n\t\tVals(\n\t\t\t[]interface{}{\"a1\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a2\", \"b1\", \"c1\"},\n\t\t\t[]interface{}{\"a3\", \"b1\", \"c1\"},\n\t\t).\n\t\tClearVals().\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\n\tinsertSQL, _, _ = goqu.Insert(\"test\").\n\t\tCols(\"a\", \"b\", \"c\").\n\t\tVals([]interface{}{\"a1\", \"b1\", \"c1\"}).\n\t\tVals([]interface{}{\"a2\", \"b2\", \"c2\"}).\n\t\tVals([]interface{}{\"a3\", \"b3\", \"c3\"}).\n\t\tClearVals().\n\t\tToSQL()\n\tfmt.Println(insertSQL)\n\t// Output:\n\t// INSERT INTO \"test\" DEFAULT VALUES\n\t// INSERT INTO \"test\" DEFAULT VALUES\n}\n"
        },
        {
          "name": "insert_dataset_test.go",
          "type": "blob",
          "size": 16.2978515625,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/mocks\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\tinsertTestCase struct {\n\t\tds      *goqu.InsertDataset\n\t\tclauses exp.InsertClauses\n\t}\n\tinsertDatasetSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (ids *insertDatasetSuite) assertCases(cases ...insertTestCase) {\n\tfor _, s := range cases {\n\t\tids.Equal(s.clauses, s.ds.GetClauses())\n\t}\n}\n\nfunc (ids *insertDatasetSuite) TestInsert() {\n\tds := goqu.Insert(\"test\")\n\tids.IsType(&goqu.InsertDataset{}, ds)\n\tids.Implements((*exp.Expression)(nil), ds)\n\tids.Implements((*exp.AppendableExpression)(nil), ds)\n}\n\nfunc (ids *insertDatasetSuite) TestClone() {\n\tds := goqu.Insert(\"test\")\n\tids.Equal(ds.Clone(), ds)\n}\n\nfunc (ids *insertDatasetSuite) TestExpression() {\n\tds := goqu.Insert(\"test\")\n\tids.Equal(ds.Expression(), ds)\n}\n\nfunc (ids *insertDatasetSuite) TestDialect() {\n\tds := goqu.Insert(\"test\")\n\tids.NotNil(ds.Dialect())\n}\n\nfunc (ids *insertDatasetSuite) TestWithDialect() {\n\tds := goqu.Insert(\"test\")\n\tmd := new(mocks.SQLDialect)\n\tds = ds.SetDialect(md)\n\n\tdialect := goqu.GetDialect(\"default\")\n\tdialectDs := ds.WithDialect(\"default\")\n\tids.Equal(md, ds.Dialect())\n\tids.Equal(dialect, dialectDs.Dialect())\n}\n\nfunc (ids *insertDatasetSuite) TestPrepared() {\n\tds := goqu.Insert(\"test\")\n\tpreparedDs := ds.Prepared(true)\n\tids.True(preparedDs.IsPrepared())\n\tids.False(ds.IsPrepared())\n\t// should apply the prepared to any datasets created from the root\n\tids.True(preparedDs.Returning(goqu.C(\"col\")).IsPrepared())\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\t// should be prepared by default\n\tds = goqu.Insert(\"test\")\n\tids.True(ds.IsPrepared())\n}\n\nfunc (ids *insertDatasetSuite) TestGetClauses() {\n\tds := goqu.Insert(\"test\")\n\tce := exp.NewInsertClauses().SetInto(goqu.I(\"test\"))\n\tids.Equal(ce, ds.GetClauses())\n}\n\nfunc (ids *insertDatasetSuite) TestWith() {\n\tfrom := goqu.From(\"cte\")\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.With(\"test-cte\", from),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from)),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestWithRecursive() {\n\tfrom := goqu.From(\"cte\")\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.WithRecursive(\"test-cte\", from),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(true, \"test-cte\", from)),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestInto() {\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.Into(\"items2\"),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items2\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd.Into(goqu.L(\"items2\")),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.L(\"items2\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n\n\tids.PanicsWithValue(goqu.ErrUnsupportedIntoType, func() {\n\t\tbd.Into(true)\n\t})\n}\n\nfunc (ids *insertDatasetSuite) TestCols() {\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.Cols(\"a\", \"b\"),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetCols(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Cols(\"a\", \"b\").Cols(\"c\", \"d\"),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetCols(exp.NewColumnListExpression(\"c\", \"d\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestClearCols() {\n\tbd := goqu.Insert(\"items\").Cols(\"a\", \"b\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.ClearCols(),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetCols(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestColsAppend() {\n\tbd := goqu.Insert(\"items\").Cols(\"a\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.ColsAppend(\"b\"),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetCols(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetCols(exp.NewColumnListExpression(\"a\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestFromQuery() {\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.FromQuery(goqu.From(\"other_items\").Where(goqu.C(\"b\").Gt(10))),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetFrom(goqu.From(\"other_items\").Where(goqu.C(\"b\").Gt(10))),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.FromQuery(goqu.From(\"other_items\").Where(goqu.C(\"b\").Gt(10))).Cols(\"a\", \"b\"),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetCols(exp.NewColumnListExpression(\"a\", \"b\")).\n\t\t\t\tSetFrom(goqu.From(\"other_items\").Where(goqu.C(\"b\").Gt(10))),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestFromQueryDialectInheritance() {\n\tmd := new(mocks.SQLDialect)\n\tmd.On(\"Dialect\").Return(\"dialect\")\n\n\tids.Run(\"ok, default dialect is replaced with insert dialect\", func() {\n\t\tbd := goqu.Insert(\"items\").SetDialect(md).FromQuery(goqu.From(\"other_items\"))\n\t\tids.Require().Equal(md, bd.GetClauses().From().(*goqu.SelectDataset).Dialect())\n\t})\n\n\tids.Run(\"ok, insert and select dialects coincide\", func() {\n\t\tbd := goqu.Insert(\"items\").SetDialect(md).FromQuery(goqu.From(\"other_items\").SetDialect(md))\n\t\tids.Require().Equal(md, bd.GetClauses().From().(*goqu.SelectDataset).Dialect())\n\t})\n\n\tids.Run(\"ok, insert and select dialects are default\", func() {\n\t\tbd := goqu.Insert(\"items\").FromQuery(goqu.From(\"other_items\"))\n\t\tids.Require().Equal(goqu.GetDialect(\"default\"), bd.GetClauses().From().(*goqu.SelectDataset).Dialect())\n\t})\n\n\tids.Run(\"panic, insert and select dialects are different\", func() {\n\t\tdefer func() {\n\t\t\tr := recover()\n\t\t\tif r == nil {\n\t\t\t\tids.Fail(\"there should be a panic\")\n\t\t\t}\n\t\t\tids.Require().Equal(\n\t\t\t\t\"incompatible dialects for INSERT (\\\"dialect\\\") and SELECT (\\\"other_dialect\\\")\",\n\t\t\t\tr.(error).Error(),\n\t\t\t)\n\t\t}()\n\n\t\totherDialect := new(mocks.SQLDialect)\n\t\totherDialect.On(\"Dialect\").Return(\"other_dialect\")\n\t\tgoqu.Insert(\"items\").SetDialect(md).FromQuery(goqu.From(\"otherItems\").SetDialect(otherDialect))\n\t})\n}\n\nfunc (ids *insertDatasetSuite) TestVals() {\n\tval1 := []interface{}{\n\t\t\"a\", \"b\",\n\t}\n\tval2 := []interface{}{\n\t\t\"c\", \"d\",\n\t}\n\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.Vals(val1),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetVals([][]interface{}{val1}),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Vals(val1, val2),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetVals([][]interface{}{val1, val2}),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Vals(val1).Vals(val2),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetVals([][]interface{}{val1, val2}),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestClearVals() {\n\tval := []interface{}{\n\t\t\"a\", \"b\",\n\t}\n\tbd := goqu.Insert(\"items\").Vals(val)\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.ClearVals(),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetVals([][]interface{}{val}),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestRows() {\n\ttype item struct {\n\t\tCreatedAt *time.Time `db:\"created_at\"`\n\t}\n\tn := time.Now()\n\tr := item{CreatedAt: nil}\n\tr2 := item{CreatedAt: &n}\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.Rows(r),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetRows([]interface{}{r}),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd.Rows(r).Rows(r2),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetRows([]interface{}{r2}),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestClearRows() {\n\ttype item struct {\n\t\tCreatedAt *time.Time `db:\"created_at\"`\n\t}\n\tr := item{CreatedAt: nil}\n\tbd := goqu.Insert(\"items\").Rows(r)\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.ClearRows(),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetRows([]interface{}{r}),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestOnConflict() {\n\tdu := goqu.DoUpdate(\"other_items\", goqu.Record{\"a\": 1})\n\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.OnConflict(nil),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd.OnConflict(goqu.DoNothing()),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetOnConflict(goqu.DoNothing()),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd.OnConflict(du),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetOnConflict(du),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestAs() {\n\tdu := goqu.DoUpdate(\"other_items\", goqu.Record{\"new.a\": 1})\n\n\tbd := goqu.Insert(\"items\").As(\"new\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.OnConflict(nil),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).\n\t\t\t\tSetAlias(exp.NewIdentifierExpression(\"\", \"new\", \"\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.OnConflict(goqu.DoNothing()),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).\n\t\t\t\tSetAlias(exp.NewIdentifierExpression(\"\", \"new\", \"\")).\n\t\t\t\tSetOnConflict(goqu.DoNothing()),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.OnConflict(du),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetAlias(exp.NewIdentifierExpression(\"\", \"new\", \"\")).\n\t\t\t\tSetInto(goqu.C(\"items\")).SetOnConflict(du),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetAlias(exp.NewIdentifierExpression(\"\", \"new\", \"\")).\n\t\t\t\tSetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestClearOnConflict() {\n\tdu := goqu.DoUpdate(\"other_items\", goqu.Record{\"a\": 1})\n\n\tbd := goqu.Insert(\"items\").OnConflict(du)\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds:      bd.ClearOnConflict(),\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")).SetOnConflict(du),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestReturning() {\n\tbd := goqu.Insert(\"items\")\n\tids.assertCases(\n\t\tinsertTestCase{\n\t\t\tds: bd.Returning(\"a\"),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression(\"a\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Returning(),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Returning(nil),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Returning(),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds: bd.Returning(\"a\").Returning(\"b\"),\n\t\t\tclauses: exp.NewInsertClauses().\n\t\t\t\tSetInto(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression(\"b\")),\n\t\t},\n\t\tinsertTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewInsertClauses().SetInto(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (ids *insertDatasetSuite) TestReturnsColumns() {\n\tds := goqu.Insert(\"test\")\n\tids.False(ds.ReturnsColumns())\n\tids.True(ds.Returning(\"foo\", \"bar\").ReturnsColumns())\n}\n\nfunc (ids *insertDatasetSuite) TestExecutor() {\n\tmDB, _, err := sqlmock.New()\n\tids.NoError(err)\n\n\tds := goqu.New(\"mock\", mDB).Insert(\"items\").\n\t\tRows(goqu.Record{\"address\": \"111 Test Addr\", \"name\": \"Test1\"})\n\n\tisql, args, err := ds.Executor().ToSQL()\n\tids.NoError(err)\n\tids.Empty(args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1')`, isql)\n\n\tisql, args, err = ds.Prepared(true).Executor().ToSQL()\n\tids.NoError(err)\n\tids.Equal([]interface{}{\"111 Test Addr\", \"Test1\"}, args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?)`, isql)\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\tisql, args, err = ds.Executor().ToSQL()\n\tids.NoError(err)\n\tids.Equal([]interface{}{\"111 Test Addr\", \"Test1\"}, args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?)`, isql)\n}\n\nfunc (ids *insertDatasetSuite) TestInsertStruct() {\n\tdefer goqu.SetIgnoreUntaggedFields(false)\n\n\tmDB, _, err := sqlmock.New()\n\tids.NoError(err)\n\n\titem := dsUntaggedTestActionItem{\n\t\tAddress:  \"111 Test Addr\",\n\t\tName:     \"Test1\",\n\t\tUntagged: \"Test2\",\n\t}\n\n\tds := goqu.New(\"mock\", mDB).Insert(\"items\").\n\t\tRows(item)\n\n\tisql, args, err := ds.Executor().ToSQL()\n\tids.NoError(err)\n\tids.Empty(args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\", \"untagged\") VALUES ('111 Test Addr', 'Test1', 'Test2')`, isql)\n\n\tisql, args, err = ds.Prepared(true).Executor().ToSQL()\n\tids.NoError(err)\n\tids.Equal([]interface{}{\"111 Test Addr\", \"Test1\", \"Test2\"}, args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\", \"untagged\") VALUES (?, ?, ?)`, isql)\n\n\tgoqu.SetIgnoreUntaggedFields(true)\n\n\tisql, args, err = ds.Executor().ToSQL()\n\tids.NoError(err)\n\tids.Empty(args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1')`, isql)\n\n\tisql, args, err = ds.Prepared(true).Executor().ToSQL()\n\tids.NoError(err)\n\tids.Equal([]interface{}{\"111 Test Addr\", \"Test1\"}, args)\n\tids.Equal(`INSERT INTO \"items\" (\"address\", \"name\") VALUES (?, ?)`, isql)\n}\n\nfunc (ids *insertDatasetSuite) TestToSQL() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Insert(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToInsertSQL\", sqlB, c).Return(nil).Once()\n\tinsertSQL, args, err := ds.ToSQL()\n\tids.Empty(insertSQL)\n\tids.Empty(args)\n\tids.Nil(err)\n\tmd.AssertExpectations(ids.T())\n}\n\nfunc (ids *insertDatasetSuite) TestToSQL_Prepared() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Insert(\"test\").SetDialect(md).Prepared(true)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(true)\n\tmd.On(\"ToInsertSQL\", sqlB, c).Return(nil).Once()\n\tinsertSQL, args, err := ds.ToSQL()\n\tids.Empty(insertSQL)\n\tids.Empty(args)\n\tids.Nil(err)\n\tmd.AssertExpectations(ids.T())\n}\n\nfunc (ids *insertDatasetSuite) TestToSQL_ReturnedError() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Insert(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tee := errors.New(\"expected error\")\n\tmd.On(\"ToInsertSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(ee)\n\t}).Once()\n\n\tinsertSQL, args, err := ds.ToSQL()\n\tids.Empty(insertSQL)\n\tids.Empty(args)\n\tids.Equal(ee, err)\n\tmd.AssertExpectations(ids.T())\n}\n\nfunc (ids *insertDatasetSuite) TestSetError() {\n\terr1 := errors.New(\"error #1\")\n\terr2 := errors.New(\"error #2\")\n\terr3 := errors.New(\"error #3\")\n\n\t// Verify initial error set/get works properly\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Insert(\"test\").SetDialect(md)\n\tds = ds.SetError(err1)\n\tids.Equal(err1, ds.Error())\n\tsql, args, err := ds.ToSQL()\n\tids.Empty(sql)\n\tids.Empty(args)\n\tids.Equal(err1, err)\n\n\t// Repeated SetError calls on Dataset should not overwrite the original error\n\tds = ds.SetError(err2)\n\tids.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tids.Empty(sql)\n\tids.Empty(args)\n\tids.Equal(err1, err)\n\n\t// Builder functions should not lose the error\n\tds = ds.Cols(\"a\", \"b\")\n\tids.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tids.Empty(sql)\n\tids.Empty(args)\n\tids.Equal(err1, err)\n\n\t// Deeper errors inside SQL generation should still return original error\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToInsertSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(err3)\n\t}).Once()\n\n\tsql, args, err = ds.ToSQL()\n\tids.Empty(sql)\n\tids.Empty(args)\n\tids.Equal(err1, err)\n}\n\nfunc TestInsertDataset(t *testing.T) {\n\tsuite.Run(t, new(insertDatasetSuite))\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "issues_test.go",
          "type": "blob",
          "size": 13.56640625,
          "content": "package goqu_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype githubIssuesSuite struct {\n\tsuite.Suite\n}\n\nfunc (gis *githubIssuesSuite) AfterTest(_, _ string) {\n\tgoqu.SetColumnRenameFunction(strings.ToLower)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/49\nfunc (gis *githubIssuesSuite) TestIssue49() {\n\tdialect := goqu.Dialect(\"default\")\n\n\tfilters := goqu.Or()\n\tsql, args, err := dialect.From(\"table\").Where(filters).ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(args)\n\tgis.Equal(`SELECT * FROM \"table\"`, sql)\n\n\tsql, args, err = dialect.From(\"table\").Where(goqu.Ex{}).ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(args)\n\tgis.Equal(`SELECT * FROM \"table\"`, sql)\n\n\tsql, args, err = dialect.From(\"table\").Where(goqu.ExOr{}).ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(args)\n\tgis.Equal(`SELECT * FROM \"table\"`, sql)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/115\nfunc (gis *githubIssuesSuite) TestIssue115() {\n\ttype TestStruct struct {\n\t\tField string\n\t}\n\tgoqu.SetColumnRenameFunction(func(col string) string {\n\t\treturn \"\"\n\t})\n\n\t_, _, err := goqu.Insert(\"test\").Rows(TestStruct{Field: \"hello\"}).ToSQL()\n\tgis.EqualError(err, `goqu: a empty identifier was encountered, please specify a \"schema\", \"table\" or \"column\"`)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/118\nfunc (gis *githubIssuesSuite) TestIssue118_withEmbeddedStructWithoutExportedFields() {\n\t// struct is in a custom package\n\ttype SimpleRole struct {\n\t\tpermissions []string //nolint:structcheck,unused //needed for test\n\t}\n\n\t// .....\n\n\ttype Role struct {\n\t\t*SimpleRole\n\n\t\tID        string    `json:\"id\" db:\"id\" goqu:\"skipinsert\"`\n\t\tKey       string    `json:\"key\" db:\"key\"`\n\t\tName      string    `json:\"name\" db:\"name\"`\n\t\tCreatedAt time.Time `json:\"-\" db:\"created_at\" goqu:\"skipinsert\"`\n\t}\n\n\trUser := &Role{\n\t\tKey:  `user`,\n\t\tName: `User role`,\n\t}\n\n\tsql, arg, err := goqu.Insert(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tRows(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(`INSERT INTO \"rbac_roles\" (\"key\", \"name\") VALUES ('user', 'User role') RETURNING \"id\"`, sql)\n\n\tsql, arg, err = goqu.Update(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tSet(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(\n\t\t`UPDATE \"rbac_roles\" SET \"created_at\"='0001-01-01T00:00:00Z',\"id\"='',\"key\"='user',\"name\"='User role' RETURNING \"id\"`,\n\t\tsql,\n\t)\n\n\trUser = &Role{\n\t\tSimpleRole: &SimpleRole{},\n\t\tKey:        `user`,\n\t\tName:       `User role`,\n\t}\n\n\tsql, arg, err = goqu.Insert(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tRows(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(`INSERT INTO \"rbac_roles\" (\"key\", \"name\") VALUES ('user', 'User role') RETURNING \"id\"`, sql)\n\n\tsql, arg, err = goqu.Update(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tSet(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(\n\t\t`UPDATE \"rbac_roles\" SET `+\n\t\t\t`\"created_at\"='0001-01-01T00:00:00Z',\"id\"='',\"key\"='user',\"name\"='User role' RETURNING \"id\"`,\n\t\tsql,\n\t)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/118\nfunc (gis *githubIssuesSuite) TestIssue118_withNilEmbeddedStructWithExportedFields() {\n\t// struct is in a custom package\n\ttype SimpleRole struct {\n\t\tpermissions []string //nolint:structcheck,unused // needed for test\n\t\tIDStr       string\n\t}\n\n\t// .....\n\n\ttype Role struct {\n\t\t*SimpleRole\n\n\t\tID        string    `json:\"id\" db:\"id\" goqu:\"skipinsert\"`\n\t\tKey       string    `json:\"key\" db:\"key\"`\n\t\tName      string    `json:\"name\" db:\"name\"`\n\t\tCreatedAt time.Time `json:\"-\" db:\"created_at\" goqu:\"skipinsert\"`\n\t}\n\n\trUser := &Role{\n\t\tKey:  `user`,\n\t\tName: `User role`,\n\t}\n\tsql, arg, err := goqu.Insert(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tRows(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\t// it should not insert fields on nil embedded pointers\n\tgis.Equal(`INSERT INTO \"rbac_roles\" (\"key\", \"name\") VALUES ('user', 'User role') RETURNING \"id\"`, sql)\n\n\tsql, arg, err = goqu.Update(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tSet(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\t// it should not insert fields on nil embedded pointers\n\tgis.Equal(\n\t\t`UPDATE \"rbac_roles\" SET \"created_at\"='0001-01-01T00:00:00Z',\"id\"='',\"key\"='user',\"name\"='User role' RETURNING \"id\"`,\n\t\tsql,\n\t)\n\n\trUser = &Role{\n\t\tSimpleRole: &SimpleRole{},\n\t\tKey:        `user`,\n\t\tName:       `User role`,\n\t}\n\tsql, arg, err = goqu.Insert(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tRows(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\t// it should not insert fields on nil embedded pointers\n\tgis.Equal(\n\t\t`INSERT INTO \"rbac_roles\" (\"idstr\", \"key\", \"name\") VALUES ('', 'user', 'User role') RETURNING \"id\"`,\n\t\tsql,\n\t)\n\n\tsql, arg, err = goqu.Update(`rbac_roles`).\n\t\tReturning(goqu.C(`id`)).\n\t\tSet(rUser).\n\t\tToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\t// it should not insert fields on nil embedded pointers\n\tgis.Equal(\n\t\t`UPDATE \"rbac_roles\" SET `+\n\t\t\t`\"created_at\"='0001-01-01T00:00:00Z',\"id\"='',\"idstr\"='',\"key\"='user',\"name\"='User role' RETURNING \"id\"`,\n\t\tsql,\n\t)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/118\nfunc (gis *githubIssuesSuite) TestIssue140() {\n\tsql, arg, err := goqu.Insert(`test`).Returning().ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(`INSERT INTO \"test\" DEFAULT VALUES`, sql)\n\n\tsql, arg, err = goqu.Update(`test`).Set(goqu.Record{\"a\": \"b\"}).Returning().ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(\n\t\t`UPDATE \"test\" SET \"a\"='b'`,\n\t\tsql,\n\t)\n\n\tsql, arg, err = goqu.Delete(`test`).Returning().ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(\n\t\t`DELETE FROM \"test\"`,\n\t\tsql,\n\t)\n\n\tsql, arg, err = goqu.Insert(`test`).Returning(nil).ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(`INSERT INTO \"test\" DEFAULT VALUES`, sql)\n\n\tsql, arg, err = goqu.Update(`test`).Set(goqu.Record{\"a\": \"b\"}).Returning(nil).ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(\n\t\t`UPDATE \"test\" SET \"a\"='b'`,\n\t\tsql,\n\t)\n\n\tsql, arg, err = goqu.Delete(`test`).Returning(nil).ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(arg)\n\tgis.Equal(\n\t\t`DELETE FROM \"test\"`,\n\t\tsql,\n\t)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/164\nfunc (gis *githubIssuesSuite) TestIssue164() {\n\tinsertDs := goqu.Insert(\"foo\").Rows(goqu.Record{\"user_id\": 10}).Returning(\"id\")\n\n\tds := goqu.From(\"bar\").\n\t\tWith(\"ins\", insertDs).\n\t\tSelect(\"bar_name\").\n\t\tWhere(goqu.Ex{\"bar.user_id\": goqu.I(\"ins.user_id\")})\n\n\tsql, args, err := ds.ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(args)\n\tgis.Equal(\n\t\t`WITH ins AS (INSERT INTO \"foo\" (\"user_id\") VALUES (10) RETURNING \"id\") `+\n\t\t\t`SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"ins\".\"user_id\")`,\n\t\tsql,\n\t)\n\n\tsql, args, err = ds.Prepared(true).ToSQL()\n\tgis.NoError(err)\n\tgis.Equal([]interface{}{int64(10)}, args)\n\tgis.Equal(\n\t\t`WITH ins AS (INSERT INTO \"foo\" (\"user_id\") VALUES (?) RETURNING \"id\")`+\n\t\t\t` SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"ins\".\"user_id\")`,\n\t\tsql,\n\t)\n\n\tupdateDs := goqu.Update(\"foo\").Set(goqu.Record{\"bar\": \"baz\"}).Returning(\"id\")\n\n\tds = goqu.From(\"bar\").\n\t\tWith(\"upd\", updateDs).\n\t\tSelect(\"bar_name\").\n\t\tWhere(goqu.Ex{\"bar.user_id\": goqu.I(\"upd.user_id\")})\n\n\tsql, args, err = ds.ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(args)\n\tgis.Equal(\n\t\t`WITH upd AS (UPDATE \"foo\" SET \"bar\"='baz' RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"upd\".\"user_id\")`,\n\t\tsql,\n\t)\n\n\tsql, args, err = ds.Prepared(true).ToSQL()\n\tgis.NoError(err)\n\tgis.Equal([]interface{}{\"baz\"}, args)\n\tgis.Equal(\n\t\t`WITH upd AS (UPDATE \"foo\" SET \"bar\"=? RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"upd\".\"user_id\")`,\n\t\tsql,\n\t)\n\n\tdeleteDs := goqu.Delete(\"foo\").Where(goqu.Ex{\"bar\": \"baz\"}).Returning(\"id\")\n\n\tds = goqu.From(\"bar\").\n\t\tWith(\"del\", deleteDs).\n\t\tSelect(\"bar_name\").\n\t\tWhere(goqu.Ex{\"bar.user_id\": goqu.I(\"del.user_id\")})\n\n\tsql, args, err = ds.ToSQL()\n\tgis.NoError(err)\n\tgis.Empty(args)\n\tgis.Equal(\n\t\t`WITH del AS (DELETE FROM \"foo\" WHERE (\"bar\" = 'baz') RETURNING \"id\")`+\n\t\t\t` SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"del\".\"user_id\")`,\n\t\tsql,\n\t)\n\n\tsql, args, err = ds.Prepared(true).ToSQL()\n\tgis.NoError(err)\n\tgis.Equal([]interface{}{\"baz\"}, args)\n\tgis.Equal(\n\t\t`WITH del AS (DELETE FROM \"foo\" WHERE (\"bar\" = ?) RETURNING \"id\")`+\n\t\t\t` SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"del\".\"user_id\")`,\n\t\tsql,\n\t)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/177\nfunc (gis *githubIssuesSuite) TestIssue177() {\n\tds := goqu.Dialect(\"postgres\").\n\t\tFrom(\"ins1\").\n\t\tWith(\"ins1\",\n\t\t\tgoqu.Dialect(\"postgres\").\n\t\t\t\tInsert(\"account\").\n\t\t\t\tRows(goqu.Record{\"email\": \"email@email.com\", \"status\": \"active\", \"uuid\": \"XXX-XXX-XXXX\"}).\n\t\t\t\tReturning(\"*\"),\n\t\t).\n\t\tWith(\"ins2\",\n\t\t\tgoqu.Dialect(\"postgres\").\n\t\t\t\tInsert(\"account_user\").\n\t\t\t\tCols(\"account_id\", \"user_id\").\n\t\t\t\tFromQuery(goqu.Dialect(\"postgres\").\n\t\t\t\t\tFrom(\"ins1\").\n\t\t\t\t\tSelect(\n\t\t\t\t\t\t\"id\",\n\t\t\t\t\t\tgoqu.V(1001),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t).\n\t\tSelect(\"*\")\n\tsql, args, err := ds.ToSQL()\n\tgis.NoError(err)\n\tgis.Equal(`WITH ins1 AS (`+\n\t\t`INSERT INTO \"account\" (\"email\", \"status\", \"uuid\") VALUES ('email@email.com', 'active', 'XXX-XXX-XXXX') RETURNING *),`+\n\t\t` ins2 AS (INSERT INTO \"account_user\" (\"account_id\", \"user_id\") SELECT \"id\", 1001 FROM \"ins1\")`+\n\t\t` SELECT * FROM \"ins1\"`, sql)\n\tgis.Len(args, 0)\n\n\tsql, args, err = ds.Prepared(true).ToSQL()\n\tgis.NoError(err)\n\tgis.Equal(`WITH ins1 AS (INSERT INTO \"account\" (\"email\", \"status\", \"uuid\") VALUES ($1, $2, $3) RETURNING *), ins2`+\n\t\t` AS (INSERT INTO \"account_user\" (\"account_id\", \"user_id\") SELECT \"id\", $4 FROM \"ins1\") SELECT * FROM \"ins1\"`, sql)\n\tgis.Equal(args, []interface{}{\"email@email.com\", \"active\", \"XXX-XXX-XXXX\", int64(1001)})\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/183\nfunc (gis *githubIssuesSuite) TestIssue184() {\n\texpectedErr := fmt.Errorf(\"an error\")\n\ttestCases := []struct {\n\t\tds exp.AppendableExpression\n\t}{\n\t\t{ds: goqu.From(\"test\").As(\"t\").SetError(expectedErr)},\n\t\t{ds: goqu.Insert(\"test\").Rows(goqu.Record{\"foo\": \"bar\"}).Returning(\"foo\").SetError(expectedErr)},\n\t\t{ds: goqu.Update(\"test\").Set(goqu.Record{\"foo\": \"bar\"}).Returning(\"foo\").SetError(expectedErr)},\n\t\t{ds: goqu.Update(\"test\").Set(goqu.Record{\"foo\": \"bar\"}).Returning(\"foo\").SetError(expectedErr)},\n\t\t{ds: goqu.Delete(\"test\").Returning(\"foo\").SetError(expectedErr)},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tds := goqu.From(tc.ds)\n\t\tsql, args, err := ds.ToSQL()\n\t\tgis.Equal(expectedErr, err)\n\t\tgis.Empty(sql)\n\t\tgis.Empty(args)\n\n\t\tsql, args, err = ds.Prepared(true).ToSQL()\n\t\tgis.Equal(expectedErr, err)\n\t\tgis.Empty(sql)\n\t\tgis.Empty(args)\n\n\t\tds = goqu.From(\"test2\").Where(goqu.Ex{\"foo\": tc.ds})\n\n\t\tsql, args, err = ds.ToSQL()\n\t\tgis.Equal(expectedErr, err)\n\t\tgis.Empty(sql)\n\t\tgis.Empty(args)\n\n\t\tsql, args, err = ds.Prepared(true).ToSQL()\n\t\tgis.Equal(expectedErr, err)\n\t\tgis.Empty(sql)\n\t\tgis.Empty(args)\n\t}\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/185\nfunc (gis *githubIssuesSuite) TestIssue185() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tgis.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \\* FROM \\(SELECT \"id\" FROM \"table\" ORDER BY \"id\" ASC\\) AS \"t1\" UNION \n\\(SELECT \\* FROM \\(SELECT \"id\" FROM \"table\" ORDER BY \"id\" ASC\\) AS \"t1\"\\)`,\n\t).\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n\"))\n\tdb := goqu.New(\"mock\", mDB)\n\n\tds := db.Select(\"id\").From(\"table\").Order(goqu.C(\"id\").Asc()).\n\t\tUnion(\n\t\t\tdb.Select(\"id\").From(\"table\").Order(goqu.C(\"id\").Asc()),\n\t\t)\n\n\tctx := context.Background()\n\tvar i []int\n\tgis.NoError(ds.ScanValsContext(ctx, &i))\n\tgis.Equal([]int{1, 2, 3, 4}, i)\n}\n\n// Test for https://github.com/doug-martin/goqu/issues/203\nfunc (gis *githubIssuesSuite) TestIssue203() {\n\t// Schema definitions.\n\tauthSchema := goqu.S(\"company_auth\")\n\n\t// Table definitions\n\tusersTable := authSchema.Table(\"users\")\n\n\tu := usersTable.As(\"u\")\n\n\tds := goqu.From(u).Select(\n\t\tu.Col(\"id\"),\n\t\tu.Col(\"name\"),\n\t\tu.Col(\"created_at\"),\n\t\tu.Col(\"updated_at\"),\n\t)\n\n\tsql, args, err := ds.ToSQL()\n\tgis.NoError(err)\n\tgis.Equal(`SELECT \"u\".\"id\", \"u\".\"name\", \"u\".\"created_at\", \"u\".\"updated_at\" FROM \"company_auth\".\"users\" AS \"u\"`, sql)\n\tgis.Empty(args, []interface{}{})\n\n\tsql, args, err = ds.Prepared(true).ToSQL()\n\tgis.NoError(err)\n\tgis.Equal(`SELECT \"u\".\"id\", \"u\".\"name\", \"u\".\"created_at\", \"u\".\"updated_at\" FROM \"company_auth\".\"users\" AS \"u\"`, sql)\n\tgis.Empty(args, []interface{}{})\n}\n\nfunc (gis *githubIssuesSuite) TestIssue290() {\n\ttype OcomModel struct {\n\t\tID           uint      `json:\"id\" db:\"id\" goqu:\"skipinsert\"`\n\t\tCreatedDate  time.Time `json:\"created_date\" db:\"created_date\" goqu:\"skipupdate\"`\n\t\tModifiedDate time.Time `json:\"modified_date\" db:\"modified_date\"`\n\t}\n\n\ttype ActiveModel struct {\n\t\tOcomModel\n\t\tActiveStartDate time.Time  `json:\"active_start_date\" db:\"active_start_date\"`\n\t\tActiveEndDate   *time.Time `json:\"active_end_date\" db:\"active_end_date\"`\n\t}\n\n\ttype CodeModel struct {\n\t\tActiveModel\n\n\t\tCode        string `json:\"code\" db:\"code\"`\n\t\tDescription string `json:\"description\" binding:\"required\" db:\"description\"`\n\t}\n\n\ttype CodeExample struct {\n\t\tCodeModel\n\t}\n\n\tvar item CodeExample\n\titem.Code = \"Code\"\n\titem.Description = \"Description\"\n\titem.ID = 1 // Value set HERE!\n\titem.CreatedDate = time.Date(\n\t\t2021, 1, 1, 1, 1, 1, 1, time.UTC)\n\titem.ModifiedDate = time.Date(\n\t\t2021, 2, 2, 2, 2, 2, 2, time.UTC) // The Value we Get!\n\titem.ActiveStartDate = time.Date(\n\t\t2021, 3, 3, 3, 3, 3, 3, time.UTC)\n\n\tupdateQuery := goqu.From(\"example\").Update().Set(item).Where(goqu.C(\"id\").Eq(1))\n\n\tsql, params, err := updateQuery.ToSQL()\n\n\tgis.NoError(err)\n\tgis.Empty(params)\n\tgis.Equal(`UPDATE \"example\" SET \"active_end_date\"=NULL,\"active_start_date\"='2021-03-03T03:03:03.000000003Z',\"code\"='Code',\"description\"='Description',\"id\"=1,\"modified_date\"='2021-02-02T02:02:02.000000002Z' WHERE (\"id\" = 1)`, sql) //nolint:lll\n}\n\nfunc TestGithubIssuesSuite(t *testing.T) {\n\tsuite.Run(t, new(githubIssuesSuite))\n}\n"
        },
        {
          "name": "mocks",
          "type": "tree",
          "content": null
        },
        {
          "name": "prepared.go",
          "type": "blob",
          "size": 1.13671875,
          "content": "package goqu\n\nvar (\n\t// defaultPrepared is controlled by SetDefaultPrepared\n\tdefaultPrepared bool\n)\n\ntype prepared int\n\nconst (\n\t// zero value that defers to defaultPrepared\n\tpreparedNoPreference prepared = iota\n\n\t// explicitly enabled via Prepared(true) on a dataset\n\tpreparedEnabled\n\n\t// explicitly disabled via Prepared(false) on a dataset\n\tpreparedDisabled\n)\n\n// Bool converts the ternary prepared state into a boolean. If the prepared\n// state is preparedNoPreference, the value depends on the last value that\n// SetDefaultPrepared was called with which is false by default.\nfunc (p prepared) Bool() bool {\n\tif p == preparedNoPreference {\n\t\treturn defaultPrepared\n\t} else if p == preparedEnabled {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// preparedFromBool converts a bool from e.g. Prepared(true) into a prepared\n// const.\nfunc preparedFromBool(prepared bool) prepared {\n\tif prepared {\n\t\treturn preparedEnabled\n\t}\n\n\treturn preparedDisabled\n}\n\n// SetDefaultPrepared controls the default Prepared state of all datasets. If\n// set to true, any new dataset will use prepared queries by default.\nfunc SetDefaultPrepared(prepared bool) {\n\tdefaultPrepared = prepared\n}\n"
        },
        {
          "name": "select_dataset.go",
          "type": "blob",
          "size": 25.1455078125,
          "content": "package goqu\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/doug-martin/goqu/v9/exec\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n)\n\n// Dataset for creating and/or executing SELECT SQL statements.\ntype SelectDataset struct {\n\tdialect      SQLDialect\n\tclauses      exp.SelectClauses\n\tisPrepared   prepared\n\tqueryFactory exec.QueryFactory\n\terr          error\n}\n\nvar ErrQueryFactoryNotFoundError = errors.New(\n\t\"unable to execute query did you use goqu.Database#From to create the dataset\",\n)\n\n// used internally by database to create a database with a specific adapter\nfunc newDataset(d string, queryFactory exec.QueryFactory) *SelectDataset {\n\treturn &SelectDataset{\n\t\tclauses:      exp.NewSelectClauses(),\n\t\tdialect:      GetDialect(d),\n\t\tqueryFactory: queryFactory,\n\t}\n}\n\nfunc From(table ...interface{}) *SelectDataset {\n\treturn newDataset(\"default\", nil).From(table...)\n}\n\nfunc Select(cols ...interface{}) *SelectDataset {\n\treturn newDataset(\"default\", nil).Select(cols...)\n}\n\n// Sets the adapter used to serialize values and create the SQL statement\nfunc (sd *SelectDataset) WithDialect(dl string) *SelectDataset {\n\tds := sd.copy(sd.GetClauses())\n\tds.dialect = GetDialect(dl)\n\treturn ds\n}\n\n// Set the parameter interpolation behavior. See examples\n//\n// prepared: If true the dataset WILL NOT interpolate the parameters.\nfunc (sd *SelectDataset) Prepared(prepared bool) *SelectDataset {\n\tret := sd.copy(sd.clauses)\n\tret.isPrepared = preparedFromBool(prepared)\n\treturn ret\n}\n\nfunc (sd *SelectDataset) IsPrepared() bool {\n\treturn sd.isPrepared.Bool()\n}\n\n// Returns the current adapter on the dataset\nfunc (sd *SelectDataset) Dialect() SQLDialect {\n\treturn sd.dialect\n}\n\n// Returns the current adapter on the dataset\nfunc (sd *SelectDataset) SetDialect(dialect SQLDialect) *SelectDataset {\n\tcd := sd.copy(sd.GetClauses())\n\tcd.dialect = dialect\n\treturn cd\n}\n\nfunc (sd *SelectDataset) Expression() exp.Expression {\n\treturn sd\n}\n\n// Clones the dataset\nfunc (sd *SelectDataset) Clone() exp.Expression {\n\treturn sd.copy(sd.clauses)\n}\n\n// Returns the current clauses on the dataset.\nfunc (sd *SelectDataset) GetClauses() exp.SelectClauses {\n\treturn sd.clauses\n}\n\n// used interally to copy the dataset\nfunc (sd *SelectDataset) copy(clauses exp.SelectClauses) *SelectDataset {\n\treturn &SelectDataset{\n\t\tdialect:      sd.dialect,\n\t\tclauses:      clauses,\n\t\tisPrepared:   sd.isPrepared,\n\t\tqueryFactory: sd.queryFactory,\n\t\terr:          sd.err,\n\t}\n}\n\n// Creates a new UpdateDataset using the FROM of this dataset. This method will also copy over the `WITH`, `WHERE`,\n// `ORDER , and `LIMIT`\nfunc (sd *SelectDataset) Update() *UpdateDataset {\n\tu := newUpdateDataset(sd.dialect.Dialect(), sd.queryFactory).\n\t\tPrepared(sd.isPrepared.Bool())\n\tif sd.clauses.HasSources() {\n\t\tu = u.Table(sd.GetClauses().From().Columns()[0])\n\t}\n\tc := u.clauses\n\tfor _, ce := range sd.clauses.CommonTables() {\n\t\tc = c.CommonTablesAppend(ce)\n\t}\n\tif sd.clauses.Where() != nil {\n\t\tc = c.WhereAppend(sd.clauses.Where())\n\t}\n\tif sd.clauses.HasLimit() {\n\t\tc = c.SetLimit(sd.clauses.Limit())\n\t}\n\tif sd.clauses.HasOrder() {\n\t\tfor _, oe := range sd.clauses.Order().Columns() {\n\t\t\tc = c.OrderAppend(oe.(exp.OrderedExpression))\n\t\t}\n\t}\n\tu.clauses = c\n\treturn u\n}\n\n// Creates a new InsertDataset using the FROM of this dataset. This method will also copy over the `WITH` clause to the\n// insert.\nfunc (sd *SelectDataset) Insert() *InsertDataset {\n\ti := newInsertDataset(sd.dialect.Dialect(), sd.queryFactory).\n\t\tPrepared(sd.isPrepared.Bool())\n\tif sd.clauses.HasSources() {\n\t\ti = i.Into(sd.GetClauses().From().Columns()[0])\n\t}\n\tc := i.clauses\n\tfor _, ce := range sd.clauses.CommonTables() {\n\t\tc = c.CommonTablesAppend(ce)\n\t}\n\ti.clauses = c\n\treturn i\n}\n\n// Creates a new DeleteDataset using the FROM of this dataset. This method will also copy over the `WITH`, `WHERE`,\n// `ORDER , and `LIMIT`\nfunc (sd *SelectDataset) Delete() *DeleteDataset {\n\td := newDeleteDataset(sd.dialect.Dialect(), sd.queryFactory).\n\t\tPrepared(sd.isPrepared.Bool())\n\tif sd.clauses.HasSources() {\n\t\td = d.From(sd.clauses.From().Columns()[0])\n\t}\n\tc := d.clauses\n\tfor _, ce := range sd.clauses.CommonTables() {\n\t\tc = c.CommonTablesAppend(ce)\n\t}\n\tif sd.clauses.Where() != nil {\n\t\tc = c.WhereAppend(sd.clauses.Where())\n\t}\n\tif sd.clauses.HasLimit() {\n\t\tc = c.SetLimit(sd.clauses.Limit())\n\t}\n\tif sd.clauses.HasOrder() {\n\t\tfor _, oe := range sd.clauses.Order().Columns() {\n\t\t\tc = c.OrderAppend(oe.(exp.OrderedExpression))\n\t\t}\n\t}\n\td.clauses = c\n\treturn d\n}\n\n// Creates a new TruncateDataset using the FROM of this dataset.\nfunc (sd *SelectDataset) Truncate() *TruncateDataset {\n\ttd := newTruncateDataset(sd.dialect.Dialect(), sd.queryFactory)\n\tif sd.clauses.HasSources() {\n\t\ttd = td.Table(sd.clauses.From())\n\t}\n\treturn td\n}\n\n// Creates a WITH clause for a common table expression (CTE).\n//\n// The name will be available to SELECT from in the associated query; and can optionally\n// contain a list of column names \"name(col1, col2, col3)\".\n//\n// The name will refer to the results of the specified subquery.\nfunc (sd *SelectDataset) With(name string, subquery exp.Expression) *SelectDataset {\n\treturn sd.copy(sd.clauses.CommonTablesAppend(exp.NewCommonTableExpression(false, name, subquery)))\n}\n\n// Creates a WITH RECURSIVE clause for a common table expression (CTE)\n//\n// The name will be available to SELECT from in the associated query; and must\n// contain a list of column names \"name(col1, col2, col3)\" for a recursive clause.\n//\n// The name will refer to the results of the specified subquery. The subquery for\n// a recursive query will always end with a UNION or UNION ALL with a clause that\n// refers to the CTE by name.\nfunc (sd *SelectDataset) WithRecursive(name string, subquery exp.Expression) *SelectDataset {\n\treturn sd.copy(sd.clauses.CommonTablesAppend(exp.NewCommonTableExpression(true, name, subquery)))\n}\n\n// Replaces columns of the SELECT clause. Empty list resets the clause. See examples\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tDataset: Will use the SQL generated from that Dataset. If the dataset is aliased it will use that alias as the\n//\tcolumn name.\n//\tLiteralExpression: (See Literal) Will use the literal SQL\n//\tSQLFunction: (See Func, MIN, MAX, COUNT....)\n//\tStruct: If passing in an instance of a struct, we will parse the struct for the column names to select.\n//\tSee examples\nfunc (sd *SelectDataset) Select(selects ...interface{}) *SelectDataset {\n\tif len(selects) == 0 {\n\t\treturn sd.ClearSelect()\n\t}\n\treturn sd.copy(sd.clauses.SetSelect(exp.NewColumnListExpression(selects...)))\n}\n\n// Replaces columns of the SELECT DISTINCT clause. Empty list resets the clause. See examples\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tDataset: Will use the SQL generated from that Dataset. If the dataset is aliased it will use that alias as the\n//\tcolumn name.\n//\tLiteralExpression: (See Literal) Will use the literal SQL\n//\tSQLFunction: (See Func, MIN, MAX, COUNT....)\n//\tStruct: If passing in an instance of a struct, we will parse the struct for the column names to select.\n//\tSee examples\n//\n// Deprecated: Use Distinct() instead.\nfunc (sd *SelectDataset) SelectDistinct(selects ...interface{}) *SelectDataset {\n\tif len(selects) == 0 {\n\t\tcleared := sd.ClearSelect()\n\t\treturn cleared.copy(cleared.clauses.SetDistinct(nil))\n\t}\n\treturn sd.copy(sd.clauses.SetSelect(exp.NewColumnListExpression(selects...)).SetDistinct(exp.NewColumnListExpression()))\n}\n\n// Resets to SELECT *. If the SelectDistinct or Distinct was used the returned Dataset will have the the dataset set to SELECT *.\n// See examples.\nfunc (sd *SelectDataset) ClearSelect() *SelectDataset {\n\treturn sd.copy(sd.clauses.SetSelect(exp.NewColumnListExpression(exp.Star())).SetDistinct(nil))\n}\n\n// Adds columns to the SELECT clause. See examples\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tDataset: Will use the SQL generated from that Dataset. If the dataset is aliased it will use that alias as the\n//\tcolumn name.\n//\tLiteralExpression: (See Literal) Will use the literal SQL\n//\tSQLFunction: (See Func, MIN, MAX, COUNT....)\nfunc (sd *SelectDataset) SelectAppend(selects ...interface{}) *SelectDataset {\n\treturn sd.copy(sd.clauses.SelectAppend(exp.NewColumnListExpression(selects...)))\n}\n\nfunc (sd *SelectDataset) Distinct(on ...interface{}) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetDistinct(exp.NewColumnListExpression(on...)))\n}\n\n// Adds a FROM clause. This return a new dataset with the original sources replaced. See examples.\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tDataset: Will be added as a sub select. If the Dataset is not aliased it will automatically be aliased\n//\tLiteralExpression: (See Literal) Will use the literal SQL\nfunc (sd *SelectDataset) From(from ...interface{}) *SelectDataset {\n\tvar sources []interface{}\n\tnumSources := 0\n\tfor _, source := range from {\n\t\tif ds, ok := source.(*SelectDataset); ok && !ds.clauses.HasAlias() {\n\t\t\tnumSources++\n\t\t\tsources = append(sources, ds.As(fmt.Sprintf(\"t%d\", numSources)))\n\t\t} else {\n\t\t\tsources = append(sources, source)\n\t\t}\n\t}\n\treturn sd.copy(sd.clauses.SetFrom(exp.NewColumnListExpression(sources...)))\n}\n\n// Returns a new Dataset with the current one as an source. If the current Dataset is not aliased (See Dataset#As) then\n// it will automatically be aliased. See examples.\nfunc (sd *SelectDataset) FromSelf() *SelectDataset {\n\treturn sd.copy(exp.NewSelectClauses()).From(sd)\n}\n\n// Alias to InnerJoin. See examples.\nfunc (sd *SelectDataset) Join(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.InnerJoin(table, condition)\n}\n\n// Adds an INNER JOIN clause. See examples.\nfunc (sd *SelectDataset) InnerJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.InnerJoinType, table, condition))\n}\n\n// Adds a FULL OUTER JOIN clause. See examples.\nfunc (sd *SelectDataset) FullOuterJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.FullOuterJoinType, table, condition))\n}\n\n// Adds a RIGHT OUTER JOIN clause. See examples.\nfunc (sd *SelectDataset) RightOuterJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.RightOuterJoinType, table, condition))\n}\n\n// Adds a LEFT OUTER JOIN clause. See examples.\nfunc (sd *SelectDataset) LeftOuterJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.LeftOuterJoinType, table, condition))\n}\n\n// Adds a FULL JOIN clause. See examples.\nfunc (sd *SelectDataset) FullJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.FullJoinType, table, condition))\n}\n\n// Adds a RIGHT JOIN clause. See examples.\nfunc (sd *SelectDataset) RightJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.RightJoinType, table, condition))\n}\n\n// Adds a LEFT JOIN clause. See examples.\nfunc (sd *SelectDataset) LeftJoin(table exp.Expression, condition exp.JoinCondition) *SelectDataset {\n\treturn sd.joinTable(exp.NewConditionedJoinExpression(exp.LeftJoinType, table, condition))\n}\n\n// Adds a NATURAL JOIN clause. See examples.\nfunc (sd *SelectDataset) NaturalJoin(table exp.Expression) *SelectDataset {\n\treturn sd.joinTable(exp.NewUnConditionedJoinExpression(exp.NaturalJoinType, table))\n}\n\n// Adds a NATURAL LEFT JOIN clause. See examples.\nfunc (sd *SelectDataset) NaturalLeftJoin(table exp.Expression) *SelectDataset {\n\treturn sd.joinTable(exp.NewUnConditionedJoinExpression(exp.NaturalLeftJoinType, table))\n}\n\n// Adds a NATURAL RIGHT JOIN clause. See examples.\nfunc (sd *SelectDataset) NaturalRightJoin(table exp.Expression) *SelectDataset {\n\treturn sd.joinTable(exp.NewUnConditionedJoinExpression(exp.NaturalRightJoinType, table))\n}\n\n// Adds a NATURAL FULL JOIN clause. See examples.\nfunc (sd *SelectDataset) NaturalFullJoin(table exp.Expression) *SelectDataset {\n\treturn sd.joinTable(exp.NewUnConditionedJoinExpression(exp.NaturalFullJoinType, table))\n}\n\n// Adds a CROSS JOIN clause. See examples.\nfunc (sd *SelectDataset) CrossJoin(table exp.Expression) *SelectDataset {\n\treturn sd.joinTable(exp.NewUnConditionedJoinExpression(exp.CrossJoinType, table))\n}\n\n// Joins this Datasets table with another\nfunc (sd *SelectDataset) joinTable(join exp.JoinExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.JoinsAppend(join))\n}\n\n// Adds a WHERE clause. See examples.\nfunc (sd *SelectDataset) Where(expressions ...exp.Expression) *SelectDataset {\n\treturn sd.copy(sd.clauses.WhereAppend(expressions...))\n}\n\n// Removes the WHERE clause. See examples.\nfunc (sd *SelectDataset) ClearWhere() *SelectDataset {\n\treturn sd.copy(sd.clauses.ClearWhere())\n}\n\n// Adds a FOR UPDATE clause. See examples.\nfunc (sd *SelectDataset) ForUpdate(waitOption exp.WaitOption, of ...exp.IdentifierExpression) *SelectDataset {\n\treturn sd.withLock(exp.ForUpdate, waitOption, of...)\n}\n\n// Adds a FOR NO KEY UPDATE clause. See examples.\nfunc (sd *SelectDataset) ForNoKeyUpdate(waitOption exp.WaitOption, of ...exp.IdentifierExpression) *SelectDataset {\n\treturn sd.withLock(exp.ForNoKeyUpdate, waitOption, of...)\n}\n\n// Adds a FOR KEY SHARE clause. See examples.\nfunc (sd *SelectDataset) ForKeyShare(waitOption exp.WaitOption, of ...exp.IdentifierExpression) *SelectDataset {\n\treturn sd.withLock(exp.ForKeyShare, waitOption, of...)\n}\n\n// Adds a FOR SHARE clause. See examples.\nfunc (sd *SelectDataset) ForShare(waitOption exp.WaitOption, of ...exp.IdentifierExpression) *SelectDataset {\n\treturn sd.withLock(exp.ForShare, waitOption, of...)\n}\n\nfunc (sd *SelectDataset) withLock(strength exp.LockStrength, option exp.WaitOption, of ...exp.IdentifierExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetLock(exp.NewLock(strength, option, of...)))\n}\n\n// Adds a GROUP BY clause. See examples.\nfunc (sd *SelectDataset) GroupBy(groupBy ...interface{}) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetGroupBy(exp.NewColumnListExpression(groupBy...)))\n}\n\n// Adds more columns to the current GROUP BY clause. See examples.\nfunc (sd *SelectDataset) GroupByAppend(groupBy ...interface{}) *SelectDataset {\n\treturn sd.copy(sd.clauses.GroupByAppend(exp.NewColumnListExpression(groupBy...)))\n}\n\n// Adds a HAVING clause. See examples.\nfunc (sd *SelectDataset) Having(expressions ...exp.Expression) *SelectDataset {\n\treturn sd.copy(sd.clauses.HavingAppend(expressions...))\n}\n\n// Adds a ORDER clause. If the ORDER is currently set it replaces it. See examples.\nfunc (sd *SelectDataset) Order(order ...exp.OrderedExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetOrder(order...))\n}\n\n// Adds a more columns to the current ORDER BY clause. If no order has be previously specified it is the same as\n// calling Order. See examples.\nfunc (sd *SelectDataset) OrderAppend(order ...exp.OrderedExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.OrderAppend(order...))\n}\n\n// Adds a more columns to the beginning of the current ORDER BY clause. If no order has be previously specified it is the same as\n// calling Order. See examples.\nfunc (sd *SelectDataset) OrderPrepend(order ...exp.OrderedExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.OrderPrepend(order...))\n}\n\n// Removes the ORDER BY clause. See examples.\nfunc (sd *SelectDataset) ClearOrder() *SelectDataset {\n\treturn sd.copy(sd.clauses.ClearOrder())\n}\n\n// Adds a LIMIT clause. If the LIMIT is currently set it replaces it. See examples.\nfunc (sd *SelectDataset) Limit(limit uint) *SelectDataset {\n\tif limit > 0 {\n\t\treturn sd.copy(sd.clauses.SetLimit(limit))\n\t}\n\treturn sd.copy(sd.clauses.ClearLimit())\n}\n\n// Adds a LIMIT ALL clause. If the LIMIT is currently set it replaces it. See examples.\nfunc (sd *SelectDataset) LimitAll() *SelectDataset {\n\treturn sd.copy(sd.clauses.SetLimit(L(\"ALL\")))\n}\n\n// Removes the LIMIT clause.\nfunc (sd *SelectDataset) ClearLimit() *SelectDataset {\n\treturn sd.copy(sd.clauses.ClearLimit())\n}\n\n// Adds an OFFSET clause. If the OFFSET is currently set it replaces it. See examples.\nfunc (sd *SelectDataset) Offset(offset uint) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetOffset(offset))\n}\n\n// Removes the OFFSET clause from the Dataset\nfunc (sd *SelectDataset) ClearOffset() *SelectDataset {\n\treturn sd.copy(sd.clauses.ClearOffset())\n}\n\n// Creates an UNION statement with another dataset.\n// If this or the other dataset has a limit or offset it will use that dataset as a subselect in the FROM clause.\n// See examples.\nfunc (sd *SelectDataset) Union(other *SelectDataset) *SelectDataset {\n\treturn sd.withCompound(exp.UnionCompoundType, other.CompoundFromSelf())\n}\n\n// Creates an UNION ALL statement with another dataset.\n// If this or the other dataset has a limit or offset it will use that dataset as a subselect in the FROM clause.\n// See examples.\nfunc (sd *SelectDataset) UnionAll(other *SelectDataset) *SelectDataset {\n\treturn sd.withCompound(exp.UnionAllCompoundType, other.CompoundFromSelf())\n}\n\n// Creates an INTERSECT statement with another dataset.\n// If this or the other dataset has a limit or offset it will use that dataset as a subselect in the FROM clause.\n// See examples.\nfunc (sd *SelectDataset) Intersect(other *SelectDataset) *SelectDataset {\n\treturn sd.withCompound(exp.IntersectCompoundType, other.CompoundFromSelf())\n}\n\n// Creates an INTERSECT ALL statement with another dataset.\n// If this or the other dataset has a limit or offset it will use that dataset as a subselect in the FROM clause.\n// See examples.\nfunc (sd *SelectDataset) IntersectAll(other *SelectDataset) *SelectDataset {\n\treturn sd.withCompound(exp.IntersectAllCompoundType, other.CompoundFromSelf())\n}\n\nfunc (sd *SelectDataset) withCompound(ct exp.CompoundType, other exp.AppendableExpression) *SelectDataset {\n\tce := exp.NewCompoundExpression(ct, other)\n\tret := sd.CompoundFromSelf()\n\tret.clauses = ret.clauses.CompoundsAppend(ce)\n\treturn ret\n}\n\n// Used internally to determine if the dataset needs to use iteself as a source.\n// If the dataset has an order or limit it will select from itself\nfunc (sd *SelectDataset) CompoundFromSelf() *SelectDataset {\n\tif sd.clauses.HasOrder() || sd.clauses.HasLimit() {\n\t\treturn sd.FromSelf()\n\t}\n\treturn sd.copy(sd.clauses)\n}\n\n// Sets the alias for this dataset. This is typically used when using a Dataset as a subselect. See examples.\nfunc (sd *SelectDataset) As(alias string) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetAlias(T(alias)))\n}\n\n// Returns the alias value as an identiier expression\nfunc (sd *SelectDataset) GetAs() exp.IdentifierExpression {\n\treturn sd.clauses.Alias()\n}\n\n// Sets the WINDOW clauses\nfunc (sd *SelectDataset) Window(ws ...exp.WindowExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.SetWindows(ws))\n}\n\n// Sets the WINDOW clauses\nfunc (sd *SelectDataset) WindowAppend(ws ...exp.WindowExpression) *SelectDataset {\n\treturn sd.copy(sd.clauses.WindowsAppend(ws...))\n}\n\n// Sets the WINDOW clauses\nfunc (sd *SelectDataset) ClearWindow() *SelectDataset {\n\treturn sd.copy(sd.clauses.ClearWindows())\n}\n\n// Get any error that has been set or nil if no error has been set.\nfunc (sd *SelectDataset) Error() error {\n\treturn sd.err\n}\n\n// Set an error on the dataset if one has not already been set. This error will be returned by a future call to Error\n// or as part of ToSQL. This can be used by end users to record errors while building up queries without having to\n// track those separately.\nfunc (sd *SelectDataset) SetError(err error) *SelectDataset {\n\tif sd.err == nil {\n\t\tsd.err = err\n\t}\n\n\treturn sd\n}\n\n// Generates a SELECT sql statement, if Prepared has been called with true then the parameters will not be interpolated.\n// See examples.\n//\n// Errors:\n//   - There is an error generating the SQL\nfunc (sd *SelectDataset) ToSQL() (sql string, params []interface{}, err error) {\n\treturn sd.selectSQLBuilder().ToSQL()\n}\n\n// Generates the SELECT sql, and returns an Exec struct with the sql set to the SELECT statement\n//\n//\tdb.From(\"test\").Select(\"col\").Executor()\n//\n// See Dataset#ToUpdateSQL for arguments\nfunc (sd *SelectDataset) Executor() exec.QueryExecutor {\n\treturn sd.queryFactory.FromSQLBuilder(sd.selectSQLBuilder())\n}\n\n// Appends this Dataset's SELECT statement to the SQLBuilder\n// This is used internally for sub-selects by the dialect\nfunc (sd *SelectDataset) AppendSQL(b sb.SQLBuilder) {\n\tif sd.err != nil {\n\t\tb.SetError(sd.err)\n\t\treturn\n\t}\n\tsd.dialect.ToSelectSQL(b, sd.GetClauses())\n}\n\nfunc (sd *SelectDataset) ReturnsColumns() bool {\n\treturn true\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanStructs to scan the results into a slice of structs.\n//\n// ScanStructs will only select the columns that can be scanned in to the struct unless you have explicitly selected\n// certain columns. See examples.\n//\n// i: A pointer to a slice of structs\nfunc (sd *SelectDataset) ScanStructs(i interface{}) error {\n\treturn sd.ScanStructsContext(context.Background(), i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanStructsContext to scan the results into a slice of\n// structs.\n//\n// ScanStructsContext will only select the columns that can be scanned in to the struct unless you have explicitly\n// selected certain columns. See examples.\n//\n// i: A pointer to a slice of structs\nfunc (sd *SelectDataset) ScanStructsContext(ctx context.Context, i interface{}) error {\n\tif sd.queryFactory == nil {\n\t\treturn ErrQueryFactoryNotFoundError\n\t}\n\tds := sd\n\tif sd.GetClauses().IsDefaultSelect() {\n\t\tds = sd.Select(i)\n\t}\n\treturn ds.Executor().ScanStructsContext(ctx, i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanStruct to scan the result into a slice of structs\n//\n// ScanStruct will only select the columns that can be scanned in to the struct unless you have explicitly selected\n// certain columns. See examples.\n//\n// i: A pointer to a structs\nfunc (sd *SelectDataset) ScanStruct(i interface{}) (bool, error) {\n\treturn sd.ScanStructContext(context.Background(), i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanStructContext to scan the result into a slice of structs\n//\n// ScanStructContext will only select the columns that can be scanned in to the struct unless you have explicitly\n// selected certain columns. See examples.\n//\n// i: A pointer to a structs\nfunc (sd *SelectDataset) ScanStructContext(ctx context.Context, i interface{}) (bool, error) {\n\tif sd.queryFactory == nil {\n\t\treturn false, ErrQueryFactoryNotFoundError\n\t}\n\tds := sd\n\tif sd.GetClauses().IsDefaultSelect() {\n\t\tds = sd.Select(i)\n\t}\n\treturn ds.Limit(1).Executor().ScanStructContext(ctx, i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanVals to scan the results into a slice of primitive values\n//\n// i: A pointer to a slice of primitive values\nfunc (sd *SelectDataset) ScanVals(i interface{}) error {\n\treturn sd.ScanValsContext(context.Background(), i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanValsContext to scan the results into a slice of primitive\n// values\n//\n// i: A pointer to a slice of primitive values\nfunc (sd *SelectDataset) ScanValsContext(ctx context.Context, i interface{}) error {\n\tif sd.queryFactory == nil {\n\t\treturn ErrQueryFactoryNotFoundError\n\t}\n\treturn sd.Executor().ScanValsContext(ctx, i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanVal to scan the result into a primitive value\n//\n// i: A pointer to a primitive value\nfunc (sd *SelectDataset) ScanVal(i interface{}) (bool, error) {\n\treturn sd.ScanValContext(context.Background(), i)\n}\n\n// Generates the SELECT sql for this dataset and uses Exec#ScanValContext to scan the result into a primitive value\n//\n// i: A pointer to a primitive value\nfunc (sd *SelectDataset) ScanValContext(ctx context.Context, i interface{}) (bool, error) {\n\tif sd.queryFactory == nil {\n\t\treturn false, ErrQueryFactoryNotFoundError\n\t}\n\treturn sd.Limit(1).Executor().ScanValContext(ctx, i)\n}\n\n// Generates the SELECT COUNT(*) sql for this dataset and uses Exec#ScanVal to scan the result into an int64.\nfunc (sd *SelectDataset) Count() (int64, error) {\n\treturn sd.CountContext(context.Background())\n}\n\n// Generates the SELECT COUNT(*) sql for this dataset and uses Exec#ScanValContext to scan the result into an int64.\nfunc (sd *SelectDataset) CountContext(ctx context.Context) (int64, error) {\n\tvar count int64\n\t_, err := sd.Select(COUNT(Star()).As(\"count\")).ScanValContext(ctx, &count)\n\treturn count, err\n}\n\n// Generates the SELECT sql only selecting the passed in column and uses Exec#ScanVals to scan the result into a slice\n// of primitive values.\n//\n// i: A slice of primitive values\n//\n// col: The column to select when generative the SQL\nfunc (sd *SelectDataset) Pluck(i interface{}, col string) error {\n\treturn sd.PluckContext(context.Background(), i, col)\n}\n\n// Generates the SELECT sql only selecting the passed in column and uses Exec#ScanValsContext to scan the result into a\n// slice of primitive values.\n//\n// i: A slice of primitive values\n//\n// col: The column to select when generative the SQL\nfunc (sd *SelectDataset) PluckContext(ctx context.Context, i interface{}, col string) error {\n\treturn sd.Select(col).ScanValsContext(ctx, i)\n}\n\nfunc (sd *SelectDataset) selectSQLBuilder() sb.SQLBuilder {\n\tbuf := sb.NewSQLBuilder(sd.isPrepared.Bool())\n\tif sd.err != nil {\n\t\treturn buf.SetError(sd.err)\n\t}\n\tsd.dialect.ToSelectSQL(buf, sd.GetClauses())\n\treturn buf\n}\n"
        },
        {
          "name": "select_dataset_example_test.go",
          "type": "blob",
          "size": 48.1591796875,
          "content": "//nolint:lll // sql statements are long\npackage goqu_test\n\nimport (\n\tgoSQL \"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n\t\"time\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/lib/pq\"\n)\n\nconst schema = `\n\t\tDROP TABLE IF EXISTS \"user_role\";\n\t\tDROP TABLE IF EXISTS \"goqu_user\";\t\n\t\tCREATE  TABLE \"goqu_user\" (\n\t\t\t\"id\" SERIAL PRIMARY KEY NOT NULL,\n\t\t\t\"first_name\" VARCHAR(45) NOT NULL,\n\t\t\t\"last_name\" VARCHAR(45) NOT NULL,\n\t\t\t\"created\" TIMESTAMP NOT NULL DEFAULT now()\n\t\t);\n\t\tCREATE  TABLE \"user_role\" (\n\t\t\t\"id\" SERIAL PRIMARY KEY NOT NULL,\n\t\t\t\"user_id\" BIGINT NOT NULL REFERENCES goqu_user(id) ON DELETE CASCADE,\n\t\t\t\"name\" VARCHAR(45) NOT NULL,\n\t\t\t\"created\" TIMESTAMP NOT NULL DEFAULT now()\n\t\t); \n    `\n\nconst defaultDBURI = \"postgres://postgres:@localhost:5435/goqupostgres?sslmode=disable\"\n\nvar goquDB *goqu.Database\n\nfunc getDB() *goqu.Database {\n\tif goquDB == nil {\n\t\tdbURI := os.Getenv(\"PG_URI\")\n\t\tif dbURI == \"\" {\n\t\t\tdbURI = defaultDBURI\n\t\t}\n\t\turi, err := pq.ParseURL(dbURI)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tpdb, err := goSQL.Open(\"postgres\", uri)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tgoquDB = goqu.New(\"postgres\", pdb)\n\t}\n\t// reset the db\n\tif _, err := goquDB.Exec(schema); err != nil {\n\t\tpanic(err)\n\t}\n\ttype goquUser struct {\n\t\tID        int64     `db:\"id\" goqu:\"skipinsert\"`\n\t\tFirstName string    `db:\"first_name\"`\n\t\tLastName  string    `db:\"last_name\"`\n\t\tCreated   time.Time `db:\"created\" goqu:\"skipupdate\"`\n\t}\n\n\tusers := []goquUser{\n\t\t{FirstName: \"Bob\", LastName: \"Yukon\"},\n\t\t{FirstName: \"Sally\", LastName: \"Yukon\"},\n\t\t{FirstName: \"Vinita\", LastName: \"Yukon\"},\n\t\t{FirstName: \"John\", LastName: \"Doe\"},\n\t}\n\tvar userIds []int64\n\terr := goquDB.Insert(\"goqu_user\").Rows(users).Returning(\"id\").Executor().ScanVals(&userIds)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttype userRole struct {\n\t\tID      int64     `db:\"id\" goqu:\"skipinsert\"`\n\t\tUserID  int64     `db:\"user_id\"`\n\t\tName    string    `db:\"name\"`\n\t\tCreated time.Time `db:\"created\" goqu:\"skipupdate\"`\n\t}\n\n\troles := []userRole{\n\t\t{UserID: userIds[0], Name: \"Admin\"},\n\t\t{UserID: userIds[1], Name: \"Manager\"},\n\t\t{UserID: userIds[2], Name: \"Manager\"},\n\t\t{UserID: userIds[3], Name: \"User\"},\n\t}\n\t_, err = goquDB.Insert(\"user_role\").Rows(roles).Executor().Exec()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn goquDB\n}\n\nfunc ExampleSelectDataset() {\n\tds := goqu.From(\"test\").\n\t\tSelect(goqu.COUNT(\"*\")).\n\t\tInnerJoin(goqu.T(\"test2\"), goqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.id\")))).\n\t\tLeftJoin(goqu.T(\"test3\"), goqu.On(goqu.I(\"test2.fkey\").Eq(goqu.I(\"test3.id\")))).\n\t\tWhere(\n\t\t\tgoqu.Ex{\n\t\t\t\t\"test.name\": goqu.Op{\n\t\t\t\t\t\"like\": regexp.MustCompile(\"^[ab]\"),\n\t\t\t\t},\n\t\t\t\t\"test2.amount\": goqu.Op{\n\t\t\t\t\t\"isNot\": nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\tgoqu.ExOr{\n\t\t\t\t\"test3.id\":     nil,\n\t\t\t\t\"test3.status\": []string{\"passed\", \"active\", \"registered\"},\n\t\t\t}).\n\t\tOrder(goqu.I(\"test.created\").Desc().NullsLast()).\n\t\tGroupBy(goqu.I(\"test.user_id\")).\n\t\tHaving(goqu.AVG(\"test3.age\").Gt(10))\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t//nolint:lll // SQL statements are long\n\t// Output:\n\t// SELECT COUNT(*) FROM \"test\" INNER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"id\") LEFT JOIN \"test3\" ON (\"test2\".\"fkey\" = \"test3\".\"id\") WHERE (((\"test\".\"name\" ~ '^[ab]') AND (\"test2\".\"amount\" IS NOT NULL)) AND ((\"test3\".\"id\" IS NULL) OR (\"test3\".\"status\" IN ('passed', 'active', 'registered')))) GROUP BY \"test\".\"user_id\" HAVING (AVG(\"test3\".\"age\") > 10) ORDER BY \"test\".\"created\" DESC NULLS LAST []\n\t// SELECT COUNT(*) FROM \"test\" INNER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"id\") LEFT JOIN \"test3\" ON (\"test2\".\"fkey\" = \"test3\".\"id\") WHERE (((\"test\".\"name\" ~ ?) AND (\"test2\".\"amount\" IS NOT NULL)) AND ((\"test3\".\"id\" IS NULL) OR (\"test3\".\"status\" IN (?, ?, ?)))) GROUP BY \"test\".\"user_id\" HAVING (AVG(\"test3\".\"age\") > ?) ORDER BY \"test\".\"created\" DESC NULLS LAST [^[ab] passed active registered 10]\n}\n\nfunc ExampleSelect() {\n\tsql, _, _ := goqu.Select(goqu.L(\"NOW()\")).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT NOW()\n}\n\nfunc ExampleFrom() {\n\tsql, args, _ := goqu.From(\"test\").ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" []\n}\n\nfunc ExampleSelectDataset_As() {\n\tds := goqu.From(\"test\").As(\"t\")\n\tsql, _, _ := goqu.From(ds).ToSQL()\n\tfmt.Println(sql)\n\t// Output: SELECT * FROM (SELECT * FROM \"test\") AS \"t\"\n}\n\nfunc ExampleSelectDataset_Union() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tUnion(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tUnion(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tUnion(goqu.From(\"test2\").\n\t\t\tOrder(goqu.C(\"id\").Desc())).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" UNION (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" UNION (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" UNION (SELECT * FROM (SELECT * FROM \"test2\" ORDER BY \"id\" DESC) AS \"t1\")\n}\n\nfunc ExampleSelectDataset_UnionAll() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tUnionAll(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tUnionAll(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tUnionAll(goqu.From(\"test2\").\n\t\t\tOrder(goqu.C(\"id\").Desc())).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" UNION ALL (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" UNION ALL (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" UNION ALL (SELECT * FROM (SELECT * FROM \"test2\" ORDER BY \"id\" DESC) AS \"t1\")\n}\n\nfunc ExampleSelectDataset_With() {\n\tsql, _, _ := goqu.From(\"one\").\n\t\tWith(\"one\", goqu.From().Select(goqu.L(\"1\"))).\n\t\tSelect(goqu.Star()).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"derived\").\n\t\tWith(\"intermed\", goqu.From(\"test\").Select(goqu.Star()).Where(goqu.C(\"x\").Gte(5))).\n\t\tWith(\"derived\", goqu.From(\"intermed\").Select(goqu.Star()).Where(goqu.C(\"x\").Lt(10))).\n\t\tSelect(goqu.Star()).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"multi\").\n\t\tWith(\"multi(x,y)\", goqu.From().Select(goqu.L(\"1\"), goqu.L(\"2\"))).\n\t\tSelect(goqu.C(\"x\"), goqu.C(\"y\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// WITH one AS (SELECT 1) SELECT * FROM \"one\"\n\t// WITH intermed AS (SELECT * FROM \"test\" WHERE (\"x\" >= 5)), derived AS (SELECT * FROM \"intermed\" WHERE (\"x\" < 10)) SELECT * FROM \"derived\"\n\t// WITH multi(x,y) AS (SELECT 1, 2) SELECT \"x\", \"y\" FROM \"multi\"\n}\n\nfunc ExampleSelectDataset_With_insertDataset() {\n\tinsertDs := goqu.Insert(\"foo\").Rows(goqu.Record{\"user_id\": 10}).Returning(\"id\")\n\n\tds := goqu.From(\"bar\").\n\t\tWith(\"ins\", insertDs).\n\t\tSelect(\"bar_name\").\n\t\tWhere(goqu.Ex{\"bar.user_id\": goqu.I(\"ins.user_id\")})\n\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\n\tsql, args, _ := ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// WITH ins AS (INSERT INTO \"foo\" (\"user_id\") VALUES (10) RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"ins\".\"user_id\")\n\t// WITH ins AS (INSERT INTO \"foo\" (\"user_id\") VALUES (?) RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"ins\".\"user_id\") [10]\n}\n\nfunc ExampleSelectDataset_With_updateDataset() {\n\tupdateDs := goqu.Update(\"foo\").Set(goqu.Record{\"bar\": \"baz\"}).Returning(\"id\")\n\n\tds := goqu.From(\"bar\").\n\t\tWith(\"upd\", updateDs).\n\t\tSelect(\"bar_name\").\n\t\tWhere(goqu.Ex{\"bar.user_id\": goqu.I(\"upd.user_id\")})\n\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\n\tsql, args, _ := ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// WITH upd AS (UPDATE \"foo\" SET \"bar\"='baz' RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"upd\".\"user_id\")\n\t// WITH upd AS (UPDATE \"foo\" SET \"bar\"=? RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"upd\".\"user_id\") [baz]\n}\n\nfunc ExampleSelectDataset_With_deleteDataset() {\n\tdeleteDs := goqu.Delete(\"foo\").Where(goqu.Ex{\"bar\": \"baz\"}).Returning(\"id\")\n\n\tds := goqu.From(\"bar\").\n\t\tWith(\"del\", deleteDs).\n\t\tSelect(\"bar_name\").\n\t\tWhere(goqu.Ex{\"bar.user_id\": goqu.I(\"del.user_id\")})\n\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\n\tsql, args, _ := ds.Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// WITH del AS (DELETE FROM \"foo\" WHERE (\"bar\" = 'baz') RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"del\".\"user_id\")\n\t// WITH del AS (DELETE FROM \"foo\" WHERE (\"bar\" = ?) RETURNING \"id\") SELECT \"bar_name\" FROM \"bar\" WHERE (\"bar\".\"user_id\" = \"del\".\"user_id\") [baz]\n}\n\nfunc ExampleSelectDataset_WithRecursive() {\n\tsql, _, _ := goqu.From(\"nums\").\n\t\tWithRecursive(\"nums(x)\",\n\t\t\tgoqu.From().Select(goqu.L(\"1\")).\n\t\t\t\tUnionAll(goqu.From(\"nums\").\n\t\t\t\t\tSelect(goqu.L(\"x+1\")).Where(goqu.C(\"x\").Lt(5)))).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// WITH RECURSIVE nums(x) AS (SELECT 1 UNION ALL (SELECT x+1 FROM \"nums\" WHERE (\"x\" < 5))) SELECT * FROM \"nums\"\n}\n\nfunc ExampleSelectDataset_Intersect() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tIntersect(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tIntersect(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tIntersect(goqu.From(\"test2\").\n\t\t\tOrder(goqu.C(\"id\").Desc())).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" INTERSECT (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" INTERSECT (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" INTERSECT (SELECT * FROM (SELECT * FROM \"test2\" ORDER BY \"id\" DESC) AS \"t1\")\n}\n\nfunc ExampleSelectDataset_IntersectAll() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tIntersectAll(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tIntersectAll(goqu.From(\"test2\")).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").\n\t\tLimit(1).\n\t\tIntersectAll(goqu.From(\"test2\").\n\t\t\tOrder(goqu.C(\"id\").Desc())).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" INTERSECT ALL (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" INTERSECT ALL (SELECT * FROM \"test2\")\n\t// SELECT * FROM (SELECT * FROM \"test\" LIMIT 1) AS \"t1\" INTERSECT ALL (SELECT * FROM (SELECT * FROM \"test2\" ORDER BY \"id\" DESC) AS \"t1\")\n}\n\nfunc ExampleSelectDataset_ClearOffset() {\n\tds := goqu.From(\"test\").\n\t\tOffset(2)\n\tsql, _, _ := ds.\n\t\tClearOffset().\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Offset() {\n\tds := goqu.From(\"test\").Offset(2)\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" OFFSET 2\n}\n\nfunc ExampleSelectDataset_Limit() {\n\tds := goqu.From(\"test\").Limit(10)\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" LIMIT 10\n}\n\nfunc ExampleSelectDataset_LimitAll() {\n\tds := goqu.From(\"test\").LimitAll()\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" LIMIT ALL\n}\n\nfunc ExampleSelectDataset_ClearLimit() {\n\tds := goqu.From(\"test\").Limit(10)\n\tsql, _, _ := ds.ClearLimit().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Order() {\n\tds := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" ORDER BY \"a\" ASC\n}\n\nfunc ExampleSelectDataset_Order_caseExpression() {\n\tds := goqu.From(\"test\").Order(goqu.Case().When(goqu.C(\"num\").Gt(10), 0).Else(1).Asc())\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" ORDER BY CASE  WHEN (\"num\" > 10) THEN 0 ELSE 1 END ASC\n}\n\nfunc ExampleSelectDataset_OrderAppend() {\n\tds := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.OrderAppend(goqu.C(\"b\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" ORDER BY \"a\" ASC, \"b\" DESC NULLS LAST\n}\n\nfunc ExampleSelectDataset_OrderPrepend() {\n\tds := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.OrderPrepend(goqu.C(\"b\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" ORDER BY \"b\" DESC NULLS LAST, \"a\" ASC\n}\n\nfunc ExampleSelectDataset_ClearOrder() {\n\tds := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.ClearOrder().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_GroupBy() {\n\tsql, _, _ := goqu.From(\"test\").\n\t\tSelect(goqu.SUM(\"income\").As(\"income_sum\")).\n\t\tGroupBy(\"age\").\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT SUM(\"income\") AS \"income_sum\" FROM \"test\" GROUP BY \"age\"\n}\n\nfunc ExampleSelectDataset_GroupByAppend() {\n\tds := goqu.From(\"test\").\n\t\tSelect(goqu.SUM(\"income\").As(\"income_sum\")).\n\t\tGroupBy(\"age\")\n\tsql, _, _ := ds.\n\t\tGroupByAppend(\"job\").\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// the original dataset group by does not change\n\tsql, _, _ = ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT SUM(\"income\") AS \"income_sum\" FROM \"test\" GROUP BY \"age\", \"job\"\n\t// SELECT SUM(\"income\") AS \"income_sum\" FROM \"test\" GROUP BY \"age\"\n}\n\nfunc ExampleSelectDataset_Having() {\n\tsql, _, _ := goqu.From(\"test\").Having(goqu.SUM(\"income\").Gt(1000)).ToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").GroupBy(\"age\").Having(goqu.SUM(\"income\").Gt(1000)).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" HAVING (SUM(\"income\") > 1000)\n\t// SELECT * FROM \"test\" GROUP BY \"age\" HAVING (SUM(\"income\") > 1000)\n}\n\nfunc ExampleSelectDataset_Window() {\n\tds := goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().Over(goqu.W().PartitionBy(\"a\").OrderBy(goqu.I(\"b\").Asc())))\n\tquery, args, _ := ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tds = goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().OverName(goqu.I(\"w\"))).\n\t\tWindow(goqu.W(\"w\").PartitionBy(\"a\").OrderBy(goqu.I(\"b\").Asc()))\n\tquery, args, _ = ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tds = goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().OverName(goqu.I(\"w1\"))).\n\t\tWindow(\n\t\t\tgoqu.W(\"w1\").PartitionBy(\"a\"),\n\t\t\tgoqu.W(\"w\").Inherit(\"w1\").OrderBy(goqu.I(\"b\").Asc()),\n\t\t)\n\tquery, args, _ = ds.ToSQL()\n\tfmt.Println(query, args)\n\n\tds = goqu.From(\"test\").\n\t\tSelect(goqu.ROW_NUMBER().Over(goqu.W().Inherit(\"w\").OrderBy(\"b\"))).\n\t\tWindow(goqu.W(\"w\").PartitionBy(\"a\"))\n\tquery, args, _ = ds.ToSQL()\n\tfmt.Println(query, args)\n\t// Output\n\t// SELECT ROW_NUMBER() OVER (PARTITION BY \"a\" ORDER BY \"b\" ASC) FROM \"test\" []\n\t// SELECT ROW_NUMBER() OVER \"w\" FROM \"test\" WINDOW \"w\" AS (PARTITION BY \"a\" ORDER BY \"b\" ASC) []\n\t// SELECT ROW_NUMBER() OVER \"w\" FROM \"test\" WINDOW \"w1\" AS (PARTITION BY \"a\"), \"w\" AS (\"w1\" ORDER BY \"b\" ASC) []\n\t// SELECT ROW_NUMBER() OVER (\"w\" ORDER BY \"b\") FROM \"test\" WINDOW \"w\" AS (PARTITION BY \"a\") []\n}\n\nfunc ExampleSelectDataset_Where() {\n\t// By default everything is anded together\n\tsql, _, _ := goqu.From(\"test\").Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\t// You can use ExOr to get ORed expressions together\n\tsql, _, _ = goqu.From(\"test\").Where(goqu.ExOr{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql)\n\t// You can use Or with Ex to Or multiple Ex maps together\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.Ex{\n\t\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t},\n\t\t\tgoqu.Ex{\n\t\t\t\t\"c\": nil,\n\t\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t\t},\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// By default everything is anded together\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.C(\"a\").Gt(10),\n\t\tgoqu.C(\"b\").Lt(10),\n\t\tgoqu.C(\"c\").IsNull(),\n\t\tgoqu.C(\"d\").In(\"a\", \"b\", \"c\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// You can use a combination of Ors and Ands\n\tsql, _, _ = goqu.From(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t),\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > 10) AND (\"b\" < 10) AND (\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c')))\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > 10) OR (\"b\" < 10) OR (\"c\" IS NULL) OR (\"d\" IN ('a', 'b', 'c')))\n\t// SELECT * FROM \"test\" WHERE (((\"a\" > 10) AND (\"b\" < 10)) OR ((\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c'))))\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > 10) AND (\"b\" < 10) AND (\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c')))\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > 10) OR ((\"b\" < 10) AND (\"c\" IS NULL)))\n}\n\nfunc ExampleSelectDataset_Where_prepared() {\n\t// By default everything is anded together\n\tsql, args, _ := goqu.From(\"test\").Prepared(true).Where(goqu.Ex{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use ExOr to get ORed expressions together\n\tsql, args, _ = goqu.From(\"test\").Prepared(true).Where(goqu.ExOr{\n\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\"c\": nil,\n\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use Or with Ex to Or multiple Ex maps together\n\tsql, args, _ = goqu.From(\"test\").Prepared(true).Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.Ex{\n\t\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t},\n\t\t\tgoqu.Ex{\n\t\t\t\t\"c\": nil,\n\t\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t\t},\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// By default everything is anded together\n\tsql, args, _ = goqu.From(\"test\").Prepared(true).Where(\n\t\tgoqu.C(\"a\").Gt(10),\n\t\tgoqu.C(\"b\").Lt(10),\n\t\tgoqu.C(\"c\").IsNull(),\n\t\tgoqu.C(\"d\").In(\"a\", \"b\", \"c\"),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use a combination of Ors and Ands\n\tsql, args, _ = goqu.From(\"test\").Prepared(true).Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t),\n\t\t),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > ?) AND (\"b\" < ?) AND (\"c\" IS NULL) AND (\"d\" IN (?, ?, ?))) [10 10 a b c]\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > ?) OR (\"b\" < ?) OR (\"c\" IS NULL) OR (\"d\" IN (?, ?, ?))) [10 10 a b c]\n\t// SELECT * FROM \"test\" WHERE (((\"a\" > ?) AND (\"b\" < ?)) OR ((\"c\" IS NULL) AND (\"d\" IN (?, ?, ?)))) [10 10 a b c]\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > ?) AND (\"b\" < ?) AND (\"c\" IS NULL) AND (\"d\" IN (?, ?, ?))) [10 10 a b c]\n\t// SELECT * FROM \"test\" WHERE ((\"a\" > ?) OR ((\"b\" < ?) AND (\"c\" IS NULL))) [10 10]\n}\n\nfunc ExampleSelectDataset_ClearWhere() {\n\tds := goqu.From(\"test\").Where(\n\t\tgoqu.Or(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.And(\n\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t),\n\t\t),\n\t)\n\tsql, _, _ := ds.ClearWhere().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Join() {\n\tsql, _, _ := goqu.From(\"test\").Join(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\"test.fkey\": goqu.I(\"test2.Id\")}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Join(goqu.T(\"test2\"), goqu.Using(\"common_column\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Join(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.T(\"test2\").Col(\"Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").Join(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.T(\"test\").Col(\"fkey\").Eq(goqu.T(\"t\").Col(\"Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" INNER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" INNER JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" INNER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" INNER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_InnerJoin() {\n\tsql, _, _ := goqu.From(\"test\").InnerJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").InnerJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").InnerJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").InnerJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" INNER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" INNER JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" INNER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" INNER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_FullOuterJoin() {\n\tsql, _, _ := goqu.From(\"test\").FullOuterJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").FullOuterJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").FullOuterJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").FullOuterJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" FULL OUTER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" FULL OUTER JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" FULL OUTER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" FULL OUTER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_RightOuterJoin() {\n\tsql, _, _ := goqu.From(\"test\").RightOuterJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").RightOuterJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").RightOuterJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").RightOuterJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" RIGHT OUTER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" RIGHT OUTER JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" RIGHT OUTER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" RIGHT OUTER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_LeftOuterJoin() {\n\tsql, _, _ := goqu.From(\"test\").LeftOuterJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").LeftOuterJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").LeftOuterJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").LeftOuterJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" LEFT OUTER JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" LEFT OUTER JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" LEFT OUTER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" LEFT OUTER JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_FullJoin() {\n\tsql, _, _ := goqu.From(\"test\").FullJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").FullJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").FullJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").FullJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" FULL JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" FULL JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" FULL JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" FULL JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_RightJoin() {\n\tsql, _, _ := goqu.From(\"test\").RightJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").RightJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").RightJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").RightJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" RIGHT JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" RIGHT JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" RIGHT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" RIGHT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_LeftJoin() {\n\tsql, _, _ := goqu.From(\"test\").LeftJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.On(goqu.Ex{\n\t\t\t\"test.fkey\": goqu.I(\"test2.Id\"),\n\t\t}),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").LeftJoin(\n\t\tgoqu.T(\"test2\"),\n\t\tgoqu.Using(\"common_column\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").LeftJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"test2.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").LeftJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t\tgoqu.On(goqu.I(\"test.fkey\").Eq(goqu.I(\"t.Id\"))),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" LEFT JOIN \"test2\" ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" LEFT JOIN \"test2\" USING (\"common_column\")\n\t// SELECT * FROM \"test\" LEFT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) ON (\"test\".\"fkey\" = \"test2\".\"Id\")\n\t// SELECT * FROM \"test\" LEFT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\" ON (\"test\".\"fkey\" = \"t\".\"Id\")\n}\n\nfunc ExampleSelectDataset_NaturalJoin() {\n\tsql, _, _ := goqu.From(\"test\").NaturalJoin(goqu.T(\"test2\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" NATURAL JOIN \"test2\"\n\t// SELECT * FROM \"test\" NATURAL JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0))\n\t// SELECT * FROM \"test\" NATURAL JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\"\n}\n\nfunc ExampleSelectDataset_NaturalLeftJoin() {\n\tsql, _, _ := goqu.From(\"test\").NaturalLeftJoin(goqu.T(\"test2\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalLeftJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalLeftJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" NATURAL LEFT JOIN \"test2\"\n\t// SELECT * FROM \"test\" NATURAL LEFT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0))\n\t// SELECT * FROM \"test\" NATURAL LEFT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\"\n}\n\nfunc ExampleSelectDataset_NaturalRightJoin() {\n\tsql, _, _ := goqu.From(\"test\").NaturalRightJoin(goqu.T(\"test2\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalRightJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalRightJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" NATURAL RIGHT JOIN \"test2\"\n\t// SELECT * FROM \"test\" NATURAL RIGHT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0))\n\t// SELECT * FROM \"test\" NATURAL RIGHT JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\"\n}\n\nfunc ExampleSelectDataset_NaturalFullJoin() {\n\tsql, _, _ := goqu.From(\"test\").NaturalFullJoin(goqu.T(\"test2\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalFullJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").NaturalFullJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" NATURAL FULL JOIN \"test2\"\n\t// SELECT * FROM \"test\" NATURAL FULL JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0))\n\t// SELECT * FROM \"test\" NATURAL FULL JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\"\n}\n\nfunc ExampleSelectDataset_CrossJoin() {\n\tsql, _, _ := goqu.From(\"test\").CrossJoin(goqu.T(\"test2\")).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").CrossJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)),\n\t).ToSQL()\n\tfmt.Println(sql)\n\n\tsql, _, _ = goqu.From(\"test\").CrossJoin(\n\t\tgoqu.From(\"test2\").Where(goqu.C(\"amount\").Gt(0)).As(\"t\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\" CROSS JOIN \"test2\"\n\t// SELECT * FROM \"test\" CROSS JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0))\n\t// SELECT * FROM \"test\" CROSS JOIN (SELECT * FROM \"test2\" WHERE (\"amount\" > 0)) AS \"t\"\n}\n\nfunc ExampleSelectDataset_FromSelf() {\n\tsql, _, _ := goqu.From(\"test\").FromSelf().ToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.From(\"test\").As(\"my_test_table\").FromSelf().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM (SELECT * FROM \"test\") AS \"t1\"\n\t// SELECT * FROM (SELECT * FROM \"test\") AS \"my_test_table\"\n}\n\nfunc ExampleSelectDataset_From() {\n\tds := goqu.From(\"test\")\n\tsql, _, _ := ds.From(\"test2\").ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test2\"\n}\n\nfunc ExampleSelectDataset_From_withDataset() {\n\tds := goqu.From(\"test\")\n\tfromDs := ds.Where(goqu.C(\"age\").Gt(10))\n\tsql, _, _ := ds.From(fromDs).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM (SELECT * FROM \"test\" WHERE (\"age\" > 10)) AS \"t1\"\n}\n\nfunc ExampleSelectDataset_From_withAliasedDataset() {\n\tds := goqu.From(\"test\")\n\tfromDs := ds.Where(goqu.C(\"age\").Gt(10))\n\tsql, _, _ := ds.From(fromDs.As(\"test2\")).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM (SELECT * FROM \"test\" WHERE (\"age\" > 10)) AS \"test2\"\n}\n\nfunc ExampleSelectDataset_Select() {\n\tsql, _, _ := goqu.From(\"test\").Select(\"a\", \"b\", \"c\").ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT \"a\", \"b\", \"c\" FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Select_withDataset() {\n\tds := goqu.From(\"test\")\n\tfromDs := ds.Select(\"age\").Where(goqu.C(\"age\").Gt(10))\n\tsql, _, _ := ds.From().Select(fromDs).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT (SELECT \"age\" FROM \"test\" WHERE (\"age\" > 10))\n}\n\nfunc ExampleSelectDataset_Select_withAliasedDataset() {\n\tds := goqu.From(\"test\")\n\tfromDs := ds.Select(\"age\").Where(goqu.C(\"age\").Gt(10))\n\tsql, _, _ := ds.From().Select(fromDs.As(\"ages\")).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT (SELECT \"age\" FROM \"test\" WHERE (\"age\" > 10)) AS \"ages\"\n}\n\nfunc ExampleSelectDataset_Select_withLiteral() {\n\tsql, _, _ := goqu.From(\"test\").Select(goqu.L(\"a + b\").As(\"sum\")).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT a + b AS \"sum\" FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Select_withSQLFunctionExpression() {\n\tsql, _, _ := goqu.From(\"test\").Select(\n\t\tgoqu.COUNT(\"*\").As(\"age_count\"),\n\t\tgoqu.MAX(\"age\").As(\"max_age\"),\n\t\tgoqu.AVG(\"age\").As(\"avg_age\"),\n\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT COUNT(*) AS \"age_count\", MAX(\"age\") AS \"max_age\", AVG(\"age\") AS \"avg_age\" FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Select_withStruct() {\n\tds := goqu.From(\"test\")\n\n\ttype myStruct struct {\n\t\tName         string\n\t\tAddress      string `db:\"address\"`\n\t\tEmailAddress string `db:\"email_address\"`\n\t}\n\n\t// Pass with pointer\n\tsql, _, _ := ds.Select(&myStruct{}).ToSQL()\n\tfmt.Println(sql)\n\n\t// Pass instance of\n\tsql, _, _ = ds.Select(myStruct{}).ToSQL()\n\tfmt.Println(sql)\n\n\ttype myStruct2 struct {\n\t\tmyStruct\n\t\tZipcode string `db:\"zipcode\"`\n\t}\n\n\t// Pass pointer to struct with embedded struct\n\tsql, _, _ = ds.Select(&myStruct2{}).ToSQL()\n\tfmt.Println(sql)\n\n\t// Pass instance of struct with embedded struct\n\tsql, _, _ = ds.Select(myStruct2{}).ToSQL()\n\tfmt.Println(sql)\n\n\tvar myStructs []myStruct\n\n\t// Pass slice of structs, will only select columns from underlying type\n\tsql, _, _ = ds.Select(myStructs).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// SELECT \"address\", \"email_address\", \"name\" FROM \"test\"\n\t// SELECT \"address\", \"email_address\", \"name\" FROM \"test\"\n\t// SELECT \"address\", \"email_address\", \"name\", \"zipcode\" FROM \"test\"\n\t// SELECT \"address\", \"email_address\", \"name\", \"zipcode\" FROM \"test\"\n\t// SELECT \"address\", \"email_address\", \"name\" FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Distinct() {\n\tsql, _, _ := goqu.From(\"test\").Select(\"a\", \"b\").Distinct().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT DISTINCT \"a\", \"b\" FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Distinct_on() {\n\tsql, _, _ := goqu.From(\"test\").Distinct(\"a\").ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT DISTINCT ON (\"a\") * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Distinct_onWithLiteral() {\n\tsql, _, _ := goqu.From(\"test\").Distinct(goqu.L(\"COALESCE(?, ?)\", goqu.C(\"a\"), \"empty\")).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT DISTINCT ON (COALESCE(\"a\", 'empty')) * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_Distinct_onCoalesce() {\n\tsql, _, _ := goqu.From(\"test\").Distinct(goqu.COALESCE(goqu.C(\"a\"), \"empty\")).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT DISTINCT ON (COALESCE(\"a\", 'empty')) * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_SelectAppend() {\n\tds := goqu.From(\"test\").Select(\"a\", \"b\")\n\tsql, _, _ := ds.SelectAppend(\"c\").ToSQL()\n\tfmt.Println(sql)\n\tds = goqu.From(\"test\").Select(\"a\", \"b\").Distinct()\n\tsql, _, _ = ds.SelectAppend(\"c\").ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT \"a\", \"b\", \"c\" FROM \"test\"\n\t// SELECT DISTINCT \"a\", \"b\", \"c\" FROM \"test\"\n}\n\nfunc ExampleSelectDataset_ClearSelect() {\n\tds := goqu.From(\"test\").Select(\"a\", \"b\")\n\tsql, _, _ := ds.ClearSelect().ToSQL()\n\tfmt.Println(sql)\n\tds = goqu.From(\"test\").Select(\"a\", \"b\").Distinct()\n\tsql, _, _ = ds.ClearSelect().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// SELECT * FROM \"test\"\n\t// SELECT * FROM \"test\"\n}\n\nfunc ExampleSelectDataset_ToSQL() {\n\tsql, args, _ := goqu.From(\"items\").Where(goqu.Ex{\"a\": 1}).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE (\"a\" = 1) []\n}\n\nfunc ExampleSelectDataset_ToSQL_prepared() {\n\tsql, args, _ := goqu.From(\"items\").Where(goqu.Ex{\"a\": 1}).Prepared(true).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE (\"a\" = ?) [1]\n}\n\nfunc ExampleSelectDataset_Update() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tsql, args, _ := goqu.From(\"items\").Update().Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Update().Set(\n\t\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Update().Set(\n\t\tmap[string]interface{}{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleSelectDataset_Insert() {\n\ttype item struct {\n\t\tID      uint32 `db:\"id\" goqu:\"skipinsert\"`\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tsql, args, _ := goqu.From(\"items\").Insert().Rows(\n\t\titem{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\titem{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Insert().Rows(\n\t\tgoqu.Record{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\tgoqu.Record{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Insert().Rows(\n\t\t[]item{\n\t\t\t{Name: \"Test1\", Address: \"111 Test Addr\"},\n\t\t\t{Name: \"Test2\", Address: \"112 Test Addr\"},\n\t\t}).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Insert().Rows(\n\t\t[]goqu.Record{\n\t\t\t{\"name\": \"Test1\", \"address\": \"111 Test Addr\"},\n\t\t\t{\"name\": \"Test2\", \"address\": \"112 Test Addr\"},\n\t\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n\t// INSERT INTO \"items\" (\"address\", \"name\") VALUES ('111 Test Addr', 'Test1'), ('112 Test Addr', 'Test2') []\n}\n\nfunc ExampleSelectDataset_Delete() {\n\tsql, args, _ := goqu.From(\"items\").Delete().ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").\n\t\tWhere(goqu.Ex{\"id\": goqu.Op{\"gt\": 10}}).\n\t\tDelete().\n\t\tToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// DELETE FROM \"items\" []\n\t// DELETE FROM \"items\" WHERE (\"id\" > 10) []\n}\n\nfunc ExampleSelectDataset_Truncate() {\n\tsql, args, _ := goqu.From(\"items\").Truncate().ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// TRUNCATE \"items\" []\n}\n\nfunc ExampleSelectDataset_Prepared() {\n\tsql, args, _ := goqu.From(\"items\").Prepared(true).Where(goqu.Ex{\n\t\t\"col1\": \"a\",\n\t\t\"col2\": 1,\n\t\t\"col3\": true,\n\t\t\"col4\": false,\n\t\t\"col5\": []string{\"a\", \"b\", \"c\"},\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t//nolint:lll // sql statements are long\n\t// Output:\n\t// SELECT * FROM \"items\" WHERE ((\"col1\" = ?) AND (\"col2\" = ?) AND (\"col3\" IS TRUE) AND (\"col4\" IS FALSE) AND (\"col5\" IN (?, ?, ?))) [a 1 a b c]\n}\n\nfunc ExampleSelectDataset_ScanStructs() {\n\ttype User struct {\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\tdb := getDB()\n\tvar users []User\n\tif err := db.From(\"goqu_user\").ScanStructs(&users); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"\\n%+v\", users)\n\n\tusers = users[0:0]\n\tif err := db.From(\"goqu_user\").Select(\"first_name\").ScanStructs(&users); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"\\n%+v\", users)\n\n\t// Output:\n\t// [{FirstName:Bob LastName:Yukon} {FirstName:Sally LastName:Yukon} {FirstName:Vinita LastName:Yukon} {FirstName:John LastName:Doe}]\n\t// [{FirstName:Bob LastName:} {FirstName:Sally LastName:} {FirstName:Vinita LastName:} {FirstName:John LastName:}]\n}\n\nfunc ExampleSelectDataset_ScanStructs_prepared() {\n\ttype User struct {\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\tdb := getDB()\n\n\tds := db.From(\"goqu_user\").\n\t\tPrepared(true).\n\t\tWhere(goqu.Ex{\n\t\t\t\"last_name\": \"Yukon\",\n\t\t})\n\n\tvar users []User\n\tif err := ds.ScanStructs(&users); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"\\n%+v\", users)\n\n\t// Output:\n\t// [{FirstName:Bob LastName:Yukon} {FirstName:Sally LastName:Yukon} {FirstName:Vinita LastName:Yukon}]\n}\n\n// In this example we create a new struct that has two structs that represent two table\n// the User and Role fields are tagged with the table name\nfunc ExampleSelectDataset_ScanStructs_withJoinAutoSelect() {\n\ttype Role struct {\n\t\tUserID uint64 `db:\"user_id\"`\n\t\tName   string `db:\"name\"`\n\t}\n\ttype User struct {\n\t\tID        uint64 `db:\"id\"`\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\ttype UserAndRole struct {\n\t\tUser User `db:\"goqu_user\"` // tag as the \"goqu_user\" table\n\t\tRole Role `db:\"user_role\"` // tag as \"user_role\" table\n\t}\n\tdb := getDB()\n\n\tds := db.\n\t\tFrom(\"goqu_user\").\n\t\tJoin(goqu.T(\"user_role\"), goqu.On(goqu.I(\"goqu_user.id\").Eq(goqu.I(\"user_role.user_id\"))))\n\tvar users []UserAndRole\n\t// Scan structs will auto build the\n\tif err := ds.ScanStructs(&users); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfor _, u := range users {\n\t\tfmt.Printf(\"\\n%+v\", u)\n\t}\n\t// Output:\n\t// {User:{ID:1 FirstName:Bob LastName:Yukon} Role:{UserID:1 Name:Admin}}\n\t// {User:{ID:2 FirstName:Sally LastName:Yukon} Role:{UserID:2 Name:Manager}}\n\t// {User:{ID:3 FirstName:Vinita LastName:Yukon} Role:{UserID:3 Name:Manager}}\n\t// {User:{ID:4 FirstName:John LastName:Doe} Role:{UserID:4 Name:User}}\n}\n\n// In this example we create a new struct that has the user properties as well as a nested\n// Role struct from the join table\nfunc ExampleSelectDataset_ScanStructs_withJoinManualSelect() {\n\ttype Role struct {\n\t\tUserID uint64 `db:\"user_id\"`\n\t\tName   string `db:\"name\"`\n\t}\n\ttype User struct {\n\t\tID        uint64 `db:\"id\"`\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t\tRole      Role   `db:\"user_role\"` // tag as \"user_role\" table\n\t}\n\tdb := getDB()\n\n\tds := db.\n\t\tSelect(\n\t\t\t\"goqu_user.id\",\n\t\t\t\"goqu_user.first_name\",\n\t\t\t\"goqu_user.last_name\",\n\t\t\t// alias the fully qualified identifier `C` is important here so it doesnt parse it\n\t\t\tgoqu.I(\"user_role.user_id\").As(goqu.C(\"user_role.user_id\")),\n\t\t\tgoqu.I(\"user_role.name\").As(goqu.C(\"user_role.name\")),\n\t\t).\n\t\tFrom(\"goqu_user\").\n\t\tJoin(goqu.T(\"user_role\"), goqu.On(goqu.I(\"goqu_user.id\").Eq(goqu.I(\"user_role.user_id\"))))\n\tvar users []User\n\tif err := ds.ScanStructs(&users); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfor _, u := range users {\n\t\tfmt.Printf(\"\\n%+v\", u)\n\t}\n\n\t// Output:\n\t// {ID:1 FirstName:Bob LastName:Yukon Role:{UserID:1 Name:Admin}}\n\t// {ID:2 FirstName:Sally LastName:Yukon Role:{UserID:2 Name:Manager}}\n\t// {ID:3 FirstName:Vinita LastName:Yukon Role:{UserID:3 Name:Manager}}\n\t// {ID:4 FirstName:John LastName:Doe Role:{UserID:4 Name:User}}\n}\n\nfunc ExampleSelectDataset_ScanStruct() {\n\ttype User struct {\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\tdb := getDB()\n\tfindUserByName := func(name string) {\n\t\tvar user User\n\t\tds := db.From(\"goqu_user\").Where(goqu.C(\"first_name\").Eq(name))\n\t\tfound, err := ds.ScanStruct(&user)\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tfmt.Println(err.Error())\n\t\tcase !found:\n\t\t\tfmt.Printf(\"No user found for first_name %s\\n\", name)\n\t\tdefault:\n\t\t\tfmt.Printf(\"Found user: %+v\\n\", user)\n\t\t}\n\t}\n\n\tfindUserByName(\"Bob\")\n\tfindUserByName(\"Zeb\")\n\n\t// Output:\n\t// Found user: {FirstName:Bob LastName:Yukon}\n\t// No user found for first_name Zeb\n}\n\n// In this example we create a new struct that has two structs that represent two table\n// the User and Role fields are tagged with the table name\nfunc ExampleSelectDataset_ScanStruct_withJoinAutoSelect() {\n\ttype Role struct {\n\t\tUserID uint64 `db:\"user_id\"`\n\t\tName   string `db:\"name\"`\n\t}\n\ttype User struct {\n\t\tID        uint64 `db:\"id\"`\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\ttype UserAndRole struct {\n\t\tUser User `db:\"goqu_user\"` // tag as the \"goqu_user\" table\n\t\tRole Role `db:\"user_role\"` // tag as \"user_role\" table\n\t}\n\tdb := getDB()\n\tfindUserAndRoleByName := func(name string) {\n\t\tvar userAndRole UserAndRole\n\t\tds := db.\n\t\t\tFrom(\"goqu_user\").\n\t\t\tJoin(\n\t\t\t\tgoqu.T(\"user_role\"),\n\t\t\t\tgoqu.On(goqu.I(\"goqu_user.id\").Eq(goqu.I(\"user_role.user_id\"))),\n\t\t\t).\n\t\t\tWhere(goqu.C(\"first_name\").Eq(name))\n\t\tfound, err := ds.ScanStruct(&userAndRole)\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tfmt.Println(err.Error())\n\t\tcase !found:\n\t\t\tfmt.Printf(\"No user found for first_name %s\\n\", name)\n\t\tdefault:\n\t\t\tfmt.Printf(\"Found user and role: %+v\\n\", userAndRole)\n\t\t}\n\t}\n\n\tfindUserAndRoleByName(\"Bob\")\n\tfindUserAndRoleByName(\"Zeb\")\n\t// Output:\n\t// Found user and role: {User:{ID:1 FirstName:Bob LastName:Yukon} Role:{UserID:1 Name:Admin}}\n\t// No user found for first_name Zeb\n}\n\n// In this example we create a new struct that has the user properties as well as a nested\n// Role struct from the join table\nfunc ExampleSelectDataset_ScanStruct_withJoinManualSelect() {\n\ttype Role struct {\n\t\tUserID uint64 `db:\"user_id\"`\n\t\tName   string `db:\"name\"`\n\t}\n\ttype User struct {\n\t\tID        uint64 `db:\"id\"`\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t\tRole      Role   `db:\"user_role\"` // tag as \"user_role\" table\n\t}\n\tdb := getDB()\n\tfindUserByName := func(name string) {\n\t\tvar userAndRole User\n\t\tds := db.\n\t\t\tSelect(\n\t\t\t\t\"goqu_user.id\",\n\t\t\t\t\"goqu_user.first_name\",\n\t\t\t\t\"goqu_user.last_name\",\n\t\t\t\t// alias the fully qualified identifier `C` is important here so it doesnt parse it\n\t\t\t\tgoqu.I(\"user_role.user_id\").As(goqu.C(\"user_role.user_id\")),\n\t\t\t\tgoqu.I(\"user_role.name\").As(goqu.C(\"user_role.name\")),\n\t\t\t).\n\t\t\tFrom(\"goqu_user\").\n\t\t\tJoin(\n\t\t\t\tgoqu.T(\"user_role\"),\n\t\t\t\tgoqu.On(goqu.I(\"goqu_user.id\").Eq(goqu.I(\"user_role.user_id\"))),\n\t\t\t).\n\t\t\tWhere(goqu.C(\"first_name\").Eq(name))\n\t\tfound, err := ds.ScanStruct(&userAndRole)\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tfmt.Println(err.Error())\n\t\tcase !found:\n\t\t\tfmt.Printf(\"No user found for first_name %s\\n\", name)\n\t\tdefault:\n\t\t\tfmt.Printf(\"Found user and role: %+v\\n\", userAndRole)\n\t\t}\n\t}\n\n\tfindUserByName(\"Bob\")\n\tfindUserByName(\"Zeb\")\n\n\t// Output:\n\t// Found user and role: {ID:1 FirstName:Bob LastName:Yukon Role:{UserID:1 Name:Admin}}\n\t// No user found for first_name Zeb\n}\n\nfunc ExampleSelectDataset_ScanVals() {\n\tvar ids []int64\n\tif err := getDB().From(\"goqu_user\").Select(\"id\").ScanVals(&ids); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"UserIds = %+v\", ids)\n\n\t// Output:\n\t// UserIds = [1 2 3 4]\n}\n\nfunc ExampleSelectDataset_ScanVal() {\n\tdb := getDB()\n\tfindUserIDByName := func(name string) {\n\t\tvar id int64\n\t\tds := db.From(\"goqu_user\").\n\t\t\tSelect(\"id\").\n\t\t\tWhere(goqu.C(\"first_name\").Eq(name))\n\n\t\tfound, err := ds.ScanVal(&id)\n\t\tswitch {\n\t\tcase err != nil:\n\t\t\tfmt.Println(err.Error())\n\t\tcase !found:\n\t\t\tfmt.Printf(\"No id found for user %s\", name)\n\t\tdefault:\n\t\t\tfmt.Printf(\"\\nFound userId: %+v\\n\", id)\n\t\t}\n\t}\n\n\tfindUserIDByName(\"Bob\")\n\tfindUserIDByName(\"Zeb\")\n\t// Output:\n\t// Found userId: 1\n\t// No id found for user Zeb\n}\n\nfunc ExampleSelectDataset_Count() {\n\tcount, err := getDB().From(\"goqu_user\").Count()\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"Count is %d\", count)\n\n\t// Output:\n\t// Count is 4\n}\n\nfunc ExampleSelectDataset_Pluck() {\n\tvar lastNames []string\n\tif err := getDB().From(\"goqu_user\").Pluck(&lastNames, \"last_name\"); err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\tfmt.Printf(\"LastNames = %+v\", lastNames)\n\n\t// Output:\n\t// LastNames = [Yukon Yukon Yukon Doe]\n}\n\nfunc ExampleSelectDataset_Executor_scannerScanStruct() {\n\ttype User struct {\n\t\tFirstName string `db:\"first_name\"`\n\t\tLastName  string `db:\"last_name\"`\n\t}\n\tdb := getDB()\n\n\tscanner, err := db.\n\t\tFrom(\"goqu_user\").\n\t\tSelect(\"first_name\", \"last_name\").\n\t\tWhere(goqu.Ex{\n\t\t\t\"last_name\": \"Yukon\",\n\t\t}).\n\t\tExecutor().\n\t\tScanner()\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\n\tdefer scanner.Close()\n\n\tfor scanner.Next() {\n\t\tu := User{}\n\n\t\terr = scanner.ScanStruct(&u)\n\t\tif err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Printf(\"\\n%+v\", u)\n\t}\n\n\tif scanner.Err() != nil {\n\t\tfmt.Println(scanner.Err().Error())\n\t}\n\n\t// Output:\n\t// {FirstName:Bob LastName:Yukon}\n\t// {FirstName:Sally LastName:Yukon}\n\t// {FirstName:Vinita LastName:Yukon}\n}\n\nfunc ExampleSelectDataset_Executor_scannerScanVal() {\n\tdb := getDB()\n\n\tscanner, err := db.\n\t\tFrom(\"goqu_user\").\n\t\tSelect(\"first_name\").\n\t\tWhere(goqu.Ex{\n\t\t\t\"last_name\": \"Yukon\",\n\t\t}).\n\t\tExecutor().\n\t\tScanner()\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn\n\t}\n\n\tdefer scanner.Close()\n\n\tfor scanner.Next() {\n\t\tname := \"\"\n\n\t\terr = scanner.ScanVal(&name)\n\t\tif err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Println(name)\n\t}\n\n\tif scanner.Err() != nil {\n\t\tfmt.Println(scanner.Err().Error())\n\t}\n\n\t// Output:\n\t// Bob\n\t// Sally\n\t// Vinita\n}\n\nfunc ExampleForUpdate() {\n\tsql, args, _ := goqu.From(\"test\").ForUpdate(exp.Wait).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" FOR UPDATE  []\n}\n\nfunc ExampleForUpdate_of() {\n\tsql, args, _ := goqu.From(\"test\").ForUpdate(exp.Wait, goqu.T(\"test\")).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"test\" FOR UPDATE OF \"test\"  []\n}\n\nfunc ExampleForUpdate_ofMultiple() {\n\tsql, args, _ := goqu.From(\"table1\").Join(\n\t\tgoqu.T(\"table2\"),\n\t\tgoqu.On(goqu.I(\"table2.id\").Eq(goqu.I(\"table1.id\"))),\n\t).ForUpdate(\n\t\texp.Wait,\n\t\tgoqu.T(\"table1\"),\n\t\tgoqu.T(\"table2\"),\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM \"table1\" INNER JOIN \"table2\" ON (\"table2\".\"id\" = \"table1\".\"id\") FOR UPDATE OF \"table1\", \"table2\"  []\n}\n"
        },
        {
          "name": "select_dataset_test.go",
          "type": "blob",
          "size": 47.3916015625,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/mocks\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\tselectTestCase struct {\n\t\tds      *goqu.SelectDataset\n\t\tclauses exp.SelectClauses\n\t}\n\tdsTestActionItem struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tdsUntaggedTestActionItem struct {\n\t\tAddress  string `db:\"address\"`\n\t\tName     string `db:\"name\"`\n\t\tUntagged string\n\t}\n\tselectDatasetSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (sds *selectDatasetSuite) assertCases(cases ...selectTestCase) {\n\tfor _, s := range cases {\n\t\tsds.Equal(s.clauses, s.ds.GetClauses())\n\t}\n}\n\nfunc (sds *selectDatasetSuite) TestReturnsColumns() {\n\tds := goqu.Select(goqu.L(\"NOW()\"))\n\tsds.True(ds.ReturnsColumns())\n}\n\nfunc (sds *selectDatasetSuite) TestClone() {\n\tds := goqu.From(\"test\")\n\tsds.Equal(ds, ds.Clone())\n}\n\nfunc (sds *selectDatasetSuite) TestExpression() {\n\tds := goqu.From(\"test\")\n\tsds.Equal(ds, ds.Expression())\n}\n\nfunc (sds *selectDatasetSuite) TestDialect() {\n\tds := goqu.From(\"test\")\n\tsds.NotNil(ds.Dialect())\n}\n\nfunc (sds *selectDatasetSuite) TestWithDialect() {\n\tds := goqu.From(\"test\")\n\tmd := new(mocks.SQLDialect)\n\tds = ds.SetDialect(md)\n\n\tdialect := goqu.GetDialect(\"default\")\n\tdialectDs := ds.WithDialect(\"default\")\n\tsds.Equal(md, ds.Dialect())\n\tsds.Equal(dialect, dialectDs.Dialect())\n}\n\nfunc (sds *selectDatasetSuite) TestPrepared() {\n\tds := goqu.From(\"test\")\n\tpreparedDs := ds.Prepared(true)\n\tsds.True(preparedDs.IsPrepared())\n\tsds.False(ds.IsPrepared())\n\t// should apply the prepared to any datasets created from the root\n\tsds.True(preparedDs.Where(goqu.Ex{\"a\": 1}).IsPrepared())\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\t// should be prepared by default\n\tds = goqu.From(\"test\")\n\tsds.True(ds.IsPrepared())\n}\n\nfunc (sds *selectDatasetSuite) TestGetClauses() {\n\tds := goqu.From(\"test\")\n\tce := exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(goqu.I(\"test\")))\n\tsds.Equal(ce, ds.GetClauses())\n}\n\nfunc (sds *selectDatasetSuite) TestUpdate() {\n\twhere := goqu.Ex{\"a\": 1}\n\tfrom := goqu.From(\"cte\")\n\tlimit := uint(1)\n\torder := []exp.OrderedExpression{goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()}\n\tds := goqu.From(\"test\").\n\t\tWith(\"test-cte\", from).\n\t\tWhere(where).\n\t\tLimit(limit).\n\t\tOrder(order...)\n\tec := exp.NewUpdateClauses().\n\t\tSetTable(goqu.C(\"test\")).\n\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from)).\n\t\tWhereAppend(ds.GetClauses().Where()).\n\t\tSetLimit(limit).\n\t\tSetOrder(order...)\n\tsds.Equal(ec, ds.Update().GetClauses())\n}\n\nfunc (sds *selectDatasetSuite) TestInsert() {\n\twhere := goqu.Ex{\"a\": 1}\n\tfrom := goqu.From(\"cte\")\n\tlimit := uint(1)\n\torder := []exp.OrderedExpression{goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()}\n\tds := goqu.From(\"test\").\n\t\tWith(\"test-cte\", from).\n\t\tWhere(where).\n\t\tLimit(limit).\n\t\tOrder(order...)\n\tec := exp.NewInsertClauses().\n\t\tSetInto(goqu.C(\"test\")).\n\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from))\n\tsds.Equal(ec, ds.Insert().GetClauses())\n}\n\nfunc (sds *selectDatasetSuite) TestDelete() {\n\twhere := goqu.Ex{\"a\": 1}\n\tfrom := goqu.From(\"cte\")\n\tlimit := uint(1)\n\torder := []exp.OrderedExpression{goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()}\n\tds := goqu.From(\"test\").\n\t\tWith(\"test-cte\", from).\n\t\tWhere(where).\n\t\tLimit(limit).\n\t\tOrder(order...)\n\tec := exp.NewDeleteClauses().\n\t\tSetFrom(goqu.C(\"test\")).\n\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from)).\n\t\tWhereAppend(ds.GetClauses().Where()).\n\t\tSetLimit(limit).\n\t\tSetOrder(order...)\n\tsds.Equal(ec, ds.Delete().GetClauses())\n}\n\nfunc (sds *selectDatasetSuite) TestTruncate() {\n\twhere := goqu.Ex{\"a\": 1}\n\tfrom := goqu.From(\"cte\")\n\tlimit := uint(1)\n\torder := []exp.OrderedExpression{goqu.C(\"a\").Asc(), goqu.C(\"b\").Desc()}\n\tds := goqu.From(\"test\").\n\t\tWith(\"test-cte\", from).\n\t\tWhere(where).\n\t\tLimit(limit).\n\t\tOrder(order...)\n\tec := exp.NewTruncateClauses().\n\t\tSetTable(exp.NewColumnListExpression(\"test\"))\n\tsds.Equal(ec, ds.Truncate().GetClauses())\n}\n\nfunc (sds *selectDatasetSuite) TestWith() {\n\tfrom := goqu.From(\"cte\")\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.With(\"test-cte\", from),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestWithRecursive() {\n\tfrom := goqu.From(\"cte\")\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.WithRecursive(\"test-cte\", from),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(true, \"test-cte\", from)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestSelect() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Select(\"a\", \"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Select(\"a\").Select(\"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"b\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Select(\"a\").Select(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestSelectDistinct() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.SelectDistinct(\"a\", \"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"a\", \"b\")).\n\t\t\t\tSetDistinct(exp.NewColumnListExpression()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.SelectDistinct(\"a\").SelectDistinct(\"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"b\")).\n\t\t\t\tSetDistinct(exp.NewColumnListExpression()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Select(\"a\").SelectDistinct(\"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"b\")).\n\t\t\t\tSetDistinct(exp.NewColumnListExpression()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Select(\"a\").SelectDistinct(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(goqu.Star())).\n\t\t\t\tSetDistinct(nil),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.SelectDistinct(\"a\").SelectDistinct(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(goqu.Star())).\n\t\t\t\tSetDistinct(nil),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestClearSelect() {\n\tbd := goqu.From(\"test\").Select(\"a\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ClearSelect(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"a\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestSelectAppend() {\n\tbd := goqu.From(\"test\").Select(\"a\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.SelectAppend(\"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetSelect(exp.NewColumnListExpression(\"a\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestDistinct() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Distinct(\"a\", \"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetDistinct(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Distinct(\"a\").Distinct(\"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetDistinct(exp.NewColumnListExpression(\"b\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestFrom() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.From(goqu.T(\"test2\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(goqu.T(\"test2\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.From(goqu.From(\"test\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(goqu.From(\"test\").As(\"t1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestFromSelf() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.FromSelf(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(bd.As(\"t1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.As(\"alias\").FromSelf(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(bd.As(\"alias\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestCompoundFromSelf() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds:      bd.CompoundFromSelf(),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd.Limit(10).CompoundFromSelf(),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(bd.Limit(10).As(\"t1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Asc()).CompoundFromSelf(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(bd.Order(goqu.C(\"a\").Asc()).As(\"t1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.As(\"alias\").FromSelf(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(bd.As(\"alias\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Join(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.InnerJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestInnerJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.InnerJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.InnerJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestFullOuterJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.FullOuterJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.FullOuterJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestRightOuterJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.RightOuterJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.RightOuterJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestLeftOuterJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.LeftOuterJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.LeftOuterJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestFullJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.FullJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.FullJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestRightJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.RightJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.RightJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestLeftJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.LeftJoin(goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewConditionedJoinExpression(exp.LeftJoinType, goqu.T(\"foo\"), goqu.On(goqu.C(\"a\").IsNull())),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestNaturalJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.NaturalJoin(goqu.T(\"foo\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewUnConditionedJoinExpression(exp.NaturalJoinType, goqu.T(\"foo\")),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestNaturalLeftJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.NaturalLeftJoin(goqu.T(\"foo\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewUnConditionedJoinExpression(exp.NaturalLeftJoinType, goqu.T(\"foo\")),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestNaturalRightJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.NaturalRightJoin(goqu.T(\"foo\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewUnConditionedJoinExpression(exp.NaturalRightJoinType, goqu.T(\"foo\")),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestNaturalFullJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.NaturalFullJoin(goqu.T(\"foo\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewUnConditionedJoinExpression(exp.NaturalFullJoinType, goqu.T(\"foo\")),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestCrossJoin() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.CrossJoin(goqu.T(\"foo\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tJoinsAppend(\n\t\t\t\t\texp.NewUnConditionedJoinExpression(exp.CrossJoinType, goqu.T(\"foo\")),\n\t\t\t\t),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestWhere() {\n\tw := goqu.Ex{\"a\": 1}\n\tw2 := goqu.Ex{\"b\": \"c\"}\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Where(w),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWhereAppend(w),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Where(w).Where(w2),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWhereAppend(w).WhereAppend(w2),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestClearWhere() {\n\tw := goqu.Ex{\"a\": 1}\n\tbd := goqu.From(\"test\").Where(w)\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ClearWhere(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).WhereAppend(w),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestForUpdate() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ForUpdate(goqu.NoWait),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForUpdate, goqu.NoWait)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForUpdate(goqu.NoWait, goqu.T(\"table1\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForUpdate, goqu.NoWait, goqu.T(\"table1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForUpdate(goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForUpdate, goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestForNoKeyUpdate() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ForNoKeyUpdate(goqu.NoWait),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForNoKeyUpdate, goqu.NoWait)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForNoKeyUpdate(goqu.NoWait, goqu.T(\"table1\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForNoKeyUpdate, goqu.NoWait, goqu.T(\"table1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForNoKeyUpdate(goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForNoKeyUpdate, goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestForKeyShare() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ForKeyShare(goqu.NoWait),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForKeyShare, goqu.NoWait)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForKeyShare(goqu.NoWait, goqu.T(\"table1\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForKeyShare, goqu.NoWait, goqu.T(\"table1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForKeyShare(goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForKeyShare, goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestForShare() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ForShare(goqu.NoWait),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForShare, goqu.NoWait)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForShare(goqu.NoWait, goqu.T(\"table1\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForShare, goqu.NoWait, goqu.T(\"table1\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.ForShare(goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\")),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLock(exp.NewLock(exp.ForShare, goqu.NoWait, goqu.T(\"table1\"), goqu.T(\"table2\"))),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestGroupBy() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.GroupBy(\"a\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetGroupBy(exp.NewColumnListExpression(\"a\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.GroupBy(\"a\").GroupBy(\"b\"),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetGroupBy(exp.NewColumnListExpression(\"b\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestWindow() {\n\tw1 := goqu.W(\"w1\").PartitionBy(\"a\").OrderBy(\"b\")\n\tw2 := goqu.W(\"w2\").PartitionBy(\"a\").OrderBy(\"b\")\n\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Window(w1),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWindowsAppend(w1),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Window(w1).Window(w2),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWindowsAppend(w2),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Window(w1, w2),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWindowsAppend(w1, w2),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestWindowAppend() {\n\tw1 := goqu.W(\"w1\").PartitionBy(\"a\").OrderBy(\"b\")\n\tw2 := goqu.W(\"w2\").PartitionBy(\"a\").OrderBy(\"b\")\n\n\tbd := goqu.From(\"test\").Window(w1)\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.WindowAppend(w2),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWindowsAppend(w1, w2),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWindowsAppend(w1),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestClearWindow() {\n\tw1 := goqu.W(\"w1\").PartitionBy(\"a\").OrderBy(\"b\")\n\n\tbd := goqu.From(\"test\").Window(w1)\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds:      bd.ClearWindow(),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tWindowsAppend(w1),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestHaving() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Having(goqu.C(\"a\").Gt(1)),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tHavingAppend(goqu.C(\"a\").Gt(1)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Having(goqu.C(\"a\").Gt(1)).Having(goqu.Ex{\"b\": \"c\"}),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tHavingAppend(goqu.C(\"a\").Gt(1)).HavingAppend(goqu.Ex{\"b\": \"c\"}),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestOrder() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Asc()),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Asc()).Order(goqu.C(\"b\").Asc()),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"b\").Asc()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestOrderAppend() {\n\tbd := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.OrderAppend(goqu.C(\"b\").Asc()),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc(), goqu.C(\"b\").Asc()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestOrderPrepend() {\n\tbd := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.OrderPrepend(goqu.C(\"b\").Asc()),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"b\").Asc(), goqu.C(\"a\").Asc()),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestClearOrder() {\n\tbd := goqu.From(\"test\").Order(goqu.C(\"a\").Asc())\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.ClearOrder(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOrder(goqu.C(\"a\").Asc()),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestLimit() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Limit(10),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLimit(uint(10)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Limit(0),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Limit(10).Limit(2),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLimit(uint(2)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Limit(10).Limit(0),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestLimitAll() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.LimitAll(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLimit(goqu.L(\"ALL\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd.Limit(10).LimitAll(),\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLimit(goqu.L(\"ALL\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestClearLimit() {\n\tbd := goqu.From(\"test\").Limit(10)\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds:      bd.ClearLimit(),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewSelectClauses().\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetLimit(uint(10)),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestOffset() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds:      bd.Offset(10),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).SetOffset(10),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestClearOffset() {\n\tbd := goqu.From(\"test\").Offset(10)\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds:      bd.ClearOffset(),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).SetOffset(10),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestUnion() {\n\tuds := goqu.From(\"union_test\")\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Union(uds),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tCompoundsAppend(exp.NewCompoundExpression(exp.UnionCompoundType, uds)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestUnionAll() {\n\tuds := goqu.From(\"union_test\")\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.UnionAll(uds),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tCompoundsAppend(exp.NewCompoundExpression(exp.UnionAllCompoundType, uds)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestIntersect() {\n\tuds := goqu.From(\"union_test\")\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.Intersect(uds),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tCompoundsAppend(exp.NewCompoundExpression(exp.IntersectCompoundType, uds)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestIntersectAll() {\n\tuds := goqu.From(\"union_test\")\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.IntersectAll(uds),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tCompoundsAppend(exp.NewCompoundExpression(exp.IntersectAllCompoundType, uds)),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestAs() {\n\tbd := goqu.From(\"test\")\n\tsds.assertCases(\n\t\tselectTestCase{\n\t\t\tds: bd.As(\"t\"),\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetAlias(goqu.T(\"t\")),\n\t\t},\n\t\tselectTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewSelectClauses().SetFrom(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (sds *selectDatasetSuite) TestToSQL() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.From(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToSelectSQL\", sqlB, c).Return(nil).Once()\n\tsql, args, err := ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Nil(err)\n\tmd.AssertExpectations(sds.T())\n}\n\nfunc (sds *selectDatasetSuite) TestToSQL_prepared() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.From(\"test\").Prepared(true).SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(true)\n\tmd.On(\"ToSelectSQL\", sqlB, c).Return(nil).Once()\n\tsql, args, err := ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Nil(err)\n\tmd.AssertExpectations(sds.T())\n}\n\nfunc (sds *selectDatasetSuite) TestToSQL_ReturnedError() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.From(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tee := errors.New(\"expected error\")\n\tmd.On(\"ToSelectSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(ee)\n\t}).Once()\n\n\tsql, args, err := ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Equal(ee, err)\n\tmd.AssertExpectations(sds.T())\n}\n\nfunc (sds *selectDatasetSuite) TestAppendSQL() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.From(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToSelectSQL\", sqlB, c).Return(nil).Once()\n\tds.AppendSQL(sqlB)\n\tsds.NoError(sqlB.Error())\n\tmd.AssertExpectations(sds.T())\n}\n\nfunc (sds *selectDatasetSuite) TestScanStructs() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tsqlMock.ExpectQuery(`SELECT DISTINCT \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\tsqlMock.ExpectQuery(`SELECT \"test\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar items []dsTestActionItem\n\tsds.NoError(db.From(\"items\").ScanStructs(&items))\n\tsds.Equal([]dsTestActionItem{\n\t\t{Address: \"111 Test Addr\", Name: \"Test1\"},\n\t\t{Address: \"211 Test Addr\", Name: \"Test2\"},\n\t}, items)\n\n\titems = items[0:0]\n\tsds.NoError(db.From(\"items\").Select(\"name\").Distinct().ScanStructs(&items))\n\tsds.Equal([]dsTestActionItem{\n\t\t{Address: \"111 Test Addr\", Name: \"Test1\"},\n\t\t{Address: \"211 Test Addr\", Name: \"Test2\"},\n\t}, items)\n\n\titems = items[0:0]\n\tsds.EqualError(db.From(\"items\").ScanStructs(items),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\tsds.EqualError(db.From(\"items\").ScanStructs(&dsTestActionItem{}),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\tsds.EqualError(db.From(\"items\").Select(\"test\").ScanStructs(&items),\n\t\t`goqu: unable to find corresponding field to column \"test\" returned by query`)\n\n\tsds.Equal(goqu.ErrQueryFactoryNotFoundError, goqu.From(\"items\").ScanStructs(items))\n}\n\nfunc (sds *selectDatasetSuite) TestScanStructs_WithPreparedStatements() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \"address\", \"name\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\)`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\").\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).\n\t\t\tFromCSVString(\"111 Test Addr,Test1\\n211 Test Addr,Test2\"))\n\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \"test\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\)`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\").\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar items []dsTestActionItem\n\tsds.NoError(db.From(\"items\").Prepared(true).Where(goqu.Ex{\n\t\t\"name\":    []string{\"Bob\", \"Sally\", \"Billy\"},\n\t\t\"address\": \"111 Test Addr\",\n\t}).ScanStructs(&items))\n\tsds.Equal(items, []dsTestActionItem{\n\t\t{Address: \"111 Test Addr\", Name: \"Test1\"},\n\t\t{Address: \"211 Test Addr\", Name: \"Test2\"},\n\t})\n\n\titems = items[0:0]\n\tsds.EqualError(db.From(\"items\").ScanStructs(items),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\tsds.EqualError(db.From(\"items\").ScanStructs(&dsTestActionItem{}),\n\t\t\"goqu: type must be a pointer to a slice when scanning into structs\")\n\tsds.EqualError(db.From(\"items\").\n\t\tPrepared(true).\n\t\tSelect(\"test\").\n\t\tWhere(goqu.Ex{\"name\": []string{\"Bob\", \"Sally\", \"Billy\"}, \"address\": \"111 Test Addr\"}).\n\t\tScanStructs(&items), `goqu: unable to find corresponding field to column \"test\" returned by query`)\n}\n\nfunc (sds *selectDatasetSuite) TestScanStruct() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).FromCSVString(\"111 Test Addr,Test1\"))\n\n\tsqlMock.ExpectQuery(`SELECT DISTINCT \"name\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).FromCSVString(\"111 Test Addr,Test1\"))\n\n\tsqlMock.ExpectQuery(`SELECT \"test\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar item dsTestActionItem\n\tfound, err := db.From(\"items\").ScanStruct(&item)\n\tsds.NoError(err)\n\tsds.True(found)\n\tsds.Equal(\"111 Test Addr\", item.Address)\n\tsds.Equal(\"Test1\", item.Name)\n\n\titem = dsTestActionItem{}\n\tfound, err = db.From(\"items\").Select(\"name\").Distinct().ScanStruct(&item)\n\tsds.NoError(err)\n\tsds.True(found)\n\tsds.Equal(\"111 Test Addr\", item.Address)\n\tsds.Equal(\"Test1\", item.Name)\n\n\t_, err = db.From(\"items\").ScanStruct(item)\n\tsds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = db.From(\"items\").ScanStruct([]dsTestActionItem{})\n\tsds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = db.From(\"items\").Select(\"test\").ScanStruct(&item)\n\tsds.EqualError(err, `goqu: unable to find corresponding field to column \"test\" returned by query`)\n\n\t_, err = goqu.From(\"items\").ScanStruct(item)\n\tsds.Equal(goqu.ErrQueryFactoryNotFoundError, err)\n}\n\nfunc (sds *selectDatasetSuite) TestScanStruct_WithPreparedStatements() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \"address\", \"name\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\) LIMIT \\?`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\", 1).\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).FromCSVString(\"111 Test Addr,Test1\"))\n\n\tsqlMock.ExpectQuery(`SELECT \"test\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\) LIMIT \\?`).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\", 1).\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"test\"}).FromCSVString(\"test1\\ntest2\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar item dsTestActionItem\n\tfound, err := db.From(\"items\").Prepared(true).Where(goqu.Ex{\n\t\t\"name\":    []string{\"Bob\", \"Sally\", \"Billy\"},\n\t\t\"address\": \"111 Test Addr\",\n\t}).ScanStruct(&item)\n\tsds.NoError(err)\n\tsds.True(found)\n\tsds.Equal(\"111 Test Addr\", item.Address)\n\tsds.Equal(\"Test1\", item.Name)\n\n\t_, err = db.From(\"items\").ScanStruct(item)\n\tsds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = db.From(\"items\").ScanStruct([]dsTestActionItem{})\n\tsds.EqualError(err, \"goqu: type must be a pointer to a struct when scanning into a struct\")\n\t_, err = db.From(\"items\").\n\t\tPrepared(true).\n\t\tSelect(\"test\").\n\t\tWhere(goqu.Ex{\"name\": []string{\"Bob\", \"Sally\", \"Billy\"}, \"address\": \"111 Test Addr\"}).\n\t\tScanStruct(&item)\n\tsds.EqualError(err, `goqu: unable to find corresponding field to column \"test\" returned by query`)\n}\n\nfunc (sds *selectDatasetSuite) TestScanStructUntagged() {\n\tdefer goqu.SetIgnoreUntaggedFields(false)\n\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\", \"untagged\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\", \"untagged\"}).FromCSVString(\"111 Test Addr,Test1,Test2\"))\n\n\tsqlMock.ExpectQuery(`SELECT \"address\", \"name\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"address\", \"name\"}).FromCSVString(\"111 Test Addr,Test1\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar item dsUntaggedTestActionItem\n\n\tfound, err := db.From(\"items\").ScanStruct(&item)\n\tsds.NoError(err)\n\tsds.True(found)\n\tsds.Equal(\"111 Test Addr\", item.Address)\n\tsds.Equal(\"Test1\", item.Name)\n\tsds.Equal(\"Test2\", item.Untagged)\n\n\t// Ignore untagged fields, which will suppress the \"untagged\" column\n\tgoqu.SetIgnoreUntaggedFields(true)\n\n\titem = dsUntaggedTestActionItem{}\n\tfound, err = db.From(\"items\").ScanStruct(&item)\n\tsds.NoError(err)\n\tsds.True(found)\n\tsds.Equal(\"111 Test Addr\", item.Address)\n\tsds.Equal(\"Test1\", item.Name)\n\tsds.Equal(\"\", item.Untagged)\n}\n\nfunc (sds *selectDatasetSuite) TestScanVals() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT \"id\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tsqlMock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tsqlMock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar ids []uint32\n\tsds.NoError(db.From(\"items\").Select(\"id\").ScanVals(&ids))\n\tsds.Equal(ids, []uint32{1, 2, 3, 4, 5})\n\n\tsds.EqualError(db.From(\"items\").ScanVals([]uint32{}),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n\tsds.EqualError(db.From(\"items\").ScanVals(dsTestActionItem{}),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n\n\terr = goqu.From(\"items\").ScanVals(&ids)\n\tsds.Equal(goqu.ErrQueryFactoryNotFoundError, err)\n}\n\nfunc (sds *selectDatasetSuite) TestScanVals_WithPreparedStatment() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \"id\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\)`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\").\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\n\tsqlMock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\tsqlMock.ExpectQuery(`SELECT \\* FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"1\\n2\\n3\\n4\\n5\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar ids []uint32\n\tsds.NoError(db.From(\"items\").\n\t\tPrepared(true).\n\t\tSelect(\"id\").\n\t\tWhere(goqu.Ex{\"name\": []string{\"Bob\", \"Sally\", \"Billy\"}, \"address\": \"111 Test Addr\"}).\n\t\tScanVals(&ids))\n\tsds.Equal([]uint32{1, 2, 3, 4, 5}, ids)\n\n\tsds.EqualError(db.From(\"items\").ScanVals([]uint32{}),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n\n\tsds.EqualError(db.From(\"items\").ScanVals(dsTestActionItem{}),\n\t\t\"goqu: type must be a pointer to a slice when scanning into vals\")\n}\n\nfunc (sds *selectDatasetSuite) TestScanVal() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT \"id\" FROM \"items\" LIMIT 1`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"10\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar id int64\n\tfound, err := db.From(\"items\").Select(\"id\").ScanVal(&id)\n\tsds.NoError(err)\n\tsds.Equal(id, int64(10))\n\tsds.True(found)\n\n\tfound, err = db.From(\"items\").ScanVal([]int64{})\n\tsds.False(found)\n\tsds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n\tfound, err = db.From(\"items\").ScanVal(10)\n\tsds.False(found)\n\tsds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n\n\t_, err = goqu.From(\"items\").ScanVal(&id)\n\tsds.Equal(goqu.ErrQueryFactoryNotFoundError, err)\n}\n\nfunc (sds *selectDatasetSuite) TestScanVal_WithPreparedStatement() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \"id\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\) LIMIT ?`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\", 1).\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"id\"}).FromCSVString(\"10\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar id int64\n\tfound, err := db.From(\"items\").\n\t\tPrepared(true).\n\t\tSelect(\"id\").\n\t\tWhere(goqu.Ex{\"name\": []string{\"Bob\", \"Sally\", \"Billy\"}, \"address\": \"111 Test Addr\"}).\n\t\tScanVal(&id)\n\tsds.NoError(err)\n\tsds.Equal(int64(10), id)\n\tsds.True(found)\n\n\tfound, err = db.From(\"items\").ScanVal([]int64{})\n\tsds.False(found)\n\tsds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n\tfound, err = db.From(\"items\").ScanVal(10)\n\tsds.False(found)\n\tsds.EqualError(err, \"goqu: type must be a pointer when scanning into val\")\n}\n\nfunc (sds *selectDatasetSuite) TestCount() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT COUNT\\(\\*\\) AS \"count\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"count\"}).FromCSVString(\"10\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tcount, err := db.From(\"items\").Count()\n\tsds.NoError(err)\n\tsds.Equal(count, int64(10))\n}\n\nfunc (sds *selectDatasetSuite) TestCount_WithPreparedStatement() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT COUNT\\(\\*\\) AS \"count\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\)`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\", 1).\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"count\"}).FromCSVString(\"10\"))\n\n\tds := goqu.New(\"mock\", mDB)\n\tcount, err := ds.From(\"items\").\n\t\tPrepared(true).\n\t\tWhere(goqu.Ex{\"name\": []string{\"Bob\", \"Sally\", \"Billy\"}, \"address\": \"111 Test Addr\"}).\n\t\tCount()\n\tsds.NoError(err)\n\tsds.Equal(int64(10), count)\n}\n\nfunc (sds *selectDatasetSuite) TestPluck() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(`SELECT \"name\" FROM \"items\"`).\n\t\tWithArgs().\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"name\"}).FromCSVString(\"test1\\ntest2\\ntest3\\ntest4\\ntest5\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar names []string\n\tsds.NoError(db.From(\"items\").Pluck(&names, \"name\"))\n\tsds.Equal([]string{\"test1\", \"test2\", \"test3\", \"test4\", \"test5\"}, names)\n}\n\nfunc (sds *selectDatasetSuite) TestPluck_WithPreparedStatement() {\n\tmDB, sqlMock, err := sqlmock.New()\n\tsds.NoError(err)\n\tsqlMock.ExpectQuery(\n\t\t`SELECT \"name\" FROM \"items\" WHERE \\(\\(\"address\" = \\?\\) AND \\(\"name\" IN \\(\\?, \\?, \\?\\)\\)\\)`,\n\t).\n\t\tWithArgs(\"111 Test Addr\", \"Bob\", \"Sally\", \"Billy\").\n\t\tWillReturnRows(sqlmock.NewRows([]string{\"name\"}).FromCSVString(\"Bob\\nSally\\nBilly\"))\n\n\tdb := goqu.New(\"mock\", mDB)\n\tvar names []string\n\tsds.NoError(db.From(\"items\").\n\t\tPrepared(true).\n\t\tWhere(goqu.Ex{\"name\": []string{\"Bob\", \"Sally\", \"Billy\"}, \"address\": \"111 Test Addr\"}).\n\t\tPluck(&names, \"name\"))\n\tsds.Equal([]string{\"Bob\", \"Sally\", \"Billy\"}, names)\n}\n\nfunc (sds *selectDatasetSuite) TestSetError() {\n\terr1 := errors.New(\"error #1\")\n\terr2 := errors.New(\"error #2\")\n\terr3 := errors.New(\"error #3\")\n\n\t// Verify initial error set/get works properly\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.From(\"test\").SetDialect(md)\n\tds = ds.SetError(err1)\n\tsds.Equal(err1, ds.Error())\n\tsql, args, err := ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Equal(err1, err)\n\n\t// Repeated SetError calls on Dataset should not overwrite the original error\n\tds = ds.SetError(err2)\n\tsds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Equal(err1, err)\n\n\t// Builder functions should not lose the error\n\tds = ds.ClearWindow()\n\tsds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Equal(err1, err)\n\n\t// Deeper errors inside SQL generation should still return original error\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToInsertSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(err3)\n\t}).Once()\n\n\tsql, args, err = ds.ToSQL()\n\tsds.Empty(sql)\n\tsds.Empty(args)\n\tsds.Equal(err1, err)\n}\n\nfunc TestSelectDataset(t *testing.T) {\n\tsuite.Run(t, new(selectDatasetSuite))\n}\n"
        },
        {
          "name": "sql_dialect.go",
          "type": "blob",
          "size": 3.0107421875,
          "content": "package goqu\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/sqlgen\"\n)\n\ntype (\n\tSQLDialectOptions = sqlgen.SQLDialectOptions\n\t// An adapter interface to be used by a Dataset to generate SQL for a specific dialect.\n\t// See DefaultAdapter for a concrete implementation and examples.\n\tSQLDialect interface {\n\t\tDialect() string\n\t\tToSelectSQL(b sb.SQLBuilder, clauses exp.SelectClauses)\n\t\tToUpdateSQL(b sb.SQLBuilder, clauses exp.UpdateClauses)\n\t\tToInsertSQL(b sb.SQLBuilder, clauses exp.InsertClauses)\n\t\tToDeleteSQL(b sb.SQLBuilder, clauses exp.DeleteClauses)\n\t\tToTruncateSQL(b sb.SQLBuilder, clauses exp.TruncateClauses)\n\t}\n\t// The default adapter. This class should be used when building a new adapter. When creating a new adapter you can\n\t// either override methods, or more typically update default values.\n\t// See (github.com/doug-martin/goqu/dialect/postgres)\n\tsqlDialect struct {\n\t\tdialect        string\n\t\tdialectOptions *SQLDialectOptions\n\t\tselectGen      sqlgen.SelectSQLGenerator\n\t\tupdateGen      sqlgen.UpdateSQLGenerator\n\t\tinsertGen      sqlgen.InsertSQLGenerator\n\t\tdeleteGen      sqlgen.DeleteSQLGenerator\n\t\ttruncateGen    sqlgen.TruncateSQLGenerator\n\t}\n)\n\nvar (\n\tdialects              = make(map[string]SQLDialect)\n\tDefaultDialectOptions = sqlgen.DefaultDialectOptions\n\tdialectsMu            sync.RWMutex\n)\n\nfunc init() {\n\tRegisterDialect(\"default\", DefaultDialectOptions())\n}\n\nfunc RegisterDialect(name string, do *SQLDialectOptions) {\n\tdialectsMu.Lock()\n\tdefer dialectsMu.Unlock()\n\tlowerName := strings.ToLower(name)\n\tdialects[lowerName] = newDialect(lowerName, do)\n}\n\nfunc DeregisterDialect(name string) {\n\tdialectsMu.Lock()\n\tdefer dialectsMu.Unlock()\n\tdelete(dialects, strings.ToLower(name))\n}\n\nfunc GetDialect(name string) SQLDialect {\n\tname = strings.ToLower(name)\n\tif d, ok := dialects[name]; ok {\n\t\treturn d\n\t}\n\treturn newDialect(\"default\", DefaultDialectOptions())\n}\n\nfunc newDialect(dialect string, do *SQLDialectOptions) SQLDialect {\n\treturn &sqlDialect{\n\t\tdialect:        dialect,\n\t\tdialectOptions: do,\n\t\tselectGen:      sqlgen.NewSelectSQLGenerator(dialect, do),\n\t\tupdateGen:      sqlgen.NewUpdateSQLGenerator(dialect, do),\n\t\tinsertGen:      sqlgen.NewInsertSQLGenerator(dialect, do),\n\t\tdeleteGen:      sqlgen.NewDeleteSQLGenerator(dialect, do),\n\t\ttruncateGen:    sqlgen.NewTruncateSQLGenerator(dialect, do),\n\t}\n}\n\nfunc (d *sqlDialect) Dialect() string {\n\treturn d.dialect\n}\n\nfunc (d *sqlDialect) ToSelectSQL(b sb.SQLBuilder, clauses exp.SelectClauses) {\n\td.selectGen.Generate(b, clauses)\n}\n\nfunc (d *sqlDialect) ToUpdateSQL(b sb.SQLBuilder, clauses exp.UpdateClauses) {\n\td.updateGen.Generate(b, clauses)\n}\n\nfunc (d *sqlDialect) ToInsertSQL(b sb.SQLBuilder, clauses exp.InsertClauses) {\n\td.insertGen.Generate(b, clauses)\n}\n\nfunc (d *sqlDialect) ToDeleteSQL(b sb.SQLBuilder, clauses exp.DeleteClauses) {\n\td.deleteGen.Generate(b, clauses)\n}\n\nfunc (d *sqlDialect) ToTruncateSQL(b sb.SQLBuilder, clauses exp.TruncateClauses) {\n\td.truncateGen.Generate(b, clauses)\n}\n"
        },
        {
          "name": "sql_dialect_example_test.go",
          "type": "blob",
          "size": 0.37109375,
          "content": "package goqu_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n)\n\nfunc ExampleRegisterDialect() {\n\topts := goqu.DefaultDialectOptions()\n\topts.QuoteRune = '`'\n\tgoqu.RegisterDialect(\"custom-dialect\", opts)\n\n\tdialect := goqu.Dialect(\"custom-dialect\")\n\n\tds := dialect.From(\"test\")\n\n\tsql, args, _ := ds.ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// SELECT * FROM `test` []\n}\n"
        },
        {
          "name": "sql_dialect_internal_test.go",
          "type": "blob",
          "size": 2.2705078125,
          "content": "package goqu\n\nimport (\n\t\"testing\"\n\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/sqlgen/mocks\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype dialectTestSuite struct {\n\tsuite.Suite\n}\n\nfunc (dts *dialectTestSuite) TestDialect() {\n\topts := DefaultDialectOptions()\n\tsm := new(mocks.SelectSQLGenerator)\n\td := sqlDialect{dialect: \"test\", dialectOptions: opts, selectGen: sm}\n\n\tdts.Equal(\"test\", d.Dialect())\n}\n\nfunc (dts *dialectTestSuite) TestToSelectSQL() {\n\topts := DefaultDialectOptions()\n\tsm := new(mocks.SelectSQLGenerator)\n\td := sqlDialect{dialect: \"test\", dialectOptions: opts, selectGen: sm}\n\n\tb := sb.NewSQLBuilder(true)\n\tsc := exp.NewSelectClauses()\n\tsm.On(\"Generate\", b, sc).Return(nil).Once()\n\n\td.ToSelectSQL(b, sc)\n\tsm.AssertExpectations(dts.T())\n}\n\nfunc (dts *dialectTestSuite) TestToUpdateSQL() {\n\topts := DefaultDialectOptions()\n\tum := new(mocks.UpdateSQLGenerator)\n\td := sqlDialect{dialect: \"test\", dialectOptions: opts, updateGen: um}\n\n\tb := sb.NewSQLBuilder(true)\n\tuc := exp.NewUpdateClauses()\n\tum.On(\"Generate\", b, uc).Return(nil).Once()\n\n\td.ToUpdateSQL(b, uc)\n\tum.AssertExpectations(dts.T())\n}\n\nfunc (dts *dialectTestSuite) TestToInsertSQL() {\n\topts := DefaultDialectOptions()\n\tim := new(mocks.InsertSQLGenerator)\n\td := sqlDialect{dialect: \"test\", dialectOptions: opts, insertGen: im}\n\n\tb := sb.NewSQLBuilder(true)\n\tic := exp.NewInsertClauses()\n\tim.On(\"Generate\", b, ic).Return(nil).Once()\n\n\td.ToInsertSQL(b, ic)\n\tim.AssertExpectations(dts.T())\n}\n\nfunc (dts *dialectTestSuite) TestToDeleteSQL() {\n\topts := DefaultDialectOptions()\n\tdm := new(mocks.DeleteSQLGenerator)\n\td := sqlDialect{dialect: \"test\", dialectOptions: opts, deleteGen: dm}\n\n\tb := sb.NewSQLBuilder(true)\n\tdc := exp.NewDeleteClauses()\n\tdm.On(\"Generate\", b, dc).Return(nil).Once()\n\n\td.ToDeleteSQL(b, dc)\n\tdm.AssertExpectations(dts.T())\n}\n\nfunc (dts *dialectTestSuite) TestToTruncateSQL() {\n\topts := DefaultDialectOptions()\n\ttm := new(mocks.TruncateSQLGenerator)\n\td := sqlDialect{dialect: \"test\", dialectOptions: opts, truncateGen: tm}\n\n\tb := sb.NewSQLBuilder(true)\n\ttc := exp.NewTruncateClauses()\n\ttm.On(\"Generate\", b, tc).Return(nil).Once()\n\n\td.ToTruncateSQL(b, tc)\n\ttm.AssertExpectations(dts.T())\n}\n\nfunc TestSQLDialect(t *testing.T) {\n\tsuite.Run(t, new(dialectTestSuite))\n}\n"
        },
        {
          "name": "sqlgen",
          "type": "tree",
          "content": null
        },
        {
          "name": "truncate_dataset.go",
          "type": "blob",
          "size": 4.826171875,
          "content": "package goqu\n\nimport (\n\t\"github.com/doug-martin/goqu/v9/exec\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n)\n\ntype TruncateDataset struct {\n\tdialect      SQLDialect\n\tclauses      exp.TruncateClauses\n\tisPrepared   prepared\n\tqueryFactory exec.QueryFactory\n\terr          error\n}\n\n// used internally by database to create a database with a specific adapter\nfunc newTruncateDataset(d string, queryFactory exec.QueryFactory) *TruncateDataset {\n\treturn &TruncateDataset{\n\t\tclauses:      exp.NewTruncateClauses(),\n\t\tdialect:      GetDialect(d),\n\t\tqueryFactory: queryFactory,\n\t}\n}\n\nfunc Truncate(table ...interface{}) *TruncateDataset {\n\treturn newTruncateDataset(\"default\", nil).Table(table...)\n}\n\n// Sets the adapter used to serialize values and create the SQL statement\nfunc (td *TruncateDataset) WithDialect(dl string) *TruncateDataset {\n\tds := td.copy(td.GetClauses())\n\tds.dialect = GetDialect(dl)\n\treturn ds\n}\n\n// Set the parameter interpolation behavior. See examples\n//\n// prepared: If true the dataset WILL NOT interpolate the parameters.\nfunc (td *TruncateDataset) Prepared(prepared bool) *TruncateDataset {\n\tret := td.copy(td.clauses)\n\tret.isPrepared = preparedFromBool(prepared)\n\treturn ret\n}\n\nfunc (td *TruncateDataset) IsPrepared() bool {\n\treturn td.isPrepared.Bool()\n}\n\n// Returns the current adapter on the dataset\nfunc (td *TruncateDataset) Dialect() SQLDialect {\n\treturn td.dialect\n}\n\n// Returns the current adapter on the dataset\nfunc (td *TruncateDataset) SetDialect(dialect SQLDialect) *TruncateDataset {\n\tcd := td.copy(td.GetClauses())\n\tcd.dialect = dialect\n\treturn cd\n}\n\nfunc (td *TruncateDataset) Expression() exp.Expression {\n\treturn td\n}\n\n// Clones the dataset\nfunc (td *TruncateDataset) Clone() exp.Expression {\n\treturn td.copy(td.clauses)\n}\n\n// Returns the current clauses on the dataset.\nfunc (td *TruncateDataset) GetClauses() exp.TruncateClauses {\n\treturn td.clauses\n}\n\n// used interally to copy the dataset\nfunc (td *TruncateDataset) copy(clauses exp.TruncateClauses) *TruncateDataset {\n\treturn &TruncateDataset{\n\t\tdialect:      td.dialect,\n\t\tclauses:      clauses,\n\t\tisPrepared:   td.isPrepared,\n\t\tqueryFactory: td.queryFactory,\n\t\terr:          td.err,\n\t}\n}\n\n// Adds a FROM clause. This return a new dataset with the original sources replaced. See examples.\n// You can pass in the following.\n//\n//\tstring: Will automatically be turned into an identifier\n//\tIdentifierExpression\n//\tLiteralExpression: (See Literal) Will use the literal SQL\nfunc (td *TruncateDataset) Table(table ...interface{}) *TruncateDataset {\n\treturn td.copy(td.clauses.SetTable(exp.NewColumnListExpression(table...)))\n}\n\n// Adds a CASCADE clause\nfunc (td *TruncateDataset) Cascade() *TruncateDataset {\n\topts := td.clauses.Options()\n\topts.Cascade = true\n\treturn td.copy(td.clauses.SetOptions(opts))\n}\n\n// Clears the CASCADE clause\nfunc (td *TruncateDataset) NoCascade() *TruncateDataset {\n\topts := td.clauses.Options()\n\topts.Cascade = false\n\treturn td.copy(td.clauses.SetOptions(opts))\n}\n\n// Adds a RESTRICT clause\nfunc (td *TruncateDataset) Restrict() *TruncateDataset {\n\topts := td.clauses.Options()\n\topts.Restrict = true\n\treturn td.copy(td.clauses.SetOptions(opts))\n}\n\n// Clears the RESTRICT clause\nfunc (td *TruncateDataset) NoRestrict() *TruncateDataset {\n\topts := td.clauses.Options()\n\topts.Restrict = false\n\treturn td.copy(td.clauses.SetOptions(opts))\n}\n\n// Add a IDENTITY clause (e.g. RESTART)\nfunc (td *TruncateDataset) Identity(identity string) *TruncateDataset {\n\topts := td.clauses.Options()\n\topts.Identity = identity\n\treturn td.copy(td.clauses.SetOptions(opts))\n}\n\n// Get any error that has been set or nil if no error has been set.\nfunc (td *TruncateDataset) Error() error {\n\treturn td.err\n}\n\n// Set an error on the dataset if one has not already been set. This error will be returned by a future call to Error\n// or as part of ToSQL. This can be used by end users to record errors while building up queries without having to\n// track those separately.\nfunc (td *TruncateDataset) SetError(err error) *TruncateDataset {\n\tif td.err == nil {\n\t\ttd.err = err\n\t}\n\n\treturn td\n}\n\n// Generates a TRUNCATE sql statement, if Prepared has been called with true then the parameters will not be interpolated.\n// See examples.\n//\n// Errors:\n//   - There is an error generating the SQL\nfunc (td *TruncateDataset) ToSQL() (sql string, params []interface{}, err error) {\n\treturn td.truncateSQLBuilder().ToSQL()\n}\n\n// Generates the TRUNCATE sql, and returns an Exec struct with the sql set to the TRUNCATE statement\n//\n//\tdb.From(\"test\").Truncate().Executor().Exec()\nfunc (td *TruncateDataset) Executor() exec.QueryExecutor {\n\treturn td.queryFactory.FromSQLBuilder(td.truncateSQLBuilder())\n}\n\nfunc (td *TruncateDataset) truncateSQLBuilder() sb.SQLBuilder {\n\tbuf := sb.NewSQLBuilder(td.isPrepared.Bool())\n\tif td.err != nil {\n\t\treturn buf.SetError(td.err)\n\t}\n\ttd.dialect.ToTruncateSQL(buf, td.clauses)\n\treturn buf\n}\n"
        },
        {
          "name": "truncate_dataset_test.go",
          "type": "blob",
          "size": 8.7861328125,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/mocks\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\ttruncateTestCase struct {\n\t\tds      *goqu.TruncateDataset\n\t\tclauses exp.TruncateClauses\n\t}\n\ttruncateDatasetSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (tds *truncateDatasetSuite) assertCases(cases ...truncateTestCase) {\n\tfor _, s := range cases {\n\t\ttds.Equal(s.clauses, s.ds.GetClauses())\n\t}\n}\n\nfunc (tds *truncateDatasetSuite) TestClone() {\n\tds := goqu.Truncate(\"test\")\n\ttds.Equal(ds, ds.Clone())\n}\n\nfunc (tds *truncateDatasetSuite) TestExpression() {\n\tds := goqu.Truncate(\"test\")\n\ttds.Equal(ds, ds.Expression())\n}\n\nfunc (tds *truncateDatasetSuite) TestDialect() {\n\tds := goqu.Truncate(\"test\")\n\ttds.NotNil(ds.Dialect())\n}\n\nfunc (tds *truncateDatasetSuite) TestWithDialect() {\n\tds := goqu.Truncate(\"test\")\n\tmd := new(mocks.SQLDialect)\n\tds = ds.SetDialect(md)\n\n\tdialect := goqu.GetDialect(\"default\")\n\tdialectDs := ds.WithDialect(\"default\")\n\ttds.Equal(md, ds.Dialect())\n\ttds.Equal(dialect, dialectDs.Dialect())\n}\n\nfunc (tds *truncateDatasetSuite) TestPrepared() {\n\tds := goqu.Truncate(\"test\")\n\tpreparedDs := ds.Prepared(true)\n\ttds.True(preparedDs.IsPrepared())\n\ttds.False(ds.IsPrepared())\n\t// should apply the prepared to any datasets created from the root\n\ttds.True(preparedDs.Restrict().IsPrepared())\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\t// should be prepared by default\n\tds = goqu.Truncate(\"test\")\n\ttds.True(ds.IsPrepared())\n}\n\nfunc (tds *truncateDatasetSuite) TestGetClauses() {\n\tds := goqu.Truncate(\"test\")\n\tce := exp.NewTruncateClauses().SetTable(exp.NewColumnListExpression(goqu.I(\"test\")))\n\ttds.Equal(ce, ds.GetClauses())\n}\n\nfunc (tds *truncateDatasetSuite) TestTable() {\n\tbd := goqu.Truncate(\"test\")\n\ttds.assertCases(\n\t\ttruncateTestCase{\n\t\t\tds: bd.Table(\"test2\"),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test2\")),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Table(\"test1\", \"test2\"),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test1\", \"test2\")),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (tds *truncateDatasetSuite) TestCascade() {\n\tbd := goqu.Truncate(\"test\")\n\ttds.assertCases(\n\t\ttruncateTestCase{\n\t\t\tds: bd.Cascade(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: true}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Restrict().Cascade(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: true, Restrict: true}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (tds *truncateDatasetSuite) TestNoCascade() {\n\tbd := goqu.Truncate(\"test\").Cascade()\n\ttds.assertCases(\n\t\ttruncateTestCase{\n\t\t\tds: bd.NoCascade(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Restrict().NoCascade(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: false, Restrict: true}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: true}),\n\t\t},\n\t)\n}\n\nfunc (tds *truncateDatasetSuite) TestRestrict() {\n\tbd := goqu.Truncate(\"test\")\n\ttds.assertCases(\n\t\ttruncateTestCase{\n\t\t\tds: bd.Restrict(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Restrict: true}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Cascade().Restrict(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: true, Restrict: true}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (tds *truncateDatasetSuite) TestNoRestrict() {\n\tbd := goqu.Truncate(\"test\").Restrict()\n\ttds.assertCases(\n\t\ttruncateTestCase{\n\t\t\tds: bd.NoRestrict(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Cascade().NoRestrict(),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: true, Restrict: false}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Restrict: true}),\n\t\t},\n\t)\n}\n\nfunc (tds *truncateDatasetSuite) TestIdentity() {\n\tbd := goqu.Truncate(\"test\")\n\ttds.assertCases(\n\t\ttruncateTestCase{\n\t\t\tds: bd.Identity(\"RESTART\"),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Identity: \"RESTART\"}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Identity(\"CONTINUE\"),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Identity: \"CONTINUE\"}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd.Cascade().Restrict().Identity(\"CONTINUE\"),\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")).\n\t\t\t\tSetOptions(exp.TruncateOptions{Cascade: true, Restrict: true, Identity: \"CONTINUE\"}),\n\t\t},\n\t\ttruncateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewTruncateClauses().\n\t\t\t\tSetTable(exp.NewColumnListExpression(\"test\")),\n\t\t},\n\t)\n}\n\nfunc (tds *truncateDatasetSuite) TestToSQL() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Truncate(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToTruncateSQL\", sqlB, c).Return(nil).Once()\n\n\tsql, args, err := ds.ToSQL()\n\ttds.NoError(err)\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\tmd.AssertExpectations(tds.T())\n}\n\nfunc (tds *truncateDatasetSuite) TestToSQL__withPrepared() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Truncate(\"test\").Prepared(true).SetDialect(md)\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(true)\n\tmd.On(\"ToTruncateSQL\", sqlB, c).Return(nil).Once()\n\n\tsql, args, err := ds.ToSQL()\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\ttds.Nil(err)\n\tmd.AssertExpectations(tds.T())\n}\n\nfunc (tds *truncateDatasetSuite) TestToSQL_withError() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Truncate(\"test\").SetDialect(md)\n\tc := ds.GetClauses()\n\tee := errors.New(\"expected error\")\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToTruncateSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(ee)\n\t}).Once()\n\n\tsql, args, err := ds.ToSQL()\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\ttds.Equal(ee, err)\n\tmd.AssertExpectations(tds.T())\n}\n\nfunc (tds *truncateDatasetSuite) TestExecutor() {\n\tmDB, _, err := sqlmock.New()\n\ttds.NoError(err)\n\n\tds := goqu.New(\"mock\", mDB).Truncate(\"table1\", \"table2\")\n\n\ttsql, args, err := ds.Executor().ToSQL()\n\ttds.NoError(err)\n\ttds.Empty(args)\n\ttds.Equal(`TRUNCATE \"table1\", \"table2\"`, tsql)\n\n\ttsql, args, err = ds.Prepared(true).Executor().ToSQL()\n\ttds.NoError(err)\n\ttds.Empty(args)\n\ttds.Equal(`TRUNCATE \"table1\", \"table2\"`, tsql)\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\ttsql, args, err = ds.Executor().ToSQL()\n\ttds.NoError(err)\n\ttds.Empty(args)\n\ttds.Equal(`TRUNCATE \"table1\", \"table2\"`, tsql)\n}\n\nfunc (tds *truncateDatasetSuite) TestSetError() {\n\terr1 := errors.New(\"error #1\")\n\terr2 := errors.New(\"error #2\")\n\terr3 := errors.New(\"error #3\")\n\n\t// Verify initial error set/get works properly\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Truncate(\"test\").SetDialect(md)\n\tds = ds.SetError(err1)\n\ttds.Equal(err1, ds.Error())\n\tsql, args, err := ds.ToSQL()\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\ttds.Equal(err1, err)\n\n\t// Repeated SetError calls on Dataset should not overwrite the original error\n\tds = ds.SetError(err2)\n\ttds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\ttds.Equal(err1, err)\n\n\t// Builder functions should not lose the error\n\tds = ds.Cascade()\n\ttds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\ttds.Equal(err1, err)\n\n\t// Deeper errors inside SQL generation should still return original error\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToTruncateSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(err3)\n\t}).Once()\n\n\tsql, args, err = ds.ToSQL()\n\ttds.Empty(sql)\n\ttds.Empty(args)\n\ttds.Equal(err1, err)\n}\n\nfunc TestTruncateDataset(t *testing.T) {\n\tsuite.Run(t, new(truncateDatasetSuite))\n}\n"
        },
        {
          "name": "update_dataset.go",
          "type": "blob",
          "size": 7.8779296875,
          "content": "package goqu\n\nimport (\n\t\"github.com/doug-martin/goqu/v9/exec\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n)\n\ntype UpdateDataset struct {\n\tdialect      SQLDialect\n\tclauses      exp.UpdateClauses\n\tisPrepared   prepared\n\tqueryFactory exec.QueryFactory\n\terr          error\n}\n\nvar ErrUnsupportedUpdateTableType = errors.New(\"unsupported table type, a string or identifier expression is required\")\n\n// used internally by database to create a database with a specific adapter\nfunc newUpdateDataset(d string, queryFactory exec.QueryFactory) *UpdateDataset {\n\treturn &UpdateDataset{\n\t\tclauses:      exp.NewUpdateClauses(),\n\t\tdialect:      GetDialect(d),\n\t\tqueryFactory: queryFactory,\n\t}\n}\n\nfunc Update(table interface{}) *UpdateDataset {\n\treturn newUpdateDataset(\"default\", nil).Table(table)\n}\n\n// Set the parameter interpolation behavior. See examples\n//\n// prepared: If true the dataset WILL NOT interpolate the parameters.\nfunc (ud *UpdateDataset) Prepared(prepared bool) *UpdateDataset {\n\tret := ud.copy(ud.clauses)\n\tret.isPrepared = preparedFromBool(prepared)\n\treturn ret\n}\n\nfunc (ud *UpdateDataset) IsPrepared() bool {\n\treturn ud.isPrepared.Bool()\n}\n\n// Sets the adapter used to serialize values and create the SQL statement\nfunc (ud *UpdateDataset) WithDialect(dl string) *UpdateDataset {\n\tds := ud.copy(ud.GetClauses())\n\tds.dialect = GetDialect(dl)\n\treturn ds\n}\n\n// Returns the current adapter on the dataset\nfunc (ud *UpdateDataset) Dialect() SQLDialect {\n\treturn ud.dialect\n}\n\n// Returns the current adapter on the dataset\nfunc (ud *UpdateDataset) SetDialect(dialect SQLDialect) *UpdateDataset {\n\tcd := ud.copy(ud.GetClauses())\n\tcd.dialect = dialect\n\treturn cd\n}\n\nfunc (ud *UpdateDataset) Expression() exp.Expression {\n\treturn ud\n}\n\n// Clones the dataset\nfunc (ud *UpdateDataset) Clone() exp.Expression {\n\treturn ud.copy(ud.clauses)\n}\n\n// Returns the current clauses on the dataset.\nfunc (ud *UpdateDataset) GetClauses() exp.UpdateClauses {\n\treturn ud.clauses\n}\n\n// used internally to copy the dataset\nfunc (ud *UpdateDataset) copy(clauses exp.UpdateClauses) *UpdateDataset {\n\treturn &UpdateDataset{\n\t\tdialect:      ud.dialect,\n\t\tclauses:      clauses,\n\t\tisPrepared:   ud.isPrepared,\n\t\tqueryFactory: ud.queryFactory,\n\t\terr:          ud.err,\n\t}\n}\n\n// Creates a WITH clause for a common table expression (CTE).\n//\n// The name will be available to use in the UPDATE from in the associated query; and can optionally\n// contain a list of column names \"name(col1, col2, col3)\".\n//\n// The name will refer to the results of the specified subquery.\nfunc (ud *UpdateDataset) With(name string, subquery exp.Expression) *UpdateDataset {\n\treturn ud.copy(ud.clauses.CommonTablesAppend(exp.NewCommonTableExpression(false, name, subquery)))\n}\n\n// Creates a WITH RECURSIVE clause for a common table expression (CTE)\n//\n// The name will be available to use in the UPDATE from in the associated query; and must\n// contain a list of column names \"name(col1, col2, col3)\" for a recursive clause.\n//\n// The name will refer to the results of the specified subquery. The subquery for\n// a recursive query will always end with a UNION or UNION ALL with a clause that\n// refers to the CTE by name.\nfunc (ud *UpdateDataset) WithRecursive(name string, subquery exp.Expression) *UpdateDataset {\n\treturn ud.copy(ud.clauses.CommonTablesAppend(exp.NewCommonTableExpression(true, name, subquery)))\n}\n\n// Sets the table to update.\nfunc (ud *UpdateDataset) Table(table interface{}) *UpdateDataset {\n\tswitch t := table.(type) {\n\tcase exp.Expression:\n\t\treturn ud.copy(ud.clauses.SetTable(t))\n\tcase string:\n\t\treturn ud.copy(ud.clauses.SetTable(exp.ParseIdentifier(t)))\n\tdefault:\n\t\tpanic(ErrUnsupportedUpdateTableType)\n\t}\n}\n\n// Sets the values to use in the SET clause. See examples.\nfunc (ud *UpdateDataset) Set(values interface{}) *UpdateDataset {\n\treturn ud.copy(ud.clauses.SetSetValues(values))\n}\n\n// Allows specifying other tables to reference in your update (If your dialect supports it). See examples.\nfunc (ud *UpdateDataset) From(tables ...interface{}) *UpdateDataset {\n\treturn ud.copy(ud.clauses.SetFrom(exp.NewColumnListExpression(tables...)))\n}\n\n// Adds a WHERE clause. See examples.\nfunc (ud *UpdateDataset) Where(expressions ...exp.Expression) *UpdateDataset {\n\treturn ud.copy(ud.clauses.WhereAppend(expressions...))\n}\n\n// Removes the WHERE clause. See examples.\nfunc (ud *UpdateDataset) ClearWhere() *UpdateDataset {\n\treturn ud.copy(ud.clauses.ClearWhere())\n}\n\n// Adds a ORDER clause. If the ORDER is currently set it replaces it. See examples.\nfunc (ud *UpdateDataset) Order(order ...exp.OrderedExpression) *UpdateDataset {\n\treturn ud.copy(ud.clauses.SetOrder(order...))\n}\n\n// Adds a more columns to the current ORDER BY clause. If no order has be previously specified it is the same as\n// calling Order. See examples.\nfunc (ud *UpdateDataset) OrderAppend(order ...exp.OrderedExpression) *UpdateDataset {\n\treturn ud.copy(ud.clauses.OrderAppend(order...))\n}\n\n// Adds a more columns to the beginning of the current ORDER BY clause. If no order has be previously specified it is the same as\n// calling Order. See examples.\nfunc (ud *UpdateDataset) OrderPrepend(order ...exp.OrderedExpression) *UpdateDataset {\n\treturn ud.copy(ud.clauses.OrderPrepend(order...))\n}\n\n// Removes the ORDER BY clause. See examples.\nfunc (ud *UpdateDataset) ClearOrder() *UpdateDataset {\n\treturn ud.copy(ud.clauses.ClearOrder())\n}\n\n// Adds a LIMIT clause. If the LIMIT is currently set it replaces it. See examples.\nfunc (ud *UpdateDataset) Limit(limit uint) *UpdateDataset {\n\tif limit > 0 {\n\t\treturn ud.copy(ud.clauses.SetLimit(limit))\n\t}\n\treturn ud.copy(ud.clauses.ClearLimit())\n}\n\n// Adds a LIMIT ALL clause. If the LIMIT is currently set it replaces it. See examples.\nfunc (ud *UpdateDataset) LimitAll() *UpdateDataset {\n\treturn ud.copy(ud.clauses.SetLimit(L(\"ALL\")))\n}\n\n// Removes the LIMIT clause.\nfunc (ud *UpdateDataset) ClearLimit() *UpdateDataset {\n\treturn ud.copy(ud.clauses.ClearLimit())\n}\n\n// Adds a RETURNING clause to the dataset if the adapter supports it. See examples.\nfunc (ud *UpdateDataset) Returning(returning ...interface{}) *UpdateDataset {\n\treturn ud.copy(ud.clauses.SetReturning(exp.NewColumnListExpression(returning...)))\n}\n\n// Get any error that has been set or nil if no error has been set.\nfunc (ud *UpdateDataset) Error() error {\n\treturn ud.err\n}\n\n// Set an error on the dataset if one has not already been set. This error will be returned by a future call to Error\n// or as part of ToSQL. This can be used by end users to record errors while building up queries without having to\n// track those separately.\nfunc (ud *UpdateDataset) SetError(err error) *UpdateDataset {\n\tif ud.err == nil {\n\t\tud.err = err\n\t}\n\n\treturn ud\n}\n\n// Generates an UPDATE sql statement, if Prepared has been called with true then the parameters will not be interpolated.\n// See examples.\n//\n// Errors:\n//   - There is an error generating the SQL\nfunc (ud *UpdateDataset) ToSQL() (sql string, params []interface{}, err error) {\n\treturn ud.updateSQLBuilder().ToSQL()\n}\n\n// Appends this Dataset's UPDATE statement to the SQLBuilder\n// This is used internally when using updates in CTEs\nfunc (ud *UpdateDataset) AppendSQL(b sb.SQLBuilder) {\n\tif ud.err != nil {\n\t\tb.SetError(ud.err)\n\t\treturn\n\t}\n\tud.dialect.ToUpdateSQL(b, ud.GetClauses())\n}\n\nfunc (ud *UpdateDataset) GetAs() exp.IdentifierExpression {\n\treturn nil\n}\n\nfunc (ud *UpdateDataset) ReturnsColumns() bool {\n\treturn ud.clauses.HasReturning()\n}\n\n// Generates the UPDATE sql, and returns an exec.QueryExecutor with the sql set to the UPDATE statement\n//\n//\tdb.Update(\"test\").Set(Record{\"name\":\"Bob\", update: time.Now()}).Executor()\nfunc (ud *UpdateDataset) Executor() exec.QueryExecutor {\n\treturn ud.queryFactory.FromSQLBuilder(ud.updateSQLBuilder())\n}\n\nfunc (ud *UpdateDataset) updateSQLBuilder() sb.SQLBuilder {\n\tbuf := sb.NewSQLBuilder(ud.isPrepared.Bool())\n\tif ud.err != nil {\n\t\treturn buf.SetError(ud.err)\n\t}\n\tud.dialect.ToUpdateSQL(buf, ud.clauses)\n\treturn buf\n}\n"
        },
        {
          "name": "update_dataset_example_test.go",
          "type": "blob",
          "size": 19.478515625,
          "content": "//nolint:lll // sql statements are long\npackage goqu_test\n\nimport (\n\tdbsql \"database/sql\"\n\t\"fmt\"\n\n\t\"github.com/doug-martin/goqu/v9\"\n\t_ \"github.com/doug-martin/goqu/v9/dialect/mysql\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n)\n\nfunc ExampleUpdate_withStruct() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdate_withOmitNilTag() {\n\ttype item struct {\n\t\tFirstName string  `db:\"first_name\" goqu:\"omitnil\"`\n\t\tLastName  string  `db:\"last_name\" goqu:\"omitnil\"`\n\t\tAddress1  *string `db:\"address1\" goqu:\"omitnil\"`\n\t\tAddress2  *string `db:\"address2\" goqu:\"omitnil\"`\n\t\tAddress3  *string `db:\"address3\" goqu:\"omitnil\"`\n\t}\n\taddress1 := \"113 Test Addr\"\n\tvar emptyString string\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{\n\t\t\tFirstName: \"Test First Name\",\n\t\t\tLastName:  \"\",\n\t\t\tAddress1:  &address1,\n\t\t\tAddress2:  &emptyString,\n\t\t\tAddress3:  nil, // will omit nil pointer\n\t\t},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address1\"='113 Test Addr',\"address2\"='',\"first_name\"='Test First Name',\"last_name\"='' []\n}\n\nfunc ExampleUpdate_withOmitEmptyTag() {\n\ttype item struct {\n\t\tFirstName string  `db:\"first_name\" goqu:\"omitempty\"`\n\t\tLastName  string  `db:\"last_name\" goqu:\"omitempty\"`\n\t\tAddress1  *string `db:\"address1\" goqu:\"omitempty\"`\n\t\tAddress2  *string `db:\"address2\" goqu:\"omitempty\"`\n\t\tAddress3  *string `db:\"address3\" goqu:\"omitempty\"`\n\t}\n\taddress1 := \"114 Test Addr\"\n\tvar emptyString string\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{\n\t\t\tFirstName: \"Test First Name\",\n\t\t\tLastName:  \"\", // will omit zero field\n\t\t\tAddress1:  &address1,\n\t\t\tAddress2:  &emptyString,\n\t\t\tAddress3:  nil, // will omit nil pointer\n\t\t},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address1\"='114 Test Addr',\"address2\"='',\"first_name\"='Test First Name' []\n}\n\nfunc ExampleUpdate_withOmitEmptyTag_valuer() {\n\ttype item struct {\n\t\tFirstName  dbsql.NullString  `db:\"first_name\" goqu:\"omitempty\"`\n\t\tMiddleName dbsql.NullString  `db:\"middle_name\" goqu:\"omitempty\"`\n\t\tLastName   dbsql.NullString  `db:\"last_name\" goqu:\"omitempty\"`\n\t\tAddress1   *dbsql.NullString `db:\"address1\" goqu:\"omitempty\"`\n\t\tAddress2   *dbsql.NullString `db:\"address2\" goqu:\"omitempty\"`\n\t\tAddress3   *dbsql.NullString `db:\"address3\" goqu:\"omitempty\"`\n\t\tAddress4   *dbsql.NullString `db:\"address4\" goqu:\"omitempty\"`\n\t}\n\tquery, args, _ := goqu.Update(\"items\").Set(\n\t\titem{\n\t\t\tFirstName:  dbsql.NullString{Valid: true, String: \"Test First Name\"},\n\t\t\tMiddleName: dbsql.NullString{Valid: true, String: \"\"},\n\t\t\tLastName:   dbsql.NullString{}, // will omit zero valuer struct\n\t\t\tAddress1:   &dbsql.NullString{Valid: true, String: \"Test Address 1\"},\n\t\t\tAddress2:   &dbsql.NullString{Valid: true, String: \"\"},\n\t\t\tAddress3:   &dbsql.NullString{},\n\t\t\tAddress4:   nil, // will omit nil pointer\n\t\t},\n\t).ToSQL()\n\tfmt.Println(query, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address1\"='Test Address 1',\"address2\"='',\"address3\"=NULL,\"first_name\"='Test First Name',\"middle_name\"='' []\n}\n\nfunc ExampleUpdate_withGoquRecord() {\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdate_withMap() {\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\tmap[string]interface{}{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdate_withExpressions() {\n\tsql, args, _ := goqu.Update(\"items\").Set([]exp.UpdateExpression{\n\t\tgoqu.C(\"name\").Set(\"Test\"),\n\t\tgoqu.C(\"address\").Set(\"111 Test Addr\"),\n\t}).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"name\"='Test',\"address\"='111 Test Addr' []\n}\n\nfunc ExampleUpdate_withSkipUpdateTag() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\" goqu:\"skipupdate\"`\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr' []\n}\n\nfunc ExampleUpdateDataset_Executor() {\n\tdb := getDB()\n\tupdate := db.Update(\"goqu_user\").\n\t\tWhere(goqu.C(\"first_name\").Eq(\"Bob\")).\n\t\tSet(goqu.Record{\"first_name\": \"Bobby\"}).\n\t\tExecutor()\n\n\tif r, err := update.Exec(); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tc, _ := r.RowsAffected()\n\t\tfmt.Printf(\"Updated %d users\", c)\n\t}\n\n\t// Output:\n\t// Updated 1 users\n}\n\nfunc ExampleUpdateDataset_Executor_returning() {\n\tdb := getDB()\n\tvar ids []int64\n\tupdate := db.Update(\"goqu_user\").\n\t\tSet(goqu.Record{\"last_name\": \"ucon\"}).\n\t\tWhere(goqu.Ex{\"last_name\": \"Yukon\"}).\n\t\tReturning(\"id\").\n\t\tExecutor()\n\tif err := update.ScanVals(&ids); err != nil {\n\t\tfmt.Println(err.Error())\n\t} else {\n\t\tfmt.Printf(\"Updated users with ids %+v\", ids)\n\t}\n\n\t// Output:\n\t// Updated users with ids [1 2 3]\n}\n\nfunc ExampleUpdateDataset_Returning() {\n\tsql, _, _ := goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tReturning(\"id\").\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tReturning(goqu.T(\"test\").All()).\n\t\tToSQL()\n\tfmt.Println(sql)\n\tsql, _, _ = goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tReturning(\"a\", \"b\").\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"test\" SET \"foo\"='bar' RETURNING \"id\"\n\t// UPDATE \"test\" SET \"foo\"='bar' RETURNING \"test\".*\n\t// UPDATE \"test\" SET \"foo\"='bar' RETURNING \"a\", \"b\"\n}\n\nfunc ExampleUpdateDataset_With() {\n\tsql, _, _ := goqu.Update(\"test\").\n\t\tWith(\"some_vals(val)\", goqu.From().Select(goqu.L(\"123\"))).\n\t\tWhere(goqu.C(\"val\").Eq(goqu.From(\"some_vals\").Select(\"val\"))).\n\t\tSet(goqu.Record{\"name\": \"Test\"}).ToSQL()\n\tfmt.Println(sql)\n\n\t// Output:\n\t// WITH some_vals(val) AS (SELECT 123) UPDATE \"test\" SET \"name\"='Test' WHERE (\"val\" IN (SELECT \"val\" FROM \"some_vals\"))\n}\n\nfunc ExampleUpdateDataset_WithRecursive() {\n\tsql, _, _ := goqu.Update(\"nums\").\n\t\tWithRecursive(\"nums(x)\", goqu.From().Select(goqu.L(\"1\").As(\"num\")).\n\t\t\tUnionAll(goqu.From(\"nums\").\n\t\t\t\tSelect(goqu.L(\"x+1\").As(\"num\")).Where(goqu.C(\"x\").Lt(5)))).\n\t\tSet(goqu.Record{\"foo\": goqu.T(\"nums\").Col(\"num\")}).\n\t\tToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// WITH RECURSIVE nums(x) AS (SELECT 1 AS \"num\" UNION ALL (SELECT x+1 AS \"num\" FROM \"nums\" WHERE (\"x\" < 5))) UPDATE \"nums\" SET \"foo\"=\"nums\".\"num\"\n}\n\nfunc ExampleUpdateDataset_Limit() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tLimit(10)\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar' LIMIT 10\n}\n\nfunc ExampleUpdateDataset_LimitAll() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tLimitAll()\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar' LIMIT ALL\n}\n\nfunc ExampleUpdateDataset_ClearLimit() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tLimit(10)\n\tsql, _, _ := ds.ClearLimit().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar'\n}\n\nfunc ExampleUpdateDataset_Order() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tOrder(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar' ORDER BY `a` ASC\n}\n\nfunc ExampleUpdateDataset_OrderAppend() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tOrder(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.OrderAppend(goqu.C(\"b\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar' ORDER BY `a` ASC, `b` DESC NULLS LAST\n}\n\nfunc ExampleUpdateDataset_OrderPrepend() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tOrder(goqu.C(\"a\").Asc())\n\n\tsql, _, _ := ds.OrderPrepend(goqu.C(\"b\").Desc().NullsLast()).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar' ORDER BY `b` DESC NULLS LAST, `a` ASC\n}\n\nfunc ExampleUpdateDataset_ClearOrder() {\n\tds := goqu.Dialect(\"mysql\").\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tOrder(goqu.C(\"a\").Asc())\n\tsql, _, _ := ds.ClearOrder().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `test` SET `foo`='bar'\n}\n\nfunc ExampleUpdateDataset_From() {\n\tds := goqu.Update(\"table_one\").\n\t\tSet(goqu.Record{\"foo\": goqu.I(\"table_two.bar\")}).\n\t\tFrom(\"table_two\").\n\t\tWhere(goqu.Ex{\"table_one.id\": goqu.I(\"table_two.id\")})\n\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"table_one\" SET \"foo\"=\"table_two\".\"bar\" FROM \"table_two\" WHERE (\"table_one\".\"id\" = \"table_two\".\"id\")\n}\n\nfunc ExampleUpdateDataset_From_postgres() {\n\tdialect := goqu.Dialect(\"postgres\")\n\n\tds := dialect.Update(\"table_one\").\n\t\tSet(goqu.Record{\"foo\": goqu.I(\"table_two.bar\")}).\n\t\tFrom(\"table_two\").\n\t\tWhere(goqu.Ex{\"table_one.id\": goqu.I(\"table_two.id\")})\n\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"table_one\" SET \"foo\"=\"table_two\".\"bar\" FROM \"table_two\" WHERE (\"table_one\".\"id\" = \"table_two\".\"id\")\n}\n\nfunc ExampleUpdateDataset_From_mysql() {\n\tdialect := goqu.Dialect(\"mysql\")\n\n\tds := dialect.Update(\"table_one\").\n\t\tSet(goqu.Record{\"foo\": goqu.I(\"table_two.bar\")}).\n\t\tFrom(\"table_two\").\n\t\tWhere(goqu.Ex{\"table_one.id\": goqu.I(\"table_two.id\")})\n\n\tsql, _, _ := ds.ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE `table_one`,`table_two` SET `foo`=`table_two`.`bar` WHERE (`table_one`.`id` = `table_two`.`id`)\n}\n\nfunc ExampleUpdateDataset_Where() {\n\t// By default everything is anded together\n\tsql, _, _ := goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(goqu.Ex{\n\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t\"c\": nil,\n\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t}).ToSQL()\n\tfmt.Println(sql)\n\t// You can use ExOr to get ORed expressions together\n\tsql, _, _ = goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(goqu.ExOr{\n\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t\"c\": nil,\n\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t}).ToSQL()\n\tfmt.Println(sql)\n\t// You can use Or with Ex to Or multiple Ex maps together\n\tsql, _, _ = goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.Or(\n\t\t\t\tgoqu.Ex{\n\t\t\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t\t},\n\t\t\t\tgoqu.Ex{\n\t\t\t\t\t\"c\": nil,\n\t\t\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t\t\t},\n\t\t\t),\n\t\t).ToSQL()\n\tfmt.Println(sql)\n\t// By default everything is anded together\n\tsql, _, _ = goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\tgoqu.C(\"d\").In(\"a\", \"b\", \"c\"),\n\t\t).ToSQL()\n\tfmt.Println(sql)\n\t// You can use a combination of Ors and Ands\n\tsql, _, _ = goqu.Update(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.Or(\n\t\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\t\tgoqu.And(\n\t\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t\t),\n\t\t\t),\n\t\t).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"test\" SET \"foo\"='bar' WHERE ((\"a\" > 10) AND (\"b\" < 10) AND (\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c')))\n\t// UPDATE \"test\" SET \"foo\"='bar' WHERE ((\"a\" > 10) OR (\"b\" < 10) OR (\"c\" IS NULL) OR (\"d\" IN ('a', 'b', 'c')))\n\t// UPDATE \"test\" SET \"foo\"='bar' WHERE (((\"a\" > 10) AND (\"b\" < 10)) OR ((\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c'))))\n\t// UPDATE \"test\" SET \"foo\"='bar' WHERE ((\"a\" > 10) AND (\"b\" < 10) AND (\"c\" IS NULL) AND (\"d\" IN ('a', 'b', 'c')))\n\t// UPDATE \"test\" SET \"foo\"='bar' WHERE ((\"a\" > 10) OR ((\"b\" < 10) AND (\"c\" IS NULL)))\n}\n\nfunc ExampleUpdateDataset_Where_prepared() {\n\t// By default everything is anded together\n\tsql, args, _ := goqu.Update(\"test\").\n\t\tPrepared(true).\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(goqu.Ex{\n\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t\"c\": nil,\n\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use ExOr to get ORed expressions together\n\tsql, args, _ = goqu.Update(\"test\").Prepared(true).\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(goqu.ExOr{\n\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t\"c\": nil,\n\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t}).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use Or with Ex to Or multiple Ex maps together\n\tsql, args, _ = goqu.Update(\"test\").Prepared(true).\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.Or(\n\t\t\t\tgoqu.Ex{\n\t\t\t\t\t\"a\": goqu.Op{\"gt\": 10},\n\t\t\t\t\t\"b\": goqu.Op{\"lt\": 10},\n\t\t\t\t},\n\t\t\t\tgoqu.Ex{\n\t\t\t\t\t\"c\": nil,\n\t\t\t\t\t\"d\": []string{\"a\", \"b\", \"c\"},\n\t\t\t\t},\n\t\t\t),\n\t\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// By default everything is anded together\n\tsql, args, _ = goqu.Update(\"test\").Prepared(true).\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\tgoqu.C(\"d\").In(\"a\", \"b\", \"c\"),\n\t\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// You can use a combination of Ors and Ands\n\tsql, args, _ = goqu.Update(\"test\").Prepared(true).\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.Or(\n\t\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\t\tgoqu.And(\n\t\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t\t),\n\t\t\t),\n\t\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// UPDATE \"test\" SET \"foo\"=? WHERE ((\"a\" > ?) AND (\"b\" < ?) AND (\"c\" IS NULL) AND (\"d\" IN (?, ?, ?))) [bar 10 10 a b c]\n\t// UPDATE \"test\" SET \"foo\"=? WHERE ((\"a\" > ?) OR (\"b\" < ?) OR (\"c\" IS NULL) OR (\"d\" IN (?, ?, ?))) [bar 10 10 a b c]\n\t// UPDATE \"test\" SET \"foo\"=? WHERE (((\"a\" > ?) AND (\"b\" < ?)) OR ((\"c\" IS NULL) AND (\"d\" IN (?, ?, ?)))) [bar 10 10 a b c]\n\t// UPDATE \"test\" SET \"foo\"=? WHERE ((\"a\" > ?) AND (\"b\" < ?) AND (\"c\" IS NULL) AND (\"d\" IN (?, ?, ?))) [bar 10 10 a b c]\n\t// UPDATE \"test\" SET \"foo\"=? WHERE ((\"a\" > ?) OR ((\"b\" < ?) AND (\"c\" IS NULL))) [bar 10 10]\n}\n\nfunc ExampleUpdateDataset_ClearWhere() {\n\tds := goqu.\n\t\tUpdate(\"test\").\n\t\tSet(goqu.Record{\"foo\": \"bar\"}).\n\t\tWhere(\n\t\t\tgoqu.Or(\n\t\t\t\tgoqu.C(\"a\").Gt(10),\n\t\t\t\tgoqu.And(\n\t\t\t\t\tgoqu.C(\"b\").Lt(10),\n\t\t\t\t\tgoqu.C(\"c\").IsNull(),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\tsql, _, _ := ds.ClearWhere().ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"test\" SET \"foo\"='bar'\n}\n\nfunc ExampleUpdateDataset_Table() {\n\tds := goqu.Update(\"test\")\n\tsql, _, _ := ds.Table(\"test2\").Set(goqu.Record{\"foo\": \"bar\"}).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"test2\" SET \"foo\"='bar'\n}\n\nfunc ExampleUpdateDataset_Table_aliased() {\n\tds := goqu.Update(\"test\")\n\tsql, _, _ := ds.Table(goqu.T(\"test\").As(\"t\")).Set(goqu.Record{\"foo\": \"bar\"}).ToSQL()\n\tfmt.Println(sql)\n\t// Output:\n\t// UPDATE \"test\" AS \"t\" SET \"foo\"='bar'\n}\n\nfunc ExampleUpdateDataset_Set() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.Update(\"items\").Set(\n\t\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.Update(\"items\").Set(\n\t\tmap[string]interface{}{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdateDataset_Set_struct() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdateDataset_Set_goquRecord() {\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdateDataset_Set_map() {\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\tmap[string]interface{}{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdateDataset_Set_withSkipUpdateTag() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\" goqu:\"skipupdate\"`\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr' []\n}\n\nfunc ExampleUpdateDataset_Set_withDefaultIfEmptyTag() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\" goqu:\"defaultifempty\"`\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.Update(\"items\").Set(\n\t\titem{Name: \"Bob Yukon\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"=DEFAULT []\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Bob Yukon' []\n}\n\nfunc ExampleUpdateDataset_Set_withNoTags() {\n\ttype item struct {\n\t\tAddress string\n\t\tName    string\n\t}\n\tsql, args, _ := goqu.Update(\"items\").Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test' []\n}\n\nfunc ExampleUpdateDataset_Set_withEmbeddedStruct() {\n\ttype Address struct {\n\t\tStreet string `db:\"address_street\"`\n\t\tState  string `db:\"address_state\"`\n\t}\n\ttype User struct {\n\t\tAddress\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\tds := goqu.Update(\"user\").Set(\n\t\tUser{Address: Address{Street: \"111 Street\", State: \"NY\"}, FirstName: \"Greg\", LastName: \"Farley\"},\n\t)\n\tupdateSQL, args, _ := ds.ToSQL()\n\tfmt.Println(updateSQL, args)\n\n\t// Output:\n\t// UPDATE \"user\" SET \"address_state\"='NY',\"address_street\"='111 Street',\"firstname\"='Greg',\"lastname\"='Farley' []\n}\n\nfunc ExampleUpdateDataset_Set_withIgnoredEmbedded() {\n\ttype Address struct {\n\t\tStreet string\n\t\tState  string\n\t}\n\ttype User struct {\n\t\tAddress   `db:\"-\"`\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\tds := goqu.Update(\"user\").Set(\n\t\tUser{Address: Address{Street: \"111 Street\", State: \"NY\"}, FirstName: \"Greg\", LastName: \"Farley\"},\n\t)\n\tupdateSQL, args, _ := ds.ToSQL()\n\tfmt.Println(updateSQL, args)\n\n\t// Output:\n\t// UPDATE \"user\" SET \"firstname\"='Greg',\"lastname\"='Farley' []\n}\n\nfunc ExampleUpdateDataset_Set_withNilEmbeddedPointer() {\n\ttype Address struct {\n\t\tStreet string\n\t\tState  string\n\t}\n\ttype User struct {\n\t\t*Address\n\t\tFirstName string\n\t\tLastName  string\n\t}\n\tds := goqu.Update(\"user\").Set(\n\t\tUser{FirstName: \"Greg\", LastName: \"Farley\"},\n\t)\n\tupdateSQL, args, _ := ds.ToSQL()\n\tfmt.Println(updateSQL, args)\n\n\t// Output:\n\t// UPDATE \"user\" SET \"firstname\"='Greg',\"lastname\"='Farley' []\n}\n\nfunc ExampleUpdateDataset_ToSQL_prepared() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\n\tsql, args, _ := goqu.From(\"items\").Prepared(true).Update().Set(\n\t\titem{Name: \"Test\", Address: \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Prepared(true).Update().Set(\n\t\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\tsql, args, _ = goqu.From(\"items\").Prepared(true).Update().Set(\n\t\tmap[string]interface{}{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"=?,\"name\"=? [111 Test Addr Test]\n\t// UPDATE \"items\" SET \"address\"=?,\"name\"=? [111 Test Addr Test]\n\t// UPDATE \"items\" SET \"address\"=?,\"name\"=? [111 Test Addr Test]\n}\n\nfunc ExampleUpdateDataset_Prepared() {\n\tsql, args, _ := goqu.Update(\"items\").Prepared(true).Set(\n\t\tgoqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"},\n\t).ToSQL()\n\tfmt.Println(sql, args)\n\n\t// Output:\n\t// UPDATE \"items\" SET \"address\"=?,\"name\"=? [111 Test Addr Test]\n}\n"
        },
        {
          "name": "update_dataset_test.go",
          "type": "blob",
          "size": 13.4404296875,
          "content": "package goqu_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/DATA-DOG/go-sqlmock\"\n\t\"github.com/doug-martin/goqu/v9\"\n\t\"github.com/doug-martin/goqu/v9/exp\"\n\t\"github.com/doug-martin/goqu/v9/internal/errors\"\n\t\"github.com/doug-martin/goqu/v9/internal/sb\"\n\t\"github.com/doug-martin/goqu/v9/mocks\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype (\n\tupdateTestCase struct {\n\t\tds      *goqu.UpdateDataset\n\t\tclauses exp.UpdateClauses\n\t}\n\tupdateDatasetSuite struct {\n\t\tsuite.Suite\n\t}\n)\n\nfunc (uds *updateDatasetSuite) assertCases(cases ...updateTestCase) {\n\tfor _, s := range cases {\n\t\tuds.Equal(s.clauses, s.ds.GetClauses())\n\t}\n}\n\nfunc (uds *updateDatasetSuite) TestUpdate() {\n\tds := goqu.Update(\"test\")\n\tuds.IsType(&goqu.UpdateDataset{}, ds)\n\tuds.Implements((*exp.Expression)(nil), ds)\n\tuds.Implements((*exp.AppendableExpression)(nil), ds)\n}\n\nfunc (uds *updateDatasetSuite) TestClone() {\n\tds := goqu.Update(\"test\")\n\tuds.Equal(ds, ds.Clone())\n}\n\nfunc (uds *updateDatasetSuite) TestExpression() {\n\tds := goqu.Update(\"test\")\n\tuds.Equal(ds, ds.Expression())\n}\n\nfunc (uds *updateDatasetSuite) TestDialect() {\n\tds := goqu.Update(\"test\")\n\tuds.NotNil(ds.Dialect())\n}\n\nfunc (uds *updateDatasetSuite) TestWithDialect() {\n\tds := goqu.Update(\"test\")\n\tmd := new(mocks.SQLDialect)\n\tds = ds.SetDialect(md)\n\n\tdialect := goqu.GetDialect(\"default\")\n\tdialectDs := ds.WithDialect(\"default\")\n\tuds.Equal(md, ds.Dialect())\n\tuds.Equal(dialect, dialectDs.Dialect())\n}\n\nfunc (uds *updateDatasetSuite) TestPrepared() {\n\tds := goqu.Update(\"test\")\n\tpreparedDs := ds.Prepared(true)\n\tuds.True(preparedDs.IsPrepared())\n\tuds.False(ds.IsPrepared())\n\t// should apply the prepared to any datasets created from the root\n\tuds.True(preparedDs.Where(goqu.Ex{\"a\": 1}).IsPrepared())\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\t// should be prepared by default\n\tds = goqu.Update(\"test\")\n\tuds.True(ds.IsPrepared())\n}\n\nfunc (uds *updateDatasetSuite) TestGetClauses() {\n\tds := goqu.Update(\"test\")\n\tce := exp.NewUpdateClauses().SetTable(goqu.I(\"test\"))\n\tuds.Equal(ce, ds.GetClauses())\n}\n\nfunc (uds *updateDatasetSuite) TestWith() {\n\tfrom := goqu.Update(\"cte\")\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.With(\"test-cte\", from),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(false, \"test-cte\", from)),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestWithRecursive() {\n\tfrom := goqu.Update(\"cte\")\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.WithRecursive(\"test-cte\", from),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tCommonTablesAppend(exp.NewCommonTableExpression(true, \"test-cte\", from)),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestTable() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds:      bd.Table(\"items2\"),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items2\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd.Table(goqu.L(\"literal_table\")),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.L(\"literal_table\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n\tuds.PanicsWithValue(goqu.ErrUnsupportedUpdateTableType, func() {\n\t\tbd.Table(true)\n\t})\n}\n\nfunc (uds *updateDatasetSuite) TestSet() {\n\ttype item struct {\n\t\tAddress string `db:\"address\"`\n\t\tName    string `db:\"name\"`\n\t}\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.Set(item{Name: \"Test\", Address: \"111 Test Addr\"}),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetSetValues(item{Name: \"Test\", Address: \"111 Test Addr\"}),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Set(goqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"}),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetSetValues(goqu.Record{\"name\": \"Test\", \"address\": \"111 Test Addr\"}),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Set([]exp.UpdateExpression{\n\t\t\t\tgoqu.C(\"name\").Set(\"Test\"),\n\t\t\t\tgoqu.C(\"address\").Set(\"111 Test Addr\"),\n\t\t\t}),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetSetValues([]exp.UpdateExpression{\n\t\t\t\t\tgoqu.C(\"name\").Set(\"Test\"),\n\t\t\t\t\tgoqu.C(\"address\").Set(\"111 Test Addr\"),\n\t\t\t\t}),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestFrom() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.From(\"other\"),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"other\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.From(\"other\").From(\"other2\"),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetFrom(exp.NewColumnListExpression(\"other2\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestWhere() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.Where(goqu.Ex{\"a\": 1}),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tWhereAppend(goqu.Ex{\"a\": 1}),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Where(goqu.Ex{\"a\": 1}).Where(goqu.C(\"b\").Eq(\"c\")),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tWhereAppend(goqu.Ex{\"a\": 1}).WhereAppend(goqu.C(\"b\").Eq(\"c\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestClearWhere() {\n\tbd := goqu.Update(\"items\").Where(goqu.Ex{\"a\": 1})\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds:      bd.ClearWhere(),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tWhereAppend(goqu.Ex{\"a\": 1}),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestOrder() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Desc()),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).OrderAppend(goqu.C(\"a\").Desc()),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Order(goqu.C(\"a\").Desc()).Order(goqu.C(\"b\").Asc()),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tOrderAppend(goqu.C(\"b\").Asc()),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestOrderAppend() {\n\tbd := goqu.Update(\"items\").Order(goqu.C(\"a\").Desc())\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.OrderAppend(goqu.C(\"b\").Asc()),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tOrderAppend(goqu.C(\"a\").Desc()).\n\t\t\t\tOrderAppend(goqu.C(\"b\").Asc()),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tOrderAppend(goqu.C(\"a\").Desc()),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestOrderPrepend() {\n\tbd := goqu.Update(\"items\").Order(goqu.C(\"a\").Desc())\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.OrderPrepend(goqu.C(\"b\").Asc()),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tOrderAppend(goqu.C(\"b\").Asc()).\n\t\t\t\tOrderAppend(goqu.C(\"a\").Desc()),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tOrderAppend(goqu.C(\"a\").Desc()),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestClearOrder() {\n\tbd := goqu.Update(\"items\").Order(goqu.C(\"a\").Desc())\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds:      bd.ClearOrder(),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd,\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tOrderAppend(goqu.C(\"a\").Desc()),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestLimit() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds:      bd.Limit(10),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")).SetLimit(uint(10)),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd.Limit(0),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestLimitAll() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds:      bd.LimitAll(),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")).SetLimit(goqu.L(\"ALL\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestClearLimit() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds:      bd.LimitAll().ClearLimit(),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd.Limit(10).ClearLimit(),\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestReturning() {\n\tbd := goqu.Update(\"items\")\n\tuds.assertCases(\n\t\tupdateTestCase{\n\t\t\tds: bd.Returning(\"a\", \"b\"),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression(\"a\", \"b\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Returning(),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Returning(nil),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression()),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds: bd.Returning(\"a\", \"b\").Returning(\"c\"),\n\t\t\tclauses: exp.NewUpdateClauses().\n\t\t\t\tSetTable(goqu.C(\"items\")).\n\t\t\t\tSetReturning(exp.NewColumnListExpression(\"c\")),\n\t\t},\n\t\tupdateTestCase{\n\t\t\tds:      bd,\n\t\t\tclauses: exp.NewUpdateClauses().SetTable(goqu.C(\"items\")),\n\t\t},\n\t)\n}\n\nfunc (uds *updateDatasetSuite) TestReturnsColumns() {\n\tds := goqu.Update(\"test\")\n\tuds.False(ds.ReturnsColumns())\n\tuds.True(ds.Returning(\"foo\", \"bar\").ReturnsColumns())\n}\n\nfunc (uds *updateDatasetSuite) TestToSQL() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Update(\"test\").SetDialect(md)\n\tr := goqu.Record{\"c\": \"a\"}\n\tc := ds.GetClauses().SetSetValues(r)\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToUpdateSQL\", sqlB, c).Return(nil).Once()\n\tupdateSQL, args, err := ds.Set(r).ToSQL()\n\tuds.Empty(updateSQL)\n\tuds.Empty(args)\n\tuds.Nil(err)\n\tmd.AssertExpectations(uds.T())\n}\n\nfunc (uds *updateDatasetSuite) TestToSQL_Prepared() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Update(\"test\").Prepared(true).SetDialect(md)\n\tr := goqu.Record{\"c\": \"a\"}\n\tc := ds.GetClauses().SetSetValues(r)\n\tsqlB := sb.NewSQLBuilder(true)\n\tmd.On(\"ToUpdateSQL\", sqlB, c).Return(nil).Once()\n\tupdateSQL, args, err := ds.Set(goqu.Record{\"c\": \"a\"}).ToSQL()\n\tuds.Empty(updateSQL)\n\tuds.Empty(args)\n\tuds.Nil(err)\n\tmd.AssertExpectations(uds.T())\n}\n\nfunc (uds *updateDatasetSuite) TestToSQL_WithError() {\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Update(\"test\").SetDialect(md)\n\tr := goqu.Record{\"c\": \"a\"}\n\tc := ds.GetClauses().SetSetValues(r)\n\tsqlB := sb.NewSQLBuilder(false)\n\tee := errors.New(\"expected error\")\n\tmd.On(\"ToUpdateSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(ee)\n\t}).Once()\n\n\tupdateSQL, args, err := ds.Set(goqu.Record{\"c\": \"a\"}).ToSQL()\n\tuds.Empty(updateSQL)\n\tuds.Empty(args)\n\tuds.Equal(ee, err)\n\tmd.AssertExpectations(uds.T())\n}\n\nfunc (uds *updateDatasetSuite) TestExecutor() {\n\tmDB, _, err := sqlmock.New()\n\tuds.NoError(err)\n\tds := goqu.New(\"mock\", mDB).\n\t\tUpdate(\"items\").\n\t\tSet(goqu.Record{\"address\": \"111 Test Addr\", \"name\": \"Test1\"}).\n\t\tWhere(goqu.C(\"name\").IsNull())\n\n\tupdateSQL, args, err := ds.Executor().ToSQL()\n\tuds.NoError(err)\n\tuds.Empty(args)\n\tuds.Equal(`UPDATE \"items\" SET \"address\"='111 Test Addr',\"name\"='Test1' WHERE (\"name\" IS NULL)`, updateSQL)\n\n\tupdateSQL, args, err = ds.Prepared(true).Executor().ToSQL()\n\tuds.NoError(err)\n\tuds.Equal([]interface{}{\"111 Test Addr\", \"Test1\"}, args)\n\tuds.Equal(`UPDATE \"items\" SET \"address\"=?,\"name\"=? WHERE (\"name\" IS NULL)`, updateSQL)\n\n\tdefer goqu.SetDefaultPrepared(false)\n\tgoqu.SetDefaultPrepared(true)\n\n\tupdateSQL, args, err = ds.Executor().ToSQL()\n\tuds.NoError(err)\n\tuds.Equal([]interface{}{\"111 Test Addr\", \"Test1\"}, args)\n\tuds.Equal(`UPDATE \"items\" SET \"address\"=?,\"name\"=? WHERE (\"name\" IS NULL)`, updateSQL)\n}\n\nfunc (uds *updateDatasetSuite) TestSetError() {\n\terr1 := errors.New(\"error #1\")\n\terr2 := errors.New(\"error #2\")\n\terr3 := errors.New(\"error #3\")\n\n\t// Verify initial error set/get works properly\n\tmd := new(mocks.SQLDialect)\n\tds := goqu.Update(\"test\").SetDialect(md)\n\tds = ds.SetError(err1)\n\tuds.Equal(err1, ds.Error())\n\tsql, args, err := ds.ToSQL()\n\tuds.Empty(sql)\n\tuds.Empty(args)\n\tuds.Equal(err1, err)\n\n\t// Repeated SetError calls on Dataset should not overwrite the original error\n\tds = ds.SetError(err2)\n\tuds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tuds.Empty(sql)\n\tuds.Empty(args)\n\tuds.Equal(err1, err)\n\n\t// Builder functions should not lose the error\n\tds = ds.ClearLimit()\n\tuds.Equal(err1, ds.Error())\n\tsql, args, err = ds.ToSQL()\n\tuds.Empty(sql)\n\tuds.Empty(args)\n\tuds.Equal(err1, err)\n\n\t// Deeper errors inside SQL generation should still return original error\n\tc := ds.GetClauses()\n\tsqlB := sb.NewSQLBuilder(false)\n\tmd.On(\"ToUpdateSQL\", sqlB, c).Run(func(args mock.Arguments) {\n\t\targs.Get(0).(sb.SQLBuilder).SetError(err3)\n\t}).Once()\n\n\tsql, args, err = ds.ToSQL()\n\tuds.Empty(sql)\n\tuds.Empty(args)\n\tuds.Equal(err1, err)\n}\n\nfunc TestUpdateDataset(t *testing.T) {\n\tsuite.Run(t, new(updateDatasetSuite))\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "wait-for-it.sh",
          "type": "blob",
          "size": 5.1005859375,
          "content": "#!/usr/bin/env bash\n# Use this script to test if a given TCP host/port are available\n\nWAITFORIT_cmdname=${0##*/}\n\nechoerr() { if [[ $WAITFORIT_QUIET -ne 1 ]]; then echo \"$@\" 1>&2; fi }\n\nusage()\n{\n    cat << USAGE >&2\nUsage:\n    $WAITFORIT_cmdname host:port [-s] [-t timeout] [-- command args]\n    -h HOST | --host=HOST       Host or IP under test\n    -p PORT | --port=PORT       TCP port under test\n                                Alternatively, you specify the host and port as host:port\n    -s | --strict               Only execute subcommand if the test succeeds\n    -q | --quiet                Don't output any status messages\n    -t TIMEOUT | --timeout=TIMEOUT\n                                Timeout in seconds, zero for no timeout\n    -- COMMAND ARGS             Execute command with args after the test finishes\nUSAGE\n    exit 1\n}\n\nwait_for()\n{\n    if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then\n        echoerr \"$WAITFORIT_cmdname: waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT\"\n    else\n        echoerr \"$WAITFORIT_cmdname: waiting for $WAITFORIT_HOST:$WAITFORIT_PORT without a timeout\"\n    fi\n    WAITFORIT_start_ts=$(date +%s)\n    while :\n    do\n        if [[ $WAITFORIT_ISBUSY -eq 1 ]]; then\n            nc -z $WAITFORIT_HOST $WAITFORIT_PORT\n            WAITFORIT_result=$?\n        else\n            (echo > /dev/tcp/$WAITFORIT_HOST/$WAITFORIT_PORT) >/dev/null 2>&1\n            WAITFORIT_result=$?\n        fi\n        if [[ $WAITFORIT_result -eq 0 ]]; then\n            WAITFORIT_end_ts=$(date +%s)\n            echoerr \"$WAITFORIT_cmdname: $WAITFORIT_HOST:$WAITFORIT_PORT is available after $((WAITFORIT_end_ts - WAITFORIT_start_ts)) seconds\"\n            break\n        fi\n        sleep 1\n    done\n    return $WAITFORIT_result\n}\n\nwait_for_wrapper()\n{\n    # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692\n    if [[ $WAITFORIT_QUIET -eq 1 ]]; then\n        timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --quiet --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &\n    else\n        timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &\n    fi\n    WAITFORIT_PID=$!\n    trap \"kill -INT -$WAITFORIT_PID\" INT\n    wait $WAITFORIT_PID\n    WAITFORIT_RESULT=$?\n    if [[ $WAITFORIT_RESULT -ne 0 ]]; then\n        echoerr \"$WAITFORIT_cmdname: timeout occurred after waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT\"\n    fi\n    return $WAITFORIT_RESULT\n}\n\n# process arguments\nwhile [[ $# -gt 0 ]]\ndo\n    case \"$1\" in\n        *:* )\n        WAITFORIT_hostport=(${1//:/ })\n        WAITFORIT_HOST=${WAITFORIT_hostport[0]}\n        WAITFORIT_PORT=${WAITFORIT_hostport[1]}\n        shift 1\n        ;;\n        --child)\n        WAITFORIT_CHILD=1\n        shift 1\n        ;;\n        -q | --quiet)\n        WAITFORIT_QUIET=1\n        shift 1\n        ;;\n        -s | --strict)\n        WAITFORIT_STRICT=1\n        shift 1\n        ;;\n        -h)\n        WAITFORIT_HOST=\"$2\"\n        if [[ $WAITFORIT_HOST == \"\" ]]; then break; fi\n        shift 2\n        ;;\n        --host=*)\n        WAITFORIT_HOST=\"${1#*=}\"\n        shift 1\n        ;;\n        -p)\n        WAITFORIT_PORT=\"$2\"\n        if [[ $WAITFORIT_PORT == \"\" ]]; then break; fi\n        shift 2\n        ;;\n        --port=*)\n        WAITFORIT_PORT=\"${1#*=}\"\n        shift 1\n        ;;\n        -t)\n        WAITFORIT_TIMEOUT=\"$2\"\n        if [[ $WAITFORIT_TIMEOUT == \"\" ]]; then break; fi\n        shift 2\n        ;;\n        --timeout=*)\n        WAITFORIT_TIMEOUT=\"${1#*=}\"\n        shift 1\n        ;;\n        --)\n        shift\n        WAITFORIT_CLI=(\"$@\")\n        break\n        ;;\n        --help)\n        usage\n        ;;\n        *)\n        echoerr \"Unknown argument: $1\"\n        usage\n        ;;\n    esac\ndone\n\nif [[ \"$WAITFORIT_HOST\" == \"\" || \"$WAITFORIT_PORT\" == \"\" ]]; then\n    echoerr \"Error: you need to provide a host and port to test.\"\n    usage\nfi\n\nWAITFORIT_TIMEOUT=${WAITFORIT_TIMEOUT:-15}\nWAITFORIT_STRICT=${WAITFORIT_STRICT:-0}\nWAITFORIT_CHILD=${WAITFORIT_CHILD:-0}\nWAITFORIT_QUIET=${WAITFORIT_QUIET:-0}\n\n# Check to see if timeout is from busybox?\nWAITFORIT_TIMEOUT_PATH=$(type -p timeout)\nWAITFORIT_TIMEOUT_PATH=$(realpath $WAITFORIT_TIMEOUT_PATH 2>/dev/null || readlink -f $WAITFORIT_TIMEOUT_PATH)\n\nWAITFORIT_BUSYTIMEFLAG=\"\"\nif [[ $WAITFORIT_TIMEOUT_PATH =~ \"busybox\" ]]; then\n    WAITFORIT_ISBUSY=1\n    # Check if busybox timeout uses -t flag\n    # (recent Alpine versions don't support -t anymore)\n    if timeout &>/dev/stdout | grep -q -e '-t '; then\n        WAITFORIT_BUSYTIMEFLAG=\"-t\"\n    fi\nelse\n    WAITFORIT_ISBUSY=0\nfi\n\nif [[ $WAITFORIT_CHILD -gt 0 ]]; then\n    wait_for\n    WAITFORIT_RESULT=$?\n    exit $WAITFORIT_RESULT\nelse\n    if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then\n        wait_for_wrapper\n        WAITFORIT_RESULT=$?\n    else\n        wait_for\n        WAITFORIT_RESULT=$?\n    fi\nfi\n\nif [[ $WAITFORIT_CLI != \"\" ]]; then\n    if [[ $WAITFORIT_RESULT -ne 0 && $WAITFORIT_STRICT -eq 1 ]]; then\n        echoerr \"$WAITFORIT_cmdname: strict mode, refusing to execute subprocess\"\n        exit $WAITFORIT_RESULT\n    fi\n    exec \"${WAITFORIT_CLI[@]}\"\nelse\n    exit $WAITFORIT_RESULT\nfi"
        }
      ]
    }
  ]
}