{
  "metadata": {
    "timestamp": 1736566923854,
    "page": 497,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "x-motemen/ghq",
      "stars": 3120,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "/ghq\n/ghq.exe\n/dist\n.vscode\n.idea\n"
        },
        {
          "name": ".tagpr",
          "type": "blob",
          "size": 1.779296875,
          "content": "# config file for the tagpr in git config format\n# The tagpr generates the initial configuration, which you can rewrite to suit your environment.\n# CONFIGURATIONS:\n#   tagpr.releaseBranch\n#       Generally, it is \"main.\" It is the branch for releases. The tagpr tracks this branch,\n#       creates or updates a pull request as a release candidate, or tags when they are merged.\n#\n#   tagpr.versionFile\n#       Versioning file containing the semantic version needed to be updated at release.\n#       It will be synchronized with the \"git tag\".\n#       Often this is a meta-information file such as gemspec, setup.cfg, package.json, etc.\n#       Sometimes the source code file, such as version.go or Bar.pm, is used.\n#       If you do not want to use versioning files but only git tags, specify the \"-\" string here.\n#       You can specify multiple version files by comma separated strings.\n#\n#   tagpr.vPrefix\n#       Flag whether or not v-prefix is added to semver when git tagging. (e.g. v1.2.3 if true)\n#       This is only a tagging convention, not how it is described in the version file.\n#\n#   tagpr.changelog (Optional)\n#       Flag whether or not changelog is added or changed during the release.\n#\n#   tagpr.command (Optional)\n#       Command to change files just before release.\n#\n#   tagpr.template (Optional)\n#       Pull request template in go template format\n#\n#   tagpr.release (Optional)\n#       GitHub Release creation behavior after tagging [true, draft, false]\n#       If this value is not set, the release is to be created.\n#\n#   tagpr.majorLabels (Optional)\n#       Label of major update targets. Default is [major]\n#\n#   tagpr.minorLabels (Optional)\n#       Label of minor update targets. Default is [minor]\n#\n[tagpr]\n\tvPrefix = true\n\treleaseBranch = master\n\tversionFile = main.go\n    release = draft\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 33.9296875,
          "content": "# Changelog\n\n## [v1.7.1](https://github.com/x-motemen/ghq/compare/v1.7.0...v1.7.1) - 2024-11-09\n- refine git vcs backend detection by @Songmu in https://github.com/x-motemen/ghq/pull/409\n\n## [v1.7.0](https://github.com/x-motemen/ghq/compare/v1.6.3...v1.7.0) - 2024-11-09\n- fix integration_test by @Songmu in https://github.com/x-motemen/ghq/pull/403\n- add ChiselRepository by @Songmu in https://github.com/x-motemen/ghq/pull/405\n- resolve fossil-scm.org and sqlite.org as fossil repository by @Songmu in https://github.com/x-motemen/ghq/pull/406\n- on workflow_dispatch in tagpr.yaml by @Songmu in https://github.com/x-motemen/ghq/pull/407\n- update deps by @Songmu in https://github.com/x-motemen/ghq/pull/408\n\n## [v1.6.3](https://github.com/x-motemen/ghq/compare/v1.6.2...v1.6.3) - 2024-10-27\n- Fix typo on README.adoc by @kromiii in https://github.com/x-motemen/ghq/pull/399\n- Add Windows Hardlink & Symbolic Link Support by @walnuts1018 in https://github.com/x-motemen/ghq/pull/401\n\n## [v1.6.2](https://github.com/x-motemen/ghq/compare/v1.6.1...v1.6.2) - 2024-07-12\n- chore: Update \"go build\" lines by @Okabe-Junya in https://github.com/x-motemen/ghq/pull/391\n- feat(misc): support \"ghq rm\" completion by @Okabe-Junya in https://github.com/x-motemen/ghq/pull/390\n- Optimize: Reduce full repo scans when look tag is set by @stong1994 in https://github.com/x-motemen/ghq/pull/386\n- Go 1.22.5 & update deps by @Songmu in https://github.com/x-motemen/ghq/pull/393\n\n## [v1.6.1](https://github.com/x-motemen/ghq/compare/v1.6.0...v1.6.1) - 2024-04-10\n- Revert \"feat: enable relative path ssh URL\" by @Songmu in https://github.com/x-motemen/ghq/pull/385\n\n## [v1.6.0](https://github.com/x-motemen/ghq/compare/v1.5.0...v1.6.0) - 2024-04-04\n- Feat: add alias for `ghq get` by @Okabe-Junya in https://github.com/x-motemen/ghq/pull/377\n- Append \".git\" to directory name for bare git repositories by @dochang in https://github.com/x-motemen/ghq/pull/368\n- feat(misc): add fish completion by @folliehiyuki in https://github.com/x-motemen/ghq/pull/375\n- Added mise-en-place installation and usage instructions. by @morihaya in https://github.com/x-motemen/ghq/pull/376\n- ghq rm to support bare option by @Songmu in https://github.com/x-motemen/ghq/pull/381\n- Go 1.22 and update deps by @Songmu in https://github.com/x-motemen/ghq/pull/382\n- feat: enable relative path ssh URL by @JyJyJcr in https://github.com/x-motemen/ghq/pull/378\n\n## [v1.5.0](https://github.com/x-motemen/ghq/compare/v1.4.2...v1.5.0) - 2024-02-02\n- Support pijul by @yoichi in https://github.com/x-motemen/ghq/pull/372\n- feat: implement `ghq rm` command by @Okabe-Junya in https://github.com/x-motemen/ghq/pull/371\n\n## [v1.4.2](https://github.com/x-motemen/ghq/compare/v1.4.1...v1.4.2) - 2023-04-16\n- release as draft by tagpr to hide it before uploading assets by @Songmu in https://github.com/x-motemen/ghq/pull/363\n- de-capitalize errors to make staticcheck happy by @hezhizhen in https://github.com/x-motemen/ghq/pull/365\n- adjustment by @hezhizhen in https://github.com/x-motemen/ghq/pull/366\n- introduce codecov by @Songmu in https://github.com/x-motemen/ghq/pull/359\n- update deps by @Songmu in https://github.com/x-motemen/ghq/pull/369\n\n## [v1.4.1](https://github.com/x-motemen/ghq/compare/v1.4.0...v1.4.1) - 2023-02-22\n- Add spell check workflow by @hezhizhen in https://github.com/x-motemen/ghq/pull/356\n- Fix `samePath` by @hezhizhen in https://github.com/x-motemen/ghq/pull/357\n- fix test on windows by @Songmu in https://github.com/x-motemen/ghq/pull/358\n- update deps by @Songmu in https://github.com/x-motemen/ghq/pull/360\n- Fixed a problem with SSH URLs, etc. by @Songmu in https://github.com/x-motemen/ghq/pull/361\n- go-version-file: go.mod by @Songmu in https://github.com/x-motemen/ghq/pull/362\n\n## [v1.4.0](https://github.com/x-motemen/ghq/compare/v1.3.0...v1.4.0) - 2023-02-22\n- Use t.Cleanup to remove temporally directories and set environment variables by @itchyny in https://github.com/x-motemen/ghq/pull/343\n- Support branch/tag via @ syntax by @NathanBaulch in https://github.com/x-motemen/ghq/pull/347\n- introduce tagpr by @Songmu in https://github.com/x-motemen/ghq/pull/353\n\n## [v1.3.0](https://github.com/x-motemen/ghq/compare/v1.2.1...v1.3.0) (2022-05-06)\n\n* update deps [#342](https://github.com/x-motemen/ghq/pull/342) ([Songmu](https://github.com/Songmu))\n* use go install instead of go get [#337](https://github.com/x-motemen/ghq/pull/337) ([shogo82148](https://github.com/shogo82148))\n* Simplify repository lock using sync.Map [#339](https://github.com/x-motemen/ghq/pull/339) ([itchyny](https://github.com/itchyny))\n* bump Go 1.18 [#338](https://github.com/x-motemen/ghq/pull/338) ([shogo82148](https://github.com/shogo82148))\n* bump the actions that run on Node.js 16 runtime [#336](https://github.com/x-motemen/ghq/pull/336) ([shogo82148](https://github.com/shogo82148))\n* fix: [trivial] fix the error message if nothing is passed to `ghq create` [#334](https://github.com/x-motemen/ghq/pull/334) ([gfx](https://github.com/gfx))\n* feat: do a bare clone [#328](https://github.com/x-motemen/ghq/pull/328) ([helmecke](https://github.com/helmecke))\n* update installation go [#327](https://github.com/x-motemen/ghq/pull/327) ([isanasan](https://github.com/isanasan))\n* avoid using \"Japanese Only\" [#325](https://github.com/x-motemen/ghq/pull/325) ([shogo82148](https://github.com/shogo82148))\n\n## [v1.2.1](https://github.com/x-motemen/ghq/compare/v1.2.0...v1.2.1) (2021-05-24)\n\n* ~/.gitconfig incompatible with AWS CodeCommit region specific URL [#322](https://github.com/x-motemen/ghq/pull/322) ([xeres](https://github.com/xeres))\n\n## [v1.2.0](https://github.com/x-motemen/ghq/compare/v1.1.7...v1.2.0) (2021-05-23)\n\n* Support AWS CodeCommit HTTP (GRC) [#321](https://github.com/x-motemen/ghq/pull/321) ([xeres](https://github.com/xeres))\n* Smartcasing [#317](https://github.com/x-motemen/ghq/pull/317) ([bmendric](https://github.com/bmendric))\n\n## [v1.1.7](https://github.com/x-motemen/ghq/compare/v1.1.6...v1.1.7) (2021-02-27)\n\n* sort list by default [#314](https://github.com/x-motemen/ghq/pull/314) ([Songmu](https://github.com/Songmu))\n\n## [v1.1.6](https://github.com/x-motemen/ghq/compare/v1.1.5...v1.1.6) (2021-02-25)\n\n* update deps [#313](https://github.com/x-motemen/ghq/pull/313) ([Songmu](https://github.com/Songmu))\n* Add installation instructions for GNU Guix [#310](https://github.com/x-motemen/ghq/pull/310) ([lafrenierejm](https://github.com/lafrenierejm))\n* bump saracen/walker v0.1.2 [#312](https://github.com/x-motemen/ghq/pull/312) ([shogo82148](https://github.com/shogo82148))\n* Add installation using asdf-vm [#305](https://github.com/x-motemen/ghq/pull/305) ([kajisha](https://github.com/kajisha))\n* Clone URLs by copying `net.URL` struct [#302](https://github.com/x-motemen/ghq/pull/302) ([vladimyr](https://github.com/vladimyr))\n* Fix typo in `get` command log output [#301](https://github.com/x-motemen/ghq/pull/301) ([vladimyr](https://github.com/vladimyr))\n* nit: Fix the pointer to example configuration [#298](https://github.com/x-motemen/ghq/pull/298) ([aereal](https://github.com/aereal))\n* Add scoop at installation [#297](https://github.com/x-motemen/ghq/pull/297) ([hotchpotch](https://github.com/hotchpotch))\n\n## [v1.1.5](https://github.com/x-motemen/ghq/compare/v1.1.4...v1.1.5) (2020-07-24)\n\n* update Songmu/gitconfig [#295](https://github.com/x-motemen/ghq/pull/295) ([Songmu](https://github.com/Songmu))\n* fix typo in readme [#293](https://github.com/x-motemen/ghq/pull/293) ([capytan](https://github.com/capytan))\n* Add conda install instructions [#292](https://github.com/x-motemen/ghq/pull/292) ([sodre](https://github.com/sodre))\n\n## [v1.1.4](https://github.com/x-motemen/ghq/compare/v1.1.3...v1.1.4) (2020-06-30)\n\n* Care the some repository URL ended with '.git/' [#291](https://github.com/x-motemen/ghq/pull/291) ([yoichi](https://github.com/yoichi))\n* Fix typo in `ghq get --help` [#290](https://github.com/x-motemen/ghq/pull/290) ([yoichi](https://github.com/yoichi))\n\n## [v1.1.3](https://github.com/x-motemen/ghq/compare/v1.1.2...v1.1.3) (2020-06-26)\n\n* Fix ghq root --all not showing all root directories [#289](https://github.com/x-motemen/ghq/pull/289) ([shihanng](https://github.com/shihanng))\n\n## [v1.1.2](https://github.com/x-motemen/ghq/compare/v1.1.1...v1.1.2) (2020-06-21)\n\n* update deps [#287](https://github.com/x-motemen/ghq/pull/287) ([Songmu](https://github.com/Songmu))\n* Fetch instead of pull if the working tree isn't tracking remote. [#286](https://github.com/x-motemen/ghq/pull/286) ([yoichi](https://github.com/yoichi))\n* Refactor so that RemoteRepository#VCS can return an error [#285](https://github.com/x-motemen/ghq/pull/285) ([johejo](https://github.com/johejo))\n\n## [v1.1.1](https://github.com/x-motemen/ghq/compare/v1.1.0...v1.1.1) (2020-06-03)\n\n* update deps [#284](https://github.com/x-motemen/ghq/pull/284) ([Songmu](https://github.com/Songmu))\n* fix integration testing [#283](https://github.com/x-motemen/ghq/pull/283) ([Songmu](https://github.com/Songmu))\n* Check vcsBackend is nil [#282](https://github.com/x-motemen/ghq/pull/282) ([mattn](https://github.com/mattn))\n* Add installation note for Void Linux [#280](https://github.com/x-motemen/ghq/pull/280) ([imbsky](https://github.com/imbsky))\n* Add bash completion to release archives [#279](https://github.com/x-motemen/ghq/pull/279) ([tottoto](https://github.com/tottoto))\n\n## [v1.1.0](https://github.com/x-motemen/ghq/compare/v1.0.3...v1.1.0) (2020-01-24)\n\n* update module name to github.com/x-motemen/ghq and fix import paths [#275](https://github.com/x-motemen/ghq/pull/275) ([Songmu](https://github.com/Songmu))\n\n## [v1.0.3](https://github.com/motemen/ghq/compare/v1.0.2...v1.0.3) (2020-01-22)\n\n* CGO_ENABLED=0 and drop -static flag [#273](https://github.com/motemen/ghq/pull/273) ([Songmu](https://github.com/Songmu))\n\n## [v1.0.2](https://github.com/motemen/ghq/compare/v1.0.1...v1.0.2) (2020-01-17)\n\n* static build [#271](https://github.com/motemen/ghq/pull/271) ([Songmu](https://github.com/Songmu))\n* Add options to zsh-completion [#270](https://github.com/motemen/ghq/pull/270) ([darklore](https://github.com/darklore))\n* update ghq.root description in README [#269](https://github.com/motemen/ghq/pull/269) ([ksoichiro](https://github.com/ksoichiro))\n* Enhance vcs_test.go [#266](https://github.com/motemen/ghq/pull/266) ([Songmu](https://github.com/Songmu))\n* fix testing for 'ghq get --look' [#265](https://github.com/motemen/ghq/pull/265) ([Songmu](https://github.com/Songmu))\n\n## [v1.0.1](https://github.com/motemen/ghq/compare/v1.0.0...v1.0.1) (2020-01-05)\n\n* Fix argument for look in get, to make `ghq get -look` work [#264](https://github.com/motemen/ghq/pull/264) ([astj](https://github.com/astj))\n\n## [v1.0.0](https://github.com/motemen/ghq/compare/v0.99.2...v1.0.0) (2020-01-05)\n\n* Release v1 [#262](https://github.com/motemen/ghq/pull/262) ([Songmu](https://github.com/Songmu))\n* enhance testing around \"ghq create\" [#261](https://github.com/motemen/ghq/pull/261) ([Songmu](https://github.com/Songmu))\n* start tests with empty gitconfig [#260](https://github.com/motemen/ghq/pull/260) ([Songmu](https://github.com/Songmu))\n\n## [v0.99.2](https://github.com/motemen/ghq/compare/v0.99.1...v0.99.2) (2020-01-04)\n\n* enhance logs on ghq get [#259](https://github.com/motemen/ghq/pull/259) ([Songmu](https://github.com/Songmu))\n* fix semaphore [#258](https://github.com/motemen/ghq/pull/258) ([Songmu](https://github.com/Songmu))\n\n## [v0.99.1](https://github.com/motemen/ghq/compare/v0.99.0...v0.99.1) (2020-01-02)\n\n* detect VCS backend from URL scheme [#257](https://github.com/motemen/ghq/pull/257) ([Songmu](https://github.com/Songmu))\n* print command execution output to stderr [#256](https://github.com/motemen/ghq/pull/256) ([Songmu](https://github.com/Songmu))\n\n## [v0.99.0](https://github.com/motemen/ghq/compare/v0.17.4...v0.99.0) (2019-12-31)\n\n* fix help docs [#255](https://github.com/motemen/ghq/pull/255) ([Songmu](https://github.com/Songmu))\n* update documents [#252](https://github.com/motemen/ghq/pull/252) ([Songmu](https://github.com/Songmu))\n* update deps [#251](https://github.com/motemen/ghq/pull/251) ([Songmu](https://github.com/Songmu))\n* [incompatible] remove the \"import\" subcommand and merge this function into the \"get\" subcommand [#244](https://github.com/motemen/ghq/pull/244) ([Songmu](https://github.com/Songmu))\n* [incompatible] drop look subcommand [#243](https://github.com/motemen/ghq/pull/243) ([Songmu](https://github.com/Songmu))\n* [incompatible] make ~/ghq default root [#237](https://github.com/motemen/ghq/pull/237) ([Songmu](https://github.com/Songmu))\n* add integration test for darcs [#250](https://github.com/motemen/ghq/pull/250) ([Songmu](https://github.com/Songmu))\n* integration test on master [#249](https://github.com/motemen/ghq/pull/249) ([Songmu](https://github.com/Songmu))\n* enhance svn and git-svn support [#248](https://github.com/motemen/ghq/pull/248) ([Songmu](https://github.com/Songmu))\n\n## [v0.17.4](https://github.com/motemen/ghq/compare/v0.17.3...v0.17.4) (2019-12-29)\n\n* [fix] uniq local roots [#246](https://github.com/motemen/ghq/pull/246) ([Songmu](https://github.com/Songmu))\n* [bugfix] fix race conditions by using sync.Once [#245](https://github.com/motemen/ghq/pull/245) ([Songmu](https://github.com/Songmu))\n\n## [v0.17.3](https://github.com/motemen/ghq/compare/v0.17.2...v0.17.3) (2019-12-26)\n\n* [incompatible] fix localRepositoryRoots order [#240](https://github.com/motemen/ghq/pull/240) ([Songmu](https://github.com/Songmu))\n\n## [v0.17.2](https://github.com/motemen/ghq/compare/v0.17.1...v0.17.2) (2019-12-26)\n\n* adjust ghq.root detection [#238](https://github.com/motemen/ghq/pull/238) ([Songmu](https://github.com/Songmu))\n* adjust document [#236](https://github.com/motemen/ghq/pull/236) ([Songmu](https://github.com/Songmu))\n* stop providing 32bit binary [#235](https://github.com/motemen/ghq/pull/235) ([Songmu](https://github.com/Songmu))\n* The parallel option is now an official feature [#234](https://github.com/motemen/ghq/pull/234) ([Songmu](https://github.com/Songmu))\n* Update urfave/cli to v2 [#233](https://github.com/motemen/ghq/pull/233) ([Songmu](https://github.com/Songmu))\n\n## [v0.17.1](https://github.com/motemen/ghq/compare/v0.17.0...v0.17.1) (2019-12-25)\n\n* [bugfix] fix --no-recursive [#232](https://github.com/motemen/ghq/pull/232) ([Songmu](https://github.com/Songmu))\n* Add bash-completion [#231](https://github.com/motemen/ghq/pull/231) ([mattn](https://github.com/mattn))\n\n## [v0.17.0](https://github.com/motemen/ghq/compare/v0.16.0...v0.17.0) (2019-12-24)\n\n* add create subcommand [#229](https://github.com/motemen/ghq/pull/229) ([Songmu](https://github.com/Songmu))\n* ghq.<url>.root configuration [#228](https://github.com/motemen/ghq/pull/228) ([Songmu](https://github.com/Songmu))\n\n## [v0.16.0](https://github.com/motemen/ghq/compare/v0.15.0...v0.16.0) (2019-12-22)\n\n* fetch recursively by default on git repository and  add --no-recursive option to prevent it [#227](https://github.com/motemen/ghq/pull/227) ([moajo](https://github.com/moajo))\n* add tests for package cmdutil [#226](https://github.com/motemen/ghq/pull/226) ([Songmu](https://github.com/Songmu))\n\n## [v0.15.0](https://github.com/motemen/ghq/compare/v0.14.2...v0.15.0) (2019-12-19)\n\n* refactor test helpers [#225](https://github.com/motemen/ghq/pull/225) ([Songmu](https://github.com/Songmu))\n* drop deprecated `ghq.ghe.host` configuration [#224](https://github.com/motemen/ghq/pull/224) ([Songmu](https://github.com/Songmu))\n* remove os.Exit from inside code [#223](https://github.com/motemen/ghq/pull/223) ([Songmu](https://github.com/Songmu))\n* drop xerrors deps and update deps [#222](https://github.com/motemen/ghq/pull/222) ([Songmu](https://github.com/Songmu))\n* Ignore and just log inaccessible directories instead of failing [#221](https://github.com/motemen/ghq/pull/221) ([Songmu](https://github.com/Songmu))\n* adjust files structure [#220](https://github.com/motemen/ghq/pull/220) ([Songmu](https://github.com/Songmu))\n\n## [v0.14.2](https://github.com/motemen/ghq/compare/v0.14.1...v0.14.2) (2019-12-18)\n\n* treat git-svn as a kind of git repository in local [#219](https://github.com/motemen/ghq/pull/219) ([Songmu](https://github.com/Songmu))\n\n## [v0.14.1](https://github.com/motemen/ghq/compare/v0.14.0...v0.14.1) (2019-12-18)\n\n* update deps [#218](https://github.com/motemen/ghq/pull/218) ([Songmu](https://github.com/Songmu))\n* refine local VCS detection order [#217](https://github.com/motemen/ghq/pull/217) ([Songmu](https://github.com/Songmu))\n* [refactor] define type vcsGetOption struct [#216](https://github.com/motemen/ghq/pull/216) ([Songmu](https://github.com/Songmu))\n* the import subcommand should not accept the --branch option [#214](https://github.com/motemen/ghq/pull/214) ([Songmu](https://github.com/Songmu))\n* fix broken coverage report [#213](https://github.com/motemen/ghq/pull/213) ([shogo82148](https://github.com/shogo82148))\n* Convertion for URL should return slash-ed paths. [#212](https://github.com/motemen/ghq/pull/212) ([mattn](https://github.com/mattn))\n\n## [v0.14.0](https://github.com/motemen/ghq/compare/v0.13.1...v0.14.0) (2019-12-04)\n\n* introduce GitHub Actions [#208](https://github.com/motemen/ghq/pull/208) ([Songmu](https://github.com/Songmu))\n* Fix typos! [#210](https://github.com/motemen/ghq/pull/210) ([tockn](https://github.com/tockn))\n* Fix redundant index [#209](https://github.com/motemen/ghq/pull/209) ([tockn](https://github.com/tockn))\n* add Songmu to authors [#207](https://github.com/motemen/ghq/pull/207) ([Songmu](https://github.com/Songmu))\n* Fix deprecation of urfave/cli [#206](https://github.com/motemen/ghq/pull/206) ([tockn](https://github.com/tockn))\n\n## [v0.13.1](https://github.com/motemen/ghq/compare/v0.13.0...v0.13.1) (2019-12-04)\n\n* optimize `--vcs` option of list [#205](https://github.com/motemen/ghq/pull/205) ([autopp](https://github.com/autopp))\n\n## [v0.13.0](https://github.com/motemen/ghq/compare/v0.12.9...v0.13.0) (2019-12-01)\n\n* update deps [#204](https://github.com/motemen/ghq/pull/204) ([Songmu](https://github.com/Songmu))\n* Add --branch option to `ghq get` for specifying branch [#203](https://github.com/motemen/ghq/pull/203) ([rhysd](https://github.com/rhysd))\n\n## [v0.12.9](https://github.com/motemen/ghq/compare/v0.12.8...v0.12.9) (2019-11-20)\n\n* update deps [#201](https://github.com/motemen/ghq/pull/201) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.8](https://github.com/motemen/ghq/compare/v0.12.7...v0.12.8) (2019-11-05)\n\n* [bugfix] lock in walking [#197](https://github.com/motemen/ghq/pull/197) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.7](https://github.com/motemen/ghq/compare/v0.12.6...v0.12.7) (2019-11-05)\n\n* fix accepted values of ghq.<url>.vcs in README [#196](https://github.com/motemen/ghq/pull/196) ([autopp](https://github.com/autopp))\n* Use walker [#195](https://github.com/motemen/ghq/pull/195) ([mattn](https://github.com/mattn))\n* Use filepath [#194](https://github.com/motemen/ghq/pull/194) ([mattn](https://github.com/mattn))\n* go.{mod,sum}: Update xerrors dependency [#193](https://github.com/motemen/ghq/pull/193) ([rvolosatovs](https://github.com/rvolosatovs))\n* define func detectUserName and utilize it [#191](https://github.com/motemen/ghq/pull/191) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.6](https://github.com/motemen/ghq/compare/v0.12.5...v0.12.6) (2019-05-29)\n\n* Removing port number from local directory. [#182](https://github.com/motemen/ghq/pull/182) ([gmidorii](https://github.com/gmidorii))\n\n## [v0.12.5](https://github.com/motemen/ghq/compare/v0.12.4...v0.12.5) (2019-05-28)\n\n* refine local cloning path detection [#181](https://github.com/motemen/ghq/pull/181) ([Songmu](https://github.com/Songmu))\n* Adjust metafiles [#179](https://github.com/motemen/ghq/pull/179) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.4](https://github.com/motemen/ghq/compare/v0.12.3...v0.12.4) (2019-05-24)\n\n* make archive [#178](https://github.com/motemen/ghq/pull/178) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.3](https://github.com/motemen/ghq/compare/v0.12.2...v0.12.3) (2019-05-16)\n\n* [fix] Ignore files which seems to system hidden file in walking [#176](https://github.com/motemen/ghq/pull/176) ([Songmu](https://github.com/Songmu))\n* [fix] Fix the list if symlink is in the same directory [#174](https://github.com/motemen/ghq/pull/174) ([at-grandpa](https://github.com/at-grandpa))\n* [refactoring] introduce Songmu/gitconfig [#175](https://github.com/motemen/ghq/pull/175) ([Songmu](https://github.com/Songmu))\n* [refactoring] Get ghq.completeUser strictly as a boolean value [#172](https://github.com/motemen/ghq/pull/172) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.2](https://github.com/motemen/ghq/compare/v0.12.1...v0.12.2) (2019-05-12)\n\n* [fix] remove extra / from ref when path has \"/\" prefix [#167](https://github.com/motemen/ghq/pull/167) ([sakihet](https://github.com/sakihet))\n* [fix] refine local cloning path detection [#171](https://github.com/motemen/ghq/pull/171) ([Songmu](https://github.com/Songmu))\n* [fix] skip go-import mod in detectGoImport [#170](https://github.com/motemen/ghq/pull/170) ([Songmu](https://github.com/Songmu))\n* [fix] even if the GHQ_ROOT directory doesn't exist, don't raise an error [#168](https://github.com/motemen/ghq/pull/168) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.1](https://github.com/motemen/ghq/compare/v0.12.0...v0.12.1) (2019-05-07)\n\n* update deps [#164](https://github.com/motemen/ghq/pull/164) ([Songmu](https://github.com/Songmu))\n\n## [v0.12.0](https://github.com/motemen/ghq/compare/v0.11.2...v0.12.0) (2019-05-07)\n\n* get lock using repoPath to avoid duplicate get on import [#163](https://github.com/motemen/ghq/pull/163) ([Songmu](https://github.com/Songmu))\n* separate gitutil package from main and utilize it [#162](https://github.com/motemen/ghq/pull/162) ([Songmu](https://github.com/Songmu))\n* support deep directory in GitRepository like 'github.com/motemen/ghq/logger' [#161](https://github.com/motemen/ghq/pull/161) ([Songmu](https://github.com/Songmu))\n* Test enhancement [#160](https://github.com/motemen/ghq/pull/160) ([Songmu](https://github.com/Songmu))\n* add TestLocalRepository_VCS [#159](https://github.com/motemen/ghq/pull/159) ([Songmu](https://github.com/Songmu))\n\n## [v0.11.2](https://github.com/motemen/ghq/compare/v0.11.1...v0.11.2) (2019-05-06)\n\n* [bugfix] walk up directory when finding VCS of LocalRepository to avaid panics [#158](https://github.com/motemen/ghq/pull/158) ([Songmu](https://github.com/Songmu))\n* bzr pull --overwrite same as go get [#157](https://github.com/motemen/ghq/pull/157) ([Songmu](https://github.com/Songmu))\n\n## [v0.11.1](https://github.com/motemen/ghq/compare/v0.11.0...v0.11.1) (2019-05-05)\n\n* [feature] List vcs option [#155](https://github.com/motemen/ghq/pull/155) ([msh5](https://github.com/msh5))\n* [testing] add TestDoImport [#156](https://github.com/motemen/ghq/pull/156) ([Songmu](https://github.com/Songmu))\n* [fix] fix findVCSBackend and add tests [#154](https://github.com/motemen/ghq/pull/154) ([Songmu](https://github.com/Songmu))\n* [fix] Make sure the directory exists with the exact name [#145](https://github.com/motemen/ghq/pull/145) ([knu](https://github.com/knu))\n* [bugfix] Fix fossil support [#153](https://github.com/motemen/ghq/pull/153) ([Songmu](https://github.com/Songmu))\n* [testing] add TestDoList_query [#152](https://github.com/motemen/ghq/pull/152) ([Songmu](https://github.com/Songmu))\n* [testing] add TestRunInDirSilently [#151](https://github.com/motemen/ghq/pull/151) ([Songmu](https://github.com/Songmu))\n* [testing] add more tests in TestDoLook [#150](https://github.com/motemen/ghq/pull/150) ([Songmu](https://github.com/Songmu))\n* [testing] add TestDoLook [#149](https://github.com/motemen/ghq/pull/149) ([Songmu](https://github.com/Songmu))\n* [refactoring] remove NewFakeRunner which not used [#148](https://github.com/motemen/ghq/pull/148) ([Songmu](https://github.com/Songmu))\n* [refactoring] Commonize doGet and doImport processing for refactoring [#147](https://github.com/motemen/ghq/pull/147) ([Songmu](https://github.com/Songmu))\n* [testing] add test for `ghq root` [#146](https://github.com/motemen/ghq/pull/146) ([Songmu](https://github.com/Songmu))\n\n## [v0.11.0](https://github.com/motemen/ghq/compare/v0.10.2...v0.11.0) (2019-05-01)\n\n* Delete codes for the services turned down (Google Code and JazzHub) [#144](https://github.com/motemen/ghq/pull/144) ([Songmu](https://github.com/Songmu))\n* reduce linter warnings [#143](https://github.com/motemen/ghq/pull/143) ([Songmu](https://github.com/Songmu))\n* remove ghq.import.<subcommand> feature [#137](https://github.com/motemen/ghq/pull/137) ([Songmu](https://github.com/Songmu))\n* Remove gomega [#142](https://github.com/motemen/ghq/pull/142) ([Songmu](https://github.com/Songmu))\n* Streamline VCS detection for local repositories [#141](https://github.com/motemen/ghq/pull/141) ([Songmu](https://github.com/Songmu))\n* introduce table driven test in TestCommandGet [#140](https://github.com/motemen/ghq/pull/140) ([Songmu](https://github.com/Songmu))\n* \"bzr\" as Bazaar [#139](https://github.com/motemen/ghq/pull/139) ([Songmu](https://github.com/Songmu))\n* Support bazaar [#87](https://github.com/motemen/ghq/pull/87) ([shigemk2](https://github.com/shigemk2))\n* [experimental] support parallel import by using --parallel option [#136](https://github.com/motemen/ghq/pull/136) ([Songmu](https://github.com/Songmu))\n* add -silent option to get and import [#135](https://github.com/motemen/ghq/pull/135) ([Songmu](https://github.com/Songmu))\n* Stop exec on unix in the look subcommand in order to share code with windows [#134](https://github.com/motemen/ghq/pull/134) ([Songmu](https://github.com/Songmu))\n* [list] accept url as a query [#133](https://github.com/motemen/ghq/pull/133) ([Songmu](https://github.com/Songmu))\n* adjust NewURL() [#132](https://github.com/motemen/ghq/pull/132) ([Songmu](https://github.com/Songmu))\n\n## [v0.10.2](https://github.com/motemen/ghq/compare/v0.10.1...v0.10.2) (2019-04-28)\n\n* Fix `ghq root` [#131](https://github.com/motemen/ghq/pull/131) ([knu](https://github.com/knu))\n\n## [v0.10.1](https://github.com/motemen/ghq/compare/v0.10.0...v0.10.1) (2019-04-28)\n\n* Remove panics [#130](https://github.com/motemen/ghq/pull/130) ([Songmu](https://github.com/Songmu))\n* generally loggers should output STDERR by default [#129](https://github.com/motemen/ghq/pull/129) ([Songmu](https://github.com/Songmu))\n* Care the case if the query contains a hostname in list subcommand [#128](https://github.com/motemen/ghq/pull/128) ([Songmu](https://github.com/Songmu))\n* don't panic when the current working directory doesn't exist. [#127](https://github.com/motemen/ghq/pull/127) ([Songmu](https://github.com/Songmu))\n* canonicalize root paths to absolute [#126](https://github.com/motemen/ghq/pull/126) ([Songmu](https://github.com/Songmu))\n* List symlinks to repos [#125](https://github.com/motemen/ghq/pull/125) ([Songmu](https://github.com/Songmu))\n* rename package s/utils/cmdutil/ [#124](https://github.com/motemen/ghq/pull/124) ([Songmu](https://github.com/Songmu))\n* separate logger package from utils [#123](https://github.com/motemen/ghq/pull/123) ([Songmu](https://github.com/Songmu))\n\n## [v0.10.0](https://github.com/motemen/ghq/compare/v0.9.0...v0.10.0) (2019-04-27)\n\n* drop mitchellh/go-homedir dependency [#122](https://github.com/motemen/ghq/pull/122) ([Songmu](https://github.com/Songmu))\n* introduce Go Modules and adjust releng files [#121](https://github.com/motemen/ghq/pull/121) ([Songmu](https://github.com/Songmu))\n* Add a dummy CVS backend to recognize and skip CVS working directories [#115](https://github.com/motemen/ghq/pull/115) ([knu](https://github.com/knu))\n* add -l option on get command which immediately look after get [#112](https://github.com/motemen/ghq/pull/112) ([kuboon](https://github.com/kuboon))\n* add support for Fossil SCM [#98](https://github.com/motemen/ghq/pull/98) ([motemen](https://github.com/motemen))\n* Use parsed username also with ssh for Git [#101](https://github.com/motemen/ghq/pull/101) ([jjv](https://github.com/jjv))\n* Add ghq.completeUser config to disable user completion of `ghq get` [#118](https://github.com/motemen/ghq/pull/118) ([k0kubun](https://github.com/k0kubun))\n* ghq get --vcs=<vcs> [#72](https://github.com/motemen/ghq/pull/72) ([motemen](https://github.com/motemen))\n* warn if executable was not found when RunCommand [#70](https://github.com/motemen/ghq/pull/70) ([motemen](https://github.com/motemen))\n* support `meta name=\"go-import\"` to detect Go repository [#120](https://github.com/motemen/ghq/pull/120) ([Songmu](https://github.com/Songmu))\n* support refs which start with URL Authority in ghq get [#119](https://github.com/motemen/ghq/pull/119) ([Songmu](https://github.com/Songmu))\n\n## [v0.9.0](https://github.com/motemen/ghq/compare/v0.8.0...v0.9.0) (2018-11-26)\n\n* Use new constructor for logger [#104](https://github.com/motemen/ghq/pull/104) ([raviqqe](https://github.com/raviqqe))\n* fix typo direcotry -> directory [#93](https://github.com/motemen/ghq/pull/93) ([naofumi-fujii](https://github.com/naofumi-fujii))\n\n## [v0.8.0](https://github.com/motemen/ghq/compare/v0.7.4...v0.8.0) (2017-08-22)\n\n- [breaking feature] If given URL does not contain / character, treat the URL as `https://github.com/<USERNAME>/<URL>`, where USERNAME is GitHub username obtained from `ghq.user` Git configuration variable, GITHUB_USER or USER (USERNAME in Windows) environment variables thanks to @b4b4r07 (#81)\n- [maintenance] Fix building configuration thanks to @south37 (#85), @smizy (#82)\n\n## [v0.7.4](https://github.com/motemen/ghq/compare/v0.7.3...v0.7.4) (2016-03-07)\n\n* support path list in GHQ_ROOT [#71](https://github.com/motemen/ghq/pull/71) ([hatotaka](https://github.com/hatotaka))\n\n## [v0.7.3](https://github.com/motemen/ghq/compare/v0.7.2...v0.7.3) (2016-03-02)\n\n* Github relative [#43](https://github.com/motemen/ghq/pull/43) ([mattn](https://github.com/mattn))\n\n## [v0.7.2](https://github.com/motemen/ghq/compare/v0.7.1...v0.7.2) (2015-12-11)\n\n* Revert \"Merge pull request #54 from maoe/skip-non-vcs-dirs\" [#66](https://github.com/motemen/ghq/pull/66) ([motemen](https://github.com/motemen))\n\n## [v0.7.1](https://github.com/motemen/ghq/compare/v0.7...v0.7.1) (2015-08-06)\n\n* Fix an issue of listing with directories containing symlinks [#61](https://github.com/motemen/ghq/pull/61) ([motemen](https://github.com/motemen))\n\n## [v0.7](https://github.com/motemen/ghq/compare/v0.6...v0.7) (2015-08-03)\n\n* Support for Bluemix DevOps Git service [#56](https://github.com/motemen/ghq/pull/56) ([uetchy](https://github.com/uetchy))\n* GHQ_ROOT environment variable to override the root [#59](https://github.com/motemen/ghq/pull/59) ([motemen](https://github.com/motemen))\n* Add darcs backend [#55](https://github.com/motemen/ghq/pull/55) ([maoe](https://github.com/maoe))\n* fix failing test [#58](https://github.com/motemen/ghq/pull/58) ([motemen](https://github.com/motemen))\n* Skip non-VCS directories for performance [#54](https://github.com/motemen/ghq/pull/54) ([maoe](https://github.com/maoe))\n* fix test [#57](https://github.com/motemen/ghq/pull/57) ([motemen](https://github.com/motemen))\n* `look` command accepts remote repository url too. [#51](https://github.com/motemen/ghq/pull/51) ([ryotarai](https://github.com/ryotarai))\n* Add GHQ_LOOK env variable to a new shell executed by `ghq look` [#47](https://github.com/motemen/ghq/pull/47) ([superbrothers](https://github.com/superbrothers))\n\n## [v0.6](https://github.com/motemen/ghq/compare/v0.5...v0.6) (2014-11-20)\n\n* support gist URLs [#46](https://github.com/motemen/ghq/pull/46) ([motemen](https://github.com/motemen))\n* Return exit status 1 for clone failure [#45](https://github.com/motemen/ghq/pull/45) ([k0kubun](https://github.com/k0kubun))\n\n## [v0.5](https://github.com/motemen/ghq/compare/v0.4...v0.5) (2014-10-11)\n\n* fixup docs and zsh completion [#44](https://github.com/motemen/ghq/pull/44) ([motemen](https://github.com/motemen))\n* Add 'root' subcommand completion [#42](https://github.com/motemen/ghq/pull/42) ([syohex](https://github.com/syohex))\n* Include zsh completion into release zip files [#41](https://github.com/motemen/ghq/pull/41) ([itiut](https://github.com/itiut))\n* Add --all option to the root command [#40](https://github.com/motemen/ghq/pull/40) ([aaa707](https://github.com/aaa707))\n* import: Accept the same clone flags with get command [#37](https://github.com/motemen/ghq/pull/37) ([eagletmt](https://github.com/eagletmt))\n* accept SCP-like URL (git@github.com) for import command [#35](https://github.com/motemen/ghq/pull/35) ([mkanai](https://github.com/mkanai))\n* Add root command [#34](https://github.com/motemen/ghq/pull/34) ([aaa707](https://github.com/aaa707))\n* Set exit code of `look` which failed [#33](https://github.com/motemen/ghq/pull/33) ([fujimura](https://github.com/fujimura))\n* Re-implement `ghq import` [#31](https://github.com/motemen/ghq/pull/31) ([motemen](https://github.com/motemen))\n* use go-homedir for distributing compiled binaries [#32](https://github.com/motemen/ghq/pull/32) ([motemen](https://github.com/motemen))\n* Fix for latest github.com/codegangsta/cli [#28](https://github.com/motemen/ghq/pull/28) ([syohex](https://github.com/syohex))\n\n## 0.4 (2014-06-26)\n\n- [feature] Support per-URL configuration variables e.g. `ghq.<URL>.vcs` to skip VCS backend auto-detection\n- [fix] Fixed path problems of SCP-like URLs thanks to @osamu2001 (#20)\n- [fix] `ghq get -u` now updates work tree for Mercurial repositories thanks to @troter (#19)\n- And typo fixes thanks to @sorah, @dtan4 (#17, #18)\n\n## 0.3 (2014-06-17)\n\n- [feature] `ghq get -shallow` to perform a shallow clone\n- [feature] Use GitHub token for `ghq import starred` if specified thanks to @makimoto (#16)\n- [fix] Resolve ghq.root's symlinks thanks to @sorah (#15)\n\n## 0.2 (2014-06-10)\n\n- [feature] Support SCP-like repository URLs thanks to @kentaro (#1)\n- [feature] Support GitHub:Enterprise repository URLs thanks to @kentaro (#2)\n- [fix] Fix issue that default config variable was never used thanks to @Sixeight (#3)\n- [fix] Support Windows environment thanks to @mattn (#5)\n- [feature] `ghq get -p` to clone GitHub repositories with SSH thanks to @moznion (#7)\n- [feature] Support any remotes other than GitHub and Google Code thanks to @tcnksm (#8, #13)\n- [feature] Improve zsh completion thanks to @mollifier (#12)\n- [feature] Support `ghq get git` for GitHub repositories with user and project name same thanks to @Sixeight (#14)\n- And documentation updates thanks to @kentaro, @tricknotes (#6, #9)\n\n## 0.1 (2014-06-01)\n\n- Initial release\n"
        },
        {
          "name": "CREDITS",
          "type": "blob",
          "size": 47.501953125,
          "content": "Go (the standard library)\nhttps://golang.org/\n----------------------------------------------------------------\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngithub.com/Songmu/gitconfig\nhttps://github.com/Songmu/gitconfig\n----------------------------------------------------------------\nCopyright (c) 2019 Songmu\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n================================================================\n\ngithub.com/cli/go-gh\nhttps://github.com/cli/go-gh\n----------------------------------------------------------------\nMIT License\n\nCopyright (c) 2021 GitHub Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/cli/safeexec\nhttps://github.com/cli/safeexec\n----------------------------------------------------------------\nBSD 2-Clause License\n\nCopyright (c) 2020, GitHub Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngithub.com/cpuguy83/go-md2man/v2\nhttps://github.com/cpuguy83/go-md2man/v2\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2014 Brian Goff\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/davecgh/go-spew\nhttps://github.com/davecgh/go-spew\n----------------------------------------------------------------\nISC License\n\nCopyright (c) 2012-2016 Dave Collins <dave@davec.name>\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n================================================================\n\ngithub.com/daviddengcn/go-colortext\nhttps://github.com/daviddengcn/go-colortext\n----------------------------------------------------------------\nBSD License\n===========\n\nCopyright (c) 2016, David Deng\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of go-colortext nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\nMIT License\n===========\n\nCopyright (c) 2016 David Deng\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/fatih/color\nhttps://github.com/fatih/color\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2013 Fatih Arslan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n================================================================\n\ngithub.com/go-playground/locales\nhttps://github.com/go-playground/locales\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2016 Go Playground\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n================================================================\n\ngithub.com/go-playground/universal-translator\nhttps://github.com/go-playground/universal-translator\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2016 Go Playground\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/go-playground/validator/v10\nhttps://github.com/go-playground/validator/v10\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2015 Dean Karn\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n================================================================\n\ngithub.com/goccy/go-yaml\nhttps://github.com/goccy/go-yaml\n----------------------------------------------------------------\nMIT License\n\nCopyright (c) 2019 Masaaki Goshima\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/golangplus/testing\nhttps://github.com/golangplus/testing\n----------------------------------------------------------------\nCopyright (c) 2015, Golang Plus\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of testing nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n================================================================\n\ngithub.com/google/go-cmp\nhttps://github.com/google/go-cmp\n----------------------------------------------------------------\nCopyright (c) 2017 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngithub.com/kr/pretty\nhttps://github.com/kr/pretty\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright 2012 Keith Rarick\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n================================================================\n\ngithub.com/kr/text\nhttps://github.com/kr/text\n----------------------------------------------------------------\nCopyright 2012 Keith Rarick\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n================================================================\n\ngithub.com/leodido/go-urn\nhttps://github.com/leodido/go-urn\n----------------------------------------------------------------\nMIT License\n\nCopyright (c) 2018 Leonardo Di Donato\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/mattn/go-colorable\nhttps://github.com/mattn/go-colorable\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2016 Yasuhiro Matsumoto\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/mattn/go-isatty\nhttps://github.com/mattn/go-isatty\n----------------------------------------------------------------\nCopyright (c) Yasuhiro MATSUMOTO <mattn.jp@gmail.com>\n\nMIT License (Expat)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n================================================================\n\ngithub.com/motemen/go-colorine\nhttps://github.com/motemen/go-colorine\n----------------------------------------------------------------\nThe MIT License (MIT)\n\nCopyright (c) 2014 motemen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n================================================================\n\ngithub.com/pmezard/go-difflib\nhttps://github.com/pmezard/go-difflib\n----------------------------------------------------------------\nCopyright (c) 2013, Patrick Mezard\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n    Redistributions in binary form must reproduce the above copyright\nnotice, this list of conditions and the following disclaimer in the\ndocumentation and/or other materials provided with the distribution.\n    The names of its contributors may not be used to endorse or promote\nproducts derived from this software without specific prior written\npermission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\nTO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngithub.com/russross/blackfriday/v2\nhttps://github.com/russross/blackfriday/v2\n----------------------------------------------------------------\nBlackfriday is distributed under the Simplified BSD License:\n\n> Copyright  2011 Russ Ross\n> All rights reserved.\n>\n> Redistribution and use in source and binary forms, with or without\n> modification, are permitted provided that the following conditions\n> are met:\n>\n> 1.  Redistributions of source code must retain the above copyright\n>     notice, this list of conditions and the following disclaimer.\n>\n> 2.  Redistributions in binary form must reproduce the above\n>     copyright notice, this list of conditions and the following\n>     disclaimer in the documentation and/or other materials provided with\n>     the distribution.\n>\n> THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n> \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n> LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n> FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n> COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n> INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n> BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n> LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n> CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n> LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n> ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n> POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngithub.com/saracen/walker\nhttps://github.com/saracen/walker\n----------------------------------------------------------------\nMIT License\n\nCopyright (c) 2019 Arran Walker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n================================================================\n\ngithub.com/stretchr/testify\nhttps://github.com/stretchr/testify\n----------------------------------------------------------------\nMIT License\n\nCopyright (c) 2012-2020 Mat Ryer, Tyler Bunnell and contributors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/urfave/cli/v2\nhttps://github.com/urfave/cli/v2\n----------------------------------------------------------------\nMIT License\n\nCopyright (c) 2022 urfave/cli maintainers\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n================================================================\n\ngithub.com/xrash/smetrics\nhttps://github.com/xrash/smetrics\n----------------------------------------------------------------\nCopyright (C) 2016 Felipe da Cunha Gonalves\nAll Rights Reserved.\n\nMIT LICENSE\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n================================================================\n\ngolang.org/x/crypto\nhttps://golang.org/x/crypto\n----------------------------------------------------------------\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngolang.org/x/net\nhttps://golang.org/x/net\n----------------------------------------------------------------\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngolang.org/x/sync\nhttps://golang.org/x/sync\n----------------------------------------------------------------\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngolang.org/x/sys\nhttps://golang.org/x/sys\n----------------------------------------------------------------\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngolang.org/x/xerrors\nhttps://golang.org/x/xerrors\n----------------------------------------------------------------\nCopyright (c) 2019 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngopkg.in/check.v1\nhttps://gopkg.in/check.v1\n----------------------------------------------------------------\nGocheck - A rich testing framework for Go\n \nCopyright (c) 2010-2013 Gustavo Niemeyer <gustavo@niemeyer.net>\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met: \n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution. \n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n================================================================\n\ngopkg.in/yaml.v3\nhttps://gopkg.in/yaml.v3\n----------------------------------------------------------------\n\nThis project is covered by two different licenses: MIT and Apache.\n\n#### MIT License ####\n\nThe following files were ported to Go from C files of libyaml, and thus\nare still covered by their original MIT license, with the additional\ncopyright staring in 2011 when the project was ported over:\n\n    apic.go emitterc.go parserc.go readerc.go scannerc.go\n    writerc.go yamlh.go yamlprivateh.go\n\nCopyright (c) 2006-2010 Kirill Simonov\nCopyright (c) 2006-2011 Kirill Simonov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n### Apache License ###\n\nAll the remaining project files are covered by the Apache license:\n\nCopyright (c) 2011-2019 Canonical Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n================================================================\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 motemen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.19921875,
          "content": "VERSION = $(shell godzil show-version)\nCURRENT_REVISION = $(shell git rev-parse --short HEAD)\nBUILD_LDFLAGS = \"-s -w -X main.revision=$(CURRENT_REVISION)\"\nVERBOSE_FLAG = $(if $(VERBOSE),-v)\nu := $(if $(update),-u)\n\n.PHONY: deps\ndeps:\n\tgo get ${u} $(VERBOSE_FLAG)\n\tgo mod tidy\n\n.PHONY: devel-deps\ndevel-deps: deps\n\tgo install github.com/Songmu/godzil/cmd/godzil@latest\n\tgo install github.com/tcnksm/ghr@latest\n\tgo install honnef.co/go/tools/cmd/staticcheck@latest\n\n.PHONY: test\ntest: deps\n\tgo test $(VERBOSE_FLAG) ./...\n\n.PHONY: lint\nlint: devel-deps\n\tstaticcheck ./...\n\n.PHONY: build\nbuild: deps\n\tgo build $(VERBOSE_FLAG) -ldflags=$(BUILD_LDFLAGS)\n\n.PHONY: install\ninstall: deps\n\tgo install $(VERBOSE_FLAG) -ldflags=$(BUILD_LDFLAGS)\n\n.PHONY: release\nrelease: devel-deps\n\tgodzil release\n\nCREDITS: devel-deps go.sum\n\tgodzil credits -w\n\nDIST_DIR = dist/v$(VERSION)\n.PHONY: crossbuild\ncrossbuild: CREDITS\n\trm -rf $(DIST_DIR)\n\tenv CGO_ENABLED=0 godzil crossbuild -build-ldflags=$(BUILD_LDFLAGS) \\\n      -include='misc/bash/_ghq','misc/zsh/_ghq' -z -d $(DIST_DIR)\n\tcd $(DIST_DIR) && shasum $$(find * -type f -maxdepth 0) > SHASUMS\n\n.PHONY: upload\nupload:\n\tghr -body=\"$$(godzil changelog --latest -F markdown)\" v$(VERSION) $(DIST_DIR)\n"
        },
        {
          "name": "README.adoc",
          "type": "blob",
          "size": 6.1962890625,
          "content": "= ghq(1) image:https://github.com/x-motemen/ghq/workflows/test/badge.svg?branch=master[\"Build Status\", link=\"https://github.com/x-motemen/ghq/actions?workflow=test\"] image:https://codecov.io/gh/x-motemen/ghq/branch/master/graph/badge.svg[\"Coverage\", link=\"https://codecov.io/gh/x-motemen/ghq\"]\n\n== NAME\n\nghq - Manage remote repository clones\n\n== DESCRIPTION\n\n'ghq' provides a way to organize remote repository clones, like +go get+ does. When you clone a remote repository by +ghq get+, ghq makes a directory under a specific root directory (by default +~/ghq+) using the remote repository URL's host and path.\n\n    $ ghq get https://github.com/x-motemen/ghq\n    # Runs `git clone https://github.com/x-motemen/ghq ~/ghq/github.com/x-motemen/ghq`\n\nYou can also list local repositories (+ghq list+).\n\n== SYNOPSIS\n\n[verse]\nghq get [-u] [-p] [--shallow] [--vcs <vcs>] [--look] [--silent] [--branch] [--no-recursive] [--bare] <repository URL>|<host>/<user>/<project>|<user>/<project>|<project>\nghq list [-p] [-e] [<query>]\nghq create [--vcs <vcs>] <repository URL>|<host>/<user>/<project>|<user>/<project>|<project>\nghq rm [--dry-run] <repository URL>|<host>/<user>/<project>|<user>/<project>|<project>\nghq root [--all]\n\n== COMMANDS\n\nget::\n    Clone a remote repository under ghq root directory (see\n    <<directory-structures,DIRECTORY STRUCTURES>> below). `ghq clone` is an alias for this command.\n    If the repository is\n    already cloned to local, nothing will happen unless '-u' ('--update')\n    flag is supplied, in which case the local repository is updated ('git pull --ff-only' eg.).\n    When you use '-p' option, the repository is cloned via SSH protocol. +\n    If there are multiple +ghq.root+ s, existing local clones are searched\n    first. Then a new repository clone is created under the primary root if\n    none is found. +\n    With '--shallow' option, a \"shallow clone\" will be performed (for Git\n    repositories only, 'git clone --depth 1 ...' eg.). Be careful that a\n    shallow-cloned repository cannot be pushed to remote.\n    Currently Git and Mercurial repositories are supported. +\n    With '--branch' option, you can clone the repository with specified\n    branch. This option is currently supported for Git, Mercurial,\n    Subversion and git-svn. +\n    The 'ghq' gets the git repository recursively by default. +\n    We can prevent it with '--no-recursive' option.\n    With '--bare' option, a \"bare clone\" will be performed (for Git\n    repositories only, 'git clone --bare ...' eg.).\n\nlist::\n    List locally cloned repositories. If a query argument is given, only\n    repositories whose names contain that query text are listed. '-e'\n    ('--exact') forces the match to be an exact one (i.e. the query equals to\n    _project_, _user_/_project_ or _host_/_user_/_project_)\n    If '-p' ('--full-path') is given, the full paths to the repository root are\n    printed instead of relative ones.\n\nroot::\n    Prints repositories' root (i.e. `ghq.root`). Without '--all' option, the\n    primary one is shown.\n\nrm::\n    Remove local repository. If '--dry-run' option is given, the repository is not actually removed but the path to it is printed.\n\ncreate::\n    Creates new repository.\n\n== CONFIGURATION\n\nConfiguration uses 'git-config' variables.\n\nghq.root::\n    The path to directory under which cloned repositories are placed. See\n    <<directory-structures,DIRECTORY STRUCTURES>> below. Defaults to +~/ghq+. +\n    This variable can have multiple values. If so, the last one becomes\n    primary one i.e. new repository clones are always created under it. You may\n    want to specify \"$GOPATH/src\" as a secondary root (environment variables\n    should be expanded.)\n\nghq.<url>.vcs::\n    ghq tries to detect the remote repository's VCS backend for non-\"github.com\"\n    repositories.  With this option you can explicitly specify the VCS for the\n    remote repository. The URL is matched against '<url>' using 'git config --get-urlmatch'. +\n    Accepted values are \"git\", \"github\" (an alias for \"git\"), \"subversion\",\n    \"svn\" (an alias for \"subversion\"), \"git-svn\", \"mercurial\", \"hg\" (an alias for \"mercurial\"),\n    \"darcs\", \"fossil\", \"bazaar\", and \"bzr\" (an alias for \"bazaar\"). +\n    To get this configuration variable effective, you will need Git 1.8.5 or higher.\n\nghq.<url>.root::\n    The \"ghq\" tries to detect the remote repository-specific root directory. With this option,\n    you can specify a repository-specific root directory instead of the common ghq root directory. +\n    The URL is matched against '<url>' using 'git config --get-urlmatch'.\n\n\n=== Example configuration (.gitconfig):\n\n....\n[ghq \"https://git.example.com/repos/\"]\nvcs = git\nroot = ~/myproj\n....\n\n== ENVIRONMENT VARIABLES\n\nGHQ_ROOT::\n    If set to a path, this value is used as the only root directory regardless\n    of other existing ghq.root settings.\n\n== [[directory-structures]]DIRECTORY STRUCTURES\n\nLocal repositories are placed under 'ghq.root' with named github.com/_user_/_repo_.\n\n....\n~/ghq\n|-- code.google.com/\n|   `-- p/\n|       `-- vim/\n`-- github.com/\n    |-- google/\n    |   `-- go-github/\n    |-- motemen/\n    |   `-- ghq/\n    `-- urfave/\n        `-- cli/\n....\n\n\n== [[installing]]INSTALLATION\n\n=== macOS\n\n----\nbrew install ghq\n----\n\n=== Void Linux\n\n----\nxbps-install -S ghq\n----\n\n=== GNU Guix\n\n----\nguix install ghq\n----\n\n=== Windows + scoop\n\n----\nscoop install ghq\n----\n\n\n=== go get\n\n----\ngo install github.com/x-motemen/ghq@latest\n----\n\n=== conda\n\n----\nconda install -c conda-forge go-ghq\n----\n\n=== https://github.com/asdf-vm/asdf[asdf-vm]\n\n----\nasdf plugin add ghq\nasdf install ghq latest\n----\n\n=== https://github.com/jdx/mise[mise-en-place]\n\n----\nmise install ghq\nmise use ghq\n----\n\n=== build\n\n----\ngit clone https://github.com/x-motemen/ghq .\nmake install\n----\n\nBuilt binaries are available from GitHub Releases.\nhttps://github.com/x-motemen/ghq/releases\n\n== HANDBOOK\n\nYou can buy \"ghq-handbook\" from Leanpub for more detailed usage.\n\nhttps://leanpub.com/ghq-handbook\n\nThe source Markdown files of this book are also available for free from the following repository.\n\nhttps://github.com/Songmu/ghq-handbook\n\nCurrently, only Japanese version available.\nYour translations are welcome!\n\n== AUTHOR\n\n* motemen <motemen@gmail.com>\n** https://github.com/sponsors/motemen\n* Songmu <y.songmu@gmail.com>\n** https://github.com/sponsors/Songmu\n"
        },
        {
          "name": "cmd_create.go",
          "type": "blob",
          "size": 1.41796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc doCreate(c *cli.Context) error {\n\tvar (\n\t\tname = c.Args().First()\n\t\tvcs  = c.String(\"vcs\")\n\t\tw    = c.App.Writer\n\t\tbare = c.Bool(\"bare\")\n\t)\n\n\tif name == \"\" {\n\t\treturn fmt.Errorf(\"repository name is required\")\n\t}\n\n\tu, err := newURL(name, false, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlocalRepo, err := LocalRepositoryFromURL(u, bare)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp := localRepo.FullPath\n\tok, err := isNotExistOrEmpty(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !ok {\n\t\treturn fmt.Errorf(\"directory %q already exists and not empty\", p)\n\t}\n\n\tremoteRepo, err := NewRemoteRepository(u)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvcsBackend, ok := vcsRegistry[vcs]\n\tif !ok {\n\t\tvcsBackend, _, err = remoteRepo.VCS()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif vcsBackend == nil {\n\t\treturn fmt.Errorf(\"failed to init: unsupported VCS\")\n\t}\n\n\tinitFunc := vcsBackend.Init\n\tif initFunc == nil {\n\t\treturn fmt.Errorf(\"failed to init: unsupported VCS\")\n\t}\n\n\tif err := os.MkdirAll(p, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tif err := initFunc(p); err != nil {\n\t\treturn err\n\t}\n\t_, err = fmt.Fprintln(w, p)\n\treturn err\n}\n\nfunc isNotExistOrEmpty(name string) (bool, error) {\n\tf, err := os.Open(name)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn false, err\n\t}\n\tdefer f.Close()\n\n\t_, err = f.Readdirnames(1)\n\tif err == io.EOF {\n\t\treturn true, nil\n\t}\n\treturn false, err\n}\n"
        },
        {
          "name": "cmd_create_test.go",
          "type": "blob",
          "size": 4.408203125,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/x-motemen/ghq/cmdutil\"\n)\n\nfunc TestDoCreate(t *testing.T) {\n\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\tcmdutil.CommandRunner = orig\n\t}(cmdutil.CommandRunner)\n\tvar lastCmd *exec.Cmd\n\tcommandRunner := func(cmd *exec.Cmd) error {\n\t\tlastCmd = cmd\n\t\treturn nil\n\t}\n\tdefer func(orig string) { _home = orig }(_home)\n\t_home = \"\"\n\thomeOnce = &sync.Once{}\n\ttmpd := newTempDir(t)\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\tsetEnv(t, envGhqRoot, tmpd)\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\n\ttestCases := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\twant      []string\n\t\twantDir   string\n\t\terrStr    string\n\t\tsetup     func(t *testing.T)\n\t\tcmdRun    func(cmd *exec.Cmd) error\n\t\tskipOnWin bool\n\t}{{\n\t\tname:    \"simple\",\n\t\tinput:   []string{\"create\", \"motemen/ghqq\"},\n\t\twant:    []string{\"git\", \"init\"},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghqq\"),\n\t}, {\n\t\tname:  \"empty directory exists\",\n\t\tinput: []string{\"create\", \"motemen/ghqqq\"},\n\t\twant:  []string{\"git\", \"init\"},\n\t\tsetup: func(t *testing.T) {\n\t\t\tos.MkdirAll(filepath.Join(tmpd, \"github.com/motemen/ghqqq\"), 0755)\n\t\t},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghqqq\"),\n\t}, {\n\t\tname:  \"invalid VCS\",\n\t\tinput: []string{\"create\", \"example.com/goooo/gooo\"},\n\t\tcmdRun: func(cmd *exec.Cmd) error {\n\t\t\tlastCmd = cmd\n\t\t\treturn errors.New(\"bad repository\")\n\t\t},\n\t\terrStr: \"unsupported VCS\",\n\t}, {\n\t\tname:    \"Mercurial\",\n\t\tinput:   []string{\"create\", \"--vcs=hg\", \"motemen/ghq-hg\"},\n\t\twant:    []string{\"hg\", \"init\"},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghq-hg\"),\n\t}, {\n\t\tname:    \"Darcs\",\n\t\tinput:   []string{\"create\", \"--vcs=darcs\", \"motemen/ghq-darcs\"},\n\t\twant:    []string{\"darcs\", \"init\"},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghq-darcs\"),\n\t}, {\n\t\tname:    \"Pijul\",\n\t\tinput:   []string{\"create\", \"--vcs=pijul\", \"motemen/ghq-pijul\"},\n\t\twant:    []string{\"pijul\", \"init\"},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghq-pijul\"),\n\t}, {\n\t\tname:    \"Bazzar\",\n\t\tinput:   []string{\"create\", \"--vcs=bzr\", \"motemen/ghq-bzr\"},\n\t\twant:    []string{\"bzr\", \"init\"},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghq-bzr\"),\n\t}, {\n\t\tname:    \"Fossil\",\n\t\tinput:   []string{\"create\", \"--vcs=fossil\", \"motemen/ghq-fossil\"},\n\t\twant:    []string{\"fossil\", \"open\", fossilRepoName},\n\t\twantDir: filepath.Join(tmpd, \"github.com/motemen/ghq-fossil\"),\n\t}, {\n\t\tname:   \"unsupported VCS\",\n\t\tinput:  []string{\"create\", \"--vcs=svn\", \"motemen/ghq-svn\"},\n\t\terrStr: \"unsupported VCS\",\n\t}, {\n\t\tname:  \"not permitted\",\n\t\tinput: []string{\"create\", \"motemen/ghq-notpermitted\"},\n\t\tsetup: func(t *testing.T) {\n\t\t\tf := filepath.Join(tmpd, \"github.com/motemen/ghq-notpermitted\")\n\t\t\tos.MkdirAll(f, 0)\n\t\t\tt.Cleanup(func() { os.Chmod(f, 0755) })\n\t\t},\n\t\terrStr:    \"permission denied\",\n\t\tskipOnWin: true,\n\t}, {\n\t\tname:  \"not empty\",\n\t\tinput: []string{\"create\", \"motemen/ghq-notempty\"},\n\t\tsetup: func(t *testing.T) {\n\t\t\tf := filepath.Join(tmpd, \"github.com/motemen/ghq-notempty\", \"dummy\")\n\t\t\tos.MkdirAll(f, 0755)\n\t\t},\n\t\terrStr: \"already exists and not empty\",\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.skipOnWin && runtime.GOOS == \"windows\" {\n\t\t\t\tt.SkipNow()\n\t\t\t}\n\t\t\tlastCmd = nil\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(t)\n\t\t\t}\n\n\t\t\tcmdutil.CommandRunner = commandRunner\n\t\t\tif tc.cmdRun != nil {\n\t\t\t\tcmdutil.CommandRunner = tc.cmdRun\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tout, _, _ := capture(func() {\n\t\t\t\terr = newApp().Run(append([]string{\"\"}, tc.input...))\n\t\t\t})\n\t\t\tout = strings.TrimSpace(out)\n\n\t\t\tif tc.errStr == \"\" {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"err should not be nil\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif e, g := tc.errStr, err.Error(); !strings.Contains(g, e) {\n\t\t\t\t\tt.Errorf(\"err.Error() should contains %q, but not: %q\", e, g)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(tc.want) > 0 {\n\t\t\t\tif !reflect.DeepEqual(lastCmd.Args, tc.want) {\n\t\t\t\t\tt.Errorf(\"cmd.Args = %v, want: %v\", lastCmd.Args, tc.want)\n\t\t\t\t}\n\n\t\t\t\tif lastCmd.Dir != tc.wantDir {\n\t\t\t\t\tt.Errorf(\"cmd.Dir = %q, want: %q\", lastCmd.Dir, tc.wantDir)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tc.errStr == \"\" {\n\t\t\t\tif out != tc.wantDir {\n\t\t\t\t\tt.Errorf(\"cmd.Dir = %q, want: %q\", out, tc.wantDir)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif out != \"\" {\n\t\t\t\t\tt.Errorf(\"output should be empty but: %s\", out)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cmd_get.go",
          "type": "blob",
          "size": 3.87109375,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/mattn/go-isatty\"\n\t\"github.com/urfave/cli/v2\"\n\t\"github.com/x-motemen/ghq/cmdutil\"\n\t\"github.com/x-motemen/ghq/logger\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nfunc doGet(c *cli.Context) error {\n\tvar (\n\t\targs     = c.Args().Slice()\n\t\tandLook  = c.Bool(\"look\")\n\t\tparallel = c.Bool(\"parallel\")\n\t)\n\tg := &getter{\n\t\tupdate:    c.Bool(\"update\"),\n\t\tshallow:   c.Bool(\"shallow\"),\n\t\tssh:       c.Bool(\"p\"),\n\t\tvcs:       c.String(\"vcs\"),\n\t\tsilent:    c.Bool(\"silent\"),\n\t\tbranch:    c.String(\"branch\"),\n\t\trecursive: !c.Bool(\"no-recursive\"),\n\t\tbare:      c.Bool(\"bare\"),\n\t}\n\tif parallel {\n\t\t// force silent in parallel import\n\t\tg.silent = true\n\t}\n\n\tvar (\n\t\tfirstArg string // Look at the first repo only, if there are more than one\n\t\targCnt   int\n\t\tgetInfo  getInfo // For fetching and looking a single repo\n\t\tscr      scanner\n\t\terr      error\n\t)\n\tif len(args) > 0 {\n\t\tscr = &sliceScanner{slice: args}\n\t} else {\n\t\tfd := os.Stdin.Fd()\n\t\tif isatty.IsTerminal(fd) || isatty.IsCygwinTerminal(fd) {\n\t\t\treturn fmt.Errorf(\"no target args specified. see `ghq get -h` for more details\")\n\t\t}\n\t\tscr = bufio.NewScanner(os.Stdin)\n\t}\n\n\teg := &errgroup.Group{}\n\tsem := make(chan struct{}, 6)\n\tfor scr.Scan() {\n\t\ttarget := scr.Text()\n\t\tif firstArg == \"\" {\n\t\t\tfirstArg = target\n\t\t}\n\t\targCnt += 1\n\t\tif parallel {\n\t\t\tsem <- struct{}{}\n\t\t\teg.Go(func() error {\n\t\t\t\tdefer func() { <-sem }()\n\t\t\t\tif getInfo, err = g.get(target); err != nil {\n\t\t\t\t\tlogger.Logf(\"error\", \"failed to get %q: %s\", target, err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t} else {\n\t\t\tif getInfo, err = g.get(target); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to get %q: %w\", target, err)\n\t\t\t}\n\t\t}\n\t}\n\tif err = scr.Err(); err != nil {\n\t\treturn fmt.Errorf(\"error occurred while reading input: %w\", err)\n\t}\n\tif err = eg.Wait(); err != nil {\n\t\treturn err\n\t}\n\tif andLook {\n\t\tif argCnt > 1 && firstArg != \"\" {\n\t\t\treturn look(firstArg, g.bare)\n\t\t}\n\t\tif argCnt == 1 && getInfo.localRepository != nil {\n\t\t\treturn lookByLocalRepository(getInfo.localRepository)\n\t\t}\n\t}\n\treturn nil\n}\n\ntype sliceScanner struct {\n\tslice []string\n\tindex int\n}\n\nfunc (s *sliceScanner) Scan() bool {\n\ts.index++\n\treturn s.index <= len(s.slice)\n}\n\nfunc (s *sliceScanner) Text() string {\n\treturn s.slice[s.index-1]\n}\n\nfunc (s *sliceScanner) Err() error {\n\treturn nil\n}\n\ntype scanner interface {\n\tScan() bool\n\tText() string\n\tErr() error\n}\n\nfunc detectShell() string {\n\tshell := os.Getenv(\"SHELL\")\n\tif shell != \"\" {\n\t\treturn shell\n\t}\n\tif runtime.GOOS == \"windows\" {\n\t\treturn os.Getenv(\"COMSPEC\")\n\t}\n\treturn \"/bin/sh\"\n}\n\nfunc look(name string, bare bool) error {\n\tvar (\n\t\treposFound []*LocalRepository\n\t\tmu         sync.Mutex\n\t)\n\tif err := walkAllLocalRepositories(func(repo *LocalRepository) {\n\t\tif repo.Matches(name) {\n\t\t\tmu.Lock()\n\t\t\treposFound = append(reposFound, repo)\n\t\t\tmu.Unlock()\n\t\t}\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tif len(reposFound) == 0 {\n\t\tif url, err := newURL(name, false, false); err == nil {\n\t\t\trepo, err := LocalRepositoryFromURL(url, bare)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = os.Stat(repo.FullPath)\n\n\t\t\t// if the directory exists\n\t\t\tif err == nil {\n\t\t\t\treposFound = append(reposFound, repo)\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch len(reposFound) {\n\tcase 0:\n\t\treturn fmt.Errorf(\"no repository found\")\n\tcase 1:\n\t\treturn lookByLocalRepository(reposFound[0])\n\tdefault:\n\t\tb := &strings.Builder{}\n\t\tb.WriteString(\"More than one repositories are found; Try more precise name\\n\")\n\t\tfor _, repo := range reposFound {\n\t\t\tb.WriteString(fmt.Sprintf(\"       - %s\\n\", strings.Join(repo.PathParts, \"/\")))\n\t\t}\n\t\treturn errors.New(b.String())\n\t}\n}\n\nfunc lookByLocalRepository(repo *LocalRepository) error {\n\tcmd := exec.Command(detectShell())\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tcmd.Dir = repo.FullPath\n\tcmd.Env = append(os.Environ(), \"GHQ_LOOK=\"+filepath.ToSlash(repo.RelPath))\n\treturn cmdutil.RunCommand(cmd, true)\n}\n"
        },
        {
          "name": "cmd_get_test.go",
          "type": "blob",
          "size": 12.6259765625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/Songmu/gitconfig\"\n\t\"github.com/x-motemen/ghq/cmdutil\"\n\t\"github.com/x-motemen/ghq/logger\"\n)\n\nfunc TestCommandGet(t *testing.T) {\n\tapp := newApp()\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tscenario func(*testing.T, string, *_cloneArgs, *_updateArgs)\n\t}{{\n\t\tname: \"simple\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"motemen/ghq-test-repo\"})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif cloneArgs.shallow {\n\t\t\t\tt.Errorf(\"cloneArgs.shallow should be false\")\n\t\t\t}\n\t\t\tif cloneArgs.branch != \"\" {\n\t\t\t\tt.Errorf(\"cloneArgs.branch should be empty\")\n\t\t\t}\n\t\t\tif !cloneArgs.recursive {\n\t\t\t\tt.Errorf(\"cloneArgs.recursive should be true\")\n\t\t\t}\n\t\t\tif cloneArgs.bare {\n\t\t\t\tt.Errorf(\"cloneArgs.bare should be false\")\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"-p option\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"-p\", \"motemen/ghq-test-repo\"})\n\n\t\t\texpect := \"ssh://git@github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif cloneArgs.shallow {\n\t\t\t\tt.Errorf(\"cloneArgs.shallow should be false\")\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"already cloned with -update\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\t\t\t// mark as \"already cloned\", the condition may change later\n\t\t\tos.MkdirAll(filepath.Join(localDir, \".git\"), 0755)\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"-update\", \"motemen/ghq-test-repo\"})\n\n\t\t\tif updateArgs.local != localDir {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", updateArgs.local, localDir)\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"shallow\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"-shallow\", \"motemen/ghq-test-repo\"})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif !cloneArgs.shallow {\n\t\t\t\tt.Errorf(\"cloneArgs.shallow should be true\")\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"dot slash ./\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\")\n\t\t\tos.MkdirAll(localDir, 0755)\n\t\t\twd, _ := os.Getwd()\n\t\t\tos.Chdir(localDir)\n\t\t\tdefer os.Chdir(wd)\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"-update\", \".\" + string(filepath.Separator) + \"ghq-test-repo\"})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\texpectDir := filepath.Join(localDir, \"ghq-test-repo\")\n\t\t\tif cloneArgs.local != expectDir {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.local, expectDir)\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"dot dot slash ../\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\t\t\tos.MkdirAll(localDir, 0755)\n\t\t\twd, _ := os.Getwd()\n\t\t\tos.Chdir(localDir)\n\t\t\tdefer os.Chdir(wd)\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"-update\", \"..\" + string(filepath.Separator) + \"ghq-another-test-repo\"})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-another-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\texpectDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-another-test-repo\")\n\t\t\tif cloneArgs.local != expectDir {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.local, expectDir)\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"specific branch\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\n\t\t\texpectBranch := \"hello\"\n\t\t\tapp.Run([]string{\"\", \"get\", \"-shallow\", \"-branch\", expectBranch, \"motemen/ghq-test-repo\"})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif cloneArgs.branch != expectBranch {\n\t\t\t\tt.Errorf(\"got: %q, expect: %q\", cloneArgs.branch, expectBranch)\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"specific branch using @ syntax\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\n\t\t\texpectBranch := \"hello\"\n\t\t\tapp.Run([]string{\"\", \"get\", \"-shallow\", \"motemen/ghq-test-repo@\" + expectBranch})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif cloneArgs.branch != expectBranch {\n\t\t\t\tt.Errorf(\"got: %q, expect: %q\", cloneArgs.branch, expectBranch)\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"with --no-recursive option\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tapp.Run([]string{\"\", \"get\", \"--no-recursive\", \"motemen/ghq-test-repo\"})\n\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif cloneArgs.recursive {\n\t\t\t\tt.Errorf(\"cloneArgs.recursive should be false\")\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"ghq.<url>.root\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\ttmpd := newTempDir(t)\n\t\t\tt.Cleanup(gitconfig.WithConfig(t, fmt.Sprintf(`\n[ghq \"https://github.com/motemen\"]\n  root = \"%s\"\n`, filepath.ToSlash(tmpd))))\n\t\t\tapp.Run([]string{\"\", \"get\", \"motemen/ghq-test-repo\"})\n\n\t\t\tlocalDir := filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghq-test-repo\")\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t},\n\t}, {\n\t\tname: \"bare\",\n\t\tscenario: func(t *testing.T, tmpRoot string, cloneArgs *_cloneArgs, updateArgs *_updateArgs) {\n\t\t\tlocalDir := filepath.Join(tmpRoot, \"github.com\", \"motemen\", \"ghq-test-repo.git\")\n\n\t\t\tapp.Run([]string{\"\", \"get\", \"--bare\", \"motemen/ghq-test-repo\"})\n\n\t\t\texpect := \"https://github.com/motemen/ghq-test-repo\"\n\t\t\tif cloneArgs.remote.String() != expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", cloneArgs.remote, expect)\n\t\t\t}\n\t\t\tif filepath.ToSlash(cloneArgs.local) != filepath.ToSlash(localDir) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", filepath.ToSlash(cloneArgs.local), filepath.ToSlash(localDir))\n\t\t\t}\n\t\t\tif !cloneArgs.bare {\n\t\t\t\tt.Errorf(\"cloneArgs.bare should be true\")\n\t\t\t}\n\t\t},\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\twithFakeGitBackend(t, tc.scenario)\n\t\t})\n\t}\n}\n\nfunc TestLook(t *testing.T) {\n\twithFakeGitBackend(t, func(t *testing.T, tmproot string, _ *_cloneArgs, _ *_updateArgs) {\n\t\tos.MkdirAll(filepath.Join(tmproot, \"github.com\", \"motemen\", \"ghq\", \".git\"), 0755)\n\t\tos.MkdirAll(filepath.Join(tmproot, \"github.com\", \"motemen\", \"gobump\", \".git\"), 0755)\n\t\tos.MkdirAll(filepath.Join(tmproot, \"github.com\", \"Songmu\", \"gobump\", \".git\"), 0755)\n\t\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\t\tcmdutil.CommandRunner = orig\n\t\t}(cmdutil.CommandRunner)\n\t\tvar lastCmd *exec.Cmd\n\t\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t\tlastCmd = cmd\n\t\t\treturn nil\n\t\t}\n\t\tsh := detectShell()\n\n\t\terr := newApp().Run([]string{\"\", \"get\", \"--look\", \"https://github.com/motemen/ghq\"})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(lastCmd.Args, []string{sh}) {\n\t\t\tt.Errorf(\"lastCmd.Args: got: %v, expect: %v\", lastCmd.Args, []string{sh})\n\t\t}\n\t\tdir := filepath.Join(tmproot, \"github.com\", \"motemen\", \"ghq\")\n\t\tif filepath.Clean(lastCmd.Dir) != dir {\n\t\t\tt.Errorf(\"lastCmd.Dir: got: %s, expect: %s\", lastCmd.Dir, dir)\n\t\t}\n\t\tgotEnv := lastCmd.Env[len(lastCmd.Env)-1]\n\t\texpectEnv := \"GHQ_LOOK=github.com/motemen/ghq\"\n\t\tif gotEnv != expectEnv {\n\t\t\tt.Errorf(\"lastCmd.Env[len(lastCmd.Env)-1]: got: %s, expect: %s\", gotEnv, expectEnv)\n\t\t}\n\n\t\terr = look(\"github.com/motemen/_unknown\", false)\n\t\texpect := \"no repository found\"\n\t\tif !strings.HasPrefix(fmt.Sprintf(\"%s\", err), expect) {\n\t\t\tt.Errorf(\"error should has prefix %q, but: %s\", expect, err)\n\t\t}\n\n\t\terr = look(\"gobump\", false)\n\t\texpect = \"More than one repositories are found; Try more precise name\"\n\t\tif !strings.HasPrefix(fmt.Sprintf(\"%s\", err), expect) {\n\t\t\tt.Errorf(\"error should has prefix %q, but: %s\", expect, err)\n\t\t}\n\t})\n}\n\nfunc TestBareLook(t *testing.T) {\n\twithFakeGitBackend(t, func(t *testing.T, tmproot string, _ *_cloneArgs, _ *_updateArgs) {\n\t\tos.MkdirAll(filepath.Join(tmproot, \"github.com\", \"motemen\", \"ghq.git\"), 0o755)\n\t\tos.MkdirAll(filepath.Join(tmproot, \"github.com\", \"motemen\", \"gobump\", \".git\"), 0o755)\n\t\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\t\tcmdutil.CommandRunner = orig\n\t\t}(cmdutil.CommandRunner)\n\t\tvar lastCmd *exec.Cmd\n\t\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t\tlastCmd = cmd\n\t\t\treturn nil\n\t\t}\n\t\tsh := detectShell()\n\n\t\terr := newApp().Run([]string{\"\", \"get\", \"--bare\", \"--look\", \"https://github.com/motemen/ghq.git\"})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(lastCmd.Args, []string{sh}) {\n\t\t\tt.Errorf(\"lastCmd.Args: got: %v, expect: %v\", lastCmd.Args, []string{sh})\n\t\t}\n\t\tdir := filepath.Join(tmproot, \"github.com\", \"motemen\", \"ghq.git\")\n\t\tif filepath.Clean(lastCmd.Dir) != dir {\n\t\t\tt.Errorf(\"lastCmd.Dir: got: %s, expect: %s\", lastCmd.Dir, dir)\n\t\t}\n\t\tgotEnv := lastCmd.Env[len(lastCmd.Env)-1]\n\t\texpectEnv := \"GHQ_LOOK=github.com/motemen/ghq.git\"\n\t\tif gotEnv != expectEnv {\n\t\t\tt.Errorf(\"lastCmd.Env[len(lastCmd.Env)-1]: got: %s, expect: %s\", gotEnv, expectEnv)\n\t\t}\n\n\t\terr = look(\"github.com/motemen/ghq\", false)\n\t\texpect := \"no repository found\"\n\t\tif !strings.HasPrefix(fmt.Sprintf(\"%s\", err), expect) {\n\t\t\tt.Errorf(\"error should has prefix %q, but: %s\", expect, err)\n\t\t}\n\n\t\terr = look(\"github.com/motemen/gobump.git\", true)\n\t\texpect = \"no repository found\"\n\t\tif !strings.HasPrefix(fmt.Sprintf(\"%s\", err), expect) {\n\t\t\tt.Errorf(\"error should has prefix %q, but: %s\", expect, err)\n\t\t}\n\t})\n}\n\nfunc TestDoGet_bulk(t *testing.T) {\n\tin := []string{\n\t\t\"github.com/x-motemen/ghq\",\n\t\t\"github.com/motemen/gore\",\n\t}\n\n\ttestCases := []struct {\n\t\tname string\n\t\targs []string\n\t}{{\n\t\tname: \"normal\",\n\t\targs: []string{},\n\t}, {\n\t\tname: \"parallel\",\n\t\targs: []string{\"-parallel\"},\n\t}}\n\n\tbuf := &bytes.Buffer{}\n\tlogger.SetOutput(buf)\n\tdefer func() { logger.SetOutput(os.Stderr) }()\n\n\twithFakeGitBackend(t, func(t *testing.T, tmproot string, _ *_cloneArgs, _ *_updateArgs) {\n\t\tfor _, r := range in {\n\t\t\tos.MkdirAll(filepath.Join(tmproot, r, \".git\"), 0755)\n\t\t}\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\tbuf.Reset()\n\t\t\t\tout, _, err := captureWithInput(in, func() {\n\t\t\t\t\targs := append([]string{\"\", \"get\"}, tc.args...)\n\t\t\t\t\tif err := newApp().Run(args); err != nil {\n\t\t\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t\t\t}\n\t\t\t\tif out != \"\" {\n\t\t\t\t\tt.Errorf(\"out should be empty, but: %s\", out)\n\t\t\t\t}\n\t\t\t\tlog := filepath.ToSlash(buf.String())\n\t\t\t\tfor _, r := range in {\n\t\t\t\t\tif !strings.Contains(log, r) {\n\t\t\t\t\t\tt.Errorf(\"log should contains %q but not: %s\", r, log)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "cmd_list.go",
          "type": "blob",
          "size": 2.82421875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc doList(c *cli.Context) error {\n\tvar (\n\t\tw                = c.App.Writer\n\t\tquery            = c.Args().First()\n\t\texact            = c.Bool(\"exact\")\n\t\tvcsBackend       = c.String(\"vcs\")\n\t\tprintFullPaths   = c.Bool(\"full-path\")\n\t\tprintUniquePaths = c.Bool(\"unique\")\n\t\tbare             = c.Bool(\"bare\")\n\t)\n\n\tfilterByQuery := func(_ *LocalRepository) bool {\n\t\treturn true\n\t}\n\tif query != \"\" {\n\t\tif hasSchemePattern.MatchString(query) || scpLikeURLPattern.MatchString(query) {\n\t\t\tif url, err := newURL(query, false, false); err == nil {\n\t\t\t\tif repo, err := LocalRepositoryFromURL(url, bare); err == nil {\n\t\t\t\t\tquery = filepath.ToSlash(repo.RelPath)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif exact {\n\t\t\tfilterByQuery = func(repo *LocalRepository) bool {\n\t\t\t\treturn repo.Matches(query)\n\t\t\t}\n\t\t} else {\n\t\t\tvar host string\n\t\t\tpaths := strings.Split(query, \"/\")\n\t\t\tif len(paths) > 1 && looksLikeAuthorityPattern.MatchString(paths[0]) {\n\t\t\t\tquery = strings.Join(paths[1:], \"/\")\n\t\t\t\thost = paths[0]\n\t\t\t}\n\t\t\t// Using smartcase searching\n\t\t\tif strings.ToLower(query) == query {\n\t\t\t\tfilterByQuery = func(repo *LocalRepository) bool {\n\t\t\t\t\treturn strings.Contains(strings.ToLower(repo.NonHostPath()), query) &&\n\t\t\t\t\t\t(host == \"\" || repo.PathParts[0] == host)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfilterByQuery = func(repo *LocalRepository) bool {\n\t\t\t\t\treturn strings.Contains(repo.NonHostPath(), query) &&\n\t\t\t\t\t\t(host == \"\" || repo.PathParts[0] == host)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar (\n\t\trepos []*LocalRepository\n\t\tmu    sync.Mutex\n\t)\n\tif err := walkLocalRepositories(vcsBackend, func(repo *LocalRepository) {\n\t\tif !filterByQuery(repo) {\n\t\t\treturn\n\t\t}\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\trepos = append(repos, repo)\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"failed to filter repos while walkLocalRepositories(repo): %w\", err)\n\t}\n\n\trepoList := make([]string, 0, len(repos))\n\tif printUniquePaths {\n\t\tsubpathCount := map[string]int{} // Count duplicated subpaths (ex. foo/dotfiles and bar/dotfiles)\n\t\treposCount := map[string]int{}   // Check duplicated repositories among roots\n\n\t\t// Primary first\n\t\tfor _, repo := range repos {\n\t\t\tif reposCount[repo.RelPath] == 0 {\n\t\t\t\tfor _, p := range repo.Subpaths() {\n\t\t\t\t\tsubpathCount[p] = subpathCount[p] + 1\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treposCount[repo.RelPath] = reposCount[repo.RelPath] + 1\n\t\t}\n\n\t\tfor _, repo := range repos {\n\t\t\tif reposCount[repo.RelPath] > 1 && !repo.IsUnderPrimaryRoot() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, p := range repo.Subpaths() {\n\t\t\t\tif subpathCount[p] == 1 {\n\t\t\t\t\trepoList = append(repoList, p)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, repo := range repos {\n\t\t\tif printFullPaths {\n\t\t\t\trepoList = append(repoList, repo.FullPath)\n\t\t\t} else {\n\t\t\t\trepoList = append(repoList, repo.RelPath)\n\t\t\t}\n\t\t}\n\t}\n\tsort.Strings(repoList)\n\tfor _, r := range repoList {\n\t\tfmt.Fprintln(w, r)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "cmd_list_test.go",
          "type": "blob",
          "size": 6.2822265625,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc flagSet(name string, flags []cli.Flag) *flag.FlagSet {\n\tset := flag.NewFlagSet(name, flag.ContinueOnError)\n\n\tfor _, f := range flags {\n\t\tf.Apply(set)\n\t}\n\treturn set\n}\n\nfunc TestCommandList(t *testing.T) {\n\t_, _, err := capture(func() {\n\t\tapp := cli.NewApp()\n\t\tflagSet := flagSet(\"list\", commandList.Flags)\n\t\tc := cli.NewContext(app, flagSet, nil)\n\n\t\tdoList(c)\n\t})\n\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil, but: %v\", err)\n\t}\n}\n\nfunc TestCommandListUnique(t *testing.T) {\n\t_, _, err := capture(func() {\n\t\tapp := cli.NewApp()\n\t\tflagSet := flagSet(\"list\", commandList.Flags)\n\t\tflagSet.Parse([]string{\"--unique\"})\n\t\tc := cli.NewContext(app, flagSet, nil)\n\n\t\tdoList(c)\n\t})\n\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil, but: %v\", err)\n\t}\n}\n\nfunc TestCommandListUnknown(t *testing.T) {\n\t_, _, err := capture(func() {\n\t\tapp := cli.NewApp()\n\t\tflagSet := flagSet(\"list\", commandList.Flags)\n\t\tflagSet.Parse([]string{\"--unknown-flag\"})\n\t\tc := cli.NewContext(app, flagSet, nil)\n\n\t\tdoList(c)\n\t})\n\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil, but: %v\", err)\n\t}\n}\n\nfunc sortLines(s string) string {\n\tss := strings.Split(strings.TrimSpace(s), \"\\n\")\n\tsort.Strings(ss)\n\treturn strings.Join(ss, \"\\n\")\n}\n\nfunc equalPathLines(lhs, rhs string) bool {\n\treturn sortLines(lhs) == sortLines(rhs)\n}\n\nfunc TestDoList_query(t *testing.T) {\n\tgitRepos := []string{\n\t\t\"github.com/motemen/ghq\",\n\t\t\"github.com/motemen/gobump\",\n\t\t\"github.com/motemen/gore\",\n\t\t\"github.com/Songmu/gobump\",\n\t\t\"github.com/test/Awesome\",\n\t\t\"golang.org/x/crypt\",\n\t\t\"golang.org/x/image\",\n\t}\n\tsvnRepos := []string{\n\t\t\"github.com/msh5/svntest\",\n\t}\n\ttestCases := []struct {\n\t\tname   string\n\t\targs   []string\n\t\texpect string\n\t}{{\n\t\tname:   \"repo match\",\n\t\targs:   []string{\"ghq\"},\n\t\texpect: \"github.com/motemen/ghq\\n\",\n\t}, {\n\t\tname:   \"unique\",\n\t\targs:   []string{\"--unique\", \"ghq\"},\n\t\texpect: \"ghq\\n\",\n\t}, {\n\t\tname:   \"host only doesn't match\",\n\t\targs:   []string{\"github.com\"},\n\t\texpect: \"\",\n\t}, {\n\t\tname:   \"host and slash match\",\n\t\targs:   []string{\"golang.org/\"},\n\t\texpect: \"golang.org/x/crypt\\ngolang.org/x/image\\n\",\n\t}, {\n\t\tname:   \"host and user\",\n\t\targs:   []string{\"github.com/Songmu\"},\n\t\texpect: \"github.com/Songmu/gobump\\n\",\n\t}, {\n\t\tname:   \"with scheme\",\n\t\targs:   []string{\"https://github.com/motemen/ghq\"},\n\t\texpect: \"github.com/motemen/ghq\\n\",\n\t}, {\n\t\tname:   \"exact\",\n\t\targs:   []string{\"-exact\", \"gobump\"},\n\t\texpect: \"github.com/Songmu/gobump\\ngithub.com/motemen/gobump\\n\",\n\t}, {\n\t\tname:   \"query\",\n\t\targs:   []string{\"men/go\"},\n\t\texpect: \"github.com/motemen/gobump\\ngithub.com/motemen/gore\\n\",\n\t}, {\n\t\tname:   \"exact query\",\n\t\targs:   []string{\"-exact\", \"men/go\"},\n\t\texpect: \"\",\n\t}, {\n\t\tname:   \"vcs\",\n\t\targs:   []string{\"--vcs\", \"svn\"},\n\t\texpect: \"github.com/msh5/svntest\\n\",\n\t}, {\n\t\tname:   \"smartcasing fuzzy\",\n\t\targs:   []string{\"awesome\"},\n\t\texpect: \"github.com/test/Awesome\\n\",\n\t}, {\n\t\tname:   \"smartcasing exact\",\n\t\targs:   []string{\"Awesome\"},\n\t\texpect: \"github.com/test/Awesome\\n\",\n\t}, {\n\t\tname:   \"smartcasing exact fail\",\n\t\targs:   []string{\"aWesome\"},\n\t\texpect: \"\",\n\t}}\n\n\twithFakeGitBackend(t, func(t *testing.T, tmproot string, _ *_cloneArgs, _ *_updateArgs) {\n\t\tfor _, r := range gitRepos {\n\t\t\tos.MkdirAll(filepath.Join(tmproot, r, \".git\"), 0755)\n\t\t}\n\t\tfor _, r := range svnRepos {\n\t\t\tos.MkdirAll(filepath.Join(tmproot, r, \".svn\"), 0755)\n\t\t}\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\targs := append([]string{\"ghq\", \"list\"}, tc.args...)\n\t\t\t\tout, _, _ := capture(func() {\n\t\t\t\t\tnewApp().Run(args)\n\t\t\t\t})\n\t\t\t\tif !equalPathLines(out, tc.expect) {\n\t\t\t\t\tt.Errorf(\"got:\\n%s\\nexpect:\\n%s\", out, tc.expect)\n\t\t\t\t}\n\t\t\t\tif strings.Contains(tc.name, \"unique\") {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\targsFull := append([]string{\"ghq\", \"list\", \"--full-path\"}, tc.args...)\n\t\t\t\tfullExpect := tc.expect\n\t\t\t\tif fullExpect != \"\" {\n\t\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\t\tfullExpect = strings.ReplaceAll(fullExpect, `/`, `\\`)\n\t\t\t\t\t}\n\t\t\t\t\tfullExpect = tmproot + string(filepath.Separator) + strings.TrimSpace(fullExpect)\n\t\t\t\t\tfullExpect = strings.ReplaceAll(fullExpect, \"\\n\", \"\\n\"+tmproot+string(filepath.Separator))\n\t\t\t\t\tfullExpect += \"\\n\"\n\t\t\t\t}\n\t\t\t\tout, _, _ = capture(func() {\n\t\t\t\t\tnewApp().Run(argsFull)\n\t\t\t\t})\n\t\t\t\tif !equalPathLines(out, fullExpect) {\n\t\t\t\t\tt.Errorf(\"got:\\n%s\\nexpect:\\n%s\", out, fullExpect)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestDoList_unique(t *testing.T) {\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\n\ttmp1 := newTempDir(t)\n\ttmp2 := newTempDir(t)\n\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\trootPaths := []string{tmp1, tmp2}\n\tsetEnv(t, envGhqRoot, strings.Join(rootPaths, string(os.PathListSeparator)))\n\tfor _, rootPath := range rootPaths {\n\t\tos.MkdirAll(filepath.Join(rootPath, \"github.com/motemen/ghq/.git\"), 0755)\n\t}\n\tout, _, _ := capture(func() {\n\t\tnewApp().Run([]string{\"ghq\", \"list\", \"--unique\"})\n\t})\n\tif out != \"ghq\\n\" {\n\t\tt.Errorf(\"got: %s, expect: ghq\\n\", out)\n\t}\n}\n\nfunc TestDoList_unknownRoot(t *testing.T) {\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\tsetEnv(t, envGhqRoot, \"/path/to/unknown-ghq\")\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\n\terr := newApp().Run([]string{\"ghq\", \"list\"})\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil, but: %v\", err)\n\t}\n}\n\nfunc TestDoList_notPermittedRoot(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.SkipNow()\n\t}\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\ttmpdir := newTempDir(t)\n\tdefer os.Chmod(tmpdir, 0755)\n\tsetEnv(t, envGhqRoot, tmpdir)\n\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\tos.Chmod(tmpdir, 0000)\n\n\terr := newApp().Run([]string{\"ghq\", \"list\"})\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil, but: %+v\", err)\n\t}\n}\n\nfunc TestDoList_withSystemHiddenDir(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.SkipNow()\n\t}\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\ttmpdir := newTempDir(t)\n\tsystemHidden := filepath.Join(tmpdir, \".system\")\n\tos.MkdirAll(systemHidden, 0000)\n\tdefer os.Chmod(systemHidden, 0755)\n\tsetEnv(t, envGhqRoot, tmpdir)\n\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\n\terr := newApp().Run([]string{\"ghq\", \"list\"})\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil, but: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "cmd_rm.go",
          "type": "blob",
          "size": 1.091796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc doRm(c *cli.Context) error {\n\tvar (\n\t\tname = c.Args().First()\n\t\tdry  = c.Bool(\"dry-run\")\n\t\tw    = c.App.Writer\n\t\tbare = c.Bool(\"bare\")\n\t)\n\n\tif name == \"\" {\n\t\treturn fmt.Errorf(\"repository name is required\")\n\t}\n\n\tu, err := newURL(name, false, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlocalRepo, err := LocalRepositoryFromURL(u, bare)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp := localRepo.FullPath\n\tok, err := isNotExistOrEmpty(p)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ok {\n\t\treturn fmt.Errorf(\"directory %q does not exist\", p)\n\t}\n\n\tif dry {\n\t\tfmt.Fprintf(w, \"Would remove %s\\n\", p)\n\t\treturn nil\n\t}\n\n\tok, err = confirm(fmt.Sprintf(\"Remove %s?\", p))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !ok {\n\t\treturn fmt.Errorf(\"aborted\")\n\t}\n\n\tif err := os.RemoveAll(p); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(w, \"Removed %s\\n\", p)\n\treturn nil\n}\n\nfunc confirm(message string) (bool, error) {\n\tfmt.Fprintf(os.Stderr, \"%s [y/N]: \", message)\n\tvar response string\n\tif _, err := fmt.Scanln(&response); err != nil {\n\t\treturn false, err\n\t}\n\treturn response == \"y\", nil\n}\n"
        },
        {
          "name": "cmd_rm_test.go",
          "type": "blob",
          "size": 3.75,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/x-motemen/ghq/cmdutil\"\n)\n\nfunc TestRmCommand(t *testing.T) {\n\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\tcmdutil.CommandRunner = orig\n\t}(cmdutil.CommandRunner)\n\tcommandRunner := func(cmd *exec.Cmd) error {\n\t\treturn nil\n\t}\n\tdefer func(orig string) { _home = orig }(_home)\n\t_home = \"\"\n\thomeOnce = &sync.Once{}\n\ttmpd := newTempDir(t)\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\tsetEnv(t, envGhqRoot, tmpd)\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\n\ttestCases := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\tsetup     func(t *testing.T)\n\t\texpectErr bool\n\t\tcmdRun    func(cmd *exec.Cmd) error\n\t\tskipOnWin bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tinput: []string{\"rm\", \"motemen/ghqq\"},\n\t\t\tsetup: func(t *testing.T) {\n\t\t\t\tos.MkdirAll(filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghqq\"), 0755)\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty directory\",\n\t\t\tinput:     []string{\"rm\", \"motemen/ghqqq\"},\n\t\t\tsetup:     func(t *testing.T) {},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"incorrect repository name\",\n\t\t\tinput: []string{\"rm\", \"example.com/goooo/gooo\"},\n\t\t\tsetup: func(t *testing.T) {\n\t\t\t\tos.MkdirAll(filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghqq\"), 0755)\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"permission denied\",\n\t\t\tinput: []string{\"rm\", \"motemen/ghqq\"},\n\t\t\tsetup: func(t *testing.T) {\n\t\t\t\tf := filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghqq\")\n\t\t\t\tos.MkdirAll(f, 0000)\n\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\tos.Chmod(f, 0755)\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.skipOnWin && runtime.GOOS == \"windows\" {\n\t\t\t\tt.SkipNow()\n\t\t\t}\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(t)\n\t\t\t}\n\n\t\t\tcmdutil.CommandRunner = commandRunner\n\t\t\tif tc.cmdRun != nil {\n\t\t\t\tcmdutil.CommandRunner = tc.cmdRun\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRmDryRunCommand(t *testing.T) {\n\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\tcmdutil.CommandRunner = orig\n\t}(cmdutil.CommandRunner)\n\tcommandRunner := func(cmd *exec.Cmd) error {\n\t\treturn nil\n\t}\n\tdefer func(orig string) { _home = orig }(_home)\n\t_home = \"\"\n\thomeOnce = &sync.Once{}\n\ttmpd := newTempDir(t)\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\tsetEnv(t, envGhqRoot, tmpd)\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\n\ttestCases := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\tsetup     func(t *testing.T)\n\t\texpectErr bool\n\t\tcmdRun    func(cmd *exec.Cmd) error\n\t\tskipOnWin bool\n\t}{\n\t\t{\n\t\t\tname:  \"simple\",\n\t\t\tinput: []string{\"rm\", \"--dry-run\", \"motemen/ghqq\"},\n\t\t\tsetup: func(t *testing.T) {\n\t\t\t\tos.MkdirAll(filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghqq\"), 0755)\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"empty directory\",\n\t\t\tinput:     []string{\"rm\", \"--dry-run\", \"motemen/ghqqq\"},\n\t\t\tsetup:     func(t *testing.T) {},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"incorrect repository name\",\n\t\t\tinput: []string{\"rm\", \"--dry-run\", \"example.com/goooo/gooo\"},\n\t\t\tsetup: func(t *testing.T) {\n\t\t\t\tos.MkdirAll(filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghqq\"), 0755)\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"permission denied\",\n\t\t\tinput: []string{\"rm\", \"--dry-run\", \"motemen/ghqq\"},\n\t\t\tsetup: func(t *testing.T) {\n\t\t\t\tf := filepath.Join(tmpd, \"github.com\", \"motemen\", \"ghqq\")\n\t\t\t\tos.MkdirAll(f, 0000)\n\t\t\t\tt.Cleanup(func() {\n\t\t\t\t\tos.Chmod(f, 0755)\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.skipOnWin && runtime.GOOS == \"windows\" {\n\t\t\t\tt.SkipNow()\n\t\t\t}\n\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(t)\n\t\t\t}\n\n\t\t\tcmdutil.CommandRunner = commandRunner\n\t\t\tif tc.cmdRun != nil {\n\t\t\t\tcmdutil.CommandRunner = tc.cmdRun\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cmd_root.go",
          "type": "blob",
          "size": 0.37109375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc doRoot(c *cli.Context) error {\n\troots, err := localRepositoryRoots(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !c.Bool(\"all\") {\n\t\troots = roots[:1] // only the first root is needed\n\t}\n\n\tfor _, root := range roots {\n\t\t_, err := fmt.Fprintln(c.App.Writer, root)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "cmd_root_test.go",
          "type": "blob",
          "size": 2.86328125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/Songmu/gitconfig\"\n)\n\nfunc samePaths(lhs, rhs string) bool {\n\tif runtime.GOOS != \"windows\" {\n\t\treturn lhs == rhs\n\t}\n\tlhss := strings.Split(lhs, \"\\n\")\n\trhss := strings.Split(rhs, \"\\n\")\n\treturn samePathSlice(lhss, rhss)\n}\n\nfunc TestDoRoot(t *testing.T) {\n\ttestCases := []struct {\n\t\tname              string\n\t\tsetup             func(t *testing.T)\n\t\texpect, allExpect string\n\t\tskipOnWin         bool\n\t}{{\n\t\tname: \"env\",\n\t\tsetup: func(t *testing.T) {\n\t\t\tsetEnv(t, envGhqRoot, \"/path/to/ghqroot1\"+string(os.PathListSeparator)+\"/path/to/ghqroot2\")\n\t\t},\n\t\texpect:    \"/path/to/ghqroot1\\n\",\n\t\tallExpect: \"/path/to/ghqroot1\\n/path/to/ghqroot2\\n\",\n\t}, {\n\t\tname: \"gitconfig\",\n\t\tsetup: func(t *testing.T) {\n\t\t\tsetEnv(t, envGhqRoot, \"\")\n\t\t\tt.Cleanup(gitconfig.WithConfig(t, `\n[ghq]\n  root = /path/to/ghqroot12\n  root = /path/to/ghqroot12\n  root = /path/to/ghqroot11\n`))\n\t\t},\n\t\texpect:    \"/path/to/ghqroot11\\n\",\n\t\tallExpect: \"/path/to/ghqroot11\\n/path/to/ghqroot12\\n\",\n\t\t/*\n\t\t\tIf your gitconfig contains a path to the start of slash, and you get it with `git config --type=path`,\n\t\t\tthe behavior on Windows is strange. Specifically, on Windows with GitHub Actions, a Git\n\t\t\tinstallation path such as \"C:/Program Files/Git/mingw64\" is appended immediately before the path.\n\t\t\tThis has been addressed in the following issue, which seems to have been resolved in the v2.34.0\n\t\t\trelease.\n\t\t\t    https://github.com/git-for-windows/git/pull/3472\n\t\t\tHowever, Git on GitHub Actions is v2.39.2 at the time of this comment, and this problem continues\n\t\t\tto occur. I'm not sure, so I'll skip the test for now.\n\t\t*/\n\t\tskipOnWin: true,\n\t}, {\n\t\tname: \"default home\",\n\t\tsetup: func(t *testing.T) {\n\t\t\ttmpd := newTempDir(t)\n\t\t\tfpath := filepath.Join(tmpd, \"unknown-ghq-dummy\")\n\t\t\tf, err := os.Create(fpath)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tf.Close()\n\n\t\t\tsetEnv(t, envGhqRoot, \"\")\n\t\t\tsetEnv(t, \"GIT_CONFIG\", fpath)\n\t\t\tsetEnv(t, \"HOME\", \"/path/to/ghqhome\")\n\t\t\tsetEnv(t, \"USERPROFILE\", \"/path/to/ghqhome\")\n\t\t},\n\t\texpect:    \"/path/to/ghqhome/ghq\\n\",\n\t\tallExpect: \"/path/to/ghqhome/ghq\\n\",\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.skipOnWin && runtime.GOOS == \"windows\" {\n\t\t\t\tt.SkipNow()\n\t\t\t}\n\t\t\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\t\t\t_localRepositoryRoots = nil\n\t\t\tlocalRepoOnce = &sync.Once{}\n\t\t\tdefer func(orig string) { _home = orig }(_home)\n\t\t\t_home = \"\"\n\t\t\thomeOnce = &sync.Once{}\n\t\t\ttc.setup(t)\n\t\t\tout, _, _ := capture(func() {\n\t\t\t\tnewApp().Run([]string{\"\", \"root\"})\n\t\t\t})\n\t\t\tif !samePaths(out, tc.expect) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", out, tc.expect)\n\t\t\t}\n\t\t\tout, _, _ = capture(func() {\n\t\t\t\tnewApp().Run([]string{\"\", \"root\", \"--all\"})\n\t\t\t})\n\t\t\tif !samePaths(out, tc.allExpect) {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", out, tc.allExpect)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cmdutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.03515625,
          "content": "comment: false\ngithub_checks: false\n"
        },
        {
          "name": "commands.go",
          "type": "blob",
          "size": 4.2666015625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nvar commands = []*cli.Command{\n\tcommandGet,\n\tcommandList,\n\tcommandRm,\n\tcommandRoot,\n\tcommandCreate,\n}\n\nvar commandGet = &cli.Command{\n\tName:    \"get\",\n\tAliases: []string{\"clone\"},\n\tUsage:   \"Clone/sync with a remote repository\",\n\tDescription: `\n    Clone a repository under ghq root directory. If the repository is\n    already cloned to local, nothing will happen unless '-u' ('--update')\n    flag is supplied, in which case 'git remote update' is executed.\n    When you use '-p' option, the repository is cloned via SSH.`,\n\tAction: doGet,\n\tFlags: []cli.Flag{\n\t\t&cli.BoolFlag{Name: \"update\", Aliases: []string{\"u\"},\n\t\t\tUsage: \"Update local repository if cloned already\"},\n\t\t&cli.BoolFlag{Name: \"p\", Usage: \"Clone with SSH\"},\n\t\t&cli.BoolFlag{Name: \"shallow\", Usage: \"Do a shallow clone\"},\n\t\t&cli.BoolFlag{Name: \"look\", Aliases: []string{\"l\"}, Usage: \"Look after get\"},\n\t\t&cli.StringFlag{Name: \"vcs\", Usage: \"Specify `vcs` backend for cloning\"},\n\t\t&cli.BoolFlag{Name: \"silent\", Aliases: []string{\"s\"}, Usage: \"clone or update silently\"},\n\t\t&cli.BoolFlag{Name: \"no-recursive\", Usage: \"prevent recursive fetching\"},\n\t\t&cli.StringFlag{Name: \"branch\", Aliases: []string{\"b\"},\n\t\t\tUsage: \"Specify `branch` name. This flag implies --single-branch on Git\"},\n\t\t&cli.BoolFlag{Name: \"parallel\", Aliases: []string{\"P\"}, Usage: \"Import parallelly\"},\n\t\t&cli.BoolFlag{Name: \"bare\", Usage: \"Do a bare clone\"},\n\t},\n}\n\nvar commandList = &cli.Command{\n\tName:  \"list\",\n\tUsage: \"List local repositories\",\n\tDescription: `\n    List locally cloned repositories. If a query argument is given, only\n    repositories whose names contain that query text are listed.\n    '-e' ('--exact') forces the match to be an exact one (i.e. the query equals to\n    project or user/project) If '-p' ('--full-path') is given, the full paths\n    to the repository root are printed instead of relative ones.`,\n\tAction: doList,\n\tFlags: []cli.Flag{\n\t\t&cli.BoolFlag{Name: \"exact\", Aliases: []string{\"e\"}, Usage: \"Perform an exact match\"},\n\t\t&cli.StringFlag{Name: \"vcs\", Usage: \"Specify `vcs` backend for matching\"},\n\t\t&cli.BoolFlag{Name: \"full-path\", Aliases: []string{\"p\"}, Usage: \"Print full paths\"},\n\t\t&cli.BoolFlag{Name: \"unique\", Usage: \"Print unique subpaths\"},\n\t\t&cli.BoolFlag{Name: \"bare\", Usage: \"Query bare repositories\"},\n\t},\n}\n\nvar commandRm = &cli.Command{\n\tName:   \"rm\",\n\tUsage:  \"Remove local repository\",\n\tAction: doRm,\n\tFlags: []cli.Flag{\n\t\t&cli.BoolFlag{Name: \"dry-run\", Usage: \"Do not remove actually\"},\n\t},\n}\n\nvar commandRoot = &cli.Command{\n\tName:   \"root\",\n\tUsage:  \"Show repositories' root\",\n\tAction: doRoot,\n\tFlags: []cli.Flag{\n\t\t&cli.BoolFlag{Name: \"all\", Usage: \"Show all roots\"},\n\t},\n}\n\nvar commandCreate = &cli.Command{\n\tName:   \"create\",\n\tUsage:  \"Create a new repository\",\n\tAction: doCreate,\n\tFlags: []cli.Flag{\n\t\t&cli.StringFlag{Name: \"vcs\", Usage: \"Specify `vcs` backend explicitly\"},\n\t\t&cli.BoolFlag{Name: \"bare\", Usage: \"Create a bare repository\"},\n\t},\n}\n\ntype commandDoc struct {\n\tParent    string\n\tArguments string\n}\n\nvar commandDocs = map[string]commandDoc{\n\t\"get\":    {\"\", \"[-u] [-p] [--shallow] [--vcs <vcs>] [--look] [--silent] [--branch <branch>] [--no-recursive] [--bare] <repository URL>|<project>|<user>/<project>|<host>/<user>/<project>\"},\n\t\"list\":   {\"\", \"[-p] [-e] [<query>]\"},\n\t\"create\": {\"\", \"<project>|<user>/<project>|<host>/<user>/<project>\"},\n\t\"rm\":     {\"\", \"<project>|<user>/<project>|<host>/<user>/<project>\"},\n\t\"root\":   {\"\", \"[-all]\"},\n}\n\n// Makes template conditionals to generate per-command documents.\nfunc mkCommandsTemplate(genTemplate func(commandDoc) string) string {\n\ttemplate := \"{{if false}}\"\n\tfor _, command := range commands {\n\t\ttemplate = template + fmt.Sprintf(\"{{else if (eq .Name %q)}}%s\", command.Name, genTemplate(commandDocs[command.Name]))\n\t}\n\treturn template + \"{{end}}\"\n}\n\nfunc init() {\n\targsTemplate := mkCommandsTemplate(func(doc commandDoc) string { return doc.Arguments })\n\tparentTemplate := mkCommandsTemplate(func(doc commandDoc) string { return strings.TrimLeft(doc.Parent+\" \", \" \") })\n\n\tcli.CommandHelpTemplate = `NAME:\n    {{.Name}} - {{.Usage}}\n\nUSAGE:\n    ghq ` + parentTemplate + `{{.Name}} ` + argsTemplate + `\n{{if (len .Description)}}\nDESCRIPTION: {{.Description}}\n{{end}}{{if (len .Flags)}}\nOPTIONS:\n    {{range .Flags}}{{.}}\n    {{end}}\n{{end}}`\n}\n"
        },
        {
          "name": "commands_test.go",
          "type": "blob",
          "size": 1.26171875,
          "content": "package main\n\nimport (\n\t\"net/url\"\n\t\"path/filepath\"\n\t\"sync\"\n\t\"testing\"\n)\n\ntype _cloneArgs struct {\n\tremote    *url.URL\n\tlocal     string\n\tshallow   bool\n\tbranch    string\n\trecursive bool\n\tbare      bool\n}\n\ntype _updateArgs struct {\n\tlocal string\n}\n\nfunc withFakeGitBackend(t *testing.T, block func(*testing.T, string, *_cloneArgs, *_updateArgs)) {\n\ttmpRoot := newTempDir(t)\n\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\t_localRepositoryRoots = []string{tmpRoot}\n\n\tvar cloneArgs _cloneArgs\n\tvar updateArgs _updateArgs\n\n\tvar originalGitBackend = GitBackend\n\ttmpBackend := &VCSBackend{\n\t\tClone: func(vg *vcsGetOption) error {\n\t\t\tcloneArgs = _cloneArgs{\n\t\t\t\tremote:    vg.url,\n\t\t\t\tlocal:     filepath.FromSlash(vg.dir),\n\t\t\t\tshallow:   vg.shallow,\n\t\t\t\tbranch:    vg.branch,\n\t\t\t\trecursive: vg.recursive,\n\t\t\t\tbare:      vg.bare,\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tUpdate: func(vg *vcsGetOption) error {\n\t\t\tupdateArgs = _updateArgs{\n\t\t\t\tlocal: vg.dir,\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\tdefer func(orig string) { _home = orig }(_home)\n\t_home = \"\"\n\thomeOnce = &sync.Once{}\n\n\tGitBackend = tmpBackend\n\tvcsContentsMap[\".git\"] = tmpBackend\n\tdefer func() { GitBackend = originalGitBackend; vcsContentsMap[\".git\"] = originalGitBackend }()\n\tblock(t, tmpRoot, &cloneArgs, &updateArgs)\n}\n"
        },
        {
          "name": "getter.go",
          "type": "blob",
          "size": 3.6572265625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/x-motemen/ghq/logger\"\n)\n\nvar seen sync.Map\n\nfunc getRepoLock(localRepoRoot string) bool {\n\t_, loaded := seen.LoadOrStore(localRepoRoot, struct{}{})\n\treturn !loaded\n}\n\ntype getInfo struct {\n\tlocalRepository *LocalRepository\n}\n\ntype getter struct {\n\tupdate, shallow, silent, ssh, recursive, bare bool\n\tvcs, branch                                   string\n}\n\nfunc (g *getter) get(argURL string) (getInfo, error) {\n\tu, err := newURL(argURL, g.ssh, false)\n\tif err != nil {\n\t\treturn getInfo{}, fmt.Errorf(\"could not parse URL %q: %w\", argURL, err)\n\t}\n\tbranch := g.branch\n\tif pos := strings.LastIndexByte(u.Path, '@'); pos >= 0 {\n\t\tu.Path, branch = u.Path[:pos], u.Path[pos+1:]\n\t}\n\tremote, err := NewRemoteRepository(u)\n\tif err != nil {\n\t\treturn getInfo{}, err\n\t}\n\n\treturn g.getRemoteRepository(remote, branch)\n}\n\n// getRemoteRepository clones or updates a remote repository remote.\n// If doUpdate is true, updates the locally cloned repository. Otherwise does nothing.\n// If isShallow is true, does shallow cloning. (no effect if already cloned or the VCS is Mercurial and git-svn)\nfunc (g *getter) getRemoteRepository(remote RemoteRepository, branch string) (getInfo, error) {\n\tremoteURL := remote.URL()\n\tlocal, err := LocalRepositoryFromURL(remoteURL, g.bare)\n\tif err != nil {\n\t\treturn getInfo{}, err\n\t}\n\tinfo := getInfo{\n\t\tlocalRepository: local,\n\t}\n\n\tvar (\n\t\tfpath   = local.FullPath\n\t\tnewPath = false\n\t)\n\n\t_, err = os.Stat(fpath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tnewPath = true\n\t\t\terr = nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn getInfo{}, err\n\t\t}\n\t}\n\n\tswitch {\n\tcase newPath:\n\t\tif remoteURL.Scheme == \"codecommit\" {\n\t\t\tlogger.Log(\"clone\", fmt.Sprintf(\"%s -> %s\", remoteURL.Opaque, fpath))\n\t\t} else {\n\t\t\tlogger.Log(\"clone\", fmt.Sprintf(\"%s -> %s\", remoteURL, fpath))\n\t\t}\n\t\tvar (\n\t\t\tlocalRepoRoot = fpath\n\t\t\trepoURL       = remoteURL\n\t\t)\n\t\tvcs, ok := vcsRegistry[g.vcs]\n\t\tif !ok {\n\t\t\tvcs, repoURL, err = remote.VCS()\n\t\t\tif err != nil {\n\t\t\t\treturn getInfo{}, err\n\t\t\t}\n\t\t}\n\t\tif l := detectLocalRepoRoot(remoteURL.Path, repoURL.Path); l != \"\" {\n\t\t\tlocalRepoRoot = filepath.Join(local.RootPath, remoteURL.Hostname(), l)\n\t\t}\n\n\t\tif g.bare {\n\t\t\tlocalRepoRoot = localRepoRoot + \".git\"\n\t\t}\n\n\t\tif remoteURL.Scheme == \"codecommit\" {\n\t\t\trepoURL, _ = url.Parse(remoteURL.Opaque)\n\t\t}\n\t\tif getRepoLock(localRepoRoot) {\n\t\t\treturn info,\n\t\t\t\tvcs.Clone(&vcsGetOption{\n\t\t\t\t\turl:       repoURL,\n\t\t\t\t\tdir:       localRepoRoot,\n\t\t\t\t\tshallow:   g.shallow,\n\t\t\t\t\tsilent:    g.silent,\n\t\t\t\t\tbranch:    branch,\n\t\t\t\t\trecursive: g.recursive,\n\t\t\t\t\tbare:      g.bare,\n\t\t\t\t})\n\t\t}\n\t\treturn info, nil\n\tcase g.update:\n\t\tlogger.Log(\"update\", fpath)\n\t\tvcs, localRepoRoot := local.VCS()\n\t\tif vcs == nil {\n\t\t\treturn getInfo{}, fmt.Errorf(\"failed to detect VCS for %q\", fpath)\n\t\t}\n\t\trepoURL := remoteURL\n\t\tif remoteURL.Scheme == \"codecommit\" {\n\t\t\trepoURL, _ = url.Parse(remoteURL.Opaque)\n\t\t}\n\t\tif getRepoLock(localRepoRoot) {\n\t\t\treturn info, vcs.Update(&vcsGetOption{\n\t\t\t\turl:       repoURL,\n\t\t\t\tdir:       localRepoRoot,\n\t\t\t\tsilent:    g.silent,\n\t\t\t\trecursive: g.recursive,\n\t\t\t\tbare:      g.bare,\n\t\t\t})\n\t\t}\n\t\treturn info, nil\n\t}\n\tlogger.Log(\"exists\", fpath)\n\treturn info, nil\n}\n\nfunc detectLocalRepoRoot(remotePath, repoPath string) string {\n\tremotePath = strings.TrimSuffix(strings.TrimSuffix(remotePath, \"/\"), \".git\")\n\trepoPath = strings.TrimSuffix(strings.TrimSuffix(repoPath, \"/\"), \".git\")\n\tpathParts := strings.Split(repoPath, \"/\")\n\tpathParts = pathParts[1:]\n\tfor i := 0; i < len(pathParts); i++ {\n\t\tsubPath := \"/\" + path.Join(pathParts[i:]...)\n\t\tif subIdx := strings.Index(remotePath, subPath); subIdx >= 0 {\n\t\t\treturn remotePath[0:subIdx] + subPath\n\t\t}\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "getter_test.go",
          "type": "blob",
          "size": 1.8232421875,
          "content": "package main\n\nimport \"testing\"\n\nfunc TestDetectLocalRepoRoot(t *testing.T) {\n\ttestCases := []struct {\n\t\tname, remotePath, repoPath, expect string\n\t}{{\n\t\tname:       \"same\",\n\t\tremotePath: \"/motemen/ghq\",\n\t\trepoPath:   \"/motemen/ghq\",\n\t\texpect:     \"/motemen/ghq\",\n\t}, {\n\t\tname:       \"deep remote repo path\",\n\t\tremotePath: \"/path/to/repo/repo\",\n\t\trepoPath:   \"/path/to/repo\",\n\t\texpect:     \"/path/to/repo\",\n\t}, {\n\t\tname:       \"different remote root\",\n\t\tremotePath: \"/src/path/to/repo/repo\",\n\t\trepoPath:   \"/path/to/repo\",\n\t\texpect:     \"/src/path/to/repo\",\n\t}, {\n\t\tname:       \"different repo root\",\n\t\tremotePath: \"/path/to/repo/repo\",\n\t\trepoPath:   \"/git/path/to/repo\",\n\t\texpect:     \"/path/to/repo\",\n\t}, {\n\t\tname:       \"different roots\",\n\t\tremotePath: \"/src/path/to/repo/repo\",\n\t\trepoPath:   \"/git/path/to/repo\",\n\t\texpect:     \"/src/path/to/repo\",\n\t}, {\n\t\tname:       \"different roots with multibyte\",\n\t\tremotePath: \"//path/to/repo/repo\",\n\t\trepoPath:   \"//path/to/repo\",\n\t\texpect:     \"//path/to/repo\",\n\t}, {\n\t\tname:       \"shallow path\",\n\t\tremotePath: \"/zap/buffer\",\n\t\trepoPath:   \"/uber-go/zap\",\n\t\texpect:     \"/zap\",\n\t}, {\n\t\tname:       \".git at the end\",\n\t\tremotePath: \"/path/to/repo.git\",\n\t\trepoPath:   \"/path/to/repo.git\",\n\t\texpect:     \"/path/to/repo\",\n\t}, {\n\t\tname:       \"trailing slash\",\n\t\tremotePath: \"/path/to/repo/\",\n\t\trepoPath:   \"/path/to/repo/\",\n\t\texpect:     \"/path/to/repo\",\n\t}, {\n\t\tname:       \".git/ at the end\",\n\t\tremotePath: \"/path/to/repo.git/\",\n\t\trepoPath:   \"/path/to/repo.git/\",\n\t\texpect:     \"/path/to/repo\",\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tout := detectLocalRepoRoot(tc.remotePath, tc.repoPath)\n\t\t\tif tc.expect != out {\n\t\t\t\tt.Errorf(\"detectLocalRepoRoot(%q, %q) = %q, expect: %q\",\n\t\t\t\t\ttc.remotePath, tc.repoPath, out, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.873046875,
          "content": "module github.com/x-motemen/ghq\n\ngo 1.23.3\n\nrequire (\n\tgithub.com/Songmu/gitconfig v0.2.0\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgithub.com/motemen/go-colorine v0.0.0-20180816141035-45d19169413a\n\tgithub.com/saracen/walker v0.1.4\n\tgithub.com/urfave/cli/v2 v2.27.5\n\tgolang.org/x/net v0.31.0\n\tgolang.org/x/sync v0.9.0\n)\n\nrequire (\n\tgithub.com/cli/go-gh v1.2.1 // indirect\n\tgithub.com/cli/safeexec v1.0.1 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.5 // indirect\n\tgithub.com/daviddengcn/go-colortext v1.0.0 // indirect\n\tgithub.com/fatih/color v1.18.0 // indirect\n\tgithub.com/goccy/go-yaml v1.13.6 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect\n\tgolang.org/x/sys v0.27.0 // indirect\n\tgolang.org/x/text v0.20.0\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 11.296875,
          "content": "github.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=\ngithub.com/Songmu/gitconfig v0.2.0 h1:pX2++u4KUq+K2k/ZCzGXLtkD3ceCqIdi0tDyb+IbSyo=\ngithub.com/Songmu/gitconfig v0.2.0/go.mod h1:cB5bYJer+pl7W8g6RHFwL/0X6aJROVrYuHlvc7PT+hE=\ngithub.com/cli/browser v1.1.0/go.mod h1:HKMQAt9t12kov91Mn7RfZxyJQQgWgyS/3SZswlZ5iTI=\ngithub.com/cli/go-gh v0.1.0/go.mod h1:eTGWl99EMZ+3Iau5C6dHyGAJRRia65MtdBtuhWc+84o=\ngithub.com/cli/go-gh v1.2.1 h1:xFrjejSsgPiwXFP6VYynKWwxLQcNJy3Twbu82ZDlR/o=\ngithub.com/cli/go-gh v1.2.1/go.mod h1:Jxk8X+TCO4Ui/GarwY9tByWm/8zp4jJktzVZNlTW5VM=\ngithub.com/cli/safeexec v1.0.0/go.mod h1:Z/D4tTN8Vs5gXYHDCbaM1S/anmEDnJb1iW0+EJ5zx3Q=\ngithub.com/cli/safeexec v1.0.1 h1:e/C79PbXF4yYTN/wauC4tviMxEV13BwljGj0N9j+N00=\ngithub.com/cli/safeexec v1.0.1/go.mod h1:Z/D4tTN8Vs5gXYHDCbaM1S/anmEDnJb1iW0+EJ5zx3Q=\ngithub.com/cli/shurcooL-graphql v0.0.1/go.mod h1:U7gCSuMZP/Qy7kbqkk5PrqXEeDgtfG5K+W+u8weorps=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.5 h1:ZtcqGrnekaHpVLArFSe4HK5DoKx1T0rq2DwVB0alcyc=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.5/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/daviddengcn/go-colortext v1.0.0 h1:ANqDyC0ys6qCSvuEK7l3g5RaehL/Xck9EX8ATG8oKsE=\ngithub.com/daviddengcn/go-colortext v1.0.0/go.mod h1:zDqEI5NVUop5QPpVJUxE9UO10hRnmkD5G4Pmri9+m4c=\ngithub.com/fatih/color v1.10.0/go.mod h1:ELkj/draVOlAH/xkhN6mQ50Qd0MPOk5AAr3maGEBuJM=\ngithub.com/fatih/color v1.13.0/go.mod h1:kLAiJbzzSOZDVNGyDpeOxJ47H46qBXwg5ILebYFFOfk=\ngithub.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=\ngithub.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=\ngithub.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=\ngithub.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=\ngithub.com/go-playground/assert/v2 v2.0.1/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.13.0/go.mod h1:taPMhCMXrRLJO55olJkUXHZBHCxTMfnGwq/HNwmWNS8=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.17.0/go.mod h1:UkSxE5sNxxRwHyU+Scu5vgOQjsIJAF8j9muTVoKLVtA=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.4.1/go.mod h1:nlOn6nFhuKACm19sB/8EGNn9GlaMV7XkbRSipzJ0Ii4=\ngithub.com/go-playground/validator/v10 v10.22.1 h1:40JcKH+bBNGFczGuoBYgX4I6m/i27HYW8P9FDk5PbgA=\ngithub.com/go-playground/validator/v10 v10.22.1/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=\ngithub.com/goccy/go-yaml v1.9.5/go.mod h1:U/jl18uSupI5rdI2jmuCswEA2htH9eXfferR3KfscvA=\ngithub.com/goccy/go-yaml v1.13.6 h1:pa3JkBPBseTtfqpG9DiSFhyxNPSpJ0BFa39BlMZE16E=\ngithub.com/goccy/go-yaml v1.13.6/go.mod h1:IjYwxUiJDoqpx2RmbdjMUceGHZwYLon3sfOGl5Hi9lc=\ngithub.com/golangplus/bytes v0.0.0-20160111154220-45c989fe5450/go.mod h1:Bk6SMAONeMXrxql8uvOKuAZSu8aM5RUGv+1C6IJaEho=\ngithub.com/golangplus/bytes v1.0.0/go.mod h1:AdRaCFwmc/00ZzELMWb01soso6W1R/++O1XL80yAn+A=\ngithub.com/golangplus/fmt v1.0.0/go.mod h1:zpM0OfbMCjPtd2qkTD/jX2MgiFCqklhSUFyDW44gVQE=\ngithub.com/golangplus/testing v1.0.0 h1:+ZeeiKZENNOMkTTELoSySazi+XaEhVO0mb+eanrSEUQ=\ngithub.com/golangplus/testing v1.0.0/go.mod h1:ZDreixUV3YzhoVraIDyOzHrr76p6NUh6k/pPg/Q3gYA=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510/go.mod h1:pupxD2MaaD3pAXIBCelhxNneeOaAeabZDe5s4K6zSpQ=\ngithub.com/h2non/parth v0.0.0-20190131123155-b4df798d6542/go.mod h1:Ow0tF8D4Kplbc8s8sSb3V2oUCygFHVp8gC3Dn6U4MNI=\ngithub.com/henvic/httpretty v0.0.6/go.mod h1:X38wLjWXHkXT7r2+uK8LjCMne9rsuNaBLJ+5cU2/Pmo=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/leodido/go-urn v1.2.0/go.mod h1:+8+nEpDfqqsY+g338gtMEUOtuK+4dEMhiQEgxpxOKII=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-colorable v0.1.9/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/motemen/go-colorine v0.0.0-20180816141035-45d19169413a h1:CONqI/36EjYzkAzrMD0UWuL/lRDr7UdoID4fDGke+Yc=\ngithub.com/motemen/go-colorine v0.0.0-20180816141035-45d19169413a/go.mod h1:PU2urRC7j30rrabSyp1MGGhyoiWSninPD8ckjzBSgkU=\ngithub.com/nbio/st v0.0.0-20140626010706-e9e8d9816f32/go.mod h1:9wM+0iRr9ahx58uYLpLIr5fm8diHn0JbqRycJi6w0Ms=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/saracen/walker v0.1.4 h1:/WCOt98GRkQ0KgL6hXJFBpoH21XY6iCD2N6LQWBFiaU=\ngithub.com/saracen/walker v0.1.4/go.mod h1:2F+hfOidTHfXP2AmlKOqpO+yewf8fIvNUDBNJogpJbk=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/thlib/go-timezone-local v0.0.0-20210907160436-ef149e42d28e/go.mod h1:/Tnicc6m/lsJE0irFMA0LfIwTBo4QP7A8IfyIv4zZKI=\ngithub.com/urfave/cli/v2 v2.27.5 h1:WoHEJLdsXr6dDWoJgMq/CboDmyY/8HMMH1fTECbih+w=\ngithub.com/urfave/cli/v2 v2.27.5/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=\ngithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=\ngithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.29.0 h1:L5SG1JTTXupVV3n6sUqMTeWbjAyfPwoda2DLX8J8FrQ=\ngolang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210319071255-635bc2c9138d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210831042530-f4d43177bf5e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220818161305-2296e01440c6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f/go.mod h1:K8+ghG5WaK9qNqU5K3HdILfMLy1f3aNYFI/wnl100a8=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/h2non/gock.v1 v1.1.2/go.mod h1:n7UGz/ckNChHiK05rDoiC4MYSunEC/lyaUm2WWaDva0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "go_import.go",
          "type": "blob",
          "size": 2.0322265625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n)\n\n// metaImport represents the parsed <meta name=\"go-import\"\n// content=\"prefix vcs reporoot\" /> tags from HTML files.\ntype metaImport struct {\n\tPrefix, VCS, RepoRoot string\n}\n\nfunc detectGoImport(u *url.URL) (string, *url.URL, error) {\n\tgoGetU := *u\n\tq := goGetU.Query()\n\tq.Add(\"go-get\", \"1\")\n\tgoGetU.RawQuery = q.Encode()\n\n\tcli := &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\t// never follow redirection\n\t\t\treturn http.ErrUseLastResponse\n\t\t},\n\t}\n\treq, _ := http.NewRequest(http.MethodGet, goGetU.String(), nil)\n\treq.Header.Add(\"User-Agent\", fmt.Sprintf(\"ghq/%s (+https://github.com/motemen/ghq)\", version))\n\tresp, err := cli.Do(req)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\treturn detectVCSAndRepoURL(resp.Body)\n}\n\n// find meta tag like following from html\n// <meta name=\"go-import\" content=\"gopkg.in/yaml.v2 git https://gopkg.in/yaml.v2\">\n// ref. https://golang.org/cmd/go/#hdr-Remote_import_paths\nfunc detectVCSAndRepoURL(r io.Reader) (string, *url.URL, error) {\n\tdoc, err := html.Parse(r)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tvar mImport *metaImport\n\n\tvar f func(*html.Node)\n\tf = func(n *html.Node) {\n\t\tif mImport != nil {\n\t\t\treturn\n\t\t}\n\t\tif n.Type == html.ElementNode && n.Data == \"meta\" {\n\t\t\tvar (\n\t\t\t\tgoImportMeta = false\n\t\t\t\tcontent      = \"\"\n\t\t\t)\n\t\t\tfor _, a := range n.Attr {\n\t\t\t\tif a.Key == \"name\" && a.Val == \"go-import\" {\n\t\t\t\t\tgoImportMeta = true\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif a.Key == \"content\" {\n\t\t\t\t\tcontent = a.Val\n\t\t\t\t}\n\t\t\t}\n\t\t\tif f := strings.Fields(content); goImportMeta && len(f) == 3 && f[1] != \"mod\" {\n\t\t\t\tmImport = &metaImport{\n\t\t\t\t\tPrefix:   f[0],\n\t\t\t\t\tVCS:      f[1],\n\t\t\t\t\tRepoRoot: f[2],\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tf(c)\n\t\t}\n\t}\n\tf(doc)\n\n\tif mImport == nil {\n\t\treturn \"\", nil, fmt.Errorf(\"no go-import meta tags detected\")\n\t}\n\tu, err := url.Parse(mImport.RepoRoot)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\treturn mImport.VCS, u, nil\n}\n"
        },
        {
          "name": "go_import_test.go",
          "type": "blob",
          "size": 0.8125,
          "content": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestDetectVCSAndRepoURL(t *testing.T) {\n\tinput := `<html>\n<head>\n<meta name=\"go-import\" content=\"gopkg.in/yaml.v2 mod https://gopkg.in/yaml.v2\">\n<meta name=\"go-import\" content=\"gopkg.in/yaml.v2 git https://gopkg.in/yaml.v2\">\n<meta name=\"go-source\" content=\"gopkg.in/yaml.v2 _ https://github.com/go-yaml/yaml/tree/v2.2.2{/dir} https://github.com/go-yaml/yaml/blob/v2.2.2{/dir}/{file}#L{line}\">\n</head>\n<body>\ngo get gopkg.in/yaml.v2\n</body>\n</html>`\n\n\tvcs, u, err := detectVCSAndRepoURL(strings.NewReader(input))\n\tif vcs != \"git\" {\n\t\tt.Errorf(\"want: %q, got: %q\", \"git\", vcs)\n\t}\n\texpectedURL := \"https://gopkg.in/yaml.v2\"\n\tif u.String() != expectedURL {\n\t\tt.Errorf(\"want: %q, got: %q\", expectedURL, u.String())\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"something went wrong: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 2.2158203125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc mustParseURL(urlString string) *url.URL {\n\tu, err := url.Parse(urlString)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn u\n}\n\nfunc captureReader(block func()) (*os.File, *os.File, error) {\n\trOut, wOut, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer wOut.Close()\n\n\trErr, wErr, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer wErr.Close()\n\n\tvar stdout, stderr *os.File\n\tos.Stdout, stdout = wOut, os.Stdout\n\tos.Stderr, stderr = wErr, os.Stderr\n\n\tdefer func() {\n\t\tos.Stdout = stdout\n\t\tos.Stderr = stderr\n\t}()\n\n\tblock()\n\n\twOut.Close()\n\twErr.Close()\n\n\treturn rOut, rErr, nil\n}\n\nfunc capture(block func()) (string, string, error) {\n\trOut, rErr, err := captureReader(block)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer rOut.Close()\n\tdefer rErr.Close()\n\n\tbufOut, err := io.ReadAll(rOut)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tbufErr, err := io.ReadAll(rErr)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\treturn string(bufOut), string(bufErr), nil\n}\n\nfunc captureWithInput(in []string, block func()) (string, string, error) {\n\trIn, wIn, err := os.Pipe()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer rIn.Close()\n\n\tvar stdin *os.File\n\tos.Stdin, stdin = rIn, os.Stdin\n\n\tdefer func() { os.Stdin = stdin }()\n\t\n\tfor _, line := range in {\n\t\tfmt.Fprintln(wIn, line)\n\t}\n\twIn.Close()\n\treturn capture(block)\n}\n\nfunc newTempDir(t *testing.T) string {\n\ttmpdir, err := os.MkdirTemp(\"\", \"ghq-test\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(func() { os.RemoveAll(tmpdir) })\n\n\t// Resolve /var/folders/.../T/... to /private/var/... in OSX\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatalf(\"os.Getwd(): %s\", err)\n\t}\n\n\tdefer func() {\n\t\terr := os.Chdir(wd)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"os.Chdir(): %s\", err)\n\t\t}\n\t}()\n\n\terr = os.Chdir(tmpdir)\n\tif err != nil {\n\t\tt.Fatalf(\"os.Chdir(): %s\", err)\n\t}\n\n\ttmpdir, err = os.Getwd()\n\tif err != nil {\n\t\tt.Fatalf(\"os.Getwd(): %s\", err)\n\t}\n\n\ts, err := toFullPath(tmpdir)\n\tif err != nil {\n\t\tt.Fatalf(\"toFullPath(%q): %s\", tmpdir, err)\n\t}\n\treturn s\n}\n\nfunc setEnv(t *testing.T, key, val string) {\n\torig, ok := os.LookupEnv(key)\n\tos.Setenv(key, val)\n\n\tt.Cleanup(func() {\n\t\tif ok {\n\t\t\tos.Setenv(key, orig)\n\t\t} else {\n\t\t\tos.Unsetenv(key)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "helpers_unix.go",
          "type": "blob",
          "size": 0.203125,
          "content": "//go:build !windows\n\npackage main\n\nimport \"path/filepath\"\n\nfunc toFullPath(s string) (string, error) {\n\treturn s, nil\n}\n\nfunc evalSymlinks(path string) (string, error) {\n\treturn filepath.EvalSymlinks(path)\n}\n"
        },
        {
          "name": "helpers_windows.go",
          "type": "blob",
          "size": 1.21875,
          "content": "//go:build windows\n\npackage main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n)\n\nfunc toFullPath(s string) (string, error) {\n\tp := syscall.StringToUTF16(s)\n\tb := p\n\tn, err := syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))\n\tif err != nil {\n\t\treturn s, err\n\t}\n\tif n > uint32(len(b)) {\n\t\tb = make([]uint16, n)\n\t\tn, err = syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))\n\t\tif err != nil {\n\t\t\treturn s, err\n\t\t}\n\t}\n\tb = b[:n]\n\treturn syscall.UTF16ToString(b), nil\n}\n\nfunc evalSymlinks(path string) (string, error) {\n\t_, err := os.Stat(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tlist := filepathSplitAll(path)\n\tevaled := list[0]\n\tfor i := 1; i < len(list); i++ {\n\t\tevaled = filepath.Join(evaled, list[i])\n\n\t\tlinkSrc, err := os.Readlink(evaled)\n\t\tif err != nil {\n\t\t\t// not symlink\n\t\t\tcontinue\n\t\t} else {\n\t\t\tif filepath.IsAbs(linkSrc) {\n\t\t\t\tevaled = linkSrc\n\t\t\t} else {\n\t\t\t\tevaled = filepath.Join(filepath.Dir(evaled), linkSrc)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn evaled, nil\n}\n\nfunc filepathSplitAll(path string) []string {\n\tpath = filepath.Clean(path)\n\tpath = filepath.ToSlash(path)\n\n\tvol := filepath.VolumeName(path)\n\n\tpath = path[len(vol):]\n\tlist := strings.Split(path, \"/\")\n\tlist[0] = vol + string(filepath.Separator) + list[0]\n\treturn list\n}\n"
        },
        {
          "name": "helpers_windows_test.go",
          "type": "blob",
          "size": 2.6103515625,
          "content": "//go:build windows\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"golang.org/x/text/encoding/japanese\"\n\t\"golang.org/x/text/transform\"\n)\n\ntype testEvalSymlinksMode int\n\nconst (\n\ttestEvalSymlinksNotLink testEvalSymlinksMode = iota\n\ttestEvalSymlinksSymbolicLink\n\ttestEvalSymlinksJunction\n)\n\nfunc Test_evalSymlinks(t *testing.T) {\n\ttype args struct {\n\t\tpath string\n\t}\n\ttests := []struct {\n\t\tname         string\n\t\tmode         testEvalSymlinksMode\n\t\tlinkBasePath string\n\t\targs         args\n\t\twant         string\n\t\twantErr      bool\n\t}{\n\t\t{\n\t\t\tname: \"not link\",\n\t\t\tmode: testEvalSymlinksNotLink,\n\t\t\targs: args{\n\t\t\t\tpath: filepath.Join(os.TempDir(), \"not_link\"),\n\t\t\t},\n\t\t\twant:    filepath.Join(os.TempDir(), \"not_link\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"symbolic link\",\n\t\t\tmode:         testEvalSymlinksSymbolicLink,\n\t\t\tlinkBasePath: filepath.Join(os.TempDir(), \"link_base\"),\n\t\t\targs: args{\n\t\t\t\tpath: filepath.Join(os.TempDir(), \"symbolic_link\"),\n\t\t\t},\n\t\t\twant:    filepath.Join(os.TempDir(), \"link_base\"),\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"junction\",\n\t\t\tmode:         testEvalSymlinksJunction,\n\t\t\tlinkBasePath: filepath.Join(os.TempDir(), \"link_base\"),\n\t\t\targs: args{\n\t\t\t\tpath: filepath.Join(os.TempDir(), \"junction\"),\n\t\t\t},\n\t\t\twant:    filepath.Join(os.TempDir(), \"link_base\"),\n\t\t\twantErr: false,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif err := createLink(tt.linkBasePath, tt.args.path, tt.mode); err != nil {\n\t\t\t\tt.Errorf(\"failed to create link: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tgot, err := evalSymlinks(tt.args.path)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"evalSymlinks() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"evalSymlinks() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc createLink(linkBasePath, path string, mode testEvalSymlinksMode) error {\n\tif err := os.RemoveAll(path); err != nil {\n\t\treturn err\n\t}\n\n\tif mode == testEvalSymlinksNotLink {\n\t\treturn os.MkdirAll(path, 0755)\n\t}\n\n\tif err := os.MkdirAll(linkBasePath, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tswitch mode {\n\tcase testEvalSymlinksSymbolicLink:\n\t\treturn os.Symlink(linkBasePath, path)\n\tcase testEvalSymlinksJunction:\n\t\toutput, err := exec.Command(\"cmd\", \"/c\", \"mklink\", \"/J\", path, linkBasePath).CombinedOutput()\n\t\tif err != nil {\n\t\t\toutput, err := io.ReadAll(transform.NewReader(bytes.NewBuffer(output), japanese.ShiftJIS.NewDecoder()))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to transform output: %w\", err)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"failed to create junction: %s, %w\", string(output), err)\n\t\t}\n\t\treturn nil\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "local_repository.go",
          "type": "blob",
          "size": 10.248046875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/Songmu/gitconfig\"\n\t\"github.com/saracen/walker\"\n\t\"github.com/x-motemen/ghq/logger\"\n)\n\nconst envGhqRoot = \"GHQ_ROOT\"\n\n// LocalRepository represents local repository\ntype LocalRepository struct {\n\tFullPath  string\n\tRelPath   string\n\tRootPath  string\n\tPathParts []string\n\n\trepoPath   string\n\tvcsBackend *VCSBackend\n}\n\n// RepoPath returns local repository path\nfunc (repo *LocalRepository) RepoPath() string {\n\tif repo.repoPath != \"\" {\n\t\treturn repo.repoPath\n\t}\n\treturn repo.FullPath\n}\n\n// LocalRepositoryFromFullPath resolve LocalRepository from file path\nfunc LocalRepositoryFromFullPath(fullPath string, backend *VCSBackend) (*LocalRepository, error) {\n\tvar relPath string\n\n\troots, err := localRepositoryRoots(true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar root string\n\tfor _, root = range roots {\n\t\tif !strings.HasPrefix(fullPath, root) {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar err error\n\t\trelPath, err = filepath.Rel(root, fullPath)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif relPath == \"\" {\n\t\treturn nil, fmt.Errorf(\"no local repository found for: %s\", fullPath)\n\t}\n\n\tpathParts := strings.Split(relPath, string(filepath.Separator))\n\n\treturn &LocalRepository{\n\t\tFullPath:   fullPath,\n\t\tRelPath:    filepath.ToSlash(relPath),\n\t\tRootPath:   root,\n\t\tPathParts:  pathParts,\n\t\tvcsBackend: backend,\n\t}, nil\n}\n\n// LocalRepositoryFromURL resolve LocalRepository from URL\nfunc LocalRepositoryFromURL(remoteURL *url.URL, bare bool) (*LocalRepository, error) {\n\tpathParts := append(\n\t\t[]string{remoteURL.Hostname()}, strings.Split(remoteURL.Path, \"/\")...,\n\t)\n\trelPath := strings.TrimSuffix(filepath.Join(pathParts...), \".git\")\n\tpathParts[len(pathParts)-1] = strings.TrimSuffix(pathParts[len(pathParts)-1], \".git\")\n\tif bare {\n\t\t// Force to append \".git\" even if remoteURL does not end with \".git\".\n\t\trelPath = relPath + \".git\"\n\t\tpathParts[len(pathParts)-1] = pathParts[len(pathParts)-1] + \".git\"\n\t}\n\n\tvar (\n\t\tlocalRepository *LocalRepository\n\t\tmu              sync.Mutex\n\t)\n\t// Find existing local repository first\n\tif err := walkAllLocalRepositories(func(repo *LocalRepository) {\n\t\tif repo.RelPath == relPath {\n\t\t\tmu.Lock()\n\t\t\tlocalRepository = repo\n\t\t\tmu.Unlock()\n\t\t}\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif localRepository != nil {\n\t\treturn localRepository, nil\n\t}\n\tvar remoteURLStr = remoteURL.String()\n\tif remoteURL.Scheme == \"codecommit\" {\n\t\tremoteURLStr = remoteURL.Opaque\n\t}\n\tprim, err := getRoot(remoteURLStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// No local repository found, returning new one\n\treturn &LocalRepository{\n\t\tFullPath:  filepath.Join(prim, relPath),\n\t\tRelPath:   relPath,\n\t\tRootPath:  prim,\n\t\tPathParts: pathParts,\n\t}, nil\n}\n\nfunc getRoot(u string) (string, error) {\n\tprim := os.Getenv(envGhqRoot)\n\tif prim != \"\" {\n\t\treturn prim, nil\n\t}\n\tvar err error\n\tif !codecommitLikeURLPattern.MatchString(u) {\n\t\tprim, err = gitconfig.Do(\"--path\", \"--get-urlmatch\", \"ghq.root\", u)\n\t\tif err != nil && !gitconfig.IsNotFound(err) {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\tif prim == \"\" {\n\t\tprim, err = primaryLocalRepositoryRoot()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\treturn prim, nil\n}\n\n// Subpaths returns lists of tail parts of relative path from the root directory (shortest first)\n// for example, {\"ghq\", \"motemen/ghq\", \"github.com/motemen/ghq\"} for $root/github.com/motemen/ghq.\nfunc (repo *LocalRepository) Subpaths() []string {\n\ttails := make([]string, len(repo.PathParts))\n\n\tfor i := range repo.PathParts {\n\t\ttails[i] = strings.Join(repo.PathParts[len(repo.PathParts)-(i+1):], \"/\")\n\t}\n\n\treturn tails\n}\n\n// NonHostPath returns non host path\nfunc (repo *LocalRepository) NonHostPath() string {\n\treturn strings.Join(repo.PathParts[1:], \"/\")\n}\n\n// list as bellow\n// - \"$GHQ_ROOT/github.com/motemen/ghq/cmdutil\" // repo.FullPath\n// - \"$GHQ_ROOT/github.com/motemen/ghq\"\n// - \"$GHQ_ROOT/github.com/motemen\nfunc (repo *LocalRepository) repoRootCandidates() []string {\n\thostRoot := filepath.Join(repo.RootPath, repo.PathParts[0])\n\tnonHostParts := repo.PathParts[1:]\n\tcandidates := make([]string, len(nonHostParts))\n\tfor i := 0; i < len(nonHostParts); i++ {\n\t\tcandidates[i] = filepath.Join(append(\n\t\t\t[]string{hostRoot}, nonHostParts[0:len(nonHostParts)-i]...)...)\n\t}\n\treturn candidates\n}\n\n// IsUnderPrimaryRoot or not\nfunc (repo *LocalRepository) IsUnderPrimaryRoot() bool {\n\tprim, err := primaryLocalRepositoryRoot()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn strings.HasPrefix(repo.FullPath, prim)\n}\n\n// Matches checks if any subpath of the local repository equals the query.\nfunc (repo *LocalRepository) Matches(pathQuery string) bool {\n\tfor _, p := range repo.Subpaths() {\n\t\tif p == pathQuery {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// VCS returns VCSBackend of the repository\nfunc (repo *LocalRepository) VCS() (*VCSBackend, string) {\n\tif repo.vcsBackend == nil {\n\t\tfor _, dir := range repo.repoRootCandidates() {\n\t\t\tbackend := findVCSBackend(dir, \"\")\n\t\t\tif backend != nil {\n\t\t\t\trepo.vcsBackend = backend\n\t\t\t\trepo.repoPath = dir\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn repo.vcsBackend, repo.RepoPath()\n}\n\nvar vcsContentsMap = map[string]*VCSBackend{\n\t\".git\":           GitBackend,\n\t\".hg\":            MercurialBackend,\n\t\".svn\":           SubversionBackend,\n\t\"_darcs\":         DarcsBackend,\n\t\".pijul\":         PijulBackend,\n\t\".bzr\":           BazaarBackend,\n\t\".fslckout\":      FossilBackend, // file\n\t\"_FOSSIL_\":       FossilBackend, // file\n\t\"CVS/Repository\": cvsDummyBackend,\n}\n\nvar vcsContents = [...]string{\n\t\".git\",\n\t\".hg\",\n\t\".svn\",\n\t\"_darcs\",\n\t\".pijul\",\n\t\".bzr\",\n\t\".fslckout\",\n\t\"._FOSSIL_\",\n\t\"CVS/Repository\",\n}\n\nfunc findVCSBackend(fpath, vcs string) *VCSBackend {\n\t// When vcs is not empty, search only specified contents of vcs\n\tif vcs != \"\" {\n\t\tvcsBackend, ok := vcsRegistry[vcs]\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\t\tif vcsBackend == GitBackend && strings.HasSuffix(fpath, \".git\") {\n\t\t\treturn vcsBackend\n\t\t}\n\t\tfor _, d := range vcsBackend.Contents {\n\t\t\tif _, err := os.Stat(filepath.Join(fpath, d)); err == nil {\n\t\t\t\treturn vcsBackend\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tif strings.HasSuffix(fpath, \".git\") {\n\t\treturn GitBackend\n\t}\n\tfor _, d := range vcsContents {\n\t\tif _, err := os.Stat(filepath.Join(fpath, d)); err == nil {\n\t\t\treturn vcsContentsMap[d]\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc walkAllLocalRepositories(callback func(*LocalRepository)) error {\n\treturn walkLocalRepositories(\"\", callback)\n}\n\nfunc walkLocalRepositories(vcs string, callback func(*LocalRepository)) error {\n\troots, err := localRepositoryRoots(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twalkFn := func(fpath string, fi os.FileInfo) error {\n\t\tisSymlink := false\n\t\tif fi.Mode()&os.ModeSymlink == os.ModeSymlink {\n\t\t\tisSymlink = true\n\t\t\trealpath, err := filepath.EvalSymlinks(fpath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tfi, err = os.Stat(realpath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\tif !fi.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tvcsBackend := findVCSBackend(fpath, vcs)\n\t\tif vcsBackend == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\trepo, err := LocalRepositoryFromFullPath(fpath, vcsBackend)\n\t\tif err != nil || repo == nil {\n\t\t\treturn nil\n\t\t}\n\t\tcallback(repo)\n\n\t\tif isSymlink {\n\t\t\treturn nil\n\t\t}\n\t\treturn filepath.SkipDir\n\t}\n\n\terrCb := walker.WithErrorCallback(func(pathname string, err error) error {\n\t\tif os.IsPermission(errors.Unwrap(err)) {\n\t\t\tlogger.Log(\"warning\", fmt.Sprintf(\"%s: Permission denied\", pathname))\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\n\tfor _, root := range roots {\n\t\tfi, err := os.Stat(root)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif fi.Mode()&0444 == 0 {\n\t\t\tlogger.Log(\"warning\", fmt.Sprintf(\"%s: Permission denied\", root))\n\t\t\tcontinue\n\t\t}\n\t\tif err := walker.Walk(root, walkFn, errCb); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nvar (\n\t_home    string\n\t_homeErr error\n\thomeOnce = &sync.Once{}\n)\n\nfunc getHome() (string, error) {\n\thomeOnce.Do(func() {\n\t\t_home, _homeErr = os.UserHomeDir()\n\t})\n\treturn _home, _homeErr\n}\n\nvar (\n\t_localRepositoryRoots []string\n\t_localRepoErr         error\n\tlocalRepoOnce         = &sync.Once{}\n)\n\n// localRepositoryRoots returns locally cloned repositories' root directories.\n// The root dirs are determined as following:\n//\n//   - If GHQ_ROOT environment variable is nonempty, use it as the only root dir.\n//   - Otherwise, use the result of `git config --get-all ghq.root` as the dirs.\n//   - Otherwise, fallback to the default root, `~/.ghq`.\n//   - When GHQ_ROOT is empty, specific root dirs are added from the result of\n//     `git config --path --get-regexp '^ghq\\..+\\.root$`\nfunc localRepositoryRoots(all bool) ([]string, error) {\n\tlocalRepoOnce.Do(func() {\n\t\tvar roots []string\n\t\tenvRoot := os.Getenv(envGhqRoot)\n\t\tif envRoot != \"\" {\n\t\t\troots = filepath.SplitList(envRoot)\n\t\t} else {\n\t\t\tvar err error\n\t\t\troots, err = gitconfig.PathAll(\"ghq.root\")\n\t\t\tif err != nil && !gitconfig.IsNotFound(err) {\n\t\t\t\t_localRepoErr = err\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// reverse slice\n\t\t\tfor i := len(roots)/2 - 1; i >= 0; i-- {\n\t\t\t\topp := len(roots) - 1 - i\n\t\t\t\troots[i], roots[opp] =\n\t\t\t\t\troots[opp], roots[i]\n\t\t\t}\n\t\t}\n\n\t\tif len(roots) == 0 {\n\t\t\thomeDir, err := getHome()\n\t\t\tif err != nil {\n\t\t\t\t_localRepoErr = err\n\t\t\t\treturn\n\t\t\t}\n\t\t\troots = []string{filepath.Join(homeDir, \"ghq\")}\n\t\t}\n\n\t\tif all && envRoot == \"\" {\n\t\t\tlocalRoots, err := urlMatchLocalRepositoryRoots()\n\t\t\tif err != nil {\n\t\t\t\t_localRepoErr = err\n\t\t\t\treturn\n\t\t\t}\n\t\t\troots = append(roots, localRoots...)\n\t\t}\n\n\t\tseen := make(map[string]bool, len(roots))\n\t\tfor _, v := range roots {\n\t\t\tpath := filepath.Clean(v)\n\t\t\tif _, err := os.Stat(path); err == nil {\n\t\t\t\tif path, err = evalSymlinks(path); err != nil {\n\t\t\t\t\t_localRepoErr = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !filepath.IsAbs(path) {\n\t\t\t\tvar err error\n\t\t\t\tif path, err = filepath.Abs(path); err != nil {\n\t\t\t\t\t_localRepoErr = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif seen[path] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseen[path] = true\n\t\t\t_localRepositoryRoots = append(_localRepositoryRoots, path)\n\t\t}\n\t})\n\treturn _localRepositoryRoots, _localRepoErr\n}\n\nfunc urlMatchLocalRepositoryRoots() ([]string, error) {\n\tout, err := gitconfig.Do(\"--path\", \"--get-regexp\", `^ghq\\..+\\.root$`)\n\tif err != nil {\n\t\tif gitconfig.IsNotFound(err) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\titems := strings.Split(out, \"\\x00\")\n\tret := make([]string, len(items))\n\tfor i, kvStr := range items {\n\t\tkv := strings.SplitN(kvStr, \"\\n\", 2)\n\t\tret[i] = kv[1]\n\t}\n\treturn ret, nil\n}\n\nfunc primaryLocalRepositoryRoot() (string, error) {\n\troots, err := localRepositoryRoots(false)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn roots[0], nil\n}\n"
        },
        {
          "name": "local_repository_test.go",
          "type": "blob",
          "size": 10.037109375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/Songmu/gitconfig\"\n)\n\nfunc samePathSlice(lhss, rhss []string) bool {\n\tif len(lhss) != len(rhss) {\n\t\treturn false\n\t}\n\tlhssAbs := make([]string, len(lhss))\n\trhssAbs := make([]string, len(rhss))\n\n\tfor i, p := range lhss {\n\t\tlhsAbs, _ := filepath.Abs(filepath.Clean(p))\n\t\tlhssAbs[i] = strings.ToLower(lhsAbs)\n\n\t\trhsAbs, _ := filepath.Abs(filepath.Clean(rhss[i]))\n\t\trhssAbs[i] = strings.ToLower(rhsAbs)\n\t}\n\tsort.Strings(lhssAbs)\n\tsort.Strings(rhssAbs)\n\tfor i := range lhssAbs {\n\t\tif lhssAbs[i] != rhssAbs[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestLocalRepositoryFromFullPath(t *testing.T) {\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\ttmproot := newTempDir(t)\n\t_localRepositoryRoots = []string{tmproot}\n\n\ttestCases := []struct {\n\t\tfpath    string\n\t\texpect   string\n\t\tsubpaths []string\n\t}{{\n\t\tfpath:    filepath.Join(tmproot, \"github.com/motemen/ghq\"),\n\t\texpect:   \"motemen/ghq\",\n\t\tsubpaths: []string{\"ghq\", \"motemen/ghq\", \"github.com/motemen/ghq\"},\n\t}, {\n\t\tfpath:    filepath.Join(tmproot, \"stash.com/scm/motemen/ghq\"),\n\t\texpect:   \"scm/motemen/ghq\",\n\t\tsubpaths: []string{\"ghq\", \"motemen/ghq\", \"scm/motemen/ghq\", \"stash.com/scm/motemen/ghq\"},\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.fpath, func(t *testing.T) {\n\t\t\tr, err := LocalRepositoryFromFullPath(tc.fpath, nil)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif r.NonHostPath() != tc.expect {\n\t\t\t\tt.Errorf(\"NonHostPath: got: %s, expect: %s\", r.NonHostPath(), tc.expect)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(r.Subpaths(), tc.subpaths) {\n\t\t\t\tt.Errorf(\"Subpaths:\\ngot:    %+v\\nexpect: %+v\", r.Subpaths(), tc.subpaths)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewLocalRepository(t *testing.T) {\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\ttmproot := newTempDir(t)\n\t_localRepositoryRoots = []string{tmproot}\n\n\ttestCases := []struct {\n\t\tname, url, expect string\n\t}{{\n\t\tname:   \"GitHub\",\n\t\turl:    \"ssh://git@github.com/motemen/ghq.git\",\n\t\texpect: filepath.Join(tmproot, \"github.com/motemen/ghq\"),\n\t}, {\n\t\tname:   \"stash\",\n\t\turl:    \"ssh://git@stash.com/scm/motemen/ghq.git\",\n\t\texpect: filepath.Join(tmproot, \"stash.com/scm/motemen/ghq\"),\n\t}, {\n\t\tname:   \"svn Sourceforge\",\n\t\turl:    \"http://svn.code.sf.net/p/ghq/code/trunk\",\n\t\texpect: filepath.Join(tmproot, \"svn.code.sf.net/p/ghq/code/trunk\"),\n\t}, {\n\t\tname:   \"git Sourceforge\",\n\t\turl:    \"http://git.code.sf.net/p/ghq/code\",\n\t\texpect: filepath.Join(tmproot, \"git.code.sf.net/p/ghq/code\"),\n\t}, {\n\t\tname:   \"svn Sourceforge JP\",\n\t\turl:    \"http://scm.sourceforge.jp/svnroot/ghq/\",\n\t\texpect: filepath.Join(tmproot, \"scm.sourceforge.jp/svnroot/ghq\"),\n\t}, {\n\t\tname:   \"git Sourceforge JP\",\n\t\turl:    \"http://scm.sourceforge.jp/gitroot/ghq/ghq.git\",\n\t\texpect: filepath.Join(tmproot, \"scm.sourceforge.jp/gitroot/ghq/ghq\"),\n\t}, {\n\t\tname:   \"svn Assembla\",\n\t\turl:    \"https://subversion.assembla.com/svn/ghq/\",\n\t\texpect: filepath.Join(tmproot, \"subversion.assembla.com/svn/ghq\"),\n\t}, {\n\t\tname:   \"git Assembla\",\n\t\turl:    \"https://git.assembla.com/ghq.git\",\n\t\texpect: filepath.Join(tmproot, \"git.assembla.com/ghq\"),\n\t}, {\n\t\tname:   \"bitbucket host with port\",\n\t\turl:    \"https://bitbucket.local:8888/motemen/ghq.git\",\n\t\texpect: filepath.Join(tmproot, \"bitbucket.local/motemen/ghq\"),\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefer func(orig string) { _home = orig }(_home)\n\t\t\t_home = \"\"\n\t\t\thomeOnce = &sync.Once{}\n\t\t\tr, err := LocalRepositoryFromURL(mustParseURL(tc.url), false)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif r.FullPath != tc.expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", r.FullPath, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLocalRepositoryRoots(t *testing.T) {\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\troot   string\n\t\texpect []string\n\t}{{\n\t\troot:   \"/path/to/ghqroot\",\n\t\texpect: []string{\"/path/to/ghqroot\"},\n\t}, {\n\t\troot:   \"/path/to/ghqroot1\" + string(os.PathListSeparator) + \"/path/to/ghqroot2\",\n\t\texpect: []string{\"/path/to/ghqroot1\", \"/path/to/ghqroot2\"},\n\t}, {\n\t\troot:   \"/path/to/ghqroot11\" + string(os.PathListSeparator) + \"vendor\",\n\t\texpect: []string{\"/path/to/ghqroot11\", filepath.Join(wd, \"vendor\")},\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.root, func(t *testing.T) {\n\t\t\t_localRepositoryRoots = nil\n\t\t\tlocalRepoOnce = &sync.Once{}\n\t\t\tsetEnv(t, envGhqRoot, tc.root)\n\t\t\tgot, err := localRepositoryRoots(true)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t\t}\n\t\t\tif !samePathSlice(got, tc.expect) {\n\t\t\t\tt.Errorf(\"\\ngot:    %+v\\nexpect: %+v\", got, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// https://gist.github.com/kyanny/c231f48e5d08b98ff2c3\nfunc TestList_Symlink(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.SkipNow()\n\t}\n\troot := newTempDir(t)\n\tsymDir := newTempDir(t)\n\n\torigLocalRepositoryRoots := _localRepositoryRoots\n\t_localRepositoryRoots = []string{root}\n\tdefer func() { _localRepositoryRoots = origLocalRepositoryRoots }()\n\n\tif err := os.MkdirAll(filepath.Join(root, \"github.com\", \"atom\", \"atom\", \".git\"), 0777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := os.MkdirAll(filepath.Join(root, \"github.com\", \"zabbix\", \"zabbix\", \".git\"), 0777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := os.Symlink(symDir, filepath.Join(root, \"github.com\", \"ghq\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar paths []string\n\twalkAllLocalRepositories(func(repo *LocalRepository) {\n\t\tpaths = append(paths, repo.RelPath)\n\t})\n\n\tif len(paths) != 2 {\n\t\tt.Errorf(\"length of paths should be 2, but: %d\", len(paths))\n\t}\n}\n\nfunc TestList_Symlink_In_Same_Directory(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.SkipNow()\n\t}\n\troot := newTempDir(t)\n\tsymDir := newTempDir(t)\n\n\torigLocalRepositoryRoots := _localRepositoryRoots\n\t_localRepositoryRoots = []string{root}\n\tdefer func() { _localRepositoryRoots = origLocalRepositoryRoots }()\n\n\tif err := os.MkdirAll(filepath.Join(root, \"github.com\", \"root-user\", \"a-repository\", \".git\"), 0777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := os.MkdirAll(filepath.Join(root, \"github.com\", \"root-user\", \"z-repository\", \".git\"), 0777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := os.MkdirAll(filepath.Join(symDir, \"github.com\", \"sym-user\", \"h-repository\", \".git\"), 0777); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := os.Symlink(filepath.Join(symDir, \"github.com\", \"sym-user\", \"h-repository\"), filepath.Join(root, \"github.com\", \"root-user\", \"h-repository\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar paths []string\n\twalkAllLocalRepositories(func(repo *LocalRepository) {\n\t\tpaths = append(paths, repo.RelPath)\n\t})\n\n\tif len(paths) != 3 {\n\t\tt.Errorf(\"length of paths should be 3, but: %d\", len(paths))\n\t}\n}\n\nfunc TestFindVCSBackend(t *testing.T) {\n\ttestCases := []struct {\n\t\tname   string\n\t\tsetup  func(t *testing.T) (string, string)\n\t\texpect *VCSBackend\n\t}{{\n\t\tname: \"git-bare\",\n\t\tsetup: func(t *testing.T) (string, string) {\n\t\t\tdir := newTempDir(t)\n\t\t\tdir = dir + \".git\"\n\t\t\tos.MkdirAll(dir, 0o755)\n\t\t\treturn dir, \"\"\n\t\t},\n\t\texpect: GitBackend,\n\t}, {\n\t\tname: \"git\",\n\t\tsetup: func(t *testing.T) (string, string) {\n\t\t\tdir := newTempDir(t)\n\t\t\tos.MkdirAll(filepath.Join(dir, \".git\"), 0755)\n\t\t\treturn dir, \"\"\n\t\t},\n\t\texpect: GitBackend,\n\t}, {\n\t\tname: \"git svn\",\n\t\tsetup: func(t *testing.T) (string, string) {\n\t\t\tdir := newTempDir(t)\n\t\t\tos.MkdirAll(filepath.Join(dir, \".git\", \"svn\"), 0755)\n\t\t\treturn dir, \"\"\n\t\t},\n\t\texpect: GitBackend,\n\t}, {\n\t\tname: \"git with matched vcs\",\n\t\tsetup: func(t *testing.T) (string, string) {\n\t\t\tdir := newTempDir(t)\n\t\t\tos.MkdirAll(filepath.Join(dir, \".git\"), 0755)\n\t\t\treturn dir, \"git\"\n\t\t},\n\t\texpect: GitBackend,\n\t}, {\n\t\tname: \"git with not matched vcs\",\n\t\tsetup: func(t *testing.T) (string, string) {\n\t\t\tdir := newTempDir(t)\n\t\t\tos.MkdirAll(filepath.Join(dir, \".git\"), 0755)\n\t\t\treturn dir, \"mercurial\"\n\t\t},\n\t\texpect: nil,\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfpath, vcs := tc.setup(t)\n\t\t\tbackend := findVCSBackend(fpath, vcs)\n\t\t\tif backend != tc.expect {\n\t\t\t\tt.Errorf(\"got: %v, expect: %v\", backend, tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLocalRepository_VCS(t *testing.T) {\n\tdefer func(orig []string) { _localRepositoryRoots = orig }(_localRepositoryRoots)\n\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\ttmpdir := newTempDir(t)\n\tsetEnv(t, envGhqRoot, tmpdir)\n\n\tpkg := filepath.Join(tmpdir, \"github.com\", \"motemen\", \"ghq\")\n\tsubpkg := filepath.Join(pkg, \"logger\")\n\n\tos.MkdirAll(filepath.Join(pkg, \".git\"), 0755)\n\tos.MkdirAll(subpkg, 0755)\n\n\tt.Run(\"reporoot\", func(t *testing.T) {\n\t\trepo, err := LocalRepositoryFromFullPath(pkg, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error should be nil, but: %s (%s)\", err, pkg)\n\t\t\treturn\n\t\t}\n\t\tvcs, repoPath := repo.VCS()\n\t\tif vcs != GitBackend {\n\t\t\tt.Errorf(\"repo.VCS() = %+v, expect: GitBackend\", vcs)\n\t\t\treturn\n\t\t}\n\t\tif repoPath != pkg {\n\t\t\tt.Errorf(\"got: %s, expect: %s\", repoPath, pkg)\n\t\t}\n\t})\n\n\tt.Run(\"subdir\", func(t *testing.T) {\n\t\trepo, err := LocalRepositoryFromFullPath(subpkg, nil)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t\treturn\n\t\t}\n\t\tvcs, repoPath := repo.VCS()\n\t\tif vcs != GitBackend {\n\t\t\tt.Errorf(\"repo.VCS() = %+v, expect: GitBackend\", vcs)\n\t\t}\n\t\tif repoPath != pkg {\n\t\t\tt.Errorf(\"got: %s, expect: %s\", repoPath, pkg)\n\t\t}\n\t})\n}\n\nfunc TestLocalRepositoryRoots_URLMatchLocalRepositoryRoots(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.SkipNow()\n\t}\n\tsetEnv(t, \"HOME\", \"/home/tmp\")\n\tdefer func(orig string) { _home = orig }(_home)\n\n\t_home = \"\"\n\thomeOnce = &sync.Once{}\n\tt.Cleanup(gitconfig.WithConfig(t, `\n[ghq]\n  root = /hoge\n[ghq \"https://github.com/hatena\"]\n  root = ~/proj/hatena\n  root = /backups/hatena\n[ghq \"https://github.com/natureglobal\"]\n  root = ~/proj/natureglobal\n`))\n\n\twant := []string{\"/hoge\", \"/home/tmp/proj/hatena\", \"/backups/hatena\", \"/home/tmp/proj/natureglobal\"}\n\n\t_localRepositoryRoots = nil\n\tlocalRepoOnce = &sync.Once{}\n\tgot, err := localRepositoryRoots(true)\n\tif err != nil {\n\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t}\n\tif !reflect.DeepEqual(want, got) {\n\t\tt.Errorf(\"localRepositoryRoots(true) = %+v, want: %+v\", got, want)\n\t}\n}\n"
        },
        {
          "name": "logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 0.70703125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli/v2\"\n\t\"github.com/x-motemen/ghq/logger\"\n)\n\nconst version = \"1.7.1\"\n\nvar revision = \"HEAD\"\n\nfunc main() {\n\tif err := newApp().Run(os.Args); err != nil {\n\t\texitCode := 1\n\t\tif excoder, ok := err.(cli.ExitCoder); ok {\n\t\t\texitCode = excoder.ExitCode()\n\t\t}\n\t\tlogger.Log(\"error\", err.Error())\n\t\tos.Exit(exitCode)\n\t}\n}\n\nfunc newApp() *cli.App {\n\tapp := cli.NewApp()\n\tapp.Name = \"ghq\"\n\tapp.Usage = \"Manage remote repository clones\"\n\tapp.Version = fmt.Sprintf(\"%s (rev:%s)\", version, revision)\n\tapp.Authors = []*cli.Author{{\n\t\tName:  \"motemen\",\n\t\tEmail: \"motemen@gmail.com\",\n\t}, {\n\t\tName:  \"Songmu\",\n\t\tEmail: \"y.songmu@gmail.com\",\n\t}}\n\tapp.Commands = commands\n\treturn app\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 0.189453125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/Songmu/gitconfig\"\n)\n\nfunc TestMain(m *testing.M) {\n\tteardown := gitconfig.WithConfig(nil, \"\")\n\tcode := m.Run()\n\tteardown()\n\tos.Exit(code)\n}\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "remote_repository.go",
          "type": "blob",
          "size": 6.796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/Songmu/gitconfig\"\n\t\"github.com/x-motemen/ghq/cmdutil\"\n\t\"github.com/x-motemen/ghq/logger\"\n)\n\n// A RemoteRepository represents a remote repository.\ntype RemoteRepository interface {\n\t// URL returns the repository URL.\n\tURL() *url.URL\n\t// IsValid checks if the URL is valid.\n\tIsValid() bool\n\t// VCS returns the VCS backend that hosts the repository.\n\tVCS() (*VCSBackend, *url.URL, error)\n}\n\n// A GitHubRepository represents a GitHub repository. Implements RemoteRepository.\ntype GitHubRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of the repository\nfunc (repo *GitHubRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the repository is valid or not\nfunc (repo *GitHubRepository) IsValid() bool {\n\tif strings.HasPrefix(repo.url.Path, \"/blog/\") {\n\t\tlogger.Log(\"github\", `the user or organization named \"blog\" is invalid on github, \"https://github.com/blog\" is redirected to \"https://github.blog\".`)\n\t\treturn false\n\t}\n\tpathComponents := strings.Split(strings.Trim(repo.url.Path, \"/\"), \"/\")\n\treturn len(pathComponents) >= 2\n}\n\n// VCS returns VCSBackend of the repository\nfunc (repo *GitHubRepository) VCS() (*VCSBackend, *url.URL, error) {\n\tu := *repo.url\n\tpathComponents := strings.Split(strings.Trim(strings.TrimSuffix(u.Path, \".git\"), \"/\"), \"/\")\n\tpath := \"/\" + strings.Join(pathComponents[0:2], \"/\")\n\tif strings.HasSuffix(u.String(), \".git\") {\n\t\tpath += \".git\"\n\t}\n\tu.Path = path\n\treturn GitBackend, &u, nil\n}\n\n// A GitHubGistRepository represents a GitHub Gist repository.\ntype GitHubGistRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of the GistRepository\nfunc (repo *GitHubGistRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the gist repository is valid or not\nfunc (repo *GitHubGistRepository) IsValid() bool {\n\treturn true\n}\n\n// VCS returns VCSBackend of the gist\nfunc (repo *GitHubGistRepository) VCS() (*VCSBackend, *url.URL, error) {\n\treturn GitBackend, repo.URL(), nil\n}\n\n// DarksHubRepository represents DarcsHub Repository\ntype DarksHubRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of darks repository\nfunc (repo *DarksHubRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the DarcsHub repository is valid or not\nfunc (repo *DarksHubRepository) IsValid() bool {\n\treturn strings.Count(repo.url.Path, \"/\") == 2\n}\n\n// VCS returns VCSBackend of the DarcsHub repository\nfunc (repo *DarksHubRepository) VCS() (*VCSBackend, *url.URL, error) {\n\treturn DarcsBackend, repo.URL(), nil\n}\n\n// NestPijulRepository represents the Nest repository\ntype NestPijulRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of the Nest repository\nfunc (repo *NestPijulRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the Nest repository is valid or not\nfunc (repo *NestPijulRepository) IsValid() bool {\n\treturn strings.Count(repo.url.Path, \"/\") == 2\n}\n\n// VCS returns VCSBackend of the Nest repository\nfunc (repo *NestPijulRepository) VCS() (*VCSBackend, *url.URL, error) {\n\treturn PijulBackend, repo.URL(), nil\n}\n\n// A CodeCommitRepository represents a CodeCommit repository. Implements RemoteRepository.\ntype CodeCommitRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of the repository\nfunc (repo *CodeCommitRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the repository is valid or not\nfunc (repo *CodeCommitRepository) IsValid() bool {\n\treturn true\n}\n\n// VCS returns VCSBackend of the repository\nfunc (repo *CodeCommitRepository) VCS() (*VCSBackend, *url.URL, error) {\n\tu := *repo.url\n\treturn GitBackend, &u, nil\n}\n\ntype ChiselRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of the repository\nfunc (repo *ChiselRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the repository is valid or not\nfunc (repo *ChiselRepository) IsValid() bool {\n\treturn true\n}\n\n// VCS returns VCSBackend of the repository\nfunc (repo *ChiselRepository) VCS() (*VCSBackend, *url.URL, error) {\n\treturn FossilBackend, repo.URL(), nil\n}\n\n// OtherRepository represents other repository\ntype OtherRepository struct {\n\turl *url.URL\n}\n\n// URL returns URL of the repository\nfunc (repo *OtherRepository) URL() *url.URL {\n\treturn repo.url\n}\n\n// IsValid determine if the repository is valid or not\nfunc (repo *OtherRepository) IsValid() bool {\n\treturn true\n}\n\nvar (\n\tvcsSchemeReg = regexp.MustCompile(`^(git|svn|bzr|codecommit)(?:\\+|$)`)\n\tscheme2vcs   = map[string]*VCSBackend{\n\t\t\"git\":        GitBackend,\n\t\t\"codecommit\": GitBackend,\n\t\t\"svn\":        SubversionBackend,\n\t\t\"bzr\":        BazaarBackend,\n\t}\n)\n\n// VCS detects VCSBackend of the OtherRepository\nfunc (repo *OtherRepository) VCS() (*VCSBackend, *url.URL, error) {\n\t// Respect 'ghq.url.https://ghe.example.com/.vcs' config variable\n\t// (in gitconfig:)\n\t//     [ghq \"https://ghe.example.com/\"]\n\t//     vcs = github\n\tvcs, err := gitconfig.Do(\"--path\", \"--get-urlmatch\", \"ghq.vcs\", repo.URL().String())\n\tif err != nil && !gitconfig.IsNotFound(err) {\n\t\tlogger.Log(\"error\", err.Error())\n\t}\n\tif backend, ok := vcsRegistry[vcs]; ok {\n\t\treturn backend, repo.URL(), nil\n\t}\n\n\tif m := vcsSchemeReg.FindStringSubmatch(repo.url.Scheme); len(m) > 1 {\n\t\treturn scheme2vcs[m[1]], repo.URL(), nil\n\t}\n\n\tmayBeSvn := strings.HasPrefix(repo.url.Host, \"svn.\")\n\tif mayBeSvn && cmdutil.RunSilently(\"svn\", \"info\", repo.url.String()) == nil {\n\t\treturn SubversionBackend, repo.URL(), nil\n\t}\n\n\t// Detect VCS backend\n\tif repo.url.Scheme == \"ssh\" && repo.url.User.Username() == \"git\" {\n\t\treturn GitBackend, repo.URL(), nil\n\t}\n\n\tswitch repo.url.Host {\n\tcase \"fossil-scm.org\", \"sqlite.org\":\n\t\treturn FossilBackend, repo.URL(), nil\n\t}\n\n\tif cmdutil.RunSilently(\"git\", \"ls-remote\", repo.url.String()) == nil {\n\t\treturn GitBackend, repo.URL(), nil\n\t}\n\n\tvcs, repoURL, err := detectGoImport(repo.url)\n\tif err == nil {\n\t\t// vcs == \"mod\" (modproxy) not supported yet\n\t\treturn vcsRegistry[vcs], repoURL, nil\n\t}\n\n\tif cmdutil.RunSilently(\"hg\", \"identify\", repo.url.String()) == nil {\n\t\treturn MercurialBackend, repo.URL(), nil\n\t}\n\n\tif !mayBeSvn && cmdutil.RunSilently(\"svn\", \"info\", repo.url.String()) == nil {\n\t\treturn SubversionBackend, repo.URL(), nil\n\t}\n\n\treturn nil, nil, fmt.Errorf(\"unsupported VCS, url=%s: %w\", repo.URL(), err)\n}\n\n// NewRemoteRepository returns new RemoteRepository object from URL\nfunc NewRemoteRepository(u *url.URL) (RemoteRepository, error) {\n\trepo := func() RemoteRepository {\n\t\tif u.Scheme == \"codecommit\" {\n\t\t\treturn &CodeCommitRepository{u}\n\t\t}\n\t\tswitch u.Host {\n\t\tcase \"github.com\":\n\t\t\treturn &GitHubRepository{u}\n\t\tcase \"gist.github.com\":\n\t\t\treturn &GitHubGistRepository{u}\n\t\tcase \"hub.darcs.net\":\n\t\t\treturn &DarksHubRepository{u}\n\t\tcase \"nest.pijul.com\":\n\t\t\treturn &NestPijulRepository{u}\n\t\tcase \"chiselapp.com\":\n\t\t\treturn &ChiselRepository{u}\n\t\tdefault:\n\t\t\treturn &OtherRepository{u}\n\t\t}\n\t}()\n\tif !repo.IsValid() {\n\t\treturn nil, fmt.Errorf(\"not a valid repository: %s\", u)\n\t}\n\treturn repo, nil\n}\n"
        },
        {
          "name": "remote_repository_test.go",
          "type": "blob",
          "size": 2.908203125,
          "content": "package main\n\nimport (\n\t\"testing\"\n)\n\nfunc TestNewRemoteRepository(t *testing.T) {\n\ttestCases := []struct {\n\t\turl        string\n\t\tvalid      bool\n\t\tvcsBackend *VCSBackend\n\t\trepoURL    string\n\t}{{\n\t\turl:        \"https://github.com/motemen/pusheen-explorer\",\n\t\tvalid:      true,\n\t\tvcsBackend: GitBackend,\n\t}, {\n\t\turl:        \"https://github.com/motemen/pusheen-explorer/\",\n\t\tvalid:      true,\n\t\tvcsBackend: GitBackend,\n\t}, {\n\t\turl:        \"https://github.com/motemen/ghq/logger\",\n\t\tvalid:      true,\n\t\tvcsBackend: GitBackend,\n\t\trepoURL:    \"https://github.com/motemen/ghq\",\n\t}, {\n\t\turl:        \"https://example.com/motemen/pusheen-explorer/\",\n\t\tvalid:      true,\n\t\tvcsBackend: nil,\n\t}, {\n\t\turl:        \"https://gist.github.com/motemen/9733745\",\n\t\tvalid:      true,\n\t\tvcsBackend: GitBackend,\n\t}, {\n\t\turl:        \"http://hub.darcs.net/foo/bar\",\n\t\tvalid:      true,\n\t\tvcsBackend: DarcsBackend,\n\t}, {\n\t\turl:        \"http://nest.pijul.com/foo/bar\",\n\t\tvalid:      true,\n\t\tvcsBackend: PijulBackend,\n\t}, {\n\t\turl:        \"svn+ssh://example.com/proj/repo\",\n\t\tvalid:      true,\n\t\tvcsBackend: SubversionBackend,\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.url, func(t *testing.T) {\n\t\t\trepo, err := NewRemoteRepository(mustParseURL(tc.url))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif repo.IsValid() != tc.valid {\n\t\t\t\tt.Errorf(\"repo.IsValid() should be %v, but %v\", tc.valid, repo.IsValid())\n\t\t\t}\n\t\t\tvcs, u, _ := repo.VCS()\n\t\t\tif vcs != tc.vcsBackend {\n\t\t\t\tt.Errorf(\"got: %+v, expect: %+v\", vcs, tc.vcsBackend)\n\t\t\t}\n\t\t\tif tc.repoURL != \"\" {\n\t\t\t\tif u.String() != tc.repoURL {\n\t\t\t\t\tt.Errorf(\"repoURL: got: %s, expect: %s\", u.String(), tc.repoURL)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewRemoteRepository_vcs_error(t *testing.T) {\n\ttestCases := []struct {\n\t\turl        string\n\t\tvalid      bool\n\t\tvcsBackend *VCSBackend\n\t\trepoURL    string\n\t}{{\n\t\turl:        \"https://example.com/motemen/pusheen-explorer/\",\n\t\tvalid:      true,\n\t\tvcsBackend: nil,\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.url, func(t *testing.T) {\n\t\t\trepo, err := NewRemoteRepository(mustParseURL(tc.url))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif repo.IsValid() != tc.valid {\n\t\t\t\tt.Errorf(\"repo.IsValid() should be %v, but %v\", tc.valid, repo.IsValid())\n\t\t\t}\n\t\t\tvcs, u, err := repo.VCS()\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif vcs != tc.vcsBackend {\n\t\t\t\tt.Errorf(\"got: %+v, expect: %+v\", vcs, tc.vcsBackend)\n\t\t\t}\n\t\t\tif u != nil {\n\t\t\t\tt.Errorf(\"u should be nil: %s\", u.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewRemoteRepository_error(t *testing.T) {\n\ttestCases := []struct {\n\t\turl string\n\t}{{\n\t\turl: \"https://github.com/blog/github\",\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.url, func(t *testing.T) {\n\t\t\trepo, err := NewRemoteRepository(mustParseURL(tc.url))\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif repo != nil {\n\t\t\t\tt.Errorf(\"repo should be nil: %v\", repo)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "typos.toml",
          "type": "blob",
          "size": 0.150390625,
          "content": "# See https://github.com/crate-ci/typos/blob/master/docs/reference.md to configure typos\n[default.extend-words]\n[files]\nextend-exclude = [\"CHANGELOG.md\"]\n"
        },
        {
          "name": "url.go",
          "type": "blob",
          "size": 5.498046875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/Songmu/gitconfig\"\n\t\"github.com/x-motemen/ghq/logger\"\n)\n\n// Convert SCP-like URL to SSH URL(e.g. [user@]host.xz:path/to/repo.git/)\n// ref. http://git-scm.com/docs/git-fetch#_git_urls\n// (golang hasn't supported Perl-like negative look-behind match)\nvar (\n\thasSchemePattern          = regexp.MustCompile(\"^[^:]+://\")\n\tscpLikeURLPattern         = regexp.MustCompile(\"^([^@]+@)?([^:]+):(/?.+)$\")\n\tlooksLikeAuthorityPattern = regexp.MustCompile(`[A-Za-z0-9]\\.[A-Za-z]+(?::\\d{1,5})?$`)\n\tcodecommitLikeURLPattern  = regexp.MustCompile(`^(codecommit):(?::([a-z][a-z0-9-]+):)?//(?:([^]]+)@)?([\\w\\.-]+)$`)\n)\n\nfunc newURL(ref string, ssh, forceMe bool) (*url.URL, error) {\n\t// If argURL is a \"./foo\" or \"../bar\" form,\n\t// find repository name trailing after github.com/USER/.\n\tref = filepath.ToSlash(ref)\n\tparts := strings.Split(ref, \"/\")\n\tif parts[0] == \".\" || parts[0] == \"..\" {\n\t\tif wd, err := os.Getwd(); err == nil {\n\t\t\tpath := filepath.Clean(filepath.Join(wd, filepath.Join(parts...)))\n\n\t\t\tvar localRepoRoot string\n\t\t\troots, err := localRepositoryRoots(true)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfor _, r := range roots {\n\t\t\t\tp := strings.TrimPrefix(path, r+string(filepath.Separator))\n\t\t\t\tif p != path && (localRepoRoot == \"\" || len(p) < len(localRepoRoot)) {\n\t\t\t\t\tlocalRepoRoot = filepath.ToSlash(p)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif localRepoRoot != \"\" {\n\t\t\t\t// Guess it\n\t\t\t\tlogger.Log(\"resolved\", fmt.Sprintf(\"relative %q to %q\", ref, \"https://\"+localRepoRoot))\n\t\t\t\tref = \"https://\" + localRepoRoot\n\t\t\t}\n\t\t}\n\t}\n\n\tif codecommitLikeURLPattern.MatchString(ref) {\n\t\t// SEE ALSO:\n\t\t// https://github.com/aws/git-remote-codecommit/blob/master/git_remote_codecommit/__init__.py#L68\n\t\tmatched := codecommitLikeURLPattern.FindStringSubmatch(ref)\n\t\tregion := matched[2]\n\n\t\tif matched[2] == \"\" {\n\t\t\t// Region detection priority:\n\t\t\t// 1. Explicit specification (codecommit::region://...)\n\t\t\t// 2. Environment variables\n\t\t\t//     a. AWS_REGION (implicit priority)\n\t\t\t//     b. AWS_DEFAULT_REGION\n\t\t\t// 3. AWS CLI profiles\n\t\t\t// SEE ALSO:\n\t\t\t// https://docs.aws.amazon.com/ja_jp/cli/latest/userguide/cli-configure-quickstart.html#cli-configure-quickstart-precedence\n\t\t\tvar exists bool\n\t\t\tregion, exists = os.LookupEnv(\"AWS_REGION\")\n\t\t\tif !exists {\n\t\t\t\tregion, exists = os.LookupEnv(\"AWS_DEFAULT_REGION\")\n\t\t\t}\n\n\t\t\tif !exists {\n\t\t\t\tvar stdout bytes.Buffer\n\t\t\t\tvar stderr bytes.Buffer\n\n\t\t\t\tcmd := exec.Command(\"aws\", \"configure\", \"get\", \"region\")\n\t\t\t\tcmd.Stdout = &stdout\n\t\t\t\tcmd.Stderr = &stderr\n\n\t\t\t\terr := cmd.Run()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif stderr.String() == \"\" {\n\t\t\t\t\t\tfmt.Fprintln(os.Stderr, \"You must specify a region. You can also configure your region by running \\\"aws configure\\\".\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfmt.Fprint(os.Stderr, stderr.String())\n\t\t\t\t\t}\n\t\t\t\t\tos.Exit(1)\n\t\t\t\t}\n\n\t\t\t\tregion = strings.TrimSpace(stdout.String())\n\t\t\t}\n\t\t}\n\n\t\treturn &url.URL{\n\t\t\tScheme: matched[1],\n\t\t\tHost:   region,\n\t\t\tUser:   url.User(matched[3]),\n\t\t\tPath:   matched[4],\n\t\t\tOpaque: ref,\n\t\t}, nil\n\t}\n\n\tif !hasSchemePattern.MatchString(ref) {\n\t\tif scpLikeURLPattern.MatchString(ref) {\n\t\t\tmatched := scpLikeURLPattern.FindStringSubmatch(ref)\n\t\t\tuser := matched[1]\n\t\t\thost := matched[2]\n\t\t\tpath := matched[3]\n\t\t\t// If the path is a relative path not beginning with a slash like\n\t\t\t// `path/to/repo`, we might convert to like\n\t\t\t// `ssh://user@repo.example.com/~/path/to/repo` using tilde, but\n\t\t\t// since GitHub doesn't support it, we treat relative and absolute\n\t\t\t// paths the same way.\n\t\t\tref = fmt.Sprintf(\"ssh://%s%s/%s\", user, host, strings.TrimPrefix(path, \"/\"))\n\t\t} else {\n\t\t\t// If ref is like \"github.com/motemen/ghq\" convert to \"https://github.com/motemen/ghq\"\n\t\t\tpaths := strings.Split(ref, \"/\")\n\t\t\tif len(paths) > 1 && looksLikeAuthorityPattern.MatchString(paths[0]) {\n\t\t\t\tref = \"https://\" + ref\n\t\t\t}\n\t\t}\n\t}\n\n\tu, err := url.Parse(ref)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !u.IsAbs() {\n\t\tif !strings.Contains(u.Path, \"/\") {\n\t\t\tu.Path, err = fillUsernameToPath(u.Path, forceMe)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tu.Scheme = \"https\"\n\t\tu.Host = \"github.com\"\n\t\tif u.Path[0] != '/' {\n\t\t\tu.Path = \"/\" + u.Path\n\t\t}\n\t}\n\n\tif ssh {\n\t\t// Assume Git repository if `-p` is given.\n\t\tif u, err = convertGitURLHTTPToSSH(u); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not convert URL %q: %w\", u, err)\n\t\t}\n\t}\n\n\treturn u, nil\n}\n\nfunc convertGitURLHTTPToSSH(u *url.URL) (*url.URL, error) {\n\tuser := \"git\"\n\tif u.User != nil {\n\t\tuser = u.User.Username()\n\t}\n\tsshURL := fmt.Sprintf(\"ssh://%s@%s%s\", user, u.Host, u.Path)\n\treturn u.Parse(sshURL)\n}\n\nfunc detectUserName() (string, error) {\n\tuser, err := gitconfig.Get(\"ghq.user\")\n\tif (err != nil && !gitconfig.IsNotFound(err)) || user != \"\" {\n\t\treturn user, err\n\t}\n\n\tuser, err = gitconfig.GitHubUser(\"\")\n\tif (err != nil && !gitconfig.IsNotFound(err)) || user != \"\" {\n\t\treturn user, err\n\t}\n\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tuser = os.Getenv(\"USERNAME\")\n\tdefault:\n\t\tuser = os.Getenv(\"USER\")\n\t}\n\tif user == \"\" {\n\t\t// Make the error if it does not match any pattern\n\t\treturn \"\", fmt.Errorf(\"failed to detect username. You can set ghq.user to your gitconfig\")\n\t}\n\treturn user, nil\n}\n\nfunc fillUsernameToPath(path string, forceMe bool) (string, error) {\n\tif !forceMe {\n\t\tcompleteUser, err := gitconfig.Bool(\"ghq.completeUser\")\n\t\tif err != nil && !gitconfig.IsNotFound(err) {\n\t\t\treturn path, err\n\t\t}\n\t\tif err == nil && !completeUser {\n\t\t\treturn path + \"/\" + path, nil\n\t\t}\n\t}\n\tuser, err := detectUserName()\n\tif err != nil {\n\t\treturn path, err\n\t}\n\treturn user + \"/\" + path, nil\n}\n"
        },
        {
          "name": "url_test.go",
          "type": "blob",
          "size": 4.1826171875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/Songmu/gitconfig\"\n)\n\nfunc TestNewURL(t *testing.T) {\n\ttestCases := []struct {\n\t\tname, url, expect, host string\n\t\tsetup                   func(t *testing.T)\n\t}{{\n\t\tname:   \"https\", // Does nothing when the URL has scheme part\n\t\turl:    \"https://github.com/motemen/pusheen-explorer\",\n\t\texpect: \"https://github.com/motemen/pusheen-explorer\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname:   \"scp\", // Convert SCP-like URL to SSH URL\n\t\turl:    \"git@github.com:motemen/pusheen-explorer.git\",\n\t\texpect: \"ssh://git@github.com/motemen/pusheen-explorer.git\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname:   \"scp with root\",\n\t\turl:    \"git@github.com:/motemen/pusheen-explorer.git\",\n\t\texpect: \"ssh://git@github.com/motemen/pusheen-explorer.git\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname:   \"scp without user\",\n\t\turl:    \"github.com:motemen/pusheen-explorer.git\",\n\t\texpect: \"ssh://github.com/motemen/pusheen-explorer.git\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname:   \"different name repository\",\n\t\turl:    \"motemen/ghq\",\n\t\texpect: \"https://github.com/motemen/ghq\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname:   \"with authority repository\",\n\t\turl:    \"github.com/motemen/gore\",\n\t\texpect: \"https://github.com/motemen/gore\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname:   \"with authority repository and go-import\",\n\t\turl:    \"golang.org/x/crypto\",\n\t\texpect: \"https://golang.org/x/crypto\",\n\t\thost:   \"golang.org\",\n\t}, {\n\t\tname: \"fill username\",\n\t\tsetup: func(t *testing.T) {\n\t\t\tsetEnv(t, \"GITHUB_USER\", \"ghq-test\")\n\t\t},\n\t\turl:    \"same-name-ghq\",\n\t\texpect: \"https://github.com/ghq-test/same-name-ghq\",\n\t\thost:   \"github.com\",\n\t}, {\n\t\tname: \"same name repository\",\n\t\tsetup: func(t *testing.T) {\n\t\t\tt.Cleanup(gitconfig.WithConfig(t, `[ghq]\ncompleteUser = false`))\n\t\t},\n\t\turl:    \"peco\",\n\t\texpect: \"https://github.com/peco/peco\",\n\t\thost:   \"github.com\",\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif tc.setup != nil {\n\t\t\t\ttc.setup(t)\n\t\t\t}\n\t\t\trepo, err := newURL(tc.url, false, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif repo.String() != tc.expect {\n\t\t\t\tt.Errorf(\"url: got: %s, expect: %s\", repo.String(), tc.expect)\n\t\t\t}\n\t\t\tif repo.Host != tc.host {\n\t\t\t\tt.Errorf(\"host: got: %s, expect: %s\", repo.Host, tc.host)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConvertGitURLHTTPToSSH(t *testing.T) {\n\ttestCases := []struct {\n\t\turl, expect string\n\t}{{\n\t\turl:    \"https://github.com/motemen/pusheen-explorer\",\n\t\texpect: \"ssh://git@github.com/motemen/pusheen-explorer\",\n\t}, {\n\t\turl:    \"https://ghe.example.com/motemen/pusheen-explorer\",\n\t\texpect: \"ssh://git@ghe.example.com/motemen/pusheen-explorer\",\n\t}, {\n\t\turl:    \"https://motemen@ghe.example.com/motemen/pusheen-explorer\",\n\t\texpect: \"ssh://motemen@ghe.example.com/motemen/pusheen-explorer\",\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.url, func(t *testing.T) {\n\t\t\thttpsURL, err := newURL(tc.url, false, false)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tsshURL, err := convertGitURLHTTPToSSH(httpsURL)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"error should be nil but: %s\", err)\n\t\t\t}\n\t\t\tif sshURL.String() != tc.expect {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", sshURL.String(), tc.expect)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNewURL_err(t *testing.T) {\n\tinvalidURL := \"http://foo.com/?foo\\nbar\"\n\t_, err := newURL(invalidURL, false, false)\n\tconst wantSub = \"net/url: invalid control character in URL\"\n\tif got := fmt.Sprint(err); !strings.Contains(got, wantSub) {\n\t\tt.Errorf(\"newURL(%q, false, false) error = %q; want substring %q\", invalidURL, got, wantSub)\n\t}\n\tt.Cleanup(gitconfig.WithConfig(t, `[[[`))\n\n\tvar exitError *exec.ExitError\n\t_, err = newURL(\"peco\", false, false)\n\tif !errors.As(err, &exitError) {\n\t\tt.Errorf(\"error should be occurred but nil\")\n\t}\n}\n\nfunc TestFillUsernameToPath_err(t *testing.T) {\n\tfor _, envStr := range []string{\"GITHUB_USER\", \"GITHUB_TOKEN\", \"USER\", \"USERNAME\"} {\n\t\tsetEnv(t, envStr, \"\")\n\t}\n\tsetEnv(t, \"XDG_CONFIG_HOME\", \"/dummy/dummy\")\n\n\tusr, err := fillUsernameToPath(\"peco\", false)\n\tt.Log(usr)\n\tconst wantSub = \"set ghq.user to your gitconfig\"\n\tif got := fmt.Sprint(err); !strings.Contains(got, wantSub) {\n\t\tt.Errorf(\"fillUsernameToPath(peco, false) error = %q; want substring %q\", got, wantSub)\n\t}\n}\n"
        },
        {
          "name": "vcs.go",
          "type": "blob",
          "size": 10.2470703125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/x-motemen/ghq/cmdutil\"\n)\n\nfunc run(silent bool) func(command string, args ...string) error {\n\tif silent {\n\t\treturn cmdutil.RunSilently\n\t}\n\treturn cmdutil.Run\n}\n\nfunc runInDir(silent bool) func(dir, command string, args ...string) error {\n\tif silent {\n\t\treturn cmdutil.RunInDirSilently\n\t}\n\treturn cmdutil.RunInDir\n}\n\n// A VCSBackend represents a VCS backend.\ntype VCSBackend struct {\n\t// Clones a remote repository to local path.\n\tClone func(*vcsGetOption) error\n\t// Updates a cloned local repository.\n\tUpdate func(*vcsGetOption) error\n\tInit   func(dir string) error\n\t// Returns VCS specific files\n\tContents []string\n}\n\ntype vcsGetOption struct {\n\turl                              *url.URL\n\tdir                              string\n\trecursive, shallow, silent, bare bool\n\tbranch                           string\n}\n\n// GitBackend is the VCSBackend of git\nvar GitBackend = &VCSBackend{\n\t// support submodules?\n\tClone: func(vg *vcsGetOption) error {\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\targs := []string{\"clone\"}\n\t\tif vg.shallow {\n\t\t\targs = append(args, \"--depth\", \"1\")\n\t\t}\n\t\tif vg.branch != \"\" {\n\t\t\targs = append(args, \"--branch\", vg.branch, \"--single-branch\")\n\t\t}\n\t\tif vg.recursive {\n\t\t\targs = append(args, \"--recursive\")\n\t\t}\n\t\tif vg.bare {\n\t\t\targs = append(args, \"--bare\")\n\t\t}\n\t\targs = append(args, vg.url.String(), vg.dir)\n\n\t\treturn run(vg.silent)(\"git\", args...)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\tif _, err := os.Stat(filepath.Join(vg.dir, \".git/svn\")); err == nil {\n\t\t\treturn GitsvnBackend.Update(vg)\n\t\t}\n\t\tif vg.bare {\n\t\t\treturn runInDir(true)(vg.dir, \"git\", \"fetch\", vg.url.String(), \"*:*\")\n\t\t}\n\t\terr := runInDir(true)(vg.dir, \"git\", \"rev-parse\", \"@{upstream}\")\n\t\tif err != nil {\n\t\t\terr := runInDir(vg.silent)(vg.dir, \"git\", \"fetch\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\terr = runInDir(vg.silent)(vg.dir, \"git\", \"pull\", \"--ff-only\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif vg.recursive {\n\t\t\treturn runInDir(vg.silent)(vg.dir, \"git\", \"submodule\", \"update\", \"--init\", \"--recursive\")\n\t\t}\n\t\treturn nil\n\t},\n\tInit: func(dir string) error {\n\t\targs := []string{\"init\"}\n\t\tif strings.HasSuffix(dir, \".git\") {\n\t\t\targs = append(args, \"--bare\")\n\t\t}\n\t\treturn cmdutil.RunInDir(dir, \"git\", args...)\n\t},\n\tContents: []string{\".git\"},\n}\n\n/*\nIf the svn target is under standard svn directory structure, \"ghq\" canonicalizes the checkout path.\nFor example, all following targets are checked-out into `$(ghq root)/svn.example.com/proj/repo`.\n\n- svn.example.com/proj/repo\n- svn.example.com/proj/repo/trunk\n- svn.example.com/proj/repo/branches/featureN\n- svn.example.com/proj/repo/tags/v1.0.1\n\nAddition, when the svn target may be project root, \"ghq\" tries to checkout \"/trunk\".\n\nThis checkout rule is also applied when using \"git-svn\".\n*/\n\nconst trunk = \"/trunk\"\n\nvar svnReg = regexp.MustCompile(`/(?:tags|branches)/[^/]+$`)\n\nfunc replaceOnce(reg *regexp.Regexp, str, replace string) string {\n\treplaced := false\n\treturn reg.ReplaceAllStringFunc(str, func(match string) string {\n\t\tif replaced {\n\t\t\treturn match\n\t\t}\n\t\treplaced = true\n\t\treturn reg.ReplaceAllString(match, replace)\n\t})\n}\n\nfunc svnBase(p string) string {\n\tif strings.HasSuffix(p, trunk) {\n\t\treturn strings.TrimSuffix(p, trunk)\n\t}\n\treturn replaceOnce(svnReg, p, \"\")\n}\n\n// SubversionBackend is the VCSBackend for subversion\nvar SubversionBackend = &VCSBackend{\n\tClone: func(vg *vcsGetOption) error {\n\t\tvg.dir = svnBase(vg.dir)\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\targs := []string{\"checkout\"}\n\t\tif vg.shallow {\n\t\t\targs = append(args, \"--depth\", \"immediates\")\n\t\t}\n\t\tremote := vg.url\n\t\tif vg.branch != \"\" {\n\t\t\tcopied := *vg.url\n\t\t\tremote = &copied\n\t\t\tremote.Path = svnBase(remote.Path)\n\t\t\tremote.Path += \"/branches/\" + url.PathEscape(vg.branch)\n\t\t} else if !strings.HasSuffix(remote.Path, trunk) {\n\t\t\tcopied := *vg.url\n\t\t\tcopied.Path += trunk\n\t\t\tif err := cmdutil.RunSilently(\"svn\", \"info\", copied.String()); err == nil {\n\t\t\t\tremote = &copied\n\t\t\t}\n\t\t}\n\t\targs = append(args, remote.String(), vg.dir)\n\n\t\treturn run(vg.silent)(\"svn\", args...)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn runInDir(vg.silent)(vg.dir, \"svn\", \"update\")\n\t},\n\tContents: []string{\".svn\"},\n}\n\nvar svnLastRevReg = regexp.MustCompile(`(?m)^Last Changed Rev: (\\d+)$`)\n\n// GitsvnBackend is the VCSBackend for git-svn\nvar GitsvnBackend = &VCSBackend{\n\tClone: func(vg *vcsGetOption) error {\n\t\torig := vg.dir\n\t\tvg.dir = svnBase(vg.dir)\n\t\tstandard := orig == vg.dir\n\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar getSvnInfo = func(u string) (string, error) {\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\tcmd := exec.Command(\"svn\", \"info\", u)\n\t\t\tcmd.Stdout = buf\n\t\t\tcmd.Stderr = io.Discard\n\t\t\terr := cmdutil.RunCommand(cmd, true)\n\t\t\treturn buf.String(), err\n\t\t}\n\t\tvar svnInfo string\n\t\targs := []string{\"svn\", \"clone\"}\n\t\tremote := vg.url\n\t\tif vg.branch != \"\" {\n\t\t\tcopied := *remote\n\t\t\tremote = &copied\n\t\t\tremote.Path = svnBase(remote.Path)\n\t\t\tremote.Path += \"/branches/\" + url.PathEscape(vg.branch)\n\t\t\tstandard = false\n\t\t} else if standard {\n\t\t\tcopied := *remote\n\t\t\tcopied.Path += trunk\n\t\t\tinfo, err := getSvnInfo(copied.String())\n\t\t\tif err == nil {\n\t\t\t\targs = append(args, \"-s\")\n\t\t\t\tsvnInfo = info\n\t\t\t} else {\n\t\t\t\tstandard = false\n\t\t\t}\n\t\t}\n\n\t\tif vg.shallow {\n\t\t\tif svnInfo == \"\" {\n\t\t\t\tinfo, err := getSvnInfo(remote.String())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsvnInfo = info\n\t\t\t}\n\t\t\tm := svnLastRevReg.FindStringSubmatch(svnInfo)\n\t\t\tif len(m) < 2 {\n\t\t\t\treturn fmt.Errorf(\"no revisions are taken from svn info output: %s\", svnInfo)\n\t\t\t}\n\t\t\targs = append(args, fmt.Sprintf(\"-r%s:HEAD\", m[1]))\n\t\t}\n\t\targs = append(args, remote.String(), vg.dir)\n\t\treturn run(vg.silent)(\"git\", args...)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn runInDir(vg.silent)(vg.dir, \"git\", \"svn\", \"rebase\")\n\t},\n\tContents: []string{\".git/svn\"},\n}\n\n// MercurialBackend is the VCSBackend for mercurial\nvar MercurialBackend = &VCSBackend{\n\t// Mercurial seems not supporting shallow clone currently.\n\tClone: func(vg *vcsGetOption) error {\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\targs := []string{\"clone\"}\n\t\tif vg.branch != \"\" {\n\t\t\targs = append(args, \"--branch\", vg.branch)\n\t\t}\n\t\targs = append(args, vg.url.String(), vg.dir)\n\n\t\treturn run(vg.silent)(\"hg\", args...)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn runInDir(vg.silent)(vg.dir, \"hg\", \"pull\", \"--update\")\n\t},\n\tInit: func(dir string) error {\n\t\treturn cmdutil.RunInDir(dir, \"hg\", \"init\")\n\t},\n\tContents: []string{\".hg\"},\n}\n\n// DarcsBackend is the VCSBackend for darcs\nvar DarcsBackend = &VCSBackend{\n\tClone: func(vg *vcsGetOption) error {\n\t\tif vg.branch != \"\" {\n\t\t\treturn errors.New(\"darcs does not support branch\")\n\t\t}\n\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\targs := []string{\"get\"}\n\t\tif vg.shallow {\n\t\t\targs = append(args, \"--lazy\")\n\t\t}\n\t\targs = append(args, vg.url.String(), vg.dir)\n\n\t\treturn run(vg.silent)(\"darcs\", args...)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn runInDir(vg.silent)(vg.dir, \"darcs\", \"pull\")\n\t},\n\tInit: func(dir string) error {\n\t\treturn cmdutil.RunInDir(dir, \"darcs\", \"init\")\n\t},\n\tContents: []string{\"_darcs\"},\n}\n\n// PijulBackend is the VCSBackend for pijul\nvar PijulBackend = &VCSBackend{\n\tClone: func(vg *vcsGetOption) error {\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\targs := []string{\"clone\"}\n\t\tif vg.branch != \"\" {\n\t\t\targs = append(args, \"--channel\", vg.branch)\n\t\t}\n\t\targs = append(args, vg.url.String(), vg.dir)\n\n\t\treturn run(vg.silent)(\"pijul\", args...)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn runInDir(vg.silent)(vg.dir, \"pijul\", \"pull\")\n\t},\n\tInit: func(dir string) error {\n\t\treturn cmdutil.RunInDir(dir, \"pijul\", \"init\")\n\t},\n\tContents: []string{\".pijul\"},\n}\n\nvar cvsDummyBackend = &VCSBackend{\n\tClone: func(vg *vcsGetOption) error {\n\t\treturn errors.New(\"CVS clone is not supported\")\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn errors.New(\"CVS update is not supported\")\n\t},\n\tContents: []string{\"CVS/Repository\"},\n}\n\nconst fossilRepoName = \".fossil\" // same as Go\n\n// FossilBackend is the VCSBackend for fossil\nvar FossilBackend = &VCSBackend{\n\tClone: func(vg *vcsGetOption) error {\n\t\tif vg.branch != \"\" {\n\t\t\treturn errors.New(\"fossil does not support cloning specific branch\")\n\t\t}\n\t\tif err := os.MkdirAll(vg.dir, 0755); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := run(vg.silent)(\"fossil\", \"clone\", vg.url.String(), filepath.Join(vg.dir, fossilRepoName)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn runInDir(vg.silent)(vg.dir, \"fossil\", \"open\", fossilRepoName)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\treturn runInDir(vg.silent)(vg.dir, \"fossil\", \"update\")\n\t},\n\tInit: func(dir string) error {\n\t\tif err := cmdutil.RunInDir(dir, \"fossil\", \"init\", fossilRepoName); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn cmdutil.RunInDir(dir, \"fossil\", \"open\", fossilRepoName)\n\t},\n\tContents: []string{\".fslckout\", \"_FOSSIL_\"},\n}\n\n// BazaarBackend is the VCSBackend for bazaar\nvar BazaarBackend = &VCSBackend{\n\t// bazaar seems not supporting shallow clone currently.\n\tClone: func(vg *vcsGetOption) error {\n\t\tif vg.branch != \"\" {\n\t\t\treturn errors.New(\"--branch option is unavailable for Bazaar since branch is included in remote URL\")\n\t\t}\n\t\tdir, _ := filepath.Split(vg.dir)\n\t\terr := os.MkdirAll(dir, 0755)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn run(vg.silent)(\"bzr\", \"branch\", vg.url.String(), vg.dir)\n\t},\n\tUpdate: func(vg *vcsGetOption) error {\n\t\t// Without --overwrite bzr will not pull tags that changed.\n\t\treturn runInDir(vg.silent)(vg.dir, \"bzr\", \"pull\", \"--overwrite\")\n\t},\n\tInit: func(dir string) error {\n\t\treturn cmdutil.RunInDir(dir, \"bzr\", \"init\")\n\t},\n\tContents: []string{\".bzr\"},\n}\n\nvar vcsRegistry = map[string]*VCSBackend{\n\t\"git\":        GitBackend,\n\t\"github\":     GitBackend,\n\t\"codecommit\": GitBackend,\n\t\"svn\":        SubversionBackend,\n\t\"subversion\": SubversionBackend,\n\t\"git-svn\":    GitsvnBackend,\n\t\"hg\":         MercurialBackend,\n\t\"mercurial\":  MercurialBackend,\n\t\"darcs\":      DarcsBackend,\n\t\"pijul\":      PijulBackend,\n\t\"fossil\":     FossilBackend,\n\t\"bzr\":        BazaarBackend,\n\t\"bazaar\":     BazaarBackend,\n}\n"
        },
        {
          "name": "vcs_test.go",
          "type": "blob",
          "size": 12.2744140625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/x-motemen/ghq/cmdutil\"\n)\n\nvar (\n\tremoteDummyURL = mustParseURL(\"https://example.com/git/repo\")\n\tdummySvnInfo   = []byte(`Path: trunk\nURL: https://svn.apache.org/repos/asf/subversion/trunk\nRelative URL: ^/subversion/trunk\nRepository Root: https://svn.apache.org/repos/asf\nRepository UUID: 13f79535-47bb-0310-9956-ffa450edef68\nRevision: 1872085\nNode Kind: directory\nLast Changed Author: julianfoad\nLast Changed Rev: 1872031\nLast Changed Date: 2019-08-16 15:16:45 +0900 (Fri, 16 Aug 2019)\n`)\n)\n\nfunc TestVCSBackend(t *testing.T) {\n\ttempDir := newTempDir(t)\n\tlocalDir := filepath.Join(tempDir, \"repo\")\n\tvar _commands []*exec.Cmd\n\tlastCommand := func() *exec.Cmd { return _commands[len(_commands)-1] }\n\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\tcmdutil.CommandRunner = orig\n\t}(cmdutil.CommandRunner)\n\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t_commands = append(_commands, cmd)\n\t\tif reflect.DeepEqual(cmd.Args, []string{\"svn\", \"info\", \"https://example.com/git/repo/trunk\"}) {\n\t\t\treturn fmt.Errorf(\"[test] failed to svn info\")\n\t\t}\n\t\treturn nil\n\t}\n\n\ttestCases := []struct {\n\t\tname   string\n\t\tf      func() error\n\t\texpect []string\n\t\tdir    string\n\t}{{\n\t\tname: \"[git] clone\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"clone\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git] shallow clone\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     remoteDummyURL,\n\t\t\t\tdir:     localDir,\n\t\t\t\tshallow: true,\n\t\t\t\tsilent:  true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"clone\", \"--depth\", \"1\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git] clone specific branch\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Clone(&vcsGetOption{\n\t\t\t\turl:    remoteDummyURL,\n\t\t\t\tdir:    localDir,\n\t\t\t\tbranch: \"hello\",\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"clone\", \"--branch\", \"hello\", \"--single-branch\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git] update\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"pull\", \"--ff-only\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[git] fetch\",\n\t\tf: func() error {\n\t\t\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\t\t\tcmdutil.CommandRunner = orig\n\t\t\t}(cmdutil.CommandRunner)\n\t\t\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t\t\t_commands = append(_commands, cmd)\n\t\t\t\tif reflect.DeepEqual(cmd.Args, []string{\"git\", \"rev-parse\", \"@{upstream}\"}) {\n\t\t\t\t\treturn fmt.Errorf(\"[test] failed to git rev-parse @{upstream}\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn GitBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"fetch\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[git] recursive\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Clone(&vcsGetOption{\n\t\t\t\turl:       remoteDummyURL,\n\t\t\t\tdir:       localDir,\n\t\t\t\trecursive: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"clone\", \"--recursive\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git] update recursive\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Update(&vcsGetOption{\n\t\t\t\tdir:       localDir,\n\t\t\t\trecursive: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[git] bare clone\",\n\t\tf: func() error {\n\t\t\treturn GitBackend.Clone(&vcsGetOption{\n\t\t\t\turl:    remoteDummyURL,\n\t\t\t\tdir:    localDir,\n\t\t\t\tbare:   true,\n\t\t\t\tsilent: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"clone\", \"--bare\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git] switch git-svn on update\",\n\t\tf: func() error {\n\t\t\terr := os.MkdirAll(filepath.Join(localDir, \".git\", \"svn\"), 0755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer os.RemoveAll(filepath.Join(localDir, \".git\"))\n\t\t\treturn GitBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"svn\", \"rebase\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[svn] checkout\",\n\t\tf: func() error {\n\t\t\treturn SubversionBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"svn\", \"checkout\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[svn] checkout shallow\",\n\t\tf: func() error {\n\t\t\treturn SubversionBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     remoteDummyURL,\n\t\t\t\tdir:     localDir,\n\t\t\t\tshallow: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"svn\", \"checkout\", \"--depth\", \"immediates\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[svn] checkout specific branch\",\n\t\tf: func() error {\n\t\t\treturn SubversionBackend.Clone(&vcsGetOption{\n\t\t\t\turl:    remoteDummyURL,\n\t\t\t\tdir:    localDir,\n\t\t\t\tbranch: \"hello\",\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"svn\", \"checkout\", remoteDummyURL.String() + \"/branches/hello\", localDir},\n\t}, {\n\t\tname: \"[svn] checkout with filling trunk\",\n\t\tf: func() error {\n\t\t\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\t\t\tcmdutil.CommandRunner = orig\n\t\t\t}(cmdutil.CommandRunner)\n\t\t\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t\t\t_commands = append(_commands, cmd)\n\t\t\t\tif reflect.DeepEqual(cmd.Args, []string{\"svn\", \"info\", \"https://example.com/git/repo/trunk\"}) {\n\t\t\t\t\tcmd.Stdout.Write(dummySvnInfo)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn SubversionBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"svn\", \"checkout\", remoteDummyURL.String() + \"/trunk\", localDir},\n\t}, {\n\t\tname: \"[svn] update\",\n\t\tf: func() error {\n\t\t\treturn SubversionBackend.Update(&vcsGetOption{\n\t\t\t\tdir:    localDir,\n\t\t\t\tsilent: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"svn\", \"update\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[git-svn] clone\",\n\t\tf: func() error {\n\t\t\treturn GitsvnBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"svn\", \"clone\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git-svn] update\",\n\t\tf: func() error {\n\t\t\treturn GitsvnBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"svn\", \"rebase\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[git-svn] clone shallow\",\n\t\tf: func() error {\n\t\t\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\t\t\tcmdutil.CommandRunner = orig\n\t\t\t}(cmdutil.CommandRunner)\n\t\t\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t\t\t_commands = append(_commands, cmd)\n\t\t\t\tif reflect.DeepEqual(cmd.Args, []string{\"svn\", \"info\", \"https://example.com/git/repo/trunk\"}) {\n\t\t\t\t\tcmd.Stdout.Write(dummySvnInfo)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn GitsvnBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     remoteDummyURL,\n\t\t\t\tdir:     localDir,\n\t\t\t\tshallow: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"svn\", \"clone\", \"-s\", \"-r1872031:HEAD\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[git-svn] clone specific branch\",\n\t\tf: func() error {\n\t\t\treturn GitsvnBackend.Clone(&vcsGetOption{\n\t\t\t\turl:    remoteDummyURL,\n\t\t\t\tdir:    localDir,\n\t\t\t\tbranch: \"hello\",\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"git\", \"svn\", \"clone\", remoteDummyURL.String() + \"/branches/hello\", localDir},\n\t}, {\n\t\tname: \"[git-svn] clone specific branch from tagged URL with shallow\",\n\t\tf: func() error {\n\t\t\tdefer func(orig func(cmd *exec.Cmd) error) {\n\t\t\t\tcmdutil.CommandRunner = orig\n\t\t\t}(cmdutil.CommandRunner)\n\t\t\tcmdutil.CommandRunner = func(cmd *exec.Cmd) error {\n\t\t\t\t_commands = append(_commands, cmd)\n\t\t\t\tif reflect.DeepEqual(\n\t\t\t\t\tcmd.Args, []string{\"svn\", \"info\", \"https://example.com/git/repo/branches/develop\"},\n\t\t\t\t) {\n\t\t\t\t\tcmd.Stdout.Write(dummySvnInfo)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tcopied := *remoteDummyURL\n\t\t\tcopied.Path += \"/tags/v9.9.9\"\n\t\t\treturn GitsvnBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     &copied,\n\t\t\t\tdir:     localDir,\n\t\t\t\tbranch:  \"develop\",\n\t\t\t\tshallow: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\n\t\t\t\"git\", \"svn\", \"clone\", \"-r1872031:HEAD\", remoteDummyURL.String() + \"/branches/develop\", localDir},\n\t}, {\n\t\tname: \"[hg] clone\",\n\t\tf: func() error {\n\t\t\treturn MercurialBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"hg\", \"clone\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[hg] update\",\n\t\tf: func() error {\n\t\t\treturn MercurialBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"hg\", \"pull\", \"--update\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[hg] clone shallow\",\n\t\tf: func() error {\n\t\t\treturn MercurialBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     remoteDummyURL,\n\t\t\t\tdir:     localDir,\n\t\t\t\tshallow: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"hg\", \"clone\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[hg] clone specific branch\",\n\t\tf: func() error {\n\t\t\treturn MercurialBackend.Clone(&vcsGetOption{\n\t\t\t\turl:    remoteDummyURL,\n\t\t\t\tdir:    localDir,\n\t\t\t\tbranch: \"hello\",\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"hg\", \"clone\", \"--branch\", \"hello\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[darcs] clone\",\n\t\tf: func() error {\n\t\t\treturn DarcsBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"darcs\", \"get\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[darcs] clone shallow\",\n\t\tf: func() error {\n\t\t\treturn DarcsBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     remoteDummyURL,\n\t\t\t\tdir:     localDir,\n\t\t\t\tshallow: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"darcs\", \"get\", \"--lazy\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[darcs] update\",\n\t\tf: func() error {\n\t\t\treturn DarcsBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"darcs\", \"pull\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[pijul] clone\",\n\t\tf: func() error {\n\t\t\treturn PijulBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"pijul\", \"clone\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[pijul] update\",\n\t\tf: func() error {\n\t\t\treturn PijulBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"pijul\", \"pull\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[bzr] clone\",\n\t\tf: func() error {\n\t\t\treturn BazaarBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"bzr\", \"branch\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[bzr] update\",\n\t\tf: func() error {\n\t\t\treturn BazaarBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"bzr\", \"pull\", \"--overwrite\"},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[bzr] clone shallow\",\n\t\tf: func() error {\n\t\t\treturn BazaarBackend.Clone(&vcsGetOption{\n\t\t\t\turl:     remoteDummyURL,\n\t\t\t\tdir:     localDir,\n\t\t\t\tshallow: true,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"bzr\", \"branch\", remoteDummyURL.String(), localDir},\n\t}, {\n\t\tname: \"[fossil] clone\",\n\t\tf: func() error {\n\t\t\treturn FossilBackend.Clone(&vcsGetOption{\n\t\t\t\turl: remoteDummyURL,\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"fossil\", \"open\", fossilRepoName},\n\t\tdir:    localDir,\n\t}, {\n\t\tname: \"[fossil] update\",\n\t\tf: func() error {\n\t\t\treturn FossilBackend.Update(&vcsGetOption{\n\t\t\t\tdir: localDir,\n\t\t\t})\n\t\t},\n\t\texpect: []string{\"fossil\", \"update\"},\n\t\tdir:    localDir,\n\t}}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tif err := tc.f(); err != nil {\n\t\t\t\tt.Errorf(\"error should be nil, but: %s\", err)\n\t\t\t}\n\t\t\tc := lastCommand()\n\t\t\tif !reflect.DeepEqual(c.Args, tc.expect) {\n\t\t\t\tt.Errorf(\"\\ngot:    %+v\\nexpect: %+v\", c.Args, tc.expect)\n\t\t\t}\n\t\t\tif c.Dir != tc.dir {\n\t\t\t\tt.Errorf(\"got: %s, expect: %s\", c.Dir, tc.dir)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCvsDummyBackend(t *testing.T) {\n\ttempDir := newTempDir(t)\n\tlocalDir := filepath.Join(tempDir, \"repo\")\n\n\tif err := cvsDummyBackend.Clone(&vcsGetOption{\n\t\turl: remoteDummyURL,\n\t\tdir: localDir,\n\t}); err == nil {\n\t\tt.Error(\"error should be occurred, but nil\")\n\t}\n\n\tif err := cvsDummyBackend.Clone(&vcsGetOption{\n\t\turl:     remoteDummyURL,\n\t\tdir:     localDir,\n\t\tshallow: true,\n\t}); err == nil {\n\t\tt.Error(\"error should be occurred, but nil\")\n\t}\n\n\tif err := cvsDummyBackend.Update(&vcsGetOption{\n\t\tdir: localDir,\n\t}); err == nil {\n\t\tt.Error(\"error should be occurred, but nil\")\n\t}\n}\n\nfunc TestBranchOptionIgnoredErrors(t *testing.T) {\n\ttempDir := newTempDir(t)\n\tlocalDir := filepath.Join(tempDir, \"repo\")\n\n\tif err := DarcsBackend.Clone(&vcsGetOption{\n\t\turl:    remoteDummyURL,\n\t\tdir:    localDir,\n\t\tbranch: \"hello\",\n\t}); err == nil {\n\t\tt.Error(\"error should be occurred, but nil\")\n\t}\n\n\tif err := FossilBackend.Clone(&vcsGetOption{\n\t\turl:    remoteDummyURL,\n\t\tdir:    localDir,\n\t\tbranch: \"hello\",\n\t}); err == nil {\n\t\tt.Error(\"error should be occurred, but nil\")\n\t}\n\n\tif err := BazaarBackend.Clone(&vcsGetOption{\n\t\turl:    remoteDummyURL,\n\t\tdir:    localDir,\n\t\tbranch: \"hello\",\n\t}); err == nil {\n\t\tt.Error(\"error should be occurred, but nil\")\n\t}\n}\n"
        }
      ]
    }
  ]
}