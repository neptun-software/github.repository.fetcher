{
  "metadata": {
    "timestamp": 1736566969033,
    "page": 553,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "protocolbuffers/protobuf-go",
      "stars": 2986,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.298828125,
          "content": "/.cache/\n/.gocache/\n/bin/\n/vendor/\n\n# This file includes artifacts of the system test that should not be checked in.\n# For files created by specific development environment (e.g. editor),\n# use alternative ways to exclude files from git.\n# For example, set up .git/info/exclude or use a global .gitignore.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.634765625,
          "content": "# Contributing to Go Protocol Buffers\n\nGo protocol buffers is an open source project and accepts contributions.\nThe source of truth for this repository is at\n[go.googlesource.com/protobuf](https://go.googlesource.com/protobuf).\nThe code review tool used is\n[Gerrit Code Review](https://www.gerritcodereview.com/).\nAt this time, we are unfortunately unable to accept GitHub pull requests.\n\n\n## Becoming a contributor\n\nThe first step is to configure your environment.\nPlease follow the steps outlined in\n[\"Becoming a contributor\" (golang.org)](https://golang.org/doc/contribute.html#contributor)\nas the setup for contributing to the `protobuf` project is identical\nto that for contributing to the `go` project.\n\n\n## Before contributing code\n\nThe project welcomes submissions, but to make sure things are well coordinated\nwe ask that contributors discuss any significant changes before starting work.\nBest practice is to connect your work to the\n[issue tracker](https://github.com/golang/protobuf/issues),\neither by filing a new issue or by claiming an existing issue.\n\n\n## Sending a change via Gerrit\n\nThe `protobuf` project performs development in Gerrit.\nBelow are the steps to send a change using Gerrit.\n\n\n**Step 1:** Clone the Go source code:\n```\n$ git clone https://go.googlesource.com/protobuf\n```\n\n**Step 2:** Setup a Git hook:\nSetup a hook to run the tests prior to submitting changes to Gerrit:\n```\n$ (cd protobuf/.git/hooks && echo -e '#!/bin/bash\\n./test.bash' > pre-push && chmod a+x pre-push)\n```\n\n**Step 3:** Prepare changes in a new branch, created from the `master` branch.\nTo commit the changes, use `git codereview change`;\nthat will create or amend a single commit in the branch.\n\n```\n$ git checkout -b mybranch\n$ [edit files...]\n$ git add [files...]\n$ git codereview change   # create commit in the branch\n$ [edit again...]\n$ git add [files...]\n$ git codereview change   # amend the existing commit with new changes\n$ [etc.]\n```\n\n**Step 4:** Send the changes for review to Gerrit using `git codereview mail`.\n```\n$ git codereview mail     # send changes to Gerrit\n```\n\n**Step 5:** After a review, there may be changes that are required.\nDo so by applying changes to the same commit and mail them to Gerrit again:\n```\n$ [edit files...]\n$ git add [files...]\n$ git codereview change   # update same commit\n$ git codereview mail     # send to Gerrit again\n```\n\nWhen calling `git codereview mail`, it will call `git push` under the hood,\nwhich will trigger the test hook that was setup in step 2.\n\nThe [Contribution Guidelines](https://golang.org/doc/contribute.html) for the\nGo project provides additional details that are also relevant to\ncontributing to the Go `protobuf` project.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4443359375,
          "content": "Copyright (c) 2018 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "PATENTS",
          "type": "blob",
          "size": 1.2724609375,
          "content": "Additional IP Rights Grant (Patents)\n\n\"This implementation\" means the copyrightable works distributed by\nGoogle as part of the Go project.\n\nGoogle hereby grants to You a perpetual, worldwide, non-exclusive,\nno-charge, royalty-free, irrevocable (except as stated in this section)\npatent license to make, have made, use, offer to sell, sell, import,\ntransfer and otherwise run, modify and propagate the contents of this\nimplementation of Go, where such license applies only to those patent\nclaims, both currently owned or controlled by Google and acquired in\nthe future, licensable by Google that are necessarily infringed by this\nimplementation of Go.  This grant does not include claims that would be\ninfringed only as a consequence of further modification of this\nimplementation.  If you or your agent or exclusive licensee institute or\norder or agree to the institution of patent litigation against any\nentity (including a cross-claim or counterclaim in a lawsuit) alleging\nthat this implementation of Go or any code incorporated within this\nimplementation of Go constitutes direct or contributory patent\ninfringement, or inducement of patent infringement, then any patent\nrights granted to you under this License for this implementation of Go\nshall terminate as of the date such litigation is filed.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.7744140625,
          "content": "# Go support for Protocol Buffers\n\n[![Go Reference](https://pkg.go.dev/badge/google.golang.org/protobuf.svg)](https://pkg.go.dev/google.golang.org/protobuf)\n[![Build Status](https://travis-ci.org/protocolbuffers/protobuf-go.svg?branch=master)](https://travis-ci.org/protocolbuffers/protobuf-go)\n\nThis project hosts the Go implementation for\n[protocol buffers](https://protobuf.dev), which is a\nlanguage-neutral, platform-neutral, extensible mechanism for serializing\nstructured data. The protocol buffer language is a language for specifying the\nschema for structured data. This schema is compiled into language specific\nbindings. This project provides both a tool to generate Go code for the\nprotocol buffer language, and also the runtime implementation to handle\nserialization of messages in Go. See the\n[protocol buffer developer guide](https://protobuf.dev/overview)\nfor more information about protocol buffers themselves.\n\nThis project is comprised of two components:\n\n*   Code generator: The\n    [`protoc-gen-go`](https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go)\n    tool is a compiler plugin to `protoc`, the protocol buffer compiler. It\n    augments the `protoc` compiler so that it knows how to\n    [generate Go specific code for a given `.proto` file](https://protobuf.dev/reference/go/go-generated).\n\n*   Runtime library: The\n    [`protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf) module\n    contains a set of Go packages that form the runtime implementation of\n    protobufs in Go. This provides the set of interfaces that\n    [define what a message is](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect)\n    and functionality to serialize message in various formats (e.g.,\n    [wire](https://pkg.go.dev/google.golang.org/protobuf/proto),\n    [JSON](https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson),\n    and\n    [text](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext)).\n\nSee the\n[developer guide for protocol buffers in Go](https://protobuf.dev/getting-started/gotutorial)\nfor a general guide for how to get started using protobufs in Go.\n\nThis project is the second major revision of the Go protocol buffer API\nimplemented by the\n[`google.golang.org/protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf)\nmodule. The first major version is implemented by the\n[`github.com/golang/protobuf`](https://pkg.go.dev/mod/github.com/golang/protobuf)\nmodule.\n\n## Package index\n\nSummary of the packages provided by this module:\n\n*   [`proto`](https://pkg.go.dev/google.golang.org/protobuf/proto): Package\n    `proto` provides functions operating on protobuf messages such as cloning,\n    merging, and checking equality, as well as binary serialization.\n*   [`encoding/protojson`](https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson):\n    Package `protojson` serializes protobuf messages as JSON.\n*   [`encoding/prototext`](https://pkg.go.dev/google.golang.org/protobuf/encoding/prototext):\n    Package `prototext` serializes protobuf messages as the text format.\n*   [`encoding/protowire`](https://pkg.go.dev/google.golang.org/protobuf/encoding/protowire):\n    Package `protowire` parses and formats the low-level raw wire encoding. Most\n    users should use package `proto` to serialize messages in the wire format.\n*   [`reflect/protoreflect`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect):\n    Package `protoreflect` provides interfaces to dynamically manipulate\n    protobuf messages.\n*   [`reflect/protoregistry`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoregistry):\n    Package `protoregistry` provides data structures to register and lookup\n    protobuf descriptor types.\n*   [`reflect/protodesc`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protodesc):\n    Package `protodesc` provides functionality for converting\n    `descriptorpb.FileDescriptorProto` messages to/from the reflective\n    `protoreflect.FileDescriptor`.\n*   [`reflect/protopath`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protopath):\n    Package `protopath` provides a representation of a sequence of\n    protobuf reflection operations on a message.\n*   [`reflect/protorange`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protorange):\n    Package `protorange` provides functionality to traverse a protobuf message.\n*   [`testing/protocmp`](https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp):\n    Package `protocmp` provides protobuf specific options for the `cmp` package.\n*   [`testing/protopack`](https://pkg.go.dev/google.golang.org/protobuf/testing/protopack):\n    Package `protopack` aids manual encoding and decoding of the wire format.\n*   [`testing/prototest`](https://pkg.go.dev/google.golang.org/protobuf/testing/prototest):\n    Package `prototest` exercises the protobuf reflection implementation for\n    concrete message types.\n*   [`types/dynamicpb`](https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb):\n    Package `dynamicpb` creates protobuf messages at runtime from protobuf\n    descriptors.\n*   [`types/known/anypb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/anypb):\n    Package `anypb` is the generated package for `google/protobuf/any.proto`.\n*   [`types/known/timestamppb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/timestamppb):\n    Package `timestamppb` is the generated package for\n    `google/protobuf/timestamp.proto`.\n*   [`types/known/durationpb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/durationpb):\n    Package `durationpb` is the generated package for\n    `google/protobuf/duration.proto`.\n*   [`types/known/wrapperspb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/wrapperspb):\n    Package `wrapperspb` is the generated package for\n    `google/protobuf/wrappers.proto`.\n*   [`types/known/structpb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/structpb):\n    Package `structpb` is the generated package for\n    `google/protobuf/struct.proto`.\n*   [`types/known/fieldmaskpb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/fieldmaskpb):\n    Package `fieldmaskpb` is the generated package for\n    `google/protobuf/field_mask.proto`.\n*   [`types/known/apipb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/apipb):\n    Package `apipb` is the generated package for\n    `google/protobuf/api.proto`.\n*   [`types/known/typepb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/typepb):\n    Package `typepb` is the generated package for\n    `google/protobuf/type.proto`.\n*   [`types/known/sourcecontextpb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/sourcecontextpb):\n    Package `sourcecontextpb` is the generated package for\n    `google/protobuf/source_context.proto`.\n*   [`types/known/emptypb`](https://pkg.go.dev/google.golang.org/protobuf/types/known/emptypb):\n    Package `emptypb` is the generated package for\n    `google/protobuf/empty.proto`.\n*   [`types/descriptorpb`](https://pkg.go.dev/google.golang.org/protobuf/types/descriptorpb):\n    Package `descriptorpb` is the generated package for\n    `google/protobuf/descriptor.proto`.\n*   [`types/pluginpb`](https://pkg.go.dev/google.golang.org/protobuf/types/pluginpb):\n    Package `pluginpb` is the generated package for\n    `google/protobuf/compiler/plugin.proto`.\n*   [`compiler/protogen`](https://pkg.go.dev/google.golang.org/protobuf/compiler/protogen):\n    Package `protogen` provides support for writing protoc plugins.\n*   [`cmd/protoc-gen-go`](https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go):\n    The `protoc-gen-go` binary is a protoc plugin to generate a Go protocol\n    buffer package.\n\n## Reporting issues\n\nThe issue tracker for this project is currently located at\n[golang/protobuf](https://github.com/golang/protobuf/issues).\n\nPlease report any issues there with a sufficient description of the bug or\nfeature request. Bug reports should ideally be accompanied by a minimal\nreproduction of the issue. Irreproducible bugs are difficult to diagnose and fix\n(and likely to be closed after some period of time). Bug reports must specify\nthe version of the\n[Go protocol buffer module](https://github.com/protocolbuffers/protobuf-go/releases)\nand also the version of the\n[protocol buffer toolchain](https://github.com/protocolbuffers/protobuf/releases)\nbeing used.\n\n## Contributing\n\nThis project is open-source and accepts contributions. See the\n[contribution guide](https://github.com/protocolbuffers/protobuf-go/blob/master/CONTRIBUTING.md)\nfor more information.\n\n## Compatibility\n\nThis module and the generated code are expected to be stable over time. However,\nwe reserve the right to make breaking changes without notice for the following\nreasons:\n\n*   **Security:** A security issue in the specification or implementation may\n    come to light whose resolution requires breaking compatibility. We reserve\n    the right to address such issues.\n*   **Unspecified behavior:** There are some aspects of the protocol buffer\n    specification that are undefined. Programs that depend on unspecified\n    behavior may break in future releases.\n*   **Specification changes:** It may become necessary to address an\n    inconsistency, incompleteness, or change in the protocol buffer\n    specification, which may affect the behavior of existing programs. We\n    reserve the right to address such changes.\n*   **Bugs:** If a package has a bug that violates correctness, a program\n    depending on the buggy behavior may break if the bug is fixed. We reserve\n    the right to fix such bugs.\n*   **Generated additions**: We reserve the right to add new declarations to\n    generated Go packages of `.proto` files. This includes declared constants,\n    variables, functions, types, fields in structs, and methods on types. This\n    may break attempts at injecting additional code on top of what is generated\n    by `protoc-gen-go`. Such practice is not supported by this project.\n*   **Internal changes**: We reserve the right to add, modify, and remove\n    internal code, which includes all unexported declarations, the\n    [`protoc-gen-go/internal_gengo`](https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go/internal_gengo)\n    package, the\n    [`runtime/protoimpl`](https://pkg.go.dev/google.golang.org/protobuf/runtime/protoimpl?tab=doc)\n    package, and all packages under\n    [`internal`](https://pkg.go.dev/google.golang.org/protobuf/internal).\n\nAny breaking changes outside of these will be announced 6 months in advance to\n[protobuf@googlegroups.com](https://groups.google.com/forum/#!forum/protobuf).\n\nUsers should use generated code produced by a version of\n[`protoc-gen-go`](https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go)\nthat is identical to the runtime version provided by the\n[protobuf module](https://pkg.go.dev/mod/google.golang.org/protobuf). This\nproject promises that the runtime remains compatible with code produced by a\nversion of the generator that is no older than 1 year from the version of the\nruntime used, according to the release dates of the minor version. Generated\ncode is expected to use a runtime version that is at least as new as the\ngenerator used to produce it. Generated code contains references to\n[`protoimpl.EnforceVersion`](https://pkg.go.dev/google.golang.org/protobuf/runtime/protoimpl?tab=doc#EnforceVersion)\nto statically ensure that the generated code and runtime do not drift\nsufficiently far apart.\n\n## Historical legacy\n\nThis project is the second major revision\n([released in 2020](https://blog.golang.org/a-new-go-api-for-protocol-buffers))\nof the Go protocol buffer API implemented by the\n[`google.golang.org/protobuf`](https://pkg.go.dev/mod/google.golang.org/protobuf)\nmodule. The first major version\n([released publicly in 2010](https://blog.golang.org/third-party-libraries-goprotobuf-and))\nis implemented by the\n[`github.com/golang/protobuf`](https://pkg.go.dev/mod/github.com/golang/protobuf)\nmodule.\n\nThe first version predates the release of Go 1 by several years. It has a long\nhistory as one of the first core pieces of infrastructure software ever written\nin Go. As such, the Go protobuf project was one of many pioneers for determining\nwhat the Go language should even look like and what would eventually be\nconsidered good design patterns and “idiomatic” Go (by simultaneously being\nboth positive and negative examples of it).\n\nConsider the changing signature of the `proto.Unmarshal` function as an example\nof Go language and library evolution throughout the life of this project:\n\n```go\n// 2007/09/25 - Conception of Go\n\n// 2008/11/12\nexport func UnMarshal(r io.Read, pb_e reflect.Empty) *os.Error\n\n// 2008/11/13\nexport func UnMarshal(buf *[]byte, pb_e reflect.Empty) *os.Error\n\n// 2008/11/24\nexport func UnMarshal(buf *[]byte, pb_e interface{}) *os.Error\n\n// 2008/12/18\nexport func UnMarshal(buf []byte, pb_e interface{}) *os.Error\n\n// 2009/01/20\nfunc UnMarshal(buf []byte, pb_e interface{}) *os.Error\n\n// 2009/04/17\nfunc UnMarshal(buf []byte, pb_e interface{}) os.Error\n\n// 2009/05/22\nfunc Unmarshal(buf []byte, pb_e interface{}) os.Error\n\n// 2011/11/03\nfunc Unmarshal(buf []byte, pb_e interface{}) error\n\n// 2012/03/28 - Release of Go 1\n\n// 2012/06/12\nfunc Unmarshal(buf []byte, pb Message) error\n```\n\nThese changes demonstrate the difficulty of determining what the right API is\nfor any new technology. It takes time multiplied by many users to determine what\nis best; even then, “best” is often still somewhere over the horizon.\n\nThe change on June 6th, 2012 added a degree of type-safety to Go protobufs by\ndeclaring a new interface that all protobuf messages were required to implement:\n\n```go\ntype Message interface {\n   Reset()\n   String() string\n   ProtoMessage()\n}\n```\n\nThis interface reduced the set of types that can be passed to `proto.Unmarshal`\nfrom the universal set of all possible Go types to those with a special\n`ProtoMessage` marker method. The intention of this change is to limit the\nprotobuf API to only operate on protobuf data types (i.e., protobuf messages).\nFor example, there is no sensible operation if a Go channel were passed to the\nprotobuf API as a channel cannot be serialized. The restricted interface would\nprevent that.\n\nThis interface does not behaviorally describe what a protobuf message is, but\nacts as a marker with an undocumented expectation that protobuf messages must be\na Go struct with a specific layout of fields with formatted tags. This\nexpectation is not statically enforced by the Go language, for it is an\nimplementation detail checked dynamically at runtime using Go reflection. Back\nin 2012, the only types with this marker were those generated by\n`protoc-gen-go`. Since `protoc-gen-go` would always generate messages with the\nproper layout of fields, this was deemed an acceptable and dramatic improvement\nover `interface{}`.\n\nOver the next 10 years,\n[use of Go would skyrocket](https://blog.golang.org/10years) and use of\nprotobufs in Go would skyrocket as well. With increased popularity also came\nmore diverse usages and requirements for Go protobufs and an increased number of\ncustom `proto.Message` implementations that were not generated by\n`protoc-gen-go`.\n\nThe increasingly diverse ecosystem of Go types implementing the `proto.Message`\ninterface led to incompatibilities, which often occurred when:\n\n*   **Passing custom `proto.Message` types to the protobuf APIs**: A concrete\n    message implementation might work with some top-level functions (e.g.,\n    `proto.Marshal`), but cause others (e.g., `proto.Equal`) to choke and panic.\n    This occurs because the type only had partial support for being an actual\n    message by only implementing the `proto.Marshaler` interface or having\n    malformed struct field tags that happened to work with one function, but not\n    another.\n\n*   **Using Go reflection on any `proto.Message` types**: A common desire is to\n    write general-purpose code that operates on any protobuf message. For\n    example, a microservice might want to populate a `trace_id` field if it is\n    present in a message. To accomplish this, one would use Go reflection to\n    introspect the message type, and assume it were a pointer to a Go struct\n    with a field named `TraceId` (as would be commonly produced by\n    `protoc-gen-go`). If the concrete message type did not match this\n    expectation, it either failed to work or even resulted in a panic. Such was\n    the case for concrete message types that might be backed by a Go map instead\n    of a Go struct.\n\nBoth of these issues are solved by following the idiom that _interfaces should\ndescribe behavior, not data_. This means that the interface itself should\nprovide sufficient functionality through its methods that users can introspect\nand interact with all aspects of a protobuf message through a principled API.\nThis feature is called _protobuf reflection_. Just as how Go reflection provides\nan API for programmatically interacting with any arbitrary Go value, protobuf\nreflection provides an API for programmatically interacting with any arbitrary\nprotobuf message.\n\nSince an interface cannot be extended in a backwards compatible way, this\nsuggested the need for a new major version that defines a new `proto.Message`\ninterface:\n\n```go\ntype Message interface {\n    ProtoReflect() protoreflect.Message\n}\n```\n\nThe new\n[`proto.Message`](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Message)\ninterface contains a single `ProtoReflect` method that returns a\n[`protoreflect.Message`](https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message),\nwhich is a reflective view over a protobuf message. In addition to making a\nbreaking change to the `proto.Message` interface, we took this opportunity to\ncleanup the supporting functionality that operate on a `proto.Message`, split up\ncomplicated functionality apart into manageable packages, and to hide\nimplementation details away from the public API.\n\nThe goal for this major revision is to improve upon all the benefits of, while\naddressing all the shortcomings of the old API. We hope that it will serve the\nGo ecosystem well for the next 10 years and beyond.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.2919921875,
          "content": "To report a security issue, please use [https://g.co/vulnz](https://g.co/vulnz).\nWe use g.co/vulnz for our intake, and do coordination and disclosure here on\nGitHub (including using GitHub Security Advisory). The Google Security Team will\nrespond within 5 working days of your report on g.co/vulnz.\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoding",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1962890625,
          "content": "module google.golang.org/protobuf\n\ngo 1.21\n\nrequire (\n\tgithub.com/golang/protobuf v1.5.0\n\tgithub.com/google/go-cmp v0.5.5\n)\n\nrequire golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.6328125,
          "content": "github.com/golang/protobuf v1.5.0 h1:LUVKkCeviFUMKqHa4tXIIij/lbhnMbP7Fn5wKdKkRh4=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\n"
        },
        {
          "name": "integration_test.go",
          "type": "blob",
          "size": 18.255859375,
          "content": "// Copyright 2019 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"archive/tar\"\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"crypto/sha256\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"google.golang.org/protobuf/internal/version\"\n)\n\nvar (\n\tregenerate   = flag.Bool(\"regenerate\", false, \"regenerate files\")\n\tbuildRelease = flag.Bool(\"buildRelease\", false, \"build release binaries\")\n\n\tprotobufVersion = \"29.1\"\n\n\tgolangVersions = func() []string {\n\t\t// Version policy: oldest supported version of Go, plus the version before that.\n\t\t// This matches the version policy of the Google Cloud Client Libraries:\n\t\t// https://cloud.google.com/go/getting-started/supported-go-versions\n\t\treturn []string{\n\t\t\t\"1.21.13\",\n\t\t\t\"1.22.6\",\n\t\t\t\"1.23.0\",\n\t\t}\n\t}()\n\tgolangLatest = golangVersions[len(golangVersions)-1]\n\n\tstaticcheckVersion = \"2024.1.1\"\n\tstaticcheckSHA256s = map[string]string{\n\t\t\"darwin/amd64\": \"b67380b84b81d5765b478b7ad888dd7ce53b2c0861103bafa946ac84dc9244ce\",\n\t\t\"darwin/arm64\": \"09cb10e4199f7c6356c2ed5dc45e877c3087ef775d84d39338b52e1a94866074\",\n\t\t\"linux/386\":    \"0225fd8b5cf6c762f9c0aedf1380ed4df576d1d54fb68691be895889e10faf0b\",\n\t\t\"linux/amd64\":  \"6e9398fcaff2b36e1d15e84a647a3a14733b7c2dd41187afa2c182a4c3b32180\",\n\t}\n\n\t// purgeTimeout determines the maximum age of unused sub-directories.\n\tpurgeTimeout = 30 * 24 * time.Hour // 1 month\n\n\t// Variables initialized by mustInitDeps.\n\tmodulePath   string\n\tprotobufPath string\n)\n\nfunc TestIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping integration test in short mode\")\n\t}\n\tif os.Getenv(\"GO_BUILDER_NAME\") != \"\" {\n\t\t// To start off, run on longtest builders, not longtest-race ones.\n\t\tif race() {\n\t\t\tt.Skip(\"skipping integration test in race mode on builders\")\n\t\t}\n\t\t// When on a builder, run even if it's not explicitly requested\n\t\t// provided our caller isn't already running it.\n\t\tif os.Getenv(\"GO_PROTOBUF_INTEGRATION_TEST_RUNNING\") == \"1\" {\n\t\t\tt.Skip(\"protobuf integration test is already running, skipping nested invocation\")\n\t\t}\n\t\tos.Setenv(\"GO_PROTOBUF_INTEGRATION_TEST_RUNNING\", \"1\")\n\t} else if flag.Lookup(\"test.run\").Value.String() != \"^TestIntegration$\" {\n\t\tt.Skip(\"not running integration test if not explicitly requested via test.bash\")\n\t}\n\n\tmustInitDeps(t)\n\tmustHandleFlags(t)\n\n\t// Report dirt in the working tree quickly, rather than after\n\t// going through all the presubmits.\n\t//\n\t// Fail the test late, so we can test uncommitted changes with -failfast.\n\tgitDiff := mustRunCommand(t, \"git\", \"diff\", \"HEAD\")\n\tif strings.TrimSpace(gitDiff) != \"\" {\n\t\tfmt.Printf(\"WARNING: working tree contains uncommitted changes:\\n%v\\n\", gitDiff)\n\t}\n\tgitUntracked := mustRunCommand(t, \"git\", \"ls-files\", \"--others\", \"--exclude-standard\")\n\tif strings.TrimSpace(gitUntracked) != \"\" {\n\t\tfmt.Printf(\"WARNING: working tree contains untracked files:\\n%v\\n\", gitUntracked)\n\t}\n\n\t// Do the relatively fast checks up-front.\n\tt.Run(\"GeneratedGoFiles\", func(t *testing.T) {\n\t\tdiff := mustRunCommand(t, \"go\", \"run\", \"-tags\", \"protolegacy\", \"./internal/cmd/generate-types\")\n\t\tif strings.TrimSpace(diff) != \"\" {\n\t\t\tt.Fatalf(\"stale generated files:\\n%v\", diff)\n\t\t}\n\t\tdiff = mustRunCommand(t, \"go\", \"run\", \"-tags\", \"protolegacy\", \"./internal/cmd/generate-protos\")\n\t\tif strings.TrimSpace(diff) != \"\" {\n\t\t\tt.Fatalf(\"stale generated files:\\n%v\", diff)\n\t\t}\n\t})\n\tt.Run(\"FormattedGoFiles\", func(t *testing.T) {\n\t\tfiles := strings.Split(strings.TrimSpace(mustRunCommand(t, \"git\", \"ls-files\", \"*.go\")), \"\\n\")\n\t\tdiff := mustRunCommand(t, append([]string{\"gofmt\", \"-d\"}, files...)...)\n\t\tif strings.TrimSpace(diff) != \"\" {\n\t\t\tt.Fatalf(\"unformatted source files:\\n%v\", diff)\n\t\t}\n\t})\n\tt.Run(\"GeneratedVet\", func(t *testing.T) {\n\t\tfiles := strings.Split(strings.TrimSpace(mustRunCommand(t, \"go\", \"list\", \"./internal/testprotos/...\")), \"\\n\")\n\t\tfiltered := make([]string, 0, len(files))\n\t\tfor _, f := range files {\n\t\t\tif strings.Contains(f, \"/legacy/\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfiltered = append(filtered, f)\n\t\t}\n\t\tmustRunCommand(t, append([]string{\"go\", \"vet\"}, filtered...)...)\n\t})\n\tt.Run(\"CopyrightHeaders\", func(t *testing.T) {\n\t\tfiles := strings.Split(strings.TrimSpace(mustRunCommand(t, \"git\", \"ls-files\", \"*.go\", \"*.proto\")), \"\\n\")\n\t\tmustHaveCopyrightHeader(t, files)\n\t})\n\n\tvar wg sync.WaitGroup\n\tsema := make(chan bool, (runtime.NumCPU()+1)/2)\n\tfor i := range golangVersions {\n\t\tgoVersion := golangVersions[i]\n\t\tgoLabel := \"Go\" + goVersion\n\t\trunGo := func(label string, cmd command, args ...string) {\n\t\t\twg.Add(1)\n\t\t\tsema <- true\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tdefer func() { <-sema }()\n\t\t\t\tt.Run(goLabel+\"/\"+label, func(t *testing.T) {\n\t\t\t\t\targs[0] += goVersion\n\t\t\t\t\tcmd.mustRun(t, args...)\n\t\t\t\t})\n\t\t\t}()\n\t\t}\n\n\t\trunGo(\"Normal\", command{}, \"go\", \"test\", \"-race\", \"./...\")\n\t\trunGo(\"LazyDecoding\", command{}, \"go\", \"test\", \"./proto\", \"-test_lazy_unmarshal\")\n\t\trunGo(\"Reflect\", command{}, \"go\", \"test\", \"-race\", \"-tags\", \"protoreflect\", \"./...\")\n\t\tif goVersion == golangLatest {\n\t\t\trunGo(\"ProtoLegacyRace\", command{}, \"go\", \"test\", \"-race\", \"-tags\", \"protolegacy\", \"./...\")\n\t\t\trunGo(\"ProtoLegacy\", command{}, \"go\", \"test\", \"-tags\", \"protolegacy\", \"./...\")\n\t\t\trunGo(\"ProtocGenGo\", command{Dir: \"cmd/protoc-gen-go/testdata\"}, \"go\", \"test\")\n\t\t\trunGo(\"Conformance\", command{Dir: \"internal/conformance\"}, \"go\", \"test\", \"-execute\")\n\n\t\t\t// Only run the 32-bit compatibility tests for Linux;\n\t\t\t// avoid Darwin since 10.15 dropped support i386 code execution.\n\t\t\tif runtime.GOOS == \"linux\" {\n\t\t\t\trunGo(\"Arch32Bit\", command{Env: append(os.Environ(), \"GOARCH=386\")}, \"go\", \"test\", \"./...\")\n\t\t\t}\n\t\t}\n\t}\n\twg.Wait()\n\n\tt.Run(\"GoStaticCheck\", func(t *testing.T) {\n\t\tchecks := []string{\n\t\t\t\"all\",     // start with all checks enabled\n\t\t\t\"-SA1019\", // disable deprecated usage check\n\t\t\t\"-S*\",     // disable code simplification checks\n\t\t\t\"-ST*\",    // disable coding style checks\n\t\t\t\"-U*\",     // disable unused declaration checks\n\t\t}\n\t\tout := mustRunCommand(t, \"staticcheck\", \"-checks=\"+strings.Join(checks, \",\"), \"-fail=none\", \"./...\")\n\n\t\t// Filter out findings from certain paths.\n\t\tvar findings []string\n\t\tfor _, finding := range strings.Split(strings.TrimSpace(out), \"\\n\") {\n\t\t\tswitch {\n\t\t\tcase strings.HasPrefix(finding, \"internal/testprotos/legacy/\"):\n\t\t\tdefault:\n\t\t\t\tfindings = append(findings, finding)\n\t\t\t}\n\t\t}\n\t\tif len(findings) > 0 {\n\t\t\tt.Fatalf(\"staticcheck findings:\\n%v\", strings.Join(findings, \"\\n\"))\n\t\t}\n\t})\n\tt.Run(\"CommittedGitChanges\", func(t *testing.T) {\n\t\tif strings.TrimSpace(gitDiff) != \"\" {\n\t\t\tt.Fatalf(\"uncommitted changes\")\n\t\t}\n\t})\n\tt.Run(\"TrackedGitFiles\", func(t *testing.T) {\n\t\tif strings.TrimSpace(gitUntracked) != \"\" {\n\t\t\tt.Fatalf(\"untracked files\")\n\t\t}\n\t})\n}\n\nfunc mustInitDeps(t *testing.T) {\n\tcheck := func(err error) {\n\t\tt.Helper()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\t// Determine the directory to place the test directory.\n\trepoRoot, err := os.Getwd()\n\tcheck(err)\n\ttestDir := filepath.Join(repoRoot, \".cache\")\n\tcheck(os.MkdirAll(testDir, 0775))\n\n\t// Delete the current directory if non-empty,\n\t// which only occurs if a dependency failed to initialize properly.\n\tvar workingDir string\n\tfinishedDirs := map[string]bool{}\n\tdefer func() {\n\t\tif workingDir != \"\" {\n\t\t\tos.RemoveAll(workingDir) // best-effort\n\t\t}\n\t}()\n\tstartWork := func(name string) string {\n\t\tworkingDir = filepath.Join(testDir, name)\n\t\treturn workingDir\n\t}\n\tfinishWork := func() {\n\t\tfinishedDirs[workingDir] = true\n\t\tworkingDir = \"\"\n\t}\n\n\t// Delete other sub-directories that are no longer relevant.\n\tdefer func() {\n\t\tnow := time.Now()\n\t\tfis, _ := os.ReadDir(testDir)\n\t\tfor _, fi := range fis {\n\t\t\tdir := filepath.Join(testDir, fi.Name())\n\t\t\tif finishedDirs[dir] {\n\t\t\t\tos.Chtimes(dir, now, now) // best-effort\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfii, err := fi.Info()\n\t\t\tcheck(err)\n\t\t\tif now.Sub(fii.ModTime()) < purgeTimeout {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfmt.Printf(\"delete %v\\n\", fi.Name())\n\t\t\tos.RemoveAll(dir) // best-effort\n\t\t}\n\t}()\n\n\t// The bin directory contains symlinks to each tool by version.\n\t// It is safe to delete this directory and run the test script from scratch.\n\tbinPath := startWork(\"bin\")\n\tcheck(os.RemoveAll(binPath))\n\tcheck(os.Mkdir(binPath, 0775))\n\tcheck(os.Setenv(\"PATH\", binPath+\":\"+os.Getenv(\"PATH\")))\n\tregisterBinary := func(name, path string) {\n\t\tcheck(os.Symlink(path, filepath.Join(binPath, name)))\n\t}\n\tfinishWork()\n\n\t// Get the protobuf toolchain.\n\tprotobufPath = startWork(\"protobuf-\" + protobufVersion)\n\tif _, err := os.Stat(protobufPath); err != nil {\n\t\tfmt.Printf(\"download %v\\n\", filepath.Base(protobufPath))\n\t\tcheckoutVersion := protobufVersion\n\t\tif isCommit := strings.Trim(protobufVersion, \"0123456789abcdef\") == \"\"; !isCommit {\n\t\t\t// release tags have \"v\" prefix\n\t\t\tcheckoutVersion = \"v\" + protobufVersion\n\t\t}\n\t\tcommand{Dir: testDir}.mustRun(t, \"git\", \"clone\", \"https://github.com/protocolbuffers/protobuf\", \"protobuf-\"+protobufVersion)\n\t\tcommand{Dir: protobufPath}.mustRun(t, \"git\", \"checkout\", checkoutVersion)\n\n\t\tif os.Getenv(\"GO_BUILDER_NAME\") != \"\" {\n\t\t\t// If this is running on the Go build infrastructure,\n\t\t\t// use pre-built versions of these binaries that the\n\t\t\t// builders are configured to provide in $PATH.\n\t\t\tprotocPath, err := exec.LookPath(\"protoc\")\n\t\t\tcheck(err)\n\t\t\tconfTestRunnerPath, err := exec.LookPath(\"conformance_test_runner\")\n\t\t\tcheck(err)\n\t\t\tcheck(os.MkdirAll(filepath.Join(protobufPath, \"bazel-bin\", \"conformance\"), 0775))\n\t\t\tcheck(os.Symlink(protocPath, filepath.Join(protobufPath, \"bazel-bin\", \"protoc\")))\n\t\t\tcheck(os.Symlink(confTestRunnerPath, filepath.Join(protobufPath, \"bazel-bin\", \"conformance\", \"conformance_test_runner\")))\n\t\t} else {\n\t\t\t// In other environments, download and build the protobuf toolchain.\n\t\t\t// We avoid downloading the pre-compiled binaries since they do not contain\n\t\t\t// the conformance test runner.\n\t\t\tfmt.Printf(\"build %v\\n\", filepath.Base(protobufPath))\n\t\t\tenv := os.Environ()\n\t\t\targs := []string{\n\t\t\t\t\"bazel\", \"build\",\n\t\t\t\t\":protoc\",\n\t\t\t\t\"//conformance:conformance_test_runner\",\n\t\t\t}\n\t\t\tif runtime.GOOS == \"darwin\" {\n\t\t\t\t// Adding this environment variable appears to be necessary for macOS builds.\n\t\t\t\tenv = append(env, \"CC=clang\")\n\t\t\t\t// And this flag.\n\t\t\t\targs = append(args,\n\t\t\t\t\t\"--macos_minimum_os=13.0\",\n\t\t\t\t\t\"--host_macos_minimum_os=13.0\",\n\t\t\t\t)\n\t\t\t}\n\t\t\tcommand{\n\t\t\t\tDir: protobufPath,\n\t\t\t\tEnv: env,\n\t\t\t}.mustRun(t, args...)\n\t\t}\n\t}\n\tcheck(os.Setenv(\"PROTOBUF_ROOT\", protobufPath)) // for generate-protos\n\tregisterBinary(\"conform-test-runner\", filepath.Join(protobufPath, \"bazel-bin\", \"conformance\", \"conformance_test_runner\"))\n\tregisterBinary(\"protoc\", filepath.Join(protobufPath, \"bazel-bin\", \"protoc\"))\n\tfinishWork()\n\n\t// Download each Go toolchain version.\n\tfor _, v := range golangVersions {\n\t\tgoDir := startWork(\"go\" + v)\n\t\tif _, err := os.Stat(goDir); err != nil {\n\t\t\tfmt.Printf(\"download %v\\n\", filepath.Base(goDir))\n\t\t\turl := fmt.Sprintf(\"https://dl.google.com/go/go%v.%v-%v.tar.gz\", v, runtime.GOOS, runtime.GOARCH)\n\t\t\tdownloadArchive(check, goDir, url, \"go\", \"\") // skip SHA256 check as we fetch over https from a trusted domain\n\t\t}\n\t\tregisterBinary(\"go\"+v, filepath.Join(goDir, \"bin\", \"go\"))\n\t\tfinishWork()\n\t}\n\tregisterBinary(\"go\", filepath.Join(testDir, \"go\"+golangLatest, \"bin\", \"go\"))\n\tregisterBinary(\"gofmt\", filepath.Join(testDir, \"go\"+golangLatest, \"bin\", \"gofmt\"))\n\n\t// Download the staticcheck tool.\n\tcheckDir := startWork(\"staticcheck-\" + staticcheckVersion)\n\tif _, err := os.Stat(checkDir); err != nil {\n\t\tfmt.Printf(\"download %v\\n\", filepath.Base(checkDir))\n\t\turl := fmt.Sprintf(\"https://github.com/dominikh/go-tools/releases/download/%v/staticcheck_%v_%v.tar.gz\", staticcheckVersion, runtime.GOOS, runtime.GOARCH)\n\t\tdownloadArchive(check, checkDir, url, \"staticcheck\", staticcheckSHA256s[runtime.GOOS+\"/\"+runtime.GOARCH])\n\t}\n\tregisterBinary(\"staticcheck\", filepath.Join(checkDir, \"staticcheck\"))\n\tfinishWork()\n\n\t// GitHub actions sets GOROOT, which confuses invocations of the Go toolchain.\n\t// Explicitly clear GOROOT, so each toolchain uses their default GOROOT.\n\tcheck(os.Unsetenv(\"GOROOT\"))\n\n\t// Set a cache directory outside the test directory.\n\tcheck(os.Setenv(\"GOCACHE\", filepath.Join(repoRoot, \".gocache\")))\n}\n\nfunc downloadFile(check func(error), dstPath, srcURL string, perm fs.FileMode) {\n\tresp, err := http.Get(srcURL)\n\tcheck(err)\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(io.LimitReader(resp.Body, 4<<10))\n\t\tcheck(fmt.Errorf(\"GET %q: non-200 OK status code: %v body: %q\", srcURL, resp.Status, body))\n\t}\n\n\tcheck(os.MkdirAll(filepath.Dir(dstPath), 0775))\n\tf, err := os.OpenFile(dstPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n\tcheck(err)\n\n\t_, err = io.Copy(f, resp.Body)\n\tcheck(err)\n\n\tcheck(f.Close())\n}\n\nfunc downloadArchive(check func(error), dstPath, srcURL, skipPrefix, wantSHA256 string) {\n\tcheck(os.RemoveAll(dstPath))\n\n\tresp, err := http.Get(srcURL)\n\tcheck(err)\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(io.LimitReader(resp.Body, 4<<10))\n\t\tcheck(fmt.Errorf(\"GET %q: non-200 OK status code: %v body: %q\", srcURL, resp.Status, body))\n\t}\n\n\tvar r io.Reader = resp.Body\n\tif wantSHA256 != \"\" {\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tcheck(err)\n\t\tr = bytes.NewReader(b)\n\n\t\tif gotSHA256 := fmt.Sprintf(\"%x\", sha256.Sum256(b)); gotSHA256 != wantSHA256 {\n\t\t\tcheck(fmt.Errorf(\"checksum validation error:\\ngot  %v\\nwant %v\", gotSHA256, wantSHA256))\n\t\t}\n\t}\n\n\tzr, err := gzip.NewReader(r)\n\tcheck(err)\n\n\ttr := tar.NewReader(zr)\n\tfor {\n\t\th, err := tr.Next()\n\t\tif err == io.EOF {\n\t\t\treturn\n\t\t}\n\t\tcheck(err)\n\n\t\t// Skip directories or files outside the prefix directory.\n\t\tif len(skipPrefix) > 0 {\n\t\t\tif !strings.HasPrefix(h.Name, skipPrefix) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(h.Name) > len(skipPrefix) && h.Name[len(skipPrefix)] != '/' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tpath := strings.TrimPrefix(strings.TrimPrefix(h.Name, skipPrefix), \"/\")\n\t\tpath = filepath.Join(dstPath, filepath.FromSlash(path))\n\t\tmode := os.FileMode(h.Mode & 0777)\n\t\tswitch h.Typeflag {\n\t\tcase tar.TypeReg:\n\t\t\tb, err := io.ReadAll(tr)\n\t\t\tcheck(err)\n\t\t\tcheck(os.WriteFile(path, b, mode))\n\t\tcase tar.TypeDir:\n\t\t\tcheck(os.Mkdir(path, mode))\n\t\t}\n\t}\n}\n\nfunc mustHandleFlags(t *testing.T) {\n\tif *regenerate {\n\t\tt.Run(\"Generate\", func(t *testing.T) {\n\t\t\tfmt.Print(mustRunCommand(t, \"go\", \"generate\", \"./internal/cmd/generate-types\"))\n\t\t\tfmt.Print(mustRunCommand(t, \"go\", \"generate\", \"./internal/cmd/generate-protos\"))\n\t\t\tfiles := strings.Split(strings.TrimSpace(mustRunCommand(t, \"git\", \"ls-files\", \"*.go\")), \"\\n\")\n\t\t\tmustRunCommand(t, append([]string{\"gofmt\", \"-w\"}, files...)...)\n\t\t})\n\t}\n\tif *buildRelease {\n\t\tt.Run(\"BuildRelease\", func(t *testing.T) {\n\t\t\tv := version.String()\n\t\t\tfor _, goos := range []string{\"linux\", \"darwin\", \"windows\"} {\n\t\t\t\tfor _, goarch := range []string{\"386\", \"amd64\", \"arm64\"} {\n\t\t\t\t\t// Avoid Darwin since 10.15 dropped support for i386.\n\t\t\t\t\tif goos == \"darwin\" && goarch == \"386\" {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tbinPath := filepath.Join(\"bin\", fmt.Sprintf(\"protoc-gen-go.%v.%v.%v\", v, goos, goarch))\n\n\t\t\t\t\t// Build the binary.\n\t\t\t\t\tcmd := command{Env: append(os.Environ(), \"GOOS=\"+goos, \"GOARCH=\"+goarch)}\n\t\t\t\t\tcmd.mustRun(t, \"go\", \"build\", \"-trimpath\", \"-ldflags\", \"-s -w -buildid=\", \"-o\", binPath, \"./cmd/protoc-gen-go\")\n\n\t\t\t\t\t// Archive and compress the binary.\n\t\t\t\t\tin, err := os.ReadFile(binPath)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t\tout := new(bytes.Buffer)\n\t\t\t\t\tsuffix := \"\"\n\t\t\t\t\tcomment := fmt.Sprintf(\"protoc-gen-go VERSION=%v GOOS=%v GOARCH=%v\", v, goos, goarch)\n\t\t\t\t\tswitch goos {\n\t\t\t\t\tcase \"windows\":\n\t\t\t\t\t\tsuffix = \".zip\"\n\t\t\t\t\t\tzw := zip.NewWriter(out)\n\t\t\t\t\t\tzw.SetComment(comment)\n\t\t\t\t\t\tfw, _ := zw.Create(\"protoc-gen-go.exe\")\n\t\t\t\t\t\tfw.Write(in)\n\t\t\t\t\t\tzw.Close()\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsuffix = \".tar.gz\"\n\t\t\t\t\t\tgz, _ := gzip.NewWriterLevel(out, gzip.BestCompression)\n\t\t\t\t\t\tgz.Comment = comment\n\t\t\t\t\t\ttw := tar.NewWriter(gz)\n\t\t\t\t\t\ttw.WriteHeader(&tar.Header{\n\t\t\t\t\t\t\tName: \"protoc-gen-go\",\n\t\t\t\t\t\t\tMode: int64(0775),\n\t\t\t\t\t\t\tSize: int64(len(in)),\n\t\t\t\t\t\t})\n\t\t\t\t\t\ttw.Write(in)\n\t\t\t\t\t\ttw.Close()\n\t\t\t\t\t\tgz.Close()\n\t\t\t\t\t}\n\t\t\t\t\tif err := os.WriteFile(binPath+suffix, out.Bytes(), 0664); err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tif *regenerate || *buildRelease {\n\t\tt.SkipNow()\n\t}\n}\n\nvar copyrightRegex = []*regexp.Regexp{\n\tregexp.MustCompile(`^// Copyright \\d\\d\\d\\d The Go Authors\\. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file\\.\n`),\n\t// Generated .pb.go files from main protobuf repo.\n\tregexp.MustCompile(`^// Protocol Buffers - Google's data interchange format\n// Copyright \\d\\d\\d\\d Google Inc\\.  All rights reserved\\.\n`),\n}\n\nfunc mustHaveCopyrightHeader(t *testing.T, files []string) {\n\tvar bad []string\nFile:\n\tfor _, file := range files {\n\t\tif strings.HasSuffix(file, \"internal/testprotos/conformance/editions/test_messages_edition2023.pb.go\") {\n\t\t\t// TODO(lassefolger) the underlying proto file is checked into\n\t\t\t// the protobuf repo without a copyright header. Fix is pending but\n\t\t\t// might require a release.\n\t\t\tcontinue\n\t\t}\n\t\tb, err := os.ReadFile(file)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, re := range copyrightRegex {\n\t\t\tif loc := re.FindIndex(b); loc != nil && loc[0] == 0 {\n\t\t\t\tcontinue File\n\t\t\t}\n\t\t}\n\t\tbad = append(bad, file)\n\t}\n\tif len(bad) > 0 {\n\t\tt.Fatalf(\"files with missing/bad copyright headers:\\n  %v\", strings.Join(bad, \"\\n  \"))\n\t}\n}\n\ntype command struct {\n\tDir string\n\tEnv []string\n}\n\nfunc (c command) mustRun(t *testing.T, args ...string) string {\n\tt.Helper()\n\tstdout := new(bytes.Buffer)\n\tstderr := new(bytes.Buffer)\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Dir = \".\"\n\tif c.Dir != \"\" {\n\t\tcmd.Dir = c.Dir\n\t}\n\tcmd.Env = os.Environ()\n\tif c.Env != nil {\n\t\tcmd.Env = c.Env\n\t}\n\tcmd.Env = append(cmd.Env, \"PWD=\"+cmd.Dir)\n\tcmd.Stdout = stdout\n\tcmd.Stderr = stderr\n\tif err := cmd.Run(); err != nil {\n\t\tt.Fatalf(\"executing (%v): %v\\n%s%s\", strings.Join(args, \" \"), err, stdout.String(), stderr.String())\n\t}\n\treturn stdout.String()\n}\n\nfunc mustRunCommand(t *testing.T, args ...string) string {\n\tt.Helper()\n\treturn command{}.mustRun(t, args...)\n}\n\n// race is an approximation of whether the race detector is on.\n// It's used to skip the integration test on builders, without\n// preventing the integration test from running under the race\n// detector as a '//go:build !race' build constraint would.\nfunc race() bool {\n\tbi, ok := debug.ReadBuildInfo()\n\tif !ok {\n\t\treturn false\n\t}\n\tfor _, setting := range bi.Settings {\n\t\tif setting.Key == \"-race\" {\n\t\t\treturn setting.Value == \"true\"\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "proto",
          "type": "tree",
          "content": null
        },
        {
          "name": "protoadapt",
          "type": "tree",
          "content": null
        },
        {
          "name": "reflect",
          "type": "tree",
          "content": null
        },
        {
          "name": "regenerate.bash",
          "type": "blob",
          "size": 0.2724609375,
          "content": "#!/bin/bash\n# Copyright 2018 The Go Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\ngo test google.golang.org/protobuf -run='^TestIntegration$' -v -timeout=60m -count=1 \"$@\" -regenerate\nexit $?\n"
        },
        {
          "name": "release.bash",
          "type": "blob",
          "size": 3.8828125,
          "content": "#!/bin/bash\n# Copyright 2019 The Go Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\ncd \"$(git rev-parse --show-toplevel)\"\n\nread -p \"What is the next release version (e.g., 'v1.26.0')?  \" VERSION\nSEMVER_REGEX='^v\\([0-9]*\\)[.]\\([0-9]*\\)[.]\\([0-9]*\\)\\([.a-zA-Z0-9A-Z-]*\\)$'\nif ! [[ -z $(echo $VERSION | sed -e \"s/$SEMVER_REGEX//\") ]]; then\n\techo; echo \"invalid: must be a semver string\"; exit 1\nfi\nVERSION_MAJOR=$(echo $VERSION | sed -e \"s/$SEMVER_REGEX/\\1/\")\nVERSION_MINOR=$(echo $VERSION | sed -e \"s/$SEMVER_REGEX/\\2/\")\nVERSION_PATCH=$(echo $VERSION | sed -e \"s/$SEMVER_REGEX/\\3/\")\nVERSION_PRERELEASE=$(echo $VERSION | sed -e \"s/$SEMVER_REGEX/\\4/\")\nif ! [[ \"$VERSION_MAJOR\" =~ ^1$ ]]; then\n\techo; echo \"invalid: major version must be 1\"; exit 1\nfi\nif ! [[ -z $VERSION_PRERELEASE ]] && ! [[ \"$VERSION_PRERELEASE\" =~ ^-rc[.][0-9]+$ ]]; then\n\techo; echo \"invalid: pre-release suffix must be empty or '-rc.X'\"; exit 1\nfi\nVERSION_PRERELEASE=${VERSION_PRERELEASE#\"-\"} # trim possible leading dash\n\nfunction version_string() {\n\tVERSION_STRING=\"v${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}\"\n\tif ! [[ -z $VERSION_PRERELEASE ]]; then\n\t\tVERSION_STRING=\"${VERSION_STRING}-${VERSION_PRERELEASE}\"\n\tfi\n\techo $VERSION_STRING\n}\n\nread -p \"Were there any changes to the generator that relies on new runtime functionality?  \" YN\ncase $YN in\n[Yy]* )\n\tread -p \"  What minor version of the runtime is required now?  \" GEN_VERSION\n\tif ! [[ \"$GEN_VERSION\" =~ ^[0-9]+$ ]]; then echo; echo \"invalid: must be an integer\"; exit 1; fi;;\n[Nn]* ) ;;\n* ) echo; echo \"invalid: must be 'yes' or 'no'\"; exit 1;;\nesac\n\nread -p \"Were there any dropped functionality in the runtime for old generated code?  \" YN\ncase $YN in\n[Yy]* )\n\tread -p \"  What minor version of the runtime is required now?  \" MIN_VERSION\n\tif ! [[ \"$MIN_VERSION\" =~ ^[0-9]+$ ]]; then echo; echo \"invalid: must be an integer\"; exit 1; fi;;\n[Nn]* ) ;;\n* ) echo; echo \"invalid: must be 'yes' or 'no'\"; exit 1;;\nesac\n\n\necho\necho \"Preparing changes to release $(version_string).\"\necho\n\nset -e\n\n# Create a new branch to contain the release changes.\nif [[ $(git branch --list release) ]]; then\n\techo \"error: release branch already exists\"; exit 1\nfi\ngit codereview change release\ngit codereview sync\n\n# Create commit for actual release.\nINPLACE='-i \"\"' # BSD version of sed expects argument after -i\nif [[ \"$(sed --version)\" == *\"GNU\"* ]]; then\n\tINPLACE=\"-i\" # GNU version of sed does not expect argument after -i\nfi\nsed $INPLACE -e \"s/\\(Minor *= *\\)[0-9]*/\\1$VERSION_MINOR/\" internal/version/version.go\nsed $INPLACE -e \"s/\\(Patch *= *\\)[0-9]*/\\1$VERSION_PATCH/\" internal/version/version.go\nsed $INPLACE -e \"s/\\(PreRelease *= *\\)\\\"[^\\\"]*\\\"/\\1\\\"$VERSION_PRERELEASE\\\"/\" internal/version/version.go\nif ! [[ -z $GEN_VERSION ]]; then\n\tsed $INPLACE -e \"s/\\(GenVersion *= *\\)[0-9]*/\\1$GEN_VERSION/\" runtime/protoimpl/version.go\nfi\nif ! [[ -z $MIN_VERSION ]]; then\n\tsed $INPLACE -e \"s/\\(MinVersion *= *\\)[0-9]*/\\1$MIN_VERSION/\" runtime/protoimpl/version.go\nfi\ngit commit -a -m \"all: release $(version_string)\"\n\n# Build release binaries.\ngo test google.golang.org/protobuf -run='^TestIntegration$' -timeout=60m -count=1 \"$@\" -buildRelease\n\n# Create commit to start development after release.\nVERSION_PRERELEASE=\"${VERSION_PRERELEASE}.devel\" # append \".devel\"\nVERSION_PRERELEASE=\"${VERSION_PRERELEASE#\".\"}\"   # trim possible leading \".\"\nsed $INPLACE -e \"s/\\(PreRelease *= *\\)\\\"[^\\\"]*\\\"/\\1\\\"$VERSION_PRERELEASE\\\"/\" internal/version/version.go\ngit commit -a -m \"all: start $(version_string)\"\n\necho\necho \"Release changes prepared. Additional steps:\"\necho \"  1) Submit the changes:\"\necho \"    a. Mail out the changes: git mail HEAD\"\necho \"    b. Request a review on the changes and merge them.\"\necho \"  2) Tag a new release on GitHub:\"\necho \"    a. Write release notes highlighting notable changes.\"\necho \"    b. Attach pre-compiled binaries as assets to the release.\"\necho\n"
        },
        {
          "name": "runtime",
          "type": "tree",
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.bash",
          "type": "blob",
          "size": 0.2705078125,
          "content": "#!/bin/bash\n# Copyright 2018 The Go Authors. All rights reserved.\n# Use of this source code is governed by a BSD-style\n# license that can be found in the LICENSE file.\n\ngo test google.golang.org/protobuf -run='^TestIntegration$' -v -timeout=60m -count=1 -failfast \"$@\"\nexit $?\n"
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}