{
  "metadata": {
    "timestamp": 1736567203787,
    "page": 803,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ssut/payload-dumper-go",
      "stars": 2453,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.6240234375,
          "content": "# http://editorconfig.org\nroot = true\n\n[*]\nindent_style = tab\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n# Use 4 spaces for the Python files\n[*.py]\nindent_size = 4\nmax_line_length = 80\n\n# The JSON files contain newlines inconsistently\n[*.json]\ninsert_final_newline = ignore\n\n# Minified JavaScript files shouldn't be changed\n[**.min.js]\nindent_style = ignore\ninsert_final_newline = ignore\n\n# Makefiles always use tabs for indentation\n[Makefile]\nindent_style = tab\n\n# Batch files use tabs for indentation\n[*.bat]\nindent_style = tab\n\n[*.md]\ntrim_trailing_whitespace = false\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.732421875,
          "content": "# Created by https://www.toptal.com/developers/gitignore/api/go,vscode\n# Edit at https://www.toptal.com/developers/gitignore?templates=go,vscode\n\n### Go ###\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n### Go Patch ###\n/vendor/\n/Godeps/\n\n### Go Workspace ###\ngo.work\ngo.work.sum\n\n### vscode ###\n.vscode/\n!.vscode/settings.json\n!.vscode/tasks.json\n!.vscode/launch.json\n!.vscode/extensions.json\n*.code-workspace\n\n# End of https://www.toptal.com/developers/gitignore/api/go,vscode\n\n*.zip\n**/payload.bin\n\nextracted_*/\n\n.DS_Store\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 1.673828125,
          "content": "checksum:\n  name_template: \"{{ .ProjectName }}_sha256checksums.txt\"\n  algorithm: sha256\nenv:\n  - CGO_ENABLED=1\nbuilds:\n  - id: build-windows-amd64\n    env:\n      - CC=x86_64-w64-mingw32-gcc\n      - CXX=x86_64-w64-mingw32-g++\n    goos:\n      - windows\n    goarch:\n      - amd64\n    ldflags:\n      - '-extldflags \"-static -s -w\"'\n  - id: build-linux-amd64\n    goos:\n      - linux\n    goarch:\n      - amd64\n    ldflags:\n      - '-extldflags \"-static -s -w\"'\n  - id: build-linux-armv7\n    env:\n      - CC=arm-linux-gnueabi-gcc\n      - CXX=arm-linux-gnueabi-c++\n      - CGO_CFLAGS=-I/linux-armv7-buildroot/sys-root/include\n      - CGO_LDFLAGS=-L/linux-armv7-buildroot/sys-root/lib\n    goos:\n      - linux\n    goarch:\n      - arm\n    goarm:\n      - 7\n    ldflags:\n      - '-extldflags \"-static -s -w\"'\n  - id: build-linux-arm64\n    env:\n      - CC=aarch64-linux-gnu-gcc\n      - CXX=aarch64-linux-gnu-c++\n      - CGO_CFLAGS=-I/linux-aarch64-buildroot/sys-root/include\n      - CGO_LDFLAGS=-L/linux-aarch64-buildroot/sys-root/lib\n    goos:\n      - linux\n    goarch:\n      - arm64\n    ldflags:\n      - '-extldflags \"-static -s -w\"'\n  - id: build-darwin-amd64\n    env:\n      - CC=o64-clang\n      - CXX=o64-clang++\n      - CGO_CFLAGS=-I/darwin-amd64-buildroot/sys-root/include\n      - CGO_LDFLAGS=-L/darwin-amd64-buildroot/sys-root/lib\n      - PATH=/osxcross/target/bin:$PATH\n    goos:\n      - darwin\n    goarch:\n      - amd64\n  - id: build-darwin-arm64\n    env:\n      - CC=oa64-clang\n      - CXX=oa64-clang++\n      - CGO_CFLAGS=-I/darwin-aarch64-buildroot/sys-root/include\n      - CGO_LDFLAGS=-L/darwin-aarch64-buildroot/sys-root/lib\n      - PATH=/osxcross/target/bin:$PATH\n    goos:\n      - darwin\n    goarch:\n      - arm64\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3642578125,
          "content": "FROM golang as builder\n\nRUN apt-get update \\\n    && apt-get install liblzma-dev\n\nRUN git clone https://github.com/ssut/payload-dumper-go\n\nRUN cd payload-dumper-go \\\n    && GOOS=linux go build -a -ldflags '-extldflags \"-static\"' /go/payload-dumper-go\n\nFROM alpine\nCOPY --from=builder /go/payload-dumper-go/payload-dumper-go /go/bin/\nENTRYPOINT [\"/go/bin/payload-dumper-go\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0810546875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2020 Suhun Han (ssut)\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.3232421875,
          "content": "# payload-dumper-go\n\nAn android OTA payload dumper written in Go.\n\n## Features\n\n![screenshot](https://i.imgur.com/IJtwoWU.png)\n\nSee how fast payload-dumper-go is: https://imgur.com/a/X6HKJT4. (MacBook Pro 16-inch 2019 i9-9750H, 16G)\n\n- Incredibly fast decompression. All decompression progresses are executed in parallel.\n- Payload checksum verification.\n- Support original zip package that contains payload.bin.\n\n### Cautions\n\n- There's just one dependency you need to install on your system: `xz`. (The reason I didn't use the pure Go implementation is written in the [Performance](#performance) section below.)\n- Working on a SSD is highly recommended for performance reasons, a HDD could be a bottle-neck.\n\n### Limitations\n\n- Incremental OTA (delta) payload is not supported yet. ([#44](https://github.com/ssut/payload-dumper-go/pull/44))\n\n## Installation\n\n### Linux and macOS (From releases, recommended)\n\n1. Download the latest binary for your platform from [here](https://github.com/ssut/payload-dumper-go/releases) and extract the contents of the downloaded file to a directory on your system.\n2. Make sure the extracted binary file has executable permissions. You can use the following command to set the permissions if necessary:\n\n```\nchmod +x payload-dumper-go\n```\n\n3. Run the following command to add the directory path to your system's PATH environment variable:\n\n```\nexport PATH=$PATH:/path/to/payload-dumper-go\n```\n\nNote: This command sets the PATH environment variable only for the current terminal session. To make it permanent, you need to add the command to your system's profile file (e.g. .bashrc or .zshrc for Linux/Unix systems).\n\n### macOS (Homebrew)\n\nJust simply run:\n\n```sh\n$ brew install payload-dumper-go\n```\n\n### Windows\n\n1. Download the latest binary for your platform from [here](https://github.com/ssut/payload-dumper-go/releases) and extract the contents of the downloaded file to a directory on your system.\n2. Open the Start menu and search for \"Environment Variables\".\n3. Click on \"Edit the system environment variables\".\n4. Click on the \"Environment Variables\" button at the bottom right corner of the \"System Properties\" window.\n5. Under \"System Variables\", scroll down and click on the \"Path\" variable, then click on \"Edit\".\n6. Click \"New\" and add the path to the directory where the extracted binary is located.\n7. Click \"OK\" on all the windows to save the changes.\n\n## Usage\n\nRun the following command in your terminal:\n\n```\npayload-dumper-go /path/to/payload.bin\n```\n\n## Performance\n\nMachine: MacBook Pro 16-inch 2021 (Apple M1 Max, 64G), OS: macOS Sonoma 14.5, Go: 1.22.4.\n\nTested with a 2.31GB payload.bin file from https://developers.google.com/android/ota (akita).\n\n```shell\npayload.bin: payload.bin\nPayload Version: 2\nPayload Manifest Length: 154250\nPayload Manifest Signature Length: 523\nFound partitions:\nabl (1.8 MB), bl1 (16 kB), bl2 (537 kB), bl31 (106 kB), boot (67 MB), dtbo (17 MB), gcf (8.2 kB), gsa (348 kB), gsa_bl1 (33 kB), init_boot (8.4 MB), ldfw (2.4 MB), modem (102 MB), pbl (49 kB), product (3.4 GB), pvmfw (1.0 MB), system (821 MB), system_dlkm (11 MB), system_ext (288 MB), tzsw (7.9 MB), vbmeta (12 kB), vbmeta_system (8.2 kB), vbmeta_vendor (4.1 kB), vendor (693 MB), vendor_boot (67 MB), vendor_dlkm (28 MB), vendor_kernel_boot (67 MB)\nNumber of workers: 4\nabl (1.8 MB)                [===================================================================================================================] 100 %\nbl2 (537 kB)                [===================================================================================================================] 100 %\nbl1 (16 kB)                 [===================================================================================================================] 100 %\nbl31 (106 kB)               [===================================================================================================================] 100 %\nboot (67 MB)                [===================================================================================================================] 100 %\ndtbo (17 MB)                [===================================================================================================================] 100 %\ngcf (8.2 kB)                [===================================================================================================================] 100 %\ngsa (348 kB)                [===================================================================================================================] 100 %\ngsa_bl1 (33 kB)             [===================================================================================================================] 100 %\ninit_boot (8.4 MB)          [===================================================================================================================] 100 %\nldfw (2.4 MB)               [===================================================================================================================] 100 %\nmodem (102 MB)              [===================================================================================================================] 100 %\npbl (49 kB)                 [===================================================================================================================] 100 %\nproduct (3.4 GB)            [===================================================================================================================] 100 %\npvmfw (1.0 MB)              [===================================================================================================================] 100 %\nsystem (821 MB)             [===================================================================================================================] 100 %\nsystem_dlkm (11 MB)         [===================================================================================================================] 100 %\nsystem_ext (288 MB)         [===================================================================================================================] 100 %\ntzsw (7.9 MB)               [===================================================================================================================] 100 %\nvbmeta (12 kB)              [===================================================================================================================] 100 %\nvbmeta_system (8.2 kB)      [===================================================================================================================] 100 %\nvbmeta_vendor (4.1 kB)      [===================================================================================================================] 100 %\nvendor (693 MB)             [===================================================================================================================] 100 %\nvendor_boot (67 MB)         [===================================================================================================================] 100 %\nvendor_dlkm (28 MB)         [===================================================================================================================] 100 %\nvendor_kernel_boot (67 MB)  [===================================================================================================================] 100 %\ngo run *.go payload.bin  87.93s user 3.51s system 145% cpu 1:02.99 total\n```\n\n### Why not use the pure Go implementation for xz decompression?\n\n[The pure Go implementation of xz](https://github.com/ulikunitz/xz) is very slow compared to [the C implementation used with CGO](https://github.com/spencercw/go-xz). Here's the result with the same payload.bin file on the same conditions:\n\n```shell\npayload.bin: payload.bin\nPayload Version: 2\nPayload Manifest Length: 154250\nPayload Manifest Signature Length: 523\nFound partitions:\nabl (1.8 MB), bl1 (16 kB), bl2 (537 kB), bl31 (106 kB), boot (67 MB), dtbo (17 MB), gcf (8.2 kB), gsa (348 kB), gsa_bl1 (33 kB), init_boot (8.4 MB), ldfw (2.4 MB), modem (102 MB), pbl (49 kB), product (3.4 GB), pvmfw (1.0 MB), system (821 MB), system_dlkm (11 MB), system_ext (288 MB), tzsw (7.9 MB), vbmeta (12 kB), vbmeta_system (8.2 kB), vbmeta_vendor (4.1 kB), vendor (693 MB), vendor_boot (67 MB), vendor_dlkm (28 MB), vendor_kernel_boot (67 MB)\nNumber of workers: 4\nabl (1.8 MB)                [===================================================================================================================] 100 %\nbl1 (16 kB)                 [===================================================================================================================] 100 %\nbl2 (537 kB)                [===================================================================================================================] 100 %\nbl31 (106 kB)               [===================================================================================================================] 100 %\nboot (67 MB)                [===================================================================================================================] 100 %\ndtbo (17 MB)                [===================================================================================================================] 100 %\ngcf (8.2 kB)                [===================================================================================================================] 100 %\ngsa (348 kB)                [===================================================================================================================] 100 %\ngsa_bl1 (33 kB)             [===================================================================================================================] 100 %\ninit_boot (8.4 MB)          [===================================================================================================================] 100 %\nldfw (2.4 MB)               [===================================================================================================================] 100 %\nmodem (102 MB)              [===================================================================================================================] 100 %\npbl (49 kB)                 [===================================================================================================================] 100 %\nproduct (3.4 GB)            [===================================================================================================================] 100 %\npvmfw (1.0 MB)              [===================================================================================================================] 100 %\nsystem (821 MB)             [===================================================================================================================] 100 %\nsystem_dlkm (11 MB)         [===================================================================================================================] 100 %\nsystem_ext (288 MB)         [===================================================================================================================] 100 %\ntzsw (7.9 MB)               [===================================================================================================================] 100 %\nvbmeta (12 kB)              [===================================================================================================================] 100 %\nvbmeta_system (8.2 kB)      [===================================================================================================================] 100 %\nvbmeta_vendor (4.1 kB)      [===================================================================================================================] 100 %\nvendor (693 MB)             [===================================================================================================================] 100 %\nvendor_boot (67 MB)         [===================================================================================================================] 100 %\nvendor_dlkm (28 MB)         [===================================================================================================================] 100 %\nvendor_kernel_boot (67 MB)  [===================================================================================================================] 100 %\ngo run *.go payload.bin  587.89s user 2428.69s system 248% cpu 20:12.19 total\n```\n\nAs you can see, the pure Go implementation is about 6~ times slower than the C implementation.\n\n## Sources\n\nhttps://android.googlesource.com/platform/system/update_engine/+/master/update_metadata.proto\n\n## License\n\nThis source code is licensed under the Apache License 2.0 as described in the LICENSE file.\n"
        },
        {
          "name": "chromeos_update_engine",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4990234375,
          "content": "module github.com/ssut/payload-dumper-go\n\ngo 1.18\n\nrequire (\n\tgithub.com/dustin/go-humanize v1.0.1\n\tgithub.com/spencercw/go-xz v0.0.0-20181128201811-c82a2123b492\n\tgithub.com/vbauerster/mpb/v5 v5.4.0\n\tgoogle.golang.org/protobuf v1.34.2\n)\n\nrequire (\n\tgithub.com/VividCortex/ewma v1.1.1 // indirect\n\tgithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d // indirect\n\tgithub.com/mattn/go-runewidth v0.0.9 // indirect\n\tgithub.com/valyala/gozstd v1.21.1 // indirect\n\tgolang.org/x/sys v0.22.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.904296875,
          "content": "github.com/VividCortex/ewma v1.1.1 h1:MnEK4VOv6n0RSY4vtRe3h11qjxL3+t0B8yOL8iMXdcM=\ngithub.com/VividCortex/ewma v1.1.1/go.mod h1:2Tkkvm3sRDVXaiyucHiACn4cqf7DpdyLvmxzcbUokwA=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/spencercw/go-xz v0.0.0-20181128201811-c82a2123b492 h1:8J9q7E8tGpVB84cBsMr+X160ECRqwYhkZ6KeaY9kN1I=\ngithub.com/spencercw/go-xz v0.0.0-20181128201811-c82a2123b492/go.mod h1:EvRrgz1GcjNV5yfN+ISxA4sxn255MimeGQ/ROJnQPtQ=\ngithub.com/valyala/gozstd v1.21.1 h1:TQFZVTk5zo7iJcX3o4XYBJujPdO31LFb4fVImwK873A=\ngithub.com/valyala/gozstd v1.21.1/go.mod h1:y5Ew47GLlP37EkTB+B4s7r6A5rdaeB7ftbl9zoYiIPQ=\ngithub.com/vbauerster/mpb/v5 v5.4.0 h1:n8JPunifvQvh6P1D1HAl2Ur9YcmKT1tpoUuiea5mlmg=\ngithub.com/vbauerster/mpb/v5 v5.4.0/go.mod h1:fi4wVo7BVQ22QcvFObm+VwliQXlV1eBT8JDaKXR4JGI=\ngolang.org/x/sys v0.0.0-20201218084310-7d0127a74742/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.22.0 h1:RI27ohtqKCnwULzJLqkv897zojh5/DwS/ENaMzUOaWI=\ngolang.org/x/sys v0.22.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 3.205078125,
          "content": "package main\n\nimport (\n\t\"archive/zip\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc extractPayloadBin(filename string) string {\n\tzipReader, err := zip.OpenReader(filename)\n\tif err != nil {\n\t\tlog.Fatalf(\"Not a valid zip archive: %s\\n\", filename)\n\t}\n\tdefer zipReader.Close()\n\n\tfor _, file := range zipReader.Reader.File {\n\t\tif file.Name == \"payload.bin\" && file.UncompressedSize64 > 0 {\n\t\t\tzippedFile, err := file.Open()\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"Failed to read zipped file: %s\\n\", file.Name)\n\t\t\t}\n\n\t\t\ttempfile, err := os.CreateTemp(os.TempDir(), \"payload_*.bin\")\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"Failed to create a temp file located at %s\\n\", tempfile.Name())\n\t\t\t}\n\t\t\tdefer tempfile.Close()\n\n\t\t\t_, err = io.Copy(tempfile, zippedFile)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\n\t\t\treturn tempfile.Name()\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc main() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\n\tvar (\n\t\tlist            bool\n\t\tpartitions      string\n\t\toutputDirectory string\n\t\tconcurrency     int\n\t)\n\n\tflag.IntVar(&concurrency, \"c\", 4, \"Number of multiple workers to extract (shorthand)\")\n\tflag.IntVar(&concurrency, \"concurrency\", 4, \"Number of multiple workers to extract\")\n\tflag.BoolVar(&list, \"l\", false, \"Show list of partitions in payload.bin (shorthand)\")\n\tflag.BoolVar(&list, \"list\", false, \"Show list of partitions in payload.bin\")\n\tflag.StringVar(&outputDirectory, \"o\", \"\", \"Set output directory (shorthand)\")\n\tflag.StringVar(&outputDirectory, \"output\", \"\", \"Set output directory\")\n\tflag.StringVar(&partitions, \"p\", \"\", \"Dump only selected partitions (comma-separated) (shorthand)\")\n\tflag.StringVar(&partitions, \"partitions\", \"\", \"Dump only selected partitions (comma-separated)\")\n\tflag.Parse()\n\n\tif flag.NArg() == 0 {\n\t\tusage()\n\t}\n\tfilename := flag.Arg(0)\n\n\tif _, err := os.Stat(filename); os.IsNotExist(err) {\n\t\tlog.Fatalf(\"File does not exist: %s\\n\", filename)\n\t}\n\n\tpayloadBin := filename\n\tif strings.HasSuffix(filename, \".zip\") {\n\t\tfmt.Println(\"Please wait while extracting payload.bin from the archive.\")\n\t\tpayloadBin = extractPayloadBin(filename)\n\t\tif payloadBin == \"\" {\n\t\t\tlog.Fatal(\"Failed to extract payload.bin from the archive.\")\n\t\t} else {\n\t\t\tdefer os.Remove(payloadBin)\n\t\t}\n\t}\n\tfmt.Printf(\"payload.bin: %s\\n\", payloadBin)\n\n\tpayload := NewPayload(payloadBin)\n\tif err := payload.Open(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpayload.Init()\n\n\tif list {\n\t\treturn\n\t}\n\n\tnow := time.Now()\n\n\ttargetDirectory := outputDirectory\n\tif targetDirectory == \"\" {\n\t\ttargetDirectory = fmt.Sprintf(\"extracted_%d%02d%02d_%02d%02d%02d\", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())\n\t}\n\tif _, err := os.Stat(targetDirectory); os.IsNotExist(err) {\n\t\tif err := os.Mkdir(targetDirectory, 0o755); err != nil {\n\t\t\tlog.Fatal(\"Failed to create target directory\")\n\t\t}\n\t}\n\n\tpayload.SetConcurrency(concurrency)\n\tfmt.Printf(\"Number of workers: %d\\n\", payload.GetConcurrency())\n\n\tif partitions != \"\" {\n\t\tif err := payload.ExtractSelected(targetDirectory, strings.Split(partitions, \",\")); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t} else {\n\t\tif err := payload.ExtractAll(targetDirectory); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, \"Usage: %s [options] [inputfile]\\n\", os.Args[0])\n\tflag.PrintDefaults()\n\tos.Exit(2)\n}\n"
        },
        {
          "name": "payload.go",
          "type": "blob",
          "size": 9.5947265625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"compress/bzip2\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n\t\"sync\"\n\t\"github.com/valyala/gozstd\"\n\n\thumanize \"github.com/dustin/go-humanize\"\n\txz \"github.com/spencercw/go-xz\"\n\t\"github.com/vbauerster/mpb/v5\"\n\t\"github.com/vbauerster/mpb/v5/decor\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/ssut/payload-dumper-go/chromeos_update_engine\"\n)\n\ntype request struct {\n\tpartition       *chromeos_update_engine.PartitionUpdate\n\ttargetDirectory string\n}\n\n// Payload is a new format for the Android OTA/Firmware update files since Android Oreo\ntype Payload struct {\n\tFilename string\n\n\tfile                 *os.File\n\theader               *payloadHeader\n\tdeltaArchiveManifest *chromeos_update_engine.DeltaArchiveManifest\n\tsignatures           *chromeos_update_engine.Signatures\n\n\tconcurrency int\n\n\tmetadataSize int64\n\tdataOffset   int64\n\tinitialized  bool\n\n\trequests chan *request\n\tworkerWG sync.WaitGroup\n\tprogress *mpb.Progress\n}\n\nconst (\n\tpayloadHeaderMagic        = \"CrAU\"\n\tbrilloMajorPayloadVersion = 2\n\tblockSize                 = 4096\n)\n\ntype payloadHeader struct {\n\tVersion              uint64\n\tManifestLen          uint64\n\tMetadataSignatureLen uint32\n\tSize                 uint64\n\n\tpayload *Payload\n}\n\nfunc (ph *payloadHeader) ReadFromPayload() error {\n\tbuf := make([]byte, 4)\n\tif _, err := ph.payload.file.Read(buf); err != nil {\n\t\treturn err\n\t}\n\tif string(buf) != payloadHeaderMagic {\n\t\treturn fmt.Errorf(\"Invalid payload magic: %s\", buf)\n\t}\n\n\t// Read Version\n\tbuf = make([]byte, 8)\n\tif _, err := ph.payload.file.Read(buf); err != nil {\n\t\treturn err\n\t}\n\tph.Version = binary.BigEndian.Uint64(buf)\n\tfmt.Printf(\"Payload Version: %d\\n\", ph.Version)\n\n\tif ph.Version != brilloMajorPayloadVersion {\n\t\treturn fmt.Errorf(\"Unsupported payload version: %d\", ph.Version)\n\t}\n\n\t// Read Manifest Len\n\tbuf = make([]byte, 8)\n\tif _, err := ph.payload.file.Read(buf); err != nil {\n\t\treturn err\n\t}\n\tph.ManifestLen = binary.BigEndian.Uint64(buf)\n\tfmt.Printf(\"Payload Manifest Length: %d\\n\", ph.ManifestLen)\n\n\tph.Size = 24\n\n\t// Read Manifest Signature Length\n\tbuf = make([]byte, 4)\n\tif _, err := ph.payload.file.Read(buf); err != nil {\n\t\treturn err\n\t}\n\tph.MetadataSignatureLen = binary.BigEndian.Uint32(buf)\n\tfmt.Printf(\"Payload Manifest Signature Length: %d\\n\", ph.MetadataSignatureLen)\n\n\treturn nil\n}\n\n// NewPayload creates a new Payload struct\nfunc NewPayload(filename string) *Payload {\n\tpayload := &Payload{\n\t\tFilename:    filename,\n\t\tconcurrency: 4,\n\t}\n\n\treturn payload\n}\n\n// SetConcurrency sets number of workers\nfunc (p *Payload) SetConcurrency(concurrency int) {\n\tp.concurrency = concurrency\n}\n\n// GetConcurrency returns number of workers\nfunc (p *Payload) GetConcurrency() int {\n\treturn p.concurrency\n}\n\n// Open tries to open payload.bin file defined by Filename\nfunc (p *Payload) Open() error {\n\tfile, err := os.Open(p.Filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.file = file\n\treturn nil\n}\n\nfunc (p *Payload) readManifest() (*chromeos_update_engine.DeltaArchiveManifest, error) {\n\tbuf := make([]byte, p.header.ManifestLen)\n\tif _, err := p.file.Read(buf); err != nil {\n\t\treturn nil, err\n\t}\n\tdeltaArchiveManifest := &chromeos_update_engine.DeltaArchiveManifest{}\n\tif err := proto.Unmarshal(buf, deltaArchiveManifest); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn deltaArchiveManifest, nil\n}\n\nfunc (p *Payload) readMetadataSignature() (*chromeos_update_engine.Signatures, error) {\n\tif _, err := p.file.Seek(int64(p.header.Size+p.header.ManifestLen), 0); err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := make([]byte, p.header.MetadataSignatureLen)\n\tif _, err := p.file.Read(buf); err != nil {\n\t\treturn nil, err\n\t}\n\tsignatures := &chromeos_update_engine.Signatures{}\n\tif err := proto.Unmarshal(buf, signatures); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn signatures, nil\n}\n\nfunc (p *Payload) Init() error {\n\t// Read Header\n\tp.header = &payloadHeader{\n\t\tpayload: p,\n\t}\n\tif err := p.header.ReadFromPayload(); err != nil {\n\t\treturn err\n\t}\n\n\t// Read Manifest\n\tdeltaArchiveManifest, err := p.readManifest()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.deltaArchiveManifest = deltaArchiveManifest\n\n\t// Read Signatures\n\tsignatures, err := p.readMetadataSignature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.signatures = signatures\n\n\t// Update sizes\n\tp.metadataSize = int64(p.header.Size + p.header.ManifestLen)\n\tp.dataOffset = p.metadataSize + int64(p.header.MetadataSignatureLen)\n\n\tfmt.Println(\"Found partitions:\")\n\tfor i, partition := range p.deltaArchiveManifest.Partitions {\n\t\tfmt.Printf(\"%s (%s)\", partition.GetPartitionName(), humanize.Bytes(*partition.GetNewPartitionInfo().Size))\n\n\t\tif i < len(deltaArchiveManifest.Partitions)-1 {\n\t\t\tfmt.Printf(\", \")\n\t\t} else {\n\t\t\tfmt.Printf(\"\\n\")\n\t\t}\n\t}\n\tp.initialized = true\n\n\treturn nil\n}\n\nfunc (p *Payload) readDataBlob(offset int64, length int64) ([]byte, error) {\n\tbuf := make([]byte, length)\n\tn, err := p.file.ReadAt(buf, p.dataOffset+offset)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif int64(n) != length {\n\t\treturn nil, fmt.Errorf(\"Read length mismatch: %d != %d\", n, length)\n\t}\n\n\treturn buf, nil\n}\n\nfunc (p *Payload) Extract(partition *chromeos_update_engine.PartitionUpdate, out *os.File) error {\n\tname := partition.GetPartitionName()\n\tinfo := partition.GetNewPartitionInfo()\n\ttotalOperations := len(partition.Operations)\n\tbarName := fmt.Sprintf(\"%s (%s)\", name, humanize.Bytes(info.GetSize()))\n\tbar := p.progress.AddBar(\n\t\tint64(totalOperations),\n\t\tmpb.PrependDecorators(\n\t\t\tdecor.Name(barName, decor.WCSyncSpaceR),\n\t\t),\n\t\tmpb.AppendDecorators(\n\t\t\tdecor.Percentage(),\n\t\t),\n\t)\n\tdefer bar.SetTotal(0, true)\n\n\tfor _, operation := range partition.Operations {\n\t\tif len(operation.DstExtents) == 0 {\n\t\t\treturn fmt.Errorf(\"Invalid operation.DstExtents for the partition %s\", name)\n\t\t}\n\t\tbar.Increment()\n\n\t\te := operation.DstExtents[0]\n\t\tdataOffset := p.dataOffset + int64(operation.GetDataOffset())\n\t\tdataLength := int64(operation.GetDataLength())\n\t\t_, err := out.Seek(int64(e.GetStartBlock())*blockSize, 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texpectedUncompressedBlockSize := int64(e.GetNumBlocks() * blockSize)\n\n\t\tbufSha := sha256.New()\n\t\tteeReader := io.TeeReader(io.NewSectionReader(p.file, dataOffset, dataLength), bufSha)\n\n\t\tswitch operation.GetType() {\n\t\tcase chromeos_update_engine.InstallOperation_REPLACE:\n\t\t\tn, err := io.Copy(out, teeReader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif int64(n) != expectedUncompressedBlockSize {\n\t\t\t\treturn fmt.Errorf(\"Verify failed (Unexpected bytes written): %s (%d != %d)\", name, n, expectedUncompressedBlockSize)\n\t\t\t}\n\t\t\tbreak\n\n\t\tcase chromeos_update_engine.InstallOperation_REPLACE_XZ:\n\t\t\treader := xz.NewDecompressionReader(teeReader)\n\t\t\tn, err := io.Copy(out, &reader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treader.Close()\n\t\t\tif n != expectedUncompressedBlockSize {\n\t\t\t\treturn fmt.Errorf(\"Verify failed (Unexpected bytes written): %s (%d != %d)\", name, n, expectedUncompressedBlockSize)\n\t\t\t}\n\n\t\t\tbreak\n\n\t\tcase chromeos_update_engine.InstallOperation_REPLACE_BZ:\n\t\t\treader := bzip2.NewReader(teeReader)\n\t\t\tn, err := io.Copy(out, reader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif n != expectedUncompressedBlockSize {\n\t\t\t\treturn fmt.Errorf(\"Verify failed (Unexpected bytes written): %s (%d != %d)\", name, n, expectedUncompressedBlockSize)\n\t\t\t}\n\t\t\tbreak\n\n\t\tcase chromeos_update_engine.InstallOperation_ZSTD:\n\t\t\treader := gozstd.NewReader(teeReader)\n\t\t\tn, err := io.Copy(out, reader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif n != expectedUncompressedBlockSize {\n\t\t\t\treturn fmt.Errorf(\"Verify failed (Unexpected bytes written): %s (%d != %d)\", name, n, expectedUncompressedBlockSize)\n\t\t\t}\n\t\t\tbreak\n\n\t\tcase chromeos_update_engine.InstallOperation_ZERO:\n\t\t\treader := bytes.NewReader(make([]byte, expectedUncompressedBlockSize))\n\t\t\tn, err := io.Copy(out, reader)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif n != expectedUncompressedBlockSize {\n\t\t\t\treturn fmt.Errorf(\"Verify failed (Unexpected bytes written): %s (%d != %d)\", name, n, expectedUncompressedBlockSize)\n\t\t\t}\n\t\t\tbreak\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"Unhandled operation type: %s\", operation.GetType().String())\n\t\t}\n\n\t\t// verify hash\n\t\thash := hex.EncodeToString(bufSha.Sum(nil))\n\t\texpectedHash := hex.EncodeToString(operation.GetDataSha256Hash())\n\t\tif expectedHash != \"\" && hash != expectedHash {\n\t\t\treturn fmt.Errorf(\"Verify failed (Checksum mismatch): %s (%s != %s)\", name, hash, expectedHash)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (p *Payload) worker() {\n\tfor req := range p.requests {\n\t\tpartition := req.partition\n\t\ttargetDirectory := req.targetDirectory\n\n\t\tname := fmt.Sprintf(\"%s.img\", partition.GetPartitionName())\n\t\tfilepath := fmt.Sprintf(\"%s/%s\", targetDirectory, name)\n\t\tfile, err := os.OpenFile(filepath, os.O_TRUNC|os.O_CREATE|os.O_WRONLY, 0o755)\n\t\tif err != nil {\n\t\t}\n\t\tif err := p.Extract(partition, file); err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t}\n\n\t\tp.workerWG.Done()\n\t}\n}\n\nfunc (p *Payload) spawnExtractWorkers(n int) {\n\tfor i := 0; i < n; i++ {\n\t\tgo p.worker()\n\t}\n}\n\nfunc (p *Payload) ExtractSelected(targetDirectory string, partitions []string) error {\n\tif !p.initialized {\n\t\treturn errors.New(\"Payload has not been initialized\")\n\t}\n\tp.progress = mpb.New()\n\n\tp.requests = make(chan *request, 100)\n\tp.spawnExtractWorkers(p.concurrency)\n\n\tsort.Strings(partitions)\n\n\tfor _, partition := range p.deltaArchiveManifest.Partitions {\n\t\tif len(partitions) > 0 {\n\t\t\tidx := sort.SearchStrings(partitions, *partition.PartitionName)\n\t\t\tif idx == len(partitions) || partitions[idx] != *partition.PartitionName {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tp.workerWG.Add(1)\n\t\tp.requests <- &request{\n\t\t\tpartition:       partition,\n\t\t\ttargetDirectory: targetDirectory,\n\t\t}\n\t}\n\n\tp.workerWG.Wait()\n\tclose(p.requests)\n\n\treturn nil\n}\n\nfunc (p *Payload) ExtractAll(targetDirectory string) error {\n\treturn p.ExtractSelected(targetDirectory, nil)\n}\n"
        },
        {
          "name": "reader.go",
          "type": "blob",
          "size": 0.7138671875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\n// Reader reads\ntype Reader struct {\n\tFilename string\n\tOffset   int64\n\n\tfile      *os.File\n\tbytesRead int64\n}\n\nfunc NewReader(filename string, offset int64) *Reader {\n\treader := &Reader{\n\t\tFilename: filename,\n\t\tOffset:   offset,\n\t}\n\n\treturn reader\n}\n\nfunc (r *Reader) Read(p []byte) (int, error) {\n\tif r.file == nil {\n\t\tfile, err := os.Open(r.Filename)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tr.file = file\n\t\tif _, err := r.file.Seek(r.Offset, 0); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\tn, err := r.file.Read(p)\n\tr.bytesRead += int64(n)\n\tif err != nil {\n\n\t\tfmt.Println(err)\n\t}\n\treturn n, err\n}\n\nfunc (r *Reader) Close() error {\n\tif r.file != nil {\n\t\treturn r.file.Close()\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "update_metadata.proto",
          "type": "blob",
          "size": 18.7802734375,
          "content": "//\n// Copyright (C) 2010 The Android Open Source Project\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n// Update file format: An update file contains all the operations needed\n// to update a system to a specific version. It can be a full payload which\n// can update from any version, or a delta payload which can only update\n// from a specific version.\n// The update format is represented by this struct pseudocode:\n// struct delta_update_file {\n//   char magic[4] = \"CrAU\";\n//   uint64 file_format_version;  // payload major version\n//   uint64 manifest_size;  // Size of protobuf DeltaArchiveManifest\n//\n//   // Only present if format_version >= 2:\n//   uint32 metadata_signature_size;\n//\n//   // The DeltaArchiveManifest protobuf serialized, not compressed.\n//   char manifest[manifest_size];\n//\n//   // The signature of the metadata (from the beginning of the payload up to\n//   // this location, not including the signature itself). This is a serialized\n//   // Signatures message.\n//   char metadata_signature_message[metadata_signature_size];\n//\n//   // Data blobs for files, no specific format. The specific offset\n//   // and length of each data blob is recorded in the DeltaArchiveManifest.\n//   struct {\n//     char data[];\n//   } blobs[];\n//\n//   // The signature of the entire payload, everything up to this location,\n//   // except that metadata_signature_message is skipped to simplify signing\n//   // process. These two are not signed:\n//   uint64 payload_signatures_message_size;\n//   // This is a serialized Signatures message.\n//   char payload_signatures_message[payload_signatures_message_size];\n//\n// };\n\n// The DeltaArchiveManifest protobuf is an ordered list of InstallOperation\n// objects. These objects are stored in a linear array in the\n// DeltaArchiveManifest. Each operation is applied in order by the client.\n\n// The DeltaArchiveManifest also contains the initial and final\n// checksums for the device.\n\n// The client will perform each InstallOperation in order, beginning even\n// before the entire delta file is downloaded (but after at least the\n// protobuf is downloaded). The types of operations are explained:\n// - REPLACE: Replace the dst_extents on the drive with the attached data,\n//   zero padding out to block size.\n// - REPLACE_BZ: bzip2-uncompress the attached data and write it into\n//   dst_extents on the drive, zero padding to block size.\n// - MOVE: Copy the data in src_extents to dst_extents. Extents may overlap,\n//   so it may be desirable to read all src_extents data into memory before\n//   writing it out. (deprecated)\n// - SOURCE_COPY: Copy the data in src_extents in the old partition to\n//   dst_extents in the new partition. There's no overlapping of data because\n//   the extents are in different partitions.\n// - BSDIFF: Read src_length bytes from src_extents into memory, perform\n//   bspatch with attached data, write new data to dst_extents, zero padding\n//   to block size. (deprecated)\n// - SOURCE_BSDIFF: Read the data in src_extents in the old partition, perform\n//   bspatch with the attached data and write the new data to dst_extents in the\n//   new partition.\n// - ZERO: Write zeros to the destination dst_extents.\n// - DISCARD: Discard the destination dst_extents blocks on the physical medium.\n//   the data read from those blocks is undefined.\n// - REPLACE_XZ: Replace the dst_extents with the contents of the attached\n//   xz file after decompression. The xz file should only use crc32 or no crc at\n//   all to be compatible with xz-embedded.\n// - PUFFDIFF: Read the data in src_extents in the old partition, perform\n//   puffpatch with the attached data and write the new data to dst_extents in\n//   the new partition.\n//\n// The operations allowed in the payload (supported by the client) depend on the\n// major and minor version. See InstallOperation.Type below for details.\n\nsyntax = \"proto2\";\n\npackage chromeos_update_engine;\n\noption go_package = \"./\";\n\n// Data is packed into blocks on disk, always starting from the beginning\n// of the block. If a file's data is too large for one block, it overflows\n// into another block, which may or may not be the following block on the\n// physical partition. An ordered list of extents is another\n// representation of an ordered list of blocks. For example, a file stored\n// in blocks 9, 10, 11, 2, 18, 12 (in that order) would be stored in\n// extents { {9, 3}, {2, 1}, {18, 1}, {12, 1} } (in that order).\n// In general, files are stored sequentially on disk, so it's more efficient\n// to use extents to encode the block lists (this is effectively\n// run-length encoding).\n// A sentinel value (kuint64max) as the start block denotes a sparse-hole\n// in a file whose block-length is specified by num_blocks.\n\nmessage Extent {\n  optional uint64 start_block = 1;\n  optional uint64 num_blocks = 2;\n}\n\n// Signatures: Updates may be signed by the OS vendor. The client verifies\n// an update's signature by hashing the entire download. The section of the\n// download that contains the signature is at the end of the file, so when\n// signing a file, only the part up to the signature part is signed.\n// Then, the client looks inside the download's Signatures message for a\n// Signature message that it knows how to handle. Generally, a client will\n// only know how to handle one type of signature, but an update may contain\n// many signatures to support many different types of client. Then client\n// selects a Signature message and uses that, along with a known public key,\n// to verify the download. The public key is expected to be part of the\n// client.\n\nmessage Signatures {\n  message Signature {\n    optional uint32 version = 1 [deprecated = true];\n    optional bytes data = 2;\n\n    // The DER encoded signature size of EC keys is nondeterministic for\n    // different input of sha256 hash. However, we need the size of the\n    // serialized signatures protobuf string to be fixed before signing;\n    // because this size is part of the content to be signed. Therefore, we\n    // always pad the signature data to the maximum possible signature size of\n    // a given key. And the payload verifier will truncate the signature to\n    // its correct size based on the value of |unpadded_signature_size|.\n    optional fixed32 unpadded_signature_size = 3;\n  }\n  repeated Signature signatures = 1;\n}\n\nmessage PartitionInfo {\n  optional uint64 size = 1;\n  optional bytes hash = 2;\n}\n\nmessage InstallOperation {\n  enum Type {\n    REPLACE = 0;     // Replace destination extents w/ attached data.\n    REPLACE_BZ = 1;  // Replace destination extents w/ attached bzipped data.\n    MOVE = 2 [deprecated = true];    // Move source extents to target extents.\n    BSDIFF = 3 [deprecated = true];  // The data is a bsdiff binary diff.\n\n    // On minor version 2 or newer, these operations are supported:\n    SOURCE_COPY = 4;    // Copy from source to target partition\n    SOURCE_BSDIFF = 5;  // Like BSDIFF, but read from source partition\n\n    // On minor version 3 or newer and on major version 2 or newer, these\n    // operations are supported:\n    REPLACE_XZ = 8;  // Replace destination extents w/ attached xz data.\n\n    // On minor version 4 or newer, these operations are supported:\n    ZERO = 6;     // Write zeros in the destination.\n    DISCARD = 7;  // Discard the destination blocks, reading as undefined.\n    BROTLI_BSDIFF = 10;  // Like SOURCE_BSDIFF, but compressed with brotli.\n\n    // On minor version 5 or newer, these operations are supported:\n    PUFFDIFF = 9;  // The data is in puffdiff format.\n\n    // On minor version 8 or newer, these operations are supported:\n    ZUCCHINI = 11;\n\n    // On minor version 9 or newer, these operations are supported:\n    LZ4DIFF_BSDIFF = 12;\n    LZ4DIFF_PUFFDIFF = 13;\n    \n    ZSTD = 14;\n  }\n  required Type type = 1;\n\n  // Only minor version 6 or newer support 64 bits |data_offset| and\n  // |data_length|, older client will read them as uint32.\n  // The offset into the delta file (after the protobuf)\n  // where the data (if any) is stored\n  optional uint64 data_offset = 2;\n  // The length of the data in the delta file\n  optional uint64 data_length = 3;\n\n  // Ordered list of extents that are read from (if any) and written to.\n  repeated Extent src_extents = 4;\n  // Byte length of src, equal to the number of blocks in src_extents *\n  // block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to\n  // pass that external program the number of bytes to read from the blocks we\n  // pass it.  This is not used in any other operation.\n  optional uint64 src_length = 5;\n\n  repeated Extent dst_extents = 6;\n  // Byte length of dst, equal to the number of blocks in dst_extents *\n  // block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other\n  // operation.\n  optional uint64 dst_length = 7;\n\n  // Optional SHA 256 hash of the blob associated with this operation.\n  // This is used as a primary validation for http-based downloads and\n  // as a defense-in-depth validation for https-based downloads. If\n  // the operation doesn't refer to any blob, this field will have\n  // zero bytes.\n  optional bytes data_sha256_hash = 8;\n\n  // Indicates the SHA 256 hash of the source data referenced in src_extents at\n  // the time of applying the operation. If present, the update_engine daemon\n  // MUST read and verify the source data before applying the operation.\n  optional bytes src_sha256_hash = 9;\n}\n\n// Hints to VAB snapshot to skip writing some blocks if these blocks are\n// identical to the ones on the source image. The src & dst extents for each\n// CowMergeOperation should be contiguous, and they're a subset of an OTA\n// InstallOperation.\n// During merge time, we need to follow the pre-computed sequence to avoid\n// read after write, similar to the inplace update schema.\nmessage CowMergeOperation {\n  enum Type {\n    COW_COPY = 0;     // identical blocks\n    COW_XOR = 1;      // used when src/dst blocks are highly similar\n    COW_REPLACE = 2;  // Raw replace operation\n  }\n  optional Type type = 1;\n\n  optional Extent src_extent = 2;\n  optional Extent dst_extent = 3;\n  // For COW_XOR, source location might be unaligned, so this field is in range\n  // [0, block_size), representing how much should the src_extent shift toward\n  // larger block number. If this field is non-zero, then src_extent will\n  // include 1 extra block in the end, as the merge op actually references the\n  // first |src_offset| bytes of that extra block. For example, if |dst_extent|\n  // is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].\n  // Note that |src_extent| contains 1 extra block than the |dst_extent|.\n  optional uint32 src_offset = 4;\n}\n\n// Describes the update to apply to a single partition.\nmessage PartitionUpdate {\n  // A platform-specific name to identify the partition set being updated. For\n  // example, in Chrome OS this could be \"ROOT\" or \"KERNEL\".\n  required string partition_name = 1;\n\n  // Whether this partition carries a filesystem with post-install program that\n  // must be run to finalize the update process. See also |postinstall_path| and\n  // |filesystem_type|.\n  optional bool run_postinstall = 2;\n\n  // The path of the executable program to run during the post-install step,\n  // relative to the root of this filesystem. If not set, the default \"postinst\"\n  // will be used. This setting is only used when |run_postinstall| is set and\n  // true.\n  optional string postinstall_path = 3;\n\n  // The filesystem type as passed to the mount(2) syscall when mounting the new\n  // filesystem to run the post-install program. If not set, a fixed list of\n  // filesystems will be attempted. This setting is only used if\n  // |run_postinstall| is set and true.\n  optional string filesystem_type = 4;\n\n  // If present, a list of signatures of the new_partition_info.hash signed with\n  // different keys. If the update_engine daemon requires vendor-signed images\n  // and has its public key installed, one of the signatures should be valid\n  // for /postinstall to run.\n  repeated Signatures.Signature new_partition_signature = 5;\n\n  optional PartitionInfo old_partition_info = 6;\n  optional PartitionInfo new_partition_info = 7;\n\n  // The list of operations to be performed to apply this PartitionUpdate. The\n  // associated operation blobs (in operations[i].data_offset, data_length)\n  // should be stored contiguously and in the same order.\n  repeated InstallOperation operations = 8;\n\n  // Whether a failure in the postinstall step for this partition should be\n  // ignored.\n  optional bool postinstall_optional = 9;\n\n  // On minor version 6 or newer, these fields are supported:\n\n  // The extent for data covered by verity hash tree.\n  optional Extent hash_tree_data_extent = 10;\n\n  // The extent to store verity hash tree.\n  optional Extent hash_tree_extent = 11;\n\n  // The hash algorithm used in verity hash tree.\n  optional string hash_tree_algorithm = 12;\n\n  // The salt used for verity hash tree.\n  optional bytes hash_tree_salt = 13;\n\n  // The extent for data covered by FEC.\n  optional Extent fec_data_extent = 14;\n\n  // The extent to store FEC.\n  optional Extent fec_extent = 15;\n\n  // The number of FEC roots.\n  optional uint32 fec_roots = 16 [default = 2];\n\n  // Per-partition version used for downgrade detection, added\n  // as an effort to support partial updates. For most partitions,\n  // this is the build timestamp.\n  optional string version = 17;\n\n  // A sorted list of CowMergeOperation. When writing cow, we can choose to\n  // skip writing the raw bytes for these extents. During snapshot merge, the\n  // bytes will read from the source partitions instead.\n  repeated CowMergeOperation merge_operations = 18;\n\n  // Estimated size for COW image. This is used by libsnapshot\n  // as a hint. If set to 0, libsnapshot should use alternative\n  // methods for estimating size.\n  optional uint64 estimate_cow_size = 19;\n\n  // Information about the cow used by Cow Writer to specify\n  // number of cow operations to be written\n  optional uint64 estimate_op_count_max = 20;\n}\n\nmessage DynamicPartitionGroup {\n  // Name of the group.\n  required string name = 1;\n\n  // Maximum size of the group. The sum of sizes of all partitions in the group\n  // must not exceed the maximum size of the group.\n  optional uint64 size = 2;\n\n  // A list of partitions that belong to the group.\n  repeated string partition_names = 3;\n}\n\nmessage VABCFeatureSet {\n  optional bool threaded = 1;\n  optional bool batch_writes = 2;\n}\n\n// Metadata related to all dynamic partitions.\nmessage DynamicPartitionMetadata {\n  // All updatable groups present in |partitions| of this DeltaArchiveManifest.\n  // - If an updatable group is on the device but not in the manifest, it is\n  //   not updated. Hence, the group will not be resized, and partitions cannot\n  //   be added to or removed from the group.\n  // - If an updatable group is in the manifest but not on the device, the group\n  //   is added to the device.\n  repeated DynamicPartitionGroup groups = 1;\n\n  // Whether dynamic partitions have snapshots during the update. If this is\n  // set to true, the update_engine daemon creates snapshots for all dynamic\n  // partitions if possible. If this is unset, the update_engine daemon MUST\n  // NOT create snapshots for dynamic partitions.\n  optional bool snapshot_enabled = 2;\n\n  // If this is set to false, update_engine should not use VABC regardless. If\n  // this is set to true, update_engine may choose to use VABC if device\n  // supports it, but not guaranteed.\n  // VABC stands for Virtual AB Compression\n  optional bool vabc_enabled = 3;\n\n  // The compression algorithm used by VABC. Available ones are \"gz\", \"brotli\".\n  // See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,\n  // as this parameter is ultimated forwarded to libsnapshot's CowWriter\n  optional string vabc_compression_param = 4;\n\n  // COW version used by VABC. The represents the major version in the COW\n  // header\n  optional uint32 cow_version = 5;\n\n  // A collection of knobs to tune Virtual AB Compression\n  optional VABCFeatureSet vabc_feature_set = 6;\n\n  // Max bytes to be compressed at once during ota. Options: 4k, 8k, 16k, 32k,\n  // 64k, 128k\n  optional uint64 compression_factor = 7;\n}\n\n// Definition has been duplicated from\n// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.\nmessage ApexInfo {\n  optional string package_name = 1;\n  optional int64 version = 2;\n  optional bool is_compressed = 3;\n  optional int64 decompressed_size = 4;\n}\n\n// Definition has been duplicated from\n// $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.\nmessage ApexMetadata {\n  repeated ApexInfo apex_info = 1;\n}\n\nmessage DeltaArchiveManifest {\n  // Only present in major version = 1. List of install operations for the\n  // kernel and rootfs partitions. For major version = 2 see the |partitions|\n  // field.\n  reserved 1, 2;\n\n  // (At time of writing) usually 4096\n  optional uint32 block_size = 3 [default = 4096];\n\n  // If signatures are present, the offset into the blobs, generally\n  // tacked onto the end of the file, and the length. We use an offset\n  // rather than a bool to allow for more flexibility in future file formats.\n  // If either is absent, it means signatures aren't supported in this\n  // file.\n  optional uint64 signatures_offset = 4;\n  optional uint64 signatures_size = 5;\n\n  // Fields deprecated in major version 2.\n  reserved 6,7,8,9,10,11;\n\n  // The minor version, also referred as \"delta version\", of the payload.\n  // Minor version 0 is full payload, everything else is delta payload.\n  optional uint32 minor_version = 12 [default = 0];\n\n  // Only present in major version >= 2. List of partitions that will be\n  // updated, in the order they will be updated. This field replaces the\n  // |install_operations|, |kernel_install_operations| and the\n  // |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This\n  // array can have more than two partitions if needed, and they are identified\n  // by the partition name.\n  repeated PartitionUpdate partitions = 13;\n\n  // The maximum timestamp of the OS allowed to apply this payload.\n  // Can be used to prevent downgrading the OS.\n  optional int64 max_timestamp = 14;\n\n  // Metadata related to all dynamic partitions.\n  optional DynamicPartitionMetadata dynamic_partition_metadata = 15;\n\n  // If the payload only updates a subset of partitions on the device.\n  optional bool partial_update = 16;\n\n  // Information on compressed APEX to figure out how much space is required for\n  // their decompression\n  repeated ApexInfo apex_info = 17;\n\n  // Security patch level of the device, usually in the format of\n  // yyyy-mm-dd\n  optional string security_patch_level = 18;\n}\n"
        }
      ]
    }
  ]
}