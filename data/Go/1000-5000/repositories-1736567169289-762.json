{
  "metadata": {
    "timestamp": 1736567169289,
    "page": 762,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "redis/rueidis",
      "stars": 2515,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": ".idea/\ndist/\nvendor/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0576171875,
          "content": "Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License."
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.056640625,
          "content": "rueidis\nCopyright 2024 Rueian (https://github.com/rueian)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 24.009765625,
          "content": "# rueidis\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/redis/rueidis.svg)](https://pkg.go.dev/github.com/redis/rueidis)\n[![CircleCI](https://dl.circleci.com/status-badge/img/gh/redis/rueidis/tree/main.svg?style=shield)](https://dl.circleci.com/status-badge/redirect/gh/redis/rueidis/tree/main)\n[![Go Report Card](https://goreportcard.com/badge/github.com/redis/rueidis)](https://goreportcard.com/report/github.com/redis/rueidis)\n[![codecov](https://codecov.io/gh/redis/rueidis/branch/master/graph/badge.svg?token=wGTB8GdY06)](https://codecov.io/gh/redis/rueidis)\n\nA fast Golang Redis client that does auto pipelining and supports server-assisted client-side caching.\n\n## Features\n\n* [Auto pipelining for non-blocking redis commands](#auto-pipelining)\n* [Server-assisted client-side caching](#server-assisted-client-side-caching)\n* [Generic Object Mapping with client-side caching](./om)\n* [Cache-Aside pattern with client-side caching](./rueidisaside)\n* [Distributed Locks with client-side caching](./rueidislock)\n* [Helpers for writing tests with rueidis mock](./mock)\n* [OpenTelemetry integration](./rueidisotel)\n* [Hooks and other integrations](./rueidishook)\n* [Go-redis like API adapter](./rueidiscompat) by [@418Coffee](https://github.com/418Coffee)\n* Pub/Sub, Sharded Pub/Sub, Streams\n* Redis Cluster, Sentinel, RedisJSON, RedisBloom, RediSearch, RedisTimeseries, etc.\n* [Probabilistic Data Structures without Redis Stack](./rueidisprob)\n\n---\n\n## Getting Started\n\n```golang\npackage main\n\nimport (\n\t\"context\"\n\t\"github.com/redis/rueidis\"\n)\n\nfunc main() {\n\tclient, err := rueidis.NewClient(rueidis.ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tctx := context.Background()\n\t// SET key val NX\n\terr = client.Do(ctx, client.B().Set().Key(\"key\").Value(\"val\").Nx().Build()).Error()\n\t// HGETALL hm\n\thm, err := client.Do(ctx, client.B().Hgetall().Key(\"hm\").Build()).AsStrMap()\n}\n```\n\nCheck out more examples: [Command Response Cheatsheet](https://github.com/redis/rueidis#command-response-cheatsheet)\n\n## Developer Friendly Command Builder\n\n`client.B()` is the builder entry point to construct a redis command:\n\n![Developer friendly command builder](https://user-images.githubusercontent.com/2727535/209358313-39000aee-eaa4-42e1-9748-0d3836c1264f.gif)\\\n<sub>_Recorded by @FZambia [Improving Centrifugo Redis Engine throughput and allocation efficiency with Rueidis Go library\n](https://centrifugal.dev/blog/2022/12/20/improving-redis-engine-performance)_</sub>\n\nOnce a command is built, use either `client.Do()` or `client.DoMulti()` to send it to redis.\n\n**You ❗️SHOULD NOT❗️ reuse the command to another `client.Do()` or `client.DoMulti()` call because it has been recycled to the underlying `sync.Pool` by default.**\n\nTo reuse a command, use `Pin()` after `Build()` and it will prevent the command from being recycled.\n\n\n## [Pipelining](https://redis.io/docs/manual/pipelining/)\n\n### Auto Pipelining\n\nAll concurrent non-blocking redis commands (such as `GET`, `SET`) are automatically pipelined by default,\nwhich reduces the overall round trips and system calls and gets higher throughput. You can easily get the benefit\nof [pipelining technique](https://redis.io/docs/manual/pipelining/) by just calling `client.Do()` from multiple goroutines concurrently.\nFor example:\n\n```go\nfunc BenchmarkPipelining(b *testing.B, client rueidis.Client) {\n\t// the below client.Do() operations will be issued from\n\t// multiple goroutines and thus will be pipelined automatically.\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tclient.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\t\t}\n\t})\n}\n```\n\n### Benchmark Comparison with go-redis v9\n\nCompared to go-redis, Rueidis has higher throughput across 1, 8, and 64 parallelism settings.\n\nIt is even able to achieve **~14x** throughput over go-redis in a local benchmark of Macbook Pro 16\" M1 Pro 2021. (see `parallelism(64)-key(16)-value(64)-10`)\n\n![client_test_set](https://github.com/rueian/rueidis-benchmark/blob/master/client_test_set_10.png)\n\nBenchmark source code: https://github.com/rueian/rueidis-benchmark\n\nA benchmark result performed on two GCP n2-highcpu-2 machines also shows that rueidis can achieve higher throughput with lower latencies: https://github.com/redis/rueidis/pull/93\n\n### Disable Auto Pipelining\n\nWhile auto pipelining maximizes throughput, it relys on additional goroutines to process requests and responses and may add some latencies due to goroutine scheduling and head of line blocking.\n\nYou can avoid this by setting `DisableAutoPipelining` to true, then it will switch to connection pooling approach and serve each request with dedicated connection on the same goroutine.\n\n### Manual Pipelining\n\nBesides auto pipelining, you can also pipeline commands manually with `DoMulti()`:\n\n``` golang\ncmds := make(rueidis.Commands, 0, 10)\nfor i := 0; i < 10; i++ {\n    cmds = append(cmds, client.B().Set().Key(\"key\").Value(\"value\").Build())\n}\nfor _, resp := range client.DoMulti(ctx, cmds...) {\n    if err := resp.Error(); err != nil {\n        panic(err)\n    }\n}\n```\n\n## [Server-Assisted Client-Side Caching](https://redis.io/docs/manual/client-side-caching/)\n\nThe opt-in mode of [server-assisted client-side caching](https://redis.io/docs/manual/client-side-caching/) is enabled by default and can be used by calling `DoCache()` or `DoMultiCache()` with client-side TTLs specified.\n\n```golang\nclient.DoCache(ctx, client.B().Hmget().Key(\"mk\").Field(\"1\", \"2\").Cache(), time.Minute).ToArray()\nclient.DoMultiCache(ctx,\n    rueidis.CT(client.B().Get().Key(\"k1\").Cache(), 1*time.Minute),\n    rueidis.CT(client.B().Get().Key(\"k2\").Cache(), 2*time.Minute))\n```\n\nCached responses, including Redis Nils, will be invalidated either when being notified by redis servers or when their client-side TTLs are reached. See https://github.com/redis/rueidis/issues/534 for more details.\n\n### Benchmark\n\nServer-assisted client-side caching can dramatically boost latencies and throughput just like **having a redis replica right inside your application**. For example:\n\n![client_test_get](https://github.com/rueian/rueidis-benchmark/blob/master/client_test_get_10.png)\n\nBenchmark source code: https://github.com/rueian/rueidis-benchmark\n\n### Client-Side Caching Helpers\n\nUse `CacheTTL()` to check the remaining client-side TTL in seconds:\n\n```golang\nclient.DoCache(ctx, client.B().Get().Key(\"k1\").Cache(), time.Minute).CacheTTL() == 60\n```\n\nUse `IsCacheHit()` to verify if the response came from the client-side memory:\n\n```golang\nclient.DoCache(ctx, client.B().Get().Key(\"k1\").Cache(), time.Minute).IsCacheHit() == true\n```\n\nIf the OpenTelemetry is enabled by the `rueidisotel.NewClient(option)`, then there are also two metrics instrumented:\n* rueidis_do_cache_miss\n* rueidis_do_cache_hits\n\n### MGET/JSON.MGET Client-Side Caching Helpers\n\n`rueidis.MGetCache` and `rueidis.JsonMGetCache` are handy helpers fetching multiple keys across different slots through the client-side caching.\nThey will first group keys by slot to build `MGET` or `JSON.MGET` commands respectively and then send requests with only cache missed keys to redis nodes.\n\n### Broadcast Mode Client-Side Caching\n\nAlthough the default is opt-in mode, you can use broadcast mode by specifying your prefixes in `ClientOption.ClientTrackingOptions`:\n\n```go\nclient, err := rueidis.NewClient(rueidis.ClientOption{\n\tInitAddress:           []string{\"127.0.0.1:6379\"},\n\tClientTrackingOptions: []string{\"PREFIX\", \"prefix1:\", \"PREFIX\", \"prefix2:\", \"BCAST\"},\n})\nif err != nil {\n\tpanic(err)\n}\nclient.DoCache(ctx, client.B().Get().Key(\"prefix1:1\").Cache(), time.Minute).IsCacheHit() == false\nclient.DoCache(ctx, client.B().Get().Key(\"prefix1:1\").Cache(), time.Minute).IsCacheHit() == true\n```\n\nPlease make sure that commands passed to `DoCache()` and `DoMultiCache()` are covered by your prefixes.\nOtherwise, their client-side cache will not be invalidated by redis.\n\n### Client-Side Caching with Cache Aside Pattern\n\nCache-Aside is a widely used caching strategy.\n[rueidisaside](https://github.com/redis/rueidis/blob/main/rueidisaside/README.md) can help you cache data into your client-side cache backed by Redis. For example:\n\n```go\nclient, err := rueidisaside.NewClient(rueidisaside.ClientOption{\n    ClientOption: rueidis.ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}},\n})\nif err != nil {\n    panic(err)\n}\nval, err := client.Get(context.Background(), time.Minute, \"mykey\", func(ctx context.Context, key string) (val string, err error) {\n    if err = db.QueryRowContext(ctx, \"SELECT val FROM mytab WHERE id = ?\", key).Scan(&val); err == sql.ErrNoRows {\n        val = \"_nil_\" // cache nil to avoid penetration.\n        err = nil     // clear err in case of sql.ErrNoRows.\n    }\n    return\n})\n// ...\n```\n\nPlease refer to the full example at [rueidisaside](https://github.com/redis/rueidis/blob/main/rueidisaside/README.md).\n\n### Disable Client-Side Caching\n\nSome Redis providers don't support client-side caching, ex. Google Cloud Memorystore.\nYou can disable client-side caching by setting `ClientOption.DisableCache` to `true`.\nThis will also fall back `client.DoCache()` and `client.DoMultiCache()` to `client.Do()` and `client.DoMulti()`.\n\n## Context Cancellation\n\n`client.Do()`, `client.DoMulti()`, `client.DoCache()`, and `client.DoMultiCache()` can return early if the context deadline is reached.\n\n```golang\nctx, cancel := context.WithTimeout(context.Background(), time.Second)\ndefer cancel()\nclient.Do(ctx, client.B().Set().Key(\"key\").Value(\"val\").Nx().Build()).Error() == context.DeadlineExceeded\n```\n\nPlease note that though operations can return early, the command is likely sent already.\n\n### Canceling a Context Before Its Deadline\n\nManually canceling a context is only work in pipeline mode, as it requires an additional goroutine to monitor the context.\nPipeline mode will be started automatically when there are concurrent requests on the same connection, but you can start it in advance with `ClientOption.AlwaysPipelining`\nto make sure manually cancellation is respected, especially for blocking requests which are sent with a dedicated connection where pipeline mode isn't started.\n\n### Disable Auto Retry\n\nAll read-only commands are automatically retried on failures by default before their context deadlines exceeded.\nYou can disable this by setting `DisableRetry` or adjust the number of retries and durations between retries using `RetryDelay` function.\n\n## Pub/Sub\n\nTo receive messages from channels, `client.Receive()` should be used. It supports `SUBSCRIBE`, `PSUBSCRIBE`, and Redis 7.0's `SSUBSCRIBE`:\n\n```golang\nerr = client.Receive(context.Background(), client.B().Subscribe().Channel(\"ch1\", \"ch2\").Build(), func(msg rueidis.PubSubMessage) {\n    // Handle the message. Note that if you want to call another `client.Do()` here, you need to do it in another goroutine or the `client` will be blocked.\n})\n```\n\nThe provided handler will be called with the received message.\n\nIt is important to note that `client.Receive()` will keep blocking until returning a value in the following cases:\n1. return `nil` when receiving any unsubscribe/punsubscribe message related to the provided `subscribe` command, including `sunsubscribe` messages caused by slot migrations.\n2. return `rueidis.ErrClosing` when the client is closed manually.\n3. return `ctx.Err()` when the `ctx` is done.\n4. return non-nil `err` when the provided `subscribe` command fails.\n\nWhile the `client.Receive()` call is blocking, the `Client` is still able to accept other concurrent requests,\nand they are sharing the same TCP connection. If your message handler may take some time to complete, it is recommended\nto use the `client.Receive()` inside a `client.Dedicated()` for not blocking other concurrent requests.\n\n### Alternative PubSub Hooks\n\nThe `client.Receive()` requires users to provide a subscription command in advance.\nThere is an alternative `Dedicatedclient.SetPubSubHooks()` that allows users to subscribe/unsubscribe channels later.\n\n```golang\nc, cancel := client.Dedicate()\ndefer cancel()\n\nwait := c.SetPubSubHooks(rueidis.PubSubHooks{\n\tOnMessage: func(m rueidis.PubSubMessage) {\n\t\t// Handle the message. Note that if you want to call another `c.Do()` here, you need to do it in another goroutine or the `c` will be blocked.\n\t}\n})\nc.Do(ctx, c.B().Subscribe().Channel(\"ch\").Build())\nerr := <-wait // disconnected with err\n```\n\nIf the hooks are not nil, the above `wait` channel is guaranteed to be closed when the hooks will not be called anymore,\nand produce at most one error describing the reason. Users can use this channel to detect disconnection.\n\n## CAS Transaction\n\nTo do a [CAS Transaction](https://redis.io/docs/interact/transactions/#optimistic-locking-using-check-and-set) (`WATCH` + `MULTI` + `EXEC`), a dedicated connection should be used because there should be no\nunintentional write commands between `WATCH` and `EXEC`. Otherwise, the `EXEC` may not fail as expected.\n\n```golang\nclient.Dedicated(func(c rueidis.DedicatedClient) error {\n    // watch keys first\n    c.Do(ctx, c.B().Watch().Key(\"k1\", \"k2\").Build())\n    // perform read here\n    c.Do(ctx, c.B().Mget().Key(\"k1\", \"k2\").Build())\n    // perform write with MULTI EXEC\n    c.DoMulti(\n        ctx,\n        c.B().Multi().Build(),\n        c.B().Set().Key(\"k1\").Value(\"1\").Build(),\n        c.B().Set().Key(\"k2\").Value(\"2\").Build(),\n        c.B().Exec().Build(),\n    )\n    return nil\n})\n\n```\n\nOr use `Dedicate()` and invoke `cancel()` when finished to put the connection back to the pool.\n\n``` golang\nc, cancel := client.Dedicate()\ndefer cancel()\n\nc.Do(ctx, c.B().Watch().Key(\"k1\", \"k2\").Build())\n// do the rest CAS operations with the `client` who occupies a connection\n```\n\nHowever, occupying a connection is not good in terms of throughput. It is better to use [Lua script](#lua-script) to perform\noptimistic locking instead.\n\n## Lua Script\n\nThe `NewLuaScript` or `NewLuaScriptReadOnly` will create a script which is safe for concurrent usage.\n\nWhen calling the `script.Exec`, it will try sending `EVALSHA` first and fall back to `EVAL` if the server returns `NOSCRIPT`.\n\n```golang\nscript := rueidis.NewLuaScript(\"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\")\n// the script.Exec is safe for concurrent call\nlist, err := script.Exec(ctx, client, []string{\"k1\", \"k2\"}, []string{\"a1\", \"a2\"}).ToArray()\n```\n\n## Streaming Read\n\n`client.DoStream()` and `client.DoMultiStream()` can be used to send large redis responses to an `io.Writer`\ndirectly without allocating them to the memory. They work by first sending commands to a dedicated connection acquired from a pool,\nthen directly copying the response values to the given `io.Writer`, and finally recycling the connection.\n\n```go\ns := client.DoMultiStream(ctx, client.B().Get().Key(\"a{slot1}\").Build(), client.B().Get().Key(\"b{slot1}\").Build())\nfor s.HasNext() {\n    n, err := s.WriteTo(io.Discard)\n    if rueidis.IsRedisNil(err) {\n        // ...\n    }\n}\n```\n\nNote that these two methods will occupy connections until all responses are written to the given `io.Writer`.\nThis can take a long time and hurt performance. Use the normal `Do()` and `DoMulti()` instead unless you want to avoid allocating memory for a large redis response.\n\nAlso note that these two methods only work with `string`, `integer`, and `float` redis responses. And `DoMultiStream` currently\ndoes not support pipelining keys across multiple slots when connecting to a redis cluster.\n\n## Memory Consumption Consideration\n\nEach underlying connection in rueidis allocates a ring buffer for pipelining.\nIts size is controlled by the `ClientOption.RingScaleEachConn` and the default value is 10 which results into each ring of size 2^10.\n\nIf you have many rueidis connections, you may find that they occupy quite an amount of memory.\nIn that case, you may consider reducing `ClientOption.RingScaleEachConn` to 8 or 9 at the cost of potential throughput degradation.\n\nYou may also consider setting the value of `ClientOption.PipelineMultiplex` to `-1`, which will let rueidis use only 1 connection for pipelining to each redis node.\n\n## Instantiating a new Redis Client\n\nYou can create a new redis client using `NewClient` and provide several options.\n\n```golang\n// Connect to a single redis node:\nclient, err := rueidis.NewClient(rueidis.ClientOption{\n    InitAddress: []string{\"127.0.0.1:6379\"},\n})\n\n// Connect to a redis cluster\nclient, err := rueidis.NewClient(rueidis.ClientOption{\n    InitAddress: []string{\"127.0.0.1:7001\", \"127.0.0.1:7002\", \"127.0.0.1:7003\"},\n    ShuffleInit: true,\n})\n\n// Connect to a redis cluster and use replicas for read operations\nclient, err := rueidis.NewClient(rueidis.ClientOption{\n    InitAddress: []string{\"127.0.0.1:7001\", \"127.0.0.1:7002\", \"127.0.0.1:7003\"},\n    SendToReplicas: func(cmd rueidis.Completed) bool {\n        return cmd.IsReadOnly()\n    },\n})\n\n// Connect to sentinels\nclient, err := rueidis.NewClient(rueidis.ClientOption{\n    InitAddress: []string{\"127.0.0.1:26379\", \"127.0.0.1:26380\", \"127.0.0.1:26381\"},\n    Sentinel: rueidis.SentinelOption{\n        MasterSet: \"my_master\",\n    },\n})\n```\n\n### Redis URL\n\nYou can use `ParseURL` or `MustParseURL` to construct a `ClientOption`.\n\nThe provided URL must be started with either `redis://`, `rediss://` or `unix://`.\n\nCurrently supported url parameters are `db`, `dial_timeout`, `write_timeout`, `addr`, `protocol`, `client_cache`, `client_name`, `max_retries`, and `master_set`.\n\n```go\n// connect to a redis cluster\nclient, err = rueidis.NewClient(rueidis.MustParseURL(\"redis://127.0.0.1:7001?addr=127.0.0.1:7002&addr=127.0.0.1:7003\"))\n// connect to a redis node\nclient, err = rueidis.NewClient(rueidis.MustParseURL(\"redis://127.0.0.1:6379/0\"))\n// connect to a redis sentinel\nclient, err = rueidis.NewClient(rueidis.MustParseURL(\"redis://127.0.0.1:26379/0?master_set=my_master\"))\n```\n\n\n## Arbitrary Command\n\nIf you want to construct commands that are absent from the command builder, you can use `client.B().Arbitrary()`:\n\n```golang\n// This will result in [ANY CMD k1 k2 a1 a2]\nclient.B().Arbitrary(\"ANY\", \"CMD\").Keys(\"k1\", \"k2\").Args(\"a1\", \"a2\").Build()\n```\n\n## Working with JSON, Raw `[]byte`, and Vector Similarity Search\n\nThe command builder treats all the parameters as Redis strings, which are binary safe. This means that users can store `[]byte`\ndirectly into Redis without conversion. And the `rueidis.BinaryString` helper can convert `[]byte` to `string` without copying. For example:\n\n```golang\nclient.B().Set().Key(\"b\").Value(rueidis.BinaryString([]byte{...})).Build()\n```\n\nTreating all the parameters as Redis strings also means that the command builder doesn't do any quoting, conversion automatically for users.\n\nWhen working with RedisJSON, users frequently need to prepare JSON strings in Redis strings. And `rueidis.JSON` can help:\n\n```golang\nclient.B().JsonSet().Key(\"j\").Path(\"$.myStrField\").Value(rueidis.JSON(\"str\")).Build()\n// equivalent to\nclient.B().JsonSet().Key(\"j\").Path(\"$.myStrField\").Value(`\"str\"`).Build()\n```\n\nWhen working with vector similarity search, users can use `rueidis.VectorString32` and `rueidis.VectorString64` to build queries:\n\n```golang\ncmd := client.B().FtSearch().Index(\"idx\").Query(\"*=>[KNN 5 @vec $V]\").\n    Params().Nargs(2).NameValue().NameValue(\"V\", rueidis.VectorString64([]float64{...})).\n    Dialect(2).Build()\nn, resp, err := client.Do(ctx, cmd).AsFtSearch()\n```\n\n## Command Response Cheatsheet\n\nWhile the command builder is developer-friendly, the response parser is a little unfriendly. Developers must know what type of Redis response will be returned from the server beforehand and which parser they should use.\n\nError Handling:\nIf an incorrect parser function is chosen, an errParse will be returned. Here's an example using ToArray which demonstrates this scenario:\n\n```golang\n// Attempt to parse the response. If a parsing error occurs, check if the error is a parse error and handle it.\n// Normally, you should fix the code by choosing the correct parser function.\n// For instance, use ToString() if the expected response is a string, or ToArray() if the expected response is an array as follows:\nif err := client.Do(ctx, client.B().Get().Key(\"k\").Build()).ToArray(); IsParseErr(err) {\n    fmt.Println(\"Parsing error:\", err)\n}\n```\n\nIt is hard to remember what type of message will be returned and which parsing to use. So, here are some common examples:\n\n```golang\n// GET\nclient.Do(ctx, client.B().Get().Key(\"k\").Build()).ToString()\nclient.Do(ctx, client.B().Get().Key(\"k\").Build()).AsInt64()\n// MGET\nclient.Do(ctx, client.B().Mget().Key(\"k1\", \"k2\").Build()).ToArray()\n// SET\nclient.Do(ctx, client.B().Set().Key(\"k\").Value(\"v\").Build()).Error()\n// INCR\nclient.Do(ctx, client.B().Incr().Key(\"k\").Build()).AsInt64()\n// HGET\nclient.Do(ctx, client.B().Hget().Key(\"k\").Field(\"f\").Build()).ToString()\n// HMGET\nclient.Do(ctx, client.B().Hmget().Key(\"h\").Field(\"a\", \"b\").Build()).ToArray()\n// HGETALL\nclient.Do(ctx, client.B().Hgetall().Key(\"h\").Build()).AsStrMap()\n// EXPIRE\nclient.Do(ctx, client.B().Expire().Key(\"k\").Seconds(1).Build()).AsInt64()\n// HEXPIRE\nclient.Do(ctx, client.B().Hexpire().Key(\"h\").Seconds(1).Fields().Numfields(2).Field(\"f1\", \"f2\").Build()).AsIntSlice()\n// ZRANGE\nclient.Do(ctx, client.B().Zrange().Key(\"k\").Min(\"1\").Max(\"2\").Build()).AsStrSlice()\n// ZRANK\nclient.Do(ctx, client.B().Zrank().Key(\"k\").Member(\"m\").Build()).AsInt64()\n// ZSCORE\nclient.Do(ctx, client.B().Zscore().Key(\"k\").Member(\"m\").Build()).AsFloat64()\n// ZRANGE\nclient.Do(ctx, client.B().Zrange().Key(\"k\").Min(\"0\").Max(\"-1\").Build()).AsStrSlice()\nclient.Do(ctx, client.B().Zrange().Key(\"k\").Min(\"0\").Max(\"-1\").Withscores().Build()).AsZScores()\n// ZPOPMIN\nclient.Do(ctx, client.B().Zpopmin().Key(\"k\").Build()).AsZScore()\nclient.Do(ctx, client.B().Zpopmin().Key(\"myzset\").Count(2).Build()).AsZScores()\n// SCARD\nclient.Do(ctx, client.B().Scard().Key(\"k\").Build()).AsInt64()\n// SMEMBERS\nclient.Do(ctx, client.B().Smembers().Key(\"k\").Build()).AsStrSlice()\n// LINDEX\nclient.Do(ctx, client.B().Lindex().Key(\"k\").Index(0).Build()).ToString()\n// LPOP\nclient.Do(ctx, client.B().Lpop().Key(\"k\").Build()).ToString()\nclient.Do(ctx, client.B().Lpop().Key(\"k\").Count(2).Build()).AsStrSlice()\n// SCAN\nclient.Do(ctx, client.B().Scan().Cursor(0).Build()).AsScanEntry()\n// FT.SEARCH\nclient.Do(ctx, client.B().FtSearch().Index(\"idx\").Query(\"@f:v\").Build()).AsFtSearch()\n// GEOSEARCH\nclient.Do(ctx, client.B().Geosearch().Key(\"k\").Fromlonlat(1, 1).Bybox(1).Height(1).Km().Build()).AsGeosearch()\n```\n\n## Use DecodeSliceOfJSON to Scan Array Result\n\nDecodeSliceOfJSON is useful when you would like to scan the results of an array into a slice of a specific struct.\n\n```golang\ntype User struct {\n\tName string `json:\"name\"`\n}\n\n// Set some values\nif err = client.Do(ctx, client.B().Set().Key(\"user1\").Value(`{\"name\": \"name1\"}`).Build()).Error(); err != nil {\n\treturn err\n}\nif err = client.Do(ctx, client.B().Set().Key(\"user2\").Value(`{\"name\": \"name2\"}`).Build()).Error(); err != nil {\n\treturn err\n}\n\n// Scan MGET results into []*User\nvar users []*User // or []User is also scannable\nif err := rueidis.DecodeSliceOfJSON(client.Do(ctx, client.B().Mget().Key(\"user1\", \"user2\").Build()), &users); err != nil {\n\treturn err\n}\n\nfor _, user := range users {\n\tfmt.Printf(\"%+v\\n\", user)\n}\n/*\n&{name:name1}\n&{name:name2}\n*/\n```\n\n### !!!!!! DO NOT DO THIS !!!!!!\n\nPlease make sure that all values in the result have the same JSON structures.\n\n```golang\n// Set a pure string value\nif err = client.Do(ctx, client.B().Set().Key(\"user1\").Value(\"userName1\").Build()).Error(); err != nil {\n\treturn err\n}\n\n// Bad\nusers := make([]*User, 0)\nif err := rueidis.DecodeSliceOfJSON(client.Do(ctx, client.B().Mget().Key(\"user1\").Build()), &users); err != nil {\n\treturn err\n}\n// -> Error: invalid character 'u' looking for the beginning of the value\n// in this case, use client.Do(ctx, client.B().Mget().Key(\"user1\").Build()).AsStrSlice()\n```\n\n---\n\n## Contributing\n\nContributions are welcome, including [issues](https://github.com/redis/rueidis/issues), [pull requests](https://github.com/redis/rueidis/pulls), and [discussions](https://github.com/redis/rueidis/discussions).\nContributions mean a lot to us and help us improve this library and the community!\n\n### Generate Command Builders\n\nCommand builders are generated based on the definitions in [./hack/cmds](./hack/cmds) by running:\n\n```sh\ngo generate\n```\n\n### Testing\n\nPlease use the [./dockertest.sh](./dockertest.sh) script for running test cases locally.\nAnd please try your best to have 100% test coverage on code changes.\n"
        },
        {
          "name": "binary.go",
          "type": "blob",
          "size": 2.7236328125,
          "content": "package rueidis\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"math\"\n\t\"unsafe\"\n)\n\n// BinaryString convert the provided []byte into a string without copy. It does what strings.Builder.String() does.\n// Redis Strings are binary safe, this means that it is safe to store any []byte into Redis directly.\n// Users can use this BinaryString helper to insert a []byte as the part of redis command. For example:\n//\n//\tclient.B().Set().Key(rueidis.BinaryString([]byte{0})).Value(rueidis.BinaryString([]byte{0})).Build()\n//\n// To read back the []byte of the string returned from the Redis, it is recommended to use the RedisMessage.AsReader.\nfunc BinaryString(bs []byte) string {\n\treturn unsafe.String(unsafe.SliceData(bs), len(bs))\n}\n\n// VectorString32 convert the provided []float32 into a string. Users can use this to build vector search queries:\n//\n//\tclient.B().FtSearch().Index(\"idx\").Query(\"*=>[KNN 5 @vec $V]\").\n//\t    Params().Nargs(2).NameValue().NameValue(\"V\", rueidis.VectorString32([]float32{1})).\n//\t    Dialect(2).Build()\nfunc VectorString32(v []float32) string {\n\tb := make([]byte, len(v)*4)\n\tfor i, e := range v {\n\t\ti := i * 4\n\t\tbinary.LittleEndian.PutUint32(b[i:i+4], math.Float32bits(e))\n\t}\n\treturn BinaryString(b)\n}\n\n// ToVector32 reverts VectorString32. User can use this to convert redis response back to []float32.\nfunc ToVector32(s string) []float32 {\n\tbs := unsafe.Slice(unsafe.StringData(s), len(s))\n\tvs := make([]float32, 0, len(bs)/4)\n\tfor i := 0; i < len(bs); i += 4 {\n\t\tvs = append(vs, math.Float32frombits(binary.LittleEndian.Uint32(bs[i:i+4])))\n\t}\n\treturn vs\n}\n\n// VectorString64 convert the provided []float64 into a string. Users can use this to build vector search queries:\n//\n//\tclient.B().FtSearch().Index(\"idx\").Query(\"*=>[KNN 5 @vec $V]\").\n//\t    Params().Nargs(2).NameValue().NameValue(\"V\", rueidis.VectorString64([]float64{1})).\n//\t    Dialect(2).Build()\nfunc VectorString64(v []float64) string {\n\tb := make([]byte, len(v)*8)\n\tfor i, e := range v {\n\t\ti := i * 8\n\t\tbinary.LittleEndian.PutUint64(b[i:i+8], math.Float64bits(e))\n\t}\n\treturn BinaryString(b)\n}\n\n// ToVector64 reverts VectorString64. User can use this to convert redis response back to []float64.\nfunc ToVector64(s string) []float64 {\n\tbs := unsafe.Slice(unsafe.StringData(s), len(s))\n\tvs := make([]float64, 0, len(bs)/8)\n\tfor i := 0; i < len(bs); i += 8 {\n\t\tvs = append(vs, math.Float64frombits(binary.LittleEndian.Uint64(bs[i:i+8])))\n\t}\n\treturn vs\n}\n\n// JSON convert the provided parameter into a JSON string. Users can use this JSON helper to work with RedisJSON commands.\n// For example:\n//\n//\tclient.B().JsonSet().Key(\"a\").Path(\"$.myField\").Value(rueidis.JSON(\"str\")).Build()\nfunc JSON(in any) string {\n\tbs, err := json.Marshal(in)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn BinaryString(bs)\n}\n"
        },
        {
          "name": "binary_test.go",
          "type": "blob",
          "size": 1.47265625,
          "content": "package rueidis\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestBinaryString(t *testing.T) {\n\tif str := []byte{0, 1, 2, 3, 4}; string(str) != BinaryString(str) {\n\t\tt.Fatalf(\"BinaryString mismatch\")\n\t}\n}\n\nfunc TestJSON(t *testing.T) {\n\tif v := JSON(\"a\"); v != `\"a\"` {\n\t\tt.Fatalf(\"unexpected JSON result\")\n\t}\n}\n\nfunc TestJSONPanic(t *testing.T) {\n\tdefer func() {\n\t\tif m := recover().(*json.UnsupportedValueError); !strings.Contains(m.Error(), \"encountered a cycle\") {\n\t\t\tt.Fatalf(\"should panic\")\n\t\t}\n\t}()\n\ta := &recursive{}\n\ta.R = a\n\tJSON(a)\n}\n\n\nfunc TestVectorString32(t *testing.T) {\n\tfor _, test := range [][]float32{\n\t\t{},\n\t\t{0, 0, 0, 0},\n\t\t{9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},\n\t\t{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n\t\t{.9, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9},\n\t\t{-.1, -.1, -.1, -.1, -.1, -.1, -.1, -.1, -.1, -.1},\n\t\t{.1, -.1, .1, -.1, .1, -.1, .1, -.1, .1, -.1},\n\t} {\n\t\tif !reflect.DeepEqual(test, ToVector32(VectorString32(test))) {\n\t\t\tt.Fatalf(\"fail to convert %v\", test)\n\t\t}\n\t}\n}\n\nfunc TestVectorString64(t *testing.T) {\n\tfor _, test := range [][]float64{\n\t\t{},\n\t\t{0, 0, 0, 0},\n\t\t{9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},\n\t\t{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},\n\t\t{.9, .9, .9, .9, .9, .9, .9, .9, .9, .9, .9},\n\t\t{-.1, -.1, -.1, -.1, -.1, -.1, -.1, -.1, -.1, -.1},\n\t\t{.1, -.1, .1, -.1, .1, -.1, .1, -.1, .1, -.1},\n\t} {\n\t\tif !reflect.DeepEqual(test, ToVector64(VectorString64(test))) {\n\t\t\tt.Fatalf(\"fail to convert %v\", test)\n\t\t}\n\t}\n}\n\ntype recursive struct {\n\tR *recursive\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 5.3017578125,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n)\n\n// NewCacheStoreFn can be provided in ClientOption for using a custom CacheStore implementation\ntype NewCacheStoreFn func(CacheStoreOption) CacheStore\n\n// CacheStoreOption will be passed to NewCacheStoreFn\ntype CacheStoreOption struct {\n\t// CacheSizeEachConn is redis client side cache size that bind to each TCP connection to a single redis instance.\n\t// The default is DefaultCacheBytes.\n\tCacheSizeEachConn int\n}\n\n// CacheStore is the store interface for the client side caching\n// More detailed interface requirement can be found in cache_test.go\ntype CacheStore interface {\n\t// Flight is called when DoCache and DoMultiCache, with the requested client side ttl and the current time.\n\t// It should look up the store in single-flight manner and return one of the following three combinations:\n\t// Case 1: (empty RedisMessage, nil CacheEntry)     <- when cache missed, and rueidis will send the request to redis.\n\t// Case 2: (empty RedisMessage, non-nil CacheEntry) <- when cache missed, and rueidis will use CacheEntry.Wait to wait for response.\n\t// Case 3: (non-empty RedisMessage, nil CacheEntry) <- when cache hit\n\tFlight(key, cmd string, ttl time.Duration, now time.Time) (v RedisMessage, e CacheEntry)\n\t// Update is called when receiving the response of the request sent by the above Flight Case 1 from redis.\n\t// It should not only update the store but also deliver the response to all CacheEntry.Wait and return a desired client side PXAT of the response.\n\t// Note that the server side expire time can be retrieved from RedisMessage.CachePXAT.\n\tUpdate(key, cmd string, val RedisMessage) (pxat int64)\n\t// Cancel is called when the request sent by the above Flight Case 1 failed.\n\t// It should not only deliver the error to all CacheEntry.Wait but also remove the CacheEntry from the store.\n\tCancel(key, cmd string, err error)\n\t// Delete is called when receiving invalidation notifications from redis.\n\t// If the keys is nil then it should delete all non-pending cached entries under all keys.\n\t// If the keys is not nil then it should delete all non-pending cached entries under those keys.\n\tDelete(keys []RedisMessage)\n\t// Close is called when connection between redis is broken.\n\t// It should flush all cached entries and deliver the error to all pending CacheEntry.Wait.\n\tClose(err error)\n}\n\n// CacheEntry should be used to wait for single-flight response when cache missed.\ntype CacheEntry interface {\n\tWait(ctx context.Context) (RedisMessage, error)\n}\n\n// SimpleCache is an alternative interface should be paired with NewSimpleCacheAdapter to construct a CacheStore\ntype SimpleCache interface {\n\tGet(key string) RedisMessage\n\tSet(key string, val RedisMessage)\n\tDel(key string)\n\tFlush()\n}\n\n// NewSimpleCacheAdapter converts a SimpleCache into CacheStore\nfunc NewSimpleCacheAdapter(store SimpleCache) CacheStore {\n\treturn &adapter{store: store, flights: make(map[string]map[string]CacheEntry)}\n}\n\ntype adapter struct {\n\tstore   SimpleCache\n\tflights map[string]map[string]CacheEntry\n\tmu      sync.RWMutex\n}\n\nfunc (a *adapter) Flight(key, cmd string, ttl time.Duration, now time.Time) (RedisMessage, CacheEntry) {\n\ta.mu.RLock()\n\tif v := a.store.Get(key + cmd); v.typ != 0 && v.relativePTTL(now) > 0 {\n\t\ta.mu.RUnlock()\n\t\treturn v, nil\n\t}\n\tflight := a.flights[key][cmd]\n\ta.mu.RUnlock()\n\tif flight != nil {\n\t\treturn RedisMessage{}, flight\n\t}\n\ta.mu.Lock()\n\tentries := a.flights[key]\n\tif entries == nil && a.flights != nil {\n\t\tentries = make(map[string]CacheEntry, 1)\n\t\ta.flights[key] = entries\n\t}\n\tif flight = entries[cmd]; flight == nil && entries != nil {\n\t\tentries[cmd] = &adapterEntry{ch: make(chan struct{}), xat: now.Add(ttl).UnixMilli()}\n\t}\n\ta.mu.Unlock()\n\treturn RedisMessage{}, flight\n}\n\nfunc (a *adapter) Update(key, cmd string, val RedisMessage) (sxat int64) {\n\ta.mu.Lock()\n\tentries := a.flights[key]\n\tif flight, ok := entries[cmd].(*adapterEntry); ok {\n\t\tsxat = val.getExpireAt()\n\t\tif flight.xat < sxat || sxat == 0 {\n\t\t\tsxat = flight.xat\n\t\t\tval.setExpireAt(sxat)\n\t\t}\n\t\ta.store.Set(key+cmd, val)\n\t\tflight.set(val, nil)\n\t\tentries[cmd] = nil\n\t}\n\ta.mu.Unlock()\n\treturn\n}\n\nfunc (a *adapter) Cancel(key, cmd string, err error) {\n\ta.mu.Lock()\n\tentries := a.flights[key]\n\tif flight, ok := entries[cmd].(*adapterEntry); ok {\n\t\tflight.set(RedisMessage{}, err)\n\t\tentries[cmd] = nil\n\t}\n\ta.mu.Unlock()\n}\n\nfunc (a *adapter) del(key string) {\n\tentries := a.flights[key]\n\tfor cmd, e := range entries {\n\t\tif e == nil {\n\t\t\ta.store.Del(key + cmd)\n\t\t\tdelete(entries, cmd)\n\t\t}\n\t}\n\tif len(entries) == 0 {\n\t\tdelete(a.flights, key)\n\t}\n}\n\nfunc (a *adapter) Delete(keys []RedisMessage) {\n\ta.mu.Lock()\n\tif keys == nil {\n\t\tfor key := range a.flights {\n\t\t\ta.del(key)\n\t\t}\n\t} else {\n\t\tfor _, k := range keys {\n\t\t\ta.del(k.string)\n\t\t}\n\t}\n\ta.mu.Unlock()\n}\n\nfunc (a *adapter) Close(err error) {\n\ta.mu.Lock()\n\tflights := a.flights\n\ta.flights = nil\n\ta.store.Flush()\n\ta.mu.Unlock()\n\tfor _, entries := range flights {\n\t\tfor _, e := range entries {\n\t\t\tif e != nil {\n\t\t\t\te.(*adapterEntry).set(RedisMessage{}, err)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype adapterEntry struct {\n\terr error\n\tch  chan struct{}\n\tval RedisMessage\n\txat int64\n}\n\nfunc (a *adapterEntry) set(val RedisMessage, err error) {\n\ta.err, a.val = err, val\n\tclose(a.ch)\n}\n\nfunc (a *adapterEntry) Wait(ctx context.Context) (RedisMessage, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn RedisMessage{}, ctx.Err()\n\tcase <-a.ch:\n\t\treturn a.val, a.err\n\t}\n}\n"
        },
        {
          "name": "cache_test.go",
          "type": "blob",
          "size": 6.244140625,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc test(t *testing.T, storeFn func() CacheStore) {\n\tt.Run(\"Flight and Update\", func(t *testing.T) {\n\t\tvar err error\n\t\tvar now = time.Now()\n\t\tvar store = storeFn()\n\n\t\tv, e := store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v.typ != 0 || e != nil {\n\t\t\tt.Fatal(\"first flight should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\n\t\tv, e = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v.typ != 0 || e == nil {\n\t\t\tt.Fatal(\"flights before Update should return empty RedisMessage and non-nil CacheEntry\")\n\t\t}\n\n\t\tstore.Delete([]RedisMessage{{typ: '+', string: \"key\"}}) // Delete should not affect pending CacheEntry\n\n\t\tv2, e2 := store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v2.typ != 0 || e != e2 {\n\t\t\tt.Fatal(\"flights before Update should return empty RedisMessage and the same CacheEntry, not be affected by Delete\")\n\t\t}\n\n\t\tv = RedisMessage{typ: '+', string: \"val\"}\n\t\tv.setExpireAt(now.Add(time.Second).UnixMilli())\n\t\tif pttl := store.Update(\"key\", \"cmd\", v); pttl < now.Add(90*time.Millisecond).UnixMilli() || pttl > now.Add(100*time.Millisecond).UnixMilli() {\n\t\t\tt.Fatal(\"Update should return a desired pttl\")\n\t\t}\n\n\t\tv2, err = e.Wait(context.Background())\n\t\tif v2.typ != v.typ || v2.string != v.string || err != nil {\n\t\t\tt.Fatal(\"unexpected cache response\")\n\t\t}\n\t\tif pttl := v2.CachePXAT(); pttl < now.Add(90*time.Millisecond).UnixMilli() || pttl > now.Add(100*time.Millisecond).UnixMilli() {\n\t\t\tt.Fatal(\"CachePXAT should return a desired pttl\")\n\t\t}\n\n\t\tv2, _ = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v2.typ != v.typ || v2.string != v.string {\n\t\t\tt.Fatal(\"flights after Update should return updated RedisMessage\")\n\t\t}\n\t\tif pttl := v2.CachePXAT(); pttl < now.Add(90*time.Millisecond).UnixMilli() || pttl > now.Add(100*time.Millisecond).UnixMilli() {\n\t\t\tt.Fatal(\"CachePXAT should return a desired pttl\")\n\t\t}\n\n\t\tstore.Delete([]RedisMessage{{typ: '+', string: \"key\"}})\n\t\tv, e = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v.typ != 0 || e != nil {\n\t\t\tt.Fatal(\"flights after Delete should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\t})\n\n\tt.Run(\"Flight and Cancel\", func(t *testing.T) {\n\t\tvar err error\n\t\tvar now = time.Now()\n\t\tvar store = storeFn()\n\n\t\tv, e := store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v.typ != 0 || e != nil {\n\t\t\tt.Fatal(\"first flight should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\n\t\tv, e = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v.typ != 0 || e == nil {\n\t\t\tt.Fatal(\"flights before Update should return empty RedisMessage and non-nil CacheEntry\")\n\t\t}\n\n\t\tstore.Delete([]RedisMessage{{typ: '+', string: \"key\"}}) // Delete should not affect pending CacheEntry\n\n\t\tv2, e2 := store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v2.typ != 0 || e != e2 {\n\t\t\tt.Fatal(\"flights before Update should return empty RedisMessage and the same CacheEntry, not be affected by Delete\")\n\t\t}\n\n\t\tstore.Cancel(\"key\", \"cmd\", errors.New(\"err\"))\n\n\t\tv2, err = e.Wait(context.Background())\n\t\tif err.Error() != \"err\" {\n\t\t\tt.Fatal(\"unexpected cache response\")\n\t\t}\n\n\t\tv, e = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif v.typ != 0 || e != nil {\n\t\t\tt.Fatal(\"flights after Cancel should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\t})\n\n\tt.Run(\"Flight and Delete\", func(t *testing.T) {\n\t\tvar now = time.Now()\n\t\tvar store = storeFn()\n\n\t\tfor _, deletions := range [][]RedisMessage{\n\t\t\t{{typ: '+', string: \"key\"}},\n\t\t\tnil,\n\t\t} {\n\t\t\tstore.Flight(\"key\", \"cmd1\", time.Millisecond*100, now)\n\t\t\tstore.Flight(\"key\", \"cmd2\", time.Millisecond*100, now)\n\t\t\tstore.Update(\"key\", \"cmd1\", RedisMessage{typ: '+', string: \"val\"})\n\t\t\tstore.Update(\"key\", \"cmd2\", RedisMessage{typ: '+', string: \"val\"})\n\n\t\t\tstore.Delete(deletions)\n\n\t\t\tif v, e := store.Flight(\"key\", \"cmd1\", time.Millisecond*100, now); v.typ != 0 || e != nil {\n\t\t\t\tt.Fatal(\"flight after delete should return empty RedisMessage and nil CacheEntry\")\n\t\t\t}\n\n\t\t\tif v, e := store.Flight(\"key\", \"cmd2\", time.Millisecond*100, now); v.typ != 0 || e != nil {\n\t\t\t\tt.Fatal(\"flight after delete should return empty RedisMessage and nil CacheEntry\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Flight and TTL\", func(t *testing.T) {\n\t\tvar now = time.Now()\n\t\tvar store = storeFn()\n\n\t\tv, e := store.Flight(\"key\", \"cmd\", time.Second, now)\n\t\tif v.typ != 0 || e != nil {\n\t\t\tt.Fatal(\"first flight should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\n\t\tv = RedisMessage{typ: '+', string: \"val\"}\n\t\tv.setExpireAt(now.Add(time.Millisecond).UnixMilli())\n\t\tstore.Update(\"key\", \"cmd\", v)\n\n\t\tv, e = store.Flight(\"key\", \"cmd\", time.Second, now.Add(time.Millisecond))\n\t\tif v.typ != 0 || e != nil {\n\t\t\tt.Fatal(\"flight after TTL should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\t})\n\n\tt.Run(\"Flight and Close\", func(t *testing.T) {\n\t\tvar now = time.Now()\n\t\tvar store = storeFn()\n\n\t\t_, _ = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\t_, e := store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\n\t\tstore.Close(errors.New(\"err\"))\n\n\t\tif _, err := e.Wait(context.Background()); err.Error() != \"err\" {\n\t\t\tt.Fatal(\"unexpected cache response\")\n\t\t}\n\n\t\t_, e = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\tif e != nil {\n\t\t\tt.Fatal(\"flight after Close should return empty RedisMessage and nil CacheEntry\")\n\t\t}\n\t})\n\n\tt.Run(\"Flight timeout\", func(t *testing.T) {\n\t\tvar now = time.Now()\n\t\tvar store = storeFn()\n\n\t\t_, _ = store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\t\t_, e := store.Flight(\"key\", \"cmd\", time.Millisecond*100, now)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif _, err := e.Wait(ctx); err != context.Canceled {\n\t\t\tt.Fatal(\"Wait should honor context\")\n\t\t}\n\t})\n}\n\nfunc TestCacheStore(t *testing.T) {\n\tt.Run(\"LRUCacheStore\", func(t *testing.T) {\n\t\ttest(t, func() CacheStore {\n\t\t\treturn newLRU(CacheStoreOption{CacheSizeEachConn: DefaultCacheBytes})\n\t\t})\n\t})\n\tt.Run(\"SimpleCache\", func(t *testing.T) {\n\t\ttest(t, func() CacheStore {\n\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t})\n\t})\n}\n\ntype simple struct {\n\tstore map[string]RedisMessage\n}\n\nfunc (s *simple) Get(key string) RedisMessage {\n\treturn s.store[key]\n}\n\nfunc (s *simple) Set(key string, val RedisMessage) {\n\ts.store[key] = val\n}\n\nfunc (s *simple) Del(key string) {\n\tdelete(s.store, key)\n}\n\nfunc (s *simple) Flush() {\n\ts.store = nil\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 8.1728515625,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\ntype singleClient struct {\n\tconn         conn\n\tcmd          Builder\n\tretryHandler retryHandler\n\tstop         uint32\n\tretry        bool\n\tDisableCache bool\n}\n\nfunc newSingleClient(opt *ClientOption, prev conn, connFn connFn, retryer retryHandler) (*singleClient, error) {\n\tif len(opt.InitAddress) == 0 {\n\t\treturn nil, ErrNoAddr\n\t}\n\n\tif opt.ReplicaOnly {\n\t\treturn nil, ErrReplicaOnlyNotSupported\n\t}\n\n\tconn := connFn(opt.InitAddress[0], opt)\n\tconn.Override(prev)\n\tif err := conn.Dial(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn newSingleClientWithConn(conn, cmds.NewBuilder(cmds.NoSlot), !opt.DisableRetry, opt.DisableCache, retryer), nil\n}\n\nfunc newSingleClientWithConn(conn conn, builder Builder, retry, disableCache bool, retryer retryHandler) *singleClient {\n\treturn &singleClient{cmd: builder, conn: conn, retry: retry, retryHandler: retryer, DisableCache: disableCache}\n}\n\nfunc (c *singleClient) B() Builder {\n\treturn c.cmd\n}\n\nfunc (c *singleClient) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tresp = c.conn.Do(ctx, cmd)\n\tif c.retry && cmd.IsReadOnly() && c.isRetryable(resp.Error(), ctx) {\n\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\tctx, attempts, cmd, resp.Error(),\n\t\t)\n\t\tif shouldRetry {\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\n\tif resp.NonRedisError() == nil { // not recycle cmds if error, since cmds may be used later in pipe. consider recycle them by pipe\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *singleClient) DoStream(ctx context.Context, cmd Completed) RedisResultStream {\n\ts := c.conn.DoStream(ctx, cmd)\n\tcmds.PutCompleted(cmd)\n\treturn s\n}\n\nfunc (c *singleClient) DoMultiStream(ctx context.Context, multi ...Completed) MultiRedisResultStream {\n\tif len(multi) == 0 {\n\t\treturn RedisResultStream{e: io.EOF}\n\t}\n\ts := c.conn.DoMultiStream(ctx, multi...)\n\tfor _, cmd := range multi {\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn s\n}\n\nfunc (c *singleClient) DoMulti(ctx context.Context, multi ...Completed) (resps []RedisResult) {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\tattempts := 1\nretry:\n\tresps = c.conn.DoMulti(ctx, multi...).s\n\tif c.retry && allReadOnly(multi) {\n\t\tfor i, resp := range resps {\n\t\t\tif c.isRetryable(resp.Error(), ctx) {\n\t\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\t\tctx, attempts, multi[i], resp.Error(),\n\t\t\t\t)\n\t\t\t\tif shouldRetry {\n\t\t\t\t\tattempts++\n\t\t\t\t\tgoto retry\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor i, cmd := range multi {\n\t\tif resps[i].NonRedisError() == nil {\n\t\t\tcmds.PutCompleted(cmd)\n\t\t}\n\t}\n\treturn resps\n}\n\nfunc (c *singleClient) DoMultiCache(ctx context.Context, multi ...CacheableTTL) (resps []RedisResult) {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\tattempts := 1\nretry:\n\tresps = c.conn.DoMultiCache(ctx, multi...).s\n\tif c.retry {\n\t\tfor i, resp := range resps {\n\t\t\tif c.isRetryable(resp.Error(), ctx) {\n\t\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\t\tctx, attempts, Completed(multi[i].Cmd), resp.Error(),\n\t\t\t\t)\n\t\t\t\tif shouldRetry {\n\t\t\t\t\tattempts++\n\t\t\t\t\tgoto retry\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor i, cmd := range multi {\n\t\tif err := resps[i].NonRedisError(); err == nil || err == ErrDoCacheAborted {\n\t\t\tcmds.PutCacheable(cmd.Cmd)\n\t\t}\n\t}\n\treturn resps\n}\n\nfunc (c *singleClient) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tresp = c.conn.DoCache(ctx, cmd, ttl)\n\tif c.retry && c.isRetryable(resp.Error(), ctx) {\n\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, Completed(cmd), resp.Error())\n\t\tif shouldRetry {\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\n\tif err := resp.NonRedisError(); err == nil || err == ErrDoCacheAborted {\n\t\tcmds.PutCacheable(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *singleClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) {\n\tattempts := 1\nretry:\n\terr = c.conn.Receive(ctx, subscribe, fn)\n\tif c.retry {\n\t\tif _, ok := err.(*RedisError); !ok && c.isRetryable(err, ctx) {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, subscribe, err)\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil {\n\t\tcmds.PutCompleted(subscribe)\n\t}\n\treturn err\n}\n\nfunc (c *singleClient) Dedicated(fn func(DedicatedClient) error) (err error) {\n\twire := c.conn.Acquire()\n\tdsc := &dedicatedSingleClient{cmd: c.cmd, conn: c.conn, wire: wire, retry: c.retry, retryHandler: c.retryHandler}\n\terr = fn(dsc)\n\tdsc.release()\n\treturn err\n}\n\nfunc (c *singleClient) Dedicate() (DedicatedClient, func()) {\n\twire := c.conn.Acquire()\n\tdsc := &dedicatedSingleClient{cmd: c.cmd, conn: c.conn, wire: wire, retry: c.retry, retryHandler: c.retryHandler}\n\treturn dsc, dsc.release\n}\n\nfunc (c *singleClient) Nodes() map[string]Client {\n\treturn map[string]Client{c.conn.Addr(): c}\n}\n\nfunc (c *singleClient) Close() {\n\tatomic.StoreUint32(&c.stop, 1)\n\tc.conn.Close()\n}\n\ntype dedicatedSingleClient struct {\n\tconn         conn\n\twire         wire\n\tcmd          Builder\n\tretryHandler retryHandler\n\tmark         uint32\n\tretry        bool\n}\n\nfunc (c *dedicatedSingleClient) B() Builder {\n\treturn c.cmd\n}\n\nfunc (c *dedicatedSingleClient) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tif err := c.check(); err != nil {\n\t\treturn newErrResult(err)\n\t}\n\tresp = c.wire.Do(ctx, cmd)\n\tif c.retry && cmd.IsReadOnly() && isRetryable(resp.Error(), c.wire, ctx) {\n\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\tctx, attempts, cmd, resp.Error(),\n\t\t)\n\t\tif shouldRetry {\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\n\tif resp.NonRedisError() == nil {\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *dedicatedSingleClient) DoMulti(ctx context.Context, multi ...Completed) (resp []RedisResult) {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\tattempts := 1\n\tretryable := c.retry\n\tif retryable {\n\t\tretryable = allReadOnly(multi)\n\t}\nretry:\n\tif err := c.check(); err != nil {\n\t\treturn fillErrs(len(multi), err)\n\t}\n\tresp = c.wire.DoMulti(ctx, multi...).s\n\tfor i, cmd := range multi {\n\t\tif retryable && isRetryable(resp[i].Error(), c.wire, ctx) {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\tctx, attempts, multi[i], resp[i].Error(),\n\t\t\t)\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t\tif resp[i].NonRedisError() == nil {\n\t\t\tcmds.PutCompleted(cmd)\n\t\t}\n\t}\n\treturn resp\n}\n\nfunc (c *dedicatedSingleClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) {\n\tattempts := 1\nretry:\n\tif err := c.check(); err != nil {\n\t\treturn err\n\t}\n\terr = c.wire.Receive(ctx, subscribe, fn)\n\tif c.retry {\n\t\tif _, ok := err.(*RedisError); !ok && isRetryable(err, c.wire, ctx) {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\tctx, attempts, subscribe, err,\n\t\t\t)\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil {\n\t\tcmds.PutCompleted(subscribe)\n\t}\n\treturn err\n}\n\nfunc (c *dedicatedSingleClient) SetPubSubHooks(hooks PubSubHooks) <-chan error {\n\tif err := c.check(); err != nil {\n\t\tch := make(chan error, 1)\n\t\tch <- err\n\t\treturn ch\n\t}\n\treturn c.wire.SetPubSubHooks(hooks)\n}\n\nfunc (c *dedicatedSingleClient) Close() {\n\tc.wire.Close()\n\tc.release()\n}\n\nfunc (c *dedicatedSingleClient) check() error {\n\tif atomic.LoadUint32(&c.mark) != 0 {\n\t\treturn ErrDedicatedClientRecycled\n\t}\n\treturn nil\n}\n\nfunc (c *dedicatedSingleClient) release() {\n\tif atomic.CompareAndSwapUint32(&c.mark, 0, 1) {\n\t\tc.conn.Store(c.wire)\n\t}\n}\n\nfunc (c *singleClient) isRetryable(err error, ctx context.Context) bool {\n\tif err == nil || err == Nil || err == ErrDoCacheAborted || atomic.LoadUint32(&c.stop) != 0 || ctx.Err() != nil {\n\t\treturn false\n\t}\n\tif err, ok := err.(*RedisError); ok {\n\t\treturn err.IsLoading()\n\t}\n\treturn true\n}\n\nfunc isRetryable(err error, w wire, ctx context.Context) bool {\n\tif err == nil || err == Nil || w.Error() != nil || ctx.Err() != nil {\n\t\treturn false\n\t}\n\tif err, ok := err.(*RedisError); ok {\n\t\treturn err.IsLoading()\n\t}\n\treturn true\n}\n\nfunc allReadOnly(multi []Completed) bool {\n\tfor _, cmd := range multi {\n\t\tif cmd.IsWrite() {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc chooseSlot(multi []Completed) uint16 {\n\tfor i := 0; i < len(multi); i++ {\n\t\tif multi[i].Slot() != cmds.InitSlot {\n\t\t\tfor j := i + 1; j < len(multi); j++ {\n\t\t\t\tif multi[j].Slot() != cmds.InitSlot && multi[j].Slot() != multi[i].Slot() {\n\t\t\t\t\treturn cmds.NoSlot\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn multi[i].Slot()\n\t\t}\n\t}\n\treturn cmds.InitSlot\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 44.671875,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype mockConn struct {\n\tDoFn            func(cmd Completed) RedisResult\n\tDoCacheFn       func(cmd Cacheable, ttl time.Duration) RedisResult\n\tDoMultiFn       func(multi ...Completed) *redisresults\n\tDoMultiCacheFn  func(multi ...CacheableTTL) *redisresults\n\tReceiveFn       func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error\n\tDoStreamFn      func(cmd Completed) RedisResultStream\n\tDoMultiStreamFn func(cmd ...Completed) MultiRedisResultStream\n\tInfoFn          func() map[string]RedisMessage\n\tVersionFn       func() int\n\tErrorFn         func() error\n\tCloseFn         func()\n\tDialFn          func() error\n\tAcquireFn       func() wire\n\tStoreFn         func(w wire)\n\tOverrideFn      func(c conn)\n\tAddrFn          func() string\n\n\tDoOverride      map[string]func(cmd Completed) RedisResult\n\tDoCacheOverride map[string]func(cmd Cacheable, ttl time.Duration) RedisResult\n\tReceiveOverride map[string]func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error\n}\n\nfunc (m *mockConn) Override(c conn) {\n\tif m.OverrideFn != nil {\n\t\tm.OverrideFn(c)\n\t}\n}\n\nfunc (m *mockConn) Dial() error {\n\tif m.DialFn != nil {\n\t\treturn m.DialFn()\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) Acquire() wire {\n\tif m.AcquireFn != nil {\n\t\treturn m.AcquireFn()\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) Store(w wire) {\n\tif m.StoreFn != nil {\n\t\tm.StoreFn(w)\n\t}\n}\n\nfunc (m *mockConn) Do(ctx context.Context, cmd Completed) RedisResult {\n\tif fn := m.DoOverride[strings.Join(cmd.Commands(), \" \")]; fn != nil {\n\t\treturn fn(cmd)\n\t}\n\tif m.DoFn != nil {\n\t\treturn m.DoFn(cmd)\n\t}\n\treturn RedisResult{}\n}\n\nfunc (m *mockConn) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult {\n\tif fn := m.DoCacheOverride[strings.Join(cmd.Commands(), \" \")]; fn != nil {\n\t\treturn fn(cmd, ttl)\n\t}\n\tif m.DoCacheFn != nil {\n\t\treturn m.DoCacheFn(cmd, ttl)\n\t}\n\treturn RedisResult{}\n}\n\nfunc (m *mockConn) DoMultiCache(ctx context.Context, multi ...CacheableTTL) *redisresults {\n\toverrides := make([]RedisResult, 0, len(multi))\n\tfor _, cmd := range multi {\n\t\tif fn := m.DoCacheOverride[strings.Join(cmd.Cmd.Commands(), \" \")]; fn != nil {\n\t\t\toverrides = append(overrides, fn(cmd.Cmd, cmd.TTL))\n\t\t}\n\t}\n\tif len(overrides) == len(multi) {\n\t\treturn &redisresults{s: overrides}\n\t}\n\tif m.DoMultiCacheFn != nil {\n\t\treturn m.DoMultiCacheFn(multi...)\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) DoMulti(ctx context.Context, multi ...Completed) *redisresults {\n\toverrides := make([]RedisResult, 0, len(multi))\n\tfor _, cmd := range multi {\n\t\tif fn := m.DoOverride[strings.Join(cmd.Commands(), \" \")]; fn != nil {\n\t\t\toverrides = append(overrides, fn(cmd))\n\t\t}\n\t}\n\tif len(overrides) == len(multi) {\n\t\treturn &redisresults{s: overrides}\n\t}\n\tif m.DoMultiFn != nil {\n\t\treturn m.DoMultiFn(multi...)\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) Receive(ctx context.Context, subscribe Completed, hdl func(message PubSubMessage)) error {\n\tif fn := m.ReceiveOverride[strings.Join(subscribe.Commands(), \" \")]; fn != nil {\n\t\treturn fn(ctx, subscribe, hdl)\n\t}\n\tif m.ReceiveFn != nil {\n\t\treturn m.ReceiveFn(ctx, subscribe, hdl)\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) DoStream(ctx context.Context, cmd Completed) RedisResultStream {\n\tif m.DoStreamFn != nil {\n\t\treturn m.DoStreamFn(cmd)\n\t}\n\treturn RedisResultStream{}\n}\n\nfunc (m *mockConn) DoMultiStream(ctx context.Context, cmd ...Completed) MultiRedisResultStream {\n\tif m.DoMultiStreamFn != nil {\n\t\treturn m.DoMultiStreamFn(cmd...)\n\t}\n\treturn MultiRedisResultStream{}\n}\n\nfunc (m *mockConn) CleanSubscriptions() {\n\tpanic(\"not implemented\")\n}\n\nfunc (m *mockConn) SetPubSubHooks(_ PubSubHooks) <-chan error {\n\tpanic(\"not implemented\")\n}\n\nfunc (m *mockConn) SetOnCloseHook(func(error)) {\n\n}\n\nfunc (m *mockConn) Info() map[string]RedisMessage {\n\tif m.InfoFn != nil {\n\t\treturn m.InfoFn()\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) Version() int {\n\tif m.VersionFn != nil {\n\t\treturn m.VersionFn()\n\t}\n\treturn 0\n}\n\nfunc (m *mockConn) Error() error {\n\tif m.ErrorFn != nil {\n\t\treturn m.ErrorFn()\n\t}\n\treturn nil\n}\n\nfunc (m *mockConn) Close() {\n\tif m.CloseFn != nil {\n\t\tm.CloseFn()\n\t}\n}\n\nfunc (m *mockConn) Addr() string {\n\tif m.AddrFn != nil {\n\t\treturn m.AddrFn()\n\t}\n\treturn \"\"\n}\n\nfunc TestNewSingleClientNoNode(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tif _, err := newSingleClient(\n\t\t&ClientOption{}, nil, func(dst string, opt *ClientOption) conn {\n\t\t\treturn nil\n\t\t}, newRetryer(defaultRetryDelayFn),\n\t); err != ErrNoAddr {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestNewSingleClientReplicaOnlyNotSupported(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tif _, err := newSingleClient(\n\t\t&ClientOption{ReplicaOnly: true, InitAddress: []string{\"localhost\"}}, nil, func(dst string, opt *ClientOption) conn { return nil }, newRetryer(defaultRetryDelayFn),\n\t); err != ErrReplicaOnlyNotSupported {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestNewSingleClientError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tv := errors.New(\"dail err\")\n\tif _, err := newSingleClient(\n\t\t&ClientOption{InitAddress: []string{\"\"}}, nil, func(dst string, opt *ClientOption) conn { return &mockConn{DialFn: func() error { return v }} }, newRetryer(defaultRetryDelayFn),\n\t); err != v {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestNewSingleClientOverride(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tm1 := &mockConn{}\n\tvar m2 conn\n\tif _, err := newSingleClient(\n\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\tm1,\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\treturn &mockConn{OverrideFn: func(c conn) { m2 = c }}\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t); err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif m2.(*mockConn) != m1 {\n\t\tt.Fatalf(\"unexpected m2 %v\", m2)\n\t}\n}\n\n//gocyclo:ignore\nfunc TestSingleClient(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tm := &mockConn{\n\t\tAddrFn: func() string { return \"myaddr\" },\n\t}\n\tclient, err := newSingleClient(\n\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\tm,\n\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Nodes\", func(t *testing.T) {\n\t\tif nodes := client.Nodes(); len(nodes) != 1 || nodes[\"myaddr\"] != client {\n\t\t\tt.Fatalf(\"unexpected nodes\")\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif !reflect.DeepEqual(cmd.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoStream\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoStreamFn = func(cmd Completed) RedisResultStream {\n\t\t\treturn RedisResultStream{e: errors.New(cmd.Commands()[1])}\n\t\t}\n\t\tif s := client.DoStream(context.Background(), c); s.Error().Error() != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\tif !reflect.DeepEqual(cmd[0].Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)}}\n\t\t}\n\t\tif len(client.DoMulti(context.Background())) != 0 {\n\t\t\tt.Fatalf(\"unexpected response length\")\n\t\t}\n\t\tif v, err := client.DoMulti(context.Background(), c)[0].ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiStream\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoMultiStreamFn = func(cmd ...Completed) MultiRedisResultStream {\n\t\t\treturn MultiRedisResultStream{e: errors.New(cmd[0].Commands()[1])}\n\t\t}\n\t\tif s := client.DoMultiStream(context.Background()); s.Error() != io.EOF {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t\tif s := client.DoMultiStream(context.Background(), c); s.Error().Error() != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tm.DoCacheFn = func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\tif !reflect.DeepEqual(cmd.Commands(), c.Commands()) || ttl != 100 {\n\t\t\t\tt.Fatalf(\"unexpected command %v, %v\", cmd, ttl)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"DoCache\"}, nil)\n\t\t}\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\tif !reflect.DeepEqual(multi[0].Cmd.Commands(), c.Commands()) || multi[0].TTL != 100 {\n\t\t\t\tt.Fatalf(\"unexpected command %v, %v\", multi[0].Cmd, multi[0].TTL)\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"DoCache\"}, nil)}}\n\t\t}\n\t\tif len(client.DoMultiCache(context.Background())) != 0 {\n\t\t\tt.Fatalf(\"unexpected response length\")\n\t\t}\n\t\tif v, err := client.DoMultiCache(context.Background(), CT(c, 100))[0].ToString(); err != nil || v != \"DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tm.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tm.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Close\", func(t *testing.T) {\n\t\tcalled := false\n\t\tm.CloseFn = func() { called = true }\n\t\tclient.Close()\n\t\tif !called {\n\t\t\tt.Fatalf(\"Close is not delegated\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Err\", func(t *testing.T) {\n\t\tv := errors.New(\"fn err\")\n\t\tif err := client.Dedicated(func(client DedicatedClient) error {\n\t\t\treturn v\n\t\t}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Delegate Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Delegate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tm.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor _, resp := range c.DoMulti(context.Background(), c.B().Get().Key(\"a\").Build()) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tm.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor _, resp := range c.DoMulti(context.Background(), c.B().Get().Key(\"a\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Release On Close\", func(t *testing.T) {\n\t\tstored := 0\n\t\tw := &mockWire{}\n\t\tm.AcquireFn = func() wire { return w }\n\t\tm.StoreFn = func(ww wire) { stored++ }\n\t\tc, _ := client.Dedicate()\n\n\t\tc.Close()\n\n\t\tif stored != 1 {\n\t\t\tt.Fatalf(\"unexpected stored count %v\", stored)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate No Duplicate Release\", func(t *testing.T) {\n\t\tstored := 0\n\t\tw := &mockWire{}\n\t\tm.AcquireFn = func() wire { return w }\n\t\tm.StoreFn = func(ww wire) { stored++ }\n\t\tc, cancel := client.Dedicate()\n\n\t\tc.Close()\n\t\tc.Close() // should have no effect\n\t\tcancel()  // should have no effect\n\t\tcancel()  // should have no effect\n\n\t\tif stored != 1 {\n\t\t\tt.Fatalf(\"unexpected stored count %v\", stored)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate ErrDedicatedClientRecycled after released\", func(t *testing.T) {\n\t\tm.AcquireFn = func() wire { return &mockWire{} }\n\t\tcheck := func(err error) {\n\t\t\tif !errors.Is(err, ErrDedicatedClientRecycled) {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tfor _, closeFn := range []func(client DedicatedClient, cancel func()){\n\t\t\tfunc(client DedicatedClient, cancel func()) {\n\t\t\t\tclient.Close()\n\t\t\t},\n\t\t\tfunc(client DedicatedClient, cancel func()) {\n\t\t\t\tcancel()\n\t\t\t},\n\t\t} {\n\t\t\tc, cancel := client.Dedicate()\n\t\t\tcloseFn(c, cancel)\n\t\t\tfor _, fn := range []func(){\n\t\t\t\tfunc() {\n\t\t\t\t\tresp := c.Do(context.Background(), c.B().Get().Key(\"k\").Build())\n\t\t\t\t\tcheck(resp.Error())\n\t\t\t\t},\n\t\t\t\tfunc() {\n\t\t\t\t\tresp := c.DoMulti(context.Background(), c.B().Get().Key(\"k\").Build())\n\t\t\t\t\tfor _, r := range resp {\n\t\t\t\t\t\tcheck(r.Error())\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunc() {\n\t\t\t\t\terr := c.Receive(context.Background(), c.B().Subscribe().Channel(\"k\").Build(), func(msg PubSubMessage) {})\n\t\t\t\t\tcheck(err)\n\t\t\t\t},\n\t\t\t\tfunc() {\n\t\t\t\t\tch := c.SetPubSubHooks(PubSubHooks{})\n\t\t\t\t\tcheck(<-ch)\n\t\t\t\t},\n\t\t\t} {\n\t\t\t\tfn()\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestSingleClientRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tSetupClientRetry(t, func(m *mockConn) Client {\n\t\tc, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn c\n\t})\n}\n\n//gocyclo:ignore\nfunc SetupClientRetry(t *testing.T, fn func(mock *mockConn) Client) {\n\tsetup := func() (Client, *mockConn) {\n\t\tm := &mockConn{}\n\t\treturn fn(m), m\n\t}\n\n\tmakeDoFn := func(results ...RedisResult) func(cmd Completed) RedisResult {\n\t\tcount := -1\n\t\treturn func(cmd Completed) RedisResult {\n\t\t\tcount++\n\t\t\treturn results[count]\n\t\t}\n\t}\n\n\tmakeDoCacheFn := func(results ...RedisResult) func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\tcount := -1\n\t\treturn func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\tcount++\n\t\t\treturn results[count]\n\t\t}\n\t}\n\n\tmakeReceiveFn := func(results ...error) func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\tcount := -1\n\t\treturn func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tcount++\n\t\t\treturn results[count]\n\t\t}\n\t}\n\n\tmakeDoMultiFn := func(results ...[]RedisResult) func(multi ...Completed) *redisresults {\n\t\tcount := -1\n\t\treturn func(multi ...Completed) *redisresults {\n\t\t\tcount++\n\t\t\treturn &redisresults{s: results[count]}\n\t\t}\n\t}\n\n\tmakeDoMultiCacheFn := func(results ...[]RedisResult) func(multi ...CacheableTTL) *redisresults {\n\t\tcount := -1\n\t\treturn func(multi ...CacheableTTL) *redisresults {\n\t\t\tcount++\n\t\t\treturn &redisresults{s: results[count]}\n\t\t}\n\t}\n\n\tt.Run(\"Delegate Do ReadOnly Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(\n\t\t\tnewErrResult(ErrClosing),\n\t\t\tnewResult(RedisMessage{typ: '+', string: \"Do\"}, nil),\n\t\t)\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"Do\").Build()).ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do ReadOnly NoRetry - closed\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(newErrResult(ErrClosing))\n\t\tc.Close()\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"Do\").Build()).ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do ReadOnly NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(newErrResult(ErrClosing))\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif v, err := c.Do(ctx, c.B().Get().Key(\"Do\").Build()).ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do ReadOnly NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tif cli, ok := c.(*sentinelClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*clusterClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*singleClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm.DoFn = makeDoFn(\n\t\t\tnewErrResult(ErrClosing),\n\t\t\tnewResult(RedisMessage{typ: '+', string: \"Do\"}, nil),\n\t\t)\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"Do\").Build()).ToString(); !errors.Is(err, ErrClosing) {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do Write NoRetry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(newErrResult(ErrClosing))\n\t\tif v, err := c.Do(context.Background(), c.B().Set().Key(\"Do\").Value(\"V\").Build()).ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti ReadOnly Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn(\n\t\t\t[]RedisResult{newErrResult(ErrClosing)},\n\t\t\t[]RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)},\n\t\t)\n\t\tif v, err := c.DoMulti(context.Background(), c.B().Get().Key(\"Do\").Build())[0].ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti ReadOnly NoRetry - closed\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tc.Close()\n\t\tif v, err := c.DoMulti(context.Background(), c.B().Get().Key(\"Do\").Build())[0].ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti ReadOnly NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif v, err := c.DoMulti(ctx, c.B().Get().Key(\"Do\").Build())[0].ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti ReadOnly NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tif cli, ok := c.(*sentinelClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*clusterClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\t\treturn -1\n\t\t\t\t},\n\t\t\t\tWaitForRetryFn: func(ctx context.Context, duration time.Duration) {\n\t\t\t\t\tif duration != -1 {\n\t\t\t\t\t\tt.Fatalf(\"unexpected duration %v\", duration)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*singleClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm.DoMultiFn = makeDoMultiFn(\n\t\t\t[]RedisResult{newErrResult(ErrClosing)},\n\t\t\t[]RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)},\n\t\t)\n\t\tif v, err := c.DoMulti(context.Background(), c.B().Get().Key(\"Do\").Build())[0].ToString(); !errors.Is(err, ErrClosing) {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti Write NoRetry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tif v, err := c.DoMulti(context.Background(), c.B().Set().Key(\"Do\").Value(\"V\").Build())[0].ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoCacheFn = makeDoCacheFn(\n\t\t\tnewErrResult(ErrClosing),\n\t\t\tnewResult(RedisMessage{typ: '+', string: \"Do\"}, nil),\n\t\t)\n\t\tif v, err := c.DoCache(context.Background(), c.B().Get().Key(\"Do\").Cache(), 0).ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache NoRetry - closed\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoCacheFn = makeDoCacheFn(newErrResult(ErrClosing))\n\t\tc.Close()\n\t\tif v, err := c.DoCache(context.Background(), c.B().Get().Key(\"Do\").Cache(), 0).ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache ReadOnly NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoCacheFn = makeDoCacheFn(newErrResult(ErrClosing))\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif v, err := c.DoCache(ctx, c.B().Get().Key(\"Do\").Cache(), 0).ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache ReadOnly NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tif cli, ok := c.(*sentinelClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*clusterClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*singleClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm.DoCacheFn = makeDoCacheFn(\n\t\t\tnewErrResult(ErrClosing),\n\t\t\tnewResult(RedisMessage{typ: '+', string: \"Do\"}, nil),\n\t\t)\n\t\tif v, err := c.DoCache(context.Background(), c.B().Get().Key(\"Do\").Cache(), 0).ToString(); !errors.Is(err, ErrClosing) {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiCacheFn = makeDoMultiCacheFn(\n\t\t\t[]RedisResult{newErrResult(ErrClosing)},\n\t\t\t[]RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)},\n\t\t)\n\t\tif v, err := c.DoMultiCache(context.Background(), CT(c.B().Get().Key(\"Do\").Cache(), 0))[0].ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache NoRetry - closed\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiCacheFn = makeDoMultiCacheFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tc.Close()\n\t\tif v, err := c.DoMultiCache(context.Background(), CT(c.B().Get().Key(\"Do\").Cache(), 0))[0].ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache ReadOnly NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiCacheFn = makeDoMultiCacheFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif v, err := c.DoMultiCache(ctx, CT(c.B().Get().Key(\"Do\").Cache(), 0))[0].ToString(); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache ReadOnly NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tif cli, ok := c.(*sentinelClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*clusterClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\t\treturn -1\n\t\t\t\t},\n\t\t\t\tWaitForRetryFn: func(ctx context.Context, duration time.Duration) {\n\t\t\t\t\tif duration != -1 {\n\t\t\t\t\t\tt.Fatalf(\"unexpected duration %v\", duration)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*singleClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm.DoMultiCacheFn = makeDoMultiCacheFn(\n\t\t\t[]RedisResult{newErrResult(ErrClosing)},\n\t\t\t[]RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)},\n\t\t)\n\t\tif v, err := c.DoMultiCache(context.Background(), CT(c.B().Get().Key(\"Do\").Cache(), 0))[0].ToString(); !errors.Is(err, ErrClosing) {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing, nil)\n\t\tif err := c.Receive(context.Background(), c.B().Subscribe().Channel(\"ch\").Build(), nil); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive NoRetry - closed\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing)\n\t\tc.Close()\n\t\tif err := c.Receive(context.Background(), c.B().Subscribe().Channel(\"ch\").Build(), nil); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing)\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif err := c.Receive(ctx, c.B().Subscribe().Channel(\"ch\").Build(), nil); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tif cli, ok := c.(*sentinelClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*clusterClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif cli, ok := c.(*singleClient); ok {\n\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\treturn false\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing, nil)\n\t\tif err := c.Receive(context.Background(), c.B().Subscribe().Channel(\"ch\").Build(), nil); !errors.Is(err, ErrClosing) {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Do ReadOnly Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(\n\t\t\tnewErrResult(ErrClosing),\n\t\t\tnewResult(RedisMessage{typ: '+', string: \"Do\"}, nil),\n\t\t)\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\tif v, err := cc.Do(context.Background(), c.B().Get().Key(\"Do\").Build()).ToString(); err != nil || v != \"Do\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn errors.New(\"done\")\n\t\t}); ret.Error() != \"done\" {\n\t\t\tt.Fatalf(\"Dedicated not executed\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Do ReadOnly NoRetry - broken\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(newErrResult(ErrClosing))\n\t\tm.ErrorFn = func() error { return ErrClosing }\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn, ErrorFn: m.ErrorFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.Do(context.Background(), c.B().Get().Key(\"Do\").Build()).Error()\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Do ReadOnly NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(newErrResult(ErrClosing))\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn} }\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.Do(ctx, c.B().Get().Key(\"Do\").Build()).Error()\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Do ReadOnly NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(\n\t\t\tnewErrResult(ErrClosing),\n\t\t\tnewResult(RedisMessage{typ: '+', string: \"Do\"}, nil),\n\t\t)\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\tif cli, ok := cc.(*dedicatedClusterClient); ok {\n\t\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cli, ok := cc.(*dedicatedSingleClient); ok {\n\t\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif v, err := cc.Do(context.Background(), c.B().Get().Key(\"Do\").Build()).ToString(); !errors.Is(err, ErrClosing) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn errors.New(\"done\")\n\t\t}); ret.Error() != \"done\" {\n\t\t\tt.Fatalf(\"Dedicated not executed\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Do Write NoRetry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoFn = makeDoFn(newErrResult(ErrClosing))\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.Do(context.Background(), c.B().Set().Key(\"Do\").Value(\"Do\").Build()).Error()\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate DoMulti ReadOnly Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn(\n\t\t\t[]RedisResult{newErrResult(ErrClosing)},\n\t\t\t[]RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)},\n\t\t)\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\tif v, err := cc.DoMulti(context.Background(), c.B().Get().Key(\"Do\").Build())[0].ToString(); err != nil || v != \"Do\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn errors.New(\"done\")\n\t\t}); ret.Error() != \"done\" {\n\t\t\tt.Fatalf(\"Dedicated not executed\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate DoMulti ReadOnly NoRetry - broken\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tm.ErrorFn = func() error { return ErrClosing }\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn, ErrorFn: m.ErrorFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.DoMulti(context.Background(), c.B().Get().Key(\"Do\").Build())[0].Error()\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate DoMulti ReadOnly NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn} }\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.DoMulti(ctx, c.B().Get().Key(\"Do\").Build())[0].Error()\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate DoMulti ReadOnly NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn(\n\t\t\t[]RedisResult{newErrResult(ErrClosing)},\n\t\t\t[]RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)},\n\t\t)\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\tif cli, ok := cc.(*dedicatedClusterClient); ok {\n\t\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cli, ok := cc.(*dedicatedSingleClient); ok {\n\t\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif v, err := cc.DoMulti(context.Background(), c.B().Get().Key(\"Do\").Build())[0].ToString(); !errors.Is(err, ErrClosing) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn errors.New(\"done\")\n\t\t}); ret.Error() != \"done\" {\n\t\t\tt.Fatalf(\"Dedicated not executed\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate DoMulti Write NoRetry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.DoMultiFn = makeDoMultiFn([]RedisResult{newErrResult(ErrClosing)})\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.DoMulti(context.Background(), c.B().Set().Key(\"Do\").Value(\"Do\").Build())[0].Error()\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive Retry\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing, nil)\n\t\tm.AcquireFn = func() wire { return &mockWire{ReceiveFn: m.ReceiveFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\tif err := cc.Receive(context.Background(), c.B().Subscribe().Channel(\"Do\").Build(), nil); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t\treturn errors.New(\"done\")\n\t\t}); ret.Error() != \"done\" {\n\t\t\tt.Fatalf(\"Dedicated not executed\")\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive NoRetry - broken\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing)\n\t\tm.ErrorFn = func() error { return ErrClosing }\n\t\tm.AcquireFn = func() wire { return &mockWire{ReceiveFn: m.ReceiveFn, ErrorFn: m.ErrorFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.Receive(context.Background(), c.B().Subscribe().Channel(\"Do\").Build(), nil)\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive NoRetry - ctx done\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing)\n\t\tm.AcquireFn = func() wire { return &mockWire{ReceiveFn: m.ReceiveFn} }\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\treturn cc.Receive(ctx, c.B().Subscribe().Channel(\"Do\").Build(), nil)\n\t\t}); ret != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected response %v\", ret)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive NoRetry - not retryable\", func(t *testing.T) {\n\t\tc, m := setup()\n\t\tm.ReceiveFn = makeReceiveFn(ErrClosing, nil)\n\t\tm.AcquireFn = func() wire { return &mockWire{ReceiveFn: m.ReceiveFn} }\n\t\tif ret := c.Dedicated(func(cc DedicatedClient) error {\n\t\t\tif cli, ok := cc.(*dedicatedClusterClient); ok {\n\t\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cli, ok := cc.(*dedicatedSingleClient); ok {\n\t\t\t\tcli.retryHandler = &mockRetryHandler{\n\t\t\t\t\tWaitOrSkipRetryFunc: func(ctx context.Context, attempts int, _ Completed, err error) bool {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := cc.Receive(context.Background(), c.B().Subscribe().Channel(\"Do\").Build(), nil); !errors.Is(err, ErrClosing) {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t\treturn errors.New(\"done\")\n\t\t}); ret.Error() != \"done\" {\n\t\t\tt.Fatalf(\"Dedicated not executed\")\n\t\t}\n\t})\n}\n\nfunc TestSingleClientLoadingRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tsetup := func() (*singleClient, *mockConn) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn client, m\n\t}\n\n\tt.Run(\"Do Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"test\").Build()).ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif attempts != 2 {\n\t\t\tt.Fatalf(\"expected 2 attempts, got %v\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"Do not retry on non-loading errors\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ERR some other error\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tif err := client.Do(context.Background(), client.B().Get().Key(\"test\").Build()).Error(); err == nil {\n\t\t\tt.Fatal(\"expected error but got nil\")\n\t\t}\n\t\tif attempts != 1 {\n\t\t\tt.Fatalf(\"unexpected attempts %v, expected no retry\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Build()\n\t\tresps := client.DoMulti(context.Background(), cmd)\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoCache Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoCacheFn = func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), cmd, time.Minute).ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(cmd, time.Minute))\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Do Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn} }\n\n\t\terr := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"test\").Build()).ToString(); err != nil || v != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated DoMulti Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn} }\n\n\t\terr := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tresps := c.DoMulti(context.Background(), c.B().Get().Key(\"test\").Build())\n\t\t\tif len(resps) != 1 {\n\t\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t\t}\n\t\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n}\n\nfunc BenchmarkSingleClient_DoCache(b *testing.B) {\n\tctx := context.Background()\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}, Dialer: net.Dialer{KeepAlive: -1}})\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tkeys := make([]string, 10000)\n\tfor i := 0; i < 10000; i++ {\n\t\tkeys[i] = strconv.Itoa(i)\n\t}\n\tmset := client.B().Mset().KeyValue()\n\tfor _, v := range keys {\n\t\tmset = mset.KeyValue(v, v)\n\t}\n\tif err := client.Do(ctx, mset.Build()).Error(); err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.Run(\"NoCache\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tif err := client.Do(ctx, client.B().Mget().Key(keys...).Build()).Error(); err != nil {\n\t\t\t\t\tb.Errorf(\"unexpected %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tb.StopTimer()\n\t})\n\tb.Run(\"DoCache\", func(b *testing.B) {\n\t\tb.ResetTimer()\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tif err := client.DoCache(ctx, client.B().Mget().Key(keys...).Cache(), time.Minute).Error(); err != nil {\n\t\t\t\t\tb.Errorf(\"unexpected %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tb.StopTimer()\n\t})\n\tclient.Close()\n}\n"
        },
        {
          "name": "cluster.go",
          "type": "blob",
          "size": 34.9580078125,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\n// ErrNoSlot indicates that there is no redis node owns the key slot.\nvar ErrNoSlot = errors.New(\"the slot has no redis node\")\nvar ErrReplicaOnlyConflict = errors.New(\"ReplicaOnly conflicts with SendToReplicas option\")\nvar ErrInvalidShardsRefreshInterval = errors.New(\"ShardsRefreshInterval must be greater than or equal to 0\")\nvar ErrReplicaOnlyConflictWithReplicaSelector = errors.New(\"ReplicaOnly conflicts with ReplicaSelector option\")\nvar ErrSendToReplicasNotSet = errors.New(\"SendToReplicas must be set when ReplicaSelector is set\")\n\ntype clusterClient struct {\n\tpslots       [16384]conn\n\trslots       []conn\n\tsc           call\n\trOpt         *ClientOption\n\tconns        map[string]connrole\n\tconnFn       connFn\n\topt          *ClientOption\n\tretryHandler retryHandler\n\tstopCh       chan struct{}\n\tcmd          Builder\n\tmu           sync.RWMutex\n\tstop         uint32\n\tretry        bool\n}\n\n// NOTE: connrole and conn must be initialized at the same time\ntype connrole struct {\n\tconn   conn\n\thidden bool\n\t//replica bool <- this field is removed because a server may have mixed roles at the same time in the future. https://github.com/valkey-io/valkey/issues/1372\n}\n\nvar replicaOnlySelector = func(_ uint16, replicas []ReplicaInfo) int {\n\treturn util.FastRand(len(replicas))\n}\n\nfunc newClusterClient(opt *ClientOption, connFn connFn, retryer retryHandler) (*clusterClient, error) {\n\tclient := &clusterClient{\n\t\tcmd:          cmds.NewBuilder(cmds.InitSlot),\n\t\tconnFn:       connFn,\n\t\topt:          opt,\n\t\tconns:        make(map[string]connrole),\n\t\tretry:        !opt.DisableRetry,\n\t\tretryHandler: retryer,\n\t\tstopCh:       make(chan struct{}),\n\t}\n\n\tif opt.ReplicaOnly && opt.SendToReplicas != nil {\n\t\treturn nil, ErrReplicaOnlyConflict\n\t}\n\tif opt.ReplicaOnly && opt.ReplicaSelector != nil {\n\t\treturn nil, ErrReplicaOnlyConflictWithReplicaSelector\n\t}\n\tif opt.ReplicaSelector != nil && opt.SendToReplicas == nil {\n\t\treturn nil, ErrSendToReplicasNotSet\n\t}\n\n\tif opt.SendToReplicas != nil && opt.ReplicaSelector == nil {\n\t\topt.ReplicaSelector = replicaOnlySelector\n\t}\n\n\tif opt.SendToReplicas != nil {\n\t\trOpt := *opt\n\t\trOpt.ReplicaOnly = true\n\t\tclient.rOpt = &rOpt\n\t}\n\n\tclient.connFn = func(dst string, opt *ClientOption) conn {\n\t\tcc := connFn(dst, opt)\n\t\tcc.SetOnCloseHook(func(err error) {\n\t\t\tclient.lazyRefresh()\n\t\t})\n\t\treturn cc\n\t}\n\n\tif err := client.init(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := client.refresh(context.Background()); err != nil {\n\t\treturn client, err\n\t}\n\n\tif opt.ClusterOption.ShardsRefreshInterval > 0 {\n\t\tgo client.runClusterTopologyRefreshment()\n\t} else if opt.ClusterOption.ShardsRefreshInterval < 0 {\n\t\treturn nil, ErrInvalidShardsRefreshInterval\n\t}\n\n\treturn client, nil\n}\n\nfunc (c *clusterClient) init() error {\n\tif len(c.opt.InitAddress) == 0 {\n\t\treturn ErrNoAddr\n\t}\n\tresults := make(chan error, len(c.opt.InitAddress))\n\tfor _, addr := range c.opt.InitAddress {\n\t\tcc := c.connFn(addr, c.opt)\n\t\tgo func(addr string, cc conn) {\n\t\t\tif err := cc.Dial(); err == nil {\n\t\t\t\tc.mu.Lock()\n\t\t\t\tif _, ok := c.conns[addr]; ok {\n\t\t\t\t\tgo cc.Close() // abort the new connection instead of closing the old one which may already been used\n\t\t\t\t} else {\n\t\t\t\t\tc.conns[addr] = connrole{\n\t\t\t\t\t\tconn: cc,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.mu.Unlock()\n\t\t\t\tresults <- nil\n\t\t\t} else {\n\t\t\t\tresults <- err\n\t\t\t}\n\t\t}(addr, cc)\n\t}\n\tes := make([]error, cap(results))\n\tfor i := 0; i < cap(results); i++ {\n\t\tif err := <-results; err == nil {\n\t\t\treturn nil\n\t\t} else {\n\t\t\tes[i] = err\n\t\t}\n\t}\n\treturn es[0]\n}\n\nfunc (c *clusterClient) refresh(ctx context.Context) (err error) {\n\treturn c.sc.Do(ctx, c._refresh)\n}\n\nfunc (c *clusterClient) lazyRefresh() {\n\tc.sc.LazyDo(time.Second, c._refresh)\n}\n\ntype clusterslots struct {\n\taddr  string\n\treply RedisResult\n\tver   int\n}\n\nfunc (s clusterslots) parse(tls bool) map[string]group {\n\tif s.ver < 8 {\n\t\treturn parseSlots(s.reply.val, s.addr)\n\t}\n\treturn parseShards(s.reply.val, s.addr, tls)\n}\n\nfunc getClusterSlots(c conn, timeout time.Duration) clusterslots {\n\tvar ctx context.Context\n\tvar cancel context.CancelFunc\n\tif timeout > 0 {\n\t\tctx, cancel = context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t} else {\n\t\tctx = context.Background()\n\t}\n\tv := c.Version()\n\tif v < 8 {\n\t\treturn clusterslots{reply: c.Do(ctx, cmds.SlotCmd), addr: c.Addr(), ver: v}\n\t}\n\treturn clusterslots{reply: c.Do(ctx, cmds.ShardsCmd), addr: c.Addr(), ver: v}\n}\n\nfunc (c *clusterClient) _refresh() (err error) {\n\tc.mu.RLock()\n\tresults := make(chan clusterslots, len(c.conns))\n\tpending := make([]conn, 0, len(c.conns))\n\tfor _, cc := range c.conns {\n\t\tpending = append(pending, cc.conn)\n\t}\n\tc.mu.RUnlock()\n\n\tvar result clusterslots\n\tfor i := 0; i < cap(results); i++ {\n\t\tif i&3 == 0 { // batch CLUSTER SLOTS/CLUSTER SHARDS for every 4 connections\n\t\t\tfor j := i; j < i+4 && j < len(pending); j++ {\n\t\t\t\tgo func(c conn, timeout time.Duration) {\n\t\t\t\t\tresults <- getClusterSlots(c, timeout)\n\t\t\t\t}(pending[j], c.opt.ConnWriteTimeout)\n\t\t\t}\n\t\t}\n\t\tresult = <-results\n\t\terr = result.reply.Error()\n\t\tif len(result.reply.val.values) != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tpending = nil\n\n\tgroups := result.parse(c.opt.TLSConfig != nil)\n\tconns := make(map[string]connrole, len(groups))\n\tfor master, g := range groups {\n\t\tconns[master] = connrole{conn: c.connFn(master, c.opt)}\n\t\tif c.rOpt != nil {\n\t\t\tfor _, nodeInfo := range g.nodes[1:] {\n\t\t\t\tconns[nodeInfo.Addr] = connrole{conn: c.connFn(nodeInfo.Addr, c.rOpt)}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, nodeInfo := range g.nodes[1:] {\n\t\t\t\tconns[nodeInfo.Addr] = connrole{conn: c.connFn(nodeInfo.Addr, c.opt)}\n\t\t\t}\n\t\t}\n\t}\n\t// make sure InitAddress always be present\n\tfor _, addr := range c.opt.InitAddress {\n\t\tif _, ok := conns[addr]; !ok {\n\t\t\tconns[addr] = connrole{\n\t\t\t\tconn:   c.connFn(addr, c.opt),\n\t\t\t\thidden: true,\n\t\t\t}\n\t\t}\n\t}\n\n\tvar removes []conn\n\n\tc.mu.RLock()\n\tfor addr, cc := range c.conns {\n\t\tif fresh, ok := conns[addr]; ok {\n\t\t\tfresh.conn = cc.conn\n\t\t\tconns[addr] = fresh\n\t\t} else {\n\t\t\tremoves = append(removes, cc.conn)\n\t\t}\n\t}\n\tc.mu.RUnlock()\n\n\tpslots := [16384]conn{}\n\tvar rslots []conn\n\tfor master, g := range groups {\n\t\tswitch {\n\t\tcase c.opt.ReplicaOnly && len(g.nodes) > 1:\n\t\t\tnodesCount := len(g.nodes)\n\t\t\tfor _, slot := range g.slots {\n\t\t\t\tfor i := slot[0]; i <= slot[1] && i >= 0 && i < 16384; i++ {\n\t\t\t\t\tpslots[i] = conns[g.nodes[1+util.FastRand(nodesCount-1)].Addr].conn\n\t\t\t\t}\n\t\t\t}\n\t\tcase c.rOpt != nil:\n\t\t\tif len(rslots) == 0 { // lazy init\n\t\t\t\trslots = make([]conn, 16384)\n\t\t\t}\n\t\t\tif len(g.nodes) > 1 {\n\t\t\t\tn := len(g.nodes) - 1\n\t\t\t\tfor _, slot := range g.slots {\n\t\t\t\t\tfor i := slot[0]; i <= slot[1] && i >= 0 && i < 16384; i++ {\n\t\t\t\t\t\tpslots[i] = conns[master].conn\n\t\t\t\t\t\trIndex := c.opt.ReplicaSelector(uint16(i), g.nodes[1:])\n\t\t\t\t\t\tif rIndex >= 0 && rIndex < n {\n\t\t\t\t\t\t\trslots[i] = conns[g.nodes[1+rIndex].Addr].conn\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trslots[i] = conns[master].conn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor _, slot := range g.slots {\n\t\t\t\t\tfor i := slot[0]; i <= slot[1] && i >= 0 && i < 16384; i++ {\n\t\t\t\t\t\tpslots[i] = conns[master].conn\n\t\t\t\t\t\trslots[i] = conns[master].conn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tfor _, slot := range g.slots {\n\t\t\t\tfor i := slot[0]; i <= slot[1] && i >= 0 && i < 16384; i++ {\n\t\t\t\t\tpslots[i] = conns[master].conn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tc.mu.Lock()\n\tc.pslots = pslots\n\tc.rslots = rslots\n\tc.conns = conns\n\tc.mu.Unlock()\n\n\tif len(removes) > 0 {\n\t\tgo func(removes []conn) {\n\t\t\ttime.Sleep(time.Second * 5)\n\t\t\tfor _, cc := range removes {\n\t\t\t\tcc.Close()\n\t\t\t}\n\t\t}(removes)\n\t}\n\n\treturn nil\n}\n\nfunc (c *clusterClient) single() (conn conn) {\n\treturn c._pick(cmds.InitSlot, false)\n}\n\nfunc (c *clusterClient) nodes() []string {\n\tc.mu.RLock()\n\tnodes := make([]string, 0, len(c.conns))\n\tfor addr := range c.conns {\n\t\tnodes = append(nodes, addr)\n\t}\n\tc.mu.RUnlock()\n\treturn nodes\n}\n\ntype nodes []ReplicaInfo\n\ntype group struct {\n\tnodes nodes\n\tslots [][2]int64\n}\n\nfunc parseEndpoint(fallback, endpoint string, port int64) string {\n\tswitch endpoint {\n\tcase \"\":\n\t\tendpoint, _, _ = net.SplitHostPort(fallback)\n\tcase \"?\":\n\t\treturn \"\"\n\t}\n\treturn net.JoinHostPort(endpoint, strconv.FormatInt(port, 10))\n}\n\n// parseSlots - map redis slots for each redis nodes/addresses\n// defaultAddr is needed in case the node does not know its own IP\nfunc parseSlots(slots RedisMessage, defaultAddr string) map[string]group {\n\tgroups := make(map[string]group, len(slots.values))\n\tfor _, v := range slots.values {\n\t\tmaster := parseEndpoint(defaultAddr, v.values[2].values[0].string, v.values[2].values[1].integer)\n\t\tif master == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tg, ok := groups[master]\n\t\tif !ok {\n\t\t\tg.slots = make([][2]int64, 0)\n\t\t\tg.nodes = make(nodes, 0, len(v.values)-2)\n\t\t\tfor i := 2; i < len(v.values); i++ {\n\t\t\t\tif dst := parseEndpoint(defaultAddr, v.values[i].values[0].string, v.values[i].values[1].integer); dst != \"\" {\n\t\t\t\t\tg.nodes = append(g.nodes, ReplicaInfo{Addr: dst})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg.slots = append(g.slots, [2]int64{v.values[0].integer, v.values[1].integer})\n\t\tgroups[master] = g\n\t}\n\treturn groups\n}\n\n// parseShards - map redis shards for each redis nodes/addresses\n// defaultAddr is needed in case the node does not know its own IP\nfunc parseShards(shards RedisMessage, defaultAddr string, tls bool) map[string]group {\n\tgroups := make(map[string]group, len(shards.values))\n\tfor _, v := range shards.values {\n\t\tm := -1\n\t\tshard, _ := v.AsMap()\n\t\tslots := shard[\"slots\"].values\n\t\t_nodes := shard[\"nodes\"].values\n\t\tg := group{\n\t\t\tnodes: make(nodes, 0, len(_nodes)),\n\t\t\tslots: make([][2]int64, len(slots)/2),\n\t\t}\n\t\tfor i := range g.slots {\n\t\t\tg.slots[i][0], _ = slots[i*2].AsInt64()\n\t\t\tg.slots[i][1], _ = slots[i*2+1].AsInt64()\n\t\t}\n\t\tfor _, n := range _nodes {\n\t\t\tdict, _ := n.AsMap()\n\t\t\tif dict[\"health\"].string != \"online\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tport := dict[\"port\"].integer\n\t\t\tif tls && dict[\"tls-port\"].integer > 0 {\n\t\t\t\tport = dict[\"tls-port\"].integer\n\t\t\t}\n\t\t\tif dst := parseEndpoint(defaultAddr, dict[\"endpoint\"].string, port); dst != \"\" {\n\t\t\t\tif dict[\"role\"].string == \"master\" {\n\t\t\t\t\tm = len(g.nodes)\n\t\t\t\t}\n\t\t\t\tg.nodes = append(g.nodes, ReplicaInfo{Addr: dst})\n\t\t\t}\n\t\t}\n\t\tif m >= 0 {\n\t\t\tg.nodes[0], g.nodes[m] = g.nodes[m], g.nodes[0]\n\t\t\tgroups[g.nodes[0].Addr] = g\n\t\t}\n\t}\n\treturn groups\n}\n\nfunc (c *clusterClient) runClusterTopologyRefreshment() {\n\tticker := time.NewTicker(c.opt.ClusterOption.ShardsRefreshInterval)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-c.stopCh:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t\tc.lazyRefresh()\n\t\t}\n\t}\n}\n\nfunc (c *clusterClient) _pick(slot uint16, toReplica bool) (p conn) {\n\tc.mu.RLock()\n\tif slot == cmds.InitSlot {\n\t\tfor _, cc := range c.conns {\n\t\t\tp = cc.conn\n\t\t\tbreak\n\t\t}\n\t} else if toReplica && c.rslots != nil {\n\t\tp = c.rslots[slot]\n\t} else {\n\t\tp = c.pslots[slot]\n\t}\n\tc.mu.RUnlock()\n\treturn p\n}\n\nfunc (c *clusterClient) pick(ctx context.Context, slot uint16, toReplica bool) (p conn, err error) {\n\tif p = c._pick(slot, toReplica); p == nil {\n\t\tif err := c.refresh(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p = c._pick(slot, toReplica); p == nil {\n\t\t\treturn nil, ErrNoSlot\n\t\t}\n\t}\n\treturn p, nil\n}\n\nfunc (c *clusterClient) redirectOrNew(addr string, prev conn, slot uint16, mode RedirectMode) conn {\n\tc.mu.RLock()\n\tcc := c.conns[addr]\n\tc.mu.RUnlock()\n\tif cc.conn != nil && prev != cc.conn {\n\t\treturn cc.conn\n\t}\n\tc.mu.Lock()\n\tif cc = c.conns[addr]; cc.conn == nil {\n\t\tp := c.connFn(addr, c.opt)\n\t\tcc = connrole{conn: p}\n\t\tc.conns[addr] = cc\n\t\tif mode == RedirectMove {\n\t\t\tc.pslots[slot] = p\n\t\t}\n\t} else if prev == cc.conn {\n\t\t// try reconnection if the MOVED redirects to the same host,\n\t\t// because the same hostname may actually be resolved into another destination\n\t\t// depending on the fail-over implementation. ex: AWS MemoryDB's resize process.\n\t\tgo func(prev conn) {\n\t\t\ttime.Sleep(time.Second * 5)\n\t\t\tprev.Close()\n\t\t}(prev)\n\t\tp := c.connFn(addr, c.opt)\n\t\tcc = connrole{conn: p}\n\t\tc.conns[addr] = cc\n\t\tif mode == RedirectMove { // MOVED should always point to the primary.\n\t\t\tc.pslots[slot] = p\n\t\t}\n\t}\n\tc.mu.Unlock()\n\treturn cc.conn\n}\n\nfunc (c *clusterClient) B() Builder {\n\treturn c.cmd\n}\n\nfunc (c *clusterClient) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tif resp = c.do(ctx, cmd); resp.NonRedisError() == nil { // not recycle cmds if error, since cmds may be used later in pipe. consider recycle them by pipe\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *clusterClient) do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tcc, err := c.pick(ctx, cmd.Slot(), c.toReplica(cmd))\n\tif err != nil {\n\t\treturn newErrResult(err)\n\t}\n\tresp = cc.Do(ctx, cmd)\nprocess:\n\tswitch addr, mode := c.shouldRefreshRetry(resp.Error(), ctx); mode {\n\tcase RedirectMove:\n\t\tresp = c.redirectOrNew(addr, cc, cmd.Slot(), mode).Do(ctx, cmd)\n\t\tgoto process\n\tcase RedirectAsk:\n\t\tresults := c.redirectOrNew(addr, cc, cmd.Slot(), mode).DoMulti(ctx, cmds.AskingCmd, cmd)\n\t\tresp = results.s[1]\n\t\tresultsp.Put(results)\n\t\tgoto process\n\tcase RedirectRetry:\n\t\tif c.retry && cmd.IsReadOnly() {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, cmd, resp.Error())\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t}\n\treturn resp\n}\n\nfunc (c *clusterClient) toReplica(cmd Completed) bool {\n\tif c.opt.SendToReplicas != nil {\n\t\treturn c.opt.SendToReplicas(cmd)\n\t}\n\treturn false\n}\n\nfunc (c *clusterClient) _pickMulti(multi []Completed) (retries *connretry, init bool) {\n\tlast := cmds.InitSlot\n\n\tfor _, cmd := range multi {\n\t\tif cmd.Slot() == cmds.InitSlot {\n\t\t\tinit = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tcount := conncountp.Get(len(c.conns), len(c.conns))\n\n\tif !init && c.rslots != nil && c.opt.SendToReplicas != nil {\n\t\tfor _, cmd := range multi {\n\t\t\tvar cc conn\n\t\t\tif c.opt.SendToReplicas(cmd) {\n\t\t\t\tcc = c.rslots[cmd.Slot()]\n\t\t\t} else {\n\t\t\t\tcc = c.pslots[cmd.Slot()]\n\t\t\t}\n\t\t\tif cc == nil {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\tcount.m[cc]++\n\t\t}\n\n\t\tretries = connretryp.Get(len(count.m), len(count.m))\n\t\tfor cc, n := range count.m {\n\t\t\tretries.m[cc] = retryp.Get(0, n)\n\t\t}\n\t\tconncountp.Put(count)\n\n\t\tfor i, cmd := range multi {\n\t\t\tvar cc conn\n\t\t\tif c.opt.SendToReplicas(cmd) {\n\t\t\t\tcc = c.rslots[cmd.Slot()]\n\t\t\t} else {\n\t\t\t\tcc = c.pslots[cmd.Slot()]\n\t\t\t}\n\t\t\tif cc == nil { // check cc == nil again in case of non-deterministic SendToReplicas.\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\tre := retries.m[cc]\n\t\t\tre.commands = append(re.commands, cmd)\n\t\t\tre.cIndexes = append(re.cIndexes, i)\n\t\t}\n\t\treturn retries, init\n\t}\n\n\tinits := 0\n\tfor _, cmd := range multi {\n\t\tif cmd.Slot() == cmds.InitSlot {\n\t\t\tinits++\n\t\t\tcontinue\n\t\t}\n\t\tif last == cmds.InitSlot {\n\t\t\tlast = cmd.Slot()\n\t\t} else if init && last != cmd.Slot() {\n\t\t\tpanic(panicMixCxSlot)\n\t\t}\n\t\tcc := c.pslots[cmd.Slot()]\n\t\tif cc == nil {\n\t\t\treturn nil, false\n\t\t}\n\t\tcount.m[cc]++\n\t}\n\n\tif last == cmds.InitSlot {\n\t\t// if all commands have no slots, such as INFO, we pick a non-nil slot.\n\t\tfor i, cc := range c.pslots {\n\t\t\tif cc != nil {\n\t\t\t\tlast = uint16(i)\n\t\t\t\tcount.m[cc] = inits\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif last == cmds.InitSlot {\n\t\t\treturn nil, false\n\t\t}\n\t} else if init {\n\t\tcc := c.pslots[last]\n\t\tcount.m[cc] += inits\n\t}\n\n\tretries = connretryp.Get(len(count.m), len(count.m))\n\tfor cc, n := range count.m {\n\t\tretries.m[cc] = retryp.Get(0, n)\n\t}\n\tconncountp.Put(count)\n\n\tfor i, cmd := range multi {\n\t\tvar cc conn\n\t\tif cmd.Slot() != cmds.InitSlot {\n\t\t\tcc = c.pslots[cmd.Slot()]\n\t\t} else {\n\t\t\tcc = c.pslots[last]\n\t\t}\n\t\tre := retries.m[cc]\n\t\tre.commands = append(re.commands, cmd)\n\t\tre.cIndexes = append(re.cIndexes, i)\n\t}\n\treturn retries, init\n}\n\nfunc (c *clusterClient) pickMulti(ctx context.Context, multi []Completed) (*connretry, bool, error) {\n\tconns, hasInit := c._pickMulti(multi)\n\tif conns == nil {\n\t\tif err := c.refresh(ctx); err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\tif conns, hasInit = c._pickMulti(multi); conns == nil {\n\t\t\treturn nil, false, ErrNoSlot\n\t\t}\n\t}\n\treturn conns, hasInit, nil\n}\n\nfunc isMulti(cmd Completed) bool {\n\treturn len(cmd.Commands()) == 1 && cmd.Commands()[0] == \"MULTI\"\n}\nfunc isExec(cmd Completed) bool {\n\treturn len(cmd.Commands()) == 1 && cmd.Commands()[0] == \"EXEC\"\n}\n\nfunc (c *clusterClient) doresultfn(\n\tctx context.Context, results *redisresults, retries *connretry, mu *sync.Mutex, cc conn, cIndexes []int, commands []Completed, resps []RedisResult, attempts int, hasInit bool,\n) (clean bool) {\n\tmi := -1\n\tei := -1\n\tclean = true\n\tfor i, resp := range resps {\n\t\tclean = clean && resp.NonRedisError() == nil\n\t\tii := cIndexes[i]\n\t\tcm := commands[i]\n\t\tresults.s[ii] = resp\n\t\taddr, mode := c.shouldRefreshRetry(resp.Error(), ctx)\n\t\tif mode != RedirectNone {\n\t\t\tnc := cc\n\t\t\tretryDelay := time.Duration(-1)\n\t\t\tif mode == RedirectRetry {\n\t\t\t\tif !c.retry || !cm.IsReadOnly() {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tretryDelay = c.retryHandler.RetryDelay(attempts, cm, resp.Error())\n\t\t\t} else {\n\t\t\t\tnc = c.redirectOrNew(addr, cc, cm.Slot(), mode)\n\t\t\t}\n\t\t\tif hasInit && ei < i { // find out if there is a transaction block or not.\n\t\t\t\tfor mi = i; mi >= 0 && !isMulti(commands[mi]) && !isExec(commands[mi]); mi-- {\n\t\t\t\t}\n\t\t\t\tfor ei = i; ei < len(commands) && !isMulti(commands[ei]) && !isExec(commands[ei]); ei++ {\n\t\t\t\t}\n\t\t\t\tif mi >= 0 && ei < len(commands) && isMulti(commands[mi]) && isExec(commands[ei]) && resps[mi].val.string == ok { // a transaction is found.\n\t\t\t\t\tmu.Lock()\n\t\t\t\t\tretries.Redirects++\n\t\t\t\t\tnr := retries.m[nc]\n\t\t\t\t\tif nr == nil {\n\t\t\t\t\t\tnr = retryp.Get(0, len(commands))\n\t\t\t\t\t\tretries.m[nc] = nr\n\t\t\t\t\t}\n\t\t\t\t\tfor i := mi; i <= ei; i++ {\n\t\t\t\t\t\tii := cIndexes[i]\n\t\t\t\t\t\tcm := commands[i]\n\t\t\t\t\t\tif mode == RedirectAsk {\n\t\t\t\t\t\t\tnr.aIndexes = append(nr.aIndexes, ii)\n\t\t\t\t\t\t\tnr.cAskings = append(nr.cAskings, cm)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnr.cIndexes = append(nr.cIndexes, ii)\n\t\t\t\t\t\t\tnr.commands = append(nr.commands, cm)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmu.Unlock()\n\t\t\t\t\tcontinue // the transaction has been added to the retries, go to the next cmd.\n\t\t\t\t}\n\t\t\t}\n\t\t\tif hasInit && mi < i && i < ei && mi >= 0 && isMulti(commands[mi]) {\n\t\t\t\tcontinue // the current cmd is in the processed transaction and has been added to the retries.\n\t\t\t}\n\t\t\tmu.Lock()\n\t\t\tif mode != RedirectRetry {\n\t\t\t\tretries.Redirects++\n\t\t\t}\n\t\t\tif mode == RedirectRetry && retryDelay >= 0 {\n\t\t\t\tretries.RetryDelay = max(retries.RetryDelay, retryDelay)\n\t\t\t}\n\t\t\tnr := retries.m[nc]\n\t\t\tif nr == nil {\n\t\t\t\tnr = retryp.Get(0, len(commands))\n\t\t\t\tretries.m[nc] = nr\n\t\t\t}\n\t\t\tif mode == RedirectAsk {\n\t\t\t\tnr.aIndexes = append(nr.aIndexes, ii)\n\t\t\t\tnr.cAskings = append(nr.cAskings, cm)\n\t\t\t} else {\n\t\t\t\tnr.cIndexes = append(nr.cIndexes, ii)\n\t\t\t\tnr.commands = append(nr.commands, cm)\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\t}\n\t}\n\treturn clean\n}\n\nfunc (c *clusterClient) doretry(\n\tctx context.Context, cc conn, results *redisresults, retries *connretry, re *retry, mu *sync.Mutex, wg *sync.WaitGroup, attempts int, hasInit bool,\n) {\n\tclean := true\n\tif len(re.commands) != 0 {\n\t\tresps := cc.DoMulti(ctx, re.commands...)\n\t\tclean = c.doresultfn(ctx, results, retries, mu, cc, re.cIndexes, re.commands, resps.s, attempts, hasInit)\n\t\tresultsp.Put(resps)\n\t}\n\tif len(re.cAskings) != 0 {\n\t\tresps := askingMulti(cc, ctx, re.cAskings)\n\t\tclean = c.doresultfn(ctx, results, retries, mu, cc, re.aIndexes, re.cAskings, resps.s, attempts, hasInit) && clean\n\t\tresultsp.Put(resps)\n\t}\n\tif clean {\n\t\tretryp.Put(re)\n\t}\n\twg.Done()\n}\n\nfunc (c *clusterClient) DoMulti(ctx context.Context, multi ...Completed) []RedisResult {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\n\tretries, hasInit, err := c.pickMulti(ctx, multi)\n\tif err != nil {\n\t\treturn fillErrs(len(multi), err)\n\t}\n\tdefer connretryp.Put(retries)\n\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\n\tresults := resultsp.Get(len(multi), len(multi))\n\n\tattempts := 1\n\nretry:\n\tretries.RetryDelay = -1 // Assume no retry. Because client retry flag can be set to false.\n\n\tvar cc1 conn\n\tvar re1 *retry\n\twg.Add(len(retries.m))\n\tmu.Lock()\n\tfor cc, re := range retries.m {\n\t\tdelete(retries.m, cc)\n\t\tcc1 = cc\n\t\tre1 = re\n\t\tbreak\n\t}\n\tfor cc, re := range retries.m {\n\t\tdelete(retries.m, cc)\n\t\tgo c.doretry(ctx, cc, results, retries, re, &mu, &wg, attempts, hasInit)\n\t}\n\tmu.Unlock()\n\tc.doretry(ctx, cc1, results, retries, re1, &mu, &wg, attempts, hasInit)\n\twg.Wait()\n\n\tif len(retries.m) != 0 {\n\t\tif retries.Redirects > 0 {\n\t\t\tretries.Redirects = 0\n\t\t\tgoto retry\n\t\t}\n\t\tif retries.RetryDelay >= 0 {\n\t\t\tc.retryHandler.WaitForRetry(ctx, retries.RetryDelay)\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\n\n\tfor i, cmd := range multi {\n\t\tif results.s[i].NonRedisError() == nil {\n\t\t\tcmds.PutCompleted(cmd)\n\t\t}\n\t}\n\treturn results.s\n}\n\nfunc fillErrs(n int, err error) (results []RedisResult) {\n\tresults = resultsp.Get(n, n).s\n\tfor i := range results {\n\t\tresults[i] = newErrResult(err)\n\t}\n\treturn results\n}\n\nfunc (c *clusterClient) doCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult) {\n\tattempts := 1\n\nretry:\n\tcc, err := c.pick(ctx, cmd.Slot(), c.toReplica(Completed(cmd)))\n\tif err != nil {\n\t\treturn newErrResult(err)\n\t}\n\tresp = cc.DoCache(ctx, cmd, ttl)\nprocess:\n\tswitch addr, mode := c.shouldRefreshRetry(resp.Error(), ctx); mode {\n\tcase RedirectMove:\n\t\tresp = c.redirectOrNew(addr, cc, cmd.Slot(), mode).DoCache(ctx, cmd, ttl)\n\t\tgoto process\n\tcase RedirectAsk:\n\t\tresults := askingMultiCache(c.redirectOrNew(addr, cc, cmd.Slot(), mode), ctx, []CacheableTTL{CT(cmd, ttl)})\n\t\tresp = results.s[0]\n\t\tresultsp.Put(results)\n\t\tgoto process\n\tcase RedirectRetry:\n\t\tif c.retry {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, Completed(cmd), resp.Error())\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t}\n\treturn resp\n}\n\nfunc (c *clusterClient) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult) {\n\tresp = c.doCache(ctx, cmd, ttl)\n\tif err := resp.NonRedisError(); err == nil || err == ErrDoCacheAborted {\n\t\tcmds.PutCacheable(cmd)\n\t}\n\treturn resp\n}\n\nfunc askingMulti(cc conn, ctx context.Context, multi []Completed) *redisresults {\n\tvar inTx bool\n\tcommands := make([]Completed, 0, len(multi)*2)\n\tfor _, cmd := range multi {\n\t\tif inTx {\n\t\t\tcommands = append(commands, cmd)\n\t\t\tinTx = !isExec(cmd)\n\t\t} else {\n\t\t\tcommands = append(commands, cmds.AskingCmd, cmd)\n\t\t\tinTx = isMulti(cmd)\n\t\t}\n\t}\n\tresults := resultsp.Get(0, len(multi))\n\tresps := cc.DoMulti(ctx, commands...)\n\tfor i, resp := range resps.s {\n\t\tif commands[i] != cmds.AskingCmd {\n\t\t\tresults.s = append(results.s, resp)\n\t\t}\n\t}\n\tresultsp.Put(resps)\n\treturn results\n}\n\nfunc askingMultiCache(cc conn, ctx context.Context, multi []CacheableTTL) *redisresults {\n\tcommands := make([]Completed, 0, len(multi)*6)\n\tfor _, cmd := range multi {\n\t\tck, _ := cmds.CacheKey(cmd.Cmd)\n\t\tcommands = append(commands, cmds.OptInCmd, cmds.AskingCmd, cmds.MultiCmd, cmds.NewCompleted([]string{\"PTTL\", ck}), Completed(cmd.Cmd), cmds.ExecCmd)\n\t}\n\tresults := resultsp.Get(0, len(multi))\n\tresps := cc.DoMulti(ctx, commands...)\n\tfor i := 5; i < len(resps.s); i += 6 {\n\t\tif arr, err := resps.s[i].ToArray(); err != nil {\n\t\t\tif preErr := resps.s[i-1].Error(); preErr != nil { // if {Cmd} get a RedisError\n\t\t\t\terr = preErr\n\t\t\t}\n\t\t\tresults.s = append(results.s, newErrResult(err))\n\t\t} else {\n\t\t\tresults.s = append(results.s, newResult(arr[len(arr)-1], nil))\n\t\t}\n\t}\n\tresultsp.Put(resps)\n\treturn results\n}\n\nfunc (c *clusterClient) _pickMultiCache(multi []CacheableTTL) *connretrycache {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tcount := conncountp.Get(len(c.conns), len(c.conns))\n\tif c.opt.SendToReplicas == nil || c.rslots == nil {\n\t\tfor _, cmd := range multi {\n\t\t\tp := c.pslots[cmd.Cmd.Slot()]\n\t\t\tif p == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tcount.m[p]++\n\t\t}\n\n\t\tretries := connretrycachep.Get(len(count.m), len(count.m))\n\t\tfor cc, n := range count.m {\n\t\t\tretries.m[cc] = retrycachep.Get(0, n)\n\t\t}\n\t\tconncountp.Put(count)\n\n\t\tfor i, cmd := range multi {\n\t\t\tcc := c.pslots[cmd.Cmd.Slot()]\n\t\t\tre := retries.m[cc]\n\t\t\tre.commands = append(re.commands, cmd)\n\t\t\tre.cIndexes = append(re.cIndexes, i)\n\t\t}\n\n\t\treturn retries\n\t} else {\n\t\tfor _, cmd := range multi {\n\t\t\tvar p conn\n\t\t\tif c.opt.SendToReplicas(Completed(cmd.Cmd)) {\n\t\t\t\tp = c.rslots[cmd.Cmd.Slot()]\n\t\t\t} else {\n\t\t\t\tp = c.pslots[cmd.Cmd.Slot()]\n\t\t\t}\n\t\t\tif p == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tcount.m[p]++\n\t\t}\n\n\t\tretries := connretrycachep.Get(len(count.m), len(count.m))\n\t\tfor cc, n := range count.m {\n\t\t\tretries.m[cc] = retrycachep.Get(0, n)\n\t\t}\n\t\tconncountp.Put(count)\n\n\t\tfor i, cmd := range multi {\n\t\t\tvar cc conn\n\t\t\tif c.opt.SendToReplicas(Completed(cmd.Cmd)) {\n\t\t\t\tcc = c.rslots[cmd.Cmd.Slot()]\n\t\t\t} else {\n\t\t\t\tcc = c.pslots[cmd.Cmd.Slot()]\n\t\t\t}\n\t\t\tre := retries.m[cc]\n\t\t\tre.commands = append(re.commands, cmd)\n\t\t\tre.cIndexes = append(re.cIndexes, i)\n\t\t}\n\n\t\treturn retries\n\t}\n}\n\nfunc (c *clusterClient) pickMultiCache(ctx context.Context, multi []CacheableTTL) (*connretrycache, error) {\n\tconns := c._pickMultiCache(multi)\n\tif conns == nil {\n\t\tif err := c.refresh(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif conns = c._pickMultiCache(multi); conns == nil {\n\t\t\treturn nil, ErrNoSlot\n\t\t}\n\t}\n\treturn conns, nil\n}\n\nfunc (c *clusterClient) resultcachefn(\n\tctx context.Context, results *redisresults, retries *connretrycache, mu *sync.Mutex, cc conn, cIndexes []int, commands []CacheableTTL, resps []RedisResult, attempts int,\n) (clean bool) {\n\tclean = true\n\tfor i, resp := range resps {\n\t\tclean = clean && resp.NonRedisError() == nil\n\t\tii := cIndexes[i]\n\t\tcm := commands[i]\n\t\tresults.s[ii] = resp\n\t\taddr, mode := c.shouldRefreshRetry(resp.Error(), ctx)\n\t\tif mode != RedirectNone {\n\t\t\tnc := cc\n\t\t\tretryDelay := time.Duration(-1)\n\t\t\tif mode == RedirectRetry {\n\t\t\t\tif !c.retry {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tretryDelay = c.retryHandler.RetryDelay(attempts, Completed(cm.Cmd), resp.Error())\n\t\t\t} else {\n\t\t\t\tnc = c.redirectOrNew(addr, cc, cm.Cmd.Slot(), mode)\n\t\t\t}\n\t\t\tmu.Lock()\n\t\t\tif mode != RedirectRetry {\n\t\t\t\tretries.Redirects++\n\t\t\t}\n\t\t\tif mode == RedirectRetry && retryDelay >= 0 {\n\t\t\t\tretries.RetryDelay = max(retries.RetryDelay, retryDelay)\n\t\t\t}\n\t\t\tnr := retries.m[nc]\n\t\t\tif nr == nil {\n\t\t\t\tnr = retrycachep.Get(0, len(commands))\n\t\t\t\tretries.m[nc] = nr\n\t\t\t}\n\t\t\tif mode == RedirectAsk {\n\t\t\t\tnr.aIndexes = append(nr.aIndexes, ii)\n\t\t\t\tnr.cAskings = append(nr.cAskings, cm)\n\t\t\t} else {\n\t\t\t\tnr.cIndexes = append(nr.cIndexes, ii)\n\t\t\t\tnr.commands = append(nr.commands, cm)\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\t}\n\t}\n\treturn clean\n}\n\nfunc (c *clusterClient) doretrycache(\n\tctx context.Context, cc conn, results *redisresults, retries *connretrycache, re *retrycache, mu *sync.Mutex, wg *sync.WaitGroup, attempts int,\n) {\n\tclean := true\n\tif len(re.commands) != 0 {\n\t\tresps := cc.DoMultiCache(ctx, re.commands...)\n\t\tclean = c.resultcachefn(ctx, results, retries, mu, cc, re.cIndexes, re.commands, resps.s, attempts)\n\t\tresultsp.Put(resps)\n\t}\n\tif len(re.cAskings) != 0 {\n\t\tresps := askingMultiCache(cc, ctx, re.cAskings)\n\t\tclean = c.resultcachefn(ctx, results, retries, mu, cc, re.aIndexes, re.cAskings, resps.s, attempts) && clean\n\t\tresultsp.Put(resps)\n\t}\n\tif clean {\n\t\tretrycachep.Put(re)\n\t}\n\twg.Done()\n}\n\nfunc (c *clusterClient) DoMultiCache(ctx context.Context, multi ...CacheableTTL) []RedisResult {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\n\tretries, err := c.pickMultiCache(ctx, multi)\n\tif err != nil {\n\t\treturn fillErrs(len(multi), err)\n\t}\n\tdefer connretrycachep.Put(retries)\n\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\n\tresults := resultsp.Get(len(multi), len(multi))\n\n\tattempts := 1\n\nretry:\n\tretries.RetryDelay = -1 // Assume no retry. Because client retry flag can be set to false.\n\n\tvar cc1 conn\n\tvar re1 *retrycache\n\twg.Add(len(retries.m))\n\tmu.Lock()\n\tfor cc, re := range retries.m {\n\t\tdelete(retries.m, cc)\n\t\tcc1 = cc\n\t\tre1 = re\n\t\tbreak\n\t}\n\tfor cc, re := range retries.m {\n\t\tdelete(retries.m, cc)\n\t\tgo c.doretrycache(ctx, cc, results, retries, re, &mu, &wg, attempts)\n\t}\n\tmu.Unlock()\n\tc.doretrycache(ctx, cc1, results, retries, re1, &mu, &wg, attempts)\n\twg.Wait()\n\n\tif len(retries.m) != 0 {\n\t\tif retries.Redirects > 0 {\n\t\t\tretries.Redirects = 0\n\t\t\tgoto retry\n\t\t}\n\t\tif retries.RetryDelay >= 0 {\n\t\t\tc.retryHandler.WaitForRetry(ctx, retries.RetryDelay)\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\n\n\tfor i, cmd := range multi {\n\t\tif err := results.s[i].NonRedisError(); err == nil || err == ErrDoCacheAborted {\n\t\t\tcmds.PutCacheable(cmd.Cmd)\n\t\t}\n\t}\n\treturn results.s\n}\n\nfunc (c *clusterClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) {\n\tattempts := 1\nretry:\n\tcc, err := c.pick(ctx, subscribe.Slot(), c.toReplica(subscribe))\n\tif err != nil {\n\t\tgoto ret\n\t}\n\terr = cc.Receive(ctx, subscribe, fn)\n\tif _, mode := c.shouldRefreshRetry(err, ctx); c.retry && mode != RedirectNone {\n\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, subscribe, err)\n\t\tif shouldRetry {\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\nret:\n\tif err == nil {\n\t\tcmds.PutCompleted(subscribe)\n\t}\n\treturn err\n}\n\nfunc (c *clusterClient) DoStream(ctx context.Context, cmd Completed) RedisResultStream {\n\tcc, err := c.pick(ctx, cmd.Slot(), c.toReplica(cmd))\n\tif err != nil {\n\t\treturn RedisResultStream{e: err}\n\t}\n\tret := cc.DoStream(ctx, cmd)\n\tcmds.PutCompleted(cmd)\n\treturn ret\n}\n\nfunc (c *clusterClient) DoMultiStream(ctx context.Context, multi ...Completed) MultiRedisResultStream {\n\tif len(multi) == 0 {\n\t\treturn RedisResultStream{e: io.EOF}\n\t}\n\tslot := multi[0].Slot()\n\trepl := c.toReplica(multi[0])\n\tfor i := 1; i < len(multi); i++ {\n\t\tif s := multi[i].Slot(); s != cmds.InitSlot {\n\t\t\tif slot == cmds.InitSlot {\n\t\t\t\tslot = s\n\t\t\t} else if slot != s {\n\t\t\t\tpanic(\"DoMultiStream across multiple slots is not supported\")\n\t\t\t}\n\t\t}\n\t\trepl = repl && c.toReplica(multi[i])\n\t}\n\tcc, err := c.pick(ctx, slot, repl)\n\tif err != nil {\n\t\treturn RedisResultStream{e: err}\n\t}\n\tret := cc.DoMultiStream(ctx, multi...)\n\tfor _, cmd := range multi {\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn ret\n}\n\nfunc (c *clusterClient) Dedicated(fn func(DedicatedClient) error) (err error) {\n\tdcc := &dedicatedClusterClient{cmd: c.cmd, client: c, slot: cmds.NoSlot, retry: c.retry, retryHandler: c.retryHandler}\n\terr = fn(dcc)\n\tdcc.release()\n\treturn err\n}\n\nfunc (c *clusterClient) Dedicate() (DedicatedClient, func()) {\n\tdcc := &dedicatedClusterClient{cmd: c.cmd, client: c, slot: cmds.NoSlot, retry: c.retry, retryHandler: c.retryHandler}\n\treturn dcc, dcc.release\n}\n\nfunc (c *clusterClient) Nodes() map[string]Client {\n\tc.mu.RLock()\n\t_nodes := make(map[string]Client, len(c.conns))\n\tdisableCache := c.opt != nil && c.opt.DisableCache\n\tfor addr, cc := range c.conns {\n\t\tif !cc.hidden {\n\t\t\t_nodes[addr] = newSingleClientWithConn(cc.conn, c.cmd, c.retry, disableCache, c.retryHandler)\n\t\t}\n\t}\n\tc.mu.RUnlock()\n\treturn _nodes\n}\n\nfunc (c *clusterClient) Close() {\n\tif atomic.CompareAndSwapUint32(&c.stop, 0, 1) {\n\t\tclose(c.stopCh)\n\t}\n\n\tc.mu.RLock()\n\tfor _, cc := range c.conns {\n\t\tgo cc.conn.Close()\n\t}\n\tc.mu.RUnlock()\n}\n\nfunc (c *clusterClient) shouldRefreshRetry(err error, ctx context.Context) (addr string, mode RedirectMode) {\n\tif err != nil && err != Nil && err != ErrDoCacheAborted && atomic.LoadUint32(&c.stop) == 0 {\n\t\tif err, ok := err.(*RedisError); ok {\n\t\t\tif addr, ok = err.IsMoved(); ok {\n\t\t\t\tmode = RedirectMove\n\t\t\t} else if addr, ok = err.IsAsk(); ok {\n\t\t\t\tmode = RedirectAsk\n\t\t\t} else if err.IsClusterDown() || err.IsTryAgain() || err.IsLoading() {\n\t\t\t\tmode = RedirectRetry\n\t\t\t}\n\t\t} else if ctx.Err() == nil {\n\t\t\tmode = RedirectRetry\n\t\t}\n\t\tif mode != RedirectNone {\n\t\t\tc.lazyRefresh()\n\t\t}\n\t}\n\treturn\n}\n\ntype dedicatedClusterClient struct {\n\tclient       *clusterClient\n\tconn         conn\n\twire         wire\n\tpshks        *pshks\n\tmu           sync.Mutex\n\tcmd          Builder\n\tretryHandler retryHandler\n\tretry        bool\n\tslot         uint16\n\tmark         bool\n}\n\nfunc (c *dedicatedClusterClient) acquire(ctx context.Context, slot uint16) (wire wire, err error) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.mark {\n\t\treturn nil, ErrDedicatedClientRecycled\n\t}\n\tif c.slot == cmds.NoSlot {\n\t\tc.slot = slot\n\t} else if c.slot != slot && slot != cmds.InitSlot {\n\t\tpanic(panicMsgCxSlot)\n\t}\n\tif c.wire != nil {\n\t\treturn c.wire, nil\n\t}\n\tif c.conn, err = c.client.pick(ctx, c.slot, false); err != nil {\n\t\tif p := c.pshks; p != nil {\n\t\t\tc.pshks = nil\n\t\t\tp.close <- err\n\t\t\tclose(p.close)\n\t\t}\n\t\treturn nil, err\n\t}\n\tc.wire = c.conn.Acquire()\n\tif p := c.pshks; p != nil {\n\t\tc.pshks = nil\n\t\tch := c.wire.SetPubSubHooks(p.hooks)\n\t\tgo func(ch <-chan error) {\n\t\t\tfor e := range ch {\n\t\t\t\tp.close <- e\n\t\t\t}\n\t\t\tclose(p.close)\n\t\t}(ch)\n\t}\n\treturn c.wire, nil\n}\n\nfunc (c *dedicatedClusterClient) release() {\n\tc.mu.Lock()\n\tif !c.mark {\n\t\tif p := c.pshks; p != nil {\n\t\t\tc.pshks = nil\n\t\t\tclose(p.close)\n\t\t}\n\t\tif c.wire != nil {\n\t\t\tc.conn.Store(c.wire)\n\t\t}\n\t}\n\tc.mark = true\n\tc.mu.Unlock()\n}\n\nfunc (c *dedicatedClusterClient) B() Builder {\n\treturn c.cmd\n}\n\nfunc (c *dedicatedClusterClient) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tif w, err := c.acquire(ctx, cmd.Slot()); err != nil {\n\t\tresp = newErrResult(err)\n\t} else {\n\t\tresp = w.Do(ctx, cmd)\n\t\tswitch _, mode := c.client.shouldRefreshRetry(resp.Error(), ctx); mode {\n\t\tcase RedirectRetry:\n\t\t\tif c.retry && cmd.IsReadOnly() && w.Error() == nil {\n\t\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\t\tctx, attempts, cmd, resp.Error(),\n\t\t\t\t)\n\t\t\t\tif shouldRetry {\n\t\t\t\t\tattempts++\n\t\t\t\t\tgoto retry\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif resp.NonRedisError() == nil {\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *dedicatedClusterClient) DoMulti(ctx context.Context, multi ...Completed) (resp []RedisResult) {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\tslot := chooseSlot(multi)\n\tif slot == cmds.NoSlot {\n\t\tpanic(panicMsgCxSlot)\n\t}\n\tretryable := c.retry\n\tif retryable {\n\t\tretryable = allReadOnly(multi)\n\t}\n\tattempts := 1\nretry:\n\tif w, err := c.acquire(ctx, slot); err == nil {\n\t\tresp = w.DoMulti(ctx, multi...).s\n\t\tfor i, r := range resp {\n\t\t\t_, mode := c.client.shouldRefreshRetry(r.Error(), ctx)\n\t\t\tif mode == RedirectRetry && retryable && w.Error() == nil {\n\t\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\t\tctx, attempts, multi[i], r.Error(),\n\t\t\t\t)\n\t\t\t\tif shouldRetry {\n\t\t\t\t\tattempts++\n\t\t\t\t\tgoto retry\n\t\t\t\t}\n\t\t\t}\n\t\t\tif mode != RedirectNone {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresp = resultsp.Get(len(multi), len(multi)).s\n\t\tfor i := range resp {\n\t\t\tresp[i] = newErrResult(err)\n\t\t}\n\t}\n\tfor i, cmd := range multi {\n\t\tif resp[i].NonRedisError() == nil {\n\t\t\tcmds.PutCompleted(cmd)\n\t\t}\n\t}\n\treturn resp\n}\n\nfunc (c *dedicatedClusterClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) {\n\tvar (\n\t\tw        wire\n\t\tattempts = 1\n\t)\nretry:\n\tif w, err = c.acquire(ctx, subscribe.Slot()); err == nil {\n\t\terr = w.Receive(ctx, subscribe, fn)\n\t\tif _, mode := c.client.shouldRefreshRetry(err, ctx); c.retry && mode == RedirectRetry && w.Error() == nil {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, subscribe, err)\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil {\n\t\tcmds.PutCompleted(subscribe)\n\t}\n\treturn err\n}\n\nfunc (c *dedicatedClusterClient) SetPubSubHooks(hooks PubSubHooks) <-chan error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.mark {\n\t\tch := make(chan error, 1)\n\t\tch <- ErrDedicatedClientRecycled\n\t\treturn ch\n\t}\n\tif p := c.pshks; p != nil {\n\t\tc.pshks = nil\n\t\tclose(p.close)\n\t}\n\tif c.wire != nil {\n\t\treturn c.wire.SetPubSubHooks(hooks)\n\t}\n\tif hooks.isZero() {\n\t\treturn nil\n\t}\n\tch := make(chan error, 1)\n\tc.pshks = &pshks{hooks: hooks, close: ch}\n\treturn ch\n}\n\nfunc (c *dedicatedClusterClient) Close() {\n\tc.mu.Lock()\n\tif p := c.pshks; p != nil {\n\t\tc.pshks = nil\n\t\tp.close <- ErrClosing\n\t\tclose(p.close)\n\t}\n\tif c.wire != nil {\n\t\tc.wire.Close()\n\t}\n\tc.mu.Unlock()\n\tc.release()\n}\n\ntype RedirectMode int\n\nconst (\n\tRedirectNone RedirectMode = iota\n\tRedirectMove\n\tRedirectAsk\n\tRedirectRetry\n\n\tpanicMsgCxSlot = \"cross slot command in Dedicated is prohibited\"\n\tpanicMixCxSlot = \"Mixing no-slot and cross slot commands in DoMulti is prohibited\"\n)\n"
        },
        {
          "name": "cluster_test.go",
          "type": "blob",
          "size": 235.7041015625,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar slotsResp = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 16383},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.0.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica\n\t\t\t{typ: '+', string: \"127.0.1.1\"},\n\t\t\t{typ: ':', integer: 1},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar slotsMultiResp = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 8192},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.0.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica\n\t\t\t{typ: '+', string: \"127.0.1.1\"},\n\t\t\t{typ: ':', integer: 1},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 8193},\n\t\t{typ: ':', integer: 16383},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.2.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica\n\t\t\t{typ: '+', string: \"127.0.3.1\"},\n\t\t\t{typ: ':', integer: 1},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar slotsMultiRespWithoutReplicas = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 8192},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.0.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 8193},\n\t\t{typ: ':', integer: 16383},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.1.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar slotsMultiRespWithMultiReplicas = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 8192},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.0.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica1\n\t\t\t{typ: '+', string: \"127.0.0.2\"},\n\t\t\t{typ: ':', integer: 1},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica2\n\t\t\t{typ: '+', string: \"127.0.0.3\"},\n\t\t\t{typ: ':', integer: 2},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica3\n\t\t\t{typ: '+', string: \"127.0.0.4\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 8193},\n\t\t{typ: ':', integer: 16383},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.1.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica1\n\t\t\t{typ: '+', string: \"127.0.1.2\"},\n\t\t\t{typ: ':', integer: 1},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica2\n\t\t\t{typ: '+', string: \"127.0.1.3\"},\n\t\t\t{typ: ':', integer: 2},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica3\n\t\t\t{typ: '+', string: \"127.0.1.4\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar singleSlotResp = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 0},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.0.1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar singleSlotResp2 = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 0},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"127.0.3.1\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar singleSlotWithoutIP = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 0},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"\"},\n\t\t\t{typ: ':', integer: 4},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t\t{typ: '*', values: []RedisMessage{ // replica\n\t\t\t{typ: '+', string: \"?\"},\n\t\t\t{typ: ':', integer: 1},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n\t{typ: '*', values: []RedisMessage{\n\t\t{typ: ':', integer: 0},\n\t\t{typ: ':', integer: 0},\n\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t{typ: '+', string: \"?\"},\n\t\t\t{typ: ':', integer: 4},\n\t\t\t{typ: '+', string: \"\"},\n\t\t}},\n\t}},\n}}, nil)\n\nvar shardsResp = newResult(RedisMessage{typ: typeArray, values: []RedisMessage{\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t\t{typ: typeBlobString, string: \"16383\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // failed master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"fail\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // replica\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 1},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"replica\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n}}, nil)\n\nvar shardsRespTls = newResult(RedisMessage{typ: typeArray, values: []RedisMessage{\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t\t{typ: typeBlobString, string: \"16383\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // replica, tls\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"tls-port\"},\n\t\t\t\t{typ: typeInteger, integer: 2},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.2.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.2.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"replica\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // failed master, tls + port\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"tls-port\"},\n\t\t\t\t{typ: typeInteger, integer: 1},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"fail\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master, tls + port\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"tls-port\"},\n\t\t\t\t{typ: typeInteger, integer: 1},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // replica, port\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 3},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"replica\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n}}, nil)\n\nvar shardsMultiResp = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t\t{typ: typeBlobString, string: \"8192\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // failed master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"fail\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.0.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // replica\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 1},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.1.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"replica\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"8193\"},\n\t\t\t{typ: typeBlobString, string: \"16383\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // failed master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.2.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.2.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"fail\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 0},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.2.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.2.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // replica\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 1},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"replica\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n}}, nil)\n\nvar singleShardResp2 = newResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // failed master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 3},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.99\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"fail\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 3},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"127.0.3.1\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n}}, nil)\n\nvar singleShardWithoutIP = newResult(RedisMessage{typ: typeArray, values: []RedisMessage{\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // failed master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 4},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"fail\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 4},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t\t{typ: typeMap, values: []RedisMessage{ // replica\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 1},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"?\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"?\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"replica\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n\t{typ: typeMap, values: []RedisMessage{\n\t\t{typ: typeBlobString, string: \"slots\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t\t{typ: typeBlobString, string: \"0\"},\n\t\t}},\n\t\t{typ: typeBlobString, string: \"nodes\"},\n\t\t{typ: typeArray, values: []RedisMessage{\n\t\t\t{typ: typeMap, values: []RedisMessage{ // master\n\t\t\t\t{typ: typeBlobString, string: \"id\"},\n\t\t\t\t{typ: typeBlobString, string: \"\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"port\"},\n\t\t\t\t{typ: typeInteger, integer: 4},\n\n\t\t\t\t{typ: typeBlobString, string: \"ip\"},\n\t\t\t\t{typ: typeBlobString, string: \"?\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"endpoint\"},\n\t\t\t\t{typ: typeBlobString, string: \"?\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"role\"},\n\t\t\t\t{typ: typeBlobString, string: \"master\"},\n\n\t\t\t\t{typ: typeBlobString, string: \"replication-offset\"},\n\t\t\t\t{typ: typeInteger, integer: 72156},\n\n\t\t\t\t{typ: typeBlobString, string: \"health\"},\n\t\t\t\t{typ: typeBlobString, string: \"online\"},\n\t\t\t}},\n\t\t}},\n\t}},\n}}, nil)\n\n//gocyclo:ignore\nfunc TestClusterClientInit(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"Init no nodes\", func(t *testing.T) {\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return nil },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != ErrNoAddr {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Init no dialable\", func(t *testing.T) {\n\t\tv := errors.New(\"dial err\")\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DialFn: func() error { return v }}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh err\", func(t *testing.T) {\n\t\tv := errors.New(\"refresh err\")\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult { return newErrResult(v) }}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh skip zero slots\", func(t *testing.T) {\n\t\tvar first int64\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\", \"127.0.1.1:1\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif atomic.AddInt64(&first, 1) == 1 {\n\t\t\t\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{}}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn slotsResp\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != nil || atomic.AddInt64(&first, 1) < 2 {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh skip zero shards\", func(t *testing.T) {\n\t\tvar first int64\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\", \"127.0.1.1:1\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif atomic.AddInt64(&first, 1) == 1 {\n\t\t\t\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{}}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn shardsResp\n\t\t\t\t\t},\n\t\t\t\t\tVersionFn: func() int { return 8 },\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != nil || atomic.AddInt64(&first, 1) < 2 {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh no slots cluster\", func(t *testing.T) {\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{}}, nil)\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh no shards cluster\", func(t *testing.T) {\n\t\tif _, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{}}, nil)\n\t\t\t\t\t},\n\t\t\t\t\tVersionFn: func() int { return 8 },\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh cluster of 1 node without knowing its own ip\", func(t *testing.T) {\n\t\tgetClient := func(version int) (client *clusterClient, err error) {\n\t\t\treturn newClusterClient(\n\t\t\t\t&ClientOption{InitAddress: []string{\"127.0.4.1:4\"}},\n\t\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\t\t\treturn singleSlotWithoutIP\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn singleShardWithoutIP\n\t\t\t\t\t\t},\n\t\t\t\t\t\tAddrFn:    func() string { return \"127.0.4.1:4\" },\n\t\t\t\t\t\tVersionFn: func() int { return version },\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t\t)\n\t\t}\n\n\t\tt.Run(\"slots\", func(t *testing.T) {\n\t\t\tclient, err := getClient(6)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\tnodes := client.nodes()\n\t\t\tsort.Strings(nodes)\n\t\t\tif len(nodes) != 1 ||\n\t\t\t\tnodes[0] != \"127.0.4.1:4\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"shards\", func(t *testing.T) {\n\t\t\tclient, err := getClient(8)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\tnodes := client.nodes()\n\t\t\tsort.Strings(nodes)\n\t\t\tif len(nodes) != 1 ||\n\t\t\t\tnodes[0] != \"127.0.4.1:4\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Refresh replace\", func(t *testing.T) {\n\t\ttestFunc := func(t *testing.T, client *clusterClient, num *int64) {\n\t\t\tnodes := client.nodes()\n\t\t\tsort.Strings(nodes)\n\t\t\tif len(nodes) != 3 ||\n\t\t\t\tnodes[0] != \"127.0.0.1:0\" ||\n\t\t\t\tnodes[1] != \"127.0.1.1:1\" ||\n\t\t\t\tnodes[2] != \"127.0.2.1:2\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t\t}\n\n\t\t\tatomic.AddInt64(num, 1)\n\n\t\t\tif err := client.refresh(context.Background()); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\n\t\t\tnodes = client.nodes()\n\t\t\tsort.Strings(nodes)\n\t\t\tif len(nodes) != 3 ||\n\t\t\t\tnodes[0] != \"127.0.1.1:1\" ||\n\t\t\t\tnodes[1] != \"127.0.2.1:2\" ||\n\t\t\t\tnodes[2] != \"127.0.3.1:3\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t\t}\n\t\t}\n\n\t\tt.Run(\"slots\", func(t *testing.T) {\n\t\t\tvar first int64\n\t\t\tclient, err := newClusterClient(\n\t\t\t\t&ClientOption{InitAddress: []string{\"127.0.1.1:1\", \"127.0.2.1:2\"}},\n\t\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\tif atomic.LoadInt64(&first) == 1 {\n\t\t\t\t\t\t\t\treturn singleSlotResp2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn slotsResp\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\ttestFunc(t, client, &first)\n\t\t})\n\n\t\tt.Run(\"shards\", func(t *testing.T) {\n\t\t\tvar first int64\n\t\t\tclient, err := newClusterClient(\n\t\t\t\t&ClientOption{InitAddress: []string{\"127.0.1.1:1\", \"127.0.2.1:2\"}},\n\t\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\tif atomic.LoadInt64(&first) == 1 {\n\t\t\t\t\t\t\t\treturn singleShardResp2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn shardsResp\n\t\t\t\t\t\t},\n\t\t\t\t\t\tVersionFn: func() int { return 8 },\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\ttestFunc(t, client, &first)\n\t\t})\n\t})\n\n\tt.Run(\"Refresh InitAddress which is not in CLUSTER SLOTS / CLUSTER SHARDS should be hidden\", func(t *testing.T) {\n\t\ttestFunc := func(t *testing.T, client *clusterClient, num *int64) {\n\t\t\tnodesWithHidden := client.nodes()\n\t\t\tsort.Strings(nodesWithHidden)\n\t\t\tif len(nodesWithHidden) != 4 ||\n\t\t\t\tnodesWithHidden[0] != \"127.0.0.1:0\" ||\n\t\t\t\tnodesWithHidden[1] != \"127.0.1.1:1\" ||\n\t\t\t\tnodesWithHidden[2] != \"127.0.2.1:2\" ||\n\t\t\t\tnodesWithHidden[3] != \"redis.example.com\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodesWithHidden)\n\t\t\t}\n\n\t\t\tnodes := client.Nodes()\n\t\t\t_, ok := nodes[\"127.0.0.1:0\"]\n\t\t\t_, ok2 := nodes[\"127.0.1.1:1\"]\n\t\t\tif len(nodes) != 2 || !ok || !ok2 {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t\t}\n\n\t\t\tatomic.AddInt64(num, 1)\n\n\t\t\tif err := client.refresh(context.Background()); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\n\t\t\tnodesWithHidden = client.nodes()\n\t\t\tsort.Strings(nodesWithHidden)\n\t\t\tif len(nodesWithHidden) != 4 ||\n\t\t\t\tnodesWithHidden[0] != \"127.0.1.1:1\" ||\n\t\t\t\tnodesWithHidden[1] != \"127.0.2.1:2\" ||\n\t\t\t\tnodesWithHidden[2] != \"127.0.3.1:3\" ||\n\t\t\t\tnodesWithHidden[3] != \"redis.example.com\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodesWithHidden)\n\t\t\t}\n\n\t\t\tnodes = client.Nodes()\n\t\t\t_, ok = nodes[\"127.0.3.1:3\"]\n\t\t\tif len(nodes) != 1 || !ok {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t\t}\n\t\t}\n\n\t\tt.Run(\"slots\", func(t *testing.T) {\n\t\t\tvar first int64\n\t\t\tclient, err := newClusterClient(\n\t\t\t\t&ClientOption{InitAddress: []string{\"127.0.1.1:1\", \"127.0.2.1:2\", \"redis.example.com\"}},\n\t\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\tif atomic.LoadInt64(&first) == 1 {\n\t\t\t\t\t\t\t\treturn singleSlotResp2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn slotsResp\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\ttestFunc(t, client, &first)\n\t\t})\n\n\t\tt.Run(\"shards\", func(t *testing.T) {\n\t\t\tvar first int64\n\t\t\tclient, err := newClusterClient(\n\t\t\t\t&ClientOption{InitAddress: []string{\"127.0.1.1:1\", \"127.0.2.1:2\", \"redis.example.com\"}},\n\t\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\tif atomic.LoadInt64(&first) == 1 {\n\t\t\t\t\t\t\t\treturn singleShardResp2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn shardsResp\n\t\t\t\t\t\t},\n\t\t\t\t\t\tVersionFn: func() int { return 8 },\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\ttestFunc(t, client, &first)\n\t\t})\n\t})\n\n\tt.Run(\"Shards tls\", func(t *testing.T) {\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\"}, TLSConfig: &tls.Config{}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn shardsRespTls\n\t\t\t\t\t},\n\t\t\t\t\tVersionFn: func() int { return 8 },\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tnodes := client.nodes()\n\t\tsort.Strings(nodes)\n\t\tif len(nodes) != 4 ||\n\t\t\tnodes[0] != \"127.0.0.1:0\" ||\n\t\t\tnodes[1] != \"127.0.1.1:1\" ||\n\t\t\tnodes[2] != \"127.0.2.1:2\" ||\n\t\t\tnodes[3] != \"127.0.3.1:3\" {\n\t\t\tt.Fatalf(\"unexpected nodes %v\", nodes)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh cluster which has only primary node per shard with SendToReplica option\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiRespWithoutReplicas\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tcopiedM := *m\n\t\t\t\treturn &copiedM\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif client.pslots[0] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 0\")\n\t\t}\n\t\tif client.pslots[8192] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 16383\")\n\t\t}\n\t\tif client.rslots[0] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 0\")\n\t\t}\n\t\tif client.rslots[8192] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8192\")\n\t\t}\n\t\tif client.rslots[8193] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8193\")\n\t\t}\n\t\tif client.rslots[16383] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 16383\")\n\t\t}\n\t})\n\n\tt.Run(\"Refresh cluster which has multi nodes per shard with SendToReplica option\", func(t *testing.T) {\n\t\tprimaryNodeConn := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \"127.0.0.1:0\" || dst == \"127.0.2.1:0\" {\n\t\t\t\t\tif opt.ReplicaOnly {\n\t\t\t\t\t\tt.Fatalf(\"unexpected replicaOnly option in primary node\")\n\t\t\t\t\t}\n\t\t\t\t\treturn primaryNodeConn\n\t\t\t\t} else {\n\t\t\t\t\tif !opt.ReplicaOnly {\n\t\t\t\t\t\tt.Fatalf(\"unexpected replicaOnly option in replica node\")\n\t\t\t\t\t}\n\t\t\t\t\treturn replicaNodeConn\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif client.pslots[0] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 0\")\n\t\t}\n\t\tif client.pslots[8192] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != client.conns[\"127.0.2.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != client.conns[\"127.0.2.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 16383\")\n\t\t}\n\t\tif client.rslots[0] != client.conns[\"127.0.1.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 0\")\n\t\t}\n\t\tif client.rslots[8192] != client.conns[\"127.0.1.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8192\")\n\t\t}\n\t\tif client.rslots[8193] != client.conns[\"127.0.3.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8193\")\n\t\t}\n\t\tif client.rslots[16383] != client.conns[\"127.0.3.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 16383\")\n\t\t}\n\t})\n\n\tt.Run(\"Negative ShardRefreshInterval\", func(t *testing.T) {\n\t\t_, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tClusterOption: ClusterOption{\n\t\t\t\t\tShardsRefreshInterval: -1 * time.Millisecond,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif !errors.Is(err, ErrInvalidShardsRefreshInterval) {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh cluster which has only primary node per shard with ReplicaSelector option\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiRespWithoutReplicas\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\t\treturn 0\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tcopiedM := *m\n\t\t\t\treturn &copiedM\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif client.pslots[0] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 0\")\n\t\t}\n\t\tif client.pslots[8192] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 16383\")\n\t\t}\n\t\tif client.rslots[0] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 0\")\n\t\t}\n\t\tif client.rslots[8192] != client.conns[\"127.0.0.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8192\")\n\t\t}\n\t\tif client.rslots[8193] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8193\")\n\t\t}\n\t\tif client.rslots[16383] != client.conns[\"127.0.1.1:0\"].conn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 16383\")\n\t\t}\n\t})\n\n\tt.Run(\"Refresh cluster which has multi replicas per shard with ReplicaSelector option. Returned index is within range\", func(t *testing.T) {\n\t\tprimaryNodeConn := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiRespWithMultiReplicas\n\t\t\t\t}\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn2 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn3 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\t\treturn 1\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tswitch {\n\t\t\t\tcase dst == \"127.0.0.2:1\" || dst == \"127.0.1.2:1\":\n\t\t\t\t\treturn replicaNodeConn1\n\t\t\t\tcase dst == \"127.0.0.3:2\" || dst == \"127.0.1.3:2\":\n\t\t\t\t\treturn replicaNodeConn2\n\t\t\t\tcase dst == \"127.0.0.4:3\" || dst == \"127.0.1.4:3\":\n\t\t\t\t\treturn replicaNodeConn3\n\t\t\t\tdefault:\n\t\t\t\t\treturn primaryNodeConn\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif client.pslots[0] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 0\")\n\t\t}\n\t\tif client.pslots[8192] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 16383\")\n\t\t}\n\t\tif client.rslots[0] != replicaNodeConn2 {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 0\")\n\t\t}\n\t\tif client.rslots[8192] != replicaNodeConn2 {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8192\")\n\t\t}\n\t\tif client.rslots[8193] != replicaNodeConn2 {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8193\")\n\t\t}\n\t\tif client.rslots[16383] != replicaNodeConn2 {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 16383\")\n\t\t}\n\t})\n\n\tt.Run(\"Refresh cluster which has multi replicas per shard with ReplicaSelector option. Returned index is out of range\", func(t *testing.T) {\n\t\tprimaryNodeConn := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiRespWithMultiReplicas\n\t\t\t\t}\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn2 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treplicaNodeConn3 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{\n\t\t\t\t\terr: errors.New(\"unexpected call\"),\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\t\treturn -1\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tswitch {\n\t\t\t\tcase dst == \"127.0.0.2:1\" || dst == \"127.0.1.2:1\":\n\t\t\t\t\treturn replicaNodeConn1\n\t\t\t\tcase dst == \"127.0.0.3:2\" || dst == \"127.0.1.3:2\":\n\t\t\t\t\treturn replicaNodeConn2\n\t\t\t\tcase dst == \"127.0.0.4:3\" || dst == \"127.0.1.4:3\":\n\t\t\t\t\treturn replicaNodeConn3\n\t\t\t\tdefault:\n\t\t\t\t\treturn primaryNodeConn\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif client.pslots[0] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 0\")\n\t\t}\n\t\tif client.pslots[8192] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to pslot 16383\")\n\t\t}\n\t\tif client.rslots[0] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 0\")\n\t\t}\n\t\tif client.rslots[8192] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8192\")\n\t\t}\n\t\tif client.rslots[8193] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 8193\")\n\t\t}\n\t\tif client.rslots[16383] != primaryNodeConn {\n\t\t\tt.Fatalf(\"unexpected node assigned to rslot 16383\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tm := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\treturn slotsMultiResp\n\t\t\t}\n\t\t\treturn RedisResult{}\n\t\t},\n\t\tDoStreamFn: func(cmd Completed) RedisResultStream {\n\t\t\treturn RedisResultStream{e: errors.New(cmd.Commands()[1])}\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoMultiStreamFn: func(cmd ...Completed) MultiRedisResultStream {\n\t\t\treturn MultiRedisResultStream{e: errors.New(cmd[0].Commands()[1])}\n\t\t},\n\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"GET Do\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Info\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoCacheOverride: map[string]func(cmd Cacheable, ttl time.Duration) RedisResult{\n\t\t\t\"GET DoCache\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"DoCache\"}, nil)\n\t\t\t},\n\t\t},\n\t}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\"}},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\treturn m\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Nodes\", func(t *testing.T) {\n\t\tnodes := client.Nodes()\n\t\tif len(nodes) != 4 || nodes[\"127.0.0.1:0\"] == nil || nodes[\"127.0.1.1:1\"] == nil ||\n\t\t\tnodes[\"127.0.2.1:0\"] == nil || nodes[\"127.0.3.1:1\"] == nil {\n\t\t\tt.Fatalf(\"unexpected Nodes\")\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do with no slot\", func(t *testing.T) {\n\t\tc := client.B().Info().Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"Info\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoStream\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif s := client.DoStream(context.Background(), c); s.Error().Error() != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti Empty\", func(t *testing.T) {\n\t\tif resps := client.DoMulti(context.Background()); resps != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", resps)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiStream Empty\", func(t *testing.T) {\n\t\tif s := client.DoMultiStream(context.Background()); s.Error() != io.EOF {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiStream Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tif s := client.DoMultiStream(context.Background(), c1, c2); s.Error().Error() != \"K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti Single Slot + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Info().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"INFO\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiStream Single Slot + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Info().Section(\"ANY\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tif s := client.DoMultiStream(context.Background(), c1, c2); s.Error().Error() != \"ANY\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMixCxSlot {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMulti(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"Delegate DoMultiStream Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); !strings.Contains(err.(string), \"across multiple slots\") {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMultiStream(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"Delegate DoMulti Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache Empty\", func(t *testing.T) {\n\t\tif resps := client.DoMultiCache(context.Background()); resps != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", resps)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Cache()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(c1, time.Second), CT(c2, time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]CacheableTTL, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = CT(client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Cache(), time.Second)\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tm.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tm.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Close\", func(t *testing.T) {\n\t\tonce := sync.Once{}\n\t\tcalled := make(chan struct{})\n\t\tm.CloseFn = func() {\n\t\t\tonce.Do(func() { close(called) })\n\t\t}\n\t\tclient.Close()\n\t\t<-called\n\t\tselect {\n\t\tcase _, ok := <-client.stopCh:\n\t\t\tif ok {\n\t\t\t\tt.Fatalf(\"stopCh should be closed\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Err, but no retry\", func(t *testing.T) {\n\t\tv := errors.New(\"fn err\")\n\t\tif err := client.Dedicated(func(client DedicatedClient) error {\n\t\t\treturn v\n\t\t}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tm.AcquireFn = func() wire { return &mockWire{} }\n\t\tclient.Dedicated(func(c DedicatedClient) error {\n\t\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"b\").Build()).Error()\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err Multi\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn &mockWire{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tclient.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Multi Cross Slot Err\", func(t *testing.T) {\n\t\tm.AcquireFn = func() wire { return &mockWire{} }\n\t\terr := client.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tdefer func() {\n\t\t\t\terr = errors.New(recover().(string))\n\t\t\t}()\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil || err.Error() != panicMsgCxSlot {\n\t\t\tt.Errorf(\"Multi should panic if cross slots is used\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Delegate Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Delegate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tm.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)[3].val.values {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-ch; err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Delegate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tm.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Info().Build(),\n\t\t\tc.B().Info().Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Multi().Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Exec().Build(),\n\t\t)[3].val.values {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate Release On Close\", func(t *testing.T) {\n\t\tstored := 0\n\t\tw := &mockWire{}\n\t\tm.AcquireFn = func() wire { return w }\n\t\tm.StoreFn = func(ww wire) { stored++ }\n\t\tc, _ := client.Dedicate()\n\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build())\n\n\t\tc.Close()\n\n\t\tif stored != 1 {\n\t\t\tt.Fatalf(\"unexpected stored count %v\", stored)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate No Duplicate Release\", func(t *testing.T) {\n\t\tstored := 0\n\t\tw := &mockWire{}\n\t\tm.AcquireFn = func() wire { return w }\n\t\tm.StoreFn = func(ww wire) { stored++ }\n\t\tc, cancel := client.Dedicate()\n\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build())\n\n\t\tc.Close()\n\t\tc.Close() // should have no effect\n\t\tcancel()  // should have no effect\n\t\tcancel()  // should have no effect\n\n\t\tif stored != 1 {\n\t\t\tt.Fatalf(\"unexpected stored count %v\", stored)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated SetPubSubHooks Released\", func(t *testing.T) {\n\t\tc, cancel := client.Dedicate()\n\t\tch1 := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tch2 := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t<-ch1\n\t\tcancel()\n\t\t<-ch2\n\t})\n\n\tt.Run(\"Dedicated SetPubSubHooks Close\", func(t *testing.T) {\n\t\tc, cancel := client.Dedicate()\n\t\tdefer cancel()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tc.Close()\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", ch)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated SetPubSubHooks Released\", func(t *testing.T) {\n\t\tc, cancel := client.Dedicate()\n\t\tdefer cancel()\n\t\tif ch := c.SetPubSubHooks(PubSubHooks{}); ch != nil {\n\t\t\tt.Fatalf(\"unexpected ret %v\", ch)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate ErrDedicatedClientRecycled after released\", func(t *testing.T) {\n\t\tcheck := func(err error) {\n\t\t\tif !errors.Is(err, ErrDedicatedClientRecycled) {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tfor _, closeFn := range []func(client DedicatedClient, cancel func()){\n\t\t\tfunc(client DedicatedClient, cancel func()) {\n\t\t\t\tclient.Close()\n\t\t\t},\n\t\t\tfunc(client DedicatedClient, cancel func()) {\n\t\t\t\tcancel()\n\t\t\t},\n\t\t} {\n\t\t\tc, cancel := client.Dedicate()\n\t\t\tcloseFn(c, cancel)\n\t\t\tfor _, fn := range []func(){\n\t\t\t\tfunc() {\n\t\t\t\t\tresp := c.Do(context.Background(), c.B().Get().Key(\"k\").Build())\n\t\t\t\t\tcheck(resp.Error())\n\t\t\t\t},\n\t\t\t\tfunc() {\n\t\t\t\t\tresp := c.DoMulti(context.Background(), c.B().Get().Key(\"k\").Build())\n\t\t\t\t\tfor _, r := range resp {\n\t\t\t\t\t\tcheck(r.Error())\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunc() {\n\t\t\t\t\terr := c.Receive(context.Background(), c.B().Subscribe().Channel(\"k\").Build(), func(msg PubSubMessage) {})\n\t\t\t\t\tcheck(err)\n\t\t\t\t},\n\t\t\t\tfunc() {\n\t\t\t\t\tch := c.SetPubSubHooks(PubSubHooks{})\n\t\t\t\t\tcheck(<-ch)\n\t\t\t\t},\n\t\t\t} {\n\t\t\t\tfn()\n\t\t\t}\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient_SendToOnlyPrimaryNodes(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tprimaryNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsMultiResp\n\t\t\t},\n\t\t\t\"GET Do\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET Do\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"INFO\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoCacheOverride: map[string]func(cmd Cacheable, ttl time.Duration) RedisResult{\n\t\t\t\"GET DoCache\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET DoCache\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\treplicaNodeConn := &mockConn{}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \"127.0.0.1:0\" || dst == \"127.0.2.1:0\" { // primary nodes\n\t\t\t\treturn primaryNodeConn\n\t\t\t} else { // replica nodes\n\t\t\t\treturn replicaNodeConn\n\t\t\t}\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Do\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"GET Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Info().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"INFO\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMixCxSlot {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMulti(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"DoMulti Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"DoCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"GET DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Cache()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(c1, time.Second), CT(c2, time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]CacheableTTL, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = CT(client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Cache(), time.Second)\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Err\", func(t *testing.T) {\n\t\tv := errors.New(\"fn err\")\n\t\tif err := client.Dedicated(func(client DedicatedClient) error {\n\t\t\treturn v\n\t\t}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\tclient.Dedicated(func(c DedicatedClient) error {\n\t\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"b\").Build()).Error()\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err Multi\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn &mockWire{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tclient.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Multi Cross Slot Err\", func(t *testing.T) {\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\terr := client.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tdefer func() {\n\t\t\t\terr = errors.New(recover().(string))\n\t\t\t}()\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil || err.Error() != panicMsgCxSlot {\n\t\t\tt.Errorf(\"Multi should panic if cross slots is used\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)[3].val.values {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-ch; err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Info().Build(),\n\t\t\tc.B().Info().Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Multi().Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Exec().Build(),\n\t\t)[3].val.values {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient_SendToOnlyReplicaNodes(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tprimaryNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsMultiResp\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"INFO\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t}\n\treplicaNodeConn := &mockConn{\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"GET Do\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET Do\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoCacheOverride: map[string]func(cmd Cacheable, ttl time.Duration) RedisResult{\n\t\t\t\"GET DoCache\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET DoCache\"}, nil)\n\t\t\t},\n\t\t},\n\t}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \"127.0.0.1:0\" || dst == \"127.0.2.1:0\" { // primary nodes\n\t\t\t\treturn primaryNodeConn\n\t\t\t} else { // replica nodes\n\t\t\t\treturn replicaNodeConn\n\t\t\t}\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Do\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"GET Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Info().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"INFO\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMixCxSlot {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMulti(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"DoMulti Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"DoCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"GET DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Cache()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(c1, time.Second), CT(c2, time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]CacheableTTL, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = CT(client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Cache(), time.Second)\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Ssubscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\tclient.Dedicated(func(c DedicatedClient) error {\n\t\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"b\").Build()).Error()\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err Multi\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn &mockWire{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tclient.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Multi Cross Slot Err\", func(t *testing.T) {\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\terr := client.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tdefer func() {\n\t\t\t\terr = errors.New(recover().(string))\n\t\t\t}()\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil || err.Error() != panicMsgCxSlot {\n\t\t\tt.Errorf(\"Multi should panic if cross slots is used\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\treplicaNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t} // Subscribe can work on replicas\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)[3].val.values {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-ch; err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Info().Build(),\n\t\t\tc.B().Info().Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Multi().Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Exec().Build(),\n\t\t)[3].val.values {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient_SendReadOperationToReplicaNodesWriteOperationToPrimaryNodes(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tprimaryNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsMultiResp\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"INFO\"}, nil)\n\t\t\t},\n\t\t\t\"SET Do V\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"SET Do V\"}, nil)\n\t\t\t},\n\t\t\t\"SET K2{a} V2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"SET K2{a} V2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"SET K1\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"SET K2\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"MULTI\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: \"MULTI\"}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"EXEC\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: \"EXEC\"}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\treplicaNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"GET Do\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET Do\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"GET K1\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoCacheOverride: map[string]func(cmd Cacheable, ttl time.Duration) RedisResult{\n\t\t\t\"GET DoCache\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET DoCache\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Cmd.Commands(), \" \"), \"GET K1\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn cmd.IsReadOnly()\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \"127.0.0.1:0\" || dst == \"127.0.2.1:0\" { // primary nodes\n\t\t\t\treturn primaryNodeConn\n\t\t\t} else { // replica nodes\n\t\t\t\treturn replicaNodeConn\n\t\t\t}\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Do read operation\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"GET Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Do write operation\", func(t *testing.T) {\n\t\tc := client.B().Set().Key(\"Do\").Value(\"V\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"SET Do V\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot All Read Operations\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot Read Operation And Write Operation\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Set().Key(\"K2{a}\").Value(\"V2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"SET K2{a} V2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot Operations + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Multi().Build()\n\t\tc2 := client.B().Set().Key(\"K1{a}\").Value(\"V1{a}\").Build()\n\t\tc3 := client.B().Set().Key(\"K2{a}\").Value(\"V2{a}\").Build()\n\t\tc4 := client.B().Exec().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2, c3, c4)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"MULTI\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"SET K1{a} V1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"SET K2{a} V2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"EXEC\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMixCxSlot {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMulti(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"DoMulti Multi Slot All Read Operations\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"DoMulti Multi Slot Read & Write Operations\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif i%2 == 0 {\n\t\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t\t} else {\n\t\t\t\tmulti[i] = client.B().Set().Key(fmt.Sprintf(\"K2{%d}\", i)).Value(fmt.Sprintf(\"V2{%d}\", i)).Build()\n\t\t\t}\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif i%2 == 0 {\n\t\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"SET K2{%d} V2{%d}\", i, i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"DoCache Operation\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"GET DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Cache()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(c1, time.Second), CT(c2, time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]CacheableTTL, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = CT(client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Cache(), time.Second)\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Ssubscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\tclient.Dedicated(func(c DedicatedClient) error {\n\t\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"b\").Build()).Error()\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err Multi\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn &mockWire{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tclient.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Multi Cross Slot Err\", func(t *testing.T) {\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\terr := client.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tdefer func() {\n\t\t\t\terr = errors.New(recover().(string))\n\t\t\t}()\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil || err.Error() != panicMsgCxSlot {\n\t\t\tt.Errorf(\"Multi should panic if cross slots is used\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\treplicaNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t} // Subscribe can work on replicas\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)[3].val.values {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-ch; err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Info().Build(),\n\t\t\tc.B().Info().Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Multi().Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Exec().Build(),\n\t\t)[3].val.values {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient_SendPrimaryNodeOnlyButOneSlotAssigned(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tprimaryNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult {\n\t\t\t\treturn singleSlotResp\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"INFO\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"MULTI\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: \"MULTI\"}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"EXEC\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: \"EXEC\"}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn false\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\treturn primaryNodeConn\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"DoMulti Init Slot Operations\", func(t *testing.T) {\n\t\tc1 := client.B().Multi().Build()\n\t\tc2 := client.B().Exec().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"MULTI\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"EXEC\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClientErr(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tt.Run(\"not refresh on context error\", func(t *testing.T) {\n\t\tvar count int64\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tv := ctx.Err()\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\tatomic.AddInt64(&count, 1)\n\t\t\t\t\treturn slotsResp\n\t\t\t\t}\n\t\t\t\treturn newErrResult(v)\n\t\t\t},\n\t\t\tDoStreamFn: func(cmd Completed) RedisResultStream {\n\t\t\t\treturn RedisResultStream{e: v}\n\t\t\t},\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\tres := make([]RedisResult, len(multi))\n\t\t\t\tfor i := range res {\n\t\t\t\t\tres[i] = newErrResult(v)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: res}\n\t\t\t},\n\t\t\tDoMultiStreamFn: func(cmd ...Completed) MultiRedisResultStream {\n\t\t\t\treturn MultiRedisResultStream{e: v}\n\t\t\t},\n\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newErrResult(v)\n\t\t\t},\n\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tres := make([]RedisResult, len(multi))\n\t\t\t\tfor i := range res {\n\t\t\t\t\tres[i] = newErrResult(v)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: res}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn v\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.Do(ctx, client.B().Get().Key(\"a\").Build()).Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif s := client.DoStream(ctx, client.B().Get().Key(\"a\").Build()); s.Error() != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t\t}\n\t\tif err := client.DoMulti(ctx, client.B().Get().Key(\"a\").Build())[0].Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif s := client.DoMultiStream(ctx, client.B().Get().Key(\"a\").Build()); s.Error() != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t\t}\n\t\tif err := client.DoCache(ctx, client.B().Get().Key(\"a\").Cache(), 100).Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.DoMultiCache(ctx, CT(client.B().Get().Key(\"a\").Cache(), 100))[0].Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.Receive(ctx, client.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif c := atomic.LoadInt64(&count); c != 1 {\n\t\t\tt.Fatalf(\"unexpected refresh count %v\", c)\n\t\t}\n\t})\n\n\tt.Run(\"refresh err on pick\", func(t *testing.T) {\n\t\tvar first int64\n\t\tv := errors.New(\"refresh err\")\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif atomic.AddInt64(&first, 1) == 1 {\n\t\t\t\t\treturn singleSlotResp\n\t\t\t\t}\n\t\t\t\treturn newErrResult(v)\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn v\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif s := client.DoStream(context.Background(), client.B().Get().Key(\"a\").Build()); s.Error() != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t\t}\n\t\tif err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif s := client.DoMultiStream(context.Background(), client.B().Get().Key(\"a\").Build()); s.Error() != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t\t}\n\t\tfor _, resp := range client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif err := resp.Error(); err != v {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tif err := client.DoCache(context.Background(), client.B().Get().Key(\"a\").Cache(), 100).Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100))[0].Error(); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor _, resp := range client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100), CT(client.B().Get().Key(\"b\").Cache(), 100)) {\n\t\t\tif err := resp.Error(); err != v {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tif err := client.Receive(context.Background(), client.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"refresh empty on pick\", func(t *testing.T) {\n\t\tm := &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\treturn singleSlotResp\n\t\t}}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).Error(); err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].Error(); err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor _, resp := range client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif err := resp.Error(); err != ErrNoSlot {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tif err := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100))[0].Error(); err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor _, resp := range client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100), CT(client.B().Get().Key(\"b\").Cache(), 100)) {\n\t\t\tif err := resp.Error(); err != ErrNoSlot {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"refresh empty on pick in dedicated wire\", func(t *testing.T) {\n\t\tm := &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\treturn singleSlotResp\n\t\t}}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tvar ch <-chan error\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch = c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t}); err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"refresh empty on pick in dedicated wire (multi)\", func(t *testing.T) {\n\t\tm := &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\treturn singleSlotResp\n\t\t}}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tvar ch <-chan error\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch = c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tfor _, v := range c.DoMulti(context.Background(), c.B().Get().Key(\"a\").Build()) {\n\t\t\t\tif err := v.Error(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrNoSlot {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"slot reconnect\", func(t *testing.T) {\n\t\tvar count, check int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tatomic.AddInt64(&check, 1)\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t}\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"MOVED 0 :0\"}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif atomic.LoadInt64(&check) != 6 {\n\t\t\tt.Fatalf(\"unexpected check count %v\", check)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t}\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved redirect once\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif strings.Contains(dst, \":0\") {\n\t\t\t\t\t\t\tatomic.AddInt64(&count, 1)\n\t\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\n\t\tif atomic.LoadInt64(&count) != 1 {\n\t\t\tt.Fatalf(\"unexpected count %v\", count)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti (single)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].ToString(); err != nil || v != \"a\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti (single) redirect once\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tret := make([]RedisResult, len(multi))\n\n\t\t\t\t\t\tif strings.Contains(dst, \":0\") {\n\t\t\t\t\t\t\tatomic.AddInt64(&count, 1)\n\t\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif v, err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].ToString(); err != nil || v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\n\t\tif atomic.LoadInt64(&count) != 1 {\n\t\t\tt.Fatalf(\"unexpected count %v\", count)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"7\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"5\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"6\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"5{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"6{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"7{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[4].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"2\", \"3\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[5].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[7].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[8].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[9].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"5\", \"6\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[10].ToString(); err != nil || v != \"7\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions ASKING\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"7\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"5\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"6\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"5{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"6{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"7{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[4].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"2\", \"3\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[5].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[7].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[8].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[9].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"5\", \"6\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[10].ToString(); err != nil || v != \"7\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti except transactions\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"5\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"6\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"7\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"5{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"6{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"7{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[4].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"2\", \"3\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[5].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[7].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[8].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[9].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"5\", \"6\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[10].ToString(); err != nil || v != \"7\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti except transactions ASKING\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"5\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"6\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"7\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"5{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"6{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"7{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[4].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"2\", \"3\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[5].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[7].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[8].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[9].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"5\", \"6\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[10].ToString(); err != nil || v != \"7\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions mixed\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"7\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"5\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"6\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"5{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"6{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"7{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[4].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"2\", \"3\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[5].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[7].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[8].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[9].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"5\", \"6\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[10].ToString(); err != nil || v != \"7\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions mixed ASKING\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"7\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"QUEUED\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"5\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"6\"},\n\t\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"5{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"6{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"7{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[4].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"2\", \"3\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[5].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[7].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[8].ToString(); err != nil || v != \"QUEUED\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[9].AsStrSlice(); err != nil || !reflect.DeepEqual(v, []string{\"5\", \"6\"}) {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[10].ToString(); err != nil || v != \"7\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions edge cases 1\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ERR Command not allowed inside a transaction\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Multi().Build(), // nested multi\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif err := resps[2].Error(); err == nil || !strings.Contains(err.Error(), \"Command not allowed inside a transaction\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[3].Error(); err == nil || !strings.Contains(err.Error(), \"MOVED 0 :1\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[4].Error(); err == nil || !strings.Contains(err.Error(), \"MOVED 0 :1\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[5].Error(); err == nil || !strings.Contains(err.Error(), \"EXECABORT\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions edge cases 2\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ERR Command not allowed inside a transaction\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"EXECABORT\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"4\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Multi().Build(), // nested multi\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t\tclient.B().Get().Key(\"4{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif err := resps[2].Error(); err == nil || !strings.Contains(err.Error(), \"MOVED 0 :1\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[3].Error(); err == nil || !strings.Contains(err.Error(), \"Command not allowed inside a transaction\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[4].Error(); err == nil || !strings.Contains(err.Error(), \"MOVED 0 :1\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[5].Error(); err == nil || !strings.Contains(err.Error(), \"EXECABORT\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := resps[6].ToString(); err != nil || v != \"4\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti transactions edge cases 3\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tswitch atomic.AddInt64(&count, 1) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"ERR Command not allowed inside a transaction\"}, nil),\n\t\t\t\t\t\t\tnewResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tresps := client.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tclient.B().Get().Key(\"1{t}\").Build(),\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Get().Key(\"2{t}\").Build(),\n\t\t\tclient.B().Multi().Build(), // nested multi\n\t\t\tclient.B().Get().Key(\"3{t}\").Build(),\n\t\t)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"1\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif err := resps[2].Error(); err == nil || !strings.Contains(err.Error(), \"MOVED 0 :1\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[3].Error(); err == nil || !strings.Contains(err.Error(), \"Command not allowed inside a transaction\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif err := resps[4].Error(); err == nil || !strings.Contains(err.Error(), \"MOVED 0 :1\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti (multi)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMulti(context.Background(), client.B().Set().Key(\"a\").Value(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot moved DoMulti (multi) TRYAGAIN\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 2 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMulti(context.Background(), client.B().Set().Key(\"a\").Value(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil && i != 0 && !strings.Contains(err.Error(), \"TRYAGAIN\") {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot moved new\", func(t *testing.T) {\n\t\tvar count, check int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\tatomic.AddInt64(&check, 1)\n\t\t\t\t}\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t}\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif atomic.LoadInt64(&check) == 0 {\n\t\t\tt.Fatalf(\"unexpected check value %v\", check)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved new (multi 1)\", func(t *testing.T) {\n\t\tvar count, check int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\tatomic.AddInt64(&check, 1)\n\t\t\t\t}\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].ToString(); err != nil || v != \"a\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t\tif atomic.LoadInt64(&check) == 0 {\n\t\t\tt.Fatalf(\"unexpected check value %v\", check)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved new (multi 2)\", func(t *testing.T) {\n\t\tvar count, check int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\tatomic.AddInt64(&check, 1)\n\t\t\t\t}\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMulti(context.Background(), client.B().Set().Key(\"a\").Value(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif atomic.LoadInt64(&check) == 0 {\n\t\t\tt.Fatalf(\"unexpected check value %v\", check)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved new (multi 2) TRYAGAIN\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 2 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMulti(context.Background(), client.B().Set().Key(\"a\").Value(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil && i != 0 && !strings.Contains(err.Error(), \"TRYAGAIN\") {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot moved (cache)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoCache(context.Background(), client.B().Get().Key(\"a\").Cache(), 100).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved (cache) redirect once\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\t\t\tif strings.Contains(dst, \":0\") {\n\t\t\t\t\t\t\tatomic.AddInt64(&count, 1)\n\t\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif v, err := client.DoCache(context.Background(), client.B().Get().Key(\"a\").Cache(), 100).ToString(); err != nil || v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\n\t\tif atomic.LoadInt64(&count) != 1 {\n\t\t\tt.Fatalf(\"unexpected count %v\", count)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved (cache multi 1)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Cmd.Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100))[0].ToString(); err != nil || v != \"a\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved (cache multi 1) redirect once\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\t\tret := make([]RedisResult, len(multi))\n\n\t\t\t\t\t\tif strings.Contains(dst, \":0\") {\n\t\t\t\t\t\t\tatomic.AddInt64(&count, 1)\n\t\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :2\"}, nil)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Cmd.Commands()[1]}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif v, err := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100))[0].ToString(); err != nil || v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\n\t\tif atomic.LoadInt64(&count) != 1 {\n\t\t\tt.Fatalf(\"unexpected count %v\", count)\n\t\t}\n\t})\n\n\tt.Run(\"slot moved (cache multi 2)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"MOVED 0 :1\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t}\n\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: multi[i].Cmd.Commands()[1]}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100), CT(client.B().Get().Key(\"b\").Cache(), 100)) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot asking\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\treturn &redisresults{s: []RedisResult{{}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{{}, newResult(RedisMessage{typ: '+', string: \"b\"}, nil)}}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot asking DoMulti (single)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor i := 0; i < len(multi); i += 2 {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t\t\t\tret[i+1] = newResult(RedisMessage{typ: '+', string: multi[i+1].Commands()[1]}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].ToString(); err != nil || v != \"a\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot asking DoMulti (multi)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\tfor i := range ret {\n\t\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor i := 0; i < len(multi); i += 2 {\n\t\t\t\t\t\t\tret[i] = newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t\t\t\tret[i+1] = newResult(RedisMessage{typ: '+', string: multi[i+1].Commands()[1]}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot asking (cache)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '*', values: []RedisMessage{{}, {typ: '+', string: \"b\"}}}, nil)}}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoCache(context.Background(), client.B().Get().Key(\"a\").Cache(), 100).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot asking (cache multi 1)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)}}\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '*', values: []RedisMessage{{}, {typ: '+', string: \"b\"}}}, nil)}}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100))[0].ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot asking (cache multi 2)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil)}}\n\t\t\t\t\t},\n\t\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\t\t{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\t\t{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :1\"}, nil),\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t\t{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '*', values: []RedisMessage{{}, {}, {typ: '+', string: multi[4].Commands()[1]}}}, nil),\n\t\t\t\t\t\t\t{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '*', values: []RedisMessage{{}, {}, {typ: '+', string: multi[10].Commands()[1]}}}, nil),\n\t\t\t\t\t\t}}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100), CT(client.B().Get().Key(\"b\").Cache(), 100)) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot try again\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t}\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)\n\t\t\t\t\t}\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot try again DoMulti 1\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)}}\n\t\t\t\t\t}\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tret[0] = newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build())[0].ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot try again DoMulti 2\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)}}\n\t\t\t\t\t}\n\t\t\t\t\tret := make([]RedisResult, len(multi))\n\t\t\t\t\tret[0] = newResult(RedisMessage{typ: '+', string: multi[0].Commands()[1]}, nil)\n\t\t\t\t\treturn &redisresults{s: ret}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMulti(context.Background(), client.B().Get().Key(\"a\").Build(), client.B().Get().Key(\"b\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"slot try again (cache)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t},\n\t\t\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"b\"}, nil)\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoCache(context.Background(), client.B().Get().Key(\"a\").Cache(), 100).ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot try again (cache multi 1)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}, DoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)}}\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"b\"}, nil)}}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif v, err := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100))[0].ToString(); err != nil || v != \"b\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"slot try again (cache multi 2)\", func(t *testing.T) {\n\t\tvar count int64\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{DoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t\t}\n\t\t\t\t\treturn shardsMultiResp\n\t\t\t\t}, DoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\tif atomic.AddInt64(&count, 1) <= 3 {\n\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"TRYAGAIN\"}, nil)}}\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: multi[0].Cmd.Commands()[1]}, nil)}}\n\t\t\t\t}}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tfor i, resp := range client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a\").Cache(), 100), CT(client.B().Get().Key(\"b\").Cache(), 100)) {\n\t\t\tif v, err := resp.ToString(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 0 && v != \"a\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t} else if i == 1 && v != \"b\" {\n\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestClusterClientRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tSetupClientRetry(t, func(m *mockConn) Client {\n\t\tm.DoOverride = map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult { return slotsMultiResp },\n\t\t}\n\t\tc, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn c\n\t})\n}\n\nfunc TestClusterClientReplicaOnly_PickReplica(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tm := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\treturn slotsMultiResp\n\t\t\t}\n\t\t\treturn RedisResult{}\n\t\t},\n\t}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\"}, ReplicaOnly: true},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tcopiedM := *m\n\t\t\treturn &copiedM\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tt.Run(\"replicas should be picked\", func(t *testing.T) {\n\t\tif client.pslots[0] != client.conns[\"127.0.1.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 0\")\n\t\t}\n\t\tif client.pslots[8192] != client.conns[\"127.0.1.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != client.conns[\"127.0.3.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != client.conns[\"127.0.3.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 16383\")\n\t\t}\n\t})\n}\n\nfunc TestClusterClientReplicaOnly_PickMasterIfNoReplica(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"replicas should be picked\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\"}, ReplicaOnly: true},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tcopiedM := *m\n\t\t\t\treturn &copiedM\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif client.pslots[0] != client.conns[\"127.0.1.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 0\")\n\t\t}\n\t\tif client.pslots[8192] != client.conns[\"127.0.1.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 8192\")\n\t\t}\n\t\tif client.pslots[8193] != client.conns[\"127.0.3.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 8193\")\n\t\t}\n\t\tif client.pslots[16383] != client.conns[\"127.0.3.1:1\"].conn {\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot 16383\")\n\t\t}\n\t})\n\n\tt.Run(\"distributed to replicas\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiRespWithMultiReplicas\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\"127.0.0.1:0\"}, ReplicaOnly: true},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tcopiedM := *m\n\t\t\t\treturn &copiedM\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tfor slot := 0; slot < 8193; slot++ {\n\t\t\tif client.pslots[slot] == client.conns[\"127.0.0.2:1\"].conn {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif client.pslots[slot] == client.conns[\"127.0.0.3:2\"].conn {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif client.pslots[slot] == client.conns[\"127.0.0.4:3\"].conn {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot %d\", slot)\n\t\t}\n\n\t\tfor slot := 8193; slot < 16384; slot++ {\n\t\t\tif client.pslots[slot] == client.conns[\"127.0.1.2:1\"].conn {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif client.pslots[slot] == client.conns[\"127.0.1.3:2\"].conn {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif client.pslots[slot] == client.conns[\"127.0.1.4:3\"].conn {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tt.Fatalf(\"unexpected replica node assigned to slot %d\", slot)\n\t\t}\n\t})\n}\n\nfunc TestClusterShardsParsing(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"master selection\", func(t *testing.T) {\n\t\tresult := parseShards(shardsRespTls.val, \"127.0.0.1:5\", true)\n\t\tif len(result) != 1 {\n\t\t\tt.Fatalf(\"unexpected result %v\", result)\n\t\t}\n\t\tif _, ok := result[\"127.0.1.1:1\"]; !ok {\n\t\t\tt.Fatal(\"unexpected master node\")\n\t\t}\n\t})\n\n\tt.Run(\"port selection\", func(t *testing.T) {\n\t\tresult := parseShards(shardsRespTls.val, \"127.0.0.1:5\", true)\n\t\tif len(result) != 1 {\n\t\t\tt.Fatalf(\"unexpected result %v\", result)\n\t\t}\n\t\tfor _, val := range result {\n\t\t\t_nodes := val.nodes\n\t\t\tsort.Slice(_nodes, func(i, j int) bool {\n\t\t\t\treturn _nodes[i].Addr < _nodes[j].Addr\n\t\t\t})\n\t\t\tif len(_nodes) != 3 ||\n\t\t\t\t_nodes[0].Addr != \"127.0.1.1:1\" ||\n\t\t\t\t_nodes[1].Addr != \"127.0.2.1:2\" ||\n\t\t\t\t_nodes[2].Addr != \"127.0.3.1:3\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", _nodes)\n\t\t\t}\n\t\t}\n\n\t\tresult = parseShards(shardsRespTls.val, \"127.0.0.1:5\", false)\n\t\tif len(result) != 1 {\n\t\t\tt.Fatalf(\"unexpected result %v\", result)\n\t\t}\n\t\tfor _, val := range result {\n\t\t\t_nodes := val.nodes\n\t\t\tsort.Slice(_nodes, func(i, j int) bool {\n\t\t\t\treturn _nodes[i].Addr < _nodes[j].Addr\n\t\t\t})\n\t\t\tif len(_nodes) != 3 ||\n\t\t\t\t_nodes[0].Addr != \"127.0.1.1:0\" ||\n\t\t\t\t_nodes[1].Addr != \"127.0.2.1:0\" ||\n\t\t\t\t_nodes[2].Addr != \"127.0.3.1:3\" {\n\t\t\t\tt.Fatalf(\"unexpected nodes %v\", _nodes)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"master position\", func(t *testing.T) {\n\t\tresult := parseShards(shardsRespTls.val, \"127.0.0.1:5\", true)\n\t\tif len(result) != 1 {\n\t\t\tt.Fatalf(\"unexpected result %v\", result)\n\t\t}\n\t\tfor master, group := range result {\n\t\t\tif len(group.nodes) == 0 || group.nodes[0].Addr != master {\n\t\t\t\tt.Fatalf(\"unexpected first node %v\", group)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// https://github.com/redis/rueidis/issues/543\nfunc TestConnectToNonAvailableCluster(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 4; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t_, err := NewClient(ClientOption{\n\t\t\t\t\tInitAddress: []string{\"127.0.0.1:3000\", \"127.0.0.1:3001\", \"127.0.0.1:3002\"},\n\t\t\t\t})\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected connect error\")\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestClusterTopologyRefreshment(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tt.Run(\"no refreshment\", func(t *testing.T) {\n\t\tvar callCount int64\n\t\tcc, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tClusterOption: ClusterOption{\n\t\t\t\t\tShardsRefreshInterval: 0,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t// initial call\n\t\t\t\t\t\tif atomic.CompareAndSwapInt64(&callCount, 0, 1) {\n\t\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt.Fatalf(\"unexpected call\")\n\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tdefer cc.Close()\n\n\t\ttime.Sleep(3 * time.Second) // verify that no refreshment is called\n\n\t\tif atomic.LoadInt64(&callCount) != 1 {\n\t\t\tt.Fatalf(\"unexpected call count %d\", callCount)\n\t\t}\n\t})\n\n\tt.Run(\"nothing changed\", func(t *testing.T) {\n\t\tvar callCount int64\n\t\trefreshWaitCh := make(chan struct{})\n\t\tcli, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tClusterOption: ClusterOption{\n\t\t\t\t\tShardsRefreshInterval: time.Second,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif atomic.AddInt64(&callCount, 1) >= 3 {\n\t\t\t\t\t\t\tdefer func() { recover() }()\n\t\t\t\t\t\t\tdefer close(refreshWaitCh)\n\t\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-refreshWaitCh:\n\t\t\tcli.Close()\n\n\t\t\tcli.mu.Lock()\n\t\t\tconns := cli.conns\n\t\t\tcli.mu.Unlock()\n\t\t\tif len(conns) != 1 {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t\tif _, ok := conns[\"127.0.0.1:0\"]; !ok {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"replicas are changed\", func(t *testing.T) {\n\t\tvar callCount int64\n\t\trefreshWaitCh := make(chan struct{})\n\t\tcli, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tClusterOption: ClusterOption{\n\t\t\t\t\tShardsRefreshInterval: time.Second,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif c := atomic.AddInt64(&callCount, 1); c >= 6 {\n\t\t\t\t\t\t\tdefer func() { recover() }()\n\t\t\t\t\t\t\tdefer close(refreshWaitCh)\n\t\t\t\t\t\t\treturn slotsResp\n\t\t\t\t\t\t} else if c >= 3 {\n\t\t\t\t\t\t\treturn slotsResp\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-refreshWaitCh:\n\t\t\tcli.Close()\n\n\t\t\tcli.mu.Lock()\n\t\t\tconns := cli.conns\n\t\t\tcli.mu.Unlock()\n\t\t\tif len(conns) != 2 {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t\tif _, ok := conns[\"127.0.0.1:0\"]; !ok {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t\tif _, ok := conns[\"127.0.1.1:1\"]; !ok {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"shards are changed\", func(t *testing.T) {\n\t\tvar callCount int64\n\t\trefreshWaitCh := make(chan struct{})\n\t\tcli, err := newClusterClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\t\tClusterOption: ClusterOption{\n\t\t\t\t\tShardsRefreshInterval: time.Second,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\tif c := atomic.AddInt64(&callCount, 1); c >= 6 {\n\t\t\t\t\t\t\tdefer func() { recover() }()\n\t\t\t\t\t\t\tdefer close(refreshWaitCh)\n\t\t\t\t\t\t\treturn slotsMultiRespWithoutReplicas\n\t\t\t\t\t\t} else if c >= 3 {\n\t\t\t\t\t\t\treturn slotsMultiRespWithoutReplicas\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn singleSlotResp\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tselect {\n\t\tcase <-refreshWaitCh:\n\t\t\tcli.Close()\n\n\t\t\tcli.mu.Lock()\n\t\t\tconns := cli.conns\n\t\t\tcli.mu.Unlock()\n\t\t\tif len(conns) != 2 {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t\tif _, ok := conns[\"127.0.0.1:0\"]; !ok {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t\tif _, ok := conns[\"127.0.1.1:0\"]; !ok {\n\t\t\t\tt.Fatalf(\"unexpected conns %v\", conns)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestClusterClientLoadingRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tsetup := func() (*clusterClient, *mockConn) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn client, m\n\t}\n\n\tt.Run(\"Do Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\treturn slotsMultiResp\n\t\t\t}\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"test\").Build()).ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif attempts != 2 {\n\t\t\tt.Fatalf(\"expected 2 attempts, got %v\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"Do not retry on non-loading errors\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\treturn slotsMultiResp\n\t\t\t}\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ERR some other error\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tif err := client.Do(context.Background(), client.B().Get().Key(\"test\").Build()).Error(); err == nil {\n\t\t\tt.Fatal(\"expected error but got nil\")\n\t\t}\n\t\tif attempts != 1 {\n\t\t\tt.Fatalf(\"unexpected attempts %v, expected no retry\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Build()\n\t\tresps := client.DoMulti(context.Background(), cmd)\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoCache Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoCacheFn = func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), cmd, time.Minute).ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(cmd, time.Minute))\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Do Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\treturn slotsMultiResp\n\t\t\t}\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\t\tm.AcquireFn = func() wire { return &mockWire{DoFn: m.DoFn} }\n\n\t\terr := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"test\").Build()).ToString(); err != nil || v != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated DoMulti Retry on Loading\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\t\tm.AcquireFn = func() wire { return &mockWire{DoMultiFn: m.DoMultiFn} }\n\n\t\terr := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tresps := c.DoMulti(context.Background(), c.B().Get().Key(\"test\").Build())\n\t\t\tif len(resps) != 1 {\n\t\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t\t}\n\t\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n}\n\nfunc TestClusterClientMovedRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tsetup := func() (*clusterClient, *mockConn) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn client, m\n\t}\n\n\tt.Run(\"DoMulti Retry on MOVED\", func(t *testing.T) {\n\t\tclient, m := setup()\n\n\t\tattempts := 0\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"MOVED 0 127.0.0.1\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Set().Key(\"test\").Value(`test`).Build()\n\t\tresps := client.DoMulti(context.Background(), cmd)\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Retry on ASK\", func(t *testing.T) {\n\t\tclient, m := setup()\n\n\t\tattempts := 0\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"ASK 0 127.0.0.1\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil), newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Set().Key(\"test\").Value(`test`).Build()\n\t\tresps := client.DoMulti(context.Background(), cmd)\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n}\n\nfunc TestClusterClientCacheASKRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tsetup := func() (*clusterClient, *mockConn) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif strings.Join(cmd.Commands(), \" \") == \"CLUSTER SLOTS\" {\n\t\t\t\t\treturn slotsMultiResp\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn client, m\n\t}\n\n\tt.Run(\"DoCache Retry on ASK\", func(t *testing.T) {\n\t\tclient, m := setup()\n\t\tattempts := 0\n\t\tm.DoCacheFn = func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ASK 0 :0\"}, nil)\n\t\t}\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :0\"}, nil), newResult(RedisMessage{typ: '_'}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '*', values: []RedisMessage{{}, {}, {}, {}, {}, {typ: '+', string: \"OK\"}}}, nil)}}\n\t\t}\n\t\tresp := client.DoCache(context.Background(), client.B().Get().Key(\"a1\").Cache(), 10*time.Second)\n\t\tif v, err := resp.ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif attempts != 2 {\n\t\t\tt.Fatalf(\"expected 2 attempts, got %v\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Retry on ASK\", func(t *testing.T) {\n\t\tclient, m := setup()\n\n\t\tattempts := 0\n\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"ASK 0 :0\"}, nil)}}\n\t\t}\n\t\tm.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, newResult(RedisMessage{typ: '-', string: \"ASK 0 :0\"}, nil), newResult(RedisMessage{typ: '_'}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{{}, {}, {}, {}, {}, newResult(RedisMessage{typ: '*', values: []RedisMessage{{}, {}, {}, {}, {}, RedisMessage{typ: '+', string: \"OK\"}}}, nil)}}\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), CT(client.B().Get().Key(\"a1\").Cache(), 10*time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif attempts != 2 {\n\t\t\tt.Fatalf(\"expected 2 attempts, got %v\", attempts)\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient_SendReadOperationToReplicaNodeWriteOperationToPrimaryNode(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tprimaryNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsMultiResp\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"INFO\"}, nil)\n\t\t\t},\n\t\t\t\"SET Do V\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"SET Do V\"}, nil)\n\t\t\t},\n\t\t\t\"SET K2{a} V2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"SET K2{a} V2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"SET K1\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"SET K2\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"MULTI\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: \"MULTI\"}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"EXEC\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: \"EXEC\"}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\treplicaNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"GET Do\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET Do\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Commands(), \" \"), \"GET K1\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoCacheOverride: map[string]func(cmd Cacheable, ttl time.Duration) RedisResult{\n\t\t\t\"GET DoCache\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET DoCache\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tif strings.HasPrefix(strings.Join(cmd.Cmd.Commands(), \" \"), \"GET K1\") {\n\t\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Cmd.Commands(), \" \")}, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturn &redisresults{\n\t\t\t\t\ts: []RedisResult{},\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn cmd.IsReadOnly()\n\t\t\t},\n\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \"127.0.0.1:0\" || dst == \"127.0.2.1:0\" { // primary node\n\t\t\t\treturn primaryNodeConn\n\t\t\t} else { // replica node\n\t\t\t\treturn replicaNodeConn\n\t\t\t}\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Do read operation\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"GET Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Do write operation\", func(t *testing.T) {\n\t\tc := client.B().Set().Key(\"Do\").Value(\"V\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"SET Do V\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot All Read Operations\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot Read Operation And Write Operation\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Set().Key(\"K2{a}\").Value(\"V2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"SET K2{a} V2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot Operations + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Multi().Build()\n\t\tc2 := client.B().Set().Key(\"K1{a}\").Value(\"V1{a}\").Build()\n\t\tc3 := client.B().Set().Key(\"K2{a}\").Value(\"V2{a}\").Build()\n\t\tc4 := client.B().Exec().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2, c3, c4)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"MULTI\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"SET K1{a} V1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[2].ToString(); err != nil || v != \"SET K2{a} V2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[3].ToString(); err != nil || v != \"EXEC\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMixCxSlot {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMulti(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"DoMulti Multi Slot All Read Operations\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"DoMulti Multi Slot Read & Write Operations\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif i%2 == 0 {\n\t\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t\t} else {\n\t\t\t\tmulti[i] = client.B().Set().Key(fmt.Sprintf(\"K2{%d}\", i)).Value(fmt.Sprintf(\"V2{%d}\", i)).Build()\n\t\t\t}\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif i%2 == 0 {\n\t\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"SET K2{%d} V2{%d}\", i, i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"DoCache Operation\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"GET DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Cache()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(c1, time.Second), CT(c2, time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]CacheableTTL, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = CT(client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Cache(), time.Second)\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Ssubscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\tclient.Dedicated(func(c DedicatedClient) error {\n\t\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"b\").Build()).Error()\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err Multi\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn &mockWire{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tclient.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Multi Cross Slot Err\", func(t *testing.T) {\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\terr := client.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tdefer func() {\n\t\t\t\terr = errors.New(recover().(string))\n\t\t\t}()\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil || err.Error() != panicMsgCxSlot {\n\t\t\tt.Errorf(\"Multi should panic if cross slots is used\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Subscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)[3].val.values {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-ch; err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Info().Build(),\n\t\t\tc.B().Info().Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Multi().Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Exec().Build(),\n\t\t)[3].val.values {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestClusterClient_SendToOnlyPrimaryNodeWhenPrimaryNodeSelected(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tprimaryNodeConn := &mockConn{\n\t\tDoOverride: map[string]func(cmd Completed) RedisResult{\n\t\t\t\"CLUSTER SLOTS\": func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsMultiResp\n\t\t\t},\n\t\t\t\"GET Do\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET Do\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t\t\"INFO\": func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"INFO\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t\tDoCacheOverride: map[string]func(cmd Cacheable, ttl time.Duration) RedisResult{\n\t\t\t\"GET DoCache\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET DoCache\"}, nil)\n\t\t\t},\n\t\t\t\"GET K1{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K1{a}\"}, nil)\n\t\t\t},\n\t\t\t\"GET K2{a}\": func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"GET K2{a}\"}, nil)\n\t\t\t},\n\t\t},\n\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\tresps := make([]RedisResult, len(multi))\n\t\t\tfor i, cmd := range multi {\n\t\t\t\tresps[i] = newResult(RedisMessage{typ: '+', string: strings.Join(cmd.Cmd.Commands(), \" \")}, nil)\n\t\t\t}\n\t\t\treturn &redisresults{s: resps}\n\t\t},\n\t}\n\treplicaNodeConn := &mockConn{}\n\n\tclient, err := newClusterClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\treturn -1\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \"127.0.0.1:0\" || dst == \"127.0.2.1:0\" { // primary nodes\n\t\t\t\treturn primaryNodeConn\n\t\t\t} else { // replica nodes\n\t\t\t\treturn replicaNodeConn\n\t\t\t}\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tt.Run(\"Do\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"GET Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Single Slot + Init Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Info().Build()\n\t\tresps := client.DoMulti(context.Background(), c1, c2)\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"INFO\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Cross Slot + Init Slot\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMixCxSlot {\n\t\t\t\tt.Errorf(\"DoMulti should panic if Cross Slot + Init Slot\")\n\t\t\t}\n\t\t}()\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Build()\n\t\tc2 := client.B().Get().Key(\"K1{b}\").Build()\n\t\tc3 := client.B().Info().Build()\n\t\tclient.DoMulti(context.Background(), c1, c2, c3)\n\t})\n\n\tt.Run(\"DoMulti Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]Completed, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Build()\n\t\t}\n\t\tresps := client.DoMulti(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"DoCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"GET DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Single Slot\", func(t *testing.T) {\n\t\tc1 := client.B().Get().Key(\"K1{a}\").Cache()\n\t\tc2 := client.B().Get().Key(\"K2{a}\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(c1, time.Second), CT(c2, time.Second))\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"GET K1{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v, err := resps[1].ToString(); err != nil || v != \"GET K2{a}\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Multi Slot\", func(t *testing.T) {\n\t\tmulti := make([]CacheableTTL, 500)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tmulti[i] = CT(client.B().Get().Key(fmt.Sprintf(\"K1{%d}\", i)).Cache(), time.Second)\n\t\t}\n\t\tresps := client.DoMultiCache(context.Background(), multi...)\n\t\tfor i := 0; i < len(multi); i++ {\n\t\t\tif v, err := resps[i].ToString(); err != nil || v != fmt.Sprintf(\"GET K1{%d}\", i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tprimaryNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\treplicaNodeConn.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Err\", func(t *testing.T) {\n\t\tv := errors.New(\"fn err\")\n\t\tif err := client.Dedicated(func(client DedicatedClient) error {\n\t\t\treturn v\n\t\t}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\tclient.Dedicated(func(c DedicatedClient) error {\n\t\t\tc.Do(context.Background(), c.B().Get().Key(\"a\").Build()).Error()\n\t\t\treturn c.Do(context.Background(), c.B().Get().Key(\"b\").Build()).Error()\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Cross Slot Err Multi\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != panicMsgCxSlot {\n\t\t\t\tt.Errorf(\"Dedicated should panic if cross slots is used\")\n\t\t\t}\n\t\t}()\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn &mockWire{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tclient.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tt.Run(\"Dedicated Multi Cross Slot Err\", func(t *testing.T) {\n\t\tprimaryNodeConn.AcquireFn = func() wire { return &mockWire{} }\n\t\terr := client.Dedicated(func(c DedicatedClient) (err error) {\n\t\t\tdefer func() {\n\t\t\t\terr = errors.New(recover().(string))\n\t\t\t}()\n\t\t\tc.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"b\").Build(),\n\t\t\t)\n\t\t\treturn nil\n\t\t})\n\t\tif err == nil || err.Error() != panicMsgCxSlot {\n\t\t\tt.Errorf(\"Multi should panic if cross slots is used\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Receive Redis Err\", func(t *testing.T) {\n\t\te := &RedisError{}\n\t\tw := &mockWire{\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn e\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\treturn c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {})\n\t\t}); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t\tc.B().Info().Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor i, resp := range c.DoMulti(\n\t\t\t\tcontext.Background(),\n\t\t\t\tc.B().Multi().Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\t\tc.B().Exec().Build(),\n\t\t\t)[3].val.values {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-ch; err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\tc.Close()\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate\", func(t *testing.T) {\n\t\tclosed := false\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\tif len(cmd) == 4 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"OK\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate0\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"Delegate1\"},\n\t\t\t\t\t\t}}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate0\"}, nil),\n\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"Delegate1\"}, nil),\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tSetPubSubHooksFn: func(hooks PubSubHooks) <-chan error {\n\t\t\t\tch := make(chan error, 1)\n\t\t\t\tch <- ErrClosing\n\t\t\t\tclose(ch)\n\t\t\t\treturn ch\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tclosed = true\n\t\t\t},\n\t\t}\n\t\tprimaryNodeConn.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tprimaryNodeConn.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tch := c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}})\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Info().Build(),\n\t\t\tc.B().Info().Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tfor i, resp := range c.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tc.B().Multi().Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Get().Key(\"a\").Build(),\n\t\t\tc.B().Exec().Build(),\n\t\t)[3].val.values {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\"+strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tif err := <-c.SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tc.Close()\n\t\tcancel()\n\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t\tif !closed {\n\t\t\tt.Fatalf(\"Dedicated desn't delegate Close\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "cmds.go",
          "type": "blob",
          "size": 1.265625,
          "content": "package rueidis\n\nimport \"github.com/redis/rueidis/internal/cmds\"\n\n// Builder represents a command builder. It should only be created from the client.B() method.\ntype Builder = cmds.Builder\n\n// Incomplete represents an incomplete Redis command. It should then be completed by calling the Build().\ntype Incomplete = cmds.Incomplete\n\n// Completed represents a completed Redis command. It should only be created from the Build() of a command builder.\ntype Completed = cmds.Completed\n\n// Cacheable represents a completed Redis command which supports server-assisted client side caching,\n// and it should be created by the Cache() of command builder.\ntype Cacheable = cmds.Cacheable\n\n// Commands is an exported alias to []Completed.\n// This allows users to store commands for later usage, for example:\n//\n//\tc, release := client.Dedicate()\n//\tdefer release()\n//\n//\tcmds := make(rueidis.Commands, 0, 10)\n//\tfor i := 0; i < 10; i++ {\n//\t    cmds = append(cmds, c.B().Set().Key(strconv.Itoa(i)).Value(strconv.Itoa(i)).Build())\n//\t}\n//\tfor _, resp := range c.DoMulti(ctx, cmds...) {\n//\t    if err := resp.Error(); err != nil {\n//\t    panic(err)\n//\t}\n//\n// However, please know that once commands are processed by the Do() or DoMulti(), they are recycled and should not be reused.\ntype Commands []Completed\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.0712890625,
          "content": "coverage:\n  status:\n    project: false\n    patch: false\nignore:\n  - hack\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 3.9384765625,
          "content": "services:\n  redis:\n    image: redis:7.4-alpine\n    ports:\n      - \"6379:6379\"\n  redislock:\n    image: redis:7.4-alpine\n    ports:\n      - \"6376:6379\"\n  redis5:\n    image: redis:5-alpine\n    ports:\n      - \"6355:6379\"\n  keydb6:\n    image: eqalpha/keydb:alpine_x86_64_v6.3.1\n    ports:\n      - \"6344:6379\"\n  dragonflydb:\n    image: docker.dragonflydb.io/dragonflydb/dragonfly:v1.20.1\n    ports:\n      - \"6333:6379\"\n  kvrocks:\n    image: apache/kvrocks:2.2.0\n    ports:\n      - \"6666:6666\"\n  redisearch:\n    image: redislabs/redisearch:2.8.4\n    ports:\n      - \"6377:6379\"\n  compat:\n    image: redis/redis-stack:7.4.0-v0\n    ports:\n      - \"6378:6379\"\n  compat5:\n    image: redis:5-alpine\n    ports:\n      - \"6356:6379\"\n  compat-redisearch:\n    image: redis/redis-stack:7.4.0-v0\n    ports:\n      - \"6381:6379\"\n  sentinel:\n    image: redis:7.4-alpine\n    entrypoint:\n      - /bin/sh\n      - -c\n      - |\n        redis-server --save \"\" --appendonly no --port 6380 &\n        echo \"sentinel monitor test 127.0.0.1 6380 2\\n\" > sentinel.conf\n        redis-server sentinel.conf --sentinel\n    ports:\n      - \"6380:6380\"\n      - \"26379:26379\"\n  sentinel5:\n    image: redis:5-alpine\n    entrypoint:\n      - /bin/sh\n      - -c\n      - |\n        redis-server --save \"\" --appendonly no --port 6385 &\n        echo \"sentinel monitor test5 127.0.0.1 6385 2\\n\" > sentinel.conf\n        redis-server sentinel.conf --sentinel\n    ports:\n      - \"6385:6385\"\n      - \"26355:26379\"\n  cluster:\n    image: redis:7.4-alpine\n    entrypoint:\n      - /bin/sh\n      - -c\n      - |\n        redis-server --port 7001 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7001.conf &\n        redis-server --port 7002 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7002.conf &\n        redis-server --port 7003 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7003.conf &\n        while ! redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 --cluster-yes; do sleep 1; done\n        wait\n    ports:\n      - \"7001:7001\"\n      - \"7002:7002\"\n      - \"7003:7003\"\n  cluster5:\n    image: redis:5-alpine\n    entrypoint:\n      - /bin/sh\n      - -c\n      - |\n        redis-server --port 7004 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7004.conf &\n        redis-server --port 7005 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7005.conf &\n        redis-server --port 7006 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7006.conf &\n        while ! redis-cli --cluster create 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-yes; do sleep 1; done\n        wait\n    ports:\n      - \"7004:7004\"\n      - \"7005:7005\"\n      - \"7006:7006\"\n  cluster5adapter:\n    image: redis:5-alpine\n    entrypoint:\n      - /bin/sh\n      - -c\n      - |\n        redis-server --port 7007 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7007.conf &\n        redis-server --port 7008 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7008.conf &\n        redis-server --port 7009 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7009.conf &\n        while ! redis-cli --cluster create 127.0.0.1:7007 127.0.0.1:7008 127.0.0.1:7009 --cluster-yes; do sleep 1; done\n        wait\n    ports:\n      - \"7007:7007\"\n      - \"7008:7008\"\n      - \"7009:7009\"\n  clusteradapter:\n    image: redis:7.4-alpine\n    entrypoint:\n      - /bin/sh\n      - -c\n      - |\n        redis-server --port 7010 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7010.conf &\n        redis-server --port 7011 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7011.conf &\n        redis-server --port 7012 --save \"\" --appendonly no --cluster-enabled yes --cluster-config-file 7012.conf &\n        while ! redis-cli --cluster create 127.0.0.1:7010 127.0.0.1:7011 127.0.0.1:7012 --cluster-yes; do sleep 1; done\n        wait\n    ports:\n      - \"7010:7010\"\n      - \"7011:7011\"\n      - \"7012:7012\"\n"
        },
        {
          "name": "dockertest.sh",
          "type": "blob",
          "size": 0.9384765625,
          "content": "#!/usr/bin/env bash\n\nset -ev\n\ngo vet ./...\n\ngo install honnef.co/go/tools/cmd/staticcheck@latest\n# disabled checks\n#  -ST1000 missing package doc in internal packages\n#  -ST1003 wrong naming convention would require breaking changes\n#  -ST1012 wrong error name convention in om package would require breaking changes\n#  -ST1016 violation of methods on the same type should have the same receiver name in rueidishook\n#  -ST1020 violation of go doc comment on exported methods in rueidiscompat\n#  -ST1021 violation of go doc comment on exported types in rueidiscompat\n#  -U1000 unused check in mock package\nstaticcheck -checks \"all,-ST1000,-ST1003,-ST1012,-ST1016,-ST1020,-ST1021,-U1000\"  ./... | (grep -v \"_test.go:\" && exit 1 || exit 0)\n\ntrap \"docker compose down -v\" EXIT\ndocker compose up -d\nsleep 5\ngo install gotest.tools/gotestsum@v1.10.0\ngotestsum --format standard-verbose --junitfile unit-tests.xml -- -coverprofile=coverage.out -race -timeout 30m \"$@\"\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4833984375,
          "content": "module github.com/redis/rueidis\n\ngo 1.21\n\nrequire (\n\tgithub.com/onsi/gomega v1.34.1\n\tgolang.org/x/sys v0.24.0\n)\n\nrequire (\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/kr/pretty v0.1.0 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 // indirect\n\tgolang.org/x/net v0.27.0 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.85546875,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/go-logr/logr v1.4.1 h1:pKouT5E8xu9zeFC39JXRDukb6JFQPXM5p5I91188VAQ=\ngithub.com/go-logr/logr v1.4.1/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20240424215950-a892ee059fd6 h1:k7nVchz72niMH6YLQNvHSdIE7iqsQxK1P41mySCvssg=\ngithub.com/google/pprof v0.0.0-20240424215950-a892ee059fd6/go.mod h1:kf6iHlnVGwgKolg33glAes7Yg/8iWP8ukqeldJSO7jw=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/onsi/ginkgo/v2 v2.19.0 h1:9Cnnf7UHo57Hy3k6/m5k3dRfGTMXGvxhHFvkDTCTpvA=\ngithub.com/onsi/ginkgo/v2 v2.19.0/go.mod h1:rlwLi9PilAFJ8jCg9UE1QP6VBpd6/xj3SRC0d6TU0To=\ngithub.com/onsi/gomega v1.34.1 h1:EUMJIKUjM8sKjYbtxQI9A4z2o+rruxnzNvpknOXie6k=\ngithub.com/onsi/gomega v1.34.1/go.mod h1:kU1QgUvBDLXBJq618Xvm2LUX6rSAfRaFRTcdOeDLwwY=\ngolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 h1:2dVuKD2vS7b0QIHQbpyTISPd0LeHDbnYEryqj5Q1ug8=\ngolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56/go.mod h1:M4RDyNAINzryxdtnbRXRL/OHtkFuWGRjvuhBJpk2IlY=\ngolang.org/x/net v0.27.0 h1:5K3Njcw06/l2y9vpGCSdcxWOYHOUk3dVNGDXN+FvAys=\ngolang.org/x/net v0.27.0/go.mod h1:dDi0PyhWNoiUOrAS8uXv/vnScO4wnHQO4mj9fn/RytE=\ngolang.org/x/sys v0.24.0 h1:Twjiwq9dn6R1fQcyiK+wQyHWfaz/BJB+YIpzU/Cv3Xg=\ngolang.org/x/sys v0.24.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngolang.org/x/tools v0.23.0 h1:SGsXPZ+2l4JsgaCKkx+FQ9YZ5XEtA1GZYuoDjenLjvg=\ngolang.org/x/tools v0.23.0/go.mod h1:pnu6ufv6vQkll6szChhK3C3L/ruaIv5eBeztNG8wtsI=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "hack",
          "type": "tree",
          "content": null
        },
        {
          "name": "helper.go",
          "type": "blob",
          "size": 8.5263671875,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\tintl \"github.com/redis/rueidis/internal/cmds\"\n)\n\n// MGetCache is a helper that consults the client-side caches with multiple keys by grouping keys within same slot into multiple GETs\nfunc MGetCache(client Client, ctx context.Context, ttl time.Duration, keys []string) (ret map[string]RedisMessage, err error) {\n\tif len(keys) == 0 {\n\t\treturn make(map[string]RedisMessage), nil\n\t}\n\tif isCacheDisabled(client) {\n\t\treturn MGet(client, ctx, keys)\n\t}\n\tcmds := mgetcachecmdsp.Get(len(keys), len(keys))\n\tdefer mgetcachecmdsp.Put(cmds)\n\tfor i := range cmds.s {\n\t\tcmds.s[i] = CT(client.B().Get().Key(keys[i]).Cache(), ttl)\n\t}\n\treturn doMultiCache(client, ctx, cmds.s, keys)\n}\n\nfunc isCacheDisabled(client Client) bool {\n\tswitch c := client.(type) {\n\tcase *singleClient:\n\t\treturn c.DisableCache\n\tcase *sentinelClient:\n\t\treturn c.mOpt != nil && c.mOpt.DisableCache\n\tcase *clusterClient:\n\t\treturn c.opt != nil && c.opt.DisableCache\n\t}\n\treturn false\n}\n\n// MGet is a helper that consults the redis directly with multiple keys by grouping keys within same slot into MGET or multiple GETs\nfunc MGet(client Client, ctx context.Context, keys []string) (ret map[string]RedisMessage, err error) {\n\tif len(keys) == 0 {\n\t\treturn make(map[string]RedisMessage), nil\n\t}\n\n\tswitch client.(type) {\n\tcase *singleClient, *sentinelClient:\n\t\treturn clientMGet(client, ctx, client.B().Mget().Key(keys...).Build(), keys)\n\t}\n\n\tcmds := mgetcmdsp.Get(len(keys), len(keys))\n\tdefer mgetcmdsp.Put(cmds)\n\tfor i := range cmds.s {\n\t\tcmds.s[i] = client.B().Get().Key(keys[i]).Build()\n\t}\n\treturn doMultiGet(client, ctx, cmds.s, keys)\n}\n\n// MSet is a helper that consults the redis directly with multiple keys by grouping keys within same slot into MSETs or multiple SETs\nfunc MSet(client Client, ctx context.Context, kvs map[string]string) map[string]error {\n\tif len(kvs) == 0 {\n\t\treturn make(map[string]error)\n\t}\n\n\tswitch client.(type) {\n\tcase *singleClient, *sentinelClient:\n\t\treturn clientMSet(client, ctx, \"MSET\", kvs, make(map[string]error, len(kvs)))\n\t}\n\n\tcmds := mgetcmdsp.Get(0, len(kvs))\n\tdefer mgetcmdsp.Put(cmds)\n\tfor k, v := range kvs {\n\t\tcmds.s = append(cmds.s, client.B().Set().Key(k).Value(v).Build().Pin())\n\t}\n\treturn doMultiSet(client, ctx, cmds.s)\n}\n\n// MDel is a helper that consults the redis directly with multiple keys by grouping keys within same slot into DELs\nfunc MDel(client Client, ctx context.Context, keys []string) map[string]error {\n\tif len(keys) == 0 {\n\t\treturn make(map[string]error)\n\t}\n\n\tswitch client.(type) {\n\tcase *singleClient, *sentinelClient:\n\t\treturn clientMDel(client, ctx, keys)\n\t}\n\n\tcmds := mgetcmdsp.Get(len(keys), len(keys))\n\tdefer mgetcmdsp.Put(cmds)\n\tfor i, k := range keys {\n\t\tcmds.s[i] = client.B().Del().Key(k).Build().Pin()\n\t}\n\treturn doMultiSet(client, ctx, cmds.s)\n}\n\n// MSetNX is a helper that consults the redis directly with multiple keys by grouping keys within same slot into MSETNXs or multiple SETNXs\nfunc MSetNX(client Client, ctx context.Context, kvs map[string]string) map[string]error {\n\tif len(kvs) == 0 {\n\t\treturn make(map[string]error)\n\t}\n\n\tswitch client.(type) {\n\tcase *singleClient, *sentinelClient:\n\t\treturn clientMSet(client, ctx, \"MSETNX\", kvs, make(map[string]error, len(kvs)))\n\t}\n\n\tcmds := mgetcmdsp.Get(0, len(kvs))\n\tdefer mgetcmdsp.Put(cmds)\n\tfor k, v := range kvs {\n\t\tcmds.s = append(cmds.s, client.B().Set().Key(k).Value(v).Nx().Build().Pin())\n\t}\n\treturn doMultiSet(client, ctx, cmds.s)\n}\n\n// JsonMGetCache is a helper that consults the client-side caches with multiple keys by grouping keys within same slot into multiple JSON.GETs\nfunc JsonMGetCache(client Client, ctx context.Context, ttl time.Duration, keys []string, path string) (ret map[string]RedisMessage, err error) {\n\tif len(keys) == 0 {\n\t\treturn make(map[string]RedisMessage), nil\n\t}\n\tcmds := mgetcachecmdsp.Get(len(keys), len(keys))\n\tdefer mgetcachecmdsp.Put(cmds)\n\tfor i := range cmds.s {\n\t\tcmds.s[i] = CT(client.B().JsonGet().Key(keys[i]).Path(path).Cache(), ttl)\n\t}\n\treturn doMultiCache(client, ctx, cmds.s, keys)\n}\n\n// JsonMGet is a helper that consults redis directly with multiple keys by grouping keys within same slot into JSON.MGETs or multiple JSON.GETs\nfunc JsonMGet(client Client, ctx context.Context, keys []string, path string) (ret map[string]RedisMessage, err error) {\n\tif len(keys) == 0 {\n\t\treturn make(map[string]RedisMessage), nil\n\t}\n\n\tswitch client.(type) {\n\tcase *singleClient, *sentinelClient:\n\t\treturn clientMGet(client, ctx, client.B().JsonMget().Key(keys...).Path(path).Build(), keys)\n\t}\n\n\tcmds := mgetcmdsp.Get(len(keys), len(keys))\n\tdefer mgetcmdsp.Put(cmds)\n\tfor i := range cmds.s {\n\t\tcmds.s[i] = client.B().JsonGet().Key(keys[i]).Path(path).Build()\n\t}\n\treturn doMultiGet(client, ctx, cmds.s, keys)\n}\n\n// JsonMSet is a helper that consults redis directly with multiple keys by grouping keys within same slot into JSON.MSETs or multiple JOSN.SETs\nfunc JsonMSet(client Client, ctx context.Context, kvs map[string]string, path string) map[string]error {\n\tif len(kvs) == 0 {\n\t\treturn make(map[string]error)\n\t}\n\n\tswitch client.(type) {\n\tcase *singleClient, *sentinelClient:\n\t\treturn clientJSONMSet(client, ctx, kvs, path, make(map[string]error, len(kvs)))\n\t}\n\n\tcmds := mgetcmdsp.Get(0, len(kvs))\n\tdefer mgetcmdsp.Put(cmds)\n\tfor k, v := range kvs {\n\t\tcmds.s = append(cmds.s, client.B().JsonSet().Key(k).Path(path).Value(v).Build().Pin())\n\t}\n\treturn doMultiSet(client, ctx, cmds.s)\n}\n\n// DecodeSliceOfJSON is a helper that struct-scans each RedisMessage into dest, which must be a slice of pointer.\nfunc DecodeSliceOfJSON[T any](result RedisResult, dest *[]T) error {\n\tvalues, err := result.ToArray()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tts := make([]T, len(values))\n\tfor i, v := range values {\n\t\tvar t T\n\t\tif err = v.DecodeJSON(&t); err != nil {\n\t\t\tif IsRedisNil(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tts[i] = t\n\t}\n\t*dest = ts\n\treturn nil\n}\n\nfunc clientMGet(client Client, ctx context.Context, cmd Completed, keys []string) (ret map[string]RedisMessage, err error) {\n\tarr, err := client.Do(ctx, cmd).ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn arrayToKV(make(map[string]RedisMessage, len(keys)), arr, keys), nil\n}\n\nfunc clientMSet(client Client, ctx context.Context, mset string, kvs map[string]string, ret map[string]error) map[string]error {\n\tcmd := client.B().Arbitrary(mset)\n\tfor k, v := range kvs {\n\t\tcmd = cmd.Args(k, v)\n\t}\n\tok, err := client.Do(ctx, cmd.Build()).AsBool()\n\tif err == nil && !ok {\n\t\terr = ErrMSetNXNotSet\n\t}\n\tfor k := range kvs {\n\t\tret[k] = err\n\t}\n\treturn ret\n}\n\nfunc clientJSONMSet(client Client, ctx context.Context, kvs map[string]string, path string, ret map[string]error) map[string]error {\n\tcmd := intl.JsonMsetTripletValue(client.B().JsonMset())\n\tfor k, v := range kvs {\n\t\tcmd = cmd.Key(k).Path(path).Value(v)\n\t}\n\terr := client.Do(ctx, cmd.Build()).Error()\n\tfor k := range kvs {\n\t\tret[k] = err\n\t}\n\treturn ret\n}\n\nfunc clientMDel(client Client, ctx context.Context, keys []string) map[string]error {\n\terr := client.Do(ctx, client.B().Del().Key(keys...).Build()).Error()\n\tret := make(map[string]error, len(keys))\n\tfor _, k := range keys {\n\t\tret[k] = err\n\t}\n\treturn ret\n}\n\nfunc doMultiCache(cc Client, ctx context.Context, cmds []CacheableTTL, keys []string) (ret map[string]RedisMessage, err error) {\n\tret = make(map[string]RedisMessage, len(keys))\n\tresps := cc.DoMultiCache(ctx, cmds...)\n\tdefer resultsp.Put(&redisresults{s: resps})\n\tfor i, resp := range resps {\n\t\tif err := resp.NonRedisError(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tret[keys[i]] = resp.val\n\t}\n\treturn ret, nil\n}\n\nfunc doMultiGet(cc Client, ctx context.Context, cmds []Completed, keys []string) (ret map[string]RedisMessage, err error) {\n\tret = make(map[string]RedisMessage, len(keys))\n\tresps := cc.DoMulti(ctx, cmds...)\n\tdefer resultsp.Put(&redisresults{s: resps})\n\tfor i, resp := range resps {\n\t\tif err := resp.NonRedisError(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tret[keys[i]] = resp.val\n\t}\n\treturn ret, nil\n}\n\nfunc doMultiSet(cc Client, ctx context.Context, cmds []Completed) (ret map[string]error) {\n\tret = make(map[string]error, len(cmds))\n\tresps := cc.DoMulti(ctx, cmds...)\n\tfor i, resp := range resps {\n\t\tif ret[cmds[i].Commands()[1]] = resp.Error(); resp.NonRedisError() == nil {\n\t\t\tintl.PutCompletedForce(cmds[i])\n\t\t}\n\t}\n\tresultsp.Put(&redisresults{s: resps})\n\treturn ret\n}\n\nfunc arrayToKV(m map[string]RedisMessage, arr []RedisMessage, keys []string) map[string]RedisMessage {\n\tfor i, resp := range arr {\n\t\tm[keys[i]] = resp\n\t}\n\treturn m\n}\n\n// ErrMSetNXNotSet is used in the MSetNX helper when the underlying MSETNX response is 0.\n// Ref: https://redis.io/commands/msetnx/\nvar ErrMSetNXNotSet = errors.New(\"MSETNX: no key was set\")\n"
        },
        {
          "name": "helper_test.go",
          "type": "blob",
          "size": 33.423828125,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n)\n\n//gocyclo:ignore\nfunc TestMGetCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tdisabledCacheClient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}, DisableCache: true},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate DisabledCache MGetCache\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"MGET\", \"1\", \"2\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"1\"}, {typ: '+', string: \"2\"}}}, nil)\n\t\t\t}\n\t\t\tif v, err := MGetCache(disabledCacheClient, context.Background(), 100, []string{\"1\", \"2\"}); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tif reflect.DeepEqual(multi[0].Cmd.Commands(), []string{\"GET\", \"1\"}) && multi[0].TTL == 100 &&\n\t\t\t\t\treflect.DeepEqual(multi[1].Cmd.Commands(), []string{\"GET\", \"2\"}) && multi[1].TTL == 100 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"2\"}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"unexpected command %v\", multi)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif v, err := MGetCache(client, context.Background(), 100, []string{\"1\", \"2\"}); err != nil || v[\"1\"].string != \"1\" || v[\"2\"].string != \"2\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Empty\", func(t *testing.T) {\n\t\t\tif v, err := MGetCache(client, context.Background(), 100, []string{}); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{}, context.Canceled), newResult(RedisMessage{}, context.Canceled)}}\n\t\t\t}\n\t\t\tif v, err := MGetCache(client, ctx, 100, []string{\"1\", \"2\"}); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tdisabledCacheClient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}, DisableCache: true},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate DisabledCache DoCache\", func(t *testing.T) {\n\t\t\tkeys := make([]string, 100)\n\t\t\tfor i := range keys {\n\t\t\t\tkeys[i] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, key := range keys {\n\t\t\t\t\tif !reflect.DeepEqual(cmd[i].Commands(), []string{\"GET\", key}) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: key}, nil)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tv, err := MGetCache(disabledCacheClient, context.Background(), 100, keys)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tfor _, key := range keys {\n\t\t\t\tif v[key].string != key {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\t\tkeys := make([]string, 100)\n\t\t\tfor i := range keys {\n\t\t\t\tkeys[i] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(multi))\n\t\t\t\tfor i, key := range keys {\n\t\t\t\t\tif !reflect.DeepEqual(multi[i].Cmd.Commands(), []string{\"GET\", key}) || multi[i].TTL != 100 {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", multi)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: key}, nil)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tv, err := MGetCache(client, context.Background(), 100, keys)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tfor _, key := range keys {\n\t\t\t\tif v[key].string != key {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Empty\", func(t *testing.T) {\n\t\t\tif v, err := MGetCache(client, context.Background(), 100, []string{}); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(multi))\n\t\t\t\tfor i := range result {\n\t\t\t\t\tresult[i] = newErrResult(context.Canceled)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tif v, err := MGetCache(client, ctx, 100, []string{\"1\", \"2\"}); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n}\n\n//gocyclo:ignore\nfunc TestMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"MGET\", \"1\", \"2\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"1\"}, {typ: '+', string: \"2\"}}}, nil)\n\t\t\t}\n\t\t\tif v, err := MGet(client, context.Background(), []string{\"1\", \"2\"}); err != nil || v[\"1\"].string != \"1\" || v[\"2\"].string != \"2\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif v, err := MGet(client, context.Background(), []string{}); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{}, context.Canceled)\n\t\t\t}\n\t\t\tif v, err := MGet(client, ctx, []string{\"1\", \"2\"}); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tkeys := make([]string, 100)\n\t\t\tfor i := range keys {\n\t\t\t\tkeys[i] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, key := range keys {\n\t\t\t\t\tif !reflect.DeepEqual(cmd[i].Commands(), []string{\"GET\", key}) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: key}, nil)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tv, err := MGet(client, context.Background(), keys)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tfor _, key := range keys {\n\t\t\t\tif v[key].string != key {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif v, err := MGet(client, context.Background(), []string{}); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.Canceled), newErrResult(context.Canceled)}}\n\t\t\t}\n\t\t\tif v, err := MGet(client, ctx, []string{\"1\", \"2\"}); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n}\n\n//gocyclo:ignore\nfunc TestMDel(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"DEL\", \"1\", \"2\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: ':', integer: 2}, nil)\n\t\t\t}\n\t\t\tif v := MDel(client, context.Background(), []string{\"1\", \"2\"}); v[\"1\"] != nil || v[\"2\"] != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif v := MDel(client, context.Background(), []string{}); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{}, context.Canceled)\n\t\t\t}\n\t\t\tif v := MDel(client, ctx, []string{\"1\", \"2\"}); v[\"1\"] != context.Canceled || v[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tkeys := make([]string, 100)\n\t\t\tfor i := range keys {\n\t\t\t\tkeys[i] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, key := range keys {\n\t\t\t\t\tif !reflect.DeepEqual(cmd[i].Commands(), []string{\"DEL\", key}) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: ':', integer: 1}, nil)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tv := MDel(client, context.Background(), keys)\n\t\t\tfor _, key := range keys {\n\t\t\t\tif v[key] != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif v := MDel(client, context.Background(), []string{}); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.Canceled), newErrResult(context.Canceled)}}\n\t\t\t}\n\t\t\tif v := MDel(client, ctx, []string{\"1\", \"2\"}); v[\"1\"] != context.Canceled || v[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestMSet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"MSET\", \"1\", \"1\", \"2\", \"2\"}) &&\n\t\t\t\t\t!reflect.DeepEqual(cmd.Commands(), []string{\"MSET\", \"2\", \"2\", \"1\", \"1\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t}\n\t\t\tif err := MSet(client, context.Background(), map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != nil || err[\"2\"] != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif err := MSet(client, context.Background(), map[string]string{}); len(err) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{}, context.Canceled)\n\t\t\t}\n\t\t\tif err := MSet(client, ctx, map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != context.Canceled || err[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tkeys := make(map[string]string, 100)\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tkeys[strconv.Itoa(i)] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tcpy := make(map[string]struct{}, len(keys))\n\t\t\tfor k := range keys {\n\t\t\t\tcpy[k] = struct{}{}\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, c := range cmd {\n\t\t\t\t\tdelete(cpy, c.Commands()[1])\n\t\t\t\t\tif c.Commands()[0] != \"SET\" || keys[c.Commands()[1]] != c.Commands()[2] {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t}\n\t\t\t\tif len(cpy) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\terr := MSet(client, context.Background(), keys)\n\t\t\tfor key := range keys {\n\t\t\t\tif err[key] != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif err := MSet(client, context.Background(), map[string]string{}); len(err) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.Canceled), newErrResult(context.Canceled)}}\n\t\t\t}\n\t\t\tif err := MSet(client, ctx, map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != context.Canceled || err[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestMSetNX(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"MSETNX\", \"1\", \"1\", \"2\", \"2\"}) &&\n\t\t\t\t\t!reflect.DeepEqual(cmd.Commands(), []string{\"MSETNX\", \"2\", \"2\", \"1\", \"1\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t}\n\t\t\tif err := MSetNX(client, context.Background(), map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != nil || err[\"2\"] != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif err := MSetNX(client, context.Background(), map[string]string{}); len(err) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{}, context.Canceled)\n\t\t\t}\n\t\t\tif err := MSetNX(client, ctx, map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != context.Canceled || err[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tkeys := make(map[string]string, 100)\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tkeys[strconv.Itoa(i)] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tcpy := make(map[string]struct{}, len(keys))\n\t\t\tfor k := range keys {\n\t\t\t\tcpy[k] = struct{}{}\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, c := range cmd {\n\t\t\t\t\tdelete(cpy, c.Commands()[1])\n\t\t\t\t\tif c.Commands()[0] != \"SET\" || c.Commands()[3] != \"NX\" || keys[c.Commands()[1]] != c.Commands()[2] {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t}\n\t\t\t\tif len(cpy) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\terr := MSetNX(client, context.Background(), keys)\n\t\t\tfor key := range keys {\n\t\t\t\tif err[key] != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif err := MSetNX(client, context.Background(), map[string]string{}); len(err) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.Canceled), newErrResult(context.Canceled)}}\n\t\t\t}\n\t\t\tif err := MSetNX(client, ctx, map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != context.Canceled || err[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestMSetNXNotSet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do Not Set\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: ':', integer: 0}, nil)\n\t\t\t}\n\t\t\tif err := MSetNX(client, context.Background(), map[string]string{\"1\": \"1\", \"2\": \"2\"}); err[\"1\"] != ErrMSetNXNotSet || err[\"2\"] != ErrMSetNXNotSet {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n}\n\n//gocyclo:ignore\nfunc TestJsonMGetCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tif reflect.DeepEqual(multi[0].Cmd.Commands(), []string{\"JSON.GET\", \"1\", \"$\"}) && multi[0].TTL == 100 &&\n\t\t\t\t\treflect.DeepEqual(multi[1].Cmd.Commands(), []string{\"JSON.GET\", \"2\", \"$\"}) && multi[1].TTL == 100 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"1\"}, nil),\n\t\t\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"2\"}, nil),\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"unexpected command %v\", multi)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif v, err := JsonMGetCache(client, context.Background(), 100, []string{\"1\", \"2\"}, \"$\"); err != nil || v[\"1\"].string != \"1\" || v[\"2\"].string != \"2\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Empty\", func(t *testing.T) {\n\t\t\tif v, err := JsonMGetCache(client, context.Background(), 100, []string{}, \"$\"); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{}, context.Canceled), newResult(RedisMessage{}, context.Canceled)}}\n\t\t\t}\n\t\t\tif v, err := JsonMGetCache(client, ctx, 100, []string{\"1\", \"2\"}, \"$\"); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\t\tkeys := make([]string, 100)\n\t\t\tfor i := range keys {\n\t\t\t\tkeys[i] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(multi))\n\t\t\t\tfor i, key := range keys {\n\t\t\t\t\tif !reflect.DeepEqual(multi[i].Cmd.Commands(), []string{\"JSON.GET\", key, \"$\"}) || multi[i].TTL != 100 {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", multi)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: key}, nil)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tv, err := JsonMGetCache(client, context.Background(), 100, keys, \"$\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tfor _, key := range keys {\n\t\t\t\tif v[key].string != key {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Empty\", func(t *testing.T) {\n\t\t\tif v, err := JsonMGetCache(client, context.Background(), 100, []string{}, \"$\"); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate DoCache Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(multi))\n\t\t\t\tfor i := range result {\n\t\t\t\t\tresult[i] = newErrResult(context.Canceled)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tif v, err := JsonMGetCache(client, ctx, 100, []string{\"1\", \"2\"}, \"$\"); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n}\n\n//gocyclo:ignore\nfunc TestJsonMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"JSON.MGET\", \"1\", \"2\", \"$\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"1\"}, {typ: '+', string: \"2\"}}}, nil)\n\t\t\t}\n\t\t\tif v, err := JsonMGet(client, context.Background(), []string{\"1\", \"2\"}, \"$\"); err != nil || v[\"1\"].string != \"1\" || v[\"2\"].string != \"2\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif v, err := JsonMGet(client, context.Background(), []string{}, \"$\"); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{}, context.Canceled)\n\t\t\t}\n\t\t\tif v, err := JsonMGet(client, ctx, []string{\"1\", \"2\"}, \"$\"); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tkeys := make([]string, 100)\n\t\t\tfor i := range keys {\n\t\t\t\tkeys[i] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, key := range keys {\n\t\t\t\t\tif !reflect.DeepEqual(cmd[i].Commands(), []string{\"JSON.GET\", key, \"$\"}) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: key}, nil)\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\tv, err := JsonMGet(client, context.Background(), keys, \"$\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tfor _, key := range keys {\n\t\t\t\tif v[key].string != key {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif v, err := JsonMGet(client, context.Background(), []string{}, \"$\"); err != nil || v == nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.Canceled), newErrResult(context.Canceled)}}\n\t\t\t}\n\t\t\tif v, err := JsonMGet(client, ctx, []string{\"1\", \"2\"}, \"$\"); err != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestJsonMSet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"single client\", func(t *testing.T) {\n\t\tm := &mockConn{}\n\t\tclient, err := newSingleClient(\n\t\t\t&ClientOption{InitAddress: []string{\"\"}},\n\t\t\tm,\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\tif !reflect.DeepEqual(cmd.Commands(), []string{\"JSON.MSET\", \"1\", \"$\", \"1\", \"2\", \"$\", \"2\"}) &&\n\t\t\t\t\t!reflect.DeepEqual(cmd.Commands(), []string{\"JSON.MSET\", \"2\", \"$\", \"2\", \"1\", \"$\", \"1\"}) {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t}\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t}\n\t\t\tif err := JsonMSet(client, context.Background(), map[string]string{\"1\": \"1\", \"2\": \"2\"}, \"$\"); err[\"1\"] != nil || err[\"2\"] != nil {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif err := JsonMSet(client, context.Background(), map[string]string{}, \"$\"); len(err) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{}, context.Canceled)\n\t\t\t}\n\t\t\tif err := JsonMSet(client, ctx, map[string]string{\"1\": \"1\", \"2\": \"2\"}, \"$\"); err[\"1\"] != context.Canceled || err[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"cluster client\", func(t *testing.T) {\n\t\tm := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn slotsResp\n\t\t\t},\n\t\t}\n\t\tclient, err := newClusterClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return m },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\t\tkeys := make(map[string]string, 100)\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tkeys[strconv.Itoa(i)] = strconv.Itoa(i)\n\t\t\t}\n\t\t\tcpy := make(map[string]struct{}, len(keys))\n\t\t\tfor k := range keys {\n\t\t\t\tcpy[k] = struct{}{}\n\t\t\t}\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\tresult := make([]RedisResult, len(cmd))\n\t\t\t\tfor i, c := range cmd {\n\t\t\t\t\tdelete(cpy, c.Commands()[1])\n\t\t\t\t\tif c.Commands()[0] != \"JSON.SET\" || keys[c.Commands()[1]] != c.Commands()[3] || c.Commands()[2] != \"$\" {\n\t\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tresult[i] = newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t}\n\t\t\t\tif len(cpy) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: result}\n\t\t\t}\n\t\t\terr := JsonMSet(client, context.Background(), keys, \"$\")\n\t\t\tfor key := range keys {\n\t\t\t\tif err[key] != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Empty\", func(t *testing.T) {\n\t\t\tif err := JsonMSet(client, context.Background(), map[string]string{}, \"$\"); len(err) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"Delegate Do Err\", func(t *testing.T) {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.Canceled), newErrResult(context.Canceled)}}\n\t\t\t}\n\t\t\tif err := JsonMSet(client, ctx, map[string]string{\"1\": \"1\", \"2\": \"2\"}, \"$\"); err[\"1\"] != context.Canceled || err[\"2\"] != context.Canceled {\n\t\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestDecodeSliceOfJSON(t *testing.T) {\n\ttype Inner struct {\n\t\tField string\n\t}\n\ttype T struct {\n\t\tID     int\n\t\tName   string\n\t\tInners []*Inner\n\t}\n\tvalues := []RedisMessage{\n\t\t{string: `{\"ID\":1, \"Name\": \"n1\", \"Inners\": [{\"Field\": \"f1\"}]}`, typ: '+'},\n\t\t{string: `{\"ID\":2, \"Name\": \"n2\", \"Inners\": [{\"Field\": \"f2\"}]}`, typ: '+'},\n\t}\n\tresult := RedisResult{val: RedisMessage{typ: '*', values: values}}\n\n\tt.Run(\"Scan []*T\", func(t *testing.T) {\n\t\tgot := make([]*T, 0)\n\t\twant := []*T{\n\t\t\t{ID: 1, Name: \"n1\", Inners: []*Inner{{Field: \"f1\"}}},\n\t\t\t{ID: 2, Name: \"n2\", Inners: []*Inner{{Field: \"f2\"}}},\n\t\t}\n\t\tif err := DecodeSliceOfJSON(result, &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !reflect.DeepEqual(want, got) {\n\t\t\tt.Fatalf(\"DecodeSliceOfJSON not get value as expected %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"Scan []T\", func(t *testing.T) {\n\t\tgot := make([]T, 0)\n\t\twant := []T{\n\t\t\t{ID: 1, Name: \"n1\", Inners: []*Inner{{Field: \"f1\"}}},\n\t\t\t{ID: 2, Name: \"n2\", Inners: []*Inner{{Field: \"f2\"}}},\n\t\t}\n\t\tif err := DecodeSliceOfJSON(result, &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !reflect.DeepEqual(want, got) {\n\t\t\tt.Fatalf(\"DecodeSliceOfJSON not get value as expected %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"Scan []*T: has nil error message\", func(t *testing.T) {\n\t\thasNilValues := []RedisMessage{\n\t\t\t{string: `{\"ID\":1, \"Name\": \"n1\", \"Inners\": [{\"Field\": \"f1\"}]}`, typ: '+'},\n\t\t\t{typ: '_'},\n\t\t\t{string: `{\"ID\":2, \"Name\": \"n2\", \"Inners\": [{\"Field\": \"f2\"}]}`, typ: '+'},\n\t\t}\n\t\thasNilResult := RedisResult{val: RedisMessage{typ: '*', values: hasNilValues}}\n\n\t\tgot := make([]*T, 0)\n\t\twant := []*T{\n\t\t\t{ID: 1, Name: \"n1\", Inners: []*Inner{{Field: \"f1\"}}},\n\t\t\tnil,\n\t\t\t{ID: 2, Name: \"n2\", Inners: []*Inner{{Field: \"f2\"}}},\n\t\t}\n\t\tif err := DecodeSliceOfJSON(hasNilResult, &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !reflect.DeepEqual(want, got) {\n\t\t\tt.Fatalf(\"DecodeSliceOfJSON not get value as expected %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"Scan []T: has nil error message\", func(t *testing.T) {\n\t\thasNilValues := []RedisMessage{\n\t\t\t{string: `{\"ID\":1, \"Name\": \"n1\", \"Inners\": [{\"Field\": \"f1\"}]}`, typ: '+'},\n\t\t\t{typ: '_'},\n\t\t\t{string: `{\"ID\":2, \"Name\": \"n2\", \"Inners\": [{\"Field\": \"f2\"}]}`, typ: '+'},\n\t\t}\n\t\thasNilResult := RedisResult{val: RedisMessage{typ: '*', values: hasNilValues}}\n\n\t\tgot := make([]T, 0)\n\t\twant := []T{\n\t\t\t{ID: 1, Name: \"n1\", Inners: []*Inner{{Field: \"f1\"}}},\n\t\t\t{ID: 0, Name: \"\", Inners: nil},\n\t\t\t{ID: 2, Name: \"n2\", Inners: []*Inner{{Field: \"f2\"}}},\n\t\t}\n\t\tif err := DecodeSliceOfJSON(hasNilResult, &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !reflect.DeepEqual(want, got) {\n\t\t\tt.Fatalf(\"DecodeSliceOfJSON not get value as expected %v\", got)\n\t\t}\n\t})\n\n\tt.Run(\"error result\", func(t *testing.T) {\n\t\tif err := DecodeSliceOfJSON(RedisResult{val: RedisMessage{typ: '-'}}, &[]*T{}); err == nil {\n\t\t\tt.Fatal(\"DecodeSliceOfJSON not failed as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"has non-nil error message in result\", func(t *testing.T) {\n\t\thasErrValues := []RedisMessage{\n\t\t\t{string: `{\"ID\":1, \"Name\": \"n1\", \"Inners\": [{\"Field\": \"f1\"}]}`, typ: '+'},\n\t\t\t{string: `invalid`, typ: '-'},\n\t\t}\n\t\thasErrResult := RedisResult{val: RedisMessage{typ: '*', values: hasErrValues}}\n\n\t\tgot := make([]*T, 0)\n\t\tif err := DecodeSliceOfJSON(hasErrResult, &got); err == nil {\n\t\t\tt.Fatal(\"DecodeSliceOfJSON not failed as expected\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "lru.go",
          "type": "blob",
          "size": 6.9716796875,
          "content": "package rueidis\n\nimport (\n\t\"container/list\"\n\t\"context\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\nconst (\n\tentrySize    = int(unsafe.Sizeof(cacheEntry{})) + int(unsafe.Sizeof(&cacheEntry{}))\n\tkeyCacheSize = int(unsafe.Sizeof(keyCache{})) + int(unsafe.Sizeof(&keyCache{}))\n\telementSize  = int(unsafe.Sizeof(list.Element{})) + int(unsafe.Sizeof(&list.Element{}))\n\tstringSSize  = int(unsafe.Sizeof(\"\"))\n\n\tentryBaseSize = (keyCacheSize + entrySize + elementSize + stringSSize*2) * 3 / 2\n\tentryMinSize  = entryBaseSize + messageStructSize\n\n\tmoveThreshold = uint32(1024 - 1)\n)\n\ntype cacheEntry struct {\n\terr  error\n\tch   chan struct{}\n\tkc   *keyCache\n\tcmd  string\n\tval  RedisMessage\n\tsize int\n}\n\nfunc (e *cacheEntry) Wait(ctx context.Context) (RedisMessage, error) {\n\tif ch := ctx.Done(); ch == nil {\n\t\t<-e.ch\n\t} else {\n\t\tselect {\n\t\tcase <-ch:\n\t\t\treturn RedisMessage{}, ctx.Err()\n\t\tcase <-e.ch:\n\t\t}\n\t}\n\treturn e.val, e.err\n}\n\ntype keyCache struct {\n\tcache map[string]*list.Element\n\tkey   string\n\thits  uint32\n\tmiss  uint32\n}\n\nvar _ CacheStore = (*lru)(nil)\n\ntype lru struct {\n\tstore map[string]*keyCache\n\tlist  *list.List\n\tmu    sync.RWMutex\n\tsize  int\n\tmax   int\n}\n\nfunc newLRU(opt CacheStoreOption) CacheStore {\n\treturn &lru{\n\t\tmax:   opt.CacheSizeEachConn,\n\t\tstore: make(map[string]*keyCache),\n\t\tlist:  list.New(),\n\t}\n}\n\nfunc (c *lru) Flight(key, cmd string, ttl time.Duration, now time.Time) (v RedisMessage, ce CacheEntry) {\n\tvar ok bool\n\tvar kc *keyCache\n\tvar ele, back *list.Element\n\tvar e *cacheEntry\n\n\tc.mu.RLock()\n\tif kc, ok = c.store[key]; ok {\n\t\tif ele = kc.cache[cmd]; ele != nil {\n\t\t\te = ele.Value.(*cacheEntry)\n\t\t\tv = e.val\n\t\t\tback = c.list.Back()\n\t\t}\n\t}\n\tc.mu.RUnlock()\n\n\tif e != nil && (v.typ == 0 || v.relativePTTL(now) > 0) {\n\t\thits := atomic.AddUint32(&kc.hits, 1)\n\t\tif ele != back && hits&moveThreshold == 0 {\n\t\t\tc.mu.Lock()\n\t\t\tif c.list != nil {\n\t\t\t\tc.list.MoveToBack(ele)\n\t\t\t}\n\t\t\tc.mu.Unlock()\n\t\t}\n\t\treturn v, e\n\t}\n\n\tv = RedisMessage{}\n\te = nil\n\n\tc.mu.Lock()\n\tif kc, ok = c.store[key]; !ok {\n\t\tif c.store == nil {\n\t\t\tgoto ret\n\t\t}\n\t\tkc = &keyCache{cache: make(map[string]*list.Element, 1), key: key}\n\t\tc.store[key] = kc\n\t}\n\tif ele = kc.cache[cmd]; ele != nil {\n\t\tif e = ele.Value.(*cacheEntry); e.val.typ == 0 || e.val.relativePTTL(now) > 0 {\n\t\t\tatomic.AddUint32(&kc.hits, 1)\n\t\t\tv = e.val\n\t\t\tc.list.MoveToBack(ele)\n\t\t\tce = e\n\t\t\tgoto ret\n\t\t} else {\n\t\t\tc.list.Remove(ele)\n\t\t\tc.size -= e.size\n\t\t}\n\t}\n\tatomic.AddUint32(&kc.miss, 1)\n\tv.setExpireAt(now.Add(ttl).UnixMilli())\n\tkc.cache[cmd] = c.list.PushBack(&cacheEntry{cmd: cmd, kc: kc, val: v, ch: make(chan struct{})})\nret:\n\tc.mu.Unlock()\n\treturn v, ce\n}\n\nfunc (c *lru) Flights(now time.Time, multi []CacheableTTL, results []RedisResult, entries map[int]CacheEntry) (missed []int) {\n\tvar moves []*list.Element\n\n\tc.mu.RLock()\n\tfor i, ct := range multi {\n\t\tkey, cmd := cmds.CacheKey(ct.Cmd)\n\t\tif kc, ok := c.store[key]; ok {\n\t\t\tif ele := kc.cache[cmd]; ele != nil {\n\t\t\t\te := ele.Value.(*cacheEntry)\n\t\t\t\tv := e.val\n\t\t\t\tif v.typ == 0 {\n\t\t\t\t\tentries[i] = e\n\t\t\t\t} else if v.relativePTTL(now) > 0 {\n\t\t\t\t\tresults[i] = newResult(v, nil)\n\t\t\t\t} else {\n\t\t\t\t\tgoto miss1\n\t\t\t\t}\n\t\t\t\tif atomic.AddUint32(&kc.hits, 1)&moveThreshold == 0 {\n\t\t\t\t\tif moves == nil {\n\t\t\t\t\t\tmoves = make([]*list.Element, 0, len(multi))\n\t\t\t\t\t}\n\t\t\t\t\tmoves = append(moves, ele)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\tmiss1:\n\t\tif missed == nil {\n\t\t\tmissed = make([]int, 0, len(multi))\n\t\t}\n\t\tmissed = append(missed, i)\n\t}\n\tc.mu.RUnlock()\n\n\tif len(moves) > 0 {\n\t\tc.mu.Lock()\n\t\tif c.list != nil {\n\t\t\tfor _, ele := range moves {\n\t\t\t\tc.list.MoveToBack(ele)\n\t\t\t}\n\t\t}\n\t\tc.mu.Unlock()\n\t}\n\n\tif len(missed) == 0 {\n\t\treturn missed\n\t}\n\n\tj := 0\n\tc.mu.Lock()\n\tif c.store == nil {\n\t\tc.mu.Unlock()\n\t\treturn missed\n\t}\n\tfor _, i := range missed {\n\t\tkey, cmd := cmds.CacheKey(multi[i].Cmd)\n\t\tkc, ok := c.store[key]\n\t\tif !ok {\n\t\t\tkc = &keyCache{cache: make(map[string]*list.Element, 1), key: key}\n\t\t\tc.store[key] = kc\n\t\t}\n\t\tif ele := kc.cache[cmd]; ele != nil {\n\t\t\te := ele.Value.(*cacheEntry)\n\t\t\tv := e.val\n\t\t\tif v.typ == 0 {\n\t\t\t\tentries[i] = e\n\t\t\t} else if v.relativePTTL(now) > 0 {\n\t\t\t\tresults[i] = newResult(v, nil)\n\t\t\t} else {\n\t\t\t\tc.list.Remove(ele)\n\t\t\t\tc.size -= e.size\n\t\t\t\tgoto miss2\n\t\t\t}\n\t\t\tatomic.AddUint32(&kc.hits, 1)\n\t\t\tc.list.MoveToBack(ele)\n\t\t\tcontinue\n\t\t}\n\tmiss2:\n\t\tatomic.AddUint32(&kc.miss, 1)\n\t\tv := RedisMessage{}\n\t\tv.setExpireAt(now.Add(multi[i].TTL).UnixMilli())\n\t\tkc.cache[cmd] = c.list.PushBack(&cacheEntry{cmd: cmd, kc: kc, val: v, ch: make(chan struct{})})\n\t\tmissed[j] = i\n\t\tj++\n\t}\n\tc.mu.Unlock()\n\treturn missed[:j]\n}\n\nfunc (c *lru) Update(key, cmd string, value RedisMessage) (pxat int64) {\n\tvar ch chan struct{}\n\tc.mu.Lock()\n\tif kc, ok := c.store[key]; ok {\n\t\tif ele := kc.cache[cmd]; ele != nil {\n\t\t\tif e := ele.Value.(*cacheEntry); e.val.typ == 0 {\n\t\t\t\tpxat = value.getExpireAt()\n\t\t\t\tcpttl := e.val.getExpireAt()\n\t\t\t\tif cpttl < pxat || pxat == 0 {\n\t\t\t\t\t// server side ttl should only shorten client side ttl\n\t\t\t\t\tpxat = cpttl\n\t\t\t\t\tvalue.setExpireAt(pxat)\n\t\t\t\t}\n\t\t\t\te.val = value\n\t\t\t\te.size = entryBaseSize + 2*(len(key)+len(cmd)) + value.approximateSize()\n\t\t\t\tc.size += e.size\n\t\t\t\tch = e.ch\n\t\t\t}\n\n\t\t\tele = c.list.Front()\n\t\t\tfor c.size > c.max && ele != nil {\n\t\t\t\tif e := ele.Value.(*cacheEntry); e.val.typ != 0 { // do not delete pending entries\n\t\t\t\t\tkc := e.kc\n\t\t\t\t\tif delete(kc.cache, e.cmd); len(kc.cache) == 0 {\n\t\t\t\t\t\tdelete(c.store, kc.key)\n\t\t\t\t\t}\n\t\t\t\t\tc.list.Remove(ele)\n\t\t\t\t\tc.size -= e.size\n\t\t\t\t}\n\t\t\t\tele = ele.Next()\n\t\t\t}\n\t\t}\n\t}\n\tc.mu.Unlock()\n\tif ch != nil {\n\t\tclose(ch)\n\t}\n\treturn\n}\n\nfunc (c *lru) Cancel(key, cmd string, err error) {\n\tvar ch chan struct{}\n\tc.mu.Lock()\n\tif kc, ok := c.store[key]; ok {\n\t\tif ele := kc.cache[cmd]; ele != nil {\n\t\t\tif e := ele.Value.(*cacheEntry); e.val.typ == 0 {\n\t\t\t\te.err = err\n\t\t\t\tch = e.ch\n\t\t\t\tif delete(kc.cache, cmd); len(kc.cache) == 0 {\n\t\t\t\t\tdelete(c.store, key)\n\t\t\t\t}\n\t\t\t\tc.list.Remove(ele)\n\t\t\t}\n\t\t}\n\t}\n\tc.mu.Unlock()\n\tif ch != nil {\n\t\tclose(ch)\n\t}\n}\n\nfunc (c *lru) GetTTL(key, cmd string) (ttl time.Duration) {\n\tc.mu.Lock()\n\tif kc, ok := c.store[key]; ok && kc.cache[cmd] != nil {\n\t\tttl = time.Duration(kc.cache[cmd].Value.(*cacheEntry).val.relativePTTL(time.Now())) * time.Millisecond\n\t}\n\tif ttl <= 0 {\n\t\tttl = -2\n\t}\n\tc.mu.Unlock()\n\treturn\n}\n\nfunc (c *lru) purge(key string, kc *keyCache) {\n\tif kc != nil {\n\t\tfor cmd, ele := range kc.cache {\n\t\t\tif ele != nil {\n\t\t\t\te := ele.Value.(*cacheEntry)\n\t\t\t\tif e.val.typ == 0 { // do not delete pending entries\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tc.list.Remove(ele)\n\t\t\t\tc.size -= e.size\n\t\t\t}\n\t\t\tif delete(kc.cache, cmd); len(kc.cache) == 0 {\n\t\t\t\tdelete(c.store, key)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *lru) Delete(keys []RedisMessage) {\n\tc.mu.Lock()\n\tif keys == nil {\n\t\tfor key, kc := range c.store {\n\t\t\tc.purge(key, kc)\n\t\t}\n\t} else {\n\t\tfor _, k := range keys {\n\t\t\tc.purge(k.string, c.store[k.string])\n\t\t}\n\t}\n\tc.mu.Unlock()\n}\n\nfunc (c *lru) Close(err error) {\n\tc.mu.Lock()\n\tfor _, kc := range c.store {\n\t\tfor _, ele := range kc.cache {\n\t\t\tif ele != nil {\n\t\t\t\tif e := ele.Value.(*cacheEntry); e.val.typ == 0 {\n\t\t\t\t\te.err = err\n\t\t\t\t\tclose(e.ch)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tc.store = nil\n\tc.list = nil\n\tc.mu.Unlock()\n}\n"
        },
        {
          "name": "lru_test.go",
          "type": "blob",
          "size": 17.3876953125,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\nconst PTTL = 50\nconst TTL = 100 * time.Millisecond\nconst Entries = 3\n\n//gocyclo:ignore\nfunc TestLRU(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tsetup := func(t *testing.T) *lru {\n\t\tstore := newLRU(CacheStoreOption{CacheSizeEachConn: entryMinSize * Entries})\n\t\tif v, entry := store.Flight(\"0\", \"GET\", TTL, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tm := RedisMessage{typ: '+', string: \"0\", values: []RedisMessage{{}}}\n\t\tm.setExpireAt(time.Now().Add(PTTL * time.Millisecond).UnixMilli())\n\t\tstore.Update(\"0\", \"GET\", m)\n\t\treturn store.(*lru)\n\t}\n\n\tt.Run(\"Cache Hit & Expire\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tif v, _ := lru.Flight(\"0\", \"GET\", TTL, time.Now()); v.typ == 0 {\n\t\t\tt.Fatalf(\"did not get the value from the second Flight\")\n\t\t} else if v.string != \"0\" {\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v\", v)\n\t\t}\n\t\ttime.Sleep(PTTL * time.Millisecond)\n\t\tif v, entry := lru.Flight(\"0\", \"GET\", TTL, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the Flight after pttl: %v %v\", v, entry)\n\t\t}\n\t})\n\n\tt.Run(\"Cache Should Not Expire By PTTL -2\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tif v, entry := lru.Flight(\"1\", \"GET\", TTL, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the Flight after pttl: %v %v\", v, entry)\n\t\t}\n\t\tm := RedisMessage{typ: '+', string: \"1\"}\n\t\tlru.Update(\"1\", \"GET\", m)\n\t\tif v, _ := lru.Flight(\"1\", \"GET\", TTL, time.Now()); v.typ == 0 {\n\t\t\tt.Fatalf(\"did not get the value from the second Flight\")\n\t\t} else if v.string != \"1\" {\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Cache Miss Suppress\", func(t *testing.T) {\n\t\tcount := 5000\n\t\tlru := setup(t)\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(count)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif v, _ := lru.Flight(\"1\", \"GET\", TTL, time.Now()); v.typ != 0 {\n\t\t\t\t\tt.Errorf(\"got unexpected value from the first Flight: %v\", v)\n\t\t\t\t}\n\t\t\t\tif v, _ := lru.Flight(\"2\", \"GET\", TTL, time.Now()); v.typ != 0 {\n\t\t\t\t\tt.Errorf(\"got unexpected value from the first Flight: %v\", v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\tlru.mu.RLock()\n\t\tstore1 := lru.store[\"1\"]\n\t\tstore2 := lru.store[\"2\"]\n\t\tlru.mu.RUnlock()\n\t\tif miss := atomic.LoadUint32(&store1.miss); miss != 1 {\n\t\t\tt.Fatalf(\"unexpected miss count %v\", miss)\n\t\t}\n\t\tif hits := atomic.LoadUint32(&store1.hits); hits != uint32(count-1) {\n\t\t\tt.Fatalf(\"unexpected hits count %v\", hits)\n\t\t}\n\t\tif miss := atomic.LoadUint32(&store2.miss); miss != 1 {\n\t\t\tt.Fatalf(\"unexpected miss count %v\", miss)\n\t\t}\n\t\tif hits := atomic.LoadUint32(&store2.hits); hits != uint32(count-1) {\n\t\t\tt.Fatalf(\"unexpected hits count %v\", hits)\n\t\t}\n\t})\n\n\tt.Run(\"Cache Evict\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tfor i := 1; i <= Entries; i++ {\n\t\t\tlru.Flight(strconv.Itoa(i), \"GET\", TTL, time.Now())\n\t\t\tm := RedisMessage{typ: '+', string: strconv.Itoa(i)}\n\t\t\tm.setExpireAt(time.Now().Add(PTTL * time.Millisecond).UnixMilli())\n\t\t\tlru.Update(strconv.Itoa(i), \"GET\", m)\n\t\t}\n\t\tif v, entry := lru.Flight(\"1\", \"GET\", TTL, time.Now()); v.typ != 0 {\n\t\t\tt.Fatalf(\"got evicted value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tif v, _ := lru.Flight(strconv.Itoa(Entries), \"GET\", TTL, time.Now()); v.typ == 0 {\n\t\t\tt.Fatalf(\"did not get the latest value from the Flight\")\n\t\t} else if v.string != strconv.Itoa(Entries) {\n\t\t\tt.Fatalf(\"got unexpected value from the Flight: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Cache Delete\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tlru.Delete([]RedisMessage{{string: \"0\"}})\n\t\tif v, _ := lru.Flight(\"0\", \"GET\", TTL, time.Now()); v.typ != 0 {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Cache Flush\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tfor i := 1; i < Entries; i++ {\n\t\t\tlru.Flight(strconv.Itoa(i), \"GET\", TTL, time.Now())\n\t\t\tm := RedisMessage{typ: '+', string: strconv.Itoa(i)}\n\t\t\tlru.Update(strconv.Itoa(i), \"GET\", m)\n\t\t}\n\t\tfor i := 1; i < Entries; i++ {\n\t\t\tif v, _ := lru.Flight(strconv.Itoa(i), \"GET\", TTL, time.Now()); v.string != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"got unexpected value before flush all: %v\", v)\n\t\t\t}\n\t\t}\n\t\tlru.Delete(nil)\n\t\tfor i := 1; i <= Entries; i++ {\n\t\t\tif v, _ := lru.Flight(strconv.Itoa(i), \"GET\", TTL, time.Now()); v.typ != 0 {\n\t\t\t\tt.Fatalf(\"got unexpected value after flush all: %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Cache Close\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tv, entry := lru.Flight(\"1\", \"GET\", TTL, time.Now())\n\t\tif v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tv, entry = lru.Flight(\"1\", \"GET\", TTL, time.Now())\n\t\tif v.typ != 0 || entry == nil { // entry should not be nil in second call\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v %v\", v, entry)\n\t\t}\n\n\t\tlru.Close(ErrDoCacheAborted)\n\n\t\tif _, err := entry.Wait(context.Background()); err != ErrDoCacheAborted {\n\t\t\tt.Fatalf(\"got unexpected value after Close: %v\", err)\n\t\t}\n\n\t\tm := RedisMessage{typ: '+', string: \"this Update should have no effect\"}\n\t\tm.setExpireAt(time.Now().Add(PTTL * time.Millisecond).UnixMilli())\n\t\tlru.Update(\"1\", \"GET\", m)\n\t\tfor i := 0; i < 2; i++ { // entry should be always nil after the first call if Close\n\t\t\tif v, entry := lru.Flight(\"1\", \"GET\", TTL, time.Now()); v.typ != 0 || entry != nil {\n\t\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Cache Cancel\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tv, entry := lru.Flight(\"1\", \"GET\", TTL, time.Now())\n\t\tif v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tv, entry = lru.Flight(\"1\", \"GET\", TTL, time.Now())\n\t\tif v.typ != 0 || entry == nil { // entry should not be nil in second call\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v %v\", v, entry)\n\t\t}\n\t\terr := errors.New(\"any\")\n\n\t\tgo func() {\n\t\t\tlru.Cancel(\"1\", \"GET\", err)\n\t\t}()\n\n\t\tif _, err2 := entry.Wait(context.Background()); err2 != err {\n\t\t\tt.Fatalf(\"got unexpected value from the CacheEntry.Wait(): %v %v\", err, err2)\n\t\t}\n\t})\n\n\tt.Run(\"GetTTL\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tif v := lru.GetTTL(\"empty\", \"cmd\"); v != -2 {\n\t\t\tt.Fatalf(\"unexpected %v\", v)\n\t\t}\n\t\tlru.Flight(\"key\", \"cmd\", time.Second, time.Now())\n\t\tm := RedisMessage{typ: 1}\n\t\tm.setExpireAt(time.Now().Add(time.Second).UnixMilli())\n\t\tlru.Update(\"key\", \"cmd\", m)\n\t\tif v := lru.GetTTL(\"key\", \"cmd\"); !roughly(v, time.Second) {\n\t\t\tt.Fatalf(\"unexpected %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Update Message TTL\", func(t *testing.T) {\n\t\tt.Run(\"client side TTL > server side TTL\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tlru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now())\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tm.setExpireAt(time.Now().Add(time.Second).UnixMilli())\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := lru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now()); v.CacheTTL() != 1 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"client side TTL < server side TTL\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tlru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now())\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tm.setExpireAt(time.Now().Add(3 * time.Second).UnixMilli())\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := lru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now()); v.CacheTTL() != 2 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"no server side TTL -1\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tlru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now())\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := lru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now()); v.CacheTTL() != 2 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"no server side TTL -2\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tlru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now())\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := lru.Flight(\"key\", \"cmd\", 2*time.Second, time.Now()); v.CacheTTL() != 2 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"Batch Cache Hit & Expire\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tif v, _ := lru.Flight(\"0\", \"GET\", TTL, time.Now()); v.typ == 0 {\n\t\t\tt.Fatalf(\"did not get the value from the second Flight\")\n\t\t} else if v.string != \"0\" {\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v\", v)\n\t\t}\n\t\ttime.Sleep(PTTL * time.Millisecond)\n\t\tif v, entry := flights(lru, time.Now(), TTL, \"GET\", \"0\"); v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the Flight after pttl: %v %v\", v, entry)\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Should Not Expire By PTTL -2\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tif v, entry := lru.Flight(\"1\", \"GET\", TTL, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the Flight after pttl: %v %v\", v, entry)\n\t\t}\n\t\tm := RedisMessage{typ: '+', string: \"1\"}\n\t\tlru.Update(\"1\", \"GET\", m)\n\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", \"1\"); v.typ == 0 {\n\t\t\tt.Fatalf(\"did not get the value from the second Flight\")\n\t\t} else if v.string != \"1\" {\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Miss Suppress\", func(t *testing.T) {\n\t\tcount := 5000\n\t\tlru := setup(t)\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(count)\n\t\tfor i := 0; i < count; i++ {\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", \"1\"); v.typ != 0 {\n\t\t\t\t\tt.Errorf(\"got unexpected value from the first Flight: %v\", v)\n\t\t\t\t}\n\t\t\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", \"2\"); v.typ != 0 {\n\t\t\t\t\tt.Errorf(\"got unexpected value from the first Flight: %v\", v)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\tlru.mu.RLock()\n\t\tstore1 := lru.store[\"1\"]\n\t\tstore2 := lru.store[\"2\"]\n\t\tlru.mu.RUnlock()\n\t\tif miss := atomic.LoadUint32(&store1.miss); miss != 1 {\n\t\t\tt.Fatalf(\"unexpected miss count %v\", miss)\n\t\t}\n\t\tif hits := atomic.LoadUint32(&store1.hits); hits != uint32(count-1) {\n\t\t\tt.Fatalf(\"unexpected hits count %v\", hits)\n\t\t}\n\t\tif miss := atomic.LoadUint32(&store2.miss); miss != 1 {\n\t\t\tt.Fatalf(\"unexpected miss count %v\", miss)\n\t\t}\n\t\tif hits := atomic.LoadUint32(&store2.hits); hits != uint32(count-1) {\n\t\t\tt.Fatalf(\"unexpected hits count %v\", hits)\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Evict\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tfor i := 1; i <= Entries; i++ {\n\t\t\tflights(lru, time.Now(), TTL, \"GET\", strconv.Itoa(i))\n\t\t\tm := RedisMessage{typ: '+', string: strconv.Itoa(i)}\n\t\t\tm.setExpireAt(time.Now().Add(PTTL * time.Millisecond).UnixMilli())\n\t\t\tlru.Update(strconv.Itoa(i), \"GET\", m)\n\t\t}\n\t\tif v, entry := flights(lru, time.Now(), TTL, \"GET\", \"1\"); v.typ != 0 {\n\t\t\tt.Fatalf(\"got evicted value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", strconv.Itoa(Entries)); v.typ == 0 {\n\t\t\tt.Fatalf(\"did not get the latest value from the Flight\")\n\t\t} else if v.string != strconv.Itoa(Entries) {\n\t\t\tt.Fatalf(\"got unexpected value from the Flight: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Delete\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tlru.Delete([]RedisMessage{{string: \"0\"}})\n\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", \"0\"); v.typ != 0 {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Flush\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tfor i := 1; i < Entries; i++ {\n\t\t\tflights(lru, time.Now(), TTL, \"GET\", strconv.Itoa(i))\n\t\t\tm := RedisMessage{typ: '+', string: strconv.Itoa(i)}\n\t\t\tlru.Update(strconv.Itoa(i), \"GET\", m)\n\t\t}\n\t\tfor i := 1; i < Entries; i++ {\n\t\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", strconv.Itoa(i)); v.string != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"got unexpected value before flush all: %v\", v)\n\t\t\t}\n\t\t}\n\t\tlru.Delete(nil)\n\t\tfor i := 1; i <= Entries; i++ {\n\t\t\tif v, _ := flights(lru, time.Now(), TTL, \"GET\", strconv.Itoa(i)); v.typ != 0 {\n\t\t\t\tt.Fatalf(\"got unexpected value after flush all: %v\", v)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Close\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tv, entry := flights(lru, time.Now(), TTL, \"GET\", \"1\")\n\t\tif v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tv, entry = flights(lru, time.Now(), TTL, \"GET\", \"1\")\n\t\tif v.typ != 0 || entry == nil { // entry should not be nil in second call\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v %v\", v, entry)\n\t\t}\n\n\t\tlru.Close(ErrDoCacheAborted)\n\n\t\tif _, err := entry.Wait(context.Background()); err != ErrDoCacheAborted {\n\t\t\tt.Fatalf(\"got unexpected value after Close: %v\", err)\n\t\t}\n\n\t\tm := RedisMessage{typ: '+', string: \"this Update should have no effect\"}\n\t\tm.setExpireAt(time.Now().Add(PTTL * time.Millisecond).UnixMilli())\n\t\tlru.Update(\"1\", \"GET\", m)\n\t\tfor i := 0; i < 2; i++ { // entry should be always nil after the first call if Close\n\t\t\tif v, entry := flights(lru, time.Now(), TTL, \"GET\", \"1\"); v.typ != 0 || entry != nil {\n\t\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Batch Cache Cancel\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tv, entry := flights(lru, time.Now(), TTL, \"GET\", \"1\")\n\t\tif v.typ != 0 || entry != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the first Flight: %v %v\", v, entry)\n\t\t}\n\t\tv, entry = flights(lru, time.Now(), TTL, \"GET\", \"1\")\n\t\tif v.typ != 0 || entry == nil { // entry should not be nil in second call\n\t\t\tt.Fatalf(\"got unexpected value from the second Flight: %v %v\", v, entry)\n\t\t}\n\t\terr := errors.New(\"any\")\n\n\t\tgo func() {\n\t\t\tlru.Cancel(\"1\", \"GET\", err)\n\t\t}()\n\n\t\tif _, err2 := entry.Wait(context.Background()); err2 != err {\n\t\t\tt.Fatalf(\"got unexpected value from the CacheEntry.Wait(): %v %v\", err, err2)\n\t\t}\n\t})\n\n\tt.Run(\"Batch GetTTL\", func(t *testing.T) {\n\t\tlru := setup(t)\n\t\tif v := lru.GetTTL(\"empty\", \"cmd\"); v != -2 {\n\t\t\tt.Fatalf(\"unexpected %v\", v)\n\t\t}\n\t\tflights(lru, time.Now(), time.Second, \"cmd\", \"key\")\n\t\tm := RedisMessage{typ: 1}\n\t\tm.setExpireAt(time.Now().Add(time.Second).UnixMilli())\n\t\tlru.Update(\"key\", \"cmd\", m)\n\t\tif v := lru.GetTTL(\"key\", \"cmd\"); !roughly(v, time.Second) {\n\t\t\tt.Fatalf(\"unexpected %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"Batch Update Message TTL\", func(t *testing.T) {\n\t\tt.Run(\"client side TTL > server side TTL\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tflights(lru, time.Now(), time.Second*2, \"cmd\", \"key\")\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tm.setExpireAt(time.Now().Add(time.Second).UnixMilli())\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := flights(lru, time.Now(), time.Second*2, \"cmd\", \"key\"); v.CacheTTL() != 1 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"client side TTL < server side TTL\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tflights(lru, time.Now(), time.Second*2, \"cmd\", \"key\")\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tm.setExpireAt(time.Now().Add(3 * time.Second).UnixMilli())\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := flights(lru, time.Now(), time.Second*2, \"cmd\", \"key\"); v.CacheTTL() != 2 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"no server side TTL -1\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tflights(lru, time.Now(), time.Second*2, \"cmd\", \"key\")\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := flights(lru, time.Now(), time.Second*2, \"cmd\", \"key\"); v.CacheTTL() != 2 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"no server side TTL -2\", func(t *testing.T) {\n\t\t\tlru := setup(t)\n\t\t\tflights(lru, time.Now(), time.Second*2, \"cmd\", \"key\")\n\t\t\tm := RedisMessage{typ: 1}\n\t\t\tlru.Update(\"key\", \"cmd\", m)\n\t\t\tif v, _ := flights(lru, time.Now(), time.Second*2, \"cmd\", \"key\"); v.CacheTTL() != 2 {\n\t\t\t\tt.Fatalf(\"unexpected %v\", v.CacheTTL())\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc flights(lru *lru, now time.Time, ttl time.Duration, args ...string) (RedisMessage, CacheEntry) {\n\tresults := make([]RedisResult, 1)\n\tentries := make(map[int]CacheEntry, 1)\n\tlru.Flights(now, commands(ttl, args...), results, entries)\n\treturn results[0].val, entries[0]\n}\n\nfunc commands(ttl time.Duration, args ...string) []CacheableTTL {\n\treturn []CacheableTTL{CT(Cacheable(cmds.NewCompleted(args)), ttl)}\n}\n\nfunc roughly(ttl, expect time.Duration) bool {\n\treturn ttl >= (expect/4) && ttl <= expect\n}\n\nfunc BenchmarkLRU(b *testing.B) {\n\tlru := newLRU(CacheStoreOption{CacheSizeEachConn: entryMinSize * Entries})\n\tb.Run(\"Flight\", func(b *testing.B) {\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tlru.Flight(\"0\", \"GET\", TTL, time.Now())\n\t\t\t}\n\t\t})\n\t})\n\tb.Run(\"Update\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tkey := strconv.Itoa(i)\n\t\t\tlru.Flight(key, \"GET\", TTL, time.Now())\n\t\t\tm := RedisMessage{}\n\t\t\tm.setExpireAt(time.Now().Add(PTTL * time.Millisecond).UnixMilli())\n\t\t\tlru.Update(key, \"GET\", m)\n\t\t}\n\t})\n}\n\nfunc TestEntry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"Wait\", func(t *testing.T) {\n\t\te := cacheEntry{ch: make(chan struct{})}\n\t\terr := errors.New(\"any\")\n\t\tgo func() {\n\t\t\te.val = RedisMessage{typ: 1}\n\t\t\te.err = err\n\t\t\tclose(e.ch)\n\t\t}()\n\t\tif v, err2 := e.Wait(context.Background()); v.typ != 1 || err2 != err {\n\t\t\tt.Fatalf(\"got unexpected value from the Wait: %v %v\", v.typ, err)\n\t\t}\n\t})\n\tt.Run(\"Wait with cancel\", func(t *testing.T) {\n\t\te := cacheEntry{ch: make(chan struct{})}\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\t\tgo func() {\n\t\t\te.val = RedisMessage{typ: 1}\n\t\t\tclose(e.ch)\n\t\t}()\n\t\tif v, err := e.Wait(ctx); v.typ != 1 || err != nil {\n\t\t\tt.Fatalf(\"got unexpected value from the Wait: %v %v\", v.typ, err)\n\t\t}\n\t})\n\tt.Run(\"Wait with closed ctx\", func(t *testing.T) {\n\t\te := cacheEntry{ch: make(chan struct{})}\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\t\tif v, err := e.Wait(ctx); err != context.Canceled {\n\t\t\tt.Fatalf(\"got unexpected value from the Wait: %v %v\", v.typ, err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "lua.go",
          "type": "blob",
          "size": 2.88671875,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\n// NewLuaScript creates a Lua instance whose Lua.Exec uses EVALSHA and EVAL.\nfunc NewLuaScript(script string) *Lua {\n\tsum := sha1.Sum([]byte(script))\n\treturn &Lua{script: script, sha1: hex.EncodeToString(sum[:]), maxp: runtime.GOMAXPROCS(0)}\n}\n\n// NewLuaScriptReadOnly creates a Lua instance whose Lua.Exec uses EVALSHA_RO and EVAL_RO.\nfunc NewLuaScriptReadOnly(script string) *Lua {\n\tlua := NewLuaScript(script)\n\tlua.readonly = true\n\treturn lua\n}\n\n// Lua represents a redis lua script. It should be created from the NewLuaScript() or NewLuaScriptReadOnly()\ntype Lua struct {\n\tscript   string\n\tsha1     string\n\tmaxp     int\n\treadonly bool\n}\n\n// Exec the script to the given Client.\n// It will first try with the EVALSHA/EVALSHA_RO and then EVAL/EVAL_RO if first try failed.\n// Cross slot keys are prohibited if the Client is a cluster client.\nfunc (s *Lua) Exec(ctx context.Context, c Client, keys, args []string) (resp RedisResult) {\n\tif s.readonly {\n\t\tresp = c.Do(ctx, c.B().EvalshaRo().Sha1(s.sha1).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())\n\t} else {\n\t\tresp = c.Do(ctx, c.B().Evalsha().Sha1(s.sha1).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())\n\t}\n\tif err, ok := IsRedisErr(resp.Error()); ok && err.IsNoScript() {\n\t\tif s.readonly {\n\t\t\tresp = c.Do(ctx, c.B().EvalRo().Script(s.script).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())\n\t\t} else {\n\t\t\tresp = c.Do(ctx, c.B().Eval().Script(s.script).Numkeys(int64(len(keys))).Key(keys...).Arg(args...).Build())\n\t\t}\n\t}\n\treturn resp\n}\n\n// LuaExec is a single execution unit of Lua.ExecMulti\ntype LuaExec struct {\n\tKeys []string\n\tArgs []string\n}\n\n// ExecMulti exec the script multiple times by the provided LuaExec to the given Client.\n// It will first try SCRIPT LOAD the script to all redis nodes and then exec it with the EVALSHA/EVALSHA_RO.\n// Cross slot keys within single LuaExec are prohibited if the Client is a cluster client.\nfunc (s *Lua) ExecMulti(ctx context.Context, c Client, multi ...LuaExec) (resp []RedisResult) {\n\tvar e atomic.Value\n\tutil.ParallelVals(s.maxp, c.Nodes(), func(n Client) {\n\t\tif err := n.Do(ctx, n.B().ScriptLoad().Script(s.script).Build()).Error(); err != nil {\n\t\t\te.CompareAndSwap(nil, &errs{error: err})\n\t\t}\n\t})\n\tif err := e.Load(); err != nil {\n\t\tresp = make([]RedisResult, len(multi))\n\t\tfor i := 0; i < len(resp); i++ {\n\t\t\tresp[i] = newErrResult(err.(*errs).error)\n\t\t}\n\t\treturn\n\t}\n\tcmds := make(Commands, 0, len(multi))\n\tif s.readonly {\n\t\tfor _, m := range multi {\n\t\t\tcmds = append(cmds, c.B().EvalshaRo().Sha1(s.sha1).Numkeys(int64(len(m.Keys))).Key(m.Keys...).Arg(m.Args...).Build())\n\t\t}\n\t} else {\n\t\tfor _, m := range multi {\n\t\t\tcmds = append(cmds, c.B().Evalsha().Sha1(s.sha1).Numkeys(int64(len(m.Keys))).Key(m.Keys...).Arg(m.Args...).Build())\n\t\t}\n\t}\n\treturn c.DoMulti(ctx, cmds...)\n}\n"
        },
        {
          "name": "lua_test.go",
          "type": "blob",
          "size": 7.7734375,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\nfunc TestNewLuaScriptOnePass(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbody := strconv.Itoa(rand.Int())\n\tsum := sha1.Sum([]byte(body))\n\tsha := hex.EncodeToString(sum[:])\n\n\tk := []string{\"1\", \"2\"}\n\ta := []string{\"3\", \"4\"}\n\n\tc := &client{\n\t\tBFn: func() Builder {\n\t\t\treturn cmds.NewBuilder(cmds.NoSlot)\n\t\t},\n\t\tDoFn: func(ctx context.Context, cmd Completed) (resp RedisResult) {\n\t\t\tif reflect.DeepEqual(cmd.Commands(), []string{\"EVALSHA\", sha, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"unexpected\"}, nil)\n\t\t},\n\t}\n\n\tscript := NewLuaScript(body)\n\n\tif v, err := script.Exec(context.Background(), c, k, a).ToString(); err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"ret mistmatch\")\n\t}\n}\n\nfunc TestNewLuaScript(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbody := strconv.Itoa(rand.Int())\n\tsum := sha1.Sum([]byte(body))\n\tsha := hex.EncodeToString(sum[:])\n\n\tk := []string{\"1\", \"2\"}\n\ta := []string{\"3\", \"4\"}\n\n\teval := false\n\n\tc := &client{\n\t\tBFn: func() Builder {\n\t\t\treturn cmds.NewBuilder(cmds.NoSlot)\n\t\t},\n\t\tDoFn: func(ctx context.Context, cmd Completed) (resp RedisResult) {\n\t\t\tif reflect.DeepEqual(cmd.Commands(), []string{\"EVALSHA\", sha, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\teval = true\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"NOSCRIPT\"}, nil)\n\t\t\t}\n\t\t\tif eval && reflect.DeepEqual(cmd.Commands(), []string{\"EVAL\", body, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\treturn newResult(RedisMessage{typ: '_'}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"unexpected\"}, nil)\n\t\t},\n\t}\n\n\tscript := NewLuaScript(body)\n\n\tif err, ok := IsRedisErr(script.Exec(context.Background(), c, k, a).Error()); ok && !err.IsNil() {\n\t\tt.Fatalf(\"ret mistmatch\")\n\t}\n}\n\nfunc TestNewLuaScriptReadOnly(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbody := strconv.Itoa(rand.Int())\n\tsum := sha1.Sum([]byte(body))\n\tsha := hex.EncodeToString(sum[:])\n\n\tk := []string{\"1\", \"2\"}\n\ta := []string{\"3\", \"4\"}\n\n\teval := false\n\n\tc := &client{\n\t\tBFn: func() Builder {\n\t\t\treturn cmds.NewBuilder(cmds.NoSlot)\n\t\t},\n\t\tDoFn: func(ctx context.Context, cmd Completed) (resp RedisResult) {\n\t\t\tif reflect.DeepEqual(cmd.Commands(), []string{\"EVALSHA_RO\", sha, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\teval = true\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"NOSCRIPT\"}, nil)\n\t\t\t}\n\t\t\tif eval && reflect.DeepEqual(cmd.Commands(), []string{\"EVAL_RO\", body, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\treturn newResult(RedisMessage{typ: '_'}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"unexpected\"}, nil)\n\t\t},\n\t}\n\n\tscript := NewLuaScriptReadOnly(body)\n\n\tif err, ok := IsRedisErr(script.Exec(context.Background(), c, k, a).Error()); ok && !err.IsNil() {\n\t\tt.Fatalf(\"ret mistmatch\")\n\t}\n}\n\nfunc TestNewLuaScriptExecMultiError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbody := strconv.Itoa(rand.Int())\n\n\tk := []string{\"1\", \"2\"}\n\ta := []string{\"3\", \"4\"}\n\n\tc := &client{\n\t\tBFn: func() Builder {\n\t\t\treturn cmds.NewBuilder(cmds.NoSlot)\n\t\t},\n\t\tDoFn: func(ctx context.Context, cmd Completed) (resp RedisResult) {\n\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ANY ERR\"}, nil)\n\t\t},\n\t}\n\n\tscript := NewLuaScript(body)\n\tif script.ExecMulti(context.Background(), c, LuaExec{Keys: k, Args: a})[0].Error().Error() != \"ANY ERR\" {\n\t\tt.Fatalf(\"ret mistmatch\")\n\t}\n}\n\nfunc TestNewLuaScriptExecMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbody := strconv.Itoa(rand.Int())\n\tsum := sha1.Sum([]byte(body))\n\tsha := hex.EncodeToString(sum[:])\n\n\tk := []string{\"1\", \"2\"}\n\ta := []string{\"3\", \"4\"}\n\n\tc := &client{\n\t\tBFn: func() Builder {\n\t\t\treturn cmds.NewBuilder(cmds.NoSlot)\n\t\t},\n\t\tDoFn: func(ctx context.Context, cmd Completed) (resp RedisResult) {\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t},\n\t\tDoMultiFn: func(ctx context.Context, multi ...Completed) (resp []RedisResult) {\n\t\t\tfor _, cmd := range multi {\n\t\t\t\tif reflect.DeepEqual(cmd.Commands(), []string{\"EVALSHA\", sha, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\t\tresp = append(resp, newResult(RedisMessage{typ: '+', string: \"OK\"}, nil))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resp\n\t\t},\n\t}\n\n\tscript := NewLuaScript(body)\n\tif v, err := script.ExecMulti(context.Background(), c, LuaExec{Keys: k, Args: a})[0].ToString(); err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"ret mistmatch\")\n\t}\n}\n\nfunc TestNewLuaScriptExecMultiRo(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbody := strconv.Itoa(rand.Int())\n\tsum := sha1.Sum([]byte(body))\n\tsha := hex.EncodeToString(sum[:])\n\n\tk := []string{\"1\", \"2\"}\n\ta := []string{\"3\", \"4\"}\n\n\tc := &client{\n\t\tBFn: func() Builder {\n\t\t\treturn cmds.NewBuilder(cmds.NoSlot)\n\t\t},\n\t\tDoFn: func(ctx context.Context, cmd Completed) (resp RedisResult) {\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t},\n\t\tDoMultiFn: func(ctx context.Context, multi ...Completed) (resp []RedisResult) {\n\t\t\tfor _, cmd := range multi {\n\t\t\t\tif reflect.DeepEqual(cmd.Commands(), []string{\"EVALSHA_RO\", sha, \"2\", \"1\", \"2\", \"3\", \"4\"}) {\n\t\t\t\t\tresp = append(resp, newResult(RedisMessage{typ: '+', string: \"OK\"}, nil))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resp\n\t\t},\n\t}\n\n\tscript := NewLuaScriptReadOnly(body)\n\tif v, err := script.ExecMulti(context.Background(), c, LuaExec{Keys: k, Args: a})[0].ToString(); err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"ret mistmatch\")\n\t}\n}\n\ntype client struct {\n\tBFn            func() Builder\n\tDoFn           func(ctx context.Context, cmd Completed) (resp RedisResult)\n\tDoMultiFn      func(ctx context.Context, cmd ...Completed) (resp []RedisResult)\n\tDoCacheFn      func(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult)\n\tDoMultiCacheFn func(ctx context.Context, cmd ...CacheableTTL) (resp []RedisResult)\n\tDedicatedFn    func(fn func(DedicatedClient) error) (err error)\n\tDedicateFn     func() (DedicatedClient, func())\n\tCloseFn        func()\n}\n\nfunc (c *client) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) error {\n\treturn nil\n}\n\nfunc (c *client) B() Builder {\n\tif c.BFn != nil {\n\t\treturn c.BFn()\n\t}\n\treturn Builder{}\n}\n\nfunc (c *client) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tif c.DoFn != nil {\n\t\treturn c.DoFn(ctx, cmd)\n\t}\n\treturn RedisResult{}\n}\n\nfunc (c *client) DoMulti(ctx context.Context, cmd ...Completed) (resp []RedisResult) {\n\tif c.DoMultiFn != nil {\n\t\treturn c.DoMultiFn(ctx, cmd...)\n\t}\n\treturn nil\n}\n\nfunc (c *client) DoStream(ctx context.Context, cmd Completed) (resp RedisResultStream) {\n\treturn RedisResultStream{}\n}\n\nfunc (c *client) DoMultiStream(ctx context.Context, cmd ...Completed) (resp MultiRedisResultStream) {\n\treturn MultiRedisResultStream{}\n}\n\nfunc (c *client) DoMultiCache(ctx context.Context, cmd ...CacheableTTL) (resp []RedisResult) {\n\tif c.DoMultiCacheFn != nil {\n\t\treturn c.DoMultiCacheFn(ctx, cmd...)\n\t}\n\treturn nil\n}\n\nfunc (c *client) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult) {\n\tif c.DoCacheFn != nil {\n\t\treturn c.DoCacheFn(ctx, cmd, ttl)\n\t}\n\treturn RedisResult{}\n}\n\nfunc (c *client) Dedicated(fn func(DedicatedClient) error) (err error) {\n\tif c.DedicatedFn != nil {\n\t\treturn c.DedicatedFn(fn)\n\t}\n\treturn nil\n}\n\nfunc (c *client) Dedicate() (DedicatedClient, func()) {\n\tif c.DedicateFn != nil {\n\t\treturn c.DedicateFn()\n\t}\n\treturn nil, nil\n}\n\nfunc (c *client) Nodes() map[string]Client {\n\treturn map[string]Client{\"addr\": c}\n}\n\nfunc (c *client) Close() {\n\tif c.CloseFn != nil {\n\t\tc.CloseFn()\n\t}\n}\n\nfunc ExampleLua_exec() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tctx := context.Background()\n\n\tscript := NewLuaScript(\"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\")\n\n\tscript.Exec(ctx, client, []string{\"k1\", \"k2\"}, []string{\"a1\", \"a2\"}).ToArray()\n}\n"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 36.7734375,
          "content": "package rueidis\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\nconst messageStructSize = int(unsafe.Sizeof(RedisMessage{}))\n\n// Nil represents a Redis Nil message\nvar Nil = &RedisError{typ: typeNull}\n\n// ErrParse is a parse error that occurs when a Redis message cannot be parsed correctly.\nvar errParse = errors.New(\"rueidis: parse error\")\n\n// IsRedisNil is a handy method to check if error is a redis nil response.\n// All redis nil response returns as an error.\nfunc IsRedisNil(err error) bool {\n\treturn err == Nil\n}\n\n// IsParseErr checks if the error is a parse error\nfunc IsParseErr(err error) bool {\n\treturn errors.Is(err, errParse)\n}\n\n// IsRedisBusyGroup checks if it is a redis BUSYGROUP message.\nfunc IsRedisBusyGroup(err error) bool {\n\tif ret, yes := IsRedisErr(err); yes {\n\t\treturn ret.IsBusyGroup()\n\t}\n\treturn false\n}\n\n// IsRedisErr is a handy method to check if error is a redis ERR response.\nfunc IsRedisErr(err error) (ret *RedisError, ok bool) {\n\tret, ok = err.(*RedisError)\n\treturn ret, ok && ret != Nil\n}\n\n// RedisError is an error response or a nil message from redis instance\ntype RedisError RedisMessage\n\nfunc (r *RedisError) Error() string {\n\tif r.IsNil() {\n\t\treturn \"redis nil message\"\n\t}\n\treturn r.string\n}\n\n// IsNil checks if it is a redis nil message.\nfunc (r *RedisError) IsNil() bool {\n\treturn r.typ == typeNull\n}\n\n// IsMoved checks if it is a redis MOVED message and returns moved address.\nfunc (r *RedisError) IsMoved() (addr string, ok bool) {\n\tif ok = strings.HasPrefix(r.string, \"MOVED\"); ok {\n\t\taddr = fixIPv6HostPort(strings.Split(r.string, \" \")[2])\n\t}\n\treturn\n}\n\n// IsAsk checks if it is a redis ASK message and returns ask address.\nfunc (r *RedisError) IsAsk() (addr string, ok bool) {\n\tif ok = strings.HasPrefix(r.string, \"ASK\"); ok {\n\t\taddr = fixIPv6HostPort(strings.Split(r.string, \" \")[2])\n\t}\n\treturn\n}\n\nfunc fixIPv6HostPort(addr string) string {\n\tif strings.IndexByte(addr, '.') < 0 && len(addr) > 0 && addr[0] != '[' { // skip ipv4 and enclosed ipv6\n\t\tif i := strings.LastIndexByte(addr, ':'); i >= 0 {\n\t\t\treturn net.JoinHostPort(addr[:i], addr[i+1:])\n\t\t}\n\t}\n\treturn addr\n}\n\n// IsTryAgain checks if it is a redis TRYAGAIN message and returns ask address.\nfunc (r *RedisError) IsTryAgain() bool {\n\treturn strings.HasPrefix(r.string, \"TRYAGAIN\")\n}\n\n// IsLoading checks if it is a redis LOADING message\nfunc (r *RedisError) IsLoading() bool {\n\treturn strings.HasPrefix(r.string, \"LOADING\")\n}\n\n// IsClusterDown checks if it is a redis CLUSTERDOWN message and returns ask address.\nfunc (r *RedisError) IsClusterDown() bool {\n\treturn strings.HasPrefix(r.string, \"CLUSTERDOWN\")\n}\n\n// IsNoScript checks if it is a redis NOSCRIPT message.\nfunc (r *RedisError) IsNoScript() bool {\n\treturn strings.HasPrefix(r.string, \"NOSCRIPT\")\n}\n\n// IsBusyGroup checks if it is a redis BUSYGROUP message.\nfunc (r *RedisError) IsBusyGroup() bool {\n\treturn strings.HasPrefix(r.string, \"BUSYGROUP\")\n}\n\nfunc newResult(val RedisMessage, err error) RedisResult {\n\treturn RedisResult{val: val, err: err}\n}\n\nfunc newErrResult(err error) RedisResult {\n\treturn RedisResult{err: err}\n}\n\n// RedisResult is the return struct from Client.Do or Client.DoCache\n// it contains either a redis response or an underlying error (ex. network timeout).\ntype RedisResult struct {\n\terr error\n\tval RedisMessage\n}\n\n// NonRedisError can be used to check if there is an underlying error (ex. network timeout).\nfunc (r RedisResult) NonRedisError() error {\n\treturn r.err\n}\n\n// Error returns either underlying error or redis error or nil\nfunc (r RedisResult) Error() (err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\terr = r.val.Error()\n\t}\n\treturn\n}\n\n// ToMessage retrieves the RedisMessage\nfunc (r RedisResult) ToMessage() (v RedisMessage, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\terr = r.val.Error()\n\t}\n\treturn r.val, err\n}\n\n// ToInt64 delegates to RedisMessage.ToInt64\nfunc (r RedisResult) ToInt64() (v int64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToInt64()\n\t}\n\treturn\n}\n\n// ToBool delegates to RedisMessage.ToBool\nfunc (r RedisResult) ToBool() (v bool, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToBool()\n\t}\n\treturn\n}\n\n// ToFloat64 delegates to RedisMessage.ToFloat64\nfunc (r RedisResult) ToFloat64() (v float64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToFloat64()\n\t}\n\treturn\n}\n\n// ToString delegates to RedisMessage.ToString\nfunc (r RedisResult) ToString() (v string, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToString()\n\t}\n\treturn\n}\n\n// AsReader delegates to RedisMessage.AsReader\nfunc (r RedisResult) AsReader() (v io.Reader, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsReader()\n\t}\n\treturn\n}\n\n// AsBytes delegates to RedisMessage.AsBytes\nfunc (r RedisResult) AsBytes() (v []byte, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsBytes()\n\t}\n\treturn\n}\n\n// DecodeJSON delegates to RedisMessage.DecodeJSON\nfunc (r RedisResult) DecodeJSON(v any) (err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\terr = r.val.DecodeJSON(v)\n\t}\n\treturn\n}\n\n// AsInt64 delegates to RedisMessage.AsInt64\nfunc (r RedisResult) AsInt64() (v int64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsInt64()\n\t}\n\treturn\n}\n\n// AsUint64 delegates to RedisMessage.AsUint64\nfunc (r RedisResult) AsUint64() (v uint64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsUint64()\n\t}\n\treturn\n}\n\n// AsBool delegates to RedisMessage.AsBool\nfunc (r RedisResult) AsBool() (v bool, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsBool()\n\t}\n\treturn\n}\n\n// AsFloat64 delegates to RedisMessage.AsFloat64\nfunc (r RedisResult) AsFloat64() (v float64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsFloat64()\n\t}\n\treturn\n}\n\n// ToArray delegates to RedisMessage.ToArray\nfunc (r RedisResult) ToArray() (v []RedisMessage, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToArray()\n\t}\n\treturn\n}\n\n// AsStrSlice delegates to RedisMessage.AsStrSlice\nfunc (r RedisResult) AsStrSlice() (v []string, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsStrSlice()\n\t}\n\treturn\n}\n\n// AsIntSlice delegates to RedisMessage.AsIntSlice\nfunc (r RedisResult) AsIntSlice() (v []int64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsIntSlice()\n\t}\n\treturn\n}\n\n// AsFloatSlice delegates to RedisMessage.AsFloatSlice\nfunc (r RedisResult) AsFloatSlice() (v []float64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsFloatSlice()\n\t}\n\treturn\n}\n\n// AsBoolSlice delegates to RedisMessage.AsBoolSlice\nfunc (r RedisResult) AsBoolSlice() (v []bool, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsBoolSlice()\n\t}\n\treturn\n}\n\n// AsXRangeEntry delegates to RedisMessage.AsXRangeEntry\nfunc (r RedisResult) AsXRangeEntry() (v XRangeEntry, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsXRangeEntry()\n\t}\n\treturn\n}\n\n// AsXRange delegates to RedisMessage.AsXRange\nfunc (r RedisResult) AsXRange() (v []XRangeEntry, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsXRange()\n\t}\n\treturn\n}\n\n// AsZScore delegates to RedisMessage.AsZScore\nfunc (r RedisResult) AsZScore() (v ZScore, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsZScore()\n\t}\n\treturn\n}\n\n// AsZScores delegates to RedisMessage.AsZScores\nfunc (r RedisResult) AsZScores() (v []ZScore, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsZScores()\n\t}\n\treturn\n}\n\n// AsXRead delegates to RedisMessage.AsXRead\nfunc (r RedisResult) AsXRead() (v map[string][]XRangeEntry, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsXRead()\n\t}\n\treturn\n}\n\nfunc (r RedisResult) AsLMPop() (v KeyValues, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsLMPop()\n\t}\n\treturn\n}\n\nfunc (r RedisResult) AsZMPop() (v KeyZScores, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsZMPop()\n\t}\n\treturn\n}\n\nfunc (r RedisResult) AsFtSearch() (total int64, docs []FtSearchDoc, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\ttotal, docs, err = r.val.AsFtSearch()\n\t}\n\treturn\n}\n\nfunc (r RedisResult) AsFtAggregate() (total int64, docs []map[string]string, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\ttotal, docs, err = r.val.AsFtAggregate()\n\t}\n\treturn\n}\n\nfunc (r RedisResult) AsFtAggregateCursor() (cursor, total int64, docs []map[string]string, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tcursor, total, docs, err = r.val.AsFtAggregateCursor()\n\t}\n\treturn\n}\n\nfunc (r RedisResult) AsGeosearch() (locations []GeoLocation, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tlocations, err = r.val.AsGeosearch()\n\t}\n\treturn\n}\n\n// AsMap delegates to RedisMessage.AsMap\nfunc (r RedisResult) AsMap() (v map[string]RedisMessage, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsMap()\n\t}\n\treturn\n}\n\n// AsStrMap delegates to RedisMessage.AsStrMap\nfunc (r RedisResult) AsStrMap() (v map[string]string, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsStrMap()\n\t}\n\treturn\n}\n\n// AsIntMap delegates to RedisMessage.AsIntMap\nfunc (r RedisResult) AsIntMap() (v map[string]int64, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsIntMap()\n\t}\n\treturn\n}\n\n// AsScanEntry delegates to RedisMessage.AsScanEntry.\nfunc (r RedisResult) AsScanEntry() (v ScanEntry, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.AsScanEntry()\n\t}\n\treturn\n}\n\n// ToMap delegates to RedisMessage.ToMap\nfunc (r RedisResult) ToMap() (v map[string]RedisMessage, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToMap()\n\t}\n\treturn\n}\n\n// ToAny delegates to RedisMessage.ToAny\nfunc (r RedisResult) ToAny() (v any, err error) {\n\tif r.err != nil {\n\t\terr = r.err\n\t} else {\n\t\tv, err = r.val.ToAny()\n\t}\n\treturn\n}\n\n// IsCacheHit delegates to RedisMessage.IsCacheHit\nfunc (r RedisResult) IsCacheHit() bool {\n\treturn r.val.IsCacheHit()\n}\n\n// CacheTTL delegates to RedisMessage.CacheTTL\nfunc (r RedisResult) CacheTTL() int64 {\n\treturn r.val.CacheTTL()\n}\n\n// CachePTTL delegates to RedisMessage.CachePTTL\nfunc (r RedisResult) CachePTTL() int64 {\n\treturn r.val.CachePTTL()\n}\n\n// CachePXAT delegates to RedisMessage.CachePXAT\nfunc (r RedisResult) CachePXAT() int64 {\n\treturn r.val.CachePXAT()\n}\n\n// String returns human-readable representation of RedisResult\nfunc (r *RedisResult) String() string {\n\tv, _ := (*prettyRedisResult)(r).MarshalJSON()\n\treturn string(v)\n}\n\ntype prettyRedisResult RedisResult\n\n// MarshalJSON implements json.Marshaler interface\nfunc (r *prettyRedisResult) MarshalJSON() ([]byte, error) {\n\ttype PrettyRedisResult struct {\n\t\tMessage *prettyRedisMessage `json:\"Message,omitempty\"`\n\t\tError   string              `json:\"Error,omitempty\"`\n\t}\n\tobj := PrettyRedisResult{}\n\tif r.err != nil {\n\t\tobj.Error = r.err.Error()\n\t} else {\n\t\tobj.Message = (*prettyRedisMessage)(&r.val)\n\t}\n\treturn json.Marshal(obj)\n}\n\n// RedisMessage is a redis response message, it may be a nil response\ntype RedisMessage struct {\n\tattrs   *RedisMessage\n\tstring  string\n\tvalues  []RedisMessage\n\tinteger int64\n\ttyp     byte\n\tttl     [7]byte\n}\n\nfunc (m *RedisMessage) cachesize() int {\n\tn := 9 // typ (1) + length (8) TODO: can we use VarInt instead of fixed 8 bytes for length?\n\tswitch m.typ {\n\tcase typeInteger, typeNull, typeBool:\n\tcase typeArray, typeMap, typeSet:\n\t\tfor _, val := range m.values {\n\t\t\tn += val.cachesize()\n\t\t}\n\tdefault:\n\t\tn += len(m.string)\n\t}\n\treturn n\n}\n\nfunc (m *RedisMessage) serialize(o *bytes.Buffer) {\n\tvar buf [8]byte // TODO: can we use VarInt instead of fixed 8 bytes for length?\n\to.WriteByte(m.typ)\n\tswitch m.typ {\n\tcase typeInteger, typeNull, typeBool:\n\t\tbinary.BigEndian.PutUint64(buf[:], uint64(m.integer))\n\t\to.Write(buf[:])\n\tcase typeArray, typeMap, typeSet:\n\t\tbinary.BigEndian.PutUint64(buf[:], uint64(len(m.values)))\n\t\to.Write(buf[:])\n\t\tfor _, val := range m.values {\n\t\t\tval.serialize(o)\n\t\t}\n\tdefault:\n\t\tbinary.BigEndian.PutUint64(buf[:], uint64(len(m.string)))\n\t\to.Write(buf[:])\n\t\to.WriteString(m.string)\n\t}\n}\n\nvar ErrCacheUnmarshal = errors.New(\"cache unmarshal error\")\n\nfunc (m *RedisMessage) unmarshalView(c int64, buf []byte) (int64, error) {\n\tvar err error\n\tif int64(len(buf)) < c+9 {\n\t\treturn 0, ErrCacheUnmarshal\n\t}\n\tm.typ = buf[c]\n\tc += 1\n\tm.integer = int64(binary.BigEndian.Uint64(buf[c : c+8]))\n\tc += 8 // TODO: can we use VarInt instead of fixed 8 bytes for length?\n\tswitch m.typ {\n\tcase typeInteger, typeNull, typeBool:\n\tcase typeArray, typeMap, typeSet:\n\t\tm.values = make([]RedisMessage, m.integer)\n\t\tm.integer = 0\n\t\tfor i := range m.values {\n\t\t\tif c, err = m.values[i].unmarshalView(c, buf); err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tif int64(len(buf)) < c+m.integer {\n\t\t\treturn 0, ErrCacheUnmarshal\n\t\t}\n\t\tm.string = BinaryString(buf[c : c+m.integer])\n\t\tc += m.integer\n\t\tm.integer = 0\n\t}\n\treturn c, err\n}\n\n// CacheSize returns the buffer size needed by the CacheMarshal.\nfunc (m *RedisMessage) CacheSize() int {\n\treturn m.cachesize() + 7 // 7 for ttl\n}\n\n// CacheMarshal writes serialized RedisMessage to the provided buffer.\n// If the provided buffer is nil, CacheMarshal will allocate one.\n// Note that output format is not compatible with different client versions.\nfunc (m *RedisMessage) CacheMarshal(buf []byte) []byte {\n\tif buf == nil {\n\t\tbuf = make([]byte, 0, m.CacheSize())\n\t}\n\to := bytes.NewBuffer(buf)\n\to.Write(m.ttl[:7])\n\tm.serialize(o)\n\treturn o.Bytes()\n}\n\n// CacheUnmarshalView construct the RedisMessage from the buffer produced by CacheMarshal.\n// Note that the buffer can't be reused after CacheUnmarshalView since it uses unsafe.String on top of the buffer.\nfunc (m *RedisMessage) CacheUnmarshalView(buf []byte) error {\n\tif len(buf) < 7 {\n\t\treturn ErrCacheUnmarshal\n\t}\n\tcopy(m.ttl[:7], buf[:7])\n\tif _, err := m.unmarshalView(7, buf); err != nil {\n\t\treturn err\n\t}\n\tm.attrs = cacheMark\n\treturn nil\n}\n\n// IsNil check if message is a redis nil response\nfunc (m *RedisMessage) IsNil() bool {\n\treturn m.typ == typeNull\n}\n\n// IsInt64 check if message is a redis RESP3 int response\nfunc (m *RedisMessage) IsInt64() bool {\n\treturn m.typ == typeInteger\n}\n\n// IsFloat64 check if message is a redis RESP3 double response\nfunc (m *RedisMessage) IsFloat64() bool {\n\treturn m.typ == typeFloat\n}\n\n// IsString check if message is a redis string response\nfunc (m *RedisMessage) IsString() bool {\n\treturn m.typ == typeBlobString || m.typ == typeSimpleString\n}\n\n// IsBool check if message is a redis RESP3 bool response\nfunc (m *RedisMessage) IsBool() bool {\n\treturn m.typ == typeBool\n}\n\n// IsArray check if message is a redis array response\nfunc (m *RedisMessage) IsArray() bool {\n\treturn m.typ == typeArray || m.typ == typeSet\n}\n\n// IsMap check if message is a redis RESP3 map response\nfunc (m *RedisMessage) IsMap() bool {\n\treturn m.typ == typeMap\n}\n\n// Error check if message is a redis error response, including nil response\nfunc (m *RedisMessage) Error() error {\n\tif m.typ == typeNull {\n\t\treturn Nil\n\t}\n\tif m.typ == typeSimpleErr || m.typ == typeBlobErr {\n\t\t// kvrocks: https://github.com/redis/rueidis/issues/152#issuecomment-1333923750\n\t\tmm := *m\n\t\tmm.string = strings.TrimPrefix(m.string, \"ERR \")\n\t\treturn (*RedisError)(&mm)\n\t}\n\treturn nil\n}\n\n// ToString check if message is a redis string response, and return it\nfunc (m *RedisMessage) ToString() (val string, err error) {\n\tif m.IsString() {\n\t\treturn m.string, nil\n\t}\n\tif m.IsInt64() || m.values != nil {\n\t\ttyp := m.typ\n\t\treturn \"\", fmt.Errorf(\"%w: redis message type %s is not a string\", errParse, typeNames[typ])\n\t}\n\treturn m.string, m.Error()\n}\n\n// AsReader check if message is a redis string response and wrap it with the strings.NewReader\nfunc (m *RedisMessage) AsReader() (reader io.Reader, err error) {\n\tstr, err := m.ToString()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn strings.NewReader(str), nil\n}\n\n// AsBytes check if message is a redis string response and return it as an immutable []byte\nfunc (m *RedisMessage) AsBytes() (bs []byte, err error) {\n\tstr, err := m.ToString()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn unsafe.Slice(unsafe.StringData(str), len(str)), nil\n}\n\n// DecodeJSON check if message is a redis string response and treat it as json, then unmarshal it into provided value\nfunc (m *RedisMessage) DecodeJSON(v any) (err error) {\n\tstr, err := m.ToString()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdecoder := json.NewDecoder(strings.NewReader(str))\n\treturn decoder.Decode(v)\n}\n\n// AsInt64 check if message is a redis string response, and parse it as int64\nfunc (m *RedisMessage) AsInt64() (val int64, err error) {\n\tif m.IsInt64() {\n\t\treturn m.integer, nil\n\t}\n\tv, err := m.ToString()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn strconv.ParseInt(v, 10, 64)\n}\n\n// AsUint64 check if message is a redis string response, and parse it as uint64\nfunc (m *RedisMessage) AsUint64() (val uint64, err error) {\n\tif m.IsInt64() {\n\t\treturn uint64(m.integer), nil\n\t}\n\tv, err := m.ToString()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn strconv.ParseUint(v, 10, 64)\n}\n\n// AsBool checks if message is non-nil redis response, and parses it as bool\nfunc (m *RedisMessage) AsBool() (val bool, err error) {\n\tif err = m.Error(); err != nil {\n\t\treturn\n\t}\n\tswitch m.typ {\n\tcase typeBlobString, typeSimpleString:\n\t\tval = m.string == \"OK\"\n\t\treturn\n\tcase typeInteger:\n\t\tval = m.integer != 0\n\t\treturn\n\tcase typeBool:\n\t\tval = m.integer == 1\n\t\treturn\n\tdefault:\n\t\ttyp := m.typ\n\t\treturn false, fmt.Errorf(\"%w: redis message type %s is not a int, string or bool\", errParse, typeNames[typ])\n\t}\n}\n\n// AsFloat64 check if message is a redis string response, and parse it as float64\nfunc (m *RedisMessage) AsFloat64() (val float64, err error) {\n\tif m.IsFloat64() {\n\t\treturn util.ToFloat64(m.string)\n\t}\n\tv, err := m.ToString()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn util.ToFloat64(v)\n}\n\n// ToInt64 check if message is a redis RESP3 int response, and return it\nfunc (m *RedisMessage) ToInt64() (val int64, err error) {\n\tif m.IsInt64() {\n\t\treturn m.integer, nil\n\t}\n\tif err = m.Error(); err != nil {\n\t\treturn 0, err\n\t}\n\ttyp := m.typ\n\treturn 0, fmt.Errorf(\"%w: redis message type %s is not a RESP3 int64\", errParse, typeNames[typ])\n}\n\n// ToBool check if message is a redis RESP3 bool response, and return it\nfunc (m *RedisMessage) ToBool() (val bool, err error) {\n\tif m.IsBool() {\n\t\treturn m.integer == 1, nil\n\t}\n\tif err = m.Error(); err != nil {\n\t\treturn false, err\n\t}\n\ttyp := m.typ\n\treturn false, fmt.Errorf(\"%w: redis message type %s is not a RESP3 bool\", errParse, typeNames[typ])\n}\n\n// ToFloat64 check if message is a redis RESP3 double response, and return it\nfunc (m *RedisMessage) ToFloat64() (val float64, err error) {\n\tif m.IsFloat64() {\n\t\treturn util.ToFloat64(m.string)\n\t}\n\tif err = m.Error(); err != nil {\n\t\treturn 0, err\n\t}\n\ttyp := m.typ\n\treturn 0, fmt.Errorf(\"%w: redis message type %s is not a RESP3 float64\", errParse, typeNames[typ])\n}\n\n// ToArray check if message is a redis array/set response, and return it\nfunc (m *RedisMessage) ToArray() ([]RedisMessage, error) {\n\tif m.IsArray() {\n\t\treturn m.values, nil\n\t}\n\tif err := m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a array\", errParse, typeNames[typ])\n}\n\n// AsStrSlice check if message is a redis array/set response, and convert to []string.\n// redis nil element and other non string element will be present as zero.\nfunc (m *RedisMessage) AsStrSlice() ([]string, error) {\n\tvalues, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := make([]string, 0, len(values))\n\tfor _, v := range values {\n\t\ts = append(s, v.string)\n\t}\n\treturn s, nil\n}\n\n// AsIntSlice check if message is a redis array/set response, and convert to []int64.\n// redis nil element and other non integer element will be present as zero.\nfunc (m *RedisMessage) AsIntSlice() ([]int64, error) {\n\tvalues, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := make([]int64, len(values))\n\tfor i, v := range values {\n\t\tif len(v.string) != 0 {\n\t\t\tif s[i], err = strconv.ParseInt(v.string, 10, 64); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\ts[i] = v.integer\n\t\t}\n\t}\n\treturn s, nil\n}\n\n// AsFloatSlice check if message is a redis array/set response, and convert to []float64.\n// redis nil element and other non float element will be present as zero.\nfunc (m *RedisMessage) AsFloatSlice() ([]float64, error) {\n\tvalues, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := make([]float64, len(values))\n\tfor i, v := range values {\n\t\tif len(v.string) != 0 {\n\t\t\tif s[i], err = util.ToFloat64(v.string); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\ts[i] = float64(v.integer)\n\t\t}\n\t}\n\treturn s, nil\n}\n\n// AsBoolSlice checks if message is a redis array/set response, and converts it to []bool.\n// Redis nil elements and other non-boolean elements will be represented as false.\nfunc (m *RedisMessage) AsBoolSlice() ([]bool, error) {\n\tvalues, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts := make([]bool, len(values))\n\tfor i, v := range values {\n\t\ts[i], _ = v.AsBool() // Ignore error, non-boolean values will be false\n\t}\n\treturn s, nil\n}\n\n// XRangeEntry is the element type of both XRANGE and XREVRANGE command response array\ntype XRangeEntry struct {\n\tFieldValues map[string]string\n\tID          string\n}\n\n// AsXRangeEntry check if message is a redis array/set response of length 2, and convert to XRangeEntry\nfunc (m *RedisMessage) AsXRangeEntry() (XRangeEntry, error) {\n\tvalues, err := m.ToArray()\n\tif err != nil {\n\t\treturn XRangeEntry{}, err\n\t}\n\tif len(values) != 2 {\n\t\treturn XRangeEntry{}, fmt.Errorf(\"got %d, wanted 2\", len(values))\n\t}\n\tid, err := values[0].ToString()\n\tif err != nil {\n\t\treturn XRangeEntry{}, err\n\t}\n\tfieldValues, err := values[1].AsStrMap()\n\tif err != nil {\n\t\tif IsRedisNil(err) {\n\t\t\treturn XRangeEntry{ID: id, FieldValues: nil}, nil\n\t\t}\n\t\treturn XRangeEntry{}, err\n\t}\n\treturn XRangeEntry{\n\t\tID:          id,\n\t\tFieldValues: fieldValues,\n\t}, nil\n}\n\n// AsXRange check if message is a redis array/set response, and convert to []XRangeEntry\nfunc (m *RedisMessage) AsXRange() ([]XRangeEntry, error) {\n\tvalues, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsgs := make([]XRangeEntry, 0, len(values))\n\tfor _, v := range values {\n\t\tmsg, err := v.AsXRangeEntry()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmsgs = append(msgs, msg)\n\t}\n\treturn msgs, nil\n}\n\n// AsXRead converts XREAD/XREADGRUOP response to map[string][]XRangeEntry\nfunc (m *RedisMessage) AsXRead() (ret map[string][]XRangeEntry, err error) {\n\tif err = m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\tif m.IsMap() {\n\t\tret = make(map[string][]XRangeEntry, len(m.values)/2)\n\t\tfor i := 0; i < len(m.values); i += 2 {\n\t\t\tif ret[m.values[i].string], err = m.values[i+1].AsXRange(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn ret, nil\n\t}\n\tif m.IsArray() {\n\t\tret = make(map[string][]XRangeEntry, len(m.values))\n\t\tfor _, v := range m.values {\n\t\t\tif !v.IsArray() || len(v.values) != 2 {\n\t\t\t\treturn nil, fmt.Errorf(\"got %d, wanted 2\", len(v.values))\n\t\t\t}\n\t\t\tif ret[v.values[0].string], err = v.values[1].AsXRange(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn ret, nil\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a map/array/set\", errParse, typeNames[typ])\n}\n\n// ZScore is the element type of ZRANGE WITHSCORES, ZDIFF WITHSCORES and ZPOPMAX command response\ntype ZScore struct {\n\tMember string\n\tScore  float64\n}\n\nfunc toZScore(values []RedisMessage) (s ZScore, err error) {\n\tif len(values) == 2 {\n\t\tif s.Member, err = values[0].ToString(); err == nil {\n\t\t\ts.Score, err = values[1].AsFloat64()\n\t\t}\n\t\treturn s, err\n\t}\n\treturn ZScore{}, fmt.Errorf(\"redis message is not a map/array/set or its length is not 2\")\n}\n\n// AsZScore converts ZPOPMAX and ZPOPMIN command with count 1 response to a single ZScore\nfunc (m *RedisMessage) AsZScore() (s ZScore, err error) {\n\tarr, err := m.ToArray()\n\tif err != nil {\n\t\treturn s, err\n\t}\n\treturn toZScore(arr)\n}\n\n// AsZScores converts ZRANGE WITHSCROES, ZDIFF WITHSCROES and ZPOPMAX/ZPOPMIN command with count > 1 responses to []ZScore\nfunc (m *RedisMessage) AsZScores() ([]ZScore, error) {\n\tarr, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(arr) > 0 && arr[0].IsArray() {\n\t\tscores := make([]ZScore, len(arr))\n\t\tfor i, v := range arr {\n\t\t\tif scores[i], err = toZScore(v.values); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn scores, nil\n\t}\n\tscores := make([]ZScore, len(arr)/2)\n\tfor i := 0; i < len(scores); i++ {\n\t\tj := i * 2\n\t\tif scores[i], err = toZScore(arr[j : j+2]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn scores, nil\n}\n\n// ScanEntry is the element type of both SCAN, SSCAN, HSCAN and ZSCAN command response.\ntype ScanEntry struct {\n\tElements []string\n\tCursor   uint64\n}\n\n// AsScanEntry check if message is a redis array/set response of length 2, and convert to ScanEntry.\nfunc (m *RedisMessage) AsScanEntry() (e ScanEntry, err error) {\n\tmsgs, err := m.ToArray()\n\tif err != nil {\n\t\treturn ScanEntry{}, err\n\t}\n\tif len(msgs) >= 2 {\n\t\tif e.Cursor, err = msgs[0].AsUint64(); err == nil {\n\t\t\te.Elements, err = msgs[1].AsStrSlice()\n\t\t}\n\t\treturn e, err\n\t}\n\ttyp := m.typ\n\treturn ScanEntry{}, fmt.Errorf(\"%w: redis message type %s is not a scan response or its length is not at least 2\", errParse, typeNames[typ])\n}\n\n// AsMap check if message is a redis array/set response, and convert to map[string]RedisMessage\nfunc (m *RedisMessage) AsMap() (map[string]RedisMessage, error) {\n\tif err := m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\tif (m.IsMap() || m.IsArray()) && len(m.values)%2 == 0 {\n\t\treturn toMap(m.values)\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a map/array/set or its length is not even\", errParse, typeNames[typ])\n}\n\n// AsStrMap check if message is a redis map/array/set response, and convert to map[string]string.\n// redis nil element and other non string element will be present as zero.\nfunc (m *RedisMessage) AsStrMap() (map[string]string, error) {\n\tif err := m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\tif (m.IsMap() || m.IsArray()) && len(m.values)%2 == 0 {\n\t\tr := make(map[string]string, len(m.values)/2)\n\t\tfor i := 0; i < len(m.values); i += 2 {\n\t\t\tk := m.values[i]\n\t\t\tv := m.values[i+1]\n\t\t\tr[k.string] = v.string\n\t\t}\n\t\treturn r, nil\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a map/array/set or its length is not even\", errParse, typeNames[typ])\n}\n\n// AsIntMap check if message is a redis map/array/set response, and convert to map[string]int64.\n// redis nil element and other non integer element will be present as zero.\nfunc (m *RedisMessage) AsIntMap() (map[string]int64, error) {\n\tif err := m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\tif (m.IsMap() || m.IsArray()) && len(m.values)%2 == 0 {\n\t\tvar err error\n\t\tr := make(map[string]int64, len(m.values)/2)\n\t\tfor i := 0; i < len(m.values); i += 2 {\n\t\t\tk := m.values[i]\n\t\t\tv := m.values[i+1]\n\t\t\tif k.typ == typeBlobString || k.typ == typeSimpleString {\n\t\t\t\tif len(v.string) != 0 {\n\t\t\t\t\tif r[k.string], err = strconv.ParseInt(v.string, 0, 64); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t} else if v.typ == typeInteger || v.typ == typeNull {\n\t\t\t\t\tr[k.string] = v.integer\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r, nil\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a map/array/set or its length is not even\", errParse, typeNames[typ])\n}\n\ntype KeyValues struct {\n\tKey    string\n\tValues []string\n}\n\nfunc (m *RedisMessage) AsLMPop() (kvs KeyValues, err error) {\n\tif err = m.Error(); err != nil {\n\t\treturn KeyValues{}, err\n\t}\n\tif len(m.values) >= 2 {\n\t\tkvs.Key = m.values[0].string\n\t\tkvs.Values, err = m.values[1].AsStrSlice()\n\t\treturn\n\t}\n\ttyp := m.typ\n\treturn KeyValues{}, fmt.Errorf(\"%w: redis message type %s is not a LMPOP response\", errParse, typeNames[typ])\n}\n\ntype KeyZScores struct {\n\tKey    string\n\tValues []ZScore\n}\n\nfunc (m *RedisMessage) AsZMPop() (kvs KeyZScores, err error) {\n\tif err = m.Error(); err != nil {\n\t\treturn KeyZScores{}, err\n\t}\n\tif len(m.values) >= 2 {\n\t\tkvs.Key = m.values[0].string\n\t\tkvs.Values, err = m.values[1].AsZScores()\n\t\treturn\n\t}\n\ttyp := m.typ\n\treturn KeyZScores{}, fmt.Errorf(\"%w: redis message type %s is not a ZMPOP response\", errParse, typeNames[typ])\n}\n\ntype FtSearchDoc struct {\n\tDoc   map[string]string\n\tKey   string\n\tScore float64\n}\n\nfunc (m *RedisMessage) AsFtSearch() (total int64, docs []FtSearchDoc, err error) {\n\tif err = m.Error(); err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif m.IsMap() {\n\t\tfor i := 0; i < len(m.values); i += 2 {\n\t\t\tswitch m.values[i].string {\n\t\t\tcase \"total_results\":\n\t\t\t\ttotal = m.values[i+1].integer\n\t\t\tcase \"results\":\n\t\t\t\trecords := m.values[i+1].values\n\t\t\t\tdocs = make([]FtSearchDoc, len(records))\n\t\t\t\tfor d, record := range records {\n\t\t\t\t\tfor j := 0; j < len(record.values); j += 2 {\n\t\t\t\t\t\tswitch record.values[j].string {\n\t\t\t\t\t\tcase \"id\":\n\t\t\t\t\t\t\tdocs[d].Key = record.values[j+1].string\n\t\t\t\t\t\tcase \"extra_attributes\":\n\t\t\t\t\t\t\tdocs[d].Doc, _ = record.values[j+1].AsStrMap()\n\t\t\t\t\t\tcase \"score\":\n\t\t\t\t\t\t\tdocs[d].Score, _ = strconv.ParseFloat(record.values[j+1].string, 64)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"error\":\n\t\t\t\tfor _, e := range m.values[i+1].values {\n\t\t\t\t\te := e\n\t\t\t\t\treturn 0, nil, (*RedisError)(&e)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\tif len(m.values) > 0 {\n\t\ttotal = m.values[0].integer\n\t\twscore := false\n\t\twattrs := false\n\t\toffset := 1\n\t\tif len(m.values) > 2 {\n\t\t\tif m.values[2].string == \"\" {\n\t\t\t\twattrs = true\n\t\t\t\toffset++\n\t\t\t} else {\n\t\t\t\t_, err1 := strconv.ParseFloat(m.values[1].string, 64)\n\t\t\t\t_, err2 := strconv.ParseFloat(m.values[2].string, 64)\n\t\t\t\twscore = err1 != nil && err2 == nil\n\t\t\t\toffset++\n\t\t\t}\n\t\t}\n\t\tif len(m.values) > 3 && m.values[3].string == \"\" {\n\t\t\twattrs = true\n\t\t\toffset++\n\t\t}\n\t\tdocs = make([]FtSearchDoc, 0, (len(m.values)-1)/offset)\n\t\tfor i := 1; i < len(m.values); i++ {\n\t\t\tdoc := FtSearchDoc{Key: m.values[i].string}\n\t\t\tif wscore {\n\t\t\t\ti++\n\t\t\t\tdoc.Score, _ = strconv.ParseFloat(m.values[i].string, 64)\n\t\t\t}\n\t\t\tif wattrs {\n\t\t\t\ti++\n\t\t\t\tdoc.Doc, _ = m.values[i].AsStrMap()\n\t\t\t}\n\t\t\tdocs = append(docs, doc)\n\t\t}\n\t\treturn\n\t}\n\ttyp := m.typ\n\treturn 0, nil, fmt.Errorf(\"%w: redis message type %s is not a FT.SEARCH response\", errParse, typeNames[typ])\n}\n\nfunc (m *RedisMessage) AsFtAggregate() (total int64, docs []map[string]string, err error) {\n\tif err = m.Error(); err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif m.IsMap() {\n\t\tfor i := 0; i < len(m.values); i += 2 {\n\t\t\tswitch m.values[i].string {\n\t\t\tcase \"total_results\":\n\t\t\t\ttotal = m.values[i+1].integer\n\t\t\tcase \"results\":\n\t\t\t\trecords := m.values[i+1].values\n\t\t\t\tdocs = make([]map[string]string, len(records))\n\t\t\t\tfor d, record := range records {\n\t\t\t\t\tfor j := 0; j < len(record.values); j += 2 {\n\t\t\t\t\t\tswitch record.values[j].string {\n\t\t\t\t\t\tcase \"extra_attributes\":\n\t\t\t\t\t\t\tdocs[d], _ = record.values[j+1].AsStrMap()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase \"error\":\n\t\t\t\tfor _, e := range m.values[i+1].values {\n\t\t\t\t\te := e\n\t\t\t\t\treturn 0, nil, (*RedisError)(&e)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\tif len(m.values) > 0 {\n\t\ttotal = m.values[0].integer\n\t\tdocs = make([]map[string]string, len(m.values)-1)\n\t\tfor d, record := range m.values[1:] {\n\t\t\tdocs[d], _ = record.AsStrMap()\n\t\t}\n\t\treturn\n\t}\n\ttyp := m.typ\n\treturn 0, nil, fmt.Errorf(\"%w: redis message type %s is not a FT.AGGREGATE response\", errParse, typeNames[typ])\n}\n\nfunc (m *RedisMessage) AsFtAggregateCursor() (cursor, total int64, docs []map[string]string, err error) {\n\tif m.IsArray() && len(m.values) == 2 && (m.values[0].IsArray() || m.values[0].IsMap()) {\n\t\ttotal, docs, err = m.values[0].AsFtAggregate()\n\t\tcursor = m.values[1].integer\n\t} else {\n\t\ttotal, docs, err = m.AsFtAggregate()\n\t}\n\treturn\n}\n\ntype GeoLocation struct {\n\tName                      string\n\tLongitude, Latitude, Dist float64\n\tGeoHash                   int64\n}\n\nfunc (m *RedisMessage) AsGeosearch() ([]GeoLocation, error) {\n\tarr, err := m.ToArray()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgeoLocations := make([]GeoLocation, 0, len(arr))\n\tfor _, v := range arr {\n\t\tvar loc GeoLocation\n\t\tif v.IsString() {\n\t\t\tloc.Name = v.string\n\t\t} else {\n\t\t\tinfo := v.values\n\t\t\tvar i int\n\n\t\t\t//name\n\t\t\tloc.Name = info[i].string\n\t\t\ti++\n\t\t\t//distance\n\t\t\tif i < len(info) && info[i].string != \"\" {\n\t\t\t\tloc.Dist, err = util.ToFloat64(info[i].string)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t\t//hash\n\t\t\tif i < len(info) && info[i].IsInt64() {\n\t\t\t\tloc.GeoHash = info[i].integer\n\t\t\t\ti++\n\t\t\t}\n\t\t\t//coordinates\n\t\t\tif i < len(info) && info[i].values != nil {\n\t\t\t\tcord := info[i].values\n\t\t\t\tif len(cord) < 2 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"got %d, expected 2\", len(info))\n\t\t\t\t}\n\t\t\t\tloc.Longitude, _ = cord[0].AsFloat64()\n\t\t\t\tloc.Latitude, _ = cord[1].AsFloat64()\n\t\t\t}\n\t\t}\n\t\tgeoLocations = append(geoLocations, loc)\n\t}\n\treturn geoLocations, nil\n}\n\n// ToMap check if message is a redis RESP3 map response, and return it\nfunc (m *RedisMessage) ToMap() (map[string]RedisMessage, error) {\n\tif m.IsMap() {\n\t\treturn toMap(m.values)\n\t}\n\tif err := m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a RESP3 map\", errParse, typeNames[typ])\n}\n\n// ToAny turns message into go any value\nfunc (m *RedisMessage) ToAny() (any, error) {\n\tif err := m.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch m.typ {\n\tcase typeFloat:\n\t\treturn util.ToFloat64(m.string)\n\tcase typeBlobString, typeSimpleString, typeVerbatimString, typeBigNumber:\n\t\treturn m.string, nil\n\tcase typeBool:\n\t\treturn m.integer == 1, nil\n\tcase typeInteger:\n\t\treturn m.integer, nil\n\tcase typeMap:\n\t\tvs := make(map[string]any, len(m.values)/2)\n\t\tfor i := 0; i < len(m.values); i += 2 {\n\t\t\tif v, err := m.values[i+1].ToAny(); err != nil && !IsRedisNil(err) {\n\t\t\t\tvs[m.values[i].string] = err\n\t\t\t} else {\n\t\t\t\tvs[m.values[i].string] = v\n\t\t\t}\n\t\t}\n\t\treturn vs, nil\n\tcase typeSet, typeArray:\n\t\tvs := make([]any, len(m.values))\n\t\tfor i := 0; i < len(m.values); i++ {\n\t\t\tif v, err := m.values[i].ToAny(); err != nil && !IsRedisNil(err) {\n\t\t\t\tvs[i] = err\n\t\t\t} else {\n\t\t\t\tvs[i] = v\n\t\t\t}\n\t\t}\n\t\treturn vs, nil\n\t}\n\ttyp := m.typ\n\treturn nil, fmt.Errorf(\"%w: redis message type %s is not a supported in ToAny\", errParse, typeNames[typ])\n}\n\n// IsCacheHit check if message is from client side cache\nfunc (m *RedisMessage) IsCacheHit() bool {\n\treturn m.attrs == cacheMark\n}\n\n// CacheTTL returns the remaining TTL in seconds of client side cache\nfunc (m *RedisMessage) CacheTTL() (ttl int64) {\n\tmilli := m.CachePTTL()\n\tif milli > 0 {\n\t\tif ttl = milli / 1000; milli > ttl*1000 {\n\t\t\tttl++\n\t\t}\n\t\treturn ttl\n\t}\n\treturn milli\n}\n\n// CachePTTL returns the remaining PTTL in seconds of client side cache\nfunc (m *RedisMessage) CachePTTL() int64 {\n\tmilli := m.getExpireAt()\n\tif milli == 0 {\n\t\treturn -1\n\t}\n\tif milli = milli - time.Now().UnixMilli(); milli < 0 {\n\t\tmilli = 0\n\t}\n\treturn milli\n}\n\n// CachePXAT returns the remaining PXAT in seconds of client side cache\nfunc (m *RedisMessage) CachePXAT() int64 {\n\tmilli := m.getExpireAt()\n\tif milli == 0 {\n\t\treturn -1\n\t}\n\treturn milli\n}\n\nfunc (m *RedisMessage) relativePTTL(now time.Time) int64 {\n\treturn m.getExpireAt() - now.UnixMilli()\n}\n\nfunc (m *RedisMessage) getExpireAt() int64 {\n\treturn int64(m.ttl[0]) | int64(m.ttl[1])<<8 | int64(m.ttl[2])<<16 | int64(m.ttl[3])<<24 |\n\t\tint64(m.ttl[4])<<32 | int64(m.ttl[5])<<40 | int64(m.ttl[6])<<48\n}\n\nfunc (m *RedisMessage) setExpireAt(pttl int64) {\n\tm.ttl[0] = byte(pttl)\n\tm.ttl[1] = byte(pttl >> 8)\n\tm.ttl[2] = byte(pttl >> 16)\n\tm.ttl[3] = byte(pttl >> 24)\n\tm.ttl[4] = byte(pttl >> 32)\n\tm.ttl[5] = byte(pttl >> 40)\n\tm.ttl[6] = byte(pttl >> 48)\n}\n\nfunc toMap(values []RedisMessage) (map[string]RedisMessage, error) {\n\tr := make(map[string]RedisMessage, len(values)/2)\n\tfor i := 0; i < len(values); i += 2 {\n\t\tif values[i].typ == typeBlobString || values[i].typ == typeSimpleString {\n\t\t\tr[values[i].string] = values[i+1]\n\t\t\tcontinue\n\t\t}\n\t\ttyp := values[i].typ\n\t\treturn nil, fmt.Errorf(\"%w: redis message type %s as map key is not supported\", errParse, typeNames[typ])\n\t}\n\treturn r, nil\n}\n\nfunc (m *RedisMessage) approximateSize() (s int) {\n\ts += messageStructSize\n\ts += len(m.string)\n\tfor _, v := range m.values {\n\t\ts += v.approximateSize()\n\t}\n\treturn\n}\n\n// String returns human-readable representation of RedisMessage\nfunc (m *RedisMessage) String() string {\n\tv, _ := (*prettyRedisMessage)(m).MarshalJSON()\n\treturn string(v)\n}\n\ntype prettyRedisMessage RedisMessage\n\n// MarshalJSON implements json.Marshaler interface\nfunc (m *prettyRedisMessage) MarshalJSON() ([]byte, error) {\n\ttype PrettyRedisMessage struct {\n\t\tValue any    `json:\"Value,omitempty\"`\n\t\tType  string `json:\"Type,omitempty\"`\n\t\tError string `json:\"Error,omitempty\"`\n\t\tTtl   string `json:\"TTL,omitempty\"`\n\t}\n\torg := (*RedisMessage)(m)\n\tstrType, ok := typeNames[m.typ]\n\tif !ok {\n\t\tstrType = \"unknown\"\n\t}\n\tobj := PrettyRedisMessage{Type: strType}\n\tif m.ttl != [7]byte{} {\n\t\tobj.Ttl = time.UnixMilli(org.CachePXAT()).UTC().String()\n\t}\n\tif err := org.Error(); err != nil {\n\t\tobj.Error = err.Error()\n\t}\n\tswitch m.typ {\n\tcase typeFloat, typeBlobString, typeSimpleString, typeVerbatimString, typeBigNumber:\n\t\tobj.Value = m.string\n\tcase typeBool:\n\t\tobj.Value = m.integer == 1\n\tcase typeInteger:\n\t\tobj.Value = m.integer\n\tcase typeMap, typeSet, typeArray:\n\t\tvalues := make([]prettyRedisMessage, len(m.values))\n\t\tfor i, value := range m.values {\n\t\t\tvalues[i] = prettyRedisMessage(value)\n\t\t}\n\t\tobj.Value = values\n\t}\n\treturn json.Marshal(obj)\n}\n"
        },
        {
          "name": "message_test.go",
          "type": "blob",
          "size": 70.697265625,
          "content": "package rueidis\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype wrapped struct {\n\tmsg string\n\terr error\n}\n\nfunc (e wrapped) Error() string { return e.msg }\nfunc (e wrapped) Unwrap() error { return e.err }\n\nfunc TestIsRedisNil(t *testing.T) {\n\terr := Nil\n\tif !IsRedisNil(err) {\n\t\tt.Fatal(\"IsRedisNil fail\")\n\t}\n\tif IsRedisNil(errors.New(\"other\")) {\n\t\tt.Fatal(\"IsRedisNil fail\")\n\t}\n\tif err.Error() != \"redis nil message\" {\n\t\tt.Fatal(\"IsRedisNil fail\")\n\t}\n\twrappedErr := wrapped{msg: \"wrapped\", err: Nil}\n\tif IsRedisNil(wrappedErr) {\n\t\tt.Fatal(\"IsRedisNil fail : wrapped error\")\n\t}\n}\n\nfunc TestIsParseErr(t *testing.T) {\n\terr := errParse\n\tif !IsParseErr(err) {\n\t\tt.Fatal(\"IsParseErr fail\")\n\t}\n\tif IsParseErr(errors.New(\"other\")) {\n\t\tt.Fatal(\"IsParseErr fail\")\n\t}\n\tif err.Error() != \"rueidis: parse error\" {\n\t\tt.Fatal(\"IsRedisNil fail\")\n\t}\n\twrappedErr := wrapped{msg: \"wrapped\", err: errParse}\n\twrappedNonParseErr := wrapped{msg: \"wrapped\", err: errors.New(\"other\")}\n\tif !IsParseErr(wrappedErr) || IsParseErr(wrappedNonParseErr) {\n\t\tt.Fatal(\"IsParseErr fail : wrapped error\")\n\t}\n}\n\nfunc TestIsRedisErr(t *testing.T) {\n\terr := Nil\n\tif ret, ok := IsRedisErr(err); ok || ret != Nil {\n\t\tt.Fatal(\"TestIsRedisErr fail\")\n\t}\n\tif ret, ok := IsRedisErr(nil); ok || ret != nil {\n\t\tt.Fatal(\"TestIsRedisErr fail\")\n\t}\n\tif ret, ok := IsRedisErr(errors.New(\"other\")); ok || ret != nil {\n\t\tt.Fatal(\"TestIsRedisErr fail\")\n\t}\n\tif ret, ok := IsRedisErr(&RedisError{typ: '-'}); !ok || ret.typ != '-' {\n\t\tt.Fatal(\"TestIsRedisErr fail\")\n\t}\n\twrappedErr := wrapped{msg: \"wrapped\", err: Nil}\n\tif ret, ok := IsRedisErr(wrappedErr); ok || ret == Nil {\n\t\tt.Fatal(\"TestIsRedisErr fail : wrapped error\")\n\t}\n}\n\nfunc TestRedisErrorIsMoved(t *testing.T) {\n\tfor _, c := range []struct {\n\t\terr  string\n\t\taddr string\n\t}{\n\t\t{err: \"MOVED 1 127.0.0.1:1\", addr: \"127.0.0.1:1\"},\n\t\t{err: \"MOVED 1 [::1]:1\", addr: \"[::1]:1\"},\n\t\t{err: \"MOVED 1 ::1:1\", addr: \"[::1]:1\"},\n\t} {\n\t\te := RedisError{typ: '-', string: c.err}\n\t\tif addr, ok := e.IsMoved(); !ok || addr != c.addr {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc TestRedisErrorIsAsk(t *testing.T) {\n\tfor _, c := range []struct {\n\t\terr  string\n\t\taddr string\n\t}{\n\t\t{err: \"ASK 1 127.0.0.1:1\", addr: \"127.0.0.1:1\"},\n\t\t{err: \"ASK 1 [::1]:1\", addr: \"[::1]:1\"},\n\t\t{err: \"ASK 1 ::1:1\", addr: \"[::1]:1\"},\n\t} {\n\t\te := RedisError{typ: '-', string: c.err}\n\t\tif addr, ok := e.IsAsk(); !ok || addr != c.addr {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc TestIsRedisBusyGroup(t *testing.T) {\n\terr := errors.New(\"other\")\n\tif IsRedisBusyGroup(err) {\n\t\tt.Fatal(\"TestIsRedisBusyGroup fail\")\n\t}\n\n\terr = &RedisError{string: \"BUSYGROUP Consumer Group name already exists\"}\n\tif !IsRedisBusyGroup(err) {\n\t\tt.Fatal(\"TestIsRedisBusyGroup fail\")\n\t}\n}\n\n//gocyclo:ignore\nfunc TestRedisResult(t *testing.T) {\n\t//Add erroneous type\n\ttypeNames['t'] = \"t\"\n\n\tt.Run(\"ToInt64\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToInt64(); err == nil {\n\t\t\tt.Fatal(\"ToInt64 not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToInt64(); err == nil {\n\t\t\tt.Fatal(\"ToInt64 not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: ':', integer: 1}}).ToInt64(); v != 1 {\n\t\t\tt.Fatal(\"ToInt64 not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToBool\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToBool(); err == nil {\n\t\t\tt.Fatal(\"ToBool not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToBool(); err == nil {\n\t\t\tt.Fatal(\"ToBool not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '#', integer: 1}}).ToBool(); !v {\n\t\t\tt.Fatal(\"ToBool not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsBool\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsBool(); err == nil {\n\t\t\tt.Fatal(\"ToBool not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsBool(); err == nil {\n\t\t\tt.Fatal(\"ToBool not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '#', integer: 1}}).AsBool(); !v {\n\t\t\tt.Fatal(\"ToBool not get value as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: ':', integer: 1}}).AsBool(); !v {\n\t\t\tt.Fatal(\"ToBool not get value as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"OK\"}}).AsBool(); !v {\n\t\t\tt.Fatal(\"ToBool not get value as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '$', string: \"OK\"}}).AsBool(); !v {\n\t\t\tt.Fatal(\"ToBool not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToFloat64\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToFloat64(); err == nil {\n\t\t\tt.Fatal(\"ToFloat64 not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToFloat64(); err == nil {\n\t\t\tt.Fatal(\"ToFloat64 not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: ',', string: \"0.1\"}}).ToFloat64(); v != 0.1 {\n\t\t\tt.Fatal(\"ToFloat64 not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToString\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToString(); err == nil {\n\t\t\tt.Fatal(\"ToString not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToString(); err == nil {\n\t\t\tt.Fatal(\"ToString not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"0.1\"}}).ToString(); v != \"0.1\" {\n\t\t\tt.Fatal(\"ToString not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsReader\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsReader(); err == nil {\n\t\t\tt.Fatal(\"AsReader not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsReader(); err == nil {\n\t\t\tt.Fatal(\"AsReader not failed as expected\")\n\t\t}\n\t\tr, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"0.1\"}}).AsReader()\n\t\tbs, _ := io.ReadAll(r)\n\t\tif !bytes.Equal(bs, []byte(\"0.1\")) {\n\t\t\tt.Fatalf(\"AsReader not get value as expected %v\", bs)\n\t\t}\n\t})\n\n\tt.Run(\"AsBytes\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsBytes(); err == nil {\n\t\t\tt.Fatal(\"AsBytes not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsBytes(); err == nil {\n\t\t\tt.Fatal(\"AsBytes not failed as expected\")\n\t\t}\n\t\tbs, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"0.1\"}}).AsBytes()\n\t\tif !bytes.Equal(bs, []byte(\"0.1\")) {\n\t\t\tt.Fatalf(\"AsBytes not get value as expected %v\", bs)\n\t\t}\n\t})\n\n\tt.Run(\"DecodeJSON\", func(t *testing.T) {\n\t\tv := map[string]string{}\n\t\tif err := (RedisResult{err: errors.New(\"other\")}).DecodeJSON(&v); err == nil {\n\t\t\tt.Fatal(\"DecodeJSON not failed as expected\")\n\t\t}\n\t\tif err := (RedisResult{val: RedisMessage{typ: '-'}}).DecodeJSON(&v); err == nil {\n\t\t\tt.Fatal(\"DecodeJSON not failed as expected\")\n\t\t}\n\t\tif _ = (RedisResult{val: RedisMessage{typ: '+', string: `{\"k\":\"v\"}`}}).DecodeJSON(&v); v[\"k\"] != \"v\" {\n\t\t\tt.Fatalf(\"DecodeJSON not get value as expected %v\", v)\n\t\t}\n\t})\n\n\tt.Run(\"AsInt64\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsInt64(); err == nil {\n\t\t\tt.Fatal(\"AsInt64 not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsInt64(); err == nil {\n\t\t\tt.Fatal(\"AsInt64 not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"1\"}}).AsInt64(); v != 1 {\n\t\t\tt.Fatal(\"AsInt64 not get value as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: ':', integer: 2}}).AsInt64(); v != 2 {\n\t\t\tt.Fatal(\"AsInt64 not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsUint64\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsUint64(); err == nil {\n\t\t\tt.Fatal(\"AsUint64 not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsUint64(); err == nil {\n\t\t\tt.Fatal(\"AsUint64 not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"1\"}}).AsUint64(); v != 1 {\n\t\t\tt.Fatal(\"AsUint64 not get value as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: ':', integer: 2}}).AsUint64(); v != 2 {\n\t\t\tt.Fatal(\"AsUint64 not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFloat64\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsFloat64(); err == nil {\n\t\t\tt.Fatal(\"AsFloat64 not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsFloat64(); err == nil {\n\t\t\tt.Fatal(\"AsFloat64 not failed as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: '+', string: \"1.1\"}}).AsFloat64(); v != 1.1 {\n\t\t\tt.Fatal(\"AsFloat64 not get value as expected\")\n\t\t}\n\t\tif v, _ := (RedisResult{val: RedisMessage{typ: ',', string: \"2.2\"}}).AsFloat64(); v != 2.2 {\n\t\t\tt.Fatal(\"AsFloat64 not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToArray\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToArray(); err == nil {\n\t\t\tt.Fatal(\"ToArray not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToArray(); err == nil {\n\t\t\tt.Fatal(\"ToArray not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{string: \"item\", typ: '+'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).ToArray(); !reflect.DeepEqual(ret, values) {\n\t\t\tt.Fatal(\"ToArray not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsStrSlice\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsStrSlice(); err == nil {\n\t\t\tt.Fatal(\"AsStrSlice not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsStrSlice(); err == nil {\n\t\t\tt.Fatal(\"AsStrSlice not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{string: \"item\", typ: '+'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsStrSlice(); !reflect.DeepEqual(ret, []string{\"item\"}) {\n\t\t\tt.Fatal(\"AsStrSlice not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsIntSlice\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsIntSlice(); err == nil {\n\t\t\tt.Fatal(\"AsIntSlice not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsIntSlice(); err == nil {\n\t\t\tt.Fatal(\"AsIntSlice not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{integer: 2, typ: ':'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsIntSlice(); !reflect.DeepEqual(ret, []int64{2}) {\n\t\t\tt.Fatal(\"AsIntSlice not get value as expected\")\n\t\t}\n\t\tvalues = []RedisMessage{{string: \"3\", typ: '+'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsIntSlice(); !reflect.DeepEqual(ret, []int64{3}) {\n\t\t\tt.Fatal(\"AsIntSlice not get value as expected\")\n\t\t}\n\t\tvalues = []RedisMessage{{string: \"ab\", typ: '+'}}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsIntSlice(); err == nil {\n\t\t\tt.Fatal(\"AsIntSlice not failed as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFloatSlice\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsFloatSlice(); err == nil {\n\t\t\tt.Fatal(\"AsFloatSlice not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsFloatSlice(); err == nil {\n\t\t\tt.Fatal(\"AsFloatSlice not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"fff\", typ: ','}}}}).AsFloatSlice(); err == nil {\n\t\t\tt.Fatal(\"AsFloatSlice not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{integer: 1, typ: ':'}, {string: \"2\", typ: '+'}, {string: \"3\", typ: '$'}, {string: \"4\", typ: ','}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsFloatSlice(); !reflect.DeepEqual(ret, []float64{1, 2, 3, 4}) {\n\t\t\tt.Fatal(\"AsFloatSlice not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsBoolSlice\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsBoolSlice(); err == nil {\n\t\t\tt.Fatal(\"AsBoolSlice not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsBoolSlice(); err == nil {\n\t\t\tt.Fatal(\"AsBoolSlice not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{integer: 1, typ: ':'}, {string: \"0\", typ: '+'}, {integer: 1, typ: typeBool}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsBoolSlice(); !reflect.DeepEqual(ret, []bool{true, false, true}) {\n\t\t\tt.Fatal(\"AsBoolSlice not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsMap\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsMap(); err == nil {\n\t\t\tt.Fatal(\"AsMap not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsMap(); err == nil {\n\t\t\tt.Fatal(\"AsMap not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{string: \"key\", typ: '+'}, {string: \"value\", typ: '+'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsMap(); !reflect.DeepEqual(map[string]RedisMessage{\n\t\t\tvalues[0].string: values[1],\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsMap not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsStrMap\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsStrMap(); err == nil {\n\t\t\tt.Fatal(\"AsStrMap not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsStrMap(); err == nil {\n\t\t\tt.Fatal(\"AsStrMap not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{string: \"key\", typ: '+'}, {string: \"value\", typ: '+'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsStrMap(); !reflect.DeepEqual(map[string]string{\n\t\t\tvalues[0].string: values[1].string,\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsStrMap not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsIntMap\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsIntMap(); err == nil {\n\t\t\tt.Fatal(\"AsIntMap not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsIntMap(); err == nil {\n\t\t\tt.Fatal(\"AsIntMap not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"key\", typ: '+'}, {string: \"value\", typ: '+'}}}}).AsIntMap(); err == nil {\n\t\t\tt.Fatal(\"AsIntMap not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{string: \"k1\", typ: '+'}, {string: \"1\", typ: '+'}, {string: \"k2\", typ: '+'}, {integer: 2, typ: ':'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: values}}).AsIntMap(); !reflect.DeepEqual(map[string]int64{\n\t\t\t\"k1\": 1,\n\t\t\t\"k2\": 2,\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsIntMap not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToMap\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToMap(); err == nil {\n\t\t\tt.Fatal(\"ToMap not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToMap(); err == nil {\n\t\t\tt.Fatal(\"ToMap not failed as expected\")\n\t\t}\n\t\tvalues := []RedisMessage{{string: \"key\", typ: '+'}, {string: \"value\", typ: '+'}}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '%', values: values}}).ToMap(); !reflect.DeepEqual(map[string]RedisMessage{\n\t\t\tvalues[0].string: values[1],\n\t\t}, ret) {\n\t\t\tt.Fatal(\"ToMap not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToAny\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).ToAny(); err == nil {\n\t\t\tt.Fatal(\"ToAny not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).ToAny(); err == nil {\n\t\t\tt.Fatal(\"ToAny not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '%', values: []RedisMessage{{typ: '+', string: \"key\"}, {typ: ':', integer: 1}}},\n\t\t\t{typ: '%', values: []RedisMessage{{typ: '+', string: \"nil\"}, {typ: '_'}}},\n\t\t\t{typ: '%', values: []RedisMessage{{typ: '+', string: \"err\"}, {typ: '-', string: \"err\"}}},\n\t\t\t{typ: ',', string: \"1.2\"},\n\t\t\t{typ: '+', string: \"str\"},\n\t\t\t{typ: '#', integer: 0},\n\t\t\t{typ: '-', string: \"err\"},\n\t\t\t{typ: '_'},\n\t\t}}}).ToAny(); !reflect.DeepEqual([]any{\n\t\t\tmap[string]any{\"key\": int64(1)},\n\t\t\tmap[string]any{\"nil\": nil},\n\t\t\tmap[string]any{\"err\": &RedisError{typ: '-', string: \"err\"}},\n\t\t\t1.2,\n\t\t\t\"str\",\n\t\t\tfalse,\n\t\t\t&RedisError{typ: '-', string: \"err\"},\n\t\t\tnil,\n\t\t}, ret) {\n\t\t\tt.Fatal(\"ToAny not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsXRangeEntry\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"id\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}, {typ: '+', string: \"b\"}}}}}}).AsXRangeEntry(); !reflect.DeepEqual(XRangeEntry{\n\t\t\tID:          \"id\",\n\t\t\tFieldValues: map[string]string{\"a\": \"b\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsXRangeEntry not get value as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"id\", typ: '+'}, {typ: '_'}}}}).AsXRangeEntry(); !reflect.DeepEqual(XRangeEntry{\n\t\t\tID:          \"id\",\n\t\t\tFieldValues: nil,\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsXRangeEntry not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsXRange\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsXRange(); err == nil {\n\t\t\tt.Fatal(\"AsXRange not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsXRange(); err == nil {\n\t\t\tt.Fatal(\"AsXRange not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{{string: \"id1\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}, {typ: '+', string: \"b\"}}}}},\n\t\t\t{typ: '*', values: []RedisMessage{{string: \"id2\", typ: '+'}, {typ: '_'}}},\n\t\t}}}).AsXRange(); !reflect.DeepEqual([]XRangeEntry{{\n\t\t\tID:          \"id1\",\n\t\t\tFieldValues: map[string]string{\"a\": \"b\"},\n\t\t}, {\n\t\t\tID:          \"id2\",\n\t\t\tFieldValues: nil,\n\t\t}}, ret) {\n\t\t\tt.Fatal(\"AsXRange not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsXRead\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '%', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"stream1\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '*', values: []RedisMessage{{string: \"id1\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}, {typ: '+', string: \"b\"}}}}},\n\t\t\t\t{typ: '*', values: []RedisMessage{{string: \"id2\", typ: '+'}, {typ: '_'}}},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"stream2\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '*', values: []RedisMessage{{string: \"id3\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"c\"}, {typ: '+', string: \"d\"}}}}},\n\t\t\t}},\n\t\t}}}).AsXRead(); !reflect.DeepEqual(map[string][]XRangeEntry{\n\t\t\t\"stream1\": {\n\t\t\t\t{ID: \"id1\", FieldValues: map[string]string{\"a\": \"b\"}},\n\t\t\t\t{ID: \"id2\", FieldValues: nil}},\n\t\t\t\"stream2\": {\n\t\t\t\t{ID: \"id3\", FieldValues: map[string]string{\"c\": \"d\"}},\n\t\t\t},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsXRead not get value as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"stream1\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '*', values: []RedisMessage{{string: \"id1\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}, {typ: '+', string: \"b\"}}}}},\n\t\t\t\t\t{typ: '*', values: []RedisMessage{{string: \"id2\", typ: '+'}, {typ: '_'}}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"stream2\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '*', values: []RedisMessage{{string: \"id3\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"c\"}, {typ: '+', string: \"d\"}}}}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsXRead(); !reflect.DeepEqual(map[string][]XRangeEntry{\n\t\t\t\"stream1\": {\n\t\t\t\t{ID: \"id1\", FieldValues: map[string]string{\"a\": \"b\"}},\n\t\t\t\t{ID: \"id2\", FieldValues: nil}},\n\t\t\t\"stream2\": {\n\t\t\t\t{ID: \"id3\", FieldValues: map[string]string{\"c\": \"d\"}},\n\t\t\t},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsXRead not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsZScore\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsZScore(); err == nil {\n\t\t\tt.Fatal(\"AsZScore not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsZScore(); err == nil {\n\t\t\tt.Fatal(\"AsZScore not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"m1\"},\n\t\t\t{typ: '+', string: \"1\"},\n\t\t}}}).AsZScore(); !reflect.DeepEqual(ZScore{Member: \"m1\", Score: 1}, ret) {\n\t\t\tt.Fatal(\"AsZScore not get value as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"m1\"},\n\t\t\t{typ: ',', string: \"1\"},\n\t\t}}}).AsZScore(); !reflect.DeepEqual(ZScore{Member: \"m1\", Score: 1}, ret) {\n\t\t\tt.Fatal(\"AsZScore not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsZScores\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsZScores(); err == nil {\n\t\t\tt.Fatal(\"AsZScores not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsZScores(); err == nil {\n\t\t\tt.Fatal(\"AsZScores not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"m1\"},\n\t\t\t{typ: '+', string: \"1\"},\n\t\t\t{typ: '+', string: \"m2\"},\n\t\t\t{typ: '+', string: \"2\"},\n\t\t}}}).AsZScores(); !reflect.DeepEqual([]ZScore{\n\t\t\t{Member: \"m1\", Score: 1},\n\t\t\t{Member: \"m2\", Score: 2},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsZScores not get value as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"m1\"},\n\t\t\t\t{typ: ',', string: \"1\"},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"m2\"},\n\t\t\t\t{typ: ',', string: \"2\"},\n\t\t\t}},\n\t\t}}}).AsZScores(); !reflect.DeepEqual([]ZScore{\n\t\t\t{Member: \"m1\", Score: 1},\n\t\t\t{Member: \"m2\", Score: 2},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsZScores not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsLMPop\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsLMPop(); err == nil {\n\t\t\tt.Fatal(\"AsLMPop not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsLMPop(); err == nil {\n\t\t\tt.Fatal(\"AsLMPop not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"k\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t}},\n\t\t}}}).AsLMPop(); !reflect.DeepEqual(KeyValues{\n\t\t\tKey:    \"k\",\n\t\t\tValues: []string{\"1\", \"2\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsZScores not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsZMPop\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsZMPop(); err == nil {\n\t\t\tt.Fatal(\"AsZMPop not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsZMPop(); err == nil {\n\t\t\tt.Fatal(\"AsZMPop not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"k\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ',', string: \"1\"},\n\t\t\t\t}},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: ',', string: \"2\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsZMPop(); !reflect.DeepEqual(KeyZScores{\n\t\t\tKey: \"k\",\n\t\t\tValues: []ZScore{\n\t\t\t\t{Member: \"1\", Score: 1},\n\t\t\t\t{Member: \"2\", Score: 2},\n\t\t\t},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsZMPop not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFtSearch\", func(t *testing.T) {\n\t\tif _, _, err := (RedisResult{err: errors.New(\"other\")}).AsFtSearch(); err == nil {\n\t\t\tt.Fatal(\"AsFtSearch not failed as expected\")\n\t\t}\n\t\tif _, _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsFtSearch(); err == nil {\n\t\t\tt.Fatal(\"AsFtSearch not failed as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"a\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"b\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k2\"},\n\t\t\t\t{typ: '+', string: \"v2\"},\n\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t}},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"a\", Doc: map[string]string{\"k1\": \"v1\", \"kk\": \"vv\"}},\n\t\t\t{Key: \"b\", Doc: map[string]string{\"k2\": \"v2\", \"kk\": \"vv\"}},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"a\"},\n\t\t\t{typ: '+', string: \"1\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"b\"},\n\t\t\t{typ: '+', string: \"2\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k2\"},\n\t\t\t\t{typ: '+', string: \"v2\"},\n\t\t\t}},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"a\", Doc: map[string]string{\"k1\": \"v1\"}, Score: 1},\n\t\t\t{Key: \"b\", Doc: map[string]string{\"k2\": \"v2\"}, Score: 2},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"a\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t}},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"a\", Doc: map[string]string{\"k1\": \"v1\", \"kk\": \"vv\"}},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"a\"},\n\t\t\t{typ: '+', string: \"b\"},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"a\", Doc: nil},\n\t\t\t{Key: \"b\", Doc: nil},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"a\"},\n\t\t\t{typ: '+', string: \"1\"},\n\t\t\t{typ: '+', string: \"b\"},\n\t\t\t{typ: '+', string: \"2\"},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"a\", Doc: nil, Score: 1},\n\t\t\t{Key: \"b\", Doc: nil, Score: 2},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"1\"},\n\t\t\t{typ: '+', string: \"2\"},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"1\", Doc: nil},\n\t\t\t{Key: \"2\", Doc: nil},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"a\"},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"a\", Doc: nil},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFtSearch RESP3\", func(t *testing.T) {\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '%', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"total_results\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"results\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"id\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{typ: '+', string: \"score\"},\n\t\t\t\t\t{typ: ',', string: \"1\"},\n\t\t\t\t}},\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"id\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{typ: '+', string: \"score\"},\n\t\t\t\t\t{typ: ',', string: \"2\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"error\"},\n\t\t\t{typ: '*', values: []RedisMessage{}},\n\t\t}}}).AsFtSearch(); n != 3 || !reflect.DeepEqual([]FtSearchDoc{\n\t\t\t{Key: \"1\", Doc: map[string]string{\"$\": \"1\"}, Score: 1},\n\t\t\t{Key: \"2\", Doc: map[string]string{\"$\": \"2\"}, Score: 2},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t\tif _, _, err := (RedisResult{val: RedisMessage{typ: '%', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"total_results\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"results\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"id\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t}},\n\t\t\t\t\t{typ: '+', string: \"score\"},\n\t\t\t\t\t{typ: ',', string: \"1\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"error\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"mytimeout\"},\n\t\t\t}},\n\t\t}}}).AsFtSearch(); err == nil || err.Error() != \"mytimeout\" {\n\t\t\tt.Fatal(\"AsFtSearch not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFtAggregate\", func(t *testing.T) {\n\t\tif _, _, err := (RedisResult{err: errors.New(\"other\")}).AsFtAggregate(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregate not failed as expected\")\n\t\t}\n\t\tif _, _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsFtAggregate(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregate not failed as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k2\"},\n\t\t\t\t{typ: '+', string: \"v2\"},\n\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t}},\n\t\t}}}).AsFtAggregate(); n != 3 || !reflect.DeepEqual([]map[string]string{\n\t\t\t{\"k1\": \"v1\", \"kk\": \"vv\"},\n\t\t\t{\"k2\": \"v2\", \"kk\": \"vv\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t}},\n\t\t}}}).AsFtAggregate(); n != 3 || !reflect.DeepEqual([]map[string]string{\n\t\t\t{\"k1\": \"v1\", \"kk\": \"vv\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: ':', integer: 3},\n\t\t}}}).AsFtAggregate(); n != 3 || !reflect.DeepEqual([]map[string]string{}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFtAggregate RESP3\", func(t *testing.T) {\n\t\tif n, ret, _ := (RedisResult{val: RedisMessage{typ: '%', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"total_results\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"results\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"error\"},\n\t\t\t{typ: '*', values: []RedisMessage{}},\n\t\t}}}).AsFtAggregate(); n != 3 || !reflect.DeepEqual([]map[string]string{\n\t\t\t{\"$\": \"1\"},\n\t\t\t{\"$\": \"2\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t\tif _, _, err := (RedisResult{val: RedisMessage{typ: '%', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"total_results\"},\n\t\t\t{typ: ':', integer: 3},\n\t\t\t{typ: '+', string: \"results\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '+', string: \"error\"},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"mytimeout\"},\n\t\t\t}},\n\t\t}}}).AsFtAggregate(); err == nil || err.Error() != \"mytimeout\" {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFtAggregate Cursor\", func(t *testing.T) {\n\t\tif _, _, _, err := (RedisResult{err: errors.New(\"other\")}).AsFtAggregateCursor(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregate not failed as expected\")\n\t\t}\n\t\tif _, _, _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsFtAggregateCursor(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregate not failed as expected\")\n\t\t}\n\t\tif c, n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t\t}},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"k2\"},\n\t\t\t\t\t{typ: '+', string: \"v2\"},\n\t\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: ':', integer: 1},\n\t\t}}}).AsFtAggregateCursor(); c != 1 || n != 3 || !reflect.DeepEqual([]map[string]string{\n\t\t\t{\"k1\": \"v1\", \"kk\": \"vv\"},\n\t\t\t{\"k2\": \"v2\", \"kk\": \"vv\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t\tif c, n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"k1\"},\n\t\t\t\t\t{typ: '+', string: \"v1\"},\n\t\t\t\t\t{typ: '+', string: \"kk\"},\n\t\t\t\t\t{typ: '+', string: \"vv\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: ':', integer: 1},\n\t\t}}}).AsFtAggregateCursor(); c != 1 || n != 3 || !reflect.DeepEqual([]map[string]string{\n\t\t\t{\"k1\": \"v1\", \"kk\": \"vv\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t\tif c, n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 3},\n\t\t\t}},\n\t\t\t{typ: ':', integer: 1},\n\t\t}}}).AsFtAggregateCursor(); c != 1 || n != 3 || !reflect.DeepEqual([]map[string]string{}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsFtAggregate Cursor RESP3\", func(t *testing.T) {\n\t\tif c, n, ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"total_results\"},\n\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t{typ: '+', string: \"results\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t\t{typ: '+', string: \"error\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{}},\n\t\t\t}},\n\t\t\t{typ: ':', integer: 1},\n\t\t}}}).AsFtAggregateCursor(); c != 1 || n != 3 || !reflect.DeepEqual([]map[string]string{\n\t\t\t{\"$\": \"1\"},\n\t\t\t{\"$\": \"2\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t\tif _, _, _, err := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"total_results\"},\n\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t{typ: '+', string: \"results\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"extra_attributes\"},\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"$\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t\t{typ: '+', string: \"error\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"mytimeout\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: ':', integer: 1},\n\t\t}}}).AsFtAggregateCursor(); err == nil || err.Error() != \"mytimeout\" {\n\t\t\tt.Fatal(\"AsFtAggregate not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsGeosearch\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsGeosearch(); err == nil {\n\t\t\tt.Fatal(\"AsGeosearch not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsGeosearch(); err == nil {\n\t\t\tt.Fatal(\"AsGeosearch not failed as expected\")\n\t\t}\n\t\t//WithDist, WithHash, WithCoord\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: ',', string: \"2.5\"},\n\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"28.0473\"},\n\t\t\t\t\t{typ: ',', string: \"26.2041\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: ',', string: \"4.5\"},\n\t\t\t\t{typ: ':', integer: 4},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"72.4973\"},\n\t\t\t\t\t{typ: ',', string: \"13.2263\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\", Dist: 2.5, GeoHash: 1, Longitude: 28.0473, Latitude: 26.2041},\n\t\t\t{Name: \"k2\", Dist: 4.5, GeoHash: 4, Longitude: 72.4973, Latitude: 13.2263},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//WithHash, WithCoord\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"84.3877\"},\n\t\t\t\t\t{typ: ',', string: \"33.7488\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: ':', integer: 4},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"115.8613\"},\n\t\t\t\t\t{typ: ',', string: \"31.9523\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\", GeoHash: 1, Longitude: 84.3877, Latitude: 33.7488},\n\t\t\t{Name: \"k2\", GeoHash: 4, Longitude: 115.8613, Latitude: 31.9523},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//WithDist, WithCoord\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: ',', string: \"2.50076\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"84.3877\"},\n\t\t\t\t\t{typ: ',', string: \"33.7488\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: ',', string: \"1024.96\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"115.8613\"},\n\t\t\t\t\t{typ: ',', string: \"31.9523\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\", Dist: 2.50076, Longitude: 84.3877, Latitude: 33.7488},\n\t\t\t{Name: \"k2\", Dist: 1024.96, Longitude: 115.8613, Latitude: 31.9523},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//WithCoord\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"122.4194\"},\n\t\t\t\t\t{typ: ',', string: \"37.7749\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"35.6762\"},\n\t\t\t\t\t{typ: ',', string: \"139.6503\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\", Longitude: 122.4194, Latitude: 37.7749},\n\t\t\t{Name: \"k2\", Longitude: 35.6762, Latitude: 139.6503},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//WithDist\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: ',', string: \"2.50076\"},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: ',', string: strconv.FormatFloat(math.MaxFloat64, 'E', -1, 64)},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\", Dist: 2.50076},\n\t\t\t{Name: \"k2\", Dist: math.MaxFloat64},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//WithHash\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: ':', integer: math.MaxInt64},\n\t\t\t}},\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: ':', integer: 22296},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\", GeoHash: math.MaxInt64},\n\t\t\t{Name: \"k2\", GeoHash: 22296},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//With no additional options\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t{typ: '$', string: \"k2\"},\n\t\t}}}).AsGeosearch(); !reflect.DeepEqual([]GeoLocation{\n\t\t\t{Name: \"k1\"},\n\t\t\t{Name: \"k2\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsGeosearch not get value as expected\")\n\t\t}\n\t\t//With wrong distance\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k1\"},\n\t\t\t\t{typ: ',', string: \"wrong distance\"},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); err == nil {\n\t\t\tt.Fatal(\"AsGeosearch not failed as expected\")\n\t\t}\n\t\t//With wrong coordinates\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '$', string: \"k2\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ',', string: \"35.6762\"},\n\t\t\t\t}},\n\t\t\t}},\n\t\t}}}).AsGeosearch(); err == nil {\n\t\t\tt.Fatal(\"AsGeosearch not failed as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"IsCacheHit\", func(t *testing.T) {\n\t\tif (RedisResult{err: errors.New(\"other\")}).IsCacheHit() {\n\t\t\tt.Fatal(\"IsCacheHit not as expected\")\n\t\t}\n\t\tif !(RedisResult{val: RedisMessage{attrs: cacheMark}}).IsCacheHit() {\n\t\t\tt.Fatal(\"IsCacheHit not as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"CacheTTL\", func(t *testing.T) {\n\t\tif (RedisResult{err: errors.New(\"other\")}).CacheTTL() != -1 {\n\t\t\tt.Fatal(\"CacheTTL != -1\")\n\t\t}\n\t\tm := RedisMessage{}\n\t\tm.setExpireAt(time.Now().Add(time.Millisecond * 100).UnixMilli())\n\t\tif (RedisResult{val: m}).CacheTTL() <= 0 {\n\t\t\tt.Fatal(\"CacheTTL <= 0\")\n\t\t}\n\t\ttime.Sleep(150 * time.Millisecond)\n\t\tif (RedisResult{val: m}).CacheTTL() != 0 {\n\t\t\tt.Fatal(\"CacheTTL != 0\")\n\t\t}\n\t})\n\n\tt.Run(\"CachePTTL\", func(t *testing.T) {\n\t\tif (RedisResult{err: errors.New(\"other\")}).CachePTTL() != -1 {\n\t\t\tt.Fatal(\"CachePTTL != -1\")\n\t\t}\n\t\tm := RedisMessage{}\n\t\tm.setExpireAt(time.Now().Add(time.Millisecond * 100).UnixMilli())\n\t\tif (RedisResult{val: m}).CachePTTL() <= 0 {\n\t\t\tt.Fatal(\"CachePTTL <= 0\")\n\t\t}\n\t\ttime.Sleep(150 * time.Millisecond)\n\t\tif (RedisResult{val: m}).CachePTTL() != 0 {\n\t\t\tt.Fatal(\"CachePTTL != 0\")\n\t\t}\n\t})\n\n\tt.Run(\"CachePXAT\", func(t *testing.T) {\n\t\tif (RedisResult{err: errors.New(\"other\")}).CachePXAT() != -1 {\n\t\t\tt.Fatal(\"CachePTTL != -1\")\n\t\t}\n\t\tm := RedisMessage{}\n\t\tm.setExpireAt(time.Now().Add(time.Millisecond * 100).UnixMilli())\n\t\tif (RedisResult{val: m}).CachePXAT() <= 0 {\n\t\t\tt.Fatal(\"CachePXAT <= 0\")\n\t\t}\n\t})\n\n\tt.Run(\"Stringer\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tinput    RedisResult\n\t\t\texpected string\n\t\t}{\n\t\t\t{\n\t\t\t\tinput: RedisResult{\n\t\t\t\t\tval: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t{typ: '*', values: []RedisMessage{ // master\n\t\t\t\t\t\t\t\t{typ: '+', string: \"127.0.3.1\"},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"\"},\n\t\t\t\t\t\t\t}},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t\texpected: `{\"Message\":{\"Value\":[{\"Value\":[{\"Value\":0,\"Type\":\"int64\"},{\"Value\":0,\"Type\":\"int64\"},{\"Value\":[{\"Value\":\"127.0.3.1\",\"Type\":\"simple string\"},{\"Value\":3,\"Type\":\"int64\"},{\"Value\":\"\",\"Type\":\"simple string\"}],\"Type\":\"array\"}],\"Type\":\"array\"}],\"Type\":\"array\"}}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisResult{err: errors.New(\"foo\")},\n\t\t\t\texpected: `{\"Error\":\"foo\"}`,\n\t\t\t},\n\t\t}\n\t\tfor _, test := range tests {\n\t\t\tmsg := test.input.String()\n\t\t\tif msg != test.expected {\n\t\t\t\tt.Fatalf(\"unexpected string. got %v expected %v\", msg, test.expected)\n\t\t\t}\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestRedisMessage(t *testing.T) {\n\t//Add erroneous type\n\ttypeNames['t'] = \"t\"\n\n\tt.Run(\"IsNil\", func(t *testing.T) {\n\t\tif !(&RedisMessage{typ: '_'}).IsNil() {\n\t\t\tt.Fatal(\"IsNil fail\")\n\t\t}\n\t})\n\tt.Run(\"Trim ERR prefix\", func(t *testing.T) {\n\t\t// kvrocks: https://github.com/redis/rueidis/issues/152#issuecomment-1333923750\n\t\tif (&RedisMessage{typ: '-', string: \"ERR no_prefix\"}).Error().Error() != \"no_prefix\" {\n\t\t\tt.Fatal(\"fail to trim ERR\")\n\t\t}\n\t})\n\tt.Run(\"ToInt64\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 int64\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToInt64(); err == nil {\n\t\t\tt.Fatal(\"ToInt64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %d\", val)\n\t\t}\n\n\t\t// Test case where the message type is 't', which is not a RESP3 int64\n\t\tif val, err := (&RedisMessage{typ: 't'}).ToInt64(); err == nil {\n\t\t\tt.Fatal(\"ToInt64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %d\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a RESP3 int64\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"ToBool\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 bool\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToBool(); err == nil {\n\t\t\tt.Fatal(\"ToBool did not fail as expected\")\n\t\t} else if val != false {\n\t\t\tt.Fatalf(\"expected false, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is 't', which is not a RESP3 bool\n\t\tif val, err := (&RedisMessage{typ: 't'}).ToBool(); err == nil {\n\t\t\tt.Fatal(\"ToBool did not fail as expected\")\n\t\t} else if val != false {\n\t\t\tt.Fatalf(\"expected false, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a RESP3 bool\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsBool\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 int, string, or bool\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsBool(); err == nil {\n\t\t\tt.Fatal(\"AsBool did not fail as expected\")\n\t\t} else if val != false {\n\t\t\tt.Fatalf(\"expected false, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is 't', which is not a RESP3 int, string, or bool\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsBool(); err == nil {\n\t\t\tt.Fatal(\"AsBool did not fail as expected\")\n\t\t} else if val != false {\n\t\t\tt.Fatalf(\"expected false, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a int, string or bool\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"ToFloat64\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 float64\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToFloat64(); err == nil {\n\t\t\tt.Fatal(\"ToFloat64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %f\", val)\n\t\t}\n\n\t\t// Test case where the message type is 't', which is not a RESP3 float64\n\t\tif val, err := (&RedisMessage{typ: 't'}).ToFloat64(); err == nil {\n\t\t\tt.Fatal(\"ToFloat64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %f\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a RESP3 float64\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"ToString\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToString(); err == nil {\n\t\t\tt.Fatal(\"ToString did not fail as expected\")\n\t\t} else if val != \"\" {\n\t\t\tt.Fatalf(\"expected empty string, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is ':', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: ':'}).ToString(); err == nil {\n\t\t\tt.Fatal(\"ToString did not fail as expected\")\n\t\t} else if val != \"\" {\n\t\t\tt.Fatalf(\"expected empty string, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames[':'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsReader\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsReader(); err == nil {\n\t\t\tt.Fatal(\"AsReader did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is ':', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: ':'}).AsReader(); err == nil {\n\t\t\tt.Fatal(\"AsReader did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames[':'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsBytes\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsBytes(); err == nil {\n\t\t\tt.Fatal(\"AsBytes did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is ':', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: ':'}).AsBytes(); err == nil {\n\t\t\tt.Fatal(\"AsBytes did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames[':'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"DecodeJSON\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif err := (&RedisMessage{typ: '_'}).DecodeJSON(nil); err == nil {\n\t\t\tt.Fatal(\"DecodeJSON did not fail as expected\")\n\t\t}\n\n\t\t// Test case where the message type is ':', which is not a RESP3 string\n\t\tif err := (&RedisMessage{typ: ':'}).DecodeJSON(nil); err == nil {\n\t\t\tt.Fatal(\"DecodeJSON did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames[':'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsInt64\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsInt64(); err == nil {\n\t\t\tt.Fatal(\"AsInt64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %d\", val)\n\t\t}\n\n\t\t// Test case where the message type is '*', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '*', values: []RedisMessage{{}}}).AsInt64(); err == nil {\n\t\t\tt.Fatal(\"AsInt64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %d\", val)\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsUint64\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsUint64(); err == nil {\n\t\t\tt.Fatal(\"AsUint64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %d\", val)\n\t\t}\n\n\t\t// Test case where the message type is '*', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '*', values: []RedisMessage{{}}}).AsUint64(); err == nil {\n\t\t\tt.Fatal(\"AsUint64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %d\", val)\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsFloat64\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsFloat64(); err == nil {\n\t\t\tt.Fatal(\"AsFloat64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %f\", val)\n\t\t}\n\n\t\t// Test case where the message type is ':', which is not a RESP3 string\n\t\tif val, err := (&RedisMessage{typ: ':'}).AsFloat64(); err == nil {\n\t\t\tt.Fatal(\"AsFloat64 did not fail as expected\")\n\t\t} else if val != 0 {\n\t\t\tt.Fatalf(\"expected 0, got %f\", val)\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames[':'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"ToArray\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 array\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToArray(); err == nil {\n\t\t\tt.Fatal(\"ToArray did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is 't', which is not a RESP3 array\n\t\tif val, err := (&RedisMessage{typ: 't'}).ToArray(); err == nil {\n\t\t\tt.Fatal(\"ToArray did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a array\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsStrSlice\", func(t *testing.T) {\n\t\t// Test case where the message type is '_', which is not a RESP3 array\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsStrSlice(); err == nil {\n\t\t\tt.Fatal(\"AsStrSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\t// Test case where the message type is 't', which is not a RESP3 array\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsStrSlice(); err == nil {\n\t\t\tt.Fatal(\"AsStrSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a array\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsIntSlice\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsIntSlice(); err == nil {\n\t\t\tt.Fatal(\"AsIntSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsIntSlice(); err == nil {\n\t\t\tt.Fatal(\"AsIntSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a array\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsFloatSlice\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsFloatSlice(); err == nil {\n\t\t\tt.Fatal(\"AsFloatSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsFloatSlice(); err == nil {\n\t\t\tt.Fatal(\"AsFloatSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a array\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsBoolSlice\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsBoolSlice(); err == nil {\n\t\t\tt.Fatal(\"AsBoolSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsBoolSlice(); err == nil {\n\t\t\tt.Fatal(\"AsBoolSlice did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a array\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsMap\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsMap(); err == nil {\n\t\t\tt.Fatal(\"AsMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsMap(); err == nil {\n\t\t\tt.Fatal(\"AsMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a map/array/set or its length is not even\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsStrMap\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsStrMap(); err == nil {\n\t\t\tt.Fatal(\"AsStrMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsStrMap(); err == nil {\n\t\t\tt.Fatal(\"AsStrMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a map/array/set\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsIntMap\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).AsIntMap(); err == nil {\n\t\t\tt.Fatal(\"AsIntMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).AsIntMap(); err == nil {\n\t\t\tt.Fatal(\"AsIntMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a map/array/set\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"ToMap\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToMap(); err == nil {\n\t\t\tt.Fatal(\"ToMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).ToMap(); err == nil {\n\t\t\tt.Fatal(\"ToMap did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a RESP3 map\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"ToAny\", func(t *testing.T) {\n\t\tif val, err := (&RedisMessage{typ: '_'}).ToAny(); err == nil {\n\t\t\tt.Fatal(\"ToAny did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t}\n\n\t\tif val, err := (&RedisMessage{typ: 't'}).ToAny(); err == nil {\n\t\t\tt.Fatal(\"ToAny did not fail as expected\")\n\t\t} else if val != nil {\n\t\t\tt.Fatalf(\"expected nil, got %v\", val)\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a supported in ToAny\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsXRangeEntry - no range id\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*'}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{{typ: '_'}, {typ: '%'}}}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{{typ: ':'}, {typ: '%'}}}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a string\", typeNames[':'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsXRangeEntry - no range field values\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*'}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{{typ: '+'}, {typ: '-'}}}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{{typ: '+'}, {typ: 't'}}}).AsXRangeEntry(); err == nil {\n\t\t\tt.Fatal(\"AsXRangeEntry did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a map/array/set\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsXRange\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsXRange(); err == nil {\n\t\t\tt.Fatal(\"AsXRange not failed as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{{typ: '_'}}}).AsXRange(); err == nil {\n\t\t\tt.Fatal(\"AsXRange not failed as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsXRead\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '%', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"stream1\"},\n\t\t\t{typ: '*', values: []RedisMessage{{typ: '*', values: []RedisMessage{{string: \"id1\", typ: '+'}}}}},\n\t\t}}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"stream1\"},\n\t\t\t}},\n\t\t}}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"stream1\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{{typ: '*', values: []RedisMessage{{string: \"id1\", typ: '+'}}}}},\n\t\t\t}},\n\t\t}}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: 't'}).AsXRead(); err == nil {\n\t\t\tt.Fatal(\"AsXRead did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), \"redis message type t is not a map/array/set\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsZScore\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsZScore(); err == nil {\n\t\t\tt.Fatal(\"AsZScore did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*'}).AsZScore(); err == nil {\n\t\t\tt.Fatal(\"AsZScore did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), \"redis message is not a map/array/set or its length is not 2\") {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsZScores\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsZScores(); err == nil {\n\t\t\tt.Fatal(\"AsZScore not failed as expected\")\n\t\t}\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"m1\"},\n\t\t\t{typ: '+', string: \"m2\"},\n\t\t}}).AsZScores(); err == nil {\n\t\t\tt.Fatal(\"AsZScores not fails as expected\")\n\t\t}\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"m1\"},\n\t\t\t\t{typ: '+', string: \"m2\"},\n\t\t\t}},\n\t\t}}).AsZScores(); err == nil {\n\t\t\tt.Fatal(\"AsZScores not fails as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"AsLMPop\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsLMPop(); err == nil {\n\t\t\tt.Fatal(\"AsLMPop did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"k\"},\n\t\t\t{typ: '_'},\n\t\t}}).AsLMPop(); err == nil {\n\t\t\tt.Fatal(\"AsLMPop did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"k\"},\n\t\t}}).AsLMPop(); err == nil {\n\t\t\tt.Fatal(\"AsLMPop did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a LMPOP response\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsZMPop\", func(t *testing.T) {\n\t\tif _, err := (&RedisMessage{typ: '_'}).AsZMPop(); err == nil {\n\t\t\tt.Fatal(\"AsZMPop did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"k\"},\n\t\t\t{typ: '_'},\n\t\t}}).AsZMPop(); err == nil {\n\t\t\tt.Fatal(\"AsZMPop did not fail as expected\")\n\t\t}\n\n\t\tif _, err := (&RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"k\"},\n\t\t}}).AsZMPop(); err == nil {\n\t\t\tt.Fatal(\"AsZMPop did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a ZMPOP response\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsFtSearch\", func(t *testing.T) {\n\t\tif _, _, err := (&RedisMessage{typ: '_'}).AsFtSearch(); err == nil {\n\t\t\tt.Fatal(\"AsFtSearch did not fail as expected\")\n\t\t}\n\n\t\tif _, _, err := (&RedisMessage{typ: '*'}).AsFtSearch(); err == nil {\n\t\t\tt.Fatal(\"AsFtSearch did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a FT.SEARCH response\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsFtAggregate\", func(t *testing.T) {\n\t\tif _, _, err := (&RedisMessage{typ: '_'}).AsFtAggregate(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregate did not fail as expected\")\n\t\t}\n\n\t\tif _, _, err := (&RedisMessage{typ: '*'}).AsFtAggregate(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregate did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a FT.AGGREGATE response\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsFtAggregateCursor\", func(t *testing.T) {\n\t\tif _, _, _, err := (&RedisMessage{typ: '_'}).AsFtAggregateCursor(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregateCursor did not fail as expected\")\n\t\t}\n\n\t\tif _, _, _, err := (&RedisMessage{typ: '*'}).AsFtAggregateCursor(); err == nil {\n\t\t\tt.Fatal(\"AsFtAggregateCursor did not fail as expected\")\n\t\t} else if !strings.Contains(err.Error(), fmt.Sprintf(\"redis message type %s is not a FT.AGGREGATE response\", typeNames['*'])) {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"AsScanEntry\", func(t *testing.T) {\n\t\tif _, err := (RedisResult{err: errors.New(\"other\")}).AsScanEntry(); err == nil {\n\t\t\tt.Fatal(\"AsScanEntry not failed as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '-'}}).AsScanEntry(); err == nil {\n\t\t\tt.Fatal(\"AsScanEntry not failed as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"1\", typ: '+'}, {typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}, {typ: '+', string: \"b\"}}}}}}).AsScanEntry(); !reflect.DeepEqual(ScanEntry{\n\t\t\tCursor:   1,\n\t\t\tElements: []string{\"a\", \"b\"},\n\t\t}, ret) {\n\t\t\tt.Fatal(\"AsScanEntry not get value as expected\")\n\t\t}\n\t\tif ret, _ := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"0\", typ: '+'}, {typ: '_'}}}}).AsScanEntry(); !reflect.DeepEqual(ScanEntry{}, ret) {\n\t\t\tt.Fatal(\"AsScanEntry not get value as expected\")\n\t\t}\n\t\tif _, err := (RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{string: \"0\", typ: '+'}}}}).AsScanEntry(); err == nil || !strings.Contains(err.Error(), \"a scan response or its length is not at least 2\") {\n\t\t\tt.Fatal(\"AsScanEntry not get value as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"ToMap with non-string key\", func(t *testing.T) {\n\t\t_, err := (&RedisMessage{typ: '~', values: []RedisMessage{{typ: ':'}, {typ: ':'}}}).ToMap()\n\t\tif err == nil {\n\t\t\tt.Fatal(\"ToMap did not fail as expected\")\n\t\t}\n\t\tif !strings.Contains(err.Error(), \"redis message type set is not a RESP3 map\") {\n\t\t\tt.Fatalf(\"ToMap failed with unexpected error: %v\", err)\n\t\t}\n\t\t_, err = (&RedisMessage{typ: '%', values: []RedisMessage{{typ: ':'}, {typ: ':'}}}).ToMap()\n\t\tif err == nil {\n\t\t\tt.Fatal(\"ToMap did not fail as expected\")\n\t\t}\n\t\tif !strings.Contains(err.Error(), \"int64 as map key is not supported\") {\n\t\t\tt.Fatalf(\"ToMap failed with unexpected error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"IsCacheHit\", func(t *testing.T) {\n\t\tif (&RedisMessage{typ: '_'}).IsCacheHit() {\n\t\t\tt.Fatal(\"IsCacheHit not as expected\")\n\t\t}\n\t\tif !(&RedisMessage{typ: '_', attrs: cacheMark}).IsCacheHit() {\n\t\t\tt.Fatal(\"IsCacheHit not as expected\")\n\t\t}\n\t})\n\n\tt.Run(\"CacheTTL\", func(t *testing.T) {\n\t\tif (&RedisMessage{typ: '_'}).CacheTTL() != -1 {\n\t\t\tt.Fatal(\"CacheTTL != -1\")\n\t\t}\n\t\tm := &RedisMessage{typ: '_'}\n\t\tm.setExpireAt(time.Now().Add(time.Millisecond * 100).UnixMilli())\n\t\tif m.CacheTTL() <= 0 {\n\t\t\tt.Fatal(\"CacheTTL <= 0\")\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tif m.CachePTTL() > 0 {\n\t\t\tt.Fatal(\"CachePTTL > 0\")\n\t\t}\n\t})\n\n\tt.Run(\"CachePTTL\", func(t *testing.T) {\n\t\tif (&RedisMessage{typ: '_'}).CachePTTL() != -1 {\n\t\t\tt.Fatal(\"CachePTTL != -1\")\n\t\t}\n\t\tm := &RedisMessage{typ: '_'}\n\t\tm.setExpireAt(time.Now().Add(time.Millisecond * 100).UnixMilli())\n\t\tif m.CachePTTL() <= 0 {\n\t\t\tt.Fatal(\"CachePTTL <= 0\")\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tif m.CachePTTL() > 0 {\n\t\t\tt.Fatal(\"CachePTTL > 0\")\n\t\t}\n\t})\n\n\tt.Run(\"CachePXAT\", func(t *testing.T) {\n\t\tif (&RedisMessage{typ: '_'}).CachePXAT() != -1 {\n\t\t\tt.Fatal(\"CachePXAT != -1\")\n\t\t}\n\t\tm := &RedisMessage{typ: '_'}\n\t\tm.setExpireAt(time.Now().Add(time.Millisecond * 100).UnixMilli())\n\t\tif m.CachePXAT() <= 0 {\n\t\t\tt.Fatal(\"CachePXAT <= 0\")\n\t\t}\n\t})\n\n\tt.Run(\"Stringer\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tinput    RedisMessage\n\t\t\texpected string\n\t\t}{\n\t\t\t{\n\t\t\t\tinput: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"127.0.3.1\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t\t\t{typ: '+', string: \"\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}},\n\t\t\t\t}},\n\t\t\t\texpected: `{\"Value\":[{\"Value\":[{\"Value\":0,\"Type\":\"int64\"},{\"Value\":0,\"Type\":\"int64\"},{\"Value\":[{\"Value\":\"127.0.3.1\",\"Type\":\"simple string\"},{\"Value\":3,\"Type\":\"int64\"},{\"Value\":\"\",\"Type\":\"simple string\"}],\"Type\":\"array\"}],\"Type\":\"array\"}],\"Type\":\"array\"}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisMessage{typ: '+', string: \"127.0.3.1\", ttl: [7]byte{97, 77, 74, 61, 138, 1, 0}},\n\t\t\t\texpected: `{\"Value\":\"127.0.3.1\",\"Type\":\"simple string\",\"TTL\":\"2023-08-28 17:56:34.273 +0000 UTC\"}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisMessage{typ: '0'},\n\t\t\t\texpected: `{\"Type\":\"unknown\"}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisMessage{typ: typeBool, integer: 1},\n\t\t\t\texpected: `{\"Value\":true,\"Type\":\"boolean\"}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisMessage{typ: typeNull},\n\t\t\t\texpected: `{\"Type\":\"null\",\"Error\":\"redis nil message\"}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisMessage{typ: typeSimpleErr, string: \"ERR foo\"},\n\t\t\t\texpected: `{\"Type\":\"simple error\",\"Error\":\"foo\"}`,\n\t\t\t},\n\t\t\t{\n\t\t\t\tinput:    RedisMessage{typ: typeBlobErr, string: \"ERR foo\"},\n\t\t\t\texpected: `{\"Type\":\"blob error\",\"Error\":\"foo\"}`,\n\t\t\t},\n\t\t}\n\t\tfor _, test := range tests {\n\t\t\tmsg := test.input.String()\n\t\t\tif msg != test.expected {\n\t\t\t\tt.Fatalf(\"unexpected string. got %v expected %v\", msg, test.expected)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"CacheMarshal and CacheUnmarshalView\", func(t *testing.T) {\n\t\tm1 := RedisMessage{typ: '_'}\n\t\tm2 := RedisMessage{typ: '+', string: \"random\"}\n\t\tm3 := RedisMessage{typ: '#', integer: 1}\n\t\tm4 := RedisMessage{typ: ':', integer: -1234}\n\t\tm5 := RedisMessage{typ: ',', string: \"-1.5\"}\n\t\tm6 := RedisMessage{typ: '%', values: nil}\n\t\tm7 := RedisMessage{typ: '~', values: []RedisMessage{m1, m2, m3, m4, m5, m6}}\n\t\tm8 := RedisMessage{typ: '*', values: []RedisMessage{m1, m2, m3, m4, m5, m6, m7}}\n\t\tmsgs := []RedisMessage{m1, m2, m3, m4, m5, m6, m7, m8}\n\t\tnow := time.Now()\n\t\tfor i := range msgs {\n\t\t\tmsgs[i].setExpireAt(now.Add(time.Second * time.Duration(i)).UnixMilli())\n\t\t}\n\t\tfor i, m1 := range msgs {\n\t\t\tsiz := m1.CacheSize()\n\t\t\tbs1 := m1.CacheMarshal(nil)\n\t\t\tif len(bs1) != siz {\n\t\t\t\tt.Fatal(\"size not match\")\n\t\t\t}\n\t\t\tbs2 := m1.CacheMarshal(bs1)\n\t\t\tif !bytes.Equal(bs2[:siz], bs2[siz:]) {\n\t\t\t\tt.Fatal(\"byte not match\")\n\t\t\t}\n\t\t\tvar m2 RedisMessage\n\t\t\tif err := m2.CacheUnmarshalView(bs1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m1.String() != m2.String() {\n\t\t\t\tt.Fatal(\"content not match\")\n\t\t\t}\n\t\t\tif !m2.IsCacheHit() {\n\t\t\t\tt.Fatal(\"should be cache hit\")\n\t\t\t}\n\t\t\tif m2.CachePXAT() != now.Add(time.Second*time.Duration(i)).UnixMilli() {\n\t\t\t\tt.Fatal(\"should have the same ttl\")\n\t\t\t}\n\t\t\tfor l := 0; l < siz; l++ {\n\t\t\t\tvar m3 RedisMessage\n\t\t\t\tif err := m3.CacheUnmarshalView(bs2[:l]); err != ErrCacheUnmarshal {\n\t\t\t\t\tt.Fatal(\"should fail as expected\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "mock",
          "type": "tree",
          "content": null
        },
        {
          "name": "mux.go",
          "type": "blob",
          "size": 9.3603515625,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\ntype connFn func(dst string, opt *ClientOption) conn\ntype dialFn func(dst string, opt *ClientOption) (net.Conn, error)\ntype wireFn func() wire\n\ntype singleconnect struct {\n\tw wire\n\te error\n\tg sync.WaitGroup\n}\n\ntype conn interface {\n\tDo(ctx context.Context, cmd Completed) RedisResult\n\tDoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult\n\tDoMulti(ctx context.Context, multi ...Completed) *redisresults\n\tDoMultiCache(ctx context.Context, multi ...CacheableTTL) *redisresults\n\tReceive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error\n\tDoStream(ctx context.Context, cmd Completed) RedisResultStream\n\tDoMultiStream(ctx context.Context, multi ...Completed) MultiRedisResultStream\n\tInfo() map[string]RedisMessage\n\tVersion() int\n\tError() error\n\tClose()\n\tDial() error\n\tOverride(conn)\n\tAcquire() wire\n\tStore(w wire)\n\tAddr() string\n\tSetOnCloseHook(func(error))\n}\n\nvar _ conn = (*mux)(nil)\n\ntype mux struct {\n\tinit   wire\n\tdead   wire\n\tclhks  atomic.Value\n\tdpool  *pool\n\tspool  *pool\n\twireFn wireFn\n\tdst    string\n\twire   []atomic.Value\n\tsc     []*singleconnect\n\tmu     []sync.Mutex\n\tmaxp   int\n\tmaxm   int\n\n\tusePool bool\n}\n\nfunc makeMux(dst string, option *ClientOption, dialFn dialFn) *mux {\n\tdead := deadFn()\n\tconnFn := func() (net.Conn, error) {\n\t\treturn dialFn(dst, option)\n\t}\n\twireFn := func(pipeFn pipeFn) func() wire {\n\t\treturn func() (w wire) {\n\t\t\tw, err := pipeFn(connFn, option)\n\t\t\tif err != nil {\n\t\t\t\tdead.error.Store(&errs{error: err})\n\t\t\t\tw = dead\n\t\t\t}\n\t\t\treturn w\n\t\t}\n\t}\n\treturn newMux(dst, option, (*pipe)(nil), dead, wireFn(newPipe), wireFn(newPipeNoBg))\n}\n\nfunc newMux(dst string, option *ClientOption, init, dead wire, wireFn wireFn, wireNoBgFn wireFn) *mux {\n\tvar multiplex int\n\tif option.PipelineMultiplex >= 0 {\n\t\tmultiplex = 1 << option.PipelineMultiplex\n\t} else {\n\t\tmultiplex = 1\n\t}\n\tm := &mux{dst: dst, init: init, dead: dead, wireFn: wireFn,\n\t\twire: make([]atomic.Value, multiplex),\n\t\tmu:   make([]sync.Mutex, multiplex),\n\t\tsc:   make([]*singleconnect, multiplex),\n\t\tmaxp: runtime.GOMAXPROCS(0),\n\t\tmaxm: option.BlockingPipeline,\n\n\t\tusePool: option.DisableAutoPipelining,\n\t}\n\tm.clhks.Store(emptyclhks)\n\tfor i := 0; i < len(m.wire); i++ {\n\t\tm.wire[i].Store(init)\n\t}\n\n\tm.dpool = newPool(option.BlockingPoolSize, dead, option.BlockingPoolCleanup, option.BlockingPoolMinSize, wireFn)\n\tm.spool = newPool(option.BlockingPoolSize, dead, option.BlockingPoolCleanup, option.BlockingPoolMinSize, wireNoBgFn)\n\treturn m\n}\n\nfunc (m *mux) SetOnCloseHook(fn func(error)) {\n\tm.clhks.Store(fn)\n}\n\nfunc (m *mux) setCloseHookOnWire(i uint16, w wire) {\n\tif w != m.dead && w != m.init {\n\t\tw.SetOnCloseHook(func(err error) {\n\t\t\tif err != ErrClosing {\n\t\t\t\tif m.wire[i].CompareAndSwap(w, m.init) {\n\t\t\t\t\tm.clhks.Load().(func(error))(err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (m *mux) Override(cc conn) {\n\tif m2, ok := cc.(*mux); ok {\n\t\tfor i := 0; i < len(m.wire) && i < len(m2.wire); i++ {\n\t\t\tw := m2.wire[i].Load().(wire)\n\t\t\tm.setCloseHookOnWire(uint16(i), w) // bind the new m to the old w\n\t\t\tm.wire[i].CompareAndSwap(m.init, w)\n\t\t}\n\t}\n}\n\nfunc (m *mux) _pipe(i uint16) (w wire, err error) {\n\tif w = m.wire[i].Load().(wire); w != m.init {\n\t\treturn w, nil\n\t}\n\n\tm.mu[i].Lock()\n\tsc := m.sc[i]\n\tif m.sc[i] == nil {\n\t\tm.sc[i] = &singleconnect{}\n\t\tm.sc[i].g.Add(1)\n\t}\n\tm.mu[i].Unlock()\n\n\tif sc != nil {\n\t\tsc.g.Wait()\n\t\treturn sc.w, sc.e\n\t}\n\n\tif w = m.wire[i].Load().(wire); w == m.init {\n\t\tif w = m.wireFn(); w != m.dead {\n\t\t\tm.setCloseHookOnWire(i, w)\n\t\t\tm.wire[i].Store(w)\n\t\t} else {\n\t\t\tif err = w.Error(); err != ErrClosing {\n\t\t\t\tm.clhks.Load().(func(error))(err)\n\t\t\t}\n\t\t}\n\t}\n\n\tm.mu[i].Lock()\n\tsc = m.sc[i]\n\tm.sc[i] = nil\n\tm.mu[i].Unlock()\n\n\tsc.w = w\n\tsc.e = err\n\tsc.g.Done()\n\n\treturn w, err\n}\n\nfunc (m *mux) pipe(i uint16) wire {\n\tw, _ := m._pipe(i)\n\treturn w // this should never be nil\n}\n\nfunc (m *mux) Dial() error {\n\t_, err := m._pipe(0)\n\treturn err\n}\n\nfunc (m *mux) Info() map[string]RedisMessage {\n\treturn m.pipe(0).Info()\n}\n\nfunc (m *mux) Version() int {\n\treturn m.pipe(0).Version()\n}\n\nfunc (m *mux) Error() error {\n\treturn m.pipe(0).Error()\n}\n\nfunc (m *mux) DoStream(ctx context.Context, cmd Completed) RedisResultStream {\n\twire := m.spool.Acquire()\n\treturn wire.DoStream(ctx, m.spool, cmd)\n}\n\nfunc (m *mux) DoMultiStream(ctx context.Context, multi ...Completed) MultiRedisResultStream {\n\twire := m.spool.Acquire()\n\treturn wire.DoMultiStream(ctx, m.spool, multi...)\n}\n\nfunc (m *mux) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tif m.usePool && !cmd.NoReply() {\n\t\tresp = m.blocking(m.spool, ctx, cmd)\n\t} else if cmd.IsBlock() {\n\t\tresp = m.blocking(m.dpool, ctx, cmd)\n\t} else {\n\t\tresp = m.pipeline(ctx, cmd)\n\t}\n\treturn resp\n}\n\nfunc (m *mux) DoMulti(ctx context.Context, multi ...Completed) (resp *redisresults) {\n\tfor _, cmd := range multi {\n\t\tif cmd.NoReply() {\n\t\t\treturn m.pipelineMulti(ctx, multi)\n\t\t}\n\t\tif cmd.IsBlock() {\n\t\t\tcmds.ToBlock(&multi[0]) // mark the first cmd as block if one of them is block to shortcut later check.\n\t\t\tgoto block\n\t\t}\n\t}\n\tif m.usePool || (len(multi) >= m.maxm && m.maxm > 0) {\n\t\tgoto block // use a dedicated connection if the pipeline is too large\n\t}\n\treturn m.pipelineMulti(ctx, multi)\nblock:\n\tif m.usePool {\n\t\treturn m.blockingMulti(m.spool, ctx, multi)\n\t}\n\treturn m.blockingMulti(m.dpool, ctx, multi)\n}\n\nfunc (m *mux) blocking(pool *pool, ctx context.Context, cmd Completed) (resp RedisResult) {\n\twire := pool.Acquire()\n\tresp = wire.Do(ctx, cmd)\n\tif resp.NonRedisError() != nil { // abort the wire if blocking command return early (ex. context.DeadlineExceeded)\n\t\twire.Close()\n\t}\n\tpool.Store(wire)\n\treturn resp\n}\n\nfunc (m *mux) blockingMulti(pool *pool, ctx context.Context, cmd []Completed) (resp *redisresults) {\n\twire := pool.Acquire()\n\tresp = wire.DoMulti(ctx, cmd...)\n\tfor _, res := range resp.s {\n\t\tif res.NonRedisError() != nil { // abort the wire if blocking command return early (ex. context.DeadlineExceeded)\n\t\t\twire.Close()\n\t\t\tbreak\n\t\t}\n\t}\n\tpool.Store(wire)\n\treturn resp\n}\n\nfunc (m *mux) pipeline(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tslot := slotfn(len(m.wire), cmd.Slot(), cmd.NoReply())\n\twire := m.pipe(slot)\n\tif resp = wire.Do(ctx, cmd); isBroken(resp.NonRedisError(), wire) {\n\t\tm.wire[slot].CompareAndSwap(wire, m.init)\n\t}\n\treturn resp\n}\n\nfunc (m *mux) pipelineMulti(ctx context.Context, cmd []Completed) (resp *redisresults) {\n\tslot := slotfn(len(m.wire), cmd[0].Slot(), cmd[0].NoReply())\n\twire := m.pipe(slot)\n\tresp = wire.DoMulti(ctx, cmd...)\n\tfor _, r := range resp.s {\n\t\tif isBroken(r.NonRedisError(), wire) {\n\t\t\tm.wire[slot].CompareAndSwap(wire, m.init)\n\t\t\treturn resp\n\t\t}\n\t}\n\treturn resp\n}\n\nfunc (m *mux) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult {\n\tslot := cmd.Slot() & uint16(len(m.wire)-1)\n\twire := m.pipe(slot)\n\tresp := wire.DoCache(ctx, cmd, ttl)\n\tif isBroken(resp.NonRedisError(), wire) {\n\t\tm.wire[slot].CompareAndSwap(wire, m.init)\n\t}\n\treturn resp\n}\n\nfunc (m *mux) DoMultiCache(ctx context.Context, multi ...CacheableTTL) (results *redisresults) {\n\tvar slots *muxslots\n\tvar mask = uint16(len(m.wire) - 1)\n\n\tif mask == 0 {\n\t\treturn m.doMultiCache(ctx, 0, multi)\n\t}\n\n\tslots = muxslotsp.Get(len(m.wire), len(m.wire))\n\tfor _, cmd := range multi {\n\t\tslots.s[cmd.Cmd.Slot()&mask]++\n\t}\n\n\tif slots.LessThen(2) {\n\t\treturn m.doMultiCache(ctx, multi[0].Cmd.Slot()&mask, multi)\n\t}\n\n\tbatches := batchcachemaps.Get(len(m.wire), len(m.wire))\n\tfor slot, count := range slots.s {\n\t\tif count > 0 {\n\t\t\tbatches.m[uint16(slot)] = batchcachep.Get(0, count)\n\t\t}\n\t}\n\tmuxslotsp.Put(slots)\n\n\tfor i, cmd := range multi {\n\t\tbatch := batches.m[cmd.Cmd.Slot()&mask]\n\t\tbatch.commands = append(batch.commands, cmd)\n\t\tbatch.cIndexes = append(batch.cIndexes, i)\n\t}\n\n\tresults = resultsp.Get(len(multi), len(multi))\n\tutil.ParallelKeys(m.maxp, batches.m, func(slot uint16) {\n\t\tbatch := batches.m[slot]\n\t\tresp := m.doMultiCache(ctx, slot, batch.commands)\n\t\tfor i, r := range resp.s {\n\t\t\tresults.s[batch.cIndexes[i]] = r\n\t\t}\n\t\tresultsp.Put(resp)\n\t})\n\n\tfor _, batch := range batches.m {\n\t\tbatchcachep.Put(batch)\n\t}\n\tbatchcachemaps.Put(batches)\n\n\treturn results\n}\n\nfunc (m *mux) doMultiCache(ctx context.Context, slot uint16, multi []CacheableTTL) (resps *redisresults) {\n\twire := m.pipe(slot)\n\tresps = wire.DoMultiCache(ctx, multi...)\n\tfor _, r := range resps.s {\n\t\tif isBroken(r.NonRedisError(), wire) {\n\t\t\tm.wire[slot].CompareAndSwap(wire, m.init)\n\t\t\treturn resps\n\t\t}\n\t}\n\treturn resps\n}\n\nfunc (m *mux) Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\tslot := slotfn(len(m.wire), subscribe.Slot(), subscribe.NoReply())\n\twire := m.pipe(slot)\n\terr := wire.Receive(ctx, subscribe, fn)\n\tif isBroken(err, wire) {\n\t\tm.wire[slot].CompareAndSwap(wire, m.init)\n\t}\n\treturn err\n}\n\nfunc (m *mux) Acquire() wire {\n\treturn m.dpool.Acquire()\n}\n\nfunc (m *mux) Store(w wire) {\n\tw.SetPubSubHooks(PubSubHooks{})\n\tw.CleanSubscriptions()\n\tm.dpool.Store(w)\n}\n\nfunc (m *mux) Close() {\n\tfor i := 0; i < len(m.wire); i++ {\n\t\tif prev := m.wire[i].Swap(m.dead).(wire); prev != m.init && prev != m.dead {\n\t\t\tprev.Close()\n\t\t}\n\t}\n\tm.dpool.Close()\n\tm.spool.Close()\n}\n\nfunc (m *mux) Addr() string {\n\treturn m.dst\n}\n\nfunc isBroken(err error, w wire) bool {\n\treturn err != nil && err != ErrClosing && w.Error() != nil\n}\n\nfunc slotfn(n int, ks uint16, noreply bool) uint16 {\n\tif n == 1 || ks == cmds.NoSlot || noreply {\n\t\treturn 0\n\t}\n\treturn uint16(util.FastRand(n))\n}\n"
        },
        {
          "name": "mux_test.go",
          "type": "blob",
          "size": 31.283203125,
          "content": "package rueidis\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\nfunc setupMux(wires []*mockWire) (conn *mux, checkClean func(t *testing.T)) {\n\treturn setupMuxWithOption(wires, &ClientOption{})\n}\n\nfunc setupMuxWithOption(wires []*mockWire, option *ClientOption) (conn *mux, checkClean func(t *testing.T)) {\n\tvar mu sync.Mutex\n\tvar count = -1\n\twfn := func() wire {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tcount++\n\t\treturn wires[count]\n\t}\n\tif option.BlockingPipeline == 0 {\n\t\toption.BlockingPipeline = DefaultBlockingPipeline\n\t}\n\treturn newMux(\"\", option, (*mockWire)(nil), (*mockWire)(nil), wfn, wfn), func(t *testing.T) {\n\t\tif count != len(wires)-1 {\n\t\t\tt.Fatalf(\"there is %d remaining unused wires\", len(wires)-count-1)\n\t\t}\n\t}\n}\n\nfunc TestNewMuxDailErr(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tc := 0\n\te := errors.New(\"any\")\n\tm := makeMux(\"\", &ClientOption{}, func(dst string, opt *ClientOption) (net.Conn, error) {\n\t\tc++\n\t\treturn nil, e\n\t})\n\tif err := m.Dial(); err != e {\n\t\tt.Fatalf(\"unexpected return %v\", err)\n\t}\n\tif c != 1 {\n\t\tt.Fatalf(\"dialFn not called\")\n\t}\n\tif w := m.pipe(0); w != m.dead { // c = 2\n\t\tt.Fatalf(\"unexpected wire %v\", w)\n\t}\n\tif err := m.Dial(); err != e { // c = 3\n\t\tt.Fatalf(\"unexpected return %v\", err)\n\t}\n\tif w := m.Acquire(); w != m.dead {\n\t\tt.Fatalf(\"unexpected wire %v\", w)\n\t}\n\tif c != 4 {\n\t\tt.Fatalf(\"dialFn not called %v\", c)\n\t}\n}\n\nfunc TestNewMux(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tn1, n2 := net.Pipe()\n\tmock := &redisMock{t: t, buf: bufio.NewReader(n2), conn: n2}\n\tgo func() {\n\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\tReply(RedisMessage{\n\t\t\t\ttyp: '%',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t},\n\t\t\t})\n\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\tReplyString(\"OK\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\tmock.Close()\n\t}()\n\tm := makeMux(\"\", &ClientOption{}, func(dst string, opt *ClientOption) (net.Conn, error) {\n\t\treturn n1, nil\n\t})\n\tif err := m.Dial(); err != nil {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n\n\tt.Run(\"Override with previous mux\", func(t *testing.T) {\n\t\tm2 := makeMux(\"\", &ClientOption{}, func(dst string, opt *ClientOption) (net.Conn, error) {\n\t\t\treturn n1, nil\n\t\t})\n\t\tm2.Override(m)\n\t\tif err := m2.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tm2.Close()\n\t})\n}\n\nfunc TestNewMuxPipelineMultiplex(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tfor _, v := range []int{-1, 0, 1, 2} {\n\t\tm := makeMux(\"\", &ClientOption{PipelineMultiplex: v}, func(dst string, opt *ClientOption) (net.Conn, error) { return nil, nil })\n\t\tif (v < 0 && len(m.wire) != 1) || (v >= 0 && len(m.wire) != 1<<v) {\n\t\t\tt.Fatalf(\"unexpected len(m.wire): %v\", len(m.wire))\n\t\t}\n\t}\n}\n\nfunc TestMuxAddr(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tm := makeMux(\"dst1\", &ClientOption{}, nil)\n\tif m.Addr() != \"dst1\" {\n\t\tt.Fatalf(\"unexpected m.Addr != dst1\")\n\t}\n}\n\nfunc TestMuxDialSuppress(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tvar wires, waits, done int64\n\tblocking := make(chan struct{})\n\tm := newMux(\"\", &ClientOption{}, (*mockWire)(nil), (*mockWire)(nil), func() wire {\n\t\tatomic.AddInt64(&wires, 1)\n\t\t<-blocking\n\t\treturn &mockWire{}\n\t}, func() wire {\n\t\treturn &mockWire{}\n\t})\n\tfor i := 0; i < 1000; i++ {\n\t\tgo func() {\n\t\t\tatomic.AddInt64(&waits, 1)\n\t\t\tm.Info()\n\t\t\tatomic.AddInt64(&done, 1)\n\t\t}()\n\t}\n\tfor atomic.LoadInt64(&waits) != 1000 {\n\t\truntime.Gosched()\n\t}\n\tclose(blocking)\n\tfor atomic.LoadInt64(&done) != 1000 {\n\t\truntime.Gosched()\n\t}\n\tif atomic.LoadInt64(&wires) != 1 {\n\t\tt.Fatalf(\"wireFn is not suppressed\")\n\t}\n}\n\n//gocyclo:ignore\nfunc TestMuxReuseWire(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"reuse wire if no error\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"PONG\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tif err := m.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})).Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t\t}\n\t\t}\n\t\tm.Close()\n\t})\n\n\tt.Run(\"reuse blocking (dpool) pool\", func(t *testing.T) {\n\t\tblocking := make(chan struct{})\n\t\tresponse := make(chan RedisResult)\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"ACQUIRED\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tblocking <- struct{}{}\n\t\t\t\t\treturn <-response\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twire1 := m.dpool.Acquire()\n\n\t\tgo func() {\n\t\t\t// this should use the second wire\n\t\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).ToString(); err != nil {\n\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t} else if val != \"BLOCK_RESPONSE\" {\n\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t}\n\t\t\tclose(blocking)\n\t\t}()\n\t\t<-blocking\n\n\t\tm.dpool.Store(wire1)\n\t\t// this should use the first wire\n\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"ACQUIRED\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\n\t\tresponse <- newResult(RedisMessage{typ: '+', string: \"BLOCK_RESPONSE\"}, nil)\n\t\t<-blocking\n\t})\n\n\tt.Run(\"reuse blocking (spool) pool\", func(t *testing.T) {\n\t\tblocking := make(chan struct{})\n\t\tresponse := make(chan RedisResult)\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"ACQUIRED\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tblocking <- struct{}{}\n\t\t\t\t\treturn <-response\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tm.usePool = true // switch to spool\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twire1 := m.spool.Acquire()\n\n\t\tgo func() {\n\t\t\t// this should use the second wire\n\t\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).ToString(); err != nil {\n\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t} else if val != \"BLOCK_RESPONSE\" {\n\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t}\n\t\t\tclose(blocking)\n\t\t}()\n\t\t<-blocking\n\n\t\tm.spool.Store(wire1)\n\t\t// this should use the first wire\n\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"ACQUIRED\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\n\t\tresponse <- newResult(RedisMessage{typ: '+', string: \"BLOCK_RESPONSE\"}, nil)\n\t\t<-blocking\n\t})\n\n\tt.Run(\"reuse blocking (dpool) pool DoMulti\", func(t *testing.T) {\n\t\tblocking := make(chan struct{})\n\t\tresponse := make(chan RedisResult)\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"ACQUIRED\"}, nil)}}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\tblocking <- struct{}{}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{<-response}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tm.usePool = true // switch to spool\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twire1 := m.spool.Acquire()\n\n\t\tgo func() {\n\t\t\t// this should use the second wire\n\t\t\tif val, err := m.DoMulti(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).s[0].ToString(); err != nil {\n\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t} else if val != \"BLOCK_RESPONSE\" {\n\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t}\n\t\t\tclose(blocking)\n\t\t}()\n\t\t<-blocking\n\n\t\tm.spool.Store(wire1)\n\t\t// this should use the first wire\n\t\tif val, err := m.DoMulti(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).s[0].ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"ACQUIRED\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\n\t\tresponse <- newResult(RedisMessage{typ: '+', string: \"BLOCK_RESPONSE\"}, nil)\n\t\t<-blocking\n\t})\n\n\tt.Run(\"reuse blocking (spool) pool DoMulti\", func(t *testing.T) {\n\t\tblocking := make(chan struct{})\n\t\tresponse := make(chan RedisResult)\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"ACQUIRED\"}, nil)}}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\tblocking <- struct{}{}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{<-response}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twire1 := m.dpool.Acquire()\n\n\t\tgo func() {\n\t\t\t// this should use the second wire\n\t\t\tif val, err := m.DoMulti(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).s[0].ToString(); err != nil {\n\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t} else if val != \"BLOCK_RESPONSE\" {\n\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t}\n\t\t\tclose(blocking)\n\t\t}()\n\t\t<-blocking\n\n\t\tm.dpool.Store(wire1)\n\t\t// this should use the first wire\n\t\tif val, err := m.DoMulti(context.Background(), cmds.NewBlockingCompleted([]string{\"PING\"})).s[0].ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"ACQUIRED\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\n\t\tresponse <- newResult(RedisMessage{typ: '+', string: \"BLOCK_RESPONSE\"}, nil)\n\t\t<-blocking\n\t})\n\n\tt.Run(\"unsubscribe blocking pool\", func(t *testing.T) {\n\t\tcleaned := false\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tCleanSubscriptionsFn: func() {\n\t\t\t\t\tcleaned = true\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twire1 := m.Acquire()\n\t\tm.Store(wire1)\n\n\t\tif !cleaned {\n\t\t\tt.Fatalf(\"CleanSubscriptions not called\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestMuxDelegation(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"wire info\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tInfoFn: func() map[string]RedisMessage {\n\t\t\t\t\treturn map[string]RedisMessage{\"key\": {typ: '+', string: \"value\"}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif info := m.Info(); info == nil || info[\"key\"].string != \"value\" {\n\t\t\tt.Fatalf(\"unexpected info %v\", info)\n\t\t}\n\t})\n\n\tt.Run(\"wire version\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tVersionFn: func() int {\n\t\t\t\t\treturn 7\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif version := m.Version(); version != 7 {\n\t\t\tt.Fatalf(\"unexpected version %v\", version)\n\t\t}\n\t})\n\n\tt.Run(\"wire err\", func(t *testing.T) {\n\t\te := errors.New(\"err\")\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn e\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Error(); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"wire do\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newErrResult(context.DeadlineExceeded)\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tif cmd.Commands()[0] != \"READONLY_COMMAND\" {\n\t\t\t\t\t\tt.Fatalf(\"command should be READONLY_COMMAND\")\n\t\t\t\t\t}\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"READONLY_COMMAND_RESPONSE\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Do(context.Background(), cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})).Error(); !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif val, err := m.Do(context.Background(), cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})).ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"READONLY_COMMAND_RESPONSE\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\t})\n\n\tt.Run(\"wire do stream\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoStreamFn: func(pool *pool, cmd Completed) RedisResultStream {\n\t\t\t\t\treturn RedisResultStream{e: errors.New(cmd.Commands()[0])}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif s := m.DoStream(context.Background(), cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})); s.Error().Error() != \"READONLY_COMMAND\" {\n\t\t\tt.Fatalf(\"unexpected error %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"wire do multi\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.DeadlineExceeded)}}\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"MULTI_COMMANDS_RESPONSE\"}, nil)}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.DoMulti(context.Background(), cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})).s[0].Error(); !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif val, err := m.DoMulti(context.Background(), cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})).s[0].ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"MULTI_COMMANDS_RESPONSE\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\t})\n\n\tt.Run(\"wire do multi stream\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoMultiStreamFn: func(pool *pool, cmd ...Completed) MultiRedisResultStream {\n\t\t\t\t\treturn MultiRedisResultStream{e: errors.New(cmd[0].Commands()[0])}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif s := m.DoMultiStream(context.Background(), cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})); s.Error().Error() != \"READONLY_COMMAND\" {\n\t\t\tt.Fatalf(\"unexpected error %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"wire do cache\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\t\treturn newErrResult(context.DeadlineExceeded)\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"READONLY_COMMAND_RESPONSE\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.DoCache(context.Background(), Cacheable(cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})), time.Second).Error(); !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif val, err := m.DoCache(context.Background(), Cacheable(cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})), time.Second).ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"READONLY_COMMAND_RESPONSE\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\t})\n\n\tt.Run(\"wire do multi cache\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.DeadlineExceeded)}}\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"MULTI_COMMANDS_RESPONSE\"}, nil)}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.DoMultiCache(context.Background(), CT(Cacheable(cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})), time.Second)).s[0].Error(); !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif val, err := m.DoMultiCache(context.Background(), CT(Cacheable(cmds.NewReadOnlyCompleted([]string{\"READONLY_COMMAND\"})), time.Second)).s[0].ToString(); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t} else if val != \"MULTI_COMMANDS_RESPONSE\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", val)\n\t\t}\n\t})\n\n\tt.Run(\"wire do multi cache multiple slots\", func(t *testing.T) {\n\t\tmultiplex := 1\n\t\twires := make([]*mockWire, 1<<multiplex)\n\t\tfor i := range wires {\n\t\t\tidx := uint16(i)\n\t\t\twires[i] = &mockWire{\n\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\tresult := make([]RedisResult, len(multi))\n\t\t\t\t\tfor j, cmd := range multi {\n\t\t\t\t\t\tif s := cmd.Cmd.Slot() & uint16(len(wires)-1); s != idx {\n\t\t\t\t\t\t\tresult[j] = newErrResult(fmt.Errorf(\"wrong slot %v %v\", s, idx))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[j] = newResult(RedisMessage{typ: '+', string: cmd.Cmd.Commands()[1]}, nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: result}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm, checkClean := setupMuxWithOption(wires, &ClientOption{PipelineMultiplex: multiplex})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\n\t\tfor i := range wires {\n\t\t\tm._pipe(uint16(i))\n\t\t}\n\n\t\tbuilder := cmds.NewBuilder(cmds.NoSlot)\n\n\t\tfor count := 1; count <= 3; count++ {\n\t\t\tcommands := make([]CacheableTTL, count)\n\t\t\tfor c := 0; c < count; c++ {\n\t\t\t\tcommands[c] = CT(builder.Get().Key(strconv.Itoa(c)).Cache(), time.Second)\n\t\t\t}\n\t\t\tfor i, resp := range m.DoMultiCache(context.Background(), commands...).s {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"wire do multi cache multiple slots fail\", func(t *testing.T) {\n\t\tmultiplex := 1\n\t\twires := make([]*mockWire, 1<<multiplex)\n\t\tfor i := range wires {\n\t\t\tidx := uint16(i)\n\t\t\twires[i] = &mockWire{\n\t\t\t\tDoMultiCacheFn: func(multi ...CacheableTTL) *redisresults {\n\t\t\t\t\tfor _, cmd := range multi {\n\t\t\t\t\t\tif s := cmd.Cmd.Slot() & uint16(len(wires)-1); s != idx {\n\t\t\t\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(fmt.Errorf(\"wrong slot %v %v\", s, idx))}}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.DeadlineExceeded)}}\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tm, checkClean := setupMuxWithOption(wires, &ClientOption{PipelineMultiplex: multiplex})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\n\t\tfor i := range wires {\n\t\t\tm._pipe(uint16(i))\n\t\t}\n\n\t\tbuilder := cmds.NewBuilder(cmds.NoSlot)\n\t\tcommands := make([]CacheableTTL, 4)\n\t\tfor c := 0; c < len(commands); c++ {\n\t\t\tcommands[c] = CT(builder.Get().Key(strconv.Itoa(c)).Cache(), time.Second)\n\t\t}\n\t\tif err := m.DoMultiCache(context.Background(), commands...).s[0].Error(); !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"wire receive\", func(t *testing.T) {\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\t\tif subscribe.Commands()[0] != \"SUBSCRIBE\" {\n\t\t\t\t\t\tt.Fatalf(\"command should be SUBSCRIBE\")\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Receive(context.Background(), cmds.NewCompleted([]string{\"SUBSCRIBE\"}), func(message PubSubMessage) {}); !errors.Is(err, context.DeadlineExceeded) {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t\tif err := m.Receive(context.Background(), cmds.NewCompleted([]string{\"SUBSCRIBE\"}), func(message PubSubMessage) {}); err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"single blocking\", func(t *testing.T) {\n\t\tblocked := make(chan struct{})\n\t\tresponses := make(chan RedisResult)\n\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tblocked <- struct{}{}\n\t\t\t\t\treturn <-responses\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\tblocked <- struct{}{}\n\t\t\t\t\treturn <-responses\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(2)\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tgo func() {\n\t\t\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).ToString(); err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t\t} else if val != \"BLOCK_COMMANDS_RESPONSE\" {\n\t\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t\t} else {\n\t\t\t\t\twg.Done()\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tfor i := 0; i < 2; i++ {\n\t\t\t<-blocked\n\t\t}\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tresponses <- newResult(RedisMessage{typ: '+', string: \"BLOCK_COMMANDS_RESPONSE\"}, nil)\n\t\t}\n\t\twg.Wait()\n\t})\n\n\tt.Run(\"single blocking no recycle the wire if err\", func(t *testing.T) {\n\t\tclosed := false\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newErrResult(context.DeadlineExceeded)\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t\tCloseFn: func() {\n\t\t\t\t\tclosed = true\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\t\tif err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).Error(); err != context.DeadlineExceeded {\n\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t}\n\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Errorf(\"unexpected response %v %v\", err, val)\n\t\t}\n\t\tif !closed {\n\t\t\tt.Errorf(\"wire not closed\")\n\t\t}\n\t})\n\n\tt.Run(\"multiple blocking\", func(t *testing.T) {\n\t\tblocked := make(chan struct{})\n\t\tresponses := make(chan RedisResult)\n\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\tblocked <- struct{}{}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{<-responses}}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\tblocked <- struct{}{}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{<-responses}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(2)\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tgo func() {\n\t\t\t\tif val, err := m.DoMulti(\n\t\t\t\t\tcontext.Background(),\n\t\t\t\t\tcmds.NewReadOnlyCompleted([]string{\"READONLY\"}),\n\t\t\t\t\tcmds.NewBlockingCompleted([]string{\"BLOCK\"}),\n\t\t\t\t).s[0].ToString(); err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t\t} else if val != \"BLOCK_COMMANDS_RESPONSE\" {\n\t\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t\t} else {\n\t\t\t\t\twg.Done()\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tfor i := 0; i < 2; i++ {\n\t\t\t<-blocked\n\t\t}\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tresponses <- newResult(RedisMessage{typ: '+', string: \"BLOCK_COMMANDS_RESPONSE\"}, nil)\n\t\t}\n\t\twg.Wait()\n\t})\n\n\tt.Run(\"multiple long pipeline\", func(t *testing.T) {\n\t\tblocked := make(chan struct{})\n\t\tresponses := make(chan RedisResult)\n\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\tblocked <- struct{}{}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{<-responses}}\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\tblocked <- struct{}{}\n\t\t\t\t\treturn &redisresults{s: []RedisResult{<-responses}}\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(2)\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tgo func() {\n\t\t\t\tpipeline := make(Commands, DefaultBlockingPipeline)\n\t\t\t\tfor i := 0; i < len(pipeline); i++ {\n\t\t\t\t\tpipeline[i] = cmds.NewCompleted([]string{\"SET\"})\n\t\t\t\t}\n\t\t\t\tif val, err := m.DoMulti(context.Background(), pipeline...).s[0].ToString(); err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t\t\t} else if val != \"BLOCK_COMMANDS_RESPONSE\" {\n\t\t\t\t\tt.Errorf(\"unexpected response %v\", val)\n\t\t\t\t} else {\n\t\t\t\t\twg.Done()\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\tfor i := 0; i < 2; i++ {\n\t\t\t<-blocked\n\t\t}\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tresponses <- newResult(RedisMessage{typ: '+', string: \"BLOCK_COMMANDS_RESPONSE\"}, nil)\n\t\t}\n\t\twg.Wait()\n\t})\n\n\tt.Run(\"multi blocking no recycle the wire if err\", func(t *testing.T) {\n\t\tclosed := false\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\t// leave first wire for pipeline calls\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(context.DeadlineExceeded)}}\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\treturn context.DeadlineExceeded\n\t\t\t\t},\n\t\t\t\tCloseFn: func() {\n\t\t\t\t\tclosed = true\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif err := m.Dial(); err != nil {\n\t\t\tt.Fatalf(\"unexpected dial error %v\", err)\n\t\t}\n\t\tif err := m.DoMulti(\n\t\t\tcontext.Background(),\n\t\t\tcmds.NewReadOnlyCompleted([]string{\"READONLY\"}),\n\t\t\tcmds.NewBlockingCompleted([]string{\"BLOCK\"}),\n\t\t).s[0].Error(); err != context.DeadlineExceeded {\n\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t}\n\t\tif val, err := m.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Errorf(\"unexpected response %v %v\", err, val)\n\t\t}\n\t\tif !closed {\n\t\t\tt.Errorf(\"wire not closed\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestMuxRegisterCloseHook(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"trigger hook with unexpected error\", func(t *testing.T) {\n\t\tvar hook atomic.Value\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"PONG1\"}, nil)\n\t\t\t\t},\n\t\t\t\tSetOnCloseHookFn: func(fn func(error)) {\n\t\t\t\t\thook.Store(fn)\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"PONG2\"}, nil)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif resp, _ := m.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})).ToString(); resp != \"PONG1\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", resp)\n\t\t}\n\t\thook.Load().(func(error))(errors.New(\"any\")) // invoke the hook, this should cause the first wire be discarded\n\t\tif resp, _ := m.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})).ToString(); resp != \"PONG2\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", resp)\n\t\t}\n\t})\n\tt.Run(\"not trigger hook with ErrClosing\", func(t *testing.T) {\n\t\tvar hook atomic.Value\n\t\tm, checkClean := setupMux([]*mockWire{\n\t\t\t{\n\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"PONG1\"}, nil)\n\t\t\t\t},\n\t\t\t\tSetOnCloseHookFn: func(fn func(error)) {\n\t\t\t\t\thook.Store(fn)\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tdefer checkClean(t)\n\t\tdefer m.Close()\n\t\tif resp, _ := m.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})).ToString(); resp != \"PONG1\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", resp)\n\t\t}\n\t\thook.Load().(func(error))(ErrClosing) // invoke the hook, this should cause the first wire be discarded\n\t\tif resp, _ := m.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})).ToString(); resp != \"PONG1\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", resp)\n\t\t}\n\t})\n}\n\nfunc BenchmarkClientSideCaching(b *testing.B) {\n\tsetup := func(b *testing.B) *mux {\n\t\tc := makeMux(\"127.0.0.1:6379\", &ClientOption{CacheSizeEachConn: DefaultCacheBytes}, func(dst string, opt *ClientOption) (conn net.Conn, err error) {\n\t\t\treturn net.Dial(\"tcp\", dst)\n\t\t})\n\t\tif err := c.Dial(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tb.SetParallelism(100)\n\t\tb.ResetTimer()\n\t\treturn c\n\t}\n\tb.Run(\"Do\", func(b *testing.B) {\n\t\tm := setup(b)\n\t\tcmd := cmds.NewCompleted([]string{\"GET\", \"a\"})\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tm.Do(context.Background(), cmd)\n\t\t\t}\n\t\t})\n\t})\n\tb.Run(\"DoCache\", func(b *testing.B) {\n\t\tm := setup(b)\n\t\tcmd := Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tm.DoCache(context.Background(), cmd, time.Second*5)\n\t\t\t}\n\t\t})\n\t})\n}\n\ntype mockWire struct {\n\tDoFn            func(cmd Completed) RedisResult\n\tDoCacheFn       func(cmd Cacheable, ttl time.Duration) RedisResult\n\tDoMultiFn       func(multi ...Completed) *redisresults\n\tDoMultiCacheFn  func(multi ...CacheableTTL) *redisresults\n\tReceiveFn       func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error\n\tDoStreamFn      func(pool *pool, cmd Completed) RedisResultStream\n\tDoMultiStreamFn func(pool *pool, cmd ...Completed) MultiRedisResultStream\n\tInfoFn          func() map[string]RedisMessage\n\tVersionFn       func() int\n\tErrorFn         func() error\n\tCloseFn         func()\n\n\tCleanSubscriptionsFn func()\n\tSetPubSubHooksFn     func(hooks PubSubHooks) <-chan error\n\tSetOnCloseHookFn     func(fn func(error))\n}\n\nfunc (m *mockWire) Do(ctx context.Context, cmd Completed) RedisResult {\n\tif m.DoFn != nil {\n\t\treturn m.DoFn(cmd)\n\t}\n\treturn RedisResult{}\n}\n\nfunc (m *mockWire) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult {\n\tif m.DoCacheFn != nil {\n\t\treturn m.DoCacheFn(cmd, ttl)\n\t}\n\treturn RedisResult{}\n}\n\nfunc (m *mockWire) DoMultiCache(ctx context.Context, multi ...CacheableTTL) *redisresults {\n\tif m.DoMultiCacheFn != nil {\n\t\treturn m.DoMultiCacheFn(multi...)\n\t}\n\treturn nil\n}\n\nfunc (m *mockWire) DoMulti(ctx context.Context, multi ...Completed) *redisresults {\n\tif m.DoMultiFn != nil {\n\t\treturn m.DoMultiFn(multi...)\n\t}\n\treturn nil\n}\n\nfunc (m *mockWire) Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\tif m.ReceiveFn != nil {\n\t\treturn m.ReceiveFn(ctx, subscribe, fn)\n\t}\n\treturn nil\n}\n\nfunc (m *mockWire) DoStream(ctx context.Context, pool *pool, cmd Completed) RedisResultStream {\n\tif m.DoStreamFn != nil {\n\t\treturn m.DoStreamFn(pool, cmd)\n\t}\n\treturn RedisResultStream{}\n}\n\nfunc (m *mockWire) DoMultiStream(ctx context.Context, pool *pool, cmd ...Completed) MultiRedisResultStream {\n\tif m.DoMultiStreamFn != nil {\n\t\treturn m.DoMultiStreamFn(pool, cmd...)\n\t}\n\treturn MultiRedisResultStream{}\n}\n\nfunc (m *mockWire) CleanSubscriptions() {\n\tif m.CleanSubscriptionsFn != nil {\n\t\tm.CleanSubscriptionsFn()\n\t}\n}\n\nfunc (m *mockWire) SetPubSubHooks(hooks PubSubHooks) <-chan error {\n\tif m.SetPubSubHooksFn != nil {\n\t\treturn m.SetPubSubHooksFn(hooks)\n\t}\n\treturn nil\n}\n\nfunc (m *mockWire) SetOnCloseHook(fn func(error)) {\n\tif m.SetOnCloseHookFn != nil {\n\t\tm.SetOnCloseHookFn(fn)\n\t}\n}\n\nfunc (m *mockWire) Info() map[string]RedisMessage {\n\tif m.InfoFn != nil {\n\t\treturn m.InfoFn()\n\t}\n\treturn nil\n}\n\nfunc (m *mockWire) Version() int {\n\tif m.VersionFn != nil {\n\t\treturn m.VersionFn()\n\t}\n\treturn 0\n}\n\nfunc (m *mockWire) Error() error {\n\tif m == nil {\n\t\treturn ErrClosing\n\t}\n\tif m.ErrorFn != nil {\n\t\treturn m.ErrorFn()\n\t}\n\treturn nil\n}\n\nfunc (m *mockWire) Close() {\n\tif m == nil {\n\t\treturn\n\t}\n\tif m.CloseFn != nil {\n\t\tm.CloseFn()\n\t}\n}\n"
        },
        {
          "name": "om",
          "type": "tree",
          "content": null
        },
        {
          "name": "pipe.go",
          "type": "blob",
          "size": 40.5009765625,
          "content": "package rueidis\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\nconst LibName = \"rueidis\"\nconst LibVer = \"1.0.52\"\n\nvar noHello = regexp.MustCompile(\"unknown command .?(HELLO|hello).?\")\n\n// See https://github.com/redis/rueidis/pull/691\nfunc isUnsubReply(msg *RedisMessage) bool {\n\t// ex. NOPERM User limiteduser has no permissions to run the 'ping' command\n\t// ex. LOADING Redis is loading the dataset in memory\n\tif msg.typ == '-' && (strings.HasPrefix(msg.string, \"LOADING\") || strings.Contains(msg.string, \"'ping'\")) {\n\t\tmsg.typ = '+'\n\t\tmsg.string = \"PONG\"\n\t\treturn true\n\t}\n\treturn msg.string == \"PONG\" || (len(msg.values) != 0 && msg.values[0].string == \"pong\")\n}\n\ntype wire interface {\n\tDo(ctx context.Context, cmd Completed) RedisResult\n\tDoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult\n\tDoMulti(ctx context.Context, multi ...Completed) *redisresults\n\tDoMultiCache(ctx context.Context, multi ...CacheableTTL) *redisresults\n\tReceive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error\n\tDoStream(ctx context.Context, pool *pool, cmd Completed) RedisResultStream\n\tDoMultiStream(ctx context.Context, pool *pool, multi ...Completed) MultiRedisResultStream\n\tInfo() map[string]RedisMessage\n\tVersion() int\n\tError() error\n\tClose()\n\n\tCleanSubscriptions()\n\tSetPubSubHooks(hooks PubSubHooks) <-chan error\n\tSetOnCloseHook(fn func(error))\n}\n\nvar _ wire = (*pipe)(nil)\n\ntype pipe struct {\n\tconn            net.Conn\n\terror           atomic.Value\n\tclhks           atomic.Value // closed hook, invoked after the conn is closed\n\tpshks           atomic.Value // pubsub hook, registered by the SetPubSubHooks\n\tqueue           queue\n\tcache           CacheStore\n\tr               *bufio.Reader\n\tw               *bufio.Writer\n\tclose           chan struct{}\n\tonInvalidations func([]RedisMessage)\n\tr2psFn          func() (p *pipe, err error) // func to build pipe for resp2 pubsub\n\tr2pipe          *pipe                       // internal pipe for resp2 pubsub only\n\tssubs           *subs                       // pubsub smessage subscriptions\n\tnsubs           *subs                       // pubsub  message subscriptions\n\tpsubs           *subs                       // pubsub pmessage subscriptions\n\tinfo            map[string]RedisMessage\n\ttimeout         time.Duration\n\tpinggap         time.Duration\n\tmaxFlushDelay   time.Duration\n\tonce            sync.Once\n\tr2mu            sync.Mutex\n\tversion         int32\n\t_               [10]int32\n\tblcksig         int32\n\tstate           int32\n\twaits           int32\n\trecvs           int32\n\tr2ps            bool // identify this pipe is used for resp2 pubsub or not\n\tnoNoDelay       bool\n}\n\ntype pipeFn func(connFn func() (net.Conn, error), option *ClientOption) (p *pipe, err error)\n\nfunc newPipe(connFn func() (net.Conn, error), option *ClientOption) (p *pipe, err error) {\n\treturn _newPipe(connFn, option, false, false)\n}\n\nfunc newPipeNoBg(connFn func() (net.Conn, error), option *ClientOption) (p *pipe, err error) {\n\treturn _newPipe(connFn, option, false, true)\n}\n\nfunc _newPipe(connFn func() (net.Conn, error), option *ClientOption, r2ps, nobg bool) (p *pipe, err error) {\n\tconn, err := connFn()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp = &pipe{\n\t\tconn: conn,\n\t\tr:    bufio.NewReaderSize(conn, option.ReadBufferEachConn),\n\t\tw:    bufio.NewWriterSize(conn, option.WriteBufferEachConn),\n\n\t\ttimeout:       option.ConnWriteTimeout,\n\t\tpinggap:       option.Dialer.KeepAlive,\n\t\tmaxFlushDelay: option.MaxFlushDelay,\n\t\tnoNoDelay:     option.DisableTCPNoDelay,\n\n\t\tr2ps: r2ps,\n\t}\n\tif !nobg {\n\t\tp.queue = newRing(option.RingScaleEachConn)\n\t\tp.nsubs = newSubs()\n\t\tp.psubs = newSubs()\n\t\tp.ssubs = newSubs()\n\t\tp.close = make(chan struct{})\n\t}\n\tif !r2ps {\n\t\tp.r2psFn = func() (p *pipe, err error) {\n\t\t\treturn _newPipe(connFn, option, true, nobg)\n\t\t}\n\t}\n\tif !nobg && !option.DisableCache {\n\t\tcacheStoreFn := option.NewCacheStoreFn\n\t\tif cacheStoreFn == nil {\n\t\t\tcacheStoreFn = newLRU\n\t\t}\n\t\tp.cache = cacheStoreFn(CacheStoreOption{CacheSizeEachConn: option.CacheSizeEachConn})\n\t}\n\tp.pshks.Store(emptypshks)\n\tp.clhks.Store(emptyclhks)\n\n\tusername := option.Username\n\tpassword := option.Password\n\tif option.AuthCredentialsFn != nil {\n\t\tauthCredentialsContext := AuthCredentialsContext{\n\t\t\tAddress: conn.RemoteAddr(),\n\t\t}\n\t\tauthCredentials, err := option.AuthCredentialsFn(authCredentialsContext)\n\t\tif err != nil {\n\t\t\tp.Close()\n\t\t\treturn nil, err\n\t\t}\n\t\tusername = authCredentials.Username\n\t\tpassword = authCredentials.Password\n\t}\n\n\thelloCmd := []string{\"HELLO\", \"3\"}\n\tif password != \"\" && username == \"\" {\n\t\thelloCmd = append(helloCmd, \"AUTH\", \"default\", password)\n\t} else if username != \"\" {\n\t\thelloCmd = append(helloCmd, \"AUTH\", username, password)\n\t}\n\tif option.ClientName != \"\" {\n\t\thelloCmd = append(helloCmd, \"SETNAME\", option.ClientName)\n\t}\n\n\tinit := make([][]string, 0, 5)\n\tif option.ClientTrackingOptions == nil {\n\t\tinit = append(init, helloCmd, []string{\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\"})\n\t} else {\n\t\tinit = append(init, helloCmd, append([]string{\"CLIENT\", \"TRACKING\", \"ON\"}, option.ClientTrackingOptions...))\n\t}\n\tif option.DisableCache {\n\t\tinit = init[:1]\n\t}\n\tif option.SelectDB != 0 {\n\t\tinit = append(init, []string{\"SELECT\", strconv.Itoa(option.SelectDB)})\n\t}\n\tif option.ReplicaOnly && option.Sentinel.MasterSet == \"\" {\n\t\tinit = append(init, []string{\"READONLY\"})\n\t}\n\tif option.ClientNoTouch {\n\t\tinit = append(init, []string{\"CLIENT\", \"NO-TOUCH\", \"ON\"})\n\t}\n\tif option.ClientNoEvict {\n\t\tinit = append(init, []string{\"CLIENT\", \"NO-EVICT\", \"ON\"})\n\t}\n\n\taddClientSetInfoCmds := true\n\tif len(option.ClientSetInfo) == 2 {\n\t\tinit = append(init, []string{\"CLIENT\", \"SETINFO\", \"LIB-NAME\", option.ClientSetInfo[0]}, []string{\"CLIENT\", \"SETINFO\", \"LIB-VER\", option.ClientSetInfo[1]})\n\t} else if option.ClientSetInfo == nil {\n\t\tinit = append(init, []string{\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName}, []string{\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer})\n\t} else {\n\t\taddClientSetInfoCmds = false\n\t}\n\n\ttimeout := option.Dialer.Timeout\n\tif timeout <= 0 {\n\t\ttimeout = DefaultDialTimeout\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\tdefer cancel()\n\n\tr2 := option.AlwaysRESP2\n\tif !r2 && !r2ps {\n\t\tresp := p.DoMulti(ctx, cmds.NewMultiCompleted(init)...)\n\t\tdefer resultsp.Put(resp)\n\n\t\tcount := len(resp.s)\n\t\tif addClientSetInfoCmds {\n\t\t\t// skip error checking on the last CLIENT SETINFO\n\t\t\tcount -= 2\n\t\t}\n\n\t\tfor i, r := range resp.s[:count] {\n\t\t\tif i == 0 {\n\t\t\t\tp.info, err = r.AsMap()\n\t\t\t} else {\n\t\t\t\terr = r.Error()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tif init[i][0] == \"READONLY\" {\n\t\t\t\t\t// ignore READONLY command error\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif re, ok := err.(*RedisError); ok {\n\t\t\t\t\tif !r2 && noHello.MatchString(re.string) {\n\t\t\t\t\t\tr2 = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else if init[i][0] == \"CLIENT\" {\n\t\t\t\t\t\terr = fmt.Errorf(\"%s: %v\\n%w\", re.string, init[i], ErrNoCache)\n\t\t\t\t\t} else if r2 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\tif proto := p.info[\"proto\"]; proto.integer < 3 {\n\t\tr2 = true\n\t}\n\tif !r2 && !r2ps {\n\t\tif ver, ok := p.info[\"version\"]; ok {\n\t\t\tif v := strings.Split(ver.string, \".\"); len(v) != 0 {\n\t\t\t\tvv, _ := strconv.ParseInt(v[0], 10, 32)\n\t\t\t\tp.version = int32(vv)\n\t\t\t}\n\t\t}\n\t\tp.onInvalidations = option.OnInvalidations\n\t} else {\n\t\tif !option.DisableCache {\n\t\t\tp.Close()\n\t\t\treturn nil, ErrNoCache\n\t\t}\n\t\tinit = init[:0]\n\t\tif password != \"\" && username == \"\" {\n\t\t\tinit = append(init, []string{\"AUTH\", password})\n\t\t} else if username != \"\" {\n\t\t\tinit = append(init, []string{\"AUTH\", username, password})\n\t\t}\n\t\tif option.ClientName != \"\" {\n\t\t\tinit = append(init, []string{\"CLIENT\", \"SETNAME\", option.ClientName})\n\t\t}\n\t\tif option.SelectDB != 0 {\n\t\t\tinit = append(init, []string{\"SELECT\", strconv.Itoa(option.SelectDB)})\n\t\t}\n\t\tif option.ReplicaOnly && option.Sentinel.MasterSet == \"\" {\n\t\t\tinit = append(init, []string{\"READONLY\"})\n\t\t}\n\t\tif option.ClientNoTouch {\n\t\t\tinit = append(init, []string{\"CLIENT\", \"NO-TOUCH\", \"ON\"})\n\t\t}\n\t\tif option.ClientNoEvict {\n\t\t\tinit = append(init, []string{\"CLIENT\", \"NO-EVICT\", \"ON\"})\n\t\t}\n\n\t\taddClientSetInfoCmds := true\n\t\tif len(option.ClientSetInfo) == 2 {\n\t\t\tinit = append(init, []string{\"CLIENT\", \"SETINFO\", \"LIB-NAME\", option.ClientSetInfo[0]}, []string{\"CLIENT\", \"SETINFO\", \"LIB-VER\", option.ClientSetInfo[1]})\n\t\t} else if option.ClientSetInfo == nil {\n\t\t\tinit = append(init, []string{\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName}, []string{\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer})\n\t\t} else {\n\t\t\taddClientSetInfoCmds = false\n\t\t}\n\n\t\tp.version = 5\n\t\tif len(init) != 0 {\n\t\t\tresp := p.DoMulti(ctx, cmds.NewMultiCompleted(init)...)\n\t\t\tdefer resultsp.Put(resp)\n\n\t\t\tcount := len(resp.s)\n\t\t\tif addClientSetInfoCmds {\n\t\t\t\t// skip error checking on the last CLIENT SETINFO\n\t\t\t\tcount -= 2\n\t\t\t}\n\n\t\t\tfor i, r := range resp.s[:count] {\n\t\t\t\tif init[i][0] == \"READONLY\" {\n\t\t\t\t\t// ignore READONLY command error\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err = r.Error(); err != nil {\n\t\t\t\t\tp.Close()\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif !nobg {\n\t\tif p.onInvalidations != nil || option.AlwaysPipelining {\n\t\t\tp.background()\n\t\t}\n\t\tif p.timeout > 0 && p.pinggap > 0 {\n\t\t\tgo p.backgroundPing()\n\t\t}\n\t}\n\treturn p, nil\n}\n\nfunc (p *pipe) background() {\n\tif p.queue != nil {\n\t\tatomic.CompareAndSwapInt32(&p.state, 0, 1)\n\t\tp.once.Do(func() { go p._background() })\n\t}\n}\n\nfunc (p *pipe) _exit(err error) {\n\tp.error.CompareAndSwap(nil, &errs{error: err})\n\tatomic.CompareAndSwapInt32(&p.state, 1, 2) // stop accepting new requests\n\t_ = p.conn.Close()                         // force both read & write goroutine to exit\n\tp.clhks.Load().(func(error))(err)\n}\n\nfunc disableNoDelay(conn net.Conn) {\n\tif c, ok := conn.(*tls.Conn); ok {\n\t\tconn = c.NetConn()\n\t}\n\tif c, ok := conn.(*net.TCPConn); ok {\n\t\tc.SetNoDelay(false)\n\t}\n}\n\nfunc (p *pipe) _background() {\n\tp.conn.SetDeadline(time.Time{})\n\tif p.noNoDelay {\n\t\tdisableNoDelay(p.conn)\n\t}\n\tgo func() {\n\t\tp._exit(p._backgroundWrite())\n\t\tclose(p.close)\n\t}()\n\t{\n\t\tp._exit(p._backgroundRead())\n\t\tselect {\n\t\tcase <-p.close:\n\t\tdefault:\n\t\t\tatomic.AddInt32(&p.waits, 1)\n\t\t\tgo func() {\n\t\t\t\t<-p.queue.PutOne(cmds.PingCmd) // avoid _backgroundWrite hanging at p.queue.WaitForWrite()\n\t\t\t\tatomic.AddInt32(&p.waits, -1)\n\t\t\t}()\n\t\t}\n\t}\n\terr := p.Error()\n\tp.nsubs.Close()\n\tp.psubs.Close()\n\tp.ssubs.Close()\n\tif old := p.pshks.Swap(emptypshks).(*pshks); old.close != nil {\n\t\told.close <- err\n\t\tclose(old.close)\n\t}\n\n\tvar (\n\t\tresps []RedisResult\n\t\tch    chan RedisResult\n\t\tcond  *sync.Cond\n\t)\n\n\t// clean up cache and free pending calls\n\tif p.cache != nil {\n\t\tp.cache.Close(ErrDoCacheAborted)\n\t}\n\tif p.onInvalidations != nil {\n\t\tp.onInvalidations(nil)\n\t}\n\n\tresp := newErrResult(err)\n\tfor atomic.LoadInt32(&p.waits) != 0 {\n\t\tselect {\n\t\tcase <-p.close: // p.queue.NextWriteCmd() can only be called after _backgroundWrite\n\t\t\t_, _, _ = p.queue.NextWriteCmd()\n\t\tdefault:\n\t\t}\n\t\tif _, _, ch, resps, cond = p.queue.NextResultCh(); ch != nil {\n\t\t\tfor i := range resps {\n\t\t\t\tresps[i] = resp\n\t\t\t}\n\t\t\tch <- resp\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t} else {\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t\truntime.Gosched()\n\t\t}\n\t}\n\t<-p.close\n\tatomic.StoreInt32(&p.state, 4)\n}\n\nfunc (p *pipe) _backgroundWrite() (err error) {\n\tvar (\n\t\tones  = make([]Completed, 1)\n\t\tmulti []Completed\n\t\tch    chan RedisResult\n\n\t\tflushDelay = p.maxFlushDelay\n\t\tflushStart = time.Time{}\n\t)\n\n\tfor err == nil {\n\t\tif ones[0], multi, ch = p.queue.NextWriteCmd(); ch == nil {\n\t\t\tif flushDelay != 0 {\n\t\t\t\tflushStart = time.Now()\n\t\t\t}\n\t\t\tif p.w.Buffered() != 0 {\n\t\t\t\tif err = p.w.Flush(); err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tones[0], multi, ch = p.queue.WaitForWrite()\n\t\t\tif flushDelay != 0 && atomic.LoadInt32(&p.waits) > 1 { // do not delay for sequential usage\n\t\t\t\t// Blocking commands are executed in dedicated client which is acquired from pool.\n\t\t\t\t// So, there is no sense to wait other commands to be written.\n\t\t\t\t// https://github.com/redis/rueidis/issues/379\n\t\t\t\tvar blocked bool\n\t\t\t\tfor i := 0; i < len(multi) && !blocked; i++ {\n\t\t\t\t\tblocked = multi[i].IsBlock()\n\t\t\t\t}\n\t\t\t\tif !blocked {\n\t\t\t\t\ttime.Sleep(flushDelay - time.Since(flushStart)) // ref: https://github.com/redis/rueidis/issues/156\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ch != nil && multi == nil {\n\t\t\tmulti = ones\n\t\t}\n\t\tfor _, cmd := range multi {\n\t\t\terr = writeCmd(p.w, cmd.Commands())\n\t\t\tif cmd.IsUnsub() { // See https://github.com/redis/rueidis/pull/691\n\t\t\t\terr = writeCmd(p.w, cmds.PingCmd.Commands())\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (p *pipe) _backgroundRead() (err error) {\n\tvar (\n\t\tmsg   RedisMessage\n\t\tcond  *sync.Cond\n\t\tones  = make([]Completed, 1)\n\t\tmulti []Completed\n\t\tresps []RedisResult\n\t\tch    chan RedisResult\n\t\tff    int // fulfilled count\n\t\tskip  int // skip rest push messages\n\t\tver   = p.version\n\t\tprply bool // push reply\n\t\tunsub bool // unsubscribe notification\n\n\t\tskipUnsubReply bool // if unsubscribe is replied\n\n\t\tr2ps = p.r2ps\n\t)\n\n\tdefer func() {\n\t\tresp := newErrResult(err)\n\t\tif err != nil && ff < len(multi) {\n\t\t\tfor ; ff < len(resps); ff++ {\n\t\t\t\tresps[ff] = resp\n\t\t\t}\n\t\t\tch <- resp\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t}\n\t}()\n\n\tfor {\n\t\tif msg, err = readNextMessage(p.r); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif msg.typ == '>' || (r2ps && len(msg.values) != 0 && msg.values[0].string != \"pong\") {\n\t\t\tif prply, unsub = p.handlePush(msg.values); !prply {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif skip > 0 {\n\t\t\t\tskip--\n\t\t\t\tprply = false\n\t\t\t\tunsub = false\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else if ver == 6 && len(msg.values) != 0 {\n\t\t\t// This is a workaround for Redis 6's broken invalidation protocol: https://github.com/redis/redis/issues/8935\n\t\t\t// When Redis 6 handles MULTI, MGET, or other multi-keys command,\n\t\t\t// it will send invalidation message immediately if it finds the keys are expired, thus causing the multi-keys command response to be broken.\n\t\t\t// We fix this by fetching the next message and patch it back to the response.\n\t\t\ti := 0\n\t\t\tfor j, v := range msg.values {\n\t\t\t\tif v.typ == '>' {\n\t\t\t\t\tp.handlePush(v.values)\n\t\t\t\t} else {\n\t\t\t\t\tif i != j {\n\t\t\t\t\t\tmsg.values[i] = v\n\t\t\t\t\t}\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ; i < len(msg.values); i++ {\n\t\t\t\tif msg.values[i], err = readNextMessage(p.r); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ff == len(multi) {\n\t\t\tff = 0\n\t\t\tones[0], multi, ch, resps, cond = p.queue.NextResultCh() // ch should not be nil, otherwise it must be a protocol bug\n\t\t\tif ch == nil {\n\t\t\t\tcond.L.Unlock()\n\t\t\t\t// Redis will send sunsubscribe notification proactively in the event of slot migration.\n\t\t\t\t// We should ignore them and go fetch next message.\n\t\t\t\t// We also treat all the other unsubscribe notifications just like sunsubscribe,\n\t\t\t\t// so that we don't need to track how many channels we have subscribed to deal with wildcard unsubscribe command\n\t\t\t\t// See https://github.com/redis/rueidis/pull/691\n\t\t\t\tif unsub {\n\t\t\t\t\tprply = false\n\t\t\t\t\tunsub = false\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif skipUnsubReply && isUnsubReply(&msg) {\n\t\t\t\t\tskipUnsubReply = false\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tpanic(protocolbug)\n\t\t\t}\n\t\t\tif multi == nil {\n\t\t\t\tmulti = ones\n\t\t\t}\n\t\t} else if ff >= 4 && len(msg.values) >= 2 && multi[0].IsOptIn() { // if unfulfilled multi commands are lead by opt-in and get success response\n\t\t\tnow := time.Now()\n\t\t\tif cacheable := Cacheable(multi[ff-1]); cacheable.IsMGet() {\n\t\t\t\tcc := cmds.MGetCacheCmd(cacheable)\n\t\t\t\tmsgs := msg.values[len(msg.values)-1].values\n\t\t\t\tfor i, cp := range msgs {\n\t\t\t\t\tck := cmds.MGetCacheKey(cacheable, i)\n\t\t\t\t\tcp.attrs = cacheMark\n\t\t\t\t\tif pttl := msg.values[i].integer; pttl >= 0 {\n\t\t\t\t\t\tcp.setExpireAt(now.Add(time.Duration(pttl) * time.Millisecond).UnixMilli())\n\t\t\t\t\t}\n\t\t\t\t\tmsgs[i].setExpireAt(p.cache.Update(ck, cc, cp))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tck, cc := cmds.CacheKey(cacheable)\n\t\t\t\tci := len(msg.values) - 1\n\t\t\t\tcp := msg.values[ci]\n\t\t\t\tcp.attrs = cacheMark\n\t\t\t\tif pttl := msg.values[ci-1].integer; pttl >= 0 {\n\t\t\t\t\tcp.setExpireAt(now.Add(time.Duration(pttl) * time.Millisecond).UnixMilli())\n\t\t\t\t}\n\t\t\t\tmsg.values[ci].setExpireAt(p.cache.Update(ck, cc, cp))\n\t\t\t}\n\t\t}\n\t\tif prply {\n\t\t\t// Redis will send sunsubscribe notification proactively in the event of slot migration.\n\t\t\t// We should ignore them and go fetch next message.\n\t\t\t// We also treat all the other unsubscribe notifications just like sunsubscribe,\n\t\t\t// so that we don't need to track how many channels we have subscribed to deal with wildcard unsubscribe command\n\t\t\t// See https://github.com/redis/rueidis/pull/691\n\t\t\tif unsub {\n\t\t\t\tprply = false\n\t\t\t\tunsub = false\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprply = false\n\t\t\tunsub = false\n\t\t\tif !multi[ff].NoReply() {\n\t\t\t\tpanic(protocolbug)\n\t\t\t}\n\t\t\tskip = len(multi[ff].Commands()) - 2\n\t\t\tmsg = RedisMessage{} // override successful subscribe/unsubscribe response to empty\n\t\t} else if multi[ff].NoReply() && msg.string == \"QUEUED\" {\n\t\t\tpanic(multiexecsub)\n\t\t} else if multi[ff].IsUnsub() && !isUnsubReply(&msg) {\n\t\t\t// See https://github.com/redis/rueidis/pull/691\n\t\t\tskipUnsubReply = true\n\t\t} else if skipUnsubReply {\n\t\t\t// See https://github.com/redis/rueidis/pull/691\n\t\t\tif !isUnsubReply(&msg) {\n\t\t\t\tpanic(protocolbug)\n\t\t\t}\n\t\t\tskipUnsubReply = false\n\t\t\tcontinue\n\t\t}\n\t\tresp := newResult(msg, err)\n\t\tif resps != nil {\n\t\t\tresps[ff] = resp\n\t\t}\n\t\tif ff++; ff == len(multi) {\n\t\t\tch <- resp\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t}\n\t}\n}\n\nfunc (p *pipe) backgroundPing() {\n\tvar err error\n\tvar prev, recv int32\n\n\tticker := time.NewTicker(p.pinggap)\n\tdefer ticker.Stop()\n\tfor ; err == nil; prev = recv {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\trecv = atomic.LoadInt32(&p.recvs)\n\t\t\tif recv != prev || atomic.LoadInt32(&p.blcksig) != 0 || (atomic.LoadInt32(&p.state) == 0 && atomic.LoadInt32(&p.waits) != 0) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tch := make(chan error, 1)\n\t\t\ttm := time.NewTimer(p.timeout)\n\t\t\tgo func() { ch <- p.Do(context.Background(), cmds.PingCmd).NonRedisError() }()\n\t\t\tselect {\n\t\t\tcase <-tm.C:\n\t\t\t\terr = os.ErrDeadlineExceeded\n\t\t\tcase err = <-ch:\n\t\t\t\ttm.Stop()\n\t\t\t}\n\t\t\tif err != nil && atomic.LoadInt32(&p.blcksig) != 0 {\n\t\t\t\terr = nil\n\t\t\t}\n\t\tcase <-p.close:\n\t\t\treturn\n\t\t}\n\t}\n\tif err != ErrClosing {\n\t\tp._exit(err)\n\t}\n}\n\nfunc (p *pipe) handlePush(values []RedisMessage) (reply bool, unsubscribe bool) {\n\tif len(values) < 2 {\n\t\treturn\n\t}\n\t// TODO: handle other push data\n\t// tracking-redir-broken\n\t// server-cpu-usage\n\tswitch values[0].string {\n\tcase \"invalidate\":\n\t\tif p.cache != nil {\n\t\t\tif values[1].IsNil() {\n\t\t\t\tp.cache.Delete(nil)\n\t\t\t} else {\n\t\t\t\tp.cache.Delete(values[1].values)\n\t\t\t}\n\t\t}\n\t\tif p.onInvalidations != nil {\n\t\t\tif values[1].IsNil() {\n\t\t\t\tp.onInvalidations(nil)\n\t\t\t} else {\n\t\t\t\tp.onInvalidations(values[1].values)\n\t\t\t}\n\t\t}\n\tcase \"message\":\n\t\tif len(values) >= 3 {\n\t\t\tm := PubSubMessage{Channel: values[1].string, Message: values[2].string}\n\t\t\tp.nsubs.Publish(values[1].string, m)\n\t\t\tp.pshks.Load().(*pshks).hooks.OnMessage(m)\n\t\t}\n\tcase \"pmessage\":\n\t\tif len(values) >= 4 {\n\t\t\tm := PubSubMessage{Pattern: values[1].string, Channel: values[2].string, Message: values[3].string}\n\t\t\tp.psubs.Publish(values[1].string, m)\n\t\t\tp.pshks.Load().(*pshks).hooks.OnMessage(m)\n\t\t}\n\tcase \"smessage\":\n\t\tif len(values) >= 3 {\n\t\t\tm := PubSubMessage{Channel: values[1].string, Message: values[2].string}\n\t\t\tp.ssubs.Publish(values[1].string, m)\n\t\t\tp.pshks.Load().(*pshks).hooks.OnMessage(m)\n\t\t}\n\tcase \"unsubscribe\":\n\t\tp.nsubs.Unsubscribe(values[1].string)\n\t\tif len(values) >= 3 {\n\t\t\tp.pshks.Load().(*pshks).hooks.OnSubscription(PubSubSubscription{Kind: values[0].string, Channel: values[1].string, Count: values[2].integer})\n\t\t}\n\t\treturn true, true\n\tcase \"punsubscribe\":\n\t\tp.psubs.Unsubscribe(values[1].string)\n\t\tif len(values) >= 3 {\n\t\t\tp.pshks.Load().(*pshks).hooks.OnSubscription(PubSubSubscription{Kind: values[0].string, Channel: values[1].string, Count: values[2].integer})\n\t\t}\n\t\treturn true, true\n\tcase \"sunsubscribe\":\n\t\tp.ssubs.Unsubscribe(values[1].string)\n\t\tif len(values) >= 3 {\n\t\t\tp.pshks.Load().(*pshks).hooks.OnSubscription(PubSubSubscription{Kind: values[0].string, Channel: values[1].string, Count: values[2].integer})\n\t\t}\n\t\treturn true, true\n\tcase \"subscribe\", \"psubscribe\", \"ssubscribe\":\n\t\tif len(values) >= 3 {\n\t\t\tp.pshks.Load().(*pshks).hooks.OnSubscription(PubSubSubscription{Kind: values[0].string, Channel: values[1].string, Count: values[2].integer})\n\t\t}\n\t\treturn true, false\n\t}\n\treturn false, false\n}\n\nfunc (p *pipe) _r2pipe() (r2p *pipe) {\n\tp.r2mu.Lock()\n\tif p.r2pipe != nil {\n\t\tr2p = p.r2pipe\n\t} else {\n\t\tvar err error\n\t\tif r2p, err = p.r2psFn(); err != nil {\n\t\t\tr2p = epipeFn(err)\n\t\t} else {\n\t\t\tp.r2pipe = r2p\n\t\t}\n\t}\n\tp.r2mu.Unlock()\n\treturn r2p\n}\n\nfunc (p *pipe) Receive(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\tif p.nsubs == nil || p.psubs == nil || p.ssubs == nil {\n\t\treturn p.Error()\n\t}\n\n\tif p.version < 6 && p.r2psFn != nil {\n\t\treturn p._r2pipe().Receive(ctx, subscribe, fn)\n\t}\n\n\tcmds.CompletedCS(subscribe).Verify()\n\n\tvar sb *subs\n\tcmd, args := subscribe.Commands()[0], subscribe.Commands()[1:]\n\n\tswitch cmd {\n\tcase \"SUBSCRIBE\":\n\t\tsb = p.nsubs\n\tcase \"PSUBSCRIBE\":\n\t\tsb = p.psubs\n\tcase \"SSUBSCRIBE\":\n\t\tsb = p.ssubs\n\tdefault:\n\t\tpanic(wrongreceive)\n\t}\n\n\tif ch, cancel := sb.Subscribe(args); ch != nil {\n\t\tdefer cancel()\n\t\tif err := p.Do(ctx, subscribe).Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif ctxCh := ctx.Done(); ctxCh == nil {\n\t\t\tfor msg := range ch {\n\t\t\t\tfn(msg)\n\t\t\t}\n\t\t} else {\n\t\tnext:\n\t\t\tselect {\n\t\t\tcase msg, ok := <-ch:\n\t\t\t\tif ok {\n\t\t\t\t\tfn(msg)\n\t\t\t\t\tgoto next\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\t}\n\t\t}\n\t}\n\treturn p.Error()\n}\n\nfunc (p *pipe) CleanSubscriptions() {\n\tif atomic.LoadInt32(&p.blcksig) != 0 {\n\t\tp.Close()\n\t} else if atomic.LoadInt32(&p.state) == 1 {\n\t\tif p.version >= 7 {\n\t\t\tp.DoMulti(context.Background(), cmds.UnsubscribeCmd, cmds.PUnsubscribeCmd, cmds.SUnsubscribeCmd, cmds.DiscardCmd)\n\t\t} else {\n\t\t\tp.DoMulti(context.Background(), cmds.UnsubscribeCmd, cmds.PUnsubscribeCmd, cmds.DiscardCmd)\n\t\t}\n\t}\n}\n\nfunc (p *pipe) SetPubSubHooks(hooks PubSubHooks) <-chan error {\n\tif p.version < 6 && p.r2psFn != nil {\n\t\treturn p._r2pipe().SetPubSubHooks(hooks)\n\t}\n\tif hooks.isZero() {\n\t\tif old := p.pshks.Swap(emptypshks).(*pshks); old.close != nil {\n\t\t\tclose(old.close)\n\t\t}\n\t\treturn nil\n\t}\n\tif hooks.OnMessage == nil {\n\t\thooks.OnMessage = func(m PubSubMessage) {}\n\t}\n\tif hooks.OnSubscription == nil {\n\t\thooks.OnSubscription = func(s PubSubSubscription) {}\n\t}\n\tch := make(chan error, 1)\n\tif old := p.pshks.Swap(&pshks{hooks: hooks, close: ch}).(*pshks); old.close != nil {\n\t\tclose(old.close)\n\t}\n\tif err := p.Error(); err != nil {\n\t\tif old := p.pshks.Swap(emptypshks).(*pshks); old.close != nil {\n\t\t\told.close <- err\n\t\t\tclose(old.close)\n\t\t}\n\t}\n\tif atomic.AddInt32(&p.waits, 1) == 1 && atomic.LoadInt32(&p.state) == 0 {\n\t\tp.background()\n\t}\n\tatomic.AddInt32(&p.waits, -1)\n\treturn ch\n}\n\nfunc (p *pipe) SetOnCloseHook(fn func(error)) {\n\tp.clhks.Store(fn)\n}\n\nfunc (p *pipe) Info() map[string]RedisMessage {\n\treturn p.info\n}\n\nfunc (p *pipe) Version() int {\n\treturn int(p.version)\n}\n\nfunc (p *pipe) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tif err := ctx.Err(); err != nil {\n\t\treturn newErrResult(err)\n\t}\n\n\tcmds.CompletedCS(cmd).Verify()\n\n\tif cmd.IsBlock() {\n\t\tatomic.AddInt32(&p.blcksig, 1)\n\t\tdefer func() {\n\t\t\tif resp.err == nil {\n\t\t\t\tatomic.AddInt32(&p.blcksig, -1)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif cmd.NoReply() {\n\t\tif p.version < 6 && p.r2psFn != nil {\n\t\t\treturn p._r2pipe().Do(ctx, cmd)\n\t\t}\n\t}\n\n\twaits := atomic.AddInt32(&p.waits, 1) // if this is 1, and background worker is not started, no need to queue\n\tstate := atomic.LoadInt32(&p.state)\n\n\tif state == 1 {\n\t\tgoto queue\n\t}\n\n\tif state == 0 {\n\t\tif waits != 1 {\n\t\t\tgoto queue\n\t\t}\n\t\tif cmd.NoReply() {\n\t\t\tp.background()\n\t\t\tgoto queue\n\t\t}\n\t\tdl, ok := ctx.Deadline()\n\t\tif p.queue != nil && !ok && ctx.Done() != nil {\n\t\t\tp.background()\n\t\t\tgoto queue\n\t\t}\n\t\tresp = p.syncDo(dl, ok, cmd)\n\t} else {\n\t\tresp = newErrResult(p.Error())\n\t}\n\tif left := atomic.AddInt32(&p.waits, -1); state == 0 && left != 0 {\n\t\tp.background()\n\t}\n\tatomic.AddInt32(&p.recvs, 1)\n\treturn resp\n\nqueue:\n\tch := p.queue.PutOne(cmd)\n\tif ctxCh := ctx.Done(); ctxCh == nil {\n\t\tresp = <-ch\n\t} else {\n\t\tselect {\n\t\tcase resp = <-ch:\n\t\tcase <-ctxCh:\n\t\t\tgoto abort\n\t\t}\n\t}\n\tatomic.AddInt32(&p.waits, -1)\n\tatomic.AddInt32(&p.recvs, 1)\n\treturn resp\nabort:\n\tgo func(ch chan RedisResult) {\n\t\t<-ch\n\t\tatomic.AddInt32(&p.waits, -1)\n\t\tatomic.AddInt32(&p.recvs, 1)\n\t}(ch)\n\treturn newErrResult(ctx.Err())\n}\n\nfunc (p *pipe) DoMulti(ctx context.Context, multi ...Completed) *redisresults {\n\tresp := resultsp.Get(len(multi), len(multi))\n\tif err := ctx.Err(); err != nil {\n\t\tfor i := 0; i < len(resp.s); i++ {\n\t\t\tresp.s[i] = newErrResult(err)\n\t\t}\n\t\treturn resp\n\t}\n\n\tcmds.CompletedCS(multi[0]).Verify()\n\n\tisOptIn := multi[0].IsOptIn() // len(multi) > 0 should have already been checked by upper layer\n\tnoReply := 0\n\n\tfor _, cmd := range multi {\n\t\tif cmd.NoReply() {\n\t\t\tnoReply++\n\t\t}\n\t}\n\n\tif p.version < 6 && noReply != 0 {\n\t\tif noReply != len(multi) {\n\t\t\tfor i := 0; i < len(resp.s); i++ {\n\t\t\t\tresp.s[i] = newErrResult(ErrRESP2PubSubMixed)\n\t\t\t}\n\t\t\treturn resp\n\t\t} else if p.r2psFn != nil {\n\t\t\tresultsp.Put(resp)\n\t\t\treturn p._r2pipe().DoMulti(ctx, multi...)\n\t\t}\n\t}\n\n\tfor _, cmd := range multi {\n\t\tif cmd.IsBlock() {\n\t\t\tif noReply != 0 {\n\t\t\t\tfor i := 0; i < len(resp.s); i++ {\n\t\t\t\t\tresp.s[i] = newErrResult(ErrBlockingPubSubMixed)\n\t\t\t\t}\n\t\t\t\treturn resp\n\t\t\t}\n\t\t\tatomic.AddInt32(&p.blcksig, 1)\n\t\t\tdefer func() {\n\t\t\t\tfor _, r := range resp.s {\n\t\t\t\t\tif r.err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&p.blcksig, -1)\n\t\t\t}()\n\t\t\tbreak\n\t\t}\n\t}\n\n\twaits := atomic.AddInt32(&p.waits, 1) // if this is 1, and background worker is not started, no need to queue\n\tstate := atomic.LoadInt32(&p.state)\n\n\tif state == 1 {\n\t\tgoto queue\n\t}\n\n\tif state == 0 {\n\t\tif waits != 1 {\n\t\t\tgoto queue\n\t\t}\n\t\tif isOptIn || noReply != 0 {\n\t\t\tp.background()\n\t\t\tgoto queue\n\t\t}\n\t\tdl, ok := ctx.Deadline()\n\t\tif p.queue != nil && !ok && ctx.Done() != nil {\n\t\t\tp.background()\n\t\t\tgoto queue\n\t\t}\n\t\tp.syncDoMulti(dl, ok, resp.s, multi)\n\t} else {\n\t\terr := newErrResult(p.Error())\n\t\tfor i := 0; i < len(resp.s); i++ {\n\t\t\tresp.s[i] = err\n\t\t}\n\t}\n\tif left := atomic.AddInt32(&p.waits, -1); state == 0 && left != 0 {\n\t\tp.background()\n\t}\n\tatomic.AddInt32(&p.recvs, 1)\n\treturn resp\n\nqueue:\n\tch := p.queue.PutMulti(multi, resp.s)\n\tif ctxCh := ctx.Done(); ctxCh == nil {\n\t\t<-ch\n\t} else {\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-ctxCh:\n\t\t\tgoto abort\n\t\t}\n\t}\n\tatomic.AddInt32(&p.waits, -1)\n\tatomic.AddInt32(&p.recvs, 1)\n\treturn resp\nabort:\n\tgo func(resp *redisresults, ch chan RedisResult) {\n\t\t<-ch\n\t\tresultsp.Put(resp)\n\t\tatomic.AddInt32(&p.waits, -1)\n\t\tatomic.AddInt32(&p.recvs, 1)\n\t}(resp, ch)\n\tresp = resultsp.Get(len(multi), len(multi))\n\terr := newErrResult(ctx.Err())\n\tfor i := 0; i < len(resp.s); i++ {\n\t\tresp.s[i] = err\n\t}\n\treturn resp\n}\n\ntype MultiRedisResultStream = RedisResultStream\n\ntype RedisResultStream struct {\n\tp *pool\n\tw *pipe\n\te error\n\tn int\n}\n\n// HasNext can be used in a for loop condition to check if a further WriteTo call is needed.\nfunc (s *RedisResultStream) HasNext() bool {\n\treturn s.n > 0 && s.e == nil\n}\n\n// Error returns the error happened when sending commands to redis or reading response from redis.\n// Usually a user is not required to use this function because the error is also reported by the WriteTo.\nfunc (s *RedisResultStream) Error() error {\n\treturn s.e\n}\n\n// WriteTo reads a redis response from redis and then write it to the given writer.\n// This function is not thread safe and should be called sequentially to read multiple responses.\n// An io.EOF error will be reported if all responses are read.\nfunc (s *RedisResultStream) WriteTo(w io.Writer) (n int64, err error) {\n\tif err = s.e; err == nil && s.n > 0 {\n\t\tvar clean bool\n\t\tif n, err, clean = streamTo(s.w.r, w); !clean {\n\t\t\ts.e = err // err must not be nil in case of !clean\n\t\t\ts.n = 1\n\t\t}\n\t\tif s.n--; s.n == 0 {\n\t\t\tatomic.AddInt32(&s.w.blcksig, -1)\n\t\t\tatomic.AddInt32(&s.w.waits, -1)\n\t\t\tif s.e == nil {\n\t\t\t\ts.e = io.EOF\n\t\t\t} else {\n\t\t\t\ts.w.Close()\n\t\t\t}\n\t\t\ts.p.Store(s.w)\n\t\t}\n\t}\n\treturn n, err\n}\n\nfunc (p *pipe) DoStream(ctx context.Context, pool *pool, cmd Completed) RedisResultStream {\n\tcmds.CompletedCS(cmd).Verify()\n\n\tif err := ctx.Err(); err != nil {\n\t\treturn RedisResultStream{e: err}\n\t}\n\n\tstate := atomic.LoadInt32(&p.state)\n\n\tif state == 1 {\n\t\tpanic(\"DoStream with auto pipelining is a bug\")\n\t}\n\n\tif state == 0 {\n\t\tatomic.AddInt32(&p.blcksig, 1)\n\t\twaits := atomic.AddInt32(&p.waits, 1)\n\t\tif waits != 1 {\n\t\t\tpanic(\"DoStream with racing is a bug\")\n\t\t}\n\t\tdl, ok := ctx.Deadline()\n\t\tif ok {\n\t\t\tif p.timeout > 0 && !cmd.IsBlock() {\n\t\t\t\tdefaultDeadline := time.Now().Add(p.timeout)\n\t\t\t\tif dl.After(defaultDeadline) {\n\t\t\t\t\tdl = defaultDeadline\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.conn.SetDeadline(dl)\n\t\t} else if p.timeout > 0 && !cmd.IsBlock() {\n\t\t\tp.conn.SetDeadline(time.Now().Add(p.timeout))\n\t\t} else {\n\t\t\tp.conn.SetDeadline(time.Time{})\n\t\t}\n\t\t_ = writeCmd(p.w, cmd.Commands())\n\t\tif err := p.w.Flush(); err != nil {\n\t\t\tp.error.CompareAndSwap(nil, &errs{error: err})\n\t\t\tp.conn.Close()\n\t\t\tp.background() // start the background worker to clean up goroutines\n\t\t} else {\n\t\t\treturn RedisResultStream{p: pool, w: p, n: 1}\n\t\t}\n\t}\n\tatomic.AddInt32(&p.blcksig, -1)\n\tatomic.AddInt32(&p.waits, -1)\n\tpool.Store(p)\n\treturn RedisResultStream{e: p.Error()}\n}\n\nfunc (p *pipe) DoMultiStream(ctx context.Context, pool *pool, multi ...Completed) MultiRedisResultStream {\n\tfor _, cmd := range multi {\n\t\tcmds.CompletedCS(cmd).Verify()\n\t}\n\n\tif err := ctx.Err(); err != nil {\n\t\treturn RedisResultStream{e: err}\n\t}\n\n\tstate := atomic.LoadInt32(&p.state)\n\n\tif state == 1 {\n\t\tpanic(\"DoMultiStream with auto pipelining is a bug\")\n\t}\n\n\tif state == 0 {\n\t\tatomic.AddInt32(&p.blcksig, 1)\n\t\twaits := atomic.AddInt32(&p.waits, 1)\n\t\tif waits != 1 {\n\t\t\tpanic(\"DoMultiStream with racing is a bug\")\n\t\t}\n\t\tdl, ok := ctx.Deadline()\n\t\tif ok {\n\t\t\tif p.timeout > 0 {\n\t\t\t\tfor _, cmd := range multi {\n\t\t\t\t\tif cmd.IsBlock() {\n\t\t\t\t\t\tp.conn.SetDeadline(dl)\n\t\t\t\t\t\tgoto process\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdefaultDeadline := time.Now().Add(p.timeout)\n\t\t\t\tif dl.After(defaultDeadline) {\n\t\t\t\t\tdl = defaultDeadline\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.conn.SetDeadline(dl)\n\t\t} else if p.timeout > 0 {\n\t\t\tfor _, cmd := range multi {\n\t\t\t\tif cmd.IsBlock() {\n\t\t\t\t\tp.conn.SetDeadline(time.Time{})\n\t\t\t\t\tgoto process\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.conn.SetDeadline(time.Now().Add(p.timeout))\n\t\t} else {\n\t\t\tp.conn.SetDeadline(time.Time{})\n\t\t}\n\tprocess:\n\t\tfor _, cmd := range multi {\n\t\t\t_ = writeCmd(p.w, cmd.Commands())\n\t\t}\n\t\tif err := p.w.Flush(); err != nil {\n\t\t\tp.error.CompareAndSwap(nil, &errs{error: err})\n\t\t\tp.conn.Close()\n\t\t\tp.background() // start the background worker to clean up goroutines\n\t\t} else {\n\t\t\treturn RedisResultStream{p: pool, w: p, n: len(multi)}\n\t\t}\n\t}\n\tatomic.AddInt32(&p.blcksig, -1)\n\tatomic.AddInt32(&p.waits, -1)\n\tpool.Store(p)\n\treturn RedisResultStream{e: p.Error()}\n}\n\nfunc (p *pipe) syncDo(dl time.Time, dlOk bool, cmd Completed) (resp RedisResult) {\n\tif dlOk {\n\t\tif p.timeout > 0 && !cmd.IsBlock() {\n\t\t\tdefaultDeadline := time.Now().Add(p.timeout)\n\t\t\tif dl.After(defaultDeadline) {\n\t\t\t\tdl = defaultDeadline\n\t\t\t\tdlOk = false\n\t\t\t}\n\t\t}\n\t\tp.conn.SetDeadline(dl)\n\t} else if p.timeout > 0 && !cmd.IsBlock() {\n\t\tp.conn.SetDeadline(time.Now().Add(p.timeout))\n\t} else {\n\t\tp.conn.SetDeadline(time.Time{})\n\t}\n\n\tvar msg RedisMessage\n\terr := flushCmd(p.w, cmd.Commands())\n\tif err == nil {\n\t\tmsg, err = syncRead(p.r)\n\t}\n\tif err != nil {\n\t\tif dlOk && errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\terr = context.DeadlineExceeded\n\t\t}\n\t\tp.error.CompareAndSwap(nil, &errs{error: err})\n\t\tp.conn.Close()\n\t\tp.background() // start the background worker to clean up goroutines\n\t}\n\treturn newResult(msg, err)\n}\n\nfunc (p *pipe) syncDoMulti(dl time.Time, dlOk bool, resp []RedisResult, multi []Completed) {\n\tif dlOk {\n\t\tif p.timeout > 0 {\n\t\t\tfor _, cmd := range multi {\n\t\t\t\tif cmd.IsBlock() {\n\t\t\t\t\tp.conn.SetDeadline(dl)\n\t\t\t\t\tgoto process\n\t\t\t\t}\n\t\t\t}\n\t\t\tdefaultDeadline := time.Now().Add(p.timeout)\n\t\t\tif dl.After(defaultDeadline) {\n\t\t\t\tdl = defaultDeadline\n\t\t\t\tdlOk = false\n\t\t\t}\n\t\t}\n\t\tp.conn.SetDeadline(dl)\n\t} else if p.timeout > 0 {\n\t\tfor _, cmd := range multi {\n\t\t\tif cmd.IsBlock() {\n\t\t\t\tp.conn.SetDeadline(time.Time{})\n\t\t\t\tgoto process\n\t\t\t}\n\t\t}\n\t\tp.conn.SetDeadline(time.Now().Add(p.timeout))\n\t} else {\n\t\tp.conn.SetDeadline(time.Time{})\n\t}\nprocess:\n\tvar err error\n\tvar msg RedisMessage\n\tfor _, cmd := range multi {\n\t\t_ = writeCmd(p.w, cmd.Commands())\n\t}\n\tif err = p.w.Flush(); err != nil {\n\t\tgoto abort\n\t}\n\tfor i := 0; i < len(resp); i++ {\n\t\tif msg, err = syncRead(p.r); err != nil {\n\t\t\tgoto abort\n\t\t}\n\t\tresp[i] = newResult(msg, err)\n\t}\n\treturn\nabort:\n\tif dlOk && errors.Is(err, os.ErrDeadlineExceeded) {\n\t\terr = context.DeadlineExceeded\n\t}\n\tp.error.CompareAndSwap(nil, &errs{error: err})\n\tp.conn.Close()\n\tp.background() // start the background worker to clean up goroutines\n\tfor i := 0; i < len(resp); i++ {\n\t\tresp[i] = newErrResult(err)\n\t}\n}\n\nfunc syncRead(r *bufio.Reader) (m RedisMessage, err error) {\nnext:\n\tif m, err = readNextMessage(r); err != nil {\n\t\treturn m, err\n\t}\n\tif m.typ == '>' {\n\t\tgoto next\n\t}\n\treturn m, nil\n}\n\nfunc (p *pipe) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult {\n\tif p.cache == nil {\n\t\treturn p.Do(ctx, Completed(cmd))\n\t}\n\n\tcmds.CacheableCS(cmd).Verify()\n\n\tif cmd.IsMGet() {\n\t\treturn p.doCacheMGet(ctx, cmd, ttl)\n\t}\n\tck, cc := cmds.CacheKey(cmd)\n\tnow := time.Now()\n\tif v, entry := p.cache.Flight(ck, cc, ttl, now); v.typ != 0 {\n\t\treturn newResult(v, nil)\n\t} else if entry != nil {\n\t\treturn newResult(entry.Wait(ctx))\n\t}\n\tresp := p.DoMulti(\n\t\tctx,\n\t\tcmds.OptInCmd,\n\t\tcmds.MultiCmd,\n\t\tcmds.NewCompleted([]string{\"PTTL\", ck}),\n\t\tCompleted(cmd),\n\t\tcmds.ExecCmd,\n\t)\n\tdefer resultsp.Put(resp)\n\texec, err := resp.s[4].ToArray()\n\tif err != nil {\n\t\tif _, ok := err.(*RedisError); ok {\n\t\t\terr = ErrDoCacheAborted\n\t\t\tif preErr := resp.s[3].Error(); preErr != nil { // if {cmd} get a RedisError\n\t\t\t\tif _, ok := preErr.(*RedisError); ok {\n\t\t\t\t\terr = preErr\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp.cache.Cancel(ck, cc, err)\n\t\treturn newErrResult(err)\n\t}\n\treturn newResult(exec[1], nil)\n}\n\nfunc (p *pipe) doCacheMGet(ctx context.Context, cmd Cacheable, ttl time.Duration) RedisResult {\n\tcommands := cmd.Commands()\n\tkeys := len(commands) - 1\n\tbuilder := cmds.NewBuilder(cmds.InitSlot)\n\tresult := RedisResult{val: RedisMessage{typ: '*', values: nil}}\n\tmgetcc := cmds.MGetCacheCmd(cmd)\n\tif mgetcc[0] == 'J' {\n\t\tkeys-- // the last one of JSON.MGET is a path, not a key\n\t}\n\tentries := entriesp.Get(keys, keys)\n\tdefer entriesp.Put(entries)\n\tvar now = time.Now()\n\tvar rewrite cmds.Arbitrary\n\tfor i, key := range commands[1 : keys+1] {\n\t\tv, entry := p.cache.Flight(key, mgetcc, ttl, now)\n\t\tif v.typ != 0 { // cache hit for one key\n\t\t\tif len(result.val.values) == 0 {\n\t\t\t\tresult.val.values = make([]RedisMessage, keys)\n\t\t\t}\n\t\t\tresult.val.values[i] = v\n\t\t\tcontinue\n\t\t}\n\t\tif entry != nil {\n\t\t\tentries.e[i] = entry // store entries for later entry.Wait() to avoid MGET deadlock each others.\n\t\t\tcontinue\n\t\t}\n\t\tif rewrite.IsZero() {\n\t\t\trewrite = builder.Arbitrary(commands[0])\n\t\t}\n\t\trewrite = rewrite.Args(key)\n\t}\n\n\tvar partial []RedisMessage\n\tif !rewrite.IsZero() {\n\t\tvar rewritten Completed\n\t\tvar keys int\n\t\tif mgetcc[0] == 'J' { // rewrite JSON.MGET path\n\t\t\trewritten = rewrite.Args(commands[len(commands)-1]).MultiGet()\n\t\t\tkeys = len(rewritten.Commands()) - 2\n\t\t} else {\n\t\t\trewritten = rewrite.MultiGet()\n\t\t\tkeys = len(rewritten.Commands()) - 1\n\t\t}\n\n\t\tmulti := make([]Completed, 0, keys+4)\n\t\tmulti = append(multi, cmds.OptInCmd, cmds.MultiCmd)\n\t\tfor _, key := range rewritten.Commands()[1 : keys+1] {\n\t\t\tmulti = append(multi, builder.Pttl().Key(key).Build())\n\t\t}\n\t\tmulti = append(multi, rewritten, cmds.ExecCmd)\n\n\t\tresp := p.DoMulti(ctx, multi...)\n\t\tdefer resultsp.Put(resp)\n\t\texec, err := resp.s[len(multi)-1].ToArray()\n\t\tif err != nil {\n\t\t\tif _, ok := err.(*RedisError); ok {\n\t\t\t\terr = ErrDoCacheAborted\n\t\t\t\tif preErr := resp.s[len(multi)-2].Error(); preErr != nil { // if {rewritten} get a RedisError\n\t\t\t\t\tif _, ok := preErr.(*RedisError); ok {\n\t\t\t\t\t\terr = preErr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, key := range rewritten.Commands()[1 : keys+1] {\n\t\t\t\tp.cache.Cancel(key, mgetcc, err)\n\t\t\t}\n\t\t\treturn newErrResult(err)\n\t\t}\n\t\tdefer func() {\n\t\t\tfor _, cmd := range multi[2 : len(multi)-1] {\n\t\t\t\tcmds.PutCompleted(cmd)\n\t\t\t}\n\t\t}()\n\t\tlast := len(exec) - 1\n\t\tif len(rewritten.Commands()) == len(commands) { // all cache miss\n\t\t\treturn newResult(exec[last], nil)\n\t\t}\n\t\tpartial = exec[last].values\n\t} else { // all cache hit\n\t\tresult.val.attrs = cacheMark\n\t}\n\n\tif len(result.val.values) == 0 {\n\t\tresult.val.values = make([]RedisMessage, keys)\n\t}\n\tfor i, entry := range entries.e {\n\t\tv, err := entry.Wait(ctx)\n\t\tif err != nil {\n\t\t\treturn newErrResult(err)\n\t\t}\n\t\tresult.val.values[i] = v\n\t}\n\n\tj := 0\n\tfor _, ret := range partial {\n\t\tfor ; j < len(result.val.values); j++ {\n\t\t\tif result.val.values[j].typ == 0 {\n\t\t\t\tresult.val.values[j] = ret\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (p *pipe) DoMultiCache(ctx context.Context, multi ...CacheableTTL) *redisresults {\n\tif p.cache == nil {\n\t\tcommands := make([]Completed, len(multi))\n\t\tfor i, ct := range multi {\n\t\t\tcommands[i] = Completed(ct.Cmd)\n\t\t}\n\t\treturn p.DoMulti(ctx, commands...)\n\t}\n\n\tcmds.CacheableCS(multi[0].Cmd).Verify()\n\n\tresults := resultsp.Get(len(multi), len(multi))\n\tentries := entriesp.Get(len(multi), len(multi))\n\tdefer entriesp.Put(entries)\n\tvar missing []Completed\n\tnow := time.Now()\n\tfor _, ct := range multi {\n\t\tif ct.Cmd.IsMGet() {\n\t\t\tpanic(panicmgetcsc)\n\t\t}\n\t}\n\tif cache, ok := p.cache.(*lru); ok {\n\t\tmissed := cache.Flights(now, multi, results.s, entries.e)\n\t\tfor _, i := range missed {\n\t\t\tct := multi[i]\n\t\t\tck, _ := cmds.CacheKey(ct.Cmd)\n\t\t\tmissing = append(missing, cmds.OptInCmd, cmds.MultiCmd, cmds.NewCompleted([]string{\"PTTL\", ck}), Completed(ct.Cmd), cmds.ExecCmd)\n\t\t}\n\t} else {\n\t\tfor i, ct := range multi {\n\t\t\tck, cc := cmds.CacheKey(ct.Cmd)\n\t\t\tv, entry := p.cache.Flight(ck, cc, ct.TTL, now)\n\t\t\tif v.typ != 0 { // cache hit for one key\n\t\t\t\tresults.s[i] = newResult(v, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif entry != nil {\n\t\t\t\tentries.e[i] = entry // store entries for later entry.Wait() to avoid MGET deadlock each others.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmissing = append(missing, cmds.OptInCmd, cmds.MultiCmd, cmds.NewCompleted([]string{\"PTTL\", ck}), Completed(ct.Cmd), cmds.ExecCmd)\n\t\t}\n\t}\n\n\tvar resp *redisresults\n\tif len(missing) > 0 {\n\t\tresp = p.DoMulti(ctx, missing...)\n\t\tdefer resultsp.Put(resp)\n\t\tfor i := 4; i < len(resp.s); i += 5 {\n\t\t\tif err := resp.s[i].Error(); err != nil {\n\t\t\t\tif _, ok := err.(*RedisError); ok {\n\t\t\t\t\terr = ErrDoCacheAborted\n\t\t\t\t\tif preErr := resp.s[i-1].Error(); preErr != nil { // if {cmd} get a RedisError\n\t\t\t\t\t\tif _, ok := preErr.(*RedisError); ok {\n\t\t\t\t\t\t\terr = preErr\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tck, cc := cmds.CacheKey(Cacheable(missing[i-1]))\n\t\t\t\tp.cache.Cancel(ck, cc, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i, entry := range entries.e {\n\t\tresults.s[i] = newResult(entry.Wait(ctx))\n\t}\n\n\tif len(missing) == 0 {\n\t\treturn results\n\t}\n\n\tj := 0\n\tfor i := 4; i < len(resp.s); i += 5 {\n\t\tfor ; j < len(results.s); j++ {\n\t\t\tif results.s[j].val.typ == 0 && results.s[j].err == nil {\n\t\t\t\texec, err := resp.s[i].ToArray()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif _, ok := err.(*RedisError); ok {\n\t\t\t\t\t\terr = ErrDoCacheAborted\n\t\t\t\t\t\tif preErr := resp.s[i-1].Error(); preErr != nil { // if {cmd} get a RedisError\n\t\t\t\t\t\t\tif _, ok := preErr.(*RedisError); ok {\n\t\t\t\t\t\t\t\terr = preErr\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresults.s[j] = newErrResult(err)\n\t\t\t\t} else {\n\t\t\t\t\tresults.s[j] = newResult(exec[len(exec)-1], nil)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn results\n}\n\nfunc (p *pipe) Error() error {\n\tif err, ok := p.error.Load().(*errs); ok {\n\t\treturn err.error\n\t}\n\treturn nil\n}\n\nfunc (p *pipe) Close() {\n\tp.error.CompareAndSwap(nil, errClosing)\n\tblock := atomic.AddInt32(&p.blcksig, 1)\n\twaits := atomic.AddInt32(&p.waits, 1)\n\tstopping1 := atomic.CompareAndSwapInt32(&p.state, 0, 2)\n\tstopping2 := atomic.CompareAndSwapInt32(&p.state, 1, 2)\n\tif p.queue != nil {\n\t\tif stopping1 && waits == 1 { // make sure there is no sync read\n\t\t\tp.background()\n\t\t}\n\t\tif block == 1 && (stopping1 || stopping2) { // make sure there is no block cmd\n\t\t\tatomic.AddInt32(&p.waits, 1)\n\t\t\tch := p.queue.PutOne(cmds.PingCmd)\n\t\t\tselect {\n\t\t\tcase <-ch:\n\t\t\t\tatomic.AddInt32(&p.waits, -1)\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tgo func(ch chan RedisResult) {\n\t\t\t\t\t<-ch\n\t\t\t\t\tatomic.AddInt32(&p.waits, -1)\n\t\t\t\t}(ch)\n\t\t\t}\n\t\t}\n\t}\n\tatomic.AddInt32(&p.waits, -1)\n\tatomic.AddInt32(&p.blcksig, -1)\n\tif p.conn != nil {\n\t\tp.conn.Close()\n\t}\n\tp.r2mu.Lock()\n\tif p.r2pipe != nil {\n\t\tp.r2pipe.Close()\n\t}\n\tp.r2mu.Unlock()\n}\n\ntype pshks struct {\n\thooks PubSubHooks\n\tclose chan error\n}\n\nvar emptypshks = &pshks{\n\thooks: PubSubHooks{\n\t\tOnMessage:      func(m PubSubMessage) {},\n\t\tOnSubscription: func(s PubSubSubscription) {},\n\t},\n\tclose: nil,\n}\n\nvar emptyclhks = func(error) {}\n\nfunc deadFn() *pipe {\n\tdead := &pipe{state: 3}\n\tdead.error.Store(errClosing)\n\tdead.pshks.Store(emptypshks)\n\tdead.clhks.Store(emptyclhks)\n\treturn dead\n}\n\nfunc epipeFn(err error) *pipe {\n\tdead := &pipe{state: 3}\n\tdead.error.Store(&errs{error: err})\n\tdead.pshks.Store(emptypshks)\n\tdead.clhks.Store(emptyclhks)\n\treturn dead\n}\n\nconst (\n\tprotocolbug  = \"protocol bug, message handled out of order\"\n\twrongreceive = \"only SUBSCRIBE, SSUBSCRIBE, or PSUBSCRIBE command are allowed in Receive\"\n\tmultiexecsub = \"SUBSCRIBE/UNSUBSCRIBE are not allowed in MULTI/EXEC block\"\n\tpanicmgetcsc = \"MGET and JSON.MGET in DoMultiCache are not implemented, use DoCache instead\"\n)\n\nvar cacheMark = &(RedisMessage{})\nvar errClosing = &errs{error: ErrClosing}\n\ntype errs struct{ error }\n"
        },
        {
          "name": "pipe_test.go",
          "type": "blob",
          "size": 144.5654296875,
          "content": "package rueidis\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\ntype redisExpect struct {\n\t*redisMock\n\terr error\n}\n\ntype redisMock struct {\n\tt    *testing.T\n\tbuf  *bufio.Reader\n\tconn net.Conn\n}\n\nfunc (r *redisMock) ReadMessage() (RedisMessage, error) {\n\tm, err := readNextMessage(r.buf)\n\tif err != nil {\n\t\treturn RedisMessage{}, err\n\t}\n\treturn m, nil\n}\n\nfunc (r *redisMock) Expect(expected ...string) *redisExpect {\n\tif len(expected) == 0 {\n\t\treturn &redisExpect{redisMock: r}\n\t}\n\tm, err := r.ReadMessage()\n\tif err != nil {\n\t\treturn &redisExpect{redisMock: r, err: err}\n\t}\n\tif len(expected) != len(m.values) {\n\t\tr.t.Fatalf(\"redismock receive unexpected command length: expected %v, got : %v\", len(expected), m.values)\n\t}\n\tfor i, expected := range expected {\n\t\tif m.values[i].string != expected {\n\t\t\tr.t.Fatalf(\"redismock receive unexpected command: expected %v, got : %v\", expected, m.values[i])\n\t\t}\n\t}\n\treturn &redisExpect{redisMock: r}\n}\n\nfunc (r *redisExpect) ReplyString(replies ...string) *redisExpect {\n\tfor _, reply := range replies {\n\t\tif r.err == nil {\n\t\t\tr.Reply(RedisMessage{typ: '+', string: reply})\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (r *redisExpect) ReplyBlobString(replies ...string) *redisExpect {\n\tfor _, reply := range replies {\n\t\tif r.err == nil {\n\t\t\tr.Reply(RedisMessage{typ: '$', string: reply})\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (r *redisExpect) ReplyError(replies ...string) *redisExpect {\n\tfor _, reply := range replies {\n\t\tif r.err == nil {\n\t\t\tr.Reply(RedisMessage{typ: '-', string: reply})\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (r *redisExpect) ReplyInteger(replies ...int64) *redisExpect {\n\tfor _, reply := range replies {\n\t\tif r.err == nil {\n\t\t\tr.Reply(RedisMessage{typ: ':', integer: reply})\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (r *redisExpect) Reply(replies ...RedisMessage) *redisExpect {\n\tfor _, reply := range replies {\n\t\tif r.err == nil {\n\t\t\tr.err = write(r.conn, reply)\n\t\t}\n\t}\n\treturn r\n}\n\nfunc (r *redisMock) Close() {\n\tr.conn.Close()\n}\n\nfunc write(o io.Writer, m RedisMessage) (err error) {\n\t_, err = o.Write([]byte{m.typ})\n\tswitch m.typ {\n\tcase '$':\n\t\t_, _ = o.Write(append([]byte(strconv.Itoa(len(m.string))), '\\r', '\\n'))\n\t\t_, err = o.Write(append([]byte(m.string), '\\r', '\\n'))\n\tcase '+', '-', '_':\n\t\t_, err = o.Write(append([]byte(m.string), '\\r', '\\n'))\n\tcase ':':\n\t\t_, err = o.Write(append([]byte(strconv.FormatInt(m.integer, 10)), '\\r', '\\n'))\n\tcase '%', '>', '*':\n\t\tsize := int64(len(m.values))\n\t\tif m.typ == '%' {\n\t\t\tif size%2 != 0 {\n\t\t\t\tpanic(\"map message with wrong value length\")\n\t\t\t}\n\t\t\tsize /= 2\n\t\t}\n\t\t_, err = o.Write(append([]byte(strconv.FormatInt(size, 10)), '\\r', '\\n'))\n\t\tfor _, v := range m.values {\n\t\t\terr = write(o, v)\n\t\t}\n\tdefault:\n\t\tpanic(\"unimplemented write type\")\n\t}\n\treturn err\n}\n\nfunc setup(t *testing.T, option ClientOption) (*pipe, *redisMock, func(), func()) {\n\tif option.CacheSizeEachConn <= 0 {\n\t\toption.CacheSizeEachConn = DefaultCacheBytes\n\t}\n\tn1, n2 := net.Pipe()\n\tmock := &redisMock{\n\t\tt:    t,\n\t\tbuf:  bufio.NewReader(n2),\n\t\tconn: n2,\n\t}\n\tgo func() {\n\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\tReply(RedisMessage{\n\t\t\t\ttyp: '%',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"version\"},\n\t\t\t\t\t{typ: '+', string: \"6.0.0\"},\n\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t},\n\t\t\t})\n\t\tif !option.DisableCache {\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t}\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t}()\n\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &option)\n\tif err != nil {\n\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t}\n\tif info := p.Info(); info[\"version\"].string != \"6.0.0\" {\n\t\tt.Fatalf(\"pipe setup failed, unexpected hello response: %v\", p.Info())\n\t}\n\tif version := p.Version(); version != 6 {\n\t\tt.Fatalf(\"pipe setup failed, unexpected version: %v\", p.Version())\n\t}\n\treturn p, mock, func() {\n\t\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\t\tp.Close()\n\t\t\tmock.Close()\n\t\t\tfor atomic.LoadInt32(&p.state) != 4 {\n\t\t\t\tt.Log(\"wait the pipe to be closed\")\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t}\n\t\t}, func() {\n\t\t\tn1.Close()\n\t\t\tn2.Close()\n\t\t}\n}\n\nfunc ExpectOK(t *testing.T, result RedisResult) {\n\tval, err := result.ToMessage()\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error result: %v\", err)\n\t}\n\tif str, _ := val.ToString(); str != \"OK\" {\n\t\tt.Errorf(\"unexpected result: %v\", str)\n\t}\n}\n\nfunc TestNewPipe(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"Auth without Username\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"default\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"NO-TOUCH\", \"ON\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"NO-EVICT\", \"ON\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", \"libname\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:      1,\n\t\t\tPassword:      \"pa\",\n\t\t\tClientName:    \"cn\",\n\t\t\tClientNoEvict: true,\n\t\t\tClientSetInfo: []string{\"libname\", \"1\"},\n\t\t\tClientNoTouch: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"AlwaysRESP2\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"AUTH\", \"pa\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"NO-TOUCH\", \"ON\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"NO-EVICT\", \"ON\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", \"libname\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:      1,\n\t\t\tPassword:      \"pa\",\n\t\t\tClientName:    \"cn\",\n\t\t\tClientNoEvict: true,\n\t\t\tClientSetInfo: []string{\"libname\", \"1\"},\n\t\t\tClientNoTouch: true,\n\t\t\tAlwaysRESP2:   true,\n\t\t\tDisableCache:  true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Auth with Username\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"ua\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:   1,\n\t\t\tUsername:   \"ua\",\n\t\t\tPassword:   \"pa\",\n\t\t\tClientName: \"cn\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Auth with Credentials Function\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"ua\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB: 1,\n\t\t\tAuthCredentialsFn: func(context AuthCredentialsContext) (AuthCredentials, error) {\n\t\t\t\treturn AuthCredentials{\n\t\t\t\t\tUsername: \"ua\",\n\t\t\t\t\tPassword: \"pa\",\n\t\t\t\t}, nil\n\t\t\t},\n\t\t\tClientName: \"cn\",\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"With ClientSideTrackingOptions\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\", \"NOLOOP\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tClientTrackingOptions: []string{\"OPTIN\", \"NOLOOP\"},\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Init with ReplicaOnly\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"ua\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"READONLY\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:    1,\n\t\t\tUsername:    \"ua\",\n\t\t\tPassword:    \"pa\",\n\t\t\tClientName:  \"cn\",\n\t\t\tReplicaOnly: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Init with ReplicaOnly ignores READONLY Error\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"ua\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"READONLY\").\n\t\t\t\tReplyError(\"This instance has cluster support disabled\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:    1,\n\t\t\tUsername:    \"ua\",\n\t\t\tPassword:    \"pa\",\n\t\t\tClientName:  \"cn\",\n\t\t\tReplicaOnly: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Network Error\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tn1.Close()\n\t\tn2.Close()\n\t\tif _, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{}); err != io.ErrClosedPipe {\n\t\t\tt.Fatalf(\"pipe setup should failed with io.ErrClosedPipe, but got %v\", err)\n\t\t}\n\t})\n\tt.Run(\"Auth Credentials Function Error\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\t_, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB: 1,\n\t\t\tAuthCredentialsFn: func(context AuthCredentialsContext) (AuthCredentials, error) {\n\t\t\t\treturn AuthCredentials{}, fmt.Errorf(\"auth credential failure\")\n\t\t\t},\n\t\t\tClientName: \"cn\",\n\t\t})\n\t\tif err.Error() != \"auth credential failure\" {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"With DisableClientSetInfo\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\t\tReply(RedisMessage{\n\t\t\t\t\ttyp: '%',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tClientSetInfo: DisableClientSetInfo,\n\t\t})\n\t\tgo func() {\n\t\t\tmock.Expect(\"PING\").\n\t\t\t\tReplyString(\"OK\")\n\t\t}()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n}\n\nfunc TestNewRESP2Pipe(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"Without DisableCache\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyError(\"ERR unknown subcommand or wrong number of arguments for 'TRACKING'. Try CLIENT HELP\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\t}()\n\t\tif _, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{}); !errors.Is(err, ErrNoCache) {\n\t\t\tt.Fatalf(\"unexpected err: %v\", err)\n\t\t}\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Without DisableCache 2\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\t}()\n\t\tif _, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{}); !errors.Is(err, ErrNoCache) {\n\t\t\tt.Fatalf(\"unexpected err: %v\", err)\n\t\t}\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"With Hello Proto 2\", func(t *testing.T) { // kvrocks version 2.2.0\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"server\"},\n\t\t\t\t\t{typ: '+', string: \"redis\"},\n\t\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t}})\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tDisableCache: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tif p.version >= 6 {\n\t\t\tt.Fatalf(\"unexpected p.version: %v\", p.version)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Auth without Username\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"default\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"AUTH\", \"pa\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:     1,\n\t\t\tPassword:     \"pa\",\n\t\t\tClientName:   \"cn\",\n\t\t\tDisableCache: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tif p.version >= 6 {\n\t\t\tt.Fatalf(\"unexpected p.version: %v\", p.version)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Auth with Username\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"ua\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"AUTH\", \"ua\", \"pa\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:     1,\n\t\t\tUsername:     \"ua\",\n\t\t\tPassword:     \"pa\",\n\t\t\tClientName:   \"cn\",\n\t\t\tDisableCache: true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tif p.version >= 6 {\n\t\t\tt.Fatalf(\"unexpected p.version: %v\", p.version)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Init with ReplicaOnly\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"default\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"READONLY\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"AUTH\", \"pa\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"READONLY\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:     1,\n\t\t\tPassword:     \"pa\",\n\t\t\tClientName:   \"cn\",\n\t\t\tDisableCache: true,\n\t\t\tReplicaOnly:  true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tif p.version >= 6 {\n\t\t\tt.Fatalf(\"unexpected p.version: %v\", p.version)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Init with ReplicaOnly ignores READONLY error\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"default\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"READONLY\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"AUTH\", \"pa\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyString(\"OK\")\n\t\t\tmock.Expect(\"READONLY\").\n\t\t\t\tReplyError(\"This instance has cluster support disabled\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:     1,\n\t\t\tPassword:     \"pa\",\n\t\t\tClientName:   \"cn\",\n\t\t\tDisableCache: true,\n\t\t\tReplicaOnly:  true,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tif p.version >= 6 {\n\t\t\tt.Fatalf(\"unexpected p.version: %v\", p.version)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n\tt.Run(\"Network Error\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\", \"AUTH\", \"ua\", \"pa\", \"SETNAME\", \"cn\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t\tmock.Expect(\"SELECT\", \"1\").\n\t\t\t\tReplyError(\"ERR ACL\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tn1.Close()\n\t\t\tn2.Close()\n\t\t}()\n\t\t_, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tSelectDB:     1,\n\t\t\tUsername:     \"ua\",\n\t\t\tPassword:     \"pa\",\n\t\t\tClientName:   \"cn\",\n\t\t\tDisableCache: true,\n\t\t})\n\t\tif err != io.ErrClosedPipe {\n\t\t\tt.Fatalf(\"pipe setup should failed with io.ErrClosedPipe, but got %v\", err)\n\t\t}\n\t})\n\tt.Run(\"With DisableClientSetInfo\", func(t *testing.T) {\n\t\tn1, n2 := net.Pipe()\n\t\tmock := &redisMock{buf: bufio.NewReader(n2), conn: n2, t: t}\n\t\tgo func() {\n\t\t\tmock.Expect(\"HELLO\", \"3\").\n\t\t\t\tReplyError(\"ERR unknown command `HELLO`\")\n\t\t}()\n\t\tp, err := newPipe(func() (net.Conn, error) { return n1, nil }, &ClientOption{\n\t\t\tDisableCache:  true,\n\t\t\tClientSetInfo: DisableClientSetInfo,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"pipe setup failed: %v\", err)\n\t\t}\n\t\tif p.version >= 6 {\n\t\t\tt.Fatalf(\"unexpected p.version: %v\", p.version)\n\t\t}\n\t\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\t\tp.Close()\n\t\tmock.Close()\n\t\tn1.Close()\n\t\tn2.Close()\n\t})\n}\n\nfunc TestWriteSingleFlush(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() { mock.Expect(\"PING\").ReplyString(\"OK\") }()\n\tExpectOK(t, p.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})))\n}\n\nfunc TestIgnoreOutOfBandDataDuringSyncMode(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() {\n\t\tmock.Expect(\"PING\").Reply(RedisMessage{typ: '>', string: \"This should be ignore\"}).ReplyString(\"OK\")\n\t}()\n\tExpectOK(t, p.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})))\n}\n\nfunc TestWriteSinglePipelineFlush(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tExpectOK(t, p.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})))\n\t\t}()\n\t}\n\tfor i := 0; i < times; i++ {\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t}\n}\n\nfunc TestWriteWithMaxFlushDelay(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{\n\t\tAlwaysPipelining: true,\n\t\tMaxFlushDelay:    20 * time.Microsecond,\n\t})\n\tdefer cancel()\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tExpectOK(t, p.Do(context.Background(), cmds.NewCompleted([]string{\"PING\"})))\n\t\t}()\n\t}\n\tfor i := 0; i < times; i++ {\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t}\n}\n\nfunc TestBlockWriteWithNoMaxFlushDelay(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{\n\t\tAlwaysPipelining: true,\n\t\tMaxFlushDelay:    20 * time.Microsecond,\n\t})\n\tdefer cancel()\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tfor _, resp := range p.DoMulti(context.Background(),\n\t\t\t\tcmds.NewBlockingCompleted([]string{\"PING\"}),\n\t\t\t\tcmds.NewBlockingCompleted([]string{\"PING\"})).s {\n\t\t\t\tExpectOK(t, resp)\n\t\t\t}\n\t\t}()\n\t}\n\tfor i := 0; i < times; i++ {\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\").Expect(\"PING\").ReplyString(\"OK\")\n\t}\n}\n\nfunc TestWriteMultiFlush(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() {\n\t\tmock.Expect(\"PING\").Expect(\"PING\").ReplyString(\"OK\").ReplyString(\"OK\")\n\t}()\n\tfor _, resp := range p.DoMulti(context.Background(), cmds.NewCompleted([]string{\"PING\"}), cmds.NewCompleted([]string{\"PING\"})).s {\n\t\tExpectOK(t, resp)\n\t}\n}\n\nfunc TestWriteMultiPipelineFlush(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tfor _, resp := range p.DoMulti(context.Background(), cmds.NewCompleted([]string{\"PING\"}), cmds.NewCompleted([]string{\"PING\"})).s {\n\t\t\t\tExpectOK(t, resp)\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor i := 0; i < times; i++ {\n\t\tmock.Expect(\"PING\").Expect(\"PING\").ReplyString(\"OK\").ReplyString(\"OK\")\n\t}\n}\n\nfunc TestDoStreamAutoPipelinePanic(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, shutdown := setup(t, ClientOption{})\n\tp.background()\n\tdefer func() {\n\t\tif msg := recover(); !strings.Contains(msg.(string), \"bug\") {\n\t\t\tt.Fatal(\"should panic\")\n\t\t}\n\t\tshutdown()\n\t}()\n\tp.DoStream(context.Background(), nil, cmds.NewCompleted([]string{\"PING\"}))\n}\n\nfunc TestDoMultiStreamAutoPipelinePanic(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, shutdown := setup(t, ClientOption{})\n\tp.background()\n\tdefer func() {\n\t\tif msg := recover(); !strings.Contains(msg.(string), \"bug\") {\n\t\t\tt.Fatal(\"should panic\")\n\t\t}\n\t\tshutdown()\n\t}()\n\tp.DoMultiStream(context.Background(), nil, cmds.NewCompleted([]string{\"PING\"}))\n}\n\nfunc TestDoStreamConcurrentPanic(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, shutdown := setup(t, ClientOption{})\n\tdefer func() {\n\t\tif msg := recover(); !strings.Contains(msg.(string), \"bug\") {\n\t\t\tt.Fatal(\"should panic\")\n\t\t}\n\t\tshutdown()\n\t}()\n\tgo func() {\n\t\tmock.Expect(\"PING\")\n\t}()\n\tp.DoStream(context.Background(), nil, cmds.NewCompleted([]string{\"PING\"}))\n\tp.DoStream(context.Background(), nil, cmds.NewCompleted([]string{\"PING\"}))\n}\n\nfunc TestDoMultiStreamConcurrentPanic(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, shutdown := setup(t, ClientOption{})\n\tdefer func() {\n\t\tif msg := recover(); !strings.Contains(msg.(string), \"bug\") {\n\t\t\tt.Fatal(\"should panic\")\n\t\t}\n\t\tshutdown()\n\t}()\n\tgo func() {\n\t\tmock.Expect(\"PING\")\n\t}()\n\tp.DoMultiStream(context.Background(), nil, cmds.NewCompleted([]string{\"PING\"}))\n\tp.DoMultiStream(context.Background(), nil, cmds.NewCompleted([]string{\"PING\"}))\n}\n\nfunc TestDoStreamRecycle(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() {\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t}()\n\tconns := newPool(1, nil, 0, 0, nil)\n\ts := p.DoStream(context.Background(), conns, cmds.NewCompleted([]string{\"PING\"}))\n\tbuf := bytes.NewBuffer(nil)\n\tif err := s.Error(); err != nil {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tfor s.HasNext() {\n\t\tn, err := s.WriteTo(buf)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t\t}\n\t\tif n != 2 {\n\t\t\tt.Errorf(\"unexpected n %v\\n\", n)\n\t\t}\n\t}\n\tif buf.String() != \"OK\" {\n\t\tt.Errorf(\"unexpected result %v\\n\", buf.String())\n\t}\n\tif err := s.Error(); err != io.EOF {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tif w := conns.Acquire(); w != p {\n\t\tt.Errorf(\"pipe is not recycled\\n\")\n\t}\n}\n\ntype limitedbuffer struct {\n\tbuf []byte\n}\n\nfunc (b *limitedbuffer) String() string {\n\treturn string(b.buf)\n}\n\nfunc (b *limitedbuffer) Write(buf []byte) (n int, err error) {\n\treturn n, err\n}\n\nfunc (b *limitedbuffer) ReadFrom(r io.Reader) (n int64, err error) {\n\tif n, err := r.Read(b.buf); err == nil {\n\t\treturn int64(n), io.EOF\n\t} else {\n\t\treturn int64(n), err\n\t}\n}\n\nfunc TestDoStreamRecycleDestinationFull(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() {\n\t\tmock.Expect(\"PING\").ReplyBlobString(\"OK\")\n\t}()\n\tconns := newPool(1, nil, 0, 0, nil)\n\ts := p.DoStream(context.Background(), conns, cmds.NewCompleted([]string{\"PING\"}))\n\tbuf := &limitedbuffer{buf: make([]byte, 1)}\n\tif err := s.Error(); err != nil {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tfor s.HasNext() {\n\t\tn, err := s.WriteTo(buf)\n\t\tif err != io.EOF {\n\t\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t\t}\n\t\tif n != 1 {\n\t\t\tt.Errorf(\"unexpected n %v\\n\", n)\n\t\t}\n\t}\n\tif buf.String() != \"O\" {\n\t\tt.Errorf(\"unexpected result %v\\n\", buf.String())\n\t}\n\tif err := s.Error(); err != io.EOF {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tif w := conns.Acquire(); w != p {\n\t\tt.Errorf(\"pipe is not recycled\\n\")\n\t}\n}\n\nfunc TestDoMultiStreamRecycle(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() {\n\t\tmock.Expect(\"PING\").Expect(\"PING\").ReplyString(\"OK\").ReplyString(\"OK\")\n\t}()\n\tconns := newPool(1, nil, 0, 0, nil)\n\ts := p.DoMultiStream(context.Background(), conns, cmds.NewCompleted([]string{\"PING\"}), cmds.NewCompleted([]string{\"PING\"}))\n\tbuf := bytes.NewBuffer(nil)\n\tif err := s.Error(); err != nil {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tfor s.HasNext() {\n\t\tn, err := s.WriteTo(buf)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t\t}\n\t\tif n != 2 {\n\t\t\tt.Errorf(\"unexpected n %v\\n\", n)\n\t\t}\n\t}\n\tif buf.String() != \"OKOK\" {\n\t\tt.Errorf(\"unexpected result %v\\n\", buf.String())\n\t}\n\tif err := s.Error(); err != io.EOF {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tif w := conns.Acquire(); w != p {\n\t\tt.Errorf(\"pipe is not recycled\\n\")\n\t}\n}\n\nfunc TestDoMultiStreamRecycleDestinationFull(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\tgo func() {\n\t\tmock.Expect(\"PING\").Expect(\"PING\").ReplyBlobString(\"OK\").ReplyBlobString(\"OK\")\n\t}()\n\tconns := newPool(1, nil, 0, 0, nil)\n\ts := p.DoMultiStream(context.Background(), conns, cmds.NewCompleted([]string{\"PING\"}), cmds.NewCompleted([]string{\"PING\"}))\n\tbuf := &limitedbuffer{buf: make([]byte, 1)}\n\tif err := s.Error(); err != nil {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tfor s.HasNext() {\n\t\tn, err := s.WriteTo(buf)\n\t\tif err != io.EOF {\n\t\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t\t}\n\t\tif n != 1 {\n\t\t\tt.Errorf(\"unexpected n %v\\n\", n)\n\t\t}\n\t}\n\tif buf.String() != \"O\" {\n\t\tt.Errorf(\"unexpected result %v\\n\", buf.String())\n\t}\n\tif err := s.Error(); err != io.EOF {\n\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t}\n\tif w := conns.Acquire(); w != p {\n\t\tt.Errorf(\"pipe is not recycled\\n\")\n\t}\n}\n\nfunc TestNoReplyExceedRingSize(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\ttimes := (2 << (DefaultRingScale - 1)) * 3\n\twait := make(chan struct{})\n\tgo func() {\n\t\tfor i := 0; i < times; i++ {\n\t\t\tif err := p.Do(context.Background(), cmds.UnsubscribeCmd).Error(); err != nil {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tclose(wait)\n\t}()\n\n\tfor i := 0; i < times; i++ {\n\t\tmock.Expect(\"UNSUBSCRIBE\").Reply(RedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t{typ: '+', string: \"1\"},\n\t\t\t{typ: ':', integer: 0},\n\t\t}}).Expect(cmds.PingCmd.Commands()...).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t}\n\t<-wait\n}\n\nfunc TestPanicOnProtocolBug(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\n\tgo func() {\n\t\tmock.Expect().ReplyString(\"cause panic\")\n\t}()\n\n\tdefer func() {\n\t\tif v := recover(); v != protocolbug {\n\t\t\tt.Fatalf(\"should panic on protocolbug\")\n\t\t}\n\t}()\n\n\tp._backgroundRead()\n}\n\nfunc TestResponseSequenceWithPushMessageInjected(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tv := strconv.Itoa(i)\n\t\t\tif val, _ := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", v})).ToMessage(); val.string != v {\n\t\t\t\tt.Errorf(\"out of order response, expected %v, got %v\", v, val.string)\n\t\t\t}\n\t\t}(i)\n\t}\n\tfor i := 0; i < times; i++ {\n\t\tm, _ := mock.ReadMessage()\n\t\tmock.Expect().ReplyString(m.values[1].string).\n\t\t\tReply(RedisMessage{typ: '>', values: []RedisMessage{{typ: '+', string: \"should be ignore\"}}})\n\t}\n\twg.Wait()\n}\n\nfunc TestClientSideCaching(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\texpectCSC := func(ttl int64, resp string) {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a\").\n\t\t\tExpect(\"GET\", \"a\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: ttl},\n\t\t\t\t{typ: '+', string: resp},\n\t\t\t}})\n\t}\n\tinvalidateCSC := func(keys RedisMessage) {\n\t\tmock.Expect().Reply(RedisMessage{\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\tkeys,\n\t\t\t},\n\t\t})\n\t}\n\n\tgo func() {\n\t\texpectCSC(-1, \"1\")\n\t}()\n\t// single flight\n\tmiss := uint64(0)\n\thits := uint64(0)\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).ToMessage()\n\t\t\tif v.string != \"1\" {\n\t\t\t\tt.Errorf(\"unexpected cached result, expected %v, got %v\", \"1\", v.string)\n\t\t\t}\n\t\t\tif v.IsCacheHit() {\n\t\t\t\tatomic.AddUint64(&hits, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddUint64(&miss, 1)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\tif v := atomic.LoadUint64(&miss); v != 1 {\n\t\tt.Fatalf(\"unexpected cache miss count %v\", v)\n\t}\n\n\tif v := atomic.LoadUint64(&hits); v != uint64(times-1) {\n\t\tt.Fatalf(\"unexpected cache hits count %v\", v)\n\t}\n\n\t// cache invalidation\n\tinvalidateCSC(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}})\n\tgo func() {\n\t\texpectCSC(-1, \"2\")\n\t}()\n\n\tfor {\n\t\tif v, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), time.Second).ToMessage(); v.string == \"2\" {\n\t\t\tbreak\n\t\t}\n\t\tt.Logf(\"waiting for invalidating\")\n\t}\n\n\t// cache flush invalidation\n\tinvalidateCSC(RedisMessage{typ: '_'})\n\tgo func() {\n\t\texpectCSC(-1, \"3\")\n\t}()\n\n\tfor {\n\t\tif v, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), time.Second).ToMessage(); v.string == \"3\" {\n\t\t\tbreak\n\t\t}\n\t\tt.Logf(\"waiting for invalidating\")\n\t}\n}\n\nfunc TestClientSideCachingExecAbort(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\tgo func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\tExpect(\"GET\", \"a1\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '_'})\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\tExpect(\"GET\", \"a2\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyError(\"MOVED 0 127.0.0.1\").\n\t\t\tReplyError(\"MOVED 0 127.0.0.1\").\n\t\t\tReply(RedisMessage{typ: '_'})\n\t}()\n\n\tfor i, key := range []string{\"a1\", \"a2\"} {\n\t\tv, err := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", key})), 10*time.Second).ToMessage()\n\t\tif i == 0 {\n\t\t\tif err != ErrDoCacheAborted {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif re, ok := err.(*RedisError); !ok {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t} else if _, moved := re.IsMoved(); !moved {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t}\n\t\t}\n\t\tif v.IsCacheHit() {\n\t\t\tt.Errorf(\"unexpected cache hit\")\n\t\t}\n\t\tif v, entry := p.cache.Flight(key, \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t\t}\n\t}\n}\n\nfunc TestClientSideCachingWithNonRedisError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\tcloseConn()\n\n\tv, err := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).ToMessage()\n\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t}\n\tif v.IsCacheHit() {\n\t\tt.Errorf(\"unexpected cache hit\")\n\t}\n\tif v, entry := p.cache.Flight(\"a\", \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t}\n}\n\nfunc TestClientSideCachingMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\tinvalidateCSC := func(keys RedisMessage) {\n\t\tmock.Expect().Reply(RedisMessage{\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\tkeys,\n\t\t\t},\n\t\t})\n\t}\n\n\tgo func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\tExpect(\"MGET\", \"a1\", \"a2\", \"a3\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 1000},\n\t\t\t\t{typ: ':', integer: 2000},\n\t\t\t\t{typ: ':', integer: 3000},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t}},\n\t\t\t}})\n\t}()\n\t// single flight\n\tmiss := uint64(0)\n\thits := uint64(0)\n\tfor i := 0; i < 2; i++ {\n\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a1\", \"a2\", \"a3\"})), 10*time.Second).ToMessage()\n\t\tarr, _ := v.ToArray()\n\t\tif len(arr) != 3 {\n\t\t\tt.Errorf(\"unexpected cached mget length, expected 3, got %v\", len(arr))\n\t\t}\n\t\tfor i, v := range arr {\n\t\t\tif v.integer != int64(i+1) {\n\t\t\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", i+1, v.integer)\n\t\t\t}\n\t\t}\n\t\tif ttl := p.cache.(*lru).GetTTL(\"a1\", \"GET\"); !roughly(ttl, time.Second) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif ttl := p.cache.(*lru).GetTTL(\"a2\", \"GET\"); !roughly(ttl, time.Second*2) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif ttl := p.cache.(*lru).GetTTL(\"a3\", \"GET\"); !roughly(ttl, time.Second*3) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif v.IsCacheHit() {\n\t\t\tatomic.AddUint64(&hits, 1)\n\t\t} else {\n\t\t\tatomic.AddUint64(&miss, 1)\n\t\t}\n\t}\n\n\tif v := atomic.LoadUint64(&miss); v != 1 {\n\t\tt.Fatalf(\"unexpected cache miss count %v\", v)\n\t}\n\n\tif v := atomic.LoadUint64(&hits); v != uint64(1) {\n\t\tt.Fatalf(\"unexpected cache hits count %v\", v)\n\t}\n\n\t// partial cache invalidation\n\tinvalidateCSC(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a1\"}, {typ: '+', string: \"a3\"}}})\n\tgo func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\tExpect(\"MGET\", \"a1\", \"a3\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 10000},\n\t\t\t\t{typ: ':', integer: 30000},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 10},\n\t\t\t\t\t{typ: ':', integer: 30},\n\t\t\t\t}},\n\t\t\t}})\n\t}()\n\n\tfor {\n\t\tif p.cache.(*lru).GetTTL(\"a1\", \"GET\") == -2 && p.cache.(*lru).GetTTL(\"a3\", \"GET\") == -2 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a1\", \"a2\", \"a3\"})), 10*time.Second).ToMessage()\n\tarr, _ := v.ToArray()\n\tif len(arr) != 3 {\n\t\tt.Errorf(\"unexpected cached mget length, expected 3, got %v\", len(arr))\n\t}\n\tif arr[1].integer != 2 {\n\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 2, arr[1].integer)\n\t}\n\tif arr[0].integer != 10 {\n\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 10, arr[0].integer)\n\t}\n\tif arr[2].integer != 30 {\n\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 30, arr[2].integer)\n\t}\n\tif ttl := p.cache.(*lru).GetTTL(\"a1\", \"GET\"); !roughly(ttl, time.Second*10) {\n\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t}\n\tif ttl := p.cache.(*lru).GetTTL(\"a2\", \"GET\"); !roughly(ttl, time.Second*2) {\n\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t}\n\tif ttl := p.cache.(*lru).GetTTL(\"a3\", \"GET\"); !roughly(ttl, time.Second*30) {\n\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t}\n}\n\nfunc TestClientSideCachingJSONMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\tinvalidateCSC := func(keys RedisMessage) {\n\t\tmock.Expect().Reply(RedisMessage{\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\tkeys,\n\t\t\t},\n\t\t})\n\t}\n\n\tgo func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\tExpect(\"JSON.MGET\", \"a1\", \"a2\", \"a3\", \"$\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 1000},\n\t\t\t\t{typ: ':', integer: 2000},\n\t\t\t\t{typ: ':', integer: 3000},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t}},\n\t\t\t}})\n\t}()\n\t// single flight\n\tmiss := uint64(0)\n\thits := uint64(0)\n\tfor i := 0; i < 2; i++ {\n\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"JSON.MGET\", \"a1\", \"a2\", \"a3\", \"$\"})), 10*time.Second).ToMessage()\n\t\tarr, _ := v.ToArray()\n\t\tif len(arr) != 3 {\n\t\t\tt.Errorf(\"unexpected cached mget length, expected 3, got %v\", len(arr))\n\t\t}\n\t\tfor i, v := range arr {\n\t\t\tif v.integer != int64(i+1) {\n\t\t\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", i+1, v.integer)\n\t\t\t}\n\t\t}\n\t\tif ttl := p.cache.(*lru).GetTTL(\"a1\", \"JSON.GET$\"); !roughly(ttl, time.Second) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif ttl := p.cache.(*lru).GetTTL(\"a2\", \"JSON.GET$\"); !roughly(ttl, time.Second*2) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif ttl := p.cache.(*lru).GetTTL(\"a3\", \"JSON.GET$\"); !roughly(ttl, time.Second*3) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif v.IsCacheHit() {\n\t\t\tatomic.AddUint64(&hits, 1)\n\t\t} else {\n\t\t\tatomic.AddUint64(&miss, 1)\n\t\t}\n\t}\n\n\tif v := atomic.LoadUint64(&miss); v != 1 {\n\t\tt.Fatalf(\"unexpected cache miss count %v\", v)\n\t}\n\n\tif v := atomic.LoadUint64(&hits); v != uint64(1) {\n\t\tt.Fatalf(\"unexpected cache hits count %v\", v)\n\t}\n\n\t// partial cache invalidation\n\tinvalidateCSC(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a1\"}, {typ: '+', string: \"a3\"}}})\n\tgo func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\tExpect(\"JSON.MGET\", \"a1\", \"a3\", \"$\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: 10000},\n\t\t\t\t{typ: ':', integer: 30000},\n\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 10},\n\t\t\t\t\t{typ: ':', integer: 30},\n\t\t\t\t}},\n\t\t\t}})\n\t}()\n\n\tfor {\n\t\tif p.cache.(*lru).GetTTL(\"a1\", \"JSON.GET$\") == -2 && p.cache.(*lru).GetTTL(\"a3\", \"JSON.GET$\") == -2 {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n\n\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"JSON.MGET\", \"a1\", \"a2\", \"a3\", \"$\"})), 10*time.Second).ToMessage()\n\tarr, _ := v.ToArray()\n\tif len(arr) != 3 {\n\t\tt.Errorf(\"unexpected cached mget length, expected 3, got %v\", len(arr))\n\t}\n\tif arr[1].integer != 2 {\n\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 2, arr[1].integer)\n\t}\n\tif arr[0].integer != 10 {\n\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 10, arr[0].integer)\n\t}\n\tif arr[2].integer != 30 {\n\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 30, arr[2].integer)\n\t}\n\tif ttl := p.cache.(*lru).GetTTL(\"a1\", \"JSON.GET$\"); !roughly(ttl, time.Second*10) {\n\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t}\n\tif ttl := p.cache.(*lru).GetTTL(\"a2\", \"JSON.GET$\"); !roughly(ttl, time.Second*2) {\n\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t}\n\tif ttl := p.cache.(*lru).GetTTL(\"a3\", \"JSON.GET$\"); !roughly(ttl, time.Second*30) {\n\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t}\n}\n\nfunc TestClientSideCachingExecAbortMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\tgo func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\tExpect(\"MGET\", \"a1\", \"a2\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '_'})\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"b1\").\n\t\t\tExpect(\"PTTL\", \"b2\").\n\t\t\tExpect(\"MGET\", \"b1\", \"b2\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyError(\"MOVED 0 127.0.0.1\").\n\t\t\tReply(RedisMessage{typ: '_'})\n\t}()\n\n\tfor i, pair := range [][2]string{{\"a1\", \"a2\"}, {\"b1\", \"b2\"}} {\n\t\tv, err := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", pair[0], pair[1]})), 10*time.Second).ToMessage()\n\t\tif i == 0 {\n\t\t\tif err != ErrDoCacheAborted {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tif re, ok := err.(*RedisError); !ok {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t} else if _, moved := re.IsMoved(); !moved {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t}\n\t\t}\n\t\tif v.IsCacheHit() {\n\t\t\tt.Errorf(\"unexpected cache hit\")\n\t\t}\n\t\tif v, entry := p.cache.Flight(pair[0], \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t\t}\n\t\tif v, entry := p.cache.Flight(pair[1], \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t\t}\n\t}\n}\n\nfunc TestClientSideCachingWithNonRedisErrorMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\tcloseConn()\n\n\tv, err := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a1\", \"a2\"})), 10*time.Second).ToMessage()\n\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t}\n\tif v.IsCacheHit() {\n\t\tt.Errorf(\"unexpected cache hit\")\n\t}\n\tif v, entry := p.cache.Flight(\"a1\", \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t}\n\tif v, entry := p.cache.Flight(\"a2\", \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t}\n}\n\nfunc TestClientSideCachingWithSideChannelMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\tcloseConn()\n\n\tp.cache.Flight(\"a1\", \"GET\", 10*time.Second, time.Now())\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tm := RedisMessage{typ: '+', string: \"OK\"}\n\t\tm.setExpireAt(time.Now().Add(10 * time.Millisecond).UnixMilli())\n\t\tp.cache.Update(\"a1\", \"GET\", m)\n\t}()\n\n\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a1\"})), 10*time.Second).AsStrSlice()\n\tif v[0] != \"OK\" {\n\t\tt.Errorf(\"unexpected value, got %v\", v)\n\t}\n}\n\nfunc TestClientSideCachingWithSideChannelErrorMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\tcloseConn()\n\n\tp.cache.Flight(\"a1\", \"GET\", 10*time.Second, time.Now())\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tp.cache.Cancel(\"a1\", \"GET\", io.EOF)\n\t}()\n\n\t_, err := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a1\"})), 10*time.Second).ToMessage()\n\tif err != io.EOF {\n\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t}\n}\n\nfunc TestClientSideCachingDoMultiCacheMGet(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\tdefer func() {\n\t\tif !strings.Contains(recover().(string), panicmgetcsc) {\n\t\t\tt.Fatal(\"should panic\")\n\t\t}\n\t}()\n\tp.DoMultiCache(context.Background(), []CacheableTTL{\n\t\tCT(Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a1\"})), time.Second*10),\n\t}...)\n}\n\nfunc TestClientSideCachingDoMultiCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttestfn := func(t *testing.T, option ClientOption) {\n\t\tp, mock, cancel, _ := setup(t, option)\n\t\tdefer cancel()\n\n\t\tinvalidateCSC := func(keys RedisMessage) {\n\t\t\tmock.Expect().Reply(RedisMessage{\n\t\t\t\ttyp: '>',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t\tkeys,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\n\t\tgo func() {\n\t\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\t\tExpect(\"GET\", \"a1\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\t\tExpect(\"GET\", \"a2\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\t\tExpect(\"GET\", \"a3\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 1000},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}}).\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 2000},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t}}).\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 3000},\n\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t}})\n\t\t}()\n\t\t// single flight\n\t\tmiss := uint64(0)\n\t\thits := uint64(0)\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a2\"})), time.Second*10),\n\t\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a3\"})), time.Second*10),\n\t\t\t}...).s\n\t\t\tif len(arr) != 3 {\n\t\t\t\tt.Errorf(\"unexpected cached mget length, expected 3, got %v\", len(arr))\n\t\t\t}\n\t\t\tfor i, v := range arr {\n\t\t\t\tif v.val.integer != int64(i+1) {\n\t\t\t\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", i+1, v.val.integer)\n\t\t\t\t}\n\t\t\t\tif v.val.IsCacheHit() {\n\t\t\t\t\tatomic.AddUint64(&hits, 1)\n\t\t\t\t} else {\n\t\t\t\t\tatomic.AddUint64(&miss, 1)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ttl := time.Duration(arr[0].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second) {\n\t\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t\t}\n\t\t\tif ttl := time.Duration(arr[1].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second*2) {\n\t\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t\t}\n\t\t\tif ttl := time.Duration(arr[2].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second*3) {\n\t\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t\t}\n\t\t}\n\n\t\tif v := atomic.LoadUint64(&miss); v != 3 {\n\t\t\tt.Fatalf(\"unexpected cache miss count %v\", v)\n\t\t}\n\n\t\tif v := atomic.LoadUint64(&hits); v != 3 {\n\t\t\tt.Fatalf(\"unexpected cache hits count %v\", v)\n\t\t}\n\n\t\t// partial cache invalidation\n\t\tinvalidateCSC(RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"a1\"}, {typ: '+', string: \"a3\"}}})\n\t\tgo func() {\n\t\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\t\tExpect(\"GET\", \"a1\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\t\tExpect(\"GET\", \"a3\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 10000},\n\t\t\t\t\t{typ: ':', integer: 10},\n\t\t\t\t}}).\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 30000},\n\t\t\t\t\t{typ: ':', integer: 30},\n\t\t\t\t}})\n\t\t}()\n\n\t\tif cache, ok := p.cache.(*lru); ok {\n\t\t\tfor {\n\t\t\t\tif cache.GetTTL(\"a1\", \"GET\") == -2 && p.cache.(*lru).GetTTL(\"a3\", \"GET\") == -2 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t}\n\t\t} else {\n\t\t\ttime.Sleep(time.Second)\n\t\t}\n\n\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a2\"})), time.Second*10),\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a3\"})), time.Second*10),\n\t\t}...).s\n\t\tif len(arr) != 3 {\n\t\t\tt.Errorf(\"unexpected cached mget length, expected 3, got %v\", len(arr))\n\t\t}\n\t\tif arr[1].val.integer != 2 {\n\t\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 2, arr[1].val.integer)\n\t\t}\n\t\tif arr[0].val.integer != 10 {\n\t\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 10, arr[0].val.integer)\n\t\t}\n\t\tif arr[2].val.integer != 30 {\n\t\t\tt.Errorf(\"unexpected cached mget response, expected %v, got %v\", 30, arr[2].val.integer)\n\t\t}\n\t\tif ttl := time.Duration(arr[0].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second*10) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif ttl := time.Duration(arr[1].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second*2) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif ttl := time.Duration(arr[2].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second*30) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t}\n\tt.Run(\"LRU\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{})\n\t})\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{\n\t\t\tNewCacheStoreFn: func(option CacheStoreOption) CacheStore {\n\t\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t\t},\n\t\t})\n\t})\n}\n\nfunc TestClientSideCachingExecAbortDoMultiCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttestfn := func(t *testing.T, option ClientOption) {\n\t\tp, mock, cancel, _ := setup(t, option)\n\t\tdefer cancel()\n\n\t\tgo func() {\n\t\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\t\tExpect(\"GET\", \"a1\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\t\tExpect(\"GET\", \"a2\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\tExpect(\"MULTI\").\n\t\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\t\tExpect(\"GET\", \"a3\").\n\t\t\t\tExpect(\"EXEC\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: ':', integer: 1000},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}}).\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReply(RedisMessage{typ: '_'}).\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyString(\"OK\").\n\t\t\t\tReplyError(\"MOVED 0 127.0.0.1\").\n\t\t\t\tReply(RedisMessage{typ: '_'})\n\t\t}()\n\n\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a2\"})), time.Second*10),\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a3\"})), time.Second*10),\n\t\t}...).s\n\t\tfor i, resp := range arr {\n\t\t\tv, err := resp.ToMessage()\n\t\t\tif i == 0 {\n\t\t\t\tif v.integer != 1 {\n\t\t\t\t\tt.Errorf(\"unexpected cached response, expected %v, got %v\", 1, v.integer)\n\t\t\t\t}\n\t\t\t} else if i == 1 {\n\t\t\t\tif err != ErrDoCacheAborted {\n\t\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t\t}\n\t\t\t\tif v.IsCacheHit() {\n\t\t\t\t\tt.Errorf(\"unexpected cache hit\")\n\t\t\t\t}\n\t\t\t} else if i == 2 {\n\t\t\t\tif re, ok := err.(*RedisError); !ok {\n\t\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t\t} else if _, moved := re.IsMoved(); !moved {\n\t\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t\t}\n\t\t\t\tif v.IsCacheHit() {\n\t\t\t\t\tt.Errorf(\"unexpected cache hit\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif v, entry := p.cache.Flight(\"a1\", \"GET\", time.Second, time.Now()); v.integer != 1 {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v.integer, entry)\n\t\t}\n\t\tif ttl := time.Duration(arr[0].CachePTTL()) * time.Millisecond; !roughly(ttl, time.Second) {\n\t\t\tt.Errorf(\"unexpected ttl %v\", ttl)\n\t\t}\n\t\tif v, entry := p.cache.Flight(\"a2\", \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t\t}\n\t}\n\tt.Run(\"LRU\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{})\n\t})\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{\n\t\t\tNewCacheStoreFn: func(option CacheStoreOption) CacheStore {\n\t\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t\t},\n\t\t})\n\t})\n}\n\nfunc TestClientSideCachingWithNonRedisErrorDoMultiCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttestfn := func(t *testing.T, option ClientOption) {\n\t\tp, _, _, closeConn := setup(t, option)\n\t\tcloseConn()\n\n\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a2\"})), time.Second*10),\n\t\t}...).s\n\t\tfor _, resp := range arr {\n\t\t\tv, err := resp.ToMessage()\n\t\t\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected err, got %v\", err)\n\t\t\t}\n\t\t\tif v.IsCacheHit() {\n\t\t\t\tt.Errorf(\"unexpected cache hit\")\n\t\t\t}\n\t\t}\n\t\tif v, entry := p.cache.Flight(\"a1\", \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t\t}\n\t\tif v, entry := p.cache.Flight(\"a2\", \"GET\", time.Second, time.Now()); v.typ != 0 || entry != nil {\n\t\t\tt.Errorf(\"unexpected cache value and entry %v %v\", v, entry)\n\t\t}\n\t}\n\tt.Run(\"LRU\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{})\n\t})\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{\n\t\t\tNewCacheStoreFn: func(option CacheStoreOption) CacheStore {\n\t\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t\t},\n\t\t})\n\t})\n}\n\nfunc TestClientSideCachingWithSideChannelDoMultiCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttestfn := func(t *testing.T, option ClientOption) {\n\t\tp, _, _, closeConn := setup(t, option)\n\t\tcloseConn()\n\n\t\tp.cache.Flight(\"a1\", \"GET\", 10*time.Second, time.Now())\n\t\tgo func() {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\tm := RedisMessage{typ: '+', string: \"OK\"}\n\t\t\tm.setExpireAt(time.Now().Add(10 * time.Millisecond).UnixMilli())\n\t\t\tp.cache.Update(\"a1\", \"GET\", m)\n\t\t}()\n\n\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t}...).s\n\t\tif arr[0].val.string != \"OK\" {\n\t\t\tt.Errorf(\"unexpected value, got %v\", arr[0].val.string)\n\t\t}\n\t}\n\tt.Run(\"LRU\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{})\n\t})\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{\n\t\t\tNewCacheStoreFn: func(option CacheStoreOption) CacheStore {\n\t\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t\t},\n\t\t})\n\t})\n}\n\nfunc TestClientSideCachingWithSideChannelErrorDoMultiCache(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttestfn := func(t *testing.T, option ClientOption) {\n\t\tp, _, _, closeConn := setup(t, option)\n\t\tcloseConn()\n\t\tp.cache.Flight(\"a1\", \"GET\", 10*time.Second, time.Now())\n\t\tgo func() {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\tp.cache.Cancel(\"a1\", \"GET\", io.EOF)\n\t\t}()\n\n\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t}...).s\n\t\tif arr[0].err != io.EOF {\n\t\t\tt.Errorf(\"unexpected err, got %v\", arr[0].err)\n\t\t}\n\t}\n\tt.Run(\"LRU\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{})\n\t})\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{\n\t\t\tNewCacheStoreFn: func(option CacheStoreOption) CacheStore {\n\t\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t\t},\n\t\t})\n\t})\n}\n\nfunc TestClientSideCachingMissCacheTTL(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttestfn := func(t *testing.T, option ClientOption) {\n\t\tt.Run(\"DoCache GET\", func(t *testing.T) {\n\t\t\tp, mock, cancel, _ := setup(t, option)\n\t\t\tdefer cancel()\n\t\t\texpectCSC := func(pttl int64, key string) {\n\t\t\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\t\tExpect(\"MULTI\").\n\t\t\t\t\tExpect(\"PTTL\", key).\n\t\t\t\t\tExpect(\"GET\", key).\n\t\t\t\t\tExpect(\"EXEC\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: ':', integer: pttl},\n\t\t\t\t\t\t{typ: '+', string: key},\n\t\t\t\t\t}})\n\t\t\t}\n\t\t\tgo func() {\n\t\t\t\texpectCSC(-1, \"a\")\n\t\t\t\texpectCSC(1000, \"b\")\n\t\t\t\texpectCSC(20000, \"c\")\n\t\t\t}()\n\t\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).ToMessage()\n\t\t\tif ttl := v.CacheTTL(); ttl != 10 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 10, ttl)\n\t\t\t}\n\t\t\tv, _ = p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"b\"})), 10*time.Second).ToMessage()\n\t\t\tif ttl := v.CacheTTL(); ttl != 1 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 1, ttl)\n\t\t\t}\n\t\t\tv, _ = p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"c\"})), 10*time.Second).ToMessage()\n\t\t\tif ttl := v.CacheTTL(); ttl != 10 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 10, ttl)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"DoCache MGET\", func(t *testing.T) {\n\t\t\tp, mock, cancel, _ := setup(t, option)\n\t\t\tdefer cancel()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\t\tExpect(\"MULTI\").\n\t\t\t\t\tExpect(\"PTTL\", \"a\").\n\t\t\t\t\tExpect(\"PTTL\", \"b\").\n\t\t\t\t\tExpect(\"PTTL\", \"c\").\n\t\t\t\t\tExpect(\"MGET\", \"a\", \"b\", \"c\").\n\t\t\t\t\tExpect(\"EXEC\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: ':', integer: -1},\n\t\t\t\t\t\t{typ: ':', integer: 1000},\n\t\t\t\t\t\t{typ: ':', integer: 20000},\n\t\t\t\t\t\t{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"a\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"b\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"c\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}})\n\t\t\t}()\n\t\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewMGetCompleted([]string{\"MGET\", \"a\", \"b\", \"c\"})), 10*time.Second).ToArray()\n\t\t\tif ttl := v[0].CacheTTL(); ttl != 10 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 10, ttl)\n\t\t\t}\n\t\t\tif ttl := v[1].CacheTTL(); ttl != 1 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 1, ttl)\n\t\t\t}\n\t\t\tif ttl := v[2].CacheTTL(); ttl != 10 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 10, ttl)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"DoMultiCache\", func(t *testing.T) {\n\t\t\tp, mock, cancel, _ := setup(t, option)\n\t\t\tdefer cancel()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\t\tExpect(\"MULTI\").\n\t\t\t\t\tExpect(\"PTTL\", \"a1\").\n\t\t\t\t\tExpect(\"GET\", \"a1\").\n\t\t\t\t\tExpect(\"EXEC\").\n\t\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\t\tExpect(\"MULTI\").\n\t\t\t\t\tExpect(\"PTTL\", \"a2\").\n\t\t\t\t\tExpect(\"GET\", \"a2\").\n\t\t\t\t\tExpect(\"EXEC\").\n\t\t\t\t\tExpect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\t\t\tExpect(\"MULTI\").\n\t\t\t\t\tExpect(\"PTTL\", \"a3\").\n\t\t\t\t\tExpect(\"GET\", \"a3\").\n\t\t\t\t\tExpect(\"EXEC\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: ':', integer: -1},\n\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t}}).\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: ':', integer: 1000},\n\t\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t\t}}).\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReplyString(\"OK\").\n\t\t\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: ':', integer: 20000},\n\t\t\t\t\t\t{typ: ':', integer: 3},\n\t\t\t\t\t}})\n\t\t\t}()\n\t\t\tarr := p.DoMultiCache(context.Background(), []CacheableTTL{\n\t\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a1\"})), time.Second*10),\n\t\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a2\"})), time.Second*10),\n\t\t\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"a3\"})), time.Second*10),\n\t\t\t}...).s\n\t\t\tif ttl := arr[0].CacheTTL(); ttl != 10 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 10, ttl)\n\t\t\t}\n\t\t\tif ttl := arr[1].CacheTTL(); ttl != 1 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 1, ttl)\n\t\t\t}\n\t\t\tif ttl := arr[2].CacheTTL(); ttl != 10 {\n\t\t\t\tt.Errorf(\"unexpected cached ttl, expected %v, got %v\", 10, ttl)\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"LRU\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{})\n\t})\n\tt.Run(\"Simple\", func(t *testing.T) {\n\t\ttestfn(t, ClientOption{\n\t\t\tNewCacheStoreFn: func(option CacheStoreOption) CacheStore {\n\t\t\t\treturn NewSimpleCacheAdapter(&simple{store: map[string]RedisMessage{}})\n\t\t\t},\n\t\t})\n\t})\n}\n\n// https://github.com/redis/redis/issues/8935\nfunc TestClientSideCachingRedis6InvalidationBug1(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\texpectCSC := func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a\").\n\t\t\tExpect(\"GET\", \"a\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t\t\t{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{typ: ':', integer: -2},\n\t\t\t}}).Reply(RedisMessage{typ: '_'})\n\t}\n\n\tgo func() {\n\t\texpectCSC()\n\t}()\n\t// single flight\n\tmiss := uint64(0)\n\thits := uint64(0)\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).ToMessage()\n\t\t\tif v.typ != '_' {\n\t\t\t\tt.Errorf(\"unexpected cached result, expected null, got %v\", v.string)\n\t\t\t}\n\t\t\tif v.IsCacheHit() {\n\t\t\t\tatomic.AddUint64(&hits, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddUint64(&miss, 1)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\tif v := atomic.LoadUint64(&miss); v != 1 {\n\t\tt.Fatalf(\"unexpected cache miss count %v\", v)\n\t}\n\n\tif v := atomic.LoadUint64(&hits); v != uint64(times-1) {\n\t\tt.Fatalf(\"unexpected cache hits count %v\", v)\n\t}\n}\n\n// https://github.com/redis/redis/issues/8935\nfunc TestClientSideCachingRedis6InvalidationBug2(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{})\n\tdefer cancel()\n\n\texpectCSC := func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a\").\n\t\t\tExpect(\"GET\", \"a\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: -2},\n\t\t\t\t{\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t\t\t{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}}).Reply(RedisMessage{typ: '_'})\n\t}\n\n\tgo func() {\n\t\texpectCSC()\n\t}()\n\t// single flight\n\tmiss := uint64(0)\n\thits := uint64(0)\n\ttimes := 2000\n\twg := sync.WaitGroup{}\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).ToMessage()\n\t\t\tif v.typ != '_' {\n\t\t\t\tt.Errorf(\"unexpected cached result, expected null, got %v\", v.string)\n\t\t\t}\n\t\t\tif v.IsCacheHit() {\n\t\t\t\tatomic.AddUint64(&hits, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddUint64(&miss, 1)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\tif v := atomic.LoadUint64(&miss); v != 1 {\n\t\tt.Fatalf(\"unexpected cache miss count %v\", v)\n\t}\n\n\tif v := atomic.LoadUint64(&hits); v != uint64(times-1) {\n\t\tt.Fatalf(\"unexpected cache hits count %v\", v)\n\t}\n}\n\n// https://github.com/redis/redis/issues/8935\nfunc TestClientSideCachingRedis6InvalidationBugErr(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\n\texpectCSC := func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a\").\n\t\t\tExpect(\"GET\", \"a\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReply(RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t{typ: ':', integer: -2},\n\t\t\t\t{\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t\t\t{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}})\n\t}\n\n\tgo func() {\n\t\texpectCSC()\n\t\tcloseConn()\n\t}()\n\n\terr := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).Error()\n\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Errorf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestDisableClientSideCaching(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{DisableCache: true})\n\tdefer cancel()\n\tp.background()\n\n\tgo func() {\n\t\tmock.Expect().Reply(RedisMessage{\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}},\n\t\t\t},\n\t\t})\n\t\tmock.Expect(\"GET\", \"a\").ReplyString(\"1\").\n\t\t\tExpect(\"GET\", \"b\").\n\t\t\tExpect(\"GET\", \"c\").\n\t\t\tReplyString(\"2\").\n\t\t\tReplyString(\"3\")\n\t}()\n\n\tv, _ := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).ToMessage()\n\tif v.string != \"1\" {\n\t\tt.Errorf(\"unexpected cached result, expected %v, got %v\", \"1\", v.string)\n\t}\n\n\tvs := p.DoMultiCache(context.Background(),\n\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"b\"})), 10*time.Second),\n\t\tCT(Cacheable(cmds.NewCompleted([]string{\"GET\", \"c\"})), 10*time.Second)).s\n\tif vs[0].val.string != \"2\" {\n\t\tt.Errorf(\"unexpected cached result, expected %v, got %v\", \"1\", v.string)\n\t}\n\tif vs[1].val.string != \"3\" {\n\t\tt.Errorf(\"unexpected cached result, expected %v, got %v\", \"1\", v.string)\n\t}\n}\n\nfunc TestOnInvalidations(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tch := make(chan []RedisMessage)\n\t_, mock, cancel, _ := setup(t, ClientOption{\n\t\tOnInvalidations: func(messages []RedisMessage) {\n\t\t\tch <- messages\n\t\t},\n\t})\n\n\tgo func() {\n\t\tmock.Expect().Reply(RedisMessage{\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t{typ: '*', values: []RedisMessage{{typ: '+', string: \"a\"}}},\n\t\t\t},\n\t\t})\n\t}()\n\n\tif messages := <-ch; messages[0].string != \"a\" {\n\t\tt.Fatalf(\"unexpected invlidation %v\", messages)\n\t}\n\n\tgo func() {\n\t\tmock.Expect().Reply(RedisMessage{\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"invalidate\"},\n\t\t\t\t{typ: '_'},\n\t\t\t},\n\t\t})\n\t}()\n\n\tif messages := <-ch; messages != nil {\n\t\tt.Fatalf(\"unexpected invlidation %v\", messages)\n\t}\n\n\tgo cancel()\n\n\tif messages := <-ch; messages != nil {\n\t\tt.Fatalf(\"unexpected invlidation %v\", messages)\n\t}\n}\n\nfunc TestMultiHalfErr(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\n\texpectCSC := func() {\n\t\tmock.Expect(\"CLIENT\", \"CACHING\", \"YES\").\n\t\t\tExpect(\"MULTI\").\n\t\t\tExpect(\"PTTL\", \"a\").\n\t\t\tExpect(\"GET\", \"a\").\n\t\t\tExpect(\"EXEC\").\n\t\t\tReplyString(\"OK\").\n\t\t\tReplyString(\"OK\")\n\t}\n\n\tgo func() {\n\t\texpectCSC()\n\t\tcloseConn()\n\t}()\n\n\terr := p.DoCache(context.Background(), Cacheable(cmds.NewCompleted([]string{\"GET\", \"a\"})), 10*time.Second).Error()\n\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Errorf(\"unexpected err %v\", err)\n\t}\n}\n\n//gocyclo:ignore\nfunc TestPubSub(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbuilder := cmds.NewBuilder(cmds.NoSlot)\n\tt.Run(\"NoReply Commands In Do\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\t\tdefer cancel()\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"a\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"b\").Build(),\n\t\t\tbuilder.Unsubscribe().Channel(\"c\").Build(),\n\t\t\tbuilder.Punsubscribe().Pattern(\"d\").Build(),\n\t\t\tbuilder.Ssubscribe().Channel(\"c\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"d\").Build(),\n\t\t}\n\n\t\tgo func() {\n\t\t\tfor _, c := range commands {\n\t\t\t\tif c.IsUnsub() {\n\t\t\t\t\tmock.Expect(c.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(RedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[0])},\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[1])},\n\t\t\t\t\t}}).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(c.Commands()...).Reply(RedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[0])},\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[1])},\n\t\t\t\t\t}})\n\t\t\t\t}\n\t\t\t\tmock.Expect(\"GET\", \"k\").ReplyString(\"v\")\n\t\t\t}\n\t\t}()\n\n\t\tfor _, c := range commands {\n\t\t\tp.Do(context.Background(), c)\n\t\t\tif v, _ := p.Do(context.Background(), builder.Get().Key(\"k\").Build()).ToMessage(); v.string != \"v\" {\n\t\t\t\tt.Fatalf(\"no-reply commands should not affect nornal commands\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"NoReply Commands In DoMulti\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\t\tdefer cancel()\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"a\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"b\").Build(),\n\t\t\tbuilder.Unsubscribe().Channel(\"c\").Build(),\n\t\t\tbuilder.Punsubscribe().Pattern(\"d\").Build(),\n\t\t}\n\n\t\tgo func() {\n\t\t\tfor _, c := range commands {\n\t\t\t\tif c.IsUnsub() {\n\t\t\t\t\tmock.Expect(c.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(RedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[0])},\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[1])},\n\t\t\t\t\t}}).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(c.Commands()...).Reply(RedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[0])},\n\t\t\t\t\t\t{typ: '+', string: strings.ToLower(c.Commands()[1])},\n\t\t\t\t\t}})\n\t\t\t\t}\n\t\t\t}\n\t\t\tmock.Expect(\"GET\", \"k\").ReplyString(\"v\")\n\t\t}()\n\n\t\tp.DoMulti(context.Background(), commands...)\n\t\tif v, _ := p.Do(context.Background(), builder.Get().Key(\"k\").Build()).ToMessage(); v.string != \"v\" {\n\t\t\tt.Fatalf(\"no-reply commands should not affect nornal commands\")\n\t\t}\n\t})\n\n\tt.Run(\"PubSub Subscribe RedisMessage\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tactivate := builder.Subscribe().Channel(\"1\").Build()\n\t\tdeactivate := builder.Unsubscribe().Channel(\"1\").Build()\n\t\tgo func() {\n\t\t\tmock.Expect(activate.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"message\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t}},\n\t\t\t)\n\t\t\tmock.Expect(deactivate.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t}},\n\t\t\t).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t\t}()\n\n\t\tif err := p.Receive(ctx, activate, func(msg PubSubMessage) {\n\t\t\tif msg.Channel == \"1\" && msg.Message == \"2\" {\n\t\t\t\tif err := p.Do(ctx, deactivate).Error(); err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub SSubscribe RedisMessage\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tactivate := builder.Ssubscribe().Channel(\"1\").Build()\n\t\tdeactivate := builder.Sunsubscribe().Channel(\"1\").Build()\n\t\tgo func() {\n\t\t\tmock.Expect(activate.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"ssubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"smessage\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t}},\n\t\t\t)\n\t\t\tmock.Expect(deactivate.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t}},\n\t\t\t).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t\t}()\n\n\t\tif err := p.Receive(ctx, activate, func(msg PubSubMessage) {\n\t\t\tif msg.Channel == \"1\" && msg.Message == \"2\" {\n\t\t\t\tif err := p.Do(ctx, deactivate).Error(); err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub PSubscribe RedisMessage\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tactivate := builder.Psubscribe().Pattern(\"1\").Build()\n\t\tdeactivate := builder.Punsubscribe().Pattern(\"1\").Build()\n\t\tgo func() {\n\t\t\tmock.Expect(activate.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"psubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"pmessage\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t}},\n\t\t\t)\n\t\t\tmock.Expect(deactivate.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"punsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t}},\n\t\t\t).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t\t}()\n\n\t\tif err := p.Receive(ctx, activate, func(msg PubSubMessage) {\n\t\t\tif msg.Pattern == \"1\" && msg.Channel == \"2\" && msg.Message == \"3\" {\n\t\t\t\tif err := p.Do(ctx, deactivate).Error(); err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub Wrong Command RedisMessage\", func(t *testing.T) {\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tdefer cancel()\n\n\t\tdefer func() {\n\t\t\tif !strings.Contains(recover().(string), wrongreceive) {\n\t\t\t\tt.Fatal(\"Receive not panic as expected\")\n\t\t\t}\n\t\t}()\n\n\t\t_ = p.Receive(context.Background(), builder.Get().Key(\"wrong\").Build(), func(msg PubSubMessage) {})\n\t})\n\n\tt.Run(\"PubSub Subscribe fail\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, _, _, closePipe := setup(t, ClientOption{})\n\t\tclosePipe()\n\n\t\tif err := p.Receive(ctx, builder.Psubscribe().Pattern(\"1\").Build(), func(msg PubSubMessage) {}); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"PubSub Subscribe context cancel\", func(t *testing.T) {\n\t\tctx, ctxCancel := context.WithCancel(context.Background())\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tactivate := builder.Subscribe().Channel(\"1\").Build()\n\t\tgo func() {\n\t\t\tmock.Expect(activate.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"message\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t}},\n\t\t\t)\n\t\t}()\n\n\t\tif err := p.Receive(ctx, activate, func(msg PubSubMessage) {\n\t\t\tif msg.Channel == \"1\" && msg.Message == \"2\" {\n\t\t\t\tctxCancel()\n\t\t\t}\n\t\t}); !errors.Is(err, context.Canceled) {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub Subscribe Redis Error\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"1\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"1\").Build(),\n\t\t\tbuilder.Ssubscribe().Channel(\"1\").Build(),\n\t\t\tbuilder.Unsubscribe().Channel(\"1\").Build(),\n\t\t\tbuilder.Punsubscribe().Pattern(\"1\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"1\").Build(),\n\t\t}\n\t\tgo func() {\n\t\t\tfor _, cmd := range commands {\n\t\t\t\tif cmd.IsUnsub() {\n\t\t\t\t\tmock.Expect(cmd.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(RedisMessage{typ: '-', string: cmd.Commands()[0]}).Reply(RedisMessage{typ: '+', string: \"PONG\"})\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(cmd.Commands()...).Reply(RedisMessage{typ: '-', string: cmd.Commands()[0]})\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tfor _, cmd := range commands {\n\t\t\tif err := p.Do(ctx, cmd).Error(); err == nil || !strings.Contains(err.Error(), cmd.Commands()[0]) {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub Subscribe Response\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"a\", \"b\", \"c\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"a\", \"b\", \"c\").Build(),\n\t\t\tbuilder.Ssubscribe().Channel(\"a\", \"b\", \"c\").Build(),\n\t\t\tbuilder.Unsubscribe().Channel(\"a\", \"b\", \"c\").Build(),\n\t\t\tbuilder.Punsubscribe().Pattern(\"a\", \"b\", \"c\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"a\", \"b\", \"c\").Build(),\n\t\t}\n\n\t\tfor i, cmd1 := range commands {\n\t\t\tcmd2 := builder.Get().Key(strconv.Itoa(i)).Build()\n\t\t\tgo func() {\n\t\t\t\tif cmd1.IsUnsub() {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(\n\t\t\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"a\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{ // skip\n\t\t\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"b\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{ // skip\n\t\t\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"c\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t\t}},\n\t\t\t\t\t).Reply(RedisMessage{typ: '+', string: \"PONG\"}).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Reply(\n\t\t\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"a\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{ // skip\n\t\t\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"b\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{ // skip\n\t\t\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"c\"},\n\t\t\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t\t\t}},\n\t\t\t\t\t).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t}\n\n\t\t\t}()\n\n\t\t\tif err := p.Do(ctx, cmd1).Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\tif v, err := p.Do(ctx, cmd2).ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected val %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub Wildcard Unsubscribe Response\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Unsubscribe().Build(),\n\t\t\tbuilder.Punsubscribe().Build(),\n\t\t\tbuilder.Sunsubscribe().Build(),\n\t\t}\n\n\t\treplies := [][]RedisMessage{{\n\t\t\t{\n\t\t\t\ttyp: '>',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t},\n\t\t\t},\n\t\t}, {\n\t\t\t{\n\t\t\t\ttyp: '>',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"punsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t},\n\t\t\t},\n\t\t}, {\n\t\t\t{\n\t\t\t\ttyp: '>',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\ttyp: '>',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t},\n\t\t\t},\n\t\t}}\n\n\t\tfor i, cmd1 := range commands {\n\t\t\tcmd2 := builder.Get().Key(strconv.Itoa(i)).Build()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect(cmd1.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(replies[i]...).Reply(RedisMessage{typ: '+', string: \"PONG\"}).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t}()\n\n\t\t\tif err := p.Do(ctx, cmd1).Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\tif v, err := p.Do(ctx, cmd2).ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected val %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub Proactive UNSUBSCRIBE/PUNSUBSCRIBE/SUNSUBSCRIBE\", func(t *testing.T) {\n\t\tfor _, command := range []string{\n\t\t\t\"unsubscribe\",\n\t\t\t\"punsubscribe\",\n\t\t\t\"sunsubscribe\",\n\t\t} {\n\t\t\tcommand := command\n\t\t\tt.Run(command, func(t *testing.T) {\n\t\t\t\tctx := context.Background()\n\t\t\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\t\t\tcommands := []Completed{\n\t\t\t\t\tbuilder.Sunsubscribe().Build(),\n\t\t\t\t\tbuilder.Ssubscribe().Channel(\"3\").Build(),\n\t\t\t\t}\n\n\t\t\t\treplies := [][]RedisMessage{\n\t\t\t\t\t{\n\t\t\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\t\t\ttyp: '>',\n\t\t\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: command},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\t\t\ttyp: '>',\n\t\t\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: command},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ // user unsubscribe\n\t\t\t\t\t\t\ttyp: '>',\n\t\t\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: command},\n\t\t\t\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ // proactive unsubscribe after user unsubscribe\n\t\t\t\t\t\t\ttyp: '>',\n\t\t\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: command},\n\t\t\t\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t{ // user ssubscribe\n\t\t\t\t\t\t\ttyp: '>',\n\t\t\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: \"ssubscribe\"},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ // proactive unsubscribe after user ssubscribe\n\t\t\t\t\t\t\ttyp: '>',\n\t\t\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t\t\t{typ: '+', string: command},\n\t\t\t\t\t\t\t\t{typ: '+', string: \"3\"},\n\t\t\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tp.background()\n\n\t\t\t\t// proactive unsubscribe before other commands\n\t\t\t\tmock.Expect().Reply(RedisMessage{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: command},\n\t\t\t\t\t\t{typ: '+', string: \"0\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t})\n\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\n\t\t\t\tfor i, cmd1 := range commands {\n\t\t\t\t\tcmd2 := builder.Get().Key(strconv.Itoa(i)).Build()\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tif cmd1.IsUnsub() {\n\t\t\t\t\t\t\tmock.Expect(cmd1.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(replies[i]...).Reply(RedisMessage{typ: '+', string: \"PONG\"}).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmock.Expect(cmd1.Commands()...).Reply(replies[i]...).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t\tif err := p.Do(ctx, cmd1).Error(); err != nil {\n\t\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tif v, err := p.Do(ctx, cmd2).ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected val %v %v\", v, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcancel()\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"PubSub Proactive SUNSUBSCRIBE with Slot Migration\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Sunsubscribe().Channel(\"1\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"2\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"3\").Build(),\n\t\t\tbuilder.Get().Key(\"mk\").Build(),\n\t\t}\n\n\t\treplies := [][]RedisMessage{\n\t\t\t{\n\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"a\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"b\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ // user unsubscribe, but error\n\t\t\t\t\ttyp:    '-',\n\t\t\t\t\tstring: \"MOVED 1111\",\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t{ // user unsubscribe, but error\n\t\t\t\t\ttyp:    '-',\n\t\t\t\t\tstring: \"MOVED 222\",\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t{ // user unsubscribe success\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"c\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t{ // proactive unsubscribe after user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{typ: '+', string: \"mk\"},\n\t\t\t},\n\t\t}\n\n\t\tp.background()\n\n\t\t// proactive unsubscribe before other commands\n\t\tmock.Expect().Reply(RedisMessage{ // proactive unsubscribe before user unsubscribe\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t{typ: '+', string: \"0\"},\n\t\t\t\t{typ: ':', integer: 0},\n\t\t\t},\n\t\t})\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\n\t\tfor i, cmd1 := range commands {\n\t\t\tcmd2 := builder.Get().Key(strconv.Itoa(i)).Build()\n\t\t\tgo func() {\n\t\t\t\tif cmd1.IsUnsub() {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(replies[i]...).Reply(RedisMessage{typ: '+', string: \"PONG\"}).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Reply(replies[i]...).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif err := p.Do(ctx, cmd1).Error(); err != nil {\n\t\t\t\tif i < 2 && strings.HasPrefix(err.Error(), \"MOVED\") {\n\t\t\t\t\t// OK\n\t\t\t\t} else {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif v, err := p.Do(ctx, cmd2).ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected val %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub missing unsubReply\", func(t *testing.T) {\n\t\tshouldPanic := func(push cmds.Completed) (pass bool) {\n\t\t\tdefer func() { pass = recover() == protocolbug }()\n\n\t\t\tp, mock, _, _ := setup(t, ClientOption{})\n\t\t\tatomic.StoreInt32(&p.state, 1)\n\t\t\tp.queue.PutOne(push)\n\t\t\t_, _, ch := p.queue.NextWriteCmd()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect().Reply(RedisMessage{\n\t\t\t\t\ttyp: '-', string: \"MOVED\",\n\t\t\t\t}).Reply(RedisMessage{\n\t\t\t\t\ttyp: '-', string: \"MOVED\",\n\t\t\t\t})\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\t<-ch\n\t\t\t}()\n\t\t\tp._backgroundRead()\n\t\t\treturn\n\t\t}\n\t\tfor _, push := range []cmds.Completed{\n\t\t\tbuilder.Sunsubscribe().Channel(\"ch1\").Build(),\n\t\t} {\n\t\t\tif !shouldPanic(push) {\n\t\t\t\tt.Fatalf(\"should panic on protocolbug\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"PubSub missing unsubReply more\", func(t *testing.T) {\n\t\tshouldPanic := func(push cmds.Completed) (pass bool) {\n\t\t\tdefer func() { pass = recover() == protocolbug }()\n\n\t\t\tp, mock, _, _ := setup(t, ClientOption{})\n\t\t\tatomic.StoreInt32(&p.state, 1)\n\t\t\tp.queue.PutOne(push)\n\t\t\tp.queue.PutOne(cmds.PingCmd)\n\t\t\t_, _, ch := p.queue.NextWriteCmd()\n\t\t\t_, _, _ = p.queue.NextWriteCmd()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect().Reply(RedisMessage{\n\t\t\t\t\ttyp: '-', string: \"MOVED\",\n\t\t\t\t}).Reply(RedisMessage{\n\t\t\t\t\ttyp: '-', string: \"MOVED\",\n\t\t\t\t})\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\t<-ch\n\t\t\t}()\n\t\t\tp._backgroundRead()\n\t\t\treturn\n\t\t}\n\t\tfor _, push := range []cmds.Completed{\n\t\t\tbuilder.Sunsubscribe().Channel(\"ch1\").Build(),\n\t\t} {\n\t\t\tif !shouldPanic(push) {\n\t\t\t\tt.Fatalf(\"should panic on protocolbug\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"PubSub unsubReply failed because of NOPERM error from server\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Sunsubscribe().Channel(\"1\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"2\").Build(),\n\t\t\tbuilder.Get().Key(\"mk\").Build(),\n\t\t}\n\n\t\treplies := [][]RedisMessage{\n\t\t\t{\n\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"a\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"b\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t// empty\n\t\t\t}, {\n\t\t\t\t{ // proactive unsubscribe after user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{typ: '+', string: \"mk\"},\n\t\t\t},\n\t\t}\n\n\t\tp.background()\n\n\t\t// proactive unsubscribe before other commands\n\t\tmock.Expect().Reply(RedisMessage{ // proactive unsubscribe before user unsubscribe\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t{typ: '+', string: \"0\"},\n\t\t\t\t{typ: ':', integer: 0},\n\t\t\t},\n\t\t})\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\n\t\tfor i, cmd1 := range commands {\n\t\t\tcmd2 := builder.Get().Key(strconv.Itoa(i)).Build()\n\t\t\tgo func() {\n\t\t\t\tif cmd1.IsUnsub() {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Expect(cmds.PingCmd.Commands()...).\n\t\t\t\t\t\tReply(replies[i]...).\n\t\t\t\t\t\tReply(RedisMessage{ // failed unsubReply\n\t\t\t\t\t\t\ttyp:    '-',\n\t\t\t\t\t\t\tstring: \"NOPERM User u has no permissions to run the 'ping' command\",\n\t\t\t\t\t\t}).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Reply(replies[i]...).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif i == 2 {\n\t\t\t\tif v, err := p.Do(ctx, cmd1).ToString(); err != nil || v != \"mk\" {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := p.Do(ctx, cmd1).Error(); err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif v, err := p.Do(ctx, cmd2).ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected val %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub unsubReply failed because of error LOADING from server\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Sunsubscribe().Channel(\"1\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"2\").Build(),\n\t\t\tbuilder.Get().Key(\"mk\").Build(),\n\t\t}\n\n\t\treplies := [][]RedisMessage{\n\t\t\t{\n\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"a\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ // proactive unsubscribe before user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '+', string: \"b\"},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\t// empty\n\t\t\t}, {\n\t\t\t\t{ // proactive unsubscribe after user unsubscribe\n\t\t\t\t\ttyp: '>',\n\t\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t\t{typ: ':', integer: 0},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{typ: '+', string: \"mk\"},\n\t\t\t},\n\t\t}\n\n\t\tp.background()\n\n\t\t// proactive unsubscribe before other commands\n\t\tmock.Expect().Reply(RedisMessage{ // proactive unsubscribe before user unsubscribe\n\t\t\ttyp: '>',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t\t{typ: '+', string: \"0\"},\n\t\t\t\t{typ: ':', integer: 0},\n\t\t\t},\n\t\t})\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\n\t\tfor i, cmd1 := range commands {\n\t\t\tcmd2 := builder.Get().Key(strconv.Itoa(i)).Build()\n\t\t\tgo func() {\n\t\t\t\tif cmd1.IsUnsub() {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Expect(cmds.PingCmd.Commands()...).\n\t\t\t\t\t\tReply(replies[i]...).\n\t\t\t\t\t\tReply(RedisMessage{ // failed unsubReply\n\t\t\t\t\t\t\ttyp:    '-',\n\t\t\t\t\t\t\tstring: \"LOADING Redis is loading the dataset in memory\",\n\t\t\t\t\t\t}).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t} else {\n\t\t\t\t\tmock.Expect(cmd1.Commands()...).Reply(replies[i]...).Expect(cmd2.Commands()...).ReplyString(strconv.Itoa(i))\n\t\t\t\t}\n\t\t\t}()\n\t\t\tif i == 2 {\n\t\t\t\tif v, err := p.Do(ctx, cmd1).ToString(); err != nil || v != \"mk\" {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := p.Do(ctx, cmd1).Error(); err != nil {\n\t\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif v, err := p.Do(ctx, cmd2).ToString(); err != nil || v != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected val %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tcancel()\n\t})\n\n\tt.Run(\"PubSub Unexpected Subscribe\", func(t *testing.T) {\n\t\tshouldPanic := func(push string) (pass bool) {\n\t\t\tdefer func() { pass = recover() == protocolbug }()\n\n\t\t\tp, mock, _, _ := setup(t, ClientOption{})\n\t\t\tatomic.StoreInt32(&p.state, 1)\n\t\t\tp.queue.PutOne(builder.Get().Key(\"a\").Build())\n\t\t\tp.queue.NextWriteCmd()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect().Reply(RedisMessage{\n\t\t\t\t\ttyp: '>', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: push},\n\t\t\t\t\t\t{typ: '+', string: \"\"},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}()\n\t\t\tp._backgroundRead()\n\t\t\treturn\n\t\t}\n\t\tfor _, push := range []string{\n\t\t\t\"subscribe\",\n\t\t\t\"psubscribe\",\n\t\t\t\"ssubscribe\",\n\t\t} {\n\t\t\tif !shouldPanic(push) {\n\t\t\t\tt.Fatalf(\"should panic on protocolbug\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"PubSub MULTI/EXEC Subscribe\", func(t *testing.T) {\n\t\tshouldPanic := func(cmd Completed) (pass bool) {\n\t\t\tdefer func() { pass = recover() == multiexecsub }()\n\n\t\t\tp, mock, _, _ := setup(t, ClientOption{})\n\t\t\tatomic.StoreInt32(&p.state, 1)\n\t\t\tp.queue.PutOne(cmd)\n\t\t\tp.queue.NextWriteCmd()\n\t\t\tgo func() {\n\t\t\t\tmock.Expect().Reply(RedisMessage{typ: '+', string: \"QUEUED\"})\n\t\t\t}()\n\t\t\tp._backgroundRead()\n\t\t\treturn\n\t\t}\n\t\tfor _, push := range []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"ch1\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"ch1\").Build(),\n\t\t\tbuilder.Ssubscribe().Channel(\"ch1\").Build(),\n\t\t\tbuilder.Unsubscribe().Channel(\"ch1\").Build(),\n\t\t\tbuilder.Punsubscribe().Pattern(\"ch1\").Build(),\n\t\t\tbuilder.Sunsubscribe().Channel(\"ch1\").Build(),\n\t\t} {\n\t\t\tif !shouldPanic(push) {\n\t\t\t\tt.Fatalf(\"should panic on protocolbug\")\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"PubSub blocking mixed\", func(t *testing.T) {\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tdefer cancel()\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"a\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"b\").Build(),\n\t\t\tbuilder.Blpop().Key(\"c\").Timeout(0).Build(),\n\t\t}\n\t\tfor _, resp := range p.DoMulti(context.Background(), commands...).s {\n\t\t\tif e := resp.Error(); e != ErrBlockingPubSubMixed {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", e)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"RESP2 pubsub mixed\", func(t *testing.T) {\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tp.version = 5\n\t\tdefer cancel()\n\n\t\tcommands := []Completed{\n\t\t\tbuilder.Subscribe().Channel(\"a\").Build(),\n\t\t\tbuilder.Psubscribe().Pattern(\"b\").Build(),\n\t\t\tbuilder.Get().Key(\"c\").Build(),\n\t\t}\n\t\tfor _, resp := range p.DoMulti(context.Background(), commands...).s {\n\t\t\tif e := resp.Error(); e != ErrRESP2PubSubMixed {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", e)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"RESP2 pubsub connect error\", func(t *testing.T) {\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tp.version = 5\n\t\te := errors.New(\"any\")\n\t\tp.r2psFn = func() (p *pipe, err error) {\n\t\t\treturn nil, e\n\t\t}\n\t\tdefer cancel()\n\n\t\tif err := p.Receive(context.Background(), builder.Subscribe().Channel(\"a\").Build(), nil); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif err := p.Do(context.Background(), builder.Subscribe().Channel(\"a\").Build()).Error(); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\n\t\tif err := p.DoMulti(context.Background(), builder.Subscribe().Channel(\"a\").Build()).s[0].Error(); err != e {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestPubSubHooks(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tbuilder := cmds.NewBuilder(cmds.NoSlot)\n\n\tt.Run(\"Empty Hooks\", func(t *testing.T) {\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tdefer cancel()\n\t\tif ch := p.SetPubSubHooks(PubSubHooks{}); ch != nil {\n\t\t\tt.Fatalf(\"unexpected ch %v\", ch)\n\t\t}\n\t})\n\n\tt.Run(\"Close on error\", func(t *testing.T) {\n\t\tp, _, cancel, closeConn := setup(t, ClientOption{})\n\t\tdefer cancel()\n\t\tch := p.SetPubSubHooks(PubSubHooks{\n\t\t\tOnMessage: func(m PubSubMessage) {},\n\t\t})\n\t\tcloseConn()\n\t\tif err := <-ch; err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Swap Hooks\", func(t *testing.T) {\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tdefer cancel()\n\t\tch1 := p.SetPubSubHooks(PubSubHooks{\n\t\t\tOnMessage: func(m PubSubMessage) {},\n\t\t})\n\t\tch2 := p.SetPubSubHooks(PubSubHooks{\n\t\t\tOnSubscription: func(s PubSubSubscription) {},\n\t\t})\n\t\tif err := <-ch1; err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tch3 := p.SetPubSubHooks(PubSubHooks{})\n\t\tif err := <-ch2; err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif ch3 != nil {\n\t\t\tt.Fatalf(\"unexpected ch %v\", ch3)\n\t\t}\n\t})\n\n\tt.Run(\"PubSubHooks OnSubscription\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tvar s1, s2, u1, u2 bool\n\n\t\tch := p.SetPubSubHooks(PubSubHooks{\n\t\t\tOnSubscription: func(s PubSubSubscription) {\n\t\t\t\tif s.Kind == \"subscribe\" && s.Channel == \"1\" && s.Count == 1 {\n\t\t\t\t\ts1 = true\n\t\t\t\t}\n\t\t\t\tif s.Kind == \"psubscribe\" && s.Channel == \"2\" && s.Count == 2 {\n\t\t\t\t\ts2 = true\n\t\t\t\t}\n\t\t\t\tif s.Kind == \"unsubscribe\" && s.Channel == \"1\" && s.Count == 1 {\n\t\t\t\t\tu1 = true\n\t\t\t\t}\n\t\t\t\tif s.Kind == \"punsubscribe\" && s.Channel == \"2\" && s.Count == 2 {\n\t\t\t\t\tu2 = true\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\n\t\tactivate1 := builder.Subscribe().Channel(\"1\").Build()\n\t\tactivate2 := builder.Psubscribe().Pattern(\"2\").Build()\n\t\tdeactivate1 := builder.Unsubscribe().Channel(\"1\").Build()\n\t\tdeactivate2 := builder.Punsubscribe().Pattern(\"2\").Build()\n\t\tgo func() {\n\t\t\tmock.Expect(activate1.Commands()...).Expect(activate2.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"psubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"message\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"11\"},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"pmessage\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: '+', string: \"22\"},\n\t\t\t\t\t{typ: '+', string: \"222\"},\n\t\t\t\t}},\n\t\t\t)\n\t\t\tmock.Expect(deactivate1.Commands()...).Expect(cmds.PingCmd.Commands()...).Expect(deactivate2.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"punsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\t\t)\n\t\t\tcancel()\n\t\t}()\n\n\t\tfor _, r := range p.DoMulti(ctx, activate1, activate2).s {\n\t\t\tif err := r.Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tfor _, r := range p.DoMulti(ctx, deactivate1, deactivate2).s {\n\t\t\tif err := r.Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !s1 {\n\t\t\tt.Fatalf(\"unexpected s1\")\n\t\t}\n\t\tif !s2 {\n\t\t\tt.Fatalf(\"unexpected s2\")\n\t\t}\n\t\tif !u1 {\n\t\t\tt.Fatalf(\"unexpected u1\")\n\t\t}\n\t\tif !u2 {\n\t\t\tt.Fatalf(\"unexpected u2\")\n\t\t}\n\t})\n\n\tt.Run(\"PubSubHooks OnMessage\", func(t *testing.T) {\n\t\tctx := context.Background()\n\t\tp, mock, cancel, _ := setup(t, ClientOption{})\n\n\t\tvar m1, m2 bool\n\n\t\tch := p.SetPubSubHooks(PubSubHooks{\n\t\t\tOnMessage: func(m PubSubMessage) {\n\t\t\t\tif m.Channel == \"1\" && m.Message == \"11\" {\n\t\t\t\t\tm1 = true\n\t\t\t\t}\n\t\t\t\tif m.Pattern == \"2\" && m.Channel == \"22\" && m.Message == \"222\" {\n\t\t\t\t\tm2 = true\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\n\t\tactivate1 := builder.Subscribe().Channel(\"1\").Build()\n\t\tactivate2 := builder.Psubscribe().Pattern(\"2\").Build()\n\t\tdeactivate1 := builder.Unsubscribe().Channel(\"1\").Build()\n\t\tdeactivate2 := builder.Punsubscribe().Pattern(\"2\").Build()\n\t\tgo func() {\n\t\t\tmock.Expect(activate1.Commands()...).Expect(activate2.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"subscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"psubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"message\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: '+', string: \"11\"},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"pmessage\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: '+', string: \"22\"},\n\t\t\t\t\t{typ: '+', string: \"222\"},\n\t\t\t\t}},\n\t\t\t)\n\t\t\tmock.Expect(deactivate1.Commands()...).Expect(cmds.PingCmd.Commands()...).Expect(deactivate2.Commands()...).Expect(cmds.PingCmd.Commands()...).Reply(\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"1\"},\n\t\t\t\t\t{typ: ':', integer: 1},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\t\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"punsubscribe\"},\n\t\t\t\t\t{typ: '+', string: \"2\"},\n\t\t\t\t\t{typ: ':', integer: 2},\n\t\t\t\t}},\n\t\t\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\t\t)\n\t\t\tcancel()\n\t\t}()\n\n\t\tfor _, r := range p.DoMulti(ctx, activate1, activate2).s {\n\t\t\tif err := r.Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tfor _, r := range p.DoMulti(ctx, deactivate1, deactivate2).s {\n\t\t\tif err := r.Error(); err != nil {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t\tif err := <-ch; err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !m1 {\n\t\t\tt.Fatalf(\"unexpected m1\")\n\t\t}\n\t\tif !m2 {\n\t\t\tt.Fatalf(\"unexpected m2\")\n\t\t}\n\t})\n}\n\nfunc TestExitOnWriteError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\n\tcloseConn()\n\n\tfor i := 0; i < 2; i++ {\n\t\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Errorf(\"unexpected cached result, expected io err, got %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestExitOnPubSubSubscribeWriteError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\n\tactivate := cmds.NewBuilder(cmds.NoSlot).Subscribe().Channel(\"a\").Build()\n\n\tcount := int64(0)\n\twg := sync.WaitGroup{}\n\ttimes := 2000\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tatomic.AddInt64(&count, 1)\n\t\t\tif err := p.Do(context.Background(), activate).NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\tfor atomic.LoadInt64(&count) < 1000 {\n\t\truntime.Gosched()\n\t}\n\tcloseConn()\n\twg.Wait()\n}\n\nfunc TestExitOnWriteMultiError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{})\n\n\tcloseConn()\n\n\tfor i := 0; i < 2; i++ {\n\t\tif err := p.DoMulti(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestExitOnRingFullAndConnError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{\n\t\tRingScaleEachConn: 1,\n\t})\n\tp.background()\n\n\t// fill the ring\n\tfor i := 0; i < len(p.queue.(*ring).store); i++ {\n\t\tgo func() {\n\t\t\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).Error(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\t// let writer loop over the ring\n\tfor i := 0; i < len(p.queue.(*ring).store); i++ {\n\t\tmock.Expect(\"GET\", \"a\")\n\t}\n\n\ttime.Sleep(time.Second) // make sure the writer is waiting for the next write\n\tcloseConn()\n\n\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).Error(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t}\n}\n\nfunc TestExitOnRingFullAndPingTimout(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{\n\t\tRingScaleEachConn: 1,\n\t\tConnWriteTimeout:  500 * time.Millisecond,\n\t\tDialer:            net.Dialer{KeepAlive: 500 * time.Millisecond},\n\t})\n\tp.background()\n\n\t// fill the ring\n\tfor i := 0; i < len(p.queue.(*ring).store); i++ {\n\t\tgo func() {\n\t\t\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).Error(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\tt.Errorf(\"unexpected result, expected context.DeadlineExceeded, got %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\t// let writer loop over the ring\n\tfor i := 0; i < len(p.queue.(*ring).store); i++ {\n\t\tmock.Expect(\"GET\", \"a\")\n\t}\n\n\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).Error(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Errorf(\"unexpected result, expected context.DeadlineExceeded, got %v\", err)\n\t}\n}\n\nfunc TestExitAllGoroutineOnWriteError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tconn, mock, _, closeConn := setup(t, ClientOption{})\n\n\t// start the background worker\n\tactivate := cmds.NewBuilder(cmds.NoSlot).Subscribe().Channel(\"a\").Build()\n\tgo conn.Do(context.Background(), activate)\n\tmock.Expect(activate.Commands()...)\n\n\tcloseConn()\n\twg := sync.WaitGroup{}\n\ttimes := 2000\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tif err := conn.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t\t}\n\t\t\tif err := conn.DoMulti(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestExitOnReadError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcloseConn()\n\t}()\n\n\tfor i := 0; i < 2; i++ {\n\t\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestExitOnReadMultiError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcloseConn()\n\t}()\n\n\tfor i := 0; i < 2; i++ {\n\t\tif err := p.DoMulti(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestExitAllGoroutineOnReadError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcloseConn()\n\t}()\n\n\twg := sync.WaitGroup{}\n\ttimes := 2000\n\twg.Add(times)\n\tfor i := 0; i < times; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t\t}\n\t\t\tif err := p.DoMulti(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\t\tt.Errorf(\"unexpected result, expected io err, got %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestCloseAndWaitPendingCMDs(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\n\tvar (\n\t\tloop = 2000\n\t\twg   sync.WaitGroup\n\t)\n\n\twg.Add(loop)\n\tfor i := 0; i < loop; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tif v, _ := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).ToMessage(); v.string != \"b\" {\n\t\t\t\tt.Errorf(\"unexpected GET result %v\", v.string)\n\t\t\t}\n\t\t}()\n\t}\n\tfor i := 0; i < loop; i++ {\n\t\tr := mock.Expect(\"GET\", \"a\")\n\t\tif i == loop-1 {\n\t\t\tgo p.Close()\n\t\t\ttime.Sleep(time.Second / 2)\n\t\t}\n\t\tr.ReplyString(\"b\")\n\t}\n\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\tmock.Close()\n\twg.Wait()\n}\n\nfunc TestCloseWithGracefulPeriodExceeded(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\tgo func() {\n\t\tp.Close()\n\t}()\n\tmock.Expect(\"PING\")\n\t<-p.close\n}\n\nfunc TestCloseWithPipeliningAndGracefulPeriodExceeded(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{AlwaysPipelining: true})\n\tgo func() {\n\t\tp.Close()\n\t}()\n\tmock.Expect(\"PING\")\n\t<-p.close\n}\n\nfunc TestAlreadyCanceledContext(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, close, closeConn := setup(t, ClientOption{})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\n\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\tif s := p.DoStream(ctx, cp, cmds.NewCompleted([]string{\"GET\", \"a\"})); !errors.Is(s.Error(), context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t}\n\tif s := p.DoMultiStream(ctx, cp, cmds.NewCompleted([]string{\"GET\", \"a\"})); !errors.Is(s.Error(), context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t}\n\n\tctx, cancel = context.WithDeadline(context.Background(), time.Now().Add(-1*time.Second))\n\tcancel()\n\n\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tclose()\n}\n\nfunc TestCancelContext_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, shutdown, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcancel()\n\t\tmock.Expect().ReplyString(\"OK\")\n\t}()\n\n\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tshutdown()\n}\n\nfunc TestCancelContext_DoStream(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)\n\tdefer cancel()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\ts := p.DoStream(ctx, cp, cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestWriteDeadlineIsShorterThanContextDeadline_DoStream(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{ConnWriteTimeout: 100 * time.Millisecond})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\tstartTime := time.Now()\n\ts := p.DoStream(ctx, cp, cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif time.Since(startTime) >= time.Second {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestWriteDeadlineIsNoShorterThanContextDeadline_DoStreamBlocked(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{ConnWriteTimeout: 5 * time.Millisecond})\n\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\tstartTime := time.Now()\n\ts := p.DoStream(ctx, cp, cmds.NewBlockingCompleted([]string{\"BLPOP\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif time.Since(startTime) < 100*time.Millisecond {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestCancelContext_Do_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, shutdown, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcancel()\n\t\tmock.Expect().ReplyString(\"OK\")\n\t}()\n\n\tif err := p.Do(ctx, cmds.NewBlockingCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tshutdown()\n}\n\nfunc TestCancelContext_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, shutdown, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcancel()\n\t\tmock.Expect().ReplyString(\"OK\")\n\t}()\n\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tshutdown()\n}\n\nfunc TestCancelContext_DoMulti_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, shutdown, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcancel()\n\t\tmock.Expect().ReplyString(\"OK\")\n\t}()\n\n\tif err := p.DoMulti(ctx, cmds.NewBlockingCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tshutdown()\n}\n\nfunc TestCancelContext_DoMultiStream(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)\n\tdefer cancel()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\ts := p.DoMultiStream(ctx, cp, cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestWriteDeadlineIsShorterThanContextDeadline_DoMultiStream(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{ConnWriteTimeout: 100 * time.Millisecond})\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\tstartTime := time.Now()\n\ts := p.DoMultiStream(ctx, cp, cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif time.Since(startTime) >= time.Second {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestWriteDeadlineIsNoShorterThanContextDeadline_DoMultiStreamBlocked(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{ConnWriteTimeout: 5 * time.Millisecond})\n\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\tstartTime := time.Now()\n\ts := p.DoMultiStream(ctx, cp, cmds.NewBlockingCompleted([]string{\"BLPOP\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif time.Since(startTime) < 100*time.Millisecond {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestForceClose_Do_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tp.Close()\n\t}()\n\n\tif err := p.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"GET\", \"a\"})).NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestTimeout_DoStream(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{ConnWriteTimeout: time.Millisecond * 30})\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\n\ts := p.DoStream(context.Background(), cp, cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestForceClose_DoStream_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{ConnWriteTimeout: time.Second})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tp.Close()\n\t}()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\n\ts := p.DoStream(context.Background(), cp, cmds.NewBlockingCompleted([]string{\"GET\", \"a\"}))\n\tif s.Error() != nil {\n\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t}\n\tbuf := bytes.NewBuffer(nil)\n\tfor s.HasNext() {\n\t\tn, err := s.WriteTo(buf)\n\t\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t\t}\n\t\tif n != 0 {\n\t\t\tt.Errorf(\"unexpected n %v\\n\", n)\n\t\t}\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestForceClose_Do_Canceled_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcancel()\n\t\tmock.Expect().ReplyString(\"OK\")\n\t}()\n\n\tif err := p.Do(ctx, cmds.NewBlockingCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestForceClose_DoMulti_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tp.Close()\n\t}()\n\n\tif err := p.DoMulti(context.Background(), cmds.NewBlockingCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestTimeout_DoMultiStream(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, _ := setup(t, ClientOption{ConnWriteTimeout: time.Millisecond * 30})\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\n\ts := p.DoMultiStream(context.Background(), cp, cmds.NewCompleted([]string{\"GET\", \"a\"}))\n\tif err := s.Error(); err != io.EOF && !strings.Contains(err.Error(), \"i/o\") {\n\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestForceClose_DoMultiStream_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{ConnWriteTimeout: time.Second})\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tp.Close()\n\t}()\n\n\tcp := newPool(1, nil, 0, 0, nil)\n\n\ts := p.DoMultiStream(context.Background(), cp, cmds.NewBlockingCompleted([]string{\"GET\", \"a\"}))\n\tif s.Error() != nil {\n\t\tt.Fatalf(\"unexpected err %v\", s.Error())\n\t}\n\tbuf := bytes.NewBuffer(nil)\n\tfor s.HasNext() {\n\t\tn, err := s.WriteTo(buf)\n\t\tif err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Errorf(\"unexpected err %v\\n\", err)\n\t\t}\n\t\tif n != 0 {\n\t\t\tt.Errorf(\"unexpected n %v\\n\", n)\n\t\t}\n\t}\n\tif len(cp.list) != 0 {\n\t\tt.Fatalf(\"unexpected pool length %v\", len(cp.list))\n\t}\n}\n\nfunc TestForceClose_DoMulti_Canceled_Block(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, _ := setup(t, ClientOption{})\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\tmock.Expect(\"GET\", \"a\")\n\t\tcancel()\n\t\tmock.Expect().ReplyString(\"OK\")\n\t}()\n\n\tif err := p.DoMulti(ctx, cmds.NewBlockingCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.Canceled) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestSyncModeSwitchingWithDeadlineExceed_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Microsecond*100)\n\tdefer cancel()\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\tmock.Expect(\"GET\", \"a\")\n\ttime.Sleep(time.Second / 2)\n\tmock.Expect().ReplyString(\"OK\")\n\twg.Wait()\n\tp.Close()\n}\n\nfunc TestSyncModeSwitchingWithDeadlineExceed_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, _, closeConn := setup(t, ClientOption{})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*100)\n\tdefer cancel()\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\tmock.Expect(\"GET\", \"a\")\n\ttime.Sleep(time.Second / 2)\n\tmock.Expect().ReplyString(\"OK\")\n\twg.Wait()\n\tp.Close()\n}\n\nfunc TestOngoingDeadlineShortContextInSyncMode_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 1 * time.Second})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second/2))\n\tdefer cancel()\n\n\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestOngoingDeadlineLongContextInSyncMode_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 1 * time.Second / 4})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second/2))\n\tdefer cancel()\n\n\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestWriteDeadlineInSyncMode_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 1 * time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tdefer closeConn()\n\n\tif err := p.Do(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestWriteDeadlineIsShorterThanContextDeadlineInSyncMode_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 100 * time.Millisecond, Dialer: net.Dialer{KeepAlive: time.Second}})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tstartTime := time.Now()\n\tif err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).NonRedisError(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tif time.Since(startTime) >= time.Second {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\n\tp.Close()\n}\n\nfunc TestWriteDeadlineIsNoShorterThanContextDeadlineInSyncMode_DoBlocked(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 5 * time.Second, Dialer: net.Dialer{KeepAlive: time.Second}})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\tstartTime := time.Now()\n\tif err := p.Do(ctx, cmds.NewBlockingCompleted([]string{\"BLPOP\", \"a\"})).NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tif time.Since(startTime) < 100*time.Millisecond {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\n\tp.Close()\n}\n\nfunc TestOngoingDeadlineShortContextInSyncMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: time.Second})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second/2))\n\tdefer cancel()\n\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestOngoingDeadlineLongContextInSyncMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: time.Second / 4})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(1*time.Second/2))\n\tdefer cancel()\n\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestWriteDeadlineInSyncMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tdefer closeConn()\n\n\tif err := p.DoMulti(context.Background(), cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tp.Close()\n}\n\nfunc TestWriteDeadlineIsShorterThanContextDeadlineInSyncMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 100 * time.Millisecond, Dialer: net.Dialer{KeepAlive: time.Second}})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\n\tstartTime := time.Now()\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tif time.Since(startTime) >= time.Second {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\n\tp.Close()\n}\n\nfunc TestWriteDeadlineIsNoShorterThanContextDeadlineInSyncMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: time.Second, Dialer: net.Dialer{KeepAlive: time.Second}})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second/2)\n\tdefer cancel()\n\n\tstartTime := time.Now()\n\tif err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tif time.Since(startTime) >= time.Second {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\n\tp.Close()\n}\n\nfunc TestWriteDeadlineIsNoShorterThanContextDeadlineInSyncMode_DoMultiBlocked(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 5 * time.Millisecond, Dialer: net.Dialer{KeepAlive: time.Second}})\n\tdefer closeConn()\n\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\tstartTime := time.Now()\n\tif err := p.DoMulti(ctx, cmds.NewBlockingCompleted([]string{\"BLPOP\", \"a\"})).s[0].NonRedisError(); !errors.Is(err, context.DeadlineExceeded) {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tif time.Since(startTime) < 100*time.Millisecond {\n\t\tt.Fatalf(\"unexpected time %v\", time.Since(startTime))\n\t}\n\n\tp.Close()\n}\n\nfunc TestOngoingCancelContextInPipelineMode_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, close, closeConn := setup(t, ClientOption{})\n\tdefer closeConn()\n\n\tp.background()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tcanceled := int32(0)\n\n\tfor i := 0; i < 5; i++ {\n\t\tgo func() {\n\t\t\t_, err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).ToString()\n\t\t\tif errors.Is(err, context.Canceled) {\n\t\t\t\tatomic.AddInt32(&canceled, 1)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor atomic.LoadInt32(&p.waits) != 5 {\n\t\tt.Logf(\"wait p.waits to be 5 %v\", atomic.LoadInt32(&p.waits))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tcancel()\n\n\tfor atomic.LoadInt32(&canceled) != 5 {\n\t\tt.Logf(\"wait canceled count to be 5 %v\", atomic.LoadInt32(&canceled))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\t// the rest command is still send\n\tfor i := 0; i < 5; i++ {\n\t\tmock.Expect(\"GET\", \"a\").ReplyString(\"OK\")\n\t}\n\tclose()\n}\n\nfunc TestOngoingWriteTimeoutInPipelineMode_Do(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tdefer closeConn()\n\n\tp.background()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\ttimeout := int32(0)\n\n\tfor i := 0; i < 5; i++ {\n\t\tgo func() {\n\t\t\t_, err := p.Do(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).ToString()\n\t\t\tif errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\tatomic.AddInt32(&timeout, 1)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\tfor atomic.LoadInt32(&p.waits) != 5 {\n\t\tt.Logf(\"wait p.waits to be 5 %v\", atomic.LoadInt32(&p.waits))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tfor atomic.LoadInt32(&timeout) != 5 {\n\t\tt.Logf(\"wait timeout count to be 5 %v\", atomic.LoadInt32(&timeout))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tp.Close()\n}\n\nfunc TestOngoingCancelContextInPipelineMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, close, closeConn := setup(t, ClientOption{})\n\tdefer closeConn()\n\n\tp.background()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tcanceled := int32(0)\n\n\tfor i := 0; i < 5; i++ {\n\t\tgo func() {\n\t\t\t_, err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].ToString()\n\t\t\tif errors.Is(err, context.Canceled) {\n\t\t\t\tatomic.AddInt32(&canceled, 1)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor atomic.LoadInt32(&p.waits) != 5 {\n\t\tt.Logf(\"wait p.waits to be 5 %v\", atomic.LoadInt32(&p.waits))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tcancel()\n\n\tfor atomic.LoadInt32(&canceled) != 5 {\n\t\tt.Logf(\"wait canceled count to be 5 %v\", atomic.LoadInt32(&canceled))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\t// the rest command is still send\n\tfor i := 0; i < 5; i++ {\n\t\tmock.Expect(\"GET\", \"a\").ReplyString(\"OK\")\n\t}\n\tclose()\n}\n\nfunc TestOngoingWriteTimeoutInPipelineMode_DoMulti(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, _, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tdefer closeConn()\n\n\tp.background()\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\n\ttimeout := int32(0)\n\n\tfor i := 0; i < 5; i++ {\n\t\tgo func() {\n\t\t\t_, err := p.DoMulti(ctx, cmds.NewCompleted([]string{\"GET\", \"a\"})).s[0].ToString()\n\t\t\tif errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\tatomic.AddInt32(&timeout, 1)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\tfor atomic.LoadInt32(&p.waits) != 5 {\n\t\tt.Logf(\"wait p.waits to be 5 %v\", atomic.LoadInt32(&p.waits))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tfor atomic.LoadInt32(&timeout) != 5 {\n\t\tt.Logf(\"wait timeout count to be 5 %v\", atomic.LoadInt32(&timeout))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tp.Close()\n}\n\nfunc TestPipe_CleanSubscriptions_6(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tdefer cancel()\n\tp.background()\n\tgo func() {\n\t\tp.CleanSubscriptions()\n\t}()\n\tmock.Expect(\"UNSUBSCRIBE\").Expect(cmds.PingCmd.Commands()...).Expect(\"PUNSUBSCRIBE\").Expect(cmds.PingCmd.Commands()...).Expect(\"DISCARD\").Reply(\n\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t{typ: '_'},\n\t\t\t{typ: ':', integer: 1},\n\t\t}},\n\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"punsubscribe\"},\n\t\t\t{typ: '_'},\n\t\t\t{typ: ':', integer: 2},\n\t\t}},\n\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\tRedisMessage{typ: '+', string: \"OK\"},\n\t)\n}\n\nfunc TestPipe_CleanSubscriptions_Blocking(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tdefer cancel()\n\tp.background()\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\tmock.Expect(\"BLPOP\")\n\t\tcancel()\n\t}()\n\tp.Do(ctx, cmds.NewBlockingCompleted([]string{\"BLPOP\"}))\n\tp.CleanSubscriptions()\n\tif p.Error() != ErrClosing {\n\t\tt.Fatal(\"unexpected error\")\n\t}\n}\n\nfunc TestPipe_CleanSubscriptions_7(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: time.Second / 2, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\tp.version = 7\n\tdefer cancel()\n\tp.background()\n\tgo func() {\n\t\tp.CleanSubscriptions()\n\t}()\n\tmock.Expect(\"UNSUBSCRIBE\").Expect(cmds.PingCmd.Commands()...).Expect(\"PUNSUBSCRIBE\").Expect(cmds.PingCmd.Commands()...).Expect(\"SUNSUBSCRIBE\").Expect(cmds.PingCmd.Commands()...).Expect(\"DISCARD\").Reply(\n\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"unsubscribe\"},\n\t\t\t{typ: '_'},\n\t\t\t{typ: ':', integer: 1},\n\t\t}},\n\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"punsubscribe\"},\n\t\t\t{typ: '_'},\n\t\t\t{typ: ':', integer: 2},\n\t\t}},\n\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\tRedisMessage{typ: '>', values: []RedisMessage{\n\t\t\t{typ: '+', string: \"sunsubscribe\"},\n\t\t\t{typ: '_'},\n\t\t\t{typ: ':', integer: 3},\n\t\t}},\n\t\tRedisMessage{typ: '+', string: \"PONG\"},\n\t\tRedisMessage{typ: '+', string: \"OK\"},\n\t)\n}\n\nfunc TestPingOnConnError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"sync\", func(t *testing.T) {\n\t\tp, mock, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 3 * time.Second, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\t\tmock.Expect(\"PING\")\n\t\tcloseConn()\n\t\ttime.Sleep(time.Second / 2)\n\t\tp.Close()\n\t\tif err := p.Error(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Fatalf(\"unexpect err %v\", err)\n\t\t}\n\t})\n\tt.Run(\"pipelining\", func(t *testing.T) {\n\t\tp, mock, _, closeConn := setup(t, ClientOption{ConnWriteTimeout: 3 * time.Second, Dialer: net.Dialer{KeepAlive: time.Second / 3}})\n\t\tp.background()\n\t\tmock.Expect(\"PING\")\n\t\tcloseConn()\n\t\ttime.Sleep(time.Second / 2)\n\t\tp.Close()\n\t\tif err := p.Error(); err != io.EOF && !strings.HasPrefix(err.Error(), \"io:\") {\n\t\t\tt.Fatalf(\"unexpect err %v\", err)\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestBlockingCommandNoDeadline(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\t// blocking command should not apply timeout\n\ttimeout := 100 * time.Millisecond\n\tt.Run(\"sync do\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: timeout})\n\t\tdefer cancel()\n\t\tgo func() {\n\t\t\ttime.Sleep(2 * timeout)\n\t\t\tmock.Expect(\"BLOCK\").ReplyString(\"OK\")\n\t\t}()\n\t\tif val, err := p.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Fatalf(\"unexpect resp %v %v\", err, val)\n\t\t}\n\t})\n\tt.Run(\"sync do multi\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: timeout})\n\t\tdefer cancel()\n\t\tgo func() {\n\t\t\ttime.Sleep(3 * timeout)\n\t\t\tmock.Expect(\"READ\").ReplyString(\"READ\").\n\t\t\t\tExpect(\"BLOCK\").ReplyString(\"OK\")\n\t\t}()\n\t\tif val, err := p.DoMulti(context.Background(),\n\t\t\tcmds.NewReadOnlyCompleted([]string{\"READ\"}),\n\t\t\tcmds.NewBlockingCompleted([]string{\"BLOCK\"})).s[1].ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Fatalf(\"unexpect resp %v %v\", err, val)\n\t\t}\n\t})\n\tt.Run(\"pipeline do - no ping\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: timeout, Dialer: net.Dialer{KeepAlive: timeout}})\n\t\tdefer cancel()\n\t\tp.background()\n\t\tgo func() {\n\t\t\ttime.Sleep(3 * timeout)\n\t\t\tmock.Expect(\"BLOCK\").ReplyString(\"OK\")\n\t\t}()\n\t\tif val, err := p.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Fatalf(\"unexpect resp %v %v\", err, val)\n\t\t}\n\t})\n\tt.Run(\"pipeline do - ignore ping timeout\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: timeout, Dialer: net.Dialer{KeepAlive: timeout}})\n\t\tdefer cancel()\n\t\tp.background()\n\t\twait := make(chan struct{})\n\t\tgo func() {\n\t\t\tmock.Expect(\"PING\")\n\t\t\tclose(wait)\n\t\t\ttime.Sleep(2 * timeout)\n\t\t\tmock.Expect(\"BLOCK\").ReplyString(\"OK\").ReplyString(\"OK\")\n\t\t}()\n\t\t<-wait\n\t\tif val, err := p.Do(context.Background(), cmds.NewBlockingCompleted([]string{\"BLOCK\"})).ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Fatalf(\"unexpect resp %v %v\", err, val)\n\t\t}\n\t})\n\tt.Run(\"pipeline do multi - no ping\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: timeout, Dialer: net.Dialer{KeepAlive: timeout}})\n\t\tdefer cancel()\n\t\tp.background()\n\t\tgo func() {\n\t\t\ttime.Sleep(3 * timeout)\n\t\t\tmock.Expect(\"READ\").ReplyString(\"READ\").\n\t\t\t\tExpect(\"BLOCK\").ReplyString(\"OK\")\n\t\t}()\n\t\tif val, err := p.DoMulti(context.Background(),\n\t\t\tcmds.NewReadOnlyCompleted([]string{\"READ\"}),\n\t\t\tcmds.NewBlockingCompleted([]string{\"BLOCK\"})).s[1].ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Fatalf(\"unexpect resp %v %v\", err, val)\n\t\t}\n\t})\n\tt.Run(\"pipeline do multi - ignore ping timeout\", func(t *testing.T) {\n\t\tp, mock, cancel, _ := setup(t, ClientOption{ConnWriteTimeout: timeout, Dialer: net.Dialer{KeepAlive: timeout}})\n\t\tdefer cancel()\n\t\tp.background()\n\t\twait := make(chan struct{})\n\t\tgo func() {\n\t\t\tmock.Expect(\"PING\")\n\t\t\tclose(wait)\n\t\t\ttime.Sleep(2 * timeout)\n\t\t\tmock.Expect(\"READ\").Expect(\"BLOCK\").ReplyString(\"OK\").ReplyString(\"READ\").ReplyString(\"OK\")\n\t\t}()\n\t\t<-wait\n\t\tif val, err := p.DoMulti(context.Background(),\n\t\t\tcmds.NewReadOnlyCompleted([]string{\"READ\"}),\n\t\t\tcmds.NewBlockingCompleted([]string{\"BLOCK\"})).s[1].ToString(); err != nil || val != \"OK\" {\n\t\t\tt.Fatalf(\"unexpect resp %v %v\", err, val)\n\t\t}\n\t})\n}\n\nfunc TestDeadPipe(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tctx := context.Background()\n\tif err := deadFn().Error(); err != ErrClosing {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := deadFn().Do(ctx, cmds.NewCompleted(nil)).Error(); err != ErrClosing {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := deadFn().DoMulti(ctx, cmds.NewCompleted(nil)).s[0].Error(); err != ErrClosing {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := deadFn().DoCache(ctx, Cacheable(cmds.NewCompleted(nil)), time.Second).Error(); err != ErrClosing {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := deadFn().Receive(ctx, cmds.NewCompleted(nil), func(message PubSubMessage) {}); err != ErrClosing {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := <-deadFn().SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != ErrClosing {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestErrorPipe(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tctx := context.Background()\n\ttarget := errors.New(\"any\")\n\tif err := epipeFn(target).Error(); err != target {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := epipeFn(target).Do(ctx, cmds.NewCompleted(nil)).Error(); err != target {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := epipeFn(target).DoMulti(ctx, cmds.NewCompleted(nil)).s[0].Error(); err != target {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := epipeFn(target).DoCache(ctx, Cacheable(cmds.NewCompleted(nil)), time.Second).Error(); err != target {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := epipeFn(target).Receive(ctx, cmds.NewCompleted(nil), func(message PubSubMessage) {}); err != target {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tif err := <-epipeFn(target).SetPubSubHooks(PubSubHooks{OnMessage: func(m PubSubMessage) {}}); err != target {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestCloseHook(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"normal close\", func(t *testing.T) {\n\t\tvar flag int32\n\t\tp, _, cancel, _ := setup(t, ClientOption{})\n\t\tp.SetOnCloseHook(func(error) {\n\t\t\tatomic.StoreInt32(&flag, 1)\n\t\t})\n\t\tcancel()\n\t\tif atomic.LoadInt32(&flag) != 1 {\n\t\t\tt.Fatalf(\"hook not be invoked\")\n\t\t}\n\t})\n\tt.Run(\"disconnect\", func(t *testing.T) {\n\t\tvar flag int32\n\t\tp, _, _, closeConn := setup(t, ClientOption{})\n\t\tp.SetOnCloseHook(func(error) {\n\t\t\tatomic.StoreInt32(&flag, 1)\n\t\t})\n\t\tp.background()\n\t\tcloseConn()\n\t\tfor atomic.LoadInt32(&flag) != 1 {\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\tt.Log(\"wait close hook to be invoked\")\n\t\t}\n\t})\n}\n\nfunc TestNoHelloRegex(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ttests := []struct {\n\t\tname  string\n\t\tmatch bool\n\t\tresp  string\n\t}{\n\t\t{\n\t\t\tname:  \"lowercase hello\",\n\t\t\tmatch: true,\n\t\t\tresp:  \"unknown command hello\",\n\t\t},\n\t\t{\n\t\t\tname:  \"uppercase hello\",\n\t\t\tmatch: true,\n\t\t\tresp:  \"unknown command HELLO\",\n\t\t},\n\t\t{\n\t\t\tname:  \"not hello\",\n\t\t\tmatch: false,\n\t\t\tresp:  \"unknown command not hello\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif match := noHello.MatchString(tt.resp); match != tt.match {\n\t\t\t\tt.Fatalf(\"unexpected match %v\", match)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "pool.go",
          "type": "blob",
          "size": 1.912109375,
          "content": "package rueidis\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nfunc newPool(cap int, dead wire, cleanup time.Duration, minSize int, makeFn func() wire) *pool {\n\tif cap <= 0 {\n\t\tcap = DefaultPoolSize\n\t}\n\n\treturn &pool{\n\t\tsize:    0,\n\t\tminSize: minSize,\n\t\tcap:     cap,\n\t\tdead:    dead,\n\t\tmake:    makeFn,\n\t\tlist:    make([]wire, 0, 4),\n\t\tcond:    sync.NewCond(&sync.Mutex{}),\n\t\tcleanup: cleanup,\n\t}\n}\n\ntype pool struct {\n\tdead    wire\n\tcond    *sync.Cond\n\ttimer   *time.Timer\n\tmake    func() wire\n\tlist    []wire\n\tcleanup time.Duration\n\tsize    int\n\tminSize int\n\tcap     int\n\tdown    bool\n\ttimerOn bool\n}\n\nfunc (p *pool) Acquire() (v wire) {\n\tp.cond.L.Lock()\nretry:\n\tfor len(p.list) == 0 && p.size == p.cap && !p.down {\n\t\tp.cond.Wait()\n\t}\n\tif p.down {\n\t\tv = p.dead\n\t} else if len(p.list) == 0 {\n\t\tp.size++\n\t\tv = p.make()\n\t} else {\n\t\ti := len(p.list) - 1\n\t\tv = p.list[i]\n\t\tp.list[i] = nil\n\t\tp.list = p.list[:i]\n\t\tif v.Error() != nil {\n\t\t\tp.size--\n\t\t\tv.Close()\n\t\t\tgoto retry\n\t\t}\n\t}\n\tp.cond.L.Unlock()\n\treturn v\n}\n\nfunc (p *pool) Store(v wire) {\n\tp.cond.L.Lock()\n\tif !p.down && v.Error() == nil {\n\t\tp.list = append(p.list, v)\n\t\tp.startTimerIfNeeded()\n\t} else {\n\t\tp.size--\n\t\tv.Close()\n\t}\n\tp.cond.L.Unlock()\n\tp.cond.Signal()\n}\n\nfunc (p *pool) Close() {\n\tp.cond.L.Lock()\n\tp.down = true\n\tp.stopTimer()\n\tfor _, w := range p.list {\n\t\tw.Close()\n\t}\n\tp.cond.L.Unlock()\n\tp.cond.Broadcast()\n}\n\nfunc (p *pool) startTimerIfNeeded() {\n\tif p.cleanup == 0 || p.timerOn || len(p.list) <= p.minSize {\n\t\treturn\n\t}\n\n\tp.timerOn = true\n\tif p.timer == nil {\n\t\tp.timer = time.AfterFunc(p.cleanup, p.removeIdleConns)\n\t} else {\n\t\tp.timer.Reset(p.cleanup)\n\t}\n}\n\nfunc (p *pool) removeIdleConns() {\n\tp.cond.L.Lock()\n\tdefer p.cond.L.Unlock()\n\n\tnewLen := min(p.minSize, len(p.list))\n\tfor i, w := range p.list[newLen:] {\n\t\tw.Close()\n\t\tp.list[newLen+i] = nil\n\t\tp.size--\n\t}\n\n\tp.list = p.list[:newLen]\n\tp.timerOn = false\n}\n\nfunc (p *pool) stopTimer() {\n\tp.timerOn = false\n\tif p.timer != nil {\n\t\tp.timer.Stop()\n\t}\n}\n"
        },
        {
          "name": "pool_test.go",
          "type": "blob",
          "size": 7.197265625,
          "content": "package rueidis\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar dead = deadFn()\n\n//gocyclo:ignore\nfunc TestPool(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tsetup := func(size int) (*pool, *int32) {\n\t\tvar count int32\n\t\treturn newPool(size, dead, 0, 0, func() wire {\n\t\t\tatomic.AddInt32(&count, 1)\n\t\t\tclosed := false\n\t\t\treturn &mockWire{\n\t\t\t\tCloseFn: func() {\n\t\t\t\t\tclosed = true\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\tif closed {\n\t\t\t\t\t\treturn ErrClosing\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\t\t}), &count\n\t}\n\n\tt.Run(\"DefaultPoolSize\", func(t *testing.T) {\n\t\tp := newPool(0, dead, 0, 0, func() wire { return nil })\n\t\tif cap(p.list) == 0 {\n\t\t\tt.Fatalf(\"DefaultPoolSize is not applied\")\n\t\t}\n\t})\n\n\tt.Run(\"Reuse\", func(t *testing.T) {\n\t\tpool, count := setup(100)\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tpool.Store(pool.Acquire())\n\t\t}\n\t\tif atomic.LoadInt32(count) != 1 {\n\t\t\tt.Fatalf(\"pool does not reuse connection\")\n\t\t}\n\t})\n\n\tt.Run(\"Reuse without broken connections\", func(t *testing.T) {\n\t\tpool, count := setup(100)\n\t\tc1 := pool.Acquire()\n\t\tc2 := pool.Acquire()\n\t\tpool.Store(c1)\n\t\tpool.Store(c2)\n\t\tpool.cond.L.Lock()\n\t\tfor _, p := range pool.list {\n\t\t\tp.Close()\n\t\t}\n\t\tpool.cond.L.Unlock()\n\t\tc3 := pool.Acquire()\n\t\tif c3.Error() != nil {\n\t\t\tt.Fatalf(\"c3.Error() is not nil\")\n\t\t}\n\t\tif atomic.LoadInt32(count) != 3 {\n\t\t\tt.Fatalf(\"pool does not clean borken connections\")\n\t\t}\n\t\tpool.cond.L.Lock()\n\t\tdefer pool.cond.L.Unlock()\n\t\tif pool.size != 1 {\n\t\t\tt.Fatalf(\"pool size is not 1\")\n\t\t}\n\t\tif len(pool.list) != 0 {\n\t\t\tt.Fatalf(\"pool list is not empty\")\n\t\t}\n\t})\n\n\tt.Run(\"NotExceed\", func(t *testing.T) {\n\t\tconn := make([]wire, 100)\n\t\tpool, count := setup(len(conn))\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tconn[i] = pool.Acquire()\n\t\t}\n\t\tif atomic.LoadInt32(count) != 100 {\n\t\t\tt.Fatalf(\"unexpected acquire count\")\n\t\t}\n\t\tgo func() {\n\t\t\tfor i := 0; i < len(conn); i++ {\n\t\t\t\tpool.Store(conn[i])\n\t\t\t}\n\t\t}()\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tpool.Acquire()\n\t\t}\n\t\tif atomic.LoadInt32(count) > 100 {\n\t\t\tt.Fatalf(\"pool must not exceed the size limit\")\n\t\t}\n\t})\n\n\tt.Run(\"NoShare\", func(t *testing.T) {\n\t\tconn := make([]wire, 100)\n\t\tpool, _ := setup(len(conn))\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tw := pool.Acquire()\n\t\t\tgo pool.Store(w)\n\t\t}\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tconn[i] = pool.Acquire()\n\t\t}\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tfor j := i + 1; j < len(conn); j++ {\n\t\t\t\tif conn[i] == conn[j] {\n\t\t\t\t\tt.Fatalf(\"pool must not output acquired connection\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Close\", func(t *testing.T) {\n\t\tpool, count := setup(2)\n\t\tw1 := pool.Acquire()\n\t\tw2 := pool.Acquire()\n\t\tif w1.Error() != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", w1.Error())\n\t\t}\n\t\tif w2.Error() != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", w2.Error())\n\t\t}\n\t\tif atomic.LoadInt32(count) != 2 {\n\t\t\tt.Fatalf(\"pool does not make new wire\")\n\t\t}\n\t\tpool.Store(w1)\n\t\tpool.Close()\n\t\tif w1.Error() != ErrClosing {\n\t\t\tt.Fatalf(\"pool does not close existing wire after Close()\")\n\t\t}\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif rw := pool.Acquire(); rw != dead {\n\t\t\t\tt.Fatalf(\"pool does not return the dead wire after Close()\")\n\t\t\t}\n\t\t}\n\t\tpool.Store(w2)\n\t\tif w2.Error() != ErrClosing {\n\t\t\tt.Fatalf(\"pool does not close stored wire after Close()\")\n\t\t}\n\t})\n\n\tt.Run(\"Close Empty\", func(t *testing.T) {\n\t\tpool, count := setup(2)\n\t\tw1 := pool.Acquire()\n\t\tif w1.Error() != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", w1.Error())\n\t\t}\n\t\tpool.Close()\n\t\tw2 := pool.Acquire()\n\t\tif w2.Error() != ErrClosing {\n\t\t\tt.Fatalf(\"pool does not close wire after Close()\")\n\t\t}\n\t\tif atomic.LoadInt32(count) != 1 {\n\t\t\tt.Fatalf(\"pool should not make new wire\")\n\t\t}\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif rw := pool.Acquire(); rw != dead {\n\t\t\t\tt.Fatalf(\"pool does not return the dead wire after Close()\")\n\t\t\t}\n\t\t}\n\t\tpool.Store(w1)\n\t\tif w1.Error() != ErrClosing {\n\t\t\tt.Fatalf(\"pool does not close existing wire after Close()\")\n\t\t}\n\t})\n\n\tt.Run(\"Close Waiting\", func(t *testing.T) {\n\t\tpool, count := setup(1)\n\t\tw1 := pool.Acquire()\n\t\tif w1.Error() != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", w1.Error())\n\t\t}\n\t\tpending := int64(0)\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tgo func() {\n\t\t\t\tatomic.AddInt64(&pending, 1)\n\t\t\t\tif rw := pool.Acquire(); rw != dead {\n\t\t\t\t\tt.Errorf(\"pool does not return the dead wire after Close()\")\n\t\t\t\t}\n\t\t\t\tatomic.AddInt64(&pending, -1)\n\t\t\t}()\n\t\t}\n\t\tfor atomic.LoadInt64(&pending) != 100 {\n\t\t\truntime.Gosched()\n\t\t}\n\t\tif atomic.LoadInt32(count) != 1 {\n\t\t\tt.Fatalf(\"pool should not make new wire\")\n\t\t}\n\t\tpool.Close()\n\t\tfor atomic.LoadInt64(&pending) != 0 {\n\t\t\truntime.Gosched()\n\t\t}\n\t\tpool.Store(w1)\n\t\tif w1.Error() != ErrClosing {\n\t\t\tt.Fatalf(\"pool does not close existing wire after Close()\")\n\t\t}\n\t})\n}\n\nfunc TestPoolError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tsetup := func(size int) (*pool, *int32) {\n\t\tvar count int32\n\t\treturn newPool(size, dead, 0, 0, func() wire {\n\t\t\tw := &pipe{}\n\t\t\tw.pshks.Store(emptypshks)\n\t\t\tc := atomic.AddInt32(&count, 1)\n\t\t\tif c%2 == 0 {\n\t\t\t\tw.error.Store(&errs{error: errors.New(\"any\")})\n\t\t\t}\n\t\t\treturn w\n\t\t}), &count\n\t}\n\n\tt.Run(\"NotStoreErrConn\", func(t *testing.T) {\n\t\tconn := make([]wire, 100)\n\t\tpool, count := setup(len(conn))\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tconn[i] = pool.Acquire()\n\t\t}\n\t\tif atomic.LoadInt32(count) != int32(len(conn)) {\n\t\t\tt.Fatalf(\"unexpected acquire count\")\n\t\t}\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tpool.Store(conn[i])\n\t\t}\n\t\tfor i := 0; i < len(conn); i++ {\n\t\t\tconn[i] = pool.Acquire()\n\t\t}\n\t\tif atomic.LoadInt32(count) != int32(len(conn)+len(conn)/2) {\n\t\t\tt.Fatalf(\"unexpected acquire count\")\n\t\t}\n\t})\n}\n\nfunc TestPoolWithIdleTTL(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tsetup := func(size int, ttl time.Duration, minSize int) *pool {\n\t\treturn newPool(size, dead, ttl, minSize, func() wire {\n\t\t\tclosed := false\n\t\t\treturn &mockWire{\n\t\t\t\tCloseFn: func() {\n\t\t\t\t\tclosed = true\n\t\t\t\t},\n\t\t\t\tErrorFn: func() error {\n\t\t\t\t\tif closed {\n\t\t\t\t\t\treturn ErrClosing\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Removing idle conns. Min size is not 0\", func(t *testing.T) {\n\t\tminSize := 3\n\t\tp := setup(0, time.Millisecond*50, minSize)\n\t\tconns := make([]wire, 10)\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tfor i := range conns {\n\t\t\t\tw := p.Acquire()\n\t\t\t\tconns[i] = w\n\t\t\t}\n\n\t\t\tfor _, w := range conns {\n\t\t\t\tp.Store(w)\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Millisecond * 60)\n\t\t\tp.cond.Broadcast()\n\t\t\ttime.Sleep(time.Millisecond * 40)\n\n\t\t\tp.cond.L.Lock()\n\t\t\tif p.size != minSize {\n\t\t\t\tdefer p.cond.L.Unlock()\n\t\t\t\tt.Fatalf(\"size must be equal to %d, actual: %d\", minSize, p.size)\n\t\t\t}\n\n\t\t\tif len(p.list) != minSize {\n\t\t\t\tdefer p.cond.L.Unlock()\n\t\t\t\tt.Fatalf(\"pool len must equal to %d, actual: %d\", minSize, len(p.list))\n\t\t\t}\n\t\t\tp.cond.L.Unlock()\n\t\t}\n\n\t\tp.Close()\n\t})\n\n\tt.Run(\"Removing idle conns. Min size is 0\", func(t *testing.T) {\n\t\tp := setup(0, time.Millisecond*50, 0)\n\t\tconns := make([]wire, 10)\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tfor i := range conns {\n\t\t\t\tw := p.Acquire()\n\t\t\t\tconns[i] = w\n\t\t\t}\n\n\t\t\tfor _, w := range conns {\n\t\t\t\tp.Store(w)\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Millisecond * 60)\n\t\t\tp.cond.Broadcast()\n\t\t\ttime.Sleep(time.Millisecond * 40)\n\n\t\t\tp.cond.L.Lock()\n\t\t\tif p.size != 0 {\n\t\t\t\tdefer p.cond.L.Unlock()\n\t\t\t\tt.Fatalf(\"size must be equal to 0, actual: %d\", p.size)\n\t\t\t}\n\n\t\t\tif len(p.list) != 0 {\n\t\t\t\tdefer p.cond.L.Unlock()\n\t\t\t\tt.Fatalf(\"pool len must equal to 0, actual: %d\", len(p.list))\n\t\t\t}\n\t\t\tp.cond.L.Unlock()\n\t\t}\n\n\t\tp.Close()\n\t})\n}\n"
        },
        {
          "name": "pubsub.go",
          "type": "blob",
          "size": 2.763671875,
          "content": "package rueidis\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// PubSubMessage represent a pubsub message from redis\ntype PubSubMessage struct {\n\t// Pattern is only available with pmessage.\n\tPattern string\n\t// Channel is the channel the message belongs to\n\tChannel string\n\t// Message is the message content\n\tMessage string\n}\n\n// PubSubSubscription represent a pubsub \"subscribe\", \"unsubscribe\", \"psubscribe\" or \"punsubscribe\" event.\ntype PubSubSubscription struct {\n\t// Kind is \"subscribe\", \"unsubscribe\", \"psubscribe\" or \"punsubscribe\"\n\tKind string\n\t// Channel is the event subject.\n\tChannel string\n\t// Count is the current number of subscriptions for connection.\n\tCount int64\n}\n\n// PubSubHooks can be registered into DedicatedClient to process pubsub messages without using Client.Receive\ntype PubSubHooks struct {\n\t// OnMessage will be called when receiving \"message\" and \"pmessage\" event.\n\tOnMessage func(m PubSubMessage)\n\t// OnSubscription will be called when receiving \"subscribe\", \"unsubscribe\", \"psubscribe\" and \"punsubscribe\" event.\n\tOnSubscription func(s PubSubSubscription)\n}\n\nfunc (h *PubSubHooks) isZero() bool {\n\treturn h.OnMessage == nil && h.OnSubscription == nil\n}\n\nfunc newSubs() *subs {\n\treturn &subs{chs: make(map[string]chs), sub: make(map[uint64]*sub)}\n}\n\ntype subs struct {\n\tcnt uint64\n\tchs map[string]chs\n\tsub map[uint64]*sub\n\tmu  sync.RWMutex\n}\n\ntype chs struct {\n\tsub map[uint64]*sub\n}\n\ntype sub struct {\n\tch chan PubSubMessage\n\tcs []string\n}\n\nfunc (s *subs) Publish(channel string, msg PubSubMessage) {\n\tif atomic.LoadUint64(&s.cnt) != 0 {\n\t\ts.mu.RLock()\n\t\tfor _, sb := range s.chs[channel].sub {\n\t\t\tsb.ch <- msg\n\t\t}\n\t\ts.mu.RUnlock()\n\t}\n}\n\nfunc (s *subs) Subscribe(channels []string) (ch chan PubSubMessage, cancel func()) {\n\tid := atomic.AddUint64(&s.cnt, 1)\n\ts.mu.Lock()\n\tif s.chs != nil {\n\t\tch = make(chan PubSubMessage, 16)\n\t\tsb := &sub{cs: channels, ch: ch}\n\t\ts.sub[id] = sb\n\t\tfor _, channel := range channels {\n\t\t\tc := s.chs[channel].sub\n\t\t\tif c == nil {\n\t\t\t\tc = make(map[uint64]*sub, 1)\n\t\t\t\ts.chs[channel] = chs{sub: c}\n\t\t\t}\n\t\t\tc[id] = sb\n\t\t}\n\t\tcancel = func() {\n\t\t\tgo func() {\n\t\t\t\tfor range ch {\n\t\t\t\t}\n\t\t\t}()\n\t\t\ts.mu.Lock()\n\t\t\tif s.chs != nil {\n\t\t\t\ts.remove(id)\n\t\t\t}\n\t\t\ts.mu.Unlock()\n\t\t}\n\t}\n\ts.mu.Unlock()\n\treturn ch, cancel\n}\n\nfunc (s *subs) remove(id uint64) {\n\tif sb := s.sub[id]; sb != nil {\n\t\tfor _, channel := range sb.cs {\n\t\t\tif c := s.chs[channel].sub; c != nil {\n\t\t\t\tdelete(c, id)\n\t\t\t}\n\t\t}\n\t\tclose(sb.ch)\n\t\tdelete(s.sub, id)\n\t}\n}\n\nfunc (s *subs) Unsubscribe(channel string) {\n\tif atomic.LoadUint64(&s.cnt) != 0 {\n\t\ts.mu.Lock()\n\t\tfor id := range s.chs[channel].sub {\n\t\t\ts.remove(id)\n\t\t}\n\t\tdelete(s.chs, channel)\n\t\ts.mu.Unlock()\n\t}\n}\n\nfunc (s *subs) Close() {\n\tvar sbs map[uint64]*sub\n\ts.mu.Lock()\n\tsbs = s.sub\n\ts.chs = nil\n\ts.sub = nil\n\ts.mu.Unlock()\n\tfor _, sb := range sbs {\n\t\tclose(sb.ch)\n\t}\n}\n"
        },
        {
          "name": "pubsub_test.go",
          "type": "blob",
          "size": 1.568359375,
          "content": "package rueidis\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSubs_Publish(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"without subs\", func(t *testing.T) {\n\t\ts := newSubs()\n\t\ts.Publish(\"aa\", PubSubMessage{}) // just no block\n\t})\n\n\tt.Run(\"with multiple subs\", func(t *testing.T) {\n\t\ts := newSubs()\n\t\tch1, cancel1 := s.Subscribe([]string{\"a\"})\n\t\tch2, cancel2 := s.Subscribe([]string{\"a\"})\n\t\tch3, cancel3 := s.Subscribe([]string{\"b\"})\n\t\tm1 := PubSubMessage{Pattern: \"1\", Channel: \"2\", Message: \"3\"}\n\t\tm2 := PubSubMessage{Pattern: \"11\", Channel: \"22\", Message: \"33\"}\n\t\tgo func() {\n\t\t\ts.Publish(\"a\", m1)\n\t\t\ts.Publish(\"b\", m2)\n\t\t}()\n\t\tfor m := range ch1 {\n\t\t\tif m != m1 {\n\t\t\t\tt.Fatalf(\"unexpected msg %v\", m)\n\t\t\t}\n\t\t\tcancel1()\n\t\t}\n\t\tfor m := range ch2 {\n\t\t\tif m != m1 {\n\t\t\t\tt.Fatalf(\"unexpected msg %v\", m)\n\t\t\t}\n\t\t\tcancel2()\n\t\t}\n\t\tfor m := range ch3 {\n\t\t\tif m != m2 {\n\t\t\t\tt.Fatalf(\"unexpected msg %v\", m)\n\t\t\t}\n\t\t\tcancel3()\n\t\t}\n\t})\n\n\tt.Run(\"drain ch\", func(t *testing.T) {\n\t\ts := newSubs()\n\t\tch, cancel := s.Subscribe([]string{\"a\"})\n\t\ts.Publish(\"a\", PubSubMessage{})\n\t\tif len(ch) != 1 {\n\t\t\tt.Fatalf(\"unexpected ch len %v\", len(ch))\n\t\t}\n\t\tcancel()\n\t\tfor ; len(ch) != 0; time.Sleep(time.Millisecond * 100) {\n\t\t\tt.Log(\"wait ch to be drain\")\n\t\t}\n\t})\n}\n\nfunc TestSubs_Unsubscribe(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ts := newSubs()\n\tch, _ := s.Subscribe([]string{\"1\", \"2\"})\n\tgo func() {\n\t\ts.Publish(\"1\", PubSubMessage{})\n\t}()\n\t_, ok := <-ch\n\tif !ok {\n\t\tt.Fatalf(\"unexpected ch closed\")\n\t}\n\ts.Unsubscribe(\"1\")\n\t_, ok = <-ch\n\tif ok {\n\t\tt.Fatalf(\"unexpected ch unclosed\")\n\t}\n}\n"
        },
        {
          "name": "redis_test.go",
          "type": "blob",
          "size": 27.8505859375,
          "content": "package rueidis\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc parallel(p int) (chan func(), func()) {\n\tch := make(chan func(), p)\n\twg := sync.WaitGroup{}\n\twg.Add(p)\n\tfor i := 0; i < p; i++ {\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\trecover()\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\tfor fn := range ch {\n\t\t\t\tfn()\n\t\t\t}\n\t\t}()\n\t}\n\treturn ch, func() {\n\t\tclose(ch)\n\t\twg.Wait()\n\t}\n}\n\nfunc testFlush(t *testing.T, client Client) {\n\tctx := context.Background()\n\n\tkeys := 1000\n\tpara := 8\n\n\tkvs := make(map[string]string, keys)\n\tfor i := 0; i < keys; i++ {\n\t\tkvs[strconv.Itoa(i)] = strconv.FormatInt(rand.Int63(), 10)\n\t}\n\n\tt.Logf(\"prepare %d keys for FLUSH\\n\", keys)\n\tjobs, wait := parallel(para)\n\tfor i := 0; i < keys; i++ {\n\t\tkey := strconv.Itoa(i)\n\t\tjobs <- func() {\n\t\t\tval, err := client.Do(ctx, client.B().Set().Key(key).Value(kvs[key]).Build()).ToString()\n\t\t\tif err != nil || val != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected set response %v %v\", val, err)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing client side caching before flush\\n\")\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys; i++ {\n\t\tkey := strconv.Itoa(i)\n\t\tjobs <- func() {\n\t\t\tresp := client.DoCache(ctx, client.B().Get().Key(key).Cache(), time.Minute)\n\t\t\tval, err := resp.ToString()\n\t\t\tif val != kvs[key] {\n\t\t\t\tt.Fatalf(\"unexpected csc get response %v %v\", val, err)\n\t\t\t}\n\t\t\tif resp.IsCacheHit() {\n\t\t\t\tt.Fatalf(\"unexpected csc cache hit\")\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tif err := client.Do(ctx, client.B().Flushall().Build()).Error(); err != nil {\n\t\tt.Fatalf(\"unexpected flush err %v\", err)\n\t}\n\n\ttime.Sleep(time.Second)\n\n\tt.Logf(\"testing client side caching after flush\\n\")\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys; i++ {\n\t\tkey := strconv.Itoa(i)\n\t\tjobs <- func() {\n\t\t\tresp := client.DoCache(ctx, client.B().Get().Key(key).Cache(), time.Minute)\n\t\t\tif !IsRedisNil(resp.Error()) {\n\t\t\t\tt.Fatalf(\"unexpected csc get response after flush %v\", resp)\n\t\t\t}\n\t\t\tif resp.IsCacheHit() {\n\t\t\t\tt.Fatalf(\"unexpected csc cache hit after flush\")\n\t\t\t}\n\t\t}\n\t}\n\twait()\n}\n\nfunc testSETGETCSC(t *testing.T, client Client) {\n\ttestSETGET(t, client, true)\n}\n\nfunc testSETGETRESP2(t *testing.T, client Client) {\n\ttestSETGET(t, client, false)\n}\n\n//gocyclo:ignore\nfunc testSETGET(t *testing.T, client Client, csc bool) {\n\tctx := context.Background()\n\tkeys := 10000\n\tpara := 8\n\n\tkvs := make(map[string]string, keys)\n\tfor i := 0; i < keys; i++ {\n\t\tkvs[strconv.Itoa(i)] = strconv.FormatInt(rand.Int63(), 10)\n\t}\n\n\tt.Logf(\"testing SET with %d keys and %d parallelism\\n\", keys, para)\n\tjobs, wait := parallel(para)\n\tfor i := 0; i < keys; i++ {\n\t\tkey := strconv.Itoa(i)\n\t\tjobs <- func() {\n\t\t\tval, err := client.Do(ctx, client.B().Set().Key(key).Value(kvs[key]).Build()).ToString()\n\t\t\tif err != nil || val != \"OK\" {\n\t\t\t\tt.Errorf(\"unexpected set response %v %v\", val, err)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing GET with %d keys and %d parallelism\\n\", keys*2, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*2; i++ {\n\t\tkey := strconv.Itoa(rand.Intn(keys * 2))\n\t\tjobs <- func() {\n\t\t\tval, err := client.Do(ctx, client.B().Get().Key(key).Build()).ToString()\n\t\t\tif v, ok := kvs[key]; !((ok && val == v) || (!ok && IsRedisNil(err))) {\n\t\t\t\tt.Errorf(\"unexpected get response %v %v %v\", val, err, ok)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing stream GET with %d keys and %d parallelism\\n\", keys*2, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*2; i++ {\n\t\tkey := strconv.Itoa(rand.Intn(keys * 2))\n\t\tjobs <- func() {\n\t\t\ts := client.DoStream(ctx, client.B().Get().Key(key).Build())\n\t\t\tbuf := bytes.NewBuffer(nil)\n\t\t\tn, err := s.WriteTo(buf)\n\t\t\tif v, ok := kvs[key]; !((ok && buf.String() == v && n == int64(buf.Len())) || (!ok && IsRedisNil(err))) {\n\t\t\t\tt.Errorf(\"unexpected get response %v %v %v\", buf.String(), err, ok)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing GET with %d keys and %d parallelism with timeout\\n\", keys*100, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*100; i++ {\n\t\tkey := strconv.Itoa(rand.Intn(keys))\n\t\tjobs <- func() {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)\n\t\t\tdefer cancel()\n\t\t\tval, err := client.Do(ctx, client.B().Get().Key(key).Build()).ToString()\n\t\t\tif !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\tif v, ok := kvs[key]; !((ok && val == v) || (!ok && IsRedisNil(err))) {\n\t\t\t\t\tt.Errorf(\"unexpected get response %v %v %v\", val, err, ok)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing client side caching with %d interations and %d parallelism\\n\", keys*5, para)\n\tjobs, wait = parallel(para)\n\thits, miss := int64(0), int64(0)\n\tfor i := 0; i < keys*10; i++ {\n\t\tkey := strconv.Itoa(rand.Intn(keys / 100))\n\t\tjobs <- func() {\n\t\t\tresp := client.DoCache(ctx, client.B().Get().Key(key).Cache(), time.Minute)\n\t\t\tval, err := resp.ToString()\n\t\t\tif v, ok := kvs[key]; !((ok && val == v) || (!ok && IsRedisNil(err))) {\n\t\t\t\tt.Errorf(\"unexpected csc get response %v %v %v\", val, err, ok)\n\t\t\t}\n\t\t\tif resp.IsCacheHit() {\n\t\t\t\tatomic.AddInt64(&hits, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt64(&miss, 1)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\tif csc {\n\t\tif atomic.LoadInt64(&miss) != 100 || atomic.LoadInt64(&hits) != int64(keys*10-100) {\n\t\t\tt.Fatalf(\"unexpected client side caching hits and miss %v %v\", atomic.LoadInt64(&hits), atomic.LoadInt64(&miss))\n\t\t}\n\t} else {\n\t\tif atomic.LoadInt64(&hits) != 0 {\n\t\t\tt.Fatalf(\"unexpected client side caching hits and miss %v %v\", atomic.LoadInt64(&hits), atomic.LoadInt64(&miss))\n\t\t}\n\t}\n\n\tt.Logf(\"testing DEL with %d keys and %d parallelism\\n\", keys*2, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*2; i++ {\n\t\tkey := strconv.Itoa(i)\n\t\tjobs <- func() {\n\t\t\tval, err := client.Do(ctx, client.B().Del().Key(key).Build()).AsInt64()\n\t\t\tif _, ok := kvs[key]; !((val == 1 && ok) || (val == 0 && !ok)) {\n\t\t\t\tt.Errorf(\"unexpected del response %v %v %v\", val, err, ok)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\ttime.Sleep(time.Second)\n\n\tt.Logf(\"testing client side caching after delete\\n\")\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys/100; i++ {\n\t\tkey := strconv.Itoa(i)\n\t\tjobs <- func() {\n\t\t\tresp := client.DoCache(ctx, client.B().Get().Key(key).Cache(), time.Minute)\n\t\t\tif !IsRedisNil(resp.Error()) {\n\t\t\t\tt.Errorf(\"unexpected csc get response after delete %v\", resp)\n\t\t\t}\n\t\t\tif resp.IsCacheHit() {\n\t\t\t\tt.Errorf(\"unexpected csc cache hit after delete\")\n\t\t\t}\n\t\t}\n\t}\n\twait()\n}\n\nfunc testMultiSETGETCSC(t *testing.T, client Client) {\n\ttestMultiSETGET(t, client, true)\n}\n\nfunc testMultiSETGETRESP2(t *testing.T, client Client) {\n\ttestMultiSETGET(t, client, false)\n}\n\nfunc testMultiSETGETCSCHelpers(t *testing.T, client Client) {\n\ttestMultiSETGETHelpers(t, client, true)\n}\n\nfunc testMultiSETGETRESP2Helpers(t *testing.T, client Client) {\n\ttestMultiSETGETHelpers(t, client, false)\n}\n\n//gocyclo:ignore\nfunc testMultiSETGET(t *testing.T, client Client, csc bool) {\n\tctx := context.Background()\n\tkeys := 10000\n\tbatch := 100\n\tpara := 8\n\n\tkvs := make(map[string]string, keys)\n\tfor i := 0; i < keys; i++ {\n\t\tkvs[\"m\"+strconv.Itoa(i)] = strconv.FormatInt(rand.Int63(), 10)\n\t}\n\n\tt.Logf(\"testing Multi SET with %d keys and %d parallelism\\n\", keys, para)\n\tjobs, wait := parallel(para)\n\tfor i := 0; i < keys; i += batch {\n\t\tcommands := make(Commands, 0, batch)\n\t\tfor j := 0; j < batch; j++ {\n\t\t\tkey := \"m\" + strconv.Itoa(i+j)\n\t\t\tcommands = append(commands, client.B().Set().Key(key).Value(kvs[key]).Build())\n\t\t}\n\t\tjobs <- func() {\n\t\t\tfor _, resp := range client.DoMulti(ctx, commands...) {\n\t\t\t\tval, err := resp.ToString()\n\t\t\t\tif err != nil || val != \"OK\" {\n\t\t\t\t\tt.Fatalf(\"unexpected set response %v %v\", val, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing GET with %d keys and %d parallelism\\n\", keys*2, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*2; i += batch {\n\t\tcmdkeys := make([]string, 0, batch)\n\t\tcommands := make(Commands, 0, batch)\n\t\tfor j := 0; j < batch; j++ {\n\t\t\tcmdkeys = append(cmdkeys, \"m\"+strconv.Itoa(rand.Intn(keys*2)))\n\t\t\tcommands = append(commands, client.B().Get().Key(cmdkeys[len(cmdkeys)-1]).Build())\n\t\t}\n\t\tjobs <- func() {\n\t\t\tfor j, resp := range client.DoMulti(ctx, commands...) {\n\t\t\t\tval, err := resp.ToString()\n\t\t\t\tif v, ok := kvs[cmdkeys[j]]; !((ok && val == v) || (!ok && IsRedisNil(err))) {\n\t\t\t\t\tt.Fatalf(\"unexpected get response %v %v %v\", val, err, ok)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing GET with %d keys and %d parallelism with timeout\\n\", keys*100, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*100; i += batch {\n\t\tcmdkeys := make([]string, 0, batch)\n\t\tcommands := make(Commands, 0, batch)\n\t\tfor j := 0; j < batch; j++ {\n\t\t\tcmdkeys = append(cmdkeys, \"m\"+strconv.Itoa(rand.Intn(keys)))\n\t\t\tcommands = append(commands, client.B().Get().Key(cmdkeys[len(cmdkeys)-1]).Build())\n\t\t}\n\t\tjobs <- func() {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond)\n\t\t\tdefer cancel()\n\t\t\tfor j, resp := range client.DoMulti(ctx, commands...) {\n\t\t\t\tval, err := resp.ToString()\n\t\t\t\tif !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t\t\t\tif v, ok := kvs[cmdkeys[j]]; !((ok && val == v) || (!ok && IsRedisNil(err))) {\n\t\t\t\t\t\tt.Fatalf(\"unexpected get response %v %v %v\", val, err, ok)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\tt.Logf(\"testing client side caching with %d interations and %d parallelism\\n\", keys*5, para)\n\tjobs, wait = parallel(para)\n\thits, miss := int64(0), int64(0)\n\tfor i := 0; i < keys*10; i += batch {\n\t\tcmdkeys := make([]string, 0, batch)\n\t\tcommands := make([]CacheableTTL, 0, batch)\n\t\tfor j := 0; j < batch; j++ {\n\t\t\tcmdkeys = append(cmdkeys, \"m\"+strconv.Itoa(rand.Intn(keys/100)))\n\t\t\tcommands = append(commands, CT(client.B().Get().Key(cmdkeys[len(cmdkeys)-1]).Cache(), time.Minute))\n\t\t}\n\t\tjobs <- func() {\n\t\t\tfor j, resp := range client.DoMultiCache(ctx, commands...) {\n\t\t\t\tval, err := resp.ToString()\n\t\t\t\tif v, ok := kvs[cmdkeys[j]]; !((ok && val == v) || (!ok && IsRedisNil(err))) {\n\t\t\t\t\tt.Fatalf(\"unexpected csc get response %v %v %v\", val, err, ok)\n\t\t\t\t}\n\t\t\t\tif resp.IsCacheHit() {\n\t\t\t\t\tatomic.AddInt64(&hits, 1)\n\t\t\t\t} else {\n\t\t\t\t\tatomic.AddInt64(&miss, 1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\tif csc {\n\t\tif atomic.LoadInt64(&miss) != 100 || atomic.LoadInt64(&hits) != int64(keys*10-100) {\n\t\t\tt.Fatalf(\"unexpected client side caching hits and miss %v %v\", atomic.LoadInt64(&hits), atomic.LoadInt64(&miss))\n\t\t}\n\t} else {\n\t\tif atomic.LoadInt64(&hits) != 0 {\n\t\t\tt.Fatalf(\"unexpected client side caching hits and miss %v %v\", atomic.LoadInt64(&hits), atomic.LoadInt64(&miss))\n\t\t}\n\t}\n\n\tt.Logf(\"testing DEL with %d keys and %d parallelism\\n\", keys*2, para)\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys*2; i += batch {\n\t\tcmdkeys := make([]string, 0, batch)\n\t\tcommands := make(Commands, 0, batch)\n\t\tfor j := 0; j < batch; j++ {\n\t\t\tcmdkeys = append(cmdkeys, \"m\"+strconv.Itoa(i+j))\n\t\t\tcommands = append(commands, client.B().Del().Key(cmdkeys[len(cmdkeys)-1]).Build())\n\t\t}\n\t\tjobs <- func() {\n\t\t\tfor j, resp := range client.DoMulti(ctx, commands...) {\n\t\t\t\tval, err := resp.AsInt64()\n\t\t\t\tif _, ok := kvs[cmdkeys[j]]; !((val == 1 && ok) || (val == 0 && !ok)) {\n\t\t\t\t\tt.Fatalf(\"unexpected del response %v %v %v\", val, err, ok)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n\n\ttime.Sleep(time.Second)\n\n\tt.Logf(\"testing client side caching after delete\\n\")\n\tjobs, wait = parallel(para)\n\tfor i := 0; i < keys/100; i += batch {\n\t\tcmdkeys := make([]string, 0, batch)\n\t\tcommands := make([]CacheableTTL, 0, batch)\n\t\tfor j := 0; j < batch; j++ {\n\t\t\tcmdkeys = append(cmdkeys, \"m\"+strconv.Itoa(i+j))\n\t\t\tcommands = append(commands, CT(client.B().Get().Key(cmdkeys[len(cmdkeys)-1]).Cache(), time.Minute))\n\t\t}\n\t\tjobs <- func() {\n\t\t\tfor _, resp := range client.DoMultiCache(ctx, commands...) {\n\t\t\t\tif !IsRedisNil(resp.Error()) {\n\t\t\t\t\tt.Fatalf(\"unexpected csc get response after delete %v\", resp)\n\t\t\t\t}\n\t\t\t\tif resp.IsCacheHit() {\n\t\t\t\t\tt.Fatalf(\"unexpected csc cache hit after delete\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait()\n}\n\nfunc testMultiSETGETHelpers(t *testing.T, client Client, csc bool) {\n\tctx := context.Background()\n\tkeys := 10000\n\n\tkvs := make(map[string]string, keys)\n\tfor i := 0; i < keys; i++ {\n\t\tkvs[\"z\"+strconv.Itoa(i)] = strconv.FormatInt(rand.Int63(), 10)\n\t}\n\n\tt.Logf(\"testing Multi SET with %d keys\\n\", keys)\n\tfor _, err := range MSet(client, ctx, kvs) {\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\\n\", err)\n\t\t}\n\t}\n\n\tt.Logf(\"testing GET with %d keys\\n\", keys*2)\n\tcmdKeys := make([]string, keys*2)\n\tfor i := 0; i < len(cmdKeys); i++ {\n\t\tcmdKeys[i] = \"z\" + strconv.Itoa(i)\n\t}\n\tvalidate := func(resp map[string]RedisMessage) {\n\t\tfor _, key := range cmdKeys {\n\t\t\tret, ok := resp[key]\n\t\t\tif !ok {\n\t\t\t\tt.Fatalf(\"unexpected result %v not found\\n\", key)\n\t\t\t}\n\t\t\tif exp, ok := kvs[key]; ok {\n\t\t\t\tif exp != ret.string {\n\t\t\t\t\tt.Fatalf(\"unexpected result %v wrong value %v\\n\", key, exp)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !ret.IsNil() {\n\t\t\t\t\tt.Fatalf(\"unexpected result %v wrong value %v\\n\", key, \"nil\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tresp, err := MGet(client, ctx, cmdKeys)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\\n\", err)\n\t}\n\tvalidate(resp)\n\n\tt.Logf(\"testing client side caching with %d keys\\n\", keys*2)\n\tresp, err = MGetCache(client, ctx, time.Minute, cmdKeys)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\\n\", err)\n\t}\n\tvalidate(resp)\n\tfor _, ret := range resp {\n\t\tif ret.IsCacheHit() {\n\t\t\tt.Fatalf(\"unexpeceted cache hit %v\\n\", ret)\n\t\t}\n\t}\n\tresp, err = MGetCache(client, ctx, time.Minute, cmdKeys)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\\n\", err)\n\t}\n\tvalidate(resp)\n\tfor _, ret := range resp {\n\t\tif csc && !ret.IsCacheHit() {\n\t\t\tt.Fatalf(\"unexpeceted cache miss %v\\n\", ret)\n\t\t}\n\t}\n\n\tt.Logf(\"testing DEL with %d keys\\n\", keys*2)\n\tfor _, err := range MDel(client, ctx, cmdKeys) {\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\\n\", err)\n\t\t}\n\t}\n\n\ttime.Sleep(time.Second)\n\n\tt.Logf(\"testing client side caching after delete\\n\")\n\tresp, err = MGetCache(client, ctx, time.Minute, cmdKeys)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\\n\", err)\n\t}\n\tfor _, ret := range resp {\n\t\tif !ret.IsNil() {\n\t\t\tt.Fatalf(\"unexpeceted cache hit %v\\n\", ret)\n\t\t}\n\t}\n}\n\n//gocyclo:ignore\nfunc testMultiExec(t *testing.T, client Client) {\n\tctx := context.Background()\n\tkeys := 1000\n\tpara := 8\n\n\tkvs := make(map[string]int64, keys)\n\tfor i := 1; i <= keys; i++ {\n\t\tkvs[\"me\"+strconv.Itoa(i)] = int64(i)\n\t}\n\n\tt.Logf(\"testing MULTI EXEC with %d keys and %d parallelism\\n\", keys, para)\n\tjobs, wait := parallel(para)\n\tfor k, v := range kvs {\n\t\tk, v := k, v\n\t\tjobs <- func() {\n\t\t\tresps, err := client.DoMulti(ctx,\n\t\t\t\tclient.B().Multi().Build(),\n\t\t\t\tclient.B().Set().Key(k).Value(strconv.FormatInt(v, 10)).ExSeconds(v).Build(),\n\t\t\t\tclient.B().Ttl().Key(k).Build(),\n\t\t\t\tclient.B().Get().Key(k).Build(),\n\t\t\t\tclient.B().Exec().Build(),\n\t\t\t)[4].ToArray()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected exec response %v\", err)\n\t\t\t}\n\t\t\tif resps[1].integer != v {\n\t\t\t\tt.Fatalf(\"unexpected ttl response %v %v\", v, resps[1].integer)\n\t\t\t}\n\t\t\tif resps[2].string != strconv.FormatInt(v, 10) {\n\t\t\t\tt.Fatalf(\"unexpected get response %v %v\", v, resps[2].string)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n}\n\nfunc testBlockingZPOP(t *testing.T, client Client) {\n\tctx := context.Background()\n\tkey := \"bz_pop_test\"\n\titems := 2000\n\n\tclient.Do(ctx, client.B().Del().Key(key).Build())\n\n\tt.Logf(\"testing BZPOPMIN blocking concurrently with ZADD with %d items\\n\", items)\n\tgo func() {\n\t\tfor i := 0; i < items; i++ {\n\t\t\tv, err := client.Do(ctx, client.B().Zadd().Key(key).ScoreMember().ScoreMember(float64(i), strconv.Itoa(i)).Build()).AsInt64()\n\t\t\tif err != nil || v != 1 {\n\t\t\t\tt.Errorf(\"unexpected ZADD response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t}()\n\tfor i := 0; i < items; i++ {\n\t\tarr, err := client.Do(ctx, client.B().Bzpopmin().Key(key).Timeout(0).Build()).AsStrSlice()\n\t\tif err != nil || (arr[0] != key || arr[1] != arr[2] || arr[1] != strconv.Itoa(i)) {\n\t\t\tt.Fatalf(\"unexpected BZPOPMIN response %v %v\", arr, err)\n\t\t}\n\t}\n\tclient.Do(ctx, client.B().Del().Key(key).Build())\n}\n\nfunc testBlockingXREAD(t *testing.T, client Client) {\n\tctx := context.Background()\n\tkey := \"xread_test\"\n\titems := 2000\n\n\tclient.Do(ctx, client.B().Del().Key(key).Build())\n\n\tt.Logf(\"testing blocking XREAD concurrently with XADD with %d items\\n\", items)\n\tgo func() {\n\t\tfor i := 0; i < items; i++ {\n\t\t\tv := strconv.Itoa(i)\n\t\t\tv, err := client.Do(ctx, client.B().Xadd().Key(key).Id(\"*\").FieldValue().FieldValue(v, v).Build()).ToString()\n\t\t\tif err != nil || v == \"\" {\n\t\t\t\tt.Errorf(\"unexpected XADD response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t}()\n\tid := \"0\"\n\tfor i := 0; i < items; i++ {\n\t\tm, err := client.Do(ctx, client.B().Xread().Count(1).Block(0).Streams().Key(key).Id(id).Build()).AsXRead()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected XREAD response %v %v\", m, err)\n\t\t}\n\t\tid = m[key][0].ID\n\t\tif len(m[key][0].FieldValues) == 0 {\n\t\t\tt.Fatalf(\"unexpected XREAD response %v %v\", m, err)\n\t\t}\n\t\tfor f, v := range m[key][0].FieldValues {\n\t\t\tif f != v || f != strconv.Itoa(i) {\n\t\t\t\tt.Fatalf(\"unexpected XREAD response %v %v\", m, err)\n\t\t\t}\n\t\t}\n\t}\n\tclient.Do(ctx, client.B().Del().Key(key).Build())\n}\n\nfunc testPubSub(t *testing.T, client Client) {\n\tmsgs := 5000\n\tmmap := make(map[string]struct{})\n\tfor i := 0; i < msgs; i++ {\n\t\tmmap[strconv.Itoa(i)] = struct{}{}\n\t}\n\tt.Logf(\"testing pubsub with %v messages\\n\", msgs)\n\tjobs, wait := parallel(10)\n\n\tctx := context.Background()\n\n\tmessages := make(chan string, 10)\n\n\twg := sync.WaitGroup{}\n\twg.Add(2)\n\tgo func() {\n\t\terr := client.Receive(ctx, client.B().Subscribe().Channel(\"ch1\").Build(), func(msg PubSubMessage) {\n\t\t\tmessages <- msg.Message\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected subscribe response %v\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\terr := client.Receive(ctx, client.B().Psubscribe().Pattern(\"pat*\").Build(), func(msg PubSubMessage) {\n\t\t\tmessages <- msg.Message\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected subscribe response %v\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\tfor i := 0; i < msgs; i++ {\n\t\t\tmsg := strconv.Itoa(i)\n\t\t\tch := \"ch1\"\n\t\t\tif i%10 == 0 {\n\t\t\t\tch = \"pat1\"\n\t\t\t}\n\t\t\tjobs <- func() {\n\t\t\t\tif err := client.Do(context.Background(), client.B().Publish().Channel(ch).Message(msg).Build()).Error(); err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected publish response %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twait()\n\t}()\n\n\tfor message := range messages {\n\t\tdelete(mmap, message)\n\t\tif len(mmap) == 0 {\n\t\t\tclose(messages)\n\t\t}\n\t}\n\n\tfor _, c := range client.Nodes() {\n\t\tfor _, resp := range c.DoMulti(context.Background(),\n\t\t\tclient.B().Unsubscribe().Channel(\"ch1\").Build(),\n\t\t\tclient.B().Punsubscribe().Pattern(\"pat*\").Build()) {\n\t\t\tif err := resp.Error(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n\twg.Wait()\n\n\tt.Logf(\"testing pubsub hooks with 500 messages\\n\")\n\n\tfor i := 0; i < 500; i++ {\n\t\tcc, cancel := client.Dedicate()\n\t\tmsg := strconv.Itoa(i)\n\t\tch := cc.SetPubSubHooks(PubSubHooks{\n\t\t\tOnMessage: func(m PubSubMessage) {\n\t\t\t\tcc.SetPubSubHooks(PubSubHooks{})\n\t\t\t},\n\t\t})\n\t\tif err := cc.Do(context.Background(), client.B().Subscribe().Channel(\"ch2\").Build()).Error(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := client.Do(context.Background(), client.B().Publish().Channel(\"ch2\").Message(msg).Build()).Error(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := <-ch; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tcancel()\n\t}\n}\n\nfunc testPubSubSharded(t *testing.T, client Client) {\n\tmsgs := 5000\n\tmmap := make(map[string]struct{})\n\tfor i := 0; i < msgs; i++ {\n\t\tmmap[strconv.Itoa(i)] = struct{}{}\n\t}\n\tt.Logf(\"testing pubsub with %v messages\\n\", msgs)\n\tjobs, wait := parallel(10)\n\n\tctx := context.Background()\n\n\tmessages := make(chan string, 10)\n\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\tgo func() {\n\t\terr := client.Receive(ctx, client.B().Ssubscribe().Channel(\"ch1\").Build(), func(msg PubSubMessage) {\n\t\t\tmessages <- msg.Message\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"unexpected subscribe response %v\", err)\n\t\t}\n\t\twg.Done()\n\t}()\n\n\tgo func() {\n\t\ttime.Sleep(time.Second)\n\t\tfor i := 0; i < msgs; i++ {\n\t\t\tmsg := strconv.Itoa(i)\n\t\t\tch := \"ch1\"\n\t\t\tjobs <- func() {\n\t\t\t\tif err := client.Do(context.Background(), client.B().Spublish().Channel(ch).Message(msg).Build()).Error(); err != nil {\n\t\t\t\t\tt.Errorf(\"unexpected publish response %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twait()\n\t}()\n\n\tfor message := range messages {\n\t\tdelete(mmap, message)\n\t\tif len(mmap) == 0 {\n\t\t\tclose(messages)\n\t\t}\n\t}\n\n\tfor _, resp := range client.DoMulti(context.Background(),\n\t\tclient.B().Sunsubscribe().Channel(\"ch1\").Build()) {\n\t\tif err := resp.Error(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\twg.Wait()\n\n\tt.Logf(\"testing pubsub hooks with 500 messages\\n\")\n\n\tfor i := 0; i < 500; i++ {\n\t\tcc, cancel := client.Dedicate()\n\t\tmsg := strconv.Itoa(i)\n\t\tch := cc.SetPubSubHooks(PubSubHooks{\n\t\t\tOnMessage: func(m PubSubMessage) {\n\t\t\t\tcc.SetPubSubHooks(PubSubHooks{})\n\t\t\t},\n\t\t})\n\t\tif err := cc.Do(context.Background(), client.B().Ssubscribe().Channel(\"ch2\").Build()).Error(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := client.Do(context.Background(), client.B().Spublish().Channel(\"ch2\").Message(msg).Build()).Error(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := <-ch; err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tcancel()\n\t}\n}\n\nfunc testLua(t *testing.T, client Client) {\n\tscript := NewLuaScript(\"return {KEYS[1],ARGV[1]}\")\n\n\tkeys := 1000\n\tpara := 4\n\tkvs := make(map[string]string, keys)\n\tfor i := 0; i < keys; i++ {\n\t\tkvs[\"m\"+strconv.Itoa(i)] = strconv.FormatInt(rand.Int63(), 10)\n\t}\n\n\tt.Logf(\"testing lua with %d keys and %d parallelism\\n\", keys, para)\n\tjobs, wait := parallel(para)\n\tfor k, v := range kvs {\n\t\tk := k\n\t\tv := v\n\t\tjobs <- func() {\n\t\t\tval, err := script.Exec(context.Background(), client, []string{k}, []string{v}).AsStrSlice()\n\t\t\tif err != nil || !reflect.DeepEqual(val, []string{k, v}) {\n\t\t\t\tt.Fatalf(\"unexpected lua response %v %v\", val, err)\n\t\t\t}\n\t\t}\n\t}\n\twait()\n}\n\nfunc run(t *testing.T, client Client, cases ...func(*testing.T, Client)) {\n\twg := sync.WaitGroup{}\n\twg.Add(len(cases))\n\tfor _, c := range cases {\n\t\tc := c\n\t\tgo func() {\n\t\t\tc(t, client)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestSingleClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:6379\"},\n\t\tConnWriteTimeout:  180 * time.Second,\n\t\tPipelineMultiplex: 1,\n\n\t\tDisableAutoPipelining: os.Getenv(\"DisableAutoPipelining\") == \"true\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETCSC, testMultiSETGETCSC, testMultiSETGETCSCHelpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testPubSubSharded, testLua)\n\trun(t, client, testFlush)\n\n\tclient.Close()\n}\n\nfunc TestSingleClientIntegrationWithPool(t *testing.T) {\n\tos.Setenv(\"DisableAutoPipelining\", \"true\")\n\tdefer os.Unsetenv(\"DisableAutoPipelining\")\n\tTestSingleClientIntegration(t)\n}\n\nfunc TestSentinelClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:      []string{\"127.0.0.1:26379\"},\n\t\tConnWriteTimeout: 180 * time.Second,\n\t\tSentinel: SentinelOption{\n\t\t\tMasterSet: \"test\",\n\t\t},\n\t\tSelectDB:          2, // https://github.com/redis/rueidis/issues/138\n\t\tPipelineMultiplex: 1,\n\n\t\tDisableAutoPipelining: os.Getenv(\"DisableAutoPipelining\") == \"true\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETCSC, testMultiSETGETCSC, testMultiSETGETCSCHelpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testPubSubSharded, testLua)\n\trun(t, client, testFlush)\n\n\tclient.Close()\n}\n\nfunc TestSentinelClientIntegrationWithPool(t *testing.T) {\n\tos.Setenv(\"DisableAutoPipelining\", \"true\")\n\tdefer os.Unsetenv(\"DisableAutoPipelining\")\n\tTestSentinelClientIntegration(t)\n}\n\nfunc TestClusterClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:7001\", \"127.0.0.1:7002\", \"127.0.0.1:7003\"},\n\t\tConnWriteTimeout:  180 * time.Second,\n\t\tShuffleInit:       true,\n\t\tDialer:            net.Dialer{KeepAlive: -1},\n\t\tPipelineMultiplex: 1,\n\n\t\tDisableAutoPipelining: os.Getenv(\"DisableAutoPipelining\") == \"true\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trun(t, client, testSETGETCSC, testMultiSETGETCSC, testMultiSETGETCSCHelpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testPubSubSharded, testLua)\n\n\tclient.Close()\n}\n\nfunc TestClusterClientIntegrationWithPool(t *testing.T) {\n\tos.Setenv(\"DisableAutoPipelining\", \"true\")\n\tdefer os.Unsetenv(\"DisableAutoPipelining\")\n\tTestClusterClientIntegration(t)\n}\n\nfunc TestSingleClient5Integration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:6355\"},\n\t\tConnWriteTimeout:  180 * time.Second,\n\t\tDisableCache:      true,\n\t\tPipelineMultiplex: 1,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETRESP2, testMultiSETGETRESP2, testMultiSETGETRESP2Helpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testLua)\n\n\tclient.Close()\n}\n\nfunc TestCluster5ClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:7004\", \"127.0.0.1:7005\", \"127.0.0.1:7006\"},\n\t\tConnWriteTimeout:  180 * time.Second,\n\t\tShuffleInit:       true,\n\t\tDisableCache:      true,\n\t\tDialer:            net.Dialer{KeepAlive: -1},\n\t\tPipelineMultiplex: 1,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trun(t, client, testSETGETRESP2, testMultiSETGETRESP2, testMultiSETGETRESP2Helpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testLua)\n\n\tclient.Close()\n}\n\nfunc TestSentinel5ClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:      []string{\"127.0.0.1:26355\"},\n\t\tConnWriteTimeout: 180 * time.Second,\n\t\tDisableCache:     true,\n\t\tSentinel: SentinelOption{\n\t\t\tMasterSet: \"test5\",\n\t\t},\n\t\tPipelineMultiplex: 1,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETRESP2, testMultiSETGETRESP2, testMultiSETGETRESP2Helpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testLua)\n\n\tclient.Close()\n}\n\nfunc TestKeyDBSingleClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:6344\"},\n\t\tConnWriteTimeout:  180 * time.Second,\n\t\tPipelineMultiplex: 1,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETCSC, testMultiSETGETCSC, testMultiSETGETCSCHelpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testLua)\n\trun(t, client, testFlush)\n\n\tclient.Close()\n}\n\nfunc TestDragonflyDBSingleClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:      []string{\"127.0.0.1:6333\"},\n\t\tConnWriteTimeout: 180 * time.Second,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETCSC, testMultiSETGETCSC, testMultiSETGETCSCHelpers, testMultiExec, testBlockingZPOP, testBlockingXREAD, testPubSub, testLua)\n\trun(t, client, testFlush)\n\n\tclient.Close()\n}\n\nfunc TestKvrocksSingleClientIntegration(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip()\n\t}\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:      []string{\"127.0.0.1:6666\"},\n\t\tConnWriteTimeout: 180 * time.Second,\n\t\tDisableCache:     true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trun(t, client, testSETGETRESP2, testMultiSETGETRESP2, testMultiSETGETRESP2Helpers, testPubSub, testLua)\n\trun(t, client, testFlush)\n\n\tclient.Close()\n}\n\nfunc TestNegativeConnWriteTimeout(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:      []string{\"127.0.0.1:6379\"},\n\t\tConnWriteTimeout: -1,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient.Close()\n}\n\nfunc TestNegativeKeepalive(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:6379\"},\n\t\tDialer:      net.Dialer{KeepAlive: -1},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient.Close()\n}\n\nfunc TestNegativeConnWriteTimeoutKeepalive(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:      []string{\"127.0.0.1:6379\"},\n\t\tDialer:           net.Dialer{KeepAlive: -1},\n\t\tConnWriteTimeout: -1,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclient.Close()\n}\n"
        },
        {
          "name": "resp.go",
          "type": "blob",
          "size": 8.8046875,
          "content": "package rueidis\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar errChunked = errors.New(\"unbounded redis message\")\nvar errOldNull = errors.New(\"RESP2 null\")\n\nconst (\n\ttypeBlobString     = byte('$')\n\ttypeSimpleString   = byte('+')\n\ttypeSimpleErr      = byte('-')\n\ttypeInteger        = byte(':')\n\ttypeNull           = byte('_')\n\ttypeEnd            = byte('.')\n\ttypeFloat          = byte(',')\n\ttypeBool           = byte('#')\n\ttypeBlobErr        = byte('!')\n\ttypeVerbatimString = byte('=')\n\ttypeBigNumber      = byte('(')\n\ttypeArray          = byte('*')\n\ttypeMap            = byte('%')\n\ttypeSet            = byte('~')\n\ttypeAttribute      = byte('|')\n\ttypePush           = byte('>')\n\ttypeChunk          = byte(';')\n)\n\nvar typeNames = make(map[byte]string, 16)\n\ntype reader func(i *bufio.Reader) (RedisMessage, error)\n\nvar readers = [256]reader{}\n\nfunc init() {\n\treaders[typeBlobString] = readBlobString\n\treaders[typeSimpleString] = readSimpleString\n\treaders[typeSimpleErr] = readSimpleString\n\treaders[typeInteger] = readInteger\n\treaders[typeNull] = readNull\n\treaders[typeFloat] = readSimpleString\n\treaders[typeBool] = readBoolean\n\treaders[typeBlobErr] = readBlobString\n\treaders[typeVerbatimString] = readBlobString\n\treaders[typeBigNumber] = readSimpleString\n\treaders[typeArray] = readArray\n\treaders[typeMap] = readMap\n\treaders[typeSet] = readArray\n\treaders[typeAttribute] = readMap\n\treaders[typePush] = readArray\n\treaders[typeEnd] = readNull\n\n\ttypeNames[typeBlobString] = \"blob string\"\n\ttypeNames[typeSimpleString] = \"simple string\"\n\ttypeNames[typeSimpleErr] = \"simple error\"\n\ttypeNames[typeInteger] = \"int64\"\n\ttypeNames[typeNull] = \"null\"\n\ttypeNames[typeFloat] = \"float64\"\n\ttypeNames[typeBool] = \"boolean\"\n\ttypeNames[typeBlobErr] = \"blob error\"\n\ttypeNames[typeVerbatimString] = \"verbatim string\"\n\ttypeNames[typeBigNumber] = \"big number\"\n\ttypeNames[typeArray] = \"array\"\n\ttypeNames[typeMap] = \"map\"\n\ttypeNames[typeSet] = \"set\"\n\ttypeNames[typeAttribute] = \"attribute\"\n\ttypeNames[typePush] = \"push\"\n\ttypeNames[typeEnd] = \"null\"\n}\n\nfunc readSimpleString(i *bufio.Reader) (m RedisMessage, err error) {\n\tm.string, err = readS(i)\n\treturn\n}\n\nfunc readBlobString(i *bufio.Reader) (m RedisMessage, err error) {\n\tm.string, err = readB(i)\n\tif err == errChunked {\n\t\tsb := strings.Builder{}\n\t\tfor {\n\t\t\tif _, err = i.Discard(1); err != nil { // discard the ';'\n\t\t\t\treturn RedisMessage{}, err\n\t\t\t}\n\t\t\tlength, err := readI(i)\n\t\t\tif err != nil {\n\t\t\t\treturn RedisMessage{}, err\n\t\t\t}\n\t\t\tif length == 0 {\n\t\t\t\treturn RedisMessage{string: sb.String()}, nil\n\t\t\t}\n\t\t\tsb.Grow(int(length))\n\t\t\tif _, err = io.CopyN(&sb, i, length); err != nil {\n\t\t\t\treturn RedisMessage{}, err\n\t\t\t}\n\t\t\tif _, err = i.Discard(2); err != nil {\n\t\t\t\treturn RedisMessage{}, err\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc readInteger(i *bufio.Reader) (m RedisMessage, err error) {\n\tm.integer, err = readI(i)\n\treturn\n}\n\nfunc readBoolean(i *bufio.Reader) (m RedisMessage, err error) {\n\tb, err := i.ReadByte()\n\tif err != nil {\n\t\treturn RedisMessage{}, err\n\t}\n\tif b == 't' {\n\t\tm.integer = 1\n\t}\n\t_, err = i.Discard(2)\n\treturn\n}\n\nfunc readNull(i *bufio.Reader) (m RedisMessage, err error) {\n\t_, err = i.Discard(2)\n\treturn\n}\n\nfunc readArray(i *bufio.Reader) (m RedisMessage, err error) {\n\tlength, err := readI(i)\n\tif err == nil {\n\t\tif length == -1 {\n\t\t\treturn m, errOldNull\n\t\t}\n\t\tm.values, err = readA(i, length)\n\t} else if err == errChunked {\n\t\tm.values, err = readE(i)\n\t}\n\treturn m, err\n}\n\nfunc readMap(i *bufio.Reader) (m RedisMessage, err error) {\n\tlength, err := readI(i)\n\tif err == nil {\n\t\tm.values, err = readA(i, length*2)\n\t} else if err == errChunked {\n\t\tm.values, err = readE(i)\n\t}\n\treturn m, err\n}\n\nconst ok = \"OK\"\nconst okrn = \"OK\\r\\n\"\n\nfunc readS(i *bufio.Reader) (string, error) {\n\tif peek, _ := i.Peek(2); string(peek) == ok {\n\t\tif peek, _ = i.Peek(4); string(peek) == okrn {\n\t\t\t_, _ = i.Discard(4)\n\t\t\treturn ok, nil\n\t\t}\n\t}\n\tbs, err := i.ReadBytes('\\n')\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif trim := len(bs) - 2; trim < 0 {\n\t\treturn \"\", errors.New(unexpectedNoCRLF)\n\t} else {\n\t\tbs = bs[:trim]\n\t}\n\treturn BinaryString(bs), nil\n}\n\nfunc readI(i *bufio.Reader) (v int64, err error) {\n\tbs, err := i.ReadSlice('\\n')\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif len(bs) < 3 {\n\t\treturn 0, errors.New(unexpectedNoCRLF)\n\t}\n\tif bs[0] == '?' {\n\t\treturn 0, errChunked\n\t}\n\tvar s = int64(1)\n\tif bs[0] == '-' {\n\t\ts = -1\n\t\tbs = bs[1:]\n\t}\n\tfor _, c := range bs[:len(bs)-2] {\n\t\tif d := int64(c - '0'); d >= 0 && d <= 9 {\n\t\t\tv = v*10 + d\n\t\t} else {\n\t\t\treturn 0, errors.New(unexpectedNumByte + strconv.Itoa(int(c)))\n\t\t}\n\t}\n\treturn v * s, nil\n}\n\nfunc readB(i *bufio.Reader) (string, error) {\n\tlength, err := readI(i)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif length == -1 {\n\t\treturn \"\", errOldNull\n\t}\n\tbs := make([]byte, length)\n\tif _, err = io.ReadFull(i, bs); err != nil {\n\t\treturn \"\", err\n\t}\n\tif _, err = i.Discard(2); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn BinaryString(bs), nil\n}\n\nfunc readE(i *bufio.Reader) ([]RedisMessage, error) {\n\tv := make([]RedisMessage, 0)\n\tfor {\n\t\tn, err := readNextMessage(i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif n.typ == '.' {\n\t\t\treturn v, err\n\t\t}\n\t\tv = append(v, n)\n\t}\n}\n\nfunc readA(i *bufio.Reader, length int64) (v []RedisMessage, err error) {\n\tv = make([]RedisMessage, length)\n\tfor n := int64(0); n < length; n++ {\n\t\tif v[n], err = readNextMessage(i); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn v, nil\n}\n\nfunc writeB(o *bufio.Writer, id byte, str string) (err error) {\n\t_ = writeN(o, id, len(str))\n\t_, _ = o.WriteString(str)\n\t_, err = o.WriteString(\"\\r\\n\")\n\treturn err\n}\n\nfunc writeS(o *bufio.Writer, id byte, str string) (err error) {\n\t_ = o.WriteByte(id)\n\t_, _ = o.WriteString(str)\n\t_, err = o.WriteString(\"\\r\\n\")\n\treturn err\n}\n\nfunc writeN(o *bufio.Writer, id byte, n int) (err error) {\n\t_ = o.WriteByte(id)\n\tif n < 10 {\n\t\t_ = o.WriteByte(byte('0' + n))\n\t} else {\n\t\tfor d := int(math.Pow10(int(math.Log10(float64(n))))); d > 0; d /= 10 {\n\t\t\t_ = o.WriteByte(byte('0' + n/d))\n\t\t\tn = n % d\n\t\t}\n\t}\n\t_, err = o.WriteString(\"\\r\\n\")\n\treturn err\n}\n\nfunc readNextMessage(i *bufio.Reader) (m RedisMessage, err error) {\n\tvar attrs *RedisMessage\n\tvar typ byte\n\tfor {\n\t\tif typ, err = i.ReadByte(); err != nil {\n\t\t\treturn RedisMessage{}, err\n\t\t}\n\t\tfn := readers[typ]\n\t\tif fn == nil {\n\t\t\treturn RedisMessage{}, errors.New(unknownMessageType + strconv.Itoa(int(typ)))\n\t\t}\n\t\tif m, err = fn(i); err != nil {\n\t\t\tif err == errOldNull {\n\t\t\t\treturn RedisMessage{typ: typeNull}, nil\n\t\t\t}\n\t\t\treturn RedisMessage{}, err\n\t\t}\n\t\tm.typ = typ\n\t\tif m.typ == typeAttribute { // handle the attributes\n\t\t\ta := m     // clone the original m first, and then take address of the clone\n\t\t\tattrs = &a // to avoid go compiler allocating the m on heap which causing worse performance.\n\t\t\tm = RedisMessage{}\n\t\t\tcontinue\n\t\t}\n\t\tm.attrs = attrs\n\t\treturn m, nil\n\t}\n}\n\nvar lrs = sync.Pool{New: func() any { return &io.LimitedReader{} }}\n\nfunc streamTo(i *bufio.Reader, w io.Writer) (n int64, err error, clean bool) {\nnext:\n\tvar typ byte\n\tif typ, err = i.ReadByte(); err != nil {\n\t\treturn 0, err, false\n\t}\n\tswitch typ {\n\tcase typeBlobString, typeVerbatimString, typeChunk:\n\t\tif n, err = readI(i); err != nil {\n\t\t\tif err == errChunked {\n\t\t\t\tvar nn int64\n\t\t\t\tnn, err, clean = streamTo(i, w)\n\t\t\t\tfor n += nn; nn != 0 && clean && err == nil; n += nn {\n\t\t\t\t\tnn, err, clean = streamTo(i, w)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n, err, clean\n\t\t}\n\t\tif n == -1 {\n\t\t\treturn 0, Nil, true\n\t\t}\n\t\tfull := n + 2\n\t\tif n != 0 {\n\t\t\tlr := lrs.Get().(*io.LimitedReader)\n\t\t\tlr.R = i\n\t\t\tlr.N = n\n\t\t\tn, err = io.Copy(w, lr)\n\t\t\tlr.R = nil\n\t\t\tlrs.Put(lr)\n\t\t} else if typ == typeChunk {\n\t\t\treturn n, err, true\n\t\t}\n\t\tif _, err2 := i.Discard(int(full - n)); err2 == nil {\n\t\t\tclean = true\n\t\t} else if err == nil {\n\t\t\terr = err2\n\t\t}\n\t\treturn n, err, clean\n\tdefault:\n\t\t_ = i.UnreadByte()\n\t\tm, err := readNextMessage(i)\n\t\tif err != nil {\n\t\t\treturn 0, err, false\n\t\t}\n\t\tswitch m.typ {\n\t\tcase typeSimpleString, typeFloat, typeBigNumber:\n\t\t\tn, err := w.Write([]byte(m.string))\n\t\t\treturn int64(n), err, true\n\t\tcase typeNull:\n\t\t\treturn 0, Nil, true\n\t\tcase typeSimpleErr, typeBlobErr:\n\t\t\tmm := m\n\t\t\treturn 0, (*RedisError)(&mm), true\n\t\tcase typeInteger, typeBool:\n\t\t\tn, err := w.Write([]byte(strconv.FormatInt(m.integer, 10)))\n\t\t\treturn int64(n), err, true\n\t\tcase typePush:\n\t\t\tgoto next\n\t\tdefault:\n\t\t\treturn 0, fmt.Errorf(\"unsupported redis %q response for streaming read\", typeNames[typ]), true\n\t\t}\n\t}\n}\n\nfunc writeCmd(o *bufio.Writer, cmd []string) (err error) {\n\terr = writeN(o, '*', len(cmd))\n\tfor _, m := range cmd {\n\t\terr = writeB(o, '$', m)\n\t\t// TODO: Can we set cmd[i] = \"\" here to allow GC to eagerly recycle memory?\n\t\t// Related: https://github.com/redis/rueidis/issues/364\n\t}\n\treturn err\n}\n\nfunc flushCmd(o *bufio.Writer, cmd []string) (err error) {\n\t_ = writeCmd(o, cmd)\n\treturn o.Flush()\n}\n\nconst (\n\tunexpectedNoCRLF   = \"received unexpected simple string message ending without CRLF\"\n\tunexpectedNumByte  = \"received unexpected number byte: \"\n\tunknownMessageType = \"received unknown message type: \"\n)\n"
        },
        {
          "name": "resp_test.go",
          "type": "blob",
          "size": 17.029296875,
          "content": "package rueidis\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\tcrand \"crypto/rand\"\n\t\"io\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\nconst iteration = 100\n\nvar generators = map[byte]func(i int64, f float64, str string) string{}\n\n//gocyclo:ignore\nfunc init() {\n\tgenerators['$'] = func(i int64, f float64, str string) string {\n\t\treturn strconv.Itoa(len(str)) + \"\\r\\n\" + str + \"\\r\\n\"\n\t}\n\tgenerators['!'] = generators['$']\n\tgenerators['='] = generators['$']\n\tgenerators['+'] = func(i int64, f float64, str string) string {\n\t\treturn str + \"\\r\\n\"\n\t}\n\tgenerators['-'] = generators['+']\n\tgenerators['('] = generators['+'] // big number as string\n\tgenerators[':'] = func(i int64, f float64, str string) string {\n\t\treturn strconv.FormatInt(i, 10) + \"\\r\\n\"\n\t}\n\tgenerators['_'] = func(i int64, f float64, str string) string {\n\t\treturn \"\\r\\n\"\n\t}\n\tgenerators[','] = func(i int64, f float64, str string) string {\n\t\treturn strconv.FormatFloat(f, 'f', -1, 64) + \"\\r\\n\"\n\t}\n\tgenerators['#'] = func(i int64, f float64, str string) string {\n\t\tif i%2 == 1 {\n\t\t\treturn \"t\\r\\n\"\n\t\t}\n\t\treturn \"f\\r\\n\"\n\t}\n\tgenerators['*'] = func(i int64, f float64, str string) string {\n\t\tl := i%20 + 1\n\t\tif l == 0 {\n\t\t\tl = 1\n\t\t}\n\t\tif l < 0 {\n\t\t\tl *= -1\n\t\t}\n\t\tsb := strings.Builder{}\n\t\tsb.WriteString(strconv.FormatInt(l, 10))\n\t\tsb.WriteString(\"\\r\\n\")\n\t\tfor {\n\t\t\tfor k, g := range generators {\n\t\t\t\tif k == '*' || k == '%' || k == '~' || k == '>' {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsb.WriteByte(k)\n\t\t\t\tsb.WriteString(g(i, f, random(k == '+' || k == '-' || k == '(')))\n\t\t\t\tl--\n\t\t\t\tif l == 0 {\n\t\t\t\t\treturn sb.String()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgenerators['%'] = func(i int64, f float64, str string) string {\n\t\tl := i % 20\n\t\tif l == 0 {\n\t\t\tl = 1\n\t\t}\n\t\tif l < 0 {\n\t\t\tl *= -1\n\t\t}\n\t\tsb := strings.Builder{}\n\t\tsb.WriteString(strconv.FormatInt(l, 10))\n\t\tsb.WriteString(\"\\r\\n\")\n\t\tl *= 2\n\t\tfor {\n\t\t\tfor k, g := range generators {\n\t\t\t\tif k == '*' || k == '%' || k == '~' || k == '>' {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tsb.WriteByte(k)\n\t\t\t\tsb.WriteString(g(i, f, random(k == '+' || k == '-' || k == '(')))\n\t\t\t\tl--\n\t\t\t\tif l == 0 {\n\t\t\t\t\treturn sb.String()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgenerators['~'] = generators['*']\n\tgenerators['>'] = generators['*']\n}\n\nfunc TestReadNextMessage(t *testing.T) {\n\tb := bytes.NewBuffer(nil)\n\tr := bufio.NewReader(b)\n\n\tfor i := 0; i < iteration; i++ {\n\t\tfor k, g := range generators {\n\t\t\tb.WriteByte(k)\n\t\t\tb.WriteString(g(rand.Int63(), rand.Float64(), random(k == '+' || k == '-' || k == '(')))\n\t\t\tmsg, err := readNextMessage(r)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t\t}\n\t\t\tif msg.typ != k {\n\t\t\t\tt.Fatalf(\"unexpected msg type, expected %v, got %v\", k, msg.typ)\n\t\t\t}\n\t\t\t// TODO test msg value\n\t\t}\n\t}\n}\n\nfunc TestWriteCmdAndRead(t *testing.T) {\n\tfor i := 0; i < iteration; i++ {\n\t\tb := bytes.NewBuffer(nil)\n\t\to := bufio.NewWriter(b)\n\t\tcmd := make([]string, randN(20))\n\t\tfor i := range cmd {\n\t\t\tcmd[i] = random(false)\n\t\t}\n\t\tif err := writeCmd(o, cmd); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\t_ = o.Flush()\n\t\tif m, err := readNextMessage(bufio.NewReader(b)); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t} else if m.typ != '*' {\n\t\t\tt.Fatalf(\"unexpected m.typ: expected *, got %v\", m.typ)\n\t\t} else if len(m.values) != len(cmd) {\n\t\t\tt.Fatalf(\"unexpected m.values: expected %v, got %v\", len(cmd), len(m.values))\n\t\t} else {\n\t\t\tfor i, v := range m.values {\n\t\t\t\tif v.typ != '$' {\n\t\t\t\t\tt.Fatalf(\"unexpected v.values: expected $, got %v\", v.typ)\n\t\t\t\t}\n\t\t\t\tif v.string != cmd[i] {\n\t\t\t\t\tt.Fatalf(\"unexpected v.string\\n expected %v \\n got %v\", cmd[i], v.string)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadI(t *testing.T) {\n\tfor i := 0; i < iteration; i++ {\n\t\tint1 := rand.Int63() - rand.Int63()\n\t\tint2, err := readI(source(strconv.FormatInt(int1, 10)))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err: %v\", err)\n\t\t}\n\t\tif int1 != int2 {\n\t\t\tt.Fatalf(\"readI fail to read the int: \\n expected: %v \\n got: %v\", int1, int2)\n\t\t}\n\t}\n}\n\nfunc TestReadBoolean(t *testing.T) {\n\tdata := \"#t\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '#' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif m.integer != 1 {\n\t\t\t\tt.Fatalf(\"unexpected msg integer %v\", m.integer)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadString(t *testing.T) {\n\tdata := \"+Hello word\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '+' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif m.string != \"Hello word\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", m.string)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadStringStream(t *testing.T) {\n\tdata := \"+Hello word\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif buf.String() != \"Hello word\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", buf.String())\n\t\t\t}\n\t\t\tif n != int64(buf.Len()) {\n\t\t\t\tt.Fatalf(\"unexpected msg len %v\", buf.Len())\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadErrorStream(t *testing.T) {\n\tdata := \"-Err: word\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif err.Error() != \"Err: word\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", err.Error())\n\t\t\t}\n\t\t\tif n != 0 {\n\t\t\t\tt.Fatalf(\"unexpected msg len %v\", buf.Len())\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadIntegerStream(t *testing.T) {\n\tdata := \":-1234567\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif buf.String() != \"-1234567\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", buf.String())\n\t\t\t}\n\t\t\tif n != int64(buf.Len()) {\n\t\t\t\tt.Fatalf(\"unexpected msg len %v\", buf.Len())\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadPrefixPushIntegerStream(t *testing.T) {\n\tdata := \">2\\r\\n+ignore\\r\\n+ignore\\r\\n:-1234567\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif buf.String() != \"-1234567\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", buf.String())\n\t\t\t}\n\t\t\tif n != int64(buf.Len()) {\n\t\t\t\tt.Fatalf(\"unexpected msg len %v\", buf.Len())\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadComplexTypesStream(t *testing.T) {\n\tdata := \"%1\\r\\n+ignore\\r\\n+ignore\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif !strings.HasPrefix(err.Error(), \"unsupported\") {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif n != 0 {\n\t\t\t\tt.Fatalf(\"unexpected msg len %v\", buf.Len())\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadStringCRLFErr(t *testing.T) {\n\tdata := \"+\\n\"\n\tif _, err := readNextMessage(bufio.NewReader(strings.NewReader(data))); err.Error() != unexpectedNoCRLF {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestReadStringStreamCRLFErr(t *testing.T) {\n\tdata := \"+\\n\"\n\tbuf := bytes.NewBuffer(nil)\n\tif _, err, _ := streamTo(bufio.NewReader(strings.NewReader(data)), buf); err.Error() != unexpectedNoCRLF {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestReadChunkedString(t *testing.T) {\n\tdata := \"$?\\r\\n;4\\r\\nHell\\r\\n;5\\r\\no wor\\r\\n;1\\r\\nd\\r\\n;0\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '$' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif m.string != \"Hello word\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", m.string)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadChunkedStringStream(t *testing.T) {\n\tdata := \"$?\\r\\n;4\\r\\nHell\\r\\n;5\\r\\no wor\\r\\n;1\\r\\nd\\r\\n;0\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif buf.String() != \"Hello word\" {\n\t\t\t\tt.Fatalf(\"unexpected msg string %v\", buf.String())\n\t\t\t}\n\t\t\tif n != int64(buf.Len()) {\n\t\t\t\tt.Fatalf(\"unexpected msg len %v\", buf.Len())\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadChunkedArray(t *testing.T) {\n\tdata := \"*?\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n.\\r\\n\"\n\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '*' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif len(m.values) != 3 {\n\t\t\t\tt.Fatalf(\"unexpected msg values length %v\", len(m.values))\n\t\t\t}\n\t\t\tfor i, v := range m.values {\n\t\t\t\tif v.typ != ':' || v.integer != int64(i+1) {\n\t\t\t\t\tt.Fatalf(\"unexpected msg values %v\", m.values)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadChunkedMap(t *testing.T) {\n\tdata := \"%?\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n:4\\r\\n.\\r\\n\"\n\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '%' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif len(m.values) != 4 {\n\t\t\t\tt.Fatalf(\"unexpected msg values length %v\", len(m.values))\n\t\t\t}\n\t\t\tfor i, v := range m.values {\n\t\t\t\tif v.typ != ':' || v.integer != int64(i+1) {\n\t\t\t\t\tt.Fatalf(\"unexpected msg values %v\", m.values)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md#attribute-type\nfunc TestReadAttr(t *testing.T) {\n\tdata := \"|1\\r\\n+key-popularity\\r\\n%2\\r\\n$1\\r\\na\\r\\n,0.1923\\r\\n$1\\r\\nb\\r\\n,0.0012\\r\\n*2\\r\\n:2039123\\r\\n:9543892\\r\\n\"\n\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '*' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif m.values[0].integer != 2039123 {\n\t\t\t\tt.Fatalf(\"unexpected msg values[0] %v\", m.values[0])\n\t\t\t}\n\t\t\tif m.values[1].integer != 9543892 {\n\t\t\t\tt.Fatalf(\"unexpected msg values[0] %v\", m.values[1])\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(*m.attrs, RedisMessage{typ: '|', values: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"key-popularity\"},\n\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t{typ: '$', string: \"a\"},\n\t\t\t\t\t{typ: ',', string: \"0.1923\"},\n\t\t\t\t\t{typ: '$', string: \"b\"},\n\t\t\t\t\t{typ: ',', string: \"0.0012\"},\n\t\t\t\t}},\n\t\t\t}}) {\n\t\t\t\tt.Fatalf(\"unexpected msg attr %v\", m.attrs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadRESP2NullString(t *testing.T) {\n\tdata := \"$-1\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '_' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadRESP3NullStream(t *testing.T) {\n\tdata := \"_\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif m, ok := err.(*RedisError); !ok {\n\t\t\t\tt.Fatal(err)\n\t\t\t} else if m.typ != '_' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t\tif n != 0 {\n\t\t\t\tt.Fatalf(\"unexpected n value %v\", n)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadRESP2NullStringStream(t *testing.T) {\n\tdata := \"$-1\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tbuf := bytes.NewBuffer(nil)\n\t\tn, err, clean := streamTo(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))), buf)\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif m, ok := err.(*RedisError); !ok {\n\t\t\t\tt.Fatal(err)\n\t\t\t} else if m.typ != '_' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t\tif !clean {\n\t\t\t\tt.Fatalf(\"unexpected clean value %v\", clean)\n\t\t\t}\n\t\t\tif n != 0 {\n\t\t\t\tt.Fatalf(\"unexpected n value %v\", n)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadRESP2NullStringInArray(t *testing.T) {\n\tdata := \"*3\\r\\n$5\\r\\nhello\\r\\n$-1\\r\\n$5\\r\\nworld\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(m, RedisMessage{\n\t\t\t\ttyp: '*',\n\t\t\t\tvalues: []RedisMessage{\n\t\t\t\t\t{typ: '$', string: \"hello\"},\n\t\t\t\t\t{typ: '_'},\n\t\t\t\t\t{typ: '$', string: \"world\"},\n\t\t\t\t},\n\t\t\t}) {\n\t\t\t\tt.Fatalf(\"unexpected msg %v\", m)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestReadRESP2NullArray(t *testing.T) {\n\tdata := \"*-1\\r\\n\"\n\tfor i := 1; i <= len(data); i++ {\n\t\tm, err := readNextMessage(bufio.NewReader(io.LimitReader(strings.NewReader(data), int64(i))))\n\t\tif i < len(data) {\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"unexpected no error: %v\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m.typ != '_' {\n\t\t\t\tt.Fatalf(\"unexpected msg type %v\", m.typ)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestWriteBReadB(t *testing.T) {\n\tTWriterAndReader(t, writeB, readB, false)\n}\n\nfunc TestWriteSReadS(t *testing.T) {\n\tTWriterAndReader(t, writeS, readS, true)\n}\n\nfunc TWriterAndReader(t *testing.T, writer func(*bufio.Writer, byte, string) error, reader func(*bufio.Reader) (string, error), trim bool) {\n\tfor i := 0; i < iteration; i++ {\n\t\tb := bytes.NewBuffer(nil)\n\t\to := bufio.NewWriter(b)\n\t\tstr1 := random(trim)\n\t\tif err := writer(o, str1[0], str1); err != nil {\n\t\t\tt.Fatalf(\"unexpected err: %v\", err)\n\t\t}\n\t\t_ = o.Flush()\n\t\tr := bufio.NewReader(b)\n\t\tif id, err := r.ReadByte(); err != nil {\n\t\t\tt.Fatalf(\"unexpected err: %v\", err)\n\t\t} else if id != str1[0] {\n\t\t\tt.Fatalf(\"unexpected id: expected %v, got %v\", str1[0], id)\n\t\t}\n\t\tif str2, err := reader(r); err != nil {\n\t\t\tt.Fatalf(\"unexpected err: %v\", err)\n\t\t} else if str1 != str2 {\n\t\t\tt.Fatalf(\"fail to read the string: \\n expected: %v \\n got: %v\", str1, str2)\n\t\t}\n\t}\n}\n\nfunc TestRand(t *testing.T) {\n\tread := func(in *bufio.Reader) (m RedisMessage, err error) {\n\t\tm, err = readNextMessage(in)\n\t\treturn\n\t}\n\tfor i := 0; i < iteration; i++ {\n\t\tif _, err := read(bufio.NewReader(strings.NewReader(random(false)))); err != nil {\n\t\t\tif err != io.EOF &&\n\t\t\t\terr.Error() != \"panic as expected\" &&\n\t\t\t\terr.Error() != \"unbounded redis message\" &&\n\t\t\t\t!strings.HasPrefix(err.Error(), unexpectedNoCRLF) &&\n\t\t\t\t!strings.HasPrefix(err.Error(), unexpectedNumByte) &&\n\t\t\t\t!strings.HasPrefix(err.Error(), unknownMessageType) {\n\t\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestChunkedStringRand(t *testing.T) {\n\tchunkedPrefix := \"$?\\n;\"\n\n\tread := func(in *bufio.Reader) (m RedisMessage, err error) {\n\t\tm, err = readNextMessage(in)\n\t\treturn\n\t}\n\n\tfor i := 0; i < iteration; i++ {\n\t\tif _, err := read(bufio.NewReader(strings.NewReader(chunkedPrefix + random(false)))); err != nil &&\n\t\t\terr != io.EOF &&\n\t\t\terr != errChunked &&\n\t\t\t!strings.HasPrefix(err.Error(), unexpectedNoCRLF) &&\n\t\t\t!strings.HasPrefix(err.Error(), unexpectedNumByte) &&\n\t\t\t!strings.HasPrefix(err.Error(), unknownMessageType) {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t}\n}\n\nfunc source(str string) *bufio.Reader {\n\treturn bufio.NewReader(bytes.NewReader(append([]byte(str), '\\r', '\\n')))\n}\n\nfunc random(trim bool) string {\nretry:\n\tbs := make([]byte, randN(5000))\n\tif _, err := crand.Read(bs); err != nil {\n\t\tpanic(err)\n\t}\n\tif trim {\n\t\tif v := strings.NewReplacer(\"\\r\", \"\", \"\\n\", \"\").Replace(string(bs)); len(v) != 0 {\n\t\t\treturn v\n\t\t}\n\t\tgoto retry\n\t}\n\treturn string(bs)\n}\n\nfunc randN(n int) (v int) {\n\tfor v == 0 {\n\t\tv = rand.Intn(n)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 2.6533203125,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\nconst (\n\tdefaultMaxRetries    = 20\n\tdefaultMaxRetryDelay = 1 * time.Second\n)\n\n// RetryDelayFn returns the delay that should be used before retrying the\n// attempt. Will return negative delay if the delay could not be determined or do not retry.\ntype RetryDelayFn func(attempts int, cmd Completed, err error) time.Duration\n\n// defaultRetryDelayFn delays the next retry exponentially without considering the error.\n// max delay is 1 second.\n// This \"Equal Jitter\" delay produced by this implementation is not monotonic increasing. ref: https://aws.amazon.com/ko/blogs/architecture/exponential-backoff-and-jitter/\nfunc defaultRetryDelayFn(attempts int, _ Completed, _ error) time.Duration {\n\tbase := 1 << min(defaultMaxRetries, attempts)\n\tjitter := util.FastRand(base)\n\treturn min(defaultMaxRetryDelay, time.Duration(base+jitter)*time.Microsecond)\n}\n\ntype retryHandler interface {\n\t// RetryDelay returns the delay that should be used before retrying the\n\t// attempt. Will return negative delay if the delay could not be determined or do\n\t// not retry.\n\t// If the delay is zero, the next retry should be attempted immediately.\n\tRetryDelay(attempts int, cmd Completed, err error) time.Duration\n\n\t// WaitForRetry waits until the next retry should be attempted.\n\tWaitForRetry(ctx context.Context, duration time.Duration)\n\n\t// WaitOrSkipRetry waits until the next retry should be attempted\n\t// or returns false if the command should not be retried.\n\t// Returns false immediately if the command should not be retried.\n\t// Returns true after the delay if the command should be retried.\n\tWaitOrSkipRetry(ctx context.Context, attempts int, cmd Completed, err error) bool\n}\n\ntype retryer struct {\n\tRetryDelayFn RetryDelayFn\n}\n\nvar _ retryHandler = (*retryer)(nil)\n\nfunc newRetryer(retryDelayFn RetryDelayFn) *retryer {\n\treturn &retryer{RetryDelayFn: retryDelayFn}\n}\n\nfunc (r *retryer) RetryDelay(attempts int, cmd Completed, err error) time.Duration {\n\treturn r.RetryDelayFn(attempts, cmd, err)\n}\n\nfunc (r *retryer) WaitForRetry(ctx context.Context, duration time.Duration) {\n\tif duration > 0 {\n\t\tif ch := ctx.Done(); ch != nil {\n\t\t\ttm := time.NewTimer(duration)\n\t\t\tdefer tm.Stop()\n\t\t\tselect {\n\t\t\tcase <-ch:\n\t\t\tcase <-tm.C:\n\t\t\t}\n\t\t} else {\n\t\t\ttime.Sleep(duration)\n\t\t}\n\t}\n}\n\nfunc (r *retryer) WaitOrSkipRetry(\n\tctx context.Context, attempts int, cmd Completed, err error,\n) bool {\n\tif delay := r.RetryDelay(attempts, cmd, err); delay == 0 {\n\t\truntime.Gosched()\n\t\treturn true\n\t} else if delay > 0 {\n\t\tif dl, ok := ctx.Deadline(); !ok || time.Until(dl) > delay {\n\t\t\tr.WaitForRetry(ctx, delay)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "retry_test.go",
          "type": "blob",
          "size": 5.4794921875,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype mockRetryHandler struct {\n\tRetryDelayFn        func(attempts int, _ Completed, err error) time.Duration\n\tWaitForRetryFn      func(ctx context.Context, duration time.Duration)\n\tWaitOrSkipRetryFunc func(ctx context.Context, attempts int, _ Completed, err error) bool\n}\n\nvar _ retryHandler = (*mockRetryHandler)(nil)\n\nfunc (m *mockRetryHandler) WaitOrSkipRetry(ctx context.Context, attempts int, cmd Completed, err error) bool {\n\treturn m.WaitOrSkipRetryFunc(ctx, attempts, cmd, err)\n}\n\nfunc (m *mockRetryHandler) RetryDelay(attempts int, cmd Completed, err error) time.Duration {\n\treturn m.RetryDelayFn(attempts, cmd, err)\n}\n\nfunc (m *mockRetryHandler) WaitForRetry(ctx context.Context, duration time.Duration) {\n\tm.WaitForRetryFn(ctx, duration)\n}\n\nfunc TestDefaultRetryDelay(t *testing.T) {\n\tfor i := 0; i < 100; i++ {\n\t\terr := errors.New(\"test\")\n\t\tgot := defaultRetryDelayFn(i, Completed{}, err)\n\n\t\tif got < 0 || got > defaultMaxRetryDelay {\n\t\t\tt.Errorf(\"defaultRetryDelayFn(%d, %v) = %v; want >= 0 and <= %v\", i, err, got, defaultMaxRetryDelay)\n\t\t}\n\t}\n}\n\nfunc TestRetryer_RetryDelay(t *testing.T) {\n\tr := &retryer{\n\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\treturn time.Second\n\t\t},\n\t}\n\n\tgot := r.RetryDelay(0, Completed{}, nil)\n\tif got != time.Second {\n\t\tt.Errorf(\"RetryDelay() = %v; want %v\", got, time.Second)\n\t}\n}\n\nfunc TestRetryer_WaitForRetry(t *testing.T) {\n\tt.Run(\"context is canceled\", func(t *testing.T) {\n\t\tr := &retryer{}\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\n\t\tstart := time.Now()\n\t\tr.WaitForRetry(ctx, time.Second)\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitForRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n\n\tt.Run(\"context deadline is before duration\", func(t *testing.T) {\n\t\tr := &retryer{}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\t\tdefer cancel()\n\n\t\tstart := time.Now()\n\t\tr.WaitForRetry(ctx, time.Second)\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitForRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n\n\tt.Run(\"wait until duration\", func(t *testing.T) {\n\t\tr := &retryer{}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\tstart := time.Now()\n\t\tr.WaitForRetry(ctx, 50*time.Millisecond)\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitForRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n\n\tt.Run(\"empty context\", func(t *testing.T) {\n\t\tr := &retryer{}\n\n\t\tstart := time.Now()\n\t\tr.WaitForRetry(context.Background(), 50*time.Millisecond)\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitForRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n}\n\nfunc TestRetrier_WaitOrSkipRetry(t *testing.T) {\n\tt.Run(\"RetryDelayFn returns negative delay\", func(t *testing.T) {\n\t\tr := &retryer{\n\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\treturn -1 * time.Second\n\t\t\t},\n\t\t}\n\n\t\tshouldRetry := r.WaitOrSkipRetry(nil, 0, Completed{}, nil)\n\t\tif shouldRetry {\n\t\t\tt.Error(\"WaitOrSkipRetry() = true; want false\")\n\t\t}\n\t})\n\n\tt.Run(\"RetryDelayFn returns 0 delay\", func(t *testing.T) {\n\t\tr := &retryer{\n\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t}\n\n\t\tshouldRetry := r.WaitOrSkipRetry(nil, 0, Completed{}, nil)\n\t\tif !shouldRetry {\n\t\t\tt.Error(\"WaitOrSkipRetry() = false; want true\")\n\t\t}\n\t})\n\n\tt.Run(\"context is canceled\", func(t *testing.T) {\n\t\tr := &retryer{\n\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\treturn time.Second\n\t\t\t},\n\t\t}\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\n\t\tshouldRetry := r.WaitOrSkipRetry(ctx, 0, Completed{}, nil)\n\t\tif !shouldRetry {\n\t\t\tt.Error(\"WaitOrSkipRetry() = false; want true\")\n\t\t}\n\t})\n\n\tt.Run(\"context deadline is before delay\", func(t *testing.T) {\n\t\tr := &retryer{\n\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\treturn time.Second\n\t\t\t},\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\t\tdefer cancel()\n\n\t\tstart := time.Now()\n\t\tshouldRetry := r.WaitOrSkipRetry(ctx, 0, Completed{}, nil)\n\t\tif shouldRetry {\n\t\t\tt.Error(\"WaitOrSkipRetry() = true; want false\")\n\t\t}\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitOrSkipRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n\n\tt.Run(\"wait until next retry\", func(t *testing.T) {\n\t\tr := &retryer{\n\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\treturn 50 * time.Millisecond\n\t\t\t},\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\t\tdefer cancel()\n\n\t\tstart := time.Now()\n\t\tshouldRetry := r.WaitOrSkipRetry(ctx, 0, Completed{}, nil)\n\t\tif !shouldRetry {\n\t\t\tt.Error(\"WaitOrSkipRetry() = false; want true\")\n\t\t}\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitOrSkipRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n\n\tt.Run(\"empty context\", func(t *testing.T) {\n\t\tr := &retryer{\n\t\t\tRetryDelayFn: func(attempts int, _ Completed, err error) time.Duration {\n\t\t\t\treturn 50 * time.Millisecond\n\t\t\t},\n\t\t}\n\n\t\tstart := time.Now()\n\t\tshouldRetry := r.WaitOrSkipRetry(context.Background(), 0, Completed{}, nil)\n\t\tif !shouldRetry {\n\t\t\tt.Error(\"WaitOrSkipRetry() = false; want true\")\n\t\t}\n\t\telapsed := time.Since(start)\n\n\t\tif elapsed > 100*time.Millisecond {\n\t\t\tt.Errorf(\"WaitOrSkipRetry() took %v; want < 100ms\", elapsed)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "ring.go",
          "type": "blob",
          "size": 2.83984375,
          "content": "package rueidis\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"golang.org/x/sys/cpu\"\n)\n\ntype queue interface {\n\tPutOne(m Completed) chan RedisResult\n\tPutMulti(m []Completed, resps []RedisResult) chan RedisResult\n\tNextWriteCmd() (Completed, []Completed, chan RedisResult)\n\tWaitForWrite() (Completed, []Completed, chan RedisResult)\n\tNextResultCh() (Completed, []Completed, chan RedisResult, []RedisResult, *sync.Cond)\n}\n\nvar _ queue = (*ring)(nil)\n\nfunc newRing(factor int) *ring {\n\tif factor <= 0 {\n\t\tfactor = DefaultRingScale\n\t}\n\tr := &ring{store: make([]node, 2<<(factor-1))}\n\tr.mask = uint32(len(r.store) - 1)\n\tfor i := range r.store {\n\t\tm := &sync.Mutex{}\n\t\tr.store[i].c1 = sync.NewCond(m)\n\t\tr.store[i].c2 = sync.NewCond(m)\n\t\tr.store[i].ch = make(chan RedisResult) // this channel can't be buffered\n\t}\n\treturn r\n}\n\ntype ring struct {\n\tstore []node // store's size must be 2^N to work with the mask\n\t_     cpu.CacheLinePad\n\twrite uint32\n\t_     cpu.CacheLinePad\n\tread1 uint32\n\tread2 uint32\n\tmask  uint32\n}\n\ntype node struct {\n\tc1    *sync.Cond\n\tc2    *sync.Cond\n\tch    chan RedisResult\n\tone   Completed\n\tmulti []Completed\n\tresps []RedisResult\n\tmark  uint32\n\tslept bool\n}\n\nfunc (r *ring) PutOne(m Completed) chan RedisResult {\n\tn := &r.store[atomic.AddUint32(&r.write, 1)&r.mask]\n\tn.c1.L.Lock()\n\tfor n.mark != 0 {\n\t\tn.c1.Wait()\n\t}\n\tn.one = m\n\tn.mark = 1\n\ts := n.slept\n\tn.c1.L.Unlock()\n\tif s {\n\t\tn.c2.Broadcast()\n\t}\n\treturn n.ch\n}\n\nfunc (r *ring) PutMulti(m []Completed, resps []RedisResult) chan RedisResult {\n\tn := &r.store[atomic.AddUint32(&r.write, 1)&r.mask]\n\tn.c1.L.Lock()\n\tfor n.mark != 0 {\n\t\tn.c1.Wait()\n\t}\n\tn.multi = m\n\tn.resps = resps\n\tn.mark = 1\n\ts := n.slept\n\tn.c1.L.Unlock()\n\tif s {\n\t\tn.c2.Broadcast()\n\t}\n\treturn n.ch\n}\n\n// NextWriteCmd should be only called by one dedicated thread\nfunc (r *ring) NextWriteCmd() (one Completed, multi []Completed, ch chan RedisResult) {\n\tr.read1++\n\tp := r.read1 & r.mask\n\tn := &r.store[p]\n\tn.c1.L.Lock()\n\tif n.mark == 1 {\n\t\tone, multi, ch = n.one, n.multi, n.ch\n\t\tn.mark = 2\n\t} else {\n\t\tr.read1--\n\t}\n\tn.c1.L.Unlock()\n\treturn\n}\n\n// WaitForWrite should be only called by one dedicated thread\nfunc (r *ring) WaitForWrite() (one Completed, multi []Completed, ch chan RedisResult) {\n\tr.read1++\n\tp := r.read1 & r.mask\n\tn := &r.store[p]\n\tn.c1.L.Lock()\n\tfor n.mark != 1 {\n\t\tn.slept = true\n\t\tn.c2.Wait() // c1 and c2 share the same mutex\n\t\tn.slept = false\n\t}\n\tone, multi, ch = n.one, n.multi, n.ch\n\tn.mark = 2\n\tn.c1.L.Unlock()\n\treturn\n}\n\n// NextResultCh should be only called by one dedicated thread\nfunc (r *ring) NextResultCh() (one Completed, multi []Completed, ch chan RedisResult, resps []RedisResult, cond *sync.Cond) {\n\tr.read2++\n\tp := r.read2 & r.mask\n\tn := &r.store[p]\n\tcond = n.c1\n\tn.c1.L.Lock()\n\tif n.mark == 2 {\n\t\tone, multi, ch, resps = n.one, n.multi, n.ch, n.resps\n\t\tn.mark = 0\n\t\tn.one = Completed{}\n\t\tn.multi = nil\n\t\tn.resps = nil\n\t} else {\n\t\tr.read2--\n\t}\n\treturn\n}\n"
        },
        {
          "name": "ring_test.go",
          "type": "blob",
          "size": 3.9541015625,
          "content": "package rueidis\n\nimport (\n\t\"runtime\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\n//gocyclo:ignore\nfunc TestRing(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"PutOne\", func(t *testing.T) {\n\t\tring := newRing(DefaultRingScale)\n\t\tsize := 5000\n\t\tfixture := make(map[string]struct{}, size)\n\t\tfor i := 0; i < size; i++ {\n\t\t\tfixture[strconv.Itoa(i)] = struct{}{}\n\t\t}\n\n\t\tfor cmd := range fixture {\n\t\t\tgo ring.PutOne(cmds.NewCompleted([]string{cmd}))\n\t\t}\n\n\t\tfor len(fixture) != 0 {\n\t\t\tcmd1, _, _ := ring.NextWriteCmd()\n\t\t\tif cmd1.IsEmpty() {\n\t\t\t\truntime.Gosched()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcmd2, _, ch, _, cond := ring.NextResultCh()\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t\tif cmd1.Commands()[0] != cmd2.Commands()[0] {\n\t\t\t\tt.Fatalf(\"cmds read by NextWriteCmd and NextResultCh is not the same one\")\n\t\t\t}\n\t\t\tif ch == nil || len(ch) != 0 {\n\t\t\t\tt.Fatalf(\"channel from NextResultCh is broken\")\n\t\t\t}\n\t\t\tdelete(fixture, cmd1.Commands()[0])\n\t\t}\n\t})\n\n\tt.Run(\"PutMulti\", func(t *testing.T) {\n\t\tring := newRing(DefaultRingScale)\n\t\tsize := 5000\n\t\tfixture := make(map[string]struct{}, size)\n\t\tfor i := 0; i < size; i++ {\n\t\t\tfixture[strconv.Itoa(i)] = struct{}{}\n\t\t}\n\n\t\tbase := [][]string{{\"a\"}, {\"b\"}, {\"c\"}, {\"d\"}}\n\t\tfor cmd := range fixture {\n\t\t\tgo ring.PutMulti(cmds.NewMultiCompleted(append([][]string{{cmd}}, base...)), nil)\n\t\t}\n\n\t\tfor len(fixture) != 0 {\n\t\t\t_, cmd1, _ := ring.NextWriteCmd()\n\t\t\tif cmd1 == nil {\n\t\t\t\truntime.Gosched()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t_, cmd2, ch, _, cond := ring.NextResultCh()\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t\tfor j := 0; j < len(cmd1); j++ {\n\t\t\t\tif cmd1[j].Commands()[0] != cmd2[j].Commands()[0] {\n\t\t\t\t\tt.Fatalf(\"cmds read by NextWriteCmd and NextResultCh is not the same one\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ch == nil || len(ch) != 0 {\n\t\t\t\tt.Fatalf(\"channel from NextResultCh is broken\")\n\t\t\t}\n\t\t\tdelete(fixture, cmd1[0].Commands()[0])\n\t\t}\n\t})\n\n\tt.Run(\"NextWriteCmd & NextResultCh\", func(t *testing.T) {\n\t\tring := newRing(DefaultRingScale)\n\t\tif one, multi, _ := ring.NextWriteCmd(); !one.IsEmpty() || multi != nil {\n\t\t\tt.Fatalf(\"NextWriteCmd should returns nil if empty\")\n\t\t}\n\t\tif one, multi, ch, _, cond := ring.NextResultCh(); !one.IsEmpty() || multi != nil || ch != nil {\n\t\t\tt.Fatalf(\"NextResultCh should returns nil if not NextWriteCmd yet\")\n\t\t} else {\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t}\n\n\t\tring.PutOne(cmds.NewCompleted([]string{\"0\"}))\n\t\tif one, _, _ := ring.NextWriteCmd(); len(one.Commands()) == 0 || one.Commands()[0] != \"0\" {\n\t\t\tt.Fatalf(\"NextWriteCmd should returns next cmd\")\n\t\t}\n\t\tif one, _, ch, _, cond := ring.NextResultCh(); len(one.Commands()) == 0 || one.Commands()[0] != \"0\" || ch == nil {\n\t\t\tt.Fatalf(\"NextResultCh should returns next cmd after NextWriteCmd\")\n\t\t} else {\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t}\n\n\t\tring.PutMulti(cmds.NewMultiCompleted([][]string{{\"0\"}}), nil)\n\t\tif _, multi, _ := ring.NextWriteCmd(); len(multi) == 0 || multi[0].Commands()[0] != \"0\" {\n\t\t\tt.Fatalf(\"NextWriteCmd should returns next cmd\")\n\t\t}\n\t\tif _, multi, ch, _, cond := ring.NextResultCh(); len(multi) == 0 || multi[0].Commands()[0] != \"0\" || ch == nil {\n\t\t\tt.Fatalf(\"NextResultCh should returns next cmd after NextWriteCmd\")\n\t\t} else {\n\t\t\tcond.L.Unlock()\n\t\t\tcond.Signal()\n\t\t}\n\t})\n\n\tt.Run(\"PutOne Wakeup WaitForWrite\", func(t *testing.T) {\n\t\tring := newRing(DefaultRingScale)\n\t\tif one, _, ch := ring.NextWriteCmd(); ch == nil {\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tring.PutOne(cmds.PingCmd)\n\t\t\t}()\n\t\t\tif one, _, ch = ring.WaitForWrite(); ch != nil && one.Commands()[0] == cmds.PingCmd.Commands()[0] {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tt.Fatal(\"Should sleep\")\n\t})\n\n\tt.Run(\"PutMulti Wakeup WaitForWrite\", func(t *testing.T) {\n\t\tring := newRing(DefaultRingScale)\n\t\tif _, _, ch := ring.NextWriteCmd(); ch == nil {\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tring.PutMulti([]Completed{cmds.PingCmd}, nil)\n\t\t\t}()\n\t\t\tif _, multi, ch := ring.WaitForWrite(); ch != nil && multi[0].Commands()[0] == cmds.PingCmd.Commands()[0] {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tt.Fatal(\"Should sleep\")\n\t})\n}\n"
        },
        {
          "name": "rueidis.go",
          "type": "blob",
          "size": 22.8251953125,
          "content": "// Package rueidis is a fast Golang Redis RESP3 client that does auto pipelining and supports client side caching.\npackage rueidis\n\n//go:generate go run hack/cmds/gen.go internal/cmds hack/cmds/*.json\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"math\"\n\t\"net\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\nconst (\n\t// DefaultCacheBytes is the default value of ClientOption.CacheSizeEachConn, which is 128 MiB\n\tDefaultCacheBytes = 128 * (1 << 20)\n\t// DefaultRingScale is the default value of ClientOption.RingScaleEachConn, which results into having a ring of size 2^10 for each connection\n\tDefaultRingScale = 10\n\t// DefaultPoolSize is the default value of ClientOption.BlockingPoolSize\n\tDefaultPoolSize = 1024\n\t// DefaultBlockingPipeline is the default value of ClientOption.BlockingPipeline\n\tDefaultBlockingPipeline = 2000\n\t// DefaultDialTimeout is the default value of ClientOption.Dialer.Timeout\n\tDefaultDialTimeout = 5 * time.Second\n\t// DefaultTCPKeepAlive is the default value of ClientOption.Dialer.KeepAlive\n\tDefaultTCPKeepAlive = 1 * time.Second\n\t// DefaultReadBuffer is the default value of bufio.NewReaderSize for each connection, which is 0.5MiB\n\tDefaultReadBuffer = 1 << 19\n\t// DefaultWriteBuffer is the default value of bufio.NewWriterSize for each connection, which is 0.5MiB\n\tDefaultWriteBuffer = 1 << 19\n\t// MaxPipelineMultiplex is the maximum meaningful value for ClientOption.PipelineMultiplex\n\tMaxPipelineMultiplex = 8\n)\n\nvar (\n\t// ErrClosing means the Client.Close had been called\n\tErrClosing = errors.New(\"rueidis client is closing or unable to connect redis\")\n\t// ErrNoAddr means the ClientOption.InitAddress is empty\n\tErrNoAddr = errors.New(\"no alive address in InitAddress\")\n\t// ErrNoCache means your redis does not support client-side caching and must set ClientOption.DisableCache to true\n\tErrNoCache = errors.New(\"ClientOption.DisableCache must be true for redis not supporting client-side caching or not supporting RESP3\")\n\t// ErrRESP2PubSubMixed means your redis does not support RESP3 and rueidis can't handle SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE in mixed case\n\tErrRESP2PubSubMixed = errors.New(\"rueidis does not support SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE mixed with other commands in RESP2\")\n\t// ErrBlockingPubSubMixed rueidis can't handle SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE mixed with other blocking commands\n\tErrBlockingPubSubMixed = errors.New(\"rueidis does not support SUBSCRIBE/PSUBSCRIBE/SSUBSCRIBE mixed with other blocking commands\")\n\t// ErrDoCacheAborted means redis abort EXEC request or connection closed\n\tErrDoCacheAborted = errors.New(\"failed to fetch the cache because EXEC was aborted by redis or connection closed\")\n\t// ErrReplicaOnlyNotSupported means ReplicaOnly flag is not supported by\n\t// current client\n\tErrReplicaOnlyNotSupported = errors.New(\"ReplicaOnly is not supported for single client\")\n\t// ErrWrongPipelineMultiplex means wrong value for ClientOption.PipelineMultiplex\n\tErrWrongPipelineMultiplex = errors.New(\"ClientOption.PipelineMultiplex must not be bigger than MaxPipelineMultiplex\")\n\t// ErrDedicatedClientRecycled means the caller attempted to use the dedicated client which has been already recycled (after canceled/closed).\n\tErrDedicatedClientRecycled = errors.New(\"dedicated client should not be used after recycled\")\n\t// DisableClientSetInfo is the value that can be used for ClientOption.ClientSetInfo to disable making the CLIENT SETINFO command\n\tDisableClientSetInfo = make([]string, 0)\n)\n\n// ClientOption should be passed to NewClient to construct a Client\ntype ClientOption struct {\n\t// TCP & TLS\n\t// Dialer can be used to customized how rueidis connect to a redis instance via TCP, including:\n\t// - Timeout, the default is DefaultDialTimeout\n\t// - KeepAlive, the default is DefaultTCPKeepAlive\n\t// The Dialer.KeepAlive interval is used to detect an unresponsive idle tcp connection.\n\t// OS takes at least (tcp_keepalive_probes+1)*Dialer.KeepAlive time to conclude an idle connection to be unresponsive.\n\t// For example: DefaultTCPKeepAlive = 1s and the default of tcp_keepalive_probes on Linux is 9.\n\t// Therefore, it takes at least 10s to kill an idle and unresponsive tcp connection on Linux by default.\n\tDialer    net.Dialer\n\tTLSConfig *tls.Config\n\n\t// DialFn allows for a custom function to be used to create net.Conn connections\n\tDialFn func(string, *net.Dialer, *tls.Config) (conn net.Conn, err error)\n\n\t// NewCacheStoreFn allows a custom client side caching store for each connection\n\tNewCacheStoreFn NewCacheStoreFn\n\n\t// OnInvalidations is a callback function in case of client-side caching invalidation received.\n\t// Note that this function must be fast, otherwise other redis messages will be blocked.\n\tOnInvalidations func([]RedisMessage)\n\n\t// SendToReplicas is a function that returns true if the command should be sent to replicas.\n\t// currently only used for cluster client.\n\t// NOTE: This function can't be used with ReplicaOnly option.\n\tSendToReplicas func(cmd Completed) bool\n\n\t// Sentinel options, including MasterSet and Auth options\n\tSentinel SentinelOption\n\n\t// Redis AUTH parameters\n\tUsername   string\n\tPassword   string\n\tClientName string\n\n\t// AuthCredentialsFn allows for setting the AUTH username and password dynamically on each connection attempt to\n\t// support rotating credentials\n\tAuthCredentialsFn func(AuthCredentialsContext) (AuthCredentials, error)\n\n\t// ClientSetInfo will assign various info attributes to the current connection.\n\t// Note that ClientSetInfo should have exactly 2 values, the lib name and the lib version respectively.\n\tClientSetInfo []string\n\n\t// InitAddress point to redis nodes.\n\t// Rueidis will connect to them one by one and issue CLUSTER SLOT command to initialize the cluster client until success.\n\t// If len(InitAddress) == 1 and the address is not running in cluster mode, rueidis will fall back to the single client mode.\n\t// If ClientOption.Sentinel.MasterSet is set, then InitAddress will be used to connect sentinels\n\t// You can bypass this behaviour by using ClientOption.ForceSingleClient.\n\tInitAddress []string\n\n\t// ClientTrackingOptions will be appended to CLIENT TRACKING ON command when the connection is established.\n\t// The default is []string{\"OPTIN\"}\n\tClientTrackingOptions []string\n\n\tSelectDB int\n\n\t// CacheSizeEachConn is redis client side cache size that bind to each TCP connection to a single redis instance.\n\t// The default is DefaultCacheBytes.\n\tCacheSizeEachConn int\n\n\t// RingScaleEachConn sets the size of the ring buffer in each connection to (2 ^ RingScaleEachConn).\n\t// The default is RingScaleEachConn, which results into having a ring of size 2^10 for each connection.\n\t// Reduce this value can reduce the memory consumption of each connection at the cost of potential throughput degradation.\n\t// Values smaller than 8 is typically not recommended.\n\tRingScaleEachConn int\n\n\t// ReadBufferEachConn is the size of the bufio.NewReaderSize for each connection, default to DefaultReadBuffer (0.5 MiB).\n\tReadBufferEachConn int\n\t// WriteBufferEachConn is the size of the bufio.NewWriterSize for each connection, default to DefaultWriteBuffer (0.5 MiB).\n\tWriteBufferEachConn int\n\n\t// BlockingPoolCleanup is the duration for cleaning up idle connections.\n\t// If BlockingPoolCleanup is 0, then idle connections will not be cleaned up.\n\tBlockingPoolCleanup time.Duration\n\t// BlockingPoolMinSize is the minimum size of the connection pool\n\t// shared by blocking commands (ex BLPOP, XREAD with BLOCK).\n\t// Only relevant if BlockingPoolCleanup is not 0. This parameter limits\n\t// the number of idle connections that can be removed by BlockingPoolCleanup.\n\tBlockingPoolMinSize int\n\n\t// BlockingPoolSize is the size of the connection pool shared by blocking commands (ex BLPOP, XREAD with BLOCK).\n\t// The default is DefaultPoolSize.\n\tBlockingPoolSize int\n\t// BlockingPipeline is the threshold of a pipeline that will be treated as blocking commands when exceeding it.\n\tBlockingPipeline int\n\n\t// PipelineMultiplex determines how many tcp connections used to pipeline commands to one redis instance.\n\t// The default for single and sentinel clients is 2, which means 4 connections (2^2).\n\t// The default for cluster clients is 0, which means 1 connection (2^0).\n\tPipelineMultiplex int\n\n\t// ConnWriteTimeout is read/write timeout for each connection. If specified,\n\t// it is used to control the maximum duration waits for responses to pipeline commands.\n\t// Also, ConnWriteTimeout is applied net.Conn.SetDeadline and periodic PING to redis\n\t// Since the Dialer.KeepAlive will not be triggered if there is data in the outgoing buffer,\n\t// ConnWriteTimeout should be set in order to detect local congestion or unresponsive redis server.\n\t// This default is ClientOption.Dialer.KeepAlive * (9+1), where 9 is the default of tcp_keepalive_probes on Linux.\n\tConnWriteTimeout time.Duration\n\n\t// MaxFlushDelay when greater than zero pauses pipeline write loop for some time (not larger than MaxFlushDelay)\n\t// after each flushing of data to the connection. This gives pipeline a chance to collect more commands to send\n\t// to Redis. Adding this delay increases latency, reduces throughput – but in most cases may significantly reduce\n\t// application and Redis CPU utilization due to less executed system calls. By default, Rueidis flushes data to the\n\t// connection without extra delays. Depending on network latency and application-specific conditions the value\n\t// of MaxFlushDelay may vary, sth like 20 microseconds should not affect latency/throughput a lot but still\n\t// produce notable CPU usage reduction under load. Ref: https://github.com/redis/rueidis/issues/156\n\tMaxFlushDelay time.Duration\n\n\t// DisableTCPNoDelay turns on Nagle's algorithm in pipelining mode by using conn.SetNoDelay(false).\n\t// Turning this on can result in lower p99 latencies and lower CPU usages if all your requests are small.\n\t// But if you have large requests or fast network, this might degrade the performance. Ref: https://github.com/redis/rueidis/pull/650\n\tDisableTCPNoDelay bool\n\n\t// ShuffleInit is a handy flag that shuffles the InitAddress after passing to the NewClient() if it is true\n\tShuffleInit bool\n\t// ClientNoTouch controls whether commands alter LRU/LFU stats\n\tClientNoTouch bool\n\t// DisableRetry disables retrying read-only commands under network errors\n\tDisableRetry bool\n\t// RetryDelay is the function that returns the delay that should be used before retrying the attempt.\n\t// The default is an exponential backoff with a maximum delay of 1 second.\n\t// Only used when DisableRetry is false.\n\tRetryDelay RetryDelayFn\n\t// DisableCache falls back Client.DoCache/Client.DoMultiCache to Client.Do/Client.DoMulti\n\tDisableCache bool\n\t// DisableAutoPipelining makes rueidis.Client always pick a connection from the BlockingPool to serve each request.\n\tDisableAutoPipelining bool\n\t// AlwaysPipelining makes rueidis.Client always pipeline redis commands even if they are not issued concurrently.\n\tAlwaysPipelining bool\n\t// AlwaysRESP2 makes rueidis.Client always uses RESP2, otherwise it will try using RESP3 first.\n\tAlwaysRESP2 bool\n\t//  ForceSingleClient force the usage of a single client connection, without letting the lib guessing\n\t//  if redis instance is a cluster or a single redis instance.\n\tForceSingleClient bool\n\n\t// ReplicaOnly indicates that this client will only try to connect to readonly replicas of redis setup.\n\tReplicaOnly bool\n\n\t// ClientNoEvict sets the client eviction mode for the current connection.\n\t// When turned on and client eviction is configured,\n\t// the current connection will be excluded from the client eviction process\n\t// even if we're above the configured client eviction threshold.\n\tClientNoEvict bool\n\n\t// ClusterOption is the options for the redis cluster client.\n\tClusterOption ClusterOption\n\n\t// ReplicaSelector selects a replica node when `SendToReplicas` returns true.\n\t// If the function is set, the client will send selected command to the replica node.\n\t// Returned value is the index of the replica node in the replicas slice.\n\t// If the returned value is out of range, the primary node will be selected.\n\t// If primary node does not have any replica, the primary node will be selected\n\t// and function will not be called.\n\t// Currently only used for cluster client.\n\t// Each ReplicaInfo must not be modified.\n\t// NOTE: This function can't be used with ReplicaOnly option.\n\t// NOTE: This function must be used with SendToReplicas function.\n\tReplicaSelector func(slot uint16, replicas []ReplicaInfo) int\n}\n\n// SentinelOption contains MasterSet,\ntype SentinelOption struct {\n\t// TCP & TLS, same as ClientOption but for connecting sentinel\n\tDialer    net.Dialer\n\tTLSConfig *tls.Config\n\n\t// MasterSet is the redis master set name monitored by sentinel cluster.\n\t// If this field is set, then ClientOption.InitAddress will be used to connect to sentinel cluster.\n\tMasterSet string\n\n\t// Redis AUTH parameters for sentinel\n\tUsername   string\n\tPassword   string\n\tClientName string\n}\n\n// ClusterOption is the options for the redis cluster client.\ntype ClusterOption struct {\n\t// ShardsRefreshInterval is the interval to scan the cluster topology.\n\t// If the value is zero, refreshment will be disabled.\n\t// Cluster topology cache refresh happens always in the background after successful scan.\n\tShardsRefreshInterval time.Duration\n}\n\n// ReplicaInfo is the information of a replica node in a redis cluster.\ntype ReplicaInfo struct {\n\tAddr string\n}\n\n// Client is the redis client interface for both single redis instance and redis cluster. It should be created from the NewClient()\ntype Client interface {\n\tCoreClient\n\n\t// DoCache is similar to Do, but it uses opt-in client side caching and requires a client side TTL.\n\t// The explicit client side TTL specifies the maximum TTL on the client side.\n\t// If the key's TTL on the server is smaller than the client side TTL, the client side TTL will be capped.\n\t//  client.Do(ctx, client.B().Get().Key(\"k\").Cache(), time.Minute).ToString()\n\t// The above example will send the following command to redis if cache miss:\n\t//  CLIENT CACHING YES\n\t//  PTTL k\n\t//  GET k\n\t// The in-memory cache size is configured by ClientOption.CacheSizeEachConn.\n\t// The cmd parameter is recycled after passing into DoCache() and should not be reused.\n\tDoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult)\n\n\t// DoMultiCache is similar to DoCache, but works with multiple cacheable commands across different slots.\n\t// It will first group commands by slots and will send only cache missed commands to redis.\n\tDoMultiCache(ctx context.Context, multi ...CacheableTTL) (resp []RedisResult)\n\n\t// DoStream send a command to redis through a dedicated connection acquired from a connection pool.\n\t// It returns a RedisResultStream, but it does not read the command response until the RedisResultStream.WriteTo is called.\n\t// After the RedisResultStream.WriteTo is called, the underlying connection is then recycled.\n\t// DoStream should only be used when you want to stream redis response directly to an io.Writer without additional allocation,\n\t// otherwise, the normal Do() should be used instead.\n\t// Also note that DoStream can only work with commands returning string, integer, or float response.\n\tDoStream(ctx context.Context, cmd Completed) RedisResultStream\n\n\t// DoMultiStream is similar to DoStream, but pipelines multiple commands to redis.\n\t// It returns a MultiRedisResultStream, and users should call MultiRedisResultStream.WriteTo as many times as the number of commands sequentially\n\t// to read each command response from redis. After all responses are read, the underlying connection is then recycled.\n\t// DoMultiStream should only be used when you want to stream redis responses directly to an io.Writer without additional allocation,\n\t// otherwise, the normal DoMulti() should be used instead.\n\t// DoMultiStream does not support multiple key slots when connecting to a redis cluster.\n\tDoMultiStream(ctx context.Context, multi ...Completed) MultiRedisResultStream\n\n\t// Dedicated acquire a connection from the blocking connection pool, no one else can use the connection\n\t// during Dedicated. The main usage of Dedicated is CAS operation, which is WATCH + MULTI + EXEC.\n\t// However, one should try to avoid CAS operation but use Lua script instead, because occupying a connection\n\t// is not good for performance.\n\tDedicated(fn func(DedicatedClient) error) (err error)\n\n\t// Dedicate does the same as Dedicated, but it exposes DedicatedClient directly\n\t// and requires user to invoke cancel() manually to put connection back to the pool.\n\tDedicate() (client DedicatedClient, cancel func())\n\n\t// Nodes returns each redis node this client known as rueidis.Client. This is useful if you want to\n\t// send commands to some specific redis nodes in the cluster.\n\tNodes() map[string]Client\n}\n\n// DedicatedClient is obtained from Client.Dedicated() and it will be bound to single redis connection and\n// no other commands can be pipelined in to this connection during Client.Dedicated().\n// If the DedicatedClient is obtained from cluster client, the first command to it must have a Key() to identify the redis node.\ntype DedicatedClient interface {\n\tCoreClient\n\n\t// SetPubSubHooks is an alternative way to processing Pub/Sub messages instead of using Receive.\n\t// SetPubSubHooks is non-blocking and allows users to subscribe/unsubscribe channels later.\n\t// Note that the hooks will be called sequentially but in another goroutine.\n\t// The return value will be either:\n\t//   1. an error channel, if the hooks passed in is not zero, or\n\t//   2. nil, if the hooks passed in is zero. (used for reset hooks)\n\t// In the former case, the error channel is guaranteed to be close when the hooks will not be called anymore,\n\t// and has at most one error describing the reason why the hooks will not be called anymore.\n\t// Users can use the error channel to detect disconnection.\n\tSetPubSubHooks(hooks PubSubHooks) <-chan error\n}\n\n// CoreClient is the minimum interface shared by the Client and the DedicatedClient.\ntype CoreClient interface {\n\t// B is the getter function to the command builder for the client\n\t// If the client is a cluster client, the command builder also prohibits cross key slots in one command.\n\tB() Builder\n\t// Do is the method sending user's redis command building from the B() to a redis node.\n\t//  client.Do(ctx, client.B().Get().Key(\"k\").Build()).ToString()\n\t// All concurrent non-blocking commands will be pipelined automatically and have better throughput.\n\t// Blocking commands will use another separated connection pool.\n\t// The cmd parameter is recycled after passing into Do() and should not be reused.\n\tDo(ctx context.Context, cmd Completed) (resp RedisResult)\n\t// DoMulti takes multiple redis commands and sends them together, reducing RTT from the user code.\n\t// The multi parameters are recycled after passing into DoMulti() and should not be reused.\n\tDoMulti(ctx context.Context, multi ...Completed) (resp []RedisResult)\n\t// Receive accepts SUBSCRIBE, SSUBSCRIBE, PSUBSCRIBE command and a message handler.\n\t// Receive will block and then return value only when the following cases:\n\t//   1. return nil when received any unsubscribe/punsubscribe message related to the provided `subscribe` command.\n\t//   2. return ErrClosing when the client is closed manually.\n\t//   3. return ctx.Err() when the `ctx` is done.\n\t//   4. return non-nil err when the provided `subscribe` command failed.\n\tReceive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) error\n\t// Close will make further calls to the client be rejected with ErrClosing,\n\t// and Close will wait until all pending calls finished.\n\tClose()\n}\n\n// CT is a shorthand constructor for CacheableTTL\nfunc CT(cmd Cacheable, ttl time.Duration) CacheableTTL {\n\treturn CacheableTTL{Cmd: cmd, TTL: ttl}\n}\n\n// CacheableTTL is parameter container of DoMultiCache\ntype CacheableTTL struct {\n\tCmd Cacheable\n\tTTL time.Duration\n}\n\n// AuthCredentialsContext is the parameter container of AuthCredentialsFn\ntype AuthCredentialsContext struct {\n\tAddress net.Addr\n}\n\n// AuthCredentials is the output of AuthCredentialsFn\ntype AuthCredentials struct {\n\tUsername string\n\tPassword string\n}\n\n// NewClient uses ClientOption to initialize the Client for both cluster client and single client.\n// It will first try to connect as cluster client. If the len(ClientOption.InitAddress) == 1 and\n// the address does not enable cluster mode, the NewClient() will use single client instead.\nfunc NewClient(option ClientOption) (client Client, err error) {\n\tif option.ReadBufferEachConn < 32 { // the buffer should be able to hold an int64 string at least\n\t\toption.ReadBufferEachConn = DefaultReadBuffer\n\t}\n\tif option.WriteBufferEachConn < 32 {\n\t\toption.WriteBufferEachConn = DefaultWriteBuffer\n\t}\n\tif option.CacheSizeEachConn <= 0 {\n\t\toption.CacheSizeEachConn = DefaultCacheBytes\n\t}\n\tif option.Dialer.Timeout == 0 {\n\t\toption.Dialer.Timeout = DefaultDialTimeout\n\t}\n\tif option.Dialer.KeepAlive == 0 {\n\t\toption.Dialer.KeepAlive = DefaultTCPKeepAlive\n\t}\n\tif option.ConnWriteTimeout == 0 {\n\t\toption.ConnWriteTimeout = max(DefaultTCPKeepAlive, option.Dialer.KeepAlive) * 10\n\t}\n\tif option.BlockingPipeline == 0 {\n\t\toption.BlockingPipeline = DefaultBlockingPipeline\n\t}\n\tif option.DisableAutoPipelining {\n\t\toption.AlwaysPipelining = false\n\t}\n\tif option.ShuffleInit {\n\t\tutil.Shuffle(len(option.InitAddress), func(i, j int) {\n\t\t\toption.InitAddress[i], option.InitAddress[j] = option.InitAddress[j], option.InitAddress[i]\n\t\t})\n\t}\n\tif option.PipelineMultiplex > MaxPipelineMultiplex {\n\t\treturn nil, ErrWrongPipelineMultiplex\n\t}\n\tif option.RetryDelay == nil {\n\t\toption.RetryDelay = defaultRetryDelayFn\n\t}\n\tif option.Sentinel.MasterSet != \"\" {\n\t\toption.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)\n\t\treturn newSentinelClient(&option, makeConn, newRetryer(option.RetryDelay))\n\t}\n\tif option.ForceSingleClient {\n\t\toption.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)\n\t\treturn newSingleClient(&option, nil, makeConn, newRetryer(option.RetryDelay))\n\t}\n\tif client, err = newClusterClient(&option, makeConn, newRetryer(option.RetryDelay)); err != nil {\n\t\tif client == (*clusterClient)(nil) {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(option.InitAddress) == 1 && (err.Error() == redisErrMsgCommandNotAllow || strings.Contains(strings.ToUpper(err.Error()), \"CLUSTER\")) {\n\t\t\toption.PipelineMultiplex = singleClientMultiplex(option.PipelineMultiplex)\n\t\t\tclient, err = newSingleClient(&option, client.(*clusterClient).single(), makeConn, newRetryer(option.RetryDelay))\n\t\t} else {\n\t\t\tclient.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn client, err\n}\n\nfunc singleClientMultiplex(multiplex int) int {\n\tif multiplex == 0 {\n\t\tif multiplex = int(math.Log2(float64(runtime.GOMAXPROCS(0)))); multiplex >= 2 {\n\t\t\tmultiplex = 2\n\t\t}\n\t}\n\tif multiplex < 0 {\n\t\tmultiplex = 0\n\t}\n\treturn multiplex\n}\n\nfunc makeConn(dst string, opt *ClientOption) conn {\n\treturn makeMux(dst, opt, dial)\n}\n\nfunc dial(dst string, opt *ClientOption) (conn net.Conn, err error) {\n\tif opt.DialFn != nil {\n\t\treturn opt.DialFn(dst, &opt.Dialer, opt.TLSConfig)\n\t}\n\tif opt.TLSConfig != nil {\n\t\tconn, err = tls.DialWithDialer(&opt.Dialer, \"tcp\", dst, opt.TLSConfig)\n\t} else {\n\t\tconn, err = opt.Dialer.Dial(\"tcp\", dst)\n\t}\n\treturn conn, err\n}\n\nconst redisErrMsgCommandNotAllow = \"command is not allowed\"\n"
        },
        {
          "name": "rueidis_test.go",
          "type": "blob",
          "size": 14.53515625,
          "content": "package rueidis\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/ed25519\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/onsi/gomega\"\n\t\"github.com/onsi/gomega/gleak\"\n)\n\nfunc SetupLeakDetection() (gomega.Gomega, []gleak.Goroutine) {\n\treturn gomega.NewGomega(func(message string, callerSkip ...int) {\n\t\tpanic(message)\n\t}), gleak.Goroutines()\n}\n\nfunc ShouldNotLeaked(g gomega.Gomega, snapshot []gleak.Goroutine) {\n\tg.Eventually(gleak.Goroutines).WithTimeout(time.Minute).ShouldNot(gleak.HaveLeaked(snapshot))\n}\n\nfunc TestMain(m *testing.M) {\n\tg, snap := SetupLeakDetection()\n\tcode := m.Run()\n\tShouldNotLeaked(g, snap)\n\tos.Exit(code)\n}\n\nfunc accept(t *testing.T, ln net.Listener) (*redisMock, error) {\n\tconn, err := ln.Accept()\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn nil, err\n\t}\n\tmock := &redisMock{\n\t\tt:    t,\n\t\tbuf:  bufio.NewReader(conn),\n\t\tconn: conn,\n\t}\n\tmock.Expect(\"HELLO\", \"3\").\n\t\tReply(RedisMessage{\n\t\t\ttyp: '%',\n\t\t\tvalues: []RedisMessage{\n\t\t\t\t{typ: '+', string: \"proto\"},\n\t\t\t\t{typ: ':', integer: 3},\n\t\t\t},\n\t\t})\n\tmock.Expect(\"CLIENT\", \"TRACKING\", \"ON\", \"OPTIN\").\n\t\tReplyString(\"OK\")\n\treturn mock, nil\n}\n\nfunc TestNewClusterClient(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ln.Close()\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tmock, err := accept(t, ln)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tslots, _ := slotsResp.ToMessage()\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLUSTER\", \"SLOTS\").Reply(slots)\n\t\tmock.Close()\n\t\tclose(done)\n\t}()\n\n\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:\" + port},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer client.Close()\n\tif _, ok := client.(*clusterClient); !ok {\n\t\tt.Fatal(\"client should be a clusterClient\")\n\t}\n\t<-done\n}\n\nfunc TestNewClusterClientError(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"cluster slots command error\", func(t *testing.T) {\n\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer ln.Close()\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tmock, err := accept(t, ln)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\t\tmock.Expect(\"CLUSTER\", \"SLOTS\").Reply(RedisMessage{typ: '-', string: \"other error\"})\n\t\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\t\tmock.Close()\n\t\t\tclose(done)\n\t\t}()\n\t\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\t\tclient, err := NewClient(ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:\" + port},\n\t\t})\n\t\tif client != nil || err == nil {\n\t\t\tt.Errorf(\"unexpected return %v %v\", client, err)\n\t\t}\n\t\t<-done\n\t})\n\n\tt.Run(\"replica only and send to replicas option conflict\", func(t *testing.T) {\n\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer ln.Close()\n\n\t\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\t\tclient, err := NewClient(ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:\" + port},\n\t\t\tReplicaOnly: true,\n\t\t\tSendToReplicas: func(cmd Completed) bool {\n\t\t\t\treturn true\n\t\t\t},\n\t\t})\n\t\tif client != nil || err == nil {\n\t\t\tt.Errorf(\"unexpected return %v %v\", client, err)\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), ErrReplicaOnlyConflict.Error()) {\n\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"replica only and replica selector option conflict\", func(t *testing.T) {\n\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer ln.Close()\n\n\t\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\t\tclient, err := NewClient(ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:\" + port},\n\t\t\tReplicaOnly: true,\n\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t})\n\t\tif client != nil || err == nil {\n\t\t\tt.Errorf(\"unexpected return %v %v\", client, err)\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), ErrReplicaOnlyConflictWithReplicaSelector.Error()) {\n\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"send to replicas should be set when replica selector is set\", func(t *testing.T) {\n\t\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer ln.Close()\n\n\t\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\t\tclient, err := NewClient(ClientOption{\n\t\t\tInitAddress: []string{\"127.0.0.1:\" + port},\n\t\t\tReplicaSelector: func(slot uint16, replicas []ReplicaInfo) int {\n\t\t\t\treturn 0\n\t\t\t},\n\t\t})\n\t\tif client != nil || err == nil {\n\t\t\tt.Errorf(\"unexpected return %v %v\", client, err)\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), ErrSendToReplicasNotSet.Error()) {\n\t\t\tt.Errorf(\"unexpected error %v\", err)\n\t\t}\n\t})\n}\n\nfunc TestFallBackSingleClient(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ln.Close()\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tmock, err := accept(t, ln)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLUSTER\", \"SLOTS\").Reply(RedisMessage{typ: '-', string: \"ERR This instance has cluster support disabled\"})\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\tmock.Close()\n\t\tclose(done)\n\t}()\n\n\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:\" + port},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := client.(*singleClient); !ok {\n\t\tt.Fatal(\"client should be a singleClient\")\n\t}\n\tclient.Close()\n\t<-done\n}\n\nfunc TestForceSingleClient(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ln.Close()\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tmock, err := accept(t, ln)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\tmock.Close()\n\t\tclose(done)\n\t}()\n\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:\" + port},\n\t\tForceSingleClient: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := client.(*singleClient); !ok {\n\t\tt.Fatal(\"client should be a singleClient\")\n\t}\n\tclient.Close()\n\t<-done\n}\n\nfunc TestTLSClient(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tpub, priv, err := ed25519.GenerateKey(rand.Reader)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to generate private key: %v\", err)\n\t}\n\n\tserialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to generate serial number: %v\", err)\n\t}\n\n\ttemplate := x509.Certificate{\n\t\tSerialNumber:          serialNumber,\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().Add(time.Hour),\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tDNSNames:              []string{\"localhost\"},\n\t\tSubject:               pkix.Name{Organization: []string{\"Acme Co\"}},\n\t}\n\n\tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, pub, priv)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create certificate: %v\", err)\n\t}\n\n\tcertPem := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes})\n\n\tprivBytes, err := x509.MarshalPKCS8PrivateKey(priv)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to marshal private key: %v\", err)\n\t}\n\n\tprivPem := pem.EncodeToMemory(&pem.Block{Type: \"PRIVATE KEY\", Bytes: privBytes})\n\n\tcert, err := tls.X509KeyPair(certPem, privPem)\n\tif err != nil {\n\t\tt.Fatalf(\"Fail to load X509KeyPair: %v\", err)\n\t}\n\n\tconfig := &tls.Config{\n\t\tCertificates:       []tls.Certificate{cert},\n\t\tInsecureSkipVerify: true,\n\t}\n\n\tln, err := tls.Listen(\"tcp\", \"127.0.0.1:0\", config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer ln.Close()\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tmock, err := accept(t, ln)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-NAME\", LibName).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLIENT\", \"SETINFO\", \"LIB-VER\", LibVer).\n\t\t\tReplyError(\"UNKNOWN COMMAND\")\n\t\tmock.Expect(\"CLUSTER\", \"SLOTS\").Reply(RedisMessage{typ: '-', string: \"ERR This instance has cluster support disabled\"})\n\t\tmock.Expect(\"PING\").ReplyString(\"OK\")\n\t\tmock.Close()\n\t\tclose(done)\n\t}()\n\n\t_, port, _ := net.SplitHostPort(ln.Addr().String())\n\tclient, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:\" + port},\n\t\tTLSConfig:         config,\n\t\tDisableTCPNoDelay: true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, ok := client.(*singleClient); !ok {\n\t\tt.Fatal(\"client should be a singleClient\")\n\t}\n\tclient.Close()\n\t<-done\n}\n\nfunc TestNewClientMaxMultiplex(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\t_, err := NewClient(ClientOption{\n\t\tInitAddress:       []string{\"127.0.0.1:6379\"},\n\t\tPipelineMultiplex: MaxPipelineMultiplex + 1,\n\t})\n\tif err != ErrWrongPipelineMultiplex {\n\t\tt.Fatalf(\"unexpected error %v\", err)\n\t}\n}\n\nfunc TestSingleClientMultiplex(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\toption := ClientOption{}\n\tif v := singleClientMultiplex(option.PipelineMultiplex); v != 2 {\n\t\tt.Fatalf(\"unexpected value %v\", v)\n\t}\n\toption.PipelineMultiplex = -1\n\tif v := singleClientMultiplex(option.PipelineMultiplex); v != 0 {\n\t\tt.Fatalf(\"unexpected value %v\", v)\n\t}\n}\n\nfunc TestCustomDialFnIsCalled(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tisFnCalled := false\n\toption := ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:0\"},\n\t\tDialFn: func(s string, dialer *net.Dialer, config *tls.Config) (conn net.Conn, err error) {\n\t\t\tisFnCalled = true\n\t\t\treturn nil, errors.New(\"dial error\")\n\t\t},\n\t}\n\n\t_, err := NewClient(option)\n\n\tif !isFnCalled {\n\t\tt.Fatalf(\"excepted ClientOption.DialFn to be called\")\n\t}\n\tif err == nil {\n\t\tt.Fatalf(\"expected dial error\")\n\t}\n}\n\nfunc ExampleIsRedisNil() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\t_, err = client.Do(context.Background(), client.B().Get().Key(\"not_exists\").Build()).ToString()\n\tif err != nil && IsRedisNil(err) {\n\t\tfmt.Printf(\"it is a nil response\")\n\t}\n}\n\nfunc ExampleClient_do() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tctx := context.Background()\n\n\tclient.Do(ctx, client.B().Set().Key(\"k\").Value(\"1\").Build()).Error()\n\n\tclient.Do(ctx, client.B().Get().Key(\"k\").Build()).ToString()\n\n\tclient.Do(ctx, client.B().Get().Key(\"k\").Build()).AsInt64()\n\n\tclient.Do(ctx, client.B().Hmget().Key(\"h\").Field(\"a\", \"b\").Build()).ToArray()\n\n\tclient.Do(ctx, client.B().Scard().Key(\"s\").Build()).ToInt64()\n\n\tclient.Do(ctx, client.B().Smembers().Key(\"s\").Build()).AsStrSlice()\n}\n\nfunc ExampleClient_doCache() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tctx := context.Background()\n\n\tclient.DoCache(ctx, client.B().Get().Key(\"k\").Cache(), time.Minute).ToString()\n\n\tclient.DoCache(ctx, client.B().Get().Key(\"k\").Cache(), time.Minute).AsInt64()\n\n\tclient.DoCache(ctx, client.B().Hmget().Key(\"h\").Field(\"a\", \"b\").Cache(), time.Minute).ToArray()\n\n\tclient.DoCache(ctx, client.B().Scard().Key(\"s\").Cache(), time.Minute).ToInt64()\n\n\tclient.DoCache(ctx, client.B().Smembers().Key(\"s\").Cache(), time.Minute).AsStrSlice()\n}\n\nfunc ExampleClient_scan() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tfor _, c := range client.Nodes() { // loop over all your redis nodes\n\t\tvar scan ScanEntry\n\t\tfor more := true; more; more = scan.Cursor != 0 {\n\t\t\tif scan, err = c.Do(context.Background(), c.B().Scan().Cursor(scan.Cursor).Build()).AsScanEntry(); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfmt.Println(scan.Elements)\n\t\t}\n\t}\n}\n\nfunc ExampleClient_dedicatedCAS() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tctx := context.Background()\n\n\tclient.Dedicated(func(client DedicatedClient) error {\n\t\t// watch keys first\n\t\tif err := client.Do(ctx, client.B().Watch().Key(\"k1\", \"k2\").Build()).Error(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// perform read here\n\t\tvalues, err := client.Do(ctx, client.B().Mget().Key(\"k1\", \"k2\").Build()).ToArray()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv1, _ := values[0].ToString()\n\t\tv2, _ := values[1].ToString()\n\t\t// perform write with MULTI EXEC\n\t\tfor _, resp := range client.DoMulti(\n\t\t\tctx,\n\t\t\tclient.B().Multi().Build(),\n\t\t\tclient.B().Set().Key(\"k1\").Value(v1+\"1\").Build(),\n\t\t\tclient.B().Set().Key(\"k2\").Value(v2+\"2\").Build(),\n\t\t\tclient.B().Exec().Build(),\n\t\t) {\n\t\t\tif err := resp.Error(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc ExampleClient_dedicateCAS() {\n\tclient, err := NewClient(ClientOption{InitAddress: []string{\"127.0.0.1:6379\"}})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tc, cancel := client.Dedicate()\n\tdefer cancel()\n\n\tctx := context.Background()\n\n\t// watch keys first\n\tif err := c.Do(ctx, c.B().Watch().Key(\"k1\", \"k2\").Build()).Error(); err != nil {\n\t\tpanic(err)\n\t}\n\t// perform read here\n\tvalues, err := c.Do(ctx, c.B().Mget().Key(\"k1\", \"k2\").Build()).ToArray()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tv1, _ := values[0].ToString()\n\tv2, _ := values[1].ToString()\n\t// perform write with MULTI EXEC\n\tfor _, resp := range c.DoMulti(\n\t\tctx,\n\t\tc.B().Multi().Build(),\n\t\tc.B().Set().Key(\"k1\").Value(v1+\"1\").Build(),\n\t\tc.B().Set().Key(\"k2\").Value(v2+\"2\").Build(),\n\t\tc.B().Exec().Build(),\n\t) {\n\t\tif err := resp.Error(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc ExampleNewClient_cluster() {\n\tclient, _ := NewClient(ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:7001\", \"127.0.0.1:7002\", \"127.0.0.1:7003\"},\n\t\tShuffleInit: true,\n\t})\n\tdefer client.Close()\n}\n\nfunc ExampleNewClient_single() {\n\tclient, _ := NewClient(ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:6379\"},\n\t})\n\tdefer client.Close()\n}\n\nfunc ExampleNewClient_sentinel() {\n\tclient, _ := NewClient(ClientOption{\n\t\tInitAddress: []string{\"127.0.0.1:26379\", \"127.0.0.1:26380\", \"127.0.0.1:26381\"},\n\t\tSentinel: SentinelOption{\n\t\t\tMasterSet: \"my_master\",\n\t\t},\n\t})\n\tdefer client.Close()\n}\n"
        },
        {
          "name": "rueidisaside",
          "type": "tree",
          "content": null
        },
        {
          "name": "rueidiscompat",
          "type": "tree",
          "content": null
        },
        {
          "name": "rueidishook",
          "type": "tree",
          "content": null
        },
        {
          "name": "rueidislimiter",
          "type": "tree",
          "content": null
        },
        {
          "name": "rueidislock",
          "type": "tree",
          "content": null
        },
        {
          "name": "rueidisotel",
          "type": "tree",
          "content": null
        },
        {
          "name": "rueidisprob",
          "type": "tree",
          "content": null
        },
        {
          "name": "sentinel.go",
          "type": "blob",
          "size": 12.0654296875,
          "content": "package rueidis\n\nimport (\n\t\"container/list\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\nfunc newSentinelClient(opt *ClientOption, connFn connFn, retryer retryHandler) (client *sentinelClient, err error) {\n\tclient = &sentinelClient{\n\t\tcmd:          cmds.NewBuilder(cmds.NoSlot),\n\t\tmOpt:         opt,\n\t\tsOpt:         newSentinelOpt(opt),\n\t\tconnFn:       connFn,\n\t\tsentinels:    list.New(),\n\t\tretry:        !opt.DisableRetry,\n\t\tretryHandler: retryer,\n\t\treplica:      opt.ReplicaOnly,\n\t}\n\n\tfor _, sentinel := range opt.InitAddress {\n\t\tclient.sentinels.PushBack(sentinel)\n\t}\n\n\tif err = client.refresh(); err != nil {\n\t\tclient.Close()\n\t\treturn nil, err\n\t}\n\n\treturn client, nil\n}\n\ntype sentinelClient struct {\n\tmConn        atomic.Value\n\tmAddr        string\n\tsAddr        string\n\tconnFn       connFn\n\tmOpt         *ClientOption\n\tsOpt         *ClientOption\n\tsConn        conn\n\tsentinels    *list.List\n\tsc           call\n\tretryHandler retryHandler\n\tcmd          Builder\n\tmu           sync.Mutex\n\tstop         uint32\n\tretry        bool\n\treplica      bool\n}\n\nfunc (c *sentinelClient) B() Builder {\n\treturn c.cmd\n}\n\nfunc (c *sentinelClient) Do(ctx context.Context, cmd Completed) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tresp = c.mConn.Load().(conn).Do(ctx, cmd)\n\tif c.retry && cmd.IsReadOnly() && c.isRetryable(resp.Error(), ctx) {\n\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\tctx, attempts, cmd, resp.Error(),\n\t\t)\n\t\tif shouldRetry {\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\t}\n\tif resp.NonRedisError() == nil { // not recycle cmds if error, since cmds may be used later in pipe. consider recycle them by pipe\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *sentinelClient) DoMulti(ctx context.Context, multi ...Completed) []RedisResult {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\n\tattempts := 1\nretry:\n\tresps := c.mConn.Load().(conn).DoMulti(ctx, multi...)\n\tif c.retry && allReadOnly(multi) {\n\t\tfor i, resp := range resps.s {\n\t\t\tif c.isRetryable(resp.Error(), ctx) {\n\t\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\t\tctx, attempts, multi[i], resp.Error(),\n\t\t\t\t)\n\t\t\t\tif shouldRetry {\n\t\t\t\t\tresultsp.Put(resps)\n\t\t\t\t\tattempts++\n\t\t\t\t\tgoto retry\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor i, cmd := range multi {\n\t\tif resps.s[i].NonRedisError() == nil {\n\t\t\tcmds.PutCompleted(cmd)\n\t\t}\n\t}\n\treturn resps.s\n}\n\nfunc (c *sentinelClient) DoCache(ctx context.Context, cmd Cacheable, ttl time.Duration) (resp RedisResult) {\n\tattempts := 1\nretry:\n\tresp = c.mConn.Load().(conn).DoCache(ctx, cmd, ttl)\n\tif c.retry && c.isRetryable(resp.Error(), ctx) {\n\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(ctx, attempts, Completed(cmd), resp.Error())\n\t\tif shouldRetry {\n\t\t\tattempts++\n\t\t\tgoto retry\n\t\t}\n\n\t}\n\tif err := resp.NonRedisError(); err == nil || err == ErrDoCacheAborted {\n\t\tcmds.PutCacheable(cmd)\n\t}\n\treturn resp\n}\n\nfunc (c *sentinelClient) DoMultiCache(ctx context.Context, multi ...CacheableTTL) []RedisResult {\n\tif len(multi) == 0 {\n\t\treturn nil\n\t}\n\tattempts := 1\nretry:\n\tresps := c.mConn.Load().(conn).DoMultiCache(ctx, multi...)\n\tif c.retry {\n\t\tfor i, resp := range resps.s {\n\t\t\tif c.isRetryable(resp.Error(), ctx) {\n\t\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\t\tctx, attempts, Completed(multi[i].Cmd), resp.Error(),\n\t\t\t\t)\n\t\t\t\tif shouldRetry {\n\t\t\t\t\tresultsp.Put(resps)\n\t\t\t\t\tattempts++\n\t\t\t\t\tgoto retry\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor i, cmd := range multi {\n\t\tif err := resps.s[i].NonRedisError(); err == nil || err == ErrDoCacheAborted {\n\t\t\tcmds.PutCacheable(cmd.Cmd)\n\t\t}\n\t}\n\treturn resps.s\n}\n\nfunc (c *sentinelClient) Receive(ctx context.Context, subscribe Completed, fn func(msg PubSubMessage)) (err error) {\n\tattempts := 1\nretry:\n\terr = c.mConn.Load().(conn).Receive(ctx, subscribe, fn)\n\tif c.retry {\n\t\tif _, ok := err.(*RedisError); !ok && c.isRetryable(err, ctx) {\n\t\t\tshouldRetry := c.retryHandler.WaitOrSkipRetry(\n\t\t\t\tctx, attempts, subscribe, err,\n\t\t\t)\n\t\t\tif shouldRetry {\n\t\t\t\tattempts++\n\t\t\t\tgoto retry\n\t\t\t}\n\t\t}\n\t}\n\tif err == nil {\n\t\tcmds.PutCompleted(subscribe)\n\t}\n\treturn err\n}\n\nfunc (c *sentinelClient) DoStream(ctx context.Context, cmd Completed) RedisResultStream {\n\tresp := c.mConn.Load().(conn).DoStream(ctx, cmd)\n\tcmds.PutCompleted(cmd)\n\treturn resp\n}\n\nfunc (c *sentinelClient) DoMultiStream(ctx context.Context, multi ...Completed) MultiRedisResultStream {\n\tif len(multi) == 0 {\n\t\treturn RedisResultStream{e: io.EOF}\n\t}\n\ts := c.mConn.Load().(conn).DoMultiStream(ctx, multi...)\n\tfor _, cmd := range multi {\n\t\tcmds.PutCompleted(cmd)\n\t}\n\treturn s\n}\n\nfunc (c *sentinelClient) Dedicated(fn func(DedicatedClient) error) (err error) {\n\tmaster := c.mConn.Load().(conn)\n\twire := master.Acquire()\n\tdsc := &dedicatedSingleClient{cmd: c.cmd, conn: master, wire: wire, retry: c.retry, retryHandler: c.retryHandler}\n\terr = fn(dsc)\n\tdsc.release()\n\treturn err\n}\n\nfunc (c *sentinelClient) Dedicate() (DedicatedClient, func()) {\n\tmaster := c.mConn.Load().(conn)\n\twire := master.Acquire()\n\tdsc := &dedicatedSingleClient{cmd: c.cmd, conn: master, wire: wire, retry: c.retry, retryHandler: c.retryHandler}\n\treturn dsc, dsc.release\n}\n\nfunc (c *sentinelClient) Nodes() map[string]Client {\n\tconn := c.mConn.Load().(conn)\n\tdisableCache := c.mOpt != nil && c.mOpt.DisableCache\n\treturn map[string]Client{conn.Addr(): newSingleClientWithConn(conn, c.cmd, c.retry, disableCache, c.retryHandler)}\n}\n\nfunc (c *sentinelClient) Close() {\n\tatomic.StoreUint32(&c.stop, 1)\n\tc.mu.Lock()\n\tif c.sConn != nil {\n\t\tc.sConn.Close()\n\t}\n\tif master := c.mConn.Load(); master != nil {\n\t\tmaster.(conn).Close()\n\t}\n\tc.mu.Unlock()\n}\n\nfunc (c *sentinelClient) isRetryable(err error, ctx context.Context) (should bool) {\n\tif err == nil || err == Nil || err == ErrDoCacheAborted || atomic.LoadUint32(&c.stop) != 0 || ctx.Err() != nil {\n\t\treturn false\n\t}\n\tif err, ok := err.(*RedisError); ok {\n\t\treturn err.IsLoading()\n\t}\n\treturn true\n}\n\nfunc (c *sentinelClient) addSentinel(addr string) {\n\tc.mu.Lock()\n\tc._addSentinel(addr)\n\tc.mu.Unlock()\n}\n\nfunc (c *sentinelClient) _addSentinel(addr string) {\n\tfor e := c.sentinels.Front(); e != nil; e = e.Next() {\n\t\tif e.Value.(string) == addr {\n\t\t\treturn\n\t\t}\n\t}\n\tc.sentinels.PushFront(addr)\n}\n\nfunc (c *sentinelClient) switchTargetRetry(addr string) {\n\tc.mu.Lock()\n\terr := c._switchTarget(addr)\n\tc.mu.Unlock()\n\tif err != nil {\n\t\tgo c.refreshRetry()\n\t}\n}\n\nfunc (c *sentinelClient) _switchTarget(addr string) (err error) {\n\tvar target conn\n\tif atomic.LoadUint32(&c.stop) == 1 {\n\t\treturn nil\n\t}\n\tif c.mAddr == addr {\n\t\ttarget = c.mConn.Load().(conn)\n\t\tif target.Error() != nil {\n\t\t\ttarget = nil\n\t\t}\n\t}\n\tif target == nil {\n\t\ttarget = c.connFn(addr, c.mOpt)\n\t\tif err = target.Dial(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tresp, err := target.Do(context.Background(), cmds.RoleCmd).ToArray()\n\tif err != nil {\n\t\ttarget.Close()\n\t\treturn err\n\t}\n\n\tif c.replica && resp[0].string != \"slave\" {\n\t\ttarget.Close()\n\t\treturn errNotSlave\n\t} else if !c.replica && resp[0].string != \"master\" {\n\t\ttarget.Close()\n\t\treturn errNotMaster\n\t}\n\n\tc.mAddr = addr\n\tif old := c.mConn.Swap(target); old != nil {\n\t\tif prev := old.(conn); prev != target {\n\t\t\tprev.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *sentinelClient) refreshRetry() {\nretry:\n\tif err := c.refresh(); err != nil {\n\t\tgoto retry\n\t}\n}\n\nfunc (c *sentinelClient) refresh() (err error) {\n\treturn c.sc.Do(context.Background(), c._refresh)\n}\n\nfunc (c *sentinelClient) _refresh() (err error) {\n\tvar target string\n\tvar sentinels []string\n\n\tc.mu.Lock()\n\thead := c.sentinels.Front()\n\tfor e := head; e != nil; {\n\t\tif atomic.LoadUint32(&c.stop) == 1 {\n\t\t\tc.mu.Unlock()\n\t\t\treturn nil\n\t\t}\n\t\taddr := e.Value.(string)\n\n\t\tif c.sAddr != addr || c.sConn == nil || c.sConn.Error() != nil {\n\t\t\tif c.sConn != nil {\n\t\t\t\tc.sConn.Close()\n\t\t\t}\n\t\t\tc.sAddr = addr\n\t\t\tc.sConn = c.connFn(addr, c.sOpt)\n\t\t\terr = c.sConn.Dial()\n\t\t}\n\t\tif err == nil {\n\t\t\t// listWatch returns server address with sentinels.\n\t\t\t// check if target is master or replica\n\t\t\tif target, sentinels, err = c.listWatch(c.sConn); err == nil {\n\t\t\t\tfor _, sentinel := range sentinels {\n\t\t\t\t\tc._addSentinel(sentinel)\n\t\t\t\t}\n\n\t\t\t\t// _switchTarget will switch the connection for master OR replica\n\t\t\t\tif err = c._switchTarget(target); err == nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.sConn.Close()\n\t\t}\n\t\tc.sentinels.MoveToBack(e)\n\t\tif e = c.sentinels.Front(); e == head {\n\t\t\tbreak\n\t\t}\n\t}\n\tc.mu.Unlock()\n\n\tif err == nil {\n\t\tif master := c.mConn.Load(); master == nil {\n\t\t\terr = ErrNoAddr\n\t\t} else {\n\t\t\terr = master.(conn).Error()\n\t\t}\n\t}\n\treturn err\n}\n\n// listWatch will use sentinel to list current master|replica address along with sentinels address\nfunc (c *sentinelClient) listWatch(cc conn) (target string, sentinels []string, err error) {\n\tctx := context.Background()\n\tsentinelsCMD := c.cmd.SentinelSentinels().Master(c.mOpt.Sentinel.MasterSet).Build()\n\tgetMasterCMD := c.cmd.SentinelGetMasterAddrByName().Master(c.mOpt.Sentinel.MasterSet).Build()\n\treplicasCMD := c.cmd.SentinelReplicas().Master(c.mOpt.Sentinel.MasterSet).Build()\n\n\tdefer func() {\n\t\tif err == nil { // not recycle cmds if error, since cmds may be used later in pipe. consider recycle them by pipe\n\t\t\tcmds.PutCompleted(sentinelsCMD)\n\t\t\tcmds.PutCompleted(getMasterCMD)\n\t\t\tcmds.PutCompleted(replicasCMD)\n\t\t}\n\t}()\n\n\t// unsubscribe in case there is any previous subscription\n\tcc.Do(ctx, cmds.SentinelUnSubscribe)\n\n\tgo func(cc conn) {\n\t\tif err := cc.Receive(ctx, cmds.SentinelSubscribe, func(event PubSubMessage) {\n\t\t\tswitch event.Channel {\n\t\t\tcase \"+sentinel\":\n\t\t\t\tm := strings.SplitN(event.Message, \" \", 4)\n\t\t\t\tc.addSentinel(net.JoinHostPort(m[2], m[3]))\n\t\t\tcase \"+switch-master\":\n\t\t\t\tm := strings.SplitN(event.Message, \" \", 5)\n\t\t\t\tif m[0] == c.sOpt.Sentinel.MasterSet {\n\t\t\t\t\tc.switchTargetRetry(net.JoinHostPort(m[3], m[4]))\n\t\t\t\t}\n\t\t\tcase \"+reboot\":\n\t\t\t\tm := strings.SplitN(event.Message, \" \", 7)\n\t\t\t\tif m[0] == \"master\" && m[1] == c.sOpt.Sentinel.MasterSet {\n\t\t\t\t\tc.switchTargetRetry(net.JoinHostPort(m[2], m[3]))\n\t\t\t\t} else if c.replica && m[0] == \"slave\" && m[5] == c.sOpt.Sentinel.MasterSet {\n\t\t\t\t\tc.refreshRetry()\n\t\t\t\t}\n\t\t\t// note that in case of failover, every slave in the setup\n\t\t\t// will send +slave event individually.\n\t\t\tcase \"+slave\", \"+sdown\", \"-sdown\":\n\t\t\t\tm := strings.SplitN(event.Message, \" \", 7)\n\t\t\t\tif c.replica && m[0] == \"slave\" && m[5] == c.sOpt.Sentinel.MasterSet {\n\t\t\t\t\t// call refresh to randomly choose a new slave\n\t\t\t\t\tc.refreshRetry()\n\t\t\t\t}\n\t\t\t}\n\t\t}); err != nil && atomic.LoadUint32(&c.stop) == 0 {\n\t\t\tc.refreshRetry()\n\t\t}\n\t}(cc)\n\n\tvar commands Commands\n\tif c.replica {\n\t\tcommands = Commands{sentinelsCMD, replicasCMD}\n\t} else {\n\t\tcommands = Commands{sentinelsCMD, getMasterCMD}\n\t}\n\n\tresp := cc.DoMulti(ctx, commands...)\n\tdefer resultsp.Put(resp)\n\tothers, err := resp.s[0].ToArray()\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\tfor _, other := range others {\n\t\tif m, err := other.AsStrMap(); err == nil {\n\t\t\tsentinels = append(sentinels, net.JoinHostPort(m[\"ip\"], m[\"port\"]))\n\t\t}\n\t}\n\n\t// we return random slave address instead of master\n\tif c.replica {\n\t\taddr, err := pickReplica(resp.s)\n\t\tif err != nil {\n\t\t\treturn \"\", nil, err\n\t\t}\n\n\t\treturn addr, sentinels, nil\n\t}\n\n\t// otherwise send master as address\n\tm, err := resp.s[1].AsStrSlice()\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\treturn net.JoinHostPort(m[0], m[1]), sentinels, nil\n}\n\nfunc pickReplica(resp []RedisResult) (string, error) {\n\treplicas, err := resp[1].ToArray()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\teligible := make([]map[string]string, 0, len(replicas))\n\t// eliminate replicas with s_down condition\n\tfor i := range replicas {\n\t\treplica, err := replicas[i].AsStrMap()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := replica[\"s-down-time\"]; !ok {\n\t\t\teligible = append(eligible, replica)\n\t\t}\n\t}\n\n\tif len(eligible) == 0 {\n\t\treturn \"\", fmt.Errorf(\"not enough ready replicas\")\n\t}\n\n\t// choose a replica randomly\n\tm := eligible[util.FastRand(len(eligible))]\n\treturn net.JoinHostPort(m[\"ip\"], m[\"port\"]), nil\n}\n\nfunc newSentinelOpt(opt *ClientOption) *ClientOption {\n\to := *opt\n\to.Username = o.Sentinel.Username\n\to.Password = o.Sentinel.Password\n\to.ClientName = o.Sentinel.ClientName\n\to.Dialer = o.Sentinel.Dialer\n\to.TLSConfig = o.Sentinel.TLSConfig\n\to.SelectDB = 0 // https://github.com/redis/rueidis/issues/138\n\treturn &o\n}\n\nvar (\n\terrNotMaster = errors.New(\"the redis role is not master\")\n\terrNotSlave  = errors.New(\"the redis role is not slave\")\n)\n"
        },
        {
          "name": "sentinel_test.go",
          "type": "blob",
          "size": 51.509765625,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"reflect\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/cmds\"\n)\n\n//gocyclo:ignore\nfunc TestSentinelClientInit(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tt.Run(\"Init no nodes\", func(t *testing.T) {\n\t\tif _, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return nil },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != ErrNoAddr {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Init no dialable\", func(t *testing.T) {\n\t\tv := errors.New(\"dial err\")\n\t\tif _, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn { return &mockConn{DialFn: func() error { return v }} },\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh err\", func(t *testing.T) {\n\t\tv := errors.New(\"refresh err\")\n\t\tif _, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn &mockConn{\n\t\t\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults { return &redisresults{s: []RedisResult{newErrResult(v)}} },\n\t\t\t\t}\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Refresh retry\", func(t *testing.T) {\n\t\tv := errors.New(\"refresh err\")\n\t\ts0 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewErrResult(v),\n\t\t\t\t\tnewErrResult(v),\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\ts1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"0\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\tnewErrResult(v),\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\ts2 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"3\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"5\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\ts3 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"4\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"6\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\ts4 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"2\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"7\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tclient, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\", \":1\", \":2\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":0\" {\n\t\t\t\t\treturn s0\n\t\t\t\t}\n\t\t\t\tif dst == \":1\" {\n\t\t\t\t\treturn s1\n\t\t\t\t}\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\treturn s2\n\t\t\t\t}\n\t\t\t\tif dst == \":3\" {\n\t\t\t\t\treturn s3\n\t\t\t\t}\n\t\t\t\tif dst == \":4\" {\n\t\t\t\t\treturn s4\n\t\t\t\t}\n\t\t\t\tif dst == \":5\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDialFn: func() error { return v },\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif dst == \":6\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"slave\"}}}}\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif dst == \":7\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif client.sConn == nil {\n\t\t\tt.Fatalf(\"unexpected nil sentinel conn\")\n\t\t}\n\t\tif client.mConn.Load() == nil {\n\t\t\tt.Fatalf(\"unexpected nil master conn\")\n\t\t}\n\t\tclient.Close()\n\t})\n\n\tt.Run(\"Refresh retry replica-only client\", func(t *testing.T) {\n\t\tv := errors.New(\"refresh err\")\n\t\tslaveWithMultiError := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\tnewErrResult(v),\n\t\t\t\t\tnewErrResult(v),\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tslaveWithReplicaResponseErr := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"0\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\tnewErrResult(v),\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tsentinelWithFaultiSlave := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"3\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"6\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\t// this connection will fail because OK slave is in 's-down' status\n\t\t// since the next 2 connections won't update sentinel list,\n\t\t// we update the list here.\n\t\tsentinelWithHealthySlaveInSDown := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"4\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"32\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"31\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"6\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"8\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"s-down-time\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tsentinelWithoutEligibleSlave := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"32\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"8\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"s-down-time\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\n\t\tsentinelWithInvalidMapResponse := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"4\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\tRedisMessage(*Nil),\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tsentinelWithMasterRoleAsSlave := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"5\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"7\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tsentinelWithOKResponse := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"2\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"8\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\n\t\tclient, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\", \":1\", \":2\"}, ReplicaOnly: true},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":0\" {\n\t\t\t\t\treturn slaveWithMultiError\n\t\t\t\t}\n\t\t\t\tif dst == \":1\" {\n\t\t\t\t\treturn slaveWithReplicaResponseErr\n\t\t\t\t}\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\treturn sentinelWithFaultiSlave\n\t\t\t\t}\n\t\t\t\tif dst == \":3\" {\n\t\t\t\t\treturn sentinelWithHealthySlaveInSDown\n\t\t\t\t}\n\t\t\t\tif dst == \":31\" {\n\t\t\t\t\treturn sentinelWithoutEligibleSlave\n\t\t\t\t}\n\n\t\t\t\tif dst == \":32\" {\n\t\t\t\t\treturn sentinelWithInvalidMapResponse\n\t\t\t\t}\n\n\t\t\t\tif dst == \":4\" {\n\t\t\t\t\treturn sentinelWithMasterRoleAsSlave\n\t\t\t\t}\n\t\t\t\tif dst == \":5\" {\n\t\t\t\t\treturn sentinelWithOKResponse\n\t\t\t\t}\n\t\t\t\tif dst == \":6\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDialFn: func() error { return v },\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif dst == \":7\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif dst == \":8\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"slave\"}}}}\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif client.sAddr != \":5\" && err == nil {\n\t\t\tt.Fatalf(\"expected error but got nil with sentinel %s\", client.sAddr)\n\t\t}\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif client.sConn == nil {\n\t\t\tt.Fatalf(\"unexpected nil sentinel conn\")\n\t\t}\n\t\tif client.mConn.Load() == nil {\n\t\t\tt.Fatalf(\"unexpected nil slave conn\")\n\t\t}\n\t\tclient.Close()\n\t})\n\n\tt.Run(\"Refresh retry 2\", func(t *testing.T) {\n\t\tv := errors.New(\"refresh err\")\n\t\ts0 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"2\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\ts1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"0\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"3\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tclient, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":0\" {\n\t\t\t\t\treturn s0\n\t\t\t\t}\n\t\t\t\tif dst == \":1\" {\n\t\t\t\t\treturn s1\n\t\t\t\t}\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult { return newErrResult(v) },\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif dst == \":3\" {\n\t\t\t\t\treturn &mockConn{\n\t\t\t\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif client.sConn == nil {\n\t\t\tt.Fatalf(\"unexpected nil sentinel conn\")\n\t\t}\n\t\tif client.mConn.Load() == nil {\n\t\t\tt.Fatalf(\"unexpected nil master conn\")\n\t\t}\n\t\tclient.Close()\n\t})\n\n\tt.Run(\"sentinel disconnect\", func(t *testing.T) {\n\t\ttrigger := make(chan error)\n\t\tdisconnect := int32(0)\n\t\ts0closed := int32(0)\n\t\tr3closed := int32(0)\n\t\ts0 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif atomic.LoadInt32(&disconnect) == 1 {\n\t\t\t\t\treturn newErrResult(errors.New(\"die\"))\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"3\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\tif err, ok := <-trigger; ok {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tatomic.StoreInt32(&s0closed, 1)\n\t\t\t},\n\t\t}\n\t\ts1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"2\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"3\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\ts2 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"0\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"4\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tr3 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif atomic.LoadInt32(&disconnect) == 1 {\n\t\t\t\t\treturn newErrResult(errors.New(\"die\"))\n\t\t\t\t}\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t},\n\t\t\tCloseFn: func() {\n\t\t\t\tatomic.StoreInt32(&r3closed, 1)\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\tif atomic.LoadInt32(&disconnect) == 1 {\n\t\t\t\t\treturn errClosing\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\tr4 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t},\n\t\t}\n\t\tclient, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":0\" {\n\t\t\t\t\treturn s0\n\t\t\t\t}\n\t\t\t\tif dst == \":1\" {\n\t\t\t\t\treturn s1\n\t\t\t\t}\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\treturn s2\n\t\t\t\t}\n\t\t\t\tif dst == \":3\" {\n\t\t\t\t\treturn r3\n\t\t\t\t}\n\t\t\t\tif dst == \":4\" {\n\t\t\t\t\treturn r4\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tatomic.StoreInt32(&disconnect, 1)\n\t\ttrigger <- errors.New(\"reconnect\")\n\t\tclose(trigger)\n\t\tfor {\n\t\t\tt.Log(\"wait switch master\")\n\t\t\tif client.mConn.Load().(*mockConn) == r4 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif atomic.LoadInt32(&s0closed) != 1 {\n\t\t\tt.Fatalf(\"s0 not closed\")\n\t\t}\n\t\tif atomic.LoadInt32(&r3closed) != 1 {\n\t\t\tt.Fatalf(\"r3 not closed\")\n\t\t}\n\t\tclient.Close()\n\t})\n}\n\nfunc TestSentinelRefreshAfterClose(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tfirst := true\n\ts0 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tif first {\n\t\t\t\tfirst = true\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newErrResult(ErrClosing), newErrResult(ErrClosing)}}\n\t\t},\n\t}\n\tm := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t},\n\t}\n\tclient, err := newSentinelClient(\n\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \":0\" {\n\t\t\t\treturn s0\n\t\t\t}\n\t\t\tif dst == \":1\" {\n\t\t\t\treturn m\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tclient.Close()\n\tif err := client.refresh(); err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestSentinelSwitchAfterClose(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tfirst := true\n\ts0 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"1\"},\n\t\t\t\t}}},\n\t\t\t}}\n\t\t},\n\t}\n\tm := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif first {\n\t\t\t\tfirst = false\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t}\n\t\t\treturn newErrResult(ErrClosing)\n\t\t},\n\t}\n\tclient, err := newSentinelClient(\n\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \":0\" {\n\t\t\t\treturn s0\n\t\t\t}\n\t\t\tif dst == \":1\" {\n\t\t\t\treturn m\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tclient.Close()\n\tif err := client._switchTarget(\":1\"); err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\n//gocyclo:ignore\nfunc TestSentinelClientDelegate(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\ts0 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"1\"},\n\t\t\t\t}}},\n\t\t\t}}\n\t\t},\n\t}\n\tm := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t},\n\t\tAddrFn: func() string { return \":1\" },\n\t}\n\tclient, err := newSentinelClient(\n\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \":0\" {\n\t\t\t\treturn s0\n\t\t\t}\n\t\t\tif dst == \":1\" {\n\t\t\t\treturn m\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tdefer client.Close()\n\n\tdisabledCacheClient, err := newSentinelClient(\n\t\t&ClientOption{InitAddress: []string{\":0\"}, DisableCache: true},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \":0\" {\n\t\t\t\treturn s0\n\t\t\t}\n\t\t\tif dst == \":1\" {\n\t\t\t\treturn m\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tdefer disabledCacheClient.Close()\n\n\tt.Run(\"Delegate MGetCache\", func(t *testing.T) {\n\t\tkeys := []string{\"key1\", \"key2\"}\n\t\texpectedCommand := []string{\"MGET\", \"key1\", \"key2\"}\n\n\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\tif !reflect.DeepEqual(cmd[0].Commands(), expectedCommand) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\tnewResult(RedisMessage{typ: '+', string: \"master\"}, nil),\n\t\t\t}}\n\t\t}\n\n\t\tret, err := MGetCache(disabledCacheClient, context.Background(), time.Second, keys)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error %v\", err)\n\t\t}\n\n\t\texpected := map[string]RedisMessage{\n\t\t\t\"key1\": {typ: '+', string: \"master\"},\n\t\t}\n\t\tif !reflect.DeepEqual(ret, expected) {\n\t\t\tt.Fatalf(\"unexpected result %v, expected %v\", ret, expected)\n\t\t}\n\t})\n\n\tt.Run(\"Nodes\", func(t *testing.T) {\n\t\tif nodes := client.Nodes(); len(nodes) != 1 || nodes[\":1\"] == nil {\n\t\t\tt.Fatalf(\"unexpected nodes\")\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif !reflect.DeepEqual(cmd.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)\n\t\t}\n\t\tif v, err := client.Do(context.Background(), c).ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoStream\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoStreamFn = func(cmd Completed) RedisResultStream {\n\t\t\treturn RedisResultStream{e: errors.New(cmd.Commands()[1])}\n\t\t}\n\t\tif s := client.DoStream(context.Background(), c); s.Error().Error() != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMulti\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoMultiFn = func(cmd ...Completed) *redisresults {\n\t\t\tif !reflect.DeepEqual(cmd[0].Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", cmd)\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"Do\"}, nil)}}\n\t\t}\n\t\tif len(client.DoMulti(context.Background())) != 0 {\n\t\t\tt.Fatalf(\"unexpected response length\")\n\t\t}\n\t\tif v, err := client.DoMulti(context.Background(), c)[0].ToString(); err != nil || v != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiStream\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"Do\").Build()\n\t\tm.DoMultiStreamFn = func(cmd ...Completed) MultiRedisResultStream {\n\t\t\treturn MultiRedisResultStream{e: errors.New(cmd[0].Commands()[1])}\n\t\t}\n\t\tif s := client.DoMultiStream(context.Background()); s.Error() != io.EOF {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t\tif s := client.DoMultiStream(context.Background(), c); s.Error().Error() != \"Do\" {\n\t\t\tt.Fatalf(\"unexpected response %v\", s.Error())\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tm.DoCacheFn = func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\tif !reflect.DeepEqual(cmd.Commands(), c.Commands()) || ttl != 100 {\n\t\t\t\tt.Fatalf(\"unexpected command %v, %v\", cmd, ttl)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"DoCache\"}, nil)\n\t\t}\n\t\tif v, err := client.DoCache(context.Background(), c, 100).ToString(); err != nil || v != \"DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate DoMultiCache\", func(t *testing.T) {\n\t\tc := client.B().Get().Key(\"DoCache\").Cache()\n\t\tm.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\tif !reflect.DeepEqual(multi[0].Cmd.Commands(), c.Commands()) || multi[0].TTL != 100 {\n\t\t\t\tt.Fatalf(\"unexpected command %v, %v\", multi[0].Cmd, multi[0].TTL)\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"DoCache\"}, nil)}}\n\t\t}\n\t\tif len(client.DoMultiCache(context.Background())) != 0 {\n\t\t\tt.Fatalf(\"unexpected response length\")\n\t\t}\n\t\tif v, err := client.DoMultiCache(context.Background(), CT(c, 100))[0].ToString(); err != nil || v != \"DoCache\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\thdl := func(message PubSubMessage) {}\n\t\tm.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tif !reflect.DeepEqual(subscribe.Commands(), c.Commands()) {\n\t\t\t\tt.Fatalf(\"unexpected command %v\", subscribe)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, hdl); err != nil {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Receive Redis Err\", func(t *testing.T) {\n\t\tc := client.B().Subscribe().Channel(\"ch\").Build()\n\t\te := &RedisError{}\n\t\tm.ReceiveFn = func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\treturn e\n\t\t}\n\t\tif err := client.Receive(context.Background(), c, func(message PubSubMessage) {}); err != e {\n\t\t\tt.Fatalf(\"unexpected response %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Delegate Close\", func(t *testing.T) {\n\t\tcalled := false\n\t\tm.CloseFn = func() { called = true }\n\t\tclient.Close()\n\t\tif !called {\n\t\t\tt.Fatalf(\"Close is not delegated\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Err\", func(t *testing.T) {\n\t\tv := errors.New(\"fn err\")\n\t\tif err := client.Dedicated(func(client DedicatedClient) error {\n\t\t\treturn v\n\t\t}); err != v {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Delegate\", func(t *testing.T) {\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tm.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tif err := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t\t}\n\t\t\tfor _, resp := range c.DoMulti(context.Background(), c.B().Get().Key(\"a\").Build()) {\n\t\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t})\n\n\tt.Run(\"Dedicate Delegate\", func(t *testing.T) {\n\t\tw := &mockWire{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\treturn newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)\n\t\t\t},\n\t\t\tDoMultiFn: func(cmd ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"Delegate\"}, nil)}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t}\n\t\tm.AcquireFn = func() wire {\n\t\t\treturn w\n\t\t}\n\t\tstored := false\n\t\tm.StoreFn = func(ww wire) {\n\t\t\tif ww != w {\n\t\t\t\tt.Fatalf(\"received unexpected wire %v\", ww)\n\t\t\t}\n\t\t\tstored = true\n\t\t}\n\t\tc, cancel := client.Dedicate()\n\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"a\").Build()).ToString(); err != nil || v != \"Delegate\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif v := c.DoMulti(context.Background()); len(v) != 0 {\n\t\t\tt.Fatalf(\"received unexpected response %v\", v)\n\t\t}\n\t\tfor _, resp := range c.DoMulti(context.Background(), c.B().Get().Key(\"a\").Build()) {\n\t\t\tif v, err := resp.ToString(); err != nil || v != \"Delegate\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t}\n\t\tif err := c.Receive(context.Background(), c.B().Ssubscribe().Channel(\"a\").Build(), func(msg PubSubMessage) {}); err != ErrClosing {\n\t\t\tt.Fatalf(\"unexpected ret %v\", err)\n\t\t}\n\t\tcancel()\n\t\tif !stored {\n\t\t\tt.Fatalf(\"Dedicated desn't put back the wire\")\n\t\t}\n\t})\n}\n\n//gocyclo:ignore\nfunc TestSentinelClientDelegateRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tsetup := func(t *testing.T) (client *sentinelClient, cb func()) {\n\t\tretry := uint32(0)\n\t\ttrigger := make(chan error)\n\t\ts0 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\tif atomic.LoadUint32(&retry) == 0 {\n\t\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t\t}}},\n\t\t\t\t\t}}\n\t\t\t\t}\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"2\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\tif err, ok := <-trigger; ok {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t\tErrorFn: func() error {\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t}\n\t\tm1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t\t}\n\t\t\t\tatomic.AddUint32(&retry, 1)\n\t\t\t\treturn newErrResult(ErrClosing)\n\t\t\t},\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\tatomic.AddUint32(&retry, 1)\n\t\t\t\treturn &redisresults{s: []RedisResult{newErrResult(ErrClosing)}}\n\t\t\t},\n\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\tatomic.AddUint32(&retry, 1)\n\t\t\t\treturn newErrResult(ErrClosing)\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\tatomic.AddUint32(&retry, 1)\n\t\t\t\treturn ErrClosing\n\t\t\t},\n\t\t}\n\t\tm2 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t\t}\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '+', string: \"OK\"}}\n\t\t\t},\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{{val: RedisMessage{typ: '+', string: \"OK\"}}}}\n\t\t\t},\n\t\t\tDoCacheFn: func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '+', string: \"OK\"}}\n\t\t\t},\n\t\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\tclient, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":0\" {\n\t\t\t\t\treturn s0\n\t\t\t\t}\n\t\t\t\tif dst == \":1\" {\n\t\t\t\t\treturn m1\n\t\t\t\t}\n\t\t\t\tif dst == \":2\" {\n\t\t\t\t\treturn m2\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn client, func() {\n\t\t\tfor atomic.LoadUint32(&retry) < 10 {\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t}\n\t\t\ttrigger <- errors.New(\"die\")\n\t\t\tclose(trigger)\n\t\t}\n\t}\n\n\tt.Run(\"Delegate Do\", func(t *testing.T) {\n\t\tclient, cb := setup(t)\n\n\t\tgo func() {\n\t\t\tcb()\n\t\t}()\n\n\t\tv, err := client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\t\tif err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\n\t\tclient.Close()\n\t})\n\n\tt.Run(\"Delegate DoMulti\", func(t *testing.T) {\n\t\tclient, cb := setup(t)\n\n\t\tgo func() {\n\t\t\tcb()\n\t\t}()\n\n\t\tv, err := client.DoMulti(context.Background(), client.B().Get().Key(\"k\").Build())[0].ToString()\n\t\tif err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\n\t\tclient.Close()\n\t})\n\n\tt.Run(\"Delegate DoCache\", func(t *testing.T) {\n\t\tclient, cb := setup(t)\n\n\t\tgo func() {\n\t\t\tcb()\n\t\t}()\n\n\t\tv, err := client.DoCache(context.Background(), client.B().Get().Key(\"k\").Cache(), time.Minute).ToString()\n\t\tif err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t\t}\n\n\t\tclient.Close()\n\t})\n\n\tt.Run(\"Delegate Receive\", func(t *testing.T) {\n\t\tclient, cb := setup(t)\n\n\t\tgo func() {\n\t\t\tcb()\n\t\t}()\n\n\t\terr := client.Receive(context.Background(), client.B().Subscribe().Channel(\"k\").Build(), func(msg PubSubMessage) {\n\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected resp %v\", err)\n\t\t}\n\n\t\tclient.Close()\n\t})\n}\n\n//gocyclo:ignore\nfunc TestSentinelClientPubSub(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tvar s0count, s0close, m1close, m2close, m4close int32\n\n\tmessages := make(chan PubSubMessage)\n\n\ts0 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tcount := atomic.AddInt32(&s0count, 1)\n\t\t\tif (count-1)%2 == 0 {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"2\"},\n\t\t\t\t}}},\n\t\t\t}}\n\t\t},\n\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tfor msg := range messages {\n\t\t\t\tfn(msg)\n\t\t\t}\n\t\t\treturn ErrClosing\n\t\t},\n\t\tCloseFn: func() { atomic.AddInt32(&s0close, 1) },\n\t}\n\tm1 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t}\n\t\t\treturn RedisResult{val: RedisMessage{typ: '+', string: \"OK\"}}\n\t\t},\n\t\tCloseFn: func() {\n\t\t\tatomic.AddInt32(&m1close, 1)\n\t\t},\n\t}\n\tm2 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"slave\"}}}}\n\t\t},\n\t\tCloseFn: func() { atomic.AddInt32(&m2close, 1) },\n\t}\n\ts3 := &mockConn{\n\t\tDoMultiFn: func(cmd ...Completed) *redisresults { return &redisresults{s: []RedisResult{newErrResult(errClosing)}} },\n\t}\n\tm4 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t}\n\t\t\treturn RedisResult{val: RedisMessage{typ: '+', string: \"OK4\"}}\n\t\t},\n\t\tCloseFn: func() { atomic.AddInt32(&m4close, 1) },\n\t}\n\n\tclient, err := newSentinelClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\":0\"},\n\t\t\tSentinel: SentinelOption{\n\t\t\t\tMasterSet: \"test\",\n\t\t\t},\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \":0\" {\n\t\t\t\treturn s0\n\t\t\t}\n\t\t\tif dst == \":1\" {\n\t\t\t\treturn m1\n\t\t\t}\n\t\t\tif dst == \":2\" {\n\t\t\t\treturn m2\n\t\t\t}\n\t\t\tif dst == \":3\" {\n\t\t\t\treturn s3\n\t\t\t}\n\t\t\tif dst == \":4\" {\n\t\t\t\treturn m4\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tmessages <- PubSubMessage{Channel: \"+sentinel\", Message: \"sentinel 000000  3\"}\n\n\tvar added bool\n\tfor !added {\n\t\tclient.mu.Lock()\n\t\tadded = client.sentinels.Front().Value.(string) == \":3\"\n\t\tclient.mu.Unlock()\n\t\tt.Log(\"wait +sentinel\")\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\t// switch to false master\n\tmessages <- PubSubMessage{Channel: \"+switch-master\", Message: \"test  1  2\"}\n\n\tfor atomic.LoadInt32(&m2close) != 2 {\n\t\tt.Log(\"wait false m2 to be close\", atomic.LoadInt32(&m2close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tfor atomic.LoadInt32(&s0count) != 3 {\n\t\tt.Log(\"wait s0 to be call third time\", atomic.LoadInt32(&s0count))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tv, err := client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\tif err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t}\n\n\t// switch to master by reboot\n\tmessages <- PubSubMessage{Channel: \"+reboot\", Message: \"master test  4\"}\n\n\tfor atomic.LoadInt32(&m1close) != 1 {\n\t\tt.Log(\"wait old m1 to be close\", atomic.LoadInt32(&m1close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tv, err = client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\tif err != nil || v != \"OK4\" {\n\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t}\n\n\tclose(messages)\n\tclient.Close()\n\n\tfor atomic.LoadInt32(&s0close) != 4 {\n\t\tt.Log(\"wait old s0 to be close\", atomic.LoadInt32(&s0close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tfor atomic.LoadInt32(&m4close) != 1 {\n\t\tt.Log(\"wait old m1 to be close\", atomic.LoadInt32(&m4close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n}\n\n//gocyclo:ignore\nfunc TestSentinelReplicaOnlyClientPubSub(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tvar s0count, s0close, slave1close, slave2close, slave4close int32\n\n\tmessages := make(chan PubSubMessage)\n\n\ts0 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\tcount := atomic.AddInt32(&s0count, 1)\n\t\t\tremainder := (count - 1) % 3\n\t\t\tif remainder == 0 {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t} else if remainder == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"2\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t} else {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '%', values: []RedisMessage{\n\t\t\t\t\t\t\t{typ: '+', string: \"ip\"}, {typ: '+', string: \"\"},\n\t\t\t\t\t\t\t{typ: '+', string: \"port\"}, {typ: '+', string: \"4\"},\n\t\t\t\t\t\t}},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t}\n\t\t},\n\t\tReceiveFn: func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\tfor msg := range messages {\n\t\t\t\tfn(msg)\n\t\t\t}\n\t\t\treturn ErrClosing\n\t\t},\n\t\tCloseFn: func() { atomic.AddInt32(&s0close, 1) },\n\t}\n\tslave1 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"slave\"}}}}\n\t\t\t}\n\t\t\treturn RedisResult{val: RedisMessage{typ: '+', string: \"OK\"}}\n\t\t},\n\t\tCloseFn: func() {\n\t\t\tatomic.AddInt32(&slave1close, 1)\n\t\t},\n\t}\n\tslave2 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t},\n\t\tCloseFn: func() { atomic.AddInt32(&slave2close, 1) },\n\t}\n\ts3 := &mockConn{\n\t\tDoMultiFn: func(cmd ...Completed) *redisresults { return &redisresults{s: []RedisResult{newErrResult(errClosing)}} },\n\t}\n\tslave4 := &mockConn{\n\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"slave\"}}}}\n\t\t\t}\n\t\t\treturn RedisResult{val: RedisMessage{typ: '+', string: \"OK4\"}}\n\t\t},\n\t\tCloseFn: func() { atomic.AddInt32(&slave4close, 1) },\n\t}\n\n\tclient, err := newSentinelClient(\n\t\t&ClientOption{\n\t\t\tInitAddress: []string{\":0\"},\n\t\t\tSentinel: SentinelOption{\n\t\t\t\tMasterSet: \"replicaonly\",\n\t\t\t},\n\t\t\tReplicaOnly: true,\n\t\t},\n\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\tif dst == \":0\" {\n\t\t\t\treturn s0\n\t\t\t}\n\t\t\tif dst == \":1\" {\n\t\t\t\treturn slave1\n\t\t\t}\n\t\t\tif dst == \":2\" {\n\t\t\t\treturn slave2\n\t\t\t}\n\t\t\tif dst == \":3\" {\n\t\t\t\treturn s3\n\t\t\t}\n\t\t\tif dst == \":4\" {\n\t\t\t\treturn slave4\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tnewRetryer(defaultRetryDelayFn),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\n\tmessages <- PubSubMessage{Channel: \"+sentinel\", Message: \"sentinel 000000  3\"}\n\n\tvar added bool\n\tfor !added {\n\t\tclient.mu.Lock()\n\t\tadded = client.sentinels.Front().Value.(string) == \":3\"\n\t\tclient.mu.Unlock()\n\t\tt.Log(\"wait +sentinel\")\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\t// event will be skipped because of first word\n\tmessages <- PubSubMessage{Channel: \"+slave\", Message: \"sla_ve 0:0 0 2 @ replicaonly 0 0\"}\n\n\tv, err := client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\tif err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t}\n\n\t// event will be skipped because of wrong master set name\n\tmessages <- PubSubMessage{Channel: \"+slave\", Message: \"slave 0:0 0 2 @ test 0 0\"}\n\n\tv, err = client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\tif err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t}\n\n\t// new slave with wrong role (2)\n\t// this won't directly switch to :2 like master\n\t// it will cause s0 to return :2 in DoMulti response\n\tmessages <- PubSubMessage{Channel: \"+slave\", Message: \"slave 0:0 0 2 @ replicaonly 0 0\"}\n\n\tfor atomic.LoadInt32(&slave2close) != 1 {\n\t\tt.Log(\"wait false slave2 to be close\", atomic.LoadInt32(&slave2close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tfor atomic.LoadInt32(&s0count) != 3 {\n\t\tt.Log(\"wait s0 to be call third time\", atomic.LoadInt32(&s0count))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tfor atomic.LoadInt32(&slave1close) != 1 {\n\t\tt.Log(\"wait for slave1 to close (and for client to use slave4)\", atomic.LoadInt32(&slave1close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tv, err = client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\tif err != nil || v != \"OK4\" {\n\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t}\n\n\t// switch to new slave by reboot\n\tmessages <- PubSubMessage{Channel: \"+reboot\", Message: \"slave 0:0 0 1 @ replicaonly 0 0\"}\n\n\tfor atomic.LoadInt32(&slave4close) != 1 {\n\t\tt.Log(\"wait old slave4 to be close\", atomic.LoadInt32(&slave4close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\n\tv, err = client.Do(context.Background(), client.B().Get().Key(\"k\").Build()).ToString()\n\tif err != nil || v != \"OK\" {\n\t\tt.Fatalf(\"unexpected resp %v %v\", v, err)\n\t}\n\n\tclose(messages)\n\tclient.Close()\n\n\tfor atomic.LoadInt32(&s0close) != 4 {\n\t\tt.Log(\"wait old s0 to be close\", atomic.LoadInt32(&s0close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n\tfor atomic.LoadInt32(&slave1close) != 2 {\n\t\tt.Log(\"wait old slave1 to be close\", atomic.LoadInt32(&slave1close))\n\t\ttime.Sleep(time.Millisecond * 100)\n\t}\n}\n\nfunc TestSentinelClientRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tSetupClientRetry(t, func(m *mockConn) Client {\n\t\tm.DoOverride = map[string]func(cmd Completed) RedisResult{\n\t\t\t\"SENTINEL SENTINELS masters\": func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{}}}\n\t\t\t},\n\t\t\t\"SENTINEL GET-MASTER-ADDR-BY-NAME masters\": func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"5\"},\n\t\t\t\t}}}\n\t\t\t},\n\t\t\t\"ROLE\": func(cmd Completed) RedisResult {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t},\n\t\t}\n\t\tm.ReceiveOverride = map[string]func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error{\n\t\t\t\"SUBSCRIBE +sentinel +slave -sdown +sdown +switch-master +reboot\": func(ctx context.Context, subscribe Completed, fn func(message PubSubMessage)) error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\tc, err := newSentinelClient(\n\t\t\t&ClientOption{\n\t\t\t\tInitAddress: []string{\":0\"},\n\t\t\t\tSentinel:    SentinelOption{MasterSet: \"masters\"},\n\t\t\t},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\treturn m\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn c\n\t})\n}\n\nfunc TestSentinelClientLoadingRetry(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\n\tsetup := func() (*sentinelClient, *mockConn, *mockConn) {\n\t\ts0 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult { return RedisResult{} },\n\t\t\tDoMultiFn: func(multi ...Completed) *redisresults {\n\t\t\t\treturn &redisresults{s: []RedisResult{\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{}}},\n\t\t\t\t\t{val: RedisMessage{typ: '*', values: []RedisMessage{\n\t\t\t\t\t\t{typ: '+', string: \"\"}, {typ: '+', string: \"1\"},\n\t\t\t\t\t}}},\n\t\t\t\t}}\n\t\t\t},\n\t\t}\n\t\tm1 := &mockConn{\n\t\t\tDoFn: func(cmd Completed) RedisResult {\n\t\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t\t}\n\t\t\t\treturn RedisResult{}\n\t\t\t},\n\t\t}\n\t\tclient, err := newSentinelClient(\n\t\t\t&ClientOption{InitAddress: []string{\":0\"}},\n\t\t\tfunc(dst string, opt *ClientOption) conn {\n\t\t\t\tif dst == \":0\" {\n\t\t\t\t\treturn s0\n\t\t\t\t}\n\t\t\t\tif dst == \":1\" {\n\t\t\t\t\treturn m1\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tnewRetryer(defaultRetryDelayFn),\n\t\t)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t\treturn client, s0, m1\n\t}\n\n\tt.Run(\"Do Retry on Loading\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t}\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tif v, err := client.Do(context.Background(), client.B().Get().Key(\"test\").Build()).ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t\tif attempts != 2 {\n\t\t\tt.Fatalf(\"expected 2 attempts, got %v\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"Do not retry on non-loading errors\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t}\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"ERR some other error\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tif err := client.Do(context.Background(), client.B().Get().Key(\"test\").Build()).Error(); err == nil {\n\t\t\tt.Fatal(\"expected error but got nil\")\n\t\t}\n\t\tif attempts != 1 {\n\t\t\tt.Fatalf(\"unexpected attempts %v, expected no retry\", attempts)\n\t\t}\n\t})\n\n\tt.Run(\"DoMulti Retry on Loading\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Build()\n\t\tresps := client.DoMulti(context.Background(), cmd)\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoCache Retry on Loading\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoCacheFn = func(cmd Cacheable, ttl time.Duration) RedisResult {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Cache()\n\t\tif v, err := client.DoCache(context.Background(), cmd, time.Minute).ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"DoMultiCache Retry on Loading\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoMultiCacheFn = func(multi ...CacheableTTL) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\n\t\tcmd := client.B().Get().Key(\"test\").Cache()\n\t\tresps := client.DoMultiCache(context.Background(), CT(cmd, time.Minute))\n\t\tif len(resps) != 1 {\n\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t}\n\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated Do Retry on Loading\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoFn = func(cmd Completed) RedisResult {\n\t\t\tif cmd == cmds.RoleCmd {\n\t\t\t\treturn RedisResult{val: RedisMessage{typ: '*', values: []RedisMessage{{typ: '+', string: \"master\"}}}}\n\t\t\t}\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)\n\t\t\t}\n\t\t\treturn newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)\n\t\t}\n\t\tm1.AcquireFn = func() wire { return &mockWire{DoFn: m1.DoFn} }\n\n\t\terr := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tif v, err := c.Do(context.Background(), c.B().Get().Key(\"test\").Build()).ToString(); err != nil || v != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"Dedicated DoMulti Retry on Loading\", func(t *testing.T) {\n\t\tclient, _, m1 := setup()\n\t\tattempts := 0\n\t\tm1.DoMultiFn = func(multi ...Completed) *redisresults {\n\t\t\tattempts++\n\t\t\tif attempts == 1 {\n\t\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '-', string: \"LOADING Redis is loading the dataset in memory\"}, nil)}}\n\t\t\t}\n\t\t\treturn &redisresults{s: []RedisResult{newResult(RedisMessage{typ: '+', string: \"OK\"}, nil)}}\n\t\t}\n\t\tm1.AcquireFn = func() wire { return &mockWire{DoMultiFn: m1.DoMultiFn} }\n\n\t\terr := client.Dedicated(func(c DedicatedClient) error {\n\t\t\tresps := c.DoMulti(context.Background(), c.B().Get().Key(\"test\").Build())\n\t\t\tif len(resps) != 1 {\n\t\t\t\tt.Fatalf(\"unexpected response length %v\", len(resps))\n\t\t\t}\n\t\t\tif v, err := resps[0].ToString(); err != nil || v != \"OK\" {\n\t\t\t\tt.Fatalf(\"unexpected response %v %v\", v, err)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected err %v\", err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "singleflight.go",
          "type": "blob",
          "size": 1.0595703125,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype call struct {\n\tts time.Time\n\tch chan struct{}\n\tcn int\n\tmu sync.Mutex\n}\n\nfunc (c *call) Do(ctx context.Context, fn func() error) error {\n\tc.mu.Lock()\n\tc.cn++\n\tch := c.ch\n\tif ch != nil {\n\t\tc.mu.Unlock()\n\t\tif ctxCh := ctx.Done(); ctxCh != nil {\n\t\t\tselect {\n\t\t\tcase <-ch:\n\t\t\tcase <-ctxCh:\n\t\t\t\treturn ctx.Err()\n\t\t\t}\n\t\t} else {\n\t\t\t<-ch\n\t\t}\n\t\treturn nil\n\t}\n\tch = make(chan struct{})\n\tc.ch = ch\n\tc.mu.Unlock()\n\treturn c.do(ch, fn)\n}\n\nfunc (c *call) LazyDo(threshold time.Duration, fn func() error) {\n\tc.mu.Lock()\n\tch := c.ch\n\tif ch != nil {\n\t\tc.mu.Unlock()\n\t\treturn\n\t}\n\tch = make(chan struct{})\n\tc.ch = ch\n\tc.cn++\n\tts := c.ts\n\tc.mu.Unlock()\n\tgo func(ts time.Time, ch chan struct{}, fn func() error) {\n\t\ttime.Sleep(time.Until(ts))\n\t\tc.do(ch, fn)\n\t}(ts.Add(threshold), ch, fn)\n}\n\nfunc (c *call) do(ch chan struct{}, fn func() error) (err error) {\n\terr = fn()\n\tc.mu.Lock()\n\tc.ch = nil\n\tc.cn = 0\n\tc.ts = time.Now()\n\tc.mu.Unlock()\n\tclose(ch)\n\treturn\n}\n\nfunc (c *call) suppressing() int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\treturn c.cn\n}\n"
        },
        {
          "name": "singleflight_test.go",
          "type": "blob",
          "size": 2.248046875,
          "content": "package rueidis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"runtime\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSingleFlight(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tvar calls, done, err int64\n\n\tsg := call{}\n\n\tfor i := 0; i < 1000; i++ {\n\t\tgo func() {\n\t\t\tif ret := sg.Do(context.Background(), func() error {\n\t\t\t\tatomic.AddInt64(&calls, 1)\n\t\t\t\t// wait for all goroutine invoked then return\n\t\t\t\tfor sg.suppressing() != 1000 {\n\t\t\t\t\truntime.Gosched()\n\t\t\t\t}\n\t\t\t\treturn errors.New(\"I should be the only ret\")\n\t\t\t}); ret != nil {\n\t\t\t\tatomic.AddInt64(&err, 1)\n\t\t\t}\n\n\t\t\tatomic.AddInt64(&done, 1)\n\t\t}()\n\t}\n\n\tfor atomic.LoadInt64(&done) != 1000 {\n\t\truntime.Gosched()\n\t}\n\n\tif atomic.LoadInt64(&calls) == 0 {\n\t\tt.Fatalf(\"singleflight not call at all\")\n\t}\n\n\tif v := atomic.LoadInt64(&calls); v != 1 {\n\t\tt.Fatalf(\"singleflight should suppress all concurrent calls, got: %v\", v)\n\t}\n\n\tif atomic.LoadInt64(&err) != 1 {\n\t\tt.Fatalf(\"singleflight should that one call get the return value\")\n\t}\n}\n\nfunc TestSingleFlightWithContext(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tch := make(chan struct{})\n\tsg := call{}\n\tgo func() {\n\t\tsg.Do(context.Background(), func() error {\n\t\t\t<-ch\n\t\t\treturn nil\n\t\t})\n\t}()\n\tfor sg.suppressing() != 1 {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tif err := sg.Do(ctx, func() error { return nil }); err != context.Canceled {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n\tgo func() {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\t\tif err := sg.Do(ctx, func() error { return nil }); err != nil {\n\t\t\tt.Errorf(\"unexpected err %v\", err)\n\t\t}\n\t}()\n\tfor sg.suppressing() != 3 {\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\tclose(ch)\n\tif err := sg.Do(context.Background(), func() error { return nil }); err != nil {\n\t\tt.Fatalf(\"unexpected err %v\", err)\n\t}\n}\n\nfunc TestSingleFlightLazyDo(t *testing.T) {\n\tdefer ShouldNotLeaked(SetupLeakDetection())\n\tch := make(chan struct{})\n\tsg := call{}\n\tsg.LazyDo(time.Second, func() error {\n\t\t<-ch\n\t\treturn nil\n\t})\n\tcn := 0\n\tsg.LazyDo(time.Second, func() error {\n\t\tcn++ // this should not occur\n\t\treturn nil\n\t})\n\tif cn != 0 {\n\t\tt.Fatalf(\"unexpected cn %v\", cn)\n\t}\n\tif sc := sg.suppressing(); sc != 1 {\n\t\tt.Fatalf(\"unexpected suppressing %v\", sc)\n\t}\n\tclose(ch)\n}\n"
        },
        {
          "name": "syncp.go",
          "type": "blob",
          "size": 4.83984375,
          "content": "package rueidis\n\nimport (\n\t\"time\"\n\n\t\"github.com/redis/rueidis/internal/util\"\n)\n\nvar (\n\tresultsp = util.NewPool(func(capacity int) *redisresults {\n\t\treturn &redisresults{s: make([]RedisResult, 0, capacity)}\n\t})\n\tmgetcmdsp = util.NewPool(func(capacity int) *mgetcmds {\n\t\treturn &mgetcmds{s: make([]Completed, 0, capacity)}\n\t})\n\tretryp = util.NewPool(func(capacity int) *retry {\n\t\treturn &retry{\n\t\t\tcIndexes: make([]int, 0, capacity),\n\t\t\tcommands: make([]Completed, 0, capacity),\n\t\t}\n\t})\n\tmgetcachecmdsp = util.NewPool(func(capacity int) *mgetcachecmds {\n\t\treturn &mgetcachecmds{s: make([]CacheableTTL, 0, capacity)}\n\t})\n\tretrycachep = util.NewPool(func(capacity int) *retrycache {\n\t\treturn &retrycache{\n\t\t\tcIndexes: make([]int, 0, capacity),\n\t\t\tcommands: make([]CacheableTTL, 0, capacity),\n\t\t}\n\t})\n\tbatchcachep = util.NewPool(func(capacity int) *batchcache {\n\t\treturn &batchcache{\n\t\t\tcIndexes: make([]int, 0, capacity),\n\t\t\tcommands: make([]CacheableTTL, 0, capacity),\n\t\t}\n\t})\n\tbatchcachemaps = util.NewPool(func(capacity int) *batchcachemap {\n\t\treturn &batchcachemap{m: make(map[uint16]*batchcache, capacity), n: capacity}\n\t})\n\tmuxslotsp = util.NewPool(func(capacity int) *muxslots {\n\t\treturn &muxslots{s: make([]int, 0, capacity)}\n\t})\n\tconnretryp = util.NewPool(func(capacity int) *connretry {\n\t\treturn &connretry{m: make(map[conn]*retry, capacity), n: capacity}\n\t})\n\tconncountp = util.NewPool(func(capacity int) *conncount {\n\t\treturn &conncount{m: make(map[conn]int, capacity), n: capacity}\n\t})\n\tconnretrycachep = util.NewPool(func(capacity int) *connretrycache {\n\t\treturn &connretrycache{m: make(map[conn]*retrycache, capacity), n: capacity}\n\t})\n)\n\ntype muxslots struct {\n\ts []int\n}\n\nfunc (r *muxslots) Capacity() int {\n\treturn cap(r.s)\n}\n\nfunc (r *muxslots) ResetLen(n int) {\n\tclear(r.s)\n\tr.s = r.s[:n]\n}\n\nfunc (r *muxslots) LessThen(n int) bool {\n\tcount := 0\n\tfor _, value := range r.s {\n\t\tif value > 0 {\n\t\t\tif count++; count == n {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\ntype redisresults struct {\n\ts []RedisResult\n}\n\nfunc (r *redisresults) Capacity() int {\n\treturn cap(r.s)\n}\n\nfunc (r *redisresults) ResetLen(n int) {\n\tclear(r.s)\n\tr.s = r.s[:n]\n}\n\ntype cacheentries struct {\n\te map[int]CacheEntry\n\tc int\n}\n\nfunc (c *cacheentries) Capacity() int {\n\treturn c.c\n}\n\nfunc (c *cacheentries) ResetLen(n int) {\n\tclear(c.e)\n}\n\nvar entriesp = util.NewPool(func(capacity int) *cacheentries {\n\treturn &cacheentries{e: make(map[int]CacheEntry, capacity), c: capacity}\n})\n\ntype mgetcachecmds struct {\n\ts []CacheableTTL\n}\n\nfunc (r *mgetcachecmds) Capacity() int {\n\treturn cap(r.s)\n}\n\nfunc (r *mgetcachecmds) ResetLen(n int) {\n\tclear(r.s)\n\tr.s = r.s[:n]\n}\n\ntype mgetcmds struct {\n\ts []Completed\n}\n\nfunc (r *mgetcmds) Capacity() int {\n\treturn cap(r.s)\n}\n\nfunc (r *mgetcmds) ResetLen(n int) {\n\tclear(r.s)\n\tr.s = r.s[:n]\n}\n\ntype retry struct {\n\tcIndexes []int\n\tcommands []Completed\n\taIndexes []int\n\tcAskings []Completed\n}\n\nfunc (r *retry) Capacity() int {\n\treturn cap(r.commands)\n}\n\nfunc (r *retry) ResetLen(n int) {\n\tclear(r.cIndexes)\n\tclear(r.commands)\n\tclear(r.aIndexes)\n\tclear(r.cAskings)\n\tr.cIndexes = r.cIndexes[:n]\n\tr.commands = r.commands[:n]\n\tr.aIndexes = r.aIndexes[:0]\n\tr.cAskings = r.cAskings[:0]\n}\n\ntype retrycache struct {\n\tcIndexes []int\n\tcommands []CacheableTTL\n\taIndexes []int\n\tcAskings []CacheableTTL\n}\n\nfunc (r *retrycache) Capacity() int {\n\treturn cap(r.commands)\n}\n\nfunc (r *retrycache) ResetLen(n int) {\n\tclear(r.cIndexes)\n\tclear(r.commands)\n\tclear(r.aIndexes)\n\tclear(r.cAskings)\n\tr.cIndexes = r.cIndexes[:n]\n\tr.commands = r.commands[:n]\n\tr.aIndexes = r.aIndexes[:0]\n\tr.cAskings = r.cAskings[:0]\n}\n\ntype batchcache struct {\n\tcIndexes []int\n\tcommands []CacheableTTL\n}\n\nfunc (r *batchcache) Capacity() int {\n\treturn cap(r.commands)\n}\n\nfunc (r *batchcache) ResetLen(n int) {\n\tclear(r.cIndexes)\n\tclear(r.commands)\n\tr.cIndexes = r.cIndexes[:n]\n\tr.commands = r.commands[:n]\n}\n\ntype batchcachemap struct {\n\tm map[uint16]*batchcache\n\tn int\n}\n\nfunc (r *batchcachemap) Capacity() int {\n\treturn r.n\n}\n\nfunc (r *batchcachemap) ResetLen(n int) {\n\tclear(r.m)\n}\n\ntype conncount struct {\n\tm map[conn]int\n\tn int\n}\n\nfunc (r *conncount) Capacity() int {\n\treturn r.n\n}\n\nfunc (r *conncount) ResetLen(n int) {\n\tclear(r.m)\n}\n\ntype connretry struct {\n\tm          map[conn]*retry\n\tn          int\n\tRetryDelay time.Duration // NOTE: This is not thread-safe.\n\tRedirects  uint32        // NOTE: This is not thread-safe.\n}\n\nfunc (r *connretry) Capacity() int {\n\treturn r.n\n}\n\nfunc (r *connretry) ResetLen(n int) {\n\tclear(r.m)\n\tr.Redirects = 0\n\tr.RetryDelay = time.Duration(-1) // No retry.\n}\n\ntype connretrycache struct {\n\tm          map[conn]*retrycache\n\tn          int\n\tRetryDelay time.Duration // NOTE: This is not thread-safe.\n\tRedirects  uint32        // NOTE: This is not thread-safe.\n}\n\nfunc (r *connretrycache) Capacity() int {\n\treturn r.n\n}\n\nfunc (r *connretrycache) ResetLen(n int) {\n\tclear(r.m)\n\tr.Redirects = 0\n\tr.RetryDelay = time.Duration(-1) // No retry.\n}\n"
        },
        {
          "name": "url.go",
          "type": "blob",
          "size": 3.234375,
          "content": "package rueidis\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// ParseURL parses a redis URL into ClientOption.\n// https://github.com/redis/redis-specifications/blob/master/uri/redis.txt\n// Example:\n//\n// redis://<user>:<password>@<host>:<port>/<db_number>\n// redis://<user>:<password>@<host>:<port>?addr=<host2>:<port2>&addr=<host3>:<port3>\n// unix://<user>:<password>@</path/to/redis.sock>?db=<db_number>\nfunc ParseURL(str string) (opt ClientOption, err error) {\n\tu, err := url.Parse(str)\n\tif err != nil {\n\t\treturn opt, err\n\t}\n\tparseAddr := func(hostport string) (host string, addr string) {\n\t\thost, port, _ := net.SplitHostPort(hostport)\n\t\tif host == \"\" {\n\t\t\thost = u.Host\n\t\t}\n\t\tif host == \"\" {\n\t\t\thost = \"localhost\"\n\t\t}\n\t\tif port == \"\" {\n\t\t\tport = \"6379\"\n\t\t}\n\t\treturn host, net.JoinHostPort(host, port)\n\t}\n\tswitch u.Scheme {\n\tcase \"unix\":\n\t\topt.DialFn = func(s string, dialer *net.Dialer, config *tls.Config) (conn net.Conn, err error) {\n\t\t\treturn dialer.Dial(\"unix\", s)\n\t\t}\n\t\topt.InitAddress = []string{strings.TrimSpace(u.Path)}\n\tcase \"rediss\", \"valkeys\":\n\t\topt.TLSConfig = &tls.Config{\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t}\n\tcase \"redis\", \"valkey\":\n\tdefault:\n\t\treturn opt, fmt.Errorf(\"redis: invalid URL scheme: %s\", u.Scheme)\n\t}\n\tif opt.InitAddress == nil {\n\t\thost, addr := parseAddr(u.Host)\n\t\topt.InitAddress = []string{addr}\n\t\tif opt.TLSConfig != nil {\n\t\t\topt.TLSConfig.ServerName = host\n\t\t}\n\t}\n\tif u.User != nil {\n\t\topt.Username = u.User.Username()\n\t\topt.Password, _ = u.User.Password()\n\t}\n\tif u.Scheme != \"unix\" {\n\t\tif ps := strings.Split(u.Path, \"/\"); len(ps) == 2 {\n\t\t\tif opt.SelectDB, err = strconv.Atoi(ps[1]); err != nil {\n\t\t\t\treturn opt, fmt.Errorf(\"redis: invalid database number: %q\", ps[1])\n\t\t\t}\n\t\t} else if len(ps) > 2 {\n\t\t\treturn opt, fmt.Errorf(\"redis: invalid URL path: %s\", u.Path)\n\t\t}\n\t}\n\tq := u.Query()\n\tif q.Has(\"db\") {\n\t\tif opt.SelectDB, err = strconv.Atoi(q.Get(\"db\")); err != nil {\n\t\t\treturn opt, fmt.Errorf(\"redis: invalid database number: %q\", q.Get(\"db\"))\n\t\t}\n\t}\n\tif q.Has(\"dial_timeout\") {\n\t\tif opt.Dialer.Timeout, err = time.ParseDuration(q.Get(\"dial_timeout\")); err != nil {\n\t\t\treturn opt, fmt.Errorf(\"redis: invalid dial timeout: %q\", q.Get(\"dial_timeout\"))\n\t\t}\n\t}\n\tif q.Has(\"write_timeout\") {\n\t\tif opt.Dialer.Timeout, err = time.ParseDuration(q.Get(\"write_timeout\")); err != nil {\n\t\t\treturn opt, fmt.Errorf(\"redis: invalid write timeout: %q\", q.Get(\"write_timeout\"))\n\t\t}\n\t}\n\tfor _, addr := range q[\"addr\"] {\n\t\t_, addr = parseAddr(addr)\n\t\topt.InitAddress = append(opt.InitAddress, addr)\n\t}\n\tif opt.TLSConfig != nil && q.Has(\"skip_verify\") {\n\t\tskipVerifyParam := q.Get(\"skip_verify\")\n\t\tif skipVerifyParam == \"\" {\n\t\t\topt.TLSConfig.InsecureSkipVerify = true\n\t\t} else {\n\t\t\tskipVerify, err := strconv.ParseBool(skipVerifyParam)\n\t\t\tif err != nil {\n\t\t\t\treturn opt, fmt.Errorf(\"valkey: invalid skip verify: %q\", skipVerifyParam)\n\t\t\t}\n\t\t\topt.TLSConfig.InsecureSkipVerify = skipVerify\n\t\t}\n\t}\n\topt.AlwaysRESP2 = q.Get(\"protocol\") == \"2\"\n\topt.DisableCache = q.Get(\"client_cache\") == \"0\"\n\topt.DisableRetry = q.Get(\"max_retries\") == \"0\"\n\topt.ClientName = q.Get(\"client_name\")\n\topt.Sentinel.MasterSet = q.Get(\"master_set\")\n\treturn\n}\n\nfunc MustParseURL(str string) ClientOption {\n\topt, err := ParseURL(str)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn opt\n}\n"
        },
        {
          "name": "url_test.go",
          "type": "blob",
          "size": 4.2958984375,
          "content": "package rueidis\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestParseURL(t *testing.T) {\n\tif opt, err := ParseURL(\"re dis://\"); err == nil {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"\"); !strings.HasPrefix(err.Error(), \"redis: invalid URL scheme\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"rediss://\"); err != nil || opt.TLSConfig == nil {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"valkeys://\"); err != nil || opt.TLSConfig == nil {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"unix://\"); err != nil || opt.DialFn == nil {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"valkey://\"); err != nil {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://\"); err != nil || opt.InitAddress[0] != \"localhost:6379\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://localhost\"); err != nil || opt.InitAddress[0] != \"localhost:6379\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?addr=:6380&addr=:6381\"); err != nil || opt.InitAddress[0] != \"localhost:6379\" || opt.InitAddress[1] != \"localhost:6380\" || opt.InitAddress[2] != \"localhost:6381\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://myhost:1234\"); err != nil || opt.InitAddress[0] != \"myhost:1234\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://ooo:xxx@\"); err != nil || opt.Username != \"ooo\" || opt.Password != \"xxx\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis:///1\"); err != nil || opt.SelectDB != 1 {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis:///a\"); !strings.HasPrefix(err.Error(), \"redis: invalid database number\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis:///1?db=a\"); !strings.HasPrefix(err.Error(), \"redis: invalid database number\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis:////1\"); !strings.HasPrefix(err.Error(), \"redis: invalid URL path\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?dial_timeout=a\"); !strings.HasPrefix(err.Error(), \"redis: invalid dial timeout\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?write_timeout=a\"); !strings.HasPrefix(err.Error(), \"redis: invalid write timeout\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"rediss://?skip_verify\"); err != nil || opt.TLSConfig == nil || !opt.TLSConfig.InsecureSkipVerify {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"rediss://?skip_verify=true\"); err != nil || opt.TLSConfig == nil || !opt.TLSConfig.InsecureSkipVerify {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"rediss://?skip_verify=a\"); !strings.HasPrefix(err.Error(), \"valkey: invalid skip verify\") {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?protocol=2\"); !opt.AlwaysRESP2 {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?client_cache=0\"); !opt.DisableCache {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?max_retries=0\"); !opt.DisableRetry {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?client_name=0\"); opt.ClientName != \"0\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"redis://?master_set=0\"); opt.Sentinel.MasterSet != \"0\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"rediss://myhost:6379\"); err != nil || opt.TLSConfig.ServerName != \"myhost\" {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n\tif opt, err := ParseURL(\"unix:///path/to/redis.sock?db=1\"); opt.DialFn == nil || opt.InitAddress[0] != \"/path/to/redis.sock\" || opt.SelectDB != 1 {\n\t\tt.Fatalf(\"unexpected %v %v\", opt, err)\n\t}\n}\n\nfunc TestMustParseURL(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); !strings.HasPrefix(err.(error).Error(), \"redis: invalid URL path\") {\n\t\t\tt.Failed()\n\t\t}\n\t}()\n\tMustParseURL(\"redis:////1\")\n}\n\nfunc TestMustParseURLUnix(t *testing.T) {\n\topt := MustParseURL(\"unix://\")\n\tif conn, err := opt.DialFn(\"\", &opt.Dialer, nil); !strings.Contains(err.Error(), \"unix\") {\n\t\tt.Fatalf(\"unexpected %v %v\", conn, err) // the error should be \"dial unix: missing address\"\n\t}\n}\n"
        }
      ]
    }
  ]
}