{
  "metadata": {
    "timestamp": 1736566902299,
    "page": 471,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Shopify/go-lua",
      "stars": 3177,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0224609375,
          "content": "lua-tests/\n.DS_[sS]tore"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.1044921875,
          "content": "[submodule \"lua-tests\"]\n\tpath = lua-tests\n\turl = https://github.com/Shopify/lua-tests.git\n\tbranch = go-lua\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Shopify Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.8935546875,
          "content": "[![Build Status](https://circleci.com/gh/Shopify/go-lua.png?circle-token=997f951c602c0c63a263eba92975428a49ee4c2e)](https://circleci.com/gh/Shopify/go-lua)\n[![GoDoc](https://godoc.org/github.com/Shopify/go-lua?status.png)](https://godoc.org/github.com/Shopify/go-lua)\n\nA Lua VM in pure Go\n===================\n\ngo-lua is a port of the Lua 5.2 VM to pure Go. It is compatible with binary files dumped by `luac`, from the [Lua reference implementation](http://www.lua.org/).\n\nThe motivation is to enable simple scripting of Go applications. For example, it is used to describe flows in [Shopify's](http://www.shopify.com/) load generation tool, Genghis.\n\nUsage\n-----\n\ngo-lua is intended to be used as a Go package. It does not include a command to run the interpreter. To start using the library, run:\n```sh\ngo get github.com/Shopify/go-lua\n```\n\nTo develop & test go-lua, you'll also need the [lua-tests](https://github.com/Shopify/lua-tests) submodule checked out:\n```sh\ngit submodule update --init\n```\n\nYou can then develop with the usual Go commands, e.g.:\n```sh\ngo build\ngo test -cover\n```\n\nA simple example that loads & runs a Lua script is:\n```go\npackage main\n\nimport \"github.com/Shopify/go-lua\"\n\nfunc main() {\n  l := lua.NewState()\n  lua.OpenLibraries(l)\n  if err := lua.DoFile(l, \"hello.lua\"); err != nil {\n    panic(err)\n  }\n}\n```\n\nStatus\n------\n\ngo-lua has been used in production in Shopify's load generation tool, Genghis, since May 2014, and is also part of Shopify's resiliency tooling.\n\nThe core VM and compiler has been ported and tested. The compiler is able to correctly process all Lua source files from the [Lua test suite](https://github.com/Shopify/lua-tests). The VM has been tested to correctly execute over a third of the Lua test cases.\n\nMost core Lua libraries are at least partially implemented. Prominent exceptions are regular expressions, coroutines and `string.dump`.\n\nWeak reference tables are not and will not be supported. go-lua uses the Go heap for Lua objects, and Go does not support weak references.\n\nBenchmarks\n----------\n\nBenchmark results shown here are taken from a Mid 2012 MacBook Pro Retina with a 2.6 GHz Core i7 CPU running OS X 10.10.2, go 1.4.2 and Lua 5.2.2.\n\nThe Fibonacci function can be written a few different ways to evaluate different performance characteristics of a language interpreter. The simplest way is as a recursive function:\n```lua\n  function fib(n)\n    if n == 0 then\n      return 0\n    elseif n == 1 then\n      return 1\n    end\n    return fib(n-1) + fib(n-2)\n  end\n```\n\nThis exercises the call stack implementation. When computing `fib(35)`, go-lua is about 6x slower than the C Lua interpreter. [Gopher-lua](https://github.com/yuin/gopher-lua) is about 20% faster than go-lua. Much of the performance difference between go-lua and gopher-lua comes from the inclusion of debug hooks in go-lua. The remainder is due to the call stack implementation - go-lua heap-allocates Lua stack frames with a separately allocated variant struct, as outlined above. Although it caches recently used stack frames, it is outperformed by the simpler statically allocated call stacks in gopher-lua.\n```\n  $ time lua fibr.lua\n  real  0m2.807s\n  user  0m2.795s\n  sys   0m0.006s\n  \n  $ time glua fibr.lua\n  real  0m14.528s\n  user  0m14.513s\n  sys   0m0.031s\n  \n  $ time go-lua fibr.lua\n  real  0m17.411s\n  user  0m17.514s\n  sys   0m1.287s\n```\n\nThe recursive Fibonacci function can be transformed into a tail-recursive variant:\n```lua\n  function fibt(n0, n1, c)\n    if c == 0 then\n      return n0\n    else if c == 1 then\n      return n1\n    end\n    return fibt(n1, n0+n1, c-1)\n  end\n  \n  function fib(n)\n    fibt(0, 1, n)\n  end\n```\n\nThe Lua interpreter detects and optimizes tail calls. This exhibits similar relative performance between the 3 interpreters, though gopher-lua edges ahead a little due to its simpler stack model and reduced bookkeeping.\n```\n  $ time lua fibt.lua\n  real  0m0.099s\n  user  0m0.096s\n  sys   0m0.002s\n\n  $ time glua fibt.lua\n  real  0m0.489s\n  user  0m0.484s\n  sys   0m0.005s\n\n  $ time go-lua fibt.lua\n  real  0m0.607s\n  user  0m0.610s\n  sys   0m0.068s\n```\n\nFinally, we can write an explicitly iterative implementation:\n```lua\n  function fib(n)\n    if n == 0 then\n      return 0\n    else if n == 1 then\n      return 1\n    end\n    local n0, n1 = 0, 1\n    for i = n, 2, -1 do\n      local tmp = n0 + n1\n      n0 = n1\n      n1 = tmp\n    end\n    return n1\n  end\n```\n\nThis exercises more of the bytecode interpreter’s inner loop. Here we see the performance impact of Go’s `switch` implementation. Both go-lua and gopher-lua are an order of magnitude slower than the C Lua interpreter.\n```\n  $ time lua fibi.lua\n  real  0m0.023s\n  user  0m0.020s\n  sys   0m0.003s\n\n  $ time glua fibi.lua\n  real  0m0.242s\n  user  0m0.235s\n  sys   0m0.005s\n\n  $ time go-lua fibi.lua\n  real  0m0.242s\n  user  0m0.240s\n  sys   0m0.028s\n```\n\nLicense\n-------\n\ngo-lua is licensed under the [MIT license](https://github.com/Shopify/go-lua/blob/master/LICENSE.md).\n"
        },
        {
          "name": "auxiliary.go",
          "type": "blob",
          "size": 15.404296875,
          "content": "package lua\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc functionName(l *State, d Debug) string {\n\tswitch {\n\tcase d.NameKind != \"\":\n\t\treturn fmt.Sprintf(\"function '%s'\", d.Name)\n\tcase d.What == \"main\":\n\t\treturn \"main chunk\"\n\tcase d.What == \"Go\":\n\t\tif pushGlobalFunctionName(l, d.callInfo) {\n\t\t\ts, _ := l.ToString(-1)\n\t\t\tl.Pop(1)\n\t\t\treturn fmt.Sprintf(\"function '%s'\", s)\n\t\t}\n\t\treturn \"?\"\n\t}\n\treturn fmt.Sprintf(\"function <%s:%d>\", d.ShortSource, d.LineDefined)\n}\n\nfunc countLevels(l *State) int {\n\tli, le := 1, 1\n\tfor _, ok := Stack(l, le); ok; _, ok = Stack(l, le) {\n\t\tli = le\n\t\tle *= 2\n\t}\n\tfor li < le {\n\t\tm := (li + le) / 2\n\t\tif _, ok := Stack(l, m); ok {\n\t\t\tli = m + 1\n\t\t} else {\n\t\t\tle = m\n\t\t}\n\t}\n\treturn le - 1\n}\n\n// Traceback creates and pushes a traceback of the stack l1. If message is not\n// nil it is appended at the beginning of the traceback. The level parameter\n// tells at which level to start the traceback.\nfunc Traceback(l, l1 *State, message string, level int) {\n\tconst levels1, levels2 = 12, 10\n\tlevels := countLevels(l1)\n\tmark := 0\n\tif levels > levels1+levels2 {\n\t\tmark = levels1\n\t}\n\tbuf := message\n\tif buf != \"\" {\n\t\tbuf += \"\\n\"\n\t}\n\tbuf += \"stack traceback:\"\n\tfor f, ok := Stack(l1, level); ok; f, ok = Stack(l1, level) {\n\t\tif level++; level == mark {\n\t\t\tbuf += \"\\n\\t...\"\n\t\t\tlevel = levels - levels2\n\t\t} else {\n\t\t\td, _ := Info(l1, \"Slnt\", f)\n\t\t\tbuf += \"\\n\\t\" + d.ShortSource + \":\"\n\t\t\tif d.CurrentLine > 0 {\n\t\t\t\tbuf += fmt.Sprintf(\"%d:\", d.CurrentLine)\n\t\t\t}\n\t\t\tbuf += \" in \" + functionName(l, d)\n\t\t\tif d.IsTailCall {\n\t\t\t\tbuf += \"\\n\\t(...tail calls...)\"\n\t\t\t}\n\t\t}\n\t}\n\tl.PushString(buf)\n}\n\n// MetaField pushes onto the stack the field event from the metatable of the\n// object at index. If the object does not have a metatable, or if the\n// metatable does not have this field, returns false and pushes nothing.\nfunc MetaField(l *State, index int, event string) bool {\n\tif !l.MetaTable(index) {\n\t\treturn false\n\t}\n\tl.PushString(event)\n\tl.RawGet(-2)\n\tif l.IsNil(-1) {\n\t\tl.Pop(2) // remove metatable and metafield\n\t\treturn false\n\t}\n\tl.Remove(-2) // remove only metatable\n\treturn true\n}\n\n// CallMeta calls a metamethod.\n//\n// If the object at index has a metatable and this metatable has a field event,\n// this function calls this field passing the object as its only argument. In\n// this case this function returns true and pushes onto the stack the value\n// returned by the call. If there is no metatable or no metamethod, this\n// function returns false (without pushing any value on the stack).\nfunc CallMeta(l *State, index int, event string) bool {\n\tindex = l.AbsIndex(index)\n\tif !MetaField(l, index, event) {\n\t\treturn false\n\t}\n\tl.PushValue(index)\n\tl.Call(1, 1)\n\treturn true\n}\n\n// ArgumentError raises an error with a standard message that includes extraMessage as a comment.\n//\n// This function never returns. It is an idiom to use it in Go functions as\n//  lua.ArgumentError(l, args, \"message\")\n//  panic(\"unreachable\")\nfunc ArgumentError(l *State, argCount int, extraMessage string) {\n\tf, ok := Stack(l, 0)\n\tif !ok { // no stack frame?\n\t\tErrorf(l, \"bad argument #%d (%s)\", argCount, extraMessage)\n\t\treturn\n\t}\n\td, _ := Info(l, \"n\", f)\n\tif d.NameKind == \"method\" {\n\t\targCount--         // do not count 'self'\n\t\tif argCount == 0 { // error is in the self argument itself?\n\t\t\tErrorf(l, \"calling '%s' on bad self (%s)\", d.Name, extraMessage)\n\t\t\treturn\n\t\t}\n\t}\n\tif d.Name == \"\" {\n\t\tif pushGlobalFunctionName(l, f) {\n\t\t\td.Name, _ = l.ToString(-1)\n\t\t} else {\n\t\t\td.Name = \"?\"\n\t\t}\n\t}\n\tErrorf(l, \"bad argument #%d to '%s' (%s)\", argCount, d.Name, extraMessage)\n}\n\nfunc findField(l *State, objectIndex, level int) bool {\n\tif level == 0 || !l.IsTable(-1) {\n\t\treturn false\n\t}\n\tfor l.PushNil(); l.Next(-2); l.Pop(1) { // for each pair in table\n\t\tif l.IsString(-2) { // ignore non-string keys\n\t\t\tif l.RawEqual(objectIndex, -1) { // found object?\n\t\t\t\tl.Pop(1) // remove value (but keep name)\n\t\t\t\treturn true\n\t\t\t} else if findField(l, objectIndex, level-1) { // try recursively\n\t\t\t\tl.Remove(-2) // remove table (but keep name)\n\t\t\t\tl.PushString(\".\")\n\t\t\t\tl.Insert(-2) // place \".\" between the two names\n\t\t\t\tl.Concat(3)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc pushGlobalFunctionName(l *State, f Frame) bool {\n\ttop := l.Top()\n\tInfo(l, \"f\", f) // push function\n\tl.PushGlobalTable()\n\tif findField(l, top+1, 2) {\n\t\tl.Copy(-1, top+1) // move name to proper place\n\t\tl.Pop(2)          // remove pushed values\n\t\treturn true\n\t}\n\tl.SetTop(top) // remove function and global table\n\treturn false\n}\n\nfunc typeError(l *State, argCount int, typeName string) {\n\tArgumentError(l, argCount, l.PushString(typeName+\" expected, got \"+TypeNameOf(l, argCount)))\n}\n\nfunc tagError(l *State, argCount int, tag Type) { typeError(l, argCount, tag.String()) }\n\n// Where pushes onto the stack a string identifying the current position of\n// the control at level in the call stack. Typically this string has the\n// following format:\n//   chunkname:currentline:\n// Level 0 is the running function, level 1 is the function that called the\n// running function, etc.\n//\n// This function is used to build a prefix for error messages.\nfunc Where(l *State, level int) {\n\tif f, ok := Stack(l, level); ok { // check function at level\n\t\tar, _ := Info(l, \"Sl\", f) // get info about it\n\t\tif ar.CurrentLine > 0 {   // is there info?\n\t\t\tl.PushString(fmt.Sprintf(\"%s:%d: \", ar.ShortSource, ar.CurrentLine))\n\t\t\treturn\n\t\t}\n\t}\n\tl.PushString(\"\") // else, no information available...\n}\n\n// Errorf raises an error. The error message format is given by format plus\n// any extra arguments, following the same rules as PushFString. It also adds\n// at the beginning of the message the file name and the line number where\n// the error occurred, if this information is available.\n//\n// This function never returns. It is an idiom to use it in Go functions as:\n//   lua.Errorf(l, args)\n//   panic(\"unreachable\")\nfunc Errorf(l *State, format string, a ...interface{}) {\n\tWhere(l, 1)\n\tl.PushFString(format, a...)\n\tl.Concat(2)\n\tl.Error()\n}\n\n// ToStringMeta converts any Lua value at the given index to a Go string in a\n// reasonable format. The resulting string is pushed onto the stack and also\n// returned by the function.\n//\n// If the value has a metatable with a \"__tostring\" field, then ToStringMeta\n// calls the corresponding metamethod with the value as argument, and uses\n// the result of the call as its result.\nfunc ToStringMeta(l *State, index int) (string, bool) {\n\tif !CallMeta(l, index, \"__tostring\") {\n\t\tswitch l.TypeOf(index) {\n\t\tcase TypeNumber, TypeString:\n\t\t\tl.PushValue(index)\n\t\tcase TypeBoolean:\n\t\t\tif l.ToBoolean(index) {\n\t\t\t\tl.PushString(\"true\")\n\t\t\t} else {\n\t\t\t\tl.PushString(\"false\")\n\t\t\t}\n\t\tcase TypeNil:\n\t\t\tl.PushString(\"nil\")\n\t\tdefault:\n\t\t\tl.PushFString(\"%s: %p\", TypeNameOf(l, index), l.ToValue(index))\n\t\t}\n\t}\n\treturn l.ToString(-1)\n}\n\n// NewMetaTable returns false if the registry already has the key name. Otherwise,\n// creates a new table to be used as a metatable for userdata, adds it to the\n// registry with key name, and returns true.\n//\n// In both cases it pushes onto the stack the final value associated with name in\n// the registry.\nfunc NewMetaTable(l *State, name string) bool {\n\tif MetaTableNamed(l, name); !l.IsNil(-1) {\n\t\treturn false\n\t}\n\tl.Pop(1)\n\tl.NewTable()\n\tl.PushValue(-1)\n\tl.SetField(RegistryIndex, name)\n\treturn true\n}\n\nfunc MetaTableNamed(l *State, name string) {\n\tl.Field(RegistryIndex, name)\n}\n\nfunc SetMetaTableNamed(l *State, name string) {\n\tMetaTableNamed(l, name)\n\tl.SetMetaTable(-2)\n}\n\nfunc TestUserData(l *State, index int, name string) interface{} {\n\tif d := l.ToUserData(index); d != nil {\n\t\tif l.MetaTable(index) {\n\t\t\tif MetaTableNamed(l, name); !l.RawEqual(-1, -2) {\n\t\t\t\td = nil\n\t\t\t}\n\t\t\tl.Pop(2)\n\t\t\treturn d\n\t\t}\n\t}\n\treturn nil\n}\n\n// CheckUserData checks whether the function argument at index is a userdata\n// of the type name (see NewMetaTable) and returns the userdata (see\n// ToUserData).\nfunc CheckUserData(l *State, index int, name string) interface{} {\n\tif d := TestUserData(l, index, name); d != nil {\n\t\treturn d\n\t}\n\ttypeError(l, index, name)\n\tpanic(\"unreachable\")\n}\n\n// CheckType checks whether the function argument at index has type t. See Type for the encoding of types for t.\nfunc CheckType(l *State, index int, t Type) {\n\tif l.TypeOf(index) != t {\n\t\ttagError(l, index, t)\n\t}\n}\n\n// CheckAny checks whether the function has an argument of any type (including nil) at position index.\nfunc CheckAny(l *State, index int) {\n\tif l.TypeOf(index) == TypeNone {\n\t\tArgumentError(l, index, \"value expected\")\n\t}\n}\n\n// ArgumentCheck checks whether cond is true. If not, raises an error with a standard message.\nfunc ArgumentCheck(l *State, cond bool, index int, extraMessage string) {\n\tif !cond {\n\t\tArgumentError(l, index, extraMessage)\n\t}\n}\n\n// CheckString checks whether the function argument at index is a string and returns this string.\n//\n// This function uses ToString to get its result, so all conversions and caveats of that function apply here.\nfunc CheckString(l *State, index int) string {\n\tif s, ok := l.ToString(index); ok {\n\t\treturn s\n\t}\n\ttagError(l, index, TypeString)\n\tpanic(\"unreachable\")\n}\n\n// OptString returns the string at index if it is a string. If this argument is\n// absent or is nil, returns def. Otherwise, raises an error.\nfunc OptString(l *State, index int, def string) string {\n\tif l.IsNoneOrNil(index) {\n\t\treturn def\n\t}\n\treturn CheckString(l, index)\n}\n\nfunc CheckNumber(l *State, index int) float64 {\n\tn, ok := l.ToNumber(index)\n\tif !ok {\n\t\ttagError(l, index, TypeNumber)\n\t}\n\treturn n\n}\n\nfunc OptNumber(l *State, index int, def float64) float64 {\n\tif l.IsNoneOrNil(index) {\n\t\treturn def\n\t}\n\treturn CheckNumber(l, index)\n}\n\nfunc CheckInteger(l *State, index int) int {\n\ti, ok := l.ToInteger(index)\n\tif !ok {\n\t\ttagError(l, index, TypeNumber)\n\t}\n\treturn i\n}\n\nfunc OptInteger(l *State, index, def int) int {\n\tif l.IsNoneOrNil(index) {\n\t\treturn def\n\t}\n\treturn CheckInteger(l, index)\n}\n\nfunc CheckUnsigned(l *State, index int) uint {\n\ti, ok := l.ToUnsigned(index)\n\tif !ok {\n\t\ttagError(l, index, TypeNumber)\n\t}\n\treturn i\n}\n\nfunc OptUnsigned(l *State, index int, def uint) uint {\n\tif l.IsNoneOrNil(index) {\n\t\treturn def\n\t}\n\treturn CheckUnsigned(l, index)\n}\n\nfunc TypeNameOf(l *State, index int) string { return l.TypeOf(index).String() }\n\nfunc SetFunctions(l *State, functions []RegistryFunction, upValueCount uint8) {\n\tuvCount := int(upValueCount)\n\tCheckStackWithMessage(l, uvCount, \"too many upvalues\")\n\tfor _, r := range functions { // fill the table with given functions\n\t\tfor i := 0; i < uvCount; i++ { // copy upvalues to the top\n\t\t\tl.PushValue(-uvCount)\n\t\t}\n\t\tl.PushGoClosure(r.Function, upValueCount) // closure with those upvalues\n\t\tl.SetField(-(uvCount + 2), r.Name)\n\t}\n\tl.Pop(uvCount) // remove upvalues\n}\n\nfunc CheckStackWithMessage(l *State, space int, message string) {\n\t// keep some extra space to run error routines, if needed\n\tif !l.CheckStack(space + MinStack) {\n\t\tif message != \"\" {\n\t\t\tErrorf(l, \"stack overflow (%s)\", message)\n\t\t} else {\n\t\t\tErrorf(l, \"stack overflow\")\n\t\t}\n\t}\n}\n\nfunc CheckOption(l *State, index int, def string, list []string) int {\n\tvar name string\n\tif def == \"\" {\n\t\tname = OptString(l, index, def)\n\t} else {\n\t\tname = CheckString(l, index)\n\t}\n\tfor i, s := range list {\n\t\tif name == s {\n\t\t\treturn i\n\t\t}\n\t}\n\tArgumentError(l, index, l.PushFString(\"invalid option '%s'\", name))\n\tpanic(\"unreachable\")\n}\n\nfunc SubTable(l *State, index int, name string) bool {\n\tl.Field(index, name)\n\tif l.IsTable(-1) {\n\t\treturn true // table already there\n\t}\n\tl.Pop(1) // remove previous result\n\tindex = l.AbsIndex(index)\n\tl.NewTable()\n\tl.PushValue(-1)         // copy to be left at top\n\tl.SetField(index, name) // assign new table to field\n\treturn false            // did not find table there\n}\n\n// Require calls function f with string name as an argument and sets the call\n// result in package.loaded[name], as if that function had been called\n// through require.\n//\n// If global is true, also stores the result into global name.\n//\n// Leaves a copy of that result on the stack.\nfunc Require(l *State, name string, f Function, global bool) {\n\tl.PushGoFunction(f)\n\tl.PushString(name) // argument to f\n\tl.Call(1, 1)       // open module\n\tSubTable(l, RegistryIndex, \"_LOADED\")\n\tl.PushValue(-2)      // make copy of module (call result)\n\tl.SetField(-2, name) // _LOADED[name] = module\n\tl.Pop(1)             // remove _LOADED table\n\tif global {\n\t\tl.PushValue(-1)   // copy of module\n\t\tl.SetGlobal(name) // _G[name] = module\n\t}\n}\n\nfunc NewLibraryTable(l *State, functions []RegistryFunction) { l.CreateTable(0, len(functions)) }\n\nfunc NewLibrary(l *State, functions []RegistryFunction) {\n\tNewLibraryTable(l, functions)\n\tSetFunctions(l, functions, 0)\n}\n\nfunc skipComment(r *bufio.Reader) (bool, error) {\n\tbom := \"\\xEF\\xBB\\xBF\"\n\tif ba, err := r.Peek(len(bom)); err != nil && err != io.EOF {\n\t\treturn false, err\n\t} else if string(ba) == bom {\n\t\t_, _ = r.Read(ba)\n\t}\n\tif c, _, err := r.ReadRune(); err != nil {\n\t\tif err == io.EOF {\n\t\t\terr = nil\n\t\t}\n\t\treturn false, err\n\t} else if c == '#' {\n\t\t_, err = r.ReadBytes('\\n')\n\t\tif err == io.EOF {\n\t\t\terr = nil\n\t\t}\n\t\treturn true, err\n\t}\n\treturn false, r.UnreadRune()\n}\n\nfunc LoadFile(l *State, fileName, mode string) error {\n\tvar f *os.File\n\tfileNameIndex := l.Top() + 1\n\tfileError := func(what string) error {\n\t\tfileName, _ := l.ToString(fileNameIndex)\n\t\tl.PushFString(\"cannot %s %s\", what, fileName[1:])\n\t\tl.Remove(fileNameIndex)\n\t\treturn FileError\n\t}\n\tif fileName == \"\" {\n\t\tl.PushString(\"=stdin\")\n\t\tf = os.Stdin\n\t} else {\n\t\tl.PushString(\"@\" + fileName)\n\t\tvar err error\n\t\tif f, err = os.Open(fileName); err != nil {\n\t\t\treturn fileError(\"open\")\n\t\t}\n\t}\n\tr := bufio.NewReader(f)\n\tif skipped, err := skipComment(r); err != nil {\n\t\tl.SetTop(fileNameIndex)\n\t\treturn fileError(\"read\")\n\t} else if skipped {\n\t\tr = bufio.NewReader(io.MultiReader(strings.NewReader(\"\\n\"), r))\n\t}\n\ts, _ := l.ToString(-1)\n\terr := l.Load(r, s, mode)\n\tif f != os.Stdin {\n\t\t_ = f.Close()\n\t}\n\tswitch err {\n\tcase nil, SyntaxError, MemoryError: // do nothing\n\tdefault:\n\t\tl.SetTop(fileNameIndex)\n\t\treturn fileError(\"read\")\n\t}\n\tl.Remove(fileNameIndex)\n\treturn err\n}\n\nfunc LoadString(l *State, s string) error { return LoadBuffer(l, s, s, \"\") }\n\nfunc LoadBuffer(l *State, b, name, mode string) error {\n\treturn l.Load(strings.NewReader(b), name, mode)\n}\n\n// NewStateEx creates a new Lua state. It calls NewState and then sets a panic\n// function that prints an error message to the standard error output in case\n// of fatal errors.\n//\n// Returns the new state.\nfunc NewStateEx() *State {\n\tl := NewState()\n\tif l != nil {\n\t\t_ = AtPanic(l, func(l *State) int {\n\t\t\ts, _ := l.ToString(-1)\n\t\t\tfmt.Fprintf(os.Stderr, \"PANIC: unprotected error in call to Lua API (%s)\\n\", s)\n\t\t\treturn 0\n\t\t})\n\t}\n\treturn l\n}\n\nfunc LengthEx(l *State, index int) int {\n\tl.Length(index)\n\tif length, ok := l.ToInteger(-1); ok {\n\t\tl.Pop(1)\n\t\treturn length\n\t}\n\tErrorf(l, \"object length is not a number\")\n\tpanic(\"unreachable\")\n}\n\n// FileResult produces the return values for file-related functions in the standard\n// library (io.open, os.rename, file:seek, etc.).\nfunc FileResult(l *State, err error, filename string) int {\n\tif err == nil {\n\t\tl.PushBoolean(true)\n\t\treturn 1\n\t}\n\tl.PushNil()\n\tif filename != \"\" {\n\t\tl.PushString(filename + \": \" + err.Error())\n\t} else {\n\t\tl.PushString(err.Error())\n\t}\n\tl.PushInteger(0) // TODO map err to errno\n\treturn 3\n}\n\n// DoFile loads and runs the given file.\nfunc DoFile(l *State, fileName string) error {\n\tif err := LoadFile(l, fileName, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn l.ProtectedCall(0, MultipleReturns, 0)\n}\n\n// DoString loads and runs the given string.\nfunc DoString(l *State, s string) error {\n\tif err := LoadString(l, s); err != nil {\n\t\treturn err\n\t}\n\treturn l.ProtectedCall(0, MultipleReturns, 0)\n}\n"
        },
        {
          "name": "auxiliary_test.go",
          "type": "blob",
          "size": 1.0302734375,
          "content": "package lua\n\nimport \"testing\"\n\nfunc TestLoadFileSyntaxError(t *testing.T) {\n\tl := NewState()\n\terr := LoadFile(l, \"fixtures/syntax_error.lua\", \"\")\n\tif err != SyntaxError {\n\t\tt.Error(\"didn't return SyntaxError on file with syntax error\")\n\t}\n\tif l.Top() != 1 {\n\t\tt.Error(\"didn't push anything to the stack\")\n\t}\n\tif l.IsString(-1) != true {\n\t\tt.Error(\"didn't push a string to the stack\")\n\t}\n\testr, _ := l.ToString(-1)\n\tif estr != \"fixtures/syntax_error.lua:4: syntax error near <eof>\" {\n\t\tt.Error(\"didn't push the correct error string\")\n\t}\n}\n\nfunc TestLoadStringSyntaxError(t *testing.T) {\n\tl := NewState()\n\terr := LoadString(l, \"this_is_a_syntax_error\")\n\tif err != SyntaxError {\n\t\tt.Error(\"didn't return SyntaxError on string with syntax error\")\n\t}\n\tif l.Top() != 1 {\n\t\tt.Error(\"didn't push anything to the stack\")\n\t}\n\tif l.IsString(-1) != true {\n\t\tt.Error(\"didn't push a string to the stack\")\n\t}\n\testr, _ := l.ToString(-1)\n\tif estr != \"[string \\\"this_is_a_syntax_error\\\"]:1: syntax error near <eof>\" {\n\t\tt.Error(\"didn't push the correct error string\")\n\t}\n}\n"
        },
        {
          "name": "base.go",
          "type": "blob",
          "size": 7.248046875,
          "content": "package lua\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc next(l *State) int {\n\tCheckType(l, 1, TypeTable)\n\tl.SetTop(2)\n\tif l.Next(1) {\n\t\treturn 2\n\t}\n\tl.PushNil()\n\treturn 1\n}\n\nfunc pairs(method string, isZero bool, iter Function) Function {\n\treturn func(l *State) int {\n\t\tif hasMetamethod := MetaField(l, 1, method); !hasMetamethod {\n\t\t\tCheckType(l, 1, TypeTable) // argument must be a table\n\t\t\tl.PushGoFunction(iter)     // will return generator,\n\t\t\tl.PushValue(1)             // state,\n\t\t\tif isZero {                // and initial value\n\t\t\t\tl.PushInteger(0)\n\t\t\t} else {\n\t\t\t\tl.PushNil()\n\t\t\t}\n\t\t} else {\n\t\t\tl.PushValue(1) // argument 'self' to metamethod\n\t\t\tl.Call(1, 3)   // get 3 values from metamethod\n\t\t}\n\t\treturn 3\n\t}\n}\n\nfunc intPairs(l *State) int {\n\ti := CheckInteger(l, 2)\n\tCheckType(l, 1, TypeTable)\n\ti++ // next value\n\tl.PushInteger(i)\n\tl.RawGetInt(1, i)\n\tif l.IsNil(-1) {\n\t\treturn 1\n\t}\n\treturn 2\n}\n\nfunc finishProtectedCall(l *State, status bool) int {\n\tif !l.CheckStack(1) {\n\t\tl.SetTop(0) // create space for return values\n\t\tl.PushBoolean(false)\n\t\tl.PushString(\"stack overflow\")\n\t\treturn 2 // return false, message\n\t}\n\tl.PushBoolean(status) // first result (status)\n\tl.Replace(1)          // put first result in the first slot\n\treturn l.Top()\n}\n\nfunc protectedCallContinuation(l *State) int {\n\t_, shouldYield, _ := l.Context()\n\treturn finishProtectedCall(l, shouldYield)\n}\n\nfunc loadHelper(l *State, s error, e int) int {\n\tif s == nil {\n\t\tif e != 0 {\n\t\t\tl.PushValue(e)\n\t\t\tif _, ok := SetUpValue(l, -2, 1); !ok {\n\t\t\t\tl.Pop(1)\n\t\t\t}\n\t\t}\n\t\treturn 1\n\t}\n\tl.PushNil()\n\tl.Insert(-2)\n\treturn 2\n}\n\ntype genericReader struct {\n\tl *State\n\tr *strings.Reader\n\te error\n}\n\nfunc (r *genericReader) Read(b []byte) (n int, err error) {\n\tif r.e != nil {\n\t\treturn 0, r.e\n\t}\n\tif l := r.l; r.r == nil {\n\t\tCheckStackWithMessage(l, 2, \"too many nested functions\")\n\t\tl.PushValue(1)\n\t\tif l.Call(0, 1); l.IsNil(-1) {\n\t\t\tl.Pop(1)\n\t\t\treturn 0, io.EOF\n\t\t} else if !l.IsString(-1) {\n\t\t\tErrorf(l, \"reader function must return a string\")\n\t\t}\n\t\tif s, ok := l.ToString(-1); ok {\n\t\t\tr.r = strings.NewReader(s)\n\t\t} else {\n\t\t\treturn 0, io.EOF\n\t\t}\n\t}\n\tif n, err = r.r.Read(b); err == io.EOF {\n\t\tr.r, err = nil, nil\n\t} else if err != nil {\n\t\tr.e = err\n\t}\n\treturn\n}\n\nvar baseLibrary = []RegistryFunction{\n\t{\"assert\", func(l *State) int {\n\t\tif !l.ToBoolean(1) {\n\t\t\tErrorf(l, \"%s\", OptString(l, 2, \"assertion failed!\"))\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t\treturn l.Top()\n\t}},\n\t{\"collectgarbage\", func(l *State) int {\n\t\tswitch opt, _ := OptString(l, 1, \"collect\"), OptInteger(l, 2, 0); opt {\n\t\tcase \"collect\":\n\t\t\truntime.GC()\n\t\t\tl.PushInteger(0)\n\t\tcase \"step\":\n\t\t\truntime.GC()\n\t\t\tl.PushBoolean(true)\n\t\tcase \"count\":\n\t\t\tvar stats runtime.MemStats\n\t\t\truntime.ReadMemStats(&stats)\n\t\t\tl.PushNumber(float64(stats.HeapAlloc >> 10))\n\t\t\tl.PushInteger(int(stats.HeapAlloc & 0x3ff))\n\t\t\treturn 2\n\t\tdefault:\n\t\t\tl.PushInteger(-1)\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"dofile\", func(l *State) int {\n\t\tf := OptString(l, 1, \"\")\n\t\tif l.SetTop(1); LoadFile(l, f, \"\") != nil {\n\t\t\tl.Error()\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t\tcontinuation := func(l *State) int { return l.Top() - 1 }\n\t\tl.CallWithContinuation(0, MultipleReturns, 0, continuation)\n\t\treturn continuation(l)\n\t}},\n\t{\"error\", func(l *State) int {\n\t\tlevel := OptInteger(l, 2, 1)\n\t\tl.SetTop(1)\n\t\tif l.IsString(1) && level > 0 {\n\t\t\tWhere(l, level)\n\t\t\tl.PushValue(1)\n\t\t\tl.Concat(2)\n\t\t}\n\t\tl.Error()\n\t\tpanic(\"unreachable\")\n\t}},\n\t{\"getmetatable\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tif !l.MetaTable(1) {\n\t\t\tl.PushNil()\n\t\t\treturn 1\n\t\t}\n\t\tMetaField(l, 1, \"__metatable\")\n\t\treturn 1\n\t}},\n\t{\"ipairs\", pairs(\"__ipairs\", true, intPairs)},\n\t{\"loadfile\", func(l *State) int {\n\t\tf, m, e := OptString(l, 1, \"\"), OptString(l, 2, \"\"), 3\n\t\tif l.IsNone(e) {\n\t\t\te = 0\n\t\t}\n\t\treturn loadHelper(l, LoadFile(l, f, m), e)\n\t}},\n\t{\"load\", func(l *State) int {\n\t\tm, e := OptString(l, 3, \"bt\"), 4\n\t\tif l.IsNone(e) {\n\t\t\te = 0\n\t\t}\n\t\tvar err error\n\t\tif s, ok := l.ToString(1); ok {\n\t\t\terr = LoadBuffer(l, s, OptString(l, 2, s), m)\n\t\t} else {\n\t\t\tchunkName := OptString(l, 2, \"=(load)\")\n\t\t\tCheckType(l, 1, TypeFunction)\n\t\t\terr = l.Load(&genericReader{l: l}, chunkName, m)\n\t\t}\n\t\treturn loadHelper(l, err, e)\n\t}},\n\t{\"next\", next},\n\t{\"pairs\", pairs(\"__pairs\", false, next)},\n\t{\"pcall\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tl.PushNil()\n\t\tl.Insert(1) // create space for status result\n\t\treturn finishProtectedCall(l, nil == l.ProtectedCallWithContinuation(l.Top()-2, MultipleReturns, 0, 0, protectedCallContinuation))\n\t}},\n\t{\"print\", func(l *State) int {\n\t\tn := l.Top()\n\t\tl.Global(\"tostring\")\n\t\tfor i := 1; i <= n; i++ {\n\t\t\tl.PushValue(-1) // function to be called\n\t\t\tl.PushValue(i)  // value to print\n\t\t\tl.Call(1, 1)\n\t\t\ts, ok := l.ToString(-1)\n\t\t\tif !ok {\n\t\t\t\tErrorf(l, \"'tostring' must return a string to 'print'\")\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\t\t\tif i > 1 {\n\t\t\t\tos.Stdout.WriteString(\"\\t\")\n\t\t\t}\n\t\t\tos.Stdout.WriteString(s)\n\t\t\tl.Pop(1) // pop result\n\t\t}\n\t\tos.Stdout.WriteString(\"\\n\")\n\t\tos.Stdout.Sync()\n\t\treturn 0\n\t}},\n\t{\"rawequal\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tCheckAny(l, 2)\n\t\tl.PushBoolean(l.RawEqual(1, 2))\n\t\treturn 1\n\t}},\n\t{\"rawlen\", func(l *State) int {\n\t\tt := l.TypeOf(1)\n\t\tArgumentCheck(l, t == TypeTable || t == TypeString, 1, \"table or string expected\")\n\t\tl.PushInteger(l.RawLength(1))\n\t\treturn 1\n\t}},\n\t{\"rawget\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\tCheckAny(l, 2)\n\t\tl.SetTop(2)\n\t\tl.RawGet(1)\n\t\treturn 1\n\t}},\n\t{\"rawset\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\tCheckAny(l, 2)\n\t\tCheckAny(l, 3)\n\t\tl.SetTop(3)\n\t\tl.RawSet(1)\n\t\treturn 1\n\t}},\n\t{\"select\", func(l *State) int {\n\t\tn := l.Top()\n\t\tif l.TypeOf(1) == TypeString {\n\t\t\tif s, _ := l.ToString(1); s[0] == '#' {\n\t\t\t\tl.PushInteger(n - 1)\n\t\t\t\treturn 1\n\t\t\t}\n\t\t}\n\t\ti := CheckInteger(l, 1)\n\t\tif i < 0 {\n\t\t\ti = n + i\n\t\t} else if i > n {\n\t\t\ti = n\n\t\t}\n\t\tArgumentCheck(l, 1 <= i, 1, \"index out of range\")\n\t\treturn n - i\n\t}},\n\t{\"setmetatable\", func(l *State) int {\n\t\tt := l.TypeOf(2)\n\t\tCheckType(l, 1, TypeTable)\n\t\tArgumentCheck(l, t == TypeNil || t == TypeTable, 2, \"nil or table expected\")\n\t\tif MetaField(l, 1, \"__metatable\") {\n\t\t\tErrorf(l, \"cannot change a protected metatable\")\n\t\t}\n\t\tl.SetTop(2)\n\t\tl.SetMetaTable(1)\n\t\treturn 1\n\t}},\n\t{\"tonumber\", func(l *State) int {\n\t\tif l.IsNoneOrNil(2) { // standard conversion\n\t\t\tif n, ok := l.ToNumber(1); ok {\n\t\t\t\tl.PushNumber(n)\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tCheckAny(l, 1)\n\t\t} else {\n\t\t\ts := CheckString(l, 1)\n\t\t\tbase := CheckInteger(l, 2)\n\t\t\tArgumentCheck(l, 2 <= base && base <= 36, 2, \"base out of range\")\n\t\t\tif i, err := strconv.ParseInt(strings.TrimSpace(s), base, 64); err == nil {\n\t\t\t\tl.PushNumber(float64(i))\n\t\t\t\treturn 1\n\t\t\t}\n\t\t}\n\t\tl.PushNil()\n\t\treturn 1\n\t}},\n\t{\"tostring\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tToStringMeta(l, 1)\n\t\treturn 1\n\t}},\n\t{\"type\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tl.PushString(TypeNameOf(l, 1))\n\t\treturn 1\n\t}},\n\t{\"xpcall\", func(l *State) int {\n\t\tn := l.Top()\n\t\tArgumentCheck(l, n >= 2, 2, \"value expected\")\n\t\tl.PushValue(1) // exchange function and error handler\n\t\tl.Copy(2, 1)\n\t\tl.Replace(2)\n\t\treturn finishProtectedCall(l, nil == l.ProtectedCallWithContinuation(n-2, MultipleReturns, 1, 0, protectedCallContinuation))\n\t}},\n}\n\n// BaseOpen opens the basic library. Usually passed to Require.\nfunc BaseOpen(l *State) int {\n\tl.PushGlobalTable()\n\tl.PushGlobalTable()\n\tl.SetField(-2, \"_G\")\n\tSetFunctions(l, baseLibrary, 0)\n\tl.PushString(VersionString)\n\tl.SetField(-2, \"_VERSION\")\n\treturn 1\n}\n"
        },
        {
          "name": "bit32.go",
          "type": "blob",
          "size": 2.81640625,
          "content": "package lua\n\nimport (\n\t\"math\"\n)\n\nconst bitCount = 32\n\nfunc trim(x uint) uint { return x & math.MaxUint32 }\nfunc mask(n uint) uint { return ^(math.MaxUint32 << n) }\n\nfunc shift(l *State, r uint, i int) int {\n\tif i < 0 {\n\t\tif i, r = -i, trim(r); i >= bitCount {\n\t\t\tr = 0\n\t\t} else {\n\t\t\tr >>= uint(i)\n\t\t}\n\t} else {\n\t\tif i >= bitCount {\n\t\t\tr = 0\n\t\t} else {\n\t\t\tr <<= uint(i)\n\t\t}\n\t\tr = trim(r)\n\t}\n\tl.PushUnsigned(r)\n\treturn 1\n}\n\nfunc rotate(l *State, i int) int {\n\tr := trim(CheckUnsigned(l, 1))\n\tif i &= bitCount - 1; i != 0 {\n\t\tr = trim((r << uint(i)) | (r >> uint(bitCount-i)))\n\t}\n\tl.PushUnsigned(r)\n\treturn 1\n}\n\nfunc bitOp(l *State, init uint, f func(a, b uint) uint) uint {\n\tr := init\n\tfor i, n := 1, l.Top(); i <= n; i++ {\n\t\tr = f(r, CheckUnsigned(l, i))\n\t}\n\treturn trim(r)\n}\n\nfunc andHelper(l *State) uint {\n\tx := bitOp(l, ^uint(0), func(a, b uint) uint { return a & b })\n\treturn x\n}\n\nfunc fieldArguments(l *State, fieldIndex int) (uint, uint) {\n\tf, w := CheckInteger(l, fieldIndex), OptInteger(l, fieldIndex+1, 1)\n\tArgumentCheck(l, 0 <= f, fieldIndex, \"field cannot be negative\")\n\tArgumentCheck(l, 0 < w, fieldIndex+1, \"width must be positive\")\n\tif f+w > bitCount {\n\t\tErrorf(l, \"trying to access non-existent bits\")\n\t}\n\treturn uint(f), uint(w)\n}\n\nvar bitLibrary = []RegistryFunction{\n\t{\"arshift\", func(l *State) int {\n\t\tr, i := CheckUnsigned(l, 1), CheckInteger(l, 2)\n\t\tif i < 0 || (r&(1<<(bitCount-1)) == 0) {\n\t\t\treturn shift(l, r, -i)\n\t\t}\n\n\t\tif i >= bitCount {\n\t\t\tr = math.MaxUint32\n\t\t} else {\n\t\t\tr = trim((r >> uint(i)) | ^(math.MaxUint32 >> uint(i)))\n\t\t}\n\t\tl.PushUnsigned(r)\n\t\treturn 1\n\t}},\n\t{\"band\", func(l *State) int { l.PushUnsigned(andHelper(l)); return 1 }},\n\t{\"bnot\", func(l *State) int { l.PushUnsigned(trim(^CheckUnsigned(l, 1))); return 1 }},\n\t{\"bor\", func(l *State) int { l.PushUnsigned(bitOp(l, 0, func(a, b uint) uint { return a | b })); return 1 }},\n\t{\"bxor\", func(l *State) int { l.PushUnsigned(bitOp(l, 0, func(a, b uint) uint { return a ^ b })); return 1 }},\n\t{\"btest\", func(l *State) int { l.PushBoolean(andHelper(l) != 0); return 1 }},\n\t{\"extract\", func(l *State) int {\n\t\tr := CheckUnsigned(l, 1)\n\t\tf, w := fieldArguments(l, 2)\n\t\tl.PushUnsigned((r >> f) & mask(w))\n\t\treturn 1\n\t}},\n\t{\"lrotate\", func(l *State) int { return rotate(l, CheckInteger(l, 2)) }},\n\t{\"lshift\", func(l *State) int { return shift(l, CheckUnsigned(l, 1), CheckInteger(l, 2)) }},\n\t{\"replace\", func(l *State) int {\n\t\tr, v := CheckUnsigned(l, 1), CheckUnsigned(l, 2)\n\t\tf, w := fieldArguments(l, 3)\n\t\tm := mask(w)\n\t\tv &= m\n\t\tl.PushUnsigned((r & ^(m << f)) | (v << f))\n\t\treturn 1\n\t}},\n\t{\"rrotate\", func(l *State) int { return rotate(l, -CheckInteger(l, 2)) }},\n\t{\"rshift\", func(l *State) int { return shift(l, CheckUnsigned(l, 1), -CheckInteger(l, 2)) }},\n}\n\n// Bit32Open opens the bit32 library. Usually passed to Require.\nfunc Bit32Open(l *State) int {\n\tNewLibrary(l, bitLibrary)\n\treturn 1\n}\n"
        },
        {
          "name": "code.go",
          "type": "blob",
          "size": 30.466796875,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nconst (\n\toprMinus = iota\n\toprNot\n\toprLength\n\toprNoUnary\n)\n\nconst (\n\tnoJump            = -1\n\tnoRegister        = maxArgA\n\tmaxLocalVariables = 200\n)\n\nconst (\n\toprAdd = iota\n\toprSub\n\toprMul\n\toprDiv\n\toprMod\n\toprPow\n\toprConcat\n\toprEq\n\toprLT\n\toprLE\n\toprNE\n\toprGT\n\toprGE\n\toprAnd\n\toprOr\n\toprNoBinary\n)\n\nconst (\n\tkindVoid = iota // no value\n\tkindNil\n\tkindTrue\n\tkindFalse\n\tkindConstant       // info = index of constant\n\tkindNumber         // value = numerical value\n\tkindNonRelocatable // info = result register\n\tkindLocal          // info = local register\n\tkindUpValue        // info = index of upvalue\n\tkindIndexed        // table = table register/upvalue, index = register/constant index\n\tkindJump           // info = instruction pc\n\tkindRelocatable    // info = instruction pc\n\tkindCall           // info = instruction pc\n\tkindVarArg         // info = instruction pc\n)\n\nvar kinds []string = []string{\n\t\"void\",\n\t\"nil\",\n\t\"true\",\n\t\"false\",\n\t\"constant\",\n\t\"number\",\n\t\"nonrelocatable\",\n\t\"local\",\n\t\"upvalue\",\n\t\"indexed\",\n\t\"jump\",\n\t\"relocatable\",\n\t\"call\",\n\t\"vararg\",\n}\n\ntype exprDesc struct {\n\tkind      int\n\tindex     int // register/constant index\n\ttable     int // register or upvalue\n\ttableType int // whether 'table' is register (kindLocal) or upvalue (kindUpValue)\n\tinfo      int\n\tt, f      int // patch lists for 'exit when true/false'\n\tvalue     float64\n}\n\ntype assignmentTarget struct {\n\tprevious *assignmentTarget\n\texprDesc\n}\n\ntype label struct {\n\tname                string\n\tpc, line            int\n\tactiveVariableCount int\n}\n\ntype block struct {\n\tprevious              *block\n\tfirstLabel, firstGoto int\n\tactiveVariableCount   int\n\thasUpValue, isLoop    bool\n}\n\ntype function struct {\n\tconstantLookup      map[value]int\n\tf                   *prototype\n\tprevious            *function\n\tp                   *parser\n\tblock               *block\n\tjumpPC, lastTarget  int\n\tfreeRegisterCount   int\n\tactiveVariableCount int\n\tfirstLocal          int\n}\n\nfunc (f *function) OpenFunction(line int) {\n\tf.f.prototypes = append(f.f.prototypes, prototype{source: f.p.source, maxStackSize: 2, lineDefined: line})\n\tf.p.function = &function{f: &f.f.prototypes[len(f.f.prototypes)-1], constantLookup: make(map[value]int), previous: f, p: f.p, jumpPC: noJump, firstLocal: len(f.p.activeVariables)}\n\tf.p.function.EnterBlock(false)\n}\n\nfunc (f *function) CloseFunction() exprDesc {\n\te := f.previous.ExpressionToNextRegister(makeExpression(kindRelocatable, f.previous.encodeABx(opClosure, 0, len(f.previous.f.prototypes)-1)))\n\tf.ReturnNone()\n\tf.LeaveBlock()\n\tf.assert(f.block == nil)\n\tf.p.function = f.previous\n\treturn e\n}\n\nfunc (f *function) EnterBlock(isLoop bool) {\n\t// TODO www.lua.org uses a trick here to stack allocate the block, and chain blocks in the stack\n\tf.block = &block{previous: f.block, firstLabel: len(f.p.activeLabels), firstGoto: len(f.p.pendingGotos), activeVariableCount: f.activeVariableCount, isLoop: isLoop}\n\tf.assert(f.freeRegisterCount == f.activeVariableCount)\n}\n\nfunc (f *function) undefinedGotoError(g label) {\n\tif isReserved(g.name) {\n\t\tf.semanticError(fmt.Sprintf(\"<%s> at line %d not inside a loop\", g.name, g.line))\n\t} else {\n\t\tf.semanticError(fmt.Sprintf(\"no visible label '%s' for <goto> at line %d\", g.name, g.line))\n\t}\n}\n\nfunc (f *function) LocalVariable(i int) *localVariable {\n\tindex := f.p.activeVariables[f.firstLocal+i]\n\treturn &f.f.localVariables[index]\n}\n\nfunc (f *function) AdjustLocalVariables(n int) {\n\tfor f.activeVariableCount += n; n != 0; n-- {\n\t\tf.LocalVariable(f.activeVariableCount - n).startPC = pc(len(f.f.code))\n\t}\n}\n\nfunc (f *function) removeLocalVariables(level int) {\n\tfor i := level; i < f.activeVariableCount; i++ {\n\t\tf.LocalVariable(i).endPC = pc(len(f.f.code))\n\t}\n\tf.p.activeVariables = f.p.activeVariables[:len(f.p.activeVariables)-(f.activeVariableCount-level)]\n\tf.activeVariableCount = level\n}\n\nfunc (f *function) MakeLocalVariable(name string) {\n\tr := len(f.f.localVariables)\n\tf.f.localVariables = append(f.f.localVariables, localVariable{name: name})\n\tf.p.checkLimit(len(f.p.activeVariables)+1-f.firstLocal, maxLocalVariables, \"local variables\")\n\tf.p.activeVariables = append(f.p.activeVariables, r)\n}\n\nfunc (f *function) MakeGoto(name string, line, pc int) {\n\tf.p.pendingGotos = append(f.p.pendingGotos, label{name: name, line: line, pc: pc, activeVariableCount: f.activeVariableCount})\n\tf.findLabel(len(f.p.pendingGotos) - 1)\n}\n\nfunc (f *function) MakeLabel(name string, line int) int {\n\tf.p.activeLabels = append(f.p.activeLabels, label{name: name, line: line, pc: len(f.f.code), activeVariableCount: f.activeVariableCount})\n\treturn len(f.p.activeLabels) - 1\n}\n\nfunc (f *function) closeGoto(i int, l label) {\n\tg := f.p.pendingGotos[i]\n\tif f.assert(g.name == l.name); g.activeVariableCount < l.activeVariableCount {\n\t\tf.semanticError(fmt.Sprintf(\"<goto %s> at line %d jumps into the scope of local '%s'\", g.name, g.line, f.LocalVariable(g.activeVariableCount).name))\n\t}\n\tf.PatchList(g.pc, l.pc)\n\tcopy(f.p.pendingGotos[i:], f.p.pendingGotos[i+1:])\n\tf.p.pendingGotos = f.p.pendingGotos[:len(f.p.pendingGotos)-1]\n}\n\nfunc (f *function) findLabel(i int) int {\n\tg, b := f.p.pendingGotos[i], f.block\n\tfor _, l := range f.p.activeLabels[b.firstLabel:] {\n\t\tif l.name == g.name {\n\t\t\tif g.activeVariableCount > l.activeVariableCount && (b.hasUpValue || len(f.p.activeLabels) > b.firstLabel) {\n\t\t\t\tf.PatchClose(g.pc, l.activeVariableCount)\n\t\t\t}\n\t\t\tf.closeGoto(i, l)\n\t\t\treturn 0\n\t\t}\n\t}\n\treturn 1\n}\n\nfunc (f *function) CheckRepeatedLabel(name string) {\n\tfor _, l := range f.p.activeLabels[f.block.firstLabel:] {\n\t\tif l.name == name {\n\t\t\tf.semanticError(fmt.Sprintf(\"label '%s' already defined on line %d\", name, l.line))\n\t\t}\n\t}\n}\n\nfunc (f *function) FindGotos(label int) {\n\tfor i, l := f.block.firstGoto, f.p.activeLabels[label]; i < len(f.p.pendingGotos); {\n\t\tif f.p.pendingGotos[i].name == l.name {\n\t\t\tf.closeGoto(i, l)\n\t\t} else {\n\t\t\ti++\n\t\t}\n\t}\n}\n\nfunc (f *function) moveGotosOut(b block) {\n\tfor i := b.firstGoto; i < len(f.p.pendingGotos); i += f.findLabel(i) {\n\t\tif f.p.pendingGotos[i].activeVariableCount > b.activeVariableCount {\n\t\t\tif b.hasUpValue {\n\t\t\t\tf.PatchClose(f.p.pendingGotos[i].pc, b.activeVariableCount)\n\t\t\t}\n\t\t\tf.p.pendingGotos[i].activeVariableCount = b.activeVariableCount\n\t\t}\n\t}\n}\n\nfunc (f *function) LeaveBlock() {\n\tb := f.block\n\tif b.previous != nil && b.hasUpValue { // create a 'jump to here' to close upvalues\n\t\tj := f.Jump()\n\t\tf.PatchClose(j, b.activeVariableCount)\n\t\tf.PatchToHere(j)\n\t}\n\tif b.isLoop {\n\t\tf.breakLabel() // close pending breaks\n\t}\n\tf.block = b.previous\n\tf.removeLocalVariables(b.activeVariableCount)\n\tf.assert(b.activeVariableCount == f.activeVariableCount)\n\tf.freeRegisterCount = f.activeVariableCount\n\tf.p.activeLabels = f.p.activeLabels[:b.firstLabel]\n\tif b.previous != nil { // inner block\n\t\tf.moveGotosOut(*b) // update pending gotos to outer block\n\t} else if b.firstGoto < len(f.p.pendingGotos) { // pending gotos in outer block\n\t\tf.undefinedGotoError(f.p.pendingGotos[b.firstGoto])\n\t}\n}\n\nfunc abs(i int) int {\n\tif i < 0 {\n\t\treturn -i\n\t}\n\treturn i\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc not(b int) int {\n\tif b == 0 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc makeExpression(kind, info int) exprDesc {\n\treturn exprDesc{f: noJump, t: noJump, kind: kind, info: info}\n}\n\nfunc (f *function) semanticError(message string) {\n\tf.p.t = 0 // remove \"near to\" from final message\n\tf.p.syntaxError(message)\n}\n\nfunc (f *function) breakLabel()                         { f.FindGotos(f.MakeLabel(\"break\", 0)) }\nfunc (f *function) unreachable()                        { f.assert(false) }\nfunc (f *function) assert(cond bool)                    { f.p.l.assert(cond) }\nfunc (f *function) Instruction(e exprDesc) *instruction { return &f.f.code[e.info] }\nfunc (e exprDesc) hasJumps() bool                       { return e.t != e.f }\nfunc (e exprDesc) isNumeral() bool                      { return e.kind == kindNumber && e.t == noJump && e.f == noJump }\nfunc (e exprDesc) isVariable() bool                     { return kindLocal <= e.kind && e.kind <= kindIndexed }\nfunc (e exprDesc) hasMultipleReturns() bool             { return e.kind == kindCall || e.kind == kindVarArg }\n\nfunc (f *function) assertEqual(a, b interface{}) {\n\tif a != b {\n\t\tpanic(fmt.Sprintf(\"%v != %v\", a, b))\n\t}\n}\n\nfunc (f *function) encode(i instruction) int {\n\tf.assert(len(f.f.code) == len(f.f.lineInfo))\n\tf.dischargeJumpPC()\n\tf.f.code = append(f.f.code, i)\n\tf.f.lineInfo = append(f.f.lineInfo, int32(f.p.lastLine))\n\treturn len(f.f.code) - 1\n}\n\nfunc (f *function) dropLastInstruction() {\n\tf.assert(len(f.f.code) == len(f.f.lineInfo))\n\tf.f.code = f.f.code[:len(f.f.code)-1]\n\tf.f.lineInfo = f.f.lineInfo[:len(f.f.lineInfo)-1]\n}\n\nfunc (f *function) EncodeABC(op opCode, a, b, c int) int {\n\tf.assert(opMode(op) == iABC)\n\tf.assert(bMode(op) != opArgN || b == 0)\n\tf.assert(cMode(op) != opArgN || c == 0)\n\tf.assert(a <= maxArgA && b <= maxArgB && c <= maxArgC)\n\treturn f.encode(createABC(op, a, b, c))\n}\n\nfunc (f *function) encodeABx(op opCode, a, bx int) int {\n\tf.assert(opMode(op) == iABx || opMode(op) == iAsBx)\n\tf.assert(cMode(op) == opArgN)\n\tf.assert(a <= maxArgA && bx <= maxArgBx)\n\treturn f.encode(createABx(op, a, bx))\n}\n\nfunc (f *function) encodeAsBx(op opCode, a, sbx int) int { return f.encodeABx(op, a, sbx+maxArgSBx) }\n\nfunc (f *function) encodeExtraArg(a int) int {\n\tf.assert(a <= maxArgAx)\n\treturn f.encode(createAx(opExtraArg, a))\n}\n\nfunc (f *function) EncodeConstant(r, constant int) int {\n\tif constant <= maxArgBx {\n\t\treturn f.encodeABx(opLoadConstant, r, constant)\n\t}\n\tpc := f.encodeABx(opLoadConstant, r, 0)\n\tf.encodeExtraArg(constant)\n\treturn pc\n}\n\nfunc (f *function) EncodeString(s string) exprDesc {\n\treturn makeExpression(kindConstant, f.stringConstant(s))\n}\n\nfunc (f *function) loadNil(from, n int) {\n\tif len(f.f.code) > f.lastTarget { // no jumps to current position\n\t\tif previous := &f.f.code[len(f.f.code)-1]; previous.opCode() == opLoadNil {\n\t\t\tif pf, pl, l := previous.a(), previous.a()+previous.b(), from+n-1; pf <= from && from <= pl+1 || from <= pf && pf <= l+1 { // can connect both\n\t\t\t\tfrom, l = min(from, pf), max(l, pl)\n\t\t\t\tprevious.setA(from)\n\t\t\t\tprevious.setB(l - from)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tf.EncodeABC(opLoadNil, from, n-1, 0)\n}\n\nfunc (f *function) Jump() int {\n\tf.assert(f.isJumpListWalkable(f.jumpPC))\n\tjumpPC := f.jumpPC\n\tf.jumpPC = noJump\n\treturn f.Concatenate(f.encodeAsBx(opJump, 0, noJump), jumpPC)\n}\n\nfunc (f *function) JumpTo(target int)             { f.PatchList(f.Jump(), target) }\nfunc (f *function) ReturnNone()                   { f.EncodeABC(opReturn, 0, 1, 0) }\nfunc (f *function) SetMultipleReturns(e exprDesc) { f.setReturns(e, MultipleReturns) }\n\nfunc (f *function) Return(e exprDesc, resultCount int) {\n\tif e.hasMultipleReturns() {\n\t\tif f.SetMultipleReturns(e); e.kind == kindCall && resultCount == 1 {\n\t\t\tf.Instruction(e).setOpCode(opTailCall)\n\t\t\tf.assert(f.Instruction(e).a() == f.activeVariableCount)\n\t\t}\n\t\tf.EncodeABC(opReturn, f.activeVariableCount, MultipleReturns+1, 0)\n\t} else if resultCount == 1 {\n\t\tf.EncodeABC(opReturn, f.ExpressionToAnyRegister(e).info, 1+1, 0)\n\t} else {\n\t\t_ = f.ExpressionToNextRegister(e)\n\t\tf.assert(resultCount == f.freeRegisterCount-f.activeVariableCount)\n\t\tf.EncodeABC(opReturn, f.activeVariableCount, resultCount+1, 0)\n\t}\n}\n\nfunc (f *function) conditionalJump(op opCode, a, b, c int) int {\n\tf.EncodeABC(op, a, b, c)\n\treturn f.Jump()\n}\n\nfunc (f *function) fixJump(pc, dest int) {\n\tf.assert(f.isJumpListWalkable(pc))\n\tf.assert(dest != noJump)\n\toffset := dest - (pc + 1)\n\tif abs(offset) > maxArgSBx {\n\t\tf.p.syntaxError(\"control structure too long\")\n\t}\n\tf.f.code[pc].setSBx(offset)\n}\n\nfunc (f *function) Label() int {\n\tf.lastTarget = len(f.f.code)\n\treturn f.lastTarget\n}\n\nfunc (f *function) jump(pc int) int {\n\tf.assert(f.isJumpListWalkable(pc))\n\tif offset := f.f.code[pc].sbx(); offset != noJump {\n\t\treturn pc + 1 + offset\n\t}\n\treturn noJump\n}\n\nfunc (f *function) isJumpListWalkable(list int) bool {\n\tif list == noJump {\n\t\treturn true\n\t}\n\tif list < 0 || list >= len(f.f.code) {\n\t\treturn false\n\t}\n\toffset := f.f.code[list].sbx()\n\treturn offset == noJump || f.isJumpListWalkable(list+1+offset)\n}\n\nfunc (f *function) jumpControl(pc int) *instruction {\n\tif pc >= 1 && testTMode(f.f.code[pc-1].opCode()) {\n\t\treturn &f.f.code[pc-1]\n\t}\n\treturn &f.f.code[pc]\n}\n\nfunc (f *function) needValue(list int) bool {\n\tf.assert(f.isJumpListWalkable(list))\n\tfor ; list != noJump; list = f.jump(list) {\n\t\tif f.jumpControl(list).opCode() != opTestSet {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (f *function) patchTestRegister(node, register int) bool {\n\tif i := f.jumpControl(node); i.opCode() != opTestSet {\n\t\treturn false\n\t} else if register != noRegister && register != i.b() {\n\t\ti.setA(register)\n\t} else {\n\t\t*i = createABC(opTest, i.b(), 0, i.c())\n\t}\n\treturn true\n}\n\nfunc (f *function) removeValues(list int) {\n\tf.assert(f.isJumpListWalkable(list))\n\tfor ; list != noJump; list = f.jump(list) {\n\t\t_ = f.patchTestRegister(list, noRegister)\n\t}\n}\n\nfunc (f *function) patchListHelper(list, target, register, defaultTarget int) {\n\tf.assert(f.isJumpListWalkable(list))\n\tfor list != noJump {\n\t\tnext := f.jump(list)\n\t\tif f.patchTestRegister(list, register) {\n\t\t\tf.fixJump(list, target)\n\t\t} else {\n\t\t\tf.fixJump(list, defaultTarget)\n\t\t}\n\t\tlist = next\n\t}\n}\n\nfunc (f *function) dischargeJumpPC() {\n\tf.assert(f.isJumpListWalkable(f.jumpPC))\n\tf.patchListHelper(f.jumpPC, len(f.f.code), noRegister, len(f.f.code))\n\tf.jumpPC = noJump\n}\n\nfunc (f *function) PatchList(list, target int) {\n\tif target == len(f.f.code) {\n\t\tf.PatchToHere(list)\n\t} else {\n\t\tf.assert(target < len(f.f.code))\n\t\tf.patchListHelper(list, target, noRegister, target)\n\t}\n}\n\nfunc (f *function) PatchClose(list, level int) {\n\tf.assert(f.isJumpListWalkable(list))\n\tfor level, next := level+1, 0; list != noJump; list = next {\n\t\tnext = f.jump(list)\n\t\tf.assert(f.f.code[list].opCode() == opJump && f.f.code[list].a() == 0 || f.f.code[list].a() >= level)\n\t\tf.f.code[list].setA(level)\n\t}\n}\n\nfunc (f *function) PatchToHere(list int) {\n\tf.assert(f.isJumpListWalkable(list))\n\tf.assert(f.isJumpListWalkable(f.jumpPC))\n\tf.Label()\n\tf.jumpPC = f.Concatenate(f.jumpPC, list)\n\tf.assert(f.isJumpListWalkable(f.jumpPC))\n}\n\nfunc (f *function) Concatenate(l1, l2 int) int {\n\tf.assert(f.isJumpListWalkable(l1))\n\tswitch {\n\tcase l2 == noJump:\n\tcase l1 == noJump:\n\t\treturn l2\n\tdefault:\n\t\tlist := l1\n\t\tfor next := f.jump(list); next != noJump; list, next = next, f.jump(next) {\n\t\t}\n\t\tf.fixJump(list, l2)\n\t}\n\treturn l1\n}\n\nfunc (f *function) addConstant(k, v value) int {\n\tif index, ok := f.constantLookup[k]; ok && f.f.constants[index] == v {\n\t\treturn index\n\t}\n\tindex := len(f.f.constants)\n\tf.constantLookup[k] = index\n\tf.f.constants = append(f.f.constants, v)\n\treturn index\n}\n\nfunc (f *function) NumberConstant(n float64) int {\n\tif n == 0.0 || math.IsNaN(n) {\n\t\treturn f.addConstant(math.Float64bits(n), n)\n\t}\n\treturn f.addConstant(n, n)\n}\n\nfunc (f *function) CheckStack(n int) {\n\tif n += f.freeRegisterCount; n >= maxStack {\n\t\tf.p.syntaxError(\"function or expression too complex\")\n\t} else if n > f.f.maxStackSize {\n\t\tf.f.maxStackSize = n\n\t}\n}\n\nfunc (f *function) ReserveRegisters(n int) {\n\tf.CheckStack(n)\n\tf.freeRegisterCount += n\n}\n\nfunc (f *function) freeRegister(r int) {\n\tif !isConstant(r) && r >= f.activeVariableCount {\n\t\tf.freeRegisterCount--\n\t\tf.assertEqual(r, f.freeRegisterCount)\n\t}\n}\n\nfunc (f *function) freeExpression(e exprDesc) {\n\tif e.kind == kindNonRelocatable {\n\t\tf.freeRegister(e.info)\n\t}\n}\n\nfunc (f *function) stringConstant(s string) int { return f.addConstant(s, s) }\nfunc (f *function) booleanConstant(b bool) int  { return f.addConstant(b, b) }\nfunc (f *function) nilConstant() int            { return f.addConstant(f, nil) }\n\nfunc (f *function) setReturns(e exprDesc, resultCount int) {\n\tif e.kind == kindCall {\n\t\tf.Instruction(e).setC(resultCount + 1)\n\t} else if e.kind == kindVarArg {\n\t\tf.Instruction(e).setB(resultCount + 1)\n\t\tf.Instruction(e).setA(f.freeRegisterCount)\n\t\tf.ReserveRegisters(1)\n\t}\n}\n\nfunc (f *function) SetReturn(e exprDesc) exprDesc {\n\tif e.kind == kindCall {\n\t\te.kind, e.info = kindNonRelocatable, f.Instruction(e).a()\n\t} else if e.kind == kindVarArg {\n\t\tf.Instruction(e).setB(2)\n\t\te.kind = kindRelocatable\n\t}\n\treturn e\n}\n\nfunc (f *function) DischargeVariables(e exprDesc) exprDesc {\n\tswitch e.kind {\n\tcase kindLocal:\n\t\te.kind = kindNonRelocatable\n\tcase kindUpValue:\n\t\te.kind, e.info = kindRelocatable, f.EncodeABC(opGetUpValue, 0, e.info, 0)\n\tcase kindIndexed:\n\t\tif f.freeRegister(e.index); e.tableType == kindLocal {\n\t\t\tf.freeRegister(e.table)\n\t\t\te.kind, e.info = kindRelocatable, f.EncodeABC(opGetTable, 0, e.table, e.index)\n\t\t} else {\n\t\t\te.kind, e.info = kindRelocatable, f.EncodeABC(opGetTableUp, 0, e.table, e.index)\n\t\t}\n\tcase kindVarArg, kindCall:\n\t\te = f.SetReturn(e)\n\t}\n\treturn e\n}\n\nfunc (f *function) dischargeToRegister(e exprDesc, r int) exprDesc {\n\tswitch e = f.DischargeVariables(e); e.kind {\n\tcase kindNil:\n\t\tf.loadNil(r, 1)\n\tcase kindFalse:\n\t\tf.EncodeABC(opLoadBool, r, 0, 0)\n\tcase kindTrue:\n\t\tf.EncodeABC(opLoadBool, r, 1, 0)\n\tcase kindConstant:\n\t\tf.EncodeConstant(r, e.info)\n\tcase kindNumber:\n\t\tf.EncodeConstant(r, f.NumberConstant(e.value))\n\tcase kindRelocatable:\n\t\tf.Instruction(e).setA(r)\n\tcase kindNonRelocatable:\n\t\tif r != e.info {\n\t\t\tf.EncodeABC(opMove, r, e.info, 0)\n\t\t}\n\tdefault:\n\t\tf.assert(e.kind == kindVoid || e.kind == kindJump)\n\t\treturn e\n\t}\n\te.kind, e.info = kindNonRelocatable, r\n\treturn e\n}\n\nfunc (f *function) dischargeToAnyRegister(e exprDesc) exprDesc {\n\tif e.kind != kindNonRelocatable {\n\t\tf.ReserveRegisters(1)\n\t\te = f.dischargeToRegister(e, f.freeRegisterCount-1)\n\t}\n\treturn e\n}\n\nfunc (f *function) encodeLabel(a, b, jump int) int {\n\tf.Label()\n\treturn f.EncodeABC(opLoadBool, a, b, jump)\n}\n\nfunc (f *function) expressionToRegister(e exprDesc, r int) exprDesc {\n\tif e = f.dischargeToRegister(e, r); e.kind == kindJump {\n\t\te.t = f.Concatenate(e.t, e.info)\n\t}\n\tif e.hasJumps() {\n\t\tloadFalse, loadTrue := noJump, noJump\n\t\tif f.needValue(e.t) || f.needValue(e.f) {\n\t\t\tjump := noJump\n\t\t\tif e.kind != kindJump {\n\t\t\t\tjump = f.Jump()\n\t\t\t}\n\t\t\tloadFalse, loadTrue = f.encodeLabel(r, 0, 1), f.encodeLabel(r, 1, 0)\n\t\t\tf.PatchToHere(jump)\n\t\t}\n\t\tend := f.Label()\n\t\tf.patchListHelper(e.f, end, r, loadFalse)\n\t\tf.patchListHelper(e.t, end, r, loadTrue)\n\t}\n\te.f, e.t, e.info, e.kind = noJump, noJump, r, kindNonRelocatable\n\treturn e\n}\n\nfunc (f *function) ExpressionToNextRegister(e exprDesc) exprDesc {\n\te = f.DischargeVariables(e)\n\tf.freeExpression(e)\n\tf.ReserveRegisters(1)\n\treturn f.expressionToRegister(e, f.freeRegisterCount-1)\n}\n\nfunc (f *function) ExpressionToAnyRegister(e exprDesc) exprDesc {\n\tif e = f.DischargeVariables(e); e.kind == kindNonRelocatable {\n\t\tif !e.hasJumps() {\n\t\t\treturn e\n\t\t}\n\t\tif e.info >= f.activeVariableCount {\n\t\t\treturn f.expressionToRegister(e, e.info)\n\t\t}\n\t}\n\treturn f.ExpressionToNextRegister(e)\n}\n\nfunc (f *function) ExpressionToAnyRegisterOrUpValue(e exprDesc) exprDesc {\n\tif e.kind != kindUpValue || e.hasJumps() {\n\t\te = f.ExpressionToAnyRegister(e)\n\t}\n\treturn e\n}\n\nfunc (f *function) ExpressionToValue(e exprDesc) exprDesc {\n\tif e.hasJumps() {\n\t\treturn f.ExpressionToAnyRegister(e)\n\t}\n\treturn f.DischargeVariables(e)\n}\n\nfunc (f *function) expressionToRegisterOrConstant(e exprDesc) (exprDesc, int) {\n\tswitch e = f.ExpressionToValue(e); e.kind {\n\tcase kindTrue, kindFalse:\n\t\tif len(f.f.constants) <= maxIndexRK {\n\t\t\te.info, e.kind = f.booleanConstant(e.kind == kindTrue), kindConstant\n\t\t\treturn e, asConstant(e.info)\n\t\t}\n\tcase kindNil:\n\t\tif len(f.f.constants) <= maxIndexRK {\n\t\t\te.info, e.kind = f.nilConstant(), kindConstant\n\t\t\treturn e, asConstant(e.info)\n\t\t}\n\tcase kindNumber:\n\t\te.info, e.kind = f.NumberConstant(e.value), kindConstant\n\t\tfallthrough\n\tcase kindConstant:\n\t\tif e.info <= maxIndexRK {\n\t\t\treturn e, asConstant(e.info)\n\t\t}\n\t}\n\te = f.ExpressionToAnyRegister(e)\n\treturn e, e.info\n}\n\nfunc (f *function) StoreVariable(v, e exprDesc) {\n\tswitch v.kind {\n\tcase kindLocal:\n\t\tf.freeExpression(e)\n\t\tf.expressionToRegister(e, v.info)\n\t\treturn\n\tcase kindUpValue:\n\t\te = f.ExpressionToAnyRegister(e)\n\t\tf.EncodeABC(opSetUpValue, e.info, v.info, 0)\n\tcase kindIndexed:\n\t\tvar r int\n\t\te, r = f.expressionToRegisterOrConstant(e)\n\t\tif v.tableType == kindLocal {\n\t\t\tf.EncodeABC(opSetTable, v.table, v.index, r)\n\t\t} else {\n\t\t\tf.EncodeABC(opSetTableUp, v.table, v.index, r)\n\t\t}\n\tdefault:\n\t\tf.unreachable()\n\t}\n\tf.freeExpression(e)\n}\n\nfunc (f *function) Self(e, key exprDesc) exprDesc {\n\te = f.ExpressionToAnyRegister(e)\n\tr := e.info\n\tf.freeExpression(e)\n\tresult := exprDesc{info: f.freeRegisterCount, kind: kindNonRelocatable} // base register for opSelf\n\tf.ReserveRegisters(2)                                                   // function and 'self' produced by opSelf\n\tkey, k := f.expressionToRegisterOrConstant(key)\n\tf.EncodeABC(opSelf, result.info, r, k)\n\tf.freeExpression(key)\n\treturn result\n}\n\nfunc (f *function) invertJump(pc int) {\n\ti := f.jumpControl(pc)\n\tf.p.l.assert(testTMode(i.opCode()) && i.opCode() != opTestSet && i.opCode() != opTest)\n\ti.setA(not(i.a()))\n}\n\nfunc (f *function) jumpOnCondition(e exprDesc, cond int) int {\n\tif e.kind == kindRelocatable {\n\t\tif i := f.Instruction(e); i.opCode() == opNot {\n\t\t\tf.dropLastInstruction() // remove previous opNot\n\t\t\treturn f.conditionalJump(opTest, i.b(), 0, not(cond))\n\t\t}\n\t}\n\te = f.dischargeToAnyRegister(e)\n\tf.freeExpression(e)\n\treturn f.conditionalJump(opTestSet, noRegister, e.info, cond)\n}\n\nfunc (f *function) GoIfTrue(e exprDesc) exprDesc {\n\tpc := noJump\n\tswitch e = f.DischargeVariables(e); e.kind {\n\tcase kindJump:\n\t\tf.invertJump(e.info)\n\t\tpc = e.info\n\tcase kindConstant, kindNumber, kindTrue:\n\tdefault:\n\t\tpc = f.jumpOnCondition(e, 0)\n\t}\n\te.f = f.Concatenate(e.f, pc)\n\tf.PatchToHere(e.t)\n\te.t = noJump\n\treturn e\n}\n\nfunc (f *function) GoIfFalse(e exprDesc) exprDesc {\n\tpc := noJump\n\tswitch e = f.DischargeVariables(e); e.kind {\n\tcase kindJump:\n\t\tpc = e.info\n\tcase kindNil, kindFalse:\n\tdefault:\n\t\tpc = f.jumpOnCondition(e, 1)\n\t}\n\te.t = f.Concatenate(e.t, pc)\n\tf.PatchToHere(e.f)\n\te.f = noJump\n\treturn e\n}\n\nfunc (f *function) encodeNot(e exprDesc) exprDesc {\n\tswitch e = f.DischargeVariables(e); e.kind {\n\tcase kindNil, kindFalse:\n\t\te.kind = kindTrue\n\tcase kindConstant, kindNumber, kindTrue:\n\t\te.kind = kindFalse\n\tcase kindJump:\n\t\tf.invertJump(e.info)\n\tcase kindRelocatable, kindNonRelocatable:\n\t\te = f.dischargeToAnyRegister(e)\n\t\tf.freeExpression(e)\n\t\te.info, e.kind = f.EncodeABC(opNot, 0, e.info, 0), kindRelocatable\n\tdefault:\n\t\tf.unreachable()\n\t}\n\te.f, e.t = e.t, e.f\n\tf.removeValues(e.f)\n\tf.removeValues(e.t)\n\treturn e\n}\n\nfunc (f *function) Indexed(t, k exprDesc) (r exprDesc) {\n\tf.assert(!t.hasJumps())\n\tr = makeExpression(kindIndexed, 0)\n\tr.table = t.info\n\t_, r.index = f.expressionToRegisterOrConstant(k)\n\tif t.kind == kindUpValue {\n\t\tr.tableType = kindUpValue\n\t} else {\n\t\tf.assert(t.kind == kindNonRelocatable || t.kind == kindLocal)\n\t\tr.tableType = kindLocal\n\t}\n\treturn\n}\n\nfunc foldConstants(op opCode, e1, e2 exprDesc) (exprDesc, bool) {\n\tif !e1.isNumeral() || !e2.isNumeral() {\n\t\treturn e1, false\n\t} else if (op == opDiv || op == opMod) && e2.value == 0.0 {\n\t\treturn e1, false\n\t}\n\te1.value = arith(Operator(op-opAdd)+OpAdd, e1.value, e2.value)\n\treturn e1, true\n}\n\nfunc (f *function) encodeArithmetic(op opCode, e1, e2 exprDesc, line int) exprDesc {\n\tif e, folded := foldConstants(op, e1, e2); folded {\n\t\treturn e\n\t}\n\to2 := 0\n\tif op != opUnaryMinus && op != opLength {\n\t\te2, o2 = f.expressionToRegisterOrConstant(e2)\n\t}\n\te1, o1 := f.expressionToRegisterOrConstant(e1)\n\tif o1 > o2 {\n\t\tf.freeExpression(e1)\n\t\tf.freeExpression(e2)\n\t} else {\n\t\tf.freeExpression(e2)\n\t\tf.freeExpression(e1)\n\t}\n\te1.info, e1.kind = f.EncodeABC(op, 0, o1, o2), kindRelocatable\n\tf.FixLine(line)\n\treturn e1\n}\n\nfunc (f *function) Prefix(op int, e exprDesc, line int) exprDesc {\n\tswitch op {\n\tcase oprMinus:\n\t\tif e.isNumeral() {\n\t\t\te.value = -e.value\n\t\t\treturn e\n\t\t}\n\t\treturn f.encodeArithmetic(opUnaryMinus, f.ExpressionToAnyRegister(e), makeExpression(kindNumber, 0), line)\n\tcase oprNot:\n\t\treturn f.encodeNot(e)\n\tcase oprLength:\n\t\treturn f.encodeArithmetic(opLength, f.ExpressionToAnyRegister(e), makeExpression(kindNumber, 0), line)\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc (f *function) Infix(op int, e exprDesc) exprDesc {\n\tswitch op {\n\tcase oprAnd:\n\t\te = f.GoIfTrue(e)\n\tcase oprOr:\n\t\te = f.GoIfFalse(e)\n\tcase oprConcat:\n\t\te = f.ExpressionToNextRegister(e)\n\tcase oprAdd, oprSub, oprMul, oprDiv, oprMod, oprPow:\n\t\tif !e.isNumeral() {\n\t\t\te, _ = f.expressionToRegisterOrConstant(e)\n\t\t}\n\tdefault:\n\t\te, _ = f.expressionToRegisterOrConstant(e)\n\t}\n\treturn e\n}\n\nfunc (f *function) encodeComparison(op opCode, cond int, e1, e2 exprDesc) exprDesc {\n\te1, o1 := f.expressionToRegisterOrConstant(e1)\n\te2, o2 := f.expressionToRegisterOrConstant(e2)\n\tf.freeExpression(e2)\n\tf.freeExpression(e1)\n\tif cond == 0 && op != opEqual {\n\t\to1, o2, cond = o2, o1, 1\n\t}\n\treturn makeExpression(kindJump, f.conditionalJump(op, cond, o1, o2))\n}\n\nfunc (f *function) Postfix(op int, e1, e2 exprDesc, line int) exprDesc {\n\tswitch op {\n\tcase oprAnd:\n\t\tf.assert(e1.t == noJump)\n\t\te2 = f.DischargeVariables(e2)\n\t\te2.f = f.Concatenate(e2.f, e1.f)\n\t\treturn e2\n\tcase oprOr:\n\t\tf.assert(e1.f == noJump)\n\t\te2 = f.DischargeVariables(e2)\n\t\te2.t = f.Concatenate(e2.t, e1.t)\n\t\treturn e2\n\tcase oprConcat:\n\t\tif e2 = f.ExpressionToValue(e2); e2.kind == kindRelocatable && f.Instruction(e2).opCode() == opConcat {\n\t\t\tf.assert(e1.info == f.Instruction(e2).b()-1)\n\t\t\tf.freeExpression(e1)\n\t\t\tf.Instruction(e2).setB(e1.info)\n\t\t\treturn makeExpression(kindRelocatable, e2.info)\n\t\t}\n\t\treturn f.encodeArithmetic(opConcat, e1, f.ExpressionToNextRegister(e2), line)\n\tcase oprAdd, oprSub, oprMul, oprDiv, oprMod, oprPow:\n\t\treturn f.encodeArithmetic(opCode(op-oprAdd)+opAdd, e1, e2, line)\n\tcase oprEq, oprLT, oprLE:\n\t\treturn f.encodeComparison(opCode(op-oprEq)+opEqual, 1, e1, e2)\n\tcase oprNE, oprGT, oprGE:\n\t\treturn f.encodeComparison(opCode(op-oprNE)+opEqual, 0, e1, e2)\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc (f *function) FixLine(line int) { f.f.lineInfo[len(f.f.code)-1] = int32(line) }\n\nfunc (f *function) setList(base, elementCount, storeCount int) {\n\tif f.assert(storeCount != 0); storeCount == MultipleReturns {\n\t\tstoreCount = 0\n\t}\n\tif c := (elementCount-1)/listItemsPerFlush + 1; c <= maxArgC {\n\t\tf.EncodeABC(opSetList, base, storeCount, c)\n\t} else if c <= maxArgAx {\n\t\tf.EncodeABC(opSetList, base, storeCount, 0)\n\t\tf.encodeExtraArg(c)\n\t} else {\n\t\tf.p.syntaxError(\"constructor too long\")\n\t}\n\tf.freeRegisterCount = base + 1\n}\n\nfunc (f *function) CheckConflict(t *assignmentTarget, e exprDesc) {\n\textra, conflict := f.freeRegisterCount, false\n\tfor ; t != nil; t = t.previous {\n\t\tif t.kind == kindIndexed {\n\t\t\tif t.tableType == e.kind && t.table == e.info {\n\t\t\t\tconflict = true\n\t\t\t\tt.table, t.tableType = extra, kindLocal\n\t\t\t}\n\t\t\tif e.kind == kindLocal && t.index == e.info {\n\t\t\t\tconflict = true\n\t\t\t\tt.index = extra\n\t\t\t}\n\t\t}\n\t}\n\tif conflict {\n\t\tif e.kind == kindLocal {\n\t\t\tf.EncodeABC(opMove, extra, e.info, 0)\n\t\t} else {\n\t\t\tf.EncodeABC(opGetUpValue, extra, e.info, 0)\n\t\t}\n\t\tf.ReserveRegisters(1)\n\t}\n}\n\nfunc (f *function) AdjustAssignment(variableCount, expressionCount int, e exprDesc) {\n\tif extra := variableCount - expressionCount; e.hasMultipleReturns() {\n\t\tif extra++; extra < 0 {\n\t\t\textra = 0\n\t\t}\n\t\tif f.setReturns(e, extra); extra > 1 {\n\t\t\tf.ReserveRegisters(extra - 1)\n\t\t}\n\t} else {\n\t\tif expressionCount > 0 {\n\t\t\t_ = f.ExpressionToNextRegister(e)\n\t\t}\n\t\tif extra > 0 {\n\t\t\tr := f.freeRegisterCount\n\t\t\tf.ReserveRegisters(extra)\n\t\t\tf.loadNil(r, extra)\n\t\t}\n\t}\n}\n\nfunc (f *function) makeUpValue(name string, e exprDesc) int {\n\tf.p.checkLimit(len(f.f.upValues)+1, maxUpValue, \"upvalues\")\n\tf.f.upValues = append(f.f.upValues, upValueDesc{name: name, isLocal: e.kind == kindLocal, index: e.info})\n\treturn len(f.f.upValues) - 1\n}\n\nfunc singleVariableHelper(f *function, name string, base bool) (e exprDesc, found bool) {\n\towningBlock := func(b *block, level int) *block {\n\t\tfor b.activeVariableCount > level {\n\t\t\tb = b.previous\n\t\t}\n\t\treturn b\n\t}\n\tfind := func() (int, bool) {\n\t\tfor i := f.activeVariableCount - 1; i >= 0; i-- {\n\t\t\tif name == f.LocalVariable(i).name {\n\t\t\t\treturn i, true\n\t\t\t}\n\t\t}\n\t\treturn 0, false\n\t}\n\tfindUpValue := func() (int, bool) {\n\t\tfor i, u := range f.f.upValues {\n\t\t\tif u.name == name {\n\t\t\t\treturn i, true\n\t\t\t}\n\t\t}\n\t\treturn 0, false\n\t}\n\tif f == nil {\n\t\treturn\n\t}\n\tvar v int\n\tif v, found = find(); found {\n\t\tif e = makeExpression(kindLocal, v); !base {\n\t\t\towningBlock(f.block, v).hasUpValue = true\n\t\t}\n\t\treturn\n\t}\n\tif v, found = findUpValue(); found {\n\t\treturn makeExpression(kindUpValue, v), true\n\t}\n\tif e, found = singleVariableHelper(f.previous, name, false); !found {\n\t\treturn\n\t}\n\treturn makeExpression(kindUpValue, f.makeUpValue(name, e)), true\n}\n\nfunc (f *function) SingleVariable(name string) (e exprDesc) {\n\tvar found bool\n\tif e, found = singleVariableHelper(f, name, true); !found {\n\t\te, found = singleVariableHelper(f, \"_ENV\", true)\n\t\tf.assert(found && (e.kind == kindLocal || e.kind == kindUpValue))\n\t\te = f.Indexed(e, f.EncodeString(name))\n\t}\n\treturn\n}\n\nfunc (f *function) OpenConstructor() (pc int, t exprDesc) {\n\tpc = f.EncodeABC(opNewTable, 0, 0, 0)\n\tt = f.ExpressionToNextRegister(makeExpression(kindRelocatable, pc))\n\treturn\n}\n\nfunc (f *function) FlushFieldToConstructor(tableRegister, freeRegisterCount int, k exprDesc, v func() exprDesc) {\n\t_, rk := f.expressionToRegisterOrConstant(k)\n\t_, rv := f.expressionToRegisterOrConstant(v())\n\tf.EncodeABC(opSetTable, tableRegister, rk, rv)\n\tf.freeRegisterCount = freeRegisterCount\n}\n\nfunc (f *function) FlushToConstructor(tableRegister, pending, arrayCount int, e exprDesc) int {\n\tf.ExpressionToNextRegister(e)\n\tif pending == listItemsPerFlush {\n\t\tf.setList(tableRegister, arrayCount, listItemsPerFlush)\n\t\tpending = 0\n\t}\n\treturn pending\n}\n\nfunc (f *function) CloseConstructor(pc, tableRegister, pending, arrayCount, hashCount int, e exprDesc) {\n\tif pending != 0 {\n\t\tif e.hasMultipleReturns() {\n\t\t\tf.SetMultipleReturns(e)\n\t\t\tf.setList(tableRegister, arrayCount, MultipleReturns)\n\t\t\tarrayCount--\n\t\t} else {\n\t\t\tif e.kind != kindVoid {\n\t\t\t\tf.ExpressionToNextRegister(e)\n\t\t\t}\n\t\t\tf.setList(tableRegister, arrayCount, pending)\n\t\t}\n\t}\n\tf.f.code[pc].setB(int(float8FromInt(arrayCount)))\n\tf.f.code[pc].setC(int(float8FromInt(hashCount)))\n}\n\nfunc (f *function) OpenForBody(base, n int, isNumeric bool) (prep int) {\n\tif isNumeric {\n\t\tprep = f.encodeAsBx(opForPrep, base, noJump)\n\t} else {\n\t\tprep = f.Jump()\n\t}\n\tf.EnterBlock(false)\n\tf.AdjustLocalVariables(n)\n\tf.ReserveRegisters(n)\n\treturn\n}\n\nfunc (f *function) CloseForBody(prep, base, line, n int, isNumeric bool) {\n\tf.LeaveBlock()\n\tf.PatchToHere(prep)\n\tvar end int\n\tif isNumeric {\n\t\tend = f.encodeAsBx(opForLoop, base, noJump)\n\t} else {\n\t\tf.EncodeABC(opTForCall, base, 0, n)\n\t\tf.FixLine(line)\n\t\tend = f.encodeAsBx(opTForLoop, base+2, noJump)\n\t}\n\tf.PatchList(end, prep+1)\n\tf.FixLine(line)\n}\n\nfunc (f *function) OpenMainFunction() {\n\tf.EnterBlock(false)\n\tf.makeUpValue(\"_ENV\", makeExpression(kindLocal, 0))\n}\n\nfunc (f *function) CloseMainFunction() *function {\n\tf.ReturnNone()\n\tf.LeaveBlock()\n\tf.assert(f.block == nil)\n\treturn f.previous\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 0.4609375,
          "content": "package lua\n\nimport \"math\"\n\nconst (\n\tmaxStack          = 1000000\n\tmaxCallCount      = 200\n\terrorStackSize    = maxStack + 200\n\textraStack        = 5\n\tbasicStackSize    = 2 * MinStack\n\tmaxTagLoop        = 100\n\tfirstPseudoIndex  = -maxStack - 1000\n\tmaxUpValue        = math.MaxUint8\n\tidSize            = 60\n\tapiCheck          = false\n\tinternalCheck     = false\n\tpathListSeparator = ';'\n)\n\nvar defaultPath = \"./?.lua\" // TODO \"${LUA_LDIR}?.lua;${LUA_LDIR}?/init.lua;./?.lua\"\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 14.7333984375,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// A Frame is a token representing an activation record. It is returned by\n// Stack and passed to Info.\ntype Frame *callInfo\n\nfunc (l *State) resetHookCount() { l.hookCount = l.baseHookCount }\nfunc (l *State) prototype(ci *callInfo) *prototype {\n\treturn l.stack[ci.function].(*luaClosure).prototype\n}\nfunc (l *State) currentLine(ci *callInfo) int {\n\treturn int(l.prototype(ci).lineInfo[ci.savedPC - 1])\n}\n\nfunc chunkID(source string) string {\n\tswitch source[0] {\n\tcase '=': // \"literal\" source\n\t\tif len(source) <= idSize {\n\t\t\treturn source[1:]\n\t\t}\n\t\treturn source[1:idSize]\n\tcase '@': // file name\n\t\tif len(source) <= idSize {\n\t\t\treturn source[1:]\n\t\t}\n\t\treturn \"...\" + source[1:idSize-3]\n\t}\n\tsource = strings.Split(source, \"\\n\")[0]\n\tif l := len(\"[string \\\"...\\\"]\"); len(source) > idSize-l {\n\t\treturn \"[string \\\"\" + source + \"...\\\"]\"\n\t}\n\treturn \"[string \\\"\" + source + \"\\\"]\"\n}\n\nfunc (l *State) runtimeError(message string) {\n\tl.push(message)\n\tif ci := l.callInfo; ci.isLua() {\n\t\tline, source := l.currentLine(ci), l.prototype(ci).source\n\t\tif source == \"\" {\n\t\t\tsource = \"?\"\n\t\t} else {\n\t\t\tsource = chunkID(source)\n\t\t}\n\t\tl.push(fmt.Sprintf(\"%s:%d: %s\", source, line, message))\n\t}\n\tl.errorMessage()\n}\n\nfunc (l *State) typeError(v value, operation string) {\n\ttypeName := l.valueToType(v).String()\n\tif ci := l.callInfo; ci.isLua() {\n\t\tc := l.stack[ci.function].(*luaClosure)\n\t\tvar kind, name string\n\t\tisUpValue := func() bool {\n\t\t\tfor i, uv := range c.upValues {\n\t\t\t\tif uv.value() == v {\n\t\t\t\t\tkind, name = \"upvalue\", c.prototype.upValueName(i)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\tframeIndex := 0\n\t\tisInStack := func() bool {\n\t\t\tfor i, e := range ci.frame {\n\t\t\t\tif e == v {\n\t\t\t\t\tframeIndex = i\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\tif !isUpValue() && isInStack() {\n\t\t\tname, kind = c.prototype.objectName(frameIndex, ci.savedPC)\n\t\t}\n\t\tif kind != \"\" {\n\t\t\tl.runtimeError(fmt.Sprintf(\"attempt to %s %s '%s' (a %s value)\", operation, kind, name, typeName))\n\t\t}\n\t}\n\tl.runtimeError(fmt.Sprintf(\"attempt to %s a %s value\", operation, typeName))\n}\n\nfunc (l *State) orderError(left, right value) {\n\tleftType, rightType := l.valueToType(left).String(), l.valueToType(right).String()\n\tif leftType == rightType {\n\t\tl.runtimeError(fmt.Sprintf(\"attempt to compare two '%s' values\", leftType))\n\t}\n\tl.runtimeError(fmt.Sprintf(\"attempt to compare '%s' with '%s'\", leftType, rightType))\n}\n\nfunc (l *State) arithError(v1, v2 value) {\n\tif _, ok := l.toNumber(v1); !ok {\n\t\tv2 = v1\n\t}\n\tl.typeError(v2, \"perform arithmetic on\")\n}\n\nfunc (l *State) concatError(v1, v2 value) {\n\t_, isString := v1.(string)\n\t_, isNumber := v1.(float64)\n\tif isString || isNumber {\n\t\tv1 = v2\n\t}\n\t_, isString = v1.(string)\n\t_, isNumber = v1.(float64)\n\tl.assert(!isString && !isNumber)\n\tl.typeError(v1, \"concatenate\")\n}\n\nfunc (l *State) assert(cond bool) {\n\tif !cond {\n\t\tl.runtimeError(\"assertion failure\")\n\t}\n}\n\nfunc (l *State) errorMessage() {\n\tif l.errorFunction != 0 { // is there an error handling function?\n\t\terrorFunction := l.stack[l.errorFunction]\n\t\tswitch errorFunction.(type) {\n\t\tcase closure:\n\t\tcase *goFunction:\n\t\tdefault:\n\t\t\tl.throw(ErrorError)\n\t\t}\n\t\tl.stack[l.top] = l.stack[l.top-1] // move argument\n\t\tl.stack[l.top-1] = errorFunction  // push function\n\t\tl.top++\n\t\tl.call(l.top-2, 1, false)\n\t}\n\tl.throw(RuntimeError(CheckString(l, -1)))\n}\n\n// SetDebugHook sets the debugging hook function.\n//\n// f is the hook function. mask specifies on which events the hook will be\n// called: it is formed by a bitwise or of the constants MaskCall, MaskReturn,\n// MaskLine, and MaskCount. The count argument is only meaningful when the\n// mask includes MaskCount. For each event, the hook is called as explained\n// below:\n//\n// Call hook is called when the interpreter calls a function. The hook is\n// called just after Lua enters the new function, before the function gets\n// its arguments.\n//\n// Return hook is called when the interpreter returns from a function. The\n// hook is called just before Lua leaves the function. There is no standard\n// way to access the values to be returned by the function.\n//\n// Line hook is called when the interpreter is about to start the execution\n// of a new line of code, or when it jumps back in the code (even to the same\n// line). (This event only happens while Lua is executing a Lua function.)\n//\n// Count hook is called after the interpreter executes every count\n// instructions. (This event only happens while Lua is executing a Lua\n// function.)\n//\n// A hook is disabled by setting mask to zero.\nfunc SetDebugHook(l *State, f Hook, mask byte, count int) {\n\tif f == nil || mask == 0 {\n\t\tf, mask = nil, 0\n\t}\n\tif ci := l.callInfo; ci.isLua() {\n\t\tl.oldPC = ci.savedPC\n\t}\n\tl.hooker, l.baseHookCount = f, count\n\tl.resetHookCount()\n\tl.hookMask = mask\n\tl.internalHook = false\n}\n\n// DebugHook returns the current hook function.\nfunc DebugHook(l *State) Hook { return l.hooker }\n\n// DebugHookMask returns the current hook mask.\nfunc DebugHookMask(l *State) byte { return l.hookMask }\n\n// DebugHookCount returns the current hook count.\nfunc DebugHookCount(l *State) int { return l.hookCount }\n\n// Stack gets information about the interpreter runtime stack.\n//\n// It returns a Frame identifying the activation record of the\n// function executing at a given level. Level 0 is the current running\n// function, whereas level n+1 is the function that has called level n (except\n// for tail calls, which do not count on the stack). When there are no errors,\n// Stack returns true; when called with a level greater than the stack depth,\n// it returns false.\nfunc Stack(l *State, level int) (f Frame, ok bool) {\n\tif level < 0 {\n\t\treturn // invalid (negative) level\n\t}\n\tcallInfo := l.callInfo\n\tfor ; level > 0 && callInfo != &l.baseCallInfo; level, callInfo = level-1, callInfo.previous {\n\t}\n\tif level == 0 && callInfo != &l.baseCallInfo { // level found?\n\t\tf, ok = callInfo, true\n\t}\n\treturn\n}\n\nfunc functionInfo(p Debug, f closure) (d Debug) {\n\td = p\n\tif l, ok := f.(*luaClosure); !ok {\n\t\td.Source = \"=[Go]\"\n\t\td.LineDefined, d.LastLineDefined = -1, -1\n\t\td.What = \"Go\"\n\t} else {\n\t\tp := l.prototype\n\t\td.Source = p.source\n\t\tif d.Source == \"\" {\n\t\t\td.Source = \"=?\"\n\t\t}\n\t\td.LineDefined, d.LastLineDefined = p.lineDefined, p.lastLineDefined\n\t\td.What = \"Lua\"\n\t\tif d.LineDefined == 0 {\n\t\t\td.What = \"main\"\n\t\t}\n\t}\n\td.ShortSource = chunkID(d.Source)\n\treturn\n}\n\nfunc (l *State) functionName(ci *callInfo) (name, kind string) {\n\tif ci == &l.baseCallInfo {\n\t\treturn\n\t}\n\tvar tm tm\n\tp := l.prototype(ci)\n\tpc := ci.savedPC\n\tswitch i := p.code[pc]; i.opCode() {\n\tcase opCall, opTailCall:\n\t\treturn p.objectName(i.a(), pc)\n\tcase opTForCall:\n\t\treturn \"for iterator\", \"for iterator\"\n\tcase opSelf, opGetTableUp, opGetTable:\n\t\ttm = tmIndex\n\tcase opSetTableUp, opSetTable:\n\t\ttm = tmNewIndex\n\tcase opEqual:\n\t\ttm = tmEq\n\tcase opAdd:\n\t\ttm = tmAdd\n\tcase opSub:\n\t\ttm = tmSub\n\tcase opMul:\n\t\ttm = tmMul\n\tcase opDiv:\n\t\ttm = tmDiv\n\tcase opMod:\n\t\ttm = tmMod\n\tcase opPow:\n\t\ttm = tmPow\n\tcase opUnaryMinus:\n\t\ttm = tmUnaryMinus\n\tcase opLength:\n\t\ttm = tmLen\n\tcase opLessThan:\n\t\ttm = tmLT\n\tcase opLessOrEqual:\n\t\ttm = tmLE\n\tcase opConcat:\n\t\ttm = tmConcat\n\tdefault:\n\t\treturn\n\t}\n\treturn eventNames[tm], \"metamethod\"\n}\n\nfunc (l *State) collectValidLines(f closure) {\n\tif lc, ok := f.(*luaClosure); !ok {\n\t\tl.apiPush(nil)\n\t} else {\n\t\tt := newTable()\n\t\tl.apiPush(t)\n\t\tfor _, i := range lc.prototype.lineInfo {\n\t\t\tt.putAtInt(int(i), true)\n\t\t}\n\t}\n}\n\n// Info gets information about a specific function or function invocation.\n//\n// To get information about a function invocation, the parameter where must\n// be a valid activation record that was filled by a previous call to Stack\n// or given as an argument to a hook (see Hook).\n//\n// To get information about a function you push it onto the stack and start\n// the what string with the character '>'. (In that case, Info pops the\n// function from the top of the stack.) For instance, to know in which line\n// a function f was defined, you can write the following code:\n//   l.Global(\"f\") // Get global 'f'.\n//   d, _ := lua.Info(l, \">S\", nil)\n//   fmt.Printf(\"%d\\n\", d.LineDefined)\n//\n// Each character in the string what selects some fields of the Debug struct\n// to be filled or a value to be pushed on the stack:\n// \t 'n': fills in the field Name and NameKind\n// \t 'S': fills in the fields Source, ShortSource, LineDefined, LastLineDefined, and What\n// \t 'l': fills in the field CurrentLine\n// \t 't': fills in the field IsTailCall\n// \t 'u': fills in the fields UpValueCount, ParameterCount, and IsVarArg\n// \t 'f': pushes onto the stack the function that is running at the given level\n// \t 'L': pushes onto the stack a table whose indices are the numbers of the lines that are valid on the function\n// (A valid line is a line with some associated code, that is, a line where you\n// can put a break point. Non-valid lines include empty lines and comments.)\n//\n// This function returns false on error (for instance, an invalid option in what).\nfunc Info(l *State, what string, where Frame) (d Debug, ok bool) {\n\tvar f closure\n\tvar fun value\n\tif what[0] == '>' {\n\t\twhere = nil\n\t\tfun = l.stack[l.top-1]\n\t\tswitch fun := fun.(type) {\n\t\tcase closure:\n\t\t\tf = fun\n\t\tcase *goFunction:\n\t\tdefault:\n\t\t\tpanic(\"function expected\")\n\t\t}\n\t\twhat = what[1:] // skip the '>'\n\t\tl.top--         // pop function\n\t} else {\n\t\tfun = l.stack[where.function]\n\t\tswitch fun := fun.(type) {\n\t\tcase closure:\n\t\t\tf = fun\n\t\tcase *goFunction:\n\t\tdefault:\n\t\t\tl.assert(false)\n\t\t}\n\t}\n\tok, hasL, hasF := true, false, false\n\td.callInfo = where\n\tci := d.callInfo\n\tfor _, r := range what {\n\t\tswitch r {\n\t\tcase 'S':\n\t\t\td = functionInfo(d, f)\n\t\tcase 'l':\n\t\t\td.CurrentLine = -1\n\t\t\tif where != nil && ci.isLua() {\n\t\t\t\td.CurrentLine = l.currentLine(where)\n\t\t\t}\n\t\tcase 'u':\n\t\t\tif f == nil {\n\t\t\t\td.UpValueCount = 0\n\t\t\t} else {\n\t\t\t\td.UpValueCount = f.upValueCount()\n\t\t\t}\n\t\t\tif lf, ok := f.(*luaClosure); !ok {\n\t\t\t\td.IsVarArg = true\n\t\t\t\td.ParameterCount = 0\n\t\t\t} else {\n\t\t\t\td.IsVarArg = lf.prototype.isVarArg\n\t\t\t\td.ParameterCount = lf.prototype.parameterCount\n\t\t\t}\n\t\tcase 't':\n\t\t\td.IsTailCall = where != nil && ci.isCallStatus(callStatusTail)\n\t\tcase 'n':\n\t\t\t// calling function is a known Lua function?\n\t\t\tif where != nil && !ci.isCallStatus(callStatusTail) && where.previous.isLua() {\n\t\t\t\td.Name, d.NameKind = l.functionName(where.previous)\n\t\t\t} else {\n\t\t\t\td.NameKind = \"\"\n\t\t\t}\n\t\t\tif d.NameKind == \"\" {\n\t\t\t\td.NameKind = \"\" // not found\n\t\t\t\td.Name = \"\"\n\t\t\t}\n\t\tcase 'L':\n\t\t\thasL = true\n\t\tcase 'f':\n\t\t\thasF = true\n\t\tdefault:\n\t\t\tok = false\n\t\t}\n\t}\n\tif hasF {\n\t\tl.apiPush(f)\n\t}\n\tif hasL {\n\t\tl.collectValidLines(f)\n\t}\n\treturn d, ok\n}\n\nfunc upValueHelper(f func(*State, int, int) (string, bool), returnValueCount int) Function {\n\treturn func(l *State) int {\n\t\tCheckType(l, 1, TypeFunction)\n\t\tname, ok := f(l, 1, CheckInteger(l, 2))\n\t\tif !ok {\n\t\t\treturn 0\n\t\t}\n\t\tl.PushString(name)\n\t\tl.Insert(-returnValueCount)\n\t\treturn returnValueCount\n\t}\n}\n\nfunc (l *State) checkUpValue(f, upValueCount int) int {\n\tn := CheckInteger(l, upValueCount)\n\tCheckType(l, f, TypeFunction)\n\tl.PushValue(f)\n\tdebug, _ := Info(l, \">u\", nil)\n\tArgumentCheck(l, 1 <= n && n <= debug.UpValueCount, upValueCount, \"invalue upvalue index\")\n\treturn n\n}\n\nfunc threadArg(l *State) (int, *State) {\n\tif l.IsThread(1) {\n\t\treturn 1, l.ToThread(1)\n\t}\n\treturn 0, l\n}\n\nfunc hookTable(l *State) bool { return SubTable(l, RegistryIndex, \"_HKEY\") }\n\nfunc internalHook(l *State, d Debug) {\n\thookNames := []string{\"call\", \"return\", \"line\", \"count\", \"tail call\"}\n\thookTable(l)\n\tl.PushThread()\n\tl.RawGet(-2)\n\tif l.IsFunction(-1) {\n\t\tl.PushString(hookNames[d.Event])\n\t\tif d.CurrentLine >= 0 {\n\t\t\tl.PushInteger(d.CurrentLine)\n\t\t} else {\n\t\t\tl.PushNil()\n\t\t}\n\t\t_, ok := Info(l, \"lS\", d.callInfo)\n\t\tl.assert(ok)\n\t\tl.Call(2, 0)\n\t}\n}\n\nfunc maskToString(mask byte) (s string) {\n\tif mask&MaskCall != 0 {\n\t\ts += \"c\"\n\t}\n\tif mask&MaskReturn != 0 {\n\t\ts += \"r\"\n\t}\n\tif mask&MaskLine != 0 {\n\t\ts += \"l\"\n\t}\n\treturn\n}\n\nfunc stringToMask(s string, maskCount bool) (mask byte) {\n\tfor r, b := range map[rune]byte{'c': MaskCall, 'r': MaskReturn, 'l': MaskLine} {\n\t\tif strings.ContainsRune(s, r) {\n\t\t\tmask |= b\n\t\t}\n\t}\n\tif maskCount {\n\t\tmask |= MaskCount\n\t}\n\treturn\n}\n\nvar debugLibrary = []RegistryFunction{\n\t// {\"debug\", db_debug},\n\t{\"getuservalue\", func(l *State) int {\n\t\tif l.TypeOf(1) != TypeUserData {\n\t\t\tl.PushNil()\n\t\t} else {\n\t\t\tl.UserValue(1)\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"gethook\", func(l *State) int {\n\t\t_, l1 := threadArg(l)\n\t\thooker, mask := DebugHook(l1), DebugHookMask(l1)\n\t\tif hooker != nil && !l.internalHook {\n\t\t\tl.PushString(\"external hook\")\n\t\t} else {\n\t\t\thookTable(l)\n\t\t\tl1.PushThread()\n\t\t\t//\t\t\tXMove(l1, l, 1)\n\t\t\tpanic(\"XMove not implemented yet\")\n\t\t\tl.RawGet(-2)\n\t\t\tl.Remove(-2)\n\t\t}\n\t\tl.PushString(maskToString(mask))\n\t\tl.PushInteger(DebugHookCount(l1))\n\t\treturn 3\n\t}},\n\t// {\"getinfo\", db_getinfo},\n\t// {\"getlocal\", db_getlocal},\n\t{\"getregistry\", func(l *State) int { l.PushValue(RegistryIndex); return 1 }},\n\t{\"getmetatable\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tif !l.MetaTable(1) {\n\t\t\tl.PushNil()\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"getupvalue\", upValueHelper(UpValue, 2)},\n\t{\"upvaluejoin\", func(l *State) int {\n\t\tn1 := l.checkUpValue(1, 2)\n\t\tn2 := l.checkUpValue(3, 4)\n\t\tArgumentCheck(l, !l.IsGoFunction(1), 1, \"Lua function expected\")\n\t\tArgumentCheck(l, !l.IsGoFunction(3), 3, \"Lua function expected\")\n\t\tUpValueJoin(l, 1, n1, 3, n2)\n\t\treturn 0\n\t}},\n\t{\"upvalueid\", func(l *State) int { l.PushLightUserData(UpValueId(l, 1, l.checkUpValue(1, 2))); return 1 }},\n\t{\"setuservalue\", func(l *State) int {\n\t\tif l.TypeOf(1) == TypeLightUserData {\n\t\t\tArgumentError(l, 1, \"full userdata expected, got light userdata\")\n\t\t}\n\t\tCheckType(l, 1, TypeUserData)\n\t\tif !l.IsNoneOrNil(2) {\n\t\t\tCheckType(l, 2, TypeTable)\n\t\t}\n\t\tl.SetTop(2)\n\t\tl.SetUserValue(1)\n\t\treturn 1\n\t}},\n\t{\"sethook\", func(l *State) int {\n\t\tvar hook Hook\n\t\tvar mask byte\n\t\tvar count int\n\t\ti, l1 := threadArg(l)\n\t\tif l.IsNoneOrNil(i + 1) {\n\t\t\tl.SetTop(i + 1)\n\t\t} else {\n\t\t\ts := CheckString(l, i+2)\n\t\t\tCheckType(l, i+1, TypeFunction)\n\t\t\tcount = OptInteger(l, i+3, 0)\n\t\t\thook, mask = internalHook, stringToMask(s, count > 0)\n\t\t}\n\t\tif !hookTable(l) {\n\t\t\tl.PushString(\"k\")\n\t\t\tl.SetField(-2, \"__mode\")\n\t\t\tl.PushValue(-1)\n\t\t\tl.SetMetaTable(-2)\n\t\t}\n\t\tl1.PushThread()\n\t\t//\t \tXMove(l1, l, 1)\n\t\tpanic(\"XMove not yet implemented\")\n\t\tl.PushValue(i + 1)\n\t\tl.RawSet(-3)\n\t\tSetDebugHook(l1, hook, mask, count)\n\t\tl1.internalHook = true\n\t\treturn 0\n\t}},\n\t// {\"setlocal\", db_setlocal},\n\t{\"setmetatable\", func(l *State) int {\n\t\tt := l.TypeOf(2)\n\t\tArgumentCheck(l, t == TypeNil || t == TypeTable, 2, \"nil or table expected\")\n\t\tl.SetTop(2)\n\t\tl.SetMetaTable(1)\n\t\treturn 1\n\t}},\n\t{\"setupvalue\", upValueHelper(SetUpValue, 1)},\n\t{\"traceback\", func(l *State) int {\n\t\ti, l1 := threadArg(l)\n\t\tif s, ok := l.ToString(i + 1); !ok && !l.IsNoneOrNil(i+1) {\n\t\t\tl.PushValue(i + 1)\n\t\t} else if l == l1 {\n\t\t\tTraceback(l, l, s, OptInteger(l, i+2, 1))\n\t\t} else {\n\t\t\tTraceback(l, l1, s, OptInteger(l, i+2, 0))\n\t\t}\n\t\treturn 1\n\t}},\n}\n\n// DebugOpen opens the debug library. Usually passed to Require.\nfunc DebugOpen(l *State) int {\n\tNewLibrary(l, debugLibrary)\n\treturn 1\n}\n"
        },
        {
          "name": "dev.yml",
          "type": "blob",
          "size": 0.525390625,
          "content": "name: go-lua\n\nup:\n  - go: 1.22.1\n  - custom:\n      name: Initializing submodules\n      met?: test -f lua-tests/.git\n      meet: git submodule update --init\n  - custom:\n      name: Lua version check\n      met?: |\n        if [ ! $(luac -v | awk ' { print $2 }') == \"5.2.4\" ]; then\n          echo \"Luac version 5.2.4 is required.\"\n          echo \"Luac is installed with Lua.\"\n          echo \"brew install lua\"\n          exit 1\n        fi\n      meet: \"true\"\n\ncommands:\n  test:\n    run: go test -v -tags=!skip ./...\n    desc: \"run unit tests\"\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.083984375,
          "content": "// Package lua is a port of the Lua VM from http://lua.org/ from C to Go.\npackage lua\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc_test.go",
          "type": "blob",
          "size": 0.525390625,
          "content": "package lua_test\n\nimport (\n\t\"github.com/Shopify/go-lua\"\n)\n\n// This example receives a variable number of numerical arguments and returns their average and sum.\nfunc ExampleFunction(l *lua.State) int {\n\tn := l.Top() // Number of arguments.\n\tvar sum float64\n\tfor i := 1; i <= n; i++ {\n\t\tf, ok := l.ToNumber(i)\n\t\tif !ok {\n\t\t\tl.PushString(\"incorrect argument\")\n\t\t\tl.Error()\n\t\t}\n\t\tsum += f\n\t}\n\tl.PushNumber(sum / float64(n)) // First result.\n\tl.PushNumber(sum)              // Second result.\n\treturn 2                       // Result count.\n}\n"
        },
        {
          "name": "dump.go",
          "type": "blob",
          "size": 2.6494140625,
          "content": "package lua\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\ntype dumpState struct {\n\tl     *State\n\tout   io.Writer\n\torder binary.ByteOrder\n\terr   error\n}\n\nfunc (d *dumpState) write(data interface{}) {\n\tif d.err == nil {\n\t\td.err = binary.Write(d.out, d.order, data)\n\t}\n}\n\nfunc (d *dumpState) writeInt(i int) {\n\td.write(int32(i))\n}\n\nfunc (d *dumpState) writePC(p pc) {\n\td.writeInt(int(p))\n}\n\nfunc (d *dumpState) writeCode(p *prototype) {\n\td.writeInt(len(p.code))\n\td.write(p.code)\n}\n\nfunc (d *dumpState) writeByte(b byte) {\n\td.write(b)\n}\n\nfunc (d *dumpState) writeBool(b bool) {\n\tif b {\n\t\td.writeByte(1)\n\t} else {\n\t\td.writeByte(0)\n\t}\n}\n\nfunc (d *dumpState) writeNumber(f float64) {\n\td.write(f)\n}\n\nfunc (d *dumpState) writeConstants(p *prototype) {\n\td.writeInt(len(p.constants))\n\n\tfor _, o := range p.constants {\n\t\td.writeByte(byte(d.l.valueToType(o)))\n\n\t\tswitch o := o.(type) {\n\t\tcase nil:\n\t\tcase bool:\n\t\t\td.writeBool(o)\n\t\tcase float64:\n\t\t\td.writeNumber(o)\n\t\tcase string:\n\t\t\td.writeString(o)\n\t\tdefault:\n\t\t\td.l.assert(false)\n\t\t}\n\t}\n}\n\nfunc (d *dumpState) writePrototypes(p *prototype) {\n\td.writeInt(len(p.prototypes))\n\n\tfor _, o := range p.prototypes {\n\t\td.dumpFunction(&o)\n\t}\n}\n\nfunc (d *dumpState) writeUpvalues(p *prototype) {\n\td.writeInt(len(p.upValues))\n\n\tfor _, u := range p.upValues {\n\t\td.writeBool(u.isLocal)\n\t\td.writeByte(byte(u.index))\n\t}\n}\n\nfunc (d *dumpState) writeString(s string) {\n\tba := []byte(s)\n\tsize := len(s)\n\tif size > 0 {\n\t\tsize++ //accounts for 0 byte at the end\n\t}\n\tswitch header.PointerSize {\n\tcase 8:\n\t\td.write(uint64(size))\n\tcase 4:\n\t\td.write(uint32(size))\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unsupported pointer size (%d)\", header.PointerSize))\n\t}\n\tif size > 0 {\n\t\td.write(ba)\n\t\td.writeByte(0)\n\t}\n}\n\nfunc (d *dumpState) writeLocalVariables(p *prototype) {\n\td.writeInt(len(p.localVariables))\n\n\tfor _, lv := range p.localVariables {\n\t\td.writeString(lv.name)\n\t\td.writePC(lv.startPC)\n\t\td.writePC(lv.endPC)\n\t}\n}\n\nfunc (d *dumpState) writeDebug(p *prototype) {\n\td.writeString(p.source)\n\td.writeInt(len(p.lineInfo))\n\td.write(p.lineInfo)\n\td.writeLocalVariables(p)\n\n\td.writeInt(len(p.upValues))\n\n\tfor _, uv := range p.upValues {\n\t\td.writeString(uv.name)\n\t}\n}\n\nfunc (d *dumpState) dumpFunction(p *prototype) {\n\td.writeInt(p.lineDefined)\n\td.writeInt(p.lastLineDefined)\n\td.writeByte(byte(p.parameterCount))\n\td.writeBool(p.isVarArg)\n\td.writeByte(byte(p.maxStackSize))\n\td.writeCode(p)\n\td.writeConstants(p)\n\td.writePrototypes(p)\n\td.writeUpvalues(p)\n\td.writeDebug(p)\n}\n\nfunc (d *dumpState) dumpHeader() {\n\td.err = binary.Write(d.out, d.order, header)\n}\n\nfunc (l *State) dump(p *prototype, w io.Writer) error {\n\td := dumpState{l: l, out: w, order: endianness()}\n\td.dumpHeader()\n\td.dumpFunction(p)\n\n\treturn d.err\n}\n"
        },
        {
          "name": "dump_test.go",
          "type": "blob",
          "size": 2.2197265625,
          "content": "package lua\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestUndumpThenDumpReturnsTheSameFunction(t *testing.T) {\n\t_, err := exec.LookPath(\"luac\")\n\tif err != nil {\n\t\tt.Skipf(\"testing dump requires luac: %s\", err)\n\t}\n\tsource := filepath.Join(\"lua-tests\", \"checktable.lua\")\n\tbinary := filepath.Join(\"lua-tests\", \"checktable.bin\")\n\tif err := exec.Command(\"luac\", \"-o\", binary, source).Run(); err != nil {\n\t\tt.Fatalf(\"luac failed to compile %s: %s\", source, err)\n\t}\n\tfile, err := os.Open(binary)\n\tif err != nil {\n\t\tt.Fatal(\"couldn't open checktable.bin\")\n\t}\n\n\tl := NewState()\n\tclosure, err := l.undump(file, \"test\")\n\tif err != nil {\n\t\toffset, _ := file.Seek(0, 1)\n\t\tt.Error(\"unexpected error\", err, \"at file offset\", offset)\n\t}\n\tif closure == nil {\n\t\tt.Error(\"closure was nil\")\n\t}\n\tp := closure.prototype\n\tif p == nil {\n\t\tt.Fatal(\"prototype was nil\")\n\t}\n\n\tvar out bytes.Buffer\n\terr = l.Dump(&out)\n\tif err != nil {\n\t\tt.Error(\"unexpected error\", err, \"with testing dump\")\n\t}\n\n\texpectedBinary, err := ioutil.ReadFile(binary)\n\tif err != nil {\n\t\tt.Error(\"error reading file\", err)\n\t}\n\tactualBinary, err := ioutil.ReadAll(&out)\n\tif err != nil {\n\t\tt.Error(\"error reading out bugger\", err)\n\t}\n\tif !bytes.Equal(expectedBinary, actualBinary) {\n\t\tt.Errorf(\"binary chunks are not the same: %v %v\", expectedBinary, actualBinary)\n\t}\n}\n\nfunc TestDumpThenUndumpReturnsTheSameFunction(t *testing.T) {\n\t_, err := exec.LookPath(\"luac\")\n\tif err != nil {\n\t\tt.Skipf(\"testing dump requires luac: %s\", err)\n\t}\n\tsource := filepath.Join(\"lua-tests\", \"checktable.lua\")\n\tl := NewState()\n\terr = LoadFile(l, source, \"\")\n\tif err != nil {\n\t\tt.Error(\"unexpected error\", err, \"with loading file\", source)\n\t}\n\n\tvar out bytes.Buffer\n\tf := l.stack[l.top-1].(*luaClosure)\n\terr = l.Dump(&out)\n\tif err != nil {\n\t\tt.Error(\"unexpected error\", err, \"with testing dump\")\n\t}\n\n\tclosure, err := l.undump(&out, \"test\")\n\tif err != nil {\n\t\tt.Error(\"unexpected error\", err)\n\t}\n\tif closure == nil {\n\t\tt.Fatal(\"closure was nil\")\n\t}\n\tundumpedPrototype := closure.prototype\n\tif undumpedPrototype == nil {\n\t\tt.Fatal(\"prototype was nil\")\n\t}\n\n\tif !reflect.DeepEqual(f.prototype, undumpedPrototype) {\n\t\tt.Errorf(\"prototypes not the same: %#v %#v\", f.prototype, undumpedPrototype)\n\t}\n}\n"
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.041015625,
          "content": "module github.com/Shopify/go-lua\n\ngo 1.22\n"
        },
        {
          "name": "go_test.go",
          "type": "blob",
          "size": 1.9560546875,
          "content": "// Skip these test since they have different results based on the CPU architecture.\n//go:build skip\n\npackage lua\n\n// Test assumptions about how Go works\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"testing\"\n\t\"unicode\"\n)\n\nfunc TestStringCompare(t *testing.T) {\n\ts1 := \"hello\\x00world\"\n\ts2 := \"hello\\x00sweet\"\n\tif s1 <= s2 {\n\t\tt.Error(\"s1 <= s2\")\n\t}\n}\n\nfunc TestStringLength(t *testing.T) {\n\ts := \"hello\\x00world\"\n\tif len(s) != 11 {\n\t\tt.Error(\"go doesn't count embedded nulls in string length\")\n\t}\n}\n\nfunc TestIsControl(t *testing.T) {\n\tt.Skip()\n\tfor i := 0; i < 256; i++ {\n\t\tcontrol := i < 0x20 || i == 0x7f\n\t\tif lib := unicode.Is(unicode.Cc, rune(i)); control != lib {\n\t\t\tt.Errorf(\"%x: is control? %s\", i, strconv.FormatBool(lib))\n\t\t}\n\t}\n}\n\nfunc TestReslicing(t *testing.T) {\n\ta := [5]int{0, 1, 2, 3, 4}\n\ts := a[:0]\n\tif cap(s) != cap(a) {\n\t\tt.Error(\"cap(s) != cap(a)\")\n\t}\n\tif len(s) != 0 {\n\t\tt.Error(\"len(s) != 0\")\n\t}\n\ts = a[1:3]\n\tif cap(s) == len(s) {\n\t\tt.Error(\"cap(s) == len(s)\")\n\t}\n\ts = s[:cap(s)]\n\tif cap(s) != len(s) {\n\t\tt.Error(\"cap(s) != len(s)\")\n\t}\n}\n\nfunc TestPow(t *testing.T) {\n\t// if a, b := math.Pow(10.0, 33.0), 1.0e33; a != b {\n\t// \tt.Errorf(\"%v != %v\\n\", a, b)\n\t// }\n\tif a, b := math.Pow10(33), 1.0e33; a != b {\n\t\tt.Errorf(\"%v != %v\\n\", a, b)\n\t}\n}\n\nfunc TestParseFloat(t *testing.T) {\n\tif f, err := strconv.ParseFloat(\"inf\", 64); err != nil {\n\t\tt.Error(\"ParseFloat('inf', 64) == \", f, err)\n\t}\n}\n\nfunc TestUnsigned(t *testing.T) {\n\tn := -1.0\n\tconst supUnsigned = float64(^uint32(0)) + 1\n\tif x := math.Floor(n / supUnsigned); x != -1.0 {\n\t\tt.Error(\"math.Floor(-1/supUnsigned) == \", x)\n\t}\n\tif x := math.Floor(n/supUnsigned) * supUnsigned; x != -4294967296.0 {\n\t\tt.Error(\"math.Floor(n/supUnsigned)*supUnsigned == \", x)\n\t}\n\tif x := n - math.Floor(n/supUnsigned)*supUnsigned; x != 4294967295.0 {\n\t\tt.Error(\"n-math.Floor(n/supUnsigned)*supUnsigned == \", x)\n\t}\n\tif x := uint(n - math.Floor(n/supUnsigned)*supUnsigned); x != 4294967295 {\n\t\tt.Error(\"uint(n-math.Floor(n/supUnsigned)*supUnsigned) == \", x)\n\t}\n}\n"
        },
        {
          "name": "instructions.go",
          "type": "blob",
          "size": 7.6240234375,
          "content": "package lua\n\nimport \"fmt\"\n\ntype opCode uint\n\nconst (\n\tiABC int = iota\n\tiABx\n\tiAsBx\n\tiAx\n)\n\nconst (\n\topMove opCode = iota\n\topLoadConstant\n\topLoadConstantEx\n\topLoadBool\n\topLoadNil\n\topGetUpValue\n\topGetTableUp\n\topGetTable\n\topSetTableUp\n\topSetUpValue\n\topSetTable\n\topNewTable\n\topSelf\n\topAdd\n\topSub\n\topMul\n\topDiv\n\topMod\n\topPow\n\topUnaryMinus\n\topNot\n\topLength\n\topConcat\n\topJump\n\topEqual\n\topLessThan\n\topLessOrEqual\n\topTest\n\topTestSet\n\topCall\n\topTailCall\n\topReturn\n\topForLoop\n\topForPrep\n\topTForCall\n\topTForLoop\n\topSetList\n\topClosure\n\topVarArg\n\topExtraArg\n)\n\nvar opNames = []string{\n\t\"MOVE\",\n\t\"LOADK\",\n\t\"LOADKX\",\n\t\"LOADBOOL\",\n\t\"LOADNIL\",\n\t\"GETUPVAL\",\n\t\"GETTABUP\",\n\t\"GETTABLE\",\n\t\"SETTABUP\",\n\t\"SETUPVAL\",\n\t\"SETTABLE\",\n\t\"NEWTABLE\",\n\t\"SELF\",\n\t\"ADD\",\n\t\"SUB\",\n\t\"MUL\",\n\t\"DIV\",\n\t\"MOD\",\n\t\"POW\",\n\t\"UNM\",\n\t\"NOT\",\n\t\"LEN\",\n\t\"CONCAT\",\n\t\"JMP\",\n\t\"EQ\",\n\t\"LT\",\n\t\"LE\",\n\t\"TEST\",\n\t\"TESTSET\",\n\t\"CALL\",\n\t\"TAILCALL\",\n\t\"RETURN\",\n\t\"FORLOOP\",\n\t\"FORPREP\",\n\t\"TFORCALL\",\n\t\"TFORLOOP\",\n\t\"SETLIST\",\n\t\"CLOSURE\",\n\t\"VARARG\",\n\t\"EXTRAARG\",\n}\n\nconst (\n\tsizeC             = 9\n\tsizeB             = 9\n\tsizeBx            = sizeC + sizeB\n\tsizeA             = 8\n\tsizeAx            = sizeC + sizeB + sizeA\n\tsizeOp            = 6\n\tposOp             = 0\n\tposA              = posOp + sizeOp\n\tposC              = posA + sizeA\n\tposB              = posC + sizeC\n\tposBx             = posC\n\tposAx             = posA\n\tbitRK             = 1 << (sizeB - 1)\n\tmaxIndexRK        = bitRK - 1\n\tmaxArgAx          = 1<<sizeAx - 1\n\tmaxArgBx          = 1<<sizeBx - 1\n\tmaxArgSBx         = maxArgBx >> 1 // sBx is signed\n\tmaxArgA           = 1<<sizeA - 1\n\tmaxArgB           = 1<<sizeB - 1\n\tmaxArgC           = 1<<sizeC - 1\n\tlistItemsPerFlush = 50 // # list items to accumulate before a setList instruction\n)\n\ntype instruction uint32\n\nfunc isConstant(x int) bool   { return 0 != x&bitRK }\nfunc constantIndex(r int) int { return r & ^bitRK }\nfunc asConstant(r int) int    { return r | bitRK }\n\n// creates a mask with 'n' 1 bits at position 'p'\nfunc mask1(n, p uint) instruction { return ^(^instruction(0) << n) << p }\n\n// creates a mask with 'n' 0 bits at position 'p'\nfunc mask0(n, p uint) instruction { return ^mask1(n, p) }\n\nfunc (i instruction) opCode() opCode         { return opCode(i >> posOp & (1<<sizeOp - 1)) }\nfunc (i instruction) arg(pos, size uint) int { return int(i >> pos & mask1(size, 0)) }\nfunc (i *instruction) setOpCode(op opCode)   { i.setArg(posOp, sizeOp, int(op)) }\nfunc (i *instruction) setArg(pos, size uint, arg int) {\n\t*i = *i&mask0(size, pos) | instruction(arg)<<pos&mask1(size, pos)\n}\n\n// Note: the gc optimizer cannot inline through multiple function calls. Manually inline for now.\n// func (i instruction) a() int   { return i.arg(posA, sizeA) }\n// func (i instruction) b() int   { return i.arg(posB, sizeB) }\n// func (i instruction) c() int   { return i.arg(posC, sizeC) }\n// func (i instruction) bx() int  { return i.arg(posBx, sizeBx) }\n// func (i instruction) ax() int  { return i.arg(posAx, sizeAx) }\n// func (i instruction) sbx() int { return i.bx() - maxArgSBx }\n\nfunc (i instruction) a() int   { return int(i >> posA & maxArgA) }\nfunc (i instruction) b() int   { return int(i >> posB & maxArgB) }\nfunc (i instruction) c() int   { return int(i >> posC & maxArgC) }\nfunc (i instruction) bx() int  { return int(i >> posBx & maxArgBx) }\nfunc (i instruction) ax() int  { return int(i >> posAx & maxArgAx) }\nfunc (i instruction) sbx() int { return int(i>>posBx&maxArgBx) - maxArgSBx }\n\nfunc (i *instruction) setA(arg int)   { i.setArg(posA, sizeA, arg) }\nfunc (i *instruction) setB(arg int)   { i.setArg(posB, sizeB, arg) }\nfunc (i *instruction) setC(arg int)   { i.setArg(posC, sizeC, arg) }\nfunc (i *instruction) setBx(arg int)  { i.setArg(posBx, sizeBx, arg) }\nfunc (i *instruction) setAx(arg int)  { i.setArg(posAx, sizeAx, arg) }\nfunc (i *instruction) setSBx(arg int) { i.setArg(posBx, sizeBx, arg+maxArgSBx) }\n\nfunc createABC(op opCode, a, b, c int) instruction {\n\treturn instruction(op)<<posOp |\n\t\tinstruction(a)<<posA |\n\t\tinstruction(b)<<posB |\n\t\tinstruction(c)<<posC\n}\n\nfunc createABx(op opCode, a, bx int) instruction {\n\treturn instruction(op)<<posOp |\n\t\tinstruction(a)<<posA |\n\t\tinstruction(bx)<<posBx\n}\n\nfunc createAx(op opCode, a int) instruction { return instruction(op)<<posOp | instruction(a)<<posAx }\n\nfunc (i instruction) String() string {\n\top := i.opCode()\n\ts := opNames[op]\n\tswitch opMode(op) {\n\tcase iABC:\n\t\ts = fmt.Sprintf(\"%s %d\", s, i.a())\n\t\tif bMode(op) == opArgK && isConstant(i.b()) {\n\t\t\ts = fmt.Sprintf(\"%s constant %d\", s, constantIndex(i.b()))\n\t\t} else if bMode(op) != opArgN {\n\t\t\ts = fmt.Sprintf(\"%s %d\", s, i.b())\n\t\t}\n\t\tif cMode(op) == opArgK && isConstant(i.c()) {\n\t\t\ts = fmt.Sprintf(\"%s constant %d\", s, constantIndex(i.c()))\n\t\t} else if cMode(op) != opArgN {\n\t\t\ts = fmt.Sprintf(\"%s %d\", s, i.c())\n\t\t}\n\tcase iAsBx:\n\t\ts = fmt.Sprintf(\"%s %d\", s, i.a())\n\t\tif bMode(op) != opArgN {\n\t\t\ts = fmt.Sprintf(\"%s %d\", s, i.sbx())\n\t\t}\n\tcase iABx:\n\t\ts = fmt.Sprintf(\"%s %d\", s, i.a())\n\t\tif bMode(op) != opArgN {\n\t\t\ts = fmt.Sprintf(\"%s %d\", s, i.bx())\n\t\t}\n\tcase iAx:\n\t\ts = fmt.Sprintf(\"%s %d\", s, i.ax())\n\t}\n\treturn s\n}\n\nfunc opmode(t, a, b, c, m int) byte { return byte(t<<7 | a<<6 | b<<4 | c<<2 | m) }\n\nconst (\n\topArgN = iota // argument is not used\n\topArgU        // argument is used\n\topArgR        // argument is a register or a jump offset\n\topArgK        // argument is a constant or register/constant\n)\n\nfunc opMode(m opCode) int     { return int(opModes[m] & 3) }\nfunc bMode(m opCode) byte     { return (opModes[m] >> 4) & 3 }\nfunc cMode(m opCode) byte     { return (opModes[m] >> 2) & 3 }\nfunc testAMode(m opCode) bool { return opModes[m]&(1<<6) != 0 }\nfunc testTMode(m opCode) bool { return opModes[m]&(1<<7) != 0 }\n\nvar opModes []byte = []byte{\n\t//     T  A    B       C     mode\t\t    opcode\n\topmode(0, 1, opArgR, opArgN, iABC),  // opMove\n\topmode(0, 1, opArgK, opArgN, iABx),  // opLoadConstant\n\topmode(0, 1, opArgN, opArgN, iABx),  // opLoadConstantEx\n\topmode(0, 1, opArgU, opArgU, iABC),  // opLoadBool\n\topmode(0, 1, opArgU, opArgN, iABC),  // opLoadNil\n\topmode(0, 1, opArgU, opArgN, iABC),  // opGetUpValue\n\topmode(0, 1, opArgU, opArgK, iABC),  // opGetTableUp\n\topmode(0, 1, opArgR, opArgK, iABC),  // opGetTable\n\topmode(0, 0, opArgK, opArgK, iABC),  // opSetTableUp\n\topmode(0, 0, opArgU, opArgN, iABC),  // opSetUpValue\n\topmode(0, 0, opArgK, opArgK, iABC),  // opSetTable\n\topmode(0, 1, opArgU, opArgU, iABC),  // opNewTable\n\topmode(0, 1, opArgR, opArgK, iABC),  // opSelf\n\topmode(0, 1, opArgK, opArgK, iABC),  // opAdd\n\topmode(0, 1, opArgK, opArgK, iABC),  // opSub\n\topmode(0, 1, opArgK, opArgK, iABC),  // opMul\n\topmode(0, 1, opArgK, opArgK, iABC),  // opDiv\n\topmode(0, 1, opArgK, opArgK, iABC),  // opMod\n\topmode(0, 1, opArgK, opArgK, iABC),  // opPow\n\topmode(0, 1, opArgR, opArgN, iABC),  // opUnaryMinus\n\topmode(0, 1, opArgR, opArgN, iABC),  // opNot\n\topmode(0, 1, opArgR, opArgN, iABC),  // opLength\n\topmode(0, 1, opArgR, opArgR, iABC),  // opConcat\n\topmode(0, 0, opArgR, opArgN, iAsBx), // opJump\n\topmode(1, 0, opArgK, opArgK, iABC),  // opEqual\n\topmode(1, 0, opArgK, opArgK, iABC),  // opLessThan\n\topmode(1, 0, opArgK, opArgK, iABC),  // opLessOrEqual\n\topmode(1, 0, opArgN, opArgU, iABC),  // opTest\n\topmode(1, 1, opArgR, opArgU, iABC),  // opTestSet\n\topmode(0, 1, opArgU, opArgU, iABC),  // opCall\n\topmode(0, 1, opArgU, opArgU, iABC),  // opTailCall\n\topmode(0, 0, opArgU, opArgN, iABC),  // opReturn\n\topmode(0, 1, opArgR, opArgN, iAsBx), // opForLoop\n\topmode(0, 1, opArgR, opArgN, iAsBx), // opForPrep\n\topmode(0, 0, opArgN, opArgU, iABC),  // opTForCall\n\topmode(0, 1, opArgR, opArgN, iAsBx), // opTForLoop\n\topmode(0, 0, opArgU, opArgU, iABC),  // opSetList\n\topmode(0, 1, opArgU, opArgN, iABx),  // opClosure\n\topmode(0, 1, opArgU, opArgN, iABC),  // opVarArg\n\topmode(0, 0, opArgU, opArgU, iAx),   // opExtraArg\n}\n"
        },
        {
          "name": "io.go",
          "type": "blob",
          "size": 7.2451171875,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\nconst fileHandle = \"FILE*\"\nconst input = \"_IO_input\"\nconst output = \"_IO_output\"\n\ntype stream struct {\n\tf     *os.File\n\tclose Function\n}\n\nfunc toStream(l *State) *stream { return CheckUserData(l, 1, fileHandle).(*stream) }\n\nfunc toFile(l *State) *os.File {\n\ts := toStream(l)\n\tif s.close == nil {\n\t\tErrorf(l, \"attempt to use a closed file\")\n\t}\n\tl.assert(s.f != nil)\n\treturn s.f\n}\n\nfunc newStream(l *State, f *os.File, close Function) *stream {\n\ts := &stream{f: f, close: close}\n\tl.PushUserData(s)\n\tSetMetaTableNamed(l, fileHandle)\n\treturn s\n}\n\nfunc newFile(l *State) *stream {\n\treturn newStream(l, nil, func(l *State) int { return FileResult(l, toStream(l).f.Close(), \"\") })\n}\n\nfunc ioFile(l *State, name string) *os.File {\n\tl.Field(RegistryIndex, name)\n\ts := l.ToUserData(-1).(*stream)\n\tif s.close == nil {\n\t\tErrorf(l, fmt.Sprintf(\"standard %s file is closed\", name[len(\"_IO_\"):]))\n\t}\n\treturn s.f\n}\n\nfunc forceOpen(l *State, name, mode string) {\n\ts := newFile(l)\n\tflags, err := flags(mode)\n\tif err == nil {\n\t\ts.f, err = os.OpenFile(name, flags, 0666)\n\t}\n\tif err != nil {\n\t\tErrorf(l, fmt.Sprintf(\"cannot open file '%s' (%s)\", name, err.Error()))\n\t}\n}\n\nfunc ioFileHelper(name, mode string) Function {\n\treturn func(l *State) int {\n\t\tif !l.IsNoneOrNil(1) {\n\t\t\tif name, ok := l.ToString(1); ok {\n\t\t\t\tforceOpen(l, name, mode)\n\t\t\t} else {\n\t\t\t\ttoFile(l)\n\t\t\t\tl.PushValue(1)\n\t\t\t}\n\t\t\tl.SetField(RegistryIndex, name)\n\t\t}\n\t\tl.Field(RegistryIndex, name)\n\t\treturn 1\n\t}\n}\n\nfunc closeHelper(l *State) int {\n\ts := toStream(l)\n\tclose := s.close\n\ts.close = nil\n\treturn close(l)\n}\n\nfunc close(l *State) int {\n\tif l.IsNone(1) {\n\t\tl.Field(RegistryIndex, output)\n\t}\n\ttoFile(l)\n\treturn closeHelper(l)\n}\n\nfunc write(l *State, f *os.File, argIndex int) int {\n\tvar err error\n\tfor argCount := l.Top(); argIndex < argCount && err == nil; argIndex++ {\n\t\tif n, ok := l.ToNumber(argIndex); ok {\n\t\t\t_, err = f.WriteString(numberToString(n))\n\t\t} else {\n\t\t\t_, err = f.WriteString(CheckString(l, argIndex))\n\t\t}\n\t}\n\tif err == nil {\n\t\treturn 1\n\t}\n\treturn FileResult(l, err, \"\")\n}\n\nfunc readNumber(l *State, f *os.File) (err error) {\n\tvar n float64\n\tif _, err = fmt.Fscanf(f, \"%f\", &n); err == nil {\n\t\tl.PushNumber(n)\n\t} else {\n\t\tl.PushNil()\n\t}\n\treturn\n}\n\nfunc read(l *State, f *os.File, argIndex int) int {\n\tresultCount := 0\n\tvar err error\n\tif argCount := l.Top() - 1; argCount == 0 {\n\t\t//\t\terr = readLineHelper(l, f, true)\n\t\tresultCount = argIndex + 1\n\t} else {\n\t\t// TODO\n\t}\n\tif err != nil {\n\t\treturn FileResult(l, err, \"\")\n\t}\n\tif err == io.EOF {\n\t\tl.Pop(1)\n\t\tl.PushNil()\n\t}\n\treturn resultCount - argIndex\n}\n\nfunc readLine(l *State) int {\n\ts := l.ToUserData(UpValueIndex(1)).(*stream)\n\targCount, _ := l.ToInteger(UpValueIndex(2))\n\tif s.close == nil {\n\t\tErrorf(l, \"file is already closed\")\n\t}\n\tl.SetTop(1)\n\tfor i := 1; i <= argCount; i++ {\n\t\tl.PushValue(UpValueIndex(3 + i))\n\t}\n\tresultCount := read(l, s.f, 2)\n\tl.assert(resultCount > 0)\n\tif !l.IsNil(-resultCount) {\n\t\treturn resultCount\n\t}\n\tif resultCount > 1 {\n\t\tm, _ := l.ToString(-resultCount + 1)\n\t\tErrorf(l, m)\n\t}\n\tif l.ToBoolean(UpValueIndex(3)) {\n\t\tl.SetTop(0)\n\t\tl.PushValue(UpValueIndex(1))\n\t\tcloseHelper(l)\n\t}\n\treturn 0\n}\n\nfunc lines(l *State, shouldClose bool) {\n\targCount := l.Top() - 1\n\tArgumentCheck(l, argCount <= MinStack-3, MinStack-3, \"too many options\")\n\tl.PushValue(1)\n\tl.PushInteger(argCount)\n\tl.PushBoolean(shouldClose)\n\tfor i := 1; i <= argCount; i++ {\n\t\tl.PushValue(i + 1)\n\t}\n\tl.PushGoClosure(readLine, uint8(3+argCount))\n}\n\nfunc flags(m string) (f int, err error) {\n\tif len(m) > 0 && m[len(m)-1] == 'b' {\n\t\tm = m[:len(m)-1]\n\t}\n\tswitch m {\n\tcase \"r\":\n\t\tf = os.O_RDONLY\n\tcase \"r+\":\n\t\tf = os.O_RDWR\n\tcase \"w\":\n\t\tf = os.O_WRONLY | os.O_CREATE | os.O_TRUNC\n\tcase \"w+\":\n\t\tf = os.O_RDWR | os.O_CREATE | os.O_TRUNC\n\tcase \"a\":\n\t\tf = os.O_WRONLY | os.O_CREATE | os.O_APPEND\n\tcase \"a+\":\n\t\tf = os.O_RDWR | os.O_CREATE | os.O_APPEND\n\tdefault:\n\t\terr = os.ErrInvalid\n\t}\n\treturn\n}\n\nvar ioLibrary = []RegistryFunction{\n\t{\"close\", close},\n\t{\"flush\", func(l *State) int { return FileResult(l, ioFile(l, output).Sync(), \"\") }},\n\t{\"input\", ioFileHelper(input, \"r\")},\n\t{\"lines\", func(l *State) int {\n\t\tif l.IsNone(1) {\n\t\t\tl.PushNil()\n\t\t}\n\t\tif l.IsNil(1) { // No file name.\n\t\t\tl.Field(RegistryIndex, input)\n\t\t\tl.Replace(1)\n\t\t\ttoFile(l)\n\t\t\tlines(l, false)\n\t\t} else {\n\t\t\tforceOpen(l, CheckString(l, 1), \"r\")\n\t\t\tl.Replace(1)\n\t\t\tlines(l, true)\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"open\", func(l *State) int {\n\t\tname := CheckString(l, 1)\n\t\tflags, err := flags(OptString(l, 2, \"r\"))\n\t\ts := newFile(l)\n\t\tArgumentCheck(l, err == nil, 2, \"invalid mode\")\n\t\ts.f, err = os.OpenFile(name, flags, 0666)\n\t\tif err == nil {\n\t\t\treturn 1\n\t\t}\n\t\treturn FileResult(l, err, name)\n\t}},\n\t{\"output\", ioFileHelper(output, \"w\")},\n\t{\"popen\", func(l *State) int { Errorf(l, \"'popen' not supported\"); panic(\"unreachable\") }},\n\t{\"read\", func(l *State) int { return read(l, ioFile(l, input), 1) }},\n\t{\"tmpfile\", func(l *State) int {\n\t\ts := newFile(l)\n\t\tf, err := ioutil.TempFile(\"\", \"\")\n\t\tif err == nil {\n\t\t\ts.f = f\n\t\t\treturn 1\n\t\t}\n\t\treturn FileResult(l, err, \"\")\n\t}},\n\t{\"type\", func(l *State) int {\n\t\tCheckAny(l, 1)\n\t\tif f, ok := TestUserData(l, 1, fileHandle).(*stream); !ok {\n\t\t\tl.PushNil()\n\t\t} else if f.close == nil {\n\t\t\tl.PushString(\"closed file\")\n\t\t} else {\n\t\t\tl.PushString(\"file\")\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"write\", func(l *State) int { return write(l, ioFile(l, output), 1) }},\n}\n\nvar fileHandleMethods = []RegistryFunction{\n\t{\"close\", close},\n\t{\"flush\", func(l *State) int { return FileResult(l, toFile(l).Sync(), \"\") }},\n\t{\"lines\", func(l *State) int { toFile(l); lines(l, false); return 1 }},\n\t{\"read\", func(l *State) int { return read(l, toFile(l), 2) }},\n\t{\"seek\", func(l *State) int {\n\t\twhence := []int{os.SEEK_SET, os.SEEK_CUR, os.SEEK_END}\n\t\tf := toFile(l)\n\t\top := CheckOption(l, 2, \"cur\", []string{\"set\", \"cur\", \"end\"})\n\t\tp3 := OptNumber(l, 3, 0)\n\t\toffset := int64(p3)\n\t\tArgumentCheck(l, float64(offset) == p3, 3, \"not an integer in proper range\")\n\t\tret, err := f.Seek(offset, whence[op])\n\t\tif err != nil {\n\t\t\treturn FileResult(l, err, \"\")\n\t\t}\n\t\tl.PushNumber(float64(ret))\n\t\treturn 1\n\t}},\n\t{\"setvbuf\", func(l *State) int { // Files are unbuffered in Go. Fake support for now.\n\t\t//\t\tf := toFile(l)\n\t\t//\t\top := CheckOption(l, 2, \"\", []string{\"no\", \"full\", \"line\"})\n\t\t//\t\tsize := OptInteger(l, 3, 1024)\n\t\t// TODO err := setvbuf(f, nil, mode[op], size)\n\t\treturn FileResult(l, nil, \"\")\n\t}},\n\t{\"write\", func(l *State) int { l.PushValue(1); return write(l, toFile(l), 2) }},\n\t//\t{\"__gc\", },\n\t{\"__tostring\", func(l *State) int {\n\t\tif s := toStream(l); s.close == nil {\n\t\t\tl.PushString(\"file (closed)\")\n\t\t} else {\n\t\t\tl.PushString(fmt.Sprintf(\"file (%p)\", s.f))\n\t\t}\n\t\treturn 1\n\t}},\n}\n\nfunc dontClose(l *State) int {\n\ttoStream(l).close = dontClose\n\tl.PushNil()\n\tl.PushString(\"cannot close standard file\")\n\treturn 2\n}\n\nfunc registerStdFile(l *State, f *os.File, reg, name string) {\n\tnewStream(l, f, dontClose)\n\tif reg != \"\" {\n\t\tl.PushValue(-1)\n\t\tl.SetField(RegistryIndex, reg)\n\t}\n\tl.SetField(-2, name)\n}\n\n// IOOpen opens the io library. Usually passed to Require.\nfunc IOOpen(l *State) int {\n\tNewLibrary(l, ioLibrary)\n\n\tNewMetaTable(l, fileHandle)\n\tl.PushValue(-1)\n\tl.SetField(-2, \"__index\")\n\tSetFunctions(l, fileHandleMethods, 0)\n\tl.Pop(1)\n\n\tregisterStdFile(l, os.Stdin, input, \"stdin\")\n\tregisterStdFile(l, os.Stdout, output, \"stdout\")\n\tregisterStdFile(l, os.Stderr, \"\", \"stderr\")\n\n\treturn 1\n}\n"
        },
        {
          "name": "libs.go",
          "type": "blob",
          "size": 1.9931640625,
          "content": "package lua\n\n// OpenLibraries opens all standard libraries. Alternatively, the host program\n// can open them individually by using Require to call BaseOpen (for the basic\n// library), PackageOpen (for the package library), CoroutineOpen (for the\n// coroutine library), StringOpen (for the string library), TableOpen (for the\n// table library), MathOpen (for the mathematical library), Bit32Open (for the\n// bit library), IOOpen (for the I/O library), OSOpen (for the Operating System\n// library), and DebugOpen (for the debug library).\n//\n// The standard Lua libraries provide useful functions that are implemented\n// directly through the Go API. Some of these functions provide essential\n// services to the language (e.g. Type and MetaTable); others provide access\n// to \"outside\" services (e.g. I/O); and others could be implemented in Lua\n// itself, but are quite useful or have critical performance requirements that\n// deserve an implementation in Go (e.g. table.sort).\n//\n// All libraries are implemented through the official Go API. Currently, Lua\n// has the following standard libraries:\n//  basic library\n//  package library\n//  string manipulation\n//  table manipulation\n//  mathematical functions (sin, log, etc.);\n//  bitwise operations\n//  input and output\n//  operating system facilities\n//  debug facilities\n// Except for the basic and the package libraries, each library provides all\n// its functions as fields of a global table or as methods of its objects.\nfunc OpenLibraries(l *State, preloaded ...RegistryFunction) {\n\tlibs := []RegistryFunction{\n\t\t{\"_G\", BaseOpen},\n\t\t{\"package\", PackageOpen},\n\t\t// {\"coroutine\", CoroutineOpen},\n\t\t{\"table\", TableOpen},\n\t\t{\"io\", IOOpen},\n\t\t{\"os\", OSOpen},\n\t\t{\"string\", StringOpen},\n\t\t{\"bit32\", Bit32Open},\n\t\t{\"math\", MathOpen},\n\t\t{\"debug\", DebugOpen},\n\t}\n\tfor _, lib := range libs {\n\t\tRequire(l, lib.Name, lib.Function, true)\n\t\tl.Pop(1)\n\t}\n\tSubTable(l, RegistryIndex, \"_PRELOAD\")\n\tfor _, lib := range preloaded {\n\t\tl.PushGoFunction(lib.Function)\n\t\tl.SetField(-2, lib.Name)\n\t}\n\tl.Pop(1)\n}\n"
        },
        {
          "name": "libs",
          "type": "tree",
          "content": null
        },
        {
          "name": "load.go",
          "type": "blob",
          "size": 4.5830078125,
          "content": "package lua\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc findLoader(l *State, name string) {\n\tvar msg string\n\tif l.Field(UpValueIndex(1), \"searchers\"); !l.IsTable(3) {\n\t\tErrorf(l, \"'package.searchers' must be a table\")\n\t}\n\tfor i := 1; ; i++ {\n\t\tif l.RawGetInt(3, i); l.IsNil(-1) {\n\t\t\tl.Pop(1)\n\t\t\tl.PushString(msg)\n\t\t\tErrorf(l, \"module '%s' not found: %s\", name, msg)\n\t\t}\n\t\tl.PushString(name)\n\t\tif l.Call(1, 2); l.IsFunction(-2) {\n\t\t\treturn\n\t\t} else if l.IsString(-2) {\n\t\t\tmsg += CheckString(l, -2)\n\t\t}\n\t\tl.Pop(2)\n\t}\n}\n\nfunc findFile(l *State, name, field, dirSep string) (string, error) {\n\tl.Field(UpValueIndex(1), field)\n\tpath, ok := l.ToString(-1)\n\tif !ok {\n\t\tErrorf(l, \"'package.%s' must be a string\", field)\n\t}\n\treturn searchPath(l, name, path, \".\", dirSep)\n}\n\nfunc checkLoad(l *State, loaded bool, fileName string) int {\n\tif loaded { // Module loaded successfully?\n\t\tl.PushString(fileName) // Second argument to module.\n\t\treturn 2               // Return open function & file name.\n\t}\n\tm := CheckString(l, 1)\n\te := CheckString(l, -1)\n\tErrorf(l, \"error loading module '%s' from file '%s':\\n\\t%s\", m, fileName, e)\n\tpanic(\"unreachable\")\n}\n\nfunc searcherLua(l *State) int {\n\tname := CheckString(l, 1)\n\tfilename, err := findFile(l, name, \"path\", string(filepath.Separator))\n\tif err != nil {\n\t\treturn 1 // Module not found in this path.\n\t}\n\treturn checkLoad(l, LoadFile(l, filename, \"\") == nil, filename)\n}\n\nfunc searcherPreload(l *State) int {\n\tname := CheckString(l, 1)\n\tl.Field(RegistryIndex, \"_PRELOAD\")\n\tl.Field(-1, name)\n\tif l.IsNil(-1) {\n\t\tl.PushString(fmt.Sprintf(\"\\n\\tno field package.preload['%s']\", name))\n\t}\n\treturn 1\n}\n\nfunc createSearchersTable(l *State) {\n\tsearchers := []Function{searcherPreload, searcherLua}\n\tl.CreateTable(len(searchers), 0)\n\tfor i, s := range searchers {\n\t\tl.PushValue(-2)\n\t\tl.PushGoClosure(s, 1)\n\t\tl.RawSetInt(-2, i+1)\n\t}\n}\n\nfunc readable(filename string) bool {\n\tf, err := os.Open(filename)\n\tif f != nil {\n\t\tf.Close()\n\t}\n\treturn err == nil\n}\n\nfunc searchPath(l *State, name, path, sep, dirSep string) (string, error) {\n\tvar msg string\n\tif sep != \"\" {\n\t\tname = strings.Replace(name, sep, dirSep, -1) // Replace sep by dirSep.\n\t}\n\tpath = strings.Replace(path, string(pathListSeparator), string(filepath.ListSeparator), -1)\n\tfor _, template := range filepath.SplitList(path) {\n\t\tif template != \"\" {\n\t\t\tfilename := strings.Replace(template, \"?\", name, -1)\n\t\t\tif readable(filename) {\n\t\t\t\treturn filename, nil\n\t\t\t}\n\t\t\tmsg = fmt.Sprintf(\"%s\\n\\tno file '%s'\", msg, filename)\n\t\t}\n\t}\n\treturn \"\", errors.New(msg)\n}\n\nfunc noEnv(l *State) bool {\n\tl.Field(RegistryIndex, \"LUA_NOENV\")\n\tb := l.ToBoolean(-1)\n\tl.Pop(1)\n\treturn b\n}\n\nfunc setPath(l *State, field, env, def string) {\n\tif path := os.Getenv(env); path == \"\" || noEnv(l) {\n\t\tl.PushString(def)\n\t} else {\n\t\to := fmt.Sprintf(\"%c%c\", pathListSeparator, pathListSeparator)\n\t\tn := fmt.Sprintf(\"%c%s%c\", pathListSeparator, def, pathListSeparator)\n\t\tpath = strings.Replace(path, o, n, -1)\n\t\tl.PushString(path)\n\t}\n\tl.SetField(-2, field)\n}\n\nvar packageLibrary = []RegistryFunction{\n\t{\"loadlib\", func(l *State) int {\n\t\t_ = CheckString(l, 1) // path\n\t\t_ = CheckString(l, 2) // init\n\t\tl.PushNil()\n\t\tl.PushString(\"dynamic libraries not enabled; check your Lua installation\")\n\t\tl.PushString(\"absent\")\n\t\treturn 3 // Return nil, error message, and where.\n\t}},\n\t{\"searchpath\", func(l *State) int {\n\t\tname := CheckString(l, 1)\n\t\tpath := CheckString(l, 2)\n\t\tsep := OptString(l, 3, \".\")\n\t\tdirSep := OptString(l, 4, string(filepath.Separator))\n\t\tf, err := searchPath(l, name, path, sep, dirSep)\n\t\tif err != nil {\n\t\t\tl.PushNil()\n\t\t\tl.PushString(err.Error())\n\t\t\treturn 2\n\t\t}\n\t\tl.PushString(f)\n\t\treturn 1\n\t}},\n}\n\n// PackageOpen opens the package library. Usually passed to Require.\nfunc PackageOpen(l *State) int {\n\tNewLibrary(l, packageLibrary)\n\tcreateSearchersTable(l)\n\tl.SetField(-2, \"searchers\")\n\tsetPath(l, \"path\", \"LUA_PATH\", defaultPath)\n\tl.PushString(fmt.Sprintf(\"%c\\n%c\\n?\\n!\\n-\\n\", filepath.Separator, pathListSeparator))\n\tl.SetField(-2, \"config\")\n\tSubTable(l, RegistryIndex, \"_LOADED\")\n\tl.SetField(-2, \"loaded\")\n\tSubTable(l, RegistryIndex, \"_PRELOAD\")\n\tl.SetField(-2, \"preload\")\n\tl.PushGlobalTable()\n\tl.PushValue(-2)\n\tSetFunctions(l, []RegistryFunction{{\"require\", func(l *State) int {\n\t\tname := CheckString(l, 1)\n\t\tl.SetTop(1)\n\t\tl.Field(RegistryIndex, \"_LOADED\")\n\t\tl.Field(2, name)\n\t\tif l.ToBoolean(-1) {\n\t\t\treturn 1\n\t\t}\n\t\tl.Pop(1)\n\t\tfindLoader(l, name)\n\t\tl.PushString(name)\n\t\tl.Insert(-2)\n\t\tl.Call(2, 1)\n\t\tif !l.IsNil(-1) {\n\t\t\tl.SetField(2, name)\n\t\t}\n\t\tl.Field(2, name)\n\t\tif l.IsNil(-1) {\n\t\t\tl.PushBoolean(true)\n\t\t\tl.PushValue(-1)\n\t\t\tl.SetField(2, name)\n\t\t}\n\t\treturn 1\n\t}}}, 1)\n\tl.Pop(1)\n\treturn 1\n}\n"
        },
        {
          "name": "lua-tests",
          "type": "commit",
          "content": null
        },
        {
          "name": "lua.go",
          "type": "blob",
          "size": 50.185546875,
          "content": "package lua\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strings\"\n)\n\n// MultipleReturns is the argument for argCount or resultCount in ProtectedCall and Call.\nconst MultipleReturns = -1\n\n// Debug.Event and SetDebugHook mask argument values.\nconst (\n\tHookCall, MaskCall = iota, 1 << iota\n\tHookReturn, MaskReturn\n\tHookLine, MaskLine\n\tHookCount, MaskCount\n\tHookTailCall, MaskTailCall\n)\n\n// Errors introduced by the Lua VM.\nvar (\n\tSyntaxError = errors.New(\"syntax error\")\n\tMemoryError = errors.New(\"memory error\")\n\tErrorError  = errors.New(\"error within the error handler\")\n\tFileError   = errors.New(\"file error\")\n)\n\n// A RuntimeError is an error raised internally by the Lua VM or through Error.\ntype RuntimeError string\n\nfunc (r RuntimeError) Error() string { return \"runtime error: \" + string(r) }\n\n// A Type is a symbolic representation of a Lua VM type.\ntype Type int\n\n// Valid Type values.\nconst (\n\tTypeNil Type = iota\n\tTypeBoolean\n\tTypeLightUserData\n\tTypeNumber\n\tTypeString\n\tTypeTable\n\tTypeFunction\n\tTypeUserData\n\tTypeThread\n\n\tTypeCount\n\tTypeNone = TypeNil - 1\n)\n\n// An Operator is an op argument for Arith.\ntype Operator int\n\n// Valid Operator values for Arith.\nconst (\n\tOpAdd        Operator = iota // Performs addition (+).\n\tOpSub                        // Performs subtraction (-).\n\tOpMul                        // Performs multiplication (*).\n\tOpDiv                        // Performs division (/).\n\tOpMod                        // Performs modulo (%).\n\tOpPow                        // Performs exponentiation (^).\n\tOpUnaryMinus                 // Performs mathematical negation (unary -).\n)\n\n// A ComparisonOperator is an op argument for Compare.\ntype ComparisonOperator int\n\n// Valid ComparisonOperator values for Compare.\nconst (\n\tOpEq ComparisonOperator = iota // Compares for equality (==).\n\tOpLT                           // Compares for less than (<).\n\tOpLE                           // Compares for less or equal (<=).\n)\n\n// Lua provides a registry, a predefined table, that can be used by any Go code\n// to store whatever Lua values it needs to store. The registry table is always\n// located at pseudo-index RegistryIndex, which is a valid index. Any Go\n// library can store data into this table, but it should take care to choose\n// keys that are different from those used by other libraries, to avoid\n// collisions. Typically, you should use as key a string containing your\n// library name, or a light userdata object in your code, or any Lua object\n// created by your code. As with global names, string keys starting with an\n// underscore followed by uppercase letters are reserved for Lua.\n//\n// The integer keys in the registry are used by the reference mechanism\n// and by some predefined values. Therefore, integer keys should not be used\n// for other purposes.\n//\n// When you create a new Lua state, its registry comes with some predefined\n// values. These predefined values are indexed with integer keys defined as\n// constants.\nconst (\n\t// RegistryIndex is the pseudo-index for the registry table.\n\tRegistryIndex = firstPseudoIndex\n\n\t// RegistryIndexMainThread is the registry index for the main thread of the\n\t// State. (The main thread is the one created together with the State.)\n\tRegistryIndexMainThread = iota\n\n\t// RegistryIndexGlobals is the registry index for the global environment.\n\tRegistryIndexGlobals\n)\n\n// Signature is the mark for precompiled code ('<esc>Lua').\nconst Signature = \"\\033Lua\"\n\n// MinStack is the minimum Lua stack available to a Go function.\nconst MinStack = 20\n\nconst (\n\tVersionMajor  = 5\n\tVersionMinor  = 2\n\tVersionNumber = 502\n\tVersionString = \"Lua \" + string('0'+VersionMajor) + \".\" + string('0'+VersionMinor)\n)\n\n// A RegistryFunction is used for arrays of functions to be registered by\n// SetFunctions. Name is the function name and Function is the function.\ntype RegistryFunction struct {\n\tName     string\n\tFunction Function\n}\n\n// A Debug carries different pieces of information about a function or an\n// activation record. Stack fills only the private part of this structure, for\n// later use. To fill the other fields of a Debug with useful information, call\n// Info.\ntype Debug struct {\n\tEvent int\n\n\t// Name is a reasonable name for the given function. Because functions in\n\t// Lua are first-class values, they do not have a fixed name. Some functions\n\t// can be the value of multiple global variables, while others can be stored\n\t// only in a table field. The Info function checks how the function was\n\t// called to find a suitable name. If it cannot find a name, then Name is \"\".\n\tName string\n\n\t// NameKind explains the name field. The value of NameKind can be \"global\",\n\t// \"local\", \"method\", \"field\", \"upvalue\", or \"\" (the empty string), according\n\t// to how the function was called. (Lua uses the empty string when no other\n\t// option seems to apply.)\n\tNameKind string\n\n\t// What is the string \"Lua\" if the function is a Lua function, \"Go\" if it is\n\t// a Go function, \"main\" if it is the main part of a chunk.\n\tWhat string\n\n\t// Source is the source of the chunk that created the function. If Source\n\t// starts with a '@', it means that the function was defined in a file where\n\t// the file name follows the '@'. If Source starts with a '=', the remainder\n\t// of its contents describe the source in a user-dependent manner. Otherwise,\n\t// the function was defined in a string where Source is that string.\n\tSource string\n\n\t// ShortSource is a \"printable\" version of source, to be used in error messages.\n\tShortSource string\n\n\t// CurrentLine is the current line where the given function is executing.\n\t// When no line information is available, CurrentLine is set to -1.\n\tCurrentLine int\n\n\t// LineDefined is the line number where the definition of the function starts.\n\tLineDefined int\n\n\t// LastLineDefined is the line number where the definition of the function ends.\n\tLastLineDefined int\n\n\t// UpValueCount is the number of upvalues of the function.\n\tUpValueCount int\n\n\t// ParameterCount is the number of fixed parameters of the function (always 0\n\t// for Go functions).\n\tParameterCount int\n\n\t// IsVarArg is true if the function is a vararg function (always true for Go\n\t// functions).\n\tIsVarArg bool\n\n\t// IsTailCall is true if this function invocation was called by a tail call.\n\t// In this case, the caller of this level is not in the stack.\n\tIsTailCall bool\n\n\t// callInfo is the active function.\n\tcallInfo *callInfo\n}\n\n// A Hook is a callback function that can be registered with SetDebugHook to trace various VM events.\ntype Hook func(state *State, activationRecord Debug)\n\n// A Function is a Go function intended to be called from Lua.\ntype Function func(state *State) int\n\n// TODO XMove(from, to State, n int)\n//\n// Set functions (stack -> Lua)\n// RawSetValue(index int, p interface{})\n//\n// Debug API\n// Local(activationRecord *Debug, index int) string\n// SetLocal(activationRecord *Debug, index int) string\n\ntype pc int\ntype callStatus byte\n\nconst (\n\tcallStatusLua                callStatus = 1 << iota // call is running a Lua function\n\tcallStatusHooked                                    // call is running a debug hook\n\tcallStatusReentry                                   // call is running on same invocation of execute of previous call\n\tcallStatusYielded                                   // call reentered after suspension\n\tcallStatusYieldableProtected                        // call is a yieldable protected call\n\tcallStatusError                                     // call has an error status (pcall)\n\tcallStatusTail                                      // call was tail called\n\tcallStatusHookYielded                               // last hook called yielded\n)\n\n// A State is an opaque structure representing per thread Lua state.\ntype State struct {\n\terror                 error\n\tshouldYield           bool\n\ttop                   int // first free slot in the stack\n\tglobal                *globalState\n\tcallInfo              *callInfo // call info for current function\n\toldPC                 pc        // last pC traced\n\tstackLast             int       // last free slot in the stack\n\tstack                 []value\n\tnonYieldableCallCount int\n\tnestedGoCallCount     int\n\thookMask              byte\n\tallowHook             bool\n\tinternalHook          bool\n\tbaseHookCount         int\n\thookCount             int\n\thooker                Hook\n\tupValues              *openUpValue\n\terrorFunction         int      // current error handling function (stack index)\n\tbaseCallInfo          callInfo // callInfo for first level (go calling lua)\n\tprotectFunction       func()\n}\n\ntype globalState struct {\n\tmainThread         *State\n\ttagMethodNames     [tmCount]string\n\tmetaTables         [TypeCount]*table // metatables for basic types\n\tregistry           *table\n\tpanicFunction      Function // to be called in unprotected errors\n\tversion            *float64 // pointer to version number\n\tmemoryErrorMessage string\n\t// seed uint // randomized seed for hashes\n\t// upValueHead upValue // head of double-linked list of all open upvalues\n}\n\nfunc (g *globalState) metaTable(o value) *table {\n\tvar t Type\n\tswitch o.(type) {\n\tcase nil:\n\t\tt = TypeNil\n\tcase bool:\n\t\tt = TypeBoolean\n\t// TODO TypeLightUserData\n\tcase float64:\n\t\tt = TypeNumber\n\tcase string:\n\t\tt = TypeString\n\tcase *table:\n\t\tt = TypeTable\n\tcase *goFunction:\n\t\tt = TypeFunction\n\tcase closure:\n\t\tt = TypeFunction\n\tcase *userData:\n\t\tt = TypeUserData\n\tcase *State:\n\t\tt = TypeThread\n\tdefault:\n\t\treturn nil\n\t}\n\treturn g.metaTables[t]\n}\n\nfunc (l *State) adjustResults(resultCount int) {\n\tif resultCount == MultipleReturns && l.callInfo.top < l.top {\n\t\tl.callInfo.setTop(l.top)\n\t}\n}\n\nfunc (l *State) apiIncrementTop() {\n\tl.top++\n\tif apiCheck && l.top > l.callInfo.top {\n\t\tpanic(\"stack overflow\")\n\t}\n}\n\nfunc (l *State) apiPush(v value) {\n\tl.push(v)\n\tif apiCheck && l.top > l.callInfo.top {\n\t\tpanic(\"stack overflow\")\n\t}\n}\n\nfunc (l *State) checkElementCount(n int) {\n\tif apiCheck && n >= l.top-l.callInfo.function {\n\t\tpanic(\"not enough elements in the stack\")\n\t}\n}\n\nfunc (l *State) checkResults(argCount, resultCount int) {\n\tif apiCheck && resultCount != MultipleReturns && l.callInfo.top-l.top < resultCount-argCount {\n\t\tpanic(\"results from function overflow current stack size\")\n\t}\n}\n\n// Context is called by a continuation function to retrieve the status of the\n// thread and context information. When called in the origin function, it\n// will always return (0, false, nil). When called inside a continuation function,\n// it will return (ctx, shouldYield, err), where ctx is the value that was\n// passed to the callee together with the continuation function.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_getctx\nfunc (l *State) Context() (int, bool, error) {\n\tif l.callInfo.isCallStatus(callStatusYielded) {\n\t\treturn l.callInfo.context, l.callInfo.shouldYield, l.callInfo.error\n\t}\n\treturn 0, false, nil\n}\n\n// CallWithContinuation is exactly like Call, but allows the called function to\n// yield.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_callk\nfunc (l *State) CallWithContinuation(argCount, resultCount, context int, continuation Function) {\n\tif apiCheck && continuation != nil && l.callInfo.isLua() {\n\t\tpanic(\"cannot use continuations inside hooks\")\n\t}\n\tl.checkElementCount(argCount + 1)\n\tif apiCheck && l.shouldYield {\n\t\tpanic(\"cannot do calls on non-normal thread\")\n\t}\n\tl.checkResults(argCount, resultCount)\n\tf := l.top - (argCount + 1)\n\tif continuation != nil && l.nonYieldableCallCount == 0 { // need to prepare continuation?\n\t\tl.callInfo.continuation = continuation\n\t\tl.callInfo.context = context\n\t\tl.call(f, resultCount, true) // just do the call\n\t} else { // no continuation or not yieldable\n\t\tl.call(f, resultCount, false) // just do the call\n\t}\n\tl.adjustResults(resultCount)\n}\n\n// ProtectedCall calls a function in protected mode. Both argCount and\n// resultCount have the same meaning as in Call. If there are no errors\n// during the call, ProtectedCall behaves exactly like Call.\n//\n// However, if there is any error, ProtectedCall catches it, pushes a single\n// value on the stack (the error message), and returns an error. Like Call,\n// ProtectedCall always removes the function and its arguments from the stack.\n//\n// If errorFunction is 0, then the error message returned on the stack is\n// exactly the original error message. Otherwise, errorFunction is the stack\n// index of an error handler (in the Lua C, message handler). This cannot be\n// a pseudo-index in the current implementation. In case of runtime errors,\n// this function will be called with the error message and its return value\n// will be the message returned on the stack by ProtectedCall.\n//\n// Typically, the error handler is used to add more debug information to the\n// error message, such as a stack traceback. Such information cannot be\n// gathered after the return of ProtectedCall, since by then, the stack has\n// unwound.\n//\n// The possible errors are the following:\n//\n//    RuntimeError  a runtime error\n//    MemoryError   allocating memory, the error handler is not called\n//    ErrorError    running the error handler\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pcall\nfunc (l *State) ProtectedCall(argCount, resultCount, errorFunction int) error {\n\treturn l.ProtectedCallWithContinuation(argCount, resultCount, errorFunction, 0, nil)\n}\n\n// ProtectedCallWithContinuation behaves exactly like ProtectedCall, but\n// allows the called function to yield.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pcallk\nfunc (l *State) ProtectedCallWithContinuation(argCount, resultCount, errorFunction, context int, continuation Function) (err error) {\n\tif apiCheck && continuation != nil && l.callInfo.isLua() {\n\t\tpanic(\"cannot use continuations inside hooks\")\n\t}\n\tl.checkElementCount(argCount + 1)\n\tif apiCheck && l.shouldYield {\n\t\tpanic(\"cannot do calls on non-normal thread\")\n\t}\n\tl.checkResults(argCount, resultCount)\n\tif errorFunction != 0 {\n\t\tapiCheckStackIndex(errorFunction, l.indexToValue(errorFunction))\n\t\terrorFunction = l.AbsIndex(errorFunction)\n\t}\n\n\tf := l.top - (argCount + 1)\n\n\tif continuation == nil || l.nonYieldableCallCount > 0 {\n\t\terr = l.protectedCall(func() { l.call(f, resultCount, false) }, f, errorFunction)\n\t} else {\n\t\tc := l.callInfo\n\t\tc.continuation, c.context, c.extra, c.oldAllowHook, c.oldErrorFunction = continuation, context, f, l.allowHook, l.errorFunction\n\t\tl.errorFunction = errorFunction\n\t\tl.callInfo.setCallStatus(callStatusYieldableProtected)\n\t\tl.call(f, resultCount, true)\n\t\tl.callInfo.clearCallStatus(callStatusYieldableProtected)\n\t\tl.errorFunction = c.oldErrorFunction\n\t}\n\tl.adjustResults(resultCount)\n\treturn\n}\n\n// Load loads a Lua chunk, without running it. If there are no errors, it\n// pushes the compiled chunk as a Lua function on top of the stack.\n// Otherwise, it pushes an error message.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_load\nfunc (l *State) Load(r io.Reader, chunkName string, mode string) error {\n\tif chunkName == \"\" {\n\t\tchunkName = \"?\"\n\t}\n\n\tif err := protectedParser(l, r, chunkName, mode); err != nil {\n\t\treturn err\n\t}\n\n\tif f := l.stack[l.top-1].(*luaClosure); f.upValueCount() == 1 {\n\t\tf.setUpValue(0, l.global.registry.atInt(RegistryIndexGlobals))\n\t}\n\treturn nil\n}\n\n// Dump dumps a function as a binary chunk. It receives a Lua function on\n// the top of the stack and produces a binary chunk that, if loaded again,\n// results in a function equivalent to the one dumped.\n//\n// http://www.lua.org/manual/5.3/manual.html#lua_dump\nfunc (l *State) Dump(w io.Writer) error {\n\tl.checkElementCount(1)\n\tif f, ok := l.stack[l.top-1].(*luaClosure); ok {\n\t\treturn l.dump(f.prototype, w)\n\t}\n\tpanic(\"closure expected\")\n}\n\n// NewState creates a new thread running in a new, independent state.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_newstate\nfunc NewState() *State {\n\tv := float64(VersionNumber)\n\tl := &State{allowHook: true, error: nil, nonYieldableCallCount: 1}\n\tg := &globalState{mainThread: l, registry: newTable(), version: &v, memoryErrorMessage: \"not enough memory\"}\n\tl.global = g\n\tl.initializeStack()\n\tg.registry.putAtInt(RegistryIndexMainThread, l)\n\tg.registry.putAtInt(RegistryIndexGlobals, newTable())\n\tcopy(g.tagMethodNames[:], eventNames)\n\treturn l\n}\n\nfunc apiCheckStackIndex(index int, v value) {\n\tif apiCheck && (v == none || isPseudoIndex(index)) {\n\t\tpanic(fmt.Sprintf(\"index %d not in the stack\", index))\n\t}\n}\n\n// SetField does the equivalent of table[key]=v where table is the value at\n// index and v is the value on top of the stack.\n//\n// This function pops the value from the stack. As in Lua, this function may\n// trigger a metamethod for the __newindex event.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_setfield\nfunc (l *State) SetField(index int, key string) {\n\tl.checkElementCount(1)\n\tt := l.indexToValue(index)\n\tl.push(key)\n\tl.setTableAt(t, key, l.stack[l.top-2])\n\tl.top -= 2\n}\n\nvar none value = &struct{}{}\n\nfunc (l *State) indexToValue(index int) value {\n\tswitch {\n\tcase index > 0:\n\t\t// TODO apiCheck(index <= callInfo.top_-(callInfo.function+1), \"unacceptable index\")\n\t\t// if i := callInfo.function + index; i < l.top {\n\t\t// \treturn l.stack[i]\n\t\t// }\n\t\t// return none\n\t\tif l.callInfo.function+index >= l.top {\n\t\t\treturn none\n\t\t}\n\t\treturn l.stack[l.callInfo.function:l.top][index]\n\tcase index > RegistryIndex: // negative index\n\t\t// TODO apiCheck(index != 0 && -index <= l.top-(callInfo.function+1), \"invalid index\")\n\t\treturn l.stack[l.top+index]\n\tcase index == RegistryIndex:\n\t\treturn l.global.registry\n\tdefault: // upvalues\n\t\ti := RegistryIndex - index\n\t\treturn l.stack[l.callInfo.function].(*goClosure).upValues[i-1]\n\t\t// if closure := l.stack[callInfo.function].(*goClosure); i <= len(closure.upValues) {\n\t\t// \treturn closure.upValues[i-1]\n\t\t// }\n\t\t// return none\n\t}\n}\n\nfunc (l *State) setIndexToValue(index int, v value) {\n\tswitch {\n\tcase index > 0:\n\t\tl.stack[l.callInfo.function:l.top][index] = v\n\t\t// if i := callInfo.function + index; i < l.top {\n\t\t// \tl.stack[i] = v\n\t\t// } else {\n\t\t// \tpanic(\"unacceptable index\")\n\t\t// }\n\tcase index > RegistryIndex: // negative index\n\t\tl.stack[l.top+index] = v\n\tcase index == RegistryIndex:\n\t\tl.global.registry = v.(*table)\n\tdefault: // upvalues\n\t\ti := RegistryIndex - index\n\t\tl.stack[l.callInfo.function].(*goClosure).upValues[i-1] = v\n\t}\n}\n\n// AbsIndex converts the acceptable index index to an absolute index (that\n// is, one that does not depend on the stack top).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_absindex\nfunc (l *State) AbsIndex(index int) int {\n\tif index > 0 || isPseudoIndex(index) {\n\t\treturn index\n\t}\n\treturn l.top - l.callInfo.function + index\n}\n\n// SetTop accepts any index, or 0, and sets the stack top to index. If the\n// new top is larger than the old one, then the new elements are filled with\n// nil. If index is 0, then all stack elements are removed.\n//\n// If index is negative, the stack will be decremented by that much. If\n// the decrement is larger than the stack, SetTop will panic().\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_settop\nfunc (l *State) SetTop(index int) {\n\tf := l.callInfo.function\n\tif index >= 0 {\n\t\tif apiCheck && index > l.stackLast-(f+1) {\n\t\t\tpanic(\"new top too large\")\n\t\t}\n\t\ti := l.top\n\t\tfor l.top = f + 1 + index; i < l.top; i++ {\n\t\t\tl.stack[i] = nil\n\t\t}\n\t} else {\n\t\tif apiCheck && -(index+1) > l.top-(f+1) {\n\t\t\tpanic(\"invalid new top\")\n\t\t}\n\t\tl.top += index + 1 // 'subtract' index (index is negative)\n\t}\n}\n\n// Remove the element at the given valid index, shifting down the elements\n// above index to fill the gap. This function cannot be called with a\n// pseudo-index, because a pseudo-index is not an actual stack position.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_remove\nfunc (l *State) Remove(index int) {\n\tapiCheckStackIndex(index, l.indexToValue(index))\n\ti := l.callInfo.function + l.AbsIndex(index)\n\tcopy(l.stack[i:l.top-1], l.stack[i+1:l.top])\n\tl.top--\n}\n\n// Insert moves the top element into the given valid index, shifting up the\n// elements above this index to open space.  This function cannot be called\n// with a pseudo-index, because a pseudo-index is not an actual stack position.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_insert\nfunc (l *State) Insert(index int) {\n\tapiCheckStackIndex(index, l.indexToValue(index))\n\ti := l.callInfo.function + l.AbsIndex(index)\n\tcopy(l.stack[i+1:l.top+1], l.stack[i:l.top])\n\tl.stack[i] = l.stack[l.top]\n}\n\nfunc (l *State) move(dest int, src value) { l.setIndexToValue(dest, src) }\n\n// Replace moves the top element into the given valid index without shifting\n// any element (therefore replacing the value at the given index), and then\n// pops the top element.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_replace\nfunc (l *State) Replace(index int) {\n\tl.checkElementCount(1)\n\tl.move(index, l.stack[l.top-1])\n\tl.top--\n}\n\n// CheckStack ensures that there are at least size free stack slots in the\n// stack. This call will not panic(), unlike the other Check*() functions.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_checkstack\nfunc (l *State) CheckStack(size int) bool {\n\tcallInfo := l.callInfo\n\tok := l.stackLast-l.top > size\n\tif !ok && l.top+extraStack <= maxStack-size {\n\t\tok = l.protect(func() { l.growStack(size) }) == nil\n\t}\n\tif ok && callInfo.top < l.top+size {\n\t\tcallInfo.setTop(l.top + size)\n\t}\n\treturn ok\n}\n\n// AtPanic sets a new panic function and returns the old one.\nfunc AtPanic(l *State, panicFunction Function) Function {\n\tpanicFunction, l.global.panicFunction = l.global.panicFunction, panicFunction\n\treturn panicFunction\n}\n\nfunc (l *State) valueToType(v value) Type {\n\tswitch v.(type) {\n\tcase nil:\n\t\treturn TypeNil\n\tcase bool:\n\t\treturn TypeBoolean\n\t// case lightUserData:\n\t// \treturn TypeLightUserData\n\tcase float64:\n\t\treturn TypeNumber\n\tcase string:\n\t\treturn TypeString\n\tcase *table:\n\t\treturn TypeTable\n\tcase *goFunction:\n\t\treturn TypeFunction\n\tcase *userData:\n\t\treturn TypeUserData\n\tcase *State:\n\t\treturn TypeThread\n\tcase *luaClosure:\n\t\treturn TypeFunction\n\tcase *goClosure:\n\t\treturn TypeFunction\n\t}\n\treturn TypeNone\n}\n\n// TypeOf returns the type of the value at index, or TypeNone for a\n// non-valid (but acceptable) index.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_type\nfunc (l *State) TypeOf(index int) Type {\n\treturn l.valueToType(l.indexToValue(index))\n}\n\n// IsGoFunction verifies that the value at index is a Go function.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_iscfunction\nfunc (l *State) IsGoFunction(index int) bool {\n\tif _, ok := l.indexToValue(index).(*goFunction); ok {\n\t\treturn true\n\t}\n\t_, ok := l.indexToValue(index).(*goClosure)\n\treturn ok\n}\n\n// IsNumber verifies that the value at index is a number.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isnumber\nfunc (l *State) IsNumber(index int) bool {\n\t_, ok := l.toNumber(l.indexToValue(index))\n\treturn ok\n}\n\n// IsString verifies that the value at index is a string, or a number (which\n// is always convertible to a string).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isstring\nfunc (l *State) IsString(index int) bool {\n\tif _, ok := l.indexToValue(index).(string); ok {\n\t\treturn true\n\t}\n\t_, ok := l.indexToValue(index).(float64)\n\treturn ok\n}\n\n// IsUserData verifies that the value at index is a userdata.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isuserdata\nfunc (l *State) IsUserData(index int) bool {\n\t_, ok := l.indexToValue(index).(*userData)\n\treturn ok\n}\n\n// Arith performs an arithmetic operation over the two values (or one, in\n// case of negation) at the top of the stack, with the value at the top being\n// the second operand, ops these values and pushes the result of the operation.\n// The function follows the semantics of the corresponding Lua operator\n// (that is, it may call metamethods).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_arith\nfunc (l *State) Arith(op Operator) {\n\tif op != OpUnaryMinus {\n\t\tl.checkElementCount(2)\n\t} else {\n\t\tl.checkElementCount(1)\n\t\tl.push(l.stack[l.top-1])\n\t}\n\to1, o2 := l.stack[l.top-2], l.stack[l.top-1]\n\tif n1, n2, ok := pairAsNumbers(o1, o2); ok {\n\t\tl.stack[l.top-2] = arith(op, n1, n2)\n\t} else {\n\t\tl.stack[l.top-2] = l.arith(o1, o2, tm(op-OpAdd)+tmAdd)\n\t}\n\tl.top--\n}\n\n// RawEqual verifies that the values at index1 and index2 are primitively\n// equal (that is, without calling their metamethods).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawequal\nfunc (l *State) RawEqual(index1, index2 int) bool {\n\tif o1, o2 := l.indexToValue(index1), l.indexToValue(index2); o1 != nil && o2 != nil {\n\t\treturn o1 == o2\n\t}\n\treturn false\n}\n\n// Compare compares two values.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_compare\nfunc (l *State) Compare(index1, index2 int, op ComparisonOperator) bool {\n\tif o1, o2 := l.indexToValue(index1), l.indexToValue(index2); o1 != nil && o2 != nil {\n\t\tswitch op {\n\t\tcase OpEq:\n\t\t\treturn l.equalObjects(o1, o2)\n\t\tcase OpLT:\n\t\t\treturn l.lessThan(o1, o2)\n\t\tcase OpLE:\n\t\t\treturn l.lessOrEqual(o1, o2)\n\t\tdefault:\n\t\t\tpanic(\"invalid option\")\n\t\t}\n\t}\n\treturn false\n}\n\n// ToInteger converts the Lua value at index into a signed integer. The Lua\n// value must be a number, or a string convertible to a number.\n//\n// If the number is not an integer, it is truncated in some non-specified way.\n//\n// If the operation failed, the second return value will be false.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tointegerx\nfunc (l *State) ToInteger(index int) (int, bool) {\n\tif n, ok := l.toNumber(l.indexToValue(index)); ok {\n\t\treturn int(n), true\n\t}\n\treturn 0, false\n}\n\n// ToUnsigned converts the Lua value at index to a Go uint. The Lua value\n// must be a number or a string convertible to a number.\n//\n// If the number is not an unsigned integer, it is truncated in some\n// non-specified way.  If the number is outside the range of uint, it is\n// normalized to the remainder of its division by one more than the maximum\n// representable value.\n//\n// If the operation failed, the second return value will be false.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tounsignedx\nfunc (l *State) ToUnsigned(index int) (uint, bool) {\n\tif n, ok := l.toNumber(l.indexToValue(index)); ok {\n\t\tconst supUnsigned = float64(^uint32(0)) + 1\n\t\treturn uint(n - math.Floor(n/supUnsigned)*supUnsigned), true\n\t}\n\treturn 0, false\n}\n\n// ToString  converts the Lua value at index to a Go string.  The Lua value\n// must also be a string or a number; otherwise the function returns\n// false for its second return value.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tolstring\nfunc (l *State) ToString(index int) (s string, ok bool) {\n\tif s, ok = toString(l.indexToValue(index)); ok { // Bug compatibility: replace a number with its string representation.\n\t\tl.setIndexToValue(index, s)\n\t}\n\treturn\n}\n\n// RawLength returns the length of the value at index.  For strings, this is\n// the length.  For tables, this is the result of the # operator with no\n// metamethods.  For userdata, this is the size of the block of memory\n// allocated for the userdata (not implemented yet). For other values, it is 0.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawlen\nfunc (l *State) RawLength(index int) int {\n\tswitch v := l.indexToValue(index).(type) {\n\tcase string:\n\t\treturn len(v)\n\t// case *userData:\n\t// \treturn reflect.Sizeof(v.data)\n\tcase *table:\n\t\treturn v.length()\n\t}\n\treturn 0\n}\n\n// ToGoFunction converts a value at index into a Go function.  That value\n// must be a Go function, otherwise it returns nil.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tocfunction\nfunc (l *State) ToGoFunction(index int) Function {\n\tswitch v := l.indexToValue(index).(type) {\n\tcase *goFunction:\n\t\treturn v.Function\n\tcase *goClosure:\n\t\treturn v.function\n\t}\n\treturn nil\n}\n\n// ToUserData returns an interface{} of the userdata of the value at index.\n// Otherwise, it returns nil.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_touserdata\nfunc (l *State) ToUserData(index int) interface{} {\n\tif d, ok := l.indexToValue(index).(*userData); ok {\n\t\treturn d.data\n\t}\n\treturn nil\n}\n\n// ToThread converts the value at index to a Lua thread (a State). This\n// value must be a thread, otherwise the return value will be nil.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tothread\nfunc (l *State) ToThread(index int) *State {\n\tif t, ok := l.indexToValue(index).(*State); ok {\n\t\treturn t\n\t}\n\treturn nil\n}\n\n// ToValue convertes the value at index into a generic Go interface{}.  The\n// value can be a userdata, a table, a thread, a function, or Go string, bool\n// or float64 types. Otherwise, the function returns nil.\n//\n// Different objects will give different values.  There is no way to convert\n// the value back into its original value.\n//\n// Typically, this function is used only for debug information.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tovalue\nfunc (l *State) ToValue(index int) interface{} {\n\tv := l.indexToValue(index)\n\tswitch v := v.(type) {\n\tcase string, float64, bool, *table, *luaClosure, *goClosure, *goFunction, *State:\n\tcase *userData:\n\t\treturn v.data\n\tdefault:\n\t\treturn nil\n\t}\n\treturn v\n}\n\n// PushString pushes a string onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushstring\nfunc (l *State) PushString(s string) string { // TODO is it useful to return the argument?\n\tl.apiPush(s)\n\treturn s\n}\n\n// PushFString pushes onto the stack a formatted string and returns that\n// string.  It is similar to fmt.Sprintf, but has some differences: the\n// conversion specifiers are quite restricted.  There are no flags, widths,\n// or precisions.  The conversion specifiers can only be %% (inserts a %\n// in the string), %s, %f (a Lua number), %p (a pointer as a hexadecimal\n// numeral), %d and %c (an integer as a byte).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushfstring\nfunc (l *State) PushFString(format string, args ...interface{}) string {\n\tn, i := 0, 0\n\tfor {\n\t\te := strings.IndexRune(format, '%')\n\t\tif e < 0 {\n\t\t\tbreak\n\t\t}\n\t\tl.checkStack(2) // format + item\n\t\tl.push(format[:e])\n\t\tswitch format[e+1] {\n\t\tcase 's':\n\t\t\tif args[i] == nil {\n\t\t\t\tl.push(\"(null)\")\n\t\t\t} else {\n\t\t\t\tl.push(args[i].(string))\n\t\t\t}\n\t\t\ti++\n\t\tcase 'c':\n\t\t\tl.push(string(args[i].(rune)))\n\t\t\ti++\n\t\tcase 'd':\n\t\t\tl.push(float64(args[i].(int)))\n\t\t\ti++\n\t\tcase 'f':\n\t\t\tl.push(args[i].(float64))\n\t\t\ti++\n\t\tcase 'p':\n\t\t\tl.push(fmt.Sprintf(\"%p\", args[i]))\n\t\t\ti++\n\t\tcase '%':\n\t\t\tl.push(\"%\")\n\t\tdefault:\n\t\t\tl.runtimeError(\"invalid option \" + format[e:e+2] + \" to 'lua_pushfstring'\")\n\t\t}\n\t\tn += 2\n\t\tformat = format[e+2:]\n\t}\n\tl.checkStack(1)\n\tl.push(format)\n\tif n > 0 {\n\t\tl.concat(n + 1)\n\t}\n\treturn l.stack[l.top-1].(string)\n}\n\n// PushGoClosure pushes a new Go closure onto the stack.\n//\n// When a Go function is created, it is possible to associate some values with\n// it, thus creating a Go closure; these values are then accessible to the\n// function whenever it is called.  To associate values with a Go function,\n// first these values should be pushed onto the stack (when there are multiple\n// values, the first value is pushed first).  Then PushGoClosure is called to\n// create and push the Go function onto the stack, with the argument upValueCount\n// telling how many values should be associated with the function.  Calling\n// PushGoClosure also pops these values from the stack.\n//\n// When upValueCount is 0, this function creates a light Go function, which is just a\n// Go function.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushcclosure\nfunc (l *State) PushGoClosure(function Function, upValueCount uint8) {\n\tif upValueCount == 0 {\n\t\tl.apiPush(&goFunction{function})\n\t} else {\n\t\tn := int(upValueCount)\n\n\t\tl.checkElementCount(n)\n\t\tcl := &goClosure{function: function, upValues: make([]value, upValueCount)}\n\t\tl.top -= n\n\t\tcopy(cl.upValues, l.stack[l.top:l.top+n])\n\t\tl.apiPush(cl)\n\t}\n}\n\n// PushThread pushes the thread l onto the stack.  It returns true if l is\n// the main thread of its state.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushthread\nfunc (l *State) PushThread() bool {\n\tl.apiPush(l)\n\treturn l.global.mainThread == l\n}\n\n// Global pushes onto the stack the value of the global name.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_getglobal\nfunc (l *State) Global(name string) {\n\tg := l.global.registry.atInt(RegistryIndexGlobals)\n\tl.push(name)\n\tl.stack[l.top-1] = l.tableAt(g, l.stack[l.top-1])\n}\n\n// Field pushes onto the stack the value table[name], where table is the\n// table on the stack at the given index. This call may trigger a\n// metamethod for the __index event.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_getfield\nfunc (l *State) Field(index int, name string) {\n\tt := l.indexToValue(index)\n\tl.apiPush(name)\n\tl.stack[l.top-1] = l.tableAt(t, l.stack[l.top-1])\n}\n\n// RawGet is similar to GetTable, but does a raw access (without metamethods).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawget\nfunc (l *State) RawGet(index int) {\n\tt := l.indexToValue(index).(*table)\n\tl.stack[l.top-1] = t.at(l.stack[l.top-1])\n}\n\n// RawGetInt pushes onto the stack the value table[key] where table is the\n// value at index on the stack. The access is raw, as it doesn't invoke\n// metamethods.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawgeti\nfunc (l *State) RawGetInt(index, key int) {\n\tt := l.indexToValue(index).(*table)\n\tl.apiPush(t.atInt(key))\n}\n\n// RawGetValue pushes onto the stack value table[p] where table is the\n// value at index on the stack, and p is a light userdata.  The access is\n// raw, as it doesn't invoke metamethods.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawgetp\nfunc (l *State) RawGetValue(index int, p interface{}) {\n\tt := l.indexToValue(index).(*table)\n\tl.apiPush(t.at(p))\n}\n\n// CreateTable creates a new empty table and pushes it onto the stack.\n// arrayCount is a hint for how many elements the table will have as a\n// sequence; recordCount is a hint for how many other elements the table\n// will have.  Lua may use these hints to preallocate memory for the the new\n// table.  This pre-allocation is useful for performance when you know in\n// advance how many elements the table will have.  Otherwise, you can use the\n// function NewTable.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_createtable\nfunc (l *State) CreateTable(arrayCount, recordCount int) {\n\tl.apiPush(newTableWithSize(arrayCount, recordCount))\n}\n\n// MetaTable pushes onto the stack the metatable of the value at index.  If\n// the value at index does not have a metatable, the function returns\n// false and nothing is put onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_getmetatable\nfunc (l *State) MetaTable(index int) bool {\n\tvar mt *table\n\tswitch v := l.indexToValue(index).(type) {\n\tcase *table:\n\t\tmt = v.metaTable\n\tcase *userData:\n\t\tmt = v.metaTable\n\tdefault:\n\t\tmt = l.global.metaTable(v)\n\t}\n\tif mt == nil {\n\t\treturn false\n\t}\n\tl.apiPush(mt)\n\treturn true\n}\n\n// UserValue pushes onto the stack the Lua value associated with the userdata\n// at index.  This value must be a table or nil.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_getuservalue\nfunc (l *State) UserValue(index int) {\n\td := l.indexToValue(index).(*userData)\n\tif d.env == nil {\n\t\tl.apiPush(nil)\n\t} else {\n\t\tl.apiPush(d.env)\n\t}\n}\n\n// SetGlobal pops a value from the stack and sets it as the new value of\n// global name.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_setglobal\nfunc (l *State) SetGlobal(name string) {\n\tl.checkElementCount(1)\n\tg := l.global.registry.atInt(RegistryIndexGlobals)\n\tl.push(name)\n\tl.setTableAt(g, l.stack[l.top-1], l.stack[l.top-2])\n\tl.top -= 2 // pop value and key\n}\n\n// SetTable does the equivalent of table[key]=v, where table is the value\n// at index, v is the value at the top of the stack and key is the value\n// just below the top.\n//\n// The function pops both the key and the value from the stack.  As in Lua,\n// this function may trigger a metamethod for the __newindex event.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_settable\nfunc (l *State) SetTable(index int) {\n\tl.checkElementCount(2)\n\tl.setTableAt(l.indexToValue(index), l.stack[l.top-2], l.stack[l.top-1])\n\tl.top -= 2\n}\n\n// RawSet is similar to SetTable, but does a raw assignment (without\n// metamethods).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawset\nfunc (l *State) RawSet(index int) {\n\tl.checkElementCount(2)\n\tt := l.indexToValue(index).(*table)\n\tt.put(l, l.stack[l.top-2], l.stack[l.top-1])\n\tt.invalidateTagMethodCache()\n\tl.top -= 2\n}\n\n// RawSetInt does the equivalent of table[n]=v where table is the table at\n// index and v is the value at the top of the stack.\n//\n// This function pops the value from the stack.  The assignment is raw; it\n// doesn't invoke metamethods.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_rawseti\nfunc (l *State) RawSetInt(index, key int) {\n\tl.checkElementCount(1)\n\tt := l.indexToValue(index).(*table)\n\tt.putAtInt(key, l.stack[l.top-1])\n\tl.top--\n}\n\n// SetUserValue pops a table or nil from the stack and sets it as the new\n// value associated to the userdata at index.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_setuservalue\nfunc (l *State) SetUserValue(index int) {\n\tl.checkElementCount(1)\n\td := l.indexToValue(index).(*userData)\n\tif l.stack[l.top-1] == nil {\n\t\td.env = nil\n\t} else {\n\t\tt := l.stack[l.top-1].(*table)\n\t\td.env = t\n\t}\n\tl.top--\n}\n\n// SetMetaTable pops a table from the stack and sets it as the new metatable\n// for the value at index.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_setmetatable\nfunc (l *State) SetMetaTable(index int) {\n\tl.checkElementCount(1)\n\tmt, ok := l.stack[l.top-1].(*table)\n\tif apiCheck && !ok && l.stack[l.top-1] != nil {\n\t\tpanic(\"table expected\")\n\t}\n\tswitch v := l.indexToValue(index).(type) {\n\tcase *table:\n\t\tv.metaTable = mt\n\tcase *userData:\n\t\tv.metaTable = mt\n\tdefault:\n\t\tl.global.metaTables[l.TypeOf(index)] = mt\n\t}\n\tl.top--\n}\n\n// Error generates a Lua error.  The error message must be on the stack top.\n// The error can be any of any Lua type. This function will panic().\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_error\nfunc (l *State) Error() {\n\tl.checkElementCount(1)\n\tl.errorMessage()\n}\n\n// Next pops a key from the stack and pushes a key-value pair from the table\n// at index, while the table has next elements.  If there are no more\n// elements, nothing is pushed on the stack and Next returns false.\n//\n// A typical traversal looks like this:\n//\n//  // Table is on top of the stack (index -1).\n//  l.PushNil() // Add nil entry on stack (need 2 free slots).\n//  for l.Next(-2) {\n//  \tkey := lua.CheckString(l, -2)\n//  \tval := lua.CheckString(l, -1)\n//  \tl.Pop(1) // Remove val, but need key for the next iter.\n//  }\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_next\nfunc (l *State) Next(index int) bool {\n\tt := l.indexToValue(index).(*table)\n\tif l.next(t, l.top-1) {\n\t\tl.apiIncrementTop()\n\t\treturn true\n\t}\n\t// no more elements\n\tl.top-- // remove key\n\treturn false\n}\n\n// Concat concatenates the n values at the top of the stack, pops them, and\n// leaves the result at the top. If n is 1, the result is the single value\n// on the stack (that is, the function does nothing); if n is 0, the result\n// is the empty string. Concatenation is performed following the usual\n// semantic of Lua.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_concat\nfunc (l *State) Concat(n int) {\n\tl.checkElementCount(n)\n\tif n >= 2 {\n\t\tl.concat(n)\n\t} else if n == 0 { // push empty string\n\t\tl.apiPush(\"\")\n\t} // else n == 1; nothing to do\n}\n\n// Register sets the Go function f as the new value of global name. If\n// name was already defined, it is overwritten.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_register\nfunc (l *State) Register(name string, f Function) {\n\tl.PushGoFunction(f)\n\tl.SetGlobal(name)\n}\n\nfunc (l *State) setErrorObject(err error, oldTop int) {\n\tswitch err {\n\tcase MemoryError:\n\t\tl.stack[oldTop] = l.global.memoryErrorMessage\n\tcase ErrorError:\n\t\tl.stack[oldTop] = \"error in error handling\"\n\tdefault:\n\t\tl.stack[oldTop] = l.stack[l.top-1]\n\t}\n\tl.top = oldTop + 1\n}\n\nfunc (l *State) protectedCall(f func(), oldTop, errorFunc int) error {\n\tcallInfo, allowHook, nonYieldableCallCount, errorFunction := l.callInfo, l.allowHook, l.nonYieldableCallCount, l.errorFunction\n\tl.errorFunction = errorFunc\n\terr := l.protect(f)\n\tif err != nil {\n\t\tl.close(oldTop)\n\t\tl.setErrorObject(err, oldTop)\n\t\tl.callInfo, l.allowHook, l.nonYieldableCallCount = callInfo, allowHook, nonYieldableCallCount\n\t\t// TODO l.shrinkStack()\n\t}\n\tl.errorFunction = errorFunction\n\treturn err\n}\n\n// UpValue returns the name of the upvalue at index away from function,\n// where index cannot be greater than the number of upvalues.\n//\n// Returns an empty string and false if the index is greater than the number\n// of upvalues.\nfunc UpValue(l *State, function, index int) (name string, ok bool) {\n\tif c, isClosure := l.indexToValue(function).(closure); isClosure {\n\t\tif ok = 1 <= index && index <= c.upValueCount(); ok {\n\t\t\tif c, isLua := c.(*luaClosure); isLua {\n\t\t\t\tname = c.prototype.upValues[index-1].name\n\t\t\t}\n\t\t\tl.apiPush(c.upValue(index - 1))\n\t\t}\n\t}\n\treturn\n}\n\n// SetUpValue sets the value of a closure's upvalue. It assigns the value at\n// the top of the stack to the upvalue and returns its name.  It also pops a\n// value from the stack. function and index are as in UpValue.\n//\n// Returns an empty string and false if the index is greater than the number\n// of upvalues.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_setupvalue\nfunc SetUpValue(l *State, function, index int) (name string, ok bool) {\n\tif c, isClosure := l.indexToValue(function).(closure); isClosure {\n\t\tif ok = 1 <= index && index <= c.upValueCount(); ok {\n\t\t\tif c, isLua := c.(*luaClosure); isLua {\n\t\t\t\tname = c.prototype.upValues[index-1].name\n\t\t\t}\n\t\t\tl.top--\n\t\t\tc.setUpValue(index-1, l.stack[l.top])\n\t\t}\n\t}\n\treturn\n}\n\nfunc (l *State) upValue(f, n int) **upValue {\n\treturn &l.indexToValue(f).(*luaClosure).upValues[n-1]\n}\n\n// UpValueId returns a unique identifier for the upvalue numbered n from the\n// closure at index f. Parameters f and n are as in UpValue (but n cannot be\n// greater than the number of upvalues).\n//\n// These unique identifiers allow a program to check whether different\n// closures share upvalues. Lua closures that share an upvalue (that is, that\n// access a same external local variable) will return identical ids for those\n// upvalue indices.\nfunc UpValueId(l *State, f, n int) interface{} {\n\tswitch fun := l.indexToValue(f).(type) {\n\tcase *luaClosure:\n\t\treturn *l.upValue(f, n)\n\tcase *goClosure:\n\t\treturn &fun.upValues[n-1]\n\t}\n\tpanic(\"closure expected\")\n}\n\n// UpValueJoin makes the n1-th upvalue of the Lua closure at index f1 refer to\n// the n2-th upvalue of the Lua closure at index f2.\nfunc UpValueJoin(l *State, f1, n1, f2, n2 int) {\n\tu1 := l.upValue(f1, n1)\n\tu2 := l.upValue(f2, n2)\n\t*u1 = *u2\n}\n\n// Call calls a function. To do so, use the following protocol: first, the\n// function to be called is pushed onto the stack; then, the arguments to the\n// function are pushed in direct order - that is, the first argument is pushed\n// first. Finally, call Call. argCount is the number of arguments that you\n// pushed onto the stack. All arguments and the function value are popped\n// from the stack when the function is called.\n//\n// The results are pushed onto the stack when the function returns. The\n// number of results is adjusted to resultCount, unless resultCount is\n// MultipleReturns. In this case, all results from the function are pushed.\n// Lua takes care that the returned values fit into the stack space. The\n// function results are pushed onto the stack in direct order (the first\n// result is pushed first), so that after the call the last result is on the\n// top of the stack.\n//\n// Any error inside the called function provokes a call to panic().\n//\n// The following example shows how the host program can do the equivalent to\n// this Lua code:\n//\n//\t\ta = f(\"how\", t.x, 14)\n//\n// Here it is in Go:\n//\n//\t\tl.Global(\"f\")       // Function to be called.\n//\t\tl.PushString(\"how\") // 1st argument.\n//\t\tl.Global(\"t\")       // Table to be indexed.\n//\t\tl.Field(-1, \"x\")    // Push result of t.x (2nd arg).\n//\t\tl.Remove(-2)        // Remove t from the stack.\n//\t\tl.PushInteger(14)   // 3rd argument.\n//\t\tl.Call(3, 1)        // Call f with 3 arguments and 1 result.\n//\t\tl.SetGlobal(\"a\")    // Set global a.\n//\n// Note that the code above is \"balanced\": at its end, the stack is back to\n// its original configuration. This is considered good programming practice.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_call\nfunc (l *State) Call(argCount, resultCount int) {\n\tl.CallWithContinuation(argCount, resultCount, 0, nil)\n}\n\n// Top returns the index of the top element in the stack. Because Lua indices\n// start at 1, this result is equal to the number of elements in the stack\n// (hence 0 means an empty stack).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_gettop\nfunc (l *State) Top() int { return l.top - (l.callInfo.function + 1) }\n\n// Copy moves the element at the index from into the valid index to\n// without shifting any element (therefore replacing the value at that\n// position).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_copy\nfunc (l *State) Copy(from, to int) { l.move(to, l.indexToValue(from)) }\n\n// Version returns the address of the version number stored in the Lua core.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_version\nfunc Version(l *State) *float64 { return l.global.version }\n\n// UpValueIndex returns the pseudo-index that represents the i-th upvalue of\n// the running function.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_upvalueindex\nfunc UpValueIndex(i int) int   { return RegistryIndex - i }\nfunc isPseudoIndex(i int) bool { return i <= RegistryIndex }\n\nfunc apiCheckStackSpace(l *State, n int) { l.assert(n < l.top-l.callInfo.function) }\n\n// String returns the name of Type t.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_typename\nfunc (t Type) String() string { return typeNames[t+1] }\n\n// ToNumber converts the Lua value at index to the Go type for a Lua number\n// (float64). The Lua value must be a number or a string convertible to a\n// number.\n//\n// If the operation failed, the second return value will be false.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_tonumberx\nfunc (l *State) ToNumber(index int) (float64, bool) { return l.toNumber(l.indexToValue(index)) }\n\n// ToBoolean converts the Lua value at index to a Go boolean. Like all\n// tests in Lua, the only false values are false booleans and nil.\n// Otherwise, all other Lua values evaluate to true.\n//\n// To accept only actual boolean values, use the test IsBoolean.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_toboolean\nfunc (l *State) ToBoolean(index int) bool { return !isFalse(l.indexToValue(index)) }\n\n// Table pushes onto the stack the value table[top], where table is the\n// value at index, and top is the value at the top of the stack. This\n// function pops the key from the stack, putting the resulting value in its\n// place.  As in Lua, this function may trigger a metamethod for the __index\n// event.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_gettable\nfunc (l *State) Table(index int) {\n\tl.stack[l.top-1] = l.tableAt(l.indexToValue(index), l.stack[l.top-1])\n}\n\n// PushValue pushes a copy of the element at index onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushvalue\nfunc (l *State) PushValue(index int) { l.apiPush(l.indexToValue(index)) }\n\n// PushNil pushes a nil value onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushnil\nfunc (l *State) PushNil() { l.apiPush(nil) }\n\n// PushNumber pushes a number onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushnumber\nfunc (l *State) PushNumber(n float64) { l.apiPush(n) }\n\n// PushInteger pushes n onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushinteger\nfunc (l *State) PushInteger(n int) { l.apiPush(float64(n)) }\n\n// PushUnsigned pushes n onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushunsigned\nfunc (l *State) PushUnsigned(n uint) { l.apiPush(float64(n)) }\n\n// PushBoolean pushes a boolean value with value b onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushboolean\nfunc (l *State) PushBoolean(b bool) { l.apiPush(b) }\n\n// PushLightUserData pushes a light user data onto the stack. Userdata\n// represents Go values in Lua. A light userdata is an interface{}. Its\n// equality matches the Go rules (http://golang.org/ref/spec#Comparison_operators).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushlightuserdata\nfunc (l *State) PushLightUserData(d interface{}) { l.apiPush(d) }\n\n// PushUserData is similar to PushLightUserData, but pushes a full userdata\n// onto the stack.\nfunc (l *State) PushUserData(d interface{}) { l.apiPush(&userData{data: d}) }\n\n// Length of the value at index; it is equivalent to the # operator in\n// Lua. The result is pushed on the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_len\nfunc (l *State) Length(index int) { l.apiPush(l.objectLength(l.indexToValue(index))) }\n\n// Pop pops n elements from the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pop\nfunc (l *State) Pop(n int) { l.SetTop(-n - 1) }\n\n// NewTable creates a new empty table and pushes it onto the stack. It is\n// equivalent to l.CreateTable(0, 0).\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_newtable\nfunc (l *State) NewTable() { l.CreateTable(0, 0) }\n\n// PushGoFunction pushes a Function implemented in Go onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushcfunction\nfunc (l *State) PushGoFunction(f Function) { l.PushGoClosure(f, 0) }\n\n// IsFunction verifies that the value at index is a function, either Go or\n// Lua function.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isfunction\nfunc (l *State) IsFunction(index int) bool { return l.TypeOf(index) == TypeFunction }\n\n// IsTable verifies that the value at index is a table.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_istable\nfunc (l *State) IsTable(index int) bool { return l.TypeOf(index) == TypeTable }\n\n// IsLightUserData verifies that the value at index is a light userdata.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_islightuserdata\nfunc (l *State) IsLightUserData(index int) bool { return l.TypeOf(index) == TypeLightUserData }\n\n// IsNil verifies that the value at index is nil.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isnil\nfunc (l *State) IsNil(index int) bool { return l.TypeOf(index) == TypeNil }\n\n// IsBoolean verifies that the value at index is a boolean.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isboolean\nfunc (l *State) IsBoolean(index int) bool { return l.TypeOf(index) == TypeBoolean }\n\n// IsThread verifies that the value at index is a thread.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isthread\nfunc (l *State) IsThread(index int) bool { return l.TypeOf(index) == TypeThread }\n\n// IsNone verifies that the value at index is not valid.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isnone\nfunc (l *State) IsNone(index int) bool { return l.TypeOf(index) == TypeNone }\n\n// IsNoneOrNil verifies that the value at index is either nil or invalid.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_isnonornil.\nfunc (l *State) IsNoneOrNil(index int) bool { return l.TypeOf(index) <= TypeNil }\n\n// PushGlobalTable pushes the global environment onto the stack.\n//\n// http://www.lua.org/manual/5.2/manual.html#lua_pushglobaltable\nfunc (l *State) PushGlobalTable() { l.RawGetInt(RegistryIndex, RegistryIndexGlobals) }\n"
        },
        {
          "name": "lua_test.go",
          "type": "blob",
          "size": 0.615234375,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestPushFStringPointer(t *testing.T) {\n\tl := NewState()\n\tl.PushFString(\"%p %s\", l, \"test\")\n\n\texpected := fmt.Sprintf(\"%p %s\", l, \"test\")\n\tactual := CheckString(l, -1)\n\tif expected != actual {\n\t\tt.Errorf(\"PushFString, expected \\\"%s\\\" but found \\\"%s\\\"\", expected, actual)\n\t}\n}\n\nfunc TestToBooleanOutOfRange(t *testing.T) {\n\tl := NewState()\n\tl.SetTop(0)\n\tl.PushBoolean(false)\n\tl.PushBoolean(true)\n\n\tfor i, want := range []bool{false, true, false, false} {\n\t\tidx := 1 + i\n\t\tif got := l.ToBoolean(idx); got != want {\n\t\t\tt.Errorf(\"l.ToBoolean(%d) = %t; want %t\", idx, got, want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "math.go",
          "type": "blob",
          "size": 3.0693359375,
          "content": "package lua\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n)\n\nconst radiansPerDegree = math.Pi / 180.0\n\nfunc mathUnaryOp(f func(float64) float64) Function {\n\treturn func(l *State) int {\n\t\tl.PushNumber(f(CheckNumber(l, 1)))\n\t\treturn 1\n\t}\n}\n\nfunc mathBinaryOp(f func(float64, float64) float64) Function {\n\treturn func(l *State) int {\n\t\tl.PushNumber(f(CheckNumber(l, 1), CheckNumber(l, 2)))\n\t\treturn 1\n\t}\n}\n\nfunc reduce(f func(float64, float64) float64) Function {\n\treturn func(l *State) int {\n\t\tn := l.Top() // number of arguments\n\t\tv := CheckNumber(l, 1)\n\t\tfor i := 2; i <= n; i++ {\n\t\t\tv = f(v, CheckNumber(l, i))\n\t\t}\n\t\tl.PushNumber(v)\n\t\treturn 1\n\t}\n}\n\nvar mathLibrary = []RegistryFunction{\n\t{\"abs\", mathUnaryOp(math.Abs)},\n\t{\"acos\", mathUnaryOp(math.Acos)},\n\t{\"asin\", mathUnaryOp(math.Asin)},\n\t{\"atan2\", mathBinaryOp(math.Atan2)},\n\t{\"atan\", mathUnaryOp(math.Atan)},\n\t{\"ceil\", mathUnaryOp(math.Ceil)},\n\t{\"cosh\", mathUnaryOp(math.Cosh)},\n\t{\"cos\", mathUnaryOp(math.Cos)},\n\t{\"deg\", mathUnaryOp(func(x float64) float64 { return x / radiansPerDegree })},\n\t{\"exp\", mathUnaryOp(math.Exp)},\n\t{\"floor\", mathUnaryOp(math.Floor)},\n\t{\"fmod\", mathBinaryOp(math.Mod)},\n\t{\"frexp\", func(l *State) int {\n\t\tf, e := math.Frexp(CheckNumber(l, 1))\n\t\tl.PushNumber(f)\n\t\tl.PushInteger(e)\n\t\treturn 2\n\t}},\n\t{\"ldexp\", func(l *State) int {\n\t\tx, e := CheckNumber(l, 1), CheckInteger(l, 2)\n\t\tl.PushNumber(math.Ldexp(x, e))\n\t\treturn 1\n\t}},\n\t{\"log\", func(l *State) int {\n\t\tx := CheckNumber(l, 1)\n\t\tif l.IsNoneOrNil(2) {\n\t\t\tl.PushNumber(math.Log(x))\n\t\t} else if base := CheckNumber(l, 2); base == 10.0 {\n\t\t\tl.PushNumber(math.Log10(x))\n\t\t} else {\n\t\t\tl.PushNumber(math.Log(x) / math.Log(base))\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"max\", reduce(math.Max)},\n\t{\"min\", reduce(math.Min)},\n\t{\"modf\", func(l *State) int {\n\t\ti, f := math.Modf(CheckNumber(l, 1))\n\t\tl.PushNumber(i)\n\t\tl.PushNumber(f)\n\t\treturn 2\n\t}},\n\t{\"pow\", mathBinaryOp(math.Pow)},\n\t{\"rad\", mathUnaryOp(func(x float64) float64 { return x * radiansPerDegree })},\n\t{\"random\", func(l *State) int {\n\t\tr := rand.Float64()\n\t\tswitch l.Top() {\n\t\tcase 0: // no arguments\n\t\t\tl.PushNumber(r)\n\t\tcase 1: // upper limit only\n\t\t\tu := CheckNumber(l, 1)\n\t\t\tArgumentCheck(l, 1.0 <= u, 1, \"interval is empty\")\n\t\t\tl.PushNumber(math.Floor(r*u) + 1.0) // [1, u]\n\t\tcase 2: // lower and upper limits\n\t\t\tlo, u := CheckNumber(l, 1), CheckNumber(l, 2)\n\t\t\tArgumentCheck(l, lo <= u, 2, \"interval is empty\")\n\t\t\tl.PushNumber(math.Floor(r*(u-lo+1)) + lo) // [lo, u]\n\t\tdefault:\n\t\t\tErrorf(l, \"wrong number of arguments\")\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"randomseed\", func(l *State) int {\n\t\trand.Seed(int64(CheckUnsigned(l, 1)))\n\t\trand.Float64() // discard first value to avoid undesirable correlations\n\t\treturn 0\n\t}},\n\t{\"sinh\", mathUnaryOp(math.Sinh)},\n\t{\"sin\", mathUnaryOp(math.Sin)},\n\t{\"sqrt\", mathUnaryOp(math.Sqrt)},\n\t{\"tanh\", mathUnaryOp(math.Tanh)},\n\t{\"tan\", mathUnaryOp(math.Tan)},\n}\n\n// MathOpen opens the math library. Usually passed to Require.\nfunc MathOpen(l *State) int {\n\tNewLibrary(l, mathLibrary)\n\tl.PushNumber(3.1415926535897932384626433832795) // TODO use math.Pi instead? Values differ.\n\tl.SetField(-2, \"pi\")\n\tl.PushNumber(math.MaxFloat64)\n\tl.SetField(-2, \"huge\")\n\treturn 1\n}\n"
        },
        {
          "name": "os.go",
          "type": "blob",
          "size": 3.6025390625,
          "content": "package lua\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\t\"time\"\n)\n\nfunc field(l *State, key string, def int) int {\n\tl.Field(-1, key)\n\tr, ok := l.ToInteger(-1)\n\tif !ok {\n\t\tif def < 0 {\n\t\t\tErrorf(l, \"field '%s' missing in date table\", key)\n\t\t}\n\t\tr = def\n\t}\n\tl.Pop(1)\n\treturn r\n}\n\nvar osLibrary = []RegistryFunction{\n\t{\"clock\", clock},\n\t// {\"date\", os_date},\n\t{\"difftime\", func(l *State) int {\n\t\tl.PushNumber(time.Unix(int64(CheckNumber(l, 1)), 0).Sub(time.Unix(int64(OptNumber(l, 2, 0)), 0)).Seconds())\n\t\treturn 1\n\t}},\n\n\t// From the Lua manual:\n\t// \"This function is equivalent to the ISO C function system\"\n\t// https://www.lua.org/manual/5.2/manual.html#pdf-os.execute\n\t{\"execute\", func(l *State) int {\n\t\tc := OptString(l, 1, \"\")\n\n\t\tif c == \"\" {\n\t\t\t// Check whether \"sh\" is available on the system.\n\t\t\terr := exec.Command(\"sh\").Run()\n\t\t\tl.PushBoolean(err == nil)\n\t\t\treturn 1\n\t\t}\n\n\t\tterminatedSuccessfully := true\n\t\tterminationReason := \"exit\"\n\t\tterminationData := 0\n\n\t\t// Create the command.\n\t\tcmd := exec.Command(\"sh\", \"-c\", c)\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\n\t\t// Run the command.\n\t\tif err := cmd.Run(); err != nil {\n\t\t\tterminatedSuccessfully = false\n\t\t\tterminationReason = \"exit\"\n\t\t\tterminationData = 1\n\n\t\t\tif exiterr, ok := err.(*exec.ExitError); ok {\n\t\t\t\tif status, ok := exiterr.Sys().(syscall.WaitStatus); ok {\n\t\t\t\t\tif status.Signaled() {\n\t\t\t\t\t\tterminationReason = \"signal\"\n\t\t\t\t\t\tterminationData = int(status.Signal())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tterminationData = status.ExitStatus()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Unsupported system?\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// From man 3 system:\n\t\t\t\t// \"If a child process could not be created, or its\n\t\t\t\t// status could not be retrieved, the return value\n\t\t\t\t// is -1.\"\n\t\t\t\tterminationData = -1\n\t\t\t}\n\t\t}\n\n\t\t// Deal with the return values.\n\t\tif terminatedSuccessfully {\n\t\t\tl.PushBoolean(true)\n\t\t} else {\n\t\t\tl.PushNil()\n\t\t}\n\n\t\tl.PushString(terminationReason)\n\t\tl.PushInteger(terminationData)\n\n\t\treturn 3\n\t}},\n\t{\"exit\", func(l *State) int {\n\t\tvar status int\n\t\tif l.IsBoolean(1) {\n\t\t\tif !l.ToBoolean(1) {\n\t\t\t\tstatus = 1\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = OptInteger(l, 1, status)\n\t\t}\n\t\t// if l.ToBoolean(2) {\n\t\t// \tClose(l)\n\t\t// }\n\t\tos.Exit(status)\n\t\tpanic(\"unreachable\")\n\t}},\n\t{\"getenv\", func(l *State) int { l.PushString(os.Getenv(CheckString(l, 1))); return 1 }},\n\t{\"remove\", func(l *State) int { name := CheckString(l, 1); return FileResult(l, os.Remove(name), name) }},\n\t{\"rename\", func(l *State) int { return FileResult(l, os.Rename(CheckString(l, 1), CheckString(l, 2)), \"\") }},\n\t// {\"setlocale\", func(l *State) int {\n\t// \top := CheckOption(l, 2, \"all\", []string{\"all\", \"collate\", \"ctype\", \"monetary\", \"numeric\", \"time\"})\n\t// \tl.PushString(setlocale([]int{LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME}, OptString(l, 1, \"\")))\n\t// \treturn 1\n\t// }},\n\t{\"time\", func(l *State) int {\n\t\tif l.IsNoneOrNil(1) {\n\t\t\tl.PushNumber(float64(time.Now().Unix()))\n\t\t} else {\n\t\t\tCheckType(l, 1, TypeTable)\n\t\t\tl.SetTop(1)\n\t\t\tyear := field(l, \"year\", -1) - 1900\n\t\t\tmonth := field(l, \"month\", -1) - 1\n\t\t\tday := field(l, \"day\", -1)\n\t\t\thour := field(l, \"hour\", 12)\n\t\t\tmin := field(l, \"min\", 0)\n\t\t\tsec := field(l, \"sec\", 0)\n\t\t\t// dst := boolField(l, \"isdst\") // TODO how to use dst?\n\t\t\tl.PushNumber(float64(time.Date(year, time.Month(month), day, hour, min, sec, 0, time.Local).Unix()))\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"tmpname\", func(l *State) int {\n\t\tf, err := ioutil.TempFile(\"\", \"lua_\")\n\t\tif err != nil {\n\t\t\tErrorf(l, \"unable to generate a unique filename\")\n\t\t}\n\t\tdefer f.Close()\n\t\tl.PushString(f.Name())\n\t\treturn 1\n\t}},\n}\n\n// OSOpen opens the os library. Usually passed to Require.\nfunc OSOpen(l *State) int {\n\tNewLibrary(l, osLibrary)\n\treturn 1\n}\n"
        },
        {
          "name": "os_windows.go",
          "type": "blob",
          "size": 0.11328125,
          "content": "package lua\n\nfunc clock(l *State) int {\n\tErrorf(l, \"os.clock not yet supported on Windows\")\n\tpanic(\"unreachable\")\n}\n"
        },
        {
          "name": "package_test.go",
          "type": "blob",
          "size": 0.73046875,
          "content": "package lua_test\n\nimport (\n\t\"fmt\"\n\t\"github.com/Shopify/go-lua\"\n)\n\ntype step struct {\n\tname     string\n\tfunction interface{}\n}\n\nfunc Example() {\n\tsteps := []step{}\n\tl := lua.NewState()\n\tlua.BaseOpen(l)\n\t_ = lua.NewMetaTable(l, \"stepMetaTable\")\n\tlua.SetFunctions(l, []lua.RegistryFunction{{\"__newindex\", func(l *lua.State) int {\n\t\tk, v := lua.CheckString(l, 2), l.ToValue(3)\n\t\tsteps = append(steps, step{name: k, function: v})\n\t\treturn 0\n\t}}}, 0)\n\tl.PushUserData(steps)\n\tl.PushValue(-1)\n\tl.SetGlobal(\"step\")\n\tlua.SetMetaTableNamed(l, \"stepMetaTable\")\n\tlua.LoadString(l, `step.request_tracking_js = function ()\n    get(config.domain..'/javascripts/shopify_stats.js')\n  end`)\n\tl.Call(0, 0)\n\tfmt.Println(steps[0].name)\n\t// Output: request_tracking_js\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 16.845703125,
          "content": "package lua\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\ntype parser struct {\n\tscanner\n\tfunction                   *function\n\tactiveVariables            []int\n\tpendingGotos, activeLabels []label\n}\n\nfunc (p *parser) checkCondition(c bool, message string) {\n\tif !c {\n\t\tp.syntaxError(message)\n\t}\n}\n\nfunc (p *parser) checkName() string {\n\tp.check(tkName)\n\ts := p.s\n\tp.next()\n\treturn s\n}\n\nfunc (p *parser) checkLimit(val, limit int, what string) {\n\tif val > limit {\n\t\twhere := \"main function\"\n\t\tif line := p.function.f.lineDefined; line != 0 {\n\t\t\twhere = fmt.Sprintf(\"function at line %d\", line)\n\t\t}\n\t\tp.syntaxError(fmt.Sprintf(\"too many %s (limit is %d) in %s\", what, limit, where))\n\t}\n}\n\nfunc (p *parser) checkNext(t rune) {\n\tp.check(t)\n\tp.next()\n}\n\nfunc (p *parser) checkNameAsExpression() exprDesc { return p.function.EncodeString(p.checkName()) }\nfunc (p *parser) singleVariable() exprDesc        { return p.function.SingleVariable(p.checkName()) }\nfunc (p *parser) leaveLevel()                     { p.l.nestedGoCallCount-- }\nfunc (p *parser) enterLevel() {\n\tp.l.nestedGoCallCount++\n\tp.checkLimit(p.l.nestedGoCallCount, maxCallCount, \"Go levels\")\n}\n\nfunc (p *parser) expressionList() (e exprDesc, n int) {\n\tfor n, e = 1, p.expression(); p.testNext(','); n, e = n+1, p.expression() {\n\t\t_ = p.function.ExpressionToNextRegister(e)\n\t}\n\treturn\n}\n\nfunc (p *parser) field(tableRegister, a, h, pending int, e exprDesc) (int, int, int, exprDesc) {\n\tfreeRegisterCount := p.function.freeRegisterCount\n\thashField := func(k exprDesc) {\n\t\th++\n\t\tp.checkNext('=')\n\t\tp.function.FlushFieldToConstructor(tableRegister, freeRegisterCount, k, p.expression)\n\t}\n\tswitch {\n\tcase p.t == tkName && p.lookAhead() == '=':\n\t\tp.checkLimit(h, maxInt, \"items in a constructor\")\n\t\thashField(p.checkNameAsExpression())\n\tcase p.t == '[':\n\t\thashField(p.index())\n\tdefault:\n\t\te = p.expression()\n\t\tp.checkLimit(a, maxInt, \"items in a constructor\")\n\t\ta++\n\t\tpending++\n\t}\n\treturn a, h, pending, e\n}\n\nfunc (p *parser) constructor() exprDesc {\n\tpc, t := p.function.OpenConstructor()\n\tline, a, h, pending := p.lineNumber, 0, 0, 0\n\tvar e exprDesc\n\tif p.checkNext('{'); p.t != '}' {\n\t\tfor a, h, pending, e = p.field(t.info, a, h, pending, e); (p.testNext(',') || p.testNext(';')) && p.t != '}'; {\n\t\t\tif e.kind != kindVoid {\n\t\t\t\tpending = p.function.FlushToConstructor(t.info, pending, a, e)\n\t\t\t\te.kind = kindVoid\n\t\t\t}\n\t\t\ta, h, pending, e = p.field(t.info, a, h, pending, e)\n\t\t}\n\t}\n\tp.checkMatch('}', '{', line)\n\tp.function.CloseConstructor(pc, t.info, pending, a, h, e)\n\treturn t\n}\n\nfunc (p *parser) functionArguments(f exprDesc, line int) exprDesc {\n\tvar args exprDesc\n\tswitch p.t {\n\tcase '(':\n\t\tp.next()\n\t\tif p.t == ')' {\n\t\t\targs.kind = kindVoid\n\t\t} else {\n\t\t\targs, _ = p.expressionList()\n\t\t\tp.function.SetMultipleReturns(args)\n\t\t}\n\t\tp.checkMatch(')', '(', line)\n\tcase '{':\n\t\targs = p.constructor()\n\tcase tkString:\n\t\targs = p.function.EncodeString(p.s)\n\t\tp.next()\n\tdefault:\n\t\tp.syntaxError(\"function arguments expected\")\n\t}\n\tbase, parameterCount := f.info, MultipleReturns\n\tif !args.hasMultipleReturns() {\n\t\tif args.kind != kindVoid {\n\t\t\targs = p.function.ExpressionToNextRegister(args)\n\t\t}\n\t\tparameterCount = p.function.freeRegisterCount - (base + 1)\n\t}\n\te := makeExpression(kindCall, p.function.EncodeABC(opCall, base, parameterCount+1, 2))\n\tp.function.FixLine(line)\n\tp.function.freeRegisterCount = base + 1 // call removed function and args & leaves (unless changed) one result\n\treturn e\n}\n\nfunc (p *parser) primaryExpression() (e exprDesc) {\n\tswitch p.t {\n\tcase '(':\n\t\tline := p.lineNumber\n\t\tp.next()\n\t\te = p.expression()\n\t\tp.checkMatch(')', '(', line)\n\t\te = p.function.DischargeVariables(e)\n\tcase tkName:\n\t\te = p.singleVariable()\n\tdefault:\n\t\tp.syntaxError(\"unexpected symbol\")\n\t}\n\treturn\n}\n\nfunc (p *parser) suffixedExpression() exprDesc {\n\tline := p.lineNumber\n\te := p.primaryExpression()\n\tfor {\n\t\tswitch p.t {\n\t\tcase '.':\n\t\t\te = p.fieldSelector(e)\n\t\tcase '[':\n\t\t\te = p.function.Indexed(p.function.ExpressionToAnyRegisterOrUpValue(e), p.index())\n\t\tcase ':':\n\t\t\tp.next()\n\t\t\te = p.functionArguments(p.function.Self(e, p.checkNameAsExpression()), line)\n\t\tcase '(', tkString, '{':\n\t\t\te = p.functionArguments(p.function.ExpressionToNextRegister(e), line)\n\t\tdefault:\n\t\t\treturn e\n\t\t}\n\t}\n}\n\nfunc (p *parser) simpleExpression() (e exprDesc) {\n\tswitch p.t {\n\tcase tkNumber:\n\t\te = makeExpression(kindNumber, 0)\n\t\te.value = p.n\n\tcase tkString:\n\t\te = p.function.EncodeString(p.s)\n\tcase tkNil:\n\t\te = makeExpression(kindNil, 0)\n\tcase tkTrue:\n\t\te = makeExpression(kindTrue, 0)\n\tcase tkFalse:\n\t\te = makeExpression(kindFalse, 0)\n\tcase tkDots:\n\t\tp.checkCondition(p.function.f.isVarArg, \"cannot use '...' outside a vararg function\")\n\t\te = makeExpression(kindVarArg, p.function.EncodeABC(opVarArg, 0, 1, 0))\n\tcase '{':\n\t\te = p.constructor()\n\t\treturn\n\tcase tkFunction:\n\t\tp.next()\n\t\te = p.body(false, p.lineNumber)\n\t\treturn\n\tdefault:\n\t\te = p.suffixedExpression()\n\t\treturn\n\t}\n\tp.next()\n\treturn\n}\n\nfunc unaryOp(op rune) int {\n\tswitch op {\n\tcase tkNot:\n\t\treturn oprNot\n\tcase '-':\n\t\treturn oprMinus\n\tcase '#':\n\t\treturn oprLength\n\t}\n\treturn oprNoUnary\n}\n\nfunc binaryOp(op rune) int {\n\tswitch op {\n\tcase '+':\n\t\treturn oprAdd\n\tcase '-':\n\t\treturn oprSub\n\tcase '*':\n\t\treturn oprMul\n\tcase '/':\n\t\treturn oprDiv\n\tcase '%':\n\t\treturn oprMod\n\tcase '^':\n\t\treturn oprPow\n\tcase tkConcat:\n\t\treturn oprConcat\n\tcase tkNE:\n\t\treturn oprNE\n\tcase tkEq:\n\t\treturn oprEq\n\tcase '<':\n\t\treturn oprLT\n\tcase tkLE:\n\t\treturn oprLE\n\tcase '>':\n\t\treturn oprGT\n\tcase tkGE:\n\t\treturn oprGE\n\tcase tkAnd:\n\t\treturn oprAnd\n\tcase tkOr:\n\t\treturn oprOr\n\t}\n\treturn oprNoBinary\n}\n\nvar priority []struct{ left, right int } = []struct{ left, right int }{\n\t{6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7}, // `+' `-' `*' `/' `%'\n\t{10, 9}, {5, 4}, // ^, .. (right associative)\n\t{3, 3}, {3, 3}, {3, 3}, // ==, <, <=\n\t{3, 3}, {3, 3}, {3, 3}, // ~=, >, >=\n\t{2, 2}, {1, 1}, // and, or\n}\n\nconst unaryPriority = 8\n\nfunc (p *parser) subExpression(limit int) (e exprDesc, op int) {\n\tp.enterLevel()\n\tif u := unaryOp(p.t); u != oprNoUnary {\n\t\tline := p.lineNumber\n\t\tp.next()\n\t\te, _ = p.subExpression(unaryPriority)\n\t\te = p.function.Prefix(u, e, line)\n\t} else {\n\t\te = p.simpleExpression()\n\t}\n\top = binaryOp(p.t)\n\tfor op != oprNoBinary && priority[op].left > limit {\n\t\tline := p.lineNumber\n\t\tp.next()\n\t\te = p.function.Infix(op, e)\n\t\te2, next := p.subExpression(priority[op].right)\n\t\te = p.function.Postfix(op, e, e2, line)\n\t\top = next\n\t}\n\tp.leaveLevel()\n\treturn\n}\n\nfunc (p *parser) expression() (e exprDesc) {\n\te, _ = p.subExpression(0)\n\treturn\n}\n\nfunc (p *parser) blockFollow(withUntil bool) bool {\n\tswitch p.t {\n\tcase tkElse, tkElseif, tkEnd, tkEOS:\n\t\treturn true\n\tcase tkUntil:\n\t\treturn withUntil\n\t}\n\treturn false\n}\n\nfunc (p *parser) statementList() {\n\tfor !p.blockFollow(true) {\n\t\tif p.t == tkReturn {\n\t\t\tp.statement()\n\t\t\treturn\n\t\t}\n\t\tp.statement()\n\t}\n}\n\nfunc (p *parser) fieldSelector(e exprDesc) exprDesc {\n\te = p.function.ExpressionToAnyRegisterOrUpValue(e)\n\tp.next() // skip dot or colon\n\treturn p.function.Indexed(e, p.checkNameAsExpression())\n}\n\nfunc (p *parser) index() exprDesc {\n\tp.next() // skip '['\n\te := p.function.ExpressionToValue(p.expression())\n\tp.checkNext(']')\n\treturn e\n}\n\nfunc (p *parser) assignment(t *assignmentTarget, variableCount int) {\n\tif p.checkCondition(t.isVariable(), \"syntax error\"); p.testNext(',') {\n\t\te := p.suffixedExpression()\n\t\tif e.kind != kindIndexed {\n\t\t\tp.function.CheckConflict(t, e)\n\t\t}\n\t\tp.checkLimit(variableCount+p.l.nestedGoCallCount, maxCallCount, \"Go levels\")\n\t\tp.assignment(&assignmentTarget{previous: t, exprDesc: e}, variableCount+1)\n\t} else {\n\t\tp.checkNext('=')\n\t\tif e, n := p.expressionList(); n != variableCount {\n\t\t\tif p.function.AdjustAssignment(variableCount, n, e); n > variableCount {\n\t\t\t\tp.function.freeRegisterCount -= n - variableCount // remove extra values\n\t\t\t}\n\t\t} else {\n\t\t\tp.function.StoreVariable(t.exprDesc, p.function.SetReturn(e))\n\t\t\treturn // avoid default\n\t\t}\n\t}\n\tp.function.StoreVariable(t.exprDesc, makeExpression(kindNonRelocatable, p.function.freeRegisterCount-1))\n}\n\nfunc (p *parser) forBody(base, line, n int, isNumeric bool) {\n\tp.function.AdjustLocalVariables(3)\n\tp.checkNext(tkDo)\n\tprep := p.function.OpenForBody(base, n, isNumeric)\n\tp.block()\n\tp.function.CloseForBody(prep, base, line, n, isNumeric)\n}\n\nfunc (p *parser) forNumeric(name string, line int) {\n\texpr := func() { p.assert(p.function.ExpressionToNextRegister(p.expression()).kind == kindNonRelocatable) }\n\tbase := p.function.freeRegisterCount\n\tp.function.MakeLocalVariable(\"(for index)\")\n\tp.function.MakeLocalVariable(\"(for limit)\")\n\tp.function.MakeLocalVariable(\"(for step)\")\n\tp.function.MakeLocalVariable(name)\n\tp.checkNext('=')\n\texpr()\n\tp.checkNext(',')\n\texpr()\n\tif p.testNext(',') {\n\t\texpr()\n\t} else {\n\t\tp.function.EncodeConstant(p.function.freeRegisterCount, p.function.NumberConstant(1))\n\t\tp.function.ReserveRegisters(1)\n\t}\n\tp.forBody(base, line, 1, true)\n}\n\nfunc (p *parser) forList(name string) {\n\tn, base := 4, p.function.freeRegisterCount\n\tp.function.MakeLocalVariable(\"(for generator)\")\n\tp.function.MakeLocalVariable(\"(for state)\")\n\tp.function.MakeLocalVariable(\"(for control)\")\n\tp.function.MakeLocalVariable(name)\n\tfor ; p.testNext(','); n++ {\n\t\tp.function.MakeLocalVariable(p.checkName())\n\t}\n\tp.checkNext(tkIn)\n\tline := p.lineNumber\n\te, c := p.expressionList()\n\tp.function.AdjustAssignment(3, c, e)\n\tp.function.CheckStack(3)\n\tp.forBody(base, line, n-3, false)\n}\n\nfunc (p *parser) forStatement(line int) {\n\tp.function.EnterBlock(true)\n\tp.next()\n\tswitch name := p.checkName(); p.t {\n\tcase '=':\n\t\tp.forNumeric(name, line)\n\tcase ',', tkIn:\n\t\tp.forList(name)\n\tdefault:\n\t\tp.syntaxError(\"'=' or 'in' expected\")\n\t}\n\tp.checkMatch(tkEnd, tkFor, line)\n\tp.function.LeaveBlock()\n}\n\nfunc (p *parser) testThenBlock(escapes int) int {\n\tvar jumpFalse int\n\tp.next()\n\te := p.expression()\n\tp.checkNext(tkThen)\n\tif p.t == tkGoto || p.t == tkBreak {\n\t\te = p.function.GoIfFalse(e)\n\t\tp.function.EnterBlock(false)\n\t\tp.gotoStatement(e.t)\n\t\tp.skipEmptyStatements()\n\t\tif p.blockFollow(false) {\n\t\t\tp.function.LeaveBlock()\n\t\t\treturn escapes\n\t\t}\n\t\tjumpFalse = p.function.Jump()\n\t} else {\n\t\te = p.function.GoIfTrue(e)\n\t\tp.function.EnterBlock(false)\n\t\tjumpFalse = e.f\n\t}\n\tp.statementList()\n\tp.function.LeaveBlock()\n\tif p.t == tkElse || p.t == tkElseif {\n\t\tescapes = p.function.Concatenate(escapes, p.function.Jump())\n\t}\n\tp.function.PatchToHere(jumpFalse)\n\treturn escapes\n}\n\nfunc (p *parser) ifStatement(line int) {\n\tescapes := p.testThenBlock(noJump)\n\tfor p.t == tkElseif {\n\t\tescapes = p.testThenBlock(escapes)\n\t}\n\tif p.testNext(tkElse) {\n\t\tp.block()\n\t}\n\tp.checkMatch(tkEnd, tkIf, line)\n\tp.function.PatchToHere(escapes)\n}\n\nfunc (p *parser) block() {\n\tp.function.EnterBlock(false)\n\tp.statementList()\n\tp.function.LeaveBlock()\n}\n\nfunc (p *parser) whileStatement(line int) {\n\tp.next()\n\ttop, conditionExit := p.function.Label(), p.condition()\n\tp.function.EnterBlock(true)\n\tp.checkNext(tkDo)\n\tp.block()\n\tp.function.JumpTo(top)\n\tp.checkMatch(tkEnd, tkWhile, line)\n\tp.function.LeaveBlock()\n\tp.function.PatchToHere(conditionExit) // false conditions finish the loop\n}\n\nfunc (p *parser) repeatStatement(line int) {\n\ttop := p.function.Label()\n\tp.function.EnterBlock(true)  // loop block\n\tp.function.EnterBlock(false) // scope block\n\tp.next()\n\tp.statementList()\n\tp.checkMatch(tkUntil, tkRepeat, line)\n\tconditionExit := p.condition()\n\tif p.function.block.hasUpValue {\n\t\tp.function.PatchClose(conditionExit, p.function.block.activeVariableCount)\n\t}\n\tp.function.LeaveBlock()                  // finish scope\n\tp.function.PatchList(conditionExit, top) // close loop\n\tp.function.LeaveBlock()                  // finish loop\n}\n\nfunc (p *parser) condition() int {\n\te := p.expression()\n\tif e.kind == kindNil {\n\t\te.kind = kindFalse\n\t}\n\treturn p.function.GoIfTrue(e).f\n}\n\nfunc (p *parser) gotoStatement(pc int) {\n\tif line := p.lineNumber; p.testNext(tkGoto) {\n\t\tp.function.MakeGoto(p.checkName(), line, pc)\n\t} else {\n\t\tp.next()\n\t\tp.function.MakeGoto(\"break\", line, pc)\n\t}\n}\n\nfunc (p *parser) skipEmptyStatements() {\n\tfor p.t == ';' || p.t == tkDoubleColon {\n\t\tp.statement()\n\t}\n}\n\nfunc (p *parser) labelStatement(label string, line int) {\n\tp.function.CheckRepeatedLabel(label)\n\tp.checkNext(tkDoubleColon)\n\tl := p.function.MakeLabel(label, line)\n\tp.skipEmptyStatements()\n\tif p.blockFollow(false) {\n\t\tp.activeLabels[l].activeVariableCount = p.function.block.activeVariableCount\n\t}\n\tp.function.FindGotos(l)\n}\n\nfunc (p *parser) parameterList() {\n\tn, isVarArg := 0, false\n\tif p.t != ')' {\n\t\tfor first := true; first || (!isVarArg && p.testNext(',')); first = false {\n\t\t\tswitch p.t {\n\t\t\tcase tkName:\n\t\t\t\tp.function.MakeLocalVariable(p.checkName())\n\t\t\t\tn++\n\t\t\tcase tkDots:\n\t\t\t\tp.next()\n\t\t\t\tisVarArg = true\n\t\t\tdefault:\n\t\t\t\tp.syntaxError(\"<name> or '...' expected\")\n\t\t\t}\n\t\t}\n\t}\n\t// TODO the following lines belong in a *function method\n\tp.function.f.isVarArg = isVarArg\n\tp.function.AdjustLocalVariables(n)\n\tp.function.f.parameterCount = p.function.activeVariableCount\n\tp.function.ReserveRegisters(p.function.activeVariableCount)\n}\n\nfunc (p *parser) body(isMethod bool, line int) exprDesc {\n\tp.function.OpenFunction(line)\n\tp.checkNext('(')\n\tif isMethod {\n\t\tp.function.MakeLocalVariable(\"self\")\n\t\tp.function.AdjustLocalVariables(1)\n\t}\n\tp.parameterList()\n\tp.checkNext(')')\n\tp.statementList()\n\tp.function.f.lastLineDefined = p.lineNumber\n\tp.checkMatch(tkEnd, tkFunction, line)\n\treturn p.function.CloseFunction()\n}\n\nfunc (p *parser) functionName() (e exprDesc, isMethod bool) {\n\tfor e = p.singleVariable(); p.t == '.'; e = p.fieldSelector(e) {\n\t}\n\tif p.t == ':' {\n\t\te, isMethod = p.fieldSelector(e), true\n\t}\n\treturn\n}\n\nfunc (p *parser) functionStatement(line int) {\n\tp.next()\n\tv, m := p.functionName()\n\tp.function.StoreVariable(v, p.body(m, line))\n\tp.function.FixLine(line)\n}\n\nfunc (p *parser) localFunction() {\n\tp.function.MakeLocalVariable(p.checkName())\n\tp.function.AdjustLocalVariables(1)\n\tp.function.LocalVariable(p.body(false, p.lineNumber).info).startPC = pc(len(p.function.f.code))\n}\n\nfunc (p *parser) localStatement() {\n\tv := 0\n\tfor first := true; first || p.testNext(','); v++ {\n\t\tp.function.MakeLocalVariable(p.checkName())\n\t\tfirst = false\n\t}\n\tif p.testNext('=') {\n\t\te, n := p.expressionList()\n\t\tp.function.AdjustAssignment(v, n, e)\n\t} else {\n\t\tvar e exprDesc\n\t\tp.function.AdjustAssignment(v, 0, e)\n\t}\n\tp.function.AdjustLocalVariables(v)\n}\n\nfunc (p *parser) expressionStatement() {\n\tif e := p.suffixedExpression(); p.t == '=' || p.t == ',' {\n\t\tp.assignment(&assignmentTarget{exprDesc: e}, 1)\n\t} else {\n\t\tp.checkCondition(e.kind == kindCall, \"syntax error\")\n\t\tp.function.Instruction(e).setC(1) // call statement uses no results\n\t}\n}\n\nfunc (p *parser) returnStatement() {\n\tif f := p.function; p.blockFollow(true) || p.t == ';' {\n\t\tf.ReturnNone()\n\t} else {\n\t\tf.Return(p.expressionList())\n\t}\n\tp.testNext(';')\n}\n\nfunc (p *parser) statement() {\n\tline := p.lineNumber\n\tp.enterLevel()\n\tswitch p.t {\n\tcase ';':\n\t\tp.next()\n\tcase tkIf:\n\t\tp.ifStatement(line)\n\tcase tkWhile:\n\t\tp.whileStatement(line)\n\tcase tkDo:\n\t\tp.next()\n\t\tp.block()\n\t\tp.checkMatch(tkEnd, tkDo, line)\n\tcase tkFor:\n\t\tp.forStatement(line)\n\tcase tkRepeat:\n\t\tp.repeatStatement(line)\n\tcase tkFunction:\n\t\tp.functionStatement(line)\n\tcase tkLocal:\n\t\tp.next()\n\t\tif p.testNext(tkFunction) {\n\t\t\tp.localFunction()\n\t\t} else {\n\t\t\tp.localStatement()\n\t\t}\n\tcase tkDoubleColon:\n\t\tp.next()\n\t\tp.labelStatement(p.checkName(), line)\n\tcase tkReturn:\n\t\tp.next()\n\t\tp.returnStatement()\n\tcase tkBreak, tkGoto:\n\t\tp.gotoStatement(p.function.Jump())\n\tdefault:\n\t\tp.expressionStatement()\n\t}\n\tp.assert(p.function.f.maxStackSize >= p.function.freeRegisterCount && p.function.freeRegisterCount >= p.function.activeVariableCount)\n\tp.function.freeRegisterCount = p.function.activeVariableCount\n\tp.leaveLevel()\n}\n\nfunc (p *parser) mainFunction() {\n\tp.function.OpenMainFunction()\n\tp.next()\n\tp.statementList()\n\tp.check(tkEOS)\n\tp.function = p.function.CloseMainFunction()\n}\n\nfunc (l *State) parse(r io.ByteReader, name string) *luaClosure {\n\tp := &parser{scanner: scanner{r: r, lineNumber: 1, lastLine: 1, lookAheadToken: token{t: tkEOS}, l: l, source: name}}\n\tf := &function{f: &prototype{source: name, maxStackSize: 2, isVarArg: true}, constantLookup: make(map[value]int), p: p, jumpPC: noJump}\n\tp.function = f\n\tp.mainFunction()\n\t// TODO assertions about parser state\n\tc := l.newLuaClosure(f.f)\n\tl.push(c)\n\treturn c\n}\n\nfunc (l *State) checkMode(mode, x string) {\n\tif mode != \"\" && !strings.Contains(mode, x[:1]) {\n\t\tl.push(fmt.Sprintf(\"attempt to load a %s chunk (mode is '%s')\", x, mode))\n\t\tl.throw(SyntaxError)\n\t}\n}\n\nfunc protectedParser(l *State, r io.Reader, name, chunkMode string) error {\n\tl.nonYieldableCallCount++\n\terr := l.protectedCall(func() {\n\t\tvar closure *luaClosure\n\t\tb := bufio.NewReader(r)\n\t\tif c, err := b.ReadByte(); err != nil {\n\t\t\tl.checkMode(chunkMode, \"text\")\n\t\t\tclosure = l.parse(b, name)\n\t\t} else if c == Signature[0] {\n\t\t\tl.checkMode(chunkMode, \"binary\")\n\t\t\tb.UnreadByte()\n\t\t\tclosure, _ = l.undump(b, name) // TODO handle err\n\t\t} else {\n\t\t\tl.checkMode(chunkMode, \"text\")\n\t\t\tb.UnreadByte()\n\t\t\tclosure = l.parse(b, name)\n\t\t}\n\t\tl.assert(closure.upValueCount() == len(closure.prototype.upValues))\n\t\tfor i := range closure.upValues {\n\t\t\tclosure.upValues[i] = l.newUpValue()\n\t\t}\n\t}, l.top, l.errorFunction)\n\tl.nonYieldableCallCount--\n\treturn err\n}\n"
        },
        {
          "name": "parser_test.go",
          "type": "blob",
          "size": 4.0185546875,
          "content": "package lua\n\nimport (\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc load(l *State, t *testing.T, fileName string) *luaClosure {\n\tif err := LoadFile(l, fileName, \"bt\"); err != nil {\n\t\treturn nil\n\t}\n\treturn l.ToValue(-1).(*luaClosure)\n}\n\nfunc TestParser(t *testing.T) {\n\tl := NewState()\n\tOpenLibraries(l)\n\tbin := load(l, t, \"fixtures/fib.bin\")\n\tl.Pop(1)\n\tclosure := load(l, t, \"fixtures/fib.lua\")\n\tp := closure.prototype\n\tif p == nil {\n\t\tt.Fatal(\"prototype was nil\")\n\t}\n\tvalidate(\"@fixtures/fib.lua\", p.source, \"as source file name\", t)\n\tif !p.isVarArg {\n\t\tt.Error(\"expected main function to be var arg, but wasn't\")\n\t}\n\tif len(closure.upValues) != len(closure.prototype.upValues) {\n\t\tt.Error(\"upvalue count doesn't match\", len(closure.upValues), \"!=\", len(closure.prototype.upValues))\n\t}\n\tcompareClosures(t, bin, closure)\n\tl.Call(0, 0)\n}\n\nfunc TestEmptyString(t *testing.T) {\n\tl := NewState()\n\tif err := LoadString(l, \"\"); err != nil {\n\t\tt.Fatal(err.Error())\n\t}\n\tl.Call(0, 0)\n}\n\nfunc TestParserExhaustively(t *testing.T) {\n\t_, err := exec.LookPath(\"luac\")\n\tif err != nil {\n\t\tt.Skipf(\"exhaustively testing the parser requires luac: %s\", err)\n\t}\n\tl := NewState()\n\tmatches, err := filepath.Glob(filepath.Join(\"lua-tests\", \"*.lua\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tblackList := map[string]bool{\"math.lua\": true}\n\tfor _, source := range matches {\n\t\tif _, ok := blackList[filepath.Base(source)]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tprotectedTestParser(l, t, source)\n\t}\n}\n\nfunc protectedTestParser(l *State, t *testing.T, source string) {\n\tdefer func() {\n\t\tif x := recover(); x != nil {\n\t\t\tt.Error(x)\n\t\t\tt.Log(string(debug.Stack()))\n\t\t}\n\t}()\n\tt.Log(\"Compiling \" + source)\n\tbinary := strings.TrimSuffix(source, \".lua\") + \".bin\"\n\tif err := exec.Command(\"luac\", \"-o\", binary, source).Run(); err != nil {\n\t\tt.Fatalf(\"luac failed to compile %s: %s\", source, err)\n\t}\n\tt.Log(\"Parsing \" + source)\n\tbin := load(l, t, binary)\n\tl.Pop(1)\n\tsrc := load(l, t, source)\n\tl.Pop(1)\n\tt.Log(source)\n\tcompareClosures(t, src, bin)\n}\n\nfunc expectEqual(t *testing.T, x, y interface{}, m string) {\n\tif x != y {\n\t\tt.Errorf(\"%s doesn't match: %v, %v\\n\", m, x, y)\n\t}\n}\n\nfunc expectDeepEqual(t *testing.T, x, y interface{}, m string) bool {\n\tif reflect.DeepEqual(x, y) {\n\t\treturn true\n\t}\n\tif reflect.TypeOf(x).Kind() == reflect.Slice && reflect.ValueOf(y).Len() == 0 && reflect.ValueOf(x).Len() == 0 {\n\t\treturn true\n\t}\n\tt.Errorf(\"%s doesn't match: %v, %v\\n\", m, x, y)\n\treturn false\n}\n\nfunc compareClosures(t *testing.T, a, b *luaClosure) {\n\texpectEqual(t, a.upValueCount(), b.upValueCount(), \"upvalue count\")\n\tcomparePrototypes(t, a.prototype, b.prototype)\n}\n\nfunc comparePrototypes(t *testing.T, a, b *prototype) {\n\texpectEqual(t, a.isVarArg, b.isVarArg, \"var arg\")\n\texpectEqual(t, a.lineDefined, b.lineDefined, \"line defined\")\n\texpectEqual(t, a.lastLineDefined, b.lastLineDefined, \"last line defined\")\n\texpectEqual(t, a.parameterCount, b.parameterCount, \"parameter count\")\n\texpectEqual(t, a.maxStackSize, b.maxStackSize, \"max stack size\")\n\texpectEqual(t, a.source, b.source, \"source\")\n\texpectEqual(t, len(a.code), len(b.code), \"code length\")\n\tif !expectDeepEqual(t, a.code, b.code, \"code\") {\n\t\tfor i := range a.code {\n\t\t\tif a.code[i] != b.code[i] {\n\t\t\t\tt.Errorf(\"%d: %v != %v\\n\", a.lineInfo[i], a.code[i], b.code[i])\n\t\t\t}\n\t\t}\n\t\tfor _, i := range []int{3, 197, 198, 199, 200, 201} {\n\t\t\tt.Errorf(\"%d: %#v, %#v\\n\", i, a.constants[i], b.constants[i])\n\t\t}\n\t\tfor _, i := range []int{202, 203, 204} {\n\t\t\tt.Errorf(\"%d: %#v\\n\", i, b.constants[i])\n\t\t}\n\t}\n\tif !expectDeepEqual(t, a.constants, b.constants, \"constants\") {\n\t\tfor i := range a.constants {\n\t\t\tif a.constants[i] != b.constants[i] {\n\t\t\t\tt.Errorf(\"%d: %#v != %#v\\n\", i, a.constants[i], b.constants[i])\n\t\t\t}\n\t\t}\n\t}\n\texpectDeepEqual(t, a.lineInfo, b.lineInfo, \"line info\")\n\texpectDeepEqual(t, a.upValues, b.upValues, \"upvalues\")\n\texpectDeepEqual(t, a.localVariables, b.localVariables, \"local variables\")\n\texpectEqual(t, len(a.prototypes), len(b.prototypes), \"prototypes length\")\n\tfor i := range a.prototypes {\n\t\tcomparePrototypes(t, &a.prototypes[i], &b.prototypes[i])\n\t}\n}\n"
        },
        {
          "name": "scanner.go",
          "type": "blob",
          "size": 11.3203125,
          "content": "package lua\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nconst firstReserved = 257\nconst endOfStream = -1\nconst maxInt = int(^uint(0) >> 1)\n\nconst (\n\ttkAnd = iota + firstReserved\n\ttkBreak\n\ttkDo\n\ttkElse\n\ttkElseif\n\ttkEnd\n\ttkFalse\n\ttkFor\n\ttkFunction\n\ttkGoto\n\ttkIf\n\ttkIn\n\ttkLocal\n\ttkNil\n\ttkNot\n\ttkOr\n\ttkRepeat\n\ttkReturn\n\ttkThen\n\ttkTrue\n\ttkUntil\n\ttkWhile\n\ttkConcat\n\ttkDots\n\ttkEq\n\ttkGE\n\ttkLE\n\ttkNE\n\ttkDoubleColon\n\ttkEOS\n\ttkNumber\n\ttkName\n\ttkString\n\treservedCount = tkWhile - firstReserved + 1\n)\n\nvar tokens []string = []string{\n\t\"and\", \"break\", \"do\", \"else\", \"elseif\",\n\t\"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n\t\"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n\t\"return\", \"then\", \"true\", \"until\", \"while\",\n\t\"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\", \"::\", \"<eof>\",\n\t\"<number>\", \"<name>\", \"<string>\",\n}\n\ntype token struct {\n\tt rune\n\tn float64\n\ts string\n}\n\ntype scanner struct {\n\tl                    *State\n\tbuffer               bytes.Buffer\n\tr                    io.ByteReader\n\tcurrent              rune\n\tlineNumber, lastLine int\n\tsource               string\n\tlookAheadToken       token\n\ttoken\n}\n\nfunc (s *scanner) assert(cond bool)           { s.l.assert(cond) }\nfunc (s *scanner) syntaxError(message string) { s.scanError(message, s.t) }\nfunc (s *scanner) errorExpected(t rune)       { s.syntaxError(s.tokenToString(t) + \" expected\") }\nfunc (s *scanner) numberError()               { s.scanError(\"malformed number\", tkNumber) }\nfunc isNewLine(c rune) bool                   { return c == '\\n' || c == '\\r' }\nfunc isDecimal(c rune) bool                   { return '0' <= c && c <= '9' }\n\nfunc (s *scanner) tokenToString(t rune) string {\n\tswitch {\n\tcase t == tkName || t == tkString:\n\t\treturn s.s\n\tcase t == tkNumber:\n\t\treturn fmt.Sprintf(\"%f\", s.n)\n\tcase t < firstReserved:\n\t\treturn string(t) // TODO check for printable rune\n\tcase t < tkEOS:\n\t\treturn fmt.Sprintf(\"'%s'\", tokens[t-firstReserved])\n\t}\n\treturn tokens[t-firstReserved]\n}\n\nfunc (s *scanner) scanError(message string, token rune) {\n\tbuff := chunkID(s.source)\n\tif token != 0 {\n\t\tmessage = fmt.Sprintf(\"%s:%d: %s near %s\", buff, s.lineNumber, message, s.tokenToString(token))\n\t} else {\n\t\tmessage = fmt.Sprintf(\"%s:%d: %s\", buff, s.lineNumber, message)\n\t}\n\ts.l.push(message)\n\ts.l.throw(SyntaxError)\n}\n\nfunc (s *scanner) incrementLineNumber() {\n\told := s.current\n\ts.assert(isNewLine(old))\n\tif s.advance(); isNewLine(s.current) && s.current != old {\n\t\ts.advance()\n\t}\n\tif s.lineNumber++; s.lineNumber >= maxInt {\n\t\ts.syntaxError(\"chunk has too many lines\")\n\t}\n}\n\nfunc (s *scanner) advance() {\n\tif c, err := s.r.ReadByte(); err != nil {\n\t\ts.current = endOfStream\n\t} else {\n\t\ts.current = rune(c)\n\t}\n}\n\nfunc (s *scanner) saveAndAdvance() {\n\ts.save(s.current)\n\ts.advance()\n}\n\nfunc (s *scanner) advanceAndSave(c rune) {\n\ts.advance()\n\ts.save(c)\n}\n\nfunc (s *scanner) save(c rune) {\n\tif err := s.buffer.WriteByte(byte(c)); err != nil {\n\t\ts.scanError(\"lexical element too long\", 0)\n\t}\n}\n\nfunc (s *scanner) checkNext(str string) bool {\n\tif s.current == 0 || !strings.ContainsRune(str, s.current) {\n\t\treturn false\n\t}\n\ts.saveAndAdvance()\n\treturn true\n}\n\nfunc (s *scanner) skipSeparator() int { // TODO is this the right name?\n\ti, c := 0, s.current\n\ts.assert(c == '[' || c == ']')\n\tfor s.saveAndAdvance(); s.current == '='; i++ {\n\t\ts.saveAndAdvance()\n\t}\n\tif s.current == c {\n\t\treturn i\n\t}\n\treturn -i - 1\n}\n\nfunc (s *scanner) readMultiLine(comment bool, sep int) (str string) {\n\tif s.saveAndAdvance(); isNewLine(s.current) {\n\t\ts.incrementLineNumber()\n\t}\n\tfor {\n\t\tswitch s.current {\n\t\tcase endOfStream:\n\t\t\tif comment {\n\t\t\t\ts.scanError(\"unfinished long comment\", tkEOS)\n\t\t\t} else {\n\t\t\t\ts.scanError(\"unfinished long string\", tkEOS)\n\t\t\t}\n\t\tcase ']':\n\t\t\tif s.skipSeparator() == sep {\n\t\t\t\ts.saveAndAdvance()\n\t\t\t\tif !comment {\n\t\t\t\t\tstr = s.buffer.String()\n\t\t\t\t\tstr = str[2+sep : len(str)-(2+sep)]\n\t\t\t\t}\n\t\t\t\ts.buffer.Reset()\n\t\t\t\treturn\n\t\t\t}\n\t\tcase '\\r':\n\t\t\ts.current = '\\n'\n\t\t\tfallthrough\n\t\tcase '\\n':\n\t\t\ts.save(s.current)\n\t\t\ts.incrementLineNumber()\n\t\tdefault:\n\t\t\tif !comment {\n\t\t\t\ts.save(s.current)\n\t\t\t}\n\t\t\ts.advance()\n\t\t}\n\t}\n}\n\nfunc (s *scanner) readDigits() (c rune) {\n\tfor c = s.current; isDecimal(c); c = s.current {\n\t\ts.saveAndAdvance()\n\t}\n\treturn\n}\n\nfunc isHexadecimal(c rune) bool {\n\treturn '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F'\n}\n\nfunc (s *scanner) readHexNumber(x float64) (n float64, c rune, i int) {\n\tif c, n = s.current, x; !isHexadecimal(c) {\n\t\treturn\n\t}\n\tfor {\n\t\tswitch {\n\t\tcase '0' <= c && c <= '9':\n\t\t\tc = c - '0'\n\t\tcase 'a' <= c && c <= 'f':\n\t\t\tc = c - 'a' + 10\n\t\tcase 'A' <= c && c <= 'F':\n\t\t\tc = c - 'A' + 10\n\t\tdefault:\n\t\t\treturn\n\t\t}\n\t\ts.advance()\n\t\tc, n, i = s.current, n*16.0+float64(c), i+1\n\t}\n}\n\nfunc (s *scanner) readNumber() token {\n\tconst bits64, base10 = 64, 10\n\tc := s.current\n\ts.assert(isDecimal(c))\n\ts.saveAndAdvance()\n\tif c == '0' && s.checkNext(\"Xx\") { // hexadecimal\n\t\tprefix := s.buffer.String()\n\t\ts.assert(prefix == \"0x\" || prefix == \"0X\")\n\t\ts.buffer.Reset()\n\t\tvar exponent int\n\t\tfraction, c, i := s.readHexNumber(0)\n\t\tif c == '.' {\n\t\t\ts.advance()\n\t\t\tfraction, c, exponent = s.readHexNumber(fraction)\n\t\t}\n\t\tif i == 0 && exponent == 0 {\n\t\t\ts.numberError()\n\t\t}\n\t\texponent *= -4\n\t\tif c == 'p' || c == 'P' {\n\t\t\ts.advance()\n\t\t\tvar negativeExponent bool\n\t\t\tif c = s.current; c == '+' || c == '-' {\n\t\t\t\tnegativeExponent = c == '-'\n\t\t\t\ts.advance()\n\t\t\t}\n\t\t\tif !isDecimal(s.current) {\n\t\t\t\ts.numberError()\n\t\t\t}\n\t\t\t_ = s.readDigits()\n\t\t\tif e, err := strconv.ParseInt(s.buffer.String(), base10, bits64); err != nil {\n\t\t\t\ts.numberError()\n\t\t\t} else if negativeExponent {\n\t\t\t\texponent += int(-e)\n\t\t\t} else {\n\t\t\t\texponent += int(e)\n\t\t\t}\n\t\t\ts.buffer.Reset()\n\t\t}\n\t\treturn token{t: tkNumber, n: math.Ldexp(fraction, exponent)}\n\t}\n\tc = s.readDigits()\n\tif c == '.' {\n\t\ts.saveAndAdvance()\n\t\tc = s.readDigits()\n\t}\n\tif c == 'e' || c == 'E' {\n\t\ts.saveAndAdvance()\n\t\tif c = s.current; c == '+' || c == '-' {\n\t\t\ts.saveAndAdvance()\n\t\t}\n\t\t_ = s.readDigits()\n\t}\n\tstr := s.buffer.String()\n\tif strings.HasPrefix(str, \"0\") {\n\t\tif str = strings.TrimLeft(str, \"0\"); str == \"\" || !isDecimal(rune(str[0])) {\n\t\t\tstr = \"0\" + str\n\t\t}\n\t}\n\tf, err := strconv.ParseFloat(str, bits64)\n\tif err != nil {\n\t\ts.numberError()\n\t}\n\ts.buffer.Reset()\n\treturn token{t: tkNumber, n: f}\n}\n\nvar escapes map[rune]rune = map[rune]rune{\n\t'a': '\\a', 'b': '\\b', 'f': '\\f', 'n': '\\n', 'r': '\\r', 't': '\\t', 'v': '\\v', '\\\\': '\\\\', '\"': '\"', '\\'': '\\'',\n}\n\nfunc (s *scanner) escapeError(c []rune, message string) {\n\ts.buffer.Reset()\n\ts.save('\\\\')\n\tfor _, r := range c {\n\t\tif r == endOfStream {\n\t\t\tbreak\n\t\t}\n\t\ts.save(r)\n\t}\n\ts.scanError(message, tkString)\n}\n\nfunc (s *scanner) readHexEscape() (r rune) {\n\ts.advance()\n\tfor i, c, b := 1, s.current, [3]rune{'x'}; i < len(b); i, c, r = i+1, s.current, r<<4+c {\n\t\tswitch b[i] = c; {\n\t\tcase '0' <= c && c <= '9':\n\t\t\tc = c - '0'\n\t\tcase 'a' <= c && c <= 'f':\n\t\t\tc = c - 'a' + 10\n\t\tcase 'A' <= c && c <= 'F':\n\t\t\tc = c - 'A' + 10\n\t\tdefault:\n\t\t\ts.escapeError(b[:i+1], \"hexadecimal digit expected\")\n\t\t}\n\t\ts.advance()\n\t}\n\treturn\n}\n\nfunc (s *scanner) readDecimalEscape() (r rune) {\n\tb := [3]rune{}\n\tfor c, i := s.current, 0; i < len(b) && isDecimal(c); i, c = i+1, s.current {\n\t\tb[i], r = c, 10*r+c-'0'\n\t\ts.advance()\n\t}\n\tif r > math.MaxUint8 {\n\t\ts.escapeError(b[:], \"decimal escape too large\")\n\t}\n\treturn\n}\n\nfunc (s *scanner) readString() token {\n\tdelimiter := s.current\n\tfor s.saveAndAdvance(); s.current != delimiter; {\n\t\tswitch s.current {\n\t\tcase endOfStream:\n\t\t\ts.scanError(\"unfinished string\", tkEOS)\n\t\tcase '\\n', '\\r':\n\t\t\ts.scanError(\"unfinished string\", tkString)\n\t\tcase '\\\\':\n\t\t\ts.advance()\n\t\t\tc := s.current\n\t\t\tswitch esc, ok := escapes[c]; {\n\t\t\tcase ok:\n\t\t\t\ts.advanceAndSave(esc)\n\t\t\tcase isNewLine(c):\n\t\t\t\ts.incrementLineNumber()\n\t\t\t\ts.save('\\n')\n\t\t\tcase c == endOfStream: // do nothing\n\t\t\tcase c == 'x':\n\t\t\t\ts.save(s.readHexEscape())\n\t\t\tcase c == 'z':\n\t\t\t\tfor s.advance(); unicode.IsSpace(s.current); {\n\t\t\t\t\tif isNewLine(s.current) {\n\t\t\t\t\t\ts.incrementLineNumber()\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts.advance()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif !isDecimal(c) {\n\t\t\t\t\ts.escapeError([]rune{c}, \"invalid escape sequence\")\n\t\t\t\t}\n\t\t\t\ts.save(s.readDecimalEscape())\n\t\t\t}\n\t\tdefault:\n\t\t\ts.saveAndAdvance()\n\t\t}\n\t}\n\ts.saveAndAdvance()\n\tstr := s.buffer.String()\n\ts.buffer.Reset()\n\treturn token{t: tkString, s: str[1 : len(str)-1]}\n}\n\nfunc isReserved(s string) bool {\n\tfor _, reserved := range tokens[:reservedCount] {\n\t\tif s == reserved {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *scanner) reservedOrName() token {\n\tstr := s.buffer.String()\n\ts.buffer.Reset()\n\tfor i, reserved := range tokens[:reservedCount] {\n\t\tif str == reserved {\n\t\t\treturn token{t: rune(i + firstReserved), s: reserved}\n\t\t}\n\t}\n\treturn token{t: tkName, s: str}\n}\n\nfunc (s *scanner) scan() token {\n\tconst comment, str = true, false\n\tfor {\n\t\tswitch c := s.current; c {\n\t\tcase '\\n', '\\r':\n\t\t\ts.incrementLineNumber()\n\t\tcase ' ', '\\f', '\\t', '\\v':\n\t\t\ts.advance()\n\t\tcase '-':\n\t\t\tif s.advance(); s.current != '-' {\n\t\t\t\treturn token{t: '-'}\n\t\t\t}\n\t\t\tif s.advance(); s.current == '[' {\n\t\t\t\tif sep := s.skipSeparator(); sep >= 0 {\n\t\t\t\t\t_ = s.readMultiLine(comment, sep)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ts.buffer.Reset()\n\t\t\t}\n\t\t\tfor !isNewLine(s.current) && s.current != endOfStream {\n\t\t\t\ts.advance()\n\t\t\t}\n\t\tcase '[':\n\t\t\tif sep := s.skipSeparator(); sep >= 0 {\n\t\t\t\treturn token{t: tkString, s: s.readMultiLine(str, sep)}\n\t\t\t} else if s.buffer.Reset(); sep == -1 {\n\t\t\t\treturn token{t: '['}\n\t\t\t}\n\t\t\ts.scanError(\"invalid long string delimiter\", tkString)\n\t\tcase '=':\n\t\t\tif s.advance(); s.current != '=' {\n\t\t\t\treturn token{t: '='}\n\t\t\t}\n\t\t\ts.advance()\n\t\t\treturn token{t: tkEq}\n\t\tcase '<':\n\t\t\tif s.advance(); s.current != '=' {\n\t\t\t\treturn token{t: '<'}\n\t\t\t}\n\t\t\ts.advance()\n\t\t\treturn token{t: tkLE}\n\t\tcase '>':\n\t\t\tif s.advance(); s.current != '=' {\n\t\t\t\treturn token{t: '>'}\n\t\t\t}\n\t\t\ts.advance()\n\t\t\treturn token{t: tkGE}\n\t\tcase '~':\n\t\t\tif s.advance(); s.current != '=' {\n\t\t\t\treturn token{t: '~'}\n\t\t\t}\n\t\t\ts.advance()\n\t\t\treturn token{t: tkNE}\n\t\tcase ':':\n\t\t\tif s.advance(); s.current != ':' {\n\t\t\t\treturn token{t: ':'}\n\t\t\t}\n\t\t\ts.advance()\n\t\t\treturn token{t: tkDoubleColon}\n\t\tcase '\"', '\\'':\n\t\t\treturn s.readString()\n\t\tcase endOfStream:\n\t\t\treturn token{t: tkEOS}\n\t\tcase '.':\n\t\t\tif s.saveAndAdvance(); s.checkNext(\".\") {\n\t\t\t\tif s.checkNext(\".\") {\n\t\t\t\t\ts.buffer.Reset()\n\t\t\t\t\treturn token{t: tkDots}\n\t\t\t\t}\n\t\t\t\ts.buffer.Reset()\n\t\t\t\treturn token{t: tkConcat}\n\t\t\t} else if !unicode.IsDigit(s.current) {\n\t\t\t\ts.buffer.Reset()\n\t\t\t\treturn token{t: '.'}\n\t\t\t} else {\n\t\t\t\treturn s.readNumber()\n\t\t\t}\n\t\tcase 0:\n\t\t\ts.advance()\n\t\tdefault:\n\t\t\tif unicode.IsDigit(c) {\n\t\t\t\treturn s.readNumber()\n\t\t\t} else if c == '_' || unicode.IsLetter(c) {\n\t\t\t\tfor ; c == '_' || unicode.IsLetter(c) || unicode.IsDigit(c); c = s.current {\n\t\t\t\t\ts.saveAndAdvance()\n\t\t\t\t}\n\t\t\t\treturn s.reservedOrName()\n\t\t\t}\n\t\t\ts.advance()\n\t\t\treturn token{t: c}\n\t\t}\n\t}\n}\n\nfunc (s *scanner) next() {\n\ts.lastLine = s.lineNumber\n\tif s.lookAheadToken.t != tkEOS {\n\t\ts.token = s.lookAheadToken\n\t\ts.lookAheadToken.t = tkEOS\n\t} else {\n\t\ts.token = s.scan()\n\t}\n}\n\nfunc (s *scanner) lookAhead() rune {\n\ts.l.assert(s.lookAheadToken.t == tkEOS)\n\ts.lookAheadToken = s.scan()\n\treturn s.lookAheadToken.t\n}\n\nfunc (s *scanner) testNext(t rune) (r bool) {\n\tif r = s.t == t; r {\n\t\ts.next()\n\t}\n\treturn\n}\n\nfunc (s *scanner) check(t rune) {\n\tif s.t != t {\n\t\ts.errorExpected(t)\n\t}\n}\n\nfunc (s *scanner) checkMatch(what, who rune, where int) {\n\tif !s.testNext(what) {\n\t\tif where == s.lineNumber {\n\t\t\ts.errorExpected(what)\n\t\t} else {\n\t\t\ts.syntaxError(fmt.Sprintf(\"%s expected (to close %s at line %d)\", s.tokenToString(what), s.tokenToString(who), where))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "scanner_test.go",
          "type": "blob",
          "size": 1.84375,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype test struct {\n\tsource string\n\ttokens []token\n}\n\nfunc TestScanner(t *testing.T) {\n\ttests := []test{\n\t\t{\"\", []token{}},\n\t\t{\"-\", []token{{t: '-'}}},\n\t\t{\"--[\\n\\n\\r--]\", []token{}},\n\t\t{\"-- hello, world\\n\", []token{}},\n\t\t{\"=\", []token{{t: '='}}},\n\t\t{\"==\", []token{{t: tkEq}}},\n\t\t{\"\\\"hello, world\\\"\", []token{{t: tkString, s: \"hello, world\"}}},\n\t\t{\"[[hello,\\r\\nworld]]\", []token{{t: tkString, s: \"hello,\\n\\nworld\"}}},\n\t\t{\".\", []token{{t: '.'}}},\n\t\t{\"..\", []token{{t: tkConcat}}},\n\t\t{\"...\", []token{{t: tkDots}}},\n\t\t{\".34\", []token{{t: tkNumber, n: 0.34}}},\n\t\t{\"_foo\", []token{{t: tkName, s: \"_foo\"}}},\n\t\t{\"3\", []token{{t: tkNumber, n: float64(3)}}},\n\t\t{\"3.0\", []token{{t: tkNumber, n: 3.0}}},\n\t\t{\"3.1416\", []token{{t: tkNumber, n: 3.1416}}},\n\t\t{\"314.16e-2\", []token{{t: tkNumber, n: 3.1416}}},\n\t\t{\"0.31416E1\", []token{{t: tkNumber, n: 3.1416}}},\n\t\t{\"0xff\", []token{{t: tkNumber, n: float64(0xff)}}},\n\t\t{\"0x0.1E\", []token{{t: tkNumber, n: 0.1171875}}},\n\t\t{\"0xA23p-4\", []token{{t: tkNumber, n: 162.1875}}},\n\t\t{\"0X1.921FB54442D18P+1\", []token{{t: tkNumber, n: 3.141592653589793}}},\n\t\t{\"  -0xa  \", []token{{t: '-'}, {t: tkNumber, n: 10.0}}},\n\t}\n\tfor i, v := range tests {\n\t\ttestScanner(t, i, v.source, v.tokens)\n\t}\n}\n\nfunc testScanner(t *testing.T, n int, source string, tokens []token) {\n\ts := scanner{r: strings.NewReader(source)}\n\tfor i, expected := range tokens {\n\t\tif result := s.scan(); result != expected {\n\t\t\tt.Errorf(\"[%d] expected token %s but found %s at %d\", n, expected, result, i)\n\t\t}\n\t}\n\texpected := token{t: tkEOS}\n\tif result := s.scan(); result != expected {\n\t\tt.Errorf(\"[%d] expected token %s but found %s\", n, expected, result)\n\t}\n}\n\nfunc (t token) String() string {\n\ttok := string(t.t)\n\tif tkAnd <= t.t && t.t <= tkString {\n\t\ttok = tokens[t.t-firstReserved]\n\t}\n\treturn fmt.Sprintf(\"{t:%s, n:%f, s:%q}\", tok, t.n, t.s)\n}\n"
        },
        {
          "name": "stack.go",
          "type": "blob",
          "size": 12.078125,
          "content": "package lua\n\nimport \"log\"\n\nfunc (l *State) push(v value) {\n\tl.stack[l.top] = v\n\tl.top++\n}\n\nfunc (l *State) pop() value {\n\tl.top--\n\treturn l.stack[l.top]\n}\n\ntype upValue struct {\n\thome interface{}\n}\n\ntype closure interface {\n\tupValue(i int) value\n\tsetUpValue(i int, v value)\n\tupValueCount() int\n}\n\ntype luaClosure struct {\n\tprototype *prototype\n\tupValues  []*upValue\n}\n\ntype goClosure struct {\n\tfunction Function\n\tupValues []value\n}\n\n// Function wrapper, to allow go functions as keys in maps. Explicitly not a closure.\ntype goFunction struct {\n\tFunction\n}\n\nfunc (c *luaClosure) upValue(i int) value {\n\tuv := c.upValues[i]\n\tif home, ok := uv.home.(stackLocation); ok {\n\t\treturn home.state.stack[home.index]\n\t}\n\treturn uv.home\n}\n\nfunc (c *luaClosure) setUpValue(i int, v value) {\n\tuv := c.upValues[i]\n\tif home, ok := uv.home.(stackLocation); ok {\n\t\thome.state.stack[home.index] = v\n\t} else {\n\t\tuv.home = v\n\t}\n}\n\nfunc (c *luaClosure) upValueCount() int        { return len(c.upValues) }\nfunc (c *goClosure) upValue(i int) value       { return c.upValues[i] }\nfunc (c *goClosure) setUpValue(i int, v value) { c.upValues[i] = v }\nfunc (c *goClosure) upValueCount() int         { return len(c.upValues) }\nfunc (l *State) newUpValue() *upValue          { return &upValue{home: nil} }\n\nfunc (uv *upValue) value() value {\n\tif home, ok := uv.home.(stackLocation); ok {\n\t\treturn home.state.stack[home.index]\n\t}\n\treturn uv.home\n}\n\nfunc (uv *upValue) close() {\n\tif home, ok := uv.home.(stackLocation); ok {\n\t\tuv.home = home.state.stack[home.index]\n\t} else {\n\t\tpanic(\"attempt to close already-closed up value\")\n\t}\n}\n\nfunc (uv *upValue) isInStackAt(level int) bool {\n\tif home, ok := uv.home.(stackLocation); ok {\n\t\treturn home.index == level\n\t}\n\treturn false\n}\n\nfunc (uv *upValue) isInStackAbove(level int) bool {\n\tif home, ok := uv.home.(stackLocation); ok {\n\t\treturn home.index >= level\n\t}\n\treturn false\n}\n\ntype openUpValue struct {\n\tupValue *upValue\n\tnext    *openUpValue\n}\n\nfunc (l *State) newUpValueAt(level int) *upValue {\n\tuv := &upValue{home: stackLocation{state: l, index: level}}\n\tl.upValues = &openUpValue{upValue: uv, next: l.upValues}\n\treturn uv\n}\n\nfunc (l *State) close(level int) {\n\t// TODO this seems really inefficient - how can we terminate early?\n\tvar p *openUpValue\n\tfor e := l.upValues; e != nil; e, p = e.next, e {\n\t\tif e.upValue.isInStackAbove(level) {\n\t\t\te.upValue.close()\n\t\t\tif p != nil {\n\t\t\t\tp.next = e.next\n\t\t\t} else {\n\t\t\t\tl.upValues = e.next\n\t\t\t}\n\t\t}\n\t}\n}\n\n// information about a call\ntype callInfo struct {\n\tfunction, top, resultCount int\n\tprevious, next             *callInfo\n\tcallStatus                 callStatus\n\t*luaCallInfo\n\t*goCallInfo\n}\n\ntype luaCallInfo struct {\n\tframe   []value\n\tsavedPC pc\n\tcode    []instruction\n}\n\ntype goCallInfo struct {\n\tcontext, extra, oldErrorFunction int\n\tcontinuation                     Function\n\toldAllowHook, shouldYield        bool\n\terror                            error\n}\n\nfunc (ci *callInfo) setCallStatus(flag callStatus)     { ci.callStatus |= flag }\nfunc (ci *callInfo) clearCallStatus(flag callStatus)   { ci.callStatus &^= flag }\nfunc (ci *callInfo) isCallStatus(flag callStatus) bool { return ci.callStatus&flag != 0 }\nfunc (ci *callInfo) isLua() bool                       { return ci.luaCallInfo != nil }\n\nfunc (ci *callInfo) stackIndex(slot int) int { return ci.top - len(ci.frame) + slot }\nfunc (ci *callInfo) base() int               { return ci.top - len(ci.frame) }\nfunc (ci *callInfo) skip()                   { ci.savedPC++ }\nfunc (ci *callInfo) jump(offset int)         { ci.savedPC += pc(offset) }\n\nfunc (ci *callInfo) setTop(top int) {\n\tif ci.luaCallInfo != nil {\n\t\tdiff := top - ci.top\n\t\tci.frame = ci.frame[:len(ci.frame)+diff]\n\t}\n\tci.top = top\n}\n\nfunc (ci *callInfo) frameIndex(stackSlot int) int {\n\tif stackSlot < ci.top-len(ci.frame) || ci.top <= stackSlot {\n\t\tpanic(\"frameIndex called with out-of-range stackSlot\")\n\t}\n\treturn stackSlot - ci.top + len(ci.frame)\n}\n\nfunc (l *State) pushLuaFrame(function, base, resultCount int, p *prototype) *callInfo {\n\tci := l.callInfo.next\n\tif ci == nil {\n\t\tci = &callInfo{previous: l.callInfo, luaCallInfo: &luaCallInfo{code: p.code}}\n\t\tl.callInfo.next = ci\n\t} else if ci.luaCallInfo == nil {\n\t\tci.goCallInfo = nil\n\t\tci.luaCallInfo = &luaCallInfo{code: p.code}\n\t} else {\n\t\tci.savedPC = 0\n\t\tci.code = p.code\n\t}\n\tci.function = function\n\tci.top = base + p.maxStackSize\n\t// TODO l.assert(ci.top <= l.stackLast)\n\tci.resultCount = resultCount\n\tci.callStatus = callStatusLua\n\tci.frame = l.stack[base:ci.top]\n\tl.callInfo = ci\n\tl.top = ci.top\n\treturn ci\n}\n\nfunc (l *State) pushGoFrame(function, resultCount int) {\n\tci := l.callInfo.next\n\tif ci == nil {\n\t\tci = &callInfo{previous: l.callInfo, goCallInfo: &goCallInfo{}}\n\t\tl.callInfo.next = ci\n\t} else if ci.goCallInfo == nil {\n\t\tci.goCallInfo = &goCallInfo{}\n\t\tci.luaCallInfo = nil\n\t}\n\tci.function = function\n\tci.top = l.top + MinStack\n\t// TODO l.assert(ci.top <= l.stackLast)\n\tci.resultCount = resultCount\n\tci.callStatus = 0\n\tl.callInfo = ci\n}\n\nfunc (ci *luaCallInfo) step() instruction {\n\ti := ci.code[ci.savedPC]\n\tci.savedPC++\n\treturn i\n}\n\nfunc (l *State) newLuaClosure(p *prototype) *luaClosure {\n\treturn &luaClosure{prototype: p, upValues: make([]*upValue, len(p.upValues))}\n}\n\nfunc (l *State) findUpValue(level int) *upValue {\n\tfor e := l.upValues; e != nil; e = e.next {\n\t\tif e.upValue.isInStackAt(level) {\n\t\t\treturn e.upValue\n\t\t}\n\t}\n\treturn l.newUpValueAt(level)\n}\n\nfunc (l *State) newClosure(p *prototype, upValues []*upValue, base int) value {\n\tc := l.newLuaClosure(p)\n\tp.cache = c\n\tfor i, uv := range p.upValues {\n\t\tif uv.isLocal { // upValue refers to local variable\n\t\t\tc.upValues[i] = l.findUpValue(base + uv.index)\n\t\t} else { // get upValue from enclosing function\n\t\t\tc.upValues[i] = upValues[uv.index]\n\t\t}\n\t}\n\treturn c\n}\n\nfunc cached(p *prototype, upValues []*upValue, base int) *luaClosure {\n\tc := p.cache\n\tif c != nil {\n\t\tfor i, uv := range p.upValues {\n\t\t\tif uv.isLocal && !c.upValues[i].isInStackAt(base+uv.index) {\n\t\t\t\treturn nil\n\t\t\t} else if !uv.isLocal && c.upValues[i].home != upValues[uv.index].home {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn c\n}\n\nfunc (l *State) callGo(f value, function int, resultCount int) {\n\tl.checkStack(MinStack)\n\tl.pushGoFrame(function, resultCount)\n\tif l.hookMask&MaskCall != 0 {\n\t\tl.hook(HookCall, -1)\n\t}\n\tvar n int\n\tswitch f := f.(type) {\n\tcase *goClosure:\n\t\tn = f.function(l)\n\tcase *goFunction:\n\t\tn = f.Function(l)\n\t}\n\tapiCheckStackSpace(l, n)\n\tl.postCall(l.top - n)\n}\n\nfunc (l *State) preCall(function int, resultCount int) bool {\n\tfor {\n\t\tswitch f := l.stack[function].(type) {\n\t\tcase *goClosure:\n\t\t\tl.callGo(f, function, resultCount)\n\t\t\treturn true\n\t\tcase *goFunction:\n\t\t\tl.callGo(f, function, resultCount)\n\t\t\treturn true\n\t\tcase *luaClosure:\n\t\t\tp := f.prototype\n\t\t\tl.checkStack(p.maxStackSize)\n\t\t\targCount, parameterCount := l.top-function-1, p.parameterCount\n\t\t\tif argCount < parameterCount {\n\t\t\t\textra := parameterCount - argCount\n\t\t\t\targs := l.stack[l.top : l.top+extra]\n\t\t\t\tfor i := range args {\n\t\t\t\t\targs[i] = nil\n\t\t\t\t}\n\t\t\t\tl.top += extra\n\t\t\t\targCount += extra\n\t\t\t}\n\t\t\tbase := function + 1\n\t\t\tif p.isVarArg {\n\t\t\t\tbase = l.adjustVarArgs(p, argCount)\n\t\t\t}\n\t\t\tci := l.pushLuaFrame(function, base, resultCount, p)\n\t\t\tif l.hookMask&MaskCall != 0 {\n\t\t\t\tl.callHook(ci)\n\t\t\t}\n\t\t\treturn false\n\t\tdefault:\n\t\t\ttm := l.tagMethodByObject(f, tmCall)\n\t\t\tswitch tm.(type) {\n\t\t\tcase closure:\n\t\t\tcase *goFunction:\n\t\t\tdefault:\n\t\t\t\tl.typeError(f, \"call\")\n\t\t\t}\n\t\t\t// Slide the args + function up 1 slot and poke in the tag method\n\t\t\tfor p := l.top; p > function; p-- {\n\t\t\t\tl.stack[p] = l.stack[p-1]\n\t\t\t}\n\t\t\tl.top++\n\t\t\tl.checkStack(0)\n\t\t\tl.stack[function] = tm\n\t\t}\n\t}\n}\n\nfunc (l *State) callHook(ci *callInfo) {\n\tci.savedPC++ // hooks assume 'pc' is already incremented\n\tif pci := ci.previous; pci.isLua() && pci.code[pci.savedPC-1].opCode() == opTailCall {\n\t\tci.setCallStatus(callStatusTail)\n\t\tl.hook(HookTailCall, -1)\n\t} else {\n\t\tl.hook(HookCall, -1)\n\t}\n\tci.savedPC-- // correct 'pc'\n}\n\nfunc (l *State) adjustVarArgs(p *prototype, argCount int) int {\n\tfixedArgCount := p.parameterCount\n\tl.assert(argCount >= fixedArgCount)\n\t// move fixed parameters to final position\n\tfixed := l.top - argCount // first fixed argument\n\tbase := l.top             // final position of first argument\n\tfixedArgs := l.stack[fixed : fixed+fixedArgCount]\n\tcopy(l.stack[base:base+fixedArgCount], fixedArgs)\n\tfor i := range fixedArgs {\n\t\tfixedArgs[i] = nil\n\t}\n\treturn base\n}\n\nfunc (l *State) postCall(firstResult int) bool {\n\tci := l.callInfo\n\tif l.hookMask&MaskReturn != 0 {\n\t\tl.hook(HookReturn, -1)\n\t}\n\tresult, wanted, i := ci.function, ci.resultCount, 0\n\tl.callInfo = ci.previous // back to caller\n\t// TODO this is obscure - I don't fully understand the control flow, but it works\n\tfor i = wanted; i != 0 && firstResult < l.top; i-- {\n\t\tl.stack[result] = l.stack[firstResult]\n\t\tresult++\n\t\tfirstResult++\n\t}\n\tfor ; i > 0; i-- {\n\t\tl.stack[result] = nil\n\t\tresult++\n\t}\n\tl.top = result\n\tif l.hookMask&(MaskReturn|MaskLine) != 0 {\n\t\tl.oldPC = l.callInfo.savedPC // oldPC for caller function\n\t}\n\treturn wanted != MultipleReturns\n}\n\n// Call a Go or Lua function. The function to be called is at function.\n// The arguments are on the stack, right after the function. On return, all the\n// results are on the stack, starting at the original function position.\nfunc (l *State) call(function int, resultCount int, allowYield bool) {\n\tif l.nestedGoCallCount++; l.nestedGoCallCount == maxCallCount {\n\t\tl.runtimeError(\"Go stack overflow\")\n\t} else if l.nestedGoCallCount >= maxCallCount+maxCallCount>>3 {\n\t\tl.throw(ErrorError) // error while handling stack error\n\t}\n\tif !allowYield {\n\t\tl.nonYieldableCallCount++\n\t}\n\tif !l.preCall(function, resultCount) { // is a Lua function?\n\t\tl.execute() // call it\n\t}\n\tif !allowYield {\n\t\tl.nonYieldableCallCount--\n\t}\n\tl.nestedGoCallCount--\n}\n\nfunc (l *State) throw(errorCode error) {\n\tif l.protectFunction != nil {\n\t\tpanic(errorCode)\n\t} else {\n\t\tl.error = errorCode\n\t\tif g := l.global.mainThread; g.protectFunction != nil {\n\t\t\tg.push(l.stack[l.top-1])\n\t\t\tg.throw(errorCode)\n\t\t} else {\n\t\t\tif l.global.panicFunction != nil {\n\t\t\t\tl.global.panicFunction(l)\n\t\t\t}\n\t\t\tlog.Panicf(\"Uncaught Lua error: %v\", errorCode)\n\t\t}\n\t}\n}\n\nfunc (l *State) protect(f func()) (err error) {\n\tnestedGoCallCount, protectFunction := l.nestedGoCallCount, l.protectFunction\n\tl.protectFunction = func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = e.(error)\n\t\t\tl.nestedGoCallCount, l.protectFunction = nestedGoCallCount, protectFunction\n\t\t}\n\t}\n\tdefer l.protectFunction()\n\tf()\n\tl.nestedGoCallCount, l.protectFunction = nestedGoCallCount, protectFunction\n\treturn err\n}\n\nfunc (l *State) hook(event, line int) {\n\tif l.hooker == nil || !l.allowHook {\n\t\treturn\n\t}\n\tci := l.callInfo\n\ttop := l.top\n\tciTop := ci.top\n\tar := Debug{Event: event, CurrentLine: line, callInfo: ci}\n\tl.checkStack(MinStack)\n\tci.setTop(l.top + MinStack)\n\tl.assert(ci.top <= l.stackLast)\n\tl.allowHook = false // can't hook calls inside a hook\n\tci.setCallStatus(callStatusHooked)\n\tl.hooker(l, ar)\n\tl.assert(!l.allowHook)\n\tl.allowHook = true\n\tci.setTop(ciTop)\n\tl.top = top\n\tci.clearCallStatus(callStatusHooked)\n}\n\nfunc (l *State) initializeStack() {\n\tl.stack = make([]value, basicStackSize)\n\tl.stackLast = basicStackSize - extraStack\n\tl.top++\n\tl.baseCallInfo.luaCallInfo = &luaCallInfo{frame: l.stack[:0]}\n\tl.baseCallInfo.setTop(l.top + MinStack)\n\tl.callInfo = &l.baseCallInfo\n}\n\nfunc (l *State) checkStack(n int) {\n\tif l.stackLast-l.top <= n {\n\t\tl.growStack(n)\n\t}\n}\n\nfunc (l *State) reallocStack(newSize int) {\n\tl.assert(newSize <= maxStack || newSize == errorStackSize)\n\tl.assert(l.stackLast == len(l.stack)-extraStack)\n\tl.stack = append(l.stack, make([]value, newSize-len(l.stack))...)\n\tl.stackLast = len(l.stack) - extraStack\n\tl.callInfo.next = nil\n\tfor ci := l.callInfo; ci != nil; ci = ci.previous {\n\t\tif ci.isLua() {\n\t\t\ttop := ci.top\n\t\t\tci.frame = l.stack[top-len(ci.frame) : top]\n\t\t}\n\t}\n}\n\nfunc (l *State) growStack(n int) {\n\tif len(l.stack) > maxStack { // error after extra size?\n\t\tl.throw(ErrorError)\n\t} else {\n\t\tneeded := l.top + n + extraStack\n\t\tnewSize := 2 * len(l.stack)\n\t\tif newSize > maxStack {\n\t\t\tnewSize = maxStack\n\t\t}\n\t\tif newSize < needed {\n\t\t\tnewSize = needed\n\t\t}\n\t\tif newSize > maxStack { // stack overflow?\n\t\t\tl.reallocStack(errorStackSize)\n\t\t\tl.runtimeError(\"stack overflow\")\n\t\t} else {\n\t\t\tl.reallocStack(newSize)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "string.go",
          "type": "blob",
          "size": 6.1005859375,
          "content": "package lua\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc relativePosition(pos, length int) int {\n\tif pos >= 0 {\n\t\treturn pos\n\t} else if -pos > length {\n\t\treturn 0\n\t}\n\treturn length + pos + 1\n}\n\nfunc findHelper(l *State, isFind bool) int {\n\ts, p := CheckString(l, 1), CheckString(l, 2)\n\tinit := relativePosition(OptInteger(l, 3, 1), len(s))\n\tif init < 1 {\n\t\tinit = 1\n\t} else if init > len(s)+1 {\n\t\tl.PushNil()\n\t\treturn 1\n\t}\n\tisPlain := l.TypeOf(4) == TypeNone || l.ToBoolean(4)\n\tif isFind && (isPlain || !strings.ContainsAny(p, \"^$*+?.([%-\")) {\n\t\tif start := strings.Index(s[init-1:], p); start >= 0 {\n\t\t\tl.PushInteger(start + init)\n\t\t\tl.PushInteger(start + init + len(p) - 1)\n\t\t\treturn 2\n\t\t}\n\t} else {\n\t\tl.assert(false) // TODO implement pattern matching\n\t}\n\tl.PushNil()\n\treturn 1\n}\n\nfunc scanFormat(l *State, fs string) string {\n\ti := 0\n\tskipDigit := func() {\n\t\tif unicode.IsDigit(rune(fs[i])) {\n\t\t\ti++\n\t\t}\n\t}\n\tflags := \"-+ #0\"\n\tfor i < len(fs) && strings.ContainsRune(flags, rune(fs[i])) {\n\t\ti++\n\t}\n\tif i >= len(flags) {\n\t\tErrorf(l, \"invalid format (repeated flags)\")\n\t}\n\tskipDigit()\n\tskipDigit()\n\tif fs[i] == '.' {\n\t\ti++\n\t\tskipDigit()\n\t\tskipDigit()\n\t}\n\tif unicode.IsDigit(rune(fs[i])) {\n\t\tErrorf(l, \"invalid format (width or precision too long)\")\n\t}\n\ti++\n\treturn \"%\" + fs[:i]\n}\n\nfunc formatHelper(l *State, fs string, argCount int) string {\n\tvar b bytes.Buffer\n\tfor i, arg := 0, 1; i < len(fs); i++ {\n\t\tif fs[i] != '%' {\n\t\t\tb.WriteByte(fs[i])\n\t\t} else if i++; fs[i] == '%' {\n\t\t\tb.WriteByte(fs[i])\n\t\t} else {\n\t\t\tif arg++; arg > argCount {\n\t\t\t\tArgumentError(l, arg, \"no value\")\n\t\t\t}\n\t\t\tf := scanFormat(l, fs[i:])\n\t\t\tswitch i += len(f) - 2; fs[i] {\n\t\t\tcase 'c':\n\t\t\t\t// Ensure each character is represented by a single byte, while preserving format modifiers.\n\t\t\t\tc := CheckInteger(l, arg)\n\t\t\t\tfmt.Fprintf(&b, f, 'x')\n\t\t\t\tbuf := b.Bytes()\n\t\t\t\tbuf[len(buf)-1] = byte(c)\n\t\t\tcase 'i': // The fmt package doesn't support %i.\n\t\t\t\tf = f[:len(f)-1] + \"d\"\n\t\t\t\tfallthrough\n\t\t\tcase 'd':\n\t\t\t\tn := CheckNumber(l, arg)\n\t\t\t\tArgumentCheck(l, math.Floor(n) == n && -math.Pow(2, 63) <= n && n < math.Pow(2, 63), arg, \"number has no integer representation\")\n\t\t\t\tni := int(n)\n\t\t\t\tfmt.Fprintf(&b, f, ni)\n\t\t\tcase 'u': // The fmt package doesn't support %u.\n\t\t\t\tf = f[:len(f)-1] + \"d\"\n\t\t\t\tn := CheckNumber(l, arg)\n\t\t\t\tArgumentCheck(l, math.Floor(n) == n && 0.0 <= n && n < math.Pow(2, 64), arg, \"not a non-negative number in proper range\")\n\t\t\t\tni := uint(n)\n\t\t\t\tfmt.Fprintf(&b, f, ni)\n\t\t\tcase 'o', 'x', 'X':\n\t\t\t\tn := CheckNumber(l, arg)\n\t\t\t\tArgumentCheck(l, 0.0 <= n && n < math.Pow(2, 64), arg, \"not a non-negative number in proper range\")\n\t\t\t\tni := uint(n)\n\t\t\t\tfmt.Fprintf(&b, f, ni)\n\t\t\tcase 'e', 'E', 'f', 'g', 'G':\n\t\t\t\tfmt.Fprintf(&b, f, CheckNumber(l, arg))\n\t\t\tcase 'q':\n\t\t\t\ts := CheckString(l, arg)\n\t\t\t\tb.WriteByte('\"')\n\t\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\t\tswitch s[i] {\n\t\t\t\t\tcase '\"', '\\\\', '\\n':\n\t\t\t\t\t\tb.WriteByte('\\\\')\n\t\t\t\t\t\tb.WriteByte(s[i])\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif 0x20 <= s[i] && s[i] != 0x7f { // ASCII control characters don't correspond to a Unicode range.\n\t\t\t\t\t\t\tb.WriteByte(s[i])\n\t\t\t\t\t\t} else if i+1 < len(s) && unicode.IsDigit(rune(s[i+1])) {\n\t\t\t\t\t\t\tfmt.Fprintf(&b, \"\\\\%03d\", s[i])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfmt.Fprintf(&b, \"\\\\%d\", s[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb.WriteByte('\"')\n\t\t\tcase 's':\n\t\t\t\tif s, _ := ToStringMeta(l, arg); !strings.ContainsRune(f, '.') && len(s) >= 100 {\n\t\t\t\t\tb.WriteString(s)\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Fprintf(&b, f, s)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tErrorf(l, fmt.Sprintf(\"invalid option '%%%c' to 'format'\", fs[i]))\n\t\t\t}\n\t\t}\n\t}\n\treturn b.String()\n}\n\nvar stringLibrary = []RegistryFunction{\n\t{\"byte\", func(l *State) int {\n\t\ts := CheckString(l, 1)\n\t\tstart := relativePosition(OptInteger(l, 2, 1), len(s))\n\t\tend := relativePosition(OptInteger(l, 3, start), len(s))\n\t\tif start < 1 {\n\t\t\tstart = 1\n\t\t}\n\t\tif end > len(s) {\n\t\t\tend = len(s)\n\t\t}\n\t\tif start > end {\n\t\t\treturn 0\n\t\t}\n\t\tn := end - start + 1\n\t\tif start+n <= end {\n\t\t\tErrorf(l, \"string slice too long\")\n\t\t}\n\t\tCheckStackWithMessage(l, n, \"string slice too long\")\n\t\tfor _, c := range []byte(s[start-1 : end]) {\n\t\t\tl.PushInteger(int(c))\n\t\t}\n\t\treturn n\n\t}},\n\t{\"char\", func(l *State) int {\n\t\tvar b bytes.Buffer\n\t\tfor i, n := 1, l.Top(); i <= n; i++ {\n\t\t\tc := CheckInteger(l, i)\n\t\t\tArgumentCheck(l, int(byte(c)) == c, i, \"value out of range\")\n\t\t\tb.WriteByte(byte(c))\n\t\t}\n\t\tl.PushString(b.String())\n\t\treturn 1\n\t}},\n\t// {\"dump\", ...},\n\t{\"find\", func(l *State) int { return findHelper(l, true) }},\n\t{\"format\", func(l *State) int {\n\t\tl.PushString(formatHelper(l, CheckString(l, 1), l.Top()))\n\t\treturn 1\n\t}},\n\t// {\"gmatch\", ...},\n\t// {\"gsub\", ...},\n\t{\"len\", func(l *State) int { l.PushInteger(len(CheckString(l, 1))); return 1 }},\n\t{\"lower\", func(l *State) int { l.PushString(strings.ToLower(CheckString(l, 1))); return 1 }},\n\t// {\"match\", ...},\n\t{\"rep\", func(l *State) int {\n\t\ts, n, sep := CheckString(l, 1), CheckInteger(l, 2), OptString(l, 3, \"\")\n\t\tif n <= 0 {\n\t\t\tl.PushString(\"\")\n\t\t} else if len(s)+len(sep) < len(s) || len(s)+len(sep) >= maxInt/n {\n\t\t\tErrorf(l, \"resulting string too large\")\n\t\t} else if sep == \"\" {\n\t\t\tl.PushString(strings.Repeat(s, n))\n\t\t} else {\n\t\t\tvar b bytes.Buffer\n\t\t\tb.Grow(n*len(s) + (n-1)*len(sep))\n\t\t\tb.WriteString(s)\n\t\t\tfor ; n > 1; n-- {\n\t\t\t\tb.WriteString(sep)\n\t\t\t\tb.WriteString(s)\n\t\t\t}\n\t\t\tl.PushString(b.String())\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"reverse\", func(l *State) int {\n\t\tr := []rune(CheckString(l, 1))\n\t\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\n\t\t\tr[i], r[j] = r[j], r[i]\n\t\t}\n\t\tl.PushString(string(r))\n\t\treturn 1\n\t}},\n\t{\"sub\", func(l *State) int {\n\t\ts := CheckString(l, 1)\n\t\tstart, end := relativePosition(CheckInteger(l, 2), len(s)), relativePosition(OptInteger(l, 3, -1), len(s))\n\t\tif start < 1 {\n\t\t\tstart = 1\n\t\t}\n\t\tif end > len(s) {\n\t\t\tend = len(s)\n\t\t}\n\t\tif start <= end {\n\t\t\tl.PushString(s[start-1 : end])\n\t\t} else {\n\t\t\tl.PushString(\"\")\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"upper\", func(l *State) int { l.PushString(strings.ToUpper(CheckString(l, 1))); return 1 }},\n}\n\n// StringOpen opens the string library. Usually passed to Require.\nfunc StringOpen(l *State) int {\n\tNewLibrary(l, stringLibrary)\n\tl.CreateTable(0, 1)\n\tl.PushString(\"\")\n\tl.PushValue(-2)\n\tl.SetMetaTable(-2)\n\tl.Pop(1)\n\tl.PushValue(-2)\n\tl.SetField(-2, \"__index\")\n\tl.Pop(1)\n\treturn 1\n}\n"
        },
        {
          "name": "table.go",
          "type": "blob",
          "size": 3.3330078125,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype sortHelper struct {\n\tl           *State\n\tn           int\n\thasFunction bool\n}\n\nfunc (h sortHelper) Len() int { return h.n }\n\nfunc (h sortHelper) Swap(i, j int) {\n\t// Convert Go to Lua indices\n\ti++\n\tj++\n\th.l.RawGetInt(1, i)\n\th.l.RawGetInt(1, j)\n\th.l.RawSetInt(1, i)\n\th.l.RawSetInt(1, j)\n}\n\nfunc (h sortHelper) Less(i, j int) bool {\n\t// Convert Go to Lua indices\n\ti++\n\tj++\n\tif h.hasFunction {\n\t\th.l.PushValue(2)\n\t\th.l.RawGetInt(1, i)\n\t\th.l.RawGetInt(1, j)\n\t\th.l.Call(2, 1)\n\t\tb := h.l.ToBoolean(-1)\n\t\th.l.Pop(1)\n\t\treturn b\n\t}\n\th.l.RawGetInt(1, i)\n\th.l.RawGetInt(1, j)\n\tb := h.l.Compare(-2, -1, OpLT)\n\th.l.Pop(2)\n\treturn b\n}\n\nvar tableLibrary = []RegistryFunction{\n\t{\"concat\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\tsep := OptString(l, 2, \"\")\n\t\ti := OptInteger(l, 3, 1)\n\t\tvar last int\n\t\tif l.IsNoneOrNil(4) {\n\t\t\tlast = LengthEx(l, 1)\n\t\t} else {\n\t\t\tlast = CheckInteger(l, 4)\n\t\t}\n\t\ts := \"\"\n\t\taddField := func() {\n\t\t\tl.RawGetInt(1, i)\n\t\t\tif str, ok := l.ToString(-1); ok {\n\t\t\t\ts += str\n\t\t\t} else {\n\t\t\t\tErrorf(l, fmt.Sprintf(\"invalid value (%s) at index %d in table for 'concat'\", TypeNameOf(l, -1), i))\n\t\t\t}\n\t\t\tl.Pop(1)\n\t\t}\n\t\tfor ; i < last; i++ {\n\t\t\taddField()\n\t\t\ts += sep\n\t\t}\n\t\tif i == last {\n\t\t\taddField()\n\t\t}\n\t\tl.PushString(s)\n\t\treturn 1\n\t}},\n\t{\"insert\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\te := LengthEx(l, 1) + 1 // First empty element.\n\t\tswitch l.Top() {\n\t\tcase 2:\n\t\t\tl.RawSetInt(1, e) // Insert new element at the end.\n\t\tcase 3:\n\t\t\tpos := CheckInteger(l, 2)\n\t\t\tArgumentCheck(l, 1 <= pos && pos <= e, 2, \"position out of bounds\")\n\t\t\tfor i := e; i > pos; i-- {\n\t\t\t\tl.RawGetInt(1, i-1)\n\t\t\t\tl.RawSetInt(1, i) // t[i] = t[i-1]\n\t\t\t}\n\t\t\tl.RawSetInt(1, pos) // t[pos] = v\n\t\tdefault:\n\t\t\tErrorf(l, \"wrong number of arguments to 'insert'\")\n\t\t}\n\t\treturn 0\n\t}},\n\t{\"pack\", func(l *State) int {\n\t\tn := l.Top()\n\t\tl.CreateTable(n, 1)\n\t\tl.PushInteger(n)\n\t\tl.SetField(-2, \"n\")\n\t\tif n > 0 {\n\t\t\tl.PushValue(1)\n\t\t\tl.RawSetInt(-2, 1)\n\t\t\tl.Replace(1)\n\t\t\tfor i := n; i >= 2; i-- {\n\t\t\t\tl.RawSetInt(1, i)\n\t\t\t}\n\t\t}\n\t\treturn 1\n\t}},\n\t{\"unpack\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\ti := OptInteger(l, 2, 1)\n\t\tvar e int\n\t\tif l.IsNoneOrNil(3) {\n\t\t\te = LengthEx(l, 1)\n\t\t} else {\n\t\t\te = CheckInteger(l, 3)\n\t\t}\n\t\tif i > e {\n\t\t\treturn 0\n\t\t}\n\t\tn := e - i + 1\n\t\tif n <= 0 || !l.CheckStack(n) {\n\t\t\tErrorf(l, \"too many results to unpack\")\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\t\tfor l.RawGetInt(1, i); i < e; i++ {\n\t\t\tl.RawGetInt(1, i+1)\n\t\t}\n\t\treturn n\n\t}},\n\t{\"remove\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\tsize := LengthEx(l, 1)\n\t\tpos := OptInteger(l, 2, size)\n\t\tif pos != size {\n\t\t\tArgumentCheck(l, 1 <= pos && pos <= size+1, 2, \"position out of bounds\")\n\t\t}\n\t\tfor l.RawGetInt(1, pos); pos < size; pos++ {\n\t\t\tl.RawGetInt(1, pos+1)\n\t\t\tl.RawSetInt(1, pos) // t[pos] = t[pos+1]\n\t\t}\n\t\tl.PushNil()\n\t\tl.RawSetInt(1, pos) // t[pos] = nil\n\t\treturn 1\n\t}},\n\t{\"sort\", func(l *State) int {\n\t\tCheckType(l, 1, TypeTable)\n\t\tn := LengthEx(l, 1)\n\t\thasFunction := !l.IsNoneOrNil(2)\n\t\tif hasFunction {\n\t\t\tCheckType(l, 2, TypeFunction)\n\t\t}\n\t\tl.SetTop(2)\n\t\th := sortHelper{l, n, hasFunction}\n\t\tsort.Sort(h)\n\t\t// Check result is sorted.\n\t\tif n > 0 && h.Less(n-1, 0) {\n\t\t\tErrorf(l, \"invalid order function for sorting\")\n\t\t}\n\t\treturn 0\n\t}},\n}\n\n// TableOpen opens the table library. Usually passed to Require.\nfunc TableOpen(l *State) int {\n\tNewLibrary(l, tableLibrary)\n\treturn 1\n}\n"
        },
        {
          "name": "tables.go",
          "type": "blob",
          "size": 5.1865234375,
          "content": "package lua\n\nimport (\n\t\"math\"\n)\n\ntype table struct {\n\tarray         []value\n\thash          map[value]value\n\tmetaTable     *table\n\tflags         byte\n\titerationKeys []value\n}\n\nfunc newTable() *table                     { return &table{hash: make(map[value]value)} }\nfunc (t *table) invalidateTagMethodCache() { t.flags = 0 }\nfunc (t *table) atString(k string) value   { return t.hash[k] }\n\nfunc newTableWithSize(arraySize, hashSize int) *table {\n\tt := new(table)\n\tif arraySize > 0 {\n\t\tt.array = make([]value, arraySize)\n\t}\n\tif hashSize > 0 {\n\t\tt.hash = make(map[value]value, hashSize)\n\t} else {\n\t\tt.hash = make(map[value]value)\n\t}\n\treturn t\n}\n\nfunc (l *State) fastTagMethod(table *table, event tm) value {\n\tif table == nil || table.flags&1<<event != 0 {\n\t\treturn nil\n\t}\n\treturn table.tagMethod(event, l.global.tagMethodNames[event])\n}\n\nfunc (t *table) extendArray(last int) {\n\tt.array = append(t.array, make([]value, last-len(t.array))...)\n\tfor k, v := range t.hash {\n\t\tif f, ok := k.(float64); ok {\n\t\t\tif i := int(f); float64(i) == f {\n\t\t\t\tif 0 < i && i <= len(t.array) {\n\t\t\t\t\tt.array[i-1] = v\n\t\t\t\t\tdelete(t.hash, k)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (t *table) atInt(k int) value {\n\tif 0 < k && k <= len(t.array) {\n\t\treturn t.array[k-1]\n\t}\n\treturn t.hash[float64(k)]\n}\n\nfunc (t *table) maybeResizeArray(key int) bool {\n\t// Precondition: key > len(t.array).\n\toccupancy := 0\n\tfor _, v := range t.array {\n\t\tif v != nil {\n\t\t\toccupancy++\n\t\t}\n\t}\n\tfor k, v := range t.hash {\n\t\tif f, ok := k.(float64); ok && v != nil {\n\t\t\tif i := int(f); i <= key && float64(i) == f {\n\t\t\t\toccupancy++\n\t\t\t}\n\t\t}\n\t}\n\tif occupancy >= key>>1 {\n\t\tt.extendArray(max(occupancy*2, key)) // TODO Tune growth function.\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (t *table) addOrInsertHash(k, v value) {\n\tif _, ok := t.hash[k]; !ok {\n\t\tt.iterationKeys = nil // invalidate iterations when adding an entry\n\t}\n\tt.hash[k] = v\n}\n\nfunc (t *table) putAtInt(k int, v value) {\n\tif 0 < k && k <= len(t.array) {\n\t\tt.array[k-1] = v\n\t} else if k > 0 && v != nil && t.maybeResizeArray(k) {\n\t\tt.array[k-1] = v\n\t} else if v == nil {\n\t\tdelete(t.hash, float64(k))\n\t} else {\n\t\tt.addOrInsertHash(float64(k), v)\n\t}\n}\n\nfunc (t *table) at(k value) value {\n\tswitch k := k.(type) {\n\tcase nil:\n\t\treturn nil\n\tcase float64:\n\t\tif i := int(k); float64(i) == k { // OPT: Inlined copy of atInt.\n\t\t\tif 0 < i && i <= len(t.array) {\n\t\t\t\treturn t.array[i-1]\n\t\t\t}\n\t\t\treturn t.hash[k]\n\t\t}\n\tcase string:\n\t\treturn t.hash[k]\n\t}\n\treturn t.hash[k]\n}\n\nfunc (t *table) put(l *State, k, v value) {\n\tswitch k := k.(type) {\n\tcase nil:\n\t\tl.runtimeError(\"table index is nil\")\n\tcase float64:\n\t\tif i := int(k); float64(i) == k {\n\t\t\tt.putAtInt(i, v)\n\t\t} else if math.IsNaN(k) {\n\t\t\tl.runtimeError(\"table index is NaN\")\n\t\t} else if v == nil {\n\t\t\tdelete(t.hash, k)\n\t\t} else {\n\t\t\tt.addOrInsertHash(k, v)\n\t\t}\n\tcase string:\n\t\tif v == nil {\n\t\t\tdelete(t.hash, k)\n\t\t} else {\n\t\t\tt.addOrInsertHash(k, v)\n\t\t}\n\tdefault:\n\t\tif v == nil {\n\t\t\tdelete(t.hash, k)\n\t\t} else {\n\t\t\tt.addOrInsertHash(k, v)\n\t\t}\n\t}\n}\n\n// OPT: tryPut is an optimized variant of the at/put pair used by setTableAt to avoid hashing the key twice.\nfunc (t *table) tryPut(l *State, k, v value) bool {\n\tswitch k := k.(type) {\n\tcase nil:\n\tcase float64:\n\t\tif i := int(k); float64(i) == k && 0 < i && i <= len(t.array) && t.array[i-1] != nil {\n\t\t\tt.array[i-1] = v\n\t\t\treturn true\n\t\t} else if math.IsNaN(k) {\n\t\t\treturn false\n\t\t} else if t.hash[k] != nil && v != nil {\n\t\t\tt.hash[k] = v\n\t\t\treturn true\n\t\t}\n\tcase string:\n\t\tif t.hash[k] != nil && v != nil {\n\t\t\tt.hash[k] = v\n\t\t\treturn true\n\t\t}\n\tdefault:\n\t\tif t.hash[k] != nil && v != nil {\n\t\t\tt.hash[k] = v\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (t *table) unboundSearch(j int) int {\n\ti := j\n\tfor j++; nil != t.atInt(j); {\n\t\ti = j\n\t\tif j *= 2; j < 0 {\n\t\t\tfor i = 1; nil != t.atInt(i); i++ {\n\t\t\t}\n\t\t\treturn i - 1\n\t\t}\n\t}\n\tfor j-i > 1 {\n\t\tm := (i + j) / 2\n\t\tif nil == t.atInt(m) {\n\t\t\tj = m\n\t\t} else {\n\t\t\ti = m\n\t\t}\n\t}\n\treturn i\n}\n\nfunc (t *table) length() int {\n\tj := len(t.array)\n\tif j > 0 && t.array[j-1] == nil {\n\t\ti := 0\n\t\tfor j-i > 1 {\n\t\t\tm := (i + j) / 2\n\t\t\tif t.array[m-1] == nil {\n\t\t\t\tj = m\n\t\t\t} else {\n\t\t\t\ti = m\n\t\t\t}\n\t\t}\n\t\treturn i\n\t} else if t.hash == nil {\n\t\treturn j\n\t}\n\treturn t.unboundSearch(j)\n}\n\nfunc arrayIndex(k value) int {\n\tif n, ok := k.(float64); ok {\n\t\tif i := int(n); float64(i) == n {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc (l *State) next(t *table, key int) bool {\n\ti, k := 0, l.stack[key]\n\tif k == nil { // first iteration\n\t} else if i = arrayIndex(k); 0 < i && i <= len(t.array) {\n\t\tk = nil\n\t} else if _, ok := t.hash[k]; !ok {\n\t\tl.runtimeError(\"invalid key to 'next'\") // key not found\n\t} else {\n\t\ti = len(t.array)\n\t}\n\tfor ; i < len(t.array); i++ {\n\t\tif t.array[i] != nil {\n\t\t\tl.stack[key] = float64(i + 1)\n\t\t\tl.stack[key+1] = t.array[i]\n\t\t\treturn true\n\t\t}\n\t}\n\tif t.iterationKeys == nil {\n\t\tj, keys := 0, make([]value, len(t.hash))\n\t\tfor hk := range t.hash {\n\t\t\tkeys[j] = hk\n\t\t\tj++\n\t\t}\n\t\tt.iterationKeys = keys\n\t}\n\tfound := k == nil\n\tfor i, hk := range t.iterationKeys {\n\t\tif hk == nil { // skip deleted key\n\t\t} else if _, present := t.hash[hk]; !present {\n\t\t\tt.iterationKeys[i] = nil // mark key as deleted\n\t\t} else if found {\n\t\t\tl.stack[key] = hk\n\t\t\tl.stack[key+1] = t.hash[hk]\n\t\t\treturn true\n\t\t} else if l.equalObjects(hk, k) {\n\t\t\tfound = true\n\t\t}\n\t}\n\treturn false // no more elements\n}\n"
        },
        {
          "name": "tag_methods.go",
          "type": "blob",
          "size": 1.373046875,
          "content": "package lua\n\ntype tm uint\n\nconst (\n\ttmIndex tm = iota\n\ttmNewIndex\n\ttmGC\n\ttmMode\n\ttmLen\n\ttmEq\n\ttmAdd\n\ttmSub\n\ttmMul\n\ttmDiv\n\ttmMod\n\ttmPow\n\ttmUnaryMinus\n\ttmLT\n\ttmLE\n\ttmConcat\n\ttmCall\n\ttmCount // number of tag methods\n)\n\nvar eventNames = []string{\n\t\"__index\",\n\t\"__newindex\",\n\t\"__gc\",\n\t\"__mode\",\n\t\"__len\",\n\t\"__eq\",\n\t\"__add\",\n\t\"__sub\",\n\t\"__mul\",\n\t\"__div\",\n\t\"__mod\",\n\t\"__pow\",\n\t\"__unm\",\n\t\"__lt\",\n\t\"__le\",\n\t\"__concat\",\n\t\"__call\",\n}\n\nvar typeNames = []string{\n\t\"no value\",\n\t\"nil\",\n\t\"boolean\",\n\t\"userdata\",\n\t\"number\",\n\t\"string\",\n\t\"table\",\n\t\"function\",\n\t\"userdata\",\n\t\"thread\",\n\t\"proto\", // these last two cases are used for tests only\n\t\"upval\",\n}\n\nfunc (events *table) tagMethod(event tm, name string) value {\n\ttm := events.atString(name)\n\t//l.assert(event <= tmEq)\n\tif tm == nil {\n\t\tevents.flags |= 1 << event\n\t}\n\treturn tm\n}\n\nfunc (l *State) tagMethodByObject(o value, event tm) value {\n\tvar mt *table\n\tswitch o := o.(type) {\n\tcase *table:\n\t\tmt = o.metaTable\n\tcase *userData:\n\t\tmt = o.metaTable\n\tdefault:\n\t\tmt = l.global.metaTable(o)\n\t}\n\tif mt == nil {\n\t\treturn nil\n\t}\n\treturn mt.atString(l.global.tagMethodNames[event])\n}\n\nfunc (l *State) callTagMethod(f, p1, p2 value) value {\n\tl.push(f)\n\tl.push(p1)\n\tl.push(p2)\n\tl.call(l.top-3, 1, l.callInfo.isLua())\n\treturn l.pop()\n}\n\nfunc (l *State) callTagMethodV(f, p1, p2, p3 value) {\n\tl.push(f)\n\tl.push(p1)\n\tl.push(p2)\n\tl.push(p3)\n\tl.call(l.top-4, 0, l.callInfo.isLua())\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 7.0673828125,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n)\n\ntype value interface{}\ntype float8 int\n\nfunc debugValue(v value) string {\n\tswitch v := v.(type) {\n\tcase *table:\n\t\tentry := func(x value) string {\n\t\t\tif t, ok := x.(*table); ok {\n\t\t\t\treturn fmt.Sprintf(\"table %#v\", t)\n\t\t\t}\n\t\t\treturn debugValue(x)\n\t\t}\n\t\ts := fmt.Sprintf(\"table %#v {[\", v)\n\t\tfor _, x := range v.array {\n\t\t\ts += entry(x) + \", \"\n\t\t}\n\t\ts += \"], {\"\n\t\tfor k, x := range v.hash {\n\t\t\ts += entry(k) + \": \" + entry(x) + \", \"\n\t\t}\n\t\treturn s + \"}}\"\n\tcase string:\n\t\treturn \"'\" + v + \"'\"\n\tcase float64:\n\t\treturn fmt.Sprintf(\"%f\", v)\n\tcase *luaClosure:\n\t\treturn fmt.Sprintf(\"closure %s:%d %v\", v.prototype.source, v.prototype.lineDefined, v)\n\tcase *goClosure:\n\t\treturn fmt.Sprintf(\"go closure %#v\", v)\n\tcase *goFunction:\n\t\tpc := reflect.ValueOf(v.Function).Pointer()\n\t\tf := runtime.FuncForPC(pc)\n\t\tfile, line := f.FileLine(pc)\n\t\treturn fmt.Sprintf(\"go function %s %s:%d\", f.Name(), file, line)\n\tcase *userData:\n\t\treturn fmt.Sprintf(\"userdata %#v\", v)\n\tcase nil:\n\t\treturn \"nil\"\n\tcase bool:\n\t\treturn fmt.Sprintf(\"%#v\", v)\n\t}\n\treturn fmt.Sprintf(\"unknown %#v %s\", v, reflect.TypeOf(v).Name())\n}\n\nfunc stack(s []value) string {\n\tr := fmt.Sprintf(\"stack (len: %d, cap: %d):\\n\", len(s), cap(s))\n\tfor i, v := range s {\n\t\tr = fmt.Sprintf(\"%s %d: %s\\n\", r, i, debugValue(v))\n\t}\n\treturn r\n}\n\nfunc isFalse(s value) bool {\n\tif s == nil || s == none {\n\t\treturn true\n\t}\n\tb, isBool := s.(bool)\n\treturn isBool && !b\n}\n\ntype localVariable struct {\n\tname           string\n\tstartPC, endPC pc\n}\n\ntype userData struct {\n\tmetaTable, env *table\n\tdata           interface{}\n}\n\ntype upValueDesc struct {\n\tname    string\n\tisLocal bool\n\tindex   int\n}\n\ntype stackLocation struct {\n\tstate *State\n\tindex int\n}\n\ntype prototype struct {\n\tconstants                    []value\n\tcode                         []instruction\n\tprototypes                   []prototype\n\tlineInfo                     []int32\n\tlocalVariables               []localVariable\n\tupValues                     []upValueDesc\n\tcache                        *luaClosure\n\tsource                       string\n\tlineDefined, lastLineDefined int\n\tparameterCount, maxStackSize int\n\tisVarArg                     bool\n}\n\nfunc (p *prototype) upValueName(index int) string {\n\tif s := p.upValues[index].name; s != \"\" {\n\t\treturn s\n\t}\n\treturn \"?\"\n}\n\nfunc (p *prototype) lastLoad(reg int, lastPC pc) (loadPC pc, found bool) {\n\tvar ip, jumpTarget pc\n\tfor ; ip < lastPC; ip++ {\n\t\ti, maybe := p.code[ip], false\n\t\tswitch i.opCode() {\n\t\tcase opLoadNil:\n\t\t\tmaybe = i.a() <= reg && reg <= i.a()+i.b()\n\t\tcase opTForCall:\n\t\t\tmaybe = reg >= i.a()+2\n\t\tcase opCall, opTailCall:\n\t\t\tmaybe = reg >= i.a()\n\t\tcase opJump:\n\t\t\tif dest := ip + 1 + pc(i.sbx()); ip < dest && dest <= lastPC && dest > jumpTarget {\n\t\t\t\tjumpTarget = dest\n\t\t\t}\n\t\tcase opTest:\n\t\t\tmaybe = reg == i.a()\n\t\tdefault:\n\t\t\tmaybe = testAMode(i.opCode()) && reg == i.a()\n\t\t}\n\t\tif maybe {\n\t\t\tif ip < jumpTarget { // Can't know loading instruction because code is conditional.\n\t\t\t\tfound = false\n\t\t\t} else {\n\t\t\t\tloadPC, found = ip, true\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc (p *prototype) objectName(reg int, lastPC pc) (name, kind string) {\n\tif name, isLocal := p.localName(reg+1, lastPC); isLocal {\n\t\treturn name, \"local\"\n\t}\n\tif pc, found := p.lastLoad(reg, lastPC); found {\n\t\ti := p.code[pc]\n\t\tswitch op := i.opCode(); op {\n\t\tcase opMove:\n\t\t\tif b := i.b(); b < i.a() {\n\t\t\t\treturn p.objectName(b, pc)\n\t\t\t}\n\t\tcase opGetTableUp:\n\t\t\tname, kind = p.constantName(i.c(), pc), \"local\"\n\t\t\tif p.upValueName(i.b()) == \"_ENV\" {\n\t\t\t\tkind = \"global\"\n\t\t\t}\n\t\t\treturn\n\t\tcase opGetTable:\n\t\t\tname, kind = p.constantName(i.c(), pc), \"local\"\n\t\t\tif v, ok := p.localName(i.b()+1, pc); ok && v == \"_ENV\" {\n\t\t\t\tkind = \"global\"\n\t\t\t}\n\t\t\treturn\n\t\tcase opGetUpValue:\n\t\t\treturn p.upValueName(i.b()), \"upvalue\"\n\t\tcase opLoadConstant:\n\t\t\tif s, ok := p.constants[i.bx()].(string); ok {\n\t\t\t\treturn s, \"constant\"\n\t\t\t}\n\t\tcase opLoadConstantEx:\n\t\t\tif s, ok := p.constants[p.code[pc+1].ax()].(string); ok {\n\t\t\t\treturn s, \"constant\"\n\t\t\t}\n\t\tcase opSelf:\n\t\t\treturn p.constantName(i.c(), pc), \"method\"\n\t\t}\n\t}\n\treturn\n}\n\nfunc (p *prototype) constantName(k int, pc pc) string {\n\tif isConstant(k) {\n\t\tif s, ok := p.constants[constantIndex(k)].(string); ok {\n\t\t\treturn s\n\t\t}\n\t} else if name, kind := p.objectName(k, pc); kind == \"c\" {\n\t\treturn name\n\t}\n\treturn \"?\"\n}\n\nfunc (p *prototype) localName(index int, pc pc) (string, bool) {\n\tfor i := 0; i < len(p.localVariables) && p.localVariables[i].startPC <= pc; i++ {\n\t\tif pc < p.localVariables[i].endPC {\n\t\t\tif index--; index == 0 {\n\t\t\t\treturn p.localVariables[i].name, true\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// Converts an integer to a \"floating point byte\", represented as\n// (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if\n// eeeee != 0 and (xxx) otherwise.\nfunc float8FromInt(x int) float8 {\n\tif x < 8 {\n\t\treturn float8(x)\n\t}\n\te := 0\n\tfor ; x >= 0x10; e++ {\n\t\tx = (x + 1) >> 1\n\t}\n\treturn float8(((e + 1) << 3) | (x - 8))\n}\n\nfunc intFromFloat8(x float8) int {\n\te := x >> 3 & 0x1f\n\tif e == 0 {\n\t\treturn int(x)\n\t}\n\treturn int(x&7+8) << uint(e-1)\n}\n\nfunc arith(op Operator, v1, v2 float64) float64 {\n\tswitch op {\n\tcase OpAdd:\n\t\treturn v1 + v2\n\tcase OpSub:\n\t\treturn v1 - v2\n\tcase OpMul:\n\t\treturn v1 * v2\n\tcase OpDiv:\n\t\treturn v1 / v2\n\tcase OpMod:\n\t\treturn v1 - math.Floor(v1/v2)*v2\n\tcase OpPow:\n\t\t// Golang bug: math.Pow(10.0, 33.0) is incorrect by 1 bit.\n\t\tif v1 == 10.0 && float64(int(v2)) == v2 {\n\t\t\treturn math.Pow10(int(v2))\n\t\t}\n\t\treturn math.Pow(v1, v2)\n\tcase OpUnaryMinus:\n\t\treturn -v1\n\t}\n\tpanic(fmt.Sprintf(\"not an arithmetic op code (%d)\", op))\n}\n\nfunc (l *State) parseNumber(s string) (v float64, ok bool) { // TODO this is f*cking ugly - scanner.readNumber should be refactored.\n\tif len(strings.Fields(s)) != 1 || strings.ContainsRune(s, 0) {\n\t\treturn\n\t}\n\tscanner := scanner{l: l, r: strings.NewReader(s)}\n\tt := scanner.scan()\n\tif t.t == '-' {\n\t\tif t := scanner.scan(); t.t == tkNumber {\n\t\t\tv, ok = -t.n, true\n\t\t}\n\t} else if t.t == tkNumber {\n\t\tv, ok = t.n, true\n\t} else if t.t == '+' {\n\t\tif t := scanner.scan(); t.t == tkNumber {\n\t\t\tv, ok = t.n, true\n\t\t}\n\t}\n\tif ok && scanner.scan().t != tkEOS {\n\t\tok = false\n\t} else if math.IsInf(v, 0) || math.IsNaN(v) {\n\t\tok = false\n\t}\n\treturn\n}\n\nfunc (l *State) toNumber(r value) (v float64, ok bool) {\n\tif v, ok = r.(float64); ok {\n\t\treturn\n\t}\n\tvar s string\n\tif s, ok = r.(string); ok {\n\t\tif err := l.protectedCall(func() { v, ok = l.parseNumber(strings.TrimSpace(s)) }, l.top, l.errorFunction); err != nil {\n\t\t\tl.pop() // Remove error message from the stack.\n\t\t\tok = false\n\t\t}\n\t}\n\treturn\n}\n\nfunc (l *State) toString(index int) (s string, ok bool) {\n\tif s, ok = toString(l.stack[index]); ok {\n\t\tl.stack[index] = s\n\t}\n\treturn\n}\n\nfunc numberToString(f float64) string {\n\treturn fmt.Sprintf(\"%.14g\", f)\n}\n\nfunc toString(r value) (string, bool) {\n\tswitch r := r.(type) {\n\tcase string:\n\t\treturn r, true\n\tcase float64:\n\t\treturn numberToString(r), true\n\t}\n\treturn \"\", false\n}\n\nfunc pairAsNumbers(p1, p2 value) (f1, f2 float64, ok bool) {\n\tif f1, ok = p1.(float64); !ok {\n\t\treturn\n\t}\n\tf2, ok = p2.(float64)\n\treturn\n}\n\nfunc pairAsStrings(p1, p2 value) (s1, s2 string, ok bool) {\n\tif s1, ok = p1.(string); !ok {\n\t\treturn\n\t}\n\ts2, ok = p2.(string)\n\treturn\n}\n"
        },
        {
          "name": "undump.go",
          "type": "blob",
          "size": 7.296875,
          "content": "package lua\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"unsafe\"\n)\n\ntype loadState struct {\n\tin    io.Reader\n\torder binary.ByteOrder\n}\n\nvar header struct {\n\tSignature                            [4]byte\n\tVersion, Format, Endianness, IntSize byte\n\tPointerSize, InstructionSize         byte\n\tNumberSize, IntegralNumber           byte\n\tTail                                 [6]byte\n}\n\nvar (\n\terrUnknownConstantType = errors.New(\"lua: unknown constant type in lua binary\")\n\terrNotPrecompiledChunk = errors.New(\"lua: is not a precompiled chunk\")\n\terrVersionMismatch     = errors.New(\"lua: version mismatch in precompiled chunk\")\n\terrIncompatible        = errors.New(\"lua: incompatible precompiled chunk\")\n\terrCorrupted           = errors.New(\"lua: corrupted precompiled chunk\")\n)\n\nfunc (state *loadState) read(data interface{}) error {\n\treturn binary.Read(state.in, state.order, data)\n}\n\nfunc (state *loadState) readNumber() (f float64, err error) {\n\terr = state.read(&f)\n\treturn\n}\n\nfunc (state *loadState) readInt() (i int32, err error) {\n\terr = state.read(&i)\n\treturn\n}\n\nfunc (state *loadState) readPC() (pc, error) {\n\ti, err := state.readInt()\n\treturn pc(i), err\n}\n\nfunc (state *loadState) readByte() (b byte, err error) {\n\terr = state.read(&b)\n\treturn\n}\n\nfunc (state *loadState) readBool() (bool, error) {\n\tb, err := state.readByte()\n\treturn b != 0, err\n}\n\nfunc (state *loadState) readString() (s string, err error) {\n\t// Feel my pain\n\tmaxUint := ^uint(0)\n\tvar size uintptr\n\tvar size64 uint64\n\tvar size32 uint32\n\tif uint64(maxUint) == math.MaxUint64 {\n\t\terr = state.read(&size64)\n\t\tsize = uintptr(size64)\n\t} else if maxUint == math.MaxUint32 {\n\t\terr = state.read(&size32)\n\t\tsize = uintptr(size32)\n\t} else {\n\t\tpanic(fmt.Sprintf(\"unsupported pointer size (%d)\", maxUint))\n\t}\n\tif err != nil || size == 0 {\n\t\treturn\n\t}\n\tba := make([]byte, size)\n\tif err = state.read(ba); err == nil {\n\t\ts = string(ba[:len(ba)-1])\n\t}\n\treturn\n}\n\nfunc (state *loadState) readCode() (code []instruction, err error) {\n\tn, err := state.readInt()\n\tif err != nil || n == 0 {\n\t\treturn\n\t}\n\tcode = make([]instruction, n)\n\terr = state.read(code)\n\treturn\n}\n\nfunc (state *loadState) readUpValues() (u []upValueDesc, err error) {\n\tn, err := state.readInt()\n\tif err != nil || n == 0 {\n\t\treturn\n\t}\n\tv := make([]struct{ IsLocal, Index byte }, n)\n\terr = state.read(v)\n\tif err != nil {\n\t\treturn\n\t}\n\tu = make([]upValueDesc, n)\n\tfor i := range v {\n\t\tu[i].isLocal, u[i].index = v[i].IsLocal != 0, int(v[i].Index)\n\t}\n\treturn\n}\n\nfunc (state *loadState) readLocalVariables() (localVariables []localVariable, err error) {\n\tvar n int32\n\tif n, err = state.readInt(); err != nil || n == 0 {\n\t\treturn\n\t}\n\tlocalVariables = make([]localVariable, n)\n\tfor i := range localVariables {\n\t\tif localVariables[i].name, err = state.readString(); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif localVariables[i].startPC, err = state.readPC(); err != nil {\n\t\t\treturn\n\t\t}\n\t\tif localVariables[i].endPC, err = state.readPC(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nfunc (state *loadState) readLineInfo() (lineInfo []int32, err error) {\n\tvar n int32\n\tif n, err = state.readInt(); err != nil || n == 0 {\n\t\treturn\n\t}\n\tlineInfo = make([]int32, n)\n\terr = state.read(lineInfo)\n\treturn\n}\n\nfunc (state *loadState) readDebug(p *prototype) (source string, lineInfo []int32, localVariables []localVariable, names []string, err error) {\n\tvar n int32\n\tif source, err = state.readString(); err != nil {\n\t\treturn\n\t}\n\tif lineInfo, err = state.readLineInfo(); err != nil {\n\t\treturn\n\t}\n\tif localVariables, err = state.readLocalVariables(); err != nil {\n\t\treturn\n\t}\n\tif n, err = state.readInt(); err != nil {\n\t\treturn\n\t}\n\tnames = make([]string, n)\n\tfor i := range names {\n\t\tif names[i], err = state.readString(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nfunc (state *loadState) readConstants() (constants []value, prototypes []prototype, err error) {\n\tvar n int32\n\tif n, err = state.readInt(); err != nil || n == 0 {\n\t\treturn\n\t}\n\n\tconstants = make([]value, n)\n\tfor i := range constants {\n\t\tvar t byte\n\t\tswitch t, err = state.readByte(); {\n\t\tcase err != nil:\n\t\t\treturn\n\t\tcase t == byte(TypeNil):\n\t\t\tconstants[i] = nil\n\t\tcase t == byte(TypeBoolean):\n\t\t\tconstants[i], err = state.readBool()\n\t\tcase t == byte(TypeNumber):\n\t\t\tconstants[i], err = state.readNumber()\n\t\tcase t == byte(TypeString):\n\t\t\tconstants[i], err = state.readString()\n\t\tdefault:\n\t\t\terr = errUnknownConstantType\n\t\t}\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nfunc (state *loadState) readPrototypes() (prototypes []prototype, err error) {\n\tvar n int32\n\tif n, err = state.readInt(); err != nil || n == 0 {\n\t\treturn\n\t}\n\tprototypes = make([]prototype, n)\n\tfor i := range prototypes {\n\t\tif prototypes[i], err = state.readFunction(); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\nfunc (state *loadState) readFunction() (p prototype, err error) {\n\tvar n int32\n\tif n, err = state.readInt(); err != nil {\n\t\treturn\n\t}\n\tp.lineDefined = int(n)\n\tif n, err = state.readInt(); err != nil {\n\t\treturn\n\t}\n\tp.lastLineDefined = int(n)\n\tvar b byte\n\tif b, err = state.readByte(); err != nil {\n\t\treturn\n\t}\n\tp.parameterCount = int(b)\n\tif b, err = state.readByte(); err != nil {\n\t\treturn\n\t}\n\tp.isVarArg = b != 0\n\tif b, err = state.readByte(); err != nil {\n\t\treturn\n\t}\n\tp.maxStackSize = int(b)\n\tif p.code, err = state.readCode(); err != nil {\n\t\treturn\n\t}\n\tif p.constants, p.prototypes, err = state.readConstants(); err != nil {\n\t\treturn\n\t}\n\tif p.prototypes, err = state.readPrototypes(); err != nil {\n\t\treturn\n\t}\n\tif p.upValues, err = state.readUpValues(); err != nil {\n\t\treturn\n\t}\n\tvar names []string\n\tif p.source, p.lineInfo, p.localVariables, names, err = state.readDebug(&p); err != nil {\n\t\treturn\n\t}\n\tfor i, name := range names {\n\t\tp.upValues[i].name = name\n\t}\n\treturn\n}\n\nfunc init() {\n\tcopy(header.Signature[:], Signature)\n\theader.Version = VersionMajor<<4 | VersionMinor\n\theader.Format = 0\n\tif endianness() == binary.LittleEndian {\n\t\theader.Endianness = 1\n\t} else {\n\t\theader.Endianness = 0\n\t}\n\theader.IntSize = 4\n\theader.PointerSize = byte(1+^uintptr(0)>>32&1) * 4\n\theader.InstructionSize = byte(1+^instruction(0)>>32&1) * 4\n\theader.NumberSize = 8\n\theader.IntegralNumber = 0\n\ttail := \"\\x19\\x93\\r\\n\\x1a\\n\"\n\tcopy(header.Tail[:], tail)\n\n\t// The uintptr numeric type is implementation-specific\n\tuintptrBitCount := byte(0)\n\tfor bits := ^uintptr(0); bits != 0; bits >>= 1 {\n\t\tuintptrBitCount++\n\t}\n\tif uintptrBitCount != header.PointerSize*8 {\n\t\tpanic(fmt.Sprintf(\"invalid pointer size (%d)\", uintptrBitCount))\n\t}\n}\n\nfunc endianness() binary.ByteOrder {\n\tif x := 1; *(*byte)(unsafe.Pointer(&x)) == 1 {\n\t\treturn binary.LittleEndian\n\t}\n\treturn binary.BigEndian\n}\n\nfunc (state *loadState) checkHeader() error {\n\th := header\n\tif err := state.read(&h); err != nil {\n\t\treturn err\n\t} else if h == header {\n\t\treturn nil\n\t} else if string(h.Signature[:]) != Signature {\n\t\treturn errNotPrecompiledChunk\n\t} else if h.Version != header.Version || h.Format != header.Format {\n\t\treturn errVersionMismatch\n\t} else if h.Tail != header.Tail {\n\t\treturn errCorrupted\n\t}\n\treturn errIncompatible\n}\n\nfunc (l *State) undump(in io.Reader, name string) (c *luaClosure, err error) {\n\tif name[0] == '@' || name[0] == '=' {\n\t\tname = name[1:]\n\t} else if name[0] == Signature[0] {\n\t\tname = \"binary string\"\n\t}\n\t// TODO assign name to p.source?\n\ts := &loadState{in, endianness()}\n\tvar p prototype\n\tif err = s.checkHeader(); err != nil {\n\t\treturn\n\t} else if p, err = s.readFunction(); err != nil {\n\t\treturn\n\t}\n\tc = l.newLuaClosure(&p)\n\tl.push(c)\n\treturn\n}\n"
        },
        {
          "name": "undump_test.go",
          "type": "blob",
          "size": 2.55078125,
          "content": "package lua\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestAllHeaderNoFun(t *testing.T) {\n\texpectErrorFromUndump(io.EOF, header, t)\n}\n\nfunc TestWrongEndian(t *testing.T) {\n\th := header\n\tif h.Endianness == 0 {\n\t\th.Endianness = 1\n\t} else {\n\t\th.Endianness = 0\n\t}\n\texpectErrorFromUndump(errIncompatible, h, t)\n}\n\nfunc TestWrongVersion(t *testing.T) {\n\th := header\n\th.Version += 1\n\texpectErrorFromUndump(errVersionMismatch, h, t)\n}\n\nfunc TestWrongNumberSize(t *testing.T) {\n\th := header\n\th.NumberSize /= 2\n\texpectErrorFromUndump(errIncompatible, h, t)\n}\n\nfunc TestCorruptTail(t *testing.T) {\n\th := header\n\th.Tail[3] += 1\n\texpectErrorFromUndump(errCorrupted, h, t)\n}\n\nfunc TestUndump(t *testing.T) {\n\t_, err := exec.LookPath(\"luac\")\n\tif err != nil {\n\t\tt.Skipf(\"testing undump requires luac: %s\", err)\n\t}\n\tsource := filepath.Join(\"lua-tests\", \"checktable.lua\")\n\tbinary := filepath.Join(\"lua-tests\", \"checktable.bin\")\n\tif err := exec.Command(\"luac\", \"-o\", binary, source).Run(); err != nil {\n\t\tt.Fatalf(\"luac failed to compile %s: %s\", source, err)\n\t}\n\tfile, err := os.Open(binary)\n\tif err != nil {\n\t\tt.Fatal(\"couldn't open checktable.bin\")\n\t}\n\tl := NewState()\n\tclosure, err := l.undump(file, \"test\")\n\tif err != nil {\n\t\toffset, _ := file.Seek(0, 1)\n\t\tt.Error(\"unexpected error\", err, \"at file offset\", offset)\n\t}\n\tif closure == nil {\n\t\tt.Error(\"closure was nil\")\n\t}\n\tp := closure.prototype\n\tif p == nil {\n\t\tt.Fatal(\"prototype was nil\")\n\t}\n\tvalidate(\"@lua-tests/checktable.lua\", p.source, \"as source file name\", t)\n\tvalidate(23, len(p.code), \"instructions\", t)\n\tvalidate(8, len(p.constants), \"constants\", t)\n\tvalidate(4, len(p.prototypes), \"prototypes\", t)\n\tvalidate(1, len(p.upValues), \"upvalues\", t)\n\tvalidate(0, len(p.localVariables), \"local variables\", t)\n\tvalidate(0, p.parameterCount, \"parameters\", t)\n\tvalidate(4, p.maxStackSize, \"stack slots\", t)\n\tif !p.isVarArg {\n\t\tt.Error(\"expected main function to be var arg, but wasn't\")\n\t}\n}\n\nfunc validate(expected, actual interface{}, description string, t *testing.T) {\n\tif expected != actual {\n\t\tt.Errorf(\"expected %v %s in main function but found %v\", expected, description, actual)\n\t}\n}\n\nfunc expectErrorFromUndump(expected error, data interface{}, t *testing.T) {\n\tl := NewState()\n\t_, err := l.undump(readerOn(data, t), \"test\")\n\tif err != expected {\n\t\tt.Error(\"expected\", expected, \"but got\", err)\n\t}\n}\n\nfunc readerOn(data interface{}, t *testing.T) io.Reader {\n\tbuf := new(bytes.Buffer)\n\tif err := binary.Write(buf, endianness(), data); err != nil {\n\t\tt.Fatal(\"couldn't serialize data -\", err)\n\t}\n\treturn buf\n}\n"
        },
        {
          "name": "unix.go",
          "type": "blob",
          "size": 0.30078125,
          "content": "// +build !windows\n\npackage lua\n\nimport (\n\t\"syscall\"\n)\n\nfunc clock(l *State) int {\n\tvar rusage syscall.Rusage\n\t_ = syscall.Getrusage(syscall.RUSAGE_SELF, &rusage) // ignore errors\n\tl.PushNumber(float64(rusage.Utime.Sec+rusage.Stime.Sec) + float64(rusage.Utime.Usec+rusage.Stime.Usec)/1000000.0)\n\treturn 1\n\n}\n"
        },
        {
          "name": "vm.go",
          "type": "blob",
          "size": 35.5068359375,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\nfunc (l *State) arith(rb, rc value, op tm) value {\n\tif b, ok := l.toNumber(rb); ok {\n\t\tif c, ok := l.toNumber(rc); ok {\n\t\t\treturn arith(Operator(op-tmAdd)+OpAdd, b, c)\n\t\t}\n\t}\n\tif result, ok := l.callBinaryTagMethod(rb, rc, op); ok {\n\t\treturn result\n\t}\n\tl.arithError(rb, rc)\n\treturn nil\n}\n\nfunc (l *State) tableAt(t value, key value) value {\n\tfor loop := 0; loop < maxTagLoop; loop++ {\n\t\tvar tm value\n\t\tif table, ok := t.(*table); ok {\n\t\t\tif result := table.at(key); result != nil {\n\t\t\t\treturn result\n\t\t\t} else if tm = l.fastTagMethod(table.metaTable, tmIndex); tm == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t} else if tm = l.tagMethodByObject(t, tmIndex); tm == nil {\n\t\t\tl.typeError(t, \"index\")\n\t\t}\n\t\tswitch tm.(type) {\n\t\tcase closure, *goFunction:\n\t\t\treturn l.callTagMethod(tm, t, key)\n\t\t}\n\t\tt = tm\n\t}\n\tl.runtimeError(\"loop in table\")\n\treturn nil\n}\n\nfunc (l *State) setTableAt(t value, key value, val value) {\n\tfor loop := 0; loop < maxTagLoop; loop++ {\n\t\tvar tm value\n\t\tif table, ok := t.(*table); ok {\n\t\t\tif table.tryPut(l, key, val) {\n\t\t\t\t// previous non-nil value ==> metamethod irrelevant\n\t\t\t\ttable.invalidateTagMethodCache()\n\t\t\t\treturn\n\t\t\t} else if tm = l.fastTagMethod(table.metaTable, tmNewIndex); tm == nil {\n\t\t\t\t// no metamethod\n\t\t\t\ttable.put(l, key, val)\n\t\t\t\ttable.invalidateTagMethodCache()\n\t\t\t\treturn\n\t\t\t}\n\t\t} else if tm = l.tagMethodByObject(t, tmNewIndex); tm == nil {\n\t\t\tl.typeError(t, \"index\")\n\t\t}\n\t\tswitch tm.(type) {\n\t\tcase closure, *goFunction:\n\t\t\tl.callTagMethodV(tm, t, key, val)\n\t\t\treturn\n\t\t}\n\t\tt = tm\n\t}\n\tl.runtimeError(\"loop in setTable\")\n}\n\nfunc (l *State) objectLength(v value) value {\n\tvar tm value\n\tswitch v := v.(type) {\n\tcase *table:\n\t\tif tm = l.fastTagMethod(v.metaTable, tmLen); tm == nil {\n\t\t\treturn float64(v.length())\n\t\t}\n\tcase string:\n\t\treturn float64(len(v))\n\tdefault:\n\t\tif tm = l.tagMethodByObject(v, tmLen); tm == nil {\n\t\t\tl.typeError(v, \"get length of\")\n\t\t}\n\t}\n\treturn l.callTagMethod(tm, v, v)\n}\n\nfunc (l *State) equalTagMethod(mt1, mt2 *table, event tm) value {\n\tif tm1 := l.fastTagMethod(mt1, event); tm1 == nil { // no metamethod\n\t} else if mt1 == mt2 { // same metatables => same metamethods\n\t\treturn tm1\n\t} else if tm2 := l.fastTagMethod(mt2, event); tm2 == nil { // no metamethod\n\t} else if tm1 == tm2 { // same metamethods\n\t\treturn tm1\n\t}\n\treturn nil\n}\n\nfunc (l *State) equalObjects(t1, t2 value) bool {\n\tvar tm value\n\tswitch t1 := t1.(type) {\n\tcase *userData:\n\t\tif t1 == t2 {\n\t\t\treturn true\n\t\t} else if t2, ok := t2.(*userData); ok {\n\t\t\ttm = l.equalTagMethod(t1.metaTable, t2.metaTable, tmEq)\n\t\t}\n\tcase *table:\n\t\tif t1 == t2 {\n\t\t\treturn true\n\t\t} else if t2, ok := t2.(*table); ok {\n\t\t\ttm = l.equalTagMethod(t1.metaTable, t2.metaTable, tmEq)\n\t\t}\n\tdefault:\n\t\treturn t1 == t2\n\t}\n\treturn tm != nil && !isFalse(l.callTagMethod(tm, t1, t2))\n}\n\nfunc (l *State) callBinaryTagMethod(p1, p2 value, event tm) (value, bool) {\n\ttm := l.tagMethodByObject(p1, event)\n\tif tm == nil {\n\t\ttm = l.tagMethodByObject(p2, event)\n\t}\n\tif tm == nil {\n\t\treturn nil, false\n\t}\n\treturn l.callTagMethod(tm, p1, p2), true\n}\n\nfunc (l *State) callOrderTagMethod(left, right value, event tm) (bool, bool) {\n\tresult, ok := l.callBinaryTagMethod(left, right, event)\n\treturn !isFalse(result), ok\n}\n\nfunc (l *State) lessThan(left, right value) bool {\n\tif lf, ok := left.(float64); ok {\n\t\tif rf, ok := right.(float64); ok {\n\t\t\treturn lf < rf\n\t\t}\n\t} else if ls, ok := left.(string); ok {\n\t\tif rs, ok := right.(string); ok {\n\t\t\treturn ls < rs\n\t\t}\n\t}\n\tif result, ok := l.callOrderTagMethod(left, right, tmLT); ok {\n\t\treturn result\n\t}\n\tl.orderError(left, right)\n\treturn false\n}\n\nfunc (l *State) lessOrEqual(left, right value) bool {\n\tif lf, ok := left.(float64); ok {\n\t\tif rf, ok := right.(float64); ok {\n\t\t\treturn lf <= rf\n\t\t}\n\t} else if ls, ok := left.(string); ok {\n\t\tif rs, ok := right.(string); ok {\n\t\t\treturn ls <= rs\n\t\t}\n\t}\n\tif result, ok := l.callOrderTagMethod(left, right, tmLE); ok {\n\t\treturn result\n\t} else if result, ok := l.callOrderTagMethod(right, left, tmLT); ok {\n\t\treturn !result\n\t}\n\tl.orderError(left, right)\n\treturn false\n}\n\nfunc (l *State) concat(total int) {\n\tt := func(i int) value { return l.stack[l.top-i] }\n\tput := func(i int, v value) { l.stack[l.top-i] = v }\n\tconcatTagMethod := func() {\n\t\tif v, ok := l.callBinaryTagMethod(t(2), t(1), tmConcat); !ok {\n\t\t\tl.concatError(t(2), t(1))\n\t\t} else {\n\t\t\tput(2, v)\n\t\t}\n\t}\n\tl.assert(total >= 2)\n\tfor total > 1 {\n\t\tn := 2 // # of elements handled in this pass (at least 2)\n\t\ts2, ok := t(2).(string)\n\t\tif !ok {\n\t\t\t_, ok = t(2).(float64)\n\t\t}\n\t\tif !ok {\n\t\t\tconcatTagMethod()\n\t\t} else if s1, ok := l.toString(l.top - 1); !ok {\n\t\t\tconcatTagMethod()\n\t\t} else if len(s1) == 0 {\n\t\t\tv, _ := l.toString(l.top - 2)\n\t\t\tput(2, v)\n\t\t} else if s2, ok = t(2).(string); ok && len(s2) == 0 {\n\t\t\tput(2, t(1))\n\t\t} else {\n\t\t\t// at least 2 non-empty strings; scarf as many as possible\n\t\t\tss := []string{s1}\n\t\t\tfor ; n <= total; n++ {\n\t\t\t\tif s, ok := l.toString(l.top - n); ok {\n\t\t\t\t\tss = append(ss, s)\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tn-- // last increment wasn't valid\n\t\t\tfor i, j := 0, len(ss)-1; i < j; i, j = i+1, j-1 {\n\t\t\t\tss[i], ss[j] = ss[j], ss[i]\n\t\t\t}\n\t\t\tput(len(ss), strings.Join(ss, \"\"))\n\t\t}\n\t\ttotal -= n - 1 // created 1 new string from `n` strings\n\t\tl.top -= n - 1 // popped `n` strings and pushed 1\n\t}\n}\n\nfunc (l *State) traceExecution() {\n\tcallInfo := l.callInfo\n\tmask := l.hookMask\n\tcountHook := mask&MaskCount != 0 && l.hookCount == 0\n\tif countHook {\n\t\tl.resetHookCount()\n\t}\n\tif callInfo.isCallStatus(callStatusHookYielded) {\n\t\tcallInfo.clearCallStatus(callStatusHookYielded)\n\t\treturn\n\t}\n\tif countHook {\n\t\tl.hook(HookCount, -1)\n\t}\n\tif mask&MaskLine != 0 {\n\t\tp := l.prototype(callInfo)\n\t\tnpc := callInfo.savedPC - 1\n\t\tnewline := p.lineInfo[npc]\n\t\tif npc == 0 || callInfo.savedPC <= l.oldPC || newline != p.lineInfo[l.oldPC-1] {\n\t\t\tl.hook(HookLine, int(newline))\n\t\t}\n\t}\n\tl.oldPC = callInfo.savedPC\n\tif l.shouldYield {\n\t\tif countHook {\n\t\t\tl.hookCount = 1\n\t\t}\n\t\tcallInfo.savedPC--\n\t\tcallInfo.setCallStatus(callStatusHookYielded)\n\t\tcallInfo.function = l.top - 1\n\t\tpanic(\"Not implemented - use goroutines to emulate yield\")\n\t}\n}\n\ntype engine struct {\n\tframe     []value\n\tclosure   *luaClosure\n\tconstants []value\n\tcallInfo  *callInfo\n\tl         *State\n}\n\nfunc (e *engine) k(field int) value {\n\tif field&bitRK != 0 { // OPT: Inline isConstant(field).\n\t\treturn e.constants[field & ^bitRK] // OPT: Inline constantIndex(field).\n\t}\n\treturn e.frame[field]\n}\n\nfunc (e *engine) expectNext(expected opCode) instruction {\n\ti := e.callInfo.step() // go to next instruction\n\tif op := i.opCode(); op != expected {\n\t\tpanic(fmt.Sprintf(\"expected opcode %s, got %s\", opNames[expected], opNames[op]))\n\t}\n\treturn i\n}\n\nfunc clear(r []value) {\n\tfor i := range r {\n\t\tr[i] = nil\n\t}\n}\n\nfunc (e *engine) newFrame() {\n\tci := e.callInfo\n\t// if internalCheck {\n\t// \te.l.assert(ci == e.l.callInfo.variant)\n\t// }\n\te.frame = ci.frame\n\te.closure = e.l.stack[ci.function].(*luaClosure)\n\te.constants = e.closure.prototype.constants\n}\n\nfunc (e *engine) hooked() bool { return e.l.hookMask&(MaskLine|MaskCount) != 0 }\n\nfunc (e *engine) hook() {\n\tif e.l.hookCount--; e.l.hookCount == 0 || e.l.hookMask&MaskLine != 0 {\n\t\te.l.traceExecution()\n\t\te.frame = e.callInfo.frame\n\t}\n}\n\ntype engineOp func(*engine, instruction) (engineOp, instruction)\n\nvar jumpTable []engineOp\n\nfunc init() {\n\tjumpTable = []engineOp{\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opMove\n\t\t\te.frame[i.a()] = e.frame[i.b()]\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLoadConstant\n\t\t\te.frame[i.a()] = e.constants[i.bx()]\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLoadConstantEx\n\t\t\te.frame[i.a()] = e.constants[e.expectNext(opExtraArg).ax()]\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLoadBool\n\t\t\te.frame[i.a()] = i.b() != 0\n\t\t\tif i.c() != 0 {\n\t\t\t\te.callInfo.skip()\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLoadNil\n\t\t\ta, b := i.a(), i.b()\n\t\t\tclear(e.frame[a : a+b+1])\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opGetUpValue\n\t\t\te.frame[i.a()] = e.closure.upValue(i.b())\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opGetTableUp\n\t\t\ttmp := e.l.tableAt(e.closure.upValue(i.b()), e.k(i.c()))\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opGetTable\n\t\t\ttmp := e.l.tableAt(e.frame[i.b()], e.k(i.c()))\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opSetTableUp\n\t\t\te.l.setTableAt(e.closure.upValue(i.a()), e.k(i.b()), e.k(i.c()))\n\t\t\te.frame = e.callInfo.frame\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opSetUpValue\n\t\t\te.closure.setUpValue(i.b(), e.frame[i.a()])\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opSetTable\n\t\t\te.l.setTableAt(e.frame[i.a()], e.k(i.b()), e.k(i.c()))\n\t\t\te.frame = e.callInfo.frame\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opNewTable\n\t\t\ta := i.a()\n\t\t\tif b, c := float8(i.b()), float8(i.c()); b != 0 || c != 0 {\n\t\t\t\te.frame[a] = newTableWithSize(intFromFloat8(b), intFromFloat8(c))\n\t\t\t} else {\n\t\t\t\te.frame[a] = newTable()\n\t\t\t}\n\t\t\tclear(e.frame[a+1:])\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opSelf\n\t\t\ta, t := i.a(), e.frame[i.b()]\n\t\t\ttmp := e.l.tableAt(t, e.k(i.c()))\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[a+1], e.frame[a] = t, tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opAdd\n\t\t\tb := e.k(i.b())\n\t\t\tc := e.k(i.c())\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\te.frame[i.a()] = nb + nc\n\t\t\t\t\tif e.hooked() {\n\t\t\t\t\t\te.hook()\n\t\t\t\t\t}\n\t\t\t\t\ti = e.callInfo.step()\n\t\t\t\t\treturn jumpTable[i.opCode()], i\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := e.l.arith(b, c, tmAdd)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opSub\n\t\t\tb := e.k(i.b())\n\t\t\tc := e.k(i.c())\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\te.frame[i.a()] = nb - nc\n\t\t\t\t\tif e.hooked() {\n\t\t\t\t\t\te.hook()\n\t\t\t\t\t}\n\t\t\t\t\ti = e.callInfo.step()\n\t\t\t\t\treturn jumpTable[i.opCode()], i\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := e.l.arith(b, c, tmSub)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opMul\n\t\t\tb := e.k(i.b())\n\t\t\tc := e.k(i.c())\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\te.frame[i.a()] = nb * nc\n\t\t\t\t\tif e.hooked() {\n\t\t\t\t\t\te.hook()\n\t\t\t\t\t}\n\t\t\t\t\ti = e.callInfo.step()\n\t\t\t\t\treturn jumpTable[i.opCode()], i\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := e.l.arith(b, c, tmMul)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opDiv\n\t\t\tb := e.k(i.b())\n\t\t\tc := e.k(i.c())\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\te.frame[i.a()] = nb / nc\n\t\t\t\t\tif e.hooked() {\n\t\t\t\t\t\te.hook()\n\t\t\t\t\t}\n\t\t\t\t\ti = e.callInfo.step()\n\t\t\t\t\treturn jumpTable[i.opCode()], i\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := e.l.arith(b, c, tmDiv)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opMod\n\t\t\tb := e.k(i.b())\n\t\t\tc := e.k(i.c())\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\te.frame[i.a()] = math.Mod(nb, nc)\n\t\t\t\t\tif e.hooked() {\n\t\t\t\t\t\te.hook()\n\t\t\t\t\t}\n\t\t\t\t\ti = e.callInfo.step()\n\t\t\t\t\treturn jumpTable[i.opCode()], i\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := e.l.arith(b, c, tmMod)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opPow\n\t\t\tb := e.k(i.b())\n\t\t\tc := e.k(i.c())\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\te.frame[i.a()] = math.Pow(nb, nc)\n\t\t\t\t\tif e.hooked() {\n\t\t\t\t\t\te.hook()\n\t\t\t\t\t}\n\t\t\t\t\ti = e.callInfo.step()\n\t\t\t\t\treturn jumpTable[i.opCode()], i\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := e.l.arith(b, c, tmPow)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opUnaryMinus\n\t\t\tswitch b := e.frame[i.b()].(type) {\n\t\t\tcase float64:\n\t\t\t\te.frame[i.a()] = -b\n\t\t\tdefault:\n\t\t\t\ttmp := e.l.arith(b, b, tmUnaryMinus)\n\t\t\t\te.frame = e.callInfo.frame\n\t\t\t\te.frame[i.a()] = tmp\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opNot\n\t\t\te.frame[i.a()] = isFalse(e.frame[i.b()])\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLength\n\t\t\ttmp := e.l.objectLength(e.frame[i.b()])\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[i.a()] = tmp\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opConcat\n\t\t\ta, b, c := i.a(), i.b(), i.c()\n\t\t\te.l.top = e.callInfo.stackIndex(c + 1) // mark the end of concat operands\n\t\t\te.l.concat(c - b + 1)\n\t\t\te.frame = e.callInfo.frame\n\t\t\te.frame[a] = e.frame[b]\n\t\t\tif a >= b { // limit of live values\n\t\t\t\tclear(e.frame[a+1:])\n\t\t\t} else {\n\t\t\t\tclear(e.frame[b:])\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opJump\n\t\t\tif a := i.a(); a > 0 {\n\t\t\t\te.l.close(e.callInfo.stackIndex(a - 1))\n\t\t\t}\n\t\t\te.callInfo.jump(i.sbx())\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opEqual\n\t\t\ttest := i.a() != 0\n\t\t\tresult := e.l.equalObjects(e.k(i.b()), e.k(i.c()))\n\t\t\tif result == test {\n\t\t\t\ti := e.callInfo.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\te.l.close(e.callInfo.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\te.callInfo.skip()\n\t\t\t}\n\t\t\te.frame = e.callInfo.frame\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLessThan\n\t\t\ttest := i.a() != 0\n\t\t\tresult := e.l.lessThan(e.k(i.b()), e.k(i.c()))\n\t\t\tif result == test {\n\t\t\t\ti := e.callInfo.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\te.l.close(e.callInfo.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\te.callInfo.skip()\n\t\t\t}\n\t\t\te.frame = e.callInfo.frame\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opLessOrEqual\n\t\t\ttest := i.a() != 0\n\t\t\tresult := e.l.lessOrEqual(e.k(i.b()), e.k(i.c()))\n\t\t\tif result == test {\n\t\t\t\ti := e.callInfo.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\te.l.close(e.callInfo.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\te.callInfo.skip()\n\t\t\t}\n\t\t\te.frame = e.callInfo.frame\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opTest\n\t\t\ttest := i.c() == 0\n\t\t\tif isFalse(e.frame[i.a()]) == test {\n\t\t\t\ti := e.callInfo.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\te.l.close(e.callInfo.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\te.callInfo.skip()\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opTestSet\n\t\t\tb := e.frame[i.b()]\n\t\t\ttest := i.c() == 0\n\t\t\tif isFalse(b) == test {\n\t\t\t\te.frame[i.a()] = b\n\t\t\t\ti := e.callInfo.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\te.l.close(e.callInfo.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\te.callInfo.skip()\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opCall\n\t\t\ta, b, c := i.a(), i.b(), i.c()\n\t\t\tif b != 0 {\n\t\t\t\te.l.top = e.callInfo.stackIndex(a + b)\n\t\t\t} // else previous instruction set top\n\t\t\tif n := c - 1; e.l.preCall(e.callInfo.stackIndex(a), n) { // go function\n\t\t\t\tif n >= 0 {\n\t\t\t\t\te.l.top = e.callInfo.top // adjust results\n\t\t\t\t}\n\t\t\t\te.frame = e.callInfo.frame\n\t\t\t} else { // lua function\n\t\t\t\te.callInfo = e.l.callInfo\n\t\t\t\te.callInfo.setCallStatus(callStatusReentry)\n\t\t\t\te.newFrame()\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opTailCall\n\t\t\ta, b := i.a(), i.b()\n\t\t\tif b != 0 {\n\t\t\t\te.l.top = e.callInfo.stackIndex(a + b)\n\t\t\t} // else previous instruction set top\n\t\t\t// TODO e.l.assert(i.c()-1 == MultipleReturns)\n\t\t\tif e.l.preCall(e.callInfo.stackIndex(a), MultipleReturns) { // go function\n\t\t\t\te.frame = e.callInfo.frame\n\t\t\t} else {\n\t\t\t\t// tail call: put called frame (n) in place of caller one (o)\n\t\t\t\tnci := e.l.callInfo                    // called frame\n\t\t\t\toci := nci.previous                    // caller frame\n\t\t\t\tnfn, ofn := nci.function, oci.function // called & caller function\n\t\t\t\t// last stack slot filled by 'precall'\n\t\t\t\tlim := nci.base() + e.l.stack[nfn].(*luaClosure).prototype.parameterCount\n\t\t\t\tif len(e.closure.prototype.prototypes) > 0 { // close all upvalues from previous call\n\t\t\t\t\te.l.close(oci.base())\n\t\t\t\t}\n\t\t\t\t// move new frame into old one\n\t\t\t\tfor i := 0; nfn+i < lim; i++ {\n\t\t\t\t\te.l.stack[ofn+i] = e.l.stack[nfn+i]\n\t\t\t\t}\n\t\t\t\tbase := ofn + (nci.base() - nfn)  // correct base\n\t\t\t\toci.setTop(ofn + (e.l.top - nfn)) // correct top\n\t\t\t\toci.frame = e.l.stack[base:oci.top]\n\t\t\t\toci.savedPC, oci.code = nci.savedPC, nci.code // correct code (savedPC indexes nci->code)\n\t\t\t\toci.setCallStatus(callStatusTail)             // function was tail called\n\t\t\t\te.l.top, e.l.callInfo, e.callInfo = oci.top, oci, oci\n\t\t\t\t// TODO e.l.assert(e.l.top == oci.base()+e.l.stack[ofn].(*luaClosure).prototype.maxStackSize)\n\t\t\t\t// TODO e.l.assert(&oci.frame[0] == &e.l.stack[oci.base()] && len(oci.frame) == oci.top-oci.base())\n\t\t\t\te.newFrame()\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opReturn\n\t\t\ta := i.a()\n\t\t\tif b := i.b(); b != 0 {\n\t\t\t\te.l.top = e.callInfo.stackIndex(a + b - 1)\n\t\t\t}\n\t\t\tif len(e.closure.prototype.prototypes) > 0 {\n\t\t\t\te.l.close(e.callInfo.base())\n\t\t\t}\n\t\t\tn := e.l.postCall(e.callInfo.stackIndex(a))\n\t\t\tif !e.callInfo.isCallStatus(callStatusReentry) { // ci still the called one?\n\t\t\t\treturn nil, i // external invocation: return\n\t\t\t}\n\t\t\te.callInfo = e.l.callInfo\n\t\t\tif n {\n\t\t\t\te.l.top = e.callInfo.top\n\t\t\t}\n\t\t\t// TODO l.assert(e.callInfo.code[e.callInfo.savedPC-1].opCode() == opCall)\n\t\t\te.newFrame()\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opForLoop\n\t\t\ta := i.a()\n\t\t\tindex, limit, step := e.frame[a+0].(float64), e.frame[a+1].(float64), e.frame[a+2].(float64)\n\t\t\tif index += step; (0 < step && index <= limit) || (step <= 0 && limit <= index) {\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t\te.frame[a+0] = index // update internal index...\n\t\t\t\te.frame[a+3] = index // ... and external index\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opForPrep\n\t\t\ta := i.a()\n\t\t\tif init, ok := e.l.toNumber(e.frame[a+0]); !ok {\n\t\t\t\te.l.runtimeError(\"'for' initial value must be a number\")\n\t\t\t} else if limit, ok := e.l.toNumber(e.frame[a+1]); !ok {\n\t\t\t\te.l.runtimeError(\"'for' limit must be a number\")\n\t\t\t} else if step, ok := e.l.toNumber(e.frame[a+2]); !ok {\n\t\t\t\te.l.runtimeError(\"'for' step must be a number\")\n\t\t\t} else {\n\t\t\t\te.frame[a+0], e.frame[a+1], e.frame[a+2] = init-step, limit, step\n\t\t\t\te.callInfo.jump(i.sbx())\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opTForCall\n\t\t\ta := i.a()\n\t\t\tcallBase := a + 3\n\t\t\tcopy(e.frame[callBase:callBase+3], e.frame[a:a+3])\n\t\t\tcallBase += e.callInfo.base()\n\t\t\te.l.top = callBase + 3 // function + 2 args (state and index)\n\t\t\te.l.call(callBase, i.c(), true)\n\t\t\te.frame, e.l.top = e.callInfo.frame, e.callInfo.top\n\t\t\ti = e.expectNext(opTForLoop)         // go to next instruction\n\t\t\tif a := i.a(); e.frame[a+1] != nil { // continue loop?\n\t\t\t\te.frame[a] = e.frame[a+1] // save control variable\n\t\t\t\te.callInfo.jump(i.sbx())  // jump back\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opTForLoop:\n\t\t\tif a := i.a(); e.frame[a+1] != nil { // continue loop?\n\t\t\t\te.frame[a] = e.frame[a+1] // save control variable\n\t\t\t\te.callInfo.jump(i.sbx())  // jump back\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opSetList:\n\t\t\ta, n, c := i.a(), i.b(), i.c()\n\t\t\tif n == 0 {\n\t\t\t\tn = e.l.top - e.callInfo.stackIndex(a) - 1\n\t\t\t}\n\t\t\tif c == 0 {\n\t\t\t\tc = e.expectNext(opExtraArg).ax()\n\t\t\t}\n\t\t\th := e.frame[a].(*table)\n\t\t\tstart := (c - 1) * listItemsPerFlush\n\t\t\tlast := start + n\n\t\t\tif last > len(h.array) {\n\t\t\t\th.extendArray(last)\n\t\t\t}\n\t\t\tcopy(h.array[start:last], e.frame[a+1:a+1+n])\n\t\t\te.l.top = e.callInfo.top\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opClosure\n\t\t\ta, p := i.a(), &e.closure.prototype.prototypes[i.bx()]\n\t\t\tif ncl := cached(p, e.closure.upValues, e.callInfo.base()); ncl == nil { // no match?\n\t\t\t\te.frame[a] = e.l.newClosure(p, e.closure.upValues, e.callInfo.base()) // create a new one\n\t\t\t} else {\n\t\t\t\te.frame[a] = ncl\n\t\t\t}\n\t\t\tclear(e.frame[a+1:])\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opVarArg\n\t\t\tci := e.callInfo\n\t\t\ta, b := i.a(), i.b()-1\n\t\t\tn := ci.base() - ci.function - e.closure.prototype.parameterCount - 1\n\t\t\tif b < 0 {\n\t\t\t\tb = n // get all var arguments\n\t\t\t\te.l.checkStack(n)\n\t\t\t\te.l.top = ci.base() + a + n\n\t\t\t\tif ci.top < e.l.top {\n\t\t\t\t\tci.setTop(e.l.top)\n\t\t\t\t\tci.frame = e.l.stack[ci.base():ci.top]\n\t\t\t\t}\n\t\t\t\te.frame = ci.frame\n\t\t\t}\n\t\t\tfor j := 0; j < b; j++ {\n\t\t\t\tif j < n {\n\t\t\t\t\te.frame[a+j] = e.l.stack[ci.base()-n+j]\n\t\t\t\t} else {\n\t\t\t\t\te.frame[a+j] = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\tif e.hooked() {\n\t\t\t\te.hook()\n\t\t\t}\n\t\t\ti = e.callInfo.step()\n\t\t\treturn jumpTable[i.opCode()], i\n\t\t},\n\t\tfunc(e *engine, i instruction) (engineOp, instruction) { // opExtraArg\n\t\t\tpanic(fmt.Sprintf(\"unexpected opExtraArg instruction, '%s'\", i.String()))\n\t\t},\n\t}\n}\n\nfunc (l *State) execute() { l.executeFunctionTable() }\n\nfunc (l *State) executeFunctionTable() {\n\tci := l.callInfo\n\tclosure, _ := l.stack[ci.function].(*luaClosure)\n\te := engine{callInfo: ci, frame: ci.frame, closure: closure, constants: closure.prototype.constants, l: l}\n\tif l.hookMask&(MaskLine|MaskCount) != 0 {\n\t\tif l.hookCount--; l.hookCount == 0 || l.hookMask&MaskLine != 0 {\n\t\t\tl.traceExecution()\n\t\t\te.frame = e.callInfo.frame\n\t\t}\n\t}\n\ti := e.callInfo.step()\n\tf := jumpTable[i.opCode()]\n\tfor f, i = f(&e, i); f != nil; f, i = f(&e, i) {\n\t}\n}\n\nfunc k(field int, constants []value, frame []value) value {\n\tif 0 != field&bitRK { // OPT: Inline isConstant(field).\n\t\treturn constants[field & ^bitRK] // OPT: Inline constantIndex(field).\n\t}\n\treturn frame[field]\n}\n\nfunc newFrame(l *State, ci *callInfo) (frame []value, closure *luaClosure, constants []value) {\n\t// TODO l.assert(ci == l.callInfo)\n\tframe = ci.frame\n\tclosure, _ = l.stack[ci.function].(*luaClosure)\n\tconstants = closure.prototype.constants\n\treturn\n}\n\nfunc expectNext(ci *callInfo, expected opCode) instruction {\n\ti := ci.step() // go to next instruction\n\tif op := i.opCode(); op != expected {\n\t\tpanic(fmt.Sprintf(\"expected opcode %s, got %s\", opNames[expected], opNames[op]))\n\t}\n\treturn i\n}\n\nfunc (l *State) executeSwitch() {\n\tci := l.callInfo\n\tframe, closure, constants := newFrame(l, ci)\n\tfor {\n\t\tif l.hookMask&(MaskLine|MaskCount) != 0 {\n\t\t\tif l.hookCount--; l.hookCount == 0 || l.hookMask&MaskLine != 0 {\n\t\t\t\tl.traceExecution()\n\t\t\t\tframe = ci.frame\n\t\t\t}\n\t\t}\n\t\tswitch i := ci.step(); i.opCode() {\n\t\tcase opMove:\n\t\t\tframe[i.a()] = frame[i.b()]\n\t\tcase opLoadConstant:\n\t\t\tframe[i.a()] = constants[i.bx()]\n\t\tcase opLoadConstantEx:\n\t\t\tframe[i.a()] = constants[expectNext(ci, opExtraArg).ax()]\n\t\tcase opLoadBool:\n\t\t\tframe[i.a()] = i.b() != 0\n\t\t\tif i.c() != 0 {\n\t\t\t\tci.skip()\n\t\t\t}\n\t\tcase opLoadNil:\n\t\t\ta, b := i.a(), i.b()\n\t\t\tclear(frame[a : a+b+1])\n\t\tcase opGetUpValue:\n\t\t\tframe[i.a()] = closure.upValue(i.b())\n\t\tcase opGetTableUp:\n\t\t\ttmp := l.tableAt(closure.upValue(i.b()), k(i.c(), constants, frame))\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opGetTable:\n\t\t\ttmp := l.tableAt(frame[i.b()], k(i.c(), constants, frame))\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opSetTableUp:\n\t\t\tl.setTableAt(closure.upValue(i.a()), k(i.b(), constants, frame), k(i.c(), constants, frame))\n\t\t\tframe = ci.frame\n\t\tcase opSetUpValue:\n\t\t\tclosure.setUpValue(i.b(), frame[i.a()])\n\t\tcase opSetTable:\n\t\t\tl.setTableAt(frame[i.a()], k(i.b(), constants, frame), k(i.c(), constants, frame))\n\t\t\tframe = ci.frame\n\t\tcase opNewTable:\n\t\t\ta := i.a()\n\t\t\tif b, c := float8(i.b()), float8(i.c()); b != 0 || c != 0 {\n\t\t\t\tframe[a] = newTableWithSize(intFromFloat8(b), intFromFloat8(c))\n\t\t\t} else {\n\t\t\t\tframe[a] = newTable()\n\t\t\t}\n\t\t\tclear(frame[a+1:])\n\t\tcase opSelf:\n\t\t\ta, t := i.a(), frame[i.b()]\n\t\t\ttmp := l.tableAt(t, k(i.c(), constants, frame))\n\t\t\tframe = ci.frame\n\t\t\tframe[a+1], frame[a] = t, tmp\n\t\tcase opAdd:\n\t\t\tb := k(i.b(), constants, frame)\n\t\t\tc := k(i.c(), constants, frame)\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\tframe[i.a()] = nb + nc\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := l.arith(b, c, tmAdd)\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opSub:\n\t\t\tb := k(i.b(), constants, frame)\n\t\t\tc := k(i.c(), constants, frame)\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\tframe[i.a()] = nb - nc\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := l.arith(b, c, tmSub)\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opMul:\n\t\t\tb := k(i.b(), constants, frame)\n\t\t\tc := k(i.c(), constants, frame)\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\tframe[i.a()] = nb * nc\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := l.arith(b, c, tmMul)\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opDiv:\n\t\t\tb := k(i.b(), constants, frame)\n\t\t\tc := k(i.c(), constants, frame)\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\tframe[i.a()] = nb / nc\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := l.arith(b, c, tmDiv)\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opMod:\n\t\t\tb := k(i.b(), constants, frame)\n\t\t\tc := k(i.c(), constants, frame)\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\tframe[i.a()] = math.Mod(nb, nc)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := l.arith(b, c, tmMod)\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opPow:\n\t\t\tb := k(i.b(), constants, frame)\n\t\t\tc := k(i.c(), constants, frame)\n\t\t\tif nb, ok := b.(float64); ok {\n\t\t\t\tif nc, ok := c.(float64); ok {\n\t\t\t\t\tframe[i.a()] = math.Pow(nb, nc)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp := l.arith(b, c, tmPow)\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opUnaryMinus:\n\t\t\tswitch b := frame[i.b()].(type) {\n\t\t\tcase float64:\n\t\t\t\tframe[i.a()] = -b\n\t\t\tdefault:\n\t\t\t\ttmp := l.arith(b, b, tmUnaryMinus)\n\t\t\t\tframe = ci.frame\n\t\t\t\tframe[i.a()] = tmp\n\t\t\t}\n\t\tcase opNot:\n\t\t\tframe[i.a()] = isFalse(frame[i.b()])\n\t\tcase opLength:\n\t\t\ttmp := l.objectLength(frame[i.b()])\n\t\t\tframe = ci.frame\n\t\t\tframe[i.a()] = tmp\n\t\tcase opConcat:\n\t\t\ta, b, c := i.a(), i.b(), i.c()\n\t\t\tl.top = ci.stackIndex(c + 1) // mark the end of concat operands\n\t\t\tl.concat(c - b + 1)\n\t\t\tframe = ci.frame\n\t\t\tframe[a] = frame[b]\n\t\t\tif a >= b { // limit of live values\n\t\t\t\tclear(frame[a+1:])\n\t\t\t} else {\n\t\t\t\tclear(frame[b:])\n\t\t\t}\n\t\tcase opJump:\n\t\t\tif a := i.a(); a > 0 {\n\t\t\t\tl.close(ci.stackIndex(a - 1))\n\t\t\t}\n\t\t\tci.jump(i.sbx())\n\t\tcase opEqual:\n\t\t\ttest := i.a() != 0\n\t\t\tif l.equalObjects(k(i.b(), constants, frame), k(i.c(), constants, frame)) == test {\n\t\t\t\ti := ci.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\tl.close(ci.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\tci.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\tci.skip()\n\t\t\t}\n\t\t\tframe = ci.frame\n\t\tcase opLessThan:\n\t\t\ttest := i.a() != 0\n\t\t\tif l.lessThan(k(i.b(), constants, frame), k(i.c(), constants, frame)) == test {\n\t\t\t\ti := ci.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\tl.close(ci.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\tci.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\tci.skip()\n\t\t\t}\n\t\t\tframe = ci.frame\n\t\tcase opLessOrEqual:\n\t\t\ttest := i.a() != 0\n\t\t\tif l.lessOrEqual(k(i.b(), constants, frame), k(i.c(), constants, frame)) == test {\n\t\t\t\ti := ci.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\tl.close(ci.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\tci.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\tci.skip()\n\t\t\t}\n\t\t\tframe = ci.frame\n\t\tcase opTest:\n\t\t\ttest := i.c() == 0\n\t\t\tif isFalse(frame[i.a()]) == test {\n\t\t\t\ti := ci.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\tl.close(ci.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\tci.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\tci.skip()\n\t\t\t}\n\t\tcase opTestSet:\n\t\t\tb := frame[i.b()]\n\t\t\ttest := i.c() == 0\n\t\t\tif isFalse(b) == test {\n\t\t\t\tframe[i.a()] = b\n\t\t\t\ti := ci.step()\n\t\t\t\tif a := i.a(); a > 0 {\n\t\t\t\t\tl.close(ci.stackIndex(a - 1))\n\t\t\t\t}\n\t\t\t\tci.jump(i.sbx())\n\t\t\t} else {\n\t\t\t\tci.skip()\n\t\t\t}\n\t\tcase opCall:\n\t\t\ta, b, c := i.a(), i.b(), i.c()\n\t\t\tif b != 0 {\n\t\t\t\tl.top = ci.stackIndex(a + b)\n\t\t\t} // else previous instruction set top\n\t\t\tif n := c - 1; l.preCall(ci.stackIndex(a), n) { // go function\n\t\t\t\tif n >= 0 {\n\t\t\t\t\tl.top = ci.top // adjust results\n\t\t\t\t}\n\t\t\t\tframe = ci.frame\n\t\t\t} else { // lua function\n\t\t\t\tci = l.callInfo\n\t\t\t\tci.setCallStatus(callStatusReentry)\n\t\t\t\tframe, closure, constants = newFrame(l, ci)\n\t\t\t}\n\t\tcase opTailCall:\n\t\t\ta, b := i.a(), i.b()\n\t\t\tif b != 0 {\n\t\t\t\tl.top = ci.stackIndex(a + b)\n\t\t\t} // else previous instruction set top\n\t\t\t// TODO l.assert(i.c()-1 == MultipleReturns)\n\t\t\tif l.preCall(ci.stackIndex(a), MultipleReturns) { // go function\n\t\t\t\tframe = ci.frame\n\t\t\t} else {\n\t\t\t\t// tail call: put called frame (n) in place of caller one (o)\n\t\t\t\tnci := l.callInfo                      // called frame\n\t\t\t\toci := nci.previous                    // caller frame\n\t\t\t\tnfn, ofn := nci.function, oci.function // called & caller function\n\t\t\t\t// last stack slot filled by 'precall'\n\t\t\t\tlim := nci.base() + l.stack[nfn].(*luaClosure).prototype.parameterCount\n\t\t\t\tif len(closure.prototype.prototypes) > 0 { // close all upvalues from previous call\n\t\t\t\t\tl.close(oci.base())\n\t\t\t\t}\n\t\t\t\t// move new frame into old one\n\t\t\t\tfor i := 0; nfn+i < lim; i++ {\n\t\t\t\t\tl.stack[ofn+i] = l.stack[nfn+i]\n\t\t\t\t}\n\t\t\t\tbase := ofn + (nci.base() - nfn) // correct base\n\t\t\t\toci.setTop(ofn + (l.top - nfn))  // correct top\n\t\t\t\toci.frame = l.stack[base:oci.top]\n\t\t\t\toci.savedPC, oci.code = nci.savedPC, nci.code // correct code (savedPC indexes nci->code)\n\t\t\t\toci.setCallStatus(callStatusTail)             // function was tail called\n\t\t\t\tl.top, l.callInfo, ci = oci.top, oci, oci\n\t\t\t\t// TODO l.assert(l.top == oci.base()+l.stack[ofn].(*luaClosure).prototype.maxStackSize)\n\t\t\t\t// TODO l.assert(&oci.frame[0] == &l.stack[oci.base()] && len(oci.frame) == oci.top-oci.base())\n\t\t\t\tframe, closure, constants = newFrame(l, ci)\n\t\t\t}\n\t\tcase opReturn:\n\t\t\ta := i.a()\n\t\t\tif b := i.b(); b != 0 {\n\t\t\t\tl.top = ci.stackIndex(a + b - 1)\n\t\t\t}\n\t\t\tif len(closure.prototype.prototypes) > 0 {\n\t\t\t\tl.close(ci.base())\n\t\t\t}\n\t\t\tn := l.postCall(ci.stackIndex(a))\n\t\t\tif !ci.isCallStatus(callStatusReentry) { // ci still the called one?\n\t\t\t\treturn // external invocation: return\n\t\t\t}\n\t\t\tci = l.callInfo\n\t\t\tif n {\n\t\t\t\tl.top = ci.top\n\t\t\t}\n\t\t\t// TODO l.assert(ci.code[ci.savedPC-1].opCode() == opCall)\n\t\t\tframe, closure, constants = newFrame(l, ci)\n\t\tcase opForLoop:\n\t\t\ta := i.a()\n\t\t\tindex, limit, step := frame[a+0].(float64), frame[a+1].(float64), frame[a+2].(float64)\n\t\t\tif index += step; (0 < step && index <= limit) || (step <= 0 && limit <= index) {\n\t\t\t\tci.jump(i.sbx())\n\t\t\t\tframe[a+0] = index // update internal index...\n\t\t\t\tframe[a+3] = index // ... and external index\n\t\t\t}\n\t\tcase opForPrep:\n\t\t\ta := i.a()\n\t\t\tif init, ok := l.toNumber(frame[a+0]); !ok {\n\t\t\t\tl.runtimeError(\"'for' initial value must be a number\")\n\t\t\t} else if limit, ok := l.toNumber(frame[a+1]); !ok {\n\t\t\t\tl.runtimeError(\"'for' limit must be a number\")\n\t\t\t} else if step, ok := l.toNumber(frame[a+2]); !ok {\n\t\t\t\tl.runtimeError(\"'for' step must be a number\")\n\t\t\t} else {\n\t\t\t\tframe[a+0], frame[a+1], frame[a+2] = init-step, limit, step\n\t\t\t\tci.jump(i.sbx())\n\t\t\t}\n\t\tcase opTForCall:\n\t\t\ta := i.a()\n\t\t\tcallBase := a + 3\n\t\t\tcopy(frame[callBase:callBase+3], frame[a:a+3])\n\t\t\tcallBase += ci.base()\n\t\t\tl.top = callBase + 3 // function + 2 args (state and index)\n\t\t\tl.call(callBase, i.c(), true)\n\t\t\tframe, l.top = ci.frame, ci.top\n\t\t\ti = expectNext(ci, opTForLoop) // go to next instruction\n\t\t\tfallthrough\n\t\tcase opTForLoop:\n\t\t\tif a := i.a(); frame[a+1] != nil { // continue loop?\n\t\t\t\tframe[a] = frame[a+1] // save control variable\n\t\t\t\tci.jump(i.sbx())      // jump back\n\t\t\t}\n\t\tcase opSetList:\n\t\t\ta, n, c := i.a(), i.b(), i.c()\n\t\t\tif n == 0 {\n\t\t\t\tn = l.top - ci.stackIndex(a) - 1\n\t\t\t}\n\t\t\tif c == 0 {\n\t\t\t\tc = expectNext(ci, opExtraArg).ax()\n\t\t\t}\n\t\t\th := frame[a].(*table)\n\t\t\tstart := (c - 1) * listItemsPerFlush\n\t\t\tlast := start + n\n\t\t\tif last > len(h.array) {\n\t\t\t\th.extendArray(last)\n\t\t\t}\n\t\t\tcopy(h.array[start:last], frame[a+1:a+1+n])\n\t\t\tl.top = ci.top\n\t\tcase opClosure:\n\t\t\ta, p := i.a(), &closure.prototype.prototypes[i.bx()]\n\t\t\tif ncl := cached(p, closure.upValues, ci.base()); ncl == nil { // no match?\n\t\t\t\tframe[a] = l.newClosure(p, closure.upValues, ci.base()) // create a new one\n\t\t\t} else {\n\t\t\t\tframe[a] = ncl\n\t\t\t}\n\t\t\tclear(frame[a+1:])\n\t\tcase opVarArg:\n\t\t\ta, b := i.a(), i.b()-1\n\t\t\tn := ci.base() - ci.function - closure.prototype.parameterCount - 1\n\t\t\tif b < 0 {\n\t\t\t\tb = n // get all var arguments\n\t\t\t\tl.checkStack(n)\n\t\t\t\tl.top = ci.base() + a + n\n\t\t\t\tif ci.top < l.top {\n\t\t\t\t\tci.setTop(l.top)\n\t\t\t\t\tci.frame = l.stack[ci.base():ci.top]\n\t\t\t\t}\n\t\t\t\tframe = ci.frame\n\t\t\t}\n\t\t\tfor j := 0; j < b; j++ {\n\t\t\t\tif j < n {\n\t\t\t\t\tframe[a+j] = l.stack[ci.base()-n+j]\n\t\t\t\t} else {\n\t\t\t\t\tframe[a+j] = nil\n\t\t\t\t}\n\t\t\t}\n\t\tcase opExtraArg:\n\t\t\tpanic(fmt.Sprintf(\"unexpected opExtraArg instruction, '%s'\", i.String()))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "vm_test.go",
          "type": "blob",
          "size": 11.2529296875,
          "content": "package lua\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc testString(t *testing.T, s string) { testStringHelper(t, s, false) }\n\n// Commented out to avoid a warning relating to the method not being used. Left here since it's useful for debugging.\n//func traceString(t *testing.T, s string) { testStringHelper(t, s, true) }\n\nfunc testNoPanicString(t *testing.T, s string) {\n\tdefer func() {\n\t\tif rc := recover(); rc != nil {\n\t\t\tvar buffer [8192]byte\n\t\t\tt.Errorf(\"got panic %v; expected none\", rc)\n\t\t\tt.Logf(\"trace:\\n%s\", buffer[:runtime.Stack(buffer[:], false)])\n\t\t}\n\t}()\n\ttestStringHelper(t, s, false)\n}\n\nfunc testStringHelper(t *testing.T, s string, trace bool) {\n\tl := NewState()\n\tOpenLibraries(l)\n\tLoadString(l, s)\n\tif trace {\n\t\tSetDebugHook(l, func(state *State, ar Debug) {\n\t\t\tci := state.callInfo\n\t\t\tp := state.prototype(ci)\n\t\t\tprintln(stack(state.stack[ci.base():state.top]))\n\t\t\tprintln(ci.code[ci.savedPC].String(), p.source, p.lineInfo[ci.savedPC])\n\t\t}, MaskCount, 1)\n\t}\n\tl.Call(0, 0)\n}\n\nfunc TestProtectedCall(t *testing.T) {\n\tl := NewState()\n\tOpenLibraries(l)\n\tSetDebugHook(l, func(state *State, ar Debug) {\n\t\tci := state.callInfo\n\t\t_ = stack(state.stack[ci.base():state.top])\n\t\t_ = ci.code[ci.savedPC].String()\n\t}, MaskCount, 1)\n\tLoadString(l, \"assert(not pcall(bit32.band, {}))\")\n\tl.Call(0, 0)\n}\n\nfunc TestLua(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tnonPort bool\n\t}{\n\t\t{name: \"attrib\", nonPort: true},\n\t\t// {name: \"big\"},\n\t\t{name: \"bitwise\"},\n\t\t// {name: \"calls\"},\n\t\t// {name: \"checktable\"},\n\t\t{name: \"closure\"},\n\t\t// {name: \"code\"},\n\t\t// {name: \"constructs\"},\n\t\t// {name: \"db\"},\n\t\t// {name: \"errors\"},\n\t\t{name: \"events\"},\n\t\t// {name: \"files\"},\n\t\t// {name: \"gc\"},\n\t\t{name: \"goto\"},\n\t\t// {name: \"literals\"},\n\t\t{name: \"locals\"},\n\t\t// {name: \"main\"},\n\t\t{name: \"math\"},\n\t\t// {name: \"nextvar\"},\n\t\t// {name: \"pm\"},\n\t\t{name: \"sort\", nonPort: true}, // sort.lua depends on os.clock(), which is not yet implemented on Windows.\n\t\t{name: \"strings\"},\n\t\t// {name: \"vararg\"},\n\t\t// {name: \"verybig\"},\n\t}\n\tfor _, v := range tests {\n\t\tif v.nonPort && runtime.GOOS == \"windows\" {\n\t\t\tt.Skipf(\"'%s' skipped because it's non-portable & we're running Windows\", v.name)\n\t\t}\n\t\tt.Log(v)\n\t\tl := NewState()\n\t\tOpenLibraries(l)\n\t\tfor _, s := range []string{\"_port\", \"_no32\", \"_noformatA\"} {\n\t\t\tl.PushBoolean(true)\n\t\t\tl.SetGlobal(s)\n\t\t}\n\t\tif v.nonPort {\n\t\t\tl.PushBoolean(false)\n\t\t\tl.SetGlobal(\"_port\")\n\t\t}\n\t\t// l.SetDebugHook(func(state *State, ar Debug) {\n\t\t// \tci := state.callInfo.(*luaCallInfo)\n\t\t// \tp := state.prototype(ci)\n\t\t// \tprintln(stack(state.stack[ci.base():state.top]))\n\t\t// \tprintln(ci.code[ci.savedPC].String(), p.source, p.lineInfo[ci.savedPC])\n\t\t// }, MaskCount, 1)\n\t\tl.Global(\"debug\")\n\t\tl.Field(-1, \"traceback\")\n\t\ttraceback := l.Top()\n\t\t// t.Logf(\"%#v\", l.ToValue(traceback))\n\t\tif err := LoadFile(l, filepath.Join(\"lua-tests\", v.name+\".lua\"), \"text\"); err != nil {\n\t\t\tt.Errorf(\"'%s' failed: %s\", v.name, err.Error())\n\t\t}\n\t\t// l.Call(0, 0)\n\t\tif err := l.ProtectedCall(0, 0, traceback); err != nil {\n\t\t\tt.Errorf(\"'%s' failed: %s\", v.name, err.Error())\n\t\t}\n\t}\n}\n\nfunc benchmarkSort(b *testing.B, program string) {\n\tl := NewState()\n\tOpenLibraries(l)\n\ts := `a = {}\n\t\tfor i=1,%d do\n\t\t\ta[i] = math.random()\n\t\tend`\n\tLoadString(l, fmt.Sprintf(s, b.N))\n\tif err := l.ProtectedCall(0, 0, 0); err != nil {\n\t\tb.Error(err.Error())\n\t}\n\tLoadString(l, program)\n\tb.ResetTimer()\n\tif err := l.ProtectedCall(0, 0, 0); err != nil {\n\t\tb.Error(err.Error())\n\t}\n}\n\nfunc BenchmarkSort(b *testing.B) { benchmarkSort(b, \"table.sort(a)\") }\nfunc BenchmarkSort2(b *testing.B) {\n\tbenchmarkSort(b, \"i = 0; table.sort(a, function(x,y) i=i+1; return y<x end)\")\n}\n\nfunc BenchmarkFibonnaci(b *testing.B) {\n\tl := NewState()\n\ts := `return function(n)\n\t\t\tif n == 0 then\n\t\t\t\treturn 0\n\t\t\telseif n == 1 then\n\t\t\t\treturn 1\n\t\t\tend\n\t\t\tlocal n0, n1 = 0, 1\n\t\t\tfor i = n, 2, -1 do\n\t\t\t\tlocal tmp = n0 + n1\n\t\t\t\tn0 = n1\n\t\t\t\tn1 = tmp\n\t\t\tend\n\t\t\treturn n1\n\t\tend`\n\tLoadString(l, s)\n\tif err := l.ProtectedCall(0, 1, 0); err != nil {\n\t\tb.Error(err.Error())\n\t}\n\tl.PushInteger(b.N)\n\tb.ResetTimer()\n\tif err := l.ProtectedCall(1, 1, 0); err != nil {\n\t\tb.Error(err.Error())\n\t}\n}\n\n// TestTailCallRecursive tests for failures where both the callee and caller are making a tailcall.\nfunc TestTailCallRecursive(t *testing.T) {\n\ts := `function tailcall(n, m)\n\t\t\tif n > m then return n end\n\t\t\treturn tailcall(n + 1, m)\n\t\tend\n\t\treturn tailcall(0, 5)`\n\ttestNoPanicString(t, s)\n}\n\n// TestTailCallRecursiveDiffFn tests for failures where only the caller is making a tailcall.\nfunc TestTailCallRecursiveDiffFn(t *testing.T) {\n\ts := `function tailcall(n) return n+1 end\n\t\treturn tailcall(5)`\n\ttestNoPanicString(t, s)\n}\n\n// TestTailCallSameFn tests for failures where only the callee is making a tailcall.\nfunc TestTailCallSameFn(t *testing.T) {\n\ts := `function tailcall(n, m)\n\t\t\tif n > m then return n end\n\t\t\treturn tailcall(n + 1, m)\n\t\tend\n\t\treturn (tailcall(0, 5))`\n\ttestNoPanicString(t, s)\n}\n\n// TestNoTailCall tests for failures when neither callee nor caller make a tailcall.\nfunc TestNormalCall(t *testing.T) {\n\ts := `function notailcall() return 5 end\n\t\treturn (notailcall())`\n\ttestNoPanicString(t, s)\n}\n\nfunc TestVarArgMeta(t *testing.T) {\n\ts := `function f(t, ...) return t, {...} end\n\t\tlocal a = setmetatable({}, {__call = f})\n\t\tlocal x, y = a(table.unpack{\"a\", 1})\n\t\tassert(#x == 0)\n\t\tassert(#y == 2 and y[1] == \"a\" and y[2] == 1)`\n\ttestString(t, s)\n}\n\nfunc TestCanRemoveNilObjectFromStack(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Fatalf(\"failed to remove `nil`, %v\", r)\n\t\t}\n\t}()\n\n\tl := NewState()\n\tl.PushString(\"hello\")\n\tl.Remove(-1)\n\tl.PushNil()\n\tl.Remove(-1)\n}\n\nfunc TestTableUserdataEquality(t *testing.T) {\n\tconst s = `return function(x)\n\t\tlocal b = x == {}\n\t\tassert(type(b) == \"boolean\")\n\t\tassert(b == false)\n\t\t-- reverse\n\t\tb = {} == x\n\t\tassert(type(b) == \"boolean\")\n\t\tassert(b == false)\n\tend`\n\n\tl := NewState()\n\tOpenLibraries(l)\n\tLoadString(l, s)\n\tif err := l.ProtectedCall(0, 1, 0); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tl.PushUserData(5)\n\tif err := l.ProtectedCall(1, 0, 0); err != nil {\n\t\tt.Error(err.Error())\n\t}\n}\n\nfunc TestUserDataEqualityNil(t *testing.T) {\n\tconst s = `return function(x)\n\t\tlocal b = x == nil\n\t\tassert(type(b) == \"boolean\")\n\t\tassert(b == false)\n\tend`\n\n\tl := NewState()\n\tOpenLibraries(l)\n\tLoadString(l, s)\n\tif err := l.ProtectedCall(0, 1, 0); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tl.PushUserData(5)\n\tif err := l.ProtectedCall(1, 0, 0); err != nil {\n\t\tt.Error(err.Error())\n\t}\n}\n\nfunc TestTableEqualityNil(t *testing.T) {\n\tconst s = `local b = {} == nil\n\tassert(type(b) == \"boolean\")\n\tassert(b == false)`\n\n\ttestString(t, s)\n}\n\nfunc TestTableNext(t *testing.T) {\n\tl := NewState()\n\tOpenLibraries(l)\n\tl.CreateTable(10, 0)\n\tfor i := 1; i <= 4; i++ {\n\t\tl.PushInteger(i)\n\t\tl.PushValue(-1)\n\t\tl.SetTable(-3)\n\t}\n\tif length := LengthEx(l, -1); length != 4 {\n\t\tt.Errorf(\"expected table length to be 4, but was %d\", length)\n\t}\n\tcount := 0\n\tfor l.PushNil(); l.Next(-2); count++ {\n\t\tif k, v := CheckInteger(l, -2), CheckInteger(l, -1); k != v {\n\t\t\tt.Errorf(\"key %d != value %d\", k, v)\n\t\t}\n\t\tl.Pop(1)\n\t}\n\tif count != 4 {\n\t\tt.Errorf(\"incorrect iteration count %d in Next()\", count)\n\t}\n}\n\nfunc TestError(t *testing.T) {\n\tl := NewState()\n\tBaseOpen(l)\n\terrorHandled := false\n\tprogram := \"error('error')\"\n\tl.PushGoFunction(func(l *State) int {\n\t\tif l.Top() == 0 {\n\t\t\tt.Error(\"error handler received no arguments\")\n\t\t} else if errorMessage, ok := l.ToString(-1); !ok {\n\t\t\tt.Errorf(\"error handler received %s instead of string\", TypeNameOf(l, -1))\n\t\t} else if errorMessage != chunkID(program)+\":1: error\" {\n\t\t\tt.Errorf(\"error handler received '%s' instead of 'error'\", errorMessage)\n\t\t}\n\t\terrorHandled = true\n\t\treturn 1\n\t})\n\tLoadString(l, program)\n\tl.ProtectedCall(0, 0, -2)\n\tif !errorHandled {\n\t\tt.Error(\"error not handled\")\n\t}\n}\n\nfunc TestErrorf(t *testing.T) {\n\tl := NewState()\n\tBaseOpen(l)\n\tprogram := \"-- script that is bigger than the max ID size\\nhelper()\\n\" + strings.Repeat(\"--\", idSize)\n\texpectedErrorMessage := chunkID(program) + \":2: error\"\n\tl.PushGoFunction(func(l *State) int {\n\t\tErrorf(l, \"error\")\n\t\treturn 0\n\t})\n\tl.SetGlobal(\"helper\")\n\terrorHandled := false\n\tl.PushGoFunction(func(l *State) int {\n\t\tif l.Top() == 0 {\n\t\t\tt.Error(\"error handler received no arguments\")\n\t\t} else if errorMessage, ok := l.ToString(-1); !ok {\n\t\t\tt.Errorf(\"error handler received %s instead of string\", TypeNameOf(l, -1))\n\t\t} else if errorMessage != expectedErrorMessage {\n\t\t\tt.Errorf(\"error handler received '%s' instead of '%s'\", errorMessage, expectedErrorMessage)\n\t\t}\n\t\terrorHandled = true\n\t\treturn 1\n\t})\n\tLoadString(l, program)\n\tl.ProtectedCall(0, 0, -2)\n\tif !errorHandled {\n\t\tt.Error(\"error not handled\")\n\t}\n}\n\nfunc TestPairsSplit(t *testing.T) {\n\ttestString(t, `\n\tlocal t = {}\n\t-- first two keys go into array\n\tt[1] = true\n\tt[2] = true\n\t-- next key forced into map instead of array since it's non-sequential\n\tt[16] = true\n\t-- next key inserted into array\n\tt[3] = true\n\n\tlocal keys = {}\n\tfor k, v in pairs(t) do\n\t\tkeys[#keys + 1] = k\n\tend\n\n\ttable.sort(keys)\n\tassert(keys[1] == 1, 'got ' .. tostring(keys[1]) .. '; want 1')\n\tassert(keys[2] == 2, 'got ' .. tostring(keys[2]) .. '; want 2')\n\tassert(keys[3] == 3, 'got ' .. tostring(keys[3]) .. '; want 3')\n\tassert(keys[4] == 16, 'got ' .. tostring(keys[4]) .. '; want 16')\n\t`)\n}\n\nfunc TestConcurrentNext(t *testing.T) {\n\ttestString(t, `\n\tt = {}\n\tt[1], t[2], t[3] = true, true, true\n\n\touter = {}\n\tfor k1 in pairs(t) do\n\t\ttable.insert(outer, k1)\n\t\tinner = {}\n\t\tfor k2 in pairs(t) do\n\t\t\ttable.insert(inner, k2)\n\t\tend\n\t\ttable.sort(inner)\n\t\tgot = table.concat(inner, '')\n\t\tassert(got == '123', 'got ' .. got .. '; want 123')\n\tend\n\n\ttable.sort(outer)\n\tgot = table.concat(outer, '')\n\tassert(got == '123', 'got ' .. got .. '; want 123')\n\t`)\n}\n\nfunc TestLocIsCorrectOnRegisteredFuncCall(t *testing.T) {\n\tl := NewState()\n\tl.Register(\"barf\", func(l *State) int {\n\t\tErrorf(l, \"Boom!\")\n\t\treturn 0\n\t})\n\tif err := l.Load(strings.NewReader(`\n\t\t\tlocal thing = barf()  -- line 2; is the source of the error\n\t\t\tprint(thing)          -- line 3; this won't execute, and must NOT be the loc of the error!\n\t\t\t`), \"test\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error! Got %v\", err)\n\t}\n\terr := l.ProtectedCall(0, 0, 0)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error! Got none... :(\")\n\t} else {\n\t\tif err.Error() != \"runtime error: [string \\\"test\\\"]:2: Boom!\" {\n\t\t\tt.Errorf(\"Wrong error reported: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestLocIsCorrectOnFuncCall(t *testing.T) {\n\tl := NewState()\n\tif err := l.Load(strings.NewReader(`\n\t\t\tfunction barf()\n\t\t\t\ta = 3 + 2\n\t\t\t\tisNotDefined(\"Boom!\", a)  -- line 4; is the source of the error\n\t\t\tend\n\t\t\tbarf()                        -- line 6\n\t\t\t`), \"test\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error! Got %v\", err)\n\t}\n\terr := l.ProtectedCall(0, 0, 0)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error! Got none... :(\")\n\t} else {\n\t\tif err.Error() != \"runtime error: [string \\\"test\\\"]:4: attempt to call a nil value\" {\n\t\t\tt.Errorf(\"Wrong error reported: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestLocIsCorrectOnError(t *testing.T) {\n\tl := NewState()\n\tif err := l.Load(strings.NewReader(`\n\t\t\ta = 3 - 3\n\t\t\tb = 3 / q  -- line 3; errs!\n\t\t\t`), \"test\", \"\"); err != nil {\n\t\tt.Errorf(\"Unexpected error! Got %v\", err)\n\t}\n\terr := l.ProtectedCall(0, 0, 0)\n\tif err == nil {\n\t\tt.Errorf(\"Expected error! Got none... :(\")\n\t} else {\n\t\tif err.Error() != \"runtime error: [string \\\"test\\\"]:3: attempt to perform arithmetic on a nil value\" {\n\t\t\tt.Errorf(\"Wrong error reported: %v\", err)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}