{
  "metadata": {
    "timestamp": 1736566610388,
    "page": 165,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "burrowers/garble",
      "stars": 4251,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0791015625,
          "content": "# To prevent CRLF breakages on Windows for fragile files, like testdata.\n* -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.03515625,
          "content": "/garble\n/test\n/bincmp_output/\ndebug\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.5712890625,
          "content": "# This is the official list of Garble authors for copyright purposes.\n\n# Names should be added to this file as one of\n#     Organization's name\n#     Individual's name <submission email address>\n\n# Please keep the list sorted.\n\nAndrew LeFevre <jalefevre@liberty.edu>\nDaniel Martí <mvdan@mvdan.cc>\nEmmanuel Chee-zaram Okeke <ecokeke21@gmail.com>\nNHAS <jordanatararimu@gmail.com>\nNicholas Jones <me@nicholasjon.es>\nPaul Scheduikat <lu4p@pm.me>\nZachary Wasserman <zachwass2000@gmail.com>\npagran <pagran@protonmail.com>\nshellhazard <shellhazard@tutanota.com>\nxuannv <xuan11290@gmail.com>\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 15.552734375,
          "content": "# Changelog\n\n## [v0.13.0] - 2024-09-05\n\nThis release drops support for Go 1.21 and adds support for Go 1.23.\n\nA number of fixes are also included:\n* Fix obfuscation errors when arch-dependent struct padding is used\n* Fix a failure when using garble inside a `go.work` workspace\n* Fail early and clearly if the Go version is too new\n* Rewrite the main `go generate` script from Bash to Go and improve it\n\n## [v0.12.1] - 2024-02-18\n\nThis bugfix release fixes a regression in v0.12.0 that broke `x/sys/unix`.\nSee #830.\n\n## [v0.12.0] - 2024-02-10\n\nThis release continues support for Go 1.21 and includes fixes for Go 1.22,\nnow that the final 1.22.0 release is out.\n\n@lu4p improved the detection of types used with reflection to track `make` calls too,\nfixing more `cannot use T1 as T2` errors when obfuscating types. See [#690].\n\n@pagran added a trash block generator to the control flow obfuscator.\nSee [#825].\n\nA number of bugfixes are also included:\n* Avoid an error when building for `GOOS=ios` - [#816]\n* Prevent the shuffle literal obfuscation from being optimized away - [#819]\n* Support inline comments in assembly `#include` lines - [#812]\n\n## [v0.11.0] - 2023-12-02\n\nThis release drops support for Go 1.20, continues support for Go 1.21,\nand adds initial support for the upcoming Go 1.22.\n\n@lu4p and @mvdan improved the code using SSA to detect which types are used with reflection,\nwhich should fix a number of errors such as `cannot use T1 as T2` or `cannot convert T1 to T2`.\nSee: [#685], [#763], [#782], [#785], [#807].\n\n@pagran added experimental support for control flow obfuscation,\nwhich should provide stronger obfuscation of function bodies when enabled.\nSee the documentation at [docs/CONTROLFLOW.md](https://github.com/burrowers/garble/blob/master/docs/CONTROLFLOW.md).\nSee [#462].\n\nA number of bugfixes are also included:\n\n* Avoid panicking on a struct embedding a builtin alias - [#798]\n* Strip struct field tags when hashing struct types for type identity - [#801]\n\n## [v0.10.1] - 2023-06-25\n\nThis bugfix release continues support for Go 1.20 and the upcoming 1.21,\nand features:\n\n* Avoid obfuscating local types used for reflection, like in `go-spew` - #765\n\n## [v0.10.0] - 2023-06-05\n\nThis release drops support for Go 1.19, continues support for Go 1.20,\nand adds initial support for the upcoming Go 1.21.\n\n@lu4p rewrote the code to detect whether `reflect` is used on each Go type,\nwhich is used to decide which Go types should not be obfuscated to prevent breakage.\nThe old code analyzed syntax trees with type information, which is cheap but clumsy.\nThe new code uses SSA, which adds a bit of CPU cost to builds, but allows for a\nmore powerful analysis that is less likely to break on edge cases.\nWhile this change does slow down builds slightly, we will start using SSA for more\nfeatures in the near term, such as control flow obfuscation. See [#732].\n\n@pagran improved the patching of Go's linker to also obfuscate funcInfo.entryoff,\nmaking it harder to relate a function's metadata with its body in the binary. See [#641].\n\n@mvdan rewrote garble's caching to be more robust, avoiding errors such as\n\"cannot load garble export file\". The new caching system is entirely separate\nfrom Go's `GOCACHE`, being placed in `GARBLE_CACHE`, which defaults to a directory\nsuch as `~/.cache/garble`. See [#708].\n\n@DominicBreuker taught `-literals` to support obfuscating large string literals\nby using the \"simple\" obfuscator on them, as it runs in linear time. See [#720].\n\n@mvdan added support for `garble run`, the obfuscated version of `go run`,\nto quickly test that a main program still works when obfuscated. See [#661].\n\nA number of bugfixes are also included:\n\n* Ensure that `sync/atomic` types are still aligned by the compiler - [#686]\n* Print the chosen random seed when using `-seed=random` - [#696]\n* Avoid errors in `git apply` if the system language isn't English - [#698]\n* Avoid a panic when importing a missing package - [#694]\n* Suggest a command when asking the user to rebuild garble - [#739]\n\n## [v0.9.3] - 2023-02-12\n\nThis bugfix release continues support for Go 1.19 and 1.20, and features:\n\n* Support inline comments in assembly to fix `GOARCH=ppc64` - [#672]\n* Avoid obfuscating `reflect.Value` to fix `davecgh/go-spew` - [#676]\n* Fix runtime panics when using `garble build` inside a VCS directory - [#675]\n\n## [v0.9.2] - 2023-02-07\n\nThis bugfix release continues support for Go 1.19 and 1.20, and features:\n\n* Support `go:linkname` directives referencing methods - [#656]\n* Fix more \"unused import\" errors with `-literals` - [#658]\n\n## [v0.9.1] - 2023-01-26\n\nThis bugfix release continues support for Go 1.19 and the upcoming Go 1.20,\nand features:\n\n* Support obfuscating code which uses \"dot imports\" - [#610]\n* Fix linking errors for MIPS architectures - [#646]\n* Compiler intrinsics for packages like `math/bits` work again - [#655]\n\n## [v0.9.0] - 2023-01-17\n\nThis release continues support for Go 1.19 and the upcoming Go 1.20.\n\nNoteworthy changes include:\n\n* Randomize the magic number header in `pclntab` - [#622]\n* Further reduce binary sizes with `-tiny` by 4%  - [#633]\n* Reduce the size overhead of all builds by 2% - [#629]\n* Reduce the binary size overhead of `-literals` by 20%  - [#637]\n* Support assembly references to the current package name - [#619]\n* Support package paths with periods in assembly - [#621]\n\nNote that the first two changes are done by patching and rebuilding Go's linker.\nWhile this adds complexity, it enables more link time obfuscation.\n\n## [v0.8.0] - 2022-12-15\n\nThis release drops support for Go 1.18, continues support for Go 1.19,\nand adds initial support for the upcoming Go 1.20.\n\nNoteworthy changes include:\n\n* `GOGARBLE=*` is now the default to obfuscate all packages - [#594]\n* `GOPRIVATE` is no longer used, being deprecated in [v0.5.0]\n* Obfuscate assembly source code filenames - [#605]\n* Randomize the lengths of obfuscated names\n* Support obfuscating `time` and `syscall`\n* Avoid reflect method call panics if `reflect` is obfuscated\n\n## [v0.7.2] - 2022-09-26\n\nThis bugfix release continues support for Go 1.18 and 1.19 and features:\n\n* Fix an edge case resulting in bad syntax due to comments - [#573]\n* Avoid a panic involving generic code - [#577]\n* Obfuscate Go names in assembly header files - [#553]\n* Support `garble reverse` on packages using cgo or assembly - [#555]\n\n## [v0.7.1] - 2022-08-02\n\nThis bugfix release finishes support for Go 1.19 and features:\n\n* Obfuscate all cgo filenames to not leak import paths\n* Support obfuscating `net` and `runtime/debug`\n* Don't leak temporary directories after obfuscating\n* Fix an edge case resulting in broken import declarations\n* Reduce allocations involved in obfuscating code\n\n## [v0.7.0] - 2022-06-10\n\nThis release drops support for Go 1.17, continues support for Go 1.18,\nand adds initial support for the upcoming Go 1.19.\n\nNoteworthy changes include:\n\n* Initial support for obfuscating generic code - [#414]\n* Remove unused imports in `-literals` more reliably - [#481]\n* Support obfuscating package paths ending with `.go` - [#539]\n* Support installing garble in paths containing spaces - [#544]\n* Avoid a panic when obfuscating variadic functions - [#524]\n* Avoid a \"refusing to list package\" panic in `garble test` - [#522]\n* Some module builds are now used as regression tests - [#240]\n\n## [v0.6.0] - 2022-03-22\n\nThis release adds support for Go 1.18 while continuing support for Go 1.17.x.\nNote that building generic code isn't supported just yet.\n\nNoteworthy changes include:\n\n* Obfuscation is now fully deterministic with a fixed `-seed` - [#449]\n* Improve support for type aliases to fix some build failures - [#466]\n* Add support for quotes in `-ldflags` as per `go help build` - [#492]\n* Fail if the current Go version is newer than what built garble - [#269]\n* Various optimizations resulting in builds being up to 5% faster - [#456]\n\n## [v0.5.1] - 2022-01-18\n\nThis bugfix release features:\n\n* Obfuscate exported names in `main` packages\n* Fix build errors when using `-literals` with `GOGARBLE=*`\n* Avoid breaking `-ldflags=-X` when `-literals` is used\n* Avoid link errors when using `-debugdir`\n* Speed up obfuscating the `runtime` package\n\n## [v0.5.0] - 2022-01-06\n\nThis release of Garble adds initial support for the upcoming Go 1.18,\ncontinues support for Go 1.17.x, and drops support for Go 1.16.x.\nNote that building generic code isn't supported just yet.\n\nTwo breaking changes are introduced:\n\n* Deprecate the use of `GOPRIVATE` in favor of `GOGARBLE` (see https://github.com/burrowers/garble/issues/276)\n* `garble reverse` now requires a main package argument\n\nNoteworthy changes include:\n\n* Improve detection of `reflect` usage even further\n* Support obfuscating some more standard library packages\n* Improve literal obfuscation by using constant folding\n* Add the `-debug` flag to log details of the obfuscated build\n* Ensure the `runtime` package is built in a reproducible way\n* Obfuscate local variable names to prevent shadowing bugs\n* Fix and test support for using garble on 32-bit hosts\n\n## [v0.4.0] - 2021-08-26\n\nThis release of Garble adds support for Go 1.17.x while maintaining support for\nGo 1.16.x. A few other noteworthy changes are included:\n\n* Support obfuscating literals in more edge cases with `-literals`\n* Improve detection of `reflect` usage with standard library APIs\n* Names exported for cgo are no longer obfuscated\n* Avoid breaking consts using `iota` with `-literals`\n\nKnown bugs:\n\n* obfuscating the entire standard library with `GOPRIVATE=*` is not well supported yet\n\n## [v0.3.0] - 2021-05-31\n\nThis release of Garble fixes a number of bugs and improves existing features,\nwhile maintaining support for Go 1.16.x. Notably:\n\n* Make builds reproducible even when cleaning `GOCACHE`\n* Detecting types used with reflection is more reliable\n* Cross builds with `GOPRIVATE=*` are now supported\n* Support conversion between struct types from different packages\n* Improve support for type aliases\n* Function names used with `go:linkname` are now obfuscated\n* `garble reverse` can now reverse field names and lone filenames\n\nKnown bugs:\n\n* obfuscating the entire standard library with `GOPRIVATE=*` is not well supported yet\n\n## [v0.2.0] - 2021-04-08\n\nThis release of Garble drops support for Go 1.15.x, which is necessary for some\nof the enhancements below:\n\n* New: `garble test` allows running Go tests built with obfuscation\n* New: `garble reverse` allows de-obfuscating output like stack traces\n* Names of functions implemented in assembly are now obfuscated\n* `GOPRIVATE=*` now works with packages like `crypto/tls` and `embed`\n* `garble build` can now be used with many main packages at once\n* `-literals` is more robust and now works on all of `std`\n\nThe README is also overhauled to be more helpful to first-time users.\n\nKnown bugs:\n\n* obfuscating the entire standard library with `GOPRIVATE=*` is not well supported yet\n\n## [v0.1.0] - 2021-03-05\n\nThis is the first release of Garble. It supports Go 1.15.x and 1.16.x.\n\nIt ships all the major features that have worked for the past year, including:\n\n* Obfuscation of all names, except methods and reflect targets\n* Obfuscation of package import paths and position information\n* Stripping of build and module information\n* Support for Go modules\n* Reproducible and cacheable builds\n* Stripping of extra information via `-tiny`\n* Literal obfuscation via `-literals`\n\nKnown bugs:\n\n* obfuscating the standard library with `GOPRIVATE=*` is not well supported yet\n* `garble test` is temporarily disabled, as it is currently broken\n\n[v0.12.1]: https://github.com/burrowers/garble/releases/tag/v0.12.1\n\n[v0.12.0]: https://github.com/burrowers/garble/releases/tag/v0.12.0\n[#690]: https://github.com/burrowers/garble/issues/690\n[#812]: https://github.com/burrowers/garble/issues/812\n[#816]: https://github.com/burrowers/garble/pull/816\n[#819]: https://github.com/burrowers/garble/pull/819\n[#825]: https://github.com/burrowers/garble/pull/825\n\n[v0.11.0]: https://github.com/burrowers/garble/releases/tag/v0.11.0\n[#462]: https://github.com/burrowers/garble/issues/462\n[#685]: https://github.com/burrowers/garble/issues/685\n[#763]: https://github.com/burrowers/garble/issues/763\n[#782]: https://github.com/burrowers/garble/issues/782\n[#785]: https://github.com/burrowers/garble/issues/785\n[#798]: https://github.com/burrowers/garble/issues/798\n[#801]: https://github.com/burrowers/garble/issues/801\n[#807]: https://github.com/burrowers/garble/issues/807\n\n[v0.10.1]: https://github.com/burrowers/garble/releases/tag/v0.10.1\n\n[v0.10.0]: https://github.com/burrowers/garble/releases/tag/v0.10.0\n[#641]: https://github.com/burrowers/garble/pull/641\n[#661]: https://github.com/burrowers/garble/issues/661\n[#686]: https://github.com/burrowers/garble/issues/686\n[#694]: https://github.com/burrowers/garble/issues/694\n[#696]: https://github.com/burrowers/garble/issues/696\n[#698]: https://github.com/burrowers/garble/issues/698\n[#708]: https://github.com/burrowers/garble/issues/708\n[#720]: https://github.com/burrowers/garble/pull/720\n[#732]: https://github.com/burrowers/garble/pull/732\n[#739]: https://github.com/burrowers/garble/pull/739\n\n[v0.9.3]: https://github.com/burrowers/garble/releases/tag/v0.9.3\n[#672]: https://github.com/burrowers/garble/issues/672\n[#675]: https://github.com/burrowers/garble/pull/675\n[#676]: https://github.com/burrowers/garble/issues/676\n\n[v0.9.2]: https://github.com/burrowers/garble/releases/tag/v0.9.2\n[#656]: https://github.com/burrowers/garble/issues/656\n[#658]: https://github.com/burrowers/garble/issues/658\n\n[v0.9.1]: https://github.com/burrowers/garble/releases/tag/v0.9.1\n[#610]: https://github.com/burrowers/garble/issues/610\n[#646]: https://github.com/burrowers/garble/issues/646\n[#655]: https://github.com/burrowers/garble/pull/655\n\n[v0.9.0]: https://github.com/burrowers/garble/releases/tag/v0.9.0\n[#619]: https://github.com/burrowers/garble/issues/619\n[#621]: https://github.com/burrowers/garble/issues/621\n[#622]: https://github.com/burrowers/garble/issues/622\n[#629]: https://github.com/burrowers/garble/pull/629\n[#633]: https://github.com/burrowers/garble/pull/633\n[#637]: https://github.com/burrowers/garble/pull/637\n\n[v0.8.0]: https://github.com/burrowers/garble/releases/tag/v0.8.0\n[#594]: https://github.com/burrowers/garble/issues/594\n[#605]: https://github.com/burrowers/garble/issues/605\n\n[v0.7.2]: https://github.com/burrowers/garble/releases/tag/v0.7.2\n[#573]: https://github.com/burrowers/garble/issues/573\n[#577]: https://github.com/burrowers/garble/issues/577\n[#553]: https://github.com/burrowers/garble/issues/553\n[#555]: https://github.com/burrowers/garble/issues/555\n\n[v0.7.1]: https://github.com/burrowers/garble/releases/tag/v0.7.1\n\n[v0.7.0]: https://github.com/burrowers/garble/releases/tag/v0.7.0\n[#240]: https://github.com/burrowers/garble/issues/240\n[#414]: https://github.com/burrowers/garble/issues/414\n[#481]: https://github.com/burrowers/garble/issues/481\n[#522]: https://github.com/burrowers/garble/issues/522\n[#524]: https://github.com/burrowers/garble/issues/524\n[#539]: https://github.com/burrowers/garble/issues/539\n[#544]: https://github.com/burrowers/garble/issues/544\n\n[v0.6.0]: https://github.com/burrowers/garble/releases/tag/v0.6.0\n[#449]: https://github.com/burrowers/garble/issues/449\n[#466]: https://github.com/burrowers/garble/issues/466\n[#492]: https://github.com/burrowers/garble/issues/492\n[#269]: https://github.com/burrowers/garble/issues/269\n[#456]: https://github.com/burrowers/garble/issues/456\n\n[v0.5.1]: https://github.com/burrowers/garble/releases/tag/v0.5.1\n[v0.5.0]: https://github.com/burrowers/garble/releases/tag/v0.5.0\n[v0.4.0]: https://github.com/burrowers/garble/releases/tag/v0.4.0\n[v0.3.0]: https://github.com/burrowers/garble/releases/tag/v0.3.0\n[v0.2.0]: https://github.com/burrowers/garble/releases/tag/v0.2.0\n[v0.1.0]: https://github.com/burrowers/garble/releases/tag/v0.1.0\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6.7685546875,
          "content": "## Contributing to Garble\n\nThank you for your interest in contributing! Here are some ground rules:\n\n1. The tool's design decisions are in the [README](README.md)\n2. New features or major changes should be opened as an issue first\n3. All contributions are done in PRs with at least one review and CI\n4. All changes that alter behavior (features, flags, bugs) need a test\n5. We use the `#obfuscation` channel over at the [Gophers Slack](https://invite.slack.golangbridge.org/) to chat\n\nWhen contributing for the first time, you should also add yourself to the\n[AUTHORS file](AUTHORS).\n\n### Testing\n\nJust the usual `go test ./...`; many of the tests are in\n[testscript](https://pkg.go.dev/github.com/rogpeppe/go-internal/testscript) under\n`testdata/scripts/`, which allows laying out files and shell-like steps to run as\npart of the test.\n\nNote that the tests do real builds, so they are quite slow; on an average\nlaptop, `go test` can take over thirty seconds. Here are some tips:\n\n* Use `go test -short` to skip the more expensive or thorough tests\n* Use `go test -run Script/foo` to just run `testdata/scripts/foo.txt`\n\n### Integrating into Go builds\n\nWhen you run `go build`, it first loads all needed packages.\nIt then figures out how to build them in distinct steps,\nsuch as the calls to `asm`, `compile`, or `link` you can see in `go build -x`.\nNote how each of these toolchain tools is executed in separate processes.\nFor example, a small `go build` might look like the following process tree:\n\n\tgo build ./main\n\t\t↳ …/compile -p project.com/library library.go\n\t\t↳ …/compile -p main main.go\n\t\t↳ …/link -o main.exe\n\n`garble build` boils down to calling `go build -toolexec=garble`,\nwhich is a flag that lets us wrap the calls to each tool mentioned above.\nFor example, where a regular build might run `…/compile foo.go`,\n`-toolexec=garble` instead runs `garble …/compile foo.go`,\nwhich lets us obfuscate the Go source code before being compiled.\n\nBecause of the above, `garble` gets run as multiple processes:\none top-level process that implements the CLI and the initial setup,\nand one process for each compilation step tool that we transform.\nFor example, here's a `garble build` version of the earlier process tree:\n\n\tgarble build ./main\n\t\t↳ go build -toolexec=garble ./main\n\t\t\t↳ garble …/compile -p project.com/library library.go\n\t\t\t\t↳ …/compile -p project.com/library library.go\n\t\t\t↳ garble …/compile -p main main.go\n\t\t\t\t↳ …/compile -p main main.go\n\t\t\t↳ garble …/link -o main.exe\n\t\t\t\t↳ …/link -o main.exe\n\nGo builds happen one package at a time, and so does garble's obfuscation.\nThis is necessary to support build caching and incremental builds.\nFor further build speed, packages are built in parallel whenever possible,\nwith each package only building once all of its dependencies are finished.\n\nTo deduplicate work, the top-level garble process loads all packages to build,\nand stores their information in a file consumed by the garble sub-processes.\nEach garble sub-process also produces extra cached output of its own,\nwith information such as which declared names could not be obfuscated.\ngarble sub-processes will load the cached output files for their dependencies.\n\n### Development tips\n\nTo see how garble is obfuscating a build, you can use `garble -debug build`.\nYou can also use `-debugdir` to get a copy of the obfuscated source code.\nTo get finer-grained information, adding temporary debug prints is helpful.\n\nWhen investigating an issue, such as a build failure or subpar obfuscation,\nit's best to reproduce the problem with the smallest build input possible.\nThat will help write a test case, and also make `garble -debug` more useful.\nFor example, if you suspect what piece of code might be causing the issue,\ntry moving the code to one or two new packages with very few dependencies.\n\nTo inject code into the syntax tree, don't write `go/ast` nodes by hand; you can\ngenerate them by typing Go source into tools such as\n[astextract](https://lu4p.github.io/astextract/).\n\n### Terminology\n\nThe *Go toolchain*, or simply *the toolchain*, refers to the `go` command and\nall of its components used to build programs, such as the compiler and linker.\n\nAn *object file* or *archive file* contains the output of compiling a Go\npackage, later used to link a binary.\n\nAn *import config* is a temporary text file passed to the compiler via the\n`-importcfg` flag, which contains an *object file* path for each direct\ndependency.\n\nA *build ID* is a slash-separated list of hashes for a build operation, such as\ncompiling a package or linking binary. The first component is the *action ID*,\nthe hash of the operation's inputs, and the last component is the *content ID*,\nthe hash of the operation's output. For more, read\n[the docs in buildid.go](https://github.com/golang/go/blob/master/src/cmd/go/internal/work/buildid.go)\n\n### Benchmarking\n\nA build benchmark is available, to be able to measure the cost of builing a\nfairly simple main program with and without caching. Here is an example of how\nto use the benchmark with [benchstat](https://golang.org/x/perf/cmd/benchstat):\n\n\t# Run the benchmark six times with five iterations each.\n\tgo test -run=- -bench=. -count=6 -benchtime=5x >old.txt\n\n\t# Make some change to the code.\n\tgit checkout some-optimization\n\n\t# Obtain benchmark results once more.\n\tgo test -run=- -bench=. -count=6 -benchtime=5x >new.txt\n\n\t# Obtain the final stats.\n\tbenchstat old.txt new.txt\n\nIt is very important to run the steps above on a quiet machine. Any background\nprogram that could use CPU or I/O should be closed, as it would likely skew the\nresults; this includes browsers, chat apps, and music players.\n\nA higher `-benchtime` will mean more stable numbers, and a higher `-count` will\nmean more reliable statistical results, but both increase the overall cost of\nrunning the benchmark. The provided example should be a sane default, and each\n'go test' invocation takes about a minute on a laptop.\n\nFor example, below are the final results for a run where nothing was changed:\n\n\tname             old time/op       new time/op       delta\n\tBuild/Cache-8          165ms ± 3%        165ms ± 2%   ~     (p=1.000 n=6+6)\n\tBuild/NoCache-8        1.26s ± 7%        1.27s ± 5%   ~     (p=0.699 n=6+6)\n\n\tname             old bin-B         new bin-B         delta\n\tBuild/Cache-8          6.36M ± 0%        6.36M ± 0%   ~     (all equal)\n\tBuild/NoCache-8        6.36M ± 0%        6.36M ± 0%   ~     (all equal)\n\n\tname             old sys-time/op   new sys-time/op   delta\n\tBuild/Cache-8          205ms ± 6%        214ms ± 4%   ~     (p=0.093 n=6+6)\n\tBuild/NoCache-8        512ms ± 6%        512ms ±12%   ~     (p=0.699 n=6+6)\n\n\tname             old user-time/op  new user-time/op  delta\n\tBuild/Cache-8          829ms ± 1%        822ms ± 1%   ~     (p=0.177 n=6+5)\n\tBuild/NoCache-8        8.44s ± 7%        8.55s ± 5%   ~     (p=0.589 n=6+6)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4375,
          "content": "Copyright (c) 2019, The Garble Authors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of the copyright holder nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.3740234375,
          "content": "# garble\n\n\tgo install mvdan.cc/garble@latest\n\nObfuscate Go code by wrapping the Go toolchain. Requires Go 1.23 or later.\n\n\tgarble build [build flags] [packages]\n\nThe tool also supports `garble test` to run tests with obfuscated code,\n`garble run` to obfuscate and execute simple programs,\nand `garble reverse` to de-obfuscate text such as stack traces.\nRun `garble -h` to see all available commands and flags.\n\nYou can also use `go install mvdan.cc/garble@master` to install the latest development version.\n\n### Purpose\n\nProduce a binary that works as well as a regular build, but that has as little\ninformation about the original source code as possible.\n\nThe tool is designed to be:\n\n* Coupled with `cmd/go`, to support modules and build caching\n* Deterministic and reproducible, given the same initial source code\n* Reversible given the original source, to de-obfuscate panic stack traces\n\n### Mechanism\n\nThe tool wraps calls to the Go compiler and linker to transform the Go build, in\norder to:\n\n* Replace as many useful identifiers as possible with short base64 hashes\n* Replace package paths with short base64 hashes\n* Replace filenames and position information with short base64 hashes\n* Remove all [build](https://go.dev/pkg/runtime/#Version) and [module](https://go.dev/pkg/runtime/debug/#ReadBuildInfo) information\n* Strip debugging information and symbol tables via `-ldflags=\"-w -s\"`\n* [Obfuscate literals](#literal-obfuscation), if the `-literals` flag is given\n* Remove [extra information](#tiny-mode), if the `-tiny` flag is given\n\nBy default, the tool obfuscates all the packages being built.\nYou can manually specify which packages to obfuscate via `GOGARBLE`,\na comma-separated list of glob patterns matching package path prefixes.\nThis format is borrowed from `GOPRIVATE`; see `go help private`.\n\nNote that commands like `garble build` will use the `go` version found in your\n`$PATH`. To use different versions of Go, you can\n[install them](https://go.dev/doc/manage-install#installing-multiple)\nand set up `$PATH` with them. For example, for Go 1.17.1:\n\n```sh\n$ go install golang.org/dl/go1.17.1@latest\n$ go1.17.1 download\n$ PATH=$(go1.17.1 env GOROOT)/bin:${PATH} garble build\n```\n\n### Use cases\n\nA common question is why a code obfuscator is needed for Go, a compiled language.\nGo binaries include a surprising amount of information about the original source;\neven with debug information and symbol tables stripped, many names and positions\nremain in place for the sake of traces, reflection, and debugging.\n\nSome use cases for Go require sharing a Go binary with the end user.\nIf the source code for the binary is private or requires a purchase,\nits obfuscation can help discourage reverse engineering.\n\nA similar use case is a Go library whose source is private or purchased.\nSince Go libraries cannot be imported in binary form, and Go plugins\n[have their shortcomings](https://github.com/golang/go/issues/19282),\nsharing obfuscated source code becomes an option.\nSee [#369](https://github.com/burrowers/garble/issues/369).\n\nObfuscation can also help with aspects entirely unrelated to licensing.\nFor example, the `-tiny` flag can make binaries 15% smaller,\nsimilar to the [common practice in Android](https://developer.android.com/build/shrink-code#obfuscate) to reduce app sizes.\nObfuscation has also helped some open source developers work around\nanti-virus scans incorrectly treating Go binaries as malware.\n\n### Literal obfuscation\n\nUsing the `-literals` flag causes literal expressions such as strings to be\nreplaced with more complex expressions, resolving to the same value at run-time.\nString literals injected via `-ldflags=-X` are also replaced by this flag.\nThis feature is opt-in, as it can cause slow-downs depending on the input code.\n\nLiterals used in constant expressions cannot be obfuscated, since they are\nresolved at compile time. This includes any expressions part of a `const`\ndeclaration, for example.\n\n### Tiny mode\n\nWith the `-tiny` flag, even more information is stripped from the Go binary.\nPosition information is removed entirely, rather than being obfuscated.\nRuntime code which prints panics, fatal errors, and trace/debug info is removed.\nMany symbol names are also omitted from binary sections at link time.\nAll in all, this can make binaries about 15% smaller.\n\nWith this flag, no panics or fatal runtime errors will ever be printed, but they\ncan still be handled internally with `recover` as normal. In addition, the\n`GODEBUG` environmental variable will be ignored.\n\nNote that this flag can make debugging crashes harder, as a panic will simply\nexit the entire program without printing a stack trace, and source code\npositions and many names are removed.\nSimilarly, `garble reverse` is generally not useful in this mode.\n\n### Control flow obfuscation\n\nSee: [CONTROLFLOW.md](docs/CONTROLFLOW.md)\n\n### Speed\n\n`garble build` should take about twice as long as `go build`, as it needs to\ncomplete two builds. The original build, to be able to load and type-check the\ninput code, and then the obfuscated build.\n\nGarble obfuscates one package at a time, mirroring how Go compiles one package\nat a time. This allows Garble to fully support Go's build cache; incremental\n`garble build` calls should only re-build and re-obfuscate modified code.\n\nNote that the first call to `garble build` may be comparatively slow,\nas it has to obfuscate each package for the first time. This is akin to clearing\n`GOCACHE` with `go clean -cache` and running a `go build` from scratch.\n\nGarble also makes use of its own cache to reuse work, akin to Go's `GOCACHE`.\nIt defaults to a directory under your user's cache directory,\nsuch as `~/.cache/garble`, and can be placed elsewhere by setting `GARBLE_CACHE`.\n\n### Determinism and seeds\n\nJust like Go, garble builds are deterministic and reproducible in nature.\nThis has significant benefits, such as caching builds and being able to use\n`garble reverse` to de-obfuscate stack traces.\n\nBy default, garble will obfuscate each package in a unique way,\nwhich will change if its build input changes: the version of garble, the version\nof Go, the package's source code, or any build parameter such as GOOS or -tags.\nThis is a reasonable default since guessing those inputs is very hard.\n\nYou can use the `-seed` flag to provide your own obfuscation randomness seed.\nReusing the same seed can help produce the same code obfuscation,\nwhich can help when debugging or reproducing problems.\nRegularly rotating the seed can also help against reverse-engineering in the long run,\nas otherwise one can look at changes in how Go's standard library is obfuscated\nto guess when the Go or garble versions were changed across a series of builds.\n\nTo always use a different seed for each build, use `-seed=random`.\nNote that extra care should be taken when using custom seeds:\nif a `-seed` value used in a build is lost, `garble reverse` will not work.\n\n### Caveats\n\nMost of these can improve with time and effort. The purpose of this section is\nto document the current shortcomings of this tool.\n\n* Exported methods are never obfuscated at the moment, since they could\n  be required by interfaces. This area is a work in progress; see\n  [#3](https://github.com/burrowers/garble/issues/3).\n\n* Aside from `GOGARBLE` to select patterns of packages to obfuscate,\n  there is no supported way to exclude obfuscating a selection of files or packages.\n  More often than not, a user would want to do this to work around a bug; please file the bug instead.\n\n* Go programs [are initialized](https://go.dev/ref/spec#Program_initialization) one package at a time,\n  where imported packages are always initialized before their importers,\n  and otherwise they are initialized in the lexical order of their import paths.\n  Since garble obfuscates import paths, this lexical order may change arbitrarily.\n\n* Go plugins are not currently supported; see [#87](https://github.com/burrowers/garble/issues/87).\n\n* Garble requires `git` to patch the linker. That can be avoided once go-gitdiff\n  supports [non-strict patches](https://github.com/bluekeyes/go-gitdiff/issues/30).\n\n* APIs like [`runtime.GOROOT`](https://pkg.go.dev/runtime#GOROOT)\n  and [`runtime/debug.ReadBuildInfo`](https://pkg.go.dev/runtime/debug#ReadBuildInfo)\n  will not work in obfuscated binaries. This [can affect loading timezones](https://github.com/golang/go/issues/51473#issuecomment-2490564684), for example.\n\n### Contributing\n\nWe welcome new contributors. If you would like to contribute, see\n[CONTRIBUTING.md](CONTRIBUTING.md) as a starting point.\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 7.4931640625,
          "content": "// Copyright (c) 2020, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t_ \"embed\"\n\t\"flag\"\n\t\"fmt\"\n\t\"math/rand/v2\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-quicktest/qt\"\n)\n\n//go:embed testdata/bench/main.go\nvar benchSourceMain []byte\n\nvar (\n\trxBuiltRuntime = regexp.MustCompile(`(?m)^runtime$`)\n\trxBuiltMain    = regexp.MustCompile(`(?m)^test/main$`)\n)\n\n// BenchmarkBuild is a benchmark for 'garble build' on a fairly simple\n// main package with a handful of standard library depedencies.\n//\n// We use a real garble binary and exec it, to simulate what the real user would\n// run. The real obfuscation and compilation will happen in sub-processes\n// anyway, so skipping one exec layer doesn't help us in any way.\n//\n// The benchmark isn't parallel, because in practice users build once at a time,\n// and each build already spawns concurrent processes and goroutines to do work.\n//\n// At the moment, each iteration takes 1-2s on a laptop, so we can't make the\n// benchmark include any more features unless we make it significantly faster.\nfunc BenchmarkBuild(b *testing.B) {\n\t// As of Go 1.17, using -benchtime=Nx with N larger than 1 results in two\n\t// calls to BenchmarkBuild, with the first having b.N==1 to discover\n\t// sub-benchmarks. Unfortunately, we do a significant amount of work both\n\t// during setup and during that first iteration, which is pointless.\n\t// To avoid that, detect the scenario in a hacky way, and return early.\n\t// See https://github.com/golang/go/issues/32051.\n\tbenchtime := flag.Lookup(\"test.benchtime\").Value.String()\n\tif b.N == 1 && strings.HasSuffix(benchtime, \"x\") && benchtime != \"1x\" {\n\t\treturn\n\t}\n\ttdir := b.TempDir()\n\n\t// We collect extra metrics.\n\tvar memoryAllocs, cachedTime, systemTime int64\n\n\toutputBin := filepath.Join(tdir, \"output\")\n\tsourceDir := filepath.Join(tdir, \"src\")\n\tqt.Assert(b, qt.IsNil(os.Mkdir(sourceDir, 0o777)))\n\n\twriteSourceFile := func(name string, content []byte) {\n\t\terr := os.WriteFile(filepath.Join(sourceDir, name), content, 0o666)\n\t\tqt.Assert(b, qt.IsNil(err))\n\t}\n\twriteSourceFile(\"go.mod\", []byte(\"module test/main\"))\n\twriteSourceFile(\"main.go\", benchSourceMain)\n\n\trxGarbleAllocs := regexp.MustCompile(`(?m)^garble allocs: ([0-9]+)`)\n\n\tb.ResetTimer()\n\tb.StopTimer()\n\tfor i := range b.N {\n\t\t// First we do a fresh build, using empty cache directories,\n\t\t// and the second does an incremental rebuild reusing the same cache directories.\n\t\tgoCache := filepath.Join(tdir, \"go-cache\")\n\t\tqt.Assert(b, qt.IsNil(os.RemoveAll(goCache)))\n\t\tqt.Assert(b, qt.IsNil(os.Mkdir(goCache, 0o777)))\n\t\tgarbleCache := filepath.Join(tdir, \"garble-cache\")\n\t\tqt.Assert(b, qt.IsNil(os.RemoveAll(garbleCache)))\n\t\tqt.Assert(b, qt.IsNil(os.Mkdir(garbleCache, 0o777)))\n\t\tenv := []string{\n\t\t\t\"RUN_GARBLE_MAIN=true\",\n\t\t\t\"GOCACHE=\" + goCache,\n\t\t\t\"GARBLE_CACHE=\" + garbleCache,\n\t\t\t\"GARBLE_WRITE_ALLOCS=true\",\n\t\t}\n\t\tif prof := flag.Lookup(\"test.cpuprofile\").Value.String(); prof != \"\" {\n\t\t\t// Ensure the directory is empty and created, and pass it along, so that the garble\n\t\t\t// sub-processes can also write CPU profiles.\n\t\t\t// Collect and then merge the profiles as follows:\n\t\t\t//\n\t\t\t//    go test -run=- -vet=off -bench=. -benchtime=5x -cpuprofile=cpu.pprof\n\t\t\t//    go tool pprof -proto cpu.pprof cpu.pprof-subproc/* >merged.pprof\n\t\t\tdir, err := filepath.Abs(prof + \"-subproc\")\n\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\terr = os.RemoveAll(dir)\n\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\terr = os.MkdirAll(dir, 0o777)\n\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\tenv = append(env, \"GARBLE_WRITE_CPUPROFILES=\"+dir)\n\t\t}\n\t\tif prof := flag.Lookup(\"test.memprofile\").Value.String(); prof != \"\" {\n\t\t\t// Same as before, but for allocation profiles.\n\t\t\tdir, err := filepath.Abs(prof + \"-subproc\")\n\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\terr = os.RemoveAll(dir)\n\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\terr = os.MkdirAll(dir, 0o777)\n\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\tenv = append(env, \"GARBLE_WRITE_MEMPROFILES=\"+dir)\n\t\t}\n\t\targs := []string{\"build\", \"-v\", \"-o=\" + outputBin, sourceDir}\n\n\t\tfor _, cached := range []bool{false, true} {\n\t\t\t// The cached rebuild will reuse all dependencies,\n\t\t\t// but rebuild the main package itself.\n\t\t\tif cached {\n\t\t\t\twriteSourceFile(\"rebuild.go\", []byte(fmt.Sprintf(\"package main\\nvar v%d int\", i)))\n\t\t\t}\n\n\t\t\tcmd := exec.Command(os.Args[0], args...)\n\t\t\tcmd.Env = append(cmd.Environ(), env...)\n\t\t\tcmd.Dir = sourceDir\n\n\t\t\tcachedStart := time.Now()\n\t\t\tb.StartTimer()\n\t\t\tout, err := cmd.CombinedOutput()\n\t\t\tb.StopTimer()\n\t\t\tif cached {\n\t\t\t\tcachedTime += time.Since(cachedStart).Nanoseconds()\n\t\t\t}\n\n\t\t\tqt.Assert(b, qt.IsNil(err), qt.Commentf(\"output: %s\", out))\n\t\t\tif !cached {\n\t\t\t\t// Ensure that we built all packages, as expected.\n\t\t\t\tqt.Assert(b, qt.IsTrue(rxBuiltRuntime.Match(out)))\n\t\t\t} else {\n\t\t\t\t// Ensure that we only rebuilt the main package, as expected.\n\t\t\t\tqt.Assert(b, qt.IsFalse(rxBuiltRuntime.Match(out)))\n\t\t\t}\n\t\t\tqt.Assert(b, qt.IsTrue(rxBuiltMain.Match(out)))\n\n\t\t\tmatches := rxGarbleAllocs.FindAllSubmatch(out, -1)\n\t\t\tif !cached {\n\t\t\t\t// The non-cached version should have at least a handful of\n\t\t\t\t// sub-processes; catch if our logic breaks.\n\t\t\t\tqt.Assert(b, qt.IsTrue(len(matches) > 5))\n\t\t\t}\n\t\t\tfor _, match := range matches {\n\t\t\t\tallocs, err := strconv.ParseInt(string(match[1]), 10, 64)\n\t\t\t\tqt.Assert(b, qt.IsNil(err))\n\t\t\t\tmemoryAllocs += allocs\n\t\t\t}\n\n\t\t\tsystemTime += int64(cmd.ProcessState.SystemTime())\n\t\t}\n\t}\n\t// We can't use \"allocs/op\" as it's reserved for ReportAllocs.\n\tb.ReportMetric(float64(memoryAllocs)/float64(b.N), \"mallocs/op\")\n\tb.ReportMetric(float64(cachedTime)/float64(b.N), \"cached-ns/op\")\n\tb.ReportMetric(float64(systemTime)/float64(b.N), \"sys-ns/op\")\n\tinfo, err := os.Stat(outputBin)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ReportMetric(float64(info.Size()), \"bin-B\")\n}\n\nfunc BenchmarkAbiOriginalNames(b *testing.B) {\n\t// Benchmark two thousand obfuscated names in _originalNamePairs\n\t// and a variety of input strings to reverse.\n\t// As an example, the cmd/go binary ends up with about 2200 entries\n\t// in _originalNamePairs as of November 2024, so it's a realistic figure.\n\t// Structs with tens of fields are also relatively normal.\n\tsalt := []byte(\"some salt bytes\")\n\tfor n := range 2000 {\n\t\tname := fmt.Sprintf(\"name_%d\", n)\n\t\tgarbled := hashWithCustomSalt(salt, name)\n\t\t_originalNamePairs = append(_originalNamePairs, garbled, name)\n\t}\n\t_originalNamesInit()\n\t// Pick twenty obfuscated names at random to use as inputs below.\n\t// Use a deterministic random source so it's stable between benchmark runs.\n\trnd := rand.New(rand.NewPCG(1, 2))\n\tvar chosen []string\n\tfor i := 0; i < len(_originalNamePairs); i += 2 {\n\t\tchosen = append(chosen, _originalNamePairs[i])\n\t}\n\trnd.Shuffle(len(chosen), func(i, j int) {\n\t\tchosen[i], chosen[j] = chosen[j], chosen[i]\n\t})\n\tchosen = chosen[:20]\n\n\tinputs := []string{\n\t\t// non-obfuscated names and types\n\t\t\"Error\",\n\t\t\"int\",\n\t\t\"*[]*interface {}\",\n\t\t\"*map[uint64]bool\",\n\t\t// an obfuscated name\n\t\tchosen[0],\n\t\t// an obfuscated *pkg.Name\n\t\tfmt.Sprintf(\"*%s.%s\", chosen[1], chosen[2]),\n\t\t// big struct with more than a dozen string field types\n\t\tfmt.Sprintf(\"struct { %s string }\", strings.Join(chosen[3:], \" string \")),\n\t}\n\n\tvar inputBytes int\n\tfor _, input := range inputs {\n\t\tinputBytes += len(input)\n\t}\n\tb.SetBytes(int64(inputBytes))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\t// We use a parallel benchmark because internal/abi's Name method\n\t// is meant to be called by any goroutine at any time.\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tfor _, input := range inputs {\n\t\t\t\t_originalNames(input)\n\t\t\t}\n\t\t}\n\t})\n\t_originalNamePairs = []string{}\n\t_originalNamesReplacer = nil\n}\n"
        },
        {
          "name": "cmdgo_quoted.go",
          "type": "blob",
          "size": 2.8115234375,
          "content": "// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.\n\n// Package quoted provides string manipulation utilities.\n//\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc cmdgoQuotedisSpaceByte(c byte) bool {\n\treturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'\n}\n\n// Split splits s into a list of fields,\n// allowing single or double quotes around elements.\n// There is no unescaping or other processing within\n// quoted fields.\n//\n// Keep in sync with cmd/dist/quoted.go\nfunc cmdgoQuotedSplit(s string) ([]string, error) {\n\t// Split fields allowing '' or \"\" around elements.\n\t// Quotes further inside the string do not count.\n\tvar f []string\n\tfor len(s) > 0 {\n\t\tfor len(s) > 0 && cmdgoQuotedisSpaceByte(s[0]) {\n\t\t\ts = s[1:]\n\t\t}\n\t\tif len(s) == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// Accepted quoted string. No unescaping inside.\n\t\tif s[0] == '\"' || s[0] == '\\'' {\n\t\t\tquote := s[0]\n\t\t\ts = s[1:]\n\t\t\ti := 0\n\t\t\tfor i < len(s) && s[i] != quote {\n\t\t\t\ti++\n\t\t\t}\n\t\t\tif i >= len(s) {\n\t\t\t\treturn nil, fmt.Errorf(\"unterminated %c string\", quote)\n\t\t\t}\n\t\t\tf = append(f, s[:i])\n\t\t\ts = s[i+1:]\n\t\t\tcontinue\n\t\t}\n\t\ti := 0\n\t\tfor i < len(s) && !cmdgoQuotedisSpaceByte(s[i]) {\n\t\t\ti++\n\t\t}\n\t\tf = append(f, s[:i])\n\t\ts = s[i:]\n\t}\n\treturn f, nil\n}\n\n// Join joins a list of arguments into a string that can be parsed\n// with Split. Arguments are quoted only if necessary; arguments\n// without spaces or quotes are kept as-is. No argument may contain both\n// single and double quotes.\nfunc cmdgoQuotedJoin(args []string) (string, error) {\n\tvar buf []byte\n\tfor i, arg := range args {\n\t\tif i > 0 {\n\t\t\tbuf = append(buf, ' ')\n\t\t}\n\t\tvar sawSpace, sawSingleQuote, sawDoubleQuote bool\n\t\tfor _, c := range arg {\n\t\t\tswitch {\n\t\t\tcase c > unicode.MaxASCII:\n\t\t\t\tcontinue\n\t\t\tcase cmdgoQuotedisSpaceByte(byte(c)):\n\t\t\t\tsawSpace = true\n\t\t\tcase c == '\\'':\n\t\t\t\tsawSingleQuote = true\n\t\t\tcase c == '\"':\n\t\t\t\tsawDoubleQuote = true\n\t\t\t}\n\t\t}\n\t\tswitch {\n\t\tcase !sawSpace && !sawSingleQuote && !sawDoubleQuote:\n\t\t\tbuf = append(buf, arg...)\n\n\t\tcase !sawSingleQuote:\n\t\t\tbuf = append(buf, '\\'')\n\t\t\tbuf = append(buf, arg...)\n\t\t\tbuf = append(buf, '\\'')\n\n\t\tcase !sawDoubleQuote:\n\t\t\tbuf = append(buf, '\"')\n\t\t\tbuf = append(buf, arg...)\n\t\t\tbuf = append(buf, '\"')\n\n\t\tdefault:\n\t\t\treturn \"\", fmt.Errorf(\"argument %q contains both single and double quotes and cannot be quoted\", arg)\n\t\t}\n\t}\n\treturn string(buf), nil\n}\n\n// A Flag parses a list of string arguments encoded with Join.\n// It is useful for flags like cmd/link's -extldflags.\ntype cmdgoQuotedFlag []string\n\nvar _ flag.Value = (*cmdgoQuotedFlag)(nil)\n\nfunc (f *cmdgoQuotedFlag) Set(v string) error {\n\tfs, err := cmdgoQuotedSplit(v)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*f = fs[:len(fs):len(fs)]\n\treturn nil\n}\n\nfunc (f *cmdgoQuotedFlag) String() string {\n\tif f == nil {\n\t\treturn \"\"\n\t}\n\ts, err := cmdgoQuotedJoin(*f)\n\tif err != nil {\n\t\treturn strings.Join(*f, \" \")\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4384765625,
          "content": "module mvdan.cc/garble\n\ngo 1.23\n\nrequire (\n\tgithub.com/bluekeyes/go-gitdiff v0.8.0\n\tgithub.com/go-quicktest/qt v1.101.0\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/rogpeppe/go-internal v1.13.2-0.20241226121412-a5dc8ff20d0a\n\tgolang.org/x/mod v0.22.0\n\tgolang.org/x/tools v0.27.0\n)\n\nrequire (\n\tgithub.com/kr/pretty v0.3.1 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgolang.org/x/sync v0.9.0 // indirect\n\tgolang.org/x/sys v0.27.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.9375,
          "content": "github.com/bluekeyes/go-gitdiff v0.8.0 h1:Nn1wfw3/XeKoc3lWk+2bEXGUHIx36kj80FM1gVcBk+o=\ngithub.com/bluekeyes/go-gitdiff v0.8.0/go.mod h1:WWAk1Mc6EgWarCrPFO+xeYlujPu98VuLW3Tu+B/85AE=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/go-quicktest/qt v1.101.0 h1:O1K29Txy5P2OK0dGo59b7b0LR6wKfIhttaAhHUyn7eI=\ngithub.com/go-quicktest/qt v1.101.0/go.mod h1:14Bz/f7NwaXPtdYEgzsx46kqSxVwTbzVZsDC26tQJow=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=\ngithub.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=\ngithub.com/rogpeppe/go-internal v1.13.2-0.20241226121412-a5dc8ff20d0a h1:w3tdWGKbLGBPtR/8/oO74W6hmz0qE5q0z9aqSAewaaM=\ngithub.com/rogpeppe/go-internal v1.13.2-0.20241226121412-a5dc8ff20d0a/go.mod h1:S8kfXMp+yh77OxPD4fdM6YUknrZpQxLhvxzS4gDHENY=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/tools v0.27.0 h1:qEKojBykQkQ4EynWy4S8Weg69NumxKdn40Fce3uc/8o=\ngolang.org/x/tools v0.27.0/go.mod h1:sUi0ZgbwW9ZPAq26Ekut+weQPR5eIM6GQLQ1Yjm1H0Q=\n"
        },
        {
          "name": "go_std_tables.go",
          "type": "blob",
          "size": 8.029296875,
          "content": "// Code generated by scripts/gen_go_std_tables.go; DO NOT EDIT.\n\n// Generated from Go versions [go1.23.3].\n\npackage main\n\nvar runtimeAndDeps = map[string]bool{\n\t\"internal/abi\":              true, // go1.23\n\t\"internal/bytealg\":          true, // go1.23\n\t\"internal/byteorder\":        true, // go1.23\n\t\"internal/chacha8rand\":      true, // go1.23\n\t\"internal/coverage/rtcov\":   true, // go1.23\n\t\"internal/cpu\":              true, // go1.23\n\t\"internal/goarch\":           true, // go1.23\n\t\"internal/godebugs\":         true, // go1.23\n\t\"internal/goexperiment\":     true, // go1.23\n\t\"internal/goos\":             true, // go1.23\n\t\"internal/profilerecord\":    true, // go1.23\n\t\"internal/runtime/atomic\":   true, // go1.23\n\t\"internal/runtime/exithook\": true, // go1.23\n\t\"internal/runtime/syscall\":  true, // go1.23\n\t\"internal/stringslite\":      true, // go1.23\n\t\"runtime\":                   true, // go1.23\n\t\"runtime/internal/math\":     true, // go1.23\n\t\"runtime/internal/sys\":      true, // go1.23\n\t\"unsafe\":                    true, // go1.23\n}\n\nvar runtimeLinknamed = []string{\n\t\"arena\",                          // go1.23\n\t\"crypto/internal/boring\",         // go1.23\n\t\"crypto/internal/boring/bcache\",  // go1.23\n\t\"crypto/internal/boring/fipstls\", // go1.23\n\t\"crypto/x509/internal/macos\",     // go1.23\n\t\"internal/coverage/cfile\",        // go1.23\n\t\"internal/godebug\",               // go1.23\n\t\"internal/poll\",                  // go1.23\n\t\"internal/reflectlite\",           // go1.23\n\t\"internal/syscall/unix\",          // go1.23\n\t\"internal/syscall/windows\",       // go1.23\n\t\"internal/weak\",                  // go1.23\n\t\"maps\",                           // go1.23\n\t\"os\",                             // go1.23\n\t\"os/signal\",                      // go1.23\n\t\"plugin\",                         // go1.23\n\t\"reflect\",                        // go1.23\n\t\"runtime/debug\",                  // go1.23\n\t\"runtime/metrics\",                // go1.23\n\t\"runtime/pprof\",                  // go1.23\n\t\"runtime/trace\",                  // go1.23\n\t\"sync\",                           // go1.23\n\t\"sync/atomic\",                    // go1.23\n\t\"syscall\",                        // go1.23\n\t\"syscall/js\",                     // go1.23\n\t\"time\",                           // go1.23\n\t\"unique\",                         // go1.23\n\t// The net package linknames to the runtime, not the other way around.\n\t// TODO: support this automatically via our script.\n\t\"net\",\n}\n\nvar compilerIntrinsics = map[string]map[string]bool{\n\t\"internal/runtime/atomic\": {\n\t\t\"And\":             true, // go1.23\n\t\t\"And32\":           true, // go1.23\n\t\t\"And64\":           true, // go1.23\n\t\t\"And8\":            true, // go1.23\n\t\t\"Anduintptr\":      true, // go1.23\n\t\t\"Cas\":             true, // go1.23\n\t\t\"Cas64\":           true, // go1.23\n\t\t\"CasRel\":          true, // go1.23\n\t\t\"Casint32\":        true, // go1.23\n\t\t\"Casint64\":        true, // go1.23\n\t\t\"Casp1\":           true, // go1.23\n\t\t\"Casuintptr\":      true, // go1.23\n\t\t\"Load\":            true, // go1.23\n\t\t\"Load64\":          true, // go1.23\n\t\t\"Load8\":           true, // go1.23\n\t\t\"LoadAcq\":         true, // go1.23\n\t\t\"LoadAcq64\":       true, // go1.23\n\t\t\"LoadAcquintptr\":  true, // go1.23\n\t\t\"Loadint32\":       true, // go1.23\n\t\t\"Loadint64\":       true, // go1.23\n\t\t\"Loadp\":           true, // go1.23\n\t\t\"Loaduint\":        true, // go1.23\n\t\t\"Loaduintptr\":     true, // go1.23\n\t\t\"Or\":              true, // go1.23\n\t\t\"Or32\":            true, // go1.23\n\t\t\"Or64\":            true, // go1.23\n\t\t\"Or8\":             true, // go1.23\n\t\t\"Oruintptr\":       true, // go1.23\n\t\t\"Store\":           true, // go1.23\n\t\t\"Store64\":         true, // go1.23\n\t\t\"Store8\":          true, // go1.23\n\t\t\"StoreRel\":        true, // go1.23\n\t\t\"StoreRel64\":      true, // go1.23\n\t\t\"StoreReluintptr\": true, // go1.23\n\t\t\"Storeint32\":      true, // go1.23\n\t\t\"Storeint64\":      true, // go1.23\n\t\t\"StorepNoWB\":      true, // go1.23\n\t\t\"Storeuintptr\":    true, // go1.23\n\t\t\"Xadd\":            true, // go1.23\n\t\t\"Xadd64\":          true, // go1.23\n\t\t\"Xaddint32\":       true, // go1.23\n\t\t\"Xaddint64\":       true, // go1.23\n\t\t\"Xadduintptr\":     true, // go1.23\n\t\t\"Xchg\":            true, // go1.23\n\t\t\"Xchg64\":          true, // go1.23\n\t\t\"Xchgint32\":       true, // go1.23\n\t\t\"Xchgint64\":       true, // go1.23\n\t\t\"Xchguintptr\":     true, // go1.23\n\t},\n\t\"math\": {\n\t\t\"Abs\":         true, // go1.23\n\t\t\"Ceil\":        true, // go1.23\n\t\t\"Copysign\":    true, // go1.23\n\t\t\"FMA\":         true, // go1.23\n\t\t\"Floor\":       true, // go1.23\n\t\t\"Round\":       true, // go1.23\n\t\t\"RoundToEven\": true, // go1.23\n\t\t\"Trunc\":       true, // go1.23\n\t\t\"sqrt\":        true, // go1.23\n\t},\n\t\"math/big\": {\n\t\t\"mulWW\": true, // go1.23\n\t},\n\t\"math/bits\": {\n\t\t\"Add\":             true, // go1.23\n\t\t\"Add64\":           true, // go1.23\n\t\t\"Div\":             true, // go1.23\n\t\t\"Div64\":           true, // go1.23\n\t\t\"Len\":             true, // go1.23\n\t\t\"Len16\":           true, // go1.23\n\t\t\"Len32\":           true, // go1.23\n\t\t\"Len64\":           true, // go1.23\n\t\t\"Len8\":            true, // go1.23\n\t\t\"Mul\":             true, // go1.23\n\t\t\"Mul64\":           true, // go1.23\n\t\t\"OnesCount\":       true, // go1.23\n\t\t\"OnesCount16\":     true, // go1.23\n\t\t\"OnesCount32\":     true, // go1.23\n\t\t\"OnesCount64\":     true, // go1.23\n\t\t\"OnesCount8\":      true, // go1.23\n\t\t\"Reverse\":         true, // go1.23\n\t\t\"Reverse16\":       true, // go1.23\n\t\t\"Reverse32\":       true, // go1.23\n\t\t\"Reverse64\":       true, // go1.23\n\t\t\"Reverse8\":        true, // go1.23\n\t\t\"ReverseBytes16\":  true, // go1.23\n\t\t\"ReverseBytes32\":  true, // go1.23\n\t\t\"ReverseBytes64\":  true, // go1.23\n\t\t\"RotateLeft\":      true, // go1.23\n\t\t\"RotateLeft16\":    true, // go1.23\n\t\t\"RotateLeft32\":    true, // go1.23\n\t\t\"RotateLeft64\":    true, // go1.23\n\t\t\"RotateLeft8\":     true, // go1.23\n\t\t\"Sub\":             true, // go1.23\n\t\t\"Sub64\":           true, // go1.23\n\t\t\"TrailingZeros16\": true, // go1.23\n\t\t\"TrailingZeros32\": true, // go1.23\n\t\t\"TrailingZeros64\": true, // go1.23\n\t\t\"TrailingZeros8\":  true, // go1.23\n\t},\n\t\"runtime\": {\n\t\t\"publicationBarrier\": true, // go1.23\n\t},\n\t\"runtime/internal/math\": {\n\t\t\"MulUintptr\": true, // go1.23\n\t},\n\t\"runtime/internal/sys\": {\n\t\t\"Bswap32\":          true, // go1.23\n\t\t\"Bswap64\":          true, // go1.23\n\t\t\"Len64\":            true, // go1.23\n\t\t\"Len8\":             true, // go1.23\n\t\t\"OnesCount64\":      true, // go1.23\n\t\t\"Prefetch\":         true, // go1.23\n\t\t\"PrefetchStreamed\": true, // go1.23\n\t\t\"TrailingZeros32\":  true, // go1.23\n\t\t\"TrailingZeros64\":  true, // go1.23\n\t\t\"TrailingZeros8\":   true, // go1.23\n\t},\n\t\"sync\": {\n\t\t\"runtime_LoadAcquintptr\":  true, // go1.23\n\t\t\"runtime_StoreReluintptr\": true, // go1.23\n\t},\n\t\"sync/atomic\": {\n\t\t\"AddInt32\":              true, // go1.23\n\t\t\"AddInt64\":              true, // go1.23\n\t\t\"AddUint32\":             true, // go1.23\n\t\t\"AddUint64\":             true, // go1.23\n\t\t\"AddUintptr\":            true, // go1.23\n\t\t\"AndInt32\":              true, // go1.23\n\t\t\"AndInt64\":              true, // go1.23\n\t\t\"AndUint32\":             true, // go1.23\n\t\t\"AndUint64\":             true, // go1.23\n\t\t\"AndUintptr\":            true, // go1.23\n\t\t\"CompareAndSwapInt32\":   true, // go1.23\n\t\t\"CompareAndSwapInt64\":   true, // go1.23\n\t\t\"CompareAndSwapUint32\":  true, // go1.23\n\t\t\"CompareAndSwapUint64\":  true, // go1.23\n\t\t\"CompareAndSwapUintptr\": true, // go1.23\n\t\t\"LoadInt32\":             true, // go1.23\n\t\t\"LoadInt64\":             true, // go1.23\n\t\t\"LoadPointer\":           true, // go1.23\n\t\t\"LoadUint32\":            true, // go1.23\n\t\t\"LoadUint64\":            true, // go1.23\n\t\t\"LoadUintptr\":           true, // go1.23\n\t\t\"OrInt32\":               true, // go1.23\n\t\t\"OrInt64\":               true, // go1.23\n\t\t\"OrUint32\":              true, // go1.23\n\t\t\"OrUint64\":              true, // go1.23\n\t\t\"OrUintptr\":             true, // go1.23\n\t\t\"StoreInt32\":            true, // go1.23\n\t\t\"StoreInt64\":            true, // go1.23\n\t\t\"StoreUint32\":           true, // go1.23\n\t\t\"StoreUint64\":           true, // go1.23\n\t\t\"StoreUintptr\":          true, // go1.23\n\t\t\"SwapInt32\":             true, // go1.23\n\t\t\"SwapInt64\":             true, // go1.23\n\t\t\"SwapUint32\":            true, // go1.23\n\t\t\"SwapUint64\":            true, // go1.23\n\t\t\"SwapUintptr\":           true, // go1.23\n\t},\n}\n\nvar reflectSkipPkg = map[string]bool{\n\t\"fmt\": true,\n}\n"
        },
        {
          "name": "hash.go",
          "type": "blob",
          "size": 14.1806640625,
          "content": "// Copyright (c) 2019, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"io\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"mvdan.cc/garble/internal/literals\"\n)\n\nconst buildIDSeparator = \"/\"\n\n// splitActionID returns the action ID half of a build ID, the first hash.\nfunc splitActionID(buildID string) string {\n\treturn buildID[:strings.Index(buildID, buildIDSeparator)]\n}\n\n// splitContentID returns the content ID half of a build ID, the last hash.\nfunc splitContentID(buildID string) string {\n\treturn buildID[strings.LastIndex(buildID, buildIDSeparator)+1:]\n}\n\n// buildIDHashLength is the number of bytes each build ID hash takes,\n// such as an action ID or a content ID.\nconst buildIDHashLength = 15\n\n// decodeBuildIDHash decodes a build ID hash in base64, just like cmd/go does.\nfunc decodeBuildIDHash(str string) []byte {\n\th, err := base64.RawURLEncoding.DecodeString(str)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"invalid hash %q: %v\", str, err))\n\t}\n\tif len(h) != buildIDHashLength {\n\t\tpanic(fmt.Sprintf(\"decodeBuildIDHash expects to result in a hash of length %d, got %d\", buildIDHashLength, len(h)))\n\t}\n\treturn h\n}\n\n// encodeBuildIDHash encodes a build ID hash in base64, just like cmd/go does.\nfunc encodeBuildIDHash(h [sha256.Size]byte) string {\n\treturn base64.RawURLEncoding.EncodeToString(h[:buildIDHashLength])\n}\n\nfunc alterToolVersion(tool string, args []string) error {\n\tcmd := exec.Command(args[0], args[1:]...)\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\tif err, _ := err.(*exec.ExitError); err != nil {\n\t\t\treturn fmt.Errorf(\"%v: %s\", err, err.Stderr)\n\t\t}\n\t\treturn err\n\t}\n\tline := string(bytes.TrimSpace(out)) // no trailing newline\n\tf := strings.Fields(line)\n\tif len(f) < 3 || f[0] != tool || f[1] != \"version\" || f[2] == \"devel\" && !strings.HasPrefix(f[len(f)-1], \"buildID=\") {\n\t\treturn fmt.Errorf(\"%s -V=full: unexpected output:\\n\\t%s\", args[0], line)\n\t}\n\tvar toolID []byte\n\tif f[2] == \"devel\" {\n\t\t// On the development branch, use the content ID part of the build ID.\n\t\ttoolID = decodeBuildIDHash(splitContentID(f[len(f)-1]))\n\t} else {\n\t\t// For a release, the output is like: \"compile version go1.9.1 X:framepointer\".\n\t\t// Use the whole line, as we can assume it's unique.\n\t\ttoolID = []byte(line)\n\t}\n\n\tcontentID := addGarbleToHash(toolID)\n\t// The part of the build ID that matters is the last, since it's the\n\t// \"content ID\" which is used to work out whether there is a need to redo\n\t// the action (build) or not. Since cmd/go parses the last word in the\n\t// output as \"buildID=...\", we simply add \"+garble buildID=_/_/_/${hash}\".\n\t// The slashes let us imitate a full binary build ID, but we assume that\n\t// the other hashes such as the action ID are not necessary, since the\n\t// only reader here is cmd/go and it only consumes the content ID.\n\tfmt.Printf(\"%s +garble buildID=_/_/_/%s\\n\", line, encodeBuildIDHash(contentID))\n\treturn nil\n}\n\nvar (\n\thasher    = sha256.New()\n\tsumBuffer [sha256.Size]byte\n)\n\n// addGarbleToHash takes some arbitrary input bytes,\n// typically a hash such as an action ID or a content ID,\n// and returns a new hash which also contains garble's own deterministic inputs.\n//\n// This includes garble's own version, obtained via its own binary's content ID,\n// as well as any other options which affect a build, such as GOGARBLE and -tiny.\nfunc addGarbleToHash(inputHash []byte) [sha256.Size]byte {\n\t// Join the two content IDs together into a single base64-encoded sha256\n\t// sum. This includes the original tool's content ID, and garble's own\n\t// content ID.\n\thasher.Reset()\n\thasher.Write(inputHash)\n\tif len(sharedCache.BinaryContentID) == 0 {\n\t\tpanic(\"missing binary content ID\")\n\t}\n\thasher.Write(sharedCache.BinaryContentID)\n\n\t// We also need to add the selected options to the full version string,\n\t// because all of them result in different output. We use spaces to\n\t// separate the env vars and flags, to reduce the chances of collisions.\n\tfmt.Fprintf(hasher, \" GOGARBLE=%s\", sharedCache.GOGARBLE)\n\tappendFlags(hasher, true)\n\t// addGarbleToHash returns the sum buffer, so we need a new copy.\n\t// Otherwise the next use of the global sumBuffer would conflict.\n\tvar sumBuffer [sha256.Size]byte\n\thasher.Sum(sumBuffer[:0])\n\treturn sumBuffer\n}\n\n// appendFlags writes garble's own flags to w in string form.\n// Errors are ignored, as w is always a buffer or hasher.\n// If forBuildHash is set, only the flags affecting a build are written.\nfunc appendFlags(w io.Writer, forBuildHash bool) {\n\tif flagLiterals {\n\t\tio.WriteString(w, \" -literals\")\n\t}\n\tif flagTiny {\n\t\tio.WriteString(w, \" -tiny\")\n\t}\n\tif flagDebug && !forBuildHash {\n\t\t// -debug doesn't affect the build result at all,\n\t\t// so don't give it separate entries in the build cache.\n\t\t// If the user really wants to see debug info for already built deps,\n\t\t// they can use \"go clean cache\" or the \"-a\" build flag to rebuild.\n\t\tio.WriteString(w, \" -debug\")\n\t}\n\tif flagDebugDir != \"\" && !forBuildHash {\n\t\t// -debugdir is a bit special.\n\t\t//\n\t\t// When passing down flags via -toolexec,\n\t\t// we do want the actual flag value to be kept.\n\t\t//\n\t\t// For build hashes, we can skip the flag entirely,\n\t\t// as it doesn't affect obfuscation at all.\n\t\t//\n\t\t// TODO: in the future, we could avoid using the -a build flag\n\t\t// by using \"-debugdir=yes\" here, and caching the obfuscated source.\n\t\t// Incremental builds would recover the cached source\n\t\t// to repopulate the output directory if it was removed.\n\t\tio.WriteString(w, \" -debugdir=\")\n\t\tio.WriteString(w, flagDebugDir)\n\t}\n\tif flagSeed.present() {\n\t\tio.WriteString(w, \" -seed=\")\n\t\tio.WriteString(w, flagSeed.String())\n\t}\n\tif flagControlFlow && forBuildHash {\n\t\tio.WriteString(w, \" -ctrlflow\")\n\t}\n\tif literals.TestObfuscator != \"\" && forBuildHash {\n\t\tio.WriteString(w, literals.TestObfuscator)\n\t}\n}\n\nfunc buildidOf(path string) (string, error) {\n\tcmd := exec.Command(\"go\", \"tool\", \"buildid\", path)\n\tout, err := cmd.Output()\n\tif err != nil {\n\t\tif err, _ := err.(*exec.ExitError); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"%v: %s\", err, err.Stderr)\n\t\t}\n\t\treturn \"\", err\n\t}\n\treturn string(out), nil\n}\n\nvar (\n\t// Hashed names are base64-encoded.\n\t// Go names can only be letters, numbers, and underscores.\n\t// This means we can use base64's URL encoding, minus '-',\n\t// which is later replaced with a duplicate 'a'.\n\t// Such a lossy encoding is fine, since we never decode hashes.\n\t// We don't need padding either, as we take a short prefix anyway.\n\tnameBase64 = base64.URLEncoding.WithPadding(base64.NoPadding)\n\n\tb64NameBuffer [12]byte // nameBase64.EncodedLen(neededSumBytes) = 12\n)\n\n// These funcs mimic the unicode package API, but byte-based since we know\n// base64 is all ASCII.\n\nfunc isDigit(b byte) bool { return '0' <= b && b <= '9' }\nfunc isLower(b byte) bool { return 'a' <= b && b <= 'z' }\nfunc isUpper(b byte) bool { return 'A' <= b && b <= 'Z' }\nfunc toLower(b byte) byte { return b + ('a' - 'A') }\nfunc toUpper(b byte) byte { return b - ('a' - 'A') }\n\nfunc runtimeHashWithCustomSalt(salt []byte) uint32 {\n\thasher.Reset()\n\tif !flagSeed.present() {\n\t\thasher.Write(sharedCache.ListedPackages[\"runtime\"].GarbleActionID[:])\n\t} else {\n\t\thasher.Write(flagSeed.bytes)\n\t}\n\thasher.Write(salt)\n\tsum := hasher.Sum(sumBuffer[:0])\n\treturn binary.LittleEndian.Uint32(sum)\n}\n\n// magicValue returns random magic value based\n// on user specified seed or the runtime package's GarbleActionID.\nfunc magicValue() uint32 {\n\treturn runtimeHashWithCustomSalt([]byte(\"magic\"))\n}\n\n// entryOffKey returns random entry offset key\n// on user specified seed or the runtime package's GarbleActionID.\nfunc entryOffKey() uint32 {\n\treturn runtimeHashWithCustomSalt([]byte(\"entryOffKey\"))\n}\n\nfunc hashWithPackage(pkg *listedPackage, name string) string {\n\t// If the user provided us with an obfuscation seed,\n\t// we use that with the package import path directly..\n\t// Otherwise, we use GarbleActionID as a fallback salt.\n\tif !flagSeed.present() {\n\t\treturn hashWithCustomSalt(pkg.GarbleActionID[:], name)\n\t}\n\t// Use a separator at the end of ImportPath as a salt,\n\t// to ensure that \"pkgfoo.bar\" and \"pkg.foobar\" don't both hash\n\t// as the same string \"pkgfoobar\".\n\treturn hashWithCustomSalt([]byte(pkg.ImportPath+\"|\"), name)\n}\n\n// stripStructTags takes the bytes produced by [types.WriteType]\n// and removes any struct tags in-place, such as rewriting\n//\n//\tstruct{Foo int; Bar string \"json:\\\"bar\\\"\"}\n//\n// into\n//\n//\tstruct{Foo int; Bar string}\n//\n// Note that, unlike most Go source, WriteType uses double quotes for tags.\n//\n// Reusing WriteType does require a second pass over its output here,\n// which we could save by implementing our own modified version of WriteType.\n// However, that would be a significant amount of code to maintain.\nfunc stripStructTags(p []byte) []byte {\n\ti := 0\n\tfor i < len(p) {\n\t\tb := p[i]\n\t\tstart := i - 1 // a struct tag is preceded by a space\n\t\ti++\n\t\tif b != '\"' {\n\t\t\tcontinue\n\t\t}\n\t\t// Find the closing double quote, skipping over escaped characters.\n\t\t// Note that we should probably iterate over runes and not bytes,\n\t\t// but this byte implementation is probably good enough in practice.\n\t\tfor {\n\t\t\tb = p[i]\n\t\t\ti++\n\t\t\tif b == '\\\\' {\n\t\t\t\ti++\n\t\t\t} else if b == '\"' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tend := i\n\t\t// Remove the bytes between start and end,\n\t\t// and reset i to start, since we just shortened p.\n\t\tp = append(p[:start], p[end:]...)\n\t\ti = start\n\t}\n\treturn p\n}\n\nvar typeIdentityBuf bytes.Buffer\n\n// hashWithStruct is separate from hashWithPackage since Go\n// allows converting between struct types across packages.\n// Hashing struct field names differently between packages would break that.\n//\n// We hash field names with the identity struct type as a salt\n// so that the same field name used in different struct types is obfuscated differently.\n// Note that \"identity\" means omitting struct tags since conversions ignore them.\nfunc hashWithStruct(strct *types.Struct, field *types.Var) string {\n\ttypeIdentityBuf.Reset()\n\ttypes.WriteType(&typeIdentityBuf, strct, nil)\n\tsalt := stripStructTags(typeIdentityBuf.Bytes())\n\n\t// If the user provided us with an obfuscation seed,\n\t// we only use the identity struct type as a salt.\n\t// Otherwise, we add garble's own inputs to the salt as a fallback.\n\tif !flagSeed.present() {\n\t\twithGarbleHash := addGarbleToHash(salt)\n\t\tsalt = withGarbleHash[:]\n\t}\n\treturn hashWithCustomSalt(salt, field.Name())\n}\n\n// minHashLength and maxHashLength define the range for the number of base64\n// characters to use for the final hashed name.\n//\n// minHashLength needs to be long enough to realistically avoid hash collisions,\n// but maxHashLength should be short enough to not bloat binary sizes.\n// The namespace for collisions is generally a single package, since\n// that's where most hashed names are namespaced to.\n//\n// Using a \"hash collision\" formula, and taking a generous estimate of a\n// package having 10k names, we get the following probabilities.\n// Most packages will have far fewer names, but some packages are huge,\n// especially generated ones.\n//\n// We also have slightly fewer bits in practice, since the base64\n// charset has 'z' twice, and the first base64 char is coerced into a\n// valid Go identifier. So we must be conservative.\n// Remember that base64 stores 6 bits per encoded byte.\n// The probability numbers are approximated.\n//\n//\tlength (base64) | length (bits) | collision probability\n//\t-------------------------------------------------------\n//\t       4               24                   ~95%\n//\t       5               30                    ~4%\n//\t       6               36                 ~0.07%\n//\t       7               42                ~0.001%\n//\t       8               48              ~0.00001%\n//\n// We want collisions to be practically impossible, so the hashed names end up\n// with lengths evenly distributed between 6 and 12. Naively, this results in an\n// average length of 9, which has a chance well below 1 in a million even when a\n// package has thousands of obfuscated names.\n//\n// These numbers are also chosen to keep obfuscated binary sizes reasonable.\n// For example, increasing the average length of 9 by 1 results in roughly a 1%\n// increase in binary sizes.\nconst (\n\tminHashLength = 6\n\tmaxHashLength = 12\n\n\t// At most we'll need maxHashLength base64 characters,\n\t// so 9 checksum bytes are enough for that purpose,\n\t// which is nameBase64.DecodedLen(12) being rounded up.\n\tneededSumBytes = 9\n)\n\n// hashWithCustomSalt returns a hashed version of name,\n// including the provided salt as well as opts.Seed into the hash input.\n//\n// The result is always four bytes long. If the input was a valid identifier,\n// the output remains equally exported or unexported. Note that this process is\n// reproducible, but not reversible.\nfunc hashWithCustomSalt(salt []byte, name string) string {\n\tif len(salt) == 0 {\n\t\tpanic(\"hashWithCustomSalt: empty salt\")\n\t}\n\tif name == \"\" {\n\t\tpanic(\"hashWithCustomSalt: empty name\")\n\t}\n\n\thasher.Reset()\n\thasher.Write(salt)\n\thasher.Write(flagSeed.bytes)\n\tio.WriteString(hasher, name)\n\tsum := hasher.Sum(sumBuffer[:0])\n\n\t// The byte after neededSumBytes is never used as part of the name,\n\t// but it is still deterministic and hard to predict,\n\t// so it provides us with useful randomness between 0 and 255.\n\t// We want the number to be between 0 and hashLenthRange-1 as well,\n\t// so we use a remainder operation.\n\thashLengthRandomness := sum[neededSumBytes] % ((maxHashLength - minHashLength) + 1)\n\thashLength := minHashLength + hashLengthRandomness\n\n\tnameBase64.Encode(b64NameBuffer[:], sum[:neededSumBytes])\n\tb64Name := b64NameBuffer[:hashLength]\n\n\t// Even if we are hashing a package path, which is not an identifier,\n\t// we still want the result to be a valid identifier,\n\t// since we'll use it as the package name too.\n\tif isDigit(b64Name[0]) {\n\t\t// Turn \"3foo\" into \"Dfoo\".\n\t\t// Similar to toLower, since uppercase letters go after digits\n\t\t// in the ASCII table.\n\t\tb64Name[0] += 'A' - '0'\n\t}\n\tfor i, b := range b64Name {\n\t\tif b == '-' { // URL encoding uses dashes, which aren't valid\n\t\t\tb64Name[i] = 'a'\n\t\t}\n\t}\n\t// Valid identifiers should stay exported or unexported.\n\tif token.IsIdentifier(name) {\n\t\tif token.IsExported(name) {\n\t\t\tif b64Name[0] == '_' {\n\t\t\t\t// Turn \"_foo\" into \"Zfoo\".\n\t\t\t\tb64Name[0] = 'Z'\n\t\t\t} else if isLower(b64Name[0]) {\n\t\t\t\t// Turn \"afoo\" into \"Afoo\".\n\t\t\t\tb64Name[0] = toUpper(b64Name[0])\n\t\t\t}\n\t\t} else if isUpper(b64Name[0]) {\n\t\t\t// Turn \"Afoo\" into \"afoo\".\n\t\t\tb64Name[0] = toLower(b64Name[0])\n\t\t}\n\t}\n\treturn string(b64Name)\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 74.76953125,
          "content": "// Copyright (c) 2019, The Garble Authors.\n// See LICENSE for licensing information.\n\n// garble obfuscates Go code by wrapping the Go toolchain.\npackage main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"cmp\"\n\tcryptorand \"crypto/rand\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/gob\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/importer\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"go/types\"\n\t\"go/version\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"maps\"\n\tmathrand \"math/rand\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"runtime/pprof\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/rogpeppe/go-internal/cache\"\n\t\"golang.org/x/mod/module\"\n\t\"golang.org/x/tools/go/ast/astutil\"\n\t\"golang.org/x/tools/go/ssa\"\n\t\"mvdan.cc/garble/internal/ctrlflow\"\n\n\t\"mvdan.cc/garble/internal/linker\"\n\t\"mvdan.cc/garble/internal/literals\"\n)\n\nvar flagSet = flag.NewFlagSet(\"garble\", flag.ExitOnError)\n\nvar (\n\tflagLiterals bool\n\tflagTiny     bool\n\tflagDebug    bool\n\tflagDebugDir string\n\tflagSeed     seedFlag\n\t// TODO(pagran): in the future, when control flow obfuscation will be stable migrate to flag\n\tflagControlFlow = os.Getenv(\"GARBLE_EXPERIMENTAL_CONTROLFLOW\") == \"1\"\n)\n\nfunc init() {\n\tflagSet.Usage = usage\n\tflagSet.BoolVar(&flagLiterals, \"literals\", false, \"Obfuscate literals such as strings\")\n\tflagSet.BoolVar(&flagTiny, \"tiny\", false, \"Optimize for binary size, losing some ability to reverse the process\")\n\tflagSet.BoolVar(&flagDebug, \"debug\", false, \"Print debug logs to stderr\")\n\tflagSet.StringVar(&flagDebugDir, \"debugdir\", \"\", \"Write the obfuscated source to a directory, e.g. -debugdir=out\")\n\tflagSet.Var(&flagSeed, \"seed\", \"Provide a base64-encoded seed, e.g. -seed=o9WDTZ4CN4w\\nFor a random seed, provide -seed=random\")\n}\n\nvar rxGarbleFlag = regexp.MustCompile(`-(?:literals|tiny|debug|debugdir|seed)(?:$|=)`)\n\ntype seedFlag struct {\n\trandom bool\n\tbytes  []byte\n}\n\nfunc (f seedFlag) present() bool { return len(f.bytes) > 0 }\n\nfunc (f seedFlag) String() string {\n\treturn base64.RawStdEncoding.EncodeToString(f.bytes)\n}\n\nfunc (f *seedFlag) Set(s string) error {\n\tif s == \"random\" {\n\t\tf.random = true // to show the random seed we chose\n\n\t\tf.bytes = make([]byte, 16) // random 128 bit seed\n\t\tif _, err := cryptorand.Read(f.bytes); err != nil {\n\t\t\treturn fmt.Errorf(\"error generating random seed: %v\", err)\n\t\t}\n\t} else {\n\t\t// We expect unpadded base64, but to be nice, accept padded\n\t\t// strings too.\n\t\ts = strings.TrimRight(s, \"=\")\n\t\tseed, err := base64.RawStdEncoding.DecodeString(s)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error decoding seed: %v\", err)\n\t\t}\n\n\t\t// TODO: Note that we always use 8 bytes; any bytes after that are\n\t\t// entirely ignored. That may be confusing to the end user.\n\t\tif len(seed) < 8 {\n\t\t\treturn fmt.Errorf(\"-seed needs at least 8 bytes, have %d\", len(seed))\n\t\t}\n\t\tf.bytes = seed\n\t}\n\treturn nil\n}\n\nfunc usage() {\n\tfmt.Fprint(os.Stderr, `\nGarble obfuscates Go code by wrapping the Go toolchain.\n\n\tgarble [garble flags] command [go flags] [go arguments]\n\nFor example, to build an obfuscated program:\n\n\tgarble build ./cmd/foo\n\nSimilarly, to combine garble flags and Go build flags:\n\n\tgarble -literals build -tags=purego ./cmd/foo\n\nThe following commands are supported:\n\n\tbuild          replace \"go build\"\n\ttest           replace \"go test\"\n\trun            replace \"go run\"\n\treverse        de-obfuscate output such as stack traces\n\tversion        print the version and build settings of the garble binary\n\nTo learn more about a command, run \"garble help <command>\".\n\ngarble accepts the following flags before a command:\n\n`[1:])\n\tflagSet.PrintDefaults()\n\tfmt.Fprint(os.Stderr, `\n\nFor more information, see https://github.com/burrowers/garble.\n`[1:])\n}\n\nvar (\n\t// Presumably OK to share fset across packages.\n\tfset = token.NewFileSet()\n\n\tsharedTempDir = os.Getenv(\"GARBLE_SHARED\")\n\tparentWorkDir = os.Getenv(\"GARBLE_PARENT_WORK\")\n)\n\nconst actionGraphFileName = \"action-graph.json\"\n\ntype importerWithMap struct {\n\timportMap  map[string]string\n\timportFrom func(path, dir string, mode types.ImportMode) (*types.Package, error)\n}\n\nfunc (im importerWithMap) Import(path string) (*types.Package, error) {\n\tpanic(\"should never be called\")\n}\n\nfunc (im importerWithMap) ImportFrom(path, dir string, mode types.ImportMode) (*types.Package, error) {\n\tif path2 := im.importMap[path]; path2 != \"\" {\n\t\tpath = path2\n\t}\n\treturn im.importFrom(path, dir, mode)\n}\n\nfunc importerForPkg(lpkg *listedPackage) importerWithMap {\n\treturn importerWithMap{\n\t\timportFrom: importer.ForCompiler(fset, \"gc\", func(path string) (io.ReadCloser, error) {\n\t\t\tpkg, err := listPackage(lpkg, path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn os.Open(pkg.Export)\n\t\t}).(types.ImporterFrom).ImportFrom,\n\t\timportMap: lpkg.ImportMap,\n\t}\n}\n\n// uniqueLineWriter sits underneath log.SetOutput to deduplicate log lines.\n// We log bits of useful information for debugging,\n// and logging the same detail twice is not going to help the user.\n// Duplicates are relatively normal, given that names tend to repeat.\ntype uniqueLineWriter struct {\n\tout  io.Writer\n\tseen map[string]bool\n}\n\nfunc (w *uniqueLineWriter) Write(p []byte) (n int, err error) {\n\tif !flagDebug {\n\t\tpanic(\"unexpected use of uniqueLineWriter with -debug unset\")\n\t}\n\tif bytes.Count(p, []byte(\"\\n\")) != 1 {\n\t\treturn 0, fmt.Errorf(\"log write wasn't just one line: %q\", p)\n\t}\n\tif w.seen[string(p)] {\n\t\treturn len(p), nil\n\t}\n\tif w.seen == nil {\n\t\tw.seen = make(map[string]bool)\n\t}\n\tw.seen[string(p)] = true\n\treturn w.out.Write(p)\n}\n\n// debugSince is like time.Since but resulting in shorter output.\n// A build process takes at least hundreds of milliseconds,\n// so extra decimal points in the order of microseconds aren't meaningful.\nfunc debugSince(start time.Time) time.Duration {\n\treturn time.Since(start).Truncate(10 * time.Microsecond)\n}\n\nfunc main() {\n\tif dir := os.Getenv(\"GARBLE_WRITE_CPUPROFILES\"); dir != \"\" {\n\t\tf, err := os.CreateTemp(dir, \"garble-cpu-*.pprof\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif err := pprof.StartCPUProfile(f); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer func() {\n\t\t\tpprof.StopCPUProfile()\n\t\t\tif err := f.Close(); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}()\n\t}\n\tdefer func() {\n\t\tif dir := os.Getenv(\"GARBLE_WRITE_MEMPROFILES\"); dir != \"\" {\n\t\t\tf, err := os.CreateTemp(dir, \"garble-mem-*.pprof\")\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\truntime.GC() // get up-to-date statistics\n\t\t\tif err := pprof.WriteHeapProfile(f); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif err := f.Close(); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tif os.Getenv(\"GARBLE_WRITE_ALLOCS\") == \"true\" {\n\t\t\tvar memStats runtime.MemStats\n\t\t\truntime.ReadMemStats(&memStats)\n\t\t\tfmt.Fprintf(os.Stderr, \"garble allocs: %d\\n\", memStats.Mallocs)\n\t\t}\n\t}()\n\tflagSet.Parse(os.Args[1:])\n\tlog.SetPrefix(\"[garble] \")\n\tlog.SetFlags(0) // no timestamps, as they aren't very useful\n\tif flagDebug {\n\t\t// TODO: cover this in the tests.\n\t\tlog.SetOutput(&uniqueLineWriter{out: os.Stderr})\n\t} else {\n\t\tlog.SetOutput(io.Discard)\n\t}\n\targs := flagSet.Args()\n\tif len(args) < 1 {\n\t\tusage()\n\t\tos.Exit(2)\n\t}\n\n\t// If a random seed was used, the user won't be able to reproduce the\n\t// same output or failure unless we print the random seed we chose.\n\t// If the build failed and a random seed was used,\n\t// the failure might not reproduce with a different seed.\n\t// Print it before we exit.\n\tif flagSeed.random {\n\t\tfmt.Fprintf(os.Stderr, \"-seed chosen at random: %s\\n\", base64.RawStdEncoding.EncodeToString(flagSeed.bytes))\n\t}\n\tif err := mainErr(args); err != nil {\n\t\tif code, ok := err.(errJustExit); ok {\n\t\t\tos.Exit(int(code))\n\t\t}\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n\ntype errJustExit int\n\nfunc (e errJustExit) Error() string { return fmt.Sprintf(\"exit: %d\", e) }\n\nfunc goVersionOK() bool {\n\tconst (\n\t\tminGoVersion = \"go1.23\" // the first major version we support\n\t\tmaxGoVersion = \"go1.24\" // the first major version we don't support\n\t)\n\n\t// rxVersion looks for a version like \"go1.2\" or \"go1.2.3\" in `go env GOVERSION`.\n\trxVersion := regexp.MustCompile(`go\\d+\\.\\d+(?:\\.\\d+)?`)\n\n\ttoolchainVersionFull := sharedCache.GoEnv.GOVERSION\n\tsharedCache.GoVersion = rxVersion.FindString(toolchainVersionFull)\n\tif sharedCache.GoVersion == \"\" {\n\t\t// Go 1.15.x and older did not have GOVERSION yet; they are too old anyway.\n\t\tfmt.Fprintf(os.Stderr, \"Go version is too old; please upgrade to %s or newer\\n\", minGoVersion)\n\t\treturn false\n\t}\n\n\tif version.Compare(sharedCache.GoVersion, minGoVersion) < 0 {\n\t\tfmt.Fprintf(os.Stderr, \"Go version %q is too old; please upgrade to %s or newer\\n\", toolchainVersionFull, minGoVersion)\n\t\treturn false\n\t}\n\tif version.Compare(sharedCache.GoVersion, maxGoVersion) >= 0 {\n\t\tfmt.Fprintf(os.Stderr, \"Go version %q is too new; Go linker patches aren't available for %s or later yet\\n\", toolchainVersionFull, maxGoVersion)\n\t\treturn false\n\t}\n\n\t// Ensure that the version of Go that built the garble binary is equal or\n\t// newer than cache.GoVersionSemver.\n\tbuiltVersionFull := cmp.Or(os.Getenv(\"GARBLE_TEST_GOVERSION\"), runtime.Version())\n\tbuiltVersion := rxVersion.FindString(builtVersionFull)\n\tif builtVersion == \"\" {\n\t\t// If garble built itself, we don't know what Go version was used.\n\t\t// Fall back to not performing the check against the toolchain version.\n\t\treturn true\n\t}\n\tif version.Compare(builtVersion, sharedCache.GoVersion) < 0 {\n\t\tfmt.Fprintf(os.Stderr, `\ngarble was built with %q and can't be used with the newer %q; rebuild it with a command like:\n    go install mvdan.cc/garble@latest\n`[1:], builtVersionFull, toolchainVersionFull)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc mainErr(args []string) error {\n\t// TODO(mvdan): until we can rely on alias tracking to work reliably,\n\t// we must turn it off so that we don't get inconsistent types.\n\t// See: https://go.dev/issue/70394\n\tos.Setenv(\"GODEBUG\", \"gotypesalias=0\")\n\n\tcommand, args := args[0], args[1:]\n\n\t// Catch users reaching for `go build -toolexec=garble`.\n\tif command != \"toolexec\" && len(args) == 1 && args[0] == \"-V=full\" {\n\t\treturn fmt.Errorf(`did you run \"go [command] -toolexec=garble\" instead of \"garble [command]\"?`)\n\t}\n\n\tswitch command {\n\tcase \"help\":\n\t\tif hasHelpFlag(args) || len(args) > 1 {\n\t\t\tfmt.Fprintf(os.Stderr, \"usage: garble help [command]\\n\")\n\t\t\treturn errJustExit(0)\n\t\t}\n\t\tif len(args) == 1 {\n\t\t\treturn mainErr([]string{args[0], \"-h\"})\n\t\t}\n\t\tusage()\n\t\treturn errJustExit(0)\n\tcase \"version\":\n\t\tif hasHelpFlag(args) || len(args) > 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"usage: garble version\\n\")\n\t\t\treturn errJustExit(2)\n\t\t}\n\t\tinfo, ok := debug.ReadBuildInfo()\n\t\tif !ok {\n\t\t\t// The build binary was stripped of build info?\n\t\t\t// Could be the case if garble built itself.\n\t\t\tfmt.Println(\"unknown\")\n\t\t\treturn nil\n\t\t}\n\t\tmod := &info.Main\n\t\tif mod.Replace != nil {\n\t\t\tmod = mod.Replace\n\t\t}\n\n\t\t// For the tests.\n\t\tif v := os.Getenv(\"GARBLE_TEST_BUILDSETTINGS\"); v != \"\" {\n\t\t\tvar extra []debug.BuildSetting\n\t\t\tif err := json.Unmarshal([]byte(v), &extra); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tinfo.Settings = append(info.Settings, extra...)\n\t\t}\n\n\t\t// Until https://github.com/golang/go/issues/50603 is implemented,\n\t\t// manually construct something like a pseudo-version.\n\t\t// TODO: remove when this code is dead, hopefully in Go 1.22.\n\t\tif mod.Version == \"(devel)\" {\n\t\t\tvar vcsTime time.Time\n\t\t\tvar vcsRevision string\n\t\t\tfor _, setting := range info.Settings {\n\t\t\t\tswitch setting.Key {\n\t\t\t\tcase \"vcs.time\":\n\t\t\t\t\t// If the format is invalid, we'll print a zero timestamp.\n\t\t\t\t\tvcsTime, _ = time.Parse(time.RFC3339Nano, setting.Value)\n\t\t\t\tcase \"vcs.revision\":\n\t\t\t\t\tvcsRevision = setting.Value\n\t\t\t\t\tif len(vcsRevision) > 12 {\n\t\t\t\t\t\tvcsRevision = vcsRevision[:12]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif vcsRevision != \"\" {\n\t\t\t\tmod.Version = module.PseudoVersion(\"\", \"\", vcsTime, vcsRevision)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Printf(\"%s %s\\n\\n\", mod.Path, mod.Version)\n\t\tfmt.Printf(\"Build settings:\\n\")\n\t\tfor _, setting := range info.Settings {\n\t\t\tif setting.Value == \"\" {\n\t\t\t\tcontinue // do empty build settings even matter?\n\t\t\t}\n\t\t\t// The padding helps keep readability by aligning:\n\t\t\t//\n\t\t\t//   veryverylong.key value\n\t\t\t//          short.key some-other-value\n\t\t\t//\n\t\t\t// Empirically, 16 is enough; the longest key seen is \"vcs.revision\".\n\t\t\tfmt.Printf(\"%16s %s\\n\", setting.Key, setting.Value)\n\t\t}\n\t\treturn nil\n\tcase \"reverse\":\n\t\treturn commandReverse(args)\n\tcase \"build\", \"test\", \"run\":\n\t\tcmd, err := toolexecCmd(command, args)\n\t\tdefer func() {\n\t\t\tif err := os.RemoveAll(os.Getenv(\"GARBLE_SHARED\")); err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"could not clean up GARBLE_SHARED: %v\\n\", err)\n\t\t\t}\n\t\t\t// skip the trim if we didn't even start a build\n\t\t\tif sharedCache != nil {\n\t\t\t\tfsCache, err := openCache()\n\t\t\t\tif err == nil {\n\t\t\t\t\terr = fsCache.Trim()\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"could not trim GARBLE_CACHE: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\tlog.Printf(\"calling via toolexec: %s\", cmd)\n\t\treturn cmd.Run()\n\n\tcase \"toolexec\":\n\t\t_, tool := filepath.Split(args[0])\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\ttool = strings.TrimSuffix(tool, \".exe\")\n\t\t}\n\t\ttransform := transformMethods[tool]\n\t\ttransformed := args[1:]\n\t\tif transform != nil {\n\t\t\tstartTime := time.Now()\n\t\t\tlog.Printf(\"transforming %s with args: %s\", tool, strings.Join(transformed, \" \"))\n\n\t\t\t// We're in a toolexec sub-process, not directly called by the user.\n\t\t\t// Load the shared data and wrap the tool, like the compiler or linker.\n\t\t\tif err := loadSharedCache(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif len(args) == 2 && args[1] == \"-V=full\" {\n\t\t\t\treturn alterToolVersion(tool, args)\n\t\t\t}\n\t\t\tvar tf transformer\n\t\t\ttoolexecImportPath := os.Getenv(\"TOOLEXEC_IMPORTPATH\")\n\t\t\ttf.curPkg = sharedCache.ListedPackages[toolexecImportPath]\n\t\t\tif tf.curPkg == nil {\n\t\t\t\treturn fmt.Errorf(\"TOOLEXEC_IMPORTPATH not found in listed packages: %s\", toolexecImportPath)\n\t\t\t}\n\t\t\ttf.origImporter = importerForPkg(tf.curPkg)\n\n\t\t\tvar err error\n\t\t\tif transformed, err = transform(&tf, transformed); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tlog.Printf(\"transformed args for %s in %s: %s\", tool, debugSince(startTime), strings.Join(transformed, \" \"))\n\t\t} else {\n\t\t\tlog.Printf(\"skipping transform on %s with args: %s\", tool, strings.Join(transformed, \" \"))\n\t\t}\n\n\t\texecutablePath := args[0]\n\t\tif tool == \"link\" {\n\t\t\tmodifiedLinkPath, unlock, err := linker.PatchLinker(sharedCache.GoEnv.GOROOT, sharedCache.GoEnv.GOVERSION, sharedCache.CacheDir, sharedTempDir)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"cannot get modified linker: %v\", err)\n\t\t\t}\n\t\t\tdefer unlock()\n\n\t\t\texecutablePath = modifiedLinkPath\n\t\t\tos.Setenv(linker.MagicValueEnv, strconv.FormatUint(uint64(magicValue()), 10))\n\t\t\tos.Setenv(linker.EntryOffKeyEnv, strconv.FormatUint(uint64(entryOffKey()), 10))\n\t\t\tif flagTiny {\n\t\t\t\tos.Setenv(linker.TinyEnv, \"true\")\n\t\t\t}\n\n\t\t\tlog.Printf(\"replaced linker with: %s\", executablePath)\n\t\t}\n\n\t\tcmd := exec.Command(executablePath, transformed...)\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\tif err := cmd.Run(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown command: %q\", command)\n\t}\n}\n\nfunc hasHelpFlag(flags []string) bool {\n\tfor _, f := range flags {\n\t\tswitch f {\n\t\tcase \"-h\", \"-help\", \"--help\":\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// toolexecCmd builds an *exec.Cmd which is set up for running \"go <command>\"\n// with -toolexec=garble and the supplied arguments.\n//\n// Note that it uses and modifies global state; in general, it should only be\n// called once from mainErr in the top-level garble process.\nfunc toolexecCmd(command string, args []string) (*exec.Cmd, error) {\n\t// Split the flags from the package arguments, since we'll need\n\t// to run 'go list' on the same set of packages.\n\tflags, args := splitFlagsFromArgs(args)\n\tif hasHelpFlag(flags) {\n\t\tout, _ := exec.Command(\"go\", command, \"-h\").CombinedOutput()\n\t\tfmt.Fprintf(os.Stderr, `\nusage: garble [garble flags] %s [arguments]\n\nThis command wraps \"go %s\". Below is its help:\n\n%s`[1:], command, command, out)\n\t\treturn nil, errJustExit(2)\n\t}\n\tfor _, flag := range flags {\n\t\tif rxGarbleFlag.MatchString(flag) {\n\t\t\treturn nil, fmt.Errorf(\"garble flags must precede command, like: garble %s build ./pkg\", flag)\n\t\t}\n\t}\n\n\t// Here is the only place we initialize the cache.\n\t// The sub-processes will parse it from a shared gob file.\n\tsharedCache = &sharedCacheType{}\n\n\t// Note that we also need to pass build flags to 'go list', such\n\t// as -tags.\n\tsharedCache.ForwardBuildFlags, _ = filterForwardBuildFlags(flags)\n\tif command == \"test\" {\n\t\tsharedCache.ForwardBuildFlags = append(sharedCache.ForwardBuildFlags, \"-test\")\n\t}\n\n\tif err := fetchGoEnv(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !goVersionOK() {\n\t\treturn nil, errJustExit(1)\n\t}\n\n\texecPath, err := os.Executable()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Always an absolute directory; defaults to e.g. \"~/.cache/garble\".\n\tif dir := os.Getenv(\"GARBLE_CACHE\"); dir != \"\" {\n\t\tsharedCache.CacheDir, err = filepath.Abs(dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tparentDir, err := os.UserCacheDir()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsharedCache.CacheDir = filepath.Join(parentDir, \"garble\")\n\t}\n\n\tbinaryBuildID, err := buildidOf(execPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsharedCache.BinaryContentID = decodeBuildIDHash(splitContentID(binaryBuildID))\n\n\tif err := appendListedPackages(args, true); err != nil {\n\t\treturn nil, err\n\t}\n\n\tsharedTempDir, err = saveSharedCache()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tos.Setenv(\"GARBLE_SHARED\", sharedTempDir)\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tos.Setenv(\"GARBLE_PARENT_WORK\", wd)\n\n\tif flagDebugDir != \"\" {\n\t\tif !filepath.IsAbs(flagDebugDir) {\n\t\t\tflagDebugDir = filepath.Join(wd, flagDebugDir)\n\t\t}\n\n\t\tif err := os.RemoveAll(flagDebugDir); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not empty debugdir: %v\", err)\n\t\t}\n\t\tif err := os.MkdirAll(flagDebugDir, 0o755); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tgoArgs := append([]string{command}, garbleBuildFlags...)\n\n\t// Pass the garble flags down to each toolexec invocation.\n\t// This way, all garble processes see the same flag values.\n\t// Note that we can end up with a single argument to `go` in the form of:\n\t//\n\t//\t-toolexec='/binary dir/garble' -tiny toolexec\n\t//\n\t// We quote the absolute path to garble if it contains spaces.\n\t// We can add extra flags to the end of the same -toolexec argument.\n\tvar toolexecFlag strings.Builder\n\ttoolexecFlag.WriteString(\"-toolexec=\")\n\tquotedExecPath, err := cmdgoQuotedJoin([]string{execPath})\n\tif err != nil {\n\t\t// Can only happen if the absolute path to the garble binary contains\n\t\t// both single and double quotes. Seems extremely unlikely.\n\t\treturn nil, err\n\t}\n\ttoolexecFlag.WriteString(quotedExecPath)\n\tappendFlags(&toolexecFlag, false)\n\ttoolexecFlag.WriteString(\" toolexec\")\n\tgoArgs = append(goArgs, toolexecFlag.String())\n\n\tif flagControlFlow {\n\t\tgoArgs = append(goArgs, \"-debug-actiongraph\", filepath.Join(sharedTempDir, actionGraphFileName))\n\t}\n\tif flagDebugDir != \"\" {\n\t\t// In case the user deletes the debug directory,\n\t\t// and a previous build is cached,\n\t\t// rebuild all packages to re-fill the debug dir.\n\t\tgoArgs = append(goArgs, \"-a\")\n\t}\n\tif command == \"test\" {\n\t\t// vet is generally not useful on obfuscated code; keep it\n\t\t// disabled by default.\n\t\tgoArgs = append(goArgs, \"-vet=off\")\n\t}\n\tgoArgs = append(goArgs, flags...)\n\tgoArgs = append(goArgs, args...)\n\n\treturn exec.Command(\"go\", goArgs...), nil\n}\n\nvar transformMethods = map[string]func(*transformer, []string) ([]string, error){\n\t\"asm\":     (*transformer).transformAsm,\n\t\"compile\": (*transformer).transformCompile,\n\t\"link\":    (*transformer).transformLink,\n}\n\nfunc (tf *transformer) transformAsm(args []string) ([]string, error) {\n\tflags, paths := splitFlagsFromFiles(args, \".s\")\n\n\t// When assembling, the import path can make its way into the output object file.\n\tif tf.curPkg.Name != \"main\" && tf.curPkg.ToObfuscate {\n\t\tflags = flagSetValue(flags, \"-p\", tf.curPkg.obfuscatedImportPath())\n\t}\n\n\tflags = alterTrimpath(flags)\n\n\t// The assembler runs twice; the first with -gensymabis,\n\t// where we continue below and we obfuscate all the source.\n\t// The second time, without -gensymabis, we reconstruct the paths to the\n\t// obfuscated source files and reuse them to avoid work.\n\tnewPaths := make([]string, 0, len(paths))\n\tif !slices.Contains(args, \"-gensymabis\") {\n\t\tfor _, path := range paths {\n\t\t\tname := hashWithPackage(tf.curPkg, filepath.Base(path)) + \".s\"\n\t\t\tpkgDir := filepath.Join(sharedTempDir, tf.curPkg.obfuscatedImportPath())\n\t\t\tnewPath := filepath.Join(pkgDir, name)\n\t\t\tnewPaths = append(newPaths, newPath)\n\t\t}\n\t\treturn append(flags, newPaths...), nil\n\t}\n\n\tconst missingHeader = \"missing header path\"\n\tnewHeaderPaths := make(map[string]string)\n\tvar buf, includeBuf bytes.Buffer\n\tfor _, path := range paths {\n\t\tbuf.Reset()\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer f.Close() // in case of error\n\t\tscanner := bufio.NewScanner(f)\n\t\tfor scanner.Scan() {\n\t\t\tline := scanner.Text()\n\n\t\t\t// Whole-line comments might be directives, leave them in place.\n\t\t\t// For example: //go:build race\n\t\t\t// Any other comment, including inline ones, can be discarded entirely.\n\t\t\tline, comment, hasComment := strings.Cut(line, \"//\")\n\t\t\tif hasComment && line == \"\" {\n\t\t\t\tbuf.WriteString(\"//\")\n\t\t\t\tbuf.WriteString(comment)\n\t\t\t\tbuf.WriteByte('\\n')\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Preprocessor lines to include another file.\n\t\t\t// For example: #include \"foo.h\"\n\t\t\tif quoted := strings.TrimPrefix(line, \"#include\"); quoted != line {\n\t\t\t\tquoted = strings.TrimSpace(quoted)\n\t\t\t\tpath, err := strconv.Unquote(quoted)\n\t\t\t\tif err != nil { // note that strconv.Unquote errors do not include the input string\n\t\t\t\t\treturn nil, fmt.Errorf(\"cannot unquote %q: %v\", quoted, err)\n\t\t\t\t}\n\t\t\t\tnewPath := newHeaderPaths[path]\n\t\t\t\tswitch newPath {\n\t\t\t\tcase missingHeader: // no need to try again\n\t\t\t\t\tbuf.WriteString(line)\n\t\t\t\t\tbuf.WriteByte('\\n')\n\t\t\t\t\tcontinue\n\t\t\t\tcase \"\": // first time we see this header\n\t\t\t\t\tincludeBuf.Reset()\n\t\t\t\t\tcontent, err := os.ReadFile(path)\n\t\t\t\t\tif errors.Is(err, fs.ErrNotExist) {\n\t\t\t\t\t\tnewHeaderPaths[path] = missingHeader\n\t\t\t\t\t\tbuf.WriteString(line)\n\t\t\t\t\t\tbuf.WriteByte('\\n')\n\t\t\t\t\t\tcontinue // a header file provided by Go or the system\n\t\t\t\t\t} else if err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\ttf.replaceAsmNames(&includeBuf, content)\n\n\t\t\t\t\t// For now, we replace `foo.h` or `dir/foo.h` with `garbled_foo.h`.\n\t\t\t\t\t// The different name ensures we don't use the unobfuscated file.\n\t\t\t\t\t// This is far from perfect, but does the job for the time being.\n\t\t\t\t\t// In the future, use a randomized name.\n\t\t\t\t\tbasename := filepath.Base(path)\n\t\t\t\t\tnewPath = \"garbled_\" + basename\n\n\t\t\t\t\tif _, err := tf.writeSourceFile(basename, newPath, includeBuf.Bytes()); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tnewHeaderPaths[path] = newPath\n\t\t\t\t}\n\t\t\t\tbuf.WriteString(\"#include \")\n\t\t\t\tbuf.WriteString(strconv.Quote(newPath))\n\t\t\t\tbuf.WriteByte('\\n')\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Anything else is regular assembly; replace the names.\n\t\t\ttf.replaceAsmNames(&buf, []byte(line))\n\t\t\tbuf.WriteByte('\\n')\n\t\t}\n\t\tif err := scanner.Err(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// With assembly files, we obfuscate the filename in the temporary\n\t\t// directory, as assembly files do not support `/*line` directives.\n\t\t// TODO(mvdan): per cmd/asm/internal/lex, they do support `#line`.\n\t\tbasename := filepath.Base(path)\n\t\tnewName := hashWithPackage(tf.curPkg, basename) + \".s\"\n\t\tif path, err := tf.writeSourceFile(basename, newName, buf.Bytes()); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tnewPaths = append(newPaths, path)\n\t\t}\n\t\tf.Close() // do not keep len(paths) files open\n\t}\n\n\treturn append(flags, newPaths...), nil\n}\n\nfunc (tf *transformer) replaceAsmNames(buf *bytes.Buffer, remaining []byte) {\n\t// We need to replace all function references with their obfuscated name\n\t// counterparts.\n\t// Luckily, all func names in Go assembly files are immediately followed\n\t// by the unicode \"middle dot\", like:\n\t//\n\t//\tTEXT ·privateAdd(SB),$0-24\n\t//\tTEXT runtime∕internal∕sys·Ctz64(SB), NOSPLIT, $0-12\n\t//\n\t// Note that import paths in assembly, like `runtime∕internal∕sys` above,\n\t// use Unicode periods and slashes rather than the ASCII ones used by `go list`.\n\t// We need to convert to ASCII to find the right package information.\n\tconst (\n\t\tasmPeriod = '·'\n\t\tgoPeriod  = '.'\n\t\tasmSlash  = '∕'\n\t\tgoSlash   = '/'\n\t)\n\tasmPeriodLen := utf8.RuneLen(asmPeriod)\n\n\tfor {\n\t\tperiodIdx := bytes.IndexRune(remaining, asmPeriod)\n\t\tif periodIdx < 0 {\n\t\t\tbuf.Write(remaining)\n\t\t\tremaining = nil\n\t\t\tbreak\n\t\t}\n\n\t\t// The package name ends at the first rune which cannot be part of a Go\n\t\t// import path, such as a comma or space.\n\t\tpkgStart := periodIdx\n\t\tfor pkgStart >= 0 {\n\t\t\tc, size := utf8.DecodeLastRune(remaining[:pkgStart])\n\t\t\tif !unicode.IsLetter(c) && c != '_' && c != asmSlash && !unicode.IsDigit(c) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tpkgStart -= size\n\t\t}\n\t\t// The package name might actually be longer, e.g:\n\t\t//\n\t\t//\tJMP test∕with·many·dots∕main∕imported·PublicAdd(SB)\n\t\t//\n\t\t// We have `test∕with` so far; grab `·many·dots∕main∕imported` as well.\n\t\tpkgEnd := periodIdx\n\t\tlastAsmPeriod := -1\n\t\tfor i := pkgEnd + asmPeriodLen; i <= len(remaining); {\n\t\t\tc, size := utf8.DecodeRune(remaining[i:])\n\t\t\tif c == asmPeriod {\n\t\t\t\tlastAsmPeriod = i\n\t\t\t} else if !unicode.IsLetter(c) && c != '_' && c != asmSlash && !unicode.IsDigit(c) {\n\t\t\t\tif lastAsmPeriod > 0 {\n\t\t\t\t\tpkgEnd = lastAsmPeriod\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti += size\n\t\t}\n\t\tasmPkgPath := string(remaining[pkgStart:pkgEnd])\n\n\t\t// Write the bytes before our unqualified `·foo` or qualified `pkg·foo`.\n\t\tbuf.Write(remaining[:pkgStart])\n\n\t\t// If the name was qualified, fetch the package, and write the\n\t\t// obfuscated import path if needed.\n\t\t// Note that we don't obfuscate the package path \"main\".\n\t\tlpkg := tf.curPkg\n\t\tif asmPkgPath != \"\" && asmPkgPath != \"main\" {\n\t\t\tif asmPkgPath != tf.curPkg.Name {\n\t\t\t\tgoPkgPath := asmPkgPath\n\t\t\t\tgoPkgPath = strings.ReplaceAll(goPkgPath, string(asmPeriod), string(goPeriod))\n\t\t\t\tgoPkgPath = strings.ReplaceAll(goPkgPath, string(asmSlash), string(goSlash))\n\t\t\t\tvar err error\n\t\t\t\tlpkg, err = listPackage(tf.curPkg, goPkgPath)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err) // shouldn't happen\n\t\t\t\t}\n\t\t\t}\n\t\t\tif lpkg.ToObfuscate {\n\t\t\t\t// Note that we don't need to worry about asmSlash here,\n\t\t\t\t// because our obfuscated import paths contain no slashes right now.\n\t\t\t\tbuf.WriteString(lpkg.obfuscatedImportPath())\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(asmPkgPath)\n\t\t\t}\n\t\t}\n\n\t\t// Write the middle dot and advance the remaining slice.\n\t\tbuf.WriteRune(asmPeriod)\n\t\tremaining = remaining[pkgEnd+asmPeriodLen:]\n\n\t\t// The declared name ends at the first rune which cannot be part of a Go\n\t\t// identifier, such as a comma or space.\n\t\tnameEnd := 0\n\t\tfor nameEnd < len(remaining) {\n\t\t\tc, size := utf8.DecodeRune(remaining[nameEnd:])\n\t\t\tif !unicode.IsLetter(c) && c != '_' && !unicode.IsDigit(c) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnameEnd += size\n\t\t}\n\t\tname := string(remaining[:nameEnd])\n\t\tremaining = remaining[nameEnd:]\n\n\t\tif lpkg.ToObfuscate && !compilerIntrinsics[lpkg.ImportPath][name] {\n\t\t\tnewName := hashWithPackage(lpkg, name)\n\t\t\tif flagDebug { // TODO(mvdan): remove once https://go.dev/issue/53465 if fixed\n\t\t\t\tlog.Printf(\"asm name %q hashed with %x to %q\", name, tf.curPkg.GarbleActionID, newName)\n\t\t\t}\n\t\t\tbuf.WriteString(newName)\n\t\t} else {\n\t\t\tbuf.WriteString(name)\n\t\t}\n\t}\n}\n\n// writeSourceFile is a mix between os.CreateTemp and os.WriteFile, as it writes a\n// named source file in sharedTempDir given an input buffer.\n//\n// Note that the file is created under a directory tree following curPkg's\n// import path, mimicking how files are laid out in modules and GOROOT.\nfunc (tf *transformer) writeSourceFile(basename, obfuscated string, content []byte) (string, error) {\n\t// Uncomment for some quick debugging. Do not delete.\n\t// fmt.Fprintf(os.Stderr, \"\\n-- %s/%s --\\n%s\", curPkg.ImportPath, basename, content)\n\n\tif flagDebugDir != \"\" {\n\t\tpkgDir := filepath.Join(flagDebugDir, filepath.FromSlash(tf.curPkg.ImportPath))\n\t\tif err := os.MkdirAll(pkgDir, 0o755); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tdstPath := filepath.Join(pkgDir, basename)\n\t\tif err := os.WriteFile(dstPath, content, 0o666); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\t// We use the obfuscated import path to hold the temporary files.\n\t// Assembly files do not support line directives to set positions,\n\t// so the only way to not leak the import path is to replace it.\n\tpkgDir := filepath.Join(sharedTempDir, tf.curPkg.obfuscatedImportPath())\n\tif err := os.MkdirAll(pkgDir, 0o777); err != nil {\n\t\treturn \"\", err\n\t}\n\tdstPath := filepath.Join(pkgDir, obfuscated)\n\tif err := writeFileExclusive(dstPath, content); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn dstPath, nil\n}\n\n// parseFiles parses a list of Go files.\n// It supports relative file paths, such as those found in listedPackage.CompiledGoFiles,\n// as long as dir is set to listedPackage.Dir.\nfunc parseFiles(lpkg *listedPackage, dir string, paths []string) (files []*ast.File, err error) {\n\tmainPackage := lpkg.Name == \"main\" && lpkg.ForTest == \"\"\n\n\tfor _, path := range paths {\n\t\tif !filepath.IsAbs(path) {\n\t\t\tpath = filepath.Join(dir, path)\n\t\t}\n\n\t\tvar src any\n\n\t\tif lpkg.ImportPath == \"internal/abi\" && filepath.Base(path) == \"type.go\" {\n\t\t\tsrc, err = abiNamePatch(path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else if mainPackage && reflectPatchFile == \"\" {\n\t\t\tsrc, err = reflectMainPrePatch(path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treflectPatchFile = path\n\t\t}\n\n\t\tfile, err := parser.ParseFile(fset, path, src, parser.SkipObjectResolution|parser.ParseComments)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif mainPackage && src != nil {\n\t\t\tastutil.AddNamedImport(fset, file, \"_\", \"unsafe\")\n\t\t}\n\n\t\tfiles = append(files, file)\n\t}\n\treturn files, nil\n}\n\nfunc (tf *transformer) transformCompile(args []string) ([]string, error) {\n\tflags, paths := splitFlagsFromFiles(args, \".go\")\n\n\t// We will force the linker to drop DWARF via -w, so don't spend time\n\t// generating it.\n\tflags = append(flags, \"-dwarf=false\")\n\n\t// The Go file paths given to the compiler are always absolute paths.\n\tfiles, err := parseFiles(tf.curPkg, \"\", paths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Literal and control flow obfuscation uses math/rand, so seed it deterministically.\n\trandSeed := tf.curPkg.GarbleActionID[:]\n\tif flagSeed.present() {\n\t\trandSeed = flagSeed.bytes\n\t}\n\t// log.Printf(\"seeding math/rand with %x\\n\", randSeed)\n\ttf.obfRand = mathrand.New(mathrand.NewSource(int64(binary.BigEndian.Uint64(randSeed))))\n\n\t// Even if loadPkgCache below finds a direct cache hit,\n\t// other parts of garble still need type information to obfuscate.\n\t// We could potentially avoid this by saving the type info we need in the cache,\n\t// although in general that wouldn't help much, since it's rare for Go's cache\n\t// to miss on a package and for our cache to hit.\n\tif tf.pkg, tf.info, err = typecheck(tf.curPkg.ImportPath, files, tf.origImporter); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar (\n\t\tssaPkg       *ssa.Package\n\t\trequiredPkgs []string\n\t)\n\tif flagControlFlow {\n\t\tssaPkg = ssaBuildPkg(tf.pkg, files, tf.info)\n\n\t\tnewFileName, newFile, affectedFiles, err := ctrlflow.Obfuscate(fset, ssaPkg, files, tf.obfRand)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif newFile != nil {\n\t\t\tfiles = append(files, newFile)\n\t\t\tpaths = append(paths, newFileName)\n\t\t\tfor _, file := range affectedFiles {\n\t\t\t\ttf.useAllImports(file)\n\t\t\t}\n\t\t\tif tf.pkg, tf.info, err = typecheck(tf.curPkg.ImportPath, files, tf.origImporter); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor _, imp := range newFile.Imports {\n\t\t\t\tpath, err := strconv.Unquote(imp.Path.Value)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err) // should never happen\n\t\t\t\t}\n\t\t\t\trequiredPkgs = append(requiredPkgs, path)\n\t\t\t}\n\t\t}\n\t}\n\n\tif tf.curPkgCache, err = loadPkgCache(tf.curPkg, tf.pkg, files, tf.info, ssaPkg); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// These maps are not kept in pkgCache, since they are only needed to obfuscate curPkg.\n\ttf.fieldToStruct = computeFieldToStruct(tf.info)\n\tif flagLiterals {\n\t\tif tf.linkerVariableStrings, err = computeLinkerVariableStrings(tf.pkg); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tflags = alterTrimpath(flags)\n\tnewImportCfg, err := tf.processImportCfg(flags, requiredPkgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// If this is a package to obfuscate, swap the -p flag with the new package path.\n\t// We don't if it's the main package, as that just uses \"-p main\".\n\t// We only set newPkgPath if we're obfuscating the import path,\n\t// to replace the original package name in the package clause below.\n\tnewPkgPath := \"\"\n\tif tf.curPkg.Name != \"main\" && tf.curPkg.ToObfuscate {\n\t\tnewPkgPath = tf.curPkg.obfuscatedImportPath()\n\t\tflags = flagSetValue(flags, \"-p\", newPkgPath)\n\t}\n\n\tnewPaths := make([]string, 0, len(files))\n\n\tfor i, file := range files {\n\t\tbasename := filepath.Base(paths[i])\n\t\tlog.Printf(\"obfuscating %s\", basename)\n\t\tif tf.curPkg.ImportPath == \"runtime\" {\n\t\t\tif flagTiny {\n\t\t\t\t// strip unneeded runtime code\n\t\t\t\tstripRuntime(basename, file)\n\t\t\t\ttf.useAllImports(file)\n\t\t\t}\n\t\t\tif basename == \"symtab.go\" {\n\t\t\t\tupdateMagicValue(file, magicValue())\n\t\t\t\tupdateEntryOffset(file, entryOffKey())\n\t\t\t}\n\t\t}\n\t\ttf.transformDirectives(file.Comments)\n\t\tfile = tf.transformGoFile(file)\n\t\t// newPkgPath might be the original ImportPath in some edge cases like\n\t\t// compilerIntrinsics; we don't want to use slashes in package names.\n\t\t// TODO: when we do away with those edge cases, only check the string is\n\t\t// non-empty.\n\t\tif newPkgPath != \"\" && newPkgPath != tf.curPkg.ImportPath {\n\t\t\tfile.Name.Name = newPkgPath\n\t\t}\n\n\t\tsrc, err := printFile(tf.curPkg, file)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif tf.curPkg.Name == \"main\" && strings.HasSuffix(reflectPatchFile, basename) {\n\t\t\tsrc = reflectMainPostPatch(src, tf.curPkg, tf.curPkgCache)\n\t\t}\n\n\t\t// We hide Go source filenames via \"//line\" directives,\n\t\t// so there is no need to use obfuscated filenames here.\n\t\tif path, err := tf.writeSourceFile(basename, basename, src); err != nil {\n\t\t\treturn nil, err\n\t\t} else {\n\t\t\tnewPaths = append(newPaths, path)\n\t\t}\n\t}\n\tflags = flagSetValue(flags, \"-importcfg\", newImportCfg)\n\n\treturn append(flags, newPaths...), nil\n}\n\n// transformDirectives rewrites //go:linkname toolchain directives in comments\n// to replace names with their obfuscated versions.\nfunc (tf *transformer) transformDirectives(comments []*ast.CommentGroup) {\n\tfor _, group := range comments {\n\t\tfor _, comment := range group.List {\n\t\t\tif !strings.HasPrefix(comment.Text, \"//go:linkname \") {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// We can have either just one argument:\n\t\t\t//\n\t\t\t//\t//go:linkname localName\n\t\t\t//\n\t\t\t// Or two arguments, where the second may refer to a name in a\n\t\t\t// different package:\n\t\t\t//\n\t\t\t//\t//go:linkname localName newName\n\t\t\t//\t//go:linkname localName pkg.newName\n\t\t\tfields := strings.Fields(comment.Text)\n\t\t\tlocalName := fields[1]\n\t\t\tnewName := \"\"\n\t\t\tif len(fields) == 3 {\n\t\t\t\tnewName = fields[2]\n\t\t\t}\n\n\t\t\tlocalName, newName = tf.transformLinkname(localName, newName)\n\t\t\tfields[1] = localName\n\t\t\tif len(fields) == 3 {\n\t\t\t\tfields[2] = newName\n\t\t\t}\n\n\t\t\tif flagDebug { // TODO(mvdan): remove once https://go.dev/issue/53465 if fixed\n\t\t\t\tlog.Printf(\"linkname %q changed to %q\", comment.Text, strings.Join(fields, \" \"))\n\t\t\t}\n\t\t\tcomment.Text = strings.Join(fields, \" \")\n\t\t}\n\t}\n}\n\nfunc (tf *transformer) transformLinkname(localName, newName string) (string, string) {\n\t// obfuscate the local name, if the current package is obfuscated\n\tif tf.curPkg.ToObfuscate && !compilerIntrinsics[tf.curPkg.ImportPath][localName] {\n\t\tlocalName = hashWithPackage(tf.curPkg, localName)\n\t}\n\tif newName == \"\" {\n\t\treturn localName, \"\"\n\t}\n\t// If the new name is of the form \"pkgpath.Name\", and we've obfuscated\n\t// \"Name\" in that package, rewrite the directive to use the obfuscated name.\n\tdotCnt := strings.Count(newName, \".\")\n\tif dotCnt < 1 {\n\t\t// cgo-generated code uses linknames to made up symbol names,\n\t\t// which do not have a package path at all.\n\t\t// Replace the comment in case the local name was obfuscated.\n\t\treturn localName, newName\n\t}\n\tswitch newName {\n\tcase \"main.main\", \"main..inittask\", \"runtime..inittask\":\n\t\t// The runtime uses some special symbols with \"..\".\n\t\t// We aren't touching those at the moment.\n\t\treturn localName, newName\n\t}\n\n\tpkgSplit := 0\n\tvar foreignName string\n\tvar lpkg *listedPackage\n\tfor {\n\t\ti := strings.Index(newName[pkgSplit:], \".\")\n\t\tif i < 0 {\n\t\t\t// We couldn't find a prefix that matched a known package.\n\t\t\t// Probably a made up name like above, but with a dot.\n\t\t\treturn localName, newName\n\t\t}\n\t\tpkgSplit += i\n\t\tpkgPath := newName[:pkgSplit]\n\t\tpkgSplit++ // skip over the dot\n\n\t\tif strings.HasSuffix(pkgPath, \"_test\") {\n\t\t\t// runtime uses a go:linkname to metrics_test;\n\t\t\t// we don't need this to work for now on regular builds,\n\t\t\t// though we might need to rethink this if we want \"go test std\" to work.\n\t\t\tcontinue\n\t\t}\n\n\t\tvar err error\n\t\tlpkg, err = listPackage(tf.curPkg, pkgPath)\n\t\tif err == nil {\n\t\t\tforeignName = newName[pkgSplit:]\n\t\t\tbreak\n\t\t}\n\t\tif errors.Is(err, ErrNotFound) {\n\t\t\t// No match; find the next dot.\n\t\t\tcontinue\n\t\t}\n\t\tif errors.Is(err, ErrNotDependency) {\n\t\t\tfmt.Fprintf(os.Stderr,\n\t\t\t\t\"//go:linkname refers to %s - add `import _ %q` for garble to find the package\",\n\t\t\t\tnewName, pkgPath)\n\t\t\treturn localName, newName\n\t\t}\n\t\tpanic(err) // shouldn't happen\n\t}\n\n\tif !lpkg.ToObfuscate || compilerIntrinsics[lpkg.ImportPath][foreignName] {\n\t\t// We're not obfuscating that package or name.\n\t\treturn localName, newName\n\t}\n\n\tvar newForeignName string\n\tif receiver, name, ok := strings.Cut(foreignName, \".\"); ok {\n\t\tif strings.HasPrefix(receiver, \"(*\") {\n\t\t\t// pkg/path.(*Receiver).method\n\t\t\treceiver = strings.TrimPrefix(receiver, \"(*\")\n\t\t\treceiver = strings.TrimSuffix(receiver, \")\")\n\t\t\treceiver = \"(*\" + hashWithPackage(lpkg, receiver) + \")\"\n\t\t} else {\n\t\t\t// pkg/path.Receiver.method\n\t\t\treceiver = hashWithPackage(lpkg, receiver)\n\t\t}\n\t\t// Exported methods are never obfuscated.\n\t\t//\n\t\t// TODO(mvdan): We're duplicating the logic behind these decisions.\n\t\t// Reuse the logic with transformCompile.\n\t\tif !token.IsExported(name) {\n\t\t\tname = hashWithPackage(lpkg, name)\n\t\t}\n\t\tnewForeignName = receiver + \".\" + name\n\t} else {\n\t\t// pkg/path.function\n\t\tnewForeignName = hashWithPackage(lpkg, foreignName)\n\t}\n\n\tnewPkgPath := lpkg.ImportPath\n\tif newPkgPath != \"main\" {\n\t\tnewPkgPath = lpkg.obfuscatedImportPath()\n\t}\n\tnewName = newPkgPath + \".\" + newForeignName\n\treturn localName, newName\n}\n\n// processImportCfg parses the importcfg file passed to a compile or link step.\n// It also builds a new importcfg file to account for obfuscated import paths.\nfunc (tf *transformer) processImportCfg(flags []string, requiredPkgs []string) (newImportCfg string, _ error) {\n\timportCfg := flagValue(flags, \"-importcfg\")\n\tif importCfg == \"\" {\n\t\treturn \"\", fmt.Errorf(\"could not find -importcfg argument\")\n\t}\n\tdata, err := os.ReadFile(importCfg)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar packagefiles, importmaps [][2]string\n\n\t// using for track required but not imported packages\n\tvar newIndirectImports map[string]bool\n\tif requiredPkgs != nil {\n\t\tnewIndirectImports = make(map[string]bool)\n\t\tfor _, pkg := range requiredPkgs {\n\t\t\tnewIndirectImports[pkg] = true\n\t\t}\n\t}\n\n\tfor _, line := range strings.Split(string(data), \"\\n\") {\n\t\tif line == \"\" || strings.HasPrefix(line, \"#\") {\n\t\t\tcontinue\n\t\t}\n\t\tverb, args, found := strings.Cut(line, \" \")\n\t\tif !found {\n\t\t\tcontinue\n\t\t}\n\t\tswitch verb {\n\t\tcase \"importmap\":\n\t\t\tbeforePath, afterPath, found := strings.Cut(args, \"=\")\n\t\t\tif !found {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\timportmaps = append(importmaps, [2]string{beforePath, afterPath})\n\t\tcase \"packagefile\":\n\t\t\timportPath, objectPath, found := strings.Cut(args, \"=\")\n\t\t\tif !found {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpackagefiles = append(packagefiles, [2]string{importPath, objectPath})\n\t\t\tdelete(newIndirectImports, importPath)\n\t\t}\n\t}\n\n\t// Produce the modified importcfg file.\n\t// This is mainly replacing the obfuscated paths.\n\t// Note that we range over maps, so this is non-deterministic, but that\n\t// should not matter as the file is treated like a lookup table.\n\tnewCfg, err := os.CreateTemp(sharedTempDir, \"importcfg\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, pair := range importmaps {\n\t\tbeforePath, afterPath := pair[0], pair[1]\n\t\tlpkg, err := listPackage(tf.curPkg, beforePath)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif lpkg.ToObfuscate {\n\t\t\t// Note that beforePath is not the canonical path.\n\t\t\t// For beforePath=\"vendor/foo\", afterPath and\n\t\t\t// lpkg.ImportPath can be just \"foo\".\n\t\t\t// Don't use obfuscatedImportPath here.\n\t\t\tbeforePath = hashWithPackage(lpkg, beforePath)\n\n\t\t\tafterPath = lpkg.obfuscatedImportPath()\n\t\t}\n\t\tfmt.Fprintf(newCfg, \"importmap %s=%s\\n\", beforePath, afterPath)\n\t}\n\n\tif len(newIndirectImports) > 0 {\n\t\tf, err := os.Open(filepath.Join(sharedTempDir, actionGraphFileName))\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"cannot open action graph file: %v\", err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\tvar actions []struct {\n\t\t\tMode    string\n\t\t\tPackage string\n\t\t\tObjdir  string\n\t\t}\n\t\tif err := json.NewDecoder(f).Decode(&actions); err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"cannot parse action graph file: %v\", err)\n\t\t}\n\n\t\t// theoretically action graph can be long, to optimise it process it in one pass\n\t\t// with an early exit when all the required imports are found\n\t\tfor _, action := range actions {\n\t\t\tif action.Mode != \"build\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ok := newIndirectImports[action.Package]; !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tpackagefiles = append(packagefiles, [2]string{action.Package, filepath.Join(action.Objdir, \"_pkg_.a\")}) // file name hardcoded in compiler\n\t\t\tdelete(newIndirectImports, action.Package)\n\t\t\tif len(newIndirectImports) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif len(newIndirectImports) > 0 {\n\t\t\treturn \"\", fmt.Errorf(\"cannot resolve required packages from action graph file: %v\", requiredPkgs)\n\t\t}\n\t}\n\n\tfor _, pair := range packagefiles {\n\t\timpPath, pkgfile := pair[0], pair[1]\n\t\tlpkg, err := listPackage(tf.curPkg, impPath)\n\t\tif err != nil {\n\t\t\t// TODO: it's unclear why an importcfg can include an import path\n\t\t\t// that's not a dependency in an edge case with \"go test ./...\".\n\t\t\t// See exporttest/*.go in testdata/scripts/test.txt.\n\t\t\t// For now, spot the pattern and avoid the unnecessary error;\n\t\t\t// the dependency is unused, so the packagefile line is redundant.\n\t\t\t// This still triggers as of go1.21.\n\t\t\tif strings.HasSuffix(tf.curPkg.ImportPath, \".test]\") && strings.HasPrefix(tf.curPkg.ImportPath, impPath) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t\tif lpkg.Name != \"main\" {\n\t\t\timpPath = lpkg.obfuscatedImportPath()\n\t\t}\n\t\tfmt.Fprintf(newCfg, \"packagefile %s=%s\\n\", impPath, pkgfile)\n\t}\n\n\t// Uncomment to debug the transformed importcfg. Do not delete.\n\t// newCfg.Seek(0, 0)\n\t// io.Copy(os.Stderr, newCfg)\n\n\tif err := newCfg.Close(); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn newCfg.Name(), nil\n}\n\ntype (\n\tfuncFullName = string // as per go/types.Func.FullName\n\tobjectString = string // as per recordedObjectString\n\n\ttypeName struct {\n\t\tPkgPath string // empty if builtin\n\t\tName    string\n\t}\n)\n\n// pkgCache contains information about a package that will be stored in fsCache.\n// Note that pkgCache is \"deep\", containing information about all packages\n// which are transitive dependencies as well.\ntype pkgCache struct {\n\t// ReflectAPIs is a static record of what std APIs use reflection on their\n\t// parameters, so we can avoid obfuscating types used with them.\n\t//\n\t// TODO: we're not including fmt.Printf, as it would have many false positives,\n\t// unless we were smart enough to detect which arguments get used as %#v or %T.\n\tReflectAPIs map[funcFullName]map[int]bool\n\n\t// ReflectObjectNames maps obfuscated names which are reflected to their \"real\"\n\t// non-obfuscated names.\n\tReflectObjectNames map[objectString]string\n\n\t// EmbeddedAliasFields records which embedded fields use a type alias.\n\t// They are the only instance where a type alias matters for obfuscation,\n\t// because the embedded field name is derived from the type alias itself,\n\t// and not the type that the alias points to.\n\t// In that way, the type alias is obfuscated as a form of named type,\n\t// bearing in mind that it may be owned by a different package.\n\tEmbeddedAliasFields map[objectString]typeName\n}\n\nfunc (c *pkgCache) CopyFrom(c2 pkgCache) {\n\tmaps.Copy(c.ReflectAPIs, c2.ReflectAPIs)\n\tmaps.Copy(c.ReflectObjectNames, c2.ReflectObjectNames)\n\tmaps.Copy(c.EmbeddedAliasFields, c2.EmbeddedAliasFields)\n}\n\nfunc ssaBuildPkg(pkg *types.Package, files []*ast.File, info *types.Info) *ssa.Package {\n\t// Create SSA packages for all imports. Order is not significant.\n\tssaProg := ssa.NewProgram(fset, 0)\n\tcreated := make(map[*types.Package]bool)\n\tvar createAll func(pkgs []*types.Package)\n\tcreateAll = func(pkgs []*types.Package) {\n\t\tfor _, p := range pkgs {\n\t\t\tif !created[p] {\n\t\t\t\tcreated[p] = true\n\t\t\t\tssaProg.CreatePackage(p, nil, nil, true)\n\t\t\t\tcreateAll(p.Imports())\n\t\t\t}\n\t\t}\n\t}\n\tcreateAll(pkg.Imports())\n\n\tssaPkg := ssaProg.CreatePackage(pkg, files, info, false)\n\tssaPkg.Build()\n\treturn ssaPkg\n}\n\nfunc openCache() (*cache.Cache, error) {\n\t// Use a subdirectory for the hashed build cache, to clarify what it is,\n\t// and to allow us to have other directories or files later on without mixing.\n\tdir := filepath.Join(sharedCache.CacheDir, \"build\")\n\tif err := os.MkdirAll(dir, 0o777); err != nil {\n\t\treturn nil, err\n\t}\n\treturn cache.Open(dir)\n}\n\nfunc loadPkgCache(lpkg *listedPackage, pkg *types.Package, files []*ast.File, info *types.Info, ssaPkg *ssa.Package) (pkgCache, error) {\n\tfsCache, err := openCache()\n\tif err != nil {\n\t\treturn pkgCache{}, err\n\t}\n\tfilename, _, err := fsCache.GetFile(lpkg.GarbleActionID)\n\t// Already in the cache; load it directly.\n\tif err == nil {\n\t\tf, err := os.Open(filename)\n\t\tif err != nil {\n\t\t\treturn pkgCache{}, err\n\t\t}\n\t\tdefer f.Close()\n\t\tvar loaded pkgCache\n\t\tif err := gob.NewDecoder(f).Decode(&loaded); err != nil {\n\t\t\treturn pkgCache{}, fmt.Errorf(\"gob decode: %w\", err)\n\t\t}\n\t\treturn loaded, nil\n\t}\n\treturn computePkgCache(fsCache, lpkg, pkg, files, info, ssaPkg)\n}\n\nfunc computePkgCache(fsCache *cache.Cache, lpkg *listedPackage, pkg *types.Package, files []*ast.File, info *types.Info, ssaPkg *ssa.Package) (pkgCache, error) {\n\t// Not yet in the cache. Load the cache entries for all direct dependencies,\n\t// build our cache entry, and write it to disk.\n\t// Note that practically all errors from Cache.GetFile are a cache miss;\n\t// for example, a file might exist but be empty if another process\n\t// is filling the same cache entry concurrently.\n\t//\n\t// TODO: if A (curPkg) imports B and C, and B also imports C,\n\t// then loading the gob files from both B and C is unnecessary;\n\t// loading B's gob file would be enough. Is there an easy way to do that?\n\tcomputed := pkgCache{\n\t\tReflectAPIs: map[funcFullName]map[int]bool{\n\t\t\t\"reflect.TypeOf\":  {0: true},\n\t\t\t\"reflect.ValueOf\": {0: true},\n\t\t},\n\t\tReflectObjectNames:  map[objectString]string{},\n\t\tEmbeddedAliasFields: map[objectString]typeName{},\n\t}\n\tfor _, imp := range lpkg.Imports {\n\t\tif imp == \"C\" {\n\t\t\t// `go list -json` shows \"C\" in Imports but not Deps.\n\t\t\t// See https://go.dev/issue/60453.\n\t\t\tcontinue\n\t\t}\n\t\t// Shadowing lpkg ensures we don't use the wrong listedPackage below.\n\t\tlpkg, err := listPackage(lpkg, imp)\n\t\tif err != nil {\n\t\t\treturn computed, err\n\t\t}\n\t\tif lpkg.BuildID == \"\" {\n\t\t\tcontinue // nothing to load\n\t\t}\n\t\tif err := func() error { // function literal for the deferred close\n\t\t\tif filename, _, err := fsCache.GetFile(lpkg.GarbleActionID); err == nil {\n\t\t\t\t// Cache hit; append new entries to computed.\n\t\t\t\tf, err := os.Open(filename)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t\tif err := gob.NewDecoder(f).Decode(&computed); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"gob decode: %w\", err)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Missing or corrupted entry in the cache for a dependency.\n\t\t\t// Could happen if GARBLE_CACHE was emptied but GOCACHE was not.\n\t\t\t// Compute it, which can recurse if many entries are missing.\n\t\t\tfiles, err := parseFiles(lpkg, lpkg.Dir, lpkg.CompiledGoFiles)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\torigImporter := importerForPkg(lpkg)\n\t\t\tpkg, info, err := typecheck(lpkg.ImportPath, files, origImporter)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcomputedImp, err := computePkgCache(fsCache, lpkg, pkg, files, info, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcomputed.CopyFrom(computedImp)\n\t\t\treturn nil\n\t\t}(); err != nil {\n\t\t\treturn pkgCache{}, fmt.Errorf(\"pkgCache load for %s: %w\", imp, err)\n\t\t}\n\t}\n\n\t// Fill EmbeddedAliasFields from the type info.\n\tfor name, obj := range info.Uses {\n\t\tobj, ok := obj.(*types.TypeName)\n\t\tif !ok || !obj.IsAlias() {\n\t\t\tcontinue\n\t\t}\n\t\tvr, _ := info.Defs[name].(*types.Var)\n\t\tif vr == nil || !vr.Embedded() {\n\t\t\tcontinue\n\t\t}\n\t\tvrStr := recordedObjectString(vr)\n\t\tif vrStr == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\taliasTypeName := typeName{\n\t\t\tName: obj.Name(),\n\t\t}\n\t\tif pkg := obj.Pkg(); pkg != nil {\n\t\t\taliasTypeName.PkgPath = pkg.Path()\n\t\t}\n\t\tcomputed.EmbeddedAliasFields[vrStr] = aliasTypeName\n\t}\n\n\t// Fill the reflect info from SSA, which builds on top of the syntax tree and type info.\n\tinspector := reflectInspector{\n\t\tpkg:             pkg,\n\t\tcheckedAPIs:     make(map[string]bool),\n\t\tpropagatedInstr: map[ssa.Instruction]bool{},\n\t\tresult:          computed, // append the results\n\t}\n\tif ssaPkg == nil {\n\t\tssaPkg = ssaBuildPkg(pkg, files, info)\n\t}\n\tinspector.recordReflection(ssaPkg)\n\n\t// Unlikely that we could stream the gob encode, as cache.Put wants an io.ReadSeeker.\n\tvar buf bytes.Buffer\n\tif err := gob.NewEncoder(&buf).Encode(computed); err != nil {\n\t\treturn pkgCache{}, err\n\t}\n\tif err := fsCache.PutBytes(lpkg.GarbleActionID, buf.Bytes()); err != nil {\n\t\treturn pkgCache{}, err\n\t}\n\treturn computed, nil\n}\n\n// cmd/bundle will include a go:generate directive in its output by default.\n// Ours specifies a version and doesn't assume bundle is in $PATH, so drop it.\n\n//go:generate go run golang.org/x/tools/cmd/bundle -o cmdgo_quoted.go -prefix cmdgoQuoted cmd/internal/quoted\n//go:generate sed -i /go:generate/d cmdgo_quoted.go\n\n// computeLinkerVariableStrings iterates over the -ldflags arguments,\n// filling a map with all the string values set via the linker's -X flag.\n// TODO: can we put this in sharedCache, using objectString as a key?\nfunc computeLinkerVariableStrings(pkg *types.Package) (map[*types.Var]string, error) {\n\tlinkerVariableStrings := make(map[*types.Var]string)\n\n\t// TODO: this is a linker flag that affects how we obfuscate a package at\n\t// compile time. Note that, if the user changes ldflags, then Go may only\n\t// re-link the final binary, without re-compiling any packages at all.\n\t// It's possible that this could result in:\n\t//\n\t//    garble -literals build -ldflags=-X=pkg.name=before # name=\"before\"\n\t//    garble -literals build -ldflags=-X=pkg.name=after  # name=\"before\" as cached\n\t//\n\t// We haven't been able to reproduce this problem for now,\n\t// but it's worth noting it and keeping an eye out for it in the future.\n\t// If we do confirm this theoretical bug,\n\t// the solution will be to either find a different solution for -literals,\n\t// or to force including -ldflags into the build cache key.\n\tldflags, err := cmdgoQuotedSplit(flagValue(sharedCache.ForwardBuildFlags, \"-ldflags\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tflagValueIter(ldflags, \"-X\", func(val string) {\n\t\t// val is in the form of \"foo.com/bar.name=value\".\n\t\tfullName, stringValue, found := strings.Cut(val, \"=\")\n\t\tif !found {\n\t\t\treturn // invalid\n\t\t}\n\n\t\t// fullName is \"foo.com/bar.name\"\n\t\ti := strings.LastIndexByte(fullName, '.')\n\t\tpath, name := fullName[:i], fullName[i+1:]\n\n\t\t// -X represents the main package as \"main\", not its import path.\n\t\tif path != pkg.Path() && (path != \"main\" || pkg.Name() != \"main\") {\n\t\t\treturn // not the current package\n\t\t}\n\n\t\tobj, _ := pkg.Scope().Lookup(name).(*types.Var)\n\t\tif obj == nil {\n\t\t\treturn // no such variable; skip\n\t\t}\n\t\tlinkerVariableStrings[obj] = stringValue\n\t})\n\treturn linkerVariableStrings, nil\n}\n\n// transformer holds all the information and state necessary to obfuscate a\n// single Go package.\ntype transformer struct {\n\t// curPkg holds basic information about the package being currently compiled or linked.\n\tcurPkg *listedPackage\n\n\t// curPkgCache is the pkgCache for curPkg.\n\tcurPkgCache pkgCache\n\n\t// The type-checking results; the package itself, and the Info struct.\n\tpkg  *types.Package\n\tinfo *types.Info\n\n\t// linkerVariableStrings records objects for variables used in -ldflags=-X flags,\n\t// as well as the strings the user wants to inject them with.\n\t// Used when obfuscating literals, so that we obfuscate the injected value.\n\tlinkerVariableStrings map[*types.Var]string\n\n\t// fieldToStruct helps locate struct types from any of their field\n\t// objects. Useful when obfuscating field names.\n\tfieldToStruct map[*types.Var]*types.Struct\n\n\t// obfRand is initialized by transformCompile and used during obfuscation.\n\t// It is left nil at init time, so that we only use it after it has been\n\t// properly initialized with a deterministic seed.\n\t// It must only be used for deterministic obfuscation;\n\t// if it is used for any other purpose, we may lose determinism.\n\tobfRand *mathrand.Rand\n\n\t// origImporter is a go/types importer which uses the original versions\n\t// of packages, without any obfuscation. This is helpful to make\n\t// decisions on how to obfuscate our input code.\n\torigImporter importerWithMap\n\n\t// usedAllImportsFiles is used to prevent multiple calls of tf.useAllImports function on one file\n\t// in case of simultaneously applied control flow and literals obfuscation\n\tusedAllImportsFiles map[*ast.File]bool\n}\n\nfunc typecheck(pkgPath string, files []*ast.File, origImporter importerWithMap) (*types.Package, *types.Info, error) {\n\tinfo := &types.Info{\n\t\tTypes:      make(map[ast.Expr]types.TypeAndValue),\n\t\tDefs:       make(map[*ast.Ident]types.Object),\n\t\tUses:       make(map[*ast.Ident]types.Object),\n\t\tImplicits:  make(map[ast.Node]types.Object),\n\t\tScopes:     make(map[ast.Node]*types.Scope),\n\t\tSelections: make(map[*ast.SelectorExpr]*types.Selection),\n\t\tInstances:  make(map[*ast.Ident]types.Instance),\n\t}\n\t// TODO(mvdan): we should probably set types.Config.GoVersion from go.mod\n\torigTypesConfig := types.Config{\n\t\tImporter: origImporter,\n\t\tSizes:    types.SizesFor(\"gc\", sharedCache.GoEnv.GOARCH),\n\t}\n\tpkg, err := origTypesConfig.Check(pkgPath, fset, files, info)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"typecheck error: %v\", err)\n\t}\n\treturn pkg, info, err\n}\n\nfunc computeFieldToStruct(info *types.Info) map[*types.Var]*types.Struct {\n\tdone := make(map[*types.Named]bool)\n\tfieldToStruct := make(map[*types.Var]*types.Struct)\n\n\t// Run recordType on all types reachable via types.Info.\n\t// A bit hacky, but I could not find an easier way to do this.\n\tfor _, obj := range info.Uses {\n\t\tif obj != nil {\n\t\t\trecordType(obj.Type(), nil, done, fieldToStruct)\n\t\t}\n\t}\n\tfor _, obj := range info.Defs {\n\t\tif obj != nil {\n\t\t\trecordType(obj.Type(), nil, done, fieldToStruct)\n\t\t}\n\t}\n\tfor _, tv := range info.Types {\n\t\trecordType(tv.Type, nil, done, fieldToStruct)\n\t}\n\treturn fieldToStruct\n}\n\n// recordType visits every reachable type after typechecking a package.\n// Right now, all it does is fill the fieldToStruct map.\n// Since types can be recursive, we need a map to avoid cycles.\n// We only need to track named types as done, as all cycles must use them.\nfunc recordType(used, origin types.Type, done map[*types.Named]bool, fieldToStruct map[*types.Var]*types.Struct) {\n\tif origin == nil {\n\t\torigin = used\n\t}\n\torigin = types.Unalias(origin)\n\tused = types.Unalias(used)\n\ttype Container interface{ Elem() types.Type }\n\tswitch used := used.(type) {\n\tcase Container:\n\t\t// origin may be a *types.TypeParam, which is not a Container.\n\t\t// For now, we haven't found a need to recurse in that case.\n\t\t// We can edit this code in the future if we find an example,\n\t\t// because we panic if a field is not in fieldToStruct.\n\t\tif origin, ok := origin.(Container); ok {\n\t\t\trecordType(used.Elem(), origin.Elem(), done, fieldToStruct)\n\t\t}\n\tcase *types.Named:\n\t\tif done[used] {\n\t\t\treturn\n\t\t}\n\t\tdone[used] = true\n\t\t// If we have a generic struct like\n\t\t//\n\t\t//\ttype Foo[T any] struct { Bar T }\n\t\t//\n\t\t// then we want the hashing to use the original \"Bar T\",\n\t\t// because otherwise different instances like \"Bar int\" and \"Bar bool\"\n\t\t// will result in different hashes and the field names will break.\n\t\t// Ensure we record the original generic struct, if there is one.\n\t\trecordType(used.Underlying(), used.Origin().Underlying(), done, fieldToStruct)\n\tcase *types.Struct:\n\t\torigin := origin.(*types.Struct)\n\t\tfor i := range used.NumFields() {\n\t\t\tfield := used.Field(i)\n\t\t\tfieldToStruct[field] = origin\n\n\t\t\tif field.Embedded() {\n\t\t\t\trecordType(field.Type(), origin.Field(i).Type(), done, fieldToStruct)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// isSafeForInstanceType returns true if the passed type is safe for var declaration.\n// Unsafe types: generic types and non-method interfaces.\nfunc isSafeForInstanceType(t types.Type) bool {\n\tswitch t := types.Unalias(t).(type) {\n\tcase *types.Named:\n\t\tif t.TypeParams().Len() > 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn isSafeForInstanceType(t.Underlying())\n\tcase *types.Signature:\n\t\treturn t.TypeParams().Len() == 0\n\tcase *types.Interface:\n\t\treturn t.IsMethodSet()\n\t}\n\treturn true\n}\n\nfunc (tf *transformer) useAllImports(file *ast.File) {\n\tif tf.usedAllImportsFiles == nil {\n\t\ttf.usedAllImportsFiles = make(map[*ast.File]bool)\n\t} else if ok := tf.usedAllImportsFiles[file]; ok {\n\t\treturn\n\t}\n\ttf.usedAllImportsFiles[file] = true\n\n\tfor _, imp := range file.Imports {\n\t\tif imp.Name != nil && imp.Name.Name == \"_\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tpkgName := tf.info.PkgNameOf(imp)\n\t\tpkgScope := pkgName.Imported().Scope()\n\t\tvar nameObj types.Object\n\t\tfor _, name := range pkgScope.Names() {\n\t\t\tif obj := pkgScope.Lookup(name); obj.Exported() && isSafeForInstanceType(obj.Type()) {\n\t\t\t\tnameObj = obj\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif nameObj == nil {\n\t\t\t// A very unlikely situation where there is no suitable declaration for a reference variable\n\t\t\t// and almost certainly means that there is another import reference in code.\n\t\t\tcontinue\n\t\t}\n\t\tspec := &ast.ValueSpec{Names: []*ast.Ident{ast.NewIdent(\"_\")}}\n\t\tdecl := &ast.GenDecl{Specs: []ast.Spec{spec}}\n\n\t\tnameIdent := ast.NewIdent(nameObj.Name())\n\t\tvar nameExpr ast.Expr\n\t\tswitch {\n\t\tcase imp.Name == nil: // import \"pkg/path\"\n\t\t\tnameExpr = &ast.SelectorExpr{\n\t\t\t\tX:   ast.NewIdent(pkgName.Name()),\n\t\t\t\tSel: nameIdent,\n\t\t\t}\n\t\tcase imp.Name.Name != \".\": // import path2 \"pkg/path\"\n\t\t\tnameExpr = &ast.SelectorExpr{\n\t\t\t\tX:   ast.NewIdent(imp.Name.Name),\n\t\t\t\tSel: nameIdent,\n\t\t\t}\n\t\tdefault: // import . \"pkg/path\"\n\t\t\tnameExpr = nameIdent\n\t\t}\n\n\t\tswitch nameObj.(type) {\n\t\tcase *types.Const:\n\t\t\t// const _ = <value>\n\t\t\tdecl.Tok = token.CONST\n\t\t\tspec.Values = []ast.Expr{nameExpr}\n\t\tcase *types.Var, *types.Func:\n\t\t\t// var _ = <value>\n\t\t\tdecl.Tok = token.VAR\n\t\t\tspec.Values = []ast.Expr{nameExpr}\n\t\tcase *types.TypeName:\n\t\t\t// var _ <type>\n\t\t\tdecl.Tok = token.VAR\n\t\t\tspec.Type = nameExpr\n\t\tdefault:\n\t\t\tcontinue // skip *types.Builtin and others\n\t\t}\n\n\t\t// Ensure that types.Info.Uses is up to date.\n\t\ttf.info.Uses[nameIdent] = nameObj\n\t\tfile.Decls = append(file.Decls, decl)\n\t}\n}\n\n// transformGoFile obfuscates the provided Go syntax file.\nfunc (tf *transformer) transformGoFile(file *ast.File) *ast.File {\n\t// Only obfuscate the literals here if the flag is on\n\t// and if the package in question is to be obfuscated.\n\t//\n\t// We can't obfuscate literals in the runtime and its dependencies,\n\t// because obfuscated literals sometimes escape to heap,\n\t// and that's not allowed in the runtime itself.\n\tif flagLiterals && tf.curPkg.ToObfuscate {\n\t\tfile = literals.Obfuscate(tf.obfRand, file, tf.info, tf.linkerVariableStrings)\n\n\t\t// some imported constants might not be needed anymore, remove unnecessary imports\n\t\ttf.useAllImports(file)\n\t}\n\n\tpre := func(cursor *astutil.Cursor) bool {\n\t\tnode, ok := cursor.Node().(*ast.Ident)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tname := node.Name\n\t\tif name == \"_\" {\n\t\t\treturn true // unnamed remains unnamed\n\t\t}\n\t\tobj := tf.info.ObjectOf(node)\n\t\tif obj == nil {\n\t\t\t_, isImplicit := tf.info.Defs[node]\n\t\t\t_, parentIsFile := cursor.Parent().(*ast.File)\n\t\t\tif !isImplicit || parentIsFile {\n\t\t\t\t// We only care about nil objects in the switch scenario below.\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// In a type switch like \"switch foo := bar.(type) {\",\n\t\t\t// \"foo\" is being declared as a symbolic variable,\n\t\t\t// as it is only actually declared in each \"case SomeType:\".\n\t\t\t//\n\t\t\t// As such, the symbolic \"foo\" in the syntax tree has no object,\n\t\t\t// but it is still recorded under Defs with a nil value.\n\t\t\t// We still want to obfuscate that syntax tree identifier,\n\t\t\t// so if we detect the case, create a dummy types.Var for it.\n\t\t\t//\n\t\t\t// Note that \"package mypkg\" also denotes a nil object in Defs,\n\t\t\t// and we don't want to treat that \"mypkg\" as a variable,\n\t\t\t// so avoid that case by checking the type of cursor.Parent.\n\t\t\tobj = types.NewVar(node.Pos(), tf.pkg, name, nil)\n\t\t}\n\t\tpkg := obj.Pkg()\n\t\tif vr, ok := obj.(*types.Var); ok && vr.Embedded() {\n\t\t\t// The docs for ObjectOf say:\n\t\t\t//\n\t\t\t//     If id is an embedded struct field, ObjectOf returns the\n\t\t\t//     field (*Var) it defines, not the type (*TypeName) it uses.\n\t\t\t//\n\t\t\t// If this embedded field is a type alias, we want to\n\t\t\t// handle the alias's TypeName instead of treating it as\n\t\t\t// the type the alias points to.\n\t\t\t//\n\t\t\t// Alternatively, if we don't have an alias, we still want to\n\t\t\t// use the embedded type, not the field.\n\t\t\tvrStr := recordedObjectString(vr)\n\t\t\taliasTypeName, ok := tf.curPkgCache.EmbeddedAliasFields[vrStr]\n\t\t\tif ok {\n\t\t\t\taliasScope := tf.pkg.Scope()\n\t\t\t\tif path := aliasTypeName.PkgPath; path == \"\" {\n\t\t\t\t\taliasScope = types.Universe\n\t\t\t\t} else if path != tf.pkg.Path() {\n\t\t\t\t\t// If the package is a dependency, import it.\n\t\t\t\t\t// We can't grab the package via tf.pkg.Imports,\n\t\t\t\t\t// because some of the packages under there are incomplete.\n\t\t\t\t\t// ImportFrom will cache complete imports, anyway.\n\t\t\t\t\tpkg2, err := tf.origImporter.ImportFrom(path, parentWorkDir, 0)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t\taliasScope = pkg2.Scope()\n\t\t\t\t}\n\t\t\t\ttname, ok := aliasScope.Lookup(aliasTypeName.Name).(*types.TypeName)\n\t\t\t\tif !ok {\n\t\t\t\t\tpanic(fmt.Sprintf(\"EmbeddedAliasFields pointed %q to a missing type %q\", vrStr, aliasTypeName))\n\t\t\t\t}\n\t\t\t\tif !tname.IsAlias() {\n\t\t\t\t\tpanic(fmt.Sprintf(\"EmbeddedAliasFields pointed %q to a non-alias type %q\", vrStr, aliasTypeName))\n\t\t\t\t}\n\t\t\t\tobj = tname\n\t\t\t} else {\n\t\t\t\ttname := namedType(obj.Type())\n\t\t\t\tif tname == nil {\n\t\t\t\t\treturn true // unnamed type (probably a basic type, e.g. int)\n\t\t\t\t}\n\t\t\t\tobj = tname\n\t\t\t}\n\t\t\tpkg = obj.Pkg()\n\t\t}\n\t\tif pkg == nil {\n\t\t\treturn true // universe scope\n\t\t}\n\n\t\t// TODO: We match by object name here, which is actually imprecise.\n\t\t// For example, in package embed we match the type FS, but we would also\n\t\t// match any field or method named FS.\n\t\t// Can we instead use an object map like ReflectObjects?\n\t\tpath := pkg.Path()\n\t\tswitch path {\n\t\tcase \"sync/atomic\", \"runtime/internal/atomic\":\n\t\t\tif name == \"align64\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase \"embed\":\n\t\t\t// FS is detected by the compiler for //go:embed.\n\t\t\tif name == \"FS\" {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase \"reflect\":\n\t\t\tswitch name {\n\t\t\t// Per the linker's deadcode.go docs,\n\t\t\t// the Method and MethodByName methods are what drive the logic.\n\t\t\tcase \"Method\", \"MethodByName\":\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase \"crypto/x509/pkix\":\n\t\t\t// For better or worse, encoding/asn1 detects a \"SET\" suffix on slice type names\n\t\t\t// to tell whether those slices should be treated as sets or sequences.\n\t\t\t// Do not obfuscate those names to prevent breaking x509 certificates.\n\t\t\t// TODO: we can surely do better; ideally propose a non-string-based solution\n\t\t\t// upstream, or as a fallback, obfuscate to a name ending with \"SET\".\n\t\t\tif strings.HasSuffix(name, \"SET\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tlpkg, err := listPackage(tf.curPkg, path)\n\t\tif err != nil {\n\t\t\tpanic(err) // shouldn't happen\n\t\t}\n\t\tif !lpkg.ToObfuscate {\n\t\t\treturn true // we're not obfuscating this package\n\t\t}\n\t\thashToUse := lpkg.GarbleActionID\n\t\tdebugName := \"variable\"\n\n\t\t// log.Printf(\"%s: %#v %T\", fset.Position(node.Pos()), node, obj)\n\t\tswitch obj := obj.(type) {\n\t\tcase *types.Var:\n\t\t\tif !obj.IsField() {\n\t\t\t\t// Identifiers denoting variables are always obfuscated.\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdebugName = \"field\"\n\t\t\t// From this point on, we deal with struct fields.\n\n\t\t\t// Fields don't get hashed with the package's action ID.\n\t\t\t// They get hashed with the type of their parent struct.\n\t\t\t// This is because one struct can be converted to another,\n\t\t\t// as long as the underlying types are identical,\n\t\t\t// even if the structs are defined in different packages.\n\t\t\t//\n\t\t\t// TODO: Consider only doing this for structs where all\n\t\t\t// fields are exported. We only need this special case\n\t\t\t// for cross-package conversions, which can't work if\n\t\t\t// any field is unexported. If that is done, add a test\n\t\t\t// that ensures unexported fields from different\n\t\t\t// packages result in different obfuscated names.\n\t\t\tstrct := tf.fieldToStruct[obj]\n\t\t\tif strct == nil {\n\t\t\t\tpanic(\"could not find struct for field \" + name)\n\t\t\t}\n\t\t\tnode.Name = hashWithStruct(strct, obj)\n\t\t\tif flagDebug { // TODO(mvdan): remove once https://go.dev/issue/53465 if fixed\n\t\t\t\tlog.Printf(\"%s %q hashed with struct fields to %q\", debugName, name, node.Name)\n\t\t\t}\n\t\t\treturn true\n\n\t\tcase *types.TypeName:\n\t\t\tdebugName = \"type\"\n\t\tcase *types.Func:\n\t\t\tif compilerIntrinsics[path][name] {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tsign := obj.Type().(*types.Signature)\n\t\t\tif sign.Recv() == nil {\n\t\t\t\tdebugName = \"func\"\n\t\t\t} else {\n\t\t\t\tdebugName = \"method\"\n\t\t\t}\n\t\t\tif obj.Exported() && sign.Recv() != nil {\n\t\t\t\treturn true // might implement an interface\n\t\t\t}\n\t\t\tswitch name {\n\t\t\tcase \"main\", \"init\", \"TestMain\":\n\t\t\t\treturn true // don't break them\n\t\t\t}\n\t\t\tif strings.HasPrefix(name, \"Test\") && isTestSignature(sign) {\n\t\t\t\treturn true // don't break tests\n\t\t\t}\n\t\tdefault:\n\t\t\treturn true // we only want to rename the above\n\t\t}\n\n\t\tnode.Name = hashWithPackage(lpkg, name)\n\t\t// TODO: probably move the debugf lines inside the hash funcs\n\t\tif flagDebug { // TODO(mvdan): remove once https://go.dev/issue/53465 if fixed\n\t\t\tlog.Printf(\"%s %q hashed with %x… to %q\", debugName, name, hashToUse[:4], node.Name)\n\t\t}\n\t\treturn true\n\t}\n\tpost := func(cursor *astutil.Cursor) bool {\n\t\timp, ok := cursor.Node().(*ast.ImportSpec)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tpath, err := strconv.Unquote(imp.Path.Value)\n\t\tif err != nil {\n\t\t\tpanic(err) // should never happen\n\t\t}\n\t\t// We're importing an obfuscated package.\n\t\t// Replace the import path with its obfuscated version.\n\t\t// If the import was unnamed, give it the name of the\n\t\t// original package name, to keep references working.\n\t\tlpkg, err := listPackage(tf.curPkg, path)\n\t\tif err != nil {\n\t\t\tpanic(err) // should never happen\n\t\t}\n\t\tif !lpkg.ToObfuscate {\n\t\t\treturn true\n\t\t}\n\t\tif lpkg.Name != \"main\" {\n\t\t\tnewPath := lpkg.obfuscatedImportPath()\n\t\t\timp.Path.Value = strconv.Quote(newPath)\n\t\t}\n\t\tif imp.Name == nil {\n\t\t\timp.Name = &ast.Ident{\n\t\t\t\tNamePos: imp.Path.ValuePos, // ensure it ends up on the same line\n\t\t\t\tName:    lpkg.Name,\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\treturn astutil.Apply(file, pre, post).(*ast.File)\n}\n\n// namedType tries to obtain the *types.TypeName behind a type, if there is one.\n// This is useful to obtain \"testing.T\" from \"*testing.T\", or to obtain the type\n// declaration object from an embedded field.\n// Note that, for a type alias, this gives the alias name.\nfunc namedType(t types.Type) *types.TypeName {\n\tswitch t := t.(type) {\n\tcase *types.Alias:\n\t\treturn t.Obj()\n\tcase *types.Named:\n\t\treturn t.Obj()\n\tcase *types.Pointer:\n\t\treturn namedType(t.Elem())\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// isTestSignature returns true if the signature matches \"func _(*testing.T)\".\nfunc isTestSignature(sign *types.Signature) bool {\n\tif sign.Recv() != nil {\n\t\treturn false // test funcs don't have receivers\n\t}\n\tparams := sign.Params()\n\tif params.Len() != 1 {\n\t\treturn false // too many parameters for a test func\n\t}\n\ttname := namedType(params.At(0).Type())\n\tif tname == nil {\n\t\treturn false // the only parameter isn't named, like \"string\"\n\t}\n\treturn tname.Pkg().Path() == \"testing\" && tname.Name() == \"T\"\n}\n\nfunc (tf *transformer) transformLink(args []string) ([]string, error) {\n\t// We can't split by the \".a\" extension, because cached object files\n\t// lack any extension.\n\tflags, args := splitFlagsFromArgs(args)\n\n\tnewImportCfg, err := tf.processImportCfg(flags, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// TODO: unify this logic with the -X handling when using -literals.\n\t// We should be able to handle both cases via the syntax tree.\n\t//\n\t// Make sure -X works with obfuscated identifiers.\n\t// To cover both obfuscated and non-obfuscated names,\n\t// duplicate each flag with a obfuscated version.\n\tflagValueIter(flags, \"-X\", func(val string) {\n\t\t// val is in the form of \"foo.com/bar.name=value\".\n\t\tfullName, stringValue, found := strings.Cut(val, \"=\")\n\t\tif !found {\n\t\t\treturn // invalid\n\t\t}\n\n\t\t// fullName is \"foo.com/bar.name\"\n\t\ti := strings.LastIndexByte(fullName, '.')\n\t\tpath, name := fullName[:i], fullName[i+1:]\n\n\t\t// If the package path is \"main\", it's the current top-level\n\t\t// package we are linking.\n\t\t// Otherwise, find it in the cache.\n\t\tlpkg := tf.curPkg\n\t\tif path != \"main\" {\n\t\t\tlpkg = sharedCache.ListedPackages[path]\n\t\t}\n\t\tif lpkg == nil {\n\t\t\t// We couldn't find the package.\n\t\t\t// Perhaps a typo, perhaps not part of the build.\n\t\t\t// cmd/link ignores those, so we should too.\n\t\t\treturn\n\t\t}\n\t\t// As before, the main package must remain as \"main\".\n\t\tnewPath := path\n\t\tif path != \"main\" {\n\t\t\tnewPath = lpkg.obfuscatedImportPath()\n\t\t}\n\t\tnewName := hashWithPackage(lpkg, name)\n\t\tflags = append(flags, fmt.Sprintf(\"-X=%s.%s=%s\", newPath, newName, stringValue))\n\t})\n\n\t// Starting in Go 1.17, Go's version is implicitly injected by the linker.\n\t// It's the same method as -X, so we can override it with an extra flag.\n\tflags = append(flags, \"-X=runtime.buildVersion=unknown\")\n\n\t// Ensure we strip the -buildid flag, to not leak any build IDs for the\n\t// link operation or the main package's compilation.\n\tflags = flagSetValue(flags, \"-buildid\", \"\")\n\n\t// Strip debug information and symbol tables.\n\tflags = append(flags, \"-w\", \"-s\")\n\n\tflags = flagSetValue(flags, \"-importcfg\", newImportCfg)\n\treturn append(flags, args...), nil\n}\n\nfunc splitFlagsFromArgs(all []string) (flags, args []string) {\n\tfor i := 0; i < len(all); i++ {\n\t\targ := all[i]\n\t\tif !strings.HasPrefix(arg, \"-\") {\n\t\t\treturn all[:i:i], all[i:]\n\t\t}\n\t\tif booleanFlags[arg] || strings.Contains(arg, \"=\") {\n\t\t\t// Either \"-bool\" or \"-name=value\".\n\t\t\tcontinue\n\t\t}\n\t\t// \"-name value\", so the next arg is part of this flag.\n\t\ti++\n\t}\n\treturn all, nil\n}\n\nfunc alterTrimpath(flags []string) []string {\n\ttrimpath := flagValue(flags, \"-trimpath\")\n\n\t// Add our temporary dir to the beginning of -trimpath, so that we don't\n\t// leak temporary dirs. Needs to be at the beginning, since there may be\n\t// shorter prefixes later in the list, such as $PWD if TMPDIR=$PWD/tmp.\n\treturn flagSetValue(flags, \"-trimpath\", sharedTempDir+\"=>;\"+trimpath)\n}\n\n// forwardBuildFlags is obtained from 'go help build' as of Go 1.21.\nvar forwardBuildFlags = map[string]bool{\n\t// These shouldn't be used in nested cmd/go calls.\n\t\"-a\": false,\n\t\"-n\": false,\n\t\"-x\": false,\n\t\"-v\": false,\n\n\t// These are always set by garble.\n\t\"-trimpath\": false,\n\t\"-toolexec\": false,\n\t\"-buildvcs\": false,\n\n\t\"-C\":             true,\n\t\"-asan\":          true,\n\t\"-asmflags\":      true,\n\t\"-buildmode\":     true,\n\t\"-compiler\":      true,\n\t\"-cover\":         true,\n\t\"-covermode\":     true,\n\t\"-coverpkg\":      true,\n\t\"-gccgoflags\":    true,\n\t\"-gcflags\":       true,\n\t\"-installsuffix\": true,\n\t\"-ldflags\":       true,\n\t\"-linkshared\":    true,\n\t\"-mod\":           true,\n\t\"-modcacherw\":    true,\n\t\"-modfile\":       true,\n\t\"-msan\":          true,\n\t\"-overlay\":       true,\n\t\"-p\":             true,\n\t\"-pgo\":           true,\n\t\"-pkgdir\":        true,\n\t\"-race\":          true,\n\t\"-tags\":          true,\n\t\"-work\":          true,\n\t\"-workfile\":      true,\n}\n\n// booleanFlags is obtained from 'go help build' and 'go help testflag' as of Go 1.21.\nvar booleanFlags = map[string]bool{\n\t// Shared build flags.\n\t\"-a\":          true,\n\t\"-asan\":       true,\n\t\"-buildvcs\":   true,\n\t\"-cover\":      true,\n\t\"-i\":          true,\n\t\"-linkshared\": true,\n\t\"-modcacherw\": true,\n\t\"-msan\":       true,\n\t\"-n\":          true,\n\t\"-race\":       true,\n\t\"-trimpath\":   true,\n\t\"-v\":          true,\n\t\"-work\":       true,\n\t\"-x\":          true,\n\n\t// Test flags (TODO: support its special -args flag)\n\t\"-benchmem\": true,\n\t\"-c\":        true,\n\t\"-failfast\": true,\n\t\"-fullpath\": true,\n\t\"-json\":     true,\n\t\"-short\":    true,\n}\n\nfunc filterForwardBuildFlags(flags []string) (filtered []string, firstUnknown string) {\n\tfor i := 0; i < len(flags); i++ {\n\t\targ := flags[i]\n\t\tif strings.HasPrefix(arg, \"--\") {\n\t\t\targ = arg[1:] // \"--name\" to \"-name\"; keep the short form\n\t\t}\n\n\t\tname, _, _ := strings.Cut(arg, \"=\") // \"-name=value\" to \"-name\"\n\n\t\tbuildFlag := forwardBuildFlags[name]\n\t\tif buildFlag {\n\t\t\tfiltered = append(filtered, arg)\n\t\t} else {\n\t\t\tfirstUnknown = name\n\t\t}\n\t\tif booleanFlags[arg] || strings.Contains(arg, \"=\") {\n\t\t\t// Either \"-bool\" or \"-name=value\".\n\t\t\tcontinue\n\t\t}\n\t\t// \"-name value\", so the next arg is part of this flag.\n\t\tif i++; buildFlag && i < len(flags) {\n\t\t\tfiltered = append(filtered, flags[i])\n\t\t}\n\t}\n\treturn filtered, firstUnknown\n}\n\n// splitFlagsFromFiles splits args into a list of flag and file arguments. Since\n// we can't rely on \"--\" being present, and we don't parse all flags upfront, we\n// rely on finding the first argument that doesn't begin with \"-\" and that has\n// the extension we expect for the list of paths.\n//\n// This function only makes sense for lower-level tool commands, such as\n// \"compile\" or \"link\", since their arguments are predictable.\n//\n// We iterate from the end rather than from the start, to better protect\n// oursrelves from flag arguments that may look like paths, such as:\n//\n//\tcompile [flags...] -p pkg/path.go [more flags...] file1.go file2.go\n//\n// For now, since those confusing flags are always followed by more flags,\n// iterating in reverse order works around them entirely.\nfunc splitFlagsFromFiles(all []string, ext string) (flags, paths []string) {\n\tfor i := len(all) - 1; i >= 0; i-- {\n\t\targ := all[i]\n\t\tif strings.HasPrefix(arg, \"-\") || !strings.HasSuffix(arg, ext) {\n\t\t\tcutoff := i + 1 // arg is a flag, not a path\n\t\t\treturn all[:cutoff:cutoff], all[cutoff:]\n\t\t}\n\t}\n\treturn nil, all\n}\n\n// flagValue retrieves the value of a flag such as \"-foo\", from strings in the\n// list of arguments like \"-foo=bar\" or \"-foo\" \"bar\". If the flag is repeated,\n// the last value is returned.\nfunc flagValue(flags []string, name string) string {\n\tlastVal := \"\"\n\tflagValueIter(flags, name, func(val string) {\n\t\tlastVal = val\n\t})\n\treturn lastVal\n}\n\n// flagValueIter retrieves all the values for a flag such as \"-foo\", like\n// flagValue. The difference is that it allows handling complex flags, such as\n// those whose values compose a list.\nfunc flagValueIter(flags []string, name string, fn func(string)) {\n\tfor i, arg := range flags {\n\t\tif val := strings.TrimPrefix(arg, name+\"=\"); val != arg {\n\t\t\t// -name=value\n\t\t\tfn(val)\n\t\t}\n\t\tif arg == name { // -name ...\n\t\t\tif i+1 < len(flags) {\n\t\t\t\t// -name value\n\t\t\t\tfn(flags[i+1])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc flagSetValue(flags []string, name, value string) []string {\n\tfor i, arg := range flags {\n\t\tif strings.HasPrefix(arg, name+\"=\") {\n\t\t\t// -name=value\n\t\t\tflags[i] = name + \"=\" + value\n\t\t\treturn flags\n\t\t}\n\t\tif arg == name { // -name ...\n\t\t\tif i+1 < len(flags) {\n\t\t\t\t// -name value\n\t\t\t\tflags[i+1] = value\n\t\t\t\treturn flags\n\t\t\t}\n\t\t\treturn flags\n\t\t}\n\t}\n\treturn append(flags, name+\"=\"+value)\n}\n\nfunc fetchGoEnv() error {\n\tout, err := exec.Command(\"go\", \"env\", \"-json\",\n\t\t// Keep in sync with [sharedCacheType.GoEnv].\n\t\t\"GOOS\", \"GOARCH\", \"GOMOD\", \"GOVERSION\", \"GOROOT\",\n\t).Output()\n\tif err != nil {\n\t\t// TODO: cover this in the tests.\n\t\tfmt.Fprintf(os.Stderr, `Can't find the Go toolchain: %v\n\nThis is likely due to Go not being installed/setup correctly.\n\nTo install Go, see: https://go.dev/doc/install\n`, err)\n\t\treturn errJustExit(1)\n\t}\n\tif err := json.Unmarshal(out, &sharedCache.GoEnv); err != nil {\n\t\treturn fmt.Errorf(`cannot unmarshal from \"go env -json\": %w`, err)\n\t}\n\tsharedCache.GOGARBLE = cmp.Or(os.Getenv(\"GOGARBLE\"), \"*\") // we default to obfuscating everything\n\treturn nil\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 12.4404296875,
          "content": "// Copyright (c) 2019, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/printer\"\n\t\"go/token\"\n\t\"io/fs\"\n\tmathrand \"math/rand\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-quicktest/qt\"\n\t\"github.com/rogpeppe/go-internal/goproxytest\"\n\t\"github.com/rogpeppe/go-internal/gotooltest\"\n\t\"github.com/rogpeppe/go-internal/testscript\"\n\n\tah \"mvdan.cc/garble/internal/asthelper\"\n)\n\nvar proxyURL string\n\nfunc TestMain(m *testing.M) {\n\t// If GORACE is unset, lower the default of atexit_sleep_ms=1000,\n\t// since otherwise every execution of garble through the test binary\n\t// would sleep for one second before exiting.\n\t// Given how many times garble runs via toolexec, that is very slow!\n\t// If GORACE is set, we assume that the caller knows what they are doing,\n\t// and we don't try to replace or modify their flags.\n\tif os.Getenv(\"GORACE\") == \"\" {\n\t\tos.Setenv(\"GORACE\", \"atexit_sleep_ms=10\")\n\t}\n\tif os.Getenv(\"RUN_GARBLE_MAIN\") == \"true\" {\n\t\tmain()\n\t}\n\ttestscript.Main(garbleMain{m}, map[string]func(){\n\t\t\"garble\": main,\n\t})\n}\n\ntype garbleMain struct {\n\tm *testing.M\n}\n\nfunc (m garbleMain) Run() int {\n\t// Start the Go proxy server running for all tests.\n\tsrv, err := goproxytest.NewServer(\"testdata/mod\", \"\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"cannot start proxy: %v\", err))\n\t}\n\tproxyURL = srv.URL\n\n\treturn m.m.Run()\n}\n\nvar update = flag.Bool(\"u\", false, \"update testscript output files\")\n\nfunc TestScript(t *testing.T) {\n\tt.Parallel()\n\n\texecPath, err := os.Executable()\n\tqt.Assert(t, qt.IsNil(err))\n\n\ttempCacheDir := t.TempDir()\n\n\thostCacheDir, err := os.UserCacheDir()\n\tqt.Assert(t, qt.IsNil(err))\n\n\tp := testscript.Params{\n\t\tDir: filepath.Join(\"testdata\", \"script\"),\n\t\tSetup: func(env *testscript.Env) error {\n\t\t\t// Use testdata/mod as our module proxy.\n\t\t\tenv.Setenv(\"GOPROXY\", proxyURL)\n\n\t\t\t// We use our own proxy, so avoid sum.golang.org.\n\t\t\tenv.Setenv(\"GONOSUMDB\", \"*\")\n\n\t\t\t// \"go build\" starts many short-lived Go processes,\n\t\t\t// such as asm, buildid, compile, and link.\n\t\t\t// They don't allocate huge amounts of memory,\n\t\t\t// and they'll exit within seconds,\n\t\t\t// so using the GC is basically a waste of CPU.\n\t\t\t// Turn it off entirely, releasing memory on exit.\n\t\t\t//\n\t\t\t// We don't want this setting always on,\n\t\t\t// as it could result in memory problems for users.\n\t\t\t// But it helps for our test suite,\n\t\t\t// as the packages are relatively small.\n\t\t\tenv.Setenv(\"GOGC\", \"off\")\n\n\t\t\tenv.Setenv(\"gofullversion\", runtime.Version())\n\t\t\tenv.Setenv(\"EXEC_PATH\", execPath)\n\n\t\t\tif os.Getenv(\"GOCOVERDIR\") != \"\" {\n\t\t\t\t// Don't share cache dirs with the host if we want to collect code\n\t\t\t\t// coverage. Otherwise, the coverage info might be incomplete.\n\t\t\t\tenv.Setenv(\"GOCACHE\", filepath.Join(tempCacheDir, \"go-cache\"))\n\t\t\t\tenv.Setenv(\"GARBLE_CACHE\", filepath.Join(tempCacheDir, \"garble-cache\"))\n\t\t\t} else {\n\t\t\t\t// GOCACHE is initialized by gotooltest to use the host's cache.\n\t\t\t\tenv.Setenv(\"GARBLE_CACHE\", filepath.Join(hostCacheDir, \"garble\"))\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\t// TODO: this condition should probably be supported by gotooltest\n\t\tCondition: func(cond string) (bool, error) {\n\t\t\tswitch cond {\n\t\t\tcase \"cgo\":\n\t\t\t\tout, err := exec.Command(\"go\", \"env\", \"CGO_ENABLED\").CombinedOutput()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t\tresult := strings.TrimSpace(string(out))\n\t\t\t\tswitch result {\n\t\t\t\tcase \"0\", \"1\":\n\t\t\t\t\treturn result == \"1\", nil\n\t\t\t\tdefault:\n\t\t\t\t\treturn false, fmt.Errorf(\"unknown CGO_ENABLED: %q\", result)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false, fmt.Errorf(\"unknown condition\")\n\t\t},\n\t\tCmds: map[string]func(ts *testscript.TestScript, neg bool, args []string){\n\t\t\t\"sleep\":             sleep,\n\t\t\t\"binsubstr\":         binsubstr,\n\t\t\t\"bincmp\":            bincmp,\n\t\t\t\"generate-literals\": generateLiterals,\n\t\t\t\"setenvfile\":        setenvfile,\n\t\t\t\"grepfiles\":         grepfiles,\n\t\t},\n\t\tUpdateScripts:       *update,\n\t\tRequireExplicitExec: true,\n\t\tRequireUniqueNames:  true,\n\t}\n\tif err := gotooltest.Setup(&p); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttestscript.Run(t, p)\n}\n\nfunc createFile(ts *testscript.TestScript, path string) *os.File {\n\tfile, err := os.Create(ts.MkAbs(path))\n\tif err != nil {\n\t\tts.Fatalf(\"%v\", err)\n\t}\n\treturn file\n}\n\n// sleep is akin to a shell's sleep builtin.\n// Note that tests should almost never use this; it's currently only used to\n// work around a low-level Go syscall race on Linux.\nfunc sleep(ts *testscript.TestScript, neg bool, args []string) {\n\tif len(args) != 1 {\n\t\tts.Fatalf(\"usage: sleep duration\")\n\t}\n\td, err := time.ParseDuration(args[0])\n\tif err != nil {\n\t\tts.Fatalf(\"%v\", err)\n\t}\n\ttime.Sleep(d)\n}\n\nfunc binsubstr(ts *testscript.TestScript, neg bool, args []string) {\n\tif len(args) < 2 {\n\t\tts.Fatalf(\"usage: binsubstr file substr...\")\n\t}\n\tdata := ts.ReadFile(args[0])\n\tvar failed []string\n\tfor _, substr := range args[1:] {\n\t\tmatch := strings.Contains(data, substr)\n\t\tif match && neg {\n\t\t\tfailed = append(failed, substr)\n\t\t} else if !match && !neg {\n\t\t\tfailed = append(failed, substr)\n\t\t}\n\t}\n\tif len(failed) > 0 && neg {\n\t\tts.Fatalf(\"unexpected match for %q in %s\", failed, args[0])\n\t} else if len(failed) > 0 {\n\t\tts.Fatalf(\"expected match for %q in %s\", failed, args[0])\n\t}\n}\n\nfunc bincmp(ts *testscript.TestScript, neg bool, args []string) {\n\tif len(args) != 2 {\n\t\tts.Fatalf(\"usage: bincmp file1 file2\")\n\t}\n\tfor _, arg := range args {\n\t\tswitch arg {\n\t\tcase \"stdout\", \"stderr\":\n\t\t\t// Note that the diffoscope call below would not deal with\n\t\t\t// stdout/stderr either.\n\t\t\tts.Fatalf(\"bincmp is for binary files. did you mean cmp?\")\n\t\t}\n\t}\n\tdata1 := ts.ReadFile(args[0])\n\tdata2 := ts.ReadFile(args[1])\n\tif neg {\n\t\tif data1 == data2 {\n\t\t\tts.Fatalf(\"%s and %s don't differ\", args[0], args[1])\n\t\t}\n\t\treturn\n\t}\n\tif data1 != data2 {\n\t\tif _, err := exec.LookPath(\"diffoscope\"); err == nil {\n\t\t\t// We'll error below; ignore the exec error here.\n\t\t\tts.Exec(\"diffoscope\",\n\t\t\t\t\"--diff-context\", \"2\", // down from 7 by default\n\t\t\t\t\"--max-text-report-size\", \"4096\", // no limit (in bytes) by default; avoid huge output\n\t\t\t\tts.MkAbs(args[0]), ts.MkAbs(args[1]))\n\t\t} else {\n\t\t\tts.Logf(\"diffoscope not found; skipping\")\n\t\t}\n\t\toutDir := \"bincmp_output\"\n\t\terr := os.MkdirAll(outDir, 0o777)\n\t\tts.Check(err)\n\n\t\tfile1, err := os.CreateTemp(outDir, \"file1-*\")\n\t\tts.Check(err)\n\t\t_, err = file1.Write([]byte(data1))\n\t\tts.Check(err)\n\t\terr = file1.Close()\n\t\tts.Check(err)\n\n\t\tfile2, err := os.CreateTemp(outDir, \"file2-*\")\n\t\tts.Check(err)\n\t\t_, err = file2.Write([]byte(data2))\n\t\tts.Check(err)\n\t\terr = file2.Close()\n\t\tts.Check(err)\n\n\t\tts.Logf(\"wrote files to %s and %s\", file1.Name(), file2.Name())\n\t\tsizeDiff := len(data2) - len(data1)\n\t\tts.Fatalf(\"%s and %s differ; diffoscope above, size diff: %+d\",\n\t\t\targs[0], args[1], sizeDiff)\n\t}\n}\n\nvar testRand = mathrand.New(mathrand.NewSource(time.Now().UnixNano()))\n\nfunc generateStringLit(minSize int) *ast.BasicLit {\n\tbuffer := make([]byte, minSize)\n\t_, err := testRand.Read(buffer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn ah.StringLit(string(buffer) + \"a_unique_string_that_is_part_of_all_extra_literals\")\n}\n\n// generateLiterals creates a new source code file with a few random literals inside.\n// All literals contain the string \"a_unique_string_that_is_part_of_all_extra_literals\"\n// so we can later check if they are all obfuscated by looking for this substring.\n// The code is designed such that the Go compiler does not optimize away the literals,\n// which would destroy the test.\n// This is achieved by defining a global variable `var x = \"\"` and an `init` function\n// which appends all literals to `x`.\nfunc generateLiterals(ts *testscript.TestScript, neg bool, args []string) {\n\tif neg {\n\t\tts.Fatalf(\"unsupported: ! generate-literals\")\n\t}\n\tif len(args) != 1 {\n\t\tts.Fatalf(\"usage: generate-literals file\")\n\t}\n\n\tcodePath := args[0]\n\n\t// Global string variable to which which we append string literals: `var x = \"\"`\n\tglobalVar := &ast.GenDecl{\n\t\tTok: token.VAR,\n\t\tSpecs: []ast.Spec{\n\t\t\t&ast.ValueSpec{\n\t\t\t\tNames: []*ast.Ident{ast.NewIdent(\"x\")},\n\t\t\t\tValues: []ast.Expr{\n\t\t\t\t\t&ast.BasicLit{Kind: token.STRING, Value: `\"\"`},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tvar statements []ast.Stmt\n\n\t// Assignments which append 100 random small literals to x: `x += \"the_small_random_literal\"`\n\tfor range 100 {\n\t\tstatements = append(\n\t\t\tstatements,\n\t\t\t&ast.AssignStmt{\n\t\t\t\tLhs: []ast.Expr{ast.NewIdent(\"x\")},\n\t\t\t\tTok: token.ADD_ASSIGN,\n\t\t\t\tRhs: []ast.Expr{generateStringLit(1 + testRand.Intn(255))},\n\t\t\t},\n\t\t)\n\t}\n\n\t// Assignments which append 5 random huge literals to x: `x += \"the_huge_random_literal\"`\n\t// We add huge literals to make sure we obfuscate them fast.\n\t// 5 * 128KiB is large enough that it would take a very, very long time\n\t// to obfuscate those literals if too complex obfuscators are used.\n\tfor range 5 {\n\t\tstatements = append(\n\t\t\tstatements,\n\t\t\t&ast.AssignStmt{\n\t\t\t\tLhs: []ast.Expr{ast.NewIdent(\"x\")},\n\t\t\t\tTok: token.ADD_ASSIGN,\n\t\t\t\tRhs: []ast.Expr{generateStringLit(128 << 10)},\n\t\t\t},\n\t\t)\n\t}\n\n\t// An `init` function which includes all assignments from above\n\tinitFunc := &ast.FuncDecl{\n\t\tName: &ast.Ident{\n\t\t\tName: \"init\",\n\t\t},\n\t\tType: &ast.FuncType{},\n\t\tBody: ah.BlockStmt(statements...),\n\t}\n\n\t// A file with the global string variable and init function\n\tfile := &ast.File{\n\t\tName: ast.NewIdent(\"main\"),\n\t\tDecls: []ast.Decl{\n\t\t\tglobalVar,\n\t\t\tinitFunc,\n\t\t},\n\t}\n\n\tcodeFile := createFile(ts, codePath)\n\tdefer codeFile.Close()\n\n\tif err := printer.Fprint(codeFile, token.NewFileSet(), file); err != nil {\n\t\tts.Fatalf(\"%v\", err)\n\t}\n}\n\nfunc setenvfile(ts *testscript.TestScript, neg bool, args []string) {\n\tif neg {\n\t\tts.Fatalf(\"unsupported: ! setenvfile\")\n\t}\n\tif len(args) != 2 {\n\t\tts.Fatalf(\"usage: setenvfile name file\")\n\t}\n\n\tts.Setenv(args[0], ts.ReadFile(args[1]))\n}\n\nfunc grepfiles(ts *testscript.TestScript, neg bool, args []string) {\n\tif len(args) != 2 {\n\t\tts.Fatalf(\"usage: grepfiles path pattern\")\n\t}\n\tanyFound := false\n\tpath, pattern := ts.MkAbs(args[0]), args[1]\n\trx := regexp.MustCompile(pattern)\n\tif err := filepath.WalkDir(path, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rx.MatchString(path) {\n\t\t\tif neg {\n\t\t\t\treturn fmt.Errorf(\"%q matches %q\", path, pattern)\n\t\t\t} else {\n\t\t\t\tanyFound = true\n\t\t\t\treturn fs.SkipAll\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tts.Fatalf(\"%s\", err)\n\t}\n\tif !neg && !anyFound {\n\t\tts.Fatalf(\"no matches for %q\", pattern)\n\t}\n}\n\nfunc TestSplitFlagsFromArgs(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname string\n\t\targs []string\n\t\twant [2][]string\n\t}{\n\t\t{\"Empty\", []string{}, [2][]string{{}, nil}},\n\t\t{\n\t\t\t\"JustFlags\",\n\t\t\t[]string{\"-foo\", \"bar\", \"-baz\"},\n\t\t\t[2][]string{{\"-foo\", \"bar\", \"-baz\"}, nil},\n\t\t},\n\t\t{\n\t\t\t\"JustArgs\",\n\t\t\t[]string{\"some\", \"pkgs\"},\n\t\t\t[2][]string{{}, {\"some\", \"pkgs\"}},\n\t\t},\n\t\t{\n\t\t\t\"FlagsAndArgs\",\n\t\t\t[]string{\"-foo=bar\", \"baz\"},\n\t\t\t[2][]string{{\"-foo=bar\"}, {\"baz\"}},\n\t\t},\n\t\t{\n\t\t\t\"BoolFlagsAndArgs\",\n\t\t\t[]string{\"-race\", \"pkg\"},\n\t\t\t[2][]string{{\"-race\"}, {\"pkg\"}},\n\t\t},\n\t\t{\n\t\t\t\"ExplicitBoolFlag\",\n\t\t\t[]string{\"-race=true\", \"pkg\"},\n\t\t\t[2][]string{{\"-race=true\"}, {\"pkg\"}},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tflags, args := splitFlagsFromArgs(test.args)\n\t\t\tgot := [2][]string{flags, args}\n\n\t\t\tqt.Assert(t, qt.DeepEquals(got, test.want))\n\t\t})\n\t}\n}\n\nfunc TestFilterForwardBuildFlags(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname  string\n\t\tflags []string\n\t\twant  []string\n\t}{\n\t\t{\"Empty\", []string{}, nil},\n\t\t{\n\t\t\t\"NoBuild\",\n\t\t\t[]string{\"-short\", \"-json\"},\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"Mixed\",\n\t\t\t[]string{\"-short\", \"-tags\", \"foo\", \"-mod=readonly\", \"-json\"},\n\t\t\t[]string{\"-tags\", \"foo\", \"-mod=readonly\"},\n\t\t},\n\t\t{\n\t\t\t\"NonBinarySkipped\",\n\t\t\t[]string{\"-o\", \"binary\", \"-tags\", \"foo\"},\n\t\t\t[]string{\"-tags\", \"foo\"},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tgot, _ := filterForwardBuildFlags(test.flags)\n\t\t\tqt.Assert(t, qt.DeepEquals(got, test.want))\n\t\t})\n\t}\n}\n\nfunc TestFlagValue(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname     string\n\t\tflags    []string\n\t\tflagName string\n\t\twant     string\n\t}{\n\t\t{\"StrSpace\", []string{\"-buildid\", \"bar\"}, \"-buildid\", \"bar\"},\n\t\t{\"StrSpaceDash\", []string{\"-buildid\", \"-bar\"}, \"-buildid\", \"-bar\"},\n\t\t{\"StrEqual\", []string{\"-buildid=bar\"}, \"-buildid\", \"bar\"},\n\t\t{\"StrEqualDash\", []string{\"-buildid=-bar\"}, \"-buildid\", \"-bar\"},\n\t\t{\"StrMissing\", []string{\"-foo\"}, \"-buildid\", \"\"},\n\t\t{\"StrNotFollowed\", []string{\"-buildid\"}, \"-buildid\", \"\"},\n\t\t{\"StrEmpty\", []string{\"-buildid=\"}, \"-buildid\", \"\"},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tgot := flagValue(test.flags, test.flagName)\n\t\t\tqt.Assert(t, qt.DeepEquals(got, test.want))\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "position.go",
          "type": "blob",
          "size": 4.7919921875,
          "content": "// Copyright (c) 2020, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/printer\"\n\t\"go/scanner\"\n\t\"go/token\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nvar printBuf1, printBuf2 bytes.Buffer\n\n// printFile prints a Go file to a buffer, while also removing non-directive\n// comments and adding extra compiler directives to obfuscate position information.\nfunc printFile(lpkg *listedPackage, file *ast.File) ([]byte, error) {\n\tif lpkg.ToObfuscate {\n\t\t// Omit comments from the final Go code.\n\t\t// Keep directives, as they affect the build.\n\t\t// We do this before printing to print fewer bytes below.\n\t\tvar newComments []*ast.CommentGroup\n\t\tfor _, group := range file.Comments {\n\t\t\tvar newGroup ast.CommentGroup\n\t\t\tfor _, comment := range group.List {\n\t\t\t\tif strings.HasPrefix(comment.Text, \"//go:\") {\n\t\t\t\t\tnewGroup.List = append(newGroup.List, comment)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(newGroup.List) > 0 {\n\t\t\t\tnewComments = append(newComments, &newGroup)\n\t\t\t}\n\t\t}\n\t\tfile.Comments = newComments\n\t}\n\n\tprintBuf1.Reset()\n\tprintConfig := printer.Config{Mode: printer.RawFormat}\n\tif err := printConfig.Fprint(&printBuf1, fset, file); err != nil {\n\t\treturn nil, err\n\t}\n\tsrc := printBuf1.Bytes()\n\n\tif !lpkg.ToObfuscate {\n\t\t// We lightly transform packages which shouldn't be obfuscated,\n\t\t// such as when rewriting go:linkname directives to obfuscated packages.\n\t\t// We still need to print the files, but without obfuscating positions.\n\t\treturn src, nil\n\t}\n\n\tfsetFile := fset.File(file.Pos())\n\tfilename := filepath.Base(fsetFile.Name())\n\tnewPrefix := \"\"\n\tif strings.HasPrefix(filename, \"_cgo_\") {\n\t\tnewPrefix = \"_cgo_\"\n\t}\n\n\t// Many parts of garble, notably the literal obfuscator, modify the AST.\n\t// Unfortunately, comments are free-floating in File.Comments,\n\t// and those are the only source of truth that go/printer uses.\n\t// So the positions of the comments in the given file are wrong.\n\t// The only way we can get the final ones is to tokenize again.\n\t// Using go/scanner is slightly awkward, but cheaper than parsing again.\n\n\t// We want to use the original positions for the hashed positions.\n\t// Since later we'll iterate on tokens rather than walking an AST,\n\t// we use a list of offsets indexed by identifiers in source order.\n\tvar origCallOffsets []int\n\tnextOffset := -1\n\tast.Inspect(file, func(node ast.Node) bool {\n\t\tswitch node := node.(type) {\n\t\tcase *ast.CallExpr:\n\t\t\tnextOffset = fsetFile.Position(node.Pos()).Offset\n\t\tcase *ast.Ident:\n\t\t\torigCallOffsets = append(origCallOffsets, nextOffset)\n\t\t\tnextOffset = -1\n\t\t}\n\t\treturn true\n\t})\n\n\tcopied := 0\n\tprintBuf2.Reset()\n\n\t// Make sure the entire file gets a zero filename by default,\n\t// in case we miss any positions below.\n\t// We use a //-style comment, because there might be build tags.\n\tfmt.Fprintf(&printBuf2, \"//line %s:1\\n\", newPrefix)\n\n\t// We use an empty filename when tokenizing below.\n\t// We use a nil go/scanner.ErrorHandler because src comes from go/printer.\n\t// Syntax errors should be rare, and when they do happen,\n\t// we don't want to point to the original source file on disk.\n\t// That would be confusing, as we've changed the source in memory.\n\tvar s scanner.Scanner\n\tfsetFile = fset.AddFile(\"\", fset.Base(), len(src))\n\ts.Init(fsetFile, src, nil, scanner.ScanComments)\n\n\tidentIndex := 0\n\tfor {\n\t\tpos, tok, lit := s.Scan()\n\t\tswitch tok {\n\t\tcase token.EOF:\n\t\t\t// Copy the rest and return.\n\t\t\tprintBuf2.Write(src[copied:])\n\t\t\treturn printBuf2.Bytes(), nil\n\t\tcase token.COMMENT:\n\t\t\t// Omit comments from the final Go code, again.\n\t\t\t// Before we removed the comments from file.Comments,\n\t\t\t// but go/printer also grabs comments from some Doc ast.Node fields.\n\t\t\t// TODO: is there an easy way to filter all comments at once?\n\t\t\tif strings.HasPrefix(lit, \"//go:\") {\n\t\t\t\tcontinue // directives are kept\n\t\t\t}\n\t\t\toffset := fsetFile.Position(pos).Offset\n\t\t\tprintBuf2.Write(src[copied:offset])\n\t\t\tcopied = offset + len(lit)\n\t\tcase token.IDENT:\n\t\t\torigOffset := origCallOffsets[identIndex]\n\t\t\tidentIndex++\n\t\t\tif origOffset == -1 {\n\t\t\t\tcontinue // identifiers which don't start func calls are left untouched\n\t\t\t}\n\t\t\tnewName := \"\"\n\t\t\tif !flagTiny {\n\t\t\t\torigPos := fmt.Sprintf(\"%s:%d\", filename, origOffset)\n\t\t\t\tnewName = hashWithPackage(lpkg, origPos) + \".go\"\n\t\t\t\t// log.Printf(\"%q hashed with %x to %q\", origPos, curPkg.GarbleActionID, newName)\n\t\t\t}\n\n\t\t\toffset := fsetFile.Position(pos).Offset\n\t\t\tprintBuf2.Write(src[copied:offset])\n\t\t\tcopied = offset\n\n\t\t\t// We use the \"/*text*/\" form, since we can use multiple of them\n\t\t\t// on a single line, and they don't require extra newlines.\n\t\t\t// Make sure there is whitespace at either side of a comment.\n\t\t\t// Otherwise, we could change the syntax of the program.\n\t\t\t// Inserting \"/*text*/\" in \"a/b\" // must be \"a/ /*text*/ b\",\n\t\t\t// as \"a//*text*/b\" is tokenized as a \"//\" comment.\n\t\t\tfmt.Fprintf(&printBuf2, \" /*line %s%s:1*/ \", newPrefix, newName)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "reflect.go",
          "type": "blob",
          "size": 14.4677734375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"go/types\"\n\t\"maps\"\n\t\"path/filepath\"\n\t\"slices\"\n\n\t\"golang.org/x/tools/go/ssa\"\n)\n\ntype reflectInspector struct {\n\tpkg *types.Package\n\n\tcheckedAPIs map[string]bool\n\n\tpropagatedInstr map[ssa.Instruction]bool\n\n\tresult pkgCache\n}\n\n// Record all instances of reflection use, and don't obfuscate types which are used in reflection.\nfunc (ri *reflectInspector) recordReflection(ssaPkg *ssa.Package) {\n\tif reflectSkipPkg[ssaPkg.Pkg.Path()] {\n\t\treturn\n\t}\n\n\tprevDone := len(ri.result.ReflectAPIs) + len(ri.result.ReflectObjectNames)\n\n\t// find all unchecked APIs to add them to checkedAPIs after the pass\n\tnotCheckedAPIs := make(map[string]bool)\n\tfor knownAPI := range maps.Keys(ri.result.ReflectAPIs) {\n\t\tif !ri.checkedAPIs[knownAPI] {\n\t\t\tnotCheckedAPIs[knownAPI] = true\n\t\t}\n\t}\n\n\tri.ignoreReflectedTypes(ssaPkg)\n\n\t// all previously unchecked APIs have now been checked add them to checkedAPIs,\n\t// to avoid checking them twice\n\tmaps.Copy(ri.checkedAPIs, notCheckedAPIs)\n\n\t// if a new reflectAPI is found we need to Re-evaluate all functions which might be using that API\n\tnewDone := len(ri.result.ReflectAPIs) + len(ri.result.ReflectObjectNames)\n\tif newDone > prevDone {\n\t\tri.recordReflection(ssaPkg) // TODO: avoid recursing\n\t}\n}\n\n// find all functions, methods and interface declarations of a package and record their\n// reflection use\nfunc (ri *reflectInspector) ignoreReflectedTypes(ssaPkg *ssa.Package) {\n\t// Some packages reach into reflect internals, like go-spew.\n\t// It's not particularly right of them to do that,\n\t// and it's entirely unsupported, but try to accomodate for now.\n\t// At least it's enough to leave the rtype and Value types intact.\n\tif ri.pkg.Path() == \"reflect\" {\n\t\tscope := ri.pkg.Scope()\n\t\tri.recursivelyRecordUsedForReflect(scope.Lookup(\"rtype\").Type(), nil)\n\t\tri.recursivelyRecordUsedForReflect(scope.Lookup(\"Value\").Type(), nil)\n\t}\n\n\tfor _, memb := range ssaPkg.Members {\n\t\tswitch x := memb.(type) {\n\t\tcase *ssa.Type:\n\t\t\t// methods aren't package members only their reciever types are\n\t\t\t// so some logic is required to find the methods a type has\n\n\t\t\tmethod := func(mset *types.MethodSet) {\n\t\t\t\tfor i := range mset.Len() {\n\t\t\t\t\tat := mset.At(i)\n\n\t\t\t\t\tif m := ssaPkg.Prog.MethodValue(at); m != nil {\n\t\t\t\t\t\tri.checkFunction(m)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tm := at.Obj().(*types.Func)\n\t\t\t\t\t\t// handle interface declarations\n\t\t\t\t\t\tri.checkInterfaceMethod(m)\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// yes, finding all methods really only works with both calls\n\t\t\tmset := ssaPkg.Prog.MethodSets.MethodSet(x.Type())\n\t\t\tmethod(mset)\n\n\t\t\tmset = ssaPkg.Prog.MethodSets.MethodSet(types.NewPointer(x.Type()))\n\t\t\tmethod(mset)\n\n\t\tcase *ssa.Function:\n\t\t\t// these not only include top level functions, but also synthetic\n\t\t\t// functions like the initialization of global variables\n\n\t\t\tri.checkFunction(x)\n\t\t}\n\t}\n}\n\n// Exported methods with unnamed structs as paramters may be \"used\" in interface declarations\n// elsewhere, these interfaces will break if any method uses reflection on the same parameter.\n//\n// Therefore never obfuscate unnamed structs which are used as a method parameter\n// and treat them like a parameter which is actually used in reflection.\n//\n// See \"UnnamedStructMethod\" in the reflect.txtar test for an example.\nfunc (ri *reflectInspector) checkMethodSignature(reflectParams map[int]bool, sig *types.Signature) {\n\tif sig.Recv() == nil {\n\t\treturn\n\t}\n\n\tparams := sig.Params()\n\tfor i := range params.Len() {\n\t\tif reflectParams[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\tignore := false\n\t\tparam := params.At(i)\n\n\t\tswitch x := param.Type().(type) {\n\t\tcase *types.Struct:\n\t\t\tignore = true\n\t\tcase *types.Array:\n\t\t\tif _, ok := x.Elem().(*types.Struct); ok {\n\t\t\t\tignore = true\n\t\t\t}\n\t\tcase *types.Slice:\n\t\t\tif _, ok := x.Elem().(*types.Struct); ok {\n\t\t\t\tignore = true\n\t\t\t}\n\t\t}\n\n\t\tif ignore {\n\t\t\treflectParams[i] = true\n\t\t\tri.recursivelyRecordUsedForReflect(param.Type(), nil)\n\t\t}\n\t}\n}\n\n// Checks the signature of an interface method for potential reflection use.\nfunc (ri *reflectInspector) checkInterfaceMethod(m *types.Func) {\n\treflectParams := make(map[int]bool)\n\n\tmaps.Copy(reflectParams, ri.result.ReflectAPIs[m.FullName()])\n\n\tsig := m.Type().(*types.Signature)\n\tif m.Exported() {\n\t\tri.checkMethodSignature(reflectParams, sig)\n\t}\n\n\tif len(reflectParams) > 0 {\n\t\tri.result.ReflectAPIs[m.FullName()] = reflectParams\n\n\t\t/* fmt.Printf(\"curPkgCache.ReflectAPIs: %v\\n\", curPkgCache.ReflectAPIs) */\n\t}\n}\n\n// Checks all callsites in a function declaration for use of reflection.\nfunc (ri *reflectInspector) checkFunction(fun *ssa.Function) {\n\t// if fun != nil && fun.Synthetic != \"loaded from gc object file\" {\n\t// \t// fun.WriteTo crashes otherwise\n\t// \tfun.WriteTo(os.Stdout)\n\t// }\n\n\tf, _ := fun.Object().(*types.Func)\n\n\treflectParams := make(map[int]bool)\n\tif f != nil {\n\t\tmaps.Copy(reflectParams, ri.result.ReflectAPIs[f.FullName()])\n\n\t\tif f.Exported() {\n\t\t\tri.checkMethodSignature(reflectParams, fun.Signature)\n\t\t}\n\t}\n\n\t// fmt.Printf(\"f: %v\\n\", f)\n\t// fmt.Printf(\"fun: %v\\n\", fun)\n\n\tfor _, block := range fun.Blocks {\n\t\tfor _, inst := range block.Instrs {\n\t\t\tif ri.propagatedInstr[inst] {\n\t\t\t\tbreak // already done\n\t\t\t}\n\n\t\t\t// fmt.Printf(\"inst: %v, t: %T\\n\", inst, inst)\n\t\t\tswitch inst := inst.(type) {\n\t\t\tcase *ssa.Store:\n\t\t\t\tobj := typeToObj(inst.Addr.Type())\n\t\t\t\tif usedForReflect(ri.result, obj) {\n\t\t\t\t\tri.recordArgReflected(inst.Val, make(map[ssa.Value]bool))\n\t\t\t\t\tri.propagatedInstr[inst] = true\n\t\t\t\t}\n\t\t\tcase *ssa.ChangeType:\n\t\t\t\tobj := typeToObj(inst.X.Type())\n\t\t\t\tif usedForReflect(ri.result, obj) {\n\t\t\t\t\tri.recursivelyRecordUsedForReflect(inst.Type(), nil)\n\t\t\t\t\tri.propagatedInstr[inst] = true\n\t\t\t\t}\n\t\t\tcase *ssa.Call:\n\t\t\t\tcallName := inst.Call.Value.String()\n\t\t\t\tif m := inst.Call.Method; m != nil {\n\t\t\t\t\tcallName = inst.Call.Method.FullName()\n\t\t\t\t}\n\n\t\t\t\tif ri.checkedAPIs[callName] {\n\t\t\t\t\t// only check apis which were not already checked\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t/* fmt.Printf(\"callName: %v\\n\", callName) */\n\n\t\t\t\t// record each call argument passed to a function parameter which is used in reflection\n\t\t\t\tknownParams := ri.result.ReflectAPIs[callName]\n\t\t\t\tfor knownParam := range knownParams {\n\t\t\t\t\tif len(inst.Call.Args) <= knownParam {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\targ := inst.Call.Args[knownParam]\n\n\t\t\t\t\t/* fmt.Printf(\"flagging arg: %v\\n\", arg) */\n\n\t\t\t\t\treflectedParam := ri.recordArgReflected(arg, make(map[ssa.Value]bool))\n\t\t\t\t\tif reflectedParam == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tpos := slices.Index(fun.Params, reflectedParam)\n\t\t\t\t\tif pos < 0 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t/* fmt.Printf(\"recorded param: %v func: %v\\n\", pos, fun) */\n\n\t\t\t\t\treflectParams[pos] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(reflectParams) > 0 {\n\t\tri.result.ReflectAPIs[f.FullName()] = reflectParams\n\n\t\t/* fmt.Printf(\"curPkgCache.ReflectAPIs: %v\\n\", curPkgCache.ReflectAPIs) */\n\t}\n}\n\n// recordArgReflected finds the type(s) of a function argument, which is being used in reflection\n// and excludes these types from obfuscation\n// It also checks if this argument has any relation to a function paramter and returns it if found.\nfunc (ri *reflectInspector) recordArgReflected(val ssa.Value, visited map[ssa.Value]bool) *ssa.Parameter {\n\t// make sure we visit every val only once, otherwise there will be infinite recursion\n\tif visited[val] {\n\t\treturn nil\n\t}\n\n\t/* fmt.Printf(\"val: %v %T %v\\n\", val, val, val.Type()) */\n\tvisited[val] = true\n\n\tswitch val := val.(type) {\n\tcase *ssa.IndexAddr:\n\t\tfor _, ref := range *val.Referrers() {\n\t\t\tif store, ok := ref.(*ssa.Store); ok {\n\t\t\t\tri.recordArgReflected(store.Val, visited)\n\t\t\t}\n\t\t}\n\t\treturn ri.recordArgReflected(val.X, visited)\n\tcase *ssa.Slice:\n\t\treturn ri.recordArgReflected(val.X, visited)\n\tcase *ssa.MakeInterface:\n\t\treturn ri.recordArgReflected(val.X, visited)\n\tcase *ssa.UnOp:\n\t\tfor _, ref := range *val.Referrers() {\n\t\t\tif idx, ok := ref.(ssa.Value); ok {\n\t\t\t\tri.recordArgReflected(idx, visited)\n\t\t\t}\n\t\t}\n\t\treturn ri.recordArgReflected(val.X, visited)\n\tcase *ssa.FieldAddr:\n\t\treturn ri.recordArgReflected(val.X, visited)\n\n\tcase *ssa.Alloc:\n\t\t/* fmt.Printf(\"recording val %v \\n\", *val.Referrers()) */\n\t\tri.recursivelyRecordUsedForReflect(val.Type(), nil)\n\n\t\tfor _, ref := range *val.Referrers() {\n\t\t\tif idx, ok := ref.(ssa.Value); ok {\n\t\t\t\tri.recordArgReflected(idx, visited)\n\t\t\t}\n\t\t}\n\n\t\t// relatedParam needs to revisit nodes so create an empty map\n\t\tvisited := make(map[ssa.Value]bool)\n\n\t\t// check if the found alloc gets tainted by function parameters\n\t\treturn relatedParam(val, visited)\n\n\tcase *ssa.ChangeType:\n\t\tri.recursivelyRecordUsedForReflect(val.X.Type(), nil)\n\tcase *ssa.MakeSlice, *ssa.MakeMap, *ssa.MakeChan, *ssa.Const:\n\t\tri.recursivelyRecordUsedForReflect(val.Type(), nil)\n\tcase *ssa.Global:\n\t\tri.recursivelyRecordUsedForReflect(val.Type(), nil)\n\n\t\t// TODO: this might need similar logic to *ssa.Alloc, however\n\t\t// reassigning a function param to a global variable and then reflecting\n\t\t// it is probably unlikely to occur\n\tcase *ssa.Parameter:\n\t\t// this only finds the parameters who want to be found,\n\t\t// otherwise relatedParam is used for more in depth analysis\n\n\t\tri.recursivelyRecordUsedForReflect(val.Type(), nil)\n\t\treturn val\n\t}\n\n\treturn nil\n}\n\n// relatedParam checks if a route to a function paramter can be constructed\n// from a ssa.Value, and returns the paramter if it found one.\nfunc relatedParam(val ssa.Value, visited map[ssa.Value]bool) *ssa.Parameter {\n\t// every val should only be visited once to prevent infinite recursion\n\tif visited[val] {\n\t\treturn nil\n\t}\n\n\t/* fmt.Printf(\"related val: %v %T %v\\n\", val, val, val.Type()) */\n\n\tvisited[val] = true\n\n\tswitch x := val.(type) {\n\tcase *ssa.Parameter:\n\t\t// a paramter has been found\n\t\treturn x\n\tcase *ssa.UnOp:\n\t\tif param := relatedParam(x.X, visited); param != nil {\n\t\t\treturn param\n\t\t}\n\tcase *ssa.FieldAddr:\n\t\t/* fmt.Printf(\"addr: %v\\n\", x)\n\t\tfmt.Printf(\"addr.X: %v %T\\n\", x.X, x.X) */\n\n\t\tif param := relatedParam(x.X, visited); param != nil {\n\t\t\treturn param\n\t\t}\n\t}\n\n\trefs := val.Referrers()\n\tif refs == nil {\n\t\treturn nil\n\t}\n\n\tfor _, ref := range *refs {\n\t\t/* fmt.Printf(\"ref: %v %T\\n\", ref, ref) */\n\n\t\tvar param *ssa.Parameter\n\t\tswitch ref := ref.(type) {\n\t\tcase *ssa.FieldAddr:\n\t\t\tparam = relatedParam(ref, visited)\n\n\t\tcase *ssa.UnOp:\n\t\t\tparam = relatedParam(ref, visited)\n\n\t\tcase *ssa.Store:\n\t\t\tif param := relatedParam(ref.Val, visited); param != nil {\n\t\t\t\treturn param\n\t\t\t}\n\n\t\t\tparam = relatedParam(ref.Addr, visited)\n\n\t\t}\n\n\t\tif param != nil {\n\t\t\treturn param\n\t\t}\n\n\t}\n\n\treturn nil\n}\n\n// recursivelyRecordUsedForReflect calls recordUsedForReflect on any named\n// types and fields under typ.\n//\n// Only the names declared in the current package are recorded. This is to ensure\n// that reflection detection only happens within the package declaring a type.\n// Detecting it in downstream packages could result in inconsistencies.\nfunc (ri *reflectInspector) recursivelyRecordUsedForReflect(t types.Type, parent *types.Struct) {\n\tswitch t := t.(type) {\n\tcase *types.Named:\n\t\tobj := t.Obj()\n\t\tif obj.Pkg() == nil || obj.Pkg() != ri.pkg {\n\t\t\treturn // not from the specified package\n\t\t}\n\t\tif usedForReflect(ri.result, obj) {\n\t\t\treturn // prevent endless recursion\n\t\t}\n\t\tri.recordUsedForReflect(obj, parent)\n\n\t\t// Record the underlying type, too.\n\t\tri.recursivelyRecordUsedForReflect(t.Underlying(), nil)\n\n\tcase *types.Struct:\n\t\tfor i := range t.NumFields() {\n\t\t\tfield := t.Field(i)\n\n\t\t\t// This check is similar to the one in *types.Named.\n\t\t\t// It's necessary for unnamed struct types,\n\t\t\t// as they aren't named but still have named fields.\n\t\t\tif field.Pkg() == nil || field.Pkg() != ri.pkg {\n\t\t\t\treturn // not from the specified package\n\t\t\t}\n\n\t\t\t// Record the field itself, too.\n\t\t\tri.recordUsedForReflect(field, t)\n\n\t\t\tri.recursivelyRecordUsedForReflect(field.Type(), nil)\n\t\t}\n\n\tcase interface{ Elem() types.Type }:\n\t\t// Get past pointers, slices, etc.\n\t\tri.recursivelyRecordUsedForReflect(t.Elem(), nil)\n\t}\n}\n\n// TODO: remove once alias tracking is properly implemented\nfunc recordedObjectString(obj types.Object) objectString {\n\tif obj == nil {\n\t\treturn \"\"\n\t}\n\tpkg := obj.Pkg()\n\tif pkg == nil {\n\t\treturn \"\"\n\t}\n\t// Names which are not at the package level still need to avoid obfuscation in some cases:\n\t//\n\t// 1. Field names on global types, which can be reached via reflection.\n\t// 2. Field names on anonymous types can also be reached via reflection.\n\t// 3. Local named types can be embedded in a local struct, becoming a field name as well.\n\t//\n\t// For now, a hack: assume that packages don't declare the same field\n\t// more than once in the same line. This works in practice, but one\n\t// could craft Go code to break this assumption.\n\t// Also note that the compiler's object files include filenames and line\n\t// numbers, but not column numbers nor byte offsets.\n\tif pkg.Scope() != obj.Parent() {\n\t\tswitch obj := obj.(type) {\n\t\tcase *types.Var: // struct fields; cases 1 and 2 above\n\t\t\tif !obj.IsField() {\n\t\t\t\treturn \"\" // local variables don't need to be recorded\n\t\t\t}\n\t\tcase *types.TypeName: // local named types; case 3 above\n\t\tdefault:\n\t\t\treturn \"\" // other objects (labels, consts, etc) don't need to be recorded\n\t\t}\n\t\tpos := fset.Position(obj.Pos())\n\t\treturn fmt.Sprintf(\"%s.%s - %s:%d\", pkg.Path(), obj.Name(),\n\t\t\tfilepath.Base(pos.Filename), pos.Line)\n\t}\n\t// For top-level names, \"pkgpath.Name\" is unique.\n\treturn pkg.Path() + \".\" + obj.Name()\n}\n\n// reflectedObjectString returns the obfucated name of a types.Object,\n// parent is needed to correctly get the obfucated name of struct fields\nfunc reflectedObjectString(obj types.Object, parent *types.Struct) string {\n\tif obj == nil {\n\t\treturn \"\"\n\t}\n\tpkg := obj.Pkg()\n\tif pkg == nil {\n\t\treturn \"\"\n\t}\n\n\tif v, ok := obj.(*types.Var); ok && parent != nil {\n\t\treturn hashWithStruct(parent, v)\n\t}\n\n\tlpkg := sharedCache.ListedPackages[obj.Pkg().Path()]\n\treturn hashWithPackage(lpkg, obj.Name())\n}\n\n// recordUsedForReflect records the objects whose names we cannot obfuscate due to reflection.\n// We currently record named types and fields.\nfunc (ri *reflectInspector) recordUsedForReflect(obj types.Object, parent *types.Struct) {\n\tif obj.Pkg().Path() != ri.pkg.Path() {\n\t\tpanic(\"called recordUsedForReflect with a foreign object\")\n\t}\n\tobjStr := reflectedObjectString(obj, parent)\n\tif objStr == \"\" {\n\t\treturn\n\t}\n\tri.result.ReflectObjectNames[objStr] = obj.Name()\n}\n\nfunc usedForReflect(cache pkgCache, obj types.Object) bool {\n\tobjStr := reflectedObjectString(obj, nil)\n\tif objStr == \"\" {\n\t\treturn false\n\t}\n\t_, ok := cache.ReflectObjectNames[objStr]\n\treturn ok\n}\n\n// We only mark named objects, so this function looks for a named object\n// corresponding to a type.\nfunc typeToObj(typ types.Type) types.Object {\n\tswitch t := typ.(type) {\n\tcase *types.Named:\n\t\treturn t.Obj()\n\tcase *types.Struct:\n\t\tif t.NumFields() > 0 {\n\t\t\treturn t.Field(0)\n\t\t}\n\tcase interface{ Elem() types.Type }:\n\t\treturn typeToObj(t.Elem())\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "reflect_abi_code.go",
          "type": "blob",
          "size": 7.755859375,
          "content": "package main\n\n// The \"name\" internal/abi passes to this function doesn't have to be a simple \"someName\",\n// it can also be for function names like \"*pkgName.FuncName\" (obfuscated)\n// or for structs the entire struct definition, like\n//\n//\t*struct { AQ45rr68K string; ipq5aQSIqN string; hNfiW5O5LVq struct { gPTbGR00hu string } }\n//\n// Therefore all obfuscated names which occur within name need to be replaced with their original equivalents.\n// The code below does a more efficient version of:\n//\n//\tfunc _originalNames(name string) string {\n//\t\tfor _, pair := range _originalNamePairs {\n//\t\t\tname = strings.ReplaceAll(name, pair[0], pair[1])\n//\t\t}\n//\t\treturn name\n//\t}\n//\n// The linknames below are only turned on when the code is injected,\n// so that we can test and benchmark this code normally.\n\n// Injected code below this line.\n\n// Each pair is the obfuscated and then the real name.\n// The pairs are sorted by obfuscated name, lexicographically.\nvar _originalNamePairs = []string{}\n\nvar _originalNamesReplacer *_genericReplacer\n\n//disabledgo:linkname _originalNamesInit internal/abi._originalNamesInit\nfunc _originalNamesInit() {\n\t_originalNamesReplacer = _makeGenericReplacer(_originalNamePairs)\n}\n\n//disabledgo:linkname _originalNames internal/abi._originalNames\nfunc _originalNames(name string) string {\n\treturn _originalNamesReplacer.Replace(name)\n}\n\n// -- Lifted from internal/stringslite --\n\nfunc _hasPrefix(s, prefix string) bool {\n\treturn len(s) >= len(prefix) && s[0:len(prefix)] == prefix\n}\n\n// -- Lifted from strings as of Go 1.23 --\n//\n// With minor modifications to avoid type assertions,\n// as any reflection in internal/abi causes a recursive call to the runtime\n// which locks up the entire runtime. Moreover, we can't import strings.\n//\n// Updating the code below should not be necessary in general,\n// unless upstream Go makes significant improvements to this replacer implementation.\n\n// _trieNode is a node in a lookup trie for prioritized key/value pairs. Keys\n// and values may be empty. For example, the trie containing keys \"ax\", \"ay\",\n// \"bcbc\", \"x\" and \"xy\" could have eight nodes:\n//\n//\tn0  -\n//\tn1  a-\n//\tn2  .x+\n//\tn3  .y+\n//\tn4  b-\n//\tn5  .cbc+\n//\tn6  x+\n//\tn7  .y+\n//\n// n0 is the root node, and its children are n1, n4 and n6; n1's children are\n// n2 and n3; n4's child is n5; n6's child is n7. Nodes n0, n1 and n4 (marked\n// with a trailing \"-\") are partial keys, and nodes n2, n3, n5, n6 and n7\n// (marked with a trailing \"+\") are complete keys.\ntype _trieNode struct {\n\t// value is the value of the trie node's key/value pair. It is empty if\n\t// this node is not a complete key.\n\tvalue string\n\t// priority is the priority (higher is more important) of the trie node's\n\t// key/value pair; keys are not necessarily matched shortest- or longest-\n\t// first. Priority is positive if this node is a complete key, and zero\n\t// otherwise. In the example above, positive/zero priorities are marked\n\t// with a trailing \"+\" or \"-\".\n\tpriority int\n\n\t// A trie node may have zero, one or more child nodes:\n\t//  * if the remaining fields are zero, there are no children.\n\t//  * if prefix and next are non-zero, there is one child in next.\n\t//  * if table is non-zero, it defines all the children.\n\t//\n\t// Prefixes are preferred over tables when there is one child, but the\n\t// root node always uses a table for lookup efficiency.\n\n\t// prefix is the difference in keys between this trie node and the next.\n\t// In the example above, node n4 has prefix \"cbc\" and n4's next node is n5.\n\t// Node n5 has no children and so has zero prefix, next and table fields.\n\tprefix string\n\tnext   *_trieNode\n\n\t// table is a lookup table indexed by the next byte in the key, after\n\t// remapping that byte through _genericReplacer.mapping to create a dense\n\t// index. In the example above, the keys only use 'a', 'b', 'c', 'x' and\n\t// 'y', which remap to 0, 1, 2, 3 and 4. All other bytes remap to 5, and\n\t// _genericReplacer.tableSize will be 5. Node n0's table will be\n\t// []*_trieNode{ 0:n1, 1:n4, 3:n6 }, where the 0, 1 and 3 are the remapped\n\t// 'a', 'b' and 'x'.\n\ttable []*_trieNode\n}\n\nfunc (t *_trieNode) add(key, val string, priority int, r *_genericReplacer) {\n\tif key == \"\" {\n\t\tif t.priority == 0 {\n\t\t\tt.value = val\n\t\t\tt.priority = priority\n\t\t}\n\t\treturn\n\t}\n\n\tif t.prefix != \"\" {\n\t\tvar n int // length of the longest common prefix\n\t\tfor ; n < len(t.prefix) && n < len(key); n++ {\n\t\t\tif t.prefix[n] != key[n] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif n == len(t.prefix) {\n\t\t\tt.next.add(key[n:], val, priority, r)\n\t\t} else if n == 0 {\n\t\t\tvar prefixNode *_trieNode\n\t\t\tif len(t.prefix) == 1 {\n\t\t\t\tprefixNode = t.next\n\t\t\t} else {\n\t\t\t\tprefixNode = &_trieNode{\n\t\t\t\t\tprefix: t.prefix[1:],\n\t\t\t\t\tnext:   t.next,\n\t\t\t\t}\n\t\t\t}\n\t\t\tkeyNode := new(_trieNode)\n\t\t\tt.table = make([]*_trieNode, r.tableSize)\n\t\t\tt.table[r.mapping[t.prefix[0]]] = prefixNode\n\t\t\tt.table[r.mapping[key[0]]] = keyNode\n\t\t\tt.prefix = \"\"\n\t\t\tt.next = nil\n\t\t\tkeyNode.add(key[1:], val, priority, r)\n\t\t} else {\n\t\t\t// Insert new node after the common section of the prefix.\n\t\t\tnext := &_trieNode{\n\t\t\t\tprefix: t.prefix[n:],\n\t\t\t\tnext:   t.next,\n\t\t\t}\n\t\t\tt.prefix = t.prefix[:n]\n\t\t\tt.next = next\n\t\t\tnext.add(key[n:], val, priority, r)\n\t\t}\n\t} else if t.table != nil {\n\t\t// Insert into existing table.\n\t\tm := r.mapping[key[0]]\n\t\tif t.table[m] == nil {\n\t\t\tt.table[m] = new(_trieNode)\n\t\t}\n\t\tt.table[m].add(key[1:], val, priority, r)\n\t} else {\n\t\tt.prefix = key\n\t\tt.next = new(_trieNode)\n\t\tt.next.add(\"\", val, priority, r)\n\t}\n}\n\nfunc (r *_genericReplacer) lookup(s string, ignoreRoot bool) (val string, keylen int, found bool) {\n\t// Iterate down the trie to the end, and grab the value and keylen with\n\t// the highest priority.\n\tbestPriority := 0\n\tnode := &r.root\n\tn := 0\n\tfor node != nil {\n\t\tif node.priority > bestPriority && !(ignoreRoot && node == &r.root) {\n\t\t\tbestPriority = node.priority\n\t\t\tval = node.value\n\t\t\tkeylen = n\n\t\t\tfound = true\n\t\t}\n\n\t\tif s == \"\" {\n\t\t\tbreak\n\t\t}\n\t\tif node.table != nil {\n\t\t\tindex := r.mapping[s[0]]\n\t\t\tif int(index) == r.tableSize {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = node.table[index]\n\t\t\ts = s[1:]\n\t\t\tn++\n\t\t} else if node.prefix != \"\" && _hasPrefix(s, node.prefix) {\n\t\t\tn += len(node.prefix)\n\t\t\ts = s[len(node.prefix):]\n\t\t\tnode = node.next\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\ntype _genericReplacer struct {\n\troot _trieNode\n\t// tableSize is the size of a trie node's lookup table. It is the number\n\t// of unique key bytes.\n\ttableSize int\n\t// mapping maps from key bytes to a dense index for _trieNode.table.\n\tmapping [256]byte\n}\n\nfunc _makeGenericReplacer(oldnew []string) *_genericReplacer {\n\tr := new(_genericReplacer)\n\t// Find each byte used, then assign them each an index.\n\tfor i := 0; i < len(oldnew); i += 2 {\n\t\tkey := oldnew[i]\n\t\tfor j := 0; j < len(key); j++ {\n\t\t\tr.mapping[key[j]] = 1\n\t\t}\n\t}\n\n\tfor _, b := range r.mapping {\n\t\tr.tableSize += int(b)\n\t}\n\n\tvar index byte\n\tfor i, b := range r.mapping {\n\t\tif b == 0 {\n\t\t\tr.mapping[i] = byte(r.tableSize)\n\t\t} else {\n\t\t\tr.mapping[i] = index\n\t\t\tindex++\n\t\t}\n\t}\n\t// Find each byte used, then assign them each an index.\n\tr.root.table = make([]*_trieNode, r.tableSize)\n\n\tfor i := 0; i < len(oldnew); i += 2 {\n\t\tr.root.add(oldnew[i], oldnew[i+1], len(oldnew)-i, r)\n\t}\n\treturn r\n}\n\nfunc (r *_genericReplacer) Replace(s string) string {\n\tdst := make([]byte, 0, len(s))\n\tvar last int\n\tvar prevMatchEmpty bool\n\tfor i := 0; i <= len(s); {\n\t\t// Fast path: s[i] is not a prefix of any pattern.\n\t\tif i != len(s) && r.root.priority == 0 {\n\t\t\tindex := int(r.mapping[s[i]])\n\t\t\tif index == r.tableSize || r.root.table[index] == nil {\n\t\t\t\ti++\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// Ignore the empty match iff the previous loop found the empty match.\n\t\tval, keylen, match := r.lookup(s[i:], prevMatchEmpty)\n\t\tprevMatchEmpty = match && keylen == 0\n\t\tif match {\n\t\t\tdst = append(dst, s[last:i]...)\n\t\t\tdst = append(dst, val...)\n\t\t\ti += keylen\n\t\t\tlast = i\n\t\t\tcontinue\n\t\t}\n\t\ti++\n\t}\n\tif last != len(s) {\n\t\tdst = append(dst, s[last:]...)\n\t}\n\treturn string(dst)\n}\n"
        },
        {
          "name": "reflect_abi_patch.go",
          "type": "blob",
          "size": 2.361328125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t_ \"embed\"\n\t\"fmt\"\n\t\"maps\"\n\t\"os\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc abiNamePatch(path string) (string, error) {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfind := `return unsafe.String(n.DataChecked(1+i, \"non-empty string\"), l)`\n\treplace := `return _originalNames(unsafe.String(n.DataChecked(1+i, \"non-empty string\"), l))`\n\n\tstr := strings.Replace(string(data), find, replace, 1)\n\n\toriginalNames := `\n//go:linkname _originalNames\nfunc _originalNames(name string) string\n\n//go:linkname _originalNamesInit\nfunc _originalNamesInit()\n\nfunc init() { _originalNamesInit() }\n`\n\n\treturn str + originalNames, nil\n}\n\nvar reflectPatchFile = \"\"\n\n// reflectMainPrePatch adds the initial empty name mapping and _originalNames implementation\n// to a file in the main package. The name mapping will be populated later after\n// analyzing the main package, since we need to know all obfuscated names that need mapping.\n// We split this into pre/post steps so that all variable names in the generated code\n// can be properly obfuscated - if we added the filled map directly, the obfuscated names\n// would appear as plain strings in the binary.\nfunc reflectMainPrePatch(path string) ([]byte, error) {\n\tif reflectPatchFile != \"\" {\n\t\t// already patched another file in main\n\t\treturn nil, nil\n\t}\n\n\tcontent, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t_, code, _ := strings.Cut(reflectAbiCode, \"// Injected code below this line.\")\n\tcode = strings.ReplaceAll(code, \"//disabledgo:\", \"//go:\")\n\t// This constant is declared in our hash.go file.\n\tcode = strings.ReplaceAll(code, \"minHashLength\", strconv.Itoa(minHashLength))\n\treturn append(content, []byte(code)...), nil\n}\n\n// reflectMainPostPatch populates the name mapping with the final obfuscated->real name\n// mappings after all packages have been analyzed.\nfunc reflectMainPostPatch(file []byte, lpkg *listedPackage, pkg pkgCache) []byte {\n\tobfVarName := hashWithPackage(lpkg, \"_originalNamePairs\")\n\tnamePairs := fmt.Appendf(nil, \"%s = []string{\", obfVarName)\n\n\tkeys := slices.Sorted(maps.Keys(pkg.ReflectObjectNames))\n\tnamePairsFilled := bytes.Clone(namePairs)\n\tfor _, obf := range keys {\n\t\tnamePairsFilled = fmt.Appendf(namePairsFilled, \"%q, %q,\", obf, pkg.ReflectObjectNames[obf])\n\t}\n\n\treturn bytes.Replace(file, namePairs, namePairsFilled, 1)\n}\n\n//go:embed reflect_abi_code.go\nvar reflectAbiCode string\n"
        },
        {
          "name": "reverse.go",
          "type": "blob",
          "size": 5.365234375,
          "content": "// Copyright (c) 2019, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/types\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\n// commandReverse implements \"garble reverse\".\nfunc commandReverse(args []string) error {\n\tflags, args := splitFlagsFromArgs(args)\n\tif hasHelpFlag(flags) || len(args) == 0 {\n\t\tfmt.Fprint(os.Stderr, `\nusage: garble [garble flags] reverse [build flags] package [files]\n\nFor example, after building an obfuscated program as follows:\n\n\tgarble -literals build -tags=mytag ./cmd/mycmd\n\nOne can reverse a captured panic stack trace as follows:\n\n\tgarble -literals reverse -tags=mytag ./cmd/mycmd panic-output.txt\n`[1:])\n\t\treturn errJustExit(2)\n\t}\n\n\tpkg, args := args[0], args[1:]\n\t// We don't actually run `go list -toolexec=garble`; we only use toolexecCmd\n\t// to ensure that sharedCache.ListedPackages is filled.\n\t_, err := toolexecCmd(\"list\", []string{pkg})\n\tdefer os.RemoveAll(os.Getenv(\"GARBLE_SHARED\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// We don't actually run a main Go command with all flags,\n\t// so if the user gave a non-build flag,\n\t// we need this check to not silently ignore it.\n\tif _, firstUnknown := filterForwardBuildFlags(flags); firstUnknown != \"\" {\n\t\t// A bit of a hack to get a normal flag.Parse error.\n\t\t// Longer term, \"reverse\" might have its own FlagSet.\n\t\treturn flag.NewFlagSet(\"\", flag.ContinueOnError).Parse([]string{firstUnknown})\n\t}\n\n\t// A package's names are generally hashed with the action ID of its\n\t// obfuscated build. We recorded those action IDs above.\n\t// Note that we parse Go files directly to obtain the names, since the\n\t// export data only exposes exported names. Parsing Go files is cheap,\n\t// so it's unnecessary to try to avoid this cost.\n\tvar replaces []string\n\n\tfor _, lpkg := range sharedCache.ListedPackages {\n\t\tif !lpkg.ToObfuscate {\n\t\t\tcontinue\n\t\t}\n\t\taddHashedWithPackage := func(str string) {\n\t\t\treplaces = append(replaces, hashWithPackage(lpkg, str), str)\n\t\t}\n\n\t\t// Package paths are obfuscated, too.\n\t\taddHashedWithPackage(lpkg.ImportPath)\n\n\t\tfiles, err := parseFiles(lpkg, lpkg.Dir, lpkg.CompiledGoFiles)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\torigImporter := importerForPkg(lpkg)\n\t\t_, info, err := typecheck(lpkg.ImportPath, files, origImporter)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfieldToStruct := computeFieldToStruct(info)\n\t\tfor i, file := range files {\n\t\t\tgoFile := lpkg.CompiledGoFiles[i]\n\t\t\tast.Inspect(file, func(node ast.Node) bool {\n\t\t\t\tswitch node := node.(type) {\n\n\t\t\t\t// Replace names.\n\t\t\t\t// TODO: do var names ever show up in output?\n\t\t\t\tcase *ast.FuncDecl:\n\t\t\t\t\taddHashedWithPackage(node.Name.Name)\n\t\t\t\tcase *ast.TypeSpec:\n\t\t\t\t\taddHashedWithPackage(node.Name.Name)\n\t\t\t\tcase *ast.Field:\n\t\t\t\t\tfor _, name := range node.Names {\n\t\t\t\t\t\tobj, _ := info.ObjectOf(name).(*types.Var)\n\t\t\t\t\t\tif obj == nil || !obj.IsField() {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstrct := fieldToStruct[obj]\n\t\t\t\t\t\tif strct == nil {\n\t\t\t\t\t\t\tpanic(\"could not find struct for field \" + name.Name)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaces = append(replaces, hashWithStruct(strct, obj), name.Name)\n\t\t\t\t\t}\n\n\t\t\t\tcase *ast.CallExpr:\n\t\t\t\t\t// Reverse position information of call sites.\n\t\t\t\t\tpos := fset.Position(node.Pos())\n\t\t\t\t\torigPos := fmt.Sprintf(\"%s:%d\", goFile, pos.Offset)\n\t\t\t\t\tnewFilename := hashWithPackage(lpkg, origPos) + \".go\"\n\n\t\t\t\t\t// Do \"obfuscated.go:1\", corresponding to the call site's line.\n\t\t\t\t\t// Most common in stack traces.\n\t\t\t\t\treplaces = append(replaces,\n\t\t\t\t\t\tnewFilename+\":1\",\n\t\t\t\t\t\tfmt.Sprintf(\"%s/%s:%d\", lpkg.ImportPath, goFile, pos.Line),\n\t\t\t\t\t)\n\n\t\t\t\t\t// Do \"obfuscated.go\" as a fallback.\n\t\t\t\t\t// Most useful in build errors in obfuscated code,\n\t\t\t\t\t// since those might land on any line.\n\t\t\t\t\t// Any \":N\" line number will end up being useless,\n\t\t\t\t\t// but at least the filename will be correct.\n\t\t\t\t\treplaces = append(replaces,\n\t\t\t\t\t\tnewFilename,\n\t\t\t\t\t\tfmt.Sprintf(\"%s/%s\", lpkg.ImportPath, goFile),\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\treturn true\n\t\t\t})\n\t\t}\n\t}\n\trepl := strings.NewReplacer(replaces...)\n\n\tif len(args) == 0 {\n\t\tmodified, err := reverseContent(os.Stdout, os.Stdin, repl)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !modified {\n\t\t\treturn errJustExit(1)\n\t\t}\n\t\treturn nil\n\t}\n\t// TODO: cover this code in the tests too\n\tanyModified := false\n\tfor _, path := range args {\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer f.Close()\n\t\tmodified, err := reverseContent(os.Stdout, f, repl)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tanyModified = anyModified || modified\n\t\tf.Close() // since we're in a loop\n\t}\n\tif !anyModified {\n\t\treturn errJustExit(1)\n\t}\n\treturn nil\n}\n\nfunc reverseContent(w io.Writer, r io.Reader, repl *strings.Replacer) (bool, error) {\n\t// Read line by line.\n\t// Reading the entire content at once wouldn't be interactive,\n\t// nor would it support large files well.\n\t// Reading entire lines ensures we don't cut words in half.\n\t// We use bufio.Reader instead of bufio.Scanner,\n\t// to also obtain the newline characters themselves.\n\tbr := bufio.NewReader(r)\n\tmodified := false\n\tfor {\n\t\t// Note that ReadString can return a line as well as an error if\n\t\t// we hit EOF without a newline.\n\t\t// In that case, we still want to process the string.\n\t\tline, readErr := br.ReadString('\\n')\n\n\t\tnewLine := repl.Replace(line)\n\t\tif newLine != line {\n\t\t\tmodified = true\n\t\t}\n\t\tif _, err := io.WriteString(w, newLine); err != nil {\n\t\t\treturn modified, err\n\t\t}\n\t\tif readErr == io.EOF {\n\t\t\treturn modified, nil\n\t\t}\n\t\tif readErr != nil {\n\t\t\treturn modified, readErr\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "runtime_patch.go",
          "type": "blob",
          "size": 7.0576171875,
          "content": "// Copyright (c) 2020, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t\"go/ast\"\n\t\"go/token\"\n\t\"strconv\"\n\t\"strings\"\n\n\tah \"mvdan.cc/garble/internal/asthelper\"\n)\n\n// updateMagicValue updates hardcoded value of hdr.magic\n// when verifying header in symtab.go\nfunc updateMagicValue(file *ast.File, magicValue uint32) {\n\tmagicUpdated := false\n\n\t// Find `hdr.magic != 0xfffffff?` in symtab.go and update to random magicValue\n\tupdateMagic := func(node ast.Node) bool {\n\t\tbinExpr, ok := node.(*ast.BinaryExpr)\n\t\tif !ok || binExpr.Op != token.NEQ {\n\t\t\treturn true\n\t\t}\n\n\t\tselectorExpr, ok := binExpr.X.(*ast.SelectorExpr)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tif ident, ok := selectorExpr.X.(*ast.Ident); !ok || ident.Name != \"hdr\" {\n\t\t\treturn true\n\t\t}\n\t\tif selectorExpr.Sel.Name != \"magic\" {\n\t\t\treturn true\n\t\t}\n\n\t\tif _, ok := binExpr.Y.(*ast.BasicLit); !ok {\n\t\t\treturn true\n\t\t}\n\t\tbinExpr.Y = &ast.BasicLit{\n\t\t\tKind:  token.INT,\n\t\t\tValue: strconv.FormatUint(uint64(magicValue), 10),\n\t\t}\n\t\tmagicUpdated = true\n\t\treturn false\n\t}\n\n\tfor _, decl := range file.Decls {\n\t\tfuncDecl, ok := decl.(*ast.FuncDecl)\n\t\tif ok && funcDecl.Name.Name == \"moduledataverify1\" {\n\t\t\tast.Inspect(funcDecl, updateMagic)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !magicUpdated {\n\t\tpanic(\"magic value not updated\")\n\t}\n}\n\n// updateEntryOffset adds xor encryption for funcInfo.entryoff\n// Encryption algorithm contains 1 xor and 1 multiply operations and is not cryptographically strong.\n// Its goal, without slowing down program performance (reflection, stacktrace),\n// is to make it difficult to determine relations between function metadata and function itself in a binary file.\n// Difficulty of decryption is based on the difficulty of finding a small (probably inlined) entry() function without obvious patterns.\nfunc updateEntryOffset(file *ast.File, entryOffKey uint32) {\n\t// Note that this field could be renamed in future Go versions.\n\tconst nameOffField = \"nameOff\"\n\tentryOffUpdated := false\n\n\t// During linker stage we encrypt funcInfo.entryoff using a random number and funcInfo.nameOff,\n\t// for correct program functioning we must decrypt funcInfo.entryoff at any access to it.\n\t// In runtime package all references to funcInfo.entryOff are made through one method entry():\n\t// func (f funcInfo) entry() uintptr {\n\t//\treturn f.datap.textAddr(f.entryoff)\n\t// }\n\t// It is enough to inject decryption into entry() method for program to start working transparently with encrypted value of funcInfo.entryOff:\n\t// func (f funcInfo) entry() uintptr {\n\t//\treturn f.datap.textAddr(f.entryoff ^ (uint32(f.nameOff) * <random int>))\n\t// }\n\tupdateEntryOff := func(node ast.Node) bool {\n\t\tcallExpr, ok := node.(*ast.CallExpr)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\ttextSelExpr, ok := callExpr.Fun.(*ast.SelectorExpr)\n\t\tif !ok || textSelExpr.Sel.Name != \"textAddr\" {\n\t\t\treturn true\n\t\t}\n\n\t\tselExpr, ok := callExpr.Args[0].(*ast.SelectorExpr)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tcallExpr.Args[0] = &ast.BinaryExpr{\n\t\t\tX:  selExpr,\n\t\t\tOp: token.XOR,\n\t\t\tY: &ast.ParenExpr{X: &ast.BinaryExpr{\n\t\t\t\tX: ah.CallExpr(ast.NewIdent(\"uint32\"), &ast.SelectorExpr{\n\t\t\t\t\tX:   selExpr.X,\n\t\t\t\t\tSel: ast.NewIdent(nameOffField),\n\t\t\t\t}),\n\t\t\t\tOp: token.MUL,\n\t\t\t\tY: &ast.BasicLit{\n\t\t\t\t\tKind:  token.INT,\n\t\t\t\t\tValue: strconv.FormatUint(uint64(entryOffKey), 10),\n\t\t\t\t},\n\t\t\t}},\n\t\t}\n\t\tentryOffUpdated = true\n\t\treturn false\n\t}\n\n\tvar entryFunc *ast.FuncDecl\n\tfor _, decl := range file.Decls {\n\t\tdecl, ok := decl.(*ast.FuncDecl)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif decl.Name.Name == \"entry\" {\n\t\t\tentryFunc = decl\n\t\t\tbreak\n\t\t}\n\t}\n\tif entryFunc == nil {\n\t\tpanic(\"entry function not found\")\n\t}\n\n\tast.Inspect(entryFunc, updateEntryOff)\n\tif !entryOffUpdated {\n\t\tpanic(\"entryOff not found\")\n\t}\n}\n\n// stripRuntime removes unnecessary code from the runtime,\n// such as panic and fatal error printing, and code that\n// prints trace/debug info of the runtime.\nfunc stripRuntime(basename string, file *ast.File) {\n\tstripPrints := func(node ast.Node) bool {\n\t\tcall, ok := node.(*ast.CallExpr)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\t\tid, ok := call.Fun.(*ast.Ident)\n\t\tif !ok {\n\t\t\treturn true\n\t\t}\n\n\t\tswitch id.Name {\n\t\tcase \"print\", \"println\":\n\t\t\tid.Name = \"hidePrint\"\n\t\t\treturn false\n\t\tdefault:\n\t\t\treturn true\n\t\t}\n\t}\n\n\tfor _, decl := range file.Decls {\n\t\tfuncDecl, ok := decl.(*ast.FuncDecl)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch basename {\n\t\tcase \"error.go\":\n\t\t\t// only used in panics\n\t\t\tswitch funcDecl.Name.Name {\n\t\t\tcase \"printany\", \"printanycustomtype\":\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"mgcscavenge.go\":\n\t\t\t// used in tracing the scavenger\n\t\t\tif funcDecl.Name.Name == \"printScavTrace\" {\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"mprof.go\":\n\t\t\t// remove all functions that print debug/tracing info\n\t\t\t// of the runtime\n\t\t\tif strings.HasPrefix(funcDecl.Name.Name, \"trace\") {\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"panic.go\":\n\t\t\t// used for printing panics\n\t\t\tswitch funcDecl.Name.Name {\n\t\t\tcase \"preprintpanics\", \"printpanics\":\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"print.go\":\n\t\t\t// only used in tracebacks\n\t\t\tif funcDecl.Name.Name == \"hexdumpWords\" {\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"proc.go\":\n\t\t\t// used in tracing the scheduler\n\t\t\tif funcDecl.Name.Name == \"schedtrace\" {\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"runtime1.go\":\n\t\t\tusesEnv := func(node ast.Node) bool {\n\t\t\t\tseen := false\n\t\t\t\tast.Inspect(node, func(node ast.Node) bool {\n\t\t\t\t\tident, ok := node.(*ast.Ident)\n\t\t\t\t\tif ok && ident.Name == \"gogetenv\" {\n\t\t\t\t\t\tseen = true\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t\t\treturn seen\n\t\t\t}\n\t\tfilenames:\n\t\t\tswitch funcDecl.Name.Name {\n\t\t\tcase \"parsedebugvars\":\n\t\t\t\t// keep defaults for GODEBUG cgocheck and invalidptr,\n\t\t\t\t// remove code that reads GODEBUG via gogetenv\n\t\t\t\tfor i, stmt := range funcDecl.Body.List {\n\t\t\t\t\tif usesEnv(stmt) {\n\t\t\t\t\t\tfuncDecl.Body.List = funcDecl.Body.List[:i]\n\t\t\t\t\t\tbreak filenames\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpanic(\"did not see any gogetenv call in parsedebugvars\")\n\t\t\tcase \"setTraceback\":\n\t\t\t\t// tracebacks are completely hidden, no\n\t\t\t\t// sense keeping this function\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t}\n\t\tcase \"traceback.go\":\n\t\t\t// only used for printing tracebacks\n\t\t\tswitch funcDecl.Name.Name {\n\t\t\tcase \"tracebackdefers\", \"printcreatedby\", \"printcreatedby1\", \"traceback\", \"tracebacktrap\", \"traceback1\", \"printAncestorTraceback\",\n\t\t\t\t\"printAncestorTracebackFuncInfo\", \"goroutineheader\", \"tracebackothers\", \"tracebackHexdump\", \"printCgoTraceback\":\n\t\t\t\tfuncDecl.Body.List = nil\n\t\t\tcase \"printOneCgoTraceback\":\n\t\t\t\tfuncDecl.Body = ah.BlockStmt(ah.ReturnStmt(ast.NewIdent(\"false\")))\n\t\t\tdefault:\n\t\t\t\tif strings.HasPrefix(funcDecl.Name.Name, \"print\") {\n\t\t\t\t\tfuncDecl.Body.List = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif basename == \"print.go\" {\n\t\tfile.Decls = append(file.Decls, hidePrintDecl)\n\t\treturn\n\t}\n\n\t// replace all 'print' and 'println' statements in\n\t// the runtime with an empty func, which will be\n\t// optimized out by the compiler\n\tast.Inspect(file, stripPrints)\n}\n\nvar hidePrintDecl = &ast.FuncDecl{\n\tName: ast.NewIdent(\"hidePrint\"),\n\tType: &ast.FuncType{Params: &ast.FieldList{\n\t\tList: []*ast.Field{{\n\t\t\tNames: []*ast.Ident{{Name: \"args\"}},\n\t\t\tType: &ast.Ellipsis{Elt: &ast.InterfaceType{\n\t\t\t\tMethods: &ast.FieldList{},\n\t\t\t}},\n\t\t}},\n\t}},\n\tBody: &ast.BlockStmt{},\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "shared.go",
          "type": "blob",
          "size": 14.9013671875,
          "content": "// Copyright (c) 2020, The Garble Authors.\n// See LICENSE for licensing information.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/gob\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"slices\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/mod/module\"\n)\n\n//go:generate go run scripts/gen_go_std_tables.go\n\n// sharedCacheType is shared as a read-only cache between the many garble toolexec\n// sub-processes.\n//\n// Note that we fill this cache once from the root process in saveListedPackages,\n// store it into a temporary file via gob encoding, and then reuse that file\n// in each of the garble toolexec sub-processes.\ntype sharedCacheType struct {\n\tForwardBuildFlags []string // build flags fed to the original \"garble ...\" command\n\n\tCacheDir string // absolute path to the GARBLE_CACHE directory being used\n\n\t// ListedPackages contains data obtained via 'go list -json -export -deps'.\n\t// This allows us to obtain the non-obfuscated export data of all dependencies,\n\t// useful for type checking of the packages as we obfuscate them.\n\tListedPackages map[string]*listedPackage\n\n\t// We can't use garble's own module version, as it may not exist.\n\t// We can't use the stamped VCS information either,\n\t// as uncommitted changes simply show up as \"dirty\".\n\t//\n\t// The only unique way to identify garble's version without being published\n\t// or committed is to use its content ID from the build cache.\n\tBinaryContentID []byte\n\n\tGOGARBLE string\n\n\t// GoVersion is a version of the Go toolchain currently being used,\n\t// as reported by \"go env GOVERSION\" and compatible with go/version.\n\t// Note that the version of Go that built the garble binary might be newer.\n\t// Also note that a devel version like \"go1.22-231f290e51\" is\n\t// currently represented as \"go1.22\", as the suffix is ignored by go/version.\n\tGoVersion string\n\n\t// Filled directly from \"go env\".\n\t// Keep in sync with fetchGoEnv.\n\tGoEnv struct {\n\t\tGOOS   string // the GOOS build target\n\t\tGOARCH string // the GOARCH build target\n\n\t\tGOVERSION string\n\t\tGOROOT    string\n\t}\n}\n\nvar sharedCache *sharedCacheType\n\n// loadSharedCache the shared data passed from the entry garble process\nfunc loadSharedCache() error {\n\tif sharedCache != nil {\n\t\tpanic(\"shared cache loaded twice?\")\n\t}\n\tstartTime := time.Now()\n\tf, err := os.Open(filepath.Join(sharedTempDir, \"main-cache.gob\"))\n\tif err != nil {\n\t\treturn fmt.Errorf(`cannot open shared file: %v\\ndid you run \"go [command] -toolexec=garble\" instead of \"garble [command]\"?`, err)\n\t}\n\tdefer func() {\n\t\tlog.Printf(\"shared cache loaded in %s from %s\", debugSince(startTime), f.Name())\n\t}()\n\tdefer f.Close()\n\tif err := gob.NewDecoder(f).Decode(&sharedCache); err != nil {\n\t\treturn fmt.Errorf(\"cannot decode shared file: %v\", err)\n\t}\n\treturn nil\n}\n\n// saveSharedCache creates a temporary directory to share between garble processes.\n// This directory also includes the gob-encoded cache global.\nfunc saveSharedCache() (string, error) {\n\tif sharedCache == nil {\n\t\tpanic(\"saving a missing cache?\")\n\t}\n\tdir, err := os.MkdirTemp(\"\", \"garble-shared\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tcachePath := filepath.Join(dir, \"main-cache.gob\")\n\tif err := writeGobExclusive(cachePath, &sharedCache); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn dir, nil\n}\n\nfunc createExclusive(name string) (*os.File, error) {\n\treturn os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0o666)\n}\n\nfunc writeFileExclusive(name string, data []byte) error {\n\tf, err := createExclusive(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = f.Write(data)\n\tif err2 := f.Close(); err == nil {\n\t\terr = err2\n\t}\n\treturn err\n}\n\nfunc writeGobExclusive(name string, val any) error {\n\tf, err := createExclusive(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Always close the file, and return the first error we get.\n\terr = gob.NewEncoder(f).Encode(val)\n\tif err2 := f.Close(); err == nil {\n\t\terr = err2\n\t}\n\treturn err\n}\n\n// listedPackage contains the 'go list -json -export' fields obtained by the\n// root process, shared with all garble sub-processes via a file.\ntype listedPackage struct {\n\tName       string\n\tImportPath string\n\tForTest    string\n\tExport     string\n\tBuildID    string\n\tImportMap  map[string]string\n\tStandard   bool\n\n\tDir             string\n\tCompiledGoFiles []string\n\tImports         []string\n\n\tError *packageError // to report package loading errors to the user\n\n\t// The fields below are not part of 'go list', but are still reused\n\t// between garble processes. Use \"Garble\" as a prefix to ensure no\n\t// collisions with the JSON fields from 'go list'.\n\n\t// allDeps is like the Deps field given by 'go list', but in the form of a map\n\t// for the sake of fast lookups. It's also unnecessary to consume or store Deps\n\t// as returned by 'go list', as it can be reconstructed from Imports.\n\tallDeps map[string]struct{}\n\n\t// GarbleActionID is a hash combining the Action ID from BuildID,\n\t// with Garble's own inputs as per addGarbleToHash.\n\t// It is set even when ToObfuscate is false, as it is also used for random\n\t// seeds and build cache paths, and not just to obfuscate names.\n\tGarbleActionID [sha256.Size]byte `json:\"-\"`\n\n\t// ToObfuscate records whether the package should be obfuscated.\n\t// When true, GarbleActionID must not be empty.\n\tToObfuscate bool `json:\"-\"`\n}\n\nfunc (p *listedPackage) hasDep(path string) bool {\n\tif p.allDeps == nil {\n\t\tp.allDeps = make(map[string]struct{}, len(p.Imports)*2)\n\t\tp.addImportsFrom(p)\n\t}\n\t_, ok := p.allDeps[path]\n\treturn ok\n}\n\nfunc (p *listedPackage) addImportsFrom(from *listedPackage) {\n\tfor _, path := range from.Imports {\n\t\tif path == \"C\" {\n\t\t\t// `go list -json` shows \"C\" in Imports but not Deps.\n\t\t\t// See https://go.dev/issue/60453.\n\t\t\tcontinue\n\t\t}\n\t\tif path2 := from.ImportMap[path]; path2 != \"\" {\n\t\t\tpath = path2\n\t\t}\n\t\tif _, ok := p.allDeps[path]; ok {\n\t\t\tcontinue // already added\n\t\t}\n\t\tp.allDeps[path] = struct{}{}\n\t\tp.addImportsFrom(sharedCache.ListedPackages[path])\n\t}\n}\n\ntype packageError struct {\n\tPos string\n\tErr string\n}\n\nfunc (p *listedPackage) obfuscatedImportPath() string {\n\t// We can't obfuscate these standard library import paths,\n\t// as the toolchain expects to recognize the packages by them:\n\t//\n\t//   * runtime: it is special in many ways\n\t//   * reflect: its presence turns down dead code elimination\n\t//   * embed: its presence enables using //go:embed\n\t//   * others like syscall are allowed by import path to have more ABI tricks\n\t//\n\t// TODO: collect directly from cmd/internal/objabi/pkgspecial.go,\n\t// in this particular case from allowAsmABIPkgs.\n\tswitch p.ImportPath {\n\tcase \"runtime\", \"reflect\", \"embed\", \"syscall\", \"runtime/internal/startlinetest\":\n\t\treturn p.ImportPath\n\t}\n\t// Intrinsics are matched by package import path as well.\n\tif _, ok := compilerIntrinsics[p.ImportPath]; ok {\n\t\treturn p.ImportPath\n\t}\n\tif !p.ToObfuscate {\n\t\treturn p.ImportPath\n\t}\n\tnewPath := hashWithPackage(p, p.ImportPath)\n\tlog.Printf(\"import path %q hashed with %x to %q\", p.ImportPath, p.GarbleActionID, newPath)\n\treturn newPath\n}\n\n// garbleBuildFlags are always passed to top-level build commands such as\n// \"go build\", \"go list\", or \"go test\".\nvar garbleBuildFlags = []string{\"-trimpath\", \"-buildvcs=false\"}\n\n// appendListedPackages gets information about the current package\n// and all of its dependencies\nfunc appendListedPackages(packages []string, mainBuild bool) error {\n\tstartTime := time.Now()\n\targs := []string{\n\t\t\"list\",\n\t\t// Similar flags to what go/packages uses.\n\t\t\"-json\", \"-export\", \"-compiled\", \"-e\",\n\t}\n\tif mainBuild {\n\t\t// When loading the top-level packages we are building,\n\t\t// we want to transitively load all their dependencies as well.\n\t\t// That is not the case when loading standard library packages,\n\t\t// as runtimeLinknamed already contains transitive dependencies.\n\t\targs = append(args, \"-deps\")\n\t}\n\targs = append(args, garbleBuildFlags...)\n\targs = append(args, sharedCache.ForwardBuildFlags...)\n\n\tif !mainBuild {\n\t\t// If the top-level build included the -mod or -modfile flags,\n\t\t// they should be used when loading the top-level packages.\n\t\t// However, when loading standard library packages,\n\t\t// using those flags would likely result in an error,\n\t\t// as the standard library uses its own Go module and vendoring.\n\t\targs = slices.DeleteFunc(args, func(arg string) bool {\n\t\t\treturn strings.HasPrefix(arg, \"-mod=\") || strings.HasPrefix(arg, \"-modfile=\")\n\t\t})\n\t}\n\n\targs = append(args, packages...)\n\tcmd := exec.Command(\"go\", args...)\n\n\tdefer func() {\n\t\tlog.Printf(\"original build info obtained in %s via: go %s\", debugSince(startTime), strings.Join(args, \" \"))\n\t}()\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar stderr bytes.Buffer\n\tcmd.Stderr = &stderr\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn fmt.Errorf(\"go list error: %v\", err)\n\t}\n\n\tdec := json.NewDecoder(stdout)\n\tif sharedCache.ListedPackages == nil {\n\t\tsharedCache.ListedPackages = make(map[string]*listedPackage)\n\t}\n\tvar pkgErrors strings.Builder\n\tfor dec.More() {\n\t\tvar pkg listedPackage\n\t\tif err := dec.Decode(&pkg); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif perr := pkg.Error; perr != nil {\n\t\t\tif !mainBuild && strings.Contains(perr.Err, \"build constraints exclude all Go files\") {\n\t\t\t\t// Some packages in runtimeLinknamed need a build tag to be importable,\n\t\t\t\t// like crypto/internal/boring/fipstls with boringcrypto,\n\t\t\t\t// so any pkg.Error should be ignored when the build tag isn't set.\n\t\t\t} else if !mainBuild && strings.Contains(perr.Err, \"is not in std\") {\n\t\t\t\t// When we support multiple Go versions at once, some packages may only\n\t\t\t\t// exist in the newer version, so we fail to list them with the older.\n\t\t\t} else {\n\t\t\t\tif pkgErrors.Len() > 0 {\n\t\t\t\t\tpkgErrors.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\tif perr.Pos != \"\" {\n\t\t\t\t\tpkgErrors.WriteString(perr.Pos)\n\t\t\t\t\tpkgErrors.WriteString(\": \")\n\t\t\t\t}\n\t\t\t\t// Error messages sometimes include a trailing newline.\n\t\t\t\tpkgErrors.WriteString(strings.TrimRight(perr.Err, \"\\n\"))\n\t\t\t}\n\t\t}\n\n\t\t// Note that we use the `-e` flag above with `go list`.\n\t\t// If a package fails to load, the Incomplete and Error fields will be set.\n\t\t// We still record failed packages in the ListedPackages map,\n\t\t// because some like crypto/internal/boring/fipstls simply fall under\n\t\t// \"build constraints exclude all Go files\" and can be ignored.\n\t\t// Real build errors will still be surfaced by `go build -toolexec` later.\n\t\tif sharedCache.ListedPackages[pkg.ImportPath] != nil {\n\t\t\treturn fmt.Errorf(\"duplicate package: %q\", pkg.ImportPath)\n\t\t}\n\t\tif pkg.BuildID != \"\" {\n\t\t\tactionID := decodeBuildIDHash(splitActionID(pkg.BuildID))\n\t\t\tpkg.GarbleActionID = addGarbleToHash(actionID)\n\t\t}\n\n\t\tsharedCache.ListedPackages[pkg.ImportPath] = &pkg\n\t}\n\n\tif err := cmd.Wait(); err != nil {\n\t\treturn fmt.Errorf(\"go list error: %v:\\nargs: %q\\n%s\", err, args, stderr.Bytes())\n\t}\n\tif pkgErrors.Len() > 0 {\n\t\treturn errors.New(pkgErrors.String())\n\t}\n\n\tanyToObfuscate := false\n\tfor path, pkg := range sharedCache.ListedPackages {\n\t\t// If \"GOGARBLE=foo/bar\", \"foo/bar_test\" should also match.\n\t\tif pkg.ForTest != \"\" {\n\t\t\tpath = pkg.ForTest\n\t\t}\n\t\tswitch {\n\t\t// We do not support obfuscating the runtime nor its dependencies.\n\t\tcase runtimeAndDeps[path],\n\t\t\t// \"unknown pc\" crashes on windows in the cgo test otherwise.\n\t\t\tpath == \"runtime/cgo\":\n\n\t\t// No point in obfuscating empty packages, like OS-specific ones that don't match.\n\t\tcase len(pkg.CompiledGoFiles) == 0:\n\n\t\t// Test main packages like \"foo/bar.test\" are always obfuscated,\n\t\t// just like unnamed and plugin main packages.\n\t\tcase pkg.Name == \"main\" && strings.HasSuffix(path, \".test\"),\n\t\t\tpath == \"command-line-arguments\",\n\t\t\tstrings.HasPrefix(path, \"plugin/unnamed\"),\n\t\t\tmodule.MatchPrefixPatterns(sharedCache.GOGARBLE, path):\n\n\t\t\tpkg.ToObfuscate = true\n\t\t\tanyToObfuscate = true\n\t\t\tif len(pkg.GarbleActionID) == 0 {\n\t\t\t\treturn fmt.Errorf(\"package %q to be obfuscated lacks build id?\", pkg.ImportPath)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Don't error if the user ran: GOGARBLE='*' garble build runtime\n\tif !anyToObfuscate && !module.MatchPrefixPatterns(sharedCache.GOGARBLE, \"runtime\") {\n\t\treturn fmt.Errorf(\"GOGARBLE=%q does not match any packages to be built\", sharedCache.GOGARBLE)\n\t}\n\n\treturn nil\n}\n\nvar listedRuntimeLinknamed = false\n\nvar ErrNotFound = errors.New(\"not found\")\n\nvar ErrNotDependency = errors.New(\"not a dependency\")\n\n// listPackage gets the listedPackage information for a certain package\nfunc listPackage(from *listedPackage, path string) (*listedPackage, error) {\n\tif path == from.ImportPath {\n\t\treturn from, nil\n\t}\n\n\t// If the path is listed in the top-level ImportMap, use its mapping instead.\n\t// This is a common scenario when dealing with vendored packages in GOROOT.\n\t// The map is flat, so we don't need to recurse.\n\tif path2 := from.ImportMap[path]; path2 != \"\" {\n\t\tpath = path2\n\t}\n\n\tpkg, ok := sharedCache.ListedPackages[path]\n\n\t// A std package may list any other package in std, even those it doesn't depend on.\n\t// This is due to how runtime linkname-implements std packages,\n\t// such as sync/atomic or reflect, without importing them in any way.\n\t// A few other cases don't involve runtime, like time/tzdata linknaming to time,\n\t// but luckily those few cases are covered by runtimeLinknamed as well.\n\t//\n\t// If ListedPackages lacks such a package we fill it via runtimeLinknamed.\n\t// TODO: can we instead add runtimeLinknamed to the top-level \"go list\" args?\n\tif from.Standard {\n\t\tif ok {\n\t\t\treturn pkg, nil\n\t\t}\n\t\tif listedRuntimeLinknamed {\n\t\t\treturn nil, fmt.Errorf(\"package %q still missing after go list call\", path)\n\t\t}\n\t\tstartTime := time.Now()\n\t\tmissing := make([]string, 0, len(runtimeLinknamed))\n\t\tfor _, linknamed := range runtimeLinknamed {\n\t\t\tswitch {\n\t\t\tcase sharedCache.ListedPackages[linknamed] != nil:\n\t\t\t\t// We already have it; skip.\n\t\t\tcase sharedCache.GoEnv.GOOS != \"js\" && linknamed == \"syscall/js\":\n\t\t\t\t// GOOS-specific package.\n\t\t\tcase sharedCache.GoEnv.GOOS != \"darwin\" && sharedCache.GoEnv.GOOS != \"ios\" && linknamed == \"crypto/x509/internal/macos\":\n\t\t\t\t// GOOS-specific package.\n\t\t\tdefault:\n\t\t\t\tmissing = append(missing, linknamed)\n\t\t\t}\n\t\t}\n\t\t// We don't need any information about their dependencies, in this case.\n\t\tif err := appendListedPackages(missing, false); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to load missing runtime-linknamed packages: %v\", err)\n\t\t}\n\t\tpkg, ok := sharedCache.ListedPackages[path]\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"std listed another std package that we can't find: %s\", path)\n\t\t}\n\t\tlistedRuntimeLinknamed = true\n\t\tlog.Printf(\"listed %d missing runtime-linknamed packages in %s\", len(missing), debugSince(startTime))\n\t\treturn pkg, nil\n\t}\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"list %s: %w\", path, ErrNotFound)\n\t}\n\n\t// Packages outside std can list any package,\n\t// as long as they depend on it directly or indirectly.\n\tif from.hasDep(pkg.ImportPath) {\n\t\treturn pkg, nil\n\t}\n\n\t// As a special case, any package can list runtime or its dependencies,\n\t// since those are always an implicit dependency.\n\t// We need to handle this ourselves as runtime does not appear in Deps.\n\t// TODO: it might be faster to bring back a \"runtimeAndDeps\" map or func.\n\tif pkg.ImportPath == \"runtime\" {\n\t\treturn pkg, nil\n\t}\n\tif sharedCache.ListedPackages[\"runtime\"].hasDep(pkg.ImportPath) {\n\t\treturn pkg, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"list %s: %w\", path, ErrNotDependency)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}