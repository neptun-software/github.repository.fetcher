{
  "metadata": {
    "timestamp": 1736566900177,
    "page": 470,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "goccy/go-json",
      "stars": 3181,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.4599609375,
          "content": "codecov:\n  require_ci_to_pass: yes\n\ncoverage:\n  precision: 2\n  round: down\n  range: \"70...100\"\n\n  status:\n    project:\n      default:\n        target: 70%\n        threshold: 2%\n    patch: off\n    changes: no\n\nparsers:\n  gcov:\n    branch_detection:\n      conditional: yes\n      loop: yes\n      method: no\n      macro: no\n\ncomment:\n  layout: \"header,diff\"\n  behavior: default\n  require_changes: no\n\nignore:\n  - internal/encoder/vm_color\n  - internal/encoder/vm_color_indent\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0205078125,
          "content": "cover.html\ncover.out\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.4609375,
          "content": "run:\n  skip-files:\n    - encode_optype.go\n    - \".*_test\\\\.go$\"\n\nlinters-settings:\n  govet:\n    enable-all: true\n    disable:\n      - shadow\n\nlinters:\n  enable-all: true\n  disable:\n    - dogsled\n    - dupl\n    - exhaustive\n    - exhaustivestruct\n    - errorlint\n    - forbidigo\n    - funlen\n    - gci\n    - gochecknoglobals\n    - gochecknoinits\n    - gocognit\n    - gocritic\n    - gocyclo\n    - godot\n    - godox\n    - goerr113\n    - gofumpt\n    - gomnd\n    - gosec\n    - ifshort\n    - lll\n    - makezero\n    - nakedret\n    - nestif\n    - nlreturn\n    - paralleltest\n    - testpackage\n    - thelper\n    - wrapcheck\n    - interfacer\n    - lll\n    - nakedret\n    - nestif\n    - nlreturn\n    - testpackage\n    - wsl\n    - varnamelen\n    - nilnil\n    - ireturn\n    - govet\n    - forcetypeassert\n    - cyclop\n    - containedctx\n    - revive\n    - nosnakecase\n    - exhaustruct\n    - depguard\n\nissues:\n  exclude-rules:\n    # not needed\n    - path: /*.go\n      text: \"ST1003: should not use underscores in package names\"\n      linters:\n        - stylecheck\n    - path: /*.go\n      text: \"don't use an underscore in package name\"\n      linters:\n        - golint\n    - path: rtype.go\n      linters:\n        - golint\n        - stylecheck\n    - path: error.go\n      linters:\n        - staticcheck\n\n  # Maximum issues count per one linter. Set to 0 to disable. Default is 50.\n  max-issues-per-linter: 0\n\n  # Maximum count of issues with the same text. Set to 0 to disable. Default is 3.\n  max-same-issues: 0\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 11.328125,
          "content": "# v0.10.2 - 2023/03/20\n\n### New features\n\n* Support DebugDOT option for debugging encoder ( #440 )\n\n### Fix bugs\n\n* Fix combination of embedding structure and omitempty option ( #442 )\n\n# v0.10.1 - 2023/03/13\n\n### Fix bugs\n\n* Fix checkptr error for array decoder ( #415 )\n* Fix added buffer size check when decoding key ( #430 )\n* Fix handling of anonymous fields other than struct ( #431 )\n* Fix to not optimize when lower conversion can't handle byte-by-byte ( #432 )\n* Fix a problem that MarshalIndent does not work when UnorderedMap is specified ( #435 )\n* Fix mapDecoder.DecodeStream() for empty objects containing whitespace ( #425 )\n* Fix an issue that could not set the correct NextField for fields in the embedded structure ( #438 )\n\n# v0.10.0 - 2022/11/29\n\n### New features\n\n* Support JSON Path ( #250 )\n\n### Fix bugs\n\n* Fix marshaler for map's key ( #409 )\n\n# v0.9.11 - 2022/08/18\n\n### Fix bugs\n\n* Fix unexpected behavior when buffer ends with backslash ( #383 )\n* Fix stream decoding of escaped character ( #387 )\n\n# v0.9.10 - 2022/07/15\n\n### Fix bugs\n\n* Fix boundary exception of type caching ( #382 )\n\n# v0.9.9 - 2022/07/15\n\n### Fix bugs\n\n* Fix encoding of directed interface with typed nil ( #377 )\n* Fix embedded primitive type encoding using alias ( #378 )\n* Fix slice/array type encoding with types implementing MarshalJSON ( #379 )\n* Fix unicode decoding when the expected buffer state is not met after reading ( #380 )\n\n# v0.9.8 - 2022/06/30\n\n### Fix bugs\n\n* Fix decoding of surrogate-pair ( #365 )\n* Fix handling of embedded primitive type ( #366 )\n* Add validation of escape sequence for decoder ( #367 )\n* Fix stream tokenizing respecting UseNumber ( #369 )\n* Fix encoding when struct pointer type that implements Marshal JSON is embedded ( #375 )\n\n### Improve performance\n\n* Improve performance of linkRecursiveCode ( #368 )\n\n# v0.9.7 - 2022/04/22\n\n### Fix bugs\n\n#### Encoder\n\n* Add filtering process for encoding on slow path ( #355 )\n* Fix encoding of interface{} with pointer type ( #363 )\n\n#### Decoder\n\n* Fix map key decoder that implements UnmarshalJSON ( #353 )\n* Fix decoding of []uint8 type ( #361 )\n\n### New features\n\n* Add DebugWith option for encoder ( #356 )\n\n# v0.9.6 - 2022/03/22\n\n### Fix bugs\n\n* Correct the handling of the minimum value of int type for decoder ( #344 )\n* Fix bugs of stream decoder's bufferSize ( #349 )\n* Add a guard to use typeptr more safely ( #351 )\n\n### Improve decoder performance\n\n* Improve escapeString's performance ( #345 )\n\n### Others\n\n* Update go version for CI ( #347 )\n\n# v0.9.5 - 2022/03/04\n\n### Fix bugs\n\n* Fix panic when decoding time.Time with context ( #328 )\n* Fix reading the next character in buffer to nul consideration ( #338 )\n* Fix incorrect handling on skipValue ( #341 )\n\n### Improve decoder performance\n\n* Improve performance when a payload contains escape sequence ( #334 )\n\n# v0.9.4 - 2022/01/21\n\n* Fix IsNilForMarshaler for string type with omitempty ( #323 )\n* Fix the case where the embedded field is at the end ( #326 )\n\n# v0.9.3 - 2022/01/14\n\n* Fix logic of removing struct field for decoder ( #322 )\n\n# v0.9.2 - 2022/01/14\n\n* Add invalid decoder to delay type error judgment at decode ( #321 )\n\n# v0.9.1 - 2022/01/11\n\n* Fix encoding of MarshalText/MarshalJSON operation with head offset ( #319 )\n\n# v0.9.0 - 2022/01/05\n\n### New feature\n\n* Supports dynamic filtering of struct fields ( #314 )\n\n### Improve encoding performance\n\n* Improve map encoding performance ( #310 )\n* Optimize encoding path for escaped string ( #311 )\n* Add encoding option for performance ( #312 )\n\n### Fix bugs\n\n* Fix panic at encoding map value on 1.18 ( #310 )\n* Fix MarshalIndent for interface type ( #317 )\n\n# v0.8.1 - 2021/12/05\n\n* Fix operation conversion from PtrHead to Head in Recursive type ( #305 )\n\n# v0.8.0 - 2021/12/02\n\n* Fix embedded field conflict behavior ( #300 )\n* Refactor compiler for encoder ( #301 #302 )\n\n# v0.7.10 - 2021/10/16\n\n* Fix conversion from pointer to uint64  ( #294 )\n\n# v0.7.9 - 2021/09/28\n\n* Fix encoding of nil value about interface type that has method ( #291 )\n\n# v0.7.8 - 2021/09/01\n\n* Fix mapassign_faststr for indirect struct type ( #283 )\n* Fix encoding of not empty interface type ( #284 )\n* Fix encoding of empty struct interface type ( #286 )\n\n# v0.7.7 - 2021/08/25\n\n* Fix invalid utf8 on stream decoder ( #279 )\n* Fix buffer length bug on string stream decoder ( #280 )\n\nThank you @orisano !!\n\n# v0.7.6 - 2021/08/13\n\n* Fix nil slice assignment ( #276 )\n* Improve error message ( #277 )\n\n# v0.7.5 - 2021/08/12\n\n* Fix encoding of embedded struct with tags ( #265 )\n* Fix encoding of embedded struct that isn't first field ( #272 )\n* Fix decoding of binary type with escaped char ( #273 )\n\n# v0.7.4 - 2021/07/06\n\n* Fix encoding of indirect layout structure ( #264 )\n\n# v0.7.3 - 2021/06/29\n\n* Fix encoding of pointer type in empty interface ( #262 )\n\n# v0.7.2 - 2021/06/26\n\n### Fix decoder\n\n* Add decoder for func type to fix decoding of nil function value ( #257 )\n* Fix stream decoding of []byte type ( #258 )\n\n### Performance\n\n* Improve decoding performance of map[string]interface{} type ( use `mapassign_faststr` ) ( #256 )\n* Improve encoding performance of empty interface type ( remove recursive calling of `vm.Run` ) ( #259 )\n\n### Benchmark\n\n* Add bytedance/sonic as benchmark target ( #254 )\n\n# v0.7.1 - 2021/06/18\n\n### Fix decoder\n\n* Fix error when unmarshal empty array ( #253 )\n\n# v0.7.0 - 2021/06/12\n\n### Support context for MarshalJSON and UnmarshalJSON ( #248 )\n\n* json.MarshalContext(context.Context, interface{}, ...json.EncodeOption) ([]byte, error)\n* json.NewEncoder(io.Writer).EncodeContext(context.Context, interface{}, ...json.EncodeOption) error\n* json.UnmarshalContext(context.Context, []byte, interface{}, ...json.DecodeOption) error\n* json.NewDecoder(io.Reader).DecodeContext(context.Context, interface{}) error\n\n```go\ntype MarshalerContext interface {\n  MarshalJSON(context.Context) ([]byte, error)\n}\n\ntype UnmarshalerContext interface {\n  UnmarshalJSON(context.Context, []byte) error\n}\n```\n\n### Add DecodeFieldPriorityFirstWin option ( #242 )\n\nIn the default behavior, go-json, like encoding/json, will reflect the result of the last evaluation when a field with the same name exists. I've added new options to allow you to change this behavior. `json.DecodeFieldPriorityFirstWin` option reflects the result of the first evaluation if a field with the same name exists. This behavior has a performance advantage as it allows the subsequent strings to be skipped if all fields have been evaluated.\n\n### Fix encoder\n\n* Fix indent number contains recursive type ( #249 )\n* Fix encoding of using empty interface as map key ( #244 )\n\n### Fix decoder\n\n* Fix decoding fields containing escaped characters ( #237 )\n\n### Refactor\n\n* Move some tests to subdirectory ( #243 )\n* Refactor package layout for decoder ( #238 )\n\n# v0.6.1 - 2021/06/02\n\n### Fix encoder\n\n* Fix value of totalLength for encoding ( #236 )\n\n# v0.6.0 - 2021/06/01\n\n### Support Colorize option for encoding (#233)\n\n```go\nb, err := json.MarshalWithOption(v, json.Colorize(json.DefaultColorScheme))\nif err != nil {\n  ...\n}\nfmt.Println(string(b)) // print colored json\n```\n\n### Refactor\n\n* Fix opcode layout - Adjust memory layout of the opcode to 128 bytes in a 64-bit environment ( #230 )\n* Refactor encode option ( #231 )\n* Refactor escape string ( #232 )\n\n# v0.5.1 - 2021/5/20\n\n### Optimization\n\n* Add type addrShift to enable bigger encoder/decoder cache ( #213 )\n\n### Fix decoder\n\n* Keep original reference of slice element ( #229 )\n\n### Refactor\n\n* Refactor Debug mode for encoding ( #226 )\n* Generate VM sources for encoding ( #227 )\n* Refactor validator for null/true/false for decoding ( #221 )\n\n# v0.5.0 - 2021/5/9\n\n### Supports using omitempty and string tags at the same time ( #216 )\n\n### Fix decoder\n\n* Fix stream decoder for unicode char ( #215 )\n* Fix decoding of slice element ( #219 )\n* Fix calculating of buffer length for stream decoder ( #220 )\n\n### Refactor\n\n* replace skipWhiteSpace goto by loop ( #212 )\n\n# v0.4.14 - 2021/5/4\n\n### Benchmark\n\n* Add valyala/fastjson to benchmark ( #193 )\n* Add benchmark task for CI ( #211 )\n\n### Fix decoder\n\n* Fix decoding of slice with unmarshal json type ( #198 )\n* Fix decoding of null value for interface type that does not implement Unmarshaler ( #205 )\n* Fix decoding of null value to []byte by json.Unmarshal ( #206 )\n* Fix decoding of backslash char at the end of string ( #207 )\n* Fix stream decoder for null/true/false value ( #208 )\n* Fix stream decoder for slow reader ( #211 )\n\n### Performance\n\n* If cap of slice is enough, reuse slice data for compatibility with encoding/json ( #200 )\n\n# v0.4.13 - 2021/4/20\n\n### Fix json.Compact and json.Indent\n\n* Support validation the input buffer for json.Compact and json.Indent ( #189 )\n* Optimize json.Compact and json.Indent ( improve memory footprint ) ( #190 )\n\n# v0.4.12 - 2021/4/15\n\n### Fix encoder\n\n* Fix unnecessary indent for empty slice type ( #181 )\n* Fix encoding of omitempty feature for the slice or interface type ( #183 )\n* Fix encoding custom types zero values with omitempty when marshaller exists ( #187 )\n\n### Fix decoder\n\n* Fix decoder for invalid top level value ( #184 )\n* Fix decoder for invalid number value ( #185 )\n\n# v0.4.11 - 2021/4/3\n\n* Improve decoder performance for interface type\n\n# v0.4.10 - 2021/4/2\n\n### Fix encoder\n\n* Fixed a bug when encoding slice and map containing recursive structures\n* Fixed a logic to determine if indirect reference\n\n# v0.4.9 - 2021/3/29\n\n### Add debug mode\n\nIf you use `json.MarshalWithOption(v, json.Debug())` and `panic` occurred in `go-json`, produces debug information to console.\n\n### Support a new feature to compatible with encoding/json\n\n- invalid UTF-8 is coerced to valid UTF-8 ( without performance down )\n\n### Fix encoder\n\n- Fixed handling of MarshalJSON of function type\n\n### Fix decoding of slice of pointer type\n\nIf there is a pointer value, go-json will use it. (This behavior is necessary to achieve the ability to prioritize pre-filled values). However, since slices are reused internally, there was a bug that referred to the previous pointer value. Therefore, it is not necessary to refer to the pointer value in advance for the slice element, so we explicitly initialize slice element by `nil`.\n\n# v0.4.8 - 2021/3/21\n\n### Reduce memory usage at compile time\n\n* go-json have used about 2GB of memory at compile time, but now it can compile with about less than 550MB.\n\n### Fix any encoder's bug\n\n* Add many test cases for encoder\n* Fix composite type ( slice/array/map )\n* Fix pointer types\n* Fix encoding of MarshalJSON or MarshalText or json.Number type\n\n### Refactor encoder\n\n* Change package layout for reducing memory usage at compile\n* Remove anonymous and only operation\n* Remove root property from encodeCompileContext and opcode\n\n### Fix CI\n\n* Add Go 1.16\n* Remove Go 1.13\n* Fix `make cover` task\n\n### Number/Delim/Token/RawMessage use the types defined in encoding/json by type alias\n\n# v0.4.7 - 2021/02/22\n\n### Fix decoder\n\n* Fix decoding of deep recursive structure\n* Fix decoding of embedded unexported pointer field\n* Fix invalid test case\n* Fix decoding of invalid value\n* Fix decoding of prefilled value\n* Fix not being able to return UnmarshalTypeError when it should be returned\n* Fix decoding of null value\n* Fix decoding of type of null string\n* Use pre allocated pointer if exists it at decoding\n\n### Reduce memory usage at compile\n\n* Integrate int/int8/int16/int32/int64 and uint/uint8/uint16/uint32/uint64 operation to reduce memory usage at compile\n\n### Remove unnecessary optype\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2020 Masaaki Goshima\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.85546875,
          "content": "PKG := github.com/goccy/go-json\n\nBIN_DIR := $(CURDIR)/bin\nPKGS := $(shell go list ./... | grep -v internal/cmd|grep -v test)\nCOVER_PKGS := $(foreach pkg,$(PKGS),$(subst $(PKG),.,$(pkg)))\n\nCOMMA := ,\nEMPTY :=\nSPACE := $(EMPTY) $(EMPTY)\nCOVERPKG_OPT := $(subst $(SPACE),$(COMMA),$(COVER_PKGS))\n\n$(BIN_DIR):\n\t@mkdir -p $(BIN_DIR)\n\n.PHONY: cover\ncover:\n\tgo test -coverpkg=$(COVERPKG_OPT) -coverprofile=cover.out ./...\n\n.PHONY: cover-html\ncover-html: cover\n\tgo tool cover -html=cover.out\n\n.PHONY: lint\nlint: golangci-lint\n\t$(BIN_DIR)/golangci-lint run\n\ngolangci-lint: | $(BIN_DIR)\n\t@{ \\\n\t\tset -e; \\\n\t\tGOLANGCI_LINT_TMP_DIR=$$(mktemp -d); \\\n\t\tcd $$GOLANGCI_LINT_TMP_DIR; \\\n\t\tgo mod init tmp; \\\n\t\tGOBIN=$(BIN_DIR) go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.54.2; \\\n\t\trm -rf $$GOLANGCI_LINT_TMP_DIR; \\\n\t}\n\n.PHONY: generate\ngenerate:\n\tgo generate ./internal/...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.787109375,
          "content": "# go-json\n\n![Go](https://github.com/goccy/go-json/workflows/Go/badge.svg)\n[![GoDoc](https://godoc.org/github.com/goccy/go-json?status.svg)](https://pkg.go.dev/github.com/goccy/go-json?tab=doc)\n[![codecov](https://codecov.io/gh/goccy/go-json/branch/master/graph/badge.svg)](https://codecov.io/gh/goccy/go-json)\n\nFast JSON encoder/decoder compatible with encoding/json for Go\n\n<img width=\"400px\" src=\"https://user-images.githubusercontent.com/209884/92572337-42b42900-f2bf-11ea-973a-c74a359553a5.png\"></img>\n\n# Roadmap\n\n```\n* version ( expected release date )\n\n* v0.9.0\n |\n | while maintaining compatibility with encoding/json, we will add convenient APIs\n |\n v\n* v1.0.0\n```\n\nWe are accepting requests for features that will be implemented between v0.9.0 and v.1.0.0.\nIf you have the API you need, please submit your issue [here](https://github.com/goccy/go-json/issues).\n\n# Features\n\n- Drop-in replacement of `encoding/json`\n- Fast ( See [Benchmark section](https://github.com/goccy/go-json#benchmarks) )\n- Flexible customization with options\n- Coloring the encoded string\n- Can propagate context.Context to `MarshalJSON` or `UnmarshalJSON`\n- Can dynamically filter the fields of the structure type-safely\n\n# Installation\n\n```\ngo get github.com/goccy/go-json\n```\n\n# How to use\n\nReplace import statement from `encoding/json` to `github.com/goccy/go-json`\n\n```\n-import \"encoding/json\"\n+import \"github.com/goccy/go-json\"\n```\n\n# JSON library comparison\n\n|  name  |  encoder | decoder | compatible with `encoding/json` |\n| :----: | :------: | :-----: | :-----------------------------: |\n| encoding/json |  yes | yes | N/A |\n| [json-iterator/go](https://github.com/json-iterator/go) | yes | yes | partial |\n| [easyjson](https://github.com/mailru/easyjson) | yes | yes |  no |\n| [gojay](https://github.com/francoispqt/gojay) | yes | yes |  no |\n| [segmentio/encoding/json](https://github.com/segmentio/encoding/tree/master/json) | yes | yes | partial |\n| [jettison](https://github.com/wI2L/jettison) | yes | no | no |\n| [simdjson-go](https://github.com/minio/simdjson-go) | no | yes | no |\n| goccy/go-json | yes | yes | yes |\n\n- `json-iterator/go` isn't compatible with `encoding/json` in many ways (e.g. https://github.com/json-iterator/go/issues/229 ), but it hasn't been supported for a long time.\n- `segmentio/encoding/json` is well supported for encoders, but some are not supported for decoder APIs such as `Token` ( streaming decode )\n\n## Other libraries\n\n- [jingo](https://github.com/bet365/jingo)\n\nI tried the benchmark but it didn't work.\nAlso, it seems to panic when it receives an unexpected value because there is no error handling...\n\n- [ffjson](https://github.com/pquerna/ffjson)\n\nBenchmarking gave very slow results.\nIt seems that it is assumed that the user will use the buffer pool properly.\nAlso, development seems to have already stopped\n\n# Benchmarks\n\n```\n$ cd benchmarks\n$ go test -bench .\n```\n\n## Encode\n\n<img width=\"700px\" src=\"https://user-images.githubusercontent.com/209884/107126758-0845cb00-68f5-11eb-8db7-086fcf9bcfaa.png\"></img>\n<img width=\"700px\" src=\"https://user-images.githubusercontent.com/209884/107126757-07ad3480-68f5-11eb-87aa-858cc5eacfcb.png\"></img>\n\n## Decode\n\n<img width=\"700\" alt=\"\" src=\"https://user-images.githubusercontent.com/209884/107979944-bd1d6d80-7002-11eb-944b-9d17b6674e3f.png\">\n<img width=\"700\" alt=\"\" src=\"https://user-images.githubusercontent.com/209884/107979931-b989e680-7002-11eb-87a0-66fc22d90dd4.png\">\n<img width=\"700\" alt=\"\" src=\"https://user-images.githubusercontent.com/209884/107979940-bc84d700-7002-11eb-9647-869bbc25c9d9.png\">\n\n\n# Fuzzing\n\n[go-json-fuzz](https://github.com/goccy/go-json-fuzz) is the repository for fuzzing tests.\nIf you run the test in this repository and find a bug, please commit to corpus to go-json-fuzz and report the issue to [go-json](https://github.com/goccy/go-json/issues).\n\n# How it works\n\n`go-json` is very fast in both encoding and decoding compared to other libraries.\nIt's easier to implement by using automatic code generation for performance or by using a dedicated interface, but `go-json` dares to stick to compatibility with `encoding/json` and is the simple interface. Despite this, we are developing with the aim of being the fastest library.\n\nHere, we explain the various speed-up techniques implemented by `go-json`.\n\n## Basic technique\n\nThe techniques listed here are the ones used by most of the libraries listed above.\n\n### Buffer reuse\n\nSince the only value required for the result of `json.Marshal(interface{}) ([]byte, error)` is `[]byte`, the only value that must be allocated during encoding is the return value `[]byte` .\n\nAlso, as the number of allocations increases, the performance will be affected, so the number of allocations should be kept as low as possible when creating `[]byte`.\n\nTherefore, there is a technique to reduce the number of times a new buffer must be allocated by reusing the buffer used for the previous encoding by using `sync.Pool`.\n\nFinally, you allocate a buffer that is as long as the resulting buffer and copy the contents into it, you only need to allocate the buffer once in theory.\n\n```go\ntype buffer struct {\n    data []byte\n}\n\nvar bufPool = sync.Pool{\n    New: func() interface{} {\n        return &buffer{data: make([]byte, 0, 1024)}\n    },\n}\n\nbuf := bufPool.Get().(*buffer)\ndata := encode(buf.data) // reuse buf.data\n\nnewBuf := make([]byte, len(data))\ncopy(newBuf, buf)\n\nbuf.data = data\nbufPool.Put(buf)\n```\n\n### Elimination of reflection\n\nAs you know, the reflection operation is very slow.\n\nTherefore, using the fact that the address position where the type information is stored is fixed for each binary ( we call this `typeptr` ),\nwe can use the address in the type information to call a pre-built optimized process.\n\nFor example, you can get the address to the type information from `interface{}` as follows and you can use that information to call a process that does not have reflection.\n\nTo process without reflection, pass a pointer (`unsafe.Pointer`) to the value is stored.\n\n```go\n\ntype emptyInterface struct {\n    typ unsafe.Pointer\n    ptr unsafe.Pointer\n}\n\nvar typeToEncoder = map[uintptr]func(unsafe.Pointer)([]byte, error){}\n\nfunc Marshal(v interface{}) ([]byte, error) {\n    iface := (*emptyInterface)(unsafe.Pointer(&v)\n    typeptr := uintptr(iface.typ)\n    if enc, exists := typeToEncoder[typeptr]; exists {\n        return enc(iface.ptr)\n    }\n    ...\n}\n```\n\n※ In reality, `typeToEncoder` can be referenced by multiple goroutines, so exclusive control is required.\n\n## Unique speed-up technique\n\n## Encoder\n\n### Do not escape arguments of `Marshal`\n\n`json.Marshal` and `json.Unmarshal` receive `interface{}` value and they perform type determination dynamically to process.\nIn normal case, you need to use the `reflect` library to determine the type dynamically, but since `reflect.Type` is defined as `interface`, when you call the method of `reflect.Type`, The reflect's argument is escaped.\n\nTherefore, the arguments for `Marshal` and `Unmarshal` are always escaped to the heap.\nHowever, `go-json` can use the feature of `reflect.Type` while avoiding escaping.\n\n`reflect.Type` is defined as `interface`, but in reality `reflect.Type` is implemented only by the structure `rtype` defined in the `reflect` package.\nFor this reason, to date `reflect.Type` is the same as `*reflect.rtype`.\n\nTherefore, by directly handling `*reflect.rtype`, which is an implementation of `reflect.Type`, it is possible to avoid escaping because it changes from `interface` to using `struct`.\n\nThe technique for working with `*reflect.rtype` directly from `go-json` is implemented at [rtype.go](https://github.com/goccy/go-json/blob/master/internal/runtime/rtype.go)\n\nAlso, the same technique is cut out as a library ( https://github.com/goccy/go-reflect )\n\nInitially this feature was the default behavior of `go-json`.\nBut after careful testing, I found that I passed a large value to `json.Marshal()` and if the argument could not be assigned to the stack, it could not be properly escaped to the heap (a bug in the Go compiler).\n\nTherefore, this feature will be provided as an **optional** until this issue is resolved.\n\nTo use it, add `NoEscape` like `MarshalNoEscape()`\n\n### Encoding using opcode sequence\n\nI explained that you can use `typeptr` to call a pre-built process from type information.\n\nIn other libraries, this dedicated process is processed by making it an function calling like anonymous function, but function calls are inherently slow processes and should be avoided as much as possible.\n\nTherefore, `go-json` adopted the Instruction-based execution processing system, which is also used to implement virtual machines for programming language.\n\nIf it is the first type to encode, create the opcode ( instruction ) sequence required for encoding.\nFrom the second time onward, use `typeptr` to get the cached pre-built opcode sequence and encode it based on it. An example of the opcode sequence is shown below.\n\n```go\njson.Marshal(struct{\n    X int `json:\"x\"`\n    Y string `json:\"y\"`\n}{X: 1, Y: \"hello\"})\n```\n\nWhen encoding a structure like the one above, create a sequence of opcodes like this:\n\n```\n- opStructFieldHead ( `{` )\n- opStructFieldInt ( `\"x\": 1,` )\n- opStructFieldString ( `\"y\": \"hello\"` )\n- opStructEnd ( `}` )\n- opEnd\n```\n\n※ When processing each operation, write the letters on the right.\n\nIn addition, each opcode is managed by the following structure ( \nPseudo code ).\n\n```go\ntype opType int\nconst (\n    opStructFieldHead opType = iota\n    opStructFieldInt\n    opStructFieldStirng\n    opStructEnd\n    opEnd\n)\ntype opcode struct {\n    op opType\n    key []byte\n    next *opcode\n}\n```\n\nThe process of encoding using the opcode sequence is roughly implemented as follows.\n\n```go\nfunc encode(code *opcode, b []byte, p unsafe.Pointer) ([]byte, error) {\n    for {\n        switch code.op {\n        case opStructFieldHead:\n            b = append(b, '{')\n            code = code.next\n        case opStructFieldInt:\n            b = append(b, code.key...)\n            b = appendInt((*int)(unsafe.Pointer(uintptr(p)+code.offset)))\n            code = code.next\n        case opStructFieldString:\n            b = append(b, code.key...)\n            b = appendString((*string)(unsafe.Pointer(uintptr(p)+code.offset)))\n            code = code.next\n        case opStructEnd:\n            b = append(b, '}')\n            code = code.next\n        case opEnd:\n            goto END\n        }\n    }\nEND:\n    return b, nil\n}\n```\n\nIn this way, the huge `switch-case` is used to encode by manipulating the linked list opcodes to avoid unnecessary function calls.\n\n### Opcode sequence optimization\n\nOne of the advantages of encoding using the opcode sequence is the ease of optimization.\nThe opcode sequence mentioned above is actually converted into the following optimized operations and used.\n\n```\n- opStructFieldHeadInt ( `{\"x\": 1,` )\n- opStructEndString ( `\"y\": \"hello\"}` )\n- opEnd\n```\n\nIt has been reduced from 5 opcodes to 3 opcodes !\nReducing the number of opcodees means reducing the number of branches with `switch-case`.\nIn other words, the closer the number of operations is to 1, the faster the processing can be performed.\n\nIn `go-json`, optimization to reduce the number of opcodes itself like the above and it speeds up by preparing opcodes with optimized paths.\n\n### Change recursive call from CALL to JMP\n\nRecursive processing is required during encoding if the type is defined recursively as follows:\n\n```go\ntype T struct {\n    X int\n    U *U\n}\n\ntype U struct {\n    T *T\n}\n\nb, err := json.Marshal(&T{\n    X: 1,\n    U: &U{\n        T: &T{\n            X: 2,\n        },\n    },\n})\nfmt.Println(string(b)) // {\"X\":1,\"U\":{\"T\":{\"X\":2,\"U\":null}}}\n```\n\nIn `go-json`, recursive processing is processed by the operation type of ` opStructFieldRecursive`.\n\nIn this operation, after acquiring the opcode sequence used for recursive processing, the function is **not** called recursively as it is, but the necessary values ​​are saved by itself and implemented by moving to the next operation.\n\nThe technique of implementing recursive processing with the `JMP` operation while avoiding the `CALL` operation is a famous technique for implementing a high-speed virtual machine.\n\nFor more details, please refer to [the article](https://engineering.mercari.com/blog/entry/1599563768-081104c850) ( but Japanese only ).\n\n### Dispatch by typeptr from map to slice\n\nWhen retrieving the data cached from the type information by `typeptr`, we usually use map.\nMap requires exclusive control, so use `sync.Map` for a naive implementation.\n\nHowever, this is slow, so it's a good idea to use the `atomic` package for exclusive control as implemented by `segmentio/encoding/json` ( https://github.com/segmentio/encoding/blob/master/json/codec.go#L41-L55 ).\n\nThis implementation slows down the set instead of speeding up the get, but it works well because of the nature of the library, it encodes much more for the same type.\n\nHowever, as a result of profiling, I noticed that `runtime.mapaccess2` accounts for a significant percentage of the execution time. So I thought if I could change the lookup from map to slice.\n\nThere is an API named `typelinks` defined in the `runtime` package that the `reflect` package uses internally.\nThis allows you to get all the type information defined in the binary at runtime.\n\nThe fact that all type information can be acquired means that by constructing slices in advance with the acquired total number of type information, it is possible to look up with the value of `typeptr` without worrying about out-of-range access.\n\nHowever, if there is too much type information, it will use a lot of memory, so by default we will only use this optimization if the slice size fits within **2Mib** .\n\nIf this approach is not available, it will fall back to the `atomic` based process described above.\n\nIf you want to know more, please refer to the implementation [here](https://github.com/goccy/go-json/blob/master/internal/runtime/type.go#L36-L100)\n\n## Decoder\n\n### Dispatch by typeptr from map to slice\n\nLike the encoder, the decoder also uses typeptr to call the dedicated process.\n\n### Faster termination character inspection using NUL character\n\nIn order to decode, you have to traverse the input buffer character by position.\nAt that time, if you check whether the buffer has reached the end, it will be very slow.\n\n`buf` : `[]byte` type variable. holds the string passed to the decoder\n`cursor` : `int64` type variable. holds the current read position\n\n```go\nbuflen := len(buf)\nfor ; cursor < buflen; cursor++ { // compare cursor and buflen at all times, it is so slow.\n    switch buf[cursor] {\n    case ' ', '\\n', '\\r', '\\t':\n    }\n}\n```\n\nTherefore, by adding the `NUL` (`\\000`) character to the end of the read buffer as shown below, it is possible to check the termination character at the same time as other characters.\n\n```go\nfor {\n    switch buf[cursor] {\n    case ' ', '\\n', '\\r', '\\t':\n    case '\\000':\n        return nil\n    }\n    cursor++\n}\n```\n\n### Use Boundary Check Elimination\n\nDue to the `NUL` character optimization, the Go compiler does a boundary check every time, even though `buf[cursor]` does not cause out-of-range access.\n\nTherefore, `go-json` eliminates boundary check by fetching characters for hotspot by pointer operation. For example, the following code.\n\n```go\nfunc char(ptr unsafe.Pointer, offset int64) byte {\n\treturn *(*byte)(unsafe.Pointer(uintptr(ptr) + uintptr(offset)))\n}\n\np := (*sliceHeader)(&unsafe.Pointer(buf)).data\nfor {\n    switch char(p, cursor) {\n    case ' ', '\\n', '\\r', '\\t':\n    case '\\000':\n        return nil\n    }\n    cursor++\n}\n```\n\n### Checking the existence of fields of struct using Bitmaps\n\nI found by the profiling result, in the struct decode, lookup process for field was taking a long time.\n\nFor example, consider decoding a string like `{\"a\":1,\"b\":2,\"c\":3}` into the following structure:\n\n```go\ntype T struct {\n    A int `json:\"a\"`\n    B int `json:\"b\"`\n    C int `json:\"c\"`\n}\n```\n\nAt this time, it was found that it takes a lot of time to acquire the decoding process corresponding to the field from the field name as shown below during the decoding process.\n\n```go\nfieldName := decodeKey(buf, cursor) // \"a\" or \"b\" or \"c\"\ndecoder, exists := fieldToDecoderMap[fieldName] // so slow\nif exists {\n    decoder(buf, cursor)\n} else {\n    skipValue(buf, cursor)\n}\n```\n\nTo improve this process, `json-iterator/go` is optimized so that it can be branched by switch-case when the number of fields in the structure is 10 or less (switch-case is faster than map). However, there is a risk of hash collision because the value hashed by the FNV algorithm is used for conditional branching. Also, `gojay` processes this part at high speed by letting the library user yourself write `switch-case`.\n\n\n`go-json` considers and implements a new approach that is different from these. I call this **bitmap field optimization**.\n\nThe range of values ​​per character can be represented by `[256]byte`. Also, if the number of fields in the structure is 8 or less, `int8` type can represent the state of each field.\nIn other words, it has the following structure.\n\n- Base ( 8bit ): `00000000`\n- Key \"a\": `00000001` ( assign key \"a\" to the first bit )\n- Key \"b\": `00000010` ( assign key \"b\" to the second bit )\n- Key \"c\": `00000100` ( assign key \"c\" to the third bit )\n\nBitmap structure is the following\n\n```\n        | key index(0) |\n------------------------\n 0      | 00000000     |\n 1      | 00000000     |\n~~      |              |\n97 (a)  | 00000001     |\n98 (b)  | 00000010     |\n99 (c)  | 00000100     |\n~~      |              |\n255     | 00000000     |\n```\n\nYou can think of this as a Bitmap with a height of `256` and a width of the maximum string length in the field name.\nIn other words, it can be represented by the following type .\n\n```go\n[maxFieldKeyLength][256]int8\n```\n\nWhen decoding a field character, check whether the corresponding character exists by referring to the pre-built bitmap like the following.\n\n```go\nvar curBit int8 = math.MaxInt8 // 11111111\n\nc := char(buf, cursor)\nbit := bitmap[keyIdx][c]\ncurBit &= bit\nif curBit == 0 {\n    // not found field\n}\n```\n\nIf `curBit` is not `0` until the end of the field string, then the string is\nYou may have hit one of the fields.\nBut the possibility is that if the decoded string is shorter than the field string, you will get a false hit.\n\n- input: `{\"a\":1}`\n```go\ntype T struct {\n    X int `json:\"abc\"`\n}\n```\n※ Since `a` is shorter than `abc`, it can decode to the end of the field character without `curBit` being 0.\n\nRest assured. In this case, it doesn't matter because you can tell if you hit by comparing the string length of `a` with the string length of `abc`.\n\nFinally, calculate the position of the bit where `1` is set and get the corresponding value, and you're done.\n\nUsing this technique, field lookups are possible with only bitwise operations and access to slices.\n\n`go-json` uses a similar technique for fields with 9 or more and 16 or less fields. At this time, Bitmap is constructed as `[maxKeyLen][256]int16` type.\n\nCurrently, this optimization is not performed when the maximum length of the field name is long (specifically, 64 bytes or more) in addition to the limitation of the number of fields from the viewpoint of saving memory usage.\n\n### Others\n\nI have done a lot of other optimizations. I will find time to write about them. If you have any questions about what's written here or other optimizations, please visit the `#go-json` channel on `gophers.slack.com` .\n\n## Reference\n\nRegarding the story of go-json, there are the following articles in Japanese only.\n\n- https://speakerdeck.com/goccy/zui-su-falsejsonraiburariwoqiu-mete\n- https://engineering.mercari.com/blog/entry/1599563768-081104c850/\n\n# Looking for Sponsors\n\nI'm looking for sponsors this library. This library is being developed as a personal project in my spare time. If you want a quick response or problem resolution when using this library in your project, please register as a [sponsor](https://github.com/sponsors/goccy). I will cooperate as much as possible. Of course, this library is developed as an MIT license, so you can use it freely for free.\n\n# License\n\nMIT\n"
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "color.go",
          "type": "blob",
          "size": 1.2421875,
          "content": "package json\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/goccy/go-json/internal/encoder\"\n)\n\ntype (\n\tColorFormat = encoder.ColorFormat\n\tColorScheme = encoder.ColorScheme\n)\n\nconst escape = \"\\x1b\"\n\ntype colorAttr int\n\n//nolint:deadcode,varcheck\nconst (\n\tfgBlackColor colorAttr = iota + 30\n\tfgRedColor\n\tfgGreenColor\n\tfgYellowColor\n\tfgBlueColor\n\tfgMagentaColor\n\tfgCyanColor\n\tfgWhiteColor\n)\n\n//nolint:deadcode,varcheck\nconst (\n\tfgHiBlackColor colorAttr = iota + 90\n\tfgHiRedColor\n\tfgHiGreenColor\n\tfgHiYellowColor\n\tfgHiBlueColor\n\tfgHiMagentaColor\n\tfgHiCyanColor\n\tfgHiWhiteColor\n)\n\nfunc createColorFormat(attr colorAttr) ColorFormat {\n\treturn ColorFormat{\n\t\tHeader: wrapColor(attr),\n\t\tFooter: resetColor(),\n\t}\n}\n\nfunc wrapColor(attr colorAttr) string {\n\treturn fmt.Sprintf(\"%s[%dm\", escape, attr)\n}\n\nfunc resetColor() string {\n\treturn wrapColor(colorAttr(0))\n}\n\nvar (\n\tDefaultColorScheme = &ColorScheme{\n\t\tInt:       createColorFormat(fgHiMagentaColor),\n\t\tUint:      createColorFormat(fgHiMagentaColor),\n\t\tFloat:     createColorFormat(fgHiMagentaColor),\n\t\tBool:      createColorFormat(fgHiYellowColor),\n\t\tString:    createColorFormat(fgHiGreenColor),\n\t\tBinary:    createColorFormat(fgHiRedColor),\n\t\tObjectKey: createColorFormat(fgHiCyanColor),\n\t\tNull:      createColorFormat(fgBlueColor),\n\t}\n)\n"
        },
        {
          "name": "color_test.go",
          "type": "blob",
          "size": 0.822265625,
          "content": "package json_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\nfunc TestColorize(t *testing.T) {\n\tv := struct {\n\t\tA int\n\t\tB uint\n\t\tC float32\n\t\tD string\n\t\tE bool\n\t\tF []byte\n\t\tG []int\n\t\tH *struct{}\n\t\tI map[string]interface{}\n\t}{\n\t\tA: 123,\n\t\tB: 456,\n\t\tC: 3.14,\n\t\tD: \"hello\",\n\t\tE: true,\n\t\tF: []byte(\"binary\"),\n\t\tG: []int{1, 2, 3, 4},\n\t\tH: nil,\n\t\tI: map[string]interface{}{\n\t\t\t\"mapA\": -10,\n\t\t\t\"mapB\": 10,\n\t\t\t\"mapC\": nil,\n\t\t},\n\t}\n\tt.Run(\"marshal with color\", func(t *testing.T) {\n\t\tb, err := json.MarshalWithOption(v, json.Colorize(json.DefaultColorScheme))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Log(string(b))\n\t})\n\tt.Run(\"marshal indent with color\", func(t *testing.T) {\n\t\tb, err := json.MarshalIndentWithOption(v, \"\", \"\\t\", json.Colorize(json.DefaultColorScheme))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Log(\"\\n\" + string(b))\n\t})\n}\n"
        },
        {
          "name": "decode.go",
          "type": "blob",
          "size": 6.2841796875,
          "content": "package json\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"unsafe\"\n\n\t\"github.com/goccy/go-json/internal/decoder\"\n\t\"github.com/goccy/go-json/internal/errors\"\n\t\"github.com/goccy/go-json/internal/runtime\"\n)\n\ntype Decoder struct {\n\ts *decoder.Stream\n}\n\nconst (\n\tnul = '\\000'\n)\n\ntype emptyInterface struct {\n\ttyp *runtime.Type\n\tptr unsafe.Pointer\n}\n\nfunc unmarshal(data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\tsrc := make([]byte, len(data)+1) // append nul byte to the end\n\tcopy(src, data)\n\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\n\tif err := validateType(header.typ, uintptr(header.ptr)); err != nil {\n\t\treturn err\n\t}\n\tdec, err := decoder.CompileToGetDecoder(header.typ)\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := decoder.TakeRuntimeContext()\n\tctx.Buf = src\n\tctx.Option.Flags = 0\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(ctx.Option)\n\t}\n\tcursor, err := dec.Decode(ctx, 0, 0, header.ptr)\n\tif err != nil {\n\t\tdecoder.ReleaseRuntimeContext(ctx)\n\t\treturn err\n\t}\n\tdecoder.ReleaseRuntimeContext(ctx)\n\treturn validateEndBuf(src, cursor)\n}\n\nfunc unmarshalContext(ctx context.Context, data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\tsrc := make([]byte, len(data)+1) // append nul byte to the end\n\tcopy(src, data)\n\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\n\tif err := validateType(header.typ, uintptr(header.ptr)); err != nil {\n\t\treturn err\n\t}\n\tdec, err := decoder.CompileToGetDecoder(header.typ)\n\tif err != nil {\n\t\treturn err\n\t}\n\trctx := decoder.TakeRuntimeContext()\n\trctx.Buf = src\n\trctx.Option.Flags = 0\n\trctx.Option.Flags |= decoder.ContextOption\n\trctx.Option.Context = ctx\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(rctx.Option)\n\t}\n\tcursor, err := dec.Decode(rctx, 0, 0, header.ptr)\n\tif err != nil {\n\t\tdecoder.ReleaseRuntimeContext(rctx)\n\t\treturn err\n\t}\n\tdecoder.ReleaseRuntimeContext(rctx)\n\treturn validateEndBuf(src, cursor)\n}\n\nvar (\n\tpathDecoder = decoder.NewPathDecoder()\n)\n\nfunc extractFromPath(path *Path, data []byte, optFuncs ...DecodeOptionFunc) ([][]byte, error) {\n\tif path.path.RootSelectorOnly {\n\t\treturn [][]byte{data}, nil\n\t}\n\tsrc := make([]byte, len(data)+1) // append nul byte to the end\n\tcopy(src, data)\n\n\tctx := decoder.TakeRuntimeContext()\n\tctx.Buf = src\n\tctx.Option.Flags = 0\n\tctx.Option.Flags |= decoder.PathOption\n\tctx.Option.Path = path.path\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(ctx.Option)\n\t}\n\tpaths, cursor, err := pathDecoder.DecodePath(ctx, 0, 0)\n\tif err != nil {\n\t\tdecoder.ReleaseRuntimeContext(ctx)\n\t\treturn nil, err\n\t}\n\tdecoder.ReleaseRuntimeContext(ctx)\n\tif err := validateEndBuf(src, cursor); err != nil {\n\t\treturn nil, err\n\t}\n\treturn paths, nil\n}\n\nfunc unmarshalNoEscape(data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\tsrc := make([]byte, len(data)+1) // append nul byte to the end\n\tcopy(src, data)\n\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\n\tif err := validateType(header.typ, uintptr(header.ptr)); err != nil {\n\t\treturn err\n\t}\n\tdec, err := decoder.CompileToGetDecoder(header.typ)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx := decoder.TakeRuntimeContext()\n\tctx.Buf = src\n\tctx.Option.Flags = 0\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(ctx.Option)\n\t}\n\tcursor, err := dec.Decode(ctx, 0, 0, noescape(header.ptr))\n\tif err != nil {\n\t\tdecoder.ReleaseRuntimeContext(ctx)\n\t\treturn err\n\t}\n\tdecoder.ReleaseRuntimeContext(ctx)\n\treturn validateEndBuf(src, cursor)\n}\n\nfunc validateEndBuf(src []byte, cursor int64) error {\n\tfor {\n\t\tswitch src[cursor] {\n\t\tcase ' ', '\\t', '\\n', '\\r':\n\t\t\tcursor++\n\t\t\tcontinue\n\t\tcase nul:\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.ErrSyntax(\n\t\t\tfmt.Sprintf(\"invalid character '%c' after top-level value\", src[cursor]),\n\t\t\tcursor+1,\n\t\t)\n\t}\n}\n\n//nolint:staticcheck\n//go:nosplit\nfunc noescape(p unsafe.Pointer) unsafe.Pointer {\n\tx := uintptr(p)\n\treturn unsafe.Pointer(x ^ 0)\n}\n\nfunc validateType(typ *runtime.Type, p uintptr) error {\n\tif typ == nil || typ.Kind() != reflect.Ptr || p == 0 {\n\t\treturn &InvalidUnmarshalError{Type: runtime.RType2Type(typ)}\n\t}\n\treturn nil\n}\n\n// NewDecoder returns a new decoder that reads from r.\n//\n// The decoder introduces its own buffering and may\n// read data from r beyond the JSON values requested.\nfunc NewDecoder(r io.Reader) *Decoder {\n\ts := decoder.NewStream(r)\n\treturn &Decoder{\n\t\ts: s,\n\t}\n}\n\n// Buffered returns a reader of the data remaining in the Decoder's\n// buffer. The reader is valid until the next call to Decode.\nfunc (d *Decoder) Buffered() io.Reader {\n\treturn d.s.Buffered()\n}\n\n// Decode reads the next JSON-encoded value from its\n// input and stores it in the value pointed to by v.\n//\n// See the documentation for Unmarshal for details about\n// the conversion of JSON into a Go value.\nfunc (d *Decoder) Decode(v interface{}) error {\n\treturn d.DecodeWithOption(v)\n}\n\n// DecodeContext reads the next JSON-encoded value from its\n// input and stores it in the value pointed to by v with context.Context.\nfunc (d *Decoder) DecodeContext(ctx context.Context, v interface{}) error {\n\td.s.Option.Flags |= decoder.ContextOption\n\td.s.Option.Context = ctx\n\treturn d.DecodeWithOption(v)\n}\n\nfunc (d *Decoder) DecodeWithOption(v interface{}, optFuncs ...DecodeOptionFunc) error {\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\ttyp := header.typ\n\tptr := uintptr(header.ptr)\n\ttypeptr := uintptr(unsafe.Pointer(typ))\n\t// noescape trick for header.typ ( reflect.*rtype )\n\tcopiedType := *(**runtime.Type)(unsafe.Pointer(&typeptr))\n\n\tif err := validateType(copiedType, ptr); err != nil {\n\t\treturn err\n\t}\n\n\tdec, err := decoder.CompileToGetDecoder(typ)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := d.s.PrepareForDecode(); err != nil {\n\t\treturn err\n\t}\n\ts := d.s\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(s.Option)\n\t}\n\tif err := dec.DecodeStream(s, 0, header.ptr); err != nil {\n\t\treturn err\n\t}\n\ts.Reset()\n\treturn nil\n}\n\nfunc (d *Decoder) More() bool {\n\treturn d.s.More()\n}\n\nfunc (d *Decoder) Token() (Token, error) {\n\treturn d.s.Token()\n}\n\n// DisallowUnknownFields causes the Decoder to return an error when the destination\n// is a struct and the input contains object keys which do not match any\n// non-ignored, exported fields in the destination.\nfunc (d *Decoder) DisallowUnknownFields() {\n\td.s.DisallowUnknownFields = true\n}\n\nfunc (d *Decoder) InputOffset() int64 {\n\treturn d.s.TotalOffset()\n}\n\n// UseNumber causes the Decoder to unmarshal a number into an interface{} as a\n// Number instead of as a float64.\nfunc (d *Decoder) UseNumber() {\n\td.s.UseNumber = true\n}\n"
        },
        {
          "name": "decode_test.go",
          "type": "blob",
          "size": 103.60546875,
          "content": "package json_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding\"\n\tstdjson \"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"image\"\n\t\"math\"\n\t\"math/big\"\n\t\"net\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"github.com/goccy/go-json\"\n)\n\nfunc Test_Decoder(t *testing.T) {\n\tt.Run(\"int\", func(t *testing.T) {\n\t\tvar v int\n\t\tassertErr(t, json.Unmarshal([]byte(`-1`), &v))\n\t\tassertEq(t, \"int\", int(-1), v)\n\t})\n\tt.Run(\"int8\", func(t *testing.T) {\n\t\tvar v int8\n\t\tassertErr(t, json.Unmarshal([]byte(`-2`), &v))\n\t\tassertEq(t, \"int8\", int8(-2), v)\n\t})\n\tt.Run(\"int16\", func(t *testing.T) {\n\t\tvar v int16\n\t\tassertErr(t, json.Unmarshal([]byte(`-3`), &v))\n\t\tassertEq(t, \"int16\", int16(-3), v)\n\t})\n\tt.Run(\"int32\", func(t *testing.T) {\n\t\tvar v int32\n\t\tassertErr(t, json.Unmarshal([]byte(`-4`), &v))\n\t\tassertEq(t, \"int32\", int32(-4), v)\n\t})\n\tt.Run(\"int64\", func(t *testing.T) {\n\t\tvar v int64\n\t\tassertErr(t, json.Unmarshal([]byte(`-5`), &v))\n\t\tassertEq(t, \"int64\", int64(-5), v)\n\t})\n\tt.Run(\"uint\", func(t *testing.T) {\n\t\tvar v uint\n\t\tassertErr(t, json.Unmarshal([]byte(`1`), &v))\n\t\tassertEq(t, \"uint\", uint(1), v)\n\t})\n\tt.Run(\"uint8\", func(t *testing.T) {\n\t\tvar v uint8\n\t\tassertErr(t, json.Unmarshal([]byte(`2`), &v))\n\t\tassertEq(t, \"uint8\", uint8(2), v)\n\t})\n\tt.Run(\"uint16\", func(t *testing.T) {\n\t\tvar v uint16\n\t\tassertErr(t, json.Unmarshal([]byte(`3`), &v))\n\t\tassertEq(t, \"uint16\", uint16(3), v)\n\t})\n\tt.Run(\"uint32\", func(t *testing.T) {\n\t\tvar v uint32\n\t\tassertErr(t, json.Unmarshal([]byte(`4`), &v))\n\t\tassertEq(t, \"uint32\", uint32(4), v)\n\t})\n\tt.Run(\"uint64\", func(t *testing.T) {\n\t\tvar v uint64\n\t\tassertErr(t, json.Unmarshal([]byte(`5`), &v))\n\t\tassertEq(t, \"uint64\", uint64(5), v)\n\t})\n\tt.Run(\"bool\", func(t *testing.T) {\n\t\tt.Run(\"true\", func(t *testing.T) {\n\t\t\tvar v bool\n\t\t\tassertErr(t, json.Unmarshal([]byte(`true`), &v))\n\t\t\tassertEq(t, \"bool\", true, v)\n\t\t})\n\t\tt.Run(\"false\", func(t *testing.T) {\n\t\t\tv := true\n\t\t\tassertErr(t, json.Unmarshal([]byte(`false`), &v))\n\t\t\tassertEq(t, \"bool\", false, v)\n\t\t})\n\t})\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tvar v string\n\t\tassertErr(t, json.Unmarshal([]byte(`\"hello\"`), &v))\n\t\tassertEq(t, \"string\", \"hello\", v)\n\t})\n\tt.Run(\"float32\", func(t *testing.T) {\n\t\tvar v float32\n\t\tassertErr(t, json.Unmarshal([]byte(`3.14`), &v))\n\t\tassertEq(t, \"float32\", float32(3.14), v)\n\t})\n\tt.Run(\"float64\", func(t *testing.T) {\n\t\tvar v float64\n\t\tassertErr(t, json.Unmarshal([]byte(`3.14`), &v))\n\t\tassertEq(t, \"float64\", float64(3.14), v)\n\t})\n\tt.Run(\"slice\", func(t *testing.T) {\n\t\tvar v []int\n\t\tassertErr(t, json.Unmarshal([]byte(` [ 1 , 2 , 3 , 4 ] `), &v))\n\t\tassertEq(t, \"slice\", fmt.Sprint([]int{1, 2, 3, 4}), fmt.Sprint(v))\n\t})\n\tt.Run(\"slice_reuse_data\", func(t *testing.T) {\n\t\tv := make([]int, 0, 10)\n\t\tassertErr(t, json.Unmarshal([]byte(` [ 1 , 2 , 3 , 4 ] `), &v))\n\t\tassertEq(t, \"slice\", fmt.Sprint([]int{1, 2, 3, 4}), fmt.Sprint(v))\n\t\tassertEq(t, \"cap\", 10, cap(v))\n\t})\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tvar v [4]int\n\t\tassertErr(t, json.Unmarshal([]byte(` [ 1 , 2 , 3 , 4 ] `), &v))\n\t\tassertEq(t, \"array\", fmt.Sprint([4]int{1, 2, 3, 4}), fmt.Sprint(v))\n\t})\n\tt.Run(\"map\", func(t *testing.T) {\n\t\tvar v map[string]int\n\t\tassertErr(t, json.Unmarshal([]byte(` { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 } `), &v))\n\t\tassertEq(t, \"map.a\", v[\"a\"], 1)\n\t\tassertEq(t, \"map.b\", v[\"b\"], 2)\n\t\tassertEq(t, \"map.c\", v[\"c\"], 3)\n\t\tassertEq(t, \"map.d\", v[\"d\"], 4)\n\t\tt.Run(\"nested map\", func(t *testing.T) {\n\t\t\t// https://github.com/goccy/go-json/issues/8\n\t\t\tcontent := `\n{\n  \"a\": {\n    \"nestedA\": \"value of nested a\"\n  },\n  \"b\": {\n    \"nestedB\": \"value of nested b\"\n  },\n  \"c\": {\n    \"nestedC\": \"value of nested c\"\n  }\n}`\n\t\t\tvar v map[string]interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(content), &v))\n\t\t\tassertEq(t, \"length\", 3, len(v))\n\t\t})\n\t})\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttype T struct {\n\t\t\tAA int    `json:\"aa\"`\n\t\t\tBB string `json:\"bb\"`\n\t\t\tCC bool   `json:\"cc\"`\n\t\t}\n\t\tvar v struct {\n\t\t\tA int    `json:\"abcd\"`\n\t\t\tB string `json:\"str\"`\n\t\t\tC bool\n\t\t\tD *T\n\t\t\tE func()\n\t\t}\n\t\tcontent := []byte(`\n{\n  \"abcd\": 123,\n  \"str\" : \"hello\",\n  \"c\"   : true,\n  \"d\"   : {\n    \"aa\": 2,\n    \"bb\": \"world\",\n    \"cc\": true\n  },\n  \"e\"   : null\n}`)\n\t\tassertErr(t, json.Unmarshal(content, &v))\n\t\tassertEq(t, \"struct.A\", 123, v.A)\n\t\tassertEq(t, \"struct.B\", \"hello\", v.B)\n\t\tassertEq(t, \"struct.C\", true, v.C)\n\t\tassertEq(t, \"struct.D.AA\", 2, v.D.AA)\n\t\tassertEq(t, \"struct.D.BB\", \"world\", v.D.BB)\n\t\tassertEq(t, \"struct.D.CC\", true, v.D.CC)\n\t\tassertEq(t, \"struct.E\", true, v.E == nil)\n\t\tt.Run(\"struct.field null\", func(t *testing.T) {\n\t\t\tvar v struct {\n\t\t\t\tA string\n\t\t\t\tB []string\n\t\t\t\tC []int\n\t\t\t\tD map[string]interface{}\n\t\t\t\tE [2]string\n\t\t\t\tF interface{}\n\t\t\t\tG func()\n\t\t\t}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`{\"a\":null,\"b\":null,\"c\":null,\"d\":null,\"e\":null,\"f\":null,\"g\":null}`), &v))\n\t\t\tassertEq(t, \"string\", v.A, \"\")\n\t\t\tassertNeq(t, \"[]string\", v.B, nil)\n\t\t\tassertEq(t, \"[]string\", len(v.B), 0)\n\t\t\tassertNeq(t, \"[]int\", v.C, nil)\n\t\t\tassertEq(t, \"[]int\", len(v.C), 0)\n\t\t\tassertNeq(t, \"map\", v.D, nil)\n\t\t\tassertEq(t, \"map\", len(v.D), 0)\n\t\t\tassertNeq(t, \"array\", v.E, nil)\n\t\t\tassertEq(t, \"array\", len(v.E), 2)\n\t\t\tassertEq(t, \"interface{}\", v.F, nil)\n\t\t\tassertEq(t, \"nilfunc\", true, v.G == nil)\n\t\t})\n\t\tt.Run(\"struct.pointer must be nil\", func(t *testing.T) {\n\t\t\tvar v struct {\n\t\t\t\tA *int\n\t\t\t}\n\t\t\tjson.Unmarshal([]byte(`{\"a\": \"alpha\"}`), &v)\n\t\t\tassertEq(t, \"struct.A\", v.A, (*int)(nil))\n\t\t})\n\t})\n\tt.Run(\"interface\", func(t *testing.T) {\n\t\tt.Run(\"number\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`10`), &v))\n\t\t\tassertEq(t, \"interface.kind\", \"float64\", reflect.TypeOf(v).Kind().String())\n\t\t\tassertEq(t, \"interface\", `10`, fmt.Sprint(v))\n\t\t})\n\t\tt.Run(\"string\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`\"hello\"`), &v))\n\t\t\tassertEq(t, \"interface.kind\", \"string\", reflect.TypeOf(v).Kind().String())\n\t\t\tassertEq(t, \"interface\", `hello`, fmt.Sprint(v))\n\t\t})\n\t\tt.Run(\"escaped string\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`\"he\\\"llo\"`), &v))\n\t\t\tassertEq(t, \"interface.kind\", \"string\", reflect.TypeOf(v).Kind().String())\n\t\t\tassertEq(t, \"interface\", `he\"llo`, fmt.Sprint(v))\n\t\t})\n\t\tt.Run(\"bool\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`true`), &v))\n\t\t\tassertEq(t, \"interface.kind\", \"bool\", reflect.TypeOf(v).Kind().String())\n\t\t\tassertEq(t, \"interface\", `true`, fmt.Sprint(v))\n\t\t})\n\t\tt.Run(\"slice\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`[1,2,3,4]`), &v))\n\t\t\tassertEq(t, \"interface.kind\", \"slice\", reflect.TypeOf(v).Kind().String())\n\t\t\tassertEq(t, \"interface\", `[1 2 3 4]`, fmt.Sprint(v))\n\t\t})\n\t\tt.Run(\"map\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tassertErr(t, json.Unmarshal([]byte(`{\"a\": 1, \"b\": \"c\"}`), &v))\n\t\t\tassertEq(t, \"interface.kind\", \"map\", reflect.TypeOf(v).Kind().String())\n\t\t\tm := v.(map[string]interface{})\n\t\t\tassertEq(t, \"interface\", `1`, fmt.Sprint(m[\"a\"]))\n\t\t\tassertEq(t, \"interface\", `c`, fmt.Sprint(m[\"b\"]))\n\t\t})\n\t\tt.Run(\"null\", func(t *testing.T) {\n\t\t\tvar v interface{}\n\t\t\tv = 1\n\t\t\tassertErr(t, json.Unmarshal([]byte(`null`), &v))\n\t\t\tassertEq(t, \"interface\", nil, v)\n\t\t})\n\t})\n\tt.Run(\"func\", func(t *testing.T) {\n\t\tvar v func()\n\t\tassertErr(t, json.Unmarshal([]byte(`null`), &v))\n\t\tassertEq(t, \"nilfunc\", true, v == nil)\n\t})\n}\n\nfunc TestIssue98(t *testing.T) {\n\tdata := \"[\\\"\\\\\"\n\tvar v interface{}\n\tif err := json.Unmarshal([]byte(data), &v); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc Test_Decoder_UseNumber(t *testing.T) {\n\tdec := json.NewDecoder(strings.NewReader(`{\"a\": 3.14}`))\n\tdec.UseNumber()\n\tvar v map[string]interface{}\n\tassertErr(t, dec.Decode(&v))\n\tassertEq(t, \"json.Number\", \"json.Number\", fmt.Sprintf(\"%T\", v[\"a\"]))\n}\n\nfunc Test_Decoder_DisallowUnknownFields(t *testing.T) {\n\tdec := json.NewDecoder(strings.NewReader(`{\"x\": 1}`))\n\tdec.DisallowUnknownFields()\n\tvar v struct {\n\t\tx int\n\t}\n\terr := dec.Decode(&v)\n\tif err == nil {\n\t\tt.Fatal(\"expected unknown field error\")\n\t}\n\tif err.Error() != `json: unknown field \"x\"` {\n\t\tt.Fatal(\"expected unknown field error\")\n\t}\n}\n\nfunc Test_Decoder_EmptyObjectWithSpace(t *testing.T) {\n\tdec := json.NewDecoder(strings.NewReader(`{\"obj\":{ }}`))\n\tvar v struct {\n\t\tObj map[string]int `json:\"obj\"`\n\t}\n\tassertErr(t, dec.Decode(&v))\n}\n\ntype unmarshalJSON struct {\n\tv int\n}\n\nfunc (u *unmarshalJSON) UnmarshalJSON(b []byte) error {\n\tvar v int\n\tif err := json.Unmarshal(b, &v); err != nil {\n\t\treturn err\n\t}\n\tu.v = v\n\treturn nil\n}\n\nfunc Test_UnmarshalJSON(t *testing.T) {\n\tt.Run(\"*struct\", func(t *testing.T) {\n\t\tvar v unmarshalJSON\n\t\tassertErr(t, json.Unmarshal([]byte(`10`), &v))\n\t\tassertEq(t, \"unmarshal\", 10, v.v)\n\t})\n}\n\ntype unmarshalText struct {\n\tv int\n}\n\nfunc (u *unmarshalText) UnmarshalText(b []byte) error {\n\tvar v int\n\tif err := json.Unmarshal(b, &v); err != nil {\n\t\treturn err\n\t}\n\tu.v = v\n\treturn nil\n}\n\nfunc Test_UnmarshalText(t *testing.T) {\n\tt.Run(\"*struct\", func(t *testing.T) {\n\t\tvar v unmarshalText\n\t\tassertErr(t, json.Unmarshal([]byte(`\"11\"`), &v))\n\t\tassertEq(t, \"unmarshal\", v.v, 11)\n\t})\n}\n\nfunc Test_InvalidUnmarshalError(t *testing.T) {\n\tt.Run(\"nil\", func(t *testing.T) {\n\t\tvar v *struct{}\n\t\terr := fmt.Sprint(json.Unmarshal([]byte(`{}`), v))\n\t\tassertEq(t, \"invalid unmarshal error\", \"json: Unmarshal(nil *struct {})\", err)\n\t})\n\tt.Run(\"non pointer\", func(t *testing.T) {\n\t\tvar v int\n\t\terr := fmt.Sprint(json.Unmarshal([]byte(`{}`), v))\n\t\tassertEq(t, \"invalid unmarshal error\", \"json: Unmarshal(non-pointer int)\", err)\n\t})\n}\n\nfunc Test_Token(t *testing.T) {\n\tdec := json.NewDecoder(strings.NewReader(`{\"a\": 1, \"b\": true, \"c\": [1, \"two\", null]}`))\n\tcnt := 0\n\tfor {\n\t\tif _, err := dec.Token(); err != nil {\n\t\t\tbreak\n\t\t}\n\t\tcnt++\n\t}\n\tif cnt != 12 {\n\t\tt.Fatal(\"failed to parse token\")\n\t}\n}\n\nfunc Test_DecodeStream(t *testing.T) {\n\tconst stream = `\n\t[\n\t\t{\"Name\": \"Ed\", \"Text\": \"Knock knock.\"},\n\t\t{\"Name\": \"Sam\", \"Text\": \"Who's there?\"},\n\t\t{\"Name\": \"Ed\", \"Text\": \"Go fmt.\"},\n\t\t{\"Name\": \"Sam\", \"Text\": \"Go fmt who?\"},\n\t\t{\"Name\": \"Ed\", \"Text\": \"Go fmt yourself!\"}\n\t]\n`\n\ttype Message struct {\n\t\tName, Text string\n\t}\n\tdec := json.NewDecoder(strings.NewReader(stream))\n\n\ttk, err := dec.Token()\n\tassertErr(t, err)\n\tassertEq(t, \"[\", fmt.Sprint(tk), \"[\")\n\n\telem := 0\n\t// while the array contains values\n\tfor dec.More() {\n\t\tvar m Message\n\t\t// decode an array value (Message)\n\t\tassertErr(t, dec.Decode(&m))\n\t\tif m.Name == \"\" || m.Text == \"\" {\n\t\t\tt.Fatal(\"failed to assign value to struct field\")\n\t\t}\n\t\telem++\n\t}\n\tassertEq(t, \"decode count\", elem, 5)\n\n\ttk, err = dec.Token()\n\tassertErr(t, err)\n\tassertEq(t, \"]\", fmt.Sprint(tk), \"]\")\n}\n\ntype T struct {\n\tX string\n\tY int\n\tZ int `json:\"-\"`\n}\n\ntype U struct {\n\tAlphabet string `json:\"alpha\"`\n}\n\ntype V struct {\n\tF1 interface{}\n\tF2 int32\n\tF3 json.Number\n\tF4 *VOuter\n}\n\ntype VOuter struct {\n\tV V\n}\n\ntype W struct {\n\tS SS\n}\n\ntype P struct {\n\tPP PP\n}\n\ntype PP struct {\n\tT  T\n\tTs []T\n}\n\ntype SS string\n\nfunc (*SS) UnmarshalJSON(data []byte) error {\n\treturn &json.UnmarshalTypeError{Value: \"number\", Type: reflect.TypeOf(SS(\"\"))}\n}\n\n// ifaceNumAsFloat64/ifaceNumAsNumber are used to test unmarshaling with and\n// without UseNumber\nvar ifaceNumAsFloat64 = map[string]interface{}{\n\t\"k1\": float64(1),\n\t\"k2\": \"s\",\n\t\"k3\": []interface{}{float64(1), float64(2.0), float64(3e-3)},\n\t\"k4\": map[string]interface{}{\"kk1\": \"s\", \"kk2\": float64(2)},\n}\n\nvar ifaceNumAsNumber = map[string]interface{}{\n\t\"k1\": json.Number(\"1\"),\n\t\"k2\": \"s\",\n\t\"k3\": []interface{}{json.Number(\"1\"), json.Number(\"2.0\"), json.Number(\"3e-3\")},\n\t\"k4\": map[string]interface{}{\"kk1\": \"s\", \"kk2\": json.Number(\"2\")},\n}\n\ntype tx struct {\n\tx int\n}\n\ntype u8 uint8\n\n// A type that can unmarshal itself.\n\ntype unmarshaler struct {\n\tT bool\n}\n\nfunc (u *unmarshaler) UnmarshalJSON(b []byte) error {\n\t*u = unmarshaler{true} // All we need to see that UnmarshalJSON is called.\n\treturn nil\n}\n\ntype ustruct struct {\n\tM unmarshaler\n}\n\nvar _ encoding.TextUnmarshaler = (*unmarshalerText)(nil)\n\ntype ustructText struct {\n\tM unmarshalerText\n}\n\n// u8marshal is an integer type that can marshal/unmarshal itself.\ntype u8marshal uint8\n\nfunc (u8 u8marshal) MarshalText() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(\"u%d\", u8)), nil\n}\n\nvar errMissingU8Prefix = errors.New(\"missing 'u' prefix\")\n\nfunc (u8 *u8marshal) UnmarshalText(b []byte) error {\n\tif !bytes.HasPrefix(b, []byte{'u'}) {\n\t\treturn errMissingU8Prefix\n\t}\n\tn, err := strconv.Atoi(string(b[1:]))\n\tif err != nil {\n\t\treturn err\n\t}\n\t*u8 = u8marshal(n)\n\treturn nil\n}\n\nvar _ encoding.TextUnmarshaler = (*u8marshal)(nil)\n\nvar (\n\tumtrue   = unmarshaler{true}\n\tumslice  = []unmarshaler{{true}}\n\tumstruct = ustruct{unmarshaler{true}}\n\n\tumtrueXY   = unmarshalerText{\"x\", \"y\"}\n\tumsliceXY  = []unmarshalerText{{\"x\", \"y\"}}\n\tumstructXY = ustructText{unmarshalerText{\"x\", \"y\"}}\n\n\tummapXY = map[unmarshalerText]bool{{\"x\", \"y\"}: true}\n)\n\n// Test data structures for anonymous fields.\n\ntype Point struct {\n\tZ int\n}\n\ntype Top struct {\n\tLevel0 int\n\tEmbed0\n\t*Embed0a\n\t*Embed0b `json:\"e,omitempty\"` // treated as named\n\tEmbed0c  `json:\"-\"`           // ignored\n\tLoop\n\tEmbed0p // has Point with X, Y, used\n\tEmbed0q // has Point with Z, used\n\tembed   // contains exported field\n}\n\ntype Embed0 struct {\n\tLevel1a int // overridden by Embed0a's Level1a with json tag\n\tLevel1b int // used because Embed0a's Level1b is renamed\n\tLevel1c int // used because Embed0a's Level1c is ignored\n\tLevel1d int // annihilated by Embed0a's Level1d\n\tLevel1e int `json:\"x\"` // annihilated by Embed0a.Level1e\n}\n\ntype Embed0a struct {\n\tLevel1a int `json:\"Level1a,omitempty\"`\n\tLevel1b int `json:\"LEVEL1B,omitempty\"`\n\tLevel1c int `json:\"-\"`\n\tLevel1d int // annihilated by Embed0's Level1d\n\tLevel1f int `json:\"x\"` // annihilated by Embed0's Level1e\n}\n\ntype Embed0b Embed0\n\ntype Embed0c Embed0\n\ntype Embed0p struct {\n\timage.Point\n}\n\ntype Embed0q struct {\n\tPoint\n}\n\ntype embed struct {\n\tQ int\n}\n\ntype Loop struct {\n\tLoop1 int `json:\",omitempty\"`\n\tLoop2 int `json:\",omitempty\"`\n\t*Loop\n}\n\n// From reflect test:\n// The X in S6 and S7 annihilate, but they also block the X in S8.S9.\ntype S5 struct {\n\tS6\n\tS7\n\tS8\n}\n\ntype S6 struct {\n\tX int\n}\n\ntype S7 S6\n\ntype S8 struct {\n\tS9\n}\n\ntype S9 struct {\n\tX int\n\tY int\n}\n\n// From reflect test:\n// The X in S11.S6 and S12.S6 annihilate, but they also block the X in S13.S8.S9.\ntype S10 struct {\n\tS11\n\tS12\n\tS13\n}\n\ntype S11 struct {\n\tS6\n}\n\ntype S12 struct {\n\tS6\n}\n\ntype S13 struct {\n\tS8\n}\n\ntype Ambig struct {\n\t// Given \"hello\", the first match should win.\n\tFirst  int `json:\"HELLO\"`\n\tSecond int `json:\"Hello\"`\n}\n\ntype XYZ struct {\n\tX interface{}\n\tY interface{}\n\tZ interface{}\n}\n\ntype unexportedWithMethods struct{}\n\nfunc (unexportedWithMethods) F() {}\n\ntype byteWithMarshalJSON byte\n\nfunc (b byteWithMarshalJSON) MarshalJSON() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(`\"Z%.2x\"`, byte(b))), nil\n}\n\nfunc (b *byteWithMarshalJSON) UnmarshalJSON(data []byte) error {\n\tif len(data) != 5 || data[0] != '\"' || data[1] != 'Z' || data[4] != '\"' {\n\t\treturn fmt.Errorf(\"bad quoted string\")\n\t}\n\ti, err := strconv.ParseInt(string(data[2:4]), 16, 8)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bad hex\")\n\t}\n\t*b = byteWithMarshalJSON(i)\n\treturn nil\n}\n\ntype byteWithPtrMarshalJSON byte\n\nfunc (b *byteWithPtrMarshalJSON) MarshalJSON() ([]byte, error) {\n\treturn byteWithMarshalJSON(*b).MarshalJSON()\n}\n\nfunc (b *byteWithPtrMarshalJSON) UnmarshalJSON(data []byte) error {\n\treturn (*byteWithMarshalJSON)(b).UnmarshalJSON(data)\n}\n\ntype byteWithMarshalText byte\n\nfunc (b byteWithMarshalText) MarshalText() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(`Z%.2x`, byte(b))), nil\n}\n\nfunc (b *byteWithMarshalText) UnmarshalText(data []byte) error {\n\tif len(data) != 3 || data[0] != 'Z' {\n\t\treturn fmt.Errorf(\"bad quoted string\")\n\t}\n\ti, err := strconv.ParseInt(string(data[1:3]), 16, 8)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bad hex\")\n\t}\n\t*b = byteWithMarshalText(i)\n\treturn nil\n}\n\ntype byteWithPtrMarshalText byte\n\nfunc (b *byteWithPtrMarshalText) MarshalText() ([]byte, error) {\n\treturn byteWithMarshalText(*b).MarshalText()\n}\n\nfunc (b *byteWithPtrMarshalText) UnmarshalText(data []byte) error {\n\treturn (*byteWithMarshalText)(b).UnmarshalText(data)\n}\n\ntype intWithMarshalJSON int\n\nfunc (b intWithMarshalJSON) MarshalJSON() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(`\"Z%.2x\"`, int(b))), nil\n}\n\nfunc (b *intWithMarshalJSON) UnmarshalJSON(data []byte) error {\n\tif len(data) != 5 || data[0] != '\"' || data[1] != 'Z' || data[4] != '\"' {\n\t\treturn fmt.Errorf(\"bad quoted string\")\n\t}\n\ti, err := strconv.ParseInt(string(data[2:4]), 16, 8)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bad hex\")\n\t}\n\t*b = intWithMarshalJSON(i)\n\treturn nil\n}\n\ntype intWithPtrMarshalJSON int\n\nfunc (b *intWithPtrMarshalJSON) MarshalJSON() ([]byte, error) {\n\treturn intWithMarshalJSON(*b).MarshalJSON()\n}\n\nfunc (b *intWithPtrMarshalJSON) UnmarshalJSON(data []byte) error {\n\treturn (*intWithMarshalJSON)(b).UnmarshalJSON(data)\n}\n\ntype intWithMarshalText int\n\nfunc (b intWithMarshalText) MarshalText() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(`Z%.2x`, int(b))), nil\n}\n\nfunc (b *intWithMarshalText) UnmarshalText(data []byte) error {\n\tif len(data) != 3 || data[0] != 'Z' {\n\t\treturn fmt.Errorf(\"bad quoted string\")\n\t}\n\ti, err := strconv.ParseInt(string(data[1:3]), 16, 8)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"bad hex\")\n\t}\n\t*b = intWithMarshalText(i)\n\treturn nil\n}\n\ntype intWithPtrMarshalText int\n\nfunc (b *intWithPtrMarshalText) MarshalText() ([]byte, error) {\n\treturn intWithMarshalText(*b).MarshalText()\n}\n\nfunc (b *intWithPtrMarshalText) UnmarshalText(data []byte) error {\n\treturn (*intWithMarshalText)(b).UnmarshalText(data)\n}\n\ntype mapStringToStringData struct {\n\tData map[string]string `json:\"data\"`\n}\n\ntype unmarshalTest struct {\n\tin                    string\n\tptr                   interface{} // new(type)\n\tout                   interface{}\n\terr                   error\n\tuseNumber             bool\n\tgolden                bool\n\tdisallowUnknownFields bool\n}\n\ntype B struct {\n\tB bool `json:\",string\"`\n}\n\ntype DoublePtr struct {\n\tI **int\n\tJ **int\n}\n\nvar unmarshalTests = []unmarshalTest{\n\t// basic types\n\t{in: `true`, ptr: new(bool), out: true},                                                                                                                       // 0\n\t{in: `1`, ptr: new(int), out: 1},                                                                                                                              // 1\n\t{in: `1.2`, ptr: new(float64), out: 1.2},                                                                                                                      // 2\n\t{in: `-5`, ptr: new(int16), out: int16(-5)},                                                                                                                   // 3\n\t{in: `2`, ptr: new(json.Number), out: json.Number(\"2\"), useNumber: true},                                                                                      // 4\n\t{in: `2`, ptr: new(json.Number), out: json.Number(\"2\")},                                                                                                       // 5\n\t{in: `2`, ptr: new(interface{}), out: float64(2.0)},                                                                                                           // 6\n\t{in: `2`, ptr: new(interface{}), out: json.Number(\"2\"), useNumber: true},                                                                                      // 7\n\t{in: `\"a\\u1234\"`, ptr: new(string), out: \"a\\u1234\"},                                                                                                           // 8\n\t{in: `\"http:\\/\\/\"`, ptr: new(string), out: \"http://\"},                                                                                                         // 9\n\t{in: `\"g-clef: \\uD834\\uDD1E\"`, ptr: new(string), out: \"g-clef: \\U0001D11E\"},                                                                                   // 10\n\t{in: `\"invalid: \\uD834x\\uDD1E\"`, ptr: new(string), out: \"invalid: \\uFFFDx\\uFFFD\"},                                                                             // 11\n\t{in: \"null\", ptr: new(interface{}), out: nil},                                                                                                                 // 12\n\t{in: `{\"X\": [1,2,3], \"Y\": 4}`, ptr: new(T), out: T{Y: 4}, err: &json.UnmarshalTypeError{\"array\", reflect.TypeOf(\"\"), 7, \"T\", \"X\"}},                            // 13\n\t{in: `{\"X\": 23}`, ptr: new(T), out: T{}, err: &json.UnmarshalTypeError{\"number\", reflect.TypeOf(\"\"), 8, \"T\", \"X\"}}, {in: `{\"x\": 1}`, ptr: new(tx), out: tx{}}, // 14\n\t{in: `{\"x\": 1}`, ptr: new(tx), out: tx{}}, // 15, 16\n\t{in: `{\"x\": 1}`, ptr: new(tx), err: fmt.Errorf(\"json: unknown field \\\"x\\\"\"), disallowUnknownFields: true},                           // 17\n\t{in: `{\"S\": 23}`, ptr: new(W), out: W{}, err: &json.UnmarshalTypeError{\"number\", reflect.TypeOf(SS(\"\")), 0, \"W\", \"S\"}},              // 18\n\t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: float64(1), F2: int32(2), F3: json.Number(\"3\")}},                             // 19\n\t{in: `{\"F1\":1,\"F2\":2,\"F3\":3}`, ptr: new(V), out: V{F1: json.Number(\"1\"), F2: int32(2), F3: json.Number(\"3\")}, useNumber: true},      // 20\n\t{in: `{\"k1\":1,\"k2\":\"s\",\"k3\":[1,2.0,3e-3],\"k4\":{\"kk1\":\"s\",\"kk2\":2}}`, ptr: new(interface{}), out: ifaceNumAsFloat64},                 // 21\n\t{in: `{\"k1\":1,\"k2\":\"s\",\"k3\":[1,2.0,3e-3],\"k4\":{\"kk1\":\"s\",\"kk2\":2}}`, ptr: new(interface{}), out: ifaceNumAsNumber, useNumber: true}, // 22\n\n\t// raw values with whitespace\n\t{in: \"\\n true \", ptr: new(bool), out: true},                  // 23\n\t{in: \"\\t 1 \", ptr: new(int), out: 1},                         // 24\n\t{in: \"\\r 1.2 \", ptr: new(float64), out: 1.2},                 // 25\n\t{in: \"\\t -5 \\n\", ptr: new(int16), out: int16(-5)},            // 26\n\t{in: \"\\t \\\"a\\\\u1234\\\" \\n\", ptr: new(string), out: \"a\\u1234\"}, // 27\n\n\t// Z has a \"-\" tag.\n\t{in: `{\"Y\": 1, \"Z\": 2}`, ptr: new(T), out: T{Y: 1}},                                                              // 28\n\t{in: `{\"Y\": 1, \"Z\": 2}`, ptr: new(T), err: fmt.Errorf(\"json: unknown field \\\"Z\\\"\"), disallowUnknownFields: true}, // 29\n\n\t{in: `{\"alpha\": \"abc\", \"alphabet\": \"xyz\"}`, ptr: new(U), out: U{Alphabet: \"abc\"}},                                                          // 30\n\t{in: `{\"alpha\": \"abc\", \"alphabet\": \"xyz\"}`, ptr: new(U), err: fmt.Errorf(\"json: unknown field \\\"alphabet\\\"\"), disallowUnknownFields: true}, // 31\n\t{in: `{\"alpha\": \"abc\"}`, ptr: new(U), out: U{Alphabet: \"abc\"}},                                                                             // 32\n\t{in: `{\"alphabet\": \"xyz\"}`, ptr: new(U), out: U{}},                                                                                         // 33\n\t{in: `{\"alphabet\": \"xyz\"}`, ptr: new(U), err: fmt.Errorf(\"json: unknown field \\\"alphabet\\\"\"), disallowUnknownFields: true},                 // 34\n\n\t// syntax errors\n\t{in: `{\"X\": \"foo\", \"Y\"}`, err: json.NewSyntaxError(\"invalid character '}' after object key\", 17)},                                              // 35\n\t{in: `[1, 2, 3+]`, err: json.NewSyntaxError(\"invalid character '+' after array element\", 9)},                                                   // 36\n\t{in: `{\"X\":12x}`, err: json.NewSyntaxError(\"invalid character 'x' after object key:value pair\", 8), useNumber: true},                           // 37\n\t{in: `[2, 3`, err: json.NewSyntaxError(\"unexpected end of JSON input\", 5)},                                                                     // 38\n\t{in: `{\"F3\": -}`, ptr: new(V), out: V{F3: json.Number(\"-\")}, err: json.NewSyntaxError(\"strconv.ParseFloat: parsing \\\"-\\\": invalid syntax\", 9)}, // 39\n\n\t// raw value errors\n\t{in: \"\\x01 42\", err: json.NewSyntaxError(\"invalid character '\\\\x01' looking for beginning of value\", 1)},         // 40\n\t{in: \" 42 \\x01\", err: json.NewSyntaxError(\"invalid character '\\\\x01' after top-level value\", 5)},                 // 41\n\t{in: \"\\x01 true\", err: json.NewSyntaxError(\"invalid character '\\\\x01' looking for beginning of value\", 1)},       // 42\n\t{in: \" false \\x01\", err: json.NewSyntaxError(\"invalid character '\\\\x01' after top-level value\", 8)},              // 43\n\t{in: \"\\x01 1.2\", err: json.NewSyntaxError(\"invalid character '\\\\x01' looking for beginning of value\", 1)},        // 44\n\t{in: \" 3.4 \\x01\", err: json.NewSyntaxError(\"invalid character '\\\\x01' after top-level value\", 6)},                // 45\n\t{in: \"\\x01 \\\"string\\\"\", err: json.NewSyntaxError(\"invalid character '\\\\x01' looking for beginning of value\", 1)}, // 46\n\t{in: \" \\\"string\\\" \\x01\", err: json.NewSyntaxError(\"invalid character '\\\\x01' after top-level value\", 11)},        // 47\n\n\t// array tests\n\t{in: `[1, 2, 3]`, ptr: new([3]int), out: [3]int{1, 2, 3}},                                           // 48\n\t{in: `[1, 2, 3]`, ptr: new([1]int), out: [1]int{1}},                                                 // 49\n\t{in: `[1, 2, 3]`, ptr: new([5]int), out: [5]int{1, 2, 3, 0, 0}},                                     // 50\n\t{in: `[1, 2, 3]`, ptr: new(MustNotUnmarshalJSON), err: errors.New(\"MustNotUnmarshalJSON was used\")}, // 51\n\n\t// empty array to interface test\n\t{in: `[]`, ptr: new([]interface{}), out: []interface{}{}},                                                //52\n\t{in: `null`, ptr: new([]interface{}), out: []interface{}(nil)},                                           //53\n\t{in: `{\"T\":[]}`, ptr: new(map[string]interface{}), out: map[string]interface{}{\"T\": []interface{}{}}},    //54\n\t{in: `{\"T\":null}`, ptr: new(map[string]interface{}), out: map[string]interface{}{\"T\": interface{}(nil)}}, // 55\n\n\t// composite tests\n\t{in: allValueIndent, ptr: new(All), out: allValue},      // 56\n\t{in: allValueCompact, ptr: new(All), out: allValue},     // 57\n\t{in: allValueIndent, ptr: new(*All), out: &allValue},    // 58\n\t{in: allValueCompact, ptr: new(*All), out: &allValue},   // 59\n\t{in: pallValueIndent, ptr: new(All), out: pallValue},    // 60\n\t{in: pallValueCompact, ptr: new(All), out: pallValue},   // 61\n\t{in: pallValueIndent, ptr: new(*All), out: &pallValue},  // 62\n\t{in: pallValueCompact, ptr: new(*All), out: &pallValue}, // 63\n\n\t// unmarshal interface test\n\t{in: `{\"T\":false}`, ptr: new(unmarshaler), out: umtrue},        // use \"false\" so test will fail if custom unmarshaler is not called\n\t{in: `{\"T\":false}`, ptr: new(*unmarshaler), out: &umtrue},      // 65\n\t{in: `[{\"T\":false}]`, ptr: new([]unmarshaler), out: umslice},   // 66\n\t{in: `[{\"T\":false}]`, ptr: new(*[]unmarshaler), out: &umslice}, // 67\n\t{in: `{\"M\":{\"T\":\"x:y\"}}`, ptr: new(ustruct), out: umstruct},    // 68\n\n\t// UnmarshalText interface test\n\t{in: `\"x:y\"`, ptr: new(unmarshalerText), out: umtrueXY},        // 69\n\t{in: `\"x:y\"`, ptr: new(*unmarshalerText), out: &umtrueXY},      // 70\n\t{in: `[\"x:y\"]`, ptr: new([]unmarshalerText), out: umsliceXY},   // 71\n\t{in: `[\"x:y\"]`, ptr: new(*[]unmarshalerText), out: &umsliceXY}, // 72\n\t{in: `{\"M\":\"x:y\"}`, ptr: new(ustructText), out: umstructXY},    // 73\n\t// integer-keyed map test\n\t{\n\t\tin:  `{\"-1\":\"a\",\"0\":\"b\",\"1\":\"c\"}`, // 74\n\t\tptr: new(map[int]string),\n\t\tout: map[int]string{-1: \"a\", 0: \"b\", 1: \"c\"},\n\t},\n\t{\n\t\tin:  `{\"0\":\"a\",\"10\":\"c\",\"9\":\"b\"}`, // 75\n\t\tptr: new(map[u8]string),\n\t\tout: map[u8]string{0: \"a\", 9: \"b\", 10: \"c\"},\n\t},\n\t{\n\t\tin:  `{\"-9223372036854775808\":\"min\",\"9223372036854775807\":\"max\"}`, // 76\n\t\tptr: new(map[int64]string),\n\t\tout: map[int64]string{math.MinInt64: \"min\", math.MaxInt64: \"max\"},\n\t},\n\t{\n\t\tin:  `{\"18446744073709551615\":\"max\"}`, // 77\n\t\tptr: new(map[uint64]string),\n\t\tout: map[uint64]string{math.MaxUint64: \"max\"},\n\t},\n\t{\n\t\tin:  `{\"0\":false,\"10\":true}`, // 78\n\t\tptr: new(map[uintptr]bool),\n\t\tout: map[uintptr]bool{0: false, 10: true},\n\t},\n\t// Check that MarshalText and UnmarshalText take precedence\n\t// over default integer handling in map keys.\n\t{\n\t\tin:  `{\"u2\":4}`, // 79\n\t\tptr: new(map[u8marshal]int),\n\t\tout: map[u8marshal]int{2: 4},\n\t},\n\t{\n\t\tin:  `{\"2\":4}`, // 80\n\t\tptr: new(map[u8marshal]int),\n\t\terr: errMissingU8Prefix,\n\t},\n\t// integer-keyed map errors\n\t{\n\t\tin:  `{\"abc\":\"abc\"}`, // 81\n\t\tptr: new(map[int]string),\n\t\terr: &json.UnmarshalTypeError{Value: \"number a\", Type: reflect.TypeOf(0), Offset: 2},\n\t},\n\t{\n\t\tin:  `{\"256\":\"abc\"}`, // 82\n\t\tptr: new(map[uint8]string),\n\t\terr: &json.UnmarshalTypeError{Value: \"number 256\", Type: reflect.TypeOf(uint8(0)), Offset: 2},\n\t},\n\t{\n\t\tin:  `{\"128\":\"abc\"}`, // 83\n\t\tptr: new(map[int8]string),\n\t\terr: &json.UnmarshalTypeError{Value: \"number 128\", Type: reflect.TypeOf(int8(0)), Offset: 2},\n\t},\n\t{\n\t\tin:  `{\"-1\":\"abc\"}`, // 84\n\t\tptr: new(map[uint8]string),\n\t\terr: &json.UnmarshalTypeError{Value: \"number -\", Type: reflect.TypeOf(uint8(0)), Offset: 2},\n\t},\n\t{\n\t\tin:  `{\"F\":{\"a\":2,\"3\":4}}`, // 85\n\t\tptr: new(map[string]map[int]int),\n\t\terr: &json.UnmarshalTypeError{Value: \"number a\", Type: reflect.TypeOf(int(0)), Offset: 7},\n\t},\n\t{\n\t\tin:  `{\"F\":{\"a\":2,\"3\":4}}`, // 86\n\t\tptr: new(map[string]map[uint]int),\n\t\terr: &json.UnmarshalTypeError{Value: \"number a\", Type: reflect.TypeOf(uint(0)), Offset: 7},\n\t},\n\t// Map keys can be encoding.TextUnmarshalers.\n\t{in: `{\"x:y\":true}`, ptr: new(map[unmarshalerText]bool), out: ummapXY}, // 87\n\t// If multiple values for the same key exists, only the most recent value is used.\n\t{in: `{\"x:y\":false,\"x:y\":true}`, ptr: new(map[unmarshalerText]bool), out: ummapXY}, // 88\n\t{ // 89\n\t\tin: `{\n\t\t\t\t\t\t\t\"Level0\": 1,\n\t\t\t\t\t\t\t\"Level1b\": 2,\n\t\t\t\t\t\t\t\"Level1c\": 3,\n\t\t\t\t\t\t\t\"x\": 4,\n\t\t\t\t\t\t\t\"Level1a\": 5,\n\t\t\t\t\t\t\t\"LEVEL1B\": 6,\n\t\t\t\t\t\t\t\"e\": {\n\t\t\t\t\t\t\t\t\"Level1a\": 8,\n\t\t\t\t\t\t\t\t\"Level1b\": 9,\n\t\t\t\t\t\t\t\t\"Level1c\": 10,\n\t\t\t\t\t\t\t\t\"Level1d\": 11,\n\t\t\t\t\t\t\t\t\"x\": 12\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Loop1\": 13,\n\t\t\t\t\t\t\t\"Loop2\": 14,\n\t\t\t\t\t\t\t\"X\": 15,\n\t\t\t\t\t\t\t\"Y\": 16,\n\t\t\t\t\t\t\t\"Z\": 17,\n\t\t\t\t\t\t\t\"Q\": 18\n\t\t\t\t\t\t}`,\n\t\tptr: new(Top),\n\t\tout: Top{\n\t\t\tLevel0: 1,\n\t\t\tEmbed0: Embed0{\n\t\t\t\tLevel1b: 2,\n\t\t\t\tLevel1c: 3,\n\t\t\t},\n\t\t\tEmbed0a: &Embed0a{\n\t\t\t\tLevel1a: 5,\n\t\t\t\tLevel1b: 6,\n\t\t\t},\n\t\t\tEmbed0b: &Embed0b{\n\t\t\t\tLevel1a: 8,\n\t\t\t\tLevel1b: 9,\n\t\t\t\tLevel1c: 10,\n\t\t\t\tLevel1d: 11,\n\t\t\t\tLevel1e: 12,\n\t\t\t},\n\t\t\tLoop: Loop{\n\t\t\t\tLoop1: 13,\n\t\t\t\tLoop2: 14,\n\t\t\t},\n\t\t\tEmbed0p: Embed0p{\n\t\t\t\tPoint: image.Point{X: 15, Y: 16},\n\t\t\t},\n\t\t\tEmbed0q: Embed0q{\n\t\t\t\tPoint: Point{Z: 17},\n\t\t\t},\n\t\t\tembed: embed{\n\t\t\t\tQ: 18,\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tin:  `{\"hello\": 1}`, // 90\n\t\tptr: new(Ambig),\n\t\tout: Ambig{First: 1},\n\t},\n\t{\n\t\tin:  `{\"X\": 1,\"Y\":2}`, // 91\n\t\tptr: new(S5),\n\t\tout: S5{S8: S8{S9: S9{Y: 2}}},\n\t},\n\t{\n\t\tin:                    `{\"X\": 1,\"Y\":2}`, // 92\n\t\tptr:                   new(S5),\n\t\terr:                   fmt.Errorf(\"json: unknown field \\\"X\\\"\"),\n\t\tdisallowUnknownFields: true,\n\t},\n\t{\n\t\tin:  `{\"X\": 1,\"Y\":2}`, // 93\n\t\tptr: new(S10),\n\t\tout: S10{S13: S13{S8: S8{S9: S9{Y: 2}}}},\n\t},\n\t{\n\t\tin:                    `{\"X\": 1,\"Y\":2}`, // 94\n\t\tptr:                   new(S10),\n\t\terr:                   fmt.Errorf(\"json: unknown field \\\"X\\\"\"),\n\t\tdisallowUnknownFields: true,\n\t},\n\t{\n\t\tin:  `{\"I\": 0, \"I\": null, \"J\": null}`, // 95\n\t\tptr: new(DoublePtr),\n\t\tout: DoublePtr{I: nil, J: nil},\n\t},\n\t{\n\t\tin:  \"\\\"hello\\\\ud800world\\\"\", // 96\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffdworld\",\n\t},\n\t{\n\t\tin:  \"\\\"hello\\\\ud800\\\\ud800world\\\"\", // 97\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffd\\ufffdworld\",\n\t},\n\t{\n\t\tin:  \"\\\"hello\\\\ud800\\\\ud800world\\\"\", // 98\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffd\\ufffdworld\",\n\t},\n\t// Used to be issue 8305, but time.Time implements encoding.TextUnmarshaler so this works now.\n\t{\n\t\tin:  `{\"2009-11-10T23:00:00Z\": \"hello world\"}`, // 99\n\t\tptr: new(map[time.Time]string),\n\t\tout: map[time.Time]string{time.Date(2009, 11, 10, 23, 0, 0, 0, time.UTC): \"hello world\"},\n\t},\n\t// issue 8305\n\t{\n\t\tin:  `{\"2009-11-10T23:00:00Z\": \"hello world\"}`, // 100\n\t\tptr: new(map[Point]string),\n\t\terr: &json.UnmarshalTypeError{Value: \"object\", Type: reflect.TypeOf(Point{}), Offset: 0},\n\t},\n\t{\n\t\tin:  `{\"asdf\": \"hello world\"}`, // 101\n\t\tptr: new(map[unmarshaler]string),\n\t\terr: &json.UnmarshalTypeError{Value: \"object\", Type: reflect.TypeOf(unmarshaler{}), Offset: 1},\n\t},\n\t// related to issue 13783.\n\t// Go 1.7 changed marshaling a slice of typed byte to use the methods on the byte type,\n\t// similar to marshaling a slice of typed int.\n\t// These tests check that, assuming the byte type also has valid decoding methods,\n\t// either the old base64 string encoding or the new per-element encoding can be\n\t// successfully unmarshaled. The custom unmarshalers were accessible in earlier\n\t// versions of Go, even though the custom marshaler was not.\n\t{\n\t\tin:  `\"AQID\"`, // 102\n\t\tptr: new([]byteWithMarshalJSON),\n\t\tout: []byteWithMarshalJSON{1, 2, 3},\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 103\n\t\tptr:    new([]byteWithMarshalJSON),\n\t\tout:    []byteWithMarshalJSON{1, 2, 3},\n\t\tgolden: true,\n\t},\n\t{\n\t\tin:  `\"AQID\"`, // 104\n\t\tptr: new([]byteWithMarshalText),\n\t\tout: []byteWithMarshalText{1, 2, 3},\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 105\n\t\tptr:    new([]byteWithMarshalText),\n\t\tout:    []byteWithMarshalText{1, 2, 3},\n\t\tgolden: true,\n\t},\n\t{\n\t\tin:  `\"AQID\"`, // 106\n\t\tptr: new([]byteWithPtrMarshalJSON),\n\t\tout: []byteWithPtrMarshalJSON{1, 2, 3},\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 107\n\t\tptr:    new([]byteWithPtrMarshalJSON),\n\t\tout:    []byteWithPtrMarshalJSON{1, 2, 3},\n\t\tgolden: true,\n\t},\n\t{\n\t\tin:  `\"AQID\"`, // 108\n\t\tptr: new([]byteWithPtrMarshalText),\n\t\tout: []byteWithPtrMarshalText{1, 2, 3},\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 109\n\t\tptr:    new([]byteWithPtrMarshalText),\n\t\tout:    []byteWithPtrMarshalText{1, 2, 3},\n\t\tgolden: true,\n\t},\n\n\t// ints work with the marshaler but not the base64 []byte case\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 110\n\t\tptr:    new([]intWithMarshalJSON),\n\t\tout:    []intWithMarshalJSON{1, 2, 3},\n\t\tgolden: true,\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 111\n\t\tptr:    new([]intWithMarshalText),\n\t\tout:    []intWithMarshalText{1, 2, 3},\n\t\tgolden: true,\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 112\n\t\tptr:    new([]intWithPtrMarshalJSON),\n\t\tout:    []intWithPtrMarshalJSON{1, 2, 3},\n\t\tgolden: true,\n\t},\n\t{\n\t\tin:     `[\"Z01\",\"Z02\",\"Z03\"]`, // 113\n\t\tptr:    new([]intWithPtrMarshalText),\n\t\tout:    []intWithPtrMarshalText{1, 2, 3},\n\t\tgolden: true,\n\t},\n\n\t{in: `0.000001`, ptr: new(float64), out: 0.000001, golden: true},                               // 114\n\t{in: `1e-07`, ptr: new(float64), out: 1e-7, golden: true},                                      // 115\n\t{in: `100000000000000000000`, ptr: new(float64), out: 100000000000000000000.0, golden: true},   // 116\n\t{in: `1e+21`, ptr: new(float64), out: 1e21, golden: true},                                      // 117\n\t{in: `-0.000001`, ptr: new(float64), out: -0.000001, golden: true},                             // 118\n\t{in: `-1e-07`, ptr: new(float64), out: -1e-7, golden: true},                                    // 119\n\t{in: `-100000000000000000000`, ptr: new(float64), out: -100000000000000000000.0, golden: true}, // 120\n\t{in: `-1e+21`, ptr: new(float64), out: -1e21, golden: true},                                    // 121\n\t{in: `999999999999999900000`, ptr: new(float64), out: 999999999999999900000.0, golden: true},   // 122\n\t{in: `9007199254740992`, ptr: new(float64), out: 9007199254740992.0, golden: true},             // 123\n\t{in: `9007199254740993`, ptr: new(float64), out: 9007199254740992.0, golden: false},            // 124\n\t{\n\t\tin:  `{\"V\": {\"F2\": \"hello\"}}`, // 125\n\t\tptr: new(VOuter),\n\t\terr: &json.UnmarshalTypeError{\n\t\t\tValue:  `number \"`,\n\t\t\tStruct: \"V\",\n\t\t\tField:  \"F2\",\n\t\t\tType:   reflect.TypeOf(int32(0)),\n\t\t\tOffset: 20,\n\t\t},\n\t},\n\t{\n\t\tin:  `{\"V\": {\"F4\": {}, \"F2\": \"hello\"}}`, // 126\n\t\tptr: new(VOuter),\n\t\terr: &json.UnmarshalTypeError{\n\t\t\tValue:  `number \"`,\n\t\t\tStruct: \"V\",\n\t\t\tField:  \"F2\",\n\t\t\tType:   reflect.TypeOf(int32(0)),\n\t\t\tOffset: 30,\n\t\t},\n\t},\n\t// issue 15146.\n\t// invalid inputs in wrongStringTests below.\n\t{in: `{\"B\":\"true\"}`, ptr: new(B), out: B{true}, golden: true},                                                               // 127\n\t{in: `{\"B\":\"false\"}`, ptr: new(B), out: B{false}, golden: true},                                                             // 128\n\t{in: `{\"B\": \"maybe\"}`, ptr: new(B), err: errors.New(`json: bool unexpected end of JSON input`)},                             // 129\n\t{in: `{\"B\": \"tru\"}`, ptr: new(B), err: errors.New(`json: invalid character as true`)},                                       // 130\n\t{in: `{\"B\": \"False\"}`, ptr: new(B), err: errors.New(`json: bool unexpected end of JSON input`)},                             // 131\n\t{in: `{\"B\": \"null\"}`, ptr: new(B), out: B{false}},                                                                           // 132\n\t{in: `{\"B\": \"nul\"}`, ptr: new(B), err: errors.New(`json: invalid character as null`)},                                       // 133\n\t{in: `{\"B\": [2, 3]}`, ptr: new(B), err: errors.New(`json: cannot unmarshal array into Go struct field B.B of type string`)}, // 134\n\t// additional tests for disallowUnknownFields\n\t{ // 135\n\t\tin: `{\n\t\t\t\t\t\t\"Level0\": 1,\n\t\t\t\t\t\t\"Level1b\": 2,\n\t\t\t\t\t\t\"Level1c\": 3,\n\t\t\t\t\t\t\"x\": 4,\n\t\t\t\t\t\t\"Level1a\": 5,\n\t\t\t\t\t\t\"LEVEL1B\": 6,\n\t\t\t\t\t\t\"e\": {\n\t\t\t\t\t\t\t\"Level1a\": 8,\n\t\t\t\t\t\t\t\"Level1b\": 9,\n\t\t\t\t\t\t\t\"Level1c\": 10,\n\t\t\t\t\t\t\t\"Level1d\": 11,\n\t\t\t\t\t\t\t\"x\": 12\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Loop1\": 13,\n\t\t\t\t\t\t\"Loop2\": 14,\n\t\t\t\t\t\t\"X\": 15,\n\t\t\t\t\t\t\"Y\": 16,\n\t\t\t\t\t\t\"Z\": 17,\n\t\t\t\t\t\t\"Q\": 18,\n\t\t\t\t\t\t\"extra\": true\n\t\t\t\t\t}`,\n\t\tptr:                   new(Top),\n\t\terr:                   fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n\t\tdisallowUnknownFields: true,\n\t},\n\t{ // 136\n\t\tin: `{\n\t\t\t\t\t\t\"Level0\": 1,\n\t\t\t\t\t\t\"Level1b\": 2,\n\t\t\t\t\t\t\"Level1c\": 3,\n\t\t\t\t\t\t\"x\": 4,\n\t\t\t\t\t\t\"Level1a\": 5,\n\t\t\t\t\t\t\"LEVEL1B\": 6,\n\t\t\t\t\t\t\"e\": {\n\t\t\t\t\t\t\t\"Level1a\": 8,\n\t\t\t\t\t\t\t\"Level1b\": 9,\n\t\t\t\t\t\t\t\"Level1c\": 10,\n\t\t\t\t\t\t\t\"Level1d\": 11,\n\t\t\t\t\t\t\t\"x\": 12,\n\t\t\t\t\t\t\t\"extra\": null\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Loop1\": 13,\n\t\t\t\t\t\t\"Loop2\": 14,\n\t\t\t\t\t\t\"X\": 15,\n\t\t\t\t\t\t\"Y\": 16,\n\t\t\t\t\t\t\"Z\": 17,\n\t\t\t\t\t\t\"Q\": 18\n\t\t\t\t\t}`,\n\t\tptr:                   new(Top),\n\t\terr:                   fmt.Errorf(\"json: unknown field \\\"extra\\\"\"),\n\t\tdisallowUnknownFields: true,\n\t},\n\t// issue 26444\n\t// UnmarshalTypeError without field & struct values\n\t{\n\t\tin:  `{\"data\":{\"test1\": \"bob\", \"test2\": 123}}`, // 137\n\t\tptr: new(mapStringToStringData),\n\t\terr: &json.UnmarshalTypeError{Value: \"number\", Type: reflect.TypeOf(\"\"), Offset: 37, Struct: \"mapStringToStringData\", Field: \"Data\"},\n\t},\n\t{\n\t\tin:  `{\"data\":{\"test1\": 123, \"test2\": \"bob\"}}`, // 138\n\t\tptr: new(mapStringToStringData),\n\t\terr: &json.UnmarshalTypeError{Value: \"number\", Type: reflect.TypeOf(\"\"), Offset: 21, Struct: \"mapStringToStringData\", Field: \"Data\"},\n\t},\n\n\t// trying to decode JSON arrays or objects via TextUnmarshaler\n\t{\n\t\tin:  `[1, 2, 3]`, // 139\n\t\tptr: new(MustNotUnmarshalText),\n\t\terr: &json.UnmarshalTypeError{Value: \"array\", Type: reflect.TypeOf(&MustNotUnmarshalText{}), Offset: 1},\n\t},\n\t{\n\t\tin:  `{\"foo\": \"bar\"}`, // 140\n\t\tptr: new(MustNotUnmarshalText),\n\t\terr: &json.UnmarshalTypeError{Value: \"object\", Type: reflect.TypeOf(&MustNotUnmarshalText{}), Offset: 1},\n\t},\n\t// #22369\n\t{\n\t\tin:  `{\"PP\": {\"T\": {\"Y\": \"bad-type\"}}}`, // 141\n\t\tptr: new(P),\n\t\terr: &json.UnmarshalTypeError{\n\t\t\tValue:  `number \"`,\n\t\t\tStruct: \"T\",\n\t\t\tField:  \"Y\",\n\t\t\tType:   reflect.TypeOf(int(0)),\n\t\t\tOffset: 29,\n\t\t},\n\t},\n\t{\n\t\tin:  `{\"Ts\": [{\"Y\": 1}, {\"Y\": 2}, {\"Y\": \"bad-type\"}]}`, // 142\n\t\tptr: new(PP),\n\t\terr: &json.UnmarshalTypeError{\n\t\t\tValue:  `number \"`,\n\t\t\tStruct: \"T\",\n\t\t\tField:  \"Y\",\n\t\t\tType:   reflect.TypeOf(int(0)),\n\t\t\tOffset: 29,\n\t\t},\n\t},\n\t// #14702\n\t{\n\t\tin:  `invalid`, // 143\n\t\tptr: new(json.Number),\n\t\terr: json.NewSyntaxError(\n\t\t\t`invalid character 'i' looking for beginning of value`,\n\t\t\t1,\n\t\t),\n\t},\n\t{\n\t\tin:  `\"invalid\"`, // 144\n\t\tptr: new(json.Number),\n\t\terr: fmt.Errorf(`strconv.ParseFloat: parsing \"invalid\": invalid syntax`),\n\t},\n\t{\n\t\tin:  `{\"A\":\"invalid\"}`, // 145\n\t\tptr: new(struct{ A json.Number }),\n\t\terr: fmt.Errorf(`strconv.ParseFloat: parsing \"invalid\": invalid syntax`),\n\t},\n\t{\n\t\tin: `{\"A\":\"invalid\"}`, // 146\n\t\tptr: new(struct {\n\t\t\tA json.Number `json:\",string\"`\n\t\t}),\n\t\terr: fmt.Errorf(`json: json.Number unexpected end of JSON input`),\n\t},\n\t{\n\t\tin:  `{\"A\":\"invalid\"}`, // 147\n\t\tptr: new(map[string]json.Number),\n\t\terr: fmt.Errorf(`strconv.ParseFloat: parsing \"invalid\": invalid syntax`),\n\t},\n\t// invalid UTF-8 is coerced to valid UTF-8.\n\t{\n\t\tin:  \"\\\"hello\\xffworld\\\"\", // 148\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffdworld\",\n\t},\n\t{\n\t\tin:  \"\\\"hello\\xc2\\xc2world\\\"\", // 149\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffd\\ufffdworld\",\n\t},\n\t{\n\t\tin:  \"\\\"hello\\xc2\\xffworld\\\"\", // 150\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffd\\ufffdworld\",\n\t},\n\t{\n\t\tin:  \"\\\"hello\\xed\\xa0\\x80\\xed\\xb0\\x80world\\\"\", // 151\n\t\tptr: new(string),\n\t\tout: \"hello\\ufffd\\ufffd\\ufffd\\ufffd\\ufffd\\ufffdworld\",\n\t},\n\t{in: \"-128\", ptr: new(int8), out: int8(-128)},\n\t{in: \"127\", ptr: new(int8), out: int8(127)},\n\t{in: \"-32768\", ptr: new(int16), out: int16(-32768)},\n\t{in: \"32767\", ptr: new(int16), out: int16(32767)},\n\t{in: \"-2147483648\", ptr: new(int32), out: int32(-2147483648)},\n\t{in: \"2147483647\", ptr: new(int32), out: int32(2147483647)},\n}\n\ntype All struct {\n\tBool    bool\n\tInt     int\n\tInt8    int8\n\tInt16   int16\n\tInt32   int32\n\tInt64   int64\n\tUint    uint\n\tUint8   uint8\n\tUint16  uint16\n\tUint32  uint32\n\tUint64  uint64\n\tUintptr uintptr\n\tFloat32 float32\n\tFloat64 float64\n\n\tFoo  string `json:\"bar\"`\n\tFoo2 string `json:\"bar2,dummyopt\"`\n\n\tIntStr     int64   `json:\",string\"`\n\tUintptrStr uintptr `json:\",string\"`\n\n\tPBool    *bool\n\tPInt     *int\n\tPInt8    *int8\n\tPInt16   *int16\n\tPInt32   *int32\n\tPInt64   *int64\n\tPUint    *uint\n\tPUint8   *uint8\n\tPUint16  *uint16\n\tPUint32  *uint32\n\tPUint64  *uint64\n\tPUintptr *uintptr\n\tPFloat32 *float32\n\tPFloat64 *float64\n\n\tString  string\n\tPString *string\n\n\tMap   map[string]Small\n\tMapP  map[string]*Small\n\tPMap  *map[string]Small\n\tPMapP *map[string]*Small\n\n\tEmptyMap map[string]Small\n\tNilMap   map[string]Small\n\n\tSlice   []Small\n\tSliceP  []*Small\n\tPSlice  *[]Small\n\tPSliceP *[]*Small\n\n\tEmptySlice []Small\n\tNilSlice   []Small\n\n\tStringSlice []string\n\tByteSlice   []byte\n\n\tSmall   Small\n\tPSmall  *Small\n\tPPSmall **Small\n\n\tInterface  interface{}\n\tPInterface *interface{}\n\n\tunexported int\n}\n\ntype Small struct {\n\tTag string\n}\n\nvar allValue = All{\n\tBool:       true,\n\tInt:        2,\n\tInt8:       3,\n\tInt16:      4,\n\tInt32:      5,\n\tInt64:      6,\n\tUint:       7,\n\tUint8:      8,\n\tUint16:     9,\n\tUint32:     10,\n\tUint64:     11,\n\tUintptr:    12,\n\tFloat32:    14.1,\n\tFloat64:    15.1,\n\tFoo:        \"foo\",\n\tFoo2:       \"foo2\",\n\tIntStr:     42,\n\tUintptrStr: 44,\n\tString:     \"16\",\n\tMap: map[string]Small{\n\t\t\"17\": {Tag: \"tag17\"},\n\t\t\"18\": {Tag: \"tag18\"},\n\t},\n\tMapP: map[string]*Small{\n\t\t\"19\": {Tag: \"tag19\"},\n\t\t\"20\": nil,\n\t},\n\tEmptyMap:    map[string]Small{},\n\tSlice:       []Small{{Tag: \"tag20\"}, {Tag: \"tag21\"}},\n\tSliceP:      []*Small{{Tag: \"tag22\"}, nil, {Tag: \"tag23\"}},\n\tEmptySlice:  []Small{},\n\tStringSlice: []string{\"str24\", \"str25\", \"str26\"},\n\tByteSlice:   []byte{27, 28, 29},\n\tSmall:       Small{Tag: \"tag30\"},\n\tPSmall:      &Small{Tag: \"tag31\"},\n\tInterface:   5.2,\n}\n\nvar pallValue = All{\n\tPBool:      &allValue.Bool,\n\tPInt:       &allValue.Int,\n\tPInt8:      &allValue.Int8,\n\tPInt16:     &allValue.Int16,\n\tPInt32:     &allValue.Int32,\n\tPInt64:     &allValue.Int64,\n\tPUint:      &allValue.Uint,\n\tPUint8:     &allValue.Uint8,\n\tPUint16:    &allValue.Uint16,\n\tPUint32:    &allValue.Uint32,\n\tPUint64:    &allValue.Uint64,\n\tPUintptr:   &allValue.Uintptr,\n\tPFloat32:   &allValue.Float32,\n\tPFloat64:   &allValue.Float64,\n\tPString:    &allValue.String,\n\tPMap:       &allValue.Map,\n\tPMapP:      &allValue.MapP,\n\tPSlice:     &allValue.Slice,\n\tPSliceP:    &allValue.SliceP,\n\tPPSmall:    &allValue.PSmall,\n\tPInterface: &allValue.Interface,\n}\n\nvar allValueIndent = `{\n\t\"Bool\": true,\n\t\"Int\": 2,\n\t\"Int8\": 3,\n\t\"Int16\": 4,\n\t\"Int32\": 5,\n\t\"Int64\": 6,\n\t\"Uint\": 7,\n\t\"Uint8\": 8,\n\t\"Uint16\": 9,\n\t\"Uint32\": 10,\n\t\"Uint64\": 11,\n\t\"Uintptr\": 12,\n\t\"Float32\": 14.1,\n\t\"Float64\": 15.1,\n\t\"bar\": \"foo\",\n\t\"bar2\": \"foo2\",\n\t\"IntStr\": \"42\",\n\t\"UintptrStr\": \"44\",\n\t\"PBool\": null,\n\t\"PInt\": null,\n\t\"PInt8\": null,\n\t\"PInt16\": null,\n\t\"PInt32\": null,\n\t\"PInt64\": null,\n\t\"PUint\": null,\n\t\"PUint8\": null,\n\t\"PUint16\": null,\n\t\"PUint32\": null,\n\t\"PUint64\": null,\n\t\"PUintptr\": null,\n\t\"PFloat32\": null,\n\t\"PFloat64\": null,\n\t\"String\": \"16\",\n\t\"PString\": null,\n\t\"Map\": {\n\t\t\"17\": {\n\t\t\t\"Tag\": \"tag17\"\n\t\t},\n\t\t\"18\": {\n\t\t\t\"Tag\": \"tag18\"\n\t\t}\n\t},\n\t\"MapP\": {\n\t\t\"19\": {\n\t\t\t\"Tag\": \"tag19\"\n\t\t},\n\t\t\"20\": null\n\t},\n\t\"PMap\": null,\n\t\"PMapP\": null,\n\t\"EmptyMap\": {},\n\t\"NilMap\": null,\n\t\"Slice\": [\n\t\t{\n\t\t\t\"Tag\": \"tag20\"\n\t\t},\n\t\t{\n\t\t\t\"Tag\": \"tag21\"\n\t\t}\n\t],\n\t\"SliceP\": [\n\t\t{\n\t\t\t\"Tag\": \"tag22\"\n\t\t},\n\t\tnull,\n\t\t{\n\t\t\t\"Tag\": \"tag23\"\n\t\t}\n\t],\n\t\"PSlice\": null,\n\t\"PSliceP\": null,\n\t\"EmptySlice\": [],\n\t\"NilSlice\": null,\n\t\"StringSlice\": [\n\t\t\"str24\",\n\t\t\"str25\",\n\t\t\"str26\"\n\t],\n\t\"ByteSlice\": \"Gxwd\",\n\t\"Small\": {\n\t\t\"Tag\": \"tag30\"\n\t},\n\t\"PSmall\": {\n\t\t\"Tag\": \"tag31\"\n\t},\n\t\"PPSmall\": null,\n\t\"Interface\": 5.2,\n\t\"PInterface\": null\n}`\n\nvar allValueCompact = strings.Map(noSpace, allValueIndent)\n\nvar pallValueIndent = `{\n\t\"Bool\": false,\n\t\"Int\": 0,\n\t\"Int8\": 0,\n\t\"Int16\": 0,\n\t\"Int32\": 0,\n\t\"Int64\": 0,\n\t\"Uint\": 0,\n\t\"Uint8\": 0,\n\t\"Uint16\": 0,\n\t\"Uint32\": 0,\n\t\"Uint64\": 0,\n\t\"Uintptr\": 0,\n\t\"Float32\": 0,\n\t\"Float64\": 0,\n\t\"bar\": \"\",\n\t\"bar2\": \"\",\n        \"IntStr\": \"0\",\n\t\"UintptrStr\": \"0\",\n\t\"PBool\": true,\n\t\"PInt\": 2,\n\t\"PInt8\": 3,\n\t\"PInt16\": 4,\n\t\"PInt32\": 5,\n\t\"PInt64\": 6,\n\t\"PUint\": 7,\n\t\"PUint8\": 8,\n\t\"PUint16\": 9,\n\t\"PUint32\": 10,\n\t\"PUint64\": 11,\n\t\"PUintptr\": 12,\n\t\"PFloat32\": 14.1,\n\t\"PFloat64\": 15.1,\n\t\"String\": \"\",\n\t\"PString\": \"16\",\n\t\"Map\": null,\n\t\"MapP\": null,\n\t\"PMap\": {\n\t\t\"17\": {\n\t\t\t\"Tag\": \"tag17\"\n\t\t},\n\t\t\"18\": {\n\t\t\t\"Tag\": \"tag18\"\n\t\t}\n\t},\n\t\"PMapP\": {\n\t\t\"19\": {\n\t\t\t\"Tag\": \"tag19\"\n\t\t},\n\t\t\"20\": null\n\t},\n\t\"EmptyMap\": null,\n\t\"NilMap\": null,\n\t\"Slice\": null,\n\t\"SliceP\": null,\n\t\"PSlice\": [\n\t\t{\n\t\t\t\"Tag\": \"tag20\"\n\t\t},\n\t\t{\n\t\t\t\"Tag\": \"tag21\"\n\t\t}\n\t],\n\t\"PSliceP\": [\n\t\t{\n\t\t\t\"Tag\": \"tag22\"\n\t\t},\n\t\tnull,\n\t\t{\n\t\t\t\"Tag\": \"tag23\"\n\t\t}\n\t],\n\t\"EmptySlice\": null,\n\t\"NilSlice\": null,\n\t\"StringSlice\": null,\n\t\"ByteSlice\": null,\n\t\"Small\": {\n\t\t\"Tag\": \"\"\n\t},\n\t\"PSmall\": null,\n\t\"PPSmall\": {\n\t\t\"Tag\": \"tag31\"\n\t},\n\t\"Interface\": null,\n\t\"PInterface\": 5.2\n}`\n\nvar pallValueCompact = strings.Map(noSpace, pallValueIndent)\n\ntype NullTest struct {\n\tBool      bool\n\tInt       int\n\tInt8      int8\n\tInt16     int16\n\tInt32     int32\n\tInt64     int64\n\tUint      uint\n\tUint8     uint8\n\tUint16    uint16\n\tUint32    uint32\n\tUint64    uint64\n\tFloat32   float32\n\tFloat64   float64\n\tString    string\n\tPBool     *bool\n\tMap       map[string]string\n\tSlice     []string\n\tInterface interface{}\n\n\tPRaw    *json.RawMessage\n\tPTime   *time.Time\n\tPBigInt *big.Int\n\tPText   *MustNotUnmarshalText\n\tPBuffer *bytes.Buffer // has methods, just not relevant ones\n\tPStruct *struct{}\n\n\tRaw    json.RawMessage\n\tTime   time.Time\n\tBigInt big.Int\n\tText   MustNotUnmarshalText\n\tBuffer bytes.Buffer\n\tStruct struct{}\n}\n\ntype MustNotUnmarshalJSON struct{}\n\nfunc (x MustNotUnmarshalJSON) UnmarshalJSON(data []byte) error {\n\treturn errors.New(\"MustNotUnmarshalJSON was used\")\n}\n\ntype MustNotUnmarshalText struct{}\n\nfunc (x MustNotUnmarshalText) UnmarshalText(text []byte) error {\n\treturn errors.New(\"MustNotUnmarshalText was used\")\n}\n\nfunc isSpace(c byte) bool {\n\treturn c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')\n}\n\nfunc noSpace(c rune) rune {\n\tif isSpace(byte(c)) { //only used for ascii\n\t\treturn -1\n\t}\n\treturn c\n}\n\nvar badUTF8 = []struct {\n\tin, out string\n}{\n\t{\"hello\\xffworld\", `\"hello\\ufffdworld\"`},\n\t{\"\", `\"\"`},\n\t{\"\\xff\", `\"\\ufffd\"`},\n\t{\"\\xff\\xff\", `\"\\ufffd\\ufffd\"`},\n\t{\"a\\xffb\", `\"a\\ufffdb\"`},\n\t{\"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xff\\xaa\\x9e\", `\"日本\\ufffd\\ufffd\\ufffd\"`},\n}\n\nfunc TestMarshalAllValue(t *testing.T) {\n\tb, err := json.Marshal(allValue)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal allValue: %v\", err)\n\t}\n\tif string(b) != allValueCompact {\n\t\tt.Errorf(\"Marshal allValueCompact\")\n\t\tdiff(t, b, []byte(allValueCompact))\n\t\treturn\n\t}\n\n\tb, err = json.Marshal(pallValue)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal pallValue: %v\", err)\n\t}\n\tif string(b) != pallValueCompact {\n\t\tt.Errorf(\"Marshal pallValueCompact\")\n\t\tdiff(t, b, []byte(pallValueCompact))\n\t\treturn\n\t}\n}\n\nfunc TestMarshalBadUTF8(t *testing.T) {\n\tfor _, tt := range badUTF8 {\n\t\tb, err := json.Marshal(tt.in)\n\t\tif string(b) != tt.out || err != nil {\n\t\t\tt.Errorf(\"Marshal(%q) = %#q, %v, want %#q, nil\", tt.in, b, err, tt.out)\n\t\t}\n\t}\n}\n\nfunc TestMarshalNumberZeroVal(t *testing.T) {\n\tvar n json.Number\n\tout, err := json.Marshal(n)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toutStr := string(out)\n\tif outStr != \"0\" {\n\t\tt.Fatalf(\"Invalid zero val for Number: %q\", outStr)\n\t}\n}\n\nfunc TestMarshalEmbeds(t *testing.T) {\n\ttop := &Top{\n\t\tLevel0: 1,\n\t\tEmbed0: Embed0{\n\t\t\tLevel1b: 2,\n\t\t\tLevel1c: 3,\n\t\t},\n\t\tEmbed0a: &Embed0a{\n\t\t\tLevel1a: 5,\n\t\t\tLevel1b: 6,\n\t\t},\n\t\tEmbed0b: &Embed0b{\n\t\t\tLevel1a: 8,\n\t\t\tLevel1b: 9,\n\t\t\tLevel1c: 10,\n\t\t\tLevel1d: 11,\n\t\t\tLevel1e: 12,\n\t\t},\n\t\tLoop: Loop{\n\t\t\tLoop1: 13,\n\t\t\tLoop2: 14,\n\t\t},\n\t\tEmbed0p: Embed0p{\n\t\t\tPoint: image.Point{X: 15, Y: 16},\n\t\t},\n\t\tEmbed0q: Embed0q{\n\t\t\tPoint: Point{Z: 17},\n\t\t},\n\t\tembed: embed{\n\t\t\tQ: 18,\n\t\t},\n\t}\n\tb, err := json.Marshal(top)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := \"{\\\"Level0\\\":1,\\\"Level1b\\\":2,\\\"Level1c\\\":3,\\\"Level1a\\\":5,\\\"LEVEL1B\\\":6,\\\"e\\\":{\\\"Level1a\\\":8,\\\"Level1b\\\":9,\\\"Level1c\\\":10,\\\"Level1d\\\":11,\\\"x\\\":12},\\\"Loop1\\\":13,\\\"Loop2\\\":14,\\\"X\\\":15,\\\"Y\\\":16,\\\"Z\\\":17,\\\"Q\\\":18}\"\n\tif string(b) != want {\n\t\tt.Errorf(\"Wrong marshal result.\\n got: %q\\nwant: %q\", b, want)\n\t}\n}\n\nfunc equalError(a, b error) bool {\n\tif a == nil {\n\t\treturn b == nil\n\t}\n\tif b == nil {\n\t\treturn a == nil\n\t}\n\treturn a.Error() == b.Error()\n}\n\nfunc TestUnmarshal(t *testing.T) {\n\tfor i, tt := range unmarshalTests {\n\t\tt.Run(fmt.Sprintf(\"%d_%q\", i, tt.in), func(t *testing.T) {\n\t\t\tin := []byte(tt.in)\n\t\t\tif tt.ptr == nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttyp := reflect.TypeOf(tt.ptr)\n\t\t\tif typ.Kind() != reflect.Ptr {\n\t\t\t\tt.Errorf(\"#%d: unmarshalTest.ptr %T is not a pointer type\", i, tt.ptr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttyp = typ.Elem()\n\n\t\t\t// v = new(right-type)\n\t\t\tv := reflect.New(typ)\n\n\t\t\tif !reflect.DeepEqual(tt.ptr, v.Interface()) {\n\t\t\t\t// There's no reason for ptr to point to non-zero data,\n\t\t\t\t// as we decode into new(right-type), so the data is\n\t\t\t\t// discarded.\n\t\t\t\t// This can easily mean tests that silently don't test\n\t\t\t\t// what they should. To test decoding into existing\n\t\t\t\t// data, see TestPrefilled.\n\t\t\t\tt.Errorf(\"#%d: unmarshalTest.ptr %#v is not a pointer to a zero value\", i, tt.ptr)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdec := json.NewDecoder(bytes.NewReader(in))\n\t\t\tif tt.useNumber {\n\t\t\t\tdec.UseNumber()\n\t\t\t}\n\t\t\tif tt.disallowUnknownFields {\n\t\t\t\tdec.DisallowUnknownFields()\n\t\t\t}\n\t\t\tif err := dec.Decode(v.Interface()); !equalError(err, tt.err) {\n\t\t\t\tt.Errorf(\"#%d: %v, want %v\", i, err, tt.err)\n\t\t\t\treturn\n\t\t\t} else if err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(v.Elem().Interface(), tt.out) {\n\t\t\t\tt.Errorf(\"#%d: mismatch\\nhave: %#+v\\nwant: %#+v\", i, v.Elem().Interface(), tt.out)\n\t\t\t\tdata, _ := json.Marshal(v.Elem().Interface())\n\t\t\t\tprintln(string(data))\n\t\t\t\tdata, _ = json.Marshal(tt.out)\n\t\t\t\tprintln(string(data))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check round trip also decodes correctly.\n\t\t\tif tt.err == nil {\n\t\t\t\tenc, err := json.Marshal(v.Interface())\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"#%d: error re-marshaling: %v\", i, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif tt.golden && !bytes.Equal(enc, in) {\n\t\t\t\t\tt.Errorf(\"#%d: remarshal mismatch:\\nhave: %s\\nwant: %s\", i, enc, in)\n\t\t\t\t}\n\t\t\t\tvv := reflect.New(reflect.TypeOf(tt.ptr).Elem())\n\t\t\t\tdec = json.NewDecoder(bytes.NewReader(enc))\n\t\t\t\tif tt.useNumber {\n\t\t\t\t\tdec.UseNumber()\n\t\t\t\t}\n\t\t\t\tif err := dec.Decode(vv.Interface()); err != nil {\n\t\t\t\t\tt.Errorf(\"#%d: error re-unmarshaling %#q: %v\", i, enc, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(v.Elem().Interface(), vv.Elem().Interface()) {\n\t\t\t\t\tt.Errorf(\"#%d: mismatch\\nhave: %#+v\\nwant: %#+v\", i, v.Elem().Interface(), vv.Elem().Interface())\n\t\t\t\t\tt.Errorf(\"     In: %q\", strings.Map(noSpace, string(in)))\n\t\t\t\t\tt.Errorf(\"Marshal: %q\", strings.Map(noSpace, string(enc)))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalMarshal(t *testing.T) {\n\tinitBig()\n\tvar v interface{}\n\tif err := json.Unmarshal(jsonBig, &v); err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\tif !bytes.Equal(jsonBig, b) {\n\t\tt.Errorf(\"Marshal jsonBig\")\n\t\tdiff(t, b, jsonBig)\n\t\treturn\n\t}\n}\n\nvar numberTests = []struct {\n\tin       string\n\ti        int64\n\tintErr   string\n\tf        float64\n\tfloatErr string\n}{\n\t{in: \"-1.23e1\", intErr: \"strconv.ParseInt: parsing \\\"-1.23e1\\\": invalid syntax\", f: -1.23e1},\n\t{in: \"-12\", i: -12, f: -12.0},\n\t{in: \"1e1000\", intErr: \"strconv.ParseInt: parsing \\\"1e1000\\\": invalid syntax\", floatErr: \"strconv.ParseFloat: parsing \\\"1e1000\\\": value out of range\"},\n}\n\n// Independent of Decode, basic coverage of the accessors in Number\nfunc TestNumberAccessors(t *testing.T) {\n\tfor _, tt := range numberTests {\n\t\tn := json.Number(tt.in)\n\t\tif s := n.String(); s != tt.in {\n\t\t\tt.Errorf(\"Number(%q).String() is %q\", tt.in, s)\n\t\t}\n\t\tif i, err := n.Int64(); err == nil && tt.intErr == \"\" && i != tt.i {\n\t\t\tt.Errorf(\"Number(%q).Int64() is %d\", tt.in, i)\n\t\t} else if (err == nil && tt.intErr != \"\") || (err != nil && err.Error() != tt.intErr) {\n\t\t\tt.Errorf(\"Number(%q).Int64() wanted error %q but got: %v\", tt.in, tt.intErr, err)\n\t\t}\n\t\tif f, err := n.Float64(); err == nil && tt.floatErr == \"\" && f != tt.f {\n\t\t\tt.Errorf(\"Number(%q).Float64() is %g\", tt.in, f)\n\t\t} else if (err == nil && tt.floatErr != \"\") || (err != nil && err.Error() != tt.floatErr) {\n\t\t\tt.Errorf(\"Number(%q).Float64() wanted error %q but got: %v\", tt.in, tt.floatErr, err)\n\t\t}\n\t}\n}\n\nfunc TestLargeByteSlice(t *testing.T) {\n\ts0 := make([]byte, 2000)\n\tfor i := range s0 {\n\t\ts0[i] = byte(i)\n\t}\n\tb, err := json.Marshal(s0)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\tvar s1 []byte\n\tif err := json.Unmarshal(b, &s1); err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif !bytes.Equal(s0, s1) {\n\t\tt.Errorf(\"Marshal large byte slice\")\n\t\tdiff(t, s0, s1)\n\t}\n}\n\ntype Xint struct {\n\tX int\n}\n\nfunc TestUnmarshalInterface(t *testing.T) {\n\tvar xint Xint\n\tvar i interface{} = &xint\n\tif err := json.Unmarshal([]byte(`{\"X\":1}`), &i); err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif xint.X != 1 {\n\t\tt.Fatalf(\"Did not write to xint\")\n\t}\n}\n\nfunc TestUnmarshalPtrPtr(t *testing.T) {\n\tvar xint Xint\n\tpxint := &xint\n\tif err := json.Unmarshal([]byte(`{\"X\":1}`), &pxint); err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif xint.X != 1 {\n\t\tt.Fatalf(\"Did not write to xint\")\n\t}\n}\n\nfunc TestEscape(t *testing.T) {\n\tconst input = `\"foobar\"<html>` + \" [\\u2028 \\u2029]\"\n\tconst expected = `\"\\\"foobar\\\"\\u003chtml\\u003e [\\u2028 \\u2029]\"`\n\tb, err := json.Marshal(input)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal error: %v\", err)\n\t}\n\tif s := string(b); s != expected {\n\t\tt.Errorf(\"Encoding of [%s]:\\n got [%s]\\nwant [%s]\", input, s, expected)\n\t}\n}\n\n// WrongString is a struct that's misusing the ,string modifier.\ntype WrongString struct {\n\tMessage string `json:\"result,string\"`\n}\n\ntype wrongStringTest struct {\n\tin, err string\n}\n\nvar wrongStringTests = []wrongStringTest{\n\t{`{\"result\":\"x\"}`, `invalid character 'x' looking for beginning of value`},\n\t{`{\"result\":\"foo\"}`, `invalid character 'f' looking for beginning of value`},\n\t{`{\"result\":\"123\"}`, `json: cannot unmarshal number into Go struct field WrongString.Message of type string`},\n\t{`{\"result\":123}`, `json: cannot unmarshal number into Go struct field WrongString.Message of type string`},\n\t{`{\"result\":\"\\\"\"}`, `json: string unexpected end of JSON input`},\n\t{`{\"result\":\"\\\"foo\"}`, `json: string unexpected end of JSON input`},\n}\n\n// If people misuse the ,string modifier, the error message should be\n// helpful, telling the user that they're doing it wrong.\nfunc TestErrorMessageFromMisusedString(t *testing.T) {\n\tfor n, tt := range wrongStringTests {\n\t\tr := strings.NewReader(tt.in)\n\t\tvar s WrongString\n\t\terr := json.NewDecoder(r).Decode(&s)\n\t\tgot := fmt.Sprintf(\"%v\", err)\n\t\tif got != tt.err {\n\t\t\tt.Errorf(\"%d. got err = %q, want %q\", n, got, tt.err)\n\t\t}\n\t}\n}\n\nfunc TestRefUnmarshal(t *testing.T) {\n\ttype S struct {\n\t\t// Ref is defined in encode_test.go.\n\t\tR0 Ref\n\t\tR1 *Ref\n\t\tR2 RefText\n\t\tR3 *RefText\n\t}\n\twant := S{\n\t\tR0: 12,\n\t\tR1: new(Ref),\n\t\tR2: 13,\n\t\tR3: new(RefText),\n\t}\n\t*want.R1 = 12\n\t*want.R3 = 13\n\n\tvar got S\n\tif err := json.Unmarshal([]byte(`{\"R0\":\"ref\",\"R1\":\"ref\",\"R2\":\"ref\",\"R3\":\"ref\"}`), &got); err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %+v, want %+v\", got, want)\n\t}\n}\n\n// Test that the empty string doesn't panic decoding when ,string is specified\n// Issue 3450\nfunc TestEmptyString(t *testing.T) {\n\ttype T2 struct {\n\t\tNumber1 int `json:\",string\"`\n\t\tNumber2 int `json:\",string\"`\n\t}\n\tdata := `{\"Number1\":\"1\", \"Number2\":\"\"}`\n\tdec := json.NewDecoder(strings.NewReader(data))\n\tvar t2 T2\n\terr := dec.Decode(&t2)\n\tif err == nil {\n\t\tt.Fatal(\"Decode: did not return error\")\n\t}\n\tif t2.Number1 != 1 {\n\t\tt.Fatal(\"Decode: did not set Number1\")\n\t}\n}\n\n// Test that a null for ,string is not replaced with the previous quoted string (issue 7046).\n// It should also not be an error (issue 2540, issue 8587).\nfunc TestNullString(t *testing.T) {\n\ttype T struct {\n\t\tA int  `json:\",string\"`\n\t\tB int  `json:\",string\"`\n\t\tC *int `json:\",string\"`\n\t}\n\tdata := []byte(`{\"A\": \"1\", \"B\": null, \"C\": null}`)\n\tvar s T\n\ts.B = 1\n\ts.C = new(int)\n\t*s.C = 2\n\terr := json.Unmarshal(data, &s)\n\tif err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif s.B != 1 || s.C != nil {\n\t\tt.Fatalf(\"after Unmarshal, s.B=%d, s.C=%p, want 1, nil\", s.B, s.C)\n\t}\n}\n\nfunc intp(x int) *int {\n\tp := new(int)\n\t*p = x\n\treturn p\n}\n\nfunc intpp(x *int) **int {\n\tpp := new(*int)\n\t*pp = x\n\treturn pp\n}\n\nvar interfaceSetTests = []struct {\n\tpre  interface{}\n\tjson string\n\tpost interface{}\n}{\n\t{\"foo\", `\"bar\"`, \"bar\"},\n\t{\"foo\", `2`, 2.0},\n\t{\"foo\", `true`, true},\n\t{\"foo\", `null`, nil},\n\t{nil, `null`, nil},\n\t{new(int), `null`, nil},\n\t{(*int)(nil), `null`, nil},\n\t//{new(*int), `null`, new(*int)},\n\t{(**int)(nil), `null`, nil},\n\t{intp(1), `null`, nil},\n\t//{intpp(nil), `null`, intpp(nil)},\n\t//{intpp(intp(1)), `null`, intpp(nil)},\n}\n\nfunc TestInterfaceSet(t *testing.T) {\n\tfor idx, tt := range interfaceSetTests {\n\t\tb := struct{ X interface{} }{tt.pre}\n\t\tblob := `{\"X\":` + tt.json + `}`\n\t\tif err := json.Unmarshal([]byte(blob), &b); err != nil {\n\t\t\tt.Errorf(\"Unmarshal %#q: %v\", blob, err)\n\t\t\tcontinue\n\t\t}\n\t\tif !reflect.DeepEqual(b.X, tt.post) {\n\t\t\tt.Errorf(\"%d: Unmarshal %#q into %#v: X=%#v, want %#v\", idx, blob, tt.pre, b.X, tt.post)\n\t\t}\n\t}\n}\n\n// JSON null values should be ignored for primitives and string values instead of resulting in an error.\n// Issue 2540\nfunc TestUnmarshalNulls(t *testing.T) {\n\t// Unmarshal docs:\n\t// The JSON null value unmarshals into an interface, map, pointer, or slice\n\t// by setting that Go value to nil. Because null is often used in JSON to mean\n\t// ``not present,'' unmarshaling a JSON null into any other Go type has no effect\n\t// on the value and produces no error.\n\n\tjsonData := []byte(`{\n\t\t\t\t\"Bool\"    : null,\n\t\t\t\t\"Int\"     : null,\n\t\t\t\t\"Int8\"    : null,\n\t\t\t\t\"Int16\"   : null,\n\t\t\t\t\"Int32\"   : null,\n\t\t\t\t\"Int64\"   : null,\n\t\t\t\t\"Uint\"    : null,\n\t\t\t\t\"Uint8\"   : null,\n\t\t\t\t\"Uint16\"  : null,\n\t\t\t\t\"Uint32\"  : null,\n\t\t\t\t\"Uint64\"  : null,\n\t\t\t\t\"Float32\" : null,\n\t\t\t\t\"Float64\" : null,\n\t\t\t\t\"String\"  : null,\n\t\t\t\t\"PBool\": null,\n\t\t\t\t\"Map\": null,\n\t\t\t\t\"Slice\": null,\n\t\t\t\t\"Interface\": null,\n\t\t\t\t\"PRaw\": null,\n\t\t\t\t\"PTime\": null,\n\t\t\t\t\"PBigInt\": null,\n\t\t\t\t\"PText\": null,\n\t\t\t\t\"PBuffer\": null,\n\t\t\t\t\"PStruct\": null,\n\t\t\t\t\"Raw\": null,\n\t\t\t\t\"Time\": null,\n\t\t\t\t\"BigInt\": null,\n\t\t\t\t\"Text\": null,\n\t\t\t\t\"Buffer\": null,\n\t\t\t\t\"Struct\": null\n\t\t\t}`)\n\tnulls := NullTest{\n\t\tBool:      true,\n\t\tInt:       2,\n\t\tInt8:      3,\n\t\tInt16:     4,\n\t\tInt32:     5,\n\t\tInt64:     6,\n\t\tUint:      7,\n\t\tUint8:     8,\n\t\tUint16:    9,\n\t\tUint32:    10,\n\t\tUint64:    11,\n\t\tFloat32:   12.1,\n\t\tFloat64:   13.1,\n\t\tString:    \"14\",\n\t\tPBool:     new(bool),\n\t\tMap:       map[string]string{},\n\t\tSlice:     []string{},\n\t\tInterface: new(MustNotUnmarshalJSON),\n\t\tPRaw:      new(json.RawMessage),\n\t\tPTime:     new(time.Time),\n\t\tPBigInt:   new(big.Int),\n\t\tPText:     new(MustNotUnmarshalText),\n\t\tPStruct:   new(struct{}),\n\t\tPBuffer:   new(bytes.Buffer),\n\t\tRaw:       json.RawMessage(\"123\"),\n\t\tTime:      time.Unix(123456789, 0),\n\t\tBigInt:    *big.NewInt(123),\n\t}\n\n\tbefore := nulls.Time.String()\n\n\terr := json.Unmarshal(jsonData, &nulls)\n\tif err != nil {\n\t\tt.Errorf(\"Unmarshal of null values failed: %v\", err)\n\t}\n\tif !nulls.Bool || nulls.Int != 2 || nulls.Int8 != 3 || nulls.Int16 != 4 || nulls.Int32 != 5 || nulls.Int64 != 6 ||\n\t\tnulls.Uint != 7 || nulls.Uint8 != 8 || nulls.Uint16 != 9 || nulls.Uint32 != 10 || nulls.Uint64 != 11 ||\n\t\tnulls.Float32 != 12.1 || nulls.Float64 != 13.1 || nulls.String != \"14\" {\n\t\tt.Errorf(\"Unmarshal of null values affected primitives\")\n\t}\n\n\tif nulls.PBool != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PBool\")\n\t}\n\tif nulls.Map != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.Map\")\n\t}\n\tif nulls.Slice != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.Slice\")\n\t}\n\tif nulls.Interface != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.Interface\")\n\t}\n\tif nulls.PRaw != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PRaw\")\n\t}\n\tif nulls.PTime != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PTime\")\n\t}\n\tif nulls.PBigInt != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PBigInt\")\n\t}\n\tif nulls.PText != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PText\")\n\t}\n\tif nulls.PBuffer != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PBuffer\")\n\t}\n\tif nulls.PStruct != nil {\n\t\tt.Errorf(\"Unmarshal of null did not clear nulls.PStruct\")\n\t}\n\n\tif string(nulls.Raw) != \"null\" {\n\t\tt.Errorf(\"Unmarshal of RawMessage null did not record null: %v\", string(nulls.Raw))\n\t}\n\tif nulls.Time.String() != before {\n\t\tt.Errorf(\"Unmarshal of time.Time null set time to %v\", nulls.Time.String())\n\t}\n\tif nulls.BigInt.String() != \"123\" {\n\t\tt.Errorf(\"Unmarshal of big.Int null set int to %v\", nulls.BigInt.String())\n\t}\n}\n\nfunc TestStringKind(t *testing.T) {\n\ttype stringKind string\n\n\tvar m1, m2 map[stringKind]int\n\tm1 = map[stringKind]int{\n\t\t\"foo\": 42,\n\t}\n\n\tdata, err := json.Marshal(m1)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error marshaling: %v\", err)\n\t}\n\n\terr = json.Unmarshal(data, &m2)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error unmarshaling: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(m1, m2) {\n\t\tt.Error(\"Items should be equal after encoding and then decoding\")\n\t}\n}\n\n// Custom types with []byte as underlying type could not be marshaled\n// and then unmarshaled.\n// Issue 8962.\nfunc TestByteKind(t *testing.T) {\n\ttype byteKind []byte\n\n\ta := byteKind(\"hello\")\n\n\tdata, err := json.Marshal(a)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tvar b byteKind\n\terr = json.Unmarshal(data, &b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.Errorf(\"expected %v == %v\", a, b)\n\t}\n}\n\n// The fix for issue 8962 introduced a regression.\n// Issue 12921.\nfunc TestSliceOfCustomByte(t *testing.T) {\n\ttype Uint8 uint8\n\n\ta := []Uint8(\"hello\")\n\n\tdata, err := json.Marshal(a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b []Uint8\n\terr = json.Unmarshal(data, &b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(a, b) {\n\t\tt.Fatalf(\"expected %v == %v\", a, b)\n\t}\n}\n\nvar decodeTypeErrorTests = []struct {\n\tdest interface{}\n\tsrc  string\n}{\n\t{new(string), `{\"user\": \"name\"}`}, // issue 4628.\n\t{new(error), `{}`},                // issue 4222\n\t{new(error), `[]`},\n\t{new(error), `\"\"`},\n\t{new(error), `123`},\n\t{new(error), `true`},\n}\n\nfunc TestUnmarshalTypeError(t *testing.T) {\n\tfor _, item := range decodeTypeErrorTests {\n\t\terr := json.Unmarshal([]byte(item.src), item.dest)\n\t\tif _, ok := err.(*json.UnmarshalTypeError); !ok {\n\t\t\tt.Errorf(\"expected type error for Unmarshal(%q, type %T): got %T\",\n\t\t\t\titem.src, item.dest, err)\n\t\t}\n\t}\n}\n\nvar unmarshalSyntaxTests = []string{\n\t\"tru\",\n\t\"fals\",\n\t\"nul\",\n\t\"123e\",\n\t`\"hello`,\n\t`[1,2,3`,\n\t`{\"key\":1`,\n\t`{\"key\":1,`,\n}\n\nfunc TestUnmarshalSyntax(t *testing.T) {\n\tvar x interface{}\n\tfor _, src := range unmarshalSyntaxTests {\n\t\terr := json.Unmarshal([]byte(src), &x)\n\t\tif _, ok := err.(*json.SyntaxError); !ok {\n\t\t\tt.Errorf(\"expected syntax error for Unmarshal(%q): got %T\", src, err)\n\t\t}\n\t}\n}\n\n// Test handling of unexported fields that should be ignored.\n// Issue 4660\ntype unexportedFields struct {\n\tName string\n\tm    map[string]interface{} `json:\"-\"`\n\tm2   map[string]interface{} `json:\"abcd\"`\n\n\ts []int `json:\"-\"`\n}\n\nfunc TestUnmarshalUnexported(t *testing.T) {\n\tinput := `{\"Name\": \"Bob\", \"m\": {\"x\": 123}, \"m2\": {\"y\": 456}, \"abcd\": {\"z\": 789}, \"s\": [2, 3]}`\n\twant := &unexportedFields{Name: \"Bob\"}\n\n\tout := &unexportedFields{}\n\terr := json.Unmarshal([]byte(input), out)\n\tif err != nil {\n\t\tt.Errorf(\"got error %v, expected nil\", err)\n\t}\n\tif !reflect.DeepEqual(out, want) {\n\t\tt.Errorf(\"got %q, want %q\", out, want)\n\t}\n}\n\n// Time3339 is a time.Time which encodes to and from JSON\n// as an RFC 3339 time in UTC.\ntype Time3339 time.Time\n\nfunc (t *Time3339) UnmarshalJSON(b []byte) error {\n\tif len(b) < 2 || b[0] != '\"' || b[len(b)-1] != '\"' {\n\t\treturn fmt.Errorf(\"types: failed to unmarshal non-string value %q as an RFC 3339 time\", b)\n\t}\n\ttm, err := time.Parse(time.RFC3339, string(b[1:len(b)-1]))\n\tif err != nil {\n\t\treturn err\n\t}\n\t*t = Time3339(tm)\n\treturn nil\n}\n\nfunc TestUnmarshalJSONLiteralError(t *testing.T) {\n\tvar t3 Time3339\n\terr := json.Unmarshal([]byte(`\"0000-00-00T00:00:00Z\"`), &t3)\n\tif err == nil {\n\t\tt.Fatalf(\"expected error; got time %v\", time.Time(t3))\n\t}\n\tif !strings.Contains(err.Error(), \"range\") {\n\t\tt.Errorf(\"got err = %v; want out of range error\", err)\n\t}\n}\n\n// Test that extra object elements in an array do not result in a\n// \"data changing underfoot\" error.\n// Issue 3717\nfunc TestSkipArrayObjects(t *testing.T) {\n\tdata := `[{}]`\n\tvar dest [0]interface{}\n\n\terr := json.Unmarshal([]byte(data), &dest)\n\tif err != nil {\n\t\tt.Errorf(\"got error %q, want nil\", err)\n\t}\n}\n\n// Test semantics of pre-filled data, such as struct fields, map elements,\n// slices, and arrays.\n// Issues 4900 and 8837, among others.\nfunc TestPrefilled(t *testing.T) {\n\t// Values here change, cannot reuse table across runs.\n\tvar prefillTests = []struct {\n\t\tin  string\n\t\tptr interface{}\n\t\tout interface{}\n\t}{\n\t\t{\n\t\t\tin:  `{\"X\": 1, \"Y\": 2}`,\n\t\t\tptr: &XYZ{X: float32(3), Y: int16(4), Z: 1.5},\n\t\t\tout: &XYZ{X: float64(1), Y: float64(2), Z: 1.5},\n\t\t},\n\t\t{\n\t\t\tin:  `{\"X\": 1, \"Y\": 2}`,\n\t\t\tptr: &map[string]interface{}{\"X\": float32(3), \"Y\": int16(4), \"Z\": 1.5},\n\t\t\tout: &map[string]interface{}{\"X\": float64(1), \"Y\": float64(2), \"Z\": 1.5},\n\t\t},\n\t\t{\n\t\t\tin:  `[2]`,\n\t\t\tptr: &[]int{1},\n\t\t\tout: &[]int{2},\n\t\t},\n\t\t{\n\t\t\tin:  `[2, 3]`,\n\t\t\tptr: &[]int{1},\n\t\t\tout: &[]int{2, 3},\n\t\t},\n\t\t{\n\t\t\tin:  `[2, 3]`,\n\t\t\tptr: &[...]int{1},\n\t\t\tout: &[...]int{2},\n\t\t},\n\t\t{\n\t\t\tin:  `[3]`,\n\t\t\tptr: &[...]int{1, 2},\n\t\t\tout: &[...]int{3, 0},\n\t\t},\n\t}\n\n\tfor _, tt := range prefillTests {\n\t\tptrstr := fmt.Sprintf(\"%v\", tt.ptr)\n\t\terr := json.Unmarshal([]byte(tt.in), tt.ptr) // tt.ptr edited here\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unmarshal: %v\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(tt.ptr, tt.out) {\n\t\t\tt.Errorf(\"Unmarshal(%#q, %s): have %v, want %v\", tt.in, ptrstr, tt.ptr, tt.out)\n\t\t}\n\t}\n}\n\nvar invalidUnmarshalTests = []struct {\n\tv    interface{}\n\twant string\n}{\n\t{nil, \"json: Unmarshal(nil)\"},\n\t{struct{}{}, \"json: Unmarshal(non-pointer struct {})\"},\n\t{(*int)(nil), \"json: Unmarshal(nil *int)\"},\n}\n\nfunc TestInvalidUnmarshal(t *testing.T) {\n\tbuf := []byte(`{\"a\":\"1\"}`)\n\tfor _, tt := range invalidUnmarshalTests {\n\t\terr := json.Unmarshal(buf, tt.v)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Unmarshal expecting error, got nil\")\n\t\t\tcontinue\n\t\t}\n\t\tif got := err.Error(); got != tt.want {\n\t\t\tt.Errorf(\"Unmarshal = %q; want %q\", got, tt.want)\n\t\t}\n\t}\n}\n\nvar invalidUnmarshalTextTests = []struct {\n\tv    interface{}\n\twant string\n}{\n\t{nil, \"json: Unmarshal(nil)\"},\n\t{struct{}{}, \"json: Unmarshal(non-pointer struct {})\"},\n\t{(*int)(nil), \"json: Unmarshal(nil *int)\"},\n\t{new(net.IP), \"json: cannot unmarshal number into Go value of type *net.IP\"},\n}\n\nfunc TestInvalidUnmarshalText(t *testing.T) {\n\tbuf := []byte(`123`)\n\tfor _, tt := range invalidUnmarshalTextTests {\n\t\terr := json.Unmarshal(buf, tt.v)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Unmarshal expecting error, got nil\")\n\t\t\tcontinue\n\t\t}\n\t\tif got := err.Error(); got != tt.want {\n\t\t\tt.Errorf(\"Unmarshal = %q; want %q\", got, tt.want)\n\t\t}\n\t}\n}\n\n// Test that string option is ignored for invalid types.\n// Issue 9812.\nfunc TestInvalidStringOption(t *testing.T) {\n\tnum := 0\n\titem := struct {\n\t\tT time.Time         `json:\",string\"`\n\t\tM map[string]string `json:\",string\"`\n\t\tS []string          `json:\",string\"`\n\t\tA [1]string         `json:\",string\"`\n\t\tI interface{}       `json:\",string\"`\n\t\tP *int              `json:\",string\"`\n\t}{M: make(map[string]string), S: make([]string, 0), I: num, P: &num}\n\n\tdata, err := json.Marshal(item)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\terr = json.Unmarshal(data, &item)\n\tif err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n}\n\n// Test unmarshal behavior with regards to embedded unexported structs.\n//\n// (Issue 21357) If the embedded struct is a pointer and is unallocated,\n// this returns an error because unmarshal cannot set the field.\n//\n// (Issue 24152) If the embedded struct is given an explicit name,\n// ensure that the normal unmarshal logic does not panic in reflect.\n//\n// (Issue 28145) If the embedded struct is given an explicit name and has\n// exported methods, don't cause a panic trying to get its value.\nfunc TestUnmarshalEmbeddedUnexported(t *testing.T) {\n\ttype (\n\t\tembed1 struct{ Q int }\n\t\tembed2 struct{ Q int }\n\t\tembed3 struct {\n\t\t\tQ int64 `json:\",string\"`\n\t\t}\n\t\tS1 struct {\n\t\t\t*embed1\n\t\t\tR int\n\t\t}\n\t\tS2 struct {\n\t\t\t*embed1\n\t\t\tQ int\n\t\t}\n\t\tS3 struct {\n\t\t\tembed1\n\t\t\tR int\n\t\t}\n\t\tS4 struct {\n\t\t\t*embed1\n\t\t\tembed2\n\t\t}\n\t\tS5 struct {\n\t\t\t*embed3\n\t\t\tR int\n\t\t}\n\t\tS6 struct {\n\t\t\tembed1 `json:\"embed1\"`\n\t\t}\n\t\tS7 struct {\n\t\t\tembed1 `json:\"embed1\"`\n\t\t\tembed2\n\t\t}\n\t\tS8 struct {\n\t\t\tembed1 `json:\"embed1\"`\n\t\t\tembed2 `json:\"embed2\"`\n\t\t\tQ      int\n\t\t}\n\t\tS9 struct {\n\t\t\tunexportedWithMethods `json:\"embed\"`\n\t\t}\n\t)\n\n\ttests := []struct {\n\t\tin  string\n\t\tptr interface{}\n\t\tout interface{}\n\t\terr error\n\t}{{\n\t\t// Error since we cannot set S1.embed1, but still able to set S1.R.\n\t\tin:  `{\"R\":2,\"Q\":1}`,\n\t\tptr: new(S1),\n\t\tout: &S1{R: 2},\n\t\terr: fmt.Errorf(\"json: cannot set embedded pointer to unexported struct: json_test.embed1\"),\n\t}, {\n\t\t// The top level Q field takes precedence.\n\t\tin:  `{\"Q\":1}`,\n\t\tptr: new(S2),\n\t\tout: &S2{Q: 1},\n\t}, {\n\t\t// No issue with non-pointer variant.\n\t\tin:  `{\"R\":2,\"Q\":1}`,\n\t\tptr: new(S3),\n\t\tout: &S3{embed1: embed1{Q: 1}, R: 2},\n\t}, {\n\t\t// No error since both embedded structs have field R, which annihilate each other.\n\t\t// Thus, no attempt is made at setting S4.embed1.\n\t\tin:  `{\"R\":2}`,\n\t\tptr: new(S4),\n\t\tout: new(S4),\n\t}, {\n\t\t// Error since we cannot set S5.embed1, but still able to set S5.R.\n\t\tin:  `{\"R\":2,\"Q\":1}`,\n\t\tptr: new(S5),\n\t\tout: &S5{R: 2},\n\t\terr: fmt.Errorf(\"json: cannot set embedded pointer to unexported struct: json_test.embed3\"),\n\t}, {\n\t\t// Issue 24152, ensure decodeState.indirect does not panic.\n\t\tin:  `{\"embed1\": {\"Q\": 1}}`,\n\t\tptr: new(S6),\n\t\tout: &S6{embed1{1}},\n\t}, {\n\t\t// Issue 24153, check that we can still set forwarded fields even in\n\t\t// the presence of a name conflict.\n\t\t//\n\t\t// This relies on obscure behavior of reflect where it is possible\n\t\t// to set a forwarded exported field on an unexported embedded struct\n\t\t// even though there is a name conflict, even when it would have been\n\t\t// impossible to do so according to Go visibility rules.\n\t\t// Go forbids this because it is ambiguous whether S7.Q refers to\n\t\t// S7.embed1.Q or S7.embed2.Q. Since embed1 and embed2 are unexported,\n\t\t// it should be impossible for an external package to set either Q.\n\t\t//\n\t\t// It is probably okay for a future reflect change to break this.\n\t\tin:  `{\"embed1\": {\"Q\": 1}, \"Q\": 2}`,\n\t\tptr: new(S7),\n\t\tout: &S7{embed1{1}, embed2{2}},\n\t}, {\n\t\t// Issue 24153, similar to the S7 case.\n\t\tin:  `{\"embed1\": {\"Q\": 1}, \"embed2\": {\"Q\": 2}, \"Q\": 3}`,\n\t\tptr: new(S8),\n\t\tout: &S8{embed1{1}, embed2{2}, 3},\n\t}, {\n\t\t// Issue 228145, similar to the cases above.\n\t\tin:  `{\"embed\": {}}`,\n\t\tptr: new(S9),\n\t\tout: &S9{},\n\t}}\n\n\tfor i, tt := range tests {\n\t\terr := json.Unmarshal([]byte(tt.in), tt.ptr)\n\t\tif !equalError(err, tt.err) {\n\t\t\tt.Errorf(\"#%d: %v, want %v\", i, err, tt.err)\n\t\t}\n\t\tif !reflect.DeepEqual(tt.ptr, tt.out) {\n\t\t\tt.Errorf(\"#%d: mismatch\\ngot:  %#+v\\nwant: %#+v\", i, tt.ptr, tt.out)\n\t\t}\n\t}\n}\n\nfunc TestUnmarshalErrorAfterMultipleJSON(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\terr error\n\t}{{\n\t\tin:  `1 false null :`,\n\t\terr: json.NewSyntaxError(\"invalid character '\\x00' looking for beginning of value\", 14),\n\t}, {\n\t\tin:  `1 [] [,]`,\n\t\terr: json.NewSyntaxError(\"invalid character ',' looking for beginning of value\", 6),\n\t}, {\n\t\tin:  `1 [] [true:]`,\n\t\terr: json.NewSyntaxError(\"json: slice unexpected end of JSON input\", 10),\n\t}, {\n\t\tin:  `1  {}    {\"x\"=}`,\n\t\terr: json.NewSyntaxError(\"expected colon after object key\", 13),\n\t}, {\n\t\tin:  `falsetruenul#`,\n\t\terr: json.NewSyntaxError(\"json: invalid character # as null\", 12),\n\t}}\n\tfor i, tt := range tests {\n\t\tdec := json.NewDecoder(strings.NewReader(tt.in))\n\t\tvar err error\n\t\tfor {\n\t\t\tvar v interface{}\n\t\t\tif err = dec.Decode(&v); err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\tt.Errorf(\"#%d: got %#v, want %#v\", i, err, tt.err)\n\t\t}\n\t}\n}\n\ntype unmarshalPanic struct{}\n\nfunc (unmarshalPanic) UnmarshalJSON([]byte) error { panic(0xdead) }\n\nfunc TestUnmarshalPanic(t *testing.T) {\n\tdefer func() {\n\t\tif got := recover(); !reflect.DeepEqual(got, 0xdead) {\n\t\t\tt.Errorf(\"panic() = (%T)(%v), want 0xdead\", got, got)\n\t\t}\n\t}()\n\tjson.Unmarshal([]byte(\"{}\"), &unmarshalPanic{})\n\tt.Fatalf(\"Unmarshal should have panicked\")\n}\n\n// The decoder used to hang if decoding into an interface pointing to its own address.\n// See golang.org/issues/31740.\nfunc TestUnmarshalRecursivePointer(t *testing.T) {\n\tvar v interface{}\n\tv = &v\n\tdata := []byte(`{\"a\": \"b\"}`)\n\n\tif err := json.Unmarshal(data, v); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype textUnmarshalerString string\n\nfunc (m *textUnmarshalerString) UnmarshalText(text []byte) error {\n\t*m = textUnmarshalerString(strings.ToLower(string(text)))\n\treturn nil\n}\n\n// Test unmarshal to a map, where the map key is a user defined type.\n// See golang.org/issues/34437.\nfunc TestUnmarshalMapWithTextUnmarshalerStringKey(t *testing.T) {\n\tvar p map[textUnmarshalerString]string\n\tif err := json.Unmarshal([]byte(`{\"FOO\": \"1\"}`), &p); err != nil {\n\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n\t}\n\n\tif _, ok := p[\"foo\"]; !ok {\n\t\tt.Errorf(`Key \"foo\" does not exist in map: %v`, p)\n\t}\n}\n\nfunc TestUnmarshalRescanLiteralMangledUnquote(t *testing.T) {\n\t// See golang.org/issues/38105.\n\tvar p map[textUnmarshalerString]string\n\tif err := json.Unmarshal([]byte(`{\"开源\":\"12345开源\"}`), &p); err != nil {\n\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n\t}\n\tif _, ok := p[\"开源\"]; !ok {\n\t\tt.Errorf(`Key \"开源\" does not exist in map: %v`, p)\n\t}\n\n\t// See golang.org/issues/38126.\n\ttype T struct {\n\t\tF1 string `json:\"F1,string\"`\n\t}\n\tt1 := T{\"aaa\\tbbb\"}\n\n\tb, err := json.Marshal(t1)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal unexpected error: %v\", err)\n\t}\n\tvar t2 T\n\tif err := json.Unmarshal(b, &t2); err != nil {\n\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n\t}\n\tif t1 != t2 {\n\t\tt.Errorf(\"Marshal and Unmarshal roundtrip mismatch: want %q got %q\", t1, t2)\n\t}\n\n\t// See golang.org/issues/39555.\n\tinput := map[textUnmarshalerString]string{\"FOO\": \"\", `\"`: \"\"}\n\n\tencoded, err := json.Marshal(input)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal unexpected error: %v\", err)\n\t}\n\tvar got map[textUnmarshalerString]string\n\tif err := json.Unmarshal(encoded, &got); err != nil {\n\t\tt.Fatalf(\"Unmarshal unexpected error: %v\", err)\n\t}\n\twant := map[textUnmarshalerString]string{\"foo\": \"\", `\"`: \"\"}\n\tif !reflect.DeepEqual(want, got) {\n\t\tt.Fatalf(\"Unexpected roundtrip result:\\nwant: %q\\ngot:  %q\", want, got)\n\t}\n}\n\nfunc TestUnmarshalMaxDepth(t *testing.T) {\n\ttestcases := []struct {\n\t\tname        string\n\t\tdata        string\n\t\terrMaxDepth bool\n\t}{\n\t\t{\n\t\t\tname:        \"ArrayUnderMaxNestingDepth\",\n\t\t\tdata:        `{\"a\":` + strings.Repeat(`[`, 10000-1) + strings.Repeat(`]`, 10000-1) + `}`,\n\t\t\terrMaxDepth: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"ArrayOverMaxNestingDepth\",\n\t\t\tdata:        `{\"a\":` + strings.Repeat(`[`, 10000) + strings.Repeat(`]`, 10000) + `}`,\n\t\t\terrMaxDepth: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"ArrayOverStackDepth\",\n\t\t\tdata:        `{\"a\":` + strings.Repeat(`[`, 3000000) + strings.Repeat(`]`, 3000000) + `}`,\n\t\t\terrMaxDepth: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"ObjectUnderMaxNestingDepth\",\n\t\t\tdata:        `{\"a\":` + strings.Repeat(`{\"a\":`, 10000-1) + `0` + strings.Repeat(`}`, 10000-1) + `}`,\n\t\t\terrMaxDepth: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"ObjectOverMaxNestingDepth\",\n\t\t\tdata:        `{\"a\":` + strings.Repeat(`{\"a\":`, 10000) + `0` + strings.Repeat(`}`, 10000) + `}`,\n\t\t\terrMaxDepth: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"ObjectOverStackDepth\",\n\t\t\tdata:        `{\"a\":` + strings.Repeat(`{\"a\":`, 3000000) + `0` + strings.Repeat(`}`, 3000000) + `}`,\n\t\t\terrMaxDepth: true,\n\t\t},\n\t}\n\n\ttargets := []struct {\n\t\tname     string\n\t\tnewValue func() interface{}\n\t}{\n\t\t{\n\t\t\tname: \"unstructured\",\n\t\t\tnewValue: func() interface{} {\n\t\t\t\tvar v interface{}\n\t\t\t\treturn &v\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"typed named field\",\n\t\t\tnewValue: func() interface{} {\n\t\t\t\tv := struct {\n\t\t\t\t\tA interface{} `json:\"a\"`\n\t\t\t\t}{}\n\t\t\t\treturn &v\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"typed missing field\",\n\t\t\tnewValue: func() interface{} {\n\t\t\t\tv := struct {\n\t\t\t\t\tB interface{} `json:\"b\"`\n\t\t\t\t}{}\n\t\t\t\treturn &v\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"custom unmarshaler\",\n\t\t\tnewValue: func() interface{} {\n\t\t\t\tv := unmarshaler{}\n\t\t\t\treturn &v\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tfor _, target := range targets {\n\t\t\tt.Run(target.name+\"-\"+tc.name, func(t *testing.T) {\n\t\t\t\tt.Run(\"unmarshal\", func(t *testing.T) {\n\t\t\t\t\terr := json.Unmarshal([]byte(tc.data), target.newValue())\n\t\t\t\t\tif !tc.errMaxDepth {\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\tt.Errorf(\"expected error containing 'exceeded max depth', got none\")\n\t\t\t\t\t\t} else if !strings.Contains(err.Error(), \"exceeded max depth\") {\n\t\t\t\t\t\t\tt.Errorf(\"expected error containing 'exceeded max depth', got: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tt.Run(\"stream\", func(t *testing.T) {\n\t\t\t\t\terr := json.NewDecoder(strings.NewReader(tc.data)).Decode(target.newValue())\n\t\t\t\t\tif !tc.errMaxDepth {\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t\tt.Errorf(\"expected error containing 'exceeded max depth', got none\")\n\t\t\t\t\t\t} else if !strings.Contains(err.Error(), \"exceeded max depth\") {\n\t\t\t\t\t\t\tt.Errorf(\"expected error containing 'exceeded max depth', got: %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestDecodeSlice(t *testing.T) {\n\ttype B struct{ Int int32 }\n\ttype A struct{ B *B }\n\ttype X struct{ A []*A }\n\n\tw1 := &X{}\n\tw2 := &X{}\n\n\tif err := json.Unmarshal([]byte(`{\"a\": [ {\"b\":{\"int\": 42} } ] }`), w1); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tw1addr := uintptr(unsafe.Pointer(w1.A[0].B))\n\n\tif err := json.Unmarshal([]byte(`{\"a\": [ {\"b\":{\"int\": 112} } ] }`), w2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif uintptr(unsafe.Pointer(w1.A[0].B)) != w1addr {\n\t\tt.Fatal(\"wrong addr\")\n\t}\n\tw2addr := uintptr(unsafe.Pointer(w2.A[0].B))\n\tif w1addr == w2addr {\n\t\tt.Fatal(\"invaid address\")\n\t}\n}\n\nfunc TestDecodeMultipleUnmarshal(t *testing.T) {\n\tdata := []byte(`[{\"AA\":{\"X\":[{\"a\": \"A\"},{\"b\": \"B\"}],\"Y\":\"y\",\"Z\":\"z\"},\"BB\":\"bb\"},{\"AA\":{\"X\":[],\"Y\":\"y\",\"Z\":\"z\"},\"BB\":\"bb\"}]`)\n\tvar a []json.RawMessage\n\tif err := json.Unmarshal(data, &a); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(a) != 2 {\n\t\tt.Fatalf(\"failed to decode: got %v\", a)\n\t}\n\tt.Run(\"first\", func(t *testing.T) {\n\t\tdata := a[0]\n\t\tvar v map[string]json.RawMessage\n\t\tif err := json.Unmarshal(data, &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(v[\"AA\"]) != `{\"X\":[{\"a\": \"A\"},{\"b\": \"B\"}],\"Y\":\"y\",\"Z\":\"z\"}` {\n\t\t\tt.Fatalf(\"failed to decode. got %q\", v[\"AA\"])\n\t\t}\n\t\tvar aa map[string]json.RawMessage\n\t\tif err := json.Unmarshal(v[\"AA\"], &aa); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(aa[\"X\"]) != `[{\"a\": \"A\"},{\"b\": \"B\"}]` {\n\t\t\tt.Fatalf(\"failed to decode. got %q\", v[\"X\"])\n\t\t}\n\t\tvar x []json.RawMessage\n\t\tif err := json.Unmarshal(aa[\"X\"], &x); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(x) != 2 {\n\t\t\tt.Fatalf(\"failed to decode: %v\", x)\n\t\t}\n\t\tif string(x[0]) != `{\"a\": \"A\"}` {\n\t\t\tt.Fatal(\"failed to decode\")\n\t\t}\n\t\tif string(x[1]) != `{\"b\": \"B\"}` {\n\t\t\tt.Fatal(\"failed to decode\")\n\t\t}\n\t})\n\tt.Run(\"second\", func(t *testing.T) {\n\t\tdata := a[1]\n\t\tvar v map[string]json.RawMessage\n\t\tif err := json.Unmarshal(data, &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(v[\"AA\"]) != `{\"X\":[],\"Y\":\"y\",\"Z\":\"z\"}` {\n\t\t\tt.Fatalf(\"failed to decode. got %q\", v[\"AA\"])\n\t\t}\n\t\tvar aa map[string]json.RawMessage\n\t\tif err := json.Unmarshal(v[\"AA\"], &aa); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(aa[\"X\"]) != `[]` {\n\t\t\tt.Fatalf(\"failed to decode. got %q\", v[\"X\"])\n\t\t}\n\t\tvar x []json.RawMessage\n\t\tif err := json.Unmarshal(aa[\"X\"], &x); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(x) != 0 {\n\t\t\tt.Fatalf(\"failed to decode: %v\", x)\n\t\t}\n\t})\n}\n\nfunc TestMultipleDecodeWithRawMessage(t *testing.T) {\n\toriginal := []byte(`{\n\t\t\"Body\": {\n\t\t\t\"List\": [\n\t\t\t\t{\n\t\t\t\t\t\"Returns\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Value\": \"10\",\n\t\t\t\t\t\t\t\"nodeType\": \"Literal\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"nodeKind\": \"Return\",\n\t\t\t\t\t\"nodeType\": \"Statement\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"nodeKind\": \"Block\",\n\t\t\t\"nodeType\": \"Statement\"\n\t\t},\n\t\t\"nodeType\": \"Function\"\n\t}`)\n\n\tvar a map[string]json.RawMessage\n\tif err := json.Unmarshal(original, &a); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b map[string]json.RawMessage\n\tif err := json.Unmarshal(a[\"Body\"], &b); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar c []json.RawMessage\n\tif err := json.Unmarshal(b[\"List\"], &c); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar d map[string]json.RawMessage\n\tif err := json.Unmarshal(c[0], &d); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar e []json.RawMessage\n\tif err := json.Unmarshal(d[\"Returns\"], &e); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar f map[string]json.RawMessage\n\tif err := json.Unmarshal(e[0], &f); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\ntype intUnmarshaler int\n\nfunc (u *intUnmarshaler) UnmarshalJSON(b []byte) error {\n\tif *u != 0 && *u != 10 {\n\t\treturn fmt.Errorf(\"failed to decode of slice with int unmarshaler\")\n\t}\n\t*u = 10\n\treturn nil\n}\n\ntype arrayUnmarshaler [5]int\n\nfunc (u *arrayUnmarshaler) UnmarshalJSON(b []byte) error {\n\tif (*u)[0] != 0 && (*u)[0] != 10 {\n\t\treturn fmt.Errorf(\"failed to decode of slice with array unmarshaler\")\n\t}\n\t(*u)[0] = 10\n\treturn nil\n}\n\ntype mapUnmarshaler map[string]int\n\nfunc (u *mapUnmarshaler) UnmarshalJSON(b []byte) error {\n\tif len(*u) != 0 && len(*u) != 1 {\n\t\treturn fmt.Errorf(\"failed to decode of slice with map unmarshaler\")\n\t}\n\t*u = map[string]int{\"a\": 10}\n\treturn nil\n}\n\ntype structUnmarshaler struct {\n\tA        int\n\tnotFirst bool\n}\n\nfunc (u *structUnmarshaler) UnmarshalJSON(b []byte) error {\n\tif !u.notFirst && u.A != 0 {\n\t\treturn fmt.Errorf(\"failed to decode of slice with struct unmarshaler\")\n\t}\n\tu.A = 10\n\tu.notFirst = true\n\treturn nil\n}\n\nfunc TestSliceElemUnmarshaler(t *testing.T) {\n\tt.Run(\"int\", func(t *testing.T) {\n\t\tvar v []intUnmarshaler\n\t\tif err := json.Unmarshal([]byte(`[1,2,3,4,5]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 5 {\n\t\t\tt.Fatalf(\"failed to decode of slice with int unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0] != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with int unmarshaler: %v\", v)\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`[6]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with int unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0] != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with int unmarshaler: %v\", v)\n\t\t}\n\t})\n\tt.Run(\"slice\", func(t *testing.T) {\n\t\tvar v []json.RawMessage\n\t\tif err := json.Unmarshal([]byte(`[1,2,3,4,5]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 5 {\n\t\t\tt.Fatalf(\"failed to decode of slice with slice unmarshaler: %v\", v)\n\t\t}\n\t\tif len(v[0]) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with slice unmarshaler: %v\", v)\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`[6]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with slice unmarshaler: %v\", v)\n\t\t}\n\t\tif len(v[0]) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with slice unmarshaler: %v\", v)\n\t\t}\n\t})\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tvar v []arrayUnmarshaler\n\t\tif err := json.Unmarshal([]byte(`[1,2,3,4,5]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 5 {\n\t\t\tt.Fatalf(\"failed to decode of slice with array unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0][0] != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with array unmarshaler: %v\", v)\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`[6]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with array unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0][0] != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with array unmarshaler: %v\", v)\n\t\t}\n\t})\n\tt.Run(\"map\", func(t *testing.T) {\n\t\tvar v []mapUnmarshaler\n\t\tif err := json.Unmarshal([]byte(`[{\"a\":1},{\"b\":2},{\"c\":3},{\"d\":4},{\"e\":5}]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 5 {\n\t\t\tt.Fatalf(\"failed to decode of slice with map unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0][\"a\"] != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with map unmarshaler: %v\", v)\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`[6]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with map unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0][\"a\"] != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with map unmarshaler: %v\", v)\n\t\t}\n\t})\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\tvar v []structUnmarshaler\n\t\tif err := json.Unmarshal([]byte(`[1,2,3,4,5]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 5 {\n\t\t\tt.Fatalf(\"failed to decode of slice with struct unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0].A != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with struct unmarshaler: %v\", v)\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`[6]`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 1 {\n\t\t\tt.Fatalf(\"failed to decode of slice with struct unmarshaler: %v\", v)\n\t\t}\n\t\tif v[0].A != 10 {\n\t\t\tt.Fatalf(\"failed to decode of slice with struct unmarshaler: %v\", v)\n\t\t}\n\t})\n}\n\ntype keepRefTest struct {\n\tA int\n\tB string\n}\n\nfunc (t *keepRefTest) UnmarshalJSON(data []byte) error {\n\tv := []interface{}{&t.A, &t.B}\n\treturn json.Unmarshal(data, &v)\n}\n\nfunc TestKeepReferenceSlice(t *testing.T) {\n\tvar v keepRefTest\n\tif err := json.Unmarshal([]byte(`[54,\"hello\"]`), &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v.A != 54 {\n\t\tt.Fatal(\"failed to keep reference for slice\")\n\t}\n\tif v.B != \"hello\" {\n\t\tt.Fatal(\"failed to keep reference for slice\")\n\t}\n}\n\nfunc TestInvalidTopLevelValue(t *testing.T) {\n\tt.Run(\"invalid end of buffer\", func(t *testing.T) {\n\t\tvar v struct{}\n\t\tif err := stdjson.Unmarshal([]byte(`{}0`), &v); err == nil {\n\t\t\tt.Fatal(\"expected error\")\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`{}0`), &v); err == nil {\n\t\t\tt.Fatal(\"expected error\")\n\t\t}\n\t})\n\tt.Run(\"invalid object\", func(t *testing.T) {\n\t\tvar v interface{}\n\t\tif err := stdjson.Unmarshal([]byte(`{\"a\":4}{\"a\"5}`), &v); err == nil {\n\t\t\tt.Fatal(\"expected error\")\n\t\t}\n\t\tif err := json.Unmarshal([]byte(`{\"a\":4}{\"a\"5}`), &v); err == nil {\n\t\t\tt.Fatal(\"expected error\")\n\t\t}\n\t})\n}\n\nfunc TestInvalidNumber(t *testing.T) {\n\tt.Run(\"invalid length of number\", func(t *testing.T) {\n\t\tinvalidNum := strings.Repeat(\"1\", 30)\n\t\tt.Run(\"int\", func(t *testing.T) {\n\t\t\tvar v int64\n\t\t\tstdErr := stdjson.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif stdErr == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\terr := json.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\tif stdErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"unexpected error message. expected: %q but got %q\", stdErr.Error(), err.Error())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"uint\", func(t *testing.T) {\n\t\t\tvar v uint64\n\t\t\tstdErr := stdjson.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif stdErr == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\terr := json.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\tif stdErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"unexpected error message. expected: %q but got %q\", stdErr.Error(), err.Error())\n\t\t\t}\n\t\t})\n\n\t})\n\tt.Run(\"invalid number of zero\", func(t *testing.T) {\n\t\tt.Run(\"int\", func(t *testing.T) {\n\t\t\tinvalidNum := strings.Repeat(\"0\", 10)\n\t\t\tvar v int64\n\t\t\tstdErr := stdjson.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif stdErr == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\terr := json.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\tif stdErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"unexpected error message. expected: %q but got %q\", stdErr.Error(), err.Error())\n\t\t\t}\n\t\t})\n\t\tt.Run(\"uint\", func(t *testing.T) {\n\t\t\tinvalidNum := strings.Repeat(\"0\", 10)\n\t\t\tvar v uint64\n\t\t\tstdErr := stdjson.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif stdErr == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\terr := json.Unmarshal([]byte(invalidNum), &v)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t\tif stdErr.Error() != err.Error() {\n\t\t\t\tt.Fatalf(\"unexpected error message. expected: %q but got %q\", stdErr.Error(), err.Error())\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"invalid number\", func(t *testing.T) {\n\t\tt.Run(\"int\", func(t *testing.T) {\n\t\t\tt.Run(\"-0\", func(t *testing.T) {\n\t\t\t\tvar v int64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(`-0`), &v); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(`-0`), &v); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"+0\", func(t *testing.T) {\n\t\t\t\tvar v int64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(`+0`), &v); err == nil {\n\t\t\t\t\tt.Error(\"expected error\")\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(`+0`), &v); err == nil {\n\t\t\t\t\tt.Error(\"expected error\")\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t\tt.Run(\"uint\", func(t *testing.T) {\n\t\t\tt.Run(\"-0\", func(t *testing.T) {\n\t\t\t\tvar v uint64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(`-0`), &v); err == nil {\n\t\t\t\t\tt.Error(\"expected error\")\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(`-0`), &v); err == nil {\n\t\t\t\t\tt.Error(\"expected error\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"+0\", func(t *testing.T) {\n\t\t\t\tvar v uint64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(`+0`), &v); err == nil {\n\t\t\t\t\tt.Error(\"expected error\")\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(`+0`), &v); err == nil {\n\t\t\t\t\tt.Error(\"expected error\")\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t\tt.Run(\"float\", func(t *testing.T) {\n\t\t\tt.Run(\"0.0\", func(t *testing.T) {\n\t\t\t\tvar f float64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(`0.0`), &f); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(`0.0`), &f); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"0.000000000\", func(t *testing.T) {\n\t\t\t\tvar f float64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(`0.000000000`), &f); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(`0.000000000`), &f); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t})\n\t\t\tt.Run(\"repeat zero a lot with float value\", func(t *testing.T) {\n\t\t\t\tvar f float64\n\t\t\t\tif err := stdjson.Unmarshal([]byte(\"0.\"+strings.Repeat(\"0\", 30)), &f); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif err := json.Unmarshal([]byte(\"0.\"+strings.Repeat(\"0\", 30)), &f); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t})\n}\n\ntype someInterface interface {\n\tDoesNotMatter()\n}\n\nfunc TestDecodeUnknownInterface(t *testing.T) {\n\tt.Run(\"unmarshal\", func(t *testing.T) {\n\t\tvar v map[string]someInterface\n\t\tif err := json.Unmarshal([]byte(`{\"a\":null,\"b\":null}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 2 {\n\t\t\tt.Fatalf(\"failed to decode: %v\", v)\n\t\t}\n\t\tif a, exists := v[\"a\"]; a != nil || !exists {\n\t\t\tt.Fatalf(\"failed to decode: %v\", v)\n\t\t}\n\t\tif b, exists := v[\"b\"]; b != nil || !exists {\n\t\t\tt.Fatalf(\"failed to decode: %v\", v)\n\t\t}\n\t})\n\tt.Run(\"stream\", func(t *testing.T) {\n\t\tvar v map[string]someInterface\n\t\tif err := json.NewDecoder(strings.NewReader(`{\"a\":null,\"b\":null}`)).Decode(&v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(v) != 2 {\n\t\t\tt.Fatalf(\"failed to decode: %v\", v)\n\t\t}\n\t\tif a, exists := v[\"a\"]; a != nil || !exists {\n\t\t\tt.Fatalf(\"failed to decode: %v\", v)\n\t\t}\n\t\tif b, exists := v[\"b\"]; b != nil || !exists {\n\t\t\tt.Fatalf(\"failed to decode: %v\", v)\n\t\t}\n\t})\n}\n\nfunc TestDecodeByteSliceNull(t *testing.T) {\n\tt.Run(\"unmarshal\", func(t *testing.T) {\n\t\tvar v1 []byte\n\t\tif err := stdjson.Unmarshal([]byte(`null`), &v1); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar v2 []byte\n\t\tif err := json.Unmarshal([]byte(`null`), &v2); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v1 == nil && v2 != nil || len(v1) != len(v2) {\n\t\t\tt.Fatalf(\"failed to decode null to []byte. expected:%#v but got %#v\", v1, v2)\n\t\t}\n\t})\n\tt.Run(\"stream\", func(t *testing.T) {\n\t\tvar v1 []byte\n\t\tif err := stdjson.NewDecoder(strings.NewReader(`null`)).Decode(&v1); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar v2 []byte\n\t\tif err := json.NewDecoder(strings.NewReader(`null`)).Decode(&v2); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v1 == nil && v2 != nil || len(v1) != len(v2) {\n\t\t\tt.Fatalf(\"failed to decode null to []byte. expected:%#v but got %#v\", v1, v2)\n\t\t}\n\t})\n}\n\nfunc TestDecodeBackSlash(t *testing.T) {\n\tt.Run(\"unmarshal\", func(t *testing.T) {\n\t\tt.Run(\"string\", func(t *testing.T) {\n\t\t\tvar v1 map[string]stdjson.RawMessage\n\t\t\tif err := stdjson.Unmarshal([]byte(`{\"c\":\"\\\\\"}`), &v1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v2 map[string]json.RawMessage\n\t\t\tif err := json.Unmarshal([]byte(`{\"c\":\"\\\\\"}`), &v2); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v1) != len(v2) || !bytes.Equal(v1[\"c\"], v2[\"c\"]) {\n\t\t\t\tt.Fatalf(\"failed to decode backslash: expected %#v but got %#v\", v1, v2)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"array\", func(t *testing.T) {\n\t\t\tvar v1 map[string]stdjson.RawMessage\n\t\t\tif err := stdjson.Unmarshal([]byte(`{\"c\":[\"\\\\\"]}`), &v1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v2 map[string]json.RawMessage\n\t\t\tif err := json.Unmarshal([]byte(`{\"c\":[\"\\\\\"]}`), &v2); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v1) != len(v2) || !bytes.Equal(v1[\"c\"], v2[\"c\"]) {\n\t\t\t\tt.Fatalf(\"failed to decode backslash: expected %#v but got %#v\", v1, v2)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"object\", func(t *testing.T) {\n\t\t\tvar v1 map[string]stdjson.RawMessage\n\t\t\tif err := stdjson.Unmarshal([]byte(`{\"c\":{\"\\\\\":\"\\\\\"}}`), &v1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v2 map[string]json.RawMessage\n\t\t\tif err := json.Unmarshal([]byte(`{\"c\":{\"\\\\\":\"\\\\\"}}`), &v2); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v1) != len(v2) || !bytes.Equal(v1[\"c\"], v2[\"c\"]) {\n\t\t\t\tt.Fatalf(\"failed to decode backslash: expected %#v but got %#v\", v1, v2)\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"stream\", func(t *testing.T) {\n\t\tt.Run(\"string\", func(t *testing.T) {\n\t\t\tvar v1 map[string]stdjson.RawMessage\n\t\t\tif err := stdjson.NewDecoder(strings.NewReader(`{\"c\":\"\\\\\"}`)).Decode(&v1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v2 map[string]json.RawMessage\n\t\t\tif err := json.NewDecoder(strings.NewReader(`{\"c\":\"\\\\\"}`)).Decode(&v2); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v1) != len(v2) || !bytes.Equal(v1[\"c\"], v2[\"c\"]) {\n\t\t\t\tt.Fatalf(\"failed to decode backslash: expected %#v but got %#v\", v1, v2)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"array\", func(t *testing.T) {\n\t\t\tvar v1 map[string]stdjson.RawMessage\n\t\t\tif err := stdjson.NewDecoder(strings.NewReader(`{\"c\":[\"\\\\\"]}`)).Decode(&v1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v2 map[string]json.RawMessage\n\t\t\tif err := json.NewDecoder(strings.NewReader(`{\"c\":[\"\\\\\"]}`)).Decode(&v2); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v1) != len(v2) || !bytes.Equal(v1[\"c\"], v2[\"c\"]) {\n\t\t\t\tt.Fatalf(\"failed to decode backslash: expected %#v but got %#v\", v1, v2)\n\t\t\t}\n\t\t})\n\t\tt.Run(\"object\", func(t *testing.T) {\n\t\t\tvar v1 map[string]stdjson.RawMessage\n\t\t\tif err := stdjson.NewDecoder(strings.NewReader(`{\"c\":{\"\\\\\":\"\\\\\"}}`)).Decode(&v1); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v2 map[string]json.RawMessage\n\t\t\tif err := json.NewDecoder(strings.NewReader(`{\"c\":{\"\\\\\":\"\\\\\"}}`)).Decode(&v2); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v1) != len(v2) || !bytes.Equal(v1[\"c\"], v2[\"c\"]) {\n\t\t\t\tt.Fatalf(\"failed to decode backslash: expected %#v but got %#v\", v1, v2)\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestIssue218(t *testing.T) {\n\ttype A struct {\n\t\tX int\n\t}\n\ttype B struct {\n\t\tY int\n\t}\n\ttype S struct {\n\t\tA *A `json:\"a,omitempty\"`\n\t\tB *B `json:\"b,omitempty\"`\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\tgiven    []S\n\t\texpected []S\n\t}{\n\t\t{\n\t\t\tname: \"A should be correct\",\n\t\t\tgiven: []S{{\n\t\t\t\tA: &A{\n\t\t\t\t\tX: 1,\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: []S{{\n\t\t\t\tA: &A{\n\t\t\t\t\tX: 1,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\tname: \"B should be correct\",\n\t\t\tgiven: []S{{\n\t\t\t\tB: &B{\n\t\t\t\t\tY: 2,\n\t\t\t\t},\n\t\t\t}},\n\t\t\texpected: []S{{\n\t\t\t\tB: &B{\n\t\t\t\t\tY: 2,\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\tif err := json.NewEncoder(&buf).Encode(test.given); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar actual []S\n\t\t\tif err := json.NewDecoder(bytes.NewReader(buf.Bytes())).Decode(&actual); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(test.expected, actual) {\n\t\t\t\tt.Fatalf(\"mismatch value: expected %v but got %v\", test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDecodeEscapedCharField(t *testing.T) {\n\tb := []byte(`{\"\\u6D88\\u606F\":\"\\u6D88\\u606F\"}`)\n\tt.Run(\"unmarshal\", func(t *testing.T) {\n\t\tv := struct {\n\t\t\tMsg string `json:\"消息\"`\n\t\t}{}\n\t\tif err := json.Unmarshal(b, &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal([]byte(v.Msg), []byte(\"消息\")) {\n\t\t\tt.Fatal(\"failed to decode unicode char\")\n\t\t}\n\t})\n\tt.Run(\"stream\", func(t *testing.T) {\n\t\tv := struct {\n\t\t\tMsg string `json:\"消息\"`\n\t\t}{}\n\t\tif err := json.NewDecoder(bytes.NewBuffer(b)).Decode(&v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal([]byte(v.Msg), []byte(\"消息\")) {\n\t\t\tt.Fatal(\"failed to decode unicode char\")\n\t\t}\n\t})\n}\n\ntype unmarshalContextKey struct{}\n\ntype unmarshalContextStructType struct {\n\tv int\n}\n\nfunc (t *unmarshalContextStructType) UnmarshalJSON(ctx context.Context, b []byte) error {\n\tv := ctx.Value(unmarshalContextKey{})\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn fmt.Errorf(\"failed to propagate parent context.Context\")\n\t}\n\tif s != \"hello\" {\n\t\treturn fmt.Errorf(\"failed to propagate parent context.Context\")\n\t}\n\tt.v = 100\n\treturn nil\n}\n\nfunc TestDecodeContextOption(t *testing.T) {\n\tsrc := []byte(\"10\")\n\tbuf := bytes.NewBuffer(src)\n\n\tt.Run(\"UnmarshalContext\", func(t *testing.T) {\n\t\tctx := context.WithValue(context.Background(), unmarshalContextKey{}, \"hello\")\n\t\tvar v unmarshalContextStructType\n\t\tif err := json.UnmarshalContext(ctx, src, &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v.v != 100 {\n\t\t\tt.Fatal(\"failed to decode with context\")\n\t\t}\n\t})\n\tt.Run(\"DecodeContext\", func(t *testing.T) {\n\t\tctx := context.WithValue(context.Background(), unmarshalContextKey{}, \"hello\")\n\t\tvar v unmarshalContextStructType\n\t\tif err := json.NewDecoder(buf).DecodeContext(ctx, &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v.v != 100 {\n\t\t\tt.Fatal(\"failed to decode with context\")\n\t\t}\n\t})\n}\n\nfunc TestIssue251(t *testing.T) {\n\tarray := [3]int{1, 2, 3}\n\terr := stdjson.Unmarshal([]byte(\"[ ]\"), &array)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(array)\n\n\tarray = [3]int{1, 2, 3}\n\terr = json.Unmarshal([]byte(\"[ ]\"), &array)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(array)\n\n\tarray = [3]int{1, 2, 3}\n\terr = json.NewDecoder(strings.NewReader(`[ ]`)).Decode(&array)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(array)\n}\n\nfunc TestDecodeBinaryTypeWithEscapedChar(t *testing.T) {\n\ttype T struct {\n\t\tMsg []byte `json:\"msg\"`\n\t}\n\tcontent := []byte(`{\"msg\":\"aGVsbG8K\\n\"}`)\n\tt.Run(\"unmarshal\", func(t *testing.T) {\n\t\tvar expected T\n\t\tif err := stdjson.Unmarshal(content, &expected); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar got T\n\t\tif err := json.Unmarshal(content, &got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(expected.Msg, got.Msg) {\n\t\t\tt.Fatalf(\"failed to decode binary type with escaped char. expected %q but got %q\", expected.Msg, got.Msg)\n\t\t}\n\t})\n\tt.Run(\"stream\", func(t *testing.T) {\n\t\tvar expected T\n\t\tif err := stdjson.NewDecoder(bytes.NewBuffer(content)).Decode(&expected); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar got T\n\t\tif err := json.NewDecoder(bytes.NewBuffer(content)).Decode(&got); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(expected.Msg, got.Msg) {\n\t\t\tt.Fatalf(\"failed to decode binary type with escaped char. expected %q but got %q\", expected.Msg, got.Msg)\n\t\t}\n\t})\n}\n\nfunc TestIssue282(t *testing.T) {\n\tvar J = []byte(`{\n  \"a\": {},\n  \"b\": {},\n  \"c\": {},\n  \"d\": {},\n  \"e\": {},\n  \"f\": {},\n  \"g\": {},\n  \"h\": {\n    \"m\": \"1\"\n  },\n  \"i\": {}\n}`)\n\n\ttype T4 struct {\n\t\tF0 string\n\t\tF1 string\n\t\tF2 string\n\t\tF3 string\n\t\tF4 string\n\t\tF5 string\n\t\tF6 int\n\t}\n\ttype T3 struct {\n\t\tF0 string\n\t\tF1 T4\n\t}\n\ttype T2 struct {\n\t\tF0 string `json:\"m\"`\n\t\tF1 T3\n\t}\n\ttype T0 map[string]T2\n\n\t// T2 size is 136 bytes. This is indirect type.\n\tvar v T0\n\tif err := json.Unmarshal(J, &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v[\"h\"].F0 != \"1\" {\n\t\tt.Fatalf(\"failed to assign map value\")\n\t}\n}\n\nfunc TestDecodeStructFieldMap(t *testing.T) {\n\ttype Foo struct {\n\t\tBar map[float64]float64 `json:\"bar,omitempty\"`\n\t}\n\tvar v Foo\n\tif err := json.Unmarshal([]byte(`{\"name\":\"test\"}`), &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v.Bar != nil {\n\t\tt.Fatalf(\"failed to decode v.Bar = %+v\", v.Bar)\n\t}\n}\n\ntype issue303 struct {\n\tCount int\n\tType  string\n\tValue interface{}\n}\n\nfunc (t *issue303) UnmarshalJSON(b []byte) error {\n\ttype tmpType issue303\n\n\twrapped := struct {\n\t\tValue json.RawMessage\n\t\ttmpType\n\t}{}\n\tif err := json.Unmarshal(b, &wrapped); err != nil {\n\t\treturn err\n\t}\n\t*t = issue303(wrapped.tmpType)\n\n\tswitch wrapped.Type {\n\tcase \"string\":\n\t\tvar str string\n\t\tif err := json.Unmarshal(wrapped.Value, &str); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt.Value = str\n\t}\n\treturn nil\n}\n\nfunc TestIssue303(t *testing.T) {\n\tvar v issue303\n\tif err := json.Unmarshal([]byte(`{\"Count\":7,\"Type\":\"string\",\"Value\":\"hello\"}`), &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v.Count != 7 || v.Type != \"string\" || v.Value != \"hello\" {\n\t\tt.Fatalf(\"failed to decode. count = %d type = %s value = %v\", v.Count, v.Type, v.Value)\n\t}\n}\n\nfunc TestIssue327(t *testing.T) {\n\tvar v struct {\n\t\tDate time.Time `json:\"date\"`\n\t}\n\tdec := json.NewDecoder(strings.NewReader(`{\"date\": \"2021-11-23T13:47:30+01:00\"})`))\n\tif err := dec.DecodeContext(context.Background(), &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := \"2021-11-23T13:47:30+01:00\"\n\tif got := v.Date.Format(time.RFC3339); got != expected {\n\t\tt.Fatalf(\"failed to decode. expected %q but got %q\", expected, got)\n\t}\n}\n\nfunc TestIssue337(t *testing.T) {\n\tin := strings.Repeat(\" \", 510) + \"{}\"\n\tvar m map[string]string\n\tif err := json.NewDecoder(strings.NewReader(in)).Decode(&m); err != nil {\n\t\tt.Fatal(\"unexpected error:\", err)\n\t}\n\tif len(m) != 0 {\n\t\tt.Fatal(\"unexpected result\", m)\n\t}\n}\n\nfunc Benchmark306(b *testing.B) {\n\ttype T0 struct {\n\t\tStr string\n\t}\n\tin := []byte(`{\"Str\":\"` + strings.Repeat(`abcd\\\"`, 10000) + `\"}`)\n\tb.Run(\"stdjson\", func(b *testing.B) {\n\t\tvar x T0\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tstdjson.Unmarshal(in, &x)\n\t\t}\n\t})\n\tb.Run(\"go-json\", func(b *testing.B) {\n\t\tvar x T0\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tjson.Unmarshal(in, &x)\n\t\t}\n\t})\n}\n\nfunc TestIssue348(t *testing.T) {\n\tin := strings.Repeat(\"[\"+strings.Repeat(\",1000\", 500)[1:]+\"]\", 2)\n\tdec := json.NewDecoder(strings.NewReader(in))\n\tfor dec.More() {\n\t\tvar foo interface{}\n\t\tif err := dec.Decode(&foo); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n}\n\ntype issue342 string\n\nfunc (t *issue342) UnmarshalJSON(b []byte) error {\n\tpanic(\"unreachable\")\n}\n\nfunc TestIssue342(t *testing.T) {\n\tvar v map[issue342]int\n\tin := []byte(`{\"a\":1}`)\n\tif err := json.Unmarshal(in, &v); err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\texpected := 1\n\tif got := v[\"a\"]; got != expected {\n\t\tt.Errorf(\"unexpected result: got(%v) != expected(%v)\", got, expected)\n\t}\n}\n\nfunc TestIssue360(t *testing.T) {\n\tvar uints []uint8\n\terr := json.Unmarshal([]byte(`[0, 1, 2]`), &uints)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tif len(uints) != 3 || !(uints[0] == 0 && uints[1] == 1 && uints[2] == 2) {\n\t\tt.Errorf(\"unexpected result: %v\", uints)\n\t}\n}\n\nfunc TestIssue359(t *testing.T) {\n\tvar a interface{} = 1\n\tvar b interface{} = &a\n\tvar c interface{} = &b\n\tv, err := json.Marshal(c)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tif string(v) != \"1\" {\n\t\tt.Errorf(\"unexpected result: %v\", string(v))\n\t}\n}\n\nfunc TestIssue364(t *testing.T) {\n\tvar v struct {\n\t\tDescription string `json:\"description\"`\n\t}\n\terr := json.Unmarshal([]byte(`{\"description\":\"\\uD83D\\uDE87 Toledo is a metro station\"}`), &v)\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\tif v.Description != \"🚇 Toledo is a metro station\" {\n\t\tt.Errorf(\"unexpected result: %v\", v.Description)\n\t}\n}\n\nfunc TestIssue362(t *testing.T) {\n\ttype AliasedPrimitive int\n\ttype Combiner struct {\n\t\tSomeField int\n\t\tAliasedPrimitive\n\t}\n\toriginalCombiner := Combiner{AliasedPrimitive: 7}\n\tb, err := json.Marshal(originalCombiner)\n\tassertErr(t, err)\n\tnewCombiner := Combiner{}\n\terr = json.Unmarshal(b, &newCombiner)\n\tassertErr(t, err)\n\tassertEq(t, \"TestEmbeddedPrimitiveAlias\", originalCombiner, newCombiner)\n}\n\nfunc TestIssue335(t *testing.T) {\n\tvar v []string\n\tin := []byte(`[\"\\u\",\"A\"]`)\n\terr := json.Unmarshal(in, &v)\n\tif err == nil {\n\t\tt.Errorf(\"unexpected success\")\n\t}\n}\n\nfunc TestIssue372(t *testing.T) {\n\ttype A int\n\ttype T struct {\n\t\t_ int\n\t\t*A\n\t}\n\tvar v T\n\terr := json.Unmarshal([]byte(`{\"A\":7}`), &v)\n\tassertErr(t, err)\n\n\tgot := *v.A\n\texpected := A(7)\n\tif got != expected {\n\t\tt.Errorf(\"unexpected result: %v != %v\", got, expected)\n\t}\n}\n\ntype issue384 struct{}\n\nfunc (t *issue384) UnmarshalJSON(b []byte) error {\n\treturn nil\n}\n\nfunc TestIssue384(t *testing.T) {\n\ttestcases := []string{\n\t\t`{\"data\": \"` + strings.Repeat(\"-\", 500) + `\\\"\"}`,\n\t\t`[\"` + strings.Repeat(\"-\", 508) + `\\\"\"]`,\n\t}\n\tfor _, tc := range testcases {\n\t\tdec := json.NewDecoder(strings.NewReader(tc))\n\t\tvar v issue384\n\t\tif err := dec.Decode(&v); err != nil {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestIssue408(t *testing.T) {\n\ttype T struct {\n\t\tArr [2]int32 `json:\"arr\"`\n\t}\n\tvar v T\n\tif err := json.Unmarshal([]byte(`{\"arr\": [1,2]}`), &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestIssue416(t *testing.T) {\n\tb := []byte(`{\"Сообщение\":\"Текст\"}`)\n\n\ttype T struct {\n\t\tMsg string `json:\"Сообщение\"`\n\t}\n\tvar x T\n\terr := json.Unmarshal(b, &x)\n\tassertErr(t, err)\n\tassertEq(t, \"unexpected result\", \"Текст\", x.Msg)\n}\n\nfunc TestIssue429(t *testing.T) {\n\tvar x struct {\n\t\tN int32\n\t}\n\tfor _, b := range []string{\n\t\t`{\"\\u\"`,\n\t\t`{\"\\u0\"`,\n\t\t`{\"\\u00\"`,\n\t} {\n\t\tif err := json.Unmarshal([]byte(b), &x); err == nil {\n\t\t\tt.Errorf(\"unexpected success\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.25390625,
          "content": "version: '2'\nservices:\n  go-json:\n    image: golang:1.18\n    volumes:\n      - '.:/go/src/go-json'\n    deploy:\n      resources:\n        limits:\n          memory: 620M\n    working_dir: /go/src/go-json\n    command: |\n      sh -c \"go test -c . && ls go-json.test\"\n"
        },
        {
          "name": "encode.go",
          "type": "blob",
          "size": 8.8486328125,
          "content": "package json\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"os\"\n\t\"unsafe\"\n\n\t\"github.com/goccy/go-json/internal/encoder\"\n\t\"github.com/goccy/go-json/internal/encoder/vm\"\n\t\"github.com/goccy/go-json/internal/encoder/vm_color\"\n\t\"github.com/goccy/go-json/internal/encoder/vm_color_indent\"\n\t\"github.com/goccy/go-json/internal/encoder/vm_indent\"\n)\n\n// An Encoder writes JSON values to an output stream.\ntype Encoder struct {\n\tw                 io.Writer\n\tenabledIndent     bool\n\tenabledHTMLEscape bool\n\tprefix            string\n\tindentStr         string\n}\n\n// NewEncoder returns a new encoder that writes to w.\nfunc NewEncoder(w io.Writer) *Encoder {\n\treturn &Encoder{w: w, enabledHTMLEscape: true}\n}\n\n// Encode writes the JSON encoding of v to the stream, followed by a newline character.\n//\n// See the documentation for Marshal for details about the conversion of Go values to JSON.\nfunc (e *Encoder) Encode(v interface{}) error {\n\treturn e.EncodeWithOption(v)\n}\n\n// EncodeWithOption call Encode with EncodeOption.\nfunc (e *Encoder) EncodeWithOption(v interface{}, optFuncs ...EncodeOptionFunc) error {\n\tctx := encoder.TakeRuntimeContext()\n\tctx.Option.Flag = 0\n\n\terr := e.encodeWithOption(ctx, v, optFuncs...)\n\n\tencoder.ReleaseRuntimeContext(ctx)\n\treturn err\n}\n\n// EncodeContext call Encode with context.Context and EncodeOption.\nfunc (e *Encoder) EncodeContext(ctx context.Context, v interface{}, optFuncs ...EncodeOptionFunc) error {\n\trctx := encoder.TakeRuntimeContext()\n\trctx.Option.Flag = 0\n\trctx.Option.Flag |= encoder.ContextOption\n\trctx.Option.Context = ctx\n\n\terr := e.encodeWithOption(rctx, v, optFuncs...) //nolint: contextcheck\n\n\tencoder.ReleaseRuntimeContext(rctx)\n\treturn err\n}\n\nfunc (e *Encoder) encodeWithOption(ctx *encoder.RuntimeContext, v interface{}, optFuncs ...EncodeOptionFunc) error {\n\tif e.enabledHTMLEscape {\n\t\tctx.Option.Flag |= encoder.HTMLEscapeOption\n\t}\n\tctx.Option.Flag |= encoder.NormalizeUTF8Option\n\tctx.Option.DebugOut = os.Stdout\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(ctx.Option)\n\t}\n\tvar (\n\t\tbuf []byte\n\t\terr error\n\t)\n\tif e.enabledIndent {\n\t\tbuf, err = encodeIndent(ctx, v, e.prefix, e.indentStr)\n\t} else {\n\t\tbuf, err = encode(ctx, v)\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif e.enabledIndent {\n\t\tbuf = buf[:len(buf)-2]\n\t} else {\n\t\tbuf = buf[:len(buf)-1]\n\t}\n\tbuf = append(buf, '\\n')\n\tif _, err := e.w.Write(buf); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings.\n// The default behavior is to escape &, <, and > to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that can arise when embedding JSON in HTML.\n//\n// In non-HTML settings where the escaping interferes with the readability of the output, SetEscapeHTML(false) disables this behavior.\nfunc (e *Encoder) SetEscapeHTML(on bool) {\n\te.enabledHTMLEscape = on\n}\n\n// SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent).\n// Calling SetIndent(\"\", \"\") disables indentation.\nfunc (e *Encoder) SetIndent(prefix, indent string) {\n\tif prefix == \"\" && indent == \"\" {\n\t\te.enabledIndent = false\n\t\treturn\n\t}\n\te.prefix = prefix\n\te.indentStr = indent\n\te.enabledIndent = true\n}\n\nfunc marshalContext(ctx context.Context, v interface{}, optFuncs ...EncodeOptionFunc) ([]byte, error) {\n\trctx := encoder.TakeRuntimeContext()\n\trctx.Option.Flag = 0\n\trctx.Option.Flag = encoder.HTMLEscapeOption | encoder.NormalizeUTF8Option | encoder.ContextOption\n\trctx.Option.Context = ctx\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(rctx.Option)\n\t}\n\n\tbuf, err := encode(rctx, v) //nolint: contextcheck\n\tif err != nil {\n\t\tencoder.ReleaseRuntimeContext(rctx)\n\t\treturn nil, err\n\t}\n\n\t// this line exists to escape call of `runtime.makeslicecopy` .\n\t// if use `make([]byte, len(buf)-1)` and `copy(copied, buf)`,\n\t// dst buffer size and src buffer size are differrent.\n\t// in this case, compiler uses `runtime.makeslicecopy`, but it is slow.\n\tbuf = buf[:len(buf)-1]\n\tcopied := make([]byte, len(buf))\n\tcopy(copied, buf)\n\n\tencoder.ReleaseRuntimeContext(rctx)\n\treturn copied, nil\n}\n\nfunc marshal(v interface{}, optFuncs ...EncodeOptionFunc) ([]byte, error) {\n\tctx := encoder.TakeRuntimeContext()\n\n\tctx.Option.Flag = 0\n\tctx.Option.Flag |= (encoder.HTMLEscapeOption | encoder.NormalizeUTF8Option)\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(ctx.Option)\n\t}\n\n\tbuf, err := encode(ctx, v)\n\tif err != nil {\n\t\tencoder.ReleaseRuntimeContext(ctx)\n\t\treturn nil, err\n\t}\n\n\t// this line exists to escape call of `runtime.makeslicecopy` .\n\t// if use `make([]byte, len(buf)-1)` and `copy(copied, buf)`,\n\t// dst buffer size and src buffer size are differrent.\n\t// in this case, compiler uses `runtime.makeslicecopy`, but it is slow.\n\tbuf = buf[:len(buf)-1]\n\tcopied := make([]byte, len(buf))\n\tcopy(copied, buf)\n\n\tencoder.ReleaseRuntimeContext(ctx)\n\treturn copied, nil\n}\n\nfunc marshalNoEscape(v interface{}) ([]byte, error) {\n\tctx := encoder.TakeRuntimeContext()\n\n\tctx.Option.Flag = 0\n\tctx.Option.Flag |= (encoder.HTMLEscapeOption | encoder.NormalizeUTF8Option)\n\n\tbuf, err := encodeNoEscape(ctx, v)\n\tif err != nil {\n\t\tencoder.ReleaseRuntimeContext(ctx)\n\t\treturn nil, err\n\t}\n\n\t// this line exists to escape call of `runtime.makeslicecopy` .\n\t// if use `make([]byte, len(buf)-1)` and `copy(copied, buf)`,\n\t// dst buffer size and src buffer size are differrent.\n\t// in this case, compiler uses `runtime.makeslicecopy`, but it is slow.\n\tbuf = buf[:len(buf)-1]\n\tcopied := make([]byte, len(buf))\n\tcopy(copied, buf)\n\n\tencoder.ReleaseRuntimeContext(ctx)\n\treturn copied, nil\n}\n\nfunc marshalIndent(v interface{}, prefix, indent string, optFuncs ...EncodeOptionFunc) ([]byte, error) {\n\tctx := encoder.TakeRuntimeContext()\n\n\tctx.Option.Flag = 0\n\tctx.Option.Flag |= (encoder.HTMLEscapeOption | encoder.NormalizeUTF8Option | encoder.IndentOption)\n\tfor _, optFunc := range optFuncs {\n\t\toptFunc(ctx.Option)\n\t}\n\n\tbuf, err := encodeIndent(ctx, v, prefix, indent)\n\tif err != nil {\n\t\tencoder.ReleaseRuntimeContext(ctx)\n\t\treturn nil, err\n\t}\n\n\tbuf = buf[:len(buf)-2]\n\tcopied := make([]byte, len(buf))\n\tcopy(copied, buf)\n\n\tencoder.ReleaseRuntimeContext(ctx)\n\treturn copied, nil\n}\n\nfunc encode(ctx *encoder.RuntimeContext, v interface{}) ([]byte, error) {\n\tb := ctx.Buf[:0]\n\tif v == nil {\n\t\tb = encoder.AppendNull(ctx, b)\n\t\tb = encoder.AppendComma(ctx, b)\n\t\treturn b, nil\n\t}\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\ttyp := header.typ\n\n\ttypeptr := uintptr(unsafe.Pointer(typ))\n\tcodeSet, err := encoder.CompileToGetCodeSet(ctx, typeptr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := uintptr(header.ptr)\n\tctx.Init(p, codeSet.CodeLength)\n\tctx.KeepRefs = append(ctx.KeepRefs, header.ptr)\n\n\tbuf, err := encodeRunCode(ctx, b, codeSet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tctx.Buf = buf\n\treturn buf, nil\n}\n\nfunc encodeNoEscape(ctx *encoder.RuntimeContext, v interface{}) ([]byte, error) {\n\tb := ctx.Buf[:0]\n\tif v == nil {\n\t\tb = encoder.AppendNull(ctx, b)\n\t\tb = encoder.AppendComma(ctx, b)\n\t\treturn b, nil\n\t}\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\ttyp := header.typ\n\n\ttypeptr := uintptr(unsafe.Pointer(typ))\n\tcodeSet, err := encoder.CompileToGetCodeSet(ctx, typeptr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := uintptr(header.ptr)\n\tctx.Init(p, codeSet.CodeLength)\n\tbuf, err := encodeRunCode(ctx, b, codeSet)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx.Buf = buf\n\treturn buf, nil\n}\n\nfunc encodeIndent(ctx *encoder.RuntimeContext, v interface{}, prefix, indent string) ([]byte, error) {\n\tb := ctx.Buf[:0]\n\tif v == nil {\n\t\tb = encoder.AppendNull(ctx, b)\n\t\tb = encoder.AppendCommaIndent(ctx, b)\n\t\treturn b, nil\n\t}\n\theader := (*emptyInterface)(unsafe.Pointer(&v))\n\ttyp := header.typ\n\n\ttypeptr := uintptr(unsafe.Pointer(typ))\n\tcodeSet, err := encoder.CompileToGetCodeSet(ctx, typeptr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := uintptr(header.ptr)\n\tctx.Init(p, codeSet.CodeLength)\n\tbuf, err := encodeRunIndentCode(ctx, b, codeSet, prefix, indent)\n\n\tctx.KeepRefs = append(ctx.KeepRefs, header.ptr)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx.Buf = buf\n\treturn buf, nil\n}\n\nfunc encodeRunCode(ctx *encoder.RuntimeContext, b []byte, codeSet *encoder.OpcodeSet) ([]byte, error) {\n\tif (ctx.Option.Flag & encoder.DebugOption) != 0 {\n\t\tif (ctx.Option.Flag & encoder.ColorizeOption) != 0 {\n\t\t\treturn vm_color.DebugRun(ctx, b, codeSet)\n\t\t}\n\t\treturn vm.DebugRun(ctx, b, codeSet)\n\t}\n\tif (ctx.Option.Flag & encoder.ColorizeOption) != 0 {\n\t\treturn vm_color.Run(ctx, b, codeSet)\n\t}\n\treturn vm.Run(ctx, b, codeSet)\n}\n\nfunc encodeRunIndentCode(ctx *encoder.RuntimeContext, b []byte, codeSet *encoder.OpcodeSet, prefix, indent string) ([]byte, error) {\n\tctx.Prefix = []byte(prefix)\n\tctx.IndentStr = []byte(indent)\n\tif (ctx.Option.Flag & encoder.DebugOption) != 0 {\n\t\tif (ctx.Option.Flag & encoder.ColorizeOption) != 0 {\n\t\t\treturn vm_color_indent.DebugRun(ctx, b, codeSet)\n\t\t}\n\t\treturn vm_indent.DebugRun(ctx, b, codeSet)\n\t}\n\tif (ctx.Option.Flag & encoder.ColorizeOption) != 0 {\n\t\treturn vm_color_indent.Run(ctx, b, codeSet)\n\t}\n\treturn vm_indent.Run(ctx, b, codeSet)\n}\n"
        },
        {
          "name": "encode_test.go",
          "type": "blob",
          "size": 63.185546875,
          "content": "package json_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding\"\n\tstdjson \"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"math\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/goccy/go-json\"\n)\n\ntype recursiveT struct {\n\tA *recursiveT `json:\"a,omitempty\"`\n\tB *recursiveU `json:\"b,omitempty\"`\n\tC *recursiveU `json:\"c,omitempty\"`\n\tD string      `json:\"d,omitempty\"`\n}\n\ntype recursiveU struct {\n\tT *recursiveT `json:\"t,omitempty\"`\n}\n\nfunc Test_Marshal(t *testing.T) {\n\tt.Run(\"int\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(-10)\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"int\", `-10`, string(bytes))\n\t})\n\tt.Run(\"int8\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(int8(-11))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"int8\", `-11`, string(bytes))\n\t})\n\tt.Run(\"int16\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(int16(-12))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"int16\", `-12`, string(bytes))\n\t})\n\tt.Run(\"int32\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(int32(-13))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"int32\", `-13`, string(bytes))\n\t})\n\tt.Run(\"int64\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(int64(-14))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"int64\", `-14`, string(bytes))\n\t})\n\tt.Run(\"uint\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(uint(10))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"uint\", `10`, string(bytes))\n\t})\n\tt.Run(\"uint8\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(uint8(11))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"uint8\", `11`, string(bytes))\n\t})\n\tt.Run(\"uint16\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(uint16(12))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"uint16\", `12`, string(bytes))\n\t})\n\tt.Run(\"uint32\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(uint32(13))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"uint32\", `13`, string(bytes))\n\t})\n\tt.Run(\"uint64\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(uint64(14))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"uint64\", `14`, string(bytes))\n\t})\n\tt.Run(\"float32\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(float32(3.14))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"float32\", `3.14`, string(bytes))\n\t})\n\tt.Run(\"float64\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(float64(3.14))\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"float64\", `3.14`, string(bytes))\n\t})\n\tt.Run(\"bool\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(true)\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"bool\", `true`, string(bytes))\n\t})\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(\"hello world\")\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"string\", `\"hello world\"`, string(bytes))\n\t})\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(struct {\n\t\t\tA int    `json:\"a\"`\n\t\t\tB uint   `json:\"b\"`\n\t\t\tC string `json:\"c\"`\n\t\t\tD int    `json:\"-\"`  // ignore field\n\t\t\ta int    `json:\"aa\"` // private field\n\t\t}{\n\t\t\tA: -1,\n\t\t\tB: 1,\n\t\t\tC: \"hello world\",\n\t\t})\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"struct\", `{\"a\":-1,\"b\":1,\"c\":\"hello world\"}`, string(bytes))\n\t\tt.Run(\"null\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA *struct{} `json:\"a\"`\n\t\t\t}\n\t\t\tvar v T\n\t\t\tbytes, err := json.Marshal(&v)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"struct\", `{\"a\":null}`, string(bytes))\n\t\t})\n\t\tt.Run(\"recursive\", func(t *testing.T) {\n\t\t\tbytes, err := json.Marshal(recursiveT{\n\t\t\t\tA: &recursiveT{\n\t\t\t\t\tB: &recursiveU{\n\t\t\t\t\t\tT: &recursiveT{\n\t\t\t\t\t\t\tD: \"hello\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tC: &recursiveU{\n\t\t\t\t\t\tT: &recursiveT{\n\t\t\t\t\t\t\tD: \"world\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t})\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"recursive\", `{\"a\":{\"b\":{\"t\":{\"d\":\"hello\"}},\"c\":{\"t\":{\"d\":\"world\"}}}}`, string(bytes))\n\t\t})\n\t\tt.Run(\"embedded\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA string `json:\"a\"`\n\t\t\t}\n\t\t\ttype U struct {\n\t\t\t\t*T\n\t\t\t\tB string `json:\"b\"`\n\t\t\t}\n\t\t\ttype T2 struct {\n\t\t\t\tA string `json:\"a,omitempty\"`\n\t\t\t}\n\t\t\ttype U2 struct {\n\t\t\t\t*T2\n\t\t\t\tB string `json:\"b,omitempty\"`\n\t\t\t}\n\t\t\tt.Run(\"exists field\", func(t *testing.T) {\n\t\t\t\tbytes, err := json.Marshal(&U{\n\t\t\t\t\tT: &T{\n\t\t\t\t\t\tA: \"aaa\",\n\t\t\t\t\t},\n\t\t\t\t\tB: \"bbb\",\n\t\t\t\t})\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"embedded\", `{\"a\":\"aaa\",\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\tt.Run(\"omitempty\", func(t *testing.T) {\n\t\t\t\t\tbytes, err := json.Marshal(&U2{\n\t\t\t\t\t\tT2: &T2{\n\t\t\t\t\t\t\tA: \"aaa\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tB: \"bbb\",\n\t\t\t\t\t})\n\t\t\t\t\tassertErr(t, err)\n\t\t\t\t\tassertEq(t, \"embedded\", `{\"a\":\"aaa\",\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\t})\n\t\t\t})\n\t\t\tt.Run(\"none field\", func(t *testing.T) {\n\t\t\t\tbytes, err := json.Marshal(&U{\n\t\t\t\t\tB: \"bbb\",\n\t\t\t\t})\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"embedded\", `{\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\tt.Run(\"omitempty\", func(t *testing.T) {\n\t\t\t\t\tbytes, err := json.Marshal(&U2{\n\t\t\t\t\t\tB: \"bbb\",\n\t\t\t\t\t})\n\t\t\t\t\tassertErr(t, err)\n\t\t\t\t\tassertEq(t, \"embedded\", `{\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"embedded with tag\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA string `json:\"a\"`\n\t\t\t}\n\t\t\ttype U struct {\n\t\t\t\t*T `json:\"t\"`\n\t\t\t\tB  string `json:\"b\"`\n\t\t\t}\n\t\t\ttype T2 struct {\n\t\t\t\tA string `json:\"a,omitempty\"`\n\t\t\t}\n\t\t\ttype U2 struct {\n\t\t\t\t*T2 `json:\"t,omitempty\"`\n\t\t\t\tB   string `json:\"b,omitempty\"`\n\t\t\t}\n\t\t\tt.Run(\"exists field\", func(t *testing.T) {\n\t\t\t\tbytes, err := json.Marshal(&U{\n\t\t\t\t\tT: &T{\n\t\t\t\t\t\tA: \"aaa\",\n\t\t\t\t\t},\n\t\t\t\t\tB: \"bbb\",\n\t\t\t\t})\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"embedded\", `{\"t\":{\"a\":\"aaa\"},\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\tt.Run(\"omitempty\", func(t *testing.T) {\n\t\t\t\t\tbytes, err := json.Marshal(&U2{\n\t\t\t\t\t\tT2: &T2{\n\t\t\t\t\t\t\tA: \"aaa\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tB: \"bbb\",\n\t\t\t\t\t})\n\t\t\t\t\tassertErr(t, err)\n\t\t\t\t\tassertEq(t, \"embedded\", `{\"t\":{\"a\":\"aaa\"},\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tt.Run(\"none field\", func(t *testing.T) {\n\t\t\t\tbytes, err := json.Marshal(&U{\n\t\t\t\t\tB: \"bbb\",\n\t\t\t\t})\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"embedded\", `{\"t\":null,\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\tt.Run(\"omitempty\", func(t *testing.T) {\n\t\t\t\t\tbytes, err := json.Marshal(&U2{\n\t\t\t\t\t\tB: \"bbb\",\n\t\t\t\t\t})\n\t\t\t\t\tassertErr(t, err)\n\t\t\t\t\tassertEq(t, \"embedded\", `{\"b\":\"bbb\"}`, string(bytes))\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\tt.Run(\"omitempty\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA int                    `json:\",omitempty\"`\n\t\t\t\tB int8                   `json:\",omitempty\"`\n\t\t\t\tC int16                  `json:\",omitempty\"`\n\t\t\t\tD int32                  `json:\",omitempty\"`\n\t\t\t\tE int64                  `json:\",omitempty\"`\n\t\t\t\tF uint                   `json:\",omitempty\"`\n\t\t\t\tG uint8                  `json:\",omitempty\"`\n\t\t\t\tH uint16                 `json:\",omitempty\"`\n\t\t\t\tI uint32                 `json:\",omitempty\"`\n\t\t\t\tJ uint64                 `json:\",omitempty\"`\n\t\t\t\tK float32                `json:\",omitempty\"`\n\t\t\t\tL float64                `json:\",omitempty\"`\n\t\t\t\tO string                 `json:\",omitempty\"`\n\t\t\t\tP bool                   `json:\",omitempty\"`\n\t\t\t\tQ []int                  `json:\",omitempty\"`\n\t\t\t\tR map[string]interface{} `json:\",omitempty\"`\n\t\t\t\tS *struct{}              `json:\",omitempty\"`\n\t\t\t\tT int                    `json:\"t,omitempty\"`\n\t\t\t}\n\t\t\tvar v T\n\t\t\tv.T = 1\n\t\t\tbytes, err := json.Marshal(&v)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"struct\", `{\"t\":1}`, string(bytes))\n\t\t\tt.Run(\"int\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int `json:\"a,omitempty\"`\n\t\t\t\t\tB int `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 1\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"int\", `{\"b\":1}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"int8\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int  `json:\"a,omitempty\"`\n\t\t\t\t\tB int8 `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 1\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"int8\", `{\"b\":1}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"int16\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int   `json:\"a,omitempty\"`\n\t\t\t\t\tB int16 `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 1\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"int16\", `{\"b\":1}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"int32\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int   `json:\"a,omitempty\"`\n\t\t\t\t\tB int32 `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 1\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"int32\", `{\"b\":1}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"int64\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int   `json:\"a,omitempty\"`\n\t\t\t\t\tB int64 `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 1\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"int64\", `{\"b\":1}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"string\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int    `json:\"a,omitempty\"`\n\t\t\t\t\tB string `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = \"b\"\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"string\", `{\"b\":\"b\"}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"float32\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int     `json:\"a,omitempty\"`\n\t\t\t\t\tB float32 `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 1.1\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"float32\", `{\"b\":1.1}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"float64\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int     `json:\"a,omitempty\"`\n\t\t\t\t\tB float64 `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = 3.14\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"float64\", `{\"b\":3.14}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"slice\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int   `json:\"a,omitempty\"`\n\t\t\t\t\tB []int `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = []int{1, 2, 3}\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"slice\", `{\"b\":[1,2,3]}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"array\", func(t *testing.T) {\n\t\t\t\tvar v struct {\n\t\t\t\t\tA int    `json:\"a,omitempty\"`\n\t\t\t\t\tB [2]int `json:\"b\"`\n\t\t\t\t}\n\t\t\t\tv.B = [2]int{1, 2}\n\t\t\t\tbytes, err := json.Marshal(&v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"array\", `{\"b\":[1,2]}`, string(bytes))\n\t\t\t})\n\t\t\tt.Run(\"map\", func(t *testing.T) {\n\t\t\t\tv := new(struct {\n\t\t\t\t\tA int                    `json:\"a,omitempty\"`\n\t\t\t\t\tB map[string]interface{} `json:\"b\"`\n\t\t\t\t})\n\t\t\t\tv.B = map[string]interface{}{\"c\": 1}\n\t\t\t\tbytes, err := json.Marshal(v)\n\t\t\t\tassertErr(t, err)\n\t\t\t\tassertEq(t, \"array\", `{\"b\":{\"c\":1}}`, string(bytes))\n\t\t\t})\n\t\t})\n\t\tt.Run(\"head_omitempty\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA *struct{} `json:\"a,omitempty\"`\n\t\t\t}\n\t\t\tvar v T\n\t\t\tbytes, err := json.Marshal(&v)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"struct\", `{}`, string(bytes))\n\t\t})\n\t\tt.Run(\"pointer_head_omitempty\", func(t *testing.T) {\n\t\t\ttype V struct{}\n\t\t\ttype U struct {\n\t\t\t\tB *V `json:\"b,omitempty\"`\n\t\t\t}\n\t\t\ttype T struct {\n\t\t\t\tA *U `json:\"a\"`\n\t\t\t}\n\t\t\tbytes, err := json.Marshal(&T{A: &U{}})\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"struct\", `{\"a\":{}}`, string(bytes))\n\t\t})\n\t\tt.Run(\"head_int_omitempty\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA int `json:\"a,omitempty\"`\n\t\t\t}\n\t\t\tvar v T\n\t\t\tbytes, err := json.Marshal(&v)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"struct\", `{}`, string(bytes))\n\t\t})\n\t})\n\tt.Run(\"slice\", func(t *testing.T) {\n\t\tt.Run(\"[]int\", func(t *testing.T) {\n\t\t\tbytes, err := json.Marshal([]int{1, 2, 3, 4})\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"[]int\", `[1,2,3,4]`, string(bytes))\n\t\t})\n\t\tt.Run(\"[]interface{}\", func(t *testing.T) {\n\t\t\tbytes, err := json.Marshal([]interface{}{1, 2.1, \"hello\"})\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"[]interface{}\", `[1,2.1,\"hello\"]`, string(bytes))\n\t\t})\n\t\tt.Run(\"[]*time.Time\", func(t *testing.T) {\n\t\t\tbytes, err := json.Marshal([]*time.Time{nil})\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"[]*time.Time\", `[null]`, string(bytes))\n\t\t})\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal([4]int{1, 2, 3, 4})\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"array\", `[1,2,3,4]`, string(bytes))\n\t})\n\tt.Run(\"map\", func(t *testing.T) {\n\t\tt.Run(\"map[string]int\", func(t *testing.T) {\n\t\t\tv := map[string]int{\n\t\t\t\t\"a\": 1,\n\t\t\t\t\"b\": 2,\n\t\t\t\t\"c\": 3,\n\t\t\t\t\"d\": 4,\n\t\t\t}\n\t\t\tbytes, err := json.Marshal(v)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"map\", `{\"a\":1,\"b\":2,\"c\":3,\"d\":4}`, string(bytes))\n\t\t\tb, err := json.MarshalWithOption(v, json.UnorderedMap())\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"unordered map\", len(`{\"a\":1,\"b\":2,\"c\":3,\"d\":4}`), len(string(b)))\n\t\t})\n\t\tt.Run(\"map[string]interface{}\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tA int\n\t\t\t}\n\t\t\tv := map[string]interface{}{\n\t\t\t\t\"a\": 1,\n\t\t\t\t\"b\": 2.1,\n\t\t\t\t\"c\": &T{\n\t\t\t\t\tA: 10,\n\t\t\t\t},\n\t\t\t\t\"d\": 4,\n\t\t\t}\n\t\t\tbytes, err := json.Marshal(v)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"map[string]interface{}\", `{\"a\":1,\"b\":2.1,\"c\":{\"A\":10},\"d\":4}`, string(bytes))\n\t\t})\n\t})\n}\n\ntype mustErrTypeForDebug struct{}\n\nfunc (mustErrTypeForDebug) MarshalJSON() ([]byte, error) {\n\tpanic(\"panic\")\n\treturn nil, fmt.Errorf(\"panic\")\n}\n\nfunc TestDebugMode(t *testing.T) {\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Fatal(\"expected error\")\n\t\t}\n\t}()\n\tvar buf bytes.Buffer\n\tjson.MarshalWithOption(mustErrTypeForDebug{}, json.Debug(), json.DebugWith(&buf))\n}\n\nfunc TestIssue116(t *testing.T) {\n\tt.Run(\"first\", func(t *testing.T) {\n\t\ttype Boo struct{ B string }\n\t\ttype Struct struct {\n\t\t\tA   int\n\t\t\tBoo *Boo\n\t\t}\n\t\ttype Embedded struct {\n\t\t\tStruct\n\t\t}\n\t\tb, err := json.Marshal(Embedded{Struct: Struct{\n\t\t\tA:   1,\n\t\t\tBoo: &Boo{B: \"foo\"},\n\t\t}})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\texpected := `{\"A\":1,\"Boo\":{\"B\":\"foo\"}}`\n\t\tactual := string(b)\n\t\tif actual != expected {\n\t\t\tt.Fatalf(\"expected %s but got %s\", expected, actual)\n\t\t}\n\t})\n\tt.Run(\"second\", func(t *testing.T) {\n\t\ttype Boo struct{ B string }\n\t\ttype Struct struct {\n\t\t\tA int\n\t\t\tB *Boo\n\t\t}\n\t\ttype Embedded struct {\n\t\t\tStruct\n\t\t}\n\t\tb, err := json.Marshal(Embedded{Struct: Struct{\n\t\t\tA: 1,\n\t\t\tB: &Boo{B: \"foo\"},\n\t\t}})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tactual := string(b)\n\t\texpected := `{\"A\":1,\"B\":{\"B\":\"foo\"}}`\n\t\tif actual != expected {\n\t\t\tt.Fatalf(\"expected %s but got %s\", expected, actual)\n\t\t}\n\t})\n}\n\ntype marshalJSON struct{}\n\nfunc (*marshalJSON) MarshalJSON() ([]byte, error) {\n\treturn []byte(`1`), nil\n}\n\nfunc Test_MarshalJSON(t *testing.T) {\n\tt.Run(\"*struct\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(&marshalJSON{})\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"MarshalJSON\", \"1\", string(bytes))\n\t})\n\tt.Run(\"time\", func(t *testing.T) {\n\t\tbytes, err := json.Marshal(time.Time{})\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"MarshalJSON\", `\"0001-01-01T00:00:00Z\"`, string(bytes))\n\t})\n}\n\nfunc Test_MarshalIndent(t *testing.T) {\n\tprefix := \"-\"\n\tindent := \"\\t\"\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\tv := struct {\n\t\t\tA int         `json:\"a\"`\n\t\t\tB uint        `json:\"b\"`\n\t\t\tC string      `json:\"c\"`\n\t\t\tD interface{} `json:\"d\"`\n\t\t\tX int         `json:\"-\"`  // ignore field\n\t\t\ta int         `json:\"aa\"` // private field\n\t\t}{\n\t\t\tA: -1,\n\t\t\tB: 1,\n\t\t\tC: \"hello world\",\n\t\t\tD: struct {\n\t\t\t\tE bool `json:\"e\"`\n\t\t\t}{\n\t\t\t\tE: true,\n\t\t\t},\n\t\t}\n\t\texpected, err := stdjson.MarshalIndent(v, prefix, indent)\n\t\tassertErr(t, err)\n\t\tgot, err := json.MarshalIndent(v, prefix, indent)\n\t\tassertErr(t, err)\n\t\tassertEq(t, \"struct\", string(expected), string(got))\n\t})\n\tt.Run(\"slice\", func(t *testing.T) {\n\t\tt.Run(\"[]int\", func(t *testing.T) {\n\t\t\tbytes, err := json.MarshalIndent([]int{1, 2, 3, 4}, prefix, indent)\n\t\t\tassertErr(t, err)\n\t\t\tresult := \"[\\n-\\t1,\\n-\\t2,\\n-\\t3,\\n-\\t4\\n-]\"\n\t\t\tassertEq(t, \"[]int\", result, string(bytes))\n\t\t})\n\t\tt.Run(\"[]interface{}\", func(t *testing.T) {\n\t\t\tbytes, err := json.MarshalIndent([]interface{}{1, 2.1, \"hello\"}, prefix, indent)\n\t\t\tassertErr(t, err)\n\t\t\tresult := \"[\\n-\\t1,\\n-\\t2.1,\\n-\\t\\\"hello\\\"\\n-]\"\n\t\t\tassertEq(t, \"[]interface{}\", result, string(bytes))\n\t\t})\n\t})\n\n\tt.Run(\"array\", func(t *testing.T) {\n\t\tbytes, err := json.MarshalIndent([4]int{1, 2, 3, 4}, prefix, indent)\n\t\tassertErr(t, err)\n\t\tresult := \"[\\n-\\t1,\\n-\\t2,\\n-\\t3,\\n-\\t4\\n-]\"\n\t\tassertEq(t, \"array\", result, string(bytes))\n\t})\n\tt.Run(\"map\", func(t *testing.T) {\n\t\tt.Run(\"map[string]int\", func(t *testing.T) {\n\t\t\tbytes, err := json.MarshalIndent(map[string]int{\n\t\t\t\t\"a\": 1,\n\t\t\t\t\"b\": 2,\n\t\t\t\t\"c\": 3,\n\t\t\t\t\"d\": 4,\n\t\t\t}, prefix, indent)\n\t\t\tassertErr(t, err)\n\t\t\tresult := \"{\\n-\\t\\\"a\\\": 1,\\n-\\t\\\"b\\\": 2,\\n-\\t\\\"c\\\": 3,\\n-\\t\\\"d\\\": 4\\n-}\"\n\t\t\tassertEq(t, \"map\", result, string(bytes))\n\t\t})\n\t\tt.Run(\"map[string]interface{}\", func(t *testing.T) {\n\t\t\ttype T struct {\n\t\t\t\tE int\n\t\t\t\tF int\n\t\t\t}\n\t\t\tv := map[string]interface{}{\n\t\t\t\t\"a\": 1,\n\t\t\t\t\"b\": 2.1,\n\t\t\t\t\"c\": &T{\n\t\t\t\t\tE: 10,\n\t\t\t\t\tF: 11,\n\t\t\t\t},\n\t\t\t\t\"d\": 4,\n\t\t\t}\n\t\t\tbytes, err := json.MarshalIndent(v, prefix, indent)\n\t\t\tassertErr(t, err)\n\t\t\tresult := \"{\\n-\\t\\\"a\\\": 1,\\n-\\t\\\"b\\\": 2.1,\\n-\\t\\\"c\\\": {\\n-\\t\\t\\\"E\\\": 10,\\n-\\t\\t\\\"F\\\": 11\\n-\\t},\\n-\\t\\\"d\\\": 4\\n-}\"\n\t\t\tassertEq(t, \"map[string]interface{}\", result, string(bytes))\n\t\t})\n\t})\n}\n\ntype StringTag struct {\n\tBoolStr    bool        `json:\",string\"`\n\tIntStr     int64       `json:\",string\"`\n\tUintptrStr uintptr     `json:\",string\"`\n\tStrStr     string      `json:\",string\"`\n\tNumberStr  json.Number `json:\",string\"`\n}\n\nfunc TestRoundtripStringTag(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tin   StringTag\n\t\twant string // empty to just test that we roundtrip\n\t}{\n\t\t{\n\t\t\tname: \"AllTypes\",\n\t\t\tin: StringTag{\n\t\t\t\tBoolStr:    true,\n\t\t\t\tIntStr:     42,\n\t\t\t\tUintptrStr: 44,\n\t\t\t\tStrStr:     \"xzbit\",\n\t\t\t\tNumberStr:  \"46\",\n\t\t\t},\n\t\t\twant: `{\n\t\t\t\t\"BoolStr\": \"true\",\n\t\t\t\t\"IntStr\": \"42\",\n\t\t\t\t\"UintptrStr\": \"44\",\n\t\t\t\t\"StrStr\": \"\\\"xzbit\\\"\",\n\t\t\t\t\"NumberStr\": \"46\"\n\t\t\t}`,\n\t\t},\n\t\t{\n\t\t\t// See golang.org/issues/38173.\n\t\t\tname: \"StringDoubleEscapes\",\n\t\t\tin: StringTag{\n\t\t\t\tStrStr:    \"\\b\\f\\n\\r\\t\\\"\\\\\",\n\t\t\t\tNumberStr: \"0\", // just to satisfy the roundtrip\n\t\t\t},\n\t\t\twant: `{\n\t\t\t\t\"BoolStr\": \"false\",\n\t\t\t\t\"IntStr\": \"0\",\n\t\t\t\t\"UintptrStr\": \"0\",\n\t\t\t\t\"StrStr\": \"\\\"\\\\u0008\\\\u000c\\\\n\\\\r\\\\t\\\\\\\"\\\\\\\\\\\"\",\n\t\t\t\t\"NumberStr\": \"0\"\n\t\t\t}`,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\t// Indent with a tab prefix to make the multi-line string\n\t\t\t// literals in the table nicer to read.\n\t\t\tgot, err := json.MarshalIndent(&test.in, \"\\t\\t\\t\", \"\\t\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif got := string(got); got != test.want {\n\t\t\t\tt.Fatalf(\" got: %s\\nwant: %s\\n\", got, test.want)\n\t\t\t}\n\n\t\t\t// Verify that it round-trips.\n\t\t\tvar s2 StringTag\n\t\t\tif err := json.Unmarshal(got, &s2); err != nil {\n\t\t\t\tt.Fatalf(\"Decode: %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(test.in, s2) {\n\t\t\t\tt.Fatalf(\"decode didn't match.\\nsource: %#v\\nEncoded as:\\n%s\\ndecode: %#v\", test.in, string(got), s2)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// byte slices are special even if they're renamed types.\ntype renamedByte byte\ntype renamedByteSlice []byte\ntype renamedRenamedByteSlice []renamedByte\n\nfunc TestEncodeRenamedByteSlice(t *testing.T) {\n\ts := renamedByteSlice(\"abc\")\n\tresult, err := json.Marshal(s)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpect := `\"YWJj\"`\n\tif string(result) != expect {\n\t\tt.Errorf(\" got %s want %s\", result, expect)\n\t}\n\tr := renamedRenamedByteSlice(\"abc\")\n\tresult, err = json.Marshal(r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(result) != expect {\n\t\tt.Errorf(\" got %s want %s\", result, expect)\n\t}\n}\n\nfunc TestMarshalRawMessageValue(t *testing.T) {\n\ttype (\n\t\tT1 struct {\n\t\t\tM json.RawMessage `json:\",omitempty\"`\n\t\t}\n\t\tT2 struct {\n\t\t\tM *json.RawMessage `json:\",omitempty\"`\n\t\t}\n\t)\n\n\tvar (\n\t\trawNil   = json.RawMessage(nil)\n\t\trawEmpty = json.RawMessage([]byte{})\n\t\trawText  = json.RawMessage([]byte(`\"foo\"`))\n\t)\n\n\ttests := []struct {\n\t\tin   interface{}\n\t\twant string\n\t\tok   bool\n\t}{\n\t\t// Test with nil RawMessage.\n\t\t{rawNil, \"null\", true},\n\t\t{&rawNil, \"null\", true},\n\t\t{[]interface{}{rawNil}, \"[null]\", true},\n\t\t{&[]interface{}{rawNil}, \"[null]\", true},\n\t\t{[]interface{}{&rawNil}, \"[null]\", true},\n\t\t{&[]interface{}{&rawNil}, \"[null]\", true},\n\t\t{struct{ M json.RawMessage }{rawNil}, `{\"M\":null}`, true},\n\t\t{&struct{ M json.RawMessage }{rawNil}, `{\"M\":null}`, true},\n\t\t{struct{ M *json.RawMessage }{&rawNil}, `{\"M\":null}`, true},\n\t\t{&struct{ M *json.RawMessage }{&rawNil}, `{\"M\":null}`, true},\n\t\t{map[string]interface{}{\"M\": rawNil}, `{\"M\":null}`, true},\n\t\t{&map[string]interface{}{\"M\": rawNil}, `{\"M\":null}`, true},\n\t\t{map[string]interface{}{\"M\": &rawNil}, `{\"M\":null}`, true},\n\t\t{&map[string]interface{}{\"M\": &rawNil}, `{\"M\":null}`, true},\n\t\t{T1{rawNil}, \"{}\", true},\n\t\t{T2{&rawNil}, `{\"M\":null}`, true},\n\t\t{&T1{rawNil}, \"{}\", true},\n\t\t{&T2{&rawNil}, `{\"M\":null}`, true},\n\n\t\t// Test with empty, but non-nil, RawMessage.\n\t\t{rawEmpty, \"\", false},\n\t\t{&rawEmpty, \"\", false},\n\t\t{[]interface{}{rawEmpty}, \"\", false},\n\t\t{&[]interface{}{rawEmpty}, \"\", false},\n\t\t{[]interface{}{&rawEmpty}, \"\", false},\n\t\t{&[]interface{}{&rawEmpty}, \"\", false},\n\t\t{struct{ X json.RawMessage }{rawEmpty}, \"\", false},\n\t\t{&struct{ X json.RawMessage }{rawEmpty}, \"\", false},\n\t\t{struct{ X *json.RawMessage }{&rawEmpty}, \"\", false},\n\t\t{&struct{ X *json.RawMessage }{&rawEmpty}, \"\", false},\n\t\t{map[string]interface{}{\"nil\": rawEmpty}, \"\", false},\n\t\t{&map[string]interface{}{\"nil\": rawEmpty}, \"\", false},\n\t\t{map[string]interface{}{\"nil\": &rawEmpty}, \"\", false},\n\t\t{&map[string]interface{}{\"nil\": &rawEmpty}, \"\", false},\n\n\t\t{T1{rawEmpty}, \"{}\", true},\n\t\t{T2{&rawEmpty}, \"\", false},\n\t\t{&T1{rawEmpty}, \"{}\", true},\n\t\t{&T2{&rawEmpty}, \"\", false},\n\n\t\t// Test with RawMessage with some text.\n\t\t//\n\t\t// The tests below marked with Issue6458 used to generate \"ImZvbyI=\" instead \"foo\".\n\t\t// This behavior was intentionally changed in Go 1.8.\n\t\t// See https://golang.org/issues/14493#issuecomment-255857318\n\t\t{rawText, `\"foo\"`, true}, // Issue6458\n\t\t{&rawText, `\"foo\"`, true},\n\t\t{[]interface{}{rawText}, `[\"foo\"]`, true},  // Issue6458\n\t\t{&[]interface{}{rawText}, `[\"foo\"]`, true}, // Issue6458\n\t\t{[]interface{}{&rawText}, `[\"foo\"]`, true},\n\t\t{&[]interface{}{&rawText}, `[\"foo\"]`, true},\n\t\t{struct{ M json.RawMessage }{rawText}, `{\"M\":\"foo\"}`, true}, // Issue6458\n\t\t{&struct{ M json.RawMessage }{rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{struct{ M *json.RawMessage }{&rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{&struct{ M *json.RawMessage }{&rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{map[string]interface{}{\"M\": rawText}, `{\"M\":\"foo\"}`, true},  // Issue6458\n\t\t{&map[string]interface{}{\"M\": rawText}, `{\"M\":\"foo\"}`, true}, // Issue6458\n\t\t{map[string]interface{}{\"M\": &rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{&map[string]interface{}{\"M\": &rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{T1{rawText}, `{\"M\":\"foo\"}`, true}, // Issue6458\n\t\t{T2{&rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{&T1{rawText}, `{\"M\":\"foo\"}`, true},\n\t\t{&T2{&rawText}, `{\"M\":\"foo\"}`, true},\n\t}\n\n\tfor i, tt := range tests {\n\t\tb, err := json.Marshal(tt.in)\n\t\tif ok := (err == nil); ok != tt.ok {\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"test %d, unexpected failure: %v\", i, err)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"test %d, unexpected success\", i)\n\t\t\t}\n\t\t}\n\t\tif got := string(b); got != tt.want {\n\t\t\tt.Errorf(\"test %d, Marshal(%#v) = %q, want %q\", i, tt.in, got, tt.want)\n\t\t}\n\t}\n}\n\ntype marshalerError struct{}\n\nfunc (*marshalerError) MarshalJSON() ([]byte, error) {\n\treturn nil, errors.New(\"unexpected error\")\n}\n\nfunc Test_MarshalerError(t *testing.T) {\n\tvar v marshalerError\n\t_, err := json.Marshal(&v)\n\texpect := `json: error calling MarshalJSON for type *json_test.marshalerError: unexpected error`\n\tassertEq(t, \"marshaler error\", expect, fmt.Sprint(err))\n}\n\n// Ref has Marshaler and Unmarshaler methods with pointer receiver.\ntype Ref int\n\nfunc (*Ref) MarshalJSON() ([]byte, error) {\n\treturn []byte(`\"ref\"`), nil\n}\n\nfunc (r *Ref) UnmarshalJSON([]byte) error {\n\t*r = 12\n\treturn nil\n}\n\n// Val has Marshaler methods with value receiver.\ntype Val int\n\nfunc (Val) MarshalJSON() ([]byte, error) {\n\treturn []byte(`\"val\"`), nil\n}\n\n// RefText has Marshaler and Unmarshaler methods with pointer receiver.\ntype RefText int\n\nfunc (*RefText) MarshalText() ([]byte, error) {\n\treturn []byte(`\"ref\"`), nil\n}\n\nfunc (r *RefText) UnmarshalText([]byte) error {\n\t*r = 13\n\treturn nil\n}\n\n// ValText has Marshaler methods with value receiver.\ntype ValText int\n\nfunc (ValText) MarshalText() ([]byte, error) {\n\treturn []byte(`\"val\"`), nil\n}\n\nfunc TestRefValMarshal(t *testing.T) {\n\tvar s = struct {\n\t\tR0 Ref\n\t\tR1 *Ref\n\t\tR2 RefText\n\t\tR3 *RefText\n\t\tV0 Val\n\t\tV1 *Val\n\t\tV2 ValText\n\t\tV3 *ValText\n\t}{\n\t\tR0: 12,\n\t\tR1: new(Ref),\n\t\tR2: 14,\n\t\tR3: new(RefText),\n\t\tV0: 13,\n\t\tV1: new(Val),\n\t\tV2: 15,\n\t\tV3: new(ValText),\n\t}\n\tconst want = `{\"R0\":\"ref\",\"R1\":\"ref\",\"R2\":\"\\\"ref\\\"\",\"R3\":\"\\\"ref\\\"\",\"V0\":\"val\",\"V1\":\"val\",\"V2\":\"\\\"val\\\"\",\"V3\":\"\\\"val\\\"\"}`\n\tb, err := json.Marshal(&s)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\tif got := string(b); got != want {\n\t\tt.Errorf(\"got %q, want %q\", got, want)\n\t}\n}\n\n// C implements Marshaler and returns unescaped JSON.\ntype C int\n\nfunc (C) MarshalJSON() ([]byte, error) {\n\treturn []byte(`\"<&>\"`), nil\n}\n\n// CText implements Marshaler and returns unescaped text.\ntype CText int\n\nfunc (CText) MarshalText() ([]byte, error) {\n\treturn []byte(`\"<&>\"`), nil\n}\n\nfunc TestMarshalerEscaping(t *testing.T) {\n\tvar c C\n\twant := `\"\\u003c\\u0026\\u003e\"`\n\tb, err := json.Marshal(c)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal(c): %v\", err)\n\t}\n\tif got := string(b); got != want {\n\t\tt.Errorf(\"Marshal(c) = %#q, want %#q\", got, want)\n\t}\n\n\tvar ct CText\n\twant = `\"\\\"\\u003c\\u0026\\u003e\\\"\"`\n\tb, err = json.Marshal(ct)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal(ct): %v\", err)\n\t}\n\tif got := string(b); got != want {\n\t\tt.Errorf(\"Marshal(ct) = %#q, want %#q\", got, want)\n\t}\n}\n\ntype marshalPanic struct{}\n\nfunc (marshalPanic) MarshalJSON() ([]byte, error) { panic(0xdead) }\n\nfunc TestMarshalPanic(t *testing.T) {\n\tdefer func() {\n\t\tif got := recover(); !reflect.DeepEqual(got, 0xdead) {\n\t\t\tt.Errorf(\"panic() = (%T)(%v), want 0xdead\", got, got)\n\t\t}\n\t}()\n\tjson.Marshal(&marshalPanic{})\n\tt.Error(\"Marshal should have panicked\")\n}\n\nfunc TestMarshalUncommonFieldNames(t *testing.T) {\n\tv := struct {\n\t\tA0, À, Aβ int\n\t}{}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(\"Marshal:\", err)\n\t}\n\twant := `{\"A0\":0,\"À\":0,\"Aβ\":0}`\n\tgot := string(b)\n\tif got != want {\n\t\tt.Fatalf(\"Marshal: got %s want %s\", got, want)\n\t}\n}\n\nfunc TestMarshalerError(t *testing.T) {\n\ts := \"test variable\"\n\tst := reflect.TypeOf(s)\n\terrText := \"json: test error\"\n\n\ttests := []struct {\n\t\terr  *json.MarshalerError\n\t\twant string\n\t}{\n\t\t{\n\t\t\tjson.NewMarshalerError(st, fmt.Errorf(errText), \"\"),\n\t\t\t\"json: error calling MarshalJSON for type \" + st.String() + \": \" + errText,\n\t\t},\n\t\t{\n\t\t\tjson.NewMarshalerError(st, fmt.Errorf(errText), \"TestMarshalerError\"),\n\t\t\t\"json: error calling TestMarshalerError for type \" + st.String() + \": \" + errText,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tgot := tt.err.Error()\n\t\tif got != tt.want {\n\t\t\tt.Errorf(\"MarshalerError test %d, got: %s, want: %s\", i, got, tt.want)\n\t\t}\n\t}\n}\n\ntype unmarshalerText struct {\n\tA, B string\n}\n\n// needed for re-marshaling tests\nfunc (u unmarshalerText) MarshalText() ([]byte, error) {\n\treturn []byte(u.A + \":\" + u.B), nil\n}\n\nfunc (u *unmarshalerText) UnmarshalText(b []byte) error {\n\tpos := bytes.IndexByte(b, ':')\n\tif pos == -1 {\n\t\treturn errors.New(\"missing separator\")\n\t}\n\tu.A, u.B = string(b[:pos]), string(b[pos+1:])\n\treturn nil\n}\n\nfunc TestTextMarshalerMapKeysAreSorted(t *testing.T) {\n\tdata := map[unmarshalerText]int{\n\t\t{\"x\", \"y\"}: 1,\n\t\t{\"y\", \"x\"}: 2,\n\t\t{\"a\", \"z\"}: 3,\n\t\t{\"z\", \"a\"}: 4,\n\t}\n\tb, err := json.Marshal(data)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to Marshal text.Marshaler: %v\", err)\n\t}\n\tconst want = `{\"a:z\":3,\"x:y\":1,\"y:x\":2,\"z:a\":4}`\n\tif string(b) != want {\n\t\tt.Errorf(\"Marshal map with text.Marshaler keys: got %#q, want %#q\", b, want)\n\t}\n\n\tb, err = stdjson.Marshal(data)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to std Marshal text.Marshaler: %v\", err)\n\t}\n\tif string(b) != want {\n\t\tt.Errorf(\"std Marshal map with text.Marshaler keys: got %#q, want %#q\", b, want)\n\t}\n}\n\n// https://golang.org/issue/33675\nfunc TestNilMarshalerTextMapKey(t *testing.T) {\n\tv := map[*unmarshalerText]int{\n\t\t(*unmarshalerText)(nil): 1,\n\t\t{\"A\", \"B\"}:              2,\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to Marshal *text.Marshaler: %v\", err)\n\t}\n\tconst want = `{\"\":1,\"A:B\":2}`\n\tif string(b) != want {\n\t\tt.Errorf(\"Marshal map with *text.Marshaler keys: got %#q, want %#q\", b, want)\n\t}\n}\n\nvar re = regexp.MustCompile\n\n// syntactic checks on form of marshaled floating point numbers.\nvar badFloatREs = []*regexp.Regexp{\n\tre(`p`),                     // no binary exponential notation\n\tre(`^\\+`),                   // no leading + sign\n\tre(`^-?0[^.]`),              // no unnecessary leading zeros\n\tre(`^-?\\.`),                 // leading zero required before decimal point\n\tre(`\\.(e|$)`),               // no trailing decimal\n\tre(`\\.[0-9]+0(e|$)`),        // no trailing zero in fraction\n\tre(`^-?(0|[0-9]{2,})\\..*e`), // exponential notation must have normalized mantissa\n\tre(`e[0-9]`),                // positive exponent must be signed\n\t//re(`e[+-]0`),                // exponent must not have leading zeros\n\tre(`e-[1-6]$`),             // not tiny enough for exponential notation\n\tre(`e+(.|1.|20)$`),         // not big enough for exponential notation\n\tre(`^-?0\\.0000000`),        // too tiny, should use exponential notation\n\tre(`^-?[0-9]{22}`),         // too big, should use exponential notation\n\tre(`[1-9][0-9]{16}[1-9]`),  // too many significant digits in integer\n\tre(`[1-9][0-9.]{17}[1-9]`), // too many significant digits in decimal\n\t// below here for float32 only\n\tre(`[1-9][0-9]{8}[1-9]`),  // too many significant digits in integer\n\tre(`[1-9][0-9.]{9}[1-9]`), // too many significant digits in decimal\n}\n\nfunc TestMarshalFloat(t *testing.T) {\n\t//t.Parallel()\n\tnfail := 0\n\ttest := func(f float64, bits int) {\n\t\tvf := interface{}(f)\n\t\tif bits == 32 {\n\t\t\tf = float64(float32(f)) // round\n\t\t\tvf = float32(f)\n\t\t}\n\t\tbout, err := json.Marshal(vf)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Marshal(%T(%g)): %v\", vf, vf, err)\n\t\t\tnfail++\n\t\t\treturn\n\t\t}\n\t\tout := string(bout)\n\n\t\t// result must convert back to the same float\n\t\tg, err := strconv.ParseFloat(out, bits)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Marshal(%T(%g)) = %q, cannot parse back: %v\", vf, vf, out, err)\n\t\t\tnfail++\n\t\t\treturn\n\t\t}\n\t\tif f != g || fmt.Sprint(f) != fmt.Sprint(g) { // fmt.Sprint handles ±0\n\t\t\tt.Errorf(\"Marshal(%T(%g)) = %q (is %g, not %g)\", vf, vf, out, float32(g), vf)\n\t\t\tnfail++\n\t\t\treturn\n\t\t}\n\n\t\tbad := badFloatREs\n\t\tif bits == 64 {\n\t\t\tbad = bad[:len(bad)-2]\n\t\t}\n\t\tfor _, re := range bad {\n\t\t\tif re.MatchString(out) {\n\t\t\t\tt.Errorf(\"Marshal(%T(%g)) = %q, must not match /%s/\", vf, vf, out, re)\n\t\t\t\tnfail++\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tvar (\n\t\tbigger  = math.Inf(+1)\n\t\tsmaller = math.Inf(-1)\n\t)\n\n\tvar digits = \"1.2345678901234567890123\"\n\tfor i := len(digits); i >= 2; i-- {\n\t\tif testing.Short() && i < len(digits)-4 {\n\t\t\tbreak\n\t\t}\n\t\tfor exp := -30; exp <= 30; exp++ {\n\t\t\tfor _, sign := range \"+-\" {\n\t\t\t\tfor bits := 32; bits <= 64; bits += 32 {\n\t\t\t\t\ts := fmt.Sprintf(\"%c%se%d\", sign, digits[:i], exp)\n\t\t\t\t\tf, err := strconv.ParseFloat(s, bits)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t\tnext := math.Nextafter\n\t\t\t\t\tif bits == 32 {\n\t\t\t\t\t\tnext = func(g, h float64) float64 {\n\t\t\t\t\t\t\treturn float64(math.Nextafter32(float32(g), float32(h)))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttest(f, bits)\n\t\t\t\t\ttest(next(f, bigger), bits)\n\t\t\t\t\ttest(next(f, smaller), bits)\n\t\t\t\t\tif nfail > 50 {\n\t\t\t\t\t\tt.Fatalf(\"stopping test early\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ttest(0, 64)\n\ttest(math.Copysign(0, -1), 64)\n\ttest(0, 32)\n\ttest(math.Copysign(0, -1), 32)\n}\n\nvar encodeStringTests = []struct {\n\tin  string\n\tout string\n}{\n\t{\"\\x00\", `\"\\u0000\"`},\n\t{\"\\x01\", `\"\\u0001\"`},\n\t{\"\\x02\", `\"\\u0002\"`},\n\t{\"\\x03\", `\"\\u0003\"`},\n\t{\"\\x04\", `\"\\u0004\"`},\n\t{\"\\x05\", `\"\\u0005\"`},\n\t{\"\\x06\", `\"\\u0006\"`},\n\t{\"\\x07\", `\"\\u0007\"`},\n\t{\"\\x08\", `\"\\u0008\"`},\n\t{\"\\x09\", `\"\\t\"`},\n\t{\"\\x0a\", `\"\\n\"`},\n\t{\"\\x0b\", `\"\\u000b\"`},\n\t{\"\\x0c\", `\"\\u000c\"`},\n\t{\"\\x0d\", `\"\\r\"`},\n\t{\"\\x0e\", `\"\\u000e\"`},\n\t{\"\\x0f\", `\"\\u000f\"`},\n\t{\"\\x10\", `\"\\u0010\"`},\n\t{\"\\x11\", `\"\\u0011\"`},\n\t{\"\\x12\", `\"\\u0012\"`},\n\t{\"\\x13\", `\"\\u0013\"`},\n\t{\"\\x14\", `\"\\u0014\"`},\n\t{\"\\x15\", `\"\\u0015\"`},\n\t{\"\\x16\", `\"\\u0016\"`},\n\t{\"\\x17\", `\"\\u0017\"`},\n\t{\"\\x18\", `\"\\u0018\"`},\n\t{\"\\x19\", `\"\\u0019\"`},\n\t{\"\\x1a\", `\"\\u001a\"`},\n\t{\"\\x1b\", `\"\\u001b\"`},\n\t{\"\\x1c\", `\"\\u001c\"`},\n\t{\"\\x1d\", `\"\\u001d\"`},\n\t{\"\\x1e\", `\"\\u001e\"`},\n\t{\"\\x1f\", `\"\\u001f\"`},\n}\n\nfunc TestEncodeString(t *testing.T) {\n\tfor _, tt := range encodeStringTests {\n\t\tb, err := json.Marshal(tt.in)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Marshal(%q): %v\", tt.in, err)\n\t\t\tcontinue\n\t\t}\n\t\tout := string(b)\n\t\tif out != tt.out {\n\t\t\tt.Errorf(\"Marshal(%q) = %#q, want %#q\", tt.in, out, tt.out)\n\t\t}\n\t}\n}\n\ntype jsonbyte byte\n\nfunc (b jsonbyte) MarshalJSON() ([]byte, error) { return tenc(`{\"JB\":%d}`, b) }\n\ntype textbyte byte\n\nfunc (b textbyte) MarshalText() ([]byte, error) { return tenc(`TB:%d`, b) }\n\ntype jsonint int\n\nfunc (i jsonint) MarshalJSON() ([]byte, error) { return tenc(`{\"JI\":%d}`, i) }\n\ntype textint int\n\nfunc (i textint) MarshalText() ([]byte, error) { return tenc(`TI:%d`, i) }\n\nfunc tenc(format string, a ...interface{}) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, format, a...)\n\treturn buf.Bytes(), nil\n}\n\n// Issue 13783\nfunc TestEncodeBytekind(t *testing.T) {\n\ttestdata := []struct {\n\t\tdata interface{}\n\t\twant string\n\t}{\n\t\t{byte(7), \"7\"},\n\t\t{jsonbyte(7), `{\"JB\":7}`},\n\t\t{textbyte(4), `\"TB:4\"`},\n\t\t{jsonint(5), `{\"JI\":5}`},\n\t\t{textint(1), `\"TI:1\"`},\n\t\t{[]byte{0, 1}, `\"AAE=\"`},\n\n\t\t{[]jsonbyte{0, 1}, `[{\"JB\":0},{\"JB\":1}]`},\n\t\t{[][]jsonbyte{{0, 1}, {3}}, `[[{\"JB\":0},{\"JB\":1}],[{\"JB\":3}]]`},\n\t\t{[]textbyte{2, 3}, `[\"TB:2\",\"TB:3\"]`},\n\n\t\t{[]jsonint{5, 4}, `[{\"JI\":5},{\"JI\":4}]`},\n\t\t{[]textint{9, 3}, `[\"TI:9\",\"TI:3\"]`},\n\t\t{[]int{9, 3}, `[9,3]`},\n\t}\n\tfor i, d := range testdata {\n\t\tjs, err := json.Marshal(d.data)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tgot, want := string(js), d.want\n\t\tif got != want {\n\t\t\tt.Errorf(\"%d: got %s, want %s\", i, got, want)\n\t\t}\n\t}\n}\n\n// golang.org/issue/8582\nfunc TestEncodePointerString(t *testing.T) {\n\ttype stringPointer struct {\n\t\tN *int64 `json:\"n,string\"`\n\t}\n\tvar n int64 = 42\n\tb, err := json.Marshal(stringPointer{N: &n})\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\tif got, want := string(b), `{\"n\":\"42\"}`; got != want {\n\t\tt.Errorf(\"Marshal = %s, want %s\", got, want)\n\t}\n\tvar back stringPointer\n\terr = json.Unmarshal(b, &back)\n\tif err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif back.N == nil {\n\t\tt.Fatalf(\"Unmarshaled nil N field\")\n\t}\n\tif *back.N != 42 {\n\t\tt.Fatalf(\"*N = %d; want 42\", *back.N)\n\t}\n}\n\ntype SamePointerNoCycle struct {\n\tPtr1, Ptr2 *SamePointerNoCycle\n}\n\nvar samePointerNoCycle = &SamePointerNoCycle{}\n\ntype PointerCycle struct {\n\tPtr *PointerCycle\n}\n\nvar pointerCycle = &PointerCycle{}\n\ntype PointerCycleIndirect struct {\n\tPtrs []interface{}\n}\n\nvar pointerCycleIndirect = &PointerCycleIndirect{}\n\nfunc init() {\n\tptr := &SamePointerNoCycle{}\n\tsamePointerNoCycle.Ptr1 = ptr\n\tsamePointerNoCycle.Ptr2 = ptr\n\n\tpointerCycle.Ptr = pointerCycle\n\tpointerCycleIndirect.Ptrs = []interface{}{pointerCycleIndirect}\n}\n\nfunc TestSamePointerNoCycle(t *testing.T) {\n\tif _, err := json.Marshal(samePointerNoCycle); err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n}\n\nvar unsupportedValues = []interface{}{\n\tmath.NaN(),\n\tmath.Inf(-1),\n\tmath.Inf(1),\n\tpointerCycle,\n\tpointerCycleIndirect,\n}\n\nfunc TestUnsupportedValues(t *testing.T) {\n\tfor _, v := range unsupportedValues {\n\t\tif _, err := json.Marshal(v); err != nil {\n\t\t\tif _, ok := err.(*json.UnsupportedValueError); !ok {\n\t\t\t\tt.Errorf(\"for %v, got %T want UnsupportedValueError\", v, err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"for %v, expected error\", v)\n\t\t}\n\t}\n}\n\nfunc TestIssue10281(t *testing.T) {\n\ttype Foo struct {\n\t\tN json.Number\n\t}\n\tx := Foo{json.Number(`invalid`)}\n\n\tb, err := json.Marshal(&x)\n\tif err == nil {\n\t\tt.Errorf(\"Marshal(&x) = %#q; want error\", b)\n\t}\n}\n\nfunc TestHTMLEscape(t *testing.T) {\n\tvar b, want bytes.Buffer\n\tm := `{\"M\":\"<html>foo &` + \"\\xe2\\x80\\xa8 \\xe2\\x80\\xa9\" + `</html>\"}`\n\twant.Write([]byte(`{\"M\":\"\\u003chtml\\u003efoo \\u0026\\u2028 \\u2029\\u003c/html\\u003e\"}`))\n\tjson.HTMLEscape(&b, []byte(m))\n\tif !bytes.Equal(b.Bytes(), want.Bytes()) {\n\t\tt.Errorf(\"HTMLEscape(&b, []byte(m)) = %s; want %s\", b.Bytes(), want.Bytes())\n\t}\n}\n\ntype BugA struct {\n\tS string\n}\n\ntype BugB struct {\n\tBugA\n\tS string\n}\n\ntype BugC struct {\n\tS string\n}\n\n// Legal Go: We never use the repeated embedded field (S).\ntype BugX struct {\n\tA int\n\tBugA\n\tBugB\n}\n\n// golang.org/issue/16042.\n// Even if a nil interface value is passed in, as long as\n// it implements Marshaler, it should be marshaled.\ntype nilJSONMarshaler string\n\nfunc (nm *nilJSONMarshaler) MarshalJSON() ([]byte, error) {\n\tif nm == nil {\n\t\treturn json.Marshal(\"0zenil0\")\n\t}\n\treturn json.Marshal(\"zenil:\" + string(*nm))\n}\n\n// golang.org/issue/34235.\n// Even if a nil interface value is passed in, as long as\n// it implements encoding.TextMarshaler, it should be marshaled.\ntype nilTextMarshaler string\n\nfunc (nm *nilTextMarshaler) MarshalText() ([]byte, error) {\n\tif nm == nil {\n\t\treturn []byte(\"0zenil0\"), nil\n\t}\n\treturn []byte(\"zenil:\" + string(*nm)), nil\n}\n\n// See golang.org/issue/16042 and golang.org/issue/34235.\nfunc TestNilMarshal(t *testing.T) {\n\ttestCases := []struct {\n\t\tv    interface{}\n\t\twant string\n\t}{\n\t\t{v: nil, want: `null`},\n\t\t{v: new(float64), want: `0`},\n\t\t{v: []interface{}(nil), want: `null`},\n\t\t{v: []string(nil), want: `null`},\n\t\t{v: map[string]string(nil), want: `null`},\n\t\t{v: []byte(nil), want: `null`},\n\t\t{v: struct{ M string }{\"gopher\"}, want: `{\"M\":\"gopher\"}`},\n\t\t{v: struct{ M json.Marshaler }{}, want: `{\"M\":null}`},\n\t\t{v: struct{ M json.Marshaler }{(*nilJSONMarshaler)(nil)}, want: `{\"M\":\"0zenil0\"}`},\n\t\t{v: struct{ M interface{} }{(*nilJSONMarshaler)(nil)}, want: `{\"M\":null}`},\n\t\t{v: struct{ M encoding.TextMarshaler }{}, want: `{\"M\":null}`},\n\t\t{v: struct{ M encoding.TextMarshaler }{(*nilTextMarshaler)(nil)}, want: `{\"M\":\"0zenil0\"}`},\n\t\t{v: struct{ M interface{} }{(*nilTextMarshaler)(nil)}, want: `{\"M\":null}`},\n\t}\n\n\tfor i, tt := range testCases {\n\t\tout, err := json.Marshal(tt.v)\n\t\tif err != nil || string(out) != tt.want {\n\t\t\tt.Errorf(\"%d: Marshal(%#v) = %#q, %#v, want %#q, nil\", i, tt.v, out, err, tt.want)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\n// Issue 5245.\nfunc TestEmbeddedBug(t *testing.T) {\n\tv := BugB{\n\t\tBugA{\"A\"},\n\t\t\"B\",\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(\"Marshal:\", err)\n\t}\n\twant := `{\"S\":\"B\"}`\n\tgot := string(b)\n\tif got != want {\n\t\tt.Fatalf(\"Marshal: got %s want %s\", got, want)\n\t}\n\t// Now check that the duplicate field, S, does not appear.\n\tx := BugX{\n\t\tA: 23,\n\t}\n\tb, err = json.Marshal(x)\n\tif err != nil {\n\t\tt.Fatal(\"Marshal:\", err)\n\t}\n\twant = `{\"A\":23}`\n\tgot = string(b)\n\tif got != want {\n\t\tt.Fatalf(\"Marshal: got %s want %s\", got, want)\n\t}\n}\n\ntype BugD struct { // Same as BugA after tagging.\n\tXXX string `json:\"S\"`\n}\n\n// BugD's tagged S field should dominate BugA's.\ntype BugY struct {\n\tBugA\n\tBugD\n}\n\n// Test that a field with a tag dominates untagged fields.\nfunc TestTaggedFieldDominates(t *testing.T) {\n\tv := BugY{\n\t\tBugA{\"BugA\"},\n\t\tBugD{\"BugD\"},\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(\"Marshal:\", err)\n\t}\n\twant := `{\"S\":\"BugD\"}`\n\tgot := string(b)\n\tif got != want {\n\t\tt.Fatalf(\"Marshal: got %s want %s\", got, want)\n\t}\n}\n\n// There are no tags here, so S should not appear.\ntype BugZ struct {\n\tBugA\n\tBugC\n\tBugY // Contains a tagged S field through BugD; should not dominate.\n}\n\nfunc TestDuplicatedFieldDisappears(t *testing.T) {\n\tv := BugZ{\n\t\tBugA{\"BugA\"},\n\t\tBugC{\"BugC\"},\n\t\tBugY{\n\t\t\tBugA{\"nested BugA\"},\n\t\t\tBugD{\"nested BugD\"},\n\t\t},\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(\"Marshal:\", err)\n\t}\n\twant := `{}`\n\tgot := string(b)\n\tif got != want {\n\t\tt.Fatalf(\"Marshal: got %s want %s\", got, want)\n\t}\n}\n\nfunc TestAnonymousFields(t *testing.T) {\n\ttests := []struct {\n\t\tlabel     string             // Test name\n\t\tmakeInput func() interface{} // Function to create input value\n\t\twant      string             // Expected JSON output\n\t}{{\n\t\t// Both S1 and S2 have a field named X. From the perspective of S,\n\t\t// it is ambiguous which one X refers to.\n\t\t// This should not serialize either field.\n\t\tlabel: \"AmbiguousField\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tS1 struct{ x, X int }\n\t\t\t\tS2 struct{ x, X int }\n\t\t\t\tS  struct {\n\t\t\t\t\tS1\n\t\t\t\t\tS2\n\t\t\t\t}\n\t\t\t)\n\t\t\treturn S{S1{1, 2}, S2{3, 4}}\n\t\t},\n\t\twant: `{}`,\n\t}, {\n\t\tlabel: \"DominantField\",\n\t\t// Both S1 and S2 have a field named X, but since S has an X field as\n\t\t// well, it takes precedence over S1.X and S2.X.\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tS1 struct{ x, X int }\n\t\t\t\tS2 struct{ x, X int }\n\t\t\t\tS  struct {\n\t\t\t\t\tS1\n\t\t\t\t\tS2\n\t\t\t\t\tx, X int\n\t\t\t\t}\n\t\t\t)\n\t\t\treturn S{S1{1, 2}, S2{3, 4}, 5, 6}\n\t\t},\n\t\twant: `{\"X\":6}`,\n\t}, {\n\t\t// Unexported embedded field of non-struct type should not be serialized.\n\t\tlabel: \"UnexportedEmbeddedInt\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tmyInt int\n\t\t\t\tS     struct{ myInt }\n\t\t\t)\n\t\t\treturn S{5}\n\t\t},\n\t\twant: `{}`,\n\t}, {\n\t\t// Exported embedded field of non-struct type should be serialized.\n\t\tlabel: \"ExportedEmbeddedInt\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tMyInt int\n\t\t\t\tS     struct{ MyInt }\n\t\t\t)\n\t\t\treturn S{5}\n\t\t},\n\t\twant: `{\"MyInt\":5}`,\n\t}, {\n\t\t// Unexported embedded field of pointer to non-struct type\n\t\t// should not be serialized.\n\t\tlabel: \"UnexportedEmbeddedIntPointer\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tmyInt int\n\t\t\t\tS     struct{ *myInt }\n\t\t\t)\n\t\t\ts := S{new(myInt)}\n\t\t\t*s.myInt = 5\n\t\t\treturn s\n\t\t},\n\t\twant: `{}`,\n\t}, {\n\t\t// Exported embedded field of pointer to non-struct type\n\t\t// should be serialized.\n\t\tlabel: \"ExportedEmbeddedIntPointer\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tMyInt int\n\t\t\t\tS     struct{ *MyInt }\n\t\t\t)\n\t\t\ts := S{new(MyInt)}\n\t\t\t*s.MyInt = 5\n\t\t\treturn s\n\t\t},\n\t\twant: `{\"MyInt\":5}`,\n\t}, {\n\t\t// Exported fields of embedded structs should have their\n\t\t// exported fields be serialized regardless of whether the struct types\n\t\t// themselves are exported.\n\t\tlabel: \"EmbeddedStruct\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\ts1 struct{ x, X int }\n\t\t\t\tS2 struct{ y, Y int }\n\t\t\t\tS  struct {\n\t\t\t\t\ts1\n\t\t\t\t\tS2\n\t\t\t\t}\n\t\t\t)\n\t\t\treturn S{s1{1, 2}, S2{3, 4}}\n\t\t},\n\t\twant: `{\"X\":2,\"Y\":4}`,\n\t}, {\n\t\t// Exported fields of pointers to embedded structs should have their\n\t\t// exported fields be serialized regardless of whether the struct types\n\t\t// themselves are exported.\n\t\tlabel: \"EmbeddedStructPointer\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\ts1 struct{ x, X int }\n\t\t\t\tS2 struct{ y, Y int }\n\t\t\t\tS  struct {\n\t\t\t\t\t*s1\n\t\t\t\t\t*S2\n\t\t\t\t}\n\t\t\t)\n\t\t\treturn S{&s1{1, 2}, &S2{3, 4}}\n\t\t},\n\t\twant: `{\"X\":2,\"Y\":4}`,\n\t}, {\n\t\t// Exported fields on embedded unexported structs at multiple levels\n\t\t// of nesting should still be serialized.\n\t\tlabel: \"NestedStructAndInts\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tMyInt1 int\n\t\t\t\tMyInt2 int\n\t\t\t\tmyInt  int\n\t\t\t\ts2     struct {\n\t\t\t\t\tMyInt2\n\t\t\t\t\tmyInt\n\t\t\t\t}\n\t\t\t\ts1 struct {\n\t\t\t\t\tMyInt1\n\t\t\t\t\tmyInt\n\t\t\t\t\ts2\n\t\t\t\t}\n\t\t\t\tS struct {\n\t\t\t\t\ts1\n\t\t\t\t\tmyInt\n\t\t\t\t}\n\t\t\t)\n\t\t\treturn S{s1{1, 2, s2{3, 4}}, 6}\n\t\t},\n\t\twant: `{\"MyInt1\":1,\"MyInt2\":3}`,\n\t}, {\n\t\t// If an anonymous struct pointer field is nil, we should ignore\n\t\t// the embedded fields behind it. Not properly doing so may\n\t\t// result in the wrong output or reflect panics.\n\t\tlabel: \"EmbeddedFieldBehindNilPointer\",\n\t\tmakeInput: func() interface{} {\n\t\t\ttype (\n\t\t\t\tS2 struct{ Field string }\n\t\t\t\tS  struct{ *S2 }\n\t\t\t)\n\t\t\treturn S{}\n\t\t},\n\t\twant: `{}`,\n\t}}\n\n\tfor i, tt := range tests {\n\t\tt.Run(tt.label, func(t *testing.T) {\n\t\t\tb, err := json.Marshal(tt.makeInput())\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%d: Marshal() = %v, want nil error\", i, err)\n\t\t\t}\n\t\t\tif string(b) != tt.want {\n\t\t\t\tt.Fatalf(\"%d: Marshal() = %q, want %q\", i, b, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype Optionals struct {\n\tSr string `json:\"sr\"`\n\tSo string `json:\"so,omitempty\"`\n\tSw string `json:\"-\"`\n\n\tIr int `json:\"omitempty\"` // actually named omitempty, not an option\n\tIo int `json:\"io,omitempty\"`\n\n\tSlr []string `json:\"slr,random\"`\n\tSlo []string `json:\"slo,omitempty\"`\n\n\tMr map[string]interface{} `json:\"mr\"`\n\tMo map[string]interface{} `json:\",omitempty\"`\n\n\tFr float64 `json:\"fr\"`\n\tFo float64 `json:\"fo,omitempty\"`\n\n\tBr bool `json:\"br\"`\n\tBo bool `json:\"bo,omitempty\"`\n\n\tUr uint `json:\"ur\"`\n\tUo uint `json:\"uo,omitempty\"`\n\n\tStr struct{} `json:\"str\"`\n\tSto struct{} `json:\"sto,omitempty\"`\n}\n\nvar optionalsExpected = `{\n \"sr\": \"\",\n \"omitempty\": 0,\n \"slr\": null,\n \"mr\": {},\n \"fr\": 0,\n \"br\": false,\n \"ur\": 0,\n \"str\": {},\n \"sto\": {}\n}`\n\nfunc TestOmitEmpty(t *testing.T) {\n\tvar o Optionals\n\to.Sw = \"something\"\n\to.Mr = map[string]interface{}{}\n\to.Mo = map[string]interface{}{}\n\n\tgot, err := json.MarshalIndent(&o, \"\", \" \")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif got := string(got); got != optionalsExpected {\n\t\tt.Errorf(\" got: %s\\nwant: %s\\n\", got, optionalsExpected)\n\t}\n}\n\ntype testNullStr string\n\nfunc (v *testNullStr) MarshalJSON() ([]byte, error) {\n\tif *v == \"\" {\n\t\treturn []byte(\"null\"), nil\n\t}\n\n\treturn []byte(*v), nil\n}\n\nfunc TestIssue147(t *testing.T) {\n\ttype T struct {\n\t\tField1 string      `json:\"field1\"`\n\t\tField2 testNullStr `json:\"field2,omitempty\"`\n\t}\n\tgot, err := json.Marshal(T{\n\t\tField1: \"a\",\n\t\tField2: \"b\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpect, _ := stdjson.Marshal(T{\n\t\tField1: \"a\",\n\t\tField2: \"b\",\n\t})\n\tif !bytes.Equal(expect, got) {\n\t\tt.Fatalf(\"expect %q but got %q\", string(expect), string(got))\n\t}\n}\n\ntype testIssue144 struct {\n\tname   string\n\tnumber int64\n}\n\nfunc (v *testIssue144) MarshalJSON() ([]byte, error) {\n\tif v.name != \"\" {\n\t\treturn json.Marshal(v.name)\n\t}\n\treturn json.Marshal(v.number)\n}\n\nfunc TestIssue144(t *testing.T) {\n\ttype Embeded struct {\n\t\tField *testIssue144 `json:\"field,omitempty\"`\n\t}\n\ttype T struct {\n\t\tEmbeded\n\t}\n\t{\n\t\tv := T{\n\t\t\tEmbeded: Embeded{Field: &testIssue144{name: \"hoge\"}},\n\t\t}\n\t\tgot, err := json.Marshal(v)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\texpect, _ := stdjson.Marshal(v)\n\t\tif !bytes.Equal(expect, got) {\n\t\t\tt.Fatalf(\"expect %q but got %q\", string(expect), string(got))\n\t\t}\n\t}\n\t{\n\t\tv := &T{\n\t\t\tEmbeded: Embeded{Field: &testIssue144{name: \"hoge\"}},\n\t\t}\n\t\tgot, err := json.Marshal(v)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\texpect, _ := stdjson.Marshal(v)\n\t\tif !bytes.Equal(expect, got) {\n\t\t\tt.Fatalf(\"expect %q but got %q\", string(expect), string(got))\n\t\t}\n\t}\n}\n\nfunc TestIssue118(t *testing.T) {\n\ttype data struct {\n\t\tColumns []string   `json:\"columns\"`\n\t\tRows1   [][]string `json:\"rows1\"`\n\t\tRows2   [][]string `json:\"rows2\"`\n\t}\n\tv := data{Columns: []string{\"1\", \"2\", \"3\"}}\n\tgot, err := json.MarshalIndent(v, \"\", \"  \")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpect, _ := stdjson.MarshalIndent(v, \"\", \"  \")\n\tif !bytes.Equal(expect, got) {\n\t\tt.Fatalf(\"expect %q but got %q\", string(expect), string(got))\n\t}\n}\n\nfunc TestIssue104(t *testing.T) {\n\ttype A struct {\n\t\tField1 string\n\t\tField2 int\n\t\tField3 float64\n\t}\n\ttype T struct {\n\t\tField A\n\t}\n\tgot, err := json.Marshal(T{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpect, _ := stdjson.Marshal(T{})\n\tif !bytes.Equal(expect, got) {\n\t\tt.Fatalf(\"expect %q but got %q\", string(expect), string(got))\n\t}\n}\n\nfunc TestIssue179(t *testing.T) {\n\tdata := `\n{\n  \"t\": {\n    \"t1\": false,\n    \"t2\": 0,\n    \"t3\": \"\",\n    \"t4\": [],\n    \"t5\": null,\n    \"t6\": null\n  }\n}`\n\ttype T struct {\n\t\tX struct {\n\t\t\tT1 bool        `json:\"t1,omitempty\"`\n\t\t\tT2 float64     `json:\"t2,omitempty\"`\n\t\t\tT3 string      `json:\"t3,omitempty\"`\n\t\t\tT4 []string    `json:\"t4,omitempty\"`\n\t\t\tT5 *struct{}   `json:\"t5,omitempty\"`\n\t\t\tT6 interface{} `json:\"t6,omitempty\"`\n\t\t} `json:\"x\"`\n\t}\n\tvar v T\n\tif err := stdjson.Unmarshal([]byte(data), &v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar v2 T\n\tif err := json.Unmarshal([]byte(data), &v2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(v, v2) {\n\t\tt.Fatalf(\"failed to decode: expected %v got %v\", v, v2)\n\t}\n\tb1, err := stdjson.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb2, err := json.Marshal(v2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(b1, b2) {\n\t\tt.Fatalf(\"failed to equal encoded result: expected %q but got %q\", b1, b2)\n\t}\n}\n\nfunc TestIssue180(t *testing.T) {\n\tv := struct {\n\t\tT struct {\n\t\t\tT1 bool        `json:\"t1\"`\n\t\t\tT2 float64     `json:\"t2\"`\n\t\t\tT3 string      `json:\"t3\"`\n\t\t\tT4 []string    `json:\"t4\"`\n\t\t\tT5 *struct{}   `json:\"t5\"`\n\t\t\tT6 interface{} `json:\"t6\"`\n\t\t\tT7 [][]string  `json:\"t7\"`\n\t\t} `json:\"t\"`\n\t}{\n\t\tT: struct {\n\t\t\tT1 bool        `json:\"t1\"`\n\t\t\tT2 float64     `json:\"t2\"`\n\t\t\tT3 string      `json:\"t3\"`\n\t\t\tT4 []string    `json:\"t4\"`\n\t\t\tT5 *struct{}   `json:\"t5\"`\n\t\t\tT6 interface{} `json:\"t6\"`\n\t\t\tT7 [][]string  `json:\"t7\"`\n\t\t}{\n\t\t\tT4: []string{},\n\t\t\tT7: [][]string{\n\t\t\t\t[]string{\"\"},\n\t\t\t\t[]string{\"hello\", \"world\"},\n\t\t\t\t[]string{},\n\t\t\t},\n\t\t},\n\t}\n\tb1, err := stdjson.MarshalIndent(v, \"\", \"\\t\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb2, err := json.MarshalIndent(v, \"\", \"\\t\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(b1, b2) {\n\t\tt.Fatalf(\"failed to equal encoded result: expected %s but got %s\", string(b1), string(b2))\n\t}\n}\n\nfunc TestIssue235(t *testing.T) {\n\ttype TaskMessage struct {\n\t\tType      string\n\t\tPayload   map[string]interface{}\n\t\tUniqueKey string\n\t}\n\tmsg := TaskMessage{\n\t\tPayload: map[string]interface{}{\n\t\t\t\"sent_at\": map[string]interface{}{\n\t\t\t\t\"Time\":  \"0001-01-01T00:00:00Z\",\n\t\t\t\t\"Valid\": false,\n\t\t\t},\n\t\t},\n\t}\n\tif _, err := json.Marshal(msg); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestEncodeMapKeyTypeInterface(t *testing.T) {\n\tif _, err := json.Marshal(map[interface{}]interface{}{\"a\": 1}); err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\ntype marshalContextKey struct{}\n\ntype marshalContextStructType struct{}\n\nfunc (t *marshalContextStructType) MarshalJSON(ctx context.Context) ([]byte, error) {\n\tv := ctx.Value(marshalContextKey{})\n\ts, ok := v.(string)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"failed to propagate parent context.Context\")\n\t}\n\tif s != \"hello\" {\n\t\treturn nil, fmt.Errorf(\"failed to propagate parent context.Context\")\n\t}\n\treturn []byte(`\"success\"`), nil\n}\n\nfunc TestEncodeContextOption(t *testing.T) {\n\tt.Run(\"MarshalContext\", func(t *testing.T) {\n\t\tctx := context.WithValue(context.Background(), marshalContextKey{}, \"hello\")\n\t\tb, err := json.MarshalContext(ctx, &marshalContextStructType{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(b) != `\"success\"` {\n\t\t\tt.Fatal(\"failed to encode with MarshalerContext\")\n\t\t}\n\t})\n\tt.Run(\"EncodeContext\", func(t *testing.T) {\n\t\tctx := context.WithValue(context.Background(), marshalContextKey{}, \"hello\")\n\t\tbuf := bytes.NewBuffer([]byte{})\n\t\tif err := json.NewEncoder(buf).EncodeContext(ctx, &marshalContextStructType{}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif buf.String() != \"\\\"success\\\"\\n\" {\n\t\t\tt.Fatal(\"failed to encode with EncodeContext\")\n\t\t}\n\t})\n}\n\nfunc TestInterfaceWithPointer(t *testing.T) {\n\tvar (\n\t\tivalue   int         = 10\n\t\tuvalue   uint        = 20\n\t\tsvalue   string      = \"value\"\n\t\tbvalue   bool        = true\n\t\tfvalue   float32     = 3.14\n\t\tnvalue   json.Number = \"1.23\"\n\t\tstructv              = struct{ A int }{A: 10}\n\t\tslice                = []int{1, 2, 3, 4}\n\t\tarray                = [4]int{1, 2, 3, 4}\n\t\tmapvalue             = map[string]int{\"a\": 1}\n\t)\n\tdata := map[string]interface{}{\n\t\t\"ivalue\":  ivalue,\n\t\t\"uvalue\":  uvalue,\n\t\t\"svalue\":  svalue,\n\t\t\"bvalue\":  bvalue,\n\t\t\"fvalue\":  fvalue,\n\t\t\"nvalue\":  nvalue,\n\t\t\"struct\":  structv,\n\t\t\"slice\":   slice,\n\t\t\"array\":   array,\n\t\t\"map\":     mapvalue,\n\t\t\"pivalue\": &ivalue,\n\t\t\"puvalue\": &uvalue,\n\t\t\"psvalue\": &svalue,\n\t\t\"pbvalue\": &bvalue,\n\t\t\"pfvalue\": &fvalue,\n\t\t\"pnvalue\": &nvalue,\n\t\t\"pstruct\": &structv,\n\t\t\"pslice\":  &slice,\n\t\t\"parray\":  &array,\n\t\t\"pmap\":    &mapvalue,\n\t}\n\texpected, err := stdjson.Marshal(data)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tactual, err := json.Marshal(data)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassertEq(t, \"interface{}\", string(expected), string(actual))\n}\n\nfunc TestIssue263(t *testing.T) {\n\ttype Foo struct {\n\t\tA []string `json:\"a\"`\n\t\tB int      `json:\"b\"`\n\t}\n\n\ttype MyStruct struct {\n\t\tFoo *Foo `json:\"foo,omitempty\"`\n\t}\n\n\ts := MyStruct{\n\t\tFoo: &Foo{\n\t\t\tA: []string{\"ls -lah\"},\n\t\t\tB: 0,\n\t\t},\n\t}\n\texpected, err := stdjson.Marshal(s)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tactual, err := json.Marshal(s)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, actual) {\n\t\tt.Fatalf(\"expected:[%s] but got:[%s]\", string(expected), string(actual))\n\t}\n}\n\nfunc TestEmbeddedNotFirstField(t *testing.T) {\n\ttype Embedded struct {\n\t\tHas bool `json:\"has\"`\n\t}\n\ttype T struct {\n\t\tX        int `json:\"is\"`\n\t\tEmbedded `json:\"child\"`\n\t}\n\tp := T{X: 10, Embedded: Embedded{Has: true}}\n\texpected, err := stdjson.Marshal(&p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.Marshal(&p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"failed to encode embedded structure. expected = %q but got %q\", expected, got)\n\t}\n}\n\ntype implementedMethodIface interface {\n\tM()\n}\n\ntype implementedIfaceType struct {\n\tA int\n\tB string\n}\n\nfunc (implementedIfaceType) M() {}\n\nfunc TestImplementedMethodInterfaceType(t *testing.T) {\n\tdata := []implementedIfaceType{implementedIfaceType{}}\n\texpected, err := stdjson.Marshal(data)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.Marshal(data)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"failed to encode implemented method interface type. expected:[%q] but got:[%q]\", expected, got)\n\t}\n}\n\nfunc TestEmptyStructInterface(t *testing.T) {\n\texpected, err := stdjson.Marshal([]interface{}{struct{}{}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.Marshal([]interface{}{struct{}{}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"failed to encode empty struct interface. expected:[%q] but got:[%q]\", expected, got)\n\t}\n}\n\nfunc TestIssue290(t *testing.T) {\n\ttype Issue290 interface {\n\t\tA()\n\t}\n\tvar a struct {\n\t\tA Issue290\n\t}\n\texpected, err := stdjson.Marshal(a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.Marshal(a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"failed to encode non empty interface. expected = %q but got %q\", expected, got)\n\t}\n}\n\nfunc TestIssue299(t *testing.T) {\n\tt.Run(\"conflict second field\", func(t *testing.T) {\n\t\ttype Embedded struct {\n\t\t\tID   string            `json:\"id\"`\n\t\t\tName map[string]string `json:\"name\"`\n\t\t}\n\t\ttype Container struct {\n\t\t\tEmbedded\n\t\t\tName string `json:\"name\"`\n\t\t}\n\t\tc := &Container{\n\t\t\tEmbedded: Embedded{\n\t\t\t\tID:   \"1\",\n\t\t\t\tName: map[string]string{\"en\": \"Hello\", \"es\": \"Hola\"},\n\t\t\t},\n\t\t\tName: \"Hi\",\n\t\t}\n\t\texpected, _ := stdjson.Marshal(c)\n\t\tgot, err := json.Marshal(c)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(expected, got) {\n\t\t\tt.Fatalf(\"expected %q but got %q\", expected, got)\n\t\t}\n\t})\n\tt.Run(\"conflict map field\", func(t *testing.T) {\n\t\ttype Embedded struct {\n\t\t\tName map[string]string `json:\"name\"`\n\t\t}\n\t\ttype Container struct {\n\t\t\tEmbedded\n\t\t\tName string `json:\"name\"`\n\t\t}\n\t\tc := &Container{\n\t\t\tEmbedded: Embedded{\n\t\t\t\tName: map[string]string{\"en\": \"Hello\", \"es\": \"Hola\"},\n\t\t\t},\n\t\t\tName: \"Hi\",\n\t\t}\n\t\texpected, _ := stdjson.Marshal(c)\n\t\tgot, err := json.Marshal(c)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(expected, got) {\n\t\t\tt.Fatalf(\"expected %q but got %q\", expected, got)\n\t\t}\n\t})\n\tt.Run(\"conflict slice field\", func(t *testing.T) {\n\t\ttype Embedded struct {\n\t\t\tName []string `json:\"name\"`\n\t\t}\n\t\ttype Container struct {\n\t\t\tEmbedded\n\t\t\tName string `json:\"name\"`\n\t\t}\n\t\tc := &Container{\n\t\t\tEmbedded: Embedded{\n\t\t\t\tName: []string{\"Hello\"},\n\t\t\t},\n\t\t\tName: \"Hi\",\n\t\t}\n\t\texpected, _ := stdjson.Marshal(c)\n\t\tgot, err := json.Marshal(c)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(expected, got) {\n\t\t\tt.Fatalf(\"expected %q but got %q\", expected, got)\n\t\t}\n\t})\n}\n\nfunc TestRecursivePtrHead(t *testing.T) {\n\ttype User struct {\n\t\tAccount  *string `json:\"account\"`\n\t\tPassword *string `json:\"password\"`\n\t\tNickname *string `json:\"nickname\"`\n\t\tAddress  *string `json:\"address,omitempty\"`\n\t\tFriends  []*User `json:\"friends,omitempty\"`\n\t}\n\tuser1Account, user1Password, user1Nickname := \"abcdef\", \"123456\", \"user1\"\n\tuser1 := &User{\n\t\tAccount:  &user1Account,\n\t\tPassword: &user1Password,\n\t\tNickname: &user1Nickname,\n\t\tAddress:  nil,\n\t}\n\tuser2Account, user2Password, user2Nickname := \"ghijkl\", \"123456\", \"user2\"\n\tuser2 := &User{\n\t\tAccount:  &user2Account,\n\t\tPassword: &user2Password,\n\t\tNickname: &user2Nickname,\n\t\tAddress:  nil,\n\t}\n\tuser1.Friends = []*User{user2}\n\texpected, err := stdjson.Marshal(user1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.Marshal(user1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"failed to encode. expected %q but got %q\", expected, got)\n\t}\n}\n\nfunc TestMarshalIndent(t *testing.T) {\n\tv := map[string]map[string]interface{}{\n\t\t\"a\": {\n\t\t\t\"b\": \"1\",\n\t\t\t\"c\": map[string]interface{}{\n\t\t\t\t\"d\": \"1\",\n\t\t\t},\n\t\t},\n\t}\n\texpected, err := stdjson.MarshalIndent(v, \"\", \"    \")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.MarshalIndent(v, \"\", \"    \")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"expected: %q but got %q\", expected, got)\n\t}\n}\n\ntype issue318Embedded struct {\n\t_ [64]byte\n}\n\ntype issue318 struct {\n\tissue318Embedded `json:\"-\"`\n\tID               issue318MarshalText `json:\"id,omitempty\"`\n}\n\ntype issue318MarshalText struct {\n\tID string\n}\n\nfunc (i issue318MarshalText) MarshalText() ([]byte, error) {\n\treturn []byte(i.ID), nil\n}\n\nfunc TestIssue318(t *testing.T) {\n\tv := issue318{\n\t\tID: issue318MarshalText{ID: \"1\"},\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := `{\"id\":\"1\"}`\n\tif string(b) != expected {\n\t\tt.Fatalf(\"failed to encode. expected %s but got %s\", expected, string(b))\n\t}\n}\n\ntype emptyStringMarshaler struct {\n\tValue stringMarshaler `json:\"value,omitempty\"`\n}\n\ntype stringMarshaler string\n\nfunc (s stringMarshaler) MarshalJSON() ([]byte, error) {\n\treturn []byte(`\"` + s + `\"`), nil\n}\n\nfunc TestEmptyStringMarshaler(t *testing.T) {\n\tvalue := emptyStringMarshaler{}\n\texpected, err := stdjson.Marshal(value)\n\tassertErr(t, err)\n\tgot, err := json.Marshal(value)\n\tassertErr(t, err)\n\tassertEq(t, \"struct\", string(expected), string(got))\n}\n\nfunc TestIssue324(t *testing.T) {\n\ttype T struct {\n\t\tFieldA *string  `json:\"fieldA,omitempty\"`\n\t\tFieldB *string  `json:\"fieldB,omitempty\"`\n\t\tFieldC *bool    `json:\"fieldC\"`\n\t\tFieldD []string `json:\"fieldD,omitempty\"`\n\t}\n\tv := &struct {\n\t\tCode string `json:\"code\"`\n\t\t*T\n\t}{\n\t\tT: &T{},\n\t}\n\tvar sv = \"Test Field\"\n\tv.Code = \"Test\"\n\tv.T.FieldB = &sv\n\texpected, err := stdjson.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(expected, got) {\n\t\tt.Fatalf(\"failed to encode. expected %q but got %q\", expected, got)\n\t}\n}\n\nfunc TestIssue339(t *testing.T) {\n\ttype T1 struct {\n\t\t*big.Int\n\t}\n\ttype T2 struct {\n\t\tT1 T1 `json:\"T1\"`\n\t}\n\tv := T2{T1{Int: big.NewInt(10000)}}\n\tb, err := json.Marshal(&v)\n\tassertErr(t, err)\n\tgot := string(b)\n\texpected := `{\"T1\":10000}`\n\tif got != expected {\n\t\tt.Errorf(\"unexpected result: %v != %v\", got, expected)\n\t}\n}\n\nfunc TestIssue376(t *testing.T) {\n\ttype Container struct {\n\t\tV interface{} `json:\"value\"`\n\t}\n\ttype MapOnly struct {\n\t\tMap map[string]int64 `json:\"map\"`\n\t}\n\tb, err := json.Marshal(Container{MapOnly{}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot := string(b)\n\texpected := `{\"value\":{\"map\":null}}`\n\tif got != expected {\n\t\tt.Errorf(\"unexpected result: %v != %v\", got, expected)\n\t}\n}\n\ntype Issue370 struct {\n\tString string\n\tValid  bool\n}\n\nfunc (i *Issue370) MarshalJSON() ([]byte, error) {\n\tif !i.Valid {\n\t\treturn json.Marshal(nil)\n\t}\n\treturn json.Marshal(i.String)\n}\n\nfunc TestIssue370(t *testing.T) {\n\tv := []struct {\n\t\tV Issue370\n\t}{\n\t\t{V: Issue370{String: \"test\", Valid: true}},\n\t}\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot := string(b)\n\texpected := `[{\"V\":\"test\"}]`\n\tif got != expected {\n\t\tt.Errorf(\"unexpected result: %v != %v\", got, expected)\n\t}\n}\n\nfunc TestIssue374(t *testing.T) {\n\tr := io.MultiReader(strings.NewReader(strings.Repeat(\" \", 505)+`\"\\u`), strings.NewReader(`0000\"`))\n\tvar v interface{}\n\tif err := json.NewDecoder(r).Decode(&v); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tgot := v.(string)\n\texpected := \"\\u0000\"\n\tif got != expected {\n\t\tt.Errorf(\"unexpected result: %q != %q\", got, expected)\n\t}\n}\n\nfunc TestIssue381(t *testing.T) {\n\tvar v struct {\n\t\tField0  bool\n\t\tField1  bool\n\t\tField2  bool\n\t\tField3  bool\n\t\tField4  bool\n\t\tField5  bool\n\t\tField6  bool\n\t\tField7  bool\n\t\tField8  bool\n\t\tField9  bool\n\t\tField10 bool\n\t\tField11 bool\n\t\tField12 bool\n\t\tField13 bool\n\t\tField14 bool\n\t\tField15 bool\n\t\tField16 bool\n\t\tField17 bool\n\t\tField18 bool\n\t\tField19 bool\n\t\tField20 bool\n\t\tField21 bool\n\t\tField22 bool\n\t\tField23 bool\n\t\tField24 bool\n\t\tField25 bool\n\t\tField26 bool\n\t\tField27 bool\n\t\tField28 bool\n\t\tField29 bool\n\t\tField30 bool\n\t\tField31 bool\n\t\tField32 bool\n\t\tField33 bool\n\t\tField34 bool\n\t\tField35 bool\n\t\tField36 bool\n\t\tField37 bool\n\t\tField38 bool\n\t\tField39 bool\n\t\tField40 bool\n\t\tField41 bool\n\t\tField42 bool\n\t\tField43 bool\n\t\tField44 bool\n\t\tField45 bool\n\t\tField46 bool\n\t\tField47 bool\n\t\tField48 bool\n\t\tField49 bool\n\t\tField50 bool\n\t\tField51 bool\n\t\tField52 bool\n\t\tField53 bool\n\t\tField54 bool\n\t\tField55 bool\n\t\tField56 bool\n\t\tField57 bool\n\t\tField58 bool\n\t\tField59 bool\n\t\tField60 bool\n\t\tField61 bool\n\t\tField62 bool\n\t\tField63 bool\n\t\tField64 bool\n\t\tField65 bool\n\t\tField66 bool\n\t\tField67 bool\n\t\tField68 bool\n\t\tField69 bool\n\t\tField70 bool\n\t\tField71 bool\n\t\tField72 bool\n\t\tField73 bool\n\t\tField74 bool\n\t\tField75 bool\n\t\tField76 bool\n\t\tField77 bool\n\t\tField78 bool\n\t\tField79 bool\n\t\tField80 bool\n\t\tField81 bool\n\t\tField82 bool\n\t\tField83 bool\n\t\tField84 bool\n\t\tField85 bool\n\t\tField86 bool\n\t\tField87 bool\n\t\tField88 bool\n\t\tField89 bool\n\t\tField90 bool\n\t\tField91 bool\n\t\tField92 bool\n\t\tField93 bool\n\t\tField94 bool\n\t\tField95 bool\n\t\tField96 bool\n\t\tField97 bool\n\t\tField98 bool\n\t\tField99 bool\n\t}\n\n\t// test encoder cache issue, not related to encoder\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Errorf(\"failed to marshal %s\", err.Error())\n\t\tt.FailNow()\n\t}\n\n\tstd, err := stdjson.Marshal(v)\n\tif err != nil {\n\t\tt.Errorf(\"failed to marshal with encoding/json %s\", err.Error())\n\t\tt.FailNow()\n\t}\n\n\tif !bytes.Equal(std, b) {\n\t\tt.Errorf(\"encoding result not equal to encoding/json\")\n\t\tt.FailNow()\n\t}\n}\n\nfunc TestIssue386(t *testing.T) {\n\traw := `{\"date\": null, \"platform\": \"\\u6f2b\\u753b\", \"images\": {\"small\": \"https://lain.bgm.tv/pic/cover/s/d2/a1/80048_jp.jpg\", \"grid\": \"https://lain.bgm.tv/pic/cover/g/d2/a1/80048_jp.jpg\", \"large\": \"https://lain.bgm.tv/pic/cover/l/d2/a1/80048_jp.jpg\", \"medium\": \"https://lain.bgm.tv/pic/cover/m/d2/a1/80048_jp.jpg\", \"common\": \"https://lain.bgm.tv/pic/cover/c/d2/a1/80048_jp.jpg\"}, \"summary\": \"\\u5929\\u624d\\u8a2d\\u8a08\\u58eb\\u30fb\\u5929\\u5bae\\uff08\\u3042\\u307e\\u307f\\u3084\\uff09\\u3092\\u62b1\\u3048\\u308b\\u6751\\u96e8\\u7dcf\\u5408\\u4f01\\u753b\\u306f\\u3001\\u771f\\u6c34\\u5efa\\u8a2d\\u3068\\u63d0\\u643a\\u3057\\u3066\\u300c\\u3055\\u304d\\u305f\\u307e\\u30a2\\u30ea\\u30fc\\u30ca\\u300d\\u306e\\u30b3\\u30f3\\u30da\\u306b\\u512a\\u52dd\\u3059\\u308b\\u3053\\u3068\\u306b\\u8ced\\u3051\\u3066\\u3044\\u305f\\u3002\\u3057\\u304b\\u3057\\u3001\\u73fe\\u77e5\\u4e8b\\u306e\\u6d25\\u5730\\u7530\\uff08\\u3064\\u3061\\u3060\\uff09\\u306f\\u5927\\u65e5\\u5efa\\u8a2d\\u306b\\u512a\\u52dd\\u3055\\u305b\\u3088\\u3046\\u3068\\u6697\\u8e8d\\u3059\\u308b\\u3002\\u305d\\u308c\\u306f\\u73fe\\u77e5\\u4e8b\\u306e\\u6d25\\u5730\\u7530\\u3068\\u526f\\u77e5\\u4e8b\\u306e\\u592a\\u7530\\uff08\\u304a\\u304a\\u305f\\uff09\\u306e\\u653f\\u6cbb\\u751f\\u547d\\u3092\\u5de6\\u53f3\\u3059\\u308b\\u4e89\\u3044\\u3068\\u306a\\u308a\\u2026\\u2026!?\\u3000\\u305d\\u3057\\u3066\\u516c\\u5171\\u4e8b\\u696d\\u306b\\u6e26\\u5dfb\\u304f\\u6df1\\u3044\\u95c7\\u306b\\u842c\\u7530\\u9280\\u6b21\\u90ce\\uff08\\u307e\\u3093\\u3060\\u30fb\\u304e\\u3093\\u3058\\u308d\\u3046\\uff09\\u306f\\u2026\\u2026!?\", \"name\": \"\\u30df\\u30ca\\u30df\\u306e\\u5e1d\\u738b (48)\"}`\n\tvar a struct {\n\t\tDate     *string `json:\"date\"`\n\t\tPlatform *string `json:\"platform\"`\n\t\tSummary  string  `json:\"summary\"`\n\t\tName     string  `json:\"name\"`\n\t}\n\terr := json.NewDecoder(strings.NewReader(raw)).Decode(&a)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\ntype customMapKey string\n\nfunc (b customMapKey) MarshalJSON() ([]byte, error) {\n\treturn []byte(\"[]\"), nil\n}\n\nfunc TestCustomMarshalForMapKey(t *testing.T) {\n\tm := map[customMapKey]string{customMapKey(\"skipcustom\"): \"test\"}\n\texpected, err := stdjson.Marshal(m)\n\tassertErr(t, err)\n\tgot, err := json.Marshal(m)\n\tassertErr(t, err)\n\tassertEq(t, \"custom map key\", string(expected), string(got))\n}\n\nfunc TestIssue391(t *testing.T) {\n\ttype A struct {\n\t\tX string `json:\"x,omitempty\"`\n\t}\n\ttype B struct {\n\t\tA\n\t}\n\ttype C struct {\n\t\tX []int `json:\"x,omitempty\"`\n\t}\n\tfor _, tc := range []struct {\n\t\tname string\n\t\tin   interface{}\n\t\tout  string\n\t}{\n\t\t{in: struct{ B }{}, out: \"{}\"},\n\t\t{in: struct {\n\t\t\tB\n\t\t\tY string `json:\"y\"`\n\t\t}{}, out: `{\"y\":\"\"}`},\n\t\t{in: struct {\n\t\t\tY string `json:\"y\"`\n\t\t\tB\n\t\t}{}, out: `{\"y\":\"\"}`},\n\t\t{in: struct{ C }{}, out: \"{}\"},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tb, err := json.Marshal(tc.in)\n\t\t\tassertErr(t, err)\n\t\t\tassertEq(t, \"unexpected result\", tc.out, string(b))\n\t\t})\n\t}\n}\n\nfunc TestIssue417(t *testing.T) {\n\tx := map[string]string{\n\t\t\"b\": \"b\",\n\t\t\"a\": \"a\",\n\t}\n\tb, err := json.MarshalIndentWithOption(x, \"\", \" \", json.UnorderedMap())\n\tassertErr(t, err)\n\n\tvar y map[string]string\n\terr = json.Unmarshal(b, &y)\n\tassertErr(t, err)\n\n\tassertEq(t, \"key b\", \"b\", y[\"b\"])\n\tassertEq(t, \"key a\", \"a\", y[\"a\"])\n}\n\nfunc TestIssue426(t *testing.T) {\n\ttype I interface {\n\t\tFoo()\n\t}\n\ttype A struct {\n\t\tI\n\t\tVal string\n\t}\n\tvar s A\n\ts.Val = \"456\"\n\n\tb, _ := json.Marshal(s)\n\tassertEq(t, \"unexpected result\", `{\"I\":null,\"Val\":\"456\"}`, string(b))\n}\n\nfunc TestIssue441(t *testing.T) {\n\ttype A struct {\n\t\tY string `json:\"y,omitempty\"`\n\t}\n\n\ttype B struct {\n\t\tX *int `json:\"x,omitempty\"`\n\t\tA\n\t\tZ int `json:\"z,omitempty\"`\n\t}\n\n\tb, err := json.Marshal(B{})\n\tassertErr(t, err)\n\tassertEq(t, \"unexpected result\", \"{}\", string(b))\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.5009765625,
          "content": "package json\n\nimport (\n\t\"github.com/goccy/go-json/internal/errors\"\n)\n\n// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when\n// attempting to encode a string value with invalid UTF-8 sequences.\n// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by\n// replacing invalid bytes with the Unicode replacement rune U+FFFD.\n//\n// Deprecated: No longer used; kept for compatibility.\ntype InvalidUTF8Error = errors.InvalidUTF8Error\n\n// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\n// (The argument to Unmarshal must be a non-nil pointer.)\ntype InvalidUnmarshalError = errors.InvalidUnmarshalError\n\n// A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.\ntype MarshalerError = errors.MarshalerError\n\n// A SyntaxError is a description of a JSON syntax error.\ntype SyntaxError = errors.SyntaxError\n\n// An UnmarshalFieldError describes a JSON object key that\n// led to an unexported (and therefore unwritable) struct field.\n//\n// Deprecated: No longer used; kept for compatibility.\ntype UnmarshalFieldError = errors.UnmarshalFieldError\n\n// An UnmarshalTypeError describes a JSON value that was\n// not appropriate for a value of a specific Go type.\ntype UnmarshalTypeError = errors.UnmarshalTypeError\n\n// An UnsupportedTypeError is returned by Marshal when attempting\n// to encode an unsupported value type.\ntype UnsupportedTypeError = errors.UnsupportedTypeError\n\ntype UnsupportedValueError = errors.UnsupportedValueError\n\ntype PathError = errors.PathError\n"
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 0.1533203125,
          "content": "package json\n\nimport (\n\t\"github.com/goccy/go-json/internal/errors\"\n)\n\nvar (\n\tNewSyntaxError    = errors.ErrSyntax\n\tNewMarshalerError = errors.ErrMarshaler\n)\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0400390625,
          "content": "module github.com/goccy/go-json\n\ngo 1.19\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "helper_test.go",
          "type": "blob",
          "size": 0.513671875,
          "content": "package json_test\n\nimport \"testing\"\n\nfunc assertErr(t *testing.T, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatalf(\"%+v\", err)\n\t}\n}\n\nfunc assertEq(t *testing.T, msg string, exp interface{}, act interface{}) {\n\tt.Helper()\n\tif exp != act {\n\t\tt.Fatalf(\"failed to test for %s. exp=[%v] but act=[%v]\", msg, exp, act)\n\t}\n}\n\nfunc assertNeq(t *testing.T, msg string, exp interface{}, act interface{}) {\n\tt.Helper()\n\tif exp == act {\n\t\tt.Fatalf(\"failed to test for %s. expected value is not [%v] but got same value\", msg, act)\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 14.8828125,
          "content": "package json\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/goccy/go-json/internal/encoder\"\n)\n\n// Marshaler is the interface implemented by types that\n// can marshal themselves into valid JSON.\ntype Marshaler interface {\n\tMarshalJSON() ([]byte, error)\n}\n\n// MarshalerContext is the interface implemented by types that\n// can marshal themselves into valid JSON with context.Context.\ntype MarshalerContext interface {\n\tMarshalJSON(context.Context) ([]byte, error)\n}\n\n// Unmarshaler is the interface implemented by types\n// that can unmarshal a JSON description of themselves.\n// The input can be assumed to be a valid encoding of\n// a JSON value. UnmarshalJSON must copy the JSON data\n// if it wishes to retain the data after returning.\n//\n// By convention, to approximate the behavior of Unmarshal itself,\n// Unmarshalers implement UnmarshalJSON([]byte(\"null\")) as a no-op.\ntype Unmarshaler interface {\n\tUnmarshalJSON([]byte) error\n}\n\n// UnmarshalerContext is the interface implemented by types\n// that can unmarshal with context.Context a JSON description of themselves.\ntype UnmarshalerContext interface {\n\tUnmarshalJSON(context.Context, []byte) error\n}\n\n// Marshal returns the JSON encoding of v.\n//\n// Marshal traverses the value v recursively.\n// If an encountered value implements the Marshaler interface\n// and is not a nil pointer, Marshal calls its MarshalJSON method\n// to produce JSON. If no MarshalJSON method is present but the\n// value implements encoding.TextMarshaler instead, Marshal calls\n// its MarshalText method and encodes the result as a JSON string.\n// The nil pointer exception is not strictly necessary\n// but mimics a similar, necessary exception in the behavior of\n// UnmarshalJSON.\n//\n// Otherwise, Marshal uses the following type-dependent default encodings:\n//\n// Boolean values encode as JSON booleans.\n//\n// Floating point, integer, and Number values encode as JSON numbers.\n//\n// String values encode as JSON strings coerced to valid UTF-8,\n// replacing invalid bytes with the Unicode replacement rune.\n// The angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\n// to keep some browsers from misinterpreting JSON output as HTML.\n// Ampersand \"&\" is also escaped to \"\\u0026\" for the same reason.\n// This escaping can be disabled using an Encoder that had SetEscapeHTML(false)\n// called on it.\n//\n// Array and slice values encode as JSON arrays, except that\n// []byte encodes as a base64-encoded string, and a nil slice\n// encodes as the null JSON value.\n//\n// Struct values encode as JSON objects.\n// Each exported struct field becomes a member of the object, using the\n// field name as the object key, unless the field is omitted for one of the\n// reasons given below.\n//\n// The encoding of each struct field can be customized by the format string\n// stored under the \"json\" key in the struct field's tag.\n// The format string gives the name of the field, possibly followed by a\n// comma-separated list of options. The name may be empty in order to\n// specify options without overriding the default field name.\n//\n// The \"omitempty\" option specifies that the field should be omitted\n// from the encoding if the field has an empty value, defined as\n// false, 0, a nil pointer, a nil interface value, and any empty array,\n// slice, map, or string.\n//\n// As a special case, if the field tag is \"-\", the field is always omitted.\n// Note that a field with name \"-\" can still be generated using the tag \"-,\".\n//\n// Examples of struct field tags and their meanings:\n//\n//\t// Field appears in JSON as key \"myName\".\n//\tField int `json:\"myName\"`\n//\n//\t// Field appears in JSON as key \"myName\" and\n//\t// the field is omitted from the object if its value is empty,\n//\t// as defined above.\n//\tField int `json:\"myName,omitempty\"`\n//\n//\t// Field appears in JSON as key \"Field\" (the default), but\n//\t// the field is skipped if empty.\n//\t// Note the leading comma.\n//\tField int `json:\",omitempty\"`\n//\n//\t// Field is ignored by this package.\n//\tField int `json:\"-\"`\n//\n//\t// Field appears in JSON as key \"-\".\n//\tField int `json:\"-,\"`\n//\n// The \"string\" option signals that a field is stored as JSON inside a\n// JSON-encoded string. It applies only to fields of string, floating point,\n// integer, or boolean types. This extra level of encoding is sometimes used\n// when communicating with JavaScript programs:\n//\n//\tInt64String int64 `json:\",string\"`\n//\n// The key name will be used if it's a non-empty string consisting of\n// only Unicode letters, digits, and ASCII punctuation except quotation\n// marks, backslash, and comma.\n//\n// Anonymous struct fields are usually marshaled as if their inner exported fields\n// were fields in the outer struct, subject to the usual Go visibility rules amended\n// as described in the next paragraph.\n// An anonymous struct field with a name given in its JSON tag is treated as\n// having that name, rather than being anonymous.\n// An anonymous struct field of interface type is treated the same as having\n// that type as its name, rather than being anonymous.\n//\n// The Go visibility rules for struct fields are amended for JSON when\n// deciding which field to marshal or unmarshal. If there are\n// multiple fields at the same level, and that level is the least\n// nested (and would therefore be the nesting level selected by the\n// usual Go rules), the following extra rules apply:\n//\n// 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\n// even if there are multiple untagged fields that would otherwise conflict.\n//\n// 2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n//\n// 3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n//\n// Handling of anonymous struct fields is new in Go 1.1.\n// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\n// an anonymous struct field in both current and earlier versions, give the field\n// a JSON tag of \"-\".\n//\n// Map values encode as JSON objects. The map's key type must either be a\n// string, an integer type, or implement encoding.TextMarshaler. The map keys\n// are sorted and used as JSON object keys by applying the following rules,\n// subject to the UTF-8 coercion described for string values above:\n//   - string keys are used directly\n//   - encoding.TextMarshalers are marshaled\n//   - integer keys are converted to strings\n//\n// Pointer values encode as the value pointed to.\n// A nil pointer encodes as the null JSON value.\n//\n// Interface values encode as the value contained in the interface.\n// A nil interface value encodes as the null JSON value.\n//\n// Channel, complex, and function values cannot be encoded in JSON.\n// Attempting to encode such a value causes Marshal to return\n// an UnsupportedTypeError.\n//\n// JSON cannot represent cyclic data structures and Marshal does not\n// handle them. Passing cyclic structures to Marshal will result in\n// an infinite recursion.\nfunc Marshal(v interface{}) ([]byte, error) {\n\treturn MarshalWithOption(v)\n}\n\n// MarshalNoEscape returns the JSON encoding of v and doesn't escape v.\nfunc MarshalNoEscape(v interface{}) ([]byte, error) {\n\treturn marshalNoEscape(v)\n}\n\n// MarshalContext returns the JSON encoding of v with context.Context and EncodeOption.\nfunc MarshalContext(ctx context.Context, v interface{}, optFuncs ...EncodeOptionFunc) ([]byte, error) {\n\treturn marshalContext(ctx, v, optFuncs...)\n}\n\n// MarshalWithOption returns the JSON encoding of v with EncodeOption.\nfunc MarshalWithOption(v interface{}, optFuncs ...EncodeOptionFunc) ([]byte, error) {\n\treturn marshal(v, optFuncs...)\n}\n\n// MarshalIndent is like Marshal but applies Indent to format the output.\n// Each JSON element in the output will begin on a new line beginning with prefix\n// followed by one or more copies of indent according to the indentation nesting.\nfunc MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {\n\treturn MarshalIndentWithOption(v, prefix, indent)\n}\n\n// MarshalIndentWithOption is like Marshal but applies Indent to format the output with EncodeOption.\nfunc MarshalIndentWithOption(v interface{}, prefix, indent string, optFuncs ...EncodeOptionFunc) ([]byte, error) {\n\treturn marshalIndent(v, prefix, indent, optFuncs...)\n}\n\n// Unmarshal parses the JSON-encoded data and stores the result\n// in the value pointed to by v. If v is nil or not a pointer,\n// Unmarshal returns an InvalidUnmarshalError.\n//\n// Unmarshal uses the inverse of the encodings that\n// Marshal uses, allocating maps, slices, and pointers as necessary,\n// with the following additional rules:\n//\n// To unmarshal JSON into a pointer, Unmarshal first handles the case of\n// the JSON being the JSON literal null. In that case, Unmarshal sets\n// the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\n// the value pointed at by the pointer. If the pointer is nil, Unmarshal\n// allocates a new value for it to point to.\n//\n// To unmarshal JSON into a value implementing the Unmarshaler interface,\n// Unmarshal calls that value's UnmarshalJSON method, including\n// when the input is a JSON null.\n// Otherwise, if the value implements encoding.TextUnmarshaler\n// and the input is a JSON quoted string, Unmarshal calls that value's\n// UnmarshalText method with the unquoted form of the string.\n//\n// To unmarshal JSON into a struct, Unmarshal matches incoming object\n// keys to the keys used by Marshal (either the struct field name or its tag),\n// preferring an exact match but also accepting a case-insensitive match. By\n// default, object keys which don't have a corresponding struct field are\n// ignored (see Decoder.DisallowUnknownFields for an alternative).\n//\n// To unmarshal JSON into an interface value,\n// Unmarshal stores one of these in the interface value:\n//\n//\tbool, for JSON booleans\n//\tfloat64, for JSON numbers\n//\tstring, for JSON strings\n//\t[]interface{}, for JSON arrays\n//\tmap[string]interface{}, for JSON objects\n//\tnil for JSON null\n//\n// To unmarshal a JSON array into a slice, Unmarshal resets the slice length\n// to zero and then appends each element to the slice.\n// As a special case, to unmarshal an empty JSON array into a slice,\n// Unmarshal replaces the slice with a new empty slice.\n//\n// To unmarshal a JSON array into a Go array, Unmarshal decodes\n// JSON array elements into corresponding Go array elements.\n// If the Go array is smaller than the JSON array,\n// the additional JSON array elements are discarded.\n// If the JSON array is smaller than the Go array,\n// the additional Go array elements are set to zero values.\n//\n// To unmarshal a JSON object into a map, Unmarshal first establishes a map to\n// use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\n// reuses the existing map, keeping existing entries. Unmarshal then stores\n// key-value pairs from the JSON object into the map. The map's key type must\n// either be any string type, an integer, implement json.Unmarshaler, or\n// implement encoding.TextUnmarshaler.\n//\n// If a JSON value is not appropriate for a given target type,\n// or if a JSON number overflows the target type, Unmarshal\n// skips that field and completes the unmarshaling as best it can.\n// If no more serious errors are encountered, Unmarshal returns\n// an UnmarshalTypeError describing the earliest such error. In any\n// case, it's not guaranteed that all the remaining fields following\n// the problematic one will be unmarshaled into the target object.\n//\n// The JSON null value unmarshals into an interface, map, pointer, or slice\n// by setting that Go value to nil. Because null is often used in JSON to mean\n// “not present,” unmarshaling a JSON null into any other Go type has no effect\n// on the value and produces no error.\n//\n// When unmarshaling quoted strings, invalid UTF-8 or\n// invalid UTF-16 surrogate pairs are not treated as an error.\n// Instead, they are replaced by the Unicode replacement\n// character U+FFFD.\nfunc Unmarshal(data []byte, v interface{}) error {\n\treturn unmarshal(data, v)\n}\n\n// UnmarshalContext parses the JSON-encoded data and stores the result\n// in the value pointed to by v. If you implement the UnmarshalerContext interface,\n// call it with ctx as an argument.\nfunc UnmarshalContext(ctx context.Context, data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\treturn unmarshalContext(ctx, data, v)\n}\n\nfunc UnmarshalWithOption(data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\treturn unmarshal(data, v, optFuncs...)\n}\n\nfunc UnmarshalNoEscape(data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\treturn unmarshalNoEscape(data, v, optFuncs...)\n}\n\n// A Token holds a value of one of these types:\n//\n//\tDelim, for the four JSON delimiters [ ] { }\n//\tbool, for JSON booleans\n//\tfloat64, for JSON numbers\n//\tNumber, for JSON numbers\n//\tstring, for JSON string literals\n//\tnil, for JSON null\ntype Token = json.Token\n\n// A Number represents a JSON number literal.\ntype Number = json.Number\n\n// RawMessage is a raw encoded JSON value.\n// It implements Marshaler and Unmarshaler and can\n// be used to delay JSON decoding or precompute a JSON encoding.\ntype RawMessage = json.RawMessage\n\n// A Delim is a JSON array or object delimiter, one of [ ] { or }.\ntype Delim = json.Delim\n\n// Compact appends to dst the JSON-encoded src with\n// insignificant space characters elided.\nfunc Compact(dst *bytes.Buffer, src []byte) error {\n\treturn encoder.Compact(dst, src, false)\n}\n\n// Indent appends to dst an indented form of the JSON-encoded src.\n// Each element in a JSON object or array begins on a new,\n// indented line beginning with prefix followed by one or more\n// copies of indent according to the indentation nesting.\n// The data appended to dst does not begin with the prefix nor\n// any indentation, to make it easier to embed inside other formatted JSON data.\n// Although leading space characters (space, tab, carriage return, newline)\n// at the beginning of src are dropped, trailing space characters\n// at the end of src are preserved and copied to dst.\n// For example, if src has no trailing spaces, neither will dst;\n// if src ends in a trailing newline, so will dst.\nfunc Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {\n\treturn encoder.Indent(dst, src, prefix, indent)\n}\n\n// HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\n// characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\n// so that the JSON will be safe to embed inside HTML <script> tags.\n// For historical reasons, web browsers don't honor standard HTML\n// escaping within <script> tags, so an alternative JSON encoding must\n// be used.\nfunc HTMLEscape(dst *bytes.Buffer, src []byte) {\n\tvar v interface{}\n\tdec := NewDecoder(bytes.NewBuffer(src))\n\tdec.UseNumber()\n\tif err := dec.Decode(&v); err != nil {\n\t\treturn\n\t}\n\tbuf, _ := marshal(v)\n\tdst.Write(buf)\n}\n\n// Valid reports whether data is a valid JSON encoding.\nfunc Valid(data []byte) bool {\n\tvar v interface{}\n\tdecoder := NewDecoder(bytes.NewReader(data))\n\terr := decoder.Decode(&v)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif !decoder.More() {\n\t\treturn true\n\t}\n\treturn decoder.InputOffset() >= int64(len(data))\n}\n\nfunc init() {\n\tencoder.Marshal = Marshal\n\tencoder.Unmarshal = Unmarshal\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 10.7900390625,
          "content": "package json_test\n\nimport (\n\t\"bytes\"\n\tstdjson \"encoding/json\"\n\t\"math\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\nvar validTests = []struct {\n\tdata string\n\tok   bool\n}{\n\t{`foo`, false},\n\t{`}{`, false},\n\t{`{]`, false},\n\t{`{}`, true},\n\t{`{\"foo\":\"bar\"}`, true},\n\t{`{\"foo\":\"bar\",\"bar\":{\"baz\":[\"qux\"]}}`, true},\n\t{`[\"\"],`, false},\n}\n\nfunc TestValid(t *testing.T) {\n\tfor _, tt := range validTests {\n\t\tif ok := json.Valid([]byte(tt.data)); ok != tt.ok {\n\t\t\tt.Errorf(\"Valid(%#q) = %v, want %v\", tt.data, ok, tt.ok)\n\t\t}\n\t}\n}\n\nfunc TestValidWithComplexData(t *testing.T) {\n\tdata := []byte(`{\"ABCDEFGHIJKL\":[{\"MNOPQRSTUVWX\":[{\"YABC\":{\"DEFG\":[{\"HIJKLMNO\":{\"PQRS\":\"TUVWXYABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJKLMNOPQRSTUVWXYABCDE\",\"FGHIJKLM\":\"NOPQRSTUVW\"},\"XYABCDEFGH\":[{\"IJKLMNOP\":\"!=\",\"Q\":{\"RSTU\":\"V\",\"WXYABCDE\":\"FGHIJKLMNO\"},\"P\":{\"QRSTUVWX\":\"YAB\"},\"CDEFGHIJ\":\"KLMNOP\",\"QRSTUVWX\":\"YABCDEFGHI\"}],\"JKLMNOPQRSTUVW\":null,\"XYABCDEF\":\"GHIJ\"},{\"KLMNOPQR\":{\"STUVWXY\":{\"ABCDEFGH\":\"IJKLMN_OPQ_RST\",\"U\":{\"VWXY\":\"A\",\"BCDEFGHI\":\"JKLMNOPQRS\"},\"TUVWXYAB\":\"CDEFG\",\"HIJKLMNO\":\"PQRSTUVWXY\"},\"ABCDEFGH\":\"IJKLMNOP!Q41R8ST98U00V204W9800998XYA8427B\",\"CDEFGHIJ\":\"KLMNOP\",\"QRSTUVWX\":\"YABCDEFGHI\"},\"JKLMNOPQRS\":null,\"TUVWXYABCDEFGH\":null,\"IJKLMNOP\":\"QRST\"}],\"UVWXYABC\":\"DEFGH\",\"IJKLMNOP\":\"QRSTUVWXY\"},\"ABCDEFGH\":9,\"IJKL\":\"MNOPQRST/UVWXYABCDE//FGHIJKLMNOPQRST!4UV2WXYABC7826D7659EF223GH40I91J\",\"KLMNOPQRST\":[{\"UVWXYABCDEFG\":null,\"HIJKLMNO\":0,\"PQRS\":\"T\",\"UVWX\":{\"YABC\":{\"DEFG\":\"HIJK/LMNO/PQRSTU\",\"VWXYABCD\":\"EFGHIJKLM\",\"NOPQRSTU\":\"VWXY\"},\"ABCDEFGH\":\"IJKLMNO\",\"PQRSTUVW\":\"XYAB\"},\"CDEFGHIJ\":\"KLMNOPQR\"}],\"STUVWXYA\":null,\"BCDEFGH\":null,\"IJKLMN\":null,\"OPQRSTUVWXYABC\":null,\"DEFGHIJK\":\"LMNOPQRS\"},{\"TUVW\":{\"XYAB\":[{\"CDEFGHIJ\":{\"KLMN\":\"OPQRSTUV/WXYABCDEFG//HIJKLMNOPQRSTUV!4WX2YABCDE7826F7659GH223IJ40K91L\",\"MNOPQRST\":\"UVWXYABCDE\"},\"FGHIJKLMNO\":[{\"PQRS\":\"T\",\"UVWXYABC\":\"DEFGHIJKLM\"}],\"NOPQRSTUVWXYAB\":null,\"CDEFGHIJ\":\"KLMN\"}],\"OPQRSTUV\":\"WXYAB\",\"CDEFGHIJ\":\"KLMNOPQRS\"},\"TUVWXYAB\":9,\"CDEF\":\"GHIJKLMN/OPQRSTUVWX//YABCDEFGHIJKLM!4NO2PQRSTU7826V7659WX223YA40B91C\",\"DEFGHIJKLM\":[{\"NOPQRSTUVWXY\":null,\"ABCDEFGH\":0,\"IJKL\":\"M\",\"NOPQ\":{\"RSTU\":{\"VWXY\":\"ABCD/EFGH/IJKLMN\",\"OPQRSTUV\":\"WXYABCDEF\",\"GHIJKLMN\":\"OPQR\"},\"STUVWXYA\":\"BCDEFGH\",\"IJKLMNOP\":\"QRST\"},\"UVWXYABC\":\"DEFGHIJK\"}],\"LMNOPQRS\":null,\"TUVWXYA\":null,\"BCDEFG\":null,\"HIJKLMNOPQRSTU\":null,\"VWXYABCD\":\"EFGHIJKL\"},{\"MNOP\":{\"QRST\":[{\"UVWXYABC\":0,\"DEFG\":[\"HIJK\"],\"LMNO\":[{\"PQRS\":{\"TUVW\":\"XYABCDEF/GHIJKLMNOP\",\"QRSTUVWX\":\"YABCDEFGH\",\"IJKLMNOP\":\"QRST\"},\"UVWXYABC\":\"DEFGHIJ\",\"KLMNOPQR\":\"STUV\"}],\"WXYAB\":[{\"CDEF\":{\"GHIJ\":{\"KLMN\":\"OPQRSTUV/WXYABCDEFG\",\"HIJKLMNO\":\"PQRSTUVWX\",\"YABCDEFG\":\"HIJK\"},\"LMNOPQRS\":\"TUVWXYA\",\"BCDEFGHI\":\"JKLM\"},\"NOPQRSTU\":\"VWX\"}],\"YABCDEFG\":\"HIJKLMNOPQR\",\"STUVWXYA\":\"BCDEFGHIJ\"},{\"KLMNOPQR\":\"=\",\"S\":{\"TUVWXYA\":{\"BCDE\":\"FGHI\",\"JKLMNOPQ\":\"RSTUVWXYAB\"},\"CDEFGHIJ\":\"@KLMN/OPQR/STUVWX\",\"YABCDEFG\":\"HIJKLM\",\"NOPQRSTU\":\"VWXYABCDEF\"},\"G\":{\"HIJKLMNO\":{\"PQRS\":\"TUVW/XYAB/CDEFGH//IJKLMN!O41P8QR98S00T204U9800998VWX8427Y\",\"ABCDEFGH\":\"IJKLMNOPQR\"},\"STUVWXYABC\":null,\"DEFGHIJKLMNOPQ\":null,\"RSTUVWXY\":\"ABCD\"},\"EFGHIJKL\":\"MNOPQR\",\"STUVWXYA\":\"BCDEFGHIJK\"},{\"LMNOPQR\":[{\"STUV\":\"WXYA\",\"BCDEFGHI\":\"JKLMNOPQRS\"}],\"TUVWXYAB\":\"CDEFGH\",\"IJKLMNOP\":\"QRSTUVWXY\"}],\"ABCDEFGH\":\"IJKLM\",\"NOPQRSTU\":\"VWXYABCDE\"},\"FGHIJKLM\":37,\"NOPQ\":\"RSTUVWXY/ABCDEFGHIJ//KLMNOPQRST!U41V8WX98Y00A204B9800998CDE8427F\",\"GHIJKLMNOP\":null,\"QRSTUVWX\":null,\"YABCDEF\":[{\"GHIJKLMNOPQR\":null,\"STUVWXYA\":0,\"BCDE\":\"\",\"FGHI\":{\"JKLM\":{\"NOPQ\":\"RSTUVWXY/ABCDEFGHIJ\",\"KLMNOPQR\":\"STUVWXYAB\",\"CDEFGHIJ\":\"KLMN\"},\"OPQRSTUV\":\"WXYABCD\",\"EFGHIJKL\":\"MNOP\"},\"QRSTUVWX\":\"YABCDEFG\"}],\"HIJKLM\":null,\"NOPQRSTUVWXYAB\":null,\"CDEFGHIJ\":\"KLMNOPQR\"}],\"STUVWXYABC\":null,\"DEFGHIJK\":[{\"LMNO\":{\"PQRS\":\"TUVW/XYAB/CDEFGH\",\"IJKLMNOP\":\"QRSTUVWXY\",\"ABCDEFGH\":\"IJKL\"},\"MNOPQRST\":\"UVWXYAB\",\"CDEFGHIJ\":\"KLMN\"}],\"OPQRSTUV\":1,\"WXYA\":\"BCDEFGHI/JKLMNOPQRS\",\"TUVWXYAB\":null,\"CDEFGHIJKLMNOP\":null,\"QRSTUVWX\":\"YABCDE\",\"FGHIJKLM\":\"NOPQ\"}]}`)\n\texpected := stdjson.Valid(data)\n\tactual := json.Valid(data)\n\tif expected != actual {\n\t\tt.Fatalf(\"failed to valid: expected %v but got %v\", expected, actual)\n\t}\n}\n\ntype example struct {\n\tcompact string\n\tindent  string\n}\n\nvar examples = []example{\n\t{`1`, `1`},\n\t{`{}`, `{}`},\n\t{`[]`, `[]`},\n\t{`{\"\":2}`, \"{\\n\\t\\\"\\\": 2\\n}\"},\n\t{`[3]`, \"[\\n\\t3\\n]\"},\n\t{`[1,2,3]`, \"[\\n\\t1,\\n\\t2,\\n\\t3\\n]\"},\n\t{`{\"x\":1}`, \"{\\n\\t\\\"x\\\": 1\\n}\"},\n\t{ex1, ex1i},\n\t{\"{\\\"\\\":\\\"<>&\\u2028\\u2029\\\"}\", \"{\\n\\t\\\"\\\": \\\"<>&\\u2028\\u2029\\\"\\n}\"}, // See golang.org/issue/34070\n}\n\nvar ex1 = `[true,false,null,\"x\",1,1.5,0,-5e+2]`\n\nvar ex1i = `[\n\ttrue,\n\tfalse,\n\tnull,\n\t\"x\",\n\t1,\n\t1.5,\n\t0,\n\t-5e+2\n]`\n\nfunc TestCompact(t *testing.T) {\n\tvar buf bytes.Buffer\n\tfor _, tt := range examples {\n\t\tbuf.Reset()\n\t\tt.Log(\"src = \", tt.compact)\n\t\tif err := json.Compact(&buf, []byte(tt.compact)); err != nil {\n\t\t\tt.Errorf(\"Compact(%#q): %v\", tt.compact, err)\n\t\t} else if s := buf.String(); s != tt.compact {\n\t\t\tt.Errorf(\"Compact(%#q) = %#q, want original\", tt.compact, s)\n\t\t}\n\n\t\tbuf.Reset()\n\t\tif err := json.Compact(&buf, []byte(tt.indent)); err != nil {\n\t\t\tt.Errorf(\"Compact(%#q): %v\", tt.indent, err)\n\t\t\tcontinue\n\t\t} else if s := buf.String(); s != tt.compact {\n\t\t\tt.Errorf(\"Compact(%#q) = %#q, want %#q\", tt.indent, s, tt.compact)\n\t\t}\n\t}\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\tfor _, src := range []string{\n\t\t\t`invalid`,\n\t\t\t`}`,\n\t\t\t`]`,\n\t\t\t`{\"a\":1}}`,\n\t\t\t`{\"a\" 1}`,\n\t\t\t`{\"a\": 1 \"b\": 2}`,\n\t\t\t`[\"a\" \"b\"]`,\n\t\t\t`\"\\`,\n\t\t\t`{\"a\":\"\\\\\"\"}`,\n\t\t\t`tr`,\n\t\t\t`{\"a\": tru, \"b\": 1}`,\n\t\t\t`fal`,\n\t\t\t`{\"a\": fals, \"b\": 1}`,\n\t\t\t`nu`,\n\t\t\t`{\"a\": nul, \"b\": 1}`,\n\t\t\t`1.234.567`,\n\t\t\t`[nul]`,\n\t\t\t`{}   1`,\n\t\t} {\n\t\t\tbuf.Reset()\n\t\t\tif err := stdjson.Compact(&buf, []byte(src)); err == nil {\n\t\t\t\tt.Fatal(\"invalid test case\")\n\t\t\t}\n\t\t\tbuf.Reset()\n\t\t\tif err := json.Compact(&buf, []byte(src)); err == nil {\n\t\t\t\tt.Fatalf(\"%q: expected error\", src)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestCompactSeparators(t *testing.T) {\n\t// U+2028 and U+2029 should be escaped inside strings.\n\t// They should not appear outside strings.\n\ttests := []struct {\n\t\tin, compact string\n\t}{\n\t\t{\"{\\\"\\u2028\\\": 1}\", \"{\\\"\\u2028\\\":1}\"},\n\t\t{\"{\\\"\\u2029\\\" :2}\", \"{\\\"\\u2029\\\":2}\"},\n\t}\n\tfor _, tt := range tests {\n\t\tvar buf bytes.Buffer\n\t\tif err := json.Compact(&buf, []byte(tt.in)); err != nil {\n\t\t\tt.Errorf(\"Compact(%q): %v\", tt.in, err)\n\t\t} else if s := buf.String(); s != tt.compact {\n\t\t\tt.Errorf(\"Compact(%q) = %q, want %q\", tt.in, s, tt.compact)\n\t\t}\n\t}\n}\n\nfunc TestIndent(t *testing.T) {\n\tvar buf bytes.Buffer\n\tfor _, tt := range examples {\n\t\tbuf.Reset()\n\t\tif err := json.Indent(&buf, []byte(tt.indent), \"\", \"\\t\"); err != nil {\n\t\t\tt.Errorf(\"Indent(%#q): %v\", tt.indent, err)\n\t\t} else if s := buf.String(); s != tt.indent {\n\t\t\tt.Errorf(\"Indent(%#q) = %#q, want original\", tt.indent, s)\n\t\t}\n\n\t\tbuf.Reset()\n\t\tif err := json.Indent(&buf, []byte(tt.compact), \"\", \"\\t\"); err != nil {\n\t\t\tt.Errorf(\"Indent(%#q): %v\", tt.compact, err)\n\t\t\tcontinue\n\t\t} else if s := buf.String(); s != tt.indent {\n\t\t\tt.Errorf(\"Indent(%#q) = %#q, want %#q\", tt.compact, s, tt.indent)\n\t\t}\n\t}\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\tfor _, src := range []string{\n\t\t\t`invalid`,\n\t\t\t`}`,\n\t\t\t`]`,\n\t\t\t`{\"a\":1}}`,\n\t\t\t`{\"a\" 1}`,\n\t\t\t`{\"a\": 1 \"b\": 2}`,\n\t\t\t`[\"a\" \"b\"]`,\n\t\t\t`\"\\`,\n\t\t\t`{\"a\":\"\\\\\"\"}`,\n\t\t\t`tr`,\n\t\t\t`{\"a\": tru, \"b\": 1}`,\n\t\t\t`fal`,\n\t\t\t`{\"a\": fals, \"b\": 1}`,\n\t\t\t`nu`,\n\t\t\t`{\"a\": nul, \"b\": 1}`,\n\t\t\t`1.234.567`,\n\t\t\t`[nul]`,\n\t\t\t`{}   1`,\n\t\t} {\n\t\t\tbuf.Reset()\n\t\t\tif err := stdjson.Indent(&buf, []byte(src), \"\", \" \"); err == nil {\n\t\t\t\tt.Fatal(\"invalid test case\")\n\t\t\t}\n\t\t\tbuf.Reset()\n\t\t\tif err := json.Indent(&buf, []byte(src), \"\", \" \"); err == nil {\n\t\t\t\tt.Fatalf(\"%q: expected error\", src)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// Tests of a large random structure.\nfunc TestCompactBig(t *testing.T) {\n\tinitBig()\n\tvar buf bytes.Buffer\n\tif err := json.Compact(&buf, jsonBig); err != nil {\n\t\tt.Fatalf(\"Compact: %v\", err)\n\t}\n\tb := buf.Bytes()\n\tif !bytes.Equal(b, jsonBig) {\n\t\tt.Error(\"Compact(jsonBig) != jsonBig\")\n\t\tdiff(t, b, jsonBig)\n\t\treturn\n\t}\n}\n\nfunc TestIndentBig(t *testing.T) {\n\t//t.Parallel()\n\tinitBig()\n\tvar buf bytes.Buffer\n\tif err := json.Indent(&buf, jsonBig, \"\", \"\\t\"); err != nil {\n\t\tt.Fatalf(\"Indent1: %v\", err)\n\t}\n\tb := buf.Bytes()\n\tif len(b) == len(jsonBig) {\n\t\t// jsonBig is compact (no unnecessary spaces);\n\t\t// indenting should make it bigger\n\t\tt.Fatalf(\"Indent(jsonBig) did not get bigger\")\n\t}\n\n\t// should be idempotent\n\tvar buf1 bytes.Buffer\n\tif err := json.Indent(&buf1, b, \"\", \"\\t\"); err != nil {\n\t\tt.Fatalf(\"Indent2: %v\", err)\n\t}\n\tb1 := buf1.Bytes()\n\tif !bytes.Equal(b1, b) {\n\t\tt.Error(\"Indent(Indent(jsonBig)) != Indent(jsonBig)\")\n\t\tdiff(t, b1, b)\n\t\treturn\n\t}\n\n\t// should get back to original\n\tbuf1.Reset()\n\tif err := json.Compact(&buf1, b); err != nil {\n\t\tt.Fatalf(\"Compact: %v\", err)\n\t}\n\tb1 = buf1.Bytes()\n\tif !bytes.Equal(b1, jsonBig) {\n\t\tt.Error(\"Compact(Indent(jsonBig)) != jsonBig\")\n\t\tdiff(t, b1, jsonBig)\n\t\treturn\n\t}\n}\n\ntype indentErrorTest struct {\n\tin  string\n\terr error\n}\n\nvar indentErrorTests = []indentErrorTest{\n\t{`{\"X\": \"foo\", \"Y\"}`, json.NewSyntaxError(\"invalid character '}' after object key\", 17)},\n\t{`{\"X\": \"foo\" \"Y\": \"bar\"}`, json.NewSyntaxError(\"invalid character '\\\"' after object key:value pair\", 13)},\n}\n\nfunc TestIndentErrors(t *testing.T) {\n\tfor i, tt := range indentErrorTests {\n\t\tslice := make([]uint8, 0)\n\t\tbuf := bytes.NewBuffer(slice)\n\t\tif err := json.Indent(buf, []uint8(tt.in), \"\", \"\"); err != nil {\n\t\t\tif !reflect.DeepEqual(err, tt.err) {\n\t\t\t\tt.Errorf(\"#%d: Indent: expected %#v but got %#v\", i, tt.err, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc diff(t *testing.T, a, b []byte) {\n\tt.Helper()\n\tfor i := 0; ; i++ {\n\t\tif i >= len(a) || i >= len(b) || a[i] != b[i] {\n\t\t\tj := i - 10\n\t\t\tif j < 0 {\n\t\t\t\tj = 0\n\t\t\t}\n\t\t\tt.Errorf(\"diverge at %d: «%s» vs «%s»\", i, trim(a[j:]), trim(b[j:]))\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc trim(b []byte) []byte {\n\tif len(b) > 20 {\n\t\treturn b[0:20]\n\t}\n\treturn b\n}\n\n// Generate a random JSON object.\n\nvar (\n\tjsonBig []byte\n)\n\nfunc initBig() {\n\tn := 10000\n\tif testing.Short() {\n\t\tn = 100\n\t}\n\tv := genValue(n)\n\tb, err := json.Marshal(v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tjsonBig = b\n}\n\nfunc genValue(n int) interface{} {\n\tif n > 1 {\n\t\tswitch rand.Intn(2) {\n\t\tcase 0:\n\t\t\treturn genArray(n)\n\t\tcase 1:\n\t\t\treturn genMap(n)\n\t\t}\n\t}\n\tswitch rand.Intn(3) {\n\tcase 0:\n\t\treturn rand.Intn(2) == 0\n\tcase 1:\n\t\treturn rand.NormFloat64()\n\tcase 2:\n\t\treturn genString(30)\n\t}\n\tpanic(\"unreachable\")\n}\n\nfunc genString(stddev float64) string {\n\tn := int(math.Abs(rand.NormFloat64()*stddev + stddev/2))\n\tc := make([]rune, n)\n\tfor i := range c {\n\t\tf := math.Abs(rand.NormFloat64()*64 + 32)\n\t\tif f > 0x10ffff {\n\t\t\tf = 0x10ffff\n\t\t}\n\t\tc[i] = rune(f)\n\t}\n\treturn string(c)\n}\n\nfunc genArray(n int) []interface{} {\n\tf := int(math.Abs(rand.NormFloat64()) * math.Min(10, float64(n/2)))\n\tif f > n {\n\t\tf = n\n\t}\n\tif f < 1 {\n\t\tf = 1\n\t}\n\tx := make([]interface{}, f)\n\tfor i := range x {\n\t\tx[i] = genValue(((i+1)*n)/f - (i*n)/f)\n\t}\n\treturn x\n}\n\nfunc genMap(n int) map[string]interface{} {\n\tf := int(math.Abs(rand.NormFloat64()) * math.Min(10, float64(n/2)))\n\tif f > n {\n\t\tf = n\n\t}\n\tif n > 0 && f == 0 {\n\t\tf = 1\n\t}\n\tx := make(map[string]interface{})\n\tfor i := 0; i < f; i++ {\n\t\tx[genString(10)] = genValue(((i+1)*n)/f - (i*n)/f)\n\t}\n\treturn x\n}\n"
        },
        {
          "name": "number_test.go",
          "type": "blob",
          "size": 3.3583984375,
          "content": "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage json_test\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\nfunc TestNumberIsValid(t *testing.T) {\n\t// From: https://stackoverflow.com/a/13340826\n\tvar jsonNumberRegexp = regexp.MustCompile(`^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$`)\n\n\tvalidTests := []string{\n\t\t\"0\",\n\t\t\"-0\",\n\t\t\"1\",\n\t\t\"-1\",\n\t\t\"0.1\",\n\t\t\"-0.1\",\n\t\t\"1234\",\n\t\t\"-1234\",\n\t\t\"12.34\",\n\t\t\"-12.34\",\n\t\t\"12E0\",\n\t\t\"12E1\",\n\t\t\"12e34\",\n\t\t\"12E-0\",\n\t\t\"12e+1\",\n\t\t\"12e-34\",\n\t\t\"-12E0\",\n\t\t\"-12E1\",\n\t\t\"-12e34\",\n\t\t\"-12E-0\",\n\t\t\"-12e+1\",\n\t\t\"-12e-34\",\n\t\t\"1.2E0\",\n\t\t\"1.2E1\",\n\t\t\"1.2e34\",\n\t\t\"1.2E-0\",\n\t\t\"1.2e+1\",\n\t\t\"1.2e-34\",\n\t\t\"-1.2E0\",\n\t\t\"-1.2E1\",\n\t\t\"-1.2e34\",\n\t\t\"-1.2E-0\",\n\t\t\"-1.2e+1\",\n\t\t\"-1.2e-34\",\n\t\t\"0E0\",\n\t\t\"0E1\",\n\t\t\"0e34\",\n\t\t\"0E-0\",\n\t\t\"0e+1\",\n\t\t\"0e-34\",\n\t\t\"-0E0\",\n\t\t\"-0E1\",\n\t\t\"-0e34\",\n\t\t\"-0E-0\",\n\t\t\"-0e+1\",\n\t\t\"-0e-34\",\n\t}\n\n\tfor i, test := range validTests {\n\t\tif !isValidNumber(test) {\n\t\t\tt.Errorf(\"%d: %s should be valid\", i, test)\n\t\t}\n\n\t\tvar f float64\n\t\tif err := json.Unmarshal([]byte(test), &f); err != nil {\n\t\t\tt.Errorf(\"%d: %s should be valid but Unmarshal failed: %v\", i, test, err)\n\t\t}\n\n\t\tif !jsonNumberRegexp.MatchString(test) {\n\t\t\tt.Errorf(\"%d: %s should be valid but regexp does not match\", i, test)\n\t\t}\n\t}\n\n\tinvalidTests := []string{\n\t\t\"\",\n\t\t\"invalid\",\n\t\t\"1.0.1\",\n\t\t\"1..1\",\n\t\t\"-1-2\",\n\t\t\"012a42\",\n\t\t//\"01.2\",\n\t\t//\"012\",\n\t\t\"12E12.12\",\n\t\t\"1e2e3\",\n\t\t\"1e+-2\",\n\t\t\"1e--23\",\n\t\t\"1e\",\n\t\t\"e1\",\n\t\t\"1e+\",\n\t\t\"1ea\",\n\t\t\"1a\",\n\t\t\"1.a\",\n\t\t//\"1.\",\n\t\t//\"01\",\n\t\t//\"1.e1\",\n\t}\n\n\tfor i, test := range invalidTests {\n\t\tif isValidNumber(test) {\n\t\t\tt.Errorf(\"%d: %s should be invalid\", i, test)\n\t\t}\n\n\t\tvar f float64\n\t\tif err := json.Unmarshal([]byte(test), &f); err == nil {\n\t\t\tt.Errorf(\"%d: %s should be invalid but unmarshal wrote %v\", i, test, f)\n\t\t}\n\n\t\tif jsonNumberRegexp.MatchString(test) {\n\t\t\tt.Errorf(\"%d: %s should be invalid but matches regexp\", i, test)\n\t\t}\n\t}\n}\n\n// isValidNumber reports whether s is a valid JSON number literal.\nfunc isValidNumber(s string) bool {\n\t// This function implements the JSON numbers grammar.\n\t// See https://tools.ietf.org/html/rfc7159#section-6\n\t// and https://www.json.org/img/number.png\n\n\tif s == \"\" {\n\t\treturn false\n\t}\n\n\t// Optional -\n\tif s[0] == '-' {\n\t\ts = s[1:]\n\t\tif s == \"\" {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Digits\n\tswitch {\n\tdefault:\n\t\treturn false\n\n\tcase s[0] == '0':\n\t\ts = s[1:]\n\n\tcase '1' <= s[0] && s[0] <= '9':\n\t\ts = s[1:]\n\t\tfor len(s) > 0 && '0' <= s[0] && s[0] <= '9' {\n\t\t\ts = s[1:]\n\t\t}\n\t}\n\n\t// . followed by 1 or more digits.\n\tif len(s) >= 2 && s[0] == '.' && '0' <= s[1] && s[1] <= '9' {\n\t\ts = s[2:]\n\t\tfor len(s) > 0 && '0' <= s[0] && s[0] <= '9' {\n\t\t\ts = s[1:]\n\t\t}\n\t}\n\n\t// e or E followed by an optional - or + and\n\t// 1 or more digits.\n\tif len(s) >= 2 && (s[0] == 'e' || s[0] == 'E') {\n\t\ts = s[1:]\n\t\tif s[0] == '+' || s[0] == '-' {\n\t\t\ts = s[1:]\n\t\t\tif s == \"\" {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tfor len(s) > 0 && '0' <= s[0] && s[0] <= '9' {\n\t\t\ts = s[1:]\n\t\t}\n\t}\n\n\t// Make sure we are at the end.\n\treturn s == \"\"\n}\n\nfunc BenchmarkNumberIsValid(b *testing.B) {\n\ts := \"-61657.61667E+61673\"\n\tfor i := 0; i < b.N; i++ {\n\t\tisValidNumber(s)\n\t}\n}\n\nfunc BenchmarkNumberIsValidRegexp(b *testing.B) {\n\tvar jsonNumberRegexp = regexp.MustCompile(`^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$`)\n\ts := \"-61657.61667E+61673\"\n\tfor i := 0; i < b.N; i++ {\n\t\tjsonNumberRegexp.MatchString(s)\n\t}\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 2.529296875,
          "content": "package json\n\nimport (\n\t\"io\"\n\n\t\"github.com/goccy/go-json/internal/decoder\"\n\t\"github.com/goccy/go-json/internal/encoder\"\n)\n\ntype EncodeOption = encoder.Option\ntype EncodeOptionFunc func(*EncodeOption)\n\n// UnorderedMap doesn't sort when encoding map type.\nfunc UnorderedMap() EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.Flag |= encoder.UnorderedMapOption\n\t}\n}\n\n// DisableHTMLEscape disables escaping of HTML characters ( '&', '<', '>' ) when encoding string.\nfunc DisableHTMLEscape() EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.Flag &= ^encoder.HTMLEscapeOption\n\t}\n}\n\n// DisableNormalizeUTF8\n// By default, when encoding string, UTF8 characters in the range of 0x80 - 0xFF are processed by applying \\ufffd for invalid code and escaping for \\u2028 and \\u2029.\n// This option disables this behaviour. You can expect faster speeds by applying this option, but be careful.\n// encoding/json implements here: https://github.com/golang/go/blob/6178d25fc0b28724b1b5aec2b1b74fc06d9294c7/src/encoding/json/encode.go#L1067-L1093.\nfunc DisableNormalizeUTF8() EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.Flag &= ^encoder.NormalizeUTF8Option\n\t}\n}\n\n// Debug outputs debug information when panic occurs during encoding.\nfunc Debug() EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.Flag |= encoder.DebugOption\n\t}\n}\n\n// DebugWith sets the destination to write debug messages.\nfunc DebugWith(w io.Writer) EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.DebugOut = w\n\t}\n}\n\n// DebugDOT sets the destination to write opcodes graph.\nfunc DebugDOT(w io.WriteCloser) EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.DebugDOTOut = w\n\t}\n}\n\n// Colorize add an identifier for coloring to the string of the encoded result.\nfunc Colorize(scheme *ColorScheme) EncodeOptionFunc {\n\treturn func(opt *EncodeOption) {\n\t\topt.Flag |= encoder.ColorizeOption\n\t\topt.ColorScheme = scheme\n\t}\n}\n\ntype DecodeOption = decoder.Option\ntype DecodeOptionFunc func(*DecodeOption)\n\n// DecodeFieldPriorityFirstWin\n// in the default behavior, go-json, like encoding/json,\n// will reflect the result of the last evaluation when a field with the same name exists.\n// This option allow you to change this behavior.\n// this option reflects the result of the first evaluation if a field with the same name exists.\n// This behavior has a performance advantage as it allows the subsequent strings to be skipped if all fields have been evaluated.\nfunc DecodeFieldPriorityFirstWin() DecodeOptionFunc {\n\treturn func(opt *DecodeOption) {\n\t\topt.Flags |= decoder.FirstWinOption\n\t}\n}\n"
        },
        {
          "name": "path.go",
          "type": "blob",
          "size": 2.56640625,
          "content": "package json\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/goccy/go-json/internal/decoder\"\n)\n\n// CreatePath creates JSON Path.\n//\n// JSON Path rule\n// $   : root object or element. The JSON Path format must start with this operator, which refers to the outermost level of the JSON-formatted string.\n// .   : child operator. You can identify child values using dot-notation.\n// ..  : recursive descent.\n// []  : subscript operator. If the JSON object is an array, you can use brackets to specify the array index.\n// [*] : all objects/elements for array.\n//\n// Reserved words must be properly escaped when included in Path.\n//\n// Escape Rule\n// single quote style escape: e.g.) `$['a.b'].c`\n// double quote style escape: e.g.) `$.\"a.b\".c`\nfunc CreatePath(p string) (*Path, error) {\n\tpath, err := decoder.PathString(p).Build()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Path{path: path}, nil\n}\n\n// Path represents JSON Path.\ntype Path struct {\n\tpath *decoder.Path\n}\n\n// RootSelectorOnly whether only the root selector ($) is used.\nfunc (p *Path) RootSelectorOnly() bool {\n\treturn p.path.RootSelectorOnly\n}\n\n// UsedSingleQuotePathSelector whether single quote-based escaping was done when building the JSON Path.\nfunc (p *Path) UsedSingleQuotePathSelector() bool {\n\treturn p.path.SingleQuotePathSelector\n}\n\n// UsedSingleQuotePathSelector whether double quote-based escaping was done when building the JSON Path.\nfunc (p *Path) UsedDoubleQuotePathSelector() bool {\n\treturn p.path.DoubleQuotePathSelector\n}\n\n// Extract extracts a specific JSON string.\nfunc (p *Path) Extract(data []byte, optFuncs ...DecodeOptionFunc) ([][]byte, error) {\n\treturn extractFromPath(p, data, optFuncs...)\n}\n\n// PathString returns original JSON Path string.\nfunc (p *Path) PathString() string {\n\treturn p.path.String()\n}\n\n// Unmarshal extract and decode the value of the part corresponding to JSON Path from the input data.\nfunc (p *Path) Unmarshal(data []byte, v interface{}, optFuncs ...DecodeOptionFunc) error {\n\tcontents, err := extractFromPath(p, data, optFuncs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tresults := make([]interface{}, 0, len(contents))\n\tfor _, content := range contents {\n\t\tvar result interface{}\n\t\tif err := Unmarshal(content, &result); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tresults = append(results, result)\n\t}\n\tif err := decoder.AssignValue(reflect.ValueOf(results), reflect.ValueOf(v)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Get extract and substitute the value of the part corresponding to JSON Path from the input value.\nfunc (p *Path) Get(src, dst interface{}) error {\n\treturn p.path.Get(reflect.ValueOf(src), reflect.ValueOf(dst))\n}\n"
        },
        {
          "name": "path_test.go",
          "type": "blob",
          "size": 5.09375,
          "content": "package json_test\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\nfunc TestExtractPath(t *testing.T) {\n\tsrc := []byte(`{\"a\":{\"b\":10,\"c\":true},\"b\":\"text\"}`)\n\tt.Run(\"$.a.b\", func(t *testing.T) {\n\t\tpath, err := json.CreatePath(\"$.a.b\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tcontents, err := path.Extract(src)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(contents) != 1 {\n\t\t\tt.Fatal(\"failed to extract\")\n\t\t}\n\t\tif !bytes.Equal(contents[0], []byte(\"10\")) {\n\t\t\tt.Fatal(\"failed to extract\")\n\t\t}\n\t})\n\tt.Run(\"$.b\", func(t *testing.T) {\n\t\tpath, err := json.CreatePath(\"$.b\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tcontents, err := path.Extract(src)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(contents) != 1 {\n\t\t\tt.Fatal(\"failed to extract\")\n\t\t}\n\t\tif !bytes.Equal(contents[0], []byte(`\"text\"`)) {\n\t\t\tt.Fatal(\"failed to extract\")\n\t\t}\n\t})\n\tt.Run(\"$.a\", func(t *testing.T) {\n\t\tpath, err := json.CreatePath(\"$.a\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tcontents, err := path.Extract(src)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(contents) != 1 {\n\t\t\tt.Fatal(\"failed to extract\")\n\t\t}\n\t\tif !bytes.Equal(contents[0], []byte(`{\"b\":10,\"c\":true}`)) {\n\t\t\tt.Fatal(\"failed to extract\")\n\t\t}\n\t})\n}\n\nfunc TestUnmarshalPath(t *testing.T) {\n\tt.Run(\"int\", func(t *testing.T) {\n\t\tsrc := []byte(`{\"a\":{\"b\":10,\"c\":true},\"b\":\"text\"}`)\n\t\tt.Run(\"success\", func(t *testing.T) {\n\t\t\tpath, err := json.CreatePath(\"$.a.b\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v int\n\t\t\tif err := path.Unmarshal(src, &v); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif v != 10 {\n\t\t\t\tt.Fatal(\"failed to unmarshal path\")\n\t\t\t}\n\t\t})\n\t\tt.Run(\"failure\", func(t *testing.T) {\n\t\t\tpath, err := json.CreatePath(\"$.a.c\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v map[string]interface{}\n\t\t\tif err := path.Unmarshal(src, &v); err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"bool\", func(t *testing.T) {\n\t\tsrc := []byte(`{\"a\":{\"b\":10,\"c\":true},\"b\":\"text\"}`)\n\t\tt.Run(\"success\", func(t *testing.T) {\n\t\t\tpath, err := json.CreatePath(\"$.a.c\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v bool\n\t\t\tif err := path.Unmarshal(src, &v); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !v {\n\t\t\t\tt.Fatal(\"failed to unmarshal path\")\n\t\t\t}\n\t\t})\n\t\tt.Run(\"failure\", func(t *testing.T) {\n\t\t\tpath, err := json.CreatePath(\"$.a.b\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v bool\n\t\t\tif err := path.Unmarshal(src, &v); err == nil {\n\t\t\t\tt.Fatal(\"expected error\")\n\t\t\t}\n\t\t})\n\t})\n\tt.Run(\"map\", func(t *testing.T) {\n\t\tsrc := []byte(`{\"a\":{\"b\":10,\"c\":true},\"b\":\"text\"}`)\n\t\tt.Run(\"success\", func(t *testing.T) {\n\t\t\tpath, err := json.CreatePath(\"$.a\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar v map[string]interface{}\n\t\t\tif err := path.Unmarshal(src, &v); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(v) != 2 {\n\t\t\t\tt.Fatal(\"failed to decode map\")\n\t\t\t}\n\t\t})\n\t})\n\n\tt.Run(\"path with single quote selector\", func(t *testing.T) {\n\t\tpath, err := json.CreatePath(\"$['a.b'].c\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar v string\n\t\tif err := path.Unmarshal([]byte(`{\"a.b\": {\"c\": \"world\"}}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v != \"world\" {\n\t\t\tt.Fatal(\"failed to unmarshal path\")\n\t\t}\n\t})\n\tt.Run(\"path with double quote selector\", func(t *testing.T) {\n\t\tpath, err := json.CreatePath(`$.\"a.b\".c`)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar v string\n\t\tif err := path.Unmarshal([]byte(`{\"a.b\": {\"c\": \"world\"}}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v != \"world\" {\n\t\t\tt.Fatal(\"failed to unmarshal path\")\n\t\t}\n\t})\n}\n\nfunc TestGetPath(t *testing.T) {\n\tt.Run(\"selector\", func(t *testing.T) {\n\t\tvar v interface{}\n\t\tif err := json.Unmarshal([]byte(`{\"a\":{\"b\":10,\"c\":true},\"b\":\"text\"}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tpath, err := json.CreatePath(\"$.a.b\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar b int\n\t\tif err := path.Get(v, &b); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif b != 10 {\n\t\t\tt.Fatalf(\"failed to decode by json.Get\")\n\t\t}\n\t})\n\tt.Run(\"index\", func(t *testing.T) {\n\t\tvar v interface{}\n\t\tif err := json.Unmarshal([]byte(`{\"a\":[{\"b\":10,\"c\":true},{\"b\":\"text\"}]}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tpath, err := json.CreatePath(\"$.a[0].b\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar b int\n\t\tif err := path.Get(v, &b); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif b != 10 {\n\t\t\tt.Fatalf(\"failed to decode by json.Get\")\n\t\t}\n\t})\n\tt.Run(\"indexAll\", func(t *testing.T) {\n\t\tvar v interface{}\n\t\tif err := json.Unmarshal([]byte(`{\"a\":[{\"b\":1,\"c\":true},{\"b\":2},{\"b\":3}]}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tpath, err := json.CreatePath(\"$.a[*].b\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar b []int\n\t\tif err := path.Get(v, &b); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !reflect.DeepEqual(b, []int{1, 2, 3}) {\n\t\t\tt.Fatalf(\"failed to decode by json.Get\")\n\t\t}\n\t})\n\tt.Run(\"recursive\", func(t *testing.T) {\n\t\tvar v interface{}\n\t\tif err := json.Unmarshal([]byte(`{\"a\":[{\"b\":1,\"c\":true},{\"b\":2},{\"b\":3}],\"a2\":{\"b\":4}}`), &v); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tpath, err := json.CreatePath(\"$..b\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tvar b []int\n\t\tif err := path.Get(v, &b); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tsort.Ints(b)\n\t\tif !reflect.DeepEqual(b, []int{1, 2, 3, 4}) {\n\t\t\tt.Fatalf(\"failed to decode by json.Get\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 1.59375,
          "content": "package json\n\nimport (\n\t\"github.com/goccy/go-json/internal/encoder\"\n)\n\ntype (\n\t// FieldQuery you can dynamically filter the fields in the structure by creating a FieldQuery,\n\t// adding it to context.Context using SetFieldQueryToContext and then passing it to MarshalContext.\n\t// This is a type-safe operation, so it is faster than filtering using map[string]interface{}.\n\tFieldQuery       = encoder.FieldQuery\n\tFieldQueryString = encoder.FieldQueryString\n)\n\nvar (\n\t// FieldQueryFromContext get current FieldQuery from context.Context.\n\tFieldQueryFromContext = encoder.FieldQueryFromContext\n\t// SetFieldQueryToContext set current FieldQuery to context.Context.\n\tSetFieldQueryToContext = encoder.SetFieldQueryToContext\n)\n\n// BuildFieldQuery builds FieldQuery by fieldName or sub field query.\n// First, specify the field name that you want to keep in structure type.\n// If the field you want to keep is a structure type, by creating a sub field query using BuildSubFieldQuery,\n// you can select the fields you want to keep in the structure.\n// This description can be written recursively.\nfunc BuildFieldQuery(fields ...FieldQueryString) (*FieldQuery, error) {\n\tquery, err := Marshal(fields)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn FieldQueryString(query).Build()\n}\n\n// BuildSubFieldQuery builds sub field query.\nfunc BuildSubFieldQuery(name string) *SubFieldQuery {\n\treturn &SubFieldQuery{name: name}\n}\n\ntype SubFieldQuery struct {\n\tname string\n}\n\nfunc (q *SubFieldQuery) Fields(fields ...FieldQueryString) FieldQueryString {\n\tquery, _ := Marshal(map[string][]FieldQueryString{q.name: fields})\n\treturn FieldQueryString(query)\n}\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 1.8974609375,
          "content": "package json_test\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\ntype queryTestX struct {\n\tXA int\n\tXB string\n\tXC *queryTestY\n\tXD bool\n\tXE float32\n}\n\ntype queryTestY struct {\n\tYA int\n\tYB string\n\tYC *queryTestZ\n\tYD bool\n\tYE float32\n}\n\ntype queryTestZ struct {\n\tZA string\n\tZB bool\n\tZC int\n}\n\nfunc (z *queryTestZ) MarshalJSON(ctx context.Context) ([]byte, error) {\n\ttype _queryTestZ queryTestZ\n\treturn json.MarshalContext(ctx, (*_queryTestZ)(z))\n}\n\nfunc TestFieldQuery(t *testing.T) {\n\tquery, err := json.BuildFieldQuery(\n\t\t\"XA\",\n\t\t\"XB\",\n\t\tjson.BuildSubFieldQuery(\"XC\").Fields(\n\t\t\t\"YA\",\n\t\t\t\"YB\",\n\t\t\tjson.BuildSubFieldQuery(\"YC\").Fields(\n\t\t\t\t\"ZA\",\n\t\t\t\t\"ZB\",\n\t\t\t),\n\t\t),\n\t)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !reflect.DeepEqual(query, &json.FieldQuery{\n\t\tFields: []*json.FieldQuery{\n\t\t\t{\n\t\t\t\tName: \"XA\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"XB\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"XC\",\n\t\t\t\tFields: []*json.FieldQuery{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"YA\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"YB\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"YC\",\n\t\t\t\t\t\tFields: []*json.FieldQuery{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: \"ZA\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: \"ZB\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}) {\n\t\tt.Fatal(\"cannot get query\")\n\t}\n\tqueryStr, err := query.QueryString()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif queryStr != `[\"XA\",\"XB\",{\"XC\":[\"YA\",\"YB\",{\"YC\":[\"ZA\",\"ZB\"]}]}]` {\n\t\tt.Fatalf(\"failed to create query string. %s\", queryStr)\n\t}\n\tctx := json.SetFieldQueryToContext(context.Background(), query)\n\tb, err := json.MarshalContext(ctx, &queryTestX{\n\t\tXA: 1,\n\t\tXB: \"xb\",\n\t\tXC: &queryTestY{\n\t\t\tYA: 2,\n\t\t\tYB: \"yb\",\n\t\t\tYC: &queryTestZ{\n\t\t\t\tZA: \"za\",\n\t\t\t\tZB: true,\n\t\t\t\tZC: 3,\n\t\t\t},\n\t\t\tYD: true,\n\t\t\tYE: 4,\n\t\t},\n\t\tXD: true,\n\t\tXE: 5,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\texpected := `{\"XA\":1,\"XB\":\"xb\",\"XC\":{\"YA\":2,\"YB\":\"yb\",\"YC\":{\"ZA\":\"za\",\"ZB\":true}}}`\n\tgot := string(b)\n\tif expected != got {\n\t\tt.Fatalf(\"failed to encode with field query: expected %q but got %q\", expected, got)\n\t}\n}\n"
        },
        {
          "name": "size_test.go",
          "type": "blob",
          "size": 0.3388671875,
          "content": "package json\n\nimport (\n\t\"testing\"\n\t\"unsafe\"\n\n\t\"github.com/goccy/go-json/internal/encoder\"\n)\n\nfunc TestOpcodeSize(t *testing.T) {\n\tconst uintptrSize = 4 << (^uintptr(0) >> 63)\n\tif uintptrSize == 8 {\n\t\tsize := unsafe.Sizeof(encoder.Opcode{})\n\t\tif size != 120 {\n\t\t\tt.Fatalf(\"unexpected opcode size: expected 112bytes but got %dbytes\", size)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "stream_test.go",
          "type": "blob",
          "size": 14.0693359375,
          "content": "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage json_test\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\n// Test values for the stream test.\n// One of each JSON kind.\nvar streamTest = []interface{}{\n\t0.1,\n\t\"hello\",\n\tnil,\n\ttrue,\n\tfalse,\n\t[]interface{}{\"a\", \"b\", \"c\"},\n\tmap[string]interface{}{\"K\": \"Kelvin\", \"ß\": \"long s\"},\n\t3.14, // another value to make sure something can follow map\n}\n\nvar streamEncoded = `0.1\n\"hello\"\nnull\ntrue\nfalse\n[\"a\",\"b\",\"c\"]\n{\"ß\":\"long s\",\"K\":\"Kelvin\"}\n3.14\n`\n\nfunc TestStreamEncoder(t *testing.T) {\n\tfor i := 0; i <= len(streamTest); i++ {\n\t\tvar buf bytes.Buffer\n\t\tenc := json.NewEncoder(&buf)\n\t\t// Check that enc.SetIndent(\"\", \"\") turns off indentation.\n\t\tenc.SetIndent(\">\", \".\")\n\t\tenc.SetIndent(\"\", \"\")\n\t\tfor j, v := range streamTest[0:i] {\n\t\t\tif err := enc.Encode(v); err != nil {\n\t\t\t\tt.Fatalf(\"encode #%d: %v\", j, err)\n\t\t\t}\n\t\t}\n\t\tif have, want := buf.String(), nlines(streamEncoded, i); have != want {\n\t\t\tt.Errorf(\"encoding %d items: mismatch\", i)\n\t\t\tdiff(t, []byte(have), []byte(want))\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nvar streamEncodedIndent = `0.1\n\"hello\"\nnull\ntrue\nfalse\n[\n>.\"a\",\n>.\"b\",\n>.\"c\"\n>]\n{\n>.\"ß\": \"long s\",\n>.\"K\": \"Kelvin\"\n>}\n3.14\n`\n\nfunc TestEncoderIndent(t *testing.T) {\n\tvar buf bytes.Buffer\n\tenc := json.NewEncoder(&buf)\n\tenc.SetIndent(\">\", \".\")\n\tfor _, v := range streamTest {\n\t\tenc.Encode(v)\n\t}\n\tif have, want := buf.String(), streamEncodedIndent; have != want {\n\t\tt.Error(\"indented encoding mismatch\")\n\t\tdiff(t, []byte(have), []byte(want))\n\t}\n}\n\ntype strMarshaler string\n\nfunc (s strMarshaler) MarshalJSON() ([]byte, error) {\n\treturn []byte(s), nil\n}\n\ntype strPtrMarshaler string\n\nfunc (s *strPtrMarshaler) MarshalJSON() ([]byte, error) {\n\treturn []byte(*s), nil\n}\n\nfunc TestEncoderSetEscapeHTML(t *testing.T) {\n\tvar c C\n\tvar ct CText\n\tvar tagStruct struct {\n\t\tValid   int `json:\"<>&#! \"`\n\t\tInvalid int `json:\"\\\\\"`\n\t}\n\n\t// This case is particularly interesting, as we force the encoder to\n\t// take the address of the Ptr field to use its MarshalJSON method. This\n\t// is why the '&' is important.\n\tmarshalerStruct := &struct {\n\t\tNonPtr strMarshaler\n\t\tPtr    strPtrMarshaler\n\t}{`\"<str>\"`, `\"<str>\"`}\n\n\t// https://golang.org/issue/34154\n\tstringOption := struct {\n\t\tBar string `json:\"bar,string\"`\n\t}{`<html>foobar</html>`}\n\n\tfor _, tt := range []struct {\n\t\tname       string\n\t\tv          interface{}\n\t\twantEscape string\n\t\twant       string\n\t}{\n\t\t{\"c\", c, `\"\\u003c\\u0026\\u003e\"`, `\"<&>\"`},\n\t\t{\"ct\", ct, `\"\\\"\\u003c\\u0026\\u003e\\\"\"`, `\"\\\"<&>\\\"\"`},\n\t\t{`\"<&>\"`, \"<&>\", `\"\\u003c\\u0026\\u003e\"`, `\"<&>\"`},\n\t\t{\n\t\t\t\"tagStruct\", tagStruct,\n\t\t\t`{\"\\u003c\\u003e\\u0026#! \":0,\"Invalid\":0}`,\n\t\t\t`{\"<>&#! \":0,\"Invalid\":0}`,\n\t\t},\n\t\t{\n\t\t\t`\"<str>\"`, marshalerStruct,\n\t\t\t`{\"NonPtr\":\"\\u003cstr\\u003e\",\"Ptr\":\"\\u003cstr\\u003e\"}`,\n\t\t\t`{\"NonPtr\":\"<str>\",\"Ptr\":\"<str>\"}`,\n\t\t},\n\t\t{\n\t\t\t\"stringOption\", stringOption,\n\t\t\t`{\"bar\":\"\\\"\\\\u003chtml\\\\u003efoobar\\\\u003c/html\\\\u003e\\\"\"}`,\n\t\t\t`{\"bar\":\"\\\"<html>foobar</html>\\\"\"}`,\n\t\t},\n\t} {\n\t\tvar buf bytes.Buffer\n\t\tenc := json.NewEncoder(&buf)\n\t\tif err := enc.Encode(tt.v); err != nil {\n\t\t\tt.Errorf(\"Encode(%s): %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tif got := strings.TrimSpace(buf.String()); got != tt.wantEscape {\n\t\t\tt.Errorf(\"Encode(%s) = %#q, want %#q\", tt.name, got, tt.wantEscape)\n\t\t}\n\t\tbuf.Reset()\n\t\tenc.SetEscapeHTML(false)\n\t\tif err := enc.Encode(tt.v); err != nil {\n\t\t\tt.Errorf(\"SetEscapeHTML(false) Encode(%s): %s\", tt.name, err)\n\t\t\tcontinue\n\t\t}\n\t\tif got := strings.TrimSpace(buf.String()); got != tt.want {\n\t\t\tt.Errorf(\"SetEscapeHTML(false) Encode(%s) = %#q, want %#q\",\n\t\t\t\ttt.name, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc nlines(s string, n int) string {\n\tif n <= 0 {\n\t\treturn \"\"\n\t}\n\tfor i, c := range s {\n\t\tif c == '\\n' {\n\t\t\tif n--; n == 0 {\n\t\t\t\treturn s[0 : i+1]\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\nfunc TestDecoder(t *testing.T) {\n\tfor i := 0; i <= len(streamTest); i++ {\n\t\t// Use stream without newlines as input,\n\t\t// just to stress the decoder even more.\n\t\t// Our test input does not include back-to-back numbers.\n\t\t// Otherwise stripping the newlines would\n\t\t// merge two adjacent JSON values.\n\t\tvar buf bytes.Buffer\n\t\tfor _, c := range nlines(streamEncoded, i) {\n\t\t\tif c != '\\n' {\n\t\t\t\tbuf.WriteRune(c)\n\t\t\t}\n\t\t}\n\t\tout := make([]interface{}, i)\n\t\tdec := json.NewDecoder(&buf)\n\t\tfor j := range out {\n\t\t\tif err := dec.Decode(&out[j]); err != nil {\n\t\t\t\tt.Fatalf(\"decode #%d/%d: %v\", j, i, err)\n\t\t\t}\n\t\t}\n\t\tif !reflect.DeepEqual(out, streamTest[0:i]) {\n\t\t\tt.Errorf(\"decoding %d items: mismatch\", i)\n\t\t\tfor j := range out {\n\t\t\t\tif !reflect.DeepEqual(out[j], streamTest[j]) {\n\t\t\t\t\tt.Errorf(\"#%d: have %v want %v\", j, out[j], streamTest[j])\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc TestDecoderBuffered(t *testing.T) {\n\tr := strings.NewReader(`{\"Name\": \"Gopher\"} extra `)\n\tvar m struct {\n\t\tName string\n\t}\n\td := json.NewDecoder(r)\n\terr := d.Decode(&m)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif m.Name != \"Gopher\" {\n\t\tt.Errorf(\"Name = %q; want Gopher\", m.Name)\n\t}\n\trest, err := io.ReadAll(d.Buffered())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif g, w := string(rest), \" extra \"; g != w {\n\t\tt.Errorf(\"Remaining = %q; want %q\", g, w)\n\t}\n}\n\nfunc TestRawMessage(t *testing.T) {\n\tvar data struct {\n\t\tX  float64\n\t\tId json.RawMessage\n\t\tY  float32\n\t}\n\tconst raw = `[\"\\u0056\",null]`\n\tconst msg = `{\"X\":0.1,\"Id\":[\"\\u0056\",null],\"Y\":0.2}`\n\terr := json.Unmarshal([]byte(msg), &data)\n\tif err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif string([]byte(data.Id)) != raw {\n\t\tt.Fatalf(\"Raw mismatch: have %#q want %#q\", []byte(data.Id), raw)\n\t}\n\tb, err := json.Marshal(&data)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\tif string(b) != msg {\n\t\tt.Fatalf(\"Marshal: have %#q want %#q\", b, msg)\n\t}\n}\n\nfunc TestNullRawMessage(t *testing.T) {\n\tvar data struct {\n\t\tX     float64\n\t\tId    json.RawMessage\n\t\tIdPtr *json.RawMessage\n\t\tY     float32\n\t}\n\tconst msg = `{\"X\":0.1,\"Id\":null,\"IdPtr\":null,\"Y\":0.2}`\n\terr := json.Unmarshal([]byte(msg), &data)\n\tif err != nil {\n\t\tt.Fatalf(\"Unmarshal: %v\", err)\n\t}\n\tif want, got := \"null\", string(data.Id); want != got {\n\t\tt.Fatalf(\"Raw mismatch: have %q, want %q\", got, want)\n\t}\n\tif data.IdPtr != nil {\n\t\tt.Fatalf(\"Raw pointer mismatch: have non-nil, want nil\")\n\t}\n\tb, err := json.Marshal(&data)\n\tif err != nil {\n\t\tt.Fatalf(\"Marshal: %v\", err)\n\t}\n\tif string(b) != msg {\n\t\tt.Fatalf(\"Marshal: have %#q want %#q\", b, msg)\n\t}\n}\n\nvar blockingTests = []string{\n\t`{\"x\": 1}`,\n\t`[1, 2, 3]`,\n}\n\nfunc TestBlocking(t *testing.T) {\n\tfor _, enc := range blockingTests {\n\t\tr, w := net.Pipe()\n\t\tgo w.Write([]byte(enc))\n\t\tvar val interface{}\n\n\t\t// If Decode reads beyond what w.Write writes above,\n\t\t// it will block, and the test will deadlock.\n\t\tif err := json.NewDecoder(r).Decode(&val); err != nil {\n\t\t\tt.Errorf(\"decoding %s: %v\", enc, err)\n\t\t}\n\t\tr.Close()\n\t\tw.Close()\n\t}\n}\n\ntype tokenStreamCase struct {\n\tjson      string\n\texpTokens []interface{}\n}\n\ntype decodeThis struct {\n\tv interface{}\n}\n\nvar tokenStreamCases = []tokenStreamCase{\n\t// streaming token cases\n\t{json: `10`, expTokens: []interface{}{float64(10)}},\n\t{json: ` [10] `, expTokens: []interface{}{\n\t\tjson.Delim('['), float64(10), json.Delim(']')}},\n\t{json: ` [false,10,\"b\"] `, expTokens: []interface{}{\n\t\tjson.Delim('['), false, float64(10), \"b\", json.Delim(']')}},\n\t{json: `{ \"a\": 1 }`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"a\", float64(1), json.Delim('}')}},\n\t{json: `{\"a\": 1, \"b\":\"3\"}`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"a\", float64(1), \"b\", \"3\", json.Delim('}')}},\n\t{json: ` [{\"a\": 1},{\"a\": 2}] `, expTokens: []interface{}{\n\t\tjson.Delim('['),\n\t\tjson.Delim('{'), \"a\", float64(1), json.Delim('}'),\n\t\tjson.Delim('{'), \"a\", float64(2), json.Delim('}'),\n\t\tjson.Delim(']')}},\n\t{json: `{\"obj\": {\"a\": 1}}`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"obj\", json.Delim('{'), \"a\", float64(1), json.Delim('}'),\n\t\tjson.Delim('}')}},\n\t{json: `{\"obj\": [{\"a\": 1}]}`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"obj\", json.Delim('['),\n\t\tjson.Delim('{'), \"a\", float64(1), json.Delim('}'),\n\t\tjson.Delim(']'), json.Delim('}')}},\n\n\t// streaming tokens with intermittent Decode()\n\t{json: `{ \"a\": 1 }`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"a\",\n\t\tdecodeThis{float64(1)},\n\t\tjson.Delim('}')}},\n\t{json: ` [ { \"a\" : 1 } ] `, expTokens: []interface{}{\n\t\tjson.Delim('['),\n\t\tdecodeThis{map[string]interface{}{\"a\": float64(1)}},\n\t\tjson.Delim(']')}},\n\t{json: ` [{\"a\": 1},{\"a\": 2}] `, expTokens: []interface{}{\n\t\tjson.Delim('['),\n\t\tdecodeThis{map[string]interface{}{\"a\": float64(1)}},\n\t\tdecodeThis{map[string]interface{}{\"a\": float64(2)}},\n\t\tjson.Delim(']')}},\n\t{json: `{ \"obj\" : [ { \"a\" : 1 } ] }`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"obj\", json.Delim('['),\n\t\tdecodeThis{map[string]interface{}{\"a\": float64(1)}},\n\t\tjson.Delim(']'), json.Delim('}')}},\n\n\t{json: `{\"obj\": {\"a\": 1}}`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"obj\",\n\t\tdecodeThis{map[string]interface{}{\"a\": float64(1)}},\n\t\tjson.Delim('}')}},\n\t{json: `{\"obj\": [{\"a\": 1}]}`, expTokens: []interface{}{\n\t\tjson.Delim('{'), \"obj\",\n\t\tdecodeThis{[]interface{}{\n\t\t\tmap[string]interface{}{\"a\": float64(1)},\n\t\t}},\n\t\tjson.Delim('}')}},\n\t/*\n\t\t{json: ` [{\"a\": 1} {\"a\": 2}] `, expTokens: []interface{}{\n\t\t\tjson.Delim('['),\n\t\t\tdecodeThis{map[string]interface{}{\"a\": float64(1)}},\n\t\t\tdecodeThis{json.NewSyntaxError(\"expected comma after array element\", 11)},\n\t\t}},\n\t\t{json: `{ \"` + strings.Repeat(\"a\", 513) + `\" 1 }`, expTokens: []interface{}{\n\t\t\tjson.Delim('{'), strings.Repeat(\"a\", 513),\n\t\t\tdecodeThis{json.NewSyntaxError(\"expected colon after object key\", 518)},\n\t\t}},\n\t\t{json: `{ \"\\a\" }`, expTokens: []interface{}{\n\t\t\tjson.Delim('{'),\n\t\t\tjson.NewSyntaxError(\"invalid character 'a' in string escape code\", 3),\n\t\t}},\n\t\t{json: ` \\a`, expTokens: []interface{}{\n\t\t\tjson.NewSyntaxError(\"invalid character '\\\\\\\\' looking for beginning of value\", 1),\n\t\t}},\n\t*/\n}\n\nfunc TestDecodeInStream(t *testing.T) {\n\tfor ci, tcase := range tokenStreamCases {\n\n\t\tdec := json.NewDecoder(strings.NewReader(tcase.json))\n\t\tfor i, etk := range tcase.expTokens {\n\n\t\t\tvar tk interface{}\n\t\t\tvar err error\n\n\t\t\tif dt, ok := etk.(decodeThis); ok {\n\t\t\t\tetk = dt.v\n\t\t\t\terr = dec.Decode(&tk)\n\t\t\t} else {\n\t\t\t\ttk, err = dec.Token()\n\t\t\t}\n\t\t\tif experr, ok := etk.(error); ok {\n\t\t\t\tif err == nil || !reflect.DeepEqual(err, experr) {\n\t\t\t\t\tt.Errorf(\"case %v: Expected error %#v in %q, but was %#v\", ci, experr, tcase.json, err)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t} else if err == io.EOF {\n\t\t\t\tt.Errorf(\"case %v: Unexpected EOF in %q\", ci, tcase.json)\n\t\t\t\tbreak\n\t\t\t} else if err != nil {\n\t\t\t\tt.Errorf(\"case %v: Unexpected error '%#v' in %q\", ci, err, tcase.json)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tk, etk) {\n\t\t\t\tt.Errorf(`case %v: %q @ %v expected %T(%v) was %T(%v)`, ci, tcase.json, i, etk, etk, tk, tk)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDecodeStreamUseNumber(t *testing.T) {\n\tdec := json.NewDecoder(strings.NewReader(`3.14`))\n\tdec.UseNumber()\n\tv, err := dec.Token()\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %#v\", err)\n\t}\n\tassertEq(t, \"json.Number\", \"json.Number\", fmt.Sprintf(\"%T\", v))\n}\n\n// Test from golang.org/issue/11893\nfunc TestHTTPDecoding(t *testing.T) {\n\tconst raw = `{ \"foo\": \"bar\" }`\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(raw))\n\t}))\n\tdefer ts.Close()\n\tres, err := http.Get(ts.URL)\n\tif err != nil {\n\t\tlog.Fatalf(\"GET failed: %v\", err)\n\t}\n\tdefer res.Body.Close()\n\n\tfoo := struct {\n\t\tFoo string\n\t}{}\n\n\td := json.NewDecoder(res.Body)\n\terr = d.Decode(&foo)\n\tif err != nil {\n\t\tt.Fatalf(\"Decode: %v\", err)\n\t}\n\tif foo.Foo != \"bar\" {\n\t\tt.Errorf(\"decoded %q; want \\\"bar\\\"\", foo.Foo)\n\t}\n\n\t// make sure we get the EOF the second time\n\terr = d.Decode(&foo)\n\tif err != io.EOF {\n\t\tt.Errorf(\"err = %v; want io.EOF\", err)\n\t}\n}\n\nfunc TestGzipStreaming(t *testing.T) {\n\ttype someStruct struct {\n\t\tID   int      `json:\"id\"`\n\t\tText []string `json:\"text\"`\n\t}\n\n\tmanyItems := strings.Repeat(`\"Quis autem vel eum iure reprehenderit, qui in ea voluptate velit esse, quam`+\n\t\t` nihil molestiae consequatur, vel illum, qui dolorem eum fugiat, quo voluptas nulla pariatur?\",`, 400)\n\n\tlongJSON := `{\"id\":123,\"text\":[` + manyItems[0:len(manyItems)-1] + `]}`\n\n\tcompressed := bytes.NewBuffer(nil)\n\tgw := gzip.NewWriter(compressed)\n\n\t_, err := io.Copy(gw, bytes.NewReader([]byte(longJSON)))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\terr = gw.Close()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tgr, err := gzip.NewReader(bytes.NewReader(compressed.Bytes()))\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\n\tvar v someStruct\n\tdec := json.NewDecoder(gr)\n\n\terr = dec.Decode(&v)\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n}\n\nfunc TestLongUTF8(t *testing.T) {\n\twant := strings.Repeat(\"あ\", 342)\n\tr := strings.NewReader(strconv.Quote(want))\n\n\tvar got string\n\tif err := json.NewDecoder(r).Decode(&got); err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\tif got != want {\n\t\tt.Errorf(\"string %q; want = %q\", got, want)\n\t}\n}\n\nfunc TestIssue278(t *testing.T) {\n\ta := `{\"嗷嗷\":\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\u55f7\"}`\n\tr := strings.NewReader(a)\n\tvar m map[string]string\n\tif err := json.NewDecoder(r).Decode(&m); err != nil {\n\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t}\n\twant := \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\u55f7\"\n\tif got := m[\"嗷嗷\"]; got != want {\n\t\tt.Errorf(\"string %q; want = %q\", got, want)\n\t}\n}\n"
        },
        {
          "name": "tagkey_test.go",
          "type": "blob",
          "size": 2.7119140625,
          "content": "// Copyright 2011 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage json_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/goccy/go-json\"\n)\n\ntype basicLatin2xTag struct {\n\tV string `json:\"$%-/\"`\n}\n\ntype basicLatin3xTag struct {\n\tV string `json:\"0123456789\"`\n}\n\ntype basicLatin4xTag struct {\n\tV string `json:\"ABCDEFGHIJKLMO\"`\n}\n\ntype basicLatin5xTag struct {\n\tV string `json:\"PQRSTUVWXYZ_\"`\n}\n\ntype basicLatin6xTag struct {\n\tV string `json:\"abcdefghijklmno\"`\n}\n\ntype basicLatin7xTag struct {\n\tV string `json:\"pqrstuvwxyz\"`\n}\n\ntype miscPlaneTag struct {\n\tV string `json:\"色は匂へど\"`\n}\n\ntype percentSlashTag struct {\n\tV string `json:\"text/html%\"` // https://golang.org/issue/2718\n}\n\ntype punctuationTag struct {\n\tV string `json:\"!#$%&()*+-./:<=>?@[]^_{|}~\"` // https://golang.org/issue/3546\n}\n\ntype dashTag struct {\n\tV string `json:\"-,\"`\n}\n\ntype emptyTag struct {\n\tW string\n}\n\ntype misnamedTag struct {\n\tX string `jsom:\"Misnamed\"`\n}\n\ntype badFormatTag struct {\n\tY string `:\"BadFormat\"`\n}\n\ntype badCodeTag struct {\n\tZ string `json:\" !\\\"#&'()*+,.\"`\n}\n\ntype spaceTag struct {\n\tQ string `json:\"With space\"`\n}\n\ntype unicodeTag struct {\n\tW string `json:\"Ελλάδα\"`\n}\n\nvar structTagObjectKeyTests = []struct {\n\traw   interface{}\n\tvalue string\n\tkey   string\n}{\n\t{basicLatin2xTag{\"2x\"}, \"2x\", \"$%-/\"},\n\t{basicLatin3xTag{\"3x\"}, \"3x\", \"0123456789\"},\n\t{basicLatin4xTag{\"4x\"}, \"4x\", \"ABCDEFGHIJKLMO\"},\n\t{basicLatin5xTag{\"5x\"}, \"5x\", \"PQRSTUVWXYZ_\"},\n\t{basicLatin6xTag{\"6x\"}, \"6x\", \"abcdefghijklmno\"},\n\t{basicLatin7xTag{\"7x\"}, \"7x\", \"pqrstuvwxyz\"},\n\t{miscPlaneTag{\"いろはにほへと\"}, \"いろはにほへと\", \"色は匂へど\"},\n\t{dashTag{\"foo\"}, \"foo\", \"-\"},\n\t{emptyTag{\"Pour Moi\"}, \"Pour Moi\", \"W\"},\n\t{misnamedTag{\"Animal Kingdom\"}, \"Animal Kingdom\", \"X\"},\n\t{badFormatTag{\"Orfevre\"}, \"Orfevre\", \"Y\"},\n\t{badCodeTag{\"Reliable Man\"}, \"Reliable Man\", \"Z\"},\n\t{percentSlashTag{\"brut\"}, \"brut\", \"text/html%\"},\n\t{punctuationTag{\"Union Rags\"}, \"Union Rags\", \"!#$%&()*+-./:<=>?@[]^_{|}~\"},\n\t{spaceTag{\"Perreddu\"}, \"Perreddu\", \"With space\"},\n\t{unicodeTag{\"Loukanikos\"}, \"Loukanikos\", \"Ελλάδα\"},\n}\n\nfunc TestStructTagObjectKey(t *testing.T) {\n\tfor _, tt := range structTagObjectKeyTests {\n\t\tb, err := json.Marshal(tt.raw)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Marshal(%#q) failed: %v\", tt.raw, err)\n\t\t}\n\t\tvar f interface{}\n\t\terr = json.Unmarshal(b, &f)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unmarshal(%#q) failed: %v\", b, err)\n\t\t}\n\t\tfor i, v := range f.(map[string]interface{}) {\n\t\t\tswitch i {\n\t\t\tcase tt.key:\n\t\t\t\tif s, ok := v.(string); !ok || s != tt.value {\n\t\t\t\t\tt.Fatalf(\"Unexpected value: %#q, want %v\", s, tt.value)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected key: %#q, from %#q\", i, b)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}