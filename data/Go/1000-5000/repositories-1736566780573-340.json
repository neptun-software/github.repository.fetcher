{
  "metadata": {
    "timestamp": 1736566780573,
    "page": 340,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "golang/glog",
      "stars": 3558,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.0322265625,
          "content": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \"control\" means (i) the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\"submitted\" means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n2. Grant of Copyright License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.\n\n3. Grant of Patent License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.\n\n4. Redistribution.\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:\n\nYou must give any other recipients of the Work or Derivative Works a copy of\nthis License; and\nYou must cause any modified files to carry prominent notices stating that You\nchanged the files; and\nYou must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and\nIf the Work includes a \"NOTICE\" text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.\n\n5. Submission of Contributions.\n\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n6. Trademarks.\n\nThis License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty.\n\nUnless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.\n\n8. Limitation of Liability.\n\nIn no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability.\n\nWhile redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work\n\nTo apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets \"[]\" replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \"printed page\" as the copyright notice for easier identification within\nthird-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.4501953125,
          "content": "# glog\n\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/golang/glog)](https://pkg.go.dev/github.com/golang/glog)\n\nLeveled execution logs for Go.\n\nThis is an efficient pure Go implementation of leveled logs in the\nmanner of the open source C++ package [_glog_](https://github.com/google/glog).\n\nBy binding methods to booleans it is possible to use the log package without paying the expense of evaluating the arguments to the log. Through the `-vmodule` flag, the package also provides fine-grained\ncontrol over logging at the file level.\n\nThe comment from `glog.go` introduces the ideas:\n\nPackage _glog_ implements logging analogous to the Google-internal C++ INFO/ERROR/V setup.  It provides the functions Info, Warning, Error, Fatal, plus formatting variants such as Infof. It also provides V-style loggingcontrolled by the `-v` and `-vmodule=file=2` flags.\n\t\nBasic examples:\n\n```go\nglog.Info(\"Prepare to repel boarders\")\n\t\nglog.Fatalf(\"Initialization failed: %s\", err)\n```\n\t\nSee the documentation for the V function for an explanation of these examples:\n\n```go\nif glog.V(2) {\n\tglog.Info(\"Starting transaction...\")\n}\nglog.V(2).Infoln(\"Processed\", nItems, \"elements\")\n```\n\nThe repository contains an open source version of the log package used inside Google. The master copy of the source lives inside Google, not here. The code in this repo is for export only and is not itself under development. Feature requests will be ignored.\n\nSend bug reports to golang-nuts@googlegroups.com.\n"
        },
        {
          "name": "glog.go",
          "type": "blob",
          "size": 27.427734375,
          "content": "// Go support for leveled logs, analogous to https://github.com/google/glog.\n//\n// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package glog implements logging analogous to the Google-internal C++ INFO/ERROR/V setup.\n// It provides functions that have a name matched by regex:\n//\n//\t(Info|Warning|Error|Fatal)(Context)?(Depth)?(f)?\n//\n// If Context is present, function takes context.Context argument. The\n// context is used to pass through the Trace Context to log sinks that can make use\n// of it.\n// It is recommended to use the context variant of the functions over the non-context\n// variants if a context is available to make sure the Trace Contexts are present\n// in logs.\n//\n// If Depth is present, this function calls log from a different depth in the call stack.\n// This enables a callee to emit logs that use the callsite information of its caller\n// or any other callers in the stack. When depth == 0, the original callee's line\n// information is emitted. When depth > 0, depth frames are skipped in the call stack\n// and the final frame is treated like the original callee to Info.\n//\n// If 'f' is present, function formats according to a format specifier.\n//\n// This package also provides V-style logging controlled by the -v and -vmodule=file=2 flags.\n//\n// Basic examples:\n//\n//\tglog.Info(\"Prepare to repel boarders\")\n//\n//\tglog.Fatalf(\"Initialization failed: %s\", err)\n//\n// See the documentation for the V function for an explanation of these examples:\n//\n//\tif glog.V(2) {\n//\t\tglog.Info(\"Starting transaction...\")\n//\t}\n//\n//\tglog.V(2).Infoln(\"Processed\", nItems, \"elements\")\n//\n// Log output is buffered and written periodically using Flush. Programs\n// should call Flush before exiting to guarantee all log output is written.\n//\n// By default, all log statements write to files in a temporary directory.\n// This package provides several flags that modify this behavior.\n// As a result, flag.Parse must be called before any logging is done.\n//\n//\t-logtostderr=false\n//\t\tLogs are written to standard error instead of to files.\n//\t-alsologtostderr=false\n//\t\tLogs are written to standard error as well as to files.\n//\t-stderrthreshold=ERROR\n//\t\tLog events at or above this severity are logged to standard\n//\t\terror as well as to files.\n//\t-log_dir=\"\"\n//\t\tLog files will be written to this directory instead of the\n//\t\tdefault temporary directory.\n//\n// Other flags provide aids to debugging.\n//\n//\t-log_backtrace_at=\"\"\n//\t\tA comma-separated list of file and line numbers holding a logging\n//\t\tstatement, such as\n//\t\t\t-log_backtrace_at=gopherflakes.go:234\n//\t\tA stack trace will be written to the Info log whenever execution\n//\t\thits one of these statements. (Unlike with -vmodule, the \".go\"\n//\t\tmust be present.)\n//\t-v=0\n//\t\tEnable V-leveled logging at the specified level.\n//\t-vmodule=\"\"\n//\t\tThe syntax of the argument is a comma-separated list of pattern=N,\n//\t\twhere pattern is a literal file name (minus the \".go\" suffix) or\n//\t\t\"glob\" pattern and N is a V level. For instance,\n//\t\t\t-vmodule=gopher*=3\n//\t\tsets the V level to 3 in all Go files whose names begin with \"gopher\",\n//\t\tand\n//\t\t\t-vmodule=/path/to/glog/glog_test=1\n//\t\tsets the V level to 1 in the Go file /path/to/glog/glog_test.go.\n//\t\tIf a glob pattern contains a slash, it is matched against the full path,\n//\t\tand the file name. Otherwise, the pattern is\n//\t\tmatched only against the file's basename.  When both -vmodule and -v\n//\t\tare specified, the -vmodule values take precedence for the specified\n//\t\tmodules.\npackage glog\n\n// This file contains the parts of the log package that are shared among all\n// implementations (file, envelope, and appengine).\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\tstdLog \"log\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/golang/glog/internal/logsink\"\n\t\"github.com/golang/glog/internal/stackdump\"\n)\n\nvar timeNow = time.Now // Stubbed out for testing.\n\n// MaxSize is the maximum size of a log file in bytes.\nvar MaxSize uint64 = 1024 * 1024 * 1800\n\n// ErrNoLog is the error we return if no log file has yet been created\n// for the specified log type.\nvar ErrNoLog = errors.New(\"log file not yet created\")\n\n// OutputStats tracks the number of output lines and bytes written.\ntype OutputStats struct {\n\tlines int64\n\tbytes int64\n}\n\n// Lines returns the number of lines written.\nfunc (s *OutputStats) Lines() int64 {\n\treturn atomic.LoadInt64(&s.lines)\n}\n\n// Bytes returns the number of bytes written.\nfunc (s *OutputStats) Bytes() int64 {\n\treturn atomic.LoadInt64(&s.bytes)\n}\n\n// Stats tracks the number of lines of output and number of bytes\n// per severity level. Values must be read with atomic.LoadInt64.\nvar Stats struct {\n\tInfo, Warning, Error OutputStats\n}\n\nvar severityStats = [...]*OutputStats{\n\tlogsink.Info:    &Stats.Info,\n\tlogsink.Warning: &Stats.Warning,\n\tlogsink.Error:   &Stats.Error,\n\tlogsink.Fatal:   nil,\n}\n\n// Level specifies a level of verbosity for V logs.  The -v flag is of type\n// Level and should be modified only through the flag.Value interface.\ntype Level int32\n\nvar metaPool sync.Pool // Pool of *logsink.Meta.\n\n// metaPoolGet returns a *logsink.Meta from metaPool as both an interface and a\n// pointer, allocating a new one if necessary.  (Returning the interface value\n// directly avoids an allocation if there was an existing pointer in the pool.)\nfunc metaPoolGet() (any, *logsink.Meta) {\n\tif metai := metaPool.Get(); metai != nil {\n\t\treturn metai, metai.(*logsink.Meta)\n\t}\n\tmeta := new(logsink.Meta)\n\treturn meta, meta\n}\n\ntype stack bool\n\nconst (\n\tnoStack   = stack(false)\n\twithStack = stack(true)\n)\n\nfunc appendBacktrace(depth int, format string, args []any) (string, []any) {\n\t// Capture a backtrace as a stackdump.Stack (both text and PC slice).\n\t// Structured log sinks can extract the backtrace in whichever format they\n\t// prefer (PCs or text), and Text sinks will include it as just another part\n\t// of the log message.\n\t//\n\t// Use depth instead of depth+1 so that the backtrace always includes the\n\t// log function itself - otherwise the reason for the trace appearing in the\n\t// log may not be obvious to the reader.\n\tdump := stackdump.Caller(depth)\n\n\t// Add an arg and an entry in the format string for the stack dump.\n\t//\n\t// Copy the \"args\" slice to avoid a rare but serious aliasing bug\n\t// (corrupting the caller's slice if they passed it to a non-Fatal call\n\t// using \"...\").\n\tformat = format + \"\\n\\n%v\\n\"\n\targs = append(append([]any(nil), args...), dump)\n\n\treturn format, args\n}\n\n// logf acts as ctxlogf, but doesn't expect a context.\nfunc logf(depth int, severity logsink.Severity, verbose bool, stack stack, format string, args ...any) {\n\tctxlogf(nil, depth+1, severity, verbose, stack, format, args...)\n}\n\n// ctxlogf writes a log message for a log function call (or log function wrapper)\n// at the given depth in the current goroutine's stack.\nfunc ctxlogf(ctx context.Context, depth int, severity logsink.Severity, verbose bool, stack stack, format string, args ...any) {\n\tnow := timeNow()\n\t_, file, line, ok := runtime.Caller(depth + 1)\n\tif !ok {\n\t\tfile = \"???\"\n\t\tline = 1\n\t}\n\n\tif stack == withStack || backtraceAt(file, line) {\n\t\tformat, args = appendBacktrace(depth+1, format, args)\n\t}\n\n\tmetai, meta := metaPoolGet()\n\t*meta = logsink.Meta{\n\t\tContext:  ctx,\n\t\tTime:     now,\n\t\tFile:     file,\n\t\tLine:     line,\n\t\tDepth:    depth + 1,\n\t\tSeverity: severity,\n\t\tVerbose:  verbose,\n\t\tThread:   int64(pid),\n\t}\n\tsinkf(meta, format, args...)\n\t// Clear pointer fields so they can be garbage collected early.\n\tmeta.Context = nil\n\tmeta.Stack = nil\n\tmetaPool.Put(metai)\n}\n\nfunc sinkf(meta *logsink.Meta, format string, args ...any) {\n\tmeta.Depth++\n\tn, err := logsink.Printf(meta, format, args...)\n\tif stats := severityStats[meta.Severity]; stats != nil {\n\t\tatomic.AddInt64(&stats.lines, 1)\n\t\tatomic.AddInt64(&stats.bytes, int64(n))\n\t}\n\n\tif err != nil {\n\t\tlogsink.Printf(meta, \"glog: exiting because of error: %s\", err)\n\t\tsinks.file.Flush()\n\t\tos.Exit(2)\n\t}\n}\n\n// CopyStandardLogTo arranges for messages written to the Go \"log\" package's\n// default logs to also appear in the Google logs for the named and lower\n// severities.  Subsequent changes to the standard log's default output location\n// or format may break this behavior.\n//\n// Valid names are \"INFO\", \"WARNING\", \"ERROR\", and \"FATAL\".  If the name is not\n// recognized, CopyStandardLogTo panics.\nfunc CopyStandardLogTo(name string) {\n\tsev, err := logsink.ParseSeverity(name)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"log.CopyStandardLogTo(%q): %v\", name, err))\n\t}\n\t// Set a log format that captures the user's file and line:\n\t//   d.go:23: message\n\tstdLog.SetFlags(stdLog.Lshortfile)\n\tstdLog.SetOutput(logBridge(sev))\n}\n\n// NewStandardLogger returns a Logger that writes to the Google logs for the\n// named and lower severities.\n//\n// Valid names are \"INFO\", \"WARNING\", \"ERROR\", and \"FATAL\". If the name is not\n// recognized, NewStandardLogger panics.\nfunc NewStandardLogger(name string) *stdLog.Logger {\n\tsev, err := logsink.ParseSeverity(name)\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"log.NewStandardLogger(%q): %v\", name, err))\n\t}\n\treturn stdLog.New(logBridge(sev), \"\", stdLog.Lshortfile)\n}\n\n// logBridge provides the Write method that enables CopyStandardLogTo to connect\n// Go's standard logs to the logs provided by this package.\ntype logBridge logsink.Severity\n\n// Write parses the standard logging line and passes its components to the\n// logger for severity(lb).\nfunc (lb logBridge) Write(b []byte) (n int, err error) {\n\tvar (\n\t\tfile = \"???\"\n\t\tline = 1\n\t\ttext string\n\t)\n\t// Split \"d.go:23: message\" into \"d.go\", \"23\", and \"message\".\n\tif parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {\n\t\ttext = fmt.Sprintf(\"bad log format: %s\", b)\n\t} else {\n\t\tfile = string(parts[0])\n\t\ttext = string(parts[2][1:]) // skip leading space\n\t\tline, err = strconv.Atoi(string(parts[1]))\n\t\tif err != nil {\n\t\t\ttext = fmt.Sprintf(\"bad line number: %s\", b)\n\t\t\tline = 1\n\t\t}\n\t}\n\n\t// The depth below hard-codes details of how stdlog gets here.  The alternative would be to walk\n\t// up the stack looking for src/log/log.go but that seems like it would be\n\t// unfortunately slow.\n\tconst stdLogDepth = 4\n\n\tmetai, meta := metaPoolGet()\n\t*meta = logsink.Meta{\n\t\tTime:     timeNow(),\n\t\tFile:     file,\n\t\tLine:     line,\n\t\tDepth:    stdLogDepth,\n\t\tSeverity: logsink.Severity(lb),\n\t\tThread:   int64(pid),\n\t}\n\n\tformat := \"%s\"\n\targs := []any{text}\n\tif backtraceAt(file, line) {\n\t\tformat, args = appendBacktrace(meta.Depth, format, args)\n\t}\n\n\tsinkf(meta, format, args...)\n\tmetaPool.Put(metai)\n\n\treturn len(b), nil\n}\n\n// defaultFormat returns a fmt.Printf format specifier that formats its\n// arguments as if they were passed to fmt.Print.\nfunc defaultFormat(args []any) string {\n\tn := len(args)\n\tswitch n {\n\tcase 0:\n\t\treturn \"\"\n\tcase 1:\n\t\treturn \"%v\"\n\t}\n\n\tb := make([]byte, 0, n*3-1)\n\twasString := true // Suppress leading space.\n\tfor _, arg := range args {\n\t\tisString := arg != nil && reflect.TypeOf(arg).Kind() == reflect.String\n\t\tif wasString || isString {\n\t\t\tb = append(b, \"%v\"...)\n\t\t} else {\n\t\t\tb = append(b, \" %v\"...)\n\t\t}\n\t\twasString = isString\n\t}\n\treturn string(b)\n}\n\n// lnFormat returns a fmt.Printf format specifier that formats its arguments\n// as if they were passed to fmt.Println.\nfunc lnFormat(args []any) string {\n\tif len(args) == 0 {\n\t\treturn \"\\n\"\n\t}\n\n\tb := make([]byte, 0, len(args)*3)\n\tfor range args {\n\t\tb = append(b, \"%v \"...)\n\t}\n\tb[len(b)-1] = '\\n' // Replace the last space with a newline.\n\treturn string(b)\n}\n\n// Verbose is a boolean type that implements Infof (like Printf) etc.\n// See the documentation of V for more information.\ntype Verbose bool\n\n// V reports whether verbosity at the call site is at least the requested level.\n// The returned value is a boolean of type Verbose, which implements Info, Infoln\n// and Infof. These methods will write to the Info log if called.\n// Thus, one may write either\n//\n//\tif glog.V(2) { glog.Info(\"log this\") }\n//\n// or\n//\n//\tglog.V(2).Info(\"log this\")\n//\n// The second form is shorter but the first is cheaper if logging is off because it does\n// not evaluate its arguments.\n//\n// Whether an individual call to V generates a log record depends on the setting of\n// the -v and --vmodule flags; both are off by default. If the level in the call to\n// V is at most the value of -v, or of -vmodule for the source file containing the\n// call, the V call will log.\nfunc V(level Level) Verbose {\n\treturn VDepth(1, level)\n}\n\n// VDepth acts as V but uses depth to determine which call frame to check vmodule for.\n// VDepth(0, level) is the same as V(level).\nfunc VDepth(depth int, level Level) Verbose {\n\treturn Verbose(verboseEnabled(depth+1, level))\n}\n\n// Info is equivalent to the global Info function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) Info(args ...any) {\n\tv.InfoDepth(1, args...)\n}\n\n// InfoDepth is equivalent to the global InfoDepth function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) InfoDepth(depth int, args ...any) {\n\tif v {\n\t\tlogf(depth+1, logsink.Info, true, noStack, defaultFormat(args), args...)\n\t}\n}\n\n// InfoDepthf is equivalent to the global InfoDepthf function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) InfoDepthf(depth int, format string, args ...any) {\n\tif v {\n\t\tlogf(depth+1, logsink.Info, true, noStack, format, args...)\n\t}\n}\n\n// Infoln is equivalent to the global Infoln function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) Infoln(args ...any) {\n\tif v {\n\t\tlogf(1, logsink.Info, true, noStack, lnFormat(args), args...)\n\t}\n}\n\n// Infof is equivalent to the global Infof function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) Infof(format string, args ...any) {\n\tif v {\n\t\tlogf(1, logsink.Info, true, noStack, format, args...)\n\t}\n}\n\n// InfoContext is equivalent to the global InfoContext function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) InfoContext(ctx context.Context, args ...any) {\n\tv.InfoContextDepth(ctx, 1, args...)\n}\n\n// InfoContextf is equivalent to the global InfoContextf function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) InfoContextf(ctx context.Context, format string, args ...any) {\n\tif v {\n\t\tctxlogf(ctx, 1, logsink.Info, true, noStack, format, args...)\n\t}\n}\n\n// InfoContextDepth is equivalent to the global InfoContextDepth function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) InfoContextDepth(ctx context.Context, depth int, args ...any) {\n\tif v {\n\t\tctxlogf(ctx, depth+1, logsink.Info, true, noStack, defaultFormat(args), args...)\n\t}\n}\n\n// InfoContextDepthf is equivalent to the global InfoContextDepthf function, guarded by the value of v.\n// See the documentation of V for usage.\nfunc (v Verbose) InfoContextDepthf(ctx context.Context, depth int, format string, args ...any) {\n\tif v {\n\t\tctxlogf(ctx, depth+1, logsink.Info, true, noStack, format, args...)\n\t}\n}\n\n// Info logs to the INFO log.\n// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.\nfunc Info(args ...any) {\n\tInfoDepth(1, args...)\n}\n\n// InfoDepth calls Info from a different depth in the call stack.\n// This enables a callee to emit logs that use the callsite information of its caller\n// or any other callers in the stack. When depth == 0, the original callee's line\n// information is emitted. When depth > 0, depth frames are skipped in the call stack\n// and the final frame is treated like the original callee to Info.\nfunc InfoDepth(depth int, args ...any) {\n\tlogf(depth+1, logsink.Info, false, noStack, defaultFormat(args), args...)\n}\n\n// InfoDepthf acts as InfoDepth but with format string.\nfunc InfoDepthf(depth int, format string, args ...any) {\n\tlogf(depth+1, logsink.Info, false, noStack, format, args...)\n}\n\n// Infoln logs to the INFO log.\n// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.\nfunc Infoln(args ...any) {\n\tlogf(1, logsink.Info, false, noStack, lnFormat(args), args...)\n}\n\n// Infof logs to the INFO log.\n// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.\nfunc Infof(format string, args ...any) {\n\tlogf(1, logsink.Info, false, noStack, format, args...)\n}\n\n// InfoContext is like [Info], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc InfoContext(ctx context.Context, args ...any) {\n\tInfoContextDepth(ctx, 1, args...)\n}\n\n// InfoContextf is like [Infof], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc InfoContextf(ctx context.Context, format string, args ...any) {\n\tctxlogf(ctx, 1, logsink.Info, false, noStack, format, args...)\n}\n\n// InfoContextDepth is like [InfoDepth], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc InfoContextDepth(ctx context.Context, depth int, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Info, false, noStack, defaultFormat(args), args...)\n}\n\n// InfoContextDepthf is like [InfoDepthf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc InfoContextDepthf(ctx context.Context, depth int, format string, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Info, false, noStack, format, args...)\n}\n\n// Warning logs to the WARNING and INFO logs.\n// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.\nfunc Warning(args ...any) {\n\tWarningDepth(1, args...)\n}\n\n// WarningDepth acts as Warning but uses depth to determine which call frame to log.\n// WarningDepth(0, \"msg\") is the same as Warning(\"msg\").\nfunc WarningDepth(depth int, args ...any) {\n\tlogf(depth+1, logsink.Warning, false, noStack, defaultFormat(args), args...)\n}\n\n// WarningDepthf acts as Warningf but uses depth to determine which call frame to log.\n// WarningDepthf(0, \"msg\") is the same as Warningf(\"msg\").\nfunc WarningDepthf(depth int, format string, args ...any) {\n\tlogf(depth+1, logsink.Warning, false, noStack, format, args...)\n}\n\n// Warningln logs to the WARNING and INFO logs.\n// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.\nfunc Warningln(args ...any) {\n\tlogf(1, logsink.Warning, false, noStack, lnFormat(args), args...)\n}\n\n// Warningf logs to the WARNING and INFO logs.\n// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.\nfunc Warningf(format string, args ...any) {\n\tlogf(1, logsink.Warning, false, noStack, format, args...)\n}\n\n// WarningContext is like [Warning], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc WarningContext(ctx context.Context, args ...any) {\n\tWarningContextDepth(ctx, 1, args...)\n}\n\n// WarningContextf is like [Warningf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc WarningContextf(ctx context.Context, format string, args ...any) {\n\tctxlogf(ctx, 1, logsink.Warning, false, noStack, format, args...)\n}\n\n// WarningContextDepth is like [WarningDepth], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc WarningContextDepth(ctx context.Context, depth int, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Warning, false, noStack, defaultFormat(args), args...)\n}\n\n// WarningContextDepthf is like [WarningDepthf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc WarningContextDepthf(ctx context.Context, depth int, format string, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Warning, false, noStack, format, args...)\n}\n\n// Error logs to the ERROR, WARNING, and INFO logs.\n// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.\nfunc Error(args ...any) {\n\tErrorDepth(1, args...)\n}\n\n// ErrorDepth acts as Error but uses depth to determine which call frame to log.\n// ErrorDepth(0, \"msg\") is the same as Error(\"msg\").\nfunc ErrorDepth(depth int, args ...any) {\n\tlogf(depth+1, logsink.Error, false, noStack, defaultFormat(args), args...)\n}\n\n// ErrorDepthf acts as Errorf but uses depth to determine which call frame to log.\n// ErrorDepthf(0, \"msg\") is the same as Errorf(\"msg\").\nfunc ErrorDepthf(depth int, format string, args ...any) {\n\tlogf(depth+1, logsink.Error, false, noStack, format, args...)\n}\n\n// Errorln logs to the ERROR, WARNING, and INFO logs.\n// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.\nfunc Errorln(args ...any) {\n\tlogf(1, logsink.Error, false, noStack, lnFormat(args), args...)\n}\n\n// Errorf logs to the ERROR, WARNING, and INFO logs.\n// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.\nfunc Errorf(format string, args ...any) {\n\tlogf(1, logsink.Error, false, noStack, format, args...)\n}\n\n// ErrorContext is like [Error], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ErrorContext(ctx context.Context, args ...any) {\n\tErrorContextDepth(ctx, 1, args...)\n}\n\n// ErrorContextf is like [Errorf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ErrorContextf(ctx context.Context, format string, args ...any) {\n\tctxlogf(ctx, 1, logsink.Error, false, noStack, format, args...)\n}\n\n// ErrorContextDepth is like [ErrorDepth], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ErrorContextDepth(ctx context.Context, depth int, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Error, false, noStack, defaultFormat(args), args...)\n}\n\n// ErrorContextDepthf is like [ErrorDepthf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ErrorContextDepthf(ctx context.Context, depth int, format string, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Error, false, noStack, format, args...)\n}\n\nfunc ctxfatalf(ctx context.Context, depth int, format string, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Fatal, false, withStack, format, args...)\n\tsinks.file.Flush()\n\n\terr := abortProcess() // Should not return.\n\n\t// Failed to abort the process using signals.  Dump a stack trace and exit.\n\tErrorf(\"abortProcess returned unexpectedly: %v\", err)\n\tsinks.file.Flush()\n\tpprof.Lookup(\"goroutine\").WriteTo(os.Stderr, 1)\n\tos.Exit(2) // Exit with the same code as the default SIGABRT handler.\n}\n\nfunc fatalf(depth int, format string, args ...any) {\n\tctxfatalf(nil, depth+1, format, args...)\n}\n\n// Fatal logs to the FATAL, ERROR, WARNING, and INFO logs,\n// including a stack trace of all running goroutines, then calls os.Exit(2).\n// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.\nfunc Fatal(args ...any) {\n\tFatalDepth(1, args...)\n}\n\n// FatalDepth acts as Fatal but uses depth to determine which call frame to log.\n// FatalDepth(0, \"msg\") is the same as Fatal(\"msg\").\nfunc FatalDepth(depth int, args ...any) {\n\tfatalf(depth+1, defaultFormat(args), args...)\n}\n\n// FatalDepthf acts as Fatalf but uses depth to determine which call frame to log.\n// FatalDepthf(0, \"msg\") is the same as Fatalf(\"msg\").\nfunc FatalDepthf(depth int, format string, args ...any) {\n\tfatalf(depth+1, format, args...)\n}\n\n// Fatalln logs to the FATAL, ERROR, WARNING, and INFO logs,\n// including a stack trace of all running goroutines, then calls os.Exit(2).\n// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.\nfunc Fatalln(args ...any) {\n\tfatalf(1, lnFormat(args), args...)\n}\n\n// Fatalf logs to the FATAL, ERROR, WARNING, and INFO logs,\n// including a stack trace of all running goroutines, then calls os.Exit(2).\n// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.\nfunc Fatalf(format string, args ...any) {\n\tfatalf(1, format, args...)\n}\n\n// FatalContext is like [Fatal], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc FatalContext(ctx context.Context, args ...any) {\n\tFatalContextDepth(ctx, 1, args...)\n}\n\n// FatalContextf is like [Fatalf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc FatalContextf(ctx context.Context, format string, args ...any) {\n\tctxfatalf(ctx, 1, format, args...)\n}\n\n// FatalContextDepth is like [FatalDepth], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc FatalContextDepth(ctx context.Context, depth int, args ...any) {\n\tctxfatalf(ctx, depth+1, defaultFormat(args), args...)\n}\n\n// FatalContextDepthf is like [FatalDepthf], but with an extra [context.Context] parameter.\nfunc FatalContextDepthf(ctx context.Context, depth int, format string, args ...any) {\n\tctxfatalf(ctx, depth+1, format, args...)\n}\n\nfunc ctxexitf(ctx context.Context, depth int, format string, args ...any) {\n\tctxlogf(ctx, depth+1, logsink.Fatal, false, noStack, format, args...)\n\tsinks.file.Flush()\n\tos.Exit(1)\n}\n\nfunc exitf(depth int, format string, args ...any) {\n\tctxexitf(nil, depth+1, format, args...)\n}\n\n// Exit logs to the FATAL, ERROR, WARNING, and INFO logs, then calls os.Exit(1).\n// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.\nfunc Exit(args ...any) {\n\tExitDepth(1, args...)\n}\n\n// ExitDepth acts as Exit but uses depth to determine which call frame to log.\n// ExitDepth(0, \"msg\") is the same as Exit(\"msg\").\nfunc ExitDepth(depth int, args ...any) {\n\texitf(depth+1, defaultFormat(args), args...)\n}\n\n// ExitDepthf acts as Exitf but uses depth to determine which call frame to log.\n// ExitDepthf(0, \"msg\") is the same as Exitf(\"msg\").\nfunc ExitDepthf(depth int, format string, args ...any) {\n\texitf(depth+1, format, args...)\n}\n\n// Exitln logs to the FATAL, ERROR, WARNING, and INFO logs, then calls os.Exit(1).\nfunc Exitln(args ...any) {\n\texitf(1, lnFormat(args), args...)\n}\n\n// Exitf logs to the FATAL, ERROR, WARNING, and INFO logs, then calls os.Exit(1).\n// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.\nfunc Exitf(format string, args ...any) {\n\texitf(1, format, args...)\n}\n\n// ExitContext is like [Exit], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ExitContext(ctx context.Context, args ...any) {\n\tExitContextDepth(ctx, 1, args...)\n}\n\n// ExitContextf is like [Exitf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ExitContextf(ctx context.Context, format string, args ...any) {\n\tctxexitf(ctx, 1, format, args...)\n}\n\n// ExitContextDepth is like [ExitDepth], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ExitContextDepth(ctx context.Context, depth int, args ...any) {\n\tctxexitf(ctx, depth+1, defaultFormat(args), args...)\n}\n\n// ExitContextDepthf is like [ExitDepthf], but with an extra [context.Context] parameter. The\n// context is used to pass the Trace Context to log sinks.\nfunc ExitContextDepthf(ctx context.Context, depth int, format string, args ...any) {\n\tctxexitf(ctx, depth+1, format, args...)\n}\n"
        },
        {
          "name": "glog_bench_test.go",
          "type": "blob",
          "size": 3.1708984375,
          "content": "package glog\n\nimport (\n\t\"flag\"\n\t\"io/ioutil\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\n// discarder is a flushSyncWriter that discards all data.\n// Sync sleeps for 10ms to simulate a disk seek.\ntype discarder struct {\n}\n\nfunc (d *discarder) Write(data []byte) (int, error) {\n\treturn len(data), nil\n}\n\nfunc (d *discarder) Flush() error {\n\treturn nil\n}\n\nfunc (d *discarder) Sync() error {\n\ttime.Sleep(10 * time.Millisecond)\n\treturn nil\n}\n\nfunc (d *discarder) filenames() []string {\n\treturn nil\n}\n\n// newDiscard sets the log writers to all new byte buffers and returns the old array.\nfunc (s *fileSink) newDiscarders() severityWriters {\n\treturn s.swap(severityWriters{new(discarder), new(discarder), new(discarder), new(discarder)})\n}\n\nfunc discardStderr() func() {\n\tse := sinks.stderr.w\n\tsinks.stderr.w = ioutil.Discard\n\treturn func() { sinks.stderr.w = se }\n}\n\nconst message = \"benchmark log message\"\n\nfunc benchmarkLog(b *testing.B, log func(...any)) {\n\tdefer sinks.file.swap(sinks.file.newDiscarders())\n\tdefer discardStderr()()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tlog(message)\n\t}\n\tb.StopTimer()\n}\n\nfunc benchmarkLogConcurrent(b *testing.B, log func(...any)) {\n\tdefer sinks.file.swap(sinks.file.newDiscarders())\n\tdefer discardStderr()()\n\tb.ResetTimer()\n\tconcurrency := runtime.GOMAXPROCS(0)\n\tvar wg sync.WaitGroup\n\twg.Add(concurrency)\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func() {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tlog(message)\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n\tb.StopTimer()\n}\n\nfunc BenchmarkInfo(b *testing.B) {\n\tbenchmarkLog(b, Info)\n}\n\nfunc BenchmarkInfoConcurrent(b *testing.B) {\n\tbenchmarkLogConcurrent(b, Info)\n}\n\nfunc BenchmarkWarning(b *testing.B) {\n\tbenchmarkLog(b, Warning)\n}\n\nfunc BenchmarkWarningConcurrent(b *testing.B) {\n\tbenchmarkLogConcurrent(b, Warning)\n}\n\nfunc BenchmarkError(b *testing.B) {\n\tbenchmarkLog(b, Error)\n}\n\nfunc BenchmarkErrorConcurrent(b *testing.B) {\n\tbenchmarkLogConcurrent(b, Error)\n}\n\nfunc mixer() func(...any) {\n\tvar i int64\n\treturn func(args ...any) {\n\t\tn := atomic.AddInt64(&i, 1)\n\t\tswitch {\n\t\tcase n%10000 == 0:\n\t\t\tError(args...)\n\t\tcase n%1000 == 0:\n\t\t\tWarning(args...)\n\t\tdefault:\n\t\t\tInfo(args...)\n\t\t}\n\t}\n}\n\nfunc BenchmarkMix(b *testing.B) {\n\tbenchmarkLog(b, mixer())\n}\n\nfunc BenchmarkMixConcurrent(b *testing.B) {\n\tbenchmarkLogConcurrent(b, mixer())\n}\n\nfunc BenchmarkVLogDisabled(b *testing.B) {\n\tbenchmarkLog(b, vlog)\n}\n\nfunc BenchmarkVLogDisabledConcurrent(b *testing.B) {\n\tbenchmarkLogConcurrent(b, vlog)\n}\n\nfunc BenchmarkVLogModuleFlagSet(b *testing.B) {\n\tdefer withVmodule(\"nonexistant=5\")()\n\tbenchmarkLog(b, vlog)\n}\n\nfunc BenchmarkVLogModuleFlagSetConcurrent(b *testing.B) {\n\tdefer withVmodule(\"nonexistant=5\")()\n\tbenchmarkLogConcurrent(b, vlog)\n}\n\nfunc BenchmarkVLogEnabled(b *testing.B) {\n\tdefer withVmodule(\"glog_bench_test=5\")()\n\tif got := bool(V(3)); got != true {\n\t\tb.Fatalf(\"V(3) == %v, want %v\", got, true)\n\t}\n\tbenchmarkLog(b, vlog)\n}\n\nfunc BenchmarkVLogEnabledConcurrent(b *testing.B) {\n\tdefer withVmodule(\"glog_bench_test=5\")()\n\tbenchmarkLogConcurrent(b, vlog)\n}\n\nfunc vlog(args ...any) {\n\tV(3).Info(args)\n}\n\nfunc withVmodule(val string) func() {\n\tif err := flag.Set(\"vmodule\", val); err != nil {\n\t\tpanic(err)\n\t}\n\treturn func() { flag.Set(\"vmodule\", \"\") }\n}\n"
        },
        {
          "name": "glog_context_test.go",
          "type": "blob",
          "size": 1.8603515625,
          "content": "package glog\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"testing\"\n\n\t\"github.com/golang/glog/internal/logsink\"\n)\n\ntype contextKey string\ntype fakeLogSink struct {\n\tcontext context.Context\n}\n\nvar ctxKey = contextKey(\"key\")\nvar ctxValue = \"some-value\"\nvar originalSinks = logsink.StructuredSinks\n\nfunc (s *fakeLogSink) Printf(meta *logsink.Meta, format string, args ...any) (int, error) {\n\ts.context = meta.Context\n\treturn 0, nil\n}\n\n// Test that log.(Info|Error|Warning)Context functions behave the same as non context variants\n// and pass right context.\nfunc TestLogContext(t *testing.T) {\n\tfakeLogSink := &fakeLogSink{}\n\tlogsink.StructuredSinks = append([]logsink.Structured{fakeLogSink}, originalSinks...)\n\n\tfuncs := map[string]func(ctx context.Context, args ...any){\n\t\t\"InfoContext\":      InfoContext,\n\t\t\"InfoContextDepth\": func(ctx context.Context, args ...any) { InfoContextDepth(ctx, 2, args) },\n\t\t\"ErrorContext\":     ErrorContext,\n\t\t\"WarningContext\":   WarningContext,\n\t}\n\n\tctx := context.WithValue(context.Background(), ctxKey, ctxValue)\n\tfor name, f := range funcs {\n\t\tf(ctx, \"test\")\n\t\twant := ctxValue\n\t\tif got := fakeLogSink.context.Value(ctxKey); got != want {\n\t\t\tt.Errorf(\"%s: context value unexpectedly missing: got %q, want %q\", name, got, want)\n\t\t}\n\t}\n}\n\n// Test that V.InfoContext behaves the same as V.Info and passes right context.\nfunc TestVInfoContext(t *testing.T) {\n\tfakeLogSink := &fakeLogSink{}\n\tlogsink.StructuredSinks = append([]logsink.Structured{fakeLogSink}, originalSinks...)\n\tif err := flag.Lookup(\"v\").Value.Set(\"2\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -v=2: %v\", err)\n\t}\n\tdefer flag.Lookup(\"v\").Value.Set(\"0\")\n\tctx := context.WithValue(context.Background(), ctxKey, ctxValue)\n\tV(2).InfoContext(ctx, \"test\")\n\twant := ctxValue\n\tif got := fakeLogSink.context.Value(ctxKey); got != want {\n\t\tt.Errorf(\"V.InfoContext: context value unexpectedly missing: got %q, want %q\", got, want)\n\t}\n}\n"
        },
        {
          "name": "glog_file.go",
          "type": "blob",
          "size": 11.1279296875,
          "content": "// Go support for leveled logs, analogous to https://github.com/google/glog.\n//\n// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// File I/O for logs.\n\npackage glog\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/golang/glog/internal/logsink\"\n)\n\n// logDirs lists the candidate directories for new log files.\nvar logDirs []string\n\nvar (\n\t// If non-empty, overrides the choice of directory in which to write logs.\n\t// See createLogDirs for the full list of possible destinations.\n\tlogDir      = flag.String(\"log_dir\", \"\", \"If non-empty, write log files in this directory\")\n\tlogLink     = flag.String(\"log_link\", \"\", \"If non-empty, add symbolic links in this directory to the log files\")\n\tlogBufLevel = flag.Int(\"logbuflevel\", int(logsink.Info), \"Buffer log messages logged at this level or lower\"+\n\t\t\" (-1 means don't buffer; 0 means buffer INFO only; ...). Has limited applicability on non-prod platforms.\")\n)\n\nfunc createLogDirs() {\n\tif *logDir != \"\" {\n\t\tlogDirs = append(logDirs, *logDir)\n\t}\n\tlogDirs = append(logDirs, os.TempDir())\n}\n\nvar (\n\tpid      = os.Getpid()\n\tprogram  = filepath.Base(os.Args[0])\n\thost     = \"unknownhost\"\n\tuserName = \"unknownuser\"\n)\n\nfunc init() {\n\th, err := os.Hostname()\n\tif err == nil {\n\t\thost = shortHostname(h)\n\t}\n\n\tif u := lookupUser(); u != \"\" {\n\t\tuserName = u\n\t}\n\t// Sanitize userName since it is used to construct file paths.\n\tuserName = strings.Map(func(r rune) rune {\n\t\tswitch {\n\t\tcase r >= 'a' && r <= 'z':\n\t\tcase r >= 'A' && r <= 'Z':\n\t\tcase r >= '0' && r <= '9':\n\t\tdefault:\n\t\t\treturn '_'\n\t\t}\n\t\treturn r\n\t}, userName)\n}\n\n// shortHostname returns its argument, truncating at the first period.\n// For instance, given \"www.google.com\" it returns \"www\".\nfunc shortHostname(hostname string) string {\n\tif i := strings.Index(hostname, \".\"); i >= 0 {\n\t\treturn hostname[:i]\n\t}\n\treturn hostname\n}\n\n// logName returns a new log file name containing tag, with start time t, and\n// the name for the symlink for tag.\nfunc logName(tag string, t time.Time) (name, link string) {\n\tname = fmt.Sprintf(\"%s.%s.%s.log.%s.%04d%02d%02d-%02d%02d%02d.%d\",\n\t\tprogram,\n\t\thost,\n\t\tuserName,\n\t\ttag,\n\t\tt.Year(),\n\t\tt.Month(),\n\t\tt.Day(),\n\t\tt.Hour(),\n\t\tt.Minute(),\n\t\tt.Second(),\n\t\tpid)\n\treturn name, program + \".\" + tag\n}\n\nvar onceLogDirs sync.Once\n\n// create creates a new log file and returns the file and its filename, which\n// contains tag (\"INFO\", \"FATAL\", etc.) and t.  If the file is created\n// successfully, create also attempts to update the symlink for that tag, ignoring\n// errors.\nfunc create(tag string, t time.Time) (f *os.File, filename string, err error) {\n\tonceLogDirs.Do(createLogDirs)\n\tif len(logDirs) == 0 {\n\t\treturn nil, \"\", errors.New(\"log: no log dirs\")\n\t}\n\tname, link := logName(tag, t)\n\tvar lastErr error\n\tfor _, dir := range logDirs {\n\t\tfname := filepath.Join(dir, name)\n\t\tf, err := os.Create(fname)\n\t\tif err == nil {\n\t\t\tsymlink := filepath.Join(dir, link)\n\t\t\tos.Remove(symlink)        // ignore err\n\t\t\tos.Symlink(name, symlink) // ignore err\n\t\t\tif *logLink != \"\" {\n\t\t\t\tlsymlink := filepath.Join(*logLink, link)\n\t\t\t\tos.Remove(lsymlink)         // ignore err\n\t\t\t\tos.Symlink(fname, lsymlink) // ignore err\n\t\t\t}\n\t\t\treturn f, fname, nil\n\t\t}\n\t\tlastErr = err\n\t}\n\treturn nil, \"\", fmt.Errorf(\"log: cannot create log: %v\", lastErr)\n}\n\n// flushSyncWriter is the interface satisfied by logging destinations.\ntype flushSyncWriter interface {\n\tFlush() error\n\tSync() error\n\tio.Writer\n\tfilenames() []string\n}\n\nvar sinks struct {\n\tstderr stderrSink\n\tfile   fileSink\n}\n\nfunc init() {\n\t// Register stderr first: that way if we crash during file-writing at least\n\t// the log will have gone somewhere.\n\tif shouldRegisterStderrSink() {\n\t\tlogsink.TextSinks = append(logsink.TextSinks, &sinks.stderr)\n\t}\n\tlogsink.TextSinks = append(logsink.TextSinks, &sinks.file)\n\n\tsinks.file.flushChan = make(chan logsink.Severity, 1)\n\tgo sinks.file.flushDaemon()\n}\n\n// stderrSink is a logsink.Text that writes log entries to stderr\n// if they meet certain conditions.\ntype stderrSink struct {\n\tmu sync.Mutex\n\tw  io.Writer // if nil Emit uses os.Stderr directly\n}\n\n// Enabled implements logsink.Text.Enabled.  It returns true if any of the\n// various stderr flags are enabled for logs of the given severity, if the log\n// message is from the standard \"log\" package, or if google.Init has not yet run\n// (and hence file logging is not yet initialized).\nfunc (s *stderrSink) Enabled(m *logsink.Meta) bool {\n\treturn toStderr || alsoToStderr || m.Severity >= stderrThreshold.get()\n}\n\n// Emit implements logsink.Text.Emit.\nfunc (s *stderrSink) Emit(m *logsink.Meta, data []byte) (n int, err error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tw := s.w\n\tif w == nil {\n\t\tw = os.Stderr\n\t}\n\tdn, err := w.Write(data)\n\tn += dn\n\treturn n, err\n}\n\n// severityWriters is an array of flushSyncWriter with a value for each\n// logsink.Severity.\ntype severityWriters [4]flushSyncWriter\n\n// fileSink is a logsink.Text that prints to a set of Google log files.\ntype fileSink struct {\n\tmu sync.Mutex\n\t// file holds writer for each of the log types.\n\tfile      severityWriters\n\tflushChan chan logsink.Severity\n}\n\n// Enabled implements logsink.Text.Enabled.  It returns true if google.Init\n// has run and both --disable_log_to_disk and --logtostderr are false.\nfunc (s *fileSink) Enabled(m *logsink.Meta) bool {\n\treturn !toStderr\n}\n\n// Emit implements logsink.Text.Emit\nfunc (s *fileSink) Emit(m *logsink.Meta, data []byte) (n int, err error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif err = s.createMissingFiles(m.Severity); err != nil {\n\t\treturn 0, err\n\t}\n\tfor sev := m.Severity; sev >= logsink.Info; sev-- {\n\t\tif _, fErr := s.file[sev].Write(data); fErr != nil && err == nil {\n\t\t\terr = fErr // Take the first error.\n\t\t}\n\t}\n\tn = len(data)\n\tif int(m.Severity) > *logBufLevel {\n\t\tselect {\n\t\tcase s.flushChan <- m.Severity:\n\t\tdefault:\n\t\t}\n\t}\n\n\treturn n, err\n}\n\n// syncBuffer joins a bufio.Writer to its underlying file, providing access to the\n// file's Sync method and providing a wrapper for the Write method that provides log\n// file rotation. There are conflicting methods, so the file cannot be embedded.\n// s.mu is held for all its methods.\ntype syncBuffer struct {\n\tsink *fileSink\n\t*bufio.Writer\n\tfile   *os.File\n\tnames  []string\n\tsev    logsink.Severity\n\tnbytes uint64 // The number of bytes written to this file\n}\n\nfunc (sb *syncBuffer) Sync() error {\n\treturn sb.file.Sync()\n}\n\nfunc (sb *syncBuffer) Write(p []byte) (n int, err error) {\n\tif sb.nbytes+uint64(len(p)) >= MaxSize {\n\t\tif err := sb.rotateFile(time.Now()); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\tn, err = sb.Writer.Write(p)\n\tsb.nbytes += uint64(n)\n\treturn n, err\n}\n\nfunc (sb *syncBuffer) filenames() []string {\n\treturn sb.names\n}\n\nconst footer = \"\\nCONTINUED IN NEXT FILE\\n\"\n\n// rotateFile closes the syncBuffer's file and starts a new one.\nfunc (sb *syncBuffer) rotateFile(now time.Time) error {\n\tvar err error\n\tpn := \"<none>\"\n\tfile, name, err := create(sb.sev.String(), now)\n\n\tif sb.file != nil {\n\t\t// The current log file becomes the previous log at the end of\n\t\t// this block, so save its name for use in the header of the next\n\t\t// file.\n\t\tpn = sb.file.Name()\n\t\tsb.Flush()\n\t\t// If there's an existing file, write a footer with the name of\n\t\t// the next file in the chain, followed by the constant string\n\t\t// \\nCONTINUED IN NEXT FILE\\n to make continuation detection simple.\n\t\tsb.file.Write([]byte(\"Next log: \"))\n\t\tsb.file.Write([]byte(name))\n\t\tsb.file.Write([]byte(footer))\n\t\tsb.file.Close()\n\t}\n\n\tsb.file = file\n\tsb.names = append(sb.names, name)\n\tsb.nbytes = 0\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsb.Writer = bufio.NewWriterSize(sb.file, bufferSize)\n\n\t// Write header.\n\tvar buf bytes.Buffer\n\tfmt.Fprintf(&buf, \"Log file created at: %s\\n\", now.Format(\"2006/01/02 15:04:05\"))\n\tfmt.Fprintf(&buf, \"Running on machine: %s\\n\", host)\n\tfmt.Fprintf(&buf, \"Binary: Built with %s %s for %s/%s\\n\", runtime.Compiler, runtime.Version(), runtime.GOOS, runtime.GOARCH)\n\tfmt.Fprintf(&buf, \"Previous log: %s\\n\", pn)\n\tfmt.Fprintf(&buf, \"Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg\\n\")\n\tn, err := sb.file.Write(buf.Bytes())\n\tsb.nbytes += uint64(n)\n\treturn err\n}\n\n// bufferSize sizes the buffer associated with each log file. It's large\n// so that log records can accumulate without the logging thread blocking\n// on disk I/O. The flushDaemon will block instead.\nconst bufferSize = 256 * 1024\n\n// createMissingFiles creates all the log files for severity from infoLog up to\n// upTo that have not already been created.\n// s.mu is held.\nfunc (s *fileSink) createMissingFiles(upTo logsink.Severity) error {\n\tif s.file[upTo] != nil {\n\t\treturn nil\n\t}\n\tnow := time.Now()\n\t// Files are created in increasing severity order, so we can be assured that\n\t// if a high severity logfile exists, then so do all of lower severity.\n\tfor sev := logsink.Info; sev <= upTo; sev++ {\n\t\tif s.file[sev] != nil {\n\t\t\tcontinue\n\t\t}\n\t\tsb := &syncBuffer{\n\t\t\tsink: s,\n\t\t\tsev:  sev,\n\t\t}\n\t\tif err := sb.rotateFile(now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.file[sev] = sb\n\t}\n\treturn nil\n}\n\n// flushDaemon periodically flushes the log file buffers.\nfunc (s *fileSink) flushDaemon() {\n\ttick := time.NewTicker(30 * time.Second)\n\tdefer tick.Stop()\n\tfor {\n\t\tselect {\n\t\tcase <-tick.C:\n\t\t\ts.Flush()\n\t\tcase sev := <-s.flushChan:\n\t\t\ts.flush(sev)\n\t\t}\n\t}\n}\n\n// Flush flushes all pending log I/O.\nfunc Flush() {\n\tsinks.file.Flush()\n}\n\n// Flush flushes all the logs and attempts to \"sync\" their data to disk.\nfunc (s *fileSink) Flush() error {\n\treturn s.flush(logsink.Info)\n}\n\n// flush flushes all logs of severity threshold or greater.\nfunc (s *fileSink) flush(threshold logsink.Severity) error {\n\tvar firstErr error\n\tupdateErr := func(err error) {\n\t\tif err != nil && firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\t// Remember where we flushed, so we can call sync without holding\n\t// the lock.\n\tvar files []flushSyncWriter\n\tfunc() {\n\t\ts.mu.Lock()\n\t\tdefer s.mu.Unlock()\n\t\t// Flush from fatal down, in case there's trouble flushing.\n\t\tfor sev := logsink.Fatal; sev >= threshold; sev-- {\n\t\t\tif file := s.file[sev]; file != nil {\n\t\t\t\tupdateErr(file.Flush())\n\t\t\t\tfiles = append(files, file)\n\t\t\t}\n\t\t}\n\t}()\n\n\tfor _, file := range files {\n\t\tupdateErr(file.Sync())\n\t}\n\n\treturn firstErr\n}\n\n// Names returns the names of the log files holding the FATAL, ERROR,\n// WARNING, or INFO logs. Returns ErrNoLog if the log for the given\n// level doesn't exist (e.g. because no messages of that level have been\n// written). This may return multiple names if the log type requested\n// has rolled over.\nfunc Names(s string) ([]string, error) {\n\tseverity, err := logsink.ParseSeverity(s)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsinks.file.mu.Lock()\n\tdefer sinks.file.mu.Unlock()\n\tf := sinks.file.file[severity]\n\tif f == nil {\n\t\treturn nil, ErrNoLog\n\t}\n\n\treturn f.filenames(), nil\n}\n"
        },
        {
          "name": "glog_file_linux.go",
          "type": "blob",
          "size": 1.2373046875,
          "content": "// Go support for leveled logs, analogous to https://github.com/google/glog.\n//\n// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build linux\n\npackage glog\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\t\"syscall\"\n)\n\n// abortProcess attempts to kill the current process in a way that will dump the\n// currently-running goroutines someplace useful (like stderr).\n//\n// It does this by sending SIGABRT to the current thread.\n//\n// If successful, abortProcess does not return.\nfunc abortProcess() error {\n\truntime.LockOSThread()\n\tif err := syscall.Tgkill(syscall.Getpid(), syscall.Gettid(), syscall.SIGABRT); err != nil {\n\t\treturn err\n\t}\n\treturn errors.New(\"log: killed current thread with SIGABRT, but still running\")\n}\n"
        },
        {
          "name": "glog_file_nonwindows.go",
          "type": "blob",
          "size": 0.4541015625,
          "content": "//go:build !windows\n\npackage glog\n\nimport \"os/user\"\n\n// shouldRegisterStderrSink determines whether we should register a log sink that writes to stderr.\n// Today, this always returns true on non-Windows platforms, as it specifically checks for a\n// condition that is only present on Windows.\nfunc shouldRegisterStderrSink() bool {\n\treturn true\n}\n\nfunc lookupUser() string {\n\tif current, err := user.Current(); err == nil {\n\t\treturn current.Username\n\t}\n\treturn \"\"\n}\n"
        },
        {
          "name": "glog_file_other.go",
          "type": "blob",
          "size": 0.9765625,
          "content": "// Go support for leveled logs, analogous to https://github.com/google/glog.\n//\n// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !(unix || windows)\n\npackage glog\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\n// abortProcess returns an error on platforms that presumably don't support signals.\nfunc abortProcess() error {\n\treturn fmt.Errorf(\"not sending SIGABRT (%s/%s does not support signals), falling back\", runtime.GOOS, runtime.GOARCH)\n\n}\n"
        },
        {
          "name": "glog_file_posix.go",
          "type": "blob",
          "size": 1.7724609375,
          "content": "// Go support for leveled logs, analogous to https://github.com/google/glog.\n//\n// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build (unix || windows) && !linux\n\npackage glog\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n)\n\n// abortProcess attempts to kill the current process in a way that will dump the\n// currently-running goroutines someplace useful (like stderr).\n//\n// It does this by sending SIGABRT to the current process. Unfortunately, the\n// signal may or may not be delivered to the current thread; in order to do that\n// portably, we would need to add a cgo dependency and call pthread_kill.\n//\n// If successful, abortProcess does not return.\nfunc abortProcess() error {\n\tp, err := os.FindProcess(os.Getpid())\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := p.Signal(syscall.SIGABRT); err != nil {\n\t\treturn err\n\t}\n\n\t// Sent the signal.  Now we wait for it to arrive and any SIGABRT handlers to\n\t// run (and eventually terminate the process themselves).\n\t//\n\t// We could just \"select{}\" here, but there's an outside chance that would\n\t// trigger the runtime's deadlock detector if there happen not to be any\n\t// background goroutines running.  So we'll sleep a while first to give\n\t// the signal some time.\n\ttime.Sleep(10 * time.Second)\n\tselect {}\n}\n"
        },
        {
          "name": "glog_file_windows.go",
          "type": "blob",
          "size": 1.3544921875,
          "content": "//go:build windows\n\npackage glog\n\nimport (\n\t\"os\"\n\t\"syscall\"\n)\n\n// shouldRegisterStderrSink determines whether we should register a log sink that writes to stderr.\n// Today, this checks if stderr is \"valid\", in that it maps to a non-NULL Handle.\n// Windows Services are spawned without Stdout and Stderr, so any attempt to use them equates to\n// referencing an invalid file Handle.\n// os.Stderr's FD is derived from a call to `syscall.GetStdHandle(syscall.STD_ERROR_HANDLE)`.\n// Documentation[1] for the GetStdHandle function indicates the return value may be NULL if the\n// application lacks the standard handle, so consider Stderr valid if its FD is non-NULL.\n// [1]: https://learn.microsoft.com/en-us/windows/console/getstdhandle\nfunc shouldRegisterStderrSink() bool {\n\treturn os.Stderr.Fd() != 0\n}\n\n// This follows the logic in the standard library's user.Current() function, except\n// that it leaves out the potentially expensive calls required to look up the user's\n// display name in Active Directory.\nfunc lookupUser() string {\n\ttoken, err := syscall.OpenCurrentProcessToken()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tdefer token.Close()\n\ttokenUser, err := token.GetTokenUser()\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tusername, _, accountType, err := tokenUser.User.Sid.LookupAccount(\"\")\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tif accountType != syscall.SidTypeUser {\n\t\treturn \"\"\n\t}\n\treturn username\n}\n"
        },
        {
          "name": "glog_flags.go",
          "type": "blob",
          "size": 11.171875,
          "content": "// Go support for leveled logs, analogous to https://github.com/google/glog.\n//\n// Copyright 2023 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage glog\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/golang/glog/internal/logsink\"\n)\n\n// modulePat contains a filter for the -vmodule flag.\n// It holds a verbosity level and a file pattern to match.\ntype modulePat struct {\n\tpattern string\n\tliteral bool // The pattern is a literal string\n\tfull    bool // The pattern wants to match the full path\n\tlevel   Level\n}\n\n// match reports whether the file matches the pattern. It uses a string\n// comparison if the pattern contains no metacharacters.\nfunc (m *modulePat) match(full, file string) bool {\n\tif m.literal {\n\t\tif m.full {\n\t\t\treturn full == m.pattern\n\t\t}\n\t\treturn file == m.pattern\n\t}\n\tif m.full {\n\t\tmatch, _ := filepath.Match(m.pattern, full)\n\t\treturn match\n\t}\n\tmatch, _ := filepath.Match(m.pattern, file)\n\treturn match\n}\n\n// isLiteral reports whether the pattern is a literal string, that is, has no metacharacters\n// that require filepath.Match to be called to match the pattern.\nfunc isLiteral(pattern string) bool {\n\treturn !strings.ContainsAny(pattern, `\\*?[]`)\n}\n\n// isFull reports whether the pattern matches the full file path, that is,\n// whether it contains /.\nfunc isFull(pattern string) bool {\n\treturn strings.ContainsRune(pattern, '/')\n}\n\n// verboseFlags represents the setting of the -v and -vmodule flags.\ntype verboseFlags struct {\n\t// moduleLevelCache is a sync.Map storing the -vmodule Level for each V()\n\t// call site, identified by PC. If there is no matching -vmodule filter,\n\t// the cached value is exactly v. moduleLevelCache is replaced with a new\n\t// Map whenever the -vmodule or -v flag changes state.\n\tmoduleLevelCache atomic.Value\n\n\t// mu guards all fields below.\n\tmu sync.Mutex\n\n\t// v stores the value of the -v flag.  It may be read safely using\n\t// sync.LoadInt32, but is only modified under mu.\n\tv Level\n\n\t// module stores the parsed -vmodule flag.\n\tmodule []modulePat\n\n\t// moduleLength caches len(module).  If greater than zero, it\n\t// means vmodule is enabled. It may be read safely using sync.LoadInt32, but\n\t// is only modified under mu.\n\tmoduleLength int32\n}\n\n// NOTE: For compatibility with the open-sourced v1 version of this\n// package (github.com/golang/glog) we need to retain that flag.Level\n// implements the flag.Value interface. See also go/log-vs-glog.\n\n// String is part of the flag.Value interface.\nfunc (l *Level) String() string {\n\treturn strconv.FormatInt(int64(l.Get().(Level)), 10)\n}\n\n// Get is part of the flag.Value interface.\nfunc (l *Level) Get() any {\n\tif l == &vflags.v {\n\t\t// l is the value registered for the -v flag.\n\t\treturn Level(atomic.LoadInt32((*int32)(l)))\n\t}\n\treturn *l\n}\n\n// Set is part of the flag.Value interface.\nfunc (l *Level) Set(value string) error {\n\tv, err := strconv.Atoi(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif l == &vflags.v {\n\t\t// l is the value registered for the -v flag.\n\t\tvflags.mu.Lock()\n\t\tdefer vflags.mu.Unlock()\n\t\tvflags.moduleLevelCache.Store(&sync.Map{})\n\t\tatomic.StoreInt32((*int32)(l), int32(v))\n\t\treturn nil\n\t}\n\t*l = Level(v)\n\treturn nil\n}\n\n// vModuleFlag is the flag.Value for the --vmodule flag.\ntype vModuleFlag struct{ *verboseFlags }\n\nfunc (f vModuleFlag) String() string {\n\t// Do not panic on the zero value.\n\t// https://groups.google.com/g/golang-nuts/c/Atlr8uAjn6U/m/iId17Td5BQAJ.\n\tif f.verboseFlags == nil {\n\t\treturn \"\"\n\t}\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tvar b bytes.Buffer\n\tfor i, f := range f.module {\n\t\tif i > 0 {\n\t\t\tb.WriteRune(',')\n\t\t}\n\t\tfmt.Fprintf(&b, \"%s=%d\", f.pattern, f.level)\n\t}\n\treturn b.String()\n}\n\n// Get returns nil for this flag type since the struct is not exported.\nfunc (f vModuleFlag) Get() any { return nil }\n\nvar errVmoduleSyntax = errors.New(\"syntax error: expect comma-separated list of filename=N\")\n\n// Syntax: -vmodule=recordio=2,foo/bar/baz=1,gfs*=3\nfunc (f vModuleFlag) Set(value string) error {\n\tvar filter []modulePat\n\tfor _, pat := range strings.Split(value, \",\") {\n\t\tif len(pat) == 0 {\n\t\t\t// Empty strings such as from a trailing comma can be ignored.\n\t\t\tcontinue\n\t\t}\n\t\tpatLev := strings.Split(pat, \"=\")\n\t\tif len(patLev) != 2 || len(patLev[0]) == 0 || len(patLev[1]) == 0 {\n\t\t\treturn errVmoduleSyntax\n\t\t}\n\t\tpattern := patLev[0]\n\t\tv, err := strconv.Atoi(patLev[1])\n\t\tif err != nil {\n\t\t\treturn errors.New(\"syntax error: expect comma-separated list of filename=N\")\n\t\t}\n\t\t// TODO: check syntax of filter?\n\t\tfilter = append(filter, modulePat{pattern, isLiteral(pattern), isFull(pattern), Level(v)})\n\t}\n\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\tf.module = filter\n\tatomic.StoreInt32((*int32)(&f.moduleLength), int32(len(f.module)))\n\tf.moduleLevelCache.Store(&sync.Map{})\n\treturn nil\n}\n\nfunc (f *verboseFlags) levelForPC(pc uintptr) Level {\n\tif level, ok := f.moduleLevelCache.Load().(*sync.Map).Load(pc); ok {\n\t\treturn level.(Level)\n\t}\n\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\tlevel := Level(f.v)\n\tfn := runtime.FuncForPC(pc)\n\tfile, _ := fn.FileLine(pc)\n\t// The file is something like /a/b/c/d.go. We want just the d for\n\t// regular matches, /a/b/c/d for full matches.\n\tfile = strings.TrimSuffix(file, \".go\")\n\tfull := file\n\tif slash := strings.LastIndex(file, \"/\"); slash >= 0 {\n\t\tfile = file[slash+1:]\n\t}\n\tfor _, filter := range f.module {\n\t\tif filter.match(full, file) {\n\t\t\tlevel = filter.level\n\t\t\tbreak // Use the first matching level.\n\t\t}\n\t}\n\tf.moduleLevelCache.Load().(*sync.Map).Store(pc, level)\n\treturn level\n}\n\nfunc (f *verboseFlags) enabled(callerDepth int, level Level) bool {\n\tif atomic.LoadInt32(&f.moduleLength) == 0 {\n\t\t// No vmodule values specified, so compare against v level.\n\t\treturn Level(atomic.LoadInt32((*int32)(&f.v))) >= level\n\t}\n\n\tpcs := [1]uintptr{}\n\tif runtime.Callers(callerDepth+2, pcs[:]) < 1 {\n\t\treturn false\n\t}\n\tframe, _ := runtime.CallersFrames(pcs[:]).Next()\n\treturn f.levelForPC(frame.Entry) >= level\n}\n\n// traceLocation represents an entry in the -log_backtrace_at flag.\ntype traceLocation struct {\n\tfile string\n\tline int\n}\n\nvar errTraceSyntax = errors.New(\"syntax error: expect file.go:234\")\n\nfunc parseTraceLocation(value string) (traceLocation, error) {\n\tfields := strings.Split(value, \":\")\n\tif len(fields) != 2 {\n\t\treturn traceLocation{}, errTraceSyntax\n\t}\n\tfile, lineStr := fields[0], fields[1]\n\tif !strings.Contains(file, \".\") {\n\t\treturn traceLocation{}, errTraceSyntax\n\t}\n\tline, err := strconv.Atoi(lineStr)\n\tif err != nil {\n\t\treturn traceLocation{}, errTraceSyntax\n\t}\n\tif line < 0 {\n\t\treturn traceLocation{}, errors.New(\"negative value for line\")\n\t}\n\treturn traceLocation{file, line}, nil\n}\n\n// match reports whether the specified file and line matches the trace location.\n// The argument file name is the full path, not the basename specified in the flag.\nfunc (t traceLocation) match(file string, line int) bool {\n\tif t.line != line {\n\t\treturn false\n\t}\n\tif i := strings.LastIndex(file, \"/\"); i >= 0 {\n\t\tfile = file[i+1:]\n\t}\n\treturn t.file == file\n}\n\nfunc (t traceLocation) String() string {\n\treturn fmt.Sprintf(\"%s:%d\", t.file, t.line)\n}\n\n// traceLocations represents the -log_backtrace_at flag.\n// Syntax: -log_backtrace_at=recordio.go:234,sstable.go:456\n// Note that unlike vmodule the file extension is included here.\ntype traceLocations struct {\n\tmu      sync.Mutex\n\tlocsLen int32 // Safe for atomic read without mu.\n\tlocs    []traceLocation\n}\n\nfunc (t *traceLocations) String() string {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tvar buf bytes.Buffer\n\tfor i, tl := range t.locs {\n\t\tif i > 0 {\n\t\t\tbuf.WriteString(\",\")\n\t\t}\n\t\tbuf.WriteString(tl.String())\n\t}\n\treturn buf.String()\n}\n\n// Get always returns nil for this flag type since the struct is not exported\nfunc (t *traceLocations) Get() any { return nil }\n\nfunc (t *traceLocations) Set(value string) error {\n\tvar locs []traceLocation\n\tfor _, s := range strings.Split(value, \",\") {\n\t\tif s == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tloc, err := parseTraceLocation(s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlocs = append(locs, loc)\n\t}\n\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tatomic.StoreInt32(&t.locsLen, int32(len(locs)))\n\tt.locs = locs\n\treturn nil\n}\n\nfunc (t *traceLocations) match(file string, line int) bool {\n\tif atomic.LoadInt32(&t.locsLen) == 0 {\n\t\treturn false\n\t}\n\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tfor _, tl := range t.locs {\n\t\tif tl.match(file, line) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// severityFlag is an atomic flag.Value implementation for logsink.Severity.\ntype severityFlag int32\n\nfunc (s *severityFlag) get() logsink.Severity {\n\treturn logsink.Severity(atomic.LoadInt32((*int32)(s)))\n}\nfunc (s *severityFlag) String() string { return strconv.FormatInt(int64(*s), 10) }\nfunc (s *severityFlag) Get() any       { return s.get() }\nfunc (s *severityFlag) Set(value string) error {\n\tthreshold, err := logsink.ParseSeverity(value)\n\tif err != nil {\n\t\t// Not a severity name.  Try a raw number.\n\t\tv, err := strconv.Atoi(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tthreshold = logsink.Severity(v)\n\t\tif threshold < logsink.Info || threshold > logsink.Fatal {\n\t\t\treturn fmt.Errorf(\"Severity %d out of range (min %d, max %d).\", v, logsink.Info, logsink.Fatal)\n\t\t}\n\t}\n\tatomic.StoreInt32((*int32)(s), int32(threshold))\n\treturn nil\n}\n\nvar (\n\tvflags verboseFlags // The -v and -vmodule flags.\n\n\tlogBacktraceAt traceLocations // The -log_backtrace_at flag.\n\n\t// Boolean flags. Not handled atomically because the flag.Value interface\n\t// does not let us avoid the =true, and that shorthand is necessary for\n\t// compatibility. TODO: does this matter enough to fix? Seems unlikely.\n\ttoStderr     bool // The -logtostderr flag.\n\talsoToStderr bool // The -alsologtostderr flag.\n\n\tstderrThreshold severityFlag // The -stderrthreshold flag.\n)\n\n// verboseEnabled returns whether the caller at the given depth should emit\n// verbose logs at the given level, with depth 0 identifying the caller of\n// verboseEnabled.\nfunc verboseEnabled(callerDepth int, level Level) bool {\n\treturn vflags.enabled(callerDepth+1, level)\n}\n\n// backtraceAt returns whether the logging call at the given function and line\n// should also emit a backtrace of the current call stack.\nfunc backtraceAt(file string, line int) bool {\n\treturn logBacktraceAt.match(file, line)\n}\n\nfunc init() {\n\tvflags.moduleLevelCache.Store(&sync.Map{})\n\n\tflag.Var(&vflags.v, \"v\", \"log level for V logs\")\n\tflag.Var(vModuleFlag{&vflags}, \"vmodule\", \"comma-separated list of pattern=N settings for file-filtered logging\")\n\n\tflag.Var(&logBacktraceAt, \"log_backtrace_at\", \"when logging hits line file:N, emit a stack trace\")\n\n\tstderrThreshold = severityFlag(logsink.Error)\n\n\tflag.BoolVar(&toStderr, \"logtostderr\", false, \"log to standard error instead of files\")\n\tflag.BoolVar(&alsoToStderr, \"alsologtostderr\", false, \"log to standard error as well as files\")\n\tflag.Var(&stderrThreshold, \"stderrthreshold\", \"logs at or above this threshold go to stderr\")\n}\n"
        },
        {
          "name": "glog_test.go",
          "type": "blob",
          "size": 20.1845703125,
          "content": "package glog\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\tstdLog \"log\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/golang/glog/internal/logsink\"\n)\n\n// Test that shortHostname works as advertised.\nfunc TestShortHostname(t *testing.T) {\n\tfor hostname, expect := range map[string]string{\n\t\t\"\":                     \"\",\n\t\t\"host\":                 \"host\",\n\t\t\"host.google.com\":      \"host\",\n\t\t\"host.corp.google.com\": \"host\",\n\t} {\n\t\tif got := shortHostname(hostname); expect != got {\n\t\t\tt.Errorf(\"shortHostname(%q): expected %q, got %q\", hostname, expect, got)\n\t\t}\n\t}\n}\n\n// flushBuffer wraps a bytes.Buffer to satisfy flushSyncWriter.\ntype flushBuffer struct {\n\tbytes.Buffer\n}\n\nfunc (f *flushBuffer) Flush() error {\n\tf.Buffer.Reset()\n\treturn nil\n}\n\nfunc (f *flushBuffer) Sync() error {\n\treturn nil\n}\n\nfunc (f *flushBuffer) filenames() []string {\n\treturn []string{\"<local name>\"}\n}\n\n// swap sets the log writers and returns the old array.\nfunc (s *fileSink) swap(writers severityWriters) (old severityWriters) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\told = s.file\n\tfor i, w := range writers {\n\t\ts.file[i] = w\n\t}\n\treturn\n}\n\n// newBuffers sets the log writers to all new byte buffers and returns the old array.\nfunc (s *fileSink) newBuffers() severityWriters {\n\treturn s.swap(severityWriters{new(flushBuffer), new(flushBuffer), new(flushBuffer), new(flushBuffer)})\n}\n\nfunc (s *fileSink) resetBuffers() {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tfor _, buf := range s.file {\n\t\tif buf != nil {\n\t\t\tbuf.Flush()\n\t\t}\n\t}\n}\n\n// contents returns the specified log value as a string.\nfunc contents(s logsink.Severity) string {\n\treturn sinks.file.file[s].(*flushBuffer).String()\n}\n\n// contains reports whether the string is contained in the log.\nfunc contains(s logsink.Severity, str string, t *testing.T) bool {\n\treturn strings.Contains(contents(s), str)\n}\n\n// setFlags configures the logging flags how the test expects them.\nfunc setFlags() {\n\ttoStderr = false\n}\n\n// Test that Info works as advertised.\nfunc TestInfo(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tfuncs := []func(args ...any){\n\t\tInfo,\n\t\tfunc(args ...any) { InfoContext(context.Background(), args) },\n\t}\n\n\tfor _, f := range funcs {\n\t\tsinks.file.resetBuffers()\n\t\tf(\"test\")\n\t\tif !contains(logsink.Info, \"I\", t) {\n\t\t\tt.Errorf(\"Info has wrong character: %q\", contents(logsink.Info))\n\t\t}\n\t\tif !contains(logsink.Info, \"test\", t) {\n\t\t\tt.Error(\"Info failed\")\n\t\t}\n\t}\n}\n\nfunc TestInfoDepth(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\n\tfuncs := []func(d int, args ...any){\n\t\tInfoDepth,\n\t\tfunc(d int, args ...any) { InfoContextDepth(context.Background(), d+1, args) },\n\t}\n\n\tfor _, infoDepth := range funcs {\n\t\tsinks.file.resetBuffers()\n\t\tf := func() { infoDepth(1, \"depth-test1\") }\n\n\t\t// The next three lines must stay together\n\t\t_, _, wantLine, _ := runtime.Caller(0)\n\t\tinfoDepth(0, \"depth-test0\")\n\t\tf()\n\n\t\tmsgs := strings.Split(strings.TrimSuffix(contents(logsink.Info), \"\\n\"), \"\\n\")\n\t\tif len(msgs) != 2 {\n\t\t\tt.Fatalf(\"Got %d lines, expected 2\", len(msgs))\n\t\t}\n\n\t\tfor i, m := range msgs {\n\t\t\tif !strings.HasPrefix(m, \"I\") {\n\t\t\t\tt.Errorf(\"InfoDepth[%d] has wrong character: %q\", i, m)\n\t\t\t}\n\t\t\tw := fmt.Sprintf(\"depth-test%d\", i)\n\t\t\tif !strings.Contains(m, w) {\n\t\t\t\tt.Errorf(\"InfoDepth[%d] missing %q: %q\", i, w, m)\n\t\t\t}\n\n\t\t\t// pull out the line number (between : and ])\n\t\t\tmsg := m[strings.LastIndex(m, \":\")+1:]\n\t\t\tx := strings.Index(msg, \"]\")\n\t\t\tif x < 0 {\n\t\t\t\tt.Errorf(\"InfoDepth[%d]: missing ']': %q\", i, m)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tline, err := strconv.Atoi(msg[:x])\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"InfoDepth[%d]: bad line number: %q\", i, m)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twantLine++\n\t\t\tif wantLine != line {\n\t\t\t\tt.Errorf(\"InfoDepth[%d]: got line %d, want %d\", i, line, wantLine)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc init() {\n\tCopyStandardLogTo(\"INFO\")\n}\n\n// Test that CopyStandardLogTo panics on bad input.\nfunc TestCopyStandardLogToPanic(t *testing.T) {\n\tdefer func() {\n\t\tif s, ok := recover().(string); !ok || !strings.Contains(s, \"LOG\") {\n\t\t\tt.Errorf(`CopyStandardLogTo(\"LOG\") should have panicked: %v`, s)\n\t\t}\n\t}()\n\tCopyStandardLogTo(\"LOG\")\n}\n\n// Test that using the standard log package logs to INFO.\nfunc TestStandardLog(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tstdLog.Print(\"test\")\n\tif !contains(logsink.Info, \"I\", t) {\n\t\tt.Errorf(\"Info has wrong character: %q\", contents(logsink.Info))\n\t}\n\tif !contains(logsink.Info, \"test\", t) {\n\t\tt.Error(\"Info failed\")\n\t}\n}\n\n// Test that the header has the correct format.\nfunc TestHeader(t *testing.T) {\n\tsetFlags()\n\tdefer func(previous func() time.Time) { timeNow = previous }(timeNow)\n\ttimeNow = func() time.Time {\n\t\treturn time.Date(2006, 1, 2, 15, 4, 5, .067890e9, time.Local)\n\t}\n\n\toldPID := pid\n\tdefer func() { pid = oldPID }()\n\tpid = 1234\n\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\n\tInfo(\"testHeader\")\n\tvar line int\n\tformat := \"I0102 15:04:05.067890 %7d glog_test.go:%d] testHeader\\n\"\n\tvar gotPID int64\n\tn, err := fmt.Sscanf(contents(logsink.Info), format, &gotPID, &line)\n\tif n != 2 || err != nil {\n\t\tt.Errorf(\"log format error: %d elements, error %s:\\n%s\", n, err, contents(logsink.Info))\n\t}\n\n\tif want := int64(pid); gotPID != want {\n\t\tt.Errorf(\"expected log line to be logged with process ID %d, got %d\", want, gotPID)\n\t}\n\n\t// Scanf treats multiple spaces as equivalent to a single space,\n\t// so check for correct space-padding also.\n\twant := fmt.Sprintf(format, gotPID, line)\n\tif contents(logsink.Info) != want {\n\t\tt.Errorf(\"log format error: got:\\n\\t%q\\nwant:\\n\\t%q\", contents(logsink.Info), want)\n\t}\n\n}\n\n// Test that an Error log goes to Warning and Info.\n// Even in the Info log, the source character will be E, so the data should\n// all be identical.\nfunc TestError(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\n\tfuncs := []func(args ...any){\n\t\tError,\n\t\tfunc(args ...any) { ErrorContext(context.Background(), args) },\n\t}\n\n\tfor _, error := range funcs {\n\t\tsinks.file.resetBuffers()\n\t\terror(\"test\")\n\t\tif !contains(logsink.Error, \"E\", t) {\n\t\t\tt.Errorf(\"Error has wrong character: %q\", contents(logsink.Error))\n\t\t}\n\t\tif !contains(logsink.Error, \"test\", t) {\n\t\t\tt.Error(\"Error failed\")\n\t\t}\n\t\tstr := contents(logsink.Error)\n\t\tif !contains(logsink.Warning, str, t) {\n\t\t\tt.Error(\"Warning failed\")\n\t\t}\n\t\tif !contains(logsink.Info, str, t) {\n\t\t\tt.Error(\"Info failed\")\n\t\t}\n\t}\n}\n\n// Test that a Warning log goes to Info.\n// Even in the Info log, the source character will be W, so the data should\n// all be identical.\nfunc TestWarning(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\n\tfuncs := []func(args ...any){\n\t\tWarning,\n\t\tfunc(args ...any) { WarningContext(context.Background(), args) },\n\t}\n\n\tfor _, warning := range funcs {\n\t\tsinks.file.resetBuffers()\n\t\twarning(\"test\")\n\t\tif !contains(logsink.Warning, \"W\", t) {\n\t\t\tt.Errorf(\"Warning has wrong character: %q\", contents(logsink.Warning))\n\t\t}\n\t\tif !contains(logsink.Warning, \"test\", t) {\n\t\t\tt.Error(\"Warning failed\")\n\t\t}\n\t\tstr := contents(logsink.Warning)\n\t\tif !contains(logsink.Info, str, t) {\n\t\t\tt.Error(\"Info failed\")\n\t\t}\n\t}\n}\n\n// Test that a V log goes to Info.\nfunc TestV(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tif err := flag.Lookup(\"v\").Value.Set(\"2\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -v=2: %v\", err)\n\t}\n\tdefer flag.Lookup(\"v\").Value.Set(\"0\")\n\n\tfuncs := []func(args ...any){\n\t\tV(2).Info,\n\t\tfunc(args ...any) { V(2).InfoContext(context.Background(), args) },\n\t}\n\tfor _, info := range funcs {\n\t\tsinks.file.resetBuffers()\n\t\tinfo(\"test\")\n\t\tif !contains(logsink.Info, \"I\", t) {\n\t\t\tt.Errorf(\"Info has wrong character: %q\", contents(logsink.Info))\n\t\t}\n\t\tif !contains(logsink.Info, \"test\", t) {\n\t\t\tt.Error(\"Info failed\")\n\t\t}\n\t}\n}\n\n// Test that updating -v at runtime, while -vmodule is set to a non-empty\n// value, resets the modules cache correctly.\nfunc TestVFlagUpdates(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\t// Set -vmodule to some arbitrary value to make values read from cache.\n\t// See log_flags.go:/func .* enabled/.\n\tif err := flag.Lookup(\"vmodule\").Value.Set(\"non_existent_module=3\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -vmodule=log_test=3: %v\", err)\n\t}\n\tdefer flag.Lookup(\"vmodule\").Value.Set(\"\")\n\tif err := flag.Lookup(\"v\").Value.Set(\"3\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -v=3: %v\", err)\n\t}\n\tdefer flag.Lookup(\"v\").Value.Set(\"0\")\n\n\tif !V(2) {\n\t\tt.Error(\"V(2) not enabled for 2\")\n\t}\n\tif !V(3) {\n\t\tt.Error(\"V(3) not enabled for 3\")\n\t}\n\n\t// Setting a lower level should reset the modules cache.\n\tif err := flag.Lookup(\"v\").Value.Set(\"2\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -v=2: %v\", err)\n\t}\n\tif !V(2) {\n\t\tt.Error(\"V(2) not enabled for 2\")\n\t}\n\tif V(3) {\n\t\tt.Error(\"V(3) enabled for 3\")\n\t}\n}\n\n// Test that an arbitrary log.Level value does not modify -v.\nfunc TestLevel(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tif err := flag.Lookup(\"v\").Value.Set(\"3\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -v=3: %v\", err)\n\t}\n\tdefer flag.Lookup(\"v\").Value.Set(\"0\")\n\n\tvar l Level\n\tif got, want := l.String(), \"0\"; got != want {\n\t\tt.Errorf(\"l.String() = %q, want %q\", got, want)\n\t}\n\tif err := l.Set(\"2\"); err != nil {\n\t\tt.Fatalf(\"l.Set(2) failed: %v\", err)\n\t}\n\tif got, want := l.String(), \"2\"; got != want {\n\t\tt.Errorf(\"l.String() = %q, want %q\", got, want)\n\t}\n\t// -v flag should still be \"3\".\n\tif got, want := flag.Lookup(\"v\").Value.String(), \"3\"; got != want {\n\t\tt.Errorf(\"-v=%v, want %v\", got, want)\n\t}\n}\n\n// Test that a vmodule enables a log in this file.\nfunc TestVmoduleOn(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tif err := flag.Lookup(\"vmodule\").Value.Set(\"glog_test=2\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -vmodule=log_test=2: %v\", err)\n\t}\n\tdefer flag.Lookup(\"vmodule\").Value.Set(\"\")\n\n\tif !V(1) {\n\t\tt.Error(\"V not enabled for 1\")\n\t}\n\tif !V(2) {\n\t\tt.Error(\"V not enabled for 2\")\n\t}\n\tif V(3) {\n\t\tt.Error(\"V enabled for 3\")\n\t}\n\tV(2).Info(\"test\")\n\tif !contains(logsink.Info, \"I\", t) {\n\t\tt.Errorf(\"Info has wrong character: %q\", contents(logsink.Info))\n\t}\n\tif !contains(logsink.Info, \"test\", t) {\n\t\tt.Error(\"Info failed\")\n\t}\n}\n\n// Test that a VDepth calculates the depth correctly.\nfunc TestVDepth(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tif err := flag.Lookup(\"vmodule\").Value.Set(\"glog_test=3\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -vmodule=glog_test=3: %v\", err)\n\t}\n\tdefer flag.Lookup(\"vmodule\").Value.Set(\"\")\n\n\tif !V(3) {\n\t\tt.Error(\"V not enabled for 3\")\n\t}\n\tif !VDepth(0, 2) {\n\t\tt.Error(\"VDepth(0) not enabled for 2\")\n\t}\n\tif !VDepth(0, 3) {\n\t\tt.Error(\"VDepth(0) not enabled for 3\")\n\t}\n\tif VDepth(0, 4) {\n\t\tt.Error(\"VDepth(0) enabled for 4\")\n\t}\n\n\t// Since vmodule is set to glog_test=3, V(3) is true only for frames in\n\t// glog_test. runInAnotherModule's stack frame is in log_vmodule_test, whereas\n\t// this test and the provided closures are in glog_test. Therefore VDepth(0, 3)\n\t// and VDepth(2, 3) are true, while VDepth(1, 3) is false.\n\tif !runInAnotherModule(func() bool { return bool(VDepth(0, 3)) }) {\n\t\tt.Error(\"VDepth(0) in closure not enabled for 3\")\n\t}\n\tif runInAnotherModule(func() bool { return bool(VDepth(1, 3)) }) {\n\t\tt.Error(\"VDepth(1) in closure enabled for 3\")\n\t}\n\tif !runInAnotherModule(func() bool { return bool(VDepth(2, 3)) }) {\n\t\tt.Error(\"VDepth(2) in closure not enabled for 3\")\n\t}\n}\n\n// Test that a vmodule of another file does not enable a log in this file.\nfunc TestVmoduleOff(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tif err := flag.Lookup(\"vmodule\").Value.Set(\"notthisfile=2\"); err != nil {\n\t\tt.Fatalf(\"Failed to set -vmodule=notthisfile=2: %v\", err)\n\t}\n\tdefer flag.Lookup(\"vmodule\").Value.Set(\"\")\n\n\tfor i := 1; i <= 3; i++ {\n\t\tif V(Level(i)) {\n\t\t\tt.Errorf(\"V enabled for %d\", i)\n\t\t}\n\t}\n\tV(2).Info(\"test\")\n\tif contents(logsink.Info) != \"\" {\n\t\tt.Error(\"V logged incorrectly\")\n\t}\n}\n\n// vGlobs are patterns that match/don't match this file at V=2.\nvar vGlobs = map[string]bool{\n\t// Easy to test the numeric match here.\n\t\"glog_test=1\": false, // If -vmodule sets V to 1, V(2) will fail.\n\t\"glog_test=2\": true,\n\t\"glog_test=3\": true, // If -vmodule sets V to 1, V(3) will succeed.\n\t// These all use 2 and check the patterns. All are true.\n\t\"*=2\":           true,\n\t\"?l*=2\":         true,\n\t\"????_*=2\":      true,\n\t\"??[mno]?_*t=2\": true,\n\t// These all use 2 and check the patterns. All are false.\n\t\"*x=2\":         false,\n\t\"m*=2\":         false,\n\t\"??_*=2\":       false,\n\t\"?[abc]?_*t=2\": false,\n}\n\n// Test that vmodule globbing works as advertised.\nfunc testVmoduleGlob(pat string, match bool, t *testing.T) {\n\tt.Helper()\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tif err := flag.Lookup(\"vmodule\").Value.Set(pat); err != nil {\n\t\tt.Errorf(\"Failed to set -vmodule=%s: %v\", pat, err)\n\t}\n\tdefer flag.Lookup(\"vmodule\").Value.Set(\"\")\n\n\tif V(2) != Verbose(match) {\n\t\tt.Errorf(\"incorrect match for %q: got %t expected %t\", pat, V(2), match)\n\t}\n}\n\n// Test that a vmodule globbing works as advertised.\nfunc TestVmoduleGlob(t *testing.T) {\n\tfor glob, match := range vGlobs {\n\t\ttestVmoduleGlob(glob, match, t)\n\t}\n}\n\n// Test that a vmodule globbing on a full path works as advertised.\nfunc TestVmoduleFullGlob(t *testing.T) {\n\t_, file, _, _ := runtime.Caller(0)\n\tfor glob, match := range vGlobs {\n\t\ttestVmoduleGlob(filepath.Join(filepath.Dir(file), glob), match, t)\n\t}\n}\n\n// Test that a vmodule globbing across multiple directories works as advertised.\nfunc TestVmoduleFullGlobMultipleDirectories(t *testing.T) {\n\t// Note: only covering here what\n\t// TestVmoduleGlob does not.\n\t_, file, _, _ := runtime.Caller(0)\n\tdir := filepath.Dir(filepath.Dir(file))\n\ttestVmoduleGlob(filepath.Join(dir, \"*/glog_test=2\"), true, t)\n\ttestVmoduleGlob(filepath.Join(dir, \"*/glog_????=2\"), true, t)\n}\n\nfunc logAtVariousLevels() {\n\tV(3).Infof(\"level 3 message\")\n\tV(2).Infof(\"level 2 message\")\n\tV(1).Infof(\"level 1 message\")\n\tInfof(\"default level message\")\n}\n\nfunc TestRollover(t *testing.T) {\n\tsetFlags()\n\n\tInfo(\"x\") // Be sure we have a file.\n\tinfo, ok := sinks.file.file[logsink.Info].(*syncBuffer)\n\tif !ok {\n\t\tt.Fatal(\"info wasn't created\")\n\t}\n\n\t// Make sure the next log file gets a file name with a different\n\t// time stamp.\n\t//\n\t// TODO: determine whether we need to support subsecond log\n\t// rotation.  C++ does not appear to handle this case (nor does it\n\t// handle Daylight Savings Time properly).\n\ttime.Sleep(1 * time.Second)\n\n\t// Measure the current size of the log file.\n\tinfo.Flush()\n\tfi, err := info.file.Stat()\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to stat log file %s: %v\", info.file.Name(), err)\n\t}\n\n\t// Set MaxSize to a value that will accept one longMessage, but not two.\n\tlongMessage := strings.Repeat(\"x\", 1024)\n\tdefer func(previous uint64) { MaxSize = previous }(MaxSize)\n\tMaxSize = uint64(fi.Size()) + uint64(2*len(longMessage)) - 1\n\n\tfname0 := info.file.Name()\n\n\t// Force a rotation.\n\tInfo(longMessage)\n\tInfo(longMessage)\n\tinfo.Flush()\n\n\tfname1 := info.file.Name()\n\tif fname0 == fname1 {\n\t\tt.Errorf(\"info.f.Name did not change: %v\", fname0)\n\t}\n\tif info.nbytes >= MaxSize {\n\t\tt.Errorf(\"file size was not reset: %d\", info.nbytes)\n\t}\n\n\t// Check to see if the original file has the continued footer.\n\tf0, err := ioutil.ReadFile(fname0)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to read file %s: %v\", fname0, err)\n\t}\n\tif !bytes.HasSuffix(f0, []byte(footer)) {\n\t\tt.Errorf(\"%v: Missing footer %q\", fname0, footer)\n\t}\n\tfound := false\n\tfor _, l := range bytes.Split(f0, []byte(\"\\n\")) {\n\t\tvar file string\n\t\t_, err = fmt.Sscanf(string(l), \"Next log: %s\\n\", &file)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif file != fname1 {\n\t\t\tt.Errorf(\"%v: Wanted next filename %s, got %s\", fname0, fname1, file)\n\t\t}\n\t\tfound = true\n\t}\n\tif !found {\n\t\tt.Errorf(\"%v: Next log footer not found\", fname0)\n\t}\n\n\t// Check to see if the previous file header is there in the new file\n\tf1, err := ioutil.ReadFile(fname1)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to read file %s: %v\", fname1, err)\n\t}\n\tfound = false\n\tfor _, l := range bytes.Split(f1, []byte(\"\\n\")) {\n\t\tvar file string\n\t\t_, err = fmt.Sscanf(string(l), \"Previous log: %s\\n\", &file)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif file != fname0 {\n\t\t\tt.Errorf(\"%v: Wanted previous filename %s, got %s\", fname1, fname0, file)\n\t\t}\n\t\tfound = true\n\t}\n\tif !found {\n\t\tt.Errorf(\"%v: Previous log header not found\", fname1)\n\t}\n\n\t// Make sure Names returned the right names.\n\tn, err := Names(\"INFO\")\n\tif len(n) != 2 && err != nil && n[0] != fname0 && n[1] != fname1 {\n\t\tt.Errorf(\"Names(INFO) wanted [%s, %s]/nil, got %v/%v\", fname0, fname1, n, err)\n\t}\n\n\tif t.Failed() {\n\t\tt.Logf(\"%v:\\n%q\", fname0, f0)\n\t\tt.Logf(\"%v:\\n%q\", fname1, f1)\n\t}\n}\n\nfunc TestLogBacktraceAt(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\t// The peculiar style of this code simplifies line counting and maintenance of the\n\t// tracing block below.\n\tvar infoLine string\n\tsetTraceLocation := func(file string, line int, ok bool, delta int) {\n\t\tif !ok {\n\t\t\tt.Fatal(\"could not get file:line\")\n\t\t}\n\t\t_, file = filepath.Split(file)\n\t\tinfoLine = fmt.Sprintf(\"%s:%d\", file, line+delta)\n\t\terr := logBacktraceAt.Set(infoLine)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"error setting log_backtrace_at: \", err)\n\t\t}\n\t}\n\t{\n\t\t// Start of tracing block. These lines know about each other's relative position.\n\t\t_, file, line, ok := runtime.Caller(0)\n\t\tsetTraceLocation(file, line, ok, +2) // Two lines between Caller and Info calls.\n\t\tInfo(\"we want a stack trace here\")\n\t}\n\tnumAppearances := strings.Count(contents(logsink.Info), infoLine)\n\tif numAppearances < 2 {\n\t\t// Need 2 appearances, one in the log header and one in the trace:\n\t\t//   log_test.go:281: I0511 16:36:06.952398 02238 log_test.go:280] we want a stack trace here\n\t\t//   ...\n\t\t//   .../glog/glog_test.go:280 (0x41ba91)\n\t\t//   ...\n\t\t// We could be more precise but that would require knowing the details\n\t\t// of the traceback format, which may not be dependable.\n\t\tt.Fatal(\"got no trace back; log is \", contents(logsink.Info))\n\t}\n}\n\nfunc TestNewStandardLoggerLogBacktraceAt(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\ts := NewStandardLogger(\"INFO\")\n\t// The peculiar style of this code simplifies line counting and maintenance of the\n\t// tracing block below.\n\tvar infoLine string\n\tsetTraceLocation := func(file string, line int, ok bool, delta int) {\n\t\tif !ok {\n\t\t\tt.Fatal(\"could not get file:line\")\n\t\t}\n\t\t_, file = filepath.Split(file)\n\t\tinfoLine = fmt.Sprintf(\"%s:%d\", file, line+delta)\n\t\terr := logBacktraceAt.Set(infoLine)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"error setting log_backtrace_at: \", err)\n\t\t}\n\t}\n\t{\n\t\t// Start of tracing block. These lines know about each other's relative position.\n\t\t_, file, line, ok := runtime.Caller(0)\n\t\tsetTraceLocation(file, line, ok, +2) // Two lines between Caller and Info calls.\n\t\ts.Printf(\"we want a stack trace here\")\n\t}\n\tinfoContents := contents(logsink.Info)\n\tif strings.Contains(infoContents, infoLine+\"] [\") {\n\t\tt.Fatal(\"got extra bracketing around log line contents; log is \", infoContents)\n\t}\n\tnumAppearances := strings.Count(infoContents, infoLine)\n\tif numAppearances < 2 {\n\t\t// Need 2 appearances, one in the log header and one in the trace:\n\t\t//   log_test.go:281: I0511 16:36:06.952398 02238 log_test.go:280] we want a stack trace here\n\t\t//   ...\n\t\t//   .../glog/glog_test.go:280 (0x41ba91)\n\t\t//   ...\n\t\t// We could be more precise but that would require knowing the details\n\t\t// of the traceback format, which may not be dependable.\n\t\tt.Fatal(\"got no trace back; log is \", infoContents)\n\t}\n}\n\n// Test to make sure the log naming function works properly.\nfunc TestLogNames(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tn, e := Names(\"FOO\")\n\tif e == nil {\n\t\tt.Errorf(\"Names(FOO) was %v/nil, should be []/error\", n)\n\t}\n\n\t// Set the infoLog to nil to simulate \"log not yet written to\"\n\th := sinks.file.file[logsink.Info]\n\tsinks.file.file[logsink.Info] = nil\n\tn, e = Names(\"INFO\")\n\tif e != ErrNoLog {\n\t\tt.Errorf(\"Names(INFO) was %v/%v, should be [], ErrNoLog\", n, e)\n\t}\n\tsinks.file.file[logsink.Info] = h\n\n\t// Get the name; testing has a fixed fake name for these.\n\tInfo(\"test\")\n\tn, e = Names(\"INFO\")\n\tif len(n) != 1 && n[0] != \"<local name>\" {\n\t\tt.Errorf(\"Names(INFO) got %s, want <local name>\", n)\n\t}\n}\n\nfunc TestLogLength(t *testing.T) {\n\tsetFlags()\n\tdefer sinks.file.swap(sinks.file.newBuffers())\n\tInfo(strings.Repeat(\"X\", logsink.MaxLogMessageLen*2))\n\tif c := contents(logsink.Info); len(c) != logsink.MaxLogMessageLen {\n\t\tt.Errorf(\"Info was not truncated: got length %d, want %d, contents %q\",\n\t\t\tlen(c), logsink.MaxLogMessageLen, c)\n\t}\n}\n"
        },
        {
          "name": "glog_vmodule_test.go",
          "type": "blob",
          "size": 0.2578125,
          "content": "package glog\n\n// runInAnotherModule is a simple wrapper that, being defined in another file,\n// provides a different vmodule stack frame on the stack for use with\n// glog.*Depth testing.\n//\n//go:noinline\nfunc runInAnotherModule(f func() bool) bool {\n\treturn f()\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.08984375,
          "content": "module github.com/golang/glog\n\ngo 1.19\n\nrequire github.com/google/go-cmp v0.6.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1630859375,
          "content": "github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}