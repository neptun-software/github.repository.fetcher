{
  "metadata": {
    "timestamp": 1736567252883,
    "page": 851,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "v2ray/domain-list-community",
      "stars": 2366,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2018-2019 V2Ray\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.4873046875,
          "content": "# Move To https://github.com/v2fly/domain-list-community\n\n***\n\n# Domain list community\n\nThis project manages a list of domains, to be used as geosites for routing purpose in Project V.\n\n## Announcement\n\nDue to a lack of members capable of code review, this repository has been moved to [v2fly/domain-list-community](https://github.com/v2fly/domain-list-community). This also means that more contributors can have manager access to the new repository after a few successful PRs, which will make the project healthier and more active for good.\n\nFrom now on, this repo will only be used to release `dlc.dat`. Other matters (issues and pull requests) will be handled at the new repository.\n\n## Purpose of this project\n\nThis project is not opinionated. In other words, it does NOT endorse, claim or imply that a domain should be blocked or proxied. It can be used to generate routing rules on demand.\n\n## Download links\n\n- **dlc.dat**：[https://github.com/v2ray/domain-list-community/raw/release/dlc.dat](https://github.com/v2ray/domain-list-community/raw/release/dlc.dat)\n- **dlc.dat.sha256sum**：[https://github.com/v2ray/domain-list-community/raw/release/dlc.dat.sha256sum](https://github.com/v2ray/domain-list-community/raw/release/dlc.dat.sha256sum)\n\n## Usage example\n\nEach file in the `data` directory can be used as a rule in this format: `geosite:filename`.\n\n```json\n\"routing\": {\n  \"domainStrategy\": \"IPIfNonMatch\",\n  \"rules\": [\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Reject\",\n      \"domain\": [\n        \"geosite:category-ads-all\",\n        \"geosite:category-porn\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Direct\",\n      \"domain\": [\n        \"domain:icloud.com\",\n        \"domain:icloud-content.com\",\n        \"domain:cdn-apple.com\",\n        \"geosite:cn\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Proxy-1\",\n      \"domain\": [\n        \"geosite:category-anticensorship\",\n        \"geosite:category-media\",\n        \"geosite:category-vpnservices\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Proxy-2\",\n      \"domain\": [\n        \"geosite:category-dev\"\n      ]\n    },\n    {\n      \"type\": \"field\",\n      \"outboundTag\": \"Proxy-3\",\n      \"domain\": [\n        \"geosite:geolocation-!cn\"\n      ]\n    }\n  ]\n}\n```\n\n## Generate `dlc.dat` manually\n\n- Install `golang` and `git`\n- Download and install project code: `go get -u -v --insecure github.com/v2ray/domain-list-community`\n- Generate `dlc.dat` (without `datapath` option means to use `data` directory of this repository in `$GOPATH`):\n  - `$(go env GOPATH)/bin/domain-list-community`\n  - `$(go env GOPATH)/bin/domain-list-community --datapath=/path/to/your/custom/data/directory`\n\n## Structure of data\n\nAll data are under `data` directory. Each file in the directory represents a sub-list of domains, named by the file name. File content is in the following format.\n\n```\n# comments\ninclude:another-file\ndomain:google.com @attr1 @attr2\nkeyword:google\nregex:www\\.google\\.com\nfull:www.google.com\n```\n\n**Syntax:**\n\n* Comment begins with `#`. It may begin anywhere in the file. The content in the line after `#` is treated as comment and ignored in production.\n* Inclusion begins with `include:`, followed by the file name of an existing file in the same directory.\n* Subdomain begins with `domain:`, followed by a valid domain name. The prefix `domain:` may be omitted.\n* Keyword begins with `keyword:`, followed by a string.\n* Regular expression begins with `regex:`, followed by a valid regular expression (per Golang's standard).\n* Full domain begins with `full:`, followed by a complete and valid domain name.\n* Domains (including `domain`, `keyword`, `regex` and `full`) may have one or more attributes. Each attribute begins with `@` and followed by the name of the attribute.\n\n## How it works\n\nThe entire `data` directory will be built into an external `geosite` file for Project V. Each file in the directory represents a section in the generated file.\n\nTo generate a section:\n\n1. Remove all the comments in the file.\n2. Replace `include:` lines with the actual content of the file.\n3. Omit all empty lines.\n4. Generate each `domain:` line into a [sub-domain routing rule](https://github.com/v2ray/v2ray-core/blob/master/app/router/config.proto#L21).\n5. Generate each `keyword:` line into a [plain domain routing rule](https://github.com/v2ray/v2ray-core/blob/master/app/router/config.proto#L17).\n6. Generate each `regex:` line into a [regex domain routing rule](https://github.com/v2ray/v2ray-core/blob/master/app/router/config.proto#L19).\n7. Generate each `full:` line into a [full domain routing rule](https://github.com/v2ray/v2ray-core/blob/master/app/router/config.proto#L23).\n\n## How to organize domains\n\n### File name\n\nTheoretically any string can be used as the name, as long as it is a valid file name. In practice, we prefer names for determinic group of domains, such as the owner (usually a company name) of the domains, e.g., \"google\", \"netflix\". Names with unclear scope are generally unrecommended, such as \"evil\", or \"local\".\n\n### Attributes\n\nAttribute is useful for sub-group of domains, especially for filtering purpose. For example, the list of `google` domains may contains its main domains, as well as domains that serve ads. The ads domains may be marked by attribute `@ads`, and can be used as `geosite:google@ads` in V2Ray routing.\n\n## Contribution guideline\n\n* Please begin with small size PRs, say modification in a single file.\n* A PR must be reviewed and approved by another member.\n* After a few successful PRs, you may apply for manager access of this repository.\n"
        },
        {
          "name": "data",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 7.3251953125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/golang/protobuf/proto\"\n\t\"v2ray.com/core/app/router\"\n)\n\nvar (\n\tdataPath        = flag.String(\"datapath\", \"\", \"Path to your custom 'data' directory\")\n\tdefaultDataPath = filepath.Join(\"src\", \"github.com\", \"v2ray\", \"domain-list-community\", \"data\")\n)\n\ntype Entry struct {\n\tType  string\n\tValue string\n\tAttrs []*router.Domain_Attribute\n}\n\ntype List struct {\n\tName  string\n\tEntry []Entry\n}\n\ntype ParsedList struct {\n\tName      string\n\tInclusion map[string]bool\n\tEntry     []Entry\n}\n\nfunc (l *ParsedList) toProto() (*router.GeoSite, error) {\n\tsite := &router.GeoSite{\n\t\tCountryCode: l.Name,\n\t}\n\tfor _, entry := range l.Entry {\n\t\tswitch entry.Type {\n\t\tcase \"domain\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Domain,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tcase \"regexp\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Regex,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tcase \"keyword\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Plain,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tcase \"full\":\n\t\t\tsite.Domain = append(site.Domain, &router.Domain{\n\t\t\t\tType:      router.Domain_Full,\n\t\t\t\tValue:     entry.Value,\n\t\t\t\tAttribute: entry.Attrs,\n\t\t\t})\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"unknown domain type: \" + entry.Type)\n\t\t}\n\t}\n\treturn site, nil\n}\n\nfunc removeComment(line string) string {\n\tidx := strings.Index(line, \"#\")\n\tif idx == -1 {\n\t\treturn line\n\t}\n\treturn strings.TrimSpace(line[:idx])\n}\n\nfunc parseDomain(domain string, entry *Entry) error {\n\tkv := strings.Split(domain, \":\")\n\tif len(kv) == 1 {\n\t\tentry.Type = \"domain\"\n\t\tentry.Value = strings.ToLower(kv[0])\n\t\treturn nil\n\t}\n\n\tif len(kv) == 2 {\n\t\tentry.Type = strings.ToLower(kv[0])\n\t\tentry.Value = strings.ToLower(kv[1])\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"Invalid format: \" + domain)\n}\n\nfunc parseAttribute(attr string) (router.Domain_Attribute, error) {\n\tvar attribute router.Domain_Attribute\n\tif len(attr) == 0 || attr[0] != '@' {\n\t\treturn attribute, errors.New(\"invalid attribute: \" + attr)\n\t}\n\n\tattr = attr[0:]\n\tparts := strings.Split(attr, \"=\")\n\tif len(parts) == 1 {\n\t\tattribute.Key = strings.ToLower(parts[0])\n\t\tattribute.TypedValue = &router.Domain_Attribute_BoolValue{BoolValue: true}\n\t} else {\n\t\tattribute.Key = strings.ToLower(parts[0])\n\t\tintv, err := strconv.Atoi(parts[1])\n\t\tif err != nil {\n\t\t\treturn attribute, errors.New(\"invalid attribute: \" + attr + \": \" + err.Error())\n\t\t}\n\t\tattribute.TypedValue = &router.Domain_Attribute_IntValue{IntValue: int64(intv)}\n\t}\n\treturn attribute, nil\n}\n\nfunc parseEntry(line string) (Entry, error) {\n\tline = strings.TrimSpace(line)\n\tparts := strings.Split(line, \" \")\n\n\tvar entry Entry\n\tif len(parts) == 0 {\n\t\treturn entry, errors.New(\"empty entry\")\n\t}\n\n\tif err := parseDomain(parts[0], &entry); err != nil {\n\t\treturn entry, err\n\t}\n\n\tfor i := 1; i < len(parts); i++ {\n\t\tattr, err := parseAttribute(parts[i])\n\t\tif err != nil {\n\t\t\treturn entry, err\n\t\t}\n\t\tentry.Attrs = append(entry.Attrs, &attr)\n\t}\n\n\treturn entry, nil\n}\n\nfunc DetectPath(path string) (string, error) {\n\tarrPath := strings.Split(path, string(filepath.ListSeparator))\n\tfor _, content := range arrPath {\n\t\tfullPath := filepath.Join(content, defaultDataPath)\n\t\t_, err := os.Stat(fullPath)\n\t\tif err == nil || os.IsExist(err) {\n\t\t\treturn fullPath, nil\n\t\t}\n\t}\n\terr := fmt.Errorf(\"directory '%s' not found in '$GOPATH'\", defaultDataPath)\n\treturn \"\", err\n}\n\nfunc Load(path string) (*List, error) {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tlist := &List{\n\t\tName: strings.ToUpper(filepath.Base(path)),\n\t}\n\tscanner := bufio.NewScanner(file)\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tline = removeComment(line)\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tentry, err := parseEntry(line)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlist.Entry = append(list.Entry, entry)\n\t}\n\n\treturn list, nil\n}\n\nfunc ParseList(list *List, ref map[string]*List) (*ParsedList, error) {\n\tpl := &ParsedList{\n\t\tName:      list.Name,\n\t\tInclusion: make(map[string]bool),\n\t}\n\tentryList := list.Entry\n\tfor {\n\t\tnewEntryList := make([]Entry, 0, len(entryList))\n\t\thasInclude := false\n\t\tfor _, entry := range entryList {\n\t\t\tif entry.Type == \"include\" {\n\t\t\t\tif pl.Inclusion[entry.Value] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\trefName := strings.ToUpper(entry.Value)\n\t\t\t\tpl.Inclusion[refName] = true\n\t\t\t\tr := ref[refName]\n\t\t\t\tif r == nil {\n\t\t\t\t\treturn nil, errors.New(entry.Value + \" not found.\")\n\t\t\t\t}\n\t\t\t\tnewEntryList = append(newEntryList, r.Entry...)\n\t\t\t\thasInclude = true\n\t\t\t} else {\n\t\t\t\tnewEntryList = append(newEntryList, entry)\n\t\t\t}\n\t\t}\n\t\tentryList = newEntryList\n\t\tif !hasInclude {\n\t\t\tbreak\n\t\t}\n\t}\n\tpl.Entry = entryList\n\n\treturn pl, nil\n}\n\nfunc envFile() (string, error) {\n\tif file := os.Getenv(\"GOENV\"); file != \"\" {\n\t\tif file == \"off\" {\n\t\t\treturn \"\", fmt.Errorf(\"GOENV=off\")\n\t\t}\n\t\treturn file, nil\n\t}\n\tdir, err := os.UserConfigDir()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif dir == \"\" {\n\t\treturn \"\", fmt.Errorf(\"missing user-config dir\")\n\t}\n\treturn filepath.Join(dir, \"go\", \"env\"), nil\n}\n\nfunc getRuntimeEnv(key string) (string, error) {\n\tfile, err := envFile()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif file == \"\" {\n\t\treturn \"\", fmt.Errorf(\"missing runtime env file\")\n\t}\n\tvar data []byte\n\tvar runtimeEnv string\n\tdata, err = ioutil.ReadFile(file)\n\tenvStrings := strings.Split(string(data), \"\\n\")\n\tfor _, envItem := range envStrings {\n\t\tenvItem = strings.TrimSuffix(envItem, \"\\r\")\n\t\tenvKeyValue := strings.Split(envItem, \"=\")\n\t\tif strings.ToLower(envKeyValue[0]) == strings.ToLower(key) {\n\t\t\truntimeEnv = envKeyValue[1]\n\t\t}\n\t}\n\treturn runtimeEnv, nil\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tvar dir string\n\tvar err error\n\tif *dataPath != \"\" {\n\t\tdir = *dataPath\n\t} else {\n\t\tgoPath, envErr := getRuntimeEnv(\"GOPATH\")\n\t\tif envErr != nil {\n\t\t\tfmt.Println(\"Failed: please set '$GOPATH' manually, or use 'datapath' option to specify the path to your custom 'data' directory\")\n\t\t\treturn\n\t\t}\n\t\tif goPath == \"\" {\n\t\t\tgoPath = build.Default.GOPATH\n\t\t}\n\t\tfmt.Println(\"Use $GOPATH:\", goPath)\n\t\tfmt.Printf(\"Searching directory '%s' in '%s'...\\n\", defaultDataPath, goPath)\n\t\tdir, err = DetectPath(goPath)\n\t}\n\tif err != nil {\n\t\tfmt.Println(\"Failed: \", err)\n\t\treturn\n\t}\n\tfmt.Println(\"Use domain lists in\", dir)\n\n\tref := make(map[string]*List)\n\terr = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tlist, err := Load(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tref[list.Name] = list\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tfmt.Println(\"Failed: \", err)\n\t\treturn\n\t}\n\tprotoList := new(router.GeoSiteList)\n\tfor _, list := range ref {\n\t\tpl, err := ParseList(list, ref)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed: \", err)\n\t\t\treturn\n\t\t}\n\t\tsite, err := pl.toProto()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Failed: \", err)\n\t\t\treturn\n\t\t}\n\t\tprotoList.Entry = append(protoList.Entry, site)\n\t}\n\n\tprotoBytes, err := proto.Marshal(protoList)\n\tif err != nil {\n\t\tfmt.Println(\"Failed:\", err)\n\t\treturn\n\t}\n\tif err := ioutil.WriteFile(\"dlc.dat\", protoBytes, 0777); err != nil {\n\t\tfmt.Println(\"Failed: \", err)\n\t} else {\n\t\tfmt.Println(\"dlc.dat has been generated successfully in the directory. You can rename 'dlc.dat' to 'geosite.dat' and use it in V2Ray.\")\n\t}\n}\n"
        }
      ]
    }
  ]
}