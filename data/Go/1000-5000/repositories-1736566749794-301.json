{
  "metadata": {
    "timestamp": 1736566749794,
    "page": 301,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "XTLS/REALITY",
      "stars": 3703,
      "defaultBranch": "main",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.37890625,
          "content": "Copyright (c) 2023 RPRX. All rights reserved.\n\nMozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\n    means each individual or legal entity that creates, contributes to\n    the creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n    means the combination of the Contributions of others (if any) used\n    by a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n    means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n    means Source Code Form to which the initial Contributor has attached\n    the notice in Exhibit A, the Executable Form of such Source Code\n    Form, and Modifications of such Source Code Form, in each case\n    including portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n    means\n\n    (a) that the initial Contributor has attached the notice described\n        in Exhibit B to the Covered Software; or\n\n    (b) that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the\n        terms of a Secondary License.\n\n1.6. \"Executable Form\"\n    means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n    means a work that combines Covered Software with other material, in\n    a separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n    means this document.\n\n1.9. \"Licensable\"\n    means having the right to grant, to the maximum extent possible,\n    whether at the time of the initial grant or subsequently, any and\n    all of the rights conveyed by this License.\n\n1.10. \"Modifications\"\n    means any of the following:\n\n    (a) any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered\n        Software; or\n\n    (b) any new file in Source Code Form that contains any Covered\n        Software.\n\n1.11. \"Patent Claims\" of a Contributor\n    means any patent claim(s), including without limitation, method,\n    process, and apparatus claims, in any patent Licensable by such\n    Contributor that would be infringed, but for the grant of the\n    License, by the making, using, selling, offering for sale, having\n    made, import, or transfer of either its Contributions or its\n    Contributor Version.\n\n1.12. \"Secondary License\"\n    means either the GNU General Public License, Version 2.0, the GNU\n    Lesser General Public License, Version 2.1, the GNU Affero General\n    Public License, Version 3.0, or any later versions of those\n    licenses.\n\n1.13. \"Source Code Form\"\n    means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n    means an individual or a legal entity exercising rights under this\n    License. For legal entities, \"You\" includes any entity that\n    controls, is controlled by, or is under common control with You. For\n    purposes of this definition, \"control\" means (a) the power, direct\n    or indirect, to cause the direction or management of such entity,\n    whether by contract or otherwise, or (b) ownership of more than\n    fifty percent (50%) of the outstanding shares or beneficial\n    ownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\n    Licensable by such Contributor to use, reproduce, make available,\n    modify, display, perform, distribute, and otherwise exploit its\n    Contributions, either on an unmodified basis, with Modifications, or\n    as part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\n    for sale, have made, import, and otherwise transfer either its\n    Contributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\n    or\n\n(b) for infringements caused by: (i) Your and any other third party's\n    modifications of Covered Software, or (ii) the combination of its\n    Contributions with other software (except as part of its Contributor\n    Version); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\n    its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\n    Form, as described in Section 3.1, and You must inform recipients of\n    the Executable Form how they can obtain a copy of such Source Code\n    Form by reasonable means in a timely manner, at a charge no more\n    than the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\n    License, or sublicense it under different terms, provided that the\n    license for the Executable Form does not attempt to limit or alter\n    the recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n*                                                                      *\n*  6. Disclaimer of Warranty                                           *\n*  -------------------------                                           *\n*                                                                      *\n*  Covered Software is provided under this License on an \"as is\"       *\n*  basis, without warranty of any kind, either expressed, implied, or  *\n*  statutory, including, without limitation, warranties that the       *\n*  Covered Software is free of defects, merchantable, fit for a        *\n*  particular purpose or non-infringing. The entire risk as to the     *\n*  quality and performance of the Covered Software is with You.        *\n*  Should any Covered Software prove defective in any respect, You     *\n*  (not any Contributor) assume the cost of any necessary servicing,   *\n*  repair, or correction. This disclaimer of warranty constitutes an   *\n*  essential part of this License. No use of any Covered Software is   *\n*  authorized under this License except under this disclaimer.         *\n*                                                                      *\n************************************************************************\n\n************************************************************************\n*                                                                      *\n*  7. Limitation of Liability                                          *\n*  --------------------------                                          *\n*                                                                      *\n*  Under no circumstances and under no legal theory, whether tort      *\n*  (including negligence), contract, or otherwise, shall any           *\n*  Contributor, or anyone who distributes Covered Software as          *\n*  permitted above, be liable to You for any direct, indirect,         *\n*  special, incidental, or consequential damages of any character      *\n*  including, without limitation, damages for lost profits, loss of    *\n*  goodwill, work stoppage, computer failure or malfunction, or any    *\n*  and all other commercial damages or losses, even if such party      *\n*  shall have been informed of the possibility of such damages. This   *\n*  limitation of liability shall not apply to liability for death or   *\n*  personal injury resulting from such party's negligence to the       *\n*  extent applicable law prohibits such limitation. Some               *\n*  jurisdictions do not allow the exclusion or limitation of           *\n*  incidental or consequential damages, so this exclusion and          *\n*  limitation may not apply to You.                                    *\n*                                                                      *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\n  This Source Code Form is \"Incompatible With Secondary Licenses\", as\n  defined by the Mozilla Public License, v. 2.0.\n"
        },
        {
          "name": "LICENSE-Go",
          "type": "blob",
          "size": 1.4443359375,
          "content": "Copyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.en.md",
          "type": "blob",
          "size": 6.2314453125,
          "content": "# REALITY\n\n### THE NEXT FUTURE\n\nServer side implementation of REALITY protocol, a fork of package tls in latest [Go](https://github.com/golang/go/commits/master/src/crypto/tls).\nFor client side, please follow https://github.com/XTLS/Xray-core/blob/main/transport/internet/reality/reality.go.  \n\nTODO List: TODO\n\n## VLESS-XTLS-uTLS-REALITY example for [Xray-core](https://github.com/XTLS/Xray-core)\n\n[中文](README.md) | English\n\n```json5\n{\n    \"inbounds\": [ // Server Inbound Configuration\n        {\n            \"listen\": \"0.0.0.0\",\n            \"port\": 443,\n            \"protocol\": \"vless\",\n            \"settings\": {\n                \"clients\": [\n                    {\n                        \"id\": \"\", // Required, execute ./xray uuid to generate, or a string of 1-30 characters\n                        \"flow\": \"xtls-rprx-vision\" // Optional, if any, client must enable XTLS\n                    }\n                ],\n                \"decryption\": \"none\"\n            },\n            \"streamSettings\": {\n                \"network\": \"tcp\",\n                \"security\": \"reality\",\n                \"realitySettings\": {\n                    \"show\": false, // Optional, if true, output debugging information\n                    \"dest\": \"example.com:443\", // Required, the format is the same as the dest of VLESS fallbacks\n                    \"xver\": 0, // Optional, the format is the same as xver of VLESS fallbacks\n                    \"serverNames\": [ // Required, the acceptable serverName list, does not support * wildcards for now\n                        \"example.com\",\n                        \"www.example.com\"\n                    ],\n                    \"privateKey\": \"\", // Required, execute ./xray x25519 to generate\n                    \"minClientVer\": \"\", // Optional, minimum client Xray version, format is x.y.z\n                    \"maxClientVer\": \"\", // Optional, the highest version of client Xray, the format is x.y.z\n                    \"maxTimeDiff\": 0, // Optional, the maximum time difference allowed, in milliseconds\n                    \"shortIds\": [ // Required, the acceptable shortId list, which can be used to distinguish different clients\n                        \"\", // If there is this item, the client shortId can be empty\n                        \"0123456789abcdef\" // 0 to f, the length is a multiple of 2, the maximum length is 16\n                    ]\n                }\n            }\n        }\n    ]\n}\n```\n\nREALITY is intented to replace the use of TLS, it can **eliminate the detectable TLS fingerprint on the server side**, while still maintain the forward secrecy, etc. **Guard against the certificate chain attack, thus its security exceeds conventional TLS**\n**REALITY can point to other people's websites**, no need to buy domain names, configure TLS server, more convenient to deploy a proxy service. It **achieves full real TLS that is undistingwishable with the specified SNI to the middleman**\n  \nFor general proxy purposes, the minimum standard of the target website: **Websites out of China's GFW, support TLSv1.3 and H2, the domain name is not used for redirection** (the main domain name may be used to redirect to www)\nBonus points: target website IP reside closer to proxy IP (looks more reasonable, and lower latency), handshake messages after Server Hello are encrypted together (such as dl.google.com), OCSP Stapling\nConfiguration bonus items: **Block the proxy traffic back to China, TCP/80, UDP/443 are also forwarded to target** (REALITY behaves like port forwarding to the observer, the target IP may be better if it is an uncommon choice among REALITY users)\n\n**REALITY can also be used with proxy protocols other than XTLS**, but this is not recommended due to their obvious and already targeted TLS in TLS characteristics\nThe next main goal of REALITY is \"**pre-built mode**\", that is, to collect and build the characteristics of the target website in advance, and the next main goal of XTLS is **0-RTT**\n\n```json5\n{\n    \"outbounds\": [ // Client outbound configuration\n        {\n            \"protocol\": \"vless\",\n            \"settings\": {\n                \"vnext\": [\n                    {\n                        \"address\": \"\", // The domain name or IP of the server\n                        \"port\": 443,\n                        \"users\": [\n                            {\n                                \"id\": \"\", // consistent with the server\n                                \"flow\": \"xtls-rprx-vision\", // consistent with the server\n                                \"encryption\": \"none\"\n                            }\n                        ]\n                    }\n                ]\n            },\n            \"streamSettings\": {\n                \"network\": \"tcp\",\n                \"security\": \"reality\",\n                \"realitySettings\": {\n                    \"show\": false, // Optional, if true, output debugging information\n                    \"fingerprint\": \"chrome\", // Required, use uTLS library to emulate client TLS fingerprint\n                    \"serverName\": \"\", // One of the server serverNames\n                    \"publicKey\": \"\", // The public key corresponding to the private key of the server\n                    \"shortId\": \"\", // One of the server shortIds\n                    \"spiderX\": \"\" // The initial path and parameters of the crawler, recommended to be different for each client\n                }\n            }\n        }\n    ]\n}\n```\n\nThe REALITY client should receive the \"**Temporary Trusted Certificate**\" issued by \"**Temporary Authentication Key**\", but the real certificate of the target website will be received in the following three cases:\n\n1. The REALITY server rejects the Client Hello of the client, and the traffic is redirected to the target website\n2. The Client Hello of the client is redirected to the target website by the middleman\n3. Man-in-the-middle attack, it may be the help of the target website, or it may be a certificate chain attack\n\nThe REALITY client can perfectly distinguish temporary trusted certificates, real certificates, and invalid certificates, and decide the next action:\n\n1. When the temporary trusted certificate is received, the proxy connection is available and everything is business as usual\n2. When the real certificate is received, enter the crawler mode (spiderX)\n3. When an invalid certificate is received, TLS alert will be sent and the connection will be disconnected\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.3359375,
          "content": "# REALITY\n\n### THE NEXT FUTURE\n\nServer side implementation of REALITY protocol, a fork of package tls in latest [Go](https://github.com/golang/go/commits/master/src/crypto/tls).\nFor client side, please follow https://github.com/XTLS/Xray-core/blob/main/transport/internet/reality/reality.go.  \n\nTODO List: TODO\n\n## VLESS-XTLS-uTLS-REALITY example for [Xray-core](https://github.com/XTLS/Xray-core)\n\n中文 | [English](README.en.md)\n\n```json5\n{\n    \"inbounds\": [ // 服务端入站配置\n        {\n            \"listen\": \"0.0.0.0\",\n            \"port\": 443,\n            \"protocol\": \"vless\",\n            \"settings\": {\n                \"clients\": [\n                    {\n                        \"id\": \"\", // 必填，执行 ./xray uuid 生成，或 1-30 字节的字符串\n                        \"flow\": \"xtls-rprx-vision\" // 选填，若有，客户端必须启用 XTLS\n                    }\n                ],\n                \"decryption\": \"none\"\n            },\n            \"streamSettings\": {\n                \"network\": \"tcp\",\n                \"security\": \"reality\",\n                \"realitySettings\": {\n                    \"show\": false, // 选填，若为 true，输出调试信息\n                    \"dest\": \"example.com:443\", // 必填，格式同 VLESS fallbacks 的 dest\n                    \"xver\": 0, // 选填，格式同 VLESS fallbacks 的 xver\n                    \"serverNames\": [ // 必填，客户端可用的 serverName 列表，暂不支持 * 通配符\n                        \"example.com\",\n                        \"www.example.com\"\n                    ],\n                    \"privateKey\": \"\", // 必填，执行 ./xray x25519 生成\n                    \"minClientVer\": \"\", // 选填，客户端 Xray 最低版本，格式为 x.y.z\n                    \"maxClientVer\": \"\", // 选填，客户端 Xray 最高版本，格式为 x.y.z\n                    \"maxTimeDiff\": 0, // 选填，允许的最大时间差，单位为毫秒\n                    \"shortIds\": [ // 必填，客户端可用的 shortId 列表，可用于区分不同的客户端\n                        \"\", // 若有此项，客户端 shortId 可为空\n                        \"0123456789abcdef\" // 0 到 f，长度为 2 的倍数，长度上限为 16\n                    ]\n                }\n            }\n        }\n    ]\n}\n```\n\n若用 REALITY 取代 TLS，**可消除服务端 TLS 指纹特征**，仍有前向保密性等，**且证书链攻击无效，安全性超越常规 TLS**  \n**可以指向别人的网站**，无需自己买域名、配置 TLS 服务端，更方便，**实现向中间人呈现指定 SNI 的全程真实 TLS**  \n\n通常代理用途，目标网站最低标准：**国外网站，支持 TLSv1.3 与 H2，域名非跳转用**（主域名可能被用于跳转到 www）  \n加分项：IP 相近（更像，且延迟低），Server Hello 后的握手消息一起加密（如 dl.google.com），有 OCSP Stapling  \n配置加分项：**禁回国流量，TCP/80、UDP/443 也转发**（REALITY 对外表现即为端口转发，目标 IP 冷门或许更好）  \n\n**REALITY 也可以搭配 XTLS 以外的代理协议使用**，但不建议这样做，因为它们存在明显且已被针对的 TLS in TLS 特征  \nREALITY 的下一个主要目标是“**预先构建模式**”，即提前采集目标网站特征，XTLS 的下一个主要目标是 **0-RTT**  \n\n```json5\n{\n    \"outbounds\": [ // 客户端出站配置\n        {\n            \"protocol\": \"vless\",\n            \"settings\": {\n                \"vnext\": [\n                    {\n                        \"address\": \"\", // 服务端的域名或 IP\n                        \"port\": 443,\n                        \"users\": [\n                            {\n                                \"id\": \"\", // 与服务端一致\n                                \"flow\": \"xtls-rprx-vision\", // 与服务端一致\n                                \"encryption\": \"none\"\n                            }\n                        ]\n                    }\n                ]\n            },\n            \"streamSettings\": {\n                \"network\": \"tcp\",\n                \"security\": \"reality\",\n                \"realitySettings\": {\n                    \"show\": false, // 选填，若为 true，输出调试信息\n                    \"fingerprint\": \"chrome\", // 必填，使用 uTLS 库模拟客户端 TLS 指纹\n                    \"serverName\": \"\", // 服务端 serverNames 之一\n                    \"publicKey\": \"\", // 服务端私钥对应的公钥\n                    \"shortId\": \"\", // 服务端 shortIds 之一\n                    \"spiderX\": \"\" // 爬虫初始路径与参数，建议每个客户端不同\n                }\n            }\n        }\n    ]\n}\n```\n\nREALITY 客户端应当收到由“**临时认证密钥**”签发的“**临时可信证书**”，但以下三种情况会收到目标网站的真证书：\n\n1. REALITY 服务端拒绝了客户端的 Client Hello，流量被导入目标网站\n2. 客户端的 Client Hello 被中间人重定向至目标网站\n3. 中间人攻击，可能是目标网站帮忙，也可能是证书链攻击\n\nREALITY 客户端可以完美区分临时可信证书、真证书、无效证书，并决定下一步动作：\n\n1. 收到临时可信证书时，连接可用，一切如常\n2. 收到真证书时，进入爬虫模式\n3. 收到无效证书时，TLS alert，断开连接\n\n## Stargazers over time\n\n[![Stargazers over time](https://starchart.cc/XTLS/REALITY.svg)](https://starchart.cc/XTLS/REALITY)\n"
        },
        {
          "name": "alert.go",
          "type": "blob",
          "size": 4.3017578125,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport \"strconv\"\n\n// An AlertError is a TLS alert.\n//\n// When using a QUIC transport, QUICConn methods will return an error\n// which wraps AlertError rather than sending a TLS alert.\ntype AlertError uint8\n\nfunc (e AlertError) Error() string {\n\treturn alert(e).String()\n}\n\ntype alert uint8\n\nconst (\n\t// alert level\n\talertLevelWarning = 1\n\talertLevelError   = 2\n)\n\nconst (\n\talertCloseNotify                  alert = 0\n\talertUnexpectedMessage            alert = 10\n\talertBadRecordMAC                 alert = 20\n\talertDecryptionFailed             alert = 21\n\talertRecordOverflow               alert = 22\n\talertDecompressionFailure         alert = 30\n\talertHandshakeFailure             alert = 40\n\talertBadCertificate               alert = 42\n\talertUnsupportedCertificate       alert = 43\n\talertCertificateRevoked           alert = 44\n\talertCertificateExpired           alert = 45\n\talertCertificateUnknown           alert = 46\n\talertIllegalParameter             alert = 47\n\talertUnknownCA                    alert = 48\n\talertAccessDenied                 alert = 49\n\talertDecodeError                  alert = 50\n\talertDecryptError                 alert = 51\n\talertExportRestriction            alert = 60\n\talertProtocolVersion              alert = 70\n\talertInsufficientSecurity         alert = 71\n\talertInternalError                alert = 80\n\talertInappropriateFallback        alert = 86\n\talertUserCanceled                 alert = 90\n\talertNoRenegotiation              alert = 100\n\talertMissingExtension             alert = 109\n\talertUnsupportedExtension         alert = 110\n\talertCertificateUnobtainable      alert = 111\n\talertUnrecognizedName             alert = 112\n\talertBadCertificateStatusResponse alert = 113\n\talertBadCertificateHashValue      alert = 114\n\talertUnknownPSKIdentity           alert = 115\n\talertCertificateRequired          alert = 116\n\talertNoApplicationProtocol        alert = 120\n\talertECHRequired                  alert = 121\n)\n\nvar alertText = map[alert]string{\n\talertCloseNotify:                  \"close notify\",\n\talertUnexpectedMessage:            \"unexpected message\",\n\talertBadRecordMAC:                 \"bad record MAC\",\n\talertDecryptionFailed:             \"decryption failed\",\n\talertRecordOverflow:               \"record overflow\",\n\talertDecompressionFailure:         \"decompression failure\",\n\talertHandshakeFailure:             \"handshake failure\",\n\talertBadCertificate:               \"bad certificate\",\n\talertUnsupportedCertificate:       \"unsupported certificate\",\n\talertCertificateRevoked:           \"revoked certificate\",\n\talertCertificateExpired:           \"expired certificate\",\n\talertCertificateUnknown:           \"unknown certificate\",\n\talertIllegalParameter:             \"illegal parameter\",\n\talertUnknownCA:                    \"unknown certificate authority\",\n\talertAccessDenied:                 \"access denied\",\n\talertDecodeError:                  \"error decoding message\",\n\talertDecryptError:                 \"error decrypting message\",\n\talertExportRestriction:            \"export restriction\",\n\talertProtocolVersion:              \"protocol version not supported\",\n\talertInsufficientSecurity:         \"insufficient security level\",\n\talertInternalError:                \"internal error\",\n\talertInappropriateFallback:        \"inappropriate fallback\",\n\talertUserCanceled:                 \"user canceled\",\n\talertNoRenegotiation:              \"no renegotiation\",\n\talertMissingExtension:             \"missing extension\",\n\talertUnsupportedExtension:         \"unsupported extension\",\n\talertCertificateUnobtainable:      \"certificate unobtainable\",\n\talertUnrecognizedName:             \"unrecognized name\",\n\talertBadCertificateStatusResponse: \"bad certificate status response\",\n\talertBadCertificateHashValue:      \"bad certificate hash value\",\n\talertUnknownPSKIdentity:           \"unknown PSK identity\",\n\talertCertificateRequired:          \"certificate required\",\n\talertNoApplicationProtocol:        \"no application protocol\",\n\talertECHRequired:                  \"encrypted client hello required\",\n}\n\nfunc (e alert) String() string {\n\ts, ok := alertText[e]\n\tif ok {\n\t\treturn \"tls: \" + s\n\t}\n\treturn \"tls: alert(\" + strconv.Itoa(int(e)) + \")\"\n}\n\nfunc (e alert) Error() string {\n\treturn e.String()\n}\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 9.9912109375,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"bytes\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rsa\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n)\n\n// verifyHandshakeSignature verifies a signature against pre-hashed\n// (if required) handshake contents.\nfunc verifyHandshakeSignature(sigType uint8, pubkey crypto.PublicKey, hashFunc crypto.Hash, signed, sig []byte) error {\n\tswitch sigType {\n\tcase signatureECDSA:\n\t\tpubKey, ok := pubkey.(*ecdsa.PublicKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"expected an ECDSA public key, got %T\", pubkey)\n\t\t}\n\t\tif !ecdsa.VerifyASN1(pubKey, signed, sig) {\n\t\t\treturn errors.New(\"ECDSA verification failure\")\n\t\t}\n\tcase signatureEd25519:\n\t\tpubKey, ok := pubkey.(ed25519.PublicKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"expected an Ed25519 public key, got %T\", pubkey)\n\t\t}\n\t\tif !ed25519.Verify(pubKey, signed, sig) {\n\t\t\treturn errors.New(\"Ed25519 verification failure\")\n\t\t}\n\tcase signaturePKCS1v15:\n\t\tpubKey, ok := pubkey.(*rsa.PublicKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"expected an RSA public key, got %T\", pubkey)\n\t\t}\n\t\tif err := rsa.VerifyPKCS1v15(pubKey, hashFunc, signed, sig); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase signatureRSAPSS:\n\t\tpubKey, ok := pubkey.(*rsa.PublicKey)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"expected an RSA public key, got %T\", pubkey)\n\t\t}\n\t\tsignOpts := &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash}\n\t\tif err := rsa.VerifyPSS(pubKey, hashFunc, signed, sig, signOpts); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"internal error: unknown signature type\")\n\t}\n\treturn nil\n}\n\nconst (\n\tserverSignatureContext = \"TLS 1.3, server CertificateVerify\\x00\"\n\tclientSignatureContext = \"TLS 1.3, client CertificateVerify\\x00\"\n)\n\nvar signaturePadding = []byte{\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n}\n\n// signedMessage returns the pre-hashed (if necessary) message to be signed by\n// certificate keys in TLS 1.3. See RFC 8446, Section 4.4.3.\nfunc signedMessage(sigHash crypto.Hash, context string, transcript hash.Hash) []byte {\n\tif sigHash == directSigning {\n\t\tb := &bytes.Buffer{}\n\t\tb.Write(signaturePadding)\n\t\tio.WriteString(b, context)\n\t\tb.Write(transcript.Sum(nil))\n\t\treturn b.Bytes()\n\t}\n\th := sigHash.New()\n\th.Write(signaturePadding)\n\tio.WriteString(h, context)\n\th.Write(transcript.Sum(nil))\n\treturn h.Sum(nil)\n}\n\n// typeAndHashFromSignatureScheme returns the corresponding signature type and\n// crypto.Hash for a given TLS SignatureScheme.\nfunc typeAndHashFromSignatureScheme(signatureAlgorithm SignatureScheme) (sigType uint8, hash crypto.Hash, err error) {\n\tswitch signatureAlgorithm {\n\tcase PKCS1WithSHA1, PKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512:\n\t\tsigType = signaturePKCS1v15\n\tcase PSSWithSHA256, PSSWithSHA384, PSSWithSHA512:\n\t\tsigType = signatureRSAPSS\n\tcase ECDSAWithSHA1, ECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512:\n\t\tsigType = signatureECDSA\n\tcase Ed25519:\n\t\tsigType = signatureEd25519\n\tdefault:\n\t\treturn 0, 0, fmt.Errorf(\"unsupported signature algorithm: %v\", signatureAlgorithm)\n\t}\n\tswitch signatureAlgorithm {\n\tcase PKCS1WithSHA1, ECDSAWithSHA1:\n\t\thash = crypto.SHA1\n\tcase PKCS1WithSHA256, PSSWithSHA256, ECDSAWithP256AndSHA256:\n\t\thash = crypto.SHA256\n\tcase PKCS1WithSHA384, PSSWithSHA384, ECDSAWithP384AndSHA384:\n\t\thash = crypto.SHA384\n\tcase PKCS1WithSHA512, PSSWithSHA512, ECDSAWithP521AndSHA512:\n\t\thash = crypto.SHA512\n\tcase Ed25519:\n\t\thash = directSigning\n\tdefault:\n\t\treturn 0, 0, fmt.Errorf(\"unsupported signature algorithm: %v\", signatureAlgorithm)\n\t}\n\treturn sigType, hash, nil\n}\n\n// legacyTypeAndHashFromPublicKey returns the fixed signature type and crypto.Hash for\n// a given public key used with TLS 1.0 and 1.1, before the introduction of\n// signature algorithm negotiation.\nfunc legacyTypeAndHashFromPublicKey(pub crypto.PublicKey) (sigType uint8, hash crypto.Hash, err error) {\n\tswitch pub.(type) {\n\tcase *rsa.PublicKey:\n\t\treturn signaturePKCS1v15, crypto.MD5SHA1, nil\n\tcase *ecdsa.PublicKey:\n\t\treturn signatureECDSA, crypto.SHA1, nil\n\tcase ed25519.PublicKey:\n\t\t// RFC 8422 specifies support for Ed25519 in TLS 1.0 and 1.1,\n\t\t// but it requires holding on to a handshake transcript to do a\n\t\t// full signature, and not even OpenSSL bothers with the\n\t\t// complexity, so we can't even test it properly.\n\t\treturn 0, 0, fmt.Errorf(\"tls: Ed25519 public keys are not supported before TLS 1.2\")\n\tdefault:\n\t\treturn 0, 0, fmt.Errorf(\"tls: unsupported public key: %T\", pub)\n\t}\n}\n\nvar rsaSignatureSchemes = []struct {\n\tscheme          SignatureScheme\n\tminModulusBytes int\n\tmaxVersion      uint16\n}{\n\t// RSA-PSS is used with PSSSaltLengthEqualsHash, and requires\n\t//    emLen >= hLen + sLen + 2\n\t{PSSWithSHA256, crypto.SHA256.Size()*2 + 2, VersionTLS13},\n\t{PSSWithSHA384, crypto.SHA384.Size()*2 + 2, VersionTLS13},\n\t{PSSWithSHA512, crypto.SHA512.Size()*2 + 2, VersionTLS13},\n\t// PKCS #1 v1.5 uses prefixes from hashPrefixes in crypto/rsa, and requires\n\t//    emLen >= len(prefix) + hLen + 11\n\t// TLS 1.3 dropped support for PKCS #1 v1.5 in favor of RSA-PSS.\n\t{PKCS1WithSHA256, 19 + crypto.SHA256.Size() + 11, VersionTLS12},\n\t{PKCS1WithSHA384, 19 + crypto.SHA384.Size() + 11, VersionTLS12},\n\t{PKCS1WithSHA512, 19 + crypto.SHA512.Size() + 11, VersionTLS12},\n\t{PKCS1WithSHA1, 15 + crypto.SHA1.Size() + 11, VersionTLS12},\n}\n\n// signatureSchemesForCertificate returns the list of supported SignatureSchemes\n// for a given certificate, based on the public key and the protocol version,\n// and optionally filtered by its explicit SupportedSignatureAlgorithms.\n//\n// This function must be kept in sync with supportedSignatureAlgorithms.\n// FIPS filtering is applied in the caller, selectSignatureScheme.\nfunc signatureSchemesForCertificate(version uint16, cert *Certificate) []SignatureScheme {\n\tpriv, ok := cert.PrivateKey.(crypto.Signer)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tvar sigAlgs []SignatureScheme\n\tswitch pub := priv.Public().(type) {\n\tcase *ecdsa.PublicKey:\n\t\tif version != VersionTLS13 {\n\t\t\t// In TLS 1.2 and earlier, ECDSA algorithms are not\n\t\t\t// constrained to a single curve.\n\t\t\tsigAlgs = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256,\n\t\t\t\tECDSAWithP384AndSHA384,\n\t\t\t\tECDSAWithP521AndSHA512,\n\t\t\t\tECDSAWithSHA1,\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tswitch pub.Curve {\n\t\tcase elliptic.P256():\n\t\t\tsigAlgs = []SignatureScheme{ECDSAWithP256AndSHA256}\n\t\tcase elliptic.P384():\n\t\t\tsigAlgs = []SignatureScheme{ECDSAWithP384AndSHA384}\n\t\tcase elliptic.P521():\n\t\t\tsigAlgs = []SignatureScheme{ECDSAWithP521AndSHA512}\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\tcase *rsa.PublicKey:\n\t\tsize := pub.Size()\n\t\tsigAlgs = make([]SignatureScheme, 0, len(rsaSignatureSchemes))\n\t\tfor _, candidate := range rsaSignatureSchemes {\n\t\t\tif size >= candidate.minModulusBytes && version <= candidate.maxVersion {\n\t\t\t\tsigAlgs = append(sigAlgs, candidate.scheme)\n\t\t\t}\n\t\t}\n\tcase ed25519.PublicKey:\n\t\tsigAlgs = []SignatureScheme{Ed25519}\n\tdefault:\n\t\treturn nil\n\t}\n\n\tif cert.SupportedSignatureAlgorithms != nil {\n\t\tvar filteredSigAlgs []SignatureScheme\n\t\tfor _, sigAlg := range sigAlgs {\n\t\t\tif isSupportedSignatureAlgorithm(sigAlg, cert.SupportedSignatureAlgorithms) {\n\t\t\t\tfilteredSigAlgs = append(filteredSigAlgs, sigAlg)\n\t\t\t}\n\t\t}\n\t\treturn filteredSigAlgs\n\t}\n\treturn sigAlgs\n}\n\n// selectSignatureScheme picks a SignatureScheme from the peer's preference list\n// that works with the selected certificate. It's only called for protocol\n// versions that support signature algorithms, so TLS 1.2 and 1.3.\nfunc selectSignatureScheme(vers uint16, c *Certificate, peerAlgs []SignatureScheme) (SignatureScheme, error) {\n\tsupportedAlgs := signatureSchemesForCertificate(vers, c)\n\tif len(supportedAlgs) == 0 {\n\t\treturn 0, unsupportedCertificateError(c)\n\t}\n\tif len(peerAlgs) == 0 && vers == VersionTLS12 {\n\t\t// For TLS 1.2, if the client didn't send signature_algorithms then we\n\t\t// can assume that it supports SHA1. See RFC 5246, Section 7.4.1.4.1.\n\t\tpeerAlgs = []SignatureScheme{PKCS1WithSHA1, ECDSAWithSHA1}\n\t}\n\t// Pick signature scheme in the peer's preference order, as our\n\t// preference order is not configurable.\n\tfor _, preferredAlg := range peerAlgs {\n\t\tif needFIPS() && !isSupportedSignatureAlgorithm(preferredAlg, defaultSupportedSignatureAlgorithmsFIPS) {\n\t\t\tcontinue\n\t\t}\n\t\tif isSupportedSignatureAlgorithm(preferredAlg, supportedAlgs) {\n\t\t\treturn preferredAlg, nil\n\t\t}\n\t}\n\treturn 0, errors.New(\"tls: peer doesn't support any of the certificate's signature algorithms\")\n}\n\n// unsupportedCertificateError returns a helpful error for certificates with\n// an unsupported private key.\nfunc unsupportedCertificateError(cert *Certificate) error {\n\tswitch cert.PrivateKey.(type) {\n\tcase rsa.PrivateKey, ecdsa.PrivateKey:\n\t\treturn fmt.Errorf(\"tls: unsupported certificate: private key is %T, expected *%T\",\n\t\t\tcert.PrivateKey, cert.PrivateKey)\n\tcase *ed25519.PrivateKey:\n\t\treturn fmt.Errorf(\"tls: unsupported certificate: private key is *ed25519.PrivateKey, expected ed25519.PrivateKey\")\n\t}\n\n\tsigner, ok := cert.PrivateKey.(crypto.Signer)\n\tif !ok {\n\t\treturn fmt.Errorf(\"tls: certificate private key (%T) does not implement crypto.Signer\",\n\t\t\tcert.PrivateKey)\n\t}\n\n\tswitch pub := signer.Public().(type) {\n\tcase *ecdsa.PublicKey:\n\t\tswitch pub.Curve {\n\t\tcase elliptic.P256():\n\t\tcase elliptic.P384():\n\t\tcase elliptic.P521():\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"tls: unsupported certificate curve (%s)\", pub.Curve.Params().Name)\n\t\t}\n\tcase *rsa.PublicKey:\n\t\treturn fmt.Errorf(\"tls: certificate RSA key size too small for supported signature algorithms\")\n\tcase ed25519.PublicKey:\n\tdefault:\n\t\treturn fmt.Errorf(\"tls: unsupported certificate key (%T)\", pub)\n\t}\n\n\tif cert.SupportedSignatureAlgorithms != nil {\n\t\treturn fmt.Errorf(\"tls: peer doesn't support the certificate custom signature algorithms\")\n\t}\n\n\treturn fmt.Errorf(\"tls: internal error: unsupported key (%T)\", cert.PrivateKey)\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 3.435546875,
          "content": "// Copyright 2022 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"crypto/x509\"\n\t\"runtime\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype cacheEntry struct {\n\trefs atomic.Int64\n\tcert *x509.Certificate\n}\n\n// certCache implements an intern table for reference counted x509.Certificates,\n// implemented in a similar fashion to BoringSSL's CRYPTO_BUFFER_POOL. This\n// allows for a single x509.Certificate to be kept in memory and referenced from\n// multiple Conns. Returned references should not be mutated by callers. Certificates\n// are still safe to use after they are removed from the cache.\n//\n// Certificates are returned wrapped in an activeCert struct that should be held by\n// the caller. When references to the activeCert are freed, the number of references\n// to the certificate in the cache is decremented. Once the number of references\n// reaches zero, the entry is evicted from the cache.\n//\n// The main difference between this implementation and CRYPTO_BUFFER_POOL is that\n// CRYPTO_BUFFER_POOL is a more  generic structure which supports blobs of data,\n// rather than specific structures. Since we only care about x509.Certificates,\n// certCache is implemented as a specific cache, rather than a generic one.\n//\n// See https://boringssl.googlesource.com/boringssl/+/master/include/openssl/pool.h\n// and https://boringssl.googlesource.com/boringssl/+/master/crypto/pool/pool.c\n// for the BoringSSL reference.\ntype certCache struct {\n\tsync.Map\n}\n\nvar globalCertCache = new(certCache)\n\n// activeCert is a handle to a certificate held in the cache. Once there are\n// no alive activeCerts for a given certificate, the certificate is removed\n// from the cache by a finalizer.\ntype activeCert struct {\n\tcert *x509.Certificate\n}\n\n// active increments the number of references to the entry, wraps the\n// certificate in the entry in an activeCert, and sets the finalizer.\n//\n// Note that there is a race between active and the finalizer set on the\n// returned activeCert, triggered if active is called after the ref count is\n// decremented such that refs may be > 0 when evict is called. We consider this\n// safe, since the caller holding an activeCert for an entry that is no longer\n// in the cache is fine, with the only side effect being the memory overhead of\n// there being more than one distinct reference to a certificate alive at once.\nfunc (cc *certCache) active(e *cacheEntry) *activeCert {\n\te.refs.Add(1)\n\ta := &activeCert{e.cert}\n\truntime.SetFinalizer(a, func(_ *activeCert) {\n\t\tif e.refs.Add(-1) == 0 {\n\t\t\tcc.evict(e)\n\t\t}\n\t})\n\treturn a\n}\n\n// evict removes a cacheEntry from the cache.\nfunc (cc *certCache) evict(e *cacheEntry) {\n\tcc.Delete(string(e.cert.Raw))\n}\n\n// newCert returns a x509.Certificate parsed from der. If there is already a copy\n// of the certificate in the cache, a reference to the existing certificate will\n// be returned. Otherwise, a fresh certificate will be added to the cache, and\n// the reference returned. The returned reference should not be mutated.\nfunc (cc *certCache) newCert(der []byte) (*activeCert, error) {\n\tif entry, ok := cc.Load(string(der)); ok {\n\t\treturn cc.active(entry.(*cacheEntry)), nil\n\t}\n\n\tcert, err := x509.ParseCertificate(der)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tentry := &cacheEntry{cert: cert}\n\tif entry, loaded := cc.LoadOrStore(string(der), entry); loaded {\n\t\treturn cc.active(entry.(*cacheEntry)), nil\n\t}\n\treturn cc.active(entry), nil\n}\n"
        },
        {
          "name": "cipher_suites.go",
          "type": "blob",
          "size": 25.23046875,
          "content": "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"crypto\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/des\"\n\t\"crypto/hmac\"\n\t\"crypto/rc4\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"hash\"\n\t\"runtime\"\n\t_ \"unsafe\" // for linkname\n\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\t\"golang.org/x/sys/cpu\"\n)\n\n// CipherSuite is a TLS cipher suite. Note that most functions in this package\n// accept and expose cipher suite IDs instead of this type.\ntype CipherSuite struct {\n\tID   uint16\n\tName string\n\n\t// Supported versions is the list of TLS protocol versions that can\n\t// negotiate this cipher suite.\n\tSupportedVersions []uint16\n\n\t// Insecure is true if the cipher suite has known security issues\n\t// due to its primitives, design, or implementation.\n\tInsecure bool\n}\n\nvar (\n\tsupportedUpToTLS12 = []uint16{VersionTLS10, VersionTLS11, VersionTLS12}\n\tsupportedOnlyTLS12 = []uint16{VersionTLS12}\n\tsupportedOnlyTLS13 = []uint16{VersionTLS13}\n)\n\n// CipherSuites returns a list of cipher suites currently implemented by this\n// package, excluding those with security issues, which are returned by\n// [InsecureCipherSuites].\n//\n// The list is sorted by ID. Note that the default cipher suites selected by\n// this package might depend on logic that can't be captured by a static list,\n// and might not match those returned by this function.\nfunc CipherSuites() []*CipherSuite {\n\treturn []*CipherSuite{\n\t\t{TLS_AES_128_GCM_SHA256, \"TLS_AES_128_GCM_SHA256\", supportedOnlyTLS13, false},\n\t\t{TLS_AES_256_GCM_SHA384, \"TLS_AES_256_GCM_SHA384\", supportedOnlyTLS13, false},\n\t\t{TLS_CHACHA20_POLY1305_SHA256, \"TLS_CHACHA20_POLY1305_SHA256\", supportedOnlyTLS13, false},\n\n\t\t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\", supportedUpToTLS12, false},\n\t\t{TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, \"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\", supportedUpToTLS12, false},\n\t\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\", supportedUpToTLS12, false},\n\t\t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, \"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\", supportedUpToTLS12, false},\n\t\t{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\", supportedOnlyTLS12, false},\n\t\t{TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\", supportedOnlyTLS12, false},\n\t\t{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", supportedOnlyTLS12, false},\n\t\t{TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\", supportedOnlyTLS12, false},\n\t\t{TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", supportedOnlyTLS12, false},\n\t\t{TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\", supportedOnlyTLS12, false},\n\t}\n}\n\n// InsecureCipherSuites returns a list of cipher suites currently implemented by\n// this package and which have security issues.\n//\n// Most applications should not use the cipher suites in this list, and should\n// only use those returned by [CipherSuites].\nfunc InsecureCipherSuites() []*CipherSuite {\n\t// This list includes RC4, CBC_SHA256, and 3DES cipher suites. See\n\t// cipherSuitesPreferenceOrder for details.\n\treturn []*CipherSuite{\n\t\t{TLS_RSA_WITH_RC4_128_SHA, \"TLS_RSA_WITH_RC4_128_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_RSA_WITH_AES_128_CBC_SHA, \"TLS_RSA_WITH_AES_128_CBC_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_RSA_WITH_AES_256_CBC_SHA, \"TLS_RSA_WITH_AES_256_CBC_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_RSA_WITH_AES_128_CBC_SHA256, \"TLS_RSA_WITH_AES_128_CBC_SHA256\", supportedOnlyTLS12, true},\n\t\t{TLS_RSA_WITH_AES_128_GCM_SHA256, \"TLS_RSA_WITH_AES_128_GCM_SHA256\", supportedOnlyTLS12, true},\n\t\t{TLS_RSA_WITH_AES_256_GCM_SHA384, \"TLS_RSA_WITH_AES_256_GCM_SHA384\", supportedOnlyTLS12, true},\n\t\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, \"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, \"TLS_ECDHE_RSA_WITH_RC4_128_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, \"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA\", supportedUpToTLS12, true},\n\t\t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, \"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\", supportedOnlyTLS12, true},\n\t\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, \"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\", supportedOnlyTLS12, true},\n\t}\n}\n\n// CipherSuiteName returns the standard name for the passed cipher suite ID\n// (e.g. \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"), or a fallback representation\n// of the ID value if the cipher suite is not implemented by this package.\nfunc CipherSuiteName(id uint16) string {\n\tfor _, c := range CipherSuites() {\n\t\tif c.ID == id {\n\t\t\treturn c.Name\n\t\t}\n\t}\n\tfor _, c := range InsecureCipherSuites() {\n\t\tif c.ID == id {\n\t\t\treturn c.Name\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"0x%04X\", id)\n}\n\nconst (\n\t// suiteECDHE indicates that the cipher suite involves elliptic curve\n\t// Diffie-Hellman. This means that it should only be selected when the\n\t// client indicates that it supports ECC with a curve and point format\n\t// that we're happy with.\n\tsuiteECDHE = 1 << iota\n\t// suiteECSign indicates that the cipher suite involves an ECDSA or\n\t// EdDSA signature and therefore may only be selected when the server's\n\t// certificate is ECDSA or EdDSA. If this is not set then the cipher suite\n\t// is RSA based.\n\tsuiteECSign\n\t// suiteTLS12 indicates that the cipher suite should only be advertised\n\t// and accepted when using TLS 1.2.\n\tsuiteTLS12\n\t// suiteSHA384 indicates that the cipher suite uses SHA384 as the\n\t// handshake hash.\n\tsuiteSHA384\n)\n\n// A cipherSuite is a TLS 1.0–1.2 cipher suite, and defines the key exchange\n// mechanism, as well as the cipher+MAC pair or the AEAD.\ntype cipherSuite struct {\n\tid uint16\n\t// the lengths, in bytes, of the key material needed for each component.\n\tkeyLen int\n\tmacLen int\n\tivLen  int\n\tka     func(version uint16) keyAgreement\n\t// flags is a bitmask of the suite* values, above.\n\tflags  int\n\tcipher func(key, iv []byte, isRead bool) any\n\tmac    func(key []byte) hash.Hash\n\taead   func(key, fixedNonce []byte) aead\n}\n\nvar cipherSuites = []*cipherSuite{ // TODO: replace with a map, since the order doesn't matter.\n\t{TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, 32, 0, 12, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadChaCha20Poly1305},\n\t{TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, 32, 0, 12, ecdheECDSAKA, suiteECDHE | suiteECSign | suiteTLS12, nil, nil, aeadChaCha20Poly1305},\n\t{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12, nil, nil, aeadAESGCM},\n\t{TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECSign | suiteTLS12, nil, nil, aeadAESGCM},\n\t{TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheRSAKA, suiteECDHE | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n\t{TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, ecdheECDSAKA, suiteECDHE | suiteECSign | suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, 16, 32, 16, ecdheRSAKA, suiteECDHE | suiteTLS12, cipherAES, macSHA256, nil},\n\t{TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n\t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, 16, 32, 16, ecdheECDSAKA, suiteECDHE | suiteECSign | suiteTLS12, cipherAES, macSHA256, nil},\n\t{TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, 16, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECSign, cipherAES, macSHA1, nil},\n\t{TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheRSAKA, suiteECDHE, cipherAES, macSHA1, nil},\n\t{TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, 32, 20, 16, ecdheECDSAKA, suiteECDHE | suiteECSign, cipherAES, macSHA1, nil},\n\t{TLS_RSA_WITH_AES_128_GCM_SHA256, 16, 0, 4, rsaKA, suiteTLS12, nil, nil, aeadAESGCM},\n\t{TLS_RSA_WITH_AES_256_GCM_SHA384, 32, 0, 4, rsaKA, suiteTLS12 | suiteSHA384, nil, nil, aeadAESGCM},\n\t{TLS_RSA_WITH_AES_128_CBC_SHA256, 16, 32, 16, rsaKA, suiteTLS12, cipherAES, macSHA256, nil},\n\t{TLS_RSA_WITH_AES_128_CBC_SHA, 16, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n\t{TLS_RSA_WITH_AES_256_CBC_SHA, 32, 20, 16, rsaKA, 0, cipherAES, macSHA1, nil},\n\t{TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, ecdheRSAKA, suiteECDHE, cipher3DES, macSHA1, nil},\n\t{TLS_RSA_WITH_3DES_EDE_CBC_SHA, 24, 20, 8, rsaKA, 0, cipher3DES, macSHA1, nil},\n\t{TLS_RSA_WITH_RC4_128_SHA, 16, 20, 0, rsaKA, 0, cipherRC4, macSHA1, nil},\n\t{TLS_ECDHE_RSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheRSAKA, suiteECDHE, cipherRC4, macSHA1, nil},\n\t{TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, 16, 20, 0, ecdheECDSAKA, suiteECDHE | suiteECSign, cipherRC4, macSHA1, nil},\n}\n\n// selectCipherSuite returns the first TLS 1.0–1.2 cipher suite from ids which\n// is also in supportedIDs and passes the ok filter.\nfunc selectCipherSuite(ids, supportedIDs []uint16, ok func(*cipherSuite) bool) *cipherSuite {\n\tfor _, id := range ids {\n\t\tcandidate := cipherSuiteByID(id)\n\t\tif candidate == nil || !ok(candidate) {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, suppID := range supportedIDs {\n\t\t\tif id == suppID {\n\t\t\t\treturn candidate\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// A cipherSuiteTLS13 defines only the pair of the AEAD algorithm and hash\n// algorithm to be used with HKDF. See RFC 8446, Appendix B.4.\ntype cipherSuiteTLS13 struct {\n\tid     uint16\n\tkeyLen int\n\taead   func(key, fixedNonce []byte) aead\n\thash   crypto.Hash\n}\n\n// cipherSuitesTLS13 should be an internal detail,\n// but widely used packages access it using linkname.\n// Notable members of the hall of shame include:\n//   - github.com/quic-go/quic-go\n//   - github.com/sagernet/quic-go\n//\n// Do not remove or change the type signature.\n// See go.dev/issue/67401.\n//\n//go:linkname cipherSuitesTLS13\nvar cipherSuitesTLS13 = []*cipherSuiteTLS13{ // TODO: replace with a map.\n\t{TLS_AES_128_GCM_SHA256, 16, aeadAESGCMTLS13, crypto.SHA256},\n\t{TLS_CHACHA20_POLY1305_SHA256, 32, aeadChaCha20Poly1305, crypto.SHA256},\n\t{TLS_AES_256_GCM_SHA384, 32, aeadAESGCMTLS13, crypto.SHA384},\n}\n\n// cipherSuitesPreferenceOrder is the order in which we'll select (on the\n// server) or advertise (on the client) TLS 1.0–1.2 cipher suites.\n//\n// Cipher suites are filtered but not reordered based on the application and\n// peer's preferences, meaning we'll never select a suite lower in this list if\n// any higher one is available. This makes it more defensible to keep weaker\n// cipher suites enabled, especially on the server side where we get the last\n// word, since there are no known downgrade attacks on cipher suites selection.\n//\n// The list is sorted by applying the following priority rules, stopping at the\n// first (most important) applicable one:\n//\n//   - Anything else comes before RC4\n//\n//     RC4 has practically exploitable biases. See https://www.rc4nomore.com.\n//\n//   - Anything else comes before CBC_SHA256\n//\n//     SHA-256 variants of the CBC ciphersuites don't implement any Lucky13\n//     countermeasures. See http://www.isg.rhul.ac.uk/tls/Lucky13.html and\n//     https://www.imperialviolet.org/2013/02/04/luckythirteen.html.\n//\n//   - Anything else comes before 3DES\n//\n//     3DES has 64-bit blocks, which makes it fundamentally susceptible to\n//     birthday attacks. See https://sweet32.info.\n//\n//   - ECDHE comes before anything else\n//\n//     Once we got the broken stuff out of the way, the most important\n//     property a cipher suite can have is forward secrecy. We don't\n//     implement FFDHE, so that means ECDHE.\n//\n//   - AEADs come before CBC ciphers\n//\n//     Even with Lucky13 countermeasures, MAC-then-Encrypt CBC cipher suites\n//     are fundamentally fragile, and suffered from an endless sequence of\n//     padding oracle attacks. See https://eprint.iacr.org/2015/1129,\n//     https://www.imperialviolet.org/2014/12/08/poodleagain.html, and\n//     https://blog.cloudflare.com/yet-another-padding-oracle-in-openssl-cbc-ciphersuites/.\n//\n//   - AES comes before ChaCha20\n//\n//     When AES hardware is available, AES-128-GCM and AES-256-GCM are faster\n//     than ChaCha20Poly1305.\n//\n//     When AES hardware is not available, AES-128-GCM is one or more of: much\n//     slower, way more complex, and less safe (because not constant time)\n//     than ChaCha20Poly1305.\n//\n//     We use this list if we think both peers have AES hardware, and\n//     cipherSuitesPreferenceOrderNoAES otherwise.\n//\n//   - AES-128 comes before AES-256\n//\n//     The only potential advantages of AES-256 are better multi-target\n//     margins, and hypothetical post-quantum properties. Neither apply to\n//     TLS, and AES-256 is slower due to its four extra rounds (which don't\n//     contribute to the advantages above).\n//\n//   - ECDSA comes before RSA\n//\n//     The relative order of ECDSA and RSA cipher suites doesn't matter,\n//     as they depend on the certificate. Pick one to get a stable order.\nvar cipherSuitesPreferenceOrder = []uint16{\n\t// AEADs w/ ECDHE\n\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\n\t// CBC w/ ECDHE\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,\n\tTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,\n\n\t// AEADs w/o ECDHE\n\tTLS_RSA_WITH_AES_128_GCM_SHA256,\n\tTLS_RSA_WITH_AES_256_GCM_SHA384,\n\n\t// CBC w/o ECDHE\n\tTLS_RSA_WITH_AES_128_CBC_SHA,\n\tTLS_RSA_WITH_AES_256_CBC_SHA,\n\n\t// 3DES\n\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,\n\tTLS_RSA_WITH_3DES_EDE_CBC_SHA,\n\n\t// CBC_SHA256\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,\n\tTLS_RSA_WITH_AES_128_CBC_SHA256,\n\n\t// RC4\n\tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA,\n\tTLS_RSA_WITH_RC4_128_SHA,\n}\n\nvar cipherSuitesPreferenceOrderNoAES = []uint16{\n\t// ChaCha20Poly1305\n\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\n\t// AES-GCM w/ ECDHE\n\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\n\t// The rest of cipherSuitesPreferenceOrder.\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,\n\tTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,\n\tTLS_RSA_WITH_AES_128_GCM_SHA256,\n\tTLS_RSA_WITH_AES_256_GCM_SHA384,\n\tTLS_RSA_WITH_AES_128_CBC_SHA,\n\tTLS_RSA_WITH_AES_256_CBC_SHA,\n\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,\n\tTLS_RSA_WITH_3DES_EDE_CBC_SHA,\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,\n\tTLS_RSA_WITH_AES_128_CBC_SHA256,\n\tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_RC4_128_SHA,\n\tTLS_RSA_WITH_RC4_128_SHA,\n}\n\n// disabledCipherSuites are not used unless explicitly listed in Config.CipherSuites.\nvar disabledCipherSuites = map[uint16]bool{\n\t// CBC_SHA256\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: true,\n\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:   true,\n\tTLS_RSA_WITH_AES_128_CBC_SHA256:         true,\n\n\t// RC4\n\tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA: true,\n\tTLS_ECDHE_RSA_WITH_RC4_128_SHA:   true,\n\tTLS_RSA_WITH_RC4_128_SHA:         true,\n}\n\n// rsaKexCiphers contains the ciphers which use RSA based key exchange,\n// which we also disable by default unless a GODEBUG is set.\nvar rsaKexCiphers = map[uint16]bool{\n\tTLS_RSA_WITH_RC4_128_SHA:        true,\n\tTLS_RSA_WITH_3DES_EDE_CBC_SHA:   true,\n\tTLS_RSA_WITH_AES_128_CBC_SHA:    true,\n\tTLS_RSA_WITH_AES_256_CBC_SHA:    true,\n\tTLS_RSA_WITH_AES_128_CBC_SHA256: true,\n\tTLS_RSA_WITH_AES_128_GCM_SHA256: true,\n\tTLS_RSA_WITH_AES_256_GCM_SHA384: true,\n}\n\n// tdesCiphers contains 3DES ciphers,\n// which we also disable by default unless a GODEBUG is set.\nvar tdesCiphers = map[uint16]bool{\n\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: true,\n\tTLS_RSA_WITH_3DES_EDE_CBC_SHA:       true,\n}\n\nvar (\n\thasGCMAsmAMD64 = cpu.X86.HasAES && cpu.X86.HasPCLMULQDQ\n\thasGCMAsmARM64 = cpu.ARM64.HasAES && cpu.ARM64.HasPMULL\n\t// Keep in sync with crypto/aes/cipher_s390x.go.\n\thasGCMAsmS390X = cpu.S390X.HasAES && cpu.S390X.HasAESCBC && cpu.S390X.HasAESCTR &&\n\t\t(cpu.S390X.HasGHASH || cpu.S390X.HasAESGCM)\n\n\thasAESGCMHardwareSupport = runtime.GOARCH == \"amd64\" && hasGCMAsmAMD64 ||\n\t\truntime.GOARCH == \"arm64\" && hasGCMAsmARM64 ||\n\t\truntime.GOARCH == \"s390x\" && hasGCMAsmS390X\n)\n\nvar aesgcmCiphers = map[uint16]bool{\n\t// TLS 1.2\n\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:   true,\n\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:   true,\n\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: true,\n\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: true,\n\t// TLS 1.3\n\tTLS_AES_128_GCM_SHA256: true,\n\tTLS_AES_256_GCM_SHA384: true,\n}\n\n// aesgcmPreferred returns whether the first known cipher in the preference list\n// is an AES-GCM cipher, implying the peer has hardware support for it.\nfunc aesgcmPreferred(ciphers []uint16) bool {\n\tfor _, cID := range ciphers {\n\t\tif c := cipherSuiteByID(cID); c != nil {\n\t\t\treturn aesgcmCiphers[cID]\n\t\t}\n\t\tif c := cipherSuiteTLS13ByID(cID); c != nil {\n\t\t\treturn aesgcmCiphers[cID]\n\t\t}\n\t}\n\treturn false\n}\n\nfunc cipherRC4(key, iv []byte, isRead bool) any {\n\tcipher, _ := rc4.NewCipher(key)\n\treturn cipher\n}\n\nfunc cipher3DES(key, iv []byte, isRead bool) any {\n\tblock, _ := des.NewTripleDESCipher(key)\n\tif isRead {\n\t\treturn cipher.NewCBCDecrypter(block, iv)\n\t}\n\treturn cipher.NewCBCEncrypter(block, iv)\n}\n\nfunc cipherAES(key, iv []byte, isRead bool) any {\n\tblock, _ := aes.NewCipher(key)\n\tif isRead {\n\t\treturn cipher.NewCBCDecrypter(block, iv)\n\t}\n\treturn cipher.NewCBCEncrypter(block, iv)\n}\n\n// macSHA1 returns a SHA-1 based constant time MAC.\nfunc macSHA1(key []byte) hash.Hash {\n\treturn hmac.New(sha1.New, key)\n}\n\n// macSHA256 returns a SHA-256 based MAC. This is only supported in TLS 1.2 and\n// is currently only used in disabled-by-default cipher suites.\nfunc macSHA256(key []byte) hash.Hash {\n\treturn hmac.New(sha256.New, key)\n}\n\ntype aead interface {\n\tcipher.AEAD\n\n\t// explicitNonceLen returns the number of bytes of explicit nonce\n\t// included in each record. This is eight for older AEADs and\n\t// zero for modern ones.\n\texplicitNonceLen() int\n}\n\nconst (\n\taeadNonceLength   = 12\n\tnoncePrefixLength = 4\n)\n\n// prefixNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to\n// each call.\ntype prefixNonceAEAD struct {\n\t// nonce contains the fixed part of the nonce in the first four bytes.\n\tnonce [aeadNonceLength]byte\n\taead  cipher.AEAD\n}\n\nfunc (f *prefixNonceAEAD) NonceSize() int        { return aeadNonceLength - noncePrefixLength }\nfunc (f *prefixNonceAEAD) Overhead() int         { return f.aead.Overhead() }\nfunc (f *prefixNonceAEAD) explicitNonceLen() int { return f.NonceSize() }\n\nfunc (f *prefixNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte {\n\tcopy(f.nonce[4:], nonce)\n\treturn f.aead.Seal(out, f.nonce[:], plaintext, additionalData)\n}\n\nfunc (f *prefixNonceAEAD) Open(out, nonce, ciphertext, additionalData []byte) ([]byte, error) {\n\tcopy(f.nonce[4:], nonce)\n\treturn f.aead.Open(out, f.nonce[:], ciphertext, additionalData)\n}\n\n// xorNonceAEAD wraps an AEAD by XORing in a fixed pattern to the nonce\n// before each call.\ntype xorNonceAEAD struct {\n\tnonceMask [aeadNonceLength]byte\n\taead      cipher.AEAD\n}\n\nfunc (f *xorNonceAEAD) NonceSize() int        { return 8 } // 64-bit sequence number\nfunc (f *xorNonceAEAD) Overhead() int         { return f.aead.Overhead() }\nfunc (f *xorNonceAEAD) explicitNonceLen() int { return 0 }\n\nfunc (f *xorNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte {\n\tfor i, b := range nonce {\n\t\tf.nonceMask[4+i] ^= b\n\t}\n\tresult := f.aead.Seal(out, f.nonceMask[:], plaintext, additionalData)\n\tfor i, b := range nonce {\n\t\tf.nonceMask[4+i] ^= b\n\t}\n\n\treturn result\n}\n\nfunc (f *xorNonceAEAD) Open(out, nonce, ciphertext, additionalData []byte) ([]byte, error) {\n\tfor i, b := range nonce {\n\t\tf.nonceMask[4+i] ^= b\n\t}\n\tresult, err := f.aead.Open(out, f.nonceMask[:], ciphertext, additionalData)\n\tfor i, b := range nonce {\n\t\tf.nonceMask[4+i] ^= b\n\t}\n\n\treturn result, err\n}\n\nfunc aeadAESGCM(key, noncePrefix []byte) aead {\n\tif len(noncePrefix) != noncePrefixLength {\n\t\tpanic(\"tls: internal error: wrong nonce length\")\n\t}\n\taes, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\taead, err := cipher.NewGCM(aes)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tret := &prefixNonceAEAD{aead: aead}\n\tcopy(ret.nonce[:], noncePrefix)\n\treturn ret\n}\n\n// aeadAESGCMTLS13 should be an internal detail,\n// but widely used packages access it using linkname.\n// Notable members of the hall of shame include:\n//   - github.com/xtls/xray-core\n//   - github.com/v2fly/v2ray-core\n//\n// Do not remove or change the type signature.\n// See go.dev/issue/67401.\n//\n//go:linkname aeadAESGCMTLS13\nfunc aeadAESGCMTLS13(key, nonceMask []byte) aead {\n\tif len(nonceMask) != aeadNonceLength {\n\t\tpanic(\"tls: internal error: wrong nonce length\")\n\t}\n\taes, err := aes.NewCipher(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\taead, err := cipher.NewGCM(aes)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tret := &xorNonceAEAD{aead: aead}\n\tcopy(ret.nonceMask[:], nonceMask)\n\treturn ret\n}\n\nfunc aeadChaCha20Poly1305(key, nonceMask []byte) aead {\n\tif len(nonceMask) != aeadNonceLength {\n\t\tpanic(\"tls: internal error: wrong nonce length\")\n\t}\n\taead, err := chacha20poly1305.New(key)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tret := &xorNonceAEAD{aead: aead}\n\tcopy(ret.nonceMask[:], nonceMask)\n\treturn ret\n}\n\ntype constantTimeHash interface {\n\thash.Hash\n\tConstantTimeSum(b []byte) []byte\n}\n\n// cthWrapper wraps any hash.Hash that implements ConstantTimeSum, and replaces\n// with that all calls to Sum. It's used to obtain a ConstantTimeSum-based HMAC.\ntype cthWrapper struct {\n\th constantTimeHash\n}\n\nfunc (c *cthWrapper) Size() int                   { return c.h.Size() }\nfunc (c *cthWrapper) BlockSize() int              { return c.h.BlockSize() }\nfunc (c *cthWrapper) Reset()                      { c.h.Reset() }\nfunc (c *cthWrapper) Write(p []byte) (int, error) { return c.h.Write(p) }\nfunc (c *cthWrapper) Sum(b []byte) []byte         { return c.h.ConstantTimeSum(b) }\n\nfunc newConstantTimeHash(h func() hash.Hash) func() hash.Hash {\n\treturn func() hash.Hash {\n\t\treturn &cthWrapper{h().(constantTimeHash)}\n\t}\n}\n\n// tls10MAC implements the TLS 1.0 MAC function. RFC 2246, Section 6.2.3.\nfunc tls10MAC(h hash.Hash, out, seq, header, data, extra []byte) []byte {\n\th.Reset()\n\th.Write(seq)\n\th.Write(header)\n\th.Write(data)\n\tres := h.Sum(out)\n\tif extra != nil {\n\t\th.Write(extra)\n\t}\n\treturn res\n}\n\nfunc rsaKA(version uint16) keyAgreement {\n\treturn rsaKeyAgreement{}\n}\n\nfunc ecdheECDSAKA(version uint16) keyAgreement {\n\treturn &ecdheKeyAgreement{\n\t\tisRSA:   false,\n\t\tversion: version,\n\t}\n}\n\nfunc ecdheRSAKA(version uint16) keyAgreement {\n\treturn &ecdheKeyAgreement{\n\t\tisRSA:   true,\n\t\tversion: version,\n\t}\n}\n\n// mutualCipherSuite returns a cipherSuite given a list of supported\n// ciphersuites and the id requested by the peer.\nfunc mutualCipherSuite(have []uint16, want uint16) *cipherSuite {\n\tfor _, id := range have {\n\t\tif id == want {\n\t\t\treturn cipherSuiteByID(id)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc cipherSuiteByID(id uint16) *cipherSuite {\n\tfor _, cipherSuite := range cipherSuites {\n\t\tif cipherSuite.id == id {\n\t\t\treturn cipherSuite\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mutualCipherSuiteTLS13(have []uint16, want uint16) *cipherSuiteTLS13 {\n\tfor _, id := range have {\n\t\tif id == want {\n\t\t\treturn cipherSuiteTLS13ByID(id)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc cipherSuiteTLS13ByID(id uint16) *cipherSuiteTLS13 {\n\tfor _, cipherSuite := range cipherSuitesTLS13 {\n\t\tif cipherSuite.id == id {\n\t\t\treturn cipherSuite\n\t\t}\n\t}\n\treturn nil\n}\n\n// A list of cipher suite IDs that are, or have been, implemented by this\n// package.\n//\n// See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\nconst (\n\t// TLS 1.0 - 1.2 cipher suites.\n\tTLS_RSA_WITH_RC4_128_SHA                      uint16 = 0x0005\n\tTLS_RSA_WITH_3DES_EDE_CBC_SHA                 uint16 = 0x000a\n\tTLS_RSA_WITH_AES_128_CBC_SHA                  uint16 = 0x002f\n\tTLS_RSA_WITH_AES_256_CBC_SHA                  uint16 = 0x0035\n\tTLS_RSA_WITH_AES_128_CBC_SHA256               uint16 = 0x003c\n\tTLS_RSA_WITH_AES_128_GCM_SHA256               uint16 = 0x009c\n\tTLS_RSA_WITH_AES_256_GCM_SHA384               uint16 = 0x009d\n\tTLS_ECDHE_ECDSA_WITH_RC4_128_SHA              uint16 = 0xc007\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA          uint16 = 0xc009\n\tTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA          uint16 = 0xc00a\n\tTLS_ECDHE_RSA_WITH_RC4_128_SHA                uint16 = 0xc011\n\tTLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0xc012\n\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA            uint16 = 0xc013\n\tTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA            uint16 = 0xc014\n\tTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256       uint16 = 0xc023\n\tTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0xc027\n\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0xc02f\n\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       uint16 = 0xc02b\n\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0xc030\n\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       uint16 = 0xc02c\n\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xcca8\n\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca9\n\n\t// TLS 1.3 cipher suites.\n\tTLS_AES_128_GCM_SHA256       uint16 = 0x1301\n\tTLS_AES_256_GCM_SHA384       uint16 = 0x1302\n\tTLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303\n\n\t// TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\n\t// that the client is doing version fallback. See RFC 7507.\n\tTLS_FALLBACK_SCSV uint16 = 0x5600\n\n\t// Legacy names for the corresponding cipher suites with the correct _SHA256\n\t// suffix, retained for backward compatibility.\n\tTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305   = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n\tTLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n)\n"
        },
        {
          "name": "common.go",
          "type": "blob",
          "size": 59.984375,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"bytes\"\n\t\"container/list\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha512\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"slices\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t_ \"unsafe\" // for linkname\n)\n\nconst (\n\tVersionTLS10 = 0x0301\n\tVersionTLS11 = 0x0302\n\tVersionTLS12 = 0x0303\n\tVersionTLS13 = 0x0304\n\n\t// Deprecated: SSLv3 is cryptographically broken, and is no longer\n\t// supported by this package. See golang.org/issue/32716.\n\tVersionSSL30 = 0x0300\n)\n\n// VersionName returns the name for the provided TLS version number\n// (e.g. \"TLS 1.3\"), or a fallback representation of the value if the\n// version is not implemented by this package.\nfunc VersionName(version uint16) string {\n\tswitch version {\n\tcase VersionSSL30:\n\t\treturn \"SSLv3\"\n\tcase VersionTLS10:\n\t\treturn \"TLS 1.0\"\n\tcase VersionTLS11:\n\t\treturn \"TLS 1.1\"\n\tcase VersionTLS12:\n\t\treturn \"TLS 1.2\"\n\tcase VersionTLS13:\n\t\treturn \"TLS 1.3\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"0x%04X\", version)\n\t}\n}\n\nconst (\n\tmaxPlaintext               = 16384        // maximum plaintext payload length\n\tmaxCiphertext              = 16384 + 2048 // maximum ciphertext payload length\n\tmaxCiphertextTLS13         = 16384 + 256  // maximum ciphertext length in TLS 1.3\n\trecordHeaderLen            = 5            // record header length\n\tmaxHandshake               = 65536        // maximum handshake we support (protocol max is 16 MB)\n\tmaxHandshakeCertificateMsg = 262144       // maximum certificate message size (256 KiB)\n\tmaxUselessRecords          = 16           // maximum number of consecutive non-advancing records\n)\n\n// TLS record types.\ntype recordType uint8\n\nconst (\n\trecordTypeChangeCipherSpec recordType = 20\n\trecordTypeAlert            recordType = 21\n\trecordTypeHandshake        recordType = 22\n\trecordTypeApplicationData  recordType = 23\n)\n\n// TLS handshake message types.\nconst (\n\ttypeHelloRequest        uint8 = 0\n\ttypeClientHello         uint8 = 1\n\ttypeServerHello         uint8 = 2\n\ttypeNewSessionTicket    uint8 = 4\n\ttypeEndOfEarlyData      uint8 = 5\n\ttypeEncryptedExtensions uint8 = 8\n\ttypeCertificate         uint8 = 11\n\ttypeServerKeyExchange   uint8 = 12\n\ttypeCertificateRequest  uint8 = 13\n\ttypeServerHelloDone     uint8 = 14\n\ttypeCertificateVerify   uint8 = 15\n\ttypeClientKeyExchange   uint8 = 16\n\ttypeFinished            uint8 = 20\n\ttypeCertificateStatus   uint8 = 22\n\ttypeKeyUpdate           uint8 = 24\n\ttypeMessageHash         uint8 = 254 // synthetic message\n)\n\n// TLS compression types.\nconst (\n\tcompressionNone uint8 = 0\n)\n\n// TLS extension numbers\nconst (\n\textensionServerName              uint16 = 0\n\textensionStatusRequest           uint16 = 5\n\textensionSupportedCurves         uint16 = 10 // supported_groups in TLS 1.3, see RFC 8446, Section 4.2.7\n\textensionSupportedPoints         uint16 = 11\n\textensionSignatureAlgorithms     uint16 = 13\n\textensionALPN                    uint16 = 16\n\textensionSCT                     uint16 = 18\n\textensionExtendedMasterSecret    uint16 = 23\n\textensionSessionTicket           uint16 = 35\n\textensionPreSharedKey            uint16 = 41\n\textensionEarlyData               uint16 = 42\n\textensionSupportedVersions       uint16 = 43\n\textensionCookie                  uint16 = 44\n\textensionPSKModes                uint16 = 45\n\textensionCertificateAuthorities  uint16 = 47\n\textensionSignatureAlgorithmsCert uint16 = 50\n\textensionKeyShare                uint16 = 51\n\textensionQUICTransportParameters uint16 = 57\n\textensionRenegotiationInfo       uint16 = 0xff01\n\textensionECHOuterExtensions      uint16 = 0xfd00\n\textensionEncryptedClientHello    uint16 = 0xfe0d\n)\n\n// TLS signaling cipher suite values\nconst (\n\tscsvRenegotiation uint16 = 0x00ff\n)\n\n// CurveID is the type of a TLS identifier for a key exchange mechanism. See\n// https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8.\n//\n// In TLS 1.2, this registry used to support only elliptic curves. In TLS 1.3,\n// it was extended to other groups and renamed NamedGroup. See RFC 8446, Section\n// 4.2.7. It was then also extended to other mechanisms, such as hybrid\n// post-quantum KEMs.\ntype CurveID uint16\n\nconst (\n\tCurveP256 CurveID = 23\n\tCurveP384 CurveID = 24\n\tCurveP521 CurveID = 25\n\tX25519    CurveID = 29\n\n\t// Experimental codepoint for X25519Kyber768Draft00, specified in\n\t// draft-tls-westerbaan-xyber768d00-03. Not exported, as support might be\n\t// removed in the future.\n\tx25519Kyber768Draft00 CurveID = 0x6399 // X25519Kyber768Draft00\n)\n\n// TLS 1.3 Key Share. See RFC 8446, Section 4.2.8.\ntype keyShare struct {\n\tgroup CurveID\n\tdata  []byte\n}\n\n// TLS 1.3 PSK Key Exchange Modes. See RFC 8446, Section 4.2.9.\nconst (\n\tpskModePlain uint8 = 0\n\tpskModeDHE   uint8 = 1\n)\n\n// TLS 1.3 PSK Identity. Can be a Session Ticket, or a reference to a saved\n// session. See RFC 8446, Section 4.2.11.\ntype pskIdentity struct {\n\tlabel               []byte\n\tobfuscatedTicketAge uint32\n}\n\n// TLS Elliptic Curve Point Formats\n// https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9\nconst (\n\tpointFormatUncompressed uint8 = 0\n)\n\n// TLS CertificateStatusType (RFC 3546)\nconst (\n\tstatusTypeOCSP uint8 = 1\n)\n\n// Certificate types (for certificateRequestMsg)\nconst (\n\tcertTypeRSASign   = 1\n\tcertTypeECDSASign = 64 // ECDSA or EdDSA keys, see RFC 8422, Section 3.\n)\n\n// Signature algorithms (for internal signaling use). Starting at 225 to avoid overlap with\n// TLS 1.2 codepoints (RFC 5246, Appendix A.4.1), with which these have nothing to do.\nconst (\n\tsignaturePKCS1v15 uint8 = iota + 225\n\tsignatureRSAPSS\n\tsignatureECDSA\n\tsignatureEd25519\n)\n\n// directSigning is a standard Hash value that signals that no pre-hashing\n// should be performed, and that the input should be signed directly. It is the\n// hash function associated with the Ed25519 signature scheme.\nvar directSigning crypto.Hash = 0\n\n// helloRetryRequestRandom is set as the Random value of a ServerHello\n// to signal that the message is actually a HelloRetryRequest.\nvar helloRetryRequestRandom = []byte{ // See RFC 8446, Section 4.1.3.\n\t0xCF, 0x21, 0xAD, 0x74, 0xE5, 0x9A, 0x61, 0x11,\n\t0xBE, 0x1D, 0x8C, 0x02, 0x1E, 0x65, 0xB8, 0x91,\n\t0xC2, 0xA2, 0x11, 0x16, 0x7A, 0xBB, 0x8C, 0x5E,\n\t0x07, 0x9E, 0x09, 0xE2, 0xC8, 0xA8, 0x33, 0x9C,\n}\n\nconst (\n\t// downgradeCanaryTLS12 or downgradeCanaryTLS11 is embedded in the server\n\t// random as a downgrade protection if the server would be capable of\n\t// negotiating a higher version. See RFC 8446, Section 4.1.3.\n\tdowngradeCanaryTLS12 = \"DOWNGRD\\x01\"\n\tdowngradeCanaryTLS11 = \"DOWNGRD\\x00\"\n)\n\n// testingOnlyForceDowngradeCanary is set in tests to force the server side to\n// include downgrade canaries even if it's using its highers supported version.\nvar testingOnlyForceDowngradeCanary bool\n\n// ConnectionState records basic TLS details about the connection.\ntype ConnectionState struct {\n\t// Version is the TLS version used by the connection (e.g. VersionTLS12).\n\tVersion uint16\n\n\t// HandshakeComplete is true if the handshake has concluded.\n\tHandshakeComplete bool\n\n\t// DidResume is true if this connection was successfully resumed from a\n\t// previous session with a session ticket or similar mechanism.\n\tDidResume bool\n\n\t// CipherSuite is the cipher suite negotiated for the connection (e.g.\n\t// TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).\n\tCipherSuite uint16\n\n\t// NegotiatedProtocol is the application protocol negotiated with ALPN.\n\tNegotiatedProtocol string\n\n\t// NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.\n\t//\n\t// Deprecated: this value is always true.\n\tNegotiatedProtocolIsMutual bool\n\n\t// ServerName is the value of the Server Name Indication extension sent by\n\t// the client. It's available both on the server and on the client side.\n\tServerName string\n\n\t// PeerCertificates are the parsed certificates sent by the peer, in the\n\t// order in which they were sent. The first element is the leaf certificate\n\t// that the connection is verified against.\n\t//\n\t// On the client side, it can't be empty. On the server side, it can be\n\t// empty if Config.ClientAuth is not RequireAnyClientCert or\n\t// RequireAndVerifyClientCert.\n\t//\n\t// PeerCertificates and its contents should not be modified.\n\tPeerCertificates []*x509.Certificate\n\n\t// VerifiedChains is a list of one or more chains where the first element is\n\t// PeerCertificates[0] and the last element is from Config.RootCAs (on the\n\t// client side) or Config.ClientCAs (on the server side).\n\t//\n\t// On the client side, it's set if Config.InsecureSkipVerify is false. On\n\t// the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven\n\t// (and the peer provided a certificate) or RequireAndVerifyClientCert.\n\t//\n\t// VerifiedChains and its contents should not be modified.\n\tVerifiedChains [][]*x509.Certificate\n\n\t// SignedCertificateTimestamps is a list of SCTs provided by the peer\n\t// through the TLS handshake for the leaf certificate, if any.\n\tSignedCertificateTimestamps [][]byte\n\n\t// OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)\n\t// response provided by the peer for the leaf certificate, if any.\n\tOCSPResponse []byte\n\n\t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC 5929,\n\t// Section 3). This value will be nil for TLS 1.3 connections and for\n\t// resumed connections that don't support Extended Master Secret (RFC 7627).\n\tTLSUnique []byte\n\n\t// ECHAccepted indicates if Encrypted Client Hello was offered by the client\n\t// and accepted by the server. Currently, ECH is supported only on the\n\t// client side.\n\tECHAccepted bool\n\n\t// ekm is a closure exposed via ExportKeyingMaterial.\n\tekm func(label string, context []byte, length int) ([]byte, error)\n\n\t// testingOnlyDidHRR is true if a HelloRetryRequest was sent/received.\n\ttestingOnlyDidHRR bool\n\n\t// testingOnlyCurveID is the selected CurveID, or zero if an RSA exchanges\n\t// is performed.\n\ttestingOnlyCurveID CurveID\n}\n\n// ExportKeyingMaterial returns length bytes of exported key material in a new\n// slice as defined in RFC 5705. If context is nil, it is not used as part of\n// the seed. If the connection was set to allow renegotiation via\n// Config.Renegotiation, or if the connections supports neither TLS 1.3 nor\n// Extended Master Secret, this function will return an error.\n//\n// Exporting key material without Extended Master Secret or TLS 1.3 was disabled\n// in Go 1.22 due to security issues (see the Security Considerations sections\n// of RFC 5705 and RFC 7627), but can be re-enabled with the GODEBUG setting\n// tlsunsafeekm=1.\nfunc (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error) {\n\treturn cs.ekm(label, context, length)\n}\n\n// ClientAuthType declares the policy the server will follow for\n// TLS Client Authentication.\ntype ClientAuthType int\n\nconst (\n\t// NoClientCert indicates that no client certificate should be requested\n\t// during the handshake, and if any certificates are sent they will not\n\t// be verified.\n\tNoClientCert ClientAuthType = iota\n\t// RequestClientCert indicates that a client certificate should be requested\n\t// during the handshake, but does not require that the client send any\n\t// certificates.\n\tRequestClientCert\n\t// RequireAnyClientCert indicates that a client certificate should be requested\n\t// during the handshake, and that at least one certificate is required to be\n\t// sent by the client, but that certificate is not required to be valid.\n\tRequireAnyClientCert\n\t// VerifyClientCertIfGiven indicates that a client certificate should be requested\n\t// during the handshake, but does not require that the client sends a\n\t// certificate. If the client does send a certificate it is required to be\n\t// valid.\n\tVerifyClientCertIfGiven\n\t// RequireAndVerifyClientCert indicates that a client certificate should be requested\n\t// during the handshake, and that at least one valid certificate is required\n\t// to be sent by the client.\n\tRequireAndVerifyClientCert\n)\n\n// requiresClientCert reports whether the ClientAuthType requires a client\n// certificate to be provided.\nfunc requiresClientCert(c ClientAuthType) bool {\n\tswitch c {\n\tcase RequireAnyClientCert, RequireAndVerifyClientCert:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// ClientSessionCache is a cache of ClientSessionState objects that can be used\n// by a client to resume a TLS session with a given server. ClientSessionCache\n// implementations should expect to be called concurrently from different\n// goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not\n// SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which\n// are supported via this interface.\ntype ClientSessionCache interface {\n\t// Get searches for a ClientSessionState associated with the given key.\n\t// On return, ok is true if one was found.\n\tGet(sessionKey string) (session *ClientSessionState, ok bool)\n\n\t// Put adds the ClientSessionState to the cache with the given key. It might\n\t// get called multiple times in a connection if a TLS 1.3 server provides\n\t// more than one session ticket. If called with a nil *ClientSessionState,\n\t// it should remove the cache entry.\n\tPut(sessionKey string, cs *ClientSessionState)\n}\n\n//go:generate stringer -linecomment -type=SignatureScheme,CurveID,ClientAuthType -output=common_string.go\n\n// SignatureScheme identifies a signature algorithm supported by TLS. See\n// RFC 8446, Section 4.2.3.\ntype SignatureScheme uint16\n\nconst (\n\t// RSASSA-PKCS1-v1_5 algorithms.\n\tPKCS1WithSHA256 SignatureScheme = 0x0401\n\tPKCS1WithSHA384 SignatureScheme = 0x0501\n\tPKCS1WithSHA512 SignatureScheme = 0x0601\n\n\t// RSASSA-PSS algorithms with public key OID rsaEncryption.\n\tPSSWithSHA256 SignatureScheme = 0x0804\n\tPSSWithSHA384 SignatureScheme = 0x0805\n\tPSSWithSHA512 SignatureScheme = 0x0806\n\n\t// ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.\n\tECDSAWithP256AndSHA256 SignatureScheme = 0x0403\n\tECDSAWithP384AndSHA384 SignatureScheme = 0x0503\n\tECDSAWithP521AndSHA512 SignatureScheme = 0x0603\n\n\t// EdDSA algorithms.\n\tEd25519 SignatureScheme = 0x0807\n\n\t// Legacy signature and hash algorithms for TLS 1.2.\n\tPKCS1WithSHA1 SignatureScheme = 0x0201\n\tECDSAWithSHA1 SignatureScheme = 0x0203\n)\n\n// ClientHelloInfo contains information from a ClientHello message in order to\n// guide application logic in the GetCertificate and GetConfigForClient callbacks.\ntype ClientHelloInfo struct {\n\t// CipherSuites lists the CipherSuites supported by the client (e.g.\n\t// TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).\n\tCipherSuites []uint16\n\n\t// ServerName indicates the name of the server requested by the client\n\t// in order to support virtual hosting. ServerName is only set if the\n\t// client is using SNI (see RFC 4366, Section 3.1).\n\tServerName string\n\n\t// SupportedCurves lists the elliptic curves supported by the client.\n\t// SupportedCurves is set only if the Supported Elliptic Curves\n\t// Extension is being used (see RFC 4492, Section 5.1.1).\n\tSupportedCurves []CurveID\n\n\t// SupportedPoints lists the point formats supported by the client.\n\t// SupportedPoints is set only if the Supported Point Formats Extension\n\t// is being used (see RFC 4492, Section 5.1.2).\n\tSupportedPoints []uint8\n\n\t// SignatureSchemes lists the signature and hash schemes that the client\n\t// is willing to verify. SignatureSchemes is set only if the Signature\n\t// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).\n\tSignatureSchemes []SignatureScheme\n\n\t// SupportedProtos lists the application protocols supported by the client.\n\t// SupportedProtos is set only if the Application-Layer Protocol\n\t// Negotiation Extension is being used (see RFC 7301, Section 3.1).\n\t//\n\t// Servers can select a protocol by setting Config.NextProtos in a\n\t// GetConfigForClient return value.\n\tSupportedProtos []string\n\n\t// SupportedVersions lists the TLS versions supported by the client.\n\t// For TLS versions less than 1.3, this is extrapolated from the max\n\t// version advertised by the client, so values other than the greatest\n\t// might be rejected if used.\n\tSupportedVersions []uint16\n\n\t// Extensions lists the IDs of the extensions presented by the client\n\t// in the client hello.\n\tExtensions []uint16\n\n\t// Conn is the underlying net.Conn for the connection. Do not read\n\t// from, or write to, this connection; that will cause the TLS\n\t// connection to fail.\n\tConn net.Conn\n\n\t// config is embedded by the GetCertificate or GetConfigForClient caller,\n\t// for use with SupportsCertificate.\n\tconfig *Config\n\n\t// ctx is the context of the handshake that is in progress.\n\tctx context.Context\n}\n\n// Context returns the context of the handshake that is in progress.\n// This context is a child of the context passed to HandshakeContext,\n// if any, and is canceled when the handshake concludes.\nfunc (c *ClientHelloInfo) Context() context.Context {\n\treturn c.ctx\n}\n\n// CertificateRequestInfo contains information from a server's\n// CertificateRequest message, which is used to demand a certificate and proof\n// of control from a client.\ntype CertificateRequestInfo struct {\n\t// AcceptableCAs contains zero or more, DER-encoded, X.501\n\t// Distinguished Names. These are the names of root or intermediate CAs\n\t// that the server wishes the returned certificate to be signed by. An\n\t// empty slice indicates that the server has no preference.\n\tAcceptableCAs [][]byte\n\n\t// SignatureSchemes lists the signature schemes that the server is\n\t// willing to verify.\n\tSignatureSchemes []SignatureScheme\n\n\t// Version is the TLS version that was negotiated for this connection.\n\tVersion uint16\n\n\t// ctx is the context of the handshake that is in progress.\n\tctx context.Context\n}\n\n// Context returns the context of the handshake that is in progress.\n// This context is a child of the context passed to HandshakeContext,\n// if any, and is canceled when the handshake concludes.\nfunc (c *CertificateRequestInfo) Context() context.Context {\n\treturn c.ctx\n}\n\n// RenegotiationSupport enumerates the different levels of support for TLS\n// renegotiation. TLS renegotiation is the act of performing subsequent\n// handshakes on a connection after the first. This significantly complicates\n// the state machine and has been the source of numerous, subtle security\n// issues. Initiating a renegotiation is not supported, but support for\n// accepting renegotiation requests may be enabled.\n//\n// Even when enabled, the server may not change its identity between handshakes\n// (i.e. the leaf certificate must be the same). Additionally, concurrent\n// handshake and application data flow is not permitted so renegotiation can\n// only be used with protocols that synchronise with the renegotiation, such as\n// HTTPS.\n//\n// Renegotiation is not defined in TLS 1.3.\ntype RenegotiationSupport int\n\nconst (\n\t// RenegotiateNever disables renegotiation.\n\tRenegotiateNever RenegotiationSupport = iota\n\n\t// RenegotiateOnceAsClient allows a remote server to request\n\t// renegotiation once per connection.\n\tRenegotiateOnceAsClient\n\n\t// RenegotiateFreelyAsClient allows a remote server to repeatedly\n\t// request renegotiation.\n\tRenegotiateFreelyAsClient\n)\n\n// A Config structure is used to configure a TLS client or server.\n// After one has been passed to a TLS function it must not be\n// modified. A Config may be reused; the tls package will also not\n// modify it.\ntype Config struct {\n\tDialContext func(ctx context.Context, network, address string) (net.Conn, error)\n\n\tShow bool\n\tType string\n\tDest string\n\tXver byte\n\n\tServerNames  map[string]bool\n\tPrivateKey   []byte\n\tMinClientVer []byte\n\tMaxClientVer []byte\n\tMaxTimeDiff  time.Duration\n\tShortIds     map[[8]byte]bool\n\n\t// Rand provides the source of entropy for nonces and RSA blinding.\n\t// If Rand is nil, TLS uses the cryptographic random reader in package\n\t// crypto/rand.\n\t// The Reader must be safe for use by multiple goroutines.\n\tRand io.Reader\n\n\t// Time returns the current time as the number of seconds since the epoch.\n\t// If Time is nil, TLS uses time.Now.\n\tTime func() time.Time\n\n\t// Certificates contains one or more certificate chains to present to the\n\t// other side of the connection. The first certificate compatible with the\n\t// peer's requirements is selected automatically.\n\t//\n\t// Server configurations must set one of Certificates, GetCertificate or\n\t// GetConfigForClient. Clients doing client-authentication may set either\n\t// Certificates or GetClientCertificate.\n\t//\n\t// Note: if there are multiple Certificates, and they don't have the\n\t// optional field Leaf set, certificate selection will incur a significant\n\t// per-handshake performance cost.\n\tCertificates []Certificate\n\n\t// NameToCertificate maps from a certificate name to an element of\n\t// Certificates. Note that a certificate name can be of the form\n\t// '*.example.com' and so doesn't have to be a domain name as such.\n\t//\n\t// Deprecated: NameToCertificate only allows associating a single\n\t// certificate with a given name. Leave this field nil to let the library\n\t// select the first compatible chain from Certificates.\n\tNameToCertificate map[string]*Certificate\n\n\t// GetCertificate returns a Certificate based on the given\n\t// ClientHelloInfo. It will only be called if the client supplies SNI\n\t// information or if Certificates is empty.\n\t//\n\t// If GetCertificate is nil or returns nil, then the certificate is\n\t// retrieved from NameToCertificate. If NameToCertificate is nil, the\n\t// best element of Certificates will be used.\n\t//\n\t// Once a Certificate is returned it should not be modified.\n\tGetCertificate func(*ClientHelloInfo) (*Certificate, error)\n\n\t// GetClientCertificate, if not nil, is called when a server requests a\n\t// certificate from a client. If set, the contents of Certificates will\n\t// be ignored.\n\t//\n\t// If GetClientCertificate returns an error, the handshake will be\n\t// aborted and that error will be returned. Otherwise\n\t// GetClientCertificate must return a non-nil Certificate. If\n\t// Certificate.Certificate is empty then no certificate will be sent to\n\t// the server. If this is unacceptable to the server then it may abort\n\t// the handshake.\n\t//\n\t// GetClientCertificate may be called multiple times for the same\n\t// connection if renegotiation occurs or if TLS 1.3 is in use.\n\t//\n\t// Once a Certificate is returned it should not be modified.\n\tGetClientCertificate func(*CertificateRequestInfo) (*Certificate, error)\n\n\t// GetConfigForClient, if not nil, is called after a ClientHello is\n\t// received from a client. It may return a non-nil Config in order to\n\t// change the Config that will be used to handle this connection. If\n\t// the returned Config is nil, the original Config will be used. The\n\t// Config returned by this callback may not be subsequently modified.\n\t//\n\t// If GetConfigForClient is nil, the Config passed to Server() will be\n\t// used for all connections.\n\t//\n\t// If SessionTicketKey was explicitly set on the returned Config, or if\n\t// SetSessionTicketKeys was called on the returned Config, those keys will\n\t// be used. Otherwise, the original Config keys will be used (and possibly\n\t// rotated if they are automatically managed).\n\tGetConfigForClient func(*ClientHelloInfo) (*Config, error)\n\n\t// VerifyPeerCertificate, if not nil, is called after normal\n\t// certificate verification by either a TLS client or server. It\n\t// receives the raw ASN.1 certificates provided by the peer and also\n\t// any verified chains that normal processing found. If it returns a\n\t// non-nil error, the handshake is aborted and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. If normal verification is disabled (on the\n\t// client when InsecureSkipVerify is set, or on a server when ClientAuth is\n\t// RequestClientCert or RequireAnyClientCert), then this callback will be\n\t// considered but the verifiedChains argument will always be nil. When\n\t// ClientAuth is NoClientCert, this callback is not called on the server.\n\t// rawCerts may be empty on the server if ClientAuth is RequestClientCert or\n\t// VerifyClientCertIfGiven.\n\t//\n\t// This callback is not invoked on resumed connections, as certificates are\n\t// not re-verified on resumption.\n\t//\n\t// verifiedChains and its contents should not be modified.\n\tVerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n\n\t// VerifyConnection, if not nil, is called after normal certificate\n\t// verification and after VerifyPeerCertificate by either a TLS client\n\t// or server. If it returns a non-nil error, the handshake is aborted\n\t// and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. This callback will run for all connections,\n\t// including resumptions, regardless of InsecureSkipVerify or ClientAuth\n\t// settings.\n\tVerifyConnection func(ConnectionState) error\n\n\t// RootCAs defines the set of root certificate authorities\n\t// that clients use when verifying server certificates.\n\t// If RootCAs is nil, TLS uses the host's root CA set.\n\tRootCAs *x509.CertPool\n\n\t// NextProtos is a list of supported application level protocols, in\n\t// order of preference. If both peers support ALPN, the selected\n\t// protocol will be one from this list, and the connection will fail\n\t// if there is no mutually supported protocol. If NextProtos is empty\n\t// or the peer doesn't support ALPN, the connection will succeed and\n\t// ConnectionState.NegotiatedProtocol will be empty.\n\tNextProtos []string\n\n\t// ServerName is used to verify the hostname on the returned\n\t// certificates unless InsecureSkipVerify is given. It is also included\n\t// in the client's handshake to support virtual hosting unless it is\n\t// an IP address.\n\tServerName string\n\n\t// ClientAuth determines the server's policy for\n\t// TLS Client Authentication. The default is NoClientCert.\n\tClientAuth ClientAuthType\n\n\t// ClientCAs defines the set of root certificate authorities\n\t// that servers use if required to verify a client certificate\n\t// by the policy in ClientAuth.\n\tClientCAs *x509.CertPool\n\n\t// InsecureSkipVerify controls whether a client verifies the server's\n\t// certificate chain and host name. If InsecureSkipVerify is true, crypto/tls\n\t// accepts any certificate presented by the server and any host name in that\n\t// certificate. In this mode, TLS is susceptible to machine-in-the-middle\n\t// attacks unless custom verification is used. This should be used only for\n\t// testing or in combination with VerifyConnection or VerifyPeerCertificate.\n\tInsecureSkipVerify bool\n\n\t// CipherSuites is a list of enabled TLS 1.0–1.2 cipher suites. The order of\n\t// the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.\n\t//\n\t// If CipherSuites is nil, a safe default list is used. The default cipher\n\t// suites might change over time. In Go 1.22 RSA key exchange based cipher\n\t// suites were removed from the default list, but can be re-added with the\n\t// GODEBUG setting tlsrsakex=1. In Go 1.23 3DES cipher suites were removed\n\t// from the default list, but can be re-added with the GODEBUG setting\n\t// tls3des=1.\n\tCipherSuites []uint16\n\n\t// PreferServerCipherSuites is a legacy field and has no effect.\n\t//\n\t// It used to control whether the server would follow the client's or the\n\t// server's preference. Servers now select the best mutually supported\n\t// cipher suite based on logic that takes into account inferred client\n\t// hardware, server hardware, and security.\n\t//\n\t// Deprecated: PreferServerCipherSuites is ignored.\n\tPreferServerCipherSuites bool\n\n\t// SessionTicketsDisabled may be set to true to disable session ticket and\n\t// PSK (resumption) support. Note that on clients, session ticket support is\n\t// also disabled if ClientSessionCache is nil.\n\tSessionTicketsDisabled bool\n\n\t// SessionTicketKey is used by TLS servers to provide session resumption.\n\t// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled\n\t// with random data before the first server handshake.\n\t//\n\t// Deprecated: if this field is left at zero, session ticket keys will be\n\t// automatically rotated every day and dropped after seven days. For\n\t// customizing the rotation schedule or synchronizing servers that are\n\t// terminating connections for the same host, use SetSessionTicketKeys.\n\tSessionTicketKey [32]byte\n\n\t// ClientSessionCache is a cache of ClientSessionState entries for TLS\n\t// session resumption. It is only used by clients.\n\tClientSessionCache ClientSessionCache\n\n\t// UnwrapSession is called on the server to turn a ticket/identity\n\t// previously produced by [WrapSession] into a usable session.\n\t//\n\t// UnwrapSession will usually either decrypt a session state in the ticket\n\t// (for example with [Config.EncryptTicket]), or use the ticket as a handle\n\t// to recover a previously stored state. It must use [ParseSessionState] to\n\t// deserialize the session state.\n\t//\n\t// If UnwrapSession returns an error, the connection is terminated. If it\n\t// returns (nil, nil), the session is ignored. crypto/tls may still choose\n\t// not to resume the returned session.\n\tUnwrapSession func(identity []byte, cs ConnectionState) (*SessionState, error)\n\n\t// WrapSession is called on the server to produce a session ticket/identity.\n\t//\n\t// WrapSession must serialize the session state with [SessionState.Bytes].\n\t// It may then encrypt the serialized state (for example with\n\t// [Config.DecryptTicket]) and use it as the ticket, or store the state and\n\t// return a handle for it.\n\t//\n\t// If WrapSession returns an error, the connection is terminated.\n\t//\n\t// Warning: the return value will be exposed on the wire and to clients in\n\t// plaintext. The application is in charge of encrypting and authenticating\n\t// it (and rotating keys) or returning high-entropy identifiers. Failing to\n\t// do so correctly can compromise current, previous, and future connections\n\t// depending on the protocol version.\n\tWrapSession func(ConnectionState, *SessionState) ([]byte, error)\n\n\t// MinVersion contains the minimum TLS version that is acceptable.\n\t//\n\t// By default, TLS 1.2 is currently used as the minimum. TLS 1.0 is the\n\t// minimum supported by this package.\n\t//\n\t// The server-side default can be reverted to TLS 1.0 by including the value\n\t// \"tls10server=1\" in the GODEBUG environment variable.\n\tMinVersion uint16\n\n\t// MaxVersion contains the maximum TLS version that is acceptable.\n\t//\n\t// By default, the maximum version supported by this package is used,\n\t// which is currently TLS 1.3.\n\tMaxVersion uint16\n\n\t// CurvePreferences contains the elliptic curves that will be used in\n\t// an ECDHE handshake, in preference order. If empty, the default will\n\t// be used. The client will use the first preference as the type for\n\t// its key share in TLS 1.3. This may change in the future.\n\t//\n\t// From Go 1.23, the default includes the X25519Kyber768Draft00 hybrid\n\t// post-quantum key exchange. To disable it, set CurvePreferences explicitly\n\t// or use the GODEBUG=tlskyber=0 environment variable.\n\tCurvePreferences []CurveID\n\n\t// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.\n\t// When true, the largest possible TLS record size is always used. When\n\t// false, the size of TLS records may be adjusted in an attempt to\n\t// improve latency.\n\tDynamicRecordSizingDisabled bool\n\n\t// Renegotiation controls what types of renegotiation are supported.\n\t// The default, none, is correct for the vast majority of applications.\n\tRenegotiation RenegotiationSupport\n\n\t// KeyLogWriter optionally specifies a destination for TLS master secrets\n\t// in NSS key log format that can be used to allow external programs\n\t// such as Wireshark to decrypt TLS connections.\n\t// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.\n\t// Use of KeyLogWriter compromises security and should only be\n\t// used for debugging.\n\tKeyLogWriter io.Writer\n\n\t// EncryptedClientHelloConfigList is a serialized ECHConfigList. If\n\t// provided, clients will attempt to connect to servers using Encrypted\n\t// Client Hello (ECH) using one of the provided ECHConfigs. Servers\n\t// currently ignore this field.\n\t//\n\t// If the list contains no valid ECH configs, the handshake will fail\n\t// and return an error.\n\t//\n\t// If EncryptedClientHelloConfigList is set, MinVersion, if set, must\n\t// be VersionTLS13.\n\t//\n\t// When EncryptedClientHelloConfigList is set, the handshake will only\n\t// succeed if ECH is sucessfully negotiated. If the server rejects ECH,\n\t// an ECHRejectionError error will be returned, which may contain a new\n\t// ECHConfigList that the server suggests using.\n\t//\n\t// How this field is parsed may change in future Go versions, if the\n\t// encoding described in the final Encrypted Client Hello RFC changes.\n\tEncryptedClientHelloConfigList []byte\n\n\t// EncryptedClientHelloRejectionVerify, if not nil, is called when ECH is\n\t// rejected, in order to verify the ECH provider certificate in the outer\n\t// Client Hello. If it returns a non-nil error, the handshake is aborted and\n\t// that error results.\n\t//\n\t// Unlike VerifyPeerCertificate and VerifyConnection, normal certificate\n\t// verification will not be performed before calling\n\t// EncryptedClientHelloRejectionVerify.\n\t//\n\t// If EncryptedClientHelloRejectionVerify is nil and ECH is rejected, the\n\t// roots in RootCAs will be used to verify the ECH providers public\n\t// certificate. VerifyPeerCertificate and VerifyConnection are not called\n\t// when ECH is rejected, even if set, and InsecureSkipVerify is ignored.\n\tEncryptedClientHelloRejectionVerify func(ConnectionState) error\n\n\t// mutex protects sessionTicketKeys and autoSessionTicketKeys.\n\tmutex sync.RWMutex\n\t// sessionTicketKeys contains zero or more ticket keys. If set, it means\n\t// the keys were set with SessionTicketKey or SetSessionTicketKeys. The\n\t// first key is used for new tickets and any subsequent keys can be used to\n\t// decrypt old tickets. The slice contents are not protected by the mutex\n\t// and are immutable.\n\tsessionTicketKeys []ticketKey\n\t// autoSessionTicketKeys is like sessionTicketKeys but is owned by the\n\t// auto-rotation logic. See Config.ticketKeys.\n\tautoSessionTicketKeys []ticketKey\n}\n\nconst (\n\t// ticketKeyLifetime is how long a ticket key remains valid and can be used to\n\t// resume a client connection.\n\tticketKeyLifetime = 7 * 24 * time.Hour // 7 days\n\n\t// ticketKeyRotation is how often the server should rotate the session ticket key\n\t// that is used for new tickets.\n\tticketKeyRotation = 24 * time.Hour\n)\n\n// ticketKey is the internal representation of a session ticket key.\ntype ticketKey struct {\n\taesKey  [16]byte\n\thmacKey [16]byte\n\t// created is the time at which this ticket key was created. See Config.ticketKeys.\n\tcreated time.Time\n}\n\n// ticketKeyFromBytes converts from the external representation of a session\n// ticket key to a ticketKey. Externally, session ticket keys are 32 random\n// bytes and this function expands that into sufficient name and key material.\nfunc (c *Config) ticketKeyFromBytes(b [32]byte) (key ticketKey) {\n\thashed := sha512.Sum512(b[:])\n\t// The first 16 bytes of the hash used to be exposed on the wire as a ticket\n\t// prefix. They MUST NOT be used as a secret. In the future, it would make\n\t// sense to use a proper KDF here, like HKDF with a fixed salt.\n\tconst legacyTicketKeyNameLen = 16\n\tcopy(key.aesKey[:], hashed[legacyTicketKeyNameLen:])\n\tcopy(key.hmacKey[:], hashed[legacyTicketKeyNameLen+len(key.aesKey):])\n\tkey.created = c.time()\n\treturn key\n}\n\n// maxSessionTicketLifetime is the maximum allowed lifetime of a TLS 1.3 session\n// ticket, and the lifetime we set for all tickets we send.\nconst maxSessionTicketLifetime = 7 * 24 * time.Hour\n\n// Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a [Config] that is\n// being used concurrently by a TLS client or server.\nfunc (c *Config) Clone() *Config {\n\tif c == nil {\n\t\treturn nil\n\t}\n\tc.mutex.RLock()\n\tdefer c.mutex.RUnlock()\n\treturn &Config{\n\t\tDialContext:                         c.DialContext,\n\t\tShow:                                c.Show,\n\t\tType:                                c.Type,\n\t\tDest:                                c.Dest,\n\t\tXver:                                c.Xver,\n\t\tServerNames:                         c.ServerNames,\n\t\tPrivateKey:                          c.PrivateKey,\n\t\tMinClientVer:                        c.MinClientVer,\n\t\tMaxClientVer:                        c.MaxClientVer,\n\t\tMaxTimeDiff:                         c.MaxTimeDiff,\n\t\tShortIds:                            c.ShortIds,\n\t\tRand:                                c.Rand,\n\t\tTime:                                c.Time,\n\t\tCertificates:                        c.Certificates,\n\t\tNameToCertificate:                   c.NameToCertificate,\n\t\tGetCertificate:                      c.GetCertificate,\n\t\tGetClientCertificate:                c.GetClientCertificate,\n\t\tGetConfigForClient:                  c.GetConfigForClient,\n\t\tVerifyPeerCertificate:               c.VerifyPeerCertificate,\n\t\tVerifyConnection:                    c.VerifyConnection,\n\t\tRootCAs:                             c.RootCAs,\n\t\tNextProtos:                          c.NextProtos,\n\t\tServerName:                          c.ServerName,\n\t\tClientAuth:                          c.ClientAuth,\n\t\tClientCAs:                           c.ClientCAs,\n\t\tInsecureSkipVerify:                  c.InsecureSkipVerify,\n\t\tCipherSuites:                        c.CipherSuites,\n\t\tPreferServerCipherSuites:            c.PreferServerCipherSuites,\n\t\tSessionTicketsDisabled:              c.SessionTicketsDisabled,\n\t\tSessionTicketKey:                    c.SessionTicketKey,\n\t\tClientSessionCache:                  c.ClientSessionCache,\n\t\tUnwrapSession:                       c.UnwrapSession,\n\t\tWrapSession:                         c.WrapSession,\n\t\tMinVersion:                          c.MinVersion,\n\t\tMaxVersion:                          c.MaxVersion,\n\t\tCurvePreferences:                    c.CurvePreferences,\n\t\tDynamicRecordSizingDisabled:         c.DynamicRecordSizingDisabled,\n\t\tRenegotiation:                       c.Renegotiation,\n\t\tKeyLogWriter:                        c.KeyLogWriter,\n\t\tEncryptedClientHelloConfigList:      c.EncryptedClientHelloConfigList,\n\t\tEncryptedClientHelloRejectionVerify: c.EncryptedClientHelloRejectionVerify,\n\t\tsessionTicketKeys:                   c.sessionTicketKeys,\n\t\tautoSessionTicketKeys:               c.autoSessionTicketKeys,\n\t}\n}\n\n// deprecatedSessionTicketKey is set as the prefix of SessionTicketKey if it was\n// randomized for backwards compatibility but is not in use.\nvar deprecatedSessionTicketKey = []byte(\"DEPRECATED\")\n\n// initLegacySessionTicketKeyRLocked ensures the legacy SessionTicketKey field is\n// randomized if empty, and that sessionTicketKeys is populated from it otherwise.\nfunc (c *Config) initLegacySessionTicketKeyRLocked() {\n\t// Don't write if SessionTicketKey is already defined as our deprecated string,\n\t// or if it is defined by the user but sessionTicketKeys is already set.\n\tif c.SessionTicketKey != [32]byte{} &&\n\t\t(bytes.HasPrefix(c.SessionTicketKey[:], deprecatedSessionTicketKey) || len(c.sessionTicketKeys) > 0) {\n\t\treturn\n\t}\n\n\t// We need to write some data, so get an exclusive lock and re-check any conditions.\n\tc.mutex.RUnlock()\n\tdefer c.mutex.RLock()\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\tif c.SessionTicketKey == [32]byte{} {\n\t\tif _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"tls: unable to generate random session ticket key: %v\", err))\n\t\t}\n\t\t// Write the deprecated prefix at the beginning so we know we created\n\t\t// it. This key with the DEPRECATED prefix isn't used as an actual\n\t\t// session ticket key, and is only randomized in case the application\n\t\t// reuses it for some reason.\n\t\tcopy(c.SessionTicketKey[:], deprecatedSessionTicketKey)\n\t} else if !bytes.HasPrefix(c.SessionTicketKey[:], deprecatedSessionTicketKey) && len(c.sessionTicketKeys) == 0 {\n\t\tc.sessionTicketKeys = []ticketKey{c.ticketKeyFromBytes(c.SessionTicketKey)}\n\t}\n\n}\n\n// ticketKeys returns the ticketKeys for this connection.\n// If configForClient has explicitly set keys, those will\n// be returned. Otherwise, the keys on c will be used and\n// may be rotated if auto-managed.\n// During rotation, any expired session ticket keys are deleted from\n// c.sessionTicketKeys. If the session ticket key that is currently\n// encrypting tickets (ie. the first ticketKey in c.sessionTicketKeys)\n// is not fresh, then a new session ticket key will be\n// created and prepended to c.sessionTicketKeys.\nfunc (c *Config) ticketKeys(configForClient *Config) []ticketKey {\n\t// If the ConfigForClient callback returned a Config with explicitly set\n\t// keys, use those, otherwise just use the original Config.\n\tif configForClient != nil {\n\t\tconfigForClient.mutex.RLock()\n\t\tif configForClient.SessionTicketsDisabled {\n\t\t\treturn nil\n\t\t}\n\t\tconfigForClient.initLegacySessionTicketKeyRLocked()\n\t\tif len(configForClient.sessionTicketKeys) != 0 {\n\t\t\tret := configForClient.sessionTicketKeys\n\t\t\tconfigForClient.mutex.RUnlock()\n\t\t\treturn ret\n\t\t}\n\t\tconfigForClient.mutex.RUnlock()\n\t}\n\n\tc.mutex.RLock()\n\tdefer c.mutex.RUnlock()\n\tif c.SessionTicketsDisabled {\n\t\treturn nil\n\t}\n\tc.initLegacySessionTicketKeyRLocked()\n\tif len(c.sessionTicketKeys) != 0 {\n\t\treturn c.sessionTicketKeys\n\t}\n\t// Fast path for the common case where the key is fresh enough.\n\tif len(c.autoSessionTicketKeys) > 0 && c.time().Sub(c.autoSessionTicketKeys[0].created) < ticketKeyRotation {\n\t\treturn c.autoSessionTicketKeys\n\t}\n\n\t// autoSessionTicketKeys are managed by auto-rotation.\n\tc.mutex.RUnlock()\n\tdefer c.mutex.RLock()\n\tc.mutex.Lock()\n\tdefer c.mutex.Unlock()\n\t// Re-check the condition in case it changed since obtaining the new lock.\n\tif len(c.autoSessionTicketKeys) == 0 || c.time().Sub(c.autoSessionTicketKeys[0].created) >= ticketKeyRotation {\n\t\tvar newKey [32]byte\n\t\tif _, err := io.ReadFull(c.rand(), newKey[:]); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"unable to generate random session ticket key: %v\", err))\n\t\t}\n\t\tvalid := make([]ticketKey, 0, len(c.autoSessionTicketKeys)+1)\n\t\tvalid = append(valid, c.ticketKeyFromBytes(newKey))\n\t\tfor _, k := range c.autoSessionTicketKeys {\n\t\t\t// While rotating the current key, also remove any expired ones.\n\t\t\tif c.time().Sub(k.created) < ticketKeyLifetime {\n\t\t\t\tvalid = append(valid, k)\n\t\t\t}\n\t\t}\n\t\tc.autoSessionTicketKeys = valid\n\t}\n\treturn c.autoSessionTicketKeys\n}\n\n// SetSessionTicketKeys updates the session ticket keys for a server.\n//\n// The first key will be used when creating new tickets, while all keys can be\n// used for decrypting tickets. It is safe to call this function while the\n// server is running in order to rotate the session ticket keys. The function\n// will panic if keys is empty.\n//\n// Calling this function will turn off automatic session ticket key rotation.\n//\n// If multiple servers are terminating connections for the same host they should\n// all have the same session ticket keys. If the session ticket keys leaks,\n// previously recorded and future TLS connections using those keys might be\n// compromised.\nfunc (c *Config) SetSessionTicketKeys(keys [][32]byte) {\n\tif len(keys) == 0 {\n\t\tpanic(\"tls: keys must have at least one key\")\n\t}\n\n\tnewKeys := make([]ticketKey, len(keys))\n\tfor i, bytes := range keys {\n\t\tnewKeys[i] = c.ticketKeyFromBytes(bytes)\n\t}\n\n\tc.mutex.Lock()\n\tc.sessionTicketKeys = newKeys\n\tc.mutex.Unlock()\n}\n\nfunc (c *Config) rand() io.Reader {\n\tr := c.Rand\n\tif r == nil {\n\t\treturn rand.Reader\n\t}\n\treturn r\n}\n\nfunc (c *Config) time() time.Time {\n\tt := c.Time\n\tif t == nil {\n\t\tt = time.Now\n\t}\n\treturn t()\n}\n\nfunc (c *Config) cipherSuites() []uint16 {\n\tif c.CipherSuites == nil {\n\t\tif needFIPS() {\n\t\t\treturn defaultCipherSuitesFIPS\n\t\t}\n\t\treturn defaultCipherSuites()\n\t}\n\tif needFIPS() {\n\t\tcipherSuites := slices.Clone(c.CipherSuites)\n\t\treturn slices.DeleteFunc(cipherSuites, func(id uint16) bool {\n\t\t\treturn !slices.Contains(defaultCipherSuitesFIPS, id)\n\t\t})\n\t}\n\treturn c.CipherSuites\n}\n\nvar supportedVersions = []uint16{\n\tVersionTLS13,\n\tVersionTLS12,\n\tVersionTLS11,\n\tVersionTLS10,\n}\n\n// roleClient and roleServer are meant to call supportedVersions and parents\n// with more readability at the callsite.\nconst roleClient = true\nconst roleServer = false\n\nfunc (c *Config) supportedVersions(isClient bool) []uint16 {\n\tversions := make([]uint16, 0, len(supportedVersions))\n\tfor _, v := range supportedVersions {\n\t\tif needFIPS() && !slices.Contains(defaultSupportedVersionsFIPS, v) {\n\t\t\tcontinue\n\t\t}\n\t\tif (c == nil || c.MinVersion == 0) && v < VersionTLS12 {\n\t\t\tcontinue\n\t\t}\n\t\tif isClient && c.EncryptedClientHelloConfigList != nil && v < VersionTLS13 {\n\t\t\tcontinue\n\t\t}\n\t\tif c != nil && c.MinVersion != 0 && v < c.MinVersion {\n\t\t\tcontinue\n\t\t}\n\t\tif c != nil && c.MaxVersion != 0 && v > c.MaxVersion {\n\t\t\tcontinue\n\t\t}\n\t\tversions = append(versions, v)\n\t}\n\treturn versions\n}\n\nfunc (c *Config) maxSupportedVersion(isClient bool) uint16 {\n\tsupportedVersions := c.supportedVersions(isClient)\n\tif len(supportedVersions) == 0 {\n\t\treturn 0\n\t}\n\treturn supportedVersions[0]\n}\n\n// supportedVersionsFromMax returns a list of supported versions derived from a\n// legacy maximum version value. Note that only versions supported by this\n// library are returned. Any newer peer will use supportedVersions anyway.\nfunc supportedVersionsFromMax(maxVersion uint16) []uint16 {\n\tversions := make([]uint16, 0, len(supportedVersions))\n\tfor _, v := range supportedVersions {\n\t\tif v > maxVersion {\n\t\t\tcontinue\n\t\t}\n\t\tversions = append(versions, v)\n\t}\n\treturn versions\n}\n\nfunc (c *Config) curvePreferences(version uint16) []CurveID {\n\tvar curvePreferences []CurveID\n\tif c != nil && len(c.CurvePreferences) != 0 {\n\t\tcurvePreferences = slices.Clone(c.CurvePreferences)\n\t\tif needFIPS() {\n\t\t\treturn slices.DeleteFunc(curvePreferences, func(c CurveID) bool {\n\t\t\t\treturn !slices.Contains(defaultCurvePreferencesFIPS, c)\n\t\t\t})\n\t\t}\n\t} else if needFIPS() {\n\t\tcurvePreferences = slices.Clone(defaultCurvePreferencesFIPS)\n\t} else {\n\t\tcurvePreferences = defaultCurvePreferences()\n\t}\n\tif version < VersionTLS13 {\n\t\treturn slices.DeleteFunc(curvePreferences, func(c CurveID) bool {\n\t\t\treturn c == x25519Kyber768Draft00\n\t\t})\n\t}\n\treturn curvePreferences\n}\n\nfunc (c *Config) supportsCurve(version uint16, curve CurveID) bool {\n\tfor _, cc := range c.curvePreferences(version) {\n\t\tif cc == curve {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// mutualVersion returns the protocol version to use given the advertised\n// versions of the peer. Priority is given to the peer preference order.\nfunc (c *Config) mutualVersion(isClient bool, peerVersions []uint16) (uint16, bool) {\n\tsupportedVersions := c.supportedVersions(isClient)\n\tfor _, peerVersion := range peerVersions {\n\t\tfor _, v := range supportedVersions {\n\t\t\tif v == peerVersion {\n\t\t\t\treturn v, true\n\t\t\t}\n\t\t}\n\t}\n\treturn 0, false\n}\n\n// errNoCertificates should be an internal detail,\n// but widely used packages access it using linkname.\n// Notable members of the hall of shame include:\n//   - github.com/xtls/xray-core\n//\n// Do not remove or change the type signature.\n// See go.dev/issue/67401.\n//\n//go:linkname errNoCertificates\nvar errNoCertificates = errors.New(\"tls: no certificates configured\")\n\n// getCertificate returns the best certificate for the given ClientHelloInfo,\n// defaulting to the first element of c.Certificates.\nfunc (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error) {\n\tif c.GetCertificate != nil &&\n\t\t(len(c.Certificates) == 0 || len(clientHello.ServerName) > 0) {\n\t\tcert, err := c.GetCertificate(clientHello)\n\t\tif cert != nil || err != nil {\n\t\t\treturn cert, err\n\t\t}\n\t}\n\n\tif len(c.Certificates) == 0 {\n\t\treturn nil, errNoCertificates\n\t}\n\n\tif len(c.Certificates) == 1 {\n\t\t// There's only one choice, so no point doing any work.\n\t\treturn &c.Certificates[0], nil\n\t}\n\n\tif c.NameToCertificate != nil {\n\t\tname := strings.ToLower(clientHello.ServerName)\n\t\tif cert, ok := c.NameToCertificate[name]; ok {\n\t\t\treturn cert, nil\n\t\t}\n\t\tif len(name) > 0 {\n\t\t\tlabels := strings.Split(name, \".\")\n\t\t\tlabels[0] = \"*\"\n\t\t\twildcardName := strings.Join(labels, \".\")\n\t\t\tif cert, ok := c.NameToCertificate[wildcardName]; ok {\n\t\t\t\treturn cert, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, cert := range c.Certificates {\n\t\tif err := clientHello.SupportsCertificate(&cert); err == nil {\n\t\t\treturn &cert, nil\n\t\t}\n\t}\n\n\t// If nothing matches, return the first certificate.\n\treturn &c.Certificates[0], nil\n}\n\n// SupportsCertificate returns nil if the provided certificate is supported by\n// the client that sent the ClientHello. Otherwise, it returns an error\n// describing the reason for the incompatibility.\n//\n// If this [ClientHelloInfo] was passed to a GetConfigForClient or GetCertificate\n// callback, this method will take into account the associated [Config]. Note that\n// if GetConfigForClient returns a different [Config], the change can't be\n// accounted for by this method.\n//\n// This function will call x509.ParseCertificate unless c.Leaf is set, which can\n// incur a significant performance cost.\nfunc (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error {\n\t// Note we don't currently support certificate_authorities nor\n\t// signature_algorithms_cert, and don't check the algorithms of the\n\t// signatures on the chain (which anyway are a SHOULD, see RFC 8446,\n\t// Section 4.4.2.2).\n\n\tconfig := chi.config\n\tif config == nil {\n\t\tconfig = &Config{}\n\t}\n\tvers, ok := config.mutualVersion(roleServer, chi.SupportedVersions)\n\tif !ok {\n\t\treturn errors.New(\"no mutually supported protocol versions\")\n\t}\n\n\t// If the client specified the name they are trying to connect to, the\n\t// certificate needs to be valid for it.\n\tif chi.ServerName != \"\" {\n\t\tx509Cert, err := c.leaf()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to parse certificate: %w\", err)\n\t\t}\n\t\tif err := x509Cert.VerifyHostname(chi.ServerName); err != nil {\n\t\t\treturn fmt.Errorf(\"certificate is not valid for requested server name: %w\", err)\n\t\t}\n\t}\n\n\t// supportsRSAFallback returns nil if the certificate and connection support\n\t// the static RSA key exchange, and unsupported otherwise. The logic for\n\t// supporting static RSA is completely disjoint from the logic for\n\t// supporting signed key exchanges, so we just check it as a fallback.\n\tsupportsRSAFallback := func(unsupported error) error {\n\t\t// TLS 1.3 dropped support for the static RSA key exchange.\n\t\tif vers == VersionTLS13 {\n\t\t\treturn unsupported\n\t\t}\n\t\t// The static RSA key exchange works by decrypting a challenge with the\n\t\t// RSA private key, not by signing, so check the PrivateKey implements\n\t\t// crypto.Decrypter, like *rsa.PrivateKey does.\n\t\tif priv, ok := c.PrivateKey.(crypto.Decrypter); ok {\n\t\t\tif _, ok := priv.Public().(*rsa.PublicKey); !ok {\n\t\t\t\treturn unsupported\n\t\t\t}\n\t\t} else {\n\t\t\treturn unsupported\n\t\t}\n\t\t// Finally, there needs to be a mutual cipher suite that uses the static\n\t\t// RSA key exchange instead of ECDHE.\n\t\trsaCipherSuite := selectCipherSuite(chi.CipherSuites, config.cipherSuites(), func(c *cipherSuite) bool {\n\t\t\tif c.flags&suiteECDHE != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif vers < VersionTLS12 && c.flags&suiteTLS12 != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tif rsaCipherSuite == nil {\n\t\t\treturn unsupported\n\t\t}\n\t\treturn nil\n\t}\n\n\t// If the client sent the signature_algorithms extension, ensure it supports\n\t// schemes we can use with this certificate and TLS version.\n\tif len(chi.SignatureSchemes) > 0 {\n\t\tif _, err := selectSignatureScheme(vers, c, chi.SignatureSchemes); err != nil {\n\t\t\treturn supportsRSAFallback(err)\n\t\t}\n\t}\n\n\t// In TLS 1.3 we are done because supported_groups is only relevant to the\n\t// ECDHE computation, point format negotiation is removed, cipher suites are\n\t// only relevant to the AEAD choice, and static RSA does not exist.\n\tif vers == VersionTLS13 {\n\t\treturn nil\n\t}\n\n\t// The only signed key exchange we support is ECDHE.\n\tif !supportsECDHE(config, vers, chi.SupportedCurves, chi.SupportedPoints) {\n\t\treturn supportsRSAFallback(errors.New(\"client doesn't support ECDHE, can only use legacy RSA key exchange\"))\n\t}\n\n\tvar ecdsaCipherSuite bool\n\tif priv, ok := c.PrivateKey.(crypto.Signer); ok {\n\t\tswitch pub := priv.Public().(type) {\n\t\tcase *ecdsa.PublicKey:\n\t\t\tvar curve CurveID\n\t\t\tswitch pub.Curve {\n\t\t\tcase elliptic.P256():\n\t\t\t\tcurve = CurveP256\n\t\t\tcase elliptic.P384():\n\t\t\t\tcurve = CurveP384\n\t\t\tcase elliptic.P521():\n\t\t\t\tcurve = CurveP521\n\t\t\tdefault:\n\t\t\t\treturn supportsRSAFallback(unsupportedCertificateError(c))\n\t\t\t}\n\t\t\tvar curveOk bool\n\t\t\tfor _, c := range chi.SupportedCurves {\n\t\t\t\tif c == curve && config.supportsCurve(vers, c) {\n\t\t\t\t\tcurveOk = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !curveOk {\n\t\t\t\treturn errors.New(\"client doesn't support certificate curve\")\n\t\t\t}\n\t\t\tecdsaCipherSuite = true\n\t\tcase ed25519.PublicKey:\n\t\t\tif vers < VersionTLS12 || len(chi.SignatureSchemes) == 0 {\n\t\t\t\treturn errors.New(\"connection doesn't support Ed25519\")\n\t\t\t}\n\t\t\tecdsaCipherSuite = true\n\t\tcase *rsa.PublicKey:\n\t\tdefault:\n\t\t\treturn supportsRSAFallback(unsupportedCertificateError(c))\n\t\t}\n\t} else {\n\t\treturn supportsRSAFallback(unsupportedCertificateError(c))\n\t}\n\n\t// Make sure that there is a mutually supported cipher suite that works with\n\t// this certificate. Cipher suite selection will then apply the logic in\n\t// reverse to pick it. See also serverHandshakeState.cipherSuiteOk.\n\tcipherSuite := selectCipherSuite(chi.CipherSuites, config.cipherSuites(), func(c *cipherSuite) bool {\n\t\tif c.flags&suiteECDHE == 0 {\n\t\t\treturn false\n\t\t}\n\t\tif c.flags&suiteECSign != 0 {\n\t\t\tif !ecdsaCipherSuite {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\tif ecdsaCipherSuite {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\tif vers < VersionTLS12 && c.flags&suiteTLS12 != 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t})\n\tif cipherSuite == nil {\n\t\treturn supportsRSAFallback(errors.New(\"client doesn't support any cipher suites compatible with the certificate\"))\n\t}\n\n\treturn nil\n}\n\n// SupportsCertificate returns nil if the provided certificate is supported by\n// the server that sent the CertificateRequest. Otherwise, it returns an error\n// describing the reason for the incompatibility.\nfunc (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error {\n\tif _, err := selectSignatureScheme(cri.Version, c, cri.SignatureSchemes); err != nil {\n\t\treturn err\n\t}\n\n\tif len(cri.AcceptableCAs) == 0 {\n\t\treturn nil\n\t}\n\n\tfor j, cert := range c.Certificate {\n\t\tx509Cert := c.Leaf\n\t\t// Parse the certificate if this isn't the leaf node, or if\n\t\t// chain.Leaf was nil.\n\t\tif j != 0 || x509Cert == nil {\n\t\t\tvar err error\n\t\t\tif x509Cert, err = x509.ParseCertificate(cert); err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to parse certificate #%d in the chain: %w\", j, err)\n\t\t\t}\n\t\t}\n\n\t\tfor _, ca := range cri.AcceptableCAs {\n\t\t\tif bytes.Equal(x509Cert.RawIssuer, ca) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\treturn errors.New(\"chain is not signed by an acceptable CA\")\n}\n\n// BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate\n// from the CommonName and SubjectAlternateName fields of each of the leaf\n// certificates.\n//\n// Deprecated: NameToCertificate only allows associating a single certificate\n// with a given name. Leave that field nil to let the library select the first\n// compatible chain from Certificates.\nfunc (c *Config) BuildNameToCertificate() {\n\tc.NameToCertificate = make(map[string]*Certificate)\n\tfor i := range c.Certificates {\n\t\tcert := &c.Certificates[i]\n\t\tx509Cert, err := cert.leaf()\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// If SANs are *not* present, some clients will consider the certificate\n\t\t// valid for the name in the Common Name.\n\t\tif x509Cert.Subject.CommonName != \"\" && len(x509Cert.DNSNames) == 0 {\n\t\t\tc.NameToCertificate[x509Cert.Subject.CommonName] = cert\n\t\t}\n\t\tfor _, san := range x509Cert.DNSNames {\n\t\t\tc.NameToCertificate[san] = cert\n\t\t}\n\t}\n}\n\nconst (\n\tkeyLogLabelTLS12           = \"CLIENT_RANDOM\"\n\tkeyLogLabelClientHandshake = \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\"\n\tkeyLogLabelServerHandshake = \"SERVER_HANDSHAKE_TRAFFIC_SECRET\"\n\tkeyLogLabelClientTraffic   = \"CLIENT_TRAFFIC_SECRET_0\"\n\tkeyLogLabelServerTraffic   = \"SERVER_TRAFFIC_SECRET_0\"\n)\n\nfunc (c *Config) writeKeyLog(label string, clientRandom, secret []byte) error {\n\tif c.KeyLogWriter == nil {\n\t\treturn nil\n\t}\n\n\tlogLine := fmt.Appendf(nil, \"%s %x %x\\n\", label, clientRandom, secret)\n\n\twriterMutex.Lock()\n\t_, err := c.KeyLogWriter.Write(logLine)\n\twriterMutex.Unlock()\n\n\treturn err\n}\n\n// writerMutex protects all KeyLogWriters globally. It is rarely enabled,\n// and is only for debugging, so a global mutex saves space.\nvar writerMutex sync.Mutex\n\n// A Certificate is a chain of one or more certificates, leaf first.\ntype Certificate struct {\n\tCertificate [][]byte\n\t// PrivateKey contains the private key corresponding to the public key in\n\t// Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.\n\t// For a server up to TLS 1.2, it can also implement crypto.Decrypter with\n\t// an RSA PublicKey.\n\tPrivateKey crypto.PrivateKey\n\t// SupportedSignatureAlgorithms is an optional list restricting what\n\t// signature algorithms the PrivateKey can be used for.\n\tSupportedSignatureAlgorithms []SignatureScheme\n\t// OCSPStaple contains an optional OCSP response which will be served\n\t// to clients that request it.\n\tOCSPStaple []byte\n\t// SignedCertificateTimestamps contains an optional list of Signed\n\t// Certificate Timestamps which will be served to clients that request it.\n\tSignedCertificateTimestamps [][]byte\n\t// Leaf is the parsed form of the leaf certificate, which may be initialized\n\t// using x509.ParseCertificate to reduce per-handshake processing. If nil,\n\t// the leaf certificate will be parsed as needed.\n\tLeaf *x509.Certificate\n}\n\n// leaf returns the parsed leaf certificate, either from c.Leaf or by parsing\n// the corresponding c.Certificate[0].\nfunc (c *Certificate) leaf() (*x509.Certificate, error) {\n\tif c.Leaf != nil {\n\t\treturn c.Leaf, nil\n\t}\n\treturn x509.ParseCertificate(c.Certificate[0])\n}\n\ntype handshakeMessage interface {\n\tmarshal() ([]byte, error)\n\tunmarshal([]byte) bool\n}\n\ntype handshakeMessageWithOriginalBytes interface {\n\thandshakeMessage\n\n\t// originalBytes should return the original bytes that were passed to\n\t// unmarshal to create the message. If the message was not produced by\n\t// unmarshal, it should return nil.\n\toriginalBytes() []byte\n}\n\n// lruSessionCache is a ClientSessionCache implementation that uses an LRU\n// caching strategy.\ntype lruSessionCache struct {\n\tsync.Mutex\n\n\tm        map[string]*list.Element\n\tq        *list.List\n\tcapacity int\n}\n\ntype lruSessionCacheEntry struct {\n\tsessionKey string\n\tstate      *ClientSessionState\n}\n\n// NewLRUClientSessionCache returns a [ClientSessionCache] with the given\n// capacity that uses an LRU strategy. If capacity is < 1, a default capacity\n// is used instead.\nfunc NewLRUClientSessionCache(capacity int) ClientSessionCache {\n\tconst defaultSessionCacheCapacity = 64\n\n\tif capacity < 1 {\n\t\tcapacity = defaultSessionCacheCapacity\n\t}\n\treturn &lruSessionCache{\n\t\tm:        make(map[string]*list.Element),\n\t\tq:        list.New(),\n\t\tcapacity: capacity,\n\t}\n}\n\n// Put adds the provided (sessionKey, cs) pair to the cache. If cs is nil, the entry\n// corresponding to sessionKey is removed from the cache instead.\nfunc (c *lruSessionCache) Put(sessionKey string, cs *ClientSessionState) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif elem, ok := c.m[sessionKey]; ok {\n\t\tif cs == nil {\n\t\t\tc.q.Remove(elem)\n\t\t\tdelete(c.m, sessionKey)\n\t\t} else {\n\t\t\tentry := elem.Value.(*lruSessionCacheEntry)\n\t\t\tentry.state = cs\n\t\t\tc.q.MoveToFront(elem)\n\t\t}\n\t\treturn\n\t}\n\n\tif c.q.Len() < c.capacity {\n\t\tentry := &lruSessionCacheEntry{sessionKey, cs}\n\t\tc.m[sessionKey] = c.q.PushFront(entry)\n\t\treturn\n\t}\n\n\telem := c.q.Back()\n\tentry := elem.Value.(*lruSessionCacheEntry)\n\tdelete(c.m, entry.sessionKey)\n\tentry.sessionKey = sessionKey\n\tentry.state = cs\n\tc.q.MoveToFront(elem)\n\tc.m[sessionKey] = elem\n}\n\n// Get returns the [ClientSessionState] value associated with a given key. It\n// returns (nil, false) if no value is found.\nfunc (c *lruSessionCache) Get(sessionKey string) (*ClientSessionState, bool) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tif elem, ok := c.m[sessionKey]; ok {\n\t\tc.q.MoveToFront(elem)\n\t\treturn elem.Value.(*lruSessionCacheEntry).state, true\n\t}\n\treturn nil, false\n}\n\nvar emptyConfig Config\n\nfunc defaultConfig() *Config {\n\treturn &emptyConfig\n}\n\nfunc unexpectedMessageError(wanted, got any) error {\n\treturn fmt.Errorf(\"tls: received unexpected handshake message of type %T when waiting for %T\", got, wanted)\n}\n\n// supportedSignatureAlgorithms returns the supported signature algorithms.\nfunc supportedSignatureAlgorithms() []SignatureScheme {\n\tif !needFIPS() {\n\t\treturn defaultSupportedSignatureAlgorithms\n\t}\n\treturn defaultSupportedSignatureAlgorithmsFIPS\n}\n\nfunc isSupportedSignatureAlgorithm(sigAlg SignatureScheme, supportedSignatureAlgorithms []SignatureScheme) bool {\n\tfor _, s := range supportedSignatureAlgorithms {\n\t\tif s == sigAlg {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// CertificateVerificationError is returned when certificate verification fails during the handshake.\ntype CertificateVerificationError struct {\n\t// UnverifiedCertificates and its contents should not be modified.\n\tUnverifiedCertificates []*x509.Certificate\n\tErr                    error\n}\n\nfunc (e *CertificateVerificationError) Error() string {\n\treturn fmt.Sprintf(\"tls: failed to verify certificate: %s\", e.Err)\n}\n\nfunc (e *CertificateVerificationError) Unwrap() error {\n\treturn e.Err\n}\n"
        },
        {
          "name": "common_string.go",
          "type": "blob",
          "size": 3.39453125,
          "content": "// Code generated by \"stringer -linecomment -type=SignatureScheme,CurveID,ClientAuthType -output=common_string.go\"; DO NOT EDIT.\n\npackage reality\n\nimport \"strconv\"\n\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[PKCS1WithSHA256-1025]\n\t_ = x[PKCS1WithSHA384-1281]\n\t_ = x[PKCS1WithSHA512-1537]\n\t_ = x[PSSWithSHA256-2052]\n\t_ = x[PSSWithSHA384-2053]\n\t_ = x[PSSWithSHA512-2054]\n\t_ = x[ECDSAWithP256AndSHA256-1027]\n\t_ = x[ECDSAWithP384AndSHA384-1283]\n\t_ = x[ECDSAWithP521AndSHA512-1539]\n\t_ = x[Ed25519-2055]\n\t_ = x[PKCS1WithSHA1-513]\n\t_ = x[ECDSAWithSHA1-515]\n}\n\nconst (\n\t_SignatureScheme_name_0 = \"PKCS1WithSHA1\"\n\t_SignatureScheme_name_1 = \"ECDSAWithSHA1\"\n\t_SignatureScheme_name_2 = \"PKCS1WithSHA256\"\n\t_SignatureScheme_name_3 = \"ECDSAWithP256AndSHA256\"\n\t_SignatureScheme_name_4 = \"PKCS1WithSHA384\"\n\t_SignatureScheme_name_5 = \"ECDSAWithP384AndSHA384\"\n\t_SignatureScheme_name_6 = \"PKCS1WithSHA512\"\n\t_SignatureScheme_name_7 = \"ECDSAWithP521AndSHA512\"\n\t_SignatureScheme_name_8 = \"PSSWithSHA256PSSWithSHA384PSSWithSHA512Ed25519\"\n)\n\nvar (\n\t_SignatureScheme_index_8 = [...]uint8{0, 13, 26, 39, 46}\n)\n\nfunc (i SignatureScheme) String() string {\n\tswitch {\n\tcase i == 513:\n\t\treturn _SignatureScheme_name_0\n\tcase i == 515:\n\t\treturn _SignatureScheme_name_1\n\tcase i == 1025:\n\t\treturn _SignatureScheme_name_2\n\tcase i == 1027:\n\t\treturn _SignatureScheme_name_3\n\tcase i == 1281:\n\t\treturn _SignatureScheme_name_4\n\tcase i == 1283:\n\t\treturn _SignatureScheme_name_5\n\tcase i == 1537:\n\t\treturn _SignatureScheme_name_6\n\tcase i == 1539:\n\t\treturn _SignatureScheme_name_7\n\tcase 2052 <= i && i <= 2055:\n\t\ti -= 2052\n\t\treturn _SignatureScheme_name_8[_SignatureScheme_index_8[i]:_SignatureScheme_index_8[i+1]]\n\tdefault:\n\t\treturn \"SignatureScheme(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[CurveP256-23]\n\t_ = x[CurveP384-24]\n\t_ = x[CurveP521-25]\n\t_ = x[X25519-29]\n\t_ = x[x25519Kyber768Draft00-25497]\n}\n\nconst (\n\t_CurveID_name_0 = \"CurveP256CurveP384CurveP521\"\n\t_CurveID_name_1 = \"X25519\"\n\t_CurveID_name_2 = \"X25519Kyber768Draft00\"\n)\n\nvar (\n\t_CurveID_index_0 = [...]uint8{0, 9, 18, 27}\n)\n\nfunc (i CurveID) String() string {\n\tswitch {\n\tcase 23 <= i && i <= 25:\n\t\ti -= 23\n\t\treturn _CurveID_name_0[_CurveID_index_0[i]:_CurveID_index_0[i+1]]\n\tcase i == 29:\n\t\treturn _CurveID_name_1\n\tcase i == 25497:\n\t\treturn _CurveID_name_2\n\tdefault:\n\t\treturn \"CurveID(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n}\nfunc _() {\n\t// An \"invalid array index\" compiler error signifies that the constant values have changed.\n\t// Re-run the stringer command to generate them again.\n\tvar x [1]struct{}\n\t_ = x[NoClientCert-0]\n\t_ = x[RequestClientCert-1]\n\t_ = x[RequireAnyClientCert-2]\n\t_ = x[VerifyClientCertIfGiven-3]\n\t_ = x[RequireAndVerifyClientCert-4]\n}\n\nconst _ClientAuthType_name = \"NoClientCertRequestClientCertRequireAnyClientCertVerifyClientCertIfGivenRequireAndVerifyClientCert\"\n\nvar _ClientAuthType_index = [...]uint8{0, 12, 29, 49, 72, 98}\n\nfunc (i ClientAuthType) String() string {\n\tif i < 0 || i >= ClientAuthType(len(_ClientAuthType_index)-1) {\n\t\treturn \"ClientAuthType(\" + strconv.FormatInt(int64(i), 10) + \")\"\n\t}\n\treturn _ClientAuthType_name[_ClientAuthType_index[i]:_ClientAuthType_index[i+1]]\n}\n"
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 53.580078125,
          "content": "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\n// TLS low level connection and record layer\n\npackage reality\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/cipher\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// A Conn represents a secured connection.\n// It implements the net.Conn interface.\ntype Conn struct {\n\tAuthKey       []byte\n\tClientVer     [3]byte\n\tClientTime    time.Time\n\tClientShortId [8]byte\n\n\t// constant\n\tconn        net.Conn\n\tisClient    bool\n\thandshakeFn func(context.Context) error // (*Conn).clientHandshake or serverHandshake\n\tquic *quicState // nil for non-QUIC connections\n\n\t// isHandshakeComplete is true if the connection is currently transferring\n\t// application data (i.e. is not currently processing a handshake).\n\t// isHandshakeComplete is true implies handshakeErr == nil.\n\tisHandshakeComplete atomic.Bool\n\t// constant after handshake; protected by handshakeMutex\n\thandshakeMutex sync.Mutex\n\thandshakeErr   error   // error resulting from handshake\n\tvers           uint16  // TLS version\n\thaveVers       bool    // version has been negotiated\n\tconfig         *Config // configuration passed to constructor\n\t// handshakes counts the number of handshakes performed on the\n\t// connection so far. If renegotiation is disabled then this is either\n\t// zero or one.\n\thandshakes       int\n\textMasterSecret  bool\n\tdidResume        bool // whether this connection was a session resumption\n\tdidHRR           bool // whether a HelloRetryRequest was sent/received\n\tcipherSuite      uint16\n\tcurveID          CurveID\n\tocspResponse     []byte   // stapled OCSP response\n\tscts             [][]byte // signed certificate timestamps from server\n\tpeerCertificates []*x509.Certificate\n\t// activeCertHandles contains the cache handles to certificates in\n\t// peerCertificates that are used to track active references.\n\tactiveCertHandles []*activeCert\n\t// verifiedChains contains the certificate chains that we built, as\n\t// opposed to the ones presented by the server.\n\tverifiedChains [][]*x509.Certificate\n\t// serverName contains the server name indicated by the client, if any.\n\tserverName string\n\t// secureRenegotiation is true if the server echoed the secure\n\t// renegotiation extension. (This is meaningless as a server because\n\t// renegotiation is not supported in that case.)\n\tsecureRenegotiation bool\n\t// ekm is a closure for exporting keying material.\n\tekm func(label string, context []byte, length int) ([]byte, error)\n\t// resumptionSecret is the resumption_master_secret for handling\n\t// or sending NewSessionTicket messages.\n\tresumptionSecret []byte\n\techAccepted      bool\n\n\t// ticketKeys is the set of active session ticket keys for this\n\t// connection. The first one is used to encrypt new tickets and\n\t// all are tried to decrypt tickets.\n\tticketKeys []ticketKey\n\n\t// clientFinishedIsFirst is true if the client sent the first Finished\n\t// message during the most recent handshake. This is recorded because\n\t// the first transmitted Finished message is the tls-unique\n\t// channel-binding value.\n\tclientFinishedIsFirst bool\n\n\t// closeNotifyErr is any error from sending the alertCloseNotify record.\n\tcloseNotifyErr error\n\t// closeNotifySent is true if the Conn attempted to send an\n\t// alertCloseNotify record.\n\tcloseNotifySent bool\n\n\t// clientFinished and serverFinished contain the Finished message sent\n\t// by the client or server in the most recent handshake. This is\n\t// retained to support the renegotiation extension and tls-unique\n\t// channel-binding.\n\tclientFinished [12]byte\n\tserverFinished [12]byte\n\n\t// clientProtocol is the negotiated ALPN protocol.\n\tclientProtocol string\n\n\t// input/output\n\tin, out   halfConn\n\trawInput  bytes.Buffer // raw input, starting with a record header\n\tinput     bytes.Reader // application data waiting to be read, from rawInput.Next\n\thand      bytes.Buffer // handshake data waiting to be read\n\tbuffering bool         // whether records are buffered in sendBuf\n\tsendBuf   []byte       // a buffer of records waiting to be sent\n\n\t// bytesSent counts the bytes of application data sent.\n\t// packetsSent counts packets.\n\tbytesSent   int64\n\tpacketsSent int64\n\n\t// retryCount counts the number of consecutive non-advancing records\n\t// received by Conn.readRecord. That is, records that neither advance the\n\t// handshake, nor deliver application data. Protected by in.Mutex.\n\tretryCount int\n\n\t// activeCall indicates whether Close has been call in the low bit.\n\t// the rest of the bits are the number of goroutines in Conn.Write.\n\tactiveCall atomic.Int32\n\n\ttmp [16]byte\n}\n\n// Access to net.Conn methods.\n// Cannot just embed net.Conn because that would\n// export the struct field too.\n\n// LocalAddr returns the local network address.\nfunc (c *Conn) LocalAddr() net.Addr {\n\treturn c.conn.LocalAddr()\n}\n\n// RemoteAddr returns the remote network address.\nfunc (c *Conn) RemoteAddr() net.Addr {\n\treturn c.conn.RemoteAddr()\n}\n\n// SetDeadline sets the read and write deadlines associated with the connection.\n// A zero value for t means [Conn.Read] and [Conn.Write] will not time out.\n// After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.\nfunc (c *Conn) SetDeadline(t time.Time) error {\n\treturn c.conn.SetDeadline(t)\n}\n\n// SetReadDeadline sets the read deadline on the underlying connection.\n// A zero value for t means [Conn.Read] will not time out.\nfunc (c *Conn) SetReadDeadline(t time.Time) error {\n\treturn c.conn.SetReadDeadline(t)\n}\n\n// SetWriteDeadline sets the write deadline on the underlying connection.\n// A zero value for t means [Conn.Write] will not time out.\n// After a [Conn.Write] has timed out, the TLS state is corrupt and all future writes will return the same error.\nfunc (c *Conn) SetWriteDeadline(t time.Time) error {\n\treturn c.conn.SetWriteDeadline(t)\n}\n\n// NetConn returns the underlying connection that is wrapped by c.\n// Note that writing to or reading from this connection directly will corrupt the\n// TLS session.\nfunc (c *Conn) NetConn() net.Conn {\n\treturn c.conn\n}\n\n// A halfConn represents one direction of the record layer\n// connection, either sending or receiving.\ntype halfConn struct {\n\thandshakeLen [7]int\n\thandshakeBuf []byte\n\n\tsync.Mutex\n\n\terr     error  // first permanent error\n\tversion uint16 // protocol version\n\tcipher  any    // cipher algorithm\n\tmac     hash.Hash\n\tseq     [8]byte // 64-bit sequence number\n\n\tscratchBuf [13]byte // to avoid allocs; interface method args escape\n\n\tnextCipher any       // next encryption state\n\tnextMac    hash.Hash // next MAC algorithm\n\n\tlevel         QUICEncryptionLevel // current QUIC encryption level\n\ttrafficSecret []byte              // current TLS 1.3 traffic secret\n}\n\ntype permanentError struct {\n\terr net.Error\n}\n\nfunc (e *permanentError) Error() string   { return e.err.Error() }\nfunc (e *permanentError) Unwrap() error   { return e.err }\nfunc (e *permanentError) Timeout() bool   { return e.err.Timeout() }\nfunc (e *permanentError) Temporary() bool { return false }\n\nfunc (hc *halfConn) setErrorLocked(err error) error {\n\tif e, ok := err.(net.Error); ok {\n\t\thc.err = &permanentError{err: e}\n\t} else {\n\t\thc.err = err\n\t}\n\treturn hc.err\n}\n\n// prepareCipherSpec sets the encryption and MAC states\n// that a subsequent changeCipherSpec will use.\nfunc (hc *halfConn) prepareCipherSpec(version uint16, cipher any, mac hash.Hash) {\n\thc.version = version\n\thc.nextCipher = cipher\n\thc.nextMac = mac\n}\n\n// changeCipherSpec changes the encryption and MAC states\n// to the ones previously passed to prepareCipherSpec.\nfunc (hc *halfConn) changeCipherSpec() error {\n\tif hc.nextCipher == nil || hc.version == VersionTLS13 {\n\t\treturn alertInternalError\n\t}\n\thc.cipher = hc.nextCipher\n\thc.mac = hc.nextMac\n\thc.nextCipher = nil\n\thc.nextMac = nil\n\tfor i := range hc.seq {\n\t\thc.seq[i] = 0\n\t}\n\treturn nil\n}\n\nfunc (hc *halfConn) setTrafficSecret(suite *cipherSuiteTLS13, level QUICEncryptionLevel, secret []byte) {\n\thc.trafficSecret = secret\n\thc.level = level\n\tkey, iv := suite.trafficKey(secret)\n\thc.cipher = suite.aead(key, iv)\n\tfor i := range hc.seq {\n\t\thc.seq[i] = 0\n\t}\n}\n\n// incSeq increments the sequence number.\nfunc (hc *halfConn) incSeq() {\n\tfor i := 7; i >= 0; i-- {\n\t\thc.seq[i]++\n\t\tif hc.seq[i] != 0 {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Not allowed to let sequence number wrap.\n\t// Instead, must renegotiate before it does.\n\t// Not likely enough to bother.\n\tpanic(\"TLS: sequence number wraparound\")\n}\n\n// explicitNonceLen returns the number of bytes of explicit nonce or IV included\n// in each record. Explicit nonces are present only in CBC modes after TLS 1.0\n// and in certain AEAD modes in TLS 1.2.\nfunc (hc *halfConn) explicitNonceLen() int {\n\tif hc.cipher == nil {\n\t\treturn 0\n\t}\n\n\tswitch c := hc.cipher.(type) {\n\tcase cipher.Stream:\n\t\treturn 0\n\tcase aead:\n\t\treturn c.explicitNonceLen()\n\tcase cbcMode:\n\t\t// TLS 1.1 introduced a per-record explicit IV to fix the BEAST attack.\n\t\tif hc.version >= VersionTLS11 {\n\t\t\treturn c.BlockSize()\n\t\t}\n\t\treturn 0\n\tdefault:\n\t\tpanic(\"unknown cipher type\")\n\t}\n}\n\n// extractPadding returns, in constant time, the length of the padding to remove\n// from the end of payload. It also returns a byte which is equal to 255 if the\n// padding was valid and 0 otherwise. See RFC 2246, Section 6.2.3.2.\nfunc extractPadding(payload []byte) (toRemove int, good byte) {\n\tif len(payload) < 1 {\n\t\treturn 0, 0\n\t}\n\n\tpaddingLen := payload[len(payload)-1]\n\tt := uint(len(payload)-1) - uint(paddingLen)\n\t// if len(payload) >= (paddingLen - 1) then the MSB of t is zero\n\tgood = byte(int32(^t) >> 31)\n\n\t// The maximum possible padding length plus the actual length field\n\ttoCheck := 256\n\t// The length of the padded data is public, so we can use an if here\n\tif toCheck > len(payload) {\n\t\ttoCheck = len(payload)\n\t}\n\n\tfor i := 0; i < toCheck; i++ {\n\t\tt := uint(paddingLen) - uint(i)\n\t\t// if i <= paddingLen then the MSB of t is zero\n\t\tmask := byte(int32(^t) >> 31)\n\t\tb := payload[len(payload)-1-i]\n\t\tgood &^= mask&paddingLen ^ mask&b\n\t}\n\n\t// We AND together the bits of good and replicate the result across\n\t// all the bits.\n\tgood &= good << 4\n\tgood &= good << 2\n\tgood &= good << 1\n\tgood = uint8(int8(good) >> 7)\n\n\t// Zero the padding length on error. This ensures any unchecked bytes\n\t// are included in the MAC. Otherwise, an attacker that could\n\t// distinguish MAC failures from padding failures could mount an attack\n\t// similar to POODLE in SSL 3.0: given a good ciphertext that uses a\n\t// full block's worth of padding, replace the final block with another\n\t// block. If the MAC check passed but the padding check failed, the\n\t// last byte of that block decrypted to the block size.\n\t//\n\t// See also macAndPaddingGood logic below.\n\tpaddingLen &= good\n\n\ttoRemove = int(paddingLen) + 1\n\treturn\n}\n\nfunc roundUp(a, b int) int {\n\treturn a + (b-a%b)%b\n}\n\n// cbcMode is an interface for block ciphers using cipher block chaining.\ntype cbcMode interface {\n\tcipher.BlockMode\n\tSetIV([]byte)\n}\n\n// decrypt authenticates and decrypts the record if protection is active at\n// this stage. The returned plaintext might overlap with the input.\nfunc (hc *halfConn) decrypt(record []byte) ([]byte, recordType, error) {\n\tvar plaintext []byte\n\ttyp := recordType(record[0])\n\tpayload := record[recordHeaderLen:]\n\n\t// In TLS 1.3, change_cipher_spec messages are to be ignored without being\n\t// decrypted. See RFC 8446, Appendix D.4.\n\tif hc.version == VersionTLS13 && typ == recordTypeChangeCipherSpec {\n\t\treturn payload, typ, nil\n\t}\n\n\tpaddingGood := byte(255)\n\tpaddingLen := 0\n\n\texplicitNonceLen := hc.explicitNonceLen()\n\n\tif hc.cipher != nil {\n\t\tswitch c := hc.cipher.(type) {\n\t\tcase cipher.Stream:\n\t\t\tc.XORKeyStream(payload, payload)\n\t\tcase aead:\n\t\t\tif len(payload) < explicitNonceLen {\n\t\t\t\treturn nil, 0, alertBadRecordMAC\n\t\t\t}\n\t\t\tnonce := payload[:explicitNonceLen]\n\t\t\tif len(nonce) == 0 {\n\t\t\t\tnonce = hc.seq[:]\n\t\t\t}\n\t\t\tpayload = payload[explicitNonceLen:]\n\n\t\t\tvar additionalData []byte\n\t\t\tif hc.version == VersionTLS13 {\n\t\t\t\tadditionalData = record[:recordHeaderLen]\n\t\t\t} else {\n\t\t\t\tadditionalData = append(hc.scratchBuf[:0], hc.seq[:]...)\n\t\t\t\tadditionalData = append(additionalData, record[:3]...)\n\t\t\t\tn := len(payload) - c.Overhead()\n\t\t\t\tadditionalData = append(additionalData, byte(n>>8), byte(n))\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tplaintext, err = c.Open(payload[:0], nonce, payload, additionalData)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, 0, alertBadRecordMAC\n\t\t\t}\n\t\tcase cbcMode:\n\t\t\tblockSize := c.BlockSize()\n\t\t\tminPayload := explicitNonceLen + roundUp(hc.mac.Size()+1, blockSize)\n\t\t\tif len(payload)%blockSize != 0 || len(payload) < minPayload {\n\t\t\t\treturn nil, 0, alertBadRecordMAC\n\t\t\t}\n\n\t\t\tif explicitNonceLen > 0 {\n\t\t\t\tc.SetIV(payload[:explicitNonceLen])\n\t\t\t\tpayload = payload[explicitNonceLen:]\n\t\t\t}\n\t\t\tc.CryptBlocks(payload, payload)\n\n\t\t\t// In a limited attempt to protect against CBC padding oracles like\n\t\t\t// Lucky13, the data past paddingLen (which is secret) is passed to\n\t\t\t// the MAC function as extra data, to be fed into the HMAC after\n\t\t\t// computing the digest. This makes the MAC roughly constant time as\n\t\t\t// long as the digest computation is constant time and does not\n\t\t\t// affect the subsequent write, modulo cache effects.\n\t\t\tpaddingLen, paddingGood = extractPadding(payload)\n\t\tdefault:\n\t\t\tpanic(\"unknown cipher type\")\n\t\t}\n\n\t\tif hc.version == VersionTLS13 {\n\t\t\tif typ != recordTypeApplicationData {\n\t\t\t\treturn nil, 0, alertUnexpectedMessage\n\t\t\t}\n\t\t\tif len(plaintext) > maxPlaintext+1 {\n\t\t\t\treturn nil, 0, alertRecordOverflow\n\t\t\t}\n\t\t\t// Remove padding and find the ContentType scanning from the end.\n\t\t\tfor i := len(plaintext) - 1; i >= 0; i-- {\n\t\t\t\tif plaintext[i] != 0 {\n\t\t\t\t\ttyp = recordType(plaintext[i])\n\t\t\t\t\tplaintext = plaintext[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif i == 0 {\n\t\t\t\t\treturn nil, 0, alertUnexpectedMessage\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tplaintext = payload\n\t}\n\n\tif hc.mac != nil {\n\t\tmacSize := hc.mac.Size()\n\t\tif len(payload) < macSize {\n\t\t\treturn nil, 0, alertBadRecordMAC\n\t\t}\n\n\t\tn := len(payload) - macSize - paddingLen\n\t\tn = subtle.ConstantTimeSelect(int(uint32(n)>>31), 0, n) // if n < 0 { n = 0 }\n\t\trecord[3] = byte(n >> 8)\n\t\trecord[4] = byte(n)\n\t\tremoteMAC := payload[n : n+macSize]\n\t\tlocalMAC := tls10MAC(hc.mac, hc.scratchBuf[:0], hc.seq[:], record[:recordHeaderLen], payload[:n], payload[n+macSize:])\n\n\t\t// This is equivalent to checking the MACs and paddingGood\n\t\t// separately, but in constant-time to prevent distinguishing\n\t\t// padding failures from MAC failures. Depending on what value\n\t\t// of paddingLen was returned on bad padding, distinguishing\n\t\t// bad MAC from bad padding can lead to an attack.\n\t\t//\n\t\t// See also the logic at the end of extractPadding.\n\t\tmacAndPaddingGood := subtle.ConstantTimeCompare(localMAC, remoteMAC) & int(paddingGood)\n\t\tif macAndPaddingGood != 1 {\n\t\t\treturn nil, 0, alertBadRecordMAC\n\t\t}\n\n\t\tplaintext = payload[:n]\n\t}\n\n\thc.incSeq()\n\treturn plaintext, typ, nil\n}\n\n// sliceForAppend extends the input slice by n bytes. head is the full extended\n// slice, while tail is the appended part. If the original slice has sufficient\n// capacity no allocation is performed.\nfunc sliceForAppend(in []byte, n int) (head, tail []byte) {\n\tif total := len(in) + n; cap(in) >= total {\n\t\thead = in[:total]\n\t} else {\n\t\thead = make([]byte, total)\n\t\tcopy(head, in)\n\t}\n\ttail = head[len(in):]\n\treturn\n}\n\n// encrypt encrypts payload, adding the appropriate nonce and/or MAC, and\n// appends it to record, which must already contain the record header.\nfunc (hc *halfConn) encrypt(record, payload []byte, rand io.Reader) ([]byte, error) {\n\tif hc.cipher == nil {\n\t\treturn append(record, payload...), nil\n\t}\n\n\tvar explicitNonce []byte\n\tif explicitNonceLen := hc.explicitNonceLen(); explicitNonceLen > 0 {\n\t\trecord, explicitNonce = sliceForAppend(record, explicitNonceLen)\n\t\tif _, isCBC := hc.cipher.(cbcMode); !isCBC && explicitNonceLen < 16 {\n\t\t\t// The AES-GCM construction in TLS has an explicit nonce so that the\n\t\t\t// nonce can be random. However, the nonce is only 8 bytes which is\n\t\t\t// too small for a secure, random nonce. Therefore we use the\n\t\t\t// sequence number as the nonce. The 3DES-CBC construction also has\n\t\t\t// an 8 bytes nonce but its nonces must be unpredictable (see RFC\n\t\t\t// 5246, Appendix F.3), forcing us to use randomness. That's not\n\t\t\t// 3DES' biggest problem anyway because the birthday bound on block\n\t\t\t// collision is reached first due to its similarly small block size\n\t\t\t// (see the Sweet32 attack).\n\t\t\tcopy(explicitNonce, hc.seq[:])\n\t\t} else {\n\t\t\tif _, err := io.ReadFull(rand, explicitNonce); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tvar dst []byte\n\tswitch c := hc.cipher.(type) {\n\tcase cipher.Stream:\n\t\tmac := tls10MAC(hc.mac, hc.scratchBuf[:0], hc.seq[:], record[:recordHeaderLen], payload, nil)\n\t\trecord, dst = sliceForAppend(record, len(payload)+len(mac))\n\t\tc.XORKeyStream(dst[:len(payload)], payload)\n\t\tc.XORKeyStream(dst[len(payload):], mac)\n\tcase aead:\n\t\tnonce := explicitNonce\n\t\tif len(nonce) == 0 {\n\t\t\tnonce = hc.seq[:]\n\t\t}\n\n\t\tif hc.version == VersionTLS13 {\n\t\t\trecord = append(record, payload...)\n\n\t\t\t// Encrypt the actual ContentType and replace the plaintext one.\n\t\t\trecord = append(record, record[0])\n\t\t\tpadding := 0\n\t\t\tif recordType(record[0]) == recordTypeHandshake && hc.handshakeLen[1] != 0 {\n\t\t\t\tswitch payload[0] {\n\t\t\t\tcase typeEncryptedExtensions:\n\t\t\t\t\tpadding = hc.handshakeLen[2]\n\t\t\t\t\thc.handshakeLen[2] = 0\n\t\t\t\tcase typeCertificate:\n\t\t\t\t\tpadding = hc.handshakeLen[3]\n\t\t\t\t\thc.handshakeLen[3] = 0\n\t\t\t\tcase typeCertificateVerify:\n\t\t\t\t\tpadding = hc.handshakeLen[4]\n\t\t\t\t\thc.handshakeLen[4] = 0\n\t\t\t\tcase typeFinished:\n\t\t\t\t\tpadding = hc.handshakeLen[5]\n\t\t\t\t\thc.handshakeLen[5] = 0\n\t\t\t\tcase typeNewSessionTicket:\n\t\t\t\t\tpadding = hc.handshakeLen[6]\n\t\t\t\t\thc.handshakeLen[6] = 0\n\t\t\t\t\trecord[5] = byte(recordTypeApplicationData)\n\t\t\t\t\trecord[6] = 0\n\t\t\t\t}\n\t\t\t\tpadding -= len(record) + c.Overhead()\n\t\t\t\tif padding < 0 {\n\t\t\t\t\treturn nil, fmt.Errorf(\"payload[0]: %v, padding: %v\", payload[0], padding)\n\t\t\t\t}\n\t\t\t\trecord = append(record, empty[:padding]...)\n\t\t\t}\n\t\t\trecord[0] = byte(recordTypeApplicationData)\n\n\t\t\tn := len(record) + c.Overhead() - recordHeaderLen\n\t\t\trecord[3] = byte(n >> 8)\n\t\t\trecord[4] = byte(n)\n\n\t\t\trecord = c.Seal(record[:recordHeaderLen],\n\t\t\t\tnonce, record[recordHeaderLen:], record[:recordHeaderLen])\n\t\t} else {\n\t\t\tadditionalData := append(hc.scratchBuf[:0], hc.seq[:]...)\n\t\t\tadditionalData = append(additionalData, record[:recordHeaderLen]...)\n\t\t\trecord = c.Seal(record, nonce, payload, additionalData)\n\t\t}\n\tcase cbcMode:\n\t\tmac := tls10MAC(hc.mac, hc.scratchBuf[:0], hc.seq[:], record[:recordHeaderLen], payload, nil)\n\t\tblockSize := c.BlockSize()\n\t\tplaintextLen := len(payload) + len(mac)\n\t\tpaddingLen := blockSize - plaintextLen%blockSize\n\t\trecord, dst = sliceForAppend(record, plaintextLen+paddingLen)\n\t\tcopy(dst, payload)\n\t\tcopy(dst[len(payload):], mac)\n\t\tfor i := plaintextLen; i < len(dst); i++ {\n\t\t\tdst[i] = byte(paddingLen - 1)\n\t\t}\n\t\tif len(explicitNonce) > 0 {\n\t\t\tc.SetIV(explicitNonce)\n\t\t}\n\t\tc.CryptBlocks(dst, dst)\n\tdefault:\n\t\tpanic(\"unknown cipher type\")\n\t}\n\n\t// Update length to include nonce, MAC and any block padding needed.\n\tn := len(record) - recordHeaderLen\n\trecord[3] = byte(n >> 8)\n\trecord[4] = byte(n)\n\thc.incSeq()\n\n\treturn record, nil\n}\n\n// RecordHeaderError is returned when a TLS record header is invalid.\ntype RecordHeaderError struct {\n\t// Msg contains a human readable string that describes the error.\n\tMsg string\n\t// RecordHeader contains the five bytes of TLS record header that\n\t// triggered the error.\n\tRecordHeader [5]byte\n\t// Conn provides the underlying net.Conn in the case that a client\n\t// sent an initial handshake that didn't look like TLS.\n\t// It is nil if there's already been a handshake or a TLS alert has\n\t// been written to the connection.\n\tConn net.Conn\n}\n\nfunc (e RecordHeaderError) Error() string { return \"tls: \" + e.Msg }\n\nfunc (c *Conn) newRecordHeaderError(conn net.Conn, msg string) (err RecordHeaderError) {\n\terr.Msg = msg\n\terr.Conn = conn\n\tcopy(err.RecordHeader[:], c.rawInput.Bytes())\n\treturn err\n}\n\nfunc (c *Conn) readRecord() error {\n\treturn c.readRecordOrCCS(false)\n}\n\nfunc (c *Conn) readChangeCipherSpec() error {\n\treturn c.readRecordOrCCS(true)\n}\n\n// readRecordOrCCS reads one or more TLS records from the connection and\n// updates the record layer state. Some invariants:\n//   - c.in must be locked\n//   - c.input must be empty\n//\n// During the handshake one and only one of the following will happen:\n//   - c.hand grows\n//   - c.in.changeCipherSpec is called\n//   - an error is returned\n//\n// After the handshake one and only one of the following will happen:\n//   - c.hand grows\n//   - c.input is set\n//   - an error is returned\nfunc (c *Conn) readRecordOrCCS(expectChangeCipherSpec bool) error {\n\tif c.in.err != nil {\n\t\treturn c.in.err\n\t}\n\thandshakeComplete := c.isHandshakeComplete.Load()\n\n\t// This function modifies c.rawInput, which owns the c.input memory.\n\tif c.input.Len() != 0 {\n\t\treturn c.in.setErrorLocked(errors.New(\"tls: internal error: attempted to read record with pending application data\"))\n\t}\n\tc.input.Reset(nil)\n\n\tif c.quic != nil {\n\t\treturn c.in.setErrorLocked(errors.New(\"tls: internal error: attempted to read record with QUIC transport\"))\n\t}\n\n\t// Read header, payload.\n\tif err := c.readFromUntil(c.conn, recordHeaderLen); err != nil {\n\t\t// RFC 8446, Section 6.1 suggests that EOF without an alertCloseNotify\n\t\t// is an error, but popular web sites seem to do this, so we accept it\n\t\t// if and only if at the record boundary.\n\t\tif err == io.ErrUnexpectedEOF && c.rawInput.Len() == 0 {\n\t\t\terr = io.EOF\n\t\t}\n\t\tif e, ok := err.(net.Error); !ok || !e.Temporary() {\n\t\t\tc.in.setErrorLocked(err)\n\t\t}\n\t\treturn err\n\t}\n\thdr := c.rawInput.Bytes()[:recordHeaderLen]\n\ttyp := recordType(hdr[0])\n\n\t// No valid TLS record has a type of 0x80, however SSLv2 handshakes\n\t// start with a uint16 length where the MSB is set and the first record\n\t// is always < 256 bytes long. Therefore typ == 0x80 strongly suggests\n\t// an SSLv2 client.\n\tif !handshakeComplete && typ == 0x80 {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn c.in.setErrorLocked(c.newRecordHeaderError(nil, \"unsupported SSLv2 handshake received\"))\n\t}\n\n\tvers := uint16(hdr[1])<<8 | uint16(hdr[2])\n\texpectedVers := c.vers\n\tif expectedVers == VersionTLS13 {\n\t\t// All TLS 1.3 records are expected to have 0x0303 (1.2) after\n\t\t// the initial hello (RFC 8446 Section 5.1).\n\t\texpectedVers = VersionTLS12\n\t}\n\tn := int(hdr[3])<<8 | int(hdr[4])\n\tif c.haveVers && vers != expectedVers {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\tmsg := fmt.Sprintf(\"received record with version %x when expecting version %x\", vers, expectedVers)\n\t\treturn c.in.setErrorLocked(c.newRecordHeaderError(nil, msg))\n\t}\n\tif !c.haveVers {\n\t\t// First message, be extra suspicious: this might not be a TLS\n\t\t// client. Bail out before reading a full 'body', if possible.\n\t\t// The current max version is 3.3 so if the version is >= 16.0,\n\t\t// it's probably not real.\n\t\tif (typ != recordTypeAlert && typ != recordTypeHandshake) || vers >= 0x1000 {\n\t\t\treturn c.in.setErrorLocked(c.newRecordHeaderError(c.conn, \"first record does not look like a TLS handshake\"))\n\t\t}\n\t}\n\tif c.vers == VersionTLS13 && n > maxCiphertextTLS13 || n > maxCiphertext {\n\t\tc.sendAlert(alertRecordOverflow)\n\t\tmsg := fmt.Sprintf(\"oversized record received with length %d\", n)\n\t\treturn c.in.setErrorLocked(c.newRecordHeaderError(nil, msg))\n\t}\n\tif err := c.readFromUntil(c.conn, recordHeaderLen+n); err != nil {\n\t\tif e, ok := err.(net.Error); !ok || !e.Temporary() {\n\t\t\tc.in.setErrorLocked(err)\n\t\t}\n\t\treturn err\n\t}\n\n\t// Process message.\n\trecord := c.rawInput.Next(recordHeaderLen + n)\n\tdata, typ, err := c.in.decrypt(record)\n\tif err != nil {\n\t\treturn c.in.setErrorLocked(c.sendAlert(err.(alert)))\n\t}\n\tif len(data) > maxPlaintext {\n\t\treturn c.in.setErrorLocked(c.sendAlert(alertRecordOverflow))\n\t}\n\n\t// Application Data messages are always protected.\n\tif c.in.cipher == nil && typ == recordTypeApplicationData {\n\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t}\n\n\tif typ != recordTypeAlert && typ != recordTypeChangeCipherSpec && len(data) > 0 {\n\t\t// This is a state-advancing message: reset the retry count.\n\t\tc.retryCount = 0\n\t}\n\n\t// Handshake messages MUST NOT be interleaved with other record types in TLS 1.3.\n\tif c.vers == VersionTLS13 && typ != recordTypeHandshake && c.hand.Len() > 0 {\n\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t}\n\n\tswitch typ {\n\tdefault:\n\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\n\tcase recordTypeAlert:\n\t\tif c.quic != nil {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\t\tif len(data) != 2 {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\t\tif alert(data[1]) == alertCloseNotify {\n\t\t\treturn c.in.setErrorLocked(io.EOF)\n\t\t}\n\t\tif c.vers == VersionTLS13 {\n\t\t\treturn c.in.setErrorLocked(&net.OpError{Op: \"remote error\", Err: alert(data[1])})\n\t\t}\n\t\tswitch data[0] {\n\t\tcase alertLevelWarning:\n\t\t\t// Drop the record on the floor and retry.\n\t\t\treturn c.retryReadRecord(expectChangeCipherSpec)\n\t\tcase alertLevelError:\n\t\t\treturn c.in.setErrorLocked(&net.OpError{Op: \"remote error\", Err: alert(data[1])})\n\t\tdefault:\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\n\tcase recordTypeChangeCipherSpec:\n\t\tif len(data) != 1 || data[0] != 1 {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertDecodeError))\n\t\t}\n\t\t// Handshake messages are not allowed to fragment across the CCS.\n\t\tif c.hand.Len() > 0 {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\t\t// In TLS 1.3, change_cipher_spec records are ignored until the\n\t\t// Finished. See RFC 8446, Appendix D.4. Note that according to Section\n\t\t// 5, a server can send a ChangeCipherSpec before its ServerHello, when\n\t\t// c.vers is still unset. That's not useful though and suspicious if the\n\t\t// server then selects a lower protocol version, so don't allow that.\n\t\tif c.vers == VersionTLS13 && !handshakeComplete {\n\t\t\treturn c.retryReadRecord(expectChangeCipherSpec)\n\t\t}\n\t\tif !expectChangeCipherSpec {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\t\tif err := c.in.changeCipherSpec(); err != nil {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(err.(alert)))\n\t\t}\n\n\tcase recordTypeApplicationData:\n\t\tif !handshakeComplete || expectChangeCipherSpec {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\t\t// Some OpenSSL servers send empty records in order to randomize the\n\t\t// CBC IV. Ignore a limited number of empty records.\n\t\tif len(data) == 0 {\n\t\t\treturn c.retryReadRecord(expectChangeCipherSpec)\n\t\t}\n\t\t// Note that data is owned by c.rawInput, following the Next call above,\n\t\t// to avoid copying the plaintext. This is safe because c.rawInput is\n\t\t// not read from or written to until c.input is drained.\n\t\tc.input.Reset(data)\n\n\tcase recordTypeHandshake:\n\t\tif len(data) == 0 || expectChangeCipherSpec {\n\t\t\treturn c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t\t}\n\t\tc.hand.Write(data)\n\t}\n\n\treturn nil\n}\n\n// retryReadRecord recurs into readRecordOrCCS to drop a non-advancing record, like\n// a warning alert, empty application_data, or a change_cipher_spec in TLS 1.3.\nfunc (c *Conn) retryReadRecord(expectChangeCipherSpec bool) error {\n\tc.retryCount++\n\tif c.retryCount > maxUselessRecords {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn c.in.setErrorLocked(errors.New(\"tls: too many ignored records\"))\n\t}\n\treturn c.readRecordOrCCS(expectChangeCipherSpec)\n}\n\n// atLeastReader reads from R, stopping with EOF once at least N bytes have been\n// read. It is different from an io.LimitedReader in that it doesn't cut short\n// the last Read call, and in that it considers an early EOF an error.\ntype atLeastReader struct {\n\tR io.Reader\n\tN int64\n}\n\nfunc (r *atLeastReader) Read(p []byte) (int, error) {\n\tif r.N <= 0 {\n\t\treturn 0, io.EOF\n\t}\n\tn, err := r.R.Read(p)\n\tr.N -= int64(n) // won't underflow unless len(p) >= n > 9223372036854775809\n\tif r.N > 0 && err == io.EOF {\n\t\treturn n, io.ErrUnexpectedEOF\n\t}\n\tif r.N <= 0 && err == nil {\n\t\treturn n, io.EOF\n\t}\n\treturn n, err\n}\n\n// readFromUntil reads from r into c.rawInput until c.rawInput contains\n// at least n bytes or else returns an error.\nfunc (c *Conn) readFromUntil(r io.Reader, n int) error {\n\tif c.rawInput.Len() >= n {\n\t\treturn nil\n\t}\n\tneeds := n - c.rawInput.Len()\n\t// There might be extra input waiting on the wire. Make a best effort\n\t// attempt to fetch it so that it can be used in (*Conn).Read to\n\t// \"predict\" closeNotify alerts.\n\tc.rawInput.Grow(needs + bytes.MinRead)\n\t_, err := c.rawInput.ReadFrom(&atLeastReader{r, int64(needs)})\n\treturn err\n}\n\n// sendAlertLocked sends a TLS alert message.\nfunc (c *Conn) sendAlertLocked(err alert) error {\n\tif c.quic != nil {\n\t\treturn c.out.setErrorLocked(&net.OpError{Op: \"local error\", Err: err})\n\t}\n\tswitch err {\n\tcase alertNoRenegotiation, alertCloseNotify:\n\t\tc.tmp[0] = alertLevelWarning\n\tdefault:\n\t\tc.tmp[0] = alertLevelError\n\t}\n\tc.tmp[1] = byte(err)\n\n\t_, writeErr := c.writeRecordLocked(recordTypeAlert, c.tmp[0:2])\n\tif err == alertCloseNotify {\n\t\t// closeNotify is a special case in that it isn't an error.\n\t\treturn writeErr\n\t}\n\n\treturn c.out.setErrorLocked(&net.OpError{Op: \"local error\", Err: err})\n}\n\n// sendAlert sends a TLS alert message.\nfunc (c *Conn) sendAlert(err alert) error {\n\tc.out.Lock()\n\tdefer c.out.Unlock()\n\treturn c.sendAlertLocked(err)\n}\n\nconst (\n\t// tcpMSSEstimate is a conservative estimate of the TCP maximum segment\n\t// size (MSS). A constant is used, rather than querying the kernel for\n\t// the actual MSS, to avoid complexity. The value here is the IPv6\n\t// minimum MTU (1280 bytes) minus the overhead of an IPv6 header (40\n\t// bytes) and a TCP header with timestamps (32 bytes).\n\ttcpMSSEstimate = 1208\n\n\t// recordSizeBoostThreshold is the number of bytes of application data\n\t// sent after which the TLS record size will be increased to the\n\t// maximum.\n\trecordSizeBoostThreshold = 128 * 1024\n)\n\n// maxPayloadSizeForWrite returns the maximum TLS payload size to use for the\n// next application data record. There is the following trade-off:\n//\n//   - For latency-sensitive applications, such as web browsing, each TLS\n//     record should fit in one TCP segment.\n//   - For throughput-sensitive applications, such as large file transfers,\n//     larger TLS records better amortize framing and encryption overheads.\n//\n// A simple heuristic that works well in practice is to use small records for\n// the first 1MB of data, then use larger records for subsequent data, and\n// reset back to smaller records after the connection becomes idle. See \"High\n// Performance Web Networking\", Chapter 4, or:\n// https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/\n//\n// In the interests of simplicity and determinism, this code does not attempt\n// to reset the record size once the connection is idle, however.\nfunc (c *Conn) maxPayloadSizeForWrite(typ recordType) int {\n\tif c.config.DynamicRecordSizingDisabled || typ != recordTypeApplicationData {\n\t\treturn maxPlaintext\n\t}\n\n\tif c.bytesSent >= recordSizeBoostThreshold {\n\t\treturn maxPlaintext\n\t}\n\n\t// Subtract TLS overheads to get the maximum payload size.\n\tpayloadBytes := tcpMSSEstimate - recordHeaderLen - c.out.explicitNonceLen()\n\tif c.out.cipher != nil {\n\t\tswitch ciph := c.out.cipher.(type) {\n\t\tcase cipher.Stream:\n\t\t\tpayloadBytes -= c.out.mac.Size()\n\t\tcase cipher.AEAD:\n\t\t\tpayloadBytes -= ciph.Overhead()\n\t\tcase cbcMode:\n\t\t\tblockSize := ciph.BlockSize()\n\t\t\t// The payload must fit in a multiple of blockSize, with\n\t\t\t// room for at least one padding byte.\n\t\t\tpayloadBytes = (payloadBytes & ^(blockSize - 1)) - 1\n\t\t\t// The MAC is appended before padding so affects the\n\t\t\t// payload size directly.\n\t\t\tpayloadBytes -= c.out.mac.Size()\n\t\tdefault:\n\t\t\tpanic(\"unknown cipher type\")\n\t\t}\n\t}\n\tif c.vers == VersionTLS13 {\n\t\tpayloadBytes-- // encrypted ContentType\n\t}\n\n\t// Allow packet growth in arithmetic progression up to max.\n\tpkt := c.packetsSent\n\tc.packetsSent++\n\tif pkt > 1000 {\n\t\treturn maxPlaintext // avoid overflow in multiply below\n\t}\n\n\tn := payloadBytes * int(pkt+1)\n\tif n > maxPlaintext {\n\t\tn = maxPlaintext\n\t}\n\treturn n\n}\n\nfunc (c *Conn) write(data []byte) (int, error) {\n\tif c.buffering {\n\t\tc.sendBuf = append(c.sendBuf, data...)\n\t\treturn len(data), nil\n\t}\n\n\tn, err := c.conn.Write(data)\n\tc.bytesSent += int64(n)\n\treturn n, err\n}\n\nfunc (c *Conn) flush() (int, error) {\n\tif len(c.sendBuf) == 0 {\n\t\treturn 0, nil\n\t}\n\n\tn, err := c.conn.Write(c.sendBuf)\n\tc.bytesSent += int64(n)\n\tc.sendBuf = nil\n\tc.buffering = false\n\treturn n, err\n}\n\n// outBufPool pools the record-sized scratch buffers used by writeRecordLocked.\nvar outBufPool = sync.Pool{\n\tNew: func() any {\n\t\treturn new([]byte)\n\t},\n}\n\n// writeRecordLocked writes a TLS record with the given type and payload to the\n// connection and updates the record layer state.\nfunc (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error) {\n\tif c.quic != nil {\n\t\tif typ != recordTypeHandshake {\n\t\t\treturn 0, errors.New(\"tls: internal error: sending non-handshake message to QUIC transport\")\n\t\t}\n\t\tc.quicWriteCryptoData(c.out.level, data)\n\t\tif !c.buffering {\n\t\t\tif _, err := c.flush(); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t\treturn len(data), nil\n\t}\n\n\toutBufPtr := outBufPool.Get().(*[]byte)\n\toutBuf := *outBufPtr\n\tdefer func() {\n\t\t// You might be tempted to simplify this by just passing &outBuf to Put,\n\t\t// but that would make the local copy of the outBuf slice header escape\n\t\t// to the heap, causing an allocation. Instead, we keep around the\n\t\t// pointer to the slice header returned by Get, which is already on the\n\t\t// heap, and overwrite and return that.\n\t\t*outBufPtr = outBuf\n\t\toutBufPool.Put(outBufPtr)\n\t}()\n\n\tvar n int\n\tfor len(data) > 0 {\n\t\tm := len(data)\n\t\tif maxPayload := c.maxPayloadSizeForWrite(typ); m > maxPayload {\n\t\t\tm = maxPayload\n\t\t}\n\n\t\t_, outBuf = sliceForAppend(outBuf[:0], recordHeaderLen)\n\t\toutBuf[0] = byte(typ)\n\t\tvers := c.vers\n\t\tif vers == 0 {\n\t\t\t// Some TLS servers fail if the record version is\n\t\t\t// greater than TLS 1.0 for the initial ClientHello.\n\t\t\tvers = VersionTLS10\n\t\t} else if vers == VersionTLS13 {\n\t\t\t// TLS 1.3 froze the record layer version to 1.2.\n\t\t\t// See RFC 8446, Section 5.1.\n\t\t\tvers = VersionTLS12\n\t\t}\n\t\toutBuf[1] = byte(vers >> 8)\n\t\toutBuf[2] = byte(vers)\n\t\toutBuf[3] = byte(m >> 8)\n\t\toutBuf[4] = byte(m)\n\n\t\tvar err error\n\t\toutBuf, err = c.out.encrypt(outBuf, data[:m], c.config.rand())\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tif _, err := c.write(outBuf); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tn += m\n\t\tdata = data[m:]\n\t}\n\n\tif typ == recordTypeChangeCipherSpec && c.vers != VersionTLS13 {\n\t\tif err := c.out.changeCipherSpec(); err != nil {\n\t\t\treturn n, c.sendAlertLocked(err.(alert))\n\t\t}\n\t}\n\n\treturn n, nil\n}\n\n// writeHandshakeRecord writes a handshake message to the connection and updates\n// the record layer state. If transcript is non-nil the marshaled message is\n// written to it.\nfunc (c *Conn) writeHandshakeRecord(msg handshakeMessage, transcript transcriptHash) (int, error) {\n\tc.out.Lock()\n\tdefer c.out.Unlock()\n\n\tdata, err := msg.marshal()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif transcript != nil {\n\t\ttranscript.Write(data)\n\t}\n\n\tif c.out.handshakeBuf != nil && len(data) > 0 && data[0] != typeServerHello {\n\t\tc.out.handshakeBuf = append(c.out.handshakeBuf, data...)\n\t\tif data[0] != typeFinished {\n\t\t\treturn len(data), nil\n\t\t}\n\t\tdata = c.out.handshakeBuf\n\t\tc.out.handshakeBuf = nil\n\t}\n\n\treturn c.writeRecordLocked(recordTypeHandshake, data)\n}\n\n// writeRecord writes a TLS record with the given type and payload to the\n// connection and updates the record layer state.\n// ONLY used by REALITY\nfunc (c *Conn) writeRecord(typ recordType, data []byte) (int, error) {\n\tc.out.Lock()\n\tdefer c.out.Unlock()\n\n\tif typ == recordTypeHandshake && c.out.handshakeBuf != nil &&\n\t\tlen(data) > 0 && data[0] != typeServerHello {\n\t\tc.out.handshakeBuf = append(c.out.handshakeBuf, data...)\n\t\tif data[0] != typeFinished {\n\t\t\treturn len(data), nil\n\t\t}\n\t\tdata = c.out.handshakeBuf\n\t\tc.out.handshakeBuf = nil\n\t}\n\n\treturn c.writeRecordLocked(typ, data)\n}\n\n// writeChangeCipherRecord writes a ChangeCipherSpec message to the connection and\n// updates the record layer state.\nfunc (c *Conn) writeChangeCipherRecord() error {\n\tc.out.Lock()\n\tdefer c.out.Unlock()\n\t_, err := c.writeRecordLocked(recordTypeChangeCipherSpec, []byte{1})\n\treturn err\n}\n\n// readHandshakeBytes reads handshake data until c.hand contains at least n bytes.\nfunc (c *Conn) readHandshakeBytes(n int) error {\n\tif c.quic != nil {\n\t\treturn c.quicReadHandshakeBytes(n)\n\t}\n\tfor c.hand.Len() < n {\n\t\tif err := c.readRecord(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// readHandshake reads the next handshake message from\n// the record layer. If transcript is non-nil, the message\n// is written to the passed transcriptHash.\nfunc (c *Conn) readHandshake(transcript transcriptHash) (any, error) {\n\tif err := c.readHandshakeBytes(4); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := c.hand.Bytes()\n\n\tmaxHandshakeSize := maxHandshake\n\t// hasVers indicates we're past the first message, forcing someone trying to\n\t// make us just allocate a large buffer to at least do the initial part of\n\t// the handshake first.\n\tif c.haveVers && data[0] == typeCertificate {\n\t\t// Since certificate messages are likely to be the only messages that\n\t\t// can be larger than maxHandshake, we use a special limit for just\n\t\t// those messages.\n\t\tmaxHandshakeSize = maxHandshakeCertificateMsg\n\t}\n\n\tn := int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n\tif n > maxHandshakeSize {\n\t\tc.sendAlertLocked(alertInternalError)\n\t\treturn nil, c.in.setErrorLocked(fmt.Errorf(\"tls: handshake message of length %d bytes exceeds maximum of %d bytes\", n, maxHandshakeSize))\n\t}\n\tif err := c.readHandshakeBytes(4 + n); err != nil {\n\t\treturn nil, err\n\t}\n\tdata = c.hand.Next(4 + n)\n\treturn c.unmarshalHandshakeMessage(data, transcript)\n}\n\nfunc (c *Conn) unmarshalHandshakeMessage(data []byte, transcript transcriptHash) (handshakeMessage, error) {\n\tvar m handshakeMessage\n\tswitch data[0] {\n\tcase typeHelloRequest:\n\t\tm = new(helloRequestMsg)\n\tcase typeClientHello:\n\t\tm = new(clientHelloMsg)\n\tcase typeServerHello:\n\t\tm = new(serverHelloMsg)\n\tcase typeNewSessionTicket:\n\t\tif c.vers == VersionTLS13 {\n\t\t\tm = new(newSessionTicketMsgTLS13)\n\t\t} else {\n\t\t\tm = new(newSessionTicketMsg)\n\t\t}\n\tcase typeCertificate:\n\t\tif c.vers == VersionTLS13 {\n\t\t\tm = new(certificateMsgTLS13)\n\t\t} else {\n\t\t\tm = new(certificateMsg)\n\t\t}\n\tcase typeCertificateRequest:\n\t\tif c.vers == VersionTLS13 {\n\t\t\tm = new(certificateRequestMsgTLS13)\n\t\t} else {\n\t\t\tm = &certificateRequestMsg{\n\t\t\t\thasSignatureAlgorithm: c.vers >= VersionTLS12,\n\t\t\t}\n\t\t}\n\tcase typeCertificateStatus:\n\t\tm = new(certificateStatusMsg)\n\tcase typeServerKeyExchange:\n\t\tm = new(serverKeyExchangeMsg)\n\tcase typeServerHelloDone:\n\t\tm = new(serverHelloDoneMsg)\n\tcase typeClientKeyExchange:\n\t\tm = new(clientKeyExchangeMsg)\n\tcase typeCertificateVerify:\n\t\tm = &certificateVerifyMsg{\n\t\t\thasSignatureAlgorithm: c.vers >= VersionTLS12,\n\t\t}\n\tcase typeFinished:\n\t\tm = new(finishedMsg)\n\tcase typeEncryptedExtensions:\n\t\tm = new(encryptedExtensionsMsg)\n\tcase typeEndOfEarlyData:\n\t\tm = new(endOfEarlyDataMsg)\n\tcase typeKeyUpdate:\n\t\tm = new(keyUpdateMsg)\n\tdefault:\n\t\treturn nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t}\n\n\t// The handshake message unmarshalers\n\t// expect to be able to keep references to data,\n\t// so pass in a fresh copy that won't be overwritten.\n\tdata = append([]byte(nil), data...)\n\n\tif !m.unmarshal(data) {\n\t\treturn nil, c.in.setErrorLocked(c.sendAlert(alertUnexpectedMessage))\n\t}\n\n\tif transcript != nil {\n\t\ttranscript.Write(data)\n\t}\n\t\n\treturn m, nil\n}\n\nvar (\n\terrShutdown = errors.New(\"tls: protocol is shutdown\")\n)\n\n// Write writes data to the connection.\n//\n// As Write calls [Conn.Handshake], in order to prevent indefinite blocking a deadline\n// must be set for both [Conn.Read] and Write before Write is called when the handshake\n// has not yet completed. See [Conn.SetDeadline], [Conn.SetReadDeadline], and\n// [Conn.SetWriteDeadline].\nfunc (c *Conn) Write(b []byte) (int, error) {\n\t// interlock with Close below\n\tfor {\n\t\tx := c.activeCall.Load()\n\t\tif x&1 != 0 {\n\t\t\treturn 0, net.ErrClosed\n\t\t}\n\t\tif c.activeCall.CompareAndSwap(x, x+2) {\n\t\t\tbreak\n\t\t}\n\t}\n\tdefer c.activeCall.Add(-2)\n\n\tif err := c.Handshake(); err != nil {\n\t\treturn 0, err\n\t}\n\n\tc.out.Lock()\n\tdefer c.out.Unlock()\n\n\tif err := c.out.err; err != nil {\n\t\treturn 0, err\n\t}\n\n\tif !c.isHandshakeComplete.Load() {\n\t\treturn 0, alertInternalError\n\t}\n\n\tif c.closeNotifySent {\n\t\treturn 0, errShutdown\n\t}\n\n\t// TLS 1.0 is susceptible to a chosen-plaintext\n\t// attack when using block mode ciphers due to predictable IVs.\n\t// This can be prevented by splitting each Application Data\n\t// record into two records, effectively randomizing the IV.\n\t//\n\t// https://www.openssl.org/~bodo/tls-cbc.txt\n\t// https://bugzilla.mozilla.org/show_bug.cgi?id=665814\n\t// https://www.imperialviolet.org/2012/01/15/beastfollowup.html\n\n\tvar m int\n\tif len(b) > 1 && c.vers == VersionTLS10 {\n\t\tif _, ok := c.out.cipher.(cipher.BlockMode); ok {\n\t\t\tn, err := c.writeRecordLocked(recordTypeApplicationData, b[:1])\n\t\t\tif err != nil {\n\t\t\t\treturn n, c.out.setErrorLocked(err)\n\t\t\t}\n\t\t\tm, b = 1, b[1:]\n\t\t}\n\t}\n\n\tn, err := c.writeRecordLocked(recordTypeApplicationData, b)\n\treturn n + m, c.out.setErrorLocked(err)\n}\n\n// handleRenegotiation processes a HelloRequest handshake message.\nfunc (c *Conn) handleRenegotiation() error {\n\tif c.vers == VersionTLS13 {\n\t\treturn errors.New(\"tls: internal error: unexpected renegotiation\")\n\t}\n\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thelloReq, ok := msg.(*helloRequestMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(helloReq, msg)\n\t}\n\n\tif !c.isClient {\n\t\treturn c.sendAlert(alertNoRenegotiation)\n\t}\n\n\tswitch c.config.Renegotiation {\n\tcase RenegotiateNever:\n\t\treturn c.sendAlert(alertNoRenegotiation)\n\tcase RenegotiateOnceAsClient:\n\t\tif c.handshakes > 1 {\n\t\t\treturn c.sendAlert(alertNoRenegotiation)\n\t\t}\n\tcase RenegotiateFreelyAsClient:\n\t\t// Ok.\n\tdefault:\n\t\tc.sendAlert(alertInternalError)\n\t\treturn errors.New(\"tls: unknown Renegotiation value\")\n\t}\n\n\tc.handshakeMutex.Lock()\n\tdefer c.handshakeMutex.Unlock()\n\n\tc.isHandshakeComplete.Store(false)\n\tif c.handshakeErr = c.clientHandshake(context.Background()); c.handshakeErr == nil {\n\t\tc.handshakes++\n\t}\n\treturn c.handshakeErr\n}\n\n// handlePostHandshakeMessage processes a handshake message arrived after the\n// handshake is complete. Up to TLS 1.2, it indicates the start of a renegotiation.\nfunc (c *Conn) handlePostHandshakeMessage() error {\n\tif c.vers != VersionTLS13 {\n\t\treturn c.handleRenegotiation()\n\t}\n\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.retryCount++\n\tif c.retryCount > maxUselessRecords {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn c.in.setErrorLocked(errors.New(\"tls: too many non-advancing records\"))\n\t}\n\n\tswitch msg := msg.(type) {\n\tcase *newSessionTicketMsgTLS13:\n\t\treturn c.handleNewSessionTicket(msg)\n\tcase *keyUpdateMsg:\n\t\treturn c.handleKeyUpdate(msg)\n\t}\n\t// The QUIC layer is supposed to treat an unexpected post-handshake CertificateRequest\n\t// as a QUIC-level PROTOCOL_VIOLATION error (RFC 9001, Section 4.4). Returning an\n\t// unexpected_message alert here doesn't provide it with enough information to distinguish\n\t// this condition from other unexpected messages. This is probably fine.\n\tc.sendAlert(alertUnexpectedMessage)\n\treturn fmt.Errorf(\"tls: received unexpected handshake message of type %T\", msg)\n}\n\nfunc (c *Conn) handleKeyUpdate(keyUpdate *keyUpdateMsg) error {\n\tif c.quic != nil {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn c.in.setErrorLocked(errors.New(\"tls: received unexpected key update message\"))\n\t}\n\n\tcipherSuite := cipherSuiteTLS13ByID(c.cipherSuite)\n\tif cipherSuite == nil {\n\t\treturn c.in.setErrorLocked(c.sendAlert(alertInternalError))\n\t}\n\n\tnewSecret := cipherSuite.nextTrafficSecret(c.in.trafficSecret)\n\tc.in.setTrafficSecret(cipherSuite, QUICEncryptionLevelInitial, newSecret)\n\n\tif keyUpdate.updateRequested {\n\t\tc.out.Lock()\n\t\tdefer c.out.Unlock()\n\n\t\tmsg := &keyUpdateMsg{}\n\t\tmsgBytes, err := msg.marshal()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = c.writeRecordLocked(recordTypeHandshake, msgBytes)\n\t\tif err != nil {\n\t\t\t// Surface the error at the next write.\n\t\t\tc.out.setErrorLocked(err)\n\t\t\treturn nil\n\t\t}\n\n\t\tnewSecret := cipherSuite.nextTrafficSecret(c.out.trafficSecret)\n\t\tc.out.setTrafficSecret(cipherSuite, QUICEncryptionLevelInitial, newSecret)\n\t}\n\n\treturn nil\n}\n\n// Read reads data from the connection.\n//\n// As Read calls [Conn.Handshake], in order to prevent indefinite blocking a deadline\n// must be set for both Read and [Conn.Write] before Read is called when the handshake\n// has not yet completed. See [Conn.SetDeadline], [Conn.SetReadDeadline], and\n// [Conn.SetWriteDeadline].\nfunc (c *Conn) Read(b []byte) (int, error) {\n\tif err := c.Handshake(); err != nil {\n\t\treturn 0, err\n\t}\n\tif len(b) == 0 {\n\t\t// Put this after Handshake, in case people were calling\n\t\t// Read(nil) for the side effect of the Handshake.\n\t\treturn 0, nil\n\t}\n\n\tc.in.Lock()\n\tdefer c.in.Unlock()\n\n\tfor c.input.Len() == 0 {\n\t\tif err := c.readRecord(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tfor c.hand.Len() > 0 {\n\t\t\tif err := c.handlePostHandshakeMessage(); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t}\n\t}\n\n\tn, _ := c.input.Read(b)\n\n\t// If a close-notify alert is waiting, read it so that we can return (n,\n\t// EOF) instead of (n, nil), to signal to the HTTP response reading\n\t// goroutine that the connection is now closed. This eliminates a race\n\t// where the HTTP response reading goroutine would otherwise not observe\n\t// the EOF until its next read, by which time a client goroutine might\n\t// have already tried to reuse the HTTP connection for a new request.\n\t// See https://golang.org/cl/76400046 and https://golang.org/issue/3514\n\tif n != 0 && c.input.Len() == 0 && c.rawInput.Len() > 0 &&\n\t\trecordType(c.rawInput.Bytes()[0]) == recordTypeAlert {\n\t\tif err := c.readRecord(); err != nil {\n\t\t\treturn n, err // will be io.EOF on closeNotify\n\t\t}\n\t}\n\n\treturn n, nil\n}\n\n// Close closes the connection.\nfunc (c *Conn) Close() error {\n\t// Interlock with Conn.Write above.\n\tvar x int32\n\tfor {\n\t\tx = c.activeCall.Load()\n\t\tif x&1 != 0 {\n\t\t\treturn net.ErrClosed\n\t\t}\n\t\tif c.activeCall.CompareAndSwap(x, x|1) {\n\t\t\tbreak\n\t\t}\n\t}\n\tif x != 0 {\n\t\t// io.Writer and io.Closer should not be used concurrently.\n\t\t// If Close is called while a Write is currently in-flight,\n\t\t// interpret that as a sign that this Close is really just\n\t\t// being used to break the Write and/or clean up resources and\n\t\t// avoid sending the alertCloseNotify, which may block\n\t\t// waiting on handshakeMutex or the c.out mutex.\n\t\treturn c.conn.Close()\n\t}\n\n\tvar alertErr error\n\tif c.isHandshakeComplete.Load() {\n\t\tif err := c.closeNotify(); err != nil {\n\t\t\talertErr = fmt.Errorf(\"tls: failed to send closeNotify alert (but connection was closed anyway): %w\", err)\n\t\t}\n\t}\n\n\tif err := c.conn.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn alertErr\n}\n\nvar errEarlyCloseWrite = errors.New(\"tls: CloseWrite called before handshake complete\")\n\n// CloseWrite shuts down the writing side of the connection. It should only be\n// called once the handshake has completed and does not call CloseWrite on the\n// underlying connection. Most callers should just use [Conn.Close].\nfunc (c *Conn) CloseWrite() error {\n\tif !c.isHandshakeComplete.Load() {\n\t\treturn errEarlyCloseWrite\n\t}\n\n\treturn c.closeNotify()\n}\n\nfunc (c *Conn) closeNotify() error {\n\tc.out.Lock()\n\tdefer c.out.Unlock()\n\n\tif !c.closeNotifySent {\n\t\t// Set a Write Deadline to prevent possibly blocking forever.\n\t\tc.SetWriteDeadline(time.Now().Add(time.Second * 5))\n\t\tc.closeNotifyErr = c.sendAlertLocked(alertCloseNotify)\n\t\tc.closeNotifySent = true\n\t\t// Any subsequent writes will fail.\n\t\tc.SetWriteDeadline(time.Now())\n\t}\n\treturn c.closeNotifyErr\n}\n\n// Handshake runs the client or server handshake\n// protocol if it has not yet been run.\n//\n// Most uses of this package need not call Handshake explicitly: the\n// first [Conn.Read] or [Conn.Write] will call it automatically.\n//\n// For control over canceling or setting a timeout on a handshake, use\n// [Conn.HandshakeContext] or the [Dialer]'s DialContext method instead.\n//\n// In order to avoid denial of service attacks, the maximum RSA key size allowed\n// in certificates sent by either the TLS server or client is limited to 8192\n// bits. This limit can be overridden by setting tlsmaxrsasize in the GODEBUG\n// environment variable (e.g. GODEBUG=tlsmaxrsasize=4096).\nfunc (c *Conn) Handshake() error {\n\treturn c.HandshakeContext(context.Background())\n}\n\n// HandshakeContext runs the client or server handshake\n// protocol if it has not yet been run.\n//\n// The provided Context must be non-nil. If the context is canceled before\n// the handshake is complete, the handshake is interrupted and an error is returned.\n// Once the handshake has completed, cancellation of the context will not affect the\n// connection.\n//\n// Most uses of this package need not call HandshakeContext explicitly: the\n// first [Conn.Read] or [Conn.Write] will call it automatically.\nfunc (c *Conn) HandshakeContext(ctx context.Context) error {\n\t// Delegate to unexported method for named return\n\t// without confusing documented signature.\n\treturn c.handshakeContext(ctx)\n}\n\nfunc (c *Conn) handshakeContext(ctx context.Context) (ret error) {\n\t// Fast sync/atomic-based exit if there is no handshake in flight and the\n\t// last one succeeded without an error. Avoids the expensive context setup\n\t// and mutex for most Read and Write calls.\n\tif c.isHandshakeComplete.Load() {\n\t\treturn nil\n\t}\n\n\thandshakeCtx, cancel := context.WithCancel(ctx)\n\t// Note: defer this before starting the \"interrupter\" goroutine\n\t// so that we can tell the difference between the input being canceled and\n\t// this cancellation. In the former case, we need to close the connection.\n\tdefer cancel()\n\n\tif c.quic != nil {\n\t\tc.quic.cancelc = handshakeCtx.Done()\n\t\tc.quic.cancel = cancel\n\t} else if ctx.Done() != nil {\n\t\t// Start the \"interrupter\" goroutine, if this context might be canceled.\n\t\t// (The background context cannot).\n\t\t//\n\t\t// The interrupter goroutine waits for the input context to be done and\n\t\t// closes the connection if this happens before the function returns.\n\t\tdone := make(chan struct{})\n\t\tinterruptRes := make(chan error, 1)\n\t\tdefer func() {\n\t\t\tclose(done)\n\t\t\tif ctxErr := <-interruptRes; ctxErr != nil {\n\t\t\t\t// Return context error to user.\n\t\t\t\tret = ctxErr\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-handshakeCtx.Done():\n\t\t\t\t// Close the connection, discarding the error\n\t\t\t\t_ = c.conn.Close()\n\t\t\t\tinterruptRes <- handshakeCtx.Err()\n\t\t\tcase <-done:\n\t\t\t\tinterruptRes <- nil\n\t\t\t}\n\t\t}()\n\t}\n\n\tc.handshakeMutex.Lock()\n\tdefer c.handshakeMutex.Unlock()\n\n\tif err := c.handshakeErr; err != nil {\n\t\treturn err\n\t}\n\tif c.isHandshakeComplete.Load() {\n\t\treturn nil\n\t}\n\n\tc.in.Lock()\n\tdefer c.in.Unlock()\n\n\tc.handshakeErr = c.handshakeFn(handshakeCtx)\n\tif c.handshakeErr == nil {\n\t\tc.handshakes++\n\t} else {\n\t\t// If an error occurred during the handshake try to flush the\n\t\t// alert that might be left in the buffer.\n\t\tc.flush()\n\t}\n\n\tif c.handshakeErr == nil && !c.isHandshakeComplete.Load() {\n\t\tc.handshakeErr = errors.New(\"tls: internal error: handshake should have had a result\")\n\t}\n\tif c.handshakeErr != nil && c.isHandshakeComplete.Load() {\n\t\tpanic(\"tls: internal error: handshake returned an error but is marked successful\")\n\t}\n\n\tif c.quic != nil {\n\t\tif c.handshakeErr == nil {\n\t\t\tc.quicHandshakeComplete()\n\t\t\t// Provide the 1-RTT read secret now that the handshake is complete.\n\t\t\t// The QUIC layer MUST NOT decrypt 1-RTT packets prior to completing\n\t\t\t// the handshake (RFC 9001, Section 5.7).\n\t\t\tc.quicSetReadSecret(QUICEncryptionLevelApplication, c.cipherSuite, c.in.trafficSecret)\n\t\t} else {\n\t\t\tvar a alert\n\t\t\tc.out.Lock()\n\t\t\tif !errors.As(c.out.err, &a) {\n\t\t\t\ta = alertInternalError\n\t\t\t}\n\t\t\tc.out.Unlock()\n\t\t\t// Return an error which wraps both the handshake error and\n\t\t\t// any alert error we may have sent, or alertInternalError\n\t\t\t// if we didn't send an alert.\n\t\t\t// Truncate the text of the alert to 0 characters.\n\t\t\tc.handshakeErr = fmt.Errorf(\"%w%.0w\", c.handshakeErr, AlertError(a))\n\t\t}\n\t\tclose(c.quic.blockedc)\n\t\tclose(c.quic.signalc)\n\t}\n\n\treturn c.handshakeErr\n}\n\n// ConnectionState returns basic TLS details about the connection.\nfunc (c *Conn) ConnectionState() ConnectionState {\n\tc.handshakeMutex.Lock()\n\tdefer c.handshakeMutex.Unlock()\n\treturn c.connectionStateLocked()\n}\n\nfunc (c *Conn) connectionStateLocked() ConnectionState {\n\tvar state ConnectionState\n\tstate.HandshakeComplete = c.isHandshakeComplete.Load()\n\tstate.Version = c.vers\n\tstate.NegotiatedProtocol = c.clientProtocol\n\tstate.DidResume = c.didResume\n\tstate.testingOnlyDidHRR = c.didHRR\n\t// c.curveID is not set on TLS 1.0–1.2 resumptions. Fix that before exposing it.\n\tstate.testingOnlyCurveID = c.curveID\n\tstate.NegotiatedProtocolIsMutual = true\n\tstate.ServerName = c.serverName\n\tstate.CipherSuite = c.cipherSuite\n\tstate.PeerCertificates = c.peerCertificates\n\tstate.VerifiedChains = c.verifiedChains\n\tstate.SignedCertificateTimestamps = c.scts\n\tstate.OCSPResponse = c.ocspResponse\n\tif (!c.didResume || c.extMasterSecret) && c.vers != VersionTLS13 {\n\t\tif c.clientFinishedIsFirst {\n\t\t\tstate.TLSUnique = c.clientFinished[:]\n\t\t} else {\n\t\t\tstate.TLSUnique = c.serverFinished[:]\n\t\t}\n\t}\n\tif c.config.Renegotiation != RenegotiateNever {\n\t\tstate.ekm = noEKMBecauseRenegotiation\n\t} else if c.vers != VersionTLS13 && !c.extMasterSecret {\n\t\tstate.ekm = func(label string, context []byte, length int) ([]byte, error) {\n\t\t\t// if ekmgodebug.Value() == \"1\" {\n\t\t\t// \tekmgodebug.IncNonDefault()\n\t\t\t// \treturn c.ekm(label, context, length)\n\t\t\t// }\n\t\t\treturn noEKMBecauseNoEMS(label, context, length)\n\t\t}\n\t} else {\n\t\tstate.ekm = c.ekm\n\t}\n\tstate.ECHAccepted = c.echAccepted\n\treturn state\n}\n\n// OCSPResponse returns the stapled OCSP response from the TLS server, if\n// any. (Only valid for client connections.)\nfunc (c *Conn) OCSPResponse() []byte {\n\tc.handshakeMutex.Lock()\n\tdefer c.handshakeMutex.Unlock()\n\n\treturn c.ocspResponse\n}\n\n// VerifyHostname checks that the peer certificate chain is valid for\n// connecting to host. If so, it returns nil; if not, it returns an error\n// describing the problem.\nfunc (c *Conn) VerifyHostname(host string) error {\n\tc.handshakeMutex.Lock()\n\tdefer c.handshakeMutex.Unlock()\n\tif !c.isClient {\n\t\treturn errors.New(\"tls: VerifyHostname called on TLS server connection\")\n\t}\n\tif !c.isHandshakeComplete.Load() {\n\t\treturn errors.New(\"tls: handshake has not yet been performed\")\n\t}\n\tif len(c.verifiedChains) == 0 {\n\t\treturn errors.New(\"tls: handshake did not verify certificate chain\")\n\t}\n\treturn c.peerCertificates[0].VerifyHostname(host)\n}\n"
        },
        {
          "name": "defaults.go",
          "type": "blob",
          "size": 3.77734375,
          "content": "// Copyright 2024 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage reality\n\nimport (\n\t\"slices\"\n\t_ \"unsafe\" // for linkname\n)\n\n// Defaults are collected in this file to allow distributions to more easily patch\n// them to apply local policies.\n\n//var tlskyber = godebug.New(\"tlskyber\")\n\nfunc defaultCurvePreferences() []CurveID {\n\tif false {\n\t\treturn []CurveID{X25519, CurveP256, CurveP384, CurveP521}\n\t}\n\t// For now, x25519Kyber768Draft00 must always be followed by X25519.\n\treturn []CurveID{x25519Kyber768Draft00, X25519, CurveP256, CurveP384, CurveP521}\n}\n\n// defaultSupportedSignatureAlgorithms contains the signature and hash algorithms that\n// the code advertises as supported in a TLS 1.2+ ClientHello and in a TLS 1.2+\n// CertificateRequest. The two fields are merged to match with TLS 1.3.\n// Note that in TLS 1.2, the ECDSA algorithms are not constrained to P-256, etc.\nvar defaultSupportedSignatureAlgorithms = []SignatureScheme{\n\tPSSWithSHA256,\n\tECDSAWithP256AndSHA256,\n\tEd25519,\n\tPSSWithSHA384,\n\tPSSWithSHA512,\n\tPKCS1WithSHA256,\n\tPKCS1WithSHA384,\n\tPKCS1WithSHA512,\n\tECDSAWithP384AndSHA384,\n\tECDSAWithP521AndSHA512,\n\tPKCS1WithSHA1,\n\tECDSAWithSHA1,\n}\n\n//var tlsrsakex = godebug.New(\"tlsrsakex\")\n//var tls3des = godebug.New(\"tls3des\")\n\nfunc defaultCipherSuites() []uint16 {\n\tsuites := slices.Clone(cipherSuitesPreferenceOrder)\n\treturn slices.DeleteFunc(suites, func(c uint16) bool {\n\t\treturn disabledCipherSuites[c] ||\n\t\t\trsaKexCiphers[c] ||\n\t\t\ttdesCiphers[c]\n\t})\n}\n\n// defaultCipherSuitesTLS13 is also the preference order, since there are no\n// disabled by default TLS 1.3 cipher suites. The same AES vs ChaCha20 logic as\n// cipherSuitesPreferenceOrder applies.\n//\n// defaultCipherSuitesTLS13 should be an internal detail,\n// but widely used packages access it using linkname.\n// Notable members of the hall of shame include:\n//   - github.com/quic-go/quic-go\n//   - github.com/sagernet/quic-go\n//\n// Do not remove or change the type signature.\n// See go.dev/issue/67401.\n//\n//go:linkname defaultCipherSuitesTLS13\nvar defaultCipherSuitesTLS13 = []uint16{\n\tTLS_AES_128_GCM_SHA256,\n\tTLS_AES_256_GCM_SHA384,\n\tTLS_CHACHA20_POLY1305_SHA256,\n}\n\n// defaultCipherSuitesTLS13NoAES should be an internal detail,\n// but widely used packages access it using linkname.\n// Notable members of the hall of shame include:\n//   - github.com/quic-go/quic-go\n//   - github.com/sagernet/quic-go\n//\n// Do not remove or change the type signature.\n// See go.dev/issue/67401.\n//\n//go:linkname defaultCipherSuitesTLS13NoAES\nvar defaultCipherSuitesTLS13NoAES = []uint16{\n\tTLS_CHACHA20_POLY1305_SHA256,\n\tTLS_AES_128_GCM_SHA256,\n\tTLS_AES_256_GCM_SHA384,\n}\n\n// The FIPS-only policies below match BoringSSL's ssl_policy_fips_202205.\n\nvar defaultSupportedVersionsFIPS = []uint16{\n\tVersionTLS12,\n\tVersionTLS13,\n}\n\n// defaultCurvePreferencesFIPS are the FIPS-allowed curves,\n// in preference order (most preferable first).\nvar defaultCurvePreferencesFIPS = []CurveID{CurveP256, CurveP384}\n\n// defaultSupportedSignatureAlgorithmsFIPS currently are a subset of\n// defaultSupportedSignatureAlgorithms without Ed25519 and SHA-1.\nvar defaultSupportedSignatureAlgorithmsFIPS = []SignatureScheme{\n\tPSSWithSHA256,\n\tPSSWithSHA384,\n\tPSSWithSHA512,\n\tPKCS1WithSHA256,\n\tECDSAWithP256AndSHA256,\n\tPKCS1WithSHA384,\n\tECDSAWithP384AndSHA384,\n\tPKCS1WithSHA512,\n}\n\n// defaultCipherSuitesFIPS are the FIPS-allowed cipher suites.\nvar defaultCipherSuitesFIPS = []uint16{\n\tTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\tTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\tTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\tTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n}\n\n// defaultCipherSuitesTLS13FIPS are the FIPS-allowed cipher suites for TLS 1.3.\nvar defaultCipherSuitesTLS13FIPS = []uint16{\n\tTLS_AES_128_GCM_SHA256,\n\tTLS_AES_256_GCM_SHA384,\n}"
        },
        {
          "name": "ech.go",
          "type": "blob",
          "size": 7.4306640625,
          "content": "// Copyright 2024 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage reality\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/cryptobyte\"\n\n\t\"github.com/xtls/reality/hpke\"\n)\n\ntype echCipher struct {\n\tKDFID  uint16\n\tAEADID uint16\n}\n\ntype echExtension struct {\n\tType uint16\n\tData []byte\n}\n\ntype echConfig struct {\n\traw []byte\n\n\tVersion uint16\n\tLength  uint16\n\n\tConfigID             uint8\n\tKemID                uint16\n\tPublicKey            []byte\n\tSymmetricCipherSuite []echCipher\n\n\tMaxNameLength uint8\n\tPublicName    []byte\n\tExtensions    []echExtension\n}\n\nvar errMalformedECHConfig = errors.New(\"tls: malformed ECHConfigList\")\n\n// parseECHConfigList parses a draft-ietf-tls-esni-18 ECHConfigList, returning a\n// slice of parsed ECHConfigs, in the same order they were parsed, or an error\n// if the list is malformed.\nfunc parseECHConfigList(data []byte) ([]echConfig, error) {\n\ts := cryptobyte.String(data)\n\t// Skip the length prefix\n\tvar length uint16\n\tif !s.ReadUint16(&length) {\n\t\treturn nil, errMalformedECHConfig\n\t}\n\tif length != uint16(len(data)-2) {\n\t\treturn nil, errMalformedECHConfig\n\t}\n\tvar configs []echConfig\n\tfor len(s) > 0 {\n\t\tvar ec echConfig\n\t\tec.raw = []byte(s)\n\t\tif !s.ReadUint16(&ec.Version) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tif !s.ReadUint16(&ec.Length) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tif len(ec.raw) < int(ec.Length)+4 {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tec.raw = ec.raw[:ec.Length+4]\n\t\tif ec.Version != extensionEncryptedClientHello {\n\t\t\ts.Skip(int(ec.Length))\n\t\t\tcontinue\n\t\t}\n\t\tif !s.ReadUint8(&ec.ConfigID) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tif !s.ReadUint16(&ec.KemID) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tif !s.ReadUint16LengthPrefixed((*cryptobyte.String)(&ec.PublicKey)) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tvar cipherSuites cryptobyte.String\n\t\tif !s.ReadUint16LengthPrefixed(&cipherSuites) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tfor !cipherSuites.Empty() {\n\t\t\tvar c echCipher\n\t\t\tif !cipherSuites.ReadUint16(&c.KDFID) {\n\t\t\t\treturn nil, errMalformedECHConfig\n\t\t\t}\n\t\t\tif !cipherSuites.ReadUint16(&c.AEADID) {\n\t\t\t\treturn nil, errMalformedECHConfig\n\t\t\t}\n\t\t\tec.SymmetricCipherSuite = append(ec.SymmetricCipherSuite, c)\n\t\t}\n\t\tif !s.ReadUint8(&ec.MaxNameLength) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tvar publicName cryptobyte.String\n\t\tif !s.ReadUint8LengthPrefixed(&publicName) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tec.PublicName = publicName\n\t\tvar extensions cryptobyte.String\n\t\tif !s.ReadUint16LengthPrefixed(&extensions) {\n\t\t\treturn nil, errMalformedECHConfig\n\t\t}\n\t\tfor !extensions.Empty() {\n\t\t\tvar e echExtension\n\t\t\tif !extensions.ReadUint16(&e.Type) {\n\t\t\t\treturn nil, errMalformedECHConfig\n\t\t\t}\n\t\t\tif !extensions.ReadUint16LengthPrefixed((*cryptobyte.String)(&e.Data)) {\n\t\t\t\treturn nil, errMalformedECHConfig\n\t\t\t}\n\t\t\tec.Extensions = append(ec.Extensions, e)\n\t\t}\n\n\t\tconfigs = append(configs, ec)\n\t}\n\treturn configs, nil\n}\n\nfunc pickECHConfig(list []echConfig) *echConfig {\n\tfor _, ec := range list {\n\t\tif _, ok := hpke.SupportedKEMs[ec.KemID]; !ok {\n\t\t\tcontinue\n\t\t}\n\t\tvar validSCS bool\n\t\tfor _, cs := range ec.SymmetricCipherSuite {\n\t\t\tif _, ok := hpke.SupportedAEADs[cs.AEADID]; !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := hpke.SupportedKDFs[cs.KDFID]; !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalidSCS = true\n\t\t\tbreak\n\t\t}\n\t\tif !validSCS {\n\t\t\tcontinue\n\t\t}\n\t\tif !validDNSName(string(ec.PublicName)) {\n\t\t\tcontinue\n\t\t}\n\t\tvar unsupportedExt bool\n\t\tfor _, ext := range ec.Extensions {\n\t\t\t// If high order bit is set to 1 the extension is mandatory.\n\t\t\t// Since we don't support any extensions, if we see a mandatory\n\t\t\t// bit, we skip the config.\n\t\t\tif ext.Type&uint16(1<<15) != 0 {\n\t\t\t\tunsupportedExt = true\n\t\t\t}\n\t\t}\n\t\tif unsupportedExt {\n\t\t\tcontinue\n\t\t}\n\t\treturn &ec\n\t}\n\treturn nil\n}\n\nfunc pickECHCipherSuite(suites []echCipher) (echCipher, error) {\n\tfor _, s := range suites {\n\t\t// NOTE: all of the supported AEADs and KDFs are fine, rather than\n\t\t// imposing some sort of preference here, we just pick the first valid\n\t\t// suite.\n\t\tif _, ok := hpke.SupportedAEADs[s.AEADID]; !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := hpke.SupportedKDFs[s.KDFID]; !ok {\n\t\t\tcontinue\n\t\t}\n\t\treturn s, nil\n\t}\n\treturn echCipher{}, errors.New(\"tls: no supported symmetric ciphersuites for ECH\")\n}\n\nfunc encodeInnerClientHello(inner *clientHelloMsg, maxNameLength int) ([]byte, error) {\n\th, err := inner.marshalMsg(true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\th = h[4:] // strip four byte prefix\n\n\tvar paddingLen int\n\tif inner.serverName != \"\" {\n\t\tpaddingLen = max(0, maxNameLength-len(inner.serverName))\n\t} else {\n\t\tpaddingLen = maxNameLength + 9\n\t}\n\tpaddingLen = 31 - ((len(h) + paddingLen - 1) % 32)\n\n\treturn append(h, make([]byte, paddingLen)...), nil\n}\n\nfunc generateOuterECHExt(id uint8, kdfID, aeadID uint16, encodedKey []byte, payload []byte) ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(0) // outer\n\tb.AddUint16(kdfID)\n\tb.AddUint16(aeadID)\n\tb.AddUint8(id)\n\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) { b.AddBytes(encodedKey) })\n\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) { b.AddBytes(payload) })\n\treturn b.Bytes()\n}\n\nfunc computeAndUpdateOuterECHExtension(outer, inner *clientHelloMsg, ech *echContext, useKey bool) error {\n\tvar encapKey []byte\n\tif useKey {\n\t\tencapKey = ech.encapsulatedKey\n\t}\n\tencodedInner, err := encodeInnerClientHello(inner, int(ech.config.MaxNameLength))\n\tif err != nil {\n\t\treturn err\n\t}\n\t// NOTE: the tag lengths for all of the supported AEADs are the same (16\n\t// bytes), so we have hardcoded it here. If we add support for another AEAD\n\t// with a different tag length, we will need to change this.\n\tencryptedLen := len(encodedInner) + 16 // AEAD tag length\n\touter.encryptedClientHello, err = generateOuterECHExt(ech.config.ConfigID, ech.kdfID, ech.aeadID, encapKey, make([]byte, encryptedLen))\n\tif err != nil {\n\t\treturn err\n\t}\n\tserializedOuter, err := outer.marshal()\n\tif err != nil {\n\t\treturn err\n\t}\n\tserializedOuter = serializedOuter[4:] // strip the four byte prefix\n\tencryptedInner, err := ech.hpkeContext.Seal(serializedOuter, encodedInner)\n\tif err != nil {\n\t\treturn err\n\t}\n\touter.encryptedClientHello, err = generateOuterECHExt(ech.config.ConfigID, ech.kdfID, ech.aeadID, encapKey, encryptedInner)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// validDNSName is a rather rudimentary check for the validity of a DNS name.\n// This is used to check if the public_name in a ECHConfig is valid when we are\n// picking a config. This can be somewhat lax because even if we pick a\n// valid-looking name, the DNS layer will later reject it anyway.\nfunc validDNSName(name string) bool {\n\tif len(name) > 253 {\n\t\treturn false\n\t}\n\tlabels := strings.Split(name, \".\")\n\tif len(labels) <= 1 {\n\t\treturn false\n\t}\n\tfor _, l := range labels {\n\t\tlabelLen := len(l)\n\t\tif labelLen == 0 {\n\t\t\treturn false\n\t\t}\n\t\tfor i, r := range l {\n\t\t\tif r == '-' && (i == 0 || i == labelLen-1) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif (r < '0' || r > '9') && (r < 'a' || r > 'z') && (r < 'A' || r > 'Z') && r != '-' {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// ECHRejectionError is the error type returned when ECH is rejected by a remote\n// server. If the server offered a ECHConfigList to use for retries, the\n// RetryConfigList field will contain this list.\n//\n// The client may treat an ECHRejectionError with an empty set of RetryConfigs\n// as a secure signal from the server.\ntype ECHRejectionError struct {\n\tRetryConfigList []byte\n}\n\nfunc (e *ECHRejectionError) Error() string {\n\treturn \"tls: server rejected ECH\"\n}"
        },
        {
          "name": "generate_cert.go",
          "type": "blob",
          "size": 4.833984375,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\n//go:build ignore\n\n// Generate a self-signed X.509 certificate for a TLS server. Outputs to\n// 'cert.pem' and 'key.pem' and will overwrite existing files.\n\npackage main\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"flag\"\n\t\"log\"\n\t\"math/big\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\thost       = flag.String(\"host\", \"\", \"Comma-separated hostnames and IPs to generate a certificate for\")\n\tvalidFrom  = flag.String(\"start-date\", \"\", \"Creation date formatted as Jan 1 15:04:05 2011\")\n\tvalidFor   = flag.Duration(\"duration\", 365*24*time.Hour, \"Duration that certificate is valid for\")\n\tisCA       = flag.Bool(\"ca\", false, \"whether this cert should be its own Certificate Authority\")\n\trsaBits    = flag.Int(\"rsa-bits\", 2048, \"Size of RSA key to generate. Ignored if --ecdsa-curve is set\")\n\tecdsaCurve = flag.String(\"ecdsa-curve\", \"\", \"ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521\")\n\ted25519Key = flag.Bool(\"ed25519\", false, \"Generate an Ed25519 key\")\n)\n\nfunc publicKey(priv any) any {\n\tswitch k := priv.(type) {\n\tcase *rsa.PrivateKey:\n\t\treturn &k.PublicKey\n\tcase *ecdsa.PrivateKey:\n\t\treturn &k.PublicKey\n\tcase ed25519.PrivateKey:\n\t\treturn k.Public().(ed25519.PublicKey)\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tif len(*host) == 0 {\n\t\tlog.Fatalf(\"Missing required --host parameter\")\n\t}\n\n\tvar priv any\n\tvar err error\n\tswitch *ecdsaCurve {\n\tcase \"\":\n\t\tif *ed25519Key {\n\t\t\t_, priv, err = ed25519.GenerateKey(rand.Reader)\n\t\t} else {\n\t\t\tpriv, err = rsa.GenerateKey(rand.Reader, *rsaBits)\n\t\t}\n\tcase \"P224\":\n\t\tpriv, err = ecdsa.GenerateKey(elliptic.P224(), rand.Reader)\n\tcase \"P256\":\n\t\tpriv, err = ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tcase \"P384\":\n\t\tpriv, err = ecdsa.GenerateKey(elliptic.P384(), rand.Reader)\n\tcase \"P521\":\n\t\tpriv, err = ecdsa.GenerateKey(elliptic.P521(), rand.Reader)\n\tdefault:\n\t\tlog.Fatalf(\"Unrecognized elliptic curve: %q\", *ecdsaCurve)\n\t}\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to generate private key: %v\", err)\n\t}\n\n\t// ECDSA, ED25519 and RSA subject keys should have the DigitalSignature\n\t// KeyUsage bits set in the x509.Certificate template\n\tkeyUsage := x509.KeyUsageDigitalSignature\n\t// Only RSA subject keys should have the KeyEncipherment KeyUsage bits set. In\n\t// the context of TLS this KeyUsage is particular to RSA key exchange and\n\t// authentication.\n\tif _, isRSA := priv.(*rsa.PrivateKey); isRSA {\n\t\tkeyUsage |= x509.KeyUsageKeyEncipherment\n\t}\n\n\tvar notBefore time.Time\n\tif len(*validFrom) == 0 {\n\t\tnotBefore = time.Now()\n\t} else {\n\t\tnotBefore, err = time.Parse(\"Jan 2 15:04:05 2006\", *validFrom)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Failed to parse creation date: %v\", err)\n\t\t}\n\t}\n\n\tnotAfter := notBefore.Add(*validFor)\n\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to generate serial number: %v\", err)\n\t}\n\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Acme Co\"},\n\t\t},\n\t\tNotBefore: notBefore,\n\t\tNotAfter:  notAfter,\n\n\t\tKeyUsage:              keyUsage,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t}\n\n\thosts := strings.Split(*host, \",\")\n\tfor _, h := range hosts {\n\t\tif ip := net.ParseIP(h); ip != nil {\n\t\t\ttemplate.IPAddresses = append(template.IPAddresses, ip)\n\t\t} else {\n\t\t\ttemplate.DNSNames = append(template.DNSNames, h)\n\t\t}\n\t}\n\n\tif *isCA {\n\t\ttemplate.IsCA = true\n\t\ttemplate.KeyUsage |= x509.KeyUsageCertSign\n\t}\n\n\tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, publicKey(priv), priv)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create certificate: %v\", err)\n\t}\n\n\tcertOut, err := os.Create(\"cert.pem\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open cert.pem for writing: %v\", err)\n\t}\n\tif err := pem.Encode(certOut, &pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes}); err != nil {\n\t\tlog.Fatalf(\"Failed to write data to cert.pem: %v\", err)\n\t}\n\tif err := certOut.Close(); err != nil {\n\t\tlog.Fatalf(\"Error closing cert.pem: %v\", err)\n\t}\n\tlog.Print(\"wrote cert.pem\\n\")\n\n\tkeyOut, err := os.OpenFile(\"key.pem\", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open key.pem for writing: %v\", err)\n\t}\n\tprivBytes, err := x509.MarshalPKCS8PrivateKey(priv)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to marshal private key: %v\", err)\n\t}\n\tif err := pem.Encode(keyOut, &pem.Block{Type: \"PRIVATE KEY\", Bytes: privBytes}); err != nil {\n\t\tlog.Fatalf(\"Failed to write data to key.pem: %v\", err)\n\t}\n\tif err := keyOut.Close(); err != nil {\n\t\tlog.Fatalf(\"Error closing key.pem: %v\", err)\n\t}\n\tlog.Print(\"wrote key.pem\\n\")\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1435546875,
          "content": "module github.com/xtls/reality\n\ngo 1.23\n\nrequire (\n\tgithub.com/pires/go-proxyproto v0.7.0\n\tgolang.org/x/crypto v0.26.0\n\tgolang.org/x/sys v0.24.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.4794921875,
          "content": "github.com/pires/go-proxyproto v0.7.0 h1:IukmRewDQFWC7kfnb66CSomk2q/seBuilHBYFwyq0Hs=\ngithub.com/pires/go-proxyproto v0.7.0/go.mod h1:Vz/1JPY/OACxWGQNIRY2BeyDmpoaWmEP40O9LbuiFR4=\ngolang.org/x/crypto v0.26.0 h1:RrRspgV4mU+YwB4FYnuBoKsUapNIL5cohGAmSH3azsw=\ngolang.org/x/crypto v0.26.0/go.mod h1:GY7jblb9wI+FOo5y8/S2oY4zWP07AkOJ4+jxCqdqn54=\ngolang.org/x/sys v0.24.0 h1:Twjiwq9dn6R1fQcyiK+wQyHWfaz/BJB+YIpzU/Cv3Xg=\ngolang.org/x/sys v0.24.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        },
        {
          "name": "handshake_client.go",
          "type": "blob",
          "size": 38.55859375,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/xtls/reality/hpke\"\n\t\"github.com/xtls/reality/mlkem768\"\n)\n\ntype clientHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tserverHello  *serverHelloMsg\n\thello        *clientHelloMsg\n\tsuite        *cipherSuite\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tsession      *SessionState // the session being resumed\n\tticket       []byte        // a fresh ticket received during this handshake\n}\n\nvar testingOnlyForceClientHelloSignatureAlgorithms []SignatureScheme\n\nfunc (c *Conn) makeClientHello() (*clientHelloMsg, *keySharePrivateKeys, *echContext, error) {\n\tconfig := c.config\n\tif len(config.ServerName) == 0 && !config.InsecureSkipVerify {\n\t\treturn nil, nil, nil, errors.New(\"tls: either ServerName or InsecureSkipVerify must be specified in the tls.Config\")\n\t}\n\n\tnextProtosLength := 0\n\tfor _, proto := range config.NextProtos {\n\t\tif l := len(proto); l == 0 || l > 255 {\n\t\t\treturn nil, nil, nil, errors.New(\"tls: invalid NextProtos value\")\n\t\t} else {\n\t\t\tnextProtosLength += 1 + l\n\t\t}\n\t}\n\tif nextProtosLength > 0xffff {\n\t\treturn nil, nil, nil, errors.New(\"tls: NextProtos values too large\")\n\t}\n\n\tsupportedVersions := config.supportedVersions(roleClient)\n\tif len(supportedVersions) == 0 {\n\t\treturn nil, nil, nil, errors.New(\"tls: no supported versions satisfy MinVersion and MaxVersion\")\n\t}\n\n\tmaxVersion := config.maxSupportedVersion(roleClient)\n\n\thello := &clientHelloMsg{\n\t\tvers:                         maxVersion,\n\t\tcompressionMethods:           []uint8{compressionNone},\n\t\trandom:                       make([]byte, 32),\n\t\textendedMasterSecret:         true,\n\t\tocspStapling:                 true,\n\t\tscts:                         true,\n\t\tserverName:                   hostnameInSNI(config.ServerName),\n\t\tsupportedCurves:              config.curvePreferences(maxVersion),\n\t\tsupportedPoints:              []uint8{pointFormatUncompressed},\n\t\tsecureRenegotiationSupported: true,\n\t\talpnProtocols:                config.NextProtos,\n\t\tsupportedVersions:            supportedVersions,\n\t}\n\n\t// The version at the beginning of the ClientHello was capped at TLS 1.2\n\t// for compatibility reasons. The supported_versions extension is used\n\t// to negotiate versions now. See RFC 8446, Section 4.2.1.\n\tif hello.vers > VersionTLS12 {\n\t\thello.vers = VersionTLS12\n\t}\n\n\tif c.handshakes > 0 {\n\t\thello.secureRenegotiation = c.clientFinished[:]\n\t}\n\n\tpreferenceOrder := cipherSuitesPreferenceOrder\n\tif !hasAESGCMHardwareSupport {\n\t\tpreferenceOrder = cipherSuitesPreferenceOrderNoAES\n\t}\n\tconfigCipherSuites := config.cipherSuites()\n\thello.cipherSuites = make([]uint16, 0, len(configCipherSuites))\n\n\tfor _, suiteId := range preferenceOrder {\n\t\tsuite := mutualCipherSuite(configCipherSuites, suiteId)\n\t\tif suite == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Don't advertise TLS 1.2-only cipher suites unless\n\t\t// we're attempting TLS 1.2.\n\t\tif maxVersion < VersionTLS12 && suite.flags&suiteTLS12 != 0 {\n\t\t\tcontinue\n\t\t}\n\t\thello.cipherSuites = append(hello.cipherSuites, suiteId)\n\t}\n\n\t_, err := io.ReadFull(config.rand(), hello.random)\n\tif err != nil {\n\t\treturn nil, nil, nil, errors.New(\"tls: short read from Rand: \" + err.Error())\n\t}\n\n\t// A random session ID is used to detect when the server accepted a ticket\n\t// and is resuming a session (see RFC 5077). In TLS 1.3, it's always set as\n\t// a compatibility measure (see RFC 8446, Section 4.1.2).\n\t//\n\t// The session ID is not set for QUIC connections (see RFC 9001, Section 8.4).\n\tif c.quic == nil {\n\t\thello.sessionId = make([]byte, 32)\n\t\tif _, err := io.ReadFull(config.rand(), hello.sessionId); err != nil {\n\t\t\treturn nil, nil, nil, errors.New(\"tls: short read from Rand: \" + err.Error())\n\t\t}\n\t}\n\n\tif maxVersion >= VersionTLS12 {\n\t\thello.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t}\n\tif testingOnlyForceClientHelloSignatureAlgorithms != nil {\n\t\thello.supportedSignatureAlgorithms = testingOnlyForceClientHelloSignatureAlgorithms\n\t}\n\n\tvar keyShareKeys *keySharePrivateKeys\n\tif hello.supportedVersions[0] == VersionTLS13 {\n\t\t// Reset the list of ciphers when the client only supports TLS 1.3.\n\t\tif len(hello.supportedVersions) == 1 {\n\t\t\thello.cipherSuites = nil\n\t\t}\n\t\tif needFIPS() {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13FIPS...)\n\t\t} else if hasAESGCMHardwareSupport {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13...)\n\t\t} else {\n\t\t\thello.cipherSuites = append(hello.cipherSuites, defaultCipherSuitesTLS13NoAES...)\n\t\t}\n\n\t\tif len(hello.supportedCurves) == 0 {\n\t\t\treturn nil, nil, nil, errors.New(\"tls: no supported elliptic curves for ECDHE\")\n\t\t}\n\t\tcurveID := hello.supportedCurves[0]\n\t\tkeyShareKeys = &keySharePrivateKeys{curveID: curveID}\n\t\tif curveID == x25519Kyber768Draft00 {\n\t\t\tkeyShareKeys.ecdhe, err = generateECDHEKey(config.rand(), X25519)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, nil, err\n\t\t\t}\n\t\t\tseed := make([]byte, mlkem768.SeedSize)\n\t\t\tif _, err := io.ReadFull(config.rand(), seed); err != nil {\n\t\t\t\treturn nil, nil, nil, err\n\t\t\t}\n\t\t\tkeyShareKeys.kyber, err = mlkem768.NewKeyFromSeed(seed)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, nil, err\n\t\t\t}\n\t\t\t// For draft-tls-westerbaan-xyber768d00-03, we send both a hybrid\n\t\t\t// and a standard X25519 key share, since most servers will only\n\t\t\t// support the latter. We reuse the same X25519 ephemeral key for\n\t\t\t// both, as allowed by draft-ietf-tls-hybrid-design-09, Section 3.2.\n\t\t\thello.keyShares = []keyShare{\n\t\t\t\t{group: x25519Kyber768Draft00, data: append(keyShareKeys.ecdhe.PublicKey().Bytes(),\n\t\t\t\t\tkeyShareKeys.kyber.EncapsulationKey()...)},\n\t\t\t\t{group: X25519, data: keyShareKeys.ecdhe.PublicKey().Bytes()},\n\t\t\t}\n\t\t} else {\n\t\t\tif _, ok := curveForCurveID(curveID); !ok {\n\t\t\t\treturn nil, nil, nil, errors.New(\"tls: CurvePreferences includes unsupported curve\")\n\t\t\t}\n\t\t\tkeyShareKeys.ecdhe, err = generateECDHEKey(config.rand(), curveID)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, nil, err\n\t\t\t}\n\t\t\thello.keyShares = []keyShare{{group: curveID, data: keyShareKeys.ecdhe.PublicKey().Bytes()}}\n\t\t}\n\t}\n\n\tif c.quic != nil {\n\t\tp, err := c.quicGetTransportParameters()\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tif p == nil {\n\t\t\tp = []byte{}\n\t\t}\n\t\thello.quicTransportParameters = p\n\t}\n\n\tvar ech *echContext\n\tif c.config.EncryptedClientHelloConfigList != nil {\n\t\tif c.config.MinVersion != 0 && c.config.MinVersion < VersionTLS13 {\n\t\t\treturn nil, nil, nil, errors.New(\"tls: MinVersion must be >= VersionTLS13 if EncryptedClientHelloConfigList is populated\")\n\t\t}\n\t\tif c.config.MaxVersion != 0 && c.config.MaxVersion <= VersionTLS12 {\n\t\t\treturn nil, nil, nil, errors.New(\"tls: MaxVersion must be >= VersionTLS13 if EncryptedClientHelloConfigList is populated\")\n\t\t}\n\t\techConfigs, err := parseECHConfigList(c.config.EncryptedClientHelloConfigList)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\techConfig := pickECHConfig(echConfigs)\n\t\tif echConfig == nil {\n\t\t\treturn nil, nil, nil, errors.New(\"tls: EncryptedClientHelloConfigList contains no valid configs\")\n\t\t}\n\t\tech = &echContext{config: echConfig}\n\t\thello.encryptedClientHello = []byte{1} // indicate inner hello\n\t\t// We need to explicitly set these 1.2 fields to nil, as we do not\n\t\t// marshal them when encoding the inner hello, otherwise transcripts\n\t\t// will later mismatch.\n\t\thello.supportedPoints = nil\n\t\thello.ticketSupported = false\n\t\thello.secureRenegotiationSupported = false\n\t\thello.extendedMasterSecret = false\n\n\t\techPK, err := hpke.ParseHPKEPublicKey(ech.config.KemID, ech.config.PublicKey)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tsuite, err := pickECHCipherSuite(ech.config.SymmetricCipherSuite)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t\tech.kdfID, ech.aeadID = suite.KDFID, suite.AEADID\n\t\tinfo := append([]byte(\"tls ech\\x00\"), ech.config.raw...)\n\t\tech.encapsulatedKey, ech.hpkeContext, err = hpke.SetupSender(ech.config.KemID, suite.KDFID, suite.AEADID, echPK, info)\n\t\tif err != nil {\n\t\t\treturn nil, nil, nil, err\n\t\t}\n\t}\n\n\treturn hello, keyShareKeys, ech, nil\n}\n\ntype echContext struct {\n\tconfig          *echConfig\n\thpkeContext     *hpke.Sender\n\tencapsulatedKey []byte\n\tinnerHello      *clientHelloMsg\n\tinnerTranscript hash.Hash\n\tkdfID           uint16\n\taeadID          uint16\n\techRejected     bool\n}\n\nfunc (c *Conn) clientHandshake(ctx context.Context) (err error) {\n\tif c.config == nil {\n\t\tc.config = defaultConfig()\n\t}\n\n\t// This may be a renegotiation handshake, in which case some fields\n\t// need to be reset.\n\tc.didResume = false\n\n\thello, keyShareKeys, ech, err := c.makeClientHello()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.serverName = hello.serverName\n\n\tsession, earlySecret, binderKey, err := c.loadSession(hello)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif session != nil {\n\t\tdefer func() {\n\t\t\t// If we got a handshake failure when resuming a session, throw away\n\t\t\t// the session ticket. See RFC 5077, Section 3.2.\n\t\t\t//\n\t\t\t// RFC 8446 makes no mention of dropping tickets on failure, but it\n\t\t\t// does require servers to abort on invalid binders, so we need to\n\t\t\t// delete tickets to recover from a corrupted PSK.\n\t\t\tif err != nil {\n\t\t\t\tif cacheKey := c.clientSessionCacheKey(); cacheKey != \"\" {\n\t\t\t\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tif ech != nil {\n\t\t// Split hello into inner and outer\n\t\tech.innerHello = hello.clone()\n\n\t\t// Overwrite the server name in the outer hello with the public facing\n\t\t// name.\n\t\thello.serverName = string(ech.config.PublicName)\n\t\t// Generate a new random for the outer hello.\n\t\thello.random = make([]byte, 32)\n\t\t_, err = io.ReadFull(c.config.rand(), hello.random)\n\t\tif err != nil {\n\t\t\treturn errors.New(\"tls: short read from Rand: \" + err.Error())\n\t\t}\n\n\t\t// NOTE: we don't do PSK GREASE, in line with boringssl, it's meant to\n\t\t// work around _possibly_ broken middleboxes, but there is little-to-no\n\t\t// evidence that this is actually a problem.\n\n\t\tif err := computeAndUpdateOuterECHExtension(hello, ech.innerHello, ech, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tc.serverName = hello.serverName\n\n\tif _, err := c.writeHandshakeRecord(hello, nil); err != nil {\n\t\treturn err\n\t}\n\n\tif hello.earlyData {\n\t\tsuite := cipherSuiteTLS13ByID(session.cipherSuite)\n\t\ttranscript := suite.hash.New()\n\t\tif err := transcriptMsg(hello, transcript); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tearlyTrafficSecret := suite.deriveSecret(earlySecret, clientEarlyTrafficLabel, transcript)\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelEarly, suite.id, earlyTrafficSecret)\n\t}\n\n\t// serverHelloMsg is not included in the transcript\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserverHello, ok := msg.(*serverHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverHello, msg)\n\t}\n\n\tif err := c.pickTLSVersion(serverHello); err != nil {\n\t\treturn err\n\t}\n\n\t// If we are negotiating a protocol version that's lower than what we\n\t// support, check for the server downgrade canaries.\n\t// See RFC 8446, Section 4.1.3.\n\tmaxVers := c.config.maxSupportedVersion(roleClient)\n\ttls12Downgrade := string(serverHello.random[24:]) == downgradeCanaryTLS12\n\ttls11Downgrade := string(serverHello.random[24:]) == downgradeCanaryTLS11\n\tif maxVers == VersionTLS13 && c.vers <= VersionTLS12 && (tls12Downgrade || tls11Downgrade) ||\n\t\tmaxVers == VersionTLS12 && c.vers <= VersionTLS11 && tls11Downgrade {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: downgrade attempt detected, possibly due to a MitM attack or a broken middlebox\")\n\t}\n\n\tif c.vers == VersionTLS13 {\n\t\ths := &clientHandshakeStateTLS13{\n\t\t\tc:            c,\n\t\t\tctx:          ctx,\n\t\t\tserverHello:  serverHello,\n\t\t\thello:        hello,\n\t\t\tkeyShareKeys: keyShareKeys,\n\t\t\tsession:      session,\n\t\t\tearlySecret:  earlySecret,\n\t\t\tbinderKey:    binderKey,\n\t\t\techContext:   ech,\n\t\t}\n\t\treturn hs.handshake()\n\t}\n\n\ths := &clientHandshakeState{\n\t\tc:           c,\n\t\tctx:         ctx,\n\t\tserverHello: serverHello,\n\t\thello:       hello,\n\t\tsession:     session,\n\t}\n\n\treturn hs.handshake()\n}\n\nfunc (c *Conn) loadSession(hello *clientHelloMsg) (\n\tsession *SessionState, earlySecret, binderKey []byte, err error) {\n\tif c.config.SessionTicketsDisabled || c.config.ClientSessionCache == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\techInner := bytes.Equal(hello.encryptedClientHello, []byte{1})\n\n\t// ticketSupported is a TLS 1.2 extension (as TLS 1.3 replaced tickets with PSK\n\t// identities) and ECH requires and forces TLS 1.3.\n\thello.ticketSupported = true && !echInner\n\n\tif hello.supportedVersions[0] == VersionTLS13 {\n\t\t// Require DHE on resumption as it guarantees forward secrecy against\n\t\t// compromise of the session ticket key. See RFC 8446, Section 4.2.9.\n\t\thello.pskModes = []uint8{pskModeDHE}\n\t}\n\n\t// Session resumption is not allowed if renegotiating because\n\t// renegotiation is primarily used to allow a client to send a client\n\t// certificate, which would be skipped if session resumption occurred.\n\tif c.handshakes != 0 {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// Try to resume a previously negotiated TLS session, if available.\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil, nil, nil, nil\n\t}\n\tcs, ok := c.config.ClientSessionCache.Get(cacheKey)\n\tif !ok || cs == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\tsession = cs.session\n\n\t// Check that version used for the previous session is still valid.\n\tversOk := false\n\tfor _, v := range hello.supportedVersions {\n\t\tif v == session.version {\n\t\t\tversOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !versOk {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// Check that the cached server certificate is not expired, and that it's\n\t// valid for the ServerName. This should be ensured by the cache key, but\n\t// protect the application from a faulty ClientSessionCache implementation.\n\tif c.config.time().After(session.peerCertificates[0].NotAfter) {\n\t\t// Expired certificate, delete the entry.\n\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\treturn nil, nil, nil, nil\n\t}\n\tif !c.config.InsecureSkipVerify {\n\t\tif len(session.verifiedChains) == 0 {\n\t\t\t// The original connection had InsecureSkipVerify, while this doesn't.\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\t\tif err := session.peerCertificates[0].VerifyHostname(c.config.ServerName); err != nil {\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\t}\n\n\tif session.version != VersionTLS13 {\n\t\t// In TLS 1.2 the cipher suite must match the resumed session. Ensure we\n\t\t// are still offering it.\n\t\tif mutualCipherSuite(hello.cipherSuites, session.cipherSuite) == nil {\n\t\t\treturn nil, nil, nil, nil\n\t\t}\n\n\t\thello.sessionTicket = session.ticket\n\t\treturn\n\t}\n\n\t// Check that the session ticket is not expired.\n\tif c.config.time().After(time.Unix(int64(session.useBy), 0)) {\n\t\tc.config.ClientSessionCache.Put(cacheKey, nil)\n\t\treturn nil, nil, nil, nil\n\t}\n\n\t// In TLS 1.3 the KDF hash must match the resumed session. Ensure we\n\t// offer at least one cipher suite with that hash.\n\tcipherSuite := cipherSuiteTLS13ByID(session.cipherSuite)\n\tif cipherSuite == nil {\n\t\treturn nil, nil, nil, nil\n\t}\n\tcipherSuiteOk := false\n\tfor _, offeredID := range hello.cipherSuites {\n\t\tofferedSuite := cipherSuiteTLS13ByID(offeredID)\n\t\tif offeredSuite != nil && offeredSuite.hash == cipherSuite.hash {\n\t\t\tcipherSuiteOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !cipherSuiteOk {\n\t\treturn nil, nil, nil, nil\n\t}\n\n\tif c.quic != nil {\n\t\tif c.quic.enableSessionEvents {\n\t\t\tc.quicResumeSession(session)\n\t\t}\n\n\t\t// For 0-RTT, the cipher suite has to match exactly, and we need to be\n\t\t// offering the same ALPN.\n\t\tif session.EarlyData && mutualCipherSuiteTLS13(hello.cipherSuites, session.cipherSuite) != nil {\n\t\t\tfor _, alpn := range hello.alpnProtocols {\n\t\t\t\tif alpn == session.alpnProtocol {\n\t\t\t\t\thello.earlyData = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the pre_shared_key extension. See RFC 8446, Section 4.2.11.1.\n\tticketAge := c.config.time().Sub(time.Unix(int64(session.createdAt), 0))\n\tidentity := pskIdentity{\n\t\tlabel:               session.ticket,\n\t\tobfuscatedTicketAge: uint32(ticketAge/time.Millisecond) + session.ageAdd,\n\t}\n\thello.pskIdentities = []pskIdentity{identity}\n\thello.pskBinders = [][]byte{make([]byte, cipherSuite.hash.Size())}\n\n\t// Compute the PSK binders. See RFC 8446, Section 4.2.11.2.\n\tearlySecret = cipherSuite.extract(session.secret, nil)\n\tbinderKey = cipherSuite.deriveSecret(earlySecret, resumptionBinderLabel, nil)\n\ttranscript := cipherSuite.hash.New()\n\tif err := computeAndUpdatePSK(hello, binderKey, transcript, cipherSuite.finishedHash); err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\treturn\n}\n\nfunc (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error {\n\tpeerVersion := serverHello.vers\n\tif serverHello.supportedVersion != 0 {\n\t\tpeerVersion = serverHello.supportedVersion\n\t}\n\n\tvers, ok := c.config.mutualVersion(roleClient, []uint16{peerVersion})\n\tif !ok {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn fmt.Errorf(\"tls: server selected unsupported protocol version %x\", peerVersion)\n\t}\n\n\tc.vers = vers\n\tc.haveVers = true\n\tc.in.version = vers\n\tc.out.version = vers\n\n\treturn nil\n}\n\n// Does the handshake, either a full one or resumes old session. Requires hs.c,\n// hs.hello, hs.serverHello, and, optionally, hs.session to be set.\nfunc (hs *clientHandshakeState) handshake() error {\n\tc := hs.c\n\n\tisResume, err := hs.processServerHello()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ths.finishedHash = newFinishedHash(c.vers, hs.suite)\n\n\t// No signatures of the handshake are needed in a resumption.\n\t// Otherwise, in a full handshake, if we don't have any certificates\n\t// configured then we will never send a CertificateVerify message and\n\t// thus no signatures are needed in that case either.\n\tif isResume || (len(c.config.Certificates) == 0 && c.config.GetClientCertificate == nil) {\n\t\ths.finishedHash.discardHandshakeBuffer()\n\t}\n\n\tif err := transcriptMsg(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif err := transcriptMsg(hs.serverHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tc.buffering = true\n\tc.didResume = isResume\n\tif isResume {\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = false\n\t\t// Make sure the connection is still being verified whether or not this\n\t\t// is a resumption. Resumptions currently don't reverify certificates so\n\t\t// they don't call verifyServerCertificate. See Issue 31641.\n\t\tif c.config.VerifyConnection != nil {\n\t\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := hs.doFullHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = true\n\t\tif err := hs.readSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := hs.saveSessionTicket(); err != nil {\n\t\treturn err\n\t}\n\n\tc.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random)\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) pickCipherSuite() error {\n\tif hs.suite = mutualCipherSuite(hs.hello.cipherSuites, hs.serverHello.cipherSuite); hs.suite == nil {\n\t\ths.c.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: server chose an unconfigured cipher suite\")\n\t}\n\n\ths.c.cipherSuite = hs.suite.id\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) doFullHandshake() error {\n\tc := hs.c\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcertMsg, ok := msg.(*certificateMsg)\n\tif !ok || len(certMsg.certificates) == 0 {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(certMsg, msg)\n\t}\n\n\tmsg, err = c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcs, ok := msg.(*certificateStatusMsg)\n\tif ok {\n\t\t// RFC4366 on Certificate Status Request:\n\t\t// The server MAY return a \"certificate_status\" message.\n\n\t\tif !hs.serverHello.ocspStapling {\n\t\t\t// If a server returns a \"CertificateStatus\" message, then the\n\t\t\t// server MUST have included an extension of type \"status_request\"\n\t\t\t// with empty \"extension_data\" in the extended server hello.\n\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn errors.New(\"tls: received unexpected CertificateStatus message\")\n\t\t}\n\t\t\n\t\tc.ocspResponse = cs.response\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.handshakes == 0 {\n\t\t// If this is the first handshake on a connection, process and\n\t\t// (optionally) verify the server's certificates.\n\t\tif err := c.verifyServerCertificate(certMsg.certificates); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// This is a renegotiation handshake. We require that the\n\t\t// server's identity (i.e. leaf certificate) is unchanged and\n\t\t// thus any previous trust decision is still valid.\n\t\t//\n\t\t// See https://mitls.org/pages/attacks/3SHAKE for the\n\t\t// motivation behind this requirement.\n\t\tif !bytes.Equal(c.peerCertificates[0].Raw, certMsg.certificates[0]) {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: server's identity changed during renegotiation\")\n\t\t}\n\t}\n\n\tkeyAgreement := hs.suite.ka(c.vers)\n\n\tskx, ok := msg.(*serverKeyExchangeMsg)\n\tif ok {\n\t\terr = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn err\n\t\t}\n\t\tif len(skx.key) >= 3 && skx.key[0] == 3 /* named curve */ {\n\t\t\tc.curveID = CurveID(binary.BigEndian.Uint16(skx.key[1:]))\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar chainToSend *Certificate\n\tvar certRequested bool\n\tcertReq, ok := msg.(*certificateRequestMsg)\n\tif ok {\n\t\tcertRequested = true\n\n\t\tcri := certificateRequestInfoFromMsg(hs.ctx, c.vers, certReq)\n\t\tif chainToSend, err = c.getClientCertificate(cri); err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tshd, ok := msg.(*serverHelloDoneMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(shd, msg)\n\t}\n\n\t// If the server requested a certificate then we have to send a\n\t// Certificate message, even if it's empty because we don't have a\n\t// certificate to send.\n\tif certRequested {\n\t\tcertMsg = new(certificateMsg)\n\t\tcertMsg.certificates = chainToSend.Certificate\n\t\tif _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tpreMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, c.peerCertificates[0])\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\tif ckx != nil {\n\t\tif _, err := hs.c.writeHandshakeRecord(ckx, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hs.serverHello.extendedMasterSecret {\n\t\tc.extMasterSecret = true\n\t\ths.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.finishedHash.Sum())\n\t} else {\n\t\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.hello.random, hs.serverHello.random)\n\t}\n\tif err := c.config.writeKeyLog(keyLogLabelTLS12, hs.hello.random, hs.masterSecret); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn errors.New(\"tls: failed to write to key log: \" + err.Error())\n\t}\n\n\tif chainToSend != nil && len(chainToSend.Certificate) > 0 {\n\t\tcertVerify := &certificateVerifyMsg{}\n\n\t\tkey, ok := chainToSend.PrivateKey.(crypto.Signer)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: client certificate private key of type %T does not implement crypto.Signer\", chainToSend.PrivateKey)\n\t\t}\n\n\t\tvar sigType uint8\n\t\tvar sigHash crypto.Hash\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tsignatureAlgorithm, err := selectSignatureScheme(c.vers, chainToSend, certReq.supportedSignatureAlgorithms)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(signatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\treturn c.sendAlert(alertInternalError)\n\t\t\t}\n\t\t\tcertVerify.hasSignatureAlgorithm = true\n\t\t\tcertVerify.signatureAlgorithm = signatureAlgorithm\n\t\t} else {\n\t\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(key.Public())\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tsigned := hs.finishedHash.hashForClientCertificate(sigType, sigHash)\n\t\tsignOpts := crypto.SignerOpts(sigHash)\n\t\tif sigType == signatureRSAPSS {\n\t\t\tsignOpts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: sigHash}\n\t\t}\n\t\tcertVerify.signature, err = key.Sign(c.config.rand(), signed, signOpts)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\n\t\tif _, err := hs.c.writeHandshakeRecord(certVerify, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.finishedHash.discardHandshakeBuffer()\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) establishKeys() error {\n\tc := hs.c\n\n\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n\tvar clientCipher, serverCipher any\n\tvar clientHash, serverHash hash.Hash\n\tif hs.suite.cipher != nil {\n\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */)\n\t\tclientHash = hs.suite.mac(clientMAC)\n\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */)\n\t\tserverHash = hs.suite.mac(serverMAC)\n\t} else {\n\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n\t}\n\n\tc.in.prepareCipherSpec(c.vers, serverCipher, serverHash)\n\tc.out.prepareCipherSpec(c.vers, clientCipher, clientHash)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) serverResumedSession() bool {\n\t// If the server responded with the same sessionId then it means the\n\t// sessionTicket is being used to resume a TLS session.\n\treturn hs.session != nil && hs.hello.sessionId != nil &&\n\t\tbytes.Equal(hs.serverHello.sessionId, hs.hello.sessionId)\n}\n\nfunc (hs *clientHandshakeState) processServerHello() (bool, error) {\n\tc := hs.c\n\n\tif err := hs.pickCipherSuite(); err != nil {\n\t\treturn false, err\n\t}\n\n\tif hs.serverHello.compressionMethod != compressionNone {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn false, errors.New(\"tls: server selected unsupported compression format\")\n\t}\n\n\tif c.handshakes == 0 && hs.serverHello.secureRenegotiationSupported {\n\t\tc.secureRenegotiation = true\n\t\tif len(hs.serverHello.secureRenegotiation) != 0 {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn false, errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t\t}\n\t}\n\n\tif c.handshakes > 0 && c.secureRenegotiation {\n\t\tvar expectedSecureRenegotiation [24]byte\n\t\tcopy(expectedSecureRenegotiation[:], c.clientFinished[:])\n\t\tcopy(expectedSecureRenegotiation[12:], c.serverFinished[:])\n\t\tif !bytes.Equal(hs.serverHello.secureRenegotiation, expectedSecureRenegotiation[:]) {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn false, errors.New(\"tls: incorrect renegotiation extension contents\")\n\t\t}\n\t}\n\n\tif err := checkALPN(hs.hello.alpnProtocols, hs.serverHello.alpnProtocol, false); err != nil {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn false, err\n\t}\n\tc.clientProtocol = hs.serverHello.alpnProtocol\n\n\tc.scts = hs.serverHello.scts\n\n\tif !hs.serverResumedSession() {\n\t\treturn false, nil\n\t}\n\n\tif hs.session.version != c.vers {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different version\")\n\t}\n\n\tif hs.session.cipherSuite != hs.suite.id {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different cipher suite\")\n\t}\n\n\t// RFC 7627, Section 5.3\n\tif hs.session.extMasterSecret != hs.serverHello.extendedMasterSecret {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn false, errors.New(\"tls: server resumed a session with a different EMS extension\")\n\t}\n\n\t// Restore master secret and certificates from previous state\n\ths.masterSecret = hs.session.secret\n\tc.extMasterSecret = hs.session.extMasterSecret\n\tc.peerCertificates = hs.session.peerCertificates\n\tc.activeCertHandles = hs.c.activeCertHandles\n\tc.verifiedChains = hs.session.verifiedChains\n\tc.ocspResponse = hs.session.ocspResponse\n\t// Let the ServerHello SCTs override the session SCTs from the original\n\t// connection, if any are provided\n\tif len(c.scts) == 0 && len(hs.session.scts) != 0 {\n\t\tc.scts = hs.session.scts\n\t}\n\n\treturn true, nil\n}\n\n// checkALPN ensure that the server's choice of ALPN protocol is compatible with\n// the protocols that we advertised in the Client Hello.\nfunc checkALPN(clientProtos []string, serverProto string, quic bool) error {\n\tif serverProto == \"\" {\n\t\tif quic && len(clientProtos) > 0 {\n\t\t\t// RFC 9001, Section 8.1\n\t\t\treturn errors.New(\"tls: server did not select an ALPN protocol\")\n\t\t}\n\t\treturn nil\n\t}\n\tif len(clientProtos) == 0 {\n\t\treturn errors.New(\"tls: server advertised unrequested ALPN extension\")\n\t}\n\tfor _, proto := range clientProtos {\n\t\tif proto == serverProto {\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"tls: server selected unadvertised ALPN protocol\")\n}\n\nfunc (hs *clientHandshakeState) readFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.readChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tserverFinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverFinished, msg)\n\t}\n\n\tverify := hs.finishedHash.serverSum(hs.masterSecret)\n\tif len(verify) != len(serverFinished.verifyData) ||\n\t\tsubtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: server's Finished message was incorrect\")\n\t}\n\n\tif err := transcriptMsg(serverFinished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\t\n\tcopy(out, verify)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) readSessionTicket() error {\n\tif !hs.serverHello.ticketSupported {\n\t\treturn nil\n\t}\n\tc := hs.c\n\n\tif !hs.hello.ticketSupported {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server sent unrequested session ticket\")\n\t}\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsessionTicketMsg, ok := msg.(*newSessionTicketMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(sessionTicketMsg, msg)\n\t}\n\n\ths.ticket = sessionTicketMsg.ticket\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) saveSessionTicket() error {\n\tif hs.ticket == nil {\n\t\treturn nil\n\t}\n\tc := hs.c\n\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil\n\t}\n\n\tsession := c.sessionState()\n\tsession.secret = hs.masterSecret\n\tsession.ticket = hs.ticket\n\n\tcs := &ClientSessionState{session: session}\n\tc.config.ClientSessionCache.Put(cacheKey, cs)\n\treturn nil\n}\n\nfunc (hs *clientHandshakeState) sendFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.writeChangeCipherRecord(); err != nil {\n\t\treturn err\n\t}\n\n\tfinished := new(finishedMsg)\n\tfinished.verifyData = hs.finishedHash.clientSum(hs.masterSecret)\n\tif _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tcopy(out, finished.verifyData)\n\treturn nil\n}\n\n// defaultMaxRSAKeySize is the maximum RSA key size in bits that we are willing\n// to verify the signatures of during a TLS handshake.\nconst defaultMaxRSAKeySize = 8192\n\n//var tlsmaxrsasize = godebug.New(\"tlsmaxrsasize\")\n\nfunc checkKeySize(n int) (max int, ok bool) {\n\t// if v := tlsmaxrsasize.Value(); v != \"\" {\n\t// \tif max, err := strconv.Atoi(v); err == nil {\n\t// \t\tif (n <= max) != (n <= defaultMaxRSAKeySize) {\n\t// \t\t\ttlsmaxrsasize.IncNonDefault()\n\t// \t\t}\n\t// \t\treturn max, n <= max\n\t// \t}\n\t// }\n\treturn defaultMaxRSAKeySize, n <= defaultMaxRSAKeySize\n}\n\n// verifyServerCertificate parses and verifies the provided chain, setting\n// c.verifiedChains and c.peerCertificates or sending the appropriate alert.\nfunc (c *Conn) verifyServerCertificate(certificates [][]byte) error {\n\tactiveHandles := make([]*activeCert, len(certificates))\n\tcerts := make([]*x509.Certificate, len(certificates))\n\tfor i, asn1Data := range certificates {\n\t\tcert, err := globalCertCache.newCert(asn1Data)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: failed to parse certificate from server: \" + err.Error())\n\t\t}\n\t\tif cert.cert.PublicKeyAlgorithm == x509.RSA {\n\t\t\tn := cert.cert.PublicKey.(*rsa.PublicKey).N.BitLen()\n\t\t\tif max, ok := checkKeySize(n); !ok {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn fmt.Errorf(\"tls: server sent certificate containing RSA key larger than %d bits\", max)\n\t\t\t}\n\t\t}\n\t\tactiveHandles[i] = cert\n\t\tcerts[i] = cert.cert\n\t}\n\n\techRejected := c.config.EncryptedClientHelloConfigList != nil && !c.echAccepted\n\tif echRejected {\n\t\tif c.config.EncryptedClientHelloRejectionVerify != nil {\n\t\t\tif err := c.config.EncryptedClientHelloRejectionVerify(c.connectionStateLocked()); err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\topts := x509.VerifyOptions{\n\t\t\t\tRoots:         c.config.RootCAs,\n\t\t\t\tCurrentTime:   c.config.time(),\n\t\t\t\tDNSName:       c.serverName,\n\t\t\t\tIntermediates: x509.NewCertPool(),\n\t\t\t}\n\n\t\t\tfor _, cert := range certs[1:] {\n\t\t\t\topts.Intermediates.AddCert(cert)\n\t\t\t}\n\t\t\tvar err error\n\t\t\tc.verifiedChains, err = certs[0].Verify(opts)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t\t}\n\t\t}\n\t} else if !c.config.InsecureSkipVerify {\n\t\topts := x509.VerifyOptions{\n\t\t\tRoots:         c.config.RootCAs,\n\t\t\tCurrentTime:   c.config.time(),\n\t\t\tDNSName:       c.config.ServerName,\n\t\t\tIntermediates: x509.NewCertPool(),\n\t\t}\n\n\t\tfor _, cert := range certs[1:] {\n\t\t\topts.Intermediates.AddCert(cert)\n\t\t}\n\t\tvar err error\n\t\tc.verifiedChains, err = certs[0].Verify(opts)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t}\n\t}\n\n\tswitch certs[0].PublicKey.(type) {\n\tcase *rsa.PublicKey, *ecdsa.PublicKey, ed25519.PublicKey:\n\t\tbreak\n\tdefault:\n\t\tc.sendAlert(alertUnsupportedCertificate)\n\t\treturn fmt.Errorf(\"tls: server's certificate contains an unsupported type of public key: %T\", certs[0].PublicKey)\n\t}\n\n\tc.activeCertHandles = activeHandles\n\tc.peerCertificates = certs\n\n\tif c.config.VerifyPeerCertificate != nil && !echRejected {\n\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif c.config.VerifyConnection != nil && !echRejected {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// certificateRequestInfoFromMsg generates a CertificateRequestInfo from a TLS\n// <= 1.2 CertificateRequest, making an effort to fill in missing information.\nfunc certificateRequestInfoFromMsg(ctx context.Context, vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo {\n\tcri := &CertificateRequestInfo{\n\t\tAcceptableCAs: certReq.certificateAuthorities,\n\t\tVersion:       vers,\n\t\tctx:           ctx,\n\t}\n\n\tvar rsaAvail, ecAvail bool\n\tfor _, certType := range certReq.certificateTypes {\n\t\tswitch certType {\n\t\tcase certTypeRSASign:\n\t\t\trsaAvail = true\n\t\tcase certTypeECDSASign:\n\t\t\tecAvail = true\n\t\t}\n\t}\n\n\tif !certReq.hasSignatureAlgorithm {\n\t\t// Prior to TLS 1.2, signature schemes did not exist. In this case we\n\t\t// make up a list based on the acceptable certificate types, to help\n\t\t// GetClientCertificate and SupportsCertificate select the right certificate.\n\t\t// The hash part of the SignatureScheme is a lie here, because\n\t\t// TLS 1.0 and 1.1 always use MD5+SHA1 for RSA and SHA1 for ECDSA.\n\t\tswitch {\n\t\tcase rsaAvail && ecAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512,\n\t\t\t\tPKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1,\n\t\t\t}\n\t\tcase rsaAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tPKCS1WithSHA256, PKCS1WithSHA384, PKCS1WithSHA512, PKCS1WithSHA1,\n\t\t\t}\n\t\tcase ecAvail:\n\t\t\tcri.SignatureSchemes = []SignatureScheme{\n\t\t\t\tECDSAWithP256AndSHA256, ECDSAWithP384AndSHA384, ECDSAWithP521AndSHA512,\n\t\t\t}\n\t\t}\n\t\treturn cri\n\t}\n\n\t// Filter the signature schemes based on the certificate types.\n\t// See RFC 5246, Section 7.4.4 (where it calls this \"somewhat complicated\").\n\tcri.SignatureSchemes = make([]SignatureScheme, 0, len(certReq.supportedSignatureAlgorithms))\n\tfor _, sigScheme := range certReq.supportedSignatureAlgorithms {\n\t\tsigType, _, err := typeAndHashFromSignatureScheme(sigScheme)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tswitch sigType {\n\t\tcase signatureECDSA, signatureEd25519:\n\t\t\tif ecAvail {\n\t\t\t\tcri.SignatureSchemes = append(cri.SignatureSchemes, sigScheme)\n\t\t\t}\n\t\tcase signatureRSAPSS, signaturePKCS1v15:\n\t\t\tif rsaAvail {\n\t\t\t\tcri.SignatureSchemes = append(cri.SignatureSchemes, sigScheme)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cri\n}\n\nfunc (c *Conn) getClientCertificate(cri *CertificateRequestInfo) (*Certificate, error) {\n\tif c.config.GetClientCertificate != nil {\n\t\treturn c.config.GetClientCertificate(cri)\n\t}\n\n\tfor _, chain := range c.config.Certificates {\n\t\tif err := cri.SupportsCertificate(&chain); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn &chain, nil\n\t}\n\n\t// No acceptable certificate found. Don't send a certificate.\n\treturn new(Certificate), nil\n}\n\n// clientSessionCacheKey returns a key used to cache sessionTickets that could\n// be used to resume previously negotiated TLS sessions with a server.\nfunc (c *Conn) clientSessionCacheKey() string {\n\tif len(c.config.ServerName) > 0 {\n\t\treturn c.config.ServerName\n\t}\n\tif c.conn != nil {\n\t\treturn c.conn.RemoteAddr().String()\n\t}\n\treturn \"\"\n}\n\n// hostnameInSNI converts name into an appropriate hostname for SNI.\n// Literal IP addresses and absolute FQDNs are not permitted as SNI values.\n// See RFC 6066, Section 3.\nfunc hostnameInSNI(name string) string {\n\thost := name\n\tif len(host) > 0 && host[0] == '[' && host[len(host)-1] == ']' {\n\t\thost = host[1 : len(host)-1]\n\t}\n\tif i := strings.LastIndex(host, \"%\"); i > 0 {\n\t\thost = host[:i]\n\t}\n\tif net.ParseIP(host) != nil {\n\t\treturn \"\"\n\t}\n\tfor len(name) > 0 && name[len(name)-1] == '.' {\n\t\tname = name[:len(name)-1]\n\t}\n\treturn name\n}\n\nfunc computeAndUpdatePSK(m *clientHelloMsg, binderKey []byte, transcript hash.Hash, finishedHash func([]byte, hash.Hash) []byte) error {\n\thelloBytes, err := m.marshalWithoutBinders()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttranscript.Write(helloBytes)\n\tpskBinders := [][]byte{finishedHash(binderKey, transcript)}\n\treturn m.updateBinders(pskBinders)\n}\n"
        },
        {
          "name": "handshake_client_tls13.go",
          "type": "blob",
          "size": 27.8037109375,
          "content": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/hmac\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"errors\"\n\t\"hash\"\n\t\"slices\"\n\t\"time\"\n\n\t\"github.com/xtls/reality/mlkem768\"\n)\n\ntype clientHandshakeStateTLS13 struct {\n\tc            *Conn\n\tctx          context.Context\n\tserverHello  *serverHelloMsg\n\thello        *clientHelloMsg\n\tkeyShareKeys *keySharePrivateKeys\n\n\tsession     *SessionState\n\tearlySecret []byte\n\tbinderKey   []byte\n\n\tcertReq       *certificateRequestMsgTLS13\n\tusingPSK      bool\n\tsentDummyCCS  bool\n\tsuite         *cipherSuiteTLS13\n\ttranscript    hash.Hash\n\tmasterSecret  []byte\n\ttrafficSecret []byte // client_application_traffic_secret_0\n\techContext    *echContext\n}\n\n// handshake requires hs.c, hs.hello, hs.serverHello, hs.keyShareKeys, and,\n// optionally, hs.session, hs.earlySecret and hs.binderKey to be set.\nfunc (hs *clientHandshakeStateTLS13) handshake() error {\n\tc := hs.c\n\n\t// The server must not select TLS 1.3 in a renegotiation. See RFC 8446,\n\t// sections 4.1.2 and 4.1.3.\n\tif c.handshakes > 0 {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn errors.New(\"tls: server selected TLS 1.3 in a renegotiation\")\n\t}\n\n\t// Consistency check on the presence of a keyShare and its parameters.\n\tif hs.keyShareKeys == nil || hs.keyShareKeys.ecdhe == nil || len(hs.hello.keyShares) == 0 {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\n\tif err := hs.checkServerHelloOrHRR(); err != nil {\n\t\treturn err\n\t}\n\n\ths.transcript = hs.suite.hash.New()\n\n\tif err := transcriptMsg(hs.hello, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tif hs.echContext != nil {\n\t\ths.echContext.innerTranscript = hs.suite.hash.New()\n\t\tif err := transcriptMsg(hs.echContext.innerHello, hs.echContext.innerTranscript); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif bytes.Equal(hs.serverHello.random, helloRetryRequestRandom) {\n\t\tif err := hs.sendDummyChangeCipherSpec(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.processHelloRetryRequest(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar echRetryConfigList []byte\n\tif hs.echContext != nil {\n\t\tconfTranscript := cloneHash(hs.echContext.innerTranscript, hs.suite.hash)\n\t\tconfTranscript.Write(hs.serverHello.original[:30])\n\t\tconfTranscript.Write(make([]byte, 8))\n\t\tconfTranscript.Write(hs.serverHello.original[38:])\n\t\tacceptConfirmation := hs.suite.expandLabel(\n\t\t\ths.suite.extract(hs.echContext.innerHello.random, nil),\n\t\t\t\"ech accept confirmation\",\n\t\t\tconfTranscript.Sum(nil),\n\t\t\t8,\n\t\t)\n\t\tif subtle.ConstantTimeCompare(acceptConfirmation, hs.serverHello.random[len(hs.serverHello.random)-8:]) == 1 {\n\t\t\ths.hello = hs.echContext.innerHello\n\t\t\tc.serverName = c.config.ServerName\n\t\t\ths.transcript = hs.echContext.innerTranscript\n\t\t\tc.echAccepted = true\n\n\t\t\tif hs.serverHello.encryptedClientHello != nil {\n\t\t\t\tc.sendAlert(alertUnsupportedExtension)\n\t\t\t\treturn errors.New(\"tls: unexpected encrypted_client_hello extension in server hello despite ECH being accepted\")\n\t\t\t}\n\n\t\t\tif hs.hello.serverName == \"\" && hs.serverHello.serverNameAck {\n\t\t\t\tc.sendAlert(alertUnsupportedExtension)\n\t\t\t\treturn errors.New(\"tls: unexpected server_name extension in server hello\")\n\t\t\t}\n\t\t} else {\n\t\t\ths.echContext.echRejected = true\n\t\t\t// If the server sent us retry configs, we'll return these to\n\t\t\t// the user so they can update their Config.\n\t\t\techRetryConfigList = hs.serverHello.encryptedClientHello\n\t\t}\n\t}\n\n\tif err := transcriptMsg(hs.serverHello, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tc.buffering = true\n\tif err := hs.processServerHello(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.sendDummyChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.establishHandshakeKeys(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.readServerParameters(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.readServerCertificate(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.readServerFinished(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.sendClientCertificate(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.sendClientFinished(); err != nil {\n\t\treturn err\n\t}\n\tif _, err := c.flush(); err != nil {\n\t\treturn err\n\t}\n\n\tif hs.echContext != nil && hs.echContext.echRejected {\n\t\tc.sendAlert(alertECHRequired)\n\t\treturn &ECHRejectionError{echRetryConfigList}\n\t}\n\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\n// checkServerHelloOrHRR does validity checks that apply to both ServerHello and\n// HelloRetryRequest messages. It sets hs.suite.\nfunc (hs *clientHandshakeStateTLS13) checkServerHelloOrHRR() error {\n\tc := hs.c\n\n\tif hs.serverHello.supportedVersion == 0 {\n\t\tc.sendAlert(alertMissingExtension)\n\t\treturn errors.New(\"tls: server selected TLS 1.3 using the legacy version field\")\n\t}\n\n\tif hs.serverHello.supportedVersion != VersionTLS13 {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server selected an invalid version after a HelloRetryRequest\")\n\t}\n\n\tif hs.serverHello.vers != VersionTLS12 {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server sent an incorrect legacy version\")\n\t}\n\n\tif hs.serverHello.ocspStapling ||\n\t\ths.serverHello.ticketSupported ||\n\t\ths.serverHello.extendedMasterSecret ||\n\t\ths.serverHello.secureRenegotiationSupported ||\n\t\tlen(hs.serverHello.secureRenegotiation) != 0 ||\n\t\tlen(hs.serverHello.alpnProtocol) != 0 ||\n\t\tlen(hs.serverHello.scts) != 0 {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn errors.New(\"tls: server sent a ServerHello extension forbidden in TLS 1.3\")\n\t}\n\n\tif !bytes.Equal(hs.hello.sessionId, hs.serverHello.sessionId) {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server did not echo the legacy session ID\")\n\t}\n\n\tif hs.serverHello.compressionMethod != compressionNone {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server selected unsupported compression format\")\n\t}\n\n\tselectedSuite := mutualCipherSuiteTLS13(hs.hello.cipherSuites, hs.serverHello.cipherSuite)\n\tif hs.suite != nil && selectedSuite != hs.suite {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server changed cipher suite after a HelloRetryRequest\")\n\t}\n\tif selectedSuite == nil {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server chose an unconfigured cipher suite\")\n\t}\n\ths.suite = selectedSuite\n\tc.cipherSuite = hs.suite.id\n\n\treturn nil\n}\n\n// sendDummyChangeCipherSpec sends a ChangeCipherSpec record for compatibility\n// with middleboxes that didn't implement TLS correctly. See RFC 8446, Appendix D.4.\nfunc (hs *clientHandshakeStateTLS13) sendDummyChangeCipherSpec() error {\n\tif hs.c.quic != nil {\n\t\treturn nil\n\t}\n\tif hs.sentDummyCCS {\n\t\treturn nil\n\t}\n\ths.sentDummyCCS = true\n\n\treturn hs.c.writeChangeCipherRecord()\n}\n\n// processHelloRetryRequest handles the HRR in hs.serverHello, modifies and\n// resends hs.hello, and reads the new ServerHello into hs.serverHello.\nfunc (hs *clientHandshakeStateTLS13) processHelloRetryRequest() error {\n\tc := hs.c\n\n\t// The first ClientHello gets double-hashed into the transcript upon a\n\t// HelloRetryRequest. (The idea is that the server might offload transcript\n\t// storage to the client in the cookie.) See RFC 8446, Section 4.4.1.\n\tchHash := hs.transcript.Sum(nil)\n\ths.transcript.Reset()\n\ths.transcript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})\n\ths.transcript.Write(chHash)\n\tif err := transcriptMsg(hs.serverHello, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tvar isInnerHello bool\n\thello := hs.hello\n\tif hs.echContext != nil {\n\t\tchHash = hs.echContext.innerTranscript.Sum(nil)\n\t\ths.echContext.innerTranscript.Reset()\n\t\ths.echContext.innerTranscript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})\n\t\ths.echContext.innerTranscript.Write(chHash)\n\n\t\tif hs.serverHello.encryptedClientHello != nil {\n\t\t\tif len(hs.serverHello.encryptedClientHello) != 8 {\n\t\t\t\ths.c.sendAlert(alertDecodeError)\n\t\t\t\treturn errors.New(\"tls: malformed encrypted client hello extension\")\n\t\t\t}\n\n\t\t\tconfTranscript := cloneHash(hs.echContext.innerTranscript, hs.suite.hash)\n\t\t\thrrHello := make([]byte, len(hs.serverHello.original))\n\t\t\tcopy(hrrHello, hs.serverHello.original)\n\t\t\thrrHello = bytes.Replace(hrrHello, hs.serverHello.encryptedClientHello, make([]byte, 8), 1)\n\t\t\tconfTranscript.Write(hrrHello)\n\t\t\tacceptConfirmation := hs.suite.expandLabel(\n\t\t\t\ths.suite.extract(hs.echContext.innerHello.random, nil),\n\t\t\t\t\"hrr ech accept confirmation\",\n\t\t\t\tconfTranscript.Sum(nil),\n\t\t\t\t8,\n\t\t\t)\n\t\t\tif subtle.ConstantTimeCompare(acceptConfirmation, hs.serverHello.encryptedClientHello) == 1 {\n\t\t\t\thello = hs.echContext.innerHello\n\t\t\t\tc.serverName = c.config.ServerName\n\t\t\t\tisInnerHello = true\n\t\t\t\tc.echAccepted = true\n\t\t\t}\n\t\t}\n\n\t\tif err := transcriptMsg(hs.serverHello, hs.echContext.innerTranscript); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if hs.serverHello.encryptedClientHello != nil {\n\t\t// Unsolicited ECH extension should be rejected\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn errors.New(\"tls: unexpected ECH extension in serverHello\")\n\t}\n\n\t// The only HelloRetryRequest extensions we support are key_share and\n\t// cookie, and clients must abort the handshake if the HRR would not result\n\t// in any change in the ClientHello.\n\tif hs.serverHello.selectedGroup == 0 && hs.serverHello.cookie == nil {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server sent an unnecessary HelloRetryRequest message\")\n\t}\n\n\tif hs.serverHello.cookie != nil {\n\t\thello.cookie = hs.serverHello.cookie\n\t}\n\n\tif hs.serverHello.serverShare.group != 0 {\n\t\tc.sendAlert(alertDecodeError)\n\t\treturn errors.New(\"tls: received malformed key_share extension\")\n\t}\n\n\t// If the server sent a key_share extension selecting a group, ensure it's\n\t// a group we advertised but did not send a key share for, and send a key\n\t// share for it this time.\n\tif curveID := hs.serverHello.selectedGroup; curveID != 0 {\n\t\tif !slices.Contains(hello.supportedCurves, curveID) {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: server selected unsupported group\")\n\t\t}\n\t\tif slices.ContainsFunc(hs.hello.keyShares, func(ks keyShare) bool {\n\t\t\treturn ks.group == curveID\n\t\t}) {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: server sent an unnecessary HelloRetryRequest key_share\")\n\t\t}\n\t\t// Note: we don't support selecting X25519Kyber768Draft00 in a HRR,\n\t\t// because we currently only support it at all when CurvePreferences is\n\t\t// empty, which will cause us to also send a key share for it.\n\t\t//\n\t\t// This will have to change once we support selecting hybrid KEMs\n\t\t// without sending key shares for them.\n\t\tif _, ok := curveForCurveID(curveID); !ok {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn errors.New(\"tls: CurvePreferences includes unsupported curve\")\n\t\t}\n\t\tkey, err := generateECDHEKey(c.config.rand(), curveID)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\t\ths.keyShareKeys = &keySharePrivateKeys{curveID: curveID, ecdhe: key}\n\t\thello.keyShares = []keyShare{{group: curveID, data: key.PublicKey().Bytes()}}\n\t}\n\n\tif len(hello.pskIdentities) > 0 {\n\t\tpskSuite := cipherSuiteTLS13ByID(hs.session.cipherSuite)\n\t\tif pskSuite == nil {\n\t\t\treturn c.sendAlert(alertInternalError)\n\t\t}\n\t\tif pskSuite.hash == hs.suite.hash {\n\t\t\t// Update binders and obfuscated_ticket_age.\n\t\t\tticketAge := c.config.time().Sub(time.Unix(int64(hs.session.createdAt), 0))\n\t\t\thello.pskIdentities[0].obfuscatedTicketAge = uint32(ticketAge/time.Millisecond) + hs.session.ageAdd\n\n\t\t\ttranscript := hs.suite.hash.New()\n\t\t\ttranscript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})\n\t\t\ttranscript.Write(chHash)\n\t\t\tif err := transcriptMsg(hs.serverHello, transcript); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := computeAndUpdatePSK(hello, hs.binderKey, transcript, hs.suite.finishedHash); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// Server selected a cipher suite incompatible with the PSK.\n\t\t\thello.pskIdentities = nil\n\t\t\thello.pskBinders = nil\n\t\t}\n\t}\n\n\tif hello.earlyData {\n\t\thello.earlyData = false\n\t\tc.quicRejectedEarlyData()\n\t}\n\n\tif isInnerHello {\n\t\t// Any extensions which have changed in hello, but are mirrored in the\n\t\t// outer hello and compressed, need to be copied to the outer hello, so\n\t\t// they can be properly decompressed by the server. For now, the only\n\t\t// extension which may have changed is keyShares.\n\t\ths.hello.keyShares = hello.keyShares\n\t\ths.echContext.innerHello = hello\n\t\tif err := transcriptMsg(hs.echContext.innerHello, hs.echContext.innerTranscript); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := computeAndUpdateOuterECHExtension(hs.hello, hs.echContext.innerHello, hs.echContext, false); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\ths.hello = hello\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\t// serverHelloMsg is not included in the transcript\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserverHello, ok := msg.(*serverHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(serverHello, msg)\n\t}\n\ths.serverHello = serverHello\n\n\tif err := hs.checkServerHelloOrHRR(); err != nil {\n\t\treturn err\n\t}\n\n\tc.didHRR = true\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) processServerHello() error {\n\tc := hs.c\n\n\tif bytes.Equal(hs.serverHello.random, helloRetryRequestRandom) {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn errors.New(\"tls: server sent two HelloRetryRequest messages\")\n\t}\n\n\tif len(hs.serverHello.cookie) != 0 {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn errors.New(\"tls: server sent a cookie in a normal ServerHello\")\n\t}\n\n\tif hs.serverHello.selectedGroup != 0 {\n\t\tc.sendAlert(alertDecodeError)\n\t\treturn errors.New(\"tls: malformed key_share extension\")\n\t}\n\n\tif hs.serverHello.serverShare.group == 0 {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server did not send a key share\")\n\t}\n\tif !slices.ContainsFunc(hs.hello.keyShares, func(ks keyShare) bool {\n\t\treturn ks.group == hs.serverHello.serverShare.group\n\t}) {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server selected unsupported group\")\n\t}\n\n\tif !hs.serverHello.selectedIdentityPresent {\n\t\treturn nil\n\t}\n\n\tif int(hs.serverHello.selectedIdentity) >= len(hs.hello.pskIdentities) {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server selected an invalid PSK\")\n\t}\n\n\tif len(hs.hello.pskIdentities) != 1 || hs.session == nil {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\tpskSuite := cipherSuiteTLS13ByID(hs.session.cipherSuite)\n\tif pskSuite == nil {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\tif pskSuite.hash != hs.suite.hash {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: server selected an invalid PSK and cipher suite pair\")\n\t}\n\n\ths.usingPSK = true\n\tc.didResume = true\n\tc.peerCertificates = hs.session.peerCertificates\n\tc.activeCertHandles = hs.session.activeCertHandles\n\tc.verifiedChains = hs.session.verifiedChains\n\tc.ocspResponse = hs.session.ocspResponse\n\tc.scts = hs.session.scts\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) establishHandshakeKeys() error {\n\tc := hs.c\n\n\tecdhePeerData := hs.serverHello.serverShare.data\n\tif hs.serverHello.serverShare.group == x25519Kyber768Draft00 {\n\t\tif len(ecdhePeerData) != x25519PublicKeySize+mlkem768.CiphertextSize {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: invalid server key share\")\n\t\t}\n\t\tecdhePeerData = hs.serverHello.serverShare.data[:x25519PublicKeySize]\n\t}\n\tpeerKey, err := hs.keyShareKeys.ecdhe.Curve().NewPublicKey(ecdhePeerData)\n\tif err != nil {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: invalid server key share\")\n\t}\n\tsharedKey, err := hs.keyShareKeys.ecdhe.ECDH(peerKey)\n\tif err != nil {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: invalid server key share\")\n\t}\n\tif hs.serverHello.serverShare.group == x25519Kyber768Draft00 {\n\t\tif hs.keyShareKeys.kyber == nil {\n\t\t\treturn c.sendAlert(alertInternalError)\n\t\t}\n\t\tciphertext := hs.serverHello.serverShare.data[x25519PublicKeySize:]\n\t\tkyberShared, err := kyberDecapsulate(hs.keyShareKeys.kyber, ciphertext)\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: invalid Kyber server key share\")\n\t\t}\n\t\tsharedKey = append(sharedKey, kyberShared...)\n\t}\n\tc.curveID = hs.serverHello.serverShare.group\n\n\tearlySecret := hs.earlySecret\n\tif !hs.usingPSK {\n\t\tearlySecret = hs.suite.extract(nil, nil)\n\t}\n\n\thandshakeSecret := hs.suite.extract(sharedKey,\n\t\ths.suite.deriveSecret(earlySecret, \"derived\", nil))\n\n\tclientSecret := hs.suite.deriveSecret(handshakeSecret,\n\t\tclientHandshakeTrafficLabel, hs.transcript)\n\tc.out.setTrafficSecret(hs.suite, QUICEncryptionLevelHandshake, clientSecret)\n\tserverSecret := hs.suite.deriveSecret(handshakeSecret,\n\t\tserverHandshakeTrafficLabel, hs.transcript)\n\tc.in.setTrafficSecret(hs.suite, QUICEncryptionLevelHandshake, serverSecret)\n\n\tif c.quic != nil {\n\t\tif c.hand.Len() != 0 {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t}\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelHandshake, hs.suite.id, clientSecret)\n\t\tc.quicSetReadSecret(QUICEncryptionLevelHandshake, hs.suite.id, serverSecret)\n\t}\n\n\terr = c.config.writeKeyLog(keyLogLabelClientHandshake, hs.hello.random, clientSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\terr = c.config.writeKeyLog(keyLogLabelServerHandshake, hs.hello.random, serverSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\ths.masterSecret = hs.suite.extract(nil,\n\t\ths.suite.deriveSecret(handshakeSecret, \"derived\", nil))\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) readServerParameters() error {\n\tc := hs.c\n\n\tmsg, err := c.readHandshake(hs.transcript)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tencryptedExtensions, ok := msg.(*encryptedExtensionsMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(encryptedExtensions, msg)\n\t}\n\n\tif err := checkALPN(hs.hello.alpnProtocols, encryptedExtensions.alpnProtocol, c.quic != nil); err != nil {\n\t\t// RFC 8446 specifies that no_application_protocol is sent by servers, but\n\t\t// does not specify how clients handle the selection of an incompatible protocol.\n\t\t// RFC 9001 Section 8.1 specifies that QUIC clients send no_application_protocol\n\t\t// in this case. Always sending no_application_protocol seems reasonable.\n\t\tc.sendAlert(alertNoApplicationProtocol)\n\t\treturn err\n\t}\n\tc.clientProtocol = encryptedExtensions.alpnProtocol\n\n\tif c.quic != nil {\n\t\tif encryptedExtensions.quicTransportParameters == nil {\n\t\t\t// RFC 9001 Section 8.2.\n\t\t\tc.sendAlert(alertMissingExtension)\n\t\t\treturn errors.New(\"tls: server did not send a quic_transport_parameters extension\")\n\t\t}\n\t\tc.quicSetTransportParameters(encryptedExtensions.quicTransportParameters)\n\t} else {\n\t\tif encryptedExtensions.quicTransportParameters != nil {\n\t\t\tc.sendAlert(alertUnsupportedExtension)\n\t\t\treturn errors.New(\"tls: server sent an unexpected quic_transport_parameters extension\")\n\t\t}\n\t}\n\n\tif !hs.hello.earlyData && encryptedExtensions.earlyData {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn errors.New(\"tls: server sent an unexpected early_data extension\")\n\t}\n\tif hs.hello.earlyData && !encryptedExtensions.earlyData {\n\t\tc.quicRejectedEarlyData()\n\t}\n\tif encryptedExtensions.earlyData {\n\t\tif hs.session.cipherSuite != c.cipherSuite {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn errors.New(\"tls: server accepted 0-RTT with the wrong cipher suite\")\n\t\t}\n\t\tif hs.session.alpnProtocol != c.clientProtocol {\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t\treturn errors.New(\"tls: server accepted 0-RTT with the wrong ALPN\")\n\t\t}\n\t}\n\tif hs.echContext != nil && !hs.echContext.echRejected && encryptedExtensions.echRetryConfigs != nil {\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn errors.New(\"tls: server sent ECH retry configs after accepting ECH\")\n\t}\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) readServerCertificate() error {\n\tc := hs.c\n\n\t// Either a PSK or a certificate is always used, but not both.\n\t// See RFC 8446, Section 4.1.1.\n\tif hs.usingPSK {\n\t\t// Make sure the connection is still being verified whether or not this\n\t\t// is a resumption. Resumptions currently don't reverify certificates so\n\t\t// they don't call verifyServerCertificate. See Issue 31641.\n\t\tif c.config.VerifyConnection != nil {\n\t\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tmsg, err := c.readHandshake(hs.transcript)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertReq, ok := msg.(*certificateRequestMsgTLS13)\n\tif ok {\n\t\ths.certReq = certReq\n\n\t\tmsg, err = c.readHandshake(hs.transcript)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcertMsg, ok := msg.(*certificateMsgTLS13)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(certMsg, msg)\n\t}\n\tif len(certMsg.certificate.Certificate) == 0 {\n\t\tc.sendAlert(alertDecodeError)\n\t\treturn errors.New(\"tls: received empty certificates message\")\n\t}\n\n\tc.scts = certMsg.certificate.SignedCertificateTimestamps\n\tc.ocspResponse = certMsg.certificate.OCSPStaple\n\n\tif err := c.verifyServerCertificate(certMsg.certificate.Certificate); err != nil {\n\t\treturn err\n\t}\n\n\t// certificateVerifyMsg is included in the transcript, but not until\n\t// after we verify the handshake signature, since the state before\n\t// this message was sent is used.\n\tmsg, err = c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertVerify, ok := msg.(*certificateVerifyMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(certVerify, msg)\n\t}\n\n\t// See RFC 8446, Section 4.4.3.\n\tif !isSupportedSignatureAlgorithm(certVerify.signatureAlgorithm, supportedSignatureAlgorithms()) {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: certificate used with invalid signature algorithm\")\n\t}\n\tsigType, sigHash, err := typeAndHashFromSignatureScheme(certVerify.signatureAlgorithm)\n\tif err != nil {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\tif sigType == signaturePKCS1v15 || sigHash == crypto.SHA1 {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: certificate used with invalid signature algorithm\")\n\t}\n\tsigned := signedMessage(sigHash, serverSignatureContext, hs.transcript)\n\tif err := verifyHandshakeSignature(sigType, c.peerCertificates[0].PublicKey,\n\t\tsigHash, signed, certVerify.signature); err != nil {\n\t\tc.sendAlert(alertDecryptError)\n\t\treturn errors.New(\"tls: invalid signature by the server certificate: \" + err.Error())\n\t}\n\n\tif err := transcriptMsg(certVerify, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) readServerFinished() error {\n\tc := hs.c\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(finished, msg)\n\t}\n\n\texpectedMAC := hs.suite.finishedHash(c.in.trafficSecret, hs.transcript)\n\tif !hmac.Equal(expectedMAC, finished.verifyData) {\n\t\tc.sendAlert(alertDecryptError)\n\t\treturn errors.New(\"tls: invalid server finished hash\")\n\t}\n\n\tif err := transcriptMsg(finished, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\t// Derive secrets that take context through the server Finished.\n\n\ths.trafficSecret = hs.suite.deriveSecret(hs.masterSecret,\n\t\tclientApplicationTrafficLabel, hs.transcript)\n\tserverSecret := hs.suite.deriveSecret(hs.masterSecret,\n\t\tserverApplicationTrafficLabel, hs.transcript)\n\tc.in.setTrafficSecret(hs.suite, QUICEncryptionLevelApplication, serverSecret)\n\n\terr = c.config.writeKeyLog(keyLogLabelClientTraffic, hs.hello.random, hs.trafficSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\terr = c.config.writeKeyLog(keyLogLabelServerTraffic, hs.hello.random, serverSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tc.ekm = hs.suite.exportKeyingMaterial(hs.masterSecret, hs.transcript)\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) sendClientCertificate() error {\n\tc := hs.c\n\n\tif hs.certReq == nil {\n\t\treturn nil\n\t}\n\n\tif hs.echContext != nil && hs.echContext.echRejected {\n\t\tif _, err := hs.c.writeHandshakeRecord(&certificateMsgTLS13{}, hs.transcript); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\tcert, err := c.getClientCertificate(&CertificateRequestInfo{\n\t\tAcceptableCAs:    hs.certReq.certificateAuthorities,\n\t\tSignatureSchemes: hs.certReq.supportedSignatureAlgorithms,\n\t\tVersion:          c.vers,\n\t\tctx:              hs.ctx,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertMsg := new(certificateMsgTLS13)\n\n\tcertMsg.certificate = *cert\n\tcertMsg.scts = hs.certReq.scts && len(cert.SignedCertificateTimestamps) > 0\n\tcertMsg.ocspStapling = hs.certReq.ocspStapling && len(cert.OCSPStaple) > 0\n\n\tif _, err := hs.c.writeHandshakeRecord(certMsg, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\t// If we sent an empty certificate message, skip the CertificateVerify.\n\tif len(cert.Certificate) == 0 {\n\t\treturn nil\n\t}\n\n\tcertVerifyMsg := new(certificateVerifyMsg)\n\tcertVerifyMsg.hasSignatureAlgorithm = true\n\n\tcertVerifyMsg.signatureAlgorithm, err = selectSignatureScheme(c.vers, cert, hs.certReq.supportedSignatureAlgorithms)\n\tif err != nil {\n\t\t// getClientCertificate returned a certificate incompatible with the\n\t\t// CertificateRequestInfo supported signature algorithms.\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\n\tsigType, sigHash, err := typeAndHashFromSignatureScheme(certVerifyMsg.signatureAlgorithm)\n\tif err != nil {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\n\tsigned := signedMessage(sigHash, clientSignatureContext, hs.transcript)\n\tsignOpts := crypto.SignerOpts(sigHash)\n\tif sigType == signatureRSAPSS {\n\t\tsignOpts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: sigHash}\n\t}\n\tsig, err := cert.PrivateKey.(crypto.Signer).Sign(c.config.rand(), signed, signOpts)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn errors.New(\"tls: failed to sign handshake: \" + err.Error())\n\t}\n\tcertVerifyMsg.signature = sig\n\n\tif _, err := hs.c.writeHandshakeRecord(certVerifyMsg, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *clientHandshakeStateTLS13) sendClientFinished() error {\n\tc := hs.c\n\n\tfinished := &finishedMsg{\n\t\tverifyData: hs.suite.finishedHash(c.out.trafficSecret, hs.transcript),\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(finished, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tc.out.setTrafficSecret(hs.suite, QUICEncryptionLevelApplication, hs.trafficSecret)\n\n\tif !c.config.SessionTicketsDisabled && c.config.ClientSessionCache != nil {\n\t\tc.resumptionSecret = hs.suite.deriveSecret(hs.masterSecret,\n\t\t\tresumptionLabel, hs.transcript)\n\t}\n\n\tif c.quic != nil {\n\t\tif c.hand.Len() != 0 {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t}\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelApplication, hs.suite.id, hs.trafficSecret)\n\t}\n\n\treturn nil\n}\n\nfunc (c *Conn) handleNewSessionTicket(msg *newSessionTicketMsgTLS13) error {\n\tif !c.isClient {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn errors.New(\"tls: received new session ticket from a client\")\n\t}\n\n\tif c.config.SessionTicketsDisabled || c.config.ClientSessionCache == nil {\n\t\treturn nil\n\t}\n\n\t// See RFC 8446, Section 4.6.1.\n\tif msg.lifetime == 0 {\n\t\treturn nil\n\t}\n\tlifetime := time.Duration(msg.lifetime) * time.Second\n\tif lifetime > maxSessionTicketLifetime {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: received a session ticket with invalid lifetime\")\n\t}\n\n\t// RFC 9001, Section 4.6.1\n\tif c.quic != nil && msg.maxEarlyData != 0 && msg.maxEarlyData != 0xffffffff {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: invalid early data for QUIC connection\")\n\t}\n\n\tcipherSuite := cipherSuiteTLS13ByID(c.cipherSuite)\n\tif cipherSuite == nil || c.resumptionSecret == nil {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\n\tpsk := cipherSuite.expandLabel(c.resumptionSecret, \"resumption\",\n\t\tmsg.nonce, cipherSuite.hash.Size())\n\n\tsession := c.sessionState()\n\tsession.secret = psk\n\tsession.useBy = uint64(c.config.time().Add(lifetime).Unix())\n\tsession.ageAdd = msg.ageAdd\n\tsession.EarlyData = c.quic != nil && msg.maxEarlyData == 0xffffffff // RFC 9001, Section 4.6.1\n\tsession.ticket = msg.label\n\tif c.quic != nil && c.quic.enableSessionEvents {\n\t\tc.quicStoreSession(session)\n\t\treturn nil\n\t}\n\tcs := &ClientSessionState{session: session}\n\tif cacheKey := c.clientSessionCacheKey(); cacheKey != \"\" {\n\t\tc.config.ClientSessionCache.Put(cacheKey, cs)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "handshake_messages.go",
          "type": "blob",
          "size": 51.9482421875,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"slices\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/cryptobyte\"\n)\n\n// The marshalingFunction type is an adapter to allow the use of ordinary\n// functions as cryptobyte.MarshalingValue.\ntype marshalingFunction func(b *cryptobyte.Builder) error\n\nfunc (f marshalingFunction) Marshal(b *cryptobyte.Builder) error {\n\treturn f(b)\n}\n\n// addBytesWithLength appends a sequence of bytes to the cryptobyte.Builder. If\n// the length of the sequence is not the value specified, it produces an error.\nfunc addBytesWithLength(b *cryptobyte.Builder, v []byte, n int) {\n\tb.AddValue(marshalingFunction(func(b *cryptobyte.Builder) error {\n\t\tif len(v) != n {\n\t\t\treturn fmt.Errorf(\"invalid value length: expected %d, got %d\", n, len(v))\n\t\t}\n\t\tb.AddBytes(v)\n\t\treturn nil\n\t}))\n}\n\n// addUint64 appends a big-endian, 64-bit value to the cryptobyte.Builder.\nfunc addUint64(b *cryptobyte.Builder, v uint64) {\n\tb.AddUint32(uint32(v >> 32))\n\tb.AddUint32(uint32(v))\n}\n\n// readUint64 decodes a big-endian, 64-bit value into out and advances over it.\n// It reports whether the read was successful.\nfunc readUint64(s *cryptobyte.String, out *uint64) bool {\n\tvar hi, lo uint32\n\tif !s.ReadUint32(&hi) || !s.ReadUint32(&lo) {\n\t\treturn false\n\t}\n\t*out = uint64(hi)<<32 | uint64(lo)\n\treturn true\n}\n\n// readUint8LengthPrefixed acts like s.ReadUint8LengthPrefixed, but targets a\n// []byte instead of a cryptobyte.String.\nfunc readUint8LengthPrefixed(s *cryptobyte.String, out *[]byte) bool {\n\treturn s.ReadUint8LengthPrefixed((*cryptobyte.String)(out))\n}\n\n// readUint16LengthPrefixed acts like s.ReadUint16LengthPrefixed, but targets a\n// []byte instead of a cryptobyte.String.\nfunc readUint16LengthPrefixed(s *cryptobyte.String, out *[]byte) bool {\n\treturn s.ReadUint16LengthPrefixed((*cryptobyte.String)(out))\n}\n\n// readUint24LengthPrefixed acts like s.ReadUint24LengthPrefixed, but targets a\n// []byte instead of a cryptobyte.String.\nfunc readUint24LengthPrefixed(s *cryptobyte.String, out *[]byte) bool {\n\treturn s.ReadUint24LengthPrefixed((*cryptobyte.String)(out))\n}\n\ntype clientHelloMsg struct {\n\toriginal                         []byte\n\tvers                             uint16\n\trandom                           []byte\n\tsessionId                        []byte\n\tcipherSuites                     []uint16\n\tcompressionMethods               []uint8\n\tserverName                       string\n\tocspStapling                     bool\n\tsupportedCurves                  []CurveID\n\tsupportedPoints                  []uint8\n\tticketSupported                  bool\n\tsessionTicket                    []uint8\n\tsupportedSignatureAlgorithms     []SignatureScheme\n\tsupportedSignatureAlgorithmsCert []SignatureScheme\n\tsecureRenegotiationSupported     bool\n\tsecureRenegotiation              []byte\n\textendedMasterSecret             bool\n\talpnProtocols                    []string\n\tscts                             bool\n\tsupportedVersions                []uint16\n\tcookie                           []byte\n\tkeyShares                        []keyShare\n\tearlyData                        bool\n\tpskModes                         []uint8\n\tpskIdentities                    []pskIdentity\n\tpskBinders                       [][]byte\n\tquicTransportParameters          []byte\n\tencryptedClientHello             []byte\n\t// extensions are only populated on the server-side of a handshake\n\textensions []uint16\n}\n\nfunc (m *clientHelloMsg) marshalMsg(echInner bool) ([]byte, error) {\n\tvar exts cryptobyte.Builder\n\tif len(m.serverName) > 0 {\n\t\t// RFC 6066, Section 3\n\t\texts.AddUint16(extensionServerName)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint8(0) // name_type = host_name\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\texts.AddBytes([]byte(m.serverName))\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\tif len(m.supportedPoints) > 0 && !echInner {\n\t\t// RFC 4492, Section 5.1.2\n\t\texts.AddUint16(extensionSupportedPoints)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddBytes(m.supportedPoints)\n\t\t\t})\n\t\t})\n\t}\n\tif m.ticketSupported && !echInner {\n\t\t// RFC 5077, Section 3.2\n\t\texts.AddUint16(extensionSessionTicket)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddBytes(m.sessionTicket)\n\t\t})\n\t}\n\tif m.secureRenegotiationSupported && !echInner {\n\t\t// RFC 5746, Section 3.2\n\t\texts.AddUint16(extensionRenegotiationInfo)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddBytes(m.secureRenegotiation)\n\t\t\t})\n\t\t})\n\t}\n\tif m.extendedMasterSecret && !echInner {\n\t\t// RFC 7627\n\t\texts.AddUint16(extensionExtendedMasterSecret)\n\t\texts.AddUint16(0) // empty extension_data\n\t}\n\tif m.scts {\n\t\t// RFC 6962, Section 3.3.1\n\t\texts.AddUint16(extensionSCT)\n\t\texts.AddUint16(0) // empty extension_data\n\t}\n\tif m.earlyData {\n\t\t// RFC 8446, Section 4.2.10\n\t\texts.AddUint16(extensionEarlyData)\n\t\texts.AddUint16(0) // empty extension_data\n\t}\n\tif m.quicTransportParameters != nil { // marshal zero-length parameters when present\n\t\t// RFC 9001, Section 8.2\n\t\texts.AddUint16(extensionQUICTransportParameters)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddBytes(m.quicTransportParameters)\n\t\t})\n\t}\n\tif len(m.encryptedClientHello) > 0 {\n\t\texts.AddUint16(extensionEncryptedClientHello)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddBytes(m.encryptedClientHello)\n\t\t})\n\t}\n\t// Note that any extension that can be compressed during ECH must be\n\t// contiguous. If any additional extensions are to be compressed they must\n\t// be added to the following block, so that they can be properly\n\t// decompressed on the other side.\n\tvar echOuterExts []uint16\n\tif m.ocspStapling {\n\t\t// RFC 4366, Section 3.6\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionStatusRequest)\n\t\t} else {\n\t\t\texts.AddUint16(extensionStatusRequest)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint8(1)  // status_type = ocsp\n\t\t\t\texts.AddUint16(0) // empty responder_id_list\n\t\t\t\texts.AddUint16(0) // empty request_extensions\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.supportedCurves) > 0 {\n\t\t// RFC 4492, sections 5.1.1 and RFC 8446, Section 4.2.7\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionSupportedCurves)\n\t\t} else {\n\t\t\texts.AddUint16(extensionSupportedCurves)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\tfor _, curve := range m.supportedCurves {\n\t\t\t\t\t\texts.AddUint16(uint16(curve))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.supportedSignatureAlgorithms) > 0 {\n\t\t// RFC 5246, Section 7.4.1.4.1\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionSignatureAlgorithms)\n\t\t} else {\n\t\t\texts.AddUint16(extensionSignatureAlgorithms)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\tfor _, sigAlgo := range m.supportedSignatureAlgorithms {\n\t\t\t\t\t\texts.AddUint16(uint16(sigAlgo))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.supportedSignatureAlgorithmsCert) > 0 {\n\t\t// RFC 8446, Section 4.2.3\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionSignatureAlgorithmsCert)\n\t\t} else {\n\t\t\texts.AddUint16(extensionSignatureAlgorithmsCert)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\tfor _, sigAlgo := range m.supportedSignatureAlgorithmsCert {\n\t\t\t\t\t\texts.AddUint16(uint16(sigAlgo))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.alpnProtocols) > 0 {\n\t\t// RFC 7301, Section 3.1\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionALPN)\n\t\t} else {\n\t\t\texts.AddUint16(extensionALPN)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\tfor _, proto := range m.alpnProtocols {\n\t\t\t\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\t\t\texts.AddBytes([]byte(proto))\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.supportedVersions) > 0 {\n\t\t// RFC 8446, Section 4.2.1\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionSupportedVersions)\n\t\t} else {\n\t\t\texts.AddUint16(extensionSupportedVersions)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\tfor _, vers := range m.supportedVersions {\n\t\t\t\t\t\texts.AddUint16(vers)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.cookie) > 0 {\n\t\t// RFC 8446, Section 4.2.2\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionCookie)\n\t\t} else {\n\t\t\texts.AddUint16(extensionCookie)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\texts.AddBytes(m.cookie)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.keyShares) > 0 {\n\t\t// RFC 8446, Section 4.2.8\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionKeyShare)\n\t\t} else {\n\t\t\texts.AddUint16(extensionKeyShare)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\tfor _, ks := range m.keyShares {\n\t\t\t\t\t\texts.AddUint16(uint16(ks.group))\n\t\t\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\t\t\texts.AddBytes(ks.data)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(m.pskModes) > 0 {\n\t\t// RFC 8446, Section 4.2.9\n\t\tif echInner {\n\t\t\techOuterExts = append(echOuterExts, extensionPSKModes)\n\t\t} else {\n\t\t\texts.AddUint16(extensionPSKModes)\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\texts.AddBytes(m.pskModes)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t}\n\tif len(echOuterExts) > 0 && echInner {\n\t\texts.AddUint16(extensionECHOuterExtensions)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\tfor _, e := range echOuterExts {\n\t\t\t\t\texts.AddUint16(e)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\tif len(m.pskIdentities) > 0 { // pre_shared_key must be the last extension\n\t\t// RFC 8446, Section 4.2.11\n\t\texts.AddUint16(extensionPreSharedKey)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\tfor _, psk := range m.pskIdentities {\n\t\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\t\texts.AddBytes(psk.label)\n\t\t\t\t\t})\n\t\t\t\t\texts.AddUint32(psk.obfuscatedTicketAge)\n\t\t\t\t}\n\t\t\t})\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\tfor _, binder := range m.pskBinders {\n\t\t\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\t\texts.AddBytes(binder)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\textBytes, err := exts.Bytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeClientHello)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddUint16(m.vers)\n\t\taddBytesWithLength(b, m.random, 32)\n\t\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tif !echInner {\n\t\t\t\tb.AddBytes(m.sessionId)\n\t\t\t}\n\t\t})\n\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tfor _, suite := range m.cipherSuites {\n\t\t\t\tb.AddUint16(suite)\n\t\t\t}\n\t\t})\n\t\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes(m.compressionMethods)\n\t\t})\n\n\t\tif len(extBytes) > 0 {\n\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\tb.AddBytes(extBytes)\n\t\t\t})\n\t\t}\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *clientHelloMsg) marshal() ([]byte, error) {\n\treturn m.marshalMsg(false)\n}\n\n// marshalWithoutBinders returns the ClientHello through the\n// PreSharedKeyExtension.identities field, according to RFC 8446, Section\n// 4.2.11.2. Note that m.pskBinders must be set to slices of the correct length.\nfunc (m *clientHelloMsg) marshalWithoutBinders() ([]byte, error) {\n\tbindersLen := 2 // uint16 length prefix\n\tfor _, binder := range m.pskBinders {\n\t\tbindersLen += 1 // uint8 length prefix\n\t\tbindersLen += len(binder)\n\t}\n\n\tvar fullMessage []byte\n\tif m.original != nil {\n\t\tfullMessage = m.original\n\t} else {\n\t\tvar err error\n\t\tfullMessage, err = m.marshal()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn fullMessage[:len(fullMessage)-bindersLen], nil\n}\n\n// updateBinders updates the m.pskBinders field. The supplied binders must have\n// the same length as the current m.pskBinders.\nfunc (m *clientHelloMsg) updateBinders(pskBinders [][]byte) error {\n\tif len(pskBinders) != len(m.pskBinders) {\n\t\treturn errors.New(\"tls: internal error: pskBinders length mismatch\")\n\t}\n\tfor i := range m.pskBinders {\n\t\tif len(pskBinders[i]) != len(m.pskBinders[i]) {\n\t\t\treturn errors.New(\"tls: internal error: pskBinders length mismatch\")\n\t\t}\n\t}\n\tm.pskBinders = pskBinders\n\n\treturn nil\n}\n\nfunc (m *clientHelloMsg) unmarshal(data []byte) bool {\n\t*m = clientHelloMsg{original: data}\n\ts := cryptobyte.String(data)\n\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint16(&m.vers) || !s.ReadBytes(&m.random, 32) ||\n\t\t!readUint8LengthPrefixed(&s, &m.sessionId) {\n\t\treturn false\n\t}\n\n\tvar cipherSuites cryptobyte.String\n\tif !s.ReadUint16LengthPrefixed(&cipherSuites) {\n\t\treturn false\n\t}\n\tm.cipherSuites = []uint16{}\n\tm.secureRenegotiationSupported = false\n\tfor !cipherSuites.Empty() {\n\t\tvar suite uint16\n\t\tif !cipherSuites.ReadUint16(&suite) {\n\t\t\treturn false\n\t\t}\n\t\tif suite == scsvRenegotiation {\n\t\t\tm.secureRenegotiationSupported = true\n\t\t}\n\t\tm.cipherSuites = append(m.cipherSuites, suite)\n\t}\n\n\tif !readUint8LengthPrefixed(&s, &m.compressionMethods) {\n\t\treturn false\n\t}\n\n\tif s.Empty() {\n\t\t// ClientHello is optionally followed by extension data\n\t\treturn true\n\t}\n\n\tvar extensions cryptobyte.String\n\tif !s.ReadUint16LengthPrefixed(&extensions) || !s.Empty() {\n\t\treturn false\n\t}\n\n\tseenExts := make(map[uint16]bool)\n\tfor !extensions.Empty() {\n\t\tvar extension uint16\n\t\tvar extData cryptobyte.String\n\t\tif !extensions.ReadUint16(&extension) ||\n\t\t\t!extensions.ReadUint16LengthPrefixed(&extData) {\n\t\t\treturn false\n\t\t}\n\n\t\tif seenExts[extension] {\n\t\t\treturn false\n\t\t}\n\t\tseenExts[extension] = true\n\t\tm.extensions = append(m.extensions, extension)\n\n\t\tswitch extension {\n\t\tcase extensionServerName:\n\t\t\t// RFC 6066, Section 3\n\t\t\tvar nameList cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&nameList) || nameList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !nameList.Empty() {\n\t\t\t\tvar nameType uint8\n\t\t\t\tvar serverName cryptobyte.String\n\t\t\t\tif !nameList.ReadUint8(&nameType) ||\n\t\t\t\t\t!nameList.ReadUint16LengthPrefixed(&serverName) ||\n\t\t\t\t\tserverName.Empty() {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tif nameType != 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif len(m.serverName) != 0 {\n\t\t\t\t\t// Multiple names of the same name_type are prohibited.\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.serverName = string(serverName)\n\t\t\t\t// An SNI value may not include a trailing dot.\n\t\t\t\tif strings.HasSuffix(m.serverName, \".\") {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\tcase extensionStatusRequest:\n\t\t\t// RFC 4366, Section 3.6\n\t\t\tvar statusType uint8\n\t\t\tvar ignored cryptobyte.String\n\t\t\tif !extData.ReadUint8(&statusType) ||\n\t\t\t\t!extData.ReadUint16LengthPrefixed(&ignored) ||\n\t\t\t\t!extData.ReadUint16LengthPrefixed(&ignored) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm.ocspStapling = statusType == statusTypeOCSP\n\t\tcase extensionSupportedCurves:\n\t\t\t// RFC 4492, sections 5.1.1 and RFC 8446, Section 4.2.7\n\t\t\tvar curves cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&curves) || curves.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !curves.Empty() {\n\t\t\t\tvar curve uint16\n\t\t\t\tif !curves.ReadUint16(&curve) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.supportedCurves = append(m.supportedCurves, CurveID(curve))\n\t\t\t}\n\t\tcase extensionSupportedPoints:\n\t\t\t// RFC 4492, Section 5.1.2\n\t\t\tif !readUint8LengthPrefixed(&extData, &m.supportedPoints) ||\n\t\t\t\tlen(m.supportedPoints) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionSessionTicket:\n\t\t\t// RFC 5077, Section 3.2\n\t\t\tm.ticketSupported = true\n\t\t\textData.ReadBytes(&m.sessionTicket, len(extData))\n\t\tcase extensionSignatureAlgorithms:\n\t\t\t// RFC 5246, Section 7.4.1.4.1\n\t\t\tvar sigAndAlgs cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&sigAndAlgs) || sigAndAlgs.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !sigAndAlgs.Empty() {\n\t\t\t\tvar sigAndAlg uint16\n\t\t\t\tif !sigAndAlgs.ReadUint16(&sigAndAlg) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.supportedSignatureAlgorithms = append(\n\t\t\t\t\tm.supportedSignatureAlgorithms, SignatureScheme(sigAndAlg))\n\t\t\t}\n\t\tcase extensionSignatureAlgorithmsCert:\n\t\t\t// RFC 8446, Section 4.2.3\n\t\t\tvar sigAndAlgs cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&sigAndAlgs) || sigAndAlgs.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !sigAndAlgs.Empty() {\n\t\t\t\tvar sigAndAlg uint16\n\t\t\t\tif !sigAndAlgs.ReadUint16(&sigAndAlg) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.supportedSignatureAlgorithmsCert = append(\n\t\t\t\t\tm.supportedSignatureAlgorithmsCert, SignatureScheme(sigAndAlg))\n\t\t\t}\n\t\tcase extensionRenegotiationInfo:\n\t\t\t// RFC 5746, Section 3.2\n\t\t\tif !readUint8LengthPrefixed(&extData, &m.secureRenegotiation) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm.secureRenegotiationSupported = true\n\t\tcase extensionExtendedMasterSecret:\n\t\t\t// RFC 7627\n\t\t\tm.extendedMasterSecret = true\n\t\tcase extensionALPN:\n\t\t\t// RFC 7301, Section 3.1\n\t\t\tvar protoList cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&protoList) || protoList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !protoList.Empty() {\n\t\t\t\tvar proto cryptobyte.String\n\t\t\t\tif !protoList.ReadUint8LengthPrefixed(&proto) || proto.Empty() {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.alpnProtocols = append(m.alpnProtocols, string(proto))\n\t\t\t}\n\t\tcase extensionSCT:\n\t\t\t// RFC 6962, Section 3.3.1\n\t\t\tm.scts = true\n\t\tcase extensionSupportedVersions:\n\t\t\t// RFC 8446, Section 4.2.1\n\t\t\tvar versList cryptobyte.String\n\t\t\tif !extData.ReadUint8LengthPrefixed(&versList) || versList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !versList.Empty() {\n\t\t\t\tvar vers uint16\n\t\t\t\tif !versList.ReadUint16(&vers) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.supportedVersions = append(m.supportedVersions, vers)\n\t\t\t}\n\t\tcase extensionCookie:\n\t\t\t// RFC 8446, Section 4.2.2\n\t\t\tif !readUint16LengthPrefixed(&extData, &m.cookie) ||\n\t\t\t\tlen(m.cookie) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionKeyShare:\n\t\t\t// RFC 8446, Section 4.2.8\n\t\t\tvar clientShares cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&clientShares) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !clientShares.Empty() {\n\t\t\t\tvar ks keyShare\n\t\t\t\tif !clientShares.ReadUint16((*uint16)(&ks.group)) ||\n\t\t\t\t\t!readUint16LengthPrefixed(&clientShares, &ks.data) ||\n\t\t\t\t\tlen(ks.data) == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.keyShares = append(m.keyShares, ks)\n\t\t\t}\n\t\tcase extensionEarlyData:\n\t\t\t// RFC 8446, Section 4.2.10\n\t\t\tm.earlyData = true\n\t\tcase extensionPSKModes:\n\t\t\t// RFC 8446, Section 4.2.9\n\t\t\tif !readUint8LengthPrefixed(&extData, &m.pskModes) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionQUICTransportParameters:\n\t\t\tm.quicTransportParameters = make([]byte, len(extData))\n\t\t\tif !extData.CopyBytes(m.quicTransportParameters) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionPreSharedKey:\n\t\t\t// RFC 8446, Section 4.2.11\n\t\t\tif !extensions.Empty() {\n\t\t\t\treturn false // pre_shared_key must be the last extension\n\t\t\t}\n\t\t\tvar identities cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&identities) || identities.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !identities.Empty() {\n\t\t\t\tvar psk pskIdentity\n\t\t\t\tif !readUint16LengthPrefixed(&identities, &psk.label) ||\n\t\t\t\t\t!identities.ReadUint32(&psk.obfuscatedTicketAge) ||\n\t\t\t\t\tlen(psk.label) == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.pskIdentities = append(m.pskIdentities, psk)\n\t\t\t}\n\t\t\tvar binders cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&binders) || binders.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !binders.Empty() {\n\t\t\t\tvar binder []byte\n\t\t\t\tif !readUint8LengthPrefixed(&binders, &binder) ||\n\t\t\t\t\tlen(binder) == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.pskBinders = append(m.pskBinders, binder)\n\t\t\t}\n\t\tdefault:\n\t\t\t// Ignore unknown extensions.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !extData.Empty() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (m *clientHelloMsg) originalBytes() []byte {\n\treturn m.original\n}\n\nfunc (m *clientHelloMsg) clone() *clientHelloMsg {\n\treturn &clientHelloMsg{\n\t\toriginal:                         slices.Clone(m.original),\n\t\tvers:                             m.vers,\n\t\trandom:                           slices.Clone(m.random),\n\t\tsessionId:                        slices.Clone(m.sessionId),\n\t\tcipherSuites:                     slices.Clone(m.cipherSuites),\n\t\tcompressionMethods:               slices.Clone(m.compressionMethods),\n\t\tserverName:                       m.serverName,\n\t\tocspStapling:                     m.ocspStapling,\n\t\tsupportedCurves:                  slices.Clone(m.supportedCurves),\n\t\tsupportedPoints:                  slices.Clone(m.supportedPoints),\n\t\tticketSupported:                  m.ticketSupported,\n\t\tsessionTicket:                    slices.Clone(m.sessionTicket),\n\t\tsupportedSignatureAlgorithms:     slices.Clone(m.supportedSignatureAlgorithms),\n\t\tsupportedSignatureAlgorithmsCert: slices.Clone(m.supportedSignatureAlgorithmsCert),\n\t\tsecureRenegotiationSupported:     m.secureRenegotiationSupported,\n\t\tsecureRenegotiation:              slices.Clone(m.secureRenegotiation),\n\t\textendedMasterSecret:             m.extendedMasterSecret,\n\t\talpnProtocols:                    slices.Clone(m.alpnProtocols),\n\t\tscts:                             m.scts,\n\t\tsupportedVersions:                slices.Clone(m.supportedVersions),\n\t\tcookie:                           slices.Clone(m.cookie),\n\t\tkeyShares:                        slices.Clone(m.keyShares),\n\t\tearlyData:                        m.earlyData,\n\t\tpskModes:                         slices.Clone(m.pskModes),\n\t\tpskIdentities:                    slices.Clone(m.pskIdentities),\n\t\tpskBinders:                       slices.Clone(m.pskBinders),\n\t\tquicTransportParameters:          slices.Clone(m.quicTransportParameters),\n\t\tencryptedClientHello:             slices.Clone(m.encryptedClientHello),\n\t}\n}\n\ntype serverHelloMsg struct {\n\toriginal                     []byte\n\tvers                         uint16\n\trandom                       []byte\n\tsessionId                    []byte\n\tcipherSuite                  uint16\n\tcompressionMethod            uint8\n\tocspStapling                 bool\n\tticketSupported              bool\n\tsecureRenegotiationSupported bool\n\tsecureRenegotiation          []byte\n\textendedMasterSecret         bool\n\talpnProtocol                 string\n\tscts                         [][]byte\n\tsupportedVersion             uint16\n\tserverShare                  keyShare\n\tselectedIdentityPresent      bool\n\tselectedIdentity             uint16\n\tsupportedPoints              []uint8\n\tencryptedClientHello         []byte\n\tserverNameAck                bool\n\n\t// HelloRetryRequest extensions\n\tcookie        []byte\n\tselectedGroup CurveID\n}\n\nfunc (m *serverHelloMsg) marshal() ([]byte, error) {\n\tvar exts cryptobyte.Builder\n\tif m.ocspStapling {\n\t\texts.AddUint16(extensionStatusRequest)\n\t\texts.AddUint16(0) // empty extension_data\n\t}\n\tif m.ticketSupported {\n\t\texts.AddUint16(extensionSessionTicket)\n\t\texts.AddUint16(0) // empty extension_data\n\t}\n\tif m.secureRenegotiationSupported {\n\t\texts.AddUint16(extensionRenegotiationInfo)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddBytes(m.secureRenegotiation)\n\t\t\t})\n\t\t})\n\t}\n\tif m.extendedMasterSecret {\n\t\texts.AddUint16(extensionExtendedMasterSecret)\n\t\texts.AddUint16(0) // empty extension_data\n\t}\n\tif len(m.alpnProtocol) > 0 {\n\t\texts.AddUint16(extensionALPN)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\texts.AddBytes([]byte(m.alpnProtocol))\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n\tif len(m.scts) > 0 {\n\t\texts.AddUint16(extensionSCT)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\tfor _, sct := range m.scts {\n\t\t\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\t\t\texts.AddBytes(sct)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\tif m.supportedVersion != 0 {\n\t\texts.AddUint16(extensionSupportedVersions)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16(m.supportedVersion)\n\t\t})\n\t}\n\tif m.serverShare.group != 0 {\n\t\texts.AddUint16(extensionKeyShare)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16(uint16(m.serverShare.group))\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddBytes(m.serverShare.data)\n\t\t\t})\n\t\t})\n\t}\n\tif m.selectedIdentityPresent {\n\t\texts.AddUint16(extensionPreSharedKey)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16(m.selectedIdentity)\n\t\t})\n\t}\n\n\tif len(m.cookie) > 0 {\n\t\texts.AddUint16(extensionCookie)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddBytes(m.cookie)\n\t\t\t})\n\t\t})\n\t}\n\tif m.selectedGroup != 0 {\n\t\texts.AddUint16(extensionKeyShare)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint16(uint16(m.selectedGroup))\n\t\t})\n\t}\n\tif len(m.supportedPoints) > 0 {\n\t\texts.AddUint16(extensionSupportedPoints)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddUint8LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\t\texts.AddBytes(m.supportedPoints)\n\t\t\t})\n\t\t})\n\t}\n\tif len(m.encryptedClientHello) > 0 {\n\t\texts.AddUint16(extensionEncryptedClientHello)\n\t\texts.AddUint16LengthPrefixed(func(exts *cryptobyte.Builder) {\n\t\t\texts.AddBytes(m.encryptedClientHello)\n\t\t})\n\t}\n\tif m.serverNameAck {\n\t\texts.AddUint16(extensionServerName)\n\t\texts.AddUint16(0)\n\t}\n\n\textBytes, err := exts.Bytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeServerHello)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddUint16(m.vers)\n\t\taddBytesWithLength(b, m.random, 32)\n\t\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes(m.sessionId)\n\t\t})\n\t\tb.AddUint16(m.cipherSuite)\n\t\tb.AddUint8(m.compressionMethod)\n\n\t\tif len(extBytes) > 0 {\n\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\tb.AddBytes(extBytes)\n\t\t\t})\n\t\t}\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *serverHelloMsg) unmarshal(data []byte) bool {\n\t*m = serverHelloMsg{original: data}\n\ts := cryptobyte.String(data)\n\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint16(&m.vers) || !s.ReadBytes(&m.random, 32) ||\n\t\t!readUint8LengthPrefixed(&s, &m.sessionId) ||\n\t\t!s.ReadUint16(&m.cipherSuite) ||\n\t\t!s.ReadUint8(&m.compressionMethod) {\n\t\treturn false\n\t}\n\n\tif s.Empty() {\n\t\t// ServerHello is optionally followed by extension data\n\t\treturn true\n\t}\n\n\tvar extensions cryptobyte.String\n\tif !s.ReadUint16LengthPrefixed(&extensions) || !s.Empty() {\n\t\treturn false\n\t}\n\n\tseenExts := make(map[uint16]bool)\n\tfor !extensions.Empty() {\n\t\tvar extension uint16\n\t\tvar extData cryptobyte.String\n\t\tif !extensions.ReadUint16(&extension) ||\n\t\t\t!extensions.ReadUint16LengthPrefixed(&extData) {\n\t\t\treturn false\n\t\t}\n\n\t\tif seenExts[extension] {\n\t\t\treturn false\n\t\t}\n\t\tseenExts[extension] = true\n\n\t\tswitch extension {\n\t\tcase extensionStatusRequest:\n\t\t\tm.ocspStapling = true\n\t\tcase extensionSessionTicket:\n\t\t\tm.ticketSupported = true\n\t\tcase extensionRenegotiationInfo:\n\t\t\tif !readUint8LengthPrefixed(&extData, &m.secureRenegotiation) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm.secureRenegotiationSupported = true\n\t\tcase extensionExtendedMasterSecret:\n\t\t\tm.extendedMasterSecret = true\n\t\tcase extensionALPN:\n\t\t\tvar protoList cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&protoList) || protoList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tvar proto cryptobyte.String\n\t\t\tif !protoList.ReadUint8LengthPrefixed(&proto) ||\n\t\t\t\tproto.Empty() || !protoList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm.alpnProtocol = string(proto)\n\t\tcase extensionSCT:\n\t\t\tvar sctList cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&sctList) || sctList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !sctList.Empty() {\n\t\t\t\tvar sct []byte\n\t\t\t\tif !readUint16LengthPrefixed(&sctList, &sct) ||\n\t\t\t\t\tlen(sct) == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.scts = append(m.scts, sct)\n\t\t\t}\n\t\tcase extensionSupportedVersions:\n\t\t\tif !extData.ReadUint16(&m.supportedVersion) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionCookie:\n\t\t\tif !readUint16LengthPrefixed(&extData, &m.cookie) ||\n\t\t\t\tlen(m.cookie) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionKeyShare:\n\t\t\t// This extension has different formats in SH and HRR, accept either\n\t\t\t// and let the handshake logic decide. See RFC 8446, Section 4.2.8.\n\t\t\tif len(extData) == 2 {\n\t\t\t\tif !extData.ReadUint16((*uint16)(&m.selectedGroup)) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif !extData.ReadUint16((*uint16)(&m.serverShare.group)) ||\n\t\t\t\t\t!readUint16LengthPrefixed(&extData, &m.serverShare.data) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\tcase extensionPreSharedKey:\n\t\t\tm.selectedIdentityPresent = true\n\t\t\tif !extData.ReadUint16(&m.selectedIdentity) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionSupportedPoints:\n\t\t\t// RFC 4492, Section 5.1.2\n\t\t\tif !readUint8LengthPrefixed(&extData, &m.supportedPoints) ||\n\t\t\t\tlen(m.supportedPoints) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionEncryptedClientHello: // encrypted_client_hello\n\t\t\tm.encryptedClientHello = make([]byte, len(extData))\n\t\t\tif !extData.CopyBytes(m.encryptedClientHello) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionServerName:\n\t\t\tif len(extData) != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm.serverNameAck = true\n\t\tdefault:\n\t\t\t// Ignore unknown extensions.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !extData.Empty() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (m *serverHelloMsg) originalBytes() []byte {\n\treturn m.original\n}\n\ntype encryptedExtensionsMsg struct {\n\talpnProtocol            string\n\tquicTransportParameters []byte\n\tearlyData               bool\n\techRetryConfigs         []byte\n}\n\nfunc (m *encryptedExtensionsMsg) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeEncryptedExtensions)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tif len(m.alpnProtocol) > 0 {\n\t\t\t\tb.AddUint16(extensionALPN)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\t\tb.AddBytes([]byte(m.alpnProtocol))\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t\tif m.quicTransportParameters != nil { // marshal zero-length parameters when present\n\t\t\t\t// draft-ietf-quic-tls-32, Section 8.2\n\t\t\t\tb.AddUint16(extensionQUICTransportParameters)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddBytes(m.quicTransportParameters)\n\t\t\t\t})\n\t\t\t}\n\t\t\tif m.earlyData {\n\t\t\t\t// RFC 8446, Section 4.2.10\n\t\t\t\tb.AddUint16(extensionEarlyData)\n\t\t\t\tb.AddUint16(0) // empty extension_data\n\t\t\t}\n\t\t\tif len(m.echRetryConfigs) > 0 {\n\t\t\t\tb.AddUint16(extensionEncryptedClientHello)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddBytes(m.echRetryConfigs)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *encryptedExtensionsMsg) unmarshal(data []byte) bool {\n\t*m = encryptedExtensionsMsg{}\n\ts := cryptobyte.String(data)\n\n\tvar extensions cryptobyte.String\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint16LengthPrefixed(&extensions) || !s.Empty() {\n\t\treturn false\n\t}\n\n\tfor !extensions.Empty() {\n\t\tvar extension uint16\n\t\tvar extData cryptobyte.String\n\t\tif !extensions.ReadUint16(&extension) ||\n\t\t\t!extensions.ReadUint16LengthPrefixed(&extData) {\n\t\t\treturn false\n\t\t}\n\n\t\tswitch extension {\n\t\tcase extensionALPN:\n\t\t\tvar protoList cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&protoList) || protoList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tvar proto cryptobyte.String\n\t\t\tif !protoList.ReadUint8LengthPrefixed(&proto) ||\n\t\t\t\tproto.Empty() || !protoList.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tm.alpnProtocol = string(proto)\n\t\tcase extensionQUICTransportParameters:\n\t\t\tm.quicTransportParameters = make([]byte, len(extData))\n\t\t\tif !extData.CopyBytes(m.quicTransportParameters) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase extensionEarlyData:\n\t\t\t// RFC 8446, Section 4.2.10\n\t\t\tm.earlyData = true\n\t\tcase extensionEncryptedClientHello:\n\t\t\tm.echRetryConfigs = make([]byte, len(extData))\n\t\t\tif !extData.CopyBytes(m.echRetryConfigs) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\t// Ignore unknown extensions.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !extData.Empty() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\ntype endOfEarlyDataMsg struct{}\n\nfunc (m *endOfEarlyDataMsg) marshal() ([]byte, error) {\n\tx := make([]byte, 4)\n\tx[0] = typeEndOfEarlyData\n\treturn x, nil\n}\n\nfunc (m *endOfEarlyDataMsg) unmarshal(data []byte) bool {\n\treturn len(data) == 4\n}\n\ntype keyUpdateMsg struct {\n\tupdateRequested bool\n}\n\nfunc (m *keyUpdateMsg) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeKeyUpdate)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tif m.updateRequested {\n\t\t\tb.AddUint8(1)\n\t\t} else {\n\t\t\tb.AddUint8(0)\n\t\t}\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *keyUpdateMsg) unmarshal(data []byte) bool {\n\ts := cryptobyte.String(data)\n\n\tvar updateRequested uint8\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint8(&updateRequested) || !s.Empty() {\n\t\treturn false\n\t}\n\tswitch updateRequested {\n\tcase 0:\n\t\tm.updateRequested = false\n\tcase 1:\n\t\tm.updateRequested = true\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\ntype newSessionTicketMsgTLS13 struct {\n\tlifetime     uint32\n\tageAdd       uint32\n\tnonce        []byte\n\tlabel        []byte\n\tmaxEarlyData uint32\n}\n\nfunc (m *newSessionTicketMsgTLS13) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeNewSessionTicket)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddUint32(m.lifetime)\n\t\tb.AddUint32(m.ageAdd)\n\t\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes(m.nonce)\n\t\t})\n\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes(m.label)\n\t\t})\n\n\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tif m.maxEarlyData > 0 {\n\t\t\t\tb.AddUint16(extensionEarlyData)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddUint32(m.maxEarlyData)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *newSessionTicketMsgTLS13) unmarshal(data []byte) bool {\n\t*m = newSessionTicketMsgTLS13{}\n\ts := cryptobyte.String(data)\n\n\tvar extensions cryptobyte.String\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint32(&m.lifetime) ||\n\t\t!s.ReadUint32(&m.ageAdd) ||\n\t\t!readUint8LengthPrefixed(&s, &m.nonce) ||\n\t\t!readUint16LengthPrefixed(&s, &m.label) ||\n\t\t!s.ReadUint16LengthPrefixed(&extensions) ||\n\t\t!s.Empty() {\n\t\treturn false\n\t}\n\n\tfor !extensions.Empty() {\n\t\tvar extension uint16\n\t\tvar extData cryptobyte.String\n\t\tif !extensions.ReadUint16(&extension) ||\n\t\t\t!extensions.ReadUint16LengthPrefixed(&extData) {\n\t\t\treturn false\n\t\t}\n\n\t\tswitch extension {\n\t\tcase extensionEarlyData:\n\t\t\tif !extData.ReadUint32(&m.maxEarlyData) {\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\t// Ignore unknown extensions.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !extData.Empty() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\ntype certificateRequestMsgTLS13 struct {\n\tocspStapling                     bool\n\tscts                             bool\n\tsupportedSignatureAlgorithms     []SignatureScheme\n\tsupportedSignatureAlgorithmsCert []SignatureScheme\n\tcertificateAuthorities           [][]byte\n}\n\nfunc (m *certificateRequestMsgTLS13) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeCertificateRequest)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t// certificate_request_context (SHALL be zero length unless used for\n\t\t// post-handshake authentication)\n\t\tb.AddUint8(0)\n\n\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tif m.ocspStapling {\n\t\t\t\tb.AddUint16(extensionStatusRequest)\n\t\t\t\tb.AddUint16(0) // empty extension_data\n\t\t\t}\n\t\t\tif m.scts {\n\t\t\t\t// RFC 8446, Section 4.4.2.1 makes no mention of\n\t\t\t\t// signed_certificate_timestamp in CertificateRequest, but\n\t\t\t\t// \"Extensions in the Certificate message from the client MUST\n\t\t\t\t// correspond to extensions in the CertificateRequest message\n\t\t\t\t// from the server.\" and it appears in the table in Section 4.2.\n\t\t\t\tb.AddUint16(extensionSCT)\n\t\t\t\tb.AddUint16(0) // empty extension_data\n\t\t\t}\n\t\t\tif len(m.supportedSignatureAlgorithms) > 0 {\n\t\t\t\tb.AddUint16(extensionSignatureAlgorithms)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tfor _, sigAlgo := range m.supportedSignatureAlgorithms {\n\t\t\t\t\t\t\tb.AddUint16(uint16(sigAlgo))\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t\tif len(m.supportedSignatureAlgorithmsCert) > 0 {\n\t\t\t\tb.AddUint16(extensionSignatureAlgorithmsCert)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tfor _, sigAlgo := range m.supportedSignatureAlgorithmsCert {\n\t\t\t\t\t\t\tb.AddUint16(uint16(sigAlgo))\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t\tif len(m.certificateAuthorities) > 0 {\n\t\t\t\tb.AddUint16(extensionCertificateAuthorities)\n\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tfor _, ca := range m.certificateAuthorities {\n\t\t\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\t\t\tb.AddBytes(ca)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *certificateRequestMsgTLS13) unmarshal(data []byte) bool {\n\t*m = certificateRequestMsgTLS13{}\n\ts := cryptobyte.String(data)\n\n\tvar context, extensions cryptobyte.String\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint8LengthPrefixed(&context) || !context.Empty() ||\n\t\t!s.ReadUint16LengthPrefixed(&extensions) ||\n\t\t!s.Empty() {\n\t\treturn false\n\t}\n\n\tfor !extensions.Empty() {\n\t\tvar extension uint16\n\t\tvar extData cryptobyte.String\n\t\tif !extensions.ReadUint16(&extension) ||\n\t\t\t!extensions.ReadUint16LengthPrefixed(&extData) {\n\t\t\treturn false\n\t\t}\n\n\t\tswitch extension {\n\t\tcase extensionStatusRequest:\n\t\t\tm.ocspStapling = true\n\t\tcase extensionSCT:\n\t\t\tm.scts = true\n\t\tcase extensionSignatureAlgorithms:\n\t\t\tvar sigAndAlgs cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&sigAndAlgs) || sigAndAlgs.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !sigAndAlgs.Empty() {\n\t\t\t\tvar sigAndAlg uint16\n\t\t\t\tif !sigAndAlgs.ReadUint16(&sigAndAlg) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.supportedSignatureAlgorithms = append(\n\t\t\t\t\tm.supportedSignatureAlgorithms, SignatureScheme(sigAndAlg))\n\t\t\t}\n\t\tcase extensionSignatureAlgorithmsCert:\n\t\t\tvar sigAndAlgs cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&sigAndAlgs) || sigAndAlgs.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !sigAndAlgs.Empty() {\n\t\t\t\tvar sigAndAlg uint16\n\t\t\t\tif !sigAndAlgs.ReadUint16(&sigAndAlg) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.supportedSignatureAlgorithmsCert = append(\n\t\t\t\t\tm.supportedSignatureAlgorithmsCert, SignatureScheme(sigAndAlg))\n\t\t\t}\n\t\tcase extensionCertificateAuthorities:\n\t\t\tvar auths cryptobyte.String\n\t\t\tif !extData.ReadUint16LengthPrefixed(&auths) || auths.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfor !auths.Empty() {\n\t\t\t\tvar ca []byte\n\t\t\t\tif !readUint16LengthPrefixed(&auths, &ca) || len(ca) == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tm.certificateAuthorities = append(m.certificateAuthorities, ca)\n\t\t\t}\n\t\tdefault:\n\t\t\t// Ignore unknown extensions.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !extData.Empty() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\ntype certificateMsg struct {\n\tcertificates [][]byte\n}\n\nfunc (m *certificateMsg) marshal() ([]byte, error) {\n\tvar i int\n\tfor _, slice := range m.certificates {\n\t\ti += len(slice)\n\t}\n\n\tlength := 3 + 3*len(m.certificates) + i\n\tx := make([]byte, 4+length)\n\tx[0] = typeCertificate\n\tx[1] = uint8(length >> 16)\n\tx[2] = uint8(length >> 8)\n\tx[3] = uint8(length)\n\n\tcertificateOctets := length - 3\n\tx[4] = uint8(certificateOctets >> 16)\n\tx[5] = uint8(certificateOctets >> 8)\n\tx[6] = uint8(certificateOctets)\n\n\ty := x[7:]\n\tfor _, slice := range m.certificates {\n\t\ty[0] = uint8(len(slice) >> 16)\n\t\ty[1] = uint8(len(slice) >> 8)\n\t\ty[2] = uint8(len(slice))\n\t\tcopy(y[3:], slice)\n\t\ty = y[3+len(slice):]\n\t}\n\n\treturn x, nil\n}\n\nfunc (m *certificateMsg) unmarshal(data []byte) bool {\n\tif len(data) < 7 {\n\t\treturn false\n\t}\n\n\tcertsLen := uint32(data[4])<<16 | uint32(data[5])<<8 | uint32(data[6])\n\tif uint32(len(data)) != certsLen+7 {\n\t\treturn false\n\t}\n\n\tnumCerts := 0\n\td := data[7:]\n\tfor certsLen > 0 {\n\t\tif len(d) < 4 {\n\t\t\treturn false\n\t\t}\n\t\tcertLen := uint32(d[0])<<16 | uint32(d[1])<<8 | uint32(d[2])\n\t\tif uint32(len(d)) < 3+certLen {\n\t\t\treturn false\n\t\t}\n\t\td = d[3+certLen:]\n\t\tcertsLen -= 3 + certLen\n\t\tnumCerts++\n\t}\n\n\tm.certificates = make([][]byte, numCerts)\n\td = data[7:]\n\tfor i := 0; i < numCerts; i++ {\n\t\tcertLen := uint32(d[0])<<16 | uint32(d[1])<<8 | uint32(d[2])\n\t\tm.certificates[i] = d[3 : 3+certLen]\n\t\td = d[3+certLen:]\n\t}\n\n\treturn true\n}\n\ntype certificateMsgTLS13 struct {\n\tcertificate  Certificate\n\tocspStapling bool\n\tscts         bool\n}\n\nfunc (m *certificateMsgTLS13) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeCertificate)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddUint8(0) // certificate_request_context\n\n\t\tcertificate := m.certificate\n\t\tif !m.ocspStapling {\n\t\t\tcertificate.OCSPStaple = nil\n\t\t}\n\t\tif !m.scts {\n\t\t\tcertificate.SignedCertificateTimestamps = nil\n\t\t}\n\t\tmarshalCertificate(b, certificate)\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc marshalCertificate(b *cryptobyte.Builder, certificate Certificate) {\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tfor i, cert := range certificate.Certificate {\n\t\t\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\tb.AddBytes(cert)\n\t\t\t})\n\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\tif i > 0 {\n\t\t\t\t\t// This library only supports OCSP and SCT for leaf certificates.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif certificate.OCSPStaple != nil {\n\t\t\t\t\tb.AddUint16(extensionStatusRequest)\n\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tb.AddUint8(statusTypeOCSP)\n\t\t\t\t\t\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\t\tb.AddBytes(certificate.OCSPStaple)\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\tif certificate.SignedCertificateTimestamps != nil {\n\t\t\t\t\tb.AddUint16(extensionSCT)\n\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\t\tfor _, sct := range certificate.SignedCertificateTimestamps {\n\t\t\t\t\t\t\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\t\t\t\tb.AddBytes(sct)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc (m *certificateMsgTLS13) unmarshal(data []byte) bool {\n\t*m = certificateMsgTLS13{}\n\ts := cryptobyte.String(data)\n\n\tvar context cryptobyte.String\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint8LengthPrefixed(&context) || !context.Empty() ||\n\t\t!unmarshalCertificate(&s, &m.certificate) ||\n\t\t!s.Empty() {\n\t\treturn false\n\t}\n\n\tm.scts = m.certificate.SignedCertificateTimestamps != nil\n\tm.ocspStapling = m.certificate.OCSPStaple != nil\n\n\treturn true\n}\n\nfunc unmarshalCertificate(s *cryptobyte.String, certificate *Certificate) bool {\n\tvar certList cryptobyte.String\n\tif !s.ReadUint24LengthPrefixed(&certList) {\n\t\treturn false\n\t}\n\tfor !certList.Empty() {\n\t\tvar cert []byte\n\t\tvar extensions cryptobyte.String\n\t\tif !readUint24LengthPrefixed(&certList, &cert) ||\n\t\t\t!certList.ReadUint16LengthPrefixed(&extensions) {\n\t\t\treturn false\n\t\t}\n\t\tcertificate.Certificate = append(certificate.Certificate, cert)\n\t\tfor !extensions.Empty() {\n\t\t\tvar extension uint16\n\t\t\tvar extData cryptobyte.String\n\t\t\tif !extensions.ReadUint16(&extension) ||\n\t\t\t\t!extensions.ReadUint16LengthPrefixed(&extData) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif len(certificate.Certificate) > 1 {\n\t\t\t\t// This library only supports OCSP and SCT for leaf certificates.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tswitch extension {\n\t\t\tcase extensionStatusRequest:\n\t\t\t\tvar statusType uint8\n\t\t\t\tif !extData.ReadUint8(&statusType) || statusType != statusTypeOCSP ||\n\t\t\t\t\t!readUint24LengthPrefixed(&extData, &certificate.OCSPStaple) ||\n\t\t\t\t\tlen(certificate.OCSPStaple) == 0 {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\tcase extensionSCT:\n\t\t\t\tvar sctList cryptobyte.String\n\t\t\t\tif !extData.ReadUint16LengthPrefixed(&sctList) || sctList.Empty() {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tfor !sctList.Empty() {\n\t\t\t\t\tvar sct []byte\n\t\t\t\t\tif !readUint16LengthPrefixed(&sctList, &sct) ||\n\t\t\t\t\t\tlen(sct) == 0 {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tcertificate.SignedCertificateTimestamps = append(\n\t\t\t\t\t\tcertificate.SignedCertificateTimestamps, sct)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// Ignore unknown extensions.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !extData.Empty() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\ntype serverKeyExchangeMsg struct {\n\tkey []byte\n}\n\nfunc (m *serverKeyExchangeMsg) marshal() ([]byte, error) {\n\tlength := len(m.key)\n\tx := make([]byte, length+4)\n\tx[0] = typeServerKeyExchange\n\tx[1] = uint8(length >> 16)\n\tx[2] = uint8(length >> 8)\n\tx[3] = uint8(length)\n\tcopy(x[4:], m.key)\n\n\treturn x, nil\n}\n\nfunc (m *serverKeyExchangeMsg) unmarshal(data []byte) bool {\n\tif len(data) < 4 {\n\t\treturn false\n\t}\n\tm.key = data[4:]\n\treturn true\n}\n\ntype certificateStatusMsg struct {\n\tresponse []byte\n}\n\nfunc (m *certificateStatusMsg) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeCertificateStatus)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddUint8(statusTypeOCSP)\n\t\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes(m.response)\n\t\t})\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *certificateStatusMsg) unmarshal(data []byte) bool {\n\ts := cryptobyte.String(data)\n\n\tvar statusType uint8\n\tif !s.Skip(4) || // message type and uint24 length field\n\t\t!s.ReadUint8(&statusType) || statusType != statusTypeOCSP ||\n\t\t!readUint24LengthPrefixed(&s, &m.response) ||\n\t\tlen(m.response) == 0 || !s.Empty() {\n\t\treturn false\n\t}\n\treturn true\n}\n\ntype serverHelloDoneMsg struct{}\n\nfunc (m *serverHelloDoneMsg) marshal() ([]byte, error) {\n\tx := make([]byte, 4)\n\tx[0] = typeServerHelloDone\n\treturn x, nil\n}\n\nfunc (m *serverHelloDoneMsg) unmarshal(data []byte) bool {\n\treturn len(data) == 4\n}\n\ntype clientKeyExchangeMsg struct {\n\tciphertext []byte\n}\n\nfunc (m *clientKeyExchangeMsg) marshal() ([]byte, error) {\n\tlength := len(m.ciphertext)\n\tx := make([]byte, length+4)\n\tx[0] = typeClientKeyExchange\n\tx[1] = uint8(length >> 16)\n\tx[2] = uint8(length >> 8)\n\tx[3] = uint8(length)\n\tcopy(x[4:], m.ciphertext)\n\n\treturn x, nil\n}\n\nfunc (m *clientKeyExchangeMsg) unmarshal(data []byte) bool {\n\tif len(data) < 4 {\n\t\treturn false\n\t}\n\tl := int(data[1])<<16 | int(data[2])<<8 | int(data[3])\n\tif l != len(data)-4 {\n\t\treturn false\n\t}\n\tm.ciphertext = data[4:]\n\treturn true\n}\n\ntype finishedMsg struct {\n\tverifyData []byte\n}\n\nfunc (m *finishedMsg) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeFinished)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddBytes(m.verifyData)\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *finishedMsg) unmarshal(data []byte) bool {\n\ts := cryptobyte.String(data)\n\treturn s.Skip(1) &&\n\t\treadUint24LengthPrefixed(&s, &m.verifyData) &&\n\t\ts.Empty()\n}\n\ntype certificateRequestMsg struct {\n\t// hasSignatureAlgorithm indicates whether this message includes a list of\n\t// supported signature algorithms. This change was introduced with TLS 1.2.\n\thasSignatureAlgorithm bool\n\n\tcertificateTypes             []byte\n\tsupportedSignatureAlgorithms []SignatureScheme\n\tcertificateAuthorities       [][]byte\n}\n\nfunc (m *certificateRequestMsg) marshal() ([]byte, error) {\n\t// See RFC 4346, Section 7.4.4.\n\tlength := 1 + len(m.certificateTypes) + 2\n\tcasLength := 0\n\tfor _, ca := range m.certificateAuthorities {\n\t\tcasLength += 2 + len(ca)\n\t}\n\tlength += casLength\n\n\tif m.hasSignatureAlgorithm {\n\t\tlength += 2 + 2*len(m.supportedSignatureAlgorithms)\n\t}\n\n\tx := make([]byte, 4+length)\n\tx[0] = typeCertificateRequest\n\tx[1] = uint8(length >> 16)\n\tx[2] = uint8(length >> 8)\n\tx[3] = uint8(length)\n\n\tx[4] = uint8(len(m.certificateTypes))\n\n\tcopy(x[5:], m.certificateTypes)\n\ty := x[5+len(m.certificateTypes):]\n\n\tif m.hasSignatureAlgorithm {\n\t\tn := len(m.supportedSignatureAlgorithms) * 2\n\t\ty[0] = uint8(n >> 8)\n\t\ty[1] = uint8(n)\n\t\ty = y[2:]\n\t\tfor _, sigAlgo := range m.supportedSignatureAlgorithms {\n\t\t\ty[0] = uint8(sigAlgo >> 8)\n\t\t\ty[1] = uint8(sigAlgo)\n\t\t\ty = y[2:]\n\t\t}\n\t}\n\n\ty[0] = uint8(casLength >> 8)\n\ty[1] = uint8(casLength)\n\ty = y[2:]\n\tfor _, ca := range m.certificateAuthorities {\n\t\ty[0] = uint8(len(ca) >> 8)\n\t\ty[1] = uint8(len(ca))\n\t\ty = y[2:]\n\t\tcopy(y, ca)\n\t\ty = y[len(ca):]\n\t}\n\n\treturn x, nil\n}\n\nfunc (m *certificateRequestMsg) unmarshal(data []byte) bool {\n\tif len(data) < 5 {\n\t\treturn false\n\t}\n\n\tlength := uint32(data[1])<<16 | uint32(data[2])<<8 | uint32(data[3])\n\tif uint32(len(data))-4 != length {\n\t\treturn false\n\t}\n\n\tnumCertTypes := int(data[4])\n\tdata = data[5:]\n\tif numCertTypes == 0 || len(data) <= numCertTypes {\n\t\treturn false\n\t}\n\n\tm.certificateTypes = make([]byte, numCertTypes)\n\tif copy(m.certificateTypes, data) != numCertTypes {\n\t\treturn false\n\t}\n\n\tdata = data[numCertTypes:]\n\n\tif m.hasSignatureAlgorithm {\n\t\tif len(data) < 2 {\n\t\t\treturn false\n\t\t}\n\t\tsigAndHashLen := uint16(data[0])<<8 | uint16(data[1])\n\t\tdata = data[2:]\n\t\tif sigAndHashLen&1 != 0 {\n\t\t\treturn false\n\t\t}\n\t\tif len(data) < int(sigAndHashLen) {\n\t\t\treturn false\n\t\t}\n\t\tnumSigAlgos := sigAndHashLen / 2\n\t\tm.supportedSignatureAlgorithms = make([]SignatureScheme, numSigAlgos)\n\t\tfor i := range m.supportedSignatureAlgorithms {\n\t\t\tm.supportedSignatureAlgorithms[i] = SignatureScheme(data[0])<<8 | SignatureScheme(data[1])\n\t\t\tdata = data[2:]\n\t\t}\n\t}\n\n\tif len(data) < 2 {\n\t\treturn false\n\t}\n\tcasLength := uint16(data[0])<<8 | uint16(data[1])\n\tdata = data[2:]\n\tif len(data) < int(casLength) {\n\t\treturn false\n\t}\n\tcas := make([]byte, casLength)\n\tcopy(cas, data)\n\tdata = data[casLength:]\n\n\tm.certificateAuthorities = nil\n\tfor len(cas) > 0 {\n\t\tif len(cas) < 2 {\n\t\t\treturn false\n\t\t}\n\t\tcaLen := uint16(cas[0])<<8 | uint16(cas[1])\n\t\tcas = cas[2:]\n\n\t\tif len(cas) < int(caLen) {\n\t\t\treturn false\n\t\t}\n\n\t\tm.certificateAuthorities = append(m.certificateAuthorities, cas[:caLen])\n\t\tcas = cas[caLen:]\n\t}\n\n\treturn len(data) == 0\n}\n\ntype certificateVerifyMsg struct {\n\thasSignatureAlgorithm bool // format change introduced in TLS 1.2\n\tsignatureAlgorithm    SignatureScheme\n\tsignature             []byte\n}\n\nfunc (m *certificateVerifyMsg) marshal() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint8(typeCertificateVerify)\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tif m.hasSignatureAlgorithm {\n\t\t\tb.AddUint16(uint16(m.signatureAlgorithm))\n\t\t}\n\t\tb.AddUint16LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes(m.signature)\n\t\t})\n\t})\n\n\treturn b.Bytes()\n}\n\nfunc (m *certificateVerifyMsg) unmarshal(data []byte) bool {\n\ts := cryptobyte.String(data)\n\n\tif !s.Skip(4) { // message type and uint24 length field\n\t\treturn false\n\t}\n\tif m.hasSignatureAlgorithm {\n\t\tif !s.ReadUint16((*uint16)(&m.signatureAlgorithm)) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn readUint16LengthPrefixed(&s, &m.signature) && s.Empty()\n}\n\ntype newSessionTicketMsg struct {\n\tticket []byte\n}\n\nfunc (m *newSessionTicketMsg) marshal() ([]byte, error) {\n\t// See RFC 5077, Section 3.3.\n\tticketLen := len(m.ticket)\n\tlength := 2 + 4 + ticketLen\n\tx := make([]byte, 4+length)\n\tx[0] = typeNewSessionTicket\n\tx[1] = uint8(length >> 16)\n\tx[2] = uint8(length >> 8)\n\tx[3] = uint8(length)\n\tx[8] = uint8(ticketLen >> 8)\n\tx[9] = uint8(ticketLen)\n\tcopy(x[10:], m.ticket)\n\n\treturn x, nil\n}\n\nfunc (m *newSessionTicketMsg) unmarshal(data []byte) bool {\n\tif len(data) < 10 {\n\t\treturn false\n\t}\n\n\tlength := uint32(data[1])<<16 | uint32(data[2])<<8 | uint32(data[3])\n\tif uint32(len(data))-4 != length {\n\t\treturn false\n\t}\n\n\tticketLen := int(data[8])<<8 + int(data[9])\n\tif len(data)-10 != ticketLen {\n\t\treturn false\n\t}\n\n\tm.ticket = data[10:]\n\n\treturn true\n}\n\ntype helloRequestMsg struct {\n}\n\nfunc (*helloRequestMsg) marshal() ([]byte, error) {\n\treturn []byte{typeHelloRequest, 0, 0, 0}, nil\n}\n\nfunc (*helloRequestMsg) unmarshal(data []byte) bool {\n\treturn len(data) == 4\n}\n\ntype transcriptHash interface {\n\tWrite([]byte) (int, error)\n}\n\n// transcriptMsg is a helper used to hash messages which are not hashed when\n// they are read from, or written to, the wire. This is typically the case for\n// messages which are either not sent, or need to be hashed out of order from\n// when they are read/written.\n//\n// For most messages, the message is marshalled using their marshal method,\n// since their wire representation is idempotent. For clientHelloMsg and\n// serverHelloMsg, we store the original wire representation of the message and\n// use that for hashing, since unmarshal/marshal are not idempotent due to\n// extension ordering and other malleable fields, which may cause differences\n// between what was received and what we marshal.\nfunc transcriptMsg(msg handshakeMessage, h transcriptHash) error {\n\tif msgWithOrig, ok := msg.(handshakeMessageWithOriginalBytes); ok {\n\t\tif orig := msgWithOrig.originalBytes(); orig != nil {\n\t\t\th.Write(msgWithOrig.originalBytes())\n\t\t\treturn nil\n\t\t}\n\t}\n\t\n\tdata, err := msg.marshal()\n\tif err != nil {\n\t\treturn err\n\t}\n\th.Write(data)\n\treturn nil\n}\n"
        },
        {
          "name": "handshake_server.go",
          "type": "blob",
          "size": 27.208984375,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"time\"\n)\n\n// serverHandshakeState contains details of a server handshake in progress.\n// It's discarded once the handshake has completed.\ntype serverHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tclientHello  *clientHelloMsg\n\thello        *serverHelloMsg\n\tsuite        *cipherSuite\n\tecdheOk      bool\n\tecSignOk     bool\n\trsaDecryptOk bool\n\trsaSignOk    bool\n\tsessionState *SessionState\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tcert         *Certificate\n}\n\n// serverHandshake performs a TLS handshake as a server.\nfunc (c *Conn) serverHandshake(ctx context.Context) error {\n\tclientHello, err := c.readClientHello(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.vers == VersionTLS13 {\n\t\ths := serverHandshakeStateTLS13{\n\t\t\tc:           c,\n\t\t\tctx:         ctx,\n\t\t\tclientHello: clientHello,\n\t\t}\n\t\treturn hs.handshake()\n\t}\n\n\ths := serverHandshakeState{\n\t\tc:           c,\n\t\tctx:         ctx,\n\t\tclientHello: clientHello,\n\t}\n\treturn hs.handshake()\n}\n\nfunc (hs *serverHandshakeState) handshake() error {\n\tc := hs.c\n\n\tif err := hs.processClientHello(); err != nil {\n\t\treturn err\n\t}\n\n\t// For an overview of TLS handshaking, see RFC 5246, Section 7.3.\n\tc.buffering = true\n\tif err := hs.checkForResumption(); err != nil {\n\t\treturn err\n\t}\n\tif hs.sessionState != nil {\n\t\t// The client has included a session ticket and so we do an abbreviated handshake.\n\t\tif err := hs.doResumeHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(c.serverFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = false\n\t\tif err := hs.readFinished(nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// The client didn't include a session ticket, or it wasn't\n\t\t// valid so we do a full handshake.\n\t\tif err := hs.pickCipherSuite(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.doFullHandshake(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.establishKeys(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.readFinished(c.clientFinished[:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.clientFinishedIsFirst = true\n\t\tc.buffering = true\n\t\tif err := hs.sendSessionTicket(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.sendFinished(nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := c.flush(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tc.ekm = ekmFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random)\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\n// readClientHello reads a ClientHello message and selects the protocol version.\nfunc (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error) {\n\t// clientHelloMsg is included in the transcript, but we haven't initialized\n\t// it yet. The respective handshake functions will record it themselves.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclientHello, ok := msg.(*clientHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn nil, unexpectedMessageError(clientHello, msg)\n\t}\n\n\tvar configForClient *Config\n\toriginalConfig := c.config\n\tif c.config.GetConfigForClient != nil {\n\t\tchi := clientHelloInfo(ctx, c, clientHello)\n\t\tif configForClient, err = c.config.GetConfigForClient(chi); err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn nil, err\n\t\t} else if configForClient != nil {\n\t\t\tc.config = configForClient\n\t\t}\n\t}\n\tc.ticketKeys = originalConfig.ticketKeys(configForClient)\n\n\tclientVersions := clientHello.supportedVersions\n\tif len(clientHello.supportedVersions) == 0 {\n\t\tclientVersions = supportedVersionsFromMax(clientHello.vers)\n\t}\n\tc.vers, ok = c.config.mutualVersion(roleServer, clientVersions)\n\tif !ok {\n\t\tc.sendAlert(alertProtocolVersion)\n\t\treturn nil, fmt.Errorf(\"tls: client offered only unsupported versions: %x\", clientVersions)\n\t}\n\tc.haveVers = true\n\tc.in.version = c.vers\n\tc.out.version = c.vers\n\n\treturn clientHello, nil\n}\n\nfunc (hs *serverHandshakeState) processClientHello() error {\n\tc := hs.c\n\n\ths.hello = new(serverHelloMsg)\n\ths.hello.vers = c.vers\n\n\tfoundCompression := false\n\t// We only support null compression, so check that the client offered it.\n\tfor _, compression := range hs.clientHello.compressionMethods {\n\t\tif compression == compressionNone {\n\t\t\tfoundCompression = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !foundCompression {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: client does not support uncompressed connections\")\n\t}\n\n\ths.hello.random = make([]byte, 32)\n\tserverRandom := hs.hello.random\n\t// Downgrade protection canaries. See RFC 8446, Section 4.1.3.\n\tmaxVers := c.config.maxSupportedVersion(roleServer)\n\tif maxVers >= VersionTLS12 && c.vers < maxVers || testingOnlyForceDowngradeCanary {\n\t\tif c.vers == VersionTLS12 {\n\t\t\tcopy(serverRandom[24:], downgradeCanaryTLS12)\n\t\t} else {\n\t\t\tcopy(serverRandom[24:], downgradeCanaryTLS11)\n\t\t}\n\t\tserverRandom = serverRandom[:24]\n\t}\n\t_, err := io.ReadFull(c.config.rand(), serverRandom)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tif len(hs.clientHello.secureRenegotiation) != 0 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t}\n\n\ths.hello.extendedMasterSecret = hs.clientHello.extendedMasterSecret\n\ths.hello.secureRenegotiationSupported = hs.clientHello.secureRenegotiationSupported\n\ths.hello.compressionMethod = compressionNone\n\tif len(hs.clientHello.serverName) > 0 {\n\t\tc.serverName = hs.clientHello.serverName\n\t}\n\n\tselectedProto, err := negotiateALPN(c.config.NextProtos, hs.clientHello.alpnProtocols, false)\n\tif err != nil {\n\t\tc.sendAlert(alertNoApplicationProtocol)\n\t\treturn err\n\t}\n\ths.hello.alpnProtocol = selectedProto\n\tc.clientProtocol = selectedProto\n\n\ths.cert, err = c.config.getCertificate(clientHelloInfo(hs.ctx, c, hs.clientHello))\n\tif err != nil {\n\t\tif err == errNoCertificates {\n\t\t\tc.sendAlert(alertUnrecognizedName)\n\t\t} else {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t}\n\t\treturn err\n\t}\n\tif hs.clientHello.scts {\n\t\ths.hello.scts = hs.cert.SignedCertificateTimestamps\n\t}\n\n\ths.ecdheOk = supportsECDHE(c.config, c.vers, hs.clientHello.supportedCurves, hs.clientHello.supportedPoints)\n\n\tif hs.ecdheOk && len(hs.clientHello.supportedPoints) > 0 {\n\t\t// Although omitting the ec_point_formats extension is permitted, some\n\t\t// old OpenSSL version will refuse to handshake if not present.\n\t\t//\n\t\t// Per RFC 4492, section 5.1.2, implementations MUST support the\n\t\t// uncompressed point format. See golang.org/issue/31943.\n\t\ths.hello.supportedPoints = []uint8{pointFormatUncompressed}\n\t}\n\n\tif priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok {\n\t\tswitch priv.Public().(type) {\n\t\tcase *ecdsa.PublicKey:\n\t\t\ths.ecSignOk = true\n\t\tcase ed25519.PublicKey:\n\t\t\ths.ecSignOk = true\n\t\tcase *rsa.PublicKey:\n\t\t\ths.rsaSignOk = true\n\t\tdefault:\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: unsupported signing key type (%T)\", priv.Public())\n\t\t}\n\t}\n\tif priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {\n\t\tswitch priv.Public().(type) {\n\t\tcase *rsa.PublicKey:\n\t\t\ths.rsaDecryptOk = true\n\t\tdefault:\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn fmt.Errorf(\"tls: unsupported decryption key type (%T)\", priv.Public())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// negotiateALPN picks a shared ALPN protocol that both sides support in server\n// preference order. If ALPN is not configured or the peer doesn't support it,\n// it returns \"\" and no error.\nfunc negotiateALPN(serverProtos, clientProtos []string, quic bool) (string, error) {\n\tif len(serverProtos) == 0 || len(clientProtos) == 0 {\n\t\tif quic && len(serverProtos) != 0 {\n\t\t\t// RFC 9001, Section 8.1\n\t\t\treturn \"\", fmt.Errorf(\"tls: client did not request an application protocol\")\n\t\t}\n\t\treturn \"\", nil\n\t}\n\tvar http11fallback bool\n\tfor _, s := range serverProtos {\n\t\tfor _, c := range clientProtos {\n\t\t\tif s == c {\n\t\t\t\treturn s, nil\n\t\t\t}\n\t\t\tif s == \"h2\" && c == \"http/1.1\" {\n\t\t\t\thttp11fallback = true\n\t\t\t}\n\t\t}\n\t}\n\t// As a special case, let http/1.1 clients connect to h2 servers as if they\n\t// didn't support ALPN. We used not to enforce protocol overlap, so over\n\t// time a number of HTTP servers were configured with only \"h2\", but\n\t// expected to accept connections from \"http/1.1\" clients. See Issue 46310.\n\tif http11fallback {\n\t\treturn \"\", nil\n\t}\n\treturn \"\", fmt.Errorf(\"tls: client requested unsupported application protocols (%s)\", clientProtos)\n}\n\n// supportsECDHE returns whether ECDHE key exchanges can be used with this\n// pre-TLS 1.3 client.\nfunc supportsECDHE(c *Config, version uint16, supportedCurves []CurveID, supportedPoints []uint8) bool {\n\tsupportsCurve := false\n\tfor _, curve := range supportedCurves {\n\t\tif c.supportsCurve(version, curve) {\n\t\t\tsupportsCurve = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tsupportsPointFormat := false\n\tfor _, pointFormat := range supportedPoints {\n\t\tif pointFormat == pointFormatUncompressed {\n\t\t\tsupportsPointFormat = true\n\t\t\tbreak\n\t\t}\n\t}\n\t// Per RFC 8422, Section 5.1.2, if the Supported Point Formats extension is\n\t// missing, uncompressed points are supported. If supportedPoints is empty,\n\t// the extension must be missing, as an empty extension body is rejected by\n\t// the parser. See https://go.dev/issue/49126.\n\tif len(supportedPoints) == 0 {\n\t\tsupportsPointFormat = true\n\t}\n\n\treturn supportsCurve && supportsPointFormat\n}\n\nfunc (hs *serverHandshakeState) pickCipherSuite() error {\n\tc := hs.c\n\n\tpreferenceOrder := cipherSuitesPreferenceOrder\n\tif !hasAESGCMHardwareSupport || !aesgcmPreferred(hs.clientHello.cipherSuites) {\n\t\tpreferenceOrder = cipherSuitesPreferenceOrderNoAES\n\t}\n\n\tconfigCipherSuites := c.config.cipherSuites()\n\tpreferenceList := make([]uint16, 0, len(configCipherSuites))\n\tfor _, suiteID := range preferenceOrder {\n\t\tfor _, id := range configCipherSuites {\n\t\t\tif id == suiteID {\n\t\t\t\tpreferenceList = append(preferenceList, id)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\ths.suite = selectCipherSuite(preferenceList, hs.clientHello.cipherSuites, hs.cipherSuiteOk)\n\tif hs.suite == nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: no cipher suite supported by both client and server\")\n\t}\n\tc.cipherSuite = hs.suite.id\n\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == TLS_FALLBACK_SCSV {\n\t\t\t// The client is doing a fallback connection. See RFC 7507.\n\t\t\tif hs.clientHello.vers < c.config.maxSupportedVersion(roleServer) {\n\t\t\t\tc.sendAlert(alertInappropriateFallback)\n\t\t\t\treturn errors.New(\"tls: client using inappropriate protocol fallback\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) cipherSuiteOk(c *cipherSuite) bool {\n\tif c.flags&suiteECDHE != 0 {\n\t\tif !hs.ecdheOk {\n\t\t\treturn false\n\t\t}\n\t\tif c.flags&suiteECSign != 0 {\n\t\t\tif !hs.ecSignOk {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if !hs.rsaSignOk {\n\t\t\treturn false\n\t\t}\n\t} else if !hs.rsaDecryptOk {\n\t\treturn false\n\t}\n\tif hs.c.vers < VersionTLS12 && c.flags&suiteTLS12 != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// checkForResumption reports whether we should perform resumption on this connection.\nfunc (hs *serverHandshakeState) checkForResumption() error {\n\tc := hs.c\n\n\tif c.config.SessionTicketsDisabled {\n\t\treturn nil\n\t}\n\n\tvar sessionState *SessionState\n\tif c.config.UnwrapSession != nil {\n\t\tss, err := c.config.UnwrapSession(hs.clientHello.sessionTicket, c.connectionStateLocked())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif ss == nil {\n\t\t\treturn nil\n\t\t}\n\t\tsessionState = ss\n\t} else {\n\t\tplaintext := c.config.decryptTicket(hs.clientHello.sessionTicket, c.ticketKeys)\n\t\tif plaintext == nil {\n\t\t\treturn nil\n\t\t}\n\t\tss, err := ParseSessionState(plaintext)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tsessionState = ss\n\t}\n\n\t// TLS 1.2 tickets don't natively have a lifetime, but we want to avoid\n\t// re-wrapping the same master secret in different tickets over and over for\n\t// too long, weakening forward secrecy.\n\tcreatedAt := time.Unix(int64(sessionState.createdAt), 0)\n\tif c.config.time().Sub(createdAt) > maxSessionTicketLifetime {\n\t\treturn nil\n\t}\n\n\t// Never resume a session for a different TLS version.\n\tif c.vers != sessionState.version {\n\t\treturn nil\n\t}\n\n\tcipherSuiteOk := false\n\t// Check that the client is still offering the ciphersuite in the session.\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == sessionState.cipherSuite {\n\t\t\tcipherSuiteOk = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !cipherSuiteOk {\n\t\treturn nil\n\t}\n\n\t// Check that we also support the ciphersuite from the session.\n\tsuite := selectCipherSuite([]uint16{sessionState.cipherSuite},\n\t\tc.config.cipherSuites(), hs.cipherSuiteOk)\n\tif suite == nil {\n\t\treturn nil\n\t}\n\n\tsessionHasClientCerts := len(sessionState.peerCertificates) != 0\n\tneedClientCerts := requiresClientCert(c.config.ClientAuth)\n\tif needClientCerts && !sessionHasClientCerts {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.time().After(sessionState.peerCertificates[0].NotAfter) {\n\t\treturn nil\n\t}\n\tif sessionHasClientCerts && c.config.ClientAuth >= VerifyClientCertIfGiven &&\n\t\tlen(sessionState.verifiedChains) == 0 {\n\t\treturn nil\n\t}\n\n\t// RFC 7627, Section 5.3\n\tif !sessionState.extMasterSecret && hs.clientHello.extendedMasterSecret {\n\t\treturn nil\n\t}\n\tif sessionState.extMasterSecret && !hs.clientHello.extendedMasterSecret {\n\t\t// Aborting is somewhat harsh, but it's a MUST and it would indicate a\n\t\t// weird downgrade in client capabilities.\n\t\treturn errors.New(\"tls: session supported extended_master_secret but client does not\")\n\t}\n\n\tc.peerCertificates = sessionState.peerCertificates\n\tc.ocspResponse = sessionState.ocspResponse\n\tc.scts = sessionState.scts\n\tc.verifiedChains = sessionState.verifiedChains\n\tc.extMasterSecret = sessionState.extMasterSecret\n\ths.sessionState = sessionState\n\ths.suite = suite\n\tc.didResume = true\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) doResumeHandshake() error {\n\tc := hs.c\n\n\ths.hello.cipherSuite = hs.suite.id\n\tc.cipherSuite = hs.suite.id\n\t// We echo the client's session ID in the ServerHello to let it know\n\t// that we're doing a resumption.\n\ths.hello.sessionId = hs.clientHello.sessionId\n\t// We always send a new session ticket, even if it wraps the same master\n\t// secret and it's potentially encrypted with the same key, to help the\n\t// client avoid cross-connection tracking from a network observer.\n\ths.hello.ticketSupported = true\n\ths.finishedHash = newFinishedHash(c.vers, hs.suite)\n\ths.finishedHash.discardHandshakeBuffer()\n\tif err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.masterSecret = hs.sessionState.secret\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) doFullHandshake() error {\n\tc := hs.c\n\n\tif hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0 {\n\t\ths.hello.ocspStapling = true\n\t}\n\n\ths.hello.ticketSupported = hs.clientHello.ticketSupported && !c.config.SessionTicketsDisabled\n\ths.hello.cipherSuite = hs.suite.id\n\n\ths.finishedHash = newFinishedHash(hs.c.vers, hs.suite)\n\tif c.config.ClientAuth == NoClientCert {\n\t\t// No need to keep a full record of the handshake if client\n\t\t// certificates won't be used.\n\t\ths.finishedHash.discardHandshakeBuffer()\n\t}\n\tif err := transcriptMsg(hs.clientHello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcertMsg := new(certificateMsg)\n\tcertMsg.certificates = hs.cert.Certificate\n\tif _, err := hs.c.writeHandshakeRecord(certMsg, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif hs.hello.ocspStapling {\n\t\tcertStatus := new(certificateStatusMsg)\n\t\tcertStatus.response = hs.cert.OCSPStaple\n\t\tif _, err := hs.c.writeHandshakeRecord(certStatus, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tkeyAgreement := hs.suite.ka(c.vers)\n\tskx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello)\n\tif err != nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\tif skx != nil {\n\t\tif len(skx.key) >= 3 && skx.key[0] == 3 /* named curve */ {\n\t\t\tc.curveID = CurveID(binary.BigEndian.Uint16(skx.key[1:]))\n\t\t}\n\t\tif _, err := hs.c.writeHandshakeRecord(skx, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar certReq *certificateRequestMsg\n\tif c.config.ClientAuth >= RequestClientCert {\n\t\t// Request a client certificate\n\t\tcertReq = new(certificateRequestMsg)\n\t\tcertReq.certificateTypes = []byte{\n\t\t\tbyte(certTypeRSASign),\n\t\t\tbyte(certTypeECDSASign),\n\t\t}\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tcertReq.hasSignatureAlgorithm = true\n\t\t\tcertReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t\t}\n\n\t\t// An empty list of certificateAuthorities signals to\n\t\t// the client that it may send any certificate in response\n\t\t// to our request. When we know the CAs we trust, then\n\t\t// we can send them down, so that the client can choose\n\t\t// an appropriate certificate to give to us.\n\t\tif c.config.ClientCAs != nil {\n\t\t\tcertReq.certificateAuthorities = c.config.ClientCAs.Subjects()\n\t\t}\n\t\tif _, err := hs.c.writeHandshakeRecord(certReq, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\thelloDone := new(serverHelloDoneMsg)\n\tif _, err := hs.c.writeHandshakeRecord(helloDone, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tif _, err := c.flush(); err != nil {\n\t\treturn err\n\t}\n\n\tvar pub crypto.PublicKey // public key for client auth, if any\n\n\tmsg, err := c.readHandshake(&hs.finishedHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If we requested a client certificate, then the client must send a\n\t// certificate message, even if it's empty.\n\tif c.config.ClientAuth >= RequestClientCert {\n\t\tcertMsg, ok := msg.(*certificateMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certMsg, msg)\n\t\t}\n\n\t\tif err := c.processCertsFromClient(Certificate{\n\t\t\tCertificate: certMsg.certificates,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(certMsg.certificates) != 0 {\n\t\t\tpub = c.peerCertificates[0].PublicKey\n\t\t}\n\n\t\tmsg, err = c.readHandshake(&hs.finishedHash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Get client key exchange\n\tckx, ok := msg.(*clientKeyExchangeMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(ckx, msg)\n\t}\n\n\tpreMasterSecret, err := keyAgreement.processClientKeyExchange(c.config, hs.cert, ckx, c.vers)\n\tif err != nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\tif hs.hello.extendedMasterSecret {\n\t\tc.extMasterSecret = true\n\t\ths.masterSecret = extMasterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.finishedHash.Sum())\n\t} else {\n\t\ths.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret,\n\t\t\ths.clientHello.random, hs.hello.random)\n\t}\n\tif err := c.config.writeKeyLog(keyLogLabelTLS12, hs.clientHello.random, hs.masterSecret); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\t// If we received a client cert in response to our certificate request message,\n\t// the client will send us a certificateVerifyMsg immediately after the\n\t// clientKeyExchangeMsg. This message is a digest of all preceding\n\t// handshake-layer messages that is signed using the private key corresponding\n\t// to the client's certificate. This allows us to verify that the client is in\n\t// possession of the private key of the certificate.\n\tif len(c.peerCertificates) > 0 {\n\t\t// certificateVerifyMsg is included in the transcript, but not until\n\t\t// after we verify the handshake signature, since the state before\n\t\t// this message was sent is used.\n\t\tmsg, err = c.readHandshake(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcertVerify, ok := msg.(*certificateVerifyMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certVerify, msg)\n\t\t}\n\n\t\tvar sigType uint8\n\t\tvar sigHash crypto.Hash\n\t\tif c.vers >= VersionTLS12 {\n\t\t\tif !isSupportedSignatureAlgorithm(certVerify.signatureAlgorithm, certReq.supportedSignatureAlgorithms) {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn errors.New(\"tls: client certificate used with invalid signature algorithm\")\n\t\t\t}\n\t\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(certVerify.signatureAlgorithm)\n\t\t\tif err != nil {\n\t\t\t\treturn c.sendAlert(alertInternalError)\n\t\t\t}\n\t\t} else {\n\t\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(pub)\n\t\t\tif err != nil {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tsigned := hs.finishedHash.hashForClientCertificate(sigType, sigHash)\n\t\tif err := verifyHandshakeSignature(sigType, pub, sigHash, signed, certVerify.signature); err != nil {\n\t\t\tc.sendAlert(alertDecryptError)\n\t\t\treturn errors.New(\"tls: invalid signature by the client certificate: \" + err.Error())\n\t\t}\n\n\t\tif err := transcriptMsg(certVerify, &hs.finishedHash); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ths.finishedHash.discardHandshakeBuffer()\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) establishKeys() error {\n\tc := hs.c\n\n\tclientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=\n\t\tkeysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)\n\n\tvar clientCipher, serverCipher any\n\tvar clientHash, serverHash hash.Hash\n\n\tif hs.suite.aead == nil {\n\t\tclientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)\n\t\tclientHash = hs.suite.mac(clientMAC)\n\t\tserverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)\n\t\tserverHash = hs.suite.mac(serverMAC)\n\t} else {\n\t\tclientCipher = hs.suite.aead(clientKey, clientIV)\n\t\tserverCipher = hs.suite.aead(serverKey, serverIV)\n\t}\n\n\tc.in.prepareCipherSpec(c.vers, clientCipher, clientHash)\n\tc.out.prepareCipherSpec(c.vers, serverCipher, serverHash)\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) readFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.readChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\t// finishedMsg is included in the transcript, but not until after we\n\t// check the client version, since the state before this message was\n\t// sent is used during verification.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclientFinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(clientFinished, msg)\n\t}\n\n\tverify := hs.finishedHash.clientSum(hs.masterSecret)\n\tif len(verify) != len(clientFinished.verifyData) ||\n\t\tsubtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: client's Finished message is incorrect\")\n\t}\n\n\tif err := transcriptMsg(clientFinished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, verify)\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) sendSessionTicket() error {\n\tif !hs.hello.ticketSupported {\n\t\treturn nil\n\t}\n\n\tc := hs.c\n\tm := new(newSessionTicketMsg)\n\n\tstate := c.sessionState()\n\tstate.secret = hs.masterSecret\n\tif hs.sessionState != nil {\n\t\t// If this is re-wrapping an old key, then keep\n\t\t// the original time it was created.\n\t\tstate.createdAt = hs.sessionState.createdAt\n\t}\n\tif c.config.WrapSession != nil {\n\t\tvar err error\n\t\tm.ticket, err = c.config.WrapSession(c.connectionStateLocked(), state)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tstateBytes, err := state.Bytes()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.ticket, err = c.config.encryptTicket(stateBytes, c.ticketKeys)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(m, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeState) sendFinished(out []byte) error {\n\tc := hs.c\n\n\tif err := c.writeChangeCipherRecord(); err != nil {\n\t\treturn err\n\t}\n\n\tfinished := new(finishedMsg)\n\tfinished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)\n\tif _, err := hs.c.writeHandshakeRecord(finished, &hs.finishedHash); err != nil {\n\t\treturn err\n\t}\n\n\tcopy(out, finished.verifyData)\n\n\treturn nil\n}\n\n// processCertsFromClient takes a chain of client certificates either from a\n// Certificates message and verifies them.\nfunc (c *Conn) processCertsFromClient(certificate Certificate) error {\n\tcertificates := certificate.Certificate\n\tcerts := make([]*x509.Certificate, len(certificates))\n\tvar err error\n\tfor i, asn1Data := range certificates {\n\t\tif certs[i], err = x509.ParseCertificate(asn1Data); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn errors.New(\"tls: failed to parse client certificate: \" + err.Error())\n\t\t}\n\t\tif certs[i].PublicKeyAlgorithm == x509.RSA {\n\t\t\tn := certs[i].PublicKey.(*rsa.PublicKey).N.BitLen()\n\t\t\tif max, ok := checkKeySize(n); !ok {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn fmt.Errorf(\"tls: client sent certificate containing RSA key larger than %d bits\", max)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(certs) == 0 && requiresClientCert(c.config.ClientAuth) {\n\t\tif c.vers == VersionTLS13 {\n\t\t\tc.sendAlert(alertCertificateRequired)\n\t\t} else {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t}\n\t\treturn errors.New(\"tls: client didn't provide a certificate\")\n\t}\n\n\tif c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 {\n\t\topts := x509.VerifyOptions{\n\t\t\tRoots:         c.config.ClientCAs,\n\t\t\tCurrentTime:   c.config.time(),\n\t\t\tIntermediates: x509.NewCertPool(),\n\t\t\tKeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},\n\t\t}\n\n\t\tfor _, cert := range certs[1:] {\n\t\t\topts.Intermediates.AddCert(cert)\n\t\t}\n\n\t\tchains, err := certs[0].Verify(opts)\n\t\tif err != nil {\n\t\t\tvar errCertificateInvalid x509.CertificateInvalidError\n\t\t\tif errors.As(err, &x509.UnknownAuthorityError{}) {\n\t\t\t\tc.sendAlert(alertUnknownCA)\n\t\t\t} else if errors.As(err, &errCertificateInvalid) && errCertificateInvalid.Reason == x509.Expired {\n\t\t\t\tc.sendAlert(alertCertificateExpired)\n\t\t\t} else {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t}\n\t\t\treturn &CertificateVerificationError{UnverifiedCertificates: certs, Err: err}\n\t\t}\n\n\t\tc.verifiedChains = chains\n\t}\n\n\tc.peerCertificates = certs\n\tc.ocspResponse = certificate.OCSPStaple\n\tc.scts = certificate.SignedCertificateTimestamps\n\n\tif len(certs) > 0 {\n\t\tswitch certs[0].PublicKey.(type) {\n\t\tcase *ecdsa.PublicKey, *rsa.PublicKey, ed25519.PublicKey:\n\t\tdefault:\n\t\t\tc.sendAlert(alertUnsupportedCertificate)\n\t\t\treturn fmt.Errorf(\"tls: client certificate contains an unsupported public key of type %T\", certs[0].PublicKey)\n\t\t}\n\t}\n\n\tif c.config.VerifyPeerCertificate != nil {\n\t\tif err := c.config.VerifyPeerCertificate(certificates, c.verifiedChains); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo {\n\tsupportedVersions := clientHello.supportedVersions\n\tif len(clientHello.supportedVersions) == 0 {\n\t\tsupportedVersions = supportedVersionsFromMax(clientHello.vers)\n\t}\n\n\treturn &ClientHelloInfo{\n\t\tCipherSuites:      clientHello.cipherSuites,\n\t\tServerName:        clientHello.serverName,\n\t\tSupportedCurves:   clientHello.supportedCurves,\n\t\tSupportedPoints:   clientHello.supportedPoints,\n\t\tSignatureSchemes:  clientHello.supportedSignatureAlgorithms,\n\t\tSupportedProtos:   clientHello.alpnProtocols,\n\t\tSupportedVersions: supportedVersions,\n\t\tExtensions:        clientHello.extensions,\n\t\tConn:              c.conn,\n\t\tconfig:            c.config,\n\t\tctx:               ctx,\n\t}\n}\n"
        },
        {
          "name": "handshake_server_tls13.go",
          "type": "blob",
          "size": 31.828125,
          "content": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ed25519\"\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha512\"\n\t\"crypto/x509\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"hash\"\n\t\"io\"\n\t\"math/big\"\n\t\"slices\"\n\t\"time\"\n\n\t\"github.com/xtls/reality/mlkem768\"\n)\n\n// maxClientPSKIdentities is the number of client PSK identities the server will\n// attempt to validate. It will ignore the rest not to let cheap ClientHello\n// messages cause too much work in session ticket decryption attempts.\nconst maxClientPSKIdentities = 5\n\ntype serverHandshakeStateTLS13 struct {\n\tc               *Conn\n\tctx             context.Context\n\tclientHello     *clientHelloMsg\n\thello           *serverHelloMsg\n\tsentDummyCCS    bool\n\tusingPSK        bool\n\tearlyData       bool\n\tsuite           *cipherSuiteTLS13\n\tcert            *Certificate\n\tsigAlg          SignatureScheme\n\tearlySecret     []byte\n\tsharedKey       []byte\n\thandshakeSecret []byte\n\tmasterSecret    []byte\n\ttrafficSecret   []byte // client_application_traffic_secret_0\n\ttranscript      hash.Hash\n\tclientFinished  []byte\n}\n\nvar (\n\ted25519Priv ed25519.PrivateKey\n\tsignedCert  []byte\n)\n\nfunc init() {\n\tcertificate := x509.Certificate{SerialNumber: &big.Int{}}\n\t_, ed25519Priv, _ = ed25519.GenerateKey(rand.Reader)\n\tsignedCert, _ = x509.CreateCertificate(rand.Reader, &certificate, &certificate, ed25519.PublicKey(ed25519Priv[32:]), ed25519Priv)\n}\n\nfunc (hs *serverHandshakeStateTLS13) handshake() error {\n\tc := hs.c\n\n\t// For an overview of the TLS 1.3 handshake, see RFC 8446, Section 2.\n\t/*\n\t\tif err := hs.processClientHello(); err != nil {\n\t\t\treturn err\n\t\t}\n\t*/\n\t{\n\t\ths.suite = cipherSuiteTLS13ByID(hs.hello.cipherSuite)\n\t\tc.cipherSuite = hs.suite.id\n\t\ths.transcript = hs.suite.hash.New()\n\t\t\n\t\tkey, _ := generateECDHEKey(c.config.rand(), X25519)\n\t\tcopy(hs.hello.serverShare.data, key.PublicKey().Bytes())\n\t\tpeerKey, _ := key.Curve().NewPublicKey(hs.clientHello.keyShares[hs.clientHello.keyShares[0].group].data)\n\t\ths.sharedKey, _ = key.ECDH(peerKey)\n\n\t\tc.serverName = hs.clientHello.serverName\n\t}\n\t/*\n\t\tif err := hs.checkForResumption(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := hs.pickCertificate(); err != nil {\n\t\t\treturn err\n\t\t}\n\t*/\n\t{\n\t\tsignedCert := append([]byte{}, signedCert...)\n\n\t\th := hmac.New(sha512.New, c.AuthKey)\n\t\th.Write(ed25519Priv[32:])\n\t\th.Sum(signedCert[:len(signedCert)-64])\n\n\t\ths.cert = &Certificate{\n\t\t\tCertificate: [][]byte{signedCert},\n\t\t\tPrivateKey:  ed25519Priv,\n\t\t}\n\t\ths.sigAlg = Ed25519\n\t}\n\tc.buffering = true\n\tif err := hs.sendServerParameters(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.sendServerCertificate(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.sendServerFinished(); err != nil {\n\t\treturn err\n\t}\n\tif hs.c.out.handshakeLen[6] != 0 {\n\t\tif _, err := c.writeRecord(recordTypeHandshake, []byte{typeNewSessionTicket}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Note that at this point we could start sending application data without\n\t// waiting for the client's second flight, but the application might not\n\t// expect the lack of replay protection of the ClientHello parameters.\n\tif _, err := c.flush(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n\n\tif err := hs.readClientCertificate(); err != nil {\n\t\treturn err\n\t}\n\tif err := hs.readClientFinished(); err != nil {\n\t\treturn err\n\t}\n\n\tc.isHandshakeComplete.Store(true)\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) processClientHello() error {\n\tc := hs.c\n\n\ths.hello = new(serverHelloMsg)\n\n\t// TLS 1.3 froze the ServerHello.legacy_version field, and uses\n\t// supported_versions instead. See RFC 8446, sections 4.1.3 and 4.2.1.\n\ths.hello.vers = VersionTLS12\n\ths.hello.supportedVersion = c.vers\n\n\tif len(hs.clientHello.supportedVersions) == 0 {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: client used the legacy version field to negotiate TLS 1.3\")\n\t}\n\n\t// Abort if the client is doing a fallback and landing lower than what we\n\t// support. See RFC 7507, which however does not specify the interaction\n\t// with supported_versions. The only difference is that with\n\t// supported_versions a client has a chance to attempt a [TLS 1.2, TLS 1.4]\n\t// handshake in case TLS 1.3 is broken but 1.2 is not. Alas, in that case,\n\t// it will have to drop the TLS_FALLBACK_SCSV protection if it falls back to\n\t// TLS 1.2, because a TLS 1.3 server would abort here. The situation before\n\t// supported_versions was not better because there was just no way to do a\n\t// TLS 1.4 handshake without risking the server selecting TLS 1.3.\n\tfor _, id := range hs.clientHello.cipherSuites {\n\t\tif id == TLS_FALLBACK_SCSV {\n\t\t\t// Use c.vers instead of max(supported_versions) because an attacker\n\t\t\t// could defeat this by adding an arbitrary high version otherwise.\n\t\t\tif c.vers < c.config.maxSupportedVersion(roleServer) {\n\t\t\t\tc.sendAlert(alertInappropriateFallback)\n\t\t\t\treturn errors.New(\"tls: client using inappropriate protocol fallback\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif len(hs.clientHello.compressionMethods) != 1 ||\n\t\ths.clientHello.compressionMethods[0] != compressionNone {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: TLS 1.3 client supports illegal compression methods\")\n\t}\n\n\ths.hello.random = make([]byte, 32)\n\tif _, err := io.ReadFull(c.config.rand(), hs.hello.random); err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tif len(hs.clientHello.secureRenegotiation) != 0 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: initial handshake had non-empty renegotiation extension\")\n\t}\n\n\tif hs.clientHello.earlyData && c.quic != nil {\n\t\tif len(hs.clientHello.pskIdentities) == 0 {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: early_data without pre_shared_key\")\n\t\t}\n\t} else if hs.clientHello.earlyData {\n\t\t// See RFC 8446, Section 4.2.10 for the complicated behavior required\n\t\t// here. The scenario is that a different server at our address offered\n\t\t// to accept early data in the past, which we can't handle. For now, all\n\t\t// 0-RTT enabled session tickets need to expire before a Go server can\n\t\t// replace a server or join a pool. That's the same requirement that\n\t\t// applies to mixing or replacing with any TLS 1.2 server.\n\t\tc.sendAlert(alertUnsupportedExtension)\n\t\treturn errors.New(\"tls: client sent unexpected early data\")\n\t}\n\n\ths.hello.sessionId = hs.clientHello.sessionId\n\ths.hello.compressionMethod = compressionNone\n\n\tpreferenceList := defaultCipherSuitesTLS13\n\tif !hasAESGCMHardwareSupport || !aesgcmPreferred(hs.clientHello.cipherSuites) {\n\t\tpreferenceList = defaultCipherSuitesTLS13NoAES\n\t}\n\tif needFIPS() {\n\t\tpreferenceList = defaultCipherSuitesTLS13FIPS\n\t}\n\tfor _, suiteID := range preferenceList {\n\t\ths.suite = mutualCipherSuiteTLS13(hs.clientHello.cipherSuites, suiteID)\n\t\tif hs.suite != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif hs.suite == nil {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: no cipher suite supported by both client and server\")\n\t}\n\tc.cipherSuite = hs.suite.id\n\ths.hello.cipherSuite = hs.suite.id\n\ths.transcript = hs.suite.hash.New()\n\n\t// Pick the key exchange method in server preference order, but give\n\t// priority to key shares, to avoid a HelloRetryRequest round-trip.\n\tvar selectedGroup CurveID\n\tvar clientKeyShare *keyShare\n\tpreferredGroups := c.config.curvePreferences(c.vers)\n\tfor _, preferredGroup := range preferredGroups {\n\t\tki := slices.IndexFunc(hs.clientHello.keyShares, func(ks keyShare) bool {\n\t\t\treturn ks.group == preferredGroup\n\t\t})\n\t\tif ki != -1 {\n\t\t\tclientKeyShare = &hs.clientHello.keyShares[ki]\n\t\t\tselectedGroup = clientKeyShare.group\n\t\t\tif !slices.Contains(hs.clientHello.supportedCurves, selectedGroup) {\n\t\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\t\treturn errors.New(\"tls: client sent key share for group it does not support\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif selectedGroup == 0 {\n\t\tfor _, preferredGroup := range preferredGroups {\n\t\t\tif slices.Contains(hs.clientHello.supportedCurves, preferredGroup) {\n\t\t\t\tselectedGroup = preferredGroup\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif selectedGroup == 0 {\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn errors.New(\"tls: no ECDHE curve supported by both client and server\")\n\t}\n\tif clientKeyShare == nil {\n\t\tks, err := hs.doHelloRetryRequest(selectedGroup)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclientKeyShare = ks\n\t}\n\tc.curveID = selectedGroup\n\n\tecdhGroup := selectedGroup\n\tecdhData := clientKeyShare.data\n\tif selectedGroup == x25519Kyber768Draft00 {\n\t\tecdhGroup = X25519\n\t\tif len(ecdhData) != x25519PublicKeySize+mlkem768.EncapsulationKeySize {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: invalid Kyber client key share\")\n\t\t}\n\t\tecdhData = ecdhData[:x25519PublicKeySize]\n\t}\n\tif _, ok := curveForCurveID(ecdhGroup); !ok {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn errors.New(\"tls: CurvePreferences includes unsupported curve\")\n\t}\n\tkey, err := generateECDHEKey(c.config.rand(), ecdhGroup)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\ths.hello.serverShare = keyShare{group: selectedGroup, data: key.PublicKey().Bytes()}\n\tpeerKey, err := key.Curve().NewPublicKey(ecdhData)\n\tif err != nil {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: invalid client key share\")\n\t}\n\ths.sharedKey, err = key.ECDH(peerKey)\n\tif err != nil {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: invalid client key share\")\n\t}\n\tif selectedGroup == x25519Kyber768Draft00 {\n\t\tciphertext, kyberShared, err := kyberEncapsulate(clientKeyShare.data[x25519PublicKeySize:])\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: invalid Kyber client key share\")\n\t\t}\n\t\ths.sharedKey = append(hs.sharedKey, kyberShared...)\n\t\ths.hello.serverShare.data = append(hs.hello.serverShare.data, ciphertext...)\n\t}\n\n\tselectedProto, err := negotiateALPN(c.config.NextProtos, hs.clientHello.alpnProtocols, c.quic != nil)\n\tif err != nil {\n\t\tc.sendAlert(alertNoApplicationProtocol)\n\t\treturn err\n\t}\n\tc.clientProtocol = selectedProto\n\n\tif c.quic != nil {\n\t\t// RFC 9001 Section 4.2: Clients MUST NOT offer TLS versions older than 1.3.\n\t\tfor _, v := range hs.clientHello.supportedVersions {\n\t\t\tif v < VersionTLS13 {\n\t\t\t\tc.sendAlert(alertProtocolVersion)\n\t\t\t\treturn errors.New(\"tls: client offered TLS version older than TLS 1.3\")\n\t\t\t}\n\t\t}\n\t\t// RFC 9001 Section 8.2.\n\t\tif hs.clientHello.quicTransportParameters == nil {\n\t\t\tc.sendAlert(alertMissingExtension)\n\t\t\treturn errors.New(\"tls: client did not send a quic_transport_parameters extension\")\n\t\t}\n\t\tc.quicSetTransportParameters(hs.clientHello.quicTransportParameters)\n\t} else {\n\t\tif hs.clientHello.quicTransportParameters != nil {\n\t\t\tc.sendAlert(alertUnsupportedExtension)\n\t\t\treturn errors.New(\"tls: client sent an unexpected quic_transport_parameters extension\")\n\t\t}\n\t}\n\n\tc.serverName = hs.clientHello.serverName\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) checkForResumption() error {\n\tc := hs.c\n\n\tif c.config.SessionTicketsDisabled {\n\t\treturn nil\n\t}\n\n\tmodeOK := false\n\tfor _, mode := range hs.clientHello.pskModes {\n\t\tif mode == pskModeDHE {\n\t\t\tmodeOK = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !modeOK {\n\t\treturn nil\n\t}\n\n\tif len(hs.clientHello.pskIdentities) != len(hs.clientHello.pskBinders) {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn errors.New(\"tls: invalid or missing PSK binders\")\n\t}\n\tif len(hs.clientHello.pskIdentities) == 0 {\n\t\treturn nil\n\t}\n\n\tfor i, identity := range hs.clientHello.pskIdentities {\n\t\tif i >= maxClientPSKIdentities {\n\t\t\tbreak\n\t\t}\n\n\t\tvar sessionState *SessionState\n\t\tif c.config.UnwrapSession != nil {\n\t\t\tvar err error\n\t\t\tsessionState, err = c.config.UnwrapSession(identity.label, c.connectionStateLocked())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif sessionState == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else {\n\t\t\tplaintext := c.config.decryptTicket(identity.label, c.ticketKeys)\n\t\t\tif plaintext == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar err error\n\t\t\tsessionState, err = ParseSessionState(plaintext)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif sessionState.version != VersionTLS13 {\n\t\t\tcontinue\n\t\t}\n\n\t\tcreatedAt := time.Unix(int64(sessionState.createdAt), 0)\n\t\tif c.config.time().Sub(createdAt) > maxSessionTicketLifetime {\n\t\t\tcontinue\n\t\t}\n\n\t\tpskSuite := cipherSuiteTLS13ByID(sessionState.cipherSuite)\n\t\tif pskSuite == nil || pskSuite.hash != hs.suite.hash {\n\t\t\tcontinue\n\t\t}\n\n\t\t// PSK connections don't re-establish client certificates, but carry\n\t\t// them over in the session ticket. Ensure the presence of client certs\n\t\t// in the ticket is consistent with the configured requirements.\n\t\tsessionHasClientCerts := len(sessionState.peerCertificates) != 0\n\t\tneedClientCerts := requiresClientCert(c.config.ClientAuth)\n\t\tif needClientCerts && !sessionHasClientCerts {\n\t\t\tcontinue\n\t\t}\n\t\tif sessionHasClientCerts && c.config.ClientAuth == NoClientCert {\n\t\t\tcontinue\n\t\t}\n\t\tif sessionHasClientCerts && c.config.time().After(sessionState.peerCertificates[0].NotAfter) {\n\t\t\tcontinue\n\t\t}\n\t\tif sessionHasClientCerts && c.config.ClientAuth >= VerifyClientCertIfGiven &&\n\t\t\tlen(sessionState.verifiedChains) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.quic != nil && c.quic.enableSessionEvents {\n\t\t\tif err := c.quicResumeSession(sessionState); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\ths.earlySecret = hs.suite.extract(sessionState.secret, nil)\n\t\tbinderKey := hs.suite.deriveSecret(hs.earlySecret, resumptionBinderLabel, nil)\n\t\t// Clone the transcript in case a HelloRetryRequest was recorded.\n\t\ttranscript := cloneHash(hs.transcript, hs.suite.hash)\n\t\tif transcript == nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn errors.New(\"tls: internal error: failed to clone hash\")\n\t\t}\n\t\tclientHelloBytes, err := hs.clientHello.marshalWithoutBinders()\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\t\ttranscript.Write(clientHelloBytes)\n\t\tpskBinder := hs.suite.finishedHash(binderKey, transcript)\n\t\tif !hmac.Equal(hs.clientHello.pskBinders[i], pskBinder) {\n\t\t\tc.sendAlert(alertDecryptError)\n\t\t\treturn errors.New(\"tls: invalid PSK binder\")\n\t\t}\n\n\t\tif c.quic != nil && hs.clientHello.earlyData && i == 0 &&\n\t\t\tsessionState.EarlyData && sessionState.cipherSuite == hs.suite.id &&\n\t\t\tsessionState.alpnProtocol == c.clientProtocol {\n\t\t\ths.earlyData = true\n\n\t\t\ttranscript := hs.suite.hash.New()\n\t\t\tif err := transcriptMsg(hs.clientHello, transcript); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tearlyTrafficSecret := hs.suite.deriveSecret(hs.earlySecret, clientEarlyTrafficLabel, transcript)\n\t\t\tc.quicSetReadSecret(QUICEncryptionLevelEarly, hs.suite.id, earlyTrafficSecret)\n\t\t}\n\n\t\tc.didResume = true\n\t\tc.peerCertificates = sessionState.peerCertificates\n\t\tc.ocspResponse = sessionState.ocspResponse\n\t\tc.scts = sessionState.scts\n\t\tc.verifiedChains = sessionState.verifiedChains\n\n\t\ths.hello.selectedIdentityPresent = true\n\t\ths.hello.selectedIdentity = uint16(i)\n\t\ths.usingPSK = true\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\n// cloneHash uses the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler\n// interfaces implemented by standard library hashes to clone the state of in\n// to a new instance of h. It returns nil if the operation fails.\nfunc cloneHash(in hash.Hash, h crypto.Hash) hash.Hash {\n\t// Recreate the interface to avoid importing encoding.\n\ttype binaryMarshaler interface {\n\t\tMarshalBinary() (data []byte, err error)\n\t\tUnmarshalBinary(data []byte) error\n\t}\n\tmarshaler, ok := in.(binaryMarshaler)\n\tif !ok {\n\t\treturn nil\n\t}\n\tstate, err := marshaler.MarshalBinary()\n\tif err != nil {\n\t\treturn nil\n\t}\n\tout := h.New()\n\tunmarshaler, ok := out.(binaryMarshaler)\n\tif !ok {\n\t\treturn nil\n\t}\n\tif err := unmarshaler.UnmarshalBinary(state); err != nil {\n\t\treturn nil\n\t}\n\treturn out\n}\n\nfunc (hs *serverHandshakeStateTLS13) pickCertificate() error {\n\tc := hs.c\n\n\t// Only one of PSK and certificates are used at a time.\n\tif hs.usingPSK {\n\t\treturn nil\n\t}\n\n\t// signature_algorithms is required in TLS 1.3. See RFC 8446, Section 4.2.3.\n\tif len(hs.clientHello.supportedSignatureAlgorithms) == 0 {\n\t\treturn c.sendAlert(alertMissingExtension)\n\t}\n\n\tcertificate, err := c.config.getCertificate(clientHelloInfo(hs.ctx, c, hs.clientHello))\n\tif err != nil {\n\t\tif err == errNoCertificates {\n\t\t\tc.sendAlert(alertUnrecognizedName)\n\t\t} else {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t}\n\t\treturn err\n\t}\n\ths.sigAlg, err = selectSignatureScheme(c.vers, certificate, hs.clientHello.supportedSignatureAlgorithms)\n\tif err != nil {\n\t\t// getCertificate returned a certificate that is unsupported or\n\t\t// incompatible with the client's signature algorithms.\n\t\tc.sendAlert(alertHandshakeFailure)\n\t\treturn err\n\t}\n\ths.cert = certificate\n\n\treturn nil\n}\n\n// sendDummyChangeCipherSpec sends a ChangeCipherSpec record for compatibility\n// with middleboxes that didn't implement TLS correctly. See RFC 8446, Appendix D.4.\nfunc (hs *serverHandshakeStateTLS13) sendDummyChangeCipherSpec() error {\n\tif hs.c.quic != nil {\n\t\treturn nil\n\t}\n\tif hs.sentDummyCCS {\n\t\treturn nil\n\t}\n\ths.sentDummyCCS = true\n\n\treturn hs.c.writeChangeCipherRecord()\n}\n\nfunc (hs *serverHandshakeStateTLS13) doHelloRetryRequest(selectedGroup CurveID) (*keyShare, error) {\n\tc := hs.c\n\n\t// The first ClientHello gets double-hashed into the transcript upon a\n\t// HelloRetryRequest. See RFC 8446, Section 4.4.1.\n\tif err := transcriptMsg(hs.clientHello, hs.transcript); err != nil {\n\t\treturn nil, err\n\t}\n\tchHash := hs.transcript.Sum(nil)\n\ths.transcript.Reset()\n\ths.transcript.Write([]byte{typeMessageHash, 0, 0, uint8(len(chHash))})\n\ths.transcript.Write(chHash)\n\n\thelloRetryRequest := &serverHelloMsg{\n\t\tvers:              hs.hello.vers,\n\t\trandom:            helloRetryRequestRandom,\n\t\tsessionId:         hs.hello.sessionId,\n\t\tcipherSuite:       hs.hello.cipherSuite,\n\t\tcompressionMethod: hs.hello.compressionMethod,\n\t\tsupportedVersion:  hs.hello.supportedVersion,\n\t\tselectedGroup:     selectedGroup,\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(helloRetryRequest, hs.transcript); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := hs.sendDummyChangeCipherSpec(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// clientHelloMsg is not included in the transcript.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclientHello, ok := msg.(*clientHelloMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn nil, unexpectedMessageError(clientHello, msg)\n\t}\n\n\tif len(clientHello.keyShares) != 1 {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn nil, errors.New(\"tls: client didn't send one key share in second ClientHello\")\n\t}\n\tks := &clientHello.keyShares[0]\n\n\tif ks.group != selectedGroup {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn nil, errors.New(\"tls: client sent unexpected key share in second ClientHello\")\n\t}\n\n\tif clientHello.earlyData {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn nil, errors.New(\"tls: client indicated early data in second ClientHello\")\n\t}\n\n\tif illegalClientHelloChange(clientHello, hs.clientHello) {\n\t\tc.sendAlert(alertIllegalParameter)\n\t\treturn nil, errors.New(\"tls: client illegally modified second ClientHello\")\n\t}\n\n\tc.didHRR = true\n\ths.clientHello = clientHello\n\treturn ks, nil\n}\n\n// illegalClientHelloChange reports whether the two ClientHello messages are\n// different, with the exception of the changes allowed before and after a\n// HelloRetryRequest. See RFC 8446, Section 4.1.2.\nfunc illegalClientHelloChange(ch, ch1 *clientHelloMsg) bool {\n\tif len(ch.supportedVersions) != len(ch1.supportedVersions) ||\n\t\tlen(ch.cipherSuites) != len(ch1.cipherSuites) ||\n\t\tlen(ch.supportedCurves) != len(ch1.supportedCurves) ||\n\t\tlen(ch.supportedSignatureAlgorithms) != len(ch1.supportedSignatureAlgorithms) ||\n\t\tlen(ch.supportedSignatureAlgorithmsCert) != len(ch1.supportedSignatureAlgorithmsCert) ||\n\t\tlen(ch.alpnProtocols) != len(ch1.alpnProtocols) {\n\t\treturn true\n\t}\n\tfor i := range ch.supportedVersions {\n\t\tif ch.supportedVersions[i] != ch1.supportedVersions[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor i := range ch.cipherSuites {\n\t\tif ch.cipherSuites[i] != ch1.cipherSuites[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor i := range ch.supportedCurves {\n\t\tif ch.supportedCurves[i] != ch1.supportedCurves[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor i := range ch.supportedSignatureAlgorithms {\n\t\tif ch.supportedSignatureAlgorithms[i] != ch1.supportedSignatureAlgorithms[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor i := range ch.supportedSignatureAlgorithmsCert {\n\t\tif ch.supportedSignatureAlgorithmsCert[i] != ch1.supportedSignatureAlgorithmsCert[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\tfor i := range ch.alpnProtocols {\n\t\tif ch.alpnProtocols[i] != ch1.alpnProtocols[i] {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn ch.vers != ch1.vers ||\n\t\t!bytes.Equal(ch.random, ch1.random) ||\n\t\t!bytes.Equal(ch.sessionId, ch1.sessionId) ||\n\t\t!bytes.Equal(ch.compressionMethods, ch1.compressionMethods) ||\n\t\tch.serverName != ch1.serverName ||\n\t\tch.ocspStapling != ch1.ocspStapling ||\n\t\t!bytes.Equal(ch.supportedPoints, ch1.supportedPoints) ||\n\t\tch.ticketSupported != ch1.ticketSupported ||\n\t\t!bytes.Equal(ch.sessionTicket, ch1.sessionTicket) ||\n\t\tch.secureRenegotiationSupported != ch1.secureRenegotiationSupported ||\n\t\t!bytes.Equal(ch.secureRenegotiation, ch1.secureRenegotiation) ||\n\t\tch.scts != ch1.scts ||\n\t\t!bytes.Equal(ch.cookie, ch1.cookie) ||\n\t\t!bytes.Equal(ch.pskModes, ch1.pskModes)\n}\n\nfunc (hs *serverHandshakeStateTLS13) sendServerParameters() error {\n\tc := hs.c\n\n\tif err := transcriptMsg(hs.clientHello, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\tif _, err := hs.c.writeHandshakeRecord(hs.hello, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tif err := hs.sendDummyChangeCipherSpec(); err != nil {\n\t\treturn err\n\t}\n\n\tearlySecret := hs.earlySecret\n\tif earlySecret == nil {\n\t\tearlySecret = hs.suite.extract(nil, nil)\n\t}\n\ths.handshakeSecret = hs.suite.extract(hs.sharedKey,\n\t\ths.suite.deriveSecret(earlySecret, \"derived\", nil))\n\n\tclientSecret := hs.suite.deriveSecret(hs.handshakeSecret,\n\t\tclientHandshakeTrafficLabel, hs.transcript)\n\tc.in.setTrafficSecret(hs.suite, QUICEncryptionLevelHandshake, clientSecret)\n\tserverSecret := hs.suite.deriveSecret(hs.handshakeSecret,\n\t\tserverHandshakeTrafficLabel, hs.transcript)\n\tc.out.setTrafficSecret(hs.suite, QUICEncryptionLevelHandshake, serverSecret)\n\n\tif c.quic != nil {\n\t\tif c.hand.Len() != 0 {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t}\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelHandshake, hs.suite.id, serverSecret)\n\t\tc.quicSetReadSecret(QUICEncryptionLevelHandshake, hs.suite.id, clientSecret)\n\t}\n\n\terr := c.config.writeKeyLog(keyLogLabelClientHandshake, hs.clientHello.random, clientSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\terr = c.config.writeKeyLog(keyLogLabelServerHandshake, hs.clientHello.random, serverSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tencryptedExtensions := new(encryptedExtensionsMsg)\n\tencryptedExtensions.alpnProtocol = c.clientProtocol\n\n\tif c.quic != nil {\n\t\tp, err := c.quicGetTransportParameters()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tencryptedExtensions.quicTransportParameters = p\n\t\tencryptedExtensions.earlyData = hs.earlyData\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(encryptedExtensions, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) requestClientCert() bool {\n\treturn hs.c.config.ClientAuth >= RequestClientCert && !hs.usingPSK\n}\n\nfunc (hs *serverHandshakeStateTLS13) sendServerCertificate() error {\n\tc := hs.c\n\n\t// Only one of PSK and certificates are used at a time.\n\tif hs.usingPSK {\n\t\treturn nil\n\t}\n\n\tif hs.requestClientCert() {\n\t\t// Request a client certificate\n\t\tcertReq := new(certificateRequestMsgTLS13)\n\t\tcertReq.ocspStapling = true\n\t\tcertReq.scts = true\n\t\tcertReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms()\n\t\tif c.config.ClientCAs != nil {\n\t\t\tcertReq.certificateAuthorities = c.config.ClientCAs.Subjects()\n\t\t}\n\n\t\tif _, err := hs.c.writeHandshakeRecord(certReq, hs.transcript); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcertMsg := new(certificateMsgTLS13)\n\n\tcertMsg.certificate = *hs.cert\n\tcertMsg.scts = hs.clientHello.scts && len(hs.cert.SignedCertificateTimestamps) > 0\n\tcertMsg.ocspStapling = hs.clientHello.ocspStapling && len(hs.cert.OCSPStaple) > 0\n\n\tif _, err := hs.c.writeHandshakeRecord(certMsg, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tcertVerifyMsg := new(certificateVerifyMsg)\n\tcertVerifyMsg.hasSignatureAlgorithm = true\n\tcertVerifyMsg.signatureAlgorithm = hs.sigAlg\n\n\tsigType, sigHash, err := typeAndHashFromSignatureScheme(hs.sigAlg)\n\tif err != nil {\n\t\treturn c.sendAlert(alertInternalError)\n\t}\n\n\tsigned := signedMessage(sigHash, serverSignatureContext, hs.transcript)\n\tsignOpts := crypto.SignerOpts(sigHash)\n\tif sigType == signatureRSAPSS {\n\t\tsignOpts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: sigHash}\n\t}\n\tsig, err := hs.cert.PrivateKey.(crypto.Signer).Sign(c.config.rand(), signed, signOpts)\n\tif err != nil {\n\t\tpublic := hs.cert.PrivateKey.(crypto.Signer).Public()\n\t\tif rsaKey, ok := public.(*rsa.PublicKey); ok && sigType == signatureRSAPSS &&\n\t\t\trsaKey.N.BitLen()/8 < sigHash.Size()*2+2 { // key too small for RSA-PSS\n\t\t\tc.sendAlert(alertHandshakeFailure)\n\t\t} else {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t}\n\t\treturn errors.New(\"tls: failed to sign handshake: \" + err.Error())\n\t}\n\tcertVerifyMsg.signature = sig\n\n\tif _, err := hs.c.writeHandshakeRecord(certVerifyMsg, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) sendServerFinished() error {\n\tc := hs.c\n\n\tfinished := &finishedMsg{\n\t\tverifyData: hs.suite.finishedHash(c.out.trafficSecret, hs.transcript),\n\t}\n\n\tif _, err := hs.c.writeHandshakeRecord(finished, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\t// Derive secrets that take context through the server Finished.\n\n\ths.masterSecret = hs.suite.extract(nil,\n\t\ths.suite.deriveSecret(hs.handshakeSecret, \"derived\", nil))\n\n\ths.trafficSecret = hs.suite.deriveSecret(hs.masterSecret,\n\t\tclientApplicationTrafficLabel, hs.transcript)\n\tserverSecret := hs.suite.deriveSecret(hs.masterSecret,\n\t\tserverApplicationTrafficLabel, hs.transcript)\n\tc.out.setTrafficSecret(hs.suite, QUICEncryptionLevelApplication, serverSecret)\n\n\tif c.quic != nil {\n\t\tif c.hand.Len() != 0 {\n\t\t\t// TODO: Handle this in setTrafficSecret?\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t}\n\t\tc.quicSetWriteSecret(QUICEncryptionLevelApplication, hs.suite.id, serverSecret)\n\t}\n\n\terr := c.config.writeKeyLog(keyLogLabelClientTraffic, hs.clientHello.random, hs.trafficSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\terr = c.config.writeKeyLog(keyLogLabelServerTraffic, hs.clientHello.random, serverSecret)\n\tif err != nil {\n\t\tc.sendAlert(alertInternalError)\n\t\treturn err\n\t}\n\n\tc.ekm = hs.suite.exportKeyingMaterial(hs.masterSecret, hs.transcript)\n\n\t// If we did not request client certificates, at this point we can\n\t// precompute the client finished and roll the transcript forward to send\n\t// session tickets in our first flight.\n\tif !hs.requestClientCert() {\n\t\tif err := hs.sendSessionTickets(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) shouldSendSessionTickets() bool {\n\tif hs.c.config.SessionTicketsDisabled {\n\t\treturn false\n\t}\n\n\t// QUIC tickets are sent by QUICConn.SendSessionTicket, not automatically.\n\tif hs.c.quic != nil {\n\t\treturn false\n\t}\n\n\t// Don't send tickets the client wouldn't use. See RFC 8446, Section 4.2.9.\n\tfor _, pskMode := range hs.clientHello.pskModes {\n\t\tif pskMode == pskModeDHE {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (hs *serverHandshakeStateTLS13) sendSessionTickets() error {\n\tc := hs.c\n\n\ths.clientFinished = hs.suite.finishedHash(c.in.trafficSecret, hs.transcript)\n\tfinishedMsg := &finishedMsg{\n\t\tverifyData: hs.clientFinished,\n\t}\n\tif err := transcriptMsg(finishedMsg, hs.transcript); err != nil {\n\t\treturn err\n\t}\n\n\tc.resumptionSecret = hs.suite.deriveSecret(hs.masterSecret,\n\t\tresumptionLabel, hs.transcript)\n\n\tif !hs.shouldSendSessionTickets() {\n\t\treturn nil\n\t}\n\treturn c.sendSessionTicket(false, nil)\n}\n\nfunc (c *Conn) sendSessionTicket(earlyData bool, extra [][]byte) error {\n\tsuite := cipherSuiteTLS13ByID(c.cipherSuite)\n\tif suite == nil {\n\t\treturn errors.New(\"tls: internal error: unknown cipher suite\")\n\t}\n\t// ticket_nonce, which must be unique per connection, is always left at\n\t// zero because we only ever send one ticket per connection.\n\tpsk := suite.expandLabel(c.resumptionSecret, \"resumption\",\n\t\tnil, suite.hash.Size())\n\n\tm := new(newSessionTicketMsgTLS13)\n\n\tstate := c.sessionState()\n\tstate.secret = psk\n\tstate.EarlyData = earlyData\n\tstate.Extra = extra\n\tif c.config.WrapSession != nil {\n\t\tvar err error\n\t\tm.label, err = c.config.WrapSession(c.connectionStateLocked(), state)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tstateBytes, err := state.Bytes()\n\t\tif err != nil {\n\t\t\tc.sendAlert(alertInternalError)\n\t\t\treturn err\n\t\t}\n\t\tm.label, err = c.config.encryptTicket(stateBytes, c.ticketKeys)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tm.lifetime = uint32(maxSessionTicketLifetime / time.Second)\n\n\t// ticket_age_add is a random 32-bit value. See RFC 8446, section 4.6.1\n\t// The value is not stored anywhere; we never need to check the ticket age\n\t// because 0-RTT is not supported.\n\tageAdd := make([]byte, 4)\n\tif _, err := c.config.rand().Read(ageAdd); err != nil {\n\t\treturn err\n\t}\n\tm.ageAdd = binary.LittleEndian.Uint32(ageAdd)\n\n\tif earlyData {\n\t\t// RFC 9001, Section 4.6.1\n\t\tm.maxEarlyData = 0xffffffff\n\t}\n\n\tif _, err := c.writeHandshakeRecord(m, nil); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) readClientCertificate() error {\n\tc := hs.c\n\n\tif !hs.requestClientCert() {\n\t\t// Make sure the connection is still being verified whether or not\n\t\t// the server requested a client certificate.\n\t\tif c.config.VerifyConnection != nil {\n\t\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// If we requested a client certificate, then the client must send a\n\t// certificate message. If it's empty, no CertificateVerify is sent.\n\n\tmsg, err := c.readHandshake(hs.transcript)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcertMsg, ok := msg.(*certificateMsgTLS13)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(certMsg, msg)\n\t}\n\n\tif err := c.processCertsFromClient(certMsg.certificate); err != nil {\n\t\treturn err\n\t}\n\n\tif c.config.VerifyConnection != nil {\n\t\tif err := c.config.VerifyConnection(c.connectionStateLocked()); err != nil {\n\t\t\tc.sendAlert(alertBadCertificate)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif len(certMsg.certificate.Certificate) != 0 {\n\t\t// certificateVerifyMsg is included in the transcript, but not until\n\t\t// after we verify the handshake signature, since the state before\n\t\t// this message was sent is used.\n\t\tmsg, err = c.readHandshake(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcertVerify, ok := msg.(*certificateVerifyMsg)\n\t\tif !ok {\n\t\t\tc.sendAlert(alertUnexpectedMessage)\n\t\t\treturn unexpectedMessageError(certVerify, msg)\n\t\t}\n\n\t\t// See RFC 8446, Section 4.4.3.\n\t\tif !isSupportedSignatureAlgorithm(certVerify.signatureAlgorithm, supportedSignatureAlgorithms()) {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: client certificate used with invalid signature algorithm\")\n\t\t}\n\t\tsigType, sigHash, err := typeAndHashFromSignatureScheme(certVerify.signatureAlgorithm)\n\t\tif err != nil {\n\t\t\treturn c.sendAlert(alertInternalError)\n\t\t}\n\t\tif sigType == signaturePKCS1v15 || sigHash == crypto.SHA1 {\n\t\t\tc.sendAlert(alertIllegalParameter)\n\t\t\treturn errors.New(\"tls: client certificate used with invalid signature algorithm\")\n\t\t}\n\t\tsigned := signedMessage(sigHash, clientSignatureContext, hs.transcript)\n\t\tif err := verifyHandshakeSignature(sigType, c.peerCertificates[0].PublicKey,\n\t\t\tsigHash, signed, certVerify.signature); err != nil {\n\t\t\tc.sendAlert(alertDecryptError)\n\t\t\treturn errors.New(\"tls: invalid signature by the client certificate: \" + err.Error())\n\t\t}\n\n\t\tif err := transcriptMsg(certVerify, hs.transcript); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// If we waited until the client certificates to send session tickets, we\n\t// are ready to do it now.\n\tif err := hs.sendSessionTickets(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (hs *serverHandshakeStateTLS13) readClientFinished() error {\n\tc := hs.c\n\n\t// finishedMsg is not included in the transcript.\n\tmsg, err := c.readHandshake(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfinished, ok := msg.(*finishedMsg)\n\tif !ok {\n\t\tc.sendAlert(alertUnexpectedMessage)\n\t\treturn unexpectedMessageError(finished, msg)\n\t}\n\n\tif !hmac.Equal(hs.clientFinished, finished.verifyData) {\n\t\tc.sendAlert(alertDecryptError)\n\t\treturn errors.New(\"tls: invalid client finished hash\")\n\t}\n\n\tc.in.setTrafficSecret(hs.suite, QUICEncryptionLevelApplication, hs.trafficSecret)\n\n\treturn nil\n}\n"
        },
        {
          "name": "hpke",
          "type": "tree",
          "content": null
        },
        {
          "name": "key_agreement.go",
          "type": "blob",
          "size": 11.853515625,
          "content": "// Copyright 2010 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdh\"\n\t\"crypto/md5\"\n\t\"crypto/rsa\"\n\t\"crypto/sha1\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n)\n\n// A keyAgreement implements the client and server side of a TLS 1.0–1.2 key\n// agreement protocol by generating and processing key exchange messages.\ntype keyAgreement interface {\n\t// On the server side, the first two methods are called in order.\n\n\t// In the case that the key agreement protocol doesn't use a\n\t// ServerKeyExchange message, generateServerKeyExchange can return nil,\n\t// nil.\n\tgenerateServerKeyExchange(*Config, *Certificate, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, error)\n\tprocessClientKeyExchange(*Config, *Certificate, *clientKeyExchangeMsg, uint16) ([]byte, error)\n\n\t// On the client side, the next two methods are called in order.\n\n\t// This method may not be called if the server doesn't send a\n\t// ServerKeyExchange message.\n\tprocessServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) error\n\tgenerateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)\n}\n\nvar errClientKeyExchange = errors.New(\"tls: invalid ClientKeyExchange message\")\nvar errServerKeyExchange = errors.New(\"tls: invalid ServerKeyExchange message\")\n\n// rsaKeyAgreement implements the standard TLS key agreement where the client\n// encrypts the pre-master secret to the server's public key.\ntype rsaKeyAgreement struct{}\n\nfunc (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n\treturn nil, nil\n}\n\nfunc (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {\n\tif len(ckx.ciphertext) < 2 {\n\t\treturn nil, errClientKeyExchange\n\t}\n\tciphertextLen := int(ckx.ciphertext[0])<<8 | int(ckx.ciphertext[1])\n\tif ciphertextLen != len(ckx.ciphertext)-2 {\n\t\treturn nil, errClientKeyExchange\n\t}\n\tciphertext := ckx.ciphertext[2:]\n\n\tpriv, ok := cert.PrivateKey.(crypto.Decrypter)\n\tif !ok {\n\t\treturn nil, errors.New(\"tls: certificate private key does not implement crypto.Decrypter\")\n\t}\n\t// Perform constant time RSA PKCS #1 v1.5 decryption\n\tpreMasterSecret, err := priv.Decrypt(config.rand(), ciphertext, &rsa.PKCS1v15DecryptOptions{SessionKeyLen: 48})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// We don't check the version number in the premaster secret. For one,\n\t// by checking it, we would leak information about the validity of the\n\t// encrypted pre-master secret. Secondly, it provides only a small\n\t// benefit against a downgrade attack and some implementations send the\n\t// wrong version anyway. See the discussion at the end of section\n\t// 7.4.7.1 of RFC 4346.\n\treturn preMasterSecret, nil\n}\n\nfunc (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {\n\treturn errors.New(\"tls: unexpected ServerKeyExchange\")\n}\n\nfunc (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n\tpreMasterSecret := make([]byte, 48)\n\tpreMasterSecret[0] = byte(clientHello.vers >> 8)\n\tpreMasterSecret[1] = byte(clientHello.vers)\n\t_, err := io.ReadFull(config.rand(), preMasterSecret[2:])\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trsaKey, ok := cert.PublicKey.(*rsa.PublicKey)\n\tif !ok {\n\t\treturn nil, nil, errors.New(\"tls: server certificate contains incorrect key type for selected ciphersuite\")\n\t}\n\tencrypted, err := rsa.EncryptPKCS1v15(config.rand(), rsaKey, preMasterSecret)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tckx := new(clientKeyExchangeMsg)\n\tckx.ciphertext = make([]byte, len(encrypted)+2)\n\tckx.ciphertext[0] = byte(len(encrypted) >> 8)\n\tckx.ciphertext[1] = byte(len(encrypted))\n\tcopy(ckx.ciphertext[2:], encrypted)\n\treturn preMasterSecret, ckx, nil\n}\n\n// sha1Hash calculates a SHA1 hash over the given byte slices.\nfunc sha1Hash(slices [][]byte) []byte {\n\thsha1 := sha1.New()\n\tfor _, slice := range slices {\n\t\thsha1.Write(slice)\n\t}\n\treturn hsha1.Sum(nil)\n}\n\n// md5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the\n// concatenation of an MD5 and SHA1 hash.\nfunc md5SHA1Hash(slices [][]byte) []byte {\n\tmd5sha1 := make([]byte, md5.Size+sha1.Size)\n\thmd5 := md5.New()\n\tfor _, slice := range slices {\n\t\thmd5.Write(slice)\n\t}\n\tcopy(md5sha1, hmd5.Sum(nil))\n\tcopy(md5sha1[md5.Size:], sha1Hash(slices))\n\treturn md5sha1\n}\n\n// hashForServerKeyExchange hashes the given slices and returns their digest\n// using the given hash function (for TLS 1.2) or using a default based on\n// the sigType (for earlier TLS versions). For Ed25519 signatures, which don't\n// do pre-hashing, it returns the concatenation of the slices.\nfunc hashForServerKeyExchange(sigType uint8, hashFunc crypto.Hash, version uint16, slices ...[]byte) []byte {\n\tif sigType == signatureEd25519 {\n\t\tvar signed []byte\n\t\tfor _, slice := range slices {\n\t\t\tsigned = append(signed, slice...)\n\t\t}\n\t\treturn signed\n\t}\n\tif version >= VersionTLS12 {\n\t\th := hashFunc.New()\n\t\tfor _, slice := range slices {\n\t\t\th.Write(slice)\n\t\t}\n\t\tdigest := h.Sum(nil)\n\t\treturn digest\n\t}\n\tif sigType == signatureECDSA {\n\t\treturn sha1Hash(slices)\n\t}\n\treturn md5SHA1Hash(slices)\n}\n\n// ecdheKeyAgreement implements a TLS key agreement where the server\n// generates an ephemeral EC public/private key pair and signs it. The\n// pre-master secret is then calculated using ECDH. The signature may\n// be ECDSA, Ed25519 or RSA.\ntype ecdheKeyAgreement struct {\n\tversion uint16\n\tisRSA   bool\n\tkey     *ecdh.PrivateKey\n\n\t// ckx and preMasterSecret are generated in processServerKeyExchange\n\t// and returned in generateClientKeyExchange.\n\tckx             *clientKeyExchangeMsg\n\tpreMasterSecret []byte\n}\n\nfunc (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error) {\n\tvar curveID CurveID\n\tfor _, c := range clientHello.supportedCurves {\n\t\tif config.supportsCurve(ka.version, c) {\n\t\t\tcurveID = c\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif curveID == 0 {\n\t\treturn nil, errors.New(\"tls: no supported elliptic curves offered\")\n\t}\n\tif _, ok := curveForCurveID(curveID); !ok {\n\t\treturn nil, errors.New(\"tls: CurvePreferences includes unsupported curve\")\n\t}\n\n\tkey, err := generateECDHEKey(config.rand(), curveID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tka.key = key\n\n\t// See RFC 4492, Section 5.4.\n\tecdhePublic := key.PublicKey().Bytes()\n\tserverECDHEParams := make([]byte, 1+2+1+len(ecdhePublic))\n\tserverECDHEParams[0] = 3 // named curve\n\tserverECDHEParams[1] = byte(curveID >> 8)\n\tserverECDHEParams[2] = byte(curveID)\n\tserverECDHEParams[3] = byte(len(ecdhePublic))\n\tcopy(serverECDHEParams[4:], ecdhePublic)\n\n\tpriv, ok := cert.PrivateKey.(crypto.Signer)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"tls: certificate private key of type %T does not implement crypto.Signer\", cert.PrivateKey)\n\t}\n\n\tvar signatureAlgorithm SignatureScheme\n\tvar sigType uint8\n\tvar sigHash crypto.Hash\n\tif ka.version >= VersionTLS12 {\n\t\tsignatureAlgorithm, err = selectSignatureScheme(ka.version, cert, clientHello.supportedSignatureAlgorithms)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(signatureAlgorithm)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(priv.Public())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif (sigType == signaturePKCS1v15 || sigType == signatureRSAPSS) != ka.isRSA {\n\t\treturn nil, errors.New(\"tls: certificate cannot be used with the selected cipher suite\")\n\t}\n\n\tsigned := hashForServerKeyExchange(sigType, sigHash, ka.version, clientHello.random, hello.random, serverECDHEParams)\n\n\tsignOpts := crypto.SignerOpts(sigHash)\n\tif sigType == signatureRSAPSS {\n\t\tsignOpts = &rsa.PSSOptions{SaltLength: rsa.PSSSaltLengthEqualsHash, Hash: sigHash}\n\t}\n\tsig, err := priv.Sign(config.rand(), signed, signOpts)\n\tif err != nil {\n\t\treturn nil, errors.New(\"tls: failed to sign ECDHE parameters: \" + err.Error())\n\t}\n\n\tskx := new(serverKeyExchangeMsg)\n\tsigAndHashLen := 0\n\tif ka.version >= VersionTLS12 {\n\t\tsigAndHashLen = 2\n\t}\n\tskx.key = make([]byte, len(serverECDHEParams)+sigAndHashLen+2+len(sig))\n\tcopy(skx.key, serverECDHEParams)\n\tk := skx.key[len(serverECDHEParams):]\n\tif ka.version >= VersionTLS12 {\n\t\tk[0] = byte(signatureAlgorithm >> 8)\n\t\tk[1] = byte(signatureAlgorithm)\n\t\tk = k[2:]\n\t}\n\tk[0] = byte(len(sig) >> 8)\n\tk[1] = byte(len(sig))\n\tcopy(k[2:], sig)\n\n\treturn skx, nil\n}\n\nfunc (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error) {\n\tif len(ckx.ciphertext) == 0 || int(ckx.ciphertext[0]) != len(ckx.ciphertext)-1 {\n\t\treturn nil, errClientKeyExchange\n\t}\n\n\tpeerKey, err := ka.key.Curve().NewPublicKey(ckx.ciphertext[1:])\n\tif err != nil {\n\t\treturn nil, errClientKeyExchange\n\t}\n\tpreMasterSecret, err := ka.key.ECDH(peerKey)\n\tif err != nil {\n\t\treturn nil, errClientKeyExchange\n\t}\n\n\treturn preMasterSecret, nil\n}\n\nfunc (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error {\n\tif len(skx.key) < 4 {\n\t\treturn errServerKeyExchange\n\t}\n\tif skx.key[0] != 3 { // named curve\n\t\treturn errors.New(\"tls: server selected unsupported curve\")\n\t}\n\tcurveID := CurveID(skx.key[1])<<8 | CurveID(skx.key[2])\n\n\tpublicLen := int(skx.key[3])\n\tif publicLen+4 > len(skx.key) {\n\t\treturn errServerKeyExchange\n\t}\n\tserverECDHEParams := skx.key[:4+publicLen]\n\tpublicKey := serverECDHEParams[4:]\n\n\tsig := skx.key[4+publicLen:]\n\tif len(sig) < 2 {\n\t\treturn errServerKeyExchange\n\t}\n\n\tif _, ok := curveForCurveID(curveID); !ok {\n\t\treturn errors.New(\"tls: server selected unsupported curve\")\n\t}\n\n\tkey, err := generateECDHEKey(config.rand(), curveID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tka.key = key\n\n\tpeerKey, err := key.Curve().NewPublicKey(publicKey)\n\tif err != nil {\n\t\treturn errServerKeyExchange\n\t}\n\tka.preMasterSecret, err = key.ECDH(peerKey)\n\tif err != nil {\n\t\treturn errServerKeyExchange\n\t}\n\n\tourPublicKey := key.PublicKey().Bytes()\n\tka.ckx = new(clientKeyExchangeMsg)\n\tka.ckx.ciphertext = make([]byte, 1+len(ourPublicKey))\n\tka.ckx.ciphertext[0] = byte(len(ourPublicKey))\n\tcopy(ka.ckx.ciphertext[1:], ourPublicKey)\n\n\tvar sigType uint8\n\tvar sigHash crypto.Hash\n\tif ka.version >= VersionTLS12 {\n\t\tsignatureAlgorithm := SignatureScheme(sig[0])<<8 | SignatureScheme(sig[1])\n\t\tsig = sig[2:]\n\t\tif len(sig) < 2 {\n\t\t\treturn errServerKeyExchange\n\t\t}\n\n\t\tif !isSupportedSignatureAlgorithm(signatureAlgorithm, clientHello.supportedSignatureAlgorithms) {\n\t\t\treturn errors.New(\"tls: certificate used with invalid signature algorithm\")\n\t\t}\n\t\tsigType, sigHash, err = typeAndHashFromSignatureScheme(signatureAlgorithm)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tsigType, sigHash, err = legacyTypeAndHashFromPublicKey(cert.PublicKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif (sigType == signaturePKCS1v15 || sigType == signatureRSAPSS) != ka.isRSA {\n\t\treturn errServerKeyExchange\n\t}\n\n\tsigLen := int(sig[0])<<8 | int(sig[1])\n\tif sigLen+2 != len(sig) {\n\t\treturn errServerKeyExchange\n\t}\n\tsig = sig[2:]\n\n\tsigned := hashForServerKeyExchange(sigType, sigHash, ka.version, clientHello.random, serverHello.random, serverECDHEParams)\n\tif err := verifyHandshakeSignature(sigType, cert.PublicKey, sigHash, signed, sig); err != nil {\n\t\treturn errors.New(\"tls: invalid signature by the server certificate: \" + err.Error())\n\t}\n\treturn nil\n}\n\nfunc (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error) {\n\tif ka.ckx == nil {\n\t\treturn nil, nil, errors.New(\"tls: missing ServerKeyExchange message\")\n\t}\n\n\treturn ka.preMasterSecret, ka.ckx, nil\n}\n"
        },
        {
          "name": "key_schedule.go",
          "type": "blob",
          "size": 6.478515625,
          "content": "// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"crypto/ecdh\"\n\t\"crypto/hmac\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\n\t\"golang.org/x/crypto/cryptobyte\"\n\t\"golang.org/x/crypto/hkdf\"\n\t\"golang.org/x/crypto/sha3\"\n\n\t\"github.com/xtls/reality/mlkem768\"\n)\n\n// This file contains the functions necessary to compute the TLS 1.3 key\n// schedule. See RFC 8446, Section 7.\n\nconst (\n\tresumptionBinderLabel         = \"res binder\"\n\tclientEarlyTrafficLabel       = \"c e traffic\"\n\tclientHandshakeTrafficLabel   = \"c hs traffic\"\n\tserverHandshakeTrafficLabel   = \"s hs traffic\"\n\tclientApplicationTrafficLabel = \"c ap traffic\"\n\tserverApplicationTrafficLabel = \"s ap traffic\"\n\texporterLabel                 = \"exp master\"\n\tresumptionLabel               = \"res master\"\n\ttrafficUpdateLabel            = \"traffic upd\"\n)\n\n// expandLabel implements HKDF-Expand-Label from RFC 8446, Section 7.1.\nfunc (c *cipherSuiteTLS13) expandLabel(secret []byte, label string, context []byte, length int) []byte {\n\tvar hkdfLabel cryptobyte.Builder\n\thkdfLabel.AddUint16(uint16(length))\n\thkdfLabel.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddBytes([]byte(\"tls13 \"))\n\t\tb.AddBytes([]byte(label))\n\t})\n\thkdfLabel.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddBytes(context)\n\t})\n\thkdfLabelBytes, err := hkdfLabel.Bytes()\n\tif err != nil {\n\t\t// Rather than calling BytesOrPanic, we explicitly handle this error, in\n\t\t// order to provide a reasonable error message. It should be basically\n\t\t// impossible for this to panic, and routing errors back through the\n\t\t// tree rooted in this function is quite painful. The labels are fixed\n\t\t// size, and the context is either a fixed-length computed hash, or\n\t\t// parsed from a field which has the same length limitation. As such, an\n\t\t// error here is likely to only be caused during development.\n\t\t//\n\t\t// NOTE: another reasonable approach here might be to return a\n\t\t// randomized slice if we encounter an error, which would break the\n\t\t// connection, but avoid panicking. This would perhaps be safer but\n\t\t// significantly more confusing to users.\n\t\tpanic(fmt.Errorf(\"failed to construct HKDF label: %s\", err))\n\t}\n\tout := make([]byte, length)\n\tn, err := hkdf.Expand(c.hash.New, secret, hkdfLabelBytes).Read(out)\n\tif err != nil || n != length {\n\t\tpanic(\"tls: HKDF-Expand-Label invocation failed unexpectedly\")\n\t}\n\treturn out\n}\n\n// deriveSecret implements Derive-Secret from RFC 8446, Section 7.1.\nfunc (c *cipherSuiteTLS13) deriveSecret(secret []byte, label string, transcript hash.Hash) []byte {\n\tif transcript == nil {\n\t\ttranscript = c.hash.New()\n\t}\n\treturn c.expandLabel(secret, label, transcript.Sum(nil), c.hash.Size())\n}\n\n// extract implements HKDF-Extract with the cipher suite hash.\nfunc (c *cipherSuiteTLS13) extract(newSecret, currentSecret []byte) []byte {\n\tif newSecret == nil {\n\t\tnewSecret = make([]byte, c.hash.Size())\n\t}\n\treturn hkdf.Extract(c.hash.New, newSecret, currentSecret)\n}\n\n// nextTrafficSecret generates the next traffic secret, given the current one,\n// according to RFC 8446, Section 7.2.\nfunc (c *cipherSuiteTLS13) nextTrafficSecret(trafficSecret []byte) []byte {\n\treturn c.expandLabel(trafficSecret, trafficUpdateLabel, nil, c.hash.Size())\n}\n\n// trafficKey generates traffic keys according to RFC 8446, Section 7.3.\nfunc (c *cipherSuiteTLS13) trafficKey(trafficSecret []byte) (key, iv []byte) {\n\tkey = c.expandLabel(trafficSecret, \"key\", nil, c.keyLen)\n\tiv = c.expandLabel(trafficSecret, \"iv\", nil, aeadNonceLength)\n\treturn\n}\n\n// finishedHash generates the Finished verify_data or PskBinderEntry according\n// to RFC 8446, Section 4.4.4. See sections 4.4 and 4.2.11.2 for the baseKey\n// selection.\nfunc (c *cipherSuiteTLS13) finishedHash(baseKey []byte, transcript hash.Hash) []byte {\n\tfinishedKey := c.expandLabel(baseKey, \"finished\", nil, c.hash.Size())\n\tverifyData := hmac.New(c.hash.New, finishedKey)\n\tverifyData.Write(transcript.Sum(nil))\n\treturn verifyData.Sum(nil)\n}\n\n// exportKeyingMaterial implements RFC5705 exporters for TLS 1.3 according to\n// RFC 8446, Section 7.5.\nfunc (c *cipherSuiteTLS13) exportKeyingMaterial(masterSecret []byte, transcript hash.Hash) func(string, []byte, int) ([]byte, error) {\n\texpMasterSecret := c.deriveSecret(masterSecret, exporterLabel, transcript)\n\treturn func(label string, context []byte, length int) ([]byte, error) {\n\t\tsecret := c.deriveSecret(expMasterSecret, label, nil)\n\t\th := c.hash.New()\n\t\th.Write(context)\n\t\treturn c.expandLabel(secret, \"exporter\", h.Sum(nil), length), nil\n\t}\n}\n\ntype keySharePrivateKeys struct {\n\tcurveID CurveID\n\tecdhe   *ecdh.PrivateKey\n\tkyber   *mlkem768.DecapsulationKey\n}\n\n// kyberDecapsulate implements decapsulation according to Kyber Round 3.\nfunc kyberDecapsulate(dk *mlkem768.DecapsulationKey, c []byte) ([]byte, error) {\n\tK, err := mlkem768.Decapsulate(dk, c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn kyberSharedSecret(K, c), nil\n}\n\n// kyberEncapsulate implements encapsulation according to Kyber Round 3.\nfunc kyberEncapsulate(ek []byte) (c, ss []byte, err error) {\n\tc, ss, err = mlkem768.Encapsulate(ek)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn c, kyberSharedSecret(ss, c), nil\n}\n\nfunc kyberSharedSecret(K, c []byte) []byte {\n\t// Package mlkem768 implements ML-KEM, which compared to Kyber removed a\n\t// final hashing step. Compute SHAKE-256(K || SHA3-256(c), 32) to match Kyber.\n\t// See https://words.filippo.io/mlkem768/#bonus-track-using-a-ml-kem-implementation-as-kyber-v3.\n\th := sha3.NewShake256()\n\th.Write(K)\n\tch := sha3.Sum256(c)\n\th.Write(ch[:])\n\tout := make([]byte, 32)\n\th.Read(out)\n\treturn out\n}\n\nconst x25519PublicKeySize = 32\n\n// generateECDHEKey returns a PrivateKey that implements Diffie-Hellman\n// according to RFC 8446, Section 4.2.8.2.\nfunc generateECDHEKey(rand io.Reader, curveID CurveID) (*ecdh.PrivateKey, error) {\n\tcurve, ok := curveForCurveID(curveID)\n\tif !ok {\n\t\treturn nil, errors.New(\"tls: internal error: unsupported curve\")\n\t}\n\n\treturn curve.GenerateKey(rand)\n}\n\nfunc curveForCurveID(id CurveID) (ecdh.Curve, bool) {\n\tswitch id {\n\tcase X25519:\n\t\treturn ecdh.X25519(), true\n\tcase CurveP256:\n\t\treturn ecdh.P256(), true\n\tcase CurveP384:\n\t\treturn ecdh.P384(), true\n\tcase CurveP521:\n\t\treturn ecdh.P521(), true\n\tdefault:\n\t\treturn nil, false\n\t}\n}\n\nfunc curveIDForCurve(curve ecdh.Curve) (CurveID, bool) {\n\tswitch curve {\n\tcase ecdh.X25519():\n\t\treturn X25519, true\n\tcase ecdh.P256():\n\t\treturn CurveP256, true\n\tcase ecdh.P384():\n\t\treturn CurveP384, true\n\tcase ecdh.P521():\n\t\treturn CurveP521, true\n\tdefault:\n\t\treturn 0, false\n\t}\n}\n"
        },
        {
          "name": "mlkem768",
          "type": "tree",
          "content": null
        },
        {
          "name": "notboring.go",
          "type": "blob",
          "size": 0.23828125,
          "content": "// Copyright 2022 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\n//go:build !boringcrypto\n\npackage reality\n\nfunc needFIPS() bool { return false }\n"
        },
        {
          "name": "prf.go",
          "type": "blob",
          "size": 9.236328125,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"crypto\"\n\t\"crypto/hmac\"\n\t\"crypto/md5\"\n\t\"crypto/sha1\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n)\n\n// Split a premaster secret in two as specified in RFC 4346, Section 5.\nfunc splitPreMasterSecret(secret []byte) (s1, s2 []byte) {\n\ts1 = secret[0 : (len(secret)+1)/2]\n\ts2 = secret[len(secret)/2:]\n\treturn\n}\n\n// pHash implements the P_hash function, as defined in RFC 4346, Section 5.\nfunc pHash(result, secret, seed []byte, hash func() hash.Hash) {\n\th := hmac.New(hash, secret)\n\th.Write(seed)\n\ta := h.Sum(nil)\n\n\tj := 0\n\tfor j < len(result) {\n\t\th.Reset()\n\t\th.Write(a)\n\t\th.Write(seed)\n\t\tb := h.Sum(nil)\n\t\tcopy(result[j:], b)\n\t\tj += len(b)\n\n\t\th.Reset()\n\t\th.Write(a)\n\t\ta = h.Sum(nil)\n\t}\n}\n\n// prf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, Section 5.\nfunc prf10(result, secret, label, seed []byte) {\n\thashSHA1 := sha1.New\n\thashMD5 := md5.New\n\n\tlabelAndSeed := make([]byte, len(label)+len(seed))\n\tcopy(labelAndSeed, label)\n\tcopy(labelAndSeed[len(label):], seed)\n\n\ts1, s2 := splitPreMasterSecret(secret)\n\tpHash(result, s1, labelAndSeed, hashMD5)\n\tresult2 := make([]byte, len(result))\n\tpHash(result2, s2, labelAndSeed, hashSHA1)\n\n\tfor i, b := range result2 {\n\t\tresult[i] ^= b\n\t}\n}\n\n// prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, Section 5.\nfunc prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte) {\n\treturn func(result, secret, label, seed []byte) {\n\t\tlabelAndSeed := make([]byte, len(label)+len(seed))\n\t\tcopy(labelAndSeed, label)\n\t\tcopy(labelAndSeed[len(label):], seed)\n\n\t\tpHash(result, secret, labelAndSeed, hashFunc)\n\t}\n}\n\nconst (\n\tmasterSecretLength   = 48 // Length of a master secret in TLS 1.1.\n\tfinishedVerifyLength = 12 // Length of verify_data in a Finished message.\n)\n\nvar masterSecretLabel = []byte(\"master secret\")\nvar extendedMasterSecretLabel = []byte(\"extended master secret\")\nvar keyExpansionLabel = []byte(\"key expansion\")\nvar clientFinishedLabel = []byte(\"client finished\")\nvar serverFinishedLabel = []byte(\"server finished\")\n\nfunc prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte), crypto.Hash) {\n\tswitch version {\n\tcase VersionTLS10, VersionTLS11:\n\t\treturn prf10, crypto.Hash(0)\n\tcase VersionTLS12:\n\t\tif suite.flags&suiteSHA384 != 0 {\n\t\t\treturn prf12(sha512.New384), crypto.SHA384\n\t\t}\n\t\treturn prf12(sha256.New), crypto.SHA256\n\tdefault:\n\t\tpanic(\"unknown version\")\n\t}\n}\n\nfunc prfForVersion(version uint16, suite *cipherSuite) func(result, secret, label, seed []byte) {\n\tprf, _ := prfAndHashForVersion(version, suite)\n\treturn prf\n}\n\n// masterFromPreMasterSecret generates the master secret from the pre-master\n// secret. See RFC 5246, Section 8.1.\nfunc masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []byte) []byte {\n\tseed := make([]byte, 0, len(clientRandom)+len(serverRandom))\n\tseed = append(seed, clientRandom...)\n\tseed = append(seed, serverRandom...)\n\n\tmasterSecret := make([]byte, masterSecretLength)\n\tprfForVersion(version, suite)(masterSecret, preMasterSecret, masterSecretLabel, seed)\n\treturn masterSecret\n}\n\n// extMasterFromPreMasterSecret generates the extended master secret from the\n// pre-master secret. See RFC 7627.\nfunc extMasterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, transcript []byte) []byte {\n\tmasterSecret := make([]byte, masterSecretLength)\n\tprfForVersion(version, suite)(masterSecret, preMasterSecret, extendedMasterSecretLabel, transcript)\n\treturn masterSecret\n}\n\n// keysFromMasterSecret generates the connection keys from the master\n// secret, given the lengths of the MAC key, cipher key and IV, as defined in\n// RFC 2246, Section 6.3.\nfunc keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte) {\n\tseed := make([]byte, 0, len(serverRandom)+len(clientRandom))\n\tseed = append(seed, serverRandom...)\n\tseed = append(seed, clientRandom...)\n\n\tn := 2*macLen + 2*keyLen + 2*ivLen\n\tkeyMaterial := make([]byte, n)\n\tprfForVersion(version, suite)(keyMaterial, masterSecret, keyExpansionLabel, seed)\n\tclientMAC = keyMaterial[:macLen]\n\tkeyMaterial = keyMaterial[macLen:]\n\tserverMAC = keyMaterial[:macLen]\n\tkeyMaterial = keyMaterial[macLen:]\n\tclientKey = keyMaterial[:keyLen]\n\tkeyMaterial = keyMaterial[keyLen:]\n\tserverKey = keyMaterial[:keyLen]\n\tkeyMaterial = keyMaterial[keyLen:]\n\tclientIV = keyMaterial[:ivLen]\n\tkeyMaterial = keyMaterial[ivLen:]\n\tserverIV = keyMaterial[:ivLen]\n\treturn\n}\n\nfunc newFinishedHash(version uint16, cipherSuite *cipherSuite) finishedHash {\n\tvar buffer []byte\n\tif version >= VersionTLS12 {\n\t\tbuffer = []byte{}\n\t}\n\n\tprf, hash := prfAndHashForVersion(version, cipherSuite)\n\tif hash != 0 {\n\t\treturn finishedHash{hash.New(), hash.New(), nil, nil, buffer, version, prf}\n\t}\n\n\treturn finishedHash{sha1.New(), sha1.New(), md5.New(), md5.New(), buffer, version, prf}\n}\n\n// A finishedHash calculates the hash of a set of handshake messages suitable\n// for including in a Finished message.\ntype finishedHash struct {\n\tclient hash.Hash\n\tserver hash.Hash\n\n\t// Prior to TLS 1.2, an additional MD5 hash is required.\n\tclientMD5 hash.Hash\n\tserverMD5 hash.Hash\n\n\t// In TLS 1.2, a full buffer is sadly required.\n\tbuffer []byte\n\n\tversion uint16\n\tprf     func(result, secret, label, seed []byte)\n}\n\nfunc (h *finishedHash) Write(msg []byte) (n int, err error) {\n\th.client.Write(msg)\n\th.server.Write(msg)\n\n\tif h.version < VersionTLS12 {\n\t\th.clientMD5.Write(msg)\n\t\th.serverMD5.Write(msg)\n\t}\n\n\tif h.buffer != nil {\n\t\th.buffer = append(h.buffer, msg...)\n\t}\n\n\treturn len(msg), nil\n}\n\nfunc (h finishedHash) Sum() []byte {\n\tif h.version >= VersionTLS12 {\n\t\treturn h.client.Sum(nil)\n\t}\n\n\tout := make([]byte, 0, md5.Size+sha1.Size)\n\tout = h.clientMD5.Sum(out)\n\treturn h.client.Sum(out)\n}\n\n// clientSum returns the contents of the verify_data member of a client's\n// Finished message.\nfunc (h finishedHash) clientSum(masterSecret []byte) []byte {\n\tout := make([]byte, finishedVerifyLength)\n\th.prf(out, masterSecret, clientFinishedLabel, h.Sum())\n\treturn out\n}\n\n// serverSum returns the contents of the verify_data member of a server's\n// Finished message.\nfunc (h finishedHash) serverSum(masterSecret []byte) []byte {\n\tout := make([]byte, finishedVerifyLength)\n\th.prf(out, masterSecret, serverFinishedLabel, h.Sum())\n\treturn out\n}\n\n// hashForClientCertificate returns the handshake messages so far, pre-hashed if\n// necessary, suitable for signing by a TLS client certificate.\nfunc (h finishedHash) hashForClientCertificate(sigType uint8, hashAlg crypto.Hash) []byte {\n\tif (h.version >= VersionTLS12 || sigType == signatureEd25519) && h.buffer == nil {\n\t\tpanic(\"tls: handshake hash for a client certificate requested after discarding the handshake buffer\")\n\t}\n\n\tif sigType == signatureEd25519 {\n\t\treturn h.buffer\n\t}\n\n\tif h.version >= VersionTLS12 {\n\t\thash := hashAlg.New()\n\t\thash.Write(h.buffer)\n\t\treturn hash.Sum(nil)\n\t}\n\n\tif sigType == signatureECDSA {\n\t\treturn h.server.Sum(nil)\n\t}\n\n\treturn h.Sum()\n}\n\n// discardHandshakeBuffer is called when there is no more need to\n// buffer the entirety of the handshake messages.\nfunc (h *finishedHash) discardHandshakeBuffer() {\n\th.buffer = nil\n}\n\n// noEKMBecauseRenegotiation is used as a value of\n// ConnectionState.ekm when renegotiation is enabled and thus\n// we wish to fail all key-material export requests.\nfunc noEKMBecauseRenegotiation(label string, context []byte, length int) ([]byte, error) {\n\treturn nil, errors.New(\"crypto/tls: ExportKeyingMaterial is unavailable when renegotiation is enabled\")\n}\n\n// noEKMBecauseNoEMS is used as a value of ConnectionState.ekm when Extended\n// Master Secret is not negotiated and thus we wish to fail all key-material\n// export requests.\nfunc noEKMBecauseNoEMS(label string, context []byte, length int) ([]byte, error) {\n\treturn nil, errors.New(\"crypto/tls: ExportKeyingMaterial is unavailable when neither TLS 1.3 nor Extended Master Secret are negotiated; override with GODEBUG=tlsunsafeekm=1\")\n}\n\n// ekmFromMasterSecret generates exported keying material as defined in RFC 5705.\nfunc ekmFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte) func(string, []byte, int) ([]byte, error) {\n\treturn func(label string, context []byte, length int) ([]byte, error) {\n\t\tswitch label {\n\t\tcase \"client finished\", \"server finished\", \"master secret\", \"key expansion\":\n\t\t\t// These values are reserved and may not be used.\n\t\t\treturn nil, fmt.Errorf(\"crypto/tls: reserved ExportKeyingMaterial label: %s\", label)\n\t\t}\n\n\t\tseedLen := len(serverRandom) + len(clientRandom)\n\t\tif context != nil {\n\t\t\tseedLen += 2 + len(context)\n\t\t}\n\t\tseed := make([]byte, 0, seedLen)\n\n\t\tseed = append(seed, clientRandom...)\n\t\tseed = append(seed, serverRandom...)\n\n\t\tif context != nil {\n\t\t\tif len(context) >= 1<<16 {\n\t\t\t\treturn nil, fmt.Errorf(\"crypto/tls: ExportKeyingMaterial context too long\")\n\t\t\t}\n\t\t\tseed = append(seed, byte(len(context)>>8), byte(len(context)))\n\t\t\tseed = append(seed, context...)\n\t\t}\n\n\t\tkeyMaterial := make([]byte, length)\n\t\tprfForVersion(version, suite)(keyMaterial, masterSecret, []byte(label), seed)\n\t\treturn keyMaterial, nil\n\t}\n}\n"
        },
        {
          "name": "quic.go",
          "type": "blob",
          "size": 15.0947265625,
          "content": "// Copyright 2023 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage reality\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// QUICEncryptionLevel represents a QUIC encryption level used to transmit\n// handshake messages.\ntype QUICEncryptionLevel int\n\nconst (\n\tQUICEncryptionLevelInitial = QUICEncryptionLevel(iota)\n\tQUICEncryptionLevelEarly\n\tQUICEncryptionLevelHandshake\n\tQUICEncryptionLevelApplication\n)\n\nfunc (l QUICEncryptionLevel) String() string {\n\tswitch l {\n\tcase QUICEncryptionLevelInitial:\n\t\treturn \"Initial\"\n\tcase QUICEncryptionLevelEarly:\n\t\treturn \"Early\"\n\tcase QUICEncryptionLevelHandshake:\n\t\treturn \"Handshake\"\n\tcase QUICEncryptionLevelApplication:\n\t\treturn \"Application\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"QUICEncryptionLevel(%v)\", int(l))\n\t}\n}\n\n// A QUICConn represents a connection which uses a QUIC implementation as the underlying\n// transport as described in RFC 9001.\n//\n// Methods of QUICConn are not safe for concurrent use.\ntype QUICConn struct {\n\tconn *Conn\n\n\tsessionTicketSent bool\n}\n\n// A QUICConfig configures a [QUICConn].\ntype QUICConfig struct {\n\tTLSConfig *Config\n\n\t// EnableSessionEvents may be set to true to enable the\n\t// [QUICStoreSession] and [QUICResumeSession] events for client connections.\n\t// When this event is enabled, sessions are not automatically\n\t// stored in the client session cache.\n\t// The application should use [QUICConn.StoreSession] to store sessions.\n\tEnableSessionEvents bool\n}\n\n// A QUICEventKind is a type of operation on a QUIC connection.\ntype QUICEventKind int\n\nconst (\n\t// QUICNoEvent indicates that there are no events available.\n\tQUICNoEvent QUICEventKind = iota\n\n\t// QUICSetReadSecret and QUICSetWriteSecret provide the read and write\n\t// secrets for a given encryption level.\n\t// QUICEvent.Level, QUICEvent.Data, and QUICEvent.Suite are set.\n\t//\n\t// Secrets for the Initial encryption level are derived from the initial\n\t// destination connection ID, and are not provided by the QUICConn.\n\tQUICSetReadSecret\n\tQUICSetWriteSecret\n\n\t// QUICWriteData provides data to send to the peer in CRYPTO frames.\n\t// QUICEvent.Data is set.\n\tQUICWriteData\n\n\t// QUICTransportParameters provides the peer's QUIC transport parameters.\n\t// QUICEvent.Data is set.\n\tQUICTransportParameters\n\n\t// QUICTransportParametersRequired indicates that the caller must provide\n\t// QUIC transport parameters to send to the peer. The caller should set\n\t// the transport parameters with QUICConn.SetTransportParameters and call\n\t// QUICConn.NextEvent again.\n\t//\n\t// If transport parameters are set before calling QUICConn.Start, the\n\t// connection will never generate a QUICTransportParametersRequired event.\n\tQUICTransportParametersRequired\n\n\t// QUICRejectedEarlyData indicates that the server rejected 0-RTT data even\n\t// if we offered it. It's returned before QUICEncryptionLevelApplication\n\t// keys are returned.\n\t// This event only occurs on client connections.\n\tQUICRejectedEarlyData\n\n\t// QUICHandshakeDone indicates that the TLS handshake has completed.\n\tQUICHandshakeDone\n\n\t// QUICResumeSession indicates that a client is attempting to resume a previous session.\n\t// [QUICEvent.SessionState] is set.\n\t//\n\t// For client connections, this event occurs when the session ticket is selected.\n\t// For server connections, this event occurs when receiving the client's session ticket.\n\t//\n\t// The application may set [QUICEvent.SessionState.EarlyData] to false before the\n\t// next call to [QUICConn.NextEvent] to decline 0-RTT even if the session supports it.\n\tQUICResumeSession\n\n\t// QUICStoreSession indicates that the server has provided state permitting\n\t// the client to resume the session.\n\t// [QUICEvent.SessionState] is set.\n\t// The application should use [QUICConn.StoreSession] session to store the [SessionState].\n\t// The application may modify the [SessionState] before storing it.\n\t// This event only occurs on client connections.\n\tQUICStoreSession\n)\n\n// A QUICEvent is an event occurring on a QUIC connection.\n//\n// The type of event is specified by the Kind field.\n// The contents of the other fields are kind-specific.\ntype QUICEvent struct {\n\tKind QUICEventKind\n\n\t// Set for QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.\n\tLevel QUICEncryptionLevel\n\n\t// Set for QUICTransportParameters, QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.\n\t// The contents are owned by crypto/tls, and are valid until the next NextEvent call.\n\tData []byte\n\n\t// Set for QUICSetReadSecret and QUICSetWriteSecret.\n\tSuite uint16\n\n\t// Set for QUICResumeSession and QUICStoreSession.\n\tSessionState *SessionState\n}\n\ntype quicState struct {\n\tevents    []QUICEvent\n\tnextEvent int\n\n\t// eventArr is a statically allocated event array, large enough to handle\n\t// the usual maximum number of events resulting from a single call: transport\n\t// parameters, Initial data, Early read secret, Handshake write and read\n\t// secrets, Handshake data, Application write secret, Application data.\n\teventArr [8]QUICEvent\n\n\tstarted  bool\n\tsignalc  chan struct{}   // handshake data is available to be read\n\tblockedc chan struct{}   // handshake is waiting for data, closed when done\n\tcancelc  <-chan struct{} // handshake has been canceled\n\tcancel   context.CancelFunc\n\n\twaitingForDrain bool\n\n\t// readbuf is shared between HandleData and the handshake goroutine.\n\t// HandshakeCryptoData passes ownership to the handshake goroutine by\n\t// reading from signalc, and reclaims ownership by reading from blockedc.\n\treadbuf []byte\n\n\ttransportParams []byte // to send to the peer\n\n\tenableSessionEvents bool\n}\n\n// QUICClient returns a new TLS client side connection using QUICTransport as the\n// underlying transport. The config cannot be nil.\n//\n// The config's MinVersion must be at least TLS 1.3.\nfunc QUICClient(config *QUICConfig) *QUICConn {\n\treturn newQUICConn(Client(nil, config.TLSConfig), config)\n}\n\n// QUICServer returns a new TLS server side connection using QUICTransport as the\n// underlying transport. The config cannot be nil.\n//\n// The config's MinVersion must be at least TLS 1.3.\nfunc QUICServer(config *QUICConfig) *QUICConn {\n\tc, _ := Server(context.Background(), nil, config.TLSConfig)\n\treturn newQUICConn(c, config)\n}\n\nfunc newQUICConn(conn *Conn, config *QUICConfig) *QUICConn {\n\tconn.quic = &quicState{\n\t\tsignalc:             make(chan struct{}),\n\t\tblockedc:            make(chan struct{}),\n\t\tenableSessionEvents: config.EnableSessionEvents,\n\t}\n\tconn.quic.events = conn.quic.eventArr[:0]\n\treturn &QUICConn{\n\t\tconn: conn,\n\t}\n}\n\n// Start starts the client or server handshake protocol.\n// It may produce connection events, which may be read with [QUICConn.NextEvent].\n//\n// Start must be called at most once.\nfunc (q *QUICConn) Start(ctx context.Context) error {\n\tif q.conn.quic.started {\n\t\treturn quicError(errors.New(\"tls: Start called more than once\"))\n\t}\n\tq.conn.quic.started = true\n\tif q.conn.config.MinVersion < VersionTLS13 {\n\t\treturn quicError(errors.New(\"tls: Config MinVersion must be at least TLS 1.3\"))\n\t}\n\tgo q.conn.HandshakeContext(ctx)\n\tif _, ok := <-q.conn.quic.blockedc; !ok {\n\t\treturn q.conn.handshakeErr\n\t}\n\treturn nil\n}\n\n// NextEvent returns the next event occurring on the connection.\n// It returns an event with a Kind of [QUICNoEvent] when no events are available.\nfunc (q *QUICConn) NextEvent() QUICEvent {\n\tqs := q.conn.quic\n\tif last := qs.nextEvent - 1; last >= 0 && len(qs.events[last].Data) > 0 {\n\t\t// Write over some of the previous event's data,\n\t\t// to catch callers erroniously retaining it.\n\t\tqs.events[last].Data[0] = 0\n\t}\n\tif qs.nextEvent >= len(qs.events) && qs.waitingForDrain {\n\t\tqs.waitingForDrain = false\n\t\t<-qs.signalc\n\t\t<-qs.blockedc\n\t}\n\tif qs.nextEvent >= len(qs.events) {\n\t\tqs.events = qs.events[:0]\n\t\tqs.nextEvent = 0\n\t\treturn QUICEvent{Kind: QUICNoEvent}\n\t}\n\te := qs.events[qs.nextEvent]\n\tqs.events[qs.nextEvent] = QUICEvent{} // zero out references to data\n\tqs.nextEvent++\n\treturn e\n}\n\n// Close closes the connection and stops any in-progress handshake.\nfunc (q *QUICConn) Close() error {\n\tif q.conn.quic.cancel == nil {\n\t\treturn nil // never started\n\t}\n\tq.conn.quic.cancel()\n\tfor range q.conn.quic.blockedc {\n\t\t// Wait for the handshake goroutine to return.\n\t}\n\treturn q.conn.handshakeErr\n}\n\n// HandleData handles handshake bytes received from the peer.\n// It may produce connection events, which may be read with [QUICConn.NextEvent].\nfunc (q *QUICConn) HandleData(level QUICEncryptionLevel, data []byte) error {\n\tc := q.conn\n\tif c.in.level != level {\n\t\treturn quicError(c.in.setErrorLocked(errors.New(\"tls: handshake data received at wrong level\")))\n\t}\n\tc.quic.readbuf = data\n\t<-c.quic.signalc\n\t_, ok := <-c.quic.blockedc\n\tif ok {\n\t\t// The handshake goroutine is waiting for more data.\n\t\treturn nil\n\t}\n\t// The handshake goroutine has exited.\n\tc.handshakeMutex.Lock()\n\tdefer c.handshakeMutex.Unlock()\n\tc.hand.Write(c.quic.readbuf)\n\tc.quic.readbuf = nil\n\tfor q.conn.hand.Len() >= 4 && q.conn.handshakeErr == nil {\n\t\tb := q.conn.hand.Bytes()\n\t\tn := int(b[1])<<16 | int(b[2])<<8 | int(b[3])\n\t\tif n > maxHandshake {\n\t\t\tq.conn.handshakeErr = fmt.Errorf(\"tls: handshake message of length %d bytes exceeds maximum of %d bytes\", n, maxHandshake)\n\t\t\tbreak\n\t\t}\n\t\tif len(b) < 4+n {\n\t\t\treturn nil\n\t\t}\n\t\tif err := q.conn.handlePostHandshakeMessage(); err != nil {\n\t\t\tq.conn.handshakeErr = err\n\t\t}\n\t}\n\tif q.conn.handshakeErr != nil {\n\t\treturn quicError(q.conn.handshakeErr)\n\t}\n\treturn nil\n}\n\ntype QUICSessionTicketOptions struct {\n\t// EarlyData specifies whether the ticket may be used for 0-RTT.\n\tEarlyData bool\n\tExtra     [][]byte\n}\n\n// SendSessionTicket sends a session ticket to the client.\n// It produces connection events, which may be read with [QUICConn.NextEvent].\n// Currently, it can only be called once.\nfunc (q *QUICConn) SendSessionTicket(opts QUICSessionTicketOptions) error {\n\tc := q.conn\n\tif !c.isHandshakeComplete.Load() {\n\t\treturn quicError(errors.New(\"tls: SendSessionTicket called before handshake completed\"))\n\t}\n\tif c.isClient {\n\t\treturn quicError(errors.New(\"tls: SendSessionTicket called on the client\"))\n\t}\n\tif q.sessionTicketSent {\n\t\treturn quicError(errors.New(\"tls: SendSessionTicket called multiple times\"))\n\t}\n\tq.sessionTicketSent = true\n\treturn quicError(c.sendSessionTicket(opts.EarlyData, opts.Extra))\n}\n\n// StoreSession stores a session previously received in a QUICStoreSession event\n// in the ClientSessionCache.\n// The application may process additional events or modify the SessionState\n// before storing the session.\nfunc (q *QUICConn) StoreSession(session *SessionState) error {\n\tc := q.conn\n\tif !c.isClient {\n\t\treturn quicError(errors.New(\"tls: StoreSessionTicket called on the server\"))\n\t}\n\tcacheKey := c.clientSessionCacheKey()\n\tif cacheKey == \"\" {\n\t\treturn nil\n\t}\n\tcs := &ClientSessionState{session: session}\n\tc.config.ClientSessionCache.Put(cacheKey, cs)\n\treturn nil\n}\n\n// ConnectionState returns basic TLS details about the connection.\nfunc (q *QUICConn) ConnectionState() ConnectionState {\n\treturn q.conn.ConnectionState()\n}\n\n// SetTransportParameters sets the transport parameters to send to the peer.\n//\n// Server connections may delay setting the transport parameters until after\n// receiving the client's transport parameters. See [QUICTransportParametersRequired].\nfunc (q *QUICConn) SetTransportParameters(params []byte) {\n\tif params == nil {\n\t\tparams = []byte{}\n\t}\n\tq.conn.quic.transportParams = params\n\tif q.conn.quic.started {\n\t\t<-q.conn.quic.signalc\n\t\t<-q.conn.quic.blockedc\n\t}\n}\n\n// quicError ensures err is an AlertError.\n// If err is not already, quicError wraps it with alertInternalError.\nfunc quicError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar ae AlertError\n\tif errors.As(err, &ae) {\n\t\treturn err\n\t}\n\tvar a alert\n\tif !errors.As(err, &a) {\n\t\ta = alertInternalError\n\t}\n\t// Return an error wrapping the original error and an AlertError.\n\t// Truncate the text of the alert to 0 characters.\n\treturn fmt.Errorf(\"%w%.0w\", err, AlertError(a))\n}\n\nfunc (c *Conn) quicReadHandshakeBytes(n int) error {\n\tfor c.hand.Len() < n {\n\t\tif err := c.quicWaitForSignal(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) quicSetReadSecret(level QUICEncryptionLevel, suite uint16, secret []byte) {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind:  QUICSetReadSecret,\n\t\tLevel: level,\n\t\tSuite: suite,\n\t\tData:  secret,\n\t})\n}\n\nfunc (c *Conn) quicSetWriteSecret(level QUICEncryptionLevel, suite uint16, secret []byte) {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind:  QUICSetWriteSecret,\n\t\tLevel: level,\n\t\tSuite: suite,\n\t\tData:  secret,\n\t})\n}\n\nfunc (c *Conn) quicWriteCryptoData(level QUICEncryptionLevel, data []byte) {\n\tvar last *QUICEvent\n\tif len(c.quic.events) > 0 {\n\t\tlast = &c.quic.events[len(c.quic.events)-1]\n\t}\n\tif last == nil || last.Kind != QUICWriteData || last.Level != level {\n\t\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\t\tKind:  QUICWriteData,\n\t\t\tLevel: level,\n\t\t})\n\t\tlast = &c.quic.events[len(c.quic.events)-1]\n\t}\n\tlast.Data = append(last.Data, data...)\n}\n\nfunc (c *Conn) quicResumeSession(session *SessionState) error {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind:         QUICResumeSession,\n\t\tSessionState: session,\n\t})\n\tc.quic.waitingForDrain = true\n\tfor c.quic.waitingForDrain {\n\t\tif err := c.quicWaitForSignal(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *Conn) quicStoreSession(session *SessionState) {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind:         QUICStoreSession,\n\t\tSessionState: session,\n\t})\n}\n\nfunc (c *Conn) quicSetTransportParameters(params []byte) {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind: QUICTransportParameters,\n\t\tData: params,\n\t})\n}\n\nfunc (c *Conn) quicGetTransportParameters() ([]byte, error) {\n\tif c.quic.transportParams == nil {\n\t\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\t\tKind: QUICTransportParametersRequired,\n\t\t})\n\t}\n\tfor c.quic.transportParams == nil {\n\t\tif err := c.quicWaitForSignal(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn c.quic.transportParams, nil\n}\n\nfunc (c *Conn) quicHandshakeComplete() {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind: QUICHandshakeDone,\n\t})\n}\n\nfunc (c *Conn) quicRejectedEarlyData() {\n\tc.quic.events = append(c.quic.events, QUICEvent{\n\t\tKind: QUICRejectedEarlyData,\n\t})\n}\n\n// quicWaitForSignal notifies the QUICConn that handshake progress is blocked,\n// and waits for a signal that the handshake should proceed.\n//\n// The handshake may become blocked waiting for handshake bytes\n// or for the user to provide transport parameters.\nfunc (c *Conn) quicWaitForSignal() error {\n\t// Drop the handshake mutex while blocked to allow the user\n\t// to call ConnectionState before the handshake completes.\n\tc.handshakeMutex.Unlock()\n\tdefer c.handshakeMutex.Lock()\n\t// Send on blockedc to notify the QUICConn that the handshake is blocked.\n\t// Exported methods of QUICConn wait for the handshake to become blocked\n\t// before returning to the user.\n\tselect {\n\tcase c.quic.blockedc <- struct{}{}:\n\tcase <-c.quic.cancelc:\n\t\treturn c.sendAlertLocked(alertCloseNotify)\n\t}\n\t// The QUICConn reads from signalc to notify us that the handshake may\n\t// be able to proceed. (The QUICConn reads, because we close signalc to\n\t// indicate that the handshake has completed.)\n\tselect {\n\tcase c.quic.signalc <- struct{}{}:\n\t\tc.hand.Write(c.quic.readbuf)\n\t\tc.quic.readbuf = nil\n\tcase <-c.quic.cancelc:\n\t\treturn c.sendAlertLocked(alertCloseNotify)\n\t}\n\treturn nil\n}"
        },
        {
          "name": "ticket.go",
          "type": "blob",
          "size": 12.55859375,
          "content": "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\npackage reality\n\nimport (\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/subtle\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"io\"\n\n\t\"golang.org/x/crypto/cryptobyte\"\n)\n\n// A SessionState is a resumable session.\ntype SessionState struct {\n\t// Encoded as a SessionState (in the language of RFC 8446, Section 3).\n\t//\n\t//   enum { server(1), client(2) } SessionStateType;\n\t//\n\t//   opaque Certificate<1..2^24-1>;\n\t//\n\t//   Certificate CertificateChain<0..2^24-1>;\n\t//\n\t//   opaque Extra<0..2^24-1>;\n\t//\n\t//   struct {\n\t//       uint16 version;\n\t//       SessionStateType type;\n\t//       uint16 cipher_suite;\n\t//       uint64 created_at;\n\t//       opaque secret<1..2^8-1>;\n\t//       Extra extra<0..2^24-1>;\n\t//       uint8 ext_master_secret = { 0, 1 };\n\t//       uint8 early_data = { 0, 1 };\n\t//       CertificateEntry certificate_list<0..2^24-1>;\n\t//       CertificateChain verified_chains<0..2^24-1>; /* excluding leaf */\n\t//       select (SessionState.early_data) {\n\t//           case 0: Empty;\n\t//           case 1: opaque alpn<1..2^8-1>;\n\t//       };\n\t//       select (SessionState.type) {\n\t//           case server: Empty;\n\t//           case client: struct {\n\t//               select (SessionState.version) {\n\t//                   case VersionTLS10..VersionTLS12: Empty;\n\t//                   case VersionTLS13: struct {\n\t//                       uint64 use_by;\n\t//                       uint32 age_add;\n\t//                   };\n\t//               };\n\t//           };\n\t//       };\n\t//   } SessionState;\n\t//\n\n\t// Extra is ignored by crypto/tls, but is encoded by [SessionState.Bytes]\n\t// and parsed by [ParseSessionState].\n\t//\n\t// This allows [Config.UnwrapSession]/[Config.WrapSession] and\n\t// [ClientSessionCache] implementations to store and retrieve additional\n\t// data alongside this session.\n\t//\n\t// To allow different layers in a protocol stack to share this field,\n\t// applications must only append to it, not replace it, and must use entries\n\t// that can be recognized even if out of order (for example, by starting\n\t// with an id and version prefix).\n\tExtra [][]byte\n\n\t// EarlyData indicates whether the ticket can be used for 0-RTT in a QUIC\n\t// connection. The application may set this to false if it is true to\n\t// decline to offer 0-RTT even if supported.\n\tEarlyData bool\n\n\tversion     uint16\n\tisClient    bool\n\tcipherSuite uint16\n\t// createdAt is the generation time of the secret on the sever (which for\n\t// TLS 1.0–1.2 might be earlier than the current session) and the time at\n\t// which the ticket was received on the client.\n\tcreatedAt         uint64 // seconds since UNIX epoch\n\tsecret            []byte // master secret for TLS 1.2, or the PSK for TLS 1.3\n\textMasterSecret   bool\n\tpeerCertificates  []*x509.Certificate\n\tactiveCertHandles []*activeCert\n\tocspResponse      []byte\n\tscts              [][]byte\n\tverifiedChains [][]*x509.Certificate\n\talpnProtocol      string // only set if EarlyData is true\n\n\t// Client-side TLS 1.3-only fields.\n\tuseBy  uint64 // seconds since UNIX epoch\n\tageAdd uint32\n\tticket []byte\n}\n\n// Bytes encodes the session, including any private fields, so that it can be\n// parsed by [ParseSessionState]. The encoding contains secret values critical\n// to the security of future and possibly past sessions.\n//\n// The specific encoding should be considered opaque and may change incompatibly\n// between Go versions.\nfunc (s *SessionState) Bytes() ([]byte, error) {\n\tvar b cryptobyte.Builder\n\tb.AddUint16(s.version)\n\tif s.isClient {\n\t\tb.AddUint8(2) // client\n\t} else {\n\t\tb.AddUint8(1) // server\n\t}\n\tb.AddUint16(s.cipherSuite)\n\taddUint64(&b, s.createdAt)\n\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tb.AddBytes(s.secret)\n\t})\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tfor _, extra := range s.Extra {\n\t\t\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\tb.AddBytes(extra)\n\t\t\t})\n\t\t}\n\t})\n\tif s.extMasterSecret {\n\t\tb.AddUint8(1)\n\t} else {\n\t\tb.AddUint8(0)\n\t}\n\tif s.EarlyData {\n\t\tb.AddUint8(1)\n\t} else {\n\t\tb.AddUint8(0)\n\t}\n\tmarshalCertificate(&b, Certificate{\n\t\tCertificate:                 certificatesToBytesSlice(s.peerCertificates),\n\t\tOCSPStaple:                  s.ocspResponse,\n\t\tSignedCertificateTimestamps: s.scts,\n\t})\n\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\tfor _, chain := range s.verifiedChains {\n\t\t\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t// We elide the first certificate because it's always the leaf.\n\t\t\t\tif len(chain) == 0 {\n\t\t\t\t\tb.SetError(errors.New(\"tls: internal error: empty verified chain\"))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor _, cert := range chain[1:] {\n\t\t\t\t\tb.AddUint24LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\t\t\t\tb.AddBytes(cert.Raw)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\tif s.EarlyData {\n\t\tb.AddUint8LengthPrefixed(func(b *cryptobyte.Builder) {\n\t\t\tb.AddBytes([]byte(s.alpnProtocol))\n\t\t})\n\t}\n\tif s.isClient {\n\t\tif s.version >= VersionTLS13 {\n\t\t\taddUint64(&b, s.useBy)\n\t\t\tb.AddUint32(s.ageAdd)\n\t\t}\n\t}\n\treturn b.Bytes()\n}\n\nfunc certificatesToBytesSlice(certs []*x509.Certificate) [][]byte {\n\ts := make([][]byte, 0, len(certs))\n\tfor _, c := range certs {\n\t\ts = append(s, c.Raw)\n\t}\n\treturn s\n}\n\n// ParseSessionState parses a [SessionState] encoded by [SessionState.Bytes].\nfunc ParseSessionState(data []byte) (*SessionState, error) {\n\tss := &SessionState{}\n\ts := cryptobyte.String(data)\n\tvar typ, extMasterSecret, earlyData uint8\n\tvar cert Certificate\n\tvar extra cryptobyte.String\n\tif !s.ReadUint16(&ss.version) ||\n\t\t!s.ReadUint8(&typ) ||\n\t\t(typ != 1 && typ != 2) ||\n\t\t!s.ReadUint16(&ss.cipherSuite) ||\n\t\t!readUint64(&s, &ss.createdAt) ||\n\t\t!readUint8LengthPrefixed(&s, &ss.secret) ||\n\t\t!s.ReadUint24LengthPrefixed(&extra) ||\n\t\t!s.ReadUint8(&extMasterSecret) ||\n\t\t!s.ReadUint8(&earlyData) ||\n\t\tlen(ss.secret) == 0 ||\n\t\t!unmarshalCertificate(&s, &cert) {\n\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t}\n\tfor !extra.Empty() {\n\t\tvar e []byte\n\t\tif !readUint24LengthPrefixed(&extra, &e) {\n\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t}\n\t\tss.Extra = append(ss.Extra, e)\n\t}\n\tswitch extMasterSecret {\n\tcase 0:\n\t\tss.extMasterSecret = false\n\tcase 1:\n\t\tss.extMasterSecret = true\n\tdefault:\n\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t}\n\tswitch earlyData {\n\tcase 0:\n\t\tss.EarlyData = false\n\tcase 1:\n\t\tss.EarlyData = true\n\tdefault:\n\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t}\n\tfor _, cert := range cert.Certificate {\n\t\tc, err := globalCertCache.newCert(cert)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tss.activeCertHandles = append(ss.activeCertHandles, c)\n\t\tss.peerCertificates = append(ss.peerCertificates, c.cert)\n\t}\n\tss.ocspResponse = cert.OCSPStaple\n\tss.scts = cert.SignedCertificateTimestamps\n\tvar chainList cryptobyte.String\n\tif !s.ReadUint24LengthPrefixed(&chainList) {\n\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t}\n\tfor !chainList.Empty() {\n\t\tvar certList cryptobyte.String\n\t\tif !chainList.ReadUint24LengthPrefixed(&certList) {\n\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t}\n\t\tvar chain []*x509.Certificate\n\t\tif len(ss.peerCertificates) == 0 {\n\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t}\n\t\tchain = append(chain, ss.peerCertificates[0])\n\t\tfor !certList.Empty() {\n\t\t\tvar cert []byte\n\t\t\tif !readUint24LengthPrefixed(&certList, &cert) {\n\t\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t\t}\n\t\t\tc, err := globalCertCache.newCert(cert)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tss.activeCertHandles = append(ss.activeCertHandles, c)\n\t\t\tchain = append(chain, c.cert)\n\t\t}\n\t\tss.verifiedChains = append(ss.verifiedChains, chain)\n\t}\n\tif ss.EarlyData {\n\t\tvar alpn []byte\n\t\tif !readUint8LengthPrefixed(&s, &alpn) {\n\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t}\n\t\tss.alpnProtocol = string(alpn)\n\t}\n\tif isClient := typ == 2; !isClient {\n\t\tif !s.Empty() {\n\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t}\n\t\treturn ss, nil\n\t}\n\tss.isClient = true\n\tif len(ss.peerCertificates) == 0 {\n\t\treturn nil, errors.New(\"tls: no server certificates in client session\")\n\t}\n\tif ss.version < VersionTLS13 {\n\t\tif !s.Empty() {\n\t\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t\t}\n\t\treturn ss, nil\n\t}\n\tif !s.ReadUint64(&ss.useBy) || !s.ReadUint32(&ss.ageAdd) || !s.Empty() {\n\t\treturn nil, errors.New(\"tls: invalid session encoding\")\n\t}\n\treturn ss, nil\n}\n\n// sessionState returns a partially filled-out [SessionState] with information\n// from the current connection.\nfunc (c *Conn) sessionState() *SessionState {\n\treturn &SessionState{\n\t\tversion:           c.vers,\n\t\tcipherSuite:       c.cipherSuite,\n\t\tcreatedAt:         uint64(c.config.time().Unix()),\n\t\talpnProtocol:      c.clientProtocol,\n\t\tpeerCertificates:  c.peerCertificates,\n\t\tactiveCertHandles: c.activeCertHandles,\n\t\tocspResponse:      c.ocspResponse,\n\t\tscts:              c.scts,\n\t\tisClient:          c.isClient,\n\t\textMasterSecret:   c.extMasterSecret,\n\t\tverifiedChains:    c.verifiedChains,\n\t}\n}\n\n// EncryptTicket encrypts a ticket with the [Config]'s configured (or default)\n// session ticket keys. It can be used as a [Config.WrapSession] implementation.\nfunc (c *Config) EncryptTicket(cs ConnectionState, ss *SessionState) ([]byte, error) {\n\tticketKeys := c.ticketKeys(nil)\n\tstateBytes, err := ss.Bytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.encryptTicket(stateBytes, ticketKeys)\n}\n\nfunc (c *Config) encryptTicket(state []byte, ticketKeys []ticketKey) ([]byte, error) {\n\tif len(ticketKeys) == 0 {\n\t\treturn nil, errors.New(\"tls: internal error: session ticket keys unavailable\")\n\t}\n\n\tencrypted := make([]byte, aes.BlockSize+len(state)+sha256.Size)\n\tiv := encrypted[:aes.BlockSize]\n\tciphertext := encrypted[aes.BlockSize : len(encrypted)-sha256.Size]\n\tauthenticated := encrypted[:len(encrypted)-sha256.Size]\n\tmacBytes := encrypted[len(encrypted)-sha256.Size:]\n\n\tif _, err := io.ReadFull(c.rand(), iv); err != nil {\n\t\treturn nil, err\n\t}\n\tkey := ticketKeys[0]\n\tblock, err := aes.NewCipher(key.aesKey[:])\n\tif err != nil {\n\t\treturn nil, errors.New(\"tls: failed to create cipher while encrypting ticket: \" + err.Error())\n\t}\n\tcipher.NewCTR(block, iv).XORKeyStream(ciphertext, state)\n\n\tmac := hmac.New(sha256.New, key.hmacKey[:])\n\tmac.Write(authenticated)\n\tmac.Sum(macBytes[:0])\n\n\treturn encrypted, nil\n}\n\n// DecryptTicket decrypts a ticket encrypted by [Config.EncryptTicket]. It can\n// be used as a [Config.UnwrapSession] implementation.\n//\n// If the ticket can't be decrypted or parsed, DecryptTicket returns (nil, nil).\nfunc (c *Config) DecryptTicket(identity []byte, cs ConnectionState) (*SessionState, error) {\n\tticketKeys := c.ticketKeys(nil)\n\tstateBytes := c.decryptTicket(identity, ticketKeys)\n\tif stateBytes == nil {\n\t\treturn nil, nil\n\t}\n\ts, err := ParseSessionState(stateBytes)\n\tif err != nil {\n\t\treturn nil, nil // drop unparsable tickets on the floor\n\t}\n\treturn s, nil\n}\n\nfunc (c *Config) decryptTicket(encrypted []byte, ticketKeys []ticketKey) []byte {\n\tif len(encrypted) < aes.BlockSize+sha256.Size {\n\t\treturn nil\n\t}\n\n\tiv := encrypted[:aes.BlockSize]\n\tciphertext := encrypted[aes.BlockSize : len(encrypted)-sha256.Size]\n\tauthenticated := encrypted[:len(encrypted)-sha256.Size]\n\tmacBytes := encrypted[len(encrypted)-sha256.Size:]\n\tfor _, key := range ticketKeys {\n\t\tmac := hmac.New(sha256.New, key.hmacKey[:])\n\t\tmac.Write(authenticated)\n\t\texpected := mac.Sum(nil)\n\n\t\tif subtle.ConstantTimeCompare(macBytes, expected) != 1 {\n\t\t\tcontinue\n\t\t}\n\n\t\tblock, err := aes.NewCipher(key.aesKey[:])\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\t\tplaintext := make([]byte, len(ciphertext))\n\t\tcipher.NewCTR(block, iv).XORKeyStream(plaintext, ciphertext)\n\n\t\treturn plaintext\n\t}\n\n\treturn nil\n}\n\n// ClientSessionState contains the state needed by a client to\n// resume a previous TLS session.\ntype ClientSessionState struct {\n\tsession *SessionState\n}\n\n// ResumptionState returns the session ticket sent by the server (also known as\n// the session's identity) and the state necessary to resume this session.\n//\n// It can be called by [ClientSessionCache.Put] to serialize (with\n// [SessionState.Bytes]) and store the session.\nfunc (cs *ClientSessionState) ResumptionState() (ticket []byte, state *SessionState, err error) {\n\tif cs == nil || cs.session == nil {\n\t\treturn nil, nil, nil\n\t}\n\treturn cs.session.ticket, cs.session, nil\n}\n\n// NewResumptionState returns a state value that can be returned by\n// [ClientSessionCache.Get] to resume a previous session.\n//\n// state needs to be returned by [ParseSessionState], and the ticket and session\n// state must have been returned by [ClientSessionState.ResumptionState].\nfunc NewResumptionState(ticket []byte, state *SessionState) (*ClientSessionState, error) {\n\tstate.ticket = ticket\n\treturn &ClientSessionState{\n\t\tsession: state,\n\t}, nil\n}\n"
        },
        {
          "name": "tls.go",
          "type": "blob",
          "size": 21.728515625,
          "content": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE-Go file.\n\n// Server side implementation of REALITY protocol, a fork of package tls in Go 1.20.\n// For client side, please follow https://github.com/XTLS/Xray-core/blob/main/transport/internet/reality/reality.go.\npackage reality\n\n// BUG(agl): The crypto/tls package only implements some countermeasures\n// against Lucky13 attacks on CBC-mode encryption, and only on SHA1\n// variants. See http://www.isg.rhul.ac.uk/tls/TLStiming.pdf and\n// https://www.imperialviolet.org/2013/02/04/luckythirteen.html.\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/aes\"\n\t\"crypto/cipher\"\n\t\"crypto/ecdsa\"\n\t\"crypto/ed25519\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/binary\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pires/go-proxyproto\"\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\t\"golang.org/x/crypto/curve25519\"\n\t\"golang.org/x/crypto/hkdf\"\n)\n\ntype CloseWriteConn interface {\n\tnet.Conn\n\tCloseWrite() error\n}\n\ntype MirrorConn struct {\n\t*sync.Mutex\n\tnet.Conn\n\tTarget net.Conn\n}\n\nfunc (c *MirrorConn) Read(b []byte) (int, error) {\n\tc.Unlock()\n\truntime.Gosched()\n\tn, err := c.Conn.Read(b)\n\tc.Lock() // calling c.Lock() before c.Target.Write(), to make sure that this goroutine has the priority to make the next move\n\tif n != 0 {\n\t\tc.Target.Write(b[:n])\n\t}\n\tif err != nil {\n\t\tc.Target.Close()\n\t}\n\treturn n, err\n}\n\nfunc (c *MirrorConn) Write(b []byte) (int, error) {\n\treturn 0, fmt.Errorf(\"Write(%v)\", len(b))\n}\n\nfunc (c *MirrorConn) Close() error {\n\treturn fmt.Errorf(\"Close()\")\n}\n\nfunc (c *MirrorConn) SetDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (c *MirrorConn) SetReadDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (c *MirrorConn) SetWriteDeadline(t time.Time) error {\n\treturn nil\n}\n\nvar (\n\tsize  = 8192\n\tempty = make([]byte, size)\n\ttypes = [7]string{\n\t\t\"Server Hello\",\n\t\t\"Change Cipher Spec\",\n\t\t\"Encrypted Extensions\",\n\t\t\"Certificate\",\n\t\t\"Certificate Verify\",\n\t\t\"Finished\",\n\t\t\"New Session Ticket\",\n\t}\n)\n\nfunc Value(vals ...byte) (value int) {\n\tfor i, val := range vals {\n\t\tvalue |= int(val) << ((len(vals) - i - 1) * 8)\n\t}\n\treturn\n}\n\n// Server returns a new TLS server side connection\n// using conn as the underlying transport.\n// The configuration config must be non-nil and must include\n// at least one certificate or else set GetCertificate.\nfunc Server(ctx context.Context, conn net.Conn, config *Config) (*Conn, error) {\n\tremoteAddr := conn.RemoteAddr().String()\n\tif config.Show {\n\t\tfmt.Printf(\"REALITY remoteAddr: %v\\n\", remoteAddr)\n\t}\n\n\ttarget, err := config.DialContext(ctx, config.Type, config.Dest)\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, errors.New(\"REALITY: failed to dial dest: \" + err.Error())\n\t}\n\n\tif config.Xver == 1 || config.Xver == 2 {\n\t\tif _, err = proxyproto.HeaderProxyFromAddrs(config.Xver, conn.RemoteAddr(), conn.LocalAddr()).WriteTo(target); err != nil {\n\t\t\ttarget.Close()\n\t\t\tconn.Close()\n\t\t\treturn nil, errors.New(\"REALITY: failed to send PROXY protocol: \" + err.Error())\n\t\t}\n\t}\n\n\traw := conn\n\tif pc, ok := conn.(*proxyproto.Conn); ok {\n\t\traw = pc.Raw() // for TCP splicing in io.Copy()\n\t}\n\tunderlying := raw.(CloseWriteConn) // *net.TCPConn or *net.UnixConn\n\n\tmutex := new(sync.Mutex)\n\n\ths := serverHandshakeStateTLS13{\n\t\tc: &Conn{\n\t\t\tconn: &MirrorConn{\n\t\t\t\tMutex:  mutex,\n\t\t\t\tConn:   conn,\n\t\t\t\tTarget: target,\n\t\t\t},\n\t\t\tconfig: config,\n\t\t},\n\t\tctx: context.Background(),\n\t}\n\n\tcopying := false\n\n\twaitGroup := new(sync.WaitGroup)\n\twaitGroup.Add(2)\n\n\tgo func() {\n\t\tfor {\n\t\t\tmutex.Lock()\n\t\t\ths.clientHello, err = hs.c.readClientHello(context.Background()) // TODO: Change some rules in this function.\n\t\t\tif copying || err != nil || hs.c.vers != VersionTLS13 || !config.ServerNames[hs.clientHello.serverName] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfor i, keyShare := range hs.clientHello.keyShares {\n\t\t\t\tif keyShare.group != X25519 || len(keyShare.data) != 32 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif hs.c.AuthKey, err = curve25519.X25519(config.PrivateKey, keyShare.data); err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif _, err = hkdf.New(sha256.New, hs.c.AuthKey, hs.clientHello.random[:20], []byte(\"REALITY\")).Read(hs.c.AuthKey); err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tvar aead cipher.AEAD\n\t\t\t\tif aesgcmPreferred(hs.clientHello.cipherSuites) {\n\t\t\t\t\tblock, _ := aes.NewCipher(hs.c.AuthKey)\n\t\t\t\t\taead, _ = cipher.NewGCM(block)\n\t\t\t\t} else {\n\t\t\t\t\taead, _ = chacha20poly1305.New(hs.c.AuthKey)\n\t\t\t\t}\n\t\t\t\tif config.Show {\n\t\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.c.AuthKey[:16]: %v\\tAEAD: %T\\n\", remoteAddr, hs.c.AuthKey[:16], aead)\n\t\t\t\t}\n\t\t\t\tciphertext := make([]byte, 32)\n\t\t\t\tplainText := make([]byte, 32)\n\t\t\t\tcopy(ciphertext, hs.clientHello.sessionId)\n\t\t\t\tcopy(hs.clientHello.sessionId, plainText) // hs.clientHello.sessionId points to hs.clientHello.raw[39:]\n\t\t\t\tif _, err = aead.Open(plainText[:0], hs.clientHello.random[20:], ciphertext, hs.clientHello.original); err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcopy(hs.clientHello.sessionId, ciphertext)\n\t\t\t\tcopy(hs.c.ClientVer[:], plainText)\n\t\t\t\ths.c.ClientTime = time.Unix(int64(binary.BigEndian.Uint32(plainText[4:])), 0)\n\t\t\t\tcopy(hs.c.ClientShortId[:], plainText[8:])\n\t\t\t\tif config.Show {\n\t\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.c.ClientVer: %v\\n\", remoteAddr, hs.c.ClientVer)\n\t\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.c.ClientTime: %v\\n\", remoteAddr, hs.c.ClientTime)\n\t\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.c.ClientShortId: %v\\n\", remoteAddr, hs.c.ClientShortId)\n\t\t\t\t}\n\t\t\t\tif (config.MinClientVer == nil || Value(hs.c.ClientVer[:]...) >= Value(config.MinClientVer...)) &&\n\t\t\t\t\t(config.MaxClientVer == nil || Value(hs.c.ClientVer[:]...) <= Value(config.MaxClientVer...)) &&\n\t\t\t\t\t(config.MaxTimeDiff == 0 || time.Since(hs.c.ClientTime).Abs() <= config.MaxTimeDiff) &&\n\t\t\t\t\t(config.ShortIds[hs.c.ClientShortId]) {\n\t\t\t\t\ths.c.conn = conn\n\t\t\t\t}\n\t\t\t\ths.clientHello.keyShares[0].group = CurveID(i)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif config.Show {\n\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.c.conn == conn: %v\\n\", remoteAddr, hs.c.conn == conn)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tmutex.Unlock()\n\t\tif hs.c.conn != conn {\n\t\t\tif config.Show && hs.clientHello != nil {\n\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\tforwarded SNI: %v\\n\", remoteAddr, hs.clientHello.serverName)\n\t\t\t}\n\t\t\tio.Copy(target, underlying)\n\t\t}\n\t\twaitGroup.Done()\n\t}()\n\n\tgo func() {\n\t\ts2cSaved := make([]byte, 0, size)\n\t\tbuf := make([]byte, size)\n\t\thandshakeLen := 0\n\tf:\n\t\tfor {\n\t\t\truntime.Gosched()\n\t\t\tn, err := target.Read(buf)\n\t\t\tif n == 0 {\n\t\t\t\tif err != nil {\n\t\t\t\t\tconn.Close()\n\t\t\t\t\twaitGroup.Done()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tmutex.Lock()\n\t\t\ts2cSaved = append(s2cSaved, buf[:n]...)\n\t\t\tif hs.c.conn != conn {\n\t\t\t\tcopying = true // if the target already sent some data, just start bidirectional direct forwarding\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif len(s2cSaved) > size {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfor i, t := range types {\n\t\t\t\tif hs.c.out.handshakeLen[i] != 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif i == 6 && len(s2cSaved) == 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif handshakeLen == 0 && len(s2cSaved) > recordHeaderLen {\n\t\t\t\t\tif Value(s2cSaved[1:3]...) != VersionTLS12 ||\n\t\t\t\t\t\t(i == 0 && (recordType(s2cSaved[0]) != recordTypeHandshake || s2cSaved[5] != typeServerHello)) ||\n\t\t\t\t\t\t(i == 1 && (recordType(s2cSaved[0]) != recordTypeChangeCipherSpec || s2cSaved[5] != 1)) ||\n\t\t\t\t\t\t(i > 1 && recordType(s2cSaved[0]) != recordTypeApplicationData) {\n\t\t\t\t\t\tbreak f\n\t\t\t\t\t}\n\t\t\t\t\thandshakeLen = recordHeaderLen + Value(s2cSaved[3:5]...)\n\t\t\t\t}\n\t\t\t\tif config.Show {\n\t\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\tlen(s2cSaved): %v\\t%v: %v\\n\", remoteAddr, len(s2cSaved), t, handshakeLen)\n\t\t\t\t}\n\t\t\t\tif handshakeLen > size { // too long\n\t\t\t\t\tbreak f\n\t\t\t\t}\n\t\t\t\tif i == 1 && handshakeLen > 0 && handshakeLen != 6 {\n\t\t\t\t\tbreak f\n\t\t\t\t}\n\t\t\t\tif i == 2 && handshakeLen > 512 {\n\t\t\t\t\ths.c.out.handshakeLen[i] = handshakeLen\n\t\t\t\t\ths.c.out.handshakeBuf = buf[:0]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif i == 6 && handshakeLen > 0 {\n\t\t\t\t\ths.c.out.handshakeLen[i] = handshakeLen\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif handshakeLen == 0 || len(s2cSaved) < handshakeLen {\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\tcontinue f\n\t\t\t\t}\n\t\t\t\tif i == 0 {\n\t\t\t\t\ths.hello = new(serverHelloMsg)\n\t\t\t\t\tif !hs.hello.unmarshal(s2cSaved[recordHeaderLen:handshakeLen]) ||\n\t\t\t\t\t\ths.hello.vers != VersionTLS12 || hs.hello.supportedVersion != VersionTLS13 ||\n\t\t\t\t\t\tcipherSuiteTLS13ByID(hs.hello.cipherSuite) == nil ||\n\t\t\t\t\t\ths.hello.serverShare.group != X25519 || len(hs.hello.serverShare.data) != 32 {\n\t\t\t\t\t\tbreak f\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ths.c.out.handshakeLen[i] = handshakeLen\n\t\t\t\ts2cSaved = s2cSaved[handshakeLen:]\n\t\t\t\thandshakeLen = 0\n\t\t\t}\n\t\t\tstart := time.Now()\n\t\t\terr = hs.handshake()\n\t\t\tif config.Show {\n\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.handshake() err: %v\\n\", remoteAddr, err)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tgo func() { // TODO: Probe target's maxUselessRecords and some time-outs in advance.\n\t\t\t\tif handshakeLen-len(s2cSaved) > 0 {\n\t\t\t\t\tio.ReadFull(target, buf[:handshakeLen-len(s2cSaved)])\n\t\t\t\t}\n\t\t\t\tif n, err := target.Read(buf); !hs.c.isHandshakeComplete.Load() {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tconn.Close()\n\t\t\t\t\t}\n\t\t\t\t\tif config.Show {\n\t\t\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ttime.Since(start): %v\\tn: %v\\terr: %v\\n\", remoteAddr, time.Since(start), n, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t\terr = hs.readClientFinished()\n\t\t\tif config.Show {\n\t\t\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.readClientFinished() err: %v\\n\", remoteAddr, err)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ths.c.isHandshakeComplete.Store(true)\n\t\t\tbreak\n\t\t}\n\t\tmutex.Unlock()\n\t\tif hs.c.out.handshakeLen[0] == 0 { // if the target sent an incorrect Server Hello, or before that\n\t\t\tif hs.c.conn == conn { // if we processed the Client Hello successfully but the target did not\n\t\t\t\twaitGroup.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\tio.Copy(target, underlying)\n\t\t\t\t\twaitGroup.Done()\n\t\t\t\t}()\n\t\t\t}\n\t\t\tconn.Write(s2cSaved)\n\t\t\tio.Copy(underlying, target)\n\t\t\t// Here is bidirectional direct forwarding:\n\t\t\t// client ---underlying--- server ---target--- dest\n\t\t\t// Call `underlying.CloseWrite()` once `io.Copy()` returned\n\t\t\tunderlying.CloseWrite()\n\t\t}\n\t\twaitGroup.Done()\n\t}()\n\n\twaitGroup.Wait()\n\ttarget.Close()\n\tif config.Show {\n\t\tfmt.Printf(\"REALITY remoteAddr: %v\\ths.c.handshakeStatus: %v\\n\", remoteAddr, hs.c.isHandshakeComplete.Load())\n\t}\n\tif hs.c.isHandshakeComplete.Load() {\n\t\treturn hs.c, nil\n\t}\n\tconn.Close()\n\treturn nil, errors.New(\"REALITY: processed invalid connection\") // TODO: Add details.\n\n\t/*\n\t\tc := &Conn{\n\t\t\tconn:   conn,\n\t\t\tconfig: config,\n\t\t}\n\t\tc.handshakeFn = c.serverHandshake\n\t\treturn c\n\t*/\n}\n\n// Client returns a new TLS client side connection\n// using conn as the underlying transport.\n// The config cannot be nil: users must set either ServerName or\n// InsecureSkipVerify in the config.\nfunc Client(conn net.Conn, config *Config) *Conn {\n\tc := &Conn{\n\t\tconn:     conn,\n\t\tconfig:   config,\n\t\tisClient: true,\n\t}\n\tc.handshakeFn = c.clientHandshake\n\treturn c\n}\n\n// A listener implements a network listener (net.Listener) for TLS connections.\ntype listener struct {\n\tnet.Listener\n\tconfig *Config\n\tconns  chan net.Conn\n\terr    error\n}\n\n// Accept waits for and returns the next incoming TLS connection.\n// The returned connection is of type *Conn.\nfunc (l *listener) Accept() (net.Conn, error) {\n\t/*\n\t\tc, err := l.Listener.Accept()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn Server(c, l.config), nil\n\t*/\n\tif c, ok := <-l.conns; ok {\n\t\treturn c, nil\n\t}\n\treturn nil, l.err\n}\n\n// NewListener creates a Listener which accepts connections from an inner\n// Listener and wraps each connection with [Server].\n// The configuration config must be non-nil and must include\n// at least one certificate or else set GetCertificate.\nfunc NewListener(inner net.Listener, config *Config) net.Listener {\n\tl := new(listener)\n\tl.Listener = inner\n\tl.config = config\n\t{\n\t\tl.conns = make(chan net.Conn)\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tc, err := l.Listener.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\tl.err = err\n\t\t\t\t\tclose(l.conns)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer recover()\n\t\t\t\t\tc, err = Server(context.Background(), c, l.config)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tl.conns <- c\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t}()\n\t}\n\treturn l\n}\n\n// Listen creates a TLS listener accepting connections on the\n// given network address using net.Listen.\n// The configuration config must be non-nil and must include\n// at least one certificate or else set GetCertificate.\nfunc Listen(network, laddr string, config *Config) (net.Listener, error) {\n\t// If this condition changes, consider updating http.Server.ServeTLS too.\n\tif config == nil || len(config.Certificates) == 0 &&\n\t\tconfig.GetCertificate == nil && config.GetConfigForClient == nil {\n\t\treturn nil, errors.New(\"tls: neither Certificates, GetCertificate, nor GetConfigForClient set in Config\")\n\t}\n\tl, err := net.Listen(network, laddr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewListener(l, config), nil\n}\n\ntype timeoutError struct{}\n\nfunc (timeoutError) Error() string   { return \"tls: DialWithDialer timed out\" }\nfunc (timeoutError) Timeout() bool   { return true }\nfunc (timeoutError) Temporary() bool { return true }\n\n// DialWithDialer connects to the given network address using dialer.Dial and\n// then initiates a TLS handshake, returning the resulting TLS connection. Any\n// timeout or deadline given in the dialer apply to connection and TLS\n// handshake as a whole.\n//\n// DialWithDialer interprets a nil configuration as equivalent to the zero\n// configuration; see the documentation of [Config] for the defaults.\n//\n// DialWithDialer uses context.Background internally; to specify the context,\n// use [Dialer.DialContext] with NetDialer set to the desired dialer.\nfunc DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error) {\n\treturn dial(context.Background(), dialer, network, addr, config)\n}\n\nfunc dial(ctx context.Context, netDialer *net.Dialer, network, addr string, config *Config) (*Conn, error) {\n\tif netDialer.Timeout != 0 {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithTimeout(ctx, netDialer.Timeout)\n\t\tdefer cancel()\n\t}\n\n\tif !netDialer.Deadline.IsZero() {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithDeadline(ctx, netDialer.Deadline)\n\t\tdefer cancel()\n\t}\n\n\trawConn, err := netDialer.DialContext(ctx, network, addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcolonPos := strings.LastIndex(addr, \":\")\n\tif colonPos == -1 {\n\t\tcolonPos = len(addr)\n\t}\n\thostname := addr[:colonPos]\n\n\tif config == nil {\n\t\tconfig = defaultConfig()\n\t}\n\t// If no ServerName is set, infer the ServerName\n\t// from the hostname we're connecting to.\n\tif config.ServerName == \"\" {\n\t\t// Make a copy to avoid polluting argument or default.\n\t\tc := config.Clone()\n\t\tc.ServerName = hostname\n\t\tconfig = c\n\t}\n\n\tconn := Client(rawConn, config)\n\tif err := conn.HandshakeContext(ctx); err != nil {\n\t\trawConn.Close()\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\n// Dial connects to the given network address using net.Dial\n// and then initiates a TLS handshake, returning the resulting\n// TLS connection.\n// Dial interprets a nil configuration as equivalent to\n// the zero configuration; see the documentation of Config\n// for the defaults.\nfunc Dial(network, addr string, config *Config) (*Conn, error) {\n\treturn DialWithDialer(new(net.Dialer), network, addr, config)\n}\n\n// Dialer dials TLS connections given a configuration and a Dialer for the\n// underlying connection.\ntype Dialer struct {\n\t// NetDialer is the optional dialer to use for the TLS connections'\n\t// underlying TCP connections.\n\t// A nil NetDialer is equivalent to the net.Dialer zero value.\n\tNetDialer *net.Dialer\n\n\t// Config is the TLS configuration to use for new connections.\n\t// A nil configuration is equivalent to the zero\n\t// configuration; see the documentation of Config for the\n\t// defaults.\n\tConfig *Config\n}\n\n// Dial connects to the given network address and initiates a TLS\n// handshake, returning the resulting TLS connection.\n//\n// The returned [Conn], if any, will always be of type *[Conn].\n//\n// Dial uses context.Background internally; to specify the context,\n// use [Dialer.DialContext].\nfunc (d *Dialer) Dial(network, addr string) (net.Conn, error) {\n\treturn d.DialContext(context.Background(), network, addr)\n}\n\nfunc (d *Dialer) netDialer() *net.Dialer {\n\tif d.NetDialer != nil {\n\t\treturn d.NetDialer\n\t}\n\treturn new(net.Dialer)\n}\n\n// DialContext connects to the given network address and initiates a TLS\n// handshake, returning the resulting TLS connection.\n//\n// The provided Context must be non-nil. If the context expires before\n// the connection is complete, an error is returned. Once successfully\n// connected, any expiration of the context will not affect the\n// connection.\n//\n// The returned [Conn], if any, will always be of type *[Conn].\nfunc (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error) {\n\tc, err := dial(ctx, d.netDialer(), network, addr, d.Config)\n\tif err != nil {\n\t\t// Don't return c (a typed nil) in an interface.\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\n// LoadX509KeyPair reads and parses a public/private key pair from a pair of\n// files. The files must contain PEM encoded data. The certificate file may\n// contain intermediate certificates following the leaf certificate to form a\n// certificate chain. On successful return, Certificate.Leaf will be populated.\n//\n// Before Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was\n// discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\"\n// in the GODEBUG environment variable.\nfunc LoadX509KeyPair(certFile, keyFile string) (Certificate, error) {\n\tcertPEMBlock, err := os.ReadFile(certFile)\n\tif err != nil {\n\t\treturn Certificate{}, err\n\t}\n\tkeyPEMBlock, err := os.ReadFile(keyFile)\n\tif err != nil {\n\t\treturn Certificate{}, err\n\t}\n\treturn X509KeyPair(certPEMBlock, keyPEMBlock)\n}\n\n// X509KeyPair parses a public/private key pair from a pair of\n// PEM encoded data. On successful return, Certificate.Leaf will be populated.\n//\n// Before Go 1.23 Certificate.Leaf was left nil, and the parsed certificate was\n// discarded. This behavior can be re-enabled by setting \"x509keypairleaf=0\"\n// in the GODEBUG environment variable.\nfunc X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error) {\n\tfail := func(err error) (Certificate, error) { return Certificate{}, err }\n\n\tvar cert Certificate\n\tvar skippedBlockTypes []string\n\tfor {\n\t\tvar certDERBlock *pem.Block\n\t\tcertDERBlock, certPEMBlock = pem.Decode(certPEMBlock)\n\t\tif certDERBlock == nil {\n\t\t\tbreak\n\t\t}\n\t\tif certDERBlock.Type == \"CERTIFICATE\" {\n\t\t\tcert.Certificate = append(cert.Certificate, certDERBlock.Bytes)\n\t\t} else {\n\t\t\tskippedBlockTypes = append(skippedBlockTypes, certDERBlock.Type)\n\t\t}\n\t}\n\n\tif len(cert.Certificate) == 0 {\n\t\tif len(skippedBlockTypes) == 0 {\n\t\t\treturn fail(errors.New(\"tls: failed to find any PEM data in certificate input\"))\n\t\t}\n\t\tif len(skippedBlockTypes) == 1 && strings.HasSuffix(skippedBlockTypes[0], \"PRIVATE KEY\") {\n\t\t\treturn fail(errors.New(\"tls: failed to find certificate PEM data in certificate input, but did find a private key; PEM inputs may have been switched\"))\n\t\t}\n\t\treturn fail(fmt.Errorf(\"tls: failed to find \\\"CERTIFICATE\\\" PEM block in certificate input after skipping PEM blocks of the following types: %v\", skippedBlockTypes))\n\t}\n\n\tskippedBlockTypes = skippedBlockTypes[:0]\n\tvar keyDERBlock *pem.Block\n\tfor {\n\t\tkeyDERBlock, keyPEMBlock = pem.Decode(keyPEMBlock)\n\t\tif keyDERBlock == nil {\n\t\t\tif len(skippedBlockTypes) == 0 {\n\t\t\t\treturn fail(errors.New(\"tls: failed to find any PEM data in key input\"))\n\t\t\t}\n\t\t\tif len(skippedBlockTypes) == 1 && skippedBlockTypes[0] == \"CERTIFICATE\" {\n\t\t\t\treturn fail(errors.New(\"tls: found a certificate rather than a key in the PEM for the private key\"))\n\t\t\t}\n\t\t\treturn fail(fmt.Errorf(\"tls: failed to find PEM block with type ending in \\\"PRIVATE KEY\\\" in key input after skipping PEM blocks of the following types: %v\", skippedBlockTypes))\n\t\t}\n\t\tif keyDERBlock.Type == \"PRIVATE KEY\" || strings.HasSuffix(keyDERBlock.Type, \" PRIVATE KEY\") {\n\t\t\tbreak\n\t\t}\n\t\tskippedBlockTypes = append(skippedBlockTypes, keyDERBlock.Type)\n\t}\n\n\t// We don't need to parse the public key for TLS, but we so do anyway\n\t// to check that it looks sane and matches the private key.\n\tx509Cert, err := x509.ParseCertificate(cert.Certificate[0])\n\tif err != nil {\n\t\treturn fail(err)\n\t}\n\n\tcert.Leaf = x509Cert\n\n\tcert.PrivateKey, err = parsePrivateKey(keyDERBlock.Bytes)\n\tif err != nil {\n\t\treturn fail(err)\n\t}\n\n\tswitch pub := x509Cert.PublicKey.(type) {\n\tcase *rsa.PublicKey:\n\t\tpriv, ok := cert.PrivateKey.(*rsa.PrivateKey)\n\t\tif !ok {\n\t\t\treturn fail(errors.New(\"tls: private key type does not match public key type\"))\n\t\t}\n\t\tif pub.N.Cmp(priv.N) != 0 {\n\t\t\treturn fail(errors.New(\"tls: private key does not match public key\"))\n\t\t}\n\tcase *ecdsa.PublicKey:\n\t\tpriv, ok := cert.PrivateKey.(*ecdsa.PrivateKey)\n\t\tif !ok {\n\t\t\treturn fail(errors.New(\"tls: private key type does not match public key type\"))\n\t\t}\n\t\tif pub.X.Cmp(priv.X) != 0 || pub.Y.Cmp(priv.Y) != 0 {\n\t\t\treturn fail(errors.New(\"tls: private key does not match public key\"))\n\t\t}\n\tcase ed25519.PublicKey:\n\t\tpriv, ok := cert.PrivateKey.(ed25519.PrivateKey)\n\t\tif !ok {\n\t\t\treturn fail(errors.New(\"tls: private key type does not match public key type\"))\n\t\t}\n\t\tif !bytes.Equal(priv.Public().(ed25519.PublicKey), pub) {\n\t\t\treturn fail(errors.New(\"tls: private key does not match public key\"))\n\t\t}\n\tdefault:\n\t\treturn fail(errors.New(\"tls: unknown public key algorithm\"))\n\t}\n\n\treturn cert, nil\n}\n\n// Attempt to parse the given private key DER block. OpenSSL 0.9.8 generates\n// PKCS #1 private keys by default, while OpenSSL 1.0.0 generates PKCS #8 keys.\n// OpenSSL ecparam generates SEC1 EC private keys for ECDSA. We try all three.\nfunc parsePrivateKey(der []byte) (crypto.PrivateKey, error) {\n\tif key, err := x509.ParsePKCS1PrivateKey(der); err == nil {\n\t\treturn key, nil\n\t}\n\tif key, err := x509.ParsePKCS8PrivateKey(der); err == nil {\n\t\tswitch key := key.(type) {\n\t\tcase *rsa.PrivateKey, *ecdsa.PrivateKey, ed25519.PrivateKey:\n\t\t\treturn key, nil\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"tls: found unknown private key type in PKCS#8 wrapping\")\n\t\t}\n\t}\n\tif key, err := x509.ParseECPrivateKey(der); err == nil {\n\t\treturn key, nil\n\t}\n\n\treturn nil, errors.New(\"tls: failed to parse private key\")\n}\n"
        }
      ]
    }
  ]
}