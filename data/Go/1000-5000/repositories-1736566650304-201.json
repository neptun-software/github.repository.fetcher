{
  "metadata": {
    "timestamp": 1736566650304,
    "page": 201,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fvbock/endless",
      "stars": 4067,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.26171875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n*~"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05859375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Florian von Bock\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.544921875,
          "content": "# endless\n\nZero downtime restarts for golang HTTP and HTTPS servers. (for golang 1.3+)\n\n[![GoDoc](https://godoc.org/github.com/fvbock/endless?status.svg)](https://godoc.org/github.com/fvbock/endless)\n\n## Inspiration & Credits\n\nWell... it's what you want right - no need to hook in and out on a loadbalancer or something - just compile, SIGHUP, start new one, finish old requests etc.\n\nThere is https://github.com/rcrowley/goagain and i looked at https://fitstar.github.io/falcore/hot_restart.html which looked easier to do, but still some assembly required. I wanted something that's ideally as simple as\n\n    err := endless.ListenAndServe(\"localhost:4242\", mux)\n\nI found the excellent post [Graceful Restart in Golang](http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/) by [Grisha Trubetskoy](https://github.com/grisha) and took his code as a start. So a lot of credit to Grisha!\n\n\n## Features\n\n- Drop-in replacement for `http.ListenAndServe` and `http.ListenAndServeTLS`\n- Signal hooks to execute your own code before or after the listened to signals (SIGHUP, SIGUSR1, SIGUSR2, SIGINT, SIGTERM, SIGTSTP)\n- You can start multiple servers from one binary and endless will take care of the different sockets/ports assignments when restarting\n\n\n## Default Timeouts & MaxHeaderBytes\n\nThere are three variables exported by the package that control the values set for `DefaultReadTimeOut`, `DefaultWriteTimeOut`, and `MaxHeaderBytes` on the inner [`http.Server`](https://golang.org/pkg/net/http/#Server):\n\n\tDefaultReadTimeOut    time.Duration\n\tDefaultWriteTimeOut   time.Duration\n\tDefaultMaxHeaderBytes int\n\nThe endless default behaviour is to use the same defaults defined in `net/http`.\n\nThese have impact on endless by potentially not letting the parent process die until all connections are handled/finished.\n\n\n### Hammer Time\n\nTo deal with hanging requests on the parent after restarting endless will *hammer* the parent 60 seconds after receiving the shutdown signal from the forked child process. When hammered still running requests get terminated. This behaviour can be controlled by another exported variable:\n\n    DefaultHammerTime time.Duration\n\nThe default is 60 seconds. When set to `-1` `hammerTime()` is not invoked automatically. You can then hammer the parent manually by sending `SIGUSR2`. This will only hammer the parent if it is already in shutdown mode. So unless the process had received a `SIGTERM`, `SIGSTOP`, or `SIGINT` (manually or by forking) before `SIGUSR2` will be ignored.\n\nIf you had hanging requests and the server got hammered you will see a log message like this:\n\n    2015/04/04 13:04:10 [STOP - Hammer Time] Forcefully shutting down parent\n\n\n## Examples & Documentation\n\n    import \"github.com/fvbock/endless\"\n\nand then replacing `http.ListenAndServe` with `endless.ListenAndServe` or `http.ListenAndServeTLS` with `endless.ListenAndServeTLS`\n\n\terr := endless.ListenAndServe(\"localhost:4242\", handler)\n\nAfter starting your server you can make some changes, build, and send `SIGHUP` to the running process and it will finish handling any outstanding requests and serve all new incoming ones with the new binary.\n\nMore examples are in [here](https://github.com/fvbock/endless/tree/master/examples)\n\nThere is also [GoDoc Documentation](https://godoc.org/github.com/fvbock/endless)\n\n\n## Signals\n\nThe endless server will listen for the following signals: `syscall.SIGHUP`, `syscall.SIGUSR1`, `syscall.SIGUSR2`, `syscall.SIGINT`, `syscall.SIGTERM`, and `syscall.SIGTSTP`:\n\n`SIGHUP` will trigger a fork/restart\n\n`syscall.SIGINT` and `syscall.SIGTERM` will trigger a shutdown of the server (it will finish running requests)\n\n`SIGUSR2` will trigger [hammerTime](https://github.com/fvbock/endless#hammer-time)\n\n`SIGUSR1` and `SIGTSTP` are listened for but do not trigger anything in the endless server itself. (probably useless - might get rid of those two)\n\nYou can hook your own functions to be called *pre* or *post* signal handling - eg. pre fork or pre shutdown. More about that in the [hook example](https://github.com/fvbock/endless/tree/master/examples#hooking-into-the-signal-handling).\n\n\n## Limitation: No changing of ports\n\nCurrently you cannot restart a server on a different port than the previous version was running on.\n\n## PID file\n\nIf you want to save actual pid file, you can change the `BeforeBegin` hook like this:\n\n\tserver := endless.NewServer(\"localhost:4242\", handler)\n\tserver.BeforeBegin = func(add string) {\n\t\tlog.Printf(\"Actual pid is %d\", syscall.Getpid())\n\t\t// save it somehow\n\t}\n\terr := server.ListenAndServe()\n\n\n## TODOs\n\n- tests\n- documentation\n- less ugly wrapping of the tls.listener\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.4208984375,
          "content": "/*\nendless provides a drop in  replacement for the `net/http` stl functions `ListenAndServe` and `ListenAndServeTLS` to achieve zero downtime restarts and code upgrades.\n\nThe code is based on the excellent post [Graceful Restart in Golang](http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/) by [Grisha Trubetskoy](https://github.com/grisha). I took his code as a start. So a lot of credit to Grisha!\n*/\npackage endless\n"
        },
        {
          "name": "endless.go",
          "type": "blob",
          "size": 13.529296875,
          "content": "package endless\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t// \"github.com/fvbock/uds-go/introspect\"\n)\n\nconst (\n\tPRE_SIGNAL = iota\n\tPOST_SIGNAL\n\n\tSTATE_INIT\n\tSTATE_RUNNING\n\tSTATE_SHUTTING_DOWN\n\tSTATE_TERMINATE\n)\n\nvar (\n\trunningServerReg     sync.RWMutex\n\trunningServers       map[string]*endlessServer\n\trunningServersOrder  []string\n\tsocketPtrOffsetMap   map[string]uint\n\trunningServersForked bool\n\n\tDefaultReadTimeOut    time.Duration\n\tDefaultWriteTimeOut   time.Duration\n\tDefaultMaxHeaderBytes int\n\tDefaultHammerTime     time.Duration\n\n\tisChild     bool\n\tsocketOrder string\n\n\thookableSignals []os.Signal\n)\n\nfunc init() {\n\trunningServerReg = sync.RWMutex{}\n\trunningServers = make(map[string]*endlessServer)\n\trunningServersOrder = []string{}\n\tsocketPtrOffsetMap = make(map[string]uint)\n\n\tDefaultMaxHeaderBytes = 0 // use http.DefaultMaxHeaderBytes - which currently is 1 << 20 (1MB)\n\n\t// after a restart the parent will finish ongoing requests before\n\t// shutting down. set to a negative value to disable\n\tDefaultHammerTime = 60 * time.Second\n\n\thookableSignals = []os.Signal{\n\t\tsyscall.SIGHUP,\n\t\tsyscall.SIGUSR1,\n\t\tsyscall.SIGUSR2,\n\t\tsyscall.SIGINT,\n\t\tsyscall.SIGTERM,\n\t\tsyscall.SIGTSTP,\n\t}\n}\n\ntype endlessServer struct {\n\thttp.Server\n\tEndlessListener  net.Listener\n\tSignalHooks      map[int]map[os.Signal][]func()\n\ttlsInnerListener *endlessListener\n\twg               sync.WaitGroup\n\tsigChan          chan os.Signal\n\tisChild          bool\n\tstate            uint8\n\tlock             *sync.RWMutex\n\tBeforeBegin      func(add string)\n}\n\n/*\nNewServer returns an intialized endlessServer Object. Calling Serve on it will\nactually \"start\" the server.\n*/\nfunc NewServer(addr string, handler http.Handler) (srv *endlessServer) {\n\trunningServerReg.Lock()\n\tdefer runningServerReg.Unlock()\n\n\tsocketOrder = os.Getenv(\"ENDLESS_SOCKET_ORDER\")\n\tisChild = os.Getenv(\"ENDLESS_CONTINUE\") != \"\"\n\n\tif len(socketOrder) > 0 {\n\t\tfor i, addr := range strings.Split(socketOrder, \",\") {\n\t\t\tsocketPtrOffsetMap[addr] = uint(i)\n\t\t}\n\t} else {\n\t\tsocketPtrOffsetMap[addr] = uint(len(runningServersOrder))\n\t}\n\n\tsrv = &endlessServer{\n\t\twg:      sync.WaitGroup{},\n\t\tsigChan: make(chan os.Signal),\n\t\tisChild: isChild,\n\t\tSignalHooks: map[int]map[os.Signal][]func(){\n\t\t\tPRE_SIGNAL: map[os.Signal][]func(){\n\t\t\t\tsyscall.SIGHUP:  []func(){},\n\t\t\t\tsyscall.SIGUSR1: []func(){},\n\t\t\t\tsyscall.SIGUSR2: []func(){},\n\t\t\t\tsyscall.SIGINT:  []func(){},\n\t\t\t\tsyscall.SIGTERM: []func(){},\n\t\t\t\tsyscall.SIGTSTP: []func(){},\n\t\t\t},\n\t\t\tPOST_SIGNAL: map[os.Signal][]func(){\n\t\t\t\tsyscall.SIGHUP:  []func(){},\n\t\t\t\tsyscall.SIGUSR1: []func(){},\n\t\t\t\tsyscall.SIGUSR2: []func(){},\n\t\t\t\tsyscall.SIGINT:  []func(){},\n\t\t\t\tsyscall.SIGTERM: []func(){},\n\t\t\t\tsyscall.SIGTSTP: []func(){},\n\t\t\t},\n\t\t},\n\t\tstate: STATE_INIT,\n\t\tlock:  &sync.RWMutex{},\n\t}\n\n\tsrv.Server.Addr = addr\n\tsrv.Server.ReadTimeout = DefaultReadTimeOut\n\tsrv.Server.WriteTimeout = DefaultWriteTimeOut\n\tsrv.Server.MaxHeaderBytes = DefaultMaxHeaderBytes\n\tsrv.Server.Handler = handler\n\n\tsrv.BeforeBegin = func(addr string) {\n\t\tlog.Println(syscall.Getpid(), addr)\n\t}\n\n\trunningServersOrder = append(runningServersOrder, addr)\n\trunningServers[addr] = srv\n\n\treturn\n}\n\n/*\nListenAndServe listens on the TCP network address addr and then calls Serve\nwith handler to handle requests on incoming connections. Handler is typically\nnil, in which case the DefaultServeMux is used.\n*/\nfunc ListenAndServe(addr string, handler http.Handler) error {\n\tserver := NewServer(addr, handler)\n\treturn server.ListenAndServe()\n}\n\n/*\nListenAndServeTLS acts identically to ListenAndServe, except that it expects\nHTTPS connections. Additionally, files containing a certificate and matching\nprivate key for the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation of the server's\ncertificate followed by the CA's certificate.\n*/\nfunc ListenAndServeTLS(addr string, certFile string, keyFile string, handler http.Handler) error {\n\tserver := NewServer(addr, handler)\n\treturn server.ListenAndServeTLS(certFile, keyFile)\n}\n\nfunc (srv *endlessServer) getState() uint8 {\n\tsrv.lock.RLock()\n\tdefer srv.lock.RUnlock()\n\n\treturn srv.state\n}\n\nfunc (srv *endlessServer) setState(st uint8) {\n\tsrv.lock.Lock()\n\tdefer srv.lock.Unlock()\n\n\tsrv.state = st\n}\n\n/*\nServe accepts incoming HTTP connections on the listener l, creating a new\nservice goroutine for each. The service goroutines read requests and then call\nhandler to reply to them. Handler is typically nil, in which case the\nDefaultServeMux is used.\n\nIn addition to the stl Serve behaviour each connection is added to a\nsync.Waitgroup so that all outstanding connections can be served before shutting\ndown the server.\n*/\nfunc (srv *endlessServer) Serve() (err error) {\n\tdefer log.Println(syscall.Getpid(), \"Serve() returning...\")\n\tsrv.setState(STATE_RUNNING)\n\terr = srv.Server.Serve(srv.EndlessListener)\n\tlog.Println(syscall.Getpid(), \"Waiting for connections to finish...\")\n\tsrv.wg.Wait()\n\tsrv.setState(STATE_TERMINATE)\n\treturn\n}\n\n/*\nListenAndServe listens on the TCP network address srv.Addr and then calls Serve\nto handle requests on incoming connections. If srv.Addr is blank, \":http\" is\nused.\n*/\nfunc (srv *endlessServer) ListenAndServe() (err error) {\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":http\"\n\t}\n\n\tgo srv.handleSignals()\n\n\tl, err := srv.getListener(addr)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tsrv.EndlessListener = newEndlessListener(l, srv)\n\n\tif srv.isChild {\n\t\tsyscall.Kill(syscall.Getppid(), syscall.SIGTERM)\n\t}\n\n\tsrv.BeforeBegin(srv.Addr)\n\n\treturn srv.Serve()\n}\n\n/*\nListenAndServeTLS listens on the TCP network address srv.Addr and then calls\nServe to handle requests on incoming TLS connections.\n\nFilenames containing a certificate and matching private key for the server must\nbe provided. If the certificate is signed by a certificate authority, the\ncertFile should be the concatenation of the server's certificate followed by the\nCA's certificate.\n\nIf srv.Addr is blank, \":https\" is used.\n*/\nfunc (srv *endlessServer) ListenAndServeTLS(certFile, keyFile string) (err error) {\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":https\"\n\t}\n\n\tconfig := &tls.Config{}\n\tif srv.TLSConfig != nil {\n\t\t*config = *srv.TLSConfig\n\t}\n\tif config.NextProtos == nil {\n\t\tconfig.NextProtos = []string{\"http/1.1\"}\n\t}\n\n\tconfig.Certificates = make([]tls.Certificate, 1)\n\tconfig.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tgo srv.handleSignals()\n\n\tl, err := srv.getListener(addr)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tsrv.tlsInnerListener = newEndlessListener(l, srv)\n\tsrv.EndlessListener = tls.NewListener(srv.tlsInnerListener, config)\n\n\tif srv.isChild {\n\t\tsyscall.Kill(syscall.Getppid(), syscall.SIGTERM)\n\t}\n\n\tlog.Println(syscall.Getpid(), srv.Addr)\n\treturn srv.Serve()\n}\n\n/*\ngetListener either opens a new socket to listen on, or takes the acceptor socket\nit got passed when restarted.\n*/\nfunc (srv *endlessServer) getListener(laddr string) (l net.Listener, err error) {\n\tif srv.isChild {\n\t\tvar ptrOffset uint = 0\n\t\trunningServerReg.RLock()\n\t\tdefer runningServerReg.RUnlock()\n\t\tif len(socketPtrOffsetMap) > 0 {\n\t\t\tptrOffset = socketPtrOffsetMap[laddr]\n\t\t\t// log.Println(\"laddr\", laddr, \"ptr offset\", socketPtrOffsetMap[laddr])\n\t\t}\n\n\t\tf := os.NewFile(uintptr(3+ptrOffset), \"\")\n\t\tl, err = net.FileListener(f)\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"net.FileListener error: %v\", err)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tl, err = net.Listen(\"tcp\", laddr)\n\t\tif err != nil {\n\t\t\terr = fmt.Errorf(\"net.Listen error: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n/*\nhandleSignals listens for os Signals and calls any hooked in function that the\nuser had registered with the signal.\n*/\nfunc (srv *endlessServer) handleSignals() {\n\tvar sig os.Signal\n\n\tsignal.Notify(\n\t\tsrv.sigChan,\n\t\thookableSignals...,\n\t)\n\n\tpid := syscall.Getpid()\n\tfor {\n\t\tsig = <-srv.sigChan\n\t\tsrv.signalHooks(PRE_SIGNAL, sig)\n\t\tswitch sig {\n\t\tcase syscall.SIGHUP:\n\t\t\tlog.Println(pid, \"Received SIGHUP. forking.\")\n\t\t\terr := srv.fork()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Fork err:\", err)\n\t\t\t}\n\t\tcase syscall.SIGUSR1:\n\t\t\tlog.Println(pid, \"Received SIGUSR1.\")\n\t\tcase syscall.SIGUSR2:\n\t\t\tlog.Println(pid, \"Received SIGUSR2.\")\n\t\t\tsrv.hammerTime(0 * time.Second)\n\t\tcase syscall.SIGINT:\n\t\t\tlog.Println(pid, \"Received SIGINT.\")\n\t\t\tsrv.shutdown()\n\t\tcase syscall.SIGTERM:\n\t\t\tlog.Println(pid, \"Received SIGTERM.\")\n\t\t\tsrv.shutdown()\n\t\tcase syscall.SIGTSTP:\n\t\t\tlog.Println(pid, \"Received SIGTSTP.\")\n\t\tdefault:\n\t\t\tlog.Printf(\"Received %v: nothing i care about...\\n\", sig)\n\t\t}\n\t\tsrv.signalHooks(POST_SIGNAL, sig)\n\t}\n}\n\nfunc (srv *endlessServer) signalHooks(ppFlag int, sig os.Signal) {\n\tif _, notSet := srv.SignalHooks[ppFlag][sig]; !notSet {\n\t\treturn\n\t}\n\tfor _, f := range srv.SignalHooks[ppFlag][sig] {\n\t\tf()\n\t}\n\treturn\n}\n\n/*\nshutdown closes the listener so that no new connections are accepted. it also\nstarts a goroutine that will hammer (stop all running requests) the server\nafter DefaultHammerTime.\n*/\nfunc (srv *endlessServer) shutdown() {\n\tif srv.getState() != STATE_RUNNING {\n\t\treturn\n\t}\n\n\tsrv.setState(STATE_SHUTTING_DOWN)\n\tif DefaultHammerTime >= 0 {\n\t\tgo srv.hammerTime(DefaultHammerTime)\n\t}\n\t// disable keep-alives on existing connections\n\tsrv.SetKeepAlivesEnabled(false)\n\terr := srv.EndlessListener.Close()\n\tif err != nil {\n\t\tlog.Println(syscall.Getpid(), \"Listener.Close() error:\", err)\n\t} else {\n\t\tlog.Println(syscall.Getpid(), srv.EndlessListener.Addr(), \"Listener closed.\")\n\t}\n}\n\n/*\nhammerTime forces the server to shutdown in a given timeout - whether it\nfinished outstanding requests or not. if Read/WriteTimeout are not set or the\nmax header size is very big a connection could hang...\n\nsrv.Serve() will not return until all connections are served. this will\nunblock the srv.wg.Wait() in Serve() thus causing ListenAndServe(TLS) to\nreturn.\n*/\nfunc (srv *endlessServer) hammerTime(d time.Duration) {\n\tdefer func() {\n\t\t// we are calling srv.wg.Done() until it panics which means we called\n\t\t// Done() when the counter was already at 0 and we're done.\n\t\t// (and thus Serve() will return and the parent will exit)\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Println(\"WaitGroup at 0\", r)\n\t\t}\n\t}()\n\tif srv.getState() != STATE_SHUTTING_DOWN {\n\t\treturn\n\t}\n\ttime.Sleep(d)\n\tlog.Println(\"[STOP - Hammer Time] Forcefully shutting down parent\")\n\tfor {\n\t\tif srv.getState() == STATE_TERMINATE {\n\t\t\tbreak\n\t\t}\n\t\tsrv.wg.Done()\n\t\truntime.Gosched()\n\t}\n}\n\nfunc (srv *endlessServer) fork() (err error) {\n\trunningServerReg.Lock()\n\tdefer runningServerReg.Unlock()\n\n\t// only one server instance should fork!\n\tif runningServersForked {\n\t\treturn errors.New(\"Another process already forked. Ignoring this one.\")\n\t}\n\n\trunningServersForked = true\n\n\tvar files = make([]*os.File, len(runningServers))\n\tvar orderArgs = make([]string, len(runningServers))\n\t// get the accessor socket fds for _all_ server instances\n\tfor _, srvPtr := range runningServers {\n\t\t// introspect.PrintTypeDump(srvPtr.EndlessListener)\n\t\tswitch srvPtr.EndlessListener.(type) {\n\t\tcase *endlessListener:\n\t\t\t// normal listener\n\t\t\tfiles[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.EndlessListener.(*endlessListener).File()\n\t\tdefault:\n\t\t\t// tls listener\n\t\t\tfiles[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.tlsInnerListener.File()\n\t\t}\n\t\torderArgs[socketPtrOffsetMap[srvPtr.Server.Addr]] = srvPtr.Server.Addr\n\t}\n\n\tenv := append(\n\t\tos.Environ(),\n\t\t\"ENDLESS_CONTINUE=1\",\n\t)\n\tif len(runningServers) > 1 {\n\t\tenv = append(env, fmt.Sprintf(`ENDLESS_SOCKET_ORDER=%s`, strings.Join(orderArgs, \",\")))\n\t}\n\n\t// log.Println(files)\n\tpath := os.Args[0]\n\tvar args []string\n\tif len(os.Args) > 1 {\n\t\targs = os.Args[1:]\n\t}\n\n\tcmd := exec.Command(path, args...)\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\tcmd.ExtraFiles = files\n\tcmd.Env = env\n\n\t// cmd.SysProcAttr = &syscall.SysProcAttr{\n\t// \tSetsid:  true,\n\t// \tSetctty: true,\n\t// \tCtty:    ,\n\t// }\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\tlog.Fatalf(\"Restart: Failed to launch, error: %v\", err)\n\t}\n\n\treturn\n}\n\ntype endlessListener struct {\n\tnet.Listener\n\tstopped bool\n\tserver  *endlessServer\n}\n\nfunc (el *endlessListener) Accept() (c net.Conn, err error) {\n\ttc, err := el.Listener.(*net.TCPListener).AcceptTCP()\n\tif err != nil {\n\t\treturn\n\t}\n\n\ttc.SetKeepAlive(true)                  // see http.tcpKeepAliveListener\n\ttc.SetKeepAlivePeriod(3 * time.Minute) // see http.tcpKeepAliveListener\n\n\tc = endlessConn{\n\t\tConn:   tc,\n\t\tserver: el.server,\n\t}\n\n\tel.server.wg.Add(1)\n\treturn\n}\n\nfunc newEndlessListener(l net.Listener, srv *endlessServer) (el *endlessListener) {\n\tel = &endlessListener{\n\t\tListener: l,\n\t\tserver:   srv,\n\t}\n\n\treturn\n}\n\nfunc (el *endlessListener) Close() error {\n\tif el.stopped {\n\t\treturn syscall.EINVAL\n\t}\n\n\tel.stopped = true\n\treturn el.Listener.Close()\n}\n\nfunc (el *endlessListener) File() *os.File {\n\t// returns a dup(2) - FD_CLOEXEC flag *not* set\n\ttl := el.Listener.(*net.TCPListener)\n\tfl, _ := tl.File()\n\treturn fl\n}\n\ntype endlessConn struct {\n\tnet.Conn\n\tserver *endlessServer\n}\n\nfunc (w endlessConn) Close() error {\n\terr := w.Conn.Close()\n\tif err == nil {\n\t\tw.server.wg.Done()\n\t}\n\treturn err\n}\n\n/*\nRegisterSignalHook registers a function to be run PRE_SIGNAL or POST_SIGNAL for\na given signal. PRE or POST in this case means before or after the signal\nrelated code endless itself runs\n*/\nfunc (srv *endlessServer) RegisterSignalHook(prePost int, sig os.Signal, f func()) (err error) {\n\tif prePost != PRE_SIGNAL && prePost != POST_SIGNAL {\n\t\terr = fmt.Errorf(\"Cannot use %v for prePost arg. Must be endless.PRE_SIGNAL or endless.POST_SIGNAL.\", sig)\n\t\treturn\n\t}\n\tfor _, s := range hookableSignals {\n\t\tif s == sig {\n\t\t\tsrv.SignalHooks[prePost][sig] = append(srv.SignalHooks[prePost][sig], f)\n\t\t\treturn\n\t\t}\n\t}\n\terr = fmt.Errorf(\"Signal %v is not supported.\", sig)\n\treturn\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}