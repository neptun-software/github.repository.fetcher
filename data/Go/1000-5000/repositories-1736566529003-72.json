{
  "metadata": {
    "timestamp": 1736566529003,
    "page": 72,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pufferffish/wireproxy",
      "stars": 4664,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.060546875,
          "content": ".dockerignore\n.github\n.gitignore\nDockerfile\nLICENSE\nREADME.md\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0517578125,
          "content": "/main\n/wireproxy\n*.sw?\n/.idea\n.goreleaser.yml\n*.conf\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.5595703125,
          "content": "# Start by building the application.\nFROM docker.io/golang:1.21 as build\n\nWORKDIR /usr/src/wireproxy\nCOPY . .\n\nRUN make\n\n# Now copy it into our base image.\nFROM gcr.io/distroless/static-debian11:nonroot\nCOPY --from=build /usr/src/wireproxy/wireproxy /usr/bin/wireproxy\n\nVOLUME [ \"/etc/wireproxy\"]\nENTRYPOINT [ \"/usr/bin/wireproxy\" ]\nCMD [ \"--config\", \"/etc/wireproxy/config\" ]\n\nLABEL org.opencontainers.image.title=\"wireproxy\"\nLABEL org.opencontainers.image.description=\"Wireguard client that exposes itself as a socks5 proxy\"\nLABEL org.opencontainers.image.licenses=\"ISC\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7236328125,
          "content": "Copyright (c) 2024 Wind Wong <me@windtfw.com>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3037109375,
          "content": "export GO ?= go\nexport CGO_ENABLED = 0\n\nTAG := $(shell git describe --always --tags $(git rev-list --tags --max-count=1) --match v*)\n\n.PHONY: all\nall: wireproxy\n\n.PHONY: wireproxy\nwireproxy:\n\t${GO} build -trimpath -ldflags \"-s -w -X 'main.version=${TAG}'\" ./cmd/wireproxy\n\n.PHONY: clean\nclean:\n\t${RM} wireproxy\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.1923828125,
          "content": "# wireproxy\n[![ISC licensed](https://img.shields.io/badge/license-ISC-blue)](./LICENSE)\n[![Build status](https://github.com/octeep/wireproxy/actions/workflows/build.yml/badge.svg)](https://github.com/octeep/wireproxy/actions)\n[![Documentation](https://img.shields.io/badge/godoc-wireproxy-blue)](https://pkg.go.dev/github.com/octeep/wireproxy)\n\nA wireguard client that exposes itself as a socks5/http proxy or tunnels.\n\n# What is this\n`wireproxy` is a completely userspace application that connects to a wireguard peer,\nand exposes a socks5/http proxy or tunnels on the machine. This can be useful if you need\nto connect to certain sites via a wireguard peer, but can't be bothered to setup a new network\ninterface for whatever reasons.\n\n# Why you might want this\n- You simply want to use wireguard as a way to proxy some traffic.\n- You don't want root permission just to change wireguard settings.\n\nCurrently, I'm running wireproxy connected to a wireguard server in another country,\nand configured my browser to use wireproxy for certain sites. It's pretty useful since\nwireproxy is completely isolated from my network interfaces, and I don't need root to configure\nanything.\n\nUsers who want something similar but for Amnezia VPN can use [this fork](https://github.com/artem-russkikh/wireproxy-awg)\nof wireproxy by [@artem-russkikh](https://github.com/artem-russkikh).\n\n# Feature\n- TCP static routing for client and server\n- SOCKS5/HTTP proxy (currently only CONNECT is supported)\n\n# TODO\n- UDP Support in SOCKS5\n- UDP static routing\n\n# Usage\n```\n./wireproxy [-c path to config]\n```\n\n```\nusage: wireproxy [-h|--help] [-c|--config \"<value>\"] [-s|--silent]\n                 [-d|--daemon] [-i|--info \"<value>\"] [-v|--version]\n                 [-n|--configtest]\n\n                 Userspace wireguard client for proxying\n\nArguments:\n\n  -h  --help        Print help information\n  -c  --config      Path of configuration file\n                    Default paths: /etc/wireproxy/wireproxy.conf, $HOME/.config/wireproxy.conf\n  -s  --silent      Silent mode\n  -d  --daemon      Make wireproxy run in background\n  -i  --info        Specify the address and port for exposing health status\n  -v  --version     Print version\n  -n  --configtest  Configtest mode. Only check the configuration file for\n                    validity.\n\n```\n\n# Build instruction\n```\ngit clone https://github.com/octeep/wireproxy\ncd wireproxy\nmake\n```\n\n# Use with VPN\nInstructions for using wireproxy with Firefox container tabs and auto-start on MacOS can be found [here](/UseWithVPN.md).\n\n# Sample config file\n```\n# The [Interface] and [Peer] configurations follow the same semantics and meaning\n# of a wg-quick configuration. To understand what these fields mean, please refer to:\n# https://wiki.archlinux.org/title/WireGuard#Persistent_configuration\n# https://www.wireguard.com/#simple-network-interface\n[Interface]\nAddress = 10.200.200.2/32 # The subnet should be /32 and /128 for IPv4 and v6 respectively\n# MTU = 1420 (optional)\nPrivateKey = uCTIK+56CPyCvwJxmU5dBfuyJvPuSXAq1FzHdnIxe1Q=\n# PrivateKey = $MY_WIREGUARD_PRIVATE_KEY # Alternatively, reference environment variables\nDNS = 10.200.200.1\n\n[Peer]\nPublicKey = QP+A67Z2UBrMgvNIdHv8gPel5URWNLS4B3ZQ2hQIZlg=\n# PresharedKey = UItQuvLsyh50ucXHfjF0bbR4IIpVBd74lwKc8uIPXXs= (optional)\nEndpoint = my.ddns.example.com:51820\n# PersistentKeepalive = 25 (optional)\n\n# TCPClientTunnel is a tunnel listening on your machine,\n# and it forwards any TCP traffic received to the specified target via wireguard.\n# Flow:\n# <an app on your LAN> --> localhost:25565 --(wireguard)--> play.cubecraft.net:25565\n[TCPClientTunnel]\nBindAddress = 127.0.0.1:25565\nTarget = play.cubecraft.net:25565\n\n# TCPServerTunnel is a tunnel listening on wireguard,\n# and it forwards any TCP traffic received to the specified target via local network.\n# Flow:\n# <an app on your wireguard network> --(wireguard)--> 172.16.31.2:3422 --> localhost:25545\n[TCPServerTunnel]\nListenPort = 3422\nTarget = localhost:25545\n\n# STDIOTunnel is a tunnel connecting the standard input and output of the wireproxy\n# process to the specified TCP target via wireguard.\n# This is especially useful to use wireproxy as a ProxyCommand parameter in openssh\n# For example:\n#    ssh -o ProxyCommand='wireproxy -c myconfig.conf' ssh.myserver.net\n# Flow:\n# Piped command -->(wireguard)--> ssh.myserver.net:22\n[STDIOTunnel]\nTarget = ssh.myserver.net:22\n\n# Socks5 creates a socks5 proxy on your LAN, and all traffic would be routed via wireguard.\n[Socks5]\nBindAddress = 127.0.0.1:25344\n\n# Socks5 authentication parameters, specifying username and password enables\n# proxy authentication.\n#Username = ...\n# Avoid using spaces in the password field\n#Password = ...\n\n# http creates a http proxy on your LAN, and all traffic would be routed via wireguard.\n[http]\nBindAddress = 127.0.0.1:25345\n\n# HTTP authentication parameters, specifying username and password enables\n# proxy authentication.\n#Username = ...\n# Avoid using spaces in the password field\n#Password = ...\n```\n\nAlternatively, if you already have a wireguard config, you can import it in the\nwireproxy config file like this:\n```\nWGConfig = <path to the wireguard config>\n\n# Same semantics as above\n[TCPClientTunnel]\n...\n\n[TCPServerTunnel]\n...\n\n[Socks5]\n...\n```\n\nHaving multiple peers is also supported. `AllowedIPs` would need to be specified\nsuch that wireproxy would know which peer to forward to.\n```\n[Interface]\nAddress = 10.254.254.40/32\nPrivateKey = XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX=\n\n[Peer]\nEndpoint = 192.168.0.204:51820\nPublicKey = YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY=\nAllowedIPs = 10.254.254.100/32\nPersistentKeepalive = 25\n\n[Peer]\nPublicKey = ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ=\nAllowedIPs = 10.254.254.1/32, fdee:1337:c000:d00d::1/128\nEndpoint = 172.16.0.185:44044\nPersistentKeepalive = 25\n\n\n[TCPServerTunnel]\nListenPort = 5000\nTarget = service-one.servicenet:5000\n\n[TCPServerTunnel]\nListenPort = 5001\nTarget = service-two.servicenet:5001\n\n[TCPServerTunnel]\nListenPort = 5080\nTarget = service-three.servicenet:80\n```\n\nWireproxy can also allow peers to connect to it:\n```\n[Interface]\nListenPort = 5400\n...\n\n[Peer]\nPublicKey = YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY=\nAllowedIPs = 10.254.254.100/32\n# Note there is no Endpoint defined here.\n```\n# Health endpoint\nWireproxy supports exposing a health endpoint for monitoring purposes.\nThe argument `--info/-i` specifies an address and port (e.g. `localhost:9080`), which exposes a HTTP server that provides health status metric of the server.\n\nCurrently two endpoints are implemented:\n\n`/metrics`: Exposes information of the wireguard daemon, this provides the same information you would get with `wg show`. [This](https://www.wireguard.com/xplatform/#example-dialog) shows an example of what the response would look like.\n\n`/readyz`: This responds with a json which shows the last time a pong is received from an IP specified with `CheckAlive`. When `CheckAlive` is set, a ping is sent out to addresses in `CheckAlive` per `CheckAliveInterval` seconds (defaults to 5) via wireguard. If a pong has not been received from one of the addresses within the last `CheckAliveInterval` seconds (+2 seconds for some leeway to account for latency), then it would respond with a 503, otherwise a 200.\n\nFor example:\n```\n[Interface]\nPrivateKey = censored\nAddress = 10.2.0.2/32\nDNS = 10.2.0.1\nCheckAlive = 1.1.1.1, 3.3.3.3\nCheckAliveInterval = 3\n\n[Peer]\nPublicKey = censored\nAllowedIPs = 0.0.0.0/0\nEndpoint = 149.34.244.174:51820\n\n[Socks5]\nBindAddress = 127.0.0.1:25344\n```\n`/readyz` would respond with\n```\n< HTTP/1.1 503 Service Unavailable\n< Date: Thu, 11 Apr 2024 00:54:59 GMT\n< Content-Length: 35\n< Content-Type: text/plain; charset=utf-8\n<\n{\"1.1.1.1\":1712796899,\"3.3.3.3\":0}\n```\n\nAnd for:\n```\n[Interface]\nPrivateKey = censored\nAddress = 10.2.0.2/32\nDNS = 10.2.0.1\nCheckAlive = 1.1.1.1\n```\n`/readyz` would respond with\n```\n< HTTP/1.1 200 OK\n< Date: Thu, 11 Apr 2024 00:56:21 GMT\n< Content-Length: 23\n< Content-Type: text/plain; charset=utf-8\n<\n{\"1.1.1.1\":1712796979}\n```\n\nIf nothing is set for `CheckAlive`, an empty JSON object with 200 will be the response.\n\nThe peer which the ICMP ping packet is routed to depends on the `AllowedIPs` set for each peers.\n\n# Stargazers over time\n[![Stargazers over time](https://starchart.cc/octeep/wireproxy.svg)](https://starchart.cc/octeep/wireproxy)\n"
        },
        {
          "name": "UseWithVPN.md",
          "type": "blob",
          "size": 3.091796875,
          "content": "# Getting a Wireguard Server\nYou can create your own wireguard server using a host service like DigitalOcean,\nor you can get a VPN service that provides WireGuard configs.\n\nI recommend ProtonVPN, because it is highly secure and has a great WireGuard\nconfig generator.\n\nSimply go to https://account.protonvpn.com/downloads and scroll down to the\nwireguard section to generate your configs, then paste into the appropriate\nsection below.\n\n# Simple Setup for multiple SOCKS configs for firefox\n\nCreate a folder for your configs and startup scripts. Can be the same place as\nthis code. That path you will use below. For reference this text uses\n`/Users/jonny/vpntabs`\n\nFor each VPN you want to run, you will download your wireguard config and name\nit appropriately (e.g. `ProtonUS.adblock.server.conf`) and then create two new\nfiles from those below with similar names (e.g. `ProtonUS.adblock.conf` and\n`ProtonUS.adblock.sh`)\n\nYou will also create a launch script, the reference below is only for macOS. The\nnaming should also be similar (e.g.\n`/Users/jonny/Library/LaunchAgents/com.ProtonUS.adblock.plist`)\n\n## Config File\nMake sure you use a unique port for every separate server\nI recommend you set proxy authentication, you can use the same user/pass for all\n```\n# Link to the Downloaded config\nWGConfig = /Users/jonny/vpntabs/ProtonUS.adblock.server.conf\n\n# Used for firefox containers\n[Socks5]\nBindAddress = 127.0.0.1:25344 # Update the port here for each new server\n\n# Socks5 authentication parameters, specifying username and password enables\n# proxy authentication.\n#Username = ...\n# Avoid using spaces in the password field\n#Password = ...\n```\n\n## Startup Script File\nThis is a bash script to facilitate startup, not strictly essential, but adds\nease.\nNote, you MUST update the first path to wherever you installed this code to.\nMake sure you use the path for the config file above, not the one you downloaded\nfrom e.g. protonvpn.\n```\n#!/bin/bash\n/Users/jonny/wireproxy/wireproxy -c /Users/jonny/vpntabs/ProtonUS.adblock.conf\n```\n\n## MacOS LaunchAgent\nTo make it run every time you start your computer, you can create a launch agent\nin `$HOME/Library/LaunchAgents`. Name reference above.\n\nThat file should contain the following, the label should be the same as the file\nname and the paths should be set correctly:\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>Label</key>\n    <string>com.ProtonUS.adblock</string>\n    <key>Program</key>\n    <string>/Users/jonny/vpntabs/ProtonUS.adblock.sh</string>\n    <key>RunAtLoad</key>\n\t<true/>\n    <key>KeepAlive</key>\n    <true/>\n</dict>\n</plist>\n```\n\nTo enable it, run\n`launchctl load ~/Library/LaunchAgents/com.ProtonUS.adblock.plist` and\n`launchtl start ~/Library/LaunchAgents/com.PortonUS.adblock.plist`\n\n# Firefox Setup\nYou will need to enable the Multi Account Container Tabs extension and a proxy extension, I\nrecommend Sideberry, but Container Proxy also works.\n\nCreate a container to be dedicated to this VPN, and then add the IP, port,\nusername, and password from above.\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 11.259765625,
          "content": "package wireproxy\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/go-ini/ini\"\n\n\t\"net/netip\"\n)\n\ntype PeerConfig struct {\n\tPublicKey    string\n\tPreSharedKey string\n\tEndpoint     *string\n\tKeepAlive    int\n\tAllowedIPs   []netip.Prefix\n}\n\n// DeviceConfig contains the information to initiate a wireguard connection\ntype DeviceConfig struct {\n\tSecretKey          string\n\tEndpoint           []netip.Addr\n\tPeers              []PeerConfig\n\tDNS                []netip.Addr\n\tMTU                int\n\tListenPort         *int\n\tCheckAlive         []netip.Addr\n\tCheckAliveInterval int\n}\n\ntype TCPClientTunnelConfig struct {\n\tBindAddress *net.TCPAddr\n\tTarget      string\n}\n\ntype STDIOTunnelConfig struct {\n\tTarget string\n}\n\ntype TCPServerTunnelConfig struct {\n\tListenPort int\n\tTarget     string\n}\n\ntype Socks5Config struct {\n\tBindAddress string\n\tUsername    string\n\tPassword    string\n}\n\ntype HTTPConfig struct {\n\tBindAddress string\n\tUsername    string\n\tPassword    string\n}\n\ntype Configuration struct {\n\tDevice   *DeviceConfig\n\tRoutines []RoutineSpawner\n}\n\nfunc parseString(section *ini.Section, keyName string) (string, error) {\n\tkey := section.Key(strings.ToLower(keyName))\n\tif key == nil {\n\t\treturn \"\", errors.New(keyName + \" should not be empty\")\n\t}\n\tvalue := key.String()\n\tif strings.HasPrefix(value, \"$\") {\n\t\tif strings.HasPrefix(value, \"$$\") {\n\t\t\treturn strings.Replace(value, \"$$\", \"$\", 1), nil\n\t\t}\n\t\tvar ok bool\n\t\tvalue, ok = os.LookupEnv(strings.TrimPrefix(value, \"$\"))\n\t\tif !ok {\n\t\t\treturn \"\", errors.New(keyName + \" references unset environment variable \" + key.String())\n\t\t}\n\t\treturn value, nil\n\t}\n\treturn key.String(), nil\n}\n\nfunc parsePort(section *ini.Section, keyName string) (int, error) {\n\tkey := section.Key(keyName)\n\tif key == nil {\n\t\treturn 0, errors.New(keyName + \" should not be empty\")\n\t}\n\n\tport, err := key.Int()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif !(port >= 0 && port < 65536) {\n\t\treturn 0, errors.New(\"port should be >= 0 and < 65536\")\n\t}\n\n\treturn port, nil\n}\n\nfunc parseTCPAddr(section *ini.Section, keyName string) (*net.TCPAddr, error) {\n\taddrStr, err := parseString(section, keyName)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn net.ResolveTCPAddr(\"tcp\", addrStr)\n}\n\nfunc parseBase64KeyToHex(section *ini.Section, keyName string) (string, error) {\n\tkey, err := parseString(section, keyName)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tresult, err := encodeBase64ToHex(key)\n\tif err != nil {\n\t\treturn result, err\n\t}\n\n\treturn result, nil\n}\n\nfunc encodeBase64ToHex(key string) (string, error) {\n\tdecoded, err := base64.StdEncoding.DecodeString(key)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"invalid base64 string: \" + key)\n\t}\n\tif len(decoded) != 32 {\n\t\treturn \"\", errors.New(\"key should be 32 bytes: \" + key)\n\t}\n\treturn hex.EncodeToString(decoded), nil\n}\n\nfunc parseNetIP(section *ini.Section, keyName string) ([]netip.Addr, error) {\n\tkey, err := parseString(section, keyName)\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"should not be empty\") {\n\t\t\treturn []netip.Addr{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tkeys := strings.Split(key, \",\")\n\tvar ips = make([]netip.Addr, 0, len(keys))\n\tfor _, str := range keys {\n\t\tstr = strings.TrimSpace(str)\n\t\tif len(str) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tip, err := netip.ParseAddr(str)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tips = append(ips, ip)\n\t}\n\treturn ips, nil\n}\n\nfunc parseCIDRNetIP(section *ini.Section, keyName string) ([]netip.Addr, error) {\n\tkey, err := parseString(section, keyName)\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"should not be empty\") {\n\t\t\treturn []netip.Addr{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tkeys := strings.Split(key, \",\")\n\tvar ips = make([]netip.Addr, 0, len(keys))\n\tfor _, str := range keys {\n\t\tstr = strings.TrimSpace(str)\n\t\tif len(str) == 0 {\n\t\t\tcontinue\n\t\t}\n    \n\t\tif addr, err := netip.ParseAddr(str); err == nil {\n\t\t\tips = append(ips, addr)\n\t\t} else {\n\t\t\tprefix, err := netip.ParsePrefix(str)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n      \n\t\t\taddr := prefix.Addr()\n\t\t\tips = append(ips, addr)\n\t\t}\n\t}\n\treturn ips, nil\n}\n\nfunc parseAllowedIPs(section *ini.Section) ([]netip.Prefix, error) {\n\tkey, err := parseString(section, \"AllowedIPs\")\n\tif err != nil {\n\t\tif strings.Contains(err.Error(), \"should not be empty\") {\n\t\t\treturn []netip.Prefix{}, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tkeys := strings.Split(key, \",\")\n\tvar ips = make([]netip.Prefix, 0, len(keys))\n\tfor _, str := range keys {\n\t\tstr = strings.TrimSpace(str)\n\t\tif len(str) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tprefix, err := netip.ParsePrefix(str)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tips = append(ips, prefix)\n\t}\n\treturn ips, nil\n}\n\nfunc resolveIP(ip string) (*net.IPAddr, error) {\n\treturn net.ResolveIPAddr(\"ip\", ip)\n}\n\nfunc resolveIPPAndPort(addr string) (string, error) {\n\thost, port, err := net.SplitHostPort(addr)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tip, err := resolveIP(host)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn net.JoinHostPort(ip.String(), port), nil\n}\n\n// ParseInterface parses the [Interface] section and extract the information into `device`\nfunc ParseInterface(cfg *ini.File, device *DeviceConfig) error {\n\tsections, err := cfg.SectionsByName(\"Interface\")\n\tif len(sections) != 1 || err != nil {\n\t\treturn errors.New(\"one and only one [Interface] is expected\")\n\t}\n\tsection := sections[0]\n\n\taddress, err := parseCIDRNetIP(section, \"Address\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdevice.Endpoint = address\n\n\tprivKey, err := parseBase64KeyToHex(section, \"PrivateKey\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdevice.SecretKey = privKey\n\n\tdns, err := parseNetIP(section, \"DNS\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdevice.DNS = dns\n\n\tif sectionKey, err := section.GetKey(\"MTU\"); err == nil {\n\t\tvalue, err := sectionKey.Int()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdevice.MTU = value\n\t}\n\n\tif sectionKey, err := section.GetKey(\"ListenPort\"); err == nil {\n\t\tvalue, err := sectionKey.Int()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdevice.ListenPort = &value\n\t}\n\n\tcheckAlive, err := parseNetIP(section, \"CheckAlive\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdevice.CheckAlive = checkAlive\n\n\tdevice.CheckAliveInterval = 5\n\tif sectionKey, err := section.GetKey(\"CheckAliveInterval\"); err == nil {\n\t\tvalue, err := sectionKey.Int()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(checkAlive) == 0 {\n\t\t\treturn errors.New(\"CheckAliveInterval is only valid when CheckAlive is set\")\n\t\t}\n\n\t\tdevice.CheckAliveInterval = value\n\t}\n\n\treturn nil\n}\n\n// ParsePeers parses the [Peer] section and extract the information into `peers`\nfunc ParsePeers(cfg *ini.File, peers *[]PeerConfig) error {\n\tsections, err := cfg.SectionsByName(\"Peer\")\n\tif len(sections) < 1 || err != nil {\n\t\treturn errors.New(\"at least one [Peer] is expected\")\n\t}\n\n\tfor _, section := range sections {\n\t\tpeer := PeerConfig{\n\t\t\tPreSharedKey: \"0000000000000000000000000000000000000000000000000000000000000000\",\n\t\t\tKeepAlive:    0,\n\t\t}\n\n\t\tdecoded, err := parseBase64KeyToHex(section, \"PublicKey\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpeer.PublicKey = decoded\n\n\t\tif sectionKey, err := section.GetKey(\"PreSharedKey\"); err == nil {\n\t\t\tvalue, err := encodeBase64ToHex(sectionKey.String())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpeer.PreSharedKey = value\n\t\t}\n\n\t\tif value, err := parseString(section, \"Endpoint\"); err == nil {\n\t\t\tdecoded, err = resolveIPPAndPort(strings.ToLower(value))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpeer.Endpoint = &decoded\n\t\t}\n\n\t\tif sectionKey, err := section.GetKey(\"PersistentKeepalive\"); err == nil {\n\t\t\tvalue, err := sectionKey.Int()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpeer.KeepAlive = value\n\t\t}\n\n\t\tpeer.AllowedIPs, err = parseAllowedIPs(section)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*peers = append(*peers, peer)\n\t}\n\treturn nil\n}\n\nfunc parseTCPClientTunnelConfig(section *ini.Section) (RoutineSpawner, error) {\n\tconfig := &TCPClientTunnelConfig{}\n\ttcpAddr, err := parseTCPAddr(section, \"BindAddress\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.BindAddress = tcpAddr\n\n\ttargetSection, err := parseString(section, \"Target\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.Target = targetSection\n\n\treturn config, nil\n}\n\nfunc parseSTDIOTunnelConfig(section *ini.Section) (RoutineSpawner, error) {\n\tconfig := &STDIOTunnelConfig{}\n\ttargetSection, err := parseString(section, \"Target\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.Target = targetSection\n\n\treturn config, nil\n}\n\nfunc parseTCPServerTunnelConfig(section *ini.Section) (RoutineSpawner, error) {\n\tconfig := &TCPServerTunnelConfig{}\n\n\tlistenPort, err := parsePort(section, \"ListenPort\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.ListenPort = listenPort\n\n\ttarget, err := parseString(section, \"Target\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.Target = target\n\n\treturn config, nil\n}\n\nfunc parseSocks5Config(section *ini.Section) (RoutineSpawner, error) {\n\tconfig := &Socks5Config{}\n\n\tbindAddress, err := parseString(section, \"BindAddress\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.BindAddress = bindAddress\n\n\tusername, _ := parseString(section, \"Username\")\n\tconfig.Username = username\n\n\tpassword, _ := parseString(section, \"Password\")\n\tconfig.Password = password\n\n\treturn config, nil\n}\n\nfunc parseHTTPConfig(section *ini.Section) (RoutineSpawner, error) {\n\tconfig := &HTTPConfig{}\n\n\tbindAddress, err := parseString(section, \"BindAddress\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig.BindAddress = bindAddress\n\n\tusername, _ := parseString(section, \"Username\")\n\tconfig.Username = username\n\n\tpassword, _ := parseString(section, \"Password\")\n\tconfig.Password = password\n\n\treturn config, nil\n}\n\n// Takes a function that parses an individual section into a config, and apply it on all\n// specified sections\nfunc parseRoutinesConfig(routines *[]RoutineSpawner, cfg *ini.File, sectionName string, f func(*ini.Section) (RoutineSpawner, error)) error {\n\tsections, err := cfg.SectionsByName(sectionName)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tfor _, section := range sections {\n\t\tconfig, err := f(section)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t*routines = append(*routines, config)\n\t}\n\n\treturn nil\n}\n\n// ParseConfig takes the path of a configuration file and parses it into Configuration\nfunc ParseConfig(path string) (*Configuration, error) {\n\tiniOpt := ini.LoadOptions{\n\t\tInsensitive:            true,\n\t\tAllowShadows:           true,\n\t\tAllowNonUniqueSections: true,\n\t}\n\n\tcfg, err := ini.LoadSources(iniOpt, path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdevice := &DeviceConfig{\n\t\tMTU: 1420,\n\t}\n\n\troot := cfg.Section(\"\")\n\twgConf, err := root.GetKey(\"WGConfig\")\n\twgCfg := cfg\n\tif err == nil {\n\t\twgCfg, err = ini.LoadSources(iniOpt, wgConf.String())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = ParseInterface(wgCfg, device)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = ParsePeers(wgCfg, &device.Peers)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar routinesSpawners []RoutineSpawner\n\n\terr = parseRoutinesConfig(&routinesSpawners, cfg, \"TCPClientTunnel\", parseTCPClientTunnelConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = parseRoutinesConfig(&routinesSpawners, cfg, \"STDIOTunnel\", parseSTDIOTunnelConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = parseRoutinesConfig(&routinesSpawners, cfg, \"TCPServerTunnel\", parseTCPServerTunnelConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = parseRoutinesConfig(&routinesSpawners, cfg, \"Socks5\", parseSocks5Config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = parseRoutinesConfig(&routinesSpawners, cfg, \"http\", parseHTTPConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Configuration{\n\t\tDevice:   device,\n\t\tRoutines: routinesSpawners,\n\t}, nil\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 1.7822265625,
          "content": "package wireproxy\n\nimport (\n\t\"github.com/go-ini/ini\"\n\t\"testing\"\n)\n\nfunc loadIniConfig(config string) (*ini.File, error) {\n\tiniOpt := ini.LoadOptions{\n\t\tInsensitive:            true,\n\t\tAllowShadows:           true,\n\t\tAllowNonUniqueSections: true,\n\t}\n\n\treturn ini.LoadSources(iniOpt, []byte(config))\n}\n\nfunc TestWireguardConfWithoutSubnet(t *testing.T) {\n\tconst config = `\n[Interface]\nPrivateKey = LAr1aNSNF9d0MjwUgAVC4020T0N/E5NUtqVv5EnsSz0=\nAddress = 10.5.0.2\nDNS = 1.1.1.1\n\n[Peer]\nPublicKey = e8LKAc+f9xEzq9Ar7+MfKRrs+gZ/4yzvpRJLRJ/VJ1w=\nAllowedIPs = 0.0.0.0/0, ::/0\nEndpoint = 94.140.11.15:51820\nPersistentKeepalive = 25`\n\tvar cfg DeviceConfig\n\tiniData, err := loadIniConfig(config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = ParseInterface(iniData, &cfg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestWireguardConfWithSubnet(t *testing.T) {\n\tconst config = `\n[Interface]\nPrivateKey = LAr1aNSNF9d0MjwUgAVC4020T0N/E5NUtqVv5EnsSz0=\nAddress = 10.5.0.2/23\nDNS = 1.1.1.1\n\n[Peer]\nPublicKey = e8LKAc+f9xEzq9Ar7+MfKRrs+gZ/4yzvpRJLRJ/VJ1w=\nAllowedIPs = 0.0.0.0/0, ::/0\nEndpoint = 94.140.11.15:51820\nPersistentKeepalive = 25`\n\tvar cfg DeviceConfig\n\tiniData, err := loadIniConfig(config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = ParseInterface(iniData, &cfg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestWireguardConfWithManyAddress(t *testing.T) {\n\tconst config = `\n[Interface]\nPrivateKey = mBsVDahr1XIu9PPd17UmsDdB6E53nvmS47NbNqQCiFM=\nAddress = 100.96.0.190,2606:B300:FFFF:fe8a:2ac6:c7e8:b021:6f5f/128\nDNS = 198.18.0.1,198.18.0.2\n\n[Peer]\nPublicKey = SHnh4C2aDXhp1gjIqceGhJrhOLSeNYcqWLKcYnzj00U=\nAllowedIPs = 0.0.0.0/0,::/0\nEndpoint = 192.200.144.22:51820`\n\tvar cfg DeviceConfig\n\tiniData, err := loadIniConfig(config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = ParseInterface(iniData, &cfg)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.8154296875,
          "content": "module github.com/pufferffish/wireproxy\n\ngo 1.21.1\n\ntoolchain go1.21.6\n\nrequire (\n\tgithub.com/MakeNowJust/heredoc/v2 v2.0.1\n\tgithub.com/akamensky/argparse v1.4.0\n\tgithub.com/go-ini/ini v1.67.0\n\tgithub.com/landlock-lsm/go-landlock v0.0.0-20240216195629-efb66220540a\n\tgithub.com/sourcegraph/conc v0.3.0\n\tgithub.com/things-go/go-socks5 v0.0.5\n\tgolang.org/x/net v0.23.0\n\tgolang.zx2c4.com/wireguard v0.0.0-20231211153847-12269c276173\n\tsuah.dev/protect v1.2.3\n)\n\nrequire (\n\tgithub.com/google/btree v1.1.2 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/time v0.5.0 // indirect\n\tgolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2 // indirect\n\tgvisor.dev/gvisor v0.0.0-20230927004350-cbd86285d259 // indirect\n\tkernel.org/pub/linux/libs/security/libcap/psx v1.2.69 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.5888671875,
          "content": "github.com/MakeNowJust/heredoc/v2 v2.0.1 h1:rlCHh70XXXv7toz95ajQWOWQnN4WNLt0TdpZYIR/J6A=\ngithub.com/MakeNowJust/heredoc/v2 v2.0.1/go.mod h1:6/2Abh5s+hc3g9nbWLe9ObDIOhaRrqsyY9MWy+4JdRM=\ngithub.com/akamensky/argparse v1.4.0 h1:YGzvsTqCvbEZhL8zZu2AiA5nq805NZh75JNj4ajn1xc=\ngithub.com/akamensky/argparse v1.4.0/go.mod h1:S5kwC7IuDcEr5VeXtGPRVZ5o/FdhcMlQz4IZQuw64xA=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-ini/ini v1.67.0 h1:z6ZrTEZqSWOTyH2FlglNbNgARyHG8oLW9gMELqKr06A=\ngithub.com/go-ini/ini v1.67.0/go.mod h1:ByCAeIL28uOIIG0E3PJtZPDL8WnHpFKFOtgjp+3Ies8=\ngithub.com/google/btree v1.1.2 h1:xf4v41cLI2Z6FxbKm+8Bu+m8ifhj15JuZ9sa0jZCMUU=\ngithub.com/google/btree v1.1.2/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=\ngithub.com/landlock-lsm/go-landlock v0.0.0-20240216195629-efb66220540a h1:dz+a1MiMQksVhejeZwqJuzPawYQBwug74J8PPtkLl9U=\ngithub.com/landlock-lsm/go-landlock v0.0.0-20240216195629-efb66220540a/go.mod h1:1NY/VPO8xm3hXw3f+M65z+PJDLUaZA5cu7OfanxoUzY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=\ngithub.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/things-go/go-socks5 v0.0.5 h1:qvKaGcBkfDrUL33SchHN93srAmYGzb4CxSM2DPYufe8=\ngithub.com/things-go/go-socks5 v0.0.5/go.mod h1:mtzInf8v5xmsBpHZVbIw2YQYhc4K0jRwzfsH64Uh0IQ=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\ngolang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2 h1:B82qJJgjvYKsXS9jeunTOisW56dUokqW/FOteYJJ/yg=\ngolang.zx2c4.com/wintun v0.0.0-20230126152724-0fa3db229ce2/go.mod h1:deeaetjYA+DHMHg+sMSMI58GrEteJUUzzw7en6TJQcI=\ngolang.zx2c4.com/wireguard v0.0.0-20231211153847-12269c276173 h1:/jFs0duh4rdb8uIfPMv78iAJGcPKDeqAFnaLBropIC4=\ngolang.zx2c4.com/wireguard v0.0.0-20231211153847-12269c276173/go.mod h1:tkCQ4FQXmpAgYVh++1cq16/dH4QJtmvpRv19DWGAHSA=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngvisor.dev/gvisor v0.0.0-20230927004350-cbd86285d259 h1:TbRPT0HtzFP3Cno1zZo7yPzEEnfu8EjLfl6IU9VfqkQ=\ngvisor.dev/gvisor v0.0.0-20230927004350-cbd86285d259/go.mod h1:AVgIgHMwK63XvmAzWG9vLQ41YnVHN0du0tEC46fI7yY=\nkernel.org/pub/linux/libs/security/libcap/psx v1.2.69 h1:IdrOs1ZgwGw5CI+BH6GgVVlOt+LAXoPyh7enr8lfaXs=\nkernel.org/pub/linux/libs/security/libcap/psx v1.2.69/go.mod h1:+l6Ee2F59XiJ2I6WR5ObpC1utCQJZ/VLsEbQCD8RG24=\nsuah.dev/protect v1.2.3 h1:aHeoNwZ9YPp64hrYaN0g0djNE1eRujgH63CrfRrUKdc=\nsuah.dev/protect v1.2.3/go.mod h1:n1R3XIbsnryKX7C1PO88i5Wgo0v8OTXm9K9FIKt4rfs=\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 3.5341796875,
          "content": "package wireproxy\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/sourcegraph/conc\"\n)\n\nconst proxyAuthHeaderKey = \"Proxy-Authorization\"\n\ntype HTTPServer struct {\n\tconfig *HTTPConfig\n\n\tauth CredentialValidator\n\tdial func(network, address string) (net.Conn, error)\n\n\tauthRequired bool\n}\n\nfunc (s *HTTPServer) authenticate(req *http.Request) (int, error) {\n\tif !s.authRequired {\n\t\treturn 0, nil\n\t}\n\n\tauth := req.Header.Get(proxyAuthHeaderKey)\n\tif auth == \"\" {\n\t\treturn http.StatusProxyAuthRequired, fmt.Errorf(http.StatusText(http.StatusProxyAuthRequired))\n\t}\n\n\tenc := strings.TrimPrefix(auth, \"Basic \")\n\tstr, err := base64.StdEncoding.DecodeString(enc)\n\tif err != nil {\n\t\treturn http.StatusNotAcceptable, fmt.Errorf(\"decode username and password failed: %w\", err)\n\t}\n\tpairs := bytes.SplitN(str, []byte(\":\"), 2)\n\tif len(pairs) != 2 {\n\t\treturn http.StatusLengthRequired, fmt.Errorf(\"username and password format invalid\")\n\t}\n\tif s.auth.Valid(string(pairs[0]), string(pairs[1])) {\n\t\treturn 0, nil\n\t}\n\treturn http.StatusUnauthorized, fmt.Errorf(\"username and password not matching\")\n}\n\nfunc (s *HTTPServer) handleConn(req *http.Request, conn net.Conn) (peer net.Conn, err error) {\n\taddr := req.Host\n\tif !strings.Contains(addr, \":\") {\n\t\tport := \"443\"\n\t\taddr = net.JoinHostPort(addr, port)\n\t}\n\n\tpeer, err = s.dial(\"tcp\", addr)\n\tif err != nil {\n\t\treturn peer, fmt.Errorf(\"tun tcp dial failed: %w\", err)\n\t}\n\n\t_, err = conn.Write([]byte(\"HTTP/1.1 200 Connection established\\r\\n\\r\\n\"))\n\tif err != nil {\n\t\t_ = peer.Close()\n\t\tpeer = nil\n\t}\n\n\treturn\n}\n\nfunc (s *HTTPServer) handle(req *http.Request) (peer net.Conn, err error) {\n\taddr := req.Host\n\tif !strings.Contains(addr, \":\") {\n\t\tport := \"80\"\n\t\taddr = net.JoinHostPort(addr, port)\n\t}\n\n\tpeer, err = s.dial(\"tcp\", addr)\n\tif err != nil {\n\t\treturn peer, fmt.Errorf(\"tun tcp dial failed: %w\", err)\n\t}\n\n\terr = req.Write(peer)\n\tif err != nil {\n\t\t_ = peer.Close()\n\t\tpeer = nil\n\t\treturn peer, fmt.Errorf(\"conn write failed: %w\", err)\n\t}\n\n\treturn\n}\n\nfunc (s *HTTPServer) serve(conn net.Conn) {\n\tvar rd = bufio.NewReader(conn)\n\treq, err := http.ReadRequest(rd)\n\tif err != nil {\n\t\tlog.Printf(\"read request failed: %s\\n\", err)\n\t\treturn\n\t}\n\n\tcode, err := s.authenticate(req)\n\tif err != nil {\n\t\tresp := responseWith(req, code)\n\t\tif code == http.StatusProxyAuthRequired {\n\t\t\tresp.Header.Set(\"Proxy-Authenticate\", \"Basic realm=\\\"Proxy\\\"\")\n\t\t}\n\t\t_ = resp.Write(conn)\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\n\tvar peer net.Conn\n\tswitch req.Method {\n\tcase http.MethodConnect:\n\t\tpeer, err = s.handleConn(req, conn)\n\tcase http.MethodGet:\n\t\tpeer, err = s.handle(req)\n\tdefault:\n\t\t_ = responseWith(req, http.StatusMethodNotAllowed).Write(conn)\n\t\tlog.Printf(\"unsupported protocol: %s\\n\", req.Method)\n\t\treturn\n\t}\n\tif err != nil {\n\t\tlog.Printf(\"dial proxy failed: %s\\n\", err)\n\t\treturn\n\t}\n\tif peer == nil {\n\t\tlog.Println(\"dial proxy failed: peer nil\")\n\t\treturn\n\t}\n\tgo func() {\n\t\twg := conc.NewWaitGroup()\n\t\twg.Go(func() {\n\t\t\t_, err = io.Copy(conn, peer)\n\t\t\t_ = conn.Close()\n\t\t})\n\t\twg.Go(func() {\n\t\t\t_, err = io.Copy(peer, conn)\n\t\t\t_ = peer.Close()\n\t\t})\n\t\twg.Wait()\n\t}()\n}\n\n// ListenAndServe is used to create a listener and serve on it\nfunc (s *HTTPServer) ListenAndServe(network, addr string) error {\n\tserver, err := net.Listen(network, addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"listen tcp failed: %w\", err)\n\t}\n\tdefer func(server net.Listener) {\n\t\t_ = server.Close()\n\t}(server)\n\tfor {\n\t\tconn, err := server.Accept()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"accept request failed: %w\", err)\n\t\t}\n\t\tgo func(conn net.Conn) {\n\t\t\ts.serve(conn)\n\t\t}(conn)\n\t}\n}\n"
        },
        {
          "name": "net.go",
          "type": "blob",
          "size": 0.259765625,
          "content": "// will delete when upgrading to go 1.18\n\npackage wireproxy\n\nimport (\n\t\"net\"\n\t\"net/netip\"\n)\n\nfunc TCPAddrFromAddrPort(addr netip.AddrPort) *net.TCPAddr {\n\treturn &net.TCPAddr{\n\t\tIP:   addr.Addr().AsSlice(),\n\t\tZone: addr.Addr().Zone(),\n\t\tPort: int(addr.Port()),\n\t}\n}\n"
        },
        {
          "name": "routine.go",
          "type": "blob",
          "size": 12.55859375,
          "content": "package wireproxy\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\tsrand \"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"golang.org/x/net/icmp\"\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/net/ipv6\"\n\t\"golang.zx2c4.com/wireguard/device\"\n\t\"io\"\n\t\"log\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/sourcegraph/conc\"\n\t\"github.com/things-go/go-socks5\"\n\t\"github.com/things-go/go-socks5/bufferpool\"\n\n\t\"net/netip\"\n\n\t\"golang.zx2c4.com/wireguard/tun/netstack\"\n)\n\n// errorLogger is the logger to print error message\nvar errorLogger = log.New(os.Stderr, \"ERROR: \", log.LstdFlags)\n\n// CredentialValidator stores the authentication data of a socks5 proxy\ntype CredentialValidator struct {\n\tusername string\n\tpassword string\n}\n\n// VirtualTun stores a reference to netstack network and DNS configuration\ntype VirtualTun struct {\n\tTnet      *netstack.Net\n\tDev       *device.Device\n\tSystemDNS bool\n\tConf      *DeviceConfig\n\t// PingRecord stores the last time an IP was pinged\n\tPingRecord     map[string]uint64\n\tPingRecordLock *sync.Mutex\n}\n\n// RoutineSpawner spawns a routine (e.g. socks5, tcp static routes) after the configuration is parsed\ntype RoutineSpawner interface {\n\tSpawnRoutine(vt *VirtualTun)\n}\n\ntype addressPort struct {\n\taddress string\n\tport    uint16\n}\n\n// LookupAddr lookups a hostname.\n// DNS traffic may or may not be routed depending on VirtualTun's setting\nfunc (d VirtualTun) LookupAddr(ctx context.Context, name string) ([]string, error) {\n\tif d.SystemDNS {\n\t\treturn net.DefaultResolver.LookupHost(ctx, name)\n\t}\n\treturn d.Tnet.LookupContextHost(ctx, name)\n}\n\n// ResolveAddrWithContext resolves a hostname and returns an AddrPort.\n// DNS traffic may or may not be routed depending on VirtualTun's setting\nfunc (d VirtualTun) ResolveAddrWithContext(ctx context.Context, name string) (*netip.Addr, error) {\n\taddrs, err := d.LookupAddr(ctx, name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsize := len(addrs)\n\tif size == 0 {\n\t\treturn nil, errors.New(\"no address found for: \" + name)\n\t}\n\n\trand.Shuffle(size, func(i, j int) {\n\t\taddrs[i], addrs[j] = addrs[j], addrs[i]\n\t})\n\n\tvar addr netip.Addr\n\tfor _, saddr := range addrs {\n\t\taddr, err = netip.ParseAddr(saddr)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &addr, nil\n}\n\n// Resolve resolves a hostname and returns an IP.\n// DNS traffic may or may not be routed depending on VirtualTun's setting\nfunc (d VirtualTun) Resolve(ctx context.Context, name string) (context.Context, net.IP, error) {\n\taddr, err := d.ResolveAddrWithContext(ctx, name)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn ctx, addr.AsSlice(), nil\n}\n\nfunc parseAddressPort(endpoint string) (*addressPort, error) {\n\tname, sport, err := net.SplitHostPort(endpoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tport, err := strconv.Atoi(sport)\n\tif err != nil || port < 0 || port > 65535 {\n\t\treturn nil, &net.OpError{Op: \"dial\", Err: errors.New(\"port must be numeric\")}\n\t}\n\n\treturn &addressPort{address: name, port: uint16(port)}, nil\n}\n\nfunc (d VirtualTun) resolveToAddrPort(endpoint *addressPort) (*netip.AddrPort, error) {\n\taddr, err := d.ResolveAddrWithContext(context.Background(), endpoint.address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\taddrPort := netip.AddrPortFrom(*addr, endpoint.port)\n\treturn &addrPort, nil\n}\n\n// SpawnRoutine spawns a socks5 server.\nfunc (config *Socks5Config) SpawnRoutine(vt *VirtualTun) {\n\tvar authMethods []socks5.Authenticator\n\tif username := config.Username; username != \"\" {\n\t\tauthMethods = append(authMethods, socks5.UserPassAuthenticator{\n\t\t\tCredentials: socks5.StaticCredentials{username: config.Password},\n\t\t})\n\t} else {\n\t\tauthMethods = append(authMethods, socks5.NoAuthAuthenticator{})\n\t}\n\n\toptions := []socks5.Option{\n\t\tsocks5.WithDial(vt.Tnet.DialContext),\n\t\tsocks5.WithResolver(vt),\n\t\tsocks5.WithAuthMethods(authMethods),\n\t\tsocks5.WithBufferPool(bufferpool.NewPool(256 * 1024)),\n\t}\n\n\tserver := socks5.NewServer(options...)\n\n\tif err := server.ListenAndServe(\"tcp\", config.BindAddress); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// SpawnRoutine spawns a http server.\nfunc (config *HTTPConfig) SpawnRoutine(vt *VirtualTun) {\n\tserver := &HTTPServer{\n\t\tconfig: config,\n\t\tdial:   vt.Tnet.Dial,\n\t\tauth:   CredentialValidator{config.Username, config.Password},\n\t}\n\tif config.Username != \"\" || config.Password != \"\" {\n\t\tserver.authRequired = true\n\t}\n\n\tif err := server.ListenAndServe(\"tcp\", config.BindAddress); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// Valid checks the authentication data in CredentialValidator and compare them\n// to username and password in constant time.\nfunc (c CredentialValidator) Valid(username, password string) bool {\n\tu := subtle.ConstantTimeCompare([]byte(c.username), []byte(username))\n\tp := subtle.ConstantTimeCompare([]byte(c.password), []byte(password))\n\treturn u&p == 1\n}\n\n// connForward copy data from `from` to `to`\nfunc connForward(from io.ReadWriteCloser, to io.ReadWriteCloser) {\n\t_, err := io.Copy(to, from)\n\tif err != nil {\n\t\terrorLogger.Printf(\"Cannot forward traffic: %s\\n\", err.Error())\n\t}\n}\n\n// tcpClientForward starts a new connection via wireguard and forward traffic from `conn`\nfunc tcpClientForward(vt *VirtualTun, raddr *addressPort, conn net.Conn) {\n\ttarget, err := vt.resolveToAddrPort(raddr)\n\tif err != nil {\n\t\terrorLogger.Printf(\"TCP Server Tunnel to %s: %s\\n\", target, err.Error())\n\t\treturn\n\t}\n\n\ttcpAddr := TCPAddrFromAddrPort(*target)\n\n\tsconn, err := vt.Tnet.DialTCP(tcpAddr)\n\tif err != nil {\n\t\terrorLogger.Printf(\"TCP Client Tunnel to %s: %s\\n\", target, err.Error())\n\t\treturn\n\t}\n\n\tgo func() {\n\t\twg := conc.NewWaitGroup()\n\t\twg.Go(func() {\n\t\t\tconnForward(sconn, conn)\n\t\t})\n\t\twg.Go(func() {\n\t\t\tconnForward(conn, sconn)\n\t\t})\n\t\twg.Wait()\n\t\t_ = sconn.Close()\n\t\t_ = conn.Close()\n\t\tsconn = nil\n\t\tconn = nil\n\t}()\n}\n\n// STDIOTcpForward starts a new connection via wireguard and forward traffic from `conn`\nfunc STDIOTcpForward(vt *VirtualTun, raddr *addressPort) {\n\ttarget, err := vt.resolveToAddrPort(raddr)\n\tif err != nil {\n\t\terrorLogger.Printf(\"Name resolution error for %s: %s\\n\", raddr.address, err.Error())\n\t\treturn\n\t}\n\n\t// os.Stdout has previously been remapped to stderr, se we can't use it\n\tstdout, err := os.OpenFile(\"/dev/stdout\", os.O_WRONLY, 0)\n\tif err != nil {\n\t\terrorLogger.Printf(\"Failed to open /dev/stdout: %s\\n\", err.Error())\n\t\treturn\n\t}\n\n\ttcpAddr := TCPAddrFromAddrPort(*target)\n\tsconn, err := vt.Tnet.DialTCP(tcpAddr)\n\tif err != nil {\n\t\terrorLogger.Printf(\"TCP Client Tunnel to %s (%s): %s\\n\", target, tcpAddr, err.Error())\n\t\treturn\n\t}\n\n\tgo func() {\n\t\twg := conc.NewWaitGroup()\n\t\twg.Go(func() {\n\t\t\tconnForward(os.Stdin, sconn)\n\t\t})\n\t\twg.Go(func() {\n\t\t\tconnForward(sconn, stdout)\n\t\t})\n\t\twg.Wait()\n\t\t_ = sconn.Close()\n\t\tsconn = nil\n\t}()\n}\n\n// SpawnRoutine spawns a local TCP server which acts as a proxy to the specified target\nfunc (conf *TCPClientTunnelConfig) SpawnRoutine(vt *VirtualTun) {\n\traddr, err := parseAddressPort(conf.Target)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tserver, err := net.ListenTCP(\"tcp\", conf.BindAddress)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor {\n\t\tconn, err := server.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo tcpClientForward(vt, raddr, conn)\n\t}\n}\n\n// SpawnRoutine connects to the specified target and plumbs it to STDIN / STDOUT\nfunc (conf *STDIOTunnelConfig) SpawnRoutine(vt *VirtualTun) {\n\traddr, err := parseAddressPort(conf.Target)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tgo STDIOTcpForward(vt, raddr)\n}\n\n// tcpServerForward starts a new connection locally and forward traffic from `conn`\nfunc tcpServerForward(vt *VirtualTun, raddr *addressPort, conn net.Conn) {\n\ttarget, err := vt.resolveToAddrPort(raddr)\n\tif err != nil {\n\t\terrorLogger.Printf(\"TCP Server Tunnel to %s: %s\\n\", target, err.Error())\n\t\treturn\n\t}\n\n\ttcpAddr := TCPAddrFromAddrPort(*target)\n\n\tsconn, err := net.DialTCP(\"tcp\", nil, tcpAddr)\n\tif err != nil {\n\t\terrorLogger.Printf(\"TCP Server Tunnel to %s: %s\\n\", target, err.Error())\n\t\treturn\n\t}\n\n\tgo func() {\n\t\tgr := conc.NewWaitGroup()\n\t\tgr.Go(func() {\n\t\t\tconnForward(sconn, conn)\n\t\t})\n\t\tgr.Go(func() {\n\t\t\tconnForward(conn, sconn)\n\t\t})\n\t\tgr.Wait()\n\t\t_ = sconn.Close()\n\t\t_ = conn.Close()\n\t\tsconn = nil\n\t\tconn = nil\n\t}()\n}\n\n// SpawnRoutine spawns a TCP server on wireguard which acts as a proxy to the specified target\nfunc (conf *TCPServerTunnelConfig) SpawnRoutine(vt *VirtualTun) {\n\traddr, err := parseAddressPort(conf.Target)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\taddr := &net.TCPAddr{Port: conf.ListenPort}\n\tserver, err := vt.Tnet.ListenTCP(addr)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor {\n\t\tconn, err := server.Accept()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tgo tcpServerForward(vt, raddr, conn)\n\t}\n}\n\nfunc (d VirtualTun) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tlog.Printf(\"Health metric request: %s\\n\", r.URL.Path)\n\tswitch path.Clean(r.URL.Path) {\n\tcase \"/readyz\":\n\t\tbody, err := json.Marshal(d.PingRecord)\n\t\tif err != nil {\n\t\t\terrorLogger.Printf(\"Failed to get device metrics: %s\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tstatus := http.StatusOK\n\t\tfor _, record := range d.PingRecord {\n\t\t\tlastPong := time.Unix(int64(record), 0)\n\t\t\t// +2 seconds to account for the time it takes to ping the IP\n\t\t\tif time.Since(lastPong) > time.Duration(d.Conf.CheckAliveInterval+2)*time.Second {\n\t\t\t\tstatus = http.StatusServiceUnavailable\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tw.WriteHeader(status)\n\t\t_, _ = w.Write(body)\n\t\t_, _ = w.Write([]byte(\"\\n\"))\n\tcase \"/metrics\":\n\t\tget, err := d.Dev.IpcGet()\n\t\tif err != nil {\n\t\t\terrorLogger.Printf(\"Failed to get device metrics: %s\\n\", err.Error())\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tvar buf bytes.Buffer\n\t\tfor _, peer := range strings.Split(get, \"\\n\") {\n\t\t\tpair := strings.SplitN(peer, \"=\", 2)\n\t\t\tif len(pair) != 2 {\n\t\t\t\tbuf.WriteString(peer)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pair[0] == \"private_key\" || pair[0] == \"preshared_key\" {\n\t\t\t\tpair[1] = \"REDACTED\"\n\t\t\t}\n\t\t\tbuf.WriteString(pair[0])\n\t\t\tbuf.WriteString(\"=\")\n\t\t\tbuf.WriteString(pair[1])\n\t\t\tbuf.WriteString(\"\\n\")\n\t\t}\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, _ = w.Write(buf.Bytes())\n\tdefault:\n\t\tw.WriteHeader(http.StatusNotFound)\n\t}\n}\n\nfunc (d VirtualTun) pingIPs() {\n\tfor _, addr := range d.Conf.CheckAlive {\n\t\tsocket, err := d.Tnet.Dial(\"ping\", addr.String())\n\t\tif err != nil {\n\t\t\terrorLogger.Printf(\"Failed to ping %s: %s\\n\", addr, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tdata := make([]byte, 16)\n\t\t_, _ = srand.Read(data)\n\n\t\trequestPing := icmp.Echo{\n\t\t\tSeq:  rand.Intn(1 << 16),\n\t\t\tData: data,\n\t\t}\n\n\t\tvar icmpBytes []byte\n\t\tif addr.Is4() {\n\t\t\ticmpBytes, _ = (&icmp.Message{Type: ipv4.ICMPTypeEcho, Code: 0, Body: &requestPing}).Marshal(nil)\n\t\t} else if addr.Is6() {\n\t\t\ticmpBytes, _ = (&icmp.Message{Type: ipv6.ICMPTypeEchoRequest, Code: 0, Body: &requestPing}).Marshal(nil)\n\t\t} else {\n\t\t\terrorLogger.Printf(\"Failed to ping %s: invalid address: %s\\n\", addr, addr.String())\n\t\t\tcontinue\n\t\t}\n\n\t\t_ = socket.SetReadDeadline(time.Now().Add(time.Duration(d.Conf.CheckAliveInterval) * time.Second))\n\t\t_, err = socket.Write(icmpBytes)\n\t\tif err != nil {\n\t\t\terrorLogger.Printf(\"Failed to ping %s: %s\\n\", addr, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\taddr := addr\n\t\tgo func() {\n\t\t\tn, err := socket.Read(icmpBytes[:])\n\t\t\tif err != nil {\n\t\t\t\terrorLogger.Printf(\"Failed to read ping response from %s: %s\\n\", addr, err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treplyPacket, err := icmp.ParseMessage(1, icmpBytes[:n])\n\t\t\tif err != nil {\n\t\t\t\terrorLogger.Printf(\"Failed to parse ping response from %s: %s\\n\", addr, err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif addr.Is4() {\n\t\t\t\treplyPing, ok := replyPacket.Body.(*icmp.Echo)\n\t\t\t\tif !ok {\n\t\t\t\t\terrorLogger.Printf(\"Failed to parse ping response from %s: invalid reply type: %s\\n\", addr, replyPacket.Type)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !bytes.Equal(replyPing.Data, requestPing.Data) || replyPing.Seq != requestPing.Seq {\n\t\t\t\t\terrorLogger.Printf(\"Failed to parse ping response from %s: invalid ping reply: %v\\n\", addr, replyPing)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif addr.Is6() {\n\t\t\t\treplyPing, ok := replyPacket.Body.(*icmp.RawBody)\n\t\t\t\tif !ok {\n\t\t\t\t\terrorLogger.Printf(\"Failed to parse ping response from %s: invalid reply type: %s\\n\", addr, replyPacket.Type)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tseq := binary.BigEndian.Uint16(replyPing.Data[2:4])\n\t\t\t\tpongBody := replyPing.Data[4:]\n\t\t\t\tif !bytes.Equal(pongBody, requestPing.Data) || int(seq) != requestPing.Seq {\n\t\t\t\t\terrorLogger.Printf(\"Failed to parse ping response from %s: invalid ping reply: %v\\n\", addr, replyPing)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\td.PingRecordLock.Lock()\n\t\t\td.PingRecord[addr.String()] = uint64(time.Now().Unix())\n\t\t\td.PingRecordLock.Unlock()\n\n\t\t\tdefer socket.Close()\n\t\t}()\n\t}\n}\n\nfunc (d VirtualTun) StartPingIPs() {\n\tfor _, addr := range d.Conf.CheckAlive {\n\t\td.PingRecord[addr.String()] = 0\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\td.pingIPs()\n\t\t\ttime.Sleep(time.Duration(d.Conf.CheckAliveInterval) * time.Second)\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "systemd",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_config.sh",
          "type": "blob",
          "size": 0.5302734375,
          "content": "#!/usr/bin/env bash\nset -e\nexec 3<>/dev/tcp/demo.wireguard.com/42912\nprivatekey=\"$(wg genkey)\"\nwg pubkey <<<\"$privatekey\" >&3\nIFS=: read -r status server_pubkey server_port internal_ip <&3\n[[ $status == OK ]]\ncat >test.conf <<EOL\n[Interface]\nAddress = $internal_ip/32\nPrivateKey = $privatekey\nDNS = 8.8.8.8\n\n[Peer]\nPublicKey = $server_pubkey\nEndpoint = demo.wireguard.com:$server_port\n\n[Socks5]\nBindAddress = 127.0.0.1:64423\n\n[http]\nBindAddress = 127.0.0.1:64424\n\n[http]\nBindAddress = 127.0.0.1:64425\nUsername = peter\nPassword = hunter123\nEOL\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 0.5478515625,
          "content": "package wireproxy\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nconst space = \" \"\n\nfunc responseWith(req *http.Request, statusCode int) *http.Response {\n\tstatusText := http.StatusText(statusCode)\n\tbody := \"wireproxy:\" + space + req.Proto + space + strconv.Itoa(statusCode) + space + statusText + \"\\r\\n\"\n\n\treturn &http.Response{\n\t\tStatusCode: statusCode,\n\t\tStatus:     statusText,\n\t\tProto:      req.Proto,\n\t\tProtoMajor: req.ProtoMajor,\n\t\tProtoMinor: req.ProtoMinor,\n\t\tHeader:     http.Header{},\n\t\tBody:       io.NopCloser(bytes.NewBufferString(body)),\n\t}\n}\n"
        },
        {
          "name": "wireguard.go",
          "type": "blob",
          "size": 2.22265625,
          "content": "package wireproxy\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"sync\"\n\n\t\"net/netip\"\n\n\t\"github.com/MakeNowJust/heredoc/v2\"\n\t\"golang.zx2c4.com/wireguard/conn\"\n\t\"golang.zx2c4.com/wireguard/device\"\n\t\"golang.zx2c4.com/wireguard/tun/netstack\"\n)\n\n// DeviceSetting contains the parameters for setting up a tun interface\ntype DeviceSetting struct {\n\tIpcRequest string\n\tDNS        []netip.Addr\n\tDeviceAddr []netip.Addr\n\tMTU        int\n}\n\n// CreateIPCRequest serialize the config into an IPC request and DeviceSetting\nfunc CreateIPCRequest(conf *DeviceConfig) (*DeviceSetting, error) {\n\tvar request bytes.Buffer\n\n\trequest.WriteString(fmt.Sprintf(\"private_key=%s\\n\", conf.SecretKey))\n\n\tif conf.ListenPort != nil {\n\t\trequest.WriteString(fmt.Sprintf(\"listen_port=%d\\n\", *conf.ListenPort))\n\t}\n\n\tfor _, peer := range conf.Peers {\n\t\trequest.WriteString(fmt.Sprintf(heredoc.Doc(`\n\t\t\t\tpublic_key=%s\n\t\t\t\tpersistent_keepalive_interval=%d\n\t\t\t\tpreshared_key=%s\n\t\t\t`),\n\t\t\tpeer.PublicKey, peer.KeepAlive, peer.PreSharedKey,\n\t\t))\n\t\tif peer.Endpoint != nil {\n\t\t\trequest.WriteString(fmt.Sprintf(\"endpoint=%s\\n\", *peer.Endpoint))\n\t\t}\n\n\t\tif len(peer.AllowedIPs) > 0 {\n\t\t\tfor _, ip := range peer.AllowedIPs {\n\t\t\t\trequest.WriteString(fmt.Sprintf(\"allowed_ip=%s\\n\", ip.String()))\n\t\t\t}\n\t\t} else {\n\t\t\trequest.WriteString(heredoc.Doc(`\n\t\t\t\tallowed_ip=0.0.0.0/0\n\t\t\t\tallowed_ip=::0/0\n\t\t\t`))\n\t\t}\n\t}\n\n\tsetting := &DeviceSetting{IpcRequest: request.String(), DNS: conf.DNS, DeviceAddr: conf.Endpoint, MTU: conf.MTU}\n\treturn setting, nil\n}\n\n// StartWireguard creates a tun interface on netstack given a configuration\nfunc StartWireguard(conf *DeviceConfig, logLevel int) (*VirtualTun, error) {\n\tsetting, err := CreateIPCRequest(conf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttun, tnet, err := netstack.CreateNetTUN(setting.DeviceAddr, setting.DNS, setting.MTU)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdev := device.NewDevice(tun, conn.NewDefaultBind(), device.NewLogger(logLevel, \"\"))\n\terr = dev.IpcSet(setting.IpcRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = dev.Up()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &VirtualTun{\n\t\tTnet:           tnet,\n\t\tDev:            dev,\n\t\tConf:           conf,\n\t\tSystemDNS:      len(setting.DNS) == 0,\n\t\tPingRecord:     make(map[string]uint64),\n\t\tPingRecordLock: new(sync.Mutex),\n\t}, nil\n}\n"
        }
      ]
    }
  ]
}