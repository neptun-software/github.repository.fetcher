{
  "metadata": {
    "timestamp": 1736566461933,
    "page": 7,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ReactiveX/RxGo",
      "stars": 4963,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3525390625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n# Backup files\n*~\n*#\n\n# Dep directories\nbower_components\nnode_modules\n\n# IntelliJ\n.idea\n*.iml\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.9951171875,
          "content": "# Contributions Guidelines\n\nContributions are always welcome. However, to make this a smooth collaboration experience for everyone and to maintain the quality of the code, here is a few things to consider before and after making a pull request:\n\n## Consistency\n\nThere are already +80 operators and +250 unit tests. Please don't try necessarily to reinvent the wheel and make sure to check first how the current implementation solves the most common problems.\n\n## Edge Case\n\nWhen we develop a new operator, there are a lot of edge cases to handle (eager/lazy observation, sequential vs parallel, on error strategy, etc.). The utility functions `observable()`, `single()` and `optionalSingle()` are there to help. Yet, it is not always possible to use them (observation of multiple Observables, etc.). In this case, you may want to take a look at existing operators like `WindowWithTime` to see an exhaustive implementation.\n\n## Unit Tests\n\nMake sure to include unit tests. Again, consistency is key. In most of the unit tests, we use the RxGo assertion API.\n\n## Duration\n\nIf an operator input contains a duration, we should use `rxgo.Duration`. It allows us to mock it and to implement deterministic tests whenever possible using `timeCausality()`.\n\n## Write Nice Code\n\nTry to write idiomatic code according to [Go style guide](https://github.com/golang/go/wiki/CodeReviewComments). Also, see this project style guide for project-specific idioms (when in doubt, consult the first).\n\n## Code Formatting\n\nBefore to create a pull request, make sure to format your code using:\n\n* [gofumpt](https://github.com/mvdan/gofumpt):\n    * Install: `go get mvdan.cc/gofumpt`\n    * Execute: `gofumpt -s -w .`\n\n* [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports):\n    * Install: `go get golang.o`\n    * Execute: `goimports -w .`\n    \n## Open an issue\n\nThis is to encourage discussions and reach a sound design decision before implementing an additional feature or fixing a bug. If you're proposing a new feature, make it obvious in the subject.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.044921875,
          "content": "MIT License\n\nCopyright (c) 2016 Joe Chasinga\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.111328125,
          "content": "test:\n\tgo clean -testcache ./...\n\tgo test -race -timeout 10s ./... --tags=all\n\tgo test -timeout 10s -run TestLeak\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 23.486328125,
          "content": "# RxGo\n[![Maintenance](https://img.shields.io/maintenance/new%20%F0%9F%91%8B/2025?color=blue&style=for-the-badge)](https://github.com/ReactiveX/RxGo/issues/363)\n[![Go Report Card](https://goreportcard.com/badge/github.com/reactivex/rxgo?style=for-the-badge)](https://goreportcard.com/report/github.com/reactivex/rxgo)\n[![Gitter Chat](https://img.shields.io/gitter/room/reactivex/rxgo.svg?style=for-the-badge&color=yellowgreen)](https://gitter.im/reactivex/rxgo)\n\nReactive Extensions for the Go Language\n\n## ReactiveX\n\n[ReactiveX](http://reactivex.io/), or Rx for short, is an API for programming with Observable streams. This is the official ReactiveX API for the Go language.\n\nReactiveX is a new, alternative way of asynchronous programming to callbacks, promises, and deferred. It is about processing streams of events or items, with events being any occurrences or changes within the system. A stream of events is called an [Observable](http://reactivex.io/documentation/contract.html).\n\nAn operator is a function that defines an Observable, how and when it should emit data. The list of operators covered is available [here](README.md#supported-operators-in-rxgo).\n\n## RxGo\n\nThe RxGo implementation is based on the concept of [pipelines](https://blog.golang.org/pipelines). A pipeline is a series of stages connected by channels, where each stage is a group of goroutines running the same function.\n\n![](doc/rx.png)\n\nLet's see a concrete example with each box being an operator:\n* We create a static Observable based on a fixed list of items using the `Just` operator.\n* We define a transformation function (convert a circle into a square) using the `Map` operator.\n* We filter each yellow square using the `Filter` operator.\n\nIn this example, the final items are sent in a channel, available to a consumer. There are many ways to consume or to produce data using RxGo. Publishing the results in a channel is only one of them.\n\nEach operator is a transformation stage. By default, everything is sequential. Yet, we can leverage modern CPU architectures by defining multiple instances of the same operator. Each operator instance being a goroutine connected to a common channel.\n\nThe philosophy of RxGo is to implement the ReactiveX concepts and leverage the main Go primitives (channels, goroutines, etc.) so that the integration between the two worlds is as smooth as possible.\n\n## Installation of RxGo v2\n\n```\ngo get -u github.com/reactivex/rxgo/v2\n```\n\n## Getting Started\n\n### Hello World\n\nLet's create our first Observable and consume an item:\n\n```go\nobservable := rxgo.Just(\"Hello, World!\")()\nch := observable.Observe()\nitem := <-ch\nfmt.Println(item.V)\n```\n\nThe `Just` operator creates an Observable from a static list of items. `Of(value)` creates an item from a given value. If we want to create an item from an error, we have to use `Error(err)`. This is a difference with the v1 that was accepting a value or an error directly without having to wrap it. What's the rationale for this change? It is to prepare RxGo for the generics feature coming (hopefully) in Go 2.\n\nBy the way, the `Just` operator uses currying as syntactic sugar. This way, it accepts multiple items in the first parameter list and multiple options in the second parameter list. We'll see below how to specify options.\n\nOnce the Observable is created, we can observe it using `Observe()`. By default, an Observable is lazy in the sense that it emits items only once a subscription is made. `Observe()` returns a `<-chan rxgo.Item`.\n\nWe consumed an item from this channel and printed its value of the item using `item.V`. \n\nAn item is a wrapper on top of a value or an error. We may want to check the type first like this:\n\n```go\nitem := <-ch\nif item.Error() {\n    return item.E\n}\nfmt.Println(item.V)\n``` \n\n`item.Error()` returns a boolean indicating whether an item contains an error. Then, we use either `item.E` to get the error or `item.V` to get the value.\n\nBy default, an Observable is stopped once an error is produced. However, there are special operators to deal with errors (e.g., `OnError`, `Retry`, etc.)\n\nIt is also possible to consume items using callbacks:\n\n```go\nobservable.ForEach(func(v interface{}) {\n    fmt.Printf(\"received: %v\\n\", v)\n}, func(err error) {\n    fmt.Printf(\"error: %e\\n\", err)\n}, func() {\n    fmt.Println(\"observable is closed\")\n})\n```\n\nIn this example, we passed three functions:\n* A `NextFunc` triggered when a value item is emitted.\n* An `ErrFunc` triggered when an error item is emitted.\n* A `CompletedFunc` triggered once the Observable is completed.\n\n`ForEach` is non-blocking. Yet, it returns a notification channel that will be closed once the Observable completes. Hence, to make the previous code blocking, we simply need to use `<-`:\n\n```go\n<-observable.ForEach(...)\n```\n\n### Real-World Example\n\nLet's say we want to implement a stream that consumes the following `Customer` structure:\n```go\ntype Customer struct {\n\tID             int\n\tName, LastName string\n\tAge            int\n\tTaxNumber      string\n}\n```\n\nWe create a producer that will emit `Customer`s to a given `chan rxgo.Item` and create an Observable from it:\n```go\n// Create the input channel\nch := make(chan rxgo.Item)\n// Data producer\ngo producer(ch)\n\n// Create an Observable\nobservable := rxgo.FromChannel(ch)\n```\n\nThen, we need to perform the two following operations:\n* Filter the customers whose age is below 18.\n* Enrich each customer with a tax number. Retrieving a tax number is done, for example, by an IO-bound function doing an external REST call.\n\nAs the enriching step is IO-bound, it might be interesting to parallelize it within a given pool of goroutines.\nYet, let's imagine that all the `Customer` items need to be produced sequentially based on its `ID`.\n\n```go\nobservable.\n\tFilter(func(item interface{}) bool {\n\t\t// Filter operation\n\t\tcustomer := item.(Customer)\n\t\treturn customer.Age > 18\n\t}).\n\tMap(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\t// Enrich operation\n\t\tcustomer := item.(Customer)\n\t\ttaxNumber, err := getTaxNumber(customer)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcustomer.TaxNumber = taxNumber\n\t\treturn customer, nil\n\t},\n\t\t// Create multiple instances of the map operator\n\t\trxgo.WithPool(pool),\n\t\t// Serialize the items emitted by their Customer.ID\n\t\trxgo.Serialize(func(item interface{}) int {\n\t\t\tcustomer := item.(Customer)\n\t\t\treturn customer.ID\n\t\t}), rxgo.WithBufferedChannel(1))\n``` \n\nIn the end, we consume the items using `ForEach()` or `Observe()` for example. `Observe()` returns a `<-chan Item`:\n```go\nfor customer := range observable.Observe() {\n\tif customer.Error() {\n\t\treturn err\n\t}\n\tfmt.Println(customer)\n}\n```\n\n## Observable Types\n\n### Hot vs. Cold Observables\n\nIn the Rx world, there is a distinction between cold and hot Observables. When the data is produced by the Observable itself, it is a cold Observable. When the data is produced outside the Observable, it is a hot Observable. Usually, when we don't want to create a producer over and over again, we favour a hot Observable.\n\nIn RxGo, there is a similar concept.\n\nFirst, let's create a **hot** Observable using `FromChannel` operator and see the implications:\n\n```go\nch := make(chan rxgo.Item)\ngo func() {\n    for i := 0; i < 3; i++ {\n        ch <- rxgo.Of(i)\n    }\n    close(ch)\n}()\nobservable := rxgo.FromChannel(ch)\n\n// First Observer\nfor item := range observable.Observe() {\n    fmt.Println(item.V)\n}\n\n// Second Observer\nfor item := range observable.Observe() {\n    fmt.Println(item.V)\n}\n```\n\nThe result of this execution is:\n\n```\n0\n1\n2\n```\n\nIt means the first Observer already consumed all items. And nothing left for others.  \nThough this behavior can be altered with [Connectable](#connectable-observable) Observables.  \nThe main point here is the goroutine produced those items.\n\nOn the other hand, let's create a **cold** Observable using `Defer` operator:\n\n```go\nobservable := rxgo.Defer([]rxgo.Producer{func(_ context.Context, ch chan<- rxgo.Item) {\n    for i := 0; i < 3; i++ {\n        ch <- rxgo.Of(i)\n    }\n}})\n\n// First Observer\nfor item := range observable.Observe() {\n    fmt.Println(item.V)\n}\n\n// Second Observer\nfor item := range observable.Observe() {\n    fmt.Println(item.V)\n}\n```\n\nNow, the result is:\n\n```go\n0\n1\n2\n0\n1\n2\n```\n\nIn the case of a cold observable, the stream was created independently for every Observer.\n\nAgain, **hot** vs **cold** Observables are not about how you consume items, it's about where data is produced.  \nGood example for hot Observable are price ticks from a trading exchange.  \nAnd if you teach an Observable to fetch products from a database, then yield them one by one, you will create the **cold** Observable.\n\n### Backpressure\n\nThere is another operator called `FromEventSource` that creates an Observable from a channel. The difference between `FromChannel` operator is that as soon as the Observable is created, it starts to emit items regardless if there is an Observer or not. Hence, the items emitted by an Observable without Observer(s) are lost (while they are buffered with `FromChannel` operator).\n\nA use case with `FromEventSource` operator is, for example, telemetry. We may not be interested in all the data produced from the very beginning of a stream—only the data since we started to observe it.\n\nOnce we start observing an Observable created with `FromEventSource`, we can configure the backpressure strategy. By default, it is blocking (there is a guaranteed delivery for the items emitted after we observe it). We can override this strategy this way:\n\n```go\nobservable := rxgo.FromEventSource(input, rxgo.WithBackPressureStrategy(rxgo.Drop))\n```\n\nThe `Drop` strategy means that if the pipeline after `FromEventSource` was not ready to consume an item, this item is dropped.\n\nBy default, a channel connecting operators is non-buffered. We can override this behaviour like this:\n\n```go\nobservable.Map(transform, rxgo.WithBufferedChannel(42))\n```\n\nEach operator has an `opts ...Option` parameter allowing to pass such options.\n\n### Lazy vs. Eager Observation\n\nThe default observation strategy is lazy. It means an operator processes the items emitted by an Observable once we start observing it. We can change this behaviour this way:\n\n```go\nobservable := rxgo.FromChannel(ch).Map(transform, rxgo.WithObservationStrategy(rxgo.Eager))\n```\n\nIn this case, the `Map` operator is triggered whenever an item is produced, even without any Observer.\n\n### Sequential vs. Parallel Operators\n\nBy default, each operator is sequential. One operator being one goroutine instance. We can override it using the following option:\n\n```go\nobservable.Map(transform, rxgo.WithPool(32))\n```\n\nIn this example, we create a pool of 32 goroutines that consume items concurrently from the same channel. If the operation is CPU-bound, we can use the `WithCPUPool()` option that creates a pool based on the number of logical CPUs.\n\n### Connectable Observable\n\nA Connectable Observable resembles an ordinary Observable, except that it does not begin emitting items when it is subscribed to, but only when its connect() method is called. In this way, you can wait for all intended Subscribers to subscribe to the Observable before the Observable begins emitting items.\n\nLet's create a Connectable Observable using `rxgo.WithPublishStrategy`:\n\n```go\nch := make(chan rxgo.Item)\ngo func() {\n\tch <- rxgo.Of(1)\n\tch <- rxgo.Of(2)\n\tch <- rxgo.Of(3)\n\tclose(ch)\n}()\nobservable := rxgo.FromChannel(ch, rxgo.WithPublishStrategy())\n```\n\nThen, we create two Observers:\n\n```go\nobservable.Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\treturn i.(int) + 1, nil\n}).DoOnNext(func(i interface{}) {\n\tfmt.Printf(\"First observer: %d\\n\", i)\n})\n\nobservable.Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\treturn i.(int) * 2, nil\n}).DoOnNext(func(i interface{}) {\n\tfmt.Printf(\"Second observer: %d\\n\", i)\n})\n```\n\nIf `observable` was not a Connectable Observable, as `DoOnNext` creates an Observer, the source Observable would have begun emitting items. Yet, in the case of a Connectable Observable, we have to call `Connect()`:\n\n```go\nobservable.Connect()\n``` \n\nOnce `Connect()` is called, the Connectable Observable begins to emit items.\n\nThere is another important change with a regular Observable. A Connectable Observable publishes its items. It means all the Observers receive a copy of the items.\n\nHere is an example with a regular Observable:\n\n```go\nch := make(chan rxgo.Item)\ngo func() {\n\tch <- rxgo.Of(1)\n\tch <- rxgo.Of(2)\n\tch <- rxgo.Of(3)\n\tclose(ch)\n}()\n// Create a regular Observable\nobservable := rxgo.FromChannel(ch)\n\n// Create the first Observer\nobservable.DoOnNext(func(i interface{}) {\n\tfmt.Printf(\"First observer: %d\\n\", i)\n})\n\n// Create the second Observer\nobservable.DoOnNext(func(i interface{}) {\n\tfmt.Printf(\"Second observer: %d\\n\", i)\n})\n```\n\n```\nFirst observer: 1\nFirst observer: 2\nFirst observer: 3\n```\n\nNow, with a Connectable Observable:\n\n```go\nch := make(chan rxgo.Item)\ngo func() {\n\tch <- rxgo.Of(1)\n\tch <- rxgo.Of(2)\n\tch <- rxgo.Of(3)\n\tclose(ch)\n}()\n// Create a Connectable Observable\nobservable := rxgo.FromChannel(ch, rxgo.WithPublishStrategy())\n\n// Create the first Observer\nobservable.DoOnNext(func(i interface{}) {\n\tfmt.Printf(\"First observer: %d\\n\", i)\n})\n\n// Create the second Observer\nobservable.DoOnNext(func(i interface{}) {\n\tfmt.Printf(\"Second observer: %d\\n\", i)\n})\n\ndisposed, cancel := observable.Connect()\ngo func() {\n\t// Do something\n\ttime.Sleep(time.Second)\n\t// Then cancel the subscription\n\tcancel()\n}()\n// Wait for the subscription to be disposed\n<-disposed\n```\n\n```\nSecond observer: 1\nFirst observer: 1\nFirst observer: 2\nFirst observer: 3\nSecond observer: 2\nSecond observer: 3\n```\n\n### Observable, Single, and Optional Single\n\nAn Iterable is an object that can be observed using `Observe(opts ...Option) <-chan Item`.\n\nAn Iterable can be either:\n* An Observable: emit 0 or multiple items\n* A Single: emit 1 item\n* An Optional Single: emit 0 or 1 item\n\n## Documentation\n\nPackage documentation: [https://pkg.go.dev/github.com/reactivex/rxgo/v2](https://pkg.go.dev/github.com/reactivex/rxgo/v2)\n\n### Assert API\n\nHow to use the [assert API](doc/assert.md) to write unit tests while using RxGo.\n\n### Operator Options\n\n[Operator options](doc/options.md)\n\n### Creating Observables\n* [Create](doc/create.md) — create an Observable from scratch by calling Observer methods programmatically\n* [Defer](doc/defer.md) — do not create the Observable until the Observer subscribes, and create a fresh Observable for each Observer\n* [Empty](doc/empty.md)/[Never](doc/never.md)/[Thrown](doc/thrown.md) — create Observables that have very precise and limited behaviour\n* [FromChannel](doc/fromchannel.md) — create an Observable based on a lazy channel\n* [FromEventSource](doc/fromeventsource.md) — create an Observable based on an eager channel\n* [Interval](doc/interval.md) — create an Observable that emits a sequence of integers spaced by a particular time interval\n* [Just](doc/just.md) — convert a set of objects into an Observable that emits that or those objects\n* [JustItem](doc/justitem.md) — convert one object into a Single that emits this object\n* [Range](doc/range.md) — create an Observable that emits a range of sequential integers\n* [Repeat](doc/repeat.md) — create an Observable that emits a particular item or sequence of items repeatedly\n* [Start](doc/start.md) — create an Observable that emits the return value of a function\n* [Timer](doc/timer.md) — create an Observable that completes after a specified delay\n\n### Transforming Observables\n* [Buffer](doc/buffer.md) — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time\n* [FlatMap](doc/flatmap.md) — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable\n* [GroupBy](doc/groupby.md) — divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key\n* [GroupByDynamic](doc/groupbydynamic.md) — divide an Observable into a dynamic set of Observables that each emit GroupedObservables from the original Observable, organized by key\n* [Map](doc/map.md) — transform the items emitted by an Observable by applying a function to each item\n* [Marshal](doc/marshal.md) — transform the items emitted by an Observable by applying a marshalling function to each item\n* [Scan](doc/scan.md) — apply a function to each item emitted by an Observable, sequentially, and emit each successive value\n* [Unmarshal](doc/unmarshal.md) — transform the items emitted by an Observable by applying an unmarshalling function to each item\n* [Window](doc/window.md) — apply a function to each item emitted by an Observable, sequentially, and emit each successive value\n\n### Filtering Observables\n* [Debounce](doc/debounce.md) — only emit an item from an Observable if a particular timespan has passed without it emitting another item\n* [Distinct](doc/distinct.md)/[DistinctUntilChanged](doc/distinctuntilchanged.md) — suppress duplicate items emitted by an Observable\n* [ElementAt](doc/elementat.md) — emit only item n emitted by an Observable\n* [Filter](doc/filter.md) — emit only those items from an Observable that pass a predicate test\n* [Find](doc/find.md) — emit the first item passing a predicate, then complete\n* [First](doc/first.md)/[FirstOrDefault](doc/firstordefault.md) — emit only the first item or the first item that meets a condition from an Observable\n* [IgnoreElements](doc/ignoreelements.md) — do not emit any items from an Observable but mirror its termination notification\n* [Last](doc/last.md)/[LastOrDefault](doc/lastordefault.md) — emit only the last item emitted by an Observable\n* [Sample](doc/sample.md) — emit the most recent item emitted by an Observable within periodic time intervals\n* [Skip](doc/skip.md) — suppress the first n items emitted by an Observable\n* [SkipLast](doc/skiplast.md) — suppress the last n items emitted by an Observable\n* [Take](doc/take.md) — emit only the first n items emitted by an Observable\n* [TakeLast](doc/takelast.md) — emit only the last n items emitted by an Observable\n\n### Combining Observables\n* [CombineLatest](doc/combinelatest.md) — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function\n* [Join](doc/join.md) — combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable\n* [Merge](doc/merge.md) — combine multiple Observables into one by merging their emissions\n* [StartWithIterable](doc/startwithiterable.md) — emit a specified sequence of items before beginning to emit the items from the source Iterable\n* [ZipFromIterable](doc/zipfromiterable.md) — combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function\n\n### Error Handling Operators\n* [Catch](doc/catch.md) — recover from an onError notification by continuing the sequence without error\n* [Retry](doc/retry.md)/[BackOffRetry](doc/backoffretry.md) — if a source Observable sends an onError notification, resubscribe to it in the hopes that it will complete without error\n\n### Observable Utility Operators\n* [Do](doc/do.md) - register an action to take upon a variety of Observable lifecycle events\n* [Run](doc/run.md) — create an Observer without consuming the emitted items\n* [Send](doc/send.md) — send the Observable items in a specific channel\n* [Serialize](doc/serialize.md) — force an Observable to make serialized calls and to be well-behaved\n* [TimeInterval](doc/timeinterval.md) — convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions\n* [Timestamp](doc/timestamp.md) — attach a timestamp to each item emitted by an Observable\n\n### Conditional and Boolean Operators\n* [All](doc/all.md) — determine whether all items emitted by an Observable meet some criteria\n* [Amb](doc/amb.md) — given two or more source Observables, emit all of the items from only the first of these Observables to emit an item\n* [Contains](doc/contains.md) — determine whether an Observable emits a particular item or not\n* [DefaultIfEmpty](doc/defaultifempty.md) — emit items from the source Observable, or a default item if the source Observable emits nothing\n* [SequenceEqual](doc/sequenceequal.md) — determine whether two Observables emit the same sequence of items\n* [SkipWhile](doc/skipwhile.md) — discard items emitted by an Observable until a specified condition becomes false\n* [TakeUntil](doc/takeuntil.md) — discard items emitted by an Observable after a second Observable emits an item or terminates\n* [TakeWhile](doc/takewhile.md) — discard items emitted by an Observable after a specified condition becomes false\n\n### Mathematical and Aggregate Operators\n* [Average](doc/average.md) — calculates the average of numbers emitted by an Observable and emits this average\n* [Concat](doc/concat.md) — emit the emissions from two or more Observables without interleaving them\n* [Count](doc/count.md) — count the number of items emitted by the source Observable and emit only this value\n* [Max](doc/max.md) — determine, and emit, the maximum-valued item emitted by an Observable\n* [Min](doc/min.md) — determine, and emit, the minimum-valued item emitted by an Observable\n* [Reduce](doc/reduce.md) — apply a function to each item emitted by an Observable, sequentially, and emit the final value\n* [Sum](doc/sum.md) — calculate the sum of numbers emitted by an Observable and emit this sum\n\n### Operators to Convert Observables\n* [Error](doc/error.md) — return the first error thrown by an observable\n* [Errors](doc/errors.md) — return all the errors thrown by an observable\n* [ToMap](doc/tomap.md)/[ToMapWithValueSelector](doc/tomapwithvalueselector.md)/[ToSlice](doc/toslice.md) — convert an Observable into another object or data structure\n\n## Contributing\n\nAll contributions are very welcome! Be sure you check out the [contributing guidelines](CONTRIBUTING.md) first. Newcomers can take a look at ongoing issues and check for the `help needed` label. \n\nAlso, if you publish a post about RxGo, please let us know. We would be glad to include it in the [External Resources](#external-resources) section.\n\nThanks to all the people who already contributed to RxGo!\n\n<a href=\"https://github.com/ReactiveX/RxGo/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=ReactiveX/RxGo\" />\n</a>\n\n## External Resources\n\n* [Announcing RxGo v2](https://teivah.medium.com/introducing-rxgo-v2-e7e369faa99a)\n* [Why YoMo (an open-source streaming serverless framework for building low-latency edge computing applications) uses RxGo](https://docs.yomo.run/rx#why-use-rx)\n* [Go Cookbook from Packt - Reactive programming with RxGo (based on v1)](https://subscription.packtpub.com/book/application_development/9781783286836/11/ch11lvl1sec87/reactive-programming-with-rxgo)\n* [Writing PizzaScript Lexer with RxGo](https://korzio.medium.com/writing-pizzascript-lexer-with-rxgo-a-saga-in-iii-slices-3790dc6099e7)\n* [Writing PizzaScript Parser with RxGo](https://korzio.medium.com/pizzascript-parser-with-rxgo-the-pyramid-of-doom-36e574f129dc)\n* [Reactive programming in Go](https://prakharsrivastav.com/posts/reactive-programming-in-go/)\n* [Programación reactiva en Go (Spanish)](https://blog.friendsofgo.tech/posts/programacion-reactiva-en-go/)\n* [Go 每日一库之 RxGo (Chinese)](https://darjun.github.io/2020/10/11/godailylib/rxgo/)\n* [RxGo入门 · 语雀 (Chinese)](https://www.yuque.com/yaozj/go/rxgo-get-started?language=en-us)\n\n## Special Thanks\n\nA big thanks to [JetBrains](https://jb.gg/OpenSource) for supporting the project.\n"
        },
        {
          "name": "assert.go",
          "type": "blob",
          "size": 6.916015625,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// AssertPredicate is a custom predicate based on the items.\ntype AssertPredicate func(items []interface{}) error\n\n// RxAssert lists the Observable assertions.\ntype RxAssert interface {\n\tapply(*rxAssert)\n\titemsToBeChecked() (bool, []interface{})\n\titemsNoOrderedToBeChecked() (bool, []interface{})\n\tnoItemsToBeChecked() bool\n\tsomeItemsToBeChecked() bool\n\traisedErrorToBeChecked() (bool, error)\n\traisedErrorsToBeChecked() (bool, []error)\n\traisedAnErrorToBeChecked() (bool, error)\n\tnotRaisedErrorToBeChecked() bool\n\titemToBeChecked() (bool, interface{})\n\tnoItemToBeChecked() (bool, interface{})\n\tcustomPredicatesToBeChecked() (bool, []AssertPredicate)\n}\n\ntype rxAssert struct {\n\tf                       func(*rxAssert)\n\tcheckHasItems           bool\n\tcheckHasNoItems         bool\n\tcheckHasSomeItems       bool\n\titems                   []interface{}\n\tcheckHasItemsNoOrder    bool\n\titemsNoOrder            []interface{}\n\tcheckHasRaisedError     bool\n\terr                     error\n\tcheckHasRaisedErrors    bool\n\terrs                    []error\n\tcheckHasRaisedAnError   bool\n\tcheckHasNotRaisedError  bool\n\tcheckHasItem            bool\n\titem                    interface{}\n\tcheckHasNoItem          bool\n\tcheckHasCustomPredicate bool\n\tcustomPredicates        []AssertPredicate\n}\n\nfunc (ass *rxAssert) apply(do *rxAssert) {\n\tass.f(do)\n}\n\nfunc (ass *rxAssert) itemsToBeChecked() (bool, []interface{}) {\n\treturn ass.checkHasItems, ass.items\n}\n\nfunc (ass *rxAssert) itemsNoOrderedToBeChecked() (bool, []interface{}) {\n\treturn ass.checkHasItemsNoOrder, ass.itemsNoOrder\n}\n\nfunc (ass *rxAssert) noItemsToBeChecked() bool {\n\treturn ass.checkHasNoItems\n}\n\nfunc (ass *rxAssert) someItemsToBeChecked() bool {\n\treturn ass.checkHasSomeItems\n}\n\nfunc (ass *rxAssert) raisedErrorToBeChecked() (bool, error) {\n\treturn ass.checkHasRaisedError, ass.err\n}\n\nfunc (ass *rxAssert) raisedErrorsToBeChecked() (bool, []error) {\n\treturn ass.checkHasRaisedErrors, ass.errs\n}\n\nfunc (ass *rxAssert) raisedAnErrorToBeChecked() (bool, error) {\n\treturn ass.checkHasRaisedAnError, ass.err\n}\n\nfunc (ass *rxAssert) notRaisedErrorToBeChecked() bool {\n\treturn ass.checkHasNotRaisedError\n}\n\nfunc (ass *rxAssert) itemToBeChecked() (bool, interface{}) {\n\treturn ass.checkHasItem, ass.item\n}\n\nfunc (ass *rxAssert) noItemToBeChecked() (bool, interface{}) {\n\treturn ass.checkHasNoItem, ass.item\n}\n\nfunc (ass *rxAssert) customPredicatesToBeChecked() (bool, []AssertPredicate) {\n\treturn ass.checkHasCustomPredicate, ass.customPredicates\n}\n\nfunc newAssertion(f func(*rxAssert)) *rxAssert {\n\treturn &rxAssert{\n\t\tf: f,\n\t}\n}\n\n// HasItems checks that the observable produces the corresponding items.\nfunc HasItems(items ...interface{}) RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasItems = true\n\t\ta.items = items\n\t})\n}\n\n// HasItem checks if a single or optional single has a specific item.\nfunc HasItem(i interface{}) RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasItem = true\n\t\ta.item = i\n\t})\n}\n\n// HasItemsNoOrder checks that an observable produces the corresponding items regardless of the order.\nfunc HasItemsNoOrder(items ...interface{}) RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasItemsNoOrder = true\n\t\ta.itemsNoOrder = items\n\t})\n}\n\n// IsNotEmpty checks that the observable produces some items.\nfunc IsNotEmpty() RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasSomeItems = true\n\t})\n}\n\n// IsEmpty checks that the observable has not produce any item.\nfunc IsEmpty() RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasNoItems = true\n\t})\n}\n\n// HasError checks that the observable has produce a specific error.\nfunc HasError(err error) RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasRaisedError = true\n\t\ta.err = err\n\t})\n}\n\n// HasAnError checks that the observable has produce an error.\nfunc HasAnError() RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasRaisedAnError = true\n\t})\n}\n\n// HasErrors checks that the observable has produce a set of errors.\nfunc HasErrors(errs ...error) RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasRaisedErrors = true\n\t\ta.errs = errs\n\t})\n}\n\n// HasNoError checks that the observable has not raised any error.\nfunc HasNoError() RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\ta.checkHasRaisedError = true\n\t})\n}\n\n// CustomPredicate checks a custom predicate.\nfunc CustomPredicate(predicate AssertPredicate) RxAssert {\n\treturn newAssertion(func(a *rxAssert) {\n\t\tif !a.checkHasCustomPredicate {\n\t\t\ta.checkHasCustomPredicate = true\n\t\t\ta.customPredicates = make([]AssertPredicate, 0)\n\t\t}\n\t\ta.customPredicates = append(a.customPredicates, predicate)\n\t})\n}\n\nfunc parseAssertions(assertions ...RxAssert) RxAssert {\n\tass := new(rxAssert)\n\tfor _, assertion := range assertions {\n\t\tassertion.apply(ass)\n\t}\n\treturn ass\n}\n\n// Assert asserts the result of an iterable against a list of assertions.\nfunc Assert(ctx context.Context, t *testing.T, iterable Iterable, assertions ...RxAssert) {\n\tass := parseAssertions(assertions...)\n\n\tgot := make([]interface{}, 0)\n\terrs := make([]error, 0)\n\n\tobserve := iterable.Observe()\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tbreak loop\n\t\tcase item, ok := <-observe:\n\t\t\tif !ok {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t\tif item.Error() {\n\t\t\t\terrs = append(errs, item.E)\n\t\t\t} else {\n\t\t\t\tgot = append(got, item.V)\n\t\t\t}\n\t\t}\n\t}\n\n\tif checked, predicates := ass.customPredicatesToBeChecked(); checked {\n\t\tfor _, predicate := range predicates {\n\t\t\terr := predicate(got)\n\t\t\tif err != nil {\n\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t}\n\t\t}\n\t}\n\tif checkHasItems, expectedItems := ass.itemsToBeChecked(); checkHasItems {\n\t\tassert.Equal(t, expectedItems, got)\n\t}\n\tif checkHasItemsNoOrder, itemsNoOrder := ass.itemsNoOrderedToBeChecked(); checkHasItemsNoOrder {\n\t\tm := make(map[interface{}]interface{})\n\t\tfor _, v := range itemsNoOrder {\n\t\t\tm[v] = nil\n\t\t}\n\n\t\tfor _, v := range got {\n\t\t\tdelete(m, v)\n\t\t}\n\t\tif len(m) != 0 {\n\t\t\tassert.Fail(t, \"missing elements\", \"%v\", got)\n\t\t}\n\t}\n\tif checkHasItem, value := ass.itemToBeChecked(); checkHasItem {\n\t\tlength := len(got)\n\t\tif length != 1 {\n\t\t\tassert.FailNow(t, \"wrong number of items\", \"expected 1, got %d\", length)\n\t\t}\n\t\tassert.Equal(t, value, got[0])\n\t}\n\tif ass.noItemsToBeChecked() {\n\t\tassert.Equal(t, 0, len(got))\n\t}\n\tif ass.someItemsToBeChecked() {\n\t\tassert.NotEqual(t, 0, len(got))\n\t}\n\tif checkHasRaisedError, expectedError := ass.raisedErrorToBeChecked(); checkHasRaisedError {\n\t\tif expectedError == nil {\n\t\t\tassert.Equal(t, 0, len(errs))\n\t\t} else {\n\t\t\tif len(errs) == 0 {\n\t\t\t\tassert.FailNow(t, \"no error raised\", \"expected %v\", expectedError)\n\t\t\t}\n\t\t\tassert.Equal(t, expectedError, errs[0])\n\t\t}\n\t}\n\tif checkHasRaisedErrors, expectedErrors := ass.raisedErrorsToBeChecked(); checkHasRaisedErrors {\n\t\tassert.Equal(t, expectedErrors, errs)\n\t}\n\tif checkHasRaisedAnError, expectedError := ass.raisedAnErrorToBeChecked(); checkHasRaisedAnError {\n\t\tassert.Nil(t, expectedError)\n\t}\n\tif ass.notRaisedErrorToBeChecked() {\n\t\tassert.Equal(t, 0, len(errs))\n\t}\n}\n"
        },
        {
          "name": "auto_assign.yml",
          "type": "blob",
          "size": 0.060546875,
          "content": "addReviewers: true\n\naddAssignees: false\n\nreviewers:\n  - teivah"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "duration.go",
          "type": "blob",
          "size": 1.626953125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/mock\"\n)\n\n// Infinite represents an infinite wait time\nvar Infinite int64 = -1\n\n// Duration represents a duration\ntype Duration interface {\n\tduration() time.Duration\n}\n\ntype duration struct {\n\td time.Duration\n}\n\nfunc (d *duration) duration() time.Duration {\n\treturn d.d\n}\n\n// WithDuration is a duration option\nfunc WithDuration(d time.Duration) Duration {\n\treturn &duration{\n\t\td: d,\n\t}\n}\n\nvar tick = struct{}{}\n\ntype causalityDuration struct {\n\tfs []execution\n}\n\ntype execution struct {\n\tf      func()\n\tisTick bool\n}\n\nfunc timeCausality(elems ...interface{}) (context.Context, Observable, Duration) {\n\tch := make(chan Item, 1)\n\tfs := make([]execution, len(elems)+1)\n\tctx, cancel := context.WithCancel(context.Background())\n\tfor i, elem := range elems {\n\t\ti := i\n\t\telem := elem\n\t\tif elem == tick {\n\t\t\tfs[i] = execution{\n\t\t\t\tf:      func() {},\n\t\t\t\tisTick: true,\n\t\t\t}\n\t\t} else {\n\t\t\tswitch elem := elem.(type) {\n\t\t\tdefault:\n\t\t\t\tfs[i] = execution{\n\t\t\t\t\tf: func() {\n\t\t\t\t\t\tch <- Of(elem)\n\t\t\t\t\t},\n\t\t\t\t\tisTick: false,\n\t\t\t\t}\n\t\t\tcase error:\n\t\t\t\tfs[i] = execution{\n\t\t\t\t\tf: func() {\n\t\t\t\t\t\tch <- Error(elem)\n\t\t\t\t\t},\n\t\t\t\t\tisTick: false,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfs[len(elems)] = execution{\n\t\tf: func() {\n\t\t\tcancel()\n\t\t},\n\t\tisTick: false,\n\t}\n\treturn ctx, FromChannel(ch), &causalityDuration{fs: fs}\n}\n\nfunc (d *causalityDuration) duration() time.Duration {\n\tpop := d.fs[0]\n\tpop.f()\n\td.fs = d.fs[1:]\n\tif pop.isTick {\n\t\treturn time.Nanosecond\n\t}\n\treturn time.Minute\n}\n\ntype mockDuration struct {\n\tmock.Mock\n}\n\nfunc (m *mockDuration) duration() time.Duration {\n\targs := m.Called()\n\treturn args.Get(0).(time.Duration)\n}\n"
        },
        {
          "name": "duration_test.go",
          "type": "blob",
          "size": 0.2314453125,
          "content": "package rxgo\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWithFrequency(t *testing.T) {\n\tfrequency := WithDuration(100 * time.Millisecond)\n\tassert.Equal(t, 100*time.Millisecond, frequency.duration())\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.453125,
          "content": "package rxgo\n\n// IllegalInputError is triggered when the observable receives an illegal input.\ntype IllegalInputError struct {\n\terror string\n}\n\nfunc (e IllegalInputError) Error() string {\n\treturn \"illegal input: \" + e.error\n}\n\n// IndexOutOfBoundError is triggered when the observable cannot access to the specified index.\ntype IndexOutOfBoundError struct {\n\terror string\n}\n\nfunc (e IndexOutOfBoundError) Error() string {\n\treturn \"index out of bound: \" + e.error\n}\n"
        },
        {
          "name": "factory.go",
          "type": "blob",
          "size": 7.73828125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Amb takes several Observables, emit all of the items from only the first of these Observables\n// to emit an item or notification.\nfunc Amb(observables []Observable, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(emptyContext)\n\tnext := option.buildChannel()\n\tonce := sync.Once{}\n\n\tf := func(o Observable) {\n\t\tit := o.Observe(opts...)\n\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase item, ok := <-it:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tonce.Do(func() {\n\t\t\t\tdefer close(next)\n\t\t\t\tif item.Error() {\n\t\t\t\t\tnext <- item\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tnext <- item\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase item, ok := <-it:\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif item.Error() {\n\t\t\t\t\t\t\tnext <- item\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext <- item\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfor _, o := range observables {\n\t\tgo f(o)\n\t}\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// CombineLatest combines the latest item emitted by each Observable via a specified function\n// and emit items based on the results of this function.\nfunc CombineLatest(f FuncN, observables []Observable, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(emptyContext)\n\tnext := option.buildChannel()\n\n\tgo func() {\n\t\tsize := uint32(len(observables))\n\t\tvar counter uint32\n\t\ts := make([]interface{}, size)\n\t\tmutex := sync.Mutex{}\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(int(size))\n\t\terrCh := make(chan struct{})\n\n\t\thandler := func(ctx context.Context, it Iterable, i int) {\n\t\t\tdefer wg.Done()\n\t\t\tobserve := it.Observe(opts...)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase item, ok := <-observe:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif item.Error() {\n\t\t\t\t\t\tnext <- item\n\t\t\t\t\t\terrCh <- struct{}{}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif s[i] == nil {\n\t\t\t\t\t\tatomic.AddUint32(&counter, 1)\n\t\t\t\t\t}\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\ts[i] = item.V\n\t\t\t\t\tif atomic.LoadUint32(&counter) == size {\n\t\t\t\t\t\tnext <- Of(f(s...))\n\t\t\t\t\t}\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tfor i, o := range observables {\n\t\t\tgo handler(ctx, o, i)\n\t\t}\n\n\t\tgo func() {\n\t\t\tfor range errCh {\n\t\t\t\tcancel()\n\t\t\t}\n\t\t}()\n\n\t\twg.Wait()\n\t\tclose(next)\n\t\tclose(errCh)\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Concat emits the emissions from two or more Observables without interleaving them.\nfunc Concat(observables []Observable, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(emptyContext)\n\tnext := option.buildChannel()\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tfor _, obs := range observables {\n\t\t\tobserve := obs.Observe(opts...)\n\t\tloop:\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase item, ok := <-observe:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\t}\n\t\t\t\t\tif item.Error() {\n\t\t\t\t\t\tnext <- item\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tnext <- item\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Create creates an Observable from scratch by calling observer methods programmatically.\nfunc Create(f []Producer, opts ...Option) Observable {\n\treturn &ObservableImpl{\n\t\titerable: newCreateIterable(f, opts...),\n\t}\n}\n\n// Defer does not create the Observable until the observer subscribes,\n// and creates a fresh Observable for each observer.\nfunc Defer(f []Producer, opts ...Option) Observable {\n\treturn &ObservableImpl{\n\t\titerable: newDeferIterable(f, opts...),\n\t}\n}\n\n// Empty creates an Observable with no item and terminate immediately.\nfunc Empty() Observable {\n\tnext := make(chan Item)\n\tclose(next)\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// FromChannel creates a cold observable from a channel.\nfunc FromChannel(next <-chan Item, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(emptyContext)\n\treturn &ObservableImpl{\n\t\tparent:   ctx,\n\t\titerable: newChannelIterable(next, opts...),\n\t}\n}\n\n// FromEventSource creates a hot observable from a channel.\nfunc FromEventSource(next <-chan Item, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\n\treturn &ObservableImpl{\n\t\titerable: newEventSourceIterable(option.buildContext(emptyContext), next, option.getBackPressureStrategy()),\n\t}\n}\n\n// Interval creates an Observable emitting incremental integers infinitely between\n// each given time interval.\nfunc Interval(interval Duration, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(emptyContext)\n\n\tgo func() {\n\t\ti := 0\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(interval.duration()):\n\t\t\t\tif !Of(i).SendContext(ctx, next) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\tcase <-ctx.Done():\n\t\t\t\tclose(next)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\treturn &ObservableImpl{\n\t\titerable: newEventSourceIterable(ctx, next, option.getBackPressureStrategy()),\n\t}\n}\n\n// Just creates an Observable with the provided items.\nfunc Just(items ...interface{}) func(opts ...Option) Observable {\n\treturn func(opts ...Option) Observable {\n\t\treturn &ObservableImpl{\n\t\t\titerable: newJustIterable(items...)(opts...),\n\t\t}\n\t}\n}\n\n// JustItem creates a single from one item.\nfunc JustItem(item interface{}, opts ...Option) Single {\n\treturn &SingleImpl{\n\t\titerable: newJustIterable(item)(opts...),\n\t}\n}\n\n// Merge combines multiple Observables into one by merging their emissions\nfunc Merge(observables []Observable, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(emptyContext)\n\tnext := option.buildChannel()\n\twg := sync.WaitGroup{}\n\twg.Add(len(observables))\n\n\tf := func(o Observable) {\n\t\tdefer wg.Done()\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\tnext <- item\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tnext <- item\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, o := range observables {\n\t\tgo f(o)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(next)\n\t}()\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Never creates an Observable that emits no items and does not terminate.\nfunc Never() Observable {\n\tnext := make(chan Item)\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Range creates an Observable that emits count sequential integers beginning\n// at start.\nfunc Range(start, count int, opts ...Option) Observable {\n\tif count < 0 {\n\t\treturn Thrown(IllegalInputError{error: \"count must be positive\"})\n\t}\n\tif start+count-1 > math.MaxInt32 {\n\t\treturn Thrown(IllegalInputError{error: \"max value is bigger than math.MaxInt32\"})\n\t}\n\treturn &ObservableImpl{\n\t\titerable: newRangeIterable(start, count, opts...),\n\t}\n}\n\n// Start creates an Observable from one or more directive-like Supplier\n// and emits the result of each operation asynchronously on a new Observable.\nfunc Start(fs []Supplier, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(emptyContext)\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tfor _, f := range fs {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase next <- f(ctx):\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Thrown creates an Observable that emits no items and terminates with an error.\nfunc Thrown(err error) Observable {\n\tnext := make(chan Item, 1)\n\tnext <- Error(err)\n\tclose(next)\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Timer returns an Observable that completes after a specified delay.\nfunc Timer(d Duration, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := make(chan Item, 1)\n\tctx := option.buildContext(emptyContext)\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase <-time.After(d.duration()):\n\t\t\treturn\n\t\t}\n\t}()\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n"
        },
        {
          "name": "factory_connectable_test.go",
          "type": "blob",
          "size": 7.8701171875,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/goleak\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nfunc Test_Connectable_IterableChannel_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 10)\n\tgo func() {\n\t\tch <- Of(1)\n\t\tch <- Of(2)\n\t\tch <- Of(3)\n\t\tclose(ch)\n\t}()\n\tobs := &ObservableImpl{\n\t\titerable: newChannelIterable(ch, WithPublishStrategy()),\n\t}\n\ttestConnectableSingle(t, obs)\n}\n\nfunc Test_Connectable_IterableChannel_Composed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 10)\n\tgo func() {\n\t\tch <- Of(1)\n\t\tch <- Of(2)\n\t\tch <- Of(3)\n\t\tclose(ch)\n\t}()\n\tobs := &ObservableImpl{\n\t\titerable: newChannelIterable(ch, WithPublishStrategy()),\n\t}\n\ttestConnectableComposed(t, obs)\n}\n\nfunc Test_Connectable_IterableChannel_Disposed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 10)\n\tgo func() {\n\t\tch <- Of(1)\n\t\tch <- Of(2)\n\t\tch <- Of(3)\n\t\tclose(ch)\n\t}()\n\tobs := &ObservableImpl{\n\t\titerable: newChannelIterable(ch, WithPublishStrategy()),\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\t_, disposable := obs.Connect(ctx)\n\tdisposable()\n\ttime.Sleep(50 * time.Millisecond)\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Connectable_IterableChannel_WithoutConnect(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 10)\n\tgo func() {\n\t\tch <- Of(1)\n\t\tch <- Of(2)\n\t\tch <- Of(3)\n\t\tclose(ch)\n\t}()\n\tobs := &ObservableImpl{\n\t\titerable: newChannelIterable(ch, WithPublishStrategy()),\n\t}\n\ttestConnectableWithoutConnect(t, obs)\n}\n\nfunc Test_Connectable_IterableCreate_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newCreateIterable([]Producer{func(_ context.Context, ch chan<- Item) {\n\t\t\tch <- Of(1)\n\t\t\tch <- Of(2)\n\t\t\tch <- Of(3)\n\t\t\tcancel()\n\t\t}}, WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableSingle(t, obs)\n}\n\nfunc Test_Connectable_IterableCreate_Composed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newCreateIterable([]Producer{func(_ context.Context, ch chan<- Item) {\n\t\t\tch <- Of(1)\n\t\t\tch <- Of(2)\n\t\t\tch <- Of(3)\n\t\t\tcancel()\n\t\t}}, WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableComposed(t, obs)\n}\n\nfunc Test_Connectable_IterableCreate_Disposed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newCreateIterable([]Producer{func(_ context.Context, ch chan<- Item) {\n\t\t\tch <- Of(1)\n\t\t\tch <- Of(2)\n\t\t\tch <- Of(3)\n\t\t\tcancel()\n\t\t}}, WithPublishStrategy(), WithContext(ctx)),\n\t}\n\tobs.Connect(ctx)\n\t_, cancel2 := context.WithTimeout(context.Background(), 550*time.Millisecond)\n\tdefer cancel2()\n\ttime.Sleep(50 * time.Millisecond)\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Connectable_IterableCreate_WithoutConnect(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newCreateIterable([]Producer{func(_ context.Context, ch chan<- Item) {\n\t\t\tch <- Of(1)\n\t\t\tch <- Of(2)\n\t\t\tch <- Of(3)\n\t\t\tcancel()\n\t\t}}, WithBufferedChannel(3), WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableWithoutConnect(t, obs)\n}\n\nfunc Test_Connectable_IterableDefer_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newDeferIterable([]Producer{func(_ context.Context, ch chan<- Item) {\n\t\t\tch <- Of(1)\n\t\t\tch <- Of(2)\n\t\t\tch <- Of(3)\n\t\t\tcancel()\n\t\t}}, WithBufferedChannel(3), WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableSingle(t, obs)\n}\n\nfunc Test_Connectable_IterableDefer_Composed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newDeferIterable([]Producer{func(_ context.Context, ch chan<- Item) {\n\t\t\tch <- Of(1)\n\t\t\tch <- Of(2)\n\t\t\tch <- Of(3)\n\t\t\tcancel()\n\t\t}}, WithBufferedChannel(3), WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableComposed(t, obs)\n}\n\nfunc Test_Connectable_IterableJust_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newJustIterable(1, 2, 3)(WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableSingle(t, obs)\n}\n\nfunc Test_Connectable_IterableJust_Composed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newJustIterable(1, 2, 3)(WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableComposed(t, obs)\n}\n\nfunc Test_Connectable_IterableRange_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newRangeIterable(1, 3, WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableSingle(t, obs)\n}\n\nfunc Test_Connectable_IterableRange_Composed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{\n\t\titerable: newRangeIterable(1, 3, WithPublishStrategy(), WithContext(ctx)),\n\t}\n\ttestConnectableComposed(t, obs)\n}\n\nfunc Test_Connectable_IterableSlice_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{iterable: newSliceIterable([]Item{Of(1), Of(2), Of(3)},\n\t\tWithPublishStrategy(), WithContext(ctx))}\n\ttestConnectableSingle(t, obs)\n}\n\nfunc Test_Connectable_IterableSlice_Composed(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := &ObservableImpl{iterable: newSliceIterable([]Item{Of(1), Of(2), Of(3)},\n\t\tWithPublishStrategy(), WithContext(ctx))}\n\ttestConnectableComposed(t, obs)\n}\n\nfunc testConnectableSingle(t *testing.T, obs Observable) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\teg, _ := errgroup.WithContext(ctx)\n\n\texpected := []interface{}{1, 2, 3}\n\n\tnbConsumers := 3\n\twg := sync.WaitGroup{}\n\twg.Add(nbConsumers)\n\t// Before Connect() is called we create multiple observers\n\t// We check all observers receive the same items\n\tfor i := 0; i < nbConsumers; i++ {\n\t\teg.Go(func() error {\n\t\t\tobserver := obs.Observe(WithContext(ctx))\n\t\t\twg.Done()\n\t\t\tgot, err := collect(ctx, observer)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, expected) {\n\t\t\t\treturn fmt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\n\twg.Wait()\n\tobs.Connect(ctx)\n\tassert.NoError(t, eg.Wait())\n}\n\nfunc testConnectableComposed(t *testing.T, obs Observable) {\n\tobs = obs.Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t}, WithPublishStrategy())\n\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\teg, _ := errgroup.WithContext(ctx)\n\n\texpected := []interface{}{2, 3, 4}\n\n\tnbConsumers := 3\n\twg := sync.WaitGroup{}\n\twg.Add(nbConsumers)\n\t// Before Connect() is called we create multiple observers\n\t// We check all observers receive the same items\n\tfor i := 0; i < nbConsumers; i++ {\n\t\teg.Go(func() error {\n\t\t\tobserver := obs.Observe(WithContext(ctx))\n\t\t\twg.Done()\n\n\t\t\tgot, err := collect(ctx, observer)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, expected) {\n\t\t\t\treturn fmt.Errorf(\"expected: %v, got: %v\", expected, got)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\n\twg.Wait()\n\tobs.Connect(ctx)\n\tassert.NoError(t, eg.Wait())\n}\n\nfunc testConnectableWithoutConnect(t *testing.T, obs Observable) {\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\tAssert(ctx, t, obs, IsEmpty())\n}\n"
        },
        {
          "name": "factory_test.go",
          "type": "blob",
          "size": 14.5048828125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc collect(ctx context.Context, ch <-chan Item) ([]interface{}, error) {\n\ts := make([]interface{}, 0)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tcase item, ok := <-ch:\n\t\t\tif !ok {\n\t\t\t\treturn s, nil\n\t\t\t}\n\t\t\tif item.Error() {\n\t\t\t\ts = append(s, item.E)\n\t\t\t} else {\n\t\t\t\ts = append(s, item.V)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_Amb1(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Amb([]Observable{testObservable(ctx, 1, 2, 3), Empty()})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_Amb2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Amb([]Observable{Empty(), testObservable(ctx, 1, 2, 3), Empty(), Empty()})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_CombineLatest(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := CombineLatest(func(ii ...interface{}) interface{} {\n\t\tsum := 0\n\t\tfor _, v := range ii {\n\t\t\tif v == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsum += v.(int)\n\t\t}\n\t\treturn sum\n\t}, []Observable{testObservable(ctx, 1, 2), testObservable(ctx, 10, 11)})\n\tAssert(context.Background(), t, obs, IsNotEmpty())\n}\n\nfunc Test_CombineLatest_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := CombineLatest(func(ii ...interface{}) interface{} {\n\t\tsum := 0\n\t\tfor _, v := range ii {\n\t\t\tsum += v.(int)\n\t\t}\n\t\treturn sum\n\t}, []Observable{testObservable(ctx, 1, 2), Empty()})\n\tAssert(context.Background(), t, obs, IsEmpty())\n}\n\nfunc Test_CombineLatest_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := CombineLatest(func(ii ...interface{}) interface{} {\n\t\tsum := 0\n\t\tfor _, v := range ii {\n\t\t\tsum += v.(int)\n\t\t}\n\t\treturn sum\n\t}, []Observable{testObservable(ctx, 1, 2), testObservable(ctx, errFoo)})\n\tAssert(context.Background(), t, obs, IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Concat_SingleObservable(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Concat([]Observable{testObservable(ctx, 1, 2, 3)})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_Concat_TwoObservables(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Concat([]Observable{testObservable(ctx, 1, 2, 3), testObservable(ctx, 4, 5, 6)})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3, 4, 5, 6))\n}\n\nfunc Test_Concat_MoreThanTwoObservables(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Concat([]Observable{testObservable(ctx, 1, 2, 3), testObservable(ctx, 4, 5, 6), testObservable(ctx, 7, 8, 9)})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3, 4, 5, 6, 7, 8, 9))\n}\n\nfunc Test_Concat_EmptyObservables(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Concat([]Observable{Empty(), Empty(), Empty()})\n\tAssert(context.Background(), t, obs, IsEmpty())\n}\n\nfunc Test_Concat_OneEmptyObservable(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Concat([]Observable{Empty(), testObservable(ctx, 1, 2, 3)})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3))\n\n\tobs = Concat([]Observable{testObservable(ctx, 1, 2, 3), Empty()})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_Create(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Create([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Of(3)\n\t}})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_Create_SingleDup(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Create([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Of(3)\n\t}})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n\tAssert(context.Background(), t, obs, IsEmpty(), HasNoError())\n}\n\nfunc Test_Create_ContextCancelled(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tclosed1 := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tCreate([]Producer{\n\t\tfunc(ctx context.Context, next chan<- Item) {\n\t\t\tcancel()\n\t\t}, func(ctx context.Context, next chan<- Item) {\n\t\t\t<-ctx.Done()\n\t\t\tclosed1 <- struct{}{}\n\t\t},\n\t}, WithContext(ctx)).Run()\n\n\tselect {\n\tcase <-time.Tick(time.Second):\n\t\tassert.FailNow(t, \"producer not closed\")\n\tcase <-closed1:\n\t}\n}\n\nfunc Test_Defer(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Of(3)\n\t}})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_Defer_Multiple(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t}, func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(10)\n\t\tnext <- Of(20)\n\t}})\n\tAssert(context.Background(), t, obs, HasItemsNoOrder(1, 2, 10, 20), HasNoError())\n}\n\nfunc Test_Defer_ContextCancelled(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tclosed1 := make(chan struct{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tDefer([]Producer{\n\t\tfunc(ctx context.Context, next chan<- Item) {\n\t\t\tcancel()\n\t\t}, func(ctx context.Context, next chan<- Item) {\n\t\t\t<-ctx.Done()\n\t\t\tclosed1 <- struct{}{}\n\t\t},\n\t}, WithContext(ctx)).Run()\n\n\tselect {\n\tcase <-time.Tick(time.Second):\n\t\tassert.FailNow(t, \"producer not closed\")\n\tcase <-closed1:\n\t}\n}\n\nfunc Test_Defer_SingleDup(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Of(3)\n\t}})\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_Defer_ComposedDup(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Of(3)\n\t}}).Map(func(_ context.Context, i interface{}) (_ interface{}, _ error) {\n\t\treturn i.(int) + 1, nil\n\t}).Map(func(_ context.Context, i interface{}) (_ interface{}, _ error) {\n\t\treturn i.(int) + 1, nil\n\t})\n\tAssert(context.Background(), t, obs, HasItems(3, 4, 5), HasNoError())\n\tAssert(context.Background(), t, obs, HasItems(3, 4, 5), HasNoError())\n}\n\nfunc Test_Defer_ComposedDup_EagerObservation(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Of(3)\n\t}}).Map(func(_ context.Context, i interface{}) (_ interface{}, _ error) {\n\t\treturn i.(int) + 1, nil\n\t}, WithObservationStrategy(Eager)).Map(func(_ context.Context, i interface{}) (_ interface{}, _ error) {\n\t\treturn i.(int) + 1, nil\n\t})\n\tAssert(context.Background(), t, obs, HasItems(3, 4, 5), HasNoError())\n\t// In the case of an eager observation, we already consumed the items produced by Defer\n\t// So if we create another subscription, it will be empty\n\tAssert(context.Background(), t, obs, IsEmpty(), HasNoError())\n}\n\nfunc Test_Defer_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Error(errFoo)\n\t}})\n\tAssert(context.Background(), t, obs, HasItems(1, 2), HasError(errFoo))\n}\n\nfunc Test_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Empty()\n\tAssert(context.Background(), t, obs, IsEmpty())\n}\n\nfunc Test_FromChannel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item)\n\tgo func() {\n\t\tch <- Of(1)\n\t\tch <- Of(2)\n\t\tch <- Of(3)\n\t\tclose(ch)\n\t}()\n\tobs := FromChannel(ch)\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_FromChannel_SimpleCapacity(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := FromChannel(make(chan Item, 10)).Observe()\n\tassert.Equal(t, 10, cap(ch))\n}\n\nfunc Test_FromChannel_ComposedCapacity(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\n\tobs1 := FromChannel(make(chan Item, 10)).\n\t\tMap(func(_ context.Context, _ interface{}) (interface{}, error) {\n\t\t\treturn 1, nil\n\t\t}, WithContext(ctx), WithBufferedChannel(11))\n\tassert.Equal(t, 11, cap(obs1.Observe()))\n\n\tobs2 := obs1.Map(func(_ context.Context, _ interface{}) (interface{}, error) {\n\t\treturn 1, nil\n\t}, WithContext(ctx), WithBufferedChannel(12))\n\tassert.Equal(t, 12, cap(obs2.Observe()))\n}\n\nfunc Test_FromEventSource_ObservationAfterAllSent(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tconst max = 10\n\tnext := make(chan Item, max)\n\tobs := FromEventSource(next, WithBackPressureStrategy(Drop))\n\n\tgo func() {\n\t\tfor i := 0; i < max; i++ {\n\t\t\tnext <- Of(i)\n\t\t}\n\t\tclose(next)\n\t}()\n\ttime.Sleep(50 * time.Millisecond)\n\n\tAssert(context.Background(), t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) != 0 {\n\t\t\treturn errors.New(\"items should be nil\")\n\t\t}\n\t\treturn nil\n\t}))\n}\n\nfunc Test_FromEventSource_Drop(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tconst max = 100000\n\tnext := make(chan Item, max)\n\tobs := FromEventSource(next, WithBackPressureStrategy(Drop))\n\n\tgo func() {\n\t\tfor i := 0; i < max; i++ {\n\t\t\tnext <- Of(i)\n\t\t}\n\t\tclose(next)\n\t}()\n\n\tAssert(context.Background(), t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) == max {\n\t\t\treturn errors.New(\"some items should be dropped\")\n\t\t}\n\t\tif len(items) == 0 {\n\t\t\treturn errors.New(\"no items\")\n\t\t}\n\t\treturn nil\n\t}))\n}\n\n// FIXME\n//func Test_Interval(t *testing.T) {\n//\tdefer goleak.VerifyNone(t)\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tobs := Interval(WithDuration(time.Nanosecond), WithContext(ctx))\n//\tgo func() {\n//\t\ttime.Sleep(50 * time.Millisecond)\n//\t\tcancel()\n//\t}()\n//\tAssert(context.Background(), t, obs, IsNotEmpty())\n//}\n\nfunc Test_JustItem(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tsingle := JustItem(1)\n\tAssert(context.Background(), t, single, HasItem(1), HasNoError())\n\tAssert(context.Background(), t, single, HasItem(1), HasNoError())\n}\n\nfunc Test_Just(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Just(1, 2, 3)()\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_Just_CustomStructure(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\ttype customer struct {\n\t\tid int\n\t}\n\n\tobs := Just(customer{id: 1}, customer{id: 2}, customer{id: 3})()\n\tAssert(context.Background(), t, obs, HasItems(customer{id: 1}, customer{id: 2}, customer{id: 3}), HasNoError())\n\tAssert(context.Background(), t, obs, HasItems(customer{id: 1}, customer{id: 2}, customer{id: 3}), HasNoError())\n}\n\nfunc Test_Just_Channel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan int, 1)\n\tgo func() {\n\t\tch <- 1\n\t\tch <- 2\n\t\tch <- 3\n\t\tclose(ch)\n\t}()\n\tobs := Just(ch)()\n\tAssert(context.Background(), t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_Just_SimpleCapacity(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := Just(1)(WithBufferedChannel(5)).Observe()\n\tassert.Equal(t, 5, cap(ch))\n}\n\nfunc Test_Just_ComposedCapacity(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs1 := Just(1)().Map(func(_ context.Context, _ interface{}) (interface{}, error) {\n\t\treturn 1, nil\n\t}, WithBufferedChannel(11))\n\tassert.Equal(t, 11, cap(obs1.Observe()))\n\n\tobs2 := obs1.Map(func(_ context.Context, _ interface{}) (interface{}, error) {\n\t\treturn 1, nil\n\t}, WithBufferedChannel(12))\n\tassert.Equal(t, 12, cap(obs2.Observe()))\n}\n\nfunc Test_Merge(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Merge([]Observable{testObservable(ctx, 1, 2), testObservable(ctx, 3, 4)})\n\tAssert(context.Background(), t, obs, HasItemsNoOrder(1, 2, 3, 4))\n}\n\nfunc Test_Merge_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Merge([]Observable{testObservable(ctx, 1, 2), testObservable(ctx, 3, errFoo)})\n\t// The content is not deterministic, hence we just test if we have some items\n\tAssert(context.Background(), t, obs, IsNotEmpty(), HasError(errFoo))\n}\n\n// FIXME\n//func Test_Merge_Interval(t *testing.T) {\n//\tdefer goleak.VerifyNone(t)\n//\tvar obs []Observable\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tobs = append(obs, Interval(WithDuration(3*time.Millisecond), WithContext(ctx)).\n//\t\tTake(3).\n//\t\tMap(func(_ context.Context, v interface{}) (interface{}, error) {\n//\t\t\treturn 10 + v.(int), nil\n//\t\t}))\n//\tobs = append(obs, Interval(WithDuration(5*time.Millisecond), WithContext(ctx)).\n//\t\tTake(3).\n//\t\tMap(func(_ context.Context, v interface{}) (interface{}, error) {\n//\t\t\treturn 20 + v.(int), nil\n//\t\t}))\n//\n//\tgo func() {\n//\t\ttime.Sleep(50 * time.Millisecond)\n//\t\tcancel()\n//\t}()\n//\tAssert(ctx, t, Merge(obs), HasNoError(), HasItemsNoOrder(10, 11, 12, 20, 21, 22))\n//}\n\nfunc Test_Range(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Range(5, 3)\n\tAssert(context.Background(), t, obs, HasItems(5, 6, 7))\n\t// Test whether the observable is reproducible\n\tAssert(context.Background(), t, obs, HasItems(5, 6, 7))\n}\n\nfunc Test_Range_NegativeCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Range(1, -5)\n\tAssert(context.Background(), t, obs, HasAnError())\n}\n\nfunc Test_Range_MaximumExceeded(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Range(1<<31, 1)\n\tAssert(context.Background(), t, obs, HasAnError())\n}\n\nfunc Test_Start(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Start([]Supplier{func(ctx context.Context) Item {\n\t\treturn Of(1)\n\t}, func(ctx context.Context) Item {\n\t\treturn Of(2)\n\t}})\n\tAssert(context.Background(), t, obs, HasItemsNoOrder(1, 2))\n}\n\nfunc Test_Thrown(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Thrown(errFoo)\n\tAssert(context.Background(), t, obs, HasError(errFoo))\n}\n\nfunc Test_Timer(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs := Timer(WithDuration(time.Nanosecond))\n\tselect {\n\tcase <-time.Tick(time.Second):\n\t\tassert.FailNow(t, \"observable not closed\")\n\tcase <-obs.Observe():\n\t}\n}\n\nfunc Test_Timer_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tobs := Timer(WithDuration(time.Hour), WithContext(ctx))\n\tgo func() {\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tcancel()\n\t}()\n\tselect {\n\tcase <-time.Tick(time.Second):\n\t\tassert.FailNow(t, \"observable not closed\")\n\tcase <-obs.Observe():\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3076171875,
          "content": "module github.com/reactivex/rxgo/v2\n\ngo 1.13\n\nrequire (\n\tgithub.com/cenkalti/backoff/v4 v4.1.1\n\tgithub.com/emirpasic/gods v1.12.0\n\tgithub.com/stretchr/testify v1.8.0\n\tgithub.com/teivah/onecontext v0.0.0-20200513185103-40f981bfd775\n\tgo.uber.org/goleak v1.1.12\n\tgolang.org/x/sync v0.0.0-20210220032951-036812b2e83c\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.9326171875,
          "content": "github.com/cenkalti/backoff/v4 v4.1.1 h1:G2HAfAmvm/GcKan2oOQpBXOd2tT2G57ZnZGWa1PxPBQ=\ngithub.com/cenkalti/backoff/v4 v4.1.1/go.mod h1:scbssz8iZGpm3xbr14ovlUdkxfGXNInqkPWOWmG2CLw=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/emirpasic/gods v1.12.0 h1:QAUIPSaCu4G+POclxeqb3F+WPpdKqFGlw36+yOzGlrg=\ngithub.com/emirpasic/gods v1.12.0/go.mod h1:YfzfFFoVP/catgzJb4IKIqXjX78Ha8FMSDh3ymbK86o=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0 h1:M2gUjqZET1qApGOWNSnZ49BAIMX4F/1plDv3+l31EJ4=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0 h1:pSgiaMZlXftHpm5L7V1+rVB+AZJydKsMxsQBIJw4PKk=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/teivah/onecontext v0.0.0-20200513185103-40f981bfd775 h1:BLNsFR8l/hj/oGjnJXkd4Vi3s4kQD3/3x8HSAE4bzN0=\ngithub.com/teivah/onecontext v0.0.0-20200513185103-40f981bfd775/go.mod h1:XUZ4x3oGhWfiOnUvTslnKKs39AWUct3g3yJvXTQSJOQ=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngo.uber.org/goleak v1.1.12 h1:gZAh5/EyT/HQwlpkCy6wTpqfH9H8Lz8zbm3dZh+OyzA=\ngo.uber.org/goleak v1.1.12/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de h1:5hukYrvBGR8/eNkX5mdUezrA6JiaEZDtJb9Ei+1LlBs=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.4.2 h1:Gz96sIWK3OalVv/I/qNygP42zyoKp3xptRVCWRFEBvo=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c h1:5KslGYwFpkhGh+Q16bwMP3cOontH8FOep7tGV86Y7SQ=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007 h1:gG67DSER+11cZvqIMb8S8bt0vZtiN6xWYARwirrOSfE=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.5 h1:ouewzE6p+/VEB31YYnTbEJdi8pFqKp4P4n85vwo3DHA=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "item.go",
          "type": "blob",
          "size": 2.7119140625,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"time\"\n)\n\ntype (\n\t// Item is a wrapper having either a value or an error.\n\tItem struct {\n\t\tV interface{}\n\t\tE error\n\t}\n\n\t// TimestampItem attach a timestamp to an item.\n\tTimestampItem struct {\n\t\tTimestamp time.Time\n\t\tV         interface{}\n\t}\n\n\t// CloseChannelStrategy indicates a strategy on whether to close a channel.\n\tCloseChannelStrategy uint32\n)\n\nconst (\n\t// LeaveChannelOpen indicates to leave the channel open after completion.\n\tLeaveChannelOpen CloseChannelStrategy = iota\n\t// CloseChannel indicates to close the channel open after completion.\n\tCloseChannel\n)\n\n// Of creates an item from a value.\nfunc Of(i interface{}) Item {\n\treturn Item{V: i}\n}\n\n// Error creates an item from an error.\nfunc Error(err error) Item {\n\treturn Item{E: err}\n}\n\n// SendItems is an utility function that send a list of interface{} and indicate a strategy on whether to close\n// the channel once the function completes.\nfunc SendItems(ctx context.Context, ch chan<- Item, strategy CloseChannelStrategy, items ...interface{}) {\n\tif strategy == CloseChannel {\n\t\tdefer close(ch)\n\t}\n\tsend(ctx, ch, items...)\n}\n\nfunc send(ctx context.Context, ch chan<- Item, items ...interface{}) {\n\tfor _, currentItem := range items {\n\t\tswitch item := currentItem.(type) {\n\t\tdefault:\n\t\t\trt := reflect.TypeOf(item)\n\t\t\tswitch rt.Kind() {\n\t\t\tdefault:\n\t\t\t\tOf(item).SendContext(ctx, ch)\n\t\t\tcase reflect.Chan:\n\t\t\t\tin := reflect.ValueOf(currentItem)\n\t\t\t\tfor {\n\t\t\t\t\tv, ok := in.Recv()\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcurrentItem := v.Interface()\n\t\t\t\t\tswitch item := currentItem.(type) {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tOf(item).SendContext(ctx, ch)\n\t\t\t\t\tcase error:\n\t\t\t\t\t\tError(item).SendContext(ctx, ch)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase reflect.Slice:\n\t\t\t\ts := reflect.ValueOf(currentItem)\n\t\t\t\tfor i := 0; i < s.Len(); i++ {\n\t\t\t\t\tsend(ctx, ch, s.Index(i).Interface())\n\t\t\t\t}\n\t\t\t}\n\t\tcase error:\n\t\t\tError(item).SendContext(ctx, ch)\n\t\t}\n\t}\n}\n\n// Error checks if an item is an error.\nfunc (i Item) Error() bool {\n\treturn i.E != nil\n}\n\n// SendBlocking sends an item and blocks until it is sent.\nfunc (i Item) SendBlocking(ch chan<- Item) {\n\tch <- i\n}\n\n// SendContext sends an item and blocks until it is sent or a context canceled.\n// It returns a boolean to indicate whether the item was sent.\nfunc (i Item) SendContext(ctx context.Context, ch chan<- Item) bool {\n\tselect {\n\tcase <-ctx.Done(): // Context's done channel has the highest priority\n\t\treturn false\n\tdefault:\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn false\n\t\tcase ch <- i:\n\t\t\treturn true\n\t\t}\n\t}\n}\n\n// SendNonBlocking sends an item without blocking.\n// It returns a boolean to indicate whether the item was sent.\nfunc (i Item) SendNonBlocking(ch chan<- Item) bool {\n\tselect {\n\tdefault:\n\t\treturn false\n\tcase ch <- i:\n\t\treturn true\n\t}\n}\n"
        },
        {
          "name": "item_test.go",
          "type": "blob",
          "size": 1.953125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc Test_SendItems_Variadic(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 3)\n\tgo SendItems(context.Background(), ch, CloseChannel, 1, 2, 3)\n\tAssert(context.Background(), t, FromChannel(ch), HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_SendItems_VariadicWithError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 3)\n\tgo SendItems(context.Background(), ch, CloseChannel, 1, errFoo, 3)\n\tAssert(context.Background(), t, FromChannel(ch), HasItems(1, 3), HasError(errFoo))\n}\n\nfunc Test_SendItems_Slice(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 3)\n\tgo SendItems(context.Background(), ch, CloseChannel, []int{1, 2, 3})\n\tAssert(context.Background(), t, FromChannel(ch), HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_SendItems_SliceWithError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 3)\n\tgo SendItems(context.Background(), ch, CloseChannel, []interface{}{1, errFoo, 3})\n\tAssert(context.Background(), t, FromChannel(ch), HasItems(1, 3), HasError(errFoo))\n}\n\nfunc Test_Item_SendBlocking(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 1)\n\tdefer close(ch)\n\tOf(5).SendBlocking(ch)\n\tassert.Equal(t, 5, (<-ch).V)\n}\n\nfunc Test_Item_SendContext_True(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 1)\n\tdefer close(ch)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.True(t, Of(5).SendContext(ctx, ch))\n}\n\nfunc Test_Item_SendContext_False(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 1)\n\tdefer close(ch)\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tassert.False(t, Of(5).SendContext(ctx, ch))\n}\n\nfunc Test_Item_SendNonBlocking(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item, 1)\n\tdefer close(ch)\n\tassert.True(t, Of(5).SendNonBlocking(ch))\n\tassert.False(t, Of(5).SendNonBlocking(ch))\n}\n"
        },
        {
          "name": "iterable.go",
          "type": "blob",
          "size": 0.1279296875,
          "content": "package rxgo\n\n// Iterable is the basic type that can be observed.\ntype Iterable interface {\n\tObserve(opts ...Option) <-chan Item\n}\n"
        },
        {
          "name": "iterable_channel.go",
          "type": "blob",
          "size": 1.4111328125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype channelIterable struct {\n\tnext                   <-chan Item\n\topts                   []Option\n\tsubscribers            []chan Item\n\tmutex                  sync.RWMutex\n\tproducerAlreadyCreated bool\n}\n\nfunc newChannelIterable(next <-chan Item, opts ...Option) Iterable {\n\treturn &channelIterable{\n\t\tnext:        next,\n\t\tsubscribers: make([]chan Item, 0),\n\t\topts:        opts,\n\t}\n}\n\nfunc (i *channelIterable) Observe(opts ...Option) <-chan Item {\n\tmergedOptions := append(i.opts, opts...)\n\toption := parseOptions(mergedOptions...)\n\n\tif !option.isConnectable() {\n\t\treturn i.next\n\t}\n\n\tif option.isConnectOperation() {\n\t\ti.connect(option.buildContext(emptyContext))\n\t\treturn nil\n\t}\n\n\tch := option.buildChannel()\n\ti.mutex.Lock()\n\ti.subscribers = append(i.subscribers, ch)\n\ti.mutex.Unlock()\n\treturn ch\n}\n\nfunc (i *channelIterable) connect(ctx context.Context) {\n\ti.mutex.Lock()\n\tif !i.producerAlreadyCreated {\n\t\tgo i.produce(ctx)\n\t\ti.producerAlreadyCreated = true\n\t}\n\ti.mutex.Unlock()\n}\n\nfunc (i *channelIterable) produce(ctx context.Context) {\n\tdefer func() {\n\t\ti.mutex.RLock()\n\t\tfor _, subscriber := range i.subscribers {\n\t\t\tclose(subscriber)\n\t\t}\n\t\ti.mutex.RUnlock()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase item, ok := <-i.next:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ti.mutex.RLock()\n\t\t\tfor _, subscriber := range i.subscribers {\n\t\t\t\tsubscriber <- item\n\t\t\t}\n\t\t\ti.mutex.RUnlock()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "iterable_create.go",
          "type": "blob",
          "size": 1.5390625,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype createIterable struct {\n\tnext                   <-chan Item\n\topts                   []Option\n\tsubscribers            []chan Item\n\tmutex                  sync.RWMutex\n\tproducerAlreadyCreated bool\n}\n\nfunc newCreateIterable(fs []Producer, opts ...Option) Iterable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(emptyContext)\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tfor _, f := range fs {\n\t\t\tf(ctx, next)\n\t\t}\n\t}()\n\n\treturn &createIterable{\n\t\topts: opts,\n\t\tnext: next,\n\t}\n}\n\nfunc (i *createIterable) Observe(opts ...Option) <-chan Item {\n\tmergedOptions := append(i.opts, opts...)\n\toption := parseOptions(mergedOptions...)\n\n\tif !option.isConnectable() {\n\t\treturn i.next\n\t}\n\n\tif option.isConnectOperation() {\n\t\ti.connect(option.buildContext(emptyContext))\n\t\treturn nil\n\t}\n\n\tch := option.buildChannel()\n\ti.mutex.Lock()\n\ti.subscribers = append(i.subscribers, ch)\n\ti.mutex.Unlock()\n\treturn ch\n}\n\nfunc (i *createIterable) connect(ctx context.Context) {\n\ti.mutex.Lock()\n\tif !i.producerAlreadyCreated {\n\t\tgo i.produce(ctx)\n\t\ti.producerAlreadyCreated = true\n\t}\n\ti.mutex.Unlock()\n}\n\nfunc (i *createIterable) produce(ctx context.Context) {\n\tdefer func() {\n\t\ti.mutex.RLock()\n\t\tfor _, subscriber := range i.subscribers {\n\t\t\tclose(subscriber)\n\t\t}\n\t\ti.mutex.RUnlock()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase item, ok := <-i.next:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ti.mutex.RLock()\n\t\t\tfor _, subscriber := range i.subscribers {\n\t\t\t\tsubscriber <- item\n\t\t\t}\n\t\t\ti.mutex.RUnlock()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "iterable_defer.go",
          "type": "blob",
          "size": 0.47265625,
          "content": "package rxgo\n\ntype deferIterable struct {\n\tfs   []Producer\n\topts []Option\n}\n\nfunc newDeferIterable(f []Producer, opts ...Option) Iterable {\n\treturn &deferIterable{\n\t\tfs:   f,\n\t\topts: opts,\n\t}\n}\n\nfunc (i *deferIterable) Observe(opts ...Option) <-chan Item {\n\toption := parseOptions(append(i.opts, opts...)...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(emptyContext)\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tfor _, f := range i.fs {\n\t\t\tf(ctx, next)\n\t\t}\n\t}()\n\n\treturn next\n}\n"
        },
        {
          "name": "iterable_eventsource.go",
          "type": "blob",
          "size": 1.474609375,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"sync\"\n)\n\ntype eventSourceIterable struct {\n\tsync.RWMutex\n\tobservers []chan Item\n\tdisposed  bool\n\topts      []Option\n}\n\nfunc newEventSourceIterable(ctx context.Context, next <-chan Item, strategy BackpressureStrategy, opts ...Option) Iterable {\n\tit := &eventSourceIterable{\n\t\tobservers: make([]chan Item, 0),\n\t\topts:      opts,\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tit.closeAllObservers()\n\t\t}()\n\n\t\tdeliver := func(item Item) (done bool) {\n\t\t\tit.RLock()\n\t\t\tdefer it.RUnlock()\n\n\t\t\tswitch strategy {\n\t\t\tdefault:\n\t\t\t\tfallthrough\n\t\t\tcase Block:\n\t\t\t\tfor _, observer := range it.observers {\n\t\t\t\t\tif !item.SendContext(ctx, observer) {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase Drop:\n\t\t\t\tfor _, observer := range it.observers {\n\t\t\t\t\tselect {\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn true\n\t\t\t\t\tcase observer <- item:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-next:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif done := deliver(item); done {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn it\n}\n\nfunc (i *eventSourceIterable) closeAllObservers() {\n\ti.Lock()\n\tfor _, observer := range i.observers {\n\t\tclose(observer)\n\t}\n\ti.disposed = true\n\ti.Unlock()\n}\n\nfunc (i *eventSourceIterable) Observe(opts ...Option) <-chan Item {\n\toption := parseOptions(append(i.opts, opts...)...)\n\tnext := option.buildChannel()\n\n\ti.Lock()\n\tif i.disposed {\n\t\tclose(next)\n\t} else {\n\t\ti.observers = append(i.observers, next)\n\t}\n\ti.Unlock()\n\treturn next\n}\n"
        },
        {
          "name": "iterable_factory.go",
          "type": "blob",
          "size": 0.2978515625,
          "content": "package rxgo\n\ntype factoryIterable struct {\n\tfactory func(opts ...Option) <-chan Item\n}\n\nfunc newFactoryIterable(factory func(opts ...Option) <-chan Item) Iterable {\n\treturn &factoryIterable{factory: factory}\n}\n\nfunc (i *factoryIterable) Observe(opts ...Option) <-chan Item {\n\treturn i.factory(opts...)\n}\n"
        },
        {
          "name": "iterable_just.go",
          "type": "blob",
          "size": 0.4892578125,
          "content": "package rxgo\n\ntype justIterable struct {\n\titems []interface{}\n\topts  []Option\n}\n\nfunc newJustIterable(items ...interface{}) func(opts ...Option) Iterable {\n\treturn func(opts ...Option) Iterable {\n\t\treturn &justIterable{\n\t\t\titems: items,\n\t\t\topts:  opts,\n\t\t}\n\t}\n}\n\nfunc (i *justIterable) Observe(opts ...Option) <-chan Item {\n\toption := parseOptions(append(i.opts, opts...)...)\n\tnext := option.buildChannel()\n\n\tgo SendItems(option.buildContext(emptyContext), next, CloseChannel, i.items)\n\treturn next\n}\n"
        },
        {
          "name": "iterable_range.go",
          "type": "blob",
          "size": 0.5859375,
          "content": "package rxgo\n\ntype rangeIterable struct {\n\tstart, count int\n\topts         []Option\n}\n\nfunc newRangeIterable(start, count int, opts ...Option) Iterable {\n\treturn &rangeIterable{\n\t\tstart: start,\n\t\tcount: count,\n\t\topts:  opts,\n\t}\n}\n\nfunc (i *rangeIterable) Observe(opts ...Option) <-chan Item {\n\toption := parseOptions(append(i.opts, opts...)...)\n\tctx := option.buildContext(emptyContext)\n\tnext := option.buildChannel()\n\n\tgo func() {\n\t\tfor idx := i.start; idx <= i.start+i.count-1; idx++ {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase next <- Of(idx):\n\t\t\t}\n\t\t}\n\t\tclose(next)\n\t}()\n\treturn next\n}\n"
        },
        {
          "name": "iterable_slice.go",
          "type": "blob",
          "size": 0.5302734375,
          "content": "package rxgo\n\ntype sliceIterable struct {\n\titems []Item\n\topts  []Option\n}\n\nfunc newSliceIterable(items []Item, opts ...Option) Iterable {\n\treturn &sliceIterable{\n\t\titems: items,\n\t\topts:  opts,\n\t}\n}\n\nfunc (i *sliceIterable) Observe(opts ...Option) <-chan Item {\n\toption := parseOptions(append(i.opts, opts...)...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(emptyContext)\n\n\tgo func() {\n\t\tfor _, item := range i.items {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase next <- item:\n\t\t\t}\n\t\t}\n\t\tclose(next)\n\t}()\n\treturn next\n}\n"
        },
        {
          "name": "observable.go",
          "type": "blob",
          "size": 14.6708984375,
          "content": "// Package rxgo is the main RxGo package.\npackage rxgo\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/emirpasic/gods/trees/binaryheap\"\n)\n\n// Observable is the standard interface for Observables.\ntype Observable interface {\n\tIterable\n\tAll(predicate Predicate, opts ...Option) Single\n\tAverageFloat32(opts ...Option) Single\n\tAverageFloat64(opts ...Option) Single\n\tAverageInt(opts ...Option) Single\n\tAverageInt8(opts ...Option) Single\n\tAverageInt16(opts ...Option) Single\n\tAverageInt32(opts ...Option) Single\n\tAverageInt64(opts ...Option) Single\n\tBackOffRetry(backOffCfg backoff.BackOff, opts ...Option) Observable\n\tBufferWithCount(count int, opts ...Option) Observable\n\tBufferWithTime(timespan Duration, opts ...Option) Observable\n\tBufferWithTimeOrCount(timespan Duration, count int, opts ...Option) Observable\n\tConnect(ctx context.Context) (context.Context, Disposable)\n\tContains(equal Predicate, opts ...Option) Single\n\tCount(opts ...Option) Single\n\tDebounce(timespan Duration, opts ...Option) Observable\n\tDefaultIfEmpty(defaultValue interface{}, opts ...Option) Observable\n\tDistinct(apply Func, opts ...Option) Observable\n\tDistinctUntilChanged(apply Func, opts ...Option) Observable\n\tDoOnCompleted(completedFunc CompletedFunc, opts ...Option) Disposed\n\tDoOnError(errFunc ErrFunc, opts ...Option) Disposed\n\tDoOnNext(nextFunc NextFunc, opts ...Option) Disposed\n\tElementAt(index uint, opts ...Option) Single\n\tError(opts ...Option) error\n\tErrors(opts ...Option) []error\n\tFilter(apply Predicate, opts ...Option) Observable\n\tFind(find Predicate, opts ...Option) OptionalSingle\n\tFirst(opts ...Option) OptionalSingle\n\tFirstOrDefault(defaultValue interface{}, opts ...Option) Single\n\tFlatMap(apply ItemToObservable, opts ...Option) Observable\n\tForEach(nextFunc NextFunc, errFunc ErrFunc, completedFunc CompletedFunc, opts ...Option) Disposed\n\tGroupBy(length int, distribution func(Item) int, opts ...Option) Observable\n\tGroupByDynamic(distribution func(Item) string, opts ...Option) Observable\n\tIgnoreElements(opts ...Option) Observable\n\tJoin(joiner Func2, right Observable, timeExtractor func(interface{}) time.Time, window Duration, opts ...Option) Observable\n\tLast(opts ...Option) OptionalSingle\n\tLastOrDefault(defaultValue interface{}, opts ...Option) Single\n\tMap(apply Func, opts ...Option) Observable\n\tMarshal(marshaller Marshaller, opts ...Option) Observable\n\tMax(comparator Comparator, opts ...Option) OptionalSingle\n\tMin(comparator Comparator, opts ...Option) OptionalSingle\n\tOnErrorResumeNext(resumeSequence ErrorToObservable, opts ...Option) Observable\n\tOnErrorReturn(resumeFunc ErrorFunc, opts ...Option) Observable\n\tOnErrorReturnItem(resume interface{}, opts ...Option) Observable\n\tReduce(apply Func2, opts ...Option) OptionalSingle\n\tRepeat(count int64, frequency Duration, opts ...Option) Observable\n\tRetry(count int, shouldRetry func(error) bool, opts ...Option) Observable\n\tRun(opts ...Option) Disposed\n\tSample(iterable Iterable, opts ...Option) Observable\n\tScan(apply Func2, opts ...Option) Observable\n\tSequenceEqual(iterable Iterable, opts ...Option) Single\n\tSend(output chan<- Item, opts ...Option)\n\tSerialize(from int, identifier func(interface{}) int, opts ...Option) Observable\n\tSkip(nth uint, opts ...Option) Observable\n\tSkipLast(nth uint, opts ...Option) Observable\n\tSkipWhile(apply Predicate, opts ...Option) Observable\n\tStartWith(iterable Iterable, opts ...Option) Observable\n\tSumFloat32(opts ...Option) OptionalSingle\n\tSumFloat64(opts ...Option) OptionalSingle\n\tSumInt64(opts ...Option) OptionalSingle\n\tTake(nth uint, opts ...Option) Observable\n\tTakeLast(nth uint, opts ...Option) Observable\n\tTakeUntil(apply Predicate, opts ...Option) Observable\n\tTakeWhile(apply Predicate, opts ...Option) Observable\n\tTimeInterval(opts ...Option) Observable\n\tTimestamp(opts ...Option) Observable\n\tToMap(keySelector Func, opts ...Option) Single\n\tToMapWithValueSelector(keySelector, valueSelector Func, opts ...Option) Single\n\tToSlice(initialCapacity int, opts ...Option) ([]interface{}, error)\n\tUnmarshal(unmarshaller Unmarshaller, factory func() interface{}, opts ...Option) Observable\n\tWindowWithCount(count int, opts ...Option) Observable\n\tWindowWithTime(timespan Duration, opts ...Option) Observable\n\tWindowWithTimeOrCount(timespan Duration, count int, opts ...Option) Observable\n\tZipFromIterable(iterable Iterable, zipper Func2, opts ...Option) Observable\n}\n\n// ObservableImpl implements Observable.\ntype ObservableImpl struct {\n\tparent   context.Context\n\titerable Iterable\n}\n\nfunc defaultErrorFuncOperator(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\titem.SendContext(ctx, dst)\n\toperatorOptions.stop()\n}\n\nfunc customObservableOperator(parent context.Context, f func(ctx context.Context, next chan Item, option Option, opts ...Option), opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(parent)\n\n\tif option.isEagerObservation() {\n\t\tgo f(ctx, next, option, opts...)\n\t\treturn &ObservableImpl{iterable: newChannelIterable(next)}\n\t}\n\n\treturn &ObservableImpl{\n\t\titerable: newFactoryIterable(func(propagatedOptions ...Option) <-chan Item {\n\t\t\tmergedOptions := append(opts, propagatedOptions...)\n\t\t\tgo f(ctx, next, option, mergedOptions...)\n\t\t\treturn next\n\t\t}),\n\t}\n}\n\ntype operator interface {\n\tnext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions)\n\terr(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions)\n\tend(ctx context.Context, dst chan<- Item)\n\tgatherNext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions)\n}\n\nfunc observable(parent context.Context, iterable Iterable, operatorFactory func() operator, forceSeq, bypassGather bool, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tparallel, _ := option.getPool()\n\n\tif option.isEagerObservation() {\n\t\tnext := option.buildChannel()\n\t\tctx := option.buildContext(parent)\n\t\tif forceSeq || !parallel {\n\t\t\trunSequential(ctx, next, iterable, operatorFactory, option, opts...)\n\t\t} else {\n\t\t\trunParallel(ctx, next, iterable.Observe(opts...), operatorFactory, bypassGather, option, opts...)\n\t\t}\n\t\treturn &ObservableImpl{iterable: newChannelIterable(next)}\n\t}\n\n\tif forceSeq || !parallel {\n\t\treturn &ObservableImpl{\n\t\t\titerable: newFactoryIterable(func(propagatedOptions ...Option) <-chan Item {\n\t\t\t\tmergedOptions := append(opts, propagatedOptions...)\n\t\t\t\toption := parseOptions(mergedOptions...)\n\n\t\t\t\tnext := option.buildChannel()\n\t\t\t\tctx := option.buildContext(parent)\n\t\t\t\trunSequential(ctx, next, iterable, operatorFactory, option, mergedOptions...)\n\t\t\t\treturn next\n\t\t\t}),\n\t\t}\n\t}\n\n\tif serialized, f := option.isSerialized(); serialized {\n\t\tfirstItemIDCh := make(chan Item, 1)\n\t\tfromCh := make(chan Item, 1)\n\t\tobs := &ObservableImpl{\n\t\t\titerable: newFactoryIterable(func(propagatedOptions ...Option) <-chan Item {\n\t\t\t\tmergedOptions := append(opts, propagatedOptions...)\n\t\t\t\toption := parseOptions(mergedOptions...)\n\n\t\t\t\tnext := option.buildChannel()\n\t\t\t\tctx := option.buildContext(parent)\n\t\t\t\tobserve := iterable.Observe(opts...)\n\t\t\t\tgo func() {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase firstItemID := <-firstItemIDCh:\n\t\t\t\t\t\tif firstItemID.Error() {\n\t\t\t\t\t\t\tfirstItemID.SendContext(ctx, fromCh)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOf(firstItemID.V.(int)).SendContext(ctx, fromCh)\n\t\t\t\t\t\trunParallel(ctx, next, observe, operatorFactory, bypassGather, option, mergedOptions...)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\trunFirstItem(ctx, f, firstItemIDCh, observe, next, operatorFactory, option, mergedOptions...)\n\t\t\t\treturn next\n\t\t\t}),\n\t\t}\n\t\treturn obs.serialize(parent, fromCh, f)\n\t}\n\n\treturn &ObservableImpl{\n\t\titerable: newFactoryIterable(func(propagatedOptions ...Option) <-chan Item {\n\t\t\tmergedOptions := append(opts, propagatedOptions...)\n\t\t\toption := parseOptions(mergedOptions...)\n\n\t\t\tnext := option.buildChannel()\n\t\t\tctx := option.buildContext(parent)\n\t\t\trunParallel(ctx, next, iterable.Observe(mergedOptions...), operatorFactory, bypassGather, option, mergedOptions...)\n\t\t\treturn next\n\t\t}),\n\t}\n}\n\nfunc single(parent context.Context, iterable Iterable, operatorFactory func() operator, forceSeq, bypassGather bool, opts ...Option) Single {\n\toption := parseOptions(opts...)\n\tparallel, _ := option.getPool()\n\tnext := option.buildChannel()\n\tctx := option.buildContext(parent)\n\n\tif option.isEagerObservation() {\n\t\tif forceSeq || !parallel {\n\t\t\trunSequential(ctx, next, iterable, operatorFactory, option, opts...)\n\t\t} else {\n\t\t\trunParallel(ctx, next, iterable.Observe(opts...), operatorFactory, bypassGather, option, opts...)\n\t\t}\n\t\treturn &SingleImpl{iterable: newChannelIterable(next)}\n\t}\n\n\treturn &SingleImpl{\n\t\titerable: newFactoryIterable(func(propagatedOptions ...Option) <-chan Item {\n\t\t\tmergedOptions := append(opts, propagatedOptions...)\n\t\t\toption = parseOptions(mergedOptions...)\n\n\t\t\tif forceSeq || !parallel {\n\t\t\t\trunSequential(ctx, next, iterable, operatorFactory, option, mergedOptions...)\n\t\t\t} else {\n\t\t\t\trunParallel(ctx, next, iterable.Observe(mergedOptions...), operatorFactory, bypassGather, option, mergedOptions...)\n\t\t\t}\n\t\t\treturn next\n\t\t}),\n\t}\n}\n\nfunc optionalSingle(parent context.Context, iterable Iterable, operatorFactory func() operator, forceSeq, bypassGather bool, opts ...Option) OptionalSingle {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(parent)\n\tparallel, _ := option.getPool()\n\n\tif option.isEagerObservation() {\n\t\tnext := option.buildChannel()\n\t\tif forceSeq || !parallel {\n\t\t\trunSequential(ctx, next, iterable, operatorFactory, option, opts...)\n\t\t} else {\n\t\t\trunParallel(ctx, next, iterable.Observe(opts...), operatorFactory, bypassGather, option, opts...)\n\t\t}\n\t\treturn &OptionalSingleImpl{iterable: newChannelIterable(next)}\n\t}\n\n\treturn &OptionalSingleImpl{\n\t\tparent: ctx,\n\t\titerable: newFactoryIterable(func(propagatedOptions ...Option) <-chan Item {\n\t\t\tmergedOptions := append(opts, propagatedOptions...)\n\t\t\toption = parseOptions(mergedOptions...)\n\n\t\t\tnext := option.buildChannel()\n\t\t\tctx := option.buildContext(parent)\n\t\t\tif forceSeq || !parallel {\n\t\t\t\trunSequential(ctx, next, iterable, operatorFactory, option, mergedOptions...)\n\t\t\t} else {\n\t\t\t\trunParallel(ctx, next, iterable.Observe(mergedOptions...), operatorFactory, bypassGather, option, mergedOptions...)\n\t\t\t}\n\t\t\treturn next\n\t\t}),\n\t}\n}\n\nfunc runSequential(ctx context.Context, next chan Item, iterable Iterable, operatorFactory func() operator, option Option, opts ...Option) {\n\tobserve := iterable.Observe(opts...)\n\tgo func() {\n\t\top := operatorFactory()\n\t\tstopped := false\n\t\toperator := operatorOptions{\n\t\t\tstop: func() {\n\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\tstopped = true\n\t\t\t\t}\n\t\t\t},\n\t\t\tresetIterable: func(newIterable Iterable) {\n\t\t\t\tobserve = newIterable.Observe(opts...)\n\t\t\t},\n\t\t}\n\n\tloop:\n\t\tfor !stopped {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\top.err(ctx, i, next, operator)\n\t\t\t\t} else {\n\t\t\t\t\top.next(ctx, i, next, operator)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\top.end(ctx, next)\n\t\tclose(next)\n\t}()\n}\n\nfunc runParallel(ctx context.Context, next chan Item, observe <-chan Item, operatorFactory func() operator, bypassGather bool, option Option, opts ...Option) {\n\twg := sync.WaitGroup{}\n\t_, pool := option.getPool()\n\twg.Add(pool)\n\n\tvar gather chan Item\n\tif bypassGather {\n\t\tgather = next\n\t} else {\n\t\tgather = make(chan Item, 1)\n\n\t\t// Gather\n\t\tgo func() {\n\t\t\top := operatorFactory()\n\t\t\tstopped := false\n\t\t\toperator := operatorOptions{\n\t\t\t\tstop: func() {\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\tstopped = true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tresetIterable: func(newIterable Iterable) {\n\t\t\t\t\tobserve = newIterable.Observe(opts...)\n\t\t\t\t},\n\t\t\t}\n\t\t\tfor item := range gather {\n\t\t\t\tif stopped {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\top.err(ctx, item, next, operator)\n\t\t\t\t} else {\n\t\t\t\t\top.gatherNext(ctx, item, next, operator)\n\t\t\t\t}\n\t\t\t}\n\t\t\top.end(ctx, next)\n\t\t\tclose(next)\n\t\t}()\n\t}\n\n\t// Scatter\n\tfor i := 0; i < pool; i++ {\n\t\tgo func() {\n\t\t\top := operatorFactory()\n\t\t\tstopped := false\n\t\t\toperator := operatorOptions{\n\t\t\t\tstop: func() {\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\tstopped = true\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tresetIterable: func(newIterable Iterable) {\n\t\t\t\t\tobserve = newIterable.Observe(opts...)\n\t\t\t\t},\n\t\t\t}\n\t\t\tdefer wg.Done()\n\t\t\tfor !stopped {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase item, ok := <-observe:\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tif !bypassGather {\n\t\t\t\t\t\t\tOf(op).SendContext(ctx, gather)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif item.Error() {\n\t\t\t\t\t\top.err(ctx, item, gather, operator)\n\t\t\t\t\t} else {\n\t\t\t\t\t\top.next(ctx, item, gather, operator)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(gather)\n\t}()\n}\n\nfunc runFirstItem(ctx context.Context, f func(interface{}) int, notif chan Item, observe <-chan Item, next chan Item, operatorFactory func() operator, option Option, opts ...Option) {\n\tgo func() {\n\t\top := operatorFactory()\n\t\tstopped := false\n\t\toperator := operatorOptions{\n\t\t\tstop: func() {\n\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\tstopped = true\n\t\t\t\t}\n\t\t\t},\n\t\t\tresetIterable: func(newIterable Iterable) {\n\t\t\t\tobserve = newIterable.Observe(opts...)\n\t\t\t},\n\t\t}\n\n\tloop:\n\t\tfor !stopped {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\top.err(ctx, i, next, operator)\n\t\t\t\t\ti.SendContext(ctx, notif)\n\t\t\t\t} else {\n\t\t\t\t\top.next(ctx, i, next, operator)\n\t\t\t\t\tOf(f(i.V)).SendContext(ctx, notif)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\top.end(ctx, next)\n\t}()\n}\n\nfunc (o *ObservableImpl) serialize(parent context.Context, fromCh chan Item, identifier func(interface{}) int, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\n\tctx := option.buildContext(parent)\n\tminHeap := binaryheap.NewWith(func(a, b interface{}) int {\n\t\treturn a.(int) - b.(int)\n\t})\n\titems := make(map[int]interface{})\n\n\tvar from int\n\tvar counter int64\n\tsrc := o.Observe(opts...)\n\tgo func() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tclose(next)\n\t\t\treturn\n\t\tcase item := <-fromCh:\n\t\t\tif item.Error() {\n\t\t\t\titem.SendContext(ctx, next)\n\t\t\t\tclose(next)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfrom = item.V.(int)\n\t\t\tcounter = int64(from)\n\n\t\t\tgo func() {\n\t\t\t\tdefer close(next)\n\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase item, ok := <-src:\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif item.Error() {\n\t\t\t\t\t\t\tnext <- item\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tid := identifier(item.V)\n\t\t\t\t\t\tminHeap.Push(id)\n\t\t\t\t\t\titems[id] = item.V\n\n\t\t\t\t\t\tfor !minHeap.Empty() {\n\t\t\t\t\t\t\tv, _ := minHeap.Peek()\n\t\t\t\t\t\t\tid := v.(int)\n\t\t\t\t\t\t\tif atomic.LoadInt64(&counter) == int64(id) {\n\t\t\t\t\t\t\t\tif itemValue, contains := items[id]; contains {\n\t\t\t\t\t\t\t\t\tminHeap.Pop()\n\t\t\t\t\t\t\t\t\tdelete(items, id)\n\t\t\t\t\t\t\t\t\tOf(itemValue).SendContext(ctx, next)\n\t\t\t\t\t\t\t\t\tcounter++\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n"
        },
        {
          "name": "observable_operator.go",
          "type": "blob",
          "size": 77.248046875,
          "content": "package rxgo\n\nimport (\n\t\"container/ring\"\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/emirpasic/gods/trees/binaryheap\"\n)\n\n// All determines whether all items emitted by an Observable meet some criteria.\nfunc (o *ObservableImpl) All(predicate Predicate, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &allOperator{\n\t\t\tpredicate: predicate,\n\t\t\tall:       true,\n\t\t}\n\t}, false, false, opts...)\n}\n\ntype allOperator struct {\n\tpredicate Predicate\n\tall       bool\n}\n\nfunc (op *allOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif !op.predicate(item.V) {\n\t\tOf(false).SendContext(ctx, dst)\n\t\top.all = false\n\t\toperatorOptions.stop()\n\t}\n}\n\nfunc (op *allOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *allOperator) end(ctx context.Context, dst chan<- Item) {\n\tif op.all {\n\t\tOf(true).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *allOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif item.V == false {\n\t\tOf(false).SendContext(ctx, dst)\n\t\top.all = false\n\t\toperatorOptions.stop()\n\t}\n}\n\n// AverageFloat32 calculates the average of numbers emitted by an Observable and emits the average float32.\nfunc (o *ObservableImpl) AverageFloat32(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageFloat32Operator{}\n\t}, false, false, opts...)\n}\n\ntype averageFloat32Operator struct {\n\tsum   float32\n\tcount float32\n}\n\nfunc (op *averageFloat32Operator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: float or int, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int:\n\t\top.sum += float32(v)\n\t\top.count++\n\tcase float32:\n\t\top.sum += v\n\t\top.count++\n\tcase float64:\n\t\top.sum += float32(v)\n\t\top.count++\n\t}\n}\n\nfunc (op *averageFloat32Operator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageFloat32Operator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageFloat32Operator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageFloat32Operator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// AverageFloat64 calculates the average of numbers emitted by an Observable and emits the average float64.\nfunc (o *ObservableImpl) AverageFloat64(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageFloat64Operator{}\n\t}, false, false, opts...)\n}\n\ntype averageFloat64Operator struct {\n\tsum   float64\n\tcount float64\n}\n\nfunc (op *averageFloat64Operator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: float or int, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int:\n\t\top.sum += float64(v)\n\t\top.count++\n\tcase float32:\n\t\top.sum += float64(v)\n\t\top.count++\n\tcase float64:\n\t\top.sum += v\n\t\top.count++\n\t}\n}\n\nfunc (op *averageFloat64Operator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageFloat64Operator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageFloat64Operator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageFloat64Operator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// AverageInt calculates the average of numbers emitted by an Observable and emits the average int.\nfunc (o *ObservableImpl) AverageInt(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageIntOperator{}\n\t}, false, false, opts...)\n}\n\ntype averageIntOperator struct {\n\tsum   int\n\tcount int\n}\n\nfunc (op *averageIntOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: int, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int:\n\t\top.sum += v\n\t\top.count++\n\t}\n}\n\nfunc (op *averageIntOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageIntOperator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageIntOperator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageIntOperator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// AverageInt8 calculates the average of numbers emitted by an Observable and emits the≤ average int8.\nfunc (o *ObservableImpl) AverageInt8(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageInt8Operator{}\n\t}, false, false, opts...)\n}\n\ntype averageInt8Operator struct {\n\tsum   int8\n\tcount int8\n}\n\nfunc (op *averageInt8Operator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: int8, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int8:\n\t\top.sum += v\n\t\top.count++\n\t}\n}\n\nfunc (op *averageInt8Operator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageInt8Operator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageInt8Operator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageInt8Operator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// AverageInt16 calculates the average of numbers emitted by an Observable and emits the average int16.\nfunc (o *ObservableImpl) AverageInt16(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageInt16Operator{}\n\t}, false, false, opts...)\n}\n\ntype averageInt16Operator struct {\n\tsum   int16\n\tcount int16\n}\n\nfunc (op *averageInt16Operator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: int16, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int16:\n\t\top.sum += v\n\t\top.count++\n\t}\n}\n\nfunc (op *averageInt16Operator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageInt16Operator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageInt16Operator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageInt16Operator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// AverageInt32 calculates the average of numbers emitted by an Observable and emits the average int32.\nfunc (o *ObservableImpl) AverageInt32(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageInt32Operator{}\n\t}, false, false, opts...)\n}\n\ntype averageInt32Operator struct {\n\tsum   int32\n\tcount int32\n}\n\nfunc (op *averageInt32Operator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: int32, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int32:\n\t\top.sum += v\n\t\top.count++\n\t}\n}\n\nfunc (op *averageInt32Operator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageInt32Operator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageInt32Operator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageInt32Operator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// AverageInt64 calculates the average of numbers emitted by an Observable and emits this average int64.\nfunc (o *ObservableImpl) AverageInt64(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &averageInt64Operator{}\n\t}, false, false, opts...)\n}\n\ntype averageInt64Operator struct {\n\tsum   int64\n\tcount int64\n}\n\nfunc (op *averageInt64Operator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tswitch v := item.V.(type) {\n\tdefault:\n\t\tError(IllegalInputError{error: fmt.Sprintf(\"expected type: int64, got: %t\", item)}).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\tcase int64:\n\t\top.sum += v\n\t\top.count++\n\t}\n}\n\nfunc (op *averageInt64Operator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *averageInt64Operator) end(ctx context.Context, dst chan<- Item) {\n\tif op.count == 0 {\n\t\tOf(0).SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.sum/op.count).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *averageInt64Operator) gatherNext(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\tv := item.V.(*averageInt64Operator)\n\top.sum += v.sum\n\top.count += v.count\n}\n\n// BackOffRetry implements a backoff retry if a source Observable sends an error, resubscribe to it in the hopes that it will complete without error.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) BackOffRetry(backOffCfg backoff.BackOff, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\n\tf := func() error {\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tclose(next)\n\t\t\t\treturn nil\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\treturn i.E\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, next)\n\t\t\t}\n\t\t}\n\t}\n\tgo func() {\n\t\tif err := backoff.Retry(f, backOffCfg); err != nil {\n\t\t\tError(err).SendContext(ctx, next)\n\t\t\tclose(next)\n\t\t\treturn\n\t\t}\n\t\tclose(next)\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// BufferWithCount returns an Observable that emits buffers of items it collects\n// from the source Observable.\n// The resulting Observable emits buffers every skip items, each containing a slice of count items.\n// When the source Observable completes or encounters an error,\n// the resulting Observable emits the current buffer and propagates\n// the notification from the source Observable.\nfunc (o *ObservableImpl) BufferWithCount(count int, opts ...Option) Observable {\n\tif count <= 0 {\n\t\treturn Thrown(IllegalInputError{error: \"count must be positive\"})\n\t}\n\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &bufferWithCountOperator{\n\t\t\tcount:  count,\n\t\t\tbuffer: make([]interface{}, count),\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype bufferWithCountOperator struct {\n\tcount  int\n\tiCount int\n\tbuffer []interface{}\n}\n\nfunc (op *bufferWithCountOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\top.buffer[op.iCount] = item.V\n\top.iCount++\n\tif op.iCount == op.count {\n\t\tOf(op.buffer).SendContext(ctx, dst)\n\t\top.iCount = 0\n\t\top.buffer = make([]interface{}, op.count)\n\t}\n}\n\nfunc (op *bufferWithCountOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *bufferWithCountOperator) end(ctx context.Context, dst chan<- Item) {\n\tif op.iCount != 0 {\n\t\tOf(op.buffer[:op.iCount]).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *bufferWithCountOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// BufferWithTime returns an Observable that emits buffers of items it collects from the source\n// Observable. The resulting Observable starts a new buffer periodically, as determined by the\n// timeshift argument. It emits each buffer after a fixed timespan, specified by the timespan argument.\n// When the source Observable completes or encounters an error, the resulting Observable emits\n// the current buffer and propagates the notification from the source Observable.\nfunc (o *ObservableImpl) BufferWithTime(timespan Duration, opts ...Option) Observable {\n\tif timespan == nil {\n\t\treturn Thrown(IllegalInputError{error: \"timespan must no be nil\"})\n\t}\n\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tobserve := o.Observe(opts...)\n\t\tbuffer := make([]interface{}, 0)\n\t\tstop := make(chan struct{})\n\t\tmutex := sync.Mutex{}\n\n\t\tcheckBuffer := func() {\n\t\t\tmutex.Lock()\n\t\t\tif len(buffer) != 0 {\n\t\t\t\tif !Of(buffer).SendContext(ctx, next) {\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbuffer = make([]interface{}, 0)\n\t\t\t}\n\t\t\tmutex.Unlock()\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer close(next)\n\t\t\tduration := timespan.duration()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-stop:\n\t\t\t\t\tcheckBuffer()\n\t\t\t\t\treturn\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(duration):\n\t\t\t\t\tcheckBuffer()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tclose(stop)\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tclose(stop)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\titem.SendContext(ctx, next)\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\tclose(stop)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tbuffer = append(buffer, item.V)\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// BufferWithTimeOrCount returns an Observable that emits buffers of items it collects from the source\n// Observable either from a given count or at a given time interval.\nfunc (o *ObservableImpl) BufferWithTimeOrCount(timespan Duration, count int, opts ...Option) Observable {\n\tif timespan == nil {\n\t\treturn Thrown(IllegalInputError{error: \"timespan must no be nil\"})\n\t}\n\tif count <= 0 {\n\t\treturn Thrown(IllegalInputError{error: \"count must be positive\"})\n\t}\n\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tobserve := o.Observe(opts...)\n\t\tbuffer := make([]interface{}, 0)\n\t\tstop := make(chan struct{})\n\t\tsend := make(chan struct{})\n\t\tmutex := sync.Mutex{}\n\n\t\tcheckBuffer := func() {\n\t\t\tmutex.Lock()\n\t\t\tif len(buffer) != 0 {\n\t\t\t\tif !Of(buffer).SendContext(ctx, next) {\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbuffer = make([]interface{}, 0)\n\t\t\t}\n\t\t\tmutex.Unlock()\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer close(next)\n\t\t\tduration := timespan.duration()\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-send:\n\t\t\t\t\tcheckBuffer()\n\t\t\t\tcase <-stop:\n\t\t\t\t\tcheckBuffer()\n\t\t\t\t\treturn\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(duration):\n\t\t\t\t\tcheckBuffer()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tclose(stop)\n\t\t\t\t\tclose(send)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\titem.SendContext(ctx, next)\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\tclose(stop)\n\t\t\t\t\t\tclose(send)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tbuffer = append(buffer, item.V)\n\t\t\t\t\tif len(buffer) == count {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t\tsend <- struct{}{}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// Connect instructs a connectable Observable to begin emitting items to its subscribers.\nfunc (o *ObservableImpl) Connect(ctx context.Context) (context.Context, Disposable) {\n\tctx, cancel := context.WithCancel(ctx)\n\to.Observe(WithContext(ctx), connect())\n\treturn ctx, Disposable(cancel)\n}\n\n// Contains determines whether an Observable emits a particular item or not.\nfunc (o *ObservableImpl) Contains(equal Predicate, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &containsOperator{\n\t\t\tequal:    equal,\n\t\t\tcontains: false,\n\t\t}\n\t}, false, false, opts...)\n}\n\ntype containsOperator struct {\n\tequal    Predicate\n\tcontains bool\n}\n\nfunc (op *containsOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif op.equal(item.V) {\n\t\tOf(true).SendContext(ctx, dst)\n\t\top.contains = true\n\t\toperatorOptions.stop()\n\t}\n}\n\nfunc (op *containsOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *containsOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.contains {\n\t\tOf(false).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *containsOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif item.V == true {\n\t\tOf(true).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\top.contains = true\n\t}\n}\n\n// Count counts the number of items emitted by the source Observable and emit only this value.\nfunc (o *ObservableImpl) Count(opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &countOperator{}\n\t}, true, false, opts...)\n}\n\ntype countOperator struct {\n\tcount int64\n}\n\nfunc (op *countOperator) next(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n\top.count++\n}\n\nfunc (op *countOperator) err(_ context.Context, _ Item, _ chan<- Item, operatorOptions operatorOptions) {\n\toperatorOptions.stop()\n}\n\nfunc (op *countOperator) end(ctx context.Context, dst chan<- Item) {\n\tOf(op.count).SendContext(ctx, dst)\n}\n\nfunc (op *countOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Debounce only emits an item from an Observable if a particular timespan has passed without it emitting another item.\nfunc (o *ObservableImpl) Debounce(timespan Duration, opts ...Option) Observable {\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tdefer close(next)\n\t\tobserve := o.Observe(opts...)\n\t\tvar latest interface{}\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\tif !item.SendContext(ctx, next) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlatest = item.V\n\t\t\t\t}\n\t\t\tcase <-time.After(timespan.duration()):\n\t\t\t\tif latest != nil {\n\t\t\t\t\tif !Of(latest).SendContext(ctx, next) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tlatest = nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// DefaultIfEmpty returns an Observable that emits the items emitted by the source\n// Observable or a specified default item if the source Observable is empty.\nfunc (o *ObservableImpl) DefaultIfEmpty(defaultValue interface{}, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &defaultIfEmptyOperator{\n\t\t\tdefaultValue: defaultValue,\n\t\t\tempty:        true,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype defaultIfEmptyOperator struct {\n\tdefaultValue interface{}\n\tempty        bool\n}\n\nfunc (op *defaultIfEmptyOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\top.empty = false\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *defaultIfEmptyOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *defaultIfEmptyOperator) end(ctx context.Context, dst chan<- Item) {\n\tif op.empty {\n\t\tOf(op.defaultValue).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *defaultIfEmptyOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Distinct suppresses duplicate items in the original Observable and returns\n// a new Observable.\nfunc (o *ObservableImpl) Distinct(apply Func, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &distinctOperator{\n\t\t\tapply:  apply,\n\t\t\tkeyset: make(map[interface{}]interface{}),\n\t\t}\n\t}, false, false, opts...)\n}\n\ntype distinctOperator struct {\n\tapply  Func\n\tkeyset map[interface{}]interface{}\n}\n\nfunc (op *distinctOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tkey, err := op.apply(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\t_, ok := op.keyset[key]\n\tif !ok {\n\t\titem.SendContext(ctx, dst)\n\t}\n\top.keyset[key] = nil\n}\n\nfunc (op *distinctOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *distinctOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *distinctOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tswitch item.V.(type) {\n\tcase *distinctOperator:\n\t\treturn\n\t}\n\n\tif _, contains := op.keyset[item.V]; !contains {\n\t\tOf(item.V).SendContext(ctx, dst)\n\t\top.keyset[item.V] = nil\n\t}\n}\n\n// DistinctUntilChanged suppresses consecutive duplicate items in the original Observable.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) DistinctUntilChanged(apply Func, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &distinctUntilChangedOperator{\n\t\t\tapply: apply,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype distinctUntilChangedOperator struct {\n\tapply   Func\n\tcurrent interface{}\n}\n\nfunc (op *distinctUntilChangedOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tkey, err := op.apply(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\tif op.current != key {\n\t\titem.SendContext(ctx, dst)\n\t\top.current = key\n\t}\n}\n\nfunc (op *distinctUntilChangedOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *distinctUntilChangedOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *distinctUntilChangedOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// DoOnCompleted registers a callback action that will be called once the Observable terminates.\nfunc (o *ObservableImpl) DoOnCompleted(completedFunc CompletedFunc, opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\thandler := func(ctx context.Context, src <-chan Item) {\n\t\tdefer close(dispose)\n\t\tdefer completedFunc()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-src:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\tgo handler(ctx, o.Observe(opts...))\n\treturn dispose\n}\n\n// DoOnError registers a callback action that will be called if the Observable terminates abnormally.\nfunc (o *ObservableImpl) DoOnError(errFunc ErrFunc, opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\thandler := func(ctx context.Context, src <-chan Item) {\n\t\tdefer close(dispose)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-src:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\terrFunc(i.E)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\tgo handler(ctx, o.Observe(opts...))\n\treturn dispose\n}\n\n// DoOnNext registers a callback action that will be called on each item emitted by the Observable.\nfunc (o *ObservableImpl) DoOnNext(nextFunc NextFunc, opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\thandler := func(ctx context.Context, src <-chan Item) {\n\t\tdefer close(dispose)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-src:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tnextFunc(i.V)\n\t\t\t}\n\t\t}\n\t}\n\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\tgo handler(ctx, o.Observe(opts...))\n\treturn dispose\n}\n\n// ElementAt emits only item n emitted by an Observable.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) ElementAt(index uint, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &elementAtOperator{\n\t\t\tindex: index,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype elementAtOperator struct {\n\tindex     uint\n\ttakeCount int\n\tsent      bool\n}\n\nfunc (op *elementAtOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif op.takeCount == int(op.index) {\n\t\titem.SendContext(ctx, dst)\n\t\top.sent = true\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\top.takeCount++\n}\n\nfunc (op *elementAtOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *elementAtOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.sent {\n\t\tError(&IllegalInputError{}).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *elementAtOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Error returns the eventual Observable error.\n// This method is blocking.\nfunc (o *ObservableImpl) Error(opts ...Option) error {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\tobserve := o.iterable.Observe(opts...)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase item, ok := <-observe:\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif item.Error() {\n\t\t\t\treturn item.E\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Errors returns an eventual list of Observable errors.\n// This method is blocking\nfunc (o *ObservableImpl) Errors(opts ...Option) []error {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\tobserve := o.iterable.Observe(opts...)\n\terrs := make([]error, 0)\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn []error{ctx.Err()}\n\t\tcase item, ok := <-observe:\n\t\t\tif !ok {\n\t\t\t\treturn errs\n\t\t\t}\n\t\t\tif item.Error() {\n\t\t\t\terrs = append(errs, item.E)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Filter emits only those items from an Observable that pass a predicate test.\nfunc (o *ObservableImpl) Filter(apply Predicate, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &filterOperator{apply: apply}\n\t}, false, true, opts...)\n}\n\ntype filterOperator struct {\n\tapply Predicate\n}\n\nfunc (op *filterOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tif op.apply(item.V) {\n\t\titem.SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *filterOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *filterOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *filterOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Find emits the first item passing a predicate then complete.\nfunc (o *ObservableImpl) Find(find Predicate, opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &findOperator{\n\t\t\tfind: find,\n\t\t}\n\t}, true, true, opts...)\n}\n\ntype findOperator struct {\n\tfind Predicate\n}\n\nfunc (op *findOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif op.find(item.V) {\n\t\titem.SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t}\n}\n\nfunc (op *findOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *findOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *findOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// First returns new Observable which emit only first item.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) First(opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &firstOperator{}\n\t}, true, false, opts...)\n}\n\ntype firstOperator struct{}\n\nfunc (op *firstOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\titem.SendContext(ctx, dst)\n\toperatorOptions.stop()\n}\n\nfunc (op *firstOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *firstOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *firstOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// FirstOrDefault returns new Observable which emit only first item.\n// If the observable fails to emit any items, it emits a default value.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) FirstOrDefault(defaultValue interface{}, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &firstOrDefaultOperator{\n\t\t\tdefaultValue: defaultValue,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype firstOrDefaultOperator struct {\n\tdefaultValue interface{}\n\tsent         bool\n}\n\nfunc (op *firstOrDefaultOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\titem.SendContext(ctx, dst)\n\top.sent = true\n\toperatorOptions.stop()\n}\n\nfunc (op *firstOrDefaultOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *firstOrDefaultOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.sent {\n\t\tOf(op.defaultValue).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *firstOrDefaultOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// FlatMap transforms the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable.\nfunc (o *ObservableImpl) FlatMap(apply ItemToObservable, opts ...Option) Observable {\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tdefer close(next)\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tobserve2 := apply(item).Observe(opts...)\n\t\t\tloop2:\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase item, ok := <-observe2:\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\tbreak loop2\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif item.Error() {\n\t\t\t\t\t\t\titem.SendContext(ctx, next)\n\t\t\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif !item.SendContext(ctx, next) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// ForEach subscribes to the Observable and receives notifications for each element.\nfunc (o *ObservableImpl) ForEach(nextFunc NextFunc, errFunc ErrFunc, completedFunc CompletedFunc, opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\thandler := func(ctx context.Context, src <-chan Item) {\n\t\tdefer close(dispose)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tcompletedFunc()\n\t\t\t\treturn\n\t\t\tcase i, ok := <-src:\n\t\t\t\tif !ok {\n\t\t\t\t\tcompletedFunc()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\terrFunc(i.E)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tnextFunc(i.V)\n\t\t\t}\n\t\t}\n\t}\n\n\tctx := o.parent\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\tgo handler(ctx, o.Observe(opts...))\n\treturn dispose\n}\n\n// IgnoreElements ignores all items emitted by the source ObservableSource except for the errors.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) IgnoreElements(opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &ignoreElementsOperator{}\n\t}, true, false, opts...)\n}\n\ntype ignoreElementsOperator struct{}\n\nfunc (op *ignoreElementsOperator) next(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\nfunc (op *ignoreElementsOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *ignoreElementsOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *ignoreElementsOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Returns absolute value for int64\nfunc abs(n int64) int64 {\n\ty := n >> 63\n\treturn (n ^ y) - y\n}\n\n// Join combines items emitted by two Observables whenever an item from one Observable is emitted during\n// a time window defined according to an item emitted by the other Observable.\n// The time is extracted using a timeExtractor function.\nfunc (o *ObservableImpl) Join(joiner Func2, right Observable, timeExtractor func(interface{}) time.Time, window Duration, opts ...Option) Observable {\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tdefer close(next)\n\t\twindowDuration := int64(window.duration())\n\t\trBuf := make([]Item, 0)\n\n\t\tlObserve := o.Observe()\n\t\trObserve := right.Observe()\n\tlLoop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase lItem, ok := <-lObserve:\n\t\t\t\tif lItem.V == nil && !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lItem.Error() {\n\t\t\t\t\tlItem.SendContext(ctx, next)\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tlTime := timeExtractor(lItem.V).UnixNano()\n\t\t\t\tcutPoint := 0\n\t\t\t\tfor i, rItem := range rBuf {\n\t\t\t\t\trTime := timeExtractor(rItem.V).UnixNano()\n\t\t\t\t\tif abs(lTime-rTime) <= windowDuration {\n\t\t\t\t\t\ti, err := joiner(ctx, lItem.V, rItem.V)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tError(err).SendContext(ctx, next)\n\t\t\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOf(i).SendContext(ctx, next)\n\t\t\t\t\t}\n\t\t\t\t\tif lTime > rTime+windowDuration {\n\t\t\t\t\t\tcutPoint = i + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trBuf = rBuf[cutPoint:]\n\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase rItem, ok := <-rObserve:\n\t\t\t\t\t\tif rItem.V == nil && !ok {\n\t\t\t\t\t\t\tcontinue lLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif rItem.Error() {\n\t\t\t\t\t\t\trItem.SendContext(ctx, next)\n\t\t\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trBuf = append(rBuf, rItem)\n\t\t\t\t\t\trTime := timeExtractor(rItem.V).UnixNano()\n\t\t\t\t\t\tif abs(lTime-rTime) <= windowDuration {\n\t\t\t\t\t\t\ti, err := joiner(ctx, lItem.V, rItem.V)\n\t\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\t\tError(err).SendContext(ctx, next)\n\t\t\t\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tOf(i).SendContext(ctx, next)\n\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue lLoop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// GroupBy divides an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key.\nfunc (o *ObservableImpl) GroupBy(length int, distribution func(Item) int, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\n\ts := make([]Item, length)\n\tchs := make([]chan Item, length)\n\tfor i := 0; i < length; i++ {\n\t\tch := option.buildChannel()\n\t\tchs[i] = ch\n\t\ts[i] = Of(&ObservableImpl{\n\t\t\titerable: newChannelIterable(ch),\n\t\t})\n\t}\n\n\tgo func() {\n\t\tobserve := o.Observe(opts...)\n\t\tdefer func() {\n\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\tclose(chs[i])\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tidx := distribution(item)\n\t\t\t\tif idx >= length {\n\t\t\t\t\terr := Error(IndexOutOfBoundError{error: fmt.Sprintf(\"index %d, length %d\", idx, length)})\n\t\t\t\t\tfor i := 0; i < length; i++ {\n\t\t\t\t\t\terr.SendContext(ctx, chs[i])\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\titem.SendContext(ctx, chs[idx])\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newSliceIterable(s, opts...),\n\t}\n}\n\n// GroupedObservable is the observable type emitted by the GroupByDynamic operator.\ntype GroupedObservable struct {\n\tObservable\n\t// Key is the distribution key\n\tKey string\n}\n\n// GroupByDynamic divides an Observable into a dynamic set of Observables that each emit GroupedObservable from the original Observable, organized by key.\nfunc (o *ObservableImpl) GroupByDynamic(distribution func(Item) string, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\tchs := make(map[string]chan Item)\n\n\tgo func() {\n\t\tobserve := o.Observe(opts...)\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tidx := distribution(i)\n\t\t\t\tch, contains := chs[idx]\n\t\t\t\tif !contains {\n\t\t\t\t\tch = option.buildChannel()\n\t\t\t\t\tchs[idx] = ch\n\t\t\t\t\tOf(GroupedObservable{\n\t\t\t\t\t\tObservable: &ObservableImpl{\n\t\t\t\t\t\t\titerable: newChannelIterable(ch),\n\t\t\t\t\t\t},\n\t\t\t\t\t\tKey: idx,\n\t\t\t\t\t}).SendContext(ctx, next)\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, ch)\n\t\t\t}\n\t\t}\n\t\tfor _, ch := range chs {\n\t\t\tclose(ch)\n\t\t}\n\t\tclose(next)\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Last returns a new Observable which emit only last item.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) Last(opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &lastOperator{\n\t\t\tempty: true,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype lastOperator struct {\n\tlast  Item\n\tempty bool\n}\n\nfunc (op *lastOperator) next(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\top.last = item\n\top.empty = false\n}\n\nfunc (op *lastOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *lastOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.empty {\n\t\top.last.SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *lastOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// LastOrDefault returns a new Observable which emit only last item.\n// If the observable fails to emit any items, it emits a default value.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) LastOrDefault(defaultValue interface{}, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &lastOrDefaultOperator{\n\t\t\tdefaultValue: defaultValue,\n\t\t\tempty:        true,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype lastOrDefaultOperator struct {\n\tdefaultValue interface{}\n\tlast         Item\n\tempty        bool\n}\n\nfunc (op *lastOrDefaultOperator) next(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\top.last = item\n\top.empty = false\n}\n\nfunc (op *lastOrDefaultOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *lastOrDefaultOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.empty {\n\t\top.last.SendContext(ctx, dst)\n\t} else {\n\t\tOf(op.defaultValue).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *lastOrDefaultOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Map transforms the items emitted by an Observable by applying a function to each item.\nfunc (o *ObservableImpl) Map(apply Func, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &mapOperator{apply: apply}\n\t}, false, true, opts...)\n}\n\ntype mapOperator struct {\n\tapply Func\n}\n\nfunc (op *mapOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tres, err := op.apply(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\tOf(res).SendContext(ctx, dst)\n}\n\nfunc (op *mapOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *mapOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *mapOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tswitch item.V.(type) {\n\tcase *mapOperator:\n\t\treturn\n\t}\n\titem.SendContext(ctx, dst)\n}\n\n// Marshal transforms the items emitted by an Observable by applying a marshalling to each item.\nfunc (o *ObservableImpl) Marshal(marshaller Marshaller, opts ...Option) Observable {\n\treturn o.Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn marshaller(i)\n\t}, opts...)\n}\n\n// Max determines and emits the maximum-valued item emitted by an Observable according to a comparator.\nfunc (o *ObservableImpl) Max(comparator Comparator, opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &maxOperator{\n\t\t\tcomparator: comparator,\n\t\t\tempty:      true,\n\t\t}\n\t}, false, false, opts...)\n}\n\ntype maxOperator struct {\n\tcomparator Comparator\n\tempty      bool\n\tmax        interface{}\n}\n\nfunc (op *maxOperator) next(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\top.empty = false\n\n\tif op.max == nil {\n\t\top.max = item.V\n\t} else {\n\t\tif op.comparator(op.max, item.V) < 0 {\n\t\t\top.max = item.V\n\t\t}\n\t}\n}\n\nfunc (op *maxOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *maxOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.empty {\n\t\tOf(op.max).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *maxOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\top.next(ctx, Of(item.V.(*maxOperator).max), dst, operatorOptions)\n}\n\n// Min determines and emits the minimum-valued item emitted by an Observable according to a comparator.\nfunc (o *ObservableImpl) Min(comparator Comparator, opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &minOperator{\n\t\t\tcomparator: comparator,\n\t\t\tempty:      true,\n\t\t}\n\t}, false, false, opts...)\n}\n\ntype minOperator struct {\n\tcomparator Comparator\n\tempty      bool\n\tmax        interface{}\n}\n\nfunc (op *minOperator) next(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\top.empty = false\n\n\tif op.max == nil {\n\t\top.max = item.V\n\t} else {\n\t\tif op.comparator(op.max, item.V) > 0 {\n\t\t\top.max = item.V\n\t\t}\n\t}\n}\n\nfunc (op *minOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *minOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.empty {\n\t\tOf(op.max).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *minOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\top.next(ctx, Of(item.V.(*minOperator).max), dst, operatorOptions)\n}\n\n// Observe observes an Observable by returning its channel.\nfunc (o *ObservableImpl) Observe(opts ...Option) <-chan Item {\n\treturn o.iterable.Observe(opts...)\n}\n\n// OnErrorResumeNext instructs an Observable to pass control to another Observable rather than invoking\n// onError if it encounters an error.\nfunc (o *ObservableImpl) OnErrorResumeNext(resumeSequence ErrorToObservable, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &onErrorResumeNextOperator{resumeSequence: resumeSequence}\n\t}, true, false, opts...)\n}\n\ntype onErrorResumeNextOperator struct {\n\tresumeSequence ErrorToObservable\n}\n\nfunc (op *onErrorResumeNextOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *onErrorResumeNextOperator) err(_ context.Context, item Item, _ chan<- Item, operatorOptions operatorOptions) {\n\toperatorOptions.resetIterable(op.resumeSequence(item.E))\n}\n\nfunc (op *onErrorResumeNextOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *onErrorResumeNextOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// OnErrorReturn instructs an Observable to emit an item (returned by a specified function)\n// rather than invoking onError if it encounters an error.\nfunc (o *ObservableImpl) OnErrorReturn(resumeFunc ErrorFunc, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &onErrorReturnOperator{resumeFunc: resumeFunc}\n\t}, true, false, opts...)\n}\n\ntype onErrorReturnOperator struct {\n\tresumeFunc ErrorFunc\n}\n\nfunc (op *onErrorReturnOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *onErrorReturnOperator) err(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tOf(op.resumeFunc(item.E)).SendContext(ctx, dst)\n}\n\nfunc (op *onErrorReturnOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *onErrorReturnOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// OnErrorReturnItem instructs on Observable to emit an item if it encounters an error.\nfunc (o *ObservableImpl) OnErrorReturnItem(resume interface{}, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &onErrorReturnItemOperator{resume: resume}\n\t}, true, false, opts...)\n}\n\ntype onErrorReturnItemOperator struct {\n\tresume interface{}\n}\n\nfunc (op *onErrorReturnItemOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *onErrorReturnItemOperator) err(ctx context.Context, _ Item, dst chan<- Item, _ operatorOptions) {\n\tOf(op.resume).SendContext(ctx, dst)\n}\n\nfunc (op *onErrorReturnItemOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *onErrorReturnItemOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Reduce applies a function to each item emitted by an Observable, sequentially, and emit the final value.\nfunc (o *ObservableImpl) Reduce(apply Func2, opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &reduceOperator{\n\t\t\tapply: apply,\n\t\t\tempty: true,\n\t\t}\n\t}, false, false, opts...)\n}\n\ntype reduceOperator struct {\n\tapply Func2\n\tacc   interface{}\n\tempty bool\n}\n\nfunc (op *reduceOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\top.empty = false\n\tv, err := op.apply(ctx, op.acc, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\top.empty = true\n\t\treturn\n\t}\n\top.acc = v\n}\n\nfunc (op *reduceOperator) err(_ context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdst <- item\n\toperatorOptions.stop()\n\top.empty = true\n}\n\nfunc (op *reduceOperator) end(ctx context.Context, dst chan<- Item) {\n\tif !op.empty {\n\t\tOf(op.acc).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *reduceOperator) gatherNext(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\top.next(ctx, Of(item.V.(*reduceOperator).acc), dst, operatorOptions)\n}\n\n// Repeat returns an Observable that repeats the sequence of items emitted by the source Observable\n// at most count times, at a particular frequency.\n// Cannot run in parallel.\nfunc (o *ObservableImpl) Repeat(count int64, frequency Duration, opts ...Option) Observable {\n\tif count != Infinite {\n\t\tif count < 0 {\n\t\t\treturn Thrown(IllegalInputError{error: \"count must be positive\"})\n\t\t}\n\t}\n\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &repeatOperator{\n\t\t\tcount:     count,\n\t\t\tfrequency: frequency,\n\t\t\tseq:       make([]Item, 0),\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype repeatOperator struct {\n\tcount     int64\n\tfrequency Duration\n\tseq       []Item\n}\n\nfunc (op *repeatOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\titem.SendContext(ctx, dst)\n\top.seq = append(op.seq, item)\n}\n\nfunc (op *repeatOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *repeatOperator) end(ctx context.Context, dst chan<- Item) {\n\tfor {\n\t\tselect {\n\t\tdefault:\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t\tif op.count != Infinite {\n\t\t\tif op.count == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif op.frequency != nil {\n\t\t\ttime.Sleep(op.frequency.duration())\n\t\t}\n\t\tfor _, v := range op.seq {\n\t\t\tv.SendContext(ctx, dst)\n\t\t}\n\t\top.count = op.count - 1\n\t}\n}\n\nfunc (op *repeatOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Retry retries if a source Observable sends an error, resubscribe to it in the hopes that it will complete without error.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) Retry(count int, shouldRetry func(error) bool, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\n\tgo func() {\n\t\tobserve := o.Observe(opts...)\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\tcount--\n\t\t\t\t\tif count < 0 || !shouldRetry(i.E) {\n\t\t\t\t\t\ti.SendContext(ctx, next)\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\t}\n\t\t\t\t\tobserve = o.Observe(opts...)\n\t\t\t\t} else {\n\t\t\t\t\ti.SendContext(ctx, next)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclose(next)\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Run creates an Observer without consuming the emitted items.\nfunc (o *ObservableImpl) Run(opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\n\tgo func() {\n\t\tdefer close(dispose)\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase _, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn dispose\n}\n\n// Sample returns an Observable that emits the most recent items emitted by the source\n// Iterable whenever the input Iterable emits an item.\nfunc (o *ObservableImpl) Sample(iterable Iterable, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\titCh := make(chan Item)\n\tobsCh := make(chan Item)\n\n\tgo func() {\n\t\tdefer close(obsCh)\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, obsCh)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer close(itCh)\n\t\tobserve := iterable.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, itCh)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tvar lastEmittedItem Item\n\t\tisItemWaitingToBeEmitted := false\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase _, ok := <-itCh:\n\t\t\t\tif ok {\n\t\t\t\t\tif isItemWaitingToBeEmitted {\n\t\t\t\t\t\tnext <- lastEmittedItem\n\t\t\t\t\t\tisItemWaitingToBeEmitted = false\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase item, ok := <-obsCh:\n\t\t\t\tif ok {\n\t\t\t\t\tlastEmittedItem = item\n\t\t\t\t\tisItemWaitingToBeEmitted = true\n\t\t\t\t} else {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Scan apply a Func2 to each item emitted by an Observable, sequentially, and emit each successive value.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) Scan(apply Func2, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &scanOperator{\n\t\t\tapply: apply,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype scanOperator struct {\n\tapply   Func2\n\tcurrent interface{}\n}\n\nfunc (op *scanOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tv, err := op.apply(ctx, op.current, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\tOf(v).SendContext(ctx, dst)\n\top.current = v\n}\n\nfunc (op *scanOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *scanOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *scanOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Compares first items of two sequences and returns true if they are equal and false if\n// they are not. Besides, it returns two new sequences - input sequences without compared items.\nfunc popAndCompareFirstItems(\n\tinputSequence1 []interface{},\n\tinputSequence2 []interface{}) (bool, []interface{}, []interface{}) {\n\tif len(inputSequence1) > 0 && len(inputSequence2) > 0 {\n\t\ts1, sequence1 := inputSequence1[0], inputSequence1[1:]\n\t\ts2, sequence2 := inputSequence2[0], inputSequence2[1:]\n\t\treturn s1 == s2, sequence1, sequence2\n\t}\n\treturn true, inputSequence1, inputSequence2\n}\n\n// Send sends the items to a given channel.\nfunc (o *ObservableImpl) Send(output chan<- Item, opts ...Option) {\n\tgo func() {\n\t\toption := parseOptions(opts...)\n\t\tctx := option.buildContext(o.parent)\n\t\tobserve := o.Observe(opts...)\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\toutput <- i\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, output)\n\t\t\t}\n\t\t}\n\t\tclose(output)\n\t}()\n}\n\n// SequenceEqual emits true if an Observable and the input Observable emit the same items,\n// in the same order, with the same termination state. Otherwise, it emits false.\nfunc (o *ObservableImpl) SequenceEqual(iterable Iterable, opts ...Option) Single {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\titCh := make(chan Item)\n\tobsCh := make(chan Item)\n\n\tgo func() {\n\t\tdefer close(obsCh)\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, obsCh)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer close(itCh)\n\t\tobserve := iterable.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, itCh)\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tvar mainSequence []interface{}\n\t\tvar obsSequence []interface{}\n\t\tareCorrect := true\n\t\tisMainChannelClosed := false\n\t\tisObsChannelClosed := false\n\n\tmainLoop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase item, ok := <-itCh:\n\t\t\t\tif ok {\n\t\t\t\t\tmainSequence = append(mainSequence, item)\n\t\t\t\t\tareCorrect, mainSequence, obsSequence = popAndCompareFirstItems(mainSequence, obsSequence)\n\t\t\t\t} else {\n\t\t\t\t\tisMainChannelClosed = true\n\t\t\t\t}\n\t\t\tcase item, ok := <-obsCh:\n\t\t\t\tif ok {\n\t\t\t\t\tobsSequence = append(obsSequence, item)\n\t\t\t\t\tareCorrect, mainSequence, obsSequence = popAndCompareFirstItems(mainSequence, obsSequence)\n\t\t\t\t} else {\n\t\t\t\t\tisObsChannelClosed = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !areCorrect || (isMainChannelClosed && isObsChannelClosed) {\n\t\t\t\tbreak mainLoop\n\t\t\t}\n\t\t}\n\n\t\tOf(areCorrect && len(mainSequence) == 0 && len(obsSequence) == 0).SendContext(ctx, next)\n\t\tclose(next)\n\t}()\n\n\treturn &SingleImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Serialize forces an Observable to make serialized calls and to be well-behaved.\nfunc (o *ObservableImpl) Serialize(from int, identifier func(interface{}) int, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\n\tctx := option.buildContext(o.parent)\n\tminHeap := binaryheap.NewWith(func(a, b interface{}) int {\n\t\treturn a.(int) - b.(int)\n\t})\n\tcounter := int64(from)\n\titems := make(map[int]interface{})\n\n\tgo func() {\n\t\tsrc := o.Observe(opts...)\n\t\tdefer close(next)\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-src:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\tnext <- item\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tid := identifier(item.V)\n\t\t\t\tminHeap.Push(id)\n\t\t\t\titems[id] = item.V\n\n\t\t\t\tfor !minHeap.Empty() {\n\t\t\t\t\tv, _ := minHeap.Peek()\n\t\t\t\t\tid := v.(int)\n\t\t\t\t\tif atomic.LoadInt64(&counter) == int64(id) {\n\t\t\t\t\t\tif itemValue, contains := items[id]; contains {\n\t\t\t\t\t\t\tminHeap.Pop()\n\t\t\t\t\t\t\tdelete(items, id)\n\t\t\t\t\t\t\tOf(itemValue).SendContext(ctx, next)\n\t\t\t\t\t\t\tcounter++\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// Skip suppresses the first n items in the original Observable and\n// returns a new Observable with the rest items.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) Skip(nth uint, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &skipOperator{\n\t\t\tnth: nth,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype skipOperator struct {\n\tnth       uint\n\tskipCount int\n}\n\nfunc (op *skipOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tif op.skipCount < int(op.nth) {\n\t\top.skipCount++\n\t\treturn\n\t}\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *skipOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *skipOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *skipOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// SkipLast suppresses the last n items in the original Observable and\n// returns a new Observable with the rest items.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) SkipLast(nth uint, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &skipLastOperator{\n\t\t\tnth: nth,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype skipLastOperator struct {\n\tnth       uint\n\tskipCount int\n}\n\nfunc (op *skipLastOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif op.skipCount >= int(op.nth) {\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\top.skipCount++\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *skipLastOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *skipLastOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *skipLastOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// SkipWhile discard items emitted by an Observable until a specified condition becomes false.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) SkipWhile(apply Predicate, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &skipWhileOperator{\n\t\t\tapply: apply,\n\t\t\tskip:  true,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype skipWhileOperator struct {\n\tapply Predicate\n\tskip  bool\n}\n\nfunc (op *skipWhileOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tif !op.skip {\n\t\titem.SendContext(ctx, dst)\n\t} else {\n\t\tif !op.apply(item.V) {\n\t\t\top.skip = false\n\t\t\titem.SendContext(ctx, dst)\n\t\t}\n\t}\n}\n\nfunc (op *skipWhileOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *skipWhileOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *skipWhileOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// StartWith emits a specified Iterable before beginning to emit the items from the source Observable.\nfunc (o *ObservableImpl) StartWith(iterable Iterable, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tobserve := iterable.Observe(opts...)\n\tloop1:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop1\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop1\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\tnext <- i\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, next)\n\t\t\t}\n\t\t}\n\t\tobserve = o.Observe(opts...)\n\tloop2:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop2\n\t\t\tcase i, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop2\n\t\t\t\t}\n\t\t\t\tif i.Error() {\n\t\t\t\t\ti.SendContext(ctx, next)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SendContext(ctx, next)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n\n// SumFloat32 calculates the average of float32 emitted by an Observable and emits a float32.\nfunc (o *ObservableImpl) SumFloat32(opts ...Option) OptionalSingle {\n\treturn o.Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif acc == nil {\n\t\t\tacc = float32(0)\n\t\t}\n\t\tsum := acc.(float32)\n\t\tswitch i := elem.(type) {\n\t\tdefault:\n\t\t\treturn nil, IllegalInputError{error: fmt.Sprintf(\"expected type: (float32|int|int8|int16|int32|int64), got: %t\", elem)}\n\t\tcase int:\n\t\t\treturn sum + float32(i), nil\n\t\tcase int8:\n\t\t\treturn sum + float32(i), nil\n\t\tcase int16:\n\t\t\treturn sum + float32(i), nil\n\t\tcase int32:\n\t\t\treturn sum + float32(i), nil\n\t\tcase int64:\n\t\t\treturn sum + float32(i), nil\n\t\tcase float32:\n\t\t\treturn sum + i, nil\n\t\t}\n\t}, opts...)\n}\n\n// SumFloat64 calculates the average of float64 emitted by an Observable and emits a float64.\nfunc (o *ObservableImpl) SumFloat64(opts ...Option) OptionalSingle {\n\treturn o.Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif acc == nil {\n\t\t\tacc = float64(0)\n\t\t}\n\t\tsum := acc.(float64)\n\t\tswitch i := elem.(type) {\n\t\tdefault:\n\t\t\treturn nil, IllegalInputError{error: fmt.Sprintf(\"expected type: (float32|float64|int|int8|int16|int32|int64), got: %t\", elem)}\n\t\tcase int:\n\t\t\treturn sum + float64(i), nil\n\t\tcase int8:\n\t\t\treturn sum + float64(i), nil\n\t\tcase int16:\n\t\t\treturn sum + float64(i), nil\n\t\tcase int32:\n\t\t\treturn sum + float64(i), nil\n\t\tcase int64:\n\t\t\treturn sum + float64(i), nil\n\t\tcase float32:\n\t\t\treturn sum + float64(i), nil\n\t\tcase float64:\n\t\t\treturn sum + i, nil\n\t\t}\n\t}, opts...)\n}\n\n// SumInt64 calculates the average of integers emitted by an Observable and emits an int64.\nfunc (o *ObservableImpl) SumInt64(opts ...Option) OptionalSingle {\n\treturn o.Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif acc == nil {\n\t\t\tacc = int64(0)\n\t\t}\n\t\tsum := acc.(int64)\n\t\tswitch i := elem.(type) {\n\t\tdefault:\n\t\t\treturn nil, IllegalInputError{error: fmt.Sprintf(\"expected type: (int|int8|int16|int32|int64), got: %t\", elem)}\n\t\tcase int:\n\t\t\treturn sum + int64(i), nil\n\t\tcase int8:\n\t\t\treturn sum + int64(i), nil\n\t\tcase int16:\n\t\t\treturn sum + int64(i), nil\n\t\tcase int32:\n\t\t\treturn sum + int64(i), nil\n\t\tcase int64:\n\t\t\treturn sum + i, nil\n\t\t}\n\t}, opts...)\n}\n\n// Take emits only the first n items emitted by an Observable.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) Take(nth uint, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &takeOperator{\n\t\t\tnth: nth,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype takeOperator struct {\n\tnth       uint\n\ttakeCount int\n}\n\nfunc (op *takeOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif op.takeCount >= int(op.nth) {\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\n\top.takeCount++\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *takeOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *takeOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *takeOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// TakeLast emits only the last n items emitted by an Observable.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) TakeLast(nth uint, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\tn := int(nth)\n\t\treturn &takeLast{\n\t\t\tn: n,\n\t\t\tr: ring.New(n),\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype takeLast struct {\n\tn     int\n\tr     *ring.Ring\n\tcount int\n}\n\nfunc (op *takeLast) next(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\top.count++\n\top.r.Value = item.V\n\top.r = op.r.Next()\n}\n\nfunc (op *takeLast) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *takeLast) end(ctx context.Context, dst chan<- Item) {\n\tif op.count < op.n {\n\t\tremaining := op.n - op.count\n\t\tif remaining <= op.count {\n\t\t\top.r = op.r.Move(op.n - op.count)\n\t\t} else {\n\t\t\top.r = op.r.Move(-op.count)\n\t\t}\n\t\top.n = op.count\n\t}\n\tfor i := 0; i < op.n; i++ {\n\t\tOf(op.r.Value).SendContext(ctx, dst)\n\t\top.r = op.r.Next()\n\t}\n}\n\nfunc (op *takeLast) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// TakeUntil returns an Observable that emits items emitted by the source Observable,\n// checks the specified predicate for each item, and then completes when the condition is satisfied.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) TakeUntil(apply Predicate, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &takeUntilOperator{\n\t\t\tapply: apply,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype takeUntilOperator struct {\n\tapply Predicate\n}\n\nfunc (op *takeUntilOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\titem.SendContext(ctx, dst)\n\tif op.apply(item.V) {\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n}\n\nfunc (op *takeUntilOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *takeUntilOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *takeUntilOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// TakeWhile returns an Observable that emits items emitted by the source ObservableSource so long as each\n// item satisfied a specified condition, and then completes as soon as this condition is not satisfied.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) TakeWhile(apply Predicate, opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &takeWhileOperator{\n\t\t\tapply: apply,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype takeWhileOperator struct {\n\tapply Predicate\n}\n\nfunc (op *takeWhileOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tif !op.apply(item.V) {\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\titem.SendContext(ctx, dst)\n}\n\nfunc (op *takeWhileOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *takeWhileOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *takeWhileOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// TimeInterval converts an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions.\nfunc (o *ObservableImpl) TimeInterval(opts ...Option) Observable {\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tdefer close(next)\n\t\tobserve := o.Observe(opts...)\n\t\tlatest := time.Now().UTC()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\tif !item.SendContext(ctx, next) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnow := time.Now().UTC()\n\t\t\t\t\tif !Of(now.Sub(latest)).SendContext(ctx, next) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tlatest = now\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// Timestamp attaches a timestamp to each item emitted by an Observable indicating when it was emitted.\nfunc (o *ObservableImpl) Timestamp(opts ...Option) Observable {\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &timestampOperator{}\n\t}, true, false, opts...)\n}\n\ntype timestampOperator struct {\n}\n\nfunc (op *timestampOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tOf(TimestampItem{\n\t\tTimestamp: time.Now().UTC(),\n\t\tV:         item.V,\n\t}).SendContext(ctx, dst)\n}\n\nfunc (op *timestampOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *timestampOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *timestampOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// ToMap convert the sequence of items emitted by an Observable\n// into a map keyed by a specified key function.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) ToMap(keySelector Func, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &toMapOperator{\n\t\t\tkeySelector: keySelector,\n\t\t\tm:           make(map[interface{}]interface{}),\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype toMapOperator struct {\n\tkeySelector Func\n\tm           map[interface{}]interface{}\n}\n\nfunc (op *toMapOperator) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tk, err := op.keySelector(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\top.m[k] = item.V\n}\n\nfunc (op *toMapOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *toMapOperator) end(ctx context.Context, dst chan<- Item) {\n\tOf(op.m).SendContext(ctx, dst)\n}\n\nfunc (op *toMapOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// ToMapWithValueSelector convert the sequence of items emitted by an Observable\n// into a map keyed by a specified key function and valued by another\n// value function.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) ToMapWithValueSelector(keySelector, valueSelector Func, opts ...Option) Single {\n\treturn single(o.parent, o, func() operator {\n\t\treturn &toMapWithValueSelector{\n\t\t\tkeySelector:   keySelector,\n\t\t\tvalueSelector: valueSelector,\n\t\t\tm:             make(map[interface{}]interface{}),\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype toMapWithValueSelector struct {\n\tkeySelector, valueSelector Func\n\tm                          map[interface{}]interface{}\n}\n\nfunc (op *toMapWithValueSelector) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tk, err := op.keySelector(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\n\tv, err := op.valueSelector(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\n\top.m[k] = v\n}\n\nfunc (op *toMapWithValueSelector) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *toMapWithValueSelector) end(ctx context.Context, dst chan<- Item) {\n\tOf(op.m).SendContext(ctx, dst)\n}\n\nfunc (op *toMapWithValueSelector) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// ToSlice collects all items from an Observable and emit them in a slice and an optional error.\n// Cannot be run in parallel.\nfunc (o *ObservableImpl) ToSlice(initialCapacity int, opts ...Option) ([]interface{}, error) {\n\top := &toSliceOperator{\n\t\ts: make([]interface{}, 0, initialCapacity),\n\t}\n\t<-observable(o.parent, o, func() operator {\n\t\treturn op\n\t}, true, false, opts...).Run()\n\treturn op.s, op.observableErr\n}\n\ntype toSliceOperator struct {\n\ts             []interface{}\n\tobservableErr error\n}\n\nfunc (op *toSliceOperator) next(_ context.Context, item Item, _ chan<- Item, _ operatorOptions) {\n\top.s = append(op.s, item.V)\n}\n\nfunc (op *toSliceOperator) err(_ context.Context, item Item, _ chan<- Item, operatorOptions operatorOptions) {\n\top.observableErr = item.E\n\toperatorOptions.stop()\n}\n\nfunc (op *toSliceOperator) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *toSliceOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Unmarshal transforms the items emitted by an Observable by applying an unmarshalling to each item.\nfunc (o *ObservableImpl) Unmarshal(unmarshaller Unmarshaller, factory func() interface{}, opts ...Option) Observable {\n\treturn o.Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\tv := factory()\n\t\terr := unmarshaller(i.([]byte), v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn v, nil\n\t}, opts...)\n}\n\n// WindowWithCount periodically subdivides items from an Observable into Observable windows of a given size and emit these windows\n// rather than emitting the items one at a time.\nfunc (o *ObservableImpl) WindowWithCount(count int, opts ...Option) Observable {\n\tif count < 0 {\n\t\treturn Thrown(IllegalInputError{error: \"count must be positive or nil\"})\n\t}\n\n\toption := parseOptions(opts...)\n\treturn observable(o.parent, o, func() operator {\n\t\treturn &windowWithCountOperator{\n\t\t\tcount:  count,\n\t\t\toption: option,\n\t\t}\n\t}, true, false, opts...)\n}\n\ntype windowWithCountOperator struct {\n\tcount          int\n\tiCount         int\n\tcurrentChannel chan Item\n\toption         Option\n}\n\nfunc (op *windowWithCountOperator) pre(ctx context.Context, dst chan<- Item) {\n\tif op.currentChannel == nil {\n\t\tch := op.option.buildChannel()\n\t\top.currentChannel = ch\n\t\tOf(FromChannel(ch)).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *windowWithCountOperator) post(ctx context.Context, dst chan<- Item) {\n\tif op.iCount == op.count {\n\t\top.iCount = 0\n\t\tclose(op.currentChannel)\n\t\tch := op.option.buildChannel()\n\t\top.currentChannel = ch\n\t\tOf(FromChannel(ch)).SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *windowWithCountOperator) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\top.pre(ctx, dst)\n\top.currentChannel <- item\n\top.iCount++\n\top.post(ctx, dst)\n}\n\nfunc (op *windowWithCountOperator) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\top.pre(ctx, dst)\n\top.currentChannel <- item\n\top.iCount++\n\top.post(ctx, dst)\n\toperatorOptions.stop()\n}\n\nfunc (op *windowWithCountOperator) end(_ context.Context, _ chan<- Item) {\n\tif op.currentChannel != nil {\n\t\tclose(op.currentChannel)\n\t}\n}\n\nfunc (op *windowWithCountOperator) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// WindowWithTime periodically subdivides items from an Observable into Observables based on timed windows\n// and emit them rather than emitting the items one at a time.\nfunc (o *ObservableImpl) WindowWithTime(timespan Duration, opts ...Option) Observable {\n\tif timespan == nil {\n\t\treturn Thrown(IllegalInputError{error: \"timespan must no be nil\"})\n\t}\n\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tobserve := o.Observe(opts...)\n\t\tch := option.buildChannel()\n\t\tdone := make(chan struct{})\n\t\tempty := true\n\t\tmutex := sync.Mutex{}\n\t\tif !Of(FromChannel(ch)).SendContext(ctx, next) {\n\t\t\treturn\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tmutex.Lock()\n\t\t\t\tclose(ch)\n\t\t\t\tmutex.Unlock()\n\t\t\t}()\n\t\t\tdefer close(next)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(timespan.duration()):\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tif empty {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tclose(ch)\n\t\t\t\t\tempty = true\n\t\t\t\t\tch = option.buildChannel()\n\t\t\t\t\tif !Of(FromChannel(ch)).SendContext(ctx, next) {\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tclose(done)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tif !item.SendContext(ctx, ch) {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmutex.Lock()\n\t\t\t\tif !item.SendContext(ctx, ch) {\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tempty = false\n\t\t\t\tmutex.Unlock()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// WindowWithTimeOrCount periodically subdivides items from an Observable into Observables based on timed windows or a specific size\n// and emit them rather than emitting the items one at a time.\nfunc (o *ObservableImpl) WindowWithTimeOrCount(timespan Duration, count int, opts ...Option) Observable {\n\tif timespan == nil {\n\t\treturn Thrown(IllegalInputError{error: \"timespan must no be nil\"})\n\t}\n\tif count < 0 {\n\t\treturn Thrown(IllegalInputError{error: \"count must be positive or nil\"})\n\t}\n\n\tf := func(ctx context.Context, next chan Item, option Option, opts ...Option) {\n\t\tobserve := o.Observe(opts...)\n\t\tch := option.buildChannel()\n\t\tdone := make(chan struct{})\n\t\tmutex := sync.Mutex{}\n\t\tiCount := 0\n\t\tif !Of(FromChannel(ch)).SendContext(ctx, next) {\n\t\t\treturn\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tmutex.Lock()\n\t\t\t\tclose(ch)\n\t\t\t\tmutex.Unlock()\n\t\t\t}()\n\t\t\tdefer close(next)\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\treturn\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\tcase <-time.After(timespan.duration()):\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tif iCount == 0 {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tclose(ch)\n\t\t\t\t\tiCount = 0\n\t\t\t\t\tch = option.buildChannel()\n\t\t\t\t\tif !Of(FromChannel(ch)).SendContext(ctx, next) {\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tcase item, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\tclose(done)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif item.Error() {\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tif !item.SendContext(ctx, ch) {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\tif option.getErrorStrategy() == StopOnError {\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmutex.Lock()\n\t\t\t\tif !item.SendContext(ctx, ch) {\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tiCount++\n\t\t\t\tif iCount == count {\n\t\t\t\t\tclose(ch)\n\t\t\t\t\tiCount = 0\n\t\t\t\t\tch = option.buildChannel()\n\t\t\t\t\tif !Of(FromChannel(ch)).SendContext(ctx, next) {\n\t\t\t\t\t\tmutex.Unlock()\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmutex.Unlock()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn customObservableOperator(o.parent, f, opts...)\n}\n\n// ZipFromIterable merges the emissions of an Iterable via a specified function\n// and emit single items for each combination based on the results of this function.\nfunc (o *ObservableImpl) ZipFromIterable(iterable Iterable, zipper Func2, opts ...Option) Observable {\n\toption := parseOptions(opts...)\n\tnext := option.buildChannel()\n\tctx := option.buildContext(o.parent)\n\n\tgo func() {\n\t\tdefer close(next)\n\t\tit1 := o.Observe(opts...)\n\t\tit2 := iterable.Observe(opts...)\n\tloop:\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak loop\n\t\t\tcase i1, ok := <-it1:\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t\tif i1.Error() {\n\t\t\t\t\ti1.SendContext(ctx, next)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\tbreak loop\n\t\t\t\t\tcase i2, ok := <-it2:\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\tbreak loop\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif i2.Error() {\n\t\t\t\t\t\t\ti2.SendContext(ctx, next)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv, err := zipper(ctx, i1.V, i2.V)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tError(err).SendContext(ctx, next)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOf(v).SendContext(ctx, next)\n\t\t\t\t\t\tcontinue loop\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn &ObservableImpl{\n\t\titerable: newChannelIterable(next),\n\t}\n}\n"
        },
        {
          "name": "observable_operator_bench_test.go",
          "type": "blob",
          "size": 3.3251953125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst (\n\tbenchChannelCap            = 1000\n\tbenchNumberOfElementsSmall = 1000\n\tioPool                     = 32\n)\n\nfunc Benchmark_Range_Sequential(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\treturn i, nil\n\t\t\t})\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n\nfunc Benchmark_Range_Serialize(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\treturn i, nil\n\t\t\t}, WithCPUPool(), WithBufferedChannel(benchChannelCap)).\n\t\t\tSerialize(0, func(i interface{}) int {\n\t\t\t\treturn i.(int)\n\t\t\t})\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n\nfunc Benchmark_Range_OptionSerialize(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\treturn i, nil\n\t\t\t}, WithCPUPool(), WithBufferedChannel(benchChannelCap), Serialize(func(i interface{}) int {\n\t\t\t\treturn i.(int)\n\t\t\t}))\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n\nfunc Benchmark_Reduce_Sequential(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tReduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\tif a, ok := acc.(int); ok {\n\t\t\t\t\tif b, ok := elem.(int); ok {\n\t\t\t\t\t\treturn a + b, nil\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn elem.(int), nil\n\t\t\t\t}\n\t\t\t\treturn 0, errFoo\n\t\t\t})\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n\nfunc Benchmark_Reduce_Parallel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tReduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\tif a, ok := acc.(int); ok {\n\t\t\t\t\tif b, ok := elem.(int); ok {\n\t\t\t\t\t\treturn a + b, nil\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn elem.(int), nil\n\t\t\t\t}\n\t\t\t\treturn 0, errFoo\n\t\t\t}, WithPool(ioPool))\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n\nfunc Benchmark_Map_Sequential(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\treturn i, nil\n\t\t\t})\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n\nfunc Benchmark_Map_Parallel(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tb.StopTimer()\n\t\tobs := Range(0, benchNumberOfElementsSmall, WithBufferedChannel(benchChannelCap)).\n\t\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t// Simulate a blocking IO call\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\treturn i, nil\n\t\t\t}, WithCPUPool())\n\t\tb.StartTimer()\n\t\t<-obs.Run()\n\t}\n}\n"
        },
        {
          "name": "observable_operator_option_test.go",
          "type": "blob",
          "size": 4.0830078125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc Test_Observable_Option_WithOnErrorStrategy_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).\n\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\tif i == 2 {\n\t\t\t\treturn nil, errFoo\n\t\t\t}\n\t\t\treturn i, nil\n\t\t}, WithErrorStrategy(ContinueOnError))\n\tAssert(context.Background(), t, obs, HasItems(1, 3), HasError(errFoo))\n}\n\nfunc Test_Observable_Option_WithOnErrorStrategy_Propagate(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).\n\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\tif i == 1 {\n\t\t\t\treturn nil, errFoo\n\t\t\t}\n\t\t\treturn i, nil\n\t\t}).\n\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\tif i == 2 {\n\t\t\t\treturn nil, errBar\n\t\t\t}\n\t\t\treturn i, nil\n\t\t}, WithErrorStrategy(ContinueOnError))\n\tAssert(context.Background(), t, obs, HasItems(3), HasErrors(errFoo, errBar))\n}\n\nfunc Test_Observable_Option_SimpleCapacity(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := Just(1)(WithBufferedChannel(5)).Observe()\n\tassert.Equal(t, 5, cap(ch))\n}\n\nfunc Test_Observable_Option_ComposedCapacity(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tobs1 := Just(1)().Map(func(_ context.Context, _ interface{}) (interface{}, error) {\n\t\treturn 1, nil\n\t}, WithBufferedChannel(11))\n\tobs2 := obs1.Map(func(_ context.Context, _ interface{}) (interface{}, error) {\n\t\treturn 1, nil\n\t}, WithBufferedChannel(12))\n\n\tassert.Equal(t, 11, cap(obs1.Observe()))\n\tassert.Equal(t, 12, cap(obs2.Observe()))\n}\n\nfunc Test_Observable_Option_ContextPropagation(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\texpectedCtx := context.Background()\n\tvar gotCtx context.Context\n\t<-Just(1)().Map(func(ctx context.Context, i interface{}) (interface{}, error) {\n\t\tgotCtx = ctx\n\t\treturn i, nil\n\t}, WithContext(expectedCtx)).Run()\n\tassert.Equal(t, expectedCtx, gotCtx)\n}\n\n// FIXME\n//func Test_Observable_Option_Serialize(t *testing.T) {\n//\tdefer goleak.VerifyNone(t)\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tdefer cancel()\n//\tidx := 1\n//\t<-testObservable(ctx, 1, 3, 2, 6, 4, 5).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n//\t\treturn i, nil\n//\t}, WithBufferedChannel(10), WithCPUPool(), WithContext(ctx), Serialize(func(i interface{}) int {\n//\t\treturn i.(int)\n//\t})).DoOnNext(func(i interface{}) {\n//\t\tv := i.(int)\n//\t\tif v != idx {\n//\t\t\tassert.FailNow(t, \"not sequential\", \"expected=%d, got=%d\", idx, v)\n//\t\t}\n//\t\tidx++\n//\t})\n//}\n\nfunc Test_Observable_Option_Serialize_Range(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tidx := 0\n\t<-Range(0, 10000).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i, nil\n\t}, WithBufferedChannel(10), WithCPUPool(), WithContext(ctx), Serialize(func(i interface{}) int {\n\t\treturn i.(int)\n\t})).DoOnNext(func(i interface{}) {\n\t\tv := i.(int)\n\t\tif v != idx {\n\t\t\tassert.FailNow(t, \"not sequential\", \"expected=%d, got=%d\", idx, v)\n\t\t}\n\t\tidx++\n\t})\n}\n\nfunc Test_Observable_Option_Serialize_SingleElement(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tidx := 0\n\t<-Just(0)().Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i, nil\n\t}, WithBufferedChannel(10), WithCPUPool(), Serialize(func(i interface{}) int {\n\t\treturn i.(int)\n\t})).DoOnNext(func(i interface{}) {\n\t\tv := i.(int)\n\t\tif v != idx {\n\t\t\tassert.FailNow(t, \"not sequential\", \"expected=%d, got=%d\", idx, v)\n\t\t}\n\t\tidx++\n\t})\n}\n\nfunc Test_Observable_Option_Serialize_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, errFoo, 2, 3, 4).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i, nil\n\t}, WithBufferedChannel(10), WithCPUPool(), WithContext(ctx), Serialize(func(i interface{}) int {\n\t\treturn i.(int)\n\t}))\n\tAssert(context.Background(), t, obs, IsEmpty(), HasError(errFoo))\n}\n"
        },
        {
          "name": "observable_operator_random_test.go",
          "type": "blob",
          "size": 3.7041015625,
          "content": "// +build !all\n\npackage rxgo\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/goleak\"\n)\n\nconst maxSleepNs = 10_000_000 // 10 ms\n\n// TODO Keep enriching tests\nfunc TestLeak(t *testing.T) {\n\tvar (\n\t\tcount  = 100\n\t\tfooErr = errors.New(\"\")\n\t)\n\n\tobservables := map[string]func(context.Context) Observable{\n\t\t\"Amb\": func(ctx context.Context) Observable {\n\t\t\tobs := FromChannel(make(chan Item), WithContext(ctx))\n\t\t\treturn Amb([]Observable{obs}, WithContext(ctx))\n\t\t},\n\t\t\"CombineLatest\": func(ctx context.Context) Observable {\n\t\t\treturn CombineLatest(func(i ...interface{}) interface{} {\n\t\t\t\tsum := 0\n\t\t\t\tfor _, v := range i {\n\t\t\t\t\tif v == nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tsum += v.(int)\n\t\t\t\t}\n\t\t\t\treturn sum\n\t\t\t}, []Observable{\n\t\t\t\tJust(1, 2)(),\n\t\t\t\tJust(10, 11)(),\n\t\t\t})\n\t\t},\n\t\t\"Concat\": func(ctx context.Context) Observable {\n\t\t\treturn Concat([]Observable{\n\t\t\t\tJust(1, 2, 3)(),\n\t\t\t\tJust(4, 5, 6)(),\n\t\t\t})\n\t\t},\n\t\t\"FromChannel\": func(ctx context.Context) Observable {\n\t\t\treturn FromChannel(getChannel(ctx), WithContext(ctx))\n\t\t},\n\t\t\"FromEventSource\": func(ctx context.Context) Observable {\n\t\t\treturn FromEventSource(getChannel(ctx), WithContext(ctx))\n\t\t},\n\t}\n\n\tactions := map[string]func(context.Context, Observable){\n\t\t\"All\": func(ctx context.Context, obs Observable) {\n\t\t\tobs.All(func(_ interface{}) bool {\n\t\t\t\treturn true\n\t\t\t}, WithContext(ctx))\n\t\t},\n\t\t\"Average\": func(ctx context.Context, obs Observable) {\n\t\t\tobs.AverageInt(WithContext(ctx))\n\t\t},\n\t\t\"BufferWithTime\": func(ctx context.Context, obs Observable) {\n\t\t\tobs.BufferWithTime(WithDuration(time.Millisecond), WithContext(ctx))\n\t\t},\n\t\t\"Connect\": func(ctx context.Context, obs Observable) {\n\t\t\tobs.Connect(ctx)\n\t\t},\n\t\t\"Contains\": func(ctx context.Context, obs Observable) {\n\t\t\tobs.Contains(func(i interface{}) bool {\n\t\t\t\treturn i == 2\n\t\t\t}, WithContext(ctx))\n\t\t},\n\t\t\"For each\": func(_ context.Context, obs Observable) {\n\t\t\tobs.ForEach(func(_ interface{}) {}, func(_ error) {}, func() {})\n\t\t},\n\t}\n\n\tdefer goleak.VerifyNone(t)\n\tfor testObservable, factory := range observables {\n\t\tfor testAction, action := range actions {\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\twaitTime := randomTime()\n\t\t\t\tfactory := factory\n\t\t\t\taction := action\n\t\t\t\tt.Run(fmt.Sprintf(\"%s - %s - %v - single\", testObservable, testAction, waitTime), func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\t\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), waitTime)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t\taction(ctx, factory(ctx))\n\t\t\t\t})\n\t\t\t\tt.Run(fmt.Sprintf(\"%s - %s - %v - composed\", testObservable, testAction, waitTime), func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\t\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), waitTime)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t\taction(ctx, factory(ctx).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t\t\treturn i, nil\n\t\t\t\t\t}))\n\t\t\t\t})\n\t\t\t\tt.Run(fmt.Sprintf(\"%s - %s - %v - erritem\", testObservable, testAction, waitTime), func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\t\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), waitTime)\n\t\t\t\t\tdefer cancel()\n\t\t\t\t\taction(ctx, factory(ctx).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\t\t\t\treturn nil, fooErr\n\t\t\t\t\t}))\n\t\t\t\t})\n\t\t\t}\n\t\t\tt.Run(fmt.Sprintf(\"%s - %s - already cancelled\", testObservable, testAction), func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\t\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\t\tcancel()\n\t\t\t\taction(ctx, factory(ctx))\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc getChannel(ctx context.Context) chan Item {\n\tch := make(chan Item, 3)\n\tgo func() {\n\t\ttime.Sleep(randomTime())\n\t\tOf(1).SendContext(ctx, ch)\n\t\ttime.Sleep(randomTime())\n\t\tOf(2).SendContext(ctx, ch)\n\t\ttime.Sleep(randomTime())\n\t\tOf(3).SendContext(ctx, ch)\n\t}()\n\treturn ch\n}\n\nfunc randomTime() time.Duration {\n\treturn time.Duration(rand.Intn(maxSleepNs)) * time.Nanosecond\n}\n"
        },
        {
          "name": "observable_operator_test.go",
          "type": "blob",
          "size": 69.8994140625,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/goleak\"\n\n\t\"github.com/cenkalti/backoff/v4\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar predicateAllInt = func(i interface{}) bool {\n\tswitch i.(type) {\n\tcase int:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc Test_Observable_All_True(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Range(1, 10000).All(predicateAllInt),\n\t\tHasItem(true), HasNoError())\n}\n\nfunc Test_Observable_All_False(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1, \"x\", 3).All(predicateAllInt),\n\t\tHasItem(false), HasNoError())\n}\n\nfunc Test_Observable_All_Parallel_True(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Range(1, 10000).All(predicateAllInt, WithContext(ctx), WithCPUPool()),\n\t\tHasItem(true), HasNoError())\n}\n\nfunc Test_Observable_All_Parallel_False(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1, \"x\", 3).All(predicateAllInt, WithContext(ctx), WithCPUPool()),\n\t\tHasItem(false), HasNoError())\n}\n\nfunc Test_Observable_All_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1, errFoo, 3).All(predicateAllInt, WithContext(ctx), WithCPUPool()),\n\t\tHasError(errFoo))\n}\n\nfunc Test_Observable_AverageFloat32(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float32(1), float32(20)).AverageFloat32(), HasItem(float32(10.5)))\n\tAssert(ctx, t, testObservable(ctx, float64(1), float64(20)).AverageFloat32(), HasItem(float32(10.5)))\n}\n\nfunc Test_Observable_AverageFloat32_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().AverageFloat32(), HasItem(0))\n}\n\nfunc Test_Observable_AverageFloat32_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, \"x\").AverageFloat32(), HasAnError())\n}\n\nfunc Test_Observable_AverageFloat32_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float32(1), float32(20)).AverageFloat32(), HasItem(float32(10.5)))\n\tAssert(ctx, t, testObservable(ctx, float64(1), float64(20)).AverageFloat32(), HasItem(float32(10.5)))\n}\n\nfunc Test_Observable_AverageFloat32_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().AverageFloat32(WithContext(ctx), WithCPUPool()),\n\t\tHasItem(0))\n}\n\nfunc Test_Observable_AverageFloat32_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, \"x\").AverageFloat32(WithContext(ctx), WithCPUPool()),\n\t\tHasAnError())\n}\n\nfunc Test_Observable_AverageFloat64(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float64(1), float64(20)).AverageFloat64(), HasItem(10.5))\n\tAssert(ctx, t, testObservable(ctx, float32(1), float32(20)).AverageFloat64(), HasItem(10.5))\n}\n\nfunc Test_Observable_AverageFloat64_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().AverageFloat64(), HasItem(0))\n}\n\nfunc Test_Observable_AverageFloat64_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, \"x\").AverageFloat64(), HasAnError())\n}\n\nfunc Test_Observable_AverageFloat64_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float64(1), float64(20)).AverageFloat64(), HasItem(float64(10.5)))\n}\n\nfunc Test_Observable_AverageFloat64_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().AverageFloat64(WithContext(ctx), WithCPUPool()),\n\t\tHasItem(0))\n}\n\nfunc Test_Observable_AverageFloat64_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, \"x\").AverageFloat64(WithContext(ctx), WithCPUPool()),\n\t\tHasAnError())\n}\n\nfunc Test_Observable_AverageInt(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1, 2, 3).AverageInt(), HasItem(2))\n\tAssert(ctx, t, testObservable(ctx, 1, 20).AverageInt(), HasItem(10))\n\tAssert(ctx, t, Empty().AverageInt(), HasItem(0))\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).AverageInt(), HasAnError())\n}\n\nfunc Test_Observable_AverageInt8(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, int8(1), int8(2), int8(3)).AverageInt8(), HasItem(int8(2)))\n\tAssert(ctx, t, testObservable(ctx, int8(1), int8(20)).AverageInt8(), HasItem(int8(10)))\n\tAssert(ctx, t, Empty().AverageInt8(), HasItem(0))\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).AverageInt8(), HasAnError())\n}\n\nfunc Test_Observable_AverageInt16(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, int16(1), int16(2), int16(3)).AverageInt16(), HasItem(int16(2)))\n\tAssert(ctx, t, testObservable(ctx, int16(1), int16(20)).AverageInt16(), HasItem(int16(10)))\n\tAssert(ctx, t, Empty().AverageInt16(), HasItem(0))\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).AverageInt16(), HasAnError())\n}\n\nfunc Test_Observable_AverageInt32(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, int32(1), int32(2), int32(3)).AverageInt32(), HasItem(int32(2)))\n\tAssert(ctx, t, testObservable(ctx, int32(1), int32(20)).AverageInt32(), HasItem(int32(10)))\n\tAssert(ctx, t, Empty().AverageInt32(), HasItem(0))\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).AverageInt32(), HasAnError())\n}\n\nfunc Test_Observable_AverageInt64(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, int64(1), int64(2), int64(3)).AverageInt64(), HasItem(int64(2)))\n\tAssert(ctx, t, testObservable(ctx, int64(1), int64(20)).AverageInt64(), HasItem(int64(10)))\n\tAssert(ctx, t, Empty().AverageInt64(), HasItem(0))\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).AverageInt64(), HasAnError())\n}\n\nfunc Test_Observable_BackOffRetry(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ti := 0\n\tbackOffCfg := backoff.NewExponentialBackOff()\n\tbackOffCfg.InitialInterval = time.Nanosecond\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tif i == 2 {\n\t\t\tnext <- Of(3)\n\t\t} else {\n\t\t\ti++\n\t\t\tnext <- Error(errFoo)\n\t\t}\n\t}}).BackOffRetry(backoff.WithMaxRetries(backOffCfg, 3))\n\tAssert(ctx, t, obs, HasItems(1, 2, 1, 2, 1, 2, 3), HasNoError())\n}\n\nfunc Test_Observable_BackOffRetry_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tbackOffCfg := backoff.NewExponentialBackOff()\n\tbackOffCfg.InitialInterval = time.Nanosecond\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Error(errFoo)\n\t}}).BackOffRetry(backoff.WithMaxRetries(backOffCfg, 3))\n\tAssert(ctx, t, obs, HasItems(1, 2, 1, 2, 1, 2, 1, 2), HasError(errFoo))\n}\n\nfunc Test_Observable_BufferWithCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5, 6).BufferWithCount(3)\n\tAssert(ctx, t, obs, HasItems([]interface{}{1, 2, 3}, []interface{}{4, 5, 6}))\n}\n\nfunc Test_Observable_BufferWithCount_IncompleteLastItem(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4).BufferWithCount(3)\n\tAssert(ctx, t, obs, HasItems([]interface{}{1, 2, 3}, []interface{}{4}))\n}\n\nfunc Test_Observable_BufferWithCount_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, errFoo).BufferWithCount(3)\n\tAssert(ctx, t, obs, HasItems([]interface{}{1, 2, 3}, []interface{}{4}), HasError(errFoo))\n}\n\nfunc Test_Observable_BufferWithCount_InputError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4).BufferWithCount(0)\n\tAssert(ctx, t, obs, HasAnError())\n}\n\nfunc Test_Observable_BufferWithTime_Single(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Just(1, 2, 3)().BufferWithTime(WithDuration(30 * time.Millisecond))\n\tAssert(ctx, t, obs, HasItems(\n\t\t[]interface{}{1, 2, 3},\n\t))\n}\n\nfunc Test_Observable_BufferWithTime_Multiple(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tch := make(chan Item, 1)\n\tobs := FromChannel(ch)\n\tobs = obs.BufferWithTime(WithDuration(30 * time.Millisecond))\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tch <- Of(i)\n\t\t}\n\t\tclose(ch)\n\t}()\n\tAssert(ctx, t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) == 0 {\n\t\t\treturn errors.New(\"items should not be nil\")\n\t\t}\n\t\treturn nil\n\t}))\n}\n\nfunc Test_Observable_BufferWithTimeOrCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tch := make(chan Item, 1)\n\tobs := FromChannel(ch)\n\tobs = obs.BufferWithTimeOrCount(WithDuration(30*time.Millisecond), 100)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tch <- Of(i)\n\t\t}\n\t\tclose(ch)\n\t}()\n\tAssert(ctx, t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) == 0 {\n\t\t\treturn errors.New(\"items should not be nil\")\n\t\t}\n\t\treturn nil\n\t}))\n}\n\nfunc Test_Observable_Contain(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tpredicate := func(i interface{}) bool {\n\t\tswitch i := i.(type) {\n\t\tcase int:\n\t\t\treturn i == 2\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\n\tAssert(ctx, t,\n\t\ttestObservable(ctx, 1, 2, 3).Contains(predicate),\n\t\tHasItem(true))\n\tAssert(ctx, t,\n\t\ttestObservable(ctx, 1, 5, 3).Contains(predicate),\n\t\tHasItem(false))\n}\n\nfunc Test_Observable_Contain_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tpredicate := func(i interface{}) bool {\n\t\tswitch i := i.(type) {\n\t\tcase int:\n\t\t\treturn i == 2\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\n\tAssert(ctx, t,\n\t\ttestObservable(ctx, 1, 2, 3).Contains(predicate, WithContext(ctx), WithCPUPool()),\n\t\tHasItem(true))\n\tAssert(ctx, t,\n\t\ttestObservable(ctx, 1, 5, 3).Contains(predicate, WithContext(ctx), WithCPUPool()),\n\t\tHasItem(false))\n}\n\nfunc Test_Observable_Count(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Range(1, 10000).Count(),\n\t\tHasItem(int64(10000)))\n}\n\nfunc Test_Observable_Count_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Range(1, 10000).Count(WithCPUPool()),\n\t\tHasItem(int64(10000)))\n}\n\nfunc Test_Observable_Debounce(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, obs, d := timeCausality(1, tick, 2, tick, 3, 4, 5, tick, 6, tick)\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\tAssert(ctx, t, obs.Debounce(d, WithBufferedChannel(10), WithContext(ctx)),\n\t\tHasItems(1, 2, 5, 6))\n}\n\nfunc Test_Observable_Debounce_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, obs, d := timeCausality(1, tick, 2, tick, 3, errFoo, 5, tick, 6, tick)\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\tAssert(ctx, t, obs.Debounce(d, WithBufferedChannel(10), WithContext(ctx)),\n\t\tHasItems(1, 2), HasError(errFoo))\n}\n\nfunc Test_Observable_DefaultIfEmpty_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().DefaultIfEmpty(3)\n\tAssert(ctx, t, obs, HasItems(3))\n}\n\nfunc Test_Observable_DefaultIfEmpty_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2).DefaultIfEmpty(3)\n\tAssert(ctx, t, obs, HasItems(1, 2))\n}\n\nfunc Test_Observable_DefaultIfEmpty_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().DefaultIfEmpty(3, WithCPUPool())\n\tAssert(ctx, t, obs, HasItems(3))\n}\n\nfunc Test_Observable_DefaultIfEmpty_Parallel_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2).DefaultIfEmpty(3, WithCPUPool())\n\tAssert(ctx, t, obs, HasItems(1, 2))\n}\n\nfunc Test_Observable_Distinct(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, 1, 3).Distinct(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\treturn item, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 3), HasNoError())\n}\n\nfunc Test_Observable_Distinct_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, errFoo, 3).Distinct(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\treturn item, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2), HasError(errFoo))\n}\n\nfunc Test_Observable_Distinct_Error2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, 2, 3, 4).Distinct(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\tif item.(int) == 3 {\n\t\t\treturn nil, errFoo\n\t\t}\n\t\treturn item, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2), HasError(errFoo))\n}\n\nfunc Test_Observable_Distinct_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, 1, 3).Distinct(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\treturn item, nil\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItemsNoOrder(1, 2, 3), HasNoError())\n}\n\nfunc Test_Observable_Distinct_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, errFoo).Distinct(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\treturn item, nil\n\t}, WithContext(ctx), WithCPUPool())\n\tAssert(ctx, t, obs, HasError(errFoo))\n}\n\nfunc Test_Observable_Distinct_Parallel_Error2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, 2, 3, 4).Distinct(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\tif item.(int) == 3 {\n\t\t\treturn nil, errFoo\n\t\t}\n\t\treturn item, nil\n\t}, WithContext(ctx), WithCPUPool())\n\tAssert(ctx, t, obs, HasError(errFoo))\n}\n\nfunc Test_Observable_DistinctUntilChanged(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, 1, 3).DistinctUntilChanged(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\treturn item, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 1, 3))\n}\n\nfunc Test_Observable_DistinctUntilChanged_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 2, 1, 3).DistinctUntilChanged(func(_ context.Context, item interface{}) (interface{}, error) {\n\t\treturn item, nil\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItems(1, 2, 1, 3))\n}\n\nfunc Test_Observable_DoOnCompleted_NoError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tcalled := false\n\t<-testObservable(ctx, 1, 2, 3).DoOnCompleted(func() {\n\t\tcalled = true\n\t})\n\tassert.True(t, called)\n}\n\nfunc Test_Observable_DoOnCompleted_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tcalled := false\n\t<-testObservable(ctx, 1, errFoo, 3).DoOnCompleted(func() {\n\t\tcalled = true\n\t})\n\tassert.True(t, called)\n}\n\nfunc Test_Observable_DoOnError_NoError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tvar got error\n\t<-testObservable(ctx, 1, 2, 3).DoOnError(func(err error) {\n\t\tgot = err\n\t})\n\tassert.Nil(t, got)\n}\n\nfunc Test_Observable_DoOnError_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tvar got error\n\t<-testObservable(ctx, 1, errFoo, 3).DoOnError(func(err error) {\n\t\tgot = err\n\t})\n\tassert.Equal(t, errFoo, got)\n}\n\nfunc Test_Observable_DoOnNext_NoError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ts := make([]interface{}, 0)\n\t<-testObservable(ctx, 1, 2, 3).DoOnNext(func(i interface{}) {\n\t\ts = append(s, i)\n\t})\n\tassert.Equal(t, []interface{}{1, 2, 3}, s)\n}\n\nfunc Test_Observable_DoOnNext_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ts := make([]interface{}, 0)\n\t<-testObservable(ctx, 1, errFoo, 3).DoOnNext(func(i interface{}) {\n\t\ts = append(s, i)\n\t})\n\tassert.Equal(t, []interface{}{1}, s)\n}\n\nfunc Test_Observable_ElementAt(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(0, 10000).ElementAt(9999)\n\tAssert(ctx, t, obs, HasItems(9999))\n}\n\nfunc Test_Observable_ElementAt_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(0, 10000).ElementAt(9999, WithCPUPool())\n\tAssert(ctx, t, obs, HasItems(9999))\n}\n\nfunc Test_Observable_ElementAt_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 0, 1, 2, 3, 4).ElementAt(10)\n\tAssert(ctx, t, obs, IsEmpty(), HasAnError())\n}\n\nfunc Test_Observable_Error_NoError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.NoError(t, testObservable(ctx, 1, 2, 3).Error())\n}\n\nfunc Test_Observable_Error_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.Equal(t, errFoo, testObservable(ctx, 1, errFoo, 3).Error())\n}\n\nfunc Test_Observable_Errors_NoError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.Equal(t, 0, len(testObservable(ctx, 1, 2, 3).Errors()))\n}\n\nfunc Test_Observable_Errors_OneError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.Equal(t, 1, len(testObservable(ctx, 1, errFoo, 3).Errors()))\n}\n\nfunc Test_Observable_Errors_MultipleError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tassert.Equal(t, 2, len(testObservable(ctx, 1, errFoo, errBar).Errors()))\n}\n\nfunc Test_Observable_Errors_MultipleErrorFromMap(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\terrs := testObservable(ctx, 1, 2, 3, 4).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\tif i == 2 {\n\t\t\treturn nil, errFoo\n\t\t}\n\t\tif i == 3 {\n\t\t\treturn nil, errBar\n\t\t}\n\t\treturn i, nil\n\t}, WithErrorStrategy(ContinueOnError)).Errors()\n\tassert.Equal(t, 2, len(errs))\n}\n\nfunc Test_Observable_Filter(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4).Filter(\n\t\tfunc(i interface{}) bool {\n\t\t\treturn i.(int)%2 == 0\n\t\t})\n\tAssert(ctx, t, obs, HasItems(2, 4), HasNoError())\n}\n\nfunc Test_Observable_Filter_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4).Filter(\n\t\tfunc(i interface{}) bool {\n\t\t\treturn i.(int)%2 == 0\n\t\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItemsNoOrder(2, 4), HasNoError())\n}\n\nfunc Test_Observable_Find_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).Find(func(i interface{}) bool {\n\t\treturn i == 2\n\t})\n\tAssert(ctx, t, obs, HasItem(2))\n}\n\nfunc Test_Observable_Find_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().Find(func(_ interface{}) bool {\n\t\treturn true\n\t})\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_First_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).First()\n\tAssert(ctx, t, obs, HasItem(1))\n}\n\nfunc Test_Observable_First_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().First()\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_First_Parallel_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).First(WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(1))\n}\n\nfunc Test_Observable_First_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().First(WithCPUPool())\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_FirstOrDefault_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).FirstOrDefault(10)\n\tAssert(ctx, t, obs, HasItem(1))\n}\n\nfunc Test_Observable_FirstOrDefault_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().FirstOrDefault(10)\n\tAssert(ctx, t, obs, HasItem(10))\n}\n\nfunc Test_Observable_FirstOrDefault_Parallel_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).FirstOrDefault(10, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(1))\n}\n\nfunc Test_Observable_FirstOrDefault_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().FirstOrDefault(10, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(10))\n}\n\nfunc Test_Observable_FlatMap(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).FlatMap(func(i Item) Observable {\n\t\treturn testObservable(ctx, i.V.(int)+1, i.V.(int)*10)\n\t})\n\tAssert(ctx, t, obs, HasItems(2, 10, 3, 20, 4, 30))\n}\n\nfunc Test_Observable_FlatMap_Error1(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).FlatMap(func(i Item) Observable {\n\t\tif i.V == 2 {\n\t\t\treturn testObservable(ctx, errFoo)\n\t\t}\n\t\treturn testObservable(ctx, i.V.(int)+1, i.V.(int)*10)\n\t})\n\tAssert(ctx, t, obs, HasItems(2, 10), HasError(errFoo))\n}\n\nfunc Test_Observable_FlatMap_Error2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, errFoo, 3).FlatMap(func(i Item) Observable {\n\t\tif i.Error() {\n\t\t\treturn testObservable(ctx, 0)\n\t\t}\n\t\treturn testObservable(ctx, i.V.(int)+1, i.V.(int)*10)\n\t})\n\tAssert(ctx, t, obs, HasItems(2, 10, 0, 4, 30), HasNoError())\n}\n\nfunc Test_Observable_FlatMap_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).FlatMap(func(i Item) Observable {\n\t\treturn testObservable(ctx, i.V.(int)+1, i.V.(int)*10)\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItemsNoOrder(2, 10, 3, 20, 4, 30))\n}\n\nfunc Test_Observable_FlatMap_Parallel_Error1(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).FlatMap(func(i Item) Observable {\n\t\tif i.V == 2 {\n\t\t\treturn testObservable(ctx, errFoo)\n\t\t}\n\t\treturn testObservable(ctx, i.V.(int)+1, i.V.(int)*10)\n\t})\n\tAssert(ctx, t, obs, HasError(errFoo))\n}\n\nfunc Test_Observable_ForEach_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tcount := 0\n\tvar gotErr error\n\tdone := make(chan struct{})\n\n\tobs := testObservable(ctx, 1, 2, 3, errFoo)\n\tobs.ForEach(func(i interface{}) {\n\t\tcount += i.(int)\n\t}, func(err error) {\n\t\tgotErr = err\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase done <- struct{}{}:\n\t\t}\n\t}, func() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\tcase done <- struct{}{}:\n\t\t}\n\t}, WithContext(ctx))\n\n\t// We avoid using the assertion API on purpose\n\t<-done\n\tassert.Equal(t, 6, count)\n\tassert.Equal(t, errFoo, gotErr)\n}\n\nfunc Test_Observable_ForEach_Done(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tcount := 0\n\tvar gotErr error\n\tdone := make(chan struct{})\n\n\tobs := testObservable(ctx, 1, 2, 3)\n\tobs.ForEach(func(i interface{}) {\n\t\tcount += i.(int)\n\t}, func(err error) {\n\t\tgotErr = err\n\t\tdone <- struct{}{}\n\t}, func() {\n\t\tdone <- struct{}{}\n\t})\n\n\t// We avoid using the assertion API on purpose\n\t<-done\n\tassert.Equal(t, 6, count)\n\tassert.Nil(t, gotErr)\n}\n\nfunc Test_Observable_IgnoreElements(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).IgnoreElements()\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_IgnoreElements_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, errFoo, 3).IgnoreElements()\n\tAssert(ctx, t, obs, IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Observable_IgnoreElements_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).IgnoreElements(WithCPUPool())\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_IgnoreElements_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, errFoo, 3).IgnoreElements(WithCPUPool())\n\tAssert(ctx, t, obs, IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Observable_GroupBy(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tlength := 3\n\tcount := 11\n\n\tobs := Range(0, count).GroupBy(length, func(item Item) int {\n\t\treturn item.V.(int) % length\n\t}, WithBufferedChannel(count))\n\ts, err := obs.ToSlice(0)\n\tif err != nil {\n\t\tassert.FailNow(t, err.Error())\n\t}\n\tif len(s) != length {\n\t\tassert.FailNow(t, \"length\", \"got=%d, expected=%d\", len(s), length)\n\t}\n\n\tAssert(ctx, t, s[0].(Observable), HasItems(0, 3, 6, 9), HasNoError())\n\tAssert(ctx, t, s[1].(Observable), HasItems(1, 4, 7, 10), HasNoError())\n\tAssert(ctx, t, s[2].(Observable), HasItems(2, 5, 8), HasNoError())\n}\n\nfunc Test_Observable_GroupBy_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tlength := 3\n\tcount := 11\n\n\tobs := Range(0, count).GroupBy(length, func(item Item) int {\n\t\treturn 4\n\t}, WithBufferedChannel(count))\n\ts, err := obs.ToSlice(0)\n\tif err != nil {\n\t\tassert.FailNow(t, err.Error())\n\t}\n\tif len(s) != length {\n\t\tassert.FailNow(t, \"length\", \"got=%d, expected=%d\", len(s), length)\n\t}\n\n\tAssert(ctx, t, s[0].(Observable), HasAnError())\n\tAssert(ctx, t, s[1].(Observable), HasAnError())\n\tAssert(ctx, t, s[2].(Observable), HasAnError())\n}\n\nfunc Test_Observable_GroupByDynamic(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tlength := 3\n\tcount := 11\n\n\tobs := Range(0, count).GroupByDynamic(func(item Item) string {\n\t\tif item.V == 10 {\n\t\t\treturn \"10\"\n\t\t}\n\t\treturn strconv.Itoa(item.V.(int) % length)\n\t}, WithBufferedChannel(count))\n\ts, err := obs.ToSlice(0)\n\tif err != nil {\n\t\tassert.FailNow(t, err.Error())\n\t}\n\tif len(s) != 4 {\n\t\tassert.FailNow(t, \"length\", \"got=%d, expected=%d\", len(s), 4)\n\t}\n\n\tAssert(ctx, t, s[0].(GroupedObservable), HasItems(0, 3, 6, 9), HasNoError())\n\tassert.Equal(t, \"0\", s[0].(GroupedObservable).Key)\n\tAssert(ctx, t, s[1].(GroupedObservable), HasItems(1, 4, 7), HasNoError())\n\tassert.Equal(t, \"1\", s[1].(GroupedObservable).Key)\n\tAssert(ctx, t, s[2].(GroupedObservable), HasItems(2, 5, 8), HasNoError())\n\tassert.Equal(t, \"2\", s[2].(GroupedObservable).Key)\n\tAssert(ctx, t, s[3].(GroupedObservable), HasItems(10), HasNoError())\n\tassert.Equal(t, \"10\", s[3].(GroupedObservable).Key)\n}\n\nfunc joinTest(ctx context.Context, t *testing.T, left, right []interface{}, window Duration, expected []int64) {\n\tleftObs := testObservable(ctx, left...)\n\trightObs := testObservable(ctx, right...)\n\n\tobs := leftObs.Join(func(ctx context.Context, l, r interface{}) (interface{}, error) {\n\t\treturn map[string]interface{}{\n\t\t\t\"l\": l,\n\t\t\t\"r\": r,\n\t\t}, nil\n\t},\n\t\trightObs,\n\t\tfunc(i interface{}) time.Time {\n\t\t\treturn time.Unix(0, i.(map[string]int64)[\"tt\"]*1000000)\n\t\t},\n\t\twindow,\n\t)\n\n\tAssert(ctx, t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tactuals := make([]int64, 0)\n\t\tfor _, p := range items {\n\t\t\tval := p.(map[string]interface{})\n\t\t\tactuals = append(actuals, val[\"l\"].(map[string]int64)[\"V\"], val[\"r\"].(map[string]int64)[\"V\"])\n\t\t}\n\t\tassert.Equal(t, expected, actuals)\n\t\treturn nil\n\t}))\n}\n\nfunc Test_Observable_Join1(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tleft := []interface{}{\n\t\tmap[string]int64{\"tt\": 1, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 4, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 7, \"V\": 3},\n\t}\n\tright := []interface{}{\n\t\tmap[string]int64{\"tt\": 2, \"V\": 5},\n\t\tmap[string]int64{\"tt\": 3, \"V\": 6},\n\t\tmap[string]int64{\"tt\": 5, \"V\": 7},\n\t}\n\twindow := WithDuration(2 * time.Millisecond)\n\texpected := []int64{\n\t\t1, 5,\n\t\t1, 6,\n\t\t2, 5,\n\t\t2, 6,\n\t\t2, 7,\n\t\t3, 7,\n\t}\n\n\tjoinTest(ctx, t, left, right, window, expected)\n}\n\nfunc Test_Observable_Join2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tleft := []interface{}{\n\t\tmap[string]int64{\"tt\": 1, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 3, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 5, \"V\": 3},\n\t\tmap[string]int64{\"tt\": 9, \"V\": 4},\n\t}\n\tright := []interface{}{\n\t\tmap[string]int64{\"tt\": 2, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 7, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 10, \"V\": 3},\n\t}\n\twindow := WithDuration(2 * time.Millisecond)\n\texpected := []int64{\n\t\t1, 1,\n\t\t2, 1,\n\t\t3, 2,\n\t\t4, 2,\n\t\t4, 3,\n\t}\n\n\tjoinTest(ctx, t, left, right, window, expected)\n}\n\nfunc Test_Observable_Join3(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tleft := []interface{}{\n\t\tmap[string]int64{\"tt\": 1, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 2, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 3, \"V\": 3},\n\t\tmap[string]int64{\"tt\": 4, \"V\": 4},\n\t}\n\tright := []interface{}{\n\t\tmap[string]int64{\"tt\": 5, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 6, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 7, \"V\": 3},\n\t}\n\twindow := WithDuration(3 * time.Millisecond)\n\texpected := []int64{\n\t\t2, 1,\n\t\t3, 1,\n\t\t3, 2,\n\t\t4, 1,\n\t\t4, 2,\n\t\t4, 3,\n\t}\n\n\tjoinTest(ctx, t, left, right, window, expected)\n}\n\nfunc Test_Observable_Join_Error_OnLeft(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tleft := []interface{}{\n\t\tmap[string]int64{\"tt\": 1, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 3, \"V\": 2},\n\t\terrFoo,\n\t\tmap[string]int64{\"tt\": 9, \"V\": 4},\n\t}\n\tright := []interface{}{\n\t\tmap[string]int64{\"tt\": 2, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 7, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 10, \"V\": 3},\n\t}\n\twindow := WithDuration(3 * time.Millisecond)\n\texpected := []int64{\n\t\t1, 1,\n\t\t2, 1,\n\t}\n\n\tjoinTest(ctx, t, left, right, window, expected)\n}\n\nfunc Test_Observable_Join_Error_OnRight(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tleft := []interface{}{\n\t\tmap[string]int64{\"tt\": 1, \"V\": 1},\n\t\tmap[string]int64{\"tt\": 3, \"V\": 2},\n\t\tmap[string]int64{\"tt\": 5, \"V\": 3},\n\t\tmap[string]int64{\"tt\": 9, \"V\": 4},\n\t}\n\tright := []interface{}{\n\t\tmap[string]int64{\"tt\": 2, \"V\": 1},\n\t\terrFoo,\n\t\tmap[string]int64{\"tt\": 10, \"V\": 3},\n\t}\n\twindow := WithDuration(3 * time.Millisecond)\n\texpected := []int64{\n\t\t1, 1,\n\t}\n\n\tjoinTest(ctx, t, left, right, window, expected)\n}\n\nfunc Test_Observable_Last_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).Last()\n\tAssert(ctx, t, obs, HasItem(3))\n}\n\nfunc Test_Observable_Last_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().Last()\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_Last_Parallel_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).Last(WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(3))\n}\n\nfunc Test_Observable_Last_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().Last(WithCPUPool())\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_LastOrDefault_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).LastOrDefault(10)\n\tAssert(ctx, t, obs, HasItem(3))\n}\n\nfunc Test_Observable_LastOrDefault_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().LastOrDefault(10)\n\tAssert(ctx, t, obs, HasItem(10))\n}\n\nfunc Test_Observable_LastOrDefault_Parallel_NotEmpty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).LastOrDefault(10, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(3))\n}\n\nfunc Test_Observable_LastOrDefault_Parallel_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().LastOrDefault(10, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(10))\n}\n\nfunc Test_Observable_Map_One(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(2, 3, 4), HasNoError())\n}\n\nfunc Test_Observable_Map_Multiple(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t}).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) * 10, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(20, 30, 40), HasNoError())\n}\n\nfunc Test_Observable_Map_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, errFoo).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t})\n\tAssert(ctx, t, obs, HasItems(2, 3, 4), HasError(errFoo))\n}\n\nfunc Test_Observable_Map_ReturnValueAndError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn 2, errFoo\n\t})\n\tAssert(ctx, t, obs, IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Observable_Map_Multiple_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tcalled := false\n\tobs := testObservable(ctx, 1, 2, 3).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn nil, errFoo\n\t}).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\tcalled = true\n\t\treturn nil, nil\n\t})\n\tAssert(ctx, t, obs, IsEmpty(), HasError(errFoo))\n\tassert.False(t, called)\n}\n\nfunc Test_Observable_Map_Cancel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tnext := make(chan Item)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tobs := FromChannel(next).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t}, WithContext(ctx))\n\tcancel()\n\tAssert(ctx, t, obs, IsEmpty(), HasNoError())\n}\n\nfunc Test_Observable_Map_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tconst len = 10\n\tch := make(chan Item, len)\n\tgo func() {\n\t\tfor i := 0; i < len; i++ {\n\t\t\tch <- Of(i)\n\t\t}\n\t\tclose(ch)\n\t}()\n\n\tobs := FromChannel(ch).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t}, WithPool(len))\n\tAssert(ctx, t, obs, HasItemsNoOrder(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), HasNoError())\n}\n\nfunc Test_Observable_Marshal(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, testStruct{\n\t\tID: 1,\n\t}, testStruct{\n\t\tID: 2,\n\t}).Marshal(json.Marshal)\n\tAssert(ctx, t, obs, HasItems([]byte(`{\"id\":1}`), []byte(`{\"id\":2}`)))\n}\n\nfunc Test_Observable_Marshal_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, testStruct{\n\t\tID: 1,\n\t}, testStruct{\n\t\tID: 2,\n\t}).Marshal(json.Marshal,\n\t\t// We cannot use HasItemsNoOrder function with a []byte\n\t\tWithPool(1))\n\tAssert(ctx, t, obs, HasItems([]byte(`{\"id\":1}`), []byte(`{\"id\":2}`)))\n}\n\nfunc Test_Observable_Max(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(0, 10000).Max(func(e1, e2 interface{}) int {\n\t\ti1 := e1.(int)\n\t\ti2 := e2.(int)\n\t\tif i1 > i2 {\n\t\t\treturn 1\n\t\t} else if i1 < i2 {\n\t\t\treturn -1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t})\n\tAssert(ctx, t, obs, HasItem(9999))\n}\n\nfunc Test_Observable_Max_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(0, 10000).Max(func(e1, e2 interface{}) int {\n\t\tvar i1 int\n\t\tif e1 == nil {\n\t\t\ti1 = 0\n\t\t} else {\n\t\t\ti1 = e1.(int)\n\t\t}\n\n\t\tvar i2 int\n\t\tif e2 == nil {\n\t\t\ti2 = 0\n\t\t} else {\n\t\t\ti2 = e2.(int)\n\t\t}\n\n\t\tif i1 > i2 {\n\t\t\treturn 1\n\t\t} else if i1 < i2 {\n\t\t\treturn -1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(9999))\n}\n\nfunc Test_Observable_Min(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(0, 10000).Min(func(e1, e2 interface{}) int {\n\t\ti1 := e1.(int)\n\t\ti2 := e2.(int)\n\t\tif i1 > i2 {\n\t\t\treturn 1\n\t\t} else if i1 < i2 {\n\t\t\treturn -1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t})\n\tAssert(ctx, t, obs, HasItem(0))\n}\n\nfunc Test_Observable_Min_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(0, 10000).Min(func(e1, e2 interface{}) int {\n\t\ti1 := e1.(int)\n\t\ti2 := e2.(int)\n\t\tif i1 > i2 {\n\t\t\treturn 1\n\t\t} else if i1 < i2 {\n\t\t\treturn -1\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(0))\n}\n\nfunc Test_Observable_Observe(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tgot := make([]int, 0)\n\tch := testObservable(ctx, 1, 2, 3).Observe()\n\tfor item := range ch {\n\t\tgot = append(got, item.V.(int))\n\t}\n\tassert.Equal(t, []int{1, 2, 3}, got)\n}\n\nfunc Test_Observable_OnErrorResumeNext(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, errFoo, 4).OnErrorResumeNext(func(e error) Observable {\n\t\treturn testObservable(ctx, 10, 20)\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 10, 20), HasNoError())\n}\n\nfunc Test_Observable_OnErrorReturn(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, errFoo, 4, errBar, 6).OnErrorReturn(func(err error) interface{} {\n\t\treturn err.Error()\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, \"foo\", 4, \"bar\", 6), HasNoError())\n}\n\nfunc Test_Observable_OnErrorReturnItem(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, errFoo, 4, errBar, 6).OnErrorReturnItem(\"foo\")\n\tAssert(ctx, t, obs, HasItems(1, 2, \"foo\", 4, \"foo\", 6), HasNoError())\n}\n\nfunc Test_Observable_Reduce(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(1, 10000).Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif a, ok := acc.(int); ok {\n\t\t\tif b, ok := elem.(int); ok {\n\t\t\t\treturn a + b, nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn elem.(int), nil\n\t\t}\n\t\treturn 0, errFoo\n\t})\n\tAssert(ctx, t, obs, HasItem(50005000), HasNoError())\n}\n\nfunc Test_Observable_Reduce_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\treturn 0, nil\n\t})\n\tAssert(ctx, t, obs, IsEmpty(), HasNoError())\n}\n\nfunc Test_Observable_Reduce_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, errFoo, 4, 5).Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\treturn 0, nil\n\t})\n\tAssert(ctx, t, obs, IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Observable_Reduce_ReturnError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif elem == 2 {\n\t\t\treturn 0, errFoo\n\t\t}\n\t\treturn elem, nil\n\t})\n\tAssert(ctx, t, obs, IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Observable_Reduce_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(1, 10000).Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif a, ok := acc.(int); ok {\n\t\t\tif b, ok := elem.(int); ok {\n\t\t\t\treturn a + b, nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn elem.(int), nil\n\t\t}\n\t\treturn 0, errFoo\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItem(50005000), HasNoError())\n}\n\nfunc Test_Observable_Reduce_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(1, 10000).Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif elem == 1000 {\n\t\t\treturn nil, errFoo\n\t\t}\n\t\tif a, ok := acc.(int); ok {\n\t\t\tif b, ok := elem.(int); ok {\n\t\t\t\treturn a + b, nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn elem.(int), nil\n\t\t}\n\t\treturn 0, errFoo\n\t}, WithContext(ctx), WithCPUPool())\n\tAssert(ctx, t, obs, HasError(errFoo))\n}\n\nfunc Test_Observable_Reduce_Parallel_WithErrorStrategy(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Range(1, 10000).Reduce(func(_ context.Context, acc, elem interface{}) (interface{}, error) {\n\t\tif elem == 1 {\n\t\t\treturn nil, errFoo\n\t\t}\n\t\tif a, ok := acc.(int); ok {\n\t\t\tif b, ok := elem.(int); ok {\n\t\t\t\treturn a + b, nil\n\t\t\t}\n\t\t} else {\n\t\t\treturn elem.(int), nil\n\t\t}\n\t\treturn 0, errFoo\n\t}, WithCPUPool(), WithErrorStrategy(ContinueOnError))\n\tAssert(ctx, t, obs, HasItem(50004999), HasError(errFoo))\n}\n\nfunc Test_Observable_Repeat(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\trepeat := testObservable(ctx, 1, 2, 3).Repeat(1, nil)\n\tAssert(ctx, t, repeat, HasItems(1, 2, 3, 1, 2, 3))\n}\n\nfunc Test_Observable_Repeat_Zero(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\trepeat := testObservable(ctx, 1, 2, 3).Repeat(0, nil)\n\tAssert(ctx, t, repeat, HasItems(1, 2, 3))\n}\n\nfunc Test_Observable_Repeat_NegativeCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\trepeat := testObservable(ctx, 1, 2, 3).Repeat(-2, nil)\n\tAssert(ctx, t, repeat, IsEmpty(), HasAnError())\n}\n\nfunc Test_Observable_Repeat_Infinite(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\trepeat := testObservable(ctx, 1, 2, 3).Repeat(Infinite, nil, WithContext(ctx))\n\tgo func() {\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\tcancel()\n\t}()\n\tAssert(ctx, t, repeat, HasNoError(), CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) == 0 {\n\t\t\treturn errors.New(\"no items\")\n\t\t}\n\t\treturn nil\n\t}))\n}\n\nfunc Test_Observable_Repeat_Frequency(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tfrequency := new(mockDuration)\n\tfrequency.On(\"duration\").Return(time.Millisecond)\n\n\trepeat := testObservable(ctx, 1, 2, 3).Repeat(1, frequency)\n\tAssert(ctx, t, repeat, HasItems(1, 2, 3, 1, 2, 3))\n\tfrequency.AssertNumberOfCalls(t, \"duration\", 1)\n\tfrequency.AssertExpectations(t)\n}\n\nfunc Test_Observable_Retry(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ti := 0\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tif i == 2 {\n\t\t\tnext <- Of(3)\n\t\t} else {\n\t\t\ti++\n\t\t\tnext <- Error(errFoo)\n\t\t}\n\t}}).Retry(3, func(err error) bool {\n\t\treturn true\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 1, 2, 1, 2, 3), HasNoError())\n}\n\nfunc Test_Observable_Retry_Error_ShouldRetry(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Error(errFoo)\n\t}}).Retry(3, func(err error) bool {\n\t\treturn true\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 1, 2, 1, 2, 1, 2), HasError(errFoo))\n}\n\nfunc Test_Observable_Retry_Error_ShouldNotRetry(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Defer([]Producer{func(ctx context.Context, next chan<- Item) {\n\t\tnext <- Of(1)\n\t\tnext <- Of(2)\n\t\tnext <- Error(errFoo)\n\t}}).Retry(3, func(err error) bool {\n\t\treturn false\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2), HasError(errFoo))\n}\n\nfunc Test_Observable_Run(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ts := make([]int, 0)\n\t<-testObservable(ctx, 1, 2, 3).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\ts = append(s, i.(int))\n\t\treturn i, nil\n\t}).Run()\n\tassert.Equal(t, []int{1, 2, 3}, s)\n}\n\nfunc Test_Observable_Run_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ts := make([]int, 0)\n\t<-testObservable(ctx, 1, errFoo).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\ts = append(s, i.(int))\n\t\treturn i, nil\n\t}).Run()\n\tassert.Equal(t, []int{1}, s)\n}\n\nfunc Test_Observable_Sample_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1).Sample(Empty(), WithContext(ctx))\n\tAssert(ctx, t, obs, IsEmpty(), HasNoError())\n}\n\nfunc Test_Observable_Scan(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).Scan(func(_ context.Context, x, y interface{}) (interface{}, error) {\n\t\tif x == nil {\n\t\t\treturn y, nil\n\t\t}\n\t\treturn x.(int) + y.(int), nil\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 3, 6, 10, 15))\n}\n\nfunc Test_Observable_Scan_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).Scan(func(_ context.Context, x, y interface{}) (interface{}, error) {\n\t\tif x == nil {\n\t\t\treturn y, nil\n\t\t}\n\t\treturn x.(int) + y.(int), nil\n\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasItemsNoOrder(1, 3, 6, 10, 15))\n}\n\nfunc Test_Observable_SequenceEqual_EvenSequence(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tsequence := testObservable(ctx, 2, 5, 12, 43, 98, 100, 213)\n\tresult := testObservable(ctx, 2, 5, 12, 43, 98, 100, 213).SequenceEqual(sequence)\n\tAssert(ctx, t, result, HasItem(true))\n}\n\nfunc Test_Observable_SequenceEqual_UnevenSequence(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tsequence := testObservable(ctx, 2, 5, 12, 43, 98, 100, 213)\n\tresult := testObservable(ctx, 2, 5, 12, 43, 15, 100, 213).SequenceEqual(sequence, WithContext(ctx))\n\tAssert(ctx, t, result, HasItem(false))\n}\n\nfunc Test_Observable_SequenceEqual_DifferentLengthSequence(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tsequenceShorter := testObservable(ctx, 2, 5, 12, 43, 98, 100)\n\tsequenceLonger := testObservable(ctx, 2, 5, 12, 43, 98, 100, 213, 512)\n\n\tresultForShorter := testObservable(ctx, 2, 5, 12, 43, 98, 100, 213).SequenceEqual(sequenceShorter)\n\tAssert(ctx, t, resultForShorter, HasItem(false))\n\n\tresultForLonger := testObservable(ctx, 2, 5, 12, 43, 98, 100, 213).SequenceEqual(sequenceLonger)\n\tAssert(ctx, t, resultForLonger, HasItem(false))\n}\n\nfunc Test_Observable_SequenceEqual_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tresult := Empty().SequenceEqual(Empty())\n\tAssert(ctx, t, result, HasItem(true))\n}\n\nfunc Test_Observable_Send(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tch := make(chan Item, 10)\n\ttestObservable(ctx, 1, 2, 3, errFoo).Send(ch)\n\tassert.Equal(t, Of(1), <-ch)\n\tassert.Equal(t, Of(2), <-ch)\n\tassert.Equal(t, Of(3), <-ch)\n\tassert.Equal(t, Error(errFoo), <-ch)\n}\n\ntype message struct {\n\tid int\n}\n\nfunc Test_Observable_Serialize_Struct(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, message{3}, message{5}, message{1}, message{2}, message{4}).\n\t\tSerialize(1, func(i interface{}) int {\n\t\t\treturn i.(message).id\n\t\t})\n\tAssert(ctx, t, obs, HasItems(message{1}, message{2}, message{3}, message{4}, message{5}))\n}\n\nfunc Test_Observable_Serialize_Duplicates(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 3, 2, 6, 4, 5).\n\t\tSerialize(1, func(i interface{}) int {\n\t\t\treturn i.(int)\n\t\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 3, 4, 5, 6))\n}\n\nfunc Test_Observable_Serialize_Loop(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tidx := 0\n\t<-Range(1, 10000).\n\t\tSerialize(0, func(i interface{}) int {\n\t\t\treturn i.(int)\n\t\t}).\n\t\tMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\t\treturn i, nil\n\t\t}, WithCPUPool()).\n\t\tDoOnNext(func(i interface{}) {\n\t\t\tv := i.(int)\n\t\t\tif v != idx {\n\t\t\t\tassert.FailNow(t, \"not sequential\", \"expected=%d, got=%d\", idx, v)\n\t\t\t}\n\t\t\tidx++\n\t\t})\n}\n\nfunc Test_Observable_Serialize_DifferentFrom(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, message{13}, message{15}, message{11}, message{12}, message{14}).\n\t\tSerialize(11, func(i interface{}) int {\n\t\t\treturn i.(message).id\n\t\t})\n\tAssert(ctx, t, obs, HasItems(message{11}, message{12}, message{13}, message{14}, message{15}))\n}\n\nfunc Test_Observable_Serialize_ContextCanceled(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)\n\tdefer cancel()\n\tobs := Never().Serialize(1, func(i interface{}) int {\n\t\treturn i.(message).id\n\t}, WithContext(ctx))\n\tAssert(ctx, t, obs, IsEmpty(), HasNoError())\n}\n\nfunc Test_Observable_Serialize_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, message{3}, message{5}, message{7}, message{2}, message{4}).\n\t\tSerialize(1, func(i interface{}) int {\n\t\t\treturn i.(message).id\n\t\t})\n\tAssert(ctx, t, obs, IsEmpty())\n}\n\nfunc Test_Observable_Serialize_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, message{3}, message{1}, errFoo, message{2}, message{4}).\n\t\tSerialize(1, func(i interface{}) int {\n\t\t\treturn i.(message).id\n\t\t})\n\tAssert(ctx, t, obs, HasItems(message{1}), HasError(errFoo))\n}\n\nfunc Test_Observable_Skip(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 0, 1, 2, 3, 4, 5).Skip(3)\n\tAssert(ctx, t, obs, HasItems(3, 4, 5))\n}\n\nfunc Test_Observable_Skip_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 0, 1, 2, 3, 4, 5).Skip(3, WithCPUPool())\n\tAssert(ctx, t, obs, HasItems(3, 4, 5))\n}\n\nfunc Test_Observable_SkipLast(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 0, 1, 2, 3, 4, 5).SkipLast(3)\n\tAssert(ctx, t, obs, HasItems(0, 1, 2))\n}\n\nfunc Test_Observable_SkipLast_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 0, 1, 2, 3, 4, 5).SkipLast(3, WithCPUPool())\n\tAssert(ctx, t, obs, HasItems(0, 1, 2))\n}\n\nfunc Test_Observable_SkipWhile(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).SkipWhile(func(i interface{}) bool {\n\t\tswitch i := i.(type) {\n\t\tcase int:\n\t\t\treturn i != 3\n\t\tdefault:\n\t\t\treturn true\n\t\t}\n\t})\n\n\tAssert(ctx, t, obs, HasItems(3, 4, 5), HasNoError())\n}\n\nfunc Test_Observable_SkipWhile_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).SkipWhile(func(i interface{}) bool {\n\t\tswitch i := i.(type) {\n\t\tcase int:\n\t\t\treturn i != 3\n\t\tdefault:\n\t\t\treturn true\n\t\t}\n\t}, WithCPUPool())\n\n\tAssert(ctx, t, obs, HasItems(3, 4, 5), HasNoError())\n}\n\nfunc Test_Observable_StartWithIterable(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 4, 5, 6).StartWith(testObservable(ctx, 1, 2, 3))\n\tAssert(ctx, t, obs, HasItems(1, 2, 3, 4, 5, 6), HasNoError())\n}\n\nfunc Test_Observable_StartWithIterable_Error1(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 4, 5, 6).StartWith(testObservable(ctx, 1, errFoo, 3))\n\tAssert(ctx, t, obs, HasItems(1), HasError(errFoo))\n}\n\nfunc Test_Observable_StartWithIterable_Error2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 4, errFoo, 6).StartWith(testObservable(ctx, 1, 2, 3))\n\tAssert(ctx, t, obs, HasItems(1, 2, 3, 4), HasError(errFoo))\n}\n\nfunc Test_Observable_SumFloat32_OnlyFloat32(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float32(1.0), float32(2.0), float32(3.0)).SumFloat32(),\n\t\tHasItem(float32(6.)))\n}\n\nfunc Test_Observable_SumFloat32_DifferentTypes(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float32(1.1), 2, int8(3), int16(1), int32(1), int64(1)).SumFloat32(),\n\t\tHasItem(float32(9.1)))\n}\n\nfunc Test_Observable_SumFloat32_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).SumFloat32(), HasAnError())\n}\n\nfunc Test_Observable_SumFloat32_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().SumFloat32(), IsEmpty())\n}\n\nfunc Test_Observable_SumFloat64_OnlyFloat64(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).SumFloat64(),\n\t\tHasItem(6.6))\n}\n\nfunc Test_Observable_SumFloat64_DifferentTypes(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, float32(1.0), 2, int8(3), 4., int16(1), int32(1), int64(1)).SumFloat64(),\n\t\tHasItem(13.))\n}\n\nfunc Test_Observable_SumFloat64_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, \"x\").SumFloat64(), HasAnError())\n}\n\nfunc Test_Observable_SumFloat64_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().SumFloat64(), IsEmpty())\n}\n\nfunc Test_Observable_SumInt64_OnlyInt64(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1, 2, 3).SumInt64(), HasItem(int64(6)))\n}\n\nfunc Test_Observable_SumInt64_DifferentTypes(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, int8(1), int(2), int16(3), int32(4), int64(5)).SumInt64(),\n\t\tHasItem(int64(15)))\n}\n\nfunc Test_Observable_SumInt64_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, testObservable(ctx, 1.1, 2.2, 3.3).SumInt64(), HasAnError())\n}\n\nfunc Test_Observable_SumInt64_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tAssert(ctx, t, Empty().SumInt64(), IsEmpty())\n}\n\nfunc Test_Observable_Take(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).Take(3)\n\tAssert(ctx, t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_Observable_Take_Interval(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Interval(WithDuration(time.Nanosecond), WithContext(ctx)).Take(3)\n\tAssert(ctx, t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) != 3 {\n\t\t\treturn errors.New(\"3 items are expected\")\n\t\t}\n\t\treturn nil\n\t}))\n}\n\nfunc Test_Observable_TakeLast(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).TakeLast(3)\n\tAssert(ctx, t, obs, HasItems(3, 4, 5))\n}\n\nfunc Test_Observable_TakeLast_LessThanNth(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 4, 5).TakeLast(3)\n\tAssert(ctx, t, obs, HasItems(4, 5))\n}\n\nfunc Test_Observable_TakeLast_LessThanNth2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 4, 5).TakeLast(100000)\n\tAssert(ctx, t, obs, HasItems(4, 5))\n}\n\nfunc Test_Observable_TakeUntil(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).TakeUntil(func(item interface{}) bool {\n\t\treturn item == 3\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2, 3))\n}\n\nfunc Test_Observable_TakeWhile(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3, 4, 5).TakeWhile(func(item interface{}) bool {\n\t\treturn item != 3\n\t})\n\tAssert(ctx, t, obs, HasItems(1, 2))\n}\n\nfunc Test_Observable_TimeInterval(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 1, 2, 3).TimeInterval()\n\tAssert(ctx, t, obs, CustomPredicate(func(items []interface{}) error {\n\t\tif len(items) != 3 {\n\t\t\treturn fmt.Errorf(\"expected 3 items, got %d items\", len(items))\n\t\t}\n\t\treturn nil\n\t}))\n}\n\nfunc Test_Observable_Timestamp(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobserve := testObservable(ctx, 1, 2, 3).Timestamp().Observe()\n\tv := (<-observe).V.(TimestampItem)\n\tassert.Equal(t, 1, v.V)\n\tv = (<-observe).V.(TimestampItem)\n\tassert.Equal(t, 2, v.V)\n\tv = (<-observe).V.(TimestampItem)\n\tassert.Equal(t, 3, v.V)\n}\n\nfunc Test_Observable_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobserve := testObservable(ctx, 1, errFoo).Timestamp().Observe()\n\tv := (<-observe).V.(TimestampItem)\n\tassert.Equal(t, 1, v.V)\n\tassert.True(t, (<-observe).Error())\n}\n\nfunc Test_Observable_ToMap(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, 3, 4, 5, true, false).ToMap(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\tswitch v := i.(type) {\n\t\tcase int:\n\t\t\treturn v, nil\n\t\tcase bool:\n\t\t\tif v {\n\t\t\t\treturn 0, nil\n\t\t\t}\n\t\t\treturn 1, nil\n\t\tdefault:\n\t\t\treturn i, nil\n\t\t}\n\t})\n\tAssert(ctx, t, obs, HasItem(map[interface{}]interface{}{\n\t\t3: 3,\n\t\t4: 4,\n\t\t5: 5,\n\t\t0: true,\n\t\t1: false,\n\t}))\n}\n\nfunc Test_Observable_ToMapWithValueSelector(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tkeySelector := func(_ context.Context, i interface{}) (interface{}, error) {\n\t\tswitch v := i.(type) {\n\t\tcase int:\n\t\t\treturn v, nil\n\t\tcase bool:\n\t\t\tif v {\n\t\t\t\treturn 0, nil\n\t\t\t}\n\t\t\treturn 1, nil\n\t\tdefault:\n\t\t\treturn i, nil\n\t\t}\n\t}\n\tvalueSelector := func(_ context.Context, i interface{}) (interface{}, error) {\n\t\tswitch v := i.(type) {\n\t\tcase int:\n\t\t\treturn v * 10, nil\n\t\tcase bool:\n\t\t\treturn v, nil\n\t\tdefault:\n\t\t\treturn i, nil\n\t\t}\n\t}\n\tsingle := testObservable(ctx, 3, 4, 5, true, false).ToMapWithValueSelector(keySelector, valueSelector)\n\tAssert(ctx, t, single, HasItem(map[interface{}]interface{}{\n\t\t3: 30,\n\t\t4: 40,\n\t\t5: 50,\n\t\t0: true,\n\t\t1: false,\n\t}))\n}\n\nfunc Test_Observable_ToSlice(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ts, err := testObservable(ctx, 1, 2, 3).ToSlice(5)\n\tassert.Equal(t, []interface{}{1, 2, 3}, s)\n\tassert.Equal(t, 5, cap(s))\n\tassert.NoError(t, err)\n}\n\nfunc Test_Observable_ToSlice_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\ts, err := testObservable(ctx, 1, 2, errFoo, 3).ToSlice(0)\n\tassert.Equal(t, []interface{}{1, 2}, s)\n\tassert.Equal(t, errFoo, err)\n}\n\nfunc Test_Observable_Unmarshal(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, []byte(`{\"id\":1}`), []byte(`{\"id\":2}`)).Unmarshal(json.Unmarshal,\n\t\tfunc() interface{} {\n\t\t\treturn &testStruct{}\n\t\t})\n\tAssert(ctx, t, obs, HasItems(&testStruct{\n\t\tID: 1,\n\t}, &testStruct{\n\t\tID: 2,\n\t}))\n}\n\nfunc Test_Observable_Unmarshal_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, []byte(`{\"id\":1`), []byte(`{\"id\":2}`)).Unmarshal(json.Unmarshal,\n\t\tfunc() interface{} {\n\t\t\treturn &testStruct{}\n\t\t})\n\tAssert(ctx, t, obs, HasAnError())\n}\n\nfunc Test_Observable_Unmarshal_Parallel(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, []byte(`{\"id\":1}`), []byte(`{\"id\":2}`)).Unmarshal(json.Unmarshal,\n\t\tfunc() interface{} {\n\t\t\treturn &testStruct{}\n\t\t}, WithPool(1))\n\tAssert(ctx, t, obs, HasItems(&testStruct{\n\t\tID: 1,\n\t}, &testStruct{\n\t\tID: 2,\n\t}))\n}\n\nfunc Test_Observable_Unmarshal_Parallel_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := testObservable(ctx, []byte(`{\"id\":1`), []byte(`{\"id\":2}`)).Unmarshal(json.Unmarshal,\n\t\tfunc() interface{} {\n\t\t\treturn &testStruct{}\n\t\t}, WithCPUPool())\n\tAssert(ctx, t, obs, HasAnError())\n}\n\nfunc Test_Observable_WindowWithCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobserve := testObservable(ctx, 1, 2, 3, 4, 5).WindowWithCount(2).Observe()\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(1, 2))\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(3, 4))\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(5))\n}\n\nfunc Test_Observable_WindowWithCount_ZeroCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobserve := testObservable(ctx, 1, 2, 3, 4, 5).WindowWithCount(0).Observe()\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(1, 2, 3, 4, 5))\n}\n\nfunc Test_Observable_WindowWithCount_ObservableError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobserve := testObservable(ctx, 1, 2, errFoo, 4, 5).WindowWithCount(2).Observe()\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(1, 2))\n\tAssert(ctx, t, (<-observe).V.(Observable), IsEmpty(), HasError(errFoo))\n}\n\nfunc Test_Observable_WindowWithCount_InputError(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs := Empty().WindowWithCount(-1)\n\tAssert(ctx, t, obs, HasAnError())\n}\n\n// FIXME\n//func Test_Observable_WindowWithTime(t *testing.T) {\n//\tdefer goleak.VerifyNone(t)\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tdefer cancel()\n//\tch := make(chan Item, 10)\n//\tch <- Of(1)\n//\tch <- Of(2)\n//\tobs := FromChannel(ch)\n//\tgo func() {\n//\t\ttime.Sleep(30 * time.Millisecond)\n//\t\tch <- Of(3)\n//\t\tclose(ch)\n//\t}()\n//\n//\tobserve := obs.WindowWithTime(WithDuration(10*time.Millisecond), WithBufferedChannel(10)).Observe()\n//\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(1, 2))\n//\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(3))\n//}\n\nfunc Test_Observable_WindowWithTimeOrCount(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tch := make(chan Item, 10)\n\tch <- Of(1)\n\tch <- Of(2)\n\tobs := FromChannel(ch)\n\tgo func() {\n\t\ttime.Sleep(30 * time.Millisecond)\n\t\tch <- Of(3)\n\t\tclose(ch)\n\t}()\n\n\tobserve := obs.WindowWithTimeOrCount(WithDuration(10*time.Millisecond), 1, WithBufferedChannel(10)).Observe()\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(1))\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(2))\n\tAssert(ctx, t, (<-observe).V.(Observable), HasItems(3))\n}\n\nfunc Test_Observable_ZipFromObservable(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs1 := testObservable(ctx, 1, 2, 3)\n\tobs2 := testObservable(ctx, 10, 20, 30)\n\tzipper := func(_ context.Context, elem1, elem2 interface{}) (interface{}, error) {\n\t\tswitch v1 := elem1.(type) {\n\t\tcase int:\n\t\t\tswitch v2 := elem2.(type) {\n\t\t\tcase int:\n\t\t\t\treturn v1 + v2, nil\n\t\t\t}\n\t\t}\n\t\treturn 0, nil\n\t}\n\tzip := obs1.ZipFromIterable(obs2, zipper)\n\tAssert(ctx, t, zip, HasItems(11, 22, 33))\n}\n\nfunc Test_Observable_ZipFromObservable_DifferentLength1(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs1 := testObservable(ctx, 1, 2, 3)\n\tobs2 := testObservable(ctx, 10, 20)\n\tzipper := func(_ context.Context, elem1, elem2 interface{}) (interface{}, error) {\n\t\tswitch v1 := elem1.(type) {\n\t\tcase int:\n\t\t\tswitch v2 := elem2.(type) {\n\t\t\tcase int:\n\t\t\t\treturn v1 + v2, nil\n\t\t\t}\n\t\t}\n\t\treturn 0, nil\n\t}\n\tzip := obs1.ZipFromIterable(obs2, zipper)\n\tAssert(ctx, t, zip, HasItems(11, 22))\n}\n\nfunc Test_Observable_ZipFromObservable_DifferentLength2(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tobs1 := testObservable(ctx, 1, 2)\n\tobs2 := testObservable(ctx, 10, 20, 30)\n\tzipper := func(_ context.Context, elem1, elem2 interface{}) (interface{}, error) {\n\t\tswitch v1 := elem1.(type) {\n\t\tcase int:\n\t\t\tswitch v2 := elem2.(type) {\n\t\t\tcase int:\n\t\t\t\treturn v1 + v2, nil\n\t\t\t}\n\t\t}\n\t\treturn 0, nil\n\t}\n\tzip := obs1.ZipFromIterable(obs2, zipper)\n\tAssert(ctx, t, zip, HasItems(11, 22))\n}\n"
        },
        {
          "name": "optionalsingle.go",
          "type": "blob",
          "size": 2.58203125,
          "content": "package rxgo\n\nimport \"context\"\n\n// OptionalSingleEmpty is the constant returned when an OptionalSingle is empty.\nvar OptionalSingleEmpty = Item{}\n\n// OptionalSingle is an optional single.\ntype OptionalSingle interface {\n\tIterable\n\tGet(opts ...Option) (Item, error)\n\tMap(apply Func, opts ...Option) OptionalSingle\n\tRun(opts ...Option) Disposed\n}\n\n// OptionalSingleImpl implements OptionalSingle.\ntype OptionalSingleImpl struct {\n\tparent   context.Context\n\titerable Iterable\n}\n\n// Get returns the item or rxgo.OptionalEmpty. The error returned is if the context has been cancelled.\n// This method is blocking.\nfunc (o *OptionalSingleImpl) Get(opts ...Option) (Item, error) {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\n\tobserve := o.Observe(opts...)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn Item{}, ctx.Err()\n\t\tcase v, ok := <-observe:\n\t\t\tif !ok {\n\t\t\t\treturn OptionalSingleEmpty, nil\n\t\t\t}\n\t\t\treturn v, nil\n\t\t}\n\t}\n}\n\n// Map transforms the items emitted by an OptionalSingle by applying a function to each item.\nfunc (o *OptionalSingleImpl) Map(apply Func, opts ...Option) OptionalSingle {\n\treturn optionalSingle(o.parent, o, func() operator {\n\t\treturn &mapOperatorOptionalSingle{apply: apply}\n\t}, false, true, opts...)\n}\n\n// Observe observes an OptionalSingle by returning its channel.\nfunc (o *OptionalSingleImpl) Observe(opts ...Option) <-chan Item {\n\treturn o.iterable.Observe(opts...)\n}\n\ntype mapOperatorOptionalSingle struct {\n\tapply Func\n}\n\nfunc (op *mapOperatorOptionalSingle) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tres, err := op.apply(ctx, item.V)\n\tif err != nil {\n\t\tdst <- Error(err)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\tdst <- Of(res)\n}\n\nfunc (op *mapOperatorOptionalSingle) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *mapOperatorOptionalSingle) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *mapOperatorOptionalSingle) gatherNext(_ context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tswitch item.V.(type) {\n\tcase *mapOperatorOptionalSingle:\n\t\treturn\n\t}\n\tdst <- item\n}\n\n// Run creates an observer without consuming the emitted items.\nfunc (o *OptionalSingleImpl) Run(opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(o.parent)\n\n\tgo func() {\n\t\tdefer close(dispose)\n\t\tobserve := o.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase _, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn dispose\n}\n"
        },
        {
          "name": "optionalsingle_test.go",
          "type": "blob",
          "size": 1.572265625,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc Test_OptionalSingle_Get_Item(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tvar os OptionalSingle = &OptionalSingleImpl{iterable: Just(1)()}\n\tget, err := os.Get()\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, get.V)\n}\n\nfunc Test_OptionalSingle_Get_Empty(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tvar os OptionalSingle = &OptionalSingleImpl{iterable: Empty()}\n\tget, err := os.Get()\n\tassert.NoError(t, err)\n\tassert.Equal(t, OptionalSingleEmpty, get)\n}\n\nfunc Test_OptionalSingle_Get_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tvar os OptionalSingle = &OptionalSingleImpl{iterable: Just(errFoo)()}\n\tget, err := os.Get()\n\tassert.NoError(t, err)\n\tassert.Equal(t, errFoo, get.E)\n}\n\nfunc Test_OptionalSingle_Get_ContextCanceled(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tctx, cancel := context.WithCancel(context.Background())\n\tvar os OptionalSingle = &OptionalSingleImpl{iterable: Never()}\n\tcancel()\n\t_, err := os.Get(WithContext(ctx))\n\tassert.Equal(t, ctx.Err(), err)\n}\n\nfunc Test_OptionalSingle_Map(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tsingle := Just(1)().Max(func(_, _ interface{}) int {\n\t\treturn 1\n\t}).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t})\n\tAssert(context.Background(), t, single, HasItem(2), HasNoError())\n}\n\nfunc Test_OptionalSingle_Observe(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tos := JustItem(1).Filter(func(i interface{}) bool {\n\t\treturn i == 1\n\t})\n\tAssert(context.Background(), t, os, HasItem(1), HasNoError())\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 4.42578125,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"runtime\"\n\n\t\"github.com/teivah/onecontext\"\n)\n\nvar emptyContext context.Context\n\n// Option handles configurable options.\ntype Option interface {\n\tapply(*funcOption)\n\ttoPropagate() bool\n\tisEagerObservation() bool\n\tgetPool() (bool, int)\n\tbuildChannel() chan Item\n\tbuildContext(parent context.Context) context.Context\n\tgetBackPressureStrategy() BackpressureStrategy\n\tgetErrorStrategy() OnErrorStrategy\n\tisConnectable() bool\n\tisConnectOperation() bool\n\tisSerialized() (bool, func(interface{}) int)\n}\n\ntype funcOption struct {\n\tf                    func(*funcOption)\n\tisBuffer             bool\n\tbuffer               int\n\tctx                  context.Context\n\tobservation          ObservationStrategy\n\tpool                 int\n\tbackPressureStrategy BackpressureStrategy\n\tonErrorStrategy      OnErrorStrategy\n\tpropagate            bool\n\tconnectable          bool\n\tconnectOperation     bool\n\tserialized           func(interface{}) int\n}\n\nfunc (fdo *funcOption) toPropagate() bool {\n\treturn fdo.propagate\n}\n\nfunc (fdo *funcOption) isEagerObservation() bool {\n\treturn fdo.observation == Eager\n}\n\nfunc (fdo *funcOption) getPool() (bool, int) {\n\treturn fdo.pool > 0, fdo.pool\n}\n\nfunc (fdo *funcOption) buildChannel() chan Item {\n\tif fdo.isBuffer {\n\t\treturn make(chan Item, fdo.buffer)\n\t}\n\treturn make(chan Item)\n}\n\nfunc (fdo *funcOption) buildContext(parent context.Context) context.Context {\n\tif fdo.ctx != nil && parent != nil {\n\t\tctx, _ := onecontext.Merge(fdo.ctx, parent)\n\t\treturn ctx\n\t}\n\n\tif fdo.ctx != nil {\n\t\treturn fdo.ctx\n\t}\n\tif parent != nil {\n\t\treturn parent\n\t}\n\treturn context.Background()\n}\n\nfunc (fdo *funcOption) getBackPressureStrategy() BackpressureStrategy {\n\treturn fdo.backPressureStrategy\n}\n\nfunc (fdo *funcOption) getErrorStrategy() OnErrorStrategy {\n\treturn fdo.onErrorStrategy\n}\n\nfunc (fdo *funcOption) isConnectable() bool {\n\treturn fdo.connectable\n}\n\nfunc (fdo *funcOption) isConnectOperation() bool {\n\treturn fdo.connectOperation\n}\n\nfunc (fdo *funcOption) apply(do *funcOption) {\n\tfdo.f(do)\n}\n\nfunc (fdo *funcOption) isSerialized() (bool, func(interface{}) int) {\n\tif fdo.serialized == nil {\n\t\treturn false, nil\n\t}\n\treturn true, fdo.serialized\n}\n\nfunc newFuncOption(f func(*funcOption)) *funcOption {\n\treturn &funcOption{\n\t\tf: f,\n\t}\n}\n\nfunc parseOptions(opts ...Option) Option {\n\to := new(funcOption)\n\tfor _, opt := range opts {\n\t\topt.apply(o)\n\t}\n\treturn o\n}\n\n// WithBufferedChannel allows to configure the capacity of a buffered channel.\nfunc WithBufferedChannel(capacity int) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.isBuffer = true\n\t\toptions.buffer = capacity\n\t})\n}\n\n// WithContext allows to pass a context.\nfunc WithContext(ctx context.Context) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.ctx = ctx\n\t})\n}\n\n// WithObservationStrategy uses the eager observation mode meaning consuming the items even without subscription.\nfunc WithObservationStrategy(strategy ObservationStrategy) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.observation = strategy\n\t})\n}\n\n// WithPool allows to specify an execution pool.\nfunc WithPool(pool int) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.pool = pool\n\t})\n}\n\n// WithCPUPool allows to specify an execution pool based on the number of logical CPUs.\nfunc WithCPUPool() Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.pool = runtime.NumCPU()\n\t})\n}\n\n// WithBackPressureStrategy sets the back pressure strategy: drop or block.\nfunc WithBackPressureStrategy(strategy BackpressureStrategy) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.backPressureStrategy = strategy\n\t})\n}\n\n// WithErrorStrategy defines how an observable should deal with error.\n// This strategy is propagated to the parent observable.\nfunc WithErrorStrategy(strategy OnErrorStrategy) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.onErrorStrategy = strategy\n\t})\n}\n\n// WithPublishStrategy converts an ordinary Observable into a connectable Observable.\nfunc WithPublishStrategy() Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.connectable = true\n\t})\n}\n\n// Serialize forces an Observable to make serialized calls and to be well-behaved.\nfunc Serialize(identifier func(interface{}) int) Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.serialized = identifier\n\t})\n}\n\nfunc connect() Option {\n\treturn newFuncOption(func(options *funcOption) {\n\t\toptions.connectOperation = true\n\t})\n}\n"
        },
        {
          "name": "single.go",
          "type": "blob",
          "size": 3.193359375,
          "content": "package rxgo\n\nimport \"context\"\n\n// Single is a observable with a single element.\ntype Single interface {\n\tIterable\n\tFilter(apply Predicate, opts ...Option) OptionalSingle\n\tGet(opts ...Option) (Item, error)\n\tMap(apply Func, opts ...Option) Single\n\tRun(opts ...Option) Disposed\n}\n\n// SingleImpl implements Single.\ntype SingleImpl struct {\n\tparent   context.Context\n\titerable Iterable\n}\n\n// Filter emits only those items from an Observable that pass a predicate test.\nfunc (s *SingleImpl) Filter(apply Predicate, opts ...Option) OptionalSingle {\n\treturn optionalSingle(s.parent, s, func() operator {\n\t\treturn &filterOperatorSingle{apply: apply}\n\t}, true, true, opts...)\n}\n\n// Get returns the item. The error returned is if the context has been cancelled.\n// This method is blocking.\nfunc (s *SingleImpl) Get(opts ...Option) (Item, error) {\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(s.parent)\n\n\tobserve := s.Observe(opts...)\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn Item{}, ctx.Err()\n\t\tcase v := <-observe:\n\t\t\treturn v, nil\n\t\t}\n\t}\n}\n\n// Map transforms the items emitted by a Single by applying a function to each item.\nfunc (s *SingleImpl) Map(apply Func, opts ...Option) Single {\n\treturn single(s.parent, s, func() operator {\n\t\treturn &mapOperatorSingle{apply: apply}\n\t}, false, true, opts...)\n}\n\ntype mapOperatorSingle struct {\n\tapply Func\n}\n\nfunc (op *mapOperatorSingle) next(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tres, err := op.apply(ctx, item.V)\n\tif err != nil {\n\t\tError(err).SendContext(ctx, dst)\n\t\toperatorOptions.stop()\n\t\treturn\n\t}\n\tOf(res).SendContext(ctx, dst)\n}\n\nfunc (op *mapOperatorSingle) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *mapOperatorSingle) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *mapOperatorSingle) gatherNext(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tswitch item.V.(type) {\n\tcase *mapOperatorSingle:\n\t\treturn\n\t}\n\titem.SendContext(ctx, dst)\n}\n\n// Observe observes a Single by returning its channel.\nfunc (s *SingleImpl) Observe(opts ...Option) <-chan Item {\n\treturn s.iterable.Observe(opts...)\n}\n\ntype filterOperatorSingle struct {\n\tapply Predicate\n}\n\nfunc (op *filterOperatorSingle) next(ctx context.Context, item Item, dst chan<- Item, _ operatorOptions) {\n\tif op.apply(item.V) {\n\t\titem.SendContext(ctx, dst)\n\t}\n}\n\nfunc (op *filterOperatorSingle) err(ctx context.Context, item Item, dst chan<- Item, operatorOptions operatorOptions) {\n\tdefaultErrorFuncOperator(ctx, item, dst, operatorOptions)\n}\n\nfunc (op *filterOperatorSingle) end(_ context.Context, _ chan<- Item) {\n}\n\nfunc (op *filterOperatorSingle) gatherNext(_ context.Context, _ Item, _ chan<- Item, _ operatorOptions) {\n}\n\n// Run creates an observer without consuming the emitted items.\nfunc (s *SingleImpl) Run(opts ...Option) Disposed {\n\tdispose := make(chan struct{})\n\toption := parseOptions(opts...)\n\tctx := option.buildContext(s.parent)\n\n\tgo func() {\n\t\tdefer close(dispose)\n\t\tobserve := s.Observe(opts...)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tcase _, ok := <-observe:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn dispose\n}\n"
        },
        {
          "name": "single_test.go",
          "type": "blob",
          "size": 1.4638671875,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/goleak\"\n)\n\nfunc Test_Single_Get_Item(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tvar s Single = &SingleImpl{iterable: Just(1)()}\n\tget, err := s.Get()\n\tassert.NoError(t, err)\n\tassert.Equal(t, 1, get.V)\n}\n\nfunc Test_Single_Get_Error(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tvar s Single = &SingleImpl{iterable: Just(errFoo)()}\n\tget, err := s.Get()\n\tassert.NoError(t, err)\n\tassert.Equal(t, errFoo, get.E)\n}\n\nfunc Test_Single_Get_ContextCanceled(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tch := make(chan Item)\n\tdefer close(ch)\n\tctx, cancel := context.WithCancel(context.Background())\n\tvar s Single = &SingleImpl{iterable: FromChannel(ch)}\n\tcancel()\n\t_, err := s.Get(WithContext(ctx))\n\tassert.Equal(t, ctx.Err(), err)\n}\n\nfunc Test_Single_Filter_True(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tos := JustItem(1).Filter(func(i interface{}) bool {\n\t\treturn i == 1\n\t})\n\tAssert(context.Background(), t, os, HasItem(1), HasNoError())\n}\n\nfunc Test_Single_Filter_False(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tos := JustItem(1).Filter(func(i interface{}) bool {\n\t\treturn i == 0\n\t})\n\tAssert(context.Background(), t, os, IsEmpty(), HasNoError())\n}\n\nfunc Test_Single_Map(t *testing.T) {\n\tdefer goleak.VerifyNone(t)\n\tsingle := JustItem(1).Map(func(_ context.Context, i interface{}) (interface{}, error) {\n\t\treturn i.(int) + 1, nil\n\t})\n\tAssert(context.Background(), t, single, HasItem(2), HasNoError())\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 2.8955078125,
          "content": "package rxgo\n\nimport \"context\"\n\ntype (\n\toperatorOptions struct {\n\t\tstop          func()\n\t\tresetIterable func(Iterable)\n\t}\n\n\t// Comparator defines a func that returns an int:\n\t// - 0 if two elements are equals\n\t// - A negative value if the first argument is less than the second\n\t// - A positive value if the first argument is greater than the second\n\tComparator func(interface{}, interface{}) int\n\t// ItemToObservable defines a function that computes an observable from an item.\n\tItemToObservable func(Item) Observable\n\t// ErrorToObservable defines a function that transforms an observable from an error.\n\tErrorToObservable func(error) Observable\n\t// Func defines a function that computes a value from an input value.\n\tFunc func(context.Context, interface{}) (interface{}, error)\n\t// Func2 defines a function that computes a value from two input values.\n\tFunc2 func(context.Context, interface{}, interface{}) (interface{}, error)\n\t// FuncN defines a function that computes a value from N input values.\n\tFuncN func(...interface{}) interface{}\n\t// ErrorFunc defines a function that computes a value from an error.\n\tErrorFunc func(error) interface{}\n\t// Predicate defines a func that returns a bool from an input value.\n\tPredicate func(interface{}) bool\n\t// Marshaller defines a marshaller type (interface{} to []byte).\n\tMarshaller func(interface{}) ([]byte, error)\n\t// Unmarshaller defines an unmarshaller type ([]byte to interface).\n\tUnmarshaller func([]byte, interface{}) error\n\t// Producer defines a producer implementation.\n\tProducer func(ctx context.Context, next chan<- Item)\n\t// Supplier defines a function that supplies a result from nothing.\n\tSupplier func(ctx context.Context) Item\n\t// Disposed is a notification channel indicating when an Observable is closed.\n\tDisposed <-chan struct{}\n\t// Disposable is a function to be called in order to dispose a subscription.\n\tDisposable context.CancelFunc\n\n\t// NextFunc handles a next item in a stream.\n\tNextFunc func(interface{})\n\t// ErrFunc handles an error in a stream.\n\tErrFunc func(error)\n\t// CompletedFunc handles the end of a stream.\n\tCompletedFunc func()\n)\n\n// BackpressureStrategy is the backpressure strategy type.\ntype BackpressureStrategy uint32\n\nconst (\n\t// Block blocks until the channel is available.\n\tBlock BackpressureStrategy = iota\n\t// Drop drops the message.\n\tDrop\n)\n\n// OnErrorStrategy is the Observable error strategy.\ntype OnErrorStrategy uint32\n\nconst (\n\t// StopOnError is the default error strategy.\n\t// An operator will stop processing items on error.\n\tStopOnError OnErrorStrategy = iota\n\t// ContinueOnError means an operator will continue processing items after an error.\n\tContinueOnError\n)\n\n// ObservationStrategy defines the strategy to consume from an Observable.\ntype ObservationStrategy uint32\n\nconst (\n\t// Lazy is the default observation strategy, when an Observer subscribes.\n\tLazy ObservationStrategy = iota\n\t// Eager means consuming as soon as the Observable is created.\n\tEager\n)\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 0.5927734375,
          "content": "package rxgo\n\nimport (\n\t\"context\"\n\t\"errors\"\n)\n\ntype testStruct struct {\n\tID int `json:\"id\"`\n}\n\nvar (\n\terrFoo = errors.New(\"foo\")\n\terrBar = errors.New(\"bar\")\n)\n\nfunc channelValue(ctx context.Context, items ...interface{}) chan Item {\n\tnext := make(chan Item)\n\tgo func() {\n\t\tfor _, item := range items {\n\t\t\tswitch item := item.(type) {\n\t\t\tdefault:\n\t\t\t\tOf(item).SendContext(ctx, next)\n\t\t\tcase error:\n\t\t\t\tError(item).SendContext(ctx, next)\n\t\t\t}\n\t\t}\n\t\tclose(next)\n\t}()\n\treturn next\n}\n\nfunc testObservable(ctx context.Context, items ...interface{}) Observable {\n\treturn FromChannel(channelValue(ctx, items...))\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}