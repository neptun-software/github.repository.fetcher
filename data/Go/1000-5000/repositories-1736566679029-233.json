{
  "metadata": {
    "timestamp": 1736566679029,
    "page": 233,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uptrace/bun",
      "stars": 3941,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.09765625,
          "content": "# Patterns for files created by this project.\n# For other files, use global gitignore.\n*.s3db\n.idea\n"
        },
        {
          "name": ".prettierrc.yml",
          "type": "blob",
          "size": 0.0927734375,
          "content": "trailingComma: all\ntabWidth: 2\nsemi: false\nsingleQuote: true\nproseWrap: always\nprintWidth: 100\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 47.9130859375,
          "content": "## [1.2.8](https://github.com/uptrace/bun/compare/v1.2.7...v1.2.8) (2025-01-06)\n\n\n### Bug Fixes\n\n* comment string zero bytes filtering ([34dfd68](https://github.com/uptrace/bun/commit/34dfd684e371c24b9f59e9b13ef57660931f0bde))\n* get m2m table's structKey with driver.Valuer ([f107314](https://github.com/uptrace/bun/commit/f1073147dc73d01dcf8a6ee9252d354ff06a1062)), closes [#1100](https://github.com/uptrace/bun/issues/1100)\n* return error when use dest with has-many/many-to-many ([8296774](https://github.com/uptrace/bun/commit/829677486b502e6d5d2ae37814488ae9f2c7386e)), closes [#606](https://github.com/uptrace/bun/issues/606)\n* support scan float32 to float32/float64 ([a52e733](https://github.com/uptrace/bun/commit/a52e7339a93f84468878dcaffc42536faa44efae)), closes [#1087](https://github.com/uptrace/bun/issues/1087)\n\n\n### Features\n\n* add RelationWithOpts method to SelectQuery ([dd3ef52](https://github.com/uptrace/bun/commit/dd3ef522c8a9c656958b73ee5d546854fb7c6edf))\n* enhance debugging by adding query comments in headers ([1376d18](https://github.com/uptrace/bun/commit/1376d1870bfe3d89e3630203787f1e87c503d5df))\n* sort fields by struct ([5edb672](https://github.com/uptrace/bun/commit/5edb672e320be9b210f06d25c4f4b9e761c1c526)), closes [#1095](https://github.com/uptrace/bun/issues/1095)\n\n\n\n## [1.2.7](https://github.com/uptrace/bun/compare/v1.2.6...v1.2.7) (2025-01-01)\n\n\n### Bug Fixes\n\n* do not create new migrations if nothing to migrate ([5cc961d](https://github.com/uptrace/bun/commit/5cc961d6cc461ad3534728fc4d3cae12bf8b736e))\n* has many relation with driver.Valuer ([cb8c42c](https://github.com/uptrace/bun/commit/cb8c42cd3f65d95865c76a594abad815eea1df3c))\n* improve range type to support driver.Valuer and sql.Scanner ([856e12b](https://github.com/uptrace/bun/commit/856e12b0d37275a6aa247370f6a8231fd89ca3e7))\n* pass correct 'transactional' parameter ([ebdef1b](https://github.com/uptrace/bun/commit/ebdef1b0e9d33a5ca475ab4c2ec2fb44d11d4595))\n* **pgdialect:** remove unsigned integer conversion ([ab3c679](https://github.com/uptrace/bun/commit/ab3c679d529dd20d44e789dc6f1d89f9510bde0b)), closes [uptrace/bun#624](https://github.com/uptrace/bun/issues/624)\n* remove unused param on table.go and tables.go: canAddr ([d563e2d](https://github.com/uptrace/bun/commit/d563e2dbe95caeb0e00ad1b3e82283431747fe7b))\n* replace the link to docs repo in CONTRIBUTING.md ([e120096](https://github.com/uptrace/bun/commit/e12009662ae1ddefcc1337cc5e32e73d77c7def0))\n* trim surrounding '' in string literal in DEFAULT clause ([a0dff72](https://github.com/uptrace/bun/commit/a0dff72b6ab0ca24d00c96c923046200dd6112ed))\n\n\n### Features\n\n* add an ordered map to remove unnecessary dependencies ([9fea143](https://github.com/uptrace/bun/commit/9fea1437d8344d836670e802fd12d3476e8cad86))\n* support disable dialect's feature ([5343bd7](https://github.com/uptrace/bun/commit/5343bd7fc4ceda866a7d607388ebb7a89f7f5823))\n\n\n\n## [1.2.6](https://github.com/uptrace/bun/compare/v1.2.5...v1.2.6) (2024-11-20)\n\n\n### Bug Fixes\n\n* append IDENTITY to ADD COLUMN statement if needed ([694f873](https://github.com/uptrace/bun/commit/694f873d61ed8d2f09032ae0c0dbec4b71c3719e))\n* **ci:** prune stale should be executed at 3 AM every day ([0cedcb0](https://github.com/uptrace/bun/commit/0cedcb068229b63041a4f48de12bb767c8454048))\n* cleanup after testUniqueRenamedTable ([b1ae32e](https://github.com/uptrace/bun/commit/b1ae32e9e9f45ff2a66e50bfd13bedcf6653d874))\n* fix go.mod of oracledialect ([89e21ea](https://github.com/uptrace/bun/commit/89e21eab362c60511cca00890ae29551a2ba7c46))\n* has many relationship with multiple columns ([1664b2c](https://github.com/uptrace/bun/commit/1664b2c07a5f6cfd3b6730e5005373686e9830a6))\n* ignore case for type equivalence ([c3253a5](https://github.com/uptrace/bun/commit/c3253a5c59b078607db9e216ddc11afdef546e05))\n* implement DefaultSchema for Oracle dialect ([d08fa40](https://github.com/uptrace/bun/commit/d08fa40cc87d67296a83a77448ea511531fc8cdd))\n* **oracledialect:** add go.mod file so the dialect is released properly ([#1043](https://github.com/uptrace/bun/issues/1043)) ([1bb5597](https://github.com/uptrace/bun/commit/1bb5597f1a32f5d693101ef4a62e25d99f5b9db5))\n* **oracledialect:** update go.mod by go mod tidy to fix tests ([7f90a15](https://github.com/uptrace/bun/commit/7f90a15c51a2482dda94226dd13b913d6b470a29))\n* **pgdialect:** array value quoting ([892c416](https://github.com/uptrace/bun/commit/892c416272a8428c592896d65d3ad51a6f2356d8))\n* remove schema name from t.Name during bun-schema inspection ([31ed582](https://github.com/uptrace/bun/commit/31ed58254ad08143d88684672acd33ce044ea5a9))\n* rename column only if the name does not exist in 'target' ([fed6012](https://github.com/uptrace/bun/commit/fed6012d177e55b8320b31ef37fc02a0cbf0b9f5))\n* support embed with tag Unique ([3acd6dd](https://github.com/uptrace/bun/commit/3acd6dd8546118d7b867ca796a5e56311edad070))\n* update oracledialect/version.go in release.sh ([bcd070f](https://github.com/uptrace/bun/commit/bcd070f48a75d0092a5620261658c9c5994f0bf6))\n* update schema.Field names ([9b810de](https://github.com/uptrace/bun/commit/9b810dee4b1a721efb82c913099f39f52c44eb57))\n\n\n### Features\n\n* add and drop columns ([3fdd5b8](https://github.com/uptrace/bun/commit/3fdd5b8f635f849a74e78c665274609f75245b19))\n* add and drop IDENTITY ([dd83779](https://github.com/uptrace/bun/commit/dd837795c31490fd8816eec0e9833e79fafdda32))\n* add support type for net/netip.addr and net/netip.prefix ([#1028](https://github.com/uptrace/bun/issues/1028)) ([95c4a8e](https://github.com/uptrace/bun/commit/95c4a8ebd634e1e99114727a7b157eeeb9297ee9))\n* **automigrate:** detect renamed tables ([c03938f](https://github.com/uptrace/bun/commit/c03938ff5e9fa2f653e4c60668b1368357d2de10))\n* change column type ([3cfd8c6](https://github.com/uptrace/bun/commit/3cfd8c62125786aaf6f493acc5b39f4d3db3d628))\n* **ci:** support release on osx ([435510b](https://github.com/uptrace/bun/commit/435510b0a73b0d9e6d06e3e3c3f0fa4379e9ed8c))\n* create sql migrations and apply them ([1bf7cfd](https://github.com/uptrace/bun/commit/1bf7cfd067e0e26ae212b0f7421e5abc6f67fb4f))\n* create transactional migration files ([c3320f6](https://github.com/uptrace/bun/commit/c3320f624830dc2fe99af2c7cbe492b2a83f9e4a))\n* detect Create/Drop table ([408859f](https://github.com/uptrace/bun/commit/408859f07be38236b39a00909cdce55d49f6f824))\n* detect modified relations ([a918dc4](https://github.com/uptrace/bun/commit/a918dc472a33dd24c5fffd4d048bcf49f2e07a42))\n* detect renamed columns ([886d0a5](https://github.com/uptrace/bun/commit/886d0a5b18aba272f1c86af2a2cf68ce4c8879f2))\n* detect renamed tables ([8857bab](https://github.com/uptrace/bun/commit/8857bab54b94170d218633f3b210d379e4e51a21))\n* enhance Apply method to accept multiple functions ([7823f2f](https://github.com/uptrace/bun/commit/7823f2f24c814e104dc59475156255c7b3b26144))\n* implement fmt.Stringer queries ([5060e47](https://github.com/uptrace/bun/commit/5060e47db13451a982e48d0f14055a58ba60b472))\n* improve FK handling ([a822fc5](https://github.com/uptrace/bun/commit/a822fc5f8ae547b7cd41e1ca35609d519d78598b))\n* include target schema name in migration name ([ac8d221](https://github.com/uptrace/bun/commit/ac8d221e6443b469e794314c5fc189250fa542d5))\n* **mariadb:** support RETURNING clause in DELETE statement ([b8dec9d](https://github.com/uptrace/bun/commit/b8dec9d9a06124696bd5ee2abbf33f19087174b6))\n* migrate FKs ([4c1dfdb](https://github.com/uptrace/bun/commit/4c1dfdbe99c73d0c0f2d7b1f8b11adf30c6a41f7))\n* **mysql:** support ORDER BY and LIMIT clauses in UPDATE and DELETE statements ([de71bed](https://github.com/uptrace/bun/commit/de71bed9252980648269af85b7a51cbc464ce710))\n* support modifying primary keys ([a734629](https://github.com/uptrace/bun/commit/a734629fa285406038cbe4a50798626b5ac08539))\n* support UNIQUE constraints ([3c4d5d2](https://github.com/uptrace/bun/commit/3c4d5d2c47be4652fb9b5cf1c6bd7b6c0a437287))\n* use *bun.DB in MigratorDialect ([a8788bf](https://github.com/uptrace/bun/commit/a8788bf62cbcc954a08532c299c774262de7a81d))\n\n\n\n## [1.2.5](https://github.com/uptrace/bun/compare/v1.2.3...v1.2.5) (2024-10-26)\n\n\n### Bug Fixes\n\n* allow Limit() without Order() with MSSQL ([#1009](https://github.com/uptrace/bun/issues/1009)) ([1a46ddc](https://github.com/uptrace/bun/commit/1a46ddc0d3ca0bdc60ca8be5ad1886799d14c8b0))\n* copy bytes in mapModel.Scan ([#1030](https://github.com/uptrace/bun/issues/1030)) ([#1032](https://github.com/uptrace/bun/issues/1032)) ([39fda4e](https://github.com/uptrace/bun/commit/39fda4e3d341e59e4955f751cb354a939e57c1b1))\n* fix issue with has-many join and pointer fields ([#950](https://github.com/uptrace/bun/issues/950)) ([#983](https://github.com/uptrace/bun/issues/983)) ([cbc5177](https://github.com/uptrace/bun/commit/cbc517792ba6cdcef1828f3699d3d4dfe3c5e0eb))\n* restore explicit column: name override ([#984](https://github.com/uptrace/bun/issues/984)) ([169f258](https://github.com/uptrace/bun/commit/169f258a9460cad451f3025d2ef8df1bbd42a003))\n* return column option back ([#1036](https://github.com/uptrace/bun/issues/1036)) ([a3ccbea](https://github.com/uptrace/bun/commit/a3ccbeab39151d3eed6cb245fe15cfb5d71ba557))\n* sql.NullString mistaken as custom struct ([#1019](https://github.com/uptrace/bun/issues/1019)) ([87c77b8](https://github.com/uptrace/bun/commit/87c77b8911f2035b0ee8ea96356a2c7600b5b94d))\n* typos ([#1026](https://github.com/uptrace/bun/issues/1026)) ([760de7d](https://github.com/uptrace/bun/commit/760de7d0fad15dc761475670a4dde056aef9210d))\n\n\n### Features\n\n* add transaction isolation level support to pgdriver ([#1034](https://github.com/uptrace/bun/issues/1034)) ([3ef44ce](https://github.com/uptrace/bun/commit/3ef44ce1cdd969a21b76d6c803119cf12c375cb0))\n\n\n### Performance Improvements\n\n* refactor SelectQuery.ScanAndCount to optimize performance when there is no limit and offset ([#1035](https://github.com/uptrace/bun/issues/1035)) ([8638613](https://github.com/uptrace/bun/commit/86386135897485bbada6c50ec9a2743626111433))\n\n\n\n## [1.2.4](https://github.com/uptrace/bun/compare/v1.2.3...v1.2.4) (2024-10-26)\n\n\n### Bug Fixes\n\n* allow Limit() without Order() with MSSQL ([#1009](https://github.com/uptrace/bun/issues/1009)) ([1a46ddc](https://github.com/uptrace/bun/commit/1a46ddc0d3ca0bdc60ca8be5ad1886799d14c8b0))\n* copy bytes in mapModel.Scan ([#1030](https://github.com/uptrace/bun/issues/1030)) ([#1032](https://github.com/uptrace/bun/issues/1032)) ([39fda4e](https://github.com/uptrace/bun/commit/39fda4e3d341e59e4955f751cb354a939e57c1b1))\n* return column option back ([#1036](https://github.com/uptrace/bun/issues/1036)) ([a3ccbea](https://github.com/uptrace/bun/commit/a3ccbeab39151d3eed6cb245fe15cfb5d71ba557))\n* sql.NullString mistaken as custom struct ([#1019](https://github.com/uptrace/bun/issues/1019)) ([87c77b8](https://github.com/uptrace/bun/commit/87c77b8911f2035b0ee8ea96356a2c7600b5b94d))\n* typos ([#1026](https://github.com/uptrace/bun/issues/1026)) ([760de7d](https://github.com/uptrace/bun/commit/760de7d0fad15dc761475670a4dde056aef9210d))\n\n\n### Features\n\n* add transaction isolation level support to pgdriver ([#1034](https://github.com/uptrace/bun/issues/1034)) ([3ef44ce](https://github.com/uptrace/bun/commit/3ef44ce1cdd969a21b76d6c803119cf12c375cb0))\n\n\n### Performance Improvements\n\n* refactor SelectQuery.ScanAndCount to optimize performance when there is no limit and offset ([#1035](https://github.com/uptrace/bun/issues/1035)) ([8638613](https://github.com/uptrace/bun/commit/86386135897485bbada6c50ec9a2743626111433))\n\n\n\n## [1.2.3](https://github.com/uptrace/bun/compare/v1.2.2...v1.2.3) (2024-08-31)\n\n\n\n## [1.2.2](https://github.com/uptrace/bun/compare/v1.2.1...v1.2.2) (2024-08-29)\n\n\n### Bug Fixes\n\n* gracefully handle empty hstore in pgdialect ([#1010](https://github.com/uptrace/bun/issues/1010)) ([2f73d8a](https://github.com/uptrace/bun/commit/2f73d8a8e16c8718ebfc956036d9c9a01a0888bc))\n* number each unit test ([#974](https://github.com/uptrace/bun/issues/974)) ([b005dc2](https://github.com/uptrace/bun/commit/b005dc2a9034715c6f59dcfc8e76aa3b85df38ab))\n\n\n### Features\n\n* add ModelTableExpr to TruncateTableQuery ([#969](https://github.com/uptrace/bun/issues/969)) ([7bc330f](https://github.com/uptrace/bun/commit/7bc330f152cf0d9dc30956478e2731ea5816f012))\n\n\n\n## [1.2.1](https://github.com/uptrace/bun/compare/v1.2.0...v1.2.1) (2024-04-02)\n\n\n\n# [1.2.0](https://github.com/uptrace/bun/compare/v1.1.17...v1.2.0) (2024-04-02)\n\n\n### Bug Fixes\n\n* embedding of scanonly fields ([ed6ed74](https://github.com/uptrace/bun/commit/ed6ed74d5379ea6badb09cc37709211a51f5792b))\n* **table:** allow alt annotation ([#956](https://github.com/uptrace/bun/issues/956)) ([8a0397b](https://github.com/uptrace/bun/commit/8a0397b6e2219909d6b00d258eb7934170058edd))\n* transactional migration file extension ([#959](https://github.com/uptrace/bun/issues/959)) ([921b15b](https://github.com/uptrace/bun/commit/921b15b80110d28251a9210c77397d29924ffbc5))\n\n\n### Features\n\n* Allow overriding of Warn and Deprecated loggers ([#952](https://github.com/uptrace/bun/issues/952)) ([0e9d737](https://github.com/uptrace/bun/commit/0e9d737e4ca2deb86930237ee32a39cf3f7e8157))\n* enable SNI ([#953](https://github.com/uptrace/bun/issues/953)) ([4071ffb](https://github.com/uptrace/bun/commit/4071ffb5bcb1b233cda239c92504d8139dcf1d2f))\n* **idb:** add NewMerge method to IDB ([#966](https://github.com/uptrace/bun/issues/966)) ([664e2f1](https://github.com/uptrace/bun/commit/664e2f154f1153d2a80cd062a5074f1692edaee7))\n\n\n\n## [1.1.17](https://github.com/uptrace/bun/compare/v1.1.16...v1.1.17) (2024-01-11)\n\n\n### Features\n\n* add CreateTxSQLMigrations function ([#916](https://github.com/uptrace/bun/issues/916)) ([c68ec7c](https://github.com/uptrace/bun/commit/c68ec7cfc418959eb7c79028be7ac91f97d462ef))\n* add Join to UpdateQuery ([#908](https://github.com/uptrace/bun/issues/908)) ([8c4d8be](https://github.com/uptrace/bun/commit/8c4d8be3aa4e64582698b37fd21434b8960dddc0))\n* bunslog.QueryHook for Bun logging using `log/slog` ([#904](https://github.com/uptrace/bun/issues/904)) ([4953367](https://github.com/uptrace/bun/commit/495336731da0a995aa28c7bc84345c7825408e48))\n* dbfixture.New to accept IDB interface ([#900](https://github.com/uptrace/bun/issues/900)) ([2dee174](https://github.com/uptrace/bun/commit/2dee174bc4d09a45caeeede2885306e5fd10002d))\n\n\n\n## [1.1.16](https://github.com/uptrace/bun/compare/v1.1.15...v1.1.16) (2023-09-16)\n\n\n### Reverts\n\n* Revert \"fix: \"model does not have column\" error (#850)\" ([387228e](https://github.com/uptrace/bun/commit/387228e85d22dfcf3659f4631dfa87106d7ef45f)), closes [#850](https://github.com/uptrace/bun/issues/850)\n\n\n\n## [1.1.15](https://github.com/uptrace/bun/compare/v1.1.14...v1.1.15) (2023-09-10)\n\n\n### Bug Fixes\n\n* \"model does not have column\" error ([#850](https://github.com/uptrace/bun/issues/850)) ([16367aa](https://github.com/uptrace/bun/commit/16367aabb34b98766d28e0678f9d47710f451fae))\n* alloc when mounting ([#891](https://github.com/uptrace/bun/issues/891)) ([f2256f1](https://github.com/uptrace/bun/commit/f2256f10a1d328fb924ca79cde76e77641398573))\n* index hints have to be specified following a table name ([4a2ae85](https://github.com/uptrace/bun/commit/4a2ae853a1509bb300bc2d96471505caee799e43))\n* make Rows.Close to drain messages ([5ceba07](https://github.com/uptrace/bun/commit/5ceba076668eb7aaddb1d8a56202256d5e6c1ead))\n* run hooks on Rows ([#892](https://github.com/uptrace/bun/issues/892)) ([f652b3d](https://github.com/uptrace/bun/commit/f652b3d399a3dc46c856eb8c0f10140a12ea4310))\n* scan error [#709](https://github.com/uptrace/bun/issues/709) ([#837](https://github.com/uptrace/bun/issues/837)) ([b82afa5](https://github.com/uptrace/bun/commit/b82afa52633b2a1b352db6de4ff0d369d5468a07))\n\n\n### Features\n\n* add bun.NullZero ([786bb6b](https://github.com/uptrace/bun/commit/786bb6bfeba3c12f8b28579d61e4794d9fb3e373))\n* **bunotel:** add options for set otel providers ([#836](https://github.com/uptrace/bun/issues/836)) ([806e632](https://github.com/uptrace/bun/commit/806e6323f60b4703b03a71c113c263d0afc95b35))\n\n\n\n## [1.1.14](https://github.com/uptrace/bun/compare/v1.1.13...v1.1.14) (2023-05-24)\n\n\n### Bug Fixes\n\n* enable CompositeIn for MySQL ([9f377b5](https://github.com/uptrace/bun/commit/9f377b5e744cb38ef4aadd61213855c009e47354))\n\n\n\n## [1.1.13](https://github.com/uptrace/bun/compare/v1.1.12...v1.1.13) (2023-05-06)\n\n\n### Bug Fixes\n\n* bunbig.Int.Scan typo ([7ddabb8](https://github.com/uptrace/bun/commit/7ddabb8c667f50032bc0bb2523a287efbe0851e7))\n* compare full MySQL version ([096fabe](https://github.com/uptrace/bun/commit/096fabefa114202d3601ad8e456f5e491a4e3787))\n* enable delete table alias for MySQL >= 8.0.16 ([77a600b](https://github.com/uptrace/bun/commit/77a600bc060154fb91aa68e68ba6a8875e5b10fb))\n* incorrect table relationship panic message [#791](https://github.com/uptrace/bun/issues/791) ([ad41888](https://github.com/uptrace/bun/commit/ad4188862eeaab30fc7c48d3224b5a786557aec5))\n* should rollback if migrate using transaction and got an err (thanks [@bayshark](https://github.com/bayshark)) ([e7a119b](https://github.com/uptrace/bun/commit/e7a119b1b8911d8bf059bb271c90ad4a5f5f02be))\n\n\n### Features\n\n* add option to customize Go migration template ([f31bf73](https://github.com/uptrace/bun/commit/f31bf739b9c7a0383411b9e67cba96c858795c68))\n* expose Exec(…) method for RawQuery ([11192c8](https://github.com/uptrace/bun/commit/11192c83f932eb7421ef09e06859a7f171de7803))\n* prefix migration files with 1 upto 14 digits ([b74b671](https://github.com/uptrace/bun/commit/b74b6714bb6a83e470e21801c97cc40e20acfb50))\n* rename option ([9353a3f](https://github.com/uptrace/bun/commit/9353a3f921c038fdf4a90665f1b0a9d0d03dc182))\n\n\n\n## [1.1.12](https://github.com/uptrace/bun/compare/v1.1.11...v1.1.12) (2023-02-20)\n\n\n\n## [1.1.11](https://github.com/uptrace/bun/compare/v1.1.10...v1.1.11) (2023-02-01)\n\n\n### Bug Fixes\n\n* add support for inserting values with Unicode encoding for mssql dialect ([e98c6c0](https://github.com/uptrace/bun/commit/e98c6c0f033b553bea3bbc783aa56c2eaa17718f))\n* fix relation tag ([a3eedff](https://github.com/uptrace/bun/commit/a3eedff49700490d4998dcdcdc04f554d8f17166))\n\n\n\n## [1.1.10](https://github.com/uptrace/bun/compare/v1.1.9...v1.1.10) (2023-01-16)\n\n\n### Bug Fixes\n\n* allow QueryEvent to better detect operations in raw queries ([8e44735](https://github.com/uptrace/bun/commit/8e4473538364bae6562055d35e94c3e9c0b77691))\n* append default VARCHAR length instead of hardcoding it in the type definition ([e5079c7](https://github.com/uptrace/bun/commit/e5079c70343ba8c8b410aed23ac1d1ae5a2c9ff6))\n* prevent panic when use pg array with custom database type ([67e4412](https://github.com/uptrace/bun/commit/67e4412a972a9ed5f3a1d07c66957beedbc8a8a3))\n* properly return sql.ErrNoRows when scanning []byte ([996fead](https://github.com/uptrace/bun/commit/996fead2595fbcaff4878b77befe6709a54b3a4d))\n\n\n### Features\n\n*  mssql output support for update or delete query ([#718](https://github.com/uptrace/bun/issues/718)) ([08876b4](https://github.com/uptrace/bun/commit/08876b4d420e761cbfa658aa6bb89b3f7c62c240))\n* add Err method to query builder ([c722c90](https://github.com/uptrace/bun/commit/c722c90f3dce2642ca4f4c2ab3f9a35cd496b557))\n* add support for time.Time array in Postgres ([3dd6f3b](https://github.com/uptrace/bun/commit/3dd6f3b2ac1bfbcda08240dc1676647b61715a9c))\n* mssql and pg merge query ([#723](https://github.com/uptrace/bun/issues/723)) ([deea764](https://github.com/uptrace/bun/commit/deea764d9380b16aad34228aa32717d10f2a4bab))\n* setError on attempt to set non-positive .Varchar() ([3335e0b](https://github.com/uptrace/bun/commit/3335e0b9d6d3f424145e1f715223a0fffe773d9a))\n\n\n### Reverts\n\n* go 1.18 ([67a4488](https://github.com/uptrace/bun/commit/67a448897eaaf1ebc54d629dfd3b2509b35da352))\n\n\n\n## [1.1.9](https://github.com/uptrace/bun/compare/v1.1.8...v1.1.9) (2022-11-23)\n\n\n### Bug Fixes\n\n* adding dialect override for append-bool ([#695](https://github.com/uptrace/bun/issues/695)) ([338f2f0](https://github.com/uptrace/bun/commit/338f2f04105ad89e64530db86aeb387e2ad4789e))\n* don't call hooks twice for whereExists ([9057857](https://github.com/uptrace/bun/commit/90578578e717f248e4b6eb114c5b495fd8d4ed41))\n* don't lock migrations when running Migrate and Rollback ([69a7354](https://github.com/uptrace/bun/commit/69a7354d987ff2ed5338c9ef5f4ce320724299ab))\n* **query:** make WhereDeleted compatible with ForceDelete ([299c3fd](https://github.com/uptrace/bun/commit/299c3fd57866aaecd127a8f219c95332898475db)), closes [#673](https://github.com/uptrace/bun/issues/673)\n* relation join soft delete SQL generate ([a98f4e9](https://github.com/uptrace/bun/commit/a98f4e9f2bbdbc2b81cd13aa228a1a91eb905ba2))\n\n\n### Features\n\n* add migrate.Exec ([d368bbe](https://github.com/uptrace/bun/commit/d368bbe52bb1ee3dabf0aada190bf967eec10255))\n* **update:** \"skipupdate\" while bulk ([1a32b2f](https://github.com/uptrace/bun/commit/1a32b2ffbd5bc9a8d8b5978dd0f16c9fb79242ee))\n* **zerolog:** added zerolog hook ([9d2267d](https://github.com/uptrace/bun/commit/9d2267d414b47164ab6ceada55bf311ad548a6b0))\n\n\n\n## [1.1.8](https://github.com/uptrace/bun/compare/v1.1.7...v1.1.8) (2022-08-29)\n\n\n### Bug Fixes\n\n* **bunotel:** handle option attributes ([#656](https://github.com/uptrace/bun/issues/656)) ([9f1e0bd](https://github.com/uptrace/bun/commit/9f1e0bd19fc0300f12996b3e6595f093024e06b6))\n* driver.Valuer returns itself causes stackoverflow ([c9f51d3](https://github.com/uptrace/bun/commit/c9f51d3e2dabed0c29c26a4221abbc426a7206f3)), closes [#657](https://github.com/uptrace/bun/issues/657)\n* **pgdriver:** return FATAL and PANIC errors immediately ([4595e38](https://github.com/uptrace/bun/commit/4595e385d3706116e47bf9dc295186ec7a2ab0f9))\n* quote m2m table name fixes [#649](https://github.com/uptrace/bun/issues/649) ([61a634e](https://github.com/uptrace/bun/commit/61a634e4cd5c18df4b75f756d4b0f06ea94bc3c8))\n* support multi-level embed column ([177ec4c](https://github.com/uptrace/bun/commit/177ec4c6e04f92957614ad4724bc82c422649a4b)), closes [#643](https://github.com/uptrace/bun/issues/643)\n\n\n### Features\n\n* conditions not supporting composite in ([e5d78d4](https://github.com/uptrace/bun/commit/e5d78d464b94b78438cf275b4c35f713d129961d))\n* **idb:** support raw query ([be4e688](https://github.com/uptrace/bun/commit/be4e6886ad94b4b6ca42f24f73d79a15b1ac3188))\n* **migrate:** add MissingMigrations ([42567d0](https://github.com/uptrace/bun/commit/42567d052280f2c412d4796df7178915e537e6d9))\n* **pgdriver:** implement database/sql/driver.SessionResetter ([bda298a](https://github.com/uptrace/bun/commit/bda298ac66305e5b00ba67d72d3973625930c6b9))\n* **pgdriver:** provide access to the underlying net.Conn ([d07ea0e](https://github.com/uptrace/bun/commit/d07ea0ed1541225b5f08e59a4c87383811f7f051))\n\n\n\n## [1.1.7](https://github.com/uptrace/bun/compare/v1.1.6...v1.1.7) (2022-07-29)\n\n\n### Bug Fixes\n\n* change ScanAndCount without a limit to select all rows ([de5c570](https://github.com/uptrace/bun/commit/de5c5704166563aea41a82f7863f2db88ff108e2))\n\n\n\n## [1.1.6](https://github.com/uptrace/bun/compare/v1.1.5...v1.1.6) (2022-07-10)\n\n\n### Bug Fixes\n\n* bunotel add set attributes to query metrics ([dae82cc](https://github.com/uptrace/bun/commit/dae82cc0e3af49be1e474027b55c34364676985d))\n* **db.ScanRows:** ensure rows.Close is called ([9ffbc6a](https://github.com/uptrace/bun/commit/9ffbc6a46e24b908742b6973f33ef8e5b17cc12b))\n* merge apply ([3081849](https://github.com/uptrace/bun/commit/30818499eacddd3b1a3e749091ba6a1468125641))\n* **migrate:** close conn/tx on error ([7b168ea](https://github.com/uptrace/bun/commit/7b168eabfe0f844bcbf8dc89629d04c385b9f58c))\n* **migrate:** type Migration should be used as a value rather than a pointer ([fb43935](https://github.com/uptrace/bun/commit/fb4393582b49fe528800a66aac5fb1c9a6033048))\n* **migrate:** type MigrationGroup should be used as a value rather than a pointer ([649da1b](https://github.com/uptrace/bun/commit/649da1b3c158060add9b61b32c289260daafa65a))\n* mssql cursor pagination ([#589](https://github.com/uptrace/bun/issues/589)) ([b34ec97](https://github.com/uptrace/bun/commit/b34ec97ddda95629f73762721d60fd3e00e7e99f))\n\n\n### Features\n\n* \"skipupdate\" model field tag ([#565](https://github.com/uptrace/bun/issues/565)) ([9288294](https://github.com/uptrace/bun/commit/928829482c718a0c215aa4f4adfa6f3fb3ed4302))\n* add pgdriver write error to log ([5ddda3d](https://github.com/uptrace/bun/commit/5ddda3de31cd08ceee4bdea64ceae8d15eace07b))\n* add query string representation ([520da7e](https://github.com/uptrace/bun/commit/520da7e1d6dbf7b06846f6b39a7f99e8753c1466))\n* add relation condition with tag ([fe5bbf6](https://github.com/uptrace/bun/commit/fe5bbf64f33d25b310e5510ece7d705b9eb3bfea))\n* add support for ON UPDATE and ON DELETE rules on belongs-to relationships from struct tags ([#533](https://github.com/uptrace/bun/issues/533)) ([a327b2a](https://github.com/uptrace/bun/commit/a327b2ae216abb55a705626296c0cdbf8d648697))\n* add tx methods to IDB ([#587](https://github.com/uptrace/bun/issues/587)) ([feab313](https://github.com/uptrace/bun/commit/feab313c0358200b6e270ac70f4551b011ab5276))\n* added raw query calls ([#596](https://github.com/uptrace/bun/issues/596)) ([127644d](https://github.com/uptrace/bun/commit/127644d2eea443736fbd6bed3417595d439e4639))\n* **bunotel:** add option to enable formatting of queries ([#547](https://github.com/uptrace/bun/issues/547)) ([b9c768c](https://github.com/uptrace/bun/commit/b9c768cec3b5dea36c3c9c344d1e76e0ffad1369))\n* **config.go:** add sslrootcert support to DSN parameters ([3bd5d69](https://github.com/uptrace/bun/commit/3bd5d692d7df4f30d07b835d6a46fc7af382489a))\n* create an extra module for newrelic ([#599](https://github.com/uptrace/bun/issues/599)) ([6c676ce](https://github.com/uptrace/bun/commit/6c676ce13f05fe763471fbec2d5a2db48bc88650))\n* **migrate:** add WithMarkAppliedOnSuccess ([31b2cc4](https://github.com/uptrace/bun/commit/31b2cc4f5ccd794a436d081073d4974835d3780d))\n* **pgdialect:** add hstore support ([66b44f7](https://github.com/uptrace/bun/commit/66b44f7c0edc205927fb8be96aaf263b31828fa1))\n* **pgdialect:** add identity support ([646251e](https://github.com/uptrace/bun/commit/646251ec02a1e2ec717e907e6f128d8b51f17c6d))\n* **pgdriver:** expose pgdriver.ParseTime ([405a7d7](https://github.com/uptrace/bun/commit/405a7d78d8f60cf27e8f175deaf95db5877d84be))\n\n\n\n## [1.1.5](https://github.com/uptrace/bun/compare/v1.1.4...v1.1.5) (2022-05-12)\n\n\n### Bug Fixes\n\n* **driver/sqliteshim:** make it work with recent version of modernc sqlite ([2360584](https://github.com/uptrace/bun/commit/23605846c20684e39bf1eaac50a2147a1b68a729))\n\n\n\n## [1.1.4](https://github.com/uptrace/bun/compare/v1.1.3...v1.1.4) (2022-04-20)\n\n\n### Bug Fixes\n\n* automatically set nullzero when there is default:value option ([72c44ae](https://github.com/uptrace/bun/commit/72c44aebbeec3a83ed97ea25a3262174d744df65))\n* fix ForceDelete on live/undeleted rows ([1a33250](https://github.com/uptrace/bun/commit/1a33250f27f00e752a735ce10311ac95dcb0c968))\n* fix OmitZero and value overriding ([087ea07](https://github.com/uptrace/bun/commit/087ea0730551f1e841bacb6ad2fa3afd512a1df8))\n* rename Query to QueryBuilder ([98d111b](https://github.com/uptrace/bun/commit/98d111b7cc00fa61b6b2cec147f43285f4baadb4))\n\n\n### Features\n\n* add ApplyQueryBuilder ([582eca0](https://github.com/uptrace/bun/commit/582eca09cf2b59e67c2e4a2ad24f1a74cb53addd))\n* **config.go:** add connect_timeout to DSN parsable params ([998b04d](https://github.com/uptrace/bun/commit/998b04d51a9a4f182ac3458f90db8dbf9185c4ba)), closes [#505](https://github.com/uptrace/bun/issues/505)\n\n\n\n# [1.1.3](https://github.com/uptrace/bun/compare/v1.1.2...v) (2022-03-29)\n\n### Bug Fixes\n\n- fix panic message when has-many encounter an error\n  ([cfd2747](https://github.com/uptrace/bun/commit/cfd27475fac89a1c8cf798bfa64898bd77bbba79))\n- **migrate:** change rollback to match migrate behavior\n  ([df5af9c](https://github.com/uptrace/bun/commit/df5af9c9cbdf54ce243e037bbb2c7b154f8422b3))\n\n### Features\n\n- added QueryBuilder interface for SelectQuery, UpdateQuery, DeleteQuery\n  ([#499](https://github.com/uptrace/bun/issues/499))\n  ([59fef48](https://github.com/uptrace/bun/commit/59fef48f6b3ec7f32bdda779b6693c333ff1dfdb))\n\n# [1.1.2](https://github.com/uptrace/bun/compare/v1.1.2...v) (2022-03-22)\n\n### Bug Fixes\n\n- correctly handle bun.In([][]byte{...})\n  ([800616e](https://github.com/uptrace/bun/commit/800616ed28ca600ad676319a10adb970b2b4daf6))\n\n### Features\n\n- accept extend option to allow extending existing models\n  ([48b80e4](https://github.com/uptrace/bun/commit/48b80e4f7e3ed8a28fd305f7853ebe7ab984a497))\n\n# [1.1.0](https://github.com/uptrace/bun/compare/v1.1.0-beta.1...v1.1.0) (2022-02-28)\n\n### Features\n\n- Added [MSSQL](https://bun.uptrace.dev/guide/drivers.html#mssql) support as a 4th fully supported\n  DBMS.\n- Added `SetColumn(\"col_name\", \"upper(?)\", \"hello\")` in addition to\n  `Set(\"col_name = upper(?)\", \"hello\")` which works for all 4 supported DBMS.\n\n* improve nil ptr values handling\n  ([b398e6b](https://github.com/uptrace/bun/commit/b398e6bea840ea2fd3e001b7879c0b00b6dcd6f7))\n\n### Breaking changes\n\n- Bun no longer automatically marks some fields like `ID int64` as `pk` and `autoincrement`. You\n  need to manually add those options:\n\n```diff\ntype Model struct {\n-\t ID int64\n+\t ID int64 `bun:\",pk,autoincrement\"`\n}\n```\n\nBun [v1.0.25](#1024-2022-02-22) prints warnings for models with missing options so you are\nrecommended to upgrade to v1.0.24 before upgrading to v1.1.x.\n\n- Also, Bun no longer adds `nullzero` option to `soft_delete` fields.\n\n- Removed `nopk` and `allowzero` options.\n\n### Bug Fixes\n\n- append slice values\n  ([4a65129](https://github.com/uptrace/bun/commit/4a651294fb0f1e73079553024810c3ead9777311))\n- check for nils when appending driver.Value\n  ([7bb1640](https://github.com/uptrace/bun/commit/7bb1640a00fceca1e1075fe6544b9a4842ab2b26))\n- cleanup soft deletes for mssql\n  ([e72e2c5](https://github.com/uptrace/bun/commit/e72e2c5d0a85f3d26c3fa22c7284c2de1dcfda8e))\n- **dbfixture:** apply cascade option. Fixes [#447](https://github.com/uptrace/bun/issues/447)\n  ([d32d988](https://github.com/uptrace/bun/commit/d32d98840bc23e74c836f8192cb4bc9529aa9233))\n- create table WithForeignKey() and has-many relation\n  ([3cf5649](https://github.com/uptrace/bun/commit/3cf56491706b5652c383dbe007ff2389ad64922e))\n- do not emit m2m relations in WithForeignKeys()\n  ([56c8c5e](https://github.com/uptrace/bun/commit/56c8c5ed44c0d6d734c3d3161c642ce8437e2248))\n- accept dest in select queries\n  ([33b5b6f](https://github.com/uptrace/bun/commit/33b5b6ff660b77238a737a543ca12675c7f0c284))\n\n## [1.0.25](https://github.com/uptrace/bun/compare/v1.0.23...v1.0.25) (2022-02-22)\n\n### Bug Fixes\n\n### Deprecated\n\nIn the coming v1.1.x release, Bun will stop automatically adding `,pk,autoincrement` options on\n`ID int64/int32` fields. This version (v1.0.23) only prints a warning when it encounters such\nfields, but the code will continue working as before.\n\nTo fix warnings, add missing options:\n\n```diff\ntype Model struct {\n-\t ID int64\n+\t ID int64 `bun:\",pk,autoincrement\"`\n}\n```\n\nTo silence warnings:\n\n```go\nbun.SetWarnLogger(log.New(ioutil.Discard, \"\", log.LstdFlags))\n```\n\nBun will also print a warning on [soft delete](https://bun.uptrace.dev/guide/soft-deletes.html)\nfields without a `,nullzero` option. You can fix the warning by adding missing `,nullzero` or\n`,allowzero` options.\n\nIn v1.1.x, such options as `,nopk` and `,allowzero` will not be necessary and will be removed.\n\n### Bug Fixes\n\n- fix missing autoincrement warning\n  ([3bc9c72](https://github.com/uptrace/bun/commit/3bc9c721e1c1c5104c256a0c01c4525df6ecefc2))\n\n* append slice values\n  ([4a65129](https://github.com/uptrace/bun/commit/4a651294fb0f1e73079553024810c3ead9777311))\n* don't automatically set pk, nullzero, and autoincrement options\n  ([519a0df](https://github.com/uptrace/bun/commit/519a0df9707de01a418aba0d6b7482cfe4c9a532))\n\n### Features\n\n- add CreateTableQuery.DetectForeignKeys\n  ([a958fcb](https://github.com/uptrace/bun/commit/a958fcbab680b0c5ad7980f369c7b73f7673db87))\n\n## [1.0.22](https://github.com/uptrace/bun/compare/v1.0.21...v1.0.22) (2022-01-28)\n\n### Bug Fixes\n\n- improve scan error message\n  ([54048b2](https://github.com/uptrace/bun/commit/54048b296b9648fd62107ce6fa6fd7e6e2a648c7))\n- properly discover json.Marshaler on ptr field\n  ([3b321b0](https://github.com/uptrace/bun/commit/3b321b08601c4b8dc6bcaa24adea20875883ac14))\n\n### Breaking (MySQL, MariaDB)\n\n- **insert:** get last insert id only with pk support auto increment\n  ([79e7c79](https://github.com/uptrace/bun/commit/79e7c797beea54bfc9dc1cb0141a7520ff941b4d)). Make\n  sure your MySQL models have `bun:\",pk,autoincrement\"` options if you are using autoincrements.\n\n### Features\n\n- refuse to start when version check does not pass\n  ([ff8d767](https://github.com/uptrace/bun/commit/ff8d76794894eeaebede840e5199720f3f5cf531))\n- support Column in ValuesQuery\n  ([0707679](https://github.com/uptrace/bun/commit/0707679b075cac57efa8e6fe9019b57b2da4bcc7))\n\n## [1.0.21](https://github.com/uptrace/bun/compare/v1.0.20...v1.0.21) (2022-01-06)\n\n### Bug Fixes\n\n- append where to index create\n  ([1de6cea](https://github.com/uptrace/bun/commit/1de6ceaa8bba59b69fbe0cc6916d1b27da5586d8))\n- check if slice is nil when calling BeforeAppendModel\n  ([938d9da](https://github.com/uptrace/bun/commit/938d9dadb72ceeeb906064d9575278929d20cbbe))\n- **dbfixture:** directly set matching types via reflect\n  ([780504c](https://github.com/uptrace/bun/commit/780504cf1da687fc51a22d002ea66e2ccc41e1a3))\n- properly handle driver.Valuer and type:json\n  ([a17454a](https://github.com/uptrace/bun/commit/a17454ac6b95b2a2e927d0c4e4aee96494108389))\n- support scanning string into uint64\n  ([73cc117](https://github.com/uptrace/bun/commit/73cc117a9f7a623ced1fdaedb4546e8e7470e4d3))\n- unique module name for opentelemetry example\n  ([f2054fe](https://github.com/uptrace/bun/commit/f2054fe1d11cea3b21d69dab6f6d6d7d97ba06bb))\n\n### Features\n\n- add anonymous fields with type name\n  ([508375b](https://github.com/uptrace/bun/commit/508375b8f2396cb088fd4399a9259584353eb7e5))\n- add baseQuery.GetConn()\n  ([81a9bee](https://github.com/uptrace/bun/commit/81a9beecb74fed7ec3574a1d42acdf10a74e0b00))\n- create new queries from baseQuery\n  ([ae1dd61](https://github.com/uptrace/bun/commit/ae1dd611a91c2b7c79bc2bc12e9a53e857791e71))\n- support INSERT ... RETURNING for MariaDB >= 10.5.0\n  ([b6531c0](https://github.com/uptrace/bun/commit/b6531c00ecbd4c7ec56b4131fab213f9313edc1b))\n\n## [1.0.20](https://github.com/uptrace/bun/compare/v1.0.19...v1.0.20) (2021-12-19)\n\n### Bug Fixes\n\n- add Event.QueryTemplate and change Event.Query to be always formatted\n  ([52b1ccd](https://github.com/uptrace/bun/commit/52b1ccdf3578418aa427adef9dcf942d90ae4fdd))\n- change GetTableName to return formatted table name in case ModelTableExpr\n  ([95144dd](https://github.com/uptrace/bun/commit/95144dde937b4ac88b36b0bd8b01372421069b44))\n- change ScanAndCount to work with transactions\n  ([5b3f2c0](https://github.com/uptrace/bun/commit/5b3f2c021c424da366caffd33589e8adde821403))\n- **dbfixture:** directly call funcs bypassing template eval\n  ([a61974b](https://github.com/uptrace/bun/commit/a61974ba2d24361c5357fb9bda1f3eceec5a45cd))\n- don't append CASCADE by default in drop table/column queries\n  ([26457ea](https://github.com/uptrace/bun/commit/26457ea5cb20862d232e6e5fa4dbdeac5d444bf1))\n- **migrate:** mark migrations as applied on error so the migration can be rolled back\n  ([8ce33fb](https://github.com/uptrace/bun/commit/8ce33fbbac8e33077c20daf19a14c5ff2291bcae))\n- respect nullzero when appending struct fields. Fixes\n  [#339](https://github.com/uptrace/bun/issues/339)\n  ([ffd02f3](https://github.com/uptrace/bun/commit/ffd02f3170b3cccdd670a48d563cfb41094c05d6))\n- reuse tx for relation join ([#366](https://github.com/uptrace/bun/issues/366))\n  ([60bdb1a](https://github.com/uptrace/bun/commit/60bdb1ac84c0a699429eead3b7fdfbf14fe69ac6))\n\n### Features\n\n- add `Dialect()` to Transaction and IDB interface\n  ([693f1e1](https://github.com/uptrace/bun/commit/693f1e135999fc31cf83b99a2530a695b20f4e1b))\n- add model embedding via embed:prefix\\_\n  ([9a2cedc](https://github.com/uptrace/bun/commit/9a2cedc8b08fa8585d4bfced338bd0a40d736b1d))\n- change the default log output to stderr\n  ([4bf5773](https://github.com/uptrace/bun/commit/4bf577382f19c64457cbf0d64490401450954654)),\n  closes [#349](https://github.com/uptrace/bun/issues/349)\n\n## [1.0.19](https://github.com/uptrace/bun/compare/v1.0.18...v1.0.19) (2021-11-30)\n\n### Features\n\n- add support for column:name to specify column name\n  ([e37b460](https://github.com/uptrace/bun/commit/e37b4602823babc8221970e086cfed90c6ad4cf4))\n\n## [1.0.18](https://github.com/uptrace/bun/compare/v1.0.17...v1.0.18) (2021-11-24)\n\n### Bug Fixes\n\n- use correct operation for UpdateQuery\n  ([687a004](https://github.com/uptrace/bun/commit/687a004ef7ec6fe1ef06c394965dd2c2d822fc82))\n\n### Features\n\n- add pgdriver.Notify\n  ([7ee443d](https://github.com/uptrace/bun/commit/7ee443d1b869d8ddc4746850f7425d0a9ccd012b))\n- CreateTableQuery.PartitionBy and CreateTableQuery.TableSpace\n  ([cd3ab4d](https://github.com/uptrace/bun/commit/cd3ab4d8f3682f5a30b87c2ebc2d7e551d739078))\n- **pgdriver:** add CopyFrom and CopyTo\n  ([0b97703](https://github.com/uptrace/bun/commit/0b977030b5c05f509e11d13550b5f99dfd62358d))\n- support InsertQuery.Ignore on PostgreSQL\n  ([1aa9d14](https://github.com/uptrace/bun/commit/1aa9d149da8e46e63ff79192e394fde4d18d9b60))\n\n## [1.0.17](https://github.com/uptrace/bun/compare/v1.0.16...v1.0.17) (2021-11-11)\n\n### Bug Fixes\n\n- don't call rollback when tx is already done\n  ([8246c2a](https://github.com/uptrace/bun/commit/8246c2a63e2e6eba314201c6ba87f094edf098b9))\n- **mysql:** escape backslash char in strings\n  ([fb32029](https://github.com/uptrace/bun/commit/fb32029ea7604d066800b16df21f239b71bf121d))\n\n## [1.0.16](https://github.com/uptrace/bun/compare/v1.0.15...v1.0.16) (2021-11-07)\n\n### Bug Fixes\n\n- call query hook when tx is started, committed, or rolled back\n  ([30e85b5](https://github.com/uptrace/bun/commit/30e85b5366b2e51951ef17a0cf362b58f708dab1))\n- **pgdialect:** auto-enable array support if the sql type is an array\n  ([62c1012](https://github.com/uptrace/bun/commit/62c1012b2482e83969e5c6f5faf89e655ce78138))\n\n### Features\n\n- support multiple tag options join:left_col1=right_col1,join:left_col2=right_col2\n  ([78cd5aa](https://github.com/uptrace/bun/commit/78cd5aa60a5c7d1323bb89081db2b2b811113052))\n- **tag:** log with bad tag name\n  ([4e82d75](https://github.com/uptrace/bun/commit/4e82d75be2dabdba1a510df4e1fbb86092f92f4c))\n\n## [1.0.15](https://github.com/uptrace/bun/compare/v1.0.14...v1.0.15) (2021-10-29)\n\n### Bug Fixes\n\n- fixed bug creating table when model has no columns\n  ([042c50b](https://github.com/uptrace/bun/commit/042c50bfe41caaa6e279e02c887c3a84a3acd84f))\n- init table with dialect once\n  ([9a1ce1e](https://github.com/uptrace/bun/commit/9a1ce1e492602742bb2f587e9ed24e50d7d07cad))\n\n### Features\n\n- accept columns in WherePK\n  ([b3e7035](https://github.com/uptrace/bun/commit/b3e70356db1aa4891115a10902316090fccbc8bf))\n- support ADD COLUMN IF NOT EXISTS\n  ([ca7357c](https://github.com/uptrace/bun/commit/ca7357cdfe283e2f0b94eb638372e18401c486e9))\n\n## [1.0.14](https://github.com/uptrace/bun/compare/v1.0.13...v1.0.14) (2021-10-24)\n\n### Bug Fixes\n\n- correct binary serialization for mysql ([#259](https://github.com/uptrace/bun/issues/259))\n  ([e899f50](https://github.com/uptrace/bun/commit/e899f50b22ef6759ef8c029a6cd3f25f2bde17ef))\n- correctly escape single quotes in pg arrays\n  ([3010847](https://github.com/uptrace/bun/commit/3010847f5c2c50bce1969689a0b77fd8a6fb7e55))\n- use BLOB sql type to encode []byte in MySQL and SQLite\n  ([725ec88](https://github.com/uptrace/bun/commit/725ec8843824a7fc8f4058ead75ab0e62a78192a))\n\n### Features\n\n- warn when there are args but no placeholders\n  ([06dde21](https://github.com/uptrace/bun/commit/06dde215c8d0bde2b2364597190729a160e536a1))\n\n## [1.0.13](https://github.com/uptrace/bun/compare/v1.0.12...v1.0.13) (2021-10-17)\n\n### Breaking Change\n\n- **pgdriver:** enable TLS by default with InsecureSkipVerify=true\n  ([15ec635](https://github.com/uptrace/bun/commit/15ec6356a04d5cf62d2efbeb189610532dc5eb31))\n\n### Features\n\n- add BeforeAppendModelHook\n  ([0b55de7](https://github.com/uptrace/bun/commit/0b55de77aaffc1ed0894ef16f45df77bca7d93c1))\n- **pgdriver:** add support for unix socket DSN\n  ([f398cec](https://github.com/uptrace/bun/commit/f398cec1c3873efdf61ac0b94ebe06c657f0cf91))\n\n## [1.0.12](https://github.com/uptrace/bun/compare/v1.0.11...v1.0.12) (2021-10-14)\n\n### Bug Fixes\n\n- add InsertQuery.ColumnExpr to specify columns\n  ([60ffe29](https://github.com/uptrace/bun/commit/60ffe293b37912d95f28e69734ff51edf4b27da7))\n- **bundebug:** change WithVerbose to accept a bool flag\n  ([b2f8b91](https://github.com/uptrace/bun/commit/b2f8b912de1dc29f40c79066de1e9d6379db666c))\n- **pgdialect:** fix bytea[] handling\n  ([a5ca013](https://github.com/uptrace/bun/commit/a5ca013742c5a2e947b43d13f9c2fc0cf6a65d9c))\n- **pgdriver:** rename DriverOption to Option\n  ([51c1702](https://github.com/uptrace/bun/commit/51c1702431787d7369904b2624e346bf3e59c330))\n- support allowzero on the soft delete field\n  ([d0abec7](https://github.com/uptrace/bun/commit/d0abec71a9a546472a83bd70ed4e6a7357659a9b))\n\n### Features\n\n- **bundebug:** allow to configure the hook using env var, for example, BUNDEBUG={0,1,2}\n  ([ce92852](https://github.com/uptrace/bun/commit/ce928524cab9a83395f3772ae9dd5d7732af281d))\n- **bunotel:** report DBStats metrics\n  ([b9b1575](https://github.com/uptrace/bun/commit/b9b15750f405cdbd345b776f5a56c6f742bc7361))\n- **pgdriver:** add Error.StatementTimeout\n  ([8a7934d](https://github.com/uptrace/bun/commit/8a7934dd788057828bb2b0983732b4394b74e960))\n- **pgdriver:** allow setting Network in config\n  ([b24b5d8](https://github.com/uptrace/bun/commit/b24b5d8014195a56ad7a4c634c10681038e6044d))\n\n## [1.0.11](https://github.com/uptrace/bun/compare/v1.0.10...v1.0.11) (2021-10-05)\n\n### Bug Fixes\n\n- **mysqldialect:** remove duplicate AppendTime\n  ([8d42090](https://github.com/uptrace/bun/commit/8d42090af34a1760004482c7fc0923b114d79937))\n\n## [1.0.10](https://github.com/uptrace/bun/compare/v1.0.9...v1.0.10) (2021-10-05)\n\n### Bug Fixes\n\n- add UpdateQuery.OmitZero\n  ([2294db6](https://github.com/uptrace/bun/commit/2294db61d228711435fff1075409a30086b37555))\n- make ExcludeColumn work with many-to-many queries\n  ([300e12b](https://github.com/uptrace/bun/commit/300e12b993554ff839ec4fa6bbea97e16aca1b55))\n- **mysqldialect:** append time in local timezone\n  ([e763cc8](https://github.com/uptrace/bun/commit/e763cc81eac4b11fff4e074ad3ff6cd970a71697))\n- **tagparser:** improve parsing options with brackets\n  ([0daa61e](https://github.com/uptrace/bun/commit/0daa61edc3c4d927ed260332b99ee09f4bb6b42f))\n\n### Features\n\n- add timetz parsing\n  ([6e415c4](https://github.com/uptrace/bun/commit/6e415c4c5fa2c8caf4bb4aed4e5897fe5676f5a5))\n\n## [1.0.9](https://github.com/uptrace/bun/compare/v1.0.8...v1.0.9) (2021-09-27)\n\n### Bug Fixes\n\n- change DBStats to use uint32 instead of uint64 to make it work on i386\n  ([caca2a7](https://github.com/uptrace/bun/commit/caca2a7130288dec49fa26b49c8550140ee52f4c))\n\n### Features\n\n- add IQuery and QueryEvent.IQuery\n  ([b762942](https://github.com/uptrace/bun/commit/b762942fa3b1d8686d0a559f93f2a6847b83d9c1))\n- add QueryEvent.Model\n  ([7688201](https://github.com/uptrace/bun/commit/7688201b485d14d3e393956f09a3200ea4d4e31d))\n- **bunotel:** add experimental bun.query.timing metric\n  ([2cdb384](https://github.com/uptrace/bun/commit/2cdb384678631ccadac0fb75f524bd5e91e96ee2))\n- **pgdriver:** add Config.ConnParams to session config params\n  ([408caf0](https://github.com/uptrace/bun/commit/408caf0bb579e23e26fc6149efd6851814c22517))\n- **pgdriver:** allow specifying timeout in DSN\n  ([7dbc71b](https://github.com/uptrace/bun/commit/7dbc71b3494caddc2e97d113f00067071b9e19da))\n\n## [1.0.8](https://github.com/uptrace/bun/compare/v1.0.7...v1.0.8) (2021-09-18)\n\n### Bug Fixes\n\n- don't append soft delete where for insert queries with on conflict clause\n  ([27c477c](https://github.com/uptrace/bun/commit/27c477ce071d4c49c99a2531d638ed9f20e33461))\n- improve bun.NullTime to accept string\n  ([73ad6f5](https://github.com/uptrace/bun/commit/73ad6f5640a0a9b09f8df2bc4ab9cb510021c50c))\n- make allowzero work with auto-detected primary keys\n  ([82ca87c](https://github.com/uptrace/bun/commit/82ca87c7c49797d507b31fdaacf8343716d4feff))\n- support soft deletes on nil model\n  ([0556e3c](https://github.com/uptrace/bun/commit/0556e3c63692a7f4e48659d52b55ffd9cca0202a))\n\n## [1.0.7](https://github.com/uptrace/bun/compare/v1.0.6...v1.0.7) (2021-09-15)\n\n### Bug Fixes\n\n- don't append zero time as NULL without nullzero tag\n  ([3b8d9cb](https://github.com/uptrace/bun/commit/3b8d9cb4e39eb17f79a618396bbbe0adbc66b07b))\n- **pgdriver:** return PostgreSQL DATE as a string\n  ([40be0e8](https://github.com/uptrace/bun/commit/40be0e8ea85f8932b7a410a6fc2dd3acd2d18ebc))\n- specify table alias for soft delete where\n  ([5fff1dc](https://github.com/uptrace/bun/commit/5fff1dc1dd74fa48623a24fa79e358a544dfac0b))\n\n### Features\n\n- add SelectQuery.Exists helper\n  ([c3e59c1](https://github.com/uptrace/bun/commit/c3e59c1bc58b43c4b8e33e7d170ad33a08fbc3c7))\n\n## [1.0.6](https://github.com/uptrace/bun/compare/v1.0.5...v1.0.6) (2021-09-11)\n\n### Bug Fixes\n\n- change unique tag to create a separate unique constraint\n  ([8401615](https://github.com/uptrace/bun/commit/84016155a77ca77613cc054277fefadae3098757))\n- improve zero checker for ptr values\n  ([2b3623d](https://github.com/uptrace/bun/commit/2b3623dd665d873911fd20ca707016929921e862))\n\n## v1.0.5 - Sep 09 2021\n\n- chore: tweak bundebug colors\n- fix: check if table is present when appending columns\n- fix: copy []byte when scanning\n\n## v1.0.4 - Sep 08 2021\n\n- Added support for MariaDB.\n- Restored default `SET` for `ON CONFLICT DO UPDATE` queries.\n\n## v1.0.3 - Sep 06 2021\n\n- Fixed bulk soft deletes.\n- pgdialect: fixed scanning into an array pointer.\n\n## v1.0.2 - Sep 04 2021\n\n- Changed to completely ignore fields marked with `bun:\"-\"`. If you want to be able to scan into\n  such columns, use `bun:\",scanonly\"`.\n- pgdriver: fixed SASL authentication handling.\n\n## v1.0.1 - Sep 02 2021\n\n- pgdriver: added erroneous zero writes retry.\n- Improved column handling in Relation callback.\n\n## v1.0.0 - Sep 01 2021\n\n- First stable release.\n\n## v0.4.1 - Aug 18 2021\n\n- Fixed migrate package to properly rollback migrations.\n- Added `allowzero` tag option that undoes `nullzero` option.\n\n## v0.4.0 - Aug 11 2021\n\n- Changed `WhereGroup` function to accept `*SelectQuery`.\n- Fixed query hooks for count queries.\n\n## v0.3.4 - Jul 19 2021\n\n- Renamed `migrate.CreateGo` to `CreateGoMigration`.\n- Added `migrate.WithPackageName` to customize the Go package name in generated migrations.\n- Renamed `migrate.CreateSQL` to `CreateSQLMigrations` and changed `CreateSQLMigrations` to create\n  both up and down migration files.\n\n## v0.3.1 - Jul 12 2021\n\n- Renamed `alias` field struct tag to `alt` so it is not confused with column alias.\n- Reworked migrate package API. See\n  [migrate](https://github.com/uptrace/bun/tree/master/example/migrate) example for details.\n\n## v0.3.0 - Jul 09 2021\n\n- Changed migrate package to return structured data instead of logging the progress. See\n  [migrate](https://github.com/uptrace/bun/tree/master/example/migrate) example for details.\n\n## v0.2.14 - Jul 01 2021\n\n- Added [sqliteshim](https://pkg.go.dev/github.com/uptrace/bun/driver/sqliteshim) by\n  [Ivan Trubach](https://github.com/tie).\n- Added support for MySQL 5.7 in addition to MySQL 8.\n\n## v0.2.12 - Jun 29 2021\n\n- Fixed scanners for net.IP and net.IPNet.\n\n## v0.2.10 - Jun 29 2021\n\n- Fixed pgdriver to format passed query args.\n\n## v0.2.9 - Jun 27 2021\n\n- Added support for prepared statements in pgdriver.\n\n## v0.2.7 - Jun 26 2021\n\n- Added `UpdateQuery.Bulk` helper to generate bulk-update queries.\n\n  Before:\n\n  ```go\n  models := []Model{\n  \t{42, \"hello\"},\n  \t{43, \"world\"},\n  }\n  return db.NewUpdate().\n  \tWith(\"_data\", db.NewValues(&models)).\n  \tModel(&models).\n  \tTable(\"_data\").\n  \tSet(\"model.str = _data.str\").\n  \tWhere(\"model.id = _data.id\")\n  ```\n\n  Now:\n\n  ```go\n  db.NewUpdate().\n  \tModel(&models).\n  \tBulk()\n  ```\n\n## v0.2.5 - Jun 25 2021\n\n- Changed time.Time to always append zero time as `NULL`.\n- Added `db.RunInTx` helper.\n\n## v0.2.4 - Jun 21 2021\n\n- Added SSL support to pgdriver.\n\n## v0.2.3 - Jun 20 2021\n\n- Replaced `ForceDelete(ctx)` with `ForceDelete().Exec(ctx)` for soft deletes.\n\n## v0.2.1 - Jun 17 2021\n\n- Renamed `DBI` to `IConn`. `IConn` is a common interface for `*sql.DB`, `*sql.Conn`, and `*sql.Tx`.\n- Added `IDB`. `IDB` is a common interface for `*bun.DB`, `bun.Conn`, and `bun.Tx`.\n\n## v0.2.0 - Jun 16 2021\n\n- Changed [model hooks](https://bun.uptrace.dev/guide/hooks.html#model-hooks). See\n  [model-hooks](example/model-hooks) example.\n- Renamed `has-one` to `belongs-to`. Renamed `belongs-to` to `has-one`. Previously Bun used\n  incorrect names for these relations.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.6611328125,
          "content": "## Running tests\n\nTo run tests, you need Docker which starts PostgreSQL and MySQL servers:\n\n```shell\ncd internal/dbtest\n./test.sh\n```\n\nTo ease debugging, you can run tests and print all executed queries:\n\n```shell\nBUNDEBUG=2 TZ= go test -run=TestName\n```\n\n## Releasing\n\n1. Run `release.sh` script which updates versions in go.mod files and pushes a new branch to GitHub:\n\n```shell\nTAG=v1.0.0 ./scripts/release.sh\n```\n\n2. Open a pull request and wait for the build to finish.\n\n3. Merge the pull request and run `tag.sh` to create tags for packages:\n\n```shell\nTAG=v1.0.0 ./scripts/tag.sh\n```\n\n## Documentation\n\nTo contribute to the docs visit https://github.com/uptrace/bun-docs\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.26953125,
          "content": "Copyright (c) 2021 Vladimir Mihailenco. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7353515625,
          "content": "ALL_GO_MOD_DIRS := $(shell find . -type f -name 'go.mod' -exec dirname {} \\; | sort)\nEXAMPLE_GO_MOD_DIRS := $(shell find ./example/ -type f -name 'go.mod' -exec dirname {} \\; | sort)\n\ntest:\n\tset -e; for dir in $(ALL_GO_MOD_DIRS); do \\\n\t  echo \"go test in $${dir}\"; \\\n\t  (cd \"$${dir}\" && \\\n\t    go test && \\\n\t    env GOOS=linux GOARCH=386 TZ= go test && \\\n\t    go vet); \\\n\tdone\n\ngo_mod_tidy:\n\tset -e; for dir in $(ALL_GO_MOD_DIRS); do \\\n\t  echo \"go mod tidy in $${dir}\"; \\\n\t  (cd \"$${dir}\" && \\\n\t    go get -u ./... && \\\n\t    go mod tidy); \\\n\tdone\n\nfmt:\n\tgofmt -w -s ./\n\tgoimports -w  -local github.com/uptrace/bun ./\n\nrun-examples:\n\tset -e; for dir in $(EXAMPLE_GO_MOD_DIRS); do \\\n\t  echo \"go run . in $${dir}\"; \\\n\t  (cd \"$${dir}\" && go run .); \\\n\tdone\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.599609375,
          "content": "# SQL-first Golang ORM for PostgreSQL, MySQL, MSSQL, SQLite and Oracle\n\n[![build workflow](https://github.com/uptrace/bun/actions/workflows/build.yml/badge.svg)](https://github.com/uptrace/bun/actions)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/uptrace/bun)](https://pkg.go.dev/github.com/uptrace/bun)\n[![Documentation](https://img.shields.io/badge/bun-documentation-informational)](https://bun.uptrace.dev/)\n[![Chat](https://discordapp.com/api/guilds/752070105847955518/widget.png)](https://discord.gg/rWtp5Aj)\n[![Gurubase](https://img.shields.io/badge/Gurubase-Ask%20Bun%20Guru-006BFF)](https://gurubase.io/g/bun)\n\n> Bun is brought to you by :star: [**uptrace/uptrace**](https://github.com/uptrace/uptrace). Uptrace\n> is an open-source APM tool that supports distributed tracing, metrics, and logs. You can use it to\n> monitor applications and set up automatic alerts to receive notifications via email, Slack,\n> Telegram, and others.\n>\n> See [OpenTelemetry](example/opentelemetry) example which demonstrates how you can use Uptrace to\n> monitor Bun.\n\n## Features\n\n- Works with [PostgreSQL](https://bun.uptrace.dev/guide/drivers.html#postgresql),\n  [MySQL](https://bun.uptrace.dev/guide/drivers.html#mysql) (including MariaDB),\n  [MSSQL](https://bun.uptrace.dev/guide/drivers.html#mssql),\n  [SQLite](https://bun.uptrace.dev/guide/drivers.html#sqlite).\n  [Oracle](https://bun.uptrace.dev/guide/drivers.html#oracle).\n- [ORM-like](/example/basic/) experience using good old SQL. Bun supports structs, map, scalars, and\n  slices of map/structs/scalars.\n- [Bulk inserts](https://bun.uptrace.dev/guide/query-insert.html).\n- [Bulk updates](https://bun.uptrace.dev/guide/query-update.html) using common table expressions.\n- [Bulk deletes](https://bun.uptrace.dev/guide/query-delete.html).\n- [Fixtures](https://bun.uptrace.dev/guide/fixtures.html).\n- [Migrations](https://bun.uptrace.dev/guide/migrations.html).\n- [Soft deletes](https://bun.uptrace.dev/guide/soft-deletes.html).\n\n### Resources\n\n- [**Get started**](https://bun.uptrace.dev/guide/golang-orm.html)\n- [Examples](https://github.com/uptrace/bun/tree/master/example)\n- [Discussions](https://github.com/uptrace/bun/discussions)\n- [Chat](https://discord.gg/rWtp5Aj)\n- [Reference](https://pkg.go.dev/github.com/uptrace/bun)\n- [Starter kit](https://github.com/go-bun/bun-starter-kit)\n\n### Tutorials\n\nWrote a tutorial for Bun? Create a PR to add here and on [Bun](https://bun.uptrace.dev/) site.\n\n### Featured projects using Bun\n\n- [uptrace](https://github.com/uptrace/uptrace) - Distributed tracing and metrics.\n- [paralus](https://github.com/paralus/paralus) - All-in-one Kubernetes access manager.\n- [inovex/scrumlr.io](https://github.com/inovex/scrumlr.io) - Webapp for collaborative online\n  retrospectives.\n- [gotosocial](https://github.com/superseriousbusiness/gotosocial) - Golang fediverse server.\n- [lorawan-stack](https://github.com/TheThingsNetwork/lorawan-stack) - The Things Stack, an Open\n  Source LoRaWAN Network Server.\n- [anti-phishing-bot](https://github.com/Benricheson101/anti-phishing-bot) - Discord bot for\n  deleting Steam/Discord phishing links.\n- [emerald-web3-gateway](https://github.com/oasisprotocol/emerald-web3-gateway) - Web3 Gateway for\n  the Oasis Emerald paratime.\n- [lndhub.go](https://github.com/getAlby/lndhub.go) - accounting wrapper for the Lightning Network.\n- [penguin-statistics](https://github.com/penguin-statistics/backend-next) - Penguin Statistics v3\n  Backend.\n- And\n  [hundreds more](https://github.com/uptrace/bun/network/dependents?package_id=UGFja2FnZS0yMjkxOTc4OTA4).\n\n## Why another database client?\n\nSo you can elegantly write complex queries:\n\n```go\nregionalSales := db.NewSelect().\n\tColumnExpr(\"region\").\n\tColumnExpr(\"SUM(amount) AS total_sales\").\n\tTableExpr(\"orders\").\n\tGroupExpr(\"region\")\n\ntopRegions := db.NewSelect().\n\tColumnExpr(\"region\").\n\tTableExpr(\"regional_sales\").\n\tWhere(\"total_sales > (SELECT SUM(total_sales) / 10 FROM regional_sales)\")\n\nvar items []map[string]interface{}\nerr := db.NewSelect().\n\tWith(\"regional_sales\", regionalSales).\n\tWith(\"top_regions\", topRegions).\n\tColumnExpr(\"region\").\n\tColumnExpr(\"product\").\n\tColumnExpr(\"SUM(quantity) AS product_units\").\n\tColumnExpr(\"SUM(amount) AS product_sales\").\n\tTableExpr(\"orders\").\n\tWhere(\"region IN (SELECT region FROM top_regions)\").\n\tGroupExpr(\"region\").\n\tGroupExpr(\"product\").\n\tScan(ctx, &items)\n```\n\n```sql\nWITH regional_sales AS (\n    SELECT region, SUM(amount) AS total_sales\n    FROM orders\n    GROUP BY region\n), top_regions AS (\n    SELECT region\n    FROM regional_sales\n    WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)\n)\nSELECT region,\n       product,\n       SUM(quantity) AS product_units,\n       SUM(amount) AS product_sales\nFROM orders\nWHERE region IN (SELECT region FROM top_regions)\nGROUP BY region, product\n```\n\nAnd scan results into scalars, structs, maps, slices of structs/maps/scalars:\n\n```go\nusers := make([]User, 0)\nif err := db.NewSelect().Model(&users).OrderExpr(\"id ASC\").Scan(ctx); err != nil {\n\tpanic(err)\n}\n\nuser1 := new(User)\nif err := db.NewSelect().Model(user1).Where(\"id = ?\", 1).Scan(ctx); err != nil {\n\tpanic(err)\n}\n```\n\nSee [**Getting started**](https://bun.uptrace.dev/guide/golang-orm.html) guide and check\n[examples](example).\n\n## See also\n\n- [Golang HTTP router](https://github.com/uptrace/bunrouter)\n- [Golang ClickHouse ORM](https://github.com/uptrace/go-clickhouse)\n- [Golang msgpack](https://github.com/vmihailenco/msgpack)\n\n## Contributing\n\nSee [CONTRIBUTING.md](CONTRIBUTING.md) for some hints.\n\nAnd thanks to all the people who already contributed!\n\n<a href=\"https://github.com/uptrace/bun/graphs/contributors\">\n  <img src=\"https://contributors-img.web.app/image?repo=uptrace/bun\" />\n</a>\n"
        },
        {
          "name": "bun.go",
          "type": "blob",
          "size": 1.974609375,
          "content": "package bun\n\nimport (\n\t\"context\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype (\n\tSafe  = schema.Safe\n\tIdent = schema.Ident\n\tName  = schema.Name\n\n\tNullTime  = schema.NullTime\n\tBaseModel = schema.BaseModel\n\tQuery     = schema.Query\n\n\tBeforeAppendModelHook = schema.BeforeAppendModelHook\n\n\tBeforeScanRowHook = schema.BeforeScanRowHook\n\tAfterScanRowHook  = schema.AfterScanRowHook\n)\n\nfunc SafeQuery(query string, args ...interface{}) schema.QueryWithArgs {\n\treturn schema.SafeQuery(query, args)\n}\n\ntype BeforeSelectHook interface {\n\tBeforeSelect(ctx context.Context, query *SelectQuery) error\n}\n\ntype AfterSelectHook interface {\n\tAfterSelect(ctx context.Context, query *SelectQuery) error\n}\n\ntype BeforeInsertHook interface {\n\tBeforeInsert(ctx context.Context, query *InsertQuery) error\n}\n\ntype AfterInsertHook interface {\n\tAfterInsert(ctx context.Context, query *InsertQuery) error\n}\n\ntype BeforeUpdateHook interface {\n\tBeforeUpdate(ctx context.Context, query *UpdateQuery) error\n}\n\ntype AfterUpdateHook interface {\n\tAfterUpdate(ctx context.Context, query *UpdateQuery) error\n}\n\ntype BeforeDeleteHook interface {\n\tBeforeDelete(ctx context.Context, query *DeleteQuery) error\n}\n\ntype AfterDeleteHook interface {\n\tAfterDelete(ctx context.Context, query *DeleteQuery) error\n}\n\ntype BeforeCreateTableHook interface {\n\tBeforeCreateTable(ctx context.Context, query *CreateTableQuery) error\n}\n\ntype AfterCreateTableHook interface {\n\tAfterCreateTable(ctx context.Context, query *CreateTableQuery) error\n}\n\ntype BeforeDropTableHook interface {\n\tBeforeDropTable(ctx context.Context, query *DropTableQuery) error\n}\n\ntype AfterDropTableHook interface {\n\tAfterDropTable(ctx context.Context, query *DropTableQuery) error\n}\n\n// SetLogger overwrites default Bun logger.\nfunc SetLogger(logger internal.Logging) {\n\tinternal.SetLogger(logger)\n}\n\nfunc In(slice interface{}) schema.QueryAppender {\n\treturn schema.In(slice)\n}\n\nfunc NullZero(value interface{}) schema.QueryAppender {\n\treturn schema.NullZero(value)\n}\n"
        },
        {
          "name": "commitlint.config.js",
          "type": "blob",
          "size": 0.064453125,
          "content": "module.exports = { extends: ['@commitlint/config-conventional'] }\n"
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 15.9716796875,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"database/sql\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync/atomic\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\nconst (\n\tdiscardUnknownColumns internal.Flag = 1 << iota\n)\n\ntype DBStats struct {\n\tQueries uint32\n\tErrors  uint32\n}\n\ntype DBOption func(db *DB)\n\nfunc WithDiscardUnknownColumns() DBOption {\n\treturn func(db *DB) {\n\t\tdb.flags = db.flags.Set(discardUnknownColumns)\n\t}\n}\n\ntype DB struct {\n\t*sql.DB\n\n\tdialect schema.Dialect\n\n\tqueryHooks []QueryHook\n\n\tfmter schema.Formatter\n\tflags internal.Flag\n\n\tstats DBStats\n}\n\nfunc NewDB(sqldb *sql.DB, dialect schema.Dialect, opts ...DBOption) *DB {\n\tdialect.Init(sqldb)\n\n\tdb := &DB{\n\t\tDB:      sqldb,\n\t\tdialect: dialect,\n\t\tfmter:   schema.NewFormatter(dialect),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(db)\n\t}\n\n\treturn db\n}\n\nfunc (db *DB) String() string {\n\tvar b strings.Builder\n\tb.WriteString(\"DB<dialect=\")\n\tb.WriteString(db.dialect.Name().String())\n\tb.WriteString(\">\")\n\treturn b.String()\n}\n\nfunc (db *DB) DBStats() DBStats {\n\treturn DBStats{\n\t\tQueries: atomic.LoadUint32(&db.stats.Queries),\n\t\tErrors:  atomic.LoadUint32(&db.stats.Errors),\n\t}\n}\n\nfunc (db *DB) NewValues(model interface{}) *ValuesQuery {\n\treturn NewValuesQuery(db, model)\n}\n\nfunc (db *DB) NewMerge() *MergeQuery {\n\treturn NewMergeQuery(db)\n}\n\nfunc (db *DB) NewSelect() *SelectQuery {\n\treturn NewSelectQuery(db)\n}\n\nfunc (db *DB) NewInsert() *InsertQuery {\n\treturn NewInsertQuery(db)\n}\n\nfunc (db *DB) NewUpdate() *UpdateQuery {\n\treturn NewUpdateQuery(db)\n}\n\nfunc (db *DB) NewDelete() *DeleteQuery {\n\treturn NewDeleteQuery(db)\n}\n\nfunc (db *DB) NewRaw(query string, args ...interface{}) *RawQuery {\n\treturn NewRawQuery(db, query, args...)\n}\n\nfunc (db *DB) NewCreateTable() *CreateTableQuery {\n\treturn NewCreateTableQuery(db)\n}\n\nfunc (db *DB) NewDropTable() *DropTableQuery {\n\treturn NewDropTableQuery(db)\n}\n\nfunc (db *DB) NewCreateIndex() *CreateIndexQuery {\n\treturn NewCreateIndexQuery(db)\n}\n\nfunc (db *DB) NewDropIndex() *DropIndexQuery {\n\treturn NewDropIndexQuery(db)\n}\n\nfunc (db *DB) NewTruncateTable() *TruncateTableQuery {\n\treturn NewTruncateTableQuery(db)\n}\n\nfunc (db *DB) NewAddColumn() *AddColumnQuery {\n\treturn NewAddColumnQuery(db)\n}\n\nfunc (db *DB) NewDropColumn() *DropColumnQuery {\n\treturn NewDropColumnQuery(db)\n}\n\nfunc (db *DB) ResetModel(ctx context.Context, models ...interface{}) error {\n\tfor _, model := range models {\n\t\tif _, err := db.NewDropTable().Model(model).IfExists().Cascade().Exec(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := db.NewCreateTable().Model(model).Exec(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (db *DB) Dialect() schema.Dialect {\n\treturn db.dialect\n}\n\nfunc (db *DB) ScanRows(ctx context.Context, rows *sql.Rows, dest ...interface{}) error {\n\tdefer rows.Close()\n\n\tmodel, err := newModel(db, dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = model.ScanRows(ctx, rows)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn rows.Err()\n}\n\nfunc (db *DB) ScanRow(ctx context.Context, rows *sql.Rows, dest ...interface{}) error {\n\tmodel, err := newModel(db, dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trs, ok := model.(rowScanner)\n\tif !ok {\n\t\treturn fmt.Errorf(\"bun: %T does not support ScanRow\", model)\n\t}\n\n\treturn rs.ScanRow(ctx, rows)\n}\n\ntype queryHookIniter interface {\n\tInit(db *DB)\n}\n\nfunc (db *DB) AddQueryHook(hook QueryHook) {\n\tif initer, ok := hook.(queryHookIniter); ok {\n\t\tiniter.Init(db)\n\t}\n\tdb.queryHooks = append(db.queryHooks, hook)\n}\n\nfunc (db *DB) Table(typ reflect.Type) *schema.Table {\n\treturn db.dialect.Tables().Get(typ)\n}\n\n// RegisterModel registers models by name so they can be referenced in table relations\n// and fixtures.\nfunc (db *DB) RegisterModel(models ...interface{}) {\n\tdb.dialect.Tables().Register(models...)\n}\n\nfunc (db *DB) clone() *DB {\n\tclone := *db\n\n\tl := len(clone.queryHooks)\n\tclone.queryHooks = clone.queryHooks[:l:l]\n\n\treturn &clone\n}\n\nfunc (db *DB) WithNamedArg(name string, value interface{}) *DB {\n\tclone := db.clone()\n\tclone.fmter = clone.fmter.WithNamedArg(name, value)\n\treturn clone\n}\n\nfunc (db *DB) Formatter() schema.Formatter {\n\treturn db.fmter\n}\n\n// UpdateFQN returns a fully qualified column name. For MySQL, it returns the column name with\n// the table alias. For other RDBMS, it returns just the column name.\nfunc (db *DB) UpdateFQN(alias, column string) Ident {\n\tif db.HasFeature(feature.UpdateMultiTable) {\n\t\treturn Ident(alias + \".\" + column)\n\t}\n\treturn Ident(column)\n}\n\n// HasFeature uses feature package to report whether the underlying DBMS supports this feature.\nfunc (db *DB) HasFeature(feat feature.Feature) bool {\n\treturn db.dialect.Features().Has(feat)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (db *DB) Exec(query string, args ...interface{}) (sql.Result, error) {\n\treturn db.ExecContext(context.Background(), query, args...)\n}\n\nfunc (db *DB) ExecContext(\n\tctx context.Context, query string, args ...interface{},\n) (sql.Result, error) {\n\tformattedQuery := db.format(query, args)\n\tctx, event := db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\tres, err := db.DB.ExecContext(ctx, formattedQuery)\n\tdb.afterQuery(ctx, event, res, err)\n\treturn res, err\n}\n\nfunc (db *DB) Query(query string, args ...interface{}) (*sql.Rows, error) {\n\treturn db.QueryContext(context.Background(), query, args...)\n}\n\nfunc (db *DB) QueryContext(\n\tctx context.Context, query string, args ...interface{},\n) (*sql.Rows, error) {\n\tformattedQuery := db.format(query, args)\n\tctx, event := db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\trows, err := db.DB.QueryContext(ctx, formattedQuery)\n\tdb.afterQuery(ctx, event, nil, err)\n\treturn rows, err\n}\n\nfunc (db *DB) QueryRow(query string, args ...interface{}) *sql.Row {\n\treturn db.QueryRowContext(context.Background(), query, args...)\n}\n\nfunc (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\tformattedQuery := db.format(query, args)\n\tctx, event := db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\trow := db.DB.QueryRowContext(ctx, formattedQuery)\n\tdb.afterQuery(ctx, event, nil, row.Err())\n\treturn row\n}\n\nfunc (db *DB) format(query string, args []interface{}) string {\n\treturn db.fmter.FormatQuery(query, args...)\n}\n\n//------------------------------------------------------------------------------\n\ntype Conn struct {\n\tdb *DB\n\t*sql.Conn\n}\n\nfunc (db *DB) Conn(ctx context.Context) (Conn, error) {\n\tconn, err := db.DB.Conn(ctx)\n\tif err != nil {\n\t\treturn Conn{}, err\n\t}\n\treturn Conn{\n\t\tdb:   db,\n\t\tConn: conn,\n\t}, nil\n}\n\nfunc (c Conn) ExecContext(\n\tctx context.Context, query string, args ...interface{},\n) (sql.Result, error) {\n\tformattedQuery := c.db.format(query, args)\n\tctx, event := c.db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\tres, err := c.Conn.ExecContext(ctx, formattedQuery)\n\tc.db.afterQuery(ctx, event, res, err)\n\treturn res, err\n}\n\nfunc (c Conn) QueryContext(\n\tctx context.Context, query string, args ...interface{},\n) (*sql.Rows, error) {\n\tformattedQuery := c.db.format(query, args)\n\tctx, event := c.db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\trows, err := c.Conn.QueryContext(ctx, formattedQuery)\n\tc.db.afterQuery(ctx, event, nil, err)\n\treturn rows, err\n}\n\nfunc (c Conn) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\tformattedQuery := c.db.format(query, args)\n\tctx, event := c.db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\trow := c.Conn.QueryRowContext(ctx, formattedQuery)\n\tc.db.afterQuery(ctx, event, nil, row.Err())\n\treturn row\n}\n\nfunc (c Conn) Dialect() schema.Dialect {\n\treturn c.db.Dialect()\n}\n\nfunc (c Conn) NewValues(model interface{}) *ValuesQuery {\n\treturn NewValuesQuery(c.db, model).Conn(c)\n}\n\nfunc (c Conn) NewMerge() *MergeQuery {\n\treturn NewMergeQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewSelect() *SelectQuery {\n\treturn NewSelectQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewInsert() *InsertQuery {\n\treturn NewInsertQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewUpdate() *UpdateQuery {\n\treturn NewUpdateQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewDelete() *DeleteQuery {\n\treturn NewDeleteQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewRaw(query string, args ...interface{}) *RawQuery {\n\treturn NewRawQuery(c.db, query, args...).Conn(c)\n}\n\nfunc (c Conn) NewCreateTable() *CreateTableQuery {\n\treturn NewCreateTableQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewDropTable() *DropTableQuery {\n\treturn NewDropTableQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewCreateIndex() *CreateIndexQuery {\n\treturn NewCreateIndexQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewDropIndex() *DropIndexQuery {\n\treturn NewDropIndexQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewTruncateTable() *TruncateTableQuery {\n\treturn NewTruncateTableQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewAddColumn() *AddColumnQuery {\n\treturn NewAddColumnQuery(c.db).Conn(c)\n}\n\nfunc (c Conn) NewDropColumn() *DropColumnQuery {\n\treturn NewDropColumnQuery(c.db).Conn(c)\n}\n\n// RunInTx runs the function in a transaction. If the function returns an error,\n// the transaction is rolled back. Otherwise, the transaction is committed.\nfunc (c Conn) RunInTx(\n\tctx context.Context, opts *sql.TxOptions, fn func(ctx context.Context, tx Tx) error,\n) error {\n\ttx, err := c.BeginTx(ctx, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar done bool\n\n\tdefer func() {\n\t\tif !done {\n\t\t\t_ = tx.Rollback()\n\t\t}\n\t}()\n\n\tif err := fn(ctx, tx); err != nil {\n\t\treturn err\n\t}\n\n\tdone = true\n\treturn tx.Commit()\n}\n\nfunc (c Conn) BeginTx(ctx context.Context, opts *sql.TxOptions) (Tx, error) {\n\tctx, event := c.db.beforeQuery(ctx, nil, \"BEGIN\", nil, \"BEGIN\", nil)\n\ttx, err := c.Conn.BeginTx(ctx, opts)\n\tc.db.afterQuery(ctx, event, nil, err)\n\tif err != nil {\n\t\treturn Tx{}, err\n\t}\n\treturn Tx{\n\t\tctx: ctx,\n\t\tdb:  c.db,\n\t\tTx:  tx,\n\t}, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype Stmt struct {\n\t*sql.Stmt\n}\n\nfunc (db *DB) Prepare(query string) (Stmt, error) {\n\treturn db.PrepareContext(context.Background(), query)\n}\n\nfunc (db *DB) PrepareContext(ctx context.Context, query string) (Stmt, error) {\n\tstmt, err := db.DB.PrepareContext(ctx, query)\n\tif err != nil {\n\t\treturn Stmt{}, err\n\t}\n\treturn Stmt{Stmt: stmt}, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype Tx struct {\n\tctx context.Context\n\tdb  *DB\n\t// name is the name of a savepoint\n\tname string\n\t*sql.Tx\n}\n\n// RunInTx runs the function in a transaction. If the function returns an error,\n// the transaction is rolled back. Otherwise, the transaction is committed.\nfunc (db *DB) RunInTx(\n\tctx context.Context, opts *sql.TxOptions, fn func(ctx context.Context, tx Tx) error,\n) error {\n\ttx, err := db.BeginTx(ctx, opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar done bool\n\n\tdefer func() {\n\t\tif !done {\n\t\t\t_ = tx.Rollback()\n\t\t}\n\t}()\n\n\tif err := fn(ctx, tx); err != nil {\n\t\treturn err\n\t}\n\n\tdone = true\n\treturn tx.Commit()\n}\n\nfunc (db *DB) Begin() (Tx, error) {\n\treturn db.BeginTx(context.Background(), nil)\n}\n\nfunc (db *DB) BeginTx(ctx context.Context, opts *sql.TxOptions) (Tx, error) {\n\tctx, event := db.beforeQuery(ctx, nil, \"BEGIN\", nil, \"BEGIN\", nil)\n\ttx, err := db.DB.BeginTx(ctx, opts)\n\tdb.afterQuery(ctx, event, nil, err)\n\tif err != nil {\n\t\treturn Tx{}, err\n\t}\n\treturn Tx{\n\t\tctx: ctx,\n\t\tdb:  db,\n\t\tTx:  tx,\n\t}, nil\n}\n\nfunc (tx Tx) Commit() error {\n\tif tx.name == \"\" {\n\t\treturn tx.commitTX()\n\t}\n\treturn tx.commitSP()\n}\n\nfunc (tx Tx) commitTX() error {\n\tctx, event := tx.db.beforeQuery(tx.ctx, nil, \"COMMIT\", nil, \"COMMIT\", nil)\n\terr := tx.Tx.Commit()\n\ttx.db.afterQuery(ctx, event, nil, err)\n\treturn err\n}\n\nfunc (tx Tx) commitSP() error {\n\tif tx.db.HasFeature(feature.MSSavepoint) {\n\t\treturn nil\n\t}\n\tquery := \"RELEASE SAVEPOINT \" + tx.name\n\t_, err := tx.ExecContext(tx.ctx, query)\n\treturn err\n}\n\nfunc (tx Tx) Rollback() error {\n\tif tx.name == \"\" {\n\t\treturn tx.rollbackTX()\n\t}\n\treturn tx.rollbackSP()\n}\n\nfunc (tx Tx) rollbackTX() error {\n\tctx, event := tx.db.beforeQuery(tx.ctx, nil, \"ROLLBACK\", nil, \"ROLLBACK\", nil)\n\terr := tx.Tx.Rollback()\n\ttx.db.afterQuery(ctx, event, nil, err)\n\treturn err\n}\n\nfunc (tx Tx) rollbackSP() error {\n\tquery := \"ROLLBACK TO SAVEPOINT \" + tx.name\n\tif tx.db.HasFeature(feature.MSSavepoint) {\n\t\tquery = \"ROLLBACK TRANSACTION \" + tx.name\n\t}\n\t_, err := tx.ExecContext(tx.ctx, query)\n\treturn err\n}\n\nfunc (tx Tx) Exec(query string, args ...interface{}) (sql.Result, error) {\n\treturn tx.ExecContext(context.TODO(), query, args...)\n}\n\nfunc (tx Tx) ExecContext(\n\tctx context.Context, query string, args ...interface{},\n) (sql.Result, error) {\n\tformattedQuery := tx.db.format(query, args)\n\tctx, event := tx.db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\tres, err := tx.Tx.ExecContext(ctx, formattedQuery)\n\ttx.db.afterQuery(ctx, event, res, err)\n\treturn res, err\n}\n\nfunc (tx Tx) Query(query string, args ...interface{}) (*sql.Rows, error) {\n\treturn tx.QueryContext(context.TODO(), query, args...)\n}\n\nfunc (tx Tx) QueryContext(\n\tctx context.Context, query string, args ...interface{},\n) (*sql.Rows, error) {\n\tformattedQuery := tx.db.format(query, args)\n\tctx, event := tx.db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\trows, err := tx.Tx.QueryContext(ctx, formattedQuery)\n\ttx.db.afterQuery(ctx, event, nil, err)\n\treturn rows, err\n}\n\nfunc (tx Tx) QueryRow(query string, args ...interface{}) *sql.Row {\n\treturn tx.QueryRowContext(context.TODO(), query, args...)\n}\n\nfunc (tx Tx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\tformattedQuery := tx.db.format(query, args)\n\tctx, event := tx.db.beforeQuery(ctx, nil, query, args, formattedQuery, nil)\n\trow := tx.Tx.QueryRowContext(ctx, formattedQuery)\n\ttx.db.afterQuery(ctx, event, nil, row.Err())\n\treturn row\n}\n\n//------------------------------------------------------------------------------\n\nfunc (tx Tx) Begin() (Tx, error) {\n\treturn tx.BeginTx(tx.ctx, nil)\n}\n\n// BeginTx will save a point in the running transaction.\nfunc (tx Tx) BeginTx(ctx context.Context, _ *sql.TxOptions) (Tx, error) {\n\t// mssql savepoint names are limited to 32 characters\n\tsp := make([]byte, 14)\n\t_, err := rand.Read(sp)\n\tif err != nil {\n\t\treturn Tx{}, err\n\t}\n\n\tqName := \"SP_\" + hex.EncodeToString(sp)\n\tquery := \"SAVEPOINT \" + qName\n\tif tx.db.HasFeature(feature.MSSavepoint) {\n\t\tquery = \"SAVE TRANSACTION \" + qName\n\t}\n\t_, err = tx.ExecContext(ctx, query)\n\tif err != nil {\n\t\treturn Tx{}, err\n\t}\n\treturn Tx{\n\t\tctx:  ctx,\n\t\tdb:   tx.db,\n\t\tTx:   tx.Tx,\n\t\tname: qName,\n\t}, nil\n}\n\nfunc (tx Tx) RunInTx(\n\tctx context.Context, _ *sql.TxOptions, fn func(ctx context.Context, tx Tx) error,\n) error {\n\tsp, err := tx.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar done bool\n\n\tdefer func() {\n\t\tif !done {\n\t\t\t_ = sp.Rollback()\n\t\t}\n\t}()\n\n\tif err := fn(ctx, sp); err != nil {\n\t\treturn err\n\t}\n\n\tdone = true\n\treturn sp.Commit()\n}\n\nfunc (tx Tx) Dialect() schema.Dialect {\n\treturn tx.db.Dialect()\n}\n\nfunc (tx Tx) NewValues(model interface{}) *ValuesQuery {\n\treturn NewValuesQuery(tx.db, model).Conn(tx)\n}\n\nfunc (tx Tx) NewMerge() *MergeQuery {\n\treturn NewMergeQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewSelect() *SelectQuery {\n\treturn NewSelectQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewInsert() *InsertQuery {\n\treturn NewInsertQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewUpdate() *UpdateQuery {\n\treturn NewUpdateQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewDelete() *DeleteQuery {\n\treturn NewDeleteQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewRaw(query string, args ...interface{}) *RawQuery {\n\treturn NewRawQuery(tx.db, query, args...).Conn(tx)\n}\n\nfunc (tx Tx) NewCreateTable() *CreateTableQuery {\n\treturn NewCreateTableQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewDropTable() *DropTableQuery {\n\treturn NewDropTableQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewCreateIndex() *CreateIndexQuery {\n\treturn NewCreateIndexQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewDropIndex() *DropIndexQuery {\n\treturn NewDropIndexQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewTruncateTable() *TruncateTableQuery {\n\treturn NewTruncateTableQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewAddColumn() *AddColumnQuery {\n\treturn NewAddColumnQuery(tx.db).Conn(tx)\n}\n\nfunc (tx Tx) NewDropColumn() *DropColumnQuery {\n\treturn NewDropColumnQuery(tx.db).Conn(tx)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (db *DB) makeQueryBytes() []byte {\n\treturn internal.MakeQueryBytes()\n}\n"
        },
        {
          "name": "dbfixture",
          "type": "tree",
          "content": null
        },
        {
          "name": "dialect",
          "type": "tree",
          "content": null
        },
        {
          "name": "driver",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.7626953125,
          "content": "module github.com/uptrace/bun\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/jinzhu/inflection v1.0.0\n\tgithub.com/puzpuzpuz/xsync/v3 v3.4.0\n\tgithub.com/rs/zerolog v1.33.0\n\tgithub.com/stretchr/testify v1.8.1\n\tgithub.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc\n\tgithub.com/vmihailenco/msgpack/v5 v5.4.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/vmihailenco/tagparser/v2 v2.0.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.3955078125,
          "content": "github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=\ngithub.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/puzpuzpuz/xsync/v3 v3.4.0 h1:DuVBAdXuGFHv8adVXjWWZ63pJq+NRXOWVXlKDBZ+mJ4=\ngithub.com/puzpuzpuz/xsync/v3 v3.4.0/go.mod h1:VjzYrABPabuM4KyBh1Ftq6u8nhwY5tBPKP9jpmh0nnA=\ngithub.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=\ngithub.com/rs/zerolog v1.33.0 h1:1cU2KZkvPxNyfgEmhHAz/1A9Bz+llsdYzklWFzgp0r8=\ngithub.com/rs/zerolog v1.33.0/go.mod h1:/7mN4D5sKwJLZQ2b/znpjC3/GQWY/xaDXUM0kKWRHss=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc h1:9lRDQMhESg+zvGYmW5DyG0UqvY96Bu5QYsTLvCHdrgo=\ngithub.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc/go.mod h1:bciPuU6GHm1iF1pBvUfxfsH0Wmnc2VbpgvbI9ZWuIRs=\ngithub.com/vmihailenco/msgpack/v5 v5.4.1 h1:cQriyiUvjTwOHg8QZaPihLWeRAAVoCpE00IUPn0Bjt8=\ngithub.com/vmihailenco/msgpack/v5 v5.4.1/go.mod h1:GaZTsDaehaPpQVyxrf5mtQlH+pc21PIudVV/E3rRQok=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "hook.go",
          "type": "blob",
          "size": 2.0341796875,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\t\"unicode\"\n\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype QueryEvent struct {\n\tDB *DB\n\n\tQueryAppender schema.QueryAppender // DEPRECATED: use IQuery instead\n\tIQuery        Query\n\tQuery         string\n\tQueryTemplate string\n\tQueryArgs     []interface{}\n\tModel         Model\n\n\tStartTime time.Time\n\tResult    sql.Result\n\tErr       error\n\n\tStash map[interface{}]interface{}\n}\n\nfunc (e *QueryEvent) Operation() string {\n\tif e.IQuery != nil {\n\t\treturn e.IQuery.Operation()\n\t}\n\treturn queryOperation(e.Query)\n}\n\nfunc queryOperation(query string) string {\n\tqueryOp := strings.TrimLeftFunc(query, unicode.IsSpace)\n\n\tif idx := strings.IndexByte(queryOp, ' '); idx > 0 {\n\t\tqueryOp = queryOp[:idx]\n\t}\n\tif len(queryOp) > 16 {\n\t\tqueryOp = queryOp[:16]\n\t}\n\treturn queryOp\n}\n\ntype QueryHook interface {\n\tBeforeQuery(context.Context, *QueryEvent) context.Context\n\tAfterQuery(context.Context, *QueryEvent)\n}\n\nfunc (db *DB) beforeQuery(\n\tctx context.Context,\n\tiquery Query,\n\tqueryTemplate string,\n\tqueryArgs []interface{},\n\tquery string,\n\tmodel Model,\n) (context.Context, *QueryEvent) {\n\tatomic.AddUint32(&db.stats.Queries, 1)\n\n\tif len(db.queryHooks) == 0 {\n\t\treturn ctx, nil\n\t}\n\n\tevent := &QueryEvent{\n\t\tDB: db,\n\n\t\tModel:         model,\n\t\tQueryAppender: iquery,\n\t\tIQuery:        iquery,\n\t\tQuery:         query,\n\t\tQueryTemplate: queryTemplate,\n\t\tQueryArgs:     queryArgs,\n\n\t\tStartTime: time.Now(),\n\t}\n\n\tfor _, hook := range db.queryHooks {\n\t\tctx = hook.BeforeQuery(ctx, event)\n\t}\n\n\treturn ctx, event\n}\n\nfunc (db *DB) afterQuery(\n\tctx context.Context,\n\tevent *QueryEvent,\n\tres sql.Result,\n\terr error,\n) {\n\tswitch err {\n\tcase nil, sql.ErrNoRows:\n\t\t// nothing\n\tdefault:\n\t\tatomic.AddUint32(&db.stats.Errors, 1)\n\t}\n\n\tif event == nil {\n\t\treturn\n\t}\n\n\tevent.Result = res\n\tevent.Err = err\n\n\tdb.afterQueryFromIndex(ctx, event, len(db.queryHooks)-1)\n}\n\nfunc (db *DB) afterQueryFromIndex(ctx context.Context, event *QueryEvent, hookIndex int) {\n\tfor ; hookIndex >= 0; hookIndex-- {\n\t\tdb.queryHooks[hookIndex].AfterQuery(ctx, event)\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "migrate",
          "type": "tree",
          "content": null
        },
        {
          "name": "model.go",
          "type": "blob",
          "size": 4.2626953125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/uptrace/bun/schema\"\n)\n\nvar errNilModel = errors.New(\"bun: Model(nil)\")\n\nvar (\n\ttimeType  = reflect.TypeFor[time.Time]()\n\tbytesType = reflect.TypeFor[[]byte]()\n)\n\ntype Model = schema.Model\n\ntype rowScanner interface {\n\tScanRow(ctx context.Context, rows *sql.Rows) error\n}\n\ntype TableModel interface {\n\tModel\n\n\tschema.BeforeAppendModelHook\n\tschema.BeforeScanRowHook\n\tschema.AfterScanRowHook\n\tScanColumn(column string, src interface{}) error\n\n\tTable() *schema.Table\n\tRelation() *schema.Relation\n\n\tjoin(string) *relationJoin\n\tgetJoin(string) *relationJoin\n\tgetJoins() []relationJoin\n\taddJoin(relationJoin) *relationJoin\n\n\trootValue() reflect.Value\n\tparentIndex() []int\n\tmount(reflect.Value)\n\n\tupdateSoftDeleteField(time.Time) error\n}\n\nfunc newModel(db *DB, dest []interface{}) (Model, error) {\n\tif len(dest) == 1 {\n\t\treturn _newModel(db, dest[0], true)\n\t}\n\n\tvalues := make([]reflect.Value, len(dest))\n\n\tfor i, el := range dest {\n\t\tv := reflect.ValueOf(el)\n\t\tif v.Kind() != reflect.Ptr {\n\t\t\treturn nil, fmt.Errorf(\"bun: Scan(non-pointer %T)\", dest)\n\t\t}\n\n\t\tv = v.Elem()\n\t\tif v.Kind() != reflect.Slice {\n\t\t\treturn newScanModel(db, dest), nil\n\t\t}\n\n\t\tvalues[i] = v\n\t}\n\n\treturn newSliceModel(db, dest, values), nil\n}\n\nfunc newSingleModel(db *DB, dest interface{}) (Model, error) {\n\treturn _newModel(db, dest, false)\n}\n\nfunc _newModel(db *DB, dest interface{}, scan bool) (Model, error) {\n\tswitch dest := dest.(type) {\n\tcase nil:\n\t\treturn nil, errNilModel\n\tcase Model:\n\t\treturn dest, nil\n\tcase sql.Scanner:\n\t\tif !scan {\n\t\t\treturn nil, fmt.Errorf(\"bun: Model(unsupported %T)\", dest)\n\t\t}\n\t\treturn newScanModel(db, []interface{}{dest}), nil\n\t}\n\n\tv := reflect.ValueOf(dest)\n\tif !v.IsValid() {\n\t\treturn nil, errNilModel\n\t}\n\tif v.Kind() != reflect.Ptr {\n\t\treturn nil, fmt.Errorf(\"bun: Model(non-pointer %T)\", dest)\n\t}\n\n\tif v.IsNil() {\n\t\ttyp := v.Type().Elem()\n\t\tif typ.Kind() == reflect.Struct {\n\t\t\treturn newStructTableModel(db, dest, db.Table(typ)), nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"bun: Model(nil %s %T)\", typ.Kind(), dest)\n\t}\n\n\tv = v.Elem()\n\ttyp := v.Type()\n\n\tswitch typ {\n\tcase timeType, bytesType:\n\t\treturn newScanModel(db, []interface{}{dest}), nil\n\t}\n\n\tswitch v.Kind() {\n\tcase reflect.Map:\n\t\tif err := validMap(typ); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmapPtr := v.Addr().Interface().(*map[string]interface{})\n\t\treturn newMapModel(db, mapPtr), nil\n\tcase reflect.Struct:\n\t\treturn newStructTableModelValue(db, dest, v), nil\n\tcase reflect.Slice:\n\t\tswitch elemType := sliceElemType(v); elemType.Kind() {\n\t\tcase reflect.Struct:\n\t\t\tif elemType != timeType {\n\t\t\t\treturn newSliceTableModel(db, dest, v, elemType), nil\n\t\t\t}\n\t\tcase reflect.Map:\n\t\t\tif err := validMap(elemType); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tslicePtr := v.Addr().Interface().(*[]map[string]interface{})\n\t\t\treturn newMapSliceModel(db, slicePtr), nil\n\t\t}\n\t\treturn newSliceModel(db, []interface{}{dest}, []reflect.Value{v}), nil\n\t}\n\n\tif scan {\n\t\treturn newScanModel(db, []interface{}{dest}), nil\n\t}\n\n\treturn nil, fmt.Errorf(\"bun: Model(unsupported %T)\", dest)\n}\n\nfunc newTableModelIndex(\n\tdb *DB,\n\ttable *schema.Table,\n\troot reflect.Value,\n\tindex []int,\n\trel *schema.Relation,\n) (TableModel, error) {\n\ttyp := typeByIndex(table.Type, index)\n\n\tif typ.Kind() == reflect.Struct {\n\t\treturn &structTableModel{\n\t\t\tdb:    db,\n\t\t\ttable: table.Dialect().Tables().Get(typ),\n\t\t\trel:   rel,\n\n\t\t\troot:  root,\n\t\t\tindex: index,\n\t\t}, nil\n\t}\n\n\tif typ.Kind() == reflect.Slice {\n\t\tstructType := indirectType(typ.Elem())\n\t\tif structType.Kind() == reflect.Struct {\n\t\t\tm := sliceTableModel{\n\t\t\t\tstructTableModel: structTableModel{\n\t\t\t\t\tdb:    db,\n\t\t\t\t\ttable: table.Dialect().Tables().Get(structType),\n\t\t\t\t\trel:   rel,\n\n\t\t\t\t\troot:  root,\n\t\t\t\t\tindex: index,\n\t\t\t\t},\n\t\t\t}\n\t\t\tm.init(typ)\n\t\t\treturn &m, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"bun: NewModel(%s)\", typ)\n}\n\nfunc validMap(typ reflect.Type) error {\n\tif typ.Key().Kind() != reflect.String || typ.Elem().Kind() != reflect.Interface {\n\t\treturn fmt.Errorf(\"bun: Model(unsupported %s) (expected *map[string]interface{})\",\n\t\t\ttyp)\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc isSingleRowModel(m Model) bool {\n\tswitch m.(type) {\n\tcase *mapModel,\n\t\t*structTableModel,\n\t\t*scanModel:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n"
        },
        {
          "name": "model_map.go",
          "type": "blob",
          "size": 3.1689453125,
          "content": "package bun\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"reflect\"\n\t\"sort\"\n\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype mapModel struct {\n\tdb *DB\n\n\tdest *map[string]interface{}\n\tm    map[string]interface{}\n\n\trows         *sql.Rows\n\tcolumns      []string\n\t_columnTypes []*sql.ColumnType\n\tscanIndex    int\n}\n\nvar _ Model = (*mapModel)(nil)\n\nfunc newMapModel(db *DB, dest *map[string]interface{}) *mapModel {\n\tm := &mapModel{\n\t\tdb:   db,\n\t\tdest: dest,\n\t}\n\tif dest != nil {\n\t\tm.m = *dest\n\t}\n\treturn m\n}\n\nfunc (m *mapModel) Value() interface{} {\n\treturn m.dest\n}\n\nfunc (m *mapModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tif !rows.Next() {\n\t\treturn 0, rows.Err()\n\t}\n\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tm.rows = rows\n\tm.columns = columns\n\tdest := makeDest(m, len(columns))\n\n\tif m.m == nil {\n\t\tm.m = make(map[string]interface{}, len(m.columns))\n\t}\n\n\tm.scanIndex = 0\n\tif err := rows.Scan(dest...); err != nil {\n\t\treturn 0, err\n\t}\n\n\t*m.dest = m.m\n\n\treturn 1, nil\n}\n\nfunc (m *mapModel) Scan(src interface{}) error {\n\tif _, ok := src.([]byte); !ok {\n\t\treturn m.scanRaw(src)\n\t}\n\n\tcolumnTypes, err := m.columnTypes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tscanType := columnTypes[m.scanIndex].ScanType()\n\tswitch scanType.Kind() {\n\tcase reflect.Interface:\n\t\treturn m.scanRaw(src)\n\tcase reflect.Slice:\n\t\tif scanType.Elem().Kind() == reflect.Uint8 {\n\t\t\t// Reference types such as []byte are only valid until the next call to Scan.\n\t\t\tsrc := bytes.Clone(src.([]byte))\n\t\t\treturn m.scanRaw(src)\n\t\t}\n\t}\n\n\tdest := reflect.New(scanType).Elem()\n\tif err := schema.Scanner(scanType)(dest, src); err != nil {\n\t\treturn err\n\t}\n\n\treturn m.scanRaw(dest.Interface())\n}\n\nfunc (m *mapModel) columnTypes() ([]*sql.ColumnType, error) {\n\tif m._columnTypes == nil {\n\t\tcolumnTypes, err := m.rows.ColumnTypes()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tm._columnTypes = columnTypes\n\t}\n\treturn m._columnTypes, nil\n}\n\nfunc (m *mapModel) scanRaw(src interface{}) error {\n\tcolumnName := m.columns[m.scanIndex]\n\tm.scanIndex++\n\tm.m[columnName] = src\n\treturn nil\n}\n\nfunc (m *mapModel) appendColumnsValues(fmter schema.Formatter, b []byte) []byte {\n\tkeys := make([]string, 0, len(m.m))\n\n\tfor k := range m.m {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tb = append(b, \" (\"...)\n\n\tfor i, k := range keys {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb = fmter.AppendIdent(b, k)\n\t}\n\n\tb = append(b, \") VALUES (\"...)\n\n\tisTemplate := fmter.IsNop()\n\tfor i, k := range keys {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tif isTemplate {\n\t\t\tb = append(b, '?')\n\t\t} else {\n\t\t\tb = schema.Append(fmter, b, m.m[k])\n\t\t}\n\t}\n\n\tb = append(b, \")\"...)\n\n\treturn b\n}\n\nfunc (m *mapModel) appendSet(fmter schema.Formatter, b []byte) []byte {\n\tkeys := make([]string, 0, len(m.m))\n\n\tfor k := range m.m {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tisTemplate := fmter.IsNop()\n\tfor i, k := range keys {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tb = fmter.AppendIdent(b, k)\n\t\tb = append(b, \" = \"...)\n\t\tif isTemplate {\n\t\t\tb = append(b, '?')\n\t\t} else {\n\t\t\tb = schema.Append(fmter, b, m.m[k])\n\t\t}\n\t}\n\n\treturn b\n}\n\nfunc makeDest(v interface{}, n int) []interface{} {\n\tdest := make([]interface{}, n)\n\tfor i := range dest {\n\t\tdest[i] = v\n\t}\n\treturn dest\n}\n"
        },
        {
          "name": "model_map_slice.go",
          "type": "blob",
          "size": 2.59765625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"sort\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype mapSliceModel struct {\n\tmapModel\n\tdest *[]map[string]interface{}\n\n\tkeys []string\n}\n\nvar _ Model = (*mapSliceModel)(nil)\n\nfunc newMapSliceModel(db *DB, dest *[]map[string]interface{}) *mapSliceModel {\n\treturn &mapSliceModel{\n\t\tmapModel: mapModel{\n\t\t\tdb: db,\n\t\t},\n\t\tdest: dest,\n\t}\n}\n\nfunc (m *mapSliceModel) Value() interface{} {\n\treturn m.dest\n}\n\nfunc (m *mapSliceModel) SetCap(cap int) {\n\tif cap > 100 {\n\t\tcap = 100\n\t}\n\tif slice := *m.dest; len(slice) < cap {\n\t\t*m.dest = make([]map[string]interface{}, 0, cap)\n\t}\n}\n\nfunc (m *mapSliceModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tm.rows = rows\n\tm.columns = columns\n\tdest := makeDest(m, len(columns))\n\n\tslice := *m.dest\n\tif len(slice) > 0 {\n\t\tslice = slice[:0]\n\t}\n\n\tvar n int\n\n\tfor rows.Next() {\n\t\tm.m = make(map[string]interface{}, len(m.columns))\n\n\t\tm.scanIndex = 0\n\t\tif err := rows.Scan(dest...); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tslice = append(slice, m.m)\n\t\tn++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\n\t*m.dest = slice\n\treturn n, nil\n}\n\nfunc (m *mapSliceModel) appendColumns(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif err := m.initKeys(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i, k := range m.keys {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb = fmter.AppendIdent(b, k)\n\t}\n\n\treturn b, nil\n}\n\nfunc (m *mapSliceModel) appendValues(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif err := m.initKeys(); err != nil {\n\t\treturn nil, err\n\t}\n\tslice := *m.dest\n\n\tb = append(b, \"VALUES \"...)\n\tif m.db.HasFeature(feature.ValuesRow) {\n\t\tb = append(b, \"ROW(\"...)\n\t} else {\n\t\tb = append(b, '(')\n\t}\n\n\tif fmter.IsNop() {\n\t\tfor i := range m.keys {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb = append(b, '?')\n\t\t}\n\t\treturn b, nil\n\t}\n\n\tfor i, el := range slice {\n\t\tif i > 0 {\n\t\t\tb = append(b, \"), \"...)\n\t\t\tif m.db.HasFeature(feature.ValuesRow) {\n\t\t\t\tb = append(b, \"ROW(\"...)\n\t\t\t} else {\n\t\t\t\tb = append(b, '(')\n\t\t\t}\n\t\t}\n\n\t\tfor j, key := range m.keys {\n\t\t\tif j > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb = schema.Append(fmter, b, el[key])\n\t\t}\n\t}\n\n\tb = append(b, ')')\n\n\treturn b, nil\n}\n\nfunc (m *mapSliceModel) initKeys() error {\n\tif m.keys != nil {\n\t\treturn nil\n\t}\n\n\tslice := *m.dest\n\tif len(slice) == 0 {\n\t\treturn errors.New(\"bun: map slice is empty\")\n\t}\n\n\tfirst := slice[0]\n\tkeys := make([]string, 0, len(first))\n\n\tfor k := range first {\n\t\tkeys = append(keys, k)\n\t}\n\n\tsort.Strings(keys)\n\tm.keys = keys\n\n\treturn nil\n}\n"
        },
        {
          "name": "model_scan.go",
          "type": "blob",
          "size": 0.90234375,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"reflect\"\n\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype scanModel struct {\n\tdb *DB\n\n\tdest      []interface{}\n\tscanIndex int\n}\n\nvar _ Model = (*scanModel)(nil)\n\nfunc newScanModel(db *DB, dest []interface{}) *scanModel {\n\treturn &scanModel{\n\t\tdb:   db,\n\t\tdest: dest,\n\t}\n}\n\nfunc (m *scanModel) Value() interface{} {\n\treturn m.dest\n}\n\nfunc (m *scanModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tif !rows.Next() {\n\t\treturn 0, rows.Err()\n\t}\n\n\tdest := makeDest(m, len(m.dest))\n\n\tm.scanIndex = 0\n\tif err := rows.Scan(dest...); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn 1, nil\n}\n\nfunc (m *scanModel) ScanRow(ctx context.Context, rows *sql.Rows) error {\n\treturn rows.Scan(m.dest...)\n}\n\nfunc (m *scanModel) Scan(src interface{}) error {\n\tdest := reflect.ValueOf(m.dest[m.scanIndex])\n\tm.scanIndex++\n\n\tscanner := schema.Scanner(dest.Type())\n\treturn scanner(dest, src)\n}\n"
        },
        {
          "name": "model_slice.go",
          "type": "blob",
          "size": 1.3876953125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"reflect\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype sliceInfo struct {\n\tnextElem func() reflect.Value\n\tscan     schema.ScannerFunc\n}\n\ntype sliceModel struct {\n\tdest      []interface{}\n\tvalues    []reflect.Value\n\tscanIndex int\n\tinfo      []sliceInfo\n}\n\nvar _ Model = (*sliceModel)(nil)\n\nfunc newSliceModel(db *DB, dest []interface{}, values []reflect.Value) *sliceModel {\n\treturn &sliceModel{\n\t\tdest:   dest,\n\t\tvalues: values,\n\t}\n}\n\nfunc (m *sliceModel) Value() interface{} {\n\treturn m.dest\n}\n\nfunc (m *sliceModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tm.info = make([]sliceInfo, len(m.values))\n\tfor i, v := range m.values {\n\t\tif v.IsValid() && v.Len() > 0 {\n\t\t\tv.Set(v.Slice(0, 0))\n\t\t}\n\n\t\tm.info[i] = sliceInfo{\n\t\t\tnextElem: internal.MakeSliceNextElemFunc(v),\n\t\t\tscan:     schema.Scanner(v.Type().Elem()),\n\t\t}\n\t}\n\n\tif len(columns) == 0 {\n\t\treturn 0, nil\n\t}\n\tdest := makeDest(m, len(columns))\n\n\tvar n int\n\n\tfor rows.Next() {\n\t\tm.scanIndex = 0\n\t\tif err := rows.Scan(dest...); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tn++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}\n\nfunc (m *sliceModel) Scan(src interface{}) error {\n\tinfo := m.info[m.scanIndex]\n\tm.scanIndex++\n\n\tdest := info.nextElem()\n\treturn info.scan(dest, src)\n}\n"
        },
        {
          "name": "model_table_has_many.go",
          "type": "blob",
          "size": 3.5634765625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype hasManyModel struct {\n\t*sliceTableModel\n\tbaseTable *schema.Table\n\trel       *schema.Relation\n\n\tbaseValues map[internal.MapKey][]reflect.Value\n\tstructKey  []interface{}\n}\n\nvar _ TableModel = (*hasManyModel)(nil)\n\nfunc newHasManyModel(j *relationJoin) *hasManyModel {\n\tbaseTable := j.BaseModel.Table()\n\tjoinModel := j.JoinModel.(*sliceTableModel)\n\tbaseValues := baseValues(joinModel, j.Relation.BasePKs)\n\tif len(baseValues) == 0 {\n\t\treturn nil\n\t}\n\tm := hasManyModel{\n\t\tsliceTableModel: joinModel,\n\t\tbaseTable:       baseTable,\n\t\trel:             j.Relation,\n\n\t\tbaseValues: baseValues,\n\t}\n\tif !m.sliceOfPtr {\n\t\tm.strct = reflect.New(m.table.Type).Elem()\n\t}\n\treturn &m\n}\n\nfunc (m *hasManyModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tm.columns = columns\n\tdest := makeDest(m, len(columns))\n\n\tvar n int\n\tm.structKey = make([]interface{}, len(m.rel.JoinPKs))\n\tfor rows.Next() {\n\t\tif m.sliceOfPtr {\n\t\t\tm.strct = reflect.New(m.table.Type).Elem()\n\t\t} else {\n\t\t\tm.strct.Set(m.table.ZeroValue)\n\t\t}\n\t\tm.structInited = false\n\t\tm.scanIndex = 0\n\n\t\tif err := rows.Scan(dest...); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := m.parkStruct(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tn++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}\n\nfunc (m *hasManyModel) Scan(src interface{}) error {\n\tcolumn := m.columns[m.scanIndex]\n\tm.scanIndex++\n\n\tfield := m.table.LookupField(column)\n\tif field == nil {\n\t\treturn fmt.Errorf(\"bun: %s does not have column %q\", m.table.TypeName, column)\n\t}\n\n\tif err := field.ScanValue(m.strct, src); err != nil {\n\t\treturn err\n\t}\n\n\tfor i, f := range m.rel.JoinPKs {\n\t\tif f.Name == column {\n\t\t\tm.structKey[i] = indirectFieldValue(field.Value(m.strct))\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (m *hasManyModel) parkStruct() error {\n\n\tbaseValues, ok := m.baseValues[internal.NewMapKey(m.structKey)]\n\tif !ok {\n\t\treturn fmt.Errorf(\n\t\t\t\"bun: has-many relation=%s does not have base %s with id=%q (check join conditions)\",\n\t\t\tm.rel.Field.GoName, m.baseTable, m.structKey)\n\t}\n\n\tfor i, v := range baseValues {\n\t\tif !m.sliceOfPtr {\n\t\t\tv.Set(reflect.Append(v, m.strct))\n\t\t\tcontinue\n\t\t}\n\n\t\tif i == 0 {\n\t\t\tv.Set(reflect.Append(v, m.strct.Addr()))\n\t\t\tcontinue\n\t\t}\n\n\t\tclone := reflect.New(m.strct.Type()).Elem()\n\t\tclone.Set(m.strct)\n\t\tv.Set(reflect.Append(v, clone.Addr()))\n\t}\n\n\treturn nil\n}\n\nfunc baseValues(model TableModel, fields []*schema.Field) map[internal.MapKey][]reflect.Value {\n\tfieldIndex := model.Relation().Field.Index\n\tm := make(map[internal.MapKey][]reflect.Value)\n\tkey := make([]interface{}, 0, len(fields))\n\twalk(model.rootValue(), model.parentIndex(), func(v reflect.Value) {\n\t\tkey = modelKey(key[:0], v, fields)\n\t\tmapKey := internal.NewMapKey(key)\n\t\tm[mapKey] = append(m[mapKey], v.FieldByIndex(fieldIndex))\n\t})\n\treturn m\n}\n\nfunc modelKey(key []interface{}, strct reflect.Value, fields []*schema.Field) []interface{} {\n\tfor _, f := range fields {\n\t\tkey = append(key, indirectFieldValue(f.Value(strct)))\n\t}\n\treturn key\n}\n\n// indirectFieldValue return the field value dereferencing the pointer if necessary.\n// The value is then used as a map key.\nfunc indirectFieldValue(field reflect.Value) interface{} {\n\tif field.Kind() != reflect.Ptr {\n\t\ti := field.Interface()\n\t\tif valuer, ok := i.(driver.Valuer); ok {\n\t\t\tif v, err := valuer.Value(); err == nil {\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t\treturn i\n\t}\n\tif field.IsNil() {\n\t\treturn nil\n\t}\n\treturn field.Elem().Interface()\n}\n"
        },
        {
          "name": "model_table_m2m.go",
          "type": "blob",
          "size": 2.5625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype m2mModel struct {\n\t*sliceTableModel\n\tbaseTable *schema.Table\n\trel       *schema.Relation\n\n\tbaseValues map[internal.MapKey][]reflect.Value\n\tstructKey  []interface{}\n}\n\nvar _ TableModel = (*m2mModel)(nil)\n\nfunc newM2MModel(j *relationJoin) *m2mModel {\n\tbaseTable := j.BaseModel.Table()\n\tjoinModel := j.JoinModel.(*sliceTableModel)\n\tbaseValues := baseValues(joinModel, j.Relation.BasePKs)\n\tif len(baseValues) == 0 {\n\t\treturn nil\n\t}\n\tm := &m2mModel{\n\t\tsliceTableModel: joinModel,\n\t\tbaseTable:       baseTable,\n\t\trel:             j.Relation,\n\n\t\tbaseValues: baseValues,\n\t}\n\tif !m.sliceOfPtr {\n\t\tm.strct = reflect.New(m.table.Type).Elem()\n\t}\n\treturn m\n}\n\nfunc (m *m2mModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tm.columns = columns\n\tdest := makeDest(m, len(columns))\n\n\tvar n int\n\n\tfor rows.Next() {\n\t\tif m.sliceOfPtr {\n\t\t\tm.strct = reflect.New(m.table.Type).Elem()\n\t\t} else {\n\t\t\tm.strct.Set(m.table.ZeroValue)\n\t\t}\n\t\tm.structInited = false\n\n\t\tm.scanIndex = 0\n\t\tm.structKey = m.structKey[:0]\n\t\tif err := rows.Scan(dest...); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tif err := m.parkStruct(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tn++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}\n\nfunc (m *m2mModel) Scan(src interface{}) error {\n\tcolumn := m.columns[m.scanIndex]\n\tm.scanIndex++\n\n\t// Base pks must come first.\n\tif m.scanIndex <= len(m.rel.M2MBasePKs) {\n\t\treturn m.scanM2MColumn(column, src)\n\t}\n\n\tif field, ok := m.table.FieldMap[column]; ok {\n\t\treturn field.ScanValue(m.strct, src)\n\t}\n\n\t_, err := m.scanColumn(column, src)\n\treturn err\n}\n\nfunc (m *m2mModel) scanM2MColumn(column string, src interface{}) error {\n\tfor _, field := range m.rel.M2MBasePKs {\n\t\tif field.Name == column {\n\t\t\tdest := reflect.New(field.IndirectType).Elem()\n\t\t\tif err := field.Scan(dest, src); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tm.structKey = append(m.structKey, indirectFieldValue(dest))\n\t\t\tbreak\n\t\t}\n\t}\n\n\t_, err := m.scanColumn(column, src)\n\treturn err\n}\n\nfunc (m *m2mModel) parkStruct() error {\n\tbaseValues, ok := m.baseValues[internal.NewMapKey(m.structKey)]\n\tif !ok {\n\t\treturn fmt.Errorf(\n\t\t\t\"bun: m2m relation=%s does not have base %s with key=%q (check join conditions)\",\n\t\t\tm.rel.Field.GoName, m.baseTable, m.structKey)\n\t}\n\n\tfor _, v := range baseValues {\n\t\tif m.sliceOfPtr {\n\t\t\tv.Set(reflect.Append(v, m.strct.Addr()))\n\t\t} else {\n\t\t\tv.Set(reflect.Append(v, m.strct))\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "model_table_slice.go",
          "type": "blob",
          "size": 2.486328125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype sliceTableModel struct {\n\tstructTableModel\n\n\tslice      reflect.Value\n\tsliceLen   int\n\tsliceOfPtr bool\n\tnextElem   func() reflect.Value\n}\n\nvar _ TableModel = (*sliceTableModel)(nil)\n\nfunc newSliceTableModel(\n\tdb *DB, dest interface{}, slice reflect.Value, elemType reflect.Type,\n) *sliceTableModel {\n\tm := &sliceTableModel{\n\t\tstructTableModel: structTableModel{\n\t\t\tdb:    db,\n\t\t\ttable: db.Table(elemType),\n\t\t\tdest:  dest,\n\t\t\troot:  slice,\n\t\t},\n\n\t\tslice:    slice,\n\t\tsliceLen: slice.Len(),\n\t\tnextElem: internal.MakeSliceNextElemFunc(slice),\n\t}\n\tm.init(slice.Type())\n\treturn m\n}\n\nfunc (m *sliceTableModel) init(sliceType reflect.Type) {\n\tswitch sliceType.Elem().Kind() {\n\tcase reflect.Ptr, reflect.Interface:\n\t\tm.sliceOfPtr = true\n\t}\n}\n\nfunc (m *sliceTableModel) join(name string) *relationJoin {\n\treturn m._join(m.slice, name)\n}\n\nfunc (m *sliceTableModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tm.columns = columns\n\tdest := makeDest(m, len(columns))\n\n\tif m.slice.IsValid() && m.slice.Len() > 0 {\n\t\tm.slice.Set(m.slice.Slice(0, 0))\n\t}\n\n\tvar n int\n\n\tfor rows.Next() {\n\t\tm.strct = m.nextElem()\n\t\tif m.sliceOfPtr {\n\t\t\tm.strct = m.strct.Elem()\n\t\t}\n\t\tm.structInited = false\n\n\t\tif err := m.scanRow(ctx, rows, dest); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tn++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}\n\nvar _ schema.BeforeAppendModelHook = (*sliceTableModel)(nil)\n\nfunc (m *sliceTableModel) BeforeAppendModel(ctx context.Context, query Query) error {\n\tif !m.table.HasBeforeAppendModelHook() || !m.slice.IsValid() {\n\t\treturn nil\n\t}\n\n\tsliceLen := m.slice.Len()\n\tfor i := 0; i < sliceLen; i++ {\n\t\tstrct := m.slice.Index(i)\n\t\tif !m.sliceOfPtr {\n\t\t\tstrct = strct.Addr()\n\t\t}\n\t\terr := strct.Interface().(schema.BeforeAppendModelHook).BeforeAppendModel(ctx, query)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Inherit these hooks from structTableModel.\nvar (\n\t_ schema.BeforeScanRowHook = (*sliceTableModel)(nil)\n\t_ schema.AfterScanRowHook  = (*sliceTableModel)(nil)\n)\n\nfunc (m *sliceTableModel) updateSoftDeleteField(tm time.Time) error {\n\tsliceLen := m.slice.Len()\n\tfor i := 0; i < sliceLen; i++ {\n\t\tstrct := indirect(m.slice.Index(i))\n\t\tfv := m.table.SoftDeleteField.Value(strct)\n\t\tif err := m.table.UpdateSoftDeleteField(fv, tm); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "model_table_struct.go",
          "type": "blob",
          "size": 7.439453125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype structTableModel struct {\n\tdb    *DB\n\ttable *schema.Table\n\n\trel   *schema.Relation\n\tjoins []relationJoin\n\n\tdest  interface{}\n\troot  reflect.Value\n\tindex []int\n\n\tstrct         reflect.Value\n\tstructInited  bool\n\tstructInitErr error\n\n\tcolumns   []string\n\tscanIndex int\n}\n\nvar _ TableModel = (*structTableModel)(nil)\n\nfunc newStructTableModel(db *DB, dest interface{}, table *schema.Table) *structTableModel {\n\treturn &structTableModel{\n\t\tdb:    db,\n\t\ttable: table,\n\t\tdest:  dest,\n\t}\n}\n\nfunc newStructTableModelValue(db *DB, dest interface{}, v reflect.Value) *structTableModel {\n\treturn &structTableModel{\n\t\tdb:    db,\n\t\ttable: db.Table(v.Type()),\n\t\tdest:  dest,\n\t\troot:  v,\n\t\tstrct: v,\n\t}\n}\n\nfunc (m *structTableModel) Value() interface{} {\n\treturn m.dest\n}\n\nfunc (m *structTableModel) Table() *schema.Table {\n\treturn m.table\n}\n\nfunc (m *structTableModel) Relation() *schema.Relation {\n\treturn m.rel\n}\n\nfunc (m *structTableModel) initStruct() error {\n\tif m.structInited {\n\t\treturn m.structInitErr\n\t}\n\tm.structInited = true\n\n\tswitch m.strct.Kind() {\n\tcase reflect.Invalid:\n\t\tm.structInitErr = errNilModel\n\t\treturn m.structInitErr\n\tcase reflect.Interface:\n\t\tm.strct = m.strct.Elem()\n\t}\n\n\tif m.strct.Kind() == reflect.Ptr {\n\t\tif m.strct.IsNil() {\n\t\t\tm.strct.Set(reflect.New(m.strct.Type().Elem()))\n\t\t\tm.strct = m.strct.Elem()\n\t\t} else {\n\t\t\tm.strct = m.strct.Elem()\n\t\t}\n\t}\n\n\tm.mountJoins()\n\n\treturn nil\n}\n\nfunc (m *structTableModel) mountJoins() {\n\tfor i := range m.joins {\n\t\tj := &m.joins[i]\n\t\tswitch j.Relation.Type {\n\t\tcase schema.HasOneRelation, schema.BelongsToRelation:\n\t\t\tj.JoinModel.mount(m.strct)\n\t\t}\n\t}\n}\n\nvar _ schema.BeforeAppendModelHook = (*structTableModel)(nil)\n\nfunc (m *structTableModel) BeforeAppendModel(ctx context.Context, query Query) error {\n\tif !m.table.HasBeforeAppendModelHook() || !m.strct.IsValid() {\n\t\treturn nil\n\t}\n\treturn m.strct.Addr().Interface().(schema.BeforeAppendModelHook).BeforeAppendModel(ctx, query)\n}\n\nvar _ schema.BeforeScanRowHook = (*structTableModel)(nil)\n\nfunc (m *structTableModel) BeforeScanRow(ctx context.Context) error {\n\tif m.table.HasBeforeScanRowHook() {\n\t\treturn m.strct.Addr().Interface().(schema.BeforeScanRowHook).BeforeScanRow(ctx)\n\t}\n\treturn nil\n}\n\nvar _ schema.AfterScanRowHook = (*structTableModel)(nil)\n\nfunc (m *structTableModel) AfterScanRow(ctx context.Context) error {\n\tif !m.structInited {\n\t\treturn nil\n\t}\n\n\tif m.table.HasAfterScanRowHook() {\n\t\tfirstErr := m.strct.Addr().Interface().(schema.AfterScanRowHook).AfterScanRow(ctx)\n\n\t\tfor _, j := range m.joins {\n\t\t\tswitch j.Relation.Type {\n\t\t\tcase schema.HasOneRelation, schema.BelongsToRelation:\n\t\t\t\tif err := j.JoinModel.AfterScanRow(ctx); err != nil && firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn firstErr\n\t}\n\n\treturn nil\n}\n\nfunc (m *structTableModel) getJoin(name string) *relationJoin {\n\tfor i := range m.joins {\n\t\tj := &m.joins[i]\n\t\tif j.Relation.Field.Name == name || j.Relation.Field.GoName == name {\n\t\t\treturn j\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *structTableModel) getJoins() []relationJoin {\n\treturn m.joins\n}\n\nfunc (m *structTableModel) addJoin(j relationJoin) *relationJoin {\n\tm.joins = append(m.joins, j)\n\treturn &m.joins[len(m.joins)-1]\n}\n\nfunc (m *structTableModel) join(name string) *relationJoin {\n\treturn m._join(m.strct, name)\n}\n\nfunc (m *structTableModel) _join(bind reflect.Value, name string) *relationJoin {\n\tpath := strings.Split(name, \".\")\n\tindex := make([]int, 0, len(path))\n\n\tcurrJoin := relationJoin{\n\t\tBaseModel: m,\n\t\tJoinModel: m,\n\t}\n\tvar lastJoin *relationJoin\n\n\tfor _, name := range path {\n\t\trelation, ok := currJoin.JoinModel.Table().Relations[name]\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\n\t\tcurrJoin.Relation = relation\n\t\tindex = append(index, relation.Field.Index...)\n\n\t\tif j := currJoin.JoinModel.getJoin(name); j != nil {\n\t\t\tcurrJoin.BaseModel = j.BaseModel\n\t\t\tcurrJoin.JoinModel = j.JoinModel\n\n\t\t\tlastJoin = j\n\t\t} else {\n\t\t\tmodel, err := newTableModelIndex(m.db, m.table, bind, index, relation)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tcurrJoin.Parent = lastJoin\n\t\t\tcurrJoin.BaseModel = currJoin.JoinModel\n\t\t\tcurrJoin.JoinModel = model\n\n\t\t\tlastJoin = currJoin.BaseModel.addJoin(currJoin)\n\t\t}\n\t}\n\n\treturn lastJoin\n}\n\nfunc (m *structTableModel) rootValue() reflect.Value {\n\treturn m.root\n}\n\nfunc (m *structTableModel) parentIndex() []int {\n\treturn m.index[:len(m.index)-len(m.rel.Field.Index)]\n}\n\nfunc (m *structTableModel) mount(host reflect.Value) {\n\tm.strct = internal.FieldByIndexAlloc(host, m.rel.Field.Index)\n\tm.structInited = false\n}\n\nfunc (m *structTableModel) updateSoftDeleteField(tm time.Time) error {\n\tif !m.strct.IsValid() {\n\t\treturn nil\n\t}\n\tfv := m.table.SoftDeleteField.Value(m.strct)\n\treturn m.table.UpdateSoftDeleteField(fv, tm)\n}\n\nfunc (m *structTableModel) ScanRows(ctx context.Context, rows *sql.Rows) (int, error) {\n\tif !rows.Next() {\n\t\treturn 0, rows.Err()\n\t}\n\n\tvar n int\n\n\tif err := m.ScanRow(ctx, rows); err != nil {\n\t\treturn 0, err\n\t}\n\tn++\n\n\t// And discard the rest. This is especially important for SQLite3, which can return\n\t// a row like it was inserted successfully and then return an actual error for the next row.\n\t// See issues/100.\n\tfor rows.Next() {\n\t\tn++\n\t}\n\tif err := rows.Err(); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn n, nil\n}\n\nfunc (m *structTableModel) ScanRow(ctx context.Context, rows *sql.Rows) error {\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tm.columns = columns\n\tdest := makeDest(m, len(columns))\n\n\treturn m.scanRow(ctx, rows, dest)\n}\n\nfunc (m *structTableModel) scanRow(ctx context.Context, rows *sql.Rows, dest []interface{}) error {\n\tif err := m.BeforeScanRow(ctx); err != nil {\n\t\treturn err\n\t}\n\n\tm.scanIndex = 0\n\tif err := rows.Scan(dest...); err != nil {\n\t\treturn err\n\t}\n\n\tif err := m.AfterScanRow(ctx); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *structTableModel) Scan(src interface{}) error {\n\tcolumn := m.columns[m.scanIndex]\n\tm.scanIndex++\n\n\treturn m.ScanColumn(unquote(column), src)\n}\n\nfunc (m *structTableModel) ScanColumn(column string, src interface{}) error {\n\tif ok, err := m.scanColumn(column, src); ok {\n\t\treturn err\n\t}\n\tif column == \"\" || column[0] == '_' || m.db.flags.Has(discardUnknownColumns) {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"bun: %s does not have column %q\", m.table.TypeName, column)\n}\n\nfunc (m *structTableModel) scanColumn(column string, src interface{}) (bool, error) {\n\tif src != nil {\n\t\tif err := m.initStruct(); err != nil {\n\t\t\treturn true, err\n\t\t}\n\t}\n\n\tif field := m.table.LookupField(column); field != nil {\n\t\tif src == nil && m.isNil() {\n\t\t\treturn true, nil\n\t\t}\n\t\treturn true, field.ScanValue(m.strct, src)\n\t}\n\n\tif joinName, column := splitColumn(column); joinName != \"\" {\n\t\tif join := m.getJoin(joinName); join != nil {\n\t\t\treturn true, join.JoinModel.ScanColumn(column, src)\n\t\t}\n\n\t\tif m.table.ModelName == joinName {\n\t\t\treturn true, m.ScanColumn(column, src)\n\t\t}\n\t}\n\n\treturn false, nil\n}\n\nfunc (m *structTableModel) isNil() bool {\n\treturn m.strct.Kind() == reflect.Ptr && m.strct.IsNil()\n}\n\nfunc (m *structTableModel) AppendNamedArg(\n\tfmter schema.Formatter, b []byte, name string,\n) ([]byte, bool) {\n\treturn m.table.AppendNamedArg(fmter, b, name, m.strct)\n}\n\n// sqlite3 sometimes does not unquote columns.\nfunc unquote(s string) string {\n\tif s == \"\" {\n\t\treturn s\n\t}\n\tif s[0] == '\"' && s[len(s)-1] == '\"' {\n\t\treturn s[1 : len(s)-1]\n\t}\n\treturn s\n}\n\nfunc splitColumn(s string) (string, string) {\n\tif i := strings.Index(s, \"__\"); i >= 0 {\n\t\treturn s[:i], s[i+2:]\n\t}\n\treturn \"\", s\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.203125,
          "content": "{\n  \"name\": \"gobun\",\n  \"version\": \"1.2.8\",\n  \"main\": \"index.js\",\n  \"repository\": \"git@github.com:uptrace/bun.git\",\n  \"author\": \"Vladimir Mihailenco <vladimir.webdev@gmail.com>\",\n  \"license\": \"BSD-2-clause\"\n}\n"
        },
        {
          "name": "query_base.go",
          "type": "blob",
          "size": 31.4453125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/uptrace/bun/dialect\"\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\nconst (\n\tforceDeleteFlag internal.Flag = 1 << iota\n\tdeletedFlag\n\tallWithDeletedFlag\n)\n\ntype withQuery struct {\n\tname      string\n\tquery     schema.QueryAppender\n\trecursive bool\n}\n\n// IConn is a common interface for *sql.DB, *sql.Conn, and *sql.Tx.\ntype IConn interface {\n\tQueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)\n\tExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\n\tQueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row\n}\n\nvar (\n\t_ IConn = (*sql.DB)(nil)\n\t_ IConn = (*sql.Conn)(nil)\n\t_ IConn = (*sql.Tx)(nil)\n\t_ IConn = (*DB)(nil)\n\t_ IConn = (*Conn)(nil)\n\t_ IConn = (*Tx)(nil)\n)\n\n// IDB is a common interface for *bun.DB, bun.Conn, and bun.Tx.\ntype IDB interface {\n\tIConn\n\tDialect() schema.Dialect\n\n\tNewValues(model interface{}) *ValuesQuery\n\tNewSelect() *SelectQuery\n\tNewInsert() *InsertQuery\n\tNewUpdate() *UpdateQuery\n\tNewDelete() *DeleteQuery\n\tNewMerge() *MergeQuery\n\tNewRaw(query string, args ...interface{}) *RawQuery\n\tNewCreateTable() *CreateTableQuery\n\tNewDropTable() *DropTableQuery\n\tNewCreateIndex() *CreateIndexQuery\n\tNewDropIndex() *DropIndexQuery\n\tNewTruncateTable() *TruncateTableQuery\n\tNewAddColumn() *AddColumnQuery\n\tNewDropColumn() *DropColumnQuery\n\n\tBeginTx(ctx context.Context, opts *sql.TxOptions) (Tx, error)\n\tRunInTx(ctx context.Context, opts *sql.TxOptions, f func(ctx context.Context, tx Tx) error) error\n}\n\nvar (\n\t_ IDB = (*DB)(nil)\n\t_ IDB = (*Conn)(nil)\n\t_ IDB = (*Tx)(nil)\n)\n\n// QueryBuilder is used for common query methods\ntype QueryBuilder interface {\n\tQuery\n\tWhere(query string, args ...interface{}) QueryBuilder\n\tWhereGroup(sep string, fn func(QueryBuilder) QueryBuilder) QueryBuilder\n\tWhereOr(query string, args ...interface{}) QueryBuilder\n\tWhereDeleted() QueryBuilder\n\tWhereAllWithDeleted() QueryBuilder\n\tWherePK(cols ...string) QueryBuilder\n\tUnwrap() interface{}\n}\n\nvar (\n\t_ QueryBuilder = (*selectQueryBuilder)(nil)\n\t_ QueryBuilder = (*updateQueryBuilder)(nil)\n\t_ QueryBuilder = (*deleteQueryBuilder)(nil)\n)\n\ntype baseQuery struct {\n\tdb   *DB\n\tconn IConn\n\n\tmodel Model\n\terr   error\n\n\ttableModel TableModel\n\ttable      *schema.Table\n\n\twith           []withQuery\n\tmodelTableName schema.QueryWithArgs\n\ttables         []schema.QueryWithArgs\n\tcolumns        []schema.QueryWithArgs\n\n\tflags internal.Flag\n}\n\nfunc (q *baseQuery) DB() *DB {\n\treturn q.db\n}\n\nfunc (q *baseQuery) GetConn() IConn {\n\treturn q.conn\n}\n\nfunc (q *baseQuery) GetModel() Model {\n\treturn q.model\n}\n\nfunc (q *baseQuery) GetTableName() string {\n\tif q.table != nil {\n\t\treturn q.table.Name\n\t}\n\n\tfor _, wq := range q.with {\n\t\tif v, ok := wq.query.(Query); ok {\n\t\t\tif model := v.GetModel(); model != nil {\n\t\t\t\treturn v.GetTableName()\n\t\t\t}\n\t\t}\n\t}\n\n\tif q.modelTableName.Query != \"\" {\n\t\treturn q.modelTableName.Query\n\t}\n\n\tif len(q.tables) > 0 {\n\t\tb, _ := q.tables[0].AppendQuery(q.db.fmter, nil)\n\t\tif len(b) < 64 {\n\t\t\treturn string(b)\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\nfunc (q *baseQuery) setConn(db IConn) {\n\t// Unwrap Bun wrappers to not call query hooks twice.\n\tswitch db := db.(type) {\n\tcase *DB:\n\t\tq.conn = db.DB\n\tcase Conn:\n\t\tq.conn = db.Conn\n\tcase Tx:\n\t\tq.conn = db.Tx\n\tdefault:\n\t\tq.conn = db\n\t}\n}\n\nfunc (q *baseQuery) setModel(modeli interface{}) {\n\tmodel, err := newSingleModel(q.db, modeli)\n\tif err != nil {\n\t\tq.setErr(err)\n\t\treturn\n\t}\n\n\tq.model = model\n\tif tm, ok := model.(TableModel); ok {\n\t\tq.tableModel = tm\n\t\tq.table = tm.Table()\n\t}\n}\n\nfunc (q *baseQuery) setErr(err error) {\n\tif q.err == nil {\n\t\tq.err = err\n\t}\n}\n\nfunc (q *baseQuery) getModel(dest []interface{}) (Model, error) {\n\tif len(dest) > 0 {\n\t\treturn newModel(q.db, dest)\n\t}\n\tif q.model != nil {\n\t\treturn q.model, nil\n\t}\n\treturn nil, errNilModel\n}\n\nfunc (q *baseQuery) beforeAppendModel(ctx context.Context, query Query) error {\n\tif q.tableModel != nil {\n\t\treturn q.tableModel.BeforeAppendModel(ctx, query)\n\t}\n\treturn nil\n}\n\nfunc (q *baseQuery) hasFeature(feature feature.Feature) bool {\n\treturn q.db.HasFeature(feature)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) checkSoftDelete() error {\n\tif q.table == nil {\n\t\treturn errors.New(\"bun: can't use soft deletes without a table\")\n\t}\n\tif q.table.SoftDeleteField == nil {\n\t\treturn fmt.Errorf(\"%s does not have a soft delete field\", q.table)\n\t}\n\tif q.tableModel == nil {\n\t\treturn errors.New(\"bun: can't use soft deletes without a table model\")\n\t}\n\treturn nil\n}\n\n// Deleted adds `WHERE deleted_at IS NOT NULL` clause for soft deleted models.\nfunc (q *baseQuery) whereDeleted() {\n\tif err := q.checkSoftDelete(); err != nil {\n\t\tq.setErr(err)\n\t\treturn\n\t}\n\tq.flags = q.flags.Set(deletedFlag)\n\tq.flags = q.flags.Remove(allWithDeletedFlag)\n}\n\n// AllWithDeleted changes query to return all rows including soft deleted ones.\nfunc (q *baseQuery) whereAllWithDeleted() {\n\tif err := q.checkSoftDelete(); err != nil {\n\t\tq.setErr(err)\n\t\treturn\n\t}\n\tq.flags = q.flags.Set(allWithDeletedFlag).Remove(deletedFlag)\n}\n\nfunc (q *baseQuery) isSoftDelete() bool {\n\tif q.table != nil {\n\t\treturn q.table.SoftDeleteField != nil &&\n\t\t\t!q.flags.Has(allWithDeletedFlag) &&\n\t\t\t(!q.flags.Has(forceDeleteFlag) || q.flags.Has(deletedFlag))\n\t}\n\treturn false\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) addWith(name string, query schema.QueryAppender, recursive bool) {\n\tq.with = append(q.with, withQuery{\n\t\tname:      name,\n\t\tquery:     query,\n\t\trecursive: recursive,\n\t})\n}\n\nfunc (q *baseQuery) appendWith(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif len(q.with) == 0 {\n\t\treturn b, nil\n\t}\n\n\tb = append(b, \"WITH \"...)\n\tfor i, with := range q.with {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tif with.recursive {\n\t\t\tb = append(b, \"RECURSIVE \"...)\n\t\t}\n\n\t\tb, err = q.appendCTE(fmter, b, with)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tb = append(b, ' ')\n\treturn b, nil\n}\n\nfunc (q *baseQuery) appendCTE(\n\tfmter schema.Formatter, b []byte, cte withQuery,\n) (_ []byte, err error) {\n\tif !fmter.Dialect().Features().Has(feature.WithValues) {\n\t\tif values, ok := cte.query.(*ValuesQuery); ok {\n\t\t\treturn q.appendSelectFromValues(fmter, b, cte, values)\n\t\t}\n\t}\n\n\tb = fmter.AppendIdent(b, cte.name)\n\n\tif q, ok := cte.query.(schema.ColumnsAppender); ok {\n\t\tb = append(b, \" (\"...)\n\t\tb, err = q.AppendColumns(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb = append(b, \")\"...)\n\t}\n\n\tb = append(b, \" AS (\"...)\n\n\tb, err = cte.query.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \")\"...)\n\treturn b, nil\n}\n\nfunc (q *baseQuery) appendSelectFromValues(\n\tfmter schema.Formatter, b []byte, cte withQuery, values *ValuesQuery,\n) (_ []byte, err error) {\n\tb = fmter.AppendIdent(b, cte.name)\n\tb = append(b, \" AS (SELECT * FROM (\"...)\n\n\tb, err = cte.query.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \") AS t\"...)\n\tif q, ok := cte.query.(schema.ColumnsAppender); ok {\n\t\tb = append(b, \" (\"...)\n\t\tb, err = q.AppendColumns(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb = append(b, \")\"...)\n\t}\n\tb = append(b, \")\"...)\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) addTable(table schema.QueryWithArgs) {\n\tq.tables = append(q.tables, table)\n}\n\nfunc (q *baseQuery) addColumn(column schema.QueryWithArgs) {\n\tq.columns = append(q.columns, column)\n}\n\nfunc (q *baseQuery) excludeColumn(columns []string) {\n\tif q.table == nil {\n\t\tq.setErr(errNilModel)\n\t\treturn\n\t}\n\n\tif q.columns == nil {\n\t\tfor _, f := range q.table.Fields {\n\t\t\tq.columns = append(q.columns, schema.UnsafeIdent(f.Name))\n\t\t}\n\t}\n\n\tif len(columns) == 1 && columns[0] == \"*\" {\n\t\tq.columns = make([]schema.QueryWithArgs, 0)\n\t\treturn\n\t}\n\n\tfor _, column := range columns {\n\t\tif !q._excludeColumn(column) {\n\t\t\tq.setErr(fmt.Errorf(\"bun: can't find column=%q\", column))\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (q *baseQuery) _excludeColumn(column string) bool {\n\tfor i, col := range q.columns {\n\t\tif col.Args == nil && col.Query == column {\n\t\t\tq.columns = append(q.columns[:i], q.columns[i+1:]...)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) modelHasTableName() bool {\n\tif !q.modelTableName.IsZero() {\n\t\treturn q.modelTableName.Query != \"\"\n\t}\n\treturn q.table != nil\n}\n\nfunc (q *baseQuery) hasTables() bool {\n\treturn q.modelHasTableName() || len(q.tables) > 0\n}\n\nfunc (q *baseQuery) appendTables(\n\tfmter schema.Formatter, b []byte,\n) (_ []byte, err error) {\n\treturn q._appendTables(fmter, b, false)\n}\n\nfunc (q *baseQuery) appendTablesWithAlias(\n\tfmter schema.Formatter, b []byte,\n) (_ []byte, err error) {\n\treturn q._appendTables(fmter, b, true)\n}\n\nfunc (q *baseQuery) _appendTables(\n\tfmter schema.Formatter, b []byte, withAlias bool,\n) (_ []byte, err error) {\n\tstartLen := len(b)\n\n\tif q.modelHasTableName() {\n\t\tif !q.modelTableName.IsZero() {\n\t\t\tb, err = q.modelTableName.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tb = fmter.AppendQuery(b, string(q.table.SQLNameForSelects))\n\t\t\tif withAlias && q.table.SQLAlias != q.table.SQLNameForSelects {\n\t\t\t\tif q.db.dialect.Name() == dialect.Oracle {\n\t\t\t\t\tb = append(b, ' ')\n\t\t\t\t} else {\n\t\t\t\t\tb = append(b, \" AS \"...)\n\t\t\t\t}\n\t\t\t\tb = append(b, q.table.SQLAlias...)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, table := range q.tables {\n\t\tif len(b) > startLen {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = table.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *baseQuery) appendFirstTable(fmter schema.Formatter, b []byte) ([]byte, error) {\n\treturn q._appendFirstTable(fmter, b, false)\n}\n\nfunc (q *baseQuery) appendFirstTableWithAlias(\n\tfmter schema.Formatter, b []byte,\n) ([]byte, error) {\n\treturn q._appendFirstTable(fmter, b, true)\n}\n\nfunc (q *baseQuery) _appendFirstTable(\n\tfmter schema.Formatter, b []byte, withAlias bool,\n) ([]byte, error) {\n\tif !q.modelTableName.IsZero() {\n\t\treturn q.modelTableName.AppendQuery(fmter, b)\n\t}\n\n\tif q.table != nil {\n\t\tb = fmter.AppendQuery(b, string(q.table.SQLName))\n\t\tif withAlias {\n\t\t\tb = append(b, \" AS \"...)\n\t\t\tb = append(b, q.table.SQLAlias...)\n\t\t}\n\t\treturn b, nil\n\t}\n\n\tif len(q.tables) > 0 {\n\t\treturn q.tables[0].AppendQuery(fmter, b)\n\t}\n\n\treturn nil, errors.New(\"bun: query does not have a table\")\n}\n\nfunc (q *baseQuery) hasMultiTables() bool {\n\tif q.modelHasTableName() {\n\t\treturn len(q.tables) >= 1\n\t}\n\treturn len(q.tables) >= 2\n}\n\nfunc (q *baseQuery) appendOtherTables(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\ttables := q.tables\n\tif !q.modelHasTableName() {\n\t\ttables = tables[1:]\n\t}\n\tfor i, table := range tables {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = table.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) appendColumns(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tfor i, f := range q.columns {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = f.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\nfunc (q *baseQuery) getFields() ([]*schema.Field, error) {\n\tif len(q.columns) == 0 {\n\t\tif q.table == nil {\n\t\t\treturn nil, errNilModel\n\t\t}\n\t\treturn q.table.Fields, nil\n\t}\n\treturn q._getFields(false)\n}\n\nfunc (q *baseQuery) getDataFields() ([]*schema.Field, error) {\n\tif len(q.columns) == 0 {\n\t\tif q.table == nil {\n\t\t\treturn nil, errNilModel\n\t\t}\n\t\treturn q.table.DataFields, nil\n\t}\n\treturn q._getFields(true)\n}\n\nfunc (q *baseQuery) _getFields(omitPK bool) ([]*schema.Field, error) {\n\tfields := make([]*schema.Field, 0, len(q.columns))\n\tfor _, col := range q.columns {\n\t\tif col.Args != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tfield, err := q.table.Field(col.Query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif omitPK && field.IsPK {\n\t\t\tcontinue\n\t\t}\n\n\t\tfields = append(fields, field)\n\t}\n\treturn fields, nil\n}\n\nfunc (q *baseQuery) scan(\n\tctx context.Context,\n\tiquery Query,\n\tquery string,\n\tmodel Model,\n\thasDest bool,\n) (sql.Result, error) {\n\tctx, event := q.db.beforeQuery(ctx, iquery, query, nil, query, q.model)\n\n\trows, err := q.conn.QueryContext(ctx, query)\n\tif err != nil {\n\t\tq.db.afterQuery(ctx, event, nil, err)\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tnumRow, err := model.ScanRows(ctx, rows)\n\tif err != nil {\n\t\tq.db.afterQuery(ctx, event, nil, err)\n\t\treturn nil, err\n\t}\n\n\tif numRow == 0 && hasDest && isSingleRowModel(model) {\n\t\terr = sql.ErrNoRows\n\t}\n\n\tres := driver.RowsAffected(numRow)\n\tq.db.afterQuery(ctx, event, res, err)\n\n\treturn res, err\n}\n\nfunc (q *baseQuery) exec(\n\tctx context.Context,\n\tiquery Query,\n\tquery string,\n) (sql.Result, error) {\n\tctx, event := q.db.beforeQuery(ctx, iquery, query, nil, query, q.model)\n\tres, err := q.conn.ExecContext(ctx, query)\n\tq.db.afterQuery(ctx, event, res, err)\n\treturn res, err\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) AppendNamedArg(fmter schema.Formatter, b []byte, name string) ([]byte, bool) {\n\tif q.table == nil {\n\t\treturn b, false\n\t}\n\n\tif m, ok := q.tableModel.(*structTableModel); ok {\n\t\tif b, ok := m.AppendNamedArg(fmter, b, name); ok {\n\t\t\treturn b, ok\n\t\t}\n\t}\n\n\tswitch name {\n\tcase \"TableName\":\n\t\tb = fmter.AppendQuery(b, string(q.table.SQLName))\n\t\treturn b, true\n\tcase \"TableAlias\":\n\t\tb = fmter.AppendQuery(b, string(q.table.SQLAlias))\n\t\treturn b, true\n\tcase \"PKs\":\n\t\tb = appendColumns(b, \"\", q.table.PKs)\n\t\treturn b, true\n\tcase \"TablePKs\":\n\t\tb = appendColumns(b, q.table.SQLAlias, q.table.PKs)\n\t\treturn b, true\n\tcase \"Columns\":\n\t\tb = appendColumns(b, \"\", q.table.Fields)\n\t\treturn b, true\n\tcase \"TableColumns\":\n\t\tb = appendColumns(b, q.table.SQLAlias, q.table.Fields)\n\t\treturn b, true\n\t}\n\n\treturn b, false\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *baseQuery) Dialect() schema.Dialect {\n\treturn q.db.Dialect()\n}\n\nfunc (q *baseQuery) NewValues(model interface{}) *ValuesQuery {\n\treturn NewValuesQuery(q.db, model).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewSelect() *SelectQuery {\n\treturn NewSelectQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewInsert() *InsertQuery {\n\treturn NewInsertQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewUpdate() *UpdateQuery {\n\treturn NewUpdateQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewDelete() *DeleteQuery {\n\treturn NewDeleteQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewRaw(query string, args ...interface{}) *RawQuery {\n\treturn NewRawQuery(q.db, query, args...).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewCreateTable() *CreateTableQuery {\n\treturn NewCreateTableQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewDropTable() *DropTableQuery {\n\treturn NewDropTableQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewCreateIndex() *CreateIndexQuery {\n\treturn NewCreateIndexQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewDropIndex() *DropIndexQuery {\n\treturn NewDropIndexQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewTruncateTable() *TruncateTableQuery {\n\treturn NewTruncateTableQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewAddColumn() *AddColumnQuery {\n\treturn NewAddColumnQuery(q.db).Conn(q.conn)\n}\n\nfunc (q *baseQuery) NewDropColumn() *DropColumnQuery {\n\treturn NewDropColumnQuery(q.db).Conn(q.conn)\n}\n\n//------------------------------------------------------------------------------\n\nfunc appendColumns(b []byte, table schema.Safe, fields []*schema.Field) []byte {\n\tfor i, f := range fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tif len(table) > 0 {\n\t\t\tb = append(b, table...)\n\t\t\tb = append(b, '.')\n\t\t}\n\t\tb = append(b, f.SQLName...)\n\t}\n\treturn b\n}\n\nfunc formatterWithModel(fmter schema.Formatter, model schema.NamedArgAppender) schema.Formatter {\n\tif fmter.IsNop() {\n\t\treturn fmter\n\t}\n\treturn fmter.WithArg(model)\n}\n\n//------------------------------------------------------------------------------\n\ntype whereBaseQuery struct {\n\tbaseQuery\n\n\twhere       []schema.QueryWithSep\n\twhereFields []*schema.Field\n}\n\nfunc (q *whereBaseQuery) addWhere(where schema.QueryWithSep) {\n\tq.where = append(q.where, where)\n}\n\nfunc (q *whereBaseQuery) addWhereGroup(sep string, where []schema.QueryWithSep) {\n\tif len(where) == 0 {\n\t\treturn\n\t}\n\n\tq.addWhere(schema.SafeQueryWithSep(\"\", nil, sep))\n\tq.addWhere(schema.SafeQueryWithSep(\"\", nil, \"(\"))\n\n\twhere[0].Sep = \"\"\n\tq.where = append(q.where, where...)\n\n\tq.addWhere(schema.SafeQueryWithSep(\"\", nil, \")\"))\n}\n\nfunc (q *whereBaseQuery) addWhereCols(cols []string) {\n\tif q.table == nil {\n\t\terr := fmt.Errorf(\"bun: got %T, but WherePK requires a struct or slice-based model\", q.model)\n\t\tq.setErr(err)\n\t\treturn\n\t}\n\tif q.whereFields != nil {\n\t\terr := errors.New(\"bun: WherePK can only be called once\")\n\t\tq.setErr(err)\n\t\treturn\n\t}\n\n\tif cols == nil {\n\t\tif err := q.table.CheckPKs(); err != nil {\n\t\t\tq.setErr(err)\n\t\t\treturn\n\t\t}\n\t\tq.whereFields = q.table.PKs\n\t\treturn\n\t}\n\n\tq.whereFields = make([]*schema.Field, len(cols))\n\tfor i, col := range cols {\n\t\tfield, err := q.table.Field(col)\n\t\tif err != nil {\n\t\t\tq.setErr(err)\n\t\t\treturn\n\t\t}\n\t\tq.whereFields[i] = field\n\t}\n}\n\nfunc (q *whereBaseQuery) mustAppendWhere(\n\tfmter schema.Formatter, b []byte, withAlias bool,\n) ([]byte, error) {\n\tif len(q.where) == 0 && q.whereFields == nil && !q.flags.Has(deletedFlag) {\n\t\terr := errors.New(\"bun: Update and Delete queries require at least one Where\")\n\t\treturn nil, err\n\t}\n\treturn q.appendWhere(fmter, b, withAlias)\n}\n\nfunc (q *whereBaseQuery) appendWhere(\n\tfmter schema.Formatter, b []byte, withAlias bool,\n) (_ []byte, err error) {\n\tif len(q.where) == 0 && q.whereFields == nil && !q.isSoftDelete() {\n\t\treturn b, nil\n\t}\n\n\tb = append(b, \" WHERE \"...)\n\tstartLen := len(b)\n\n\tif len(q.where) > 0 {\n\t\tb, err = appendWhere(fmter, b, q.where)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.isSoftDelete() {\n\t\tif len(b) > startLen {\n\t\t\tb = append(b, \" AND \"...)\n\t\t}\n\n\t\tif withAlias {\n\t\t\tb = append(b, q.tableModel.Table().SQLAlias...)\n\t\t} else {\n\t\t\tb = append(b, q.tableModel.Table().SQLName...)\n\t\t}\n\t\tb = append(b, '.')\n\n\t\tfield := q.tableModel.Table().SoftDeleteField\n\t\tb = append(b, field.SQLName...)\n\n\t\tif field.IsPtr || field.NullZero {\n\t\t\tif q.flags.Has(deletedFlag) {\n\t\t\t\tb = append(b, \" IS NOT NULL\"...)\n\t\t\t} else {\n\t\t\t\tb = append(b, \" IS NULL\"...)\n\t\t\t}\n\t\t} else {\n\t\t\tif q.flags.Has(deletedFlag) {\n\t\t\t\tb = append(b, \" != \"...)\n\t\t\t} else {\n\t\t\t\tb = append(b, \" = \"...)\n\t\t\t}\n\t\t\tb = fmter.Dialect().AppendTime(b, time.Time{})\n\t\t}\n\t}\n\n\tif q.whereFields != nil {\n\t\tif len(b) > startLen {\n\t\t\tb = append(b, \" AND \"...)\n\t\t}\n\t\tb, err = q.appendWhereFields(fmter, b, q.whereFields, withAlias)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc appendWhere(\n\tfmter schema.Formatter, b []byte, where []schema.QueryWithSep,\n) (_ []byte, err error) {\n\tfor i, where := range where {\n\t\tif i > 0 {\n\t\t\tb = append(b, where.Sep...)\n\t\t}\n\n\t\tif where.Query == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tb = append(b, '(')\n\t\tb, err = where.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb = append(b, ')')\n\t}\n\treturn b, nil\n}\n\nfunc (q *whereBaseQuery) appendWhereFields(\n\tfmter schema.Formatter, b []byte, fields []*schema.Field, withAlias bool,\n) (_ []byte, err error) {\n\tif q.table == nil {\n\t\terr := fmt.Errorf(\"bun: got %T, but WherePK requires struct or slice-based model\", q.model)\n\t\treturn nil, err\n\t}\n\n\tswitch model := q.tableModel.(type) {\n\tcase *structTableModel:\n\t\treturn q.appendWhereStructFields(fmter, b, model, fields, withAlias)\n\tcase *sliceTableModel:\n\t\treturn q.appendWhereSliceFields(fmter, b, model, fields, withAlias)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"bun: WhereColumn does not support %T\", q.tableModel)\n\t}\n}\n\nfunc (q *whereBaseQuery) appendWhereStructFields(\n\tfmter schema.Formatter,\n\tb []byte,\n\tmodel *structTableModel,\n\tfields []*schema.Field,\n\twithAlias bool,\n) (_ []byte, err error) {\n\tif !model.strct.IsValid() {\n\t\treturn nil, errNilModel\n\t}\n\n\tisTemplate := fmter.IsNop()\n\tb = append(b, '(')\n\tfor i, f := range fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \" AND \"...)\n\t\t}\n\t\tif withAlias {\n\t\t\tb = append(b, q.table.SQLAlias...)\n\t\t\tb = append(b, '.')\n\t\t}\n\t\tb = append(b, f.SQLName...)\n\t\tb = append(b, \" = \"...)\n\t\tif isTemplate {\n\t\t\tb = append(b, '?')\n\t\t} else {\n\t\t\tb = f.AppendValue(fmter, b, model.strct)\n\t\t}\n\t}\n\tb = append(b, ')')\n\treturn b, nil\n}\n\nfunc (q *whereBaseQuery) appendWhereSliceFields(\n\tfmter schema.Formatter,\n\tb []byte,\n\tmodel *sliceTableModel,\n\tfields []*schema.Field,\n\twithAlias bool,\n) (_ []byte, err error) {\n\tif len(fields) > 1 {\n\t\tb = append(b, '(')\n\t}\n\tif withAlias {\n\t\tb = appendColumns(b, q.table.SQLAlias, fields)\n\t} else {\n\t\tb = appendColumns(b, \"\", fields)\n\t}\n\tif len(fields) > 1 {\n\t\tb = append(b, ')')\n\t}\n\n\tb = append(b, \" IN (\"...)\n\n\tisTemplate := fmter.IsNop()\n\tslice := model.slice\n\tsliceLen := slice.Len()\n\tfor i := 0; i < sliceLen; i++ {\n\t\tif i > 0 {\n\t\t\tif isTemplate {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tel := indirect(slice.Index(i))\n\n\t\tif len(fields) > 1 {\n\t\t\tb = append(b, '(')\n\t\t}\n\t\tfor i, f := range fields {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tif isTemplate {\n\t\t\t\tb = append(b, '?')\n\t\t\t} else {\n\t\t\t\tb = f.AppendValue(fmter, b, el)\n\t\t\t}\n\t\t}\n\t\tif len(fields) > 1 {\n\t\t\tb = append(b, ')')\n\t\t}\n\t}\n\n\tb = append(b, ')')\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype returningQuery struct {\n\treturning       []schema.QueryWithArgs\n\treturningFields []*schema.Field\n}\n\nfunc (q *returningQuery) addReturning(ret schema.QueryWithArgs) {\n\tq.returning = append(q.returning, ret)\n}\n\nfunc (q *returningQuery) addReturningField(field *schema.Field) {\n\tif len(q.returning) > 0 {\n\t\treturn\n\t}\n\tfor _, f := range q.returningFields {\n\t\tif f == field {\n\t\t\treturn\n\t\t}\n\t}\n\tq.returningFields = append(q.returningFields, field)\n}\n\nfunc (q *returningQuery) appendReturning(\n\tfmter schema.Formatter, b []byte,\n) (_ []byte, err error) {\n\treturn q._appendReturning(fmter, b, \"\")\n}\n\nfunc (q *returningQuery) appendOutput(\n\tfmter schema.Formatter, b []byte,\n) (_ []byte, err error) {\n\treturn q._appendReturning(fmter, b, \"INSERTED\")\n}\n\nfunc (q *returningQuery) _appendReturning(\n\tfmter schema.Formatter, b []byte, table string,\n) (_ []byte, err error) {\n\tfor i, f := range q.returning {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = f.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(q.returning) > 0 {\n\t\treturn b, nil\n\t}\n\n\tb = appendColumns(b, schema.Safe(table), q.returningFields)\n\treturn b, nil\n}\n\nfunc (q *returningQuery) hasReturning() bool {\n\tif len(q.returning) == 1 {\n\t\tif ret := q.returning[0]; len(ret.Args) == 0 {\n\t\t\tswitch ret.Query {\n\t\t\tcase \"\", \"null\", \"NULL\":\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn len(q.returning) > 0 || len(q.returningFields) > 0\n}\n\n//------------------------------------------------------------------------------\n\ntype columnValue struct {\n\tcolumn string\n\tvalue  schema.QueryWithArgs\n}\n\ntype customValueQuery struct {\n\tmodelValues map[string]schema.QueryWithArgs\n\textraValues []columnValue\n}\n\nfunc (q *customValueQuery) addValue(\n\ttable *schema.Table, column string, value string, args []interface{},\n) {\n\tok := false\n\tif table != nil {\n\t\t_, ok = table.FieldMap[column]\n\t}\n\n\tif ok {\n\t\tif q.modelValues == nil {\n\t\t\tq.modelValues = make(map[string]schema.QueryWithArgs)\n\t\t}\n\t\tq.modelValues[column] = schema.SafeQuery(value, args)\n\t} else {\n\t\tq.extraValues = append(q.extraValues, columnValue{\n\t\t\tcolumn: column,\n\t\t\tvalue:  schema.SafeQuery(value, args),\n\t\t})\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype setQuery struct {\n\tset []schema.QueryWithArgs\n}\n\nfunc (q *setQuery) addSet(set schema.QueryWithArgs) {\n\tq.set = append(q.set, set)\n}\n\nfunc (q setQuery) appendSet(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tfor i, f := range q.set {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = f.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype cascadeQuery struct {\n\tcascade  bool\n\trestrict bool\n}\n\nfunc (q cascadeQuery) appendCascade(fmter schema.Formatter, b []byte) []byte {\n\tif !fmter.HasFeature(feature.TableCascade) {\n\t\treturn b\n\t}\n\tif q.cascade {\n\t\tb = append(b, \" CASCADE\"...)\n\t}\n\tif q.restrict {\n\t\tb = append(b, \" RESTRICT\"...)\n\t}\n\treturn b\n}\n\n//------------------------------------------------------------------------------\n\ntype idxHintsQuery struct {\n\tuse    *indexHints\n\tignore *indexHints\n\tforce  *indexHints\n}\n\ntype indexHints struct {\n\tnames      []schema.QueryWithArgs\n\tforJoin    []schema.QueryWithArgs\n\tforOrderBy []schema.QueryWithArgs\n\tforGroupBy []schema.QueryWithArgs\n}\n\nfunc (ih *idxHintsQuery) lazyUse() *indexHints {\n\tif ih.use == nil {\n\t\tih.use = new(indexHints)\n\t}\n\treturn ih.use\n}\n\nfunc (ih *idxHintsQuery) lazyIgnore() *indexHints {\n\tif ih.ignore == nil {\n\t\tih.ignore = new(indexHints)\n\t}\n\treturn ih.ignore\n}\n\nfunc (ih *idxHintsQuery) lazyForce() *indexHints {\n\tif ih.force == nil {\n\t\tih.force = new(indexHints)\n\t}\n\treturn ih.force\n}\n\nfunc (ih *idxHintsQuery) appendIndexes(hints []schema.QueryWithArgs, indexes ...string) []schema.QueryWithArgs {\n\tfor _, idx := range indexes {\n\t\thints = append(hints, schema.UnsafeIdent(idx))\n\t}\n\treturn hints\n}\n\nfunc (ih *idxHintsQuery) addUseIndex(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyUse().names = ih.appendIndexes(ih.use.names, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addUseIndexForJoin(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyUse().forJoin = ih.appendIndexes(ih.use.forJoin, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addUseIndexForOrderBy(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyUse().forOrderBy = ih.appendIndexes(ih.use.forOrderBy, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addUseIndexForGroupBy(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyUse().forGroupBy = ih.appendIndexes(ih.use.forGroupBy, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addIgnoreIndex(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyIgnore().names = ih.appendIndexes(ih.ignore.names, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addIgnoreIndexForJoin(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyIgnore().forJoin = ih.appendIndexes(ih.ignore.forJoin, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addIgnoreIndexForOrderBy(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyIgnore().forOrderBy = ih.appendIndexes(ih.ignore.forOrderBy, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addIgnoreIndexForGroupBy(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyIgnore().forGroupBy = ih.appendIndexes(ih.ignore.forGroupBy, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addForceIndex(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyForce().names = ih.appendIndexes(ih.force.names, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addForceIndexForJoin(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyForce().forJoin = ih.appendIndexes(ih.force.forJoin, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addForceIndexForOrderBy(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyForce().forOrderBy = ih.appendIndexes(ih.force.forOrderBy, indexes...)\n}\n\nfunc (ih *idxHintsQuery) addForceIndexForGroupBy(indexes ...string) {\n\tif len(indexes) == 0 {\n\t\treturn\n\t}\n\tih.lazyForce().forGroupBy = ih.appendIndexes(ih.force.forGroupBy, indexes...)\n}\n\nfunc (ih *idxHintsQuery) appendIndexHints(\n\tfmter schema.Formatter, b []byte,\n) ([]byte, error) {\n\ttype IdxHint struct {\n\t\tName   string\n\t\tValues []schema.QueryWithArgs\n\t}\n\n\tvar hints []IdxHint\n\tif ih.use != nil {\n\t\thints = append(hints, []IdxHint{\n\t\t\t{\n\t\t\t\tName:   \"USE INDEX\",\n\t\t\t\tValues: ih.use.names,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"USE INDEX FOR JOIN\",\n\t\t\t\tValues: ih.use.forJoin,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"USE INDEX FOR ORDER BY\",\n\t\t\t\tValues: ih.use.forOrderBy,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"USE INDEX FOR GROUP BY\",\n\t\t\t\tValues: ih.use.forGroupBy,\n\t\t\t},\n\t\t}...)\n\t}\n\n\tif ih.ignore != nil {\n\t\thints = append(hints, []IdxHint{\n\t\t\t{\n\t\t\t\tName:   \"IGNORE INDEX\",\n\t\t\t\tValues: ih.ignore.names,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"IGNORE INDEX FOR JOIN\",\n\t\t\t\tValues: ih.ignore.forJoin,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"IGNORE INDEX FOR ORDER BY\",\n\t\t\t\tValues: ih.ignore.forOrderBy,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"IGNORE INDEX FOR GROUP BY\",\n\t\t\t\tValues: ih.ignore.forGroupBy,\n\t\t\t},\n\t\t}...)\n\t}\n\n\tif ih.force != nil {\n\t\thints = append(hints, []IdxHint{\n\t\t\t{\n\t\t\t\tName:   \"FORCE INDEX\",\n\t\t\t\tValues: ih.force.names,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"FORCE INDEX FOR JOIN\",\n\t\t\t\tValues: ih.force.forJoin,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"FORCE INDEX FOR ORDER BY\",\n\t\t\t\tValues: ih.force.forOrderBy,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"FORCE INDEX FOR GROUP BY\",\n\t\t\t\tValues: ih.force.forGroupBy,\n\t\t\t},\n\t\t}...)\n\t}\n\n\tvar err error\n\tfor _, h := range hints {\n\t\tb, err = ih.bufIndexHint(h.Name, h.Values, fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\nfunc (ih *idxHintsQuery) bufIndexHint(\n\tname string,\n\thints []schema.QueryWithArgs,\n\tfmter schema.Formatter, b []byte,\n) ([]byte, error) {\n\tvar err error\n\tif len(hints) == 0 {\n\t\treturn b, nil\n\t}\n\tb = append(b, fmt.Sprintf(\" %s (\", name)...)\n\tfor i, f := range hints {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = f.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tb = append(b, \")\"...)\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype orderLimitOffsetQuery struct {\n\torder []schema.QueryWithArgs\n\n\tlimit  int32\n\toffset int32\n}\n\nfunc (q *orderLimitOffsetQuery) addOrder(orders ...string) {\n\tfor _, order := range orders {\n\t\tif order == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tindex := strings.IndexByte(order, ' ')\n\t\tif index == -1 {\n\t\t\tq.order = append(q.order, schema.UnsafeIdent(order))\n\t\t\tcontinue\n\t\t}\n\n\t\tfield := order[:index]\n\t\tsort := order[index+1:]\n\n\t\tswitch strings.ToUpper(sort) {\n\t\tcase \"ASC\", \"DESC\", \"ASC NULLS FIRST\", \"DESC NULLS FIRST\",\n\t\t\t\"ASC NULLS LAST\", \"DESC NULLS LAST\":\n\t\t\tq.order = append(q.order, schema.SafeQuery(\"? ?\", []interface{}{\n\t\t\t\tIdent(field),\n\t\t\t\tSafe(sort),\n\t\t\t}))\n\t\tdefault:\n\t\t\tq.order = append(q.order, schema.UnsafeIdent(order))\n\t\t}\n\t}\n\n}\n\nfunc (q *orderLimitOffsetQuery) addOrderExpr(query string, args ...interface{}) {\n\tq.order = append(q.order, schema.SafeQuery(query, args))\n}\n\nfunc (q *orderLimitOffsetQuery) appendOrder(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif len(q.order) > 0 {\n\t\tb = append(b, \" ORDER BY \"...)\n\n\t\tfor i, f := range q.order {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb, err = f.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\treturn b, nil\n\t}\n\n\t// MSSQL: allows Limit() without Order() as per https://stackoverflow.com/a/36156953\n\tif q.limit > 0 && fmter.Dialect().Name() == dialect.MSSQL {\n\t\treturn append(b, \" ORDER BY _temp_sort\"...), nil\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *orderLimitOffsetQuery) setLimit(n int) {\n\tq.limit = int32(n)\n}\n\nfunc (q *orderLimitOffsetQuery) setOffset(n int) {\n\tq.offset = int32(n)\n}\n\nfunc (q *orderLimitOffsetQuery) appendLimitOffset(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif fmter.Dialect().Features().Has(feature.OffsetFetch) {\n\t\tif q.limit > 0 && q.offset > 0 {\n\t\t\tb = append(b, \" OFFSET \"...)\n\t\t\tb = strconv.AppendInt(b, int64(q.offset), 10)\n\t\t\tb = append(b, \" ROWS\"...)\n\n\t\t\tb = append(b, \" FETCH NEXT \"...)\n\t\t\tb = strconv.AppendInt(b, int64(q.limit), 10)\n\t\t\tb = append(b, \" ROWS ONLY\"...)\n\t\t} else if q.limit > 0 {\n\t\t\tb = append(b, \" OFFSET 0 ROWS\"...)\n\n\t\t\tb = append(b, \" FETCH NEXT \"...)\n\t\t\tb = strconv.AppendInt(b, int64(q.limit), 10)\n\t\t\tb = append(b, \" ROWS ONLY\"...)\n\t\t} else if q.offset > 0 {\n\t\t\tb = append(b, \" OFFSET \"...)\n\t\t\tb = strconv.AppendInt(b, int64(q.offset), 10)\n\t\t\tb = append(b, \" ROWS\"...)\n\t\t}\n\t} else {\n\t\tif q.limit > 0 {\n\t\t\tb = append(b, \" LIMIT \"...)\n\t\t\tb = strconv.AppendInt(b, int64(q.limit), 10)\n\t\t}\n\t\tif q.offset > 0 {\n\t\t\tb = append(b, \" OFFSET \"...)\n\t\t\tb = strconv.AppendInt(b, int64(q.offset), 10)\n\t\t}\n\t}\n\n\treturn b, nil\n}\n"
        },
        {
          "name": "query_column_add.go",
          "type": "blob",
          "size": 3.0341796875,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype AddColumnQuery struct {\n\tbaseQuery\n\n\tifNotExists bool\n\tcomment     string\n}\n\nvar _ Query = (*AddColumnQuery)(nil)\n\nfunc NewAddColumnQuery(db *DB) *AddColumnQuery {\n\tq := &AddColumnQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *AddColumnQuery) Conn(db IConn) *AddColumnQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *AddColumnQuery) Model(model interface{}) *AddColumnQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *AddColumnQuery) Err(err error) *AddColumnQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the AddColumnQuery as an argument.\nfunc (q *AddColumnQuery) Apply(fns ...func(*AddColumnQuery) *AddColumnQuery) *AddColumnQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *AddColumnQuery) Table(tables ...string) *AddColumnQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *AddColumnQuery) TableExpr(query string, args ...interface{}) *AddColumnQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *AddColumnQuery) ModelTableExpr(query string, args ...interface{}) *AddColumnQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *AddColumnQuery) ColumnExpr(query string, args ...interface{}) *AddColumnQuery {\n\tq.addColumn(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *AddColumnQuery) IfNotExists() *AddColumnQuery {\n\tq.ifNotExists = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *AddColumnQuery) Comment(comment string) *AddColumnQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *AddColumnQuery) Operation() string {\n\treturn \"ADD COLUMN\"\n}\n\nfunc (q *AddColumnQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tif len(q.columns) != 1 {\n\t\treturn nil, fmt.Errorf(\"bun: AddColumnQuery requires exactly one column\")\n\t}\n\n\tb = append(b, \"ALTER TABLE \"...)\n\n\tb, err = q.appendFirstTable(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" ADD \"...)\n\n\tif q.ifNotExists {\n\t\tb = append(b, \"IF NOT EXISTS \"...)\n\t}\n\n\tb, err = q.columns[0].AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *AddColumnQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\treturn q.exec(ctx, q, query)\n}\n"
        },
        {
          "name": "query_column_drop.go",
          "type": "blob",
          "size": 3.12109375,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype DropColumnQuery struct {\n\tbaseQuery\n\n\tcomment string\n}\n\nvar _ Query = (*DropColumnQuery)(nil)\n\nfunc NewDropColumnQuery(db *DB) *DropColumnQuery {\n\tq := &DropColumnQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *DropColumnQuery) Conn(db IConn) *DropColumnQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *DropColumnQuery) Model(model interface{}) *DropColumnQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *DropColumnQuery) Err(err error) *DropColumnQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the DropColumnQuery as an argument.\nfunc (q *DropColumnQuery) Apply(fns ...func(*DropColumnQuery) *DropColumnQuery) *DropColumnQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropColumnQuery) Table(tables ...string) *DropColumnQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *DropColumnQuery) TableExpr(query string, args ...interface{}) *DropColumnQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *DropColumnQuery) ModelTableExpr(query string, args ...interface{}) *DropColumnQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropColumnQuery) Column(columns ...string) *DropColumnQuery {\n\tfor _, column := range columns {\n\t\tq.addColumn(schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *DropColumnQuery) ColumnExpr(query string, args ...interface{}) *DropColumnQuery {\n\tq.addColumn(schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *DropColumnQuery) Comment(comment string) *DropColumnQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropColumnQuery) Operation() string {\n\treturn \"DROP COLUMN\"\n}\n\nfunc (q *DropColumnQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tif len(q.columns) != 1 {\n\t\treturn nil, fmt.Errorf(\"bun: DropColumnQuery requires exactly one column\")\n\t}\n\n\tb = append(b, \"ALTER TABLE \"...)\n\n\tb, err = q.appendFirstTable(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" DROP COLUMN \"...)\n\n\tb, err = q.columns[0].AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropColumnQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.exec(ctx, q, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n"
        },
        {
          "name": "query_delete.go",
          "type": "blob",
          "size": 9.7041015625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype DeleteQuery struct {\n\twhereBaseQuery\n\torderLimitOffsetQuery\n\treturningQuery\n\n\tcomment string\n}\n\nvar _ Query = (*DeleteQuery)(nil)\n\nfunc NewDeleteQuery(db *DB) *DeleteQuery {\n\tq := &DeleteQuery{\n\t\twhereBaseQuery: whereBaseQuery{\n\t\t\tbaseQuery: baseQuery{\n\t\t\t\tdb:   db,\n\t\t\t\tconn: db.DB,\n\t\t\t},\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *DeleteQuery) Conn(db IConn) *DeleteQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *DeleteQuery) Model(model interface{}) *DeleteQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *DeleteQuery) Err(err error) *DeleteQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the DeleteQuery as an argument.\nfunc (q *DeleteQuery) Apply(fns ...func(*DeleteQuery) *DeleteQuery) *DeleteQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\nfunc (q *DeleteQuery) With(name string, query schema.QueryAppender) *DeleteQuery {\n\tq.addWith(name, query, false)\n\treturn q\n}\n\nfunc (q *DeleteQuery) WithRecursive(name string, query schema.QueryAppender) *DeleteQuery {\n\tq.addWith(name, query, true)\n\treturn q\n}\n\nfunc (q *DeleteQuery) Table(tables ...string) *DeleteQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *DeleteQuery) TableExpr(query string, args ...interface{}) *DeleteQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *DeleteQuery) ModelTableExpr(query string, args ...interface{}) *DeleteQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DeleteQuery) WherePK(cols ...string) *DeleteQuery {\n\tq.addWhereCols(cols)\n\treturn q\n}\n\nfunc (q *DeleteQuery) Where(query string, args ...interface{}) *DeleteQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" AND \"))\n\treturn q\n}\n\nfunc (q *DeleteQuery) WhereOr(query string, args ...interface{}) *DeleteQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" OR \"))\n\treturn q\n}\n\nfunc (q *DeleteQuery) WhereGroup(sep string, fn func(*DeleteQuery) *DeleteQuery) *DeleteQuery {\n\tsaved := q.where\n\tq.where = nil\n\n\tq = fn(q)\n\n\twhere := q.where\n\tq.where = saved\n\n\tq.addWhereGroup(sep, where)\n\n\treturn q\n}\n\nfunc (q *DeleteQuery) WhereDeleted() *DeleteQuery {\n\tq.whereDeleted()\n\treturn q\n}\n\nfunc (q *DeleteQuery) WhereAllWithDeleted() *DeleteQuery {\n\tq.whereAllWithDeleted()\n\treturn q\n}\n\nfunc (q *DeleteQuery) Order(orders ...string) *DeleteQuery {\n\tif !q.hasFeature(feature.DeleteOrderLimit) {\n\t\tq.err = errors.New(\"bun: order is not supported for current dialect\")\n\t\treturn q\n\t}\n\tq.addOrder(orders...)\n\treturn q\n}\n\nfunc (q *DeleteQuery) OrderExpr(query string, args ...interface{}) *DeleteQuery {\n\tif !q.hasFeature(feature.DeleteOrderLimit) {\n\t\tq.err = errors.New(\"bun: order is not supported for current dialect\")\n\t\treturn q\n\t}\n\tq.addOrderExpr(query, args...)\n\treturn q\n}\n\nfunc (q *DeleteQuery) ForceDelete() *DeleteQuery {\n\tq.flags = q.flags.Set(forceDeleteFlag)\n\treturn q\n}\n\n// ------------------------------------------------------------------------------\nfunc (q *DeleteQuery) Limit(n int) *DeleteQuery {\n\tif !q.hasFeature(feature.DeleteOrderLimit) {\n\t\tq.err = errors.New(\"bun: limit is not supported for current dialect\")\n\t\treturn q\n\t}\n\tq.setLimit(n)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Returning adds a RETURNING clause to the query.\n//\n// To suppress the auto-generated RETURNING clause, use `Returning(\"NULL\")`.\nfunc (q *DeleteQuery) Returning(query string, args ...interface{}) *DeleteQuery {\n\tif !q.hasFeature(feature.DeleteReturning) {\n\t\tq.err = errors.New(\"bun: returning is not supported for current dialect\")\n\t\treturn q\n\t}\n\n\tq.addReturning(schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *DeleteQuery) Comment(comment string) *DeleteQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DeleteQuery) Operation() string {\n\treturn \"DELETE\"\n}\n\nfunc (q *DeleteQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tfmter = formatterWithModel(fmter, q)\n\n\tif q.isSoftDelete() {\n\t\tnow := time.Now()\n\n\t\tif err := q.tableModel.updateSoftDeleteField(now); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tupd := &UpdateQuery{\n\t\t\twhereBaseQuery: q.whereBaseQuery,\n\t\t\treturningQuery: q.returningQuery,\n\t\t}\n\t\tupd.Set(q.softDeleteSet(fmter, now))\n\n\t\treturn upd.AppendQuery(fmter, b)\n\t}\n\n\twithAlias := q.db.HasFeature(feature.DeleteTableAlias)\n\n\tb, err = q.appendWith(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \"DELETE FROM \"...)\n\n\tif withAlias {\n\t\tb, err = q.appendFirstTableWithAlias(fmter, b)\n\t} else {\n\t\tb, err = q.appendFirstTable(fmter, b)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.hasMultiTables() {\n\t\tb = append(b, \" USING \"...)\n\t\tb, err = q.appendOtherTables(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.hasFeature(feature.Output) && q.hasReturning() {\n\t\tb = append(b, \" OUTPUT \"...)\n\t\tb, err = q.appendOutput(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb, err = q.mustAppendWhere(fmter, b, withAlias)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.hasMultiTables() && (len(q.order) > 0 || q.limit > 0) {\n\t\treturn nil, errors.New(\"bun: can't use ORDER or LIMIT with multiple tables\")\n\t}\n\n\tb, err = q.appendOrder(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.appendLimitOffset(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.hasFeature(feature.DeleteReturning) && q.hasReturning() {\n\t\tb = append(b, \" RETURNING \"...)\n\t\tb, err = q.appendReturning(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *DeleteQuery) isSoftDelete() bool {\n\treturn q.tableModel != nil && q.table.SoftDeleteField != nil && !q.flags.Has(forceDeleteFlag)\n}\n\nfunc (q *DeleteQuery) softDeleteSet(fmter schema.Formatter, tm time.Time) string {\n\tb := make([]byte, 0, 32)\n\tif fmter.HasFeature(feature.UpdateMultiTable) {\n\t\tb = append(b, q.table.SQLAlias...)\n\t\tb = append(b, '.')\n\t}\n\tb = append(b, q.table.SoftDeleteField.SQLName...)\n\tb = append(b, \" = \"...)\n\tb = schema.Append(fmter, b, tm)\n\treturn internal.String(b)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DeleteQuery) Scan(ctx context.Context, dest ...interface{}) error {\n\t_, err := q.scanOrExec(ctx, dest, true)\n\treturn err\n}\n\nfunc (q *DeleteQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\treturn q.scanOrExec(ctx, dest, len(dest) > 0)\n}\n\nfunc (q *DeleteQuery) scanOrExec(\n\tctx context.Context, dest []interface{}, hasDest bool,\n) (sql.Result, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.beforeDeleteHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Run append model hooks before generating the query.\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Generate the query before checking hasReturning.\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuseScan := hasDest || (q.hasReturning() && q.hasFeature(feature.DeleteReturning|feature.Output))\n\tvar model Model\n\n\tif useScan {\n\t\tvar err error\n\t\tmodel, err = q.getModel(dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tvar res sql.Result\n\n\tif useScan {\n\t\tres, err = q.scan(ctx, q, query, model, hasDest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tres, err = q.exec(ctx, q, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.afterDeleteHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *DeleteQuery) beforeDeleteHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(BeforeDeleteHook); ok {\n\t\tif err := hook.BeforeDelete(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *DeleteQuery) afterDeleteHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(AfterDeleteHook); ok {\n\t\tif err := hook.AfterDelete(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *DeleteQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DeleteQuery) QueryBuilder() QueryBuilder {\n\treturn &deleteQueryBuilder{q}\n}\n\nfunc (q *DeleteQuery) ApplyQueryBuilder(fn func(QueryBuilder) QueryBuilder) *DeleteQuery {\n\treturn fn(q.QueryBuilder()).Unwrap().(*DeleteQuery)\n}\n\ntype deleteQueryBuilder struct {\n\t*DeleteQuery\n}\n\nfunc (q *deleteQueryBuilder) WhereGroup(\n\tsep string, fn func(QueryBuilder) QueryBuilder,\n) QueryBuilder {\n\tq.DeleteQuery = q.DeleteQuery.WhereGroup(sep, func(qs *DeleteQuery) *DeleteQuery {\n\t\treturn fn(q).(*deleteQueryBuilder).DeleteQuery\n\t})\n\treturn q\n}\n\nfunc (q *deleteQueryBuilder) Where(query string, args ...interface{}) QueryBuilder {\n\tq.DeleteQuery.Where(query, args...)\n\treturn q\n}\n\nfunc (q *deleteQueryBuilder) WhereOr(query string, args ...interface{}) QueryBuilder {\n\tq.DeleteQuery.WhereOr(query, args...)\n\treturn q\n}\n\nfunc (q *deleteQueryBuilder) WhereDeleted() QueryBuilder {\n\tq.DeleteQuery.WhereDeleted()\n\treturn q\n}\n\nfunc (q *deleteQueryBuilder) WhereAllWithDeleted() QueryBuilder {\n\tq.DeleteQuery.WhereAllWithDeleted()\n\treturn q\n}\n\nfunc (q *deleteQueryBuilder) WherePK(cols ...string) QueryBuilder {\n\tq.DeleteQuery.WherePK(cols...)\n\treturn q\n}\n\nfunc (q *deleteQueryBuilder) Unwrap() interface{} {\n\treturn q.DeleteQuery\n}\n"
        },
        {
          "name": "query_index_create.go",
          "type": "blob",
          "size": 5.6884765625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype CreateIndexQuery struct {\n\twhereBaseQuery\n\n\tunique       bool\n\tfulltext     bool\n\tspatial      bool\n\tconcurrently bool\n\tifNotExists  bool\n\n\tindex   schema.QueryWithArgs\n\tusing   schema.QueryWithArgs\n\tinclude []schema.QueryWithArgs\n\tcomment string\n}\n\nvar _ Query = (*CreateIndexQuery)(nil)\n\nfunc NewCreateIndexQuery(db *DB) *CreateIndexQuery {\n\tq := &CreateIndexQuery{\n\t\twhereBaseQuery: whereBaseQuery{\n\t\t\tbaseQuery: baseQuery{\n\t\t\t\tdb:   db,\n\t\t\t\tconn: db.DB,\n\t\t\t},\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) Conn(db IConn) *CreateIndexQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) Model(model interface{}) *CreateIndexQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) Err(err error) *CreateIndexQuery {\n\tq.setErr(err)\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) Unique() *CreateIndexQuery {\n\tq.unique = true\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) Concurrently() *CreateIndexQuery {\n\tq.concurrently = true\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) IfNotExists() *CreateIndexQuery {\n\tq.ifNotExists = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Index(query string) *CreateIndexQuery {\n\tq.index = schema.UnsafeIdent(query)\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) IndexExpr(query string, args ...interface{}) *CreateIndexQuery {\n\tq.index = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Table(tables ...string) *CreateIndexQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) TableExpr(query string, args ...interface{}) *CreateIndexQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) ModelTableExpr(query string, args ...interface{}) *CreateIndexQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) Using(query string, args ...interface{}) *CreateIndexQuery {\n\tq.using = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Column(columns ...string) *CreateIndexQuery {\n\tfor _, column := range columns {\n\t\tq.addColumn(schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) ColumnExpr(query string, args ...interface{}) *CreateIndexQuery {\n\tq.addColumn(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) ExcludeColumn(columns ...string) *CreateIndexQuery {\n\tq.excludeColumn(columns)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Include(columns ...string) *CreateIndexQuery {\n\tfor _, column := range columns {\n\t\tq.include = append(q.include, schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) IncludeExpr(query string, args ...interface{}) *CreateIndexQuery {\n\tq.include = append(q.include, schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Where(query string, args ...interface{}) *CreateIndexQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" AND \"))\n\treturn q\n}\n\nfunc (q *CreateIndexQuery) WhereOr(query string, args ...interface{}) *CreateIndexQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" OR \"))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *CreateIndexQuery) Comment(comment string) *CreateIndexQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Operation() string {\n\treturn \"CREATE INDEX\"\n}\n\nfunc (q *CreateIndexQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tb = append(b, \"CREATE \"...)\n\n\tif q.unique {\n\t\tb = append(b, \"UNIQUE \"...)\n\t}\n\tif q.fulltext {\n\t\tb = append(b, \"FULLTEXT \"...)\n\t}\n\tif q.spatial {\n\t\tb = append(b, \"SPATIAL \"...)\n\t}\n\n\tb = append(b, \"INDEX \"...)\n\n\tif q.concurrently {\n\t\tb = append(b, \"CONCURRENTLY \"...)\n\t}\n\tif q.ifNotExists {\n\t\tb = append(b, \"IF NOT EXISTS \"...)\n\t}\n\n\tb, err = q.index.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" ON \"...)\n\tb, err = q.appendFirstTable(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !q.using.IsZero() {\n\t\tb = append(b, \" USING \"...)\n\t\tb, err = q.using.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb = append(b, \" (\"...)\n\tfor i, col := range q.columns {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = col.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tb = append(b, ')')\n\n\tif len(q.include) > 0 {\n\t\tb = append(b, \" INCLUDE (\"...)\n\t\tfor i, col := range q.include {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb, err = col.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tb = append(b, ')')\n\t}\n\n\tif len(q.where) > 0 {\n\t\tb = append(b, \" WHERE \"...)\n\t\tb, err = appendWhere(fmter, b, q.where)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *CreateIndexQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.exec(ctx, q, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n"
        },
        {
          "name": "query_index_drop.go",
          "type": "blob",
          "size": 2.4921875,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype DropIndexQuery struct {\n\tbaseQuery\n\tcascadeQuery\n\n\tconcurrently bool\n\tifExists     bool\n\n\tindex   schema.QueryWithArgs\n\tcomment string\n}\n\nvar _ Query = (*DropIndexQuery)(nil)\n\nfunc NewDropIndexQuery(db *DB) *DropIndexQuery {\n\tq := &DropIndexQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *DropIndexQuery) Conn(db IConn) *DropIndexQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *DropIndexQuery) Model(model interface{}) *DropIndexQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *DropIndexQuery) Err(err error) *DropIndexQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropIndexQuery) Concurrently() *DropIndexQuery {\n\tq.concurrently = true\n\treturn q\n}\n\nfunc (q *DropIndexQuery) IfExists() *DropIndexQuery {\n\tq.ifExists = true\n\treturn q\n}\n\nfunc (q *DropIndexQuery) Cascade() *DropIndexQuery {\n\tq.cascade = true\n\treturn q\n}\n\nfunc (q *DropIndexQuery) Restrict() *DropIndexQuery {\n\tq.restrict = true\n\treturn q\n}\n\nfunc (q *DropIndexQuery) Index(query string, args ...interface{}) *DropIndexQuery {\n\tq.index = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *DropIndexQuery) Comment(comment string) *DropIndexQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropIndexQuery) Operation() string {\n\treturn \"DROP INDEX\"\n}\n\nfunc (q *DropIndexQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tb = append(b, \"DROP INDEX \"...)\n\n\tif q.concurrently {\n\t\tb = append(b, \"CONCURRENTLY \"...)\n\t}\n\tif q.ifExists {\n\t\tb = append(b, \"IF EXISTS \"...)\n\t}\n\n\tb, err = q.index.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = q.appendCascade(fmter, b)\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropIndexQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.exec(ctx, q, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n"
        },
        {
          "name": "query_insert.go",
          "type": "blob",
          "size": 14.994140625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype InsertQuery struct {\n\twhereBaseQuery\n\treturningQuery\n\tcustomValueQuery\n\n\ton schema.QueryWithArgs\n\tsetQuery\n\n\tignore  bool\n\treplace bool\n\tcomment string\n}\n\nvar _ Query = (*InsertQuery)(nil)\n\nfunc NewInsertQuery(db *DB) *InsertQuery {\n\tq := &InsertQuery{\n\t\twhereBaseQuery: whereBaseQuery{\n\t\t\tbaseQuery: baseQuery{\n\t\t\t\tdb:   db,\n\t\t\t\tconn: db.DB,\n\t\t\t},\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *InsertQuery) Conn(db IConn) *InsertQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *InsertQuery) Model(model interface{}) *InsertQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *InsertQuery) Err(err error) *InsertQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the InsertQuery as an argument.\nfunc (q *InsertQuery) Apply(fns ...func(*InsertQuery) *InsertQuery) *InsertQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\nfunc (q *InsertQuery) With(name string, query schema.QueryAppender) *InsertQuery {\n\tq.addWith(name, query, false)\n\treturn q\n}\n\nfunc (q *InsertQuery) WithRecursive(name string, query schema.QueryAppender) *InsertQuery {\n\tq.addWith(name, query, true)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *InsertQuery) Table(tables ...string) *InsertQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *InsertQuery) TableExpr(query string, args ...interface{}) *InsertQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *InsertQuery) ModelTableExpr(query string, args ...interface{}) *InsertQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *InsertQuery) Column(columns ...string) *InsertQuery {\n\tfor _, column := range columns {\n\t\tq.addColumn(schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *InsertQuery) ColumnExpr(query string, args ...interface{}) *InsertQuery {\n\tq.addColumn(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *InsertQuery) ExcludeColumn(columns ...string) *InsertQuery {\n\tq.excludeColumn(columns)\n\treturn q\n}\n\n// Value overwrites model value for the column.\nfunc (q *InsertQuery) Value(column string, expr string, args ...interface{}) *InsertQuery {\n\tif q.table == nil {\n\t\tq.err = errNilModel\n\t\treturn q\n\t}\n\tq.addValue(q.table, column, expr, args)\n\treturn q\n}\n\nfunc (q *InsertQuery) Where(query string, args ...interface{}) *InsertQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" AND \"))\n\treturn q\n}\n\nfunc (q *InsertQuery) WhereOr(query string, args ...interface{}) *InsertQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" OR \"))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Returning adds a RETURNING clause to the query.\n//\n// To suppress the auto-generated RETURNING clause, use `Returning(\"\")`.\nfunc (q *InsertQuery) Returning(query string, args ...interface{}) *InsertQuery {\n\tq.addReturning(schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Ignore generates different queries depending on the DBMS:\n//   - On MySQL, it generates `INSERT IGNORE INTO`.\n//   - On PostgreSQL, it generates `ON CONFLICT DO NOTHING`.\nfunc (q *InsertQuery) Ignore() *InsertQuery {\n\tif q.db.fmter.HasFeature(feature.InsertOnConflict) {\n\t\treturn q.On(\"CONFLICT DO NOTHING\")\n\t}\n\tif q.db.fmter.HasFeature(feature.InsertIgnore) {\n\t\tq.ignore = true\n\t}\n\treturn q\n}\n\n// Replaces generates a `REPLACE INTO` query (MySQL and MariaDB).\nfunc (q *InsertQuery) Replace() *InsertQuery {\n\tq.replace = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *InsertQuery) Comment(comment string) *InsertQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *InsertQuery) Operation() string {\n\treturn \"INSERT\"\n}\n\nfunc (q *InsertQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tfmter = formatterWithModel(fmter, q)\n\n\tb, err = q.appendWith(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.replace {\n\t\tb = append(b, \"REPLACE \"...)\n\t} else {\n\t\tb = append(b, \"INSERT \"...)\n\t\tif q.ignore {\n\t\t\tb = append(b, \"IGNORE \"...)\n\t\t}\n\t}\n\tb = append(b, \"INTO \"...)\n\n\tif q.db.HasFeature(feature.InsertTableAlias) && !q.on.IsZero() {\n\t\tb, err = q.appendFirstTableWithAlias(fmter, b)\n\t} else {\n\t\tb, err = q.appendFirstTable(fmter, b)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.appendColumnsValues(fmter, b, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.appendOn(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.hasFeature(feature.InsertReturning) && q.hasReturning() {\n\t\tb = append(b, \" RETURNING \"...)\n\t\tb, err = q.appendReturning(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *InsertQuery) appendColumnsValues(\n\tfmter schema.Formatter, b []byte, skipOutput bool,\n) (_ []byte, err error) {\n\tif q.hasMultiTables() {\n\t\tif q.columns != nil {\n\t\t\tb = append(b, \" (\"...)\n\t\t\tb, err = q.appendColumns(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tb = append(b, \")\"...)\n\t\t}\n\n\t\tif q.hasFeature(feature.Output) && q.hasReturning() {\n\t\t\tb = append(b, \" OUTPUT \"...)\n\t\t\tb, err = q.appendOutput(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tb = append(b, \" SELECT \"...)\n\n\t\tif q.columns != nil {\n\t\t\tb, err = q.appendColumns(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tb = append(b, \"*\"...)\n\t\t}\n\n\t\tb = append(b, \" FROM \"...)\n\t\tb, err = q.appendOtherTables(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn b, nil\n\t}\n\n\tif m, ok := q.model.(*mapModel); ok {\n\t\treturn m.appendColumnsValues(fmter, b), nil\n\t}\n\tif _, ok := q.model.(*mapSliceModel); ok {\n\t\treturn nil, fmt.Errorf(\"Insert(*[]map[string]interface{}) is not supported\")\n\t}\n\n\tif q.model == nil {\n\t\treturn nil, errNilModel\n\t}\n\n\t// Build fields to populate RETURNING clause.\n\tfields, err := q.getFields()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" (\"...)\n\tb = q.appendFields(fmter, b, fields)\n\tb = append(b, \")\"...)\n\n\tif q.hasFeature(feature.Output) && q.hasReturning() && !skipOutput {\n\t\tb = append(b, \" OUTPUT \"...)\n\t\tb, err = q.appendOutput(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb = append(b, \" VALUES (\"...)\n\n\tswitch model := q.tableModel.(type) {\n\tcase *structTableModel:\n\t\tb, err = q.appendStructValues(fmter, b, fields, model.strct)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase *sliceTableModel:\n\t\tb, err = q.appendSliceValues(fmter, b, fields, model.slice)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"bun: Insert does not support %T\", q.tableModel)\n\t}\n\n\tb = append(b, ')')\n\n\treturn b, nil\n}\n\nfunc (q *InsertQuery) appendStructValues(\n\tfmter schema.Formatter, b []byte, fields []*schema.Field, strct reflect.Value,\n) (_ []byte, err error) {\n\tisTemplate := fmter.IsNop()\n\tfor i, f := range fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tapp, ok := q.modelValues[f.Name]\n\t\tif ok {\n\t\t\tb, err = app.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tq.addReturningField(f)\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch {\n\t\tcase isTemplate:\n\t\t\tb = append(b, '?')\n\t\tcase q.marshalsToDefault(f, strct):\n\t\t\tif q.db.HasFeature(feature.DefaultPlaceholder) {\n\t\t\t\tb = append(b, \"DEFAULT\"...)\n\t\t\t} else if f.SQLDefault != \"\" {\n\t\t\t\tb = append(b, f.SQLDefault...)\n\t\t\t} else {\n\t\t\t\tb = append(b, \"NULL\"...)\n\t\t\t}\n\t\t\tq.addReturningField(f)\n\t\tdefault:\n\t\t\tb = f.AppendValue(fmter, b, strct)\n\t\t}\n\t}\n\n\tfor i, v := range q.extraValues {\n\t\tif i > 0 || len(fields) > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tb, err = v.value.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *InsertQuery) appendSliceValues(\n\tfmter schema.Formatter, b []byte, fields []*schema.Field, slice reflect.Value,\n) (_ []byte, err error) {\n\tif fmter.IsNop() {\n\t\treturn q.appendStructValues(fmter, b, fields, reflect.Value{})\n\t}\n\n\tsliceLen := slice.Len()\n\tfor i := 0; i < sliceLen; i++ {\n\t\tif i > 0 {\n\t\t\tb = append(b, \"), (\"...)\n\t\t}\n\t\tel := indirect(slice.Index(i))\n\t\tb, err = q.appendStructValues(fmter, b, fields, el)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *InsertQuery) getFields() ([]*schema.Field, error) {\n\thasIdentity := q.db.HasFeature(feature.Identity)\n\n\tif len(q.columns) > 0 || q.db.HasFeature(feature.DefaultPlaceholder) && !hasIdentity {\n\t\treturn q.baseQuery.getFields()\n\t}\n\n\tvar strct reflect.Value\n\n\tswitch model := q.tableModel.(type) {\n\tcase *structTableModel:\n\t\tstrct = model.strct\n\tcase *sliceTableModel:\n\t\tif model.sliceLen == 0 {\n\t\t\treturn nil, fmt.Errorf(\"bun: Insert(empty %T)\", model.slice.Type())\n\t\t}\n\t\tstrct = indirect(model.slice.Index(0))\n\tdefault:\n\t\treturn nil, errNilModel\n\t}\n\n\tfields := make([]*schema.Field, 0, len(q.table.Fields))\n\n\tfor _, f := range q.table.Fields {\n\t\tif hasIdentity && f.AutoIncrement {\n\t\t\tq.addReturningField(f)\n\t\t\tcontinue\n\t\t}\n\t\tif f.NotNull && q.marshalsToDefault(f, strct) {\n\t\t\tq.addReturningField(f)\n\t\t\tcontinue\n\t\t}\n\t\tfields = append(fields, f)\n\t}\n\n\treturn fields, nil\n}\n\n// marshalsToDefault checks if the value will be marshaled as DEFAULT or NULL (if DEFAULT placeholder is not supported)\n// when appending it to the VALUES clause in place of the given field.\nfunc (q InsertQuery) marshalsToDefault(f *schema.Field, v reflect.Value) bool {\n\treturn (f.IsPtr && f.HasNilValue(v)) ||\n\t\t(f.HasZeroValue(v) && (f.NullZero || f.SQLDefault != \"\"))\n}\n\nfunc (q *InsertQuery) appendFields(\n\tfmter schema.Formatter, b []byte, fields []*schema.Field,\n) []byte {\n\tb = appendColumns(b, \"\", fields)\n\tfor i, v := range q.extraValues {\n\t\tif i > 0 || len(fields) > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb = fmter.AppendIdent(b, v.column)\n\t}\n\treturn b\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *InsertQuery) On(s string, args ...interface{}) *InsertQuery {\n\tq.on = schema.SafeQuery(s, args)\n\treturn q\n}\n\nfunc (q *InsertQuery) Set(query string, args ...interface{}) *InsertQuery {\n\tq.addSet(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *InsertQuery) appendOn(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.on.IsZero() {\n\t\treturn b, nil\n\t}\n\n\tb = append(b, \" ON \"...)\n\tb, err = q.on.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(q.set) > 0 {\n\t\tif fmter.HasFeature(feature.InsertOnDuplicateKey) {\n\t\t\tb = append(b, ' ')\n\t\t} else {\n\t\t\tb = append(b, \" SET \"...)\n\t\t}\n\n\t\tb, err = q.appendSet(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if q.onConflictDoUpdate() {\n\t\tfields, err := q.getDataFields()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif len(fields) == 0 {\n\t\t\tfields = q.tableModel.Table().DataFields\n\t\t}\n\n\t\tb = q.appendSetExcluded(b, fields)\n\t} else if q.onDuplicateKeyUpdate() {\n\t\tfields, err := q.getDataFields()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif len(fields) == 0 {\n\t\t\tfields = q.tableModel.Table().DataFields\n\t\t}\n\n\t\tb = q.appendSetValues(b, fields)\n\t}\n\n\tif len(q.where) > 0 {\n\t\tb = append(b, \" WHERE \"...)\n\n\t\tb, err = appendWhere(fmter, b, q.where)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *InsertQuery) onConflictDoUpdate() bool {\n\treturn strings.HasSuffix(strings.ToUpper(q.on.Query), \" DO UPDATE\")\n}\n\nfunc (q *InsertQuery) onDuplicateKeyUpdate() bool {\n\treturn strings.ToUpper(q.on.Query) == \"DUPLICATE KEY UPDATE\"\n}\n\nfunc (q *InsertQuery) appendSetExcluded(b []byte, fields []*schema.Field) []byte {\n\tb = append(b, \" SET \"...)\n\tfor i, f := range fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb = append(b, f.SQLName...)\n\t\tb = append(b, \" = EXCLUDED.\"...)\n\t\tb = append(b, f.SQLName...)\n\t}\n\treturn b\n}\n\nfunc (q *InsertQuery) appendSetValues(b []byte, fields []*schema.Field) []byte {\n\tb = append(b, \" \"...)\n\tfor i, f := range fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb = append(b, f.SQLName...)\n\t\tb = append(b, \" = VALUES(\"...)\n\t\tb = append(b, f.SQLName...)\n\t\tb = append(b, \")\"...)\n\t}\n\treturn b\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *InsertQuery) Scan(ctx context.Context, dest ...interface{}) error {\n\t_, err := q.scanOrExec(ctx, dest, true)\n\treturn err\n}\n\nfunc (q *InsertQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\treturn q.scanOrExec(ctx, dest, len(dest) > 0)\n}\n\nfunc (q *InsertQuery) scanOrExec(\n\tctx context.Context, dest []interface{}, hasDest bool,\n) (sql.Result, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.beforeInsertHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Run append model hooks before generating the query.\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Generate the query before checking hasReturning.\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuseScan := hasDest || (q.hasReturning() && q.hasFeature(feature.InsertReturning|feature.Output))\n\tvar model Model\n\n\tif useScan {\n\t\tvar err error\n\t\tmodel, err = q.getModel(dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tquery := internal.String(queryBytes)\n\tvar res sql.Result\n\n\tif useScan {\n\t\tres, err = q.scan(ctx, q, query, model, hasDest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tres, err = q.exec(ctx, q, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := q.tryLastInsertID(res, dest); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.afterInsertHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *InsertQuery) beforeInsertHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(BeforeInsertHook); ok {\n\t\tif err := hook.BeforeInsert(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *InsertQuery) afterInsertHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(AfterInsertHook); ok {\n\t\tif err := hook.AfterInsert(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *InsertQuery) tryLastInsertID(res sql.Result, dest []interface{}) error {\n\tif q.db.HasFeature(feature.Returning) ||\n\t\tq.db.HasFeature(feature.Output) ||\n\t\tq.table == nil ||\n\t\tlen(q.table.PKs) != 1 ||\n\t\t!q.table.PKs[0].AutoIncrement {\n\t\treturn nil\n\t}\n\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif id == 0 {\n\t\treturn nil\n\t}\n\n\tmodel, err := q.getModel(dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpk := q.table.PKs[0]\n\tswitch model := model.(type) {\n\tcase *structTableModel:\n\t\tif err := pk.ScanValue(model.strct, id); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase *sliceTableModel:\n\t\tsliceLen := model.slice.Len()\n\t\tfor i := 0; i < sliceLen; i++ {\n\t\t\tstrct := indirect(model.slice.Index(i))\n\t\t\tif err := pk.ScanValue(strct, id); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tid++\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (q *InsertQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n"
        },
        {
          "name": "query_merge.go",
          "type": "blob",
          "size": 7.474609375,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\n\t\"github.com/uptrace/bun/dialect\"\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype MergeQuery struct {\n\tbaseQuery\n\treturningQuery\n\n\tusing   schema.QueryWithArgs\n\ton      schema.QueryWithArgs\n\twhen    []schema.QueryAppender\n\tcomment string\n}\n\nvar _ Query = (*MergeQuery)(nil)\n\nfunc NewMergeQuery(db *DB) *MergeQuery {\n\tq := &MergeQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\tif q.db.dialect.Name() != dialect.MSSQL && q.db.dialect.Name() != dialect.PG {\n\t\tq.err = errors.New(\"bun: merge not supported for current dialect\")\n\t}\n\treturn q\n}\n\nfunc (q *MergeQuery) Conn(db IConn) *MergeQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *MergeQuery) Model(model interface{}) *MergeQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *MergeQuery) Err(err error) *MergeQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the MergeQuery as an argument.\nfunc (q *MergeQuery) Apply(fns ...func(*MergeQuery) *MergeQuery) *MergeQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\nfunc (q *MergeQuery) With(name string, query schema.QueryAppender) *MergeQuery {\n\tq.addWith(name, query, false)\n\treturn q\n}\n\nfunc (q *MergeQuery) WithRecursive(name string, query schema.QueryAppender) *MergeQuery {\n\tq.addWith(name, query, true)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *MergeQuery) Table(tables ...string) *MergeQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *MergeQuery) TableExpr(query string, args ...interface{}) *MergeQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *MergeQuery) ModelTableExpr(query string, args ...interface{}) *MergeQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Returning adds a RETURNING clause to the query.\n//\n// To suppress the auto-generated RETURNING clause, use `Returning(\"NULL\")`.\n// Only for mssql output, postgres not supported returning in merge query\nfunc (q *MergeQuery) Returning(query string, args ...interface{}) *MergeQuery {\n\tq.addReturning(schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *MergeQuery) Using(s string, args ...interface{}) *MergeQuery {\n\tq.using = schema.SafeQuery(s, args)\n\treturn q\n}\n\nfunc (q *MergeQuery) On(s string, args ...interface{}) *MergeQuery {\n\tq.on = schema.SafeQuery(s, args)\n\treturn q\n}\n\n// WhenInsert for when insert clause.\nfunc (q *MergeQuery) WhenInsert(expr string, fn func(q *InsertQuery) *InsertQuery) *MergeQuery {\n\tsq := NewInsertQuery(q.db)\n\t// apply the model as default into sub query, since appendColumnsValues required\n\tif q.model != nil {\n\t\tsq = sq.Model(q.model)\n\t}\n\tsq = sq.Apply(fn)\n\tq.when = append(q.when, &whenInsert{expr: expr, query: sq})\n\treturn q\n}\n\n// WhenUpdate for when update clause.\nfunc (q *MergeQuery) WhenUpdate(expr string, fn func(q *UpdateQuery) *UpdateQuery) *MergeQuery {\n\tsq := NewUpdateQuery(q.db)\n\t// apply the model as default into sub query\n\tif q.model != nil {\n\t\tsq = sq.Model(q.model)\n\t}\n\tsq = sq.Apply(fn)\n\tq.when = append(q.when, &whenUpdate{expr: expr, query: sq})\n\treturn q\n}\n\n// WhenDelete for when delete clause.\nfunc (q *MergeQuery) WhenDelete(expr string) *MergeQuery {\n\tq.when = append(q.when, &whenDelete{expr: expr})\n\treturn q\n}\n\n// When for raw expression clause.\nfunc (q *MergeQuery) When(expr string, args ...interface{}) *MergeQuery {\n\tq.when = append(q.when, schema.SafeQuery(expr, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *MergeQuery) Comment(comment string) *MergeQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *MergeQuery) Operation() string {\n\treturn \"MERGE\"\n}\n\nfunc (q *MergeQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tfmter = formatterWithModel(fmter, q)\n\n\tb, err = q.appendWith(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \"MERGE \"...)\n\tif q.db.dialect.Name() == dialect.PG {\n\t\tb = append(b, \"INTO \"...)\n\t}\n\n\tb, err = q.appendFirstTableWithAlias(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" USING \"...)\n\tb, err = q.using.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" ON \"...)\n\tb, err = q.on.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, w := range q.when {\n\t\tb = append(b, \" WHEN \"...)\n\t\tb, err = w.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.hasFeature(feature.Output) && q.hasReturning() {\n\t\tb = append(b, \" OUTPUT \"...)\n\t\tb, err = q.appendOutput(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// A MERGE statement must be terminated by a semi-colon (;).\n\tb = append(b, \";\"...)\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *MergeQuery) Scan(ctx context.Context, dest ...interface{}) error {\n\t_, err := q.scanOrExec(ctx, dest, true)\n\treturn err\n}\n\nfunc (q *MergeQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\treturn q.scanOrExec(ctx, dest, len(dest) > 0)\n}\n\nfunc (q *MergeQuery) scanOrExec(\n\tctx context.Context, dest []interface{}, hasDest bool,\n) (sql.Result, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\t// Run append model hooks before generating the query.\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Generate the query before checking hasReturning.\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuseScan := hasDest || (q.hasReturning() && q.hasFeature(feature.InsertReturning|feature.Output))\n\tvar model Model\n\n\tif useScan {\n\t\tvar err error\n\t\tmodel, err = q.getModel(dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tquery := internal.String(queryBytes)\n\tvar res sql.Result\n\n\tif useScan {\n\t\tres, err = q.scan(ctx, q, query, model, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tres, err = q.exec(ctx, q, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *MergeQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n\n//------------------------------------------------------------------------------\n\ntype whenInsert struct {\n\texpr  string\n\tquery *InsertQuery\n}\n\nfunc (w *whenInsert) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = append(b, w.expr...)\n\tif w.query != nil {\n\t\tb = append(b, \" THEN INSERT\"...)\n\t\tb, err = w.query.appendColumnsValues(fmter, b, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\ntype whenUpdate struct {\n\texpr  string\n\tquery *UpdateQuery\n}\n\nfunc (w *whenUpdate) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = append(b, w.expr...)\n\tif w.query != nil {\n\t\tb = append(b, \" THEN UPDATE SET \"...)\n\t\tb, err = w.query.appendSet(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\ntype whenDelete struct {\n\texpr string\n}\n\nfunc (w *whenDelete) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = append(b, w.expr...)\n\tb = append(b, \" THEN DELETE\"...)\n\treturn b, nil\n}\n"
        },
        {
          "name": "query_raw.go",
          "type": "blob",
          "size": 2.0400390625,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype RawQuery struct {\n\tbaseQuery\n\n\tquery   string\n\targs    []interface{}\n\tcomment string\n}\n\n// Deprecated: Use NewRaw instead. When add it to IDB, it conflicts with the sql.Conn#Raw\nfunc (db *DB) Raw(query string, args ...interface{}) *RawQuery {\n\treturn &RawQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t\tquery: query,\n\t\targs:  args,\n\t}\n}\n\nfunc NewRawQuery(db *DB, query string, args ...interface{}) *RawQuery {\n\treturn &RawQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t\tquery: query,\n\t\targs:  args,\n\t}\n}\n\nfunc (q *RawQuery) Conn(db IConn) *RawQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *RawQuery) Err(err error) *RawQuery {\n\tq.setErr(err)\n\treturn q\n}\n\nfunc (q *RawQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\treturn q.scanOrExec(ctx, dest, len(dest) > 0)\n}\n\nfunc (q *RawQuery) Scan(ctx context.Context, dest ...interface{}) error {\n\t_, err := q.scanOrExec(ctx, dest, true)\n\treturn err\n}\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *RawQuery) Comment(comment string) *RawQuery {\n\tq.comment = comment\n\treturn q\n}\n\nfunc (q *RawQuery) scanOrExec(\n\tctx context.Context, dest []interface{}, hasDest bool,\n) (sql.Result, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tvar model Model\n\tvar err error\n\n\tif hasDest {\n\t\tmodel, err = q.getModel(dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tquery := q.db.format(q.query, q.args)\n\tvar res sql.Result\n\n\tif hasDest {\n\t\tres, err = q.scan(ctx, q, query, model, hasDest)\n\t} else {\n\t\tres, err = q.exec(ctx, q, query)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *RawQuery) AppendQuery(fmter schema.Formatter, b []byte) ([]byte, error) {\n\tb = appendComment(b, q.comment)\n\n\treturn fmter.AppendQuery(b, q.query, q.args...), nil\n}\n\nfunc (q *RawQuery) Operation() string {\n\treturn \"SELECT\"\n}\n\nfunc (q *RawQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n"
        },
        {
          "name": "query_select.go",
          "type": "blob",
          "size": 26.1064453125,
          "content": "package bun\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\n\t\"github.com/uptrace/bun/dialect\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype union struct {\n\texpr  string\n\tquery *SelectQuery\n}\n\ntype SelectQuery struct {\n\twhereBaseQuery\n\tidxHintsQuery\n\torderLimitOffsetQuery\n\n\tdistinctOn []schema.QueryWithArgs\n\tjoins      []joinQuery\n\tgroup      []schema.QueryWithArgs\n\thaving     []schema.QueryWithArgs\n\tselFor     schema.QueryWithArgs\n\n\tunion   []union\n\tcomment string\n}\n\nvar _ Query = (*SelectQuery)(nil)\n\nfunc NewSelectQuery(db *DB) *SelectQuery {\n\treturn &SelectQuery{\n\t\twhereBaseQuery: whereBaseQuery{\n\t\t\tbaseQuery: baseQuery{\n\t\t\t\tdb:   db,\n\t\t\t\tconn: db.DB,\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc (q *SelectQuery) Conn(db IConn) *SelectQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *SelectQuery) Model(model interface{}) *SelectQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *SelectQuery) Err(err error) *SelectQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the SelectQuery as an argument.\nfunc (q *SelectQuery) Apply(fns ...func(*SelectQuery) *SelectQuery) *SelectQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) With(name string, query schema.QueryAppender) *SelectQuery {\n\tq.addWith(name, query, false)\n\treturn q\n}\n\nfunc (q *SelectQuery) WithRecursive(name string, query schema.QueryAppender) *SelectQuery {\n\tq.addWith(name, query, true)\n\treturn q\n}\n\nfunc (q *SelectQuery) Distinct() *SelectQuery {\n\tq.distinctOn = make([]schema.QueryWithArgs, 0)\n\treturn q\n}\n\nfunc (q *SelectQuery) DistinctOn(query string, args ...interface{}) *SelectQuery {\n\tq.distinctOn = append(q.distinctOn, schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Table(tables ...string) *SelectQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) TableExpr(query string, args ...interface{}) *SelectQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *SelectQuery) ModelTableExpr(query string, args ...interface{}) *SelectQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Column(columns ...string) *SelectQuery {\n\tfor _, column := range columns {\n\t\tq.addColumn(schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) ColumnExpr(query string, args ...interface{}) *SelectQuery {\n\tq.addColumn(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *SelectQuery) ExcludeColumn(columns ...string) *SelectQuery {\n\tq.excludeColumn(columns)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) WherePK(cols ...string) *SelectQuery {\n\tq.addWhereCols(cols)\n\treturn q\n}\n\nfunc (q *SelectQuery) Where(query string, args ...interface{}) *SelectQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" AND \"))\n\treturn q\n}\n\nfunc (q *SelectQuery) WhereOr(query string, args ...interface{}) *SelectQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" OR \"))\n\treturn q\n}\n\nfunc (q *SelectQuery) WhereGroup(sep string, fn func(*SelectQuery) *SelectQuery) *SelectQuery {\n\tsaved := q.where\n\tq.where = nil\n\n\tq = fn(q)\n\n\twhere := q.where\n\tq.where = saved\n\n\tq.addWhereGroup(sep, where)\n\n\treturn q\n}\n\nfunc (q *SelectQuery) WhereDeleted() *SelectQuery {\n\tq.whereDeleted()\n\treturn q\n}\n\nfunc (q *SelectQuery) WhereAllWithDeleted() *SelectQuery {\n\tq.whereAllWithDeleted()\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) UseIndex(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addUseIndex(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) UseIndexForJoin(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addUseIndexForJoin(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) UseIndexForOrderBy(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addUseIndexForOrderBy(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) UseIndexForGroupBy(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addUseIndexForGroupBy(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) IgnoreIndex(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addIgnoreIndex(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) IgnoreIndexForJoin(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addIgnoreIndexForJoin(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) IgnoreIndexForOrderBy(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addIgnoreIndexForOrderBy(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) IgnoreIndexForGroupBy(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addIgnoreIndexForGroupBy(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) ForceIndex(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addForceIndex(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) ForceIndexForJoin(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addForceIndexForJoin(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) ForceIndexForOrderBy(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addForceIndexForOrderBy(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) ForceIndexForGroupBy(indexes ...string) *SelectQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addForceIndexForGroupBy(indexes...)\n\t}\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Group(columns ...string) *SelectQuery {\n\tfor _, column := range columns {\n\t\tq.group = append(q.group, schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *SelectQuery) GroupExpr(group string, args ...interface{}) *SelectQuery {\n\tq.group = append(q.group, schema.SafeQuery(group, args))\n\treturn q\n}\n\nfunc (q *SelectQuery) Having(having string, args ...interface{}) *SelectQuery {\n\tq.having = append(q.having, schema.SafeQuery(having, args))\n\treturn q\n}\n\nfunc (q *SelectQuery) Order(orders ...string) *SelectQuery {\n\tq.addOrder(orders...)\n\treturn q\n}\n\nfunc (q *SelectQuery) OrderExpr(query string, args ...interface{}) *SelectQuery {\n\tq.addOrderExpr(query, args...)\n\treturn q\n}\n\nfunc (q *SelectQuery) Limit(n int) *SelectQuery {\n\tq.setLimit(n)\n\treturn q\n}\n\nfunc (q *SelectQuery) Offset(n int) *SelectQuery {\n\tq.setOffset(n)\n\treturn q\n}\n\nfunc (q *SelectQuery) For(s string, args ...interface{}) *SelectQuery {\n\tq.selFor = schema.SafeQuery(s, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Union(other *SelectQuery) *SelectQuery {\n\treturn q.addUnion(\" UNION \", other)\n}\n\nfunc (q *SelectQuery) UnionAll(other *SelectQuery) *SelectQuery {\n\treturn q.addUnion(\" UNION ALL \", other)\n}\n\nfunc (q *SelectQuery) Intersect(other *SelectQuery) *SelectQuery {\n\treturn q.addUnion(\" INTERSECT \", other)\n}\n\nfunc (q *SelectQuery) IntersectAll(other *SelectQuery) *SelectQuery {\n\treturn q.addUnion(\" INTERSECT ALL \", other)\n}\n\nfunc (q *SelectQuery) Except(other *SelectQuery) *SelectQuery {\n\treturn q.addUnion(\" EXCEPT \", other)\n}\n\nfunc (q *SelectQuery) ExceptAll(other *SelectQuery) *SelectQuery {\n\treturn q.addUnion(\" EXCEPT ALL \", other)\n}\n\nfunc (q *SelectQuery) addUnion(expr string, other *SelectQuery) *SelectQuery {\n\tq.union = append(q.union, union{\n\t\texpr:  expr,\n\t\tquery: other,\n\t})\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Join(join string, args ...interface{}) *SelectQuery {\n\tq.joins = append(q.joins, joinQuery{\n\t\tjoin: schema.SafeQuery(join, args),\n\t})\n\treturn q\n}\n\nfunc (q *SelectQuery) JoinOn(cond string, args ...interface{}) *SelectQuery {\n\treturn q.joinOn(cond, args, \" AND \")\n}\n\nfunc (q *SelectQuery) JoinOnOr(cond string, args ...interface{}) *SelectQuery {\n\treturn q.joinOn(cond, args, \" OR \")\n}\n\nfunc (q *SelectQuery) joinOn(cond string, args []interface{}, sep string) *SelectQuery {\n\tif len(q.joins) == 0 {\n\t\tq.err = errors.New(\"bun: query has no joins\")\n\t\treturn q\n\t}\n\tj := &q.joins[len(q.joins)-1]\n\tj.on = append(j.on, schema.SafeQueryWithSep(cond, args, sep))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Relation adds a relation to the query.\nfunc (q *SelectQuery) Relation(name string, apply ...func(*SelectQuery) *SelectQuery) *SelectQuery {\n\tif len(apply) > 1 {\n\t\tpanic(\"only one apply function is supported\")\n\t}\n\n\tif q.tableModel == nil {\n\t\tq.setErr(errNilModel)\n\t\treturn q\n\t}\n\n\tjoin := q.tableModel.join(name)\n\tif join == nil {\n\t\tq.setErr(fmt.Errorf(\"%s does not have relation=%q\", q.table, name))\n\t\treturn q\n\t}\n\n\tq.applyToRelation(join, apply...)\n\n\treturn q\n}\n\ntype RelationOpts struct {\n\t// Apply applies additional options to the relation.\n\tApply func(*SelectQuery) *SelectQuery\n\t// AdditionalJoinOnConditions adds additional conditions to the JOIN ON clause.\n\tAdditionalJoinOnConditions []schema.QueryWithArgs\n}\n\n// RelationWithOpts adds a relation to the query with additional options.\nfunc (q *SelectQuery) RelationWithOpts(name string, opts RelationOpts) *SelectQuery {\n\tif q.tableModel == nil {\n\t\tq.setErr(errNilModel)\n\t\treturn q\n\t}\n\n\tjoin := q.tableModel.join(name)\n\tif join == nil {\n\t\tq.setErr(fmt.Errorf(\"%s does not have relation=%q\", q.table, name))\n\t\treturn q\n\t}\n\n\tif opts.Apply != nil {\n\t\tq.applyToRelation(join, opts.Apply)\n\t}\n\n\tif len(opts.AdditionalJoinOnConditions) > 0 {\n\t\tjoin.additionalJoinOnConditions = opts.AdditionalJoinOnConditions\n\t}\n\n\treturn q\n}\n\nfunc (q *SelectQuery) applyToRelation(join *relationJoin, apply ...func(*SelectQuery) *SelectQuery) {\n\tvar apply1, apply2 func(*SelectQuery) *SelectQuery\n\n\tif len(join.Relation.Condition) > 0 {\n\t\tapply1 = func(q *SelectQuery) *SelectQuery {\n\t\t\tfor _, opt := range join.Relation.Condition {\n\t\t\t\tq.addWhere(schema.SafeQueryWithSep(opt, nil, \" AND \"))\n\t\t\t}\n\n\t\t\treturn q\n\t\t}\n\t}\n\n\tif len(apply) == 1 {\n\t\tapply2 = apply[0]\n\t}\n\n\tjoin.apply = func(q *SelectQuery) *SelectQuery {\n\t\tif apply1 != nil {\n\t\t\tq = apply1(q)\n\t\t}\n\t\tif apply2 != nil {\n\t\t\tq = apply2(q)\n\t\t}\n\n\t\treturn q\n\t}\n}\n\nfunc (q *SelectQuery) forEachInlineRelJoin(fn func(*relationJoin) error) error {\n\tif q.tableModel == nil {\n\t\treturn nil\n\t}\n\treturn q._forEachInlineRelJoin(fn, q.tableModel.getJoins())\n}\n\nfunc (q *SelectQuery) _forEachInlineRelJoin(fn func(*relationJoin) error, joins []relationJoin) error {\n\tfor i := range joins {\n\t\tj := &joins[i]\n\t\tswitch j.Relation.Type {\n\t\tcase schema.HasOneRelation, schema.BelongsToRelation:\n\t\t\tif err := fn(j); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := q._forEachInlineRelJoin(fn, j.JoinModel.getJoins()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *SelectQuery) selectJoins(ctx context.Context, joins []relationJoin) error {\n\tfor i := range joins {\n\t\tj := &joins[i]\n\n\t\tvar err error\n\n\t\tswitch j.Relation.Type {\n\t\tcase schema.HasOneRelation, schema.BelongsToRelation:\n\t\t\terr = q.selectJoins(ctx, j.JoinModel.getJoins())\n\t\tcase schema.HasManyRelation:\n\t\t\terr = j.selectMany(ctx, q.db.NewSelect().Conn(q.conn))\n\t\tcase schema.ManyToManyRelation:\n\t\t\terr = j.selectM2M(ctx, q.db.NewSelect().Conn(q.conn))\n\t\tdefault:\n\t\t\tpanic(\"not reached\")\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *SelectQuery) Comment(comment string) *SelectQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Operation() string {\n\treturn \"SELECT\"\n}\n\nfunc (q *SelectQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = appendComment(b, q.comment)\n\n\treturn q.appendQuery(fmter, b, false)\n}\n\nfunc (q *SelectQuery) appendQuery(\n\tfmter schema.Formatter, b []byte, count bool,\n) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tfmter = formatterWithModel(fmter, q)\n\n\tcteCount := count && (len(q.group) > 0 || q.distinctOn != nil)\n\tif cteCount {\n\t\tb = append(b, \"WITH _count_wrapper AS (\"...)\n\t}\n\n\tif len(q.union) > 0 {\n\t\tb = append(b, '(')\n\t}\n\n\tb, err = q.appendWith(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := q.forEachInlineRelJoin(func(j *relationJoin) error {\n\t\tj.applyTo(q)\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \"SELECT \"...)\n\n\tif len(q.distinctOn) > 0 {\n\t\tb = append(b, \"DISTINCT ON (\"...)\n\t\tfor i, app := range q.distinctOn {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb, err = app.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tb = append(b, \") \"...)\n\t} else if q.distinctOn != nil {\n\t\tb = append(b, \"DISTINCT \"...)\n\t}\n\n\tif count && !cteCount {\n\t\tb = append(b, \"count(*)\"...)\n\t} else {\n\t\t// MSSQL: allows Limit() without Order() as per https://stackoverflow.com/a/36156953\n\t\tif q.limit > 0 && len(q.order) == 0 && fmter.Dialect().Name() == dialect.MSSQL {\n\t\t\tb = append(b, \"0 AS _temp_sort, \"...)\n\t\t}\n\n\t\tb, err = q.appendColumns(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.hasTables() {\n\t\tb, err = q.appendTables(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb, err = q.appendIndexHints(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := q.forEachInlineRelJoin(func(j *relationJoin) error {\n\t\tb = append(b, ' ')\n\t\tb, err = j.appendHasOneJoin(fmter, b, q)\n\t\treturn err\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, join := range q.joins {\n\t\tb, err = join.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb, err = q.appendWhere(fmter, b, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(q.group) > 0 {\n\t\tb = append(b, \" GROUP BY \"...)\n\t\tfor i, f := range q.group {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb, err = f.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(q.having) > 0 {\n\t\tb = append(b, \" HAVING \"...)\n\t\tfor i, f := range q.having {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \" AND \"...)\n\t\t\t}\n\t\t\tb = append(b, '(')\n\t\t\tb, err = f.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tb = append(b, ')')\n\t\t}\n\t}\n\n\tif !count {\n\t\tb, err = q.appendOrder(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tb, err = q.appendLimitOffset(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif !q.selFor.IsZero() {\n\t\t\tb = append(b, \" FOR \"...)\n\t\t\tb, err = q.selFor.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(q.union) > 0 {\n\t\tb = append(b, ')')\n\n\t\tfor _, u := range q.union {\n\t\t\tb = append(b, u.expr...)\n\t\t\tb = append(b, '(')\n\t\t\tb, err = u.query.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tb = append(b, ')')\n\t\t}\n\t}\n\n\tif cteCount {\n\t\tb = append(b, \") SELECT count(*) FROM _count_wrapper\"...)\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *SelectQuery) appendColumns(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tstart := len(b)\n\n\tswitch {\n\tcase q.columns != nil:\n\t\tfor i, col := range q.columns {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\n\t\t\tif col.Args == nil && q.table != nil {\n\t\t\t\tif field, ok := q.table.FieldMap[col.Query]; ok {\n\t\t\t\t\tb = append(b, q.table.SQLAlias...)\n\t\t\t\t\tb = append(b, '.')\n\t\t\t\t\tb = append(b, field.SQLName...)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb, err = col.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\tcase q.table != nil:\n\t\tif len(q.table.Fields) > 10 && fmter.IsNop() {\n\t\t\tb = append(b, q.table.SQLAlias...)\n\t\t\tb = append(b, '.')\n\t\t\tb = fmter.Dialect().AppendString(b, fmt.Sprintf(\"%d columns\", len(q.table.Fields)))\n\t\t} else {\n\t\t\tb = appendColumns(b, q.table.SQLAlias, q.table.Fields)\n\t\t}\n\tdefault:\n\t\tb = append(b, '*')\n\t}\n\n\tif err := q.forEachInlineRelJoin(func(join *relationJoin) error {\n\t\tif len(b) != start {\n\t\t\tb = append(b, \", \"...)\n\t\t\tstart = len(b)\n\t\t}\n\n\t\tb, err = q.appendInlineRelColumns(fmter, b, join)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = bytes.TrimSuffix(b, []byte(\", \"))\n\n\treturn b, nil\n}\n\nfunc (q *SelectQuery) appendInlineRelColumns(\n\tfmter schema.Formatter, b []byte, join *relationJoin,\n) (_ []byte, err error) {\n\tif join.columns != nil {\n\t\ttable := join.JoinModel.Table()\n\t\tfor i, col := range join.columns {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\n\t\t\tif col.Args == nil {\n\t\t\t\tif field, ok := table.FieldMap[col.Query]; ok {\n\t\t\t\t\tb = join.appendAlias(fmter, b)\n\t\t\t\t\tb = append(b, '.')\n\t\t\t\t\tb = append(b, field.SQLName...)\n\t\t\t\t\tb = append(b, \" AS \"...)\n\t\t\t\t\tb = join.appendAliasColumn(fmter, b, field.Name)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb, err = col.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treturn b, nil\n\t}\n\n\tfor i, field := range join.JoinModel.Table().Fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb = join.appendAlias(fmter, b)\n\t\tb = append(b, '.')\n\t\tb = append(b, field.SQLName...)\n\t\tb = append(b, \" AS \"...)\n\t\tb = join.appendAliasColumn(fmter, b, field.Name)\n\t}\n\treturn b, nil\n}\n\nfunc (q *SelectQuery) appendTables(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = append(b, \" FROM \"...)\n\treturn q.appendTablesWithAlias(fmter, b)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) Rows(ctx context.Context) (*sql.Rows, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tctx, event := q.db.beforeQuery(ctx, q, query, nil, query, q.model)\n\trows, err := q.conn.QueryContext(ctx, query)\n\tq.db.afterQuery(ctx, event, nil, err)\n\treturn rows, err\n}\n\nfunc (q *SelectQuery) Exec(ctx context.Context, dest ...interface{}) (res sql.Result, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tif len(dest) > 0 {\n\t\tmodel, err := q.getModel(dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tres, err = q.scan(ctx, q, query, model, true)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tres, err = q.exec(ctx, q, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *SelectQuery) Scan(ctx context.Context, dest ...interface{}) error {\n\t_, err := q.scanResult(ctx, dest...)\n\treturn err\n}\n\nfunc (q *SelectQuery) scanResult(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tmodel, err := q.getModel(dest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(dest) > 0 && q.tableModel != nil && len(q.tableModel.getJoins()) > 0 {\n\t\tfor _, j := range q.tableModel.getJoins() {\n\t\t\tswitch j.Relation.Type {\n\t\t\tcase schema.HasManyRelation, schema.ManyToManyRelation:\n\t\t\t\treturn nil, fmt.Errorf(\"When querying has-many or many-to-many relationships, you should use Model instead of the dest parameter in Scan.\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.beforeSelectHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.scan(ctx, q, query, model, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif n, _ := res.RowsAffected(); n > 0 {\n\t\tif tableModel, ok := model.(TableModel); ok {\n\t\t\tif err := q.selectJoins(ctx, tableModel.getJoins()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.afterSelectHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *SelectQuery) beforeSelectHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(BeforeSelectHook); ok {\n\t\tif err := hook.BeforeSelect(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *SelectQuery) afterSelectHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(AfterSelectHook); ok {\n\t\tif err := hook.AfterSelect(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *SelectQuery) Count(ctx context.Context) (int, error) {\n\tif q.err != nil {\n\t\treturn 0, q.err\n\t}\n\n\tqq := countQuery{q}\n\n\tqueryBytes, err := qq.AppendQuery(q.db.fmter, nil)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\tctx, event := q.db.beforeQuery(ctx, qq, query, nil, query, q.model)\n\n\tvar num int\n\terr = q.conn.QueryRowContext(ctx, query).Scan(&num)\n\n\tq.db.afterQuery(ctx, event, nil, err)\n\n\treturn num, err\n}\n\nfunc (q *SelectQuery) ScanAndCount(ctx context.Context, dest ...interface{}) (int, error) {\n\tif q.offset == 0 && q.limit == 0 {\n\t\t// If there is no limit and offset, we can use a single query to get the count and scan\n\t\tif res, err := q.scanResult(ctx, dest...); err != nil {\n\t\t\treturn 0, err\n\t\t} else if n, err := res.RowsAffected(); err != nil {\n\t\t\treturn 0, err\n\t\t} else {\n\t\t\treturn int(n), nil\n\t\t}\n\t}\n\tif _, ok := q.conn.(*DB); ok {\n\t\treturn q.scanAndCountConc(ctx, dest...)\n\t}\n\treturn q.scanAndCountSeq(ctx, dest...)\n}\n\nfunc (q *SelectQuery) scanAndCountConc(ctx context.Context, dest ...interface{}) (int, error) {\n\tvar count int\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\tvar firstErr error\n\n\tif q.limit >= 0 {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tif err := q.Scan(ctx, dest...); err != nil {\n\t\t\t\tmu.Lock()\n\t\t\t\tif firstErr == nil {\n\t\t\t\t\tfirstErr = err\n\t\t\t\t}\n\t\t\t\tmu.Unlock()\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\n\t\tvar err error\n\t\tcount, err = q.Count(ctx)\n\t\tif err != nil {\n\t\t\tmu.Lock()\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\t}\n\t}()\n\n\twg.Wait()\n\treturn count, firstErr\n}\n\nfunc (q *SelectQuery) scanAndCountSeq(ctx context.Context, dest ...interface{}) (int, error) {\n\tvar firstErr error\n\n\tif q.limit >= 0 {\n\t\tfirstErr = q.Scan(ctx, dest...)\n\t}\n\n\tcount, err := q.Count(ctx)\n\tif err != nil && firstErr == nil {\n\t\tfirstErr = err\n\t}\n\n\treturn count, firstErr\n}\n\nfunc (q *SelectQuery) Exists(ctx context.Context) (bool, error) {\n\tif q.err != nil {\n\t\treturn false, q.err\n\t}\n\n\tif q.hasFeature(feature.SelectExists) {\n\t\treturn q.selectExists(ctx)\n\t}\n\treturn q.whereExists(ctx)\n}\n\nfunc (q *SelectQuery) selectExists(ctx context.Context) (bool, error) {\n\tqq := selectExistsQuery{q}\n\n\tqueryBytes, err := qq.AppendQuery(q.db.fmter, nil)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\tctx, event := q.db.beforeQuery(ctx, qq, query, nil, query, q.model)\n\n\tvar exists bool\n\terr = q.conn.QueryRowContext(ctx, query).Scan(&exists)\n\n\tq.db.afterQuery(ctx, event, nil, err)\n\n\treturn exists, err\n}\n\nfunc (q *SelectQuery) whereExists(ctx context.Context) (bool, error) {\n\tqq := whereExistsQuery{q}\n\n\tqueryBytes, err := qq.AppendQuery(q.db.fmter, nil)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\tres, err := q.exec(ctx, qq, query)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tn, err := res.RowsAffected()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn n == 1, nil\n}\n\nfunc (q *SelectQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *SelectQuery) QueryBuilder() QueryBuilder {\n\treturn &selectQueryBuilder{q}\n}\n\nfunc (q *SelectQuery) ApplyQueryBuilder(fn func(QueryBuilder) QueryBuilder) *SelectQuery {\n\treturn fn(q.QueryBuilder()).Unwrap().(*SelectQuery)\n}\n\ntype selectQueryBuilder struct {\n\t*SelectQuery\n}\n\nfunc (q *selectQueryBuilder) WhereGroup(\n\tsep string, fn func(QueryBuilder) QueryBuilder,\n) QueryBuilder {\n\tq.SelectQuery = q.SelectQuery.WhereGroup(sep, func(qs *SelectQuery) *SelectQuery {\n\t\treturn fn(q).(*selectQueryBuilder).SelectQuery\n\t})\n\treturn q\n}\n\nfunc (q *selectQueryBuilder) Where(query string, args ...interface{}) QueryBuilder {\n\tq.SelectQuery.Where(query, args...)\n\treturn q\n}\n\nfunc (q *selectQueryBuilder) WhereOr(query string, args ...interface{}) QueryBuilder {\n\tq.SelectQuery.WhereOr(query, args...)\n\treturn q\n}\n\nfunc (q *selectQueryBuilder) WhereDeleted() QueryBuilder {\n\tq.SelectQuery.WhereDeleted()\n\treturn q\n}\n\nfunc (q *selectQueryBuilder) WhereAllWithDeleted() QueryBuilder {\n\tq.SelectQuery.WhereAllWithDeleted()\n\treturn q\n}\n\nfunc (q *selectQueryBuilder) WherePK(cols ...string) QueryBuilder {\n\tq.SelectQuery.WherePK(cols...)\n\treturn q\n}\n\nfunc (q *selectQueryBuilder) Unwrap() interface{} {\n\treturn q.SelectQuery\n}\n\n//------------------------------------------------------------------------------\n\ntype joinQuery struct {\n\tjoin schema.QueryWithArgs\n\ton   []schema.QueryWithSep\n}\n\nfunc (j *joinQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = append(b, ' ')\n\n\tb, err = j.join.AppendQuery(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(j.on) > 0 {\n\t\tb = append(b, \" ON \"...)\n\t\tfor i, on := range j.on {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, on.Sep...)\n\t\t\t}\n\n\t\t\tb = append(b, '(')\n\t\t\tb, err = on.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tb = append(b, ')')\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype countQuery struct {\n\t*SelectQuery\n}\n\nfunc (q countQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\treturn q.appendQuery(fmter, b, true)\n}\n\n//------------------------------------------------------------------------------\n\ntype selectExistsQuery struct {\n\t*SelectQuery\n}\n\nfunc (q selectExistsQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = append(b, \"SELECT EXISTS (\"...)\n\n\tb, err = q.appendQuery(fmter, b, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \")\"...)\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype whereExistsQuery struct {\n\t*SelectQuery\n}\n\nfunc (q whereExistsQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = append(b, \"SELECT 1 WHERE EXISTS (\"...)\n\n\tb, err = q.appendQuery(fmter, b, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \")\"...)\n\n\treturn b, nil\n}\n"
        },
        {
          "name": "query_table_create.go",
          "type": "blob",
          "size": 10.33203125,
          "content": "package bun\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/uptrace/bun/dialect\"\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/dialect/sqltype\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype CreateTableQuery struct {\n\tbaseQuery\n\n\ttemp        bool\n\tifNotExists bool\n\tfksFromRel  bool // Create foreign keys captured in table's relations.\n\n\t// varchar changes the default length for VARCHAR columns.\n\t// Because some dialects require that length is always specified for VARCHAR type,\n\t// we will use the exact user-defined type if length is set explicitly, as in `bun:\",type:varchar(5)\"`,\n\t// but assume the new default length when it's omitted, e.g. `bun:\",type:varchar\"`.\n\tvarchar int\n\n\tfks         []schema.QueryWithArgs\n\tpartitionBy schema.QueryWithArgs\n\ttablespace  schema.QueryWithArgs\n\tcomment     string\n}\n\nvar _ Query = (*CreateTableQuery)(nil)\n\nfunc NewCreateTableQuery(db *DB) *CreateTableQuery {\n\tq := &CreateTableQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t\tvarchar: db.Dialect().DefaultVarcharLen(),\n\t}\n\treturn q\n}\n\nfunc (q *CreateTableQuery) Conn(db IConn) *CreateTableQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *CreateTableQuery) Model(model interface{}) *CreateTableQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *CreateTableQuery) Err(err error) *CreateTableQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// ------------------------------------------------------------------------------\n\nfunc (q *CreateTableQuery) Table(tables ...string) *CreateTableQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *CreateTableQuery) TableExpr(query string, args ...interface{}) *CreateTableQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *CreateTableQuery) ModelTableExpr(query string, args ...interface{}) *CreateTableQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\nfunc (q *CreateTableQuery) ColumnExpr(query string, args ...interface{}) *CreateTableQuery {\n\tq.addColumn(schema.SafeQuery(query, args))\n\treturn q\n}\n\n// ------------------------------------------------------------------------------\n\nfunc (q *CreateTableQuery) Temp() *CreateTableQuery {\n\tq.temp = true\n\treturn q\n}\n\nfunc (q *CreateTableQuery) IfNotExists() *CreateTableQuery {\n\tq.ifNotExists = true\n\treturn q\n}\n\n// Varchar sets default length for VARCHAR columns.\nfunc (q *CreateTableQuery) Varchar(n int) *CreateTableQuery {\n\tif n <= 0 {\n\t\tq.setErr(fmt.Errorf(\"bun: illegal VARCHAR length: %d\", n))\n\t\treturn q\n\t}\n\tq.varchar = n\n\treturn q\n}\n\nfunc (q *CreateTableQuery) ForeignKey(query string, args ...interface{}) *CreateTableQuery {\n\tq.fks = append(q.fks, schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *CreateTableQuery) PartitionBy(query string, args ...interface{}) *CreateTableQuery {\n\tq.partitionBy = schema.SafeQuery(query, args)\n\treturn q\n}\n\nfunc (q *CreateTableQuery) TableSpace(tablespace string) *CreateTableQuery {\n\tq.tablespace = schema.UnsafeIdent(tablespace)\n\treturn q\n}\n\n// WithForeignKeys adds a FOREIGN KEY clause for each of the model's existing relations.\nfunc (q *CreateTableQuery) WithForeignKeys() *CreateTableQuery {\n\tq.fksFromRel = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *CreateTableQuery) Comment(comment string) *CreateTableQuery {\n\tq.comment = comment\n\treturn q\n}\n\n// ------------------------------------------------------------------------------\n\nfunc (q *CreateTableQuery) Operation() string {\n\treturn \"CREATE TABLE\"\n}\n\nfunc (q *CreateTableQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tif q.table == nil {\n\t\treturn nil, errNilModel\n\t}\n\n\tb = append(b, \"CREATE \"...)\n\tif q.temp {\n\t\tb = append(b, \"TEMP \"...)\n\t}\n\tb = append(b, \"TABLE \"...)\n\tif q.ifNotExists && fmter.HasFeature(feature.TableNotExists) {\n\t\tb = append(b, \"IF NOT EXISTS \"...)\n\t}\n\tb, err = q.appendFirstTable(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \" (\"...)\n\n\tfor i, field := range q.table.Fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tb = append(b, field.SQLName...)\n\t\tb = append(b, \" \"...)\n\t\tb = q.appendSQLType(b, field)\n\t\tif field.NotNull && q.db.dialect.Name() != dialect.Oracle {\n\t\t\tb = append(b, \" NOT NULL\"...)\n\t\t}\n\n\t\tif (field.Identity && fmter.HasFeature(feature.GeneratedIdentity)) ||\n\t\t\t(field.AutoIncrement && (fmter.HasFeature(feature.AutoIncrement) || fmter.HasFeature(feature.Identity))) {\n\t\t\tb = q.db.dialect.AppendSequence(b, q.table, field)\n\t\t}\n\n\t\tif field.SQLDefault != \"\" {\n\t\t\tb = append(b, \" DEFAULT \"...)\n\t\t\tb = append(b, field.SQLDefault...)\n\t\t}\n\t}\n\n\tfor i, col := range q.columns {\n\t\t// Only pre-pend the comma if we are on subsequent iterations, or if there were fields/columns appended before\n\t\t// this. This way if we are only appending custom column expressions we will not produce a syntax error with a\n\t\t// leading comma.\n\t\tif i > 0 || len(q.table.Fields) > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\t\tb, err = col.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// In SQLite AUTOINCREMENT is only valid for INTEGER PRIMARY KEY columns, so it might be that\n\t// a primary key constraint has already been created in dialect.AppendSequence() call above.\n\t// See sqldialect.Dialect.AppendSequence() for more details.\n\tif len(q.table.PKs) > 0 && !bytes.Contains(b, []byte(\"PRIMARY KEY\")) {\n\t\tb = q.appendPKConstraint(b, q.table.PKs)\n\t}\n\tb = q.appendUniqueConstraints(fmter, b)\n\n\tif q.fksFromRel {\n\t\tb, err = q.appendFKConstraintsRel(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tb, err = q.appendFKConstraints(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \")\"...)\n\n\tif !q.partitionBy.IsZero() {\n\t\tb = append(b, \" PARTITION BY \"...)\n\t\tb, err = q.partitionBy.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif !q.tablespace.IsZero() {\n\t\tb = append(b, \" TABLESPACE \"...)\n\t\tb, err = q.tablespace.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *CreateTableQuery) appendSQLType(b []byte, field *schema.Field) []byte {\n\t// Most of the time these two will match, but for the cases where DiscoveredSQLType is dialect-specific,\n\t// e.g. pgdialect would change sqltype.SmallInt to pgTypeSmallSerial for columns that have `bun:\",autoincrement\"`\n\tif !strings.EqualFold(field.CreateTableSQLType, field.DiscoveredSQLType) {\n\t\treturn append(b, field.CreateTableSQLType...)\n\t}\n\n\t// For all common SQL types except VARCHAR, both UserDefinedSQLType and DiscoveredSQLType specify the correct type,\n\t// and we needn't modify it. For VARCHAR columns, we will stop to check if a valid length has been set in .Varchar(int).\n\tif !strings.EqualFold(field.CreateTableSQLType, sqltype.VarChar) || q.varchar <= 0 {\n\t\treturn append(b, field.CreateTableSQLType...)\n\t}\n\n\tif q.db.dialect.Name() == dialect.Oracle {\n\t\tb = append(b, \"VARCHAR2\"...)\n\t} else {\n\t\tb = append(b, sqltype.VarChar...)\n\t}\n\tb = append(b, \"(\"...)\n\tb = strconv.AppendInt(b, int64(q.varchar), 10)\n\tb = append(b, \")\"...)\n\treturn b\n}\n\nfunc (q *CreateTableQuery) appendUniqueConstraints(fmter schema.Formatter, b []byte) []byte {\n\tunique := q.table.Unique\n\n\tkeys := make([]string, 0, len(unique))\n\tfor key := range unique {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, key := range keys {\n\t\tif key == \"\" {\n\t\t\tfor _, field := range unique[key] {\n\t\t\t\tb = q.appendUniqueConstraint(fmter, b, key, field)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tb = q.appendUniqueConstraint(fmter, b, key, unique[key]...)\n\t}\n\n\treturn b\n}\n\nfunc (q *CreateTableQuery) appendUniqueConstraint(\n\tfmter schema.Formatter, b []byte, name string, fields ...*schema.Field,\n) []byte {\n\tif name != \"\" {\n\t\tb = append(b, \", CONSTRAINT \"...)\n\t\tb = fmter.AppendIdent(b, name)\n\t} else {\n\t\tb = append(b, \",\"...)\n\t}\n\tb = append(b, \" UNIQUE (\"...)\n\tb = appendColumns(b, \"\", fields)\n\tb = append(b, \")\"...)\n\treturn b\n}\n\n// appendFKConstraintsRel appends a FOREIGN KEY clause for each of the model's existing relations.\nfunc (q *CreateTableQuery) appendFKConstraintsRel(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tfor _, rel := range q.tableModel.Table().Relations {\n\t\tif rel.References() {\n\t\t\tb, err = q.appendFK(fmter, b, schema.QueryWithArgs{\n\t\t\t\tQuery: \"(?) REFERENCES ? (?) ? ?\",\n\t\t\t\tArgs: []interface{}{\n\t\t\t\t\tSafe(appendColumns(nil, \"\", rel.BasePKs)),\n\t\t\t\t\trel.JoinTable.SQLName,\n\t\t\t\t\tSafe(appendColumns(nil, \"\", rel.JoinPKs)),\n\t\t\t\t\tSafe(rel.OnUpdate),\n\t\t\t\t\tSafe(rel.OnDelete),\n\t\t\t\t},\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\treturn b, nil\n}\n\nfunc (q *CreateTableQuery) appendFK(fmter schema.Formatter, b []byte, fk schema.QueryWithArgs) (_ []byte, err error) {\n\tb = append(b, \", FOREIGN KEY \"...)\n\treturn fk.AppendQuery(fmter, b)\n}\n\nfunc (q *CreateTableQuery) appendFKConstraints(\n\tfmter schema.Formatter, b []byte,\n) (_ []byte, err error) {\n\tfor _, fk := range q.fks {\n\t\tif b, err = q.appendFK(fmter, b, fk); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn b, nil\n}\n\nfunc (q *CreateTableQuery) appendPKConstraint(b []byte, pks []*schema.Field) []byte {\n\tb = append(b, \", PRIMARY KEY (\"...)\n\tb = appendColumns(b, \"\", pks)\n\tb = append(b, \")\"...)\n\treturn b\n}\n\n// ------------------------------------------------------------------------------\n\nfunc (q *CreateTableQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tif err := q.beforeCreateTableHook(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.exec(ctx, q, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.afterCreateTableHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *CreateTableQuery) beforeCreateTableHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(BeforeCreateTableHook); ok {\n\t\tif err := hook.BeforeCreateTable(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *CreateTableQuery) afterCreateTableHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(AfterCreateTableHook); ok {\n\t\tif err := hook.AfterCreateTable(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *CreateTableQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n"
        },
        {
          "name": "query_table_drop.go",
          "type": "blob",
          "size": 3.45703125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype DropTableQuery struct {\n\tbaseQuery\n\tcascadeQuery\n\n\tifExists bool\n\tcomment  string\n}\n\nvar _ Query = (*DropTableQuery)(nil)\n\nfunc NewDropTableQuery(db *DB) *DropTableQuery {\n\tq := &DropTableQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *DropTableQuery) Conn(db IConn) *DropTableQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *DropTableQuery) Model(model interface{}) *DropTableQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *DropTableQuery) Err(err error) *DropTableQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropTableQuery) Table(tables ...string) *DropTableQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *DropTableQuery) TableExpr(query string, args ...interface{}) *DropTableQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *DropTableQuery) ModelTableExpr(query string, args ...interface{}) *DropTableQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropTableQuery) IfExists() *DropTableQuery {\n\tq.ifExists = true\n\treturn q\n}\n\nfunc (q *DropTableQuery) Cascade() *DropTableQuery {\n\tq.cascade = true\n\treturn q\n}\n\nfunc (q *DropTableQuery) Restrict() *DropTableQuery {\n\tq.restrict = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *DropTableQuery) Comment(comment string) *DropTableQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropTableQuery) Operation() string {\n\treturn \"DROP TABLE\"\n}\n\nfunc (q *DropTableQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tb = append(b, \"DROP TABLE \"...)\n\tif q.ifExists {\n\t\tb = append(b, \"IF EXISTS \"...)\n\t}\n\n\tb, err = q.appendTables(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = q.appendCascade(fmter, b)\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *DropTableQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tif q.table != nil {\n\t\tif err := q.beforeDropTableHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.exec(ctx, q, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.afterDropTableHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *DropTableQuery) beforeDropTableHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(BeforeDropTableHook); ok {\n\t\tif err := hook.BeforeDropTable(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *DropTableQuery) afterDropTableHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(AfterDropTableHook); ok {\n\t\tif err := hook.AfterDropTable(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *DropTableQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n"
        },
        {
          "name": "query_table_truncate.go",
          "type": "blob",
          "size": 3.1611328125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype TruncateTableQuery struct {\n\tbaseQuery\n\tcascadeQuery\n\n\tcontinueIdentity bool\n\tcomment          string\n}\n\nvar _ Query = (*TruncateTableQuery)(nil)\n\nfunc NewTruncateTableQuery(db *DB) *TruncateTableQuery {\n\tq := &TruncateTableQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) Conn(db IConn) *TruncateTableQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) Model(model interface{}) *TruncateTableQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) Err(err error) *TruncateTableQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *TruncateTableQuery) Table(tables ...string) *TruncateTableQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) TableExpr(query string, args ...interface{}) *TruncateTableQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) ModelTableExpr(query string, args ...interface{}) *TruncateTableQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *TruncateTableQuery) ContinueIdentity() *TruncateTableQuery {\n\tq.continueIdentity = true\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) Cascade() *TruncateTableQuery {\n\tq.cascade = true\n\treturn q\n}\n\nfunc (q *TruncateTableQuery) Restrict() *TruncateTableQuery {\n\tq.restrict = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *TruncateTableQuery) Comment(comment string) *TruncateTableQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *TruncateTableQuery) Operation() string {\n\treturn \"TRUNCATE TABLE\"\n}\n\nfunc (q *TruncateTableQuery) AppendQuery(\n\tfmter schema.Formatter, b []byte,\n) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tif !fmter.HasFeature(feature.TableTruncate) {\n\t\tb = append(b, \"DELETE FROM \"...)\n\n\t\tb, err = q.appendTables(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn b, nil\n\t}\n\n\tb = append(b, \"TRUNCATE TABLE \"...)\n\n\tb, err = q.appendTables(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.db.HasFeature(feature.TableIdentity) {\n\t\tif q.continueIdentity {\n\t\t\tb = append(b, \" CONTINUE IDENTITY\"...)\n\t\t} else {\n\t\t\tb = append(b, \" RESTART IDENTITY\"...)\n\t\t}\n\t}\n\n\tb = q.appendCascade(fmter, b)\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *TruncateTableQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tres, err := q.exec(ctx, q, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn res, nil\n}\n"
        },
        {
          "name": "query_update.go",
          "type": "blob",
          "size": 15.6455078125,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/uptrace/bun/dialect\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype UpdateQuery struct {\n\twhereBaseQuery\n\torderLimitOffsetQuery\n\treturningQuery\n\tcustomValueQuery\n\tsetQuery\n\tidxHintsQuery\n\n\tjoins    []joinQuery\n\tomitZero bool\n\tcomment  string\n}\n\nvar _ Query = (*UpdateQuery)(nil)\n\nfunc NewUpdateQuery(db *DB) *UpdateQuery {\n\tq := &UpdateQuery{\n\t\twhereBaseQuery: whereBaseQuery{\n\t\t\tbaseQuery: baseQuery{\n\t\t\t\tdb:   db,\n\t\t\t\tconn: db.DB,\n\t\t\t},\n\t\t},\n\t}\n\treturn q\n}\n\nfunc (q *UpdateQuery) Conn(db IConn) *UpdateQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *UpdateQuery) Model(model interface{}) *UpdateQuery {\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *UpdateQuery) Err(err error) *UpdateQuery {\n\tq.setErr(err)\n\treturn q\n}\n\n// Apply calls each function in fns, passing the UpdateQuery as an argument.\nfunc (q *UpdateQuery) Apply(fns ...func(*UpdateQuery) *UpdateQuery) *UpdateQuery {\n\tfor _, fn := range fns {\n\t\tif fn != nil {\n\t\t\tq = fn(q)\n\t\t}\n\t}\n\treturn q\n}\n\nfunc (q *UpdateQuery) With(name string, query schema.QueryAppender) *UpdateQuery {\n\tq.addWith(name, query, false)\n\treturn q\n}\n\nfunc (q *UpdateQuery) WithRecursive(name string, query schema.QueryAppender) *UpdateQuery {\n\tq.addWith(name, query, true)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) Table(tables ...string) *UpdateQuery {\n\tfor _, table := range tables {\n\t\tq.addTable(schema.UnsafeIdent(table))\n\t}\n\treturn q\n}\n\nfunc (q *UpdateQuery) TableExpr(query string, args ...interface{}) *UpdateQuery {\n\tq.addTable(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *UpdateQuery) ModelTableExpr(query string, args ...interface{}) *UpdateQuery {\n\tq.modelTableName = schema.SafeQuery(query, args)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) Column(columns ...string) *UpdateQuery {\n\tfor _, column := range columns {\n\t\tq.addColumn(schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\nfunc (q *UpdateQuery) ExcludeColumn(columns ...string) *UpdateQuery {\n\tq.excludeColumn(columns)\n\treturn q\n}\n\nfunc (q *UpdateQuery) Set(query string, args ...interface{}) *UpdateQuery {\n\tq.addSet(schema.SafeQuery(query, args))\n\treturn q\n}\n\nfunc (q *UpdateQuery) SetColumn(column string, query string, args ...interface{}) *UpdateQuery {\n\tif q.db.HasFeature(feature.UpdateMultiTable) {\n\t\tcolumn = q.table.Alias + \".\" + column\n\t}\n\tq.addSet(schema.SafeQuery(column+\" = \"+query, args))\n\treturn q\n}\n\n// Value overwrites model value for the column.\nfunc (q *UpdateQuery) Value(column string, query string, args ...interface{}) *UpdateQuery {\n\tif q.table == nil {\n\t\tq.err = errNilModel\n\t\treturn q\n\t}\n\tq.addValue(q.table, column, query, args)\n\treturn q\n}\n\nfunc (q *UpdateQuery) OmitZero() *UpdateQuery {\n\tq.omitZero = true\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) Join(join string, args ...interface{}) *UpdateQuery {\n\tq.joins = append(q.joins, joinQuery{\n\t\tjoin: schema.SafeQuery(join, args),\n\t})\n\treturn q\n}\n\nfunc (q *UpdateQuery) JoinOn(cond string, args ...interface{}) *UpdateQuery {\n\treturn q.joinOn(cond, args, \" AND \")\n}\n\nfunc (q *UpdateQuery) JoinOnOr(cond string, args ...interface{}) *UpdateQuery {\n\treturn q.joinOn(cond, args, \" OR \")\n}\n\nfunc (q *UpdateQuery) joinOn(cond string, args []interface{}, sep string) *UpdateQuery {\n\tif len(q.joins) == 0 {\n\t\tq.err = errors.New(\"bun: query has no joins\")\n\t\treturn q\n\t}\n\tj := &q.joins[len(q.joins)-1]\n\tj.on = append(j.on, schema.SafeQueryWithSep(cond, args, sep))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) WherePK(cols ...string) *UpdateQuery {\n\tq.addWhereCols(cols)\n\treturn q\n}\n\nfunc (q *UpdateQuery) Where(query string, args ...interface{}) *UpdateQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" AND \"))\n\treturn q\n}\n\nfunc (q *UpdateQuery) WhereOr(query string, args ...interface{}) *UpdateQuery {\n\tq.addWhere(schema.SafeQueryWithSep(query, args, \" OR \"))\n\treturn q\n}\n\nfunc (q *UpdateQuery) WhereGroup(sep string, fn func(*UpdateQuery) *UpdateQuery) *UpdateQuery {\n\tsaved := q.where\n\tq.where = nil\n\n\tq = fn(q)\n\n\twhere := q.where\n\tq.where = saved\n\n\tq.addWhereGroup(sep, where)\n\n\treturn q\n}\n\nfunc (q *UpdateQuery) WhereDeleted() *UpdateQuery {\n\tq.whereDeleted()\n\treturn q\n}\n\nfunc (q *UpdateQuery) WhereAllWithDeleted() *UpdateQuery {\n\tq.whereAllWithDeleted()\n\treturn q\n}\n\n// ------------------------------------------------------------------------------\nfunc (q *UpdateQuery) Order(orders ...string) *UpdateQuery {\n\tif !q.hasFeature(feature.UpdateOrderLimit) {\n\t\tq.err = errors.New(\"bun: order is not supported for current dialect\")\n\t\treturn q\n\t}\n\tq.addOrder(orders...)\n\treturn q\n}\n\nfunc (q *UpdateQuery) OrderExpr(query string, args ...interface{}) *UpdateQuery {\n\tif !q.hasFeature(feature.UpdateOrderLimit) {\n\t\tq.err = errors.New(\"bun: order is not supported for current dialect\")\n\t\treturn q\n\t}\n\tq.addOrderExpr(query, args...)\n\treturn q\n}\n\nfunc (q *UpdateQuery) Limit(n int) *UpdateQuery {\n\tif !q.hasFeature(feature.UpdateOrderLimit) {\n\t\tq.err = errors.New(\"bun: limit is not supported for current dialect\")\n\t\treturn q\n\t}\n\tq.setLimit(n)\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Returning adds a RETURNING clause to the query.\n//\n// To suppress the auto-generated RETURNING clause, use `Returning(\"NULL\")`.\nfunc (q *UpdateQuery) Returning(query string, args ...interface{}) *UpdateQuery {\n\tq.addReturning(schema.SafeQuery(query, args))\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *UpdateQuery) Comment(comment string) *UpdateQuery {\n\tq.comment = comment\n\treturn q\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) Operation() string {\n\treturn \"UPDATE\"\n}\n\nfunc (q *UpdateQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tfmter = formatterWithModel(fmter, q)\n\n\tb, err = q.appendWith(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb = append(b, \"UPDATE \"...)\n\n\tif fmter.HasFeature(feature.UpdateMultiTable) {\n\t\tb, err = q.appendTablesWithAlias(fmter, b)\n\t} else if fmter.HasFeature(feature.UpdateTableAlias) {\n\t\tb, err = q.appendFirstTableWithAlias(fmter, b)\n\t} else {\n\t\tb, err = q.appendFirstTable(fmter, b)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.appendIndexHints(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.mustAppendSet(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !fmter.HasFeature(feature.UpdateMultiTable) {\n\t\tb, err = q.appendOtherTables(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tfor _, j := range q.joins {\n\t\tb, err = j.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.hasFeature(feature.Output) && q.hasReturning() {\n\t\tb = append(b, \" OUTPUT \"...)\n\t\tb, err = q.appendOutput(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tb, err = q.mustAppendWhere(fmter, b, q.hasTableAlias(fmter))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.appendOrder(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tb, err = q.appendLimitOffset(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.hasFeature(feature.Returning) && q.hasReturning() {\n\t\tb = append(b, \" RETURNING \"...)\n\t\tb, err = q.appendReturning(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *UpdateQuery) mustAppendSet(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tb = append(b, \" SET \"...)\n\n\tif len(q.set) > 0 {\n\t\treturn q.appendSet(fmter, b)\n\t}\n\n\tif m, ok := q.model.(*mapModel); ok {\n\t\treturn m.appendSet(fmter, b), nil\n\t}\n\n\tif q.tableModel == nil {\n\t\treturn nil, errNilModel\n\t}\n\n\tswitch model := q.tableModel.(type) {\n\tcase *structTableModel:\n\t\tpos := len(b)\n\t\tb, err = q.appendSetStruct(fmter, b, model)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Validate if no values were appended after SET clause.\n\t\t// e.g. UPDATE users SET WHERE id = 1\n\t\t// See issues858\n\t\tif len(b) == pos {\n\t\t\treturn nil, errors.New(\"bun: empty SET clause is not allowed in the UPDATE query\")\n\t\t}\n\tcase *sliceTableModel:\n\t\treturn nil, errors.New(\"bun: to bulk Update, use CTE and VALUES\")\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"bun: Update does not support %T\", q.tableModel)\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *UpdateQuery) appendSetStruct(\n\tfmter schema.Formatter, b []byte, model *structTableModel,\n) ([]byte, error) {\n\tfields, err := q.getDataFields()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tisTemplate := fmter.IsNop()\n\tpos := len(b)\n\tfor _, f := range fields {\n\t\tif f.SkipUpdate() {\n\t\t\tcontinue\n\t\t}\n\n\t\tapp, hasValue := q.modelValues[f.Name]\n\n\t\tif !hasValue && q.omitZero && f.HasZeroValue(model.strct) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(b) != pos {\n\t\t\tb = append(b, \", \"...)\n\t\t\tpos = len(b)\n\t\t}\n\n\t\tb = append(b, f.SQLName...)\n\t\tb = append(b, \" = \"...)\n\n\t\tif isTemplate {\n\t\t\tb = append(b, '?')\n\t\t\tcontinue\n\t\t}\n\n\t\tif hasValue {\n\t\t\tb, err = app.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tb = f.AppendValue(fmter, b, model.strct)\n\t\t}\n\t}\n\n\tfor i, v := range q.extraValues {\n\t\tif i > 0 || len(fields) > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tb = append(b, v.column...)\n\t\tb = append(b, \" = \"...)\n\n\t\tb, err = v.value.AppendQuery(fmter, b)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn b, nil\n}\n\nfunc (q *UpdateQuery) appendOtherTables(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif !q.hasMultiTables() {\n\t\treturn b, nil\n\t}\n\n\tb = append(b, \" FROM \"...)\n\n\tb, err = q.whereBaseQuery.appendOtherTables(fmter, b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b, nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) Bulk() *UpdateQuery {\n\tmodel, ok := q.model.(*sliceTableModel)\n\tif !ok {\n\t\tq.setErr(fmt.Errorf(\"bun: Bulk requires a slice, got %T\", q.model))\n\t\treturn q\n\t}\n\n\tset, err := q.updateSliceSet(q.db.fmter, model)\n\tif err != nil {\n\t\tq.setErr(err)\n\t\treturn q\n\t}\n\n\tvalues := q.db.NewValues(model)\n\tvalues.customValueQuery = q.customValueQuery\n\n\treturn q.With(\"_data\", values).\n\t\tModel(model).\n\t\tTableExpr(\"_data\").\n\t\tSet(set).\n\t\tWhere(q.updateSliceWhere(q.db.fmter, model))\n}\n\nfunc (q *UpdateQuery) updateSliceSet(\n\tfmter schema.Formatter, model *sliceTableModel,\n) (string, error) {\n\tfields, err := q.getDataFields()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar b []byte\n\tpos := len(b)\n\tfor _, field := range fields {\n\t\tif field.SkipUpdate() {\n\t\t\tcontinue\n\t\t}\n\t\tif len(b) != pos {\n\t\t\tb = append(b, \", \"...)\n\t\t\tpos = len(b)\n\t\t}\n\t\tif fmter.HasFeature(feature.UpdateMultiTable) {\n\t\t\tb = append(b, model.table.SQLAlias...)\n\t\t\tb = append(b, '.')\n\t\t}\n\t\tb = append(b, field.SQLName...)\n\t\tb = append(b, \" = _data.\"...)\n\t\tb = append(b, field.SQLName...)\n\t}\n\treturn internal.String(b), nil\n}\n\nfunc (q *UpdateQuery) updateSliceWhere(fmter schema.Formatter, model *sliceTableModel) string {\n\tvar b []byte\n\tfor i, pk := range model.table.PKs {\n\t\tif i > 0 {\n\t\t\tb = append(b, \" AND \"...)\n\t\t}\n\t\tif q.hasTableAlias(fmter) {\n\t\t\tb = append(b, model.table.SQLAlias...)\n\t\t} else {\n\t\t\tb = append(b, model.table.SQLName...)\n\t\t}\n\t\tb = append(b, '.')\n\t\tb = append(b, pk.SQLName...)\n\t\tb = append(b, \" = _data.\"...)\n\t\tb = append(b, pk.SQLName...)\n\t}\n\treturn internal.String(b)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) Scan(ctx context.Context, dest ...interface{}) error {\n\t_, err := q.scanOrExec(ctx, dest, true)\n\treturn err\n}\n\nfunc (q *UpdateQuery) Exec(ctx context.Context, dest ...interface{}) (sql.Result, error) {\n\treturn q.scanOrExec(ctx, dest, len(dest) > 0)\n}\n\nfunc (q *UpdateQuery) scanOrExec(\n\tctx context.Context, dest []interface{}, hasDest bool,\n) (sql.Result, error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.beforeUpdateHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Run append model hooks before generating the query.\n\tif err := q.beforeAppendModel(ctx, q); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Generate the query before checking hasReturning.\n\tqueryBytes, err := q.AppendQuery(q.db.fmter, q.db.makeQueryBytes())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuseScan := hasDest || (q.hasReturning() && q.hasFeature(feature.Returning|feature.Output))\n\tvar model Model\n\n\tif useScan {\n\t\tvar err error\n\t\tmodel, err = q.getModel(dest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tquery := internal.String(queryBytes)\n\n\tvar res sql.Result\n\n\tif useScan {\n\t\tres, err = q.scan(ctx, q, query, model, hasDest)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tres, err = q.exec(ctx, q, query)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif q.table != nil {\n\t\tif err := q.afterUpdateHook(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (q *UpdateQuery) beforeUpdateHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(BeforeUpdateHook); ok {\n\t\tif err := hook.BeforeUpdate(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (q *UpdateQuery) afterUpdateHook(ctx context.Context) error {\n\tif hook, ok := q.table.ZeroIface.(AfterUpdateHook); ok {\n\t\tif err := hook.AfterUpdate(ctx, q); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// FQN returns a fully qualified column name, for example, table_name.column_name or\n// table_alias.column_alias.\nfunc (q *UpdateQuery) FQN(column string) Ident {\n\tif q.table == nil {\n\t\tpanic(\"UpdateQuery.FQN requires a model\")\n\t}\n\tif q.hasTableAlias(q.db.fmter) {\n\t\treturn Ident(q.table.Alias + \".\" + column)\n\t}\n\treturn Ident(q.table.Name + \".\" + column)\n}\n\nfunc (q *UpdateQuery) hasTableAlias(fmter schema.Formatter) bool {\n\treturn fmter.HasFeature(feature.UpdateMultiTable | feature.UpdateTableAlias)\n}\n\nfunc (q *UpdateQuery) String() string {\n\tbuf, err := q.AppendQuery(q.db.Formatter(), nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn string(buf)\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) QueryBuilder() QueryBuilder {\n\treturn &updateQueryBuilder{q}\n}\n\nfunc (q *UpdateQuery) ApplyQueryBuilder(fn func(QueryBuilder) QueryBuilder) *UpdateQuery {\n\treturn fn(q.QueryBuilder()).Unwrap().(*UpdateQuery)\n}\n\ntype updateQueryBuilder struct {\n\t*UpdateQuery\n}\n\nfunc (q *updateQueryBuilder) WhereGroup(\n\tsep string, fn func(QueryBuilder) QueryBuilder,\n) QueryBuilder {\n\tq.UpdateQuery = q.UpdateQuery.WhereGroup(sep, func(qs *UpdateQuery) *UpdateQuery {\n\t\treturn fn(q).(*updateQueryBuilder).UpdateQuery\n\t})\n\treturn q\n}\n\nfunc (q *updateQueryBuilder) Where(query string, args ...interface{}) QueryBuilder {\n\tq.UpdateQuery.Where(query, args...)\n\treturn q\n}\n\nfunc (q *updateQueryBuilder) WhereOr(query string, args ...interface{}) QueryBuilder {\n\tq.UpdateQuery.WhereOr(query, args...)\n\treturn q\n}\n\nfunc (q *updateQueryBuilder) WhereDeleted() QueryBuilder {\n\tq.UpdateQuery.WhereDeleted()\n\treturn q\n}\n\nfunc (q *updateQueryBuilder) WhereAllWithDeleted() QueryBuilder {\n\tq.UpdateQuery.WhereAllWithDeleted()\n\treturn q\n}\n\nfunc (q *updateQueryBuilder) WherePK(cols ...string) QueryBuilder {\n\tq.UpdateQuery.WherePK(cols...)\n\treturn q\n}\n\nfunc (q *updateQueryBuilder) Unwrap() interface{} {\n\treturn q.UpdateQuery\n}\n\n//------------------------------------------------------------------------------\n\nfunc (q *UpdateQuery) UseIndex(indexes ...string) *UpdateQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addUseIndex(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *UpdateQuery) IgnoreIndex(indexes ...string) *UpdateQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addIgnoreIndex(indexes...)\n\t}\n\treturn q\n}\n\nfunc (q *UpdateQuery) ForceIndex(indexes ...string) *UpdateQuery {\n\tif q.db.dialect.Name() == dialect.MySQL {\n\t\tq.addForceIndex(indexes...)\n\t}\n\treturn q\n}\n"
        },
        {
          "name": "query_values.go",
          "type": "blob",
          "size": 4.4619140625,
          "content": "package bun\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype ValuesQuery struct {\n\tbaseQuery\n\tcustomValueQuery\n\n\twithOrder bool\n\tcomment   string\n}\n\nvar (\n\t_ Query                   = (*ValuesQuery)(nil)\n\t_ schema.NamedArgAppender = (*ValuesQuery)(nil)\n)\n\nfunc NewValuesQuery(db *DB, model interface{}) *ValuesQuery {\n\tq := &ValuesQuery{\n\t\tbaseQuery: baseQuery{\n\t\t\tdb:   db,\n\t\t\tconn: db.DB,\n\t\t},\n\t}\n\tq.setModel(model)\n\treturn q\n}\n\nfunc (q *ValuesQuery) Conn(db IConn) *ValuesQuery {\n\tq.setConn(db)\n\treturn q\n}\n\nfunc (q *ValuesQuery) Err(err error) *ValuesQuery {\n\tq.setErr(err)\n\treturn q\n}\n\nfunc (q *ValuesQuery) Column(columns ...string) *ValuesQuery {\n\tfor _, column := range columns {\n\t\tq.addColumn(schema.UnsafeIdent(column))\n\t}\n\treturn q\n}\n\n// Value overwrites model value for the column.\nfunc (q *ValuesQuery) Value(column string, expr string, args ...interface{}) *ValuesQuery {\n\tif q.table == nil {\n\t\tq.err = errNilModel\n\t\treturn q\n\t}\n\tq.addValue(q.table, column, expr, args)\n\treturn q\n}\n\nfunc (q *ValuesQuery) WithOrder() *ValuesQuery {\n\tq.withOrder = true\n\treturn q\n}\n\n// Comment adds a comment to the query, wrapped by /* ... */.\nfunc (q *ValuesQuery) Comment(comment string) *ValuesQuery {\n\tq.comment = comment\n\treturn q\n}\n\nfunc (q *ValuesQuery) AppendNamedArg(fmter schema.Formatter, b []byte, name string) ([]byte, bool) {\n\tswitch name {\n\tcase \"Columns\":\n\t\tbb, err := q.AppendColumns(fmter, b)\n\t\tif err != nil {\n\t\t\tq.setErr(err)\n\t\t\treturn b, true\n\t\t}\n\t\treturn bb, true\n\t}\n\treturn b, false\n}\n\n// AppendColumns appends the table columns. It is used by CTE.\nfunc (q *ValuesQuery) AppendColumns(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\tif q.model == nil {\n\t\treturn nil, errNilModel\n\t}\n\n\tif q.tableModel != nil {\n\t\tfields, err := q.getFields()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tb = appendColumns(b, \"\", fields)\n\n\t\tif q.withOrder {\n\t\t\tb = append(b, \", _order\"...)\n\t\t}\n\n\t\treturn b, nil\n\t}\n\n\tswitch model := q.model.(type) {\n\tcase *mapSliceModel:\n\t\treturn model.appendColumns(fmter, b)\n\t}\n\n\treturn nil, fmt.Errorf(\"bun: Values does not support %T\", q.model)\n}\n\nfunc (q *ValuesQuery) Operation() string {\n\treturn \"VALUES\"\n}\n\nfunc (q *ValuesQuery) AppendQuery(fmter schema.Formatter, b []byte) (_ []byte, err error) {\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\tif q.model == nil {\n\t\treturn nil, errNilModel\n\t}\n\n\tb = appendComment(b, q.comment)\n\n\tfmter = formatterWithModel(fmter, q)\n\n\tif q.tableModel != nil {\n\t\tfields, err := q.getFields()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn q.appendQuery(fmter, b, fields)\n\t}\n\n\tswitch model := q.model.(type) {\n\tcase *mapSliceModel:\n\t\treturn model.appendValues(fmter, b)\n\t}\n\n\treturn nil, fmt.Errorf(\"bun: Values does not support %T\", q.model)\n}\n\nfunc (q *ValuesQuery) appendQuery(\n\tfmter schema.Formatter,\n\tb []byte,\n\tfields []*schema.Field,\n) (_ []byte, err error) {\n\tb = append(b, \"VALUES \"...)\n\tif q.db.HasFeature(feature.ValuesRow) {\n\t\tb = append(b, \"ROW(\"...)\n\t} else {\n\t\tb = append(b, '(')\n\t}\n\n\tswitch model := q.tableModel.(type) {\n\tcase *structTableModel:\n\t\tb, err = q.appendValues(fmter, b, fields, model.strct)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif q.withOrder {\n\t\t\tb = append(b, \", \"...)\n\t\t\tb = strconv.AppendInt(b, 0, 10)\n\t\t}\n\tcase *sliceTableModel:\n\t\tslice := model.slice\n\t\tsliceLen := slice.Len()\n\t\tfor i := 0; i < sliceLen; i++ {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \"), \"...)\n\t\t\t\tif q.db.HasFeature(feature.ValuesRow) {\n\t\t\t\t\tb = append(b, \"ROW(\"...)\n\t\t\t\t} else {\n\t\t\t\t\tb = append(b, '(')\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tb, err = q.appendValues(fmter, b, fields, slice.Index(i))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tif q.withOrder {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t\tb = strconv.AppendInt(b, int64(i), 10)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"bun: Values does not support %T\", q.model)\n\t}\n\n\tb = append(b, ')')\n\n\treturn b, nil\n}\n\nfunc (q *ValuesQuery) appendValues(\n\tfmter schema.Formatter, b []byte, fields []*schema.Field, strct reflect.Value,\n) (_ []byte, err error) {\n\tisTemplate := fmter.IsNop()\n\tfor i, f := range fields {\n\t\tif i > 0 {\n\t\t\tb = append(b, \", \"...)\n\t\t}\n\n\t\tapp, ok := q.modelValues[f.Name]\n\t\tif ok {\n\t\t\tb, err = app.AppendQuery(fmter, b)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif isTemplate {\n\t\t\tb = append(b, '?')\n\t\t} else {\n\t\t\tb = f.AppendValue(fmter, b, indirect(strct))\n\t\t}\n\n\t\tif fmter.HasFeature(feature.DoubleColonCast) {\n\t\t\tb = append(b, \"::\"...)\n\t\t\tb = append(b, f.UserSQLType...)\n\t\t}\n\t}\n\treturn b, nil\n}\n"
        },
        {
          "name": "relation_join.go",
          "type": "blob",
          "size": 10.1123046875,
          "content": "package bun\n\nimport (\n\t\"context\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/uptrace/bun/dialect/feature\"\n\t\"github.com/uptrace/bun/internal\"\n\t\"github.com/uptrace/bun/schema\"\n)\n\ntype relationJoin struct {\n\tParent    *relationJoin\n\tBaseModel TableModel\n\tJoinModel TableModel\n\tRelation  *schema.Relation\n\n\tadditionalJoinOnConditions []schema.QueryWithArgs\n\n\tapply   func(*SelectQuery) *SelectQuery\n\tcolumns []schema.QueryWithArgs\n}\n\nfunc (j *relationJoin) applyTo(q *SelectQuery) {\n\tif j.apply == nil {\n\t\treturn\n\t}\n\n\tvar table *schema.Table\n\tvar columns []schema.QueryWithArgs\n\n\t// Save state.\n\ttable, q.table = q.table, j.JoinModel.Table()\n\tcolumns, q.columns = q.columns, nil\n\n\tq = j.apply(q)\n\n\t// Restore state.\n\tq.table = table\n\tj.columns, q.columns = q.columns, columns\n}\n\nfunc (j *relationJoin) Select(ctx context.Context, q *SelectQuery) error {\n\tswitch j.Relation.Type {\n\t}\n\tpanic(\"not reached\")\n}\n\nfunc (j *relationJoin) selectMany(ctx context.Context, q *SelectQuery) error {\n\tq = j.manyQuery(q)\n\tif q == nil {\n\t\treturn nil\n\t}\n\treturn q.Scan(ctx)\n}\n\nfunc (j *relationJoin) manyQuery(q *SelectQuery) *SelectQuery {\n\thasManyModel := newHasManyModel(j)\n\tif hasManyModel == nil {\n\t\treturn nil\n\t}\n\n\tq = q.Model(hasManyModel)\n\n\tvar where []byte\n\n\tif q.db.HasFeature(feature.CompositeIn) {\n\t\treturn j.manyQueryCompositeIn(where, q)\n\t}\n\treturn j.manyQueryMulti(where, q)\n}\n\nfunc (j *relationJoin) manyQueryCompositeIn(where []byte, q *SelectQuery) *SelectQuery {\n\tif len(j.Relation.JoinPKs) > 1 {\n\t\twhere = append(where, '(')\n\t}\n\twhere = appendColumns(where, j.JoinModel.Table().SQLAlias, j.Relation.JoinPKs)\n\tif len(j.Relation.JoinPKs) > 1 {\n\t\twhere = append(where, ')')\n\t}\n\twhere = append(where, \" IN (\"...)\n\twhere = appendChildValues(\n\t\tq.db.Formatter(),\n\t\twhere,\n\t\tj.JoinModel.rootValue(),\n\t\tj.JoinModel.parentIndex(),\n\t\tj.Relation.BasePKs,\n\t)\n\twhere = append(where, \")\"...)\n\tif len(j.additionalJoinOnConditions) > 0 {\n\t\twhere = append(where, \" AND \"...)\n\t\twhere = appendAdditionalJoinOnConditions(q.db.Formatter(), where, j.additionalJoinOnConditions)\n\t}\n\n\tq = q.Where(internal.String(where))\n\n\tif j.Relation.PolymorphicField != nil {\n\t\tq = q.Where(\"? = ?\", j.Relation.PolymorphicField.SQLName, j.Relation.PolymorphicValue)\n\t}\n\n\tj.applyTo(q)\n\tq = q.Apply(j.hasManyColumns)\n\n\treturn q\n}\n\nfunc (j *relationJoin) manyQueryMulti(where []byte, q *SelectQuery) *SelectQuery {\n\twhere = appendMultiValues(\n\t\tq.db.Formatter(),\n\t\twhere,\n\t\tj.JoinModel.rootValue(),\n\t\tj.JoinModel.parentIndex(),\n\t\tj.Relation.BasePKs,\n\t\tj.Relation.JoinPKs,\n\t\tj.JoinModel.Table().SQLAlias,\n\t)\n\n\tq = q.Where(internal.String(where))\n\n\tif len(j.additionalJoinOnConditions) > 0 {\n\t\tq = q.Where(internal.String(appendAdditionalJoinOnConditions(q.db.Formatter(), []byte{}, j.additionalJoinOnConditions)))\n\t}\n\n\tif j.Relation.PolymorphicField != nil {\n\t\tq = q.Where(\"? = ?\", j.Relation.PolymorphicField.SQLName, j.Relation.PolymorphicValue)\n\t}\n\n\tj.applyTo(q)\n\tq = q.Apply(j.hasManyColumns)\n\n\treturn q\n}\n\nfunc (j *relationJoin) hasManyColumns(q *SelectQuery) *SelectQuery {\n\tb := make([]byte, 0, 32)\n\n\tjoinTable := j.JoinModel.Table()\n\tif len(j.columns) > 0 {\n\t\tfor i, col := range j.columns {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\n\t\t\tif col.Args == nil {\n\t\t\t\tif field, ok := joinTable.FieldMap[col.Query]; ok {\n\t\t\t\t\tb = append(b, joinTable.SQLAlias...)\n\t\t\t\t\tb = append(b, '.')\n\t\t\t\t\tb = append(b, field.SQLName...)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tb, err = col.AppendQuery(q.db.fmter, b)\n\t\t\tif err != nil {\n\t\t\t\tq.setErr(err)\n\t\t\t\treturn q\n\t\t\t}\n\n\t\t}\n\t} else {\n\t\tb = appendColumns(b, joinTable.SQLAlias, joinTable.Fields)\n\t}\n\n\tq = q.ColumnExpr(internal.String(b))\n\n\treturn q\n}\n\nfunc (j *relationJoin) selectM2M(ctx context.Context, q *SelectQuery) error {\n\tq = j.m2mQuery(q)\n\tif q == nil {\n\t\treturn nil\n\t}\n\treturn q.Scan(ctx)\n}\n\nfunc (j *relationJoin) m2mQuery(q *SelectQuery) *SelectQuery {\n\tfmter := q.db.fmter\n\n\tm2mModel := newM2MModel(j)\n\tif m2mModel == nil {\n\t\treturn nil\n\t}\n\tq = q.Model(m2mModel)\n\n\tindex := j.JoinModel.parentIndex()\n\n\tif j.Relation.M2MTable != nil {\n\t\t// We only need base pks to park joined models to the base model.\n\t\tfields := j.Relation.M2MBasePKs\n\n\t\tb := make([]byte, 0, len(fields))\n\t\tb = appendColumns(b, j.Relation.M2MTable.SQLAlias, fields)\n\n\t\tq = q.ColumnExpr(internal.String(b))\n\t}\n\n\t//nolint\n\tvar join []byte\n\tjoin = append(join, \"JOIN \"...)\n\tjoin = fmter.AppendQuery(join, string(j.Relation.M2MTable.SQLName))\n\tjoin = append(join, \" AS \"...)\n\tjoin = append(join, j.Relation.M2MTable.SQLAlias...)\n\tjoin = append(join, \" ON (\"...)\n\tfor i, col := range j.Relation.M2MBasePKs {\n\t\tif i > 0 {\n\t\t\tjoin = append(join, \", \"...)\n\t\t}\n\t\tjoin = append(join, j.Relation.M2MTable.SQLAlias...)\n\t\tjoin = append(join, '.')\n\t\tjoin = append(join, col.SQLName...)\n\t}\n\tjoin = append(join, \") IN (\"...)\n\tjoin = appendChildValues(fmter, join, j.BaseModel.rootValue(), index, j.Relation.BasePKs)\n\tjoin = append(join, \")\"...)\n\n\tif len(j.additionalJoinOnConditions) > 0 {\n\t\tjoin = append(join, \" AND \"...)\n\t\tjoin = appendAdditionalJoinOnConditions(fmter, join, j.additionalJoinOnConditions)\n\t}\n\n\tq = q.Join(internal.String(join))\n\n\tjoinTable := j.JoinModel.Table()\n\tfor i, m2mJoinField := range j.Relation.M2MJoinPKs {\n\t\tjoinField := j.Relation.JoinPKs[i]\n\t\tq = q.Where(\"?.? = ?.?\",\n\t\t\tjoinTable.SQLAlias, joinField.SQLName,\n\t\t\tj.Relation.M2MTable.SQLAlias, m2mJoinField.SQLName)\n\t}\n\n\tj.applyTo(q)\n\tq = q.Apply(j.hasManyColumns)\n\n\treturn q\n}\n\nfunc (j *relationJoin) hasParent() bool {\n\tif j.Parent != nil {\n\t\tswitch j.Parent.Relation.Type {\n\t\tcase schema.HasOneRelation, schema.BelongsToRelation:\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (j *relationJoin) appendAlias(fmter schema.Formatter, b []byte) []byte {\n\tquote := fmter.IdentQuote()\n\n\tb = append(b, quote)\n\tb = appendAlias(b, j)\n\tb = append(b, quote)\n\treturn b\n}\n\nfunc (j *relationJoin) appendAliasColumn(fmter schema.Formatter, b []byte, column string) []byte {\n\tquote := fmter.IdentQuote()\n\n\tb = append(b, quote)\n\tb = appendAlias(b, j)\n\tb = append(b, \"__\"...)\n\tb = append(b, column...)\n\tb = append(b, quote)\n\treturn b\n}\n\nfunc (j *relationJoin) appendBaseAlias(fmter schema.Formatter, b []byte) []byte {\n\tquote := fmter.IdentQuote()\n\n\tif j.hasParent() {\n\t\tb = append(b, quote)\n\t\tb = appendAlias(b, j.Parent)\n\t\tb = append(b, quote)\n\t\treturn b\n\t}\n\treturn append(b, j.BaseModel.Table().SQLAlias...)\n}\n\nfunc (j *relationJoin) appendSoftDelete(\n\tfmter schema.Formatter, b []byte, flags internal.Flag,\n) []byte {\n\tb = append(b, '.')\n\n\tfield := j.JoinModel.Table().SoftDeleteField\n\tb = append(b, field.SQLName...)\n\n\tif field.IsPtr || field.NullZero {\n\t\tif flags.Has(deletedFlag) {\n\t\t\tb = append(b, \" IS NOT NULL\"...)\n\t\t} else {\n\t\t\tb = append(b, \" IS NULL\"...)\n\t\t}\n\t} else {\n\t\tif flags.Has(deletedFlag) {\n\t\t\tb = append(b, \" != \"...)\n\t\t} else {\n\t\t\tb = append(b, \" = \"...)\n\t\t}\n\t\tb = fmter.Dialect().AppendTime(b, time.Time{})\n\t}\n\n\treturn b\n}\n\nfunc appendAlias(b []byte, j *relationJoin) []byte {\n\tif j.hasParent() {\n\t\tb = appendAlias(b, j.Parent)\n\t\tb = append(b, \"__\"...)\n\t}\n\tb = append(b, j.Relation.Field.Name...)\n\treturn b\n}\n\nfunc (j *relationJoin) appendHasOneJoin(\n\tfmter schema.Formatter, b []byte, q *SelectQuery,\n) (_ []byte, err error) {\n\tisSoftDelete := j.JoinModel.Table().SoftDeleteField != nil && !q.flags.Has(allWithDeletedFlag)\n\n\tb = append(b, \"LEFT JOIN \"...)\n\tb = fmter.AppendQuery(b, string(j.JoinModel.Table().SQLNameForSelects))\n\tb = append(b, \" AS \"...)\n\tb = j.appendAlias(fmter, b)\n\n\tb = append(b, \" ON \"...)\n\n\tb = append(b, '(')\n\tfor i, baseField := range j.Relation.BasePKs {\n\t\tif i > 0 {\n\t\t\tb = append(b, \" AND \"...)\n\t\t}\n\t\tb = j.appendAlias(fmter, b)\n\t\tb = append(b, '.')\n\t\tb = append(b, j.Relation.JoinPKs[i].SQLName...)\n\t\tb = append(b, \" = \"...)\n\t\tb = j.appendBaseAlias(fmter, b)\n\t\tb = append(b, '.')\n\t\tb = append(b, baseField.SQLName...)\n\t}\n\tb = append(b, ')')\n\n\tif isSoftDelete {\n\t\tb = append(b, \" AND \"...)\n\t\tb = j.appendAlias(fmter, b)\n\t\tb = j.appendSoftDelete(fmter, b, q.flags)\n\t}\n\n\tif len(j.additionalJoinOnConditions) > 0 {\n\t\tb = append(b, \" AND \"...)\n\t\tb = appendAdditionalJoinOnConditions(fmter, b, j.additionalJoinOnConditions)\n\t}\n\n\treturn b, nil\n}\n\nfunc appendChildValues(\n\tfmter schema.Formatter, b []byte, v reflect.Value, index []int, fields []*schema.Field,\n) []byte {\n\tseen := make(map[string]struct{})\n\twalk(v, index, func(v reflect.Value) {\n\t\tstart := len(b)\n\n\t\tif len(fields) > 1 {\n\t\t\tb = append(b, '(')\n\t\t}\n\t\tfor i, f := range fields {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \", \"...)\n\t\t\t}\n\t\t\tb = f.AppendValue(fmter, b, v)\n\t\t}\n\t\tif len(fields) > 1 {\n\t\t\tb = append(b, ')')\n\t\t}\n\t\tb = append(b, \", \"...)\n\n\t\tif _, ok := seen[string(b[start:])]; ok {\n\t\t\tb = b[:start]\n\t\t} else {\n\t\t\tseen[string(b[start:])] = struct{}{}\n\t\t}\n\t})\n\tif len(seen) > 0 {\n\t\tb = b[:len(b)-2] // trim \", \"\n\t}\n\treturn b\n}\n\n// appendMultiValues is an alternative to appendChildValues that doesn't use the sql keyword ID\n// but instead uses old style ((k1=v1) AND (k2=v2)) OR (...) conditions.\nfunc appendMultiValues(\n\tfmter schema.Formatter, b []byte, v reflect.Value, index []int, baseFields, joinFields []*schema.Field, joinTable schema.Safe,\n) []byte {\n\t// This is based on a mix of appendChildValues and query_base.appendColumns\n\n\t// These should never mismatch in length but nice to know if it does\n\tif len(joinFields) != len(baseFields) {\n\t\tpanic(\"not reached\")\n\t}\n\n\t// walk the relations\n\tb = append(b, '(')\n\tseen := make(map[string]struct{})\n\twalk(v, index, func(v reflect.Value) {\n\t\tstart := len(b)\n\t\tfor i, f := range baseFields {\n\t\t\tif i > 0 {\n\t\t\t\tb = append(b, \" AND \"...)\n\t\t\t}\n\t\t\tif len(baseFields) > 1 {\n\t\t\t\tb = append(b, '(')\n\t\t\t}\n\t\t\t// Field name\n\t\t\tb = append(b, joinTable...)\n\t\t\tb = append(b, '.')\n\t\t\tb = append(b, []byte(joinFields[i].SQLName)...)\n\n\t\t\t// Equals value\n\t\t\tb = append(b, '=')\n\t\t\tb = f.AppendValue(fmter, b, v)\n\t\t\tif len(baseFields) > 1 {\n\t\t\t\tb = append(b, ')')\n\t\t\t}\n\t\t}\n\n\t\tb = append(b, \") OR (\"...)\n\n\t\tif _, ok := seen[string(b[start:])]; ok {\n\t\t\tb = b[:start]\n\t\t} else {\n\t\t\tseen[string(b[start:])] = struct{}{}\n\t\t}\n\t})\n\tif len(seen) > 0 {\n\t\tb = b[:len(b)-6] // trim \") OR (\"\n\t}\n\tb = append(b, ')')\n\treturn b\n}\n\nfunc appendAdditionalJoinOnConditions(\n\tfmter schema.Formatter, b []byte, conditions []schema.QueryWithArgs,\n) []byte {\n\tfor i, cond := range conditions {\n\t\tif i > 0 {\n\t\t\tb = append(b, \" AND \"...)\n\t\t}\n\t\tb = fmter.AppendQuery(b, cond.Query, cond.Args...)\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "schema",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 1.6923828125,
          "content": "package bun\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\nfunc indirect(v reflect.Value) reflect.Value {\n\tswitch v.Kind() {\n\tcase reflect.Interface:\n\t\treturn indirect(v.Elem())\n\tcase reflect.Ptr:\n\t\treturn v.Elem()\n\tdefault:\n\t\treturn v\n\t}\n}\n\nfunc walk(v reflect.Value, index []int, fn func(reflect.Value)) {\n\tv = reflect.Indirect(v)\n\tswitch v.Kind() {\n\tcase reflect.Slice:\n\t\tsliceLen := v.Len()\n\t\tfor i := 0; i < sliceLen; i++ {\n\t\t\tvisitField(v.Index(i), index, fn)\n\t\t}\n\tdefault:\n\t\tvisitField(v, index, fn)\n\t}\n}\n\nfunc visitField(v reflect.Value, index []int, fn func(reflect.Value)) {\n\tv = reflect.Indirect(v)\n\tif len(index) > 0 {\n\t\tv = v.Field(index[0])\n\t\tif v.Kind() == reflect.Ptr && v.IsNil() {\n\t\t\treturn\n\t\t}\n\t\twalk(v, index[1:], fn)\n\t} else {\n\t\tfn(v)\n\t}\n}\n\nfunc typeByIndex(t reflect.Type, index []int) reflect.Type {\n\tfor _, x := range index {\n\t\tswitch t.Kind() {\n\t\tcase reflect.Ptr:\n\t\t\tt = t.Elem()\n\t\tcase reflect.Slice:\n\t\t\tt = indirectType(t.Elem())\n\t\t}\n\t\tt = t.Field(x).Type\n\t}\n\treturn indirectType(t)\n}\n\nfunc indirectType(t reflect.Type) reflect.Type {\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn t\n}\n\nfunc sliceElemType(v reflect.Value) reflect.Type {\n\telemType := v.Type().Elem()\n\tif elemType.Kind() == reflect.Interface && v.Len() > 0 {\n\t\treturn indirect(v.Index(0).Elem()).Type()\n\t}\n\treturn indirectType(elemType)\n}\n\n// appendComment adds comment in the header of the query into buffer\nfunc appendComment(b []byte, name string) []byte {\n\tif name == \"\" {\n\t\treturn b\n\t}\n\tname = strings.Map(func(r rune) rune {\n\t\tif r == '\\x00' {\n\t\t\treturn -1\n\t\t}\n\t\treturn r\n\t}, name)\n\tname = strings.ReplaceAll(name, `/*`, `/\\*`)\n\tname = strings.ReplaceAll(name, `*/`, `*\\/`)\n\treturn append(b, fmt.Sprintf(\"/* %s */ \", name)...)\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 0.984375,
          "content": "package bun\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc Test_appendComment(t *testing.T) {\n\tt.Run(\"ordinary comment\", func(t *testing.T) {\n\t\tvar res []byte\n\t\tc := \"comment\"\n\n\t\ts := appendComment(res, c)\n\t\trequire.Equal(t, \"/* comment */ \", string(s))\n\t})\n\n\tt.Run(\"only open sequence\", func(t *testing.T) {\n\t\tvar res []byte\n\t\tc := \"/* comment\"\n\n\t\ts := appendComment(res, c)\n\t\trequire.Equal(t, \"/* /\\\\* comment */ \", string(s))\n\t})\n\n\tt.Run(\"only close sequence\", func(t *testing.T) {\n\t\tvar res []byte\n\t\tc := \"comment */\"\n\n\t\ts := appendComment(res, c)\n\t\trequire.Equal(t, \"/* comment *\\\\/ */ \", string(s))\n\t})\n\n\tt.Run(\"open and close sequences\", func(t *testing.T) {\n\t\tvar res []byte\n\t\tc := \"/* comment */\"\n\n\t\ts := appendComment(res, c)\n\t\trequire.Equal(t, \"/* /\\\\* comment *\\\\/ */ \", string(s))\n\t})\n\n\tt.Run(\"zero bytes\", func(t *testing.T) {\n\t\tvar res []byte\n\t\tc := string([]byte{'*', 0, 0, 0, 0, 0, '/'})\n\n\t\ts := appendComment(res, c)\n\t\trequire.Equal(t, \"/* *\\\\/ */ \", string(s))\n\t})\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.095703125,
          "content": "package bun\n\n// Version is the current release version.\nfunc Version() string {\n\treturn \"1.2.8\"\n}\n"
        }
      ]
    }
  ]
}